Title: PHP UK Conference 2014 - Morgan Tocker - Locking And Concurrency Control
Publication date: 2014-03-24
Playlist: PHP UK Conference 2014
Description: 
	When you use a RDBMS, it offers a number of features to protect data integrity and protect against concurrent modification of data. Concepts covered in this session include table/row locks, MVCC, deadlocks & lock waits, transactions and isolation levels. Attendees will also get a better understanding of various database errors, and know how they are expected to be handled by applications. Examples will use MySQL 5.6, but cover theory that is 90% applicable to all databases.
Captions: 
	00:00:04,430 --> 00:00:11,309
how's it going audio I think it's

00:00:07,680 --> 00:00:14,160
working perfectly excellent so what I

00:00:11,309 --> 00:00:16,199
wanted to talk about today is you now

00:00:14,160 --> 00:00:19,890
have a choice of how you choose to store

00:00:16,199 --> 00:00:21,930
data and we're familiar with relational

00:00:19,890 --> 00:00:25,080
databases they're the technology

00:00:21,930 --> 00:00:27,539
incumbent um being around for so long

00:00:25,080 --> 00:00:29,279
sometimes it's hard to remember some of

00:00:27,539 --> 00:00:31,260
those founding principles that they had

00:00:29,279 --> 00:00:33,540
and some of those behavior

00:00:31,260 --> 00:00:36,480
characteristics that they intend to have

00:00:33,540 --> 00:00:38,910
in how you access your data and make

00:00:36,480 --> 00:00:41,940
sure that it's safe so that the talk

00:00:38,910 --> 00:00:44,309
that I'm giving i will use mysql for

00:00:41,940 --> 00:00:46,469
examples obviously i work on the mysql

00:00:44,309 --> 00:00:48,800
product but it should be applicable for

00:00:46,469 --> 00:00:50,969
ninety percent of old databases I

00:00:48,800 --> 00:00:53,699
wouldn't necessarily point out whether

00:00:50,969 --> 00:00:55,680
it's exceptions are but I if you see one

00:00:53,699 --> 00:00:57,059
in you wanna ask you a question I love

00:00:55,680 --> 00:00:58,410
it if you ask questions during the talk

00:00:57,059 --> 00:01:01,850
I think it will make it nice and

00:00:58,410 --> 00:01:05,519
interactive so we're talking about

00:01:01,850 --> 00:01:08,729
really under concurrency under multi

00:01:05,519 --> 00:01:10,380
users accessing a system what unsafe

00:01:08,729 --> 00:01:15,240
situations can happen and how to

00:01:10,380 --> 00:01:17,970
databases so to prevent that quick intro

00:01:15,240 --> 00:01:20,340
slide are not so relevant today but if I

00:01:17,970 --> 00:01:22,590
do mention any dates of any upcoming

00:01:20,340 --> 00:01:29,520
features that we've announced with MySQL

00:01:22,590 --> 00:01:32,159
it should be informational only and just

00:01:29,520 --> 00:01:33,659
two minutes on on oracle we're

00:01:32,159 --> 00:01:35,640
celebrating out our fourth birthday

00:01:33,659 --> 00:01:40,490
where our fourth birthday just last

00:01:35,640 --> 00:01:43,020
month of being the steward from mysql

00:01:40,490 --> 00:01:44,869
very proud these are the things that

00:01:43,020 --> 00:01:48,170
we've done in the last four years we've

00:01:44,869 --> 00:01:52,409
released two major versions of MySQL

00:01:48,170 --> 00:01:55,770
mysql 55 and mysql 56 tomorrow same time

00:01:52,409 --> 00:01:58,110
i'll be giving a talk on mysql fix 56

00:01:55,770 --> 00:02:00,119
describing how it's it's really good to

00:01:58,110 --> 00:02:01,439
be able to use in an operational

00:02:00,119 --> 00:02:04,649
environment there's a lot more

00:02:01,439 --> 00:02:06,600
diagnostic information and it has things

00:02:04,649 --> 00:02:09,090
like online ddl so you can add indexes

00:02:06,600 --> 00:02:13,590
without blocking users from writing to

00:02:09,090 --> 00:02:15,840
your database also under Oracle them

00:02:13,590 --> 00:02:18,569
I skilled team has doubled in size from

00:02:15,840 --> 00:02:20,610
what it was the Sun acquisition we now

00:02:18,569 --> 00:02:26,550
have hundreds of people working on mysql

00:02:20,610 --> 00:02:28,319
and the QA team alone is tripled but for

00:02:26,550 --> 00:02:29,730
today what we're going to be talking

00:02:28,319 --> 00:02:32,160
about is they said those database

00:02:29,730 --> 00:02:34,709
characteristics broken down into an

00:02:32,160 --> 00:02:37,530
agenda of really just full points and

00:02:34,709 --> 00:02:41,099
the end of it I'll try and recap and say

00:02:37,530 --> 00:02:44,549
what your responsibilities should be as

00:02:41,099 --> 00:02:46,709
an application developer the live demo

00:02:44,549 --> 00:02:48,569
point number two is the the one that I'm

00:02:46,709 --> 00:02:51,329
a little bit scared about tempting that

00:02:48,569 --> 00:02:52,739
the demo gods but I think it's the best

00:02:51,329 --> 00:02:54,480
way to demonstrate it will have a

00:02:52,739 --> 00:02:56,190
multi-user system and we'll try and see

00:02:54,480 --> 00:03:00,329
some of these these areas of these

00:02:56,190 --> 00:03:05,280
situations arise so let's let's start

00:03:00,329 --> 00:03:06,959
off with table locks roll oxen MVCC so

00:03:05,280 --> 00:03:10,110
let's say that we had a relational

00:03:06,959 --> 00:03:11,849
database system that's called an

00:03:10,110 --> 00:03:15,329
accounting system this is the easiest

00:03:11,849 --> 00:03:17,850
way to draw a demonstration and in my

00:03:15,329 --> 00:03:21,380
customer accounting system here I have

00:03:17,850 --> 00:03:25,410
three tables a table for customers

00:03:21,380 --> 00:03:28,170
customers have invoices and the invoices

00:03:25,410 --> 00:03:29,459
have items and I've tried to color code

00:03:28,170 --> 00:03:32,489
this a little bit so that you can see

00:03:29,459 --> 00:03:35,180
their relationship where invoice number

00:03:32,489 --> 00:03:38,880
one belongs to customer number one and

00:03:35,180 --> 00:03:42,239
has invoice item number one of invoice

00:03:38,880 --> 00:03:44,069
ID 1 and what I want to do on this

00:03:42,239 --> 00:03:46,500
customer accounting system is I want to

00:03:44,069 --> 00:03:48,239
do an operation and the simplest

00:03:46,500 --> 00:03:51,480
operation that I can do is I can do a

00:03:48,239 --> 00:03:52,500
backup so I'm going to start my backup

00:03:51,480 --> 00:03:55,230
and I'm going to read through the

00:03:52,500 --> 00:03:57,959
customer table and then I finished

00:03:55,230 --> 00:03:59,609
reading the customer table and I'm going

00:03:57,959 --> 00:04:02,669
to read through and stop backing up the

00:03:59,609 --> 00:04:03,959
invoice table and i'm still reading the

00:04:02,669 --> 00:04:06,900
invoice table let's say it's a very

00:04:03,959 --> 00:04:09,690
large table it's the concurrent user

00:04:06,900 --> 00:04:13,290
system while I'm reading the invoice

00:04:09,690 --> 00:04:17,609
table somebody else does a modification

00:04:13,290 --> 00:04:21,359
and they insert a new customer customer

00:04:17,609 --> 00:04:24,690
number four and they create an invoice

00:04:21,359 --> 00:04:28,460
for customer number for that has some

00:04:24,690 --> 00:04:30,690
invoice items associated with

00:04:28,460 --> 00:04:32,940
so I'd already backed up the customer

00:04:30,690 --> 00:04:35,270
table I'm in the process of backing up

00:04:32,940 --> 00:04:39,180
the invoice table so that's let's finish

00:04:35,270 --> 00:04:41,220
backing up that invoice table and then I

00:04:39,180 --> 00:04:45,690
want to finish the invoice table I back

00:04:41,220 --> 00:04:48,360
up the invoice items table and then as

00:04:45,690 --> 00:04:53,040
far as I'm concerned my backup is

00:04:48,360 --> 00:04:55,410
complete or is it everyone see the the

00:04:53,040 --> 00:04:58,800
problem here what happened was is that I

00:04:55,410 --> 00:05:00,300
read through the customer table I finish

00:04:58,800 --> 00:05:02,460
with it I didn't see customer number

00:05:00,300 --> 00:05:05,070
four and I started backing up through

00:05:02,460 --> 00:05:08,160
the invoice table so if I were to do a

00:05:05,070 --> 00:05:11,760
restore of this system what was really

00:05:08,160 --> 00:05:15,930
backed up was not everything we were

00:05:11,760 --> 00:05:17,790
missing this essential row here so of

00:05:15,930 --> 00:05:19,380
course if you use something like MySQL

00:05:17,790 --> 00:05:21,630
or use another relational database they

00:05:19,380 --> 00:05:23,880
don't allow this situation happen this

00:05:21,630 --> 00:05:27,000
is an example of a naive situation that

00:05:23,880 --> 00:05:29,550
they have to prevent from happening why

00:05:27,000 --> 00:05:31,680
this is problematic is that if we were

00:05:29,550 --> 00:05:34,770
to restore from backup obviously what

00:05:31,680 --> 00:05:36,500
could happen is the the next user that

00:05:34,770 --> 00:05:38,970
gets inserted into the customers table

00:05:36,500 --> 00:05:40,410
they end up having these corresponding

00:05:38,970 --> 00:05:43,290
entries already sitting there in in

00:05:40,410 --> 00:05:48,740
those other tables so there's like this

00:05:43,290 --> 00:05:52,290
security / data privacy concern um so I

00:05:48,740 --> 00:05:54,090
sure this was a backup backup as an easy

00:05:52,290 --> 00:05:57,510
way to show you this potential race

00:05:54,090 --> 00:06:00,930
condition that exists and the way that

00:05:57,510 --> 00:06:02,280
the the database solves this problem is

00:06:00,930 --> 00:06:05,100
they say whenever you do an operation

00:06:02,280 --> 00:06:07,200
and actually the type of operation

00:06:05,100 --> 00:06:09,480
doesn't matter mine was a backup but it

00:06:07,200 --> 00:06:12,690
could be just a simple select that

00:06:09,480 --> 00:06:15,420
operation it has to represent one single

00:06:12,690 --> 00:06:17,880
point in time it actually doesn't matter

00:06:15,420 --> 00:06:20,640
when it could be the start or it could

00:06:17,880 --> 00:06:23,460
be the end so you could have a backup

00:06:20,640 --> 00:06:24,990
that nobody can make any changes while

00:06:23,460 --> 00:06:26,940
I'm doing the back up and then that

00:06:24,990 --> 00:06:28,650
might kind of represent the start or you

00:06:26,940 --> 00:06:30,090
could have some roll forward segment to

00:06:28,650 --> 00:06:31,680
be able to catch all those changes that

00:06:30,090 --> 00:06:33,570
happen while you're backing up actually

00:06:31,680 --> 00:06:36,330
doesn't matter what matters is that it's

00:06:33,570 --> 00:06:37,530
a single point in time and the other

00:06:36,330 --> 00:06:40,200
thing that doesn't matter as I said it's

00:06:37,530 --> 00:06:41,009
not necessarily just a backup anything

00:06:40,200 --> 00:06:44,279
is supposed

00:06:41,009 --> 00:06:46,199
to represent a single point in time so

00:06:44,279 --> 00:06:48,719
that's the the naive case let's look at

00:06:46,199 --> 00:06:50,849
how something like the myosin storage

00:06:48,719 --> 00:06:54,029
engine from MySQL would prevent against

00:06:50,849 --> 00:06:57,779
this race condition happening so we want

00:06:54,029 --> 00:07:01,199
to do a backup what do we do BAM we lock

00:06:57,779 --> 00:07:02,969
all tables we say other people they can

00:07:01,199 --> 00:07:04,949
read data they can read this this

00:07:02,969 --> 00:07:07,080
information if they want but they can't

00:07:04,949 --> 00:07:08,669
write to it if they write to it we could

00:07:07,080 --> 00:07:11,159
get in that situation that we just did

00:07:08,669 --> 00:07:12,719
not want to happen we know what we want

00:07:11,159 --> 00:07:15,240
to touch we want to touch all of these

00:07:12,719 --> 00:07:17,610
tables so we need to agree to lock all

00:07:15,240 --> 00:07:19,319
those tables in advance and if you use

00:07:17,610 --> 00:07:21,629
something like MySQL dump it will do

00:07:19,319 --> 00:07:23,069
this and then when you've required all

00:07:21,629 --> 00:07:25,529
those locks then you can safely read

00:07:23,069 --> 00:07:29,189
through now you can get all that data

00:07:25,529 --> 00:07:30,870
and you get a single point in time the

00:07:29,189 --> 00:07:32,279
point in time represents both the start

00:07:30,870 --> 00:07:34,050
and the end of the backup because

00:07:32,279 --> 00:07:37,649
nobody's doing anything you're the only

00:07:34,050 --> 00:07:39,619
one that has access to that system how

00:07:37,649 --> 00:07:42,539
does this feel like for concurrency

00:07:39,619 --> 00:07:45,569
while readers can co-exist but writers

00:07:42,539 --> 00:07:47,219
can't there just forbidden if you use

00:07:45,569 --> 00:07:49,110
something like MySQL dump it will

00:07:47,219 --> 00:07:52,770
responsibly lock all the tables and

00:07:49,110 --> 00:07:55,139
events if you do a single query on a

00:07:52,770 --> 00:07:57,059
single table it will lock the table

00:07:55,139 --> 00:07:58,830
without you having to explicitly ask for

00:07:57,059 --> 00:08:01,559
it it has this table overlocking

00:07:58,830 --> 00:08:04,259
internally so this is one way of solving

00:08:01,559 --> 00:08:05,729
this problem let's look at another way

00:08:04,259 --> 00:08:07,709
of solving this problem and let's look

00:08:05,729 --> 00:08:10,050
at the inner diva storage engine for

00:08:07,709 --> 00:08:13,289
mysql and actually most other databases

00:08:10,050 --> 00:08:16,189
behave a little bit closer to this what

00:08:13,289 --> 00:08:18,839
we have here is that the same data but

00:08:16,189 --> 00:08:22,769
in the row header there's some hidden

00:08:18,839 --> 00:08:25,409
metadata a couple of extra columns where

00:08:22,769 --> 00:08:28,319
we have a transaction ID and we have a

00:08:25,409 --> 00:08:30,870
rollback pointer hidden met it out and

00:08:28,319 --> 00:08:33,120
i'll show how these is work in a second

00:08:30,870 --> 00:08:35,519
but that the transaction ID is the

00:08:33,120 --> 00:08:37,440
important point here what it is it's

00:08:35,519 --> 00:08:39,659
similar to you know when you go to the

00:08:37,440 --> 00:08:41,909
DMV or the deli you get allocated a

00:08:39,659 --> 00:08:45,180
ticket and that's the ticket that you

00:08:41,909 --> 00:08:46,740
only be served with it's a monotonic

00:08:45,180 --> 00:08:49,560
number which means that it just only

00:08:46,740 --> 00:08:52,339
advances everybody gets allocated a

00:08:49,560 --> 00:08:54,630
ticket so here we can see that our

00:08:52,339 --> 00:08:57,960
initial data was ticket now

00:08:54,630 --> 00:08:59,820
123 and our modification that happened

00:08:57,960 --> 00:09:05,370
partway through our operation was ticket

00:08:59,820 --> 00:09:08,160
number 401 this hidden metadata so

00:09:05,370 --> 00:09:09,660
that's uh that's actually I let's get

00:09:08,160 --> 00:09:14,280
the slide that's sure what happens when

00:09:09,660 --> 00:09:16,080
we do the back up we read through and we

00:09:14,280 --> 00:09:19,890
cover our eyes and we say I'm not going

00:09:16,080 --> 00:09:22,290
to see a number greater than 394 because

00:09:19,890 --> 00:09:24,630
my back up it was running his ticket

00:09:22,290 --> 00:09:27,600
number 394 so anyone inserted new data

00:09:24,630 --> 00:09:30,120
and they inserted us a ticket number 401

00:09:27,600 --> 00:09:32,670
I'm just going to skip it I'm going to

00:09:30,120 --> 00:09:34,580
completely ignore it and actually if I

00:09:32,670 --> 00:09:36,810
have to see a previous version of that

00:09:34,580 --> 00:09:38,610
the data this is a technical

00:09:36,810 --> 00:09:40,680
implementation where the number is

00:09:38,610 --> 00:09:42,510
higher than what I expect I can follow a

00:09:40,680 --> 00:09:44,580
link to in some internal space called on

00:09:42,510 --> 00:09:46,980
do to be able to find earlier versions

00:09:44,580 --> 00:09:51,120
of rows and there might be many editions

00:09:46,980 --> 00:09:54,210
of the same data in this database

00:09:51,120 --> 00:09:58,950
management system many generations of a

00:09:54,210 --> 00:10:00,690
row so this algorithm where we keep this

00:09:58,950 --> 00:10:02,730
extra metadata and we keep multiple

00:10:00,690 --> 00:10:06,060
versions of a row so that we can read

00:10:02,730 --> 00:10:08,850
through here means that we don't block

00:10:06,060 --> 00:10:10,800
writers because readers can get that

00:10:08,850 --> 00:10:13,470
single point in time that consistent

00:10:10,800 --> 00:10:15,990
view just by paying attention to these

00:10:13,470 --> 00:10:17,850
coordinates all these ticket numbers and

00:10:15,990 --> 00:10:21,150
it's called multi version concurrency

00:10:17,850 --> 00:10:23,250
control it's really nice because reads

00:10:21,150 --> 00:10:25,770
can happen and rights can happen at the

00:10:23,250 --> 00:10:28,290
same time readers don't actually set any

00:10:25,770 --> 00:10:30,860
locks they just see older versions of

00:10:28,290 --> 00:10:33,570
the same data and it actually someone's

00:10:30,860 --> 00:10:35,160
held a lock while they write modify

00:10:33,570 --> 00:10:36,750
something link we don't have to pay

00:10:35,160 --> 00:10:38,280
attention to that lock either because we

00:10:36,750 --> 00:10:42,210
can just look at a previous version of

00:10:38,280 --> 00:10:46,400
the data it's this context really

00:10:42,210 --> 00:10:49,200
dependent a view of how we see the data

00:10:46,400 --> 00:10:52,560
so I'm going to do my live demo with

00:10:49,200 --> 00:10:56,460
that introduction and show how this

00:10:52,560 --> 00:10:59,910
works with some sample data and the

00:10:56,460 --> 00:11:03,360
sample data that I'm going to use it's a

00:10:59,910 --> 00:11:05,670
geography database I have all the larger

00:11:03,360 --> 00:11:07,960
cities of the world about four thousand

00:11:05,670 --> 00:11:10,060
rows imported into mysql

00:11:07,960 --> 00:11:12,700
I have two trends two sessions session

00:11:10,060 --> 00:11:15,280
one in session two and we're going to

00:11:12,700 --> 00:11:20,260
simulate where where these two users are

00:11:15,280 --> 00:11:24,930
modifying data wants so that's let's

00:11:20,260 --> 00:11:24,930
start a transaction in both sessions

00:11:28,860 --> 00:11:40,630
let's start a transaction in session

00:11:32,020 --> 00:11:46,680
number two let's select city from the

00:11:40,630 --> 00:11:49,690
city table where name equals London and

00:11:46,680 --> 00:11:54,550
we see that there are our two rows i

00:11:49,690 --> 00:12:01,350
live in toronto canada very close to the

00:11:54,550 --> 00:12:01,350
the fake london that exists here oops

00:12:04,920 --> 00:12:11,350
okay so just so I'm not cheating we can

00:12:09,670 --> 00:12:13,690
see that we see the same data in both

00:12:11,350 --> 00:12:17,100
sessions and we've got a transaction

00:12:13,690 --> 00:12:21,670
open so let's modify fake London and

00:12:17,100 --> 00:12:31,660
we'll say update city set name equals

00:12:21,670 --> 00:12:35,110
fake London where ID equals 18 20 okay

00:12:31,660 --> 00:12:39,160
so if I were to read this data back I've

00:12:35,110 --> 00:12:42,400
updated fake London now I only see

00:12:39,160 --> 00:12:45,310
London what does this other user in

00:12:42,400 --> 00:12:49,560
session to see when they try and read

00:12:45,310 --> 00:12:52,810
back London they see both of the rose

00:12:49,560 --> 00:12:55,480
this is the intended behavior here I'm

00:12:52,810 --> 00:12:57,520
allowed to see my modification and I

00:12:55,480 --> 00:13:00,220
haven't committed it or I haven't rolled

00:12:57,520 --> 00:13:02,920
back I still have that choice while

00:13:00,220 --> 00:13:04,420
these changes are pending and actually

00:13:02,920 --> 00:13:07,000
depended on something called isolation

00:13:04,420 --> 00:13:11,560
as well this user is not supposed to see

00:13:07,000 --> 00:13:18,960
those changes so let's modify another

00:13:11,560 --> 00:13:18,960
row let's update Paris

00:13:19,390 --> 00:13:23,170
just to show you that this is a

00:13:25,030 --> 00:13:35,180
bi-directional so I've updated Paris so

00:13:32,090 --> 00:13:40,610
I try and select back I should see that

00:13:35,180 --> 00:13:45,410
there's no rows for Paris and this

00:13:40,610 --> 00:13:47,870
particular in the other session I should

00:13:45,410 --> 00:13:49,430
see that there's still a row multi

00:13:47,870 --> 00:13:54,020
version concurrency control is the

00:13:49,430 --> 00:14:05,150
algorithm working here let's modify one

00:13:54,020 --> 00:14:09,560
more that's modify San Francisco oh and

00:14:05,150 --> 00:14:11,390
I spelled it wrong so it found one row

00:14:09,560 --> 00:14:14,720
it modified that one row and now San

00:14:11,390 --> 00:14:16,760
Francisco is called not Paris so I have

00:14:14,720 --> 00:14:22,550
made two changes here I've made one

00:14:16,760 --> 00:14:28,360
change here let's try and modify in this

00:14:22,550 --> 00:14:28,360
session paris

00:14:36,670 --> 00:14:45,130
this is doesn't quite work so as we're

00:14:42,730 --> 00:14:47,220
making these modifications we're

00:14:45,130 --> 00:14:51,460
actually holding rowlocks internally

00:14:47,220 --> 00:14:55,390
wanting to modify that data so session

00:14:51,460 --> 00:14:57,600
one are we modified London session two

00:14:55,390 --> 00:15:01,050
we modified Paris and San Francisco

00:14:57,600 --> 00:15:03,400
session one we tried to modify Paris and

00:15:01,050 --> 00:15:06,580
so here what we're doing is we have a

00:15:03,400 --> 00:15:09,190
lock wait waiting for by default fifty

00:15:06,580 --> 00:15:11,560
seconds for this session to either

00:15:09,190 --> 00:15:14,770
commit or rollback so that we can

00:15:11,560 --> 00:15:16,510
acquire that lock this session is just

00:15:14,770 --> 00:15:18,460
going to sit and block waiting for that

00:15:16,510 --> 00:15:21,280
or waiting for 50 seconds when the

00:15:18,460 --> 00:15:23,560
timeout happens if this were to commit

00:15:21,280 --> 00:15:27,850
or rollback this statement is going to

00:15:23,560 --> 00:15:29,320
apply immediately I will wait for it to

00:15:27,850 --> 00:15:33,160
time out there we go just so we can see

00:15:29,320 --> 00:15:35,470
what the error looks like um this

00:15:33,160 --> 00:15:38,050
session i should say the transactions

00:15:35,470 --> 00:15:41,110
still open it's still modified that one

00:15:38,050 --> 00:15:44,980
row this attempt to modify this road was

00:15:41,110 --> 00:15:47,200
unsuccessful I now have a choice I can

00:15:44,980 --> 00:15:48,850
either try and do something else or I

00:15:47,200 --> 00:15:50,710
can try again and see if that

00:15:48,850 --> 00:15:55,360
modification will be successful the

00:15:50,710 --> 00:15:58,840
second time let's try again so we're

00:15:55,360 --> 00:16:02,110
waiting 50 seconds we're waiting 50

00:15:58,840 --> 00:16:05,290
seconds and while we're waiting let's

00:16:02,110 --> 00:16:08,310
see if I'm fast enough and let's try and

00:16:05,290 --> 00:16:08,310
modify London

00:16:15,660 --> 00:16:23,340
something different happened that time

00:16:19,190 --> 00:16:27,360
this one had locks on London this one

00:16:23,340 --> 00:16:29,010
had locks on Paris in San Francisco this

00:16:27,360 --> 00:16:30,960
one tried to acquire a lock that this

00:16:29,010 --> 00:16:33,030
one had this one tried to acquire lock

00:16:30,960 --> 00:16:34,830
that that one had it's like a dog

00:16:33,030 --> 00:16:38,370
chasing its tail it's just never going

00:16:34,830 --> 00:16:41,070
to end so internally what happens here

00:16:38,370 --> 00:16:44,190
is we have deadlock detection and we

00:16:41,070 --> 00:16:46,200
realized that you know these two things

00:16:44,190 --> 00:16:50,160
are just butting up against each other

00:16:46,200 --> 00:16:53,130
and forcibly I the deadlock detection

00:16:50,160 --> 00:16:56,880
steps in and it chooses to kill one

00:16:53,130 --> 00:16:59,910
particular transaction it tells me here

00:16:56,880 --> 00:17:02,550
it tried to kill this transaction so

00:16:59,910 --> 00:17:05,580
everything that was open in this case

00:17:02,550 --> 00:17:07,800
I'd modified London it's gone those

00:17:05,580 --> 00:17:09,330
changes don't apply and the application

00:17:07,800 --> 00:17:12,350
is expected to be able to catch that

00:17:09,330 --> 00:17:15,150
particular error this transaction

00:17:12,350 --> 00:17:18,150
doesn't even know that happened it's

00:17:15,150 --> 00:17:22,620
able to do whatever it wants it can

00:17:18,150 --> 00:17:26,940
freely commit or rollback or keep making

00:17:22,620 --> 00:17:38,370
more modifications any questions with

00:17:26,940 --> 00:17:40,440
that example session Godwin's basically

00:17:38,370 --> 00:17:42,330
0 which session weights when I which

00:17:40,440 --> 00:17:44,880
session wins which which changes applied

00:17:42,330 --> 00:17:46,410
in which isn't I I think it's coming up

00:17:44,880 --> 00:17:48,810
in a couple of slides but I'll answer

00:17:46,410 --> 00:17:52,140
the quick version it can technically

00:17:48,810 --> 00:17:54,750
kill either one it chooses to kill the

00:17:52,140 --> 00:17:56,610
one that's made the least changes so

00:17:54,750 --> 00:17:59,040
that it can not have to roll back so

00:17:56,610 --> 00:18:00,510
much work so it's so it's a weighted

00:17:59,040 --> 00:18:09,200
based algorithm it's not time-based

00:18:00,510 --> 00:18:09,200
right yeah another question just

00:18:17,989 --> 00:18:23,369
well please do tell if it's too little

00:18:21,450 --> 00:18:25,379
time to explain what or is it coming

00:18:23,369 --> 00:18:27,269
later but could you explain how

00:18:25,379 --> 00:18:30,869
different transactions election levels

00:18:27,269 --> 00:18:33,149
affect locking I that looks I will I

00:18:30,869 --> 00:18:34,440
think yeah I don't know if I explain the

00:18:33,149 --> 00:18:36,119
locking but i will explain i should

00:18:34,440 --> 00:18:39,450
isolation levels and then i can try and

00:18:36,119 --> 00:18:49,549
reenter that question but it is true

00:18:39,450 --> 00:18:52,079
that isolation changes locking hi I'm

00:18:49,549 --> 00:18:55,039
you said the transactions are on

00:18:52,079 --> 00:18:59,959
different versions of the data then why

00:18:55,039 --> 00:19:02,609
do some things effective immediately I

00:18:59,959 --> 00:19:05,940
that's isolation as well i think is the

00:19:02,609 --> 00:19:09,059
answer your question I'll try and get

00:19:05,940 --> 00:19:10,409
get back to that I think but when you're

00:19:09,059 --> 00:19:12,299
doing a read you're allowed to see

00:19:10,409 --> 00:19:14,159
different versions when you're doing an

00:19:12,299 --> 00:19:16,919
update you have to require a lock to

00:19:14,159 --> 00:19:19,289
update the most recent version you can't

00:19:16,919 --> 00:19:20,879
have two people try and update it once I

00:19:19,289 --> 00:19:22,769
guess you could technically that would

00:19:20,879 --> 00:19:25,829
be something like what they call

00:19:22,769 --> 00:19:27,779
optimistic concurrency control but then

00:19:25,829 --> 00:19:32,209
you have more unsafe conditions down the

00:19:27,779 --> 00:19:35,389
road when you try and finally commit

00:19:32,209 --> 00:19:35,389
thank you

00:19:40,830 --> 00:19:45,630
what about foreign key constraints let's

00:19:43,480 --> 00:19:48,550
say you know you have a table

00:19:45,630 --> 00:19:51,460
referencing continent and you are

00:19:48,550 --> 00:19:53,740
changing you know you know something in

00:19:51,460 --> 00:19:55,270
different different sessions but what's

00:19:53,740 --> 00:19:57,850
the implications of foreign key

00:19:55,270 --> 00:20:00,190
constraints unlocking right that's a

00:19:57,850 --> 00:20:02,080
great question sir foreign key

00:20:00,190 --> 00:20:05,320
constraints do have to set locking they

00:20:02,080 --> 00:20:07,860
have to set shared locks so what would

00:20:05,320 --> 00:20:11,170
happen is is the divider modifying a

00:20:07,860 --> 00:20:12,970
child and I hadn't committed that nobody

00:20:11,170 --> 00:20:16,270
could modify the parent to make it out

00:20:12,970 --> 00:20:18,400
of range while I have my pending

00:20:16,270 --> 00:20:19,870
transaction open that answers your

00:20:18,400 --> 00:20:24,790
question it does protect against that

00:20:19,870 --> 00:20:28,060
case and it will never happen so is it

00:20:24,790 --> 00:20:30,940
possible let's say that table 2 who

00:20:28,060 --> 00:20:32,830
references table 1 yes in table 3 who

00:20:30,940 --> 00:20:34,030
also references table 1 that they

00:20:32,830 --> 00:20:36,190
actually do feeling with one another

00:20:34,030 --> 00:20:38,740
well they're both no touching table 1 at

00:20:36,190 --> 00:20:40,750
all table 2 makes a long you know

00:20:38,740 --> 00:20:43,230
transaction whatever mean Val table 3

00:20:40,750 --> 00:20:44,980
can't do anything you know because of

00:20:43,230 --> 00:20:47,500
essentially further up the food chain

00:20:44,980 --> 00:20:50,800
they're colliding you know what can you

00:20:47,500 --> 00:20:52,480
do against that I I think it is possible

00:20:50,800 --> 00:20:54,790
I'd have to put more thought into the

00:20:52,480 --> 00:20:57,550
specific race condition without lights

00:20:54,790 --> 00:20:59,590
on me but uh yeah the short version is

00:20:57,550 --> 00:21:03,210
that some people do run in the foreign

00:20:59,590 --> 00:21:07,300
key locking issues and they do rely on

00:21:03,210 --> 00:21:10,240
transactional semantics and correct no

00:21:07,300 --> 00:21:12,220
bugs in code search or enforce those

00:21:10,240 --> 00:21:13,600
constraints rather than the explicit

00:21:12,220 --> 00:21:15,820
contains constraints ettienne I've

00:21:13,600 --> 00:21:17,440
defined I have seen some customers in

00:21:15,820 --> 00:21:21,700
some situations have to remove foreign

00:21:17,440 --> 00:21:23,260
key constraints to reduce locking so the

00:21:21,700 --> 00:21:26,200
answer would be not to have foreign key

00:21:23,260 --> 00:21:28,990
constraints in place at times I think

00:21:26,200 --> 00:21:31,480
this is I would default to having it and

00:21:28,990 --> 00:21:33,370
then I would find a specific situation

00:21:31,480 --> 00:21:35,650
where it's problematic and maybe remove

00:21:33,370 --> 00:21:37,750
it these things that we've shown so far

00:21:35,650 --> 00:21:41,440
with relational databases they're great

00:21:37,750 --> 00:21:45,160
and databases a lot of them are actually

00:21:41,440 --> 00:21:48,280
similar lines of code and complexity of

00:21:45,160 --> 00:21:49,990
operating systems and they're more

00:21:48,280 --> 00:21:51,640
likely to be correct and probably your

00:21:49,990 --> 00:21:54,210
application code I think there's like a

00:21:51,640 --> 00:21:56,590
way of

00:21:54,210 --> 00:21:57,940
separation of what problems you want to

00:21:56,590 --> 00:22:00,399
manage versus what you want to let them

00:21:57,940 --> 00:22:02,460
manage I would default to say try and

00:22:00,399 --> 00:22:04,600
have the foreign key constraints and I

00:22:02,460 --> 00:22:07,210
could probably tell you offline how to

00:22:04,600 --> 00:22:08,649
run Diagnostics to show you if you're

00:22:07,210 --> 00:22:10,980
really hitting these foreign key areas

00:22:08,649 --> 00:22:17,980
and then you could try and turn them off

00:22:10,980 --> 00:22:19,179
okay okay just wondering when we set up

00:22:17,980 --> 00:22:20,649
the foreign keys where you can start

00:22:19,179 --> 00:22:22,899
with doing nothing or something like

00:22:20,649 --> 00:22:25,029
cascading zor update sort of things just

00:22:22,899 --> 00:22:33,070
a share locking up on all of them yes

00:22:25,029 --> 00:22:36,639
okay yeah cool um I'm very happy that I

00:22:33,070 --> 00:22:40,260
got so many questions by the way I think

00:22:36,639 --> 00:22:44,440
it makes for a more interactive session

00:22:40,260 --> 00:22:46,659
so the next session or are an intern

00:22:44,440 --> 00:22:50,260
next discussion point let's zoom in more

00:22:46,659 --> 00:22:52,539
on deadlocks and unlock weights so what

00:22:50,260 --> 00:22:54,429
is the deadlock a deadlock is a

00:22:52,539 --> 00:22:56,830
situation where two sessions try to

00:22:54,429 --> 00:23:00,159
acquire each other's respective locks

00:22:56,830 --> 00:23:03,220
and neither can proceed until the other

00:23:00,159 --> 00:23:05,889
backs down so the database steps in and

00:23:03,220 --> 00:23:07,720
says okay guys this is what's going to

00:23:05,889 --> 00:23:10,690
happen I'm going to make you back down

00:23:07,720 --> 00:23:13,090
and I like to think of the situation of

00:23:10,690 --> 00:23:15,610
deadlocks is similar to an organization

00:23:13,090 --> 00:23:19,059
structure where you have two people that

00:23:15,610 --> 00:23:20,889
can't work together and I'll expand on

00:23:19,059 --> 00:23:23,980
that more in a second what I mean by

00:23:20,889 --> 00:23:27,610
that but the algorithms are the same so

00:23:23,980 --> 00:23:30,700
um what is Allah quite a lock weight is

00:23:27,610 --> 00:23:32,470
one step short of a deadlock I don't

00:23:30,700 --> 00:23:34,779
know the analogy here maybe it's you try

00:23:32,470 --> 00:23:36,370
and do something but it's not in the

00:23:34,779 --> 00:23:37,809
budget this quarter and then you ask

00:23:36,370 --> 00:23:41,080
again and turn on the budget next

00:23:37,809 --> 00:23:44,980
quarter or next quarter with the default

00:23:41,080 --> 00:23:46,809
being 50 seconds and as soon as it's

00:23:44,980 --> 00:23:49,120
able to acquire that locket will and

00:23:46,809 --> 00:23:51,419
most transactions that most people have

00:23:49,120 --> 00:23:53,590
a like you know a couple of seconds tops

00:23:51,419 --> 00:23:55,690
seems unlikely that if you try it again

00:23:53,590 --> 00:24:00,309
in the default configuration you'd be

00:23:55,690 --> 00:24:04,059
able to acquire that look deadlock

00:24:00,309 --> 00:24:07,360
detection works in inner TV I via

00:24:04,059 --> 00:24:08,020
something called graph detection we had

00:24:07,360 --> 00:24:10,360
that little disguise

00:24:08,020 --> 00:24:11,830
about what happens whereas it kill kills

00:24:10,360 --> 00:24:14,380
the transaction then modified the least

00:24:11,830 --> 00:24:18,910
rose and none of those changes apply

00:24:14,380 --> 00:24:20,980
anymore they will roll back preventing

00:24:18,910 --> 00:24:25,390
deadlocks I said it was the same as when

00:24:20,980 --> 00:24:28,030
you have two colleagues argue they just

00:24:25,390 --> 00:24:30,160
get in each others face what are some

00:24:28,030 --> 00:24:32,380
potential solutions you might have if

00:24:30,160 --> 00:24:35,830
two people always arguing when they're

00:24:32,380 --> 00:24:41,590
working on projects together deathmatch

00:24:35,830 --> 00:24:43,900
I wish I had that much slide no I mean

00:24:41,590 --> 00:24:47,380
obvious right don't make them work

00:24:43,900 --> 00:24:49,930
together I mean this might or might not

00:24:47,380 --> 00:24:53,680
be practical for your organization to

00:24:49,930 --> 00:24:56,980
grow and scale it might not be but one

00:24:53,680 --> 00:24:58,600
way might be to reduce the concurrency

00:24:56,980 --> 00:25:01,150
by having these two things round in

00:24:58,600 --> 00:25:03,940
isolation lockstep rather than at the

00:25:01,150 --> 00:25:06,340
same time this works this helps you

00:25:03,940 --> 00:25:08,020
avoid dead looks I should point out dead

00:25:06,340 --> 00:25:10,690
locks are actually pretty expensive to

00:25:08,020 --> 00:25:13,120
roll back up to 30 times where the

00:25:10,690 --> 00:25:15,760
corresponding apply would have in the

00:25:13,120 --> 00:25:18,850
case of the energy storage engine so a

00:25:15,760 --> 00:25:23,140
small amounts okay a large amount could

00:25:18,850 --> 00:25:26,680
be unhealthy solution to for these two

00:25:23,140 --> 00:25:30,940
colleagues arguing don't make them work

00:25:26,680 --> 00:25:33,310
on big projects together so maybe lower

00:25:30,940 --> 00:25:35,560
the stakes rather than have this multi

00:25:33,310 --> 00:25:38,050
year long project and then you discover

00:25:35,560 --> 00:25:40,180
close to the deadline that nobody's

00:25:38,050 --> 00:25:43,300
really achieved anything and that the

00:25:40,180 --> 00:25:46,030
implementation is not acceptable so in

00:25:43,300 --> 00:25:47,920
the case of when we were doing these two

00:25:46,030 --> 00:25:51,070
different sessions and we're acquiring

00:25:47,920 --> 00:25:53,680
LOX LOX are held for the duration of the

00:25:51,070 --> 00:25:56,140
transaction if I have smaller

00:25:53,680 --> 00:25:59,260
transactions with smaller pieces of work

00:25:56,140 --> 00:26:01,960
together I have less locking I have less

00:25:59,260 --> 00:26:05,620
chance of these concurrency conditions

00:26:01,960 --> 00:26:09,010
or rising I could also apply better

00:26:05,620 --> 00:26:11,730
indexing more indexing less Rose locked

00:26:09,010 --> 00:26:16,000
potentially less of these situations

00:26:11,730 --> 00:26:18,040
arise but even though I have provided

00:26:16,000 --> 00:26:20,860
these two kind of solutions and they're

00:26:18,040 --> 00:26:21,880
half solutions what you should remember

00:26:20,860 --> 00:26:23,830
is that

00:26:21,880 --> 00:26:26,920
a small amount of deadlocks or a fact of

00:26:23,830 --> 00:26:29,800
life so let's say that we were thinking

00:26:26,920 --> 00:26:33,130
in terms of the company again we could

00:26:29,800 --> 00:26:35,260
have nobody work together ever how

00:26:33,130 --> 00:26:37,960
scalable is this how are you going to

00:26:35,260 --> 00:26:40,240
grow you have to implement some

00:26:37,960 --> 00:26:41,320
procedures like HR or something like

00:26:40,240 --> 00:26:44,770
that to be able to handle these

00:26:41,320 --> 00:26:47,020
situations if you want to operate at a

00:26:44,770 --> 00:26:48,760
reasonable scale there's this this

00:26:47,020 --> 00:26:50,740
overhead all these disputes that happen

00:26:48,760 --> 00:26:54,070
and you just part of make it part of

00:26:50,740 --> 00:26:55,780
your operating expertise so we use the

00:26:54,070 --> 00:26:57,490
example of my eyes em again that I

00:26:55,780 --> 00:26:59,710
showed at the very start of my talk

00:26:57,490 --> 00:27:01,780
where to do that back up we locked

00:26:59,710 --> 00:27:03,940
everyone out first how does this work

00:27:01,780 --> 00:27:06,970
for concurrency it's not the most

00:27:03,940 --> 00:27:08,970
exciting thing is it writes have to be

00:27:06,970 --> 00:27:10,930
put on hold as soon as I do my backup I

00:27:08,970 --> 00:27:13,750
mean of course we could say in some

00:27:10,930 --> 00:27:15,930
MySQL specific situations we could back

00:27:13,750 --> 00:27:19,060
up from a slave and what have you but

00:27:15,930 --> 00:27:20,980
deadlocks have to be able to occur at

00:27:19,060 --> 00:27:25,330
least a little bit for you to be able to

00:27:20,980 --> 00:27:28,270
have high throughput so this touches a

00:27:25,330 --> 00:27:31,480
little bit on optimistic versus like

00:27:28,270 --> 00:27:34,330
pessimistic concurrency control the

00:27:31,480 --> 00:27:36,550
optimist tries everything and they know

00:27:34,330 --> 00:27:38,580
of some of the unsafe situations but

00:27:36,550 --> 00:27:43,120
then they handle them when they occur

00:27:38,580 --> 00:27:45,100
the pessimist tries nothing and doesn't

00:27:43,120 --> 00:27:46,500
get the same concurrency as a result but

00:27:45,100 --> 00:27:48,970
doesn't have to handle these situations

00:27:46,500 --> 00:27:50,980
my eyes in being table level locking

00:27:48,970 --> 00:27:53,170
doesn't actually have deadlox because

00:27:50,980 --> 00:27:54,850
they just have table locks the the

00:27:53,170 --> 00:28:01,570
granularity is high enough that it's a

00:27:54,850 --> 00:28:03,490
single user system so expect that when

00:28:01,570 --> 00:28:05,800
the database gives you a deadlock error

00:28:03,490 --> 00:28:07,870
I gave you those two strategies but it's

00:28:05,800 --> 00:28:09,510
actually your problem he can't say

00:28:07,870 --> 00:28:11,860
databases broker and you have to

00:28:09,510 --> 00:28:15,880
database has to fix that you have to

00:28:11,860 --> 00:28:17,350
kind of fix that and you could ask why

00:28:15,880 --> 00:28:20,260
doesn't the database try and reapply the

00:28:17,350 --> 00:28:22,360
transaction and just you know rerun

00:28:20,260 --> 00:28:24,010
those statements well the state is

00:28:22,360 --> 00:28:26,110
actually kind of changed because someone

00:28:24,010 --> 00:28:28,660
else was modifying something so it can't

00:28:26,110 --> 00:28:30,700
safely do that it needs to you let you

00:28:28,660 --> 00:28:34,560
step in and you handle these errors is

00:28:30,700 --> 00:28:35,680
an application developer and yet my

00:28:34,560 --> 00:28:38,890
might

00:28:35,680 --> 00:28:41,080
poll of what I saw a former colleague

00:28:38,890 --> 00:28:43,300
give a similar talk to this said how

00:28:41,080 --> 00:28:44,830
many people handle all of the errors

00:28:43,300 --> 00:28:46,840
that their application other the

00:28:44,830 --> 00:28:49,450
database comes back five percent of

00:28:46,840 --> 00:28:52,870
people raise their hands so I don't know

00:28:49,450 --> 00:28:56,620
how what percentage of people handle the

00:28:52,870 --> 00:28:59,200
database errors I think my more than

00:28:56,620 --> 00:29:02,770
five percent I think we're maybe 10 or

00:28:59,200 --> 00:29:06,220
20 it's it's unfortunate but this is a

00:29:02,770 --> 00:29:09,280
this is a common problem how do you

00:29:06,220 --> 00:29:12,100
handle lock wait time out I would say

00:29:09,280 --> 00:29:15,100
that I you could technically handle it

00:29:12,100 --> 00:29:16,450
the same as the way a deadlock works and

00:29:15,100 --> 00:29:18,730
I did say this point already that if

00:29:16,450 --> 00:29:20,290
most transactions are about a second 50

00:29:18,730 --> 00:29:23,170
seconds it just doesn't seem likely that

00:29:20,290 --> 00:29:29,470
you'd be able to try that again and it

00:29:23,170 --> 00:29:31,240
work correctly and when I said actually

00:29:29,470 --> 00:29:33,850
that it requires it can't replay the

00:29:31,240 --> 00:29:35,170
transaction safely and you have to step

00:29:33,850 --> 00:29:39,040
in and you have to try and do that

00:29:35,170 --> 00:29:41,080
yourself because state could changed you

00:29:39,040 --> 00:29:44,770
don't necessarily even have to do this I

00:29:41,080 --> 00:29:47,050
think when you look at a typical web

00:29:44,770 --> 00:29:49,060
application you'd be talking about a

00:29:47,050 --> 00:29:50,460
small fraction of a fraction of a cent

00:29:49,060 --> 00:29:52,560
that actually gets these errors back

00:29:50,460 --> 00:29:54,790
provided you are handling those

00:29:52,560 --> 00:29:57,400
colleague situations where they clearly

00:29:54,790 --> 00:30:00,540
can't work with each other in most cases

00:29:57,400 --> 00:30:03,190
I think you would be safe if your

00:30:00,540 --> 00:30:05,530
database error handling code just gave

00:30:03,190 --> 00:30:08,470
the user an error and said nothing's

00:30:05,530 --> 00:30:09,970
been applied please try again I totally

00:30:08,470 --> 00:30:13,630
think that this is a reasonable way of

00:30:09,970 --> 00:30:15,370
handling these errors I do note that

00:30:13,630 --> 00:30:18,460
there might be exceptions where this

00:30:15,370 --> 00:30:20,620
might not be technically possible say if

00:30:18,460 --> 00:30:22,480
you've given a commitment to a user and

00:30:20,620 --> 00:30:23,980
then you've passed it to a background

00:30:22,480 --> 00:30:26,680
thread and you have no way of

00:30:23,980 --> 00:30:28,900
communicating back to that user maybe my

00:30:26,680 --> 00:30:31,870
expectation here is unrealistic like

00:30:28,900 --> 00:30:34,030
with an asynchronous worker some message

00:30:31,870 --> 00:30:35,470
queues will allow you to like have a

00:30:34,030 --> 00:30:37,330
two-phase commit where you pulpit and

00:30:35,470 --> 00:30:38,950
then you confirm it and then you could

00:30:37,330 --> 00:30:40,120
fail out and then someone else would

00:30:38,950 --> 00:30:42,400
essentially try it and that would work

00:30:40,120 --> 00:30:44,320
if your message you didn't have that you

00:30:42,400 --> 00:30:46,150
would have to find a way to building

00:30:44,320 --> 00:30:48,790
code logic to be able to reapply stuff

00:30:46,150 --> 00:30:51,430
successfully

00:30:48,790 --> 00:30:54,280
um so that's how that's our discussion

00:30:51,430 --> 00:30:57,010
of dead looks let's talk about acid

00:30:54,280 --> 00:30:59,950
let's talk about some of the questions I

00:30:57,010 --> 00:31:04,330
had about isolation so or relational

00:30:59,950 --> 00:31:07,240
databases they try to subscribe to this

00:31:04,330 --> 00:31:10,570
acronym called acid of intended

00:31:07,240 --> 00:31:13,630
behaviors a CID atomicity consistency

00:31:10,570 --> 00:31:16,930
isolation and durability but some of

00:31:13,630 --> 00:31:19,470
these are a little bit tunable I'll go

00:31:16,930 --> 00:31:23,230
into detail what what each one means but

00:31:19,470 --> 00:31:24,760
atomic means all or none I do multiple

00:31:23,230 --> 00:31:29,200
things at once I want them to apply like

00:31:24,760 --> 00:31:30,940
they're one consistency it's kind of

00:31:29,200 --> 00:31:34,480
generic and what it means applies to

00:31:30,940 --> 00:31:37,930
constraints isolation configurable

00:31:34,480 --> 00:31:42,940
durable configurable a little bit let's

00:31:37,930 --> 00:31:44,680
go into two details so atomicity most

00:31:42,940 --> 00:31:47,140
people know this one so i don't have to

00:31:44,680 --> 00:31:48,970
hop on it too much it means that if you

00:31:47,140 --> 00:31:51,790
were to write a query and say or a

00:31:48,970 --> 00:31:54,730
couple of queries transfer money from

00:31:51,790 --> 00:31:57,010
account ayee to account be we can't have

00:31:54,730 --> 00:31:58,750
like if it was starting balance of one

00:31:57,010 --> 00:32:00,190
hundred dollars each we can't end up

00:31:58,750 --> 00:32:03,430
with one account having one hundred and

00:32:00,190 --> 00:32:04,600
twenty dollars and one having 100 or you

00:32:03,430 --> 00:32:08,500
know something that doesn't add up to

00:32:04,600 --> 00:32:10,540
200 and total and aggregate so if you

00:32:08,500 --> 00:32:13,090
want that authenticity and use a

00:32:10,540 --> 00:32:14,710
relational database you just say start

00:32:13,090 --> 00:32:18,250
transaction you do your statements you

00:32:14,710 --> 00:32:19,540
say commit we guarantee this you will

00:32:18,250 --> 00:32:21,730
not end up in one of those situations

00:32:19,540 --> 00:32:24,210
where the total between the two doesn't

00:32:21,730 --> 00:32:27,160
add up to 200 we guarantee it and

00:32:24,210 --> 00:32:29,020
there's a lot of a lot of stuff in the

00:32:27,160 --> 00:32:34,600
back and that has to happen for this to

00:32:29,020 --> 00:32:37,260
be true consistency not too much more to

00:32:34,600 --> 00:32:39,580
add about consistency other than our

00:32:37,260 --> 00:32:42,100
foreign key constraints unique

00:32:39,580 --> 00:32:44,590
constraints in primary keys we will

00:32:42,100 --> 00:32:46,420
never ever allow a situation will be

00:32:44,590 --> 00:32:48,790
violated where there could be two of one

00:32:46,420 --> 00:32:50,680
of our primary key even with this multi

00:32:48,790 --> 00:32:53,020
version concurrency control funky stuff

00:32:50,680 --> 00:32:54,970
happening in the background in other

00:32:53,020 --> 00:32:57,670
databases they stretch this a little bit

00:32:54,970 --> 00:32:59,650
further where they might have some check

00:32:57,670 --> 00:33:00,970
constraints on the domain of data and

00:32:59,650 --> 00:33:04,030
make sure that it's accurate

00:33:00,970 --> 00:33:06,309
this is the promise of consistency and

00:33:04,030 --> 00:33:08,020
we have an example where we might want

00:33:06,309 --> 00:33:13,240
to relax it because it can be expensive

00:33:08,020 --> 00:33:16,720
in some situations isolation is actually

00:33:13,240 --> 00:33:19,150
very expensive what this means and it

00:33:16,720 --> 00:33:22,059
can require a lot of locking and it can

00:33:19,150 --> 00:33:24,820
require stale data being kept around so

00:33:22,059 --> 00:33:28,000
as a as an answer to this there's

00:33:24,820 --> 00:33:31,059
actually four theoretical levels or

00:33:28,000 --> 00:33:34,210
options for what changes you're allowed

00:33:31,059 --> 00:33:37,780
to see in another transaction while

00:33:34,210 --> 00:33:41,380
you're modifying data so these are these

00:33:37,780 --> 00:33:43,929
for isolation levels you start off at

00:33:41,380 --> 00:33:46,360
the very base with re uncommitted and

00:33:43,929 --> 00:33:49,210
each one implies than the promises of

00:33:46,360 --> 00:33:52,510
the previous where if you configured

00:33:49,210 --> 00:33:55,210
mysql to be read uncommitted if somebody

00:33:52,510 --> 00:33:57,370
else is modifying data in another

00:33:55,210 --> 00:34:00,190
session and they haven't said commit

00:33:57,370 --> 00:34:01,659
you'll actually see that data but in

00:34:00,190 --> 00:34:05,799
terms of what locking we have to do

00:34:01,659 --> 00:34:08,740
internally to be able to make things

00:34:05,799 --> 00:34:13,619
happen it's very low so the concurrency

00:34:08,740 --> 00:34:16,149
is very high I'm read committed is a

00:34:13,619 --> 00:34:19,030
step better and generally the minimum of

00:34:16,149 --> 00:34:20,980
what people expect of what other changes

00:34:19,030 --> 00:34:22,839
they'll allow to see that people are

00:34:20,980 --> 00:34:26,710
making so read uncommitted I'll read

00:34:22,839 --> 00:34:29,560
committed says that if I read data in my

00:34:26,710 --> 00:34:31,960
session and then someone else modified

00:34:29,560 --> 00:34:34,599
data and then I read the data again in

00:34:31,960 --> 00:34:36,730
my session I would actually see they're

00:34:34,599 --> 00:34:40,359
committed change this is usually

00:34:36,730 --> 00:34:42,040
considered acceptable the next one down

00:34:40,359 --> 00:34:44,230
called repeatable read which is actually

00:34:42,040 --> 00:34:46,599
the default says the divine read data

00:34:44,230 --> 00:34:48,730
and then someone modified and committed

00:34:46,599 --> 00:34:50,589
that data and then I read the data again

00:34:48,730 --> 00:34:54,010
i actually won't even see they're

00:34:50,589 --> 00:34:55,929
committed change this is quite a strong

00:34:54,010 --> 00:34:58,570
for a default but it's common amongst

00:34:55,929 --> 00:35:00,670
relational databases that I should be

00:34:58,570 --> 00:35:02,589
able to repeat my read I should be able

00:35:00,670 --> 00:35:05,290
to see the same data as I saw the first

00:35:02,589 --> 00:35:06,940
time so once my session starts that's

00:35:05,290 --> 00:35:09,040
the perspective of the data that I'll

00:35:06,940 --> 00:35:14,109
see with multi version concurrency

00:35:09,040 --> 00:35:14,800
control serializable this isn't too

00:35:14,109 --> 00:35:17,670
commonly

00:35:14,800 --> 00:35:19,690
use this is the strictest of choices and

00:35:17,670 --> 00:35:21,580
this doesn't use multi version

00:35:19,690 --> 00:35:23,560
concurrency control what it says is that

00:35:21,580 --> 00:35:25,720
while I read data I'll lock the data and

00:35:23,560 --> 00:35:28,120
nobody else is allowed to to make any

00:35:25,720 --> 00:35:32,590
changes in any other session of the data

00:35:28,120 --> 00:35:35,230
that have seen so I would say for most

00:35:32,590 --> 00:35:37,090
people they'll end up in a in a

00:35:35,230 --> 00:35:40,960
repeatable read situation in default a

00:35:37,090 --> 00:35:42,880
read committed situation and there was a

00:35:40,960 --> 00:35:44,680
question before that I said I would try

00:35:42,880 --> 00:35:49,360
and answer and say how does this kind of

00:35:44,680 --> 00:35:51,730
effect locking a lot of people do switch

00:35:49,360 --> 00:35:54,100
actually to read committed and the

00:35:51,730 --> 00:35:55,660
reason they switch is that if you set

00:35:54,100 --> 00:35:59,260
your isolation level to read committed

00:35:55,660 --> 00:36:04,060
and you change your binary logging to

00:35:59,260 --> 00:36:07,810
row based replication when you run a

00:36:04,060 --> 00:36:09,280
update query and the update has to scan

00:36:07,810 --> 00:36:13,000
through a lot of data but only modify a

00:36:09,280 --> 00:36:14,950
few rows with read committed only the

00:36:13,000 --> 00:36:17,470
few rows that you'll modify is the ones

00:36:14,950 --> 00:36:19,420
that will hold the locks open with

00:36:17,470 --> 00:36:22,000
repeatable read everything that he had

00:36:19,420 --> 00:36:23,410
to examine has to be locked for the

00:36:22,000 --> 00:36:25,840
duration of your transaction so there is

00:36:23,410 --> 00:36:29,530
actually a a difference that can happen

00:36:25,840 --> 00:36:34,600
with concurrency hope that answers your

00:36:29,530 --> 00:36:37,660
question the gentleman asked it yeah so

00:36:34,600 --> 00:36:40,840
isolation is configurable durability is

00:36:37,660 --> 00:36:44,200
configurable as well where what we can

00:36:40,840 --> 00:36:47,410
say is that um by default actually when

00:36:44,200 --> 00:36:49,330
you write data to like a file system it

00:36:47,410 --> 00:36:52,090
buffers it and a buff is kind of like a

00:36:49,330 --> 00:36:55,890
funnel and then when you say sync or

00:36:52,090 --> 00:36:57,730
commit then or flush those contents down

00:36:55,890 --> 00:37:00,010
to make sure that it's you know

00:36:57,730 --> 00:37:01,570
physically stored on the disk the

00:37:00,010 --> 00:37:03,640
problem of these buffers these buffers

00:37:01,570 --> 00:37:05,530
are in memory so every time you say

00:37:03,640 --> 00:37:06,940
commit actually by default in ODB will

00:37:05,530 --> 00:37:09,400
make sure that those buffers are flashed

00:37:06,940 --> 00:37:11,320
an empty but not all databases

00:37:09,400 --> 00:37:13,660
necessarily will do that and actually

00:37:11,320 --> 00:37:15,820
MySQL does offer the configuration so

00:37:13,660 --> 00:37:22,570
that you you could put my scale on this

00:37:15,820 --> 00:37:24,970
mode I if you're not using a raid

00:37:22,570 --> 00:37:27,640
controller or you're not using an SSD

00:37:24,970 --> 00:37:28,359
this is when it's most visible and the

00:37:27,640 --> 00:37:31,029
rights

00:37:28,359 --> 00:37:33,309
going to be way worse in the default

00:37:31,029 --> 00:37:36,539
mode when my skull is fully durable

00:37:33,309 --> 00:37:39,730
making sure that those changes is safe

00:37:36,539 --> 00:37:42,970
um so that's it for acid my last pot is

00:37:39,730 --> 00:37:46,420
a summary and it's very short any

00:37:42,970 --> 00:37:48,150
questions on the deadlock behavior it's

00:37:46,420 --> 00:37:51,009
hard isn't its last talk of the day I

00:37:48,150 --> 00:37:53,890
once probably I find this stuff

00:37:51,009 --> 00:37:59,109
fascinating that maybe another one she

00:37:53,890 --> 00:38:03,099
has my excitement her questions okay so

00:37:59,109 --> 00:38:06,009
um application responsibilities um wrap

00:38:03,099 --> 00:38:08,829
every logical unit of work and start

00:38:06,009 --> 00:38:13,059
transaction and commit if you do that

00:38:08,829 --> 00:38:16,630
awesome responsibility to is expect

00:38:13,059 --> 00:38:18,509
failure because failure is required for

00:38:16,630 --> 00:38:20,680
the database to be able to be concurrent

00:38:18,509 --> 00:38:22,690
the two failures that you're going to

00:38:20,680 --> 00:38:26,559
get are going to the lock wait time out

00:38:22,690 --> 00:38:29,170
and deadlock lock wait time out you

00:38:26,559 --> 00:38:31,569
could retry or you could handle it like

00:38:29,170 --> 00:38:33,430
you do a deadlock deadlock means that

00:38:31,569 --> 00:38:41,640
none of the changes that you had made

00:38:33,430 --> 00:38:41,640
are going to be successful and that's it

00:38:50,440 --> 00:38:58,010
so i have another couple of slides on

00:38:54,350 --> 00:39:00,440
internal locks to explain that if if

00:38:58,010 --> 00:39:02,030
people that curious but i was hoping to

00:39:00,440 --> 00:39:06,130
see if i could get more questions for us

00:39:02,030 --> 00:39:06,130
because that's really often a tangent

00:39:07,000 --> 00:39:10,000
question

00:39:13,789 --> 00:39:17,459
about the outside properties you were

00:39:15,900 --> 00:39:20,039
talking about what in the point of view

00:39:17,459 --> 00:39:22,259
of one server but if we have multiple

00:39:20,039 --> 00:39:23,670
servers what about the concurrency n

00:39:22,259 --> 00:39:28,499
dimensional concurrency if I am

00:39:23,670 --> 00:39:31,079
replicating data so you have so i gave

00:39:28,499 --> 00:39:32,940
multiple uses as the example just to

00:39:31,079 --> 00:39:35,369
make sure i'm correct i had both users

00:39:32,940 --> 00:39:37,349
on the same system connecting to the to

00:39:35,369 --> 00:39:38,459
the same database near saying one of the

00:39:37,349 --> 00:39:40,049
users are in different service

00:39:38,459 --> 00:39:41,999
connecting to the same database said

00:39:40,049 --> 00:39:44,219
what i was mentioning it if you have

00:39:41,999 --> 00:39:46,650
multiple databases so let's say you have

00:39:44,219 --> 00:39:49,589
a read/write replica or you have our

00:39:46,650 --> 00:39:52,229
distributed servers you Jamie exchanges

00:39:49,589 --> 00:39:54,449
in one server and it's might not applied

00:39:52,229 --> 00:39:56,849
into the others are very apt good

00:39:54,449 --> 00:39:58,709
question so I'll see if I can paraphrase

00:39:56,849 --> 00:40:00,660
to make sure I'm right right so my

00:39:58,709 --> 00:40:02,489
examples using a single mysql server

00:40:00,660 --> 00:40:04,259
you're saying what happens if i have

00:40:02,489 --> 00:40:05,779
read slaves or if i have some

00:40:04,259 --> 00:40:11,369
distributed architecture like shouting

00:40:05,779 --> 00:40:14,190
do i get these same features no yeah you

00:40:11,369 --> 00:40:17,069
only get these features if you're using

00:40:14,190 --> 00:40:18,569
a single database which is it's not

00:40:17,069 --> 00:40:22,619
impossible it's far the reason why the

00:40:18,569 --> 00:40:24,239
relational model is hard to scale what

00:40:22,619 --> 00:40:26,459
generally happens in those shot at

00:40:24,239 --> 00:40:29,039
architectures is you break it up into

00:40:26,459 --> 00:40:31,049
like groups of the problem so that

00:40:29,039 --> 00:40:33,239
you'll get this isolation this

00:40:31,049 --> 00:40:38,670
durability and everything on a per

00:40:33,239 --> 00:40:43,219
important segregated problem so like

00:40:38,670 --> 00:40:46,680
natural barriers in the data I hope that

00:40:43,219 --> 00:40:49,160
that helps sorry you can't can't do a

00:40:46,680 --> 00:40:49,160
multi-server

00:40:53,580 --> 00:41:08,140
any other questions so one of the front

00:41:00,790 --> 00:41:11,050
I'll just read from like going back to

00:41:08,140 --> 00:41:15,339
the locking where would you use the zero

00:41:11,050 --> 00:41:19,080
serializable as a default a serializable

00:41:15,339 --> 00:41:23,740
is that doesn't generally make sense one

00:41:19,080 --> 00:41:26,950
all right right so a great question let

00:41:23,740 --> 00:41:30,190
me say never and say when would you need

00:41:26,950 --> 00:41:31,570
it sometimes if you read data and you

00:41:30,190 --> 00:41:33,820
wanted to make sure that you got the

00:41:31,570 --> 00:41:36,790
most recent data said you could kind of

00:41:33,820 --> 00:41:39,369
like add salt to the recipe I guess is a

00:41:36,790 --> 00:41:40,780
way to explain it where you need to add

00:41:39,369 --> 00:41:44,260
something based on the most recent

00:41:40,780 --> 00:41:46,089
version to write back you don't want

00:41:44,260 --> 00:41:48,430
multi version concurrency control so you

00:41:46,089 --> 00:41:51,040
want like the serializable view of that

00:41:48,430 --> 00:41:53,500
so if you said select star from my table

00:41:51,040 --> 00:41:55,690
where whatever for update you will

00:41:53,500 --> 00:41:57,609
actually get serializable isolation just

00:41:55,690 --> 00:41:59,440
for that query and you'll get the most

00:41:57,609 --> 00:42:01,599
recent version of the data and you'd

00:41:59,440 --> 00:42:03,220
prevent against a specific race

00:42:01,599 --> 00:42:05,980
condition where you're modifying the

00:42:03,220 --> 00:42:08,290
data to write back because once you pull

00:42:05,980 --> 00:42:09,820
that data out you know if there's other

00:42:08,290 --> 00:42:11,950
changes that happen before you write

00:42:09,820 --> 00:42:15,099
that data back you could lose those

00:42:11,950 --> 00:42:22,390
updates and serializable protects

00:42:15,099 --> 00:42:24,010
against that I own the isolation levels

00:42:22,390 --> 00:42:25,810
again the repeatable read when it says

00:42:24,010 --> 00:42:27,280
you won't see other sessions computed

00:42:25,810 --> 00:42:30,369
roads want your session starts is that

00:42:27,280 --> 00:42:32,980
on a transaction basis rather than on a

00:42:30,369 --> 00:42:36,369
connection to the server it's a

00:42:32,980 --> 00:42:39,960
transaction basis okay yeah so my escrow

00:42:36,369 --> 00:42:42,130
has a little bit of a divorce between

00:42:39,960 --> 00:42:45,580
transactions and sessions but everything

00:42:42,130 --> 00:42:47,080
here is uh transactions okay another is

00:42:45,580 --> 00:42:49,450
arranged in sort of order of cheapness

00:42:47,080 --> 00:42:51,820
of computation to expensiveness yeah

00:42:49,450 --> 00:42:54,160
every everyone here implies the previous

00:42:51,820 --> 00:43:01,140
right so uh read uncommitted is just

00:42:54,160 --> 00:43:01,140
it's a it's cheap it's free

00:43:06,920 --> 00:43:14,130
well you mentioned that there is a row

00:43:10,800 --> 00:43:18,930
metadata and which is storing the

00:43:14,130 --> 00:43:21,480
transactions yeah are there any food the

00:43:18,930 --> 00:43:25,890
first question is can we read this

00:43:21,480 --> 00:43:27,750
metadata just that's internal and my

00:43:25,890 --> 00:43:32,790
second question is is there any other

00:43:27,750 --> 00:43:34,380
data um yeah so it's not in my slide

00:43:32,790 --> 00:43:36,240
deck tomorrow but tomorrow I talk a lot

00:43:34,380 --> 00:43:38,520
about diagnostics and operational stuff

00:43:36,240 --> 00:43:41,010
I mean there are some risks with multi

00:43:38,520 --> 00:43:43,590
version concurrency control right if you

00:43:41,010 --> 00:43:45,630
modify data and then you know you kept

00:43:43,590 --> 00:43:48,869
the transaction open and you took a

00:43:45,630 --> 00:43:51,030
vacation like all the previous autumn

00:43:48,869 --> 00:43:52,710
future modifications of other data it

00:43:51,030 --> 00:43:55,080
has to keep those previous versions of

00:43:52,710 --> 00:43:57,540
those rows available in case you might

00:43:55,080 --> 00:43:59,250
want to read them like there's a

00:43:57,540 --> 00:44:01,440
continual background thread trying to

00:43:59,250 --> 00:44:03,450
clean up old versions of data and its

00:44:01,440 --> 00:44:06,060
got like a hard mark of where it kind of

00:44:03,450 --> 00:44:08,220
events that that watermark passed so

00:44:06,060 --> 00:44:10,260
there might be some reasons when you

00:44:08,220 --> 00:44:12,000
want to see that certainly in like

00:44:10,260 --> 00:44:14,070
showing ODB status you can see the age

00:44:12,000 --> 00:44:15,930
of the oldest transaction and in

00:44:14,070 --> 00:44:17,850
information schema you can see current

00:44:15,930 --> 00:44:19,980
transactions open that are blocking

00:44:17,850 --> 00:44:22,050
locks of other people and stuff like

00:44:19,980 --> 00:44:25,770
that i don't think i have in my my

00:44:22,050 --> 00:44:28,350
slides tomorrow but operationally sure

00:44:25,770 --> 00:44:30,300
it's a concern to manage it you can't do

00:44:28,350 --> 00:44:33,240
select and then list the column names

00:44:30,300 --> 00:44:35,880
and see those invisible rose from the

00:44:33,240 --> 00:44:38,760
table I can't think of a way to to do

00:44:35,880 --> 00:44:40,770
that not going to specifically think of

00:44:38,760 --> 00:44:42,030
a good use case in that situation but

00:44:40,770 --> 00:44:46,080
you want to see the lock weights and

00:44:42,030 --> 00:44:49,980
stuff and how they stack up it's this

00:44:46,080 --> 00:44:53,760
are these transactions replicated to the

00:44:49,980 --> 00:44:56,400
slaves I know um when a transaction is

00:44:53,760 --> 00:44:58,710
finished everything is bashed up and

00:44:56,400 --> 00:45:01,470
written in the binary log on commit and

00:44:58,710 --> 00:45:05,430
then will be replicated a slave and

00:45:01,470 --> 00:45:07,560
replay then so the actual state of the

00:45:05,430 --> 00:45:09,359
pending stuff and replication and

00:45:07,560 --> 00:45:10,950
logical it's the actual internal

00:45:09,359 --> 00:45:13,109
metadata transaction at ease will be

00:45:10,950 --> 00:45:15,420
different on the on the slave but

00:45:13,109 --> 00:45:17,579
consistency is guaranteed

00:45:15,420 --> 00:45:20,150
slaves so the outer watering thing is is

00:45:17,579 --> 00:45:20,150
protected

00:45:29,579 --> 00:45:38,789
maybe you could also explain the gap

00:45:32,289 --> 00:45:43,359
locks and well essentially the general

00:45:38,789 --> 00:45:46,390
usage when when do they occur and what

00:45:43,359 --> 00:45:50,259
other operations can they block I wish I

00:45:46,390 --> 00:45:54,069
had a white board I can't explain it but

00:45:50,259 --> 00:45:59,710
it's uh I can't think of an easy way to

00:45:54,069 --> 00:46:02,349
like draw my hands to to do it um the

00:45:59,710 --> 00:46:06,579
the question is kind of when you use

00:46:02,349 --> 00:46:08,970
statement based replication as well you

00:46:06,579 --> 00:46:13,839
have to apply actually serializable

00:46:08,970 --> 00:46:16,779
replay on the slave actually maybe I

00:46:13,839 --> 00:46:19,420
think ending avoider to demonstrate

00:46:16,779 --> 00:46:28,180
let's say that in in session number one

00:46:19,420 --> 00:46:31,630
I said update uses a set value equals

00:46:28,180 --> 00:46:34,150
plus 100 where a state equals something

00:46:31,630 --> 00:46:37,210
like a rather and then it found five

00:46:34,150 --> 00:46:39,910
users but I didn't say commit and let's

00:46:37,210 --> 00:46:43,559
say in session two in that time I

00:46:39,910 --> 00:46:47,579
inserted a new user into the state of

00:46:43,559 --> 00:46:49,809
whatever and then I said commit and then

00:46:47,579 --> 00:46:52,059
things get rid of the binary log on

00:46:49,809 --> 00:46:53,559
commit so this one gets ridden first but

00:46:52,059 --> 00:46:56,380
this statement happened and then it gets

00:46:53,559 --> 00:46:57,880
committed after i would actually replay

00:46:56,380 --> 00:47:01,390
these in a different order on the slave

00:46:57,880 --> 00:47:03,039
if i didn't have gas locking so what has

00:47:01,390 --> 00:47:04,719
to happen here is when you statement

00:47:03,039 --> 00:47:06,910
based replication still the default is

00:47:04,719 --> 00:47:09,729
it has to set additional locking into

00:47:06,910 --> 00:47:11,440
the range of where state equals whatever

00:47:09,729 --> 00:47:14,410
so that nobody could insert into that

00:47:11,440 --> 00:47:17,559
range until I finished and committed

00:47:14,410 --> 00:47:22,029
this if that makes sense that's the kind

00:47:17,559 --> 00:47:24,460
of best I can try but it if you switch

00:47:22,029 --> 00:47:26,559
to row based replication and you use

00:47:24,460 --> 00:47:28,630
actually read committed isolation you

00:47:26,559 --> 00:47:30,759
don't have to do that gap locking and

00:47:28,630 --> 00:47:33,579
you will get more concurrency or so it

00:47:30,759 --> 00:47:35,440
sounded on one and some mode not not

00:47:33,579 --> 00:47:38,430
always wanna answer that that's right

00:47:35,440 --> 00:47:38,430
yeah

00:47:39,810 --> 00:47:48,840
I think the guy the back is first in

00:47:42,450 --> 00:47:50,940
this to hear oh so the boys repeatable

00:47:48,840 --> 00:47:53,040
reads the preferred default answer free

00:47:50,940 --> 00:47:55,610
committed I think it's because it's the

00:47:53,040 --> 00:48:00,660
default on oracle and other databases i

00:47:55,610 --> 00:48:02,820
think it might be history I as I said I

00:48:00,660 --> 00:48:08,010
know a reasonable amount of people

00:48:02,820 --> 00:48:10,020
change it assuming defaults is always a

00:48:08,010 --> 00:48:16,650
tough discussion I don't think we'll

00:48:10,020 --> 00:48:19,350
ever change it you are showing example

00:48:16,650 --> 00:48:21,360
when there was a deadlock what about if

00:48:19,350 --> 00:48:24,000
you are running a thing in a transaction

00:48:21,360 --> 00:48:26,640
and you have a trigger in place before

00:48:24,000 --> 00:48:32,360
update for example when the trigger is

00:48:26,640 --> 00:48:35,250
executed okay so trig is what happens is

00:48:32,360 --> 00:48:38,640
that when you're using statement based

00:48:35,250 --> 00:48:41,040
replication the triggers are just repaid

00:48:38,640 --> 00:48:43,770
on this slave the resulting statements

00:48:41,040 --> 00:48:46,050
from the triggers are not binary load

00:48:43,770 --> 00:48:47,400
and the modifications aren't made when

00:48:46,050 --> 00:48:49,110
you use row based replication it's

00:48:47,400 --> 00:48:51,420
different though all of the

00:48:49,110 --> 00:48:53,640
modifications are grouped together and

00:48:51,420 --> 00:48:54,960
they're written to the vining log

00:48:53,640 --> 00:48:57,510
together and there's no trigger replay

00:48:54,960 --> 00:49:00,210
on the slave there's actually a

00:48:57,510 --> 00:49:02,280
difference depending on the mode but

00:49:00,210 --> 00:49:04,860
from in ODB's perspective as well

00:49:02,280 --> 00:49:06,810
because this is the inner DB storage

00:49:04,860 --> 00:49:09,530
engine I don't think it really knows

00:49:06,810 --> 00:49:11,730
much about triggers it just knows about

00:49:09,530 --> 00:49:13,740
rural modifications that have to happen

00:49:11,730 --> 00:49:15,780
they have everything's in you know DB

00:49:13,740 --> 00:49:17,640
will have to apply those locks as you

00:49:15,780 --> 00:49:21,930
make modifications resulting from

00:49:17,640 --> 00:49:23,190
triggers um that's the best answer I can

00:49:21,930 --> 00:49:28,160
think of now I don't know if there's any

00:49:23,190 --> 00:49:28,160
edge cases that I'm admitting with that

00:49:28,490 --> 00:49:36,450
there was another person here they yeah

00:49:32,970 --> 00:49:38,730
when we execute a single statement do we

00:49:36,450 --> 00:49:40,740
still need to wrap it in and start

00:49:38,730 --> 00:49:43,200
transaction commits or they how to

00:49:40,740 --> 00:49:45,270
commit the feature they cares about it

00:49:43,200 --> 00:49:47,400
yeah so if you don't ask for it you get

00:49:45,270 --> 00:49:49,140
transactions every time it's just

00:49:47,400 --> 00:49:50,700
basically like a sandwich start

00:49:49,140 --> 00:49:53,250
transaction commits automatically is

00:49:50,700 --> 00:49:56,070
inserted off to its yeah

00:49:53,250 --> 00:50:01,290
that's the case for I for like an update

00:49:56,070 --> 00:50:03,840
or an insert or delete in 57 I think

00:50:01,290 --> 00:50:05,250
even 56 we have an optimization where

00:50:03,840 --> 00:50:08,670
some selects don't have to explicitly

00:50:05,250 --> 00:50:12,570
dual that set up to create the

00:50:08,670 --> 00:50:23,430
transactional context but for the most

00:50:12,570 --> 00:50:25,950
part yes ok so my couple of last slides

00:50:23,430 --> 00:50:28,320
was to say that there was one last type

00:50:25,950 --> 00:50:30,750
of locking that I emitted mutexes

00:50:28,320 --> 00:50:35,160
latches and semaphores we're going to

00:50:30,750 --> 00:50:37,200
call them internal locking and it's not

00:50:35,160 --> 00:50:40,500
unique to databases but when you write a

00:50:37,200 --> 00:50:42,210
multi-threaded program it actually has

00:50:40,500 --> 00:50:44,670
to protect against some unsafe

00:50:42,210 --> 00:50:47,100
situations happening that are not

00:50:44,670 --> 00:50:50,850
related to rose they're just related to

00:50:47,100 --> 00:50:54,450
some operations so let me try and give

00:50:50,850 --> 00:50:57,540
some examples a buffer pool awry in

00:50:54,450 --> 00:51:00,240
memory cache is full we need to load a

00:50:57,540 --> 00:51:01,680
page into memory to load a page into

00:51:00,240 --> 00:51:05,450
memory we have to free something from

00:51:01,680 --> 00:51:07,920
memory the least actively used item and

00:51:05,450 --> 00:51:09,870
then load out replacement in there but

00:51:07,920 --> 00:51:12,300
in between us freeing Sun link someone

00:51:09,870 --> 00:51:14,730
else could load in and take that spot so

00:51:12,300 --> 00:51:16,470
we have to acquire a small lock to be

00:51:14,730 --> 00:51:19,410
able to say we're doing a you know

00:51:16,470 --> 00:51:22,230
modification around out cash what's

00:51:19,410 --> 00:51:26,040
allowed to be in memory so this might be

00:51:22,230 --> 00:51:30,030
a mutex for example example two might be

00:51:26,040 --> 00:51:32,400
in an index tree we have pages pages by

00:51:30,030 --> 00:51:34,380
default 16 kilobytes each one might

00:51:32,400 --> 00:51:38,420
become too full and it might have to

00:51:34,380 --> 00:51:40,800
split into two separate pages well

00:51:38,420 --> 00:51:42,870
concurrent system two pages next to each

00:51:40,800 --> 00:51:44,660
other might have to split and they might

00:51:42,870 --> 00:51:47,280
have some problem about who goes first

00:51:44,660 --> 00:51:48,810
so in a multi-threaded programs not just

00:51:47,280 --> 00:51:51,330
databases you can actually have thread

00:51:48,810 --> 00:51:53,610
deadlox as well so you might have to

00:51:51,330 --> 00:51:55,770
create some internal locking to be able

00:51:53,610 --> 00:52:00,510
to serialize that order and make sure

00:51:55,770 --> 00:52:03,180
that the right person goes first this is

00:52:00,510 --> 00:52:06,420
a problem specifically because when

00:52:03,180 --> 00:52:07,210
mutex is a hot or mutexes have high

00:52:06,420 --> 00:52:10,089
contention there

00:52:07,210 --> 00:52:12,369
reduce concurrency same as our Roe vs.

00:52:10,089 --> 00:52:14,440
table level locks and same as the other

00:52:12,369 --> 00:52:16,030
stuff we've talked about and what can

00:52:14,440 --> 00:52:18,180
actually happen diagnostically is that

00:52:16,030 --> 00:52:20,380
you see that your database system is is

00:52:18,180 --> 00:52:22,570
something new Idol but you're not

00:52:20,380 --> 00:52:24,250
achieving more work because everything's

00:52:22,570 --> 00:52:28,380
blocked waiting behind the lock and I

00:52:24,250 --> 00:52:32,109
won't show up as cpp you use this is

00:52:28,380 --> 00:52:35,260
interesting for MySQL engineering not so

00:52:32,109 --> 00:52:38,080
interesting for you because you won't be

00:52:35,260 --> 00:52:40,720
able to fix those locks but peripheral e

00:52:38,080 --> 00:52:43,180
some DBA is like to have knowledge about

00:52:40,720 --> 00:52:45,040
this because they can learn about

00:52:43,180 --> 00:52:46,390
specific locks that are hot and then

00:52:45,040 --> 00:52:50,380
find out that they're fixed in

00:52:46,390 --> 00:52:52,060
subsequent versions such as these ones

00:52:50,380 --> 00:52:56,290
here that have been fixed in your mysql

00:52:52,060 --> 00:52:58,839
thesis um this is the these new texts or

00:52:56,290 --> 00:53:00,400
hot locks you know this this is a big

00:52:58,839 --> 00:53:02,740
issue as we move into a multi-core

00:53:00,400 --> 00:53:07,330
systems which has happened for many

00:53:02,740 --> 00:53:09,580
years mysql 56 and mysql 55 fix a lot of

00:53:07,330 --> 00:53:11,619
them if you're an early use of mysql and

00:53:09,580 --> 00:53:14,140
you've got a nice flashy new machine

00:53:11,619 --> 00:53:16,930
with 16 or 32 course you want to upgrade

00:53:14,140 --> 00:53:19,450
and the stories is better again

00:53:16,930 --> 00:53:24,070
obviously with mysql 57 the version

00:53:19,450 --> 00:53:28,960
we're working on at the moment any

00:53:24,070 --> 00:53:32,080
questions on mutexes there's more than

00:53:28,960 --> 00:53:35,490
that actually there's a lot more I just

00:53:32,080 --> 00:53:35,490
tried to summarize it question there

00:53:39,939 --> 00:53:45,949
I'm a full of the new texts and the

00:53:43,219 --> 00:53:50,089
semaphores but not the latches what are

00:53:45,949 --> 00:53:52,160
those um it's just I think it's an

00:53:50,089 --> 00:53:53,630
organism to describe it where they have

00:53:52,160 --> 00:53:57,079
different types of locks and they give

00:53:53,630 --> 00:54:01,999
different names but I latch is kind of

00:53:57,079 --> 00:54:04,039
like a mutex it's like a kind of thing

00:54:01,999 --> 00:54:06,319
what the differentiating difference is I

00:54:04,039 --> 00:54:07,729
I think you would have a latch if you

00:54:06,319 --> 00:54:09,439
had to protect it against something like

00:54:07,729 --> 00:54:13,640
happening from something else that

00:54:09,439 --> 00:54:20,420
you're doing I hate that that's recorded

00:54:13,640 --> 00:54:22,579
cuz I'm just going to look stupid yeah

00:54:20,420 --> 00:54:27,009
as we've just discovered right now

00:54:22,579 --> 00:54:27,009
Morgan is not a storage engine developer

00:54:28,869 --> 00:54:39,259
person there are ways to diagnose look

00:54:36,349 --> 00:54:40,910
errors retrospectively using like the

00:54:39,259 --> 00:54:44,469
show in urdu be status or whatever

00:54:40,910 --> 00:54:50,959
Phoenix tell us about that bit more I

00:54:44,469 --> 00:54:52,900
totally sir um I showed a deadlock we

00:54:50,959 --> 00:54:55,099
saw the deadlock but it was interactive

00:54:52,900 --> 00:54:56,239
let's say that you came to the system

00:54:55,099 --> 00:55:00,170
later and you want to know do I have

00:54:56,239 --> 00:55:03,529
deadlocks so i think it was in 56 or

00:55:00,170 --> 00:55:04,910
something we have a deadlock counter you

00:55:03,529 --> 00:55:06,529
can look at that we also have the

00:55:04,910 --> 00:55:11,959
ability I don't know when somebody fault

00:55:06,529 --> 00:55:14,299
to write deadlocked statements to the to

00:55:11,959 --> 00:55:16,699
the error log you can also capture that

00:55:14,299 --> 00:55:18,890
from your application because in ur TV

00:55:16,699 --> 00:55:21,619
we'll all my s co will hand you back

00:55:18,890 --> 00:55:22,819
that error message then your question is

00:55:21,619 --> 00:55:25,420
that when you have these two statements

00:55:22,819 --> 00:55:27,439
and you know that they conflict or a

00:55:25,420 --> 00:55:31,119
statement that can fix how can you

00:55:27,439 --> 00:55:35,869
identify exactly which is locking which

00:55:31,119 --> 00:55:37,969
the best way I think in runtime it would

00:55:35,869 --> 00:55:40,429
be there's an information schema table

00:55:37,969 --> 00:55:44,929
go to know to veelox where it would show

00:55:40,429 --> 00:55:47,900
which clocks are being held by what I so

00:55:44,929 --> 00:55:49,880
I have a log error happening and I

00:55:47,900 --> 00:55:52,339
cannon catch that and I can run against

00:55:49,880 --> 00:55:53,310
a scream against information schema on

00:55:52,339 --> 00:55:55,010
the fly and locked

00:55:53,310 --> 00:55:57,060
yeah i'm just saying i would probably

00:55:55,010 --> 00:55:58,770
technically to do the information schema

00:55:57,060 --> 00:56:01,190
thing you'd have to retry them and then

00:55:58,770 --> 00:56:04,530
see that they're locking and see which

00:56:01,190 --> 00:56:06,720
rose which locks are being held by which

00:56:04,530 --> 00:56:11,100
transaction but generally i think i

00:56:06,720 --> 00:56:12,960
would have to if you're in repeatable

00:56:11,100 --> 00:56:14,490
read if you want to explain and you see

00:56:12,960 --> 00:56:17,310
how many rows it says that it's looking

00:56:14,490 --> 00:56:19,680
at it has to lock all of the rows that

00:56:17,310 --> 00:56:21,900
looks at if you're running in read

00:56:19,680 --> 00:56:27,930
committed it only has to lock the rows

00:56:21,900 --> 00:56:32,840
that are modified i think that's the

00:56:27,930 --> 00:56:32,840
best explanation and give sorry

00:56:43,170 --> 00:56:48,900
I'm just a short one as transaction

00:56:46,650 --> 00:56:51,059
isolation levels can be set per session

00:56:48,900 --> 00:56:53,579
as well as globally if you set them in

00:56:51,059 --> 00:56:58,559
one session differently as in another

00:56:53,579 --> 00:57:01,049
how do locks work um good question so

00:56:58,559 --> 00:57:03,390
I'm going to skip past locks and say

00:57:01,049 --> 00:57:06,569
what the real issue of running the more

00:57:03,390 --> 00:57:10,049
strict isolation levels is you can't

00:57:06,569 --> 00:57:12,569
clean up the older versions of the roads

00:57:10,049 --> 00:57:14,970
I think that's the the vigor of the

00:57:12,569 --> 00:57:18,119
issue and it'll be dictated by the

00:57:14,970 --> 00:57:19,920
oldest transaction that's going to

00:57:18,119 --> 00:57:26,490
basically be the low-water mark that's

00:57:19,920 --> 00:57:28,920
going to block that from advancing the

00:57:26,490 --> 00:57:31,109
the locks they're only going to be held

00:57:28,920 --> 00:57:34,470
when you do a modification because the

00:57:31,109 --> 00:57:37,680
reeds are using MVCC so if you modify

00:57:34,470 --> 00:57:39,630
data in read committed it's going to

00:57:37,680 --> 00:57:42,660
hold less locks and if you modify the

00:57:39,630 --> 00:57:45,349
data and repeatable read okay that's

00:57:42,660 --> 00:57:45,349
good yeah

00:57:51,360 --> 00:57:54,080
ok

00:57:54,260 --> 00:57:57,220

YouTube URL: https://www.youtube.com/watch?v=aGQZtBy9J5I


