Title: PHP UK Conference 2014 - Davey Shafik - PHP Under The Hood
Publication date: 2014-03-21
Playlist: PHP UK Conference 2014
Description: 
	We've all experienced performance issues and we would typically turn to a profiler. Whether that's something in userland, or a tool like xdebug or xhprof, the reason is the same: to figure out why our code is slow. This talk will take that inspection a step further and look under the hood of PHP, at the C internals, for common performance problems. If you've ever wanted to know exactly what your code is doing, and why ++$i is faster than $i++, this talk is for you. Note: This is an advanced talk, you should be extremely familiar with PHP and have some experience with profiling if you are to get the most from this talk.
Captions: 
	00:00:05,029 --> 00:00:11,820
warning everyone everyone have a good

00:00:07,440 --> 00:00:16,320
night last night so today we can talk

00:00:11,820 --> 00:00:17,699
about PHP under the hood I am David

00:00:16,320 --> 00:00:19,740
Sheff it as you probably know from the

00:00:17,699 --> 00:00:21,990
schedule what that means is I'm a

00:00:19,740 --> 00:00:23,789
community engineer at Engine Yard we are

00:00:21,990 --> 00:00:25,170
a platform as a service we put your PHP

00:00:23,789 --> 00:00:28,109
applications in the cloud and scale them

00:00:25,170 --> 00:00:30,119
that's all my plugs for today well not

00:00:28,109 --> 00:00:31,769
really i'm the author of these n php5

00:00:30,119 --> 00:00:34,500
certification study guide and two other

00:00:31,769 --> 00:00:37,559
books and we're contributor to zend

00:00:34,500 --> 00:00:40,730
framework one and two PHP docs for a PHP

00:00:37,559 --> 00:00:44,160
internals I am the originator of the far

00:00:40,730 --> 00:00:46,050
PHP archives idea and I'm acting

00:00:44,160 --> 00:00:51,870
shattuck on Twitter so if you have any

00:00:46,050 --> 00:00:53,430
feedback please tweet me after if you're

00:00:51,870 --> 00:00:55,829
interested in getting a purple elephant

00:00:53,430 --> 00:00:58,289
and supporting PHP women PHP women dog /

00:00:55,829 --> 00:01:02,190
elephant we have a Kickstarter so go

00:00:58,289 --> 00:01:04,680
ahead and get that one or two more

00:01:02,190 --> 00:01:06,090
things actually first of all these are

00:01:04,680 --> 00:01:07,970
my slides from benelux because I tried

00:01:06,090 --> 00:01:09,930
to redeem this morning didn't work so

00:01:07,970 --> 00:01:11,250
normally i put a slide it about my

00:01:09,930 --> 00:01:12,570
accents because i kind of switch back

00:01:11,250 --> 00:01:14,040
and forth between my British from my

00:01:12,570 --> 00:01:18,270
American and I can't control it so

00:01:14,040 --> 00:01:19,560
apologies and I'm hard of hearing so if

00:01:18,270 --> 00:01:23,670
you have any questions I may actually

00:01:19,560 --> 00:01:25,020
come out and talk to you so my slides

00:01:23,670 --> 00:01:26,850
are a little bit different to a lot of

00:01:25,020 --> 00:01:28,350
people's I have a title slide like this

00:01:26,850 --> 00:01:30,740
and then behind it I have bullet points

00:01:28,350 --> 00:01:33,000
I have two problems with other speakers

00:01:30,740 --> 00:01:35,009
one is when they have the bullet points

00:01:33,000 --> 00:01:36,960
up and access subtitles which as a deaf

00:01:35,009 --> 00:01:38,100
person can be kind of nice but I read

00:01:36,960 --> 00:01:40,409
faster than they talk and it gets

00:01:38,100 --> 00:01:42,270
annoying and the other problem is when I

00:01:40,409 --> 00:01:43,560
hear about good talk and I go online to

00:01:42,270 --> 00:01:46,439
look at the slides and it's 18 pictures

00:01:43,560 --> 00:01:48,090
of cats so I'll have a slide like this

00:01:46,439 --> 00:01:51,829
behind it that you can go online and

00:01:48,090 --> 00:01:54,119
read later that i'll be skipping so

00:01:51,829 --> 00:01:55,380
originally this talk was called PHP

00:01:54,119 --> 00:01:57,990
performance under the hood and I

00:01:55,380 --> 00:01:59,460
retitled it after benelux because

00:01:57,990 --> 00:02:02,270
there's not much performance stuff in it

00:01:59,460 --> 00:02:04,950
but I want to tell you how I got here so

00:02:02,270 --> 00:02:08,340
once talked about profiling so what is

00:02:04,950 --> 00:02:09,720
profiling so and really what's the

00:02:08,340 --> 00:02:12,030
difference between benchmarking and

00:02:09,720 --> 00:02:14,610
profiling so profiling is measuring

00:02:12,030 --> 00:02:17,100
the relative speed of different portions

00:02:14,610 --> 00:02:19,020
of your application not the actual speed

00:02:17,100 --> 00:02:22,140
benchmarking is testing actual speed

00:02:19,020 --> 00:02:23,819
because profiling modifies the speed of

00:02:22,140 --> 00:02:25,770
your application so profiling is trying

00:02:23,819 --> 00:02:27,360
to identify bottlenecks but you can't

00:02:25,770 --> 00:02:29,040
actually tell if you fix the problem

00:02:27,360 --> 00:02:31,800
with profiling you have to benchmark

00:02:29,040 --> 00:02:33,810
again so we get into what I call the

00:02:31,800 --> 00:02:36,930
performance loop which looks like this

00:02:33,810 --> 00:02:39,239
your benchmark to see if what your

00:02:36,930 --> 00:02:40,709
current performance is your profile to

00:02:39,239 --> 00:02:42,660
see where your bottlenecks are your fix

00:02:40,709 --> 00:02:43,980
stuff and then you benchmark again you

00:02:42,660 --> 00:02:48,170
don't profile against see if it actually

00:02:43,980 --> 00:02:50,489
worked when should you profile your code

00:02:48,170 --> 00:02:52,050
so the number one issues I see people

00:02:50,489 --> 00:02:54,080
having with performance tuning is kind

00:02:52,050 --> 00:02:56,190
of assuming that you have a problem

00:02:54,080 --> 00:02:57,810
premature optimization is a huge waste

00:02:56,190 --> 00:02:59,819
of time and I see it happen time and

00:02:57,810 --> 00:03:02,160
time again so the first thing you need

00:02:59,819 --> 00:03:04,290
to do is determine what your desired

00:03:02,160 --> 00:03:06,810
performance should be so I need 100

00:03:04,290 --> 00:03:09,269
concurrent connections with sub second

00:03:06,810 --> 00:03:11,160
response times run your benchmark on

00:03:09,269 --> 00:03:13,140
production hardware to see if you have a

00:03:11,160 --> 00:03:15,420
problem and only then should you be

00:03:13,140 --> 00:03:18,000
profiling and actually seeing how big

00:03:15,420 --> 00:03:20,850
your problem is there are a number of

00:03:18,000 --> 00:03:24,150
common causes for slowdowns data stores

00:03:20,850 --> 00:03:26,579
external resources and then the most

00:03:24,150 --> 00:03:29,400
unusual one is bad code and that's why I

00:03:26,579 --> 00:03:30,989
got here and I have a quote here the

00:03:29,400 --> 00:03:33,920
only great code is code that never has

00:03:30,989 --> 00:03:37,049
to run everything else is just good code

00:03:33,920 --> 00:03:39,060
so basically if you got here you're in

00:03:37,049 --> 00:03:40,829
trouble if you're at the point where

00:03:39,060 --> 00:03:42,720
you're looking at your op codes you're

00:03:40,829 --> 00:03:47,609
kind of screwed but it's interesting to

00:03:42,720 --> 00:03:49,380
know so internals 101 I know there's at

00:03:47,609 --> 00:03:51,930
least two internals developers here any

00:03:49,380 --> 00:03:53,190
others actually this three which is good

00:03:51,930 --> 00:03:56,670
if you have questions later our pointer

00:03:53,190 --> 00:04:01,019
with them so the execution lifecycle of

00:03:56,670 --> 00:04:03,690
PHP that's what it looks like when you

00:04:01,019 --> 00:04:06,690
execute a PHP script it goes into the

00:04:03,690 --> 00:04:09,390
PHP interpreter binary it passes it into

00:04:06,690 --> 00:04:11,760
tokens compiles those into up codes then

00:04:09,390 --> 00:04:13,709
sends them through the zend engine which

00:04:11,760 --> 00:04:17,959
is virtual machine and we get our output

00:04:13,709 --> 00:04:20,489
and it's remarkably similar to the Java

00:04:17,959 --> 00:04:22,620
execution engine so people call PHP an

00:04:20,489 --> 00:04:23,970
interpreted language did not compile but

00:04:22,620 --> 00:04:25,950
it actually is it just happens every

00:04:23,970 --> 00:04:27,810
time right so with Java

00:04:25,950 --> 00:04:29,160
what happens as we pass we turn it in to

00:04:27,810 --> 00:04:32,010
bytecode which is their version of up

00:04:29,160 --> 00:04:33,960
codes and then we save it and then we

00:04:32,010 --> 00:04:36,990
run it through the vm time and time

00:04:33,960 --> 00:04:41,940
again that's quite similar so when you

00:04:36,990 --> 00:04:44,400
include an up cash with this one we

00:04:41,940 --> 00:04:46,560
execute we check the OP cash if it's

00:04:44,400 --> 00:04:48,060
there we just run it from shared memory

00:04:46,560 --> 00:04:49,710
so it's kind of like saving it to a

00:04:48,060 --> 00:04:52,020
binary file and executing a time and

00:04:49,710 --> 00:04:56,100
time again otherwise we pass it compile

00:04:52,020 --> 00:04:59,760
it save it and then run it today we're

00:04:56,100 --> 00:05:01,110
going to look at this bit the compiling

00:04:59,760 --> 00:05:04,490
actually look at tokens as well but

00:05:01,110 --> 00:05:04,490
compiling the opcodes and the execution

00:05:04,670 --> 00:05:09,930
so the first thing that happens is

00:05:07,110 --> 00:05:12,080
tokenizing and we're going to look at

00:05:09,930 --> 00:05:14,400
this which is the worst hello world ever

00:05:12,080 --> 00:05:18,780
if you could / engineer a hello world

00:05:14,400 --> 00:05:20,850
this would be it so we have a class

00:05:18,780 --> 00:05:23,310
greeting with a function say hello takes

00:05:20,850 --> 00:05:25,590
one variable and we echo out hello to

00:05:23,310 --> 00:05:28,730
and then we call it we instantiate the

00:05:25,590 --> 00:05:31,380
object and we pass in some information

00:05:28,730 --> 00:05:37,200
what this looks like when we tokenize it

00:05:31,380 --> 00:05:40,080
is this this came from when I was

00:05:37,200 --> 00:05:42,120
writing this talk i was getting the

00:05:40,080 --> 00:05:44,310
tokens out PHP and i was like great

00:05:42,120 --> 00:05:47,280
command line sort of dash are type code

00:05:44,310 --> 00:05:48,750
and i accidentally typed tokenize and

00:05:47,280 --> 00:05:50,250
the name of the script and it worked and

00:05:48,750 --> 00:05:51,470
threw out a wonderful table information

00:05:50,250 --> 00:05:54,240
on where the hell did this come from

00:05:51,470 --> 00:05:56,190
apparently passed me had written a

00:05:54,240 --> 00:05:58,260
script and put it in my path to actually

00:05:56,190 --> 00:06:01,680
do exactly this so as I passed me as

00:05:58,260 --> 00:06:03,420
brilliant currently is stupid so this is

00:06:01,680 --> 00:06:05,130
what tokens look like so basically

00:06:03,420 --> 00:06:07,890
tokens are typically consist of two

00:06:05,130 --> 00:06:09,630
things a name which identifies the token

00:06:07,890 --> 00:06:11,220
internally their numbers but they're

00:06:09,630 --> 00:06:13,830
just a constant that identifies the

00:06:11,220 --> 00:06:15,800
token and then a value for it some of

00:06:13,830 --> 00:06:18,570
them for example are curly braces

00:06:15,800 --> 00:06:20,430
parenthesis quotes anything that's

00:06:18,570 --> 00:06:22,020
basically a single character doesn't

00:06:20,430 --> 00:06:23,490
have a token associated with it because

00:06:22,020 --> 00:06:26,490
it would be larger than the character

00:06:23,490 --> 00:06:28,140
itself so looking at this code we can

00:06:26,490 --> 00:06:30,240
see we have an open tag we have our

00:06:28,140 --> 00:06:33,050
class we have some white space we'll see

00:06:30,240 --> 00:06:35,550
a lot of that string which is our

00:06:33,050 --> 00:06:38,400
identifier of greeting we open up the

00:06:35,550 --> 00:06:39,180
class with our curly brace and is anyone

00:06:38,400 --> 00:06:41,460
having problem

00:06:39,180 --> 00:06:43,370
reading this it's quite simple and there

00:06:41,460 --> 00:06:47,160
is some interesting stuff in here there

00:06:43,370 --> 00:06:48,449
will look at here there's a difference

00:06:47,160 --> 00:06:50,789
between interpolated and non

00:06:48,449 --> 00:06:53,460
interpolated strings so if we look back

00:06:50,789 --> 00:06:54,690
we have hello dollar two and then we

00:06:53,460 --> 00:06:59,310
have world which is just a straight

00:06:54,690 --> 00:07:01,020
string so they're both double quoted and

00:06:59,310 --> 00:07:03,240
I did this on purpose so a lot of people

00:07:01,020 --> 00:07:04,440
say oh you should use single quotes if

00:07:03,240 --> 00:07:07,259
you're not putting variables in it

00:07:04,440 --> 00:07:09,840
because it's faster and it's generally

00:07:07,259 --> 00:07:11,610
not because of this so basically there's

00:07:09,840 --> 00:07:14,310
no variables we end up with this T

00:07:11,610 --> 00:07:15,900
constant in scaped string and that's

00:07:14,310 --> 00:07:17,580
just our value whereas if there's

00:07:15,900 --> 00:07:20,099
variables and if we have our for tokens

00:07:17,580 --> 00:07:24,630
here the two quotes and then our

00:07:20,099 --> 00:07:26,849
straight string and our variable you can

00:07:24,630 --> 00:07:29,910
start to see why tokens can sort of

00:07:26,849 --> 00:07:31,229
matter for performance like looking at

00:07:29,910 --> 00:07:34,020
them can kind of give you some insight

00:07:31,229 --> 00:07:35,099
into what's going on under the hood but

00:07:34,020 --> 00:07:36,630
don't get caught up in micro

00:07:35,099 --> 00:07:39,389
optimizations which is pretty much what

00:07:36,630 --> 00:07:42,810
this talk is about so there's four ways

00:07:39,389 --> 00:07:44,729
that I know of to create strings the

00:07:42,810 --> 00:07:47,159
first one is double quoted with no

00:07:44,729 --> 00:07:48,930
variables single quoted obviously no

00:07:47,159 --> 00:07:51,510
variables and as you can see they're

00:07:48,930 --> 00:07:53,340
identical at this point if we add in a

00:07:51,510 --> 00:07:56,970
variable we go up to our for tokens

00:07:53,340 --> 00:07:59,039
interestingly if we go with this syntax

00:07:56,970 --> 00:08:01,770
which you'll often use for arrays or

00:07:59,039 --> 00:08:05,070
something inside of strings we add even

00:08:01,770 --> 00:08:07,139
more tokens so I said that all single

00:08:05,070 --> 00:08:09,990
characters and not they don't have a

00:08:07,139 --> 00:08:12,150
token this is the one exception that

00:08:09,990 --> 00:08:15,330
I've seen and this was to do with P it's

00:08:12,150 --> 00:08:17,009
kind of a it's actually to screw up it

00:08:15,330 --> 00:08:20,070
was something that was added for PHP 64

00:08:17,009 --> 00:08:22,590
string access character access and they

00:08:20,070 --> 00:08:25,099
removed it and left that in so you can

00:08:22,590 --> 00:08:27,449
pretty much ignore it but as you can see

00:08:25,099 --> 00:08:31,050
PHP can do a lot of different things

00:08:27,449 --> 00:08:35,669
with the same sort of code any questions

00:08:31,050 --> 00:08:37,560
on tokens okay so moving on from tokens

00:08:35,669 --> 00:08:40,529
we get to op codes and this is kind of

00:08:37,560 --> 00:08:42,779
where PHP actually does a lot of its

00:08:40,529 --> 00:08:44,219
work and if we're looking at op codes it

00:08:42,779 --> 00:08:45,990
means we're going to look at VL d which

00:08:44,219 --> 00:08:47,670
is the Vulcan logic dumper which was

00:08:45,990 --> 00:08:52,420
written by Derek returns he's speaking

00:08:47,670 --> 00:08:54,790
here as well and VL d is an extension

00:08:52,420 --> 00:08:57,670
that will dump the compiled opcodes the

00:08:54,790 --> 00:08:59,950
PHP cs2 pedal extensions so you can just

00:08:57,670 --> 00:09:03,100
pack will install the LD beta because

00:08:59,950 --> 00:09:05,230
everything in Pekel is beta add the

00:09:03,100 --> 00:09:07,360
following to your php.ini and then you

00:09:05,230 --> 00:09:09,459
just activate it on the command line so

00:09:07,360 --> 00:09:12,220
dash DVL deedar active equals 1 will

00:09:09,459 --> 00:09:14,589
turn it on and then you can set execute

00:09:12,220 --> 00:09:18,100
202 not actually execute the code just

00:09:14,589 --> 00:09:19,810
dump the opcodes and then VL d outputs

00:09:18,100 --> 00:09:22,990
for different three different things

00:09:19,810 --> 00:09:24,670
sorry it executes the global code so

00:09:22,990 --> 00:09:26,410
dumps the global code first anything

00:09:24,670 --> 00:09:28,420
that's in your main script it will dump

00:09:26,410 --> 00:09:30,100
all the op codes for that then it will

00:09:28,420 --> 00:09:33,550
dump the global functions and then it

00:09:30,100 --> 00:09:36,820
will dump class functions so looking at

00:09:33,550 --> 00:09:38,920
dumps they can be quite complicated they

00:09:36,820 --> 00:09:41,199
all start with a header which tells you

00:09:38,920 --> 00:09:44,010
in this case what class you're in what

00:09:41,199 --> 00:09:46,240
function you're in what file that you're

00:09:44,010 --> 00:09:49,510
executing and then the function again

00:09:46,240 --> 00:09:51,430
for some reason tells you the number of

00:09:49,510 --> 00:09:53,709
ops which is literally the number of op

00:09:51,430 --> 00:09:55,720
codes that have been dumped and it also

00:09:53,709 --> 00:09:58,180
tells you the compiled variables and

00:09:55,720 --> 00:10:01,510
this line is incredibly important i'll

00:09:58,180 --> 00:10:03,880
tell you why in a little bit under that

00:10:01,510 --> 00:10:08,019
we then actually have our dump of op

00:10:03,880 --> 00:10:09,550
codes so it's a table with a bunch of

00:10:08,019 --> 00:10:11,980
columns on so the first one is the line

00:10:09,550 --> 00:10:13,660
number in the source file the opcode

00:10:11,980 --> 00:10:17,350
number which is just a one through

00:10:13,660 --> 00:10:19,180
whatever list we have this star column

00:10:17,350 --> 00:10:21,910
which is terrible but basically it's the

00:10:19,180 --> 00:10:23,920
entry and exit points so when you enter

00:10:21,910 --> 00:10:27,160
into a function there will be a left

00:10:23,920 --> 00:10:29,980
aligned greater than symbol and when you

00:10:27,160 --> 00:10:33,329
exit so when you return there is a left

00:10:29,980 --> 00:10:37,180
writer line sorry greater than symbol

00:10:33,329 --> 00:10:40,230
the OP code name so those so be like

00:10:37,180 --> 00:10:44,100
zend ads and whatever also get to that

00:10:40,230 --> 00:10:46,660
fetching so basically anytime

00:10:44,100 --> 00:10:49,300
superglobal is accessed they'll be

00:10:46,660 --> 00:10:53,380
information in that column the EXT

00:10:49,300 --> 00:10:55,360
column is used it's just kind of a place

00:10:53,380 --> 00:10:58,930
to do stuff that's specific to an opcode

00:10:55,360 --> 00:11:01,149
there's no actual definitive purpose for

00:10:58,930 --> 00:11:02,890
it so for example for jumps it'll tell

00:11:01,149 --> 00:11:06,100
you where to jump to there are other

00:11:02,890 --> 00:11:08,829
uses for it any return data

00:11:06,100 --> 00:11:11,100
and then the upper ends used by any

00:11:08,829 --> 00:11:13,720
opcode so if you've got for example plus

00:11:11,100 --> 00:11:18,160
you'll have the either side of that in

00:11:13,720 --> 00:11:20,769
that column there are four types of

00:11:18,160 --> 00:11:24,130
variables and this is really important

00:11:20,769 --> 00:11:26,019
so ! prefixed ones are called compile

00:11:24,130 --> 00:11:28,930
variables and basically those are

00:11:26,019 --> 00:11:34,449
pointers to use a land variable so if we

00:11:28,930 --> 00:11:39,430
go back to hear this line here basically

00:11:34,449 --> 00:11:41,709
tells you that number like ! 0 is dollar

00:11:39,430 --> 00:11:43,779
to in New Zealand so that's how you can

00:11:41,709 --> 00:11:46,990
track what your user land variables are

00:11:43,779 --> 00:11:48,459
doing tilde prefixed ones they're

00:11:46,990 --> 00:11:50,680
temporary variables so whenever you do

00:11:48,459 --> 00:11:52,120
something in PHP that needs to store

00:11:50,680 --> 00:11:54,089
something temporarily under the hood

00:11:52,120 --> 00:11:57,399
they'll go into temporary variables

00:11:54,089 --> 00:11:59,620
unless it's something that needs to have

00:11:57,399 --> 00:12:01,839
ref counting which we'll get into then

00:11:59,620 --> 00:12:04,269
it has a dollar prefix and then the last

00:12:01,839 --> 00:12:07,420
one is colon prefixed which they're used

00:12:04,269 --> 00:12:09,459
for one thing only which is when the

00:12:07,420 --> 00:12:12,730
engine looks up a class in the hash

00:12:09,459 --> 00:12:14,889
table it stores it in colon prefixed

00:12:12,730 --> 00:12:16,540
ones I would like to say there is

00:12:14,889 --> 00:12:20,230
nothing that will syntax highlight this

00:12:16,540 --> 00:12:21,970
stuff so I did it all by hand so looking

00:12:20,230 --> 00:12:23,079
at the first part of our code so I'm

00:12:21,970 --> 00:12:24,490
actually doing this little backwards cuz

00:12:23,079 --> 00:12:26,410
i think is easier to understand this way

00:12:24,490 --> 00:12:29,410
so we're going to look at our class

00:12:26,410 --> 00:12:31,269
function call first so we're in class

00:12:29,410 --> 00:12:34,360
greeting function say hello we've got

00:12:31,269 --> 00:12:36,759
one compiled variable ! 0 which points

00:12:34,360 --> 00:12:39,009
to dollar two and then this is what it's

00:12:36,759 --> 00:12:41,709
actually doing when it executes say

00:12:39,009 --> 00:12:44,110
hello so the first thing we do is we

00:12:41,709 --> 00:12:47,589
receive an argument which you'll see is

00:12:44,110 --> 00:12:51,250
! 0 so that's dollar to being passed in

00:12:47,589 --> 00:12:52,569
we add a string so what we're doing here

00:12:51,250 --> 00:12:55,079
we're creating a temporary variable

00:12:52,569 --> 00:12:58,209
we're assigning the first part of our

00:12:55,079 --> 00:12:59,920
echo to it which is hello then we add a

00:12:58,209 --> 00:13:02,680
variable so we're adding we're basically

00:12:59,920 --> 00:13:05,110
concatenated our dollar to to our

00:13:02,680 --> 00:13:08,470
temporary variable and then we echo out

00:13:05,110 --> 00:13:10,300
the temporary variable okay and then

00:13:08,470 --> 00:13:15,630
lastly we return null because there's an

00:13:10,300 --> 00:13:19,480
implicit return any questions on that

00:13:15,630 --> 00:13:28,140
okay but once I instead bring a mic last

00:13:19,480 --> 00:13:28,140
month sorry hurry up this guy here

00:13:28,800 --> 00:13:33,880
shouldn't there be an echo for the hello

00:13:31,780 --> 00:13:36,460
I'm sorry second shouldn't the real echo

00:13:33,880 --> 00:13:37,900
4l oh no so because we have a temporary

00:13:36,460 --> 00:13:40,690
variable that contains the entire thing

00:13:37,900 --> 00:13:43,120
this tilde zero that actually contains

00:13:40,690 --> 00:13:45,400
the entire string so it first starts the

00:13:43,120 --> 00:13:47,950
temporary variable with hello ads on the

00:13:45,400 --> 00:13:52,390
value of dollar two and then it goes the

00:13:47,950 --> 00:13:55,600
whole deal and that's what that says we

00:13:52,390 --> 00:13:57,130
should have put that up earlier so now

00:13:55,600 --> 00:13:58,600
we're going to look at the global code

00:13:57,130 --> 00:14:01,480
so this is actually the code that cools

00:13:58,600 --> 00:14:04,720
that method so what's interesting for me

00:14:01,480 --> 00:14:07,120
here there's five lines of code there

00:14:04,720 --> 00:14:10,540
and only two here but this actually does

00:14:07,120 --> 00:14:12,940
a whole lot more so again we've got our

00:14:10,540 --> 00:14:16,750
compiled variables so our greeter which

00:14:12,940 --> 00:14:19,090
is our object ! zero so the first thing

00:14:16,750 --> 00:14:21,400
that we do here except for the knot will

00:14:19,090 --> 00:14:23,410
ignore that is we fetch the class so we

00:14:21,400 --> 00:14:26,590
go and look up the greeting class in the

00:14:23,410 --> 00:14:30,220
hash table and we store it in colon 1 so

00:14:26,590 --> 00:14:33,570
there's our fancy variable and then we

00:14:30,220 --> 00:14:35,770
instantiate it so we have the new opcode

00:14:33,570 --> 00:14:40,000
so basically what we're doing here is

00:14:35,770 --> 00:14:42,370
we're instantiate an instance of colon 1

00:14:40,000 --> 00:14:44,140
greeting and we're storing it in dollar

00:14:42,370 --> 00:14:46,390
too so the reason it's dollar to is

00:14:44,140 --> 00:14:49,150
objects need ref counting and like I

00:14:46,390 --> 00:14:50,680
said I will get to that I thought those

00:14:49,150 --> 00:14:54,570
slides were earlier like I said these

00:14:50,680 --> 00:14:57,850
are old slides anyways so we instantiate

00:14:54,570 --> 00:15:01,030
our instance of the class and then we

00:14:57,850 --> 00:15:02,890
actually call the constructor so it's

00:15:01,030 --> 00:15:08,220
actually a two-part operation so if

00:15:02,890 --> 00:15:11,680
anyone uses PDO and uses fetch object

00:15:08,220 --> 00:15:17,020
and you can assign a class that it'll

00:15:11,680 --> 00:15:19,600
create the record results set in by

00:15:17,020 --> 00:15:21,130
default it actually assigns all of the

00:15:19,600 --> 00:15:22,600
properties to their values from the

00:15:21,130 --> 00:15:25,900
columns before it calls the constructor

00:15:22,600 --> 00:15:27,190
and you actually have to tell it to do

00:15:25,900 --> 00:15:28,420
it after the instructor there's an

00:15:27,190 --> 00:15:30,160
argument to do that and the

00:15:28,420 --> 00:15:32,410
they can do that is because of this

00:15:30,160 --> 00:15:37,750
two-step process of instantiation an

00:15:32,410 --> 00:15:39,730
object next we assign our object in

00:15:37,750 --> 00:15:44,529
dollar to to our first compiled variable

00:15:39,730 --> 00:15:49,540
so our xma 2.0 so that's basically this

00:15:44,529 --> 00:15:51,880
equals and then we start calling our

00:15:49,540 --> 00:15:54,970
method so method calls are again a

00:15:51,880 --> 00:15:57,339
multi-step process so we initialize our

00:15:54,970 --> 00:15:59,440
method call so we're going to use our

00:15:57,339 --> 00:16:03,149
greeter variable with the say hello

00:15:59,440 --> 00:16:05,920
method we send in a value so basically

00:16:03,149 --> 00:16:10,660
we have a receive on the inside of the

00:16:05,920 --> 00:16:12,459
function that takes the argument and we

00:16:10,660 --> 00:16:16,750
have a sin Val that passes the arguments

00:16:12,459 --> 00:16:19,089
in and then we actually call the method

00:16:16,750 --> 00:16:21,220
so we initialize it send in values and

00:16:19,089 --> 00:16:24,310
then we actually execute the method and

00:16:21,220 --> 00:16:27,600
then finally we return 1 because there's

00:16:24,310 --> 00:16:38,290
an implicit return of one in global cove

00:16:27,600 --> 00:16:39,850
any questions so far all right so

00:16:38,290 --> 00:16:42,310
talking a little bit more about

00:16:39,850 --> 00:16:43,540
variables because let's be honest PHP is

00:16:42,310 --> 00:16:46,890
all about variables if you don't have

00:16:43,540 --> 00:16:49,480
variables it's a really language so

00:16:46,890 --> 00:16:50,920
under the hood I said if I could wake

00:16:49,480 --> 00:16:53,290
this guy up a big good talk and he's

00:16:50,920 --> 00:16:55,870
fallen asleep under the hood we use

00:16:53,290 --> 00:16:59,050
things called Z vows or Zen values these

00:16:55,870 --> 00:17:02,589
are AC data structure they used to still

00:16:59,050 --> 00:17:04,299
store all PHP variable data doesn't

00:17:02,589 --> 00:17:06,130
matter what type and they're probably

00:17:04,299 --> 00:17:07,689
the most important thing in pH peaks as

00:17:06,130 --> 00:17:09,610
I said it's a really language

00:17:07,689 --> 00:17:11,760
without variables so what does this look

00:17:09,610 --> 00:17:15,100
like so it's a struct calls eval struct

00:17:11,760 --> 00:17:18,549
we have four properties value which

00:17:15,100 --> 00:17:20,079
stores the actual data refcount GC which

00:17:18,549 --> 00:17:24,490
is for the number of references to the

00:17:20,079 --> 00:17:30,429
Cibao the data type and then whether the

00:17:24,490 --> 00:17:35,070
variable is a reference and then in that

00:17:30,429 --> 00:17:38,650
value property we have what's called a

00:17:35,070 --> 00:17:41,980
Zen value or as eval value and this is a

00:17:38,650 --> 00:17:45,880
C Union that actually stores the data

00:17:41,980 --> 00:17:47,380
does anyone know a union is because I

00:17:45,880 --> 00:17:50,049
just learned this for the talk okay so a

00:17:47,380 --> 00:17:51,850
union is a data structure that is each

00:17:50,049 --> 00:17:54,280
you can only store something in one of

00:17:51,850 --> 00:17:57,460
the properties and what's interesting

00:17:54,280 --> 00:18:01,929
about it is that it has the size of the

00:17:57,460 --> 00:18:03,730
largest member so basically this stores

00:18:01,929 --> 00:18:06,220
the actual data and it's strongly typed

00:18:03,730 --> 00:18:07,540
so when people say that PHP is not

00:18:06,220 --> 00:18:09,580
strongly typed under the hood it

00:18:07,540 --> 00:18:12,130
actually is and what's interesting is I

00:18:09,580 --> 00:18:13,900
tried I tried so hard to actually change

00:18:12,130 --> 00:18:18,480
the type of as eval from New Zealand and

00:18:13,900 --> 00:18:18,480
it's basically impossible if you cool

00:18:18,540 --> 00:18:22,360
castor there's a function to actually

00:18:20,530 --> 00:18:24,309
change a variable to another type it

00:18:22,360 --> 00:18:27,429
actually creates a another's eval under

00:18:24,309 --> 00:18:31,600
the hood the only way to change as evals

00:18:27,429 --> 00:18:34,090
type is with internals code C code it

00:18:31,600 --> 00:18:37,840
just switches out XIV as otherwise so in

00:18:34,090 --> 00:18:41,020
this value Union we have lungs for

00:18:37,840 --> 00:18:42,730
integers doubles for floats strings are

00:18:41,020 --> 00:18:46,419
represented by another struct which has

00:18:42,730 --> 00:18:48,880
the value and then length and then we

00:18:46,419 --> 00:18:52,179
have two special ones hash table is for

00:18:48,880 --> 00:18:57,429
arrays and zend object value of four

00:18:52,179 --> 00:19:00,880
object handles so as I said it is

00:18:57,429 --> 00:19:02,290
strongly typed at the sea level PHP

00:19:00,880 --> 00:19:04,120
curse is the data automatically the

00:19:02,290 --> 00:19:06,370
things like comparisons so what will

00:19:04,120 --> 00:19:10,450
happen is when you do a comparison it'll

00:19:06,370 --> 00:19:15,730
check the type in this structure and

00:19:10,450 --> 00:19:19,030
then coerce it based on that so it never

00:19:15,730 --> 00:19:21,900
actually changes the d Val there are

00:19:19,030 --> 00:19:28,360
nine types of data that gets stored in

00:19:21,900 --> 00:19:32,020
one two three four five places nulls

00:19:28,360 --> 00:19:33,910
don't get stored there just null as I

00:19:32,020 --> 00:19:37,030
said in two just go into Long's floats

00:19:33,910 --> 00:19:40,090
go into D Val strings go into that

00:19:37,030 --> 00:19:41,580
structure arrays go into HT and objects

00:19:40,090 --> 00:19:44,140
and objects know what's interesting is

00:19:41,580 --> 00:19:47,320
bullion's and resources there's a typo

00:19:44,140 --> 00:19:49,510
damn it they go into the L Val because

00:19:47,320 --> 00:19:53,140
basically their numbers 0 or 1 for

00:19:49,510 --> 00:19:54,549
billions or the resource identifiers the

00:19:53,140 --> 00:19:54,960
reason for that actually is memory

00:19:54,549 --> 00:19:57,210
saving

00:19:54,960 --> 00:19:59,549
said the structure is as large as its

00:19:57,210 --> 00:20:02,640
largest member so adding like a boolean

00:19:59,549 --> 00:20:05,700
type extra member just for billions

00:20:02,640 --> 00:20:09,270
doesn't save you any memory so they just

00:20:05,700 --> 00:20:13,710
reuse the long location and then the

00:20:09,270 --> 00:20:20,669
type property in the Z val is set to one

00:20:13,710 --> 00:20:23,130
of those constants so references and

00:20:20,669 --> 00:20:26,490
copy-on-write so PHP has something I

00:20:23,130 --> 00:20:29,700
think is amazing to avoid copying data

00:20:26,490 --> 00:20:31,230
when you pass variables around it uses

00:20:29,700 --> 00:20:32,490
something called copy-on-write and it

00:20:31,230 --> 00:20:35,039
does this by doing something called

00:20:32,490 --> 00:20:37,230
reference counting so when you assign

00:20:35,039 --> 00:20:39,330
one variable to another it's actually

00:20:37,230 --> 00:20:42,510
always a reference under the hood until

00:20:39,330 --> 00:20:45,210
the data changes but this is different

00:20:42,510 --> 00:20:47,659
from PHP references the ampersand but

00:20:45,210 --> 00:20:50,010
it's easier to show with examples so I

00:20:47,659 --> 00:20:52,610
stole this from the internals book and

00:20:50,010 --> 00:20:55,559
the guy over there wrote is here so

00:20:52,610 --> 00:20:57,840
create a variable dollar a we create as

00:20:55,559 --> 00:21:01,260
eval one that goes along with that value

00:20:57,840 --> 00:21:04,260
of one ref count of one we assign it to

00:21:01,260 --> 00:21:06,029
another variable B and what we actually

00:21:04,260 --> 00:21:08,159
do rather than create a copy even though

00:21:06,029 --> 00:21:11,970
it's not a reference we just increment

00:21:08,159 --> 00:21:14,159
the ref count we assigned B to C we

00:21:11,970 --> 00:21:16,770
increment it again so internally they're

00:21:14,159 --> 00:21:19,529
all using one piece of memory because

00:21:16,770 --> 00:21:22,500
none of them are changing the value as

00:21:19,529 --> 00:21:24,750
soon as you update any one of these it

00:21:22,500 --> 00:21:27,539
then d references under the hood and

00:21:24,750 --> 00:21:30,860
it's smart because even though the

00:21:27,539 --> 00:21:33,360
originals eval was dollar a when we

00:21:30,860 --> 00:21:34,890
increment dollar a that's the only one

00:21:33,360 --> 00:21:36,600
that gets an Uzi vow it doesn't do

00:21:34,890 --> 00:21:38,330
something stupid by saying this was the

00:21:36,600 --> 00:21:40,649
first one so we'll move all the others

00:21:38,330 --> 00:21:43,260
it only changes the one you're changing

00:21:40,649 --> 00:21:46,289
so what ends up happening is B and C

00:21:43,260 --> 00:21:49,380
still point to Z Val one the ref count

00:21:46,289 --> 00:21:51,779
gets decremented now 22 and we create an

00:21:49,380 --> 00:21:54,679
Uzi valve which is representing dollar a

00:21:51,779 --> 00:21:58,350
with a ref count of one this is great

00:21:54,679 --> 00:22:01,440
memory savings and such what if we then

00:21:58,350 --> 00:22:04,889
unset one of them in this case B we just

00:22:01,440 --> 00:22:06,809
decrement the ref count so unsetting

00:22:04,889 --> 00:22:08,540
stuff doesn't necessarily save you

00:22:06,809 --> 00:22:11,700
memory

00:22:08,540 --> 00:22:13,770
if we then unset see which is everything

00:22:11,700 --> 00:22:16,559
that pointed to the first eval that Z

00:22:13,770 --> 00:22:18,809
vow is finally destroyed so unset can

00:22:16,559 --> 00:22:20,340
help you in the long run but if you've

00:22:18,809 --> 00:22:21,540
got some sort of weird references that

00:22:20,340 --> 00:22:23,520
you're not cleaning up it's not really

00:22:21,540 --> 00:22:29,280
getting you anything and of course a is

00:22:23,520 --> 00:22:32,250
still see Val too if we actually use

00:22:29,280 --> 00:22:36,000
references anyone have a question on

00:22:32,250 --> 00:22:39,120
that okay if we actually use PHP

00:22:36,000 --> 00:22:40,799
references what ends up happening is we

00:22:39,120 --> 00:22:41,970
have the same thing with those evals and

00:22:40,799 --> 00:22:44,520
the ref counts but there's another

00:22:41,970 --> 00:22:46,470
property called is ref and basically

00:22:44,520 --> 00:22:48,419
what that means is that when you start

00:22:46,470 --> 00:22:52,350
doing things like incrementing it stops

00:22:48,419 --> 00:22:53,610
it from creating copies it continues to

00:22:52,350 --> 00:22:55,410
update the original so that's why

00:22:53,610 --> 00:22:59,490
everyone updates that's how the

00:22:55,410 --> 00:23:01,679
references work so it checks is where f

00:22:59,490 --> 00:23:03,660
is 0 or 1 if it's a zero they creates a

00:23:01,679 --> 00:23:05,760
copy for the one being modified if it's

00:23:03,660 --> 00:23:09,860
a one it does it in place and everything

00:23:05,760 --> 00:23:09,860
that's pointing to it then is updated

00:23:11,630 --> 00:23:21,120
okay this one's interesting because it

00:23:15,690 --> 00:23:23,100
combines the two AE equals 101 ref count

00:23:21,120 --> 00:23:26,760
one is rf0 and creating the references

00:23:23,100 --> 00:23:29,100
yet B equals a ref count to store no

00:23:26,760 --> 00:23:31,799
references C equals B so this is the

00:23:29,100 --> 00:23:34,520
same as our first example ref count 3 is

00:23:31,799 --> 00:23:38,070
where f0 now if we create a reference

00:23:34,520 --> 00:23:42,049
again PHP's quite smart about this it

00:23:38,070 --> 00:23:45,540
will create tues evals not three or four

00:23:42,049 --> 00:23:47,400
the ones that are not referenced go on

00:23:45,540 --> 00:23:48,780
the first one and then it creates a

00:23:47,400 --> 00:23:52,710
second one just for the two that are

00:23:48,780 --> 00:23:55,620
referenced to each other Saudi as a

00:23:52,710 --> 00:23:57,780
reference of C but not avail be so

00:23:55,620 --> 00:24:01,020
there's eat wow that's not wall the

00:23:57,780 --> 00:24:02,549
sieve how needs to be coming here so

00:24:01,020 --> 00:24:05,070
basically we have two copies of the same

00:24:02,549 --> 00:24:08,610
Z vow in terms of content except that

00:24:05,070 --> 00:24:11,760
one is is ref and one is this ref one if

00:24:08,610 --> 00:24:14,880
we then increment d they stay in place

00:24:11,760 --> 00:24:18,110
because those are referenced and the

00:24:14,880 --> 00:24:18,110
original one never gets changed

00:24:19,339 --> 00:24:24,690
so I will say there's a talk later by

00:24:22,859 --> 00:24:26,729
Julian who's in here on the op cash

00:24:24,690 --> 00:24:28,949
there may be a little bit of overlap but

00:24:26,729 --> 00:24:30,989
his is much more in-depth on it so

00:24:28,949 --> 00:24:33,690
optimizing opcodes this is something

00:24:30,989 --> 00:24:37,409
that send optimizer odds end up cash as

00:24:33,690 --> 00:24:38,969
it's called will do incrementing by one

00:24:37,409 --> 00:24:43,109
is more than one way to do it because

00:24:38,969 --> 00:24:46,889
it's PHP well most languages really the

00:24:43,109 --> 00:24:49,709
first one i equals 1 i plus plus so

00:24:46,889 --> 00:24:52,199
we're going to post increment the first

00:24:49,709 --> 00:24:56,459
thing that we do so before i go into any

00:24:52,199 --> 00:24:59,729
questions on the ok the first thing we

00:24:56,459 --> 00:25:02,369
do is we assign our value of 1 to our

00:24:59,729 --> 00:25:03,749
first compiled variable and then we do

00:25:02,369 --> 00:25:05,459
what's called a post increments so we

00:25:03,749 --> 00:25:08,519
increment the cv the empower variable

00:25:05,459 --> 00:25:10,829
not and not ! 0 and we store it in our

00:25:08,519 --> 00:25:12,839
temporary variable till the one and then

00:25:10,829 --> 00:25:15,749
we immediately free it because we've not

00:25:12,839 --> 00:25:21,059
used it this is why it's an optimization

00:25:15,749 --> 00:25:23,699
if you pre-increment then all we do is

00:25:21,059 --> 00:25:25,169
we assign and we increment it in place

00:25:23,699 --> 00:25:26,789
we don't create a temporary variable

00:25:25,169 --> 00:25:29,669
this is one of those tiny micro

00:25:26,789 --> 00:25:31,649
optimizations that don't matter but it's

00:25:29,669 --> 00:25:33,749
really interesting to note as end up

00:25:31,649 --> 00:25:34,949
cash will do this optimization for you

00:25:33,749 --> 00:25:43,799
if there's no assignment it'll actually

00:25:34,949 --> 00:25:49,079
under the hood switch them so i equals 1

00:25:43,799 --> 00:25:52,529
i equals i plus 1 we assign our one to

00:25:49,079 --> 00:25:54,359
our first empower variable we add one to

00:25:52,529 --> 00:25:58,319
the to the compiler variable and assign

00:25:54,359 --> 00:26:00,690
it to a temporary and then we that's it

00:25:58,319 --> 00:26:02,549
we assign the temporary to back to the

00:26:00,690 --> 00:26:05,489
variable itself this is why in some

00:26:02,549 --> 00:26:07,669
languages you can't assign a variable

00:26:05,489 --> 00:26:10,079
back to itself because it's modifying

00:26:07,669 --> 00:26:12,059
itself right the way PHP gets around

00:26:10,079 --> 00:26:13,739
that is it create a temporary variable

00:26:12,059 --> 00:26:16,919
for the right-hand side of the upper end

00:26:13,739 --> 00:26:20,239
stores that and then assigned it back to

00:26:16,919 --> 00:26:20,239
the variable that is started out with

00:26:21,979 --> 00:26:27,679
plus equals 1 so this is kind of a

00:26:25,529 --> 00:26:30,659
shortcut these these operators are

00:26:27,679 --> 00:26:33,119
probably the best way to go about

00:26:30,659 --> 00:26:34,320
I I always use plus equals one not

00:26:33,119 --> 00:26:35,580
because it's a performance thing but I

00:26:34,320 --> 00:26:36,690
always assume at some point I'm going to

00:26:35,580 --> 00:26:38,820
go back and say I need it to be more

00:26:36,690 --> 00:26:42,090
than one so I hate post and pre

00:26:38,820 --> 00:26:44,249
increment so basically we assign one to

00:26:42,090 --> 00:26:47,009
our compiled variable and then we do an

00:26:44,249 --> 00:26:48,809
assign ad which is an in-place edition

00:26:47,009 --> 00:26:58,440
of whatever the right operand is in this

00:26:48,809 --> 00:27:02,429
case one any questions on those okay so

00:26:58,440 --> 00:27:04,799
back to strings quoting them strings I'm

00:27:02,429 --> 00:27:07,950
going to just do an echo of single

00:27:04,799 --> 00:27:15,809
quotes and it literally is just echo the

00:27:07,950 --> 00:27:17,669
string same thing for double quotes now

00:27:15,809 --> 00:27:21,479
we get a bit complicated so simple

00:27:17,669 --> 00:27:24,809
interpolation we have one compiled

00:27:21,479 --> 00:27:26,609
variable dulla a we assign the value

00:27:24,809 --> 00:27:29,970
which is foo in this case to our

00:27:26,609 --> 00:27:34,919
compiled variable we create a temporary

00:27:29,970 --> 00:27:38,070
variable X tilde one and we assign of a

00:27:34,919 --> 00:27:40,349
compiled variable to it we add a string

00:27:38,070 --> 00:27:43,109
so this is very similar to our hello

00:27:40,349 --> 00:27:44,849
world from earlier we add the rest of

00:27:43,109 --> 00:27:48,979
the string to the temporary variable and

00:27:44,849 --> 00:27:48,979
then we echo out the temporary variable

00:27:50,179 --> 00:27:55,590
complex interpolation see you remember

00:27:52,590 --> 00:27:56,940
if looking at the tokens this created a

00:27:55,590 --> 00:28:01,559
whole bunch more tokens for the curly

00:27:56,940 --> 00:28:07,340
braces on the opcode level of actually

00:28:01,559 --> 00:28:07,340
identical I found that interested

00:28:08,210 --> 00:28:18,749
concatenation any questions on so simple

00:28:14,429 --> 00:28:24,419
concatenation so a equals foo I equals a

00:28:18,749 --> 00:28:26,940
bar 1 compiled variable a we assign the

00:28:24,419 --> 00:28:30,960
value of food to a then we use the

00:28:26,940 --> 00:28:32,519
concat opcode we can cat the to the

00:28:30,960 --> 00:28:34,470
compile variable and bar and we assign

00:28:32,519 --> 00:28:36,239
it to a temporary variable then we

00:28:34,470 --> 00:28:38,190
assign that back to our compiled

00:28:36,239 --> 00:28:40,889
variable that's the right hand versus

00:28:38,190 --> 00:28:44,149
the left hand of the equal sign and then

00:28:40,889 --> 00:28:44,149
we have the implicit return

00:28:44,749 --> 00:28:50,340
but we also have a sign think at and as

00:28:47,309 --> 00:28:54,299
I said these double sort of operators

00:28:50,340 --> 00:28:56,519
are the best so we assign food to our

00:28:54,299 --> 00:28:58,049
compiled variable and then we do an

00:28:56,519 --> 00:29:00,840
in-place concatenation there's no

00:28:58,049 --> 00:29:04,259
temporary variable created by dot equals

00:29:00,840 --> 00:29:06,179
i would say i would want to say if you

00:29:04,259 --> 00:29:07,769
do performance tweaking based on this

00:29:06,179 --> 00:29:12,570
talk again you're in trouble please

00:29:07,769 --> 00:29:14,279
don't so we already talked a little bit

00:29:12,570 --> 00:29:15,389
about method calls but our function

00:29:14,279 --> 00:29:17,909
calls but I do want to go into it a bit

00:29:15,389 --> 00:29:21,179
more so calling something like PHP info

00:29:17,909 --> 00:29:25,109
with no arguments it's a single call to

00:29:21,179 --> 00:29:29,039
F call as soon as you start adding

00:29:25,109 --> 00:29:30,690
arguments for example bc-ad we have the

00:29:29,039 --> 00:29:33,869
send values which is passing in

00:29:30,690 --> 00:29:37,200
parameters and the do f cool so actually

00:29:33,869 --> 00:29:39,539
call it there's no in it here because

00:29:37,200 --> 00:29:45,509
it's not a straight function it's not a

00:29:39,539 --> 00:29:47,549
class method so we basically you up the

00:29:45,509 --> 00:29:49,590
two arguments to send in and then we

00:29:47,549 --> 00:29:57,869
actually do the function call with those

00:29:49,590 --> 00:29:59,609
two arguments I then created the same

00:29:57,869 --> 00:30:03,599
function basically bc-ad but without all

00:29:59,609 --> 00:30:05,220
the specialness in userland so basically

00:30:03,599 --> 00:30:07,519
pass into arguments are not add them

00:30:05,220 --> 00:30:09,929
together it's not very complicated

00:30:07,519 --> 00:30:12,330
looking at this on the user land side we

00:30:09,929 --> 00:30:16,769
can actually see that it's identical so

00:30:12,330 --> 00:30:18,059
send in two values do the f cool but in

00:30:16,769 --> 00:30:22,200
this case we can actually look at the

00:30:18,059 --> 00:30:24,210
other side so as I said for every send

00:30:22,200 --> 00:30:27,059
vowel on the opposite side we have a

00:30:24,210 --> 00:30:29,309
receive so we can receive two arguments

00:30:27,059 --> 00:30:32,009
we assign them to zero and one our

00:30:29,309 --> 00:30:34,229
compiled variables at the top here we

00:30:32,009 --> 00:30:37,019
add the two variables an assignment to a

00:30:34,229 --> 00:30:39,599
temporary variable tilde zero we then

00:30:37,019 --> 00:30:41,820
assign that to our third compile

00:30:39,599 --> 00:30:45,840
variables see i wish i had to code up

00:30:41,820 --> 00:30:48,029
here and then finally we return our

00:30:45,840 --> 00:30:49,769
third compile variable so what this code

00:30:48,029 --> 00:30:54,390
looks like this function add two

00:30:49,769 --> 00:31:01,530
arguments of a and b c equals a plus B

00:30:54,390 --> 00:31:05,490
return it method overloading any

00:31:01,530 --> 00:31:15,960
questions before I get on to this one so

00:31:05,490 --> 00:31:19,260
what oh hang on Mike in the previous

00:31:15,960 --> 00:31:22,100
slide yes why were there two returns to

00:31:19,260 --> 00:31:25,770
two cents I'll to receives return oh

00:31:22,100 --> 00:31:27,720
okay there's always an implicit return

00:31:25,770 --> 00:31:30,330
in case this one is sort of inside of a

00:31:27,720 --> 00:31:32,190
conditional right okay so even if it

00:31:30,330 --> 00:31:34,290
doesn't need it it puts it in there yes

00:31:32,190 --> 00:31:36,270
it's still there now then I'll cash me

00:31:34,290 --> 00:31:43,230
take that out I don't Julian Gino if it

00:31:36,270 --> 00:31:46,170
does okay so method overloading so

00:31:43,230 --> 00:31:49,770
double underscore cool this now starts

00:31:46,170 --> 00:31:51,720
to get complicated the first thing okay

00:31:49,770 --> 00:31:54,090
so we've got class foo public function

00:31:51,720 --> 00:31:57,930
bar public function double underscore

00:31:54,090 --> 00:32:00,180
cool so two variables go into that we

00:31:57,930 --> 00:32:02,580
instantiate food we call bar which

00:32:00,180 --> 00:32:03,930
exists and we call back which doesn't so

00:32:02,580 --> 00:32:07,470
it'll go through double underscore cool

00:32:03,930 --> 00:32:09,840
so the first thing that we do is we look

00:32:07,470 --> 00:32:12,630
up the class so foo we assign it to our

00:32:09,840 --> 00:32:14,880
colon one temporary variable we

00:32:12,630 --> 00:32:17,550
instantiate it with the new and we

00:32:14,880 --> 00:32:20,820
assign it to our compiled to our special

00:32:17,550 --> 00:32:22,200
dollar sign prefixed temporary variable

00:32:20,820 --> 00:32:26,310
so we need ref counting because it's an

00:32:22,200 --> 00:32:30,300
object sorry we do f call by name so we

00:32:26,310 --> 00:32:38,240
recall we call the constructor the great

00:32:30,300 --> 00:32:40,860
fat and water and then we assign the

00:32:38,240 --> 00:32:47,880
instantiated object in dollar to to our

00:32:40,860 --> 00:32:49,170
compiled variable ! 0 then we cool we

00:32:47,880 --> 00:32:50,550
start calling the method so as I said

00:32:49,170 --> 00:32:53,220
now we're inside of a class we've got

00:32:50,550 --> 00:32:56,430
this in it type process so we start

00:32:53,220 --> 00:32:59,790
calling a method called bar and we

00:32:56,430 --> 00:33:02,090
execute it then we start calling a

00:32:59,790 --> 00:33:04,200
method called bat and we execute if

00:33:02,090 --> 00:33:06,560
anyone noticed anything interesting

00:33:04,200 --> 00:33:06,560
about this

00:33:10,920 --> 00:33:20,080
hmm yes so on the opcode level there's

00:33:17,830 --> 00:33:21,990
actually no difference between hitting

00:33:20,080 --> 00:33:24,820
bar and hitting double underscore cool

00:33:21,990 --> 00:33:28,600
it all happens actually internally in

00:33:24,820 --> 00:33:30,250
the sea level code so this do f call by

00:33:28,600 --> 00:33:31,720
name actually decides whether it's going

00:33:30,250 --> 00:33:34,420
to go through double underscore cool or

00:33:31,720 --> 00:33:36,160
not so you can't actually tell some

00:33:34,420 --> 00:33:47,100
parts of your slow downs just by looking

00:33:36,160 --> 00:33:47,100
at the opcodes wasn't prepared for that

00:33:49,200 --> 00:34:04,900
got to say any questions hi why is it

00:34:02,620 --> 00:34:06,220
always a knob at the start I actually

00:34:04,900 --> 00:34:07,510
don't know who the answer to that and I

00:34:06,220 --> 00:34:11,530
asked someone who should and they don't

00:34:07,510 --> 00:34:14,110
know either so zend up cash will kind of

00:34:11,530 --> 00:34:16,000
remove extra nops zend up cash will also

00:34:14,110 --> 00:34:17,470
do things like if there's a jump that

00:34:16,000 --> 00:34:19,419
skips other jumps and other things like

00:34:17,470 --> 00:34:22,600
i tol just get rid of branches they

00:34:19,419 --> 00:34:25,270
can't reach but yeah if when I first did

00:34:22,600 --> 00:34:28,030
the all the slides for this I had XD bug

00:34:25,270 --> 00:34:30,520
turned on and that injected a whole

00:34:28,030 --> 00:34:32,139
bunch of extra op codes and Sarah

00:34:30,520 --> 00:34:34,629
Goldman went what are those do it in

00:34:32,139 --> 00:34:35,980
there javax debugger I went yes so she

00:34:34,629 --> 00:34:37,990
need to turn it off and redo all your

00:34:35,980 --> 00:34:41,230
slides and of course with the custom

00:34:37,990 --> 00:34:42,960
syntax highlighting a lot of fun any

00:34:41,230 --> 00:34:51,700
other questions or do you have more

00:34:42,960 --> 00:34:53,440
thank you anyone else help you sort of

00:34:51,700 --> 00:34:55,510
gave a disclaimer through a lot of the

00:34:53,440 --> 00:34:59,140
talk about don't bother optimizing this

00:34:55,510 --> 00:35:01,270
yes are there any worthwhile going to be

00:34:59,140 --> 00:35:04,600
made through optimization by

00:35:01,270 --> 00:35:06,580
understanding internals I definitely

00:35:04,600 --> 00:35:09,430
feel like having never want to hear the

00:35:06,580 --> 00:35:11,260
question I definitely feel that

00:35:09,430 --> 00:35:12,700
understanding this stuff makes you a

00:35:11,260 --> 00:35:15,460
better programmer which is why I decided

00:35:12,700 --> 00:35:16,530
to give this talk I wish I'd understood

00:35:15,460 --> 00:35:20,850
it

00:35:16,530 --> 00:35:22,500
probably five years ago but practically

00:35:20,850 --> 00:35:26,370
not really and that's why I dropped the

00:35:22,500 --> 00:35:34,260
performance out of the title so anyone

00:35:26,370 --> 00:35:35,790
else oh it's Nate no this isn't a

00:35:34,260 --> 00:35:37,860
scary one I actually just wanted to know

00:35:35,790 --> 00:35:38,760
how copy-on-write works across function

00:35:37,860 --> 00:35:41,940
calls like when you're passing

00:35:38,760 --> 00:35:44,340
parameters and things like that the same

00:35:41,940 --> 00:35:46,290
way does evals it's just passing

00:35:44,340 --> 00:35:48,540
references to the sea vows okay so under

00:35:46,290 --> 00:35:52,460
the hood it's just one global list of z

00:35:48,540 --> 00:35:57,750
Val's in other words yes gotcha thanks

00:35:52,460 --> 00:36:01,920
anyone else please put a lot of time

00:35:57,750 --> 00:36:05,250
left all right so if you have any

00:36:01,920 --> 00:36:08,190
feedback joined in or Twitter prefer

00:36:05,250 --> 00:36:09,810
joined in emailed a v8 engine yard calm

00:36:08,190 --> 00:36:11,880
and the slides will be up at david

00:36:09,810 --> 00:36:15,410
shaffer calm / slides thank you very

00:36:11,880 --> 00:36:15,410

YouTube URL: https://www.youtube.com/watch?v=bHZX-CM-qQc


