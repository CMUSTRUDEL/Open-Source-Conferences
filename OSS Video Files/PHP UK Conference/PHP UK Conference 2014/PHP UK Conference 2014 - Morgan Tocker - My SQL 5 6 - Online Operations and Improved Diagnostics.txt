Title: PHP UK Conference 2014 - Morgan Tocker - My SQL 5 6 - Online Operations and Improved Diagnostics
Publication date: 2014-03-24
Playlist: PHP UK Conference 2014
Description: 
	MySQL 5.6 was released in February 2013. It is the largest release of MySQL in history (measured by code size increase) and contains a number of very useful enhancements to replication, performance and security. What I want to talk about however is how it's now much easier to run in production with features like online DDL and performance_schema.
Captions: 
	00:00:05,940 --> 00:00:12,480
okay hello everyone thank you for coming

00:00:08,940 --> 00:00:15,990
to the last toca today my name is Morgan

00:00:12,480 --> 00:00:17,730
I work for oracle on MySQL just before

00:00:15,990 --> 00:00:20,550
we get started this is Oracle's safe

00:00:17,730 --> 00:00:23,250
harbor statement it basically says that

00:00:20,550 --> 00:00:26,610
if I talk about upcoming features I have

00:00:23,250 --> 00:00:28,710
a couple of slides on MySQL 57 I can't

00:00:26,610 --> 00:00:32,700
commit two dates can't commit to things

00:00:28,710 --> 00:00:33,930
might change slightly at Oracle I showed

00:00:32,700 --> 00:00:37,110
this slide yesterday as well we're

00:00:33,930 --> 00:00:40,050
celebrating our fourth birthday being

00:00:37,110 --> 00:00:43,949
the steward of MySQL we celebrated this

00:00:40,050 --> 00:00:46,769
last month some interesting things that

00:00:43,949 --> 00:00:50,069
we managed to do in that time is release

00:00:46,769 --> 00:00:53,879
mysql 5.5 a lot of improvements for

00:00:50,069 --> 00:00:56,819
inner DB and scaling mysql on multi-core

00:00:53,879 --> 00:00:58,710
machines I you know there's a little

00:00:56,819 --> 00:01:00,629
toka scale out but scale up is also very

00:00:58,710 --> 00:01:02,460
important because it's the easiest way

00:01:00,629 --> 00:01:06,210
to be able to retrofit performance to an

00:01:02,460 --> 00:01:11,070
application so I like that aspect mysql

00:01:06,210 --> 00:01:13,860
56 has a lot of stuff so much stuff in

00:01:11,070 --> 00:01:16,620
fact that i chose not to specifically

00:01:13,860 --> 00:01:19,530
talk about mysql 56 but one aspect of

00:01:16,620 --> 00:01:21,920
that and that's how it's easier for

00:01:19,530 --> 00:01:26,040
operations people to be able to use now

00:01:21,920 --> 00:01:28,500
something I care about a lot previously

00:01:26,040 --> 00:01:30,950
doing consulting I work for a company

00:01:28,500 --> 00:01:34,050
pakona that runs my eyes conform spoke

00:01:30,950 --> 00:01:36,420
there needs to be a huge focus on

00:01:34,050 --> 00:01:38,760
databases in how to manage them and get

00:01:36,420 --> 00:01:41,810
performance often you'll find that

00:01:38,760 --> 00:01:43,590
someone has a performance problem and

00:01:41,810 --> 00:01:45,090
they're not really getting the

00:01:43,590 --> 00:01:46,500
performance that they're entitled to

00:01:45,090 --> 00:01:49,980
because they don't have the visibility

00:01:46,500 --> 00:01:51,690
to see that and so I want to focus a lot

00:01:49,980 --> 00:01:53,970
on that which is the the diagnostic

00:01:51,690 --> 00:01:56,040
enhancements that we have in mysql 56

00:01:53,970 --> 00:02:00,200
and some other features that make it

00:01:56,040 --> 00:02:04,320
easier if you're a DV a DevOps person or

00:02:00,200 --> 00:02:06,570
somewhere in between I'll give it a

00:02:04,320 --> 00:02:09,179
quick introduction to mysql 56 as well

00:02:06,570 --> 00:02:14,190
and our development model but it won't

00:02:09,179 --> 00:02:16,950
be my main focus so with that that quick

00:02:14,190 --> 00:02:19,110
introduction let me tell you about my

00:02:16,950 --> 00:02:21,720
skills development

00:02:19,110 --> 00:02:24,300
model and how we develop each new

00:02:21,720 --> 00:02:28,020
release of MySQL at the moment as I said

00:02:24,300 --> 00:02:33,720
when i'm working on mysql 5.7 mysql 5.6

00:02:28,020 --> 00:02:36,240
it was g aid in February 2013 so under

00:02:33,720 --> 00:02:39,330
Oracle the way that that MySQL releases

00:02:36,240 --> 00:02:42,630
happens has changed what we do is up to

00:02:39,330 --> 00:02:45,180
four times per year we release what we

00:02:42,630 --> 00:02:49,440
call a DMR or development milestone

00:02:45,180 --> 00:02:51,360
release and this is intended to have new

00:02:49,440 --> 00:02:53,340
features that have been high-level

00:02:51,360 --> 00:02:55,680
reviewed and how you interact with them

00:02:53,340 --> 00:02:57,870
low level reviewed into how the

00:02:55,680 --> 00:02:59,760
architecture and code works and and

00:02:57,870 --> 00:03:02,820
tested with eighty percent plus code

00:02:59,760 --> 00:03:04,050
coverage that they're somewhat stable we

00:03:02,820 --> 00:03:07,620
aim for them to be about a release

00:03:04,050 --> 00:03:09,150
candidate and we release up to four of

00:03:07,620 --> 00:03:11,580
these per year as I said with with new

00:03:09,150 --> 00:03:13,560
features and this is your opportunity to

00:03:11,580 --> 00:03:16,800
be able to test them and see what's

00:03:13,560 --> 00:03:19,470
going to be happening next we roll up

00:03:16,800 --> 00:03:20,910
these development milestones every two

00:03:19,470 --> 00:03:23,910
to three years and then we make a major

00:03:20,910 --> 00:03:26,790
release so it took two years in a couple

00:03:23,910 --> 00:03:30,540
of months between mysql 5.5 and mysql

00:03:26,790 --> 00:03:32,640
5.6 release to happen I this is going to

00:03:30,540 --> 00:03:35,010
be quite predictable moving forward

00:03:32,640 --> 00:03:37,410
based on this development model

00:03:35,010 --> 00:03:39,060
everything must be tested everything

00:03:37,410 --> 00:03:41,459
must work first before it's sort of

00:03:39,060 --> 00:03:43,709
merged into trunk I guess as you might

00:03:41,459 --> 00:03:45,750
call as a developer so we started off

00:03:43,709 --> 00:03:49,739
with optimizer enhancements in ADV

00:03:45,750 --> 00:03:53,549
enhancements I later on more optimizer

00:03:49,739 --> 00:03:55,290
mourinho TV it's very agile in that when

00:03:53,549 --> 00:03:58,350
we set out without our plans of what

00:03:55,290 --> 00:03:59,820
we're aiming for a MySQL 56 will get

00:03:58,350 --> 00:04:01,560
hopefully most of them done but we might

00:03:59,820 --> 00:04:05,040
change some of those plants and we're

00:04:01,560 --> 00:04:07,739
able to react to market needs if other

00:04:05,040 --> 00:04:09,510
features work out being more desirable

00:04:07,739 --> 00:04:13,620
or more important to be able to

00:04:09,510 --> 00:04:16,470
integrate so 56 I said it has a lot of

00:04:13,620 --> 00:04:18,900
stuff by lines of code there was

00:04:16,470 --> 00:04:22,650
actually this interesting analysis by a

00:04:18,900 --> 00:04:27,330
guy named stuart smith networks for IBM

00:04:22,650 --> 00:04:28,890
i love his court his australian like me

00:04:27,330 --> 00:04:31,860
so he's got this sort of sarcastic sense

00:04:28,890 --> 00:04:32,910
of humor he said MySQL 56 is the largest

00:04:31,860 --> 00:04:35,670
my scope

00:04:32,910 --> 00:04:37,890
sighs increase you know mysql version

00:04:35,670 --> 00:04:41,190
ever last time we saw this you know what

00:04:37,890 --> 00:04:43,080
with mysql cluster integrating most

00:04:41,190 --> 00:04:45,120
importantly article is paying people to

00:04:43,080 --> 00:04:48,780
write lines of code to the extent that

00:04:45,120 --> 00:04:52,020
nobody has before I assure you those

00:04:48,780 --> 00:04:52,980
features as well but we're writing a lot

00:04:52,020 --> 00:04:56,130
of code if you see the difference

00:04:52,980 --> 00:04:59,370
between it's not so visible mysql 5 and

00:04:56,130 --> 00:05:01,020
mysql 56 that the code size of mysql is

00:04:59,370 --> 00:05:03,060
increased the version numbers don't tell

00:05:01,020 --> 00:05:05,250
the full story and if you look at the

00:05:03,060 --> 00:05:09,660
Delta there's quite a lot of stuff that

00:05:05,250 --> 00:05:12,240
came in and you know some of these are

00:05:09,660 --> 00:05:14,640
they quite core infrastructure changes

00:05:12,240 --> 00:05:16,230
that happen so I also didn't want to try

00:05:14,640 --> 00:05:17,610
and read off bullet points because it

00:05:16,230 --> 00:05:20,310
can be kind of boring I wanted to focus

00:05:17,610 --> 00:05:23,820
on these operational enhancements but we

00:05:20,310 --> 00:05:25,950
fixed a lot of bugs as well in our four

00:05:23,820 --> 00:05:30,570
years in an hour period leading up to

00:05:25,950 --> 00:05:32,940
mysql 56 you know 2,000 bugs fixed 4,000

00:05:30,570 --> 00:05:34,680
bugs in in total fixed since mysql 55

00:05:32,940 --> 00:05:38,520
the quality of the product is much

00:05:34,680 --> 00:05:42,060
better by major features that were

00:05:38,520 --> 00:05:43,350
advertised for mysql 56 always say i

00:05:42,060 --> 00:05:45,930
said there's a lot of things these are

00:05:43,350 --> 00:05:47,550
the ones that we up i looked in our

00:05:45,930 --> 00:05:50,550
public website and I said what are we

00:05:47,550 --> 00:05:54,810
advertising that we did they look pretty

00:05:50,550 --> 00:05:58,080
cool I think um what do we actually do

00:05:54,810 --> 00:06:00,930
there I pulled this from a mysql

00:05:58,080 --> 00:06:04,230
performance blog post this is what we we

00:06:00,930 --> 00:06:05,790
did so i don't think that's going to be

00:06:04,230 --> 00:06:09,870
readable i just wanted to show you like

00:06:05,790 --> 00:06:11,850
there's a lot of goodies i will try and

00:06:09,870 --> 00:06:14,550
put that slide up at the end of my talk

00:06:11,850 --> 00:06:16,110
and i we have time try and discuss them

00:06:14,550 --> 00:06:18,390
i don't know if probably the first row

00:06:16,110 --> 00:06:23,490
can read them probably no one else past

00:06:18,390 --> 00:06:25,020
i can so that's my introduction let's

00:06:23,490 --> 00:06:25,980
get on to the operational enhancements

00:06:25,020 --> 00:06:31,740
and then after that we'll cover

00:06:25,980 --> 00:06:34,530
Diagnostics so number one best reason

00:06:31,740 --> 00:06:37,890
for a lot of people that they've given

00:06:34,530 --> 00:06:40,440
the feedback to upgrade on mysql 56 is

00:06:37,890 --> 00:06:43,200
we now have online ddl for a number of

00:06:40,440 --> 00:06:46,800
operations this means that when you

00:06:43,200 --> 00:06:49,349
create an index when you drop an index

00:06:46,800 --> 00:06:51,210
or a few other operations it doesn't

00:06:49,349 --> 00:06:53,729
block readers it doesn't block writers

00:06:51,210 --> 00:06:57,960
your application continues to be online

00:06:53,729 --> 00:06:59,400
and fully operational what people used

00:06:57,960 --> 00:07:01,020
to do is they used to add the index on

00:06:59,400 --> 00:07:03,030
the slave and they used to try and do

00:07:01,020 --> 00:07:04,680
the switching to make the slave the

00:07:03,030 --> 00:07:08,340
master after the index was added and

00:07:04,680 --> 00:07:11,340
relied on how replication works you

00:07:08,340 --> 00:07:14,460
don't have to do that anymore you can

00:07:11,340 --> 00:07:16,620
just add the index and for the most part

00:07:14,460 --> 00:07:18,210
you know there'll be a little bit of a

00:07:16,620 --> 00:07:20,639
degradation of services that consume

00:07:18,210 --> 00:07:23,539
some I oh but it'll work and this is

00:07:20,639 --> 00:07:26,039
very useful I think this was a major

00:07:23,539 --> 00:07:28,289
pain point for a lot of people that had

00:07:26,039 --> 00:07:30,990
large databases and there was some

00:07:28,289 --> 00:07:33,330
progression that led to this in the

00:07:30,990 --> 00:07:35,729
beginning actually anytime you added an

00:07:33,330 --> 00:07:38,129
index it used to have to create the

00:07:35,729 --> 00:07:39,710
whole table again with all the new index

00:07:38,129 --> 00:07:43,289
definitions and then trickle over

00:07:39,710 --> 00:07:46,500
trickle load the table row by row it got

00:07:43,289 --> 00:07:48,210
better in MySQL 55 actually where if you

00:07:46,500 --> 00:07:49,949
just create an index it only had to load

00:07:48,210 --> 00:07:52,560
that index and it's sort of the data

00:07:49,949 --> 00:07:55,650
before I loaded it but it's completely

00:07:52,560 --> 00:07:58,710
good now with mysql 56 that can do that

00:07:55,650 --> 00:08:01,259
in the in the background and not impact

00:07:58,710 --> 00:08:03,630
your clients is their reading and

00:08:01,259 --> 00:08:05,819
writing so I gave the example with

00:08:03,630 --> 00:08:07,770
indexes and I said online ddl for

00:08:05,819 --> 00:08:10,650
indexes there's a lot of other

00:08:07,770 --> 00:08:15,690
operations that you will want to do like

00:08:10,650 --> 00:08:18,690
add columns remove columns or etc I like

00:08:15,690 --> 00:08:20,759
how well documented it is in our manual

00:08:18,690 --> 00:08:24,000
I have the link to it at the bottom when

00:08:20,759 --> 00:08:25,710
you get my slides exactly which is

00:08:24,000 --> 00:08:28,229
completely online and does not block

00:08:25,710 --> 00:08:30,180
readers or does not block writers the

00:08:28,229 --> 00:08:31,979
most important column here that does not

00:08:30,180 --> 00:08:34,589
block readers and there's not block

00:08:31,979 --> 00:08:38,699
writers is his third column in what says

00:08:34,589 --> 00:08:41,310
allows concurrent DML I copy this

00:08:38,699 --> 00:08:43,289
verbatim from the manual so there was no

00:08:41,310 --> 00:08:45,240
other easy way to fit it on the slide

00:08:43,289 --> 00:08:48,690
but you can see that a fair number of

00:08:45,240 --> 00:08:50,160
the operations not quite all so if you

00:08:48,690 --> 00:08:52,800
change the data type of a column where

00:08:50,160 --> 00:08:54,540
you drop a primary key or add another

00:08:52,800 --> 00:08:56,970
primary key or convert character sets

00:08:54,540 --> 00:09:00,970
these are going to be blocking but a

00:08:56,970 --> 00:09:03,250
fairly good number of operations are now

00:09:00,970 --> 00:09:07,959
blocking as you have to make these in

00:09:03,250 --> 00:09:09,939
production um our crew cares about how

00:09:07,959 --> 00:09:11,740
you use MySQL production what I also

00:09:09,939 --> 00:09:14,949
like about when this feature was

00:09:11,740 --> 00:09:17,850
introduced we add another feature where

00:09:14,949 --> 00:09:21,029
you could in your alter table definition

00:09:17,850 --> 00:09:24,939
specify this additional syntax to say

00:09:21,029 --> 00:09:28,000
lock equals none or algorithm equals in

00:09:24,939 --> 00:09:30,759
place and what this means is that if

00:09:28,000 --> 00:09:32,439
it's not able to do this not blocking

00:09:30,759 --> 00:09:34,899
reads or writes it'll actually refuse

00:09:32,439 --> 00:09:36,129
the statement from running so you don't

00:09:34,899 --> 00:09:37,899
have to play this guessing game and

00:09:36,129 --> 00:09:42,459
they're going to have down time now or

00:09:37,899 --> 00:09:43,750
not and I've seen that at least in there

00:09:42,459 --> 00:09:47,079
the ruby on rails community with

00:09:43,750 --> 00:09:50,050
migrations they've got gems that

00:09:47,079 --> 00:09:52,110
integrate with this and by default you

00:09:50,050 --> 00:09:55,360
know as you try and do schema migrations

00:09:52,110 --> 00:09:58,060
it will refuse if it can't do it online

00:09:55,360 --> 00:10:01,360
and I think that's really nice to care

00:09:58,060 --> 00:10:04,540
for this operational aspect I don't know

00:10:01,360 --> 00:10:09,790
what's happening in other communities

00:10:04,540 --> 00:10:13,990
yet okay another feature that's very

00:10:09,790 --> 00:10:17,889
nice buffer pool dump and restore so if

00:10:13,990 --> 00:10:19,930
you have a big server and let's say that

00:10:17,889 --> 00:10:23,259
the big server has hard drives in it and

00:10:19,930 --> 00:10:27,009
you say that you know this big server

00:10:23,259 --> 00:10:29,139
has 64 gig of ram 128 gig of ram not

00:10:27,009 --> 00:10:32,290
that expensive these days actually to

00:10:29,139 --> 00:10:34,209
get a server that has that much if you

00:10:32,290 --> 00:10:36,730
were to lose power or you were to do a

00:10:34,209 --> 00:10:39,250
restart of the server everything that's

00:10:36,730 --> 00:10:41,980
stored in the buffer pool in memory it's

00:10:39,250 --> 00:10:45,750
going to be lost and when you restart

00:10:41,980 --> 00:10:48,430
you're going to have cold caches and

00:10:45,750 --> 00:10:49,930
cold caches for some applications if

00:10:48,430 --> 00:10:52,509
they have very high transactional

00:10:49,930 --> 00:10:56,230
throughput means the application is

00:10:52,509 --> 00:10:58,809
effectively offline so as we care about

00:10:56,230 --> 00:11:01,269
you know operational aspects of my ago

00:10:58,809 --> 00:11:04,360
we introduced this feature where you

00:11:01,269 --> 00:11:06,309
could save the memory addresses not the

00:11:04,360 --> 00:11:08,019
actual data pages with the addresses

00:11:06,309 --> 00:11:10,329
which is a much smaller representation

00:11:08,019 --> 00:11:13,750
of what was in memory while the server

00:11:10,329 --> 00:11:14,710
was running either explicitly by running

00:11:13,750 --> 00:11:17,380
a command or

00:11:14,710 --> 00:11:20,140
down it could save those addresses for

00:11:17,380 --> 00:11:24,010
you and then its startup it can reload

00:11:20,140 --> 00:11:25,570
those pages back into memory so it's

00:11:24,010 --> 00:11:27,190
only recording the addresses not the

00:11:25,570 --> 00:11:28,570
actual content so if there has been a

00:11:27,190 --> 00:11:31,960
change it's not like you're going to get

00:11:28,570 --> 00:11:34,450
stale data storing the addresses is

00:11:31,960 --> 00:11:36,310
eight bytes for every 16 kilobytes so

00:11:34,450 --> 00:11:39,130
it's quite small and this is quite

00:11:36,310 --> 00:11:40,540
useful if you have to do scheduled

00:11:39,130 --> 00:11:42,400
maintenance and then you want to return

00:11:40,540 --> 00:11:46,000
to be able to have operational

00:11:42,400 --> 00:11:48,220
efficiency you could use this a buffer

00:11:46,000 --> 00:11:50,170
pool save feature as well to to

00:11:48,220 --> 00:11:52,720
initialize a new slave that you're about

00:11:50,170 --> 00:11:55,780
to fail over if it had the data

00:11:52,720 --> 00:11:59,620
originated from the same master it can

00:11:55,780 --> 00:12:03,850
be very useful so I see a question is

00:11:59,620 --> 00:12:06,970
the real economy and no kamae okay

00:12:03,850 --> 00:12:11,440
another thing that's useful is that when

00:12:06,970 --> 00:12:14,740
you have in odv tables previously I if

00:12:11,440 --> 00:12:16,900
you had inner DB file per table you

00:12:14,740 --> 00:12:19,420
could not just copy that my table that

00:12:16,900 --> 00:12:22,630
IBD file and restore it on another

00:12:19,420 --> 00:12:24,130
server the reason why you couldn't is

00:12:22,630 --> 00:12:26,230
that it always had some information

00:12:24,130 --> 00:12:28,840
stored globally in that I be data one

00:12:26,230 --> 00:12:33,690
file the data dictionary and someone

00:12:28,840 --> 00:12:40,630
undo information now what we do is we

00:12:33,690 --> 00:12:43,810
offer a Zurich I'm am I reading you

00:12:40,630 --> 00:12:46,000
outside no I I'm I I was reading the

00:12:43,810 --> 00:12:47,410
wrong side sorry this feature what it

00:12:46,000 --> 00:12:49,630
does is allows you to exchange a

00:12:47,410 --> 00:12:53,890
petition with the table so you have a

00:12:49,630 --> 00:12:56,680
table petitioned which is a very common

00:12:53,890 --> 00:12:58,060
data warehousing like technique where it

00:12:56,680 --> 00:13:01,720
looks like it's one table but it's

00:12:58,060 --> 00:13:03,190
actually many tables underneath I let's

00:13:01,720 --> 00:13:05,610
say that you want to archive out some

00:13:03,190 --> 00:13:07,720
data from one petition you can swap that

00:13:05,610 --> 00:13:09,990
with another table that's sitting

00:13:07,720 --> 00:13:13,270
somewhere else and this is very useful

00:13:09,990 --> 00:13:17,440
as a feature with archiving like time

00:13:13,270 --> 00:13:19,330
series data or some server that you want

00:13:17,440 --> 00:13:22,030
to initialize somewhere else that has a

00:13:19,330 --> 00:13:24,100
smaller amount of disk space or you know

00:13:22,030 --> 00:13:26,020
seating something it's very useful that

00:13:24,100 --> 00:13:27,410
these petitions can now be swapped

00:13:26,020 --> 00:13:29,790
around

00:13:27,410 --> 00:13:32,760
the feature that I was describing sorry

00:13:29,790 --> 00:13:35,790
before is that yes you can you can

00:13:32,760 --> 00:13:37,710
switch around the tables that are you

00:13:35,790 --> 00:13:39,990
know my table that I BD from one server

00:13:37,710 --> 00:13:41,580
to another server by doing this export

00:13:39,990 --> 00:13:47,820
command and then importing the

00:13:41,580 --> 00:13:50,130
tablespace back in so this is one of one

00:13:47,820 --> 00:13:52,890
of the complaints that I know was common

00:13:50,130 --> 00:13:55,290
for some people like hosting providers

00:13:52,890 --> 00:13:57,090
that preferred my eyes em so you know TV

00:13:55,290 --> 00:13:59,060
because it was very easy to restore I

00:13:57,090 --> 00:14:01,380
use this data from one server to another

00:13:59,060 --> 00:14:04,200
it's now easier to be able to do that

00:14:01,380 --> 00:14:05,490
within a TV because you know if you're

00:14:04,200 --> 00:14:07,050
doing my skill dump or something like

00:14:05,490 --> 00:14:08,910
that it does take a lot longer to be

00:14:07,050 --> 00:14:11,280
able to restore it than just the speedy

00:14:08,910 --> 00:14:15,690
of copying data as it would be close to

00:14:11,280 --> 00:14:23,370
in this case a question if we have

00:14:15,690 --> 00:14:26,850
someone run with a mic excellent does it

00:14:23,370 --> 00:14:31,680
take the table offline does it take the

00:14:26,850 --> 00:14:34,500
table offline I have not tried I will

00:14:31,680 --> 00:14:38,100
assume that it might because it might

00:14:34,500 --> 00:14:42,690
have to make sure that no changes to

00:14:38,100 --> 00:14:43,800
data dictionary and stuff are made I can

00:14:42,690 --> 00:14:46,980
find you a better answer on that

00:14:43,800 --> 00:14:49,020
afterwards perhaps it does take the

00:14:46,980 --> 00:14:52,350
table offline in the case of my eyes em

00:14:49,020 --> 00:14:54,060
and in this case where we're kind of

00:14:52,350 --> 00:14:56,760
looking for offering some feature parity

00:14:54,060 --> 00:15:03,360
so I don't know if we would have made it

00:14:56,760 --> 00:15:07,950
online in the case of inner TV another

00:15:03,360 --> 00:15:10,170
useful thing that's fixed in mysql 56

00:15:07,950 --> 00:15:12,330
that makes ops people's life easier is

00:15:10,170 --> 00:15:13,980
if you have to do a simple thing like

00:15:12,330 --> 00:15:18,000
change the size of the energy v load

00:15:13,980 --> 00:15:20,220
file ah what used to happen is when you

00:15:18,000 --> 00:15:23,330
try and restart mysql it would say sorry

00:15:20,220 --> 00:15:25,740
can't do that mysql refuses to stop

00:15:23,330 --> 00:15:27,480
you've changed the lobe file size and i

00:15:25,740 --> 00:15:29,160
didn't like that and you had to do this

00:15:27,480 --> 00:15:31,020
ugly thing where you make sure its shots

00:15:29,160 --> 00:15:32,670
down safely you change the setting

00:15:31,020 --> 00:15:35,160
configuration you delete the lobe files

00:15:32,670 --> 00:15:36,510
and you stop back up now it realizes

00:15:35,160 --> 00:15:38,100
that you've just changed the setting in

00:15:36,510 --> 00:15:40,380
and expands the size of the log files

00:15:38,100 --> 00:15:40,769
and I think that's important for you to

00:15:40,380 --> 00:15:42,119
build

00:15:40,769 --> 00:15:44,429
because a lot of people get trapped by

00:15:42,119 --> 00:15:51,029
this even if you're experienced you'll

00:15:44,429 --> 00:15:53,149
forget a step to two more features both

00:15:51,029 --> 00:15:56,459
in the replication category our

00:15:53,149 --> 00:15:59,160
replication has global transaction IDs

00:15:56,459 --> 00:16:01,230
now so if you're running a replication

00:15:59,160 --> 00:16:03,179
topology where you've got either a

00:16:01,230 --> 00:16:06,989
master in a couple of slaves or a master

00:16:03,179 --> 00:16:10,799
slave slave some sort of tier if you

00:16:06,989 --> 00:16:12,660
have to change that topology order the

00:16:10,799 --> 00:16:14,429
coordinates for the binary lobes which

00:16:12,660 --> 00:16:17,040
is the files used for applications used

00:16:14,429 --> 00:16:18,449
to be local to an instance now you have

00:16:17,040 --> 00:16:20,910
this feature where you can make them

00:16:18,449 --> 00:16:25,679
global so that if you need to reposition

00:16:20,910 --> 00:16:28,709
a slave to another slave it'll just fall

00:16:25,679 --> 00:16:30,420
into place without having to do some

00:16:28,709 --> 00:16:32,509
silly math to figure out exactly how to

00:16:30,420 --> 00:16:34,470
do it and these are the most stressful

00:16:32,509 --> 00:16:36,839
situations when you're doing op things

00:16:34,470 --> 00:16:41,279
and trying to rebalance things it's very

00:16:36,839 --> 00:16:43,799
useful this feature and our replication

00:16:41,279 --> 00:16:47,759
is also enhanced because it's now

00:16:43,799 --> 00:16:50,129
multi-threaded on a per schema basis so

00:16:47,759 --> 00:16:52,470
what used to happen is you would have a

00:16:50,129 --> 00:16:54,749
master and i would have multi disks and

00:16:52,470 --> 00:16:57,329
multi cpus and be able to export all of

00:16:54,749 --> 00:16:59,759
this concurrency as applications would

00:16:57,329 --> 00:17:01,559
write twitted many threads but then it

00:16:59,759 --> 00:17:05,039
would serialize these rights through a

00:17:01,559 --> 00:17:06,569
straw to a slave that would be just as

00:17:05,039 --> 00:17:09,630
powerful but it wouldn't be able to

00:17:06,569 --> 00:17:11,699
exploit these parallel ISM and it could

00:17:09,630 --> 00:17:13,020
create a major bottleneck for a lot of

00:17:11,699 --> 00:17:16,649
people that had a workload there was

00:17:13,020 --> 00:17:20,159
right heavy and now it's parallel on a

00:17:16,649 --> 00:17:22,049
per schema basis or in MySQL 57 we've

00:17:20,159 --> 00:17:25,649
committed that it will be parallel on an

00:17:22,049 --> 00:17:28,139
interest schema basis so replication

00:17:25,649 --> 00:17:33,320
slaves will be a lot more useful and

00:17:28,139 --> 00:17:35,580
they'll keep up with not replication lag

00:17:33,320 --> 00:17:38,549
who's experienced the replication lag

00:17:35,580 --> 00:17:40,529
problem I think that's a totally you

00:17:38,549 --> 00:17:44,700
know exactly what I'm selling that it's

00:17:40,529 --> 00:17:48,270
going to be awesome in 57 so that was

00:17:44,700 --> 00:17:50,309
that was the operational enhancements in

00:17:48,270 --> 00:17:54,299
terms of feature sets that's talked in

00:17:50,309 --> 00:17:54,900
terms of diagnostics and I i said my

00:17:54,299 --> 00:17:56,430
advice

00:17:54,900 --> 00:17:57,840
the Diagnostics are awesome because you

00:17:56,430 --> 00:18:01,380
don't always get the performance you're

00:17:57,840 --> 00:18:03,660
entitled to so if you wanted to find out

00:18:01,380 --> 00:18:07,920
why a quick query with slow you might

00:18:03,660 --> 00:18:10,770
run explain how do you run explain from

00:18:07,920 --> 00:18:13,080
your programs and then passed it it's

00:18:10,770 --> 00:18:15,110
kind of a silly format in a way in this

00:18:13,080 --> 00:18:17,820
tabulated with extra things that turn on

00:18:15,110 --> 00:18:20,460
now we have an option to be able to get

00:18:17,820 --> 00:18:22,950
explained format equals Jason and we're

00:18:20,460 --> 00:18:25,920
expecting applications to be able to use

00:18:22,950 --> 00:18:27,780
this so they can plug in and find all

00:18:25,920 --> 00:18:31,050
Diagnostics about queries performing

00:18:27,780 --> 00:18:33,360
slow and etc when you run explain 4matic

00:18:31,050 --> 00:18:34,890
was Jason I think it's much easier to

00:18:33,360 --> 00:18:39,030
read and actually does include some

00:18:34,890 --> 00:18:41,730
additional information in it so I

00:18:39,030 --> 00:18:44,370
started reading Jason output for explain

00:18:41,730 --> 00:18:46,650
instead of reading tabular output for

00:18:44,370 --> 00:18:48,920
explaining I think it's very useful at

00:18:46,650 --> 00:18:51,420
the back of my slide deck I have a

00:18:48,920 --> 00:18:53,220
visualization that actually out to mysql

00:18:51,420 --> 00:18:57,500
workbench can read this information and

00:18:53,220 --> 00:18:57,500
print it out to you in a visual phone

00:18:58,490 --> 00:19:03,030
prior to my escrow 56 when you ran

00:19:00,930 --> 00:19:05,910
explain you could only explain a select

00:19:03,030 --> 00:19:08,130
statement now you can explain update and

00:19:05,910 --> 00:19:10,920
delete statements and find out if these

00:19:08,130 --> 00:19:15,600
queries are efficient and this is very

00:19:10,920 --> 00:19:17,310
useful you could rewrite your update or

00:19:15,600 --> 00:19:19,050
your delete statements to selects and

00:19:17,310 --> 00:19:21,720
then you could explain them this would

00:19:19,050 --> 00:19:23,790
be roughly equivalent but it's much

00:19:21,720 --> 00:19:26,190
nicer if you want to do things an

00:19:23,790 --> 00:19:30,090
automated way to be able to explain the

00:19:26,190 --> 00:19:31,980
update with the delete directly so I

00:19:30,090 --> 00:19:34,230
said that explained folinic was Jason

00:19:31,980 --> 00:19:37,430
equals knife is nice there's one even

00:19:34,230 --> 00:19:40,320
more detailed could optimize a trace

00:19:37,430 --> 00:19:43,080
where it can give you sort of the same

00:19:40,320 --> 00:19:45,230
information as what explained us but a

00:19:43,080 --> 00:19:48,240
whole lot more typically it's like on

00:19:45,230 --> 00:19:52,350
any query of any detail it's like half a

00:19:48,240 --> 00:19:54,480
megabyte of data it'll tell you not just

00:19:52,350 --> 00:19:56,340
which query or which index was pics

00:19:54,480 --> 00:19:58,320
picked it'll tell you why the other ones

00:19:56,340 --> 00:20:00,900
weren't picked and I'll show you some

00:19:58,320 --> 00:20:02,970
transformations that happen where it can

00:20:00,900 --> 00:20:06,360
do you know what it calls a quality

00:20:02,970 --> 00:20:08,390
propagation or you say of a equals B & B

00:20:06,360 --> 00:20:09,650
equals C than a equals C you know

00:20:08,390 --> 00:20:14,090
to show you how it's making these

00:20:09,650 --> 00:20:16,700
optimizations we actually created this

00:20:14,090 --> 00:20:18,530
feature so that it would be easier for

00:20:16,700 --> 00:20:21,920
our optimized a team to be able to ask

00:20:18,530 --> 00:20:24,560
people for bug reports but it's

00:20:21,920 --> 00:20:25,940
incredibly avoidance actually I don't

00:20:24,560 --> 00:20:29,000
think it's that hard to read it's very

00:20:25,940 --> 00:20:31,280
useful and so I look forward to seeing

00:20:29,000 --> 00:20:34,010
more people include this in their

00:20:31,280 --> 00:20:36,860
diagnostic tools to be able to see why

00:20:34,010 --> 00:20:42,080
queer is this lower it helps us a lot

00:20:36,860 --> 00:20:44,800
because our focus or one of our focus is

00:20:42,080 --> 00:20:47,270
making my SQL optimizer a lot better and

00:20:44,800 --> 00:20:49,010
being able to understand things like the

00:20:47,270 --> 00:20:50,740
difference between hard drives and SSD

00:20:49,010 --> 00:20:54,170
since they were having this diagnostic

00:20:50,740 --> 00:21:01,430
information allows us to move forward at

00:20:54,170 --> 00:21:04,340
a much faster rate so the other big or

00:21:01,430 --> 00:21:07,190
the big performance change that was made

00:21:04,340 --> 00:21:10,370
in mysql 56 for diagnostics is this

00:21:07,190 --> 00:21:13,340
thing called performance schemer so um

00:21:10,370 --> 00:21:15,170
when you used to want to tune your

00:21:13,340 --> 00:21:17,950
server and say is it behaving

00:21:15,170 --> 00:21:20,540
efficiently what you may have done is

00:21:17,950 --> 00:21:24,560
ran a command like show global status

00:21:20,540 --> 00:21:25,880
and showing ODB status as some true new

00:21:24,560 --> 00:21:29,090
scripts will do and then they'll make

00:21:25,880 --> 00:21:33,560
some recommendations you can still do

00:21:29,090 --> 00:21:35,420
this and it still kind of works I don't

00:21:33,560 --> 00:21:36,830
think it always completely works because

00:21:35,420 --> 00:21:39,050
I think sometimes you're looking for

00:21:36,830 --> 00:21:42,200
correlation more than you're looking for

00:21:39,050 --> 00:21:44,270
cause if I wanted to take a more cynical

00:21:42,200 --> 00:21:46,400
view of it it's kind of like when you

00:21:44,270 --> 00:21:50,240
look at tea leaves and then you try and

00:21:46,400 --> 00:21:52,070
make a decision like sometimes you can

00:21:50,240 --> 00:21:54,980
see how that might be whatever but you

00:21:52,070 --> 00:21:57,860
can never quite be sure and I think in

00:21:54,980 --> 00:22:00,440
the new way it's a lot easier to to be

00:21:57,860 --> 00:22:02,360
sure and you know you don't have always

00:22:00,440 --> 00:22:04,370
a chance to experiment things in

00:22:02,360 --> 00:22:08,570
production so it's useful useful to have

00:22:04,370 --> 00:22:10,190
that level of details so an example of

00:22:08,570 --> 00:22:13,370
this in the old way if you ran show

00:22:10,190 --> 00:22:15,170
global status you can see some ratio

00:22:13,370 --> 00:22:18,040
between temp tables and memory verses

00:22:15,170 --> 00:22:21,620
temp tables and disk or what's a ratio

00:22:18,040 --> 00:22:22,279
ratio is not so important to me I think

00:22:21,620 --> 00:22:26,059
a rate

00:22:22,279 --> 00:22:28,639
is more important like if I was doing

00:22:26,059 --> 00:22:31,009
everything all in memory I could do

00:22:28,639 --> 00:22:33,229
40,000 queries per second on you know

00:22:31,009 --> 00:22:36,259
basically any server I think of their

00:22:33,229 --> 00:22:38,029
simple queries and if I had 99% of these

00:22:36,259 --> 00:22:39,889
queries working memory I could be down

00:22:38,029 --> 00:22:42,019
to like two thousand five thousand

00:22:39,889 --> 00:22:43,999
queries per second because it depends on

00:22:42,019 --> 00:22:46,099
the rate of what that translates to of

00:22:43,999 --> 00:22:47,330
how many iOS it does on disk and I might

00:22:46,099 --> 00:22:50,690
have like a single hard drive or

00:22:47,330 --> 00:22:52,580
something like that rate is more

00:22:50,690 --> 00:22:55,190
important than than ratio and some of

00:22:52,580 --> 00:22:57,409
these these show global status tools

00:22:55,190 --> 00:22:59,539
that the information is just not

00:22:57,409 --> 00:23:01,940
detailed enough to be able to tell all

00:22:59,539 --> 00:23:03,679
this information it owes tell me as well

00:23:01,940 --> 00:23:05,119
that it creates a temp table on disk but

00:23:03,679 --> 00:23:07,070
it won't tell me how many rows are in

00:23:05,119 --> 00:23:11,269
this temp table it could be very small

00:23:07,070 --> 00:23:13,879
it could be a million rows it's not

00:23:11,269 --> 00:23:16,159
query oriented so I can kind of use this

00:23:13,879 --> 00:23:17,899
information to be able to improve maybe

00:23:16,159 --> 00:23:19,909
the capacity of the server but I can't

00:23:17,899 --> 00:23:22,159
guarantee that translates to a response

00:23:19,909 --> 00:23:24,529
time improvement to my clients because

00:23:22,159 --> 00:23:26,359
it's a little bit too disconnected so I

00:23:24,529 --> 00:23:27,950
might be trying to optimize some things

00:23:26,359 --> 00:23:29,539
but it turns out that they're only used

00:23:27,950 --> 00:23:31,070
as part of background queries or reports

00:23:29,539 --> 00:23:34,700
and doesn't matter because there's not

00:23:31,070 --> 00:23:38,109
users sitting in front my last complain

00:23:34,700 --> 00:23:40,879
about these old tools is that they're

00:23:38,109 --> 00:23:42,859
difficult for tooling to be able to plug

00:23:40,879 --> 00:23:45,379
in like this is the output of the

00:23:42,859 --> 00:23:47,119
command show engine innodb status what

00:23:45,379 --> 00:23:50,450
do these two numbers mean next to each

00:23:47,119 --> 00:23:52,369
other what does this number here me know

00:23:50,450 --> 00:23:54,799
this number here like it's not

00:23:52,369 --> 00:23:56,179
necessarily clear and sometimes the

00:23:54,799 --> 00:23:58,729
output is a little bit different

00:23:56,179 --> 00:24:01,369
depending on what situation happened

00:23:58,729 --> 00:24:04,460
it's like conditionally displayed for

00:24:01,369 --> 00:24:06,649
information now with performance schema

00:24:04,460 --> 00:24:09,109
the new way of giving diagnostic

00:24:06,649 --> 00:24:12,469
information out is to present it as a

00:24:09,109 --> 00:24:15,349
series of tables or a series of use in

00:24:12,469 --> 00:24:18,409
this schema called performance schema

00:24:15,349 --> 00:24:21,139
and it's similar to how other databases

00:24:18,409 --> 00:24:23,299
work it's similar to how oracle has this

00:24:21,139 --> 00:24:25,429
weight interface it just gives you all

00:24:23,299 --> 00:24:27,109
this metadata at any point in time if

00:24:25,429 --> 00:24:29,179
your queries are blocked waiting on

00:24:27,109 --> 00:24:31,129
something you can run a select query and

00:24:29,179 --> 00:24:34,339
you can find out where why and where

00:24:31,129 --> 00:24:35,399
that is and so MySQL is doing the same

00:24:34,339 --> 00:24:37,080
thing

00:24:35,399 --> 00:24:40,049
so it was actually introduced as a

00:24:37,080 --> 00:24:45,119
feature in mysql 5.5 but it was off by

00:24:40,049 --> 00:24:46,559
default with mysql 5.6 I it was turned

00:24:45,119 --> 00:24:48,479
on and it has some more information

00:24:46,559 --> 00:24:54,349
that's useful so I'll have some examples

00:24:48,479 --> 00:24:56,639
in just a second performance schema that

00:24:54,349 --> 00:24:59,099
the important parts of it is that it's

00:24:56,639 --> 00:25:01,169
on by default it has probes on

00:24:59,099 --> 00:25:02,759
instrumentation points and you can

00:25:01,169 --> 00:25:04,739
actually choose which levels of

00:25:02,759 --> 00:25:07,559
collection it does so that you can

00:25:04,739 --> 00:25:10,409
reduce the overhead that applies and now

00:25:07,559 --> 00:25:12,690
our default collection aim is for less

00:25:10,409 --> 00:25:14,369
than five percent overhead but you can

00:25:12,690 --> 00:25:16,799
instrument some additional things and it

00:25:14,369 --> 00:25:18,629
might be a little bit higher or you can

00:25:16,799 --> 00:25:20,940
turn some off and it might be a little

00:25:18,629 --> 00:25:23,159
bit lower so we have this variable level

00:25:20,940 --> 00:25:24,659
of configuration that's dynamic you can

00:25:23,159 --> 00:25:29,249
turn things on and off while the service

00:25:24,659 --> 00:25:31,129
running fixed memory by design designed

00:25:29,249 --> 00:25:34,859
to be as little overhead as possible

00:25:31,129 --> 00:25:37,229
when I was introduced in 5.5 it was off

00:25:34,859 --> 00:25:39,419
and it was mainly developer oriented

00:25:37,229 --> 00:25:43,169
that it instrumented things like any

00:25:39,419 --> 00:25:46,440
file i/o operation locking things that

00:25:43,169 --> 00:25:48,599
happen inside the server it didn't break

00:25:46,440 --> 00:25:51,960
it down in the career level but when it

00:25:48,599 --> 00:25:54,389
came to MySQL 56 queries were

00:25:51,960 --> 00:25:57,269
instrumented network io was instrumented

00:25:54,389 --> 00:26:02,279
there was a complete breakdown of time

00:25:57,269 --> 00:26:03,599
so if you you know use a client to be

00:26:02,279 --> 00:26:06,119
able to connect to a wide scale server

00:26:03,599 --> 00:26:10,529
and you said use performance schema in

00:26:06,119 --> 00:26:12,629
MySQL 56 here is the set of tables or

00:26:10,529 --> 00:26:15,690
views that you would see there's a lot

00:26:12,629 --> 00:26:18,599
of them and it's a little bit hard to

00:26:15,690 --> 00:26:21,899
know how to write your own queries but

00:26:18,599 --> 00:26:24,629
there are packages out there one called

00:26:21,899 --> 00:26:27,210
PS helper which is a series of views

00:26:24,629 --> 00:26:29,489
that can sit on top of performance

00:26:27,210 --> 00:26:31,649
schema my next slides I'll have some

00:26:29,489 --> 00:26:34,049
examples for performance schemer and

00:26:31,649 --> 00:26:36,359
some will be custom queries accessing

00:26:34,049 --> 00:26:40,559
these tables directly and some will be

00:26:36,359 --> 00:26:44,429
views that will access these tables for

00:26:40,559 --> 00:26:46,469
you if that makes sense so the audience

00:26:44,429 --> 00:26:48,269
here is a little bit the tools

00:26:46,469 --> 00:26:49,170
developers or a little bit of you know

00:26:48,269 --> 00:26:50,910
about specific

00:26:49,170 --> 00:26:53,430
problems you might research and find out

00:26:50,910 --> 00:26:55,220
how to write a specific query but

00:26:53,430 --> 00:26:57,300
everything that's blocking or waiting

00:26:55,220 --> 00:26:58,980
it's going to be instrumented in

00:26:57,300 --> 00:27:00,780
performance schemer and there'll be new

00:26:58,980 --> 00:27:04,560
features added to this moving forward in

00:27:00,780 --> 00:27:08,960
MySQL 57 so I have I think eight

00:27:04,560 --> 00:27:12,060
examples here is an example where a

00:27:08,960 --> 00:27:14,460
colleague of mine he wanted to know how

00:27:12,060 --> 00:27:16,320
idle connections were by particular

00:27:14,460 --> 00:27:20,040
users because he had this one

00:27:16,320 --> 00:27:23,510
application hypothetically that always

00:27:20,040 --> 00:27:25,590
left transactions open or I had

00:27:23,510 --> 00:27:28,770
connections that just didn't do anything

00:27:25,590 --> 00:27:30,810
so he wrote a query and he used the

00:27:28,770 --> 00:27:32,910
information that's available in an

00:27:30,810 --> 00:27:35,220
events waits summary table and

00:27:32,910 --> 00:27:37,020
performance schemer and he said that for

00:27:35,220 --> 00:27:38,850
this particular user it was ninety-nine

00:27:37,020 --> 00:27:40,620
percent idle for this other user was

00:27:38,850 --> 00:27:45,180
100% idle and here was the time that

00:27:40,620 --> 00:27:48,840
they were idle could be useful if you

00:27:45,180 --> 00:27:50,880
run the command sure process list I it

00:27:48,840 --> 00:27:54,060
includes which connections are running

00:27:50,880 --> 00:27:55,650
but it doesn't say for example what

00:27:54,060 --> 00:28:00,480
interface someone is connected to

00:27:55,650 --> 00:28:02,730
whether it be ipv4 ipv6 or if it was a

00:28:00,480 --> 00:28:04,170
eunuch socket connection and maybe as

00:28:02,730 --> 00:28:07,530
part of your debugging this might be

00:28:04,170 --> 00:28:09,690
useful I'm not sure and so here's an

00:28:07,530 --> 00:28:11,310
example of running a query where you can

00:28:09,690 --> 00:28:15,930
reimplement the same information and

00:28:11,310 --> 00:28:19,350
just add an extra column code ipv6 not

00:28:15,930 --> 00:28:21,090
that useful this one's useful this is

00:28:19,350 --> 00:28:24,090
cool this is another version of process

00:28:21,090 --> 00:28:27,690
list and what I can show you is it can

00:28:24,090 --> 00:28:30,870
say the users what they're currently

00:28:27,690 --> 00:28:34,560
doing where they blocked on in inner UV

00:28:30,870 --> 00:28:37,440
code I you can see the last statement

00:28:34,560 --> 00:28:40,650
how long it took how much time is spent

00:28:37,440 --> 00:28:42,330
unlocking how many temp tables have

00:28:40,650 --> 00:28:45,270
created this is really useful

00:28:42,330 --> 00:28:48,930
information and it's just crazy that you

00:28:45,270 --> 00:28:50,730
can run an SQL query the same language

00:28:48,930 --> 00:28:53,220
that you use for your applications be

00:28:50,730 --> 00:28:57,090
able to get this data back you could get

00:28:53,220 --> 00:28:58,590
a lot of intelligence from this anyone

00:28:57,090 --> 00:29:01,800
ever seen the error log where it says

00:28:58,590 --> 00:29:03,409
that some connection failed to close do

00:29:01,800 --> 00:29:05,970
you want to know which connection

00:29:03,409 --> 00:29:08,610
ride a performance schema query this

00:29:05,970 --> 00:29:11,129
will tell you by percentage in which

00:29:08,610 --> 00:29:13,049
user failed to be able to close that

00:29:11,129 --> 00:29:15,149
connection so you can see here that

00:29:13,049 --> 00:29:21,690
there's quite a lot of things that you

00:29:15,149 --> 00:29:23,330
can potentially do last week somebody

00:29:21,690 --> 00:29:25,350
was telling me that they were using

00:29:23,330 --> 00:29:28,830
MySQL as part of their continuous

00:29:25,350 --> 00:29:31,649
integration tests okay great they told

00:29:28,830 --> 00:29:33,480
me that their test took half an hour not

00:29:31,649 --> 00:29:35,009
so good I heard it's better than for

00:29:33,480 --> 00:29:37,649
about five minutes seems to be the magic

00:29:35,009 --> 00:29:40,470
number and I said I'm thinking maybe I

00:29:37,649 --> 00:29:42,690
should switch it to temp FS and then

00:29:40,470 --> 00:29:44,070
I'll get better performance in my tests

00:29:42,690 --> 00:29:46,860
to run faster and I said I don't know

00:29:44,070 --> 00:29:48,539
probably I mean if you're just doing

00:29:46,860 --> 00:29:49,769
selects or something when the dot is in

00:29:48,539 --> 00:29:52,139
memory they're not going to be any

00:29:49,769 --> 00:29:55,350
faster but if you're very right heavy

00:29:52,139 --> 00:29:58,289
then yeah maybe it might be faster but I

00:29:55,350 --> 00:30:00,299
was making a hypothesis here and you

00:29:58,289 --> 00:30:03,090
don't have to do that anymore you can

00:30:00,299 --> 00:30:05,159
actually tell so I said to this user

00:30:03,090 --> 00:30:06,799
well we know that temp efest the aim of

00:30:05,159 --> 00:30:09,419
it is that we're going to make rights

00:30:06,799 --> 00:30:10,649
much faster because we're hoping that

00:30:09,419 --> 00:30:15,509
they're just going to be like memory

00:30:10,649 --> 00:30:19,289
right so I said why don't you run your

00:30:15,509 --> 00:30:21,330
tests and while after you run your tests

00:30:19,289 --> 00:30:23,519
we'll just do a performance schema query

00:30:21,330 --> 00:30:25,919
and we'll say how much time are we

00:30:23,519 --> 00:30:28,320
waiting on Io because if we know that

00:30:25,919 --> 00:30:31,679
the whole set of test takes half an hour

00:30:28,320 --> 00:30:33,389
and then we know the the portion of time

00:30:31,679 --> 00:30:35,340
that's spent on Io because we can run

00:30:33,389 --> 00:30:36,869
this query then we can figure out if

00:30:35,340 --> 00:30:39,929
this is a large percentage of half an

00:30:36,869 --> 00:30:41,610
hour and it would be worth it you can

00:30:39,929 --> 00:30:44,700
totally do this no problem at all I

00:30:41,610 --> 00:30:47,639
think it took me a good 10 minutes to

00:30:44,700 --> 00:30:49,980
write that query I think it would have

00:30:47,639 --> 00:30:52,019
been hotter maybe not much hotter in

00:30:49,980 --> 00:30:57,539
this case but to switch to temp of s and

00:30:52,019 --> 00:31:00,210
then see if it was worthwhile when I

00:30:57,539 --> 00:31:04,499
when I talked about this with actually a

00:31:00,210 --> 00:31:07,499
colleague of mine inside mysql who is

00:31:04,499 --> 00:31:09,690
the maintainer of PS helper that of set

00:31:07,499 --> 00:31:12,389
of views that I alluded to earlier he

00:31:09,690 --> 00:31:14,610
said all yeah we do that actually as

00:31:12,389 --> 00:31:16,770
part of the MySQL enterprise monitor

00:31:14,610 --> 00:31:18,950
team we use MySQL and we

00:31:16,770 --> 00:31:21,990
you see I and we switch to tempeh fest

00:31:18,950 --> 00:31:24,330
instead actually PS helper it has the

00:31:21,990 --> 00:31:28,850
features that you can get a summary of

00:31:24,330 --> 00:31:31,440
time for we're all time was spent so i

00:31:28,850 --> 00:31:32,880
would suggest back to that person that

00:31:31,440 --> 00:31:34,470
asked me that question that this would

00:31:32,880 --> 00:31:37,110
be really helpful to include an innie

00:31:34,470 --> 00:31:39,810
see I run to know that information know

00:31:37,110 --> 00:31:42,660
where to make optimizations in the case

00:31:39,810 --> 00:31:45,150
of the the colleague that I spoke to he

00:31:42,660 --> 00:31:47,280
said that he cut his time down from 40

00:31:45,150 --> 00:31:50,460
minutes to something like 14 minutes and

00:31:47,280 --> 00:31:52,050
a big thing that motivated him knowing

00:31:50,460 --> 00:31:56,790
that that change was worthwhile is being

00:31:52,050 --> 00:31:59,940
able to see in in performance schemer so

00:31:56,790 --> 00:32:03,750
two more examples if you ever want to

00:31:59,940 --> 00:32:06,990
know how useful or non useful indexes

00:32:03,750 --> 00:32:08,580
are our index statistics apart of

00:32:06,990 --> 00:32:10,440
performance schema so you could find

00:32:08,580 --> 00:32:12,690
under use indexes and you could remove

00:32:10,440 --> 00:32:14,790
them on the same note you could find

00:32:12,690 --> 00:32:16,290
used indexes and see how many rows have

00:32:14,790 --> 00:32:21,240
happened and how much time has been

00:32:16,290 --> 00:32:22,620
spent reading from them and if you want

00:32:21,240 --> 00:32:25,020
us to know which statements are slow

00:32:22,620 --> 00:32:27,540
you're probably familiar with MySQL slow

00:32:25,020 --> 00:32:29,970
query log this is also available in

00:32:27,540 --> 00:32:31,470
performance schema so if you just logged

00:32:29,970 --> 00:32:32,700
into a fresh server and you wanted to

00:32:31,470 --> 00:32:35,610
know what's running and what's means

00:32:32,700 --> 00:32:37,140
slow recently this data is already going

00:32:35,610 --> 00:32:38,820
to be sitting there by default and you

00:32:37,140 --> 00:32:42,030
can very easily run a query on it and

00:32:38,820 --> 00:32:44,760
here's a quick aggregation that PS

00:32:42,030 --> 00:32:46,830
helper is offered me where it says that

00:32:44,760 --> 00:32:48,630
the query and it matches the patterns

00:32:46,830 --> 00:32:52,110
where they could be slight variations

00:32:48,630 --> 00:32:54,660
nice query I is it a full table scan or

00:32:52,110 --> 00:32:56,370
not how many times has been executed how

00:32:54,660 --> 00:33:00,750
much time in aggregate is that taken

00:32:56,370 --> 00:33:03,810
what's the average I think this is very

00:33:00,750 --> 00:33:05,700
good for a short play of data and you

00:33:03,810 --> 00:33:07,620
might still use the slow query log you

00:33:05,700 --> 00:33:11,400
want to analyze a larger period of data

00:33:07,620 --> 00:33:14,820
I still use them both but it's great

00:33:11,400 --> 00:33:17,880
that's that's PS helper the examples

00:33:14,820 --> 00:33:19,740
that I showed here some were direct to

00:33:17,880 --> 00:33:21,870
performance schemer some use this

00:33:19,740 --> 00:33:27,290
package PS helper and some actually I

00:33:21,870 --> 00:33:30,720
took from a colleague of mines blog any

00:33:27,290 --> 00:33:35,279
any questions on that one

00:33:30,720 --> 00:33:35,279
yeah well that way for Mike

00:33:41,010 --> 00:33:48,710
I actually have two questions one is

00:33:44,790 --> 00:33:51,030
turn it on by default and the second is

00:33:48,710 --> 00:33:54,000
you have any benchmark how much this

00:33:51,030 --> 00:33:57,420
effect performances the performance kid

00:33:54,000 --> 00:34:00,510
man yourself sure so is it turned on by

00:33:57,420 --> 00:34:03,410
default yes although the instrumentation

00:34:00,510 --> 00:34:06,720
is tunable what it'll actually measure

00:34:03,410 --> 00:34:09,810
our aim is to keep the overhead as less

00:34:06,720 --> 00:34:11,820
than five percent um there are some

00:34:09,810 --> 00:34:13,860
cases where it might be closer to ten

00:34:11,820 --> 00:34:15,450
percent and I know in some of those

00:34:13,860 --> 00:34:20,340
cases we've been working on reducing

00:34:15,450 --> 00:34:28,710
that 457 um that was both of your

00:34:20,340 --> 00:34:32,370
questions I can sense it okay yeah so

00:34:28,710 --> 00:34:35,130
that data in in those statistics tables

00:34:32,370 --> 00:34:37,980
does it get rotated in any way or is it

00:34:35,130 --> 00:34:41,429
there as in from the beginning of time

00:34:37,980 --> 00:34:44,000
or does it get rotated basically yeah so

00:34:41,429 --> 00:34:46,940
it uses a fixed memory buffer a

00:34:44,000 --> 00:34:50,610
circularbuffer that's pre-allocated and

00:34:46,940 --> 00:34:53,580
it actually keeps a lot of the data in

00:34:50,610 --> 00:34:55,379
the connection threads themself and it's

00:34:53,580 --> 00:34:57,690
when you run a query that it will

00:34:55,379 --> 00:35:00,030
aggregate it there's different PS tables

00:34:57,690 --> 00:35:02,280
so there's different ways of that works

00:35:00,030 --> 00:35:04,080
but it is fixed in length and it's a

00:35:02,280 --> 00:35:07,530
circular buffer and it will get written

00:35:04,080 --> 00:35:09,990
over there's some configuration around

00:35:07,530 --> 00:35:12,840
that I've not tried to change it former

00:35:09,990 --> 00:35:15,450
is its default you can also truncate the

00:35:12,840 --> 00:35:17,250
metrics and then start collecting again

00:35:15,450 --> 00:35:23,090
which might be useful in the in the case

00:35:17,250 --> 00:35:23,090
that I showed with the test suite yeah

00:35:26,100 --> 00:35:31,360
in explain I often see it's going to use

00:35:29,830 --> 00:35:33,160
a temporary table I would like to

00:35:31,360 --> 00:35:35,980
predict if this template table is going

00:35:33,160 --> 00:35:39,820
to be in memory or if it has to end up

00:35:35,980 --> 00:35:42,490
on our drive um so the simple answer

00:35:39,820 --> 00:35:43,720
that is that we can't tell yet we

00:35:42,490 --> 00:35:46,210
actually might be able to tell

00:35:43,720 --> 00:35:49,450
theoretically in some situations if it's

00:35:46,210 --> 00:35:51,190
got texture blobs but we can't tell yet

00:35:49,450 --> 00:35:53,230
for the other situations if it's going

00:35:51,190 --> 00:35:55,630
to spill over because explain is about

00:35:53,230 --> 00:35:57,820
our ideas in building a plan it's not

00:35:55,630 --> 00:36:01,000
about what actually happened the same

00:35:57,820 --> 00:36:03,340
with some limits we can't show you if

00:36:01,000 --> 00:36:04,570
that's going to be applied or not

00:36:03,340 --> 00:36:06,130
efficiently if it's going to find the

00:36:04,570 --> 00:36:08,610
five rows of need straight away or

00:36:06,130 --> 00:36:13,240
exhaustively search and not find five

00:36:08,610 --> 00:36:15,310
yeah hope that the answers but you could

00:36:13,240 --> 00:36:18,520
use your performance schema data to find

00:36:15,310 --> 00:36:23,520
out exactly if it had to create that or

00:36:18,520 --> 00:36:23,520
not in retrospect yeah

00:36:28,620 --> 00:36:33,600
if you're running our cluster of servers

00:36:30,720 --> 00:36:36,270
I assume there would be any problem

00:36:33,600 --> 00:36:38,100
having this enabled on one of the right

00:36:36,270 --> 00:36:39,330
servers and one on two slaves and not

00:36:38,100 --> 00:36:40,500
everything order doesn't need to be

00:36:39,330 --> 00:36:43,500
enabled on everything if you're on a

00:36:40,500 --> 00:36:45,600
cluster you could run it on one and not

00:36:43,500 --> 00:36:48,690
the others you know what I like about

00:36:45,600 --> 00:36:51,900
this being enabled and it's kind of like

00:36:48,690 --> 00:36:53,490
um you know how in the PHP world you've

00:36:51,900 --> 00:36:56,910
got extra bug and that's like a debugger

00:36:53,490 --> 00:36:58,380
for development and you can't run that

00:36:56,910 --> 00:37:00,150
in production which is a shame but you

00:36:58,380 --> 00:37:01,800
only get problems in production or you

00:37:00,150 --> 00:37:03,480
shouldn't run in production but then

00:37:01,800 --> 00:37:05,640
you've got something like X H prof which

00:37:03,480 --> 00:37:07,520
is like a debugger or a profiler

00:37:05,640 --> 00:37:11,970
designed specifically for production

00:37:07,520 --> 00:37:14,160
this is that on the MySQL side we want

00:37:11,970 --> 00:37:17,130
you to be able to run it and our

00:37:14,160 --> 00:37:18,900
commitment is is that where we're trying

00:37:17,130 --> 00:37:20,730
to in the default configuration get it

00:37:18,900 --> 00:37:22,710
to less than five percent of the time so

00:37:20,730 --> 00:37:27,270
that you'll be able to find these

00:37:22,710 --> 00:37:28,470
performance problems is that answer your

00:37:27,270 --> 00:37:31,260
question yes you can get what you want

00:37:28,470 --> 00:37:37,950
but no we don't necessarily want you to

00:37:31,260 --> 00:37:42,570
have to do that okay so performance

00:37:37,950 --> 00:37:45,890
schema is for our rapidly changing data

00:37:42,570 --> 00:37:48,680
it's this prospectus view into that

00:37:45,890 --> 00:37:51,620
internal operations of what's happening

00:37:48,680 --> 00:37:55,320
information schema is similar to that

00:37:51,620 --> 00:37:59,880
but this is another database or schema

00:37:55,320 --> 00:38:02,580
and it shows the more static data and it

00:37:59,880 --> 00:38:04,980
actually predates performance schema so

00:38:02,580 --> 00:38:07,200
this this came out i think in mysql 50

00:38:04,980 --> 00:38:08,760
where it was a it's actually an SQL

00:38:07,200 --> 00:38:12,240
standards thing to be able to show all

00:38:08,760 --> 00:38:15,540
metadata for the for the server it got a

00:38:12,240 --> 00:38:18,030
lot better in mysql 5.6 there was the

00:38:15,540 --> 00:38:23,670
addition of these information schema

00:38:18,030 --> 00:38:29,070
tables mostly an OTV yeah which is cool

00:38:23,670 --> 00:38:32,550
so I ran an example and I I wanted to

00:38:29,070 --> 00:38:35,160
know that I had a a server it had 128

00:38:32,550 --> 00:38:37,500
meg is the buffer pool size inner db's

00:38:35,160 --> 00:38:39,750
main cash and I wanted to know if this

00:38:37,500 --> 00:38:43,310
was a good number or if I had to buy

00:38:39,750 --> 00:38:45,600
more ram so actually in dotted

00:38:43,310 --> 00:38:47,760
principles there's this this thing

00:38:45,600 --> 00:38:50,520
called the five-minute rule which says

00:38:47,760 --> 00:38:53,190
that if you load a page that the basic

00:38:50,520 --> 00:38:54,930
unit of space in a memory if you're

00:38:53,190 --> 00:38:57,750
going to need that again within the next

00:38:54,930 --> 00:39:00,240
five minutes you should be able to

00:38:57,750 --> 00:39:02,310
retain that in memory and it should not

00:39:00,240 --> 00:39:06,780
have to be paged out and then reloaded

00:39:02,310 --> 00:39:08,730
back in so this is a good way of being

00:39:06,780 --> 00:39:12,090
able to uh it's a it's a rule of thumb

00:39:08,730 --> 00:39:13,350
it's not fixed in space but this is a

00:39:12,090 --> 00:39:15,600
good way to be able to tell if I have

00:39:13,350 --> 00:39:17,250
enough memory if I have the ability to

00:39:15,600 --> 00:39:21,000
get these Diagnostics from the server

00:39:17,250 --> 00:39:23,340
and in fact I do because I have all of

00:39:21,000 --> 00:39:26,430
the information about which nodb pages

00:39:23,340 --> 00:39:28,500
are currently in memory so what I did is

00:39:26,430 --> 00:39:31,860
I wrote a query I wrote a stored

00:39:28,500 --> 00:39:33,630
procedure and I said every five or ten

00:39:31,860 --> 00:39:38,790
seconds every 10 seconds it was

00:39:33,630 --> 00:39:40,410
something I wrote myself 30 times c

00:39:38,790 --> 00:39:44,250
which pages are in memory the distinct

00:39:40,410 --> 00:39:48,090
pages and then after you run that 30

00:39:44,250 --> 00:39:52,080
times then tell me the distinct count of

00:39:48,090 --> 00:39:54,090
pages that were required so what's my

00:39:52,080 --> 00:39:56,610
working said essentially what what did I

00:39:54,090 --> 00:39:58,170
need over five minutes and when I ran

00:39:56,610 --> 00:40:00,780
this on my server that was doing stuff

00:39:58,170 --> 00:40:04,190
it told me that I had a need for a

00:40:00,780 --> 00:40:08,100
hundred thousand pages and that

00:40:04,190 --> 00:40:11,220
correspondent to 1.5 gig of ram and i

00:40:08,100 --> 00:40:12,540
only had 128 megabytes of ram dedicated

00:40:11,220 --> 00:40:15,450
to an ID be so i knew that i was

00:40:12,540 --> 00:40:17,850
underperforming um you haven't been able

00:40:15,450 --> 00:40:19,890
to do this before or efficiently you

00:40:17,850 --> 00:40:21,870
might be able to tell if my o stat kind

00:40:19,890 --> 00:40:23,520
of but it's really good to be able to

00:40:21,870 --> 00:40:27,480
have these Diagnostics bill into the

00:40:23,520 --> 00:40:29,850
server it's like x-ray vision that

00:40:27,480 --> 00:40:34,460
visibility that you get everything it

00:40:29,850 --> 00:40:39,960
becomes easy when the dot is there so

00:40:34,460 --> 00:40:42,690
that's mostly it just a quick glimpse in

00:40:39,960 --> 00:40:45,920
in the future performance schema is

00:40:42,690 --> 00:40:47,430
going to get better in mysql 5.7

00:40:45,920 --> 00:40:50,100
transactions are going to be

00:40:47,430 --> 00:40:54,840
instrumented and memory allocation is

00:40:50,100 --> 00:40:56,369
going to be instrumented as well both i

00:40:54,840 --> 00:40:58,079
think not by default you

00:40:56,369 --> 00:40:59,960
have to enable that and then overhead

00:40:58,079 --> 00:41:02,930
might just be a little bit higher

00:40:59,960 --> 00:41:06,210
there's going to be more explain

00:41:02,930 --> 00:41:09,930
enhancements you can explain a running

00:41:06,210 --> 00:41:12,509
query in another connection you can show

00:41:09,930 --> 00:41:15,240
the cost information and explain 4matic

00:41:12,509 --> 00:41:17,069
with Jason which is the optimizes

00:41:15,240 --> 00:41:20,180
internal language for how it figures out

00:41:17,069 --> 00:41:23,789
which order to join things on and

00:41:20,180 --> 00:41:25,410
there's going to be more usability in

00:41:23,789 --> 00:41:28,349
your application where you can online

00:41:25,410 --> 00:41:30,450
through some SQL Lite commands change

00:41:28,349 --> 00:41:32,880
your replication filters as things go to

00:41:30,450 --> 00:41:36,630
slaves and you can configure the

00:41:32,880 --> 00:41:39,839
verbosity of the error log so what data

00:41:36,630 --> 00:41:41,730
will get ridden to where you can be kind

00:41:39,839 --> 00:41:44,910
of like very verbose so not very verbose

00:41:41,730 --> 00:41:47,579
it would be a lot more configurable some

00:41:44,910 --> 00:41:49,980
annoying bugs that are a long-standing

00:41:47,579 --> 00:41:51,569
with MySQL like you could easily create

00:41:49,980 --> 00:41:54,119
a duplicate index which is completely

00:41:51,569 --> 00:41:56,490
redundant it'll now give you a warning

00:41:54,119 --> 00:41:57,900
when you do that and say you won't even

00:41:56,490 --> 00:42:00,119
be able to do this in a future version

00:41:57,900 --> 00:42:01,650
we're going to deprecate it and when you

00:42:00,119 --> 00:42:03,720
say control C on the command line client

00:42:01,650 --> 00:42:06,569
it'll just clear the buffer rather than

00:42:03,720 --> 00:42:08,220
quitting the program it's pretty cool I

00:42:06,569 --> 00:42:11,970
love that there's a focus on these

00:42:08,220 --> 00:42:14,999
features so i said this memory

00:42:11,970 --> 00:42:18,690
statistics performance schemer so i

00:42:14,999 --> 00:42:21,720
could tell in 57 which user is consuming

00:42:18,690 --> 00:42:24,630
what memory very popular request of

00:42:21,720 --> 00:42:26,400
hosting companies and i said that the

00:42:24,630 --> 00:42:28,440
explained format equals jason is

00:42:26,400 --> 00:42:31,710
designed for programs to be able to pass

00:42:28,440 --> 00:42:34,769
that information and in 57 we have cost

00:42:31,710 --> 00:42:36,960
information where we say you know in our

00:42:34,769 --> 00:42:39,599
internal math how expensive we think

00:42:36,960 --> 00:42:43,019
things are going to to be so this is

00:42:39,599 --> 00:42:46,410
MySQL workbench 6.1 I think it's either

00:42:43,019 --> 00:42:49,499
alpha or beta connected to my skill 5.7

00:42:46,410 --> 00:42:55,739
server and explaining a query that's

00:42:49,499 --> 00:43:00,599
about to run really really helpful so

00:42:55,739 --> 00:43:03,119
that's it so I'll ask four questions and

00:43:00,599 --> 00:43:07,609
I'll also try and answer any of these

00:43:03,119 --> 00:43:07,609
questions if if anyone can read them

00:43:14,930 --> 00:43:19,980
can you think of a way information

00:43:17,940 --> 00:43:21,810
schema or what not that it can more or

00:43:19,980 --> 00:43:24,930
less measure the impact of the foreign

00:43:21,810 --> 00:43:28,050
key constraints yeah I totally think you

00:43:24,930 --> 00:43:29,490
can do it I don't have an example of the

00:43:28,050 --> 00:43:31,440
top my head but I think that is

00:43:29,490 --> 00:43:34,770
instrumented because you can get the

00:43:31,440 --> 00:43:38,490
lock time for energy be from I from

00:43:34,770 --> 00:43:40,850
performance schema no problem at all I

00:43:38,490 --> 00:43:42,900
know you asked me that yesterday but

00:43:40,850 --> 00:43:45,000
we'll follow up by email and I'll

00:43:42,900 --> 00:43:47,520
probably write a blog post I totally

00:43:45,000 --> 00:43:51,150
think you could do it and you could use

00:43:47,520 --> 00:43:53,220
that proof and you could say you know

00:43:51,150 --> 00:43:56,040
our queries when they're they're waiting

00:43:53,220 --> 00:43:57,510
on on foreign key constraints there are

00:43:56,040 --> 00:44:01,200
a lot more variable they take a lot more

00:43:57,510 --> 00:44:03,330
time and we can see turtle server time

00:44:01,200 --> 00:44:05,820
over the last 30 minutes is blocked this

00:44:03,330 --> 00:44:08,670
long on foreign key constraints and thus

00:44:05,820 --> 00:44:11,970
we should maybe drop them have a little

00:44:08,670 --> 00:44:13,110
bit more relaxed consistency yeah I'm

00:44:11,970 --> 00:44:19,980
pretty sure that all that data is

00:44:13,110 --> 00:44:21,480
available their problem at all do you

00:44:19,980 --> 00:44:23,070
mean a whole 10 the other thing to

00:44:21,480 --> 00:44:25,110
mention is that I've got stickers i

00:44:23,070 --> 00:44:27,720
forgot to say that yesterday my skills

00:44:25,110 --> 00:44:30,240
to come up the end of grad one is there

00:44:27,720 --> 00:44:33,690
an improvement in the caching caching

00:44:30,240 --> 00:44:37,050
validation and catching the queries and

00:44:33,690 --> 00:44:39,540
oh so we have we have a query cache

00:44:37,050 --> 00:44:42,090
feature if that's your question and

00:44:39,540 --> 00:44:44,580
there's no improvements to that with 56

00:44:42,090 --> 00:44:47,070
the same thing as before that's right

00:44:44,580 --> 00:44:50,010
yeah in terms of like the buffer pool

00:44:47,070 --> 00:44:53,250
which is inner db's page cache there

00:44:50,010 --> 00:44:55,560
were some improvements in mysql 55 where

00:44:53,250 --> 00:44:59,190
it improved its algorithm of if you did

00:44:55,560 --> 00:45:02,070
a table scan it didn't evict pages from

00:44:59,190 --> 00:45:06,090
the cache that were important for like

00:45:02,070 --> 00:45:09,980
more transaction processing queries but

00:45:06,090 --> 00:45:09,980
nothing on the query cache thank you

00:45:18,610 --> 00:45:23,690
you mentioned a performance schemer was

00:45:21,020 --> 00:45:25,820
disabled in 55 but threatened 56 is it

00:45:23,690 --> 00:45:30,050
fine to 155 or of our performance

00:45:25,820 --> 00:45:31,910
worries um well 55 is well the audience

00:45:30,050 --> 00:45:36,380
was more developers because it said

00:45:31,910 --> 00:45:38,870
things like locking and file IO time and

00:45:36,380 --> 00:45:41,840
I think one other thing it wasn't

00:45:38,870 --> 00:45:44,090
instrumented per per query and I think

00:45:41,840 --> 00:45:45,620
that's really important so you're fine

00:45:44,090 --> 00:45:47,570
to do it the overhead actually was a

00:45:45,620 --> 00:45:51,260
little bit higher in 55 we managed to

00:45:47,570 --> 00:45:53,930
turn that down in in 56 but it won't be

00:45:51,260 --> 00:46:02,180
as useful as 56 s I think it's just

00:45:53,930 --> 00:46:04,910
leaps and bounds better thanks when your

00:46:02,180 --> 00:46:08,360
upgrade to the new version how how do

00:46:04,910 --> 00:46:12,980
you handle slaves now that you're

00:46:08,360 --> 00:46:16,550
changing the GTI DS yeah yeah so the GTI

00:46:12,980 --> 00:46:18,800
DS isn't enabled by default so those

00:46:16,550 --> 00:46:20,390
switch things you use GTI DS generally

00:46:18,800 --> 00:46:25,100
who I've seen people do is they upgrade

00:46:20,390 --> 00:46:27,980
256 cross the board and then they change

00:46:25,100 --> 00:46:30,400
to use GTI DS or take advantage of newer

00:46:27,980 --> 00:46:30,400
features

00:46:35,820 --> 00:46:37,880
you

00:46:44,620 --> 00:46:47,310
cool

00:46:49,730 --> 00:46:58,280
so this is about 75 new other things to

00:46:52,310 --> 00:47:00,200
find it's like an Easter hunt this is a

00:46:58,280 --> 00:47:02,090
vogue post that was done by a MySQL

00:47:00,200 --> 00:47:04,690
performance bug very nice to see that

00:47:02,090 --> 00:47:04,690
level of detail

00:47:13,960 --> 00:47:17,940

YouTube URL: https://www.youtube.com/watch?v=lqmn6_PD9Qo


