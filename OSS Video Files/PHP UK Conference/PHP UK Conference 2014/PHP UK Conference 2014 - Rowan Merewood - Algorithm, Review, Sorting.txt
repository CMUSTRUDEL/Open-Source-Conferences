Title: PHP UK Conference 2014 - Rowan Merewood - Algorithm, Review, Sorting
Publication date: 2014-03-21
Playlist: PHP UK Conference 2014
Description: 
	High-level languages and platforms abstract away basic computer science problems so we can code quicker and not re-invent the wheel. That said, algorithms are too much fun to just leave as a black box. We'll learn how to analyse and compare sorting algorithms with live demos and visualisations. With an algorithm from the 1800s, it could even be a history lesson too.
Captions: 
	00:00:04,549 --> 00:00:10,559
right good evening guys okay now the

00:00:08,280 --> 00:00:14,429
last session of the day normally it's my

00:00:10,559 --> 00:00:16,289
challenge to keep you guys awake and in

00:00:14,429 --> 00:00:18,000
a session like this where we're going to

00:00:16,289 --> 00:00:20,369
go into a bunch of algorithms quite

00:00:18,000 --> 00:00:23,250
unashamedly that that can sometimes be

00:00:20,369 --> 00:00:25,710
quite a steep challenge so I'm going to

00:00:23,250 --> 00:00:27,630
turn this around a bit the reason this

00:00:25,710 --> 00:00:30,630
talk is rescheduled is because my flight

00:00:27,630 --> 00:00:33,480
was late and I am actually incredibly

00:00:30,630 --> 00:00:36,300
jet-lagged so the challenge for you is

00:00:33,480 --> 00:00:39,690
to keep me awake throughout the duration

00:00:36,300 --> 00:00:41,340
of this talk so what that means is if

00:00:39,690 --> 00:00:43,680
there's something up on screen you don't

00:00:41,340 --> 00:00:46,890
understand if you want to ask a

00:00:43,680 --> 00:00:50,100
particular question so because I'm

00:00:46,890 --> 00:00:52,199
because I am quite tired I'm also likely

00:00:50,100 --> 00:00:54,239
to get all teary and emotional as well

00:00:52,199 --> 00:00:56,070
so if in the middle of quicksort you

00:00:54,239 --> 00:00:57,840
want to say something like hey well if

00:00:56,070 --> 00:01:00,059
you know if we do add another partition

00:00:57,840 --> 00:01:03,239
exactly how does that affect the big o

00:01:00,059 --> 00:01:09,600
of the function then you can see what

00:01:03,239 --> 00:01:13,320
happens when I cry also this means that

00:01:09,600 --> 00:01:16,439
I my other google colleagues are talking

00:01:13,320 --> 00:01:18,180
at the same time on App Engine so if you

00:01:16,439 --> 00:01:19,860
were having to sort of way up the

00:01:18,180 --> 00:01:21,119
decision between seeing two of my

00:01:19,860 --> 00:01:23,280
colleagues who are vastly better

00:01:21,119 --> 00:01:25,799
speakers on a far more interesting topic

00:01:23,280 --> 00:01:28,290
or coming to see me then I've stolen a

00:01:25,799 --> 00:01:30,240
bunch of their content as well so you're

00:01:28,290 --> 00:01:37,799
kind of getting a double whammy in this

00:01:30,240 --> 00:01:39,950
presentation so let's jump in put some

00:01:37,799 --> 00:01:43,710
philosophical questions to start with

00:01:39,950 --> 00:01:46,850
Who am I and why is my mouse cursor in

00:01:43,710 --> 00:01:46,850
the middle of the presentation

00:01:47,350 --> 00:01:53,329
that's less annoying ok so I'm a

00:01:51,649 --> 00:01:57,319
developer advocate for google this is

00:01:53,329 --> 00:01:59,179
not a googly talk but afterwards if you

00:01:57,319 --> 00:02:01,520
want to come ask me about platform stuff

00:01:59,179 --> 00:02:04,090
or any kind of integration then I'm more

00:02:01,520 --> 00:02:07,159
than happy to answer questions about it

00:02:04,090 --> 00:02:10,959
if you have a company that you want me

00:02:07,159 --> 00:02:13,730
to buy for sixteen billion dollars then

00:02:10,959 --> 00:02:16,670
my my credit limit doesn't quite hit

00:02:13,730 --> 00:02:18,019
that yet but give me a little time you

00:02:16,670 --> 00:02:20,360
can find me on these various social

00:02:18,019 --> 00:02:22,129
networks as well you can read my blog I

00:02:20,360 --> 00:02:24,319
update that every soft and when the wind

00:02:22,129 --> 00:02:26,150
is blowing in the right direction you

00:02:24,319 --> 00:02:29,540
can also find me on Twitter as Rowan

00:02:26,150 --> 00:02:31,879
underscore em or on google plus as plus

00:02:29,540 --> 00:02:35,810
row and Mia what you all have Google+

00:02:31,879 --> 00:02:38,810
accounts may not know it but you do n

00:02:35,810 --> 00:02:41,030
yeah so please feel free to ask me

00:02:38,810 --> 00:02:42,650
questions or just tell everybody how

00:02:41,030 --> 00:02:46,810
amazing my talk was on those various

00:02:42,650 --> 00:02:49,760
networks ok and why am I here why are we

00:02:46,810 --> 00:02:52,849
talking about sorting and search

00:02:49,760 --> 00:02:55,400
algorithms at a PHP conference well

00:02:52,849 --> 00:02:57,139
that's easy because first of all it's

00:02:55,400 --> 00:02:59,420
just awesome it's just complete science

00:02:57,139 --> 00:03:04,700
we don't need a reason beyond that

00:02:59,420 --> 00:03:06,500
that's it however so so in a way I have

00:03:04,700 --> 00:03:09,109
to kind of prefix all of this talk with

00:03:06,500 --> 00:03:11,030
an apology several apologies this

00:03:09,109 --> 00:03:13,250
particular one is I like to come to

00:03:11,030 --> 00:03:14,359
conferences and water talk and then go

00:03:13,250 --> 00:03:16,040
back with something that I can

00:03:14,359 --> 00:03:18,260
immediately apply in my day job on

00:03:16,040 --> 00:03:22,430
Monday morning this is not one of those

00:03:18,260 --> 00:03:24,620
talks but hopefully this is something

00:03:22,430 --> 00:03:27,919
that you can apply over the rest of your

00:03:24,620 --> 00:03:30,260
career instead so by taking you into

00:03:27,919 --> 00:03:32,690
some of these low-level details of how

00:03:30,260 --> 00:03:34,700
the algorithms work the performance

00:03:32,690 --> 00:03:37,010
behind them the the reasons that they do

00:03:34,700 --> 00:03:38,209
the things that they do they should help

00:03:37,010 --> 00:03:40,130
you understand the high-level

00:03:38,209 --> 00:03:42,470
abstractions so we'll talk a bit about

00:03:40,130 --> 00:03:45,109
the sorting algorithm that is used in

00:03:42,470 --> 00:03:46,370
PHP sort function some of the sorting

00:03:45,109 --> 00:03:48,349
algorithms that are used in the SPL

00:03:46,370 --> 00:03:52,579
functions and so on so by understanding

00:03:48,349 --> 00:03:54,470
those the first lessons takeaway is if

00:03:52,579 --> 00:03:57,289
you ever find yourself writing a sorting

00:03:54,470 --> 00:03:59,770
algorithm in PHP just step away from the

00:03:57,289 --> 00:04:02,230
keyboard and make see

00:03:59,770 --> 00:04:03,520
race question about what it is you're

00:04:02,230 --> 00:04:05,550
doing with your life because you are

00:04:03,520 --> 00:04:08,500
probably making the wrong decision

00:04:05,550 --> 00:04:10,270
that's it unless unless of course you've

00:04:08,500 --> 00:04:11,950
come to a conference to show everybody a

00:04:10,270 --> 00:04:13,930
bunch of examples of sorting algorithms

00:04:11,950 --> 00:04:17,590
in PHP in which case that is totally

00:04:13,930 --> 00:04:20,080
cool okay first of all we need to

00:04:17,590 --> 00:04:24,490
understand why we go about sorting data

00:04:20,080 --> 00:04:26,290
and the reason we've got here are at a

00:04:24,490 --> 00:04:29,080
sort of ease level we just want to

00:04:26,290 --> 00:04:31,180
display lists of things to humans and it

00:04:29,080 --> 00:04:32,710
feels a bit neater if we display that in

00:04:31,180 --> 00:04:36,010
a sorted fashion it's easier for people

00:04:32,710 --> 00:04:38,950
to deal with and then in kind of exactly

00:04:36,010 --> 00:04:41,170
the same way we want to sort that data

00:04:38,950 --> 00:04:44,830
in order to either allow us to

00:04:41,170 --> 00:04:46,830
categorize it so sorting it into the you

00:04:44,830 --> 00:04:51,940
know in index and our federal index

00:04:46,830 --> 00:04:54,190
sorting it into grades for an exam or we

00:04:51,940 --> 00:04:56,560
are looking to prepare the data that

00:04:54,190 --> 00:04:59,620
we've got for merging that together so

00:04:56,560 --> 00:05:03,040
for example if we're pulling in log

00:04:59,620 --> 00:05:04,690
streams from various machines then it's

00:05:03,040 --> 00:05:06,940
probably going to be in our interest to

00:05:04,690 --> 00:05:08,680
have that say sorted by timestamp before

00:05:06,940 --> 00:05:12,850
we go ahead trying to merge that into

00:05:08,680 --> 00:05:15,010
one unified log and also as we'll see in

00:05:12,850 --> 00:05:16,750
the latter half of the talk preparing

00:05:15,010 --> 00:05:19,120
that data for searching as well because

00:05:16,750 --> 00:05:21,160
it's generally easier to search through

00:05:19,120 --> 00:05:22,330
an ordered list then is to just sort

00:05:21,160 --> 00:05:26,320
through one that's in some kind of

00:05:22,330 --> 00:05:28,480
random order so just to sum up because

00:05:26,320 --> 00:05:30,490
frankly at the moment these slides are

00:05:28,480 --> 00:05:32,890
as much a surprise for you as they are

00:05:30,490 --> 00:05:34,360
for me so every so often a bullet point

00:05:32,890 --> 00:05:35,560
will pop up and are we kind of like oh

00:05:34,360 --> 00:05:37,570
yes that's what we were talking about

00:05:35,560 --> 00:05:40,090
whoever whoever wrote this at the right

00:05:37,570 --> 00:05:41,770
idea so we really split it into two

00:05:40,090 --> 00:05:44,470
situations here we're either trying to

00:05:41,770 --> 00:05:48,640
display that data or we're preparing our

00:05:44,470 --> 00:05:52,360
data for another operation everyone with

00:05:48,640 --> 00:05:56,980
me so far good good nodding not more

00:05:52,360 --> 00:05:59,650
vigorously yes good awesome okay now we

00:05:56,980 --> 00:06:01,419
know why we want to sort data so we've

00:05:59,650 --> 00:06:03,160
got some algorithms they can let us do

00:06:01,419 --> 00:06:05,080
this but we need some ways that we can

00:06:03,160 --> 00:06:06,370
compare those algorithms to each other

00:06:05,080 --> 00:06:08,440
so that we can make some kind of

00:06:06,370 --> 00:06:10,960
intelligent choice about which ones

00:06:08,440 --> 00:06:12,370
we're going to use so the first thing

00:06:10,960 --> 00:06:13,100
that I want to tell you about sorting

00:06:12,370 --> 00:06:14,870
algorithms

00:06:13,100 --> 00:06:19,280
is the difference between a stable sort

00:06:14,870 --> 00:06:20,810
and an unstable sort this is another one

00:06:19,280 --> 00:06:22,820
of those computer science terms that

00:06:20,810 --> 00:06:24,920
sounds a lot cooler than actually is

00:06:22,820 --> 00:06:27,230
unstable sorts do not mean that your

00:06:24,920 --> 00:06:29,600
computer may randomly explode at some

00:06:27,230 --> 00:06:33,410
point unless you're using one of those

00:06:29,600 --> 00:06:36,260
recalled chromebook power supplies but

00:06:33,410 --> 00:06:39,110
so a stable a stable algorithm means

00:06:36,260 --> 00:06:41,830
that if we have a list like this so our

00:06:39,110 --> 00:06:44,480
list in this case has two components

00:06:41,830 --> 00:06:46,250
we've got a numerical index on left and

00:06:44,480 --> 00:06:48,440
we've got a letter index on the right

00:06:46,250 --> 00:06:50,060
and what we're going to do is we want to

00:06:48,440 --> 00:06:53,060
sort that list but we only care about

00:06:50,060 --> 00:06:55,580
sorting it by the first index now in a

00:06:53,060 --> 00:06:58,070
stable sorting algorithm that means that

00:06:55,580 --> 00:07:00,800
when we sort this list we get our

00:06:58,070 --> 00:07:04,070
numerical sort here but the order of the

00:07:00,800 --> 00:07:05,990
elements so the eighth bva and so on

00:07:04,070 --> 00:07:07,820
those are all still appearing in the

00:07:05,990 --> 00:07:10,790
same order that they appeared in the

00:07:07,820 --> 00:07:14,810
original list so to go back to our

00:07:10,790 --> 00:07:16,430
example of sorting log entries what this

00:07:14,810 --> 00:07:17,840
would mean is that if your log entries

00:07:16,430 --> 00:07:20,690
were being written with the granularity

00:07:17,840 --> 00:07:22,880
of one second so you knew that when you

00:07:20,690 --> 00:07:25,190
were looking in the log that they all

00:07:22,880 --> 00:07:27,110
have the same index but you can be

00:07:25,190 --> 00:07:29,210
reasonably sure that they occurred one

00:07:27,110 --> 00:07:31,370
after another if you use a stable sort

00:07:29,210 --> 00:07:33,020
then you can be fairly sure that your

00:07:31,370 --> 00:07:36,470
items are still in chronological order

00:07:33,020 --> 00:07:38,540
now an unstable sort means that we can

00:07:36,470 --> 00:07:41,870
do exactly the same thing sort by the

00:07:38,540 --> 00:07:43,970
numbers but the order may change over

00:07:41,870 --> 00:07:46,370
here it also means if we run the

00:07:43,970 --> 00:07:47,930
algorithm again we may end up with a

00:07:46,370 --> 00:07:51,080
different ordering again for the

00:07:47,930 --> 00:07:53,120
secondary for the secondary indices so

00:07:51,080 --> 00:07:54,650
for our log example this would mean that

00:07:53,120 --> 00:07:56,870
we would have everything sorted by

00:07:54,650 --> 00:07:59,150
timestamps but anything that fell within

00:07:56,870 --> 00:08:00,500
that one second granularity might now be

00:07:59,150 --> 00:08:05,540
in a different order to the one we

00:08:00,500 --> 00:08:08,180
expected so stable unsorted portion is

00:08:05,540 --> 00:08:11,180
maintained unstable unsorted portion may

00:08:08,180 --> 00:08:12,440
change so again these are always all of

00:08:11,180 --> 00:08:15,620
these things they're trade-offs that

00:08:12,440 --> 00:08:17,690
you're going to choose to make because

00:08:15,620 --> 00:08:19,190
you may not care about the order of the

00:08:17,690 --> 00:08:20,960
original elements that may be fine in

00:08:19,190 --> 00:08:22,820
which case an unstable ibrehem may

00:08:20,960 --> 00:08:25,010
perform may have some other advantages

00:08:22,820 --> 00:08:28,919
that you can that you can use

00:08:25,010 --> 00:08:34,409
okay who who did computer science

00:08:28,919 --> 00:08:36,960
university awesome right so also if I do

00:08:34,409 --> 00:08:38,669
fall asleep you guys are now all my like

00:08:36,960 --> 00:08:40,800
sort of exit row people who will

00:08:38,669 --> 00:08:43,440
volunteer to get up and just take over

00:08:40,800 --> 00:08:45,540
the presentation because this should all

00:08:43,440 --> 00:08:47,279
be like really basic revision to you and

00:08:45,540 --> 00:08:50,820
you should be able to recite this stuff

00:08:47,279 --> 00:08:53,880
in your sleep okay Big O notation then

00:08:50,820 --> 00:08:57,839
is a way of measuring how an algorithm

00:08:53,880 --> 00:09:00,089
grows as we vary its types of input so

00:08:57,839 --> 00:09:03,260
when we talk about the type of its input

00:09:00,089 --> 00:09:05,940
what that might mean is resource usage

00:09:03,260 --> 00:09:08,190
sorry the growth of the function might

00:09:05,940 --> 00:09:10,320
mean resource usage so how much CPU time

00:09:08,190 --> 00:09:12,390
are we using how much memory we

00:09:10,320 --> 00:09:13,710
consuming how much hard disk space do we

00:09:12,390 --> 00:09:16,260
need to run this particular algorithm

00:09:13,710 --> 00:09:18,000
and then when we talk about the size of

00:09:16,260 --> 00:09:20,279
input specifically when we're talking

00:09:18,000 --> 00:09:22,470
about sort what we care about is the

00:09:20,279 --> 00:09:25,800
number of elements within the list that

00:09:22,470 --> 00:09:28,470
we're trying to sort so when we talk

00:09:25,800 --> 00:09:32,040
about Big O what this means is that

00:09:28,470 --> 00:09:33,750
we're basically defining defining an

00:09:32,040 --> 00:09:36,089
algorithm that will give us the rate of

00:09:33,750 --> 00:09:38,430
growth so does everyone remember from

00:09:36,089 --> 00:09:40,680
school you'd always have you know the

00:09:38,430 --> 00:09:47,910
the algorithms to draw a straight line

00:09:40,680 --> 00:09:49,650
so x equals let's say to y plus 3 or 3y

00:09:47,910 --> 00:09:52,050
plus 6 and so on that gives you a

00:09:49,650 --> 00:09:54,570
straight line so when we talk about Big

00:09:52,050 --> 00:09:56,820
O all we care about is the most

00:09:54,570 --> 00:09:58,170
significant factor in that because we

00:09:56,820 --> 00:10:00,839
just care about the growth of the

00:09:58,170 --> 00:10:04,529
function so if we have something

00:10:00,839 --> 00:10:06,450
constant 01 that means regardless of the

00:10:04,529 --> 00:10:08,070
size of the input it always takes the

00:10:06,450 --> 00:10:10,770
same amount of time to execute or the

00:10:08,070 --> 00:10:14,490
same amount of memory so when we talk

00:10:10,770 --> 00:10:16,170
about time oh one would be pretty

00:10:14,490 --> 00:10:18,029
unusual the idea that I have an

00:10:16,170 --> 00:10:20,310
algorithm that takes let's say one

00:10:18,029 --> 00:10:21,720
second with a hundred elements and then

00:10:20,310 --> 00:10:24,720
I give it a million elements and it

00:10:21,720 --> 00:10:26,370
still takes one second I mean you could

00:10:24,720 --> 00:10:28,830
fudge that obviously have an algorithm

00:10:26,370 --> 00:10:30,630
that takes ten years to sort ten

00:10:28,830 --> 00:10:32,610
elements and also takes 10 years to saw

00:10:30,630 --> 00:10:35,600
a hundred elements but that is of

00:10:32,610 --> 00:10:35,600
limited utility

00:10:35,720 --> 00:10:42,000
linear growth then linear growth is as

00:10:39,510 --> 00:10:43,920
you would expect this is when I have one

00:10:42,000 --> 00:10:45,750
element it takes one second to element

00:10:43,920 --> 00:10:47,310
two seconds three elements three seconds

00:10:45,750 --> 00:10:48,960
and so on but like I was saying because

00:10:47,310 --> 00:10:51,480
we care about the most significant

00:10:48,960 --> 00:10:53,790
factor that that could have an

00:10:51,480 --> 00:10:57,000
additional factor so it could be 2n or

00:10:53,790 --> 00:10:59,130
3n or 4n we don't care so much about how

00:10:57,000 --> 00:11:02,160
much it's growing we care about the rate

00:10:59,130 --> 00:11:04,020
at which it grows so again linear is

00:11:02,160 --> 00:11:06,180
fairly fair especially in terms of time

00:11:04,020 --> 00:11:08,940
and sort of intuitively makes sense if

00:11:06,180 --> 00:11:10,740
I'm doing an operation per element then

00:11:08,940 --> 00:11:14,460
I'm going to have to do though that

00:11:10,740 --> 00:11:16,110
number of operations as it grows now the

00:11:14,460 --> 00:11:17,880
next one we have and this is where you

00:11:16,110 --> 00:11:20,250
start to find a lot of algorithms

00:11:17,880 --> 00:11:23,190
falling into this space is the

00:11:20,250 --> 00:11:25,830
logarithmic growth now the logarithmic

00:11:23,190 --> 00:11:28,170
growth is that kind of gentle natural

00:11:25,830 --> 00:11:31,950
curve that you generally see for like

00:11:28,170 --> 00:11:33,780
adjusting volume and so on and and what

00:11:31,950 --> 00:11:36,000
we'll see in the algorithms is this

00:11:33,780 --> 00:11:38,640
tends to be indicative of an algorithm

00:11:36,000 --> 00:11:40,740
where you have a problem space that is

00:11:38,640 --> 00:11:42,570
at this stage to begin with you do some

00:11:40,740 --> 00:11:44,040
kind of operation and you cut your

00:11:42,570 --> 00:11:46,560
problems based down to a smaller

00:11:44,040 --> 00:11:48,810
partition and then repeat cut it down to

00:11:46,560 --> 00:11:50,790
a smaller partition and repeat so you

00:11:48,810 --> 00:11:56,100
get that kind of growth that follows a

00:11:50,790 --> 00:11:58,350
nice curve this one is bad this this is

00:11:56,100 --> 00:12:02,640
where your algorithm is just starting to

00:11:58,350 --> 00:12:04,980
well you know 24 16 32 64 is just

00:12:02,640 --> 00:12:07,200
getting bigger and bigger as sort of by

00:12:04,980 --> 00:12:10,170
a power of 2 every time and of course

00:12:07,200 --> 00:12:11,910
you can carry on making that more and

00:12:10,170 --> 00:12:14,730
more ludicrous powers if you really want

00:12:11,910 --> 00:12:17,220
to but on the whole if your algorithm is

00:12:14,730 --> 00:12:22,710
N squared it's probably not the one that

00:12:17,220 --> 00:12:24,060
you want okay adaptability then this is

00:12:22,710 --> 00:12:26,310
where I skip ahead a bullet point

00:12:24,060 --> 00:12:27,960
because my jet lag brain has actually

00:12:26,310 --> 00:12:31,540
forgotten what adaptability is but

00:12:27,960 --> 00:12:35,050
luckily i wrote a definition here so

00:12:31,540 --> 00:12:36,880
so the adaptive algorithm is important

00:12:35,050 --> 00:12:39,820
again this means that you have better

00:12:36,880 --> 00:12:43,540
performance on a list that is already

00:12:39,820 --> 00:12:46,360
sorted or partially sorted so again to

00:12:43,540 --> 00:12:49,810
go back to our joining logs from various

00:12:46,360 --> 00:12:52,120
sources in that situation we know that

00:12:49,810 --> 00:12:54,069
our list is mostly sorted because our

00:12:52,120 --> 00:12:56,170
servers are all roughly in sync so there

00:12:54,069 --> 00:12:57,970
might be some time stamps that are

00:12:56,170 --> 00:12:59,889
slipping in the wrong place and we just

00:12:57,970 --> 00:13:01,449
want to sort that out so an adaptive

00:12:59,889 --> 00:13:03,310
algorithm is going to perform a lot

00:13:01,449 --> 00:13:05,500
better there whereas we may have other

00:13:03,310 --> 00:13:07,360
algorithms that as we'll see if they're

00:13:05,500 --> 00:13:09,190
not adaptive then they're going to take

00:13:07,360 --> 00:13:10,660
exactly the same amount of time as if

00:13:09,190 --> 00:13:12,490
they just received all the time stamps

00:13:10,660 --> 00:13:18,790
in a random order when we've only got a

00:13:12,490 --> 00:13:21,190
few operations to do okay now we get

00:13:18,790 --> 00:13:22,630
into the code bit so now you can alway

00:13:21,190 --> 00:13:24,970
Cup because the words are done we can

00:13:22,630 --> 00:13:27,579
just go straight into code which is far

00:13:24,970 --> 00:13:30,759
more exciting we're going to cover off

00:13:27,579 --> 00:13:34,000
insertion sort first now insertion sort

00:13:30,759 --> 00:13:37,240
is one of the easiest ones to understand

00:13:34,000 --> 00:13:39,040
because in in my head it's kind of the

00:13:37,240 --> 00:13:40,899
way that I would sort things if I was

00:13:39,040 --> 00:13:42,940
just given a sort of series of physical

00:13:40,899 --> 00:13:45,899
blocks to sort into color order or

00:13:42,940 --> 00:13:47,980
something so this is what it looks like

00:13:45,899 --> 00:13:49,630
don't worry about reading the code

00:13:47,980 --> 00:13:52,810
because what I want you to get out of

00:13:49,630 --> 00:13:54,910
this is actually understanding the

00:13:52,810 --> 00:13:58,089
effect that the blocks of code are

00:13:54,910 --> 00:14:01,420
having on the on the performance of the

00:13:58,089 --> 00:14:03,370
algorithm this is this is all online and

00:14:01,420 --> 00:14:04,600
linkable and the code is on github and

00:14:03,370 --> 00:14:06,850
everything so you can go back and play

00:14:04,600 --> 00:14:09,120
with it later if you want to so what

00:14:06,850 --> 00:14:11,800
we've got inside of the insertion sort

00:14:09,120 --> 00:14:13,569
to just highlight at this level first as

00:14:11,800 --> 00:14:15,550
you can see that we've got two levels of

00:14:13,569 --> 00:14:16,930
indentation so we've got a for loop at

00:14:15,550 --> 00:14:18,339
the top and we've got a while loop in

00:14:16,930 --> 00:14:20,079
the middle this is going to have an

00:14:18,339 --> 00:14:22,000
important effect on what happens with

00:14:20,079 --> 00:14:24,189
our big o growth of the algorithm as we

00:14:22,000 --> 00:14:26,949
go through it so the way these blocks

00:14:24,189 --> 00:14:28,990
work then is at the top level you can

00:14:26,949 --> 00:14:30,459
see that we've said iterations is the

00:14:28,990 --> 00:14:32,439
count of the elements so we're going to

00:14:30,459 --> 00:14:35,199
have at least one iteration to element

00:14:32,439 --> 00:14:37,569
and then we've got a for loop through

00:14:35,199 --> 00:14:40,089
those elements so if that's all we had

00:14:37,569 --> 00:14:42,459
then and we do no other operations

00:14:40,089 --> 00:14:45,080
inside of that loop then our algorithm

00:14:42,459 --> 00:14:46,490
is 0 n because it just grows with the

00:14:45,080 --> 00:14:49,190
number of elements that we put into it

00:14:46,490 --> 00:14:51,950
in a linear fashion now what's actually

00:14:49,190 --> 00:14:54,770
happening inside of the insertion sort

00:14:51,950 --> 00:14:58,010
is that we are basically picking up an

00:14:54,770 --> 00:15:00,380
element and dragging along comparing it

00:14:58,010 --> 00:15:03,020
to each element in turn and when we find

00:15:00,380 --> 00:15:04,730
that it is in the right place in order

00:15:03,020 --> 00:15:06,320
to you know to be sorted against the

00:15:04,730 --> 00:15:08,030
other elements then we're just dropping

00:15:06,320 --> 00:15:09,890
it down and then we go back to the

00:15:08,030 --> 00:15:12,050
beginning and we pick up another element

00:15:09,890 --> 00:15:13,310
and we go along again just comparing it

00:15:12,050 --> 00:15:15,950
to the elements that we've seen and

00:15:13,310 --> 00:15:17,240
dropping it down in the right place so

00:15:15,950 --> 00:15:18,980
you can see that's what's happening here

00:15:17,240 --> 00:15:21,260
we've picked out an element which is our

00:15:18,980 --> 00:15:23,120
insert index and we're just looping

00:15:21,260 --> 00:15:26,060
through comparing it to the element next

00:15:23,120 --> 00:15:29,870
to it and if it's in the wrong place

00:15:26,060 --> 00:15:31,640
then we're swapping them now the

00:15:29,870 --> 00:15:34,160
important point here about an adaptable

00:15:31,640 --> 00:15:36,170
algorithm is with this if the list is

00:15:34,160 --> 00:15:39,020
already in order then that while loop is

00:15:36,170 --> 00:15:41,510
not entered so for a sorted list then

00:15:39,020 --> 00:15:43,280
our algorithm is 0 n which means that

00:15:41,510 --> 00:15:45,170
this can actually be useful in certain

00:15:43,280 --> 00:15:50,000
situations despite being incredibly

00:15:45,170 --> 00:15:52,370
simplistic ok now this is the bit where

00:15:50,000 --> 00:15:55,040
I'm actually far more excited about this

00:15:52,370 --> 00:15:58,010
talk than you are because what we have

00:15:55,040 --> 00:16:00,710
going on here is these these are not

00:15:58,010 --> 00:16:02,540
just slides this is an application so

00:16:00,710 --> 00:16:04,850
all of the code that I'm showing you

00:16:02,540 --> 00:16:06,530
there is actually the code that is

00:16:04,850 --> 00:16:10,130
powering the visualization underneath

00:16:06,530 --> 00:16:15,110
this you guys really aren't as excited

00:16:10,130 --> 00:16:16,940
about this as I ok right so what I'm

00:16:15,110 --> 00:16:19,310
going to do is take you through the

00:16:16,940 --> 00:16:20,960
visualizations are each of the sorting

00:16:19,310 --> 00:16:22,820
algorithms so that we can kind of see

00:16:20,960 --> 00:16:25,100
the pattern that's going on as we work

00:16:22,820 --> 00:16:28,610
through them the other fun thing about

00:16:25,100 --> 00:16:32,090
this as well is that these these sets

00:16:28,610 --> 00:16:34,160
are generated randomly each time so at

00:16:32,090 --> 00:16:36,560
least on one of these talks I have had

00:16:34,160 --> 00:16:38,300
it just generate an ordered list which

00:16:36,560 --> 00:16:43,190
has not made the sorting of that

00:16:38,300 --> 00:16:46,850
exciting but luckily this one is not in

00:16:43,190 --> 00:16:48,080
order so we jump in and you can see that

00:16:46,850 --> 00:16:50,300
the first thing we do is we set our

00:16:48,080 --> 00:16:53,360
index to the first element of the sonar

00:16:50,300 --> 00:16:56,480
the first element the my head is not

00:16:53,360 --> 00:16:58,259
being zero indexed so we set it to

00:16:56,480 --> 00:17:00,749
element number one rather than element

00:16:58,259 --> 00:17:02,459
number 0 and at that point what we've

00:17:00,749 --> 00:17:05,039
done is we've compared it with the one

00:17:02,459 --> 00:17:06,419
there and we've said okay that's fine we

00:17:05,039 --> 00:17:08,699
don't need to do anything so we just

00:17:06,419 --> 00:17:11,269
move along we move our index along to 65

00:17:08,699 --> 00:17:14,039
I'm going to compare that that's fine

00:17:11,269 --> 00:17:15,209
273 and you can see this is where it

00:17:14,039 --> 00:17:16,529
gets a little bit tedious where it

00:17:15,209 --> 00:17:18,149
hasn't put them in the wrong waters

00:17:16,529 --> 00:17:21,029
start with now luckily we get down to

00:17:18,149 --> 00:17:24,059
116 now 116 obviously something has to

00:17:21,029 --> 00:17:27,029
happen with this so we compare it to 73

00:17:24,059 --> 00:17:29,940
and it's wrong so we swap it we compare

00:17:27,029 --> 00:17:31,799
it again it's wrong so we swap it and we

00:17:29,940 --> 00:17:33,720
keep going through swapping it round

00:17:31,799 --> 00:17:35,820
until we get down to here where it's in

00:17:33,720 --> 00:17:38,010
the right position we don't need to do

00:17:35,820 --> 00:17:40,230
anything so then we jump back to where

00:17:38,010 --> 00:17:42,419
we were in the index again we pick up

00:17:40,230 --> 00:17:44,669
this element and we start pulling this

00:17:42,419 --> 00:17:47,519
one down till it's in the right location

00:17:44,669 --> 00:17:50,639
jump forward pull it down to the right

00:17:47,519 --> 00:17:52,710
location and again oh this is fun we get

00:17:50,639 --> 00:17:58,639
to watch it go all the way down the list

00:17:52,710 --> 00:18:01,950
and eventually we've got a sorted list

00:17:58,639 --> 00:18:05,190
okay so some things about insertion sort

00:18:01,950 --> 00:18:07,080
then to recap our best case is 0 n if

00:18:05,190 --> 00:18:08,309
the list is sorted we don't have to do

00:18:07,080 --> 00:18:11,039
anything other than scan through the

00:18:08,309 --> 00:18:13,740
elements once our average to worst case

00:18:11,039 --> 00:18:16,260
is 0 N squared so that's why we had

00:18:13,740 --> 00:18:18,059
those two blocks of code if the list is

00:18:16,260 --> 00:18:19,830
in reverse order then what we're going

00:18:18,059 --> 00:18:21,600
to have to do is basically drag every

00:18:19,830 --> 00:18:23,909
single element back through the array

00:18:21,600 --> 00:18:28,049
each time which will give us that M

00:18:23,909 --> 00:18:30,659
squared pattern the memory usage is Om

00:18:28,049 --> 00:18:31,980
now this is actually the case for all of

00:18:30,659 --> 00:18:35,580
the algorithms that i'm going to show

00:18:31,980 --> 00:18:39,090
you in this in this talk because what i

00:18:35,580 --> 00:18:41,610
have done is have I actually said yes I

00:18:39,090 --> 00:18:44,220
have said good each of these algorithms

00:18:41,610 --> 00:18:45,990
are in place algorithms the reason for

00:18:44,220 --> 00:18:47,580
this is because it was vastly easier for

00:18:45,990 --> 00:18:50,370
me to put a visualization together for

00:18:47,580 --> 00:18:53,220
it but the educational reason for in

00:18:50,370 --> 00:18:55,980
place in place means that we only need

00:18:53,220 --> 00:18:58,470
the size will need the memory there's

00:18:55,980 --> 00:19:00,990
the size of the list plus one additional

00:18:58,470 --> 00:19:04,019
bit of memory to sometimes hold the to

00:19:00,990 --> 00:19:06,889
hold the element that we're sorting now

00:19:04,019 --> 00:19:09,059
what you often find is the other

00:19:06,889 --> 00:19:11,460
implementations of these algorithms so

00:19:09,059 --> 00:19:12,179
for example the insertion sort rather

00:19:11,460 --> 00:19:14,580
than

00:19:12,179 --> 00:19:16,710
rearranging the existing array you just

00:19:14,580 --> 00:19:19,369
take elements and build a new array side

00:19:16,710 --> 00:19:23,039
by side so in a lot of those situations

00:19:19,369 --> 00:19:25,139
an in-place algorithm is not necessarily

00:19:23,039 --> 00:19:27,600
the most efficient from a computer from

00:19:25,139 --> 00:19:29,490
a CPU cycles point of view but from a

00:19:27,600 --> 00:19:31,190
memory usage point of view it means that

00:19:29,490 --> 00:19:33,720
we just use the same block every time

00:19:31,190 --> 00:19:35,820
and it also means the visualizations are

00:19:33,720 --> 00:19:38,460
easier for me and finally there's

00:19:35,820 --> 00:19:41,639
another property online so what online

00:19:38,460 --> 00:19:43,799
means is that I am able to sort new

00:19:41,639 --> 00:19:46,289
elements into the array as they arrive

00:19:43,799 --> 00:19:47,999
an offline sorting algorithm means I

00:19:46,289 --> 00:19:51,119
need to be given the entire array to

00:19:47,999 --> 00:19:53,129
sort before I can go ahead and put it

00:19:51,119 --> 00:19:54,749
into order and if I get given a new

00:19:53,129 --> 00:19:56,490
element then I basically have to treat

00:19:54,749 --> 00:20:00,450
it like a brand new list and run through

00:19:56,490 --> 00:20:03,440
the entire process all over again okay

00:20:00,450 --> 00:20:07,889
insertion sort seemed clear for everyone

00:20:03,440 --> 00:20:10,169
good good okay now bubble sort bubble

00:20:07,889 --> 00:20:13,080
sort is where we can start to use a few

00:20:10,169 --> 00:20:16,590
drinks analogies which which makes it

00:20:13,080 --> 00:20:18,389
kind of natural territory for me and for

00:20:16,590 --> 00:20:21,389
a few of you judging by the tweets from

00:20:18,389 --> 00:20:23,460
last night okay now inside of bubble

00:20:21,389 --> 00:20:26,309
sort you can see again that what we've

00:20:23,460 --> 00:20:28,679
got is a similar sort of level we've got

00:20:26,309 --> 00:20:30,269
two for loops inside of there so

00:20:28,679 --> 00:20:32,399
immediately that should be telling us

00:20:30,269 --> 00:20:34,200
that we've got the possibility for this

00:20:32,399 --> 00:20:36,779
to be N squared because we could

00:20:34,200 --> 00:20:38,429
conceivably loop through every we could

00:20:36,779 --> 00:20:39,960
leap through every element and inside of

00:20:38,429 --> 00:20:42,720
that loop loop through every element

00:20:39,960 --> 00:20:46,619
again now what we're doing inside of

00:20:42,720 --> 00:20:48,360
bubble sort is we're setting swap to

00:20:46,619 --> 00:20:50,580
false at the start to tell us we haven't

00:20:48,360 --> 00:20:51,840
changed anything about the array and

00:20:50,580 --> 00:20:53,519
we're going to leap through the elements

00:20:51,840 --> 00:20:55,470
and if at the end of that we haven't

00:20:53,519 --> 00:20:59,249
swapped anything then we know that the

00:20:55,470 --> 00:21:01,889
array is sorted so if we go inside of

00:20:59,249 --> 00:21:03,029
that what we start to do is we go

00:21:01,889 --> 00:21:04,559
through and you can see this is very

00:21:03,029 --> 00:21:06,419
similar to the insertion sort because

00:21:04,559 --> 00:21:08,129
we're doing the same sort of comparison

00:21:06,419 --> 00:21:11,759
as we walk through it we're basically

00:21:08,129 --> 00:21:13,889
looking at the elements and if the

00:21:11,759 --> 00:21:15,419
element that we're comparing is in the

00:21:13,889 --> 00:21:17,490
wrong place compared to the other one

00:21:15,419 --> 00:21:19,320
then we're going to swap them around so

00:21:17,490 --> 00:21:22,230
the difference between this and the

00:21:19,320 --> 00:21:24,240
insertion sort is rather than picking up

00:21:22,230 --> 00:21:24,700
an element and kind of dragging it to

00:21:24,240 --> 00:21:26,770
the right

00:21:24,700 --> 00:21:29,110
place we're basically going through and

00:21:26,770 --> 00:21:32,380
we're just swapping elements as we work

00:21:29,110 --> 00:21:34,420
our way through the array so again if

00:21:32,380 --> 00:21:36,970
the list is in order then swapped stays

00:21:34,420 --> 00:21:40,480
false that means that we only do this we

00:21:36,970 --> 00:21:44,350
only do an M it's only om for an ordered

00:21:40,480 --> 00:21:48,040
list okay so let's do some iterations of

00:21:44,350 --> 00:21:49,690
this then first test it is out of order

00:21:48,040 --> 00:21:51,520
so we're going to see something in this

00:21:49,690 --> 00:21:53,890
one so you can see here that we've

00:21:51,520 --> 00:21:56,170
started the index at the other end and

00:21:53,890 --> 00:21:58,780
we're going through and we're actually

00:21:56,170 --> 00:22:01,480
comparing it to this upper bound of the

00:21:58,780 --> 00:22:03,870
list to start with I'm going to work

00:22:01,480 --> 00:22:06,820
through and we take that element now

00:22:03,870 --> 00:22:09,040
when people normally say bubble sort the

00:22:06,820 --> 00:22:10,690
way they intend for you to visualize it

00:22:09,040 --> 00:22:12,370
is that the elements each have a kind of

00:22:10,690 --> 00:22:15,190
density so the lighter elements are the

00:22:12,370 --> 00:22:16,750
ones that bubble up to the top given

00:22:15,190 --> 00:22:18,550
that in hindsight I should have put the

00:22:16,750 --> 00:22:20,950
visualization the other way up i'm going

00:22:18,550 --> 00:22:22,120
to use more of a cocktail analogy here

00:22:20,950 --> 00:22:24,070
and you can imagine that these are the

00:22:22,120 --> 00:22:27,010
heavier liquids kind of sinking down

00:22:24,070 --> 00:22:29,110
through the cocktail instead so you can

00:22:27,010 --> 00:22:31,060
see though we've gone up to the top

00:22:29,110 --> 00:22:33,790
we've seen three through seven and that

00:22:31,060 --> 00:22:35,590
is basically going to sink down through

00:22:33,790 --> 00:22:38,740
the array as we compare it to yell over

00:22:35,590 --> 00:22:42,070
elements when we get down to here we

00:22:38,740 --> 00:22:45,100
know that because 337 has sunk down to

00:22:42,070 --> 00:22:47,590
the right place that we can basically

00:22:45,100 --> 00:22:50,230
move ahead and we can work on a smaller

00:22:47,590 --> 00:22:53,460
version of the array so we go on through

00:22:50,230 --> 00:22:57,010
we start comparing that one sinks down

00:22:53,460 --> 00:23:00,070
move our index ahead that one sings down

00:22:57,010 --> 00:23:09,010
to the right location index moves ahead

00:23:00,070 --> 00:23:10,420
again and are we just about their first

00:23:09,010 --> 00:23:12,580
time I run through this I did have an

00:23:10,420 --> 00:23:14,230
off by one error which meant that

00:23:12,580 --> 00:23:15,820
sometimes I would think oh we're you

00:23:14,230 --> 00:23:17,590
know we're nearly there and then it

00:23:15,820 --> 00:23:19,390
would just stop and not sort the

00:23:17,590 --> 00:23:21,340
entirety of the array the other one who

00:23:19,390 --> 00:23:23,500
was doing was sometimes popping in this

00:23:21,340 --> 00:23:27,220
additional magic element from nowhere at

00:23:23,500 --> 00:23:28,840
the top of the array I lesson is don't

00:23:27,220 --> 00:23:30,250
code on planes when you don't have an

00:23:28,840 --> 00:23:31,840
internet connection because it turns out

00:23:30,250 --> 00:23:34,350
you know nothing without the internet

00:23:31,840 --> 00:23:34,350
behind you

00:23:34,729 --> 00:23:42,019
okay so we are nearly out of place so

00:23:39,359 --> 00:23:47,070
this is a last element coming through

00:23:42,019 --> 00:23:48,839
and we get here and we're done okay so

00:23:47,070 --> 00:23:51,119
some things about bubble sort then best

00:23:48,839 --> 00:23:52,369
case is 0 n because as we saw sorted

00:23:51,119 --> 00:23:55,259
list we just looped through at once

00:23:52,369 --> 00:23:58,289
average worst-case and squared which is

00:23:55,259 --> 00:24:03,389
bad memory usage again because it's an

00:23:58,289 --> 00:24:06,539
in-place algorithm is 0 n but one of the

00:24:03,389 --> 00:24:10,499
things about bubble sort is who who

00:24:06,539 --> 00:24:12,529
knows who knuth is so anyone actually

00:24:10,499 --> 00:24:17,279
read the art of computer programming

00:24:12,529 --> 00:24:20,279
well I'd cover to cover now can some

00:24:17,279 --> 00:24:22,349
kind of masochist okay so so news is

00:24:20,279 --> 00:24:26,459
like The Godfather of computer

00:24:22,349 --> 00:24:27,929
programming and the way the way he

00:24:26,459 --> 00:24:29,669
teaches computer programming is you

00:24:27,929 --> 00:24:31,139
basically invents his own programming

00:24:29,669 --> 00:24:34,169
language to teach you computer

00:24:31,139 --> 00:24:36,419
programming now he had this to say about

00:24:34,169 --> 00:24:38,129
bubble sort seems to have nothing to

00:24:36,419 --> 00:24:39,539
recommend it except it has a catchy name

00:24:38,129 --> 00:24:43,499
and the fact that leads to some

00:24:39,539 --> 00:24:45,749
interesting theoretical problems so not

00:24:43,499 --> 00:24:48,089
only not only am I giving you a talk

00:24:45,749 --> 00:24:49,889
with no immediate practical application

00:24:48,089 --> 00:24:53,309
i'm showing you algorithms they aren't

00:24:49,889 --> 00:24:58,259
even going to apply in real life you

00:24:53,309 --> 00:25:00,799
suckers okay no let's do something

00:24:58,259 --> 00:25:03,809
actually useful okay so quick sort then

00:25:00,799 --> 00:25:05,820
now that we understand the two very

00:25:03,809 --> 00:25:07,709
simple ones we're going to move on to

00:25:05,820 --> 00:25:10,649
the algorithm where it starts to get

00:25:07,709 --> 00:25:12,329
genuinely practical and applicable but

00:25:10,649 --> 00:25:14,190
also starts to move into the territory

00:25:12,329 --> 00:25:16,529
where we're using recursion so I

00:25:14,190 --> 00:25:20,099
genuinely have no idea what is going on

00:25:16,529 --> 00:25:22,769
some of the times ok this is what quick

00:25:20,099 --> 00:25:25,829
so it looks like from the top level it

00:25:22,769 --> 00:25:27,509
starts off as recursive so we've had to

00:25:25,829 --> 00:25:29,879
break out our kind of starter function

00:25:27,509 --> 00:25:32,039
to just say sort and what we're going to

00:25:29,879 --> 00:25:34,919
do is when do the quicksort on that list

00:25:32,039 --> 00:25:36,539
of elements starting and the partition

00:25:34,919 --> 00:25:39,089
we're going to define to do our sort on

00:25:36,539 --> 00:25:41,249
is going to be zero all the way up to

00:25:39,089 --> 00:25:43,360
the end so we're basically just starting

00:25:41,249 --> 00:25:47,230
our recursive call with the entire list

00:25:43,360 --> 00:25:48,640
now inside of the quicksort you can see

00:25:47,230 --> 00:25:50,740
that we're going to do is we entered

00:25:48,640 --> 00:25:52,240
divide that array into two and we're

00:25:50,740 --> 00:25:55,870
going to pick a pivot value in the

00:25:52,240 --> 00:25:57,570
middle and then we're going to go

00:25:55,870 --> 00:26:00,880
through either side of this array

00:25:57,570 --> 00:26:03,790
walking down and comparing each of the

00:26:00,880 --> 00:26:06,580
items to the pivot value so over here

00:26:03,790 --> 00:26:08,260
when we find an item that is higher than

00:26:06,580 --> 00:26:10,000
the pivot value then we're going to hold

00:26:08,260 --> 00:26:11,650
on to that one and over here when we

00:26:10,000 --> 00:26:13,870
find an item that's lower than the pivot

00:26:11,650 --> 00:26:15,850
value and a hold on to that one or in a

00:26:13,870 --> 00:26:17,919
swap them and when you keep walking

00:26:15,850 --> 00:26:19,690
those in these seas down until we've

00:26:17,919 --> 00:26:21,370
basically swapped out all of the ones

00:26:19,690 --> 00:26:23,380
that are higher than the pivot over to

00:26:21,370 --> 00:26:26,919
this side all of the ones that are lower

00:26:23,380 --> 00:26:28,960
than the pivot over to this side once

00:26:26,919 --> 00:26:31,929
we've done that we're then going to

00:26:28,960 --> 00:26:34,000
recursively call quicksort on this part

00:26:31,929 --> 00:26:38,080
of the array and on this part of the

00:26:34,000 --> 00:26:40,660
array I have a problem with recursive

00:26:38,080 --> 00:26:42,970
algorithms in the that all sounds very

00:26:40,660 --> 00:26:44,559
simple and the code is very elegant you

00:26:42,970 --> 00:26:46,929
know you just kind of like it's divide

00:26:44,559 --> 00:26:49,330
and conquer I take my problem and I do

00:26:46,929 --> 00:26:50,980
it once on the long on the list and then

00:26:49,330 --> 00:26:52,690
I break it down to a smaller list and i

00:26:50,980 --> 00:26:55,540
run the problem again the problem i have

00:26:52,690 --> 00:26:57,309
is i don't really see exactly how that's

00:26:55,540 --> 00:27:02,559
sorting the list but when you get to the

00:26:57,309 --> 00:27:06,010
end the list is sorted so you know don't

00:27:02,559 --> 00:27:08,260
don't question it so let's take a look

00:27:06,010 --> 00:27:09,940
at what we're doing inside of that so

00:27:08,260 --> 00:27:13,330
this is the bit where I said that if you

00:27:09,940 --> 00:27:15,040
wanted to ask interesting questions that

00:27:13,330 --> 00:27:17,380
i will not be able to answer then this

00:27:15,040 --> 00:27:21,820
is our pivot index so we're choosing our

00:27:17,380 --> 00:27:25,990
pivot index by taking the left index

00:27:21,820 --> 00:27:29,700
which is 0 and adding basically we're

00:27:25,990 --> 00:27:32,470
picking somewhere in the middle but

00:27:29,700 --> 00:27:35,110
picking a different index can affect the

00:27:32,470 --> 00:27:36,850
algorithm in subtly different ways we're

00:27:35,110 --> 00:27:38,910
also being very simplistic here and that

00:27:36,850 --> 00:27:40,720
we're just dividing the array into to

00:27:38,910 --> 00:27:42,309
some of the things that we'll talk about

00:27:40,720 --> 00:27:43,780
in a bit is that you don't have to

00:27:42,309 --> 00:27:45,429
divide it into two you can divide it

00:27:43,780 --> 00:27:49,360
into three you can even divide it into

00:27:45,429 --> 00:27:51,340
four ok we hold on to our indices and

00:27:49,360 --> 00:27:54,160
then we're going to go through and work

00:27:51,340 --> 00:27:56,110
through that as we go through we've just

00:27:54,160 --> 00:27:56,920
got a very simple thin here we're all

00:27:56,110 --> 00:27:59,620
we're having to do is

00:27:56,920 --> 00:28:01,240
pick out our indices again and once we

00:27:59,620 --> 00:28:05,500
know that they're ready to be swapped

00:28:01,240 --> 00:28:07,780
then we swap them and then you can see

00:28:05,500 --> 00:28:10,540
again we have all that stuff above so we

00:28:07,780 --> 00:28:14,290
process through our partition and then

00:28:10,540 --> 00:28:18,930
we just call the quicksort again on the

00:28:14,290 --> 00:28:24,070
different partitions of the array okay

00:28:18,930 --> 00:28:26,100
straighforward okay yeah you guys aren't

00:28:24,070 --> 00:28:29,260
nodding so you aren't lying to me right

00:28:26,100 --> 00:28:30,730
let's look at some iterations then so

00:28:29,260 --> 00:28:35,650
this hopefully might make it a little

00:28:30,730 --> 00:28:37,540
clearer first of all we take that we we

00:28:35,650 --> 00:28:41,320
break our array up into our partitions

00:28:37,540 --> 00:28:43,720
and what we're actually doing is we're

00:28:41,320 --> 00:28:46,750
recursing down on each of the partitions

00:28:43,720 --> 00:28:49,300
first so inside of here you can see that

00:28:46,750 --> 00:28:52,210
we need to swap those because they're in

00:28:49,300 --> 00:28:55,270
the wrong place we partition down again

00:28:52,210 --> 00:28:57,820
we look at those those are in the wrong

00:28:55,270 --> 00:28:59,590
place so we're going to swap them then

00:28:57,820 --> 00:29:01,990
we jump back up because our recursion

00:28:59,590 --> 00:29:03,190
for that particular partition has

00:29:01,990 --> 00:29:05,020
finished because we've gone all the way

00:29:03,190 --> 00:29:06,370
down to one element so we're jumping

00:29:05,020 --> 00:29:08,830
back up to deal with one of the other

00:29:06,370 --> 00:29:11,380
partitions so you can see that we start

00:29:08,830 --> 00:29:13,150
breaking it down into here look inside

00:29:11,380 --> 00:29:16,210
of that one now that one's conveniently

00:29:13,150 --> 00:29:18,550
sorted so that's fine that one sorted we

00:29:16,210 --> 00:29:20,260
jump back up to this smaller partition

00:29:18,550 --> 00:29:24,670
over here again you can see that we've

00:29:20,260 --> 00:29:30,700
got some swapping to do we jump down and

00:29:24,670 --> 00:29:32,320
ah good yeah okay so we still got one to

00:29:30,700 --> 00:29:33,970
go I just had this horrible feeling that

00:29:32,320 --> 00:29:36,970
some voodoo is going on oh you've even

00:29:33,970 --> 00:29:39,590
got duplicate elements in here what's

00:29:36,970 --> 00:29:46,429
going to happen

00:29:39,590 --> 00:29:49,640
I could consult the tests but so no okay

00:29:46,429 --> 00:29:53,480
so we go through and those need to be

00:29:49,640 --> 00:29:54,860
spot that one's fine oh no no hopefully

00:29:53,480 --> 00:29:58,850
we should see the slop here we see a

00:29:54,860 --> 00:30:00,440
spot and we're done so hopefully you

00:29:58,850 --> 00:30:02,510
could see what was happening there that

00:30:00,440 --> 00:30:04,549
we were basically hitting each of those

00:30:02,510 --> 00:30:06,289
partitions and working through and

00:30:04,549 --> 00:30:10,610
solving the problem on a smaller and

00:30:06,289 --> 00:30:12,740
smaller set of data each time okay the

00:30:10,610 --> 00:30:16,340
thing about quicksort then is that your

00:30:12,740 --> 00:30:19,190
best an average case is 0 n log n now

00:30:16,340 --> 00:30:20,450
the log the logarithmic function is

00:30:19,190 --> 00:30:22,909
something that you tend to see

00:30:20,450 --> 00:30:25,460
reoccurring in recursive oh that was an

00:30:22,909 --> 00:30:27,799
awkward sentence you tend to see again

00:30:25,460 --> 00:30:29,450
and again in recursive functions because

00:30:27,799 --> 00:30:31,309
a recursive function will work on this

00:30:29,450 --> 00:30:33,620
divide and conquer approach to the data

00:30:31,309 --> 00:30:35,899
which means that it is taking the data

00:30:33,620 --> 00:30:38,000
and then like I said running the same

00:30:35,899 --> 00:30:41,210
operation on smaller and smaller sets of

00:30:38,000 --> 00:30:43,399
it however the problem was quicksort is

00:30:41,210 --> 00:30:45,590
that the worst case is if you pass it a

00:30:43,399 --> 00:30:47,480
set of data that is already in order in

00:30:45,590 --> 00:30:51,890
which case it's going to take in squared

00:30:47,480 --> 00:30:55,610
time to sort through that data why you

00:30:51,890 --> 00:30:57,919
can tell me later okay quicksort is also

00:30:55,610 --> 00:31:00,770
relevant because that is what PHP sort

00:30:57,919 --> 00:31:03,679
function uses behind the scenes so this

00:31:00,770 --> 00:31:06,649
is the the algorithm that is running I

00:31:03,679 --> 00:31:11,860
am not entirely sure if it's an in-place

00:31:06,649 --> 00:31:14,600
algorithm if you track down Derek or

00:31:11,860 --> 00:31:17,870
Andre they can probably tell you at some

00:31:14,600 --> 00:31:19,340
point okay the other thing about this

00:31:17,870 --> 00:31:20,779
divide and conquer approach and the

00:31:19,340 --> 00:31:23,029
recursive approach to solving these

00:31:20,779 --> 00:31:25,700
algorithms is it means that you can

00:31:23,029 --> 00:31:27,740
start to split up the problem across

00:31:25,700 --> 00:31:30,200
either multiple processors multiple

00:31:27,740 --> 00:31:34,909
cores it starts become easy to parallels

00:31:30,200 --> 00:31:37,100
parallel lies the problem for another

00:31:34,909 --> 00:31:39,260
actually yeah I got asked this question

00:31:37,100 --> 00:31:41,779
let's see just how awake any of you guys

00:31:39,260 --> 00:31:48,700
are can anyone define the difference

00:31:41,779 --> 00:31:48,700
between concurrency and parallelism yes

00:31:49,630 --> 00:31:55,490
the same time so multiple streams so

00:31:52,760 --> 00:31:57,860
that two rivers side by side whereas

00:31:55,490 --> 00:32:00,860
concurrency is how many tasks you would

00:31:57,860 --> 00:32:04,190
like to pick up but will be executed

00:32:00,860 --> 00:32:08,870
sequentially so a bunch of barrels into

00:32:04,190 --> 00:32:11,210
a single rivet cool yeah yeah good there

00:32:08,870 --> 00:32:12,620
was a there was a very cool presentation

00:32:11,210 --> 00:32:15,010
that I saw where someone was doing this

00:32:12,620 --> 00:32:17,360
where they they slowly built it up with

00:32:15,010 --> 00:32:19,220
they had a pile of books that they

00:32:17,360 --> 00:32:20,750
needed to burn and they had a gopher

00:32:19,220 --> 00:32:22,220
with a wheelbarrow who could take the

00:32:20,750 --> 00:32:24,170
books back and forth but and they

00:32:22,220 --> 00:32:25,580
steadily like broke the pile down or

00:32:24,170 --> 00:32:28,430
added more Gophers are added more

00:32:25,580 --> 00:32:30,230
wheelbarrows but something that's

00:32:28,430 --> 00:32:32,390
something that's interesting about this

00:32:30,230 --> 00:32:36,520
which is we might be diverging a bit

00:32:32,390 --> 00:32:39,170
here but we've got we've got time

00:32:36,520 --> 00:32:42,230
concurrency is the idea of breaking the

00:32:39,170 --> 00:32:44,840
problem up into discrete steps that can

00:32:42,230 --> 00:32:46,760
be taken so once you've made something

00:32:44,840 --> 00:32:48,680
concurrent then it can be a lot easier

00:32:46,760 --> 00:32:50,330
to make it parallel as well because

00:32:48,680 --> 00:32:55,100
you've broken it up into those discrete

00:32:50,330 --> 00:33:00,290
steps okay now we get into the genuine

00:32:55,100 --> 00:33:03,950
voodoo level sorting I am not even into

00:33:00,290 --> 00:33:05,660
pretend to understand how this works but

00:33:03,950 --> 00:33:09,230
but it does have some practical

00:33:05,660 --> 00:33:14,480
applications okay firstly who knows what

00:33:09,230 --> 00:33:17,270
he is Wow okay we this is going to be

00:33:14,480 --> 00:33:20,150
tricky right who know who knows what a

00:33:17,270 --> 00:33:25,910
tree is in the computer science sense

00:33:20,150 --> 00:33:28,010
like good okay so a tree then a tree is

00:33:25,910 --> 00:33:30,140
something that can have a node and then

00:33:28,010 --> 00:33:32,030
off of that node you have various

00:33:30,140 --> 00:33:34,730
branches going down to other nodes that

00:33:32,030 --> 00:33:37,850
can have branches below them now a

00:33:34,730 --> 00:33:40,430
binary tree then is a special type of

00:33:37,850 --> 00:33:42,950
tree where each node can only have zero

00:33:40,430 --> 00:33:45,050
one or two connections coming off of it

00:33:42,950 --> 00:33:48,080
so every branch goes down it is either

00:33:45,050 --> 00:33:49,790
just stopping or having one come off of

00:33:48,080 --> 00:33:53,390
it or breaking down to two more branches

00:33:49,790 --> 00:33:56,090
and so on now a heap is a special type

00:33:53,390 --> 00:33:59,690
of binary tree where you construct that

00:33:56,090 --> 00:34:00,570
tree by making sure that the the child

00:33:59,690 --> 00:34:04,320
knows

00:34:00,570 --> 00:34:07,470
of the parent are always lower of a

00:34:04,320 --> 00:34:10,349
lower value than the parent node now

00:34:07,470 --> 00:34:12,210
there are a couple operations that you

00:34:10,349 --> 00:34:15,270
can do on this so basically tree

00:34:12,210 --> 00:34:16,800
processing binary trees they're very

00:34:15,270 --> 00:34:18,540
common data structures so there's a

00:34:16,800 --> 00:34:21,329
whole bunch of standard algorithms that

00:34:18,540 --> 00:34:23,129
you can do to basically swat data into a

00:34:21,329 --> 00:34:24,899
tree structure and once it's in a tree

00:34:23,129 --> 00:34:26,369
structure you've got some very efficient

00:34:24,899 --> 00:34:29,220
ways of navigating around the tree

00:34:26,369 --> 00:34:30,270
structure and processing the data so

00:34:29,220 --> 00:34:32,609
what we're going to do with the heap

00:34:30,270 --> 00:34:35,040
sort then is we're going to take our

00:34:32,609 --> 00:34:37,950
array and we're going to build a heap

00:34:35,040 --> 00:34:40,740
out of that list of data once we built a

00:34:37,950 --> 00:34:42,419
heap out of that list of data and this

00:34:40,740 --> 00:34:45,659
is where conceptually it gets a little

00:34:42,419 --> 00:34:49,649
bit weird we take the top item of the

00:34:45,659 --> 00:34:52,050
heap which is somehow the highest and

00:34:49,649 --> 00:34:54,419
then we put that at the front and then

00:34:52,050 --> 00:34:56,940
we go and rehearse and do the heap sort

00:34:54,419 --> 00:34:58,530
again on the remainder of the array and

00:34:56,940 --> 00:35:04,260
we steadily just take the top element

00:34:58,530 --> 00:35:06,720
off and build our list from that so did

00:35:04,260 --> 00:35:08,490
that you guys didn't look like you were

00:35:06,720 --> 00:35:10,589
sort of like shaking your head at me

00:35:08,490 --> 00:35:15,380
like I'm a mad person going through this

00:35:10,589 --> 00:35:15,380
yes yeah so a question

00:35:24,820 --> 00:35:35,210
yep so for it to be a heat the parent

00:35:27,680 --> 00:35:37,820
element is higher than the children yeah

00:35:35,210 --> 00:35:40,670
so something clever goes on when we when

00:35:37,820 --> 00:35:43,130
we create to the heat out of the tree

00:35:40,670 --> 00:35:45,440
which which we'll see in here so what

00:35:43,130 --> 00:35:47,000
we're doing is where the the term that

00:35:45,440 --> 00:35:49,670
gets used here is that we're sifting

00:35:47,000 --> 00:35:51,950
down the so we basically sift the

00:35:49,670 --> 00:35:54,830
elements down into the correct place in

00:35:51,950 --> 00:35:58,100
to thee this when you talk about other

00:35:54,830 --> 00:36:00,620
types of trees this this is very similar

00:35:58,100 --> 00:36:02,570
to rebalancing the tree so if you've

00:36:00,620 --> 00:36:04,520
made your tree according to a bunch of

00:36:02,570 --> 00:36:06,230
rules and you've sort of found that

00:36:04,520 --> 00:36:08,030
let's say you've actually got like a

00:36:06,230 --> 00:36:10,310
whole load of elements over here but a

00:36:08,030 --> 00:36:11,810
really short element over here are

00:36:10,310 --> 00:36:14,270
really short serve branches over here

00:36:11,810 --> 00:36:16,070
then you you basically rebalance the

00:36:14,270 --> 00:36:17,540
tree which is rearrange it so that

00:36:16,070 --> 00:36:19,910
you're basically pulling the elements up

00:36:17,540 --> 00:36:21,880
into a more balanced structure so that's

00:36:19,910 --> 00:36:26,060
that's similar to what we're doing with

00:36:21,880 --> 00:36:29,840
algorithm in here so inside of here what

00:36:26,060 --> 00:36:32,270
we are doing is you can see that we've

00:36:29,840 --> 00:36:33,980
got two for loops but rather than being

00:36:32,270 --> 00:36:35,960
nested inside of each other like a lot

00:36:33,980 --> 00:36:38,300
of our other ones we're actually just

00:36:35,960 --> 00:36:39,680
running them sequentially so inside of

00:36:38,300 --> 00:36:41,570
here you can see that we're taking the

00:36:39,680 --> 00:36:45,590
elements and before we try and do

00:36:41,570 --> 00:36:46,730
anything we are just sifting down the

00:36:45,590 --> 00:36:50,000
elements so this is where we're building

00:36:46,730 --> 00:36:52,550
a heat out of the elements and then

00:36:50,000 --> 00:36:55,010
inside of here you can see that we are

00:36:52,550 --> 00:36:57,890
picking the first element off of there

00:36:55,010 --> 00:37:01,690
and then we're repeating the sift down

00:36:57,890 --> 00:37:08,450
on on the remaining stack of elements

00:37:01,690 --> 00:37:10,770
and this is how we make eat I just let

00:37:08,450 --> 00:37:14,230
you read that for a minute

00:37:10,770 --> 00:37:16,540
hmm yeah you know I'm not even going to

00:37:14,230 --> 00:37:18,160
pretend I I had one of those beautiful

00:37:16,540 --> 00:37:20,530
moments where at about three in the

00:37:18,160 --> 00:37:22,300
morning after you know coding this and

00:37:20,530 --> 00:37:23,950
running through a couple times I had

00:37:22,300 --> 00:37:25,450
that sort of glimmer of understanding

00:37:23,950 --> 00:37:27,579
like you know when a word is on the tip

00:37:25,450 --> 00:37:31,810
of your tongue and then I went to bed

00:37:27,579 --> 00:37:33,430
and it was gone this is ha ha ha but so

00:37:31,810 --> 00:37:35,140
essentially what we're doing in here and

00:37:33,430 --> 00:37:38,079
one of the reasons that this is tricky

00:37:35,140 --> 00:37:41,230
to understand as well is because we are

00:37:38,079 --> 00:37:43,240
doing an in-place algorithm so it's a

00:37:41,230 --> 00:37:45,250
lot easier to build a tree structure if

00:37:43,240 --> 00:37:46,930
you don't have to do it in place because

00:37:45,250 --> 00:37:48,579
you can sit you can put it into a

00:37:46,930 --> 00:37:51,609
separate data structure that as a

00:37:48,579 --> 00:37:53,619
developer as well as a human being makes

00:37:51,609 --> 00:37:55,869
a lot more sense to you whereas here

00:37:53,619 --> 00:37:59,349
we're having to do some wizardry to make

00:37:55,869 --> 00:38:00,970
sure that we keep everything in place ok

00:37:59,349 --> 00:38:02,349
so let's take a look at the kind of

00:38:00,970 --> 00:38:05,079
things that are going on inside of this

00:38:02,349 --> 00:38:06,579
one this is basically just where we're

00:38:05,079 --> 00:38:11,680
going to watch the pointers jumping

00:38:06,579 --> 00:38:13,839
around and and I like I said I'm kind of

00:38:11,680 --> 00:38:16,599
following what the code is doing but I'm

00:38:13,839 --> 00:38:19,690
still not entirely there so you can see

00:38:16,599 --> 00:38:21,640
that and we're picking out some elements

00:38:19,690 --> 00:38:24,040
and this first bit is where we are

00:38:21,640 --> 00:38:26,589
basically building the heat so the

00:38:24,040 --> 00:38:28,960
problem here is that you need to try and

00:38:26,589 --> 00:38:31,000
visualize what a binary tree would look

00:38:28,960 --> 00:38:33,369
like if we just represented it as a

00:38:31,000 --> 00:38:36,339
linear array so this is what we're

00:38:33,369 --> 00:38:38,770
steadily building up inside of here so

00:38:36,339 --> 00:38:41,619
the thing to kind of see is that at this

00:38:38,770 --> 00:38:43,630
stage we're not really swapping the

00:38:41,619 --> 00:38:45,880
array into something that represents a

00:38:43,630 --> 00:38:48,190
more ordered array we're just building

00:38:45,880 --> 00:38:50,530
the data structure that we need in order

00:38:48,190 --> 00:38:52,960
to start pulling elements out so that we

00:38:50,530 --> 00:38:56,020
can build our sorted array afterwards so

00:38:52,960 --> 00:38:57,760
we just carry on through the pointers

00:38:56,020 --> 00:38:59,859
are jumping to the various partitions

00:38:57,760 --> 00:39:01,569
that we're working on as we sit down the

00:38:59,859 --> 00:39:04,530
array and smaller and smaller chunks and

00:39:01,569 --> 00:39:04,530
then eventually

00:39:07,150 --> 00:39:13,390
sometimes I have no idea when these are

00:39:09,340 --> 00:39:15,220
going to end either but you can see now

00:39:13,390 --> 00:39:20,460
we're actually getting to the stage

00:39:15,220 --> 00:39:20,460
where we're sorting the array we end and

00:39:21,420 --> 00:39:32,410
that's pretty though isn't it final one

00:39:27,310 --> 00:39:39,430
that sorted now okay so the issue with

00:39:32,410 --> 00:39:40,930
heapsort five minutes Wow okay we'll go

00:39:39,430 --> 00:39:46,150
through search algorithms really quickly

00:39:40,930 --> 00:39:48,190
they're super simple okay so huh best

00:39:46,150 --> 00:39:49,510
average and worst case o log n that's

00:39:48,190 --> 00:39:50,950
what's good about this one you feel

00:39:49,510 --> 00:39:54,100
anything at it it takes the same amount

00:39:50,950 --> 00:39:56,470
of time the useful thing here is that

00:39:54,100 --> 00:39:58,900
this is implemented by the SPLM in heat

00:39:56,470 --> 00:40:01,300
class so if you thought that codes was

00:39:58,900 --> 00:40:03,970
difficult to understand then this is how

00:40:01,300 --> 00:40:06,670
you can do it using the SPL you just

00:40:03,970 --> 00:40:08,830
take your unsorted arrays insert it into

00:40:06,670 --> 00:40:11,680
your heap called taught on the heat

00:40:08,830 --> 00:40:13,480
which is to basically keep fi the array

00:40:11,680 --> 00:40:15,580
and then you can just loop through

00:40:13,480 --> 00:40:19,600
putting out the elements and those will

00:40:15,580 --> 00:40:22,240
be sorted okay searching algorithms the

00:40:19,600 --> 00:40:24,880
remaining fifty percent of this talk in

00:40:22,240 --> 00:40:27,430
the five minutes okay sequential search

00:40:24,880 --> 00:40:29,290
then this is the one that is absolutely

00:40:27,430 --> 00:40:32,200
trivial to understand because sequential

00:40:29,290 --> 00:40:35,320
search is simply like this we literally

00:40:32,200 --> 00:40:37,450
just loop through the array and if the

00:40:35,320 --> 00:40:42,970
target matches the index then we return

00:40:37,450 --> 00:40:44,440
the element ah cool Mostert I don't know

00:40:42,970 --> 00:40:45,940
what it is about this algorithm but like

00:40:44,440 --> 00:40:48,400
every time I would pop it up it would

00:40:45,940 --> 00:40:50,080
always say I'm searching for 14 and I

00:40:48,400 --> 00:40:54,010
just have a visualization that was just

00:40:50,080 --> 00:40:56,700
like oh there it is so as you can see we

00:40:54,010 --> 00:41:01,660
just go through comparing elements until

00:40:56,700 --> 00:41:03,130
we find the one that matches now the

00:41:01,660 --> 00:41:05,050
important thing about sequential search

00:41:03,130 --> 00:41:07,930
is even though I've used a sorted array

00:41:05,050 --> 00:41:09,970
here obviously I don't need to because

00:41:07,930 --> 00:41:11,770
I'm not doing anything with the profit

00:41:09,970 --> 00:41:13,270
with the fact that my list is sorted I'm

00:41:11,770 --> 00:41:15,580
literally just going through until I

00:41:13,270 --> 00:41:17,980
find the array so what this means is

00:41:15,580 --> 00:41:19,050
that the best case is 0 1 because it's

00:41:17,980 --> 00:41:21,540
the first element in the

00:41:19,050 --> 00:41:23,100
ray the average and worst case is 0 n

00:41:21,540 --> 00:41:27,630
because we just have to loop through the

00:41:23,100 --> 00:41:30,090
elements until we find it but despite it

00:41:27,630 --> 00:41:32,340
being that trivial it's not actually

00:41:30,090 --> 00:41:35,190
completely pointless we will find out

00:41:32,340 --> 00:41:38,010
why in a minute so binary search then

00:41:35,190 --> 00:41:40,200
and this is the one where again feel

00:41:38,010 --> 00:41:42,420
free to ask me oh why didn't you look at

00:41:40,200 --> 00:41:46,140
uniform binary search and i will say

00:41:42,420 --> 00:41:48,720
than me a pull request binary search

00:41:46,140 --> 00:41:50,580
then does rely on us having a sorted

00:41:48,720 --> 00:41:52,710
array because binary search works in the

00:41:50,580 --> 00:41:53,970
same way that you would do the the

00:41:52,710 --> 00:41:55,740
number guessing game when you were a

00:41:53,970 --> 00:41:58,260
child when you have to guess a number

00:41:55,740 --> 00:42:00,390
between 1 and 100 and you just steadily

00:41:58,260 --> 00:42:02,910
break it down going ok is it higher low

00:42:00,390 --> 00:42:04,440
in the 50 no it's a higher than 25 now

00:42:02,910 --> 00:42:07,980
and just steadily breaking it down like

00:42:04,440 --> 00:42:11,490
that so inside of here you can see that

00:42:07,980 --> 00:42:13,890
again it's a binary search so it's

00:42:11,490 --> 00:42:17,910
recursive so inside of here we do the

00:42:13,890 --> 00:42:19,680
binary search if we have basically if

00:42:17,910 --> 00:42:21,180
our indexes have crossed over than we

00:42:19,680 --> 00:42:23,250
know that we haven't found it in that

00:42:21,180 --> 00:42:25,620
partition so we can just return false

00:42:23,250 --> 00:42:28,500
otherwise we're going to pick an index

00:42:25,620 --> 00:42:30,180
in the middle of at a partition and

00:42:28,500 --> 00:42:31,860
we're going to do a binary search in one

00:42:30,180 --> 00:42:34,950
partition and do a binary search in the

00:42:31,860 --> 00:42:38,310
other partition so what does this look

00:42:34,950 --> 00:42:42,540
like in this one we're looking for 101

00:42:38,310 --> 00:42:44,010
so we start out in the middle we haven't

00:42:42,540 --> 00:42:46,380
found it there so we know we need to

00:42:44,010 --> 00:42:48,440
request because it's lower than 148 so

00:42:46,380 --> 00:42:50,520
we were cursed down into that partition

00:42:48,440 --> 00:42:52,200
we haven't found it there it's higher

00:42:50,520 --> 00:42:54,690
because we've requests into the upper

00:42:52,200 --> 00:42:59,580
partition and then we cut down again and

00:42:54,690 --> 00:43:02,490
we find it there so with binary search

00:42:59,580 --> 00:43:04,530
the best case again like with all search

00:43:02,490 --> 00:43:07,020
algorithms is 0 1 because if it happens

00:43:04,530 --> 00:43:08,790
to be the first element then that's it

00:43:07,020 --> 00:43:10,440
unless you want to do some pointless

00:43:08,790 --> 00:43:13,710
fiddling around to pad the algorithm out

00:43:10,440 --> 00:43:16,730
a bit the average and worst case is o

00:43:13,710 --> 00:43:18,420
log n again because much like with our

00:43:16,730 --> 00:43:19,980
divide-and-conquer approach to the

00:43:18,420 --> 00:43:21,540
sorting algorithms we're doing the same

00:43:19,980 --> 00:43:23,400
thing with search we're basically

00:43:21,540 --> 00:43:27,360
narrowing down our problem space to a

00:43:23,400 --> 00:43:30,750
smaller area now the reason that linear

00:43:27,360 --> 00:43:31,559
search is still valid is because based

00:43:30,750 --> 00:43:34,439
on

00:43:31,559 --> 00:43:36,569
like either the CPU architecture or how

00:43:34,439 --> 00:43:40,170
your data is likely to be stored in RAM

00:43:36,569 --> 00:43:42,390
then what is often most efficient is to

00:43:40,170 --> 00:43:44,279
do a binary search down to a certain

00:43:42,390 --> 00:43:46,140
partition size and then once you know

00:43:44,279 --> 00:43:47,819
you're close enough you run a sequential

00:43:46,140 --> 00:43:49,949
search through that partition size

00:43:47,819 --> 00:43:51,569
because it's cheaper than hopping to

00:43:49,949 --> 00:43:56,189
another memory address and doing another

00:43:51,569 --> 00:43:59,279
binary search okay to sum up then so

00:43:56,189 --> 00:44:03,569
that we can get on to some questions the

00:43:59,279 --> 00:44:05,069
history then this stuff is all kind of

00:44:03,569 --> 00:44:07,949
things that were invented quite a while

00:44:05,069 --> 00:44:10,380
ago but are continually continually

00:44:07,949 --> 00:44:12,660
being optimized as time goes on so

00:44:10,380 --> 00:44:17,130
insertion sort there was that got turned

00:44:12,660 --> 00:44:19,339
into shellsort in 1959 bubble sort I was

00:44:17,130 --> 00:44:22,349
improved to two-tone saw in the 80s

00:44:19,339 --> 00:44:25,380
quicksort is back from 1960 and we're

00:44:22,349 --> 00:44:27,569
still using that heapsort again in the

00:44:25,380 --> 00:44:29,670
60s it's like all of the really weird

00:44:27,569 --> 00:44:33,719
search algorithms came out of the 60s

00:44:29,670 --> 00:44:35,759
I'm fairly sure why and then one that

00:44:33,719 --> 00:44:38,189
clearly we didn't have time to go into

00:44:35,759 --> 00:44:40,559
but I really like is there's radix sort

00:44:38,189 --> 00:44:42,059
so herman hollerith this is a sorting

00:44:40,559 --> 00:44:45,179
algorithm that was used on the punch

00:44:42,059 --> 00:44:46,799
card machines back in 8087 that has some

00:44:45,179 --> 00:44:50,369
interesting properties property because

00:44:46,799 --> 00:44:52,469
it can do an o n soort on random data

00:44:50,369 --> 00:44:58,380
provided that it falls into a certain

00:44:52,469 --> 00:45:00,179
type of data set so we are done with the

00:44:58,380 --> 00:45:02,670
the cody bit so thank you guys for

00:45:00,179 --> 00:45:04,019
keeping me awake through this there's

00:45:02,670 --> 00:45:06,809
the joined in link there if you want to

00:45:04,019 --> 00:45:10,199
give me feedback there's the code on

00:45:06,809 --> 00:45:11,729
github there and oh yes the the link to

00:45:10,199 --> 00:45:14,069
the other talk is that this is all

00:45:11,729 --> 00:45:16,349
actually running on the Google of PHP

00:45:14,069 --> 00:45:18,749
App Engine so you can just you can hit

00:45:16,349 --> 00:45:21,839
that link and you can go and try it out

00:45:18,749 --> 00:45:23,640
and I've included some links here if you

00:45:21,839 --> 00:45:27,029
want to try some of the other sorting

00:45:23,640 --> 00:45:29,910
algorithms bonus points if you have any

00:45:27,029 --> 00:45:32,939
idea how merge sort is working because I

00:45:29,910 --> 00:45:36,990
is even more complex than heap sort and

00:45:32,939 --> 00:45:45,390
quicksort questions

00:45:36,990 --> 00:45:46,920
thank you um I just wondered if you

00:45:45,390 --> 00:45:50,540
could give us an example of when you

00:45:46,920 --> 00:45:53,670
might want to use a heap sort instead of

00:45:50,540 --> 00:45:56,940
CERN in insertion sort or one of the

00:45:53,670 --> 00:45:59,310
others hmm let's take a look at some of

00:45:56,940 --> 00:46:09,030
the properties of heapsort see if I can

00:45:59,310 --> 00:46:11,970
improvise an answer very quickly ah yeah

00:46:09,030 --> 00:46:13,770
there we go okay so with heapsort you

00:46:11,970 --> 00:46:16,170
can see that the cases are the same for

00:46:13,770 --> 00:46:18,030
exactly every set of data though you

00:46:16,170 --> 00:46:19,560
would be using so quick sort if you've

00:46:18,030 --> 00:46:22,200
already got ordered data is going to

00:46:19,560 --> 00:46:24,420
perform exceptionally badly so if you

00:46:22,200 --> 00:46:26,700
don't know anything about your data then

00:46:24,420 --> 00:46:28,650
heapsort might be a better choice if you

00:46:26,700 --> 00:46:31,470
know if you know that your data is

00:46:28,650 --> 00:46:34,200
definitely mostly ordered then keep sort

00:46:31,470 --> 00:46:41,720
or or even like an insertion sort might

00:46:34,200 --> 00:46:44,640
may well be more effective anyone else

00:46:41,720 --> 00:46:46,740
are there any other exotic search and

00:46:44,640 --> 00:46:48,660
order technologies hiding in the SPL

00:46:46,740 --> 00:46:51,600
used to me that that one was in there

00:46:48,660 --> 00:46:52,980
I'm not entirely sure in the SPL I would

00:46:51,600 --> 00:46:54,810
imagine one of the billionaire so

00:46:52,980 --> 00:46:57,600
iterator classes probably does something

00:46:54,810 --> 00:47:01,770
interesting Joshua can probably tell you

00:46:57,600 --> 00:47:03,570
more about that some other cool stuff so

00:47:01,770 --> 00:47:06,240
there's there's also a sorting algorithm

00:47:03,570 --> 00:47:09,740
that I think is referred to as BOGO sort

00:47:06,240 --> 00:47:12,030
and the visualization for that is

00:47:09,740 --> 00:47:14,400
imagine that you have a deck of cards

00:47:12,030 --> 00:47:16,740
that has been shuffled and you want to

00:47:14,400 --> 00:47:18,690
swap the deck of cards into order so the

00:47:16,740 --> 00:47:20,760
the boguslaw algorithm is basically that

00:47:18,690 --> 00:47:23,100
you take that deck of cards and you

00:47:20,760 --> 00:47:25,260
throw it up in the air and then you pick

00:47:23,100 --> 00:47:29,510
all the cards up and you look at them

00:47:25,260 --> 00:47:29,510
and if they're in order then you're done

00:47:30,540 --> 00:47:35,250
if they're not used throw them up in the

00:47:32,850 --> 00:47:38,580
air again so I that that's that's

00:47:35,250 --> 00:47:40,410
actually 0 infinity in its worst case

00:47:38,580 --> 00:47:44,760
like beyond the heat death of the

00:47:40,410 --> 00:47:46,410
universe going over some of the cool

00:47:44,760 --> 00:47:48,270
stuff they didn't talk about or that I

00:47:46,410 --> 00:47:52,950
briefly mentioned on quicksort so

00:47:48,270 --> 00:47:54,780
quicksort is as recently as 2003 someone

00:47:52,950 --> 00:47:58,110
brought out a paper where they were

00:47:54,780 --> 00:48:01,290
looking at using three pivot points to

00:47:58,110 --> 00:48:03,750
pivot up the table and the thing is

00:48:01,290 --> 00:48:06,720
you're talking about you're not talking

00:48:03,750 --> 00:48:08,460
about jumping to another level of 0 n

00:48:06,720 --> 00:48:10,950
optimization these you're getting into

00:48:08,460 --> 00:48:13,020
micro optimization territory but there's

00:48:10,950 --> 00:48:15,450
still kind of there's still interesting

00:48:13,020 --> 00:48:20,670
stuff happening on on those really basic

00:48:15,450 --> 00:48:23,940
algorithms merge sort is especially good

00:48:20,670 --> 00:48:26,610
if you want to talk about how you would

00:48:23,940 --> 00:48:28,620
do that those kind of sorts for example

00:48:26,610 --> 00:48:30,420
if you're a company that has like a huge

00:48:28,620 --> 00:48:32,550
amount of data that you need to sort an

00:48:30,420 --> 00:48:33,870
index in some way and you need to split

00:48:32,550 --> 00:48:36,570
that out over a whole bunch of different

00:48:33,870 --> 00:48:44,630
machines then then merge so it starts to

00:48:36,570 --> 00:48:44,630
become really useful for that yeah

00:48:46,550 --> 00:48:50,050
I was just gonna say who I didn't think

00:48:48,590 --> 00:48:54,890
anyone else was going to say anything

00:48:50,050 --> 00:48:56,840
the Gophers it's Rob Pike yes yes

00:48:54,890 --> 00:48:58,490
recommend anyone that wants to look at

00:48:56,840 --> 00:49:01,190
concurrency and parallelism just search

00:48:58,490 --> 00:49:04,430
for Rob Pike Gophers yeah yeah that's

00:49:01,190 --> 00:49:05,690
it's an amazing talk much better than

00:49:04,430 --> 00:49:06,800
this one I should have put the link up

00:49:05,690 --> 00:49:08,840
at the start and you could have just

00:49:06,800 --> 00:49:11,450
like if you're getting bored just swap

00:49:08,840 --> 00:49:13,130
the ears and go through that just a

00:49:11,450 --> 00:49:15,740
funny remark about the bogus source it's

00:49:13,130 --> 00:49:17,240
not that pointless as it looks like it's

00:49:15,740 --> 00:49:18,950
came up at the comfort of quantum

00:49:17,240 --> 00:49:22,070
computing when you are thinking about

00:49:18,950 --> 00:49:24,230
proving upper deck having do all of the

00:49:22,070 --> 00:49:27,650
different variations and you pick up the

00:49:24,230 --> 00:49:29,810
valid one hmm to be honest I just

00:49:27,650 --> 00:49:31,580
thought the the snarky quote from youth

00:49:29,810 --> 00:49:33,200
was amusing so I brought that in

00:49:31,580 --> 00:49:34,790
although admit yeah I would be

00:49:33,200 --> 00:49:37,490
interested to know what you've seen

00:49:34,790 --> 00:49:43,490
bubble sort like being used in the wild

00:49:37,490 --> 00:49:46,010
for real but I haven't seen into used in

00:49:43,490 --> 00:49:49,850
novi the practical reasons mostly

00:49:46,010 --> 00:49:51,770
education mmm yeah no it does seem to it

00:49:49,850 --> 00:49:54,440
still exists in this bubble where it's

00:49:51,770 --> 00:49:59,780
an educational algorithm but then never

00:49:54,440 --> 00:50:03,190
actually gets used anywhere else cool in

00:49:59,780 --> 00:50:03,190
which case thanks so much

00:50:10,339 --> 00:50:13,339

YouTube URL: https://www.youtube.com/watch?v=J-DJPfjmF2I


