Title: PHP UK Conference 2014 - Joshua Thijssen - (Re)Discovering The SPL
Publication date: 2014-03-21
Playlist: PHP UK Conference 2014
Description: 
	The Standard PHP Library (SPL) might be one of the most powerful, yet the most unused part of PHP, but you are one of those lucky developers who have discovered it! But now what? The lack of documentation about SPL makes it that a lot users don't really harvest the power that SPL brings. During this presentation I will dive into the numerous iterators, data-structures and interfaces that SPL defines and when & how to implement them in your own projects, but we will talk about the edge-cases as well, as in SPL land things don't always are what they seem..
Captions: 
	00:00:05,180 --> 00:00:12,030
all right welcome rediscovering the SPL

00:00:09,290 --> 00:00:14,130
you see that rediscovering is in

00:00:12,030 --> 00:00:16,500
parentheses that's actually two reasons

00:00:14,130 --> 00:00:20,100
for that first of all is a bit selfish

00:00:16,500 --> 00:00:22,949
because it means that on the conference

00:00:20,100 --> 00:00:26,760
websites my talk is normally sorted at

00:00:22,949 --> 00:00:28,920
the top of the list and the second

00:00:26,760 --> 00:00:33,120
reason is that most of you probably

00:00:28,920 --> 00:00:35,760
heard of the SPL worked with the SPL but

00:00:33,120 --> 00:00:38,809
pretty much abandoned the SPL so today

00:00:35,760 --> 00:00:43,050
it's about rediscovering the SPL again

00:00:38,809 --> 00:00:46,829
so I had a small introduction so my name

00:00:43,050 --> 00:00:49,980
is just red Tyson and I do stuff mostly

00:00:46,829 --> 00:00:55,170
with PHP not really important but if you

00:00:49,980 --> 00:00:57,300
have some questions comments on me or

00:00:55,170 --> 00:01:00,510
the talk then you have some information

00:00:57,300 --> 00:01:03,860
here to contact me so first of all how

00:01:00,510 --> 00:01:08,010
many of you have actually used the SPL

00:01:03,860 --> 00:01:10,049
okay a little bit refreshment how many

00:01:08,010 --> 00:01:16,259
of you have ever used SPL and didn't

00:01:10,049 --> 00:01:19,020
went nuts that's a whole lot less yeah

00:01:16,259 --> 00:01:21,150
and this is the main problem of the SPL

00:01:19,020 --> 00:01:22,500
because when you want to do something

00:01:21,150 --> 00:01:24,659
with the SPL the first thing you're

00:01:22,500 --> 00:01:27,479
going to do is check SPL documentation

00:01:24,659 --> 00:01:31,640
and where can we find SPL documentation

00:01:27,479 --> 00:01:31,640
and don't say Stack Overflow

00:01:32,030 --> 00:01:35,850
that was the first time on the last

00:01:34,170 --> 00:01:41,130
conference take overflow

00:01:35,850 --> 00:01:44,010
now obviously peace p.net right so when

00:01:41,130 --> 00:01:44,970
you go to php.net slash SPL you get

00:01:44,010 --> 00:01:48,270
something like this

00:01:44,970 --> 00:01:51,000
what's the SPL it's just a one-liner

00:01:48,270 --> 00:01:55,680
it's one command post of the year ago

00:01:51,000 --> 00:01:57,870
and that's it you can't do anything with

00:01:55,680 --> 00:02:00,300
that I'm sorry I really want to use SPL

00:01:57,870 --> 00:02:03,240
but with documentation like this it's

00:02:00,300 --> 00:02:05,250
completely useless so one of the main

00:02:03,240 --> 00:02:07,530
problems is there is not enough

00:02:05,250 --> 00:02:07,920
documentation so even if you want to use

00:02:07,530 --> 00:02:11,160
it

00:02:07,920 --> 00:02:14,220
we really can't we don't know how there

00:02:11,160 --> 00:02:16,290
are very few examples and even examples

00:02:14,220 --> 00:02:19,440
that are there some of them are even

00:02:16,290 --> 00:02:24,570
wrong or missing like really good

00:02:19,440 --> 00:02:27,300
content so it's not helping now normally

00:02:24,570 --> 00:02:30,420
when you have an SPL talk you have like

00:02:27,300 --> 00:02:32,100
these five chapters and I go over them

00:02:30,420 --> 00:02:34,800
and explain you a little bit on how it

00:02:32,100 --> 00:02:38,520
worked I want to do a little bit

00:02:34,800 --> 00:02:41,459
different today because today I want to

00:02:38,520 --> 00:02:44,580
do a little bit of SPL and PHP in

00:02:41,459 --> 00:02:46,560
general bashing now obviously for me

00:02:44,580 --> 00:02:49,260
that's really awesome because I can do

00:02:46,560 --> 00:02:53,730
one hour of bashing PHP in SPL without

00:02:49,260 --> 00:02:57,020
any repercussions but I want to let you

00:02:53,730 --> 00:02:59,940
know on the things that actually is

00:02:57,020 --> 00:03:03,630
being done in the SPL that makes your

00:02:59,940 --> 00:03:05,310
life well miserable you know the things

00:03:03,630 --> 00:03:06,989
that you don't take for granted things

00:03:05,310 --> 00:03:09,330
that are wrong things that are incorrect

00:03:06,989 --> 00:03:11,610
things that doesn't really fit in the

00:03:09,330 --> 00:03:14,209
naming that they are and so I want to

00:03:11,610 --> 00:03:17,489
talk about that most of the things I

00:03:14,209 --> 00:03:20,820
don't want to scare you all away from

00:03:17,489 --> 00:03:22,650
SPL because honestly the SPL is really

00:03:20,820 --> 00:03:25,500
really awesome and if you know how it

00:03:22,650 --> 00:03:30,180
works there's a lot of potential that

00:03:25,500 --> 00:03:33,360
you can gain from the SPL so hopefully I

00:03:30,180 --> 00:03:35,880
have more people using SPL than scaring

00:03:33,360 --> 00:03:39,540
away today so if that's that's actually

00:03:35,880 --> 00:03:42,990
my my thing for today so let's start

00:03:39,540 --> 00:03:44,760
simple with the interfaces one of the

00:03:42,990 --> 00:03:47,400
first interfaces that

00:03:44,760 --> 00:03:49,890
we'll learn when you're dealing with SPL

00:03:47,400 --> 00:03:53,730
is called traversable however that's not

00:03:49,890 --> 00:03:56,189
an SPL interface in a way that it's not

00:03:53,730 --> 00:03:59,340
defined if you go to SPL and check the

00:03:56,189 --> 00:04:01,739
interfaces it's not there because they

00:03:59,340 --> 00:04:04,110
decided okay this is not really SPL

00:04:01,739 --> 00:04:06,540
related so we move it to like the core

00:04:04,110 --> 00:04:10,409
interfaces but still it's a big part of

00:04:06,540 --> 00:04:13,140
what we do with SPL okay how many of you

00:04:10,409 --> 00:04:16,560
have ever used the traversable who know

00:04:13,140 --> 00:04:18,570
of the traversable interface a few

00:04:16,560 --> 00:04:19,889
people okay that's good how many of you

00:04:18,570 --> 00:04:25,350
have actually implemented the

00:04:19,889 --> 00:04:26,820
traversable interface you succeeded okay

00:04:25,350 --> 00:04:29,699
because the traversable cannot be

00:04:26,820 --> 00:04:33,630
implemented oh yeah there's a lot of

00:04:29,699 --> 00:04:36,449
trick questions around today I know it

00:04:33,630 --> 00:04:38,039
will well a hundred percent correct you

00:04:36,449 --> 00:04:40,590
can implement it but as soon as you're

00:04:38,039 --> 00:04:42,510
gonna use that interface then PHP will

00:04:40,590 --> 00:04:43,680
throw an exception that you cannot use

00:04:42,510 --> 00:04:47,010
it then you have to use either an

00:04:43,680 --> 00:04:48,630
iterator or an iterator aggregate so

00:04:47,010 --> 00:04:50,789
what's the use it's reversible it's not

00:04:48,630 --> 00:04:53,070
really usable if it's not being

00:04:50,789 --> 00:04:55,740
implemented but traversable can be

00:04:53,070 --> 00:04:59,610
detected so you can use instance off to

00:04:55,740 --> 00:05:01,919
detect if something is reversible what

00:04:59,610 --> 00:05:04,410
happens is that if something is

00:05:01,919 --> 00:05:07,680
reversible you put that inside for each

00:05:04,410 --> 00:05:10,919
then for each can see okay this is a

00:05:07,680 --> 00:05:13,889
traversable object and instead of doing

00:05:10,919 --> 00:05:16,340
normally iterating over the properties

00:05:13,889 --> 00:05:19,460
of that object it will behave on

00:05:16,340 --> 00:05:23,370
whatever that reversible interface

00:05:19,460 --> 00:05:25,889
defined now traversable is something

00:05:23,370 --> 00:05:27,630
that is used inside PHP core so if your

00:05:25,889 --> 00:05:31,199
core developer and doing see a

00:05:27,630 --> 00:05:33,539
traversable make sense but from us it

00:05:31,199 --> 00:05:35,280
doesn't really make any sense because we

00:05:33,539 --> 00:05:38,460
cannot really change the way how to

00:05:35,280 --> 00:05:41,639
reverse a ball is used so this is where

00:05:38,460 --> 00:05:45,000
iterator comes in again iterator is

00:05:41,639 --> 00:05:49,289
still not an SPL interface but iterator

00:05:45,000 --> 00:05:52,320
is a way of us to have a sort of control

00:05:49,289 --> 00:05:56,930
over traversable the way how it reverse

00:05:52,320 --> 00:05:56,930
things in PHP userland

00:05:57,110 --> 00:06:02,910
the iterator interface defines five

00:06:00,599 --> 00:06:06,919
different methods you can use current

00:06:02,910 --> 00:06:10,050
key next rewind and valid and that

00:06:06,919 --> 00:06:12,810
pretty much shows you how to behave

00:06:10,050 --> 00:06:15,479
inside for each so you can use these

00:06:12,810 --> 00:06:19,379
five functions to change the behavior of

00:06:15,479 --> 00:06:21,750
an object when you use for each now most

00:06:19,379 --> 00:06:24,680
of you if you ever used iterators this

00:06:21,750 --> 00:06:27,810
is all pretty common knowledge hopefully

00:06:24,680 --> 00:06:29,550
when you have iterators there are a few

00:06:27,810 --> 00:06:32,250
different types and I will explain a

00:06:29,550 --> 00:06:33,900
little bit later on what that is but

00:06:32,250 --> 00:06:36,990
first of all we have the standard

00:06:33,900 --> 00:06:39,930
iterator which is something that uses

00:06:36,990 --> 00:06:41,819
one of those five that define those five

00:06:39,930 --> 00:06:44,370
methods but there's also something

00:06:41,819 --> 00:06:46,620
called a filter iterator which still is

00:06:44,370 --> 00:06:49,919
an iterator but actually accepts another

00:06:46,620 --> 00:06:51,180
iterator to filter out data and I will

00:06:49,919 --> 00:06:53,009
show you a little bit later on how that

00:06:51,180 --> 00:06:54,960
works but a lot of iterators we are

00:06:53,009 --> 00:06:57,990
using are actually filtering out data

00:06:54,960 --> 00:06:59,340
taken from other iterators there's

00:06:57,990 --> 00:07:03,139
another thing called an iterator

00:06:59,340 --> 00:07:08,520
aggregate anyone ever used that one

00:07:03,139 --> 00:07:12,719
nobody unbelievable sort of kinda all

00:07:08,520 --> 00:07:14,639
right iterator aggregate is pretty much

00:07:12,719 --> 00:07:17,610
an iterator so it extends the

00:07:14,639 --> 00:07:20,190
traversable interface as well however an

00:07:17,610 --> 00:07:23,729
iterator aggregate is not an iterator by

00:07:20,190 --> 00:07:26,460
itself it has an iterator but isn't an

00:07:23,729 --> 00:07:28,529
iterator so that's something you will

00:07:26,460 --> 00:07:30,240
see when you actually separate concerns

00:07:28,529 --> 00:07:33,360
when you have an object as a business

00:07:30,240 --> 00:07:35,610
object that can be a turrible but you

00:07:33,360 --> 00:07:37,020
don't want that inside that object when

00:07:35,610 --> 00:07:39,930
you have something like that normally

00:07:37,020 --> 00:07:43,110
you use an iterator aggregate if you are

00:07:39,930 --> 00:07:46,500
looking at the big frameworks Symphony

00:07:43,110 --> 00:07:48,690
to Zen framework to you will see that a

00:07:46,500 --> 00:07:51,389
lot of things in there are either an

00:07:48,690 --> 00:07:54,090
iterator or mostly an iterator aggregate

00:07:51,389 --> 00:07:56,699
so there's a really good place to look

00:07:54,090 --> 00:08:01,710
for on how iterators in general are

00:07:56,699 --> 00:08:04,289
actually working now let me say how or

00:08:01,710 --> 00:08:07,139
why you should use iterators because you

00:08:04,289 --> 00:08:09,779
know for each works perfectly suppose I

00:08:07,139 --> 00:08:10,449
have something like this just a little

00:08:09,779 --> 00:08:17,259
bit of code

00:08:10,449 --> 00:08:21,400
does anyone know what this is doing sort

00:08:17,259 --> 00:08:24,430
of it reads the current directory and it

00:08:21,400 --> 00:08:27,039
prints all the files out there right so

00:08:24,430 --> 00:08:28,839
this is like our business logic it's

00:08:27,039 --> 00:08:32,649
very simple it just prints out but could

00:08:28,839 --> 00:08:36,010
be really really complex obviously if

00:08:32,649 --> 00:08:37,839
you think about whatsapp it's sixteen

00:08:36,010 --> 00:08:39,969
billion dollars like these two lines

00:08:37,839 --> 00:08:43,269
it's at least as a few million dollars

00:08:39,969 --> 00:08:44,980
right so that's our business logic

00:08:43,269 --> 00:08:48,220
that's our application that's the thing

00:08:44,980 --> 00:08:50,620
we want to put out on in the public now

00:08:48,220 --> 00:08:52,660
you have this deployed and this is all

00:08:50,620 --> 00:08:55,269
running smoothly and now somebody comes

00:08:52,660 --> 00:08:58,060
over to you and says you know this is

00:08:55,269 --> 00:09:01,630
nice but we only want to display and be

00:08:58,060 --> 00:09:04,449
three files so you do something like

00:09:01,630 --> 00:09:06,550
this probably and everybody is like oh

00:09:04,449 --> 00:09:11,139
no I never had never have done that in

00:09:06,550 --> 00:09:13,480
my life yes you have trust me so what

00:09:11,139 --> 00:09:15,910
you do is inside the while loop you

00:09:13,480 --> 00:09:18,910
actually say okay you know what I check

00:09:15,910 --> 00:09:21,639
if the the file that's there if that

00:09:18,910 --> 00:09:24,310
ends on dot mp3 with a regular

00:09:21,639 --> 00:09:25,750
expression and if it doesn't I'll just

00:09:24,310 --> 00:09:29,319
continue with the next file and if it

00:09:25,750 --> 00:09:34,089
does I print that file job done quickly

00:09:29,319 --> 00:09:36,550
issue deploy more money it's perfect but

00:09:34,089 --> 00:09:36,910
this is not really a good way to do

00:09:36,550 --> 00:09:39,399
things

00:09:36,910 --> 00:09:42,190
obviously you hopefully you agree with

00:09:39,399 --> 00:09:46,300
me because what would happen if we would

00:09:42,190 --> 00:09:48,910
filter all mp3 and all JPEG files we

00:09:46,300 --> 00:09:51,160
have to change that code again what if

00:09:48,910 --> 00:09:54,069
we need to filter all mp3 files that are

00:09:51,160 --> 00:09:55,870
larger than six megabytes what if some

00:09:54,069 --> 00:09:57,610
other customer says no I don't want to

00:09:55,870 --> 00:09:59,829
filter something at all or what if we

00:09:57,610 --> 00:10:02,050
have to search subdirectories or what if

00:09:59,829 --> 00:10:05,139
we have multiple directories your whole

00:10:02,050 --> 00:10:08,470
code would be a complete mess and we

00:10:05,139 --> 00:10:11,540
like to call that legacy codes but

00:10:08,470 --> 00:10:14,720
it doesn't end well if you do stuff like

00:10:11,540 --> 00:10:18,350
this but the main problems with this is

00:10:14,720 --> 00:10:20,990
that we cannot test it that code is

00:10:18,350 --> 00:10:24,500
untestable that code is unmaintainable

00:10:20,990 --> 00:10:27,980
and that code isn't reusable so let's

00:10:24,500 --> 00:10:29,390
change it and let's use iterators so

00:10:27,980 --> 00:10:31,520
this is pretty much the same thing what

00:10:29,390 --> 00:10:33,680
we did before only with iterators and

00:10:31,520 --> 00:10:35,810
even if you have no idea what in

00:10:33,680 --> 00:10:38,870
directory iterator is you probably

00:10:35,810 --> 00:10:40,760
understand what this code says so I have

00:10:38,870 --> 00:10:43,310
a directory iterator with iterates over

00:10:40,760 --> 00:10:45,800
the current directory and then it shows

00:10:43,310 --> 00:10:50,510
all the parts of all the files that are

00:10:45,800 --> 00:10:52,700
there now again the same question I want

00:10:50,510 --> 00:10:55,550
to filter out of I want to filter

00:10:52,700 --> 00:10:57,140
everything that's an mp3 file so I do

00:10:55,550 --> 00:11:01,340
something like this so I have the

00:10:57,140 --> 00:11:05,390
directory iterator and I move that I

00:11:01,340 --> 00:11:07,010
change that to a reg X integrator again

00:11:05,390 --> 00:11:08,930
if you have no idea what already the

00:11:07,010 --> 00:11:11,240
brackets iterator is you still

00:11:08,930 --> 00:11:13,520
understand what this is doing so you get

00:11:11,240 --> 00:11:17,810
a directory iterator you put that inside

00:11:13,520 --> 00:11:20,120
that added the Reg x iterator and then

00:11:17,810 --> 00:11:23,500
I'm gonna use that so it filters out

00:11:20,120 --> 00:11:28,280
data so you can change those iterators

00:11:23,500 --> 00:11:31,040
together do you see what the difference

00:11:28,280 --> 00:11:35,480
is between doing this and doing the P

00:11:31,040 --> 00:11:38,360
rec match in the first example anyone

00:11:35,480 --> 00:11:43,760
has an idea except for using SPL

00:11:38,360 --> 00:11:47,210
obviously it's testable yeah what I'm

00:11:43,760 --> 00:11:49,880
actually looking for is that we change

00:11:47,210 --> 00:11:52,130
whatever we want to do with our business

00:11:49,880 --> 00:11:54,950
logic we move that outside of our loop

00:11:52,130 --> 00:11:57,080
so we have a simple loop that does stuff

00:11:54,950 --> 00:11:59,330
so like this is our business logic loop

00:11:57,080 --> 00:12:02,450
the for each loop and everything that

00:11:59,330 --> 00:12:05,930
needs to be fed into its moved outside

00:12:02,450 --> 00:12:07,640
because now we can do stuff like this so

00:12:05,930 --> 00:12:09,890
we have a directory iterator that

00:12:07,640 --> 00:12:12,440
filters out mp3s that filter out

00:12:09,890 --> 00:12:15,230
everything between 0 & 6 megabytes and

00:12:12,440 --> 00:12:17,600
there's a limit iterator and the limit

00:12:15,230 --> 00:12:20,730
iterator what should it do what do you

00:12:17,600 --> 00:12:24,970
think guess simple

00:12:20,730 --> 00:12:28,060
so offset limit will turn the tenth mp3

00:12:24,970 --> 00:12:30,999
that's six megabytes or less and it

00:12:28,060 --> 00:12:31,959
returns only five of them but everything

00:12:30,999 --> 00:12:37,170
is outside the loop

00:12:31,959 --> 00:12:41,350
there's no hex inside here not bad right

00:12:37,170 --> 00:12:43,540
hopefully there's anyone with me not

00:12:41,350 --> 00:12:47,740
agree that this is a better way than the

00:12:43,540 --> 00:12:49,139
first setup cause nobody dares to raise

00:12:47,740 --> 00:12:52,180
their hand right now

00:12:49,139 --> 00:12:54,399
now because now everything is reusable

00:12:52,180 --> 00:12:57,160
because we can use those iterators

00:12:54,399 --> 00:12:59,050
anywhere we want and every different

00:12:57,160 --> 00:13:01,420
order in every different form it's

00:12:59,050 --> 00:13:04,420
testable because now we can test every

00:13:01,420 --> 00:13:05,980
single separator by itself we don't care

00:13:04,420 --> 00:13:08,379
what comes next

00:13:05,980 --> 00:13:10,059
or what's before that we can test it

00:13:08,379 --> 00:13:11,980
easily and it's more maintainable

00:13:10,059 --> 00:13:14,410
because we don't need to adapt and

00:13:11,980 --> 00:13:16,389
change the business logic we just need

00:13:14,410 --> 00:13:20,019
to change whatever is being fed inside

00:13:16,389 --> 00:13:23,110
that business logic so this is pretty

00:13:20,019 --> 00:13:25,689
much the case on iterative why should

00:13:23,110 --> 00:13:27,069
you use iterators now let's continue

00:13:25,689 --> 00:13:29,500
with something else with another

00:13:27,069 --> 00:13:32,379
interface called countable and this is

00:13:29,500 --> 00:13:35,199
finally an SPL interface this is defined

00:13:32,379 --> 00:13:40,559
inside the SPL how many of you have used

00:13:35,199 --> 00:13:43,660
this few in the back few hands okay cool

00:13:40,559 --> 00:13:46,420
now countable I show you a little bit of

00:13:43,660 --> 00:13:49,240
an example on what it does so first of

00:13:46,420 --> 00:13:51,579
all I have a simple iterator and that

00:13:49,240 --> 00:13:54,220
iterator without actually putting the

00:13:51,579 --> 00:13:56,559
code here assume that it's an iterator

00:13:54,220 --> 00:13:59,589
that you put in an array and then then

00:13:56,559 --> 00:14:03,459
iterates over that array now in this

00:13:59,589 --> 00:14:11,699
case what would print count IT does what

00:14:03,459 --> 00:14:15,600
will return anything anybody I guess one

00:14:11,699 --> 00:14:15,600
okay one why

00:14:17,000 --> 00:14:23,090
because you only give it one iterator to

00:14:19,940 --> 00:14:26,840
count so currencies oh that's one object

00:14:23,090 --> 00:14:30,410
so I returned one it's pretty basic PHP

00:14:26,840 --> 00:14:30,800
knowledge however let's do something

00:14:30,410 --> 00:14:32,660
else

00:14:30,800 --> 00:14:34,400
I have a countable iterator which is

00:14:32,660 --> 00:14:35,990
pretty much the same thing but only

00:14:34,400 --> 00:14:38,000
implements accountable and if you

00:14:35,990 --> 00:14:41,330
implements countable you need to add

00:14:38,000 --> 00:14:44,510
account method and what it does as soon

00:14:41,330 --> 00:14:46,270
as you hit the PHP count function and it

00:14:44,510 --> 00:14:49,790
sees that that object actually

00:14:46,270 --> 00:14:51,850
implements countable it will not do its

00:14:49,790 --> 00:14:54,440
own PHP count but it will actually

00:14:51,850 --> 00:14:58,130
returns the result of the count method

00:14:54,440 --> 00:15:00,230
so it's like a magic hook into the count

00:14:58,130 --> 00:15:02,930
function which is really awesome because

00:15:00,230 --> 00:15:06,860
in this case I put in an array of five

00:15:02,930 --> 00:15:10,360
elements I give that to the iterator and

00:15:06,860 --> 00:15:14,780
when I print count I T what will I get

00:15:10,360 --> 00:15:16,790
five obviously right awesome this is a

00:15:14,780 --> 00:15:19,910
simple example but it could be more

00:15:16,790 --> 00:15:22,520
complex than this now same thing happens

00:15:19,910 --> 00:15:24,920
here as well so I have my same countable

00:15:22,520 --> 00:15:26,870
interface and now I'm gonna fill the

00:15:24,920 --> 00:15:29,240
stuff so I have the same array with one

00:15:26,870 --> 00:15:31,700
two five I put it in countable interface

00:15:29,240 --> 00:15:33,650
but now I'm gonna limit it again so the

00:15:31,700 --> 00:15:36,680
offset limit part and I want the first

00:15:33,650 --> 00:15:39,710
element and then three items so what

00:15:36,680 --> 00:15:46,910
will count I T to return what do you

00:15:39,710 --> 00:15:50,000
think one we thought three pretty much

00:15:46,910 --> 00:15:53,660
everybody hopefully now that the reason

00:15:50,000 --> 00:15:57,680
for this is that the limit iterator does

00:15:53,660 --> 00:16:00,800
not implement countable so it just sees

00:15:57,680 --> 00:16:04,610
oh this is an iterator it's one iterator

00:16:00,800 --> 00:16:06,230
okay just return one so even if you have

00:16:04,610 --> 00:16:08,540
implemented countable and you're hacking

00:16:06,230 --> 00:16:10,190
away and everything works nicely then

00:16:08,540 --> 00:16:12,560
all of a sudden you're gonna filter

00:16:10,190 --> 00:16:14,900
iterators and bam all of a sudden count

00:16:12,560 --> 00:16:18,980
doesn't work and you have no idea why

00:16:14,900 --> 00:16:22,100
and if you don't understand this and if

00:16:18,980 --> 00:16:24,740
you hit stuff like this after well

00:16:22,100 --> 00:16:27,200
sooner or later you will find it out but

00:16:24,740 --> 00:16:29,420
it's really annoying these are the

00:16:27,200 --> 00:16:30,590
things why people won't use the SPL

00:16:29,420 --> 00:16:32,870
because they're really getting

00:16:30,590 --> 00:16:34,610
up by stupid things like this because

00:16:32,870 --> 00:16:36,980
why wouldn't limit it rater

00:16:34,610 --> 00:16:41,990
implement countable why doesn't count

00:16:36,980 --> 00:16:44,870
work but it did before the speakable

00:16:41,990 --> 00:16:46,430
iterator many people think is an

00:16:44,870 --> 00:16:51,320
iterator but actually it's an interface

00:16:46,430 --> 00:16:55,760
why it's called seqable iterator SPL I

00:16:51,320 --> 00:16:57,620
blame the SPL the secret iterator again

00:16:55,760 --> 00:17:01,130
is an interface but it allows you to

00:16:57,620 --> 00:17:02,840
implement seek and seek is really nice

00:17:01,130 --> 00:17:04,640
because when you implement seek

00:17:02,840 --> 00:17:07,820
obliterator it can actually speed up

00:17:04,640 --> 00:17:09,500
other interfaces of other iterators so

00:17:07,820 --> 00:17:13,070
for instance the limit iterator makes

00:17:09,500 --> 00:17:15,740
use of the sake of literature so if you

00:17:13,070 --> 00:17:18,560
do the offset limiting again so you have

00:17:15,740 --> 00:17:20,570
like a limit iterator and you want to

00:17:18,560 --> 00:17:23,210
start for the thousandth element and

00:17:20,570 --> 00:17:25,670
only return the next 10 what normally

00:17:23,210 --> 00:17:28,370
will do is that the filter iterator will

00:17:25,670 --> 00:17:30,470
count from zero to thousand throw

00:17:28,370 --> 00:17:32,720
everything away and then return the next

00:17:30,470 --> 00:17:35,210
ten my obviously that's not really

00:17:32,720 --> 00:17:37,610
efficient so if you can have something

00:17:35,210 --> 00:17:39,560
called a sequel iterator then it will

00:17:37,610 --> 00:17:44,960
see hey the iterator I'm actually using

00:17:39,560 --> 00:17:47,660
is of instance C cable iterator I can

00:17:44,960 --> 00:17:50,570
actually use seek thousand and just like

00:17:47,660 --> 00:17:52,640
a database I don't have to go to one two

00:17:50,570 --> 00:17:55,220
thousand it will actually skip right to

00:17:52,640 --> 00:17:57,980
thousand and return the elements so even

00:17:55,220 --> 00:18:00,710
if you don't use don't use the sequel

00:17:57,980 --> 00:18:04,460
iterator others like the limit iterator

00:18:00,710 --> 00:18:06,980
can use so if you don't know that and

00:18:04,460 --> 00:18:09,710
you think things are really slow this

00:18:06,980 --> 00:18:12,830
might actually speed it up but trust me

00:18:09,710 --> 00:18:15,080
just from reading the documentation you

00:18:12,830 --> 00:18:16,850
probably won't recognize stuff like this

00:18:15,080 --> 00:18:19,460
but it's really it can be really

00:18:16,850 --> 00:18:22,400
important there are a lot of more

00:18:19,460 --> 00:18:25,370
interactive interfaces none of them are

00:18:22,400 --> 00:18:27,230
really that important right now I will

00:18:25,370 --> 00:18:32,120
come back to a few a little bit later on

00:18:27,230 --> 00:18:34,750
anyway so the iterators this is always

00:18:32,120 --> 00:18:40,460
nice there are a lot of iterators and

00:18:34,750 --> 00:18:42,680
since PHP 5.3 sorry 5.4 there are some

00:18:40,460 --> 00:18:44,090
really cool ones called the callback

00:18:42,680 --> 00:18:45,679
iterator called

00:18:44,090 --> 00:18:47,570
filter iterator and recursive call back

00:18:45,679 --> 00:18:50,750
fit iterator that allows you to add a

00:18:47,570 --> 00:18:52,880
call back so the need of creating your

00:18:50,750 --> 00:18:55,130
own custom iterators pretty much

00:18:52,880 --> 00:18:58,490
disappeared because you can use really

00:18:55,130 --> 00:19:01,039
cool cool box callbacks for that if you

00:18:58,490 --> 00:19:02,690
have no idea you wanna iterated us and

00:19:01,039 --> 00:19:05,150
there's a lot of them and you probably

00:19:02,690 --> 00:19:08,470
won't know even I don't know what all of

00:19:05,150 --> 00:19:11,929
them are doing you can look them up at

00:19:08,470 --> 00:19:14,779
this side alex r dot p speed up net

00:19:11,929 --> 00:19:17,120
anyone familiar with the site if you are

00:19:14,779 --> 00:19:19,789
doing like core development or stuff

00:19:17,120 --> 00:19:21,679
like that this is probably a sight

00:19:19,789 --> 00:19:23,720
familiar too because this shows you the

00:19:21,679 --> 00:19:28,370
source code of PHP the source code of

00:19:23,720 --> 00:19:30,169
PHP is on there but it's not all C code

00:19:28,370 --> 00:19:32,870
because what they did is when they

00:19:30,169 --> 00:19:35,659
created the SPL they pretty much modeled

00:19:32,870 --> 00:19:38,510
on how the iterators would work inside

00:19:35,659 --> 00:19:40,789
PHP so if you go to that directory and

00:19:38,510 --> 00:19:42,919
in this case the append iterator dot Inc

00:19:40,789 --> 00:19:45,950
you can actually see what the append

00:19:42,919 --> 00:19:48,230
iterator does in PHP code so it's much

00:19:45,950 --> 00:19:50,539
easier for you to figure out what's it

00:19:48,230 --> 00:19:54,679
doing why isn't working the way I think

00:19:50,539 --> 00:19:57,230
it should work realize that this is not

00:19:54,679 --> 00:20:00,260
really maintained so iterators involve

00:19:57,230 --> 00:20:02,090
so this might not be up to date but

00:20:00,260 --> 00:20:04,940
still it gives you a really good idea on

00:20:02,090 --> 00:20:07,039
what current iterators are doing not all

00:20:04,940 --> 00:20:08,750
of them are there but some of them are

00:20:07,039 --> 00:20:11,929
and it's really nice to take a look at

00:20:08,750 --> 00:20:15,559
that and it's just PHP code inside the

00:20:11,929 --> 00:20:18,320
PHP core now I showed you there are a

00:20:15,559 --> 00:20:19,880
lot of iterators and some of them really

00:20:18,320 --> 00:20:25,669
don't make sense if you're just starting

00:20:19,880 --> 00:20:27,590
with the SPL iterator iterator that's

00:20:25,669 --> 00:20:29,360
really recursive oh no there's a

00:20:27,590 --> 00:20:33,020
recursive iterator as well isn't that

00:20:29,360 --> 00:20:34,429
iterator iterator so would you have

00:20:33,020 --> 00:20:38,110
something like recursive iterator

00:20:34,429 --> 00:20:38,110
iterator answer yes

00:20:38,200 --> 00:20:42,020
by that by this time I'm already you

00:20:41,330 --> 00:20:46,370
know forget it

00:20:42,020 --> 00:20:50,390
I'm going to Python recursive call back

00:20:46,370 --> 00:20:53,690
filter iterator I'm sorry the I think

00:20:50,390 --> 00:20:56,600
they had like some kind of of game on

00:20:53,690 --> 00:20:59,450
who can event the longest class names or

00:20:56,600 --> 00:21:01,310
something but yeah if you start with

00:20:59,450 --> 00:21:03,590
this this doesn't really make sense it's

00:21:01,310 --> 00:21:03,920
really hard to explain what this stuff

00:21:03,590 --> 00:21:07,220
is

00:21:03,920 --> 00:21:09,350
however I will try a little bit even if

00:21:07,220 --> 00:21:11,930
you don't get it I completely understand

00:21:09,350 --> 00:21:15,290
because it's it's it can be pretty

00:21:11,930 --> 00:21:17,660
difficult so let's start with the

00:21:15,290 --> 00:21:20,390
iterator iterator I said before that for

00:21:17,660 --> 00:21:22,570
each works on traversable things and an

00:21:20,390 --> 00:21:24,800
iterator is a traversable thing and

00:21:22,570 --> 00:21:28,550
iterator aggregate is a traversable

00:21:24,800 --> 00:21:29,900
thing but inside the PHP as well there

00:21:28,550 --> 00:21:32,000
are a lot of other things that aren't

00:21:29,900 --> 00:21:32,870
really iterators but are traversable as

00:21:32,000 --> 00:21:35,600
well

00:21:32,870 --> 00:21:39,290
daytime has some classes that are

00:21:35,600 --> 00:21:43,370
traversable simple xml has one has a few

00:21:39,290 --> 00:21:45,440
and a lot of other objects inside PHP

00:21:43,370 --> 00:21:48,950
that are traversable but not really an

00:21:45,440 --> 00:21:51,860
iterator what iterator iterated us is it

00:21:48,950 --> 00:21:54,770
turns traversable things into an

00:21:51,860 --> 00:21:56,210
iterator and that doesn't really make

00:21:54,770 --> 00:21:57,980
sense for things that are only

00:21:56,210 --> 00:21:59,690
traversable but it can make sense for

00:21:57,980 --> 00:22:01,940
things that are iterator aggregate I

00:21:59,690 --> 00:22:02,870
said before iterator aggregate is not

00:22:01,940 --> 00:22:05,600
something that it's

00:22:02,870 --> 00:22:07,190
iterator Bowl by itself but it has

00:22:05,600 --> 00:22:10,220
something that can be iterator

00:22:07,190 --> 00:22:12,800
so what iterator aggregate does is it

00:22:10,220 --> 00:22:15,680
has a get iterative function so it will

00:22:12,800 --> 00:22:17,870
just fetch an iterator for you now

00:22:15,680 --> 00:22:20,990
before each loop will do that for you

00:22:17,870 --> 00:22:23,180
for each loop is smart enough to take

00:22:20,990 --> 00:22:26,120
care of that however if you want to

00:22:23,180 --> 00:22:28,580
filter stuff like a limit iterator the

00:22:26,120 --> 00:22:30,580
limit iterator has a type hinting as a

00:22:28,580 --> 00:22:33,560
type painting of iterator

00:22:30,580 --> 00:22:36,020
so you need to add an iterator they're

00:22:33,560 --> 00:22:38,660
not reversible not iterator aggregate it

00:22:36,020 --> 00:22:41,420
needs to be iterator and if you have no

00:22:38,660 --> 00:22:44,420
idea if my iterator here is actually an

00:22:41,420 --> 00:22:47,240
iterator or iterator aggregate you need

00:22:44,420 --> 00:22:49,730
to add code like this because now you

00:22:47,240 --> 00:22:50,370
have to figure out it's my iterator an

00:22:49,730 --> 00:22:53,420
iterator

00:22:50,370 --> 00:22:57,300
so yeah then I have to get the iterator

00:22:53,420 --> 00:22:59,059
complete mess I don't want to explain

00:22:57,300 --> 00:23:02,090
this to people because it makes no sense

00:22:59,059 --> 00:23:06,540
so what they did is something like this

00:23:02,090 --> 00:23:11,360
you have the iterator and then you move

00:23:06,540 --> 00:23:11,360
that iterator inside iterator iterator

00:23:12,530 --> 00:23:19,860
welcome to my world

00:23:14,570 --> 00:23:22,950
and now the it2 we know for a fact that

00:23:19,860 --> 00:23:24,630
it's something that is an iterator and

00:23:22,950 --> 00:23:27,240
now we can use that inside the limit

00:23:24,630 --> 00:23:29,100
iterator so sometimes you see out of the

00:23:27,240 --> 00:23:32,100
blue something something iterator

00:23:29,100 --> 00:23:34,050
iterator we have no idea why it's to

00:23:32,100 --> 00:23:38,400
make it an iterator to make sure that's

00:23:34,050 --> 00:23:40,650
an iterator does it make sense kinda if

00:23:38,400 --> 00:23:44,040
you are inside SPL but for a beginner

00:23:40,650 --> 00:23:48,900
who has no idea about SPL iterators yeah

00:23:44,040 --> 00:23:55,710
this stuff is really nasty the recursive

00:23:48,900 --> 00:23:59,220
whatever iterator example I have an

00:23:55,710 --> 00:24:04,050
array iterator I give it an air a full

00:23:59,220 --> 00:24:06,960
bar another array inside that's what put

00:24:04,050 --> 00:24:10,800
the output be obviously this is a

00:24:06,960 --> 00:24:15,390
straight question right so it's what do

00:24:10,800 --> 00:24:20,670
you think it will be the output fubar

00:24:15,390 --> 00:24:23,520
array bass yeah until PHP 5.4 you were

00:24:20,670 --> 00:24:26,130
correct on 5.4 it will actually throw

00:24:23,520 --> 00:24:28,260
another notice that you cannot change an

00:24:26,130 --> 00:24:30,570
area into string or something but yeah

00:24:28,260 --> 00:24:33,000
this is pretty much what's happening why

00:24:30,570 --> 00:24:35,100
is this happening because the iterator

00:24:33,000 --> 00:24:37,620
does only iterate elements so it

00:24:35,100 --> 00:24:39,660
iterates a string another string it sees

00:24:37,620 --> 00:24:41,790
an array and it sees a string it doesn't

00:24:39,660 --> 00:24:44,010
care that that array could also be

00:24:41,790 --> 00:24:47,040
iterable or whatever doesn't matter it's

00:24:44,010 --> 00:24:51,030
not this job so we need a recursive

00:24:47,040 --> 00:24:55,910
array iterator I guess and now the

00:24:51,030 --> 00:24:55,910
output would be yeah exactly the same

00:24:58,430 --> 00:25:06,900
so now I changed from Python to Ruby and

00:25:01,380 --> 00:25:10,170
try that the thing with a recursive

00:25:06,900 --> 00:25:13,830
iterate array iterator it does not make

00:25:10,170 --> 00:25:17,420
anything recursive it allows you to add

00:25:13,830 --> 00:25:19,980
the possibility to make things recursive

00:25:17,420 --> 00:25:24,030
should it be called recursive array

00:25:19,980 --> 00:25:26,510
iterator absolutely not but it happens

00:25:24,030 --> 00:25:32,720
and so this is what we have to live with

00:25:26,510 --> 00:25:32,720
what do we need to do we need to filter

00:25:32,900 --> 00:25:39,350
yeah through a recursive iterator

00:25:37,830 --> 00:25:41,700
iterator

00:25:39,350 --> 00:25:44,490
what does not recursive iterator

00:25:41,700 --> 00:25:46,950
iterator does it does pretty much the

00:25:44,490 --> 00:25:49,230
same thing as a normal iterator iterator

00:25:46,950 --> 00:25:52,380
so whatever it is it turns into an

00:25:49,230 --> 00:25:55,920
iterator fine I can live with that but

00:25:52,380 --> 00:25:58,350
the recursive part is actually the

00:25:55,920 --> 00:26:01,260
recursive iterator iterator has code to

00:25:58,350 --> 00:26:03,360
actually make it recursive the wall so

00:26:01,260 --> 00:26:05,850
it doesn't only add the possibility it

00:26:03,360 --> 00:26:07,920
actually implements that possibility you

00:26:05,850 --> 00:26:09,720
could implement it yourself so you don't

00:26:07,920 --> 00:26:11,670
need to use a recursive iterate iterator

00:26:09,720 --> 00:26:15,800
but please do because it makes more

00:26:11,670 --> 00:26:19,620
sense and now finally we get our

00:26:15,800 --> 00:26:21,810
multi-dimensional array yeah try to

00:26:19,620 --> 00:26:24,930
explain that to anyone who never heard

00:26:21,810 --> 00:26:27,420
of the SPL the recursive iterators add

00:26:24,930 --> 00:26:29,490
the possibility to recursively iterate

00:26:27,420 --> 00:26:31,890
over data you still need to implement it

00:26:29,490 --> 00:26:33,090
yourself or use recursive iterator

00:26:31,890 --> 00:26:36,810
iterator there are a few others that

00:26:33,090 --> 00:26:38,070
also do it but most of them doesn't so

00:26:36,810 --> 00:26:40,590
yeah it should have been called

00:26:38,070 --> 00:26:43,560
recursive a ball iterator at least that

00:26:40,590 --> 00:26:48,240
makes a little bit more sense but not

00:26:43,560 --> 00:26:50,190
really but still now the recursive Kobuk

00:26:48,240 --> 00:26:52,470
filter iterator that's pretty much

00:26:50,190 --> 00:26:54,840
explainable right now because it has

00:26:52,470 --> 00:26:57,450
recursive so we can assume that it's

00:26:54,840 --> 00:27:00,650
something that allows us to recurse over

00:26:57,450 --> 00:27:04,200
something probably don't do it by itself

00:27:00,650 --> 00:27:06,450
obviously the callback means I can

00:27:04,200 --> 00:27:08,310
actually add a callback filter of a

00:27:06,450 --> 00:27:10,320
callback function to it

00:27:08,310 --> 00:27:14,400
the filter iterator means it filters out

00:27:10,320 --> 00:27:16,800
data so I need to add another iterator

00:27:14,400 --> 00:27:19,560
on top of it so that's pretty much what

00:27:16,800 --> 00:27:22,020
it does so even though it's a really

00:27:19,560 --> 00:27:26,030
long name it makes sense as soon as you

00:27:22,020 --> 00:27:26,030
figure out what all the small parts are

00:27:27,590 --> 00:27:35,010
there was I think in December or

00:27:32,390 --> 00:27:38,880
beginning of January I think there was a

00:27:35,010 --> 00:27:42,000
blog post from Cal Evans who was writing

00:27:38,880 --> 00:27:45,810
about the caching iterator and he had

00:27:42,000 --> 00:27:47,910
absolutely no idea what was happening he

00:27:45,810 --> 00:27:50,040
just he was completely lost and he

00:27:47,910 --> 00:27:51,930
tweeted okay could somebody please help

00:27:50,040 --> 00:27:54,030
me out because I cannot find what's

00:27:51,930 --> 00:27:56,490
going on now I know Cal he's a pretty

00:27:54,030 --> 00:27:59,940
smart guy so if he's like completely

00:27:56,490 --> 00:28:01,530
lost things are really bad and the

00:27:59,940 --> 00:28:03,810
caching iterator is one of the fine

00:28:01,530 --> 00:28:05,730
examples that absolutely makes no sense

00:28:03,810 --> 00:28:08,880
to be inside the SPL at least not in

00:28:05,730 --> 00:28:10,470
this way because the caching iterator is

00:28:08,880 --> 00:28:15,570
actually a two for the price of one

00:28:10,470 --> 00:28:20,250
iterator because in a sense it's it

00:28:15,570 --> 00:28:23,220
caches value of values but it's a look

00:28:20,250 --> 00:28:26,130
ahead iterator it shows you what comes

00:28:23,220 --> 00:28:28,350
next it can detect am i at the end of

00:28:26,130 --> 00:28:29,640
the iterator before it actually hits the

00:28:28,350 --> 00:28:33,750
end of the iterator which could

00:28:29,640 --> 00:28:36,270
sometimes be functional I will show you

00:28:33,750 --> 00:28:38,420
a little bit of one more crappy example

00:28:36,270 --> 00:28:40,830
but at least you have an idea

00:28:38,420 --> 00:28:42,690
but that's the main feature look-ahead

00:28:40,830 --> 00:28:45,240
iterator if it was called look-ahead

00:28:42,690 --> 00:28:49,470
iterator perfect it would make sense but

00:28:45,240 --> 00:28:51,660
it isn't it also caches value values but

00:28:49,470 --> 00:28:54,270
not really it's really bad in doing all

00:28:51,660 --> 00:28:56,400
the caching stuff but it has some

00:28:54,270 --> 00:28:59,100
powerful to string functionality as well

00:28:56,400 --> 00:29:03,510
it's really awesome I never ever seen

00:28:59,100 --> 00:29:06,270
anyone use so if it gets you know gets

00:29:03,510 --> 00:29:09,360
lost in the next minor update of PHP

00:29:06,270 --> 00:29:11,940
nobody cares because nobody is using it

00:29:09,360 --> 00:29:14,250
anyway so how does it work the caching

00:29:11,940 --> 00:29:18,540
iterator so I have an array iterator

00:29:14,250 --> 00:29:21,320
raising a to Z so I have ABCD etc inside

00:29:18,540 --> 00:29:25,310
it and I

00:29:21,320 --> 00:29:26,930
move that inside a caching iterator now

00:29:25,310 --> 00:29:29,480
if I just loop it

00:29:26,930 --> 00:29:32,000
now that caching iterator has something

00:29:29,480 --> 00:29:34,550
called a hasnext and it will show you do

00:29:32,000 --> 00:29:36,530
you have an x-value yes or no and if it

00:29:34,550 --> 00:29:38,510
doesn't you can do all kinds of cool

00:29:36,530 --> 00:29:40,970
stuff with it so in this case I will

00:29:38,510 --> 00:29:43,220
just print out that you just reach the

00:29:40,970 --> 00:29:46,910
last letter before it actually prints

00:29:43,220 --> 00:29:49,340
that maybe makes no example of no sense

00:29:46,910 --> 00:29:51,410
this example but at least you know it's

00:29:49,340 --> 00:29:53,870
something that looks ahead it knows what

00:29:51,410 --> 00:29:56,930
comes up next which can be interesting

00:29:53,870 --> 00:29:58,310
once in a while so this is the main

00:29:56,930 --> 00:30:01,490
feature why you would use a caching

00:29:58,310 --> 00:30:03,530
iterator if you're gonna use it for

00:30:01,490 --> 00:30:06,350
caching purposes you will get something

00:30:03,530 --> 00:30:08,330
like this so you do the same loop again

00:30:06,350 --> 00:30:11,030
and then you type the fourth letter of

00:30:08,330 --> 00:30:13,880
the alphabet is I t3 so you can use it

00:30:11,030 --> 00:30:15,980
as an array pretty much so in this it

00:30:13,880 --> 00:30:23,230
will return the fourth element which

00:30:15,980 --> 00:30:27,320
will be it's not a straight question D

00:30:23,230 --> 00:30:29,240
so that's cool however it's an array so

00:30:27,320 --> 00:30:31,310
you could change it as well you could

00:30:29,240 --> 00:30:34,730
say the third element is now something

00:30:31,310 --> 00:30:37,070
else but don't do that because it will

00:30:34,730 --> 00:30:38,900
mess up your data it doesn't actually

00:30:37,070 --> 00:30:42,050
use the cached data on consecutive calls

00:30:38,900 --> 00:30:44,660
so if you have the iterator and you loop

00:30:42,050 --> 00:30:47,720
over that and you do a second loop and

00:30:44,660 --> 00:30:50,540
it's already build up its own cache it's

00:30:47,720 --> 00:30:54,290
not gonna use it why is it called a

00:30:50,540 --> 00:30:58,820
caching iterator again from now I moved

00:30:54,290 --> 00:31:01,400
from Ruby to go or no js' whatever so it

00:30:58,820 --> 00:31:04,460
doesn't do that um and it clears the

00:31:01,400 --> 00:31:07,010
cache on a rewind or if you do a for

00:31:04,460 --> 00:31:08,900
each loop then all the cache is clear

00:31:07,010 --> 00:31:13,940
again even if you still wanted to use

00:31:08,900 --> 00:31:20,090
that so caching not so much so yeah SPL

00:31:13,940 --> 00:31:22,820
iterators however even though I showed

00:31:20,090 --> 00:31:24,710
you some really bad examples on things

00:31:22,820 --> 00:31:26,180
that doesn't make sense and I completely

00:31:24,710 --> 00:31:29,090
agree with you and this is the reason

00:31:26,180 --> 00:31:31,940
why I do it it's really awesome

00:31:29,090 --> 00:31:34,710
it has quirks it has stuff that doesn't

00:31:31,940 --> 00:31:36,929
make sense but it's solvable we

00:31:34,710 --> 00:31:40,460
and solve it but nobody really does it

00:31:36,929 --> 00:31:43,529
why because nobody really uses it

00:31:40,460 --> 00:31:45,299
documentation is not always updated so

00:31:43,529 --> 00:31:47,179
if the documentation is not update we

00:31:45,299 --> 00:31:51,360
don't know how to use it and it gets

00:31:47,179 --> 00:31:54,059
used incorrectly etc the naming is

00:31:51,360 --> 00:31:56,039
really very confusing again with the

00:31:54,059 --> 00:31:59,970
recursive iterator the C cable iterator

00:31:56,039 --> 00:32:01,440
which is an interface but in the end it

00:31:59,970 --> 00:32:05,130
raters are really worth it

00:32:01,440 --> 00:32:08,159
even if you don't believe me by now they

00:32:05,130 --> 00:32:10,260
really are so that's the iterator part

00:32:08,159 --> 00:32:13,289
most important part for most people when

00:32:10,260 --> 00:32:15,960
you deal with the SPL data structures

00:32:13,289 --> 00:32:17,130
also another important part but not

00:32:15,960 --> 00:32:21,330
really that much used

00:32:17,130 --> 00:32:23,220
how many have used an array in PHP well

00:32:21,330 --> 00:32:26,970
really stupid question because if nobody

00:32:23,220 --> 00:32:32,429
raises a head down okay how many of you

00:32:26,970 --> 00:32:36,990
have used an SPL data structure a few

00:32:32,429 --> 00:32:39,809
okay these are the different SPL data

00:32:36,990 --> 00:32:42,570
structures that are available in the SPL

00:32:39,809 --> 00:32:45,360
SPL doubly-linked list a feel stack etc

00:32:42,570 --> 00:32:47,490
etc now I can tell you a little bit

00:32:45,360 --> 00:32:48,240
about every structure but it doesn't

00:32:47,490 --> 00:32:50,730
make sense

00:32:48,240 --> 00:32:53,340
I think last year or two years ago

00:32:50,730 --> 00:32:55,409
Petric a lot was here talking about SPL

00:32:53,340 --> 00:32:58,559
data structures which is a really good

00:32:55,409 --> 00:33:00,750
talk about what data structures are and

00:32:58,559 --> 00:33:02,990
when you should use it if you have any

00:33:00,750 --> 00:33:05,640
questions on the data structures just

00:33:02,990 --> 00:33:09,990
try and view back that talk because it

00:33:05,640 --> 00:33:12,450
explains a lot more than I can do the

00:33:09,990 --> 00:33:14,610
main problem I don't know if it's a

00:33:12,450 --> 00:33:17,059
problem is that every data structure has

00:33:14,610 --> 00:33:22,169
its own strengths and weaknesses and

00:33:17,059 --> 00:33:24,419
those could be be defined in something

00:33:22,169 --> 00:33:26,159
called a Big O so some structures are

00:33:24,419 --> 00:33:30,600
like really fast

00:33:26,159 --> 00:33:34,440
but need a lot of memory some structures

00:33:30,600 --> 00:33:36,390
are really low on memory but are a

00:33:34,440 --> 00:33:38,659
little bit slower than other structures

00:33:36,390 --> 00:33:42,090
so it's always a trade-off between

00:33:38,659 --> 00:33:45,240
different types of metrics between time

00:33:42,090 --> 00:33:47,399
and space etc those things can be

00:33:45,240 --> 00:33:48,169
defined in something called a Big O

00:33:47,399 --> 00:33:50,729
notation

00:33:48,169 --> 00:33:52,909
doesn't really matter what it is just

00:33:50,729 --> 00:33:55,409
look at the metrical art stock for that

00:33:52,909 --> 00:33:59,820
however what a lot of people don't

00:33:55,409 --> 00:34:02,489
realize that even if you think that you

00:33:59,820 --> 00:34:05,759
should use a pitch be of an SPL data

00:34:02,489 --> 00:34:07,109
structure the PHP air is by itself are

00:34:05,759 --> 00:34:12,059
really good

00:34:07,109 --> 00:34:14,339
in fact the PHP arrays internally in the

00:34:12,059 --> 00:34:17,879
pitch B core are used for pretty much

00:34:14,339 --> 00:34:21,750
everything so all the methods properties

00:34:17,879 --> 00:34:24,119
and constants of class are actually

00:34:21,750 --> 00:34:28,619
stored in the same structure that the

00:34:24,119 --> 00:34:31,260
PHP error uses everything that is like

00:34:28,619 --> 00:34:34,859
the server variables you post variables

00:34:31,260 --> 00:34:36,869
etc it's all used with the same data

00:34:34,859 --> 00:34:39,029
structure it's called a hash table they

00:34:36,869 --> 00:34:41,059
are really you really cool because

00:34:39,029 --> 00:34:44,190
there's a really cool balance between

00:34:41,059 --> 00:34:46,319
time and memory basically and they're

00:34:44,190 --> 00:34:50,250
really fast in doing lookups and they're

00:34:46,319 --> 00:34:52,409
really fast in putting data inside so

00:34:50,250 --> 00:34:55,529
even if you have no idea what to use

00:34:52,409 --> 00:34:58,109
stick to PHP arrays unless you really

00:34:55,529 --> 00:35:01,200
have a good reason to move to something

00:34:58,109 --> 00:35:03,660
like an SPL structure they are reason

00:35:01,200 --> 00:35:08,490
for that only not as much as people

00:35:03,660 --> 00:35:10,829
might think now if anyone have seen to

00:35:08,490 --> 00:35:16,680
talk about which metric a lot about its

00:35:10,829 --> 00:35:19,890
structures no a few okay so what he does

00:35:16,680 --> 00:35:21,359
is like a sort of quiz so we visualize

00:35:19,890 --> 00:35:23,460
the structures and you have to guess

00:35:21,359 --> 00:35:27,000
what it is and I thought it was so funny

00:35:23,460 --> 00:35:29,279
so I want to show you as well so let's

00:35:27,000 --> 00:35:33,720
start with something like this what kind

00:35:29,279 --> 00:35:37,520
of data structure am I looking for as

00:35:33,720 --> 00:35:43,190
stack yeah all right that's a stack

00:35:37,520 --> 00:35:48,119
something like this it's a sword over Q

00:35:43,190 --> 00:35:51,589
it's a Dutch cue actually but yeah I'm a

00:35:48,119 --> 00:35:51,589
bit embarrassed about this one

00:35:52,270 --> 00:35:59,260
it's yeah it's a sort of linked list to

00:35:57,280 --> 00:36:05,250
be mostly correct this would be a drunk

00:35:59,260 --> 00:36:05,250
Dutch linked list but yeah this one

00:36:07,590 --> 00:36:16,540
object storage my favourite when I fly

00:36:14,620 --> 00:36:22,870
back home because I can use the white

00:36:16,540 --> 00:36:29,530
one priority queue this one is a bit of

00:36:22,870 --> 00:36:32,470
a tricky one sorry three that is not

00:36:29,530 --> 00:36:35,740
really a tree there is SPL heap because

00:36:32,470 --> 00:36:39,160
SPL heap uses a tree there are other

00:36:35,740 --> 00:36:43,650
ways to display a heap but I thought I'd

00:36:39,160 --> 00:36:43,650
just be nice last one

00:36:43,890 --> 00:36:51,400
somebody actually told me SPL very large

00:36:46,840 --> 00:36:53,650
array but that doesn't exist it's

00:36:51,400 --> 00:36:56,310
actually fixed array actually they can

00:36:53,650 --> 00:37:01,000
move a little bit but it's fixed enough

00:36:56,310 --> 00:37:03,880
point being of SPL objects used wisely

00:37:01,000 --> 00:37:06,760
for instance SBR stack and SPL queue are

00:37:03,880 --> 00:37:09,370
really fast on doing sequential reads

00:37:06,760 --> 00:37:10,960
like iterate over for each loop however

00:37:09,370 --> 00:37:14,770
if you're gonna use them for random

00:37:10,960 --> 00:37:17,830
reads like item six first and 22 then 63

00:37:14,770 --> 00:37:20,650
then one doesn't work so don't use them

00:37:17,830 --> 00:37:23,110
for random reads and what a lot of

00:37:20,650 --> 00:37:26,200
people don't realize is that fixed

00:37:23,110 --> 00:37:30,160
arrays for instance are really bad for

00:37:26,200 --> 00:37:32,710
certain things they think like if I use

00:37:30,160 --> 00:37:35,920
a fixed array then I get a magically

00:37:32,710 --> 00:37:38,530
speed boost really doesn't really

00:37:35,920 --> 00:37:40,000
perform that well it performs a little

00:37:38,530 --> 00:37:41,680
bit better but it depends on how many

00:37:40,000 --> 00:37:43,480
elements you have and it depends on how

00:37:41,680 --> 00:37:45,880
you're going to use so you cannot really

00:37:43,480 --> 00:37:47,320
say I'll change it to a fixed array and

00:37:45,880 --> 00:37:51,700
then all your problems will magically

00:37:47,320 --> 00:37:54,280
solve them unicorns ponies whatever no

00:37:51,700 --> 00:37:57,730
bench market before you actually use it

00:37:54,280 --> 00:38:00,520
because chances are you actually make a

00:37:57,730 --> 00:38:01,990
code even worse and you lose a lot of

00:38:00,520 --> 00:38:05,940
benefits when you actually use a scale

00:38:01,990 --> 00:38:08,470
fixed array so use wisely

00:38:05,940 --> 00:38:13,090
how many of you actually using SPL

00:38:08,470 --> 00:38:15,220
storage a few okay cool

00:38:13,090 --> 00:38:18,520
SPL object storage is really nice

00:38:15,220 --> 00:38:20,080
because you can use them two ways you

00:38:18,520 --> 00:38:22,510
can use them as a map which is pretty

00:38:20,080 --> 00:38:24,760
much the same thing we do with arrays

00:38:22,510 --> 00:38:27,250
but one of the cool things is you can

00:38:24,760 --> 00:38:30,520
store objects as keys you can't do that

00:38:27,250 --> 00:38:32,320
with normal areas at least not yet but

00:38:30,520 --> 00:38:35,350
you can do it with SPL object storage

00:38:32,320 --> 00:38:38,680
this could be really interesting another

00:38:35,350 --> 00:38:41,890
way is to use them as sets so you create

00:38:38,680 --> 00:38:44,560
an object storage you attach objects to

00:38:41,890 --> 00:38:47,790
them and you can just ask okay does this

00:38:44,560 --> 00:38:50,230
have contain a certain object or you can

00:38:47,790 --> 00:38:53,200
intersect them or you can dip them or

00:38:50,230 --> 00:38:54,730
you can merge them and stuff like that

00:38:53,200 --> 00:38:58,450
so there's a lot of cool stuff you can

00:38:54,730 --> 00:39:01,300
do when dealing with SPL object storage

00:38:58,450 --> 00:39:03,970
as like a normal set which isn't really

00:39:01,300 --> 00:39:05,920
something that's inside the PHP but with

00:39:03,970 --> 00:39:10,120
SPL objects for which you can sort of

00:39:05,920 --> 00:39:13,360
emulate them what really cool is and and

00:39:10,120 --> 00:39:15,850
this is a little bit maybe too far but

00:39:13,360 --> 00:39:18,670
you can actually define on what gets

00:39:15,850 --> 00:39:20,680
stored inside an SPL object storage so

00:39:18,670 --> 00:39:23,290
normally you cannot store the same

00:39:20,680 --> 00:39:27,490
object twice just like you know it would

00:39:23,290 --> 00:39:30,400
overwrite the same key however if I have

00:39:27,490 --> 00:39:32,500
like my storage which extends the SPL of

00:39:30,400 --> 00:39:34,900
6 so it's you can override the get hash

00:39:32,500 --> 00:39:37,480
method and get has method is the way on

00:39:34,900 --> 00:39:43,360
how it will actually figure out which

00:39:37,480 --> 00:39:46,120
kind of you know key to use so I create

00:39:43,360 --> 00:39:48,730
three different objects object one has a

00:39:46,120 --> 00:39:51,160
type called full second one called bar

00:39:48,730 --> 00:39:52,930
and the third one called foo again now

00:39:51,160 --> 00:39:55,510
when I create my storage I'm gonna

00:39:52,930 --> 00:39:57,610
attach the first object it will add it

00:39:55,510 --> 00:39:59,920
without any problem the second one it

00:39:57,610 --> 00:40:01,540
will add without any problems but the

00:39:59,920 --> 00:40:04,510
third one even though it's a different

00:40:01,540 --> 00:40:07,150
object it will notice that the type is

00:40:04,510 --> 00:40:09,460
the same it's a type true and the get

00:40:07,150 --> 00:40:11,800
hash will return the same value and in

00:40:09,460 --> 00:40:15,640
this case it will not attach object 3

00:40:11,800 --> 00:40:18,060
which with this method you can do all

00:40:15,640 --> 00:40:20,890
kinds of awesome stuff

00:40:18,060 --> 00:40:24,250
I'm not her percent sure but I think

00:40:20,890 --> 00:40:27,010
simply to uses this type of system for

00:40:24,250 --> 00:40:28,750
some component or maybe a bundle or

00:40:27,010 --> 00:40:30,940
something does it I've seen it a few

00:40:28,750 --> 00:40:33,760
times in action and it's really great to

00:40:30,940 --> 00:40:36,640
do stuff like this but this is like the

00:40:33,760 --> 00:40:40,440
hardcore SPL stuff so you probably won't

00:40:36,640 --> 00:40:45,100
do that very often all right

00:40:40,440 --> 00:40:48,190
exceptions really cool because nobody

00:40:45,100 --> 00:40:49,710
has a clue on exceptions absolutely no

00:40:48,190 --> 00:40:52,960
clue there are a lot of exceptions

00:40:49,710 --> 00:40:55,300
available but nobody knows how to use

00:40:52,960 --> 00:40:57,370
them and as always discussions on now

00:40:55,300 --> 00:41:00,460
you should not use it this way and this

00:40:57,370 --> 00:41:02,890
exception is for that way etc the

00:41:00,460 --> 00:41:05,410
exceptions are based on two different

00:41:02,890 --> 00:41:08,910
base classes the logic exceptions and

00:41:05,410 --> 00:41:13,990
the runtime exceptions to be honest I'm

00:41:08,910 --> 00:41:16,810
perfectly glad if you use any logic

00:41:13,990 --> 00:41:19,570
exception for when you need to use a

00:41:16,810 --> 00:41:22,420
logic exception and I'm perfectly glad

00:41:19,570 --> 00:41:24,310
when you use any runtime exception when

00:41:22,420 --> 00:41:26,590
you need to troll a runtime exception

00:41:24,310 --> 00:41:29,020
because there is too much strangeness

00:41:26,590 --> 00:41:30,970
going on to figure out which is the best

00:41:29,020 --> 00:41:33,400
exception just try to find the best

00:41:30,970 --> 00:41:38,020
exception and if it doesn't well try

00:41:33,400 --> 00:41:41,350
something else for instance I have a

00:41:38,020 --> 00:41:44,950
simple method and that has an argument

00:41:41,350 --> 00:41:47,050
string STR and if that string is the

00:41:44,950 --> 00:41:48,670
Spanish acquisition I throw an

00:41:47,050 --> 00:41:53,220
unexpected failure exception because

00:41:48,670 --> 00:41:57,520
nobody expects its requisition obviously

00:41:53,220 --> 00:41:59,200
however this is wrong because unexpected

00:41:57,520 --> 00:42:01,780
failure exception is the wrong type of

00:41:59,200 --> 00:42:03,790
argument it's a runtime exception and in

00:42:01,780 --> 00:42:08,830
this case you have to throw a logic

00:42:03,790 --> 00:42:11,380
exception and now obviously you want me

00:42:08,830 --> 00:42:13,060
to explain to you what's the difference

00:42:11,380 --> 00:42:16,360
between a logic exception and runtime

00:42:13,060 --> 00:42:19,510
exception if you go on Stack Overflow or

00:42:16,360 --> 00:42:21,670
any other web site you have two parts

00:42:19,510 --> 00:42:24,000
one says this and the other says that

00:42:21,670 --> 00:42:29,530
and nobody agrees with each other

00:42:24,000 --> 00:42:31,069
however how I try to to define it is

00:42:29,530 --> 00:42:32,989
like logic

00:42:31,069 --> 00:42:36,229
exceptions are exceptions where you as a

00:42:32,989 --> 00:42:39,229
programmer are in charge of which you

00:42:36,229 --> 00:42:43,479
can actually change so for instance you

00:42:39,229 --> 00:42:46,459
are in in control of over what str is

00:42:43,479 --> 00:42:48,709
you know even if it's like something

00:42:46,459 --> 00:42:51,109
that a user give you have the power to

00:42:48,709 --> 00:42:52,910
actually sanitize the data to check if

00:42:51,109 --> 00:42:56,209
that string is actually the Spanish

00:42:52,910 --> 00:42:58,910
Inquisition before you actually call the

00:42:56,209 --> 00:43:01,009
method phone so in this case it's a

00:42:58,910 --> 00:43:03,769
logic exception you are in control you

00:43:01,009 --> 00:43:06,979
can as a programmer change that you can

00:43:03,769 --> 00:43:10,130
change it into a non exception same

00:43:06,979 --> 00:43:12,890
thing as here so if string is not a

00:43:10,130 --> 00:43:16,039
string in invalid argument if the

00:43:12,890 --> 00:43:18,199
integer is less than zero or more than

00:43:16,039 --> 00:43:21,400
ten you can throw an out of range

00:43:18,199 --> 00:43:23,869
exception it's still a logic exception

00:43:21,400 --> 00:43:25,489
but at least it's not a runtime

00:43:23,869 --> 00:43:27,650
exception because there are some runtime

00:43:25,489 --> 00:43:28,160
exceptions that do pretty much the same

00:43:27,650 --> 00:43:30,589
thing

00:43:28,160 --> 00:43:32,749
now however runtime exceptions are

00:43:30,589 --> 00:43:35,180
different runtime exceptions are for

00:43:32,749 --> 00:43:37,849
instance thrown when you want the result

00:43:35,180 --> 00:43:40,519
from a database call because when you do

00:43:37,849 --> 00:43:43,009
a database call it returns and you know

00:43:40,519 --> 00:43:44,660
you say okay save this record for

00:43:43,009 --> 00:43:47,630
instance and then it will say yeah I've

00:43:44,660 --> 00:43:49,729
done it or no something went wrong as a

00:43:47,630 --> 00:43:52,579
programmer you don't have any effect on

00:43:49,729 --> 00:43:55,549
that that's outside your control so

00:43:52,579 --> 00:43:59,329
those are runtime exceptions it also

00:43:55,549 --> 00:44:01,549
means that sometimes an even don't

00:43:59,329 --> 00:44:03,619
really overdo this is that sometimes you

00:44:01,549 --> 00:44:06,170
can retry it so for instance when you

00:44:03,619 --> 00:44:09,769
have a runtime exception on a database

00:44:06,170 --> 00:44:11,719
safe maybe try it again because maybe

00:44:09,769 --> 00:44:13,609
there was a hiccup and the network or

00:44:11,719 --> 00:44:16,069
maybe something else went wrong you

00:44:13,609 --> 00:44:18,440
could try it again if there's an invalid

00:44:16,069 --> 00:44:21,019
argument exception well you can try the

00:44:18,440 --> 00:44:26,329
same string again but still doesn't work

00:44:21,019 --> 00:44:28,999
so you could theoretically use the

00:44:26,329 --> 00:44:32,059
different kind of exceptions to actually

00:44:28,999 --> 00:44:33,380
you know resolve those exceptions you

00:44:32,059 --> 00:44:35,059
shouldn't really do it because an

00:44:33,380 --> 00:44:38,349
exception is there because it's an

00:44:35,059 --> 00:44:39,769
exception but still it's the possibility

00:44:38,349 --> 00:44:43,279
one thing

00:44:39,769 --> 00:44:44,090
actually this is debatable not so much

00:44:43,279 --> 00:44:47,690
the first one

00:44:44,090 --> 00:44:50,930
never ever ever throw exception because

00:44:47,690 --> 00:44:53,180
if you throw exception you are exactly

00:44:50,930 --> 00:44:57,140
the same as the guy that goes into your

00:44:53,180 --> 00:44:57,530
book track system and says it doesn't

00:44:57,140 --> 00:45:01,220
work

00:44:57,530 --> 00:45:04,580
enter scent and you as a developer it

00:45:01,220 --> 00:45:06,860
doesn't work mm right what doesn't work

00:45:04,580 --> 00:45:09,220
you have no idea when you throw

00:45:06,860 --> 00:45:13,040
exception you have no idea what's wrong

00:45:09,220 --> 00:45:16,910
okay you could read the message but now

00:45:13,040 --> 00:45:20,390
you as a developer or you as only can

00:45:16,910 --> 00:45:21,980
print it out to like your website like

00:45:20,390 --> 00:45:25,820
Oh something went wrong and this is the

00:45:21,980 --> 00:45:27,620
message I got returned the database was

00:45:25,820 --> 00:45:30,200
not reached or invalid invalid

00:45:27,620 --> 00:45:33,590
credentials or your data centers on fire

00:45:30,200 --> 00:45:35,660
or whatever so you have no idea because

00:45:33,590 --> 00:45:37,010
as a computer you cannot really do

00:45:35,660 --> 00:45:41,150
anything with it you could write a

00:45:37,010 --> 00:45:43,760
parser that says okay if you string

00:45:41,150 --> 00:45:45,820
match something with fire then do

00:45:43,760 --> 00:45:48,170
something strange with it but no

00:45:45,820 --> 00:45:50,570
exception is really bad exception is

00:45:48,170 --> 00:45:53,360
like the blank book report it doesn't

00:45:50,570 --> 00:45:56,930
work now I always catch the exception is

00:45:53,360 --> 00:45:59,810
actually saying like even if you play by

00:45:56,930 --> 00:46:03,110
the rules maybe somebody else doesn't so

00:45:59,810 --> 00:46:05,750
if you have a call to a library from

00:46:03,110 --> 00:46:08,930
somebody else they might just throw an

00:46:05,750 --> 00:46:10,670
exception so even though you maybe want

00:46:08,930 --> 00:46:14,180
to get runtime exceptions or logic

00:46:10,670 --> 00:46:15,890
exceptions always try to catch the main

00:46:14,180 --> 00:46:18,410
exception as well because they might

00:46:15,890 --> 00:46:20,030
show it as well some people say no you

00:46:18,410 --> 00:46:23,660
shouldn't do that and you should let

00:46:20,030 --> 00:46:25,850
that handle by the main exception

00:46:23,660 --> 00:46:27,830
handler all the way down at the bottom

00:46:25,850 --> 00:46:30,620
of your application but it depends a bit

00:46:27,830 --> 00:46:32,900
on on what you want to do so basically

00:46:30,620 --> 00:46:34,730
navitor exception always try to get

00:46:32,900 --> 00:46:38,530
exception that's the most important

00:46:34,730 --> 00:46:41,060
thing yeah again they are really bad

00:46:38,530 --> 00:46:44,470
documented badly documented so you have

00:46:41,060 --> 00:46:48,560
no idea on when should you use which

00:46:44,470 --> 00:46:53,780
exception and that's the way our days

00:46:48,560 --> 00:46:54,950
right now so miscellaneous stuff there

00:46:53,780 --> 00:46:56,780
are some other stuff in there that's

00:46:54,950 --> 00:46:57,930
really cool

00:46:56,780 --> 00:46:59,609
for instance SPL

00:46:57,930 --> 00:47:01,349
loading we don't really have to deal

00:46:59,609 --> 00:47:03,750
with that right now anymore because of

00:47:01,349 --> 00:47:06,390
the piers are zero stuff so that means

00:47:03,750 --> 00:47:09,960
that we pretty much have taken care of a

00:47:06,390 --> 00:47:13,220
spill Auto loading things like SPL file

00:47:09,960 --> 00:47:17,309
info temp file info anyone ever use that

00:47:13,220 --> 00:47:19,109
those things yeah they're like really

00:47:17,309 --> 00:47:21,720
cool classes because they pretty much

00:47:19,109 --> 00:47:24,059
encapsulate everything for a file so we

00:47:21,720 --> 00:47:26,040
have a file as an object you can do

00:47:24,059 --> 00:47:30,180
everything you could normally do in PHP

00:47:26,040 --> 00:47:31,170
only object based every object nice one

00:47:30,180 --> 00:47:33,059
I will show you as well

00:47:31,170 --> 00:47:36,690
you have something called SPL observe an

00:47:33,059 --> 00:47:38,880
SPL subject which are like interfaces

00:47:36,690 --> 00:47:42,420
you could use to implement SPL observers

00:47:38,880 --> 00:47:45,030
strategy now autoloader and and this is

00:47:42,420 --> 00:47:47,000
absolutely my favorite one so there's

00:47:45,030 --> 00:47:50,309
this function called SPL auto load

00:47:47,000 --> 00:47:52,710
register and you have a function called

00:47:50,309 --> 00:47:54,780
SPL auto load call and a spill autoload

00:47:52,710 --> 00:47:56,910
call is the default or the loader when

00:47:54,780 --> 00:47:59,579
no other loaders are loaded the default

00:47:56,910 --> 00:48:02,880
one what would happen if you actually

00:47:59,579 --> 00:48:05,690
register the default auto loader anyone

00:48:02,880 --> 00:48:05,690
wild guess

00:48:07,220 --> 00:48:15,000
obviously it draws a logic exception

00:48:10,040 --> 00:48:17,609
right okay so fair enough

00:48:15,000 --> 00:48:21,480
SPL auto load unregister let's be auto

00:48:17,609 --> 00:48:25,200
load call what will it do who's who's in

00:48:21,480 --> 00:48:29,849
favor for drawing and invalid a logic

00:48:25,200 --> 00:48:32,549
exception again I'm raising my hand but

00:48:29,849 --> 00:48:34,049
know what it actually does it doesn't

00:48:32,549 --> 00:48:36,480
throw an exception it will actually

00:48:34,049 --> 00:48:38,400
remove all the Auto loaders that are

00:48:36,480 --> 00:48:40,260
there it will destroy the complete auto

00:48:38,400 --> 00:48:43,319
load stack and if you let it it will

00:48:40,260 --> 00:48:45,900
actually set your house on fire never

00:48:43,319 --> 00:48:48,780
ever ever do it like this I actually

00:48:45,900 --> 00:48:50,790
inside the PHP core and I can show you

00:48:48,780 --> 00:48:53,220
later on if you're interested in it

00:48:50,790 --> 00:48:56,069
there is actually a piece of code that

00:48:53,220 --> 00:48:58,589
says if the argument supplied is SPL

00:48:56,069 --> 00:49:01,230
auto load call destroy this track the

00:48:58,589 --> 00:49:04,950
auto load stack it's in there probably

00:49:01,230 --> 00:49:10,049
most probably it's left over code while

00:49:04,950 --> 00:49:12,869
debugging stuff hopefully hopefully but

00:49:10,049 --> 00:49:15,359
yeah nobody actually figured it out so

00:49:12,869 --> 00:49:18,780
they're not using it but still it's in

00:49:15,359 --> 00:49:23,670
there so strange stuff happens when you

00:49:18,780 --> 00:49:25,950
supply certain arguments it's like how

00:49:23,670 --> 00:49:28,710
do you call it the Easter eggs and stuff

00:49:25,950 --> 00:49:31,010
like that so if you want to have a

00:49:28,710 --> 00:49:33,780
really good time just put this somewhere

00:49:31,010 --> 00:49:36,540
inside your coat and let your colleagues

00:49:33,780 --> 00:49:39,420
worry about whatever happened to your

00:49:36,540 --> 00:49:42,059
coat later on okay very quickly area

00:49:39,420 --> 00:49:44,369
objects anyone use array objects they

00:49:42,059 --> 00:49:47,190
are really cool because area objects are

00:49:44,369 --> 00:49:49,530
objects that act like array however area

00:49:47,190 --> 00:49:51,780
objects are really not objects that acts

00:49:49,530 --> 00:49:54,809
like array and I will show you why I

00:49:51,780 --> 00:49:59,640
have an array array with a full at a bar

00:49:54,809 --> 00:50:03,589
element I say B becomes a I add an extra

00:49:59,640 --> 00:50:12,240
element to B what will be the output

00:50:03,589 --> 00:50:15,119
what will a be bar and bass and B will

00:50:12,240 --> 00:50:18,119
become full bar bass why is that because

00:50:15,119 --> 00:50:21,450
it's something called copy-on-write

00:50:18,119 --> 00:50:23,400
so it doesn't change and it doesn't copy

00:50:21,450 --> 00:50:25,740
anything until something changes and

00:50:23,400 --> 00:50:28,230
then it makes two copies of a and B in

00:50:25,740 --> 00:50:29,880
this case perfect this is pretty common

00:50:28,230 --> 00:50:32,280
knowledge however now I'm gonna use

00:50:29,880 --> 00:50:34,410
array objects I'm gonna add foo and bar

00:50:32,280 --> 00:50:36,569
again pretty much the same thing I'm

00:50:34,410 --> 00:50:38,730
gonna say B becomes a again I add

00:50:36,569 --> 00:50:41,190
something to B and I will just because

00:50:38,730 --> 00:50:43,650
it's an area object you can actually use

00:50:41,190 --> 00:50:47,119
iterator to aerate to return it as an

00:50:43,650 --> 00:50:51,650
array what will be the output same thing

00:50:47,119 --> 00:50:55,890
reckon obviously not

00:50:51,650 --> 00:50:58,770
yeah they're both equal so now I changed

00:50:55,890 --> 00:51:01,950
B but now a has changed as well why

00:50:58,770 --> 00:51:04,020
because this is a reference B and a are

00:51:01,950 --> 00:51:06,240
the same object the pointing to the same

00:51:04,020 --> 00:51:10,020
object if you don't know that array

00:51:06,240 --> 00:51:12,150
object is an array but of is an area

00:51:10,020 --> 00:51:16,500
object and not an array things like this

00:51:12,150 --> 00:51:19,710
will be pretty messy so how can we make

00:51:16,500 --> 00:51:20,590
the SPL easier because that's the main

00:51:19,710 --> 00:51:26,160
where

00:51:20,590 --> 00:51:29,200
I'm asking first of all buy my book I

00:51:26,160 --> 00:51:31,150
can literally say I wrote the book about

00:51:29,200 --> 00:51:35,260
SPL because there's no other book about

00:51:31,150 --> 00:51:37,630
SPL hopefully it fixes the documentation

00:51:35,260 --> 00:51:40,150
problem about the SPL and if it doesn't

00:51:37,630 --> 00:51:44,260
you know it makes good thing for your

00:51:40,150 --> 00:51:46,060
cat or put it on a table or whatever but

00:51:44,260 --> 00:51:48,550
you can do as something as well

00:51:46,060 --> 00:51:51,280
adoption of the SPL can only happen when

00:51:48,550 --> 00:51:52,900
developers are familiar with it there's

00:51:51,280 --> 00:51:56,560
currently no real way to familiarize

00:51:52,900 --> 00:51:59,530
with the SPL so you have a problem what

00:51:56,560 --> 00:52:02,080
can we do Bogg about it if you do

00:51:59,530 --> 00:52:04,960
something with SPL blog about it what

00:52:02,080 --> 00:52:07,180
you did what went wrong what you fixed

00:52:04,960 --> 00:52:09,430
what's not in manual if it's not in the

00:52:07,180 --> 00:52:12,010
manual try to update them the php.net

00:52:09,430 --> 00:52:14,350
manual as well it's much easier nowadays

00:52:12,010 --> 00:52:16,450
to actually add comments on that the

00:52:14,350 --> 00:52:19,450
more commands the more people will know

00:52:16,450 --> 00:52:22,720
about SPL the easier it is to work with

00:52:19,450 --> 00:52:25,120
that if you find stuff like let's build

00:52:22,720 --> 00:52:27,850
all the road unregister find the quirks

00:52:25,120 --> 00:52:31,660
and maybe even solve them if you know

00:52:27,850 --> 00:52:33,880
how to this is the only way that I don't

00:52:31,660 --> 00:52:36,910
have to do this talk in three four years

00:52:33,880 --> 00:52:38,470
time I really want to do it but I really

00:52:36,910 --> 00:52:40,150
like to do with talk about the SPL as

00:52:38,470 --> 00:52:43,000
also man there's nothing wrong with it

00:52:40,150 --> 00:52:46,060
but the only way to do that is for you

00:52:43,000 --> 00:52:48,610
guys to actually use the SPL to document

00:52:46,060 --> 00:52:51,190
the SPL so more people can use it and

00:52:48,610 --> 00:52:55,690
more people can actually you figure out

00:52:51,190 --> 00:52:59,190
what's going on okay any questions how

00:52:55,690 --> 00:53:03,840
much time I have for questions an hour

00:52:59,190 --> 00:53:03,840
okay any questions nobody

00:53:06,450 --> 00:53:11,470
if I was deftly on the SPL I'm gonna ask

00:53:09,850 --> 00:53:15,910
questions to you guys you know that's

00:53:11,470 --> 00:53:29,620
right we do a written exam oh there's a

00:53:15,910 --> 00:53:32,260
few I saw in your it retinas there's an

00:53:29,620 --> 00:53:35,740
infinite iterator yeah what does that

00:53:32,260 --> 00:53:39,460
one do what do you reckon it does it

00:53:35,740 --> 00:53:43,360
does everything yeah it's like the

00:53:39,460 --> 00:53:45,730
Narnia cat of iterators now actually

00:53:43,360 --> 00:53:49,660
what it does normally when an iterator

00:53:45,730 --> 00:53:51,940
at is at an end it will stop right what

00:53:49,660 --> 00:53:54,040
an infinite alterator does it will

00:53:51,940 --> 00:53:57,070
actually see oh if I'm at the last

00:53:54,040 --> 00:53:59,860
element I will call rewind again so it

00:53:57,070 --> 00:54:02,830
will loop so you have a complete loop

00:53:59,860 --> 00:54:05,430
could be useful don't use it without a

00:54:02,830 --> 00:54:09,420
limit iterator afterwards otherwise

00:54:05,430 --> 00:54:12,820
takes a long time before it's finished

00:54:09,420 --> 00:54:14,560
that there are some valid use cases for

00:54:12,820 --> 00:54:18,130
that but it's not something you will use

00:54:14,560 --> 00:54:20,550
very often but still it can be useful in

00:54:18,130 --> 00:54:24,580
combination with the limit iterator okay

00:54:20,550 --> 00:54:26,440
any other questions to be honest I

00:54:24,580 --> 00:54:28,360
totally suck when it comes to questions

00:54:26,440 --> 00:54:31,060
like this if you ask me something about

00:54:28,360 --> 00:54:33,580
all the nasty edge cases I happy

00:54:31,060 --> 00:54:37,540
happily will tell you that this one I

00:54:33,580 --> 00:54:40,810
just know but yeah okay so in the last

00:54:37,540 --> 00:54:42,940
week's I came across array objects on

00:54:40,810 --> 00:54:45,850
the internet and I toyed with the idea

00:54:42,940 --> 00:54:48,960
of universally using it in our code base

00:54:45,850 --> 00:54:51,820
yeah I live in an environment where

00:54:48,960 --> 00:54:55,600
things come from an API and where

00:54:51,820 --> 00:54:58,360
everything is an array and currently we

00:54:55,600 --> 00:55:03,070
use you have MS arrays but it would be

00:54:58,360 --> 00:55:05,560
nice to make them objects to live in an

00:55:03,070 --> 00:55:09,250
object-oriented world and now seeing

00:55:05,560 --> 00:55:12,400
what you have written in on your slides

00:55:09,250 --> 00:55:16,180
I'm wondering do you advise against

00:55:12,400 --> 00:55:17,860
array objects no definitely not

00:55:16,180 --> 00:55:20,050
however you have to be

00:55:17,860 --> 00:55:22,060
with array objects because I showed you

00:55:20,050 --> 00:55:23,470
before they act a little bit differently

00:55:22,060 --> 00:55:25,000
than normal

00:55:23,470 --> 00:55:27,670
arrays so you can't just say or

00:55:25,000 --> 00:55:29,050
everywhere where define an array I can

00:55:27,670 --> 00:55:31,270
replace it with an area object it

00:55:29,050 --> 00:55:33,490
doesn't work like that because you know

00:55:31,270 --> 00:55:37,390
there are some precautions on that

00:55:33,490 --> 00:55:39,460
however if you have code that is

00:55:37,390 --> 00:55:44,470
actually testable where you have unit

00:55:39,460 --> 00:55:45,910
tests and obviously you have them soon

00:55:44,470 --> 00:55:48,970
soon okay

00:55:45,910 --> 00:55:50,890
as soon as you hit the the unit test you

00:55:48,970 --> 00:55:53,550
can actually try and experiment with

00:55:50,890 --> 00:55:56,170
them and see where things will feel

00:55:53,550 --> 00:55:58,810
might might not depends on how you're

00:55:56,170 --> 00:56:01,270
gonna use the areas but yes there are

00:55:58,810 --> 00:56:03,070
some really cool methods inside the area

00:56:01,270 --> 00:56:06,550
object that will allows you to do like

00:56:03,070 --> 00:56:08,710
nifty stuff so I can't say for now if

00:56:06,550 --> 00:56:11,440
it's worth the the whole transition

00:56:08,710 --> 00:56:13,510
period but it might be it might not be

00:56:11,440 --> 00:56:15,280
but you have to find out yourself and if

00:56:13,510 --> 00:56:17,620
you have the unit test in place then you

00:56:15,280 --> 00:56:19,140
actually can figure out if it's actually

00:56:17,620 --> 00:56:22,420
worth it

00:56:19,140 --> 00:56:24,190
thank you okay just interrupt we're

00:56:22,420 --> 00:56:26,200
gonna take one or two more questions but

00:56:24,190 --> 00:56:28,210
the people at the back if you want to

00:56:26,200 --> 00:56:30,880
commit and quietly and take some seats

00:56:28,210 --> 00:56:33,040
in the back that's okay if you wanted to

00:56:30,880 --> 00:56:35,370
take some sincere so I've got one

00:56:33,040 --> 00:56:38,410
question at the back here yeah perfect

00:56:35,370 --> 00:56:42,370
hello oh yeah is anyone attempted to

00:56:38,410 --> 00:56:46,410
make a standard standard PHP library

00:56:42,370 --> 00:56:46,410
library that normalizes the interface

00:56:46,890 --> 00:56:54,100
you know what try to post that on the

00:56:51,250 --> 00:56:55,720
internals mailing list and I will get

00:56:54,100 --> 00:57:02,350
the popcorn out and I will have a lot of

00:56:55,720 --> 00:57:04,180
fun no they don't but it would make

00:57:02,350 --> 00:57:06,640
sense to have people around that

00:57:04,180 --> 00:57:09,940
actually fixes the things that we do and

00:57:06,640 --> 00:57:11,890
the only way to fix it really correctly

00:57:09,940 --> 00:57:13,830
is to actually change the things but

00:57:11,890 --> 00:57:16,240
obviously that means backwards

00:57:13,830 --> 00:57:18,820
compatibility breaks so you can't do

00:57:16,240 --> 00:57:21,880
that on every release so you have to do

00:57:18,820 --> 00:57:24,130
it like small steps at a time so it will

00:57:21,880 --> 00:57:27,880
take a long time to actually fix all the

00:57:24,130 --> 00:57:29,710
issues we have but it means that every

00:57:27,880 --> 00:57:34,150
release it gets better and better and

00:57:29,710 --> 00:57:36,750
but nobody has written an SPL on top of

00:57:34,150 --> 00:57:40,089
the SPL know what would be fun but now

00:57:36,750 --> 00:57:45,510
unfortunately okay what one more

00:57:40,089 --> 00:57:53,349
question one more question

00:57:45,510 --> 00:57:56,530
right when writing your own exceptions

00:57:53,349 --> 00:57:59,410
yeah I usually extend the exception

00:57:56,530 --> 00:58:01,619
class is that a good idea or are the

00:57:59,410 --> 00:58:05,560
logic exception and runtime exception

00:58:01,619 --> 00:58:08,380
classes to extend I personally I would

00:58:05,560 --> 00:58:10,480
try to use the logic exception around an

00:58:08,380 --> 00:58:13,390
exception for that based on what the

00:58:10,480 --> 00:58:15,099
type of exception is you have something

00:58:13,390 --> 00:58:16,990
called a domain exception so if it's

00:58:15,099 --> 00:58:19,320
like an exception inside your domain I

00:58:16,990 --> 00:58:22,420
try to base that on the domain exception

00:58:19,320 --> 00:58:24,730
but yet try to use the most detailed

00:58:22,420 --> 00:58:27,310
exception and use that as a base class

00:58:24,730 --> 00:58:29,170
that means it's more easy and more

00:58:27,310 --> 00:58:34,119
maintainable to catch those exceptions

00:58:29,170 --> 00:58:35,200
for others to do that okay all right if

00:58:34,119 --> 00:58:37,240
that's it

00:58:35,200 --> 00:58:40,390
my presentation the slides and

00:58:37,240 --> 00:58:41,950
everything is on joint in so you can get

00:58:40,390 --> 00:58:44,619
the slides there and leave your feedback

00:58:41,950 --> 00:58:46,170
as well if you have any questions about

00:58:44,619 --> 00:58:49,869
this later

00:58:46,170 --> 00:58:52,300
later on you can ask me here or even

00:58:49,869 --> 00:58:56,790
contact me at Twitter or email or

00:58:52,300 --> 00:58:56,790

YouTube URL: https://www.youtube.com/watch?v=Z4piH7PTjVc


