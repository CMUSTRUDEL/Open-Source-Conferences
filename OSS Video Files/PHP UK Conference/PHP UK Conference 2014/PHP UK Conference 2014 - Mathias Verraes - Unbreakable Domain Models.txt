Title: PHP UK Conference 2014 - Mathias Verraes - Unbreakable Domain Models
Publication date: 2014-03-21
Playlist: PHP UK Conference 2014
Description: 
	Data Mappers (like Doctrine2) help us a lot to persist data. Yet many projects are still struggling with tough questions:

- Where to put business logic?
- How to protect our code from abuse?
- Where to put queries, and how test them?

Let's look beyond the old Gang of Four design patterns, and take some clues from tactical Domain Driven Design. At the heart of our models, we can use Value Objects and Entities, with tightly defined consistency boundaries. Repositories abstract away the persistence. Encapsulated Operations helps us to protect invariants. And if we need to manage a lot of complexity, the Specification pattern helps us express business rules in the language of the business. These patterns help us evolve from structural data models, to rich behavioral models. They capture not just state and relationships, but true meaning. The presentation is a fast paced introduction to some patterns and ideas that will make your Domain Model expressive, unbreakable, and beautiful.
Captions: 
	00:00:05,029 --> 00:00:11,219
thanks for coming I may have overdone it

00:00:09,630 --> 00:00:14,219
a little bit with the Raphael painting

00:00:11,219 --> 00:00:16,789
but you know this is a map of the world

00:00:14,219 --> 00:00:19,410
with all the interesting places and

00:00:16,789 --> 00:00:23,580
guess where I live

00:00:19,410 --> 00:00:25,619
so maybe I should oh yeah so all modes

00:00:23,580 --> 00:00:28,529
are wrong but some are useful remember

00:00:25,619 --> 00:00:29,580
this whenever you model something so my

00:00:28,529 --> 00:00:31,650
name is Mattias Rus

00:00:29,580 --> 00:00:34,820
I'm an independent consultant I help

00:00:31,650 --> 00:00:37,649
teams with enterprise web applications

00:00:34,820 --> 00:00:41,129
preferably for complex business domains

00:00:37,649 --> 00:00:43,850
I have sort of a reputation for being

00:00:41,129 --> 00:00:46,309
good with legacy systems like the big

00:00:43,850 --> 00:00:49,320
complex mess that you inherit from

00:00:46,309 --> 00:00:52,620
developers have that have long gone I

00:00:49,320 --> 00:00:54,360
help teams do you know deal with that

00:00:52,620 --> 00:00:58,410
and actually enjoy that it's like you

00:00:54,360 --> 00:00:59,609
have a bigger challenge I've been busy

00:00:58,410 --> 00:01:03,059
at the past you know I've been blogging

00:00:59,609 --> 00:01:06,510
a lot at my website I started a podcast

00:01:03,059 --> 00:01:07,830
with Constantine the B hat guy he's here

00:01:06,510 --> 00:01:11,130
in the room somewhere code talk to him

00:01:07,830 --> 00:01:13,229
he's very smart and interesting and like

00:01:11,130 --> 00:01:15,299
two weeks ago because I was getting

00:01:13,229 --> 00:01:17,070
these emails from people who I saw your

00:01:15,299 --> 00:01:17,939
talk I read your blog and can you help

00:01:17,070 --> 00:01:20,580
me with this domain-driven design

00:01:17,939 --> 00:01:23,939
problem and it's a like not very

00:01:20,580 --> 00:01:26,100
efficient to do this by email one at a

00:01:23,939 --> 00:01:28,650
time so I just founded the Google group

00:01:26,100 --> 00:01:32,040
and in two weeks time we have like

00:01:28,650 --> 00:01:34,020
almost 200 members and and I think just

00:01:32,040 --> 00:01:35,130
as many posts as well so join it if

00:01:34,020 --> 00:01:37,320
you're interested in domain driven

00:01:35,130 --> 00:01:39,829
design I haven't even gotten a proper

00:01:37,320 --> 00:01:42,530
domain name yet but I will

00:01:39,829 --> 00:01:45,390
so what are we going to talk about the

00:01:42,530 --> 00:01:47,340
domain when I talk about the domain I'm

00:01:45,390 --> 00:01:50,310
talking about the problem space this is

00:01:47,340 --> 00:01:53,220
the the problem that a business is

00:01:50,310 --> 00:01:56,579
trying to solve when we talk about the

00:01:53,220 --> 00:01:59,189
domain model it's or the interpretation

00:01:56,579 --> 00:02:01,740
of this problem and our inspiration of

00:01:59,189 --> 00:02:05,850
this of a solution it's one potential

00:02:01,740 --> 00:02:08,069
solution domain model is something

00:02:05,850 --> 00:02:10,289
different altogether than a data model

00:02:08,069 --> 00:02:11,770
often when people talk about the model

00:02:10,289 --> 00:02:13,450
they just mean

00:02:11,770 --> 00:02:15,730
the schema that they have in the

00:02:13,450 --> 00:02:18,160
database and the fields and which is a

00:02:15,730 --> 00:02:21,040
very structural way of thinking about it

00:02:18,160 --> 00:02:23,620
it's it's more about that it's it's it's

00:02:21,040 --> 00:02:27,010
more about behavior than about data the

00:02:23,620 --> 00:02:29,590
data is almost you know a side effect of

00:02:27,010 --> 00:02:33,250
the behavior this is how our users think

00:02:29,590 --> 00:02:35,860
about software it's I do this to get

00:02:33,250 --> 00:02:39,040
this thing done this is the effect that

00:02:35,860 --> 00:02:41,890
I want this is the the the behavior I

00:02:39,040 --> 00:02:45,610
expect so this is the sort of thing that

00:02:41,890 --> 00:02:47,910
that we want to think about and and this

00:02:45,610 --> 00:02:52,510
presentation I want to talk about

00:02:47,910 --> 00:02:55,210
invariance mostly so how do you I ok the

00:02:52,510 --> 00:02:56,830
tale the title is also a bit exaggerated

00:02:55,210 --> 00:02:59,290
maybe because there's always ways to

00:02:56,830 --> 00:03:01,630
break your software and you know people

00:02:59,290 --> 00:03:03,760
are always going to be more creative in

00:03:01,630 --> 00:03:08,320
breaking your software then you can come

00:03:03,760 --> 00:03:10,240
up with ways to prevent it but you if

00:03:08,320 --> 00:03:12,510
you remember only one thing it's to

00:03:10,240 --> 00:03:15,790
protect your invariance think about

00:03:12,510 --> 00:03:19,270
these business rules and how to make

00:03:15,790 --> 00:03:22,810
sure that there's no way to do anything

00:03:19,270 --> 00:03:24,640
with your system that violates these

00:03:22,810 --> 00:03:26,470
business rules and I'm not just talking

00:03:24,640 --> 00:03:29,980
about users I'm talking about the

00:03:26,470 --> 00:03:32,230
developers as well if you have a system

00:03:29,980 --> 00:03:34,780
where it's very easy for you know

00:03:32,230 --> 00:03:37,600
another guy in your team to come in and

00:03:34,780 --> 00:03:40,720
write something that violates these

00:03:37,600 --> 00:03:44,040
rules then you know you're going to have

00:03:40,720 --> 00:03:46,720
bugs eventually so we'll start with that

00:03:44,040 --> 00:03:49,630
like the simplest example I could come

00:03:46,720 --> 00:03:51,730
up with is very very basic we talk to

00:03:49,630 --> 00:03:54,490
our domain expert and he wants to do

00:03:51,730 --> 00:03:56,620
some ecommerce thing maybe and he says

00:03:54,490 --> 00:03:59,680
well a customer must always have an

00:03:56,620 --> 00:04:01,690
email address so this is just for this

00:03:59,680 --> 00:04:03,940
if you can't read it in the back at the

00:04:01,690 --> 00:04:05,730
bottom there's some disclaimers saying

00:04:03,940 --> 00:04:08,489
it could be different for your domain

00:04:05,730 --> 00:04:10,630
maybe in your domain customers do not

00:04:08,489 --> 00:04:12,610
need to have an email address all the

00:04:10,630 --> 00:04:14,350
time but for this example they do and

00:04:12,610 --> 00:04:16,500
all the examples I'm going to show are

00:04:14,350 --> 00:04:19,060
going to be very simplified of course

00:04:16,500 --> 00:04:23,050
but hopefully you can you can imagine

00:04:19,060 --> 00:04:25,270
how to use this in your own systems okay

00:04:23,050 --> 00:04:28,960
we we start building and

00:04:25,270 --> 00:04:32,050
we do this test-driven so we write a

00:04:28,960 --> 00:04:34,780
unit test and you can read this like

00:04:32,050 --> 00:04:37,560
this it's a customer should always have

00:04:34,780 --> 00:04:40,600
an email that's the name of our test I

00:04:37,560 --> 00:04:42,310
like this different notation for tests

00:04:40,600 --> 00:04:44,710
for the methods because they're not

00:04:42,310 --> 00:04:46,449
actually methods they're they're

00:04:44,710 --> 00:04:47,979
descriptions of what our code is

00:04:46,449 --> 00:04:50,410
supposed to do and we happen to use

00:04:47,979 --> 00:04:52,960
classes and methods for our unit tests

00:04:50,410 --> 00:04:55,060
but that's just the infrastructure so

00:04:52,960 --> 00:04:56,770
it's this is not a method in the sense

00:04:55,060 --> 00:04:59,710
that you know a method in your

00:04:56,770 --> 00:05:01,380
production code is a method okay we

00:04:59,710 --> 00:05:04,030
write the test the test is failing

00:05:01,380 --> 00:05:07,000
customer is a new customer assert that

00:05:04,030 --> 00:05:10,240
customer get email is equal to Jim

00:05:07,000 --> 00:05:13,470
example right example so how to make

00:05:10,240 --> 00:05:17,020
this pass this test pass very simple we

00:05:13,470 --> 00:05:19,690
set an email on to this customer object

00:05:17,020 --> 00:05:24,250
and this test is green but have we

00:05:19,690 --> 00:05:26,440
actually proven that it's now impossible

00:05:24,250 --> 00:05:29,470
for a customer not to have an email

00:05:26,440 --> 00:05:32,979
address well no because if you change

00:05:29,470 --> 00:05:34,889
the order a little bit then our test

00:05:32,979 --> 00:05:38,919
fails again so it's perfectly possible

00:05:34,889 --> 00:05:44,470
right here to make a customer and it's

00:05:38,919 --> 00:05:46,479
still in an inconsistent state it's

00:05:44,470 --> 00:05:48,520
still possible for some other developer

00:05:46,479 --> 00:05:50,830
to come in and make a new customer

00:05:48,520 --> 00:05:52,449
object somewhere and he doesn't know

00:05:50,830 --> 00:05:55,030
about this business rule about always

00:05:52,449 --> 00:05:56,320
having an email address so three months

00:05:55,030 --> 00:05:57,909
later you discover that half the

00:05:56,320 --> 00:05:59,620
customers in your database don't have

00:05:57,909 --> 00:06:02,320
email addresses and that's all messed up

00:05:59,620 --> 00:06:04,240
and you're losing a lot of money so what

00:06:02,320 --> 00:06:07,530
we want to do is make it impossible and

00:06:04,240 --> 00:06:11,919
it's it's very easy and this is basic

00:06:07,530 --> 00:06:14,380
object-oriented programming and yet and

00:06:11,919 --> 00:06:17,919
I'll get to that people don't do this so

00:06:14,380 --> 00:06:19,630
this is by simply making it a required

00:06:17,919 --> 00:06:21,880
field of the constructor it's now

00:06:19,630 --> 00:06:26,050
impossible to make a customer without an

00:06:21,880 --> 00:06:31,419
email address and you'd probably want

00:06:26,050 --> 00:06:34,460
some sound is oh that's bad

00:06:31,419 --> 00:06:37,039
the point I'm trying to make is you

00:06:34,460 --> 00:06:40,759
should see an object as a consistency

00:06:37,039 --> 00:06:46,069
boundary within an object all the rules

00:06:40,759 --> 00:06:47,629
that apply to it should always be met so

00:06:46,069 --> 00:06:49,789
it should be impossible to make a

00:06:47,629 --> 00:06:52,099
customer in this example that does not

00:06:49,789 --> 00:06:55,340
have an email address and you know

00:06:52,099 --> 00:06:58,189
you're going to say sometimes in my

00:06:55,340 --> 00:06:59,900
domain we have like it's different

00:06:58,189 --> 00:07:02,870
sometimes we have customers that don't

00:06:59,900 --> 00:07:05,870
have an email object an email address

00:07:02,870 --> 00:07:08,509
yet and they get one later in the in the

00:07:05,870 --> 00:07:10,819
processor and workflow if your domain is

00:07:08,509 --> 00:07:13,689
like that if you're the problem you're

00:07:10,819 --> 00:07:16,789
trying to solve is more ambiguous than

00:07:13,689 --> 00:07:19,520
the rule I showed first where a customer

00:07:16,789 --> 00:07:21,560
always has an email address then maybe

00:07:19,520 --> 00:07:23,749
you are missing some concept maybe

00:07:21,560 --> 00:07:26,449
there's two kinds of customers for

00:07:23,749 --> 00:07:29,449
example you could have a prospective

00:07:26,449 --> 00:07:32,569
customer and maybe the moment you

00:07:29,449 --> 00:07:34,490
actually sell something to them they

00:07:32,569 --> 00:07:36,919
become a paying customer and to have a

00:07:34,490 --> 00:07:38,599
paying customer they will need an email

00:07:36,919 --> 00:07:43,189
address because you need to send them

00:07:38,599 --> 00:07:46,490
invoices etc so here we are still we

00:07:43,189 --> 00:07:49,430
still have objects as consistency

00:07:46,490 --> 00:07:51,680
boundaries the prospective customer is

00:07:49,430 --> 00:07:53,810
consistent it doesn't need to have an

00:07:51,680 --> 00:07:56,599
email address the paying customer is

00:07:53,810 --> 00:08:00,349
consistent because it cannot have no

00:07:56,599 --> 00:08:03,830
email address so we try to make the

00:08:00,349 --> 00:08:07,430
implicit explicit if you discover this

00:08:03,830 --> 00:08:09,770
sort of vagueness or these multiple

00:08:07,430 --> 00:08:11,360
rules apply in different contexts then

00:08:09,770 --> 00:08:13,879
you're probably missing some some

00:08:11,360 --> 00:08:17,719
concept try to find it make it make it

00:08:13,879 --> 00:08:19,810
very invisible so and maybe for some

00:08:17,719 --> 00:08:24,289
bonus points

00:08:19,810 --> 00:08:26,689
if we add this method here come to

00:08:24,289 --> 00:08:30,229
paying customer on a prospective

00:08:26,689 --> 00:08:33,169
customer then there's only one place

00:08:30,229 --> 00:08:35,389
that knows how to turn a prospective

00:08:33,169 --> 00:08:38,630
customer into a paying customer this

00:08:35,389 --> 00:08:40,610
rule where you know this customer

00:08:38,630 --> 00:08:42,140
becomes a paying customer and needs an

00:08:40,610 --> 00:08:43,450
email address to have it is now

00:08:42,140 --> 00:08:46,570
encapsulated in this method

00:08:43,450 --> 00:08:48,310
so you don't have to know on the outside

00:08:46,570 --> 00:08:50,500
how this works and it's still very

00:08:48,310 --> 00:08:52,180
simple but if your your rules become

00:08:50,500 --> 00:08:57,940
more complicated then it's very valuable

00:08:52,180 --> 00:08:59,800
to do this sort of thing and so what I

00:08:57,940 --> 00:09:03,580
mentioned earlier is that many people

00:08:59,800 --> 00:09:05,800
don't do this kind of thing because

00:09:03,580 --> 00:09:09,490
they're because the frameworks often

00:09:05,800 --> 00:09:10,470
force us to have getters and setters for

00:09:09,490 --> 00:09:15,220
everything

00:09:10,470 --> 00:09:18,640
some ORM sand and you know persistence

00:09:15,220 --> 00:09:20,590
libraries force you to do this some form

00:09:18,640 --> 00:09:22,930
libraries force you to do this kind of

00:09:20,590 --> 00:09:25,420
stuff with getters and setters

00:09:22,930 --> 00:09:27,750
there are ways around that well my

00:09:25,420 --> 00:09:31,360
general answer would be don't use them

00:09:27,750 --> 00:09:33,280
but if you have to use them you can you

00:09:31,360 --> 00:09:36,010
can start to think about layers in

00:09:33,280 --> 00:09:38,860
between you could have command objects

00:09:36,010 --> 00:09:41,680
for your forms you can have DTS data

00:09:38,860 --> 00:09:43,630
transfer objects and I'm not going to go

00:09:41,680 --> 00:09:45,610
into detail but you know read up on that

00:09:43,630 --> 00:09:47,620
if you have this problem where you feel

00:09:45,610 --> 00:09:52,330
your framework is forcing you into a

00:09:47,620 --> 00:09:55,090
certain direction so um we're worried

00:09:52,330 --> 00:09:57,220
yes all domain expert comes back to us

00:09:55,090 --> 00:09:59,260
like well he doesn't even say this but

00:09:57,220 --> 00:10:01,900
this is what he implied he didn't think

00:09:59,260 --> 00:10:03,550
about this because he just assumed that

00:10:01,900 --> 00:10:05,590
the email address was going to be valid

00:10:03,550 --> 00:10:08,250
anyway but we know as developers that

00:10:05,590 --> 00:10:11,800
you know we can't just have any string

00:10:08,250 --> 00:10:14,250
being used as an email address so what

00:10:11,800 --> 00:10:17,800
many people do and what again this this

00:10:14,250 --> 00:10:20,230
typical framework and frameworks and

00:10:17,800 --> 00:10:22,620
libraries and forces to have this all

00:10:20,230 --> 00:10:26,320
this sort of validation on the outside

00:10:22,620 --> 00:10:29,320
and okay this this will work but again

00:10:26,320 --> 00:10:31,780
you can if you forget to validate this

00:10:29,320 --> 00:10:35,700
stuff on the outside then it's very easy

00:10:31,780 --> 00:10:38,140
to end up with a customer object with

00:10:35,700 --> 00:10:40,630
that doesn't have a valid email address

00:10:38,140 --> 00:10:43,210
because somebody forgot to actually do

00:10:40,630 --> 00:10:44,620
this validation at some other place in

00:10:43,210 --> 00:10:46,840
the code especially if your system gets

00:10:44,620 --> 00:10:48,220
really big and many people work on it

00:10:46,840 --> 00:10:52,510
and they don't know what your guy is

00:10:48,220 --> 00:10:55,000
doing so okay let's let's write a test

00:10:52,510 --> 00:10:56,930
we want our customer to be consistent

00:10:55,000 --> 00:10:58,940
all the time

00:10:56,930 --> 00:11:02,240
so again customers should always have a

00:10:58,940 --> 00:11:03,500
valid email this time and if you've

00:11:02,240 --> 00:11:07,190
never used to be experienced you can

00:11:03,500 --> 00:11:09,290
actually tell phpunit that you expect

00:11:07,190 --> 00:11:11,510
that the code is following is going to

00:11:09,290 --> 00:11:14,600
throw a certain exact exception in this

00:11:11,510 --> 00:11:16,880
case an invalid argument exception so

00:11:14,600 --> 00:11:19,850
and we just make a new customer object

00:11:16,880 --> 00:11:22,790
with an malformed email and we expect

00:11:19,850 --> 00:11:26,269
this test to be green when the actual

00:11:22,790 --> 00:11:28,820
exception is being thrown so again we

00:11:26,269 --> 00:11:30,980
can put this logic inside our

00:11:28,820 --> 00:11:33,649
constructor to make sure it's impossible

00:11:30,980 --> 00:11:37,190
to make a customer object that has an

00:11:33,649 --> 00:11:40,760
invalid email address so this is this is

00:11:37,190 --> 00:11:42,529
very simple but there's one sort of

00:11:40,760 --> 00:11:46,760
problem that nags me with this

00:11:42,529 --> 00:11:49,040
we now have email validation inside of a

00:11:46,760 --> 00:11:51,320
customer object this is this smells

00:11:49,040 --> 00:11:53,660
terribly like like a violation of the

00:11:51,320 --> 00:11:58,750
single responsibility principle we don't

00:11:53,660 --> 00:12:02,540
want a customer to know how emails work

00:11:58,750 --> 00:12:05,480
so then so this again we are missing

00:12:02,540 --> 00:12:07,790
some sort of concept and it's actually

00:12:05,480 --> 00:12:10,430
quite simple we just turn email into an

00:12:07,790 --> 00:12:12,769
object as well so what is what is an

00:12:10,430 --> 00:12:15,140
object anyway it's it's an object

00:12:12,769 --> 00:12:18,110
oriented programming it's it's data and

00:12:15,140 --> 00:12:20,839
behavior encapsulate it together

00:12:18,110 --> 00:12:24,800
so if our email as simple as it may be

00:12:20,839 --> 00:12:27,860
is it has behavior the behavior that it

00:12:24,800 --> 00:12:29,329
has is being an email address and being

00:12:27,860 --> 00:12:33,230
an email address comes with certain

00:12:29,329 --> 00:12:35,690
rules so this is a like the simplest

00:12:33,230 --> 00:12:38,630
example of a value object that we can

00:12:35,690 --> 00:12:43,089
have and now that we have this email

00:12:38,630 --> 00:12:46,550
object we can simply have a customer

00:12:43,089 --> 00:12:49,190
have the constructor that type-ins for

00:12:46,550 --> 00:12:52,399
an email and now it's guaranteed well

00:12:49,190 --> 00:12:54,560
the customer here this object only knows

00:12:52,399 --> 00:12:56,769
that it's guaranteed to have an email

00:12:54,560 --> 00:12:59,300
object and the email object itself is

00:12:56,769 --> 00:13:01,550
guaranteed to contain a valid email

00:12:59,300 --> 00:13:05,089
address so these responsibilities are

00:13:01,550 --> 00:13:08,569
now nicely separated into each each

00:13:05,089 --> 00:13:09,339
object and this is very very powerful

00:13:08,569 --> 00:13:11,949
this is

00:13:09,339 --> 00:13:13,860
it's like really a friend of mine called

00:13:11,949 --> 00:13:16,360
value object the heart and soul of

00:13:13,860 --> 00:13:20,220
object-oriented programming and and I

00:13:16,360 --> 00:13:23,709
agree with this I feel the same way so

00:13:20,220 --> 00:13:27,009
if we run our tests now then we can

00:13:23,709 --> 00:13:29,230
actually see that you can make it the

00:13:27,009 --> 00:13:31,209
test still passes but the responsibility

00:13:29,230 --> 00:13:34,389
is in a different place simply because

00:13:31,209 --> 00:13:38,170
we refactor this responsibility out to

00:13:34,389 --> 00:13:39,639
the email object so it's kind of

00:13:38,170 --> 00:13:42,100
important to understand this difference

00:13:39,639 --> 00:13:44,529
and a customer and in our model here is

00:13:42,100 --> 00:13:46,569
an entity and you're probably familiar

00:13:44,529 --> 00:13:48,879
with them you use them all the time I

00:13:46,569 --> 00:13:51,399
think it's an entity is something that

00:13:48,879 --> 00:13:56,050
has an identity that has a lifecycle

00:13:51,399 --> 00:13:57,970
that changes over time so maybe you are

00:13:56,050 --> 00:14:01,029
you have a first name and you have a

00:13:57,970 --> 00:14:03,310
last name as a person even if for some

00:14:01,029 --> 00:14:05,649
reason your name changes you are still

00:14:03,310 --> 00:14:08,139
the same person if your address changes

00:14:05,649 --> 00:14:10,930
you are still the same person and the

00:14:08,139 --> 00:14:13,019
way we deal with this because we cannot

00:14:10,930 --> 00:14:18,459
compare by value is we compare by

00:14:13,019 --> 00:14:21,430
identity we take a key and identity and

00:14:18,459 --> 00:14:25,720
an ID field and use this to you know

00:14:21,430 --> 00:14:28,750
find the representation of this customer

00:14:25,720 --> 00:14:31,480
or this person in an or storage and to

00:14:28,750 --> 00:14:34,180
talk between systems so if you are you

00:14:31,480 --> 00:14:36,730
know customer number five no matter how

00:14:34,180 --> 00:14:39,389
much you change no matter how much your

00:14:36,730 --> 00:14:42,130
state changes you are still the same

00:14:39,389 --> 00:14:45,339
customer so that's what it means to be

00:14:42,130 --> 00:14:49,990
an entity a value object on the other

00:14:45,339 --> 00:14:54,279
hand it's it has no ID if I make two

00:14:49,990 --> 00:14:57,279
value objects and to email objects and

00:14:54,279 --> 00:14:58,779
one is modules at France on that the

00:14:57,279 --> 00:15:01,449
other one is much as at France or net

00:14:58,779 --> 00:15:03,459
they may be different instances but it

00:15:01,449 --> 00:15:10,360
doesn't matter they are equal because

00:15:03,459 --> 00:15:13,899
their values are equal and a good way to

00:15:10,360 --> 00:15:16,990
build value objects is to make them

00:15:13,899 --> 00:15:19,649
immutable maybe you notice that my email

00:15:16,990 --> 00:15:23,500
object the ratio before has no setter

00:15:19,649 --> 00:15:25,480
because you don't want to change that it

00:15:23,500 --> 00:15:27,699
has no life cycle it doesn't evolve over

00:15:25,480 --> 00:15:30,759
time if you need a new email address you

00:15:27,699 --> 00:15:34,569
just make a new email value object with

00:15:30,759 --> 00:15:39,809
a new email inside of it and it's a you

00:15:34,569 --> 00:15:42,790
don't mute mutate an existing one so

00:15:39,809 --> 00:15:45,939
important to remember here it's again

00:15:42,790 --> 00:15:49,899
encapsulation state and behavior that

00:15:45,939 --> 00:15:52,569
belong together that express a certain

00:15:49,899 --> 00:15:56,500
value you want to you want to

00:15:52,569 --> 00:15:58,720
encapsulate that in a value object so

00:15:56,500 --> 00:16:02,880
and maybe some other examples for value

00:15:58,720 --> 00:16:05,860
objects things like measurements

00:16:02,880 --> 00:16:09,069
distances like one meter would be a

00:16:05,860 --> 00:16:12,610
value object they can have more than one

00:16:09,069 --> 00:16:16,120
value one meter has two values it has

00:16:12,610 --> 00:16:21,069
the one and it has the meters it has the

00:16:16,120 --> 00:16:24,339
the type of distance a date/time is a

00:16:21,069 --> 00:16:26,470
good example but the one in PHP is

00:16:24,339 --> 00:16:28,959
actually not a good value object because

00:16:26,470 --> 00:16:30,819
it's mutable and I think in PHP five

00:16:28,959 --> 00:16:33,429
five there's now in a day time

00:16:30,819 --> 00:16:36,160
underscore immutable so that that's a

00:16:33,429 --> 00:16:37,899
better example and you can you can

00:16:36,160 --> 00:16:40,449
combine them like a date range is

00:16:37,899 --> 00:16:44,170
perfect candidate for a value object

00:16:40,449 --> 00:16:47,259
because it has behavior it has a like a

00:16:44,170 --> 00:16:49,839
date range cannot be from today until

00:16:47,259 --> 00:16:52,959
yesterday it's always from today till

00:16:49,839 --> 00:16:57,370
tomorrow some like that so to protect

00:16:52,959 --> 00:16:59,800
this rule about date ranges cannot be

00:16:57,370 --> 00:17:02,410
negative you put this in this state

00:16:59,800 --> 00:17:04,510
range value object and it's very easy to

00:17:02,410 --> 00:17:08,110
reason about your system then because

00:17:04,510 --> 00:17:10,659
you don't have to protect this this rule

00:17:08,110 --> 00:17:13,990
all the time if you simply say okay I

00:17:10,659 --> 00:17:17,620
type int for a date range object and you

00:17:13,990 --> 00:17:20,110
know it's always going to be valid am I

00:17:17,620 --> 00:17:21,690
still making sense oh I think there's a

00:17:20,110 --> 00:17:25,460
question there in the middle

00:17:21,690 --> 00:17:25,460
okay can you wait for the microphone

00:17:32,970 --> 00:17:39,539
what happens if you want to have

00:17:35,520 --> 00:17:41,970
validation over multiple value objects

00:17:39,539 --> 00:17:45,090
like collection where would you put that

00:17:41,970 --> 00:17:48,210
validation do you have an example so say

00:17:45,090 --> 00:17:51,179
if you had more than one email address

00:17:48,210 --> 00:17:54,080
and that's such a bad example each I

00:17:51,179 --> 00:17:57,270
have a minimum of two email addresses so

00:17:54,080 --> 00:17:58,860
you've each email was immutable and will

00:17:57,270 --> 00:18:01,470
happen as a value object which will have

00:17:58,860 --> 00:18:05,760
its the email address will be validated

00:18:01,470 --> 00:18:09,270
but in the person class the parent class

00:18:05,760 --> 00:18:10,289
would would you put the validation in

00:18:09,270 --> 00:18:12,090
there to say you've got to have a

00:18:10,289 --> 00:18:13,799
minimum of two here if you need it

00:18:12,090 --> 00:18:16,470
somewhere else on a company and you

00:18:13,799 --> 00:18:19,440
needed more than two email addresses

00:18:16,470 --> 00:18:21,059
again yeah well it depends of course on

00:18:19,440 --> 00:18:23,789
the the problem you're trying to solve

00:18:21,059 --> 00:18:26,220
but if if the rule is simply a customer

00:18:23,789 --> 00:18:29,909
must have two email addresses then you

00:18:26,220 --> 00:18:32,520
can simply check if the array of email

00:18:29,909 --> 00:18:36,630
address objects that you inject are is

00:18:32,520 --> 00:18:40,080
at least two items but if this concept

00:18:36,630 --> 00:18:40,470
is like more than a simple rule like

00:18:40,080 --> 00:18:43,289
that

00:18:40,470 --> 00:18:45,150
then you probably want to make a new

00:18:43,289 --> 00:18:47,640
value object that is a composite of

00:18:45,150 --> 00:18:49,799
other value objects it could be well

00:18:47,640 --> 00:18:52,950
it's not a really interesting exact

00:18:49,799 --> 00:18:55,230
button could be an email collection kind

00:18:52,950 --> 00:18:58,470
of thing just just the same way that a

00:18:55,230 --> 00:19:01,770
date range is composed of two date/time

00:18:58,470 --> 00:19:06,720
value objects so it's it's a composite

00:19:01,770 --> 00:19:09,270
it has rules that that are over that

00:19:06,720 --> 00:19:11,669
that are above these two data objects so

00:19:09,270 --> 00:19:13,740
the date/time object itself has some

00:19:11,669 --> 00:19:15,030
rules about what is a valid date but the

00:19:13,740 --> 00:19:19,679
combination of the two has some

00:19:15,030 --> 00:19:23,340
different rules I'm not sure if I can

00:19:19,679 --> 00:19:26,610
come up with some other examples but I

00:19:23,340 --> 00:19:29,940
does that answer your question it does

00:19:26,610 --> 00:19:31,860
yes okay great so other other examples

00:19:29,940 --> 00:19:35,070
of value objects are things like money

00:19:31,860 --> 00:19:37,710
for example it's it's you know five

00:19:35,070 --> 00:19:39,710
euros is five plus two currency you

00:19:37,710 --> 00:19:42,390
cannot separate these things you cannot

00:19:39,710 --> 00:19:46,350
think about money and only think about

00:19:42,390 --> 00:19:48,480
the five without knowing

00:19:46,350 --> 00:19:50,730
that it's euros and actually the Euro

00:19:48,480 --> 00:19:52,590
could be a currency object again which

00:19:50,730 --> 00:19:55,140
also has rules about what is a valid

00:19:52,590 --> 00:19:58,289
currency so you can you combine these

00:19:55,140 --> 00:20:00,900
things and a good way to actually model

00:19:58,289 --> 00:20:02,760
your system is to model as everything

00:20:00,900 --> 00:20:04,860
has value objects first even customers

00:20:02,760 --> 00:20:07,429
and orders and all these things and then

00:20:04,860 --> 00:20:10,200
if you find out that you actually need

00:20:07,429 --> 00:20:14,340
identities then you turn these value

00:20:10,200 --> 00:20:16,950
objects into into entities okay let's

00:20:14,340 --> 00:20:19,169
let's move on let's do some more

00:20:16,950 --> 00:20:21,419
interesting things we we are building an

00:20:19,169 --> 00:20:23,159
e-commerce system and this is the core

00:20:21,419 --> 00:20:26,250
business model its customer orders

00:20:23,159 --> 00:20:27,929
products and base for them hopefully

00:20:26,250 --> 00:20:31,049
because we wouldn't have much of a

00:20:27,929 --> 00:20:34,590
business and so let's take some like

00:20:31,049 --> 00:20:38,070
traditional getter setter code and try

00:20:34,590 --> 00:20:40,950
to refactor this so here this is older

00:20:38,070 --> 00:20:43,110
older logic is on the outside in this

00:20:40,950 --> 00:20:46,320
example we have an order we have to set

00:20:43,110 --> 00:20:48,870
a customer set product sets status and

00:20:46,320 --> 00:20:51,210
then maybe a little bit later the

00:20:48,870 --> 00:20:53,070
customer pays for the order so we have

00:20:51,210 --> 00:20:57,179
to set a paid amount set the paid

00:20:53,070 --> 00:20:58,950
currency set the status to paid if you

00:20:57,179 --> 00:21:00,900
actually read this to to your domain

00:20:58,950 --> 00:21:02,490
expert so your domain expert says a

00:21:00,900 --> 00:21:05,070
customer orders products and pays for

00:21:02,490 --> 00:21:08,429
them and we say oh you mean that you

00:21:05,070 --> 00:21:10,890
know we have to set customer on order

00:21:08,429 --> 00:21:13,500
object and set products on they don't

00:21:10,890 --> 00:21:16,830
understand this is what we want is to

00:21:13,500 --> 00:21:20,549
get closer to the to the actual domain

00:21:16,830 --> 00:21:23,179
language and try to make our code almost

00:21:20,549 --> 00:21:28,020
readable for our for our domain experts

00:21:23,179 --> 00:21:31,140
so let's refactor payment status a great

00:21:28,020 --> 00:21:33,960
way to it it's a value object it's very

00:21:31,140 --> 00:21:36,659
simple it has some possibilities but the

00:21:33,960 --> 00:21:39,150
the validation is inside the payment

00:21:36,659 --> 00:21:40,860
status object itself it knows which are

00:21:39,150 --> 00:21:42,809
valid States and everything else is is

00:21:40,860 --> 00:21:47,100
invalid so now it's already impossible

00:21:42,809 --> 00:21:49,200
to to inject a misspelled string in here

00:21:47,100 --> 00:21:51,929
because it's the payment status value

00:21:49,200 --> 00:21:55,020
object that is going to protect this so

00:21:51,929 --> 00:21:56,909
this is a good first step what else can

00:21:55,020 --> 00:21:59,230
we do we already I already mentioned the

00:21:56,909 --> 00:22:02,980
money value object

00:21:59,230 --> 00:22:05,230
instead of saying you know set paid man

00:22:02,980 --> 00:22:07,540
set currency then you can still make

00:22:05,230 --> 00:22:11,230
mistakes on the outside here you cannot

00:22:07,540 --> 00:22:15,429
you can only insert a valid consistent

00:22:11,230 --> 00:22:17,530
money object what else we can instead of

00:22:15,429 --> 00:22:20,350
doing all these setters on this order

00:22:17,530 --> 00:22:23,559
object on the outside we agree that an

00:22:20,350 --> 00:22:25,900
order is always for a customer and a

00:22:23,559 --> 00:22:28,240
bunch of products again this is a

00:22:25,900 --> 00:22:30,880
simplified example but you get a point

00:22:28,240 --> 00:22:33,130
and instead of doing this status on the

00:22:30,880 --> 00:22:35,140
outside we know that a new order is

00:22:33,130 --> 00:22:37,030
always going to be unpaid from the start

00:22:35,140 --> 00:22:39,280
so we just put this inside the

00:22:37,030 --> 00:22:41,730
constructor so this rule is now also

00:22:39,280 --> 00:22:44,470
encapsulated in the in the order object

00:22:41,730 --> 00:22:48,580
and we can do the same thing for paying

00:22:44,470 --> 00:22:54,520
if you pay for an order then you know

00:22:48,580 --> 00:22:59,049
the status changes to paid optically so

00:22:54,520 --> 00:23:03,160
we want to encapsulate operations when

00:22:59,049 --> 00:23:05,890
when you need to do stuff to an entity

00:23:03,160 --> 00:23:07,660
that you know changes it or that evolves

00:23:05,890 --> 00:23:09,190
it through its lifecycle we want to

00:23:07,660 --> 00:23:13,169
encapsulate the logic that is behind

00:23:09,190 --> 00:23:15,640
that so if you read this now - and

00:23:13,169 --> 00:23:17,740
domain expert it's a lot closer to

00:23:15,640 --> 00:23:19,330
something they understand we're not

00:23:17,740 --> 00:23:22,990
quite there yet we can actually I have

00:23:19,330 --> 00:23:25,360
another bonus points right if you really

00:23:22,990 --> 00:23:26,799
want to get closer to the language you

00:23:25,360 --> 00:23:30,010
could do something like this a customer

00:23:26,799 --> 00:23:34,030
orders product and a customer pays for

00:23:30,010 --> 00:23:36,040
an order this is I think this is as

00:23:34,030 --> 00:23:38,770
close as you can get with PHP to

00:23:36,040 --> 00:23:43,630
expressing something in in the actual

00:23:38,770 --> 00:23:46,080
domain language but careful with this

00:23:43,630 --> 00:23:51,460
example what we've done now is we've

00:23:46,080 --> 00:23:54,150
coupled the customer object to the order

00:23:51,460 --> 00:23:56,710
object in the other direction as well

00:23:54,150 --> 00:23:59,020
because now a customer has to know about

00:23:56,710 --> 00:24:01,720
a customer object has to know about how

00:23:59,020 --> 00:24:03,820
paying works and about how orders work

00:24:01,720 --> 00:24:06,070
and even though it delegates it still

00:24:03,820 --> 00:24:09,909
delegates this responsibility to the

00:24:06,070 --> 00:24:12,830
actual order object so in the back of it

00:24:09,909 --> 00:24:14,960
we would still have this but we've

00:24:12,830 --> 00:24:16,970
you know added some responsibility to

00:24:14,960 --> 00:24:19,460
the customer object so be careful with

00:24:16,970 --> 00:24:22,399
this if you have this in like a small

00:24:19,460 --> 00:24:25,850
compact contains thing you can you can

00:24:22,399 --> 00:24:28,519
do this kind of coding but if you are

00:24:25,850 --> 00:24:29,899
going to make a big system and couple

00:24:28,519 --> 00:24:34,309
everything to everything you're going to

00:24:29,899 --> 00:24:36,559
get in trouble so our domain expert

00:24:34,309 --> 00:24:39,169
comes back he says yeah we have some new

00:24:36,559 --> 00:24:42,679
features that we want we want to treat

00:24:39,169 --> 00:24:45,769
our premium customers with some extra

00:24:42,679 --> 00:24:48,350
care premium customers get special

00:24:45,769 --> 00:24:50,139
offers and ok we are maybe a little bit

00:24:48,350 --> 00:24:53,389
naive in the beginning and we just had a

00:24:50,139 --> 00:24:56,720
boolean flag saying it's premium to the

00:24:53,389 --> 00:24:59,240
customer and use that as a but no

00:24:56,720 --> 00:25:01,580
manager said no no no no there's rules

00:24:59,240 --> 00:25:04,100
for this you have to order at least

00:25:01,580 --> 00:25:06,950
three times to become a premium customer

00:25:04,100 --> 00:25:09,409
we don't want to set this status field

00:25:06,950 --> 00:25:11,480
automatically or manually ourselves we

00:25:09,409 --> 00:25:15,830
want the system to take care of this for

00:25:11,480 --> 00:25:19,220
us so ok we have this business rule

00:25:15,830 --> 00:25:21,590
where do we put this do we put this

00:25:19,220 --> 00:25:24,320
inside the customer then we create more

00:25:21,590 --> 00:25:26,179
coupling do we put this inside the order

00:25:24,320 --> 00:25:30,049
well no because the order doesn't know

00:25:26,179 --> 00:25:31,960
that there's two more orders so if we

00:25:30,049 --> 00:25:35,299
have these business rules that are

00:25:31,960 --> 00:25:38,210
bridging across multiple entities then

00:25:35,299 --> 00:25:40,880
we will have to do it on the outside but

00:25:38,210 --> 00:25:44,779
we still want to encapsulate them so we

00:25:40,880 --> 00:25:47,450
can make this very explicit this is the

00:25:44,779 --> 00:25:50,210
specification pattern it's cold it's

00:25:47,450 --> 00:25:52,639
very simple it has a very easy to

00:25:50,210 --> 00:25:56,299
understand interface it has an S

00:25:52,639 --> 00:25:58,399
satisfied by method it takes a customer

00:25:56,299 --> 00:26:01,669
as an argument and it returns a true or

00:25:58,399 --> 00:26:04,250
false so this is a business rule but

00:26:01,669 --> 00:26:05,480
it's nicely encapsulated in the

00:26:04,250 --> 00:26:07,669
specification and it would look like

00:26:05,480 --> 00:26:10,429
this if you were to implement this for

00:26:07,669 --> 00:26:12,980
our customers premium rule maybe you

00:26:10,429 --> 00:26:15,350
would inject an order repository you can

00:26:12,980 --> 00:26:19,070
use dependency injection if you saw a

00:26:15,350 --> 00:26:21,020
staff on stock before and you just ask

00:26:19,070 --> 00:26:25,890
this question is satisfied by a customer

00:26:21,020 --> 00:26:28,890
and on the inside it knows how to how to

00:26:25,890 --> 00:26:31,320
find out how to how this rule is defined

00:26:28,890 --> 00:26:34,170
and only outside you just say customers

00:26:31,320 --> 00:26:36,270
premium is satisfied by customer object

00:26:34,170 --> 00:26:38,430
and in this case we will send the

00:26:36,270 --> 00:26:42,270
special order if you can see it in the

00:26:38,430 --> 00:26:44,700
back probably not but so it just says if

00:26:42,270 --> 00:26:49,110
customer is premium is satisfied by

00:26:44,700 --> 00:26:50,850
customer sent a special offer and you

00:26:49,110 --> 00:26:53,760
know as I'm reading this out loud you

00:26:50,850 --> 00:26:56,610
can hear that this is quite close to to

00:26:53,760 --> 00:27:01,380
the business again to the language of

00:26:56,610 --> 00:27:02,910
the business and one benefit of course

00:27:01,380 --> 00:27:05,820
is because this business rule is

00:27:02,910 --> 00:27:07,890
encapsulated if it changes then we can

00:27:05,820 --> 00:27:10,050
simply change this rule in one place and

00:27:07,890 --> 00:27:12,930
maybe there's twenty other places that

00:27:10,050 --> 00:27:14,430
use this rule but they don't know how it

00:27:12,930 --> 00:27:16,050
works on the inside all they know is

00:27:14,430 --> 00:27:20,360
that it's you know a specification

00:27:16,050 --> 00:27:20,360
object within is satisfied by method

00:27:20,720 --> 00:27:31,070
okay so and another nice thing about

00:27:25,530 --> 00:27:31,070
this is that we can very easily test it

00:27:32,540 --> 00:27:38,580
it's just boolean so all we need to do

00:27:36,210 --> 00:27:41,400
is bring our system or our customer

00:27:38,580 --> 00:27:43,730
object in a certain state and our orders

00:27:41,400 --> 00:27:47,130
in certain state put this in our

00:27:43,730 --> 00:27:49,290
repository somehow and then we can test

00:27:47,130 --> 00:27:53,100
it we can just do some assertions assert

00:27:49,290 --> 00:27:56,100
false for a customer who only has two

00:27:53,100 --> 00:28:02,610
orders and assert true for a customer as

00:27:56,100 --> 00:28:05,970
who has at least I might still making

00:28:02,610 --> 00:28:08,850
sense is this is anybody doing this sort

00:28:05,970 --> 00:28:14,460
of stuff okay

00:28:08,850 --> 00:28:17,010
some people great so it gets more

00:28:14,460 --> 00:28:19,230
interesting because once again our

00:28:17,010 --> 00:28:22,260
domain expert comes back and says he has

00:28:19,230 --> 00:28:24,090
whole thing is working really well but

00:28:22,260 --> 00:28:26,520
we've signed up some new clients maybe

00:28:24,090 --> 00:28:28,560
we have you know Amazon and well

00:28:26,520 --> 00:28:33,620
probably not Amazon but we have we have

00:28:28,560 --> 00:28:36,420
like 10 new shops for this two different

00:28:33,620 --> 00:28:39,450
companies and they all have these

00:28:36,420 --> 00:28:42,149
different rules about what makes

00:28:39,450 --> 00:28:44,429
premium customer so we can actually

00:28:42,149 --> 00:28:47,729
still we don't we don't want to touch

00:28:44,429 --> 00:28:52,259
our original system and this is the

00:28:47,729 --> 00:28:55,559
benefit of encapsulation if you if IDs

00:28:52,259 --> 00:28:57,119
and concepts and rules are encapsulated

00:28:55,559 --> 00:29:00,469
then you only have to change them in in

00:28:57,119 --> 00:29:03,149
one place and this is this is basically

00:29:00,469 --> 00:29:05,839
what dry means a lot of people think

00:29:03,149 --> 00:29:08,820
that dry is about code duplication or

00:29:05,839 --> 00:29:11,579
data duplication but it is in fact about

00:29:08,820 --> 00:29:13,950
knowledge it's about single source of

00:29:11,579 --> 00:29:15,869
truth there is only a single source of

00:29:13,950 --> 00:29:18,690
truth in our previous version of what

00:29:15,869 --> 00:29:20,149
makes a customer premium now that we

00:29:18,690 --> 00:29:23,339
have different rules there are still

00:29:20,149 --> 00:29:27,359
single sources of truth for each

00:29:23,339 --> 00:29:29,519
different rule so here as you can see I

00:29:27,359 --> 00:29:32,940
have I turned the customers premium

00:29:29,519 --> 00:29:36,359
which used to be a class I turn it into

00:29:32,940 --> 00:29:39,089
another interface so our code that used

00:29:36,359 --> 00:29:41,759
to depend on the customer is premium

00:29:39,089 --> 00:29:43,709
object still depends on customers

00:29:41,759 --> 00:29:46,609
premium it doesn't know what kind of

00:29:43,709 --> 00:29:50,129
customer is premium object it's getting

00:29:46,609 --> 00:29:52,279
but it doesn't care as long as it's an

00:29:50,129 --> 00:29:56,159
object with an S satisfied by method

00:29:52,279 --> 00:30:01,559
then it knows that it's it's a can

00:29:56,159 --> 00:30:03,719
answer this question for them so I have

00:30:01,559 --> 00:30:05,700
some examples maybe for one client we

00:30:03,719 --> 00:30:08,609
have customer with three orders this

00:30:05,700 --> 00:30:12,239
premium for another customer with 500

00:30:08,609 --> 00:30:14,070
euro to total as a premium maybe we have

00:30:12,239 --> 00:30:16,940
a third one a customer who bought luxury

00:30:14,070 --> 00:30:18,739
products is premium and the

00:30:16,940 --> 00:30:20,999
implementations of all these

00:30:18,739 --> 00:30:23,339
specifications is going to be completely

00:30:20,999 --> 00:30:25,739
different one is maybe going to use the

00:30:23,339 --> 00:30:28,349
order repository and another one is

00:30:25,739 --> 00:30:31,349
maybe going to use some external service

00:30:28,349 --> 00:30:35,339
and talk to some maybe to some database

00:30:31,349 --> 00:30:39,659
from third party system or some API

00:30:35,339 --> 00:30:42,929
where it can ask these questions and so

00:30:39,659 --> 00:30:45,479
it doesn't matter what technology or

00:30:42,929 --> 00:30:48,690
system or or source of truth is behind

00:30:45,479 --> 00:30:52,320
it to our existing code it's still the

00:30:48,690 --> 00:30:55,169
same thing it's just customers premium

00:30:52,320 --> 00:30:56,669
and this is what it could look like in

00:30:55,169 --> 00:30:59,820
our client code if we have a like a

00:30:56,669 --> 00:31:03,899
special offer sender or something it

00:30:59,820 --> 00:31:06,990
knows to send offers to a customer if

00:31:03,899 --> 00:31:12,450
the customer is premium specification is

00:31:06,990 --> 00:31:14,669
satisfied by this customer still making

00:31:12,450 --> 00:31:19,740
sense I hope yes great

00:31:14,669 --> 00:31:22,159
I like you guys and I have a bit of an

00:31:19,740 --> 00:31:25,889
example of how you would do this with

00:31:22,159 --> 00:31:29,309
dependency injection in Symphony the

00:31:25,889 --> 00:31:32,370
same ID applies to any other dependency

00:31:29,309 --> 00:31:36,659
injection library that you use basically

00:31:32,370 --> 00:31:38,759
you configure for different so I used

00:31:36,659 --> 00:31:41,220
Amazon as an example here and eBay but I

00:31:38,759 --> 00:31:45,000
doubt they would use or simple system at

00:31:41,220 --> 00:31:48,570
this point but so the idea is the same

00:31:45,000 --> 00:31:50,370
and we load depending on you know the

00:31:48,570 --> 00:31:54,509
customer or the tenant string that is

00:31:50,370 --> 00:31:57,259
somewhere in our system we will create a

00:31:54,509 --> 00:32:02,039
different object but we give it the same

00:31:57,259 --> 00:32:04,590
key in our di so again on the outside

00:32:02,039 --> 00:32:06,480
and elsewhere in the system we would

00:32:04,590 --> 00:32:09,809
have maybe did a special offer center

00:32:06,480 --> 00:32:12,450
and it knows that it wants it needs a

00:32:09,809 --> 00:32:13,919
service called customers premium but it

00:32:12,450 --> 00:32:15,919
doesn't know which of these two it's

00:32:13,919 --> 00:32:18,090
getting so we don't have to check

00:32:15,919 --> 00:32:23,039
configuration everywhere in our system

00:32:18,090 --> 00:32:24,840
and like if tenant equals Amazon then we

00:32:23,039 --> 00:32:28,080
apply this rule and if tenant equals

00:32:24,840 --> 00:32:30,620
ebay we applied that rule it's all in

00:32:28,080 --> 00:32:32,879
one place that's isolated we can easily

00:32:30,620 --> 00:32:36,750
reconfigure it we can even make it more

00:32:32,879 --> 00:32:38,870
dynamic if we need to for some reason so

00:32:36,750 --> 00:32:41,429
what I want you to remember is to use

00:32:38,870 --> 00:32:44,669
these specifications as a way to

00:32:41,429 --> 00:32:47,429
encapsulate business rules about object

00:32:44,669 --> 00:32:50,340
selection it's not the only way of

00:32:47,429 --> 00:32:52,620
course there's this many ways to skin a

00:32:50,340 --> 00:32:54,149
cat but for me this has been working

00:32:52,620 --> 00:32:58,259
quite well I've actually used this for

00:32:54,149 --> 00:33:01,909
things like deciding on on you know

00:32:58,259 --> 00:33:05,250
permissions can this user access this

00:33:01,909 --> 00:33:06,090
particular thing for example it's nice

00:33:05,250 --> 00:33:10,620
to put it in

00:33:06,090 --> 00:33:13,110
in a separate object but of course our

00:33:10,620 --> 00:33:15,720
domain expert comes back and he says

00:33:13,110 --> 00:33:19,320
well this is nice we're making money of

00:33:15,720 --> 00:33:21,210
this new feature but we're kind of

00:33:19,320 --> 00:33:23,490
losing track we are growing and we don't

00:33:21,210 --> 00:33:25,320
know how many premium customers we

00:33:23,490 --> 00:33:27,120
actually have and how many you know a

00:33:25,320 --> 00:33:29,220
special offers we are sending them so

00:33:27,120 --> 00:33:33,720
can you just make me a list of all the

00:33:29,220 --> 00:33:35,360
premium customers and well before we do

00:33:33,720 --> 00:33:37,440
this we need to get into what is

00:33:35,360 --> 00:33:40,980
repository we haven't really covered

00:33:37,440 --> 00:33:46,530
that there's two ways of looking at the

00:33:40,980 --> 00:33:50,330
repository most libraries I've seen have

00:33:46,530 --> 00:33:53,280
a repository is something that is

00:33:50,330 --> 00:33:54,630
persistence oriented so what is a

00:33:53,280 --> 00:33:57,660
repository it's something that takes

00:33:54,630 --> 00:34:00,120
care of putting an object in a database

00:33:57,660 --> 00:34:03,990
for you and getting objects out of that

00:34:00,120 --> 00:34:07,220
database for you and this is fine as a

00:34:03,990 --> 00:34:10,680
way of looking at this but it's a very

00:34:07,220 --> 00:34:12,660
it's kind of a limited way of looking at

00:34:10,680 --> 00:34:15,350
this problem it's again it's structural

00:34:12,660 --> 00:34:19,430
thinking it's data centric thinking its

00:34:15,350 --> 00:34:21,990
persistence centric thinking the

00:34:19,430 --> 00:34:25,650
approach that I like more as a

00:34:21,990 --> 00:34:27,390
collection oriented repositories so if

00:34:25,650 --> 00:34:30,870
you look at this interface that these

00:34:27,390 --> 00:34:33,900
these methods that the customer

00:34:30,870 --> 00:34:37,020
repository defines add remove find find

00:34:33,900 --> 00:34:39,900
all find registered in year this kind of

00:34:37,020 --> 00:34:41,970
thing these are methods that work just

00:34:39,900 --> 00:34:44,280
as well on a collection if this was an

00:34:41,970 --> 00:34:45,630
in-memory collection the interface would

00:34:44,280 --> 00:34:47,460
look exactly the same

00:34:45,630 --> 00:34:49,710
you would never write an in-memory

00:34:47,460 --> 00:34:53,910
collection object and have methods like

00:34:49,710 --> 00:34:58,350
persist on there or safe or stuff like

00:34:53,910 --> 00:35:01,350
that so this this interface doesn't

00:34:58,350 --> 00:35:03,600
betray that in the background it's maybe

00:35:01,350 --> 00:35:07,050
saving these customer objects to a

00:35:03,600 --> 00:35:08,460
database and the nice thing of having an

00:35:07,050 --> 00:35:11,700
interface like this is that you can

00:35:08,460 --> 00:35:14,840
replace this interface or implement this

00:35:11,700 --> 00:35:17,460
interface with an in-memory collection

00:35:14,840 --> 00:35:19,140
which is very nice for a unit test

00:35:17,460 --> 00:35:19,930
because then you don't have to talk to

00:35:19,140 --> 00:35:22,180
your database

00:35:19,930 --> 00:35:24,940
you can implement it with a you know

00:35:22,180 --> 00:35:29,260
maybe a doctrine customer repository or

00:35:24,940 --> 00:35:31,059
or a PTO customer repository or maybe a

00:35:29,260 --> 00:35:34,660
 customer repository things like

00:35:31,059 --> 00:35:36,579
that so but your client code is still

00:35:34,660 --> 00:35:40,020
going to think it's just a customer

00:35:36,579 --> 00:35:44,800
repository with some collection style

00:35:40,020 --> 00:35:48,490
methods so we create the illusion of an

00:35:44,800 --> 00:35:51,010
in-memory collection even though in in

00:35:48,490 --> 00:35:57,089
the background it's actually persisting

00:35:51,010 --> 00:36:00,190
to database so this is what I just said

00:35:57,089 --> 00:36:02,470
ok so we have our if you remember we

00:36:00,190 --> 00:36:04,960
need to make this this list of premium

00:36:02,470 --> 00:36:08,710
customers we have a customer repository

00:36:04,960 --> 00:36:11,800
we already have this specification so

00:36:08,710 --> 00:36:13,990
it's actually quite easy we just tell

00:36:11,800 --> 00:36:15,760
our customer or add a new method to our

00:36:13,990 --> 00:36:19,839
customer repository saying find

00:36:15,760 --> 00:36:24,670
satisfying using this customer

00:36:19,839 --> 00:36:26,910
specification so if you implement this

00:36:24,670 --> 00:36:30,099
and this is a very naive implementation

00:36:26,910 --> 00:36:32,530
then we say maybe the database customer

00:36:30,099 --> 00:36:35,170
repository finds satisfying the customer

00:36:32,530 --> 00:36:37,349
specification it will loop over all the

00:36:35,170 --> 00:36:40,569
customers and check for each of them if

00:36:37,349 --> 00:36:43,930
the specification the business rule is

00:36:40,569 --> 00:36:46,329
satisfied by this particular customer

00:36:43,930 --> 00:36:49,140
object you could do this with if you're

00:36:46,329 --> 00:36:51,670
not familiar with the array filter

00:36:49,140 --> 00:36:53,200
function you could just as well do this

00:36:51,670 --> 00:36:55,359
with it for each and just put all the

00:36:53,200 --> 00:36:57,670
customers that where the specification

00:36:55,359 --> 00:37:02,799
returns true put them in a new array and

00:36:57,670 --> 00:37:04,900
return that so it's the same thing so

00:37:02,799 --> 00:37:07,809
this is this works really nice

00:37:04,900 --> 00:37:12,490
we now have enforced or business rule

00:37:07,809 --> 00:37:14,609
using our specification so we still have

00:37:12,490 --> 00:37:16,510
this knowledge in one place this

00:37:14,609 --> 00:37:19,990
understanding of how this business rule

00:37:16,510 --> 00:37:21,460
works but of course it's if you have a

00:37:19,990 --> 00:37:24,970
lot of customers in your database this

00:37:21,460 --> 00:37:27,010
is not going to be very efficient what

00:37:24,970 --> 00:37:30,510
we actually want is to do a you know

00:37:27,010 --> 00:37:34,050
proper database query

00:37:30,510 --> 00:37:37,620
so one way to look at this is that you

00:37:34,050 --> 00:37:40,260
know the query could the query could be

00:37:37,620 --> 00:37:41,310
quite simple if the rule is just having

00:37:40,260 --> 00:37:43,890
three orders then you would have

00:37:41,310 --> 00:37:47,370
something like select from customers

00:37:43,890 --> 00:37:49,890
where and you join with the orders table

00:37:47,370 --> 00:37:53,910
and you do account and you check if the

00:37:49,890 --> 00:37:57,060
count is three or more but where to put

00:37:53,910 --> 00:38:00,600
this so one way of looking at this is

00:37:57,060 --> 00:38:03,510
that this query that we just wrote is a

00:38:00,600 --> 00:38:05,310
different representation of the same

00:38:03,510 --> 00:38:08,930
business rule that we wrote in code

00:38:05,310 --> 00:38:12,750
before so a good way of doing that is to

00:38:08,930 --> 00:38:14,430
just put this together there is a

00:38:12,750 --> 00:38:18,960
downside of course because now we have

00:38:14,430 --> 00:38:22,140
SQL in this specification object but the

00:38:18,960 --> 00:38:26,760
upside is that our two representations

00:38:22,140 --> 00:38:29,730
of the same business rule are now you

00:38:26,760 --> 00:38:32,550
know co-located in one in one class so

00:38:29,730 --> 00:38:35,240
if one of them changes we can go back

00:38:32,550 --> 00:38:39,300
and and change the other one as well so

00:38:35,240 --> 00:38:41,340
how do how to read this it's a it's this

00:38:39,300 --> 00:38:46,170
customer would reorder this premium

00:38:41,340 --> 00:38:50,370
object you can now like cost it to a

00:38:46,170 --> 00:38:52,890
query and the way it works on in the

00:38:50,370 --> 00:38:55,140
repository is that this find satisfying

00:38:52,890 --> 00:38:58,440
method that we did earlier with the

00:38:55,140 --> 00:39:01,800
naive array filter it now queries using

00:38:58,440 --> 00:39:03,900
the query the SQL representation of this

00:39:01,800 --> 00:39:06,900
specification object of this business

00:39:03,900 --> 00:39:10,350
rule and it could be SQL it could be dql

00:39:06,900 --> 00:39:13,710
if you use doctrine could be something

00:39:10,350 --> 00:39:17,790
else this is called double dispatch

00:39:13,710 --> 00:39:19,650
because on the outside we we tell the

00:39:17,790 --> 00:39:22,440
repository give us all the customers

00:39:19,650 --> 00:39:24,510
satisfying their specification and on

00:39:22,440 --> 00:39:25,910
the inside the repository says ok

00:39:24,510 --> 00:39:28,800
specification give me your

00:39:25,910 --> 00:39:32,700
representation in SQL and I will use

00:39:28,800 --> 00:39:38,910
that to query to database still making

00:39:32,700 --> 00:39:41,640
sense yes awesome so there if you want

00:39:38,910 --> 00:39:43,920
to get rid of this having this query and

00:39:41,640 --> 00:39:47,220
this this code

00:39:43,920 --> 00:39:49,920
version of the same business rule in in

00:39:47,220 --> 00:39:52,230
this specification object there's ways

00:39:49,920 --> 00:39:54,330
around that but I don't think they are

00:39:52,230 --> 00:39:56,880
very interesting or very useful because

00:39:54,330 --> 00:39:59,370
for me something like this is working

00:39:56,880 --> 00:40:02,250
quite well it's not perfect but it's

00:39:59,370 --> 00:40:05,430
it's it's nice it's encapsulated it's

00:40:02,250 --> 00:40:07,710
easy to understand please oh wait we

00:40:05,430 --> 00:40:17,310
need a microphone because the talk is

00:40:07,710 --> 00:40:21,210
being recorded so in the example there

00:40:17,310 --> 00:40:23,310
how you is it that you have extended the

00:40:21,210 --> 00:40:26,910
customer specific specification

00:40:23,310 --> 00:40:30,480
interface them to include a skill

00:40:26,910 --> 00:40:32,160
function well I did it depends if you

00:40:30,480 --> 00:40:33,750
know you're always going to have it then

00:40:32,160 --> 00:40:36,000
you can put it in the customer

00:40:33,750 --> 00:40:38,310
specification interface but I wouldn't

00:40:36,000 --> 00:40:40,560
put it on in the like more generic

00:40:38,310 --> 00:40:42,210
specification interface because not all

00:40:40,560 --> 00:40:46,290
of your specifications are going to need

00:40:42,210 --> 00:40:47,730
a SQL representation but you you figure

00:40:46,290 --> 00:40:49,080
this these things out where you need

00:40:47,730 --> 00:40:50,490
them and where you don't and what works

00:40:49,080 --> 00:40:52,020
and if you put it in the interface and

00:40:50,490 --> 00:40:53,880
it turns out that you didn't need it in

00:40:52,020 --> 00:40:56,880
you can still or you could have like an

00:40:53,880 --> 00:40:59,000
additional interface may be a queryable

00:40:56,880 --> 00:41:01,200
well that's a bad name what

00:40:59,000 --> 00:41:08,580
specification that it you know it's

00:41:01,200 --> 00:41:11,760
allowed to be a query okay so something

00:41:08,580 --> 00:41:18,090
very interesting now who of you guys and

00:41:11,760 --> 00:41:20,940
girls tests their SQL queries one two

00:41:18,090 --> 00:41:24,570
three four oh this is more people than I

00:41:20,940 --> 00:41:27,920
ever had in a sickness in guru or you

00:41:24,570 --> 00:41:31,710
are a smart audience it's now very easy

00:41:27,920 --> 00:41:34,380
why what is a test a test is doing

00:41:31,710 --> 00:41:36,930
something a different way comparing that

00:41:34,380 --> 00:41:39,090
to your production code and comparing

00:41:36,930 --> 00:41:41,670
your result and if this result is the

00:41:39,090 --> 00:41:44,040
same then you know that you know the

00:41:41,670 --> 00:41:45,990
production code is correct and now we

00:41:44,040 --> 00:41:48,270
have two representations we have our

00:41:45,990 --> 00:41:49,800
query and we still have our encode

00:41:48,270 --> 00:41:51,690
representation we haven't thrown that

00:41:49,800 --> 00:41:54,680
away because we still need that if we

00:41:51,690 --> 00:41:57,869
only want to check one single customer

00:41:54,680 --> 00:42:02,069
so it's now very easy to actually

00:41:57,869 --> 00:42:05,160
right test for Aquarius you make a copy

00:42:02,069 --> 00:42:07,349
of your production data and let me

00:42:05,160 --> 00:42:09,420
repeat that a copy of your production

00:42:07,349 --> 00:42:12,569
data and you can just run your test

00:42:09,420 --> 00:42:14,849
again against that so you you keep the

00:42:12,569 --> 00:42:17,519
same the way we did it in the beginning

00:42:14,849 --> 00:42:20,609
with a knife or a filter we can still do

00:42:17,519 --> 00:42:22,259
that we fetch all our customers from our

00:42:20,609 --> 00:42:25,349
production data or if it's too big you

00:42:22,259 --> 00:42:27,209
make a smaller version for your test so

00:42:25,349 --> 00:42:30,209
you fetch all these customers you apply

00:42:27,209 --> 00:42:32,699
the specification to them you filter

00:42:30,209 --> 00:42:36,420
them out and you compare the result with

00:42:32,699 --> 00:42:39,329
the result of your query so this is a

00:42:36,420 --> 00:42:41,759
like a quite cheap way actually to test

00:42:39,329 --> 00:42:44,489
your queries against your production

00:42:41,759 --> 00:42:45,930
data to make sure that you haven't

00:42:44,489 --> 00:42:48,479
missed anything because if your rules

00:42:45,930 --> 00:42:50,219
become more complex then writing these

00:42:48,479 --> 00:42:52,709
queries can you know they can the

00:42:50,219 --> 00:42:54,469
queries can be can become very hard to

00:42:52,709 --> 00:42:58,079
understand but now you can easily

00:42:54,469 --> 00:42:59,969
validate them and actually well this

00:42:58,079 --> 00:43:02,699
this example here that I have is not

00:42:59,969 --> 00:43:05,249
very complete what you actually would

00:43:02,699 --> 00:43:07,920
want as well as to make sure that well

00:43:05,249 --> 00:43:09,809
actually no it would work so anyway you

00:43:07,920 --> 00:43:13,199
want to make sure that all the customers

00:43:09,809 --> 00:43:15,479
that pass the specification are in the

00:43:13,199 --> 00:43:17,009
list of customers that you wear it and

00:43:15,479 --> 00:43:19,679
all the ones that didn't pass the

00:43:17,009 --> 00:43:21,959
specification are in the and the ones

00:43:19,679 --> 00:43:27,269
that you didn't worry but I think this

00:43:21,959 --> 00:43:31,709
this is kind of self-evident so what you

00:43:27,269 --> 00:43:35,009
can remember here is to test your your

00:43:31,709 --> 00:43:37,529
business rules and your queries by

00:43:35,009 --> 00:43:42,479
comparing different representations of

00:43:37,529 --> 00:43:45,779
the same business rule so these are some

00:43:42,479 --> 00:43:48,359
ideas to help you ensure that these

00:43:45,779 --> 00:43:50,369
rules are always nicely protected that

00:43:48,359 --> 00:43:52,859
these variants are always there so this

00:43:50,369 --> 00:43:54,359
these are the things that I I want you

00:43:52,859 --> 00:43:56,880
to remember it's to protect your

00:43:54,359 --> 00:44:02,069
invariance at all time always think

00:43:56,880 --> 00:44:04,079
about what what rules are here even the

00:44:02,069 --> 00:44:05,819
rules that your domain expert didn't

00:44:04,079 --> 00:44:08,130
make explicit right to find them there's

00:44:05,819 --> 00:44:10,349
always hidden rules everywhere of things

00:44:08,130 --> 00:44:11,559
that are that are just not allowed that

00:44:10,349 --> 00:44:13,599
are inconsistent

00:44:11,559 --> 00:44:16,029
we'll make your database corrupt that

00:44:13,599 --> 00:44:18,880
will you know introduce subtle bugs that

00:44:16,029 --> 00:44:23,739
you will have to figure out sometime at

00:44:18,880 --> 00:44:26,469
3 o'clock in the morning so the this is

00:44:23,739 --> 00:44:29,529
this is the core thing this is this is

00:44:26,469 --> 00:44:33,910
object-oriented design at its heart I

00:44:29,529 --> 00:44:36,339
think it's finding ways to to build code

00:44:33,910 --> 00:44:39,249
where you get out to really go wrong and

00:44:36,339 --> 00:44:41,079
you can still fool around and I mean if

00:44:39,249 --> 00:44:42,849
somebody really wanted to make that

00:44:41,079 --> 00:44:44,739
customer object that we had in the

00:44:42,849 --> 00:44:46,779
beginning without an email address then

00:44:44,739 --> 00:44:49,839
it could use reflection or some other

00:44:46,779 --> 00:44:52,089
black magic to do it but if somebody

00:44:49,839 --> 00:44:54,519
uses reflection to make a customer

00:44:52,089 --> 00:44:56,109
object without an email field then you

00:44:54,519 --> 00:44:58,329
would notice if you especially if you

00:44:56,109 --> 00:45:00,849
review the P error of the pull request

00:44:58,329 --> 00:45:02,769
of this guy you will see hey what is

00:45:00,849 --> 00:45:05,170
going on here what are you trying to do

00:45:02,769 --> 00:45:07,569
and then maybe you will discover there's

00:45:05,170 --> 00:45:10,299
some some missing concept you know the

00:45:07,569 --> 00:45:13,180
example from the prospective customer

00:45:10,299 --> 00:45:15,759
and the paying customer

00:45:13,180 --> 00:45:16,359
the other thing objects us consistency

00:45:15,759 --> 00:45:19,410
boundaries

00:45:16,359 --> 00:45:23,319
this is objects are not just you know

00:45:19,410 --> 00:45:25,839
stupid temporary placeholders for state

00:45:23,319 --> 00:45:27,999
they are especially in your in your

00:45:25,839 --> 00:45:31,329
domain model they are the core finger

00:45:27,999 --> 00:45:32,769
how how do you look at this this world

00:45:31,329 --> 00:45:35,229
how do you look at this problem space

00:45:32,769 --> 00:45:38,079
how do you model this well model it has

00:45:35,229 --> 00:45:41,709
things that are always correct always

00:45:38,079 --> 00:45:44,410
consistent and the way to do this is to

00:45:41,709 --> 00:45:46,299
encapsulate state and behavior use

00:45:44,410 --> 00:45:48,279
things like value objects use them a lot

00:45:46,299 --> 00:45:50,319
they are they are awesome they make your

00:45:48,279 --> 00:45:52,029
life better they are easy to test

00:45:50,319 --> 00:45:54,160
because they are so simple and they are

00:45:52,029 --> 00:45:56,519
easy to compose the things I told you

00:45:54,160 --> 00:46:01,199
about with like the the date range or

00:45:56,519 --> 00:46:04,749
time slot or things like I have a client

00:46:01,199 --> 00:46:07,289
it's a system for education we have a

00:46:04,749 --> 00:46:09,939
value object called school year it's

00:46:07,289 --> 00:46:11,949
basically it's like what's the school

00:46:09,939 --> 00:46:16,900
year it starts at September first it

00:46:11,949 --> 00:46:19,119
ends at August 31st so these are there

00:46:16,900 --> 00:46:21,369
are some there's some behavior to school

00:46:19,119 --> 00:46:24,579
year that is different than behavior to

00:46:21,369 --> 00:46:25,670
a calendar year if I ask this school

00:46:24,579 --> 00:46:28,400
year object

00:46:25,670 --> 00:46:31,190
what are your weeks then I get weeks

00:46:28,400 --> 00:46:34,910
from the week from September first to

00:46:31,190 --> 00:46:37,160
this calculation of which are the weeks

00:46:34,910 --> 00:46:39,349
that go into this particular school year

00:46:37,160 --> 00:46:41,150
is now encapsulated in the school year

00:46:39,349 --> 00:46:43,700
object and there's a lot lots of these

00:46:41,150 --> 00:46:46,369
things that become very easy if you if

00:46:43,700 --> 00:46:49,190
you come up with if you model each of

00:46:46,369 --> 00:46:55,160
these little concepts as as separate

00:46:49,190 --> 00:46:58,240
objects so this is a the gist of it are

00:46:55,160 --> 00:47:00,920
there any questions okay lots of them

00:46:58,240 --> 00:47:03,260
well we still have like 15 minutes I

00:47:00,920 --> 00:47:04,790
think you mentioned that your domain

00:47:03,260 --> 00:47:07,880
expert would have different criteria

00:47:04,790 --> 00:47:10,580
that makes someone a premium and then in

00:47:07,880 --> 00:47:13,130
your find premium it seemed to only be

00:47:10,580 --> 00:47:15,500
looking for the three orders total so

00:47:13,130 --> 00:47:20,630
how would you make it find all the

00:47:15,500 --> 00:47:23,180
different sort of criterias premium I'm

00:47:20,630 --> 00:47:25,460
not sure I understand so you had an

00:47:23,180 --> 00:47:27,440
three orders total made a customer

00:47:25,460 --> 00:47:30,400
premium and then for other customers

00:47:27,440 --> 00:47:34,790
having 500 euros I think maven premium

00:47:30,400 --> 00:47:37,970
then in your as SQL that was only there

00:47:34,790 --> 00:47:40,580
for the three orders total criteria yeah

00:47:37,970 --> 00:47:42,260
well each each of these rules are a

00:47:40,580 --> 00:47:43,970
different specification objectives so

00:47:42,260 --> 00:47:47,210
they would have different they would

00:47:43,970 --> 00:47:51,380
have their own as SQL method so each of

00:47:47,210 --> 00:47:53,720
them is a different way of does that

00:47:51,380 --> 00:47:56,359
answer it or I guess what I'm wondering

00:47:53,720 --> 00:47:58,700
is if I'm saying to the customer

00:47:56,359 --> 00:48:02,570
repository I want all of my premium

00:47:58,700 --> 00:48:04,339
customers I'd expect it find okay if you

00:48:02,570 --> 00:48:07,070
want them yeah so my assumption here was

00:48:04,339 --> 00:48:09,950
that you have like it's a SAS where

00:48:07,070 --> 00:48:12,890
everything is for one tenant only so if

00:48:09,950 --> 00:48:15,560
you are in the if you are in the Amazon

00:48:12,890 --> 00:48:17,900
version then you then there will be only

00:48:15,560 --> 00:48:20,060
this one business rule if you log in to

00:48:17,900 --> 00:48:22,849
the eBay version there's only this one

00:48:20,060 --> 00:48:24,740
business rule there's no in my you know

00:48:22,849 --> 00:48:27,380
simple example there's no way to

00:48:24,740 --> 00:48:30,170
actually find the premium customers for

00:48:27,380 --> 00:48:32,030
all different tenants at the same time

00:48:30,170 --> 00:48:34,750
if you'd want that you'd have like maybe

00:48:32,030 --> 00:48:37,760
in a layer on the outside or some

00:48:34,750 --> 00:48:39,260
administration kind of interface where I

00:48:37,760 --> 00:48:43,640
can check

00:48:39,260 --> 00:48:45,530
or all of my talents which is which but

00:48:43,640 --> 00:48:48,470
usually you would probably just log into

00:48:45,530 --> 00:48:53,230
one of these tenants admin interfaces

00:48:48,470 --> 00:49:02,270
something like that okay somebody else

00:48:53,230 --> 00:49:05,540
think over there if we go back to the

00:49:02,270 --> 00:49:06,920
value update on email if you expand that

00:49:05,540 --> 00:49:09,050
and such as a customer has to have a

00:49:06,920 --> 00:49:11,300
valid address and also valid phone

00:49:09,050 --> 00:49:14,270
number meaning that you have three value

00:49:11,300 --> 00:49:15,800
objects if you want to return an error

00:49:14,270 --> 00:49:17,900
message to the customer it's either of

00:49:15,800 --> 00:49:19,640
those are wrong or a list of error

00:49:17,900 --> 00:49:21,830
message if there's multiple wrong how

00:49:19,640 --> 00:49:23,840
would you do would you validate before

00:49:21,830 --> 00:49:27,950
you create a value object or will you do

00:49:23,840 --> 00:49:30,230
it inside the value object yeah so the

00:49:27,950 --> 00:49:33,020
things I've been talking about are about

00:49:30,230 --> 00:49:36,220
having a model that is valid and

00:49:33,020 --> 00:49:38,390
consistent the problem you're describing

00:49:36,220 --> 00:49:40,460
showing the error message to user

00:49:38,390 --> 00:49:42,200
actually has nothing to do with our

00:49:40,460 --> 00:49:45,130
model it's a completely different

00:49:42,200 --> 00:49:48,700
concern it's it's about user experience

00:49:45,130 --> 00:49:52,970
you want to present the user with a form

00:49:48,700 --> 00:49:55,460
that helps him to fill in valid values

00:49:52,970 --> 00:49:57,560
and there's different ways of doing that

00:49:55,460 --> 00:50:00,410
you could have like a client-side

00:49:57,560 --> 00:50:02,690
validation which is probably the best

00:50:00,410 --> 00:50:05,630
for user experience if you use a

00:50:02,690 --> 00:50:07,850
back-end form library like the one in

00:50:05,630 --> 00:50:10,100
symphony then this is going to rerender

00:50:07,850 --> 00:50:12,380
your form with with messages you can

00:50:10,100 --> 00:50:14,090
still have validation there but it's a

00:50:12,380 --> 00:50:17,210
different kind of validation

00:50:14,090 --> 00:50:19,070
it may be often it looks very much the

00:50:17,210 --> 00:50:22,400
same because the same rules are going to

00:50:19,070 --> 00:50:24,820
apply but I I see this as two completely

00:50:22,400 --> 00:50:27,680
separated concerns and this is why for

00:50:24,820 --> 00:50:30,170
many people it's this stuff is difficult

00:50:27,680 --> 00:50:33,500
because they try to do this in in one

00:50:30,170 --> 00:50:35,390
place and which means that it makes it

00:50:33,500 --> 00:50:37,700
kind of impossible to to do it cleanly

00:50:35,390 --> 00:50:39,380
you have to this form libraries they

00:50:37,700 --> 00:50:41,150
they sort of slice through your whole

00:50:39,380 --> 00:50:43,460
MVC they know about your model they know

00:50:41,150 --> 00:50:45,320
about your your controllers they know

00:50:43,460 --> 00:50:47,630
about your templates and your forms this

00:50:45,320 --> 00:50:49,970
is too much responsibility keep it

00:50:47,630 --> 00:50:52,610
simple and just if you want to validate

00:50:49,970 --> 00:50:53,210
a form do form validation if you want to

00:50:52,610 --> 00:50:54,920
validate your

00:50:53,210 --> 00:50:57,260
what we'll do model validation if this

00:50:54,920 --> 00:50:59,330
means that you do them both that's fine

00:50:57,260 --> 00:51:02,720
because sometimes you will have this

00:50:59,330 --> 00:51:05,390
model without forms if you have a an API

00:51:02,720 --> 00:51:08,860
on top of your model then this API will

00:51:05,390 --> 00:51:14,030
not use this form validation and

00:51:08,860 --> 00:51:15,620
sometimes I it can happen that your so

00:51:14,030 --> 00:51:18,440
make sure that your model validation is

00:51:15,620 --> 00:51:21,170
complete and consistent if your form

00:51:18,440 --> 00:51:24,710
validation is not complete then your

00:51:21,170 --> 00:51:26,540
model will still catch the things that

00:51:24,710 --> 00:51:30,170
slip through the maze but it will never

00:51:26,540 --> 00:51:33,980
allow inconsistent data to enter your

00:51:30,170 --> 00:51:35,900
your system if this happens you can you

00:51:33,980 --> 00:51:37,400
throw exceptions you throw exceptions in

00:51:35,900 --> 00:51:40,790
your value object if something is off

00:51:37,400 --> 00:51:44,270
you throw it in in the entities if

00:51:40,790 --> 00:51:47,120
something is is as off and you can you

00:51:44,270 --> 00:51:49,100
can use this exception messages and show

00:51:47,120 --> 00:51:52,220
them back to the user the experience for

00:51:49,100 --> 00:51:55,310
the user will be less nice because they

00:51:52,220 --> 00:51:58,970
get more technical messages but if your

00:51:55,310 --> 00:52:00,740
that will force you to make better form

00:51:58,970 --> 00:52:03,440
validation or better client-side

00:52:00,740 --> 00:52:05,510
validation to make it so to prevent

00:52:03,440 --> 00:52:07,490
users from ever getting to the point

00:52:05,510 --> 00:52:10,790
where they get an exception from the

00:52:07,490 --> 00:52:12,350
model and actually you can even be more

00:52:10,790 --> 00:52:14,660
strict about it and say if you really

00:52:12,350 --> 00:52:18,140
trust your form validation or your

00:52:14,660 --> 00:52:22,250
client side validation to be complete

00:52:18,140 --> 00:52:23,960
and catch every every violation then you

00:52:22,250 --> 00:52:27,620
can say that if the model throws an

00:52:23,960 --> 00:52:29,540
exception you just do like a 500 status

00:52:27,620 --> 00:52:32,960
code and just say no can't do this

00:52:29,540 --> 00:52:37,000
because if you trust it then you know

00:52:32,960 --> 00:52:39,740
that every request that you get that is

00:52:37,000 --> 00:52:41,990
not consistent is somebody trying to

00:52:39,740 --> 00:52:45,320
hack your system somebody trying to work

00:52:41,990 --> 00:52:48,100
around the client site and the and the

00:52:45,320 --> 00:52:51,230
server-side validation form validation

00:52:48,100 --> 00:52:52,880
to get invalidate in your system so and

00:52:51,230 --> 00:52:55,010
if somebody tries to hack my system I

00:52:52,880 --> 00:52:57,290
don't worry about showing nice messages

00:52:55,010 --> 00:52:59,690
and and you know coloring the form and

00:52:57,290 --> 00:53:02,390
whatever because they don't care either

00:52:59,690 --> 00:53:03,740
we just block it it's it's invalid

00:53:02,390 --> 00:53:05,360
you're trying to hack my system I'm not

00:53:03,740 --> 00:53:06,370
going to help you by giving you more

00:53:05,360 --> 00:53:08,380
information

00:53:06,370 --> 00:53:10,930
but the important thing is for me these

00:53:08,380 --> 00:53:12,760
are totally different concerns if you

00:53:10,930 --> 00:53:14,530
look at them this way single

00:53:12,760 --> 00:53:17,160
responsibility form validation user

00:53:14,530 --> 00:53:19,870
experience one side of the world a

00:53:17,160 --> 00:53:22,150
coherent model other side of the world

00:53:19,870 --> 00:53:25,300
and any client like if you have maybe a

00:53:22,150 --> 00:53:26,980
comment line interface restate the I I

00:53:25,300 --> 00:53:30,610
know whatever you come up with mobile

00:53:26,980 --> 00:53:32,830
application they they will all use this

00:53:30,610 --> 00:53:36,580
same model and this model is going to be

00:53:32,830 --> 00:53:48,370
guaranteed consistent all the time does

00:53:36,580 --> 00:53:52,570
that answer it hi while I'm a fan of

00:53:48,370 --> 00:53:56,410
object orientation my concern with your

00:53:52,570 --> 00:53:59,650
approach value objects and to require

00:53:56,410 --> 00:54:03,730
you require an email address if you have

00:53:59,650 --> 00:54:07,150
a large representation of your model and

00:54:03,730 --> 00:54:10,510
you require large numbers of attributes

00:54:07,150 --> 00:54:14,290
and you're enforcing that through the

00:54:10,510 --> 00:54:16,930
constructor how is that then it doesn't

00:54:14,290 --> 00:54:20,050
strike me as very pragmatic to have a

00:54:16,930 --> 00:54:22,150
huge constructor with all of those I

00:54:20,050 --> 00:54:24,910
mean in terms of performance not just

00:54:22,150 --> 00:54:28,480
performance but readability and using

00:54:24,910 --> 00:54:30,550
the code itself you know it's fine for

00:54:28,480 --> 00:54:32,230
the examples that you have given but

00:54:30,550 --> 00:54:35,010
when you've got large numbers of

00:54:32,230 --> 00:54:38,410
requirements for a single model

00:54:35,010 --> 00:54:40,300
how would you overcome that with this is

00:54:38,410 --> 00:54:43,030
that there is this the right approach

00:54:40,300 --> 00:54:46,180
whereas if you're enforcing validation

00:54:43,030 --> 00:54:48,280
from the outside on a plain old PHP

00:54:46,180 --> 00:54:51,340
object is some frameworks you're using

00:54:48,280 --> 00:54:53,020
surely that's a bit more pragmatic but I

00:54:51,340 --> 00:54:54,190
don't if you're not talking about

00:54:53,020 --> 00:54:56,430
performance and I don't really

00:54:54,190 --> 00:54:59,650
understand what is more pragmatic about

00:54:56,430 --> 00:55:01,900
doing it on the outside if I have to

00:54:59,650 --> 00:55:04,300
create a customer object and every time

00:55:01,900 --> 00:55:07,180
I do that when I call new I have to

00:55:04,300 --> 00:55:11,800
specify the first name last name and all

00:55:07,180 --> 00:55:15,010
of that up front in my code I'm going to

00:55:11,800 --> 00:55:16,870
have lines either split on multiple

00:55:15,010 --> 00:55:18,520
lines just so I can fit it within my

00:55:16,870 --> 00:55:19,360
width or it's just going to run off the

00:55:18,520 --> 00:55:21,910
end of the page

00:55:19,360 --> 00:55:25,330
so but how is cognitive overload in

00:55:21,910 --> 00:55:28,960
doing that so how is a new customer and

00:55:25,330 --> 00:55:31,630
then having five arguments less

00:55:28,960 --> 00:55:34,720
pragmatic than new customer set every

00:55:31,630 --> 00:55:36,940
set name set email I don't I don't

00:55:34,720 --> 00:55:38,200
really see how this is less pragmatic in

00:55:36,940 --> 00:55:40,410
some way well no because if you're

00:55:38,200 --> 00:55:43,090
injecting it with another framework from

00:55:40,410 --> 00:55:44,740
while sorry with another system from the

00:55:43,090 --> 00:55:46,810
outside then you can manage that

00:55:44,740 --> 00:55:49,930
separately but in doing so you have to

00:55:46,810 --> 00:55:51,190
enforce the requirement separately does

00:55:49,930 --> 00:55:53,920
that make sense

00:55:51,190 --> 00:55:56,080
so if you if you're if you're hydrating

00:55:53,920 --> 00:55:57,250
yeah from the outside with gutters and

00:55:56,080 --> 00:55:59,260
setters

00:55:57,250 --> 00:56:01,510
you'd have to apply the validation

00:55:59,260 --> 00:56:04,330
separately but you can just construct

00:56:01,510 --> 00:56:05,800
your user constructor on the fly yeah

00:56:04,330 --> 00:56:07,450
well I mean if you're talking about

00:56:05,800 --> 00:56:10,150
hydration then you're probably talking

00:56:07,450 --> 00:56:14,760
about getting stuff out of your database

00:56:10,150 --> 00:56:18,570
or deserializing it from some other

00:56:14,760 --> 00:56:23,260
service that's or some api or something

00:56:18,570 --> 00:56:25,390
it largely depends but you know use user

00:56:23,260 --> 00:56:27,760
persistence library that allows you to

00:56:25,390 --> 00:56:29,620
to do this kind of stuff like doctrine I

00:56:27,760 --> 00:56:33,220
think it's still the best one we've got

00:56:29,620 --> 00:56:36,430
for these kinds of problems if you use

00:56:33,220 --> 00:56:39,610
if you need to disable eye stuff you

00:56:36,430 --> 00:56:43,360
know I I don't like the really slow and

00:56:39,610 --> 00:56:45,340
huge serialized like the JMS one day

00:56:43,360 --> 00:56:47,320
they're well they're they're slow and

00:56:45,340 --> 00:56:49,600
they they sort of get inside your

00:56:47,320 --> 00:56:51,310
objects so much so I tend to write my

00:56:49,600 --> 00:56:55,330
own deserialize errs for this kind of

00:56:51,310 --> 00:56:57,430
stuff the only problem that I can see is

00:56:55,330 --> 00:57:02,730
if you really need to like import

00:56:57,430 --> 00:57:06,580
gazillion customers and you have maybe a

00:57:02,730 --> 00:57:07,960
some some regular expression on each of

00:57:06,580 --> 00:57:10,420
the email addresses and you make an

00:57:07,960 --> 00:57:12,070
object for like millions of of objects

00:57:10,420 --> 00:57:13,750
then it's going to be slow and then

00:57:12,070 --> 00:57:15,700
maybe you want to skip this sort of

00:57:13,750 --> 00:57:18,670
thing if you are confident that this

00:57:15,700 --> 00:57:20,620
data is is correct but that's seem like

00:57:18,670 --> 00:57:22,630
the only case I can think of for not

00:57:20,620 --> 00:57:24,820
doing this this stuff it makes your

00:57:22,630 --> 00:57:28,570
system a lot more easier to think about

00:57:24,820 --> 00:57:32,140
because it's going to be valid all the

00:57:28,570 --> 00:57:32,920
time and just it so I am NOT arguing to

00:57:32,140 --> 00:57:35,020
put everything

00:57:32,920 --> 00:57:37,030
the constructor only the things that are

00:57:35,020 --> 00:57:40,060
essential to have a valid customer if

00:57:37,030 --> 00:57:42,820
your system allows customers without a

00:57:40,060 --> 00:57:44,860
street address then don't put it in

00:57:42,820 --> 00:57:50,320
constructor it doesn't be longer it's an

00:57:44,860 --> 00:57:54,250
optional thing so does that help I'll

00:57:50,320 --> 00:57:56,800
agree to disagree okay we can talk later

00:57:54,250 --> 00:58:03,700
I think there's somebody in the back

00:57:56,800 --> 00:58:05,950
area I felt like last question was about

00:58:03,700 --> 00:58:08,730
a large number of the parameters in the

00:58:05,950 --> 00:58:11,830
constructor and so I would suggest

00:58:08,730 --> 00:58:14,980
investigate a build a pattern so that

00:58:11,830 --> 00:58:18,280
would allow us to build the object we're

00:58:14,980 --> 00:58:21,400
providing them with clever defaults

00:58:18,280 --> 00:58:23,860
which would inside pass it all in the

00:58:21,400 --> 00:58:27,850
constructor but letting them set before

00:58:23,860 --> 00:58:30,730
building the object itself yeah couldn't

00:58:27,850 --> 00:58:32,680
agree more but often so if you have a

00:58:30,730 --> 00:58:34,840
lot of parameters in the constructor and

00:58:32,680 --> 00:58:37,480
maybe again you are missing a concept

00:58:34,840 --> 00:58:39,880
maybe you are trying to do all these

00:58:37,480 --> 00:58:41,500
parameters individually maybe instead of

00:58:39,880 --> 00:58:44,140
having a street and a city and whatever

00:58:41,500 --> 00:58:48,810
you just want an address value object

00:58:44,140 --> 00:58:50,620
stuff like this and somebody else on the

00:58:48,810 --> 00:58:52,630
validation thing that you're talking

00:58:50,620 --> 00:58:54,670
about before I kind of get your point

00:58:52,630 --> 00:58:57,580
that they're different concerns and you

00:58:54,670 --> 00:58:59,440
have data consistency does that not

00:58:57,580 --> 00:59:02,080
though lead you to a kind of system in

00:58:59,440 --> 00:59:05,500
consists in consistency potential way

00:59:02,080 --> 00:59:08,290
you've got different validation rules on

00:59:05,500 --> 00:59:11,140
one piece of data because time and

00:59:08,290 --> 00:59:14,200
different people and stuff you know so

00:59:11,140 --> 00:59:16,510
you've got one JavaScript validation on

00:59:14,200 --> 00:59:18,400
your form and then one on your model

00:59:16,510 --> 00:59:21,330
that you want to be the same so you've

00:59:18,400 --> 00:59:26,560
got your kind of trading consistency

00:59:21,330 --> 00:59:29,680
yeah well I prefer my my state to be

00:59:26,560 --> 00:59:32,350
consistent so I want my model to be

00:59:29,680 --> 00:59:34,630
consistent this is the heart of it this

00:59:32,350 --> 00:59:38,380
is why you know domain driven design

00:59:34,630 --> 00:59:40,900
this model centric if there are

00:59:38,380 --> 00:59:43,480
inconsistencies between my clients

00:59:40,900 --> 00:59:44,980
validations or my form validation and my

00:59:43,480 --> 00:59:47,440
model

00:59:44,980 --> 00:59:49,060
many things can happen maybe this is not

00:59:47,440 --> 00:59:51,520
really a big problem for the business

00:59:49,060 --> 00:59:54,220
and maybe it never gets fixed and maybe

00:59:51,520 --> 00:59:55,840
one in a million users has some form

00:59:54,220 --> 00:59:57,100
that they cannot submit and if it

00:59:55,840 --> 00:59:58,690
doesn't hurt the business then nobody

00:59:57,100 --> 01:00:00,550
will complain if it does hurt the

00:59:58,690 --> 01:00:02,560
business then you know somebody is going

01:00:00,550 --> 01:00:04,330
to have to fix this book and just make

01:00:02,560 --> 01:00:06,850
sure that you know that these things

01:00:04,330 --> 01:00:08,800
happen if you worry about it and make

01:00:06,850 --> 01:00:12,730
sure you have some monitoring on how

01:00:08,800 --> 01:00:16,060
often do form submissions fail for what

01:00:12,730 --> 01:00:19,630
reason do they fail look at this this

01:00:16,060 --> 01:00:22,440
Locke and figure this out and fix it so

01:00:19,630 --> 01:00:24,580
yeah I mean I'd rather have

01:00:22,440 --> 01:00:28,690
inconsistency between these two

01:00:24,580 --> 01:00:31,270
validations then have inconsistency

01:00:28,690 --> 01:00:32,590
inside my model this is the central

01:00:31,270 --> 01:00:34,780
thing everything else just needs to

01:00:32,590 --> 01:00:38,680
adapt to my model or my model is wrong

01:00:34,780 --> 01:00:42,690
and then I need to change it I think we

01:00:38,680 --> 01:00:42,690
have time for one more maybe okay

01:00:49,940 --> 01:00:56,150
my question is about more about

01:00:51,860 --> 01:00:59,330
architecture in the beginning starting

01:00:56,150 --> 01:01:02,960
something you have the entity class in

01:00:59,330 --> 01:01:05,480
one side defining the properties getters

01:01:02,960 --> 01:01:08,300
and setters then you go to the

01:01:05,480 --> 01:01:12,800
persisting your data you have the

01:01:08,300 --> 01:01:16,280
repository class this is the very very

01:01:12,800 --> 01:01:19,150
early stage of any any kind of the tasks

01:01:16,280 --> 01:01:24,380
of inside your your model my question is

01:01:19,150 --> 01:01:28,850
when you start to make the model complex

01:01:24,380 --> 01:01:33,170
I mean adding the business rules is your

01:01:28,850 --> 01:01:37,640
opinion that must be inside the entity

01:01:33,170 --> 01:01:41,300
or they should go with the repository or

01:01:37,640 --> 01:01:46,010
in the other end on a third different

01:01:41,300 --> 01:01:48,920
layer oh well it depends where the rule

01:01:46,010 --> 01:01:51,470
applies and this is the difficulty and

01:01:48,920 --> 01:01:53,150
modeling of course is figuring out what

01:01:51,470 --> 01:01:55,940
kind of things will I group together and

01:01:53,150 --> 01:01:58,550
where will I put these rules and but I'd

01:01:55,940 --> 01:02:00,620
like two more interesting but maybe a

01:01:58,550 --> 01:02:03,380
topic for a different presentation would

01:02:00,620 --> 01:02:05,150
be to not start your model from your

01:02:03,380 --> 01:02:07,190
entities and these kind of things

01:02:05,150 --> 01:02:09,170
because that's still kind of structural

01:02:07,190 --> 01:02:12,950
thinking if you start your model from

01:02:09,170 --> 01:02:14,480
for example commands command objects and

01:02:12,950 --> 01:02:16,690
you you just start listing on a

01:02:14,480 --> 01:02:19,640
whiteboard or on post-its things like

01:02:16,690 --> 01:02:24,760
you know pay for order that's a command

01:02:19,640 --> 01:02:28,520
you just name it in the imperative sense

01:02:24,760 --> 01:02:30,650
pay for order add product to basket you

01:02:28,520 --> 01:02:32,810
start with these commands this is your

01:02:30,650 --> 01:02:34,310
interface to your user and you build

01:02:32,810 --> 01:02:36,080
everything from there you just start

01:02:34,310 --> 01:02:38,150
looking at okay if I have these commands

01:02:36,080 --> 01:02:40,430
where do I put this state and behavior

01:02:38,150 --> 01:02:42,680
to enforce this visual zone but that's

01:02:40,430 --> 01:02:45,590
something to discuss yeah my thing

01:02:42,680 --> 01:02:47,870
making the question again sorry starting

01:02:45,590 --> 01:02:51,560
on that way should I start with the

01:02:47,870 --> 01:02:54,350
comments on the entity type class or

01:02:51,560 --> 01:02:56,330
should be any other color all right

01:02:54,350 --> 01:02:57,530
drives methodology well it doesn't

01:02:56,330 --> 01:03:00,560
matter where you start as long as you

01:02:57,530 --> 01:03:01,370
get R of course but in this case at

01:03:00,560 --> 01:03:04,130
least I tried

01:03:01,370 --> 01:03:06,200
start from value objects and and see

01:03:04,130 --> 01:03:10,130
which ones actually need to be or want

01:03:06,200 --> 01:03:12,500
to be entities and try to keep keep the

01:03:10,130 --> 01:03:14,990
logic contained to where it's you know

01:03:12,500 --> 01:03:17,450
the most relevant place but this is the

01:03:14,990 --> 01:03:21,400
vaguest answer I can I can give thank

01:03:17,450 --> 01:03:21,400

YouTube URL: https://www.youtube.com/watch?v=ZJ63ltuwMaE


