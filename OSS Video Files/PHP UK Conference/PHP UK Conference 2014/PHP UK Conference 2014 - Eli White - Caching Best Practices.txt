Title: PHP UK Conference 2014 - Eli White - Caching Best Practices
Publication date: 2014-03-21
Playlist: PHP UK Conference 2014
Description: 
	Whether you use Memcached or another caching technology, such as APC or Zend Server Cache, having an application level cache is important for performance & scalability. Learn some best practices for making this cache layer the most efficient & easy to use. Techniques such as 'biggest smallest reusable item' & automatic write-through caching will be covered.
Captions: 
	00:00:04,520 --> 00:00:07,520
thanks everyone so yeah I again I'm

00:00:06,230 --> 00:00:09,860
gonna be talking about caching best

00:00:07,520 --> 00:00:13,309
practices if you have any questions

00:00:09,860 --> 00:00:14,600
please ask me I'm also of course be here

00:00:13,309 --> 00:00:16,100
the rest of the day this evening and all

00:00:14,600 --> 00:00:17,590
of tomorrow so you can always come up

00:00:16,100 --> 00:00:21,280
and ask me any questions that you have

00:00:17,590 --> 00:00:25,130
all right so let's go ahead and move on

00:00:21,280 --> 00:00:26,960
so a lot of times the big question

00:00:25,130 --> 00:00:30,500
people start off with is why should I

00:00:26,960 --> 00:00:32,559
bother with caching there are so many

00:00:30,500 --> 00:00:36,320
different conversations I have had with

00:00:32,559 --> 00:00:38,090
people who why bother caching it's such

00:00:36,320 --> 00:00:40,970
a pain there's so much work you have to

00:00:38,090 --> 00:00:42,920
do it gets in your way

00:00:40,970 --> 00:00:44,960
it just makes programming harder and all

00:00:42,920 --> 00:00:46,820
of those are very true but there are

00:00:44,960 --> 00:00:49,420
actually some very good reasons that you

00:00:46,820 --> 00:00:52,790
do need to worry about it um

00:00:49,420 --> 00:00:55,700
caching in general really simply put

00:00:52,790 --> 00:00:57,969
when you get down to it it's absolutely

00:00:55,700 --> 00:01:01,280
necessary to take the load off of

00:00:57,969 --> 00:01:03,920
expensive tasks now this can be any sort

00:01:01,280 --> 00:01:05,659
of expensive task typically you're doing

00:01:03,920 --> 00:01:07,189
caching against the database but you may

00:01:05,659 --> 00:01:09,619
need to do caching against an API

00:01:07,189 --> 00:01:11,600
against a web service you can do caching

00:01:09,619 --> 00:01:14,569
against filesystem access if that's a

00:01:11,600 --> 00:01:16,850
problem you have the idea is anything

00:01:14,569 --> 00:01:18,740
you have that is expensive and expensive

00:01:16,850 --> 00:01:22,279
could be in time it could be in CPU

00:01:18,740 --> 00:01:24,619
power it could be in network is the idea

00:01:22,279 --> 00:01:27,619
of you only making that request once or

00:01:24,619 --> 00:01:29,779
once ever so often and then being able

00:01:27,619 --> 00:01:33,139
to just rely on that cache coming back

00:01:29,779 --> 00:01:36,259
in in the end no really popular

00:01:33,139 --> 00:01:39,499
application can completely survive

00:01:36,259 --> 00:01:41,869
serving dynamic data upon every single

00:01:39,499 --> 00:01:44,770
request and so they all cache caching is

00:01:41,869 --> 00:01:47,929
just the way of life at this point

00:01:44,770 --> 00:01:49,639
Facebook Twitter WordPress Wikipedia all

00:01:47,929 --> 00:01:52,369
of these up here and many many more all

00:01:49,639 --> 00:01:57,859
heavily rely on caching to be able to

00:01:52,369 --> 00:01:59,539
scale to the levels that they are and so

00:01:57,859 --> 00:02:01,759
really it's often been said that there

00:01:59,539 --> 00:02:04,700
are two really hard things in computer

00:02:01,759 --> 00:02:08,450
programming cache invalidation naming

00:02:04,700 --> 00:02:10,069
things and off-by-one errors and the

00:02:08,450 --> 00:02:12,530
cache invalidation part of this is

00:02:10,069 --> 00:02:16,280
absolutely true if you have ever written

00:02:12,530 --> 00:02:17,270
any caching code at this point your bane

00:02:16,280 --> 00:02:19,460
of existence

00:02:17,270 --> 00:02:21,680
having a bug and finding out that the

00:02:19,460 --> 00:02:23,360
bug isn't really a bug is but it's not

00:02:21,680 --> 00:02:26,240
with the code it's with the caching

00:02:23,360 --> 00:02:28,640
layer it's that you're getting old data

00:02:26,240 --> 00:02:29,990
and you're relying on old data and

00:02:28,640 --> 00:02:31,550
sometimes you replicate that old data

00:02:29,990 --> 00:02:35,690
back into the database and that's a very

00:02:31,550 --> 00:02:38,510
very bad idea so usually when I'm

00:02:35,690 --> 00:02:41,000
talking to someone about caching and

00:02:38,510 --> 00:02:42,920
trying to explain to them why caching is

00:02:41,000 --> 00:02:44,420
so important this is the number one

00:02:42,920 --> 00:02:47,350
thing they come back and say but my day

00:02:44,420 --> 00:02:49,790
the changes all the time I can't cash oh

00:02:47,350 --> 00:02:54,170
the fact is again you're going to have

00:02:49,790 --> 00:02:56,600
to cache right and all these websites do

00:02:54,170 --> 00:02:58,310
caching Facebook Twitter they change

00:02:56,600 --> 00:03:01,460
constantly by the second

00:02:58,310 --> 00:03:03,740
yet they cache heavily and the trick for

00:03:01,460 --> 00:03:06,500
doing this is figuring out what you can

00:03:03,740 --> 00:03:09,740
cache and how you can cache it typically

00:03:06,500 --> 00:03:12,950
what this comes down to is caching small

00:03:09,740 --> 00:03:14,900
pieces of data all right and cache these

00:03:12,950 --> 00:03:17,210
small pieces of data that do not change

00:03:14,900 --> 00:03:20,990
nearly as often and again that evil word

00:03:17,210 --> 00:03:24,020
of cache invalidation is invalidating it

00:03:20,990 --> 00:03:26,300
when it changes or simply living with

00:03:24,020 --> 00:03:28,130
stale data for a while so in the case of

00:03:26,300 --> 00:03:29,570
Twitter they may actually cache the

00:03:28,130 --> 00:03:34,100
lookup for a specific tweet or Facebook

00:03:29,570 --> 00:03:35,630
for a specific post but that tweet once

00:03:34,100 --> 00:03:38,000
that tweet has been made once that post

00:03:35,630 --> 00:03:40,640
has been made with a few exceptions it's

00:03:38,000 --> 00:03:42,890
not going to change right so they're

00:03:40,640 --> 00:03:44,840
able to keep that cached and refer to it

00:03:42,890 --> 00:03:48,640
in a much quicker fashion than going

00:03:44,840 --> 00:03:48,640
back to the database every single time

00:03:48,910 --> 00:03:55,400
so before we move on any further we need

00:03:52,280 --> 00:03:58,130
to talk a bit about opcode caches all

00:03:55,400 --> 00:04:00,980
right and most importantly opcode caches

00:03:58,130 --> 00:04:03,470
are not the focus of this talk we are

00:04:00,980 --> 00:04:06,110
talking about application level caching

00:04:03,470 --> 00:04:08,660
not opcode caching if you are not

00:04:06,110 --> 00:04:09,980
familiar with opcode caching however let

00:04:08,660 --> 00:04:11,330
me just go ahead and cover it very

00:04:09,980 --> 00:04:14,630
quickly because it's something you

00:04:11,330 --> 00:04:17,030
absolutely should be using PHP

00:04:14,630 --> 00:04:19,459
recompiles your program every single

00:04:17,030 --> 00:04:22,070
time it is run into a machine language

00:04:19,459 --> 00:04:24,290
called op codes and then those op codes

00:04:22,070 --> 00:04:27,530
or what actually get executed all right

00:04:24,290 --> 00:04:29,720
so every time your PHP gets run this

00:04:27,530 --> 00:04:30,230
compilation process happens every single

00:04:29,720 --> 00:04:33,050
time

00:04:30,230 --> 00:04:34,370
all that an opcode cache really does on

00:04:33,050 --> 00:04:37,130
the surface it's a lot more complicated

00:04:34,370 --> 00:04:39,230
behind the scenes but is that after that

00:04:37,130 --> 00:04:40,790
compilation has happened it saves that

00:04:39,230 --> 00:04:43,700
compiled version in memory and just

00:04:40,790 --> 00:04:45,170
reruns the compiled version so you

00:04:43,700 --> 00:04:47,390
should absolutely be running one of

00:04:45,170 --> 00:04:49,460
these back in the day there used to be

00:04:47,390 --> 00:04:50,810
some drawbacks to using opcode caches

00:04:49,460 --> 00:04:53,180
there aren't anymore

00:04:50,810 --> 00:04:55,220
they are wonderful things they give you

00:04:53,180 --> 00:04:56,630
ten times or hundred times or even more

00:04:55,220 --> 00:04:59,300
it depends on your application of

00:04:56,630 --> 00:05:03,830
performance boost just by putting one in

00:04:59,300 --> 00:05:07,700
place and turning it on okay just to

00:05:03,830 --> 00:05:11,270
show it out there are a number of cache

00:05:07,700 --> 00:05:12,740
options at the moment the ancient and

00:05:11,270 --> 00:05:15,290
venerable one at this point but which is

00:05:12,740 --> 00:05:17,030
still a very good option is a PC which

00:05:15,290 --> 00:05:18,410
stands for the alternative PHP cache

00:05:17,030 --> 00:05:20,870
even though it kind of became the

00:05:18,410 --> 00:05:22,130
default when it came out there were a

00:05:20,870 --> 00:05:24,770
bunch of other ones so this was the

00:05:22,130 --> 00:05:28,940
alternative one it does work all the way

00:05:24,770 --> 00:05:31,520
back to PHP 4.0 works on Windows Linux

00:05:28,940 --> 00:05:34,430
and Mac so it's very stable it's been

00:05:31,520 --> 00:05:36,980
around for a long time it also includes

00:05:34,430 --> 00:05:38,420
a user cache and we will talk about that

00:05:36,980 --> 00:05:41,680
more in just a little bit and that's one

00:05:38,420 --> 00:05:41,680
of the reasons I wanted to bring this up

00:05:41,950 --> 00:05:48,740
built-in to PHP as of 5.5 now there is

00:05:46,910 --> 00:05:52,640
one that comes with it it comes bundled

00:05:48,740 --> 00:05:54,830
it's called op cash or Oh P cash um it

00:05:52,640 --> 00:05:59,620
is bundled in so it makes it very easy

00:05:54,830 --> 00:06:03,320
to use it only works from 5.2 and higher

00:05:59,620 --> 00:06:06,410
but it does work on all systems and then

00:06:03,320 --> 00:06:11,030
if you happen to be an I is Windows user

00:06:06,410 --> 00:06:13,460
of PHP Microsoft actually provides one

00:06:11,030 --> 00:06:15,140
themself called win cash it's current

00:06:13,460 --> 00:06:17,390
the current version only works on 5.2

00:06:15,140 --> 00:06:18,890
and higher but it's actually very

00:06:17,390 --> 00:06:20,120
excellent if you are specifically

00:06:18,890 --> 00:06:25,760
running on Windows because it was

00:06:20,120 --> 00:06:27,230
designed with Windows in mind so let's

00:06:25,760 --> 00:06:30,080
move on to talking about some actual

00:06:27,230 --> 00:06:33,560
caching methodologies here there's a

00:06:30,080 --> 00:06:35,120
number of these and there's four main

00:06:33,560 --> 00:06:37,040
ones here I'm going to talk about but

00:06:35,120 --> 00:06:39,740
there's a million different ways you can

00:06:37,040 --> 00:06:41,780
come up with in the end what this all

00:06:39,740 --> 00:06:43,239
comes down to is trying to figure out

00:06:41,780 --> 00:06:46,369
for your applicant

00:06:43,239 --> 00:06:48,979
what is the best place for you to decide

00:06:46,369 --> 00:06:53,839
what to cash how long the cash if for

00:06:48,979 --> 00:06:57,050
how to invalidate it so first off is the

00:06:53,839 --> 00:06:58,909
idea of a whole page cash a whole page

00:06:57,050 --> 00:07:00,679
cash is sort of the old-school method of

00:06:58,909 --> 00:07:03,289
cashing it's how people started doing it

00:07:00,679 --> 00:07:05,689
in the beginning where you generate your

00:07:03,289 --> 00:07:10,039
HTML page you generate your output and

00:07:05,689 --> 00:07:12,169
then you cash that output right the

00:07:10,039 --> 00:07:14,330
problem with this is this comes back to

00:07:12,169 --> 00:07:17,029
when people were complaining about but

00:07:14,330 --> 00:07:19,939
my data changes this is extremely hard

00:07:17,029 --> 00:07:21,499
to do if you truly have a static site or

00:07:19,939 --> 00:07:23,629
sorry if you truly have a dynamic site

00:07:21,499 --> 00:07:25,639
if every time someone loads a page that

00:07:23,629 --> 00:07:27,199
page is going to be different if it's

00:07:25,639 --> 00:07:29,149
just going to have the name of the user

00:07:27,199 --> 00:07:32,029
in it or anything like that that's going

00:07:29,149 --> 00:07:36,559
to be different per user then this tends

00:07:32,029 --> 00:07:39,099
to fall down honestly in my opinion you

00:07:36,559 --> 00:07:41,679
should not be inside of your own code

00:07:39,099 --> 00:07:44,300
trying to implement a whole page cache

00:07:41,679 --> 00:07:47,300
whole page caches are much better left

00:07:44,300 --> 00:07:49,069
to a well configured proxy you can

00:07:47,300 --> 00:07:50,929
easily put various proxies in front of

00:07:49,069 --> 00:07:53,659
your website and tell the proxy to take

00:07:50,929 --> 00:07:55,459
care of caching for you and saying like

00:07:53,659 --> 00:07:58,399
ok any time a page has been generated

00:07:55,459 --> 00:08:00,439
cache it for 5 seconds or however long

00:07:58,399 --> 00:08:02,659
it's okay for some still data to appear

00:08:00,439 --> 00:08:04,159
and let the proxy take care of that

00:08:02,659 --> 00:08:08,329
don't try to build that logic into your

00:08:04,159 --> 00:08:12,379
PHP itself the next step of flexibility

00:08:08,329 --> 00:08:14,209
is a partial page cache now partial

00:08:12,379 --> 00:08:17,149
pages is the idea where you are going to

00:08:14,209 --> 00:08:19,550
cache parts of the HTML so you're still

00:08:17,149 --> 00:08:21,649
generating HTML but you're not going to

00:08:19,550 --> 00:08:25,009
cache the whole page you're going to

00:08:21,649 --> 00:08:27,289
cache some widget so for example this

00:08:25,009 --> 00:08:28,639
tends to be how WordPress caching

00:08:27,289 --> 00:08:30,829
happens if you've used WordPress or

00:08:28,639 --> 00:08:32,719
other CMS systems where you may have

00:08:30,829 --> 00:08:34,189
some type of widget on the page and that

00:08:32,719 --> 00:08:36,409
widget may appear on multiple different

00:08:34,189 --> 00:08:38,990
pages so say it's a calendar of upcoming

00:08:36,409 --> 00:08:40,639
events or in the case of PHP architect

00:08:38,990 --> 00:08:42,829
it's the training that we have coming up

00:08:40,639 --> 00:08:44,329
in the future we have a training widget

00:08:42,829 --> 00:08:46,670
that widget happens to get used on

00:08:44,329 --> 00:08:47,750
multiple different pages and training

00:08:46,670 --> 00:08:51,319
doesn't change that often we don't

00:08:47,750 --> 00:08:53,660
schedule new courses that frequently so

00:08:51,319 --> 00:08:55,970
we can actually have the output of that

00:08:53,660 --> 00:08:58,490
widget we can generate it once

00:08:55,970 --> 00:09:00,949
and then have it be cashed in fact we

00:08:58,490 --> 00:09:03,529
could cash it forever and invalidate it

00:09:00,949 --> 00:09:05,209
when we do go in and add a new training

00:09:03,529 --> 00:09:07,670
course because that's the only time that

00:09:05,209 --> 00:09:09,490
piece of HTML that's going to exist on

00:09:07,670 --> 00:09:11,569
any number of pages is going to change

00:09:09,490 --> 00:09:13,850
so now we've created something a little

00:09:11,569 --> 00:09:16,040
more flexible the rest of the page can

00:09:13,850 --> 00:09:17,569
still be dynamic but this one section we

00:09:16,040 --> 00:09:22,100
can read that whole section out from the

00:09:17,569 --> 00:09:25,399
cache the next level people tend to look

00:09:22,100 --> 00:09:27,079
at our database queries directly so

00:09:25,399 --> 00:09:28,699
looking at just having any database

00:09:27,079 --> 00:09:32,259
query you do getting the results from

00:09:28,699 --> 00:09:35,050
the database and caching those results

00:09:32,259 --> 00:09:37,069
this is a very simple thing to implement

00:09:35,050 --> 00:09:39,560
because you can essentially have a

00:09:37,069 --> 00:09:41,839
database wrapper class that goes through

00:09:39,560 --> 00:09:43,579
and caches every single query you do as

00:09:41,839 --> 00:09:45,889
a very simple straightforward thing and

00:09:43,579 --> 00:09:47,810
if the same query gets run again

00:09:45,889 --> 00:09:52,009
hey you just automatically pull that

00:09:47,810 --> 00:09:54,379
data out of the cache it is simpler it's

00:09:52,009 --> 00:09:56,420
a bit more reusable again because now if

00:09:54,379 --> 00:09:58,910
two pages happen to make the same query

00:09:56,420 --> 00:10:01,639
if two pages said give me all the users

00:09:58,910 --> 00:10:05,329
or give me all the information about

00:10:01,639 --> 00:10:07,550
this particular user two pages may make

00:10:05,329 --> 00:10:10,009
that same query you didn't have to

00:10:07,550 --> 00:10:11,660
realize ahead of time that these two

00:10:10,009 --> 00:10:13,730
pages will be making the exact same

00:10:11,660 --> 00:10:15,079
query and that you would want to have a

00:10:13,730 --> 00:10:17,240
cache to share them you sort of

00:10:15,079 --> 00:10:19,069
magically get that benefit by having

00:10:17,240 --> 00:10:22,720
this generic cache layer in place and

00:10:19,069 --> 00:10:25,750
you get these benefits by default um

00:10:22,720 --> 00:10:28,790
it's still not as flexible though as

00:10:25,750 --> 00:10:30,290
going to what I consider sort of the the

00:10:28,790 --> 00:10:31,699
ultimate level of this but it's the

00:10:30,290 --> 00:10:34,519
painful level and we'll talk a bit more

00:10:31,699 --> 00:10:36,790
about it here in a bit and it's the idea

00:10:34,519 --> 00:10:38,660
of the biggest smallest reusable object

00:10:36,790 --> 00:10:41,540
thanks then we'll go into this in some

00:10:38,660 --> 00:10:43,189
more detail but the idea in general is

00:10:41,540 --> 00:10:46,069
that you're going to try the cache

00:10:43,189 --> 00:10:49,339
process data in its most reusable form

00:10:46,069 --> 00:10:52,579
and the idea is that you want the

00:10:49,339 --> 00:10:56,269
biggest chunk of data that is the most

00:10:52,579 --> 00:10:58,970
reusable so therefore it is the biggest

00:10:56,269 --> 00:11:01,879
chunk that is the smallest of a reusable

00:10:58,970 --> 00:11:03,350
chunk all right and they say I'll go

00:11:01,879 --> 00:11:05,720
into some examples about what that means

00:11:03,350 --> 00:11:07,759
later it's very complicated to code

00:11:05,720 --> 00:11:08,420
because it is very specific to your

00:11:07,759 --> 00:11:09,769
application

00:11:08,420 --> 00:11:11,360
you have to understand how your

00:11:09,769 --> 00:11:14,839
application works you have to understand

00:11:11,360 --> 00:11:17,779
how your application once it's data to

00:11:14,839 --> 00:11:22,459
then be able to go in and write the code

00:11:17,779 --> 00:11:25,300
very specifically to that so a few other

00:11:22,459 --> 00:11:27,440
things I want to cover briefly here

00:11:25,300 --> 00:11:29,149
because the world of caching gets

00:11:27,440 --> 00:11:31,130
actually very complicated there's so

00:11:29,149 --> 00:11:32,180
many different concepts of cache out

00:11:31,130 --> 00:11:34,820
there and so many different layers of

00:11:32,180 --> 00:11:37,250
cache so one thing I want to cover

00:11:34,820 --> 00:11:39,889
briefly is the MySQL query cache I know

00:11:37,250 --> 00:11:41,750
that so many of us in PHP use MySQL and

00:11:39,889 --> 00:11:44,540
other database systems have this same

00:11:41,750 --> 00:11:46,040
concept I've had a lot of people say

00:11:44,540 --> 00:11:47,930
well I don't need to worry about coding

00:11:46,040 --> 00:11:53,389
caching because MySQL takes care of

00:11:47,930 --> 00:11:55,519
caching for me kinda it's great that it

00:11:53,389 --> 00:11:57,529
exists it might give you a benefit but

00:11:55,519 --> 00:12:00,470
never rely upon it as your caching

00:11:57,529 --> 00:12:03,079
methodology the problem with it is it's

00:12:00,470 --> 00:12:06,079
extremely specific to the exact query

00:12:03,079 --> 00:12:09,320
that was given so if a query changes

00:12:06,079 --> 00:12:11,029
ever so slightly it will not get the

00:12:09,320 --> 00:12:12,860
cash yet even if the results were

00:12:11,029 --> 00:12:14,300
basically what you kind of needed and if

00:12:12,860 --> 00:12:16,550
you were coding it yourself you could

00:12:14,300 --> 00:12:18,230
have done a slightly broader query and

00:12:16,550 --> 00:12:20,390
cached it and reused that data multiple

00:12:18,230 --> 00:12:23,120
times if you're just letting the MySQL

00:12:20,390 --> 00:12:25,610
engine run it won't do that but the

00:12:23,120 --> 00:12:27,470
worst problem here is because MySQL

00:12:25,610 --> 00:12:29,390
can't know how your data is actually

00:12:27,470 --> 00:12:31,790
being used it can't know every query

00:12:29,390 --> 00:12:33,589
that has been directly cached and track

00:12:31,790 --> 00:12:36,410
everything down to a single row or a

00:12:33,589 --> 00:12:39,890
single column level is that in the

00:12:36,410 --> 00:12:43,850
update to a single table invalidates

00:12:39,890 --> 00:12:46,459
all caches that touched that table so if

00:12:43,850 --> 00:12:48,980
you have a user's table if you're doing

00:12:46,459 --> 00:12:50,870
a query based on user ID and so you're

00:12:48,980 --> 00:12:53,300
asking for user one asking for user two

00:12:50,870 --> 00:12:54,620
asking for user three my Skrill will

00:12:53,300 --> 00:12:56,480
cache those queries and if you ask for

00:12:54,620 --> 00:12:59,149
user three again you'll get that data

00:12:56,480 --> 00:13:01,790
back right away from its cache but when

00:12:59,149 --> 00:13:04,819
user number 500 changes their email

00:13:01,790 --> 00:13:07,639
address every single cache against the

00:13:04,819 --> 00:13:10,370
users table gets blown away you don't

00:13:07,639 --> 00:13:12,260
have any flexibility to go no only user

00:13:10,370 --> 00:13:17,209
500 needs to have had its cache

00:13:12,260 --> 00:13:22,610
invalidated I also want to talk a little

00:13:17,209 --> 00:13:25,730
bit about nginx fpm PHP fpm and varnish

00:13:22,610 --> 00:13:26,750
this slide sort of a mouthful here but

00:13:25,730 --> 00:13:29,079
I'm just going to touch on them briefly

00:13:26,750 --> 00:13:31,519
because these do get brought often

00:13:29,079 --> 00:13:34,880
engine X is actually a very fast web

00:13:31,519 --> 00:13:37,730
server if you're not familiar with it it

00:13:34,880 --> 00:13:40,100
can however one of its biggest features

00:13:37,730 --> 00:13:43,010
that's often used is that it can also

00:13:40,100 --> 00:13:44,450
act as a proxy and a whole page cache I

00:13:43,010 --> 00:13:46,760
talked before about how if you're going

00:13:44,450 --> 00:13:48,380
to do a whole page cache let a proxy

00:13:46,760 --> 00:13:52,160
handle it for you engine X is a great

00:13:48,380 --> 00:13:54,230
proxy for doing that you can actually

00:13:52,160 --> 00:13:56,540
run engine X on the same server that you

00:13:54,230 --> 00:13:59,209
are running Apache and you can actually

00:13:56,540 --> 00:14:01,279
configure nginx to even have Engine X to

00:13:59,209 --> 00:14:03,800
say all right if the requests that came

00:14:01,279 --> 00:14:06,829
in was for a graphic file or a CSS or a

00:14:03,800 --> 00:14:09,920
JavaScript engine X serve that directly

00:14:06,829 --> 00:14:11,930
don't even touch Apache and PHP and only

00:14:09,920 --> 00:14:16,510
send the other requests through Apache

00:14:11,930 --> 00:14:18,860
and PHP that relieves the load on Apache

00:14:16,510 --> 00:14:21,769
which can help everything run even

00:14:18,860 --> 00:14:24,230
faster as well so nginx can be a very

00:14:21,769 --> 00:14:26,870
good solution for some of that you can't

00:14:24,230 --> 00:14:29,540
actually go one step farther there is

00:14:26,870 --> 00:14:32,209
PHP fpm which is actually a standalone

00:14:29,540 --> 00:14:34,820
process a standalone service that runs

00:14:32,209 --> 00:14:37,670
PHP and through the use of it you can

00:14:34,820 --> 00:14:39,110
actually use nginx to serve PHP directly

00:14:37,670 --> 00:14:40,670
there's a little bit of funky

00:14:39,110 --> 00:14:42,350
configuration there's some great blog

00:14:40,670 --> 00:14:44,329
posts and documentation on the web of

00:14:42,350 --> 00:14:47,240
how to do it just pointing out it's

00:14:44,329 --> 00:14:50,779
possible and I wanted to also mention

00:14:47,240 --> 00:14:53,620
varnish varnish is simply a dedicated

00:14:50,779 --> 00:14:55,730
caching proxy it's open source and it's

00:14:53,620 --> 00:14:58,070
often used instead of engine x

00:14:55,730 --> 00:15:04,699
interchangeably for purely the cache of

00:14:58,070 --> 00:15:09,380
the proxy caching virgil so we've talked

00:15:04,699 --> 00:15:10,959
about cache invalidation and how hard it

00:15:09,380 --> 00:15:14,230
can be so it's actually talked about

00:15:10,959 --> 00:15:17,029
some strategies that people tend to use

00:15:14,230 --> 00:15:18,709
so one of the most common strategies and

00:15:17,029 --> 00:15:20,420
it's the easiest use because it's

00:15:18,709 --> 00:15:23,089
basically built into every caching

00:15:20,420 --> 00:15:27,860
system out there is the idea of simple

00:15:23,089 --> 00:15:30,440
time expiration so with this you're

00:15:27,860 --> 00:15:32,630
simply setting a time for how long that

00:15:30,440 --> 00:15:33,920
cache is going to last right so you're

00:15:32,630 --> 00:15:35,520
saying I'm going to cache this data

00:15:33,920 --> 00:15:37,680
cache it for five minutes

00:15:35,520 --> 00:15:39,840
and you're just going to let that expire

00:15:37,680 --> 00:15:42,360
naturally right so for the next five

00:15:39,840 --> 00:15:44,250
minutes that data you cache is that's

00:15:42,360 --> 00:15:46,020
what it's going to be no updates are

00:15:44,250 --> 00:15:47,430
going to happen it will be stale for

00:15:46,020 --> 00:15:49,710
five minutes it will be stale for a

00:15:47,430 --> 00:15:52,980
minute it can be stale for however long

00:15:49,710 --> 00:15:54,690
you set that to be with any request that

00:15:52,980 --> 00:15:57,000
comes in for that same data sees the

00:15:54,690 --> 00:15:59,880
cached version and uses it after the

00:15:57,000 --> 00:16:01,530
cache expires it itself the next request

00:15:59,880 --> 00:16:03,030
could asked for the cached object the

00:16:01,530 --> 00:16:05,460
cache goes sorry I don't have that

00:16:03,030 --> 00:16:09,510
anymore and so your code goes and

00:16:05,460 --> 00:16:11,190
regenerates the cached info like I said

00:16:09,510 --> 00:16:11,760
this is very simple but it's not very

00:16:11,190 --> 00:16:14,400
flexible

00:16:11,760 --> 00:16:17,010
it also requires you to rely on having

00:16:14,400 --> 00:16:20,070
stale data which may or may not be a

00:16:17,010 --> 00:16:21,810
good solution in your situation the

00:16:20,070 --> 00:16:25,080
other problem that I have in the small

00:16:21,810 --> 00:16:28,470
print down here is that this can cause a

00:16:25,080 --> 00:16:30,810
situation called cache hammering what

00:16:28,470 --> 00:16:32,700
cache hammering in is is the idea that

00:16:30,810 --> 00:16:35,940
say you're getting a hundred requests a

00:16:32,700 --> 00:16:39,120
second let's say that a certain cache

00:16:35,940 --> 00:16:42,420
item has expired say a hundred requests

00:16:39,120 --> 00:16:47,250
happen instantly for that piece of cache

00:16:42,420 --> 00:16:49,620
data 100 copies of your code each talk

00:16:47,250 --> 00:16:51,380
to the cache server and say hello can I

00:16:49,620 --> 00:16:54,300
please have the cached version of this

00:16:51,380 --> 00:16:57,090
your cache server says sorry nothing

00:16:54,300 --> 00:16:59,370
cache gear and so all 100 concurrent

00:16:57,090 --> 00:17:01,500
processes all go through the painful

00:16:59,370 --> 00:17:03,360
process of regenerating the data and

00:17:01,500 --> 00:17:07,770
they all then save it back into the

00:17:03,360 --> 00:17:10,470
cache overwriting each other this is

00:17:07,770 --> 00:17:13,170
officially a problem my personal

00:17:10,470 --> 00:17:17,100
solution to this is to not worry about

00:17:13,170 --> 00:17:18,510
it there are things you can do and I'll

00:17:17,100 --> 00:17:21,780
show you one thing in a little bit if we

00:17:18,510 --> 00:17:23,339
have time about some ways you can handle

00:17:21,780 --> 00:17:25,500
this if you're using locking and some

00:17:23,339 --> 00:17:27,270
other stuff to make it happen in the

00:17:25,500 --> 00:17:30,300
grand scheme of things unless you are

00:17:27,270 --> 00:17:33,390
getting an amazing amount of traffic the

00:17:30,300 --> 00:17:35,840
the fact that you had to rerun that one

00:17:33,390 --> 00:17:38,280
query a hundred times

00:17:35,840 --> 00:17:40,470
- then cache it for the next five

00:17:38,280 --> 00:17:43,710
minutes if you were getting a hundred

00:17:40,470 --> 00:17:45,540
requests every second for that data okay

00:17:43,710 --> 00:17:47,220
so instead of running at once every five

00:17:45,540 --> 00:17:48,870
minutes you're running at a hundred

00:17:47,220 --> 00:17:50,429
times every five minutes

00:17:48,870 --> 00:17:53,010
that's still so much better than running

00:17:50,429 --> 00:17:55,140
it 100 times every single second you've

00:17:53,010 --> 00:17:58,409
still gained so much that the amount of

00:17:55,140 --> 00:18:00,960
extra coding it takes to try to defeat

00:17:58,409 --> 00:18:02,610
this cash hammer I have I have been

00:18:00,960 --> 00:18:05,159
brought into projects to help them out

00:18:02,610 --> 00:18:06,419
where they had so much work trying to

00:18:05,159 --> 00:18:08,760
defeat the cash hammer that it was

00:18:06,419 --> 00:18:11,610
completely constantly invalidating their

00:18:08,760 --> 00:18:12,990
cash and their cash encode was actually

00:18:11,610 --> 00:18:15,779
causing more problems than it was

00:18:12,990 --> 00:18:19,380
helping so yeah just don't worry about

00:18:15,779 --> 00:18:22,080
it the next strategy is update and

00:18:19,380 --> 00:18:24,840
validation this is a proactive approach

00:18:22,080 --> 00:18:26,789
all right the idea here is that any time

00:18:24,840 --> 00:18:30,480
you know that you have updated the

00:18:26,789 --> 00:18:33,720
underlying data you proactively go in

00:18:30,480 --> 00:18:36,980
and expire the cash manually by manually

00:18:33,720 --> 00:18:39,779
I mean in the program not truly by hand

00:18:36,980 --> 00:18:41,070
so in this case you've cashed the

00:18:39,779 --> 00:18:42,450
information about the user like their

00:18:41,070 --> 00:18:44,669
User Profile here they've given you

00:18:42,450 --> 00:18:45,960
their name and maybe the street they

00:18:44,669 --> 00:18:48,299
live on than that kind of stuff and

00:18:45,960 --> 00:18:49,890
whenever they log in you read that in so

00:18:48,299 --> 00:18:52,230
that you can customize some pages based

00:18:49,890 --> 00:18:53,429
upon putting their name up there and so

00:18:52,230 --> 00:18:54,120
you cash the information because that

00:18:53,429 --> 00:18:56,610
information

00:18:54,120 --> 00:18:58,440
rarely changes unless the user goes to

00:18:56,610 --> 00:19:01,200
update their profile information and

00:18:58,440 --> 00:19:04,080
change it well instead of just cashing

00:19:01,200 --> 00:19:06,390
it for five minutes if you know it's not

00:19:04,080 --> 00:19:09,299
going to change except in this one way

00:19:06,390 --> 00:19:12,360
of the user going in and manually

00:19:09,299 --> 00:19:15,090
updating their information you can cache

00:19:12,360 --> 00:19:17,100
that data forever instead so the first

00:19:15,090 --> 00:19:20,010
time you read it in you sent it to the

00:19:17,100 --> 00:19:21,240
cache and say store this forever the

00:19:20,010 --> 00:19:22,260
cache won't really store it forever

00:19:21,240 --> 00:19:24,480
we'll store it until it runs out of

00:19:22,260 --> 00:19:26,730
memory and needs to memory collect but

00:19:24,480 --> 00:19:28,710
you can say store it forever and now if

00:19:26,730 --> 00:19:31,620
that user logs in and updates the

00:19:28,710 --> 00:19:33,779
profile information as you go and save

00:19:31,620 --> 00:19:36,450
that data you go oh wait I know that I

00:19:33,779 --> 00:19:39,210
had this data cached so I'm just going

00:19:36,450 --> 00:19:40,710
to blow away the cache I'm going to

00:19:39,210 --> 00:19:42,899
connect to the cache server and say

00:19:40,710 --> 00:19:45,770
alright this particular cache key blow

00:19:42,899 --> 00:19:47,460
the way I know it's invalid now

00:19:45,770 --> 00:19:50,460
alternatively you can go one step

00:19:47,460 --> 00:19:52,710
farther and don't just expire the cash

00:19:50,460 --> 00:19:54,120
but update it directly so that you're

00:19:52,710 --> 00:19:56,159
essentially never reading from the

00:19:54,120 --> 00:19:57,750
database again you're writing the data

00:19:56,159 --> 00:19:59,880
to the database because they updated

00:19:57,750 --> 00:20:01,409
their last name so you're going to write

00:19:59,880 --> 00:20:02,010
that data to the database but the same

00:20:01,409 --> 00:20:04,020
time

00:20:02,010 --> 00:20:05,760
you just go well I know all the data at

00:20:04,020 --> 00:20:07,410
this point why should I wait for the

00:20:05,760 --> 00:20:09,450
next request to read it back from the

00:20:07,410 --> 00:20:12,320
database let me just go ahead and

00:20:09,450 --> 00:20:16,080
directly update the information in cache

00:20:12,320 --> 00:20:18,270
this can be a very good way to make sure

00:20:16,080 --> 00:20:20,100
that you hit the database as little as

00:20:18,270 --> 00:20:22,260
possible or to hit an API as little as

00:20:20,100 --> 00:20:24,570
possible you do have to be careful with

00:20:22,260 --> 00:20:26,670
this because if somehow the data gets

00:20:24,570 --> 00:20:28,500
out of sync because you're pushing

00:20:26,670 --> 00:20:29,790
information back into the cache and

00:20:28,500 --> 00:20:32,040
you're never reading it back from the

00:20:29,790 --> 00:20:33,840
database or if you have database

00:20:32,040 --> 00:20:35,670
triggers that are changing the data and

00:20:33,840 --> 00:20:38,010
you're not seeing the reflection of that

00:20:35,670 --> 00:20:39,900
or if you have sis at man's who are

00:20:38,010 --> 00:20:41,370
going in and manually changing data in

00:20:39,900 --> 00:20:43,050
the database and your systems never

00:20:41,370 --> 00:20:45,720
picking back up on that you could have

00:20:43,050 --> 00:20:48,330
some problems often if I'm doing this I

00:20:45,720 --> 00:20:50,070
still set time limits on the data so

00:20:48,330 --> 00:20:52,470
I'll do this proactive update but I'll

00:20:50,070 --> 00:20:54,660
still say but you know only be cached

00:20:52,470 --> 00:20:56,400
for an hour so that like at least once

00:20:54,660 --> 00:20:58,860
an hour the data gets refreshed from the

00:20:56,400 --> 00:21:03,330
database and you know that you have

00:20:58,860 --> 00:21:05,310
something fairly up-to-date the next

00:21:03,330 --> 00:21:09,890
level of that moving one step further is

00:21:05,310 --> 00:21:09,890
the idea of pre generation of your cache

00:21:10,010 --> 00:21:16,080
now I can't speak to what some of the

00:21:12,990 --> 00:21:18,980
websites do currently I know back in the

00:21:16,080 --> 00:21:22,950
day Facebook used this very heavily the

00:21:18,980 --> 00:21:25,680
idea is that instead of waiting for a

00:21:22,950 --> 00:21:28,740
request to come in and you to generate a

00:21:25,680 --> 00:21:30,630
cached object based upon that you

00:21:28,740 --> 00:21:32,610
proactively go you know what I know all

00:21:30,630 --> 00:21:37,350
of this information is going to be

00:21:32,610 --> 00:21:39,780
needed so you write a script that simply

00:21:37,350 --> 00:21:42,300
goes through and causes all of this data

00:21:39,780 --> 00:21:44,430
to be cached and to be sitting waiting

00:21:42,300 --> 00:21:47,400
for a request to come and ask to access

00:21:44,430 --> 00:21:48,960
it um like I said I specifically know

00:21:47,400 --> 00:21:51,410
that this happened at Facebook back in

00:21:48,960 --> 00:21:54,150
the day because what they used it for

00:21:51,410 --> 00:21:56,370
was whenever that they ran clusters of

00:21:54,150 --> 00:21:58,950
your servers and they would go and put a

00:21:56,370 --> 00:22:00,420
new cluster of servers up and then they

00:21:58,950 --> 00:22:02,460
would start to route traffic to that

00:22:00,420 --> 00:22:04,380
cluster and they found that when they

00:22:02,460 --> 00:22:07,470
did that performance was horrible for

00:22:04,380 --> 00:22:09,780
about an hour because everyone coming in

00:22:07,470 --> 00:22:11,400
they had no cache of any information so

00:22:09,780 --> 00:22:13,980
every single request was hitting the

00:22:11,400 --> 00:22:14,720
database and slowly over time priming

00:22:13,980 --> 00:22:17,820
the cache

00:22:14,720 --> 00:22:20,100
so they identified what the main things

00:22:17,820 --> 00:22:22,500
that need to be cashed are and they

00:22:20,100 --> 00:22:24,990
wrote a simple script and they built it

00:22:22,500 --> 00:22:27,540
into their push script actually so that

00:22:24,990 --> 00:22:28,890
when they pushed new code before that

00:22:27,540 --> 00:22:31,140
code went live their push script were

00:22:28,890 --> 00:22:33,270
basically pushed the code live it didn't

00:22:31,140 --> 00:22:34,890
ran this script that would actually fire

00:22:33,270 --> 00:22:36,750
off a bunch of the code it would run a

00:22:34,890 --> 00:22:39,150
bunch of the code paths to cause a whole

00:22:36,750 --> 00:22:41,520
bunch of caches to be generated and only

00:22:39,150 --> 00:22:43,230
then would they turn that server live so

00:22:41,520 --> 00:22:45,360
that now that server was brought live

00:22:43,230 --> 00:22:48,630
pre cached and ready to serve things

00:22:45,360 --> 00:22:50,370
fast very rarely are you going to do

00:22:48,630 --> 00:22:52,980
this as its own thing you're going to do

00:22:50,370 --> 00:22:54,960
this on top of having another cache

00:22:52,980 --> 00:22:58,470
invalidation strategy either time-based

00:22:54,960 --> 00:23:00,059
or update based but this is a way to get

00:22:58,470 --> 00:23:03,080
things going from the beginning so that

00:23:00,059 --> 00:23:03,080
you don't have that problem

00:23:03,090 --> 00:23:07,740
I was the second programmer at dig comm

00:23:05,550 --> 00:23:11,670
if anyone remembers that site before it

00:23:07,740 --> 00:23:14,190
became what it is now um and this was

00:23:11,670 --> 00:23:15,809
something we kept meaning to get to but

00:23:14,190 --> 00:23:17,820
we never did because whenever we would

00:23:15,809 --> 00:23:19,110
do a code push and have to like restart

00:23:17,820 --> 00:23:20,940
the servers for any reason

00:23:19,110 --> 00:23:23,880
yeah performance was horrible for about

00:23:20,940 --> 00:23:26,970
an hour but we just kind of went at the

00:23:23,880 --> 00:23:29,970
time because it took work to actually

00:23:26,970 --> 00:23:33,090
like write scripts we had features to

00:23:29,970 --> 00:23:36,480
make um so now that we've talked about

00:23:33,090 --> 00:23:38,040
some of the strategies let's go ahead

00:23:36,480 --> 00:23:41,070
and talk through some of the solutions

00:23:38,040 --> 00:23:42,330
here and specifically how these

00:23:41,070 --> 00:23:44,460
different solutions have different

00:23:42,330 --> 00:23:46,260
features that allow us to do now I can't

00:23:44,460 --> 00:23:47,640
go into extreme detail and the time we

00:23:46,260 --> 00:23:49,110
have but I'm going to just try to touch

00:23:47,640 --> 00:23:53,610
on stuff and again if you have any

00:23:49,110 --> 00:23:57,390
questions come find me afterwards so

00:23:53,610 --> 00:23:59,130
really in PHP there are other solutions

00:23:57,390 --> 00:24:01,230
again I'll say Redis for anyone who

00:23:59,130 --> 00:24:03,059
wants to hear Redis but these are the

00:24:01,230 --> 00:24:06,450
three main things you see being done in

00:24:03,059 --> 00:24:10,410
PHP I mentioned before the APC includes

00:24:06,450 --> 00:24:12,390
a user cache of course APC is now not

00:24:10,410 --> 00:24:14,040
the default off caches and so now we

00:24:12,390 --> 00:24:16,500
don't have a user cache anymore and

00:24:14,040 --> 00:24:18,750
although the user cache is is a cache

00:24:16,500 --> 00:24:22,140
that you it you the user the programmer

00:24:18,750 --> 00:24:24,000
in your application can use there is a

00:24:22,140 --> 00:24:27,270
replacement for that now it's called a

00:24:24,000 --> 00:24:31,920
PC you it's a PEC extension you can

00:24:27,270 --> 00:24:35,340
and it provides the user cash Verta T's

00:24:31,920 --> 00:24:37,800
of a PC without actually having a PC so

00:24:35,340 --> 00:24:39,780
that you can be running any opcode cache

00:24:37,800 --> 00:24:42,450
you want or no opcode cache but install

00:24:39,780 --> 00:24:46,490
a PC you and still have this user space

00:24:42,450 --> 00:24:51,870
cache for yourself now the APC cache is

00:24:46,490 --> 00:24:54,630
an in-memory cache it only however works

00:24:51,870 --> 00:24:56,300
on that specific machine so if you're

00:24:54,630 --> 00:24:58,890
running three different web heads if

00:24:56,300 --> 00:25:01,290
each of them are using the a PC user

00:24:58,890 --> 00:25:05,340
cache they are accessing three different

00:25:01,290 --> 00:25:07,440
caches so therefore the cached copy of a

00:25:05,340 --> 00:25:09,090
certain user for example on one server

00:25:07,440 --> 00:25:11,760
may be different from the one on the

00:25:09,090 --> 00:25:14,730
next and you have to understand that

00:25:11,760 --> 00:25:17,010
when you're going to use a PC there are

00:25:14,730 --> 00:25:18,840
still some real benefits to this one of

00:25:17,010 --> 00:25:21,780
the main benefits of a PC is because

00:25:18,840 --> 00:25:23,340
it's truly built into PHP there is no

00:25:21,780 --> 00:25:24,809
network traffic when you go to save

00:25:23,340 --> 00:25:26,429
something to the cache or read from the

00:25:24,809 --> 00:25:30,570
cache it's all in memory so it's

00:25:26,429 --> 00:25:33,690
ridiculously fast also it can store

00:25:30,570 --> 00:25:36,600
anything because it takes the native PHP

00:25:33,690 --> 00:25:38,940
object from memory and just copies it

00:25:36,600 --> 00:25:42,090
off to memory in another spot

00:25:38,940 --> 00:25:43,679
I will contrast that to memcache or

00:25:42,090 --> 00:25:47,100
memcache D depending on how you like to

00:25:43,679 --> 00:25:49,230
pronounce it memcache is a separate

00:25:47,100 --> 00:25:51,480
service that runs it's a web service and

00:25:49,230 --> 00:25:54,300
you can you communicate to it over a

00:25:51,480 --> 00:25:56,340
protocol I mean it takes care of

00:25:54,300 --> 00:25:57,600
handling its own in memory cache for you

00:25:56,340 --> 00:26:00,750
and takes care of storage and retrieval

00:25:57,600 --> 00:26:03,390
so you can run it you can have multiple

00:26:00,750 --> 00:26:04,860
web heads all talking into it and so

00:26:03,390 --> 00:26:07,770
they can all now be pulling from the

00:26:04,860 --> 00:26:09,480
same cache which is good but the

00:26:07,770 --> 00:26:12,300
drawback to it there is that because

00:26:09,480 --> 00:26:15,210
you're talking over a protocol it has to

00:26:12,300 --> 00:26:18,120
actually take any of that data you had

00:26:15,210 --> 00:26:19,080
in PHP and it has to serialize it if

00:26:18,120 --> 00:26:20,850
you're not from here to Seeler the

00:26:19,080 --> 00:26:22,260
serialization it's taking that PHP

00:26:20,850 --> 00:26:24,840
object and turning it into a text string

00:26:22,260 --> 00:26:25,920
and then sending that across the wire

00:26:24,840 --> 00:26:28,230
and that pulls it back and does the

00:26:25,920 --> 00:26:30,600
opposite that works fine for storing

00:26:28,230 --> 00:26:32,910
basic types and arrays and basic objects

00:26:30,600 --> 00:26:35,250
and standard class type objects but you

00:26:32,910 --> 00:26:37,500
lose anything special that came along

00:26:35,250 --> 00:26:38,310
with that you can't for example have a

00:26:37,500 --> 00:26:41,670
resaw

00:26:38,310 --> 00:26:44,100
and you know cash a resource via

00:26:41,670 --> 00:26:46,530
memcache that way the nice thing about

00:26:44,100 --> 00:26:49,290
min cached is that is designed to run as

00:26:46,530 --> 00:26:51,030
a cluster and to handle failures so you

00:26:49,290 --> 00:26:52,560
can have any number of web servers

00:26:51,030 --> 00:26:54,300
running and then you can separately have

00:26:52,560 --> 00:26:57,630
any number of memcache servers running

00:26:54,300 --> 00:26:59,220
and you simply configure your PHP to say

00:26:57,630 --> 00:27:02,250
okay by the way you have three memcache

00:26:59,220 --> 00:27:03,960
servers here they are and the algorithm

00:27:02,250 --> 00:27:05,700
and the libraries that are built in take

00:27:03,960 --> 00:27:08,400
care of distributing the load across

00:27:05,700 --> 00:27:11,130
them and if one fails redistributing the

00:27:08,400 --> 00:27:12,770
load across those that are left and it's

00:27:11,130 --> 00:27:16,560
very nice that way

00:27:12,770 --> 00:27:19,530
the last one I will mention is caching

00:27:16,560 --> 00:27:22,920
things to the file system please please

00:27:19,530 --> 00:27:23,730
know it's a really bad idea I see it

00:27:22,920 --> 00:27:25,920
done so much

00:27:23,730 --> 00:27:28,230
yes it's very easy especially if you're

00:27:25,920 --> 00:27:31,110
only running one server the problem is

00:27:28,230 --> 00:27:34,170
you're now adding i/o traffic to the

00:27:31,110 --> 00:27:36,540
disk drive on that server that stuff you

00:27:34,170 --> 00:27:38,120
didn't want to happen also as soon as

00:27:36,540 --> 00:27:40,680
you start going to multiple machines

00:27:38,120 --> 00:27:43,380
they now again don't have the same cache

00:27:40,680 --> 00:27:47,150
and it's really really really slow so

00:27:43,380 --> 00:27:47,150
just don't do it please

00:27:47,270 --> 00:27:52,050
so let's talk a little bit more about a

00:27:49,410 --> 00:27:54,900
PC and just look through a couple code

00:27:52,050 --> 00:27:58,290
samples here okay they come up well on

00:27:54,900 --> 00:28:00,090
the screen here so here are just a

00:27:58,290 --> 00:28:02,640
couple common functions of a PC you can

00:28:00,090 --> 00:28:04,260
see the full documentation up there but

00:28:02,640 --> 00:28:05,910
you can see it's fairly unstraight

00:28:04,260 --> 00:28:09,000
forward and how to use so if you want to

00:28:05,910 --> 00:28:12,360
store data you simply call a PC store

00:28:09,000 --> 00:28:14,400
you pass it a key whenever you're doing

00:28:12,360 --> 00:28:16,320
any caching everything is based on a key

00:28:14,400 --> 00:28:18,060
that key can be whatever you want it to

00:28:16,320 --> 00:28:19,890
be it's just texturing but you need to

00:28:18,060 --> 00:28:22,880
generate that key and know what that key

00:28:19,890 --> 00:28:25,530
is to be able to request that key again

00:28:22,880 --> 00:28:27,750
so you have the key you say what you

00:28:25,530 --> 00:28:29,340
want to store is the variable and you

00:28:27,750 --> 00:28:31,800
can optionally give it a time to live

00:28:29,340 --> 00:28:33,630
this is in seconds if you give it time

00:28:31,800 --> 00:28:38,070
to live zero that means it never expires

00:28:33,630 --> 00:28:40,290
until a PC decides to garbage collect so

00:28:38,070 --> 00:28:42,450
that's a PC store you cannot there's

00:28:40,290 --> 00:28:45,840
also a PC ad which is the same as store

00:28:42,450 --> 00:28:48,420
but if the if the variable already

00:28:45,840 --> 00:28:48,720
existed it fails it will only add a new

00:28:48,420 --> 00:28:51,289
one

00:28:48,720 --> 00:28:54,000
it will not overwrite an existing one

00:28:51,289 --> 00:28:57,450
you retrieve something from the cache by

00:28:54,000 --> 00:28:59,970
calling a PC fetch and you can delete an

00:28:57,450 --> 00:29:02,730
existing key by calling a PC delete that

00:28:59,970 --> 00:29:05,039
is how you do the proactive invalidation

00:29:02,730 --> 00:29:06,780
of going okay I know this data has

00:29:05,039 --> 00:29:11,039
updated I'm going to delete this from

00:29:06,780 --> 00:29:14,039
the cache so here's an example that

00:29:11,039 --> 00:29:16,860
would be a very common use case because

00:29:14,039 --> 00:29:19,559
a PC like I said any machine running a

00:29:16,860 --> 00:29:23,340
PC they they include their own cached

00:29:19,559 --> 00:29:25,080
information what that means is typically

00:29:23,340 --> 00:29:27,390
you're going to want to use that for

00:29:25,080 --> 00:29:28,980
something that you want cached because

00:29:27,390 --> 00:29:30,440
you're going to be accessing it very

00:29:28,980 --> 00:29:33,360
often

00:29:30,440 --> 00:29:35,039
however it has to be something that

00:29:33,360 --> 00:29:36,330
really doesn't change all that often

00:29:35,039 --> 00:29:38,340
because you don't want to get things out

00:29:36,330 --> 00:29:40,950
of the sink so a common thing for

00:29:38,340 --> 00:29:43,620
example is to do this for configuration

00:29:40,950 --> 00:29:45,780
files say you store your configuration

00:29:43,620 --> 00:29:48,030
in an ini file or an XML file which is a

00:29:45,780 --> 00:29:50,909
common thing to do you want to read that

00:29:48,030 --> 00:29:53,640
configuration in and that configuration

00:29:50,909 --> 00:29:56,100
is very rarely going to change and if it

00:29:53,640 --> 00:29:59,610
does change you can force a flush of a

00:29:56,100 --> 00:30:01,350
PC to make sure that it works so this is

00:29:59,610 --> 00:30:04,380
just a quick example of how you might do

00:30:01,350 --> 00:30:06,059
that and all this is is it's a simple

00:30:04,380 --> 00:30:10,169
config class that's simply going through

00:30:06,059 --> 00:30:11,700
and saying if a config equals a PC fetch

00:30:10,169 --> 00:30:15,780
and here's our key we're calling our key

00:30:11,700 --> 00:30:18,230
config parsed if that did not exist

00:30:15,780 --> 00:30:21,059
because a PC fetch will return false

00:30:18,230 --> 00:30:23,100
then we're going to simply say simple

00:30:21,059 --> 00:30:25,230
XML load file we're going to load in our

00:30:23,100 --> 00:30:27,299
configuration file we're going to save

00:30:25,230 --> 00:30:29,340
that to the config and then we are going

00:30:27,299 --> 00:30:31,350
to store it in there now one thing

00:30:29,340 --> 00:30:35,340
you'll notice about this is we are not

00:30:31,350 --> 00:30:37,140
storing the raw XML we are storing the

00:30:35,340 --> 00:30:39,870
parsed version of this we're storing the

00:30:37,140 --> 00:30:41,580
simple XML object because we can do that

00:30:39,870 --> 00:30:44,400
in a PC you could not do this in

00:30:41,580 --> 00:30:47,549
memcache in memcache you could store the

00:30:44,400 --> 00:30:50,070
XML but not the already pre parsed

00:30:47,549 --> 00:30:54,600
simple XML object itself this is a great

00:30:50,070 --> 00:30:57,120
use of using a PC here but the important

00:30:54,600 --> 00:31:00,480
lesson here is that it's always best to

00:30:57,120 --> 00:31:01,460
store your data in the manipulated form

00:31:00,480 --> 00:31:04,490
that you need

00:31:01,460 --> 00:31:07,480
as best you can so for example if you

00:31:04,490 --> 00:31:10,370
have a database query you're running if

00:31:07,480 --> 00:31:12,740
you run that query but before you ever

00:31:10,370 --> 00:31:14,779
use the data you have to do a for each

00:31:12,740 --> 00:31:17,600
loop over all the data and like change

00:31:14,779 --> 00:31:19,190
okay actually it was by key value but I

00:31:17,600 --> 00:31:20,510
need it now by value key and so you're

00:31:19,190 --> 00:31:22,130
flipping something around or you're

00:31:20,510 --> 00:31:23,480
changing how it is now that's in the

00:31:22,130 --> 00:31:26,330
format you're going to pass on to a

00:31:23,480 --> 00:31:29,570
helper function cache the version after

00:31:26,330 --> 00:31:31,159
you've manipulated don't constantly go

00:31:29,570 --> 00:31:32,779
back to the cache say okay give me that

00:31:31,159 --> 00:31:34,159
raw database query oh right and now I

00:31:32,779 --> 00:31:36,649
need to manipulate it and change it

00:31:34,159 --> 00:31:38,480
around some do any manipulation you were

00:31:36,649 --> 00:31:43,100
going to do first and save yourself that

00:31:38,480 --> 00:31:44,960
extra work so the APC was very similar

00:31:43,100 --> 00:31:47,029
they're very simple there are a few

00:31:44,960 --> 00:31:50,440
other things you can do but let's look

00:31:47,029 --> 00:31:53,659
at a memcached a little bit here so

00:31:50,440 --> 00:31:56,320
first to add a little confusion there

00:31:53,659 --> 00:31:58,549
are two memcache the libraries in PHP

00:31:56,320 --> 00:32:02,360
one called memcache and one called

00:31:58,549 --> 00:32:04,820
memcached memcache was the original one

00:32:02,360 --> 00:32:07,820
I'm it still there it's very commonly

00:32:04,820 --> 00:32:09,110
available so a lot of open frameworks

00:32:07,820 --> 00:32:12,260
for example were built towards it

00:32:09,110 --> 00:32:16,309
because it's very available however it's

00:32:12,260 --> 00:32:17,899
very limited in functionality the better

00:32:16,309 --> 00:32:20,419
version at this point that much more

00:32:17,899 --> 00:32:22,730
updated one is the memcached with the D

00:32:20,419 --> 00:32:24,590
at the end library it is highly

00:32:22,730 --> 00:32:26,330
recommended you use this one if you go

00:32:24,590 --> 00:32:27,140
and look at the documentation pages you

00:32:26,330 --> 00:32:28,970
will see why

00:32:27,140 --> 00:32:32,059
there is so much more you can do with

00:32:28,970 --> 00:32:34,399
the second one the second one was

00:32:32,059 --> 00:32:38,630
actually partially written in response

00:32:34,399 --> 00:32:40,460
to by Andre to some of the needs that

00:32:38,630 --> 00:32:41,870
digg.com actually had at the time

00:32:40,460 --> 00:32:44,840
because we were using memcache so

00:32:41,870 --> 00:32:46,190
heavily and there were just some weird

00:32:44,840 --> 00:32:49,070
things going on that we needed to work

00:32:46,190 --> 00:32:53,390
around so for the rest of this I'm going

00:32:49,070 --> 00:32:55,250
to be talking about using memcache D so

00:32:53,390 --> 00:32:57,980
to configure it I talked about how you

00:32:55,250 --> 00:33:00,919
end up adding in multiple servers and it

00:32:57,980 --> 00:33:03,409
automatically balances across them you

00:33:00,919 --> 00:33:05,750
do this by using one of two calls either

00:33:03,409 --> 00:33:08,059
you make a call to ads server and you

00:33:05,750 --> 00:33:09,980
specify the host to the port and an

00:33:08,059 --> 00:33:12,350
optional wait I'll talk about that in a

00:33:09,980 --> 00:33:14,960
second or you can pass in an array of

00:33:12,350 --> 00:33:17,899
all this information so

00:33:14,960 --> 00:33:20,360
an example here where we're saying we're

00:33:17,899 --> 00:33:22,309
gonna create a new memcache D and then

00:33:20,360 --> 00:33:24,289
we're gonna call call cache ad servers

00:33:22,309 --> 00:33:26,779
and we're passing in an array and at

00:33:24,289 --> 00:33:28,460
section the array of arrays and yes I'm

00:33:26,779 --> 00:33:32,809
using short of a syntax because I love

00:33:28,460 --> 00:33:34,490
it it's the main reason I upgrade any

00:33:32,809 --> 00:33:35,870
server I touch to latest versions of PHP

00:33:34,490 --> 00:33:40,820
it's because I hate typing array

00:33:35,870 --> 00:33:43,070
parentheses so again we're passing in

00:33:40,820 --> 00:33:45,649
the host the port and a weight

00:33:43,070 --> 00:33:48,710
now what this weight is is it's used by

00:33:45,649 --> 00:33:50,929
the algorithm to determine how much of

00:33:48,710 --> 00:33:54,140
the cache data should be sent to which

00:33:50,929 --> 00:33:56,960
server so if you leave it off because it

00:33:54,140 --> 00:33:58,640
is optional or if you put identical

00:33:56,960 --> 00:34:03,679
values in each of these so if you said

00:33:58,640 --> 00:34:06,470
100 100 100 or 1 1 1 1 then an equal

00:34:03,679 --> 00:34:08,899
amount of data roughly of keys would be

00:34:06,470 --> 00:34:11,080
distributed across them so if you had 3

00:34:08,899 --> 00:34:14,240
servers you set them all at weight 1

00:34:11,080 --> 00:34:17,359
then those 3 servers without equally be

00:34:14,240 --> 00:34:19,159
loaded with data if you happen to have

00:34:17,359 --> 00:34:21,139
servers where you know one server has

00:34:19,159 --> 00:34:23,869
twice as much memory allocated to it

00:34:21,139 --> 00:34:26,060
than the other you can reflect that here

00:34:23,869 --> 00:34:28,099
by giving different weights so in this

00:34:26,060 --> 00:34:31,730
case we've given one server 50 and one

00:34:28,099 --> 00:34:33,379
server 100 so twice as many keys twice

00:34:31,730 --> 00:34:36,290
as much memory usage will be will be

00:34:33,379 --> 00:34:38,210
sent towards that second server really

00:34:36,290 --> 00:34:40,310
the only reason this exists is that you

00:34:38,210 --> 00:34:41,899
have Oder servers like you've added new

00:34:40,310 --> 00:34:43,399
servers over time the new servers have

00:34:41,899 --> 00:34:45,830
more RAM but you still only use the old

00:34:43,399 --> 00:34:47,599
servers they have less and you want to

00:34:45,830 --> 00:34:49,159
be able to reflect that we actually did

00:34:47,599 --> 00:34:50,599
that dig a lot because we had lots of

00:34:49,159 --> 00:34:52,339
old servers since we bought new servers

00:34:50,599 --> 00:34:53,480
they had more RAM that we didn't want to

00:34:52,339 --> 00:34:58,490
throw away the old servers they were

00:34:53,480 --> 00:35:01,250
still useful now to manage memcache this

00:34:58,490 --> 00:35:04,010
is very similar to those APC features

00:35:01,250 --> 00:35:07,460
you just saw these are almost one per

00:35:04,010 --> 00:35:10,880
each but with one interesting thing the

00:35:07,460 --> 00:35:12,740
expiration now you can set the

00:35:10,880 --> 00:35:15,830
expiration to a number of seconds into

00:35:12,740 --> 00:35:18,109
the future you can also pass an a UNIX

00:35:15,830 --> 00:35:20,510
timestamp instead to say no I want this

00:35:18,109 --> 00:35:23,570
data to expire on exactly this UNIX

00:35:20,510 --> 00:35:25,369
timestamp and there's some magic under

00:35:23,570 --> 00:35:26,900
the hood of how it determines if the

00:35:25,369 --> 00:35:28,130
number you passed an

00:35:26,900 --> 00:35:31,579
supposed to be seconds into the future

00:35:28,130 --> 00:35:34,130
or a UNIX timestamp and basically I

00:35:31,579 --> 00:35:36,260
believe it simply comes down to if the

00:35:34,130 --> 00:35:40,250
timestamp you pass in would be in the

00:35:36,260 --> 00:35:42,980
past by a few days it assumes you meant

00:35:40,250 --> 00:35:44,510
seconds into the future and vice-versa

00:35:42,980 --> 00:35:46,099
there's magic but it just works don't

00:35:44,510 --> 00:35:48,349
worry about it

00:35:46,099 --> 00:35:50,450
so the store data you make a call to set

00:35:48,349 --> 00:35:52,130
again you pass in the key you passing

00:35:50,450 --> 00:35:54,920
the value and you pass in the optional

00:35:52,130 --> 00:35:57,230
expiration again passing in zero or no

00:35:54,920 --> 00:36:00,099
or anything like that that evaluates to

00:35:57,230 --> 00:36:04,430
zero means it will never expire

00:36:00,099 --> 00:36:06,440
from a time expiration and again we have

00:36:04,430 --> 00:36:08,630
ADD which does the same but fails if the

00:36:06,440 --> 00:36:11,960
key already existed but now we have a

00:36:08,630 --> 00:36:15,289
few others so we have replaced replace

00:36:11,960 --> 00:36:17,859
will only update an existing key it will

00:36:15,289 --> 00:36:20,240
fail if the key didn't already exist

00:36:17,859 --> 00:36:22,789
there's rare use cases for that but I

00:36:20,240 --> 00:36:24,049
have seen some you have delete to

00:36:22,789 --> 00:36:26,720
invalidate a key

00:36:24,049 --> 00:36:28,970
it doesn't actually free the memory it

00:36:26,720 --> 00:36:32,960
just says that that area is now free to

00:36:28,970 --> 00:36:36,079
be overwritten and get is what you do is

00:36:32,960 --> 00:36:37,579
the equivalent of a PC fetch so again

00:36:36,079 --> 00:36:40,130
it's really fairly straightforward and

00:36:37,579 --> 00:36:44,289
it's all based on key value and

00:36:40,130 --> 00:36:47,180
expiration so here is a simple example

00:36:44,289 --> 00:36:50,089
so I'm going to set value equal to I am

00:36:47,180 --> 00:36:52,430
cashing this I then do cash set I call

00:36:50,089 --> 00:36:54,740
it my key give it the value and I say I

00:36:52,430 --> 00:36:58,130
want to save this for five minutes so 60

00:36:54,740 --> 00:37:00,890
seconds times five I'm then going to do

00:36:58,130 --> 00:37:02,779
result I'm going to get cash get read my

00:37:00,890 --> 00:37:04,760
key in and it should work as long as

00:37:02,779 --> 00:37:07,250
memcache existed as long as it was able

00:37:04,760 --> 00:37:08,720
to connect to your servers you've stored

00:37:07,250 --> 00:37:12,920
the day that you've read the data back

00:37:08,720 --> 00:37:16,520
in and you get exactly what you said now

00:37:12,920 --> 00:37:19,430
if we sleep for one second past how long

00:37:16,520 --> 00:37:22,970
we told it to expire we then attempt to

00:37:19,430 --> 00:37:25,839
read that key back in it will fail it

00:37:22,970 --> 00:37:28,819
will return false when to the call and

00:37:25,839 --> 00:37:30,710
therefore we know okay the day that's

00:37:28,819 --> 00:37:32,510
not cached anymore all right so the

00:37:30,710 --> 00:37:35,150
basic usage is very straightforward you

00:37:32,510 --> 00:37:37,190
sit you set data you get data and it

00:37:35,150 --> 00:37:38,870
magically expires for you if you wish to

00:37:37,190 --> 00:37:41,270
use that

00:37:38,870 --> 00:37:43,370
now here's the part where memcache gives

00:37:41,270 --> 00:37:45,650
you a lot more flexibility and this is

00:37:43,370 --> 00:37:47,570
where if you are writing very custom

00:37:45,650 --> 00:37:49,850
caching things to your application and

00:37:47,570 --> 00:37:52,310
you know how exactly your application is

00:37:49,850 --> 00:37:53,810
going to work and how it needs stuff you

00:37:52,310 --> 00:37:56,510
can start doing a few more interesting

00:37:53,810 --> 00:37:59,360
things so if your value happens to be a

00:37:56,510 --> 00:38:02,330
string there are functions append and

00:37:59,360 --> 00:38:04,250
prepend that allow you to exactly as it

00:38:02,330 --> 00:38:06,740
says add something to the end or read

00:38:04,250 --> 00:38:09,530
something off of something and this is

00:38:06,740 --> 00:38:12,470
an atomic operation so one of the

00:38:09,530 --> 00:38:14,120
problems is if for example multiple

00:38:12,470 --> 00:38:16,190
people are using the website and they

00:38:14,120 --> 00:38:18,680
both create an action that should update

00:38:16,190 --> 00:38:20,510
a certain key if each of those

00:38:18,680 --> 00:38:22,760
operations read in the key tried to

00:38:20,510 --> 00:38:24,230
update the key and save the key back one

00:38:22,760 --> 00:38:27,020
of them would when one of them would

00:38:24,230 --> 00:38:30,800
overwrite the other person's value these

00:38:27,020 --> 00:38:32,810
are atomic operations so if two people

00:38:30,800 --> 00:38:35,720
came in two people did actions that

00:38:32,810 --> 00:38:38,180
would require something to be appended

00:38:35,720 --> 00:38:39,710
to the end of this both the pins would

00:38:38,180 --> 00:38:42,200
work you couldn't necessarily guarantee

00:38:39,710 --> 00:38:44,720
the order but they would both work and

00:38:42,200 --> 00:38:46,760
that data would be appended I have

00:38:44,720 --> 00:38:50,240
actually used this once again it was at

00:38:46,760 --> 00:38:52,760
Digg where at one point we were caching

00:38:50,240 --> 00:38:55,130
information about friend relationships

00:38:52,760 --> 00:38:57,590
so like who all is this users friends

00:38:55,130 --> 00:39:00,170
and we found through a lot of

00:38:57,590 --> 00:39:03,230
manipulation and testing that it was

00:39:00,170 --> 00:39:06,530
more efficient for us to not cache that

00:39:03,230 --> 00:39:10,100
as an array of integers but to turn it

00:39:06,530 --> 00:39:12,710
into a CSV and cache it as a string by

00:39:10,100 --> 00:39:14,800
caching it as a CSV string that meant

00:39:12,710 --> 00:39:18,740
that if you went and added a new friend

00:39:14,800 --> 00:39:21,080
all we had to do was append comma and

00:39:18,740 --> 00:39:24,110
the ID of that friend to their already

00:39:21,080 --> 00:39:25,280
cached value and you could be add that

00:39:24,110 --> 00:39:27,110
you could be logged into multiple

00:39:25,280 --> 00:39:28,850
machines with your account or in

00:39:27,110 --> 00:39:30,590
multiple browsers and trying to break

00:39:28,850 --> 00:39:32,630
our website by adding friends all around

00:39:30,590 --> 00:39:34,610
and it wouldn't matter we could

00:39:32,630 --> 00:39:37,340
constantly just be appending to the CSV

00:39:34,610 --> 00:39:41,360
I'm not saying that's a common use case

00:39:37,340 --> 00:39:43,580
but it was at least one that existed if

00:39:41,360 --> 00:39:45,950
it's an integer you can also go in and

00:39:43,580 --> 00:39:48,230
increment or decrement values and again

00:39:45,950 --> 00:39:49,680
same idea you're just saying I want to

00:39:48,230 --> 00:39:53,480
add three to this I want to

00:39:49,680 --> 00:39:55,770
from this I've seen this used often

00:39:53,480 --> 00:39:57,029
specifically in making counters so

00:39:55,770 --> 00:39:58,470
you're going to use memcache as a way to

00:39:57,029 --> 00:40:00,720
like count how many times someone has

00:39:58,470 --> 00:40:02,510
failed the login or how many times

00:40:00,720 --> 00:40:05,010
someone's logged in in the last 24 hours

00:40:02,510 --> 00:40:07,289
this is a very easy way to just use

00:40:05,010 --> 00:40:13,650
memcache as a generic across all of your

00:40:07,289 --> 00:40:16,319
servers counter there's an idea of the

00:40:13,650 --> 00:40:18,539
read through cache callback all right

00:40:16,319 --> 00:40:20,250
and this gets kind of funky again it may

00:40:18,539 --> 00:40:21,630
be confusing come talk to me later

00:40:20,250 --> 00:40:25,230
because I want to make sure I get

00:40:21,630 --> 00:40:27,270
through all of this here so the idea

00:40:25,230 --> 00:40:30,299
when you do a gift there is an optional

00:40:27,270 --> 00:40:33,750
second parameter to which you can pass

00:40:30,299 --> 00:40:35,970
in a function the idea here is that so

00:40:33,750 --> 00:40:39,630
I'm making a call to cache get and get

00:40:35,970 --> 00:40:42,119
user 1 2 3 4 if that cached value did

00:40:39,630 --> 00:40:44,579
not exist since I passed in a function

00:40:42,119 --> 00:40:46,170
as a second parameter it's going to run

00:40:44,579 --> 00:40:49,230
that second print it's going to run that

00:40:46,170 --> 00:40:52,559
function and within that function I can

00:40:49,230 --> 00:40:56,069
declare how to recreate the value of K

00:40:52,559 --> 00:40:58,230
of user 1 dot 2 3 4 right so instead of

00:40:56,069 --> 00:41:00,660
building your code to say is this cache

00:40:58,230 --> 00:41:02,760
if not run this database query ok now

00:41:00,660 --> 00:41:05,579
come back you can build it all into one

00:41:02,760 --> 00:41:08,250
call by basically building in a function

00:41:05,579 --> 00:41:09,660
so in this case we're simply saying

00:41:08,250 --> 00:41:11,730
we're looking at the key that gets

00:41:09,660 --> 00:41:14,910
passed in we're removing the user dot

00:41:11,730 --> 00:41:16,920
dot to say 1 2 3 4 we're declaring a

00:41:14,910 --> 00:41:19,950
value of new user passing in the user ID

00:41:16,920 --> 00:41:24,390
and the trick here is that if you return

00:41:19,950 --> 00:41:26,069
true then the value if you changed it

00:41:24,390 --> 00:41:28,920
here note that this is passed by value

00:41:26,069 --> 00:41:30,809
the value you changed is what not only

00:41:28,920 --> 00:41:35,520
gets stored in memcache but is what gets

00:41:30,809 --> 00:41:40,049
returned from the entire operation like

00:41:35,520 --> 00:41:43,589
I said this gets kind of funky I'll

00:41:40,049 --> 00:41:46,260
leave it there there are also these

00:41:43,589 --> 00:41:47,520
ideas of check and set I don't want to

00:41:46,260 --> 00:41:49,500
spend a lot of time on this because this

00:41:47,520 --> 00:41:51,690
gets even more so but this is if you

00:41:49,500 --> 00:41:54,000
want to go look it up this is how you

00:41:51,690 --> 00:41:56,609
create you've solved the problem of

00:41:54,000 --> 00:41:59,640
cache hammering because basically this

00:41:56,609 --> 00:42:02,309
gives you the ability for you to read

00:41:59,640 --> 00:42:02,840
data and then to say all right I want to

00:42:02,309 --> 00:42:05,000
save

00:42:02,840 --> 00:42:07,130
stay back but only if no one else has

00:42:05,000 --> 00:42:09,590
updated that data in the cache since I

00:42:07,130 --> 00:42:11,240
read it and this allows that case of a

00:42:09,590 --> 00:42:13,400
hundred different people going I need to

00:42:11,240 --> 00:42:15,170
regenerate this cache and not having

00:42:13,400 --> 00:42:17,300
them all step over each other trying to

00:42:15,170 --> 00:42:18,620
write it back to the cache it doesn't

00:42:17,300 --> 00:42:22,400
stop them all from reading it from the

00:42:18,620 --> 00:42:25,930
database but it at least it's a way for

00:42:22,400 --> 00:42:25,930
you to stop them from going back through

00:42:26,770 --> 00:42:31,340
one very cool feature that memcached D

00:42:29,750 --> 00:42:33,650
added and that the original memcache

00:42:31,340 --> 00:42:36,680
library didn't have is the idea of

00:42:33,650 --> 00:42:39,890
asynchronous lookups so there is a call

00:42:36,680 --> 00:42:42,860
called get delayed get delay it allows

00:42:39,890 --> 00:42:45,320
you to pass in an array of keys to say I

00:42:42,860 --> 00:42:46,910
want all of these keys maybe there's a

00:42:45,320 --> 00:42:48,590
hundred different users information you

00:42:46,910 --> 00:42:50,930
want to load up at once instead of just

00:42:48,590 --> 00:42:52,790
iterating through them you can say give

00:42:50,930 --> 00:42:54,380
me all 100 of these regardless of what

00:42:52,790 --> 00:42:56,870
servers they're on and how they're

00:42:54,380 --> 00:42:58,850
distributed and all that I'll ask for

00:42:56,870 --> 00:43:00,170
them later when I'm ready so you can do

00:42:58,850 --> 00:43:03,470
this at the top of your script and then

00:43:00,170 --> 00:43:05,300
go off and do other things and then you

00:43:03,470 --> 00:43:06,260
can read them in once you now are at the

00:43:05,300 --> 00:43:08,630
point in your script where you

00:43:06,260 --> 00:43:10,280
absolutely need that data it's been off

00:43:08,630 --> 00:43:13,130
fetching that information and unsee

00:43:10,280 --> 00:43:15,200
realizing it in the background and now

00:43:13,130 --> 00:43:17,240
via the use of either fetch or fetch all

00:43:15,200 --> 00:43:19,160
you can retrieve these so you can call

00:43:17,240 --> 00:43:21,380
fetch all when you're ready for them and

00:43:19,160 --> 00:43:23,270
at that point it will block and wait

00:43:21,380 --> 00:43:26,330
till all that data is ready and return

00:43:23,270 --> 00:43:29,990
it all to you or you can loop through

00:43:26,330 --> 00:43:32,410
calling fetch and fetch will return one

00:43:29,990 --> 00:43:34,760
answer at a time as they are available

00:43:32,410 --> 00:43:36,860
if you're looping through with fetch you

00:43:34,760 --> 00:43:39,020
actually have to do this extra call so

00:43:36,860 --> 00:43:42,050
essentially you loop by doing while get

00:43:39,020 --> 00:43:45,320
result code and you check for memcached

00:43:42,050 --> 00:43:48,670
: : res end and that's how you know that

00:43:45,320 --> 00:43:50,810
it's finally done with all the data

00:43:48,670 --> 00:43:52,580
again a lot of this gets very

00:43:50,810 --> 00:43:54,770
complicated here and I don't have that

00:43:52,580 --> 00:43:56,990
much time to get into all of it I just

00:43:54,770 --> 00:43:59,690
want to show you what's possible here

00:43:56,990 --> 00:44:01,760
and there's a bunch of others I'm just

00:43:59,690 --> 00:44:03,860
going to mention there are other you can

00:44:01,760 --> 00:44:06,890
get set and delete multiple keys at once

00:44:03,860 --> 00:44:08,870
with the multi options these are not

00:44:06,890 --> 00:44:12,530
asynchronous these happen in these wait

00:44:08,870 --> 00:44:14,840
until they finish you can reset the

00:44:12,530 --> 00:44:15,670
cache expiry without changing the data

00:44:14,840 --> 00:44:17,809
by using

00:44:15,670 --> 00:44:19,939
it's equivalent doing a eunuchs touch

00:44:17,809 --> 00:44:22,519
you're saying alright touch update your

00:44:19,939 --> 00:44:24,170
expiration to five more minutes and you

00:44:22,519 --> 00:44:26,329
can make a call to flush which will

00:44:24,170 --> 00:44:27,049
validate the entire cache at once you

00:44:26,329 --> 00:44:29,989
can say all right

00:44:27,049 --> 00:44:32,329
everything invalidate it now or you can

00:44:29,989 --> 00:44:35,199
pass in a delay and say all right

00:44:32,329 --> 00:44:37,430
invalidate everything in five minutes

00:44:35,199 --> 00:44:38,299
it's kind of setting the self-destruct

00:44:37,430 --> 00:44:44,959
signal with a countdown

00:44:38,299 --> 00:44:46,729
I want to go into a couple combination

00:44:44,959 --> 00:44:51,650
techniques here with what time I have

00:44:46,729 --> 00:44:55,189
left this is just a quick database

00:44:51,650 --> 00:44:56,839
caching example to show how you would do

00:44:55,189 --> 00:45:00,229
this to cache the output directly of a

00:44:56,839 --> 00:45:02,420
database query so we have a function to

00:45:00,229 --> 00:45:03,680
get a user we are passing in the

00:45:02,420 --> 00:45:05,660
database connection that's going to be a

00:45:03,680 --> 00:45:08,299
PDO or passing in the cache connection

00:45:05,660 --> 00:45:09,890
which is from M cached and we're simply

00:45:08,299 --> 00:45:11,359
going and this is sort of the standard

00:45:09,890 --> 00:45:13,189
how you would do this you're going to go

00:45:11,359 --> 00:45:15,650
in and say you're going to try to get

00:45:13,189 --> 00:45:17,839
your going to generate the key based on

00:45:15,650 --> 00:45:20,689
the user ID so the key is going to be

00:45:17,839 --> 00:45:23,089
user dot user ID you're then going to

00:45:20,689 --> 00:45:25,400
attempt to read that from the cache if

00:45:23,089 --> 00:45:28,179
it existed you skip all this and just

00:45:25,400 --> 00:45:31,130
return the user if it did not exist

00:45:28,179 --> 00:45:32,779
we're now going to generate our database

00:45:31,130 --> 00:45:34,849
statement that will read that users

00:45:32,779 --> 00:45:36,380
information back in we're going to

00:45:34,849 --> 00:45:37,849
execute it we're going to fetch the

00:45:36,380 --> 00:45:39,769
information as an object and we're going

00:45:37,849 --> 00:45:40,390
to now store it into the cache for five

00:45:39,769 --> 00:45:42,439
minutes

00:45:40,390 --> 00:45:44,359
alright this is sort of just the very

00:45:42,439 --> 00:45:48,380
much straightforward how you're going to

00:45:44,359 --> 00:45:50,630
do this you can turn this into a more

00:45:48,380 --> 00:45:52,489
generic example if you want to something

00:45:50,630 --> 00:45:55,849
you could use to cache pretty much any

00:45:52,489 --> 00:45:57,349
database query it now looks a little

00:45:55,849 --> 00:46:00,019
more different because this is now a

00:45:57,349 --> 00:46:02,329
generic cached single row this will only

00:46:00,019 --> 00:46:05,839
work assuming you get one row out so if

00:46:02,329 --> 00:46:07,309
you're doing an ID based lookup but now

00:46:05,839 --> 00:46:09,380
you're passing in the query you're

00:46:07,309 --> 00:46:10,819
passing in your bind variables for your

00:46:09,380 --> 00:46:13,489
prepared statement because everyone's

00:46:10,819 --> 00:46:17,509
using prepared statements right everyone

00:46:13,489 --> 00:46:19,579
nod okay and so what we're going to do

00:46:17,509 --> 00:46:21,319
is we're going to generate the key we

00:46:19,579 --> 00:46:23,509
have to have a unique key we can always

00:46:21,319 --> 00:46:27,019
refer back to so if this same query and

00:46:23,509 --> 00:46:28,880
same bind parameters are passed in we

00:46:27,019 --> 00:46:29,430
need to realize we have a cached version

00:46:28,880 --> 00:46:31,680
of this

00:46:29,430 --> 00:46:33,390
so what we're doing is we're generating

00:46:31,680 --> 00:46:35,550
a key by saying we're going to call the

00:46:33,390 --> 00:46:38,369
key single query and we're going to

00:46:35,550 --> 00:46:41,250
append to that an md5 of the actual

00:46:38,369 --> 00:46:43,500
sequel statement that came in and an md5

00:46:41,250 --> 00:46:46,800
of all the bind variables imploded

00:46:43,500 --> 00:46:48,990
together we have now generated a key

00:46:46,800 --> 00:46:50,940
it's a key we don't know what it is but

00:46:48,990 --> 00:46:53,369
we can be generated every single time if

00:46:50,940 --> 00:46:56,280
the same query is passed in and the same

00:46:53,369 --> 00:46:57,780
bind array this will generate the same

00:46:56,280 --> 00:47:01,050
key and we'll be able to know this oh

00:46:57,780 --> 00:47:02,640
we've done exactly this query before all

00:47:01,050 --> 00:47:04,470
right and beyond that it's the same

00:47:02,640 --> 00:47:10,559
thing we try to get if we fail we

00:47:04,470 --> 00:47:13,050
prepare we fetch we set all right there

00:47:10,559 --> 00:47:16,260
is also this idea of a multi-layer cache

00:47:13,050 --> 00:47:18,329
I will just touch on this briefly I do

00:47:16,260 --> 00:47:19,859
have a code sample but you can download

00:47:18,329 --> 00:47:21,450
that off the web to look at it cuz it's

00:47:19,859 --> 00:47:24,210
really big

00:47:21,450 --> 00:47:25,770
the idea is layering and this is again

00:47:24,210 --> 00:47:28,859
something I know that Facebook did and

00:47:25,770 --> 00:47:31,440
the idea here is that you have multiple

00:47:28,859 --> 00:47:34,220
layers of cache based upon how quick the

00:47:31,440 --> 00:47:37,109
access is and how stale the data can be

00:47:34,220 --> 00:47:40,109
so a typical one would be the idea of

00:47:37,109 --> 00:47:42,540
having cache where you store the data

00:47:40,109 --> 00:47:44,369
inside of the PHP instance so if you

00:47:42,540 --> 00:47:47,160
request the same data within the same

00:47:44,369 --> 00:47:48,569
request twice you get the exact same

00:47:47,160 --> 00:47:51,690
data back instantly you don't touch

00:47:48,569 --> 00:47:53,880
anything you also store the data in a PC

00:47:51,690 --> 00:47:56,099
with a very quick expiration because

00:47:53,880 --> 00:47:57,630
again different APCs could have

00:47:56,099 --> 00:47:59,940
different amounts of staleness and get

00:47:57,630 --> 00:48:02,130
out of sync and you store the data in

00:47:59,940 --> 00:48:04,770
memcache and then you store it in the

00:48:02,130 --> 00:48:07,380
database and so whenever someone

00:48:04,770 --> 00:48:09,780
requests the data you say do I have a

00:48:07,380 --> 00:48:12,270
copy in the instance if not do I have a

00:48:09,780 --> 00:48:13,650
copy in a PC if not do I have a copy in

00:48:12,270 --> 00:48:16,079
memcache if not read it from the

00:48:13,650 --> 00:48:17,730
database and then any level the day that

00:48:16,079 --> 00:48:20,730
I didn't have write it back out to those

00:48:17,730 --> 00:48:25,230
specific levels like I said this can get

00:48:20,730 --> 00:48:27,599
very complicated this code is actually a

00:48:25,230 --> 00:48:29,160
copy of code out of an open source

00:48:27,599 --> 00:48:31,280
framework I've put out there called TREB

00:48:29,160 --> 00:48:33,180
so you can also see it in action there

00:48:31,280 --> 00:48:36,599
but I'm not even going to attempt to go

00:48:33,180 --> 00:48:37,950
through that on the screen here so a few

00:48:36,599 --> 00:48:40,130
parting thoughts here to walk through

00:48:37,950 --> 00:48:40,130
this

00:48:40,650 --> 00:48:46,420
do not store anything in cash that you

00:48:43,690 --> 00:48:49,630
cannot recreate from another source okay

00:48:46,420 --> 00:48:54,640
cash is transient cash servers will fail

00:48:49,630 --> 00:48:55,690
especially if their memcached they will

00:48:54,640 --> 00:48:57,309
fail for news and their thought just

00:48:55,690 --> 00:48:59,259
stop responding for a few seconds and

00:48:57,309 --> 00:49:00,880
then come back and go on back again so

00:48:59,259 --> 00:49:03,009
never store something in cash that's

00:49:00,880 --> 00:49:05,019
important and that you cannot recreate

00:49:03,009 --> 00:49:06,569
all right always have like a database

00:49:05,019 --> 00:49:10,660
storage

00:49:06,569 --> 00:49:13,589
beware the almighty false in memcached

00:49:10,660 --> 00:49:16,059
for example and cannot store false

00:49:13,589 --> 00:49:18,400
because false is what gets returned if

00:49:16,059 --> 00:49:20,799
the data wasn't there so if you try the

00:49:18,400 --> 00:49:21,970
store Foss you get back Foss and you

00:49:20,799 --> 00:49:23,140
don't know whether that's because the

00:49:21,970 --> 00:49:26,349
data wasn't there because you actually

00:49:23,140 --> 00:49:28,450
stored Foss you can however store null

00:49:26,349 --> 00:49:30,670
so if you're trying to truly store a

00:49:28,450 --> 00:49:35,109
boolean check to know if something's

00:49:30,670 --> 00:49:37,059
true or false store true or null so that

00:49:35,109 --> 00:49:39,880
way you can check if null is returned

00:49:37,059 --> 00:49:42,999
that means the data was stored as a Foss

00:49:39,880 --> 00:49:47,769
if fosters comes back that means the

00:49:42,999 --> 00:49:49,660
data wasn't even there you can also

00:49:47,769 --> 00:49:51,670
consider a caching much more

00:49:49,660 --> 00:49:53,049
aggressively for an anonymous user than

00:49:51,670 --> 00:49:55,299
for a logged in user this is again

00:49:53,049 --> 00:49:58,739
something we did it dig if you were just

00:49:55,299 --> 00:49:58,739
browsing the website anonymously

00:49:58,890 --> 00:50:03,009
everything you saw was like 15 minutes

00:50:01,329 --> 00:50:05,890
out of date it was heavily heavily

00:50:03,009 --> 00:50:08,259
cached but as soon as you logged in you

00:50:05,890 --> 00:50:12,160
got much more up-to-date information all

00:50:08,259 --> 00:50:13,630
right another thing to consider and this

00:50:12,160 --> 00:50:15,910
is something I know that Twitter does is

00:50:13,630 --> 00:50:18,849
consider having in your configuration

00:50:15,910 --> 00:50:22,180
file somewhere your cache expiration to

00:50:18,849 --> 00:50:23,950
be configurable the what Twitter does

00:50:22,180 --> 00:50:27,400
with this is if they're under a lot of

00:50:23,950 --> 00:50:28,869
load for some reason they'll just make

00:50:27,400 --> 00:50:30,880
all their caches last longer so

00:50:28,869 --> 00:50:33,309
everyone's getting slightly more stale

00:50:30,880 --> 00:50:37,799
data but the websites up and it's better

00:50:33,309 --> 00:50:37,799
to have your website up than to go down

00:50:38,069 --> 00:50:42,460
you can also consider adding a

00:50:40,420 --> 00:50:45,369
configurable prefix to all of your keys

00:50:42,460 --> 00:50:48,460
so if you write a cache wrapping library

00:50:45,369 --> 00:50:49,799
you can inject some prefix in front of

00:50:48,460 --> 00:50:52,359
every key that's

00:50:49,799 --> 00:50:54,660
the benefit of this is that means you

00:50:52,359 --> 00:50:56,980
can simply change that key and

00:50:54,660 --> 00:50:59,500
essentially invalidate all of your cash

00:50:56,980 --> 00:51:01,059
without actually sending a flush command

00:50:59,500 --> 00:51:03,400
to your cash which is a kind of painful

00:51:01,059 --> 00:51:05,770
thing right and you can actually set it

00:51:03,400 --> 00:51:07,890
up so that when every code push in your

00:51:05,770 --> 00:51:10,630
configuration file you put a new key and

00:51:07,890 --> 00:51:12,460
that way with every code push all old

00:51:10,630 --> 00:51:14,260
data is instantly invalidated you never

00:51:12,460 --> 00:51:16,359
get old data that doesn't match what the

00:51:14,260 --> 00:51:17,289
old code was expecting which is never a

00:51:16,359 --> 00:51:21,039
good thing

00:51:17,289 --> 00:51:22,450
experience there and again I talked

00:51:21,039 --> 00:51:26,230
before about this biggest smallest

00:51:22,450 --> 00:51:27,819
reusable this is actually a really

00:51:26,230 --> 00:51:31,660
important thing it can be very tough to

00:51:27,819 --> 00:51:34,569
do I'm getting the nod over there if I

00:51:31,660 --> 00:51:36,160
need to wrap up this is my last real

00:51:34,569 --> 00:51:38,260
slide and I wanna tell you one story

00:51:36,160 --> 00:51:40,599
real quick and he can come and pull me

00:51:38,260 --> 00:51:42,309
off if he needs to so the story here

00:51:40,599 --> 00:51:43,599
again I keep mentioning dig but just

00:51:42,309 --> 00:51:47,589
because I did deal with so much of this

00:51:43,599 --> 00:51:50,890
at dig so the story here was that our

00:51:47,589 --> 00:51:52,630
biggest pain in the side at dig was the

00:51:50,890 --> 00:51:54,339
little tiny green flag if anyone

00:51:52,630 --> 00:51:56,740
remembers that if any one of your

00:51:54,339 --> 00:51:58,510
friends had dug a story this little

00:51:56,740 --> 00:52:01,630
green flag appeared on the corner that

00:51:58,510 --> 00:52:03,250
story to let you know about that that

00:52:01,630 --> 00:52:05,950
one feature was the bane of all

00:52:03,250 --> 00:52:07,960
performance because it meant for every

00:52:05,950 --> 00:52:11,319
screen we displayed for everything that

00:52:07,960 --> 00:52:13,000
came up right we had to look at every

00:52:11,319 --> 00:52:15,220
single person you were a friend with you

00:52:13,000 --> 00:52:17,020
might have a thousand friends look at

00:52:15,220 --> 00:52:19,569
their entire history of everything

00:52:17,020 --> 00:52:21,460
they've ever dug and compared against

00:52:19,569 --> 00:52:23,890
the 15 stories we're showing on this one

00:52:21,460 --> 00:52:27,760
page just to put a little green flag on

00:52:23,890 --> 00:52:30,400
there and we went through numerous ways

00:52:27,760 --> 00:52:32,170
of trying to figure this out and what we

00:52:30,400 --> 00:52:34,089
found in the end was that caching

00:52:32,170 --> 00:52:36,190
smaller reusable chunks became the

00:52:34,089 --> 00:52:37,750
solution so instead of when you logged

00:52:36,190 --> 00:52:40,510
in instead of reading in all of your

00:52:37,750 --> 00:52:42,430
users and all of all of your friends and

00:52:40,510 --> 00:52:43,869
all of all the stories that all your

00:52:42,430 --> 00:52:46,539
friends had dug and storing that into

00:52:43,869 --> 00:52:48,760
one massive chunk of data which worked

00:52:46,539 --> 00:52:50,680
but took a lot of time and eventually

00:52:48,760 --> 00:52:51,819
some people had so many friends that

00:52:50,680 --> 00:52:53,980
that got bigger than the largest

00:52:51,819 --> 00:52:57,309
storable cached object and memcached and

00:52:53,980 --> 00:52:59,700
that stopped working is instead when you

00:52:57,309 --> 00:53:02,890
logged in if you had a thousand friends

00:52:59,700 --> 00:53:06,040
we made 1,001 queries for you

00:53:02,890 --> 00:53:07,690
because we made one query to say give me

00:53:06,040 --> 00:53:09,640
all the fruit user IDs this person's

00:53:07,690 --> 00:53:11,140
friends with and then for every single

00:53:09,640 --> 00:53:13,630
friend we made a query saying give me

00:53:11,140 --> 00:53:15,340
all the stories this person is Doug but

00:53:13,630 --> 00:53:17,050
the catch was that's a horrible stupid

00:53:15,340 --> 00:53:19,300
idea because we've gone from having one

00:53:17,050 --> 00:53:20,980
query to a thousand and one but we

00:53:19,300 --> 00:53:23,680
cached each of those individually and

00:53:20,980 --> 00:53:25,480
now when the second user logged in and

00:53:23,680 --> 00:53:27,760
they had 500 of the same friends as I

00:53:25,480 --> 00:53:29,770
did we already have the information on

00:53:27,760 --> 00:53:31,120
those 500 friends we only need to make

00:53:29,770 --> 00:53:32,380
five hundred and one queries and then

00:53:31,120 --> 00:53:34,270
the next person logged in the next

00:53:32,380 --> 00:53:36,100
person logged in and so in practice

00:53:34,270 --> 00:53:38,860
because we had so many people in all the

00:53:36,100 --> 00:53:41,740
time on average we only had to make it

00:53:38,860 --> 00:53:43,900
was like 2.4 queries per user when they

00:53:41,740 --> 00:53:47,350
logged in and they were now these very

00:53:43,900 --> 00:53:49,930
small very tiny queries all right and I

00:53:47,350 --> 00:53:51,070
am definitely out of time so a very

00:53:49,930 --> 00:53:52,570
brief commercial interruption if you

00:53:51,070 --> 00:53:54,580
didn't know our magazines back in print

00:53:52,570 --> 00:53:56,200
I have some up here you can touch and

00:53:54,580 --> 00:53:57,910
pet and feel and they're very nice I

00:53:56,200 --> 00:53:59,110
mean it you need to I have a couple I

00:53:57,910 --> 00:54:02,560
could maybe even give away for free if

00:53:59,110 --> 00:54:04,180
you begged nicely if you would please

00:54:02,560 --> 00:54:05,110
rate this talk I really would love

00:54:04,180 --> 00:54:08,250
feedback on it

00:54:05,110 --> 00:54:10,090
it's how we all grow as speakers and

00:54:08,250 --> 00:54:11,800
thank you very much are there any

00:54:10,090 --> 00:54:16,780
questions for what time I have left for

00:54:11,800 --> 00:54:17,710
them say well there I think there's

00:54:16,780 --> 00:54:26,350
someone with a microphone will come

00:54:17,710 --> 00:54:28,090
around to you over there hi so you

00:54:26,350 --> 00:54:31,150
mentioned that one of the downsides of

00:54:28,090 --> 00:54:33,010
memcache sea is that you couldn't what

00:54:31,150 --> 00:54:35,980
everything that you store get start form

00:54:33,010 --> 00:54:39,700
into a string but all the examples that

00:54:35,980 --> 00:54:45,090
you did were actual objects what what

00:54:39,700 --> 00:54:47,380
cases right so the question was I

00:54:45,090 --> 00:54:49,750
mentioned the downside of memcache T is

00:54:47,380 --> 00:54:51,910
that everything gets serialized into a

00:54:49,750 --> 00:54:56,920
string and back but all my examples were

00:54:51,910 --> 00:54:59,530
doing objects the downside specifically

00:54:56,920 --> 00:55:01,620
so it works as long as what you are

00:54:59,530 --> 00:55:04,270
storing is a standard object type

00:55:01,620 --> 00:55:05,980
situation essentially any object that

00:55:04,270 --> 00:55:08,710
you're going to store into memcache gets

00:55:05,980 --> 00:55:11,080
stored as a standard object all rights

00:55:08,710 --> 00:55:13,120
are standard class in PHP so it's a

00:55:11,080 --> 00:55:14,650
class without any other information it

00:55:13,120 --> 00:55:16,750
has no methods in it

00:55:14,650 --> 00:55:20,050
it has no extra stuff it's just the raw

00:55:16,750 --> 00:55:22,720
data that comes out so for example if

00:55:20,050 --> 00:55:24,730
you're pulling in information out of XML

00:55:22,720 --> 00:55:26,950
or if you're pulling information from

00:55:24,730 --> 00:55:28,780
the database doing a fetch object what P

00:55:26,950 --> 00:55:31,060
do is giving you back is just a standard

00:55:28,780 --> 00:55:34,210
object class anyway because it's just a

00:55:31,060 --> 00:55:36,130
raw data object so that works fine the

00:55:34,210 --> 00:55:39,370
parts that don't work the big one are

00:55:36,130 --> 00:55:42,490
resources so you can't for example open

00:55:39,370 --> 00:55:45,430
a connection and then somehow cache that

00:55:42,490 --> 00:55:48,100
connection you can actually do that with

00:55:45,430 --> 00:55:49,330
a PC which is really really weird that

00:55:48,100 --> 00:55:50,470
you can open the connection other server

00:55:49,330 --> 00:55:53,020
and go I'm going to cache this

00:55:50,470 --> 00:55:55,570
connection and it kind of works and it's

00:55:53,020 --> 00:55:56,830
it's really weird or open the connection

00:55:55,570 --> 00:55:58,480
to a file and then I'm just going to

00:55:56,830 --> 00:56:00,880
cache this connection to a file and then

00:55:58,480 --> 00:56:03,940
have someone else continue writing to

00:56:00,880 --> 00:56:06,460
this file so that's really what it comes

00:56:03,940 --> 00:56:10,630
down to any other questions

00:56:06,460 --> 00:56:12,070
Oh waiting for that one there's two here

00:56:10,630 --> 00:56:16,480
your choice

00:56:12,070 --> 00:56:18,340
guy with the mic chooses hello one of

00:56:16,480 --> 00:56:20,380
the options for validating cache so you

00:56:18,340 --> 00:56:24,790
mentioned that you can use prefixes

00:56:20,380 --> 00:56:28,090
right so for example we've got the

00:56:24,790 --> 00:56:29,590
customer one version one and two

00:56:28,090 --> 00:56:33,600
invalidated results

00:56:29,590 --> 00:56:37,150
version two what happens if you have

00:56:33,600 --> 00:56:41,890
something cached for multiple users

00:56:37,150 --> 00:56:46,810
let's say reviews how do you evaluate

00:56:41,890 --> 00:56:49,930
the reviews which are depending from the

00:56:46,810 --> 00:56:52,560
customers okay so you're asking if

00:56:49,930 --> 00:56:56,350
you're doing multiple prefixed caching

00:56:52,560 --> 00:56:57,940
how when when you update to the next

00:56:56,350 --> 00:57:02,710
version how you make sure you're getting

00:56:57,940 --> 00:57:06,570
the right one or you've got a dependent

00:57:02,710 --> 00:57:10,330
caching how do you validate the

00:57:06,570 --> 00:57:13,630
dependencies in the caching don't have

00:57:10,330 --> 00:57:16,630
dependencies in your caching be my main

00:57:13,630 --> 00:57:19,450
answer if you do have to have some type

00:57:16,630 --> 00:57:21,100
of dependency in your caching make sure

00:57:19,450 --> 00:57:23,530
that that dependency you're building in

00:57:21,100 --> 00:57:25,030
is also using the versioning so I have

00:57:23,530 --> 00:57:26,930
seen I have actually written code that

00:57:25,030 --> 00:57:29,420
did that for example where I

00:57:26,930 --> 00:57:31,190
had the idea of a cash group memcached

00:57:29,420 --> 00:57:34,309
does not support the idea of cash groups

00:57:31,190 --> 00:57:35,990
some other types of systems do and if

00:57:34,309 --> 00:57:37,670
you use a framework like Zen framework

00:57:35,990 --> 00:57:40,359
same framework will replicate the idea

00:57:37,670 --> 00:57:43,970
of grouping for you or you can say I

00:57:40,359 --> 00:57:45,260
have this these five cached items but

00:57:43,970 --> 00:57:47,150
I'm consuming them a group and I want to

00:57:45,260 --> 00:57:49,280
invalidate them at once or update them

00:57:47,150 --> 00:57:52,369
at once and I would do that in memcache

00:57:49,280 --> 00:57:56,089
by storing a key that was just an array

00:57:52,369 --> 00:57:57,740
of cash IDs so that I knew okay so I

00:57:56,089 --> 00:57:59,510
want to do something to this group I can

00:57:57,740 --> 00:58:02,690
read the key that's the group name and

00:57:59,510 --> 00:58:05,359
get an array of other key names and now

00:58:02,690 --> 00:58:06,589
I can access those and in that case you

00:58:05,359 --> 00:58:08,780
have to make sure that that array of

00:58:06,589 --> 00:58:11,960
extra key names all have this prefixes

00:58:08,780 --> 00:58:14,540
pre added as well so as soon as you

00:58:11,960 --> 00:58:16,579
update to a new prefix everything's

00:58:14,540 --> 00:58:18,530
accessing the new ones only and the new

00:58:16,579 --> 00:58:21,619
ones will either not exist or have the

00:58:18,530 --> 00:58:28,670
new key in them already okay I think we

00:58:21,619 --> 00:58:33,530
had one over here compression have you

00:58:28,670 --> 00:58:34,970
any experience on performance yeah the

00:58:33,530 --> 00:58:37,940
question was performance on memcache

00:58:34,970 --> 00:58:40,640
compression I I do have some experience

00:58:37,940 --> 00:58:43,099
um by default again it does use

00:58:40,640 --> 00:58:45,140
serialized and on serialize you can

00:58:43,099 --> 00:58:47,390
change the compression algorithm that is

00:58:45,140 --> 00:58:49,579
used we sorry you can change the

00:58:47,390 --> 00:58:51,799
serialization option that's used you can

00:58:49,579 --> 00:58:55,010
also turn on compression those are both

00:58:51,799 --> 00:58:57,890
two options I have had problems in the

00:58:55,010 --> 00:59:02,240
past when turning on compression I have

00:58:57,890 --> 00:59:03,650
not tried it recently the main problem

00:59:02,240 --> 00:59:06,190
that does happen when you turn on

00:59:03,650 --> 00:59:08,809
compression is you are now saving

00:59:06,190 --> 00:59:11,270
potentially space on your memcache

00:59:08,809 --> 00:59:13,670
server and you are transferring less

00:59:11,270 --> 00:59:16,490
data across the wire because you have

00:59:13,670 --> 00:59:20,170
compressed it all down however you are

00:59:16,490 --> 00:59:22,609
adding a lot of CPU usage on the webhead

00:59:20,170 --> 00:59:25,670
because before you go and send anything

00:59:22,609 --> 00:59:27,950
across it has to run the essential of

00:59:25,670 --> 00:59:29,750
gzip on all that data send it across

00:59:27,950 --> 00:59:33,260
when it gets read back you have to unzip

00:59:29,750 --> 00:59:35,960
it and I usually find that memory is

00:59:33,260 --> 00:59:37,790
cheap and the network traffic between

00:59:35,960 --> 00:59:38,680
your local servers should be really fast

00:59:37,790 --> 00:59:40,239
anyway

00:59:38,680 --> 00:59:42,489
but see if you

00:59:40,239 --> 00:59:43,869
power is always hard to come by and so

00:59:42,489 --> 00:59:45,639
I've usually found that turning on

00:59:43,869 --> 00:59:47,949
compression hurt performance overall

00:59:45,639 --> 00:59:50,289
just because I didn't have overpowered

00:59:47,949 --> 00:59:54,579
servers to handle that now the flip side

00:59:50,289 --> 00:59:57,849
is you can use a different serialization

00:59:54,579 --> 01:00:00,609
algorithm so there's a number of plugins

00:59:57,849 --> 01:00:01,289
that do a more optimal method for doing

01:00:00,609 --> 01:00:04,659
it

01:00:01,289 --> 01:00:06,399
IG binary I believe comes to mind which

01:00:04,659 --> 01:00:09,549
is the one that actually Facebook uses

01:00:06,399 --> 01:00:10,809
they wrote it and instead of serializing

01:00:09,549 --> 01:00:13,659
into text

01:00:10,809 --> 01:00:16,239
it actually encrypts it into a binary

01:00:13,659 --> 01:00:19,119
format and sends that to memcache and

01:00:16,239 --> 01:00:21,579
back and that's actually more efficient

01:00:19,119 --> 01:00:25,529
and you don't have to worry about the

01:00:21,579 --> 01:00:27,879
compression at that point either right

01:00:25,529 --> 01:00:30,239
that one more all right those question

01:00:27,879 --> 01:00:43,269
over there somewhere all right they're

01:00:30,239 --> 01:00:45,129
just about to the biggest yes and every

01:00:43,269 --> 01:00:47,349
request and it changes leave the

01:00:45,129 --> 01:00:49,059
application to do that but you break

01:00:47,349 --> 01:00:51,999
down that data you're retrieving it's a

01:00:49,059 --> 01:00:54,939
very small reusable parts and cache on

01:00:51,999 --> 01:00:56,559
that level and then across all requests

01:00:54,939 --> 01:00:58,239
the cache will be shared and you'll be

01:00:56,559 --> 01:01:00,789
getting a lot more hits and less

01:00:58,239 --> 01:01:03,099
retrieval from the database same track

01:01:00,789 --> 01:01:04,479
right so so the idea here it's asking

01:01:03,099 --> 01:01:06,519
about the biggest small street usable

01:01:04,479 --> 01:01:08,919
and yet what what you described is

01:01:06,519 --> 01:01:10,359
exactly the idea so the idea is that if

01:01:08,919 --> 01:01:12,849
you're going to retrieve a whole bunch

01:01:10,359 --> 01:01:14,799
of information so like the example that

01:01:12,849 --> 01:01:16,449
comes to mind comes back to the dig and

01:01:14,799 --> 01:01:18,939
you know the friends and everything the

01:01:16,449 --> 01:01:21,759
Pete the friends have dug right so

01:01:18,939 --> 01:01:24,459
that's a lot of data so what you want to

01:01:21,759 --> 01:01:25,929
do is to chop that into small parts but

01:01:24,459 --> 01:01:29,079
you have to make sure the parts you are

01:01:25,929 --> 01:01:30,729
chopping are extremely reusable right so

01:01:29,079 --> 01:01:32,889
that you constantly you're getting this

01:01:30,729 --> 01:01:35,169
benefit of not only having smaller

01:01:32,889 --> 01:01:37,569
quicker queries but to have that piece

01:01:35,169 --> 01:01:40,869
of data be far more reusable across your

01:01:37,569 --> 01:01:42,039
site but there's this fine line and

01:01:40,869 --> 01:01:44,709
that's where the biggest smallest

01:01:42,039 --> 01:01:46,719
concept comes in you could chop it up

01:01:44,709 --> 01:01:49,149
ridiculously small into these itty bitty

01:01:46,719 --> 01:01:50,499
tiny pieces of data and now instead of

01:01:49,149 --> 01:01:52,209
turning it into a thousand and one

01:01:50,499 --> 01:01:52,910
queries you've turned it into a million

01:01:52,209 --> 01:01:55,220
in one query

01:01:52,910 --> 01:01:57,740
and every piece of data has like one bit

01:01:55,220 --> 01:02:00,440
of information in it and at that point

01:01:57,740 --> 01:02:03,620
you're hurting yourself because you're

01:02:00,440 --> 01:02:06,080
now having to constantly go and do so

01:02:03,620 --> 01:02:08,030
many queries to the cache and get this

01:02:06,080 --> 01:02:11,180
data back and so that's where you want

01:02:08,030 --> 01:02:13,010
to chop them up as small as possible but

01:02:11,180 --> 01:02:16,100
then step back out and have them in the

01:02:13,010 --> 01:02:18,370
biggest still reusable chunks so if for

01:02:16,100 --> 01:02:21,290
example in the case of dig that was

01:02:18,370 --> 01:02:23,960
separately caching here's this users

01:02:21,290 --> 01:02:25,580
friends it's just a list of IDs because

01:02:23,960 --> 01:02:27,440
we use that on number different pages to

01:02:25,580 --> 01:02:29,810
go like oh here's the list of this users

01:02:27,440 --> 01:02:32,840
friends that we that would get used and

01:02:29,810 --> 01:02:36,530
then separately we would cache this user

01:02:32,840 --> 01:02:38,570
has dug these stories because that got

01:02:36,530 --> 01:02:40,160
reused in multiple ways it got used when

01:02:38,570 --> 01:02:42,590
generating the green bars it also got

01:02:40,160 --> 01:02:44,270
used when that user logged end it got

01:02:42,590 --> 01:02:47,480
used if you went and viewed that users

01:02:44,270 --> 01:02:49,460
list of dug stories so that was that

01:02:47,480 --> 01:02:52,070
perfect sweet spot of if we went any

01:02:49,460 --> 01:02:53,210
smaller we didn't get any benefit

01:02:52,070 --> 01:02:55,730
because we had to constantly make

01:02:53,210 --> 01:02:56,300
multiple cache requests if we went any

01:02:55,730 --> 01:02:59,120
bigger

01:02:56,300 --> 01:03:00,710
it wasn't reusable so it's finding that

01:02:59,120 --> 01:03:03,050
sweet spot and how the data is

01:03:00,710 --> 01:03:04,970
manipulated so that you get the most

01:03:03,050 --> 01:03:07,070
reusable Park you've made it small

01:03:04,970 --> 01:03:09,590
enough that it's reusable but it's the

01:03:07,070 --> 01:03:10,940
biggest reusable chunk you can create so

01:03:09,590 --> 01:03:15,080
that you're not making too many cache

01:03:10,940 --> 01:03:16,340
requests and it's tough all right I

01:03:15,080 --> 01:03:18,260
think we're out of time at the moment

01:03:16,340 --> 01:03:20,690
it's like I said I'll be around all

01:03:18,260 --> 01:03:23,150
evening all afternoon and all tomorrow

01:03:20,690 --> 01:03:24,620
so please come find me again if you want

01:03:23,150 --> 01:03:26,060
to touch the magazines I have them up

01:03:24,620 --> 01:03:29,200
here and you might take one away with

01:03:26,060 --> 01:03:29,200

YouTube URL: https://www.youtube.com/watch?v=bsZQcbBcXuQ


