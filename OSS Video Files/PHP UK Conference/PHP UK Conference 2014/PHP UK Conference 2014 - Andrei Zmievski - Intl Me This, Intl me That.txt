Title: PHP UK Conference 2014 - Andrei Zmievski - Intl Me This, Intl me That
Publication date: 2014-03-21
Playlist: PHP UK Conference 2014
Description: 
	Quick, what's the proper way to show a number as currency for India? 1.2 billion people would like to know. No pressure. These common localization issues come up more and more frequently. Learn to use the improved intl extension to order lists, format numbers, split text into pieces and show calendars just like a local would. It even helps with character sets and time zones - 2 out of 3 things that commonly break the Internet. ¡Muy bueno!
Captions: 
	00:00:03,950 --> 00:00:10,910
it's noon have an hour before lunch

00:00:11,480 --> 00:00:16,049
great to have big audience you guys are

00:00:14,610 --> 00:00:17,609
really either you really want to learn

00:00:16,049 --> 00:00:18,869
about int'l extension or you really

00:00:17,609 --> 00:00:22,760
don't want to go to the algorithm a

00:00:18,869 --> 00:00:29,519
review talk Rigby do computer science

00:00:22,760 --> 00:00:31,650
from school so this is a little bit of

00:00:29,519 --> 00:00:34,739
evolution I gave a talk on

00:00:31,650 --> 00:00:36,630
internationalization in the past and it

00:00:34,739 --> 00:00:38,430
mentioned this into extension I decided

00:00:36,630 --> 00:00:39,780
just to take that portion expanded

00:00:38,430 --> 00:00:42,239
because there's a whole load of new

00:00:39,780 --> 00:00:47,070
stuff that's been added to in tol since

00:00:42,239 --> 00:00:48,840
that time so I believe that slide

00:00:47,070 --> 00:00:50,489
transitions are dangerous is depleted

00:00:48,840 --> 00:01:01,559
resource so this will be the only one

00:00:50,489 --> 00:01:03,989
you see in this presentation right just

00:01:01,559 --> 00:01:06,439
a little bit uh some little facts about

00:01:03,989 --> 00:01:09,720
me I'm software architect Deb dynamics

00:01:06,439 --> 00:01:11,930
you may not have heard our name but our

00:01:09,720 --> 00:01:13,920
software hopes a lot of very well-known

00:01:11,930 --> 00:01:15,509
companies keep their applications

00:01:13,920 --> 00:01:19,170
running in top form and provide

00:01:15,509 --> 00:01:22,799
operational and business intelligence we

00:01:19,170 --> 00:01:26,759
support java.net PHP nodejs python soon

00:01:22,799 --> 00:01:28,650
and at the very high level once you drop

00:01:26,759 --> 00:01:30,479
our agent in there automatically maps

00:01:28,650 --> 00:01:32,130
out your application flow all the

00:01:30,479 --> 00:01:34,530
different services it's accessing

00:01:32,130 --> 00:01:36,060
provide stats on that deep dive

00:01:34,530 --> 00:01:38,520
instrumentation in case things go wrong

00:01:36,060 --> 00:01:41,540
and if you want to learn more about this

00:01:38,520 --> 00:01:45,750
i'll be paying out i can show you a demo

00:01:41,540 --> 00:01:48,149
i was a PHP core contributor i say was

00:01:45,750 --> 00:01:50,579
because i'm not anymore despite what

00:01:48,149 --> 00:01:55,710
people may think I did it for a decade

00:01:50,579 --> 00:01:58,680
and decided I had enough and the reason

00:01:55,710 --> 00:01:59,850
I had enough most place because I was at

00:01:58,680 --> 00:02:02,189
the architect of the Unicode and

00:01:59,850 --> 00:02:05,070
internationalization project and was

00:02:02,189 --> 00:02:06,869
supposed to be PHP 6 and I'm probably

00:02:05,070 --> 00:02:10,619
the reason why there won't be HP six

00:02:06,869 --> 00:02:13,060
I'll just jump straight to seven because

00:02:10,619 --> 00:02:14,770
some people

00:02:13,060 --> 00:02:16,569
prematurely published books and things

00:02:14,770 --> 00:02:19,120
like that on PHP 6 that had to be then

00:02:16,569 --> 00:02:20,650
pulled off the shelves when I decided

00:02:19,120 --> 00:02:23,819
that unit code wasn't going to happen in

00:02:20,650 --> 00:02:26,110
the NPH be i'm also at a on twitter

00:02:23,819 --> 00:02:27,970
don't try to reply to me i probably

00:02:26,110 --> 00:02:33,370
won't see it if you saw my talk last

00:02:27,970 --> 00:02:35,560
year about it's worse since then i also

00:02:33,370 --> 00:02:39,069
like beer both the drinking it brewing

00:02:35,560 --> 00:02:40,810
it so talk to me about that too good

00:02:39,069 --> 00:02:44,200
news everyone unicode 7 was released

00:02:40,810 --> 00:02:45,880
recently in case you didn't know there's

00:02:44,200 --> 00:02:56,280
a whole lot of new characters have been

00:02:45,880 --> 00:02:58,630
added my favorite three of these yes i

00:02:56,280 --> 00:03:00,010
just want to see that when the committee

00:02:58,630 --> 00:03:04,720
says down and i try to come up with

00:03:00,010 --> 00:03:06,760
names for these like oh well can um so

00:03:04,720 --> 00:03:11,010
raise ham with partly to middle and ring

00:03:06,760 --> 00:03:13,110
fingers okay all right so some terms

00:03:11,010 --> 00:03:15,250
they get thrown around like

00:03:13,110 --> 00:03:18,900
internationalization or i18n and

00:03:15,250 --> 00:03:21,549
localization what do we really mean well

00:03:18,900 --> 00:03:23,320
internationalization means you develop

00:03:21,549 --> 00:03:25,030
your application in such a way that it

00:03:23,320 --> 00:03:27,010
doesn't have any built-in assumptions

00:03:25,030 --> 00:03:29,380
and it's also in a way that it's

00:03:27,010 --> 00:03:31,329
efficient to localize and localization

00:03:29,380 --> 00:03:33,370
comes after that issue which is where

00:03:31,329 --> 00:03:36,190
you take an application like that and

00:03:33,370 --> 00:03:39,130
then tailor it to meet the needs of a

00:03:36,190 --> 00:03:44,350
particular culture or market or group of

00:03:39,130 --> 00:03:47,109
users so you should have any assumptions

00:03:44,350 --> 00:03:48,700
like English French Chinese Indian

00:03:47,109 --> 00:03:50,530
whatever Russian is just another

00:03:48,700 --> 00:03:52,750
language there should be no preference

00:03:50,530 --> 00:03:54,040
for a particular language your country

00:03:52,750 --> 00:03:56,769
is just on the contrary earth is just

00:03:54,040 --> 00:03:59,139
another planet at some point so keep

00:03:56,769 --> 00:04:02,049
that in mind now why would you want to

00:03:59,139 --> 00:04:04,209
localize and do all that stuff that you

00:04:02,049 --> 00:04:06,630
probably don't want to do what are we

00:04:04,209 --> 00:04:06,630
looking at here

00:04:08,110 --> 00:04:12,190
alright so you're looking about 2.5

00:04:10,630 --> 00:04:15,580
billion combined population between

00:04:12,190 --> 00:04:17,049
China and India not to mention part of

00:04:15,580 --> 00:04:18,850
Russia there as well the whole BRIC

00:04:17,049 --> 00:04:20,829
countries you've heard them right Brazil

00:04:18,850 --> 00:04:24,630
Russia India China it's going to be huge

00:04:20,829 --> 00:04:27,160
in the next you know decade or so and

00:04:24,630 --> 00:04:31,660
English speakers are minority now on the

00:04:27,160 --> 00:04:33,550
on the web and surprise surprise when

00:04:31,660 --> 00:04:36,700
served by this awesomely named common

00:04:33,550 --> 00:04:38,740
sense advisory people said oh I prefer

00:04:36,700 --> 00:04:43,300
to buy from sites and the languages that

00:04:38,740 --> 00:04:44,650
I speak and or understand so global

00:04:43,300 --> 00:04:48,010
customers will pay more for progress

00:04:44,650 --> 00:04:49,690
with information in their language so

00:04:48,010 --> 00:04:53,050
another term that comes around a lot is

00:04:49,690 --> 00:04:55,150
locale what is locale well for purposes

00:04:53,050 --> 00:04:58,060
of this stock it's basically an

00:04:55,150 --> 00:04:59,770
identifier that refers to preferences

00:04:58,060 --> 00:05:04,360
both linguistic and cultural of a

00:04:59,770 --> 00:05:07,660
certain user community and in the in the

00:05:04,360 --> 00:05:10,030
types of locale that Intel uses there

00:05:07,660 --> 00:05:12,070
are five different portions in the

00:05:10,030 --> 00:05:16,229
identifiers there's language script

00:05:12,070 --> 00:05:18,490
country variant and keywords and they're

00:05:16,229 --> 00:05:19,900
everything but language can be optional

00:05:18,490 --> 00:05:22,180
and it can be as simple as something

00:05:19,900 --> 00:05:25,510
like English and Great Britain to this

00:05:22,180 --> 00:05:27,070
where it's like Serbian which is in

00:05:25,510 --> 00:05:29,169
Latin script because it can be in

00:05:27,070 --> 00:05:30,820
Cyrillic from Yugoslavia revised I

00:05:29,169 --> 00:05:35,680
photography and currency US dollars

00:05:30,820 --> 00:05:37,600
right but we'll use simple ones now in

00:05:35,680 --> 00:05:40,419
order to have good localization into

00:05:37,600 --> 00:05:42,100
good locale data and you really don't

00:05:40,419 --> 00:05:43,479
want to do it on your own so there is

00:05:42,100 --> 00:05:45,250
this awesome project called common

00:05:43,479 --> 00:05:47,470
locale data repository which is run by

00:05:45,250 --> 00:05:49,270
Unicode consortium and they do regular

00:05:47,470 --> 00:05:51,400
releases they gather all this locale

00:05:49,270 --> 00:05:54,700
data that proof it they tested and we

00:05:51,400 --> 00:05:57,250
give it to you to use a latest count I

00:05:54,700 --> 00:06:02,560
think they have 740 locales 238

00:05:57,250 --> 00:06:05,620
languages 259 territories so we here to

00:06:02,560 --> 00:06:08,760
talk about the Intel extension that's

00:06:05,620 --> 00:06:14,200
basically been available since PHP 53

00:06:08,760 --> 00:06:18,039
and it's both in Pekel and I think maybe

00:06:14,200 --> 00:06:20,320
bundle with PHP now too if you haven't

00:06:18,039 --> 00:06:22,060
had a chance to install it it's real

00:06:20,320 --> 00:06:24,970
easy it does rely on the extra

00:06:22,060 --> 00:06:28,060
a library called ICU which you'll need

00:06:24,970 --> 00:06:29,530
to install via whatever package

00:06:28,060 --> 00:06:32,080
management system you use or build from

00:06:29,530 --> 00:06:35,250
source but provides a whole bunch of

00:06:32,080 --> 00:06:38,110
things for you that you can use in your

00:06:35,250 --> 00:06:40,030
applications things like for matters and

00:06:38,110 --> 00:06:43,800
part starts from numbers and messages

00:06:40,030 --> 00:06:45,639
sorting a character's head conversion

00:06:43,800 --> 00:06:47,620
transliteration and transfer text

00:06:45,639 --> 00:06:50,880
transforms boundaries calendars time

00:06:47,620 --> 00:06:55,150
zones and we'll talk about some of these

00:06:50,880 --> 00:06:57,360
now the API for the Intel extension has

00:06:55,150 --> 00:06:59,860
both object-oriented and procedural I

00:06:57,360 --> 00:07:02,020
don't I can decide if it's for people

00:06:59,860 --> 00:07:04,090
who can't come for the grips that PHP

00:07:02,020 --> 00:07:07,440
has had object-oriented ports since what

00:07:04,090 --> 00:07:09,940
for version four right or whatever or

00:07:07,440 --> 00:07:12,130
it's just the provide fodder to those

00:07:09,940 --> 00:07:15,639
who rant about PHP having more than two

00:07:12,130 --> 00:07:17,590
ways to do everything right but it's

00:07:15,639 --> 00:07:21,400
pretty simple like if you prefer to use

00:07:17,590 --> 00:07:23,860
the procedure was you know kool-aid or

00:07:21,400 --> 00:07:27,190
create equivalent to stanch in class

00:07:23,860 --> 00:07:29,650
same thing here you can figure it out I

00:07:27,190 --> 00:07:34,210
in my slides i use object-oriented

00:07:29,650 --> 00:07:36,190
format so let's jump into this so the

00:07:34,210 --> 00:07:37,900
one of the new things that got added to

00:07:36,190 --> 00:07:40,300
the int'l accession recently is this

00:07:37,900 --> 00:07:41,470
thing called you converter unfortunately

00:07:40,300 --> 00:07:44,770
named just because that's the name of

00:07:41,470 --> 00:07:46,450
the class in the ICU library could have

00:07:44,770 --> 00:07:49,020
been called differently but oh well and

00:07:46,450 --> 00:07:51,280
the purpose of it is they provide robust

00:07:49,020 --> 00:07:52,600
conversion capabilities between various

00:07:51,280 --> 00:07:54,669
character encodings it's basically

00:07:52,600 --> 00:07:57,610
replacement for and become very encoding

00:07:54,669 --> 00:07:59,139
which is affine function but this gives

00:07:57,610 --> 00:08:00,880
you some additional things that you can

00:07:59,139 --> 00:08:03,310
do with it plus accessed all that

00:08:00,880 --> 00:08:08,590
awesome character and locale data to

00:08:03,310 --> 00:08:11,110
start with so it has both like simple

00:08:08,590 --> 00:08:12,660
API if you just want to fire off and do

00:08:11,110 --> 00:08:14,139
one conversion or if you're an

00:08:12,660 --> 00:08:17,560
object-oriented if you want to

00:08:14,139 --> 00:08:19,810
instantiate an object and then do things

00:08:17,560 --> 00:08:22,510
more than one more than one string so

00:08:19,810 --> 00:08:24,070
for example we can say you convert a

00:08:22,510 --> 00:08:25,780
trance code and you give it the strength

00:08:24,070 --> 00:08:28,300
to transcode here this is the target

00:08:25,780 --> 00:08:29,950
encoding this is the source one so here

00:08:28,300 --> 00:08:33,240
we're going from Latin one basically to

00:08:29,950 --> 00:08:34,550
utf-8 this is the cydia character and

00:08:33,240 --> 00:08:38,169
echo

00:08:34,550 --> 00:08:41,450
it and you come up with the the result

00:08:38,169 --> 00:08:44,060
you can go backwards from utf-8 to

00:08:41,450 --> 00:08:45,620
lighten one and if it can't map a

00:08:44,060 --> 00:08:47,300
certain character into the target

00:08:45,620 --> 00:08:51,110
encoding this is not lend them on this

00:08:47,300 --> 00:08:54,740
is I think this is the Hebrew one in ISO

00:08:51,110 --> 00:08:56,390
and like I said I apologize it's really

00:08:54,740 --> 00:08:58,430
hard to see the slide the bottomless

00:08:56,390 --> 00:09:00,050
slides on the back right but they'll be

00:08:58,430 --> 00:09:04,760
online so you can sort of run through

00:09:00,050 --> 00:09:06,649
them later and if the if the Intel

00:09:04,760 --> 00:09:08,810
extension can't map the character into

00:09:06,649 --> 00:09:13,820
the target encoding it replaces it by

00:09:08,810 --> 00:09:15,170
default with hex value 1 a which is ctrl

00:09:13,820 --> 00:09:16,370
Z or whatever you want skulls it's a non

00:09:15,170 --> 00:09:18,620
printable character which is why it

00:09:16,370 --> 00:09:20,410
doesn't display here but you can

00:09:18,620 --> 00:09:23,120
customize that if you want to you know

00:09:20,410 --> 00:09:25,790
replace it with a multiplication sign or

00:09:23,120 --> 00:09:28,370
something like that then you can provide

00:09:25,790 --> 00:09:30,440
an optional parameter here saying when

00:09:28,370 --> 00:09:32,060
you do the conversion they substitute

00:09:30,440 --> 00:09:34,160
the character with this and then it

00:09:32,060 --> 00:09:35,510
comes out like that you can put a

00:09:34,160 --> 00:09:43,040
snowman in there if you want if that's

00:09:35,510 --> 00:09:44,810
supported in the target 10 what yeah now

00:09:43,040 --> 00:09:48,170
that so far this is pretty close to what

00:09:44,810 --> 00:09:49,640
mb converting coating gives you but it's

00:09:48,170 --> 00:09:51,560
way more customizable because what you

00:09:49,640 --> 00:09:54,680
can what you can do is extend the class

00:09:51,560 --> 00:09:56,720
and provide override the callback

00:09:54,680 --> 00:09:58,839
functions that will be invoked when it

00:09:56,720 --> 00:10:02,029
needs to map a character to something

00:09:58,839 --> 00:10:03,649
and it looks like this where you say

00:10:02,029 --> 00:10:05,720
extend the class and then there's

00:10:03,649 --> 00:10:08,089
function called from you call back which

00:10:05,720 --> 00:10:11,270
happens when you convert from Unicode to

00:10:08,089 --> 00:10:13,310
something from utf-8 or something and

00:10:11,270 --> 00:10:14,660
what we can do here is that ok let's say

00:10:13,310 --> 00:10:16,310
we want to translate the square root

00:10:14,660 --> 00:10:18,140
sign to some text instead of just a

00:10:16,310 --> 00:10:20,570
single character or omit it or whatever

00:10:18,140 --> 00:10:22,760
so we can say if reason is unassigned

00:10:20,570 --> 00:10:24,980
and the code point is this which is the

00:10:22,760 --> 00:10:27,770
square root reset the error to zero

00:10:24,980 --> 00:10:29,779
because otherwise it'll air out and then

00:10:27,770 --> 00:10:33,680
return the replacement and then when you

00:10:29,779 --> 00:10:38,839
convert from utf-8 to ascii here it

00:10:33,680 --> 00:10:40,519
comes out as oh it will come out as what

00:10:38,839 --> 00:10:44,870
is square root of two i forgot to put

00:10:40,519 --> 00:10:45,790
the output there sorry about that all

00:10:44,870 --> 00:10:48,199
right

00:10:45,790 --> 00:10:49,670
any questions about characters I've

00:10:48,199 --> 00:10:57,410
conversion and if you do raise your hand

00:10:49,670 --> 00:11:00,189
so that the microphone okay yes I I

00:10:57,410 --> 00:11:03,949
wonder if there is any method class or

00:11:00,189 --> 00:11:08,600
function to convert a string you def

00:11:03,949 --> 00:11:11,480
string to a array of code points like

00:11:08,600 --> 00:11:19,910
something low level so we can interact

00:11:11,480 --> 00:11:22,189
with it you can I don't think there's

00:11:19,910 --> 00:11:25,699
anything built in you can convert to

00:11:22,189 --> 00:11:27,589
utf-32 encoding which is sort of like

00:11:25,699 --> 00:11:29,839
that because it gives you full code

00:11:27,589 --> 00:11:33,920
points but it'll still be in a string

00:11:29,839 --> 00:11:36,829
representation right so I don't think

00:11:33,920 --> 00:11:39,139
there's anything built in but there

00:11:36,829 --> 00:11:40,790
could be no because I did it and it's

00:11:39,139 --> 00:11:43,579
very slow if you do it now yeah

00:11:40,790 --> 00:11:46,160
assessing every single bite and I think

00:11:43,579 --> 00:11:47,660
you maybe there is something not not to

00:11:46,160 --> 00:11:52,540
my knowledge I don't think this one has

00:11:47,660 --> 00:11:55,879
ink so next thing is collator class and

00:11:52,540 --> 00:11:59,119
collation is another term for ordering

00:11:55,879 --> 00:12:01,160
or sorting is you can imagine they're

00:11:59,119 --> 00:12:06,439
different languages have very different

00:12:01,160 --> 00:12:08,660
rules about not only like what order the

00:12:06,439 --> 00:12:11,899
characters occur in whatever they should

00:12:08,660 --> 00:12:15,559
be sorted then but they may sort more

00:12:11,899 --> 00:12:18,860
than one way depending on the what the

00:12:15,559 --> 00:12:20,209
target text will be used for for example

00:12:18,860 --> 00:12:21,410
in German whether if you're making a

00:12:20,209 --> 00:12:23,839
dictionary or phone book they're gonna

00:12:21,410 --> 00:12:25,850
be sort of different ways or it's

00:12:23,839 --> 00:12:28,189
Spanish traditional versus modern

00:12:25,850 --> 00:12:29,600
Spanish sword differently or in Japanese

00:12:28,189 --> 00:12:34,369
you can start with stroke and then

00:12:29,600 --> 00:12:35,269
radical sort or vice versa so the

00:12:34,369 --> 00:12:36,829
primary thing to understand about

00:12:35,269 --> 00:12:39,740
collation is that it has this thing

00:12:36,829 --> 00:12:41,929
called levels and they there five of

00:12:39,740 --> 00:12:44,059
them they proceeded from primary two

00:12:41,929 --> 00:12:45,499
down one to the identical primary

00:12:44,059 --> 00:12:49,429
basically means distinguishing base

00:12:45,499 --> 00:12:52,579
characters secondary is accents and some

00:12:49,429 --> 00:12:55,879
language specific differences tertiary

00:12:52,579 --> 00:12:57,740
is a case lot so uppercase lowercase and

00:12:55,879 --> 00:12:59,059
some variants of base forms of base

00:12:57,740 --> 00:13:01,519
characters

00:12:59,059 --> 00:13:03,289
quaternary you'll never use this is no

00:13:01,519 --> 00:13:08,779
need to know about it and an identical

00:13:03,289 --> 00:13:11,299
is it trust me you won't identical as a

00:13:08,779 --> 00:13:13,249
tiebreaker in case it's gone through all

00:13:11,299 --> 00:13:15,559
of them and it still needs to compare

00:13:13,249 --> 00:13:18,439
them then though it'll do it on that

00:13:15,559 --> 00:13:24,229
level and these are also called strength

00:13:18,439 --> 00:13:27,859
for some reason and each locale has a

00:13:24,229 --> 00:13:29,389
default level setting so for let's say

00:13:27,859 --> 00:13:31,549
if it's English then it's only going to

00:13:29,389 --> 00:13:33,649
be base characters normally maybe with

00:13:31,549 --> 00:13:35,059
accents and you know in Japanese it's

00:13:33,649 --> 00:13:37,789
going to go down to the third level or

00:13:35,059 --> 00:13:39,679
fourth level and the differences in

00:13:37,789 --> 00:13:43,279
lower levels are ignored of the upper

00:13:39,679 --> 00:13:45,109
ones compare characters is different so

00:13:43,279 --> 00:13:48,199
using it is pretty simple let's say we

00:13:45,109 --> 00:13:51,499
want to compare two words in French

00:13:48,199 --> 00:13:54,139
which look very very similar but you you

00:13:51,499 --> 00:13:56,089
need to know what order they come in so

00:13:54,139 --> 00:13:57,799
you can say Stan she ate the collator

00:13:56,089 --> 00:13:59,719
for the French language in France

00:13:57,799 --> 00:14:01,879
because you can do it for Canada as well

00:13:59,719 --> 00:14:03,289
and then you just say compare give it

00:14:01,879 --> 00:14:08,209
two of them and it returns just like

00:14:03,289 --> 00:14:12,319
struck out- 101 and you know echo it out

00:14:08,209 --> 00:14:13,879
and it's going to say that first word

00:14:12,319 --> 00:14:17,779
called this happens before the second

00:14:13,879 --> 00:14:20,179
one before Cote strength control so

00:14:17,779 --> 00:14:21,559
let's say you want to ignore the

00:14:20,179 --> 00:14:23,959
differences in accents you just want to

00:14:21,559 --> 00:14:26,359
compare the base characters you just set

00:14:23,959 --> 00:14:28,459
the strength of primary and then Cole

00:14:26,359 --> 00:14:30,139
compare and if it comes up comes back

00:14:28,459 --> 00:14:35,869
with a zero they're the same which in

00:14:30,139 --> 00:14:37,879
this case it would be so the side from

00:14:35,869 --> 00:14:39,589
comparing it has a couple of sword

00:14:37,879 --> 00:14:42,529
methods so you can pass it an array of

00:14:39,589 --> 00:14:44,449
strings and depending on what settings

00:14:42,529 --> 00:14:47,509
you also provide it'll sort them

00:14:44,449 --> 00:14:51,709
appropriately so for example these are

00:14:47,509 --> 00:14:53,179
all different words right and we want to

00:14:51,709 --> 00:14:55,519
know what order they should be sorted in

00:14:53,179 --> 00:14:58,699
now the trick here that in French when

00:14:55,519 --> 00:15:02,629
you sort things when you compare words

00:14:58,699 --> 00:15:04,069
that have accents they ones that have

00:15:02,629 --> 00:15:05,809
accents at the end gets sort of to the

00:15:04,069 --> 00:15:08,479
bottom even though otherwise there

00:15:05,809 --> 00:15:09,139
wouldn't be so but you don't need to

00:15:08,479 --> 00:15:10,939
worry about it because you just

00:15:09,139 --> 00:15:12,950
instantiate the collator and say sort

00:15:10,939 --> 00:15:15,170
and it comes up with them and correct

00:15:12,950 --> 00:15:17,690
to order here you see the accents one

00:15:15,170 --> 00:15:19,610
here I at the bottom which you would

00:15:17,690 --> 00:15:23,750
never know otherwise unless you were

00:15:19,610 --> 00:15:25,160
particularly interested in that so some

00:15:23,750 --> 00:15:26,720
other things you can do Lee can set

00:15:25,160 --> 00:15:29,150
different attributes you can say for

00:15:26,720 --> 00:15:30,740
example I want to sort uppercase first

00:15:29,150 --> 00:15:32,330
because usually it's lower case right

00:15:30,740 --> 00:15:35,300
like at least an ascii lower case comes

00:15:32,330 --> 00:15:37,190
first you can say case upper first and

00:15:35,300 --> 00:15:40,490
then when you compare ABC and ABC it's

00:15:37,190 --> 00:15:44,930
going to say chasm before the lowercase

00:15:40,490 --> 00:15:49,810
version the next thing is the miracle

00:15:44,930 --> 00:15:49,810
ation which is very useful if you yes

00:15:53,980 --> 00:15:58,960
what means the case first in case first

00:15:56,840 --> 00:16:01,940
is the name of the attribute so it says

00:15:58,960 --> 00:16:04,940
which case should come first and the

00:16:01,940 --> 00:16:06,950
value is upper first so it says upper

00:16:04,940 --> 00:16:10,340
characters should be it's not the best

00:16:06,950 --> 00:16:13,550
naming but so the other thing is numeric

00:16:10,340 --> 00:16:15,590
collation which if you're around this

00:16:13,550 --> 00:16:20,000
where you are trying to sort like

00:16:15,590 --> 00:16:22,040
numbers and like 10 1 and 2 and it puts

00:16:20,000 --> 00:16:24,320
them in the wrong order right you can

00:16:22,040 --> 00:16:27,350
set the Americal a Shinto on and I will

00:16:24,320 --> 00:16:28,640
store them like numbers instead of in

00:16:27,350 --> 00:16:33,580
the mayor quarter basically instead of

00:16:28,640 --> 00:16:40,610
in the string length and all that stuff

00:16:33,580 --> 00:16:47,080
anymore questions on collation yeah

00:16:40,610 --> 00:16:50,450
going to work today I can see that you

00:16:47,080 --> 00:16:52,490
switch the numeric collation on here and

00:16:50,450 --> 00:16:56,480
I assume you have to switch it off again

00:16:52,490 --> 00:16:58,340
so is there a method to ask the collator

00:16:56,480 --> 00:17:00,470
what are all your settings at the

00:16:58,340 --> 00:17:02,840
current moment you can get either get a

00:17:00,470 --> 00:17:05,720
tribute so you can say get value for

00:17:02,840 --> 00:17:07,339
numerical a shin and yeah not going

00:17:05,720 --> 00:17:12,079
through all the different methods just

00:17:07,339 --> 00:17:13,820
highlighting certain portions so the

00:17:12,079 --> 00:17:17,030
documentation for the Intel extension

00:17:13,820 --> 00:17:19,730
some classes of well-documented the sama

00:17:17,030 --> 00:17:22,189
is sort of very very skeleton level

00:17:19,730 --> 00:17:24,620
which is a at the end I'll give a couple

00:17:22,189 --> 00:17:26,490
links to the ICU project which has

00:17:24,620 --> 00:17:27,630
mature fury through that I'll

00:17:26,490 --> 00:17:29,309
they don't have more information about

00:17:27,630 --> 00:17:31,140
what the collation actually does and you

00:17:29,309 --> 00:17:36,390
know what are various things that can do

00:17:31,140 --> 00:17:40,140
and things like that now number

00:17:36,390 --> 00:17:42,179
formatter so this is basically a way a

00:17:40,140 --> 00:17:45,390
class to use when you want to format

00:17:42,179 --> 00:17:47,520
numbers in a locale sensitive manner or

00:17:45,390 --> 00:17:50,000
given a string that represents a number

00:17:47,520 --> 00:17:52,470
parse it into an integer or double

00:17:50,000 --> 00:17:56,280
depending on the locale and it's it's a

00:17:52,470 --> 00:17:58,500
replacement for number format and number

00:17:56,280 --> 00:18:00,270
formatter has a dub has a variety of

00:17:58,500 --> 00:18:02,910
different styles that the number can be

00:18:00,270 --> 00:18:05,940
formatted in and I'll give you an

00:18:02,910 --> 00:18:09,860
example of I think most of them so let's

00:18:05,940 --> 00:18:14,690
say we want to take this number here

00:18:09,860 --> 00:18:16,770
1234 dot 5 6 7 & French locale right and

00:18:14,690 --> 00:18:18,420
these are the various styles you can

00:18:16,770 --> 00:18:20,490
format the number it there's a pattern

00:18:18,420 --> 00:18:22,440
decimal which depending on the pattern

00:18:20,490 --> 00:18:25,530
you pass at formatting pattern it'll do

00:18:22,440 --> 00:18:27,120
different things but then and it's mode

00:18:25,530 --> 00:18:29,280
it was the most customizable one but

00:18:27,120 --> 00:18:31,800
then there's a built-in decimal just I

00:18:29,280 --> 00:18:33,720
just want a number and it'll format it

00:18:31,800 --> 00:18:36,330
appropriately or if you say I want to

00:18:33,720 --> 00:18:38,280
currency then I'll form it is a currency

00:18:36,330 --> 00:18:40,710
with a currency symbol included which is

00:18:38,280 --> 00:18:42,540
useful because their rules for currency

00:18:40,710 --> 00:18:45,030
symbols the way they appear before after

00:18:42,540 --> 00:18:48,300
they expanded and full like what the

00:18:45,030 --> 00:18:50,580
actual symbols are a role are all

00:18:48,300 --> 00:18:54,300
different another one is percentage

00:18:50,580 --> 00:18:56,370
because clearly decimal and percentage

00:18:54,300 --> 00:18:59,700
are very different here another

00:18:56,370 --> 00:19:03,510
formatted appropriately another one is

00:18:59,700 --> 00:19:04,920
scientific notation spell out is very

00:19:03,510 --> 00:19:08,760
cool they just spell out the number for

00:19:04,920 --> 00:19:12,600
you in case you're learning language or

00:19:08,760 --> 00:19:14,760
whatever ordinal is the you know things

00:19:12,600 --> 00:19:16,590
like first second fourth and so on with

00:19:14,760 --> 00:19:20,100
appropriate suffix or prefix or whatever

00:19:16,590 --> 00:19:24,720
else the language has and duration it

00:19:20,100 --> 00:19:26,550
treats it as a segment of time so even

00:19:24,720 --> 00:19:28,710
in you like here just gives you this

00:19:26,550 --> 00:19:29,790
number rounded up in the u.s. if he

00:19:28,710 --> 00:19:31,590
actually gives you like hours minutes

00:19:29,790 --> 00:19:36,030
seconds you know with the dots between

00:19:31,590 --> 00:19:38,460
the columns between them for the English

00:19:36,030 --> 00:19:39,900
locale it's really easy to use you just

00:19:38,460 --> 00:19:42,600
instantiate a formatter for

00:19:39,900 --> 00:19:46,490
locale that you need and this style and

00:19:42,600 --> 00:19:48,720
just say format boom comes out there

00:19:46,490 --> 00:19:50,100
another method that it has is called

00:19:48,720 --> 00:19:52,830
format currency and it's slightly

00:19:50,100 --> 00:19:55,140
different than just instantiating the

00:19:52,830 --> 00:19:58,560
currency style because you may want to

00:19:55,140 --> 00:20:00,900
have the formatter for certain locale

00:19:58,560 --> 00:20:03,060
but format currency for another country

00:20:00,900 --> 00:20:05,580
great otherwise we'll treat it as a

00:20:03,060 --> 00:20:11,190
local currency in that locale so in this

00:20:05,580 --> 00:20:13,920
case we have a German Swiss locale and

00:20:11,190 --> 00:20:17,370
we say format currency but use the

00:20:13,920 --> 00:20:19,140
currency code for Chinese RMB or you on

00:20:17,370 --> 00:20:22,080
right and it comes up with the right

00:20:19,140 --> 00:20:25,590
representation of that so that's format

00:20:22,080 --> 00:20:28,470
currency and you can go in the opposite

00:20:25,590 --> 00:20:33,180
direction you can parse a string into a

00:20:28,470 --> 00:20:36,030
number so in this case we want to take a

00:20:33,180 --> 00:20:40,020
representation of let's say of an

00:20:36,030 --> 00:20:43,320
integer in Indian locale and a decimal

00:20:40,020 --> 00:20:47,340
and parse it into an integer as well by

00:20:43,320 --> 00:20:49,260
default it's a float for some reason so

00:20:47,340 --> 00:20:51,720
you just call parse on this and it comes

00:20:49,260 --> 00:20:53,640
up with the result and if it can't parse

00:20:51,720 --> 00:20:55,830
it it gives you false so you can act on

00:20:53,640 --> 00:21:00,020
that any questions about number

00:20:55,830 --> 00:21:00,020
formatter one there

00:21:03,640 --> 00:21:11,080
I wonder if the parsing understand also

00:21:07,900 --> 00:21:14,910
the numbers written in other languages

00:21:11,080 --> 00:21:21,820
like Arabic numbers it's just you will

00:21:14,910 --> 00:21:23,620
thank you alright so from number

00:21:21,820 --> 00:21:25,830
formatter to message for matter this is

00:21:23,620 --> 00:21:29,640
really really important and very useful

00:21:25,830 --> 00:21:31,900
and what it does is it produces

00:21:29,640 --> 00:21:35,940
concatenated messages in a language

00:21:31,900 --> 00:21:38,740
neutral form language interval manner

00:21:35,940 --> 00:21:40,660
I'll give you an example on the next

00:21:38,740 --> 00:21:43,000
slide but it basically operates on

00:21:40,660 --> 00:21:45,430
patterns so like formatting patterns

00:21:43,000 --> 00:21:47,140
that could contain sub formats and the

00:21:45,430 --> 00:21:49,000
thing about this is that the program

00:21:47,140 --> 00:21:51,850
does not need to know the order of the

00:21:49,000 --> 00:21:53,560
fragments so the program just said I

00:21:51,850 --> 00:21:55,180
want to format this message and then

00:21:53,560 --> 00:21:58,330
these are the arguments and then it's up

00:21:55,180 --> 00:22:00,370
to the localized representation of that

00:21:58,330 --> 00:22:03,070
message to select the right number from

00:22:00,370 --> 00:22:05,080
the arguments right so typical let's say

00:22:03,070 --> 00:22:10,900
we wanted to format today's februari

00:22:05,080 --> 00:22:12,070
22nd 2014 that string so in PHP you know

00:22:10,900 --> 00:22:14,680
the old way you probably do something

00:22:12,070 --> 00:22:18,400
like this the echo today is then called

00:22:14,680 --> 00:22:21,880
date or store time with appropriate

00:22:18,400 --> 00:22:23,500
formatting which is fine but then you

00:22:21,880 --> 00:22:25,270
you run the difficulties you try to

00:22:23,500 --> 00:22:27,070
localize this because you need to know

00:22:25,270 --> 00:22:28,180
the right place dis place this into and

00:22:27,070 --> 00:22:29,530
also what the right locale

00:22:28,180 --> 00:22:33,280
representation is and all that stuff

00:22:29,530 --> 00:22:36,160
right and with message format you give

00:22:33,280 --> 00:22:39,160
it a pattern where you say today is and

00:22:36,160 --> 00:22:43,000
then this is the argument number so 0

00:22:39,160 --> 00:22:45,070
first argument and this is the type that

00:22:43,000 --> 00:22:48,130
it should format it is formatted as and

00:22:45,070 --> 00:22:50,140
the other portion that goes with this is

00:22:48,130 --> 00:22:52,000
the argument it's an array of parameters

00:22:50,140 --> 00:22:57,400
so here we just pass the current time

00:22:52,000 --> 00:23:01,810
then it produce this so there's not an

00:22:57,400 --> 00:23:03,520
example let's say our pattern is on 0th

00:23:01,810 --> 00:23:04,990
argument date you will have one number

00:23:03,520 --> 00:23:07,000
of meetings right and with passive to

00:23:04,990 --> 00:23:10,120
arguments we instantiate it for the

00:23:07,000 --> 00:23:11,620
english us locale with this pattern and

00:23:10,120 --> 00:23:13,870
we'll just say formatted with these

00:23:11,620 --> 00:23:17,600
arguments and it produces this string

00:23:13,870 --> 00:23:20,570
for you clear so far

00:23:17,600 --> 00:23:22,980
here's a little more complicated example

00:23:20,570 --> 00:23:25,409
in addition to just the type of the

00:23:22,980 --> 00:23:27,960
argument you can also provide some hints

00:23:25,409 --> 00:23:30,029
as to how it should be format how that

00:23:27,960 --> 00:23:32,220
type should be formatted so here we say

00:23:30,029 --> 00:23:33,809
okay I want I want a date but I want a

00:23:32,220 --> 00:23:36,119
short representation in that locale

00:23:33,809 --> 00:23:38,129
rather than the full one and i also want

00:23:36,119 --> 00:23:40,019
this number treated as a currency there

00:23:38,129 --> 00:23:42,690
are not just an integer and then when

00:23:40,019 --> 00:23:46,230
you pass this in and let's say is we use

00:23:42,690 --> 00:23:48,840
a english in great britain locale here

00:23:46,230 --> 00:23:59,129
it'll format it appropriately which is

00:23:48,840 --> 00:24:02,100
very cool yes hold on so with the how

00:23:59,129 --> 00:24:04,379
would you make a different pattern for

00:24:02,100 --> 00:24:06,659
different languages then yes and I'll

00:24:04,379 --> 00:24:12,299
talk about the need to do that later and

00:24:06,659 --> 00:24:15,029
how you would go about doing that too so

00:24:12,299 --> 00:24:16,350
here's a French example right and like I

00:24:15,029 --> 00:24:20,009
said depending on the language the

00:24:16,350 --> 00:24:21,899
location of these of these are where the

00:24:20,009 --> 00:24:24,570
things should be formatted into the

00:24:21,899 --> 00:24:28,700
parameters will vary and here we say

00:24:24,570 --> 00:24:31,499
okay we'll select the second one here

00:24:28,700 --> 00:24:33,269
sorry the third one here I guess then

00:24:31,499 --> 00:24:35,610
the first one then the second at the end

00:24:33,269 --> 00:24:37,110
and we want to format it as a date and

00:24:35,610 --> 00:24:38,970
you can give date formats he regulate I

00:24:37,110 --> 00:24:41,669
want to care about the date day and

00:24:38,970 --> 00:24:44,909
month and so on and then we pass it this

00:24:41,669 --> 00:24:46,289
array of arguments and the pattern

00:24:44,909 --> 00:24:49,279
appropriate selects the one that it

00:24:46,289 --> 00:24:52,769
needs from that list of arguments right

00:24:49,279 --> 00:24:56,279
and then French locale formatted and

00:24:52,769 --> 00:24:58,679
here's your locale sensitive message

00:24:56,279 --> 00:25:05,399
that are generated which some of you

00:24:58,679 --> 00:25:08,429
can't see I realize all right and you

00:25:05,399 --> 00:25:10,440
can also parse messages so let's say you

00:25:08,429 --> 00:25:12,539
have the same pattern as before and then

00:25:10,440 --> 00:25:13,919
you have the text that we generated or

00:25:12,539 --> 00:25:18,960
you know you received it from somewhere

00:25:13,919 --> 00:25:20,669
or whatever if you just say parse and I

00:25:18,960 --> 00:25:23,669
realize they should say text instead of

00:25:20,669 --> 00:25:25,649
argument so i'll have to fix that then

00:25:23,669 --> 00:25:28,259
it'll produce it will give you back an

00:25:25,649 --> 00:25:30,360
array which with the time stamp which is

00:25:28,259 --> 00:25:33,480
what it parse this state into

00:25:30,360 --> 00:25:36,360
and the number for the leaded parts from

00:25:33,480 --> 00:25:44,190
there as well this is really cool too

00:25:36,360 --> 00:25:45,150
and the patterns are depending how deep

00:25:44,190 --> 00:25:46,710
you want to go and can get really

00:25:45,150 --> 00:25:49,560
complicated some languages have

00:25:46,710 --> 00:25:53,880
different pluralities right depending on

00:25:49,560 --> 00:25:55,890
whether you use 012 whatever the things

00:25:53,880 --> 00:25:57,510
you want to put into the message may

00:25:55,890 --> 00:26:00,120
change but you don't know ahead of time

00:25:57,510 --> 00:26:02,520
what the argument will be right so there

00:26:00,120 --> 00:26:04,920
you can put in the rules in the pattern

00:26:02,520 --> 00:26:06,630
itself saying how to handle that so here

00:26:04,920 --> 00:26:08,580
we just want to say you know something

00:26:06,630 --> 00:26:10,620
like if it you did a search for

00:26:08,580 --> 00:26:12,810
something there are X results or no

00:26:10,620 --> 00:26:15,230
results or whatever right so you do

00:26:12,810 --> 00:26:18,960
something like this where you say okay

00:26:15,230 --> 00:26:21,810
this is going to be a plural selection

00:26:18,960 --> 00:26:24,570
and when it's zero produce this string

00:26:21,810 --> 00:26:26,490
when it's one say produce this string

00:26:24,570 --> 00:26:28,820
and the hash gets replaced with the

00:26:26,490 --> 00:26:31,350
actual argument that it received and

00:26:28,820 --> 00:26:33,540
otherwise if it's more than one then

00:26:31,350 --> 00:26:35,760
produce this string and then we

00:26:33,540 --> 00:26:37,920
instantiate it for the British locale

00:26:35,760 --> 00:26:40,680
and then format a couple times and

00:26:37,920 --> 00:26:45,440
here's a result which is really awesome

00:26:40,680 --> 00:26:49,440
I think and it has other things for like

00:26:45,440 --> 00:26:52,920
gender selection and choices which is

00:26:49,440 --> 00:26:54,780
you know there's a whole lot of stuff

00:26:52,920 --> 00:26:57,360
and this none of this is documented in

00:26:54,780 --> 00:27:00,360
the Intel extension but it is documented

00:26:57,360 --> 00:27:07,260
in the ICU user guide which you can take

00:27:00,360 --> 00:27:10,020
a look at all right break it raters so

00:27:07,260 --> 00:27:11,850
these things let you locate linguistic

00:27:10,020 --> 00:27:14,550
boundaries between various units and

00:27:11,850 --> 00:27:18,740
these the units that it operates on our

00:27:14,550 --> 00:27:18,740
characters words lines and sentences

00:27:19,280 --> 00:27:23,940
characters are basically boundaries

00:27:21,390 --> 00:27:26,700
between what we usually think as

00:27:23,940 --> 00:27:27,930
characters when we look at the text so

00:27:26,700 --> 00:27:29,910
grab with what are they also called

00:27:27,930 --> 00:27:32,570
graphemes because underneath it may be

00:27:29,910 --> 00:27:36,990
represented by more than one code point

00:27:32,570 --> 00:27:38,970
the word boundaries are for things like

00:27:36,990 --> 00:27:40,830
if you doing a board process or you want

00:27:38,970 --> 00:27:42,480
to double click and select a ward where

00:27:40,830 --> 00:27:44,290
should it actually do the selection

00:27:42,480 --> 00:27:47,440
lines is where you

00:27:44,290 --> 00:27:51,040
put a line break for wrapping text and

00:27:47,440 --> 00:27:56,380
sentences just you know for another

00:27:51,040 --> 00:27:58,000
larger unit that represents the text you

00:27:56,380 --> 00:28:00,820
can do more complex ones with custom

00:27:58,000 --> 00:28:03,130
rules which i'm not going to show here

00:28:00,820 --> 00:28:06,060
but all the oldies adult on those rules

00:28:03,130 --> 00:28:08,490
for each locale so there is an example

00:28:06,060 --> 00:28:11,700
let's say we take this sentence right

00:28:08,490 --> 00:28:15,910
where we have a number of different

00:28:11,700 --> 00:28:19,300
punctuation we have ? embedded here we

00:28:15,910 --> 00:28:21,220
have another period here and this is the

00:28:19,300 --> 00:28:23,230
actual end of the sentence like doing it

00:28:21,220 --> 00:28:24,640
by hand or by sort of instead of like

00:28:23,230 --> 00:28:27,640
logic you want to write yourself would

00:28:24,640 --> 00:28:29,410
be pretty hard I think right but you say

00:28:27,640 --> 00:28:31,240
int'l break it or create sentence

00:28:29,410 --> 00:28:33,310
instance for the locale that you want in

00:28:31,240 --> 00:28:36,070
this case English you set the text and

00:28:33,310 --> 00:28:38,430
then you do you call this thing called

00:28:36,070 --> 00:28:40,720
get parts iterator which is gives you

00:28:38,430 --> 00:28:43,150
iterated the actual parts of the words

00:28:40,720 --> 00:28:45,100
otherwise datas methods to access the

00:28:43,150 --> 00:28:46,710
boundaries but in case this case we want

00:28:45,100 --> 00:28:49,150
the actual words not the boundaries

00:28:46,710 --> 00:28:53,820
sorry the units not the boundaries and

00:28:49,150 --> 00:28:56,290
then it produces the correct sentences

00:28:53,820 --> 00:28:58,900
instead of you know potentially

00:28:56,290 --> 00:29:04,510
splitting on periods that there's like

00:28:58,900 --> 00:29:06,970
five of them there or for another but if

00:29:04,510 --> 00:29:10,840
we wanted to figure out wave way where

00:29:06,970 --> 00:29:14,020
we can wrap this text and if we're doing

00:29:10,840 --> 00:29:16,360
it you know on the line by line basis

00:29:14,020 --> 00:29:19,300
then we can instantiate a line iterator

00:29:16,360 --> 00:29:21,010
and then the resolve will be you know

00:29:19,300 --> 00:29:29,890
basically where we can put a line break

00:29:21,010 --> 00:29:35,050
in so that's one usage of it another is

00:29:29,890 --> 00:29:38,800
if you it's it also acts as a boundary

00:29:35,050 --> 00:29:40,900
interface so you can say okay to take

00:29:38,800 --> 00:29:43,030
take the same line break iterator and

00:29:40,900 --> 00:29:45,190
rewind it to the beginning so the very

00:29:43,030 --> 00:29:46,930
first boundary and then give me the next

00:29:45,190 --> 00:29:49,120
one and they Tommy Cole next that

00:29:46,930 --> 00:29:51,880
advances to the next boundary so in this

00:29:49,120 --> 00:29:54,460
case it keeps progressively outputting

00:29:51,880 --> 00:29:56,440
you know we keep doing larger substrings

00:29:54,460 --> 00:29:57,940
or you can say what's the boundary

00:29:56,440 --> 00:30:00,129
preceding this offset here

00:29:57,940 --> 00:30:02,799
and it'll give you the boundary before

00:30:00,129 --> 00:30:06,100
that so it's get a number of methods for

00:30:02,799 --> 00:30:08,799
like working with boundaries in addition

00:30:06,100 --> 00:30:22,179
to the actual units any questions on

00:30:08,799 --> 00:30:26,649
this yes I wonder if the boundary method

00:30:22,179 --> 00:30:29,110
also works with Chinese absolutely so it

00:30:26,649 --> 00:30:32,259
does the Chinese Chung King yes he

00:30:29,110 --> 00:30:34,360
detected the single word yes ok this is

00:30:32,259 --> 00:30:36,279
available right now it's available right

00:30:34,360 --> 00:30:38,500
now that's a good that's a good news

00:30:36,279 --> 00:30:41,139
yeah I just made your day today no

00:30:38,500 --> 00:30:43,690
because they know skidding I was working

00:30:41,139 --> 00:30:45,159
with this type of problems and I so

00:30:43,690 --> 00:30:47,289
that's quite complicated especially

00:30:45,159 --> 00:30:49,809
trying to their various metals and

00:30:47,289 --> 00:30:52,600
things sure um and I'm not gonna claim

00:30:49,809 --> 00:30:55,240
that it's perfect but it's but it's

00:30:52,600 --> 00:30:57,759
better than nothing he had nothing exact

00:30:55,240 --> 00:31:01,090
okay thank you I actually have it I

00:30:57,759 --> 00:31:04,049
haven't personally tried it but the

00:31:01,090 --> 00:31:07,120
locale data that this operates on I mean

00:31:04,049 --> 00:31:09,009
they ensure that it produces the correct

00:31:07,120 --> 00:31:10,750
results and there's always updates so it

00:31:09,009 --> 00:31:12,519
may you know if you you can submit bug

00:31:10,750 --> 00:31:16,360
reports against this too and they'll fix

00:31:12,519 --> 00:31:17,620
it in the next release alright so

00:31:16,360 --> 00:31:21,549
resource bundles this goes to your

00:31:17,620 --> 00:31:23,620
question about how to localize the for

00:31:21,549 --> 00:31:30,940
example the message formats for various

00:31:23,620 --> 00:31:33,309
languages so resource bundles contain

00:31:30,940 --> 00:31:36,330
resources that you want to localize so

00:31:33,309 --> 00:31:41,169
things like strings various messages

00:31:36,330 --> 00:31:43,690
formatting patterns numbers you know all

00:31:41,169 --> 00:31:48,190
kinds of stuff that you want to access

00:31:43,690 --> 00:31:52,269
them in a local independent fashion but

00:31:48,190 --> 00:31:54,879
have this this data localized for each

00:31:52,269 --> 00:31:58,210
locale and resource bundles let you do

00:31:54,879 --> 00:32:02,940
that via producing you can produce a

00:31:58,210 --> 00:32:07,119
hierarchy of your data and what it does

00:32:02,940 --> 00:32:08,230
and i'll mention fall back in a bit so

00:32:07,119 --> 00:32:09,210
let's say you want to organize your data

00:32:08,230 --> 00:32:12,299
in a

00:32:09,210 --> 00:32:13,470
in the fashion like this right you

00:32:12,299 --> 00:32:15,419
pretty much always started the route

00:32:13,470 --> 00:32:19,679
which contains your unlock Eliza

00:32:15,419 --> 00:32:21,750
untranslated resources and then you can

00:32:19,679 --> 00:32:23,070
break it down by language and say okay

00:32:21,750 --> 00:32:26,520
we're here we're working in spanish

00:32:23,070 --> 00:32:28,620
english japanese and chinese and then

00:32:26,520 --> 00:32:31,309
another level could be the chinese has

00:32:28,620 --> 00:32:31,309
simplified and traditional

00:32:31,340 --> 00:32:37,169
representations so we can split it on

00:32:34,770 --> 00:32:40,529
that and then pass that is a country

00:32:37,169 --> 00:32:43,110
level so here we have english the u.s.

00:32:40,529 --> 00:32:46,679
spanish could be for spain or mexico and

00:32:43,110 --> 00:32:48,899
then here you could have a china using

00:32:46,679 --> 00:32:52,020
simplified and hong kong using

00:32:48,899 --> 00:32:54,000
traditional and the key thing here is a

00:32:52,020 --> 00:32:57,720
thing called fallback mechanism which

00:32:54,000 --> 00:32:59,730
means that if it if you request to look

00:32:57,720 --> 00:33:01,740
hell that it doesn't have then it's

00:32:59,730 --> 00:33:03,960
going to fall back onto the one-upper in

00:33:01,740 --> 00:33:05,850
the hierarchy or if you request the

00:33:03,960 --> 00:33:10,830
resource and one in a locale that it

00:33:05,850 --> 00:33:12,899
doesn't have then it is going to look up

00:33:10,830 --> 00:33:16,559
the hierarchy again so if you try to

00:33:12,899 --> 00:33:18,000
request a for example this locale here

00:33:16,559 --> 00:33:20,909
but let's say we didn't have it then it

00:33:18,000 --> 00:33:25,230
would look here first then here second

00:33:20,909 --> 00:33:27,809
hand and finally in the route 1 in the

00:33:25,230 --> 00:33:30,779
data format for how you construct these

00:33:27,809 --> 00:33:34,140
bundles is to text you make text files

00:33:30,779 --> 00:33:35,909
basically and you can have simple

00:33:34,140 --> 00:33:37,980
resources which are things like strings

00:33:35,909 --> 00:33:40,649
integers binary data if you want to

00:33:37,980 --> 00:33:43,200
embed images in there or integer arrays

00:33:40,649 --> 00:33:48,179
and complex resources are basically

00:33:43,200 --> 00:33:50,250
arrays and maps are raised in tables so

00:33:48,179 --> 00:33:52,529
let's say we want to build up a simple

00:33:50,250 --> 00:33:54,480
resourcebundle so we'll start with the

00:33:52,529 --> 00:33:57,510
route one where the unlock alized or

00:33:54,480 --> 00:33:59,159
ones are and i'm simply grossly

00:33:57,510 --> 00:34:01,230
simplifying here but let's say we have

00:33:59,159 --> 00:34:05,250
this route takes you file this is the

00:34:01,230 --> 00:34:08,760
name of our locale we'll put a string in

00:34:05,250 --> 00:34:11,970
there by perversion we'll have a main

00:34:08,760 --> 00:34:14,879
title and say welcome to our store you

00:34:11,970 --> 00:34:16,889
can have an array of strings here we

00:34:14,879 --> 00:34:19,530
have some like website being this

00:34:16,889 --> 00:34:21,659
video's maximum and this is the this is

00:34:19,530 --> 00:34:22,980
a formatting pattern rate so you can see

00:34:21,659 --> 00:34:24,419
how when you localize this

00:34:22,980 --> 00:34:26,369
later you can switch things around and

00:34:24,419 --> 00:34:29,280
translate it and omits omit some things

00:34:26,369 --> 00:34:33,840
and select which argument you want to

00:34:29,280 --> 00:34:36,570
use and this is a int vector array of

00:34:33,840 --> 00:34:39,869
integers basically and let's say we have

00:34:36,570 --> 00:34:45,869
another locale for Great Britain and

00:34:39,869 --> 00:34:48,990
here we we yeah I struggle with the put

00:34:45,869 --> 00:34:51,090
in there but here notice we override

00:34:48,990 --> 00:34:54,359
only certain ones we override version

00:34:51,090 --> 00:34:56,820
title and sizes and we leave the errors

00:34:54,359 --> 00:34:58,560
the same so in this case if you request

00:34:56,820 --> 00:35:00,060
errors from this locale it'll actually

00:34:58,560 --> 00:35:02,990
go back to the route one and find it

00:35:00,060 --> 00:35:07,710
there right so once you once you

00:35:02,990 --> 00:35:09,570
localize your messages and data in these

00:35:07,710 --> 00:35:11,490
files then you need to compile them in

00:35:09,570 --> 00:35:14,010
it there's a tool that get comes with i

00:35:11,490 --> 00:35:15,390
see you called jen RB so you do

00:35:14,010 --> 00:35:17,520
something like this where you say make a

00:35:15,390 --> 00:35:19,680
directory and then jen RB put the

00:35:17,520 --> 00:35:23,250
resources here and give it a list of

00:35:19,680 --> 00:35:25,760
these files right and then one that runs

00:35:23,250 --> 00:35:28,200
through that is going to tell you a very

00:35:25,760 --> 00:35:29,609
first message saying how many files with

00:35:28,200 --> 00:35:31,980
processed and it's going to generate

00:35:29,609 --> 00:35:36,750
these binary things that you can load up

00:35:31,980 --> 00:35:38,100
later from PHP and so let's say we want

00:35:36,750 --> 00:35:40,680
to retrieve this let's say we just want

00:35:38,100 --> 00:35:43,200
to do a root one so we find where our

00:35:40,680 --> 00:35:45,359
resource bundle directory is and we say

00:35:43,200 --> 00:35:47,700
create for the root locale this is the

00:35:45,359 --> 00:35:50,220
directory then we gives you back an

00:35:47,700 --> 00:35:53,400
object that you can access as an array

00:35:50,220 --> 00:35:56,190
basically you say main title give me the

00:35:53,400 --> 00:36:00,000
second error what are the sizes and it

00:35:56,190 --> 00:36:01,410
gives you this stuff right and let's say

00:36:00,000 --> 00:36:03,180
we want to retrieve the Great Britain

00:36:01,410 --> 00:36:05,910
one so we just switch out with the

00:36:03,180 --> 00:36:07,710
locale exact same code after that and

00:36:05,910 --> 00:36:13,350
then it gives you the appropriate thing

00:36:07,710 --> 00:36:17,310
that it found yes yeah I had a question

00:36:13,350 --> 00:36:19,740
about format of text files because it

00:36:17,310 --> 00:36:22,530
wasn't clear if you're using and just a

00:36:19,740 --> 00:36:24,810
custom format or its I see you custom

00:36:22,530 --> 00:36:26,580
format that they write with is it

00:36:24,810 --> 00:36:28,410
documented somewhere it's documented in

00:36:26,580 --> 00:36:30,330
the user guide all right yeah yeah

00:36:28,410 --> 00:36:34,950
pretty pretty well actually so you can

00:36:30,330 --> 00:36:36,660
refer other that all right um so that's

00:36:34,950 --> 00:36:39,299
the basic idea

00:36:36,660 --> 00:36:41,099
oh let's say we request a locale that

00:36:39,299 --> 00:36:42,599
doesn't exist at all right like German

00:36:41,099 --> 00:36:44,250
we didn't localize for that then it's

00:36:42,599 --> 00:36:46,099
going to use the route one because

00:36:44,250 --> 00:36:50,309
that's the one that happens right before

00:36:46,099 --> 00:36:54,780
in a hierarchy so that's it for resource

00:36:50,309 --> 00:36:59,849
bundles all right next thing spoof

00:36:54,780 --> 00:37:02,609
checking it's pretty awesome so Unicode

00:36:59,849 --> 00:37:04,920
has like a stupidly large number of

00:37:02,609 --> 00:37:08,130
characters right and has a bunch of

00:37:04,920 --> 00:37:10,470
writing systems and scripts and if used

00:37:08,130 --> 00:37:15,230
incorrectly that you can run run into

00:37:10,470 --> 00:37:17,520
some security holes or security problems

00:37:15,230 --> 00:37:23,849
where malicious people can do things

00:37:17,520 --> 00:37:27,030
like this you ever see this guess what

00:37:23,849 --> 00:37:30,299
happens when you click on that it does

00:37:27,030 --> 00:37:34,260
not go to paypal because in fact this is

00:37:30,299 --> 00:37:36,990
not an L this is an uppercase I and this

00:37:34,260 --> 00:37:39,480
this was actually an exploit that went

00:37:36,990 --> 00:37:42,270
around in naive people you know clicked

00:37:39,480 --> 00:37:45,390
on it and said hey login into my paypal

00:37:42,270 --> 00:37:49,950
account I want my money and they stole

00:37:45,390 --> 00:37:53,970
their passwords so spoof checker helps

00:37:49,950 --> 00:37:55,740
you deal with things like this it helps

00:37:53,970 --> 00:38:01,049
you prevent certain classes of security

00:37:55,740 --> 00:38:04,440
attacks where you which rely on sort of

00:38:01,049 --> 00:38:07,619
visual confusion which can be pretty

00:38:04,440 --> 00:38:10,500
pervasive because you know used to be

00:38:07,619 --> 00:38:13,170
that yeah yet they may have had a

00:38:10,500 --> 00:38:15,180
confusing URL in the body like in the

00:38:13,170 --> 00:38:17,579
browser but if you mouse over it then

00:38:15,180 --> 00:38:18,539
like you could see the real one at the

00:38:17,579 --> 00:38:20,130
bottom of the browser but with

00:38:18,539 --> 00:38:21,779
JavaScript and all that stuff all that's

00:38:20,130 --> 00:38:23,579
like a parade meant defeated there on

00:38:21,779 --> 00:38:26,190
the real way people thought all right I

00:38:23,579 --> 00:38:28,980
actually loaded up and see what's in the

00:38:26,190 --> 00:38:30,900
URL right well guess what because of

00:38:28,980 --> 00:38:32,490
internationalized domain names you can

00:38:30,900 --> 00:38:34,319
have characters from our languages and

00:38:32,490 --> 00:38:37,799
domains now which are visually confusing

00:38:34,319 --> 00:38:40,309
right and you're screwed don't ever

00:38:37,799 --> 00:38:40,309
click on a link

00:38:41,859 --> 00:38:49,730
so if this lets you check identifier for

00:38:45,499 --> 00:38:51,470
visual confusion and various types of

00:38:49,730 --> 00:38:53,029
confusion that can happen you can have

00:38:51,470 --> 00:38:56,720
to identify errs from the same script

00:38:53,029 --> 00:38:59,359
but are confusing like that paypal l and

00:38:56,720 --> 00:39:00,950
uppercase I you can have to identify its

00:38:59,359 --> 00:39:02,960
that incorporate characters from

00:39:00,950 --> 00:39:06,289
different scripts and confusing and you

00:39:02,960 --> 00:39:08,029
have identifiers that one is it from one

00:39:06,289 --> 00:39:09,380
script completely and one is from

00:39:08,029 --> 00:39:12,619
another but they're still confusing

00:39:09,380 --> 00:39:15,440
right so here's an example you say we

00:39:12,619 --> 00:39:18,650
have two URLs right we have google and

00:39:15,440 --> 00:39:19,670
google one E and if we say new spoof

00:39:18,650 --> 00:39:24,559
checker i'm going to say are they

00:39:19,670 --> 00:39:28,220
confusable it's going to say they're

00:39:24,559 --> 00:39:29,660
confusable right which is good now

00:39:28,220 --> 00:39:33,549
here's another example it's for the

00:39:29,660 --> 00:39:36,349
single script now for the mixed script

00:39:33,549 --> 00:39:41,569
what do you think about this are they

00:39:36,349 --> 00:39:47,599
confusable so the second o is a Cyrillic

00:39:41,569 --> 00:39:49,009
oh and I actually I had to go through a

00:39:47,599 --> 00:39:50,869
few fonts where they would not be

00:39:49,009 --> 00:39:52,339
distinguishable otherwise depending on

00:39:50,869 --> 00:40:04,309
the font rendering you may notice the

00:39:52,339 --> 00:40:06,440
difference like here so this is a this

00:40:04,309 --> 00:40:09,079
is mythical confusable there's another

00:40:06,440 --> 00:40:10,880
one called is suspicious which just

00:40:09,079 --> 00:40:13,400
tells you whether a certain identifier

00:40:10,880 --> 00:40:15,499
is suspicious on a certain locale so

00:40:13,400 --> 00:40:17,960
let's say we have this here which does

00:40:15,499 --> 00:40:20,230
not say hope by the way its user

00:40:17,960 --> 00:40:23,450
Cyrillic letters to pretend it says hope

00:40:20,230 --> 00:40:26,029
what you say okay we're only allowing an

00:40:23,450 --> 00:40:27,739
english locale here is it suspicious and

00:40:26,029 --> 00:40:28,910
say yep it's suspicious in that locale

00:40:27,739 --> 00:40:32,210
because it's using characters from

00:40:28,910 --> 00:40:33,499
another one but if you say allow Russian

00:40:32,210 --> 00:40:40,549
one as well then it's going to say not

00:40:33,499 --> 00:40:43,119
suspicious right so that's useful now my

00:40:40,549 --> 00:40:43,119
favorite section

00:40:44,180 --> 00:40:52,609
so translator Reiter is a thing that you

00:40:50,059 --> 00:40:56,950
can use to do script transliteration

00:40:52,609 --> 00:40:59,240
which is converting or representing

00:40:56,950 --> 00:41:03,140
characters from one script in another in

00:40:59,240 --> 00:41:04,609
a way that sounds the same basically you

00:41:03,140 --> 00:41:06,530
run into it all the time and you try and

00:41:04,609 --> 00:41:09,500
transcribe foreign names for example

00:41:06,530 --> 00:41:11,270
into English or vice versa and

00:41:09,500 --> 00:41:13,520
originally was used just for the Justice

00:41:11,270 --> 00:41:16,520
crib transliteration but it actually is

00:41:13,520 --> 00:41:18,859
a much more general transform mechanism

00:41:16,520 --> 00:41:20,720
that is very customized Bonnie can do

00:41:18,859 --> 00:41:22,670
things like case mappings normalization

00:41:20,720 --> 00:41:25,460
if you're familiar with Unicode you know

00:41:22,670 --> 00:41:30,619
what normalization is full half with

00:41:25,460 --> 00:41:32,059
four Japanese like convert code points

00:41:30,619 --> 00:41:35,210
to hex sort of character names and

00:41:32,059 --> 00:41:39,290
things like that and the basic thing

00:41:35,210 --> 00:41:40,880
that works with 0 and transforms can be

00:41:39,290 --> 00:41:42,530
chained together to perform a series of

00:41:40,880 --> 00:41:45,470
operations so it's not just a one-trick

00:41:42,530 --> 00:41:47,150
pony and the things of basic ideas it

00:41:45,470 --> 00:41:49,220
uses this thing called transliteration

00:41:47,150 --> 00:41:51,170
IDs where the format is something like

00:41:49,220 --> 00:41:55,880
source from where you're going to target

00:41:51,170 --> 00:41:59,030
/ variant and source and target

00:41:55,880 --> 00:42:03,349
specifiers can the script IDs like Latin

00:41:59,030 --> 00:42:05,299
for example or katakana or Greek or it

00:42:03,349 --> 00:42:08,530
can be Unicode language identifiers just

00:42:05,299 --> 00:42:11,630
the short ones like fre n you know or

00:42:08,530 --> 00:42:14,119
special tags like any or hex and I'll

00:42:11,630 --> 00:42:15,950
show you an example the only really

00:42:14,119 --> 00:42:17,829
required one is the target because if

00:42:15,950 --> 00:42:21,440
you don't if you don't use the source it

00:42:17,829 --> 00:42:23,030
assumes it's any and if there is a rule

00:42:21,440 --> 00:42:27,079
in there that it tries to that it can

00:42:23,030 --> 00:42:29,599
understand from the text what the scrip

00:42:27,079 --> 00:42:33,040
is it'll just use that and variant is

00:42:29,599 --> 00:42:35,750
just a modification on some conversions

00:42:33,040 --> 00:42:38,750
you can create inverse if you swap

00:42:35,750 --> 00:42:40,160
target and source or you can call create

00:42:38,750 --> 00:42:41,599
inverse method to just do it

00:42:40,160 --> 00:42:43,099
automatically for you but keep in mind

00:42:41,599 --> 00:42:44,569
that not all transformations are

00:42:43,099 --> 00:42:48,079
reversible right like if you do

00:42:44,569 --> 00:42:49,220
lowercase something you can't really

00:42:48,079 --> 00:42:50,540
restore it back because you don't know

00:42:49,220 --> 00:42:54,810
what the original was right somewhat

00:42:50,540 --> 00:42:57,330
lossy so here's an example

00:42:54,810 --> 00:42:59,490
for some some sample IDs like I want to

00:42:57,330 --> 00:43:02,400
go from katakana to Latin or I wanna go

00:42:59,490 --> 00:43:06,000
from Latin to ascii NFD is normalized

00:43:02,400 --> 00:43:08,490
decomposed form for unicode i want to go

00:43:06,000 --> 00:43:10,200
from Annie to hex basically to take care

00:43:08,490 --> 00:43:14,160
of tourism represent them as hex

00:43:10,200 --> 00:43:16,020
entities and XML format so a script

00:43:14,160 --> 00:43:17,880
conversion let's say you say all right i

00:43:16,020 --> 00:43:20,130
want to go from any to latin here's the

00:43:17,880 --> 00:43:23,490
sign that i saw in japan somewhere right

00:43:20,130 --> 00:43:25,140
and turns alliterate it and it says it's

00:43:23,490 --> 00:43:31,230
makoto naruto which is with mcdonald's

00:43:25,140 --> 00:43:32,970
is and we can check we can say ok create

00:43:31,230 --> 00:43:34,560
a latin to katakana one and translator

00:43:32,970 --> 00:43:35,880
it back and make sure that matches

00:43:34,560 --> 00:43:40,140
because katakana to light and is

00:43:35,880 --> 00:43:44,040
reversible here's another example for a

00:43:40,140 --> 00:43:45,690
Cyrillic so let's say i'll go from

00:43:44,040 --> 00:43:47,520
Cyrillic to Latin here's a sir like fang

00:43:45,690 --> 00:43:50,460
and it produces something like this

00:43:47,520 --> 00:43:51,750
which i'm russian like the way I used to

00:43:50,460 --> 00:43:55,500
translate rating is not like this

00:43:51,750 --> 00:43:57,840
there's a different format and you can

00:43:55,500 --> 00:43:59,970
use that for Matt if you use a variant /

00:43:57,840 --> 00:44:01,740
BGN which is like board of geographic

00:43:59,970 --> 00:44:04,350
names or something like that and if you

00:44:01,740 --> 00:44:05,310
translate the exact same phrase it's

00:44:04,350 --> 00:44:07,740
going to give you something like this

00:44:05,310 --> 00:44:15,090
which is I think more pronounceable for

00:44:07,740 --> 00:44:18,150
foreign speakers of Russian all right

00:44:15,090 --> 00:44:20,640
let's say you want to get if you use any

00:44:18,150 --> 00:44:22,830
to name it gives you back the Unicode

00:44:20,640 --> 00:44:24,720
character names for the symbols so here

00:44:22,830 --> 00:44:27,330
we have Cyrillic small letter yah and

00:44:24,720 --> 00:44:28,710
then dollar sign just as an example in

00:44:27,330 --> 00:44:29,970
case that's useful for you because you

00:44:28,710 --> 00:44:33,120
want to know what the actual unit code

00:44:29,970 --> 00:44:36,450
symbol is called there's a useful one

00:44:33,120 --> 00:44:38,160
called latin to ascii so it tries to

00:44:36,450 --> 00:44:41,010
take the characters and represent them

00:44:38,160 --> 00:44:42,390
in a ski as close as possible so i could

00:44:41,010 --> 00:44:44,940
give it a copyright sign it actually

00:44:42,390 --> 00:44:50,520
produces three characters that represent

00:44:44,940 --> 00:44:52,680
copyright and things like that compound

00:44:50,520 --> 00:44:55,200
ID so let's say we have Greek to Latin

00:44:52,680 --> 00:44:58,800
and we give this Greek phrase to it and

00:44:55,200 --> 00:45:01,200
give us back the result but we don't

00:44:58,800 --> 00:45:02,760
really want accents accents are

00:45:01,200 --> 00:45:04,710
confusing we just want base characters

00:45:02,760 --> 00:45:07,200
right so there's a way to do that even

00:45:04,710 --> 00:45:08,779
though it's not built into this into

00:45:07,200 --> 00:45:10,559
this

00:45:08,779 --> 00:45:13,559
transformer what we can say something

00:45:10,559 --> 00:45:15,960
like this right we say create and so

00:45:13,559 --> 00:45:18,119
Greek to Latin first then decompose it

00:45:15,960 --> 00:45:20,460
into base character and combining ones

00:45:18,119 --> 00:45:22,470
the accents and then this is a filter it

00:45:20,460 --> 00:45:24,749
says for any non spacing mark which are

00:45:22,470 --> 00:45:26,640
the accents remove them get rid of them

00:45:24,749 --> 00:45:29,130
and then compose it back into one

00:45:26,640 --> 00:45:30,660
character and when it runs runs through

00:45:29,130 --> 00:45:33,539
this it gives you back the result here

00:45:30,660 --> 00:45:35,490
and there various filters and you know

00:45:33,539 --> 00:45:39,180
rules mappings you can use you can say

00:45:35,490 --> 00:45:40,589
like okay take only certain characters

00:45:39,180 --> 00:45:42,960
that match this filter and lowercase a

00:45:40,589 --> 00:45:47,460
modification or whatever or translate

00:45:42,960 --> 00:45:49,470
only goes and if that's not enough

00:45:47,460 --> 00:45:51,359
there's rule-based transforms so you can

00:45:49,470 --> 00:45:53,130
completely right like in another

00:45:51,359 --> 00:45:56,130
language that I guess they invented sort

00:45:53,130 --> 00:45:58,349
of like regular expressions maybe they

00:45:56,130 --> 00:45:59,880
didn't need to do that but there's a

00:45:58,349 --> 00:46:03,029
rule-based transform so let's say we

00:45:59,880 --> 00:46:05,130
want to write a rule which collapses

00:46:03,029 --> 00:46:06,990
multiple spaces into single and converts

00:46:05,130 --> 00:46:10,289
those fake dashes dash dash into real

00:46:06,990 --> 00:46:12,690
ones right so it's a create a variable

00:46:10,289 --> 00:46:16,160
dollar space here and then this is a

00:46:12,690 --> 00:46:20,730
syntax that says if you see this

00:46:16,160 --> 00:46:23,390
converted to a single space and then or

00:46:20,730 --> 00:46:26,789
if you see this occurrence of sequence

00:46:23,390 --> 00:46:28,200
converted to real dash and the less than

00:46:26,789 --> 00:46:30,779
greater that means that goes backwards

00:46:28,200 --> 00:46:33,180
as well so if it sees a real dash if you

00:46:30,779 --> 00:46:36,329
do the inverse one then it'll go back to

00:46:33,180 --> 00:46:38,640
two dashes which is good and you say

00:46:36,329 --> 00:46:41,039
create from rules and give it this very

00:46:38,640 --> 00:46:44,249
spacey and delimited remark and it gives

00:46:41,039 --> 00:46:52,380
you back the result right it's pretty

00:46:44,249 --> 00:46:57,150
cool so we could talk a whole lot more

00:46:52,380 --> 00:46:58,950
about this things like which I wanted to

00:46:57,150 --> 00:47:00,690
put in but I felt they would take too

00:46:58,950 --> 00:47:02,970
much time this thing there's a classes

00:47:00,690 --> 00:47:05,190
that deal with date times time zones and

00:47:02,970 --> 00:47:07,019
calendars which have a huge number of

00:47:05,190 --> 00:47:09,599
methods if you're really into that I

00:47:07,019 --> 00:47:12,390
encourage you to go look at that but for

00:47:09,599 --> 00:47:14,700
now so the pec hole is where the

00:47:12,390 --> 00:47:17,849
extension lives where the updates are

00:47:14,700 --> 00:47:20,249
released the php.net / gentle has the

00:47:17,849 --> 00:47:21,840
class documentation and some of those

00:47:20,249 --> 00:47:27,120
classes like I said a bear doc

00:47:21,840 --> 00:47:29,310
than others CLD r dot unicode org is the

00:47:27,120 --> 00:47:30,660
common locale data repository one you

00:47:29,310 --> 00:47:33,270
can go and see when they did the latest

00:47:30,660 --> 00:47:35,970
release or what they fixed in it in case

00:47:33,270 --> 00:47:38,550
there was a problem and this is the user

00:47:35,970 --> 00:47:44,960
guide for the ICU project which has more

00:47:38,550 --> 00:47:44,960
documentation as i mentioned questions

00:47:50,150 --> 00:47:57,270
are you familiar with this the framework

00:47:52,950 --> 00:48:00,960
symfony2 I've heard of it yeah that they

00:47:57,270 --> 00:48:02,280
do translation differently you through I

00:48:00,960 --> 00:48:05,640
actually have no idea what they use

00:48:02,280 --> 00:48:09,090
somebody no okay yes somebody doesn't

00:48:05,640 --> 00:48:17,010
know they got their own built-in I guess

00:48:09,090 --> 00:48:18,470
yeah anybody else hello right at the

00:48:17,010 --> 00:48:20,990
beginning we're talking about what

00:48:18,470 --> 00:48:23,280
character sets you can convert between

00:48:20,990 --> 00:48:26,100
I'd like to know if you can convert

00:48:23,280 --> 00:48:29,550
between utf-8 and say gsm characters

00:48:26,100 --> 00:48:33,030
that you can send via text message can

00:48:29,550 --> 00:48:34,680
you convert between utf-8 in ut f7 don't

00:48:33,030 --> 00:48:36,180
I think is I think as a subset of UTS

00:48:34,680 --> 00:48:38,850
happen isn't it is that your questioner

00:48:36,180 --> 00:48:40,590
well my question is all the characters

00:48:38,850 --> 00:48:42,210
you've got in the GSM sat I think

00:48:40,590 --> 00:48:44,100
there's any 128 or something like that

00:48:42,210 --> 00:48:46,590
in these well what's going to happen is

00:48:44,100 --> 00:48:48,270
if the converter can't map the character

00:48:46,590 --> 00:48:50,460
to the target of character set is going

00:48:48,270 --> 00:48:53,510
to use that substitution one whatever is

00:48:50,460 --> 00:48:56,970
defined by default which is usually that

00:48:53,510 --> 00:48:59,730
the control Z you know not the

00:48:56,970 --> 00:49:01,530
non-printable one but you can you can

00:48:59,730 --> 00:49:05,330
have a custom one and for your target

00:49:01,530 --> 00:49:05,330
character set okay thank you

00:49:06,800 --> 00:49:08,860
you

00:49:10,560 --> 00:49:14,670
just a tiny one can use named arguments

00:49:13,200 --> 00:49:17,280
in the message formats or rather than

00:49:14,670 --> 00:49:18,450
numerical I think you can I haven't

00:49:17,280 --> 00:49:23,520
actually tried it but I think they do

00:49:18,450 --> 00:49:25,760
have a named argument support this one

00:49:23,520 --> 00:49:25,760
there

00:49:33,540 --> 00:49:39,160
with the with the word boundaries and

00:49:36,820 --> 00:49:42,520
all that kind of splitting into words

00:49:39,160 --> 00:49:45,070
and sentences is there any data on how

00:49:42,520 --> 00:49:48,070
performin that is because obviously

00:49:45,070 --> 00:49:50,320
there are very naive kind of algorithms

00:49:48,070 --> 00:49:54,760
of doing it and they rate be a lot

00:49:50,320 --> 00:49:59,020
faster but I can't speak to how

00:49:54,760 --> 00:50:01,090
performant they are but the the same

00:49:59,020 --> 00:50:04,060
rules that the boundary analysis is

00:50:01,090 --> 00:50:05,920
based on the CLD our data is used by

00:50:04,060 --> 00:50:08,140
Apple a bunch of other companies like I

00:50:05,920 --> 00:50:10,360
so I'm pretty sure they put an effort to

00:50:08,140 --> 00:50:12,370
make them as performant as possible I

00:50:10,360 --> 00:50:15,160
see you library like the ASU libraries

00:50:12,370 --> 00:50:18,040
using Java as the basic like it's it's

00:50:15,160 --> 00:50:24,520
been bundled with it forever okay cool

00:50:18,040 --> 00:50:29,320
thank you yeah in case there's no more

00:50:24,520 --> 00:50:30,760
questions thank yes one more I was just

00:50:29,320 --> 00:50:33,310
wondering if there's some sort of

00:50:30,760 --> 00:50:35,710
support for the way the characters are

00:50:33,310 --> 00:50:37,810
sorted in database because in the past

00:50:35,710 --> 00:50:40,300
has been some conflicts about database

00:50:37,810 --> 00:50:42,300
collation and getting them out and

00:50:40,300 --> 00:50:46,390
getting different characters back and

00:50:42,300 --> 00:50:48,790
that's kind of um difficult many

00:50:46,390 --> 00:50:52,210
situation yes we will not mention the

00:50:48,790 --> 00:50:54,730
database name that has terrible terrible

00:50:52,210 --> 00:50:57,900
support for it it starts with my and it

00:50:54,730 --> 00:50:57,900
ends with sequel yeah

00:50:59,510 --> 00:51:07,140
this so I would only say try if you want

00:51:05,010 --> 00:51:09,810
to store some in database make sure that

00:51:07,140 --> 00:51:12,330
the database tables or whatever

00:51:09,810 --> 00:51:15,260
collections and manga like they they are

00:51:12,330 --> 00:51:17,520
utf-8 and you in your store data utf-8

00:51:15,260 --> 00:51:22,230
like beyond that this has no particular

00:51:17,520 --> 00:51:26,160
support for any databases okay yeah yeah

00:51:22,230 --> 00:51:28,050
there's it you can't it's a general tool

00:51:26,160 --> 00:51:31,070
it's not a you know specific for a

00:51:28,050 --> 00:51:33,540
certain database format of system

00:51:31,070 --> 00:51:36,740
there's a joint in link there which you

00:51:33,540 --> 00:51:39,870
probably can't see but it's 10 704 is

00:51:36,740 --> 00:51:41,700
the talk ID or you can just go to joined

00:51:39,870 --> 00:51:44,430
in and find the stock i would appreciate

00:51:41,700 --> 00:51:46,700
comments if you have any otherwise let's

00:51:44,430 --> 00:51:46,700
go eat

00:51:51,869 --> 00:51:53,930

YouTube URL: https://www.youtube.com/watch?v=g3M6YzzBEI4


