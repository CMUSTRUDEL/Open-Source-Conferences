Title: PHP UK Conference 2011 - ZeroMQ is the answer, by Ian Barber
Publication date: 2012-03-15
Playlist: PHP UK Conference 2011
Description: 
	
Captions: 
	00:00:02,900 --> 00:00:11,219
I'm in Barbara's Marco side I work for

00:00:07,230 --> 00:00:12,660
virgin and I'm talking about zeromq and

00:00:11,219 --> 00:00:15,570
this is the first time I've done this

00:00:12,660 --> 00:00:17,670
talk and I really like this library I

00:00:15,570 --> 00:00:19,800
think it's really really cool so I'd

00:00:17,670 --> 00:00:21,180
love to hear your feedback on what you

00:00:19,800 --> 00:00:23,250
thought was good about the talk about

00:00:21,180 --> 00:00:29,520
the library anything joined in is a

00:00:23,250 --> 00:00:31,020
excellent place for that so 0 and Q is a

00:00:29,520 --> 00:00:34,020
project that makes people sort of say

00:00:31,020 --> 00:00:37,230
things like this and that's a bit weird

00:00:34,020 --> 00:00:39,060
it's a bit of a fog thing it's 0 and Q

00:00:37,230 --> 00:00:41,820
is unbelievably cool if you haven't got

00:00:39,060 --> 00:00:44,910
a project that needs it make one up and

00:00:41,820 --> 00:00:47,220
that's by a guy called John Giffard from

00:00:44,910 --> 00:00:49,260
from a site called la Glee that do very

00:00:47,220 --> 00:00:52,140
large-scale log a great aggregation for

00:00:49,260 --> 00:00:54,149
cloud systems and they're using 0 and Q

00:00:52,140 --> 00:00:57,180
right now at a very high level of

00:00:54,149 --> 00:00:58,649
traffic he loves it and I think that's

00:00:57,180 --> 00:01:00,300
the reaction I found from almost

00:00:58,649 --> 00:01:02,430
everyone to spend time working with 0

00:01:00,300 --> 00:01:03,870
and Q and I think the reason that you

00:01:02,430 --> 00:01:05,450
get that reaction is because zero and

00:01:03,870 --> 00:01:08,490
key lets you do a very difficult thing

00:01:05,450 --> 00:01:12,420
he simply and that's bill distributed

00:01:08,490 --> 00:01:15,179
systems now anyone have a look to any mq

00:01:12,420 --> 00:01:18,329
something mq then they probably think of

00:01:15,179 --> 00:01:19,469
a system that is so message queue

00:01:18,329 --> 00:01:21,749
something that sits in the middle of

00:01:19,469 --> 00:01:24,539
your network and will help you solve a

00:01:21,749 --> 00:01:26,880
problem and that's not what zeromq it

00:01:24,539 --> 00:01:30,929
zeromq is not a demon zeromq is not a

00:01:26,880 --> 00:01:33,689
server zeromq is a library and zeromq is

00:01:30,929 --> 00:01:35,459
a way that you plug things together it

00:01:33,689 --> 00:01:37,079
has the ability to be a message queue it

00:01:35,459 --> 00:01:40,439
has the ability to be a lot of different

00:01:37,079 --> 00:01:43,079
things but it's primarily a socket

00:01:40,439 --> 00:01:47,639
system that allows you to do concurrency

00:01:43,079 --> 00:01:50,090
queuing and high availability 0 mq is

00:01:47,639 --> 00:01:53,669
really a series of multiple queues that

00:01:50,090 --> 00:01:55,200
talk to each other and these different

00:01:53,669 --> 00:01:57,569
points that are talking to each other

00:01:55,200 --> 00:01:59,700
they could be two different machines on

00:01:57,569 --> 00:02:02,340
a network they could be two different

00:01:59,700 --> 00:02:04,139
processes within one machine they could

00:02:02,340 --> 00:02:06,630
be two different threads within one

00:02:04,139 --> 00:02:11,130
process or they could be any mix of

00:02:06,630 --> 00:02:14,280
those so the way that zeromq is built is

00:02:11,130 --> 00:02:16,300
around patterns and the way that you

00:02:14,280 --> 00:02:19,480
tend to implement it is around

00:02:16,300 --> 00:02:21,580
a higher level of patterns so on the

00:02:19,480 --> 00:02:22,720
left-hand side here we've got three

00:02:21,580 --> 00:02:25,000
patterns that we're going to look at

00:02:22,720 --> 00:02:27,820
today a queue a pipeline and

00:02:25,000 --> 00:02:29,680
publish-subscribe another right hand

00:02:27,820 --> 00:02:31,720
side you've kind of got extensions of

00:02:29,680 --> 00:02:33,340
that an ESB and Enterprise Service bus

00:02:31,720 --> 00:02:36,610
have you ever encountered one of those

00:02:33,340 --> 00:02:39,310
they're basically a fancy q if you ever

00:02:36,610 --> 00:02:41,380
encountered a sink well a sink really

00:02:39,310 --> 00:02:43,120
just the kind of pipeline process and at

00:02:41,380 --> 00:02:44,560
the bottom that complex one that's a

00:02:43,120 --> 00:02:46,930
gateway well that's a forwarder

00:02:44,560 --> 00:02:49,510
sometimes it's a message distribution

00:02:46,930 --> 00:02:51,340
something like pubs are the easiest way

00:02:49,510 --> 00:02:52,930
to understand why your own key works and

00:02:51,340 --> 00:02:54,640
why it's useful and why it's going to

00:02:52,930 --> 00:02:58,090
solve problems for you I hope is to look

00:02:54,640 --> 00:02:59,380
at some code so this is about the

00:02:58,090 --> 00:03:02,860
simplest thing that you can do with any

00:02:59,380 --> 00:03:05,500
network system a request-response it's

00:03:02,860 --> 00:03:07,240
sending a message getting a reply it's

00:03:05,500 --> 00:03:09,670
client-server it's exactly what happens

00:03:07,240 --> 00:03:13,210
with almost every service that we use at

00:03:09,670 --> 00:03:14,830
the moment and in zeromq you can go and

00:03:13,210 --> 00:03:16,450
of right how you think you should be

00:03:14,830 --> 00:03:19,060
able to write for almost any socket

00:03:16,450 --> 00:03:20,560
library so you always have a context of

00:03:19,060 --> 00:03:23,050
0 and Q and that first line that you

00:03:20,560 --> 00:03:25,720
maybe can see anyone at the back can see

00:03:23,050 --> 00:03:27,190
that a little bit okay that first line

00:03:25,720 --> 00:03:29,680
is creating to where the global state

00:03:27,190 --> 00:03:31,630
for 0 and Q lives there isn't it has

00:03:29,680 --> 00:03:33,850
that is because if you include a library

00:03:31,630 --> 00:03:35,530
there already user 0 and Q it won't

00:03:33,850 --> 00:03:37,570
break they'll happily interoperate

00:03:35,530 --> 00:03:39,550
without giving you problems then you

00:03:37,570 --> 00:03:42,070
create a socket and a socket is just

00:03:39,550 --> 00:03:44,170
either a receiving or sending part of

00:03:42,070 --> 00:03:46,120
one of these bits of communication and

00:03:44,170 --> 00:03:48,459
you have a type so in this case we're

00:03:46,120 --> 00:03:51,820
saying socket Rep that's a reply socket

00:03:48,459 --> 00:03:53,680
so this is the server we then bind it to

00:03:51,820 --> 00:03:55,090
an address so binding is just like

00:03:53,680 --> 00:03:58,030
listening on the port because we're

00:03:55,090 --> 00:03:59,080
going to bind to a TCP address here and

00:03:58,030 --> 00:04:01,450
when in fact we're just going to bind to

00:03:59,080 --> 00:04:03,520
any TCP addresses on the box so any

00:04:01,450 --> 00:04:05,440
interfaces on there it will listen on

00:04:03,520 --> 00:04:08,440
and it will listen on that pool now

00:04:05,440 --> 00:04:11,080
binding needs to have access to the poor

00:04:08,440 --> 00:04:14,050
so if you start apache on port 80 and

00:04:11,080 --> 00:04:17,109
then try and bind a 0 and Q socket on

00:04:14,050 --> 00:04:19,030
port 80 it will complain once you've got

00:04:17,109 --> 00:04:22,030
it bound though all you have to do is

00:04:19,030 --> 00:04:23,590
call receive and it's going to trigger

00:04:22,030 --> 00:04:25,570
every time there's a message so receive

00:04:23,590 --> 00:04:27,280
will block receiver wait until there's a

00:04:25,570 --> 00:04:29,830
message for it to receive and the

00:04:27,280 --> 00:04:32,290
message just looks like a PHP string and

00:04:29,830 --> 00:04:33,880
reply you just do the opposite you send

00:04:32,290 --> 00:04:37,050
so in this case we're waiting for a

00:04:33,880 --> 00:04:40,200
message and then we're sending out world

00:04:37,050 --> 00:04:43,660
the client just about the same thing

00:04:40,200 --> 00:04:45,700
we're doing a wreck socket rather than a

00:04:43,660 --> 00:04:47,520
rep socket that's a request and we're

00:04:45,700 --> 00:04:51,730
doing a connector Alden a bind because

00:04:47,520 --> 00:04:53,920
we don't we don't control this socket

00:04:51,730 --> 00:04:56,500
type we're just a client of it so we're

00:04:53,920 --> 00:04:58,900
connecting to that socket so if say we

00:04:56,500 --> 00:05:01,570
have you know Apache running on that

00:04:58,900 --> 00:05:03,640
port on them sorry them it will still

00:05:01,570 --> 00:05:05,320
work this connect is not going to do

00:05:03,640 --> 00:05:07,900
anything until it needs to send data and

00:05:05,320 --> 00:05:10,360
the send and receive just look exactly

00:05:07,900 --> 00:05:12,280
the same as the server case it's very

00:05:10,360 --> 00:05:14,500
very simple and you're just again sends

00:05:12,280 --> 00:05:16,960
in a string getting it back but what

00:05:14,500 --> 00:05:20,340
makes this cool is actually how that how

00:05:16,960 --> 00:05:25,990
that works in practice so we should try

00:05:20,340 --> 00:05:28,540
and show you something so here we have a

00:05:25,990 --> 00:05:30,790
request so we're just gonna run the

00:05:28,540 --> 00:05:32,590
request this is exactly the code you saw

00:05:30,790 --> 00:05:33,790
before we're just doing this and this is

00:05:32,590 --> 00:05:35,020
just going to sit there happily because

00:05:33,790 --> 00:05:43,300
at the moment there's nothing there to

00:05:35,020 --> 00:05:44,620
listen to that request window we're

00:05:43,300 --> 00:05:46,390
going to run the reply so this is the

00:05:44,620 --> 00:05:48,490
server again exactly the same this

00:05:46,390 --> 00:05:50,200
immediately replied so zeromq doesn't

00:05:48,490 --> 00:05:52,060
require you to start your stuff in any

00:05:50,200 --> 00:05:55,780
particular order it will happily let you

00:05:52,060 --> 00:05:58,030
work as you need to and it will happily

00:05:55,780 --> 00:05:59,620
serve multiple things so if we down the

00:05:58,030 --> 00:06:00,940
bottom here we've got a slightly

00:05:59,620 --> 00:06:03,370
different version of this request so

00:06:00,940 --> 00:06:05,710
that's just going to let us define our a

00:06:03,370 --> 00:06:07,660
name and it's going to let us define a

00:06:05,710 --> 00:06:10,390
time so effectively all we're going to

00:06:07,660 --> 00:06:12,220
be doing here is sending messages once

00:06:10,390 --> 00:06:13,420
per second so it's just send it it's

00:06:12,220 --> 00:06:17,020
just bringing up a message here saying

00:06:13,420 --> 00:06:20,140
sending second type hello world if we

00:06:17,020 --> 00:06:22,570
send another request through it gets

00:06:20,140 --> 00:06:23,770
handled you don't have to do anything

00:06:22,570 --> 00:06:25,690
else it knows there are multiple

00:06:23,770 --> 00:06:27,280
connections coming in it handles it the

00:06:25,690 --> 00:06:31,210
nice thing about it is the way that it

00:06:27,280 --> 00:06:34,270
handles it if things go a bit faster so

00:06:31,210 --> 00:06:36,010
if we do well something like this so

00:06:34,270 --> 00:06:39,040
this case we're only going to wait five

00:06:36,010 --> 00:06:41,350
hundred microseconds so this one is

00:06:39,040 --> 00:06:43,190
going to send a lot more queries in the

00:06:41,350 --> 00:06:45,590
middle window now our server window you

00:06:43,190 --> 00:06:46,940
not see any of the second thing but if

00:06:45,590 --> 00:06:48,740
you look the time still ticking up

00:06:46,940 --> 00:06:50,480
because 0 and Q is not gonna let one

00:06:48,740 --> 00:06:52,220
flood out the other if there's a message

00:06:50,480 --> 00:06:54,170
waiting from this other connected socket

00:06:52,220 --> 00:06:57,290
it's going to fairly q it so you're

00:06:54,170 --> 00:06:59,510
never going to be able to starve off one

00:06:57,290 --> 00:07:00,920
service one client by having a really

00:06:59,510 --> 00:07:03,110
busy client the sending lots of data

00:07:00,920 --> 00:07:04,370
which is really cool it means that you

00:07:03,110 --> 00:07:06,590
don't have to worry about that kind of

00:07:04,370 --> 00:07:08,510
stuff the library handles it for you and

00:07:06,590 --> 00:07:10,070
we can bring it up and down in any order

00:07:08,510 --> 00:07:15,610
we've got a lot of flexibility in terms

00:07:10,070 --> 00:07:15,610
of how we start and control our services

00:07:16,060 --> 00:07:28,790
yeah absolutely so if the if there is in

00:07:27,500 --> 00:07:30,020
that case we're just checking out a

00:07:28,790 --> 00:07:33,680
message but if we have to do a lot of

00:07:30,020 --> 00:07:35,030
work then the received part of it is

00:07:33,680 --> 00:07:37,480
actually handled in a background thread

00:07:35,030 --> 00:07:39,920
so the receive would be put onto a queue

00:07:37,480 --> 00:07:41,720
so we will just sit there and keep

00:07:39,920 --> 00:07:43,130
messages until we've done it it'll the

00:07:41,720 --> 00:07:44,780
client will happily be able to send

00:07:43,130 --> 00:07:47,720
course the question that you get then is

00:07:44,780 --> 00:07:50,270
what if you just send too much and you

00:07:47,720 --> 00:07:52,700
can control in 0 and Q how much can be

00:07:50,270 --> 00:07:54,770
in the queue at any given point and then

00:07:52,700 --> 00:07:57,080
on the sending side when it cannot send

00:07:54,770 --> 00:07:58,430
anymore it'll just block so you can have

00:07:57,080 --> 00:08:00,680
your clients send as much as they need

00:07:58,430 --> 00:08:03,200
to up until the point where the services

00:08:00,680 --> 00:08:04,880
I can't take anymore and it'll block on

00:08:03,200 --> 00:08:07,610
the server side so you get quite a lot

00:08:04,880 --> 00:08:11,180
control in how you design that edge case

00:08:07,610 --> 00:08:12,680
that failure case so the other thing

00:08:11,180 --> 00:08:13,910
that's nice about 0 and Q is because

00:08:12,680 --> 00:08:16,430
this is a library and it's using

00:08:13,910 --> 00:08:18,440
everything you can write your servers in

00:08:16,430 --> 00:08:20,540
anything this is an example in Python I

00:08:18,440 --> 00:08:25,040
was going to do one in Java but life was

00:08:20,540 --> 00:08:26,600
too short so this is really

00:08:25,040 --> 00:08:28,190
straightforward and you can see it's

00:08:26,600 --> 00:08:29,930
exactly the same thing server receive

00:08:28,190 --> 00:08:31,880
sending a message it's just using a

00:08:29,930 --> 00:08:33,650
Python string and that happily maps

00:08:31,880 --> 00:08:37,000
because zeromq doesn't try and do too

00:08:33,650 --> 00:08:40,159
much to any of the messages it sends so

00:08:37,000 --> 00:08:42,710
Jerome key was actually developed by a

00:08:40,159 --> 00:08:46,339
company called I mattox it's open source

00:08:42,710 --> 00:08:48,230
lgpl and they built it really for

00:08:46,339 --> 00:08:50,810
financial systems so this is used for

00:08:48,230 --> 00:08:52,730
stock markets for people doing

00:08:50,810 --> 00:08:54,440
high-volume trading and stuff like that

00:08:52,730 --> 00:08:56,630
so it's designed to be scaled across

00:08:54,440 --> 00:08:58,690
thousands of cause handling

00:08:56,630 --> 00:09:02,870
millions of messages that was it

00:08:58,690 --> 00:09:04,310
creative function the PHP extension was

00:09:02,870 --> 00:09:09,710
actually developed by this guy who's

00:09:04,310 --> 00:09:12,530
over there and as miko coconut he's he's

00:09:09,710 --> 00:09:13,940
behind the eye magic extension and a

00:09:12,530 --> 00:09:16,280
whole bunch of other extensions that you

00:09:13,940 --> 00:09:18,050
you may have encountered and so it's a

00:09:16,280 --> 00:09:19,940
rock-solid extension what's really

00:09:18,050 --> 00:09:23,210
really nicely niko is also the build

00:09:19,940 --> 00:09:25,130
maintainer now 40 mq which means

00:09:23,210 --> 00:09:27,590
actually we have really great snapshots

00:09:25,130 --> 00:09:29,390
of zeromq available for windows soooo

00:09:27,590 --> 00:09:31,040
look at snapshot store 0 and Q of you

00:09:29,390 --> 00:09:33,890
happen to be working on windows there's

00:09:31,040 --> 00:09:35,990
great builds available there but

00:09:33,890 --> 00:09:37,850
everyone else about the best way to

00:09:35,990 --> 00:09:40,550
install 0 and Q if you want to use it is

00:09:37,850 --> 00:09:42,910
to do the configure make make install

00:09:40,550 --> 00:09:45,350
with the latest version of the website

00:09:42,910 --> 00:09:47,030
it is in package management you can get

00:09:45,350 --> 00:09:50,570
it in another two PPA and get it in a

00:09:47,030 --> 00:09:52,610
fedora repo but it's a little older this

00:09:50,570 --> 00:09:54,830
latest version came out on wednesday and

00:09:52,610 --> 00:09:56,810
is well worth using there's some really

00:09:54,830 --> 00:09:58,820
great improvements in there to install

00:09:56,810 --> 00:10:03,260
the extension you can do that straight

00:09:58,820 --> 00:10:05,570
through pair so if it on can't see V the

00:10:03,260 --> 00:10:08,360
actual commands there they are on the 0

00:10:05,570 --> 00:10:10,040
and Q site zeromq to org and also these

00:10:08,360 --> 00:10:12,440
slides will be up afterwards so it

00:10:10,040 --> 00:10:15,110
should be pretty easy to get so that

00:10:12,440 --> 00:10:18,500
initial communication we did the

00:10:15,110 --> 00:10:20,900
client-server that arm was pretty

00:10:18,500 --> 00:10:22,970
straightforward it's not complex but it

00:10:20,900 --> 00:10:25,460
did hide a lot of the stuff that 0 and

00:10:22,970 --> 00:10:27,560
kudos under and it did also bring up

00:10:25,460 --> 00:10:30,650
this problem of okay so we've got

00:10:27,560 --> 00:10:33,590
messages going to this server but what

00:10:30,650 --> 00:10:36,980
if the server can't handle all the load

00:10:33,590 --> 00:10:38,090
what if it can't do enough processing in

00:10:36,980 --> 00:10:40,190
time what do we need more than one

00:10:38,090 --> 00:10:43,820
server what is the best way to do that

00:10:40,190 --> 00:10:45,560
and that's really the classic message

00:10:43,820 --> 00:10:46,790
queue problem or we'll look at that in a

00:10:45,560 --> 00:10:48,200
little bit but first we have to

00:10:46,790 --> 00:10:52,400
understand what does it mean by

00:10:48,200 --> 00:10:55,190
messaging q so messaging in 0 and Q has

00:10:52,400 --> 00:10:58,400
a pretty specific set of things that go

00:10:55,190 --> 00:11:01,310
with it a message is atomic so when you

00:10:58,400 --> 00:11:03,950
send it you receive it or you don't if

00:11:01,310 --> 00:11:06,080
it's one gigabyte long you receive it or

00:11:03,950 --> 00:11:07,550
you don't you don't have to worry about

00:11:06,080 --> 00:11:08,690
that from our programming point of view

00:11:07,550 --> 00:11:09,329
you get the message where you don't get

00:11:08,690 --> 00:11:12,389
a message

00:11:09,329 --> 00:11:14,220
all the reliability is handled by zeromq

00:11:12,389 --> 00:11:16,230
internally that is not something you

00:11:14,220 --> 00:11:18,739
have to concern yourself with and that

00:11:16,230 --> 00:11:21,629
message is really just a string of bytes

00:11:18,739 --> 00:11:23,309
if you've done any TCP socket

00:11:21,629 --> 00:11:24,959
programming you might be used to a

00:11:23,309 --> 00:11:26,699
stream of bytes so you've really gotta

00:11:24,959 --> 00:11:28,199
work out where it ends where the clients

00:11:26,699 --> 00:11:30,869
not going to send you anymore that is

00:11:28,199 --> 00:11:32,519
never true in serum q 0 mq knows how

00:11:30,869 --> 00:11:34,589
long the message it's sending is and you

00:11:32,519 --> 00:11:35,790
do not get any more than that so you can

00:11:34,589 --> 00:11:39,179
just receive you get your whole message

00:11:35,790 --> 00:11:41,339
and it doesn't do much to those strings

00:11:39,179 --> 00:11:42,809
it will put a very small framing

00:11:41,339 --> 00:11:44,999
protocol around them but if you send a

00:11:42,809 --> 00:11:47,819
10k message what will go on the wire is

00:11:44,999 --> 00:11:49,589
a bit over 10k if you send a 10 meg

00:11:47,819 --> 00:11:51,660
message what will go on the wire is a

00:11:49,589 --> 00:11:54,059
bit over 10 meg so it's very efficient

00:11:51,660 --> 00:11:56,129
it's not going to add a lot of stuff and

00:11:54,059 --> 00:11:58,619
a lot of overhead because it's used for

00:11:56,129 --> 00:12:01,110
these very high volume financial systems

00:11:58,619 --> 00:12:02,429
and finally it's multi-part and that

00:12:01,110 --> 00:12:04,259
doesn't sound like it's necessary so

00:12:02,429 --> 00:12:06,209
much use when you can just send you know

00:12:04,259 --> 00:12:08,009
whatever because people would use JSON

00:12:06,209 --> 00:12:09,899
or Google protocol buffers or whatever

00:12:08,009 --> 00:12:12,299
they want to actually send messages but

00:12:09,899 --> 00:12:14,699
multi-part is useful because 0 and Q

00:12:12,299 --> 00:12:16,139
itself can use the different parts of

00:12:14,699 --> 00:12:18,089
the message which lets you build things

00:12:16,139 --> 00:12:19,829
like envelopes which are very useful for

00:12:18,089 --> 00:12:21,749
routine which is you get into more

00:12:19,829 --> 00:12:23,399
complex systems allow you to send

00:12:21,749 --> 00:12:28,559
messages different ways from within

00:12:23,399 --> 00:12:31,470
zeromq queuing is the other part of it

00:12:28,559 --> 00:12:35,100
and both of these things are keys so we

00:12:31,470 --> 00:12:37,290
have a post office q people are waiting

00:12:35,100 --> 00:12:39,959
in a sneaking you to go and speak to

00:12:37,290 --> 00:12:42,089
someone at a desk and that's a very

00:12:39,959 --> 00:12:43,410
traditional q it looks like a bad things

00:12:42,089 --> 00:12:45,119
there's a lot of people waiting but it's

00:12:43,410 --> 00:12:46,919
a good thing because if everyone went to

00:12:45,119 --> 00:12:48,029
the desks at once the tellers wouldn't

00:12:46,919 --> 00:12:49,350
be able to serve anyone there would just

00:12:48,029 --> 00:12:51,049
be too much going on everyone be

00:12:49,350 --> 00:12:52,980
shouting up so this is actually

00:12:51,049 --> 00:12:54,689
restraining the amount of work that's

00:12:52,980 --> 00:12:56,220
available to them to the amount they can

00:12:54,689 --> 00:12:58,499
handle so only one person who's been

00:12:56,220 --> 00:12:59,669
dealt with at a time so this works but

00:12:58,499 --> 00:13:01,049
it means everyone's having to wait

00:12:59,669 --> 00:13:03,569
they're having to sit there because they

00:13:01,049 --> 00:13:05,100
need a reply the post box is a queue as

00:13:03,569 --> 00:13:07,019
well and maybe the post box is a better

00:13:05,100 --> 00:13:08,369
cue because with the postbox you just go

00:13:07,019 --> 00:13:10,259
ahead and drop your letter off and it's

00:13:08,369 --> 00:13:13,079
done you don't have to wait for a reply

00:13:10,259 --> 00:13:16,589
you just drop it and you leave and the

00:13:13,079 --> 00:13:19,169
post box is only finite it can fill up

00:13:16,589 --> 00:13:20,999
I'm sure you've seen around Christmas

00:13:19,169 --> 00:13:22,199
sometimes post boxes do fill up and you

00:13:20,999 --> 00:13:23,040
just simply can't put any more letters

00:13:22,199 --> 00:13:24,240
into them

00:13:23,040 --> 00:13:25,980
that can be solved by having someone

00:13:24,240 --> 00:13:27,690
visit the post box and empty it more

00:13:25,980 --> 00:13:29,040
regularly but the post box is providing

00:13:27,690 --> 00:13:32,339
a buffer and that's another kind of cue

00:13:29,040 --> 00:13:34,320
and in zeromq we have q's kind of

00:13:32,339 --> 00:13:36,329
built-in so whenever the client is

00:13:34,320 --> 00:13:38,790
sending a confused stuff so you can send

00:13:36,329 --> 00:13:41,040
right away it can just queue on its

00:13:38,790 --> 00:13:43,110
internal queue and on the receiver we

00:13:41,040 --> 00:13:45,209
will also have a queue but sometimes we

00:13:43,110 --> 00:13:47,509
want something in the middle or extra

00:13:45,209 --> 00:13:50,250
cues to allow us more flexibility

00:13:47,509 --> 00:13:52,589
because Q is really other basis of being

00:13:50,250 --> 00:13:56,569
able to do things asynchronously if

00:13:52,589 --> 00:13:59,190
you've ever in much JavaScript then

00:13:56,569 --> 00:14:01,560
you'll know that when you do a call back

00:13:59,190 --> 00:14:02,910
you do an ajax function you just do it

00:14:01,560 --> 00:14:05,399
it just goes it happens immediately

00:14:02,910 --> 00:14:07,949
that's what asynchronous means it's it

00:14:05,399 --> 00:14:09,569
you're not waiting on what that resource

00:14:07,949 --> 00:14:11,339
is doing but there's still limited

00:14:09,569 --> 00:14:13,410
resource in this I just had a little

00:14:11,339 --> 00:14:14,970
JavaScript that was just going away into

00:14:13,410 --> 00:14:16,670
an Asia it's called to a PHP script that

00:14:14,970 --> 00:14:19,800
just slept for 10 seconds didn't do much

00:14:16,670 --> 00:14:21,060
but i would do 20 of them so much from

00:14:19,800 --> 00:14:22,769
my point of view from the programming

00:14:21,060 --> 00:14:25,380
point of view i can just go call call

00:14:22,769 --> 00:14:28,889
call call call call call it's fine but

00:14:25,380 --> 00:14:30,690
underneath firefox will only send six at

00:14:28,889 --> 00:14:32,730
once to a given domain it has a limited

00:14:30,690 --> 00:14:34,620
resource it can use so it has to hold

00:14:32,730 --> 00:14:36,839
the others in a queue until it's ready

00:14:34,620 --> 00:14:39,300
to process them this means that we get

00:14:36,839 --> 00:14:40,380
nice flexible behavior even though the

00:14:39,300 --> 00:14:41,819
engine underneath is doing something

00:14:40,380 --> 00:14:43,260
more complex and that's exactly the kind

00:14:41,819 --> 00:14:47,730
of thing we want to be building into our

00:14:43,260 --> 00:14:51,180
applications with 0 and Q so 0 and Q

00:14:47,730 --> 00:14:53,670
architectures are about building lots of

00:14:51,180 --> 00:14:56,100
smart edges things at the end that do

00:14:53,670 --> 00:14:58,589
stuff clients and servers and things

00:14:56,100 --> 00:15:01,139
that no stuff and in the middle having a

00:14:58,589 --> 00:15:03,209
lot of dumb things a lot of dumb ques a

00:15:01,139 --> 00:15:05,910
lot of dumb Reuters stuff that can send

00:15:03,209 --> 00:15:08,730
messages and hold message ISM not really

00:15:05,910 --> 00:15:12,510
process messages much like the Internet

00:15:08,730 --> 00:15:14,339
the idea is that you can take a sending

00:15:12,510 --> 00:15:15,899
part on a receiving part and you can

00:15:14,339 --> 00:15:17,850
drop stuff in between it so here we r

00:15:15,899 --> 00:15:19,399
drop in a queue in between it and most

00:15:17,850 --> 00:15:21,540
of the time when you look at traditional

00:15:19,399 --> 00:15:22,920
messaging middleware message queues

00:15:21,540 --> 00:15:25,199
they'll look like this bottom option

00:15:22,920 --> 00:15:26,579
there'll be a queue in the middle and

00:15:25,199 --> 00:15:28,410
the queue will have soft scent to it and

00:15:26,579 --> 00:15:30,420
it will go out but that means that

00:15:28,410 --> 00:15:31,589
you've kind of got this big hefty device

00:15:30,420 --> 00:15:34,050
in the middle of your network which is

00:15:31,589 --> 00:15:35,610
not always what you want with zeromq

00:15:34,050 --> 00:15:36,810
because it's so easy and cheap to build

00:15:35,610 --> 00:15:39,029
a queue you often

00:15:36,810 --> 00:15:41,279
put the cue well let's say you have one

00:15:39,029 --> 00:15:42,690
machine that has a local q everything is

00:15:41,279 --> 00:15:45,150
pushing to that and then it's talking to

00:15:42,690 --> 00:15:46,650
a server or you have a server with a

00:15:45,150 --> 00:15:48,210
bunch of workers on it and they have a

00:15:46,650 --> 00:15:50,490
local q and everything's pushing to that

00:15:48,210 --> 00:15:52,410
all you have both it's very very cheap

00:15:50,490 --> 00:15:54,089
and easy to build them so you don't have

00:15:52,410 --> 00:15:56,130
to worry about chucking extra ones in

00:15:54,089 --> 00:15:58,200
and the ques itself is very

00:15:56,130 --> 00:16:01,080
straightforward so this is the sort of

00:15:58,200 --> 00:16:02,370
canonical message queue example it's a

00:16:01,080 --> 00:16:06,360
little bit more complicated in the other

00:16:02,370 --> 00:16:07,890
one but not not by much we're connecting

00:16:06,360 --> 00:16:09,240
two sockets so we're connecting a front

00:16:07,890 --> 00:16:10,740
end where we're going to receive from

00:16:09,240 --> 00:16:12,300
the client and we're connecting the back

00:16:10,740 --> 00:16:14,730
end where we're going to send out to all

00:16:12,300 --> 00:16:18,150
the workers and just like before we're

00:16:14,730 --> 00:16:22,110
binding on some tcp ports we're using a

00:16:18,150 --> 00:16:24,720
slightly different socket type rather

00:16:22,110 --> 00:16:27,720
than using wreck Rep we're using ex-rep

00:16:24,720 --> 00:16:28,710
and X rack and these do these work in

00:16:27,720 --> 00:16:30,600
the same way they'll let you talk to

00:16:28,710 --> 00:16:33,839
reply and request sockets but they're a

00:16:30,600 --> 00:16:35,700
bit more intelligent so X rep is a kind

00:16:33,839 --> 00:16:37,140
of Rooter when you get some message it

00:16:35,700 --> 00:16:38,910
will put it in an envelope using the

00:16:37,140 --> 00:16:41,880
multi-part thing so that it knows where

00:16:38,910 --> 00:16:43,980
to send the reply back to and Rec x rach

00:16:41,880 --> 00:16:46,140
is a dealer so it will automatically

00:16:43,980 --> 00:16:48,390
distribute between all connected peers

00:16:46,140 --> 00:16:50,250
which means that you can do exactly what

00:16:48,390 --> 00:16:52,530
you want to do have any number of

00:16:50,250 --> 00:16:54,890
clients any number of servers and they

00:16:52,530 --> 00:16:57,600
can all just plug into this this point

00:16:54,890 --> 00:16:59,250
we're going to use a pole in order to

00:16:57,600 --> 00:17:00,540
let us listen for anything that's

00:16:59,250 --> 00:17:02,520
happening because before we were just

00:17:00,540 --> 00:17:04,110
doing receive so receive is fine but

00:17:02,520 --> 00:17:05,910
receive is going to block so let's say

00:17:04,110 --> 00:17:07,860
we're receiving on the front end nothing

00:17:05,910 --> 00:17:09,060
happens but we can have replies coming

00:17:07,860 --> 00:17:11,010
back on the back end we wouldn't know

00:17:09,060 --> 00:17:12,480
about them so pole lets us basically

00:17:11,010 --> 00:17:14,730
listen on both of those sockets at the

00:17:12,480 --> 00:17:16,079
same time and then finally we've got a

00:17:14,730 --> 00:17:17,429
couple of flags because we have to

00:17:16,079 --> 00:17:19,770
detect whether these messages and

00:17:17,429 --> 00:17:21,780
multi-part 0 and Q does that by just

00:17:19,770 --> 00:17:24,360
having a couple of flags you can check

00:17:21,780 --> 00:17:29,040
they just say mode send more and so

00:17:24,360 --> 00:17:30,900
Copts receive more the actual code it's

00:17:29,040 --> 00:17:33,090
it looks a bit long but actually this

00:17:30,900 --> 00:17:36,480
whole block is exactly the same as this

00:17:33,090 --> 00:17:38,190
whole block you can you can about half

00:17:36,480 --> 00:17:40,230
the link for this code but it's just to

00:17:38,190 --> 00:17:42,690
make it a bit clearer at the top we're

00:17:40,230 --> 00:17:44,850
looking for any event so we're just

00:17:42,690 --> 00:17:46,290
going on our poll and we're saying if I

00:17:44,850 --> 00:17:49,110
hear an event on the front end or the

00:17:46,290 --> 00:17:50,550
back end let me know when we get it we

00:17:49,110 --> 00:17:51,990
say if it's a front end

00:17:50,550 --> 00:17:53,400
we receive all the parts of it so we

00:17:51,990 --> 00:17:56,010
have a little do-while loop we're just

00:17:53,400 --> 00:17:57,480
picking out each part and then we're

00:17:56,010 --> 00:17:58,680
just going to send those out to the back

00:17:57,480 --> 00:18:00,570
end so all we going to do is shuffle

00:17:58,680 --> 00:18:02,760
messages from the front to the back and

00:18:00,570 --> 00:18:04,320
then the other bit we're just shuffling

00:18:02,760 --> 00:18:05,880
messages from the back to the front all

00:18:04,320 --> 00:18:07,920
the clever stuff of routing it back to

00:18:05,880 --> 00:18:09,420
the right place is handled by x-ray all

00:18:07,920 --> 00:18:11,760
the clever stuff of pushing it out and

00:18:09,420 --> 00:18:14,280
load balancing amongst available workers

00:18:11,760 --> 00:18:18,200
is handled by X rack so that's very very

00:18:14,280 --> 00:18:21,840
simple for us now the pole is kind of a

00:18:18,200 --> 00:18:23,790
cool part of this and pole is polling is

00:18:21,840 --> 00:18:26,100
a lot more interesting than just being

00:18:23,790 --> 00:18:27,630
able to listen on zeromq sockets when

00:18:26,100 --> 00:18:29,760
you pull something you can pull anything

00:18:27,630 --> 00:18:33,570
that in UNIX has a file descriptor which

00:18:29,760 --> 00:18:36,060
is anything really so we can have a pole

00:18:33,570 --> 00:18:38,010
that's listening on zeromq takut there's

00:18:36,060 --> 00:18:40,140
listening on a network socket so we're

00:18:38,010 --> 00:18:41,940
waiting for some tcp data or we can

00:18:40,140 --> 00:18:45,360
listen on standard in we can listen on

00:18:41,940 --> 00:18:47,970
almost anything so this is a little

00:18:45,360 --> 00:18:50,820
example where we're going to do a new

00:18:47,970 --> 00:18:52,710
socket so we're just listening / 0 mq a

00:18:50,820 --> 00:18:55,530
full type of pull socket will look at

00:18:52,710 --> 00:18:57,060
that a little bit and we have a standard

00:18:55,530 --> 00:18:58,890
in so we're just going to do an F open

00:18:57,060 --> 00:19:00,950
on standard in as you would any time you

00:18:58,890 --> 00:19:03,330
just want it to receive console input

00:19:00,950 --> 00:19:04,800
the pole is then going to add both of

00:19:03,330 --> 00:19:07,110
those so even though only one of those

00:19:04,800 --> 00:19:08,670
is 0 and Q socket we add them to the 0

00:19:07,110 --> 00:19:10,230
and Q polling function with no problem

00:19:08,670 --> 00:19:18,660
and then finally we're just going to

00:19:10,230 --> 00:19:22,500
echo out which one it is so hopefully if

00:19:18,660 --> 00:19:24,600
we run the pole then type something it

00:19:22,500 --> 00:19:26,250
picks up from standard in so pretty

00:19:24,600 --> 00:19:28,260
straightforward we're just going through

00:19:26,250 --> 00:19:30,990
and looking at stand to do then we have

00:19:28,260 --> 00:19:33,360
another little script over here and all

00:19:30,990 --> 00:19:35,070
this is doing is pushing to that 0 and Q

00:19:33,360 --> 00:19:36,990
socket that we saw before all this code

00:19:35,070 --> 00:19:39,090
incidentally is up on github there's a

00:19:36,990 --> 00:19:41,340
link at the end so you can take a look

00:19:39,090 --> 00:19:44,370
so we can just do high and it comes

00:19:41,340 --> 00:19:45,840
across zeromq so this one pole loop can

00:19:44,370 --> 00:19:47,280
easily look for events happening

00:19:45,840 --> 00:19:48,780
anywhere else so if you had a file that

00:19:47,280 --> 00:19:51,090
was being updated you can look for

00:19:48,780 --> 00:19:52,530
events on that file if you had another

00:19:51,090 --> 00:19:54,000
sort of stream that you needed to see

00:19:52,530 --> 00:19:58,670
whether anything was happening you could

00:19:54,000 --> 00:19:58,670
easily do that through zeromq as well

00:20:03,600 --> 00:20:08,830
so the other thing that the key brings

00:20:06,610 --> 00:20:13,780
up is I'm sure some people have already

00:20:08,830 --> 00:20:15,580
thought of that that Q is fixed it's a

00:20:13,780 --> 00:20:16,900
stable point in the architecture

00:20:15,580 --> 00:20:19,450
whenever you're looking at building a

00:20:16,900 --> 00:20:20,980
large distributed architecture you have

00:20:19,450 --> 00:20:23,320
to think about what's stable and what's

00:20:20,980 --> 00:20:25,660
unstable now stable sounds like the good

00:20:23,320 --> 00:20:27,730
thing but stable is equivalent to

00:20:25,660 --> 00:20:29,980
limited or fixed or single point of

00:20:27,730 --> 00:20:32,320
failure unstable sounds like a bad thing

00:20:29,980 --> 00:20:35,049
but that's dynamic or elastic it's a

00:20:32,320 --> 00:20:37,120
good thing so in general you want as

00:20:35,049 --> 00:20:39,970
much of your architecture as possible to

00:20:37,120 --> 00:20:41,830
be dynamic and in RQ example all our

00:20:39,970 --> 00:20:44,740
clients dynamic they can come and go as

00:20:41,830 --> 00:20:47,110
they please all of our workers they're

00:20:44,740 --> 00:20:48,850
also dynamic if the server goes away we

00:20:47,110 --> 00:20:50,290
don't care if it comes back it's two

00:20:48,850 --> 00:20:52,690
more come back at five more come back

00:20:50,290 --> 00:20:54,130
we're happy but we have the Q is this

00:20:52,690 --> 00:20:56,650
sort of fixed point in the middle of it

00:20:54,130 --> 00:20:58,390
what zeromq allows you to do to get

00:20:56,650 --> 00:21:00,940
around that is you can actually bind and

00:20:58,390 --> 00:21:03,820
connect to multiple sockets so from our

00:21:00,940 --> 00:21:05,830
client we can connect to our queue but

00:21:03,820 --> 00:21:07,450
we can connect to two queues and then

00:21:05,830 --> 00:21:09,520
we'll just bounce messages across both

00:21:07,450 --> 00:21:11,440
of them so we can build in redundancy if

00:21:09,520 --> 00:21:12,790
we need to but it's also always worth

00:21:11,440 --> 00:21:14,620
considering when looking at one of these

00:21:12,790 --> 00:21:16,299
architectures which bits stable which

00:21:14,620 --> 00:21:17,830
bits fixed and which of its dynamic

00:21:16,299 --> 00:21:22,480
which bits are are we going to be able

00:21:17,830 --> 00:21:24,190
to scale elastically so the little

00:21:22,480 --> 00:21:26,169
polling request their use the pull

00:21:24,190 --> 00:21:28,299
socket and the pull socket is part of a

00:21:26,169 --> 00:21:31,240
pattern called pipelining and you can

00:21:28,299 --> 00:21:33,360
see us one way communication so this is

00:21:31,240 --> 00:21:36,280
very common for work distribution

00:21:33,360 --> 00:21:37,809
anytime you're pushing work out to be

00:21:36,280 --> 00:21:39,700
done by a bunch of workers you're in

00:21:37,809 --> 00:21:41,980
fact sending one way messages from a

00:21:39,700 --> 00:21:43,570
server out to a lot of workers out to a

00:21:41,980 --> 00:21:45,280
lot of clients you don't want to reply

00:21:43,570 --> 00:21:47,830
you're just sending it out something

00:21:45,280 --> 00:21:49,059
like a MapReduce framework really is

00:21:47,830 --> 00:21:50,980
doing that you're firing off a lot of

00:21:49,059 --> 00:21:53,400
mappers and then they're going all into

00:21:50,980 --> 00:21:56,919
a reducer they're sending data one way

00:21:53,400 --> 00:21:59,770
and that's something that we can do with

00:21:56,919 --> 00:22:03,549
the pull and push socket types in 0 and

00:21:59,770 --> 00:22:05,440
Q so let's say that we wanted to do

00:22:03,549 --> 00:22:06,549
something like it could be sending a

00:22:05,440 --> 00:22:08,770
bunch of emails because we know the

00:22:06,549 --> 00:22:10,690
email sending is kind of slow so we

00:22:08,770 --> 00:22:12,580
don't want our 1 PHP process to be doing

00:22:10,690 --> 00:22:13,900
it we want lots of PHP processes but do

00:22:12,580 --> 00:22:14,210
we have that we have to send work out of

00:22:13,900 --> 00:22:17,000
them

00:22:14,210 --> 00:22:18,820
in this we've got a bit of a simple it's

00:22:17,000 --> 00:22:21,080
just going to count up a string length

00:22:18,820 --> 00:22:22,940
but what we're going to do is spawn off

00:22:21,080 --> 00:22:25,850
a bunch of workers so we're going to do

00:22:22,940 --> 00:22:28,910
is just fork and run a PHP work so this

00:22:25,850 --> 00:22:31,040
script will start our ten instances of

00:22:28,910 --> 00:22:32,720
the workshop PHP script and then we're

00:22:31,040 --> 00:22:34,070
going to set up some sockets we're going

00:22:32,720 --> 00:22:35,510
to set up a worker socket which is a

00:22:34,070 --> 00:22:37,220
push type so we're going to be sending

00:22:35,510 --> 00:22:39,350
out and we're going to send up a control

00:22:37,220 --> 00:22:40,700
socket which is another push type so

00:22:39,350 --> 00:22:42,710
we're going to be this is sort of our

00:22:40,700 --> 00:22:46,220
sending messages out to whoever's

00:22:42,710 --> 00:22:48,350
listening and we are going to bind both

00:22:46,220 --> 00:22:50,390
of those but rather than binding them to

00:22:48,350 --> 00:22:54,020
a network port as we were before we're

00:22:50,390 --> 00:22:57,080
binding them to an IPC named pipe so

00:22:54,020 --> 00:23:00,650
this allows us to do very fast basically

00:22:57,080 --> 00:23:03,470
across memory communication on almost

00:23:00,650 --> 00:23:05,900
any unix system there is a Windows named

00:23:03,470 --> 00:23:09,830
pipe support in 0 and Q coming probably

00:23:05,900 --> 00:23:11,330
in the summer this needs to have a file

00:23:09,830 --> 00:23:12,590
location that the name pipe will go

00:23:11,330 --> 00:23:13,970
through so we're just put in a couple

00:23:12,590 --> 00:23:15,620
intent but this means that this all is

00:23:13,970 --> 00:23:16,700
all going to work on one machine so

00:23:15,620 --> 00:23:18,680
rather than working across the network

00:23:16,700 --> 00:23:21,320
as we were before we're now distributing

00:23:18,680 --> 00:23:22,340
work just within one machine because we

00:23:21,320 --> 00:23:23,420
know that we just need multiple

00:23:22,340 --> 00:23:25,730
processes because they're going to be

00:23:23,420 --> 00:23:27,860
waiting not because we need to fan out

00:23:25,730 --> 00:23:28,850
to lots of different machines but if we

00:23:27,860 --> 00:23:30,290
did need to fan out to different

00:23:28,850 --> 00:23:32,210
machines this would be easy to replace

00:23:30,290 --> 00:23:34,220
with TCP all you have to change for

00:23:32,210 --> 00:23:35,540
those two bine lines so then we're going

00:23:34,220 --> 00:23:37,610
to do actual work and all that's going

00:23:35,540 --> 00:23:40,070
to do is read in all the lines of a file

00:23:37,610 --> 00:23:42,530
and just send them through that socket

00:23:40,070 --> 00:23:44,600
and that socket will fairly distribute

00:23:42,530 --> 00:23:45,680
to all connected workers so we know that

00:23:44,600 --> 00:23:48,530
each of them are going to do about the

00:23:45,680 --> 00:23:51,320
same amount of work the work is pretty

00:23:48,530 --> 00:23:53,540
straightforward as well all we have to

00:23:51,320 --> 00:23:55,010
do here is connect pulls to the pushes

00:23:53,540 --> 00:23:56,960
we connected before so we have a pool

00:23:55,010 --> 00:23:59,050
for our work socket we have a pool for a

00:23:56,960 --> 00:24:02,690
control socket and we also have a push

00:23:59,050 --> 00:24:05,180
out to our results so we sort of fanning

00:24:02,690 --> 00:24:06,740
out from one point to many workers but

00:24:05,180 --> 00:24:09,110
then we want the results to fan back in

00:24:06,740 --> 00:24:11,570
to one resolve collector which we're

00:24:09,110 --> 00:24:13,490
going to call sink and all of these are

00:24:11,570 --> 00:24:14,930
connects so because they're connects

00:24:13,490 --> 00:24:16,550
this is not a stable part of the

00:24:14,930 --> 00:24:18,320
architecture this is unstable this is

00:24:16,550 --> 00:24:19,820
dynamic so if you want 20 workers no

00:24:18,320 --> 00:24:22,190
problem they all connect into things

00:24:19,820 --> 00:24:23,660
they're not bind into any of them we're

00:24:22,190 --> 00:24:25,100
going to use a pole again but in this

00:24:23,660 --> 00:24:26,360
case we're not polling both those

00:24:25,100 --> 00:24:27,940
sockets we're going to use the pole so

00:24:26,360 --> 00:24:30,139
we can have a timeout

00:24:27,940 --> 00:24:31,940
and actually doing the work is very very

00:24:30,139 --> 00:24:33,860
straightforward we're just going to do a

00:24:31,940 --> 00:24:35,509
poll if we get a message we're going to

00:24:33,860 --> 00:24:36,679
receive and the main reason I having the

00:24:35,509 --> 00:24:38,899
pole is that we can have a little time

00:24:36,679 --> 00:24:41,419
out there and if there's no messages for

00:24:38,899 --> 00:24:42,980
a while the poll will time out and we'll

00:24:41,419 --> 00:24:44,720
go and see if there's any control

00:24:42,980 --> 00:24:46,429
messages for us on the control socket

00:24:44,720 --> 00:24:48,740
and we're doing that just so that we

00:24:46,429 --> 00:24:51,860
prioritize the work socket ahead of the

00:24:48,740 --> 00:24:52,789
control socket if the control socket we

00:24:51,860 --> 00:24:54,169
don't want to be sitting there waiting

00:24:52,789 --> 00:24:55,940
for a message because we're using

00:24:54,169 --> 00:24:57,769
receive so we're just going to pass it a

00:24:55,940 --> 00:25:00,110
flag that says don't block if there's a

00:24:57,769 --> 00:25:01,700
message waiting for you boo give me it

00:25:00,110 --> 00:25:03,230
but if there's no message waiting for

00:25:01,700 --> 00:25:05,779
you just exit and what it will actually

00:25:03,230 --> 00:25:09,200
do is is chuck in a succession so we'll

00:25:05,779 --> 00:25:10,999
capture and then finally we got the sink

00:25:09,200 --> 00:25:12,320
so all we were doing in this thing is

00:25:10,999 --> 00:25:13,580
just calculating the string length of

00:25:12,320 --> 00:25:16,249
the message was passed in so it's

00:25:13,580 --> 00:25:18,649
trivial bit of work and here we're just

00:25:16,249 --> 00:25:21,919
going to connect two sockets the result

00:25:18,649 --> 00:25:23,240
socket and the control socket and we're

00:25:21,919 --> 00:25:25,519
just going to do pretty much the same

00:25:23,240 --> 00:25:27,409
code as the worker pull everything in

00:25:25,519 --> 00:25:29,299
and when we get to the when we get a

00:25:27,409 --> 00:25:32,269
control message saying and you're done

00:25:29,299 --> 00:25:33,649
it'll just output the total length it's

00:25:32,269 --> 00:25:36,769
not that interesting to see that one run

00:25:33,649 --> 00:25:38,720
so it's just a little bit of output all

00:25:36,769 --> 00:25:41,119
it will do is start the workers send the

00:25:38,720 --> 00:25:43,009
messages in and out and collect them now

00:25:41,119 --> 00:25:45,230
this is a pretty trivial example and you

00:25:43,009 --> 00:25:47,570
could use something like this maybe for

00:25:45,230 --> 00:25:49,309
doing some light sending emails but real

00:25:47,570 --> 00:25:51,049
pipeline systems tend to get a lot more

00:25:49,309 --> 00:25:52,940
complex and have a lot more socket

00:25:51,049 --> 00:25:55,460
because what pipeline gives you is the

00:25:52,940 --> 00:25:57,919
ability to fan out and in at any point

00:25:55,460 --> 00:26:01,399
that makes sense for you so let's say

00:25:57,919 --> 00:26:04,220
that you have a some sort of image

00:26:01,399 --> 00:26:06,710
processing pipeline all the different

00:26:04,220 --> 00:26:08,570
parts of it are going to need have

00:26:06,710 --> 00:26:10,249
different requirements so you might

00:26:08,570 --> 00:26:11,509
start with images are uploaded so images

00:26:10,249 --> 00:26:14,119
go into a certain point and they're

00:26:11,509 --> 00:26:16,879
uploaded for processing but you then

00:26:14,119 --> 00:26:18,169
need to scale out so that you rien code

00:26:16,879 --> 00:26:20,299
them maybe from one format to another

00:26:18,169 --> 00:26:21,769
that's taking a bit longer you need more

00:26:20,299 --> 00:26:25,220
machine so maybe you scale out across

00:26:21,769 --> 00:26:26,779
TCP then you need to fan those back in

00:26:25,220 --> 00:26:28,129
because you're doing some quantizing

00:26:26,779 --> 00:26:30,740
which is actually just happening on one

00:26:28,129 --> 00:26:32,600
machine it's a lot cheaper and that's

00:26:30,740 --> 00:26:34,789
maybe two processes on a single machine

00:26:32,600 --> 00:26:36,169
you might have a validation point and

00:26:34,789 --> 00:26:38,929
you insist everything going through this

00:26:36,169 --> 00:26:40,679
one process for validation and then you

00:26:38,929 --> 00:26:41,999
fan out go to some water market

00:26:40,679 --> 00:26:43,769
this is the kind of thing that you can

00:26:41,999 --> 00:26:45,360
do putting together a lot of different

00:26:43,769 --> 00:26:47,730
steps add a lot of different scale

00:26:45,360 --> 00:26:49,110
requirements very easily because at any

00:26:47,730 --> 00:26:50,669
given point you'll just connect into the

00:26:49,110 --> 00:26:52,950
socket and sending a message across it

00:26:50,669 --> 00:26:54,360
and the message can even be the image we

00:26:52,950 --> 00:26:57,570
don't have to go out to another file

00:26:54,360 --> 00:26:59,749
system if we don't want to but there was

00:26:57,570 --> 00:27:04,379
a bit of a hack in that last example

00:26:59,749 --> 00:27:06,059
where we had when we ended the socket we

00:27:04,379 --> 00:27:08,159
would send an end message and we would

00:27:06,059 --> 00:27:10,590
have to send it 11 times once for each

00:27:08,159 --> 00:27:13,590
worker and then once for the sink that's

00:27:10,590 --> 00:27:16,259
not very good because now our sending

00:27:13,590 --> 00:27:18,179
system has to know how many other

00:27:16,259 --> 00:27:21,269
scripts is got connected that's very

00:27:18,179 --> 00:27:23,460
fragile we don't want that and it has to

00:27:21,269 --> 00:27:25,980
do that because when we send say from

00:27:23,460 --> 00:27:28,259
our validator out to here if we send one

00:27:25,980 --> 00:27:29,639
message it will go out to one the next

00:27:28,259 --> 00:27:31,440
message to the next one next missions

00:27:29,639 --> 00:27:34,230
next one so on it's only going to send

00:27:31,440 --> 00:27:36,029
to onenote of time and what we want is

00:27:34,230 --> 00:27:38,070
to be able to send the same message to

00:27:36,029 --> 00:27:40,619
any number of nodes of the time and

00:27:38,070 --> 00:27:42,629
that's what the pub sub published

00:27:40,619 --> 00:27:45,240
subscribe pattern is full it's kind of

00:27:42,629 --> 00:27:47,850
like it's a broadcast message a much

00:27:45,240 --> 00:27:49,889
like a radio broadcast pub/sub you can

00:27:47,850 --> 00:27:52,379
just send stuff out to it if no one's

00:27:49,889 --> 00:27:53,730
listening the messages just disappear so

00:27:52,379 --> 00:27:55,799
it's not going to wait for someone to

00:27:53,730 --> 00:27:57,869
connect to it so send some messages

00:27:55,799 --> 00:27:59,309
it'll just let you send them if anyone's

00:27:57,869 --> 00:28:02,639
listening they get them if they're not

00:27:59,309 --> 00:28:05,070
they don't so the kind of example that

00:28:02,639 --> 00:28:07,200
makes sense is something like a a web

00:28:05,070 --> 00:28:08,850
chat in a web chat you've got messages

00:28:07,200 --> 00:28:10,289
going into a point and then they need to

00:28:08,850 --> 00:28:13,950
be distributed out to all connected

00:28:10,289 --> 00:28:16,889
clients so an on top a little one just

00:28:13,950 --> 00:28:21,090
using a forever I frame but obviously if

00:28:16,889 --> 00:28:23,669
you're if you were in the html5 and css3

00:28:21,090 --> 00:28:25,860
thing you probably using web sockets or

00:28:23,669 --> 00:28:27,749
j/s sockets or whatever you want I mean

00:28:25,860 --> 00:28:28,879
what you communicate to the client with

00:28:27,749 --> 00:28:31,289
doesn't make a great deal of difference

00:28:28,879 --> 00:28:32,789
because the architecture is is roughly

00:28:31,289 --> 00:28:34,230
the same either way you're going to be

00:28:32,789 --> 00:28:35,879
sending a message from one of your

00:28:34,230 --> 00:28:37,799
clients so down here we've got perhaps

00:28:35,879 --> 00:28:39,600
or web clients they're going to send a

00:28:37,799 --> 00:28:41,850
message to a server that's going to fire

00:28:39,600 --> 00:28:43,529
it off to this distribution point that's

00:28:41,850 --> 00:28:44,940
going to distribute it to all of its

00:28:43,529 --> 00:28:47,580
subscribers and they're going to push it

00:28:44,940 --> 00:28:50,909
over to their connected web clients so

00:28:47,580 --> 00:28:53,399
the server is really easy so all we're

00:28:50,909 --> 00:28:54,600
going to do is have a pull socket so

00:28:53,399 --> 00:28:56,039
like the pipeline example

00:28:54,600 --> 00:28:58,169
for we're just going to collect work in

00:28:56,039 --> 00:29:03,660
and then we're going to publish it out a

00:28:58,169 --> 00:29:05,520
pub socket simple the sender this is a

00:29:03,660 --> 00:29:06,720
one-time script so this one has got a

00:29:05,520 --> 00:29:08,220
while true in though it's just going to

00:29:06,720 --> 00:29:09,720
loop it's going to wait for new messages

00:29:08,220 --> 00:29:12,900
to come in it's going to send them out

00:29:09,720 --> 00:29:15,059
the pub the sender is a one time it's

00:29:12,900 --> 00:29:17,340
going to create a socket connect it to a

00:29:15,059 --> 00:29:18,539
port and fire the message across it and

00:29:17,340 --> 00:29:19,890
we can do whatever we want in here I

00:29:18,539 --> 00:29:21,419
mean it's doing a little thing to say

00:29:19,890 --> 00:29:23,580
someone has joined it doesn't matter you

00:29:21,419 --> 00:29:25,830
can process it however it once it just

00:29:23,580 --> 00:29:28,380
needs to correct connect a push socket

00:29:25,830 --> 00:29:30,210
to the port it knows about and then

00:29:28,380 --> 00:29:32,010
finally you have the chat script so the

00:29:30,210 --> 00:29:34,500
chat script would be what was loaded in

00:29:32,010 --> 00:29:36,090
the forever I frame so I'm for anyone

00:29:34,500 --> 00:29:37,799
that hasn't seen that that's just the

00:29:36,090 --> 00:29:39,870
idea of having a hidden i frame with a

00:29:37,799 --> 00:29:41,340
script that never ends so you can spam

00:29:39,870 --> 00:29:46,440
JavaScript at it and it'll the browser

00:29:41,340 --> 00:29:48,210
will update instantly so this is at the

00:29:46,440 --> 00:29:50,400
actual subscriber part so we've got a

00:29:48,210 --> 00:29:51,690
sub socket type and then we actually

00:29:50,400 --> 00:29:53,970
have to say what we're subscribing to

00:29:51,690 --> 00:29:55,559
because zeromq lets you do some message

00:29:53,970 --> 00:29:56,789
matching when you're subscribing and it

00:29:55,559 --> 00:29:59,809
effectively is going to match on the

00:29:56,789 --> 00:30:02,190
start of the message this lets you do

00:29:59,809 --> 00:30:03,330
some really cool things if you know all

00:30:02,190 --> 00:30:05,850
your messages are prefixed with

00:30:03,330 --> 00:30:07,740
something you can have separate channels

00:30:05,850 --> 00:30:09,750
and readers for it in our chat example

00:30:07,740 --> 00:30:12,059
maybe you would have the actual name of

00:30:09,750 --> 00:30:13,350
the channel as the first message and

00:30:12,059 --> 00:30:17,039
then you could subscribe just the

00:30:13,350 --> 00:30:19,169
channels you're on in this case we're

00:30:17,039 --> 00:30:20,490
passing blank that means subscribe to

00:30:19,169 --> 00:30:23,700
every channel so we're going to use a

00:30:20,490 --> 00:30:25,950
poll because we want to time out

00:30:23,700 --> 00:30:28,110
occasionally just so that we can flush

00:30:25,950 --> 00:30:29,370
some output to the browser so the PHP

00:30:28,110 --> 00:30:32,159
knows whether it's still there or not

00:30:29,370 --> 00:30:34,559
but that's about it this is pretty much

00:30:32,159 --> 00:30:40,169
all the code all that's left is a bit of

00:30:34,559 --> 00:30:42,179
JavaScript so again hopefully we have to

00:30:40,169 --> 00:30:45,900
start the server so the server becomes

00:30:42,179 --> 00:30:48,330
our stable part of our architecture then

00:30:45,900 --> 00:30:54,049
we have to in our web client it just

00:30:48,330 --> 00:30:57,330
wants a name hopefully this one in join

00:30:54,049 --> 00:31:00,059
let's put a name here uh-huh so any

00:30:57,330 --> 00:31:04,290
other know Tony's joined so um we can

00:31:00,059 --> 00:31:06,590
chat and that should just turn up in the

00:31:04,290 --> 00:31:06,590
other window

00:31:07,010 --> 00:31:13,950
doing a talk um and that will just turn

00:31:12,419 --> 00:31:17,280
up in the other window as long as you

00:31:13,950 --> 00:31:19,260
want it's pretty straightforward bit of

00:31:17,280 --> 00:31:22,830
code but this will scale really nicely

00:31:19,260 --> 00:31:25,320
because our publisher here is doing so

00:31:22,830 --> 00:31:26,370
little work it's almost never going to

00:31:25,320 --> 00:31:28,169
be able to overrate that unless you're

00:31:26,370 --> 00:31:30,059
pushing a lot of messages and even if

00:31:28,169 --> 00:31:32,010
you do you can have your subscriber

00:31:30,059 --> 00:31:33,390
connect to multiple publishers and so it

00:31:32,010 --> 00:31:35,070
can receive messages from many servers

00:31:33,390 --> 00:31:37,260
and you can easily build a ring of them

00:31:35,070 --> 00:31:40,830
we're having another push pull pair that

00:31:37,260 --> 00:31:49,559
can let you sync up between them so let

00:31:40,830 --> 00:31:50,549
me just kill off so another thing you

00:31:49,559 --> 00:31:51,780
can do because you've got that

00:31:50,549 --> 00:31:54,390
subscription filtering is actually

00:31:51,780 --> 00:31:57,090
invert the whole thing so let's say that

00:31:54,390 --> 00:32:00,990
you're doing some nice cash expiry and

00:31:57,090 --> 00:32:02,400
you have a graceful bit of sore bility

00:32:00,990 --> 00:32:04,200
to still have stale cash so rather than

00:32:02,400 --> 00:32:06,120
just using your memcache expiry you're

00:32:04,200 --> 00:32:08,159
actually embedding a date in there when

00:32:06,120 --> 00:32:09,630
that date is hit then instead of

00:32:08,159 --> 00:32:11,669
deleting it from the memcache it

00:32:09,630 --> 00:32:13,260
continues to serve the old data but

00:32:11,669 --> 00:32:14,909
sends a message saying hey I need a new

00:32:13,260 --> 00:32:17,490
data that's really good it means it's

00:32:14,909 --> 00:32:18,720
going to scale better it means you're

00:32:17,490 --> 00:32:21,510
not going to suddenly have a cache

00:32:18,720 --> 00:32:22,830
stampede of all your stuff expires so we

00:32:21,510 --> 00:32:24,600
can use their own cue to do that

00:32:22,830 --> 00:32:26,580
messaging between them but this time

00:32:24,600 --> 00:32:27,539
we'll use a publisher at each of the web

00:32:26,580 --> 00:32:29,490
clients so this will be a sort of

00:32:27,539 --> 00:32:31,110
transient publish it will pop up it'll

00:32:29,490 --> 00:32:32,940
connect subscribers and little publish

00:32:31,110 --> 00:32:35,100
outs of them and we can have different

00:32:32,940 --> 00:32:37,169
subscribers for different types of data

00:32:35,100 --> 00:32:40,710
so let's say that your user data is

00:32:37,169 --> 00:32:43,710
stored in a relational database and your

00:32:40,710 --> 00:32:45,299
document data is stored over in a no SQL

00:32:43,710 --> 00:32:46,740
and you've got totally different

00:32:45,299 --> 00:32:49,020
Hardware you've got different demands

00:32:46,740 --> 00:32:50,570
different requirements you just want to

00:32:49,020 --> 00:32:53,100
balance it a completely different way

00:32:50,570 --> 00:32:54,900
you can easily do that by just having a

00:32:53,100 --> 00:32:56,190
different subscriber for each so here

00:32:54,900 --> 00:32:57,480
we're going to use in proc we assuming

00:32:56,190 --> 00:33:01,140
everything's on the same machine you

00:32:57,480 --> 00:33:02,159
could use sorry interprocess because

00:33:01,140 --> 00:33:04,169
we're assuming everything's on the same

00:33:02,159 --> 00:33:06,240
machine but we could easily use TCP one

00:33:04,169 --> 00:33:08,039
thing else and we're just going to send

00:33:06,240 --> 00:33:10,200
a message out and our message is going

00:33:08,039 --> 00:33:12,150
to be two parts so the first part is

00:33:10,200 --> 00:33:13,679
what kind of data and the second part is

00:33:12,150 --> 00:33:17,400
you know maybe an idea this is just

00:33:13,679 --> 00:33:19,170
generating some random data for us the

00:33:17,400 --> 00:33:21,150
subscriber then for each

00:33:19,170 --> 00:33:23,910
would would have codes and something

00:33:21,150 --> 00:33:26,280
like this we'd subscribe as before and

00:33:23,910 --> 00:33:28,230
we'd set the socket option to what we

00:33:26,280 --> 00:33:29,310
wanted to subscribe to so here we're

00:33:28,230 --> 00:33:31,050
just subscribing to everything that

00:33:29,310 --> 00:33:32,940
starts with users so we've got our

00:33:31,050 --> 00:33:35,100
message on the top that says users we

00:33:32,940 --> 00:33:37,680
know we can pull that clear our cash and

00:33:35,100 --> 00:33:39,690
process normally and we will never get a

00:33:37,680 --> 00:33:41,820
receive if that subscription doesn't

00:33:39,690 --> 00:33:43,680
match we will never get into we will

00:33:41,820 --> 00:33:45,390
just sit here until we get a message it

00:33:43,680 --> 00:33:47,460
starts with users if a million messages

00:33:45,390 --> 00:33:48,990
go by that start with something else we

00:33:47,460 --> 00:33:50,280
don't care we don't know anything about

00:33:48,990 --> 00:33:52,830
it from the programming point of view

00:33:50,280 --> 00:33:54,900
and we're binding this so even though

00:33:52,830 --> 00:33:56,460
this is a sub socket we're being the

00:33:54,900 --> 00:33:57,990
stable part of the architecture we're

00:33:56,460 --> 00:34:00,210
going to do the bind and that's

00:33:57,990 --> 00:34:02,070
absolutely fine there is no restrictions

00:34:00,210 --> 00:34:04,080
/ which one connects on which one binds

00:34:02,070 --> 00:34:05,810
you can do it any way around you want if

00:34:04,080 --> 00:34:08,250
you want to have your reply socket

00:34:05,810 --> 00:34:10,110
connect and your request sockets bind

00:34:08,250 --> 00:34:12,860
it's fine zeromq does not limit you in

00:34:10,110 --> 00:34:15,510
any way but there is something a bit

00:34:12,860 --> 00:34:17,040
annoying about this and this lightly

00:34:15,510 --> 00:34:18,540
annoying thing is that you know let's

00:34:17,040 --> 00:34:19,620
say you've got users and data your

00:34:18,540 --> 00:34:21,870
document data and you want to add a

00:34:19,620 --> 00:34:23,970
third one well all your clients now have

00:34:21,870 --> 00:34:27,150
to connect to that as well it would be

00:34:23,970 --> 00:34:29,010
nice if they could just send it out and

00:34:27,150 --> 00:34:32,060
they can but with a different type of

00:34:29,010 --> 00:34:34,620
transport so we've looked up into

00:34:32,060 --> 00:34:36,540
process so that's two processes talking

00:34:34,620 --> 00:34:39,000
to each other and we've look what many

00:34:36,540 --> 00:34:41,070
processes and we've looked at TCP which

00:34:39,000 --> 00:34:43,340
is usually different servers talking to

00:34:41,070 --> 00:34:46,440
each other but there's a couple of other

00:34:43,340 --> 00:34:48,240
transport types built in 20 m q in proc

00:34:46,440 --> 00:34:49,850
which is basically threads talking to

00:34:48,240 --> 00:34:53,780
each other within the same process and

00:34:49,850 --> 00:34:57,060
PGM so you can't see our and PGM is a

00:34:53,780 --> 00:34:59,850
multicast option so PGM means you send

00:34:57,060 --> 00:35:02,040
one copy out and many receivers can

00:34:59,850 --> 00:35:04,170
listen to it that's really cool and it's

00:35:02,040 --> 00:35:05,850
really cool when you need a lot of data

00:35:04,170 --> 00:35:08,250
volume because if you let's say that

00:35:05,850 --> 00:35:10,200
you're sending out pub/sub like we were

00:35:08,250 --> 00:35:12,390
with a chat client over the network so I

00:35:10,200 --> 00:35:14,550
sent to one person I'm sending Sarna a

00:35:12,390 --> 00:35:16,380
Meg of data or a second now I send to a

00:35:14,550 --> 00:35:18,330
second person I was indeed to make of

00:35:16,380 --> 00:35:20,490
data a second third person three major

00:35:18,330 --> 00:35:21,990
update or a second all of this stuff is

00:35:20,490 --> 00:35:23,190
going to add up but maybe I can flood

00:35:21,990 --> 00:35:24,960
out my own network if i have enough

00:35:23,190 --> 00:35:27,120
traffic the kind of people that have

00:35:24,960 --> 00:35:29,370
enough traffic people at social networks

00:35:27,120 --> 00:35:31,500
so if you're doing social networks are

00:35:29,370 --> 00:35:32,990
you might need to have something thats

00:35:31,500 --> 00:35:34,610
collecting events

00:35:32,990 --> 00:35:36,619
so you have people commenting and

00:35:34,610 --> 00:35:38,180
tagging and uploading all of those

00:35:36,619 --> 00:35:39,619
things are triggering events and then

00:35:38,180 --> 00:35:41,270
you have lots of people that kind of

00:35:39,619 --> 00:35:42,800
like the chat example are subscribing to

00:35:41,270 --> 00:35:44,510
those events they're just going to have

00:35:42,800 --> 00:35:48,740
their page and they wanted to update as

00:35:44,510 --> 00:35:50,360
the events come in in real time so to do

00:35:48,740 --> 00:35:54,320
that you've got to push a lot of data

00:35:50,360 --> 00:35:58,880
route and what multicast does is rather

00:35:54,320 --> 00:36:02,510
than having the messages rather than

00:35:58,880 --> 00:36:04,880
having the messages be sent out each

00:36:02,510 --> 00:36:07,010
time it sends them out once but it

00:36:04,880 --> 00:36:09,410
signals that there's a sequence in there

00:36:07,010 --> 00:36:12,500
if that sequence number is missed

00:36:09,410 --> 00:36:14,840
effectively yeah the client calls back

00:36:12,500 --> 00:36:16,640
and say hey I didn't get that one and it

00:36:14,840 --> 00:36:19,250
resends it for within a window of

00:36:16,640 --> 00:36:21,110
resending which allows you the amount of

00:36:19,250 --> 00:36:24,590
network traffic used to be significantly

00:36:21,110 --> 00:36:27,110
lower than if you were sending a copy

00:36:24,590 --> 00:36:28,460
out to each one so the kind of

00:36:27,110 --> 00:36:30,740
architecture you might use for something

00:36:28,460 --> 00:36:33,170
like this is let's say that you have an

00:36:30,740 --> 00:36:35,450
event publisher there and you have lots

00:36:33,170 --> 00:36:38,150
of clients lots of clients sending stuff

00:36:35,450 --> 00:36:40,070
people tagging things all over the place

00:36:38,150 --> 00:36:42,350
many machines pushing into this one hub

00:36:40,070 --> 00:36:43,250
and then it's using multicast to send it

00:36:42,350 --> 00:36:46,550
out so it doesn't matter how many

00:36:43,250 --> 00:36:48,740
connected racks or servers or whatever

00:36:46,550 --> 00:36:50,359
it's just sending it out and they're all

00:36:48,740 --> 00:36:52,910
going to listen on it and then each of

00:36:50,359 --> 00:36:55,280
them has another redistributor so this

00:36:52,910 --> 00:36:57,500
is going to listen on that broadcast and

00:36:55,280 --> 00:36:59,180
then rebroadcast it within the machine

00:36:57,500 --> 00:37:01,010
or within the rack or within whatever

00:36:59,180 --> 00:37:03,500
unit you choose to do within the data

00:37:01,010 --> 00:37:05,000
center and then it can have multiple

00:37:03,500 --> 00:37:06,830
subscribers on it that will actually

00:37:05,000 --> 00:37:08,690
filter the subscriptions down to the

00:37:06,830 --> 00:37:11,750
stuff they're interested in so you might

00:37:08,690 --> 00:37:13,700
have you know a million user IDs being

00:37:11,750 --> 00:37:16,310
pushed through the event pub and each

00:37:13,700 --> 00:37:18,020
subscriber at the end really only caring

00:37:16,310 --> 00:37:19,970
about 150 or whatever the average number

00:37:18,020 --> 00:37:23,030
of friends someone has so you've got

00:37:19,970 --> 00:37:24,830
many many less being worried about here

00:37:23,030 --> 00:37:26,869
and you just want to have that work

00:37:24,830 --> 00:37:29,780
pretty transiently and this is saying

00:37:26,869 --> 00:37:33,500
that is easy to do in zeromq so here

00:37:29,780 --> 00:37:35,119
we're going to do our event publisher so

00:37:33,500 --> 00:37:36,350
this is just like the chat server we

00:37:35,119 --> 00:37:38,570
have before we're going to pull in

00:37:36,350 --> 00:37:40,400
messages on a pull socket and we're

00:37:38,570 --> 00:37:43,340
going to publish them back out but

00:37:40,400 --> 00:37:45,950
rather than publishing on IPC we're

00:37:43,340 --> 00:37:46,609
publishing them EP GM so this is the

00:37:45,950 --> 00:37:48,259
multicast

00:37:46,609 --> 00:37:50,599
option that is transported over UDP

00:37:48,259 --> 00:37:54,230
there's also PGM which is transported

00:37:50,599 --> 00:37:56,900
over IP we can specify an interface so

00:37:54,230 --> 00:37:59,480
this semicolon before that you could put

00:37:56,900 --> 00:38:01,039
a 0 or the IP of whichever interface you

00:37:59,480 --> 00:38:02,690
wanted and in this case I'm just saying

00:38:01,039 --> 00:38:05,059
use the first one then you put the

00:38:02,690 --> 00:38:08,089
multicast IP there's all multicast in

00:38:05,059 --> 00:38:10,099
IPR in a certain address range and then

00:38:08,089 --> 00:38:11,599
you put the port so you can still have

00:38:10,099 --> 00:38:14,989
multiple multi cars going over the same

00:38:11,599 --> 00:38:16,730
network no problem and we're using a

00:38:14,989 --> 00:38:18,440
device here because rather than writing

00:38:16,730 --> 00:38:20,029
that code to switch packets back and

00:38:18,440 --> 00:38:22,190
forth we just go to one liner that says

00:38:20,029 --> 00:38:23,269
I want a forwarded device and that's

00:38:22,190 --> 00:38:25,519
actually going to do exactly the same

00:38:23,269 --> 00:38:27,890
thing it's just written in C and it's

00:38:25,519 --> 00:38:29,989
built in and these devices you can

00:38:27,890 --> 00:38:33,499
actually get a standalone little scripts

00:38:29,989 --> 00:38:35,749
so while 0 and Q doesn't have a server

00:38:33,499 --> 00:38:37,099
it does have standalone see versions of

00:38:35,749 --> 00:38:38,989
these devices which you can configure

00:38:37,099 --> 00:38:41,269
and run so you could replace this whole

00:38:38,989 --> 00:38:45,319
thing with a little device that runs

00:38:41,269 --> 00:38:47,079
somewhere the distributor so we're going

00:38:45,319 --> 00:38:49,819
to say this is running on each server

00:38:47,079 --> 00:38:51,230
that's handling web clients is going to

00:38:49,819 --> 00:38:53,630
do the same thing we're going to

00:38:51,230 --> 00:38:55,130
subscribe and we're going to subscribe

00:38:53,630 --> 00:38:57,109
to everything so it's blank again and

00:38:55,130 --> 00:39:00,589
then we're going to publish out through

00:38:57,109 --> 00:39:01,640
another publishing that is on a IPC so

00:39:00,589 --> 00:39:04,640
we're just going to take from the

00:39:01,640 --> 00:39:07,400
multicast and out over the IPC now the

00:39:04,640 --> 00:39:09,049
reason we do this step is not because we

00:39:07,400 --> 00:39:11,390
can't listen on the multicast directly

00:39:09,049 --> 00:39:14,450
we can but it's because of slow

00:39:11,390 --> 00:39:16,099
subscribers so if one of our web clients

00:39:14,450 --> 00:39:19,099
goes wrong or someone commits some dodgy

00:39:16,099 --> 00:39:20,960
code and it starts taking a long time it

00:39:19,099 --> 00:39:23,269
might this one is going to have to hold

00:39:20,960 --> 00:39:25,069
more data to be able to publish it out

00:39:23,269 --> 00:39:29,119
if we decide we want pretty reliable

00:39:25,069 --> 00:39:31,130
delivery so if we have a problem we want

00:39:29,119 --> 00:39:32,569
that problem to be on that box and not

00:39:31,130 --> 00:39:34,970
all the way back to our central

00:39:32,569 --> 00:39:36,769
distribution point because that's got to

00:39:34,970 --> 00:39:38,450
keep going it's got to keep throwing

00:39:36,769 --> 00:39:40,160
data out because it's not just web

00:39:38,450 --> 00:39:41,660
client cert listening it's the database

00:39:40,160 --> 00:39:43,549
it's analytics is lots of other

00:39:41,660 --> 00:39:46,369
important stuff so we have this extra

00:39:43,549 --> 00:39:48,200
step in there and again that's the idea

00:39:46,369 --> 00:39:49,940
of zeromq you build in as many little

00:39:48,200 --> 00:39:51,589
hops as you need because they're cheap

00:39:49,940 --> 00:39:53,420
and they're simple and then here's our

00:39:51,589 --> 00:39:55,069
fate client so our fake client is just

00:39:53,420 --> 00:39:57,499
going to subscribe to 100 different

00:39:55,069 --> 00:39:59,299
random IDs we can easily just do this

00:39:57,499 --> 00:40:00,440
subscribe as many times as we want so if

00:39:59,299 --> 00:40:02,030
we want to subscribe to a

00:40:00,440 --> 00:40:03,890
different things no problem it all

00:40:02,030 --> 00:40:06,650
happens really fast it uses good

00:40:03,890 --> 00:40:09,290
tree-based matching and then we're just

00:40:06,650 --> 00:40:11,329
going to connect to our IPC and it's

00:40:09,290 --> 00:40:14,300
going to help put some stuff so this is

00:40:11,329 --> 00:40:15,829
going to work out of the box these

00:40:14,300 --> 00:40:18,520
grapes will let you do that message

00:40:15,829 --> 00:40:22,550
distribution on any system that supports

00:40:18,520 --> 00:40:24,349
0q and PGM and with just on my little

00:40:22,550 --> 00:40:26,569
macbook air bottom of the line macbook

00:40:24,349 --> 00:40:28,339
air I was pushing around a hundred

00:40:26,569 --> 00:40:30,050
thousand messages a minute between two

00:40:28,339 --> 00:40:32,569
different VMs running on this if you're

00:40:30,050 --> 00:40:34,190
using proper hardware you can push

00:40:32,569 --> 00:40:35,540
significantly more and this is exactly

00:40:34,190 --> 00:40:37,130
the kind of thing you would be doing if

00:40:35,540 --> 00:40:40,700
you're pushing a lot of market data or

00:40:37,130 --> 00:40:44,990
other financial stuff like that so one

00:40:40,700 --> 00:40:47,690
last area I want to look at hopefully

00:40:44,990 --> 00:40:51,140
find this interesting is a mongrel to

00:40:47,690 --> 00:40:53,119
has anyone heard of mongrel yeah as

00:40:51,140 --> 00:40:56,270
people there so feel it Mongol web

00:40:53,119 --> 00:40:59,060
server out of the Ruby world very

00:40:56,270 --> 00:41:02,000
popular big breakup between Zed shore in

00:40:59,060 --> 00:41:04,490
the rails community and he started

00:41:02,000 --> 00:41:06,050
looking at building a new web server so

00:41:04,490 --> 00:41:07,670
he's building a sort of web application

00:41:06,050 --> 00:41:09,980
server thing and he wants it to be

00:41:07,670 --> 00:41:12,740
language agnostic he doesn't want it to

00:41:09,980 --> 00:41:14,839
be tied to anything and so rather than

00:41:12,740 --> 00:41:16,670
using are the same kind of things that

00:41:14,839 --> 00:41:19,220
engine X or like to do and use for CGI

00:41:16,670 --> 00:41:20,270
to talk to a process so those web

00:41:19,220 --> 00:41:23,210
servers you'll have your kind of

00:41:20,270 --> 00:41:25,640
application process and you'll have your

00:41:23,210 --> 00:41:28,670
web server and it'll talk to it over far

00:41:25,640 --> 00:41:29,839
cgi he decided to use zeromq to do that

00:41:28,670 --> 00:41:31,880
because then you get all the messages

00:41:29,839 --> 00:41:33,619
all the benefits are the messages you

00:41:31,880 --> 00:41:35,660
can have Reuters in there you can have

00:41:33,619 --> 00:41:37,130
clustering kind of built in because it

00:41:35,660 --> 00:41:38,839
can go out over the network or it can go

00:41:37,130 --> 00:41:41,210
in one machine you get all the nice

00:41:38,839 --> 00:41:43,819
things and you get the fact that it will

00:41:41,210 --> 00:41:46,760
work in any language the zeromq works in

00:41:43,819 --> 00:41:49,790
so if you really want to write a web web

00:41:46,760 --> 00:41:54,619
app in order or in haskell no problem

00:41:49,790 --> 00:41:55,970
because they have 0 mq blinded so what

00:41:54,619 --> 00:41:58,339
it actually does to achieve that is

00:41:55,970 --> 00:42:00,530
pushes two handlers so every time it

00:41:58,339 --> 00:42:02,089
gets a web request it's going to package

00:42:00,530 --> 00:42:04,460
out up and push that out to a handler

00:42:02,089 --> 00:42:06,770
and it's going to listen on a subscribe

00:42:04,460 --> 00:42:08,599
socket for messages coming back in and

00:42:06,770 --> 00:42:11,089
that's cool because that allows you to

00:42:08,599 --> 00:42:12,920
do some costs during really easily and

00:42:11,089 --> 00:42:14,440
it also allows you to do some really

00:42:12,920 --> 00:42:17,440
cool stuff with long

00:42:14,440 --> 00:42:21,470
so this is about the simplest possible

00:42:17,440 --> 00:42:23,240
Mongol to handler I could write all

00:42:21,470 --> 00:42:24,829
we're going to do is connect to the

00:42:23,240 --> 00:42:26,780
sockets that we've defective time from

00:42:24,829 --> 00:42:29,660
Mongol to so we're going over TCP and

00:42:26,780 --> 00:42:31,490
we're just going to listen on our pull

00:42:29,660 --> 00:42:32,930
socket so that's where the requests are

00:42:31,490 --> 00:42:35,359
going to come from and we going to send

00:42:32,930 --> 00:42:37,369
messages back on our pub socket here

00:42:35,359 --> 00:42:39,020
we've just got a bit of HTTP header and

00:42:37,369 --> 00:42:40,730
when we get a message from Mongol to

00:42:39,020 --> 00:42:42,740
it's going to tell us it the idea of the

00:42:40,730 --> 00:42:44,930
server the uuid it's going to tell us

00:42:42,740 --> 00:42:46,640
the ID of the connection which is just

00:42:44,930 --> 00:42:48,890
ID in this example it's going to tell us

00:42:46,640 --> 00:42:51,619
the path that was requested so if we

00:42:48,890 --> 00:42:53,839
want to just say no send out a redirect

00:42:51,619 --> 00:42:55,400
we can do that quite quickly and then

00:42:53,839 --> 00:42:58,310
it's going to give us all the headers in

00:42:55,400 --> 00:43:00,290
a JSON encoded object and it's going to

00:42:58,310 --> 00:43:01,819
give us the body so you know if anything

00:43:00,290 --> 00:43:02,990
was posted or anything that was sent

00:43:01,819 --> 00:43:04,910
across you're going to get that whole of

00:43:02,990 --> 00:43:07,700
that so what we're going to do here is

00:43:04,910 --> 00:43:09,740
just pull out the server ID and the ID

00:43:07,700 --> 00:43:12,079
and then our message we want to send

00:43:09,740 --> 00:43:14,900
back and send those back so we just say

00:43:12,079 --> 00:43:17,869
this server for this connection send

00:43:14,900 --> 00:43:21,109
them this a mongrel handles talking to

00:43:17,869 --> 00:43:25,310
the connection so that means if we have

00:43:21,109 --> 00:43:26,720
20 servers we can just send out and the

00:43:25,310 --> 00:43:29,569
right one will be listening with a

00:43:26,720 --> 00:43:31,250
subscription filter for its uuid at the

00:43:29,569 --> 00:43:32,750
star which makes clustering kind of very

00:43:31,250 --> 00:43:34,369
easy we don't have to worry about how

00:43:32,750 --> 00:43:37,150
many servers they are we just no wig and

00:43:34,369 --> 00:43:39,740
a request that tells us who to reply to

00:43:37,150 --> 00:43:42,530
so the config of that is I mean it's

00:43:39,740 --> 00:43:44,030
it's quite long I wouldn't worry too

00:43:42,530 --> 00:43:45,319
much about it but kind of at the top

00:43:44,030 --> 00:43:49,069
there you can just about see those are

00:43:45,319 --> 00:43:51,260
standard zeromq addresses so you can put

00:43:49,069 --> 00:43:52,730
any zeromq address you wanting there you

00:43:51,260 --> 00:43:55,339
can have it go over different transport

00:43:52,730 --> 00:43:57,440
types it's fine and you can see what the

00:43:55,339 --> 00:44:00,500
identifier is of the server so you can

00:43:57,440 --> 00:44:01,940
control all that from to but you

00:44:00,500 --> 00:44:03,650
probably want something a bit more a

00:44:01,940 --> 00:44:07,400
handle that's a bit more complex to

00:44:03,650 --> 00:44:11,930
build anything interesting actually Winx

00:44:07,400 --> 00:44:14,780
has done a PHP 53 handler Jesus name

00:44:11,930 --> 00:44:16,700
spaces and it's a bit more of a Bose but

00:44:14,780 --> 00:44:19,010
i just wanted to show you what kind of

00:44:16,700 --> 00:44:21,020
thing you could do with this handler and

00:44:19,010 --> 00:44:23,540
with too so if we think about our

00:44:21,020 --> 00:44:25,819
chat example before we were having a

00:44:23,540 --> 00:44:27,589
chat script running for each connected

00:44:25,819 --> 00:44:29,450
client so if 10 of you

00:44:27,589 --> 00:44:32,119
connected to my chat server I would have

00:44:29,450 --> 00:44:34,849
chat log PHP running 10 times serving up

00:44:32,119 --> 00:44:37,369
that iframe that's fine but if I'm

00:44:34,849 --> 00:44:39,410
running say three megs a memory pub

00:44:37,369 --> 00:44:42,019
process then that is going to run out

00:44:39,410 --> 00:44:43,609
eventually I can only serve so many but

00:44:42,019 --> 00:44:45,229
i'm not really doing anything most of

00:44:43,609 --> 00:44:47,960
the time I'm just listening and sending

00:44:45,229 --> 00:44:51,829
messages out so what we can do with this

00:44:47,960 --> 00:44:53,960
is run a single chat dot PHP and let

00:44:51,829 --> 00:44:55,789
Mongol handle which people we want to

00:44:53,960 --> 00:44:59,210
send it to so here we're just going to

00:44:55,789 --> 00:45:00,410
connect to our subscribe socket so this

00:44:59,210 --> 00:45:02,869
is where we're going to subscribe to the

00:45:00,410 --> 00:45:06,529
chat messages and we're going to connect

00:45:02,869 --> 00:45:08,239
to our Mongol socket and that is going

00:45:06,529 --> 00:45:09,140
to we're going to poll both of them so

00:45:08,239 --> 00:45:11,150
we're going to be looking for any

00:45:09,140 --> 00:45:13,210
messages coming from Mongol or any

00:45:11,150 --> 00:45:15,619
messages coming from the chat server and

00:45:13,210 --> 00:45:18,109
then the actual work of it is just this

00:45:15,619 --> 00:45:20,239
loop here so down the bottom if we get a

00:45:18,109 --> 00:45:22,339
message from mongrel we're just going to

00:45:20,239 --> 00:45:23,539
get the sender out of it and we're going

00:45:22,339 --> 00:45:25,219
to store it so we're going to have a

00:45:23,539 --> 00:45:26,630
list of all the connected people and

00:45:25,219 --> 00:45:28,400
sometimes it's going to send two

00:45:26,630 --> 00:45:29,869
disconnected messages if the client goes

00:45:28,400 --> 00:45:31,099
away it's just going to send us a

00:45:29,869 --> 00:45:33,349
disconnected message so we're going to

00:45:31,099 --> 00:45:35,269
remove that ID so what we're going to

00:45:33,349 --> 00:45:37,999
have is an array with all the IDS of

00:45:35,269 --> 00:45:40,460
people connected then at the top if we

00:45:37,999 --> 00:45:42,109
get any messages in from our chat server

00:45:40,460 --> 00:45:44,450
we're just going to put in the

00:45:42,109 --> 00:45:46,969
JavaScript as before and send it to all

00:45:44,450 --> 00:45:48,680
of those IDs so we send the one message

00:45:46,969 --> 00:45:51,079
and we just say we'd like you to go to

00:45:48,680 --> 00:45:52,910
these ten IDs a mongrel handles firing

00:45:51,079 --> 00:45:56,269
it out to the right servers so that

00:45:52,910 --> 00:45:58,430
means our memory usage to run this chat

00:45:56,269 --> 00:46:00,019
server has just massively diminished and

00:45:58,430 --> 00:46:02,180
we can serve many many more clients and

00:46:00,019 --> 00:46:04,069
because Mongols event-based pretty

00:46:02,180 --> 00:46:09,140
efficient it doesn't really use up a lot

00:46:04,069 --> 00:46:11,269
of space either so that's about it from

00:46:09,140 --> 00:46:12,859
me there are some helpful links here and

00:46:11,269 --> 00:46:15,049
we'll do a bit of questions off to if

00:46:12,859 --> 00:46:16,969
they are Hanley zeromq is the community

00:46:15,049 --> 00:46:19,700
site have a look see if there's anything

00:46:16,969 --> 00:46:21,380
interesting there the Zed guide is the

00:46:19,700 --> 00:46:23,479
best thing to look at if you want to

00:46:21,380 --> 00:46:25,369
learn more it's an in process of being

00:46:23,479 --> 00:46:28,640
written book that is going to tell you

00:46:25,369 --> 00:46:30,769
all about zeromq are all about

00:46:28,640 --> 00:46:33,499
reliability patterns really get into the

00:46:30,769 --> 00:46:37,039
details of it the code from this talk is

00:46:33,499 --> 00:46:38,779
there on github I'll put the slides on

00:46:37,039 --> 00:46:41,450
SlideShare and that link will be tweeted

00:46:38,779 --> 00:46:44,210
about and i love it please do

00:46:41,450 --> 00:46:46,640
feedback on joins in I'd love to know we

00:46:44,210 --> 00:46:47,960
think is Erin cue the talk and anything

00:46:46,640 --> 00:46:50,900
else because I think this is a really

00:46:47,960 --> 00:46:53,329
great way of building systems that do

00:46:50,900 --> 00:46:54,200
more than just the regular lamp stack I

00:46:53,329 --> 00:46:56,630
think it's the easiest way I've

00:46:54,200 --> 00:46:59,780
encountered my really hope it's gonna do

00:46:56,630 --> 00:47:08,300
something for you so um thank you any

00:46:59,780 --> 00:47:10,550
questions okay the law school that's

00:47:08,300 --> 00:47:11,780
like you put up for the chat sir with a

00:47:10,550 --> 00:47:13,640
right in thinking you could have

00:47:11,780 --> 00:47:15,530
multiple ones of those ranks will

00:47:13,640 --> 00:47:17,630
taneously absolutely and they were just

00:47:15,530 --> 00:47:19,970
sent to one of them so if one did crash

00:47:17,630 --> 00:47:23,750
and doesn't look epic it yeah I mean

00:47:19,970 --> 00:47:27,200
certainly yeah it's very easy to do that

00:47:23,750 --> 00:47:28,609
in almost any sense of you have multiple

00:47:27,200 --> 00:47:29,869
bits of redundancy in there because

00:47:28,609 --> 00:47:31,490
there and kill just happily let you

00:47:29,869 --> 00:47:33,710
connect as many as you want or bind as

00:47:31,490 --> 00:47:35,480
many as you want you can just fire in

00:47:33,710 --> 00:47:36,650
you can just have multiple of the same

00:47:35,480 --> 00:47:38,839
thing running and you get your

00:47:36,650 --> 00:47:40,790
redundancy so anytime you got a stable

00:47:38,839 --> 00:47:43,339
part like that like that server just

00:47:40,790 --> 00:47:44,930
think oh I need to so fine just have to

00:47:43,339 --> 00:47:49,520
and all this guy's this on both the

00:47:44,930 --> 00:47:53,180
absolute great cool I think yeah yeah is

00:47:49,520 --> 00:47:56,569
there anything built-in in 200 mq to

00:47:53,180 --> 00:47:59,960
monitor the queues itself to find out

00:47:56,569 --> 00:48:01,849
where they stack up on our the there are

00:47:59,960 --> 00:48:04,520
a few mechanisms in Durham key so part

00:48:01,849 --> 00:48:07,010
of the general architecture of 0 and Q

00:48:04,520 --> 00:48:10,369
itself is a library is that it does not

00:48:07,010 --> 00:48:12,950
want you to worry about what it's doing

00:48:10,369 --> 00:48:14,780
so it doesn't want you to worry about

00:48:12,950 --> 00:48:16,849
with the clients their servers there or

00:48:14,780 --> 00:48:19,250
not it'll just deliver it when it can so

00:48:16,849 --> 00:48:20,960
for its internal cues the ones you get

00:48:19,250 --> 00:48:23,569
built in when you're sending or when

00:48:20,960 --> 00:48:25,700
you're receiving the only monitoring you

00:48:23,569 --> 00:48:27,829
can do is by setting a high watermark

00:48:25,700 --> 00:48:30,079
which is the maximum number will have in

00:48:27,829 --> 00:48:31,430
it and by setting the low-water mark

00:48:30,079 --> 00:48:33,319
which is when it will start accepting

00:48:31,430 --> 00:48:34,910
things again if you're building a queue

00:48:33,319 --> 00:48:36,560
like the one we saw that was just

00:48:34,910 --> 00:48:38,480
swapping packets back and forth messages

00:48:36,560 --> 00:48:40,040
back and forth then yeah you can easily

00:48:38,480 --> 00:48:41,690
put in more monitoring there you can

00:48:40,040 --> 00:48:43,369
easily do whatever you want um miko

00:48:41,690 --> 00:48:45,710
actually has a bit of a project he'd

00:48:43,369 --> 00:48:48,890
started on which was saving off the

00:48:45,710 --> 00:48:50,210
messages into Kyoto cabinet so that you

00:48:48,890 --> 00:48:53,420
can get you know copy over them

00:48:50,210 --> 00:48:55,010
somewhere you can easily add that kind

00:48:53,420 --> 00:48:57,110
of stuff in because you

00:48:55,010 --> 00:48:58,520
only got really four or five lines of 0

00:48:57,110 --> 00:49:05,090
and Q code and after that its

00:48:58,520 --> 00:49:08,300
application code cool and on us is rayon

00:49:05,090 --> 00:49:10,910
you all move persistent for the cues so

00:49:08,300 --> 00:49:15,290
if the stable part becomes unstable and

00:49:10,910 --> 00:49:17,360
falls over yeah um in general no so you

00:49:15,290 --> 00:49:19,220
can when you hit that high water mark of

00:49:17,360 --> 00:49:21,740
having too many messages you can set up

00:49:19,220 --> 00:49:22,910
swap so it will write to disk so that

00:49:21,740 --> 00:49:25,640
you can allow yourself to handle more

00:49:22,910 --> 00:49:27,650
messages but built-in there's nothing in

00:49:25,640 --> 00:49:29,990
there to say save into a database or

00:49:27,650 --> 00:49:31,850
save them out to a file that kind of

00:49:29,990 --> 00:49:35,150
thing one of the reasons behind that is

00:49:31,850 --> 00:49:37,940
that if you have big trains of these

00:49:35,150 --> 00:49:40,670
things they break they break because

00:49:37,940 --> 00:49:42,350
someone's going slow and you can't your

00:49:40,670 --> 00:49:44,330
persistence isn't quite good enough so

00:49:42,350 --> 00:49:46,160
reliability is very very tricky on that

00:49:44,330 --> 00:49:47,630
point of view because let's say that you

00:49:46,160 --> 00:49:49,310
wanted to be sure hey Mike you will

00:49:47,630 --> 00:49:51,860
definitely have the message you send the

00:49:49,310 --> 00:49:53,030
message to your queue well the only way

00:49:51,860 --> 00:49:55,070
you could be sure it has it is if it

00:49:53,030 --> 00:49:57,530
does a reply so you'd use a rest request

00:49:55,070 --> 00:49:59,750
to reply but what if your network loses

00:49:57,530 --> 00:50:02,000
that reply packet it might actually have

00:49:59,750 --> 00:50:03,650
it so then maybe have to UM if you don't

00:50:02,000 --> 00:50:05,540
get that in a certain time center Ken

00:50:03,650 --> 00:50:07,340
and you can actually really slow down

00:50:05,540 --> 00:50:09,440
your whole system trying to build in

00:50:07,340 --> 00:50:11,240
more and more reliability so it went

00:50:09,440 --> 00:50:13,220
with another quote from John Giffard

00:50:11,240 --> 00:50:14,810
actually he said here ziering cue goes

00:50:13,220 --> 00:50:17,030
with the sort of formula 1 philosophy

00:50:14,810 --> 00:50:18,590
start with something fast and make it

00:50:17,030 --> 00:50:24,130
reliable rather than start with signed

00:50:18,590 --> 00:50:24,130
reliable and try and make it faster yeah

00:50:27,269 --> 00:50:39,209
I viewed it yeah I must admit I don't so

00:50:37,709 --> 00:50:41,459
the question was whether I knew much

00:50:39,209 --> 00:50:43,769
about the Taylor hash peer-to-peer which

00:50:41,459 --> 00:50:47,519
is I've gotten the guy's name the guy

00:50:43,769 --> 00:50:49,189
who came up with yeah xmpp I don't I

00:50:47,519 --> 00:50:52,140
don't know a lot about it to be honest I

00:50:49,189 --> 00:50:55,409
it's likely to be cool because XMPP is

00:50:52,140 --> 00:50:58,229
pretty cool there are other protocols

00:50:55,409 --> 00:51:00,179
that do messaging systems and sometimes

00:50:58,229 --> 00:51:03,929
there are things that can talk both like

00:51:00,179 --> 00:51:05,609
there is a protocol called amqp which is

00:51:03,929 --> 00:51:07,769
the advanced message queue protocol and

00:51:05,609 --> 00:51:09,329
that was that's a lot of banks use that

00:51:07,769 --> 00:51:12,659
and let you can get something like

00:51:09,329 --> 00:51:14,640
rabbitmq which can talk both amqp and 0

00:51:12,659 --> 00:51:16,019
and Q so you can kind of build stuff in

00:51:14,640 --> 00:51:17,699
together if you need to but no I don't

00:51:16,019 --> 00:51:26,399
have any specific stuff about to hash

00:51:17,699 --> 00:51:31,529
unfortunately don't you know ill do I

00:51:26,399 --> 00:51:35,339
actually Rumble using a web server from

00:51:31,529 --> 00:51:37,559
I'm ethics 80s yeah as I Tommy or

00:51:35,339 --> 00:51:39,839
whatever the name is back yeah yeah and

00:51:37,559 --> 00:51:44,519
m coupe user you've written by the same

00:51:39,839 --> 00:51:47,099
people yes zeromq is mqp done right if

00:51:44,519 --> 00:51:48,779
that's exactly it so yeah amqp was by

00:51:47,099 --> 00:51:50,519
the guys that went on to the zoo and q

00:51:48,779 --> 00:51:53,269
basically doom q is them trying to fix

00:51:50,519 --> 00:51:57,989
all the problems they encountered in mtv

00:51:53,269 --> 00:51:59,669
yeah I don't forgot I am I love zeromq

00:51:57,989 --> 00:52:02,069
I'm building a small that myself with it

00:51:59,669 --> 00:52:03,209
was very good well I just want some more

00:52:02,069 --> 00:52:07,139
of a comment maybe you could comment on

00:52:03,209 --> 00:52:08,789
it is the fact that you can write a c 0

00:52:07,139 --> 00:52:10,619
mq process really easily much more

00:52:08,789 --> 00:52:12,029
reason and running a see extension and

00:52:10,619 --> 00:52:13,769
also the fact that you can get around

00:52:12,029 --> 00:52:15,719
that there are no threads real threats

00:52:13,769 --> 00:52:17,819
in PHP yeah so you can just write

00:52:15,719 --> 00:52:19,349
multiple processes or throw it or in

00:52:17,819 --> 00:52:21,299
different languages where the PHP or C

00:52:19,349 --> 00:52:23,219
ready yeah yes absolutely I mean yeah

00:52:21,299 --> 00:52:25,139
that's absolutely right it's because

00:52:23,219 --> 00:52:26,609
it's a very easy way to plug different

00:52:25,139 --> 00:52:29,099
languages any of these examples could

00:52:26,609 --> 00:52:30,569
have been in any language because it's

00:52:29,099 --> 00:52:32,279
really easy to plug them in you often

00:52:30,569 --> 00:52:33,809
find you would do a service where you

00:52:32,279 --> 00:52:36,149
would have maybe tried to do something

00:52:33,809 --> 00:52:38,639
in PHP yourself because it's so trivial

00:52:36,149 --> 00:52:40,950
and if you do need to scale out because

00:52:38,639 --> 00:52:42,540
they do let you synchronize multiple

00:52:40,950 --> 00:52:44,940
processes easily push data between

00:52:42,540 --> 00:52:46,290
multiple processes you can have you

00:52:44,940 --> 00:52:48,000
could do multiprocessing where would

00:52:46,290 --> 00:52:50,310
have been hard and particularly if you

00:52:48,000 --> 00:52:54,210
do any work in a language which is

00:52:50,310 --> 00:52:55,710
threaded as you say data being shared

00:52:54,210 --> 00:52:57,359
between threads is where you hit all of

00:52:55,710 --> 00:53:00,780
your problems with speed when you go to

00:52:57,359 --> 00:53:02,310
multi threading and zeromq is a great

00:53:00,780 --> 00:53:04,710
way to do that because you can send

00:53:02,310 --> 00:53:06,599
messages between threads you can send a

00:53:04,710 --> 00:53:13,650
pointer between threads with the

00:53:06,599 --> 00:53:16,700
messages cool anything else no I think

00:53:13,650 --> 00:53:16,700

YouTube URL: https://www.youtube.com/watch?v=h8jo3GnKhWM


