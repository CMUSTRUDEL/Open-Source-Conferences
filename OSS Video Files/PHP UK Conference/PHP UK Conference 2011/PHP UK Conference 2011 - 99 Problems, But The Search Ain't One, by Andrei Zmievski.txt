Title: PHP UK Conference 2011 - 99 Problems, But The Search Ain't One, by Andrei Zmievski
Publication date: 2012-03-15
Playlist: PHP UK Conference 2011
Description: 
	
Captions: 
	00:00:04,850 --> 00:00:11,160
thank you for coming to the talk as our

00:00:09,030 --> 00:00:15,059
Commission is Celeste one of the day can

00:00:11,160 --> 00:00:17,759
all go to party after this so hopefully

00:00:15,059 --> 00:00:21,360
I won't keep you any longer pacity 5 30

00:00:17,759 --> 00:00:22,260
deadline just as a quick show of hands

00:00:21,360 --> 00:00:26,580
how many people have heard of

00:00:22,260 --> 00:00:29,310
elasticsearch at all ok but half a dozen

00:00:26,580 --> 00:00:32,010
and how many need to solve a full text

00:00:29,310 --> 00:00:40,799
search problem for their product a lot

00:00:32,010 --> 00:00:43,820
more good so Who am I and decided to use

00:00:40,799 --> 00:00:46,710
elastic search to answer that question

00:00:43,820 --> 00:00:50,940
we'll talk about what all that is in a

00:00:46,710 --> 00:00:55,769
little bit but I've worked on projects

00:00:50,940 --> 00:00:58,320
such as PHP for over 10 years I did PHP

00:00:55,769 --> 00:01:01,110
gtk and smarty whether you want to hate

00:00:58,320 --> 00:01:03,650
me or love me for that although I

00:01:01,110 --> 00:01:07,170
haven't worked in a long time and I also

00:01:03,650 --> 00:01:08,640
started and sort of ran the project to

00:01:07,170 --> 00:01:13,469
do unit code and international relations

00:01:08,640 --> 00:01:17,659
support and PHP which kind of got table

00:01:13,469 --> 00:01:20,640
for four now I like coding obviously I

00:01:17,659 --> 00:01:22,979
like beer both drinking and brewing beer

00:01:20,640 --> 00:01:24,630
and photography and bunch of other stuff

00:01:22,979 --> 00:01:26,100
that didn't fit on the slide so any if

00:01:24,630 --> 00:01:28,380
any of that interest you come talk to me

00:01:26,100 --> 00:01:31,649
at the party we can discuss any of that

00:01:28,380 --> 00:01:33,600
stuff I'm at a on Twitter which is

00:01:31,649 --> 00:01:36,780
awesome and horrible at the same time

00:01:33,600 --> 00:01:38,369
because my reply stream is useless if

00:01:36,780 --> 00:01:40,049
you want to see what it looks like ask

00:01:38,369 --> 00:01:42,119
me I'll show you this people tweeting

00:01:40,049 --> 00:01:44,390
nonsensical stuff we're saying I'm at a

00:01:42,119 --> 00:01:44,390
bar

00:01:46,000 --> 00:01:51,680
it gets worse and my email is there all

00:01:50,360 --> 00:01:53,990
these slides will be up or both on my

00:01:51,680 --> 00:01:55,640
side and I think on PHP case I site

00:01:53,990 --> 00:02:01,670
later so you don't need to write that

00:01:55,640 --> 00:02:04,460
right now so what is elastic search it's

00:02:01,670 --> 00:02:06,890
a full-text search engine that has been

00:02:04,460 --> 00:02:11,410
designed for the no sequel generation is

00:02:06,890 --> 00:02:14,930
sort of my tagline for it the guy who

00:02:11,410 --> 00:02:16,880
started the project shape man he worked

00:02:14,930 --> 00:02:18,950
with leucine a lot in the past and he

00:02:16,880 --> 00:02:21,769
did another search engine called calm

00:02:18,950 --> 00:02:23,959
pass on top of that a few years ago but

00:02:21,769 --> 00:02:28,100
when he started out elastic sure she

00:02:23,959 --> 00:02:30,620
wanted to ride a product that was sort

00:02:28,100 --> 00:02:32,000
of optimized for the new movements that

00:02:30,620 --> 00:02:35,209
have been happening last couple years

00:02:32,000 --> 00:02:38,840
such as cloud JSON and all the things

00:02:35,209 --> 00:02:40,610
related to that and he believes that the

00:02:38,840 --> 00:02:43,040
product should be domain-driven meaning

00:02:40,610 --> 00:02:44,560
that the product should speak your

00:02:43,040 --> 00:02:47,090
domain language not the other way around

00:02:44,560 --> 00:02:49,519
so you don't have to adapt your data to

00:02:47,090 --> 00:02:51,260
fit the search engine you search engine

00:02:49,519 --> 00:02:52,940
should adapt to fit your data he also

00:02:51,260 --> 00:02:56,320
wanted to make it distributed out of the

00:02:52,940 --> 00:02:59,630
box and as easy to set up as possible

00:02:56,320 --> 00:03:01,760
and make it restful to be able to work

00:02:59,630 --> 00:03:03,230
over HTTP and thus interface with any

00:03:01,760 --> 00:03:07,700
number of libraries of products that use

00:03:03,230 --> 00:03:10,519
hdb it is also Hitchhiker's Guide to the

00:03:07,700 --> 00:03:11,959
galaxy I'll show you in a second what it

00:03:10,519 --> 00:03:13,370
is but really there is text of

00:03:11,959 --> 00:03:18,049
hitchhikers guide to galaxy in the

00:03:13,370 --> 00:03:22,430
source code the document model that

00:03:18,049 --> 00:03:25,430
elasticsearch uses is is basically a

00:03:22,430 --> 00:03:27,590
document-oriented search engine with I

00:03:25,430 --> 00:03:31,190
think almost complete asset support so

00:03:27,590 --> 00:03:33,620
if you are indexed a document you can be

00:03:31,190 --> 00:03:35,810
guaranteed that it won't be lost if

00:03:33,620 --> 00:03:37,880
things are configured properly it will

00:03:35,810 --> 00:03:39,410
be consistent so while dr. has been

00:03:37,880 --> 00:03:42,109
indexed it's going to be read partially

00:03:39,410 --> 00:03:47,329
by another process and so on it is JSON

00:03:42,109 --> 00:03:49,010
based as I mentioned and like a lot of

00:03:47,329 --> 00:03:51,920
other products that JSON base has schema

00:03:49,010 --> 00:03:53,060
free so you are completely free to use

00:03:51,920 --> 00:03:54,530
whatever schema you want for your

00:03:53,060 --> 00:03:56,190
documents and even change the schema

00:03:54,530 --> 00:03:59,810
later if you

00:03:56,190 --> 00:04:02,700
see fit if that if you need that option

00:03:59,810 --> 00:04:08,220
the engine underneath elasticsearch is

00:04:02,700 --> 00:04:10,170
based on the scene basically every shard

00:04:08,220 --> 00:04:12,210
which we'll talk about the shard is you

00:04:10,170 --> 00:04:14,310
is a completely separate leucine index

00:04:12,210 --> 00:04:16,290
and because it is leucine based it

00:04:14,310 --> 00:04:19,340
brings with it a lot of the leucine

00:04:16,290 --> 00:04:21,870
settings and options that that it has

00:04:19,340 --> 00:04:23,270
not quite all of my things leucine still

00:04:21,870 --> 00:04:26,520
has some things that he hadn't

00:04:23,270 --> 00:04:29,580
implemented interface for but there's

00:04:26,520 --> 00:04:32,100
definitely a lot of similarities there

00:04:29,580 --> 00:04:35,580
it also has what's called multi-tenancy

00:04:32,100 --> 00:04:38,540
so you can have the same node same

00:04:35,580 --> 00:04:40,740
machine running multiple indexes and

00:04:38,540 --> 00:04:42,630
within each index you have different

00:04:40,740 --> 00:04:44,880
types of documents sort of like a

00:04:42,630 --> 00:04:48,360
database with databases and tables and

00:04:44,880 --> 00:04:49,980
so on but slightly different and like I

00:04:48,360 --> 00:04:52,800
mentioned is distributed other box it

00:04:49,980 --> 00:04:54,450
has very efficient a synchronous

00:04:52,800 --> 00:04:57,150
transport protocol that anodes talk

00:04:54,450 --> 00:04:58,710
between each other and there's automatic

00:04:57,150 --> 00:05:03,200
no discovery and all kinds of cool stuff

00:04:58,710 --> 00:05:09,350
that you will see just a nomenclature

00:05:03,200 --> 00:05:12,510
before we go on so the index is a

00:05:09,350 --> 00:05:16,650
collection of documents of one or more

00:05:12,510 --> 00:05:23,850
types so sort of like a database in the

00:05:16,650 --> 00:05:26,100
in a normal our DBA messes and you can

00:05:23,850 --> 00:05:27,720
you can search each index other for a

00:05:26,100 --> 00:05:30,330
specific type of document or for

00:05:27,720 --> 00:05:33,300
multiple types that it contains and it

00:05:30,330 --> 00:05:34,770
allows you to sort of be very free about

00:05:33,300 --> 00:05:37,320
how you model your data some people use

00:05:34,770 --> 00:05:39,900
just one index and put all their data in

00:05:37,320 --> 00:05:42,600
there some do one index per day their

00:05:39,900 --> 00:05:43,800
indexing log files for example and then

00:05:42,600 --> 00:05:45,270
it's very easy for them sort of manage

00:05:43,800 --> 00:05:49,530
that delete that index create a new one

00:05:45,270 --> 00:05:51,630
and so on and documents are schema

00:05:49,530 --> 00:05:54,360
freaks the only required field or even

00:05:51,630 --> 00:05:56,250
not required is underscore ID which is

00:05:54,360 --> 00:05:57,570
the sort of unique key that you need to

00:05:56,250 --> 00:05:59,160
provide for the document if you don't

00:05:57,570 --> 00:06:01,320
provide it will be auto-generated for

00:05:59,160 --> 00:06:03,870
you so you'd only need to supply that

00:06:01,320 --> 00:06:05,400
and then the node of cars is a machine

00:06:03,870 --> 00:06:08,280
that's running an instance of elastic

00:06:05,400 --> 00:06:09,750
search and providing the indexing

00:06:08,280 --> 00:06:12,370
research capabilities

00:06:09,750 --> 00:06:14,650
so three easy steps to search success

00:06:12,370 --> 00:06:17,440
right what we basically need to do is

00:06:14,650 --> 00:06:19,570
step one is indexed stuff and because

00:06:17,440 --> 00:06:24,310
it's in it has an HTTP protocol

00:06:19,570 --> 00:06:26,290
everybody can see this good okay we can

00:06:24,310 --> 00:06:28,090
use good all regular curl to interact

00:06:26,290 --> 00:06:31,600
with from command line even which is how

00:06:28,090 --> 00:06:33,580
I like to test stuff so to index the

00:06:31,600 --> 00:06:35,980
document and say we're writing a local

00:06:33,580 --> 00:06:39,040
host pork 9200 is its default port that

00:06:35,980 --> 00:06:41,080
it runs on we just say curl and I

00:06:39,040 --> 00:06:43,540
explicitly say that that it's a post

00:06:41,080 --> 00:06:45,640
request here but if you supply the data

00:06:43,540 --> 00:06:47,470
as request body it Carol kind of assumes

00:06:45,640 --> 00:06:52,720
that supposed and they just give it a

00:06:47,470 --> 00:06:54,760
JSON document in this case we're 12

00:06:52,720 --> 00:06:57,190
index let's say a list of speakers for

00:06:54,760 --> 00:06:58,630
the conference so flash conf is the name

00:06:57,190 --> 00:07:02,500
of my index that I'm putting stuff into

00:06:58,630 --> 00:07:05,860
and / speaker after that is the type of

00:07:02,500 --> 00:07:07,330
the of this document it's a document a

00:07:05,860 --> 00:07:10,660
speaker document that's in the conf

00:07:07,330 --> 00:07:14,050
index and flash one is the ID the unique

00:07:10,660 --> 00:07:16,690
ideas talked about so we just index this

00:07:14,050 --> 00:07:18,580
document and what we get back is another

00:07:16,690 --> 00:07:21,130
JSON document that describes the

00:07:18,580 --> 00:07:23,440
response of elastic search in this case

00:07:21,130 --> 00:07:25,980
it says okay is true which means

00:07:23,440 --> 00:07:29,800
everything went fine and it also returns

00:07:25,980 --> 00:07:32,200
what index Ladakh and went into what the

00:07:29,800 --> 00:07:35,950
type of the document was any ID that you

00:07:32,200 --> 00:07:38,280
provided serve the confirmation second

00:07:35,950 --> 00:07:40,600
step that we want to do is search and

00:07:38,280 --> 00:07:43,540
using Chrome again for that we're

00:07:40,600 --> 00:07:46,360
basically say curl localhost 9200 which

00:07:43,540 --> 00:07:49,030
index which document types of / calm /

00:07:46,360 --> 00:07:52,870
speaker and then we give it an action

00:07:49,030 --> 00:07:54,880
which is underscore search and in this

00:07:52,870 --> 00:07:56,800
case we're just putting the query in the

00:07:54,880 --> 00:07:59,020
straight in the URL it is a query string

00:07:56,800 --> 00:08:02,950
so we want to search for beer welcomes

00:07:59,020 --> 00:08:04,210
back is the response also JSON document

00:08:02,950 --> 00:08:07,750
and we'll sort of go through some of the

00:08:04,210 --> 00:08:11,740
fields to show what they are so it'll

00:08:07,750 --> 00:08:13,360
tell us the total number of hits in this

00:08:11,740 --> 00:08:17,440
case it's just one we just created this

00:08:13,360 --> 00:08:20,200
index and is there is only one document

00:08:17,440 --> 00:08:22,390
in it this field will be different if

00:08:20,200 --> 00:08:23,380
you for example do some sort of paging

00:08:22,390 --> 00:08:25,810
if you say

00:08:23,380 --> 00:08:27,100
limit 2 20 documents when this comes

00:08:25,810 --> 00:08:28,750
back it will actually show how many

00:08:27,100 --> 00:08:30,010
total documents match so you don't need

00:08:28,750 --> 00:08:33,490
to do another query to find that out

00:08:30,010 --> 00:08:35,650
that's returned automatically there's

00:08:33,490 --> 00:08:38,020
the index word document came from and

00:08:35,650 --> 00:08:40,840
this is important because you can search

00:08:38,020 --> 00:08:44,169
across indices as you will see and the

00:08:40,840 --> 00:08:48,790
type of the document the ID of course

00:08:44,169 --> 00:08:50,530
and then the hit score which if you want

00:08:48,790 --> 00:08:53,800
to use that for whatever application in

00:08:50,530 --> 00:08:55,360
new clients you can do so and it also

00:08:53,800 --> 00:08:57,280
gives you back the original source that

00:08:55,360 --> 00:08:58,830
you stored which can be handy if you

00:08:57,280 --> 00:09:02,080
don't need to go back to another data

00:08:58,830 --> 00:09:03,250
source tour to retrieve what this

00:09:02,080 --> 00:09:05,320
document was about and so on you can

00:09:03,250 --> 00:09:09,610
actually basically just use these fields

00:09:05,320 --> 00:09:10,960
directly out of the response and another

00:09:09,610 --> 00:09:13,300
interesting thing is also tells you the

00:09:10,960 --> 00:09:15,280
execution time in milliseconds so this

00:09:13,300 --> 00:09:17,500
is 3 millisecond which is you know for

00:09:15,280 --> 00:09:20,110
one document is pretty pretty fast but

00:09:17,500 --> 00:09:23,050
it you as you'll see it's fast across

00:09:20,110 --> 00:09:24,570
millions and millions of documents if

00:09:23,050 --> 00:09:28,780
their service profit that's up to you

00:09:24,570 --> 00:09:32,800
how you use elasticsearch in your quest

00:09:28,780 --> 00:09:39,160
to conquer the world everybody with me

00:09:32,800 --> 00:09:43,180
so far okay so I like doing demos during

00:09:39,160 --> 00:09:45,580
a presentation so in this case we'll

00:09:43,180 --> 00:09:48,970
just go back to my terminal is this big

00:09:45,580 --> 00:09:50,500
enough for people or and I tried

00:09:48,970 --> 00:09:52,150
not to put stuff on the bottom here I

00:09:50,500 --> 00:09:55,440
limited my terminal cuz I know people

00:09:52,150 --> 00:09:57,700
can see behind the heads necessarily but

00:09:55,440 --> 00:10:02,740
what I have here is I have a virtual

00:09:57,700 --> 00:10:05,620
machine that I'm running with the with

00:10:02,740 --> 00:10:08,470
an elastic search it's a java-based of

00:10:05,620 --> 00:10:10,570
course then I did some sample documents

00:10:08,470 --> 00:10:12,490
so I want to create that exactly that

00:10:10,570 --> 00:10:15,310
index that I talked about the conference

00:10:12,490 --> 00:10:18,010
one with speakers so I have three

00:10:15,310 --> 00:10:20,590
speakers here that's me let's go in

00:10:18,010 --> 00:10:22,450
index me and you know I put some

00:10:20,590 --> 00:10:24,550
different things in there like Twitter

00:10:22,450 --> 00:10:27,370
stuff and height and whatever so would

00:10:24,550 --> 00:10:31,030
you go to a virtual host and we execute

00:10:27,370 --> 00:10:33,400
this and gives us back that document and

00:10:31,030 --> 00:10:35,710
you notice that a them created an index

00:10:33,400 --> 00:10:36,730
because it assumes you want to there's

00:10:35,710 --> 00:10:38,470
nothing

00:10:36,730 --> 00:10:40,690
if it doesn't know about that index but

00:10:38,470 --> 00:10:42,220
it you tell it to indexes documental

00:10:40,690 --> 00:10:44,110
automatically create the index autumn I

00:10:42,220 --> 00:10:48,480
could figure out some other things to me

00:10:44,110 --> 00:10:51,820
just get up and going so let's index

00:10:48,480 --> 00:10:53,529
Derek's record his talk is about X debug

00:10:51,820 --> 00:10:56,949
and he likes you know set of viewers

00:10:53,529 --> 00:10:57,940
like swine and PHP and he is a bit

00:10:56,949 --> 00:11:02,500
taller than me about one centimeter

00:10:57,940 --> 00:11:05,680
taller he's a tall guy William decks

00:11:02,500 --> 00:11:07,420
that as well then in he gave me to talk

00:11:05,680 --> 00:11:11,470
about 0 mq which is the awesome talk by

00:11:07,420 --> 00:11:13,870
the way i think he likes beer too and i

00:11:11,470 --> 00:11:16,899
think he likes linguistics right okay

00:11:13,870 --> 00:11:18,339
good guess I don't know how tall you are

00:11:16,899 --> 00:11:22,180
i'll just put 175 because you know

00:11:18,339 --> 00:11:25,209
that's who cares this is just

00:11:22,180 --> 00:11:26,709
demonstration and then so i have this

00:11:25,209 --> 00:11:29,920
conference index and i created those

00:11:26,709 --> 00:11:31,630
three records or documents for these

00:11:29,920 --> 00:11:33,550
speakers but i want index the talks as

00:11:31,630 --> 00:11:35,170
well in this case also it's a different

00:11:33,550 --> 00:11:36,490
type of document that's a talk documents

00:11:35,170 --> 00:11:40,060
sort of speaker document but it still

00:11:36,490 --> 00:11:42,699
goes in the same index and the ID is of

00:11:40,060 --> 00:11:45,100
course unique to index type combination

00:11:42,699 --> 00:11:48,459
you can reuse the same ID for this so

00:11:45,100 --> 00:11:57,010
I'm just going to index these three

00:11:48,459 --> 00:11:58,329
talks and to copy this one as well this

00:11:57,010 --> 00:12:02,680
is first time I giving this talk so if

00:11:58,329 --> 00:12:05,740
things go wrong please be gentle ok so

00:12:02,680 --> 00:12:12,069
we index this let's see what our status

00:12:05,740 --> 00:12:13,930
of the index is conf index status pretty

00:12:12,069 --> 00:12:15,100
true want to actually read this JSON so

00:12:13,930 --> 00:12:20,649
it comes back with a whole bunch of

00:12:15,100 --> 00:12:22,750
stuff about our index things like like

00:12:20,649 --> 00:12:26,079
here's the well highlighting doesn't

00:12:22,750 --> 00:12:28,120
really work here but you'll see that it

00:12:26,079 --> 00:12:32,410
has a bunch of shards a number of

00:12:28,120 --> 00:12:33,760
documents that are in the index max doc

00:12:32,410 --> 00:12:36,370
is equal to nominate arcs because I

00:12:33,760 --> 00:12:41,230
haven't deleted any and it only has one

00:12:36,370 --> 00:12:42,970
shard here by default which is fine so

00:12:41,230 --> 00:12:47,660
now we have these documents let's do

00:12:42,970 --> 00:12:50,180
some searches so in wow this is

00:12:47,660 --> 00:12:52,310
completely horrible so there is the

00:12:50,180 --> 00:13:01,100
first request let's just search for

00:12:52,310 --> 00:13:02,780
Derek so we would came back and it did

00:13:01,100 --> 00:13:04,310
find Derek and you notice we didn't say

00:13:02,780 --> 00:13:07,280
what field to search on at all we just

00:13:04,310 --> 00:13:08,750
gave it a career string and what it does

00:13:07,280 --> 00:13:10,910
by default is that when you give it a

00:13:08,750 --> 00:13:13,760
document it puts all the like Ted feels

00:13:10,910 --> 00:13:15,590
that it knows about into another field

00:13:13,760 --> 00:13:17,030
called underscore all and that's what if

00:13:15,590 --> 00:13:18,200
you use this to search against by

00:13:17,030 --> 00:13:21,260
default so you don't have to even

00:13:18,200 --> 00:13:23,120
specify which field let's search for

00:13:21,260 --> 00:13:27,800
photography which is actually in the

00:13:23,120 --> 00:13:30,320
tags rather than in the name or anything

00:13:27,800 --> 00:13:35,900
else so here you see went through and

00:13:30,320 --> 00:13:38,900
found two records for Derek and Amy

00:13:35,900 --> 00:13:41,360
because we both like photography you can

00:13:38,900 --> 00:13:43,280
use and operator you can say photography

00:13:41,360 --> 00:13:45,050
and beer as any good search engine

00:13:43,280 --> 00:13:47,660
should let you do well in that case that

00:13:45,050 --> 00:13:51,470
will find me so you can see that works

00:13:47,660 --> 00:13:53,570
fine but if you want to specify a field

00:13:51,470 --> 00:13:59,000
to search against you can do it with the

00:13:53,570 --> 00:14:01,040
syntax it says a name which is the name

00:13:59,000 --> 00:14:05,090
of the field colin and the what you

00:14:01,040 --> 00:14:10,160
searching for so if we go into that boom

00:14:05,090 --> 00:14:12,490
okay found in now you notice that we

00:14:10,160 --> 00:14:16,160
were executing all these against the

00:14:12,490 --> 00:14:18,290
slash calm / seeker so in conf index and

00:14:16,160 --> 00:14:20,090
speakers now let's search for another

00:14:18,290 --> 00:14:22,250
type so we're going to search for talks

00:14:20,090 --> 00:14:26,060
now when a search for talks that have

00:14:22,250 --> 00:14:27,920
PHP in a description okay so give us

00:14:26,060 --> 00:14:30,230
back and so 0 and Q is the answer

00:14:27,920 --> 00:14:32,450
there's something about PHP there and

00:14:30,230 --> 00:14:35,870
the other one has PP is the very first

00:14:32,450 --> 00:14:38,450
word okay good enough but well you can

00:14:35,870 --> 00:14:40,280
actually do is search across types if

00:14:38,450 --> 00:14:41,930
you look here we're doing speaker Tama

00:14:40,280 --> 00:14:45,050
talk which means we're going to search

00:14:41,930 --> 00:14:49,430
for both document types and see which

00:14:45,050 --> 00:14:52,100
ones that contain PHP so once we do that

00:14:49,430 --> 00:14:55,190
if you scroll up that will say hits

00:14:52,100 --> 00:14:57,290
three and the first hit is actually it

00:14:55,190 --> 00:15:00,430
says type speaker because Derek had PHP

00:14:57,290 --> 00:15:04,210
and his tags and the other two

00:15:00,430 --> 00:15:06,700
have the have the peace be in a

00:15:04,210 --> 00:15:08,580
description of course we can also limit

00:15:06,700 --> 00:15:12,660
the fields that are returned if we say

00:15:08,580 --> 00:15:15,220
we just won the name and the likes and I

00:15:12,660 --> 00:15:17,050
intentionally named the field so that

00:15:15,220 --> 00:15:23,830
name is common between the talk and the

00:15:17,050 --> 00:15:27,700
speaker so if we do that then it just

00:15:23,830 --> 00:15:29,950
returns the name and the likes and as

00:15:27,700 --> 00:15:31,930
you see the field which is not present

00:15:29,950 --> 00:15:34,270
if it's not present dr has just returned

00:15:31,930 --> 00:15:36,370
there's no like for the talks for

00:15:34,270 --> 00:15:38,680
example it says the name of the talk but

00:15:36,370 --> 00:15:43,959
we don't have any likes for obviously

00:15:38,680 --> 00:15:47,470
for a talk type so there's just a quick

00:15:43,959 --> 00:15:51,910
intro into index and searching so let's

00:15:47,470 --> 00:15:54,820
go back to the slides now the big part

00:15:51,910 --> 00:16:00,160
of elastic search as I mentioned is

00:15:54,820 --> 00:16:01,029
distributed model and it gives you a

00:16:00,160 --> 00:16:02,500
couple of things it gives you

00:16:01,029 --> 00:16:03,700
performance because you can distribute

00:16:02,500 --> 00:16:07,330
your indexing and you're searching

00:16:03,700 --> 00:16:11,380
across the nodes and also gives you

00:16:07,330 --> 00:16:12,910
resiliency or high availability if its

00:16:11,380 --> 00:16:17,310
design in such a way that if one node

00:16:12,910 --> 00:16:21,450
fails the other nodes will automatically

00:16:17,310 --> 00:16:25,660
serve the cup the load and you can add

00:16:21,450 --> 00:16:27,250
documents on the fly and you don't need

00:16:25,660 --> 00:16:29,589
to worry about which shards go where

00:16:27,250 --> 00:16:34,959
which which replicas it'll rebalance

00:16:29,589 --> 00:16:37,330
thing because transparently so what is a

00:16:34,959 --> 00:16:42,820
shard a shard is a portion of the

00:16:37,330 --> 00:16:44,589
document space each one is separate

00:16:42,820 --> 00:16:47,440
leucine index as I mentioned before and

00:16:44,589 --> 00:16:53,140
you can have many / index settings you

00:16:47,440 --> 00:16:55,029
can tune certain indices to be optimized

00:16:53,140 --> 00:16:57,880
for writing and others for reading and

00:16:55,029 --> 00:17:00,870
any number of other things and the

00:16:57,880 --> 00:17:05,069
documents are chartered by the ID values

00:17:00,870 --> 00:17:11,079
since those are never change that's fine

00:17:05,069 --> 00:17:12,339
and when you ask elasticsearch to index

00:17:11,079 --> 00:17:12,920
the document it figure out which hardly

00:17:12,339 --> 00:17:18,920
should go to

00:17:12,920 --> 00:17:21,920
you sort of behind the scenes but if you

00:17:18,920 --> 00:17:22,940
do want a certain group of documents to

00:17:21,920 --> 00:17:25,700
end up on the same node

00:17:22,940 --> 00:17:28,880
deterministically you can provide

00:17:25,700 --> 00:17:31,280
another key which says well basically

00:17:28,880 --> 00:17:34,160
keep them keep all of these documents on

00:17:31,280 --> 00:17:35,960
this one node in case you're indexing I

00:17:34,160 --> 00:17:37,730
certain collection of documents together

00:17:35,960 --> 00:17:38,810
which will be a little better for

00:17:37,730 --> 00:17:40,310
performance because it doesn't need to

00:17:38,810 --> 00:17:45,070
go and fetch them from the other node

00:17:40,310 --> 00:17:49,970
and and aggregate the results together

00:17:45,070 --> 00:17:53,450
it also has zeroconf discovery both in

00:17:49,970 --> 00:17:57,350
the cloud and our normal servers it uses

00:17:53,450 --> 00:18:00,500
a multicast and unicast discovery of

00:17:57,350 --> 00:18:03,380
ip-based discovery via the zen module

00:18:00,500 --> 00:18:07,270
so-called so on your own network you can

00:18:03,380 --> 00:18:09,680
just bring up another node and it will

00:18:07,270 --> 00:18:12,320
if it's needed within the same IP range

00:18:09,680 --> 00:18:14,030
or IP sub sub metal figure out that it's

00:18:12,320 --> 00:18:16,760
running or in the cloud which is

00:18:14,030 --> 00:18:20,000
currently of ec2 only it will use the

00:18:16,760 --> 00:18:22,190
ec2 API to see that a new node has

00:18:20,000 --> 00:18:23,270
joined the cluster and it'll

00:18:22,190 --> 00:18:31,460
automatically start distributing

00:18:23,270 --> 00:18:34,280
indexing and search operations to it in

00:18:31,460 --> 00:18:39,860
in any clustering you have multiple

00:18:34,280 --> 00:18:43,370
clusters on your on your network there

00:18:39,860 --> 00:18:45,920
is a master node which the only sort of

00:18:43,370 --> 00:18:47,870
difference between a normal noted master

00:18:45,920 --> 00:18:50,660
node is that master node is responsible

00:18:47,870 --> 00:18:53,720
to maintain the cluster state so that it

00:18:50,660 --> 00:18:55,430
knows which shards are which node as

00:18:53,720 --> 00:18:59,150
primary shards which has the copies of

00:18:55,430 --> 00:19:00,920
those shards and which nodes are in the

00:18:59,150 --> 00:19:03,950
cluster if a new node joins the cluster

00:19:00,920 --> 00:19:08,300
it will let other nodes know about the

00:19:03,950 --> 00:19:10,370
new node and it also resigns the Sharks

00:19:08,300 --> 00:19:13,190
between nodes if the nodes leave or join

00:19:10,370 --> 00:19:14,900
the cluster now you can issue requests

00:19:13,190 --> 00:19:17,030
to any node in the cluster will be

00:19:14,900 --> 00:19:20,840
automatically routed each each one can

00:19:17,030 --> 00:19:24,290
basically serve as the is as the primary

00:19:20,840 --> 00:19:26,540
point of serving a request and the query

00:19:24,290 --> 00:19:30,530
is handled by this Kattegat mechanism

00:19:26,540 --> 00:19:32,330
so if if you issued a query and it has

00:19:30,530 --> 00:19:34,790
like four shards it needs to look for in

00:19:32,330 --> 00:19:38,360
the document it will ask the other nodes

00:19:34,790 --> 00:19:40,400
to find that finally document in their

00:19:38,360 --> 00:19:44,660
shards that are responsible for get the

00:19:40,400 --> 00:19:46,550
results back rescore them if it needs to

00:19:44,660 --> 00:19:52,040
and then the return of the results to

00:19:46,550 --> 00:19:54,470
you now each shard can have one or more

00:19:52,040 --> 00:20:01,340
replicas and this is good for both

00:19:54,470 --> 00:20:04,130
performance and for resiliency unlike

00:20:01,340 --> 00:20:05,960
number of shards / index the number of

00:20:04,130 --> 00:20:07,490
replicas can be updated after you create

00:20:05,960 --> 00:20:10,310
the index so you can create index with

00:20:07,490 --> 00:20:12,020
zero replicas which in the elastic

00:20:10,310 --> 00:20:17,060
search term knowledge means one because

00:20:12,020 --> 00:20:18,770
there's always a primary shard and you

00:20:17,060 --> 00:20:20,630
can index a bunch of data into it and

00:20:18,770 --> 00:20:22,340
then you can update a say okay I want

00:20:20,630 --> 00:20:24,800
two replicas for it now and it will just

00:20:22,340 --> 00:20:25,940
pick up multiple nodes will create the

00:20:24,800 --> 00:20:29,240
replicas on the other nodes

00:20:25,940 --> 00:20:30,500
automatically for if you want to index a

00:20:29,240 --> 00:20:32,720
bunch of documents without creating

00:20:30,500 --> 00:20:34,490
replicas right away that can be done and

00:20:32,720 --> 00:20:36,230
the replicas of course can be used for

00:20:34,490 --> 00:20:37,910
querying in parallel because each one is

00:20:36,230 --> 00:20:42,230
you remember as a separate server that

00:20:37,910 --> 00:20:48,590
knows how to handle the request so how

00:20:42,230 --> 00:20:53,990
does this chart allocation work so

00:20:48,590 --> 00:20:58,370
suppose you start with a single node and

00:20:53,990 --> 00:21:01,580
you say put use put to create an index

00:20:58,370 --> 00:21:03,260
as a HTTP verb put / person and then you

00:21:01,580 --> 00:21:05,750
give it the index settings that you want

00:21:03,260 --> 00:21:10,060
this index to have so in this case we

00:21:05,750 --> 00:21:12,560
want this index to have two shards and

00:21:10,060 --> 00:21:15,830
one replica which actually is too great

00:21:12,560 --> 00:21:18,830
so it'll go ahead and create those two

00:21:15,830 --> 00:21:20,150
shards on the node I color them

00:21:18,830 --> 00:21:24,290
differently just so we can distinguish

00:21:20,150 --> 00:21:27,470
them better now we start the second node

00:21:24,290 --> 00:21:29,270
and what will happen is that the first

00:21:27,470 --> 00:21:31,040
node will detect that the it's the

00:21:29,270 --> 00:21:32,630
master node but it's the only one detect

00:21:31,040 --> 00:21:36,960
that the other one joined in the cluster

00:21:32,630 --> 00:21:40,289
and it will copy the

00:21:36,960 --> 00:21:43,620
the replicas when you created the first

00:21:40,289 --> 00:21:45,600
node both of those replicas for each

00:21:43,620 --> 00:21:47,610
shard war on the first node and when the

00:21:45,600 --> 00:21:51,840
second one joins the cluster it migrates

00:21:47,610 --> 00:21:54,450
those replicas shards to it now if you

00:21:51,840 --> 00:21:56,760
start two more nodes what's going to

00:21:54,450 --> 00:21:59,220
happen is that the master is going to

00:21:56,760 --> 00:22:00,450
have to reassign the shards because

00:21:59,220 --> 00:22:02,490
there are two available nodes and we

00:22:00,450 --> 00:22:07,440
have two shards times two replicas

00:22:02,490 --> 00:22:11,669
there's four different charge so what

00:22:07,440 --> 00:22:13,950
it's going to do is take so this note is

00:22:11,669 --> 00:22:15,990
going to have shard one primary this is

00:22:13,950 --> 00:22:17,460
short two primary this is charred one

00:22:15,990 --> 00:22:21,179
replica of charred one this is a replica

00:22:17,460 --> 00:22:22,740
of chard too so now even if we add new

00:22:21,179 --> 00:22:25,350
machines to the network it's not going

00:22:22,740 --> 00:22:30,149
to do anything because it already sort

00:22:25,350 --> 00:22:31,529
of redistributed all shards but any of

00:22:30,149 --> 00:22:34,260
these machines you can query for data

00:22:31,529 --> 00:22:37,580
and it will know how to do it so let's

00:22:34,260 --> 00:22:40,529
index some data if you say put person

00:22:37,580 --> 00:22:43,380
infotype and then document one it's

00:22:40,529 --> 00:22:48,330
going to hash to chart1 for example and

00:22:43,380 --> 00:22:50,130
then when you as long as it has two

00:22:48,330 --> 00:22:53,130
shard one is going to be replicated to

00:22:50,130 --> 00:22:55,380
the other node so right away you have a

00:22:53,130 --> 00:22:57,480
copy of the data they can use for

00:22:55,380 --> 00:22:59,370
querying or if the node one goes down

00:22:57,480 --> 00:23:05,159
then that chart is still available note

00:22:59,370 --> 00:23:10,649
3 and say index second document Hatcher

00:23:05,159 --> 00:23:12,570
short two and replicated to note for now

00:23:10,649 --> 00:23:16,890
when we issue a query let's say we just

00:23:12,570 --> 00:23:18,390
ask no one for that we say get / person

00:23:16,890 --> 00:23:22,529
underscore search and I just want to

00:23:18,390 --> 00:23:24,630
search for named Thomas let's say what

00:23:22,529 --> 00:23:26,039
the node one is going to do is that

00:23:24,630 --> 00:23:28,500
knows is there two shards that knows

00:23:26,039 --> 00:23:31,710
which nodes are responsible for those

00:23:28,500 --> 00:23:33,539
shards so it's going to query the shard

00:23:31,710 --> 00:23:37,080
that it owns and then the shard that no

00:23:33,539 --> 00:23:39,000
two owns collect all the all the dog all

00:23:37,080 --> 00:23:41,340
the hits of document hits from those

00:23:39,000 --> 00:23:44,100
merge them and then return them back to

00:23:41,340 --> 00:23:46,880
you and any of these nodes can do the

00:23:44,100 --> 00:23:46,880
same operation

00:23:50,190 --> 00:23:54,130
you can I guess you can think of

00:23:52,720 --> 00:23:56,500
elastics church as a transactional

00:23:54,130 --> 00:24:00,700
system because as I mentioned it has per

00:23:56,500 --> 00:24:02,440
document consistency if you can it

00:24:00,700 --> 00:24:05,140
treats the documents as a whole you

00:24:02,440 --> 00:24:07,990
can't go and update just one field in a

00:24:05,140 --> 00:24:12,310
document need to supply the complete

00:24:07,990 --> 00:24:14,500
JSON and but you don't need to do any

00:24:12,310 --> 00:24:16,450
sort of like commit or flush as soon as

00:24:14,500 --> 00:24:18,310
you induce a document it'll be handle

00:24:16,450 --> 00:24:20,230
automatically there's a right behind

00:24:18,310 --> 00:24:26,530
transaction log that it keeps in case of

00:24:20,230 --> 00:24:28,660
crashes and there's a periodic refresh

00:24:26,530 --> 00:24:30,310
by default I think it's one second so

00:24:28,660 --> 00:24:33,670
you don't need to achieve an index

00:24:30,310 --> 00:24:34,870
refresh if you index something within

00:24:33,670 --> 00:24:38,140
what second will be available for

00:24:34,870 --> 00:24:40,690
searches and you can also control right

00:24:38,140 --> 00:24:42,970
consistency if you went to lorenzos talk

00:24:40,690 --> 00:24:45,160
he mentioned that number of right

00:24:42,970 --> 00:24:49,180
replicas and how that's important for

00:24:45,160 --> 00:24:50,860
consistency you can pass a separate path

00:24:49,180 --> 00:24:55,120
of parameter during indexing that says

00:24:50,860 --> 00:24:58,540
well I only care about one or I want to

00:24:55,120 --> 00:25:00,820
quorum or all basic the success is

00:24:58,540 --> 00:25:07,810
dependent on how many replicas you want

00:25:00,820 --> 00:25:09,610
the document to go to like I said

00:25:07,810 --> 00:25:11,860
there's a one-second refresh rate by

00:25:09,610 --> 00:25:13,570
default but there's also a refresh API

00:25:11,860 --> 00:25:15,160
in case you want to control that

00:25:13,570 --> 00:25:16,810
manually you want to index some

00:25:15,160 --> 00:25:21,970
documents and an issue a refresh and

00:25:16,810 --> 00:25:24,780
have it available for search one thing

00:25:21,970 --> 00:25:27,550
to understand is that the index data

00:25:24,780 --> 00:25:31,600
that it maintains our is considered

00:25:27,550 --> 00:25:34,690
transient you can store it in a local

00:25:31,600 --> 00:25:39,430
file system or in jvm heap or in the

00:25:34,690 --> 00:25:44,920
memory or file system memory combination

00:25:39,430 --> 00:25:47,440
but if you restart that node that data

00:25:44,920 --> 00:25:49,660
will be gone so if you want persistent

00:25:47,440 --> 00:25:55,900
storage it requires what elasticsearch

00:25:49,660 --> 00:25:58,810
calls a gateway now this gateway is used

00:25:55,900 --> 00:26:00,490
to store the cluster metadata so

00:25:58,810 --> 00:26:00,909
basically which shards aware with the

00:26:00,490 --> 00:26:03,129
names

00:26:00,909 --> 00:26:07,389
of indices our index settings and so on

00:26:03,129 --> 00:26:10,389
and the actual index data itself it uses

00:26:07,389 --> 00:26:15,389
an asynchronous translate based right

00:26:10,389 --> 00:26:17,799
strategy so for performance reasons and

00:26:15,389 --> 00:26:19,479
the Gateway allows you to do full

00:26:17,799 --> 00:26:21,609
recovery if something goes wrong in your

00:26:19,479 --> 00:26:24,099
cluster crashes and then you need to do

00:26:21,609 --> 00:26:26,799
full restart it can recover the actual

00:26:24,099 --> 00:26:28,359
index data from Gateway and the

00:26:26,799 --> 00:26:30,789
supported gateways which depending on

00:26:28,359 --> 00:26:34,570
your needs can be you can choose one or

00:26:30,789 --> 00:26:35,529
the other are a local is the default in

00:26:34,570 --> 00:26:39,239
the new version of the lacs this

00:26:35,529 --> 00:26:42,190
elasticsearch where it uses the nodes

00:26:39,239 --> 00:26:44,739
local index data to recover from rather

00:26:42,190 --> 00:26:46,659
than fetching from some other source in

00:26:44,739 --> 00:26:48,070
that case your index has to be stored on

00:26:46,659 --> 00:26:51,460
disk it can be stolen memory because

00:26:48,070 --> 00:26:54,429
that's volatile obviously or you can use

00:26:51,460 --> 00:26:57,519
a shared file system such as NFS or you

00:26:54,429 --> 00:27:01,629
know whatever else you can you want to

00:26:57,519 --> 00:27:08,019
use also supports Hadoop or Hadoop file

00:27:01,629 --> 00:27:11,499
system actually and s3 amazon s3 so you

00:27:08,019 --> 00:27:13,210
can keep your index data you set set it

00:27:11,499 --> 00:27:16,840
the gateway to s3 and it will Duke your

00:27:13,210 --> 00:27:26,049
periodic snapshots to to it by the eight

00:27:16,840 --> 00:27:28,269
s3 API which is pretty cheap actually so

00:27:26,049 --> 00:27:31,419
mapping is another important concept and

00:27:28,269 --> 00:27:34,269
this is basically your description of

00:27:31,419 --> 00:27:36,909
your schema not in a sense that it's

00:27:34,269 --> 00:27:38,590
rigid but it describes the document

00:27:36,909 --> 00:27:40,840
structure and types to the search engine

00:27:38,590 --> 00:27:44,139
so that can index index different fields

00:27:40,840 --> 00:27:47,470
in different ways or you know to give it

00:27:44,139 --> 00:27:49,090
different boost levels and so on by

00:27:47,470 --> 00:27:50,470
default you don't need provided mapping

00:27:49,090 --> 00:27:52,599
like you're so many examples we just

00:27:50,470 --> 00:27:54,609
index a document and elastic search will

00:27:52,599 --> 00:27:56,470
up like magically figure out well I see

00:27:54,609 --> 00:28:00,340
a string so I probably shoot index it as

00:27:56,470 --> 00:28:02,259
a as this type and do a full text search

00:28:00,340 --> 00:28:03,940
in it okay this is a number so I should

00:28:02,259 --> 00:28:05,950
do a different index so I can provide

00:28:03,940 --> 00:28:10,269
numeric range searches for example and

00:28:05,950 --> 00:28:12,820
so on you can provide explicit mapping

00:28:10,269 --> 00:28:14,380
if you want to customize some of those

00:28:12,820 --> 00:28:19,000
defaults and

00:28:14,380 --> 00:28:21,460
generally a good idea and if you provide

00:28:19,000 --> 00:28:25,180
a mapping or you know use a default one

00:28:21,460 --> 00:28:26,590
if you later try to update if the

00:28:25,180 --> 00:28:28,690
American already exists and you want to

00:28:26,590 --> 00:28:30,700
like add a field that's fine it'll just

00:28:28,690 --> 00:28:33,040
modify the mapping to edit field but if

00:28:30,700 --> 00:28:34,630
you want to change type or do some other

00:28:33,040 --> 00:28:35,650
things you may run into merge conflicts

00:28:34,630 --> 00:28:37,750
and there are a couple of ways of

00:28:35,650 --> 00:28:41,200
resolving those that the documentation

00:28:37,750 --> 00:28:42,910
describes and the mapping has some

00:28:41,200 --> 00:28:45,880
imported meta fields one is that

00:28:42,910 --> 00:28:48,190
underscore source which your saw when

00:28:45,880 --> 00:28:50,920
you do a search it returns back the

00:28:48,190 --> 00:28:52,990
source of the original document and it's

00:28:50,920 --> 00:28:54,700
optional you may say don't store the

00:28:52,990 --> 00:28:57,160
source when indexing the document all I

00:28:54,700 --> 00:28:58,870
want is you know ID maybe a couple of

00:28:57,160 --> 00:29:03,670
fields I don't I don't care about the

00:28:58,870 --> 00:29:05,650
full document the other one is own the

00:29:03,670 --> 00:29:08,200
source by the way can be you can able

00:29:05,650 --> 00:29:10,210
setting that uses lzw compression so you

00:29:08,200 --> 00:29:12,790
kind of save on the in the index space

00:29:10,210 --> 00:29:15,690
that way under school all is that

00:29:12,790 --> 00:29:18,070
synthesize field where it takes all the

00:29:15,690 --> 00:29:19,630
all the all the fields in a document and

00:29:18,070 --> 00:29:23,500
merges them it basically into one lets

00:29:19,630 --> 00:29:26,260
you do things like searching across

00:29:23,500 --> 00:29:28,390
fields and it also respects different

00:29:26,260 --> 00:29:30,040
fuels boost levels so let's say one

00:29:28,390 --> 00:29:33,760
field is twice as important as the other

00:29:30,040 --> 00:29:36,280
it'll handle that properly and there's

00:29:33,760 --> 00:29:41,200
also among others is the underscore

00:29:36,280 --> 00:29:42,850
boost so that is basically indicates a

00:29:41,200 --> 00:29:44,200
field in the actual document which

00:29:42,850 --> 00:29:46,570
provides the boost level so you can have

00:29:44,200 --> 00:29:48,490
per document boost that says okay this

00:29:46,570 --> 00:29:52,210
document is very important this one's

00:29:48,490 --> 00:29:56,320
not so much and you don't have to do it

00:29:52,210 --> 00:29:58,810
at cook it at in the query itself or in

00:29:56,320 --> 00:30:03,610
the indexing I mean you can just have it

00:29:58,810 --> 00:30:07,540
in your database or in the in the

00:30:03,610 --> 00:30:09,520
document the types that the you can use

00:30:07,540 --> 00:30:13,540
for the mappings are pretty standard you

00:30:09,520 --> 00:30:15,190
have integer long string boolean there's

00:30:13,540 --> 00:30:17,380
also null but there are a couple of more

00:30:15,190 --> 00:30:22,180
complex ones like array native support

00:30:17,380 --> 00:30:24,820
for arrays and objects and for a raise

00:30:22,180 --> 00:30:26,440
you didn't need to say it's an array if

00:30:24,820 --> 00:30:27,929
you just you can just indicate the type

00:30:26,440 --> 00:30:30,539
of that the array contains

00:30:27,929 --> 00:30:31,830
it's a array of strings like tags you

00:30:30,539 --> 00:30:33,210
can just say it's type string it will

00:30:31,830 --> 00:30:36,240
automate the figure out an array and let

00:30:33,210 --> 00:30:38,789
you do searches on that and object is

00:30:36,240 --> 00:30:42,899
good for nested of JSON objects so you

00:30:38,789 --> 00:30:44,220
have a you know like if you have a

00:30:42,899 --> 00:30:47,869
person record you can have a name

00:30:44,220 --> 00:30:50,700
splendid to first and last fields and

00:30:47,869 --> 00:30:54,509
map those separately if you need to so

00:30:50,700 --> 00:30:56,999
here's an example mapping using the

00:30:54,509 --> 00:30:58,980
document that we the the person document

00:30:56,999 --> 00:31:06,360
that we saw so we have user title tags

00:30:58,980 --> 00:31:08,490
post date and priority and here's how

00:31:06,360 --> 00:31:12,029
you describe the mapping by saying it's

00:31:08,490 --> 00:31:14,399
for the post type of document I know

00:31:12,029 --> 00:31:16,169
this is a low low but hopefully you can

00:31:14,399 --> 00:31:17,940
look at this slightly later I'll just

00:31:16,169 --> 00:31:19,980
quickly say what they are and then the

00:31:17,940 --> 00:31:25,619
properties which is why we're describing

00:31:19,980 --> 00:31:28,019
is we're saying user is type string and

00:31:25,619 --> 00:31:29,429
but we don't want to analyze it what I

00:31:28,019 --> 00:31:31,350
want to do full-text searches in it we

00:31:29,429 --> 00:31:33,749
just want to serve to use it as a whole

00:31:31,350 --> 00:31:37,399
as a keyboard and I think I'm a stuff

00:31:33,749 --> 00:31:40,499
that should be D indented one level

00:31:37,399 --> 00:31:44,909
message is type string and we want to

00:31:40,499 --> 00:31:47,850
boost it fifty percent so that it

00:31:44,909 --> 00:31:49,559
results if it matches on message that

00:31:47,850 --> 00:31:53,129
will have higher score the score for the

00:31:49,559 --> 00:31:54,389
dogma be higher tags is just type string

00:31:53,129 --> 00:31:56,700
even though it's an array it'll

00:31:54,389 --> 00:31:58,649
automatically get it out and we say we

00:31:56,700 --> 00:32:01,889
don't want to include it in all in the

00:31:58,649 --> 00:32:06,230
underscore all field post date is type

00:32:01,889 --> 00:32:09,480
date and you can do custom date format

00:32:06,230 --> 00:32:13,259
with a java-based sort of date

00:32:09,480 --> 00:32:16,679
formatting but let's say we don't want

00:32:13,259 --> 00:32:19,590
to store this in the index so if we

00:32:16,679 --> 00:32:21,990
don't have an underscore all field and

00:32:19,590 --> 00:32:23,610
we say store know if the that field

00:32:21,990 --> 00:32:25,379
won't come back at all is only used for

00:32:23,610 --> 00:32:27,450
indexing it's not going to be returned

00:32:25,379 --> 00:32:29,509
as part of the result unless the

00:32:27,450 --> 00:32:31,769
priority is just type integer so

00:32:29,509 --> 00:32:33,929
mappings are so a very flexible way to

00:32:31,769 --> 00:32:39,600
describe your indexing and querying

00:32:33,929 --> 00:32:42,210
needs this is slightly

00:32:39,600 --> 00:32:44,250
different but sort of feeds into the

00:32:42,210 --> 00:32:46,169
mapping is there's a concept of

00:32:44,250 --> 00:32:50,160
analyzers in elastic search which is how

00:32:46,169 --> 00:32:51,510
it breaks down the text and the

00:32:50,160 --> 00:32:54,870
documents and how it normalizes the

00:32:51,510 --> 00:32:58,770
fields during indexing and also during

00:32:54,870 --> 00:33:02,370
query time and now analyzer is basically

00:32:58,770 --> 00:33:07,799
a token Iser that knows how to tokenize

00:33:02,370 --> 00:33:10,500
a field and zero more token filters to

00:33:07,799 --> 00:33:12,120
transform that in some way so there's a

00:33:10,500 --> 00:33:15,000
standard analyzer that is applied to

00:33:12,120 --> 00:33:17,580
sort of every field like you know title

00:33:15,000 --> 00:33:20,880
description whatever and it's a standard

00:33:17,580 --> 00:33:22,980
tokenizer which has a couple of its you

00:33:20,880 --> 00:33:25,320
know settings then Stan our token filter

00:33:22,980 --> 00:33:28,880
and a lower case and a stop token filter

00:33:25,320 --> 00:33:31,860
so by default it'll lower case all the

00:33:28,880 --> 00:33:34,110
texts on indexing and during query times

00:33:31,860 --> 00:33:36,900
so you can don't have to care about case

00:33:34,110 --> 00:33:39,120
and I'll also the stop token filled will

00:33:36,900 --> 00:33:41,659
filter out things like you know articles

00:33:39,120 --> 00:33:45,140
and prepositions and so on automatically

00:33:41,659 --> 00:33:48,450
but you can customize this if you want

00:33:45,140 --> 00:33:51,030
you can customize tokenizer xand filters

00:33:48,450 --> 00:33:53,549
and do a number of things like well my

00:33:51,030 --> 00:33:56,250
next word length is you know 20 I don't

00:33:53,549 --> 00:33:59,520
want to worry about that or provide

00:33:56,250 --> 00:34:01,830
custom list of stop words and number of

00:33:59,520 --> 00:34:05,100
things one thing that I found useful to

00:34:01,830 --> 00:34:07,289
customize is both a ski folding and

00:34:05,100 --> 00:34:08,280
stemming so ask you folding it for

00:34:07,289 --> 00:34:11,730
example if you're using European

00:34:08,280 --> 00:34:14,190
languages you want to care about xn see

00:34:11,730 --> 00:34:17,280
what sort of want to fold those into a

00:34:14,190 --> 00:34:20,129
ski letters so here here's how you

00:34:17,280 --> 00:34:21,990
customize an index this is in the llamo

00:34:20,129 --> 00:34:25,649
format that's what I use it for config

00:34:21,990 --> 00:34:27,720
file index analysis analyzer and then

00:34:25,649 --> 00:34:29,970
the bold one you I just call the new

00:34:27,720 --> 00:34:33,510
line for European languages I have a

00:34:29,970 --> 00:34:35,550
custom analyzer I still have a standard

00:34:33,510 --> 00:34:37,560
tokenizer and then it just append a

00:34:35,550 --> 00:34:38,940
couple more filters here and these two

00:34:37,560 --> 00:34:40,800
the standard ones of the lower case and

00:34:38,940 --> 00:34:44,760
stuff i say i want to do SQ folding and

00:34:40,800 --> 00:34:46,560
porter standing to stand word so that if

00:34:44,760 --> 00:34:49,169
i search for fish should also find

00:34:46,560 --> 00:34:51,450
fishing and things like that and the new

00:34:49,169 --> 00:34:53,010
release of elastic search that actually

00:34:51,450 --> 00:34:55,440
supports snowball stammer also

00:34:53,010 --> 00:34:58,350
which is a higher quality than porter

00:34:55,440 --> 00:35:00,450
stammer and then in your mapping you

00:34:58,350 --> 00:35:02,520
just say type string and give it the

00:35:00,450 --> 00:35:05,280
analyzer and this analyzer will be used

00:35:02,520 --> 00:35:08,070
during indexing and to analyze the query

00:35:05,280 --> 00:35:09,960
at the query time you can specify

00:35:08,070 --> 00:35:12,630
separate analyzers for both if you want

00:35:09,960 --> 00:35:19,130
by by default this is sort of most

00:35:12,630 --> 00:35:19,130
common case everybody good so far ya

00:35:19,790 --> 00:35:26,850
know you can't put multiple analyzers on

00:35:23,460 --> 00:35:28,590
this for the same field but you can

00:35:26,850 --> 00:35:30,240
sometimes combined properties different

00:35:28,590 --> 00:35:34,920
analyzers into the same if you want to

00:35:30,240 --> 00:35:37,980
mess with the filters and so on sort of

00:35:34,920 --> 00:35:39,150
the API I'm not going to go into all of

00:35:37,980 --> 00:35:41,910
it i'm just going to sort of run through

00:35:39,150 --> 00:35:43,380
it because it's fairly extensive but

00:35:41,910 --> 00:35:45,450
sort of some conventions is you can you

00:35:43,380 --> 00:35:48,540
you can append preeti equals true to any

00:35:45,450 --> 00:35:50,280
URL and it will give you back prettified

00:35:48,540 --> 00:35:54,390
json with indented so that human

00:35:50,280 --> 00:35:56,310
readable homeless boolean values Falls 0

00:35:54,390 --> 00:35:59,160
or off is false everything else is true

00:35:56,310 --> 00:36:01,500
and if you want JSON p support just

00:35:59,160 --> 00:36:04,230
provide a callback argument so that's

00:36:01,500 --> 00:36:08,760
all built-in then a general API

00:36:04,230 --> 00:36:10,950
structure is you have host port than an

00:36:08,760 --> 00:36:12,690
optional index optional type because you

00:36:10,950 --> 00:36:17,630
can search across multiple indices in

00:36:12,690 --> 00:36:20,280
multiple time the types as you saw and

00:36:17,630 --> 00:36:21,960
then you have an action which is like

00:36:20,280 --> 00:36:24,380
underscore search you know in a couple

00:36:21,960 --> 00:36:29,160
other things or an ID for indexing

00:36:24,380 --> 00:36:31,170
documents so as an example you can do

00:36:29,160 --> 00:36:34,260
status underscore status and that'll

00:36:31,170 --> 00:36:37,050
give you the status of your of your

00:36:34,260 --> 00:36:38,820
cluster how many index as it has and so

00:36:37,050 --> 00:36:42,660
on or you can get a status for a

00:36:38,820 --> 00:36:45,270
specific index / index / action you know

00:36:42,660 --> 00:36:46,440
posting already saw gee if you do get on

00:36:45,270 --> 00:36:52,020
the same you'll just get back that

00:36:46,440 --> 00:36:55,500
document you just indexed you can do

00:36:52,020 --> 00:36:58,110
index type surgery there's another type

00:36:55,500 --> 00:37:00,930
or you can search across types as we saw

00:36:58,110 --> 00:37:03,690
giving you can search across indexes

00:37:00,930 --> 00:37:05,730
awesome you just do same convention of

00:37:03,690 --> 00:37:06,480
separated by comma which is pretty

00:37:05,730 --> 00:37:09,330
useful in certain

00:37:06,480 --> 00:37:10,920
cases or if you just do underscore

00:37:09,330 --> 00:37:15,570
social search all the indices all the

00:37:10,920 --> 00:37:18,210
types there's also underscore cluster

00:37:15,570 --> 00:37:19,770
API to get some metadata about the

00:37:18,210 --> 00:37:22,530
cluster you can ask it for cluster

00:37:19,770 --> 00:37:24,960
health which will tell you red yellow

00:37:22,530 --> 00:37:26,820
green and green means like all the

00:37:24,960 --> 00:37:31,380
shards have been allocated properly both

00:37:26,820 --> 00:37:33,450
primary and secondary yellow is just

00:37:31,380 --> 00:37:34,800
basically couldn't allocate some shards

00:37:33,450 --> 00:37:38,280
but you know they're still running but

00:37:34,800 --> 00:37:44,040
it's just not going to be resilient in

00:37:38,280 --> 00:37:45,840
case of failure some node stats and know

00:37:44,040 --> 00:37:47,910
that node info if you want for things

00:37:45,840 --> 00:37:50,040
like you know how much memory card no

00:37:47,910 --> 00:37:53,550
currently has with the cpu load is and

00:37:50,040 --> 00:37:56,070
all kinds of stuff like that the core

00:37:53,550 --> 00:37:57,540
API allows you to do a bunch of things

00:37:56,070 --> 00:37:59,340
so index where it is so that's when they

00:37:57,540 --> 00:38:01,770
send document there's also bulk indexing

00:37:59,340 --> 00:38:04,040
option so you can feed it a chunk of

00:38:01,770 --> 00:38:07,290
commands and say index index index index

00:38:04,040 --> 00:38:08,970
delete create whatever and feed it to

00:38:07,290 --> 00:38:10,410
like like you know 200 dawkins at a time

00:38:08,970 --> 00:38:12,090
and that's way more efficient for

00:38:10,410 --> 00:38:16,800
indexing a bunch of things than just do

00:38:12,090 --> 00:38:20,220
it in one by one delete pretty obvious

00:38:16,800 --> 00:38:21,780
changes delete a document and you can

00:38:20,220 --> 00:38:24,300
also delete by query if you want to lead

00:38:21,780 --> 00:38:26,040
a certain sub range of documents

00:38:24,300 --> 00:38:27,510
whatever queries you can use for

00:38:26,040 --> 00:38:30,450
searching can use for deletion which is

00:38:27,510 --> 00:38:33,210
pretty cool yet is just retrieving one

00:38:30,450 --> 00:38:37,380
specific document as we saw count is

00:38:33,210 --> 00:38:38,670
useful when you just want to get a count

00:38:37,380 --> 00:38:40,740
of the documents that match without

00:38:38,670 --> 00:38:42,150
doing any retrieval because in the case

00:38:40,740 --> 00:38:44,580
of retrieval would actually sometimes

00:38:42,150 --> 00:38:46,320
need to go disc and retrieve like the

00:38:44,580 --> 00:38:48,390
source that you give it gave it maybe

00:38:46,320 --> 00:38:50,820
parse it and so on just one the count

00:38:48,390 --> 00:38:54,480
use count and then a pretty extensive

00:38:50,820 --> 00:38:56,040
search api obviously arm and sort of the

00:38:54,480 --> 00:38:58,950
portions of the search that are useful

00:38:56,040 --> 00:39:00,690
most of the time i think it's like query

00:38:58,950 --> 00:39:03,030
which is the actual query you your

00:39:00,690 --> 00:39:07,620
you're searching for the from size for

00:39:03,030 --> 00:39:09,750
paging through the result set sorting on

00:39:07,620 --> 00:39:11,580
one field or more fields if necessary

00:39:09,750 --> 00:39:13,560
highlighting which is pretty cool if you

00:39:11,580 --> 00:39:16,230
want to highlight the what matched in

00:39:13,560 --> 00:39:18,360
the search results retrieve selected

00:39:16,230 --> 00:39:20,000
fields like you saw we only retrieve

00:39:18,360 --> 00:39:23,260
name and likes and so on and

00:39:20,000 --> 00:39:25,610
a few other things that are really cool

00:39:23,260 --> 00:39:27,770
then there's API for working with the

00:39:25,610 --> 00:39:29,270
indices so you can obviously create an

00:39:27,770 --> 00:39:31,730
index with certain parameters you can

00:39:29,270 --> 00:39:33,020
delete an index you can also open the

00:39:31,730 --> 00:39:34,160
closing index so if you know for example

00:39:33,020 --> 00:39:36,260
that you're not going to be working with

00:39:34,160 --> 00:39:38,000
a certain index for a while but you

00:39:36,260 --> 00:39:41,120
still want to keep it you know around

00:39:38,000 --> 00:39:42,410
you can close it and it won't you

00:39:41,120 --> 00:39:44,330
obviously want be able to query unit but

00:39:42,410 --> 00:39:47,210
also consume way less memory and just no

00:39:44,330 --> 00:39:48,530
processing time at all when you do when

00:39:47,210 --> 00:39:50,360
you are ready to work with it you can

00:39:48,530 --> 00:39:52,460
open it and it will do the same thing of

00:39:50,360 --> 00:39:53,720
you like that happens given cluster it

00:39:52,460 --> 00:39:56,240
restarted you know retrieved from

00:39:53,720 --> 00:39:58,940
gateway whatever end and bring it into a

00:39:56,240 --> 00:40:03,050
ready state you can get put delete the

00:39:58,940 --> 00:40:04,580
mappings for the your documents and if

00:40:03,050 --> 00:40:07,370
you delete the mapping I actually wipe

00:40:04,580 --> 00:40:08,780
out those documents by the way they

00:40:07,370 --> 00:40:11,960
refresh I already mentioned if you want

00:40:08,780 --> 00:40:13,250
to manually refresh the index to make

00:40:11,960 --> 00:40:16,790
the documents available for search

00:40:13,250 --> 00:40:18,470
there's also optimized when you delete

00:40:16,790 --> 00:40:22,070
if you do a lot of document deletions

00:40:18,470 --> 00:40:23,480
and so on there may be some you know

00:40:22,070 --> 00:40:25,910
spaces left by them so if you want

00:40:23,480 --> 00:40:29,540
optimize the index storage that's one

00:40:25,910 --> 00:40:31,570
way to do query why is this query I

00:40:29,540 --> 00:40:35,240
think that's a mistake on the slide

00:40:31,570 --> 00:40:37,340
snapshot by default it snap shouts to

00:40:35,240 --> 00:40:39,560
gateway to the persistent storage every

00:40:37,340 --> 00:40:41,540
five seconds or something like that or

00:40:39,560 --> 00:40:44,060
you can ask it manually to do a snapshot

00:40:41,540 --> 00:40:45,800
if you want to do it like you know from

00:40:44,060 --> 00:40:47,990
a cron job or something if that's what

00:40:45,800 --> 00:40:50,800
you need update settings is how you

00:40:47,990 --> 00:40:54,260
change the number of replicas / index

00:40:50,800 --> 00:40:56,840
there's also analyze which you can it

00:40:54,260 --> 00:40:59,810
tells you how it breaks down the users

00:40:56,840 --> 00:41:01,280
the analyzers to break down the the text

00:40:59,810 --> 00:41:08,870
which I can actually show you it's

00:41:01,280 --> 00:41:11,120
pretty cool so here I have a I have a

00:41:08,870 --> 00:41:13,670
text going fishing and I'm going to use

00:41:11,120 --> 00:41:18,170
that you lying analyzer that I showed an

00:41:13,670 --> 00:41:21,080
example of so if you do that it comes

00:41:18,170 --> 00:41:22,880
back with says two tokens and it token

00:41:21,080 --> 00:41:23,960
as a go and fish could added standing

00:41:22,880 --> 00:41:26,120
and lower casing and all that other

00:41:23,960 --> 00:41:27,530
stuff and it has some other you know

00:41:26,120 --> 00:41:30,680
tight what type of token it is with

00:41:27,530 --> 00:41:32,390
position it's in and so on so you can I

00:41:30,680 --> 00:41:33,650
this you can use to debug your analyzer

00:41:32,390 --> 00:41:36,520
and see how they working

00:41:33,650 --> 00:41:40,599
we can do different ones we can just use

00:41:36,520 --> 00:41:43,069
say white space then i will just

00:41:40,599 --> 00:41:49,789
tokenize on white space and not do all

00:41:43,069 --> 00:41:54,710
that other stuff did there's also

00:41:49,789 --> 00:41:57,740
cluster API oh yeah status already

00:41:54,710 --> 00:42:00,020
talked about that so there's a cluster

00:41:57,740 --> 00:42:02,809
API for health state you can shut down

00:42:00,020 --> 00:42:06,470
nodes programmatically by a API if you

00:42:02,809 --> 00:42:08,960
need to and there's a pretty extensive

00:42:06,470 --> 00:42:11,660
query domain language that you use in

00:42:08,960 --> 00:42:15,410
the query itself so term terms is just

00:42:11,660 --> 00:42:17,779
for searching for like keyboards or list

00:42:15,410 --> 00:42:19,760
of keywords range is for obviously range

00:42:17,779 --> 00:42:21,680
of numbers prefix is searching for

00:42:19,760 --> 00:42:24,470
prefix words that start with certain

00:42:21,680 --> 00:42:27,440
prefix there's a boolean query that you

00:42:24,470 --> 00:42:28,910
can say okay this must appear this must

00:42:27,440 --> 00:42:30,549
not appear and it has you can use

00:42:28,910 --> 00:42:33,289
whatever sub queries you want in that

00:42:30,549 --> 00:42:36,319
fuzzy using Levenstein algorithm you can

00:42:33,289 --> 00:42:39,020
do sort of fuzzy searching to find

00:42:36,319 --> 00:42:43,789
approximately matching words wildcard

00:42:39,020 --> 00:42:45,710
obviously and then this query string

00:42:43,789 --> 00:42:49,849
which is what it does by default when

00:42:45,710 --> 00:42:51,650
you say Q equals in the URL and it has a

00:42:49,849 --> 00:42:54,020
bunch of its own settings like default

00:42:51,650 --> 00:42:55,670
operator which is all but by default but

00:42:54,020 --> 00:42:57,319
you can set it to and so if you give it

00:42:55,670 --> 00:42:59,240
two words over use and operate on them

00:42:57,319 --> 00:43:02,299
automatically you can change the

00:42:59,240 --> 00:43:03,680
analyzer to do at query time phrase slop

00:43:02,299 --> 00:43:05,510
is pretty cool if you search for phrases

00:43:03,680 --> 00:43:07,010
well usually means you know like if you

00:43:05,510 --> 00:43:08,359
search for two word phrase they have to

00:43:07,010 --> 00:43:11,089
be next to each other if you do phrase

00:43:08,359 --> 00:43:13,069
that phrase flop to one you can put you

00:43:11,089 --> 00:43:15,470
know even if they're separated by one

00:43:13,069 --> 00:43:19,270
word will find it and a bunch of others

00:43:15,470 --> 00:43:19,270
and just show you quickly

00:43:20,690 --> 00:43:32,100
so SI prefix and here i'm starting to

00:43:28,500 --> 00:43:35,430
send queries as json documents and the

00:43:32,100 --> 00:43:39,750
pose body because it allows for a lot

00:43:35,430 --> 00:43:41,280
more query types than the URL so here we

00:43:39,750 --> 00:43:44,100
want to find everything that started

00:43:41,280 --> 00:43:48,930
with pH and obviously photography and

00:43:44,100 --> 00:43:50,400
PHP matched then let's say we searching

00:43:48,930 --> 00:43:51,420
searching for linguistics but we don't

00:43:50,400 --> 00:43:55,110
know how to spell it with say

00:43:51,420 --> 00:43:56,400
linguistics and we're doing a fuzzy

00:43:55,110 --> 00:43:57,810
search with the prefix lengths to

00:43:56,400 --> 00:43:58,830
meaning that the first two letters have

00:43:57,810 --> 00:44:01,860
to match still because otherwise

00:43:58,830 --> 00:44:03,930
Levenstein goes kind of crazy oops found

00:44:01,860 --> 00:44:06,390
Dean because he likes linguistics

00:44:03,930 --> 00:44:09,660
apparently here's a bullying query we're

00:44:06,390 --> 00:44:11,700
saying must term like scouting and must

00:44:09,660 --> 00:44:16,650
not range height less than 1 88 so I

00:44:11,700 --> 00:44:21,320
want to find tall coders and that's

00:44:16,650 --> 00:44:24,210
Derek he's the only one that's 180 805

00:44:21,320 --> 00:44:26,070
there's the query string 1 and it's sort

00:44:24,210 --> 00:44:28,530
of weird syntax as you say query then

00:44:26,070 --> 00:44:31,800
query string that a query field in that

00:44:28,530 --> 00:44:34,980
and there we do things like find PHP but

00:44:31,800 --> 00:44:36,210
the matches PHP but not proxy and we

00:44:34,980 --> 00:44:39,450
only want to search in the description

00:44:36,210 --> 00:44:44,340
and so that works and finds the zeromq

00:44:39,450 --> 00:44:47,490
talk doesn't mention proxy and there's

00:44:44,340 --> 00:44:49,619
free slop so when I search for a PHP

00:44:47,490 --> 00:44:51,480
extension but in case something else

00:44:49,619 --> 00:44:53,310
comes between those that's fine and

00:44:51,480 --> 00:44:57,480
that's true because it says PHP gmq

00:44:53,310 --> 00:45:04,020
extension highlighting which i already

00:44:57,480 --> 00:45:05,700
mentioned so I searched for varnish in

00:45:04,020 --> 00:45:06,960
the query and I want to highlight the

00:45:05,700 --> 00:45:08,850
name and description fields of that

00:45:06,960 --> 00:45:10,920
appears there so when it comes back it

00:45:08,850 --> 00:45:12,630
breaks them down to these fragments

00:45:10,920 --> 00:45:14,820
which you probably saw from other search

00:45:12,630 --> 00:45:16,920
engines but it puts am / am around

00:45:14,820 --> 00:45:19,470
varnish here and here and you can

00:45:16,920 --> 00:45:26,670
customize what those tags are a number

00:45:19,470 --> 00:45:28,050
of other things so filters are they

00:45:26,670 --> 00:45:30,869
share some similar features with queries

00:45:28,050 --> 00:45:32,430
there are term filters range filters and

00:45:30,869 --> 00:45:34,610
so on but why would use a filter versus

00:45:32,430 --> 00:45:36,950
a query well

00:45:34,610 --> 00:45:40,260
their way faster than queries and

00:45:36,950 --> 00:45:41,940
they're cached unlike cruise sort of

00:45:40,260 --> 00:45:45,390
depends on the filter how the cash is

00:45:41,940 --> 00:45:48,390
used but if you run different queries

00:45:45,390 --> 00:45:50,720
against the same filter it will reuse

00:45:48,390 --> 00:45:52,770
that cash so it's even faster than and

00:45:50,720 --> 00:45:55,290
the reason is faster doesn't need to do

00:45:52,770 --> 00:45:56,820
any scoring on the filters and most of

00:45:55,290 --> 00:46:00,530
the time you don't need scoring from

00:45:56,820 --> 00:46:02,880
things like numeric range query

00:46:00,530 --> 00:46:04,650
according for numeric range and so on or

00:46:02,880 --> 00:46:06,660
for where that something exists or

00:46:04,650 --> 00:46:08,610
missing and some of the useful funk ones

00:46:06,660 --> 00:46:11,760
are listed here so you can for example

00:46:08,610 --> 00:46:16,140
search for some sort of text and then

00:46:11,760 --> 00:46:17,520
filter only like find we could have

00:46:16,140 --> 00:46:23,070
rewritten that bullying query as

00:46:17,520 --> 00:46:24,570
searching for let's say some sort of

00:46:23,070 --> 00:46:26,610
text and then filtering by the height

00:46:24,570 --> 00:46:30,030
instead of doing that bullying must must

00:46:26,610 --> 00:46:32,130
not which would be faster facets give

00:46:30,030 --> 00:46:35,610
you aggregated data based on a search

00:46:32,130 --> 00:46:38,850
request things like histograms and

00:46:35,610 --> 00:46:42,750
statistical and terms like for example

00:46:38,850 --> 00:46:44,910
if we wanted to find what are the most

00:46:42,750 --> 00:46:46,080
common terms are we can do something

00:46:44,910 --> 00:46:49,380
like this where we say match all

00:46:46,080 --> 00:46:52,080
documents and then facet is the is on

00:46:49,380 --> 00:46:55,230
the fueled likes to tell us what the

00:46:52,080 --> 00:46:59,700
most frequent terms are and if you do

00:46:55,230 --> 00:47:01,140
that OOP it's not the right one it goes

00:46:59,700 --> 00:47:03,480
back with something like that where it

00:47:01,140 --> 00:47:06,660
has a likes facet in addition to search

00:47:03,480 --> 00:47:08,250
results which are up here by the way

00:47:06,660 --> 00:47:10,170
because we say match all we returned all

00:47:08,250 --> 00:47:11,550
documents there but the most common one

00:47:10,170 --> 00:47:13,380
is coding and the next won't come as

00:47:11,550 --> 00:47:17,250
photography and so on so you can sort of

00:47:13,380 --> 00:47:22,250
display those the same the same time or

00:47:17,250 --> 00:47:22,250
we could do oops

00:47:23,260 --> 00:47:30,880
statistical facet on the height and that

00:47:27,560 --> 00:47:33,020
comes back and says min 175 max 188

00:47:30,880 --> 00:47:37,850
variance and standard deviation all that

00:47:33,020 --> 00:47:39,260
stuff you want to so I have 10 minutes

00:47:37,850 --> 00:47:44,060
or maybe nine minutes now it's also

00:47:39,260 --> 00:47:45,950
geosearch you can set the field type

00:47:44,060 --> 00:47:48,020
could be geopoint and then you can do

00:47:45,950 --> 00:47:50,990
filters on geo dis stones if it fits in

00:47:48,020 --> 00:47:56,960
the bounding box or polygon just

00:47:50,990 --> 00:48:00,350
actually really cool see do I have time

00:47:56,960 --> 00:48:03,020
for me to do stuff I was going to show

00:48:00,350 --> 00:48:05,810
you how the how cool it is to have

00:48:03,020 --> 00:48:09,080
totally distributed search engine so I

00:48:05,810 --> 00:48:11,870
have ec2 i have three servers running

00:48:09,080 --> 00:48:14,270
ones the client to are the servers and

00:48:11,870 --> 00:48:17,780
it's really cool to this with ec2 for

00:48:14,270 --> 00:48:22,060
like demos and stuff I'm just going to

00:48:17,780 --> 00:48:24,380
SSH into that and what I have here is I

00:48:22,060 --> 00:48:27,110
suck down 1 million tweets from Twitter

00:48:24,380 --> 00:48:29,960
and index the them certain fields from

00:48:27,110 --> 00:48:37,460
them for searching so right now if I do

00:48:29,960 --> 00:48:38,960
a cluster state oh no no state so I do

00:48:37,460 --> 00:48:40,760
cluster state it's going to say I only

00:48:38,960 --> 00:48:43,220
have one node at the very top of those

00:48:40,760 --> 00:48:47,630
nodes name and it names it's funny names

00:48:43,220 --> 00:48:50,990
two nodes and whatever data is after

00:48:47,630 --> 00:48:52,910
that but I only have one note so all the

00:48:50,990 --> 00:48:55,130
shards I specified for shards for the

00:48:52,910 --> 00:48:56,750
syndics with one replica so basically

00:48:55,130 --> 00:49:03,800
two replicas but since there's only one

00:48:56,750 --> 00:49:06,680
node they're all on the same node and so

00:49:03,800 --> 00:49:09,230
let's do query I wrote this low python

00:49:06,680 --> 00:49:10,910
script sorry not PHP python has this

00:49:09,230 --> 00:49:12,920
multi processing module which makes its

00:49:10,910 --> 00:49:14,930
way easier to like fork out a bunch of

00:49:12,920 --> 00:49:17,930
proxies and then have them do work so I

00:49:14,930 --> 00:49:21,410
have 20 processes and I want to query

00:49:17,930 --> 00:49:29,600
this index million document index for 10

00:49:21,410 --> 00:49:32,840
seconds which oh no oh yeah there it

00:49:29,600 --> 00:49:34,610
goes so it went through and those 20

00:49:32,840 --> 00:49:38,680
workers at about 200 nine or queries per

00:49:34,610 --> 00:49:38,680
second against this index

00:49:38,780 --> 00:49:44,550
well let's say I this is only one note

00:49:41,700 --> 00:49:45,960
I'm going to as the note is actually up

00:49:44,550 --> 00:49:50,250
but I'm going to just start

00:49:45,960 --> 00:49:56,370
elasticsearch on it I specified that the

00:49:50,250 --> 00:49:58,620
data lives in so this configuration file

00:49:56,370 --> 00:50:01,230
says data and data elasticsearch some

00:49:58,620 --> 00:50:03,810
log files there's the cluster name some

00:50:01,230 --> 00:50:06,390
of my face api keys for amazon don't

00:50:03,810 --> 00:50:07,860
write them down please and then the

00:50:06,390 --> 00:50:09,450
discovery so how it's going to discover

00:50:07,860 --> 00:50:11,430
the nodes this is the ec2 type of

00:50:09,450 --> 00:50:14,310
discovery and it's using adb group and

00:50:11,430 --> 00:50:17,900
so on anyway there's nothing in data

00:50:14,310 --> 00:50:20,940
right so I'm going to start up

00:50:17,900 --> 00:50:29,460
elasticsearch here and here I'm going to

00:50:20,940 --> 00:50:37,980
query for cluster health watch will

00:50:29,460 --> 00:50:46,730
co-host cluster health so OOP curl

00:50:37,980 --> 00:50:52,590
Agathe curl now not a local host yes one

00:50:46,730 --> 00:50:54,480
anyway pretty that would help so here's

00:50:52,590 --> 00:50:56,340
the hell that says a CL 0 which means

00:50:54,480 --> 00:50:58,620
they wasn't able to allocate some shards

00:50:56,340 --> 00:51:01,230
there's only one node and some other

00:50:58,620 --> 00:51:05,540
data there so if we start the elastic

00:51:01,230 --> 00:51:05,540
search on the second one says starting

00:51:06,260 --> 00:51:13,680
come back here and pretty soon is it has

00:51:10,500 --> 00:51:15,570
number of nodes to and it starts says

00:51:13,680 --> 00:51:18,450
unassigned shards initializing charge

00:51:15,570 --> 00:51:21,450
and then when it's copied the data over

00:51:18,450 --> 00:51:23,850
its going to say active front how many

00:51:21,450 --> 00:51:26,790
active showers are there's x6 active

00:51:23,850 --> 00:51:29,310
shards now so now we have a replica our

00:51:26,790 --> 00:51:30,810
million dollar index pretty quickly and

00:51:29,310 --> 00:51:34,860
we can search against both and now it's

00:51:30,810 --> 00:51:41,460
we have better reliability and so on so

00:51:34,860 --> 00:51:47,390
I can actually query against both I say

00:51:41,460 --> 00:51:47,390
yes to 99 let's do the same and

00:51:47,760 --> 00:51:51,810
if I had more time I would run a top and

00:51:50,340 --> 00:51:55,830
let you see Lee that it's going to both

00:51:51,810 --> 00:51:57,810
actually its own whoa oh I'm also using

00:51:55,830 --> 00:52:00,000
thrift here so that maybe this would

00:51:57,810 --> 00:52:05,430
happen maybe a bug in the thrift thing

00:52:00,000 --> 00:52:08,010
instead of http but let's go back here

00:52:05,430 --> 00:52:10,680
so the interfaces already mentioned rest

00:52:08,010 --> 00:52:12,540
you there's a memcache d module which

00:52:10,680 --> 00:52:15,090
lets you sort of use memcache d

00:52:12,540 --> 00:52:17,280
semantics for getting and setting data

00:52:15,090 --> 00:52:18,420
and so on there's obviously Java and

00:52:17,280 --> 00:52:20,700
groovy interfaces because it's all

00:52:18,420 --> 00:52:22,140
java-based you can write the draw module

00:52:20,700 --> 00:52:25,590
that's probably higher performance than

00:52:22,140 --> 00:52:27,000
doing a external HTTP clients and then a

00:52:25,590 --> 00:52:29,070
number of language clients why arrest

00:52:27,000 --> 00:52:32,070
from thrift there's one for Python code

00:52:29,070 --> 00:52:34,140
is PHP there are standalone ones and

00:52:32,070 --> 00:52:36,900
that there's a symphony has a module for

00:52:34,140 --> 00:52:39,960
elastic search now Ruby pearl and so on

00:52:36,900 --> 00:52:43,770
flume sync implementation made people

00:52:39,960 --> 00:52:45,780
use flu no flume it's like Facebook

00:52:43,770 --> 00:52:50,130
spread or whatever it's called let's

00:52:45,780 --> 00:52:52,830
spread huh scribe but but like I think

00:52:50,130 --> 00:52:56,250
better just a system to aggregate data

00:52:52,830 --> 00:52:57,900
and collected so this the elastica is

00:52:56,250 --> 00:53:01,800
sort of i think the better of the PHP

00:52:57,900 --> 00:53:03,360
clients api naming is consistent with

00:53:01,800 --> 00:53:06,240
zend framework so if you use that'll

00:53:03,360 --> 00:53:08,070
help you getting standard for new

00:53:06,240 --> 00:53:11,460
filters facets and so on but kind of

00:53:08,070 --> 00:53:14,160
still on the development example is

00:53:11,460 --> 00:53:16,380
pretty pretty easy i don't use then

00:53:14,160 --> 00:53:17,880
framework so and i'm assuming that's

00:53:16,380 --> 00:53:19,860
what the naming conventions are but like

00:53:17,880 --> 00:53:23,640
elastic a client lexical index will

00:53:19,860 --> 00:53:25,740
create index will create document will

00:53:23,640 --> 00:53:28,100
add the document and then we construct a

00:53:25,740 --> 00:53:32,010
query run a query and so on it's a

00:53:28,100 --> 00:53:33,420
pretty easy so one question comes out

00:53:32,010 --> 00:53:34,890
with how do you get your data in elastic

00:53:33,420 --> 00:53:37,770
search because that's usually not your

00:53:34,890 --> 00:53:42,210
primary data store well you either write

00:53:37,770 --> 00:53:44,850
an agent that sits in somewhere and you

00:53:42,210 --> 00:53:46,890
send actions to it saying like index

00:53:44,850 --> 00:53:48,060
this document and so you don't because

00:53:46,890 --> 00:53:49,010
you usually don't want to do the

00:53:48,060 --> 00:53:51,180
synchronous for you it asynchronously

00:53:49,010 --> 00:53:52,890
and you can use gear man or message

00:53:51,180 --> 00:53:55,350
queues like zeromq vet or whatever else

00:53:52,890 --> 00:53:57,300
to write a nation dead will index data

00:53:55,350 --> 00:53:59,220
and or delete data from elastic search

00:53:57,300 --> 00:54:00,870
or it has support for work all rivers

00:53:59,220 --> 00:54:02,809
which is really cool is basically a

00:54:00,870 --> 00:54:05,519
built-in

00:54:02,809 --> 00:54:07,940
way for elasticsearch to suck data from

00:54:05,519 --> 00:54:10,349
somewhere and it has support for CouchDB

00:54:07,940 --> 00:54:13,309
RabbitMQ twitter right now so you can

00:54:10,349 --> 00:54:16,019
basically from command line say curl and

00:54:13,309 --> 00:54:17,880
it is underscore river and you configure

00:54:16,019 --> 00:54:19,440
it for your couchdb and alarm erica

00:54:17,880 --> 00:54:21,960
start syncing data from couch if you

00:54:19,440 --> 00:54:24,420
want or RabbitMQ which lets you use a

00:54:21,960 --> 00:54:29,190
lot of other stuff 10 more features I

00:54:24,420 --> 00:54:31,680
wish I haven't mentioned well let's do a

00:54:29,190 --> 00:54:33,329
couple there's a load balancing nodes so

00:54:31,680 --> 00:54:35,190
there's a setting you can turn on and

00:54:33,329 --> 00:54:37,019
off / note that says store data on it or

00:54:35,190 --> 00:54:39,480
not so you can have nodes that actually

00:54:37,019 --> 00:54:40,980
as routers like load balancers you can

00:54:39,480 --> 00:54:43,109
have one or two notes with like that and

00:54:40,980 --> 00:54:45,859
all the data nodes and the other one

00:54:43,109 --> 00:54:48,539
will just store data and respond to that

00:54:45,859 --> 00:54:50,400
parent-child docs you can say well this

00:54:48,539 --> 00:54:52,799
document this is the parent one for it

00:54:50,400 --> 00:54:55,170
so let's do some sort of hierarchical

00:54:52,799 --> 00:54:56,609
modeling and then you can when you do a

00:54:55,170 --> 00:54:58,349
search and say okay for this document

00:54:56,609 --> 00:54:59,880
give me all the top children or for this

00:54:58,349 --> 00:55:01,920
I'm going to give me its parent so

00:54:59,880 --> 00:55:04,200
automatically sort of return stuff to

00:55:01,920 --> 00:55:06,509
you that way there's a scripting support

00:55:04,200 --> 00:55:11,039
you can do things like do dynamic fuels

00:55:06,509 --> 00:55:14,059
based on other ones you can script your

00:55:11,039 --> 00:55:17,999
scores do a whole number of other things

00:55:14,059 --> 00:55:23,339
I have one minute left who wants to stay

00:55:17,999 --> 00:55:25,319
for two more minutes oh yes it has so

00:55:23,339 --> 00:55:27,809
there's has a plug-in architecture at

00:55:25,319 --> 00:55:28,980
its core and that's how thrift transport

00:55:27,809 --> 00:55:32,249
is improvement is implemented for

00:55:28,980 --> 00:55:34,559
example this is how cloud Amazon Web

00:55:32,249 --> 00:55:37,380
Services is implemented so if you know

00:55:34,559 --> 00:55:39,119
the API for elastic series team to write

00:55:37,380 --> 00:55:41,730
a plug-in and do it a whole number of

00:55:39,119 --> 00:55:45,720
things that that you can probably plug

00:55:41,730 --> 00:55:47,880
into everything percolation is really

00:55:45,720 --> 00:55:49,769
cool sort of inverse T search so usually

00:55:47,880 --> 00:55:50,910
you have a query that you run against

00:55:49,769 --> 00:55:52,920
the documents and it gives you back the

00:55:50,910 --> 00:55:54,809
result in this case you store your

00:55:52,920 --> 00:55:55,950
queries in elasticsearch run a document

00:55:54,809 --> 00:55:58,200
it gives you back which query would

00:55:55,950 --> 00:56:00,839
match it which you can use for a whole

00:55:58,200 --> 00:56:03,029
number of things I think like filters

00:56:00,839 --> 00:56:06,960
like you know doing like email filters

00:56:03,029 --> 00:56:08,339
and bunch of other stuff so here are

00:56:06,960 --> 00:56:11,220
some references for it it's on github

00:56:08,339 --> 00:56:13,640
it's an open source project there is a

00:56:11,220 --> 00:56:15,980
google group for it there

00:56:13,640 --> 00:56:19,609
i misspelled the elastic search on the

00:56:15,980 --> 00:56:21,890
IRC I need to fix that and I'll put the

00:56:19,609 --> 00:56:23,180
slides of this gyro hopefully today

00:56:21,890 --> 00:56:27,289
maybe tomorrow when i have a better a

00:56:23,180 --> 00:56:28,670
Wi-Fi connection and that's it if I if

00:56:27,289 --> 00:56:30,740
you have questions please come find me

00:56:28,670 --> 00:56:33,019
after this and we'll have a more

00:56:30,740 --> 00:56:48,410
informal to or or can we have questions

00:56:33,019 --> 00:56:55,760
now ok let's do questions then yes no by

00:56:48,410 --> 00:56:58,160
elasticsearch I it will consistency in

00:56:55,760 --> 00:57:02,260
what sense like if you if you write if

00:56:58,160 --> 00:57:02,260
you give it a index document will it be

00:57:09,210 --> 00:57:21,180
oh right consistency like if you when

00:57:17,400 --> 00:57:25,020
you store document yeah well when you

00:57:21,180 --> 00:57:27,120
start and you can give it an option

00:57:25,020 --> 00:57:29,370
saying return as soon as a start on one

00:57:27,120 --> 00:57:31,140
replica or make sure that stored on

00:57:29,370 --> 00:57:33,900
quorum which is usually number of nodes

00:57:31,140 --> 00:57:39,210
divided by 2 plus 1 or when all the

00:57:33,900 --> 00:57:41,160
replicas have stored we I work with a

00:57:39,210 --> 00:57:43,710
place where we just implemented a solar

00:57:41,160 --> 00:57:45,900
and now one of the things we found that

00:57:43,710 --> 00:57:48,450
it was sort of one of the difficulties

00:57:45,900 --> 00:57:50,700
was in order to create an index of it's

00:57:48,450 --> 00:57:53,520
a thousand million CDs that were putting

00:57:50,700 --> 00:57:56,250
in there it takes like 45 hours really

00:57:53,520 --> 00:57:58,740
yeah at million documents yeah a

00:57:56,250 --> 00:58:01,110
million-dollar million documents um word

00:57:58,740 --> 00:58:03,390
documents essentially okay how big are

00:58:01,110 --> 00:58:05,070
the document uh well there's Seavey so

00:58:03,390 --> 00:58:06,780
the German ones are ginormous and that

00:58:05,070 --> 00:58:11,640
you know its sister well I can tell you

00:58:06,780 --> 00:58:13,230
that this the Twitter one I so index

00:58:11,640 --> 00:58:14,700
creation is basic costs you nothing is

00:58:13,230 --> 00:58:16,380
just an empty index by when you start

00:58:14,700 --> 00:58:18,330
indexing into it I index the million

00:58:16,380 --> 00:58:23,190
things on that a you see to machine it's

00:58:18,330 --> 00:58:25,260
a large instance on in it was doing

00:58:23,190 --> 00:58:28,860
about three and a half thousand Dawkins

00:58:25,260 --> 00:58:30,240
per second okay I mean I know and they

00:58:28,860 --> 00:58:32,160
they would probably like half a kilobyte

00:58:30,240 --> 00:58:34,110
to kilobyte each but yeah it sounds like

00:58:32,160 --> 00:58:36,030
it's performing a bit better than it

00:58:34,110 --> 00:58:37,800
will distribute it to so you can if you

00:58:36,030 --> 00:58:41,130
have if you've didn't start in such a

00:58:37,800 --> 00:58:43,890
way that you know five shard index and

00:58:41,130 --> 00:58:45,480
you have five machines then it will sign

00:58:43,890 --> 00:58:46,620
a primary chart which machine when it's

00:58:45,480 --> 00:58:47,910
indexing all those missions were

00:58:46,620 --> 00:58:49,800
inducing at once rather than just doing

00:58:47,910 --> 00:58:53,880
and then they'll it looks across to each

00:58:49,800 --> 00:58:56,790
other so yeah excellent um hello don't

00:58:53,880 --> 00:58:58,890
he yeah yep so I just wonder whether had

00:58:56,790 --> 00:59:01,200
the other source Seletar things like

00:58:58,890 --> 00:59:03,030
spelling suggestions and synonyms I

00:59:01,200 --> 00:59:06,200
didn't soon I don't think that's in yet

00:59:03,030 --> 00:59:09,120
but he definitely has plans to add those

00:59:06,200 --> 00:59:11,600
because those are available in solar I

00:59:09,120 --> 00:59:11,600
think so

00:59:13,509 --> 00:59:23,209
anybody else oh one more yeah I had a

00:59:21,109 --> 00:59:26,599
question whether you I had actually

00:59:23,209 --> 00:59:28,249
tried to cilantro know is I saw that in

00:59:26,599 --> 00:59:29,690
your talk and I yeah I went to search

00:59:28,249 --> 00:59:32,089
for aiden is very few references to

00:59:29,690 --> 00:59:33,619
right now it's Britain you know Sandra

00:59:32,089 --> 00:59:36,589
which is the previous version based on

00:59:33,619 --> 00:59:38,749
the scene ok it's quite similar it it

00:59:36,589 --> 00:59:41,390
doesn't have these nice API it's using

00:59:38,749 --> 00:59:44,420
the same maybe is solar but it's back to

00:59:41,390 --> 00:59:46,069
buy a Cassandra plaster yeah so I I have

00:59:44,420 --> 00:59:48,709
a unary cause I don't know huh no okay

00:59:46,069 --> 00:59:51,769
can't compare them thanks I don't use

00:59:48,709 --> 00:59:53,450
Cassandra writer okay I think we are

00:59:51,769 --> 00:59:57,440
done in time unless there's some other

00:59:53,450 --> 00:59:59,979
guy seems okay yes so thank you thanks

00:59:57,440 --> 00:59:59,979

YouTube URL: https://www.youtube.com/watch?v=shHi1eRM1nc


