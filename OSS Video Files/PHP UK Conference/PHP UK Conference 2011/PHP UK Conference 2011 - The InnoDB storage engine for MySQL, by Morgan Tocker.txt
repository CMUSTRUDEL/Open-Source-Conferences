Title: PHP UK Conference 2011 - The InnoDB storage engine for MySQL, by Morgan Tocker
Publication date: 2012-03-15
Playlist: PHP UK Conference 2011
Description: 
	
Captions: 
	00:00:02,870 --> 00:00:09,210
hello okay what are you always working

00:00:06,689 --> 00:00:12,000
it seems that way so welcome everybody

00:00:09,210 --> 00:00:13,710
thank you for coming I'm going to be

00:00:12,000 --> 00:00:15,059
talking a lot about energy via internals

00:00:13,710 --> 00:00:16,920
so I'm skipping some of the

00:00:15,059 --> 00:00:18,839
prerequisites I'm not telling you that

00:00:16,920 --> 00:00:20,880
Moscow has this storage engine concept

00:00:18,839 --> 00:00:23,429
it's almost like a proxy in two

00:00:20,880 --> 00:00:25,079
different ways of storing data and a lot

00:00:23,429 --> 00:00:26,699
of people using my eyes m and they

00:00:25,079 --> 00:00:28,710
shouldn't be they should be using an ODB

00:00:26,699 --> 00:00:30,089
and a lot of its history why we haven't

00:00:28,710 --> 00:00:33,000
been using you know DB we should have

00:00:30,089 --> 00:00:35,489
been and finally why SQL and inner DB

00:00:33,000 --> 00:00:38,430
under the same roof and Oracle it's now

00:00:35,489 --> 00:00:40,980
the default in 5.5 so why should you be

00:00:38,430 --> 00:00:42,840
using it well I think the reason why a

00:00:40,980 --> 00:00:45,000
lot of people think you should be using

00:00:42,840 --> 00:00:46,980
it for the wrong reasons that's the

00:00:45,000 --> 00:00:48,420
funniest thing from my perspective so

00:00:46,980 --> 00:00:50,010
here's my list of why you should be

00:00:48,420 --> 00:00:51,660
using it I wanted to share that with you

00:00:50,010 --> 00:00:54,570
I think one of the best things about

00:00:51,660 --> 00:00:56,429
inner DB is that it's trans actual it's

00:00:54,570 --> 00:00:57,809
acid compliant when it says it does

00:00:56,429 --> 00:00:59,339
something could guarantees that and

00:00:57,809 --> 00:01:00,839
we'll talk a little bit about the

00:00:59,339 --> 00:01:02,460
algorithms in a second and really what

00:01:00,839 --> 00:01:04,019
that means I think you should be using

00:01:02,460 --> 00:01:05,970
inner DB because it scales well and

00:01:04,019 --> 00:01:08,160
modern hardware if using something like

00:01:05,970 --> 00:01:10,740
my eyes M it has a lot of internal

00:01:08,160 --> 00:01:13,950
locking that creates issues when you

00:01:10,740 --> 00:01:15,720
have 16 and 32 core machines and I think

00:01:13,950 --> 00:01:17,640
you should be using you know DB for a

00:01:15,720 --> 00:01:20,820
reason that might be hard to measure a

00:01:17,640 --> 00:01:23,100
lot of what benchmarks these days are

00:01:20,820 --> 00:01:25,200
doing corrupted a little bit by some

00:01:23,100 --> 00:01:27,030
other database movements as the

00:01:25,200 --> 00:01:29,460
measuring peak throughput they're not

00:01:27,030 --> 00:01:32,850
measuring what is one of in ODB's goals

00:01:29,460 --> 00:01:34,680
which is consistent results every query

00:01:32,850 --> 00:01:36,150
gets approximately the same time more or

00:01:34,680 --> 00:01:38,640
less and there's a lot of focus into

00:01:36,150 --> 00:01:40,380
making this work really nicely so that's

00:01:38,640 --> 00:01:41,640
my preface this is why I like you know

00:01:40,380 --> 00:01:44,400
DV and this is why I think you should

00:01:41,640 --> 00:01:47,670
like you know DV what's interesting is

00:01:44,400 --> 00:01:50,580
why should you yes or no use in ODB in

00:01:47,670 --> 00:01:52,770
what I think is common myths and I I

00:01:50,580 --> 00:01:54,810
wouldn't say that only using ODB if you

00:01:52,770 --> 00:01:57,150
knew use foreign keys is one at all I

00:01:54,810 --> 00:01:58,110
actually use in R DV but I often don't

00:01:57,150 --> 00:02:00,840
use foreign keys

00:01:58,110 --> 00:02:03,360
I think inner DV is probably faster at

00:02:00,840 --> 00:02:05,340
reads a lot faster it reads except for

00:02:03,360 --> 00:02:06,840
maybe table scans and index scans and I

00:02:05,340 --> 00:02:09,330
rarely do them on my part action

00:02:06,840 --> 00:02:11,580
database systems so this one is a myth

00:02:09,330 --> 00:02:13,500
as well to say that you know DV doesn't

00:02:11,580 --> 00:02:15,330
scale inner DV got a lot of criticism

00:02:13,500 --> 00:02:16,110
because the interview was earned by

00:02:15,330 --> 00:02:18,030
Oracle

00:02:16,110 --> 00:02:20,790
and MySQL was previously not owned by

00:02:18,030 --> 00:02:22,890
Oracle part of this was truth part of it

00:02:20,790 --> 00:02:26,220
was not and a lot of it is less true

00:02:22,890 --> 00:02:28,110
than it ever was and the reason that I

00:02:26,220 --> 00:02:30,060
have at the end which is why some people

00:02:28,110 --> 00:02:31,440
can't migrate to inner DB is because

00:02:30,060 --> 00:02:33,270
they're using my eyes and full-text

00:02:31,440 --> 00:02:35,550
search you don't want to use my eyes and

00:02:33,270 --> 00:02:37,320
full-text search you want to use some

00:02:35,550 --> 00:02:39,510
other full-text implementation because

00:02:37,320 --> 00:02:41,310
my isin is relevancy ranking and it's

00:02:39,510 --> 00:02:43,590
performance when these indexes confident

00:02:41,310 --> 00:02:46,860
in memory it's just powerful friends

00:02:43,590 --> 00:02:48,750
don't let friends use my eyes and so how

00:02:46,860 --> 00:02:49,950
I'm gonna talk about this I'm gonna talk

00:02:48,750 --> 00:02:52,230
about inner DV and I'm gonna talk about

00:02:49,950 --> 00:02:55,200
a lot of the internals I'm gonna try and

00:02:52,230 --> 00:02:56,940
do it in these points and I confess that

00:02:55,200 --> 00:02:58,830
I often do this in a day and I can spend

00:02:56,940 --> 00:03:01,680
the whole day talking about this and I

00:02:58,830 --> 00:03:03,540
made some trade-offs and I'm doing it

00:03:01,680 --> 00:03:05,060
about 65 slides and I'm gonna have to

00:03:03,540 --> 00:03:08,310
speak really fast to be able to do that

00:03:05,060 --> 00:03:09,810
so I won't have much time for questions

00:03:08,310 --> 00:03:10,709
so what I want to do instead is I want

00:03:09,810 --> 00:03:14,250
you to raise your hands if you have

00:03:10,709 --> 00:03:15,840
questions and I'll try and stop and

00:03:14,250 --> 00:03:17,340
answer them and if I can't then I'll try

00:03:15,840 --> 00:03:18,570
and take them offline so that's my

00:03:17,340 --> 00:03:20,700
strategy that I'm going to go forward

00:03:18,570 --> 00:03:23,160
with so first I want to talk about the

00:03:20,700 --> 00:03:24,900
basic operations of nodb

00:03:23,160 --> 00:03:27,030
and to explain that we have to explain a

00:03:24,900 --> 00:03:28,709
lot about Hardware database systems

00:03:27,030 --> 00:03:29,760
really sit very close to the hardware

00:03:28,709 --> 00:03:31,850
and a lot of things are important to

00:03:29,760 --> 00:03:33,989
understand understand how an OTB works

00:03:31,850 --> 00:03:35,730
so the first thing to explain about

00:03:33,989 --> 00:03:39,030
hardware is that discs are really really

00:03:35,730 --> 00:03:40,650
slow so here I'm grabbing some numbers

00:03:39,030 --> 00:03:42,450
from a presentation by an engineer at

00:03:40,650 --> 00:03:44,700
Google and is showing the relative

00:03:42,450 --> 00:03:46,709
speeds of every component you know in

00:03:44,700 --> 00:03:51,269
your architecture and on the top here

00:03:46,709 --> 00:03:53,070
we've got sort of CPU we can do a CPU

00:03:51,269 --> 00:03:55,950
cycle in less than a billionth of a

00:03:53,070 --> 00:03:57,900
second and then we've got main memory a

00:03:55,950 --> 00:04:00,120
hundred nanoseconds and nanosecond is a

00:03:57,900 --> 00:04:01,739
billionth of a second and we can do

00:04:00,120 --> 00:04:07,080
things like a round-trip within the same

00:04:01,739 --> 00:04:10,380
data center in 500,000 nanoseconds about

00:04:07,080 --> 00:04:12,989
half of a millisecond but what we can't

00:04:10,380 --> 00:04:14,670
do that with any relative speed

00:04:12,989 --> 00:04:16,979
comparing to that is even read from our

00:04:14,670 --> 00:04:18,810
own local disks it's faster to read from

00:04:16,979 --> 00:04:20,160
another node on the network in main

00:04:18,810 --> 00:04:22,740
memory than it is to read from her and

00:04:20,160 --> 00:04:25,830
disk this is really slow this takes

00:04:22,740 --> 00:04:28,800
about 10 milliseconds to be able to do

00:04:25,830 --> 00:04:29,610
an operation and this is like one

00:04:28,800 --> 00:04:32,250
one-hundredth

00:04:29,610 --> 00:04:34,560
of a second big difference from one

00:04:32,250 --> 00:04:37,620
billionth of a second that we're looking

00:04:34,560 --> 00:04:39,389
at for CPUs what's even more interesting

00:04:37,620 --> 00:04:41,819
about this number if I extrapolate from

00:04:39,389 --> 00:04:44,099
what I saw in this presentation and with

00:04:41,819 --> 00:04:45,389
my own understanding of hardware I can

00:04:44,099 --> 00:04:48,300
say that they were talking about cobia

00:04:45,389 --> 00:04:51,180
7200 rpm hard drive that can do 100

00:04:48,300 --> 00:04:53,310
operations per second we go into

00:04:51,180 --> 00:04:55,020
enterprise drives and we talk 15k rpm

00:04:53,310 --> 00:04:58,139
drives it's probably not that much more

00:04:55,020 --> 00:04:59,639
at best it might be double and what's

00:04:58,139 --> 00:05:01,139
also interesting is there's a lot of

00:04:59,639 --> 00:05:03,900
variance in this number they're just

00:05:01,139 --> 00:05:05,460
picking an average number depending on

00:05:03,900 --> 00:05:07,620
what sort of i/o operation you're doing

00:05:05,460 --> 00:05:09,240
it might not be this number there could

00:05:07,620 --> 00:05:12,389
be you know somewhere in between these

00:05:09,240 --> 00:05:14,069
really wide numbers and that very high

00:05:12,389 --> 00:05:16,020
number you might not see all the time

00:05:14,069 --> 00:05:17,550
I'm picking like a slow laptop drive or

00:05:16,020 --> 00:05:19,229
something like that but I'm trying to

00:05:17,550 --> 00:05:22,590
illustrate a point this is a really slow

00:05:19,229 --> 00:05:24,300
so if we look at how operations work

00:05:22,590 --> 00:05:27,210
inside let's start with the operating

00:05:24,300 --> 00:05:29,159
system the operating system when you try

00:05:27,210 --> 00:05:31,349
and read daughter it has caches when you

00:05:29,159 --> 00:05:34,050
try and write data it tries to buffer

00:05:31,349 --> 00:05:37,909
that daughter so here I'm trying to

00:05:34,050 --> 00:05:40,020
write block 9 block 10 block 1 for 200

00:05:37,909 --> 00:05:42,629
think of a buffer is almost like a

00:05:40,020 --> 00:05:44,250
funnel the more time that we spend in

00:05:42,629 --> 00:05:45,509
this buffer the more opportunity that we

00:05:44,250 --> 00:05:48,150
have to do request your ordering and

00:05:45,509 --> 00:05:49,560
merging and as we can do that request

00:05:48,150 --> 00:05:51,000
reordering and merging we get better

00:05:49,560 --> 00:05:53,310
performance to the disk because we were

00:05:51,000 --> 00:05:55,500
sequential i/o if you want to know how

00:05:53,310 --> 00:05:58,529
much better off sequential i/o is I can

00:05:55,500 --> 00:06:01,620
flip back to this chart back here it

00:05:58,529 --> 00:06:04,949
takes 10 milliseconds to be able to read

00:06:01,620 --> 00:06:06,930
the first fight it takes 20 milliseconds

00:06:04,949 --> 00:06:09,389
to be able to read a full megabyte this

00:06:06,930 --> 00:06:11,849
is the performance model of disks huge

00:06:09,389 --> 00:06:13,830
difference between sequential i/o versus

00:06:11,849 --> 00:06:15,479
gradual the operating system has a way

00:06:13,830 --> 00:06:17,279
to get better performance for reads it

00:06:15,479 --> 00:06:19,409
has caching for rights it has offering

00:06:17,279 --> 00:06:21,479
one of the interesting things about just

00:06:19,409 --> 00:06:24,509
writing to an operating system like this

00:06:21,479 --> 00:06:27,029
is that this buffer is lost if we lose

00:06:24,509 --> 00:06:29,159
power so you don't know why my eyes M is

00:06:27,029 --> 00:06:30,779
so fast because it just acts like any

00:06:29,159 --> 00:06:32,520
other dumb program and just writes this

00:06:30,779 --> 00:06:34,770
always write buffer you'll want to know

00:06:32,520 --> 00:06:36,719
why you know DB is slow because in ODB

00:06:34,770 --> 00:06:39,659
ask the operation operating system

00:06:36,719 --> 00:06:41,310
constantly can you empty this buffer can

00:06:39,659 --> 00:06:42,110
you do what's called synching or

00:06:41,310 --> 00:06:43,230
flushing

00:06:42,110 --> 00:06:44,970
this

00:06:43,230 --> 00:06:47,220
is why by default inner TV is much

00:06:44,970 --> 00:06:48,510
slower than my eyes and what's also

00:06:47,220 --> 00:06:50,900
interesting here is that if we use

00:06:48,510 --> 00:06:54,090
hardware like a hardware RAID controller

00:06:50,900 --> 00:06:55,380
it'll have a buffer of its own sitting

00:06:54,090 --> 00:06:58,050
on that rate control and you'll get all

00:06:55,380 --> 00:06:59,520
your performance back it'll do its

00:06:58,050 --> 00:07:01,890
request reordering and merging and

00:06:59,520 --> 00:07:04,560
you'll get comparable performance again

00:07:01,890 --> 00:07:06,390
if you use good Hardware within a TV and

00:07:04,560 --> 00:07:07,650
you also have some settings to be able

00:07:06,390 --> 00:07:09,330
to tune this but I'll get to this in a

00:07:07,650 --> 00:07:11,850
second I have to explain this as a

00:07:09,330 --> 00:07:14,490
prerequisite to be able to explain how

00:07:11,850 --> 00:07:16,890
in ODB's our rhythms work in order B has

00:07:14,490 --> 00:07:18,750
to be durable it has to guarantee as

00:07:16,890 --> 00:07:20,460
part of this promise that makes quote

00:07:18,750 --> 00:07:22,830
acid compliance the data would be safe

00:07:20,460 --> 00:07:26,100
on disk and something like my eyes and

00:07:22,830 --> 00:07:28,280
doesn't make that same promise so let's

00:07:26,100 --> 00:07:32,070
look at the basic operation of energy v

00:07:28,280 --> 00:07:35,460
here we have by default I be data one on

00:07:32,070 --> 00:07:36,720
disk we call it out our tablespace we

00:07:35,460 --> 00:07:40,290
have our buffer pool which is an

00:07:36,720 --> 00:07:42,840
in-memory configuration for caching what

00:07:40,290 --> 00:07:45,060
is on the table space we have a series

00:07:42,840 --> 00:07:47,010
of log files by default two of them

00:07:45,060 --> 00:07:48,960
they're going to be called I below zero

00:07:47,010 --> 00:07:50,220
and I below Quan they're gonna be stored

00:07:48,960 --> 00:07:53,580
in that same common data different

00:07:50,220 --> 00:07:54,810
directory with all of you my SQL data so

00:07:53,580 --> 00:07:56,190
we're into an operation on this system

00:07:54,810 --> 00:07:59,280
we're going to do to start with the

00:07:56,190 --> 00:08:01,620
Select query select staff from city

00:07:59,280 --> 00:08:03,180
where country code equals aus we've got

00:08:01,620 --> 00:08:06,120
a table with all of the cities in the

00:08:03,180 --> 00:08:08,790
world and we're going to look inside the

00:08:06,120 --> 00:08:10,290
buffer pool they're going to say is the

00:08:08,790 --> 00:08:12,990
data that we're looking for there in

00:08:10,290 --> 00:08:14,520
this case my service just started up so

00:08:12,990 --> 00:08:18,000
it's going to load that data from the

00:08:14,520 --> 00:08:20,040
tablespace into the buffer pool and then

00:08:18,000 --> 00:08:22,020
it's going to return results this is

00:08:20,040 --> 00:08:24,420
fairly dumb this is how most caches work

00:08:22,020 --> 00:08:27,810
what we do is we have some in-memory

00:08:24,420 --> 00:08:30,330
version of this same data these are 16 K

00:08:27,810 --> 00:08:32,849
pages they look pretty much the same

00:08:30,330 --> 00:08:37,349
there's no transformation for how they

00:08:32,849 --> 00:08:38,550
look in memory how does an update work

00:08:37,349 --> 00:08:41,040
though this is a little bit more

00:08:38,550 --> 00:08:43,290
interesting we're going to do an update

00:08:41,040 --> 00:08:45,990
on the same daughter we're going to

00:08:43,290 --> 00:08:49,170
update our table here update some of the

00:08:45,990 --> 00:08:52,440
rows we just selected for an update what

00:08:49,170 --> 00:08:55,770
we do is we make a modification in

00:08:52,440 --> 00:08:56,970
memory to the buffer pool resulting in

00:08:55,770 --> 00:08:59,730
in terminology we

00:08:56,970 --> 00:09:02,129
call a dirty page and then we record

00:08:59,730 --> 00:09:05,430
history of that modification being made

00:09:02,129 --> 00:09:07,319
to these Loeb files and then actually

00:09:05,430 --> 00:09:08,759
for you as an application developer you

00:09:07,319 --> 00:09:13,439
get an act back to say that that

00:09:08,759 --> 00:09:15,569
operations been successful this is an

00:09:13,439 --> 00:09:18,870
in-memory copy of this somewhere here

00:09:15,569 --> 00:09:20,129
but it's had a modification made we

00:09:18,870 --> 00:09:23,220
don't have to make that modification

00:09:20,129 --> 00:09:26,519
from here to here yet we delay that

00:09:23,220 --> 00:09:28,110
operation we delay that operation and it

00:09:26,519 --> 00:09:31,439
might be one second or it might be one

00:09:28,110 --> 00:09:32,490
hour inevitably we have to do this but

00:09:31,439 --> 00:09:34,889
it doesn't concern you

00:09:32,490 --> 00:09:38,639
when this dirty page gets written back

00:09:34,889 --> 00:09:40,319
down to the tablespace when it gets

00:09:38,639 --> 00:09:42,540
written back down then this page gets

00:09:40,319 --> 00:09:43,829
marked as clean and then if we have to

00:09:42,540 --> 00:09:46,680
make space in the buffer pool then we

00:09:43,829 --> 00:09:49,500
can but by default you don't have to

00:09:46,680 --> 00:09:53,519
care when that happens you do care

00:09:49,500 --> 00:09:55,860
actually as a performance tuning problem

00:09:53,519 --> 00:09:57,689
but just to start with at the basic

00:09:55,860 --> 00:10:00,029
algorithm this is purely an optimization

00:09:57,689 --> 00:10:02,189
what do you know DVD is doing is it's

00:10:00,029 --> 00:10:05,790
doing lobe file i/o which is just very

00:10:02,189 --> 00:10:07,589
small rights to be able to remember how

00:10:05,790 --> 00:10:11,279
to recovery we had some sort of failure

00:10:07,589 --> 00:10:13,470
and flushing the log making sure that it

00:10:11,279 --> 00:10:16,379
synced down on disk is a huge thing for

00:10:13,470 --> 00:10:18,209
performance the lobe file i/o is cheap

00:10:16,379 --> 00:10:20,189
but it has to happen in the foreground

00:10:18,209 --> 00:10:21,870
so users will be waiting

00:10:20,189 --> 00:10:24,689
that'll be blocking while that's being

00:10:21,870 --> 00:10:26,459
written the i/o that we have to do to do

00:10:24,689 --> 00:10:29,399
those updates right those dirty tip

00:10:26,459 --> 00:10:31,740
pages down to the tablespace now that

00:10:29,399 --> 00:10:33,360
we've introduced time we can do some

00:10:31,740 --> 00:10:33,930
sort of reordering and merging with them

00:10:33,360 --> 00:10:36,000
as well

00:10:33,930 --> 00:10:37,230
so we can get optimization for

00:10:36,000 --> 00:10:39,480
sequential i/o and then we can get

00:10:37,230 --> 00:10:41,370
optimization for sequential error and

00:10:39,480 --> 00:10:44,699
this is the basic algorithm of inner DP

00:10:41,370 --> 00:10:46,680
and I ask is sort of like an open

00:10:44,699 --> 00:10:48,360
question it shouldn't matter that we've

00:10:46,680 --> 00:10:51,120
save enough to recover actually it does

00:10:48,360 --> 00:10:52,769
matter if we have too many pending

00:10:51,120 --> 00:10:54,329
changes we have really slow crash

00:10:52,769 --> 00:10:57,899
recovery that's the main risk that we

00:10:54,329 --> 00:11:00,059
have so we know T V in this algorithm it

00:10:57,899 --> 00:11:02,160
writes to the log files for recovery

00:11:00,059 --> 00:11:03,779
purposes it actually never even reads

00:11:02,160 --> 00:11:08,220
back from the Loeb files unless we had a

00:11:03,779 --> 00:11:10,950
crash there just written to we have some

00:11:08,220 --> 00:11:13,800
in memory lists

00:11:10,950 --> 00:11:16,770
to be able to describe what pending

00:11:13,800 --> 00:11:18,870
dirty pages we have and if we have clean

00:11:16,770 --> 00:11:20,100
pages you know which ones can we free if

00:11:18,870 --> 00:11:22,770
we need to make space that's another

00:11:20,100 --> 00:11:24,630
list and we call that LRU I won't go

00:11:22,770 --> 00:11:27,030
into the specifics of this but it is

00:11:24,630 --> 00:11:29,010
memoryless to be able to avoid having to

00:11:27,030 --> 00:11:32,550
ever read from that log file we just

00:11:29,010 --> 00:11:34,050
write to it and all Logue activities are

00:11:32,550 --> 00:11:37,100
assigned a log sequence number you might

00:11:34,050 --> 00:11:40,530
see that show up in show an OTB status

00:11:37,100 --> 00:11:43,710
most databases work this way we're not

00:11:40,530 --> 00:11:45,720
unique in you know DB the terminology

00:11:43,710 --> 00:11:47,910
can differ just a little bit in Oracle

00:11:45,720 --> 00:11:49,890
they prefer to call these logs redo logs

00:11:47,910 --> 00:11:51,870
we call them transaction logs most of

00:11:49,890 --> 00:11:54,570
the time in you know to be in Oracle

00:11:51,870 --> 00:11:56,460
they write full pages to the redo log in

00:11:54,570 --> 00:11:58,470
you know deviis transaction logs we just

00:11:56,460 --> 00:12:00,420
write very short updates yeah remember

00:11:58,470 --> 00:12:02,100
the minimum and the background

00:12:00,420 --> 00:12:03,510
operations and I was talking about of

00:12:02,100 --> 00:12:05,970
writing down those dirty pages that's

00:12:03,510 --> 00:12:08,250
called a checkpoint this is the main

00:12:05,970 --> 00:12:09,360
algorithm of you know DB so we

00:12:08,250 --> 00:12:12,600
understand this we can start making

00:12:09,360 --> 00:12:14,220
optimizations open question what's the

00:12:12,600 --> 00:12:19,260
first optimization we could make on the

00:12:14,220 --> 00:12:21,450
log files what could we do to them we

00:12:19,260 --> 00:12:22,980
could increase them sure though the lobe

00:12:21,450 --> 00:12:24,950
files our way of creating some sort of

00:12:22,980 --> 00:12:27,720
buffering of background operations and

00:12:24,950 --> 00:12:30,300
we can use larger lobe files

00:12:27,720 --> 00:12:32,100
smooth out our load by having a larger

00:12:30,300 --> 00:12:34,770
log more worker we can get delayed

00:12:32,100 --> 00:12:37,170
behind on there's actually another

00:12:34,770 --> 00:12:39,140
setting related to the local files here

00:12:37,170 --> 00:12:42,330
which is to say how many log files and

00:12:39,140 --> 00:12:44,730
it's really energy V effective log size

00:12:42,330 --> 00:12:46,770
is low file size multiplied by how many

00:12:44,730 --> 00:12:48,270
log files there are there's no

00:12:46,770 --> 00:12:51,690
difference from you know TVs perspective

00:12:48,270 --> 00:12:53,910
if you have three seven Meg logs or two

00:12:51,690 --> 00:12:59,190
10 Meg logs it treats it the same like

00:12:53,910 --> 00:13:00,720
one logical log and then a forester we

00:12:59,190 --> 00:13:03,180
also have some options to be able to

00:13:00,720 --> 00:13:06,840
change the durability of this log file

00:13:03,180 --> 00:13:08,280
so now whenever someone says commit we

00:13:06,840 --> 00:13:09,990
just write to that operating system

00:13:08,280 --> 00:13:13,050
write buffer and we don't ask it to sync

00:13:09,990 --> 00:13:14,880
constantly if we're using really cheap

00:13:13,050 --> 00:13:16,110
hardware that doesn't have that battery

00:13:14,880 --> 00:13:18,680
backed write cache on a RAID controller

00:13:16,110 --> 00:13:22,800
this might get you some performance back

00:13:18,680 --> 00:13:24,790
just for example the devote is is one if

00:13:22,800 --> 00:13:27,070
we set this to you know just everyone

00:13:24,790 --> 00:13:30,070
second to a background operation to be

00:13:27,070 --> 00:13:31,720
able to sink that low file otherwise

00:13:30,070 --> 00:13:33,250
it's just going to be buffering it in a

00:13:31,720 --> 00:13:36,970
buffer before it writes it to the Loeb

00:13:33,250 --> 00:13:39,190
file this buffer is normally perfectly

00:13:36,970 --> 00:13:40,390
sized it's just if you're doing large

00:13:39,190 --> 00:13:42,550
text and blobs that you might change

00:13:40,390 --> 00:13:44,470
this buffer this one you'd only ever

00:13:42,550 --> 00:13:45,730
change if you we're accepting that you

00:13:44,470 --> 00:13:47,490
were going to use cheap hardware and you

00:13:45,730 --> 00:13:51,310
weren't going to use a RAID controller

00:13:47,490 --> 00:13:53,500
and a little bit of detail like I sort

00:13:51,310 --> 00:13:55,060
of described already is that as part of

00:13:53,500 --> 00:13:57,190
recovery we're replaying through that

00:13:55,060 --> 00:14:00,370
log file figuring out what changes

00:13:57,190 --> 00:14:01,810
needed to be reapplied because we

00:14:00,370 --> 00:14:03,880
haven't applied them to the tablespace

00:14:01,810 --> 00:14:05,740
yet and actually because we're doing

00:14:03,880 --> 00:14:07,840
some of our background work out of order

00:14:05,740 --> 00:14:10,030
crash recovery takes a really long time

00:14:07,840 --> 00:14:11,740
we can find out that some changes have

00:14:10,030 --> 00:14:14,470
already been made that they've already

00:14:11,740 --> 00:14:16,870
been made we know it because the pages

00:14:14,470 --> 00:14:19,510
internally all store their local

00:14:16,870 --> 00:14:23,590
sequence number the the mock of last

00:14:19,510 --> 00:14:25,420
known modification and you can see some

00:14:23,590 --> 00:14:29,260
of these details in something like show

00:14:25,420 --> 00:14:32,590
on our DB status here we can see the

00:14:29,260 --> 00:14:34,410
highest log sequence number ever handed

00:14:32,590 --> 00:14:37,420
out to any transaction that's running

00:14:34,410 --> 00:14:40,870
the highest log sequence number that's

00:14:37,420 --> 00:14:43,120
ever made it into our log files and the

00:14:40,870 --> 00:14:45,120
highest load sequence number for which

00:14:43,120 --> 00:14:47,260
all background work is completely done

00:14:45,120 --> 00:14:49,690
if you have a difference between those

00:14:47,260 --> 00:14:52,300
bottom two numbers expect a very long

00:14:49,690 --> 00:14:54,010
crash recovery I have a rough sizing

00:14:52,300 --> 00:14:56,290
guide of of something that's more or

00:14:54,010 --> 00:14:57,910
less rule of thumb saying have enough

00:14:56,290 --> 00:15:01,060
log space for an hour's worth of work

00:14:57,910 --> 00:15:03,610
you might set that larger if you can

00:15:01,060 --> 00:15:05,620
tolerate worse crash recovery or smaller

00:15:03,610 --> 00:15:06,550
if you want to have a small amount of

00:15:05,620 --> 00:15:08,830
crash recovery

00:15:06,550 --> 00:15:11,290
I like that in our DV gives this as a

00:15:08,830 --> 00:15:13,360
choice to me if we look at some other

00:15:11,290 --> 00:15:15,040
database systems or we have something

00:15:13,360 --> 00:15:17,890
like my eyes I'm corruption which can

00:15:15,040 --> 00:15:19,180
happen during failure it's the size of

00:15:17,890 --> 00:15:20,950
the table which dictates what the

00:15:19,180 --> 00:15:22,000
recovery is because we have to look

00:15:20,950 --> 00:15:27,120
through everything again

00:15:22,000 --> 00:15:29,860
no DV is nice in this design production

00:15:27,120 --> 00:15:31,630
so I have some frequently asked

00:15:29,860 --> 00:15:33,940
questions at this point

00:15:31,630 --> 00:15:36,190
what are we write to the log file is it

00:15:33,940 --> 00:15:38,410
committed daughter or is it uncommitted

00:15:36,190 --> 00:15:41,199
daughter it's actually both times

00:15:38,410 --> 00:15:42,819
Dadar get written to the log file right

00:15:41,199 --> 00:15:45,220
to the log file straight away as you

00:15:42,819 --> 00:15:47,230
making modifications whether or not

00:15:45,220 --> 00:15:49,420
those modifications were committed yet

00:15:47,230 --> 00:15:52,209
or not it's very optimistic in this

00:15:49,420 --> 00:15:53,740
design and by using this design we can

00:15:52,209 --> 00:15:55,480
ensure that we can do bigger

00:15:53,740 --> 00:15:57,129
transactions and what we have memory for

00:15:55,480 --> 00:16:00,970
because we're making the modification

00:15:57,129 --> 00:16:02,230
straightaway it actually does mean that

00:16:00,970 --> 00:16:05,470
as well as being able to reapply

00:16:02,230 --> 00:16:07,689
transactions through our log file system

00:16:05,470 --> 00:16:09,459
we also have to be able to uh apply the

00:16:07,689 --> 00:16:11,230
transactions something I haven't

00:16:09,459 --> 00:16:14,920
explained yet is that inner DB also has

00:16:11,230 --> 00:16:17,620
something called undo information log

00:16:14,920 --> 00:16:20,379
files reapply changes under information

00:16:17,620 --> 00:16:22,720
on applies changes and the under

00:16:20,379 --> 00:16:24,759
information is in another these case not

00:16:22,720 --> 00:16:27,040
stored in a log file it's always going

00:16:24,759 --> 00:16:31,600
to be stored in IB data one at central

00:16:27,040 --> 00:16:33,370
tablespace some transactions also in the

00:16:31,600 --> 00:16:35,529
database system they have to be able to

00:16:33,370 --> 00:16:37,720
see all versions of the data we'll get

00:16:35,529 --> 00:16:39,819
to why that is in a second but they also

00:16:37,720 --> 00:16:44,139
look at undo information to be able to

00:16:39,819 --> 00:16:46,329
see that so this is the the basic

00:16:44,139 --> 00:16:51,069
algorithm of inner DV how's that one

00:16:46,329 --> 00:16:52,810
going alright awesome so let's look at

00:16:51,069 --> 00:16:56,860
the on disk format let's look at how we

00:16:52,810 --> 00:17:00,069
know DB store starter the simplified

00:16:56,860 --> 00:17:01,420
version of energy storage is that

00:17:00,069 --> 00:17:04,270
everything is stored in this format

00:17:01,420 --> 00:17:06,909
coded table space inside pages in this

00:17:04,270 --> 00:17:10,000
table space and the default mode of this

00:17:06,909 --> 00:17:13,000
tablespace is one file called IV data

00:17:10,000 --> 00:17:15,640
one and in this same mode you can have

00:17:13,000 --> 00:17:16,270
multiple files IV data one IV data to IV

00:17:15,640 --> 00:17:18,400
out of three

00:17:16,270 --> 00:17:20,829
it'll fill the first one that'll fill

00:17:18,400 --> 00:17:22,870
the next one it doesn't do any

00:17:20,829 --> 00:17:24,730
round-robin ago striping it just works

00:17:22,870 --> 00:17:26,919
in this mode there's another mechanism

00:17:24,730 --> 00:17:30,549
coding or DB file per table where every

00:17:26,919 --> 00:17:32,980
table is its own tablespace I'll get to

00:17:30,549 --> 00:17:36,010
that in a second but the sort of data

00:17:32,980 --> 00:17:37,659
that we have to store in inner DB is at

00:17:36,010 --> 00:17:39,340
least this data it's not just the data

00:17:37,659 --> 00:17:40,630
in terms of data and indexes there's a

00:17:39,340 --> 00:17:44,230
lot of other data that happens

00:17:40,630 --> 00:17:45,429
internally so I want to I want to draw

00:17:44,230 --> 00:17:46,030
it as a picture because it's going to be

00:17:45,429 --> 00:17:48,850
a little bit easier

00:17:46,030 --> 00:17:50,320
to explain let's pretend what I read out

00:17:48,850 --> 00:17:52,060
of one might look like if I apply a

00:17:50,320 --> 00:17:55,860
little bit of a simplification

00:17:52,060 --> 00:17:57,820
I beat out a 1 divided into 16 K pages

00:17:55,860 --> 00:18:01,690
where you probably have some initial

00:17:57,820 --> 00:18:04,060
method adder in IB data 1 then we have

00:18:01,690 --> 00:18:05,740
some sort of data dictionary

00:18:04,060 --> 00:18:08,500
you know DB was actually a standalone

00:18:05,740 --> 00:18:10,900
database once upon a time before we

00:18:08,500 --> 00:18:13,690
lucked into inner DB much like MySQL

00:18:10,900 --> 00:18:15,280
remembers how to create tables in ODB

00:18:13,690 --> 00:18:17,020
has to have its own copy and reference

00:18:15,280 --> 00:18:19,410
of that separate from the daughter for

00:18:17,020 --> 00:18:22,300
m-files that you might be familiar with

00:18:19,410 --> 00:18:25,440
in ODB also has this under information

00:18:22,300 --> 00:18:28,540
it's always stored in Ivy data one and

00:18:25,440 --> 00:18:30,730
then we might have table 1 then we might

00:18:28,540 --> 00:18:32,620
have table 2 and then we might have

00:18:30,730 --> 00:18:34,510
table 1 again

00:18:32,620 --> 00:18:37,480
tables are not guaranteed to be stored

00:18:34,510 --> 00:18:40,870
contiguous they're allocated in a format

00:18:37,480 --> 00:18:43,750
called extents and or and it might not

00:18:40,870 --> 00:18:45,910
be you know 16 K at a time it's probably

00:18:43,750 --> 00:18:47,440
gonna be a negative time well I want to

00:18:45,910 --> 00:18:49,600
show you this more specifically is that

00:18:47,440 --> 00:18:53,410
this is I read out of 1 and this is if

00:18:49,600 --> 00:18:55,870
we're using ODB file for table so if

00:18:53,410 --> 00:18:57,220
we're using ODB file per table and sorry

00:18:55,870 --> 00:19:00,040
I can see it's a little bit unclear but

00:18:57,220 --> 00:19:03,520
if we have table 1 dot IBD the table 2

00:19:00,040 --> 00:19:06,070
dot IBD here if we copy table 2 dot IVD

00:19:03,520 --> 00:19:09,040
to another host do we have a complete

00:19:06,070 --> 00:19:11,830
backup of table 2 dot IVD no we don't I

00:19:09,040 --> 00:19:13,630
see someone shaking the head and you'll

00:19:11,830 --> 00:19:15,430
discover this very fast if you move to

00:19:13,630 --> 00:19:17,110
inner TV from my eyes name it doesn't

00:19:15,430 --> 00:19:19,210
have the same portability of just

00:19:17,110 --> 00:19:22,870
copying files there's some information

00:19:19,210 --> 00:19:25,210
about table 2 dot IVD such as it's data

00:19:22,870 --> 00:19:27,250
description that's not going to be

00:19:25,210 --> 00:19:29,410
stored in this file and it never will be

00:19:27,250 --> 00:19:31,870
and there's undo information describing

00:19:29,410 --> 00:19:36,340
this table as well so you have to be

00:19:31,870 --> 00:19:37,840
careful with that caveat if we expand on

00:19:36,340 --> 00:19:39,850
storage just a little bit and we talked

00:19:37,840 --> 00:19:42,640
about how allocations work I'm going to

00:19:39,850 --> 00:19:44,860
get not too deep here but I'm going to

00:19:42,640 --> 00:19:46,510
lay out that the terminology so it will

00:19:44,860 --> 00:19:50,370
help you reviewing things like show on a

00:19:46,510 --> 00:19:54,760
TV status segments fit into table spaces

00:19:50,370 --> 00:19:57,340
segments have extents an extensive made

00:19:54,760 --> 00:19:59,740
up of pages and you can think of this as

00:19:57,340 --> 00:20:01,300
some sort of allocation system to sum of

00:19:59,740 --> 00:20:03,700
how you lived on a house that's on the

00:20:01,300 --> 00:20:06,390
street and so on this is the internal

00:20:03,700 --> 00:20:09,010
terminology

00:20:06,390 --> 00:20:10,900
if we look at a page I think it's fun to

00:20:09,010 --> 00:20:13,840
look at a page this is what a dotted

00:20:10,900 --> 00:20:16,660
page might look like in you know TV here

00:20:13,840 --> 00:20:21,280
we have a series of rows of variable

00:20:16,660 --> 00:20:24,900
length sitting inside a data page and a

00:20:21,280 --> 00:20:27,309
data page has a header and a footer and

00:20:24,900 --> 00:20:30,040
there's a rule that says that a row must

00:20:27,309 --> 00:20:33,070
fit within a page or rather two rows

00:20:30,040 --> 00:20:36,960
must fit within a page it has a special

00:20:33,070 --> 00:20:39,640
handling of text blog and long watches

00:20:36,960 --> 00:20:41,890
what I like to show here is things like

00:20:39,640 --> 00:20:44,140
the header and the trailer and say how

00:20:41,890 --> 00:20:47,200
in ODB is just a fantastic database and

00:20:44,140 --> 00:20:50,500
that it's defensive for all of the the

00:20:47,200 --> 00:20:52,570
shortcomings of hardware or failure it's

00:20:50,500 --> 00:20:55,059
prepared for failure and one thing that

00:20:52,570 --> 00:20:58,510
I like that it has is it has a page

00:20:55,059 --> 00:21:00,220
checksum so that it will notice if

00:20:58,510 --> 00:21:02,049
there's some sort of on disk corruption

00:21:00,220 --> 00:21:05,440
it'll checksum the page and then I'll

00:21:02,049 --> 00:21:07,360
save that into the header here and if we

00:21:05,440 --> 00:21:09,340
have some sort of hardware failure in

00:21:07,360 --> 00:21:11,230
ODB's going to detect this and it's

00:21:09,340 --> 00:21:14,320
actually going to intentionally crash

00:21:11,230 --> 00:21:16,480
your server because anybody these minds

00:21:14,320 --> 00:21:18,130
mind with this checksum it would rather

00:21:16,480 --> 00:21:19,540
have a complete system down if your

00:21:18,130 --> 00:21:22,240
hardware has been lying in wait for your

00:21:19,540 --> 00:21:24,190
intervention rather than keep running

00:21:22,240 --> 00:21:27,429
and if you look at something like my

00:21:24,190 --> 00:21:30,549
eyes M or some other databases you'll

00:21:27,429 --> 00:21:32,710
find this silent corruption just spring

00:21:30,549 --> 00:21:34,600
up on you all of the second in ODB is

00:21:32,710 --> 00:21:36,400
designed to be defensive it's designed

00:21:34,600 --> 00:21:38,740
to be asked compliant and give some of

00:21:36,400 --> 00:21:41,320
these promises the cost of this checksum

00:21:38,740 --> 00:21:42,790
should be relatively low it only checks

00:21:41,320 --> 00:21:45,309
the checksum whatever it's reading from

00:21:42,790 --> 00:21:47,260
disk I read from disk takes something

00:21:45,309 --> 00:21:49,120
like 10 milliseconds calculating this

00:21:47,260 --> 00:21:51,220
checksum is probably in the microsecond

00:21:49,120 --> 00:21:54,760
range and updates the checksum of its

00:21:51,220 --> 00:21:56,890
writing back to disk in newer versions

00:21:54,760 --> 00:21:58,450
of energy B the company I work for makes

00:21:56,890 --> 00:22:00,820
a special version of an ODB that's

00:21:58,450 --> 00:22:02,740
enhanced this might become a bigger

00:22:00,820 --> 00:22:05,500
problem on SSDs because SSE is a much

00:22:02,740 --> 00:22:09,280
faster at reading and writing powder but

00:22:05,500 --> 00:22:11,679
this is a good feature if we look at

00:22:09,280 --> 00:22:13,240
what a row looks like there's just one

00:22:11,679 --> 00:22:14,500
thing or two things that I want to point

00:22:13,240 --> 00:22:16,690
out because it's going to help us for

00:22:14,500 --> 00:22:18,759
the next section which is a row

00:22:16,690 --> 00:22:21,519
internally has a couple of internal

00:22:18,759 --> 00:22:23,559
coordinates here to remember at what ID

00:22:21,519 --> 00:22:25,929
this road was created what transaction

00:22:23,559 --> 00:22:29,739
ID and be able to see earlier versions

00:22:25,929 --> 00:22:31,539
of the row in undo space it helps me out

00:22:29,739 --> 00:22:34,049
with this segue to this next feature

00:22:31,539 --> 00:22:36,129
called multi-version concurrency control

00:22:34,049 --> 00:22:38,889
so who's familiar with multi-version

00:22:36,129 --> 00:22:42,039
concurrency control okay a few people

00:22:38,889 --> 00:22:45,579
this is an exciting topic this is this

00:22:42,039 --> 00:22:49,809
is how inner DB is not slower at at

00:22:45,579 --> 00:22:51,940
reads or not slower than than my eyes M

00:22:49,809 --> 00:22:53,379
it's really quite good when you've got a

00:22:51,940 --> 00:22:55,899
lot of people in the system at once it

00:22:53,379 --> 00:23:00,069
gives very good concurrency let's talk

00:22:55,899 --> 00:23:02,499
about how it works so here we've got a

00:23:00,069 --> 00:23:05,619
social networking website we've got

00:23:02,499 --> 00:23:07,809
three tables we've got users users write

00:23:05,619 --> 00:23:10,899
blog posts and users can be friends with

00:23:07,809 --> 00:23:13,239
each other in this case Morgan is

00:23:10,899 --> 00:23:15,969
friends with Tom Thomas friends with

00:23:13,239 --> 00:23:18,190
Morgan Baron and Morgan are friends and

00:23:15,969 --> 00:23:20,799
that is a mutual relationship there as

00:23:18,190 --> 00:23:23,639
well so on this social networking

00:23:20,799 --> 00:23:25,779
schemer I'm going to do an operation

00:23:23,639 --> 00:23:27,369
doesn't matter what operation I'm going

00:23:25,779 --> 00:23:29,499
to do but I'm gonna do a backup because

00:23:27,369 --> 00:23:32,499
it's the easiest way to explain why this

00:23:29,499 --> 00:23:34,209
feature is required so I'm going to back

00:23:32,499 --> 00:23:35,409
up these three tables I'm going to start

00:23:34,209 --> 00:23:37,719
with the users table and I'm going to

00:23:35,409 --> 00:23:39,339
read through it and I'm gonna start

00:23:37,719 --> 00:23:42,039
reading through the blog purse table I'm

00:23:39,339 --> 00:23:43,959
gonna back that up and while I'm backing

00:23:42,039 --> 00:23:47,829
this blog purse table up and it's taking

00:23:43,959 --> 00:23:49,809
me quite a while let me just zoom back

00:23:47,829 --> 00:23:52,329
on that for a second this is a

00:23:49,809 --> 00:23:54,219
multi-user system so someone else is

00:23:52,329 --> 00:23:56,079
doing something and that someone else

00:23:54,219 --> 00:23:56,709
just inserted a new record that wasn't

00:23:56,079 --> 00:23:58,869
here before

00:23:56,709 --> 00:24:02,829
they inserted this user Justin who likes

00:23:58,869 --> 00:24:04,179
pizza and this new user as soon as they

00:24:02,829 --> 00:24:05,259
were inserted there they decided that

00:24:04,179 --> 00:24:08,709
there were going to be friends with

00:24:05,259 --> 00:24:10,029
baron my operation at this point is

00:24:08,709 --> 00:24:12,579
still backing up through the vlog post

00:24:10,029 --> 00:24:14,339
table it just finishes and now it starts

00:24:12,579 --> 00:24:17,739
backing out the user friendship table

00:24:14,339 --> 00:24:19,589
and we have a race condition here here's

00:24:17,739 --> 00:24:23,799
the data that I would have if I tried to

00:24:19,589 --> 00:24:24,279
restore from backup can you see the

00:24:23,799 --> 00:24:27,759
dilemma

00:24:24,279 --> 00:24:29,379
I had already backed up the users table

00:24:27,759 --> 00:24:32,710
and then I started backing up the user

00:24:29,379 --> 00:24:34,980
friendship table and now I have this

00:24:32,710 --> 00:24:38,409
and I didn't want to see that daughter

00:24:34,980 --> 00:24:42,249
one of the rules of databases one of the

00:24:38,409 --> 00:24:44,110
rules of consistent reads is that we

00:24:42,249 --> 00:24:47,110
have to represent a single point in time

00:24:44,110 --> 00:24:48,669
for any database operation that single

00:24:47,110 --> 00:24:50,139
point in time can be the start of when

00:24:48,669 --> 00:24:51,429
the operation runs or it can actually be

00:24:50,139 --> 00:24:53,200
the end of the operation it doesn't

00:24:51,429 --> 00:24:55,509
matter we have to represent a single

00:24:53,200 --> 00:24:57,850
point in time to be able to stop these

00:24:55,509 --> 00:25:01,289
race conditions from happening this is

00:24:57,850 --> 00:25:04,480
an acid requirement for consistent reads

00:25:01,289 --> 00:25:05,950
and we can drop some of the consistency

00:25:04,480 --> 00:25:08,409
requirements a little bit but anyway

00:25:05,950 --> 00:25:10,809
that's let's explain for example how how

00:25:08,409 --> 00:25:12,820
my eyes emselves this problem so we

00:25:10,809 --> 00:25:14,950
don't have any race condition so we want

00:25:12,820 --> 00:25:19,179
to back up these three tables here's

00:25:14,950 --> 00:25:20,769
what my Eisen does read luck now nobody

00:25:19,179 --> 00:25:22,450
can write to those tables other people

00:25:20,769 --> 00:25:24,970
allowed to read to them but nobody can

00:25:22,450 --> 00:25:26,740
write to those tables and now let's back

00:25:24,970 --> 00:25:29,590
them up and we get a consistent view of

00:25:26,740 --> 00:25:34,960
the daughter this really hurts

00:25:29,590 --> 00:25:36,909
performance readers block writers how

00:25:34,960 --> 00:25:39,369
does in ODB do this well in ODB has this

00:25:36,909 --> 00:25:41,470
hidden hidden metadata the transaction

00:25:39,369 --> 00:25:42,669
ID and missing from my slide there's

00:25:41,470 --> 00:25:44,679
also another column called rollback

00:25:42,669 --> 00:25:47,019
pointer where basically as you're

00:25:44,679 --> 00:25:49,629
reading through this daughter you just

00:25:47,019 --> 00:25:51,309
remember a series of coordinates i'm

00:25:49,629 --> 00:25:53,379
transaction number 100

00:25:51,309 --> 00:25:55,690
i can't see past 100 if there's a

00:25:53,379 --> 00:25:57,369
version called 101 don't let me see it

00:25:55,690 --> 00:25:59,379
if there's a version older than this

00:25:57,369 --> 00:26:00,610
number don't let me see it I'm just

00:25:59,379 --> 00:26:02,679
going to be able to see these changes

00:26:00,610 --> 00:26:03,610
and by remembering this set of

00:26:02,679 --> 00:26:06,249
coordinates there'll be multiple

00:26:03,610 --> 00:26:07,570
versions of a row you only see the ones

00:26:06,249 --> 00:26:09,759
that you were supposed to be able to see

00:26:07,570 --> 00:26:12,399
and you don't have readers blocking

00:26:09,759 --> 00:26:14,980
writers you get very good concurrency

00:26:12,399 --> 00:26:17,139
and I just have a little snapshot of

00:26:14,980 --> 00:26:19,659
showing those coordinates working in

00:26:17,139 --> 00:26:26,440
Shona TV status and it reads that all

00:26:19,659 --> 00:26:28,480
versions of rows from undo space okay so

00:26:26,440 --> 00:26:31,119
now we're up to some of the more

00:26:28,480 --> 00:26:34,269
advanced features we're up to talking

00:26:31,119 --> 00:26:38,259
about how nodb stores data and indexes

00:26:34,269 --> 00:26:41,379
and rather actually all data in you know

00:26:38,259 --> 00:26:45,309
TV is stored on index there's no thing

00:26:41,379 --> 00:26:46,140
as data that's just indexes so when you

00:26:45,309 --> 00:26:48,330
create a

00:26:46,140 --> 00:26:51,650
and you say you have a primary key it's

00:26:48,330 --> 00:26:54,240
physically sorted in that primary key

00:26:51,650 --> 00:26:56,250
everything is an index I'll show an

00:26:54,240 --> 00:26:57,750
example of my eyes em to start with

00:26:56,250 --> 00:27:00,990
because it makes it easier to be able to

00:26:57,750 --> 00:27:03,960
explain this we have a my I file storing

00:27:00,990 --> 00:27:07,370
indexes we have an my D file storing

00:27:03,960 --> 00:27:09,600
data the data is stored in roughly the

00:27:07,370 --> 00:27:11,160
order that the rows were inserted

00:27:09,600 --> 00:27:13,080
there's no guarantees if something is

00:27:11,160 --> 00:27:16,140
deleted we're going insert back into a

00:27:13,080 --> 00:27:19,049
gap here basically it's just like a long

00:27:16,140 --> 00:27:21,809
array of data and then we have this

00:27:19,049 --> 00:27:24,720
index file which is sorted here in some

00:27:21,809 --> 00:27:26,309
sort of tree structure of B tree and if

00:27:24,720 --> 00:27:28,190
we did something like a primary key

00:27:26,309 --> 00:27:31,380
lookup on this soft table we said that's

00:27:28,190 --> 00:27:33,480
go and let's try and look for a

00:27:31,380 --> 00:27:36,540
particular user we're gonna look for

00:27:33,480 --> 00:27:38,280
user number five if we're looking up a

00:27:36,540 --> 00:27:40,320
primary key index or any other index we

00:27:38,280 --> 00:27:43,429
find that point two four five and then

00:27:40,320 --> 00:27:43,429
we just look up that row

00:27:44,240 --> 00:27:50,400
let's look at how it works in your know

00:27:46,290 --> 00:27:51,809
to be whether it's clustered index you

00:27:50,400 --> 00:27:54,299
know Divi the primary key looks like

00:27:51,809 --> 00:27:57,299
this it's the same structure as the my

00:27:54,299 --> 00:28:01,110
eyes M indexes we're looking for user

00:27:57,299 --> 00:28:04,650
number two when we find number two there

00:28:01,110 --> 00:28:06,630
we actually just stop the data is stored

00:28:04,650 --> 00:28:11,120
in the index stored in the leaf node of

00:28:06,630 --> 00:28:13,290
the of the primary key tree here so at

00:28:11,120 --> 00:28:15,419
when we get to there we stop and

00:28:13,290 --> 00:28:17,250
actually primary key lookups in your

00:28:15,419 --> 00:28:19,260
know DB are really fast if you can

00:28:17,250 --> 00:28:21,140
design your structure around this this

00:28:19,260 --> 00:28:24,350
is a very nice feature

00:28:21,140 --> 00:28:27,000
nice uniformly consistent read time

00:28:24,350 --> 00:28:30,270
rather than having to read somewhere

00:28:27,000 --> 00:28:32,750
than follow a pointer and if we look at

00:28:30,270 --> 00:28:35,160
a second or key index how does this work

00:28:32,750 --> 00:28:37,980
well a secondary key index would be a

00:28:35,160 --> 00:28:39,780
traversal of a normal index structure

00:28:37,980 --> 00:28:41,280
and actually in the back of the

00:28:39,780 --> 00:28:44,280
secondary key index we remember the

00:28:41,280 --> 00:28:45,540
value of the primary key and remember

00:28:44,280 --> 00:28:48,809
that the person with the extension

00:28:45,540 --> 00:28:52,080
number seven was the same person who was

00:28:48,809 --> 00:28:54,179
user ID number 7 and then we traverse

00:28:52,080 --> 00:28:57,540
this primary key index and we find the

00:28:54,179 --> 00:28:59,610
full run so no newbies actually just a

00:28:57,540 --> 00:28:59,970
little bit slower at at secondary key

00:28:59,610 --> 00:29:02,580
look

00:28:59,970 --> 00:29:04,230
because navigating two trees is more

00:29:02,580 --> 00:29:07,590
expensive than navigating one tree and

00:29:04,230 --> 00:29:09,929
then some sort of hash like lookup but

00:29:07,590 --> 00:29:11,700
it has a nice feature to be able to make

00:29:09,929 --> 00:29:13,740
secretary index foster as well they

00:29:11,700 --> 00:29:15,059
talked about that in a second so this

00:29:13,740 --> 00:29:17,580
design has some interesting consequences

00:29:15,059 --> 00:29:18,929
that you need to be aware of you need to

00:29:17,580 --> 00:29:20,720
know that primary key lookups are very

00:29:18,929 --> 00:29:23,279
fast and you should engineer for that

00:29:20,720 --> 00:29:25,200
inserting data in order is very fast out

00:29:23,279 --> 00:29:27,990
of order is very slow as it causes some

00:29:25,200 --> 00:29:29,370
page splits and secondary indexes

00:29:27,990 --> 00:29:32,580
actually become very large if you're

00:29:29,370 --> 00:29:34,610
very much a monkey is it that primary

00:29:32,580 --> 00:29:36,690
key into the secondary index in

00:29:34,610 --> 00:29:39,419
practical terms this can be explained

00:29:36,690 --> 00:29:41,730
very similar I simply don't use goods

00:29:39,419 --> 00:29:42,929
foreigner TV tables it's the silliest

00:29:41,730 --> 00:29:46,620
thing for performance ever

00:29:42,929 --> 00:29:49,110
and some indexing structure like adding

00:29:46,620 --> 00:29:52,039
primary keys into secondary key indexes

00:29:49,110 --> 00:29:52,039
doesn't make sense either

00:29:53,000 --> 00:29:58,769
so next section

00:29:56,850 --> 00:30:01,110
insert buffer an adaptive hash has

00:29:58,769 --> 00:30:07,830
everyone going so far yeah

00:30:01,110 --> 00:30:09,299
all right listen so let's talk about

00:30:07,830 --> 00:30:11,909
those secondary key lookups and how

00:30:09,299 --> 00:30:14,850
they're really slow secondary key

00:30:11,909 --> 00:30:16,649
lookups the slower because we we go

00:30:14,850 --> 00:30:17,940
through a secondary index we find the

00:30:16,649 --> 00:30:22,769
value of the primary key and then we

00:30:17,940 --> 00:30:25,950
find that data are almost workloads most

00:30:22,769 --> 00:30:27,629
access patterns have hotspots you know

00:30:25,950 --> 00:30:29,370
when there's a new Harry Potter movie

00:30:27,629 --> 00:30:30,629
announced every one of forums talking

00:30:29,370 --> 00:30:34,139
about that it's like the most exciting

00:30:30,629 --> 00:30:36,210
thing ever so inner TV monitors actually

00:30:34,139 --> 00:30:39,149
your index usage which Potts is of your

00:30:36,210 --> 00:30:40,769
key or accessing and assuming that there

00:30:39,149 --> 00:30:43,559
are some hotspots which there will be

00:30:40,769 --> 00:30:44,789
most access patterns describe what we

00:30:43,559 --> 00:30:46,769
call like some sort of zip Ian

00:30:44,789 --> 00:30:48,570
distribution where the most popular

00:30:46,769 --> 00:30:50,490
thing is twice as popular as the next

00:30:48,570 --> 00:30:52,259
popular thing which was twice as

00:30:50,490 --> 00:30:54,509
populous that the next thing below that

00:30:52,259 --> 00:30:55,919
what a nerdy B is going to do is it's

00:30:54,509 --> 00:31:01,009
going to allocate a special area of

00:30:55,919 --> 00:31:03,450
memory here a hash style index so here

00:31:01,009 --> 00:31:05,309
we're going to be searching for some

00:31:03,450 --> 00:31:07,980
particular user

00:31:05,309 --> 00:31:09,779
normally by extension but before we look

00:31:07,980 --> 00:31:12,000
by extension we just searched the hash

00:31:09,779 --> 00:31:13,750
and we say is it in this hash which is

00:31:12,000 --> 00:31:16,840
not a complete index it's just

00:31:13,750 --> 00:31:19,060
index for hot spots and then in this

00:31:16,840 --> 00:31:22,060
case the particular user that we're

00:31:19,060 --> 00:31:24,100
looking for with extension number five

00:31:22,060 --> 00:31:26,410
we're looking for them all the time

00:31:24,100 --> 00:31:28,180
and so we have a special pointer to be

00:31:26,410 --> 00:31:32,350
able to say for extension number five

00:31:28,180 --> 00:31:34,570
that's user ID number seven and actually

00:31:32,350 --> 00:31:36,070
it avoids scanning this tree and it

00:31:34,570 --> 00:31:37,720
avoids scanning this tree and uses a

00:31:36,070 --> 00:31:41,050
pointer just like to the leaf node of

00:31:37,720 --> 00:31:44,560
this primary key index secondary indexes

00:31:41,050 --> 00:31:46,240
can be quite fast we don't have too much

00:31:44,560 --> 00:31:48,880
transparency into the operation of this

00:31:46,240 --> 00:31:51,160
but on my server you can see here that

00:31:48,880 --> 00:31:52,570
this alyc automatically allocated in

00:31:51,160 --> 00:31:54,550
memory and was using one hundred and

00:31:52,570 --> 00:31:56,590
twenty six megabytes of memory

00:31:54,550 --> 00:31:58,630
I like the dinner to be has these

00:31:56,590 --> 00:32:01,480
features if you compare this to my eyes

00:31:58,630 --> 00:32:07,330
and it has none of this it just relies

00:32:01,480 --> 00:32:09,580
on normal index lookups now if we look

00:32:07,330 --> 00:32:12,070
at a particularly interesting

00:32:09,580 --> 00:32:13,570
characteristic of indexes as well

00:32:12,070 --> 00:32:16,840
indexes when they don't fit in memory

00:32:13,570 --> 00:32:19,330
can get quite slow because as we insert

00:32:16,840 --> 00:32:23,050
into these indexes that we can get

00:32:19,330 --> 00:32:25,480
random i/o on disk so I'll draw some

00:32:23,050 --> 00:32:27,460
pictures to explain this better there's

00:32:25,480 --> 00:32:29,290
a feature called the insert buffer and

00:32:27,460 --> 00:32:33,450
it's designed to be able to merge i/o

00:32:29,290 --> 00:32:35,680
for index operations this buffering of

00:32:33,450 --> 00:32:38,110
inserting into indexes is completely

00:32:35,680 --> 00:32:39,990
safe there's no mistakes that are ever

00:32:38,110 --> 00:32:42,160
going to be made in this operation

00:32:39,990 --> 00:32:44,110
pictures describe it better so I'm going

00:32:42,160 --> 00:32:46,840
to skip forward here and show this

00:32:44,110 --> 00:32:49,390
picture here so here we have our classic

00:32:46,840 --> 00:32:51,400
be tree structure it's a it's a phone

00:32:49,390 --> 00:32:52,900
book of names and let's pretend that

00:32:51,400 --> 00:32:57,040
this isn't this big it's it's like

00:32:52,900 --> 00:32:58,600
massively larger so with this index not

00:32:57,040 --> 00:33:00,730
all of it could fit in memory but maybe

00:32:58,600 --> 00:33:04,150
just the first couple of levels deep of

00:33:00,730 --> 00:33:05,920
index and then the rest con often with

00:33:04,150 --> 00:33:07,210
something like a primary key we could be

00:33:05,920 --> 00:33:10,500
always inserting into the end of the

00:33:07,210 --> 00:33:13,570
index because we just allocate numbers

00:33:10,500 --> 00:33:15,130
sequentially but the secondary index is

00:33:13,570 --> 00:33:16,360
you know you don't get to say that every

00:33:15,130 --> 00:33:17,880
one that goes in the faint phonebook

00:33:16,360 --> 00:33:20,830
their names going to be alphabetically

00:33:17,880 --> 00:33:22,930
further along it can become random I

00:33:20,830 --> 00:33:24,370
you're from these pages that have to be

00:33:22,930 --> 00:33:26,680
read up and modified and things like

00:33:24,370 --> 00:33:27,640
that so if we try to insert something

00:33:26,680 --> 00:33:29,710
like buckling into the FIR

00:33:27,640 --> 00:33:31,960
book it ends up being here if we insert

00:33:29,710 --> 00:33:33,430
Maya's and ends up being here we insert

00:33:31,960 --> 00:33:36,280
joins it ends up being here it's all

00:33:33,430 --> 00:33:37,870
over the place the performance of this

00:33:36,280 --> 00:33:39,430
particular structure and this is the

00:33:37,870 --> 00:33:43,990
structure of it basically all databases

00:33:39,430 --> 00:33:46,570
use a tree structure it really depends

00:33:43,990 --> 00:33:49,930
on this structure fitting in memory to

00:33:46,570 --> 00:33:51,520
get good performance if we look at what

00:33:49,930 --> 00:33:54,520
the insert buffer does is rather than

00:33:51,520 --> 00:33:58,620
inserting those trees directly where the

00:33:54,520 --> 00:33:58,620
desk took them into this buffer

00:34:02,250 --> 00:34:26,409
operation thank you very much okay so we

00:34:24,460 --> 00:34:29,050
have this buffer we fill the buffer and

00:34:26,409 --> 00:34:31,600
then as a background operation we try

00:34:29,050 --> 00:34:32,200
and empty the buffer but that might not

00:34:31,600 --> 00:34:34,330
be soon enough

00:34:32,200 --> 00:34:38,440
so if we look at what happens if someone

00:34:34,330 --> 00:34:40,240
tried to read for Jones and the data for

00:34:38,440 --> 00:34:42,520
Jones is sitting in the insert buffer

00:34:40,240 --> 00:34:44,770
what the read operation does is it

00:34:42,520 --> 00:34:46,659
quickly before it loads up that data

00:34:44,770 --> 00:34:48,970
pages checks of any operations were

00:34:46,659 --> 00:34:51,850
pending for it and just in time it makes

00:34:48,970 --> 00:34:54,460
that change so this insert buffer is a

00:34:51,850 --> 00:34:56,649
tree like structure of its art and it's

00:34:54,460 --> 00:34:58,890
quite efficient if we had sorry to load

00:34:56,649 --> 00:35:01,720
that page we just build it just in time

00:34:58,890 --> 00:35:04,660
this feature is on by default in ODB and

00:35:01,720 --> 00:35:06,340
it's a great feature in ODB if you have

00:35:04,660 --> 00:35:08,440
a lot of tire is going to scale better

00:35:06,340 --> 00:35:14,230
than my ice m and we get some visibility

00:35:08,440 --> 00:35:17,080
into it here we can see the total size

00:35:14,230 --> 00:35:20,050
of it and we can see if there's any

00:35:17,080 --> 00:35:22,060
efficiency like merges it's going to be

00:35:20,050 --> 00:35:24,490
here any number here is good means we've

00:35:22,060 --> 00:35:28,180
reduced doing an IO and IO is just so

00:35:24,490 --> 00:35:31,210
expensive that's how it looks like in

00:35:28,180 --> 00:35:33,460
MySQL 5.1 and greater it looked a little

00:35:31,210 --> 00:35:36,060
bit different in early releases some

00:35:33,460 --> 00:35:40,750
additional notes there

00:35:36,060 --> 00:35:41,530
this feature Facebook has actually

00:35:40,750 --> 00:35:43,690
released some Sam

00:35:41,530 --> 00:35:46,570
and they get about a thirty time

00:35:43,690 --> 00:35:48,340
reduction 30 times reduction on IO from

00:35:46,570 --> 00:35:51,940
the secondary indexes by having this

00:35:48,340 --> 00:35:53,230
feature enabled in MySQL 5.5 they

00:35:51,940 --> 00:35:55,150
changed the name slightly they call this

00:35:53,230 --> 00:35:58,690
change buffering in old documentation

00:35:55,150 --> 00:36:02,680
and it now also buffers deletes and

00:35:58,690 --> 00:36:08,170
updates not just inserts so we delay out

00:36:02,680 --> 00:36:12,490
of the operation so now we're on to

00:36:08,170 --> 00:36:15,700
double write buffer I can see the

00:36:12,490 --> 00:36:19,560
tension building it gets it gets hotter

00:36:15,700 --> 00:36:21,520
and hotter doesn't it so I actually um I

00:36:19,560 --> 00:36:22,900
made a little bit of a simplification

00:36:21,520 --> 00:36:24,970
earlier when I showed how that

00:36:22,900 --> 00:36:28,840
background operation works doesn't

00:36:24,970 --> 00:36:30,160
really work how I described it did what

00:36:28,840 --> 00:36:32,770
we do is when we have to make a

00:36:30,160 --> 00:36:34,450
modification from the buffer pool to the

00:36:32,770 --> 00:36:37,480
tablespoon all space on disk is we

00:36:34,450 --> 00:36:40,840
actually do it twice we do it twice for

00:36:37,480 --> 00:36:42,490
safety because when a file system or the

00:36:40,840 --> 00:36:44,410
operating system in the layer below when

00:36:42,490 --> 00:36:46,780
we ask it to write something like 16 K

00:36:44,410 --> 00:36:49,810
of data it actually doesn't guarantee

00:36:46,780 --> 00:36:52,030
that a write 16 K of data it doesn't

00:36:49,810 --> 00:36:54,160
guarantee anything could fail halfway in

00:36:52,030 --> 00:36:55,900
between that operation and write the

00:36:54,160 --> 00:36:58,780
first half and then not the second half

00:36:55,900 --> 00:36:59,530
or complete garbage and it ODB doesn't

00:36:58,780 --> 00:37:02,590
like that idea

00:36:59,530 --> 00:37:04,270
it wants to be durable so what nodb does

00:37:02,590 --> 00:37:07,150
is if we look at this background

00:37:04,270 --> 00:37:10,120
operation first it writes in the buffer

00:37:07,150 --> 00:37:12,520
pool to the double write buffer it syncs

00:37:10,120 --> 00:37:16,810
the double write buffer to the

00:37:12,520 --> 00:37:19,150
tablespace when that operation has been

00:37:16,810 --> 00:37:22,570
synced it's doing this for about 64

00:37:19,150 --> 00:37:25,330
pages at a time then it's allowed to

00:37:22,570 --> 00:37:27,430
call that operation successful and it

00:37:25,330 --> 00:37:30,970
makes sure that it syncs to each of the

00:37:27,430 --> 00:37:33,070
individual destined pages if we had a

00:37:30,970 --> 00:37:35,680
crash before we've written to the double

00:37:33,070 --> 00:37:38,020
write buffer nothing is successful if we

00:37:35,680 --> 00:37:39,220
had a crash in between writing to the

00:37:38,020 --> 00:37:41,590
double ride buffer in each of these

00:37:39,220 --> 00:37:43,180
individual pages the first stage of

00:37:41,590 --> 00:37:46,930
crash recovery is restoring from the

00:37:43,180 --> 00:37:49,180
double write buffer that costs a little

00:37:46,930 --> 00:37:51,430
bit to be able to do that we're writing

00:37:49,180 --> 00:37:52,870
everything twice in in terms of hard

00:37:51,430 --> 00:37:55,060
drives it's probably like one mega

00:37:52,870 --> 00:37:56,710
sequential i/o here and then

00:37:55,060 --> 00:37:59,920
it's random over to this location so

00:37:56,710 --> 00:38:01,270
that cost might only be 10% more but if

00:37:59,920 --> 00:38:02,530
you're comparing you know DB to another

00:38:01,270 --> 00:38:04,480
database and you're saying that it's

00:38:02,530 --> 00:38:06,520
lower understand what problems it's

00:38:04,480 --> 00:38:10,450
trying to solve it wants to give you

00:38:06,520 --> 00:38:12,550
some promises and this is one of them so

00:38:10,450 --> 00:38:15,670
the implementation of this as it as it

00:38:12,550 --> 00:38:18,550
does this is it's about 2 Meg of IV data

00:38:15,670 --> 00:38:21,520
one is stored and reserved for double

00:38:18,550 --> 00:38:23,170
ride buffer the first part of running

00:38:21,520 --> 00:38:25,210
this buffer only one thread can do it

00:38:23,170 --> 00:38:26,740
and then the background process we can

00:38:25,210 --> 00:38:28,420
use multiple threads to be able to do

00:38:26,740 --> 00:38:30,580
that and I'll talk a little bit about

00:38:28,420 --> 00:38:33,010
this in my next section which is some

00:38:30,580 --> 00:38:36,310
advantages that nodb has for faster

00:38:33,010 --> 00:38:37,270
hardware so you want to use this buffer

00:38:36,310 --> 00:38:39,010
it's on by default

00:38:37,270 --> 00:38:40,150
why would you turn it off you don't need

00:38:39,010 --> 00:38:42,880
turn it off if you had something like

00:38:40,150 --> 00:38:44,260
ZFS there are very few file systems that

00:38:42,880 --> 00:38:46,600
the promise that a write will be

00:38:44,260 --> 00:38:50,050
successful edifis is one of the

00:38:46,600 --> 00:38:51,670
butterface on linux is another there's

00:38:50,050 --> 00:38:54,820
just some small caveat with its design

00:38:51,670 --> 00:38:56,650
and the smoke cavity is that actually it

00:38:54,820 --> 00:38:59,440
can cause a lot of ryedawg over to one

00:38:56,650 --> 00:39:01,840
central area and in the custom version

00:38:59,440 --> 00:39:03,430
of inner do be that the company I work

00:39:01,840 --> 00:39:09,220
for writes we actually have the ability

00:39:03,430 --> 00:39:13,140
to relocate that but we're on the last

00:39:09,220 --> 00:39:15,520
bit adaptive flushing I our scalability

00:39:13,140 --> 00:39:19,990
one of the nice things in your new inner

00:39:15,520 --> 00:39:21,370
DV that on in other databases so when

00:39:19,990 --> 00:39:25,630
we're talking about the background

00:39:21,370 --> 00:39:27,070
operation how much capacity do we use to

00:39:25,630 --> 00:39:29,890
be able to do that background operation

00:39:27,070 --> 00:39:32,320
of writing down those dirty pages the

00:39:29,890 --> 00:39:35,860
answer is is that we use 200 IUP's is

00:39:32,320 --> 00:39:38,560
the magic number in all in ODB releases

00:39:35,860 --> 00:39:41,170
5-1 above previous versions it was 100

00:39:38,560 --> 00:39:43,240
IUP's you can also now say this is a

00:39:41,170 --> 00:39:45,220
configuration setting to be able to say

00:39:43,240 --> 00:39:47,070
how much background work you can do I'll

00:39:45,220 --> 00:39:49,300
say well that's important in a second

00:39:47,070 --> 00:39:51,760
you can also say that you want to read

00:39:49,300 --> 00:39:53,680
and write in multiple threads and this

00:39:51,760 --> 00:39:57,250
is important for when my RAID controller

00:39:53,680 --> 00:39:59,230
has 10 disks in something like RAID 10 I

00:39:57,250 --> 00:40:01,420
can write to five of them once and I can

00:39:59,230 --> 00:40:03,130
read from 10 of them and I need to be

00:40:01,420 --> 00:40:04,690
able to set this otherwise I might not

00:40:03,130 --> 00:40:07,110
be able to extract all the capacity that

00:40:04,690 --> 00:40:07,110
it can offer

00:40:09,819 --> 00:40:14,380
we have also the ability to be able to

00:40:12,099 --> 00:40:16,480
tune some of these things with ire so

00:40:14,380 --> 00:40:18,849
that it we use SSDs we disabled read

00:40:16,480 --> 00:40:20,470
ahead and we can disable the request

00:40:18,849 --> 00:40:25,750
reordering merging that happens as part

00:40:20,470 --> 00:40:27,369
of the checkpoint what a benchmark won't

00:40:25,750 --> 00:40:28,930
show you where I said one of the inner

00:40:27,369 --> 00:40:32,950
divisions was consistent reliable

00:40:28,930 --> 00:40:35,020
performance is a benchmark will

00:40:32,950 --> 00:40:37,809
typically tell you something like I got

00:40:35,020 --> 00:40:39,369
so many queries per hour but it won't

00:40:37,809 --> 00:40:40,210
tell you of every query took the same

00:40:39,369 --> 00:40:42,190
amount of time

00:40:40,210 --> 00:40:44,880
now here's actually what I know to be

00:40:42,190 --> 00:40:49,630
used to look like a couple of years ago

00:40:44,880 --> 00:40:51,369
to show you how and why this is this is

00:40:49,630 --> 00:40:53,770
a problem in how we measure performance

00:40:51,369 --> 00:40:57,099
this is transactions per minute on an on

00:40:53,770 --> 00:40:59,980
a an inner DB system on this blue line

00:40:57,099 --> 00:41:02,410
we were doing 35 transactions per minute

00:40:59,980 --> 00:41:05,109
this looks really thirty-five thousand

00:41:02,410 --> 00:41:06,880
transactions per minute this looks like

00:41:05,109 --> 00:41:08,260
a really exciting number if you consider

00:41:06,880 --> 00:41:11,339
these transactions were actually quite

00:41:08,260 --> 00:41:13,780
complicated and riding a loaded totter

00:41:11,339 --> 00:41:15,880
we were doing this for quite a while and

00:41:13,780 --> 00:41:17,940
then all of the sudden our performance

00:41:15,880 --> 00:41:21,099
went to zero transactions per minute

00:41:17,940 --> 00:41:24,579
completely tanked nothing was happening

00:41:21,099 --> 00:41:25,960
on this server at that time at all these

00:41:24,579 --> 00:41:28,660
are different measurements but we've got

00:41:25,960 --> 00:41:31,059
rights on the server graphed on the same

00:41:28,660 --> 00:41:32,559
slide here and you can see what happens

00:41:31,059 --> 00:41:35,410
to the rights they just go through the

00:41:32,559 --> 00:41:38,500
roof all of the sudden and they go back

00:41:35,410 --> 00:41:40,720
to nothing again one of the interesting

00:41:38,500 --> 00:41:42,099
things with with I think the lack of of

00:41:40,720 --> 00:41:43,839
good benchmarks is the three port

00:41:42,099 --> 00:41:46,690
doesn't necessarily measure performance

00:41:43,839 --> 00:41:48,520
and when we do things like in the inner

00:41:46,690 --> 00:41:50,109
DB and in other databases we convert a

00:41:48,520 --> 00:41:52,420
lot of our work to background work and

00:41:50,109 --> 00:41:54,819
if we get behind in our background work

00:41:52,420 --> 00:41:56,260
we can get in trouble this is actually

00:41:54,819 --> 00:41:58,270
something that's happening in you know

00:41:56,260 --> 00:42:00,760
DB because our load file is getting full

00:41:58,270 --> 00:42:02,950
we have no more pending space in our log

00:42:00,760 --> 00:42:04,630
file to be able to make modifications so

00:42:02,950 --> 00:42:07,290
we have to free the log before we can

00:42:04,630 --> 00:42:10,809
create more space and do what work

00:42:07,290 --> 00:42:13,299
energy B solves this a lot better now

00:42:10,809 --> 00:42:16,119
what it does is it has a nice consistent

00:42:13,299 --> 00:42:17,770
flat line the less log file space that

00:42:16,119 --> 00:42:19,299
you have available the more work it does

00:42:17,770 --> 00:42:20,859
it just cranks up the work straightaway

00:42:19,299 --> 00:42:23,470
and you

00:42:20,859 --> 00:42:26,440
also specify how much background work

00:42:23,470 --> 00:42:28,180
you can do so that line that was at the

00:42:26,440 --> 00:42:31,089
bottom would just be higher all the time

00:42:28,180 --> 00:42:35,769
I would much rather have on my server a

00:42:31,089 --> 00:42:38,319
lower line that more flat than this high

00:42:35,769 --> 00:42:40,499
line even if it means worse performance

00:42:38,319 --> 00:42:42,579
if we measure something like

00:42:40,499 --> 00:42:45,190
transactions per minute or transactions

00:42:42,579 --> 00:42:48,220
per hour it's not reciprocal to say what

00:42:45,190 --> 00:42:50,230
time each transaction took and it's not

00:42:48,220 --> 00:42:53,109
a good idea to measure the average time

00:42:50,230 --> 00:42:55,119
for a transaction either you want 99% of

00:42:53,109 --> 00:42:57,249
all transactions to take the same amount

00:42:55,119 --> 00:42:59,079
of time measuring the average time for a

00:42:57,249 --> 00:43:00,609
transaction is like measuring the

00:42:59,079 --> 00:43:02,829
average temperature of a patient in the

00:43:00,609 --> 00:43:04,150
hospital you'll see there's a lot of

00:43:02,829 --> 00:43:06,039
healthy people you won't see that

00:43:04,150 --> 00:43:08,410
there's a lot of people that dine there

00:43:06,039 --> 00:43:14,559
suffering and in ER DB has nice flat

00:43:08,410 --> 00:43:16,509
performance so as we sort of get towards

00:43:14,559 --> 00:43:19,210
the end I want to draw this picture

00:43:16,509 --> 00:43:21,400
again I want to talk about the basic

00:43:19,210 --> 00:43:22,900
algorithm if you learn one thing you

00:43:21,400 --> 00:43:24,579
learn this one and I'm going to draw in

00:43:22,900 --> 00:43:26,980
some optimizations that are possible I

00:43:24,579 --> 00:43:28,630
was talking about algorithms today that

00:43:26,980 --> 00:43:30,220
was the intention of my talk but I'll

00:43:28,630 --> 00:43:33,190
give you some performance optimization

00:43:30,220 --> 00:43:35,140
that you can make out of it so let's do

00:43:33,190 --> 00:43:37,029
an update operation again we'll skip the

00:43:35,140 --> 00:43:39,009
Select we've just loaded some data in

00:43:37,029 --> 00:43:43,059
memory we're going to do an update

00:43:39,009 --> 00:43:46,359
operation on these pages here this

00:43:43,059 --> 00:43:47,710
update operation results in what was the

00:43:46,359 --> 00:43:51,279
name of the terminology that I had for

00:43:47,710 --> 00:43:53,440
this modification a dirty page and then

00:43:51,279 --> 00:43:56,499
we record history of this dirty page to

00:43:53,440 --> 00:43:59,710
the log file the Loeb file IO is

00:43:56,499 --> 00:44:01,089
typically aligned to 512 bytes it's

00:43:59,710 --> 00:44:03,009
really just the smallest amount of

00:44:01,089 --> 00:44:06,700
information to be able to remember this

00:44:03,009 --> 00:44:09,880
modification in the background we have

00:44:06,700 --> 00:44:13,210
to write down that dirty page to the

00:44:09,880 --> 00:44:15,910
tablespace that background operation is

00:44:13,210 --> 00:44:18,339
referred to as a checkpoint when that

00:44:15,910 --> 00:44:19,989
happens doesn't concern you but if you

00:44:18,339 --> 00:44:25,119
get too far behind in that work you have

00:44:19,989 --> 00:44:27,609
to boost your i/o capacity sample and we

00:44:25,119 --> 00:44:29,859
write that page the tablespace and now

00:44:27,609 --> 00:44:32,079
we have the opportunity to make space

00:44:29,859 --> 00:44:33,609
free here if we needed to we also have

00:44:32,079 --> 00:44:34,810
another statistic to be able to know

00:44:33,609 --> 00:44:38,290
which of the clean pages

00:44:34,810 --> 00:44:40,750
and make space if we have to so this

00:44:38,290 --> 00:44:42,400
buffer pool is in memory the sizing

00:44:40,750 --> 00:44:46,200
recommendation for this buffer pool is

00:44:42,400 --> 00:44:48,760
about 50 to 80 percent of system memory

00:44:46,200 --> 00:44:49,540
what's the default sitting eight

00:44:48,760 --> 00:44:51,520
megabytes

00:44:49,540 --> 00:44:54,400
how many people have 12 megabytes of

00:44:51,520 --> 00:44:56,050
memory nobody what's the performance

00:44:54,400 --> 00:44:58,690
like if you set it to this setting maybe

00:44:56,050 --> 00:45:00,940
50 times better really matters you know

00:44:58,690 --> 00:45:03,070
DB it's more complex design and you have

00:45:00,940 --> 00:45:06,130
to tune it for it to be able to get good

00:45:03,070 --> 00:45:07,570
performance okay what was the

00:45:06,130 --> 00:45:10,920
recommendation that I had for the log

00:45:07,570 --> 00:45:14,370
files what changes could we make there I

00:45:10,920 --> 00:45:17,920
could make it bigger

00:45:14,370 --> 00:45:20,500
yeah and that was this sitting here make

00:45:17,920 --> 00:45:22,060
it bigger I can get further behind if I

00:45:20,500 --> 00:45:24,310
can get further behind I can smooth out

00:45:22,060 --> 00:45:26,980
my load and I can do more request

00:45:24,310 --> 00:45:28,180
reordering and merging as well and the

00:45:26,980 --> 00:45:29,650
merging happens because we're probably

00:45:28,180 --> 00:45:32,950
going to be updating the same pages

00:45:29,650 --> 00:45:34,150
approximately more than once and we only

00:45:32,950 --> 00:45:36,340
have to write them down to the

00:45:34,150 --> 00:45:39,970
tablespace once by having a bigger load

00:45:36,340 --> 00:45:41,320
file in more time okay there was another

00:45:39,970 --> 00:45:42,940
sitting that I could change with the log

00:45:41,320 --> 00:45:45,640
file does anyone remember that the name

00:45:42,940 --> 00:45:52,180
of this saying something about your

00:45:45,640 --> 00:45:54,430
ability yes I can set this one you know

00:45:52,180 --> 00:45:57,760
to be flush logger t-rex commit by

00:45:54,430 --> 00:45:58,990
default it's 1 which means fully durable

00:45:57,760 --> 00:46:01,510
if someone says commit I've got a

00:45:58,990 --> 00:46:03,670
guarantee I've got that data they were

00:46:01,510 --> 00:46:06,280
using cheap hardware we might want to

00:46:03,670 --> 00:46:07,840
set this to something like zero to two

00:46:06,280 --> 00:46:13,050
is just a little bit safer it just means

00:46:07,840 --> 00:46:16,630
you lose earning a second of totter okay

00:46:13,050 --> 00:46:18,910
this one I haven't described yet but if

00:46:16,630 --> 00:46:20,500
we do have a RAID controller we might

00:46:18,910 --> 00:46:22,120
want to ask the operating system not to

00:46:20,500 --> 00:46:24,100
do its request reordering merging

00:46:22,120 --> 00:46:25,930
because it doesn't understand much about

00:46:24,100 --> 00:46:27,340
my disks in the i/o system underneath

00:46:25,930 --> 00:46:29,350
and the RAID controller probably does a

00:46:27,340 --> 00:46:31,090
better system and we don't want it to

00:46:29,350 --> 00:46:33,010
buffer the reads as well so we can ask

00:46:31,090 --> 00:46:36,870
the operating system just to direct i/o

00:46:33,010 --> 00:46:39,130
as it's reading and writing files and

00:46:36,870 --> 00:46:40,240
you typically only do this if you had a

00:46:39,130 --> 00:46:42,250
RAID controller and the RAID controller

00:46:40,240 --> 00:46:44,790
could do its own merging and all of them

00:46:42,250 --> 00:46:44,790
do a great job

00:46:45,549 --> 00:46:50,169
and the last possible optimization that

00:46:48,009 --> 00:46:53,649
we could make here is that we can move

00:46:50,169 --> 00:46:56,679
all of the log files to a separate set

00:46:53,649 --> 00:46:58,859
of spindles so the log files is

00:46:56,679 --> 00:47:01,119
sequential i/o we just keep appending I

00:46:58,859 --> 00:47:02,289
would typically recommend this only if

00:47:01,119 --> 00:47:04,179
you have a lot of disks

00:47:02,289 --> 00:47:06,219
I wouldn't typically recommend it if you

00:47:04,179 --> 00:47:08,289
just have two disks for your tablespace

00:47:06,219 --> 00:47:10,959
and two for your log file because the

00:47:08,289 --> 00:47:13,449
lobe file i/o is so much fewer but if

00:47:10,959 --> 00:47:15,429
you had maybe 10 disks you could put 2

00:47:13,449 --> 00:47:17,049
towards your log file and and 8 towards

00:47:15,429 --> 00:47:23,380
your data and that would be a perfectly

00:47:17,049 --> 00:47:26,349
fine optimization the last optimization

00:47:23,380 --> 00:47:28,390
here that I didn't really draw and I had

00:47:26,349 --> 00:47:30,759
a briefly on the slide was actually

00:47:28,390 --> 00:47:32,979
there's a buffer that gets filled before

00:47:30,759 --> 00:47:34,539
we ride to the log file and you can tell

00:47:32,979 --> 00:47:36,969
if that buffer is too small

00:47:34,539 --> 00:47:38,979
if you ever see in I show global status

00:47:36,969 --> 00:47:40,239
that you've got log weights and you'll

00:47:38,979 --> 00:47:44,349
typically only see that if you're

00:47:40,239 --> 00:47:46,299
writing lots of texts and blobs so with

00:47:44,349 --> 00:47:48,849
that I'm going to to close and say I

00:47:46,299 --> 00:47:51,369
hope you enjoyed this might be a little

00:47:48,849 --> 00:47:55,539
bit of a non Santa talk I don't think I

00:47:51,369 --> 00:47:58,349
said PHP once and if you have questions

00:47:55,539 --> 00:47:58,349
would be happy to answer

00:48:02,720 --> 00:48:07,160
all right that's a great question sir

00:48:05,530 --> 00:48:10,339
sure sir

00:48:07,160 --> 00:48:13,099
this design of in our DB really supports

00:48:10,339 --> 00:48:16,730
doing hot backups which is non-blocking

00:48:13,099 --> 00:48:17,900
backups and there are two tools that do

00:48:16,730 --> 00:48:19,670
this one is called MySQL Enterprise

00:48:17,900 --> 00:48:21,349
backup it was formerly called you know

00:48:19,670 --> 00:48:23,270
to be hot backup it's a commercial tool

00:48:21,349 --> 00:48:24,829
when it's called extra backup which we

00:48:23,270 --> 00:48:26,540
write they both do the same thing the

00:48:24,829 --> 00:48:30,260
extra backup one is free and open source

00:48:26,540 --> 00:48:32,390
and good so what it does to be able to

00:48:30,260 --> 00:48:34,849
back up is it backs up your tablespace

00:48:32,390 --> 00:48:36,020
it does a dirty read of your tablespace

00:48:34,849 --> 00:48:38,119
because there are changes happening at

00:48:36,020 --> 00:48:39,589
the same time but the same time is doing

00:48:38,119 --> 00:48:41,150
the backup it watch watches the Loeb

00:48:39,589 --> 00:48:43,250
file because it conceal the

00:48:41,150 --> 00:48:44,390
modifications that are happening and

00:48:43,250 --> 00:48:47,180
when it's finished backing up the

00:48:44,390 --> 00:48:48,890
tablespace it can of its pending changes

00:48:47,180 --> 00:48:51,319
that are watched in the log file reapply

00:48:48,890 --> 00:48:54,319
them and you can do a backup of inner TV

00:48:51,319 --> 00:48:56,750
without blocking anyone just by that

00:48:54,319 --> 00:48:58,760
nice mechanism extra backup is the piece

00:48:56,750 --> 00:49:02,950
of software you want to use in order to

00:48:58,760 --> 00:49:06,020
be is what do you mean that for file

00:49:02,950 --> 00:49:07,790
yeah it's it's a raw backup it's not

00:49:06,020 --> 00:49:09,680
it's not a logical backup it's not my

00:49:07,790 --> 00:49:11,780
skill down so it's very fast to be able

00:49:09,680 --> 00:49:18,589
to restore you know being much better to

00:49:11,780 --> 00:49:21,560
backup than my eysan you you talked

00:49:18,589 --> 00:49:25,130
about nbcc sure we all know that it's

00:49:21,560 --> 00:49:27,920
awesome because it allows non-blocking

00:49:25,130 --> 00:49:32,690
reads yes what you didn't mention is the

00:49:27,920 --> 00:49:35,900
drawbacks of having MVCC no need for

00:49:32,690 --> 00:49:38,660
compaction because of course you're not

00:49:35,900 --> 00:49:42,440
having okay serabian right basically

00:49:38,660 --> 00:49:44,839
you're sort of not in this is my

00:49:42,440 --> 00:49:45,920
understanding sure sir I'll cut off an

00:49:44,839 --> 00:49:47,839
explain briefly and then we can have a

00:49:45,920 --> 00:49:49,760
chat and keep your so in ODB doesn't

00:49:47,839 --> 00:49:52,310
update in place and it does a relocation

00:49:49,760 --> 00:49:54,710
of the old data John do space so it

00:49:52,310 --> 00:49:57,650
doesn't have for the data a need for

00:49:54,710 --> 00:50:00,109
compaction and potentially this update

00:49:57,650 --> 00:50:01,849
could be more expensive potentially in

00:50:00,109 --> 00:50:04,819
reality it's not too bad because it's

00:50:01,849 --> 00:50:07,040
just a logical operation to relocate to

00:50:04,819 --> 00:50:08,980
a new space which results in a dirty

00:50:07,040 --> 00:50:10,640
page and in a typical

00:50:08,980 --> 00:50:12,410
transactional system where the

00:50:10,640 --> 00:50:13,970
transactions are fairly short it's

00:50:12,410 --> 00:50:16,010
probably deleted that undo space before

00:50:13,970 --> 00:50:18,290
it wrote the dirty page out

00:50:16,010 --> 00:50:21,320
so in ODB's implementation is quite good

00:50:18,290 --> 00:50:22,850
for MVCC my opinion there are other

00:50:21,320 --> 00:50:24,619
systems that just do append-only and

00:50:22,850 --> 00:50:26,240
they do have this compaction problem

00:50:24,619 --> 00:50:28,010
there's only a small exception to that

00:50:26,240 --> 00:50:30,140
which is you know jeebies indexes

00:50:28,010 --> 00:50:32,780
actually all can contain all rows or

00:50:30,140 --> 00:50:45,440
versions and that can result in some

00:50:32,780 --> 00:50:48,380
fragmentation your indexes well this is

00:50:45,440 --> 00:50:51,200
a I think I was known problem up my

00:50:48,380 --> 00:50:53,660
sequel that it grows quite large so you

00:50:51,200 --> 00:50:56,119
have to either dump the entire database

00:50:53,660 --> 00:51:00,080
and rebuild the database to reclaim

00:50:56,119 --> 00:51:04,390
space or you use tricks like you alter

00:51:00,080 --> 00:51:08,630
table to a force and online compaction

00:51:04,390 --> 00:51:11,210
so yeah I I'll say that a lot of people

00:51:08,630 --> 00:51:14,000
that say optimizing my isin MySQL tables

00:51:11,210 --> 00:51:17,930
a lot of the time they're wrong

00:51:14,000 --> 00:51:19,609
okay they my opinion I could carry this

00:51:17,930 --> 00:51:21,230
offline and say why they're they're

00:51:19,609 --> 00:51:23,359
wrong but you know to be deliberately

00:51:21,230 --> 00:51:26,180
insert some gaps as well it really fills

00:51:23,359 --> 00:51:27,290
pages 93% full so that updates can

00:51:26,180 --> 00:51:30,550
happen it's okay to have some

00:51:27,290 --> 00:51:32,540
fragmentation just optimizing your table

00:51:30,550 --> 00:51:35,570
unnecessarily is a really bad thing to

00:51:32,540 --> 00:51:37,820
do we release extra backup extra backup

00:51:35,570 --> 00:51:40,970
has a tool to be able to do extra backup

00:51:37,820 --> 00:51:43,850
- - stats on an inner DV data file and

00:51:40,970 --> 00:51:44,720
tell you the fragmentation and I think

00:51:43,850 --> 00:51:46,040
most people that are probably

00:51:44,720 --> 00:51:48,380
defragmenting probably don't have

00:51:46,040 --> 00:51:55,640
fragmentation okay just make me feel so

00:51:48,380 --> 00:51:57,890
feel happy Thanks okay good talk thank

00:51:55,640 --> 00:52:01,180
you um just out of interest what what

00:51:57,890 --> 00:52:04,670
structure is the hot spot hot spot some

00:52:01,180 --> 00:52:08,840
structure okay Oh like the adaptive hash

00:52:04,670 --> 00:52:12,410
or it's it's a hash so it's just it's a

00:52:08,840 --> 00:52:13,850
hash of in ODB 16k pages it's never

00:52:12,410 --> 00:52:18,400
actually written down to disk it's only

00:52:13,850 --> 00:52:22,760
a memory resident representation but

00:52:18,400 --> 00:52:25,420
lots of things have hotspots adaptive

00:52:22,760 --> 00:52:27,950
hashes in acceleration for a hotspot

00:52:25,420 --> 00:52:29,780
b-trees themself as the structure very

00:52:27,950 --> 00:52:31,940
good for hotspots

00:52:29,780 --> 00:52:34,430
much better than say a hash cell

00:52:31,940 --> 00:52:35,810
structure that some other newer database

00:52:34,430 --> 00:52:41,870
is used where you have to have a hundred

00:52:35,810 --> 00:52:43,520
percent memory fit what optimizations

00:52:41,870 --> 00:52:46,070
would you recommend for running all this

00:52:43,520 --> 00:52:48,260
on SSDs for example how'd you get a

00:52:46,070 --> 00:52:51,290
decent handle on your iOS per second

00:52:48,260 --> 00:52:56,000
what was your recommended approach yeah

00:52:51,290 --> 00:52:59,810
um complicated answer some simple things

00:52:56,000 --> 00:53:02,360
I can explain those settings specifying

00:52:59,810 --> 00:53:04,220
to do more background work at once more

00:53:02,360 --> 00:53:06,530
expensive SSDs need many read and write

00:53:04,220 --> 00:53:10,640
threads to be able to exploit all of the

00:53:06,530 --> 00:53:14,210
I hopes that they can offer that's the

00:53:10,640 --> 00:53:18,380
that's a simple answer I I'll probably

00:53:14,210 --> 00:53:20,330
cover that it's not visible from

00:53:18,380 --> 00:53:22,400
perspective of you know the base

00:53:20,330 --> 00:53:26,120
architecture to support four separate

00:53:22,400 --> 00:53:28,340
i/o on data files and we especially we

00:53:26,120 --> 00:53:31,190
have different characteristics I can

00:53:28,340 --> 00:53:33,110
imagine like for example move some files

00:53:31,190 --> 00:53:36,040
to the separate hard drive sibling then

00:53:33,110 --> 00:53:37,910
it is amazing red to the fine directory

00:53:36,040 --> 00:53:41,210
is it possible to have multiple

00:53:37,910 --> 00:53:43,460
mechanisms like multiple is a multi be

00:53:41,210 --> 00:53:47,990
sets of buffers for every separate set

00:53:43,460 --> 00:53:50,980
of i/o simple answer no more complex

00:53:47,990 --> 00:53:50,980
answer yes possibly

00:53:51,610 --> 00:53:57,410
so MySQL 5.5 has multiple buffer pools

00:53:55,000 --> 00:54:00,380
they did this to be able to reduce

00:53:57,410 --> 00:54:03,500
locking server locking mutex contention

00:54:00,380 --> 00:54:06,350
but it's half way the way there to be

00:54:03,500 --> 00:54:08,270
able to have separate priorities of

00:54:06,350 --> 00:54:09,650
those buffer pools waiting on someone to

00:54:08,270 --> 00:54:13,010
maybe write a patch to enhancement for

00:54:09,650 --> 00:54:15,140
it I can see it coming I don't know any

00:54:13,010 --> 00:54:20,600
work yet there and I can't comment for

00:54:15,140 --> 00:54:23,360
our course engineering hi and how does

00:54:20,600 --> 00:54:26,180
in a DB get on with things like

00:54:23,360 --> 00:54:27,890
partitioning and using file per table

00:54:26,180 --> 00:54:30,590
and partitioning scalars and things as

00:54:27,890 --> 00:54:32,240
well interesting performance yes sir no

00:54:30,590 --> 00:54:33,770
DB actually has no understanding of

00:54:32,240 --> 00:54:35,630
petitioning that happens that the layer

00:54:33,770 --> 00:54:39,730
above the storage engine so it handles

00:54:35,630 --> 00:54:41,810
it as multiple different tables one

00:54:39,730 --> 00:54:43,130
sometimes dog more complicated

00:54:41,810 --> 00:54:44,750
discussion is some

00:54:43,130 --> 00:54:49,010
people think that having more files is

00:54:44,750 --> 00:54:52,520
is faster than having one big file it's

00:54:49,010 --> 00:54:54,860
not really true it turns out to be true

00:54:52,520 --> 00:54:56,660
with xt3 when you're using Oh direct one

00:54:54,860 --> 00:54:59,030
of my suggested optimizations because Oh

00:54:56,660 --> 00:55:00,980
direct will serialize multiple writes in

00:54:59,030 --> 00:55:03,140
a file to be one right thread to the

00:55:00,980 --> 00:55:05,900
layer below and that's a real problem

00:55:03,140 --> 00:55:11,480
that a good file system I XFS doesn't

00:55:05,900 --> 00:55:13,730
have but you know it works like anything

00:55:11,480 --> 00:55:15,380
else does I guess internally has no

00:55:13,730 --> 00:55:18,010
knowledge of petitioning but it can take

00:55:15,380 --> 00:55:18,010
advantage of it

00:55:26,760 --> 00:55:31,120
sorry our strategy has been we've got

00:55:29,440 --> 00:55:33,820
enough RAM to put our whole database in

00:55:31,120 --> 00:55:35,590
RAM so do you if you could offer some

00:55:33,820 --> 00:55:38,170
comment about with SSD drives are still

00:55:35,590 --> 00:55:41,800
variable in that case or yes so the

00:55:38,170 --> 00:55:44,290
question is is I kind of paraphrasing um

00:55:41,800 --> 00:55:47,440
I could buy lots of memory or I could

00:55:44,290 --> 00:55:49,570
buy SSDs what should I do if you can fit

00:55:47,440 --> 00:55:51,760
all your data in memory by memory

00:55:49,570 --> 00:55:54,130
absolutely without a doubt smartest

00:55:51,760 --> 00:55:56,500
decision if I go back I'm gonna have to

00:55:54,130 --> 00:55:58,030
go back a lot of slides to show that the

00:55:56,500 --> 00:55:59,500
numbers everybody should know that I

00:55:58,030 --> 00:56:01,590
sourced from the Google presentation I

00:55:59,500 --> 00:56:03,550
can point in whereas this teaser and

00:56:01,590 --> 00:56:05,320
everyone talks about how fast they are

00:56:03,550 --> 00:56:07,000
but they're slower than memory plus you

00:56:05,320 --> 00:56:08,740
know DB has to do its page recycling

00:56:07,000 --> 00:56:11,170
thing where it has to revalidate the

00:56:08,740 --> 00:56:14,140
checksum in whatever and that has its

00:56:11,170 --> 00:56:16,510
own set of problems sir you want more

00:56:14,140 --> 00:56:18,520
memory first the SSDs will help you

00:56:16,510 --> 00:56:21,760
there with writes which more memory will

00:56:18,520 --> 00:56:24,090
not help you with so we're gonna maybe

00:56:21,760 --> 00:56:27,490
memory reference is 100 nanoseconds and

00:56:24,090 --> 00:56:36,010
probably around here maybe 50,000 90

00:56:27,490 --> 00:56:38,140
seconds is something like NAND flash so

00:56:36,010 --> 00:56:42,580
we got to ish minutes yeah I think so

00:56:38,140 --> 00:56:46,980
alright okay no more questions

00:56:42,580 --> 00:56:46,980

YouTube URL: https://www.youtube.com/watch?v=adDSvfW12Lc


