Title: PHP UK Conference 2017 - Derick Rethans - Its All About The Goto
Publication date: 2017-04-03
Playlist: PHP UK Conference 2017
Description: 
	Don't worry, this is not about the goto keyword. In this presentation, I am showing you some of the inner workings of PHP. We are going to look at how different language keywords and constructs are handled internally. Basically, everything is converted to goto, but the how and why, is not as simple as it seems! This is a very in depth talk, mostly interesting to people that want to know how PHP works internally. Expect lots of wonkyness, a form of assembly, and trees.
Captions: 
	00:00:04,050 --> 00:00:08,370
good morning it's bright and early for

00:00:07,920 --> 00:00:12,600
me

00:00:08,370 --> 00:00:14,730
not really but nearly lunchtime I'll be

00:00:12,600 --> 00:00:17,070
talking in the slopes about it's all

00:00:14,730 --> 00:00:20,009
about to go to that has very little to

00:00:17,070 --> 00:00:21,449
do with the evil word itself we can have

00:00:20,009 --> 00:00:26,279
a discussion about that later if you

00:00:21,449 --> 00:00:28,890
want this is very technical that's

00:00:26,279 --> 00:00:31,079
probably why you're here if I'm going to

00:00:28,890 --> 00:00:33,510
false explaining anything really please

00:00:31,079 --> 00:00:37,199
let me know because if you miss one part

00:00:33,510 --> 00:00:39,750
and you get lost then yeah then you sort

00:00:37,199 --> 00:00:41,910
of get both totally so please let me

00:00:39,750 --> 00:00:44,940
know if something isn't clear or I

00:00:41,910 --> 00:00:47,489
haven't explained it properly I'm Derek

00:00:44,940 --> 00:00:49,829
I am European long story talk to me

00:00:47,489 --> 00:00:52,469
about it later so living here in London

00:00:49,829 --> 00:00:54,000
so this is my local conference I work

00:00:52,469 --> 00:00:56,010
for among going to be on the PHP driver

00:00:54,000 --> 00:00:56,969
for that I will not be talking anything

00:00:56,010 --> 00:00:59,249
about it web server

00:00:56,969 --> 00:01:02,309
let's actual Bloodshy at least mention

00:00:59,249 --> 00:01:04,019
it I'm you're also speech PD burger

00:01:02,309 --> 00:01:06,750
called XV book which you might have

00:01:04,019 --> 00:01:08,370
heard of at some points and small things

00:01:06,750 --> 00:01:10,380
I like maps I like there I also like

00:01:08,370 --> 00:01:13,500
whisky but my son doesn't have an icon

00:01:10,380 --> 00:01:15,750
for that so if there's any comments also

00:01:13,500 --> 00:01:18,180
let me know later I'm happy to read the

00:01:15,750 --> 00:01:19,800
comments later alright so let's get

00:01:18,180 --> 00:01:20,850
started we took going to talk about few

00:01:19,800 --> 00:01:23,010
different things you're going to solve

00:01:20,850 --> 00:01:25,350
what stages conversion stages and the

00:01:23,010 --> 00:01:27,810
conclusion that was quite isn't it let's

00:01:25,350 --> 00:01:30,180
get started so the stages what I mean

00:01:27,810 --> 00:01:32,760
here is the stages in how PHP executes

00:01:30,180 --> 00:01:34,590
code from the start on when it starts

00:01:32,760 --> 00:01:37,470
reading your code until it is done

00:01:34,590 --> 00:01:40,140
executing it or not on executing that

00:01:37,470 --> 00:01:42,600
world is executing it so there's four

00:01:40,140 --> 00:01:46,110
main stages the fourth first one is it

00:01:42,600 --> 00:01:48,360
parses your scripts just converted it

00:01:46,110 --> 00:01:51,300
into tokens explain what all the steps

00:01:48,360 --> 00:01:54,030
mean in great detail after this then

00:01:51,300 --> 00:01:55,800
from the parse scripts we creating a

00:01:54,030 --> 00:01:58,140
logical representation and it's

00:01:55,800 --> 00:02:00,570
something we call as a comp pronounce

00:01:58,140 --> 00:02:01,920
the word abstract syntax tree seven

00:02:00,570 --> 00:02:05,010
hundred times in the talk so I'm going

00:02:01,920 --> 00:02:08,640
to call it a SC for now so we converted

00:02:05,010 --> 00:02:09,149
tokens into an ast and I'll also explain

00:02:08,640 --> 00:02:10,800
what that is

00:02:09,149 --> 00:02:14,220
then we create some executable code out

00:02:10,800 --> 00:02:14,730
of that where we convert the ast into

00:02:14,220 --> 00:02:16,590
opcodes

00:02:14,730 --> 00:02:17,230
and then we're going to execute this

00:02:16,590 --> 00:02:19,720
bytecode

00:02:17,230 --> 00:02:21,519
and I will show you that resolve course

00:02:19,720 --> 00:02:23,950
okay so let's have a look at the first

00:02:21,519 --> 00:02:25,930
thing this is the parsing stage it's PHP

00:02:23,950 --> 00:02:28,660
sees your scripts it does the following

00:02:25,930 --> 00:02:31,030
thing what this actually does it

00:02:28,660 --> 00:02:34,050
tokenize the script into smaller bits so

00:02:31,030 --> 00:02:37,420
that something can make you to make any

00:02:34,050 --> 00:02:38,980
use of what is actually self and the way

00:02:37,420 --> 00:02:41,319
this works is it's a very big state

00:02:38,980 --> 00:02:42,970
machine starting with initial I can show

00:02:41,319 --> 00:02:46,120
you that actually because who doesn't

00:02:42,970 --> 00:02:47,769
like live demos this is big enough for

00:02:46,120 --> 00:02:49,180
people in the back that's big enough for

00:02:47,769 --> 00:02:52,150
me but not serious

00:02:49,180 --> 00:02:53,130
alright so I really could do a tree

00:02:52,150 --> 00:02:55,599
Hansa song

00:02:53,130 --> 00:02:58,269
so basically where it starts it starts

00:02:55,599 --> 00:02:59,829
in this stage called initial initial is

00:02:58,269 --> 00:03:01,360
basically the start of your script

00:02:59,829 --> 00:03:04,810
nothing has happened so if you have HTML

00:03:01,360 --> 00:03:06,910
in it that be also initial and any

00:03:04,810 --> 00:03:09,280
keywords can change the state to all the

00:03:06,910 --> 00:03:12,519
states so the first one we have the PHP

00:03:09,280 --> 00:03:14,860
opening tag it starts this new state

00:03:12,519 --> 00:03:16,269
called st in scripting and SC in

00:03:14,860 --> 00:03:18,640
scripting basic needs we're currently

00:03:16,269 --> 00:03:20,579
parsing PHP code now there's very

00:03:18,640 --> 00:03:24,940
different things in there as well so if

00:03:20,579 --> 00:03:30,940
we for example Luke should have set a

00:03:24,940 --> 00:03:36,819
bookmark area and where did it go

00:03:30,940 --> 00:03:38,470
and it shows so does SC in scripting so

00:03:36,819 --> 00:03:39,190
are just keyboard is angle the situation

00:03:38,470 --> 00:03:41,530
archetype it

00:03:39,190 --> 00:03:42,819
you also get things like st double

00:03:41,530 --> 00:03:44,079
quotes so the moment you see double

00:03:42,819 --> 00:03:45,880
quote who goes through different stage

00:03:44,079 --> 00:03:48,430
because the parsing rules within a

00:03:45,880 --> 00:03:49,930
string are different than any normal PHP

00:03:48,430 --> 00:03:52,000
code right because there is like desire

00:03:49,930 --> 00:03:53,980
versus this unit which you don't have a

00:03:52,000 --> 00:03:56,049
normal PHP code at least not in the

00:03:53,980 --> 00:03:58,389
exact same way so this is how to work it

00:03:56,049 --> 00:04:00,069
reads its Oakland and base or the token

00:03:58,389 --> 00:04:04,269
it can sometimes enter a different state

00:04:00,069 --> 00:04:06,280
well it gets out of this in the end it's

00:04:04,269 --> 00:04:07,989
basically a stream of tokens but no

00:04:06,280 --> 00:04:09,970
meaning is given to this tokens yet so

00:04:07,989 --> 00:04:12,370
PHP doesn't know what they actually do

00:04:09,970 --> 00:04:14,829
they're just names for bits of your code

00:04:12,370 --> 00:04:16,329
and PHP confer to tokenize accenture it

00:04:14,829 --> 00:04:19,150
makes it kind of handy and easy to

00:04:16,329 --> 00:04:20,560
visualize what it does so let's have a

00:04:19,150 --> 00:04:22,150
look an example script this is very

00:04:20,560 --> 00:04:24,610
simple stupid class that doesn't do

00:04:22,150 --> 00:04:26,020
anything at Randall's io is how much our

00:04:24,610 --> 00:04:27,520
project which I'm trying to pluck a

00:04:26,020 --> 00:04:29,570
little bit if you like whiskey and rum

00:04:27,520 --> 00:04:30,950
your website

00:04:29,570 --> 00:04:33,500
that's all I want to talk about the lm-2

00:04:30,950 --> 00:04:36,020
talk about how what happens so this is a

00:04:33,500 --> 00:04:38,540
script it has a namespace declaration as

00:04:36,020 --> 00:04:40,670
a class name in it and so on and so on

00:04:38,540 --> 00:04:42,860
it doesn't really do anything useful

00:04:40,670 --> 00:04:47,840
whatsoever but it's just amazing the

00:04:42,860 --> 00:04:49,550
example here so what comes out of the

00:04:47,840 --> 00:04:52,640
tokenizer is the following thing right

00:04:49,550 --> 00:04:54,860
so you can see that the first thing here

00:04:52,640 --> 00:04:58,160
in the script is Europe eat your open

00:04:54,860 --> 00:05:00,910
tag so that's why I get T open tag if

00:04:58,160 --> 00:05:03,500
there's anything more than a character

00:05:00,910 --> 00:05:04,700
the tokenizer will give you two things

00:05:03,500 --> 00:05:06,020
it will give you the names that dog or

00:05:04,700 --> 00:05:08,690
others will give you the token number

00:05:06,020 --> 00:05:10,460
that you can convert and then also the

00:05:08,690 --> 00:05:12,260
contents of it so if it's a string like

00:05:10,460 --> 00:05:14,780
TL contact is a string with four

00:05:12,260 --> 00:05:16,970
character of five characters you get a

00:05:14,780 --> 00:05:18,800
namespace key word which is a token you

00:05:16,970 --> 00:05:20,630
get the white space is also token but

00:05:18,800 --> 00:05:21,830
I've sort of ignore that vehicles its

00:05:20,630 --> 00:05:24,830
white space it doesn't matter

00:05:21,830 --> 00:05:27,800
it gets T string for just saying there's

00:05:24,830 --> 00:05:30,560
a string so this moment when PHP reads

00:05:27,800 --> 00:05:32,450
namespace drama aisle it doesn't know

00:05:30,560 --> 00:05:34,400
that drama i/o is actually the name of a

00:05:32,450 --> 00:05:36,800
namespace it just sees its this string

00:05:34,400 --> 00:05:38,510
and only later stages it just do

00:05:36,800 --> 00:05:40,190
something with us he has a whole bunch

00:05:38,510 --> 00:05:43,130
of other things so you have to t private

00:05:40,190 --> 00:05:45,020
T variable T function topo2 operator t

00:05:43,130 --> 00:05:46,400
palma Anoka ditalion if you have ever

00:05:45,020 --> 00:05:47,660
seen is really long keyword that means

00:05:46,400 --> 00:05:52,790
the whole double colon and Hebrew

00:05:47,660 --> 00:05:55,790
no family index at a time I I practice

00:05:52,790 --> 00:05:58,070
pronouncing on the future so yes

00:05:55,790 --> 00:06:00,170
definitely do that and so on so this is

00:05:58,070 --> 00:06:02,000
yeah what comes out is its organizer but

00:06:00,170 --> 00:06:05,900
as I said not no meaning is given to

00:06:02,000 --> 00:06:07,160
this yes which means as you can guess

00:06:05,900 --> 00:06:09,050
there needs to be something that gives a

00:06:07,160 --> 00:06:10,880
meaning to those tokens right so that is

00:06:09,050 --> 00:06:12,590
the following thing and that is what the

00:06:10,880 --> 00:06:15,680
scanner does if you've ever looked at

00:06:12,590 --> 00:06:19,040
PHP source code it is salty sores and

00:06:15,680 --> 00:06:22,010
language scanner that's a very big file

00:06:19,040 --> 00:06:26,900
if you look at it which I will show you

00:06:22,010 --> 00:06:29,570
here language parson if you go to the

00:06:26,900 --> 00:06:31,400
start of this and read through this I

00:06:29,570 --> 00:06:33,200
will just skip through don't pay

00:06:31,400 --> 00:06:34,490
attention to what you're seeing it's

00:06:33,200 --> 00:06:37,370
very complicated and then you get these

00:06:34,490 --> 00:06:41,150
big tables of numbers now nobody has

00:06:37,370 --> 00:06:42,639
written that themselves of course it's

00:06:41,150 --> 00:06:44,139
very difficult to do

00:06:42,639 --> 00:06:46,090
this is clearly generated by a computer

00:06:44,139 --> 00:06:48,219
because computers are kind of good at

00:06:46,090 --> 00:06:50,349
doing this well it basically is it's a

00:06:48,219 --> 00:06:52,330
big state machine again so in every

00:06:50,349 --> 00:06:54,639
state that there is you can transition

00:06:52,330 --> 00:06:57,819
to all the states because the scanner is

00:06:54,639 --> 00:06:59,560
much more complex or the Parsis much

00:06:57,819 --> 00:07:01,599
more complex than the scanner because

00:06:59,560 --> 00:07:04,180
the scanner only has like creates like

00:07:01,599 --> 00:07:05,889
what is it 400 tokens or something like

00:07:04,180 --> 00:07:09,189
that maybe even less smooth where is

00:07:05,889 --> 00:07:09,819
this the parser well it's very very

00:07:09,189 --> 00:07:11,379
large

00:07:09,819 --> 00:07:13,240
I'm just crawling this and scrolling

00:07:11,379 --> 00:07:16,389
distance coming as you can see nobody

00:07:13,240 --> 00:07:18,370
arrives is code there's I was going to

00:07:16,389 --> 00:07:21,099
show how many states there and just as

00:07:18,370 --> 00:07:23,139
far about 500 states is all but that has

00:07:21,099 --> 00:07:26,259
changed quite a lot between PHP 5 and

00:07:23,139 --> 00:07:28,689
PHP sound HP 7 is all looks easier to

00:07:26,259 --> 00:07:31,569
read even this is easier to read than a

00:07:28,689 --> 00:07:34,569
PHP 5 versions because instead of

00:07:31,569 --> 00:07:36,310
directly going from interpreting the

00:07:34,569 --> 00:07:37,569
rules it doesn't go directly to byte

00:07:36,310 --> 00:07:39,969
code anymore we'll go through another

00:07:37,569 --> 00:07:44,259
stage call them at this abstract syntax

00:07:39,969 --> 00:07:45,879
tree which is local asp AST let's have a

00:07:44,259 --> 00:07:48,659
quick look at how the scanner rules work

00:07:45,879 --> 00:07:50,919
here so it starts out a few scripts

00:07:48,659 --> 00:07:52,240
nashit HTML in the first switch you

00:07:50,919 --> 00:07:55,419
really shouldn't be doing any more and

00:07:52,240 --> 00:07:57,400
you get a list of what can be the top

00:07:55,419 --> 00:07:59,050
statements the top segments is basically

00:07:57,400 --> 00:08:01,719
what what is the first thing a PHP

00:07:59,050 --> 00:08:04,479
script can contain so it can either be

00:08:01,719 --> 00:08:06,490
statement does any sort of statement you

00:08:04,479 --> 00:08:08,680
can come up with or function declaration

00:08:06,490 --> 00:08:11,259
statements a class declaration straight

00:08:08,680 --> 00:08:13,449
against difficult pronounce a trait

00:08:11,259 --> 00:08:15,520
declaration statement a namespace

00:08:13,449 --> 00:08:17,919
declaration statement and so on and so

00:08:15,520 --> 00:08:20,169
on and those are again do those initial

00:08:17,919 --> 00:08:22,000
state cells can be and what the scanner

00:08:20,169 --> 00:08:25,240
is it applies rules to it it tries to

00:08:22,000 --> 00:08:27,009
find the meaning in the tokens figure

00:08:25,240 --> 00:08:31,000
out which rule applies to it and then

00:08:27,009 --> 00:08:32,979
builds up this AST so as a simple

00:08:31,000 --> 00:08:35,229
example here and I won't go into great

00:08:32,979 --> 00:08:39,070
detail about all of this but say for

00:08:35,229 --> 00:08:41,079
example that you're you fall contains a

00:08:39,070 --> 00:08:43,690
PHP class which is your class

00:08:41,079 --> 00:08:47,019
declaration statements now and that

00:08:43,690 --> 00:08:50,500
consists out of class modifiers in pink

00:08:47,019 --> 00:08:52,540
here which then are the quarter easy to

00:08:50,500 --> 00:08:55,360
read actually the class modifiers is

00:08:52,540 --> 00:08:57,060
either a cloth modifier or plus modifier

00:08:55,360 --> 00:09:00,040
followed by clouds model

00:08:57,060 --> 00:09:01,690
if you get some recursion in here now

00:09:00,040 --> 00:09:04,030
the reason why that is film in this way

00:09:01,690 --> 00:09:06,400
and not dual rail runs various class

00:09:04,030 --> 00:09:08,170
modify and then class modifiers is the

00:09:06,400 --> 00:09:09,970
way how the parsing works if you do it

00:09:08,170 --> 00:09:13,150
this way then it's much easy for the

00:09:09,970 --> 00:09:16,060
parser to figure out how to give meaning

00:09:13,150 --> 00:09:18,100
to things it's difficult to explain I

00:09:16,060 --> 00:09:20,020
had a whole compiler clause and unique

00:09:18,100 --> 00:09:23,020
about how this works so I won't bore you

00:09:20,020 --> 00:09:23,980
with that too much and but from the

00:09:23,020 --> 00:09:25,840
things that it's fine

00:09:23,980 --> 00:09:29,140
so it finds class modifies and at some

00:09:25,840 --> 00:09:30,940
point it says well it's either T

00:09:29,140 --> 00:09:32,770
abstract or T final those are the class

00:09:30,940 --> 00:09:34,390
modifiers all right so when it sees one

00:09:32,770 --> 00:09:36,550
of these tokens or knows this rule

00:09:34,390 --> 00:09:38,650
applies and then it does do something

00:09:36,550 --> 00:09:40,480
and the doing something is between the

00:09:38,650 --> 00:09:44,260
curly brackets is so basically this as

00:09:40,480 --> 00:09:47,590
well we set the value that was found to

00:09:44,260 --> 00:09:49,090
sent a cc explicit abstract class so

00:09:47,590 --> 00:09:51,940
that does then use the abstract clause

00:09:49,090 --> 00:09:54,550
in PHP and generally it will attach this

00:09:51,940 --> 00:09:56,410
keyword to your class internally so then

00:09:54,550 --> 00:09:57,880
when you do something with it you know

00:09:56,410 --> 00:10:01,060
you can't instantiate and stuff like

00:09:57,880 --> 00:10:03,339
that so that it's a whole tree that goes

00:10:01,060 --> 00:10:04,960
down so once you sign a class modifier

00:10:03,339 --> 00:10:07,990
well then it knows that it is either

00:10:04,960 --> 00:10:10,660
that it is this option so this is an or

00:10:07,990 --> 00:10:14,290
just like you type in PHP right so it is

00:10:10,660 --> 00:10:17,020
either dis roof rule or it is the order

00:10:14,290 --> 00:10:18,490
rule or this one and you can see the

00:10:17,020 --> 00:10:20,380
difference here where there is a rule

00:10:18,490 --> 00:10:22,630
there's also variable here so those

00:10:20,380 --> 00:10:24,610
variables are very much like PHP

00:10:22,630 --> 00:10:26,320
variables except they're internal to the

00:10:24,610 --> 00:10:29,650
scanner that I do very similar things

00:10:26,320 --> 00:10:31,420
and from that you can see if sometimes

00:10:29,650 --> 00:10:34,000
those rules up craziest AST create

00:10:31,420 --> 00:10:37,150
deckle function which then builds up

00:10:34,000 --> 00:10:39,400
this AST for you roll let me go back to

00:10:37,150 --> 00:10:41,410
this AST so the scanner gives meaning to

00:10:39,400 --> 00:10:43,630
the tokens it constructs this ast

00:10:41,410 --> 00:10:45,430
through those rules and then it creates

00:10:43,630 --> 00:10:47,530
very complicated code with nobody writes

00:10:45,430 --> 00:10:49,660
or reads because it's generated by

00:10:47,530 --> 00:10:52,120
computer if we look at what people

00:10:49,660 --> 00:10:55,900
actually write it survives this file

00:10:52,120 --> 00:10:57,610
here which is mope generated and it's

00:10:55,900 --> 00:11:00,570
much easy to read and quite easy to

00:10:57,610 --> 00:11:05,740
follow us if something goes on there

00:11:00,570 --> 00:11:09,430
all right so this AST

00:11:05,740 --> 00:11:11,140
how does it look like well it looks it's

00:11:09,430 --> 00:11:12,580
a following thing it describes this

00:11:11,140 --> 00:11:14,470
structure that comes out of the parser

00:11:12,580 --> 00:11:17,230
it describes the structure of your

00:11:14,470 --> 00:11:19,180
script without and having giving meaning

00:11:17,230 --> 00:11:20,830
to what all those tokens mean so each

00:11:19,180 --> 00:11:22,150
node and it is a language construct and

00:11:20,830 --> 00:11:23,350
the language construct can be many many

00:11:22,150 --> 00:11:23,800
different things I will show you in a

00:11:23,350 --> 00:11:25,870
moment

00:11:23,800 --> 00:11:28,120
so the nessa structures are in there

00:11:25,870 --> 00:11:30,600
because it's a tree but it also removes

00:11:28,120 --> 00:11:34,180
some of the original informations from

00:11:30,600 --> 00:11:37,510
from the source code like in some cases

00:11:34,180 --> 00:11:39,700
it doesn't remember your your comments

00:11:37,510 --> 00:11:41,230
anymore it remembers the dog block still

00:11:39,700 --> 00:11:43,870
but not a common fears authorizing new

00:11:41,230 --> 00:11:45,490
code it also sometimes gets line numbers

00:11:43,870 --> 00:11:46,810
wrong and things like that or it doesn't

00:11:45,490 --> 00:11:49,090
need to score the line numbers because

00:11:46,810 --> 00:11:51,790
PHP doesn't care it for executing them

00:11:49,090 --> 00:11:55,330
unless you get an error message the same

00:11:51,790 --> 00:11:57,940
thing it doesn't keep the cone or a rich

00:11:55,330 --> 00:12:00,100
column specific token has been parsed in

00:11:57,940 --> 00:12:00,820
either so there's information loss going

00:12:00,100 --> 00:12:03,490
to an AST

00:12:00,820 --> 00:12:05,590
however from an AST you can always go

00:12:03,490 --> 00:12:07,660
back to fully functional PHP script that

00:12:05,590 --> 00:12:09,700
would exactly behave the same because

00:12:07,660 --> 00:12:12,040
all the information that it does need to

00:12:09,700 --> 00:12:14,110
keep is still in there including dog

00:12:12,040 --> 00:12:15,580
blocks because they are important for

00:12:14,110 --> 00:12:18,310
doing refraction kind of stuff right so

00:12:15,580 --> 00:12:21,190
that is kept to visualize them there's

00:12:18,310 --> 00:12:23,920
an extension called PHP ast by the

00:12:21,190 --> 00:12:25,240
person that did most of the ast

00:12:23,920 --> 00:12:27,580
implementation in the first place and

00:12:25,240 --> 00:12:30,010
it's also possible to do optimizations

00:12:27,580 --> 00:12:33,490
by looking at this tree and see which

00:12:30,010 --> 00:12:35,350
things cannot be reached for example PHP

00:12:33,490 --> 00:12:38,380
itself doesn't do that but if you

00:12:35,350 --> 00:12:40,240
installed opk shore-up cache then it

00:12:38,380 --> 00:12:43,660
will look at these things and do some

00:12:40,240 --> 00:12:47,470
optimizations that are possible alright

00:12:43,660 --> 00:12:49,780
so then you use nikitos extension and

00:12:47,470 --> 00:12:53,080
run a SC parse code you get this kind of

00:12:49,780 --> 00:12:55,000
stuff back again nearly impossible to

00:12:53,080 --> 00:12:58,900
read and have lots of stuff even for my

00:12:55,000 --> 00:13:00,820
very simple scripts however there's also

00:12:58,900 --> 00:13:03,040
ways formatting it and when you format

00:13:00,820 --> 00:13:06,220
it it's much easy to read and figure out

00:13:03,040 --> 00:13:08,620
what is actually in there and so any of

00:13:06,220 --> 00:13:12,340
you ever use things like PHP code

00:13:08,620 --> 00:13:15,180
sniffer yeah chance PHP code snares are

00:13:12,340 --> 00:13:17,410
used to be based on just a token and

00:13:15,180 --> 00:13:19,250
writing rules for PHP codes never

00:13:17,410 --> 00:13:20,930
because it's based on those tokens

00:13:19,250 --> 00:13:23,510
that hasn't been giving any meaning yet

00:13:20,930 --> 00:13:26,270
it's actually very difficult to write

00:13:23,510 --> 00:13:28,280
some good rules and all being too

00:13:26,270 --> 00:13:31,820
complicated though you look at this

00:13:28,280 --> 00:13:33,560
ast it is much easy to sign these kind

00:13:31,820 --> 00:13:35,480
of things because it's an e it's a

00:13:33,560 --> 00:13:37,670
structure that a sparse view everything

00:13:35,480 --> 00:13:40,100
has gotten a meaning when you look at it

00:13:37,670 --> 00:13:42,110
you can actually almost visually in your

00:13:40,100 --> 00:13:46,310
head reconstruct back how the script

00:13:42,110 --> 00:13:49,610
looks like so in this case the top of

00:13:46,310 --> 00:13:52,010
your ASP is a AAC statement LeSueur STM

00:13:49,610 --> 00:13:53,660
c-list I don't know where to come from

00:13:52,010 --> 00:13:55,550
comes from so I'm skipping that but the

00:13:53,660 --> 00:13:57,710
first thing again is this class the

00:13:55,550 --> 00:14:01,100
class destination which has this name as

00:13:57,710 --> 00:14:03,170
you can see it's the name whisky it

00:14:01,100 --> 00:14:06,020
extends nothing it implements nothing

00:14:03,170 --> 00:14:08,240
and it's consists of statements so a

00:14:06,020 --> 00:14:10,460
class can contain statements but in this

00:14:08,240 --> 00:14:12,440
case if statements are normal statements

00:14:10,460 --> 00:14:15,920
they are like your as you can see here

00:14:12,440 --> 00:14:18,170
your property declaration or your

00:14:15,920 --> 00:14:19,640
methods in there and things like that so

00:14:18,170 --> 00:14:22,130
the property declaration basically what

00:14:19,640 --> 00:14:25,940
it says is we define a property it is

00:14:22,130 --> 00:14:27,800
private and the name of it is mean which

00:14:25,940 --> 00:14:29,750
probably wasn't the best example to

00:14:27,800 --> 00:14:31,550
picking and then the default over this

00:14:29,750 --> 00:14:33,460
no and all of this information is in it

00:14:31,550 --> 00:14:36,530
so you can write a script to figure out

00:14:33,460 --> 00:14:38,900
where you have used the argument name

00:14:36,530 --> 00:14:41,420
for example quite easily by parsing this

00:14:38,900 --> 00:14:43,880
then use methods again that modifies

00:14:41,420 --> 00:14:47,480
they have names again and of course a

00:14:43,880 --> 00:14:50,480
method or function consists of a list of

00:14:47,480 --> 00:14:52,490
arguments first so that is the ast param

00:14:50,480 --> 00:14:55,460
list so in this case is it there's a

00:14:52,490 --> 00:14:59,120
parameter called name and again it has a

00:14:55,460 --> 00:15:00,650
default of no and then you get statement

00:14:59,120 --> 00:15:01,910
list and a statement list is then every

00:15:00,650 --> 00:15:03,980
speech piece statement if you've written

00:15:01,910 --> 00:15:05,630
yourself that belongs to this method so

00:15:03,980 --> 00:15:08,650
in this case the only statement in there

00:15:05,630 --> 00:15:10,640
is the assignments and this has

00:15:08,650 --> 00:15:12,350
something more complicated actually I

00:15:10,640 --> 00:15:13,760
think I have better slide for us to

00:15:12,350 --> 00:15:16,640
explain this so if we look at this very

00:15:13,760 --> 00:15:18,320
simple construct that vsam then I've

00:15:16,640 --> 00:15:20,480
tried highlighting in colors where

00:15:18,320 --> 00:15:24,580
different bits end up in so the first

00:15:20,480 --> 00:15:28,970
thing becomes the public modifier I

00:15:24,580 --> 00:15:31,400
actually forgot to color here but that's

00:15:28,970 --> 00:15:33,080
the same on there we have the

00:15:31,400 --> 00:15:35,120
constructor which is the name we have

00:15:33,080 --> 00:15:37,010
the assignments and the assignment looks

00:15:35,120 --> 00:15:40,490
very much more complicated right because

00:15:37,010 --> 00:15:42,140
you get you get here now is the

00:15:40,490 --> 00:15:43,670
assignment actually happens in two steps

00:15:42,140 --> 00:15:46,550
this first one is actually an expression

00:15:43,670 --> 00:15:48,500
the expression that that means this name

00:15:46,550 --> 00:15:50,570
and that looks as follows

00:15:48,500 --> 00:15:53,600
so this because this is a property axis

00:15:50,570 --> 00:15:55,339
of this it knows that the variable that

00:15:53,600 --> 00:15:56,810
you're doing the property from is this

00:15:55,339 --> 00:15:58,790
in this case so that's the expression

00:15:56,810 --> 00:16:00,410
and then the property name is name see

00:15:58,790 --> 00:16:02,930
if you get this nested by doing multiple

00:16:00,410 --> 00:16:04,310
arrows you see this tree stick you're

00:16:02,930 --> 00:16:10,250
growing into something more complicated

00:16:04,310 --> 00:16:12,290
and then the other value that gets

00:16:10,250 --> 00:16:15,800
assigned to this assign the truly the

00:16:12,290 --> 00:16:18,079
sign is of course the variable name and

00:16:15,800 --> 00:16:21,560
then a return type is no because we

00:16:18,079 --> 00:16:23,360
haven't set a return type so that's what

00:16:21,560 --> 00:16:25,250
the AUC does it builds up from this

00:16:23,360 --> 00:16:26,829
function or method in this case this

00:16:25,250 --> 00:16:30,339
tree structure

00:16:26,829 --> 00:16:33,890
alright so PHP itself cannot execute

00:16:30,339 --> 00:16:35,240
this at this ast either what it needs to

00:16:33,890 --> 00:16:38,870
do is it now needs to convert as this

00:16:35,240 --> 00:16:41,480
situate can be executed by the engine

00:16:38,870 --> 00:16:42,829
itself and to do that it needs to

00:16:41,480 --> 00:16:45,260
convert this to something we call

00:16:42,829 --> 00:16:48,110
bytecode or opcodes or opera race are

00:16:45,260 --> 00:16:49,640
synonyms basically of the same thing all

00:16:48,110 --> 00:16:51,170
right so let's have a look at this

00:16:49,640 --> 00:16:53,540
bytecode and this is where it gets even

00:16:51,170 --> 00:16:55,850
more complicated there we all have so in

00:16:53,540 --> 00:16:57,709
PHP we call them opcodes so each

00:16:55,850 --> 00:17:00,170
function methods or main body of your

00:16:57,709 --> 00:17:01,910
scripts is represented by an opera and

00:17:00,170 --> 00:17:03,890
an operate contains these op codes and

00:17:01,910 --> 00:17:08,059
these are instructions for the sent

00:17:03,890 --> 00:17:10,970
engine in a very similar way as how a

00:17:08,059 --> 00:17:12,860
computer or an assembler runs the

00:17:10,970 --> 00:17:16,130
assembly code converts the assembly code

00:17:12,860 --> 00:17:18,770
to machine code PHP does not have that

00:17:16,130 --> 00:17:21,290
step but it just has the assembly

00:17:18,770 --> 00:17:23,480
assembler layer in between which are

00:17:21,290 --> 00:17:24,770
called these op codes iam it's very

00:17:23,480 --> 00:17:28,040
similar and I'll show you in a moment

00:17:24,770 --> 00:17:30,919
and there's an extension called vld that

00:17:28,040 --> 00:17:33,260
i've written many many years ago that

00:17:30,919 --> 00:17:35,750
allows you to visualize these operate

00:17:33,260 --> 00:17:38,510
and op codes let's have a quick look at

00:17:35,750 --> 00:17:41,120
how this looks like so from the previous

00:17:38,510 --> 00:17:43,380
example where we had our construct

00:17:41,120 --> 00:17:46,380
method and

00:17:43,380 --> 00:17:48,929
from their own we then generated opcode

00:17:46,380 --> 00:17:53,850
and what really shows you when it comes

00:17:48,929 --> 00:17:55,799
out of it is following so there's a list

00:17:53,850 --> 00:17:58,530
of compiled variable names compelled

00:17:55,799 --> 00:18:00,120
variable names are something that is a

00:17:58,530 --> 00:18:02,760
bit of an optimization I think that came

00:18:00,120 --> 00:18:04,530
in in PHP five 3xk where instead of

00:18:02,760 --> 00:18:06,600
having to look at the name in a table

00:18:04,530 --> 00:18:09,299
while compiling is that already

00:18:06,600 --> 00:18:12,480
associates a number array index

00:18:09,299 --> 00:18:14,309
basically describing the variable name

00:18:12,480 --> 00:18:16,590
so instead of having to do a hash look

00:18:14,309 --> 00:18:19,100
up like array key lookup it does a

00:18:16,590 --> 00:18:21,870
direct array index so that's much faster

00:18:19,100 --> 00:18:24,710
and this is probably one of the biggest

00:18:21,870 --> 00:18:27,630
performance games in PHP fast reaction

00:18:24,710 --> 00:18:30,720
so these compelled variables as they are

00:18:27,630 --> 00:18:32,940
called internally they basically attempt

00:18:30,720 --> 00:18:34,140
this array indexes to this name so in

00:18:32,940 --> 00:18:37,289
this case the variable name is

00:18:34,140 --> 00:18:40,080
represented by exclamation mark 0 so the

00:18:37,289 --> 00:18:42,450
exclamation mark is just to notify that

00:18:40,080 --> 00:18:44,610
this is a compulsive aerial and PHP has

00:18:42,450 --> 00:18:46,429
other types of variables in its engine

00:18:44,610 --> 00:18:48,570
as all sort of temporary variables and

00:18:46,429 --> 00:18:53,370
variables that actually represent a

00:18:48,570 --> 00:18:56,039
variable in PHP because if you use

00:18:53,370 --> 00:18:59,100
things like variable variables in PHP

00:18:56,039 --> 00:19:01,650
then it can also attach an array index

00:18:59,100 --> 00:19:03,600
to it because both parsing the script it

00:19:01,650 --> 00:19:05,340
doesn't know which variable is actually

00:19:03,600 --> 00:19:07,470
going to represent and it still has to

00:19:05,340 --> 00:19:09,179
do this hash hookup for you and that

00:19:07,470 --> 00:19:11,700
shows up in a different way in the

00:19:09,179 --> 00:19:17,419
opcodes that come out of it now this

00:19:11,700 --> 00:19:20,600
very simple construct actually creates

00:19:17,419 --> 00:19:23,490
for op codes that actually do something

00:19:20,600 --> 00:19:26,820
the first one x not sense for no

00:19:23,490 --> 00:19:33,870
operation does nothing the engine

00:19:26,820 --> 00:19:36,630
sometimes generates these as a it okay

00:19:33,870 --> 00:19:38,250
so well it does it doesn't generate them

00:19:36,630 --> 00:19:40,799
at from what is actually would have done

00:19:38,250 --> 00:19:43,950
is its creates a function declaration

00:19:40,799 --> 00:19:46,020
here but you don't see that because the

00:19:43,950 --> 00:19:48,929
scanner does two passes over so the

00:19:46,020 --> 00:19:51,720
first boss passes the scripts and then

00:19:48,929 --> 00:19:53,549
the second one looks at it a little bit

00:19:51,720 --> 00:19:56,340
and removes all the things that it can

00:19:53,549 --> 00:19:57,240
do well scanning and parsing your script

00:19:56,340 --> 00:20:01,530
so

00:19:57,240 --> 00:20:03,750
example here would be that main space

00:20:01,530 --> 00:20:06,450
declaration and PHP is basically

00:20:03,750 --> 00:20:09,480
something that is a alias for something

00:20:06,450 --> 00:20:12,780
else that yes in PHP like for cloth so

00:20:09,480 --> 00:20:14,910
if you have drama yo slash whiskey after

00:20:12,780 --> 00:20:17,580
the parsing stage after the second

00:20:14,910 --> 00:20:20,640
parsing states that has already been

00:20:17,580 --> 00:20:22,680
resolved so the PHP and MGM doesn't know

00:20:20,640 --> 00:20:24,690
anything about namespaces it's all don't

00:20:22,680 --> 00:20:27,510
ball parsing the scripts so this is why

00:20:24,690 --> 00:20:30,210
I don't find things like you star use

00:20:27,510 --> 00:20:32,370
namespace slash start because PHP

00:20:30,210 --> 00:20:34,230
denver's and know what good exists in

00:20:32,370 --> 00:20:36,510
the main space and hence cannot do this

00:20:34,230 --> 00:20:38,190
pre optimization of copy and pasting

00:20:36,510 --> 00:20:40,140
into the class lines which the engine

00:20:38,190 --> 00:20:42,030
needs so that's why sometimes you don't

00:20:40,140 --> 00:20:44,160
get features in PHP because the engine

00:20:42,030 --> 00:20:48,570
doesn't really do that anyway the no.of

00:20:44,160 --> 00:20:50,280
is what that used to be in this case the

00:20:48,570 --> 00:20:52,880
second opcode that we have here actually

00:20:50,280 --> 00:20:57,210
this is OP code number one is to receive

00:20:52,880 --> 00:20:59,160
anybody want to guess what that means it

00:20:57,210 --> 00:21:01,650
receives an argument into the function

00:20:59,160 --> 00:21:04,410
which is the name argument in your

00:21:01,650 --> 00:21:06,270
constructor in this case which it

00:21:04,410 --> 00:21:08,580
doesn't show name because every

00:21:06,270 --> 00:21:10,320
exclamation mark 0 you get to replace by

00:21:08,580 --> 00:21:16,500
the name right so it says receive into

00:21:10,320 --> 00:21:19,890
name PHP 7 just this internally a little

00:21:16,500 --> 00:21:21,900
bit different again PHP 7 actually does

00:21:19,890 --> 00:21:24,540
not execute this receive code it

00:21:21,900 --> 00:21:26,610
actually jumps over all the receipts it

00:21:24,540 --> 00:21:29,370
goes the way how the calling conventions

00:21:26,610 --> 00:21:32,610
work so well when calling functions in

00:21:29,370 --> 00:21:34,080
PHP 7 it actually puts those things in

00:21:32,610 --> 00:21:36,870
the right place in memory already so you

00:21:34,080 --> 00:21:39,060
don't have to do a receive but to make

00:21:36,870 --> 00:21:40,590
things still work with all the things

00:21:39,060 --> 00:21:42,210
and sometimes variant combining things

00:21:40,590 --> 00:21:44,730
the receive is still being generated

00:21:42,210 --> 00:21:47,820
although it doesn't actually use much

00:21:44,730 --> 00:21:51,080
anymore it's nice to know that it's

00:21:47,820 --> 00:21:53,850
still there and we get X statements or

00:21:51,080 --> 00:21:54,150
the next statement doesn't do anything

00:21:53,850 --> 00:21:57,660
either

00:21:54,150 --> 00:21:59,520
it is a placeholder opcode that debugger

00:21:57,660 --> 00:22:02,910
scan who can sue so if you do single

00:21:59,520 --> 00:22:05,700
step debugging that happens because the

00:22:02,910 --> 00:22:09,420
burgers will add a hook to this X

00:22:05,700 --> 00:22:12,039
statement up code and you can really

00:22:09,420 --> 00:22:14,620
only do this for

00:22:12,039 --> 00:22:16,390
and that is how single study burgers

00:22:14,620 --> 00:22:18,600
work by hooking into this specific

00:22:16,390 --> 00:22:21,640
opcode designed on handler and then

00:22:18,600 --> 00:22:25,059
introspect the function or the PHP

00:22:21,640 --> 00:22:26,710
function now the third one or actually

00:22:25,059 --> 00:22:30,460
the fourth one which is a sign

00:22:26,710 --> 00:22:32,140
underscore obj and that is has two

00:22:30,460 --> 00:22:34,179
colors here because it is an oak code

00:22:32,140 --> 00:22:37,750
that is generated from an assignment

00:22:34,179 --> 00:22:40,120
that is already sort of pre optimized so

00:22:37,750 --> 00:22:44,470
there's a sign obj there's also a sign

00:22:40,120 --> 00:22:47,049
array and normal assignment each opcode

00:22:44,470 --> 00:22:51,039
can have two arguments at most two

00:22:47,049 --> 00:22:53,320
arguments so this a return value and

00:22:51,039 --> 00:22:56,080
then two operands now the thing is

00:22:53,320 --> 00:22:58,720
assigned obj needs three operands it

00:22:56,080 --> 00:23:00,549
needs your name of your class or the

00:22:58,720 --> 00:23:04,840
variable representing your class it

00:23:00,549 --> 00:23:07,809
needs the object properties name which

00:23:04,840 --> 00:23:09,280
is in this case this string name you

00:23:07,809 --> 00:23:12,130
don't see the variable here because

00:23:09,280 --> 00:23:14,470
assigned obj hasn't as a slack in there

00:23:12,130 --> 00:23:17,650
that says if it's this then we don't

00:23:14,470 --> 00:23:18,940
have to also tell that as this disc so

00:23:17,650 --> 00:23:21,039
even though the operators only one

00:23:18,940 --> 00:23:22,450
operand showing this is actually the

00:23:21,039 --> 00:23:24,549
second operand the first one has been

00:23:22,450 --> 00:23:26,980
flagged out already so you don't see it

00:23:24,549 --> 00:23:28,750
here but because there's okay occasions

00:23:26,980 --> 00:23:30,520
where if you don't use this it's a

00:23:28,750 --> 00:23:31,840
different variable name it needs to

00:23:30,520 --> 00:23:35,010
accept both of those operands and

00:23:31,840 --> 00:23:38,080
there's no notice specialized opcode for

00:23:35,010 --> 00:23:40,870
having both cases so although I say

00:23:38,080 --> 00:23:43,299
everyone can have two they don't always

00:23:40,870 --> 00:23:46,390
use two so there's different name and

00:23:43,299 --> 00:23:47,890
then because it needs three nisi like I

00:23:46,390 --> 00:23:51,100
said the variable that represents the

00:23:47,890 --> 00:23:53,559
object the property name and it needs

00:23:51,100 --> 00:23:57,240
two data there's a special up code

00:23:53,559 --> 00:24:01,600
called oak data that basically access

00:23:57,240 --> 00:24:03,610
extra space to provide more data to an

00:24:01,600 --> 00:24:06,730
opcode that precedes it and it's very

00:24:03,610 --> 00:24:10,330
few up code that has assigned obj is one

00:24:06,730 --> 00:24:11,350
of them and as a few others as well so

00:24:10,330 --> 00:24:13,620
the last thing that I'd like to point

00:24:11,350 --> 00:24:16,150
out this is returned it says return no

00:24:13,620 --> 00:24:17,200
but I didn't write that in my in my

00:24:16,150 --> 00:24:18,669
scripts at all right

00:24:17,200 --> 00:24:20,350
that didn't have a return statement at

00:24:18,669 --> 00:24:23,710
all first of all of course constructors

00:24:20,350 --> 00:24:24,460
come we never return but PHP will always

00:24:23,710 --> 00:24:26,590
generate

00:24:24,460 --> 00:24:29,650
turn statement EDM is use of every

00:24:26,590 --> 00:24:32,020
function and script has been doing that

00:24:29,650 --> 00:24:36,640
since it starts might not continue doing

00:24:32,020 --> 00:24:37,570
that because in theory every function

00:24:36,640 --> 00:24:38,980
can return something

00:24:37,570 --> 00:24:41,560
now there's optimizations in there that

00:24:38,980 --> 00:24:43,420
if there's no return value then PHP

00:24:41,560 --> 00:24:44,770
would also not attempt to read the

00:24:43,420 --> 00:24:46,300
return value coming back either so

00:24:44,770 --> 00:24:48,310
there's an additional step there that

00:24:46,300 --> 00:24:50,470
optimizes out but there's lots of

00:24:48,310 --> 00:24:53,020
interesting intricate things going only

00:24:50,470 --> 00:24:55,000
at that make no sense if you look at it

00:24:53,020 --> 00:24:59,230
that is all there because of historical

00:24:55,000 --> 00:25:00,910
reasons now this is a very simple little

00:24:59,230 --> 00:25:02,560
topcoats I'm going to show you a few

00:25:00,910 --> 00:25:03,970
more because you might remember that

00:25:02,560 --> 00:25:05,920
started to love the toggles it's all

00:25:03,970 --> 00:25:08,350
about to go through and so far I haven't

00:25:05,920 --> 00:25:10,270
actually shown you any go to yet little

00:25:08,350 --> 00:25:12,460
get in hours so the goat that I'm

00:25:10,270 --> 00:25:16,000
referring to is a jump it's not a jump

00:25:12,460 --> 00:25:18,400
between two prongs of a mountain this is

00:25:16,000 --> 00:25:20,620
approximately 500 meters over sea level

00:25:18,400 --> 00:25:23,050
and you actually had people jumping

00:25:20,620 --> 00:25:27,010
between the two prongs is it's somewhere

00:25:23,050 --> 00:25:29,140
in Norway on the loop footin this is not

00:25:27,010 --> 00:25:30,490
my photo but that's in this position to

00:25:29,140 --> 00:25:32,650
be able to take this photo where there's

00:25:30,490 --> 00:25:34,840
no crazy people trying to jump across at

00:25:32,650 --> 00:25:36,970
a moment so I only have photos of people

00:25:34,840 --> 00:25:39,820
climbing up them anyway to jump we not

00:25:36,970 --> 00:25:43,210
talk about these jumps that can result

00:25:39,820 --> 00:25:47,920
in depths where we talk about chance in

00:25:43,210 --> 00:25:49,810
computer stuff so a jump starts with a

00:25:47,920 --> 00:25:53,710
very simple on within if statements an

00:25:49,810 --> 00:25:55,480
if statement well you can either go into

00:25:53,710 --> 00:25:57,220
the assessment or you can go out of your

00:25:55,480 --> 00:25:58,510
statement like not executed right so

00:25:57,220 --> 00:26:02,590
this is a choice that needs to be made

00:25:58,510 --> 00:26:04,690
and a choice is made by by doing a jump

00:26:02,590 --> 00:26:06,700
if something matches or not doing jump

00:26:04,690 --> 00:26:09,190
if something doesn't match or the other

00:26:06,700 --> 00:26:11,740
way around depending on which type of

00:26:09,190 --> 00:26:13,510
jump is being used so in this case we

00:26:11,740 --> 00:26:15,610
have the script is if it has a variable

00:26:13,510 --> 00:26:18,520
a and it's a value 42 which come back

00:26:15,610 --> 00:26:19,960
here in the ast and then when you look

00:26:18,520 --> 00:26:22,030
at the op codes that come out of it it

00:26:19,960 --> 00:26:25,180
looks like something like this so the

00:26:22,030 --> 00:26:28,510
first one in line one ignoring the X

00:26:25,180 --> 00:26:31,090
statement again is if equal and if equal

00:26:28,510 --> 00:26:32,680
has a return with the till the one this

00:26:31,090 --> 00:26:35,310
is a temporary variable in the engine

00:26:32,680 --> 00:26:37,840
and then it has two operands it has

00:26:35,310 --> 00:26:41,289
exclamation mark zero which is named or

00:26:37,840 --> 00:26:44,679
is a compels variable and then the value

00:26:41,289 --> 00:26:47,860
42 which is here so what is us is it

00:26:44,679 --> 00:26:51,309
runs equal and the returns values that

00:26:47,860 --> 00:26:53,679
it stores in a temporary variable then

00:26:51,309 --> 00:26:57,309
the second off code in this case gyms

00:26:53,679 --> 00:26:59,770
that stands for jump zero checks what

00:26:57,309 --> 00:27:04,299
this temporary variable is and then

00:26:59,770 --> 00:27:09,039
depending on if it is 0 that means false

00:27:04,299 --> 00:27:12,840
for the if equals returns 0 false then

00:27:09,039 --> 00:27:16,120
we need to jump so it says basically if

00:27:12,840 --> 00:27:19,059
the return value of C is equally is 0

00:27:16,120 --> 00:27:21,610
the zetz sensors area we jump to up code

00:27:19,059 --> 00:27:25,899
5 which is then returned one at the end

00:27:21,610 --> 00:27:27,940
of the function not sure whether return

00:27:25,899 --> 00:27:30,370
comes from really here

00:27:27,940 --> 00:27:32,700
I might have cutted off the slide

00:27:30,370 --> 00:27:34,960
because I ran out of space or something

00:27:32,700 --> 00:27:37,270
so that's what this so it's a very

00:27:34,960 --> 00:27:41,799
simple instruction jim-jim 0 only jump

00:27:37,270 --> 00:27:45,429
when something is false there's all the

00:27:41,799 --> 00:27:46,929
jump instructions so this is slightly

00:27:45,429 --> 00:27:51,940
more complicated one where we also have

00:27:46,929 --> 00:27:54,100
an elf so we have if a equals PI then we

00:27:51,940 --> 00:27:55,870
echo circles otherwise its square makes

00:27:54,100 --> 00:27:58,149
no sense or server of course but it's an

00:27:55,870 --> 00:27:59,200
example a simple example and then when

00:27:58,149 --> 00:28:00,760
you look at the op codes that are being

00:27:59,200 --> 00:28:02,230
generated from this there's a few more

00:28:00,760 --> 00:28:07,929
things in now there's still D is equal

00:28:02,230 --> 00:28:10,870
if this exclamation mark 0 is PI if it

00:28:07,929 --> 00:28:12,850
is mostly jump to 6 so that is basically

00:28:10,870 --> 00:28:15,669
says if this doesn't match we jump to

00:28:12,850 --> 00:28:17,380
this bit here so if you look at 6 it has

00:28:15,669 --> 00:28:20,649
the echo for squares following a trend

00:28:17,380 --> 00:28:24,190
so echo is an order up gaudium if it

00:28:20,649 --> 00:28:25,720
matches however then we run this we run

00:28:24,190 --> 00:28:27,340
the echo 4 circles and then you get

00:28:25,720 --> 00:28:30,100
another jump here this is a

00:28:27,340 --> 00:28:32,860
unconditional jump or an unconditional

00:28:30,100 --> 00:28:35,320
go-to really that then jumps to opcode 8

00:28:32,860 --> 00:28:38,260
which then returns from the function so

00:28:35,320 --> 00:28:40,720
there's the only way how this kind of

00:28:38,260 --> 00:28:43,059
structures are implemented are 3ds jumps

00:28:40,720 --> 00:28:46,240
or through these go twos because that's

00:28:43,059 --> 00:28:48,669
really what they are your nested AST

00:28:46,240 --> 00:28:51,820
structure which is a tree gets flattened

00:28:48,669 --> 00:28:55,180
out to a basically an array of opcode

00:28:51,820 --> 00:28:58,960
run but it can jump around us by these

00:28:55,180 --> 00:29:00,910
jump instructions all right so let's

00:28:58,960 --> 00:29:02,590
talk about rings anybody get guesses

00:29:00,910 --> 00:29:10,150
which is ring I'm referring to in the

00:29:02,590 --> 00:29:11,350
slide I can't hear any the collider

00:29:10,150 --> 00:29:13,000
that's exactly what it is because

00:29:11,350 --> 00:29:16,120
there's no ordering that you can't see

00:29:13,000 --> 00:29:17,710
on satellite imagery and it's 27 miles

00:29:16,120 --> 00:29:20,560
somewhere in France I don't know where

00:29:17,710 --> 00:29:23,560
this from the front fish borders in it

00:29:20,560 --> 00:29:25,090
and the ring let's meet let me know talk

00:29:23,560 --> 00:29:26,470
about the air they see although that

00:29:25,090 --> 00:29:27,760
would probably also be very interesting

00:29:26,470 --> 00:29:30,010
in this noble time talk about this

00:29:27,760 --> 00:29:31,690
morning let's have a look at four

00:29:30,010 --> 00:29:36,280
because that is a loop structure I've

00:29:31,690 --> 00:29:38,200
and this gets work complicated again

00:29:36,280 --> 00:29:39,940
because that's how the presentation

00:29:38,200 --> 00:29:43,210
falls every step gets more complicated

00:29:39,940 --> 00:29:45,520
and preaches on and because there's now

00:29:43,210 --> 00:29:47,470
multiple statements in arise so this for

00:29:45,520 --> 00:29:50,830
loop there's the initial state in here

00:29:47,470 --> 00:29:52,720
as you can see in the ast XP started

00:29:50,830 --> 00:29:54,940
blinking at me see what is this to

00:29:52,720 --> 00:30:00,510
Detroit I think the bathroom I've got

00:29:54,940 --> 00:30:05,320
empty goofy see the four has four

00:30:00,510 --> 00:30:07,480
elements in the ast and already in it

00:30:05,320 --> 00:30:09,460
stage which is the red base here the

00:30:07,480 --> 00:30:15,040
conditional which is the green bit and

00:30:09,460 --> 00:30:16,000
the loop is the blue getting and then of

00:30:15,040 --> 00:30:18,730
course you have the statements that

00:30:16,000 --> 00:30:20,200
that's fit inside your for loop and it

00:30:18,730 --> 00:30:22,660
generates so that's the following things

00:30:20,200 --> 00:30:25,930
again it is an assignment first which is

00:30:22,660 --> 00:30:28,560
your init stage it assigns the value 0

00:30:25,930 --> 00:30:31,240
to exclamation mark 1 which is the I and

00:30:28,560 --> 00:30:33,600
then we jump and we jump directly to

00:30:31,240 --> 00:30:37,000
opcode 6 which is the green bit here so

00:30:33,600 --> 00:30:41,590
before we do anything else we check

00:30:37,000 --> 00:30:45,610
whether the exclamation mark or variable

00:30:41,590 --> 00:30:50,110
a is smaller than 42 and if that's true

00:30:45,610 --> 00:30:51,580
then till the 3 contains true then it

00:30:50,110 --> 00:30:55,690
has is X a maintainer which is nothing

00:30:51,580 --> 00:31:00,370
and then it has a jump not 0 that is

00:30:55,690 --> 00:31:02,500
basically jump is this true so if I is

00:31:00,370 --> 00:31:08,920
smaller than 42

00:31:02,500 --> 00:31:11,170
then we jump to opcode 3 which is then

00:31:08,920 --> 00:31:11,850
the pink bits which saris statements in

00:31:11,170 --> 00:31:13,780
this function

00:31:11,850 --> 00:31:16,150
well it looks at the statements that

00:31:13,780 --> 00:31:18,070
does the echo and then after that does

00:31:16,150 --> 00:31:19,930
the elements have come at the end of the

00:31:18,070 --> 00:31:24,550
loop which are the blue bases this is

00:31:19,930 --> 00:31:26,590
the pre increment of I it is basically

00:31:24,550 --> 00:31:30,840
this father does it converts your for

00:31:26,590 --> 00:31:32,680
loop if we would do that in PHP syntax

00:31:30,840 --> 00:31:36,760
it would look like this

00:31:32,680 --> 00:31:39,520
so you have the I equals 0 here that

00:31:36,760 --> 00:31:41,700
then jumps to the condition it checks

00:31:39,520 --> 00:31:44,380
whether this condition is true I used

00:31:41,700 --> 00:31:49,420
dollar underscore which you should not

00:31:44,380 --> 00:31:50,830
do in your go to ever but you can check

00:31:49,420 --> 00:31:53,440
whether that's true and if that's not

00:31:50,830 --> 00:31:55,210
true we jump to the statement then it's

00:31:53,440 --> 00:31:57,010
executed statements and that a bit at

00:31:55,210 --> 00:31:58,780
the end of loops every loop you get in

00:31:57,010 --> 00:32:00,760
peach we have a loop structure he can

00:31:58,780 --> 00:32:03,010
rewrite with go-to should she do that

00:32:00,760 --> 00:32:05,050
absolutely not but you can if you really

00:32:03,010 --> 00:32:07,990
want them and the code of comes out as

00:32:05,050 --> 00:32:09,880
it is pretty much the same now it does

00:32:07,990 --> 00:32:11,110
exactly the same thing because of course

00:32:09,880 --> 00:32:14,350
they're slightly different line numbers

00:32:11,110 --> 00:32:17,140
what is interesting though is that the

00:32:14,350 --> 00:32:19,210
lines numbers you get out of here those

00:32:17,140 --> 00:32:22,570
are the items that we associates with

00:32:19,210 --> 00:32:25,090
these particular op codes the PHP

00:32:22,570 --> 00:32:26,890
doesn't always get it right sometimes

00:32:25,090 --> 00:32:30,070
gets it wrong if it gets it wrong it's a

00:32:26,890 --> 00:32:32,290
bug of course but if you ever seen PHP

00:32:30,070 --> 00:32:33,580
code coverage which uses XD we're gonna

00:32:32,290 --> 00:32:35,170
do 10 I guess the lines on that

00:32:33,580 --> 00:32:36,390
sometimes it shows you that lines aren't

00:32:35,170 --> 00:32:39,160
covered

00:32:36,390 --> 00:32:40,990
mainly because PHP doesn't get aligned

00:32:39,160 --> 00:32:43,450
numbers right now there's also fastly

00:32:40,990 --> 00:32:44,920
improved in PHP 7 so there should not no

00:32:43,450 --> 00:32:47,070
longer be so much of a problem as it

00:32:44,920 --> 00:32:50,680
used to be it's also a lot better at

00:32:47,070 --> 00:32:53,560
getting the line number even step

00:32:50,680 --> 00:32:55,180
sometimes so the revisions for now just

00:32:53,560 --> 00:32:57,520
build upon me it's a while loop which is

00:32:55,180 --> 00:33:00,100
a very similar thing again right so the

00:32:57,520 --> 00:33:03,130
while loop is he sets before the loop we

00:33:00,100 --> 00:33:07,810
set a variable and then while a certain

00:33:03,130 --> 00:33:13,270
variable is it's true or in this case

00:33:07,810 --> 00:33:14,180
larger than 0 I guess then we echo to

00:33:13,270 --> 00:33:16,910
vary

00:33:14,180 --> 00:33:17,450
the variable I and that again results in

00:33:16,910 --> 00:33:19,790
this right

00:33:17,450 --> 00:33:21,920
if you assignments the first bit invest

00:33:19,790 --> 00:33:25,690
here the dark waited to jump so it's

00:33:21,920 --> 00:33:29,150
unconditionally gems to opcode six which

00:33:25,690 --> 00:33:35,450
does the pre-decrement it does need at

00:33:29,150 --> 00:33:38,690
first if it is false so if it is true or

00:33:35,450 --> 00:33:40,970
that means that if the decrement didn't

00:33:38,690 --> 00:33:43,070
hit zero yet then it jumps back to up

00:33:40,970 --> 00:33:45,440
code for to echo the variable if nothing

00:33:43,070 --> 00:33:47,770
happens it just goes to the next operand

00:33:45,440 --> 00:33:51,470
which is to return out of this function

00:33:47,770 --> 00:33:53,570
that's well do while is very similar I

00:33:51,470 --> 00:33:55,310
don't think actually cover that as well

00:33:53,570 --> 00:33:58,640
in the same detail because it's just

00:33:55,310 --> 00:34:00,320
slightly ordering off conditional again

00:33:58,640 --> 00:34:03,350
you can reimplementation go to if you

00:34:00,320 --> 00:34:05,740
wanted again don't do that we have for

00:34:03,350 --> 00:34:10,640
each the 4-h gets a bit more complicated

00:34:05,740 --> 00:34:12,560
now if any you follows the discussion on

00:34:10,640 --> 00:34:17,230
PHP an internal then go to those

00:34:12,560 --> 00:34:20,450
introduced remember anybody's read that

00:34:17,230 --> 00:34:23,350
no ok well one thing that came up there

00:34:20,450 --> 00:34:27,380
as an argument for not having go-to is

00:34:23,350 --> 00:34:30,500
that in many languages go-to allows you

00:34:27,380 --> 00:34:33,110
to jump around a function freely like

00:34:30,500 --> 00:34:35,500
anywhere you want which makes it really

00:34:33,110 --> 00:34:38,149
difficult to implement

00:34:35,500 --> 00:34:41,090
especially in PHP because in PHP some

00:34:38,149 --> 00:34:44,570
construct like for each they do a bit of

00:34:41,090 --> 00:34:47,899
a setup beforehand so if you would jump

00:34:44,570 --> 00:34:50,659
directly into statements within before

00:34:47,899 --> 00:34:53,600
each loop because the setup hasn't been

00:34:50,659 --> 00:34:56,060
done at the end of the loop and some

00:34:53,600 --> 00:34:58,460
things need to be checked it couldn't

00:34:56,060 --> 00:35:00,470
because the setup hasn't been done so

00:34:58,460 --> 00:35:03,080
the implementation of for each made it

00:35:00,470 --> 00:35:05,360
very nearly impossible to Jim randomly

00:35:03,080 --> 00:35:07,940
into control into control structures

00:35:05,360 --> 00:35:10,190
like the for each loop so this is why P

00:35:07,940 --> 00:35:12,050
go to and PHP only allows you to jump

00:35:10,190 --> 00:35:16,160
out of control structures and never into

00:35:12,050 --> 00:35:18,530
them implementation details I would also

00:35:16,160 --> 00:35:21,020
say that is a really nice restriction

00:35:18,530 --> 00:35:23,300
logical wise because jumping all across

00:35:21,020 --> 00:35:24,790
your function where to go to is kind of

00:35:23,300 --> 00:35:27,170
rubbish to do

00:35:24,790 --> 00:35:30,350
all right let's have a quick look at

00:35:27,170 --> 00:35:32,090
what the stuff is the first thing is we

00:35:30,350 --> 00:35:33,620
do the assignment of the array and you

00:35:32,090 --> 00:35:36,020
don't see the values of the array here

00:35:33,620 --> 00:35:37,970
because PHP is already optimized it outs

00:35:36,020 --> 00:35:39,650
because it's a constant array it has

00:35:37,970 --> 00:35:40,580
created a structure in memory for you

00:35:39,650 --> 00:35:43,640
which is immutable

00:35:40,580 --> 00:35:47,600
it's a nice thing PHP 5 doesn't do that

00:35:43,640 --> 00:35:50,870
as well and then you get a few up codes

00:35:47,600 --> 00:35:55,910
that do the setup of you for each loop

00:35:50,870 --> 00:35:57,980
which are the reset the set and your and

00:35:55,910 --> 00:36:03,770
then we do the assignment so what do

00:35:57,980 --> 00:36:05,510
this op codes do so if you reset reset

00:36:03,770 --> 00:36:07,790
the internal structure of the array it

00:36:05,510 --> 00:36:09,530
is to make sure that the internal point

00:36:07,790 --> 00:36:15,350
is start at a first element in your

00:36:09,530 --> 00:36:19,940
array so it resets that if if it counts

00:36:15,350 --> 00:36:21,800
do that it jumps to up code 11 reasons

00:36:19,940 --> 00:36:23,510
why it might not be able to do that for

00:36:21,800 --> 00:36:25,400
example if you don't give it an array or

00:36:23,510 --> 00:36:29,360
if you don't give it an iterable then

00:36:25,400 --> 00:36:31,490
because you can't loop over a string as

00:36:29,360 --> 00:36:33,080
easily it jumps out it generates a

00:36:31,490 --> 00:36:36,650
warning and then it jumps out of the

00:36:33,080 --> 00:36:39,980
loop which is why jumps with the 11 to

00:36:36,650 --> 00:36:41,750
the mp3 doesn't know beforehand that are

00:36:39,980 --> 00:36:44,540
going to give an object or an array or

00:36:41,750 --> 00:36:46,610
an iterable object or an array or string

00:36:44,540 --> 00:36:51,650
so it can't optimize for that right now

00:36:46,610 --> 00:36:53,960
a problem we then do the SE such as you

00:36:51,650 --> 00:36:56,510
that's a very complete complex of code

00:36:53,960 --> 00:36:59,810
didn't I did I not say that that op

00:36:56,510 --> 00:37:04,280
codes only has two operands before well

00:36:59,810 --> 00:37:07,580
this one is straight because of PHP it

00:37:04,280 --> 00:37:09,770
is actually 2 but because of flags one

00:37:07,580 --> 00:37:13,850
of them is you've reused so it actually

00:37:09,770 --> 00:37:15,910
one operand and goes two things yeah PHP

00:37:13,850 --> 00:37:20,240
what can I say

00:37:15,910 --> 00:37:25,540
see it fetches the array element here so

00:37:20,240 --> 00:37:30,010
from the reset array we fetch the

00:37:25,540 --> 00:37:30,010
element F

00:37:30,920 --> 00:37:36,980
so I'm sorry the reason for this is the

00:37:33,799 --> 00:37:38,900
sex axis value and then there's also the

00:37:36,980 --> 00:37:41,839
assignment for the key so the facts

00:37:38,900 --> 00:37:44,900
actually gets the key now let's say that

00:37:41,839 --> 00:37:49,809
wrong right sorry this complicated the

00:37:44,900 --> 00:37:51,859
stretch sex is the value that is the

00:37:49,809 --> 00:37:53,450
exclamation mark volunteer and then it

00:37:51,859 --> 00:37:56,089
also does an assignment and the

00:37:53,450 --> 00:37:58,190
assignment isn't always there where it

00:37:56,089 --> 00:38:00,650
uses the return of this temporary

00:37:58,190 --> 00:38:05,769
variable which then contains the key and

00:38:00,650 --> 00:38:09,170
then it assigns that to exclamation mark

00:38:05,769 --> 00:38:10,960
it's completed it works most of the time

00:38:09,170 --> 00:38:13,519
and that's there's a bug somewhere and

00:38:10,960 --> 00:38:15,279
then execute some bits and then at the

00:38:13,519 --> 00:38:18,859
end of the 4-h group it does a jump an

00:38:15,279 --> 00:38:20,470
unconditional jump back to the fetch so

00:38:18,859 --> 00:38:23,750
it doesn't go back to the resulting

00:38:20,470 --> 00:38:26,269
because it has to reset the Iranian now

00:38:23,750 --> 00:38:29,359
this also means that if you ask elements

00:38:26,269 --> 00:38:31,789
to an array this works you sign-in page

00:38:29,359 --> 00:38:33,289
screen you can vote for free qing over

00:38:31,789 --> 00:38:34,910
something you can off more elements to

00:38:33,289 --> 00:38:37,509
generate now if the internal array

00:38:34,910 --> 00:38:39,500
pointer has gone beyond the original

00:38:37,509 --> 00:38:43,369
beyond the element that you're inserting

00:38:39,500 --> 00:38:44,990
then it won't show up again I would

00:38:43,369 --> 00:38:47,180
recommend people just don't do this

00:38:44,990 --> 00:38:49,339
because it's not particularly nice

00:38:47,180 --> 00:38:52,220
coding reading which you can if you want

00:38:49,339 --> 00:38:53,869
to for each now we get really complex

00:38:52,220 --> 00:38:55,519
loops and massive structures and then it

00:38:53,869 --> 00:38:59,359
gets kind of mind-boggling right suits

00:38:55,519 --> 00:39:02,599
if you go through it you can follow

00:38:59,359 --> 00:39:08,390
mostly what it does but what I want to

00:39:02,599 --> 00:39:10,309
highlight here this is the is that field

00:39:08,390 --> 00:39:12,430
Lee also shows you the in and out so

00:39:10,309 --> 00:39:15,170
that the little arrows basically

00:39:12,430 --> 00:39:17,660
indicated the start of a branch and the

00:39:15,170 --> 00:39:22,369
end of a branch and a branch in this

00:39:17,660 --> 00:39:24,170
complex loops you have the if-else is

00:39:22,369 --> 00:39:27,740
two branches out you can either either

00:39:24,170 --> 00:39:28,549
go into the if through or give false

00:39:27,740 --> 00:39:31,519
statements

00:39:28,549 --> 00:39:33,920
so those are two branches then within

00:39:31,519 --> 00:39:36,349
the it with any else there's another two

00:39:33,920 --> 00:39:37,970
branches there's the if matches or the

00:39:36,349 --> 00:39:40,490
if doesn't matches even though the elf

00:39:37,970 --> 00:39:42,589
has no case it is still a branch in here

00:39:40,490 --> 00:39:45,799
and that shows with all the little

00:39:42,589 --> 00:39:48,229
arrows here and when you go through this

00:39:45,799 --> 00:39:49,069
you can actually construct more

00:39:48,229 --> 00:39:50,900
interesting things

00:39:49,069 --> 00:39:55,849
however this gets so complicated just

00:39:50,900 --> 00:39:59,599
like trimer sure everything is film xkcd

00:39:55,849 --> 00:40:01,309
where I stole this slide from has one of

00:39:59,599 --> 00:40:03,200
those comics and has the timelines of

00:40:01,309 --> 00:40:05,180
films so one of them is the Lord of the

00:40:03,200 --> 00:40:07,190
Rings way of all the characters meeting

00:40:05,180 --> 00:40:09,319
and I'm splitting apart and reaching

00:40:07,190 --> 00:40:10,670
again and then they show primer where

00:40:09,319 --> 00:40:13,219
there's three main characters but

00:40:10,670 --> 00:40:15,650
because this is a film about time travel

00:40:13,219 --> 00:40:17,749
the loops gets extremely complicated

00:40:15,650 --> 00:40:19,069
because people go back in time and it's

00:40:17,749 --> 00:40:21,349
not as complicated as this type that

00:40:19,069 --> 00:40:25,729
it's mind boggling so you got so complex

00:40:21,349 --> 00:40:27,440
that you can't make any any sense out of

00:40:25,729 --> 00:40:29,630
it at some point which is the same thing

00:40:27,440 --> 00:40:31,430
if you get so many statements here it

00:40:29,630 --> 00:40:36,380
gets really complicated it gets

00:40:31,430 --> 00:40:37,609
complicated to read and it also got

00:40:36,380 --> 00:40:39,680
complicated for all the reasons over

00:40:37,609 --> 00:40:41,329
there back to the moment alright so this

00:40:39,680 --> 00:40:43,489
complex loops it would be nice if you

00:40:41,329 --> 00:40:45,890
can visualize them right and that's

00:40:43,489 --> 00:40:49,369
basically what really also allows you to

00:40:45,890 --> 00:40:53,269
is allows you to create a graph of all

00:40:49,369 --> 00:40:56,479
the complex loops that are in there so

00:40:53,269 --> 00:40:58,819
for example the grass on the right hand

00:40:56,479 --> 00:41:01,489
side here shows what are the

00:40:58,819 --> 00:41:04,969
possibilities so this target up code 0

00:41:01,489 --> 00:41:09,650
and 1 which are here the start of your

00:41:04,969 --> 00:41:13,400
for each right then it can either jump

00:41:09,650 --> 00:41:16,219
to the next one which is opcode 2 which

00:41:13,400 --> 00:41:17,690
is the fetch here or as I show you it

00:41:16,219 --> 00:41:19,819
can jump to number 12 and that is all

00:41:17,690 --> 00:41:21,799
this arrow shows here a jump tsunami

00:41:19,819 --> 00:41:25,400
trail which is line 8 in your script

00:41:21,799 --> 00:41:26,539
which would be this one mega maybe

00:41:25,400 --> 00:41:28,999
should have line number them that'd be

00:41:26,539 --> 00:41:31,099
easier and then it access the function

00:41:28,999 --> 00:41:33,859
by using a bug on directly out of it

00:41:31,099 --> 00:41:37,910
because that is the return here now if

00:41:33,859 --> 00:41:43,700
the Freak is right because this is a

00:41:37,910 --> 00:41:45,710
loop there's another jump to at the end

00:41:43,700 --> 00:41:46,880
of the loop so this is the loop and if

00:41:45,710 --> 00:41:49,190
there's multiple hits in there right

00:41:46,880 --> 00:41:51,079
there's the H on this side there CS on

00:41:49,190 --> 00:41:53,479
this side and then that such as opcode

00:41:51,079 --> 00:41:55,549
11 which is also binary that is the end

00:41:53,479 --> 00:41:57,760
of the loop here and end of the loop of

00:41:55,549 --> 00:42:01,120
course it jumps back to up kosis

00:41:57,760 --> 00:42:03,940
it is this jump here so the numbers here

00:42:01,120 --> 00:42:06,670
the opcode represents the numbers here

00:42:03,940 --> 00:42:08,140
to sort of tie them together I can

00:42:06,670 --> 00:42:09,160
figure out a better way of visualizing

00:42:08,140 --> 00:42:11,160
this yes

00:42:09,160 --> 00:42:16,090
but here's an idea and I have written up

00:42:11,160 --> 00:42:19,120
these complex loops are important

00:42:16,090 --> 00:42:19,980
because they allow you to do some other

00:42:19,120 --> 00:42:22,060
things too

00:42:19,980 --> 00:42:23,680
okay the last one I want to talk about

00:42:22,060 --> 00:42:30,250
is exceptions because they are a bit of

00:42:23,680 --> 00:42:31,630
a tricky case exceptions in PHP every

00:42:30,250 --> 00:42:32,950
function has a starting point right

00:42:31,630 --> 00:42:35,320
which is the start of your function

00:42:32,950 --> 00:42:37,600
however the catch statement is also

00:42:35,320 --> 00:42:40,750
starting point of your function it has

00:42:37,600 --> 00:42:43,330
to be like that because suddenly well

00:42:40,750 --> 00:42:45,960
code is being executed so if you try

00:42:43,330 --> 00:42:49,240
you'd be calling multiple functions here

00:42:45,960 --> 00:42:51,220
nested levels for functions called fall

00:42:49,240 --> 00:42:53,740
of function so if you do a throw

00:42:51,220 --> 00:42:55,810
somewhere and there's no try catch block

00:42:53,740 --> 00:42:57,850
around it earlier then certainly the

00:42:55,810 --> 00:43:00,940
control the executed function gets

00:42:57,850 --> 00:43:03,130
transferred back to this function and it

00:43:00,940 --> 00:43:05,230
goes straight to the catch statement the

00:43:03,130 --> 00:43:08,220
sketch statement denoted by an e here

00:43:05,230 --> 00:43:12,250
are often entry point to your function

00:43:08,220 --> 00:43:15,330
now and then yes finally

00:43:12,250 --> 00:43:17,680
and finally the implementation is very

00:43:15,330 --> 00:43:20,890
complicated because this finally needs

00:43:17,680 --> 00:43:23,830
to be executed regardless regardless

00:43:20,890 --> 00:43:26,770
where there's a catch or not and in some

00:43:23,830 --> 00:43:32,320
cases if you have nested catches it

00:43:26,770 --> 00:43:35,230
needs to figure out where which entry

00:43:32,320 --> 00:43:38,650
point was being used to get into the

00:43:35,230 --> 00:43:41,260
specific catch statement to be able to

00:43:38,650 --> 00:43:42,940
then jump to the final E and that is

00:43:41,260 --> 00:43:46,150
that happens through this up code called

00:43:42,940 --> 00:43:48,070
solve call I don't like the name of this

00:43:46,150 --> 00:43:49,570
up code because it has the word fast in

00:43:48,070 --> 00:43:51,610
it and has nothing to do with it being

00:43:49,570 --> 00:43:54,810
fast or slow there's no slow call

00:43:51,610 --> 00:43:57,370
function it is internally a way of

00:43:54,810 --> 00:44:00,550
remembering where we came from and

00:43:57,370 --> 00:44:02,140
whether we need to after the catch is

00:44:00,550 --> 00:44:06,070
being processed need to jump out of the

00:44:02,140 --> 00:44:09,640
function or not so if if there was an

00:44:06,070 --> 00:44:10,880
exception in try then it would do one of

00:44:09,640 --> 00:44:13,220
the catches

00:44:10,880 --> 00:44:15,080
at the end of the catch you see the jump

00:44:13,220 --> 00:44:16,820
here too of course as an outright that

00:44:15,080 --> 00:44:19,100
there is a sauce Co you don't see that

00:44:16,820 --> 00:44:20,660
as a love song because it just drops

00:44:19,100 --> 00:44:24,020
down to that automatically it's like

00:44:20,660 --> 00:44:27,670
great intentionally missing in PHP

00:44:24,020 --> 00:44:34,220
internal so just to solve stole and if

00:44:27,670 --> 00:44:38,420
there was if it came out as a catch

00:44:34,220 --> 00:44:41,900
then it remembers that jump stop code

00:44:38,420 --> 00:44:44,390
nine which is the maximum this is echo

00:44:41,900 --> 00:44:47,000
in finally and then the salt reps uses

00:44:44,390 --> 00:44:49,970
the value that was set by sauce call to

00:44:47,000 --> 00:44:51,350
either jump out of the function because

00:44:49,970 --> 00:44:53,450
there's an exception and if there's an

00:44:51,350 --> 00:44:55,640
exception anything also the try catch

00:44:53,450 --> 00:44:57,500
finally the after doesn't get executed

00:44:55,640 --> 00:45:02,870
right it means to jump immediately out

00:44:57,500 --> 00:45:04,970
of the function or it just drops down

00:45:02,870 --> 00:45:06,920
and then it's executed the off the

00:45:04,970 --> 00:45:08,090
return here so if there was an exception

00:45:06,920 --> 00:45:10,370
being caught

00:45:08,090 --> 00:45:12,530
clouds rats also returned from the

00:45:10,370 --> 00:45:15,740
function so it doesn't do this last echo

00:45:12,530 --> 00:45:19,310
after if you look at how this is

00:45:15,740 --> 00:45:21,380
implemented then you might want to tear

00:45:19,310 --> 00:45:25,490
your heads up like as you can see I have

00:45:21,380 --> 00:45:27,050
very many anyone so what the analysis of

00:45:25,490 --> 00:45:28,970
all those looping structures can

00:45:27,050 --> 00:45:31,160
actually give you is death code analysis

00:45:28,970 --> 00:45:33,080
and that code analysis is basically ways

00:45:31,160 --> 00:45:34,940
to figuring out which branches cannot be

00:45:33,080 --> 00:45:36,830
reached and that is something that I

00:45:34,940 --> 00:45:38,690
book does internally and we will be

00:45:36,830 --> 00:45:41,330
shows you that as well by showing a

00:45:38,690 --> 00:45:43,160
little star here a typical example that

00:45:41,330 --> 00:45:46,160
I'm having ears are trying to an if

00:45:43,160 --> 00:45:47,450
statement echoing forty then we return

00:45:46,160 --> 00:45:50,900
from the function and then I have an old

00:45:47,450 --> 00:45:52,610
echo statement there too of course when

00:45:50,900 --> 00:45:54,290
you look at this code is quite quite

00:45:52,610 --> 00:45:56,330
obvious that it's never going to act

00:45:54,290 --> 00:45:58,430
echo due to here because it's off the

00:45:56,330 --> 00:46:00,650
return statement the similar way that if

00:45:58,430 --> 00:46:03,290
you do with trove and then you do an

00:46:00,650 --> 00:46:05,150
echo behind it he also would never get

00:46:03,290 --> 00:46:06,860
it happening because he cannot simply

00:46:05,150 --> 00:46:10,670
reach that code so of course this is a

00:46:06,860 --> 00:46:12,380
simple example in some cases is less

00:46:10,670 --> 00:46:16,040
obvious that you have death code for

00:46:12,380 --> 00:46:18,800
other reasons and PHP would not find

00:46:16,040 --> 00:46:21,650
death codes if you had a conference

00:46:18,800 --> 00:46:24,170
value for s by the way because we up to

00:46:21,650 --> 00:46:24,750
PHP itself doesn't have an optimizer so

00:46:24,170 --> 00:46:26,610
it doesn't

00:46:24,750 --> 00:46:30,510
it doesn't eliminate the code that

00:46:26,610 --> 00:46:32,220
cannot be reached it just doesn't do

00:46:30,510 --> 00:46:35,280
that up cash just do some of that

00:46:32,220 --> 00:46:37,860
actually so Maloney does it speed up PHP

00:46:35,280 --> 00:46:39,150
it also removes code so that it doesn't

00:46:37,860 --> 00:46:42,750
have to take care of its stores and

00:46:39,150 --> 00:46:44,340
execute us so in any case what we will

00:46:42,750 --> 00:46:46,230
be an XD book under the hood - is

00:46:44,340 --> 00:46:47,970
actually allow you to follow the

00:46:46,230 --> 00:46:51,000
branches and if some branches cannot be

00:46:47,970 --> 00:46:55,920
reached for logical for logical reasons

00:46:51,000 --> 00:47:00,270
then it marks it as such and and then

00:46:55,920 --> 00:47:02,220
from their own by knowing which bits of

00:47:00,270 --> 00:47:06,030
code connect not be executed which paths

00:47:02,220 --> 00:47:08,190
cannot be hit you can go more

00:47:06,030 --> 00:47:10,620
complicated by doing branch analysis and

00:47:08,190 --> 00:47:13,920
branch analysis basically the following

00:47:10,620 --> 00:47:15,600
for the following problem now I know all

00:47:13,920 --> 00:47:18,690
of you are really good writing units at

00:47:15,600 --> 00:47:21,480
solve your code right I see something I

00:47:18,690 --> 00:47:22,830
hear some people smirk and laugh and I

00:47:21,480 --> 00:47:26,640
know but they know that they should

00:47:22,830 --> 00:47:31,320
write more test cases in but a part of

00:47:26,640 --> 00:47:32,460
writing unit tests is people try to go

00:47:31,320 --> 00:47:33,990
for a hundred percent code coverage

00:47:32,460 --> 00:47:35,910
right sometimes like it needs to be

00:47:33,990 --> 00:47:39,450
green otherwise it's not going to be

00:47:35,910 --> 00:47:40,950
great now having everything green and

00:47:39,450 --> 00:47:43,140
code coverage doesn't tell you

00:47:40,950 --> 00:47:45,570
everything it tells you that you have at

00:47:43,140 --> 00:47:47,520
least hits everything aligned in your

00:47:45,570 --> 00:47:51,600
code but it doesn't mean you have tested

00:47:47,520 --> 00:47:53,340
it all correctly and the only way how to

00:47:51,600 --> 00:47:55,020
do that is making sure that not only do

00:47:53,340 --> 00:47:59,340
we hit every line you also hit every

00:47:55,020 --> 00:48:00,690
possible path or rather from all the

00:47:59,340 --> 00:48:02,580
branches that you can do you need to

00:48:00,690 --> 00:48:04,290
have all the combinations so that gets

00:48:02,580 --> 00:48:07,290
tested every part through your code and

00:48:04,290 --> 00:48:09,930
that is of XD book now allows you to do

00:48:07,290 --> 00:48:11,730
it unfortunately PHP unit doesn't

00:48:09,930 --> 00:48:13,470
implement this yet it doesn't do

00:48:11,730 --> 00:48:15,360
anything with the information yet and

00:48:13,470 --> 00:48:18,330
that is not because they don't want to

00:48:15,360 --> 00:48:20,580
do it but it is because it produces so

00:48:18,330 --> 00:48:22,890
much information that you basically run

00:48:20,580 --> 00:48:25,350
and run out of memory before he has a

00:48:22,890 --> 00:48:27,210
chance to visualize it so my simple

00:48:25,350 --> 00:48:29,250
example is still quite easy to

00:48:27,210 --> 00:48:31,200
understand but it gets more complicated

00:48:29,250 --> 00:48:33,720
especially when you have so many nested

00:48:31,200 --> 00:48:35,550
loops everywhere so let's see what

00:48:33,720 --> 00:48:36,930
happens here so I really if-then-else

00:48:35,550 --> 00:48:38,730
going to ignore loop here

00:48:36,930 --> 00:48:41,100
if one else has to

00:48:38,730 --> 00:48:43,080
a statement right it can be true or

00:48:41,100 --> 00:48:45,150
false and B can be true or false but

00:48:43,080 --> 00:48:47,609
with two test cases I get to call for

00:48:45,150 --> 00:48:50,400
every single line in the test cases here

00:48:47,609 --> 00:48:52,170
are I call them the true and false and

00:48:50,400 --> 00:48:53,430
which falls on true which means if we

00:48:52,170 --> 00:48:59,040
look at my code coverage will show up as

00:48:53,430 --> 00:48:59,790
100% actually it looks like if you write

00:48:59,040 --> 00:49:01,530
as yourself

00:48:59,790 --> 00:49:04,050
it looks like this but I'm just showing

00:49:01,530 --> 00:49:06,090
you how the output of it right so you

00:49:04,050 --> 00:49:09,570
can see every single line in here is now

00:49:06,090 --> 00:49:15,359
green which yeh have 100% but you

00:49:09,570 --> 00:49:17,730
haven't done all of it yet right so so

00:49:15,359 --> 00:49:20,700
what you haven't tested you haven't

00:49:17,730 --> 00:49:23,550
tested a being true and B being true or

00:49:20,700 --> 00:49:25,560
a being false and B being soft we have

00:49:23,550 --> 00:49:27,510
only done the true/false and a false

00:49:25,560 --> 00:49:29,180
true so you're basically lying to

00:49:27,510 --> 00:49:31,050
yourself 100% code coverage isn't

00:49:29,180 --> 00:49:34,980
actually tell you that you have tested

00:49:31,050 --> 00:49:36,720
all of your code so what you can do

00:49:34,980 --> 00:49:37,980
because XD becomes really do it

00:49:36,720 --> 00:49:40,410
internally they do something called

00:49:37,980 --> 00:49:43,770
branch analysis which is the new magic

00:49:40,410 --> 00:49:47,760
Sofia set so the feature and this new

00:49:43,770 --> 00:49:49,230
magic sauce not only tries to find out

00:49:47,760 --> 00:49:50,820
which code cannot be reached with that

00:49:49,230 --> 00:49:53,150
code analysis but it also figured out

00:49:50,820 --> 00:49:57,180
which possible pulse you can have

00:49:53,150 --> 00:50:00,090
through a function now I have to say

00:49:57,180 --> 00:50:03,090
that this is the problem here is it's an

00:50:00,090 --> 00:50:07,020
exponentially complicated program like

00:50:03,090 --> 00:50:08,609
every statement you do means doubling

00:50:07,020 --> 00:50:11,130
the amount of thoughts that you have so

00:50:08,609 --> 00:50:12,869
with my two Lea statements you can

00:50:11,130 --> 00:50:18,060
probably guess how many pulse possible

00:50:12,869 --> 00:50:20,280
pulses are there which is four okay so

00:50:18,060 --> 00:50:21,600
what comes out of XD book or actually be

00:50:20,280 --> 00:50:23,460
able to use something like this it shows

00:50:21,600 --> 00:50:24,869
you all the different branches and then

00:50:23,460 --> 00:50:26,850
all the different parts and it will tell

00:50:24,869 --> 00:50:29,970
you whether the fault has been executed

00:50:26,850 --> 00:50:32,010
or not so the accent not any hit means

00:50:29,970 --> 00:50:34,320
hit this which is very simple

00:50:32,010 --> 00:50:39,150
personalization it is easy to see it as

00:50:34,320 --> 00:50:43,890
an accurate across here so with function

00:50:39,150 --> 00:50:46,050
and these statements it outputs

00:50:43,890 --> 00:50:48,720
something like this so you have the four

00:50:46,050 --> 00:50:50,190
different parts right so you have the

00:50:48,720 --> 00:50:53,010
dosatron side ones that haven't been

00:50:50,190 --> 00:50:54,510
executed and it

00:50:53,010 --> 00:50:57,480
solid loans are the ones that have been

00:50:54,510 --> 00:51:01,140
executed so the first one is where a

00:50:57,480 --> 00:51:03,660
equals true as well as V being true is

00:51:01,140 --> 00:51:06,510
not being hit the same thing is the

00:51:03,660 --> 00:51:08,580
purple one here the first is not being

00:51:06,510 --> 00:51:10,260
hit and the second is not being it is

00:51:08,580 --> 00:51:13,140
also dashed line because the thought is

00:51:10,260 --> 00:51:16,140
also not be run now the problem here is

00:51:13,140 --> 00:51:18,840
if even the two if statements I have for

00:51:16,140 --> 00:51:21,240
pulse already if I had plenty statements

00:51:18,840 --> 00:51:25,170
I'd have a thousand and seventy for pulp

00:51:21,240 --> 00:51:26,790
or if I have sixteen if statements or

00:51:25,170 --> 00:51:28,140
loops because they're basically

00:51:26,790 --> 00:51:30,630
statements they're the same kind of go

00:51:28,140 --> 00:51:32,100
to think then in having so many parts

00:51:30,630 --> 00:51:34,320
that you run out of color that your eyes

00:51:32,100 --> 00:51:37,170
can distinguish right nobody can see

00:51:34,320 --> 00:51:39,210
sixty-four thousand colors at eyes also

00:51:37,170 --> 00:51:42,330
how do you visualize that almost almost

00:51:39,210 --> 00:51:44,400
slide I can't show you sixty-four

00:51:42,330 --> 00:51:46,230
thousand lines here you would never be

00:51:44,400 --> 00:51:47,670
able to find anything about this eye you

00:51:46,230 --> 00:51:50,100
can never make any heads or tails of

00:51:47,670 --> 00:51:51,390
that so the visualization of the pulse

00:51:50,100 --> 00:51:54,990
coverage is actually really difficult

00:51:51,390 --> 00:51:57,660
thing to do and as I said it's this

00:51:54,990 --> 00:51:59,730
exponential problem as well so I don't

00:51:57,660 --> 00:52:01,710
think you'll see this showing up into

00:51:59,730 --> 00:52:03,450
PHP code code works repeat its repeat

00:52:01,710 --> 00:52:06,180
for unit anytime really soon

00:52:03,450 --> 00:52:08,970
unfortunately it is also ridiculously

00:52:06,180 --> 00:52:09,660
slow but let's not talk about it all

00:52:08,970 --> 00:52:11,880
right

00:52:09,660 --> 00:52:14,190
so a recap for me before we do a few

00:52:11,880 --> 00:52:16,170
questions we've spoken about the

00:52:14,190 --> 00:52:18,450
different stages executing code right so

00:52:16,170 --> 00:52:20,550
we started the PHP script you turn it

00:52:18,450 --> 00:52:23,490
into tokens you can visualize that it's

00:52:20,550 --> 00:52:25,920
tokenizer then we go with the parser to

00:52:23,490 --> 00:52:28,470
this abstract syntax tree which you can

00:52:25,920 --> 00:52:29,940
visualize as an extension of which size

00:52:28,470 --> 00:52:32,160
created a few links for you here and

00:52:29,940 --> 00:52:33,360
from the AC we go to the bytes of the

00:52:32,160 --> 00:52:36,120
opcodes which you can visualize it

00:52:33,360 --> 00:52:38,310
wielding all the looping structures in

00:52:36,120 --> 00:52:40,770
PHP are all implemented as jumps or

00:52:38,310 --> 00:52:43,020
goatees and then we look at some code

00:52:40,770 --> 00:52:46,040
analysis for fun and profit but not sure

00:52:43,020 --> 00:52:47,280
what ever some definitely no profit

00:52:46,040 --> 00:52:50,400
anyway

00:52:47,280 --> 00:52:53,810
shove off the jumps the go to the I want

00:52:50,400 --> 00:52:53,810
to talk about are there any questions

00:52:55,299 --> 00:53:04,719
I know it did it at UH fun wasn't it no

00:52:59,949 --> 00:53:06,579
questions at all yes on that

00:53:04,719 --> 00:53:07,719
I'm being blinded by the light source on

00:53:06,579 --> 00:53:10,539
such difficult to see

00:53:07,719 --> 00:53:12,249
I just asked one guys because it was a

00:53:10,539 --> 00:53:14,349
great talk and what a question I suppose

00:53:12,249 --> 00:53:16,329
I'm so if you go back to the if elf

00:53:14,349 --> 00:53:19,029
thing you were sharing with the testing

00:53:16,329 --> 00:53:22,299
just I mean theoretically the problem

00:53:19,029 --> 00:53:24,880
there is obviously because you're not

00:53:22,299 --> 00:53:26,380
using like scaler hints or anything like

00:53:24,880 --> 00:53:28,359
that I mean a and B could be anything

00:53:26,380 --> 00:53:30,429
there could be strings advantages so

00:53:28,359 --> 00:53:33,099
that graph doesn't even show the scale

00:53:30,429 --> 00:53:35,979
of what you need to tell theoretically

00:53:33,099 --> 00:53:38,469
basically Alegria so I mean that is that

00:53:35,979 --> 00:53:40,179
sort of reason why is that I mean as you

00:53:38,469 --> 00:53:42,489
said about the memory issues that you

00:53:40,179 --> 00:53:45,159
know some of this unit testing you'll

00:53:42,489 --> 00:53:47,739
never ever necessarily get 100% code

00:53:45,159 --> 00:53:50,799
coverage because theoretically it may be

00:53:47,739 --> 00:53:54,729
impossible yeah it might also sometimes

00:53:50,799 --> 00:53:56,709
cases that you defensively go against we

00:53:54,729 --> 00:53:58,869
would never ever happen in running your

00:53:56,709 --> 00:54:00,519
tests right like the hard drive being

00:53:58,869 --> 00:54:03,639
full because you definitely can't create

00:54:00,519 --> 00:54:05,709
a salt I mean you can't really test for

00:54:03,639 --> 00:54:07,569
that well unless your SQL lies then you

00:54:05,709 --> 00:54:09,909
test for people unplugging the server

00:54:07,569 --> 00:54:12,669
actually have test cases for not sure

00:54:09,909 --> 00:54:14,679
how they run that I don't think that's

00:54:12,669 --> 00:54:16,119
physically a person putting the flood

00:54:14,679 --> 00:54:18,749
water running the tests or something but

00:54:16,119 --> 00:54:20,859
yeah those things are difficult however

00:54:18,749 --> 00:54:23,559
you meant the thing you mentioned about

00:54:20,859 --> 00:54:26,409
the types in there at this stage in PHP

00:54:23,559 --> 00:54:29,380
PHP doesn't know anything about that so

00:54:26,409 --> 00:54:31,509
it is not something that code analysis

00:54:29,380 --> 00:54:33,999
can actually show you unless you start

00:54:31,509 --> 00:54:36,549
using the scalar Tysons but even then it

00:54:33,999 --> 00:54:39,249
is only check when the function gets

00:54:36,549 --> 00:54:40,269
executed after that has happens PHP

00:54:39,249 --> 00:54:43,089
doesn't do anything with this

00:54:40,269 --> 00:54:45,999
information at the moment so that might

00:54:43,089 --> 00:54:47,529
be a next stage for making people you

00:54:45,999 --> 00:54:49,659
can go faster by having the

00:54:47,529 --> 00:54:52,779
optimizations in the act that does allow

00:54:49,659 --> 00:54:54,939
PHP to have the special opcode

00:54:52,779 --> 00:54:56,859
to deal with those specific cases but

00:54:54,939 --> 00:54:59,469
that's not there right now that's

00:54:56,859 --> 00:55:04,630
hopefully in the future I have a

00:54:59,469 --> 00:55:07,389
question is there any way existing way

00:55:04,630 --> 00:55:08,079
of visualizing this pass one is missing

00:55:07,389 --> 00:55:10,689
one is

00:55:08,079 --> 00:55:12,339
when you have I mean the New York you

00:55:10,689 --> 00:55:15,999
look at the corn okay of course for

00:55:12,339 --> 00:55:17,529
graphs Adams is doing anything in your

00:55:15,999 --> 00:55:21,339
toolbox and you are working with it

00:55:17,529 --> 00:55:25,719
which helps you with it now we can maybe

00:55:21,339 --> 00:55:27,489
can reuse or there exists the graph that

00:55:25,719 --> 00:55:30,849
I'm sharing the our key being generated

00:55:27,489 --> 00:55:33,819
so I didn't hand draw the diagram okay

00:55:30,849 --> 00:55:35,829
I'm rubbish drawing diagram so this is

00:55:33,819 --> 00:55:39,640
it look what the tool does it creates a

00:55:35,829 --> 00:55:41,410
dot file here adopted the formula that

00:55:39,640 --> 00:55:43,689
that yeah you can interpret with

00:55:41,410 --> 00:55:47,380
different visualization tools to create

00:55:43,689 --> 00:55:51,789
kind of graphs like this so would you do

00:55:47,380 --> 00:55:56,009
see any usefulness and overlaying that

00:55:51,789 --> 00:56:00,279
information are over actual source code

00:55:56,009 --> 00:56:04,890
so maybe reduce variance I did look as

00:56:00,279 --> 00:56:07,269
doing that and but again the problem is

00:56:04,890 --> 00:56:08,769
the amount of information you get the

00:56:07,269 --> 00:56:10,599
amount of salts that you get sometimes

00:56:08,769 --> 00:56:14,579
so overlaying it on top of source code

00:56:10,599 --> 00:56:14,579
again very difficult thing to do

00:56:14,939 --> 00:56:18,939
difficult to visualize in Scituate if

00:56:17,559 --> 00:56:20,589
you can still understand all that stuff

00:56:18,939 --> 00:56:25,049
yeah make it useful forget thank you

00:56:20,589 --> 00:56:25,049
yeah yeah all right here

00:56:30,460 --> 00:56:39,520
hi I know you said like there XD Vulcan

00:56:34,599 --> 00:56:42,160
vld advantage of needed classically

00:56:39,520 --> 00:56:44,500
won't be in piece per unit but can we

00:56:42,160 --> 00:56:46,089
still practically use these features in

00:56:44,500 --> 00:56:51,390
all setup each per unit yes and

00:56:46,089 --> 00:56:54,700
absolutely let me go invent inflation

00:56:51,390 --> 00:56:57,520
right we have not just seen like how

00:56:54,700 --> 00:56:58,839
could we take advantage of this a small

00:56:57,520 --> 00:57:01,089
scale you can't do a large scale because

00:56:58,839 --> 00:57:03,550
you run out of RAM but it small scale

00:57:01,089 --> 00:57:06,160
you know can you give any advice how we

00:57:03,550 --> 00:57:07,440
could use a set of jobs to like help us

00:57:06,160 --> 00:57:12,099
find stuff right

00:57:07,440 --> 00:57:13,780
so when Petri universe's it uses the so

00:57:12,099 --> 00:57:17,079
called PHP code court routines of this

00:57:13,780 --> 00:57:20,260
like Co CM that doesn't handle all the

00:57:17,079 --> 00:57:21,910
different things else but exhibit just

00:57:20,260 --> 00:57:24,369
output information so if you run code

00:57:21,910 --> 00:57:27,790
coverage with this extra magic sauce

00:57:24,369 --> 00:57:29,079
flag then the result of this when you

00:57:27,790 --> 00:57:30,849
get the code coverage has all the

00:57:29,079 --> 00:57:33,970
information about the pulse being hits

00:57:30,849 --> 00:57:35,799
all the branches in there and then you

00:57:33,970 --> 00:57:38,859
can visualize them so in a very simple

00:57:35,799 --> 00:57:40,930
case I visualize it like this but there

00:57:38,859 --> 00:57:42,520
certainly you can do more with this

00:57:40,930 --> 00:57:44,260
information than just throwing enormous

00:57:42,520 --> 00:57:45,940
slice and visualizing it's like you

00:57:44,260 --> 00:57:47,349
could write some analysis to show how

00:57:45,940 --> 00:57:49,299
many percentage of the clouds have been

00:57:47,349 --> 00:57:50,950
executed and things like that so the

00:57:49,299 --> 00:57:54,400
information that you gather out of here

00:57:50,950 --> 00:57:56,410
although it's very simply visualized

00:57:54,400 --> 00:57:58,270
here you can of course do more with it

00:57:56,410 --> 00:58:00,460
and this information comes back in PHP

00:57:58,270 --> 00:58:03,750
arrays so yeah you can do something with

00:58:00,460 --> 00:58:05,920
that and this is what PHP code coverage

00:58:03,750 --> 00:58:08,559
hopefully in the future we'll use to do

00:58:05,920 --> 00:58:12,280
something with but that's that is

00:58:08,559 --> 00:58:14,760
currently missing skill like as long

00:58:12,280 --> 00:58:19,869
that I think we have one more minute

00:58:14,760 --> 00:58:23,530
hello hello you shown how the how the

00:58:19,869 --> 00:58:26,230
for each loop works in from the point of

00:58:23,530 --> 00:58:29,950
view of tokens yeah I've got a question

00:58:26,230 --> 00:58:32,530
actually what's the diff how they yield

00:58:29,950 --> 00:58:38,380
for each loop differs from the original

00:58:32,530 --> 00:58:40,850
one the can repeat on yield like it will

00:58:38,380 --> 00:58:42,650
yield return yeah

00:58:40,850 --> 00:58:44,720
they're like a no it doesn't reset

00:58:42,650 --> 00:58:48,340
probably but it jumps like two

00:58:44,720 --> 00:58:50,590
completely different place and it I

00:58:48,340 --> 00:58:57,770
haven't looked at it yet

00:58:50,590 --> 00:58:59,930
personally let's find out now I don't

00:58:57,770 --> 00:59:01,580
have time to show you right now we ran

00:58:59,930 --> 00:59:03,980
out of time if I have five more minutes

00:59:01,580 --> 00:59:05,060
I can actually just show you I don't

00:59:03,980 --> 00:59:06,080
know at the moment how they look like

00:59:05,060 --> 00:59:08,570
but in high pitch you have look it up

00:59:06,080 --> 00:59:14,720
and come find me in I don't figure that

00:59:08,570 --> 00:59:22,100
out I haven't tried goes it's 12:30 well

00:59:14,720 --> 00:59:22,760
thanks very much oh alright I have one

00:59:22,100 --> 00:59:25,040
more point

00:59:22,760 --> 00:59:26,480
so this slide should show you the joint

00:59:25,040 --> 00:59:29,950
in link where you can leave feedback for

00:59:26,480 --> 00:59:33,800
this talk however is missing

00:59:29,950 --> 00:59:35,720
however this QR code will go to my sites

00:59:33,800 --> 00:59:38,830
where I have uploaded the slides already

00:59:35,720 --> 00:59:41,150
and where I will also other link for

00:59:38,830 --> 00:59:44,300
truly feedback for the talk which I'm

00:59:41,150 --> 00:59:47,120
more than welcome about p.m. and I've

00:59:44,300 --> 00:59:50,110
also tweet about this yes thanks and

00:59:47,120 --> 00:59:50,110

YouTube URL: https://www.youtube.com/watch?v=JAB8-8gW1UU


