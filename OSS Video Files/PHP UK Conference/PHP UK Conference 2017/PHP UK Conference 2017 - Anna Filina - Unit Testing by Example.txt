Title: PHP UK Conference 2017 - Anna Filina - Unit Testing by Example
Publication date: 2017-04-03
Playlist: PHP UK Conference 2017
Description: 
	Everyone tells you that you need to test. You know the theory, but you don't know where to begin. What to test? What cases to write? Through realistic and pragmatic examples, this presentation will take you away from var_dump and ease you into the testing business until you're ready to do TDD. All this without losing sight of the tight deadlines.
Captions: 
	00:00:03,720 --> 00:00:09,099
all right so let's talk about unit

00:00:05,890 --> 00:00:11,200
testing my example automating tests is

00:00:09,099 --> 00:00:14,589
typically fun for about a day what

00:00:11,200 --> 00:00:17,320
happens is it grows to a large code base

00:00:14,589 --> 00:00:19,600
so you you know we start with a few

00:00:17,320 --> 00:00:21,430
tests then it's a few hundred lines then

00:00:19,600 --> 00:00:24,280
it's thousands then it becomes spaghetti

00:00:21,430 --> 00:00:25,690
like every other code and then you just

00:00:24,280 --> 00:00:29,890
feel like you added more work to your

00:00:25,690 --> 00:00:31,840
plate and you don't see the point you're

00:00:29,890 --> 00:00:33,610
just writing more code basically and

00:00:31,840 --> 00:00:34,989
deadlines are coming up and a lot of

00:00:33,610 --> 00:00:38,530
people give up because of that

00:00:34,989 --> 00:00:42,249
so my name is Anna I'm a project rescue

00:00:38,530 --> 00:00:43,600
expert so I develop I train I speak on

00:00:42,249 --> 00:00:45,640
the company also organize two

00:00:43,600 --> 00:00:47,460
conferences one in Montreal another in

00:00:45,640 --> 00:00:52,030
Vancouver Canada

00:00:47,460 --> 00:00:53,469
so I said testing is hard I want to show

00:00:52,030 --> 00:00:55,829
you the result doesn't have to be like

00:00:53,469 --> 00:00:58,899
that it can actually be quite enjoyable

00:00:55,829 --> 00:01:00,909
the other thing is that I see a lot of

00:00:58,899 --> 00:01:03,010
test Suites that just test a whole lot

00:01:00,909 --> 00:01:06,130
of stuff without thinking about whether

00:01:03,010 --> 00:01:08,950
it has any use so I want to show you

00:01:06,130 --> 00:01:11,040
that basically want to show you how to

00:01:08,950 --> 00:01:14,049
create tests that are useful and

00:01:11,040 --> 00:01:18,969
actually ensure that you are eliminating

00:01:14,049 --> 00:01:21,009
bugs and also a lot of developers I

00:01:18,969 --> 00:01:22,780
speak to they say that they grow grey

00:01:21,009 --> 00:01:26,020
hair every time on the release date

00:01:22,780 --> 00:01:28,479
because there it's like 10:00 p.m. and

00:01:26,020 --> 00:01:30,310
suddenly they discover this bug and this

00:01:28,479 --> 00:01:31,990
bug is making the whole application not

00:01:30,310 --> 00:01:34,000
work and they have no idea how to solve

00:01:31,990 --> 00:01:37,140
it you know the deadline is coming they

00:01:34,000 --> 00:01:40,030
have to finish it they're tired and it

00:01:37,140 --> 00:01:41,530
really sucks and nobody wants top so we

00:01:40,030 --> 00:01:44,439
can avoid the stress and I'll show you

00:01:41,530 --> 00:01:47,320
how to do that so raise your hand if you

00:01:44,439 --> 00:01:51,340
ever started past 11 p.m. on the release

00:01:47,320 --> 00:01:57,640
night because of a bug I can say about

00:01:51,340 --> 00:01:59,679
1/3 the others are too dishonest all

00:01:57,640 --> 00:02:02,560
right or maybe you're that awesome ok

00:01:59,679 --> 00:02:06,219
good for you alright let's fix that

00:02:02,560 --> 00:02:07,440
let's fix us this pre-release stress one

00:02:06,219 --> 00:02:09,700
important thing to remember about

00:02:07,440 --> 00:02:11,830
testing in general is that you don't

00:02:09,700 --> 00:02:14,290
become a testing expert overnight you

00:02:11,830 --> 00:02:15,349
don't just go and read a blog post or

00:02:14,290 --> 00:02:17,510
read some manual

00:02:15,349 --> 00:02:19,010
and then you know how to go and apply

00:02:17,510 --> 00:02:20,540
the fear and it just works on the

00:02:19,010 --> 00:02:24,170
Thunder stop you have to start somewhere

00:02:20,540 --> 00:02:26,889
and if you haven't had any successful

00:02:24,170 --> 00:02:29,450
testing I recommend that you start by

00:02:26,889 --> 00:02:32,239
writing tests after your code is already

00:02:29,450 --> 00:02:35,090
written and I can see some stones flying

00:02:32,239 --> 00:02:38,180
from the TDD found back there don't

00:02:35,090 --> 00:02:41,329
worry it's just a way to learn until you

00:02:38,180 --> 00:02:43,129
know how to how to apply this theory in

00:02:41,329 --> 00:02:45,499
cycle the next stage so it's a process

00:02:43,129 --> 00:02:47,389
you have to practice you cannot just go

00:02:45,499 --> 00:02:49,639
onstage and perform you have to practice

00:02:47,389 --> 00:02:52,250
before so show you the different steps

00:02:49,639 --> 00:02:54,590
to accomplish that the other thing is

00:02:52,250 --> 00:02:56,569
pretty controversial if you don't start

00:02:54,590 --> 00:02:59,349
with a hundred percent coverage I need

00:02:56,569 --> 00:03:00,949
to clarify you have you want to aim for

00:02:59,349 --> 00:03:03,349
eventually for one hundred percent

00:03:00,949 --> 00:03:05,989
coverage but you don't need to aim for

00:03:03,349 --> 00:03:09,139
it when you start testing because that's

00:03:05,989 --> 00:03:13,370
just an unnecessary goal it doesn't

00:03:09,139 --> 00:03:14,629
really help you learn and apply that so

00:03:13,370 --> 00:03:17,239
you have to start small you have to

00:03:14,629 --> 00:03:19,489
practice and then once you understand

00:03:17,239 --> 00:03:22,459
how how the tests work their interaction

00:03:19,489 --> 00:03:25,340
with the code and how to keep them lean

00:03:22,459 --> 00:03:26,930
and how to avoid going back and

00:03:25,340 --> 00:03:28,609
rewriting your tests because they no

00:03:26,930 --> 00:03:30,889
longer work with a new code so how to

00:03:28,609 --> 00:03:32,599
reduce the maintenance on that once you

00:03:30,889 --> 00:03:35,150
get all that you can start going on to

00:03:32,599 --> 00:03:37,970
the next stage and and gets all the way

00:03:35,150 --> 00:03:39,669
to TDD because you do have to acquire

00:03:37,970 --> 00:03:41,810
the skill and you do that by practicing

00:03:39,669 --> 00:03:44,239
so in case you still need some

00:03:41,810 --> 00:03:48,949
convincing what does it look like when

00:03:44,239 --> 00:03:51,229
you test without automation so when you

00:03:48,949 --> 00:03:53,810
do things manually what happens is you'd

00:03:51,229 --> 00:03:56,079
probably open your web browser you would

00:03:53,810 --> 00:03:58,519
click around maybe submit a form and

00:03:56,079 --> 00:03:59,930
then you check your database and you see

00:03:58,519 --> 00:04:02,659
where the things are faced correctly

00:03:59,930 --> 00:04:04,939
whether things got deleted you know and

00:04:02,659 --> 00:04:10,430
advertently maybe you output some

00:04:04,939 --> 00:04:12,650
variables with a var dump and also you

00:04:10,430 --> 00:04:14,840
don't always retest everything so once

00:04:12,650 --> 00:04:16,880
you've gone through all of that process

00:04:14,840 --> 00:04:18,620
once you finish building the feature you

00:04:16,880 --> 00:04:21,380
test that feature you don't necessarily

00:04:18,620 --> 00:04:23,120
go every time and retest the entire

00:04:21,380 --> 00:04:25,520
application once you complete the

00:04:23,120 --> 00:04:28,219
feature right you might do one last wee

00:04:25,520 --> 00:04:28,620
before a release but really what happens

00:04:28,219 --> 00:04:30,419
is that

00:04:28,620 --> 00:04:31,949
only test things once or twice and

00:04:30,419 --> 00:04:34,350
that's it because you cannot afford to

00:04:31,949 --> 00:04:35,940
retest everything every single time so

00:04:34,350 --> 00:04:37,530
you might have inadvertently affected

00:04:35,940 --> 00:04:39,060
something else in the application and

00:04:37,530 --> 00:04:46,290
you wouldn't know because you haven't

00:04:39,060 --> 00:04:48,300
tested for it so basically you end up

00:04:46,290 --> 00:04:50,100
releasing code when you deem it good

00:04:48,300 --> 00:04:54,660
enough and that is a very subjective

00:04:50,100 --> 00:04:57,690
metric so the problems with that it

00:04:54,660 --> 00:05:00,300
leads to last-minute bugs so you you are

00:04:57,690 --> 00:05:03,960
on the release knife and you you did

00:05:00,300 --> 00:05:05,220
that final sweep but you maybe not test

00:05:03,960 --> 00:05:07,560
with every everything you know you

00:05:05,220 --> 00:05:10,710
haven't tested certain scenarios and I

00:05:07,560 --> 00:05:12,660
have this bug and it's not too bad when

00:05:10,710 --> 00:05:14,610
you can still fix it before you release

00:05:12,660 --> 00:05:16,350
but often what will happen is you would

00:05:14,610 --> 00:05:20,370
release and then the customers will

00:05:16,350 --> 00:05:21,840
discover the bugs and when the customers

00:05:20,370 --> 00:05:23,280
discover the bugs it's a bit more

00:05:21,840 --> 00:05:27,300
embarrassing because you should have

00:05:23,280 --> 00:05:30,210
picked it up and when you fix when you

00:05:27,300 --> 00:05:31,800
go and fix about you apply patch because

00:05:30,210 --> 00:05:33,419
you're afraid to change things too much

00:05:31,800 --> 00:05:35,160
right because now that it's been

00:05:33,419 --> 00:05:35,970
stabilized all the bugs have been

00:05:35,160 --> 00:05:38,340
eliminated

00:05:35,970 --> 00:05:40,770
now either you need to add a little

00:05:38,340 --> 00:05:42,210
change to the code and you try to change

00:05:40,770 --> 00:05:43,590
as little code as possible because

00:05:42,210 --> 00:05:46,139
you're afraid to break everything it

00:05:43,590 --> 00:05:48,810
cannot go and refactor anything because

00:05:46,139 --> 00:05:51,210
the code controls you and not the other

00:05:48,810 --> 00:05:52,889
way around it's like you're walking on

00:05:51,210 --> 00:05:54,270
thin ice and you're afraid that if you

00:05:52,889 --> 00:05:56,310
move too much if you put too much

00:05:54,270 --> 00:05:57,270
pressure here all this is going to break

00:05:56,310 --> 00:05:59,039
and you're going to fall through and

00:05:57,270 --> 00:06:01,470
you're going to die that's how it feels

00:05:59,039 --> 00:06:03,690
when the code controls you so the unit

00:06:01,470 --> 00:06:08,639
test gives the control back to the

00:06:03,690 --> 00:06:10,530
developer so with automation decide you

00:06:08,639 --> 00:06:13,500
have control of the code and not the

00:06:10,530 --> 00:06:15,330
other way around and you can also solve

00:06:13,500 --> 00:06:17,310
some of the more obscure bugs or even

00:06:15,330 --> 00:06:19,590
discover bugs that you did not know that

00:06:17,310 --> 00:06:22,050
existed in the first place scenarios you

00:06:19,590 --> 00:06:24,690
never conceived but once you start unit

00:06:22,050 --> 00:06:26,699
testing you stumble upon the scenarios

00:06:24,690 --> 00:06:30,000
just through the methodology of the

00:06:26,699 --> 00:06:31,590
testing and so yeah you find bugs that

00:06:30,000 --> 00:06:33,419
you weren't even looking for and then

00:06:31,590 --> 00:06:35,520
you become more confident and you can go

00:06:33,419 --> 00:06:37,169
for refactoring larger chunks of code

00:06:35,520 --> 00:06:39,840
because you know that you have the

00:06:37,169 --> 00:06:41,669
safety net of the unit test so if you

00:06:39,840 --> 00:06:42,230
break something they're going to signal

00:06:41,669 --> 00:06:46,160
right

00:06:42,230 --> 00:06:47,540
that you have broken something and in

00:06:46,160 --> 00:06:50,030
the end what happens is you write more

00:06:47,540 --> 00:06:52,790
features you write fewer bugs and this

00:06:50,030 --> 00:06:55,100
is a lot more fun so unit tests already

00:06:52,790 --> 00:06:57,950
seem like a big pain in the beginning

00:06:55,100 --> 00:06:58,790
they do tend to make working a lot more

00:06:57,950 --> 00:07:00,920
fun later on

00:06:58,790 --> 00:07:06,350
so I'll show you all those steps I

00:07:00,920 --> 00:07:08,660
talked about basically so four-step

00:07:06,350 --> 00:07:10,910
process there are different

00:07:08,660 --> 00:07:14,000
opportunities that you will spot spot in

00:07:10,910 --> 00:07:16,850
your in your development where you can

00:07:14,000 --> 00:07:20,090
apply unit testing and just learn

00:07:16,850 --> 00:07:21,440
through those gradual steps so let me

00:07:20,090 --> 00:07:22,820
give you an example with a shopping cart

00:07:21,440 --> 00:07:25,280
let's say somebody goes into your

00:07:22,820 --> 00:07:27,650
shopping cart and they can enter any

00:07:25,280 --> 00:07:30,530
quantity which is free is just a text

00:07:27,650 --> 00:07:32,690
box and then suddenly enter 0.1 what

00:07:30,530 --> 00:07:36,170
will happen and I know because I did

00:07:32,690 --> 00:07:37,940
that mistake on and so I gave somebody a

00:07:36,170 --> 00:07:40,850
very big discount on a conference ticket

00:07:37,940 --> 00:07:42,620
so they only paid one tenth that was a

00:07:40,850 --> 00:07:46,250
fun bug I just covered it right away

00:07:42,620 --> 00:07:49,100
because they did not up so it's a it's a

00:07:46,250 --> 00:07:50,630
great way or I say great it's really a

00:07:49,100 --> 00:07:53,210
funny way to lose all your profit

00:07:50,630 --> 00:07:55,730
margins so the first opportunity to test

00:07:53,210 --> 00:07:57,650
is when you discover any of those bugs

00:07:55,730 --> 00:07:59,510
you encounter a bug and that's your

00:07:57,650 --> 00:08:02,510
first opportunity here's what you should

00:07:59,510 --> 00:08:04,130
do you go into your code and you find

00:08:02,510 --> 00:08:09,140
the exact location where the problem

00:08:04,130 --> 00:08:11,390
occurs and then you write a test case so

00:08:09,140 --> 00:08:13,730
I'll show you an example here's the test

00:08:11,390 --> 00:08:16,190
case you would write for example you

00:08:13,730 --> 00:08:19,730
start with a new cart item over watch 30

00:08:16,190 --> 00:08:22,010
pounds set the quantity to 0.1 so this

00:08:19,730 --> 00:08:24,710
is basically a step to reproduce the bug

00:08:22,010 --> 00:08:27,050
and then you assert that the quantity is

00:08:24,710 --> 00:08:30,500
equal 1 so this is the desired result

00:08:27,050 --> 00:08:33,349
you want it even if it's set to 0.1 you

00:08:30,500 --> 00:08:36,320
still wanted to translate to a quantity

00:08:33,349 --> 00:08:37,910
of 1 but the thing is as long as this

00:08:36,320 --> 00:08:41,180
bug is present you know that get

00:08:37,910 --> 00:08:42,890
quantity will return 0.1 so this test

00:08:41,180 --> 00:08:46,730
will fail basically you write the test

00:08:42,890 --> 00:08:48,980
you want to pass but it will necessarily

00:08:46,730 --> 00:08:51,080
fail at first because you haven't fixed

00:08:48,980 --> 00:08:52,850
the bug yet right so you write the test

00:08:51,080 --> 00:08:55,250
first you run it and you make sure it

00:08:52,850 --> 00:08:55,970
fails if it doesn't fail then it means

00:08:55,250 --> 00:08:57,709
that your test

00:08:55,970 --> 00:08:59,779
wrong because it's not proving the

00:08:57,709 --> 00:09:02,660
existence of the bug they have to go

00:08:59,779 --> 00:09:04,850
back and change the test but then you go

00:09:02,660 --> 00:09:07,519
ahead into the code and you make this

00:09:04,850 --> 00:09:10,310
change for example in set quantity what

00:09:07,519 --> 00:09:14,079
you do is you just route up to the next

00:09:10,310 --> 00:09:17,420
integer and that way if somebody enters

00:09:14,079 --> 00:09:20,689
zero then you get zero if they enter 0.1

00:09:17,420 --> 00:09:22,399
then you get one and so forth so you're

00:09:20,689 --> 00:09:24,139
going to fix that function and then you

00:09:22,399 --> 00:09:27,379
run the same test again so you fix the

00:09:24,139 --> 00:09:29,750
code the test phase rerun it now it

00:09:27,379 --> 00:09:33,019
should pass and it starts you know

00:09:29,750 --> 00:09:34,579
failing and then fail fix pass that

00:09:33,019 --> 00:09:37,430
sequence is what you're looking for

00:09:34,579 --> 00:09:39,379
that's how you write unit F that's how

00:09:37,430 --> 00:09:41,870
you guarantee the existence of the value

00:09:39,379 --> 00:09:43,339
prove the existence and then you go you

00:09:41,870 --> 00:09:44,810
fix it and then you prove that you have

00:09:43,339 --> 00:09:48,290
actually fixed it because now it's

00:09:44,810 --> 00:09:50,329
hassle so basically you are expressing

00:09:48,290 --> 00:09:53,930
the intents of your application through

00:09:50,329 --> 00:09:55,459
those tests so it does sound very simple

00:09:53,930 --> 00:09:57,259
like why would you test for something

00:09:55,459 --> 00:10:00,829
that you could have just you know var

00:09:57,259 --> 00:10:03,649
down to like in in a second well the

00:10:00,829 --> 00:10:06,410
thing about about those tests is that

00:10:03,649 --> 00:10:07,819
once you want to fix that set quantity

00:10:06,410 --> 00:10:09,790
you might break something else in the

00:10:07,819 --> 00:10:14,120
application and you would not know that

00:10:09,790 --> 00:10:16,639
so this this is a way to give you a sort

00:10:14,120 --> 00:10:21,050
of safety net so that you don't fall all

00:10:16,639 --> 00:10:24,709
the way down so yeah you want to prevent

00:10:21,050 --> 00:10:27,129
future breaks or inadvertent side

00:10:24,709 --> 00:10:30,170
effects on the rest of your code base

00:10:27,129 --> 00:10:32,059
future breaks means that if you are

00:10:30,170 --> 00:10:33,709
going to break that functionality in the

00:10:32,059 --> 00:10:35,870
future because you change that method

00:10:33,709 --> 00:10:37,610
then your test will start failing again

00:10:35,870 --> 00:10:39,290
and you'll know that oh I should not

00:10:37,610 --> 00:10:39,769
have changed that it was there for a

00:10:39,290 --> 00:10:42,559
reason

00:10:39,769 --> 00:10:44,089
and that's my other point is you don't

00:10:42,559 --> 00:10:46,879
always know why code is written a

00:10:44,089 --> 00:10:48,529
certain way so your comments are you

00:10:46,879 --> 00:10:50,540
stumble upon the code base and you have

00:10:48,529 --> 00:10:53,170
some weird condition somewhere maybe you

00:10:50,540 --> 00:10:57,019
know if order a B is greater than 12,000

00:10:53,170 --> 00:10:59,149
561 then use this SQL otherwise use that

00:10:57,019 --> 00:11:01,370
SQL which is kind of weird I find out in

00:10:59,149 --> 00:11:03,110
legacy code all the time and you don't

00:11:01,370 --> 00:11:06,170
know why it has been written this way it

00:11:03,110 --> 00:11:08,120
has a schema changed or as Li is the

00:11:06,170 --> 00:11:08,819
data now stored in the same schema but

00:11:08,120 --> 00:11:11,209
differently

00:11:08,819 --> 00:11:13,199
a what's up you don't know because

00:11:11,209 --> 00:11:15,899
there's no comments there's no

00:11:13,199 --> 00:11:18,359
documentation the it was like three

00:11:15,899 --> 00:11:19,559
developers ago right so you just come

00:11:18,359 --> 00:11:21,629
there and nobody knows why it's like

00:11:19,559 --> 00:11:24,720
that and when you write tests what

00:11:21,629 --> 00:11:26,069
happens it's a form of documentation so

00:11:24,720 --> 00:11:31,589
it tells you what the code is supposed

00:11:26,069 --> 00:11:35,519
to do and then you can then gain some

00:11:31,589 --> 00:11:39,209
insight into how right you have insight

00:11:35,519 --> 00:11:42,029
into why this code has been written that

00:11:39,209 --> 00:11:44,759
way so it's documentation for future

00:11:42,029 --> 00:11:47,249
developers but also for yourself in the

00:11:44,759 --> 00:11:49,139
future maybe one week from now you might

00:11:47,249 --> 00:11:51,499
not remember why you put certain

00:11:49,139 --> 00:11:54,059
condition in your code for example and

00:11:51,499 --> 00:11:55,829
and you can go back to your test and you

00:11:54,059 --> 00:11:58,319
can read them and you remember alright I

00:11:55,829 --> 00:11:59,999
was trying to prevent this bug so by

00:11:58,319 --> 00:12:02,039
reading the the previous code I showed

00:11:59,999 --> 00:12:05,189
you you would know that there was there

00:12:02,039 --> 00:12:08,459
used to be a bug with decimal with

00:12:05,189 --> 00:12:10,499
decimal quantities therefore this is why

00:12:08,459 --> 00:12:11,639
it rounds things up so that makes sense

00:12:10,499 --> 00:12:16,559
and you would leave it there you would

00:12:11,639 --> 00:12:18,419
not touch it and you might think okay

00:12:16,559 --> 00:12:20,549
well I can always just write a common

00:12:18,419 --> 00:12:22,619
block on top of of that thing

00:12:20,549 --> 00:12:25,169
on top of that method and explain why

00:12:22,619 --> 00:12:27,479
it's implemented that way but the thing

00:12:25,169 --> 00:12:29,399
is the effort for you to explain the bug

00:12:27,479 --> 00:12:31,859
in the comments and the effort of

00:12:29,399 --> 00:12:34,079
writing a test are about equivalent but

00:12:31,859 --> 00:12:36,029
the test is automated and offers a whole

00:12:34,079 --> 00:12:38,129
lot of other advantages so you might as

00:12:36,029 --> 00:12:41,579
well just skip the comments altogether

00:12:38,129 --> 00:12:44,220
write code that is readable and write

00:12:41,579 --> 00:12:46,169
tests that explain certain sort some of

00:12:44,220 --> 00:12:48,809
them more hidden things as to the why

00:12:46,169 --> 00:12:50,429
which is not always clearly expressed by

00:12:48,809 --> 00:12:52,319
the code even if it reads like English

00:12:50,429 --> 00:12:56,579
you know what it says but not why it

00:12:52,319 --> 00:12:58,739
says up they can do that might as well

00:12:56,579 --> 00:13:02,970
just you know write the write the test

00:12:58,739 --> 00:13:07,069
write the test and save yourself the

00:13:02,970 --> 00:13:09,839
effort of testing manually later as well

00:13:07,069 --> 00:13:11,579
and the thing is if anybody later breaks

00:13:09,839 --> 00:13:13,350
your stuff if you write a lot of these

00:13:11,579 --> 00:13:15,389
smaller tests if anybody breaks your

00:13:13,350 --> 00:13:16,949
stuff you'll know right away because you

00:13:15,389 --> 00:13:20,790
run the suite and then family it

00:13:16,949 --> 00:13:23,400
explodes and you realize oh I just

00:13:20,790 --> 00:13:26,010
I changed someone else's code that I

00:13:23,400 --> 00:13:28,740
didn't know it was supposed to prevent

00:13:26,010 --> 00:13:31,290
some bug so basically you get two for

00:13:28,740 --> 00:13:33,240
the price of one but we world we have

00:13:31,290 --> 00:13:35,340
here what we wrote is the regression

00:13:33,240 --> 00:13:38,640
test so regression testing is basically

00:13:35,340 --> 00:13:41,460
making sure that whatever you fix today

00:13:38,640 --> 00:13:43,110
does not break tomorrow so it's to

00:13:41,460 --> 00:13:45,510
prevent regressions basically so that

00:13:43,110 --> 00:13:46,830
you progress instead of regress it can

00:13:45,510 --> 00:13:48,900
only move forward you cannot move

00:13:46,830 --> 00:13:50,430
backwards because you have these steps

00:13:48,900 --> 00:13:53,970
that prevents you from from moving

00:13:50,430 --> 00:13:56,180
backwards that was the easiest way to

00:13:53,970 --> 00:14:00,060
write a test there's another opportunity

00:13:56,180 --> 00:14:01,620
when you are improving existing code so

00:14:00,060 --> 00:14:09,000
when you when you make changes for

00:14:01,620 --> 00:14:11,070
example we want to go example so we want

00:14:09,000 --> 00:14:14,130
to give for example free shipping for

00:14:11,070 --> 00:14:17,640
orders that are over 40 pounds so if you

00:14:14,130 --> 00:14:20,400
buy over 40 then you should get a zero

00:14:17,640 --> 00:14:23,490
shipping so what we do is we put two

00:14:20,400 --> 00:14:26,670
items that cost 30 so that will bring

00:14:23,490 --> 00:14:30,240
the total to 60 therefore higher than 40

00:14:26,670 --> 00:14:32,130
and you should receive free shipping but

00:14:30,240 --> 00:14:35,520
the code doesn't do that yet the code

00:14:32,130 --> 00:14:38,670
always has shipping fees so what happens

00:14:35,520 --> 00:14:40,860
here is that when you run the test it

00:14:38,670 --> 00:14:43,860
will fail then you go and you change the

00:14:40,860 --> 00:14:48,270
code you change the code by adding a

00:14:43,860 --> 00:14:50,250
condition where you say you know if

00:14:48,270 --> 00:14:53,640
shuttle is greater or equal than 40

00:14:50,250 --> 00:14:55,200
return zero otherwise return 15 and once

00:14:53,640 --> 00:14:57,660
you make that change instead of just

00:14:55,200 --> 00:15:01,200
returning 15 once you make that the test

00:14:57,660 --> 00:15:02,940
will pass but you have to test both

00:15:01,200 --> 00:15:05,490
cases because if you make a mistake

00:15:02,940 --> 00:15:07,380
somewhere and you inadvertently give

00:15:05,490 --> 00:15:07,890
free shipping to everyone that's not fun

00:15:07,380 --> 00:15:10,110
either

00:15:07,890 --> 00:15:11,910
so always think about so if you have a

00:15:10,110 --> 00:15:15,270
condition there you have to test both

00:15:11,910 --> 00:15:18,300
cases so the second case is same product

00:15:15,270 --> 00:15:23,610
but only one one quantity and you assert

00:15:18,300 --> 00:15:28,310
that you get 15 shipping so basically

00:15:23,610 --> 00:15:31,080
you now know how to write a test after

00:15:28,310 --> 00:15:33,450
the code is already written or you know

00:15:31,080 --> 00:15:34,050
while you're improving code but there's

00:15:33,450 --> 00:15:36,600
a

00:15:34,050 --> 00:15:38,309
there's also another possibility where

00:15:36,600 --> 00:15:39,629
you are writing completely new code so

00:15:38,309 --> 00:15:41,879
the get total let's say it's a

00:15:39,629 --> 00:15:46,019
completely new method you want to add

00:15:41,879 --> 00:15:49,559
some taxes on top so what you do is do

00:15:46,019 --> 00:15:51,299
what most developers do is they would go

00:15:49,559 --> 00:15:54,239
and they would write a few lines of code

00:15:51,299 --> 00:15:56,939
and then they will var down something

00:15:54,239 --> 00:15:59,279
that the the responsive app so for

00:15:56,939 --> 00:16:00,239
example you get you get the taxes and

00:15:59,279 --> 00:16:02,399
then you've are done that you actually

00:16:00,239 --> 00:16:04,739
have an array and it contains all the

00:16:02,399 --> 00:16:06,089
stuff you need and after that you go and

00:16:04,739 --> 00:16:08,009
you write the rest and then you've are

00:16:06,089 --> 00:16:11,129
dumped again and that's how a lot of

00:16:08,009 --> 00:16:13,709
developers code so here's what a var dot

00:16:11,129 --> 00:16:15,989
will look like so taxes so these are

00:16:13,709 --> 00:16:19,799
Quebec taxes you have two of them you

00:16:15,989 --> 00:16:24,049
have the GST which the federal tax and Q

00:16:19,799 --> 00:16:27,689
is Q which is the provincial guys and

00:16:24,049 --> 00:16:29,939
you just add those so I've are done this

00:16:27,689 --> 00:16:32,369
and I see my array with the name with

00:16:29,939 --> 00:16:34,889
the percentage and here's the thing

00:16:32,369 --> 00:16:37,410
about that the disadvantage to manually

00:16:34,889 --> 00:16:40,170
inspect your var dump is because you can

00:16:37,410 --> 00:16:43,949
make a mistake just by reading it so for

00:16:40,170 --> 00:16:46,110
example if it's Ted of 0.05 it says 0.5

00:16:43,949 --> 00:16:48,540
you might actually miss that when you

00:16:46,110 --> 00:16:50,639
read it because we're humans right we

00:16:48,540 --> 00:16:53,579
get this sort of blindness sometimes

00:16:50,639 --> 00:16:55,319
when we when we read numbers if you can

00:16:53,579 --> 00:16:57,600
make a mistake yourself and then you

00:16:55,319 --> 00:17:01,170
continue and your code doesn't work as

00:16:57,600 --> 00:17:02,879
expected what you think it does so you

00:17:01,170 --> 00:17:05,399
can really trust yourself that much and

00:17:02,879 --> 00:17:08,490
the other thing also is that you will

00:17:05,399 --> 00:17:09,449
inevitably erase that Werdum and you

00:17:08,490 --> 00:17:11,610
will never see it again

00:17:09,449 --> 00:17:13,679
and you would not know that you've

00:17:11,610 --> 00:17:15,779
broken something so if the messages that

00:17:13,679 --> 00:17:18,720
get applicable taxes methods changes and

00:17:15,779 --> 00:17:20,639
all starts returning something else you

00:17:18,720 --> 00:17:22,589
might not you might never know in the

00:17:20,639 --> 00:17:24,029
future and you will get a toll that is

00:17:22,589 --> 00:17:26,010
the same as the subtotal because you

00:17:24,029 --> 00:17:28,850
have zero taxes or maybe something just

00:17:26,010 --> 00:17:31,260
explodes and you wouldn't really know

00:17:28,850 --> 00:17:33,059
unless it exposed and then you have to

00:17:31,260 --> 00:17:34,320
go back but you have to you know var

00:17:33,059 --> 00:17:36,750
dump things again and you have to

00:17:34,320 --> 00:17:38,190
inspect everything manually once more so

00:17:36,750 --> 00:17:40,350
it's a lot of work it's a lot of back

00:17:38,190 --> 00:17:43,559
and forth and you want to have some sort

00:17:40,350 --> 00:17:45,659
of once you check that once you want to

00:17:43,559 --> 00:17:48,030
make sure that it stays that way doesn't

00:17:45,659 --> 00:17:51,480
change otherwise the rest

00:17:48,030 --> 00:17:54,060
your application gets impacted so what

00:17:51,480 --> 00:17:55,890
you do is when you write new code you

00:17:54,060 --> 00:17:57,840
can you can saturate the card you can

00:17:55,890 --> 00:18:00,330
get the applicable taxes and then you

00:17:57,840 --> 00:18:02,010
can check for that array so you check

00:18:00,330 --> 00:18:04,710
that it's actually an array that it has

00:18:02,010 --> 00:18:06,360
two elements you grab the first one and

00:18:04,710 --> 00:18:10,080
you make sure that it has a percent

00:18:06,360 --> 00:18:12,930
there and it's 0.05 right so this is

00:18:10,080 --> 00:18:16,410
this is your test that will pretty much

00:18:12,930 --> 00:18:18,450
inspect what you would do by I just by

00:18:16,410 --> 00:18:19,920
reading the var dump and writing this

00:18:18,450 --> 00:18:21,300
test is pretty straightforward I mean

00:18:19,920 --> 00:18:24,900
it's just a few lines of code it's very

00:18:21,300 --> 00:18:30,420
simple and what I'm trying to show you

00:18:24,900 --> 00:18:32,370
here is a an easy way to start creating

00:18:30,420 --> 00:18:35,760
a lot of tests if you want to start you

00:18:32,370 --> 00:18:38,820
know increasing the coverage is to spot

00:18:35,760 --> 00:18:40,980
those opportunities where you are doing

00:18:38,820 --> 00:18:43,200
a var dump every time you're tempted to

00:18:40,980 --> 00:18:44,430
write var down something think about how

00:18:43,200 --> 00:18:46,200
maybe I should write a test case for

00:18:44,430 --> 00:18:47,730
that because I'm testing for something

00:18:46,200 --> 00:18:49,980
right by doing the var dump I'm going to

00:18:47,730 --> 00:18:53,100
inspect the array so why not just write

00:18:49,980 --> 00:18:56,520
the test and then you prevent regression

00:18:53,100 --> 00:18:59,610
you get all of these advantages so it's

00:18:56,520 --> 00:19:02,490
a it's a very neat way to just go and

00:18:59,610 --> 00:19:05,640
start start writing more tests more

00:19:02,490 --> 00:19:07,080
quickly and it will make sure that you

00:19:05,640 --> 00:19:09,660
never fall too far so I always like to

00:19:07,080 --> 00:19:12,360
compare this to rock climbing what

00:19:09,660 --> 00:19:14,460
happens is you climb a bit then you put

00:19:12,360 --> 00:19:17,280
this anchor you get your rope through it

00:19:14,460 --> 00:19:20,370
and if you lose your grip a bit higher

00:19:17,280 --> 00:19:22,440
you only fall as far as the last anchor

00:19:20,370 --> 00:19:24,900
so the more frequently you put those

00:19:22,440 --> 00:19:26,490
anchors the the less far down you will

00:19:24,900 --> 00:19:30,470
fall so you will not lose all this

00:19:26,490 --> 00:19:33,600
progress and also not die but in case of

00:19:30,470 --> 00:19:35,940
unit test is a it's it's a bit less

00:19:33,600 --> 00:19:37,620
fatal but who knows you know people die

00:19:35,940 --> 00:19:39,630
when applications fail you know you

00:19:37,620 --> 00:19:41,160
dispatch two ambulances to the same

00:19:39,630 --> 00:19:43,020
location and you don't dispatch an

00:19:41,160 --> 00:19:44,970
ambulance there because somebody didn't

00:19:43,020 --> 00:19:47,970
write a unit test and yeah

00:19:44,970 --> 00:19:52,560
somebody died so I don't know if it

00:19:47,970 --> 00:19:55,260
makes you feel better or worse maybe I

00:19:52,560 --> 00:19:57,990
should avoid such a drastic example all

00:19:55,260 --> 00:20:00,960
right so so yeah this is just like rock

00:19:57,990 --> 00:20:01,929
climbing and you never fall too far and

00:20:00,960 --> 00:20:04,389
now you know how to

00:20:01,929 --> 00:20:06,340
tell after your code is written or while

00:20:04,389 --> 00:20:08,740
you're writing new code but what about

00:20:06,340 --> 00:20:09,879
writing tests before you write your code

00:20:08,740 --> 00:20:11,769
how does that work

00:20:09,879 --> 00:20:14,590
how can you test for something that's

00:20:11,769 --> 00:20:18,190
not even there well it's actually not

00:20:14,590 --> 00:20:19,720
that complicated so here's an example

00:20:18,190 --> 00:20:21,279
remember we're writing an e-commerce

00:20:19,720 --> 00:20:24,159
application right we have a shopping

00:20:21,279 --> 00:20:26,440
cart we have a catalog of products and

00:20:24,159 --> 00:20:28,720
those products may be arrived to you

00:20:26,440 --> 00:20:29,799
from a CSV file somebody's going to do

00:20:28,720 --> 00:20:31,779
an Excel spreadsheet

00:20:29,799 --> 00:20:33,549
they're going to export it to CSV send

00:20:31,779 --> 00:20:35,950
it to you and now you have to import it

00:20:33,549 --> 00:20:38,320
all right so you have to write this new

00:20:35,950 --> 00:20:42,070
tool to import it you probably need to

00:20:38,320 --> 00:20:43,769
just parse the data and store everything

00:20:42,070 --> 00:20:47,009
in the database maybe do some validation

00:20:43,769 --> 00:20:50,440
make sure that things are found in there

00:20:47,009 --> 00:20:52,629
and at that point you know what you want

00:20:50,440 --> 00:20:55,450
to do but you haven't defined decided

00:20:52,629 --> 00:20:57,909
upon the implementation details so the

00:20:55,450 --> 00:21:00,669
implementation details can be like they

00:20:57,909 --> 00:21:04,210
use an F open order user file get

00:21:00,669 --> 00:21:06,340
contents to grab the file from the file

00:21:04,210 --> 00:21:07,749
system you know maybe maybe it's not

00:21:06,340 --> 00:21:10,149
even coming from a file maybe it's

00:21:07,749 --> 00:21:11,679
coming from a database or something it

00:21:10,149 --> 00:21:13,990
doesn't really matter all you know is

00:21:11,679 --> 00:21:18,759
that is supposed to come from from

00:21:13,990 --> 00:21:20,470
somewhere and yeah so you don't have to

00:21:18,759 --> 00:21:22,419
make any decisions in the beginning

00:21:20,470 --> 00:21:24,220
because you can all postpone that until

00:21:22,419 --> 00:21:27,070
its limitation you only need to write

00:21:24,220 --> 00:21:29,200
the test first and then when you write

00:21:27,070 --> 00:21:31,869
the actual method that does these things

00:21:29,200 --> 00:21:34,779
then you can think about all those

00:21:31,869 --> 00:21:36,909
implementation details here's the kind

00:21:34,779 --> 00:21:39,129
of test you would write here's an

00:21:36,909 --> 00:21:42,730
example we create a new class called

00:21:39,129 --> 00:21:45,309
catalog imports and we parse something

00:21:42,730 --> 00:21:48,639
from teasley we check that we get an

00:21:45,309 --> 00:21:51,129
array back that we have two or two

00:21:48,639 --> 00:21:52,899
products that got from the CSV obviously

00:21:51,129 --> 00:21:55,360
the CSV would be made specifically for

00:21:52,899 --> 00:21:57,820
the test so that you don't constantly

00:21:55,360 --> 00:21:59,740
have to change your test make sure you

00:21:57,820 --> 00:22:01,869
always use fixed data specifically for

00:21:59,740 --> 00:22:03,909
the test and then ensure that it has a

00:22:01,869 --> 00:22:07,360
name it has a price you can also search

00:22:03,909 --> 00:22:09,460
for other things to do that at this

00:22:07,360 --> 00:22:11,619
point what do we know we know that we're

00:22:09,460 --> 00:22:13,990
getting an array out we know that we're

00:22:11,619 --> 00:22:14,980
supposed to have a file somewhere called

00:22:13,990 --> 00:22:17,350
catalog

00:22:14,980 --> 00:22:19,510
I would know exactly where it is or how

00:22:17,350 --> 00:22:21,130
we're reading it but you can already

00:22:19,510 --> 00:22:23,350
write the stuff because you know what

00:22:21,130 --> 00:22:25,660
what you're trying to do you you

00:22:23,350 --> 00:22:27,760
represent your expectations this is what

00:22:25,660 --> 00:22:30,040
you want your software to do if you want

00:22:27,760 --> 00:22:32,890
it to accept the string with a filename

00:22:30,040 --> 00:22:34,780
and you want to spit out on the Ray so

00:22:32,890 --> 00:22:35,890
we need to care about and now what

00:22:34,780 --> 00:22:38,530
you're going to do is you're going to

00:22:35,890 --> 00:22:41,980
write just enough code to make this test

00:22:38,530 --> 00:22:43,780
pass and what this test passes you have

00:22:41,980 --> 00:22:44,260
finished writing the feature you wanted

00:22:43,780 --> 00:22:50,410
to write

00:22:44,260 --> 00:22:52,299
that's it that's it so it's a it's a new

00:22:50,410 --> 00:22:55,780
mindset that will make you write less

00:22:52,299 --> 00:22:58,000
code because let me just go back to the

00:22:55,780 --> 00:23:00,580
test maybe and explain so this at this

00:22:58,000 --> 00:23:03,040
point there is no class the class

00:23:00,580 --> 00:23:05,380
catalog import does not exist the method

00:23:03,040 --> 00:23:06,820
parts from CSV does not exist you have

00:23:05,380 --> 00:23:09,280
to go and create it so you write this

00:23:06,820 --> 00:23:11,380
test you run it it fails obviously none

00:23:09,280 --> 00:23:13,179
of it this exists and then you start

00:23:11,380 --> 00:23:15,790
creating the class you start adding the

00:23:13,179 --> 00:23:17,679
the method and you know you would know

00:23:15,790 --> 00:23:19,030
that the method will take one arguments

00:23:17,679 --> 00:23:20,740
and you know that it will return an

00:23:19,030 --> 00:23:23,320
array and you just make some of those

00:23:20,740 --> 00:23:26,080
implementation decisions inside it will

00:23:23,320 --> 00:23:28,390
probably be five lines of code okay

00:23:26,080 --> 00:23:30,240
you're you're in the end your code will

00:23:28,390 --> 00:23:32,980
probably be shorter than your test

00:23:30,240 --> 00:23:36,580
because the test they kind of force you

00:23:32,980 --> 00:23:39,900
into writing just a minimum necessary to

00:23:36,580 --> 00:23:41,980
make those tests pass it's very useful

00:23:39,900 --> 00:23:44,500
so you would write write less code

00:23:41,980 --> 00:23:47,260
because the instructions are so clear as

00:23:44,500 --> 00:23:49,090
to what you need to do you just read the

00:23:47,260 --> 00:23:51,190
file extract the names and prices for

00:23:49,090 --> 00:23:53,650
each and return it and that's it that's

00:23:51,190 --> 00:23:55,750
always supposed to do it helps you

00:23:53,650 --> 00:23:57,280
really stay focused on what the

00:23:55,750 --> 00:24:01,090
objective is the objective is to make

00:23:57,280 --> 00:24:03,520
the test pass and because your focus you

00:24:01,090 --> 00:24:05,169
don't start writing more methods to do

00:24:03,520 --> 00:24:09,850
like a whole bunch of stuff it's not

00:24:05,169 --> 00:24:12,370
necessary and no not only will you write

00:24:09,850 --> 00:24:14,350
less code but also you end up writing

00:24:12,370 --> 00:24:16,360
more elegant code it's going to be clean

00:24:14,350 --> 00:24:17,590
because it's going because you're so

00:24:16,360 --> 00:24:19,840
focused it's going to be straightforward

00:24:17,590 --> 00:24:24,549
and the code is going to be very

00:24:19,840 --> 00:24:26,770
readable and as a bonus it's going to be

00:24:24,549 --> 00:24:28,480
working right away because once the test

00:24:26,770 --> 00:24:30,040
asks well you don't

00:24:28,480 --> 00:24:32,169
have a bug right I mean you can think

00:24:30,040 --> 00:24:34,360
about the scenarios later on but at

00:24:32,169 --> 00:24:36,610
least you know that this code is passing

00:24:34,360 --> 00:24:46,210
so you don't have to spend so much time

00:24:36,610 --> 00:24:49,780
debugging it later right some things to

00:24:46,210 --> 00:24:52,750
consider it's not just you're not

00:24:49,780 --> 00:24:54,880
supposed to just test how it's supposed

00:24:52,750 --> 00:24:57,220
to work but also make sure you set how

00:24:54,880 --> 00:25:02,620
it's not supposed to work so think about

00:24:57,220 --> 00:25:04,330
all the exceptions so let's say if they

00:25:02,620 --> 00:25:08,140
have a shopping cart that stores data in

00:25:04,330 --> 00:25:12,309
a session okay people come in they they

00:25:08,140 --> 00:25:14,290
go and they they add an item and then it

00:25:12,309 --> 00:25:16,809
goes into the session the quantity you

00:25:14,290 --> 00:25:19,210
then calculate from that session you can

00:25:16,809 --> 00:25:21,850
calculate the total and display it to

00:25:19,210 --> 00:25:26,650
the user but what happens is at that

00:25:21,850 --> 00:25:28,360
time price changes the price of the item

00:25:26,650 --> 00:25:30,160
has changed so it's no longer sold at

00:25:28,360 --> 00:25:32,919
the price that was before the checkout

00:25:30,160 --> 00:25:35,140
but if it's already in the session what

00:25:32,919 --> 00:25:36,940
will happen will you just stealthily

00:25:35,140 --> 00:25:39,190
charge the person the new price which

00:25:36,940 --> 00:25:41,650
might be higher and risk losing your

00:25:39,190 --> 00:25:44,200
customer in the future because if it's

00:25:41,650 --> 00:25:45,370
30 and then suddenly it's 40 you can

00:25:44,200 --> 00:25:47,530
just check out so you have to think

00:25:45,370 --> 00:25:50,140
about the scenarios so these are you

00:25:47,530 --> 00:25:52,330
know plans for all these exceptions then

00:25:50,140 --> 00:25:55,600
you would or you could for example say

00:25:52,330 --> 00:25:57,100
you know we can no longer we can no

00:25:55,600 --> 00:25:58,960
longer process this check out because

00:25:57,100 --> 00:26:01,150
the price has changed maybe you would

00:25:58,960 --> 00:26:03,370
have a process where you say do you

00:26:01,150 --> 00:26:05,850
accept this new price is that does that

00:26:03,370 --> 00:26:09,580
work for you which is what most of

00:26:05,850 --> 00:26:11,470
online what's online travel agencies

00:26:09,580 --> 00:26:14,169
they don't do if the price has changed

00:26:11,470 --> 00:26:16,690
you have to redo the search but I mean I

00:26:14,169 --> 00:26:18,669
still want the same flight I don't care

00:26:16,690 --> 00:26:21,309
ok the price increased 100 dollars I

00:26:18,669 --> 00:26:22,510
still want that flight but now they make

00:26:21,309 --> 00:26:24,220
you refresh everything so it's a

00:26:22,510 --> 00:26:26,020
decision it's a business decision you

00:26:24,220 --> 00:26:27,850
can make but at least you should plan

00:26:26,020 --> 00:26:29,980
for those things and not allow people to

00:26:27,850 --> 00:26:32,200
check out if something becomes

00:26:29,980 --> 00:26:32,980
unavailable suddenly because that will

00:26:32,200 --> 00:26:35,169
make no sense

00:26:32,980 --> 00:26:37,240
so let's say you deactivate the product

00:26:35,169 --> 00:26:39,370
so now it's you know in the database it

00:26:37,240 --> 00:26:40,929
says is active equals zero therefore

00:26:39,370 --> 00:26:42,250
you're not supposed to be able to check

00:26:40,929 --> 00:26:44,980
out anything that is

00:26:42,250 --> 00:26:47,440
available or maybe it's out of stock or

00:26:44,980 --> 00:26:48,640
any other exceptions you can think of so

00:26:47,440 --> 00:26:50,560
you can write tests for all these things

00:26:48,640 --> 00:26:54,510
and prevent those scenarios from

00:26:50,560 --> 00:26:54,510
occurring you have to plan ahead of it

00:26:57,210 --> 00:27:02,710
but at the same time you have to you

00:27:01,510 --> 00:27:05,130
don't want to spend too much time

00:27:02,710 --> 00:27:09,010
thinking about what could happen because

00:27:05,130 --> 00:27:11,110
some scenarios are not realistic and you

00:27:09,010 --> 00:27:12,610
have to use your your judgment to see

00:27:11,110 --> 00:27:14,800
what is realistic and what is not

00:27:12,610 --> 00:27:16,600
because you can even spend all your life

00:27:14,800 --> 00:27:17,980
writing these stuffs and still not

00:27:16,600 --> 00:27:21,280
finish still not account for every

00:27:17,980 --> 00:27:23,890
single thing so I'm a pragmatic person

00:27:21,280 --> 00:27:26,380
and what I do is for example I would

00:27:23,890 --> 00:27:28,510
expect a database to become unavailable

00:27:26,380 --> 00:27:30,970
I would expect prices to change things

00:27:28,510 --> 00:27:33,160
like that but I do not expect setting

00:27:30,970 --> 00:27:35,590
the total variable here and the next

00:27:33,160 --> 00:27:37,900
line it's no longer it's no longer

00:27:35,590 --> 00:27:38,800
available I mean that this does not and

00:27:37,900 --> 00:27:40,570
of course it's the simplest thing

00:27:38,800 --> 00:27:43,390
example just for illustration purposes

00:27:40,570 --> 00:27:46,000
but certain scenarios are just not

00:27:43,390 --> 00:27:48,190
really going to happen or very unlikely

00:27:46,000 --> 00:27:50,170
to happen unless is I mean there's

00:27:48,190 --> 00:27:53,050
obviously a reason for this to become

00:27:50,170 --> 00:27:55,750
unassigned yeah like as some RAM failure

00:27:53,050 --> 00:27:57,940
on your on your server I mean these

00:27:55,750 --> 00:27:58,990
things can still happen but highly

00:27:57,940 --> 00:28:00,700
unlikely you're not

00:27:58,990 --> 00:28:03,700
you shouldn't have to test for all these

00:28:00,700 --> 00:28:06,490
things so yeah use your judgment see

00:28:03,700 --> 00:28:09,100
what's likely what's not also certain

00:28:06,490 --> 00:28:11,020
certain projects or like I work with

00:28:09,100 --> 00:28:13,330
clients certain clients they can stomach

00:28:11,020 --> 00:28:14,590
a lot more risk so certain things I

00:28:13,330 --> 00:28:16,780
don't need to worry about because they

00:28:14,590 --> 00:28:19,120
say well I mean if this fails it's not

00:28:16,780 --> 00:28:20,650
really a problem anyway because I can

00:28:19,120 --> 00:28:22,510
just go and manually do that it takes me

00:28:20,650 --> 00:28:25,210
five seconds and I really don't mind and

00:28:22,510 --> 00:28:27,130
that can save me a whole lot of trouble

00:28:25,210 --> 00:28:30,610
because sometimes setting up certain

00:28:27,130 --> 00:28:33,220
types of tests can be can be tedious so

00:28:30,610 --> 00:28:35,640
yeah see see what's the the risk level

00:28:33,220 --> 00:28:39,190
that's acceptable and just go from there

00:28:35,640 --> 00:28:42,540
also I would say one of the things that

00:28:39,190 --> 00:28:45,550
you shouldn't test is when say we have a

00:28:42,540 --> 00:28:47,260
getter like I get shipping if it just

00:28:45,550 --> 00:28:49,540
returns like there's no condition with

00:28:47,260 --> 00:28:53,200
it sir there's no conditions there it

00:28:49,540 --> 00:28:53,850
just returns the the property of the of

00:28:53,200 --> 00:28:56,400
the

00:28:53,850 --> 00:28:58,320
Jeff then you probably don't need to

00:28:56,400 --> 00:29:00,210
write a test for that because it's just

00:28:58,320 --> 00:29:00,900
nothing can go wrong and there it's so

00:29:00,210 --> 00:29:03,630
straightforward

00:29:00,900 --> 00:29:07,559
that's another unrealistic thing to test

00:29:03,630 --> 00:29:09,330
in my opinion so now you think okay so

00:29:07,559 --> 00:29:12,510
how many test cases should I write

00:29:09,330 --> 00:29:15,120
should I write more or less for each

00:29:12,510 --> 00:29:18,890
method and it's actually there's a

00:29:15,120 --> 00:29:18,890
scientific method to that which is cool

00:29:20,120 --> 00:29:26,280
you just for fun raise your hand if you

00:29:22,679 --> 00:29:28,350
get that reference all right

00:29:26,280 --> 00:29:31,700
so more people give this reference than

00:29:28,350 --> 00:29:35,010
people who stress before release awesome

00:29:31,700 --> 00:29:37,830
or maybe people are just digesting lunch

00:29:35,010 --> 00:29:40,650
and not paying attention enough so

00:29:37,830 --> 00:29:44,460
cyclomatic complexity is an interesting

00:29:40,650 --> 00:29:47,640
measurement it basically says basically

00:29:44,460 --> 00:29:50,159
means how many paths in your code take

00:29:47,640 --> 00:29:53,159
when it executes so how many execution

00:29:50,159 --> 00:29:55,350
paths do you have that's what it means

00:29:53,159 --> 00:29:56,520
and you can calculate it you can just

00:29:55,350 --> 00:29:59,490
eyeball it or you can use the

00:29:56,520 --> 00:30:02,159
calculation so here we have two

00:29:59,490 --> 00:30:05,159
execution paths so here's how it will

00:30:02,159 --> 00:30:08,039
execute if the subtotal is greater than

00:30:05,159 --> 00:30:10,530
or equal to 40 what happens is you will

00:30:08,039 --> 00:30:13,190
execute the line that returns zero but

00:30:10,530 --> 00:30:17,460
you will not execute the last line and

00:30:13,190 --> 00:30:19,950
vice-versa if is less than 40 then you

00:30:17,460 --> 00:30:21,690
would skip though the the body of the of

00:30:19,950 --> 00:30:23,309
the condition there you would not

00:30:21,690 --> 00:30:25,830
execute that line and you would execute

00:30:23,309 --> 00:30:27,659
the last one instead obviously here is

00:30:25,830 --> 00:30:29,909
also simple example just for

00:30:27,659 --> 00:30:31,590
illustration purposes but if you have

00:30:29,909 --> 00:30:35,960
multiple lines of code there you might

00:30:31,590 --> 00:30:40,470
want to test both of these possibilities

00:30:35,960 --> 00:30:43,710
so this is useful because if you test

00:30:40,470 --> 00:30:45,750
with let's say just a 100 pound subtotal

00:30:43,710 --> 00:30:47,669
then you're not testing the last line

00:30:45,750 --> 00:30:49,950
and if there's above there you

00:30:47,669 --> 00:30:53,460
accidentally give free shipping to

00:30:49,950 --> 00:30:54,960
everyone if if you don't f it up or the

00:30:53,460 --> 00:30:58,490
shipping is more expensive or whatever

00:30:54,960 --> 00:31:01,830
the problem in the rest of the code is

00:30:58,490 --> 00:31:05,179
so you will know unless you test both

00:31:01,830 --> 00:31:07,020
half and the way you do that is by

00:31:05,179 --> 00:31:09,750
calculating how many decisions

00:31:07,020 --> 00:31:14,280
branches you have in writing tough test

00:31:09,750 --> 00:31:19,170
cases for each one so decision branches

00:31:14,280 --> 00:31:21,480
are execution valve so one basically

00:31:19,170 --> 00:31:23,550
when you see the if you branch into that

00:31:21,480 --> 00:31:25,200
you make a decision in you branch into

00:31:23,550 --> 00:31:26,990
that chunk of code otherwise you

00:31:25,200 --> 00:31:30,450
branches in the other chunk of code and

00:31:26,990 --> 00:31:32,850
that's how cold slows conditions are

00:31:30,450 --> 00:31:34,920
obviously decision branches but loops

00:31:32,850 --> 00:31:38,010
are also decision branches because the

00:31:34,920 --> 00:31:39,600
loop has an implicit if statement in

00:31:38,010 --> 00:31:43,040
there because you need to know whether

00:31:39,600 --> 00:31:46,130
you are executing the body or not right

00:31:43,040 --> 00:31:49,530
or whether you loop again basically and

00:31:46,130 --> 00:31:51,690
it's important because based on whether

00:31:49,530 --> 00:31:55,100
the loops body has been executed or not

00:31:51,690 --> 00:31:58,500
it can affect the code that follows it

00:31:55,100 --> 00:32:02,010
so I usually add two tests for every

00:31:58,500 --> 00:32:03,990
loop one for executing zero times and

00:32:02,010 --> 00:32:06,470
another one for executing multiple times

00:32:03,990 --> 00:32:09,510
and I'll explain why with this example

00:32:06,470 --> 00:32:11,520
so in this example we iterate over the

00:32:09,510 --> 00:32:14,160
products you know we add the total and

00:32:11,520 --> 00:32:17,010
then we do something with at all if we

00:32:14,160 --> 00:32:19,710
do not see we haven't initialized the

00:32:17,010 --> 00:32:21,990
total so that can cause problems later

00:32:19,710 --> 00:32:24,840
on the total will not exist so if we

00:32:21,990 --> 00:32:26,670
have zero products all of that will be

00:32:24,840 --> 00:32:29,190
skipped the body of the loop will be

00:32:26,670 --> 00:32:31,680
skipped and you would get to the to the

00:32:29,190 --> 00:32:35,070
other line and total is undefined and

00:32:31,680 --> 00:32:38,430
you'll get an error hopefully an error

00:32:35,070 --> 00:32:42,750
and not just a notice right so so you do

00:32:38,430 --> 00:32:45,090
that and you are basically opening

00:32:42,750 --> 00:32:46,770
yourself to the possibility of if

00:32:45,090 --> 00:32:50,100
there's no products you know to break

00:32:46,770 --> 00:32:52,170
your execution so you will need to write

00:32:50,100 --> 00:32:54,930
a test for having zero products to make

00:32:52,170 --> 00:32:57,930
sure to catch this bug and to fix that

00:32:54,930 --> 00:33:00,330
what you'll do is you'll just initialize

00:32:57,930 --> 00:33:02,880
the tool at the top right okay so now

00:33:00,330 --> 00:33:05,820
you wrote a test case and you fix the

00:33:02,880 --> 00:33:09,570
bug the underlying bug and here's the

00:33:05,820 --> 00:33:12,090
same if you execute if you execute this

00:33:09,570 --> 00:33:14,070
zero times it works if you execute it

00:33:12,090 --> 00:33:15,780
one time it works but multiple times

00:33:14,070 --> 00:33:18,980
you're not going to get what you expect

00:33:15,780 --> 00:33:25,549
because for those who might have noticed

00:33:18,980 --> 00:33:29,210
my second point here says equal plus

00:33:25,549 --> 00:33:31,340
equal so if you add v2 zero times it

00:33:29,210 --> 00:33:33,559
works one time it's fine because you

00:33:31,340 --> 00:33:36,019
assign and you get the right amount in

00:33:33,559 --> 00:33:38,269
there and you test for it great but in

00:33:36,019 --> 00:33:41,419
you click it twice it overrides and now

00:33:38,269 --> 00:33:44,659
you don't have the right amount and your

00:33:41,419 --> 00:33:47,720
code is not executing properly so now

00:33:44,659 --> 00:33:50,899
you have a bug so to be safe I recommend

00:33:47,720 --> 00:33:52,159
always to test for zero products so set

00:33:50,899 --> 00:33:53,990
up a test case where you have zero

00:33:52,159 --> 00:33:56,210
products and set up another test case

00:33:53,990 --> 00:33:57,919
where you have maybe two products just

00:33:56,210 --> 00:33:59,840
to be on the safe side you have to worry

00:33:57,919 --> 00:34:01,970
about the different permutations just

00:33:59,840 --> 00:34:04,340
just zero in two and you should be fine

00:34:01,970 --> 00:34:06,649
because if you only execute one that

00:34:04,340 --> 00:34:09,200
serves no purpose and running a test for

00:34:06,649 --> 00:34:13,099
zero one and two also is redundant

00:34:09,200 --> 00:34:15,740
because it the the thing about the the

00:34:13,099 --> 00:34:17,810
test has two products already covers all

00:34:15,740 --> 00:34:21,849
the things that can go wrong with just

00:34:17,810 --> 00:34:24,169
one product so we have zero or multiple

00:34:21,849 --> 00:34:25,970
another type of stuff that I really like

00:34:24,169 --> 00:34:28,790
to write and this is not a unit test

00:34:25,970 --> 00:34:34,550
anymore but I still use PHP units for

00:34:28,790 --> 00:34:36,079
that it's quite useful and I always get

00:34:34,550 --> 00:34:39,500
questions about that at the end so I

00:34:36,079 --> 00:34:42,950
made this into a slide what I do is when

00:34:39,500 --> 00:34:45,560
I write api's I would use something like

00:34:42,950 --> 00:34:49,220
ghazal which is just a wrapper for curl

00:34:45,560 --> 00:34:51,409
I use guzzle to make HTTP requests to my

00:34:49,220 --> 00:34:54,919
API so I would call an endpoint maybe

00:34:51,409 --> 00:34:56,899
pass them some headers I will call that

00:34:54,919 --> 00:34:59,480
and then I will grab the output of that

00:34:56,899 --> 00:35:01,520
the response from that and I will do a

00:34:59,480 --> 00:35:04,369
Serge's on string equals station on

00:35:01,520 --> 00:35:07,400
strain and I compare it to what I'm

00:35:04,369 --> 00:35:09,980
expecting of that API and the reason I

00:35:07,400 --> 00:35:13,190
use a JSON string equals JSON string

00:35:09,980 --> 00:35:14,869
instead of just equals is because this

00:35:13,190 --> 00:35:16,190
one would show you exactly where the

00:35:14,869 --> 00:35:17,930
problem is it's going to say oh I

00:35:16,190 --> 00:35:20,359
expected an array here you gave me an

00:35:17,930 --> 00:35:21,859
object or this thing is missing it's

00:35:20,359 --> 00:35:23,810
going to show you like a diff pretty

00:35:21,859 --> 00:35:25,670
much of what you're supposed to have

00:35:23,810 --> 00:35:28,400
we're equals it's going to it's just

00:35:25,670 --> 00:35:29,900
going to say not equals sorry that can

00:35:28,400 --> 00:35:31,310
be a problem with those large strings

00:35:29,900 --> 00:35:31,710
because then you have to go and hunt for

00:35:31,310 --> 00:35:33,930
the

00:35:31,710 --> 00:35:37,080
for instance very tedious and the other

00:35:33,930 --> 00:35:40,589
thing also because because it parses the

00:35:37,080 --> 00:35:42,150
the JSON internally your spacing doesn't

00:35:40,589 --> 00:35:44,849
matter in the test so it doesn't have to

00:35:42,150 --> 00:35:46,530
be the exact same spacing you can you

00:35:44,849 --> 00:35:48,119
can expand this as much as you want even

00:35:46,530 --> 00:35:50,280
if the API returns something that's very

00:35:48,119 --> 00:35:53,160
compressed so you don't have to worry

00:35:50,280 --> 00:35:56,070
about you know tabbing and all that it's

00:35:53,160 --> 00:35:57,300
doing that for you so it's very happy so

00:35:56,070 --> 00:35:59,820
I would use guzzle I would call that

00:35:57,300 --> 00:36:02,220
grab and compare the the response and

00:35:59,820 --> 00:36:05,580
the cool the really cool thing about

00:36:02,220 --> 00:36:08,130
that is it's a it establishes a contract

00:36:05,580 --> 00:36:09,810
between the API and whoever's consuming

00:36:08,130 --> 00:36:12,300
the API so I use that on certain

00:36:09,810 --> 00:36:15,650
projects where I would have say an

00:36:12,300 --> 00:36:20,070
angular developer writing the front end

00:36:15,650 --> 00:36:23,430
or just JavaScript and I was writing the

00:36:20,070 --> 00:36:26,400
backend so we would agree upon endpoints

00:36:23,430 --> 00:36:29,099
and upon the format of the data that is

00:36:26,400 --> 00:36:30,690
output by the API we would make this

00:36:29,099 --> 00:36:33,810
agreement we would basically write this

00:36:30,690 --> 00:36:36,060
if this string out would ride those

00:36:33,810 --> 00:36:38,520
tests together and that serves as the

00:36:36,060 --> 00:36:41,520
contract between the backhands and the

00:36:38,520 --> 00:36:43,890
API and the consumer of the API so I can

00:36:41,520 --> 00:36:46,619
start working on making those tests pass

00:36:43,890 --> 00:36:49,050
right because this is TDD I wrote this

00:36:46,619 --> 00:36:51,869
first and I start writing my micro I

00:36:49,050 --> 00:36:54,359
write my endpoints all of that I return

00:36:51,869 --> 00:36:57,210
the proper string and when it returns

00:36:54,359 --> 00:36:59,720
the right string then I know that I

00:36:57,210 --> 00:37:02,400
finished my work because I've achieved

00:36:59,720 --> 00:37:04,800
she achieved this objective to make my

00:37:02,400 --> 00:37:06,660
tests pass now for the father developer

00:37:04,800 --> 00:37:08,339
is really cool the front end the

00:37:06,660 --> 00:37:10,440
developer doesn't have to wait for me to

00:37:08,339 --> 00:37:11,910
finish writing the API because they

00:37:10,440 --> 00:37:14,730
already know what they should expect

00:37:11,910 --> 00:37:16,800
from which endpoint and what the those

00:37:14,730 --> 00:37:19,230
developers usually do they would go and

00:37:16,800 --> 00:37:21,630
grab that string save that into a file

00:37:19,230 --> 00:37:23,369
and you can even create a file instead

00:37:21,630 --> 00:37:26,490
and read a file rather than writing the

00:37:23,369 --> 00:37:28,650
the thing else the JSON Al's right now

00:37:26,490 --> 00:37:31,080
and they can point to those JSON files

00:37:28,650 --> 00:37:33,540
and they grab those the static JSON

00:37:31,080 --> 00:37:37,589
files and you can start building their

00:37:33,540 --> 00:37:41,130
interfaces on top of that and once once

00:37:37,589 --> 00:37:43,589
they're done and I'm done they instead

00:37:41,130 --> 00:37:45,110
of pointing to that side file they point

00:37:43,589 --> 00:37:47,240
to the proper endpoint

00:37:45,110 --> 00:37:49,040
and it just works and I know it works

00:37:47,240 --> 00:37:51,440
because the tests are there they're

00:37:49,040 --> 00:37:54,770
using the exact same string to build on

00:37:51,440 --> 00:37:57,290
that and I'm making it output the exact

00:37:54,770 --> 00:37:59,690
same string so the the match is

00:37:57,290 --> 00:38:03,260
immediate there's no time there's no

00:37:59,690 --> 00:38:07,940
time necessary to put all the pieces

00:38:03,260 --> 00:38:12,620
together which is pretty nice so a quick

00:38:07,940 --> 00:38:15,140
recap of what I said testing takes some

00:38:12,620 --> 00:38:16,880
practice so don't expect to be an expert

00:38:15,140 --> 00:38:18,740
overnight as I said don't not

00:38:16,880 --> 00:38:20,510
necessarily aim at the beginning for the

00:38:18,740 --> 00:38:22,850
hundred percent coverage don't worry

00:38:20,510 --> 00:38:24,320
about TDD start with something small

00:38:22,850 --> 00:38:27,230
start with something that makes sense to

00:38:24,320 --> 00:38:29,780
you right now and what will happen is as

00:38:27,230 --> 00:38:31,880
you ease into this whole unit testing

00:38:29,780 --> 00:38:34,520
business it will start to understand how

00:38:31,880 --> 00:38:36,380
it works and because quite abstract then

00:38:34,520 --> 00:38:38,360
it will this idea will grow in your mind

00:38:36,380 --> 00:38:39,890
and you will become comfortable with it

00:38:38,360 --> 00:38:41,780
and then you can cycle the second and

00:38:39,890 --> 00:38:43,940
the third and the fourth step and then

00:38:41,780 --> 00:38:45,710
CDD will become natural to you but if

00:38:43,940 --> 00:38:47,540
you go straight to TDD and you skip all

00:38:45,710 --> 00:38:48,830
of that it's like you want to play the

00:38:47,540 --> 00:38:50,960
valley and you don't even know how to

00:38:48,830 --> 00:38:53,420
play twinkle twinkle little star on the

00:38:50,960 --> 00:38:56,720
violin you cannot just go and skip all

00:38:53,420 --> 00:38:59,740
of this process and that's I find it sad

00:38:56,720 --> 00:39:03,680
that not too many people teach that and

00:38:59,740 --> 00:39:05,780
also so the four the four steps you can

00:39:03,680 --> 00:39:08,840
take is right test when you see a bob

00:39:05,780 --> 00:39:11,360
first and then you write test when you

00:39:08,840 --> 00:39:13,310
improve your code like what we did was

00:39:11,360 --> 00:39:16,550
added the shipping you know free

00:39:13,310 --> 00:39:19,460
shipping then you can test as you write

00:39:16,550 --> 00:39:21,950
new code so when we did the whole taxes

00:39:19,460 --> 00:39:24,080
thing then you can write tests before

00:39:21,950 --> 00:39:25,070
you code and there's many ways you can

00:39:24,080 --> 00:39:29,170
do that

00:39:25,070 --> 00:39:33,020
the thing about the API but also the

00:39:29,170 --> 00:39:34,700
parsing the CSV file and always always

00:39:33,020 --> 00:39:37,100
remember that you have to test those

00:39:34,700 --> 00:39:39,080
unexpected scenarios so use use

00:39:37,100 --> 00:39:43,490
cyclomatic complexity to make sure that

00:39:39,080 --> 00:39:45,520
you write tests for all the for all the

00:39:43,490 --> 00:39:48,530
branches that you have in your code and

00:39:45,520 --> 00:39:51,080
this way you will you will ensure that

00:39:48,530 --> 00:39:53,600
all of your tests is all your code is

00:39:51,080 --> 00:39:56,120
covered every single line basically that

00:39:53,600 --> 00:39:58,720
can execute has been executed through

00:39:56,120 --> 00:39:58,720
the unit tests

00:39:59,530 --> 00:40:08,500
so one before we finish this I would

00:40:06,640 --> 00:40:10,300
like you to see testing as pre-emptive

00:40:08,500 --> 00:40:12,790
debugging and that is the reason why

00:40:10,300 --> 00:40:14,500
it's so hard to sell tests because it's

00:40:12,790 --> 00:40:15,670
great I mean you you learn all of this

00:40:14,500 --> 00:40:18,030
you're going to you're going to go to

00:40:15,670 --> 00:40:21,100
the office and you will try to convince

00:40:18,030 --> 00:40:23,890
your boss to allow you to write unit

00:40:21,100 --> 00:40:25,870
tests but you shouldn't because that is

00:40:23,890 --> 00:40:28,000
none of their business you don't have to

00:40:25,870 --> 00:40:29,710
convince anyone because testing is

00:40:28,000 --> 00:40:31,960
preemptive debugging it is not something

00:40:29,710 --> 00:40:35,560
that is suffered from the code can you

00:40:31,960 --> 00:40:37,450
can you go and write code and say well

00:40:35,560 --> 00:40:38,830
I'm going to charge you that much to

00:40:37,450 --> 00:40:40,300
write the code but if you want me to

00:40:38,830 --> 00:40:42,280
spend time debugging it

00:40:40,300 --> 00:40:45,280
that's extra I mean nobody does that

00:40:42,280 --> 00:40:47,440
really right you cannot you have to

00:40:45,280 --> 00:40:49,720
debug the code it's part of writing the

00:40:47,440 --> 00:40:52,120
code well if testing is pre-emptive

00:40:49,720 --> 00:40:53,830
debugging therefore testing is part of

00:40:52,120 --> 00:40:55,930
the creation process it's not something

00:40:53,830 --> 00:40:58,540
that you can just remove because

00:40:55,930 --> 00:41:01,090
basically instead of debugging later

00:40:58,540 --> 00:41:04,720
after you discover the bugs you write

00:41:01,090 --> 00:41:06,850
tests before you discover them and it's

00:41:04,720 --> 00:41:09,970
less effort it's always less effort to

00:41:06,850 --> 00:41:11,260
debug now than to debug later if you

00:41:09,970 --> 00:41:12,760
write those steps you're going to spend

00:41:11,260 --> 00:41:14,830
on or maybe five minutes writing a test

00:41:12,760 --> 00:41:16,930
but if you have to change that valve a

00:41:14,830 --> 00:41:19,270
few months later it's going to take you

00:41:16,930 --> 00:41:21,940
maybe a day so you can see it's really a

00:41:19,270 --> 00:41:24,400
big difference so you'd rather debug as

00:41:21,940 --> 00:41:27,190
early as possible by writing tests so

00:41:24,400 --> 00:41:29,890
once you start seeing testing as an

00:41:27,190 --> 00:41:31,600
integral part an integral part of your

00:41:29,890 --> 00:41:34,330
development process because it's really

00:41:31,600 --> 00:41:36,010
just debugging and from there it becomes

00:41:34,330 --> 00:41:37,630
so much easier to convince anyone you

00:41:36,010 --> 00:41:41,740
don't even need to you just write your

00:41:37,630 --> 00:41:44,230
tests and in the end you would spend

00:41:41,740 --> 00:41:47,260
less time on the entire project by

00:41:44,230 --> 00:41:49,720
writing tests done by not writing tests

00:41:47,260 --> 00:41:51,850
and debugging later so it will shorten

00:41:49,720 --> 00:41:53,860
your development time although it feels

00:41:51,850 --> 00:41:56,530
like you're adding more work you are

00:41:53,860 --> 00:41:58,750
actually shortening the actually the the

00:41:56,530 --> 00:42:02,950
second part which is you know writing

00:41:58,750 --> 00:42:04,510
the code and debugging it so yeah you

00:42:02,950 --> 00:42:06,520
will eventually as you get enough

00:42:04,510 --> 00:42:08,350
practice at first it's overwhelming it

00:42:06,520 --> 00:42:10,720
takes time but as you get enough

00:42:08,350 --> 00:42:12,040
practice it will save you a lot of time

00:42:10,720 --> 00:42:14,800
on the project as

00:42:12,040 --> 00:42:17,440
in my case I save about half of the time

00:42:14,800 --> 00:42:19,300
just by writing tests so something that

00:42:17,440 --> 00:42:22,120
would take otherwise six weeks is not

00:42:19,300 --> 00:42:24,100
taking three weeks so I don't even

00:42:22,120 --> 00:42:27,010
estimate projects in months anymore it's

00:42:24,100 --> 00:42:29,650
weeks sometimes days I want rescue the

00:42:27,010 --> 00:42:33,220
project in five hours just by writing

00:42:29,650 --> 00:42:35,440
tests so it's counterintuitive that you

00:42:33,220 --> 00:42:37,480
would save time by adding tests but what

00:42:35,440 --> 00:42:40,240
you have to do is really give testing a

00:42:37,480 --> 00:42:43,360
fair chance to work don't give up

00:42:40,240 --> 00:42:45,220
start small follow the steps if you go

00:42:43,360 --> 00:42:47,740
to the TDD and then it suddenly starts

00:42:45,220 --> 00:42:49,870
to not make sense go back to the other

00:42:47,740 --> 00:42:52,900
things and then when you're ready try

00:42:49,870 --> 00:42:55,690
again the last step TDD and see how it

00:42:52,900 --> 00:42:58,150
works for you so yeah that's pretty much

00:42:55,690 --> 00:43:02,170
it that's all I had to say I will tweet

00:42:58,150 --> 00:43:04,090
those slides I think this conference is

00:43:02,170 --> 00:43:06,400
enjoying it so go and write some

00:43:04,090 --> 00:43:14,890
comments I blog about a bunch of stuff

00:43:06,400 --> 00:43:17,530
and I'm ready for questions alright I

00:43:14,890 --> 00:43:19,780
wore approach do you take when you want

00:43:17,530 --> 00:43:22,800
to introduce that to code that maybe has

00:43:19,780 --> 00:43:26,770
lots of dependencies anism testable

00:43:22,800 --> 00:43:31,480
right I should really make a slide about

00:43:26,770 --> 00:43:34,330
that one day it's also very common I

00:43:31,480 --> 00:43:39,040
think I will actually pull another slide

00:43:34,330 --> 00:43:41,380
from another presentation which are also

00:43:39,040 --> 00:43:44,650
used to explain that so that's for my

00:43:41,380 --> 00:43:46,350
refactoring talk it doesn't matter what

00:43:44,650 --> 00:43:49,960
it does really what I'm saying here is

00:43:46,350 --> 00:43:53,080
this is very long method right and there

00:43:49,960 --> 00:43:55,270
is no test and there's a bug in there so

00:43:53,080 --> 00:43:57,430
you know it accepts a whole watch a

00:43:55,270 --> 00:44:01,840
bunch of arguments it's just so unwieldy

00:43:57,430 --> 00:44:04,390
and what you can do with that is you can

00:44:01,840 --> 00:44:07,690
find exactly so you go in and you find

00:44:04,390 --> 00:44:09,370
where the bug is right so I mean you

00:44:07,690 --> 00:44:11,740
don't just start writing tests for the

00:44:09,370 --> 00:44:13,630
sake of writing them necessarily as soon

00:44:11,740 --> 00:44:15,700
as you encounter about you go in there

00:44:13,630 --> 00:44:17,950
and you say okay so the second block

00:44:15,700 --> 00:44:20,680
there which unless you have the contrast

00:44:17,950 --> 00:44:22,450
but the second block gets coordinates

00:44:20,680 --> 00:44:25,630
for a location so it uses the Google

00:44:22,450 --> 00:44:27,760
geocoding API and you give it

00:44:25,630 --> 00:44:29,560
like a the brewery and it's going to

00:44:27,760 --> 00:44:32,920
give you the address and everything

00:44:29,560 --> 00:44:35,080
life is longitude all the good stuff so

00:44:32,920 --> 00:44:38,470
you have a bug in there so you grab that

00:44:35,080 --> 00:44:40,180
block and you can put it into a separate

00:44:38,470 --> 00:44:42,700
method and just call that method from

00:44:40,180 --> 00:44:46,000
this one right now you have a smaller

00:44:42,700 --> 00:44:48,820
method and you can write tests for it so

00:44:46,000 --> 00:44:51,460
you write tests first you fit the bug

00:44:48,820 --> 00:44:54,190
and then the test will have and that's

00:44:51,460 --> 00:44:57,190
how you can start instead of worrying

00:44:54,190 --> 00:44:59,560
about unit testing this whole method you

00:44:57,190 --> 00:45:01,450
split it into smaller chunks at the same

00:44:59,560 --> 00:45:04,060
time refactoring your code and making it

00:45:01,450 --> 00:45:06,250
more testable I've seen so this is

00:45:04,060 --> 00:45:08,740
actually pretty simple but code that I

00:45:06,250 --> 00:45:12,460
cannot show due to a contract that I had

00:45:08,740 --> 00:45:15,130
with the client have a method with two

00:45:12,460 --> 00:45:16,930
thousand lines of code and I found a bug

00:45:15,130 --> 00:45:18,940
in there that was just a small child and

00:45:16,930 --> 00:45:21,190
I just put it put it outside in a

00:45:18,940 --> 00:45:23,050
separate method called up unit test list

00:45:21,190 --> 00:45:25,600
and this this is a bug that will never

00:45:23,050 --> 00:45:35,080
happen again I know for sure is that

00:45:25,600 --> 00:45:37,270
help yes I mean there are tools where

00:45:35,080 --> 00:45:39,850
you can with reflection and everything

00:45:37,270 --> 00:45:43,050
we have other tools now that allow you

00:45:39,850 --> 00:45:52,560
to test I think even private methods

00:45:43,050 --> 00:45:58,540
yeah hi so what's the best way to test

00:45:52,560 --> 00:46:01,780
API data from third parties from third

00:45:58,540 --> 00:46:04,390
parties like if I want to make sure that

00:46:01,780 --> 00:46:06,250
data always coming or a certain

00:46:04,390 --> 00:46:10,960
structure but it could bring different

00:46:06,250 --> 00:46:13,120
things actually so what I do let's say

00:46:10,960 --> 00:46:15,160
let's use this example of the geocoding

00:46:13,120 --> 00:46:18,280
API when I was building this initially

00:46:15,160 --> 00:46:20,080
it's actually cold from work I would say

00:46:18,280 --> 00:46:24,460
paraphrase from from something I've

00:46:20,080 --> 00:46:27,430
built so I'm sending it something like a

00:46:24,460 --> 00:46:31,840
location and yeah the key and everything

00:46:27,430 --> 00:46:34,330
and then so I grabbed that URL I curl I

00:46:31,840 --> 00:46:37,210
get some data back and then I cash it

00:46:34,330 --> 00:46:39,300
and then I use that then I know that

00:46:37,210 --> 00:46:41,370
this URL correlates to this

00:46:39,300 --> 00:46:44,490
but it's hopefully consistently

00:46:41,370 --> 00:46:46,650
outputting this thing right and I can

00:46:44,490 --> 00:46:49,560
just save that file and then I can start

00:46:46,650 --> 00:46:51,930
writing tests against app and then when

00:46:49,560 --> 00:46:54,750
I build on top of it hopefully it

00:46:51,930 --> 00:47:09,810
doesn't change but that's one way to do

00:46:54,750 --> 00:47:11,400
it okay hi you mentioned not to go to

00:47:09,810 --> 00:47:14,760
your boss and tell them you're going to

00:47:11,400 --> 00:47:16,050
start unit testing and but in order to

00:47:14,760 --> 00:47:18,840
understand a problem you normally need

00:47:16,050 --> 00:47:21,660
to understand the business requirements

00:47:18,840 --> 00:47:23,670
for that so you can't just look at co2

00:47:21,660 --> 00:47:26,370
think I'm going to fix this you need to

00:47:23,670 --> 00:47:29,300
know why it's wrong and you know that

00:47:26,370 --> 00:47:32,090
kind of get some context around it so

00:47:29,300 --> 00:47:33,540
are you talking about getting into

00:47:32,090 --> 00:47:37,380
existing codes

00:47:33,540 --> 00:47:39,420
yeah six think oh yeah alright I suppose

00:47:37,380 --> 00:47:41,220
my question is you said don't gonna tell

00:47:39,420 --> 00:47:44,100
your boss I mean is that really good

00:47:41,220 --> 00:47:46,260
advice oh then tell your boss that

00:47:44,100 --> 00:47:49,170
you're writing stuff yeah well because

00:47:46,260 --> 00:47:50,910
what I mean is you need to get a better

00:47:49,170 --> 00:47:52,200
understanding of the problem before you

00:47:50,910 --> 00:47:55,050
can write catch to fix it

00:47:52,200 --> 00:47:58,550
yeah so you need to yeah this is awesome

00:47:55,050 --> 00:48:00,930
yeah and the Sun so what I'm saying is

00:47:58,550 --> 00:48:02,160
if you need to gather requirements go

00:48:00,930 --> 00:48:04,260
ahead and gather the requirements you

00:48:02,160 --> 00:48:05,580
don't have to justify that you're

00:48:04,260 --> 00:48:06,990
writing it you don't have to say that

00:48:05,580 --> 00:48:09,360
it's because you're writing a test or

00:48:06,990 --> 00:48:11,400
you're debugging I mean I'm not

00:48:09,360 --> 00:48:13,170
advocating a report for lying to people

00:48:11,400 --> 00:48:14,640
and everything and hiding I'm just

00:48:13,170 --> 00:48:17,640
saying you don't necessarily have to

00:48:14,640 --> 00:48:19,320
always say oh I'm going to debug this by

00:48:17,640 --> 00:48:21,120
doing a var dumpling you're not going to

00:48:19,320 --> 00:48:23,580
tell people every single thing you do so

00:48:21,120 --> 00:48:26,010
once you start seeing it like that

00:48:23,580 --> 00:48:28,290
don't don't separate that in your

00:48:26,010 --> 00:48:29,820
estimates don't show all I'm going to

00:48:28,290 --> 00:48:31,530
spend that much time writing code and

00:48:29,820 --> 00:48:33,720
that much time writing tests that

00:48:31,530 --> 00:48:37,170
doesn't make any sense just include that

00:48:33,720 --> 00:48:41,550
in to the entire estimate and present it

00:48:37,170 --> 00:48:44,940
as an indivisible unit okay one more

00:48:41,550 --> 00:48:47,250
question in this one it's just random

00:48:44,940 --> 00:48:48,440
obviously writing your own tested self

00:48:47,250 --> 00:48:51,060
policing

00:48:48,440 --> 00:48:52,280
would it be a good steps Watchi if you

00:48:51,060 --> 00:48:54,710
are working as part

00:48:52,280 --> 00:48:56,210
rather than individual to get someone

00:48:54,710 --> 00:48:58,970
else to write tests and then you

00:48:56,210 --> 00:49:01,120
implement those requirements oh yeah

00:48:58,970 --> 00:49:03,710
okay so so yeah we're talking about

00:49:01,120 --> 00:49:05,810
separating the QA team from the

00:49:03,710 --> 00:49:07,820
development team and that's that's

00:49:05,810 --> 00:49:10,910
perfectly fair it doesn't have to be but

00:49:07,820 --> 00:49:13,010
it can be and it's fine just because one

00:49:10,910 --> 00:49:16,970
person takes care of gathering all the

00:49:13,010 --> 00:49:19,160
requirements and putting it in coding it

00:49:16,970 --> 00:49:21,410
basically into test and the other person

00:49:19,160 --> 00:49:23,180
is responsible to read those tests and

00:49:21,410 --> 00:49:27,320
make them pass I mean yeah you can

00:49:23,180 --> 00:49:38,990
separate up okay there's one on the

00:49:27,320 --> 00:49:41,060
balcony they're hard to see hi so I'm

00:49:38,990 --> 00:49:46,070
walking libraries would you use mockery

00:49:41,060 --> 00:49:49,640
fake or PHP units native way of mocking

00:49:46,070 --> 00:49:52,400
objects I personally use PHP unit from

00:49:49,640 --> 00:49:54,140
for pretty much anything I mean it has

00:49:52,400 --> 00:49:58,610
integration with selenium and all that

00:49:54,140 --> 00:50:02,320
so I don't go too far okay I say I can't

00:49:58,610 --> 00:50:02,320
necessarily compare them side-by-side

00:50:03,220 --> 00:50:10,090
and you know one

00:50:15,470 --> 00:50:18,589
I just wonder if you use any particular

00:50:17,240 --> 00:50:21,259
tools or anything for measuring things

00:50:18,589 --> 00:50:23,630
life cyclomatic complexity right can

00:50:21,259 --> 00:50:25,759
chisel down so I just wondered if you

00:50:23,630 --> 00:50:30,529
use any particular tool for measuring

00:50:25,759 --> 00:50:32,210
the cyclomatic complexity yes the cycle

00:50:30,529 --> 00:50:36,500
Marv the cyclomatic complexity you can

00:50:32,210 --> 00:50:40,150
see that when you do what's it called

00:50:36,500 --> 00:50:42,950
the report the HTML report in the

00:50:40,150 --> 00:50:48,740
impeach feed unit and you can see all

00:50:42,950 --> 00:50:54,529
the variables there okay yes coverage

00:50:48,740 --> 00:51:01,430
thank you there's a lot question over

00:50:54,529 --> 00:51:04,640
there hi obviously when we're talking

00:51:01,430 --> 00:51:07,190
about unit testing to isolate systems we

00:51:04,640 --> 00:51:09,049
often mock dependencies so that we're

00:51:07,190 --> 00:51:11,000
only testing the system were concerned

00:51:09,049 --> 00:51:13,519
with I think my issue that I've

00:51:11,000 --> 00:51:16,130
experienced with multiple dependencies

00:51:13,519 --> 00:51:18,680
and mocking is that you get caught up

00:51:16,130 --> 00:51:20,240
with your test is very concerned with

00:51:18,680 --> 00:51:22,369
the implementation of the system your

00:51:20,240 --> 00:51:23,660
testing because it needs to know what

00:51:22,369 --> 00:51:26,630
methods are called on those mock

00:51:23,660 --> 00:51:27,859
dependent mock dependencies and so you

00:51:26,630 --> 00:51:30,349
will never tably end up when you're

00:51:27,859 --> 00:51:32,000
refactoring even though the expectation

00:51:30,349 --> 00:51:35,359
of whatever you're testing hasn't

00:51:32,000 --> 00:51:36,950
changed and the output and input haven't

00:51:35,359 --> 00:51:39,589
necessarily changed the implementation

00:51:36,950 --> 00:51:42,049
estate changed and because your test is

00:51:39,589 --> 00:51:44,329
so concerned with the implementation you

00:51:42,049 --> 00:51:46,670
end up having to maintain several tests

00:51:44,329 --> 00:51:48,559
and have every time you factor even a

00:51:46,670 --> 00:51:53,089
small bit of code you end up having to

00:51:48,559 --> 00:51:55,640
change multiple tests and I like trivial

00:51:53,089 --> 00:51:58,700
things like if maybe you called a method

00:51:55,640 --> 00:52:01,279
on the dependency they've mocked twice

00:51:58,700 --> 00:52:02,869
previously but now you've refracted a

00:52:01,279 --> 00:52:05,150
small bit of code in your you're now

00:52:02,869 --> 00:52:06,619
storing that to some variable and you're

00:52:05,150 --> 00:52:08,630
only calling at once you now need to

00:52:06,619 --> 00:52:10,549
update your test and say I should only

00:52:08,630 --> 00:52:13,220
expect this method to be called twice so

00:52:10,549 --> 00:52:16,069
it seems counterproductive when you're

00:52:13,220 --> 00:52:18,380
refactoring if you've got large test

00:52:16,069 --> 00:52:20,119
coverage and you've got you've separated

00:52:18,380 --> 00:52:22,069
loads of concerns so everything's being

00:52:20,119 --> 00:52:23,360
injected by dependencies as as we all

00:52:22,069 --> 00:52:25,100
feel it should be

00:52:23,360 --> 00:52:27,730
I just wanted to know what your approach

00:52:25,100 --> 00:52:30,550
to handling that kind of system is when

00:52:27,730 --> 00:52:33,010
your tests are no longer you no longer

00:52:30,550 --> 00:52:36,470
maintaining your tests for the sake of

00:52:33,010 --> 00:52:37,970
finding bugs but simply because you're

00:52:36,470 --> 00:52:39,590
having to get them to pass because

00:52:37,970 --> 00:52:41,450
you're changing some implementation

00:52:39,590 --> 00:52:43,670
though you're not you know for a fact

00:52:41,450 --> 00:52:46,400
you not introducing breaking changes

00:52:43,670 --> 00:52:46,820
because you know by the nature of what

00:52:46,400 --> 00:52:49,130
you're doing

00:52:46,820 --> 00:52:51,290
of course and it's a big problem when

00:52:49,130 --> 00:52:54,620
you start mocking a lot basically

00:52:51,290 --> 00:52:57,080
mocking is you create dependencies in

00:52:54,620 --> 00:52:59,240
your class and they kind of become into

00:52:57,080 --> 00:53:02,150
almost integration tests because you

00:52:59,240 --> 00:53:05,120
rely on these other methods so if you

00:53:02,150 --> 00:53:07,760
start if you get into a lot of mocks in

00:53:05,120 --> 00:53:10,280
your test case then that's a that's a

00:53:07,760 --> 00:53:13,790
warning sign basically some of the ways

00:53:10,280 --> 00:53:15,830
to reduce that is to split your code as

00:53:13,790 --> 00:53:18,560
much as possible so that instead of

00:53:15,830 --> 00:53:21,740
accepting dependency they can accept

00:53:18,560 --> 00:53:25,310
something more basic like a string so

00:53:21,740 --> 00:53:27,470
for example this geocoding I could

00:53:25,310 --> 00:53:30,530
either accept like a very complex class

00:53:27,470 --> 00:53:32,840
or I can accept so once I decoded

00:53:30,530 --> 00:53:35,270
everything I can have an object that's

00:53:32,840 --> 00:53:37,250
very complex or I can just you know

00:53:35,270 --> 00:53:41,570
provide a string with latitude longitude

00:53:37,250 --> 00:53:43,730
or or just two numbers and try to use

00:53:41,570 --> 00:53:45,800
primitives as much as possible when

00:53:43,730 --> 00:53:50,240
calling methods and that can avoid using

00:53:45,800 --> 00:53:52,340
a lot of a lot of those mocks and yeah I

00:53:50,240 --> 00:53:54,980
just in general having methods that

00:53:52,340 --> 00:53:57,740
don't necessarily depend or aren't

00:53:54,980 --> 00:54:00,200
concerned about dependencies as much so

00:53:57,740 --> 00:54:03,920
in your object instead of calling this

00:54:00,200 --> 00:54:05,570
from some dependency call method you can

00:54:03,920 --> 00:54:08,630
maybe maybe that method can from a

00:54:05,570 --> 00:54:11,360
different one receive the the raw data

00:54:08,630 --> 00:54:13,730
from the dependencies and then acts upon

00:54:11,360 --> 00:54:15,350
it a machine this and what I mean

00:54:13,730 --> 00:54:17,000
so for exactly you're writing a

00:54:15,350 --> 00:54:19,100
controller and you have the request

00:54:17,000 --> 00:54:20,930
object so maybe instead of grabbing the

00:54:19,100 --> 00:54:23,890
request object and getting something out

00:54:20,930 --> 00:54:26,690
of it you can have a method that just

00:54:23,890 --> 00:54:29,300
gets the let's say you're concerned with

00:54:26,690 --> 00:54:31,310
the system header from your request so

00:54:29,300 --> 00:54:32,690
you grab that from the request and then

00:54:31,310 --> 00:54:34,940
you pass it to this other method that

00:54:32,690 --> 00:54:36,810
does the actual logic then you can unit

00:54:34,940 --> 00:54:38,610
test it much more easily with

00:54:36,810 --> 00:54:40,290
being concerned with dependency so it's

00:54:38,610 --> 00:54:43,800
just a way to refactor things so that

00:54:40,290 --> 00:54:46,350
your methods are concerned with the

00:54:43,800 --> 00:54:47,580
state of the object so much instead you

00:54:46,350 --> 00:54:49,410
have a method that kind of puts

00:54:47,580 --> 00:54:51,150
everything together which you don't

00:54:49,410 --> 00:54:53,520
necessarily need to test and then that

00:54:51,150 --> 00:54:55,440
dispatches to the smaller methods that

00:54:53,520 --> 00:54:57,360
do the actual logic because you're you

00:54:55,440 --> 00:54:59,190
only care about testing the logically

00:54:57,360 --> 00:55:00,870
and then you can have integration tests

00:54:59,190 --> 00:55:03,960
for the others and those are a lot more

00:55:00,870 --> 00:55:06,450
high maintenance so yeah I try to try to

00:55:03,960 --> 00:55:09,390
have your unit test as isolated from

00:55:06,450 --> 00:55:14,640
even its own object as possible that's

00:55:09,390 --> 00:55:19,350
my approach does that help okay there

00:55:14,640 --> 00:55:22,130
was a question on there not that

00:55:19,350 --> 00:55:25,380
person's on the phone Matt so oh good

00:55:22,130 --> 00:55:26,790
maybe asking the Twitterverse all right

00:55:25,380 --> 00:55:27,870
well thank you very much thanks for

00:55:26,790 --> 00:55:31,710
joining

00:55:27,870 --> 00:55:31,710

YouTube URL: https://www.youtube.com/watch?v=ESl-ncXA4G0


