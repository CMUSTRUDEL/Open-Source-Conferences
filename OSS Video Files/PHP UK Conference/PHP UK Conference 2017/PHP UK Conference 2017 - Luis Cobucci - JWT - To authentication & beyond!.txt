Title: PHP UK Conference 2017 - Luis Cobucci - JWT - To authentication & beyond!
Publication date: 2017-04-03
Playlist: PHP UK Conference 2017
Description: 
	Tokens are widely used to identify resources and try to add some security to insecure environments, but sometimes the management of those identifiers can get a bit complex - even more on distributed systems. What if we could have an intelligent token, one that simplifies the way things works without losing integrity or security? In this talk we present Json Web Tokens as an alternative for smart and self contained tokens, explaining how to use each claim and giving some common use cases.
Captions: 
	00:00:00,000 --> 00:00:10,320
owning everyone how you doing great all

00:00:06,089 --> 00:00:14,389
right so a couple years ago I had a

00:00:10,320 --> 00:00:19,640
mission my mission was to create an API

00:00:14,389 --> 00:00:22,590
not a very fancy API though but a

00:00:19,640 --> 00:00:26,699
restful api with the hypermedia stuff

00:00:22,590 --> 00:00:29,099
and a simple authentication method then

00:00:26,699 --> 00:00:36,180
I said yeah all right

00:00:29,099 --> 00:00:40,739
I am ready but there was some weird

00:00:36,180 --> 00:00:43,730
stuff happening because I had to create

00:00:40,739 --> 00:00:46,469
some tokens in order to say okay

00:00:43,730 --> 00:00:49,440
basically exchange your credentials for

00:00:46,469 --> 00:00:55,050
a token so you can use the API back and

00:00:49,440 --> 00:00:57,989
forth but that token should expire okay

00:00:55,050 --> 00:01:01,230
I will just throw that information in

00:00:57,989 --> 00:01:08,250
the database not the most natural way to

00:01:01,230 --> 00:01:12,510
to do that some months later I was asked

00:01:08,250 --> 00:01:16,500
to do like now we have two clients some

00:01:12,510 --> 00:01:22,950
tokens can only be a one of these

00:01:16,500 --> 00:01:27,140
clients okay let's hook that into the

00:01:22,950 --> 00:01:30,689
database again and more of these things

00:01:27,140 --> 00:01:35,150
kept coming and you can see that it was

00:01:30,689 --> 00:01:38,460
wonderful everything was perfect but no

00:01:35,150 --> 00:01:42,390
the database was a match we have it

00:01:38,460 --> 00:01:47,869
we had expired tokens in a database we

00:01:42,390 --> 00:01:51,540
had a lot of issues there and from it

00:01:47,869 --> 00:01:56,610
when I look at that math I said okay I'm

00:01:51,540 --> 00:02:01,740
done we need something simple in order

00:01:56,610 --> 00:02:07,350
to work yeah my clickers not good we

00:02:01,740 --> 00:02:10,590
need it simple and my name is Luis

00:02:07,350 --> 00:02:12,030
kabuki I'm a Brazilian developer living

00:02:10,590 --> 00:02:13,910
in Anthem

00:02:12,030 --> 00:02:18,510
I have

00:02:13,910 --> 00:02:22,440
acromial to break doctrine I also help

00:02:18,510 --> 00:02:26,460
Raphael to ruin everything else in PHP I

00:02:22,440 --> 00:02:29,580
work at vex pot into Dutch company that

00:02:26,460 --> 00:02:36,300
also has some business in InterPro in

00:02:29,580 --> 00:02:40,790
Italy as interpro and after I went

00:02:36,300 --> 00:02:45,740
through all these database troubles I

00:02:40,790 --> 00:02:51,600
found something very interesting it was

00:02:45,740 --> 00:02:57,650
a work that would started in 2012 it was

00:02:51,600 --> 00:03:00,180
basically to have smart tokens a self

00:02:57,650 --> 00:03:03,720
everything was in the token and it was

00:03:00,180 --> 00:03:07,070
very easy to understand and how to use

00:03:03,720 --> 00:03:11,280
it the name of it was G's on web tokens

00:03:07,070 --> 00:03:14,490
in order to start this the best thing I

00:03:11,280 --> 00:03:20,570
can do is to show it token for you this

00:03:14,490 --> 00:03:27,360
is a token ah it looks familiar right oh

00:03:20,570 --> 00:03:30,270
come on don't is this looks like

00:03:27,360 --> 00:03:36,540
basically poor encoding strings right a

00:03:30,270 --> 00:03:39,420
bit because it is kind of a base64

00:03:36,540 --> 00:03:43,530
encoding for those that doesn't know

00:03:39,420 --> 00:03:47,070
about basics before just keep one thing

00:03:43,530 --> 00:03:51,050
in mind it's not encryption that's

00:03:47,070 --> 00:03:53,970
enough but basically is a way to have a

00:03:51,050 --> 00:03:56,940
binary safe string so if you have a

00:03:53,970 --> 00:03:59,370
string that contains binary data you can

00:03:56,940 --> 00:04:01,500
just encode it with that algorithm and

00:03:59,370 --> 00:04:04,640
you have you can just pass it around and

00:04:01,500 --> 00:04:08,610
you it will be safe but the problem is

00:04:04,640 --> 00:04:12,930
we have some dots here and base64

00:04:08,610 --> 00:04:16,790
encoding doesn't have dots the idea of

00:04:12,930 --> 00:04:20,010
the dots is to serve as separators and

00:04:16,790 --> 00:04:24,060
there's another difference here in this

00:04:20,010 --> 00:04:26,310
encoded string because it's a variation

00:04:24,060 --> 00:04:30,560
of a base64 encoding

00:04:26,310 --> 00:04:33,720
is what we call base64 URL basically it

00:04:30,560 --> 00:04:37,260
converts some characters in order to

00:04:33,720 --> 00:04:41,280
make it safe to be passed and a query

00:04:37,260 --> 00:04:41,960
string or basically on the URL any part

00:04:41,280 --> 00:04:47,580
of it

00:04:41,960 --> 00:04:50,250
okay so now that we know how to decode

00:04:47,580 --> 00:04:56,880
this token let's apply that algorithm

00:04:50,250 --> 00:05:01,020
and the result will be this so yeah we

00:04:56,880 --> 00:05:03,780
have a JSON perfect it can do all sorts

00:05:01,020 --> 00:05:06,930
of things we can store anything in the

00:05:03,780 --> 00:05:11,120
JSON and pass it around right the first

00:05:06,930 --> 00:05:14,389
use case or the most common use case is

00:05:11,120 --> 00:05:17,729
about authorization and authentication

00:05:14,389 --> 00:05:21,090
where you have two sides of it the

00:05:17,729 --> 00:05:23,910
client and an API the client basically

00:05:21,090 --> 00:05:26,040
presents the credentials the API

00:05:23,910 --> 00:05:29,790
validates the credentials this is

00:05:26,040 --> 00:05:34,110
basically an example of the objects that

00:05:29,790 --> 00:05:39,330
you can use as JSON content we're going

00:05:34,110 --> 00:05:44,210
to talk about what does it mean and the

00:05:39,330 --> 00:05:47,000
API sends the token back and for next

00:05:44,210 --> 00:05:50,460
request the token will be passed as

00:05:47,000 --> 00:05:52,800
authorization header and API will be

00:05:50,460 --> 00:05:56,550
able to say okay it's the signature

00:05:52,800 --> 00:06:01,919
valid is this client allowed to use this

00:05:56,550 --> 00:06:04,590
token the the issue was me or somebody

00:06:01,919 --> 00:06:07,530
else issued this token and can this

00:06:04,590 --> 00:06:11,010
still can be used at this moment another

00:06:07,530 --> 00:06:16,860
common use case and and that helps a lot

00:06:11,010 --> 00:06:22,590
is links have you ever needed to create

00:06:16,860 --> 00:06:24,510
a reset password token or email and you

00:06:22,590 --> 00:06:27,870
needed to store things in the database

00:06:24,510 --> 00:06:31,169
or find a way to be able to expire this

00:06:27,870 --> 00:06:35,220
token with JSON web token it makes very

00:06:31,169 --> 00:06:38,690
simple because you can set ok the

00:06:35,220 --> 00:06:44,380
expiration of this token is in two days

00:06:38,690 --> 00:06:47,210
so the user is the user one two or three

00:06:44,380 --> 00:06:51,290
it will have a string and you can just

00:06:47,210 --> 00:06:55,210
pass it on the URL the same thing

00:06:51,290 --> 00:06:59,000
happens with the the pages that you need

00:06:55,210 --> 00:07:01,460
like the user must be logged to use the

00:06:59,000 --> 00:07:03,530
content and you want to from an email

00:07:01,460 --> 00:07:08,270
you want to login the user you can also

00:07:03,530 --> 00:07:11,390
use a JSON web token to do that CSRs

00:07:08,270 --> 00:07:16,850
validation program use created this

00:07:11,390 --> 00:07:22,760
library ah that basically puts the the

00:07:16,850 --> 00:07:25,160
ID so let's go back a bit CSRs is

00:07:22,760 --> 00:07:30,080
basically a security measure to make

00:07:25,160 --> 00:07:31,870
sure that nobody is the user is sending

00:07:30,080 --> 00:07:35,900
the form is the right user and you

00:07:31,870 --> 00:07:39,650
certifies that so usually you put a

00:07:35,900 --> 00:07:42,440
token in your session and this goes also

00:07:39,650 --> 00:07:45,470
in the form when you have the request

00:07:42,440 --> 00:07:47,870
you you receive the token on the form

00:07:45,470 --> 00:07:53,360
and validates okay is this the same

00:07:47,870 --> 00:07:56,510
token or not so you can also use JSON

00:07:53,360 --> 00:07:58,550
web tokens to implement that so the

00:07:56,510 --> 00:08:00,919
token that girls in in the form is a

00:07:58,550 --> 00:08:04,160
smart token is the one that knows about

00:08:00,919 --> 00:08:07,100
expiration and all sorts of things so

00:08:04,160 --> 00:08:12,590
this library is pretty nice and helps

00:08:07,100 --> 00:08:17,530
you to manipulate this inside forms in a

00:08:12,590 --> 00:08:21,050
different use case is regarding sessions

00:08:17,530 --> 00:08:26,950
the standard PHP session basically works

00:08:21,050 --> 00:08:30,320
with cookies right so you have something

00:08:26,950 --> 00:08:33,229
some data that the webstore server

00:08:30,320 --> 00:08:35,780
stores into a file get another

00:08:33,229 --> 00:08:40,099
identifier and send it back to the

00:08:35,780 --> 00:08:42,590
client right that happens when you do a

00:08:40,099 --> 00:08:46,220
session start view everything out of

00:08:42,590 --> 00:08:49,130
session superglobal and ends the request

00:08:46,220 --> 00:08:51,650
and you have this session there on the

00:08:49,130 --> 00:08:52,459
next request the server the clients will

00:08:51,650 --> 00:08:55,980
send

00:08:52,459 --> 00:09:00,959
that the same identifier and the server

00:08:55,980 --> 00:09:04,920
will know okay I will fetch the file

00:09:00,959 --> 00:09:06,089
with that name and I will know all the

00:09:04,920 --> 00:09:11,990
data that is stored there

00:09:06,089 --> 00:09:15,779
this in Joe's storing so IO also

00:09:11,990 --> 00:09:17,759
serializing because session data is

00:09:15,779 --> 00:09:22,170
serialize in order to be stored into a

00:09:17,759 --> 00:09:27,089
file and there's an issue that if you

00:09:22,170 --> 00:09:31,050
have this kind of setup you just have to

00:09:27,089 --> 00:09:34,079
basically two choices either you create

00:09:31,050 --> 00:09:38,850
a you remove the storage from the web

00:09:34,079 --> 00:09:42,240
server or you just say okay the load

00:09:38,850 --> 00:09:45,689
balancer will do a sticky session so if

00:09:42,240 --> 00:09:48,000
the client goes it was processed on the

00:09:45,689 --> 00:09:51,899
server one it will always go to the

00:09:48,000 --> 00:09:55,889
server one this involves a lot of things

00:09:51,899 --> 00:10:00,029
and also rely on superglobals is not

00:09:55,889 --> 00:10:04,439
really cool right so if you want you can

00:10:00,029 --> 00:10:07,649
use a JSON web token that basically

00:10:04,439 --> 00:10:10,740
contains the session data and it's best

00:10:07,649 --> 00:10:13,759
to any web server and anyone can process

00:10:10,740 --> 00:10:16,769
that request of course it has some

00:10:13,759 --> 00:10:19,470
limitations they have some issues that

00:10:16,769 --> 00:10:21,810
you need to understand because well

00:10:19,470 --> 00:10:25,350
basics before it's not encryption

00:10:21,810 --> 00:10:27,660
do you remember so you need to ensure

00:10:25,350 --> 00:10:31,019
that you're not saving sensitive data

00:10:27,660 --> 00:10:33,839
inside of the token another another

00:10:31,019 --> 00:10:37,380
library that you can use is this one

00:10:33,839 --> 00:10:41,490
that we create together chrome use me

00:10:37,380 --> 00:10:45,809
and Maliki and it's basically a mirror

00:10:41,490 --> 00:10:48,750
that you can use to create and

00:10:45,809 --> 00:10:53,879
manipulate the sessions using JSON web

00:10:48,750 --> 00:10:57,839
tokens now that you have some ideas on

00:10:53,879 --> 00:11:01,490
how a token can use can be used let's

00:10:57,839 --> 00:11:04,410
see and understand it better on how

00:11:01,490 --> 00:11:09,270
things works there

00:11:04,410 --> 00:11:12,420
as you saw we had this to JSON objects

00:11:09,270 --> 00:11:15,720
there the first one represents the

00:11:12,420 --> 00:11:19,560
headers the headers basically have the

00:11:15,720 --> 00:11:23,640
information that you need to know in

00:11:19,560 --> 00:11:26,520
order to decode that token so you can

00:11:23,640 --> 00:11:32,610
you have a type you have an algorithm

00:11:26,520 --> 00:11:36,960
you can have a key ID as Adam shown on

00:11:32,610 --> 00:11:42,210
his talk yesterday and you also have a

00:11:36,960 --> 00:11:45,480
list of claims you basically we have

00:11:42,210 --> 00:11:49,320
three kinds of claims in the JSON

00:11:45,480 --> 00:11:51,900
token a web token extrication the public

00:11:49,320 --> 00:11:56,970
can claims the registry claims and the

00:11:51,900 --> 00:12:01,230
private claims the list of register

00:11:56,970 --> 00:12:05,310
claims is this one so the idea of a JSON

00:12:01,230 --> 00:12:09,240
web tokens to be compact so the register

00:12:05,310 --> 00:12:12,630
claims as in the standard claims where

00:12:09,240 --> 00:12:16,890
you can use and nobody can collide with

00:12:12,630 --> 00:12:19,710
them it's basically this one we have on

00:12:16,890 --> 00:12:24,090
the top the token ID which is the

00:12:19,710 --> 00:12:28,860
identifier for the token the issue so

00:12:24,090 --> 00:12:31,560
what was the server or the host name

00:12:28,860 --> 00:12:35,460
that issued the token basically an

00:12:31,560 --> 00:12:38,760
identification for that the audience of

00:12:35,460 --> 00:12:41,280
the token so what are the clients that

00:12:38,760 --> 00:12:44,370
are permitted to consume this token or

00:12:41,280 --> 00:12:47,850
to use that token so it can be just a

00:12:44,370 --> 00:12:51,180
single string or URI or an array of

00:12:47,850 --> 00:12:55,860
strings the subjects of the token what a

00:12:51,180 --> 00:12:59,100
token relates to and finally the three

00:12:55,860 --> 00:13:02,250
informations about date issue that when

00:12:59,100 --> 00:13:05,070
the token was created expiration and not

00:13:02,250 --> 00:13:09,270
before which is basically the minimum

00:13:05,070 --> 00:13:11,820
time where the token can be used so this

00:13:09,270 --> 00:13:15,270
tree are very powerful because you can

00:13:11,820 --> 00:13:17,320
say I'm creating the token now it can

00:13:15,270 --> 00:13:21,400
only be used

00:13:17,320 --> 00:13:24,730
tomorrow but it cannot be used before of

00:13:21,400 --> 00:13:28,440
five minutes from now so you can specify

00:13:24,730 --> 00:13:31,660
a very good range and this numeric date

00:13:28,440 --> 00:13:34,900
usually is represented using a UNIX

00:13:31,660 --> 00:13:38,710
timestamp as an integer but it can also

00:13:34,900 --> 00:13:43,270
be a string with so it will be a

00:13:38,710 --> 00:13:46,870
timestamp with microseconds so it's very

00:13:43,270 --> 00:13:48,810
powerful so how to manage that is really

00:13:46,870 --> 00:13:53,710
nice

00:13:48,810 --> 00:13:55,630
the first register claims are case

00:13:53,710 --> 00:13:58,570
sensitive so when you're validating them

00:13:55,630 --> 00:14:00,790
you must be sure that you're doing in

00:13:58,570 --> 00:14:03,220
the right way

00:14:00,790 --> 00:14:06,970
apart from the register claims we have

00:14:03,220 --> 00:14:09,940
the idea of public claims public claims

00:14:06,970 --> 00:14:13,030
are basically claims that people from

00:14:09,940 --> 00:14:16,840
all around the world they are using all

00:14:13,030 --> 00:14:20,380
the time the same claims so it can be

00:14:16,840 --> 00:14:23,710
standardized sometime so we like

00:14:20,380 --> 00:14:26,350
reserved them as public for some time

00:14:23,710 --> 00:14:29,800
and then we register them the private

00:14:26,350 --> 00:14:34,030
claims are the claims that you want to

00:14:29,800 --> 00:14:37,440
use you can be anything would be nice to

00:14:34,030 --> 00:14:42,220
keep the idea of short identifiers so

00:14:37,440 --> 00:14:46,060
you don't use a lot of space because

00:14:42,220 --> 00:14:49,930
again it's a base64 URL encryption

00:14:46,060 --> 00:14:57,310
encoding sorry so yeah just to see if

00:14:49,930 --> 00:15:01,600
you're awake or not and so this encoded

00:14:57,310 --> 00:15:03,040
string will increase in size according

00:15:01,600 --> 00:15:06,850
to the data that it's stored there and

00:15:03,040 --> 00:15:11,350
it can get very big so looking at it

00:15:06,850 --> 00:15:15,310
this is the token this is the content of

00:15:11,350 --> 00:15:19,660
token and if we apply the same encoding

00:15:15,310 --> 00:15:22,720
we have these the encoded result but I

00:15:19,660 --> 00:15:27,940
want to point you that there's an ID

00:15:22,720 --> 00:15:30,960
that right so if I just encode it it

00:15:27,940 --> 00:15:35,400
will be this but it cannot be trusted

00:15:30,960 --> 00:15:38,070
because it's not encryption anyone can

00:15:35,400 --> 00:15:42,150
just decode the token change the data

00:15:38,070 --> 00:15:46,470
and pass it back to you so how do you

00:15:42,150 --> 00:15:49,410
ensure the integrity of the token we use

00:15:46,470 --> 00:15:54,090
signatures for that basically you get

00:15:49,410 --> 00:15:59,520
the headers and the claims in codon use

00:15:54,090 --> 00:16:02,940
the dot as separator and this string

00:15:59,520 --> 00:16:07,950
will be a payload for a signature

00:16:02,940 --> 00:16:10,610
algorithm that you now basically say

00:16:07,950 --> 00:16:14,130
okay this is my key this is my pickled

00:16:10,610 --> 00:16:17,760
create a hash for me and I will use this

00:16:14,130 --> 00:16:23,670
hash as signature again this signature

00:16:17,760 --> 00:16:27,240
is encoded with the same algorithm so

00:16:23,670 --> 00:16:34,230
the same example using this key will

00:16:27,240 --> 00:16:38,640
create this token now this is true

00:16:34,230 --> 00:16:42,650
stable because if somebody changes the

00:16:38,640 --> 00:16:48,800
content the signature will not match

00:16:42,650 --> 00:16:52,770
right so yeah unless they have your

00:16:48,800 --> 00:16:58,530
signing key which is not recommended

00:16:52,770 --> 00:17:01,590
right enough of this let's see some PHP

00:16:58,530 --> 00:17:07,470
because after all we're in a PHP

00:17:01,590 --> 00:17:11,100
conference right so as I said um the

00:17:07,470 --> 00:17:15,500
whole thing was created in the movement

00:17:11,100 --> 00:17:20,940
of JSON web tokens started in 2012 in

00:17:15,500 --> 00:17:26,060
2014 I've created this library or I

00:17:20,940 --> 00:17:31,050
started this library it's being used

00:17:26,060 --> 00:17:35,390
pretty well I gotta say and we're very

00:17:31,050 --> 00:17:39,030
close to releasing a new major version

00:17:35,390 --> 00:17:40,930
because yeah nobody uses PHP 5 anymore

00:17:39,030 --> 00:17:46,750
so

00:17:40,930 --> 00:17:49,540
ah come on yeah so I'm dropping php5 and

00:17:46,750 --> 00:17:52,600
I'm dropping support of 57 as well just

00:17:49,540 --> 00:17:55,120
will support 7 1

00:17:52,600 --> 00:17:58,630
yeah because new liberal types and voids

00:17:55,120 --> 00:18:01,240
are awesome so what I'm going to show

00:17:58,630 --> 00:18:04,030
here is basically the usage of this new

00:18:01,240 --> 00:18:09,690
API everything starts with a

00:18:04,030 --> 00:18:13,510
configuration that basically is used as

00:18:09,690 --> 00:18:17,530
a small dependency injection container

00:18:13,510 --> 00:18:19,750
because all the objects has some objects

00:18:17,530 --> 00:18:23,920
like the buter or the faster they have

00:18:19,750 --> 00:18:26,350
some dependencies and if you are to pass

00:18:23,920 --> 00:18:29,290
these dependencies you can get very

00:18:26,350 --> 00:18:34,980
complicated so yeah let's cut in the

00:18:29,290 --> 00:18:34,980
easy way this configuration is basically

00:18:35,070 --> 00:18:42,160
will hold the validator the buter and

00:18:38,710 --> 00:18:44,830
the parser so here we're building a

00:18:42,160 --> 00:18:50,350
configuration for an n symmetric signer

00:18:44,830 --> 00:18:53,290
that's using RSA and you just pass two

00:18:50,350 --> 00:18:56,680
keys because it's a symmetric we're

00:18:53,290 --> 00:19:00,850
going to talk about this in a few

00:18:56,680 --> 00:19:04,960
moments and so you have to specify the

00:19:00,850 --> 00:19:07,540
private key and the public key then you

00:19:04,960 --> 00:19:09,940
start building your token you get a

00:19:07,540 --> 00:19:16,740
configuration object and you're saying

00:19:09,940 --> 00:19:22,510
okay this token is identified by this ID

00:19:16,740 --> 00:19:26,490
was issued by this host this is the list

00:19:22,510 --> 00:19:31,090
of permitted clients was issued at now

00:19:26,490 --> 00:19:35,350
it's valid for one hour and can only be

00:19:31,090 --> 00:19:38,860
used after 30 seconds from now and I

00:19:35,350 --> 00:19:44,140
have a private claim here not that short

00:19:38,860 --> 00:19:47,830
it says user ID is 1 and I just get a

00:19:44,140 --> 00:19:52,660
token passing the designer and the

00:19:47,830 --> 00:19:54,690
signing key and if I do a a 2 string or

00:19:52,660 --> 00:19:57,150
I

00:19:54,690 --> 00:20:03,710
do a dive cast first ring I will have my

00:19:57,150 --> 00:20:08,010
token as trained this token is an object

00:20:03,710 --> 00:20:12,870
that is immutable so once it's created

00:20:08,010 --> 00:20:18,600
you cannot modify anything the result of

00:20:12,870 --> 00:20:25,380
this drink cast as typecast will be this

00:20:18,600 --> 00:20:28,710
string which is very long but you can

00:20:25,380 --> 00:20:32,340
see cannot find easily the dots there

00:20:28,710 --> 00:20:37,830
but most of it is basically the

00:20:32,340 --> 00:20:42,440
signature it's using RSA and if I want

00:20:37,830 --> 00:20:46,320
to parse the token I just get it the

00:20:42,440 --> 00:20:50,220
JSON string the JSON web token go to the

00:20:46,320 --> 00:20:53,580
parser and I have my object back okay so

00:20:50,220 --> 00:20:57,480
I know how to create a token using PHP I

00:20:53,580 --> 00:21:01,310
know how to parse a token use PHP but I

00:20:57,480 --> 00:21:05,220
need to validate it right because yeah

00:21:01,310 --> 00:21:08,460
what I'm doing with a string and with

00:21:05,220 --> 00:21:11,100
the data if I was not the one that

00:21:08,460 --> 00:21:14,460
created a token or this is not my

00:21:11,100 --> 00:21:16,530
signature I need to validate on using

00:21:14,460 --> 00:21:19,980
the library there are two methods that

00:21:16,530 --> 00:21:22,020
you can call to validate the token one

00:21:19,980 --> 00:21:25,860
is basically you get the validator and

00:21:22,020 --> 00:21:29,670
you call validate that will return true

00:21:25,860 --> 00:21:32,400
or false if the token is valid or not or

00:21:29,670 --> 00:21:34,860
you can use a search and it will raise

00:21:32,400 --> 00:21:36,600
an exception if the token is in solid

00:21:34,860 --> 00:21:40,640
base it on the constraint list that

00:21:36,600 --> 00:21:45,690
you're passing you can create a

00:21:40,640 --> 00:21:49,140
customized validators or constraints if

00:21:45,690 --> 00:21:52,290
you want to check like okay the user ID

00:21:49,140 --> 00:21:56,280
must be an integer and must exist in my

00:21:52,290 --> 00:21:59,910
database so you can create a validation

00:21:56,280 --> 00:22:02,250
for that if you want here I'm basically

00:21:59,910 --> 00:22:06,510
checking if the token was issued by me

00:22:02,250 --> 00:22:07,690
is permitted for this client and it's

00:22:06,510 --> 00:22:12,009
valid as

00:22:07,690 --> 00:22:15,179
now and it was signed with my signer and

00:22:12,009 --> 00:22:20,409
verification key which is my public key

00:22:15,179 --> 00:22:23,019
if you want more libraries we have this

00:22:20,409 --> 00:22:25,950
page which is very very nice

00:22:23,019 --> 00:22:28,870
because you can read they're on top

00:22:25,950 --> 00:22:32,679
there's a debugger where you can just

00:22:28,870 --> 00:22:35,950
call it a token there and say okay is

00:22:32,679 --> 00:22:39,690
this token valid or what it contains

00:22:35,950 --> 00:22:46,269
what is its body and its headers you can

00:22:39,690 --> 00:22:50,230
easily see and also for RSA and H Mac

00:22:46,269 --> 00:22:53,019
you can validate the signature you can't

00:22:50,230 --> 00:22:55,870
you have a future there that says ok I

00:22:53,019 --> 00:22:58,690
want to see all the PHP implementations

00:22:55,870 --> 00:23:01,059
or the Java implementations Java Script

00:22:58,690 --> 00:23:04,720
go whatever you can just go there and

00:23:01,059 --> 00:23:10,000
see all right guys

00:23:04,720 --> 00:23:14,320
so we saw what is the JSON web token we

00:23:10,000 --> 00:23:17,710
saw how to use it some ideas it's

00:23:14,320 --> 00:23:21,220
important to say that your imagination

00:23:17,710 --> 00:23:26,860
is the limit you can use in all sorts of

00:23:21,220 --> 00:23:30,570
ways I was talking with a Crimea's some

00:23:26,860 --> 00:23:34,210
days ago and he had an idea to use it

00:23:30,570 --> 00:23:36,639
with captures so we can validate that

00:23:34,210 --> 00:23:40,539
and pass the token instead of putting

00:23:36,639 --> 00:23:46,029
things into the session yeah you can do

00:23:40,539 --> 00:23:48,820
that on these years that I maintain this

00:23:46,029 --> 00:23:53,710
library I got I had some questions about

00:23:48,820 --> 00:23:57,730
the JSON web token usage and so I'm

00:23:53,710 --> 00:24:04,720
basically bringing them first question

00:23:57,730 --> 00:24:09,909
is is it a replacement for OAuth short

00:24:04,720 --> 00:24:12,490
answer no the idea of a JSON web token

00:24:09,909 --> 00:24:16,450
is basically to be a token it doesn't

00:24:12,490 --> 00:24:18,779
say that you need to use to create these

00:24:16,450 --> 00:24:21,799
authorization and authentication flow

00:24:18,779 --> 00:24:25,820
now it that's up to you

00:24:21,799 --> 00:24:30,220
in fact you can also combine the JSON

00:24:25,820 --> 00:24:36,289
web token with the OAuth if you see the

00:24:30,220 --> 00:24:38,809
the OAuth server of the PHP League you

00:24:36,289 --> 00:24:43,399
will see that we have JSON web token

00:24:38,809 --> 00:24:46,639
support there and it works fine the

00:24:43,399 --> 00:24:51,919
access key and also the Refresh key you

00:24:46,639 --> 00:24:55,009
can use JSON web tokens there what is

00:24:51,919 --> 00:25:00,739
the best algorithm to create your

00:24:55,009 --> 00:25:04,159
signatures yeah that's a question that

00:25:00,739 --> 00:25:08,080
you will hear a lot again the short

00:25:04,159 --> 00:25:15,759
answer is just go for a symmetric

00:25:08,080 --> 00:25:18,950
algorithms like RSA or ECDSA we have

00:25:15,759 --> 00:25:24,489
untwisted tokens like the ones that

00:25:18,950 --> 00:25:28,639
doesn't have a signature and we have the

00:25:24,489 --> 00:25:33,379
H Mac the problem with H max is that it

00:25:28,639 --> 00:25:39,669
is a symmetric algorithm so it has only

00:25:33,379 --> 00:25:43,100
one key that means that if you need to

00:25:39,669 --> 00:25:45,440
verify your key or your signature in a

00:25:43,100 --> 00:25:49,100
different place you need to share that

00:25:45,440 --> 00:25:54,559
key so that's why I'm recommend to use

00:25:49,100 --> 00:25:57,830
either RSA or ECDSA the difference

00:25:54,559 --> 00:26:01,929
between them I must be honest I'd don't

00:25:57,830 --> 00:26:05,929
know for sure I know that one used

00:26:01,929 --> 00:26:11,629
Olympic elliptic curves sorry for the

00:26:05,929 --> 00:26:13,759
bad english but the idea is that you

00:26:11,629 --> 00:26:19,429
have some mathematical curves and you

00:26:13,759 --> 00:26:24,409
just use there and the other is RSA I

00:26:19,429 --> 00:26:27,950
think you probably know a bit so the

00:26:24,409 --> 00:26:28,879
idea of them all like ok when to use one

00:26:27,950 --> 00:26:32,059
or the other

00:26:28,879 --> 00:26:35,660
easier to say I know that it creates a

00:26:32,059 --> 00:26:39,980
shorter signature so if you really need

00:26:35,660 --> 00:26:42,890
that and that you're only concerned go

00:26:39,980 --> 00:26:45,920
for that if you need more information

00:26:42,890 --> 00:26:48,650
about cryptography please you have

00:26:45,920 --> 00:26:50,270
scores increase that are very good on

00:26:48,650 --> 00:26:54,110
that

00:26:50,270 --> 00:26:56,210
how to block tokens yeah that's a very

00:26:54,110 --> 00:27:00,710
good question because once the token was

00:26:56,210 --> 00:27:05,810
created it's there because there's no

00:27:00,710 --> 00:27:09,740
way to know if it's oaken I was created

00:27:05,810 --> 00:27:13,460
by up by this thing in and it will

00:27:09,740 --> 00:27:15,290
basically not work anymore you don't

00:27:13,460 --> 00:27:19,160
have the information of the token so

00:27:15,290 --> 00:27:23,630
what we do is we use the JSON token ID

00:27:19,160 --> 00:27:24,230
to set the identifier and if we want to

00:27:23,630 --> 00:27:28,610
okay

00:27:24,230 --> 00:27:29,180
this token is not it cannot be used

00:27:28,610 --> 00:27:34,310
anymore

00:27:29,180 --> 00:27:38,000
even though it is it's not expired so we

00:27:34,310 --> 00:27:43,550
get the token ID and we create a

00:27:38,000 --> 00:27:46,370
blacklist you can use a cash system to

00:27:43,550 --> 00:27:49,850
use that setting like teaching the time

00:27:46,370 --> 00:27:53,090
to leave of the cache entry will be the

00:27:49,850 --> 00:27:55,310
same amount of exploration so the cache

00:27:53,090 --> 00:27:58,400
will do the cleanup for you you don't

00:27:55,310 --> 00:28:01,210
need to worry about that you can also

00:27:58,400 --> 00:28:05,840
create using the library that I've shown

00:28:01,210 --> 00:28:13,820
the accustomed constraint to see okay is

00:28:05,840 --> 00:28:17,840
this token ID in my blacklist or not how

00:28:13,820 --> 00:28:20,870
much data can I use in the token yeah

00:28:17,840 --> 00:28:22,700
because you can just put everything in

00:28:20,870 --> 00:28:24,950
there right

00:28:22,700 --> 00:28:29,270
but the problem is your string will be

00:28:24,950 --> 00:28:32,810
very very big if you're using a JSON web

00:28:29,270 --> 00:28:36,110
token for sessions for example you have

00:28:32,810 --> 00:28:41,170
a limit on your cookie it's not that big

00:28:36,110 --> 00:28:44,450
so you must be aware that everything

00:28:41,170 --> 00:28:48,640
that you store there will impact on the

00:28:44,450 --> 00:28:48,640
size so be cautious on that

00:28:49,650 --> 00:28:56,740
another question that I often get is how

00:28:52,300 --> 00:29:01,990
to secure the token because it's not an

00:28:56,740 --> 00:29:04,630
encrypted thing basically you can verify

00:29:01,990 --> 00:29:10,810
the signature but you cannot say okay I

00:29:04,630 --> 00:29:14,920
want to to protect the data who was on

00:29:10,810 --> 00:29:19,440
yesterday's talk about hotel so you saw

00:29:14,920 --> 00:29:23,080
the idea of JSON web encryptions right

00:29:19,440 --> 00:29:25,390
the idea is basically you have the same

00:29:23,080 --> 00:29:28,900
structure are kind of the same structure

00:29:25,390 --> 00:29:32,050
as JSON web token but for an encrypted

00:29:28,900 --> 00:29:35,650
object so you have instead of three

00:29:32,050 --> 00:29:37,150
pieces you have five and you have each

00:29:35,650 --> 00:29:39,790
part saying okay

00:29:37,150 --> 00:29:42,520
this is the header this is my ciphertext

00:29:39,790 --> 00:29:46,480
this is the encrypted text you have

00:29:42,520 --> 00:29:51,580
everything that is needed to know okay

00:29:46,480 --> 00:29:56,440
how should I decrease this piece of

00:29:51,580 --> 00:30:01,420
string and you can also say okay encrypt

00:29:56,440 --> 00:30:03,670
these token the header will be basically

00:30:01,420 --> 00:30:06,790
saying okay the content type that I have

00:30:03,670 --> 00:30:11,500
here is a token instead of application

00:30:06,790 --> 00:30:14,500
JSON or any other thing and then only

00:30:11,500 --> 00:30:18,610
people that knows how to decrypt and has

00:30:14,500 --> 00:30:21,930
access to all the keys are needed to

00:30:18,610 --> 00:30:26,890
decrypt the token will be able to

00:30:21,930 --> 00:30:33,660
consume it right Wow

00:30:26,890 --> 00:30:41,250
I was a bit too sad haha okay so

00:30:33,660 --> 00:30:45,400
questions yes good very interesting huh

00:30:41,250 --> 00:30:48,540
so put it in an actual usable example

00:30:45,400 --> 00:30:53,440
you've got a web page on that web page

00:30:48,540 --> 00:30:55,840
you've got three bits of JavaScript that

00:30:53,440 --> 00:30:58,490
need to make three Ajax requests to pull

00:30:55,840 --> 00:31:01,220
data back show grants or whatever

00:30:58,490 --> 00:31:04,429
for that when that page load you need to

00:31:01,220 --> 00:31:07,220
somehow load in three different tokens

00:31:04,429 --> 00:31:10,910
for each request is that correct it

00:31:07,220 --> 00:31:13,550
depends if you want you can create three

00:31:10,910 --> 00:31:15,950
different tokens so the token will be

00:31:13,550 --> 00:31:19,370
the identifier for each request or you

00:31:15,950 --> 00:31:22,910
can use a single token that has a like a

00:31:19,370 --> 00:31:25,520
bigger expiration so you can play around

00:31:22,910 --> 00:31:27,770
with a single one it's up for you see

00:31:25,520 --> 00:31:30,500
you in that case you could just send the

00:31:27,770 --> 00:31:33,190
singular identify token and then have

00:31:30,500 --> 00:31:35,510
additional request based parameters

00:31:33,190 --> 00:31:38,590
appended on to say the get request would

00:31:35,510 --> 00:31:41,179
that be correct or - sorry can you

00:31:38,590 --> 00:31:43,460
relate it if you're making a get request

00:31:41,179 --> 00:31:44,720
mm-hmm you might in a traditional get

00:31:43,460 --> 00:31:48,110
request without JWT

00:31:44,720 --> 00:31:51,590
you might for some reason put like user

00:31:48,110 --> 00:31:54,559
ID again etc you know I want to get this

00:31:51,590 --> 00:31:56,660
data for this graph sort of thing could

00:31:54,559 --> 00:31:59,720
you what you're saying is if you have

00:31:56,660 --> 00:32:02,330
one token instead of that user ID as

00:31:59,720 --> 00:32:04,580
they identify you have a token and then

00:32:02,330 --> 00:32:06,710
your parameters afterwards to say I want

00:32:04,580 --> 00:32:09,110
to actually get this data got that

00:32:06,710 --> 00:32:13,490
correct yeah okay you can you can use

00:32:09,110 --> 00:32:16,160
other way the benefit of it is that you

00:32:13,490 --> 00:32:20,600
know when the data change because you

00:32:16,160 --> 00:32:24,410
have a signature there but since the

00:32:20,600 --> 00:32:27,650
signature are the content was created by

00:32:24,410 --> 00:32:30,140
a JavaScript client I'm assuming that

00:32:27,650 --> 00:32:34,100
faded on the conversation the Java

00:32:30,140 --> 00:32:36,740
Script must also have the private key in

00:32:34,100 --> 00:32:39,590
order to generate tokens if you are

00:32:36,740 --> 00:32:41,780
creating the the keys on the server side

00:32:39,590 --> 00:32:46,970
and just rendering them then it's fine

00:32:41,780 --> 00:32:49,429
you can just use them so when I have

00:32:46,970 --> 00:32:53,630
traditional sessions currently and I

00:32:49,429 --> 00:32:55,070
want to migrate them over to j WT do you

00:32:53,630 --> 00:32:57,080
have any best practices for that or

00:32:55,070 --> 00:33:02,690
should I just start over and sign out

00:32:57,080 --> 00:33:04,309
all users iOS you think application with

00:33:02,690 --> 00:33:08,330
rational sessions and I were to start

00:33:04,309 --> 00:33:09,660
Jade ability okay so if you go I'll just

00:33:08,330 --> 00:33:12,729
go back

00:33:09,660 --> 00:33:12,729
[Music]

00:33:15,430 --> 00:33:22,970
here to go to that page you will see all

00:33:19,310 --> 00:33:28,460
the limitations that we have and that we

00:33:22,970 --> 00:33:32,390
must understand because as I said the

00:33:28,460 --> 00:33:35,210
token is not encrypted by default and to

00:33:32,390 --> 00:33:38,630
encrypt it it requires some processing

00:33:35,210 --> 00:33:42,640
power right and now also to decrypt you

00:33:38,630 --> 00:33:46,000
you'll have to have this delay so maybe

00:33:42,640 --> 00:33:50,900
increasing as a session data is not

00:33:46,000 --> 00:33:56,720
really interesting so the token will be

00:33:50,900 --> 00:33:59,300
plain you can use and yeah the other

00:33:56,720 --> 00:34:02,090
limitations is that this library it

00:33:59,300 --> 00:34:05,330
doesn't create any blacklist so if the

00:34:02,090 --> 00:34:10,190
session data change you or the want to

00:34:05,330 --> 00:34:12,380
revoke the previews token so this is the

00:34:10,190 --> 00:34:15,980
kind of best practice that you need to

00:34:12,380 --> 00:34:19,520
to to take into consideration like okay

00:34:15,980 --> 00:34:23,560
I want to use a stateless or storage

00:34:19,520 --> 00:34:29,330
storage list session but I need to know

00:34:23,560 --> 00:34:33,740
what what I'm like all the details that

00:34:29,330 --> 00:34:37,429
are required in order to not make my

00:34:33,740 --> 00:34:40,550
application not so safe and secure

00:34:37,429 --> 00:34:46,940
alright so if you care about all this

00:34:40,550 --> 00:34:51,530
kind of thing things I would say that go

00:34:46,940 --> 00:34:54,530
with a normal session because if you're

00:34:51,530 --> 00:34:56,570
storing important data inside of the

00:34:54,530 --> 00:35:08,030
token you will compromise your security

00:34:56,570 --> 00:35:10,760
okay thank you so I get the impression

00:35:08,030 --> 00:35:13,820
that the you should only use this if you

00:35:10,760 --> 00:35:17,000
actually need to store some data instead

00:35:13,820 --> 00:35:20,480
how your tape token because otherwise if

00:35:17,000 --> 00:35:22,460
it did it is more secure if you have all

00:35:20,480 --> 00:35:23,840
your data in your data based on you just

00:35:22,460 --> 00:35:28,330
use an awesome

00:35:23,840 --> 00:35:31,310
and don't expose any data to the client

00:35:28,330 --> 00:35:34,460
usually you don't have any problem on

00:35:31,310 --> 00:35:37,070
exposing the expiration date or the date

00:35:34,460 --> 00:35:39,530
that token was issued the youth ready a

00:35:37,070 --> 00:35:42,080
little yeah and also

00:35:39,530 --> 00:35:44,570
yeah the user IDs like yeah what the

00:35:42,080 --> 00:35:48,170
user can do with a user ID yeah but if

00:35:44,570 --> 00:35:52,540
you stored the user email in a token

00:35:48,170 --> 00:35:52,540
then my friend you have a problem yeah

00:35:57,310 --> 00:36:01,400
so good that time we're having so many

00:36:00,290 --> 00:36:03,530
questions hi yeah

00:36:01,400 --> 00:36:05,300
and I suppose one of the biggest

00:36:03,530 --> 00:36:07,400
benefits of JWT is you no longer have to

00:36:05,300 --> 00:36:11,390
store like in your database a massive

00:36:07,400 --> 00:36:14,150
list of tokens yeah and but one thing

00:36:11,390 --> 00:36:16,360
that you said that you can sort of

00:36:14,150 --> 00:36:18,650
create a blacklist so if one of my users

00:36:16,360 --> 00:36:20,450
their accounts compromised or whatever

00:36:18,650 --> 00:36:24,050
and they need to blacklist surely I

00:36:20,450 --> 00:36:28,220
still need to store a list of token IDs

00:36:24,050 --> 00:36:33,310
in my database so I know which ones the

00:36:28,220 --> 00:36:37,430
blacklist yeah yeah this is like a

00:36:33,310 --> 00:36:40,100
trade-off if you want to use this kind

00:36:37,430 --> 00:36:44,660
of silk'n to create an authorization in

00:36:40,100 --> 00:36:46,820
an authentication flow and you really

00:36:44,660 --> 00:36:50,300
need to block tokens you have to source

00:36:46,820 --> 00:36:53,810
something somewhere because how you will

00:36:50,300 --> 00:36:59,180
know that this token needs to be

00:36:53,810 --> 00:37:02,240
blacklisted or not so are if the user is

00:36:59,180 --> 00:37:05,060
logged on multiple places and you want

00:37:02,240 --> 00:37:08,180
to blacklist them all so you need to

00:37:05,060 --> 00:37:13,550
have this o at least the IDS of every

00:37:08,180 --> 00:37:15,650
single token you you created but there's

00:37:13,550 --> 00:37:20,000
a difference on storing just the ID and

00:37:15,650 --> 00:37:28,850
the whole data so that's the trade-off

00:37:20,000 --> 00:37:33,040
that you need to do so I was listening

00:37:28,850 --> 00:37:37,690
about them assigning so

00:37:33,040 --> 00:37:40,450
is having the the public key to sign the

00:37:37,690 --> 00:37:45,780
client aside the request isn't there any

00:37:40,450 --> 00:37:49,210
type of problem on them if someone's

00:37:45,780 --> 00:37:53,290
stills my signing key that I get

00:37:49,210 --> 00:37:55,630
compromised if some well the signing key

00:37:53,290 --> 00:38:00,060
will be the private not at public but if

00:37:55,630 --> 00:38:02,560
somebody I have access to your privately

00:38:00,060 --> 00:38:06,040
key you have a bigger problem than just

00:38:02,560 --> 00:38:10,210
the token right I was talking about the

00:38:06,040 --> 00:38:13,060
the client signing the request for the

00:38:10,210 --> 00:38:17,560
server maybe I don't know if I hadn't

00:38:13,060 --> 00:38:19,780
stood usually record usually you just

00:38:17,560 --> 00:38:23,650
sign the token on at the time that

00:38:19,780 --> 00:38:26,740
you're issuing it so if you want to have

00:38:23,650 --> 00:38:29,860
like we had yesterday the use case where

00:38:26,740 --> 00:38:33,100
the both requests and response are

00:38:29,860 --> 00:38:36,730
signed and they are signed by different

00:38:33,100 --> 00:38:38,800
issues then you have the private key and

00:38:36,730 --> 00:38:41,230
the public here and the private key and

00:38:38,800 --> 00:38:46,420
a public key here and they don't have

00:38:41,230 --> 00:38:49,690
they're not the same so when the client

00:38:46,420 --> 00:38:53,500
is create a new token it says okay I'm

00:38:49,690 --> 00:38:54,360
creating the token with these ID this

00:38:53,500 --> 00:38:58,960
key sorry

00:38:54,360 --> 00:39:04,840
and this key ID represents a public key

00:38:58,960 --> 00:39:09,250
and the server will validate that token

00:39:04,840 --> 00:39:13,810
using the client public key and if the

00:39:09,250 --> 00:39:16,930
client wants to validate your the token

00:39:13,810 --> 00:39:19,390
that will generate it on the the server

00:39:16,930 --> 00:39:22,570
side you it will use the public key of

00:39:19,390 --> 00:39:25,050
the server so nobody knows about the

00:39:22,570 --> 00:39:25,050
private one

00:39:30,620 --> 00:39:38,190
for for token invalidation this might be

00:39:35,040 --> 00:39:41,010
a terrible idea please tell if it is we

00:39:38,190 --> 00:39:43,590
do a way to handle that BT store instead

00:39:41,010 --> 00:39:46,080
of storing a blacklist to store a white

00:39:43,590 --> 00:39:48,330
list of all the IDS of tokens that have

00:39:46,080 --> 00:39:51,240
been issued in say something like read

00:39:48,330 --> 00:39:53,910
it so that then they expire when the

00:39:51,240 --> 00:39:57,000
token is set to expire and then to be

00:39:53,910 --> 00:39:59,490
able to blacklist something as Aleta out

00:39:57,000 --> 00:39:59,820
the white list yeah that works fine as

00:39:59,490 --> 00:40:02,610
well

00:39:59,820 --> 00:40:04,830
the only difference is you probably end

00:40:02,610 --> 00:40:07,140
up with more tokens on the white list

00:40:04,830 --> 00:40:17,250
and the black place but yeah it's

00:40:07,140 --> 00:40:20,460
perfect thank you no in that case you

00:40:17,250 --> 00:40:22,620
wouldn't have that problem because you

00:40:20,460 --> 00:40:28,800
like every token you issue

00:40:22,620 --> 00:40:33,420
uoh you put the ID in in Redis and it

00:40:28,800 --> 00:40:35,160
will expire in some minutes so you

00:40:33,420 --> 00:40:39,390
already have the expiration and that's

00:40:35,160 --> 00:40:41,100
granted for on the cash system so when

00:40:39,390 --> 00:40:44,250
the token expires you don't have the

00:40:41,100 --> 00:40:47,040
white list there anymore the validation

00:40:44,250 --> 00:40:50,220
will be is my token there okay so I'm

00:40:47,040 --> 00:40:53,400
safe instead of is my token blacklist

00:40:50,220 --> 00:41:12,660
okay you you're not allowed to use it so

00:40:53,400 --> 00:41:16,230
yeah it works fine now okay yes yeah I

00:41:12,660 --> 00:41:18,450
know I guess I've stood the ID with with

00:41:16,230 --> 00:41:21,740
the token in Redis so like to look it up

00:41:18,450 --> 00:41:21,740
and young like this yeah

00:41:24,430 --> 00:41:31,300
how would you deal with wind tokens

00:41:29,500 --> 00:41:35,590
expire when they were at time the expiry

00:41:31,300 --> 00:41:38,410
date passed would you on the client-side

00:41:35,590 --> 00:41:42,190
on on the chilled your website would you

00:41:38,410 --> 00:41:43,990
literally mostly just say I don't know

00:41:42,190 --> 00:41:46,840
when is to expires because it's

00:41:43,990 --> 00:41:48,880
encrypted inside so I can't find out

00:41:46,840 --> 00:41:52,000
when it expires but I'll try and use it

00:41:48,880 --> 00:41:54,100
and then circumspect you have to say

00:41:52,000 --> 00:41:56,350
okay observe comes back says sorry this

00:41:54,100 --> 00:41:59,650
took is another anymore as we make

00:41:56,350 --> 00:42:00,400
another request or could you say on the

00:41:59,650 --> 00:42:03,790
server side

00:42:00,400 --> 00:42:05,950
well this cousin is good until midday

00:42:03,790 --> 00:42:08,590
two more bits now I let it clock I'll

00:42:05,950 --> 00:42:10,030
give the new token that will be good for

00:42:08,590 --> 00:42:13,150
some more time

00:42:10,030 --> 00:42:16,180
yeah that's up to you because the token

00:42:13,150 --> 00:42:17,950
is not encrypted it's encoded and you

00:42:16,180 --> 00:42:20,890
have JavaScript libraries to read its

00:42:17,950 --> 00:42:27,370
opening and you can see the expiration

00:42:20,890 --> 00:42:31,270
date so yeah if the client doesn't want

00:42:27,370 --> 00:42:33,730
to to open a token and to read it it

00:42:31,270 --> 00:42:37,690
rose to just say okay the token is

00:42:33,730 --> 00:42:41,650
invalid or you can do what you're saying

00:42:37,690 --> 00:42:44,110
okay your request is valid but in five

00:42:41,650 --> 00:42:47,590
minutes the token will expire so here's

00:42:44,110 --> 00:42:49,390
my new token I will I created that so

00:42:47,590 --> 00:42:53,770
you don't need to bother with refresh

00:42:49,390 --> 00:42:56,940
refresh in the token but when it expires

00:42:53,770 --> 00:43:00,100
and the client didn't request anything

00:42:56,940 --> 00:43:03,070
in order for the server to to create a

00:43:00,100 --> 00:43:05,620
new token it will be expired and period

00:43:03,070 --> 00:43:08,470
otherwise you're also compromising the

00:43:05,620 --> 00:43:11,110
security of your API because if you use

00:43:08,470 --> 00:43:13,330
the tokens of bearer token to says it's

00:43:11,110 --> 00:43:18,250
something that you gave me although

00:43:13,330 --> 00:43:21,970
somebody gave me is this you have to

00:43:18,250 --> 00:43:23,680
truck it bearer token is was given to

00:43:21,970 --> 00:43:27,040
the right person and has been shared

00:43:23,680 --> 00:43:29,620
around yeah so if you then upgraded that

00:43:27,040 --> 00:43:32,610
token that is a potential security issue

00:43:29,620 --> 00:43:35,950
because you don't necessarily know they

00:43:32,610 --> 00:43:38,230
Chinle would give them the token yeah

00:43:35,950 --> 00:43:40,420
but that happens despite of JSON

00:43:38,230 --> 00:43:42,820
tokens we though off you have a bearer

00:43:40,420 --> 00:43:45,810
token as well and you can share that

00:43:42,820 --> 00:43:48,810
soaking them wrong and do new requests

00:43:45,810 --> 00:43:48,810
yeah

00:43:51,060 --> 00:43:54,840
any other question

00:43:56,609 --> 00:44:06,250
all right so oh here

00:44:00,730 --> 00:44:08,950
sorry do you have somewhere I can go

00:44:06,250 --> 00:44:12,460
we're able to have a list of libraries

00:44:08,950 --> 00:44:23,740
you can use together with this yep this

00:44:12,460 --> 00:44:29,470
website here just this one chisel JWT

00:44:23,740 --> 00:44:33,600
dot IO you can just see libraries

00:44:29,470 --> 00:44:33,600
implemented in all sorts of languages

00:44:39,240 --> 00:44:46,930
now there's another question there I

00:44:41,830 --> 00:44:50,619
think what's the significance of the S

00:44:46,930 --> 00:44:57,160
the low three-letter acronyms sorry like

00:44:50,619 --> 00:45:01,500
this sub an AED IET okay are the acronym

00:44:57,160 --> 00:45:08,560
yeah the idea was to have a compact

00:45:01,500 --> 00:45:13,240
representation so jason token ID issuer

00:45:08,560 --> 00:45:18,640
audience subject issued at expires and

00:45:13,240 --> 00:45:29,200
not before the next chunk there's

00:45:18,640 --> 00:45:31,840
another so maybe them in question but um

00:45:29,200 --> 00:45:34,930
what's the best practice for example

00:45:31,840 --> 00:45:37,600
i've logged in in one tab like generated

00:45:34,930 --> 00:45:40,240
token and then i open in anonymous tab

00:45:37,600 --> 00:45:42,460
for example should i detect wait you

00:45:40,240 --> 00:45:44,920
still have a little can just reuse it or

00:45:42,460 --> 00:45:47,680
should I create every single time if it

00:45:44,920 --> 00:45:50,590
what is the users authenticate generates

00:45:47,680 --> 00:45:51,810
a new token you you're basically talking

00:45:50,590 --> 00:45:54,210
about the

00:45:51,810 --> 00:45:57,680
- science right JavaScript or declines

00:45:54,210 --> 00:46:00,750
oxide and the API

00:45:57,680 --> 00:46:02,850
yeah the API must receive a request in

00:46:00,750 --> 00:46:05,970
order to to know if the token was used

00:46:02,850 --> 00:46:08,430
or not so if the token is stored in the

00:46:05,970 --> 00:46:12,140
local storage the API doesn't know

00:46:08,430 --> 00:46:16,850
unless we have a request right yeah so

00:46:12,140 --> 00:46:20,850
I'm not sure but I think that on

00:46:16,850 --> 00:46:25,110
anonymous tab the normal tab they don't

00:46:20,850 --> 00:46:27,180
share the local storage to dead Teddy so

00:46:25,110 --> 00:46:29,850
for example I generated a new I'm

00:46:27,180 --> 00:46:32,940
logging in basically on two different

00:46:29,850 --> 00:46:35,010
computers on okay should I try and reuse

00:46:32,940 --> 00:46:38,010
the same token or generate a new one

00:46:35,010 --> 00:46:40,620
every single login if you always you

00:46:38,010 --> 00:46:42,990
always use the same token you have a

00:46:40,620 --> 00:46:45,990
security issue because someone can just

00:46:42,990 --> 00:46:48,660
gather token and use it because yeah

00:46:45,990 --> 00:46:51,420
it's there and it's JavaScript it's it

00:46:48,660 --> 00:46:54,030
and just read the token get it so I

00:46:51,420 --> 00:46:58,110
wouldn't recommend to reuse your token

00:46:54,030 --> 00:47:00,950
if you're logging uh and yeah just

00:46:58,110 --> 00:47:04,860
create a new token for that session and

00:47:00,950 --> 00:47:09,600
make that expires like in few moments

00:47:04,860 --> 00:47:13,160
like 20 minutes at most so and also have

00:47:09,600 --> 00:47:18,990
a way to refresh a token all these

00:47:13,160 --> 00:47:21,900
refreshing mechanisms and granting

00:47:18,990 --> 00:47:26,340
mechanisms are already covered by ooofff

00:47:21,900 --> 00:47:29,820
so you can use OAuth creating a access

00:47:26,340 --> 00:47:32,460
tokens with JSON web tokens and just use

00:47:29,820 --> 00:47:34,440
it it's nice because then you can store

00:47:32,460 --> 00:47:36,360
things into the token and you can read

00:47:34,440 --> 00:47:43,290
on the client-side and present some

00:47:36,360 --> 00:47:47,850
information if you want no more

00:47:43,290 --> 00:47:50,900
questions all right guys thank you very

00:47:47,850 --> 00:47:50,900

YouTube URL: https://www.youtube.com/watch?v=p2tItlr_3QI


