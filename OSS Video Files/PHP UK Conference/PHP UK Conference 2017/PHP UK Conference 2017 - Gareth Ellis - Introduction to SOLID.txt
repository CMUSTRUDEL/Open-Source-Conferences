Title: PHP UK Conference 2017 - Gareth Ellis - Introduction to SOLID
Publication date: 2017-04-03
Playlist: PHP UK Conference 2017
Description: 
	It is pretty common to hear people talk about "SOLID code" in talks, blogs and podcasts these days. For the object-oriented programming novice who hears this term for the first time, the Wikipedia article gives a high-level overview, but advice and information about what ""SOLID"" really means on a practical level can be hard to come across. This talk aims to clarify what the SOLID principles are and how you can apply them in your work, with the aim of producing easier-to-maintain, de-coupled code with fewer smells. I'll show you PHP examples of each of the five SOLID principles, talk about when and how to implement them in your applications and give you a few other hints about ways you can improve your OOP design.
Captions: 
	00:00:03,360 --> 00:00:10,950
good afternoon everybody my name is

00:00:07,200 --> 00:00:13,590
Gareth Ellis and I'm a developer at the

00:00:10,950 --> 00:00:16,590
in the language services group at a

00:00:13,590 --> 00:00:18,650
company called icon I'm also the lead

00:00:16,590 --> 00:00:21,210
organizer of the PHP Oxford user group

00:00:18,650 --> 00:00:22,859
so if you're ever in the Oxford area on

00:00:21,210 --> 00:00:25,739
the last Wednesday of the month we'd

00:00:22,859 --> 00:00:27,569
love to see that so I'm going to talk to

00:00:25,739 --> 00:00:30,119
you this afternoon about the solid

00:00:27,569 --> 00:00:32,279
principles and I created this talk

00:00:30,119 --> 00:00:34,829
because I felt that it was content that

00:00:32,279 --> 00:00:37,980
I couldn't find when I was a relative

00:00:34,829 --> 00:00:40,019
novice to object-oriented programming so

00:00:37,980 --> 00:00:41,519
the talk is pitched at those of you who

00:00:40,019 --> 00:00:43,710
have maybe heard of the solid principles

00:00:41,519 --> 00:00:45,359
and know vaguely what they are at a high

00:00:43,710 --> 00:00:47,399
level but you're unsure how you can

00:00:45,359 --> 00:00:49,440
actually apply them practically in your

00:00:47,399 --> 00:00:50,940
day to day and for those people who've

00:00:49,440 --> 00:00:57,559
never come across the solid principles

00:00:50,940 --> 00:01:01,399
at all the solid principles are five

00:00:57,559 --> 00:01:03,870
guidelines for object-oriented design

00:01:01,399 --> 00:01:06,300
they were first formulated in the late

00:01:03,870 --> 00:01:08,850
90s under the name the first five

00:01:06,300 --> 00:01:10,950
principles by a developer called Robert

00:01:08,850 --> 00:01:14,340
Martin who some of you may know may know

00:01:10,950 --> 00:01:15,420
as Uncle Bob and then in the early 2000s

00:01:14,340 --> 00:01:16,830
another developer called Michael

00:01:15,420 --> 00:01:19,470
feathers came up with this acronym

00:01:16,830 --> 00:01:22,110
solids that we use today to describe

00:01:19,470 --> 00:01:24,420
these principles together and the idea

00:01:22,110 --> 00:01:27,420
is that when you apply all of the solid

00:01:24,420 --> 00:01:28,830
principles together to your code it will

00:01:27,420 --> 00:01:32,520
result in code which is easier to

00:01:28,830 --> 00:01:36,600
maintain easier to read easier to extend

00:01:32,520 --> 00:01:39,720
and easier to reason about so what does

00:01:36,600 --> 00:01:41,400
reason about me because I think when I

00:01:39,720 --> 00:01:43,860
first heard that phrase I just assumed

00:01:41,400 --> 00:01:46,980
it meant understand but I think it's

00:01:43,860 --> 00:01:48,510
subtly different from understanding code

00:01:46,980 --> 00:01:50,130
that we can understand this code that we

00:01:48,510 --> 00:01:51,810
can look at we might have to ask a

00:01:50,130 --> 00:01:54,180
colleague to help explain what it does

00:01:51,810 --> 00:01:55,680
remind go and read documentation after

00:01:54,180 --> 00:01:58,020
those steps we might arrive at

00:01:55,680 --> 00:02:00,120
understanding the code or as codes

00:01:58,020 --> 00:02:02,040
that's easy to reason about these codes

00:02:00,120 --> 00:02:03,300
that you can just look at you can just

00:02:02,040 --> 00:02:06,180
understand it because it's

00:02:03,300 --> 00:02:07,650
self-explanatory it's clear and I think

00:02:06,180 --> 00:02:10,399
that's a really worthwhile goal of any

00:02:07,650 --> 00:02:10,399
code that we write

00:02:11,170 --> 00:02:14,540
solid principles are about

00:02:13,010 --> 00:02:17,510
object-oriented programming in general

00:02:14,540 --> 00:02:19,040
they're not about PHP weeds bear this in

00:02:17,510 --> 00:02:25,370
mind when we interpret the wording of

00:02:19,040 --> 00:02:26,720
these guidelines when you're trying to

00:02:25,370 --> 00:02:29,690
apply solid to your work

00:02:26,720 --> 00:02:30,500
the goal is not adherence to the goals

00:02:29,690 --> 00:02:32,660
themselves

00:02:30,500 --> 00:02:36,920
there's no gold star this achievement

00:02:32,660 --> 00:02:38,840
doesn't exist as software developers we

00:02:36,920 --> 00:02:40,790
should all know that every decision we

00:02:38,840 --> 00:02:43,010
make has a trade-off or trade-offs

00:02:40,790 --> 00:02:44,600
plural and we need to be aware of what

00:02:43,010 --> 00:02:46,330
those trade-offs are at every point and

00:02:44,600 --> 00:02:49,400
you may come across the quotations when

00:02:46,330 --> 00:02:51,830
the trade-off for not applying solid to

00:02:49,400 --> 00:02:53,120
your work is worth it it's up to us to

00:02:51,830 --> 00:02:55,400
know those trade-offs and to be able to

00:02:53,120 --> 00:03:00,260
make informed decisions for our use

00:02:55,400 --> 00:03:02,690
cases you will find that writing solid

00:03:00,260 --> 00:03:06,190
code means you are writing more code

00:03:02,690 --> 00:03:09,050
full-stop I think this is okay because

00:03:06,190 --> 00:03:12,050
as developers we spend way more time

00:03:09,050 --> 00:03:14,390
reading code than we do writing I think

00:03:12,050 --> 00:03:16,550
we can all relate to the idea of working

00:03:14,390 --> 00:03:18,590
on a problem writing code and mean right

00:03:16,550 --> 00:03:20,090
in the headspace of that problem right

00:03:18,590 --> 00:03:22,130
in that context having all the

00:03:20,090 --> 00:03:24,290
information around us and we write code

00:03:22,130 --> 00:03:26,930
then we come back to it a week later and

00:03:24,290 --> 00:03:28,370
we look at it and we gable I'm not

00:03:26,930 --> 00:03:30,140
really sure what I was doing there that

00:03:28,370 --> 00:03:31,519
doesn't make sense to me and that's

00:03:30,140 --> 00:03:33,200
because we've optimized for writing

00:03:31,519 --> 00:03:34,610
we've optimized for saving a few

00:03:33,200 --> 00:03:36,230
keystrokes instead of making sure that

00:03:34,610 --> 00:03:42,350
our code is easy to read and easy to

00:03:36,230 --> 00:03:44,060
reason about so on with the five

00:03:42,350 --> 00:03:47,390
principles and the first of them as you

00:03:44,060 --> 00:03:50,800
may guess is the s and that is the

00:03:47,390 --> 00:03:53,570
single responsibility principle or SRP

00:03:50,800 --> 00:03:56,600
SRP states that a class should have a

00:03:53,570 --> 00:04:00,070
single well-defined purpose or more

00:03:56,600 --> 00:04:04,100
specifically it has one reason to change

00:04:00,070 --> 00:04:05,600
so what's a reason to change well in my

00:04:04,100 --> 00:04:08,090
opinion a reason to change is something

00:04:05,600 --> 00:04:11,120
which can possibly drive a change

00:04:08,090 --> 00:04:12,380
somewhere in your code so for example if

00:04:11,120 --> 00:04:14,780
you have a class which deals with

00:04:12,380 --> 00:04:16,549
talking to the database the only reason

00:04:14,780 --> 00:04:17,810
for that class to change would be if you

00:04:16,549 --> 00:04:19,280
change something about the way you're

00:04:17,810 --> 00:04:22,270
talking to the database so you're going

00:04:19,280 --> 00:04:22,270
to change a query for example

00:04:23,090 --> 00:04:28,169
classes shouldn't get ideas about their

00:04:25,259 --> 00:04:30,150
station the could rule of thumb is that

00:04:28,169 --> 00:04:32,099
you could try to define the purpose for

00:04:30,150 --> 00:04:35,069
your class in a single sentence without

00:04:32,099 --> 00:04:37,530
using the word and or all and if you

00:04:35,069 --> 00:04:41,460
can't do that your class might be doing

00:04:37,530 --> 00:04:42,840
too much in my experience and certainly

00:04:41,460 --> 00:04:46,349
an experience of applications that I

00:04:42,840 --> 00:04:49,110
have written in the past controllers in

00:04:46,349 --> 00:04:51,720
MVC applications tend to be quite big

00:04:49,110 --> 00:04:53,129
violators of this principle so here's

00:04:51,720 --> 00:04:55,139
some code I have completely made up for

00:04:53,129 --> 00:04:56,550
the purposes of this talk but hopefully

00:04:55,139 --> 00:04:58,009
it will seem familiar to some of you

00:04:56,550 --> 00:05:00,479
have worked on applications of this type

00:04:58,009 --> 00:05:02,039
fairly common function for a lot of

00:05:00,479 --> 00:05:05,699
applications is to have a method for

00:05:02,039 --> 00:05:07,590
users to register so here we have a user

00:05:05,699 --> 00:05:09,180
registration controller I have a method

00:05:07,590 --> 00:05:12,300
put register and we're passing in a

00:05:09,180 --> 00:05:13,879
request than a response object so what's

00:05:12,300 --> 00:05:16,469
the controller's reason to change

00:05:13,879 --> 00:05:18,300
controllers concern should only really

00:05:16,469 --> 00:05:20,490
be with control flow it's called a

00:05:18,300 --> 00:05:22,199
controller for a reason the job as a

00:05:20,490 --> 00:05:23,849
controller is to take the request and

00:05:22,199 --> 00:05:25,560
return a response and that might involve

00:05:23,849 --> 00:05:27,659
talking to the domain or the model or

00:05:25,560 --> 00:05:30,300
whatever you want to call it in between

00:05:27,659 --> 00:05:32,279
but it's very easy to stuff business

00:05:30,300 --> 00:05:36,210
logic into our controllers and make them

00:05:32,279 --> 00:05:38,099
bloated so in this example we've got a

00:05:36,210 --> 00:05:40,919
user that we're creating from request

00:05:38,099 --> 00:05:42,210
data for making an entity we're then

00:05:40,919 --> 00:05:44,310
going to save it in the database in the

00:05:42,210 --> 00:05:46,380
controller so we've got some SQL in the

00:05:44,310 --> 00:05:48,060
middle of our controller we're then

00:05:46,380 --> 00:05:49,560
going to send a welcome email to the

00:05:48,060 --> 00:05:51,719
user saying hey thanks for registering

00:05:49,560 --> 00:05:54,389
and then we're going to return a

00:05:51,719 --> 00:05:55,949
response so this controller has got

00:05:54,389 --> 00:05:57,419
several reasons to change right here

00:05:55,949 --> 00:05:59,490
because it's dealing with logic to do

00:05:57,419 --> 00:06:01,440
with the database dealing with logic do

00:05:59,490 --> 00:06:04,860
sending emails and it's got to do its

00:06:01,440 --> 00:06:07,050
job as a controller as well so the first

00:06:04,860 --> 00:06:08,879
step to refactoring this would be to

00:06:07,050 --> 00:06:10,229
move that logic into a separate class so

00:06:08,879 --> 00:06:13,469
you could call this a service class if

00:06:10,229 --> 00:06:16,529
you like I've named it user registration

00:06:13,469 --> 00:06:18,150
here and what we're going to use this

00:06:16,529 --> 00:06:19,800
for is that instead of stuffing that

00:06:18,150 --> 00:06:22,379
logic into the controller the controller

00:06:19,800 --> 00:06:24,449
will talk to this service class so the

00:06:22,379 --> 00:06:26,879
controller knows I am a controller

00:06:24,449 --> 00:06:28,440
method that is used when user registers

00:06:26,879 --> 00:06:30,120
I'm going to take the user I'm going to

00:06:28,440 --> 00:06:31,330
pass it to the service class and now I

00:06:30,120 --> 00:06:33,039
don't care what happens

00:06:31,330 --> 00:06:35,470
that none of my business I'm a

00:06:33,039 --> 00:06:36,849
controller so the service class will

00:06:35,470 --> 00:06:39,580
then deal with what needs to happen next

00:06:36,849 --> 00:06:41,370
so here we've got the dependencies in

00:06:39,580 --> 00:06:44,219
the constructors of a database

00:06:41,370 --> 00:06:46,599
dependency and the email dependency and

00:06:44,219 --> 00:06:48,520
we're signing into class properties and

00:06:46,599 --> 00:06:49,930
then in the register method of the

00:06:48,520 --> 00:06:52,870
service class which is the method that

00:06:49,930 --> 00:06:56,129
the controller will call we can call

00:06:52,870 --> 00:06:58,240
those same methods from the controller

00:06:56,129 --> 00:06:59,560
now we can still do a little bit to

00:06:58,240 --> 00:07:00,939
improve this because all we've done at

00:06:59,560 --> 00:07:03,940
the minute is copy and paste code from

00:07:00,939 --> 00:07:05,259
one class to another this class has more

00:07:03,940 --> 00:07:07,690
than one reason to change because it's

00:07:05,259 --> 00:07:10,810
got logic to do with saving in the

00:07:07,690 --> 00:07:13,030
database sending emails so we can

00:07:10,810 --> 00:07:14,560
refactor that further and we could move

00:07:13,030 --> 00:07:16,270
the logic to do with saving to the

00:07:14,560 --> 00:07:19,240
database to a separate class called user

00:07:16,270 --> 00:07:20,979
registration storage for example and the

00:07:19,240 --> 00:07:23,259
email logic into another class called

00:07:20,979 --> 00:07:24,400
user registration welcome email and once

00:07:23,259 --> 00:07:27,219
again we assign those two class

00:07:24,400 --> 00:07:29,259
properties and then we can call those in

00:07:27,219 --> 00:07:33,879
the register method so now this class

00:07:29,259 --> 00:07:35,680
has fewer responsibilities we could

00:07:33,879 --> 00:07:37,389
improve this further using for example

00:07:35,680 --> 00:07:38,500
the observer pattern and that's

00:07:37,389 --> 00:07:41,590
something we're going to briefly touch

00:07:38,500 --> 00:07:45,039
upon in the next section because the OU

00:07:41,590 --> 00:07:48,789
in solid stands for the open and closed

00:07:45,039 --> 00:07:51,099
principle open closed states that

00:07:48,789 --> 00:07:53,800
software entities which we can think of

00:07:51,099 --> 00:07:59,440
as classes should be open for extension

00:07:53,800 --> 00:08:00,639
but closed for modification that is we

00:07:59,440 --> 00:08:03,400
need to be able to change the behavior

00:08:00,639 --> 00:08:09,370
of a class without editing its source

00:08:03,400 --> 00:08:10,900
code or you should need to cut your

00:08:09,370 --> 00:08:16,150
chest open just to put on a different

00:08:10,900 --> 00:08:18,279
code closed for modification does not

00:08:16,150 --> 00:08:19,629
mean we should never ever change source

00:08:18,279 --> 00:08:21,940
code I think I'll jobs would be pretty

00:08:19,629 --> 00:08:26,409
difficult if that's what it meant but

00:08:21,940 --> 00:08:28,469
just as a little example how many people

00:08:26,409 --> 00:08:30,729
here had a class which is doing its job

00:08:28,469 --> 00:08:33,490
working and got any bugs that you know

00:08:30,729 --> 00:08:34,719
of and you have to change the

00:08:33,490 --> 00:08:36,610
functionality of it in some way you have

00:08:34,719 --> 00:08:38,409
to change its behavior so you make a

00:08:36,610 --> 00:08:40,349
change and then you introduce a bug

00:08:38,409 --> 00:08:42,639
grammar

00:08:40,349 --> 00:08:47,860
yeah quite a lot of people and some

00:08:42,639 --> 00:08:51,730
liars so changing code is a really

00:08:47,860 --> 00:08:54,459
common entry point for defects so if we

00:08:51,730 --> 00:08:56,170
can design upfront for extension design

00:08:54,459 --> 00:08:57,879
upfront to anticipate ways in which we

00:08:56,170 --> 00:08:59,889
might need to use our code in the future

00:08:57,879 --> 00:09:02,079
we can hopefully avoid having to make

00:08:59,889 --> 00:09:05,499
source code changes and avoid the

00:09:02,079 --> 00:09:06,699
likelihood of introducing bugs on the

00:09:05,499 --> 00:09:09,189
other hand there's always the chance

00:09:06,699 --> 00:09:11,529
that you ain't going to need it so the

00:09:09,189 --> 00:09:14,199
trade-off here is how do we work out

00:09:11,529 --> 00:09:16,360
what in what ways our classes might need

00:09:14,199 --> 00:09:19,720
to be used in the future and that takes

00:09:16,360 --> 00:09:21,160
experience it takes practice

00:09:19,720 --> 00:09:24,670
and you just need to kind of get an

00:09:21,160 --> 00:09:26,290
inkling and a feeling for what ways you

00:09:24,670 --> 00:09:28,179
might need to change things going

00:09:26,290 --> 00:09:31,660
forward so it's a fine balance between

00:09:28,179 --> 00:09:36,149
not writing too much code and closing

00:09:31,660 --> 00:09:38,529
yourself off to future future extension

00:09:36,149 --> 00:09:40,660
so open/close States the classes should

00:09:38,529 --> 00:09:44,019
be open for extension and what does that

00:09:40,660 --> 00:09:45,759
mean when I first read this as a PHP

00:09:44,019 --> 00:09:47,980
developer I immediately thought

00:09:45,759 --> 00:09:50,889
extension that derives from the word

00:09:47,980 --> 00:09:53,529
extends which is a key word in PHP it's

00:09:50,889 --> 00:09:55,209
what we use to create a subclass so I

00:09:53,529 --> 00:09:56,679
thought well okay that just means we

00:09:55,209 --> 00:09:58,239
need to be able to extend classes it's

00:09:56,679 --> 00:10:03,189
inheritance right open for extension

00:09:58,239 --> 00:10:07,679
means inheritance but solid isn't about

00:10:03,189 --> 00:10:11,559
PHP PHP does have the keyword extends

00:10:07,679 --> 00:10:13,209
PHP has inheritance but there are some

00:10:11,559 --> 00:10:14,889
object oriented languages that don't for

00:10:13,209 --> 00:10:16,660
example golang I believe doesn't have

00:10:14,889 --> 00:10:18,879
the classic inheritance model that PHP

00:10:16,660 --> 00:10:20,319
does it has alternative ways you can get

00:10:18,879 --> 00:10:24,069
similar behavior but it doesn't have

00:10:20,319 --> 00:10:26,279
that same approach built in PHP itself

00:10:24,069 --> 00:10:29,019
has the final keyword and when you

00:10:26,279 --> 00:10:31,419
prefix final on to a class definition

00:10:29,019 --> 00:10:34,569
nobody can extend that last you can't

00:10:31,419 --> 00:10:38,559
subclass it so the truth is that

00:10:34,569 --> 00:10:40,959
inheritance is just one tool available

00:10:38,559 --> 00:10:43,569
to us for ensuring our classes are open

00:10:40,959 --> 00:10:46,360
to extension unlike Awful's we need to

00:10:43,569 --> 00:10:48,509
know what strengths and weaknesses they

00:10:46,360 --> 00:10:48,509
have

00:10:48,660 --> 00:10:51,810
inheritance has its uses I'm not going

00:10:50,730 --> 00:10:54,210
to stand here and tell you I don't use

00:10:51,810 --> 00:10:56,790
it because I do but you have to know

00:10:54,210 --> 00:10:59,070
your tools like to say but in general we

00:10:56,790 --> 00:11:02,220
should trying to favor composition over

00:10:59,070 --> 00:11:03,600
inheritance composition is one of the

00:11:02,220 --> 00:11:05,760
fundamental building blocks of

00:11:03,600 --> 00:11:07,440
object-oriented design it's the idea

00:11:05,760 --> 00:11:09,570
that we can abstract things which vary

00:11:07,440 --> 00:11:12,330
between components of our applications

00:11:09,570 --> 00:11:15,690
and compose them into separate units or

00:11:12,330 --> 00:11:17,820
classes so I've got an example view of

00:11:15,690 --> 00:11:20,280
how composition might be better than

00:11:17,820 --> 00:11:22,050
inheritance in a certain situation I've

00:11:20,280 --> 00:11:23,880
adapted this example from a really great

00:11:22,050 --> 00:11:25,770
book called head first design patterns

00:11:23,880 --> 00:11:27,990
got a link to it at the end of my slide

00:11:25,770 --> 00:11:29,280
you are not familiar with design

00:11:27,990 --> 00:11:31,860
patterns and you want to learn more

00:11:29,280 --> 00:11:36,030
about it I really really recommend this

00:11:31,860 --> 00:11:38,970
book fantastic read so let's say we're

00:11:36,030 --> 00:11:41,040
working on a duck simulator app everyone

00:11:38,970 --> 00:11:43,230
likes ducks right

00:11:41,040 --> 00:11:44,340
so in this simulator app we're going to

00:11:43,230 --> 00:11:46,470
have a screen and it's going to have

00:11:44,340 --> 00:11:48,030
ducks flying around on it and doing

00:11:46,470 --> 00:11:50,880
things with ducks do like quacking and

00:11:48,030 --> 00:11:51,960
swimming and you know ducks things so if

00:11:50,880 --> 00:11:53,460
we were to approach this using

00:11:51,960 --> 00:11:54,900
inheritance we might do something like

00:11:53,460 --> 00:11:57,000
this we might have an abstract class

00:11:54,900 --> 00:12:00,390
called ducks which has methods swim

00:11:57,000 --> 00:12:01,890
quack and fly and in those methods we're

00:12:00,390 --> 00:12:03,630
going to have the logic concerned with

00:12:01,890 --> 00:12:05,520
actually performing those behaviors so

00:12:03,630 --> 00:12:07,020
we don't have real code here because

00:12:05,520 --> 00:12:09,540
it's not real application but hopefully

00:12:07,020 --> 00:12:11,040
you can use your imagination and then we

00:12:09,540 --> 00:12:12,720
can add different types of ducks to our

00:12:11,040 --> 00:12:15,060
application by extending the abstract

00:12:12,720 --> 00:12:19,650
plus so you have a mallard and an Ida

00:12:15,060 --> 00:12:21,780
and a Mandarin and so on so it's great

00:12:19,650 --> 00:12:27,210
doesn't it because all ducks quack fly

00:12:21,780 --> 00:12:28,800
and swim then the boss says we need to

00:12:27,210 --> 00:12:30,980
put a rubber duck into our application

00:12:28,800 --> 00:12:30,980
Oh

00:12:31,070 --> 00:12:37,260
so we extend our abstract class

00:12:34,760 --> 00:12:39,030
ducks rubber ducks don't swim and just

00:12:37,260 --> 00:12:42,060
kind of float Bob on the water we have

00:12:39,030 --> 00:12:43,710
to override the parent method there let

00:12:42,060 --> 00:12:45,570
it quite either they squeak when you

00:12:43,710 --> 00:12:48,060
squeeze them so again we have to

00:12:45,570 --> 00:12:50,010
override that parent method and they

00:12:48,060 --> 00:12:51,810
don't fly they didn't have anything you

00:12:50,010 --> 00:12:53,700
could describe a flying unless throwing

00:12:51,810 --> 00:12:55,380
it across the room could be cool flying

00:12:53,700 --> 00:12:57,120
and of course they have an additional

00:12:55,380 --> 00:12:58,300
behavior because they can help us debug

00:12:57,120 --> 00:13:00,250
our code

00:12:58,300 --> 00:13:02,140
so we're finding ourselves having to

00:13:00,250 --> 00:13:03,730
override every method from our parent

00:13:02,140 --> 00:13:08,230
class which is a bit of a sign that

00:13:03,730 --> 00:13:09,850
something's wrong with our design now

00:13:08,230 --> 00:13:11,290
this might not be a big problem in this

00:13:09,850 --> 00:13:13,420
specific example where we've only got

00:13:11,290 --> 00:13:14,530
four types but as we scale our

00:13:13,420 --> 00:13:15,970
application we're going to run into

00:13:14,530 --> 00:13:17,500
problems maintaining this they said

00:13:15,970 --> 00:13:19,570
let's say we have to also add a wooden

00:13:17,500 --> 00:13:21,670
toy ducks to our application this can

00:13:19,570 --> 00:13:24,580
have some Sarah laughs similarities with

00:13:21,670 --> 00:13:26,170
a rubber duck because it doesn't swim it

00:13:24,580 --> 00:13:30,040
doesn't quite make any noise at all in

00:13:26,170 --> 00:13:31,600
fact and it doesn't fly so again we're

00:13:30,040 --> 00:13:34,120
overriding methods from the parent class

00:13:31,600 --> 00:13:35,680
we're having to duplicate code we're

00:13:34,120 --> 00:13:36,760
going to run into problems scaling this

00:13:35,680 --> 00:13:38,560
because we're going to have behavior

00:13:36,760 --> 00:13:42,580
code spread about different classes and

00:13:38,560 --> 00:13:43,900
it's going to get messy so if we were to

00:13:42,580 --> 00:13:46,330
approach this problem using composition

00:13:43,900 --> 00:13:48,220
we might do something like this let's

00:13:46,330 --> 00:13:50,770
say we create interfaces could swimming

00:13:48,220 --> 00:13:53,560
with a method swim quacking with a

00:13:50,770 --> 00:13:57,280
method quack and flying with a method

00:13:53,560 --> 00:13:59,320
fly we're going to encapsulate the thing

00:13:57,280 --> 00:14:00,940
which varies between the ducks which is

00:13:59,320 --> 00:14:02,890
the way that they perform these

00:14:00,940 --> 00:14:04,750
behaviors and we're going to compose

00:14:02,890 --> 00:14:08,080
those behaviors into their own classes

00:14:04,750 --> 00:14:09,580
these interfaces will not be implemented

00:14:08,080 --> 00:14:12,460
by the duck classes they will be

00:14:09,580 --> 00:14:15,040
implemented by classes which whose job

00:14:12,460 --> 00:14:20,770
whose single responsibility is to

00:14:15,040 --> 00:14:22,510
perform those behaviors by doing this we

00:14:20,770 --> 00:14:24,070
also make our ducks more compliant with

00:14:22,510 --> 00:14:26,050
single responsibility principle because

00:14:24,070 --> 00:14:31,270
the duck classes are no longer concerned

00:14:26,050 --> 00:14:32,470
with how they fly swim or quack so we

00:14:31,270 --> 00:14:33,970
might implement this something like this

00:14:32,470 --> 00:14:36,160
we've got the interface quacking for

00:14:33,970 --> 00:14:38,140
example we'll have a quacking ducks

00:14:36,160 --> 00:14:40,180
behavior which the regular ducks can use

00:14:38,140 --> 00:14:42,220
they'll make a normal crack noise we'll

00:14:40,180 --> 00:14:44,560
have a mute duck for the wooden ducks

00:14:42,220 --> 00:14:48,580
and we're going to have a squeaking duck

00:14:44,560 --> 00:14:50,050
for the rubber duck and then it might

00:14:48,580 --> 00:14:53,620
look something like this so we've got

00:14:50,050 --> 00:14:54,670
the Eider ducks class whose constructor

00:14:53,620 --> 00:14:56,500
would look something like this and if

00:14:54,670 --> 00:14:57,820
you look in the constructor here we can

00:14:56,500 --> 00:15:00,070
see we've got type Pence on those

00:14:57,820 --> 00:15:02,560
behavior interfaces swim n quacking and

00:15:00,070 --> 00:15:04,390
flying so we inject in instances of

00:15:02,560 --> 00:15:06,790
those behaviors assignments class

00:15:04,390 --> 00:15:08,500
properties and then in the methods the

00:15:06,790 --> 00:15:11,260
swim quack and fly methods on the duck

00:15:08,500 --> 00:15:12,749
class we just delegate to those

00:15:11,260 --> 00:15:14,829
behaviors

00:15:12,749 --> 00:15:18,040
so what does this have to do with the

00:15:14,829 --> 00:15:20,079
open and closed principle our duct

00:15:18,040 --> 00:15:22,389
classes are now open to extension

00:15:20,079 --> 00:15:24,999
because these tight pants in the

00:15:22,389 --> 00:15:27,129
constructor here are interfaces so we

00:15:24,999 --> 00:15:28,749
can pass in alternative behaviors if we

00:15:27,129 --> 00:15:31,540
want and change the way that this duct

00:15:28,749 --> 00:15:33,609
behaves now Ida ducts are a particular

00:15:31,540 --> 00:15:38,980
favorite of mine because they have a

00:15:33,609 --> 00:15:45,279
really cool mating noise kind of sounds

00:15:38,980 --> 00:15:47,980
like this let's say some users of our

00:15:45,279 --> 00:15:49,660
application want either ducks

00:15:47,980 --> 00:15:51,399
instead of quacking to make the noise

00:15:49,660 --> 00:15:53,980
that I can't believe I just made onstage

00:15:51,399 --> 00:15:55,299
in front of a couple hundred people we

00:15:53,980 --> 00:15:58,119
might create a class cuckoo which

00:15:55,299 --> 00:15:59,529
implements our quacking interface and it

00:15:58,119 --> 00:16:02,169
would take care of the logic is making

00:15:59,529 --> 00:16:04,179
that ridiculous sound and then we can

00:16:02,169 --> 00:16:06,279
inject that into the I deduct class by

00:16:04,179 --> 00:16:08,109
passing it in in the constructor so

00:16:06,279 --> 00:16:09,639
we've changed its behavior without

00:16:08,109 --> 00:16:13,389
having to change its source code it's

00:16:09,639 --> 00:16:15,279
open for extension and that approach is

00:16:13,389 --> 00:16:16,839
a pattern which is known as the strategy

00:16:15,279 --> 00:16:19,749
pattern very common pattern you'll come

00:16:16,839 --> 00:16:21,699
across a very powerful way of changing

00:16:19,749 --> 00:16:26,199
behaviors by passing in different

00:16:21,699 --> 00:16:28,569
implementations of interfaces another

00:16:26,199 --> 00:16:30,759
way that we can keep our classes open -

00:16:28,569 --> 00:16:35,350
extension is to use something called the

00:16:30,759 --> 00:16:36,610
decorator pattern I like to think of the

00:16:35,350 --> 00:16:40,600
decorator pattern is a bit like

00:16:36,610 --> 00:16:45,189
sandwiches I like sandwiches decorator

00:16:40,600 --> 00:16:46,660
pattern is I'll rewind slowly imagine

00:16:45,189 --> 00:16:48,730
you go into a shop like present mulching

00:16:46,660 --> 00:16:50,290
or Tesco or somewhere where they sell

00:16:48,730 --> 00:16:52,089
prepackaged sandwiches and you take one

00:16:50,290 --> 00:16:54,939
out of the fridge you take it home

00:16:52,089 --> 00:16:56,410
that's like that sandwich is close to a

00:16:54,939 --> 00:16:58,360
modification effectively because if you

00:16:56,410 --> 00:16:59,589
want to change the sandwich so you walk

00:16:58,360 --> 00:17:01,480
chicken and mayonnaise and you don't

00:16:59,589 --> 00:17:02,769
like mayonnaise either open the sandwich

00:17:01,480 --> 00:17:04,740
you go to scrape the mayonnaise off the

00:17:02,769 --> 00:17:06,639
bread not going to be very good of it

00:17:04,740 --> 00:17:10,299
whereas if you go to somewhere like

00:17:06,639 --> 00:17:11,799
Subway they have this kind of production

00:17:10,299 --> 00:17:14,740
line process you go up and you'd say I'd

00:17:11,799 --> 00:17:16,419
like a week's bread roll with chicken in

00:17:14,740 --> 00:17:18,399
it please and then they pass it along

00:17:16,419 --> 00:17:19,809
their production line and at each stage

00:17:18,399 --> 00:17:21,159
of that production line you can choose

00:17:19,809 --> 00:17:23,679
whether you want to decorate your

00:17:21,159 --> 00:17:24,550
sandwich with salad or sauce or cheese

00:17:23,679 --> 00:17:26,830
or whatever it might

00:17:24,550 --> 00:17:29,920
be so Subway sandwiches are effectively

00:17:26,830 --> 00:17:31,720
open for extension and they you don't

00:17:29,920 --> 00:17:33,040
have to like send go all the way back to

00:17:31,720 --> 00:17:34,150
the start and start again if you decide

00:17:33,040 --> 00:17:36,790
that you want mayonnaise in your

00:17:34,150 --> 00:17:38,950
sandwich so that's the decorator pattern

00:17:36,790 --> 00:17:42,190
effectively I've got real example for

00:17:38,950 --> 00:17:44,710
you but is anyone in here done any

00:17:42,190 --> 00:17:47,080
implementing of PS r7 middleware in

00:17:44,710 --> 00:17:49,390
something like slim or symphony or

00:17:47,080 --> 00:17:50,740
something like that okay well if you've

00:17:49,390 --> 00:17:52,750
done that that's the decorator pattern

00:17:50,740 --> 00:17:54,340
effectively this idea of passing in

00:17:52,750 --> 00:17:56,020
request and response objects down a

00:17:54,340 --> 00:17:58,690
change the middleware stack and

00:17:56,020 --> 00:18:00,160
operating on those objects and when you

00:17:58,690 --> 00:18:01,480
get to the other end of the chain those

00:18:00,160 --> 00:18:05,050
objects will have changed they would

00:18:01,480 --> 00:18:06,730
have been decorated so here is a real

00:18:05,050 --> 00:18:09,400
example adapted from something we did it

00:18:06,730 --> 00:18:12,700
works so I one of our applications had

00:18:09,400 --> 00:18:15,160
to integrate with a third party API and

00:18:12,700 --> 00:18:18,160
that API uses OAuth 2 for its

00:18:15,160 --> 00:18:20,560
authentication so every time we hit an

00:18:18,160 --> 00:18:22,210
API endpoint to request some data or

00:18:20,560 --> 00:18:25,500
post something or whatever we're doing

00:18:22,210 --> 00:18:28,840
we have to send a valid Oh wolf to token

00:18:25,500 --> 00:18:30,910
tokens from this API was valid for 48

00:18:28,840 --> 00:18:33,250
hours and we were going to be making

00:18:30,910 --> 00:18:36,580
multiple requests for this API every day

00:18:33,250 --> 00:18:39,040
so to us it didn't make sense to just

00:18:36,580 --> 00:18:41,110
request a new token every time we were

00:18:39,040 --> 00:18:45,330
going to hit the API we could store an

00:18:41,110 --> 00:18:47,680
existing token for 48 hours and reuse it

00:18:45,330 --> 00:18:51,880
so we realized we could achieve this

00:18:47,680 --> 00:18:54,040
using decorator man so the first key

00:18:51,880 --> 00:18:56,290
steps to a decorator pattern is having

00:18:54,040 --> 00:18:57,550
some common interface that your classes

00:18:56,290 --> 00:18:59,020
can implement and that you can chain

00:18:57,550 --> 00:19:01,450
together so in this case it was called

00:18:59,020 --> 00:19:03,310
access token repository and as a single

00:19:01,450 --> 00:19:05,250
method called get which returns an

00:19:03,310 --> 00:19:08,380
access token so this will represent

00:19:05,250 --> 00:19:11,020
somewhere where a client code can call

00:19:08,380 --> 00:19:16,240
this get method and get an access token

00:19:11,020 --> 00:19:17,950
object back that's its contract so we

00:19:16,240 --> 00:19:19,720
then made a class called API repository

00:19:17,950 --> 00:19:24,370
and this will be a class that we use to

00:19:19,720 --> 00:19:26,200
get a new access token from the API so

00:19:24,370 --> 00:19:28,240
in the constructor of this class we pass

00:19:26,200 --> 00:19:30,910
in an instance of a class called

00:19:28,240 --> 00:19:33,910
provider which came from the PHP League

00:19:30,910 --> 00:19:35,260
of Extraordinary packages both to client

00:19:33,910 --> 00:19:37,089
really great library if you want to work

00:19:35,260 --> 00:19:39,119
with oauth2 by the way

00:19:37,089 --> 00:19:41,499
we signed that to a class property and

00:19:39,119 --> 00:19:43,269
then the get method we can just delegate

00:19:41,499 --> 00:19:44,919
to that provider class and call the get

00:19:43,269 --> 00:19:48,569
access token because we know that that

00:19:44,919 --> 00:19:48,569
will give us that access token object

00:19:49,049 --> 00:19:55,419
now if we want to store that token we

00:19:53,229 --> 00:19:58,599
could of course go back and change this

00:19:55,419 --> 00:20:00,279
and put storage logic into that code but

00:19:58,599 --> 00:20:01,839
for a start that's not making our code

00:20:00,279 --> 00:20:03,249
it's not going to be very flexible if we

00:20:01,839 --> 00:20:05,079
ever want to take the storage logic out

00:20:03,249 --> 00:20:07,689
we've got a change in source code so it

00:20:05,079 --> 00:20:09,339
would be open for modification we'd also

00:20:07,689 --> 00:20:11,139
be adding additional responsibilities

00:20:09,339 --> 00:20:12,759
this class is really simple because all

00:20:11,139 --> 00:20:14,289
it cares about is getting a token from

00:20:12,759 --> 00:20:17,619
the API we shouldn't be adding

00:20:14,289 --> 00:20:19,959
additional responsibilities to it so

00:20:17,619 --> 00:20:21,849
according to the decorator approach we

00:20:19,959 --> 00:20:23,859
make a new implementation of our access

00:20:21,849 --> 00:20:25,779
token repository interface so here it's

00:20:23,859 --> 00:20:28,359
called storage repository and this will

00:20:25,779 --> 00:20:30,639
represent somewhere where we can we can

00:20:28,359 --> 00:20:32,439
get an access token from a store of some

00:20:30,639 --> 00:20:34,509
kind whether that's a database or file

00:20:32,439 --> 00:20:38,049
system or reddit or whatever you like

00:20:34,509 --> 00:20:40,179
and in its constructor it has two

00:20:38,049 --> 00:20:42,699
dependencies one is token storage which

00:20:40,179 --> 00:20:44,139
is another interface we created I don't

00:20:42,699 --> 00:20:46,419
have it on the slides but hopefully you

00:20:44,139 --> 00:20:48,219
can imagine what it might look like and

00:20:46,419 --> 00:20:49,959
that will just be something which will

00:20:48,219 --> 00:20:51,429
represent talking that that will deal

00:20:49,959 --> 00:20:52,479
with you know talking to whatever store

00:20:51,429 --> 00:20:54,009
you're using so if you're using a

00:20:52,479 --> 00:20:56,519
database that would be that would

00:20:54,009 --> 00:20:59,889
contain PDO and some queries or whatever

00:20:56,519 --> 00:21:01,239
and then the other dependency you can

00:20:59,889 --> 00:21:02,739
see on the second line of the

00:21:01,239 --> 00:21:04,869
constructor signature is another

00:21:02,739 --> 00:21:07,539
instance of access token repository and

00:21:04,869 --> 00:21:09,309
the eagle-eyed of you will notice that

00:21:07,539 --> 00:21:11,499
access token repository in the

00:21:09,309 --> 00:21:14,469
constructor signature is the same type

00:21:11,499 --> 00:21:18,579
as in the implement statement at the top

00:21:14,469 --> 00:21:20,769
of the class so what this means is we

00:21:18,579 --> 00:21:21,999
can ask the storage repository to get us

00:21:20,769 --> 00:21:23,799
a token from its store

00:21:21,999 --> 00:21:26,799
we can check whether it's valid or not

00:21:23,799 --> 00:21:29,469
and if it's not valid we can call that

00:21:26,799 --> 00:21:32,379
other repository instance we passed in

00:21:29,469 --> 00:21:34,629
as a fallback method so at our case

00:21:32,379 --> 00:21:36,939
we're saying check the database for a

00:21:34,629 --> 00:21:39,189
storage for check the database for a

00:21:36,939 --> 00:21:40,599
token if we don't have one we're going

00:21:39,189 --> 00:21:43,959
to call the next decorator which in our

00:21:40,599 --> 00:21:46,239
case will just be the API repository and

00:21:43,959 --> 00:21:48,209
in this case after we called it we've

00:21:46,239 --> 00:21:50,529
got the taken back the storage

00:21:48,209 --> 00:21:50,940
dependency can then save the token in

00:21:50,529 --> 00:21:52,440
our they

00:21:50,940 --> 00:21:54,180
faced against so the next time we hit it

00:21:52,440 --> 00:21:57,330
it will be there and valid and then we

00:21:54,180 --> 00:22:00,030
can return it the important point to

00:21:57,330 --> 00:22:01,380
note is that this in this instance of

00:22:00,030 --> 00:22:03,540
access taking the depository that we

00:22:01,380 --> 00:22:05,310
pass in could be any implementation we

00:22:03,540 --> 00:22:08,060
like so if we want to add additional

00:22:05,310 --> 00:22:10,380
decorators to our chain we can do that

00:22:08,060 --> 00:22:12,390
so here's what the usage of that code

00:22:10,380 --> 00:22:14,670
would look like we have to instantiate a

00:22:12,390 --> 00:22:16,410
few different things and wire things

00:22:14,670 --> 00:22:17,430
together this is an example of solid

00:22:16,410 --> 00:22:19,920
meaning I'm going to write a bit of code

00:22:17,430 --> 00:22:23,880
wrap solid tends to put the burden on

00:22:19,920 --> 00:22:25,290
the calling code and this is an example

00:22:23,880 --> 00:22:28,770
of facts we've got to set up all the

00:22:25,290 --> 00:22:30,090
dependencies and then what I think is

00:22:28,770 --> 00:22:32,130
really nice and really simple is that

00:22:30,090 --> 00:22:34,200
the client code ok does have to deal

00:22:32,130 --> 00:22:36,360
with wiring clear these dependencies but

00:22:34,200 --> 00:22:37,920
then it can just call one method and it

00:22:36,360 --> 00:22:39,510
gets a token back and it doesn't need to

00:22:37,920 --> 00:22:41,100
know anything about what's happening

00:22:39,510 --> 00:22:42,750
underneath that it doesn't know that

00:22:41,100 --> 00:22:44,790
there's any decorator pattern involved

00:22:42,750 --> 00:22:46,350
there it doesn't know that it's whether

00:22:44,790 --> 00:22:48,240
it's getting a token from storage or

00:22:46,350 --> 00:22:50,760
from the API it doesn't care it doesn't

00:22:48,240 --> 00:22:52,440
need to know so if we wanted to add an

00:22:50,760 --> 00:22:56,160
additional decorator here let's say if

00:22:52,440 --> 00:22:58,710
we wanted to log every time we were

00:22:56,160 --> 00:23:00,810
hitting the API to request an access

00:22:58,710 --> 00:23:03,300
token we could add a new implementation

00:23:00,810 --> 00:23:05,610
of our repository and family that in

00:23:03,300 --> 00:23:10,350
between the different layers of our

00:23:05,610 --> 00:23:12,210
decorator setup final pattern I want to

00:23:10,350 --> 00:23:13,680
briefly mention I don't have time

00:23:12,210 --> 00:23:16,290
unfortunately to go into any detail on

00:23:13,680 --> 00:23:17,760
this is the observer pattern and this is

00:23:16,290 --> 00:23:20,190
another way you can keep your classes

00:23:17,760 --> 00:23:22,370
open for extension if we think back to

00:23:20,190 --> 00:23:25,260
that controller example where we

00:23:22,370 --> 00:23:27,660
refactored out into a service class we

00:23:25,260 --> 00:23:30,380
could make that class more open to

00:23:27,660 --> 00:23:32,730
extension by using the observer pattern

00:23:30,380 --> 00:23:34,320
all I can say is this is a really

00:23:32,730 --> 00:23:38,160
interesting and useful pattern if you've

00:23:34,320 --> 00:23:39,480
ever used frameworks event subsystems

00:23:38,160 --> 00:23:41,700
they tend to use a version of the

00:23:39,480 --> 00:23:43,110
observer pump and there's some really

00:23:41,700 --> 00:23:45,960
great articles out there you can go away

00:23:43,110 --> 00:23:47,640
and read I would recommend that the good

00:23:45,960 --> 00:23:50,090
section in that book as well so I

00:23:47,640 --> 00:23:50,090
mentioned before

00:23:56,559 --> 00:24:04,940
so Ron to the L of solid which is the

00:24:01,489 --> 00:24:07,519
liftoff substitution principle Liskov

00:24:04,940 --> 00:24:09,950
substitution principle was formulated by

00:24:07,519 --> 00:24:12,229
a woman called Barbara Liskov she was

00:24:09,950 --> 00:24:14,959
quite an awesome lady she was the first

00:24:12,229 --> 00:24:18,679
woman in the u.s. ladies night to get a

00:24:14,959 --> 00:24:21,109
doctorate in computer science and her

00:24:18,679 --> 00:24:22,580
principle states that objects in a

00:24:21,109 --> 00:24:24,859
program should be replaceable with

00:24:22,580 --> 00:24:27,909
instances of their subtypes without

00:24:24,859 --> 00:24:32,629
altering the correctness of that program

00:24:27,909 --> 00:24:35,059
or if s is a subtype of T and objects of

00:24:32,629 --> 00:24:37,849
type T in a program may be replaced with

00:24:35,059 --> 00:24:41,559
objects of type F without altering the

00:24:37,849 --> 00:24:45,729
desirable properties of that program

00:24:41,559 --> 00:24:45,729
everything seems to come back to ducks

00:24:47,049 --> 00:24:53,179
so when I read that wording and I see

00:24:49,369 --> 00:24:55,249
things like correctness and desirable

00:24:53,179 --> 00:24:59,419
properties assess to me it's all about

00:24:55,249 --> 00:25:02,239
behavior so here's an example of a

00:24:59,419 --> 00:25:04,549
Liskov substitution breach this comes

00:25:02,239 --> 00:25:07,039
from Uncle Bob himself he wrote an

00:25:04,549 --> 00:25:08,450
article about LSP which is really

00:25:07,039 --> 00:25:10,759
interesting I won't on pretend to

00:25:08,450 --> 00:25:12,109
understand it all it's quite academic in

00:25:10,759 --> 00:25:12,759
places but it's very interesting read

00:25:12,109 --> 00:25:15,409
anyway

00:25:12,759 --> 00:25:17,690
so let's suppose we have an application

00:25:15,409 --> 00:25:19,070
which deals with geometric shapes and we

00:25:17,690 --> 00:25:21,469
have a classical rectangle which is

00:25:19,070 --> 00:25:22,909
going to represent a rectangle and the

00:25:21,469 --> 00:25:24,169
rectangle has a height in a width and we

00:25:22,909 --> 00:25:26,269
need to be able to set and get those

00:25:24,169 --> 00:25:28,579
this isn't a very good class it's

00:25:26,269 --> 00:25:32,089
completely mutable and so on but let's

00:25:28,579 --> 00:25:33,469
just ignore that for this example we

00:25:32,089 --> 00:25:35,389
then have a function called transform

00:25:33,469 --> 00:25:37,190
which again I'm not really sure why it

00:25:35,389 --> 00:25:39,919
would exist in real world but here we go

00:25:37,190 --> 00:25:41,749
just serve could serve the purpose of

00:25:39,919 --> 00:25:43,759
this example and when you pass in a

00:25:41,749 --> 00:25:45,589
rectangle for this function it's going

00:25:43,759 --> 00:25:50,989
to change the height of the rectangle to

00:25:45,589 --> 00:25:52,399
10 so we instantiate a rectangle give it

00:25:50,989 --> 00:25:56,989
a height and width and we call our

00:25:52,399 --> 00:25:59,029
transform method transform function the

00:25:56,989 --> 00:26:01,129
idea would be that if we check the

00:25:59,029 --> 00:26:04,410
height and the width of the rectangle

00:26:01,129 --> 00:26:06,480
after we call transform

00:26:04,410 --> 00:26:08,850
the height will have changed but the

00:26:06,480 --> 00:26:11,730
width will estate the same that is the

00:26:08,850 --> 00:26:15,480
desirable property of the rectangle

00:26:11,730 --> 00:26:17,390
class all right transform function when

00:26:15,480 --> 00:26:21,720
it calls set height it doesn't expect

00:26:17,390 --> 00:26:23,250
anything to happen to the width so let's

00:26:21,720 --> 00:26:26,490
say in our application as well as the

00:26:23,250 --> 00:26:30,140
rectangle we also you have a square now

00:26:26,490 --> 00:26:35,670
squares in mathematics in geometry are

00:26:30,140 --> 00:26:37,410
in arguably a type of rectangle so we

00:26:35,670 --> 00:26:39,450
should be able to just subclass a

00:26:37,410 --> 00:26:41,490
rectangle right create a square like

00:26:39,450 --> 00:26:43,980
that so let's do that let's see what

00:26:41,490 --> 00:26:47,640
that looks like so here's our square

00:26:43,980 --> 00:26:49,080
class Mao squares the fundamental

00:26:47,640 --> 00:26:52,170
property of a square is that its height

00:26:49,080 --> 00:26:53,490
and width always the same so we can get

00:26:52,170 --> 00:26:54,960
rid of the height and width properties

00:26:53,490 --> 00:26:57,660
from rectangle and replace it with a

00:26:54,960 --> 00:26:59,100
single height and width property we then

00:26:57,660 --> 00:27:00,900
have to override the status and the

00:26:59,100 --> 00:27:03,480
getters to deal with different property

00:27:00,900 --> 00:27:05,250
once again as with the duck example

00:27:03,480 --> 00:27:08,040
before the fact that we're overriding

00:27:05,250 --> 00:27:11,060
all of those methods is a sign that

00:27:08,040 --> 00:27:14,190
there's something wrong with our design

00:27:11,060 --> 00:27:16,590
but here's the problem when we pass in a

00:27:14,190 --> 00:27:18,480
square to the rectangle to the transform

00:27:16,590 --> 00:27:20,610
function which PHP will allow us to do

00:27:18,480 --> 00:27:22,530
because our rectangle type in here will

00:27:20,610 --> 00:27:27,120
allow us to pass in a subtype like

00:27:22,530 --> 00:27:28,980
Square and it's called set height the

00:27:27,120 --> 00:27:32,190
height will have changed but so will the

00:27:28,980 --> 00:27:35,310
width so from the point of view of the

00:27:32,190 --> 00:27:38,430
consumer of the rectangle type which is

00:27:35,310 --> 00:27:43,490
our transform function this is forming

00:27:38,430 --> 00:27:43,490
undesirable things unexpected things

00:27:45,140 --> 00:27:53,010
who's heard of a concept called design

00:27:48,090 --> 00:27:55,470
by contract period okay really

00:27:53,010 --> 00:27:58,890
interesting topic it's worthy of many

00:27:55,470 --> 00:28:00,300
talks by itself but there's a good

00:27:58,890 --> 00:28:02,760
Wikipedia rascal if you want to get an

00:28:00,300 --> 00:28:04,440
overview on it there's also a couple of

00:28:02,760 --> 00:28:06,270
RFC s in discussion at the minute I

00:28:04,440 --> 00:28:08,760
think for adding native designed by

00:28:06,270 --> 00:28:10,789
contracts features to PHP which could be

00:28:08,760 --> 00:28:13,070
interesting

00:28:10,789 --> 00:28:14,989
and in his article anyway his article

00:28:13,070 --> 00:28:16,699
Uncle Bob talks about strong correlation

00:28:14,989 --> 00:28:20,329
between LFP between Liskov substitution

00:28:16,699 --> 00:28:22,009
principle and designed by contract one

00:28:20,329 --> 00:28:24,379
of the things that design by contract

00:28:22,009 --> 00:28:27,469
talks about is the idea of preconditions

00:28:24,379 --> 00:28:29,389
and postconditions so if we can have a

00:28:27,469 --> 00:28:32,119
look at what that might look like for

00:28:29,389 --> 00:28:34,219
our rectangle class the precondition of

00:28:32,119 --> 00:28:36,409
our set height method could be for

00:28:34,219 --> 00:28:39,320
example there is a rectangle and a house

00:28:36,409 --> 00:28:41,809
a given height and width the post

00:28:39,320 --> 00:28:43,609
condition of the set height method what

00:28:41,809 --> 00:28:46,219
we would expect to be the case after

00:28:43,609 --> 00:28:48,319
we've called it would be the height of

00:28:46,219 --> 00:28:52,309
the rectangle has changed but the width

00:28:48,319 --> 00:28:54,169
has not so this is a useful approach for

00:28:52,309 --> 00:28:57,499
assessing the substitutability of

00:28:54,169 --> 00:28:59,749
subclasses we can come up with these pre

00:28:57,499 --> 00:29:04,129
and post conditions and we can write

00:28:59,749 --> 00:29:09,739
tests to assert we are meeting those

00:29:04,129 --> 00:29:11,119
conditions in general I think the square

00:29:09,739 --> 00:29:12,679
and rectangle example is another

00:29:11,119 --> 00:29:14,389
illustration of the problems that can be

00:29:12,679 --> 00:29:16,339
introduced by inheritance I would go

00:29:14,389 --> 00:29:18,949
back to the point I made before about

00:29:16,339 --> 00:29:21,529
favoring composition and I think LSP

00:29:18,949 --> 00:29:24,069
pushes us towards composition away from

00:29:21,529 --> 00:29:24,069
inheritance

00:29:30,909 --> 00:29:36,950
the I in solid stands for interface

00:29:34,730 --> 00:29:40,010
segregation principle an interface

00:29:36,950 --> 00:29:42,110
segregation principle or ISP states that

00:29:40,010 --> 00:29:44,059
many clients specific interfaces are

00:29:42,110 --> 00:29:47,149
better than one general purpose

00:29:44,059 --> 00:29:51,169
interface no client should be forced to

00:29:47,149 --> 00:29:54,860
depend on methods it doesn't use you can

00:29:51,169 --> 00:29:57,440
think of it as breaking down larger

00:29:54,860 --> 00:30:02,570
interfaces into smaller ones more and

00:29:57,440 --> 00:30:04,850
more specific ones Uncle Bob's first

00:30:02,570 --> 00:30:09,020
formulated ISP when he was contracting

00:30:04,850 --> 00:30:12,559
at Xerox in the late 90s Xerox obviously

00:30:09,020 --> 00:30:14,330
makes these big corporate printers and

00:30:12,559 --> 00:30:16,520
photocopiers you know all-in-one type

00:30:14,330 --> 00:30:19,220
things and the software that was running

00:30:16,520 --> 00:30:22,610
on these had this concept of jobs so you

00:30:19,220 --> 00:30:26,240
had a print job and a Tanna copy job a

00:30:22,610 --> 00:30:28,789
fax job etc and apparently these

00:30:26,240 --> 00:30:32,210
software had one big interface called

00:30:28,789 --> 00:30:34,399
job which has you know print method a

00:30:32,210 --> 00:30:36,289
copy method that sort of thing it was he

00:30:34,399 --> 00:30:38,720
was big and every time they wanted to

00:30:36,289 --> 00:30:40,190
make changes to their software it was

00:30:38,720 --> 00:30:43,100
getting harder and harder because they

00:30:40,190 --> 00:30:44,960
had this tight dependency on this class

00:30:43,100 --> 00:30:48,730
which wasn't the sorriest type which

00:30:44,960 --> 00:30:48,730
wasn't specific enough to their use case

00:30:48,909 --> 00:30:55,850
so before I go into an example I also

00:30:54,140 --> 00:30:58,730
like to mention another talk

00:30:55,850 --> 00:31:00,590
specifically about ISP obviously in a

00:30:58,730 --> 00:31:02,750
talk about all of the solid principles I

00:31:00,590 --> 00:31:05,779
can only talk so long about each

00:31:02,750 --> 00:31:07,340
individual one there's a guy called Dan

00:31:05,779 --> 00:31:10,669
Akroyd who did a really good talk about

00:31:07,340 --> 00:31:12,860
this at PHP Northwest last year videos

00:31:10,669 --> 00:31:14,570
not online yet but the slides are so

00:31:12,860 --> 00:31:16,490
I've got a link to those and obviously

00:31:14,570 --> 00:31:21,890
he goes into a bit more depth than when

00:31:16,490 --> 00:31:24,830
I can about this and this time so here's

00:31:21,890 --> 00:31:26,809
an example of ISP at work literally at

00:31:24,830 --> 00:31:28,880
work this is a adapted from something

00:31:26,809 --> 00:31:30,620
real we did so the end of last year we

00:31:28,880 --> 00:31:34,039
were working on application which has

00:31:30,620 --> 00:31:36,230
pages which had lists of things on it so

00:31:34,039 --> 00:31:38,299
we had things like lists or users lists

00:31:36,230 --> 00:31:40,940
as clients lists of projects that kind

00:31:38,299 --> 00:31:42,470
of thing and some of these pages are

00:31:40,940 --> 00:31:43,450
going to be you know they can be loads

00:31:42,470 --> 00:31:45,580
and loads and loads of items

00:31:43,450 --> 00:31:48,190
hundreds of items the users needed a way

00:31:45,580 --> 00:31:49,630
to filter those lists and find what was

00:31:48,190 --> 00:31:52,929
actually interesting to them what they

00:31:49,630 --> 00:31:54,460
needed to use so we had to include

00:31:52,929 --> 00:31:56,679
various search options at the top of

00:31:54,460 --> 00:31:59,200
each page so we had types like drop-down

00:31:56,679 --> 00:32:00,669
so if we wanted to search for projects

00:31:59,200 --> 00:32:03,190
for a certain client we have a select

00:32:00,669 --> 00:32:04,870
box with the client names in them free

00:32:03,190 --> 00:32:06,549
text so if we wanted to search by

00:32:04,870 --> 00:32:09,789
project names we'd have a free text

00:32:06,549 --> 00:32:11,350
field and date ranges so they want to

00:32:09,789 --> 00:32:12,760
define projects created within a certain

00:32:11,350 --> 00:32:15,880
date range there'd be a couple of date

00:32:12,760 --> 00:32:17,320
pickers that they could use so we

00:32:15,880 --> 00:32:19,090
decided the way that we could implement

00:32:17,320 --> 00:32:20,980
this would be to use our friends the

00:32:19,090 --> 00:32:23,830
decorator pattern and the composite

00:32:20,980 --> 00:32:26,710
pattern and we created this interface

00:32:23,830 --> 00:32:28,990
called filter and the idea would be that

00:32:26,710 --> 00:32:32,230
each of those types of filter date range

00:32:28,990 --> 00:32:35,919
free text drop-down etc would have its

00:32:32,230 --> 00:32:37,539
own implementation of this interface and

00:32:35,919 --> 00:32:39,580
we'd additionally have a collection

00:32:37,539 --> 00:32:43,090
class which would bundle all of the

00:32:39,580 --> 00:32:45,940
filters together so they could be used

00:32:43,090 --> 00:32:48,010
together so this interface we have a

00:32:45,940 --> 00:32:52,269
method called build query from which has

00:32:48,010 --> 00:32:56,110
two two dependencies one which is a

00:32:52,269 --> 00:32:59,590
request which is cakephp HTTP requests

00:32:56,110 --> 00:33:00,880
objects and the idea would be that when

00:32:59,590 --> 00:33:03,100
a user filled in the form it would

00:33:00,880 --> 00:33:04,659
submit it and the data they had posted

00:33:03,100 --> 00:33:06,760
would be populated in the query string

00:33:04,659 --> 00:33:10,480
and we could grab their search data from

00:33:06,760 --> 00:33:14,049
the query string so request the request

00:33:10,480 --> 00:33:17,679
object in cage PHP take PHP have a query

00:33:14,049 --> 00:33:19,240
method so we can just grab what's coming

00:33:17,679 --> 00:33:21,940
from the query string using that query

00:33:19,240 --> 00:33:23,500
method the other dependency is slightly

00:33:21,940 --> 00:33:25,539
confusingly called query this is a

00:33:23,500 --> 00:33:28,330
different kind of query this comes from

00:33:25,539 --> 00:33:30,220
cakephp 0rm so this is a database query

00:33:28,330 --> 00:33:32,380
and the idea would be that for each

00:33:30,220 --> 00:33:33,850
filter we can look at what the user is

00:33:32,380 --> 00:33:35,529
actually search for and decide whether

00:33:33,850 --> 00:33:39,250
we need to adjust our database query

00:33:35,529 --> 00:33:42,549
accordingly so here's what the filter

00:33:39,250 --> 00:33:44,380
collection would look like we have a

00:33:42,549 --> 00:33:47,679
massive ad where we can add sales within

00:33:44,380 --> 00:33:50,500
and then in the build query from

00:33:47,679 --> 00:33:52,360
implementation we can loop over each of

00:33:50,500 --> 00:33:54,820
those filters that we've added we can

00:33:52,360 --> 00:33:55,590
decorate the query object by passing it

00:33:54,820 --> 00:33:57,330
in along with the

00:33:55,590 --> 00:33:58,830
request each filter will operate it on

00:33:57,330 --> 00:34:01,020
in turn and eventually we will get back

00:33:58,830 --> 00:34:02,850
a query object which will have all the

00:34:01,020 --> 00:34:04,740
right wear conditions and join but

00:34:02,850 --> 00:34:08,070
whatever we need to do the search for

00:34:04,740 --> 00:34:09,450
what the users have searched for so

00:34:08,070 --> 00:34:11,909
here's an example of an implementation

00:34:09,450 --> 00:34:15,929
of an individual filter class this one's

00:34:11,909 --> 00:34:18,839
the free text so we pass in the table

00:34:15,929 --> 00:34:21,960
alias and field name say for example

00:34:18,839 --> 00:34:23,639
blog posts table and we're searching on

00:34:21,960 --> 00:34:26,429
the field title we pass in blog posts

00:34:23,639 --> 00:34:29,070
and title and then in the build query

00:34:26,429 --> 00:34:32,339
from method first of all we have to

00:34:29,070 --> 00:34:34,800
check does does this field exist in the

00:34:32,339 --> 00:34:36,750
query string so if request query this

00:34:34,800 --> 00:34:39,030
field name we're basically saying query

00:34:36,750 --> 00:34:40,800
string do you have the field that we're

00:34:39,030 --> 00:34:42,810
interested in which in example an escape

00:34:40,800 --> 00:34:45,300
would be title to be saying does the

00:34:42,810 --> 00:34:48,149
query string have a key title and if say

00:34:45,300 --> 00:34:49,440
what's the value if it does have it then

00:34:48,149 --> 00:34:51,450
we'll be able to decorate the query

00:34:49,440 --> 00:34:52,710
object by changing the wear conditions

00:34:51,450 --> 00:34:55,859
so here we're just adding a light

00:34:52,710 --> 00:34:57,810
condition for our SQL and then finally

00:34:55,859 --> 00:35:01,230
we're going to return the query back so

00:34:57,810 --> 00:35:04,470
the next part of the chain can decorate

00:35:01,230 --> 00:35:05,880
the query and so on so usage is really

00:35:04,470 --> 00:35:09,390
simple really neat this is what it looks

00:35:05,880 --> 00:35:13,050
like just add our new free text into the

00:35:09,390 --> 00:35:16,560
collection like that but then we hit a

00:35:13,050 --> 00:35:19,740
bug after we deployed and the bug was

00:35:16,560 --> 00:35:24,089
what if the user searches for 0 we had a

00:35:19,740 --> 00:35:27,630
very specific use case where a user was

00:35:24,089 --> 00:35:29,760
searching 0 and it was valid now because

00:35:27,630 --> 00:35:35,160
this is our X pointment obviously PHP

00:35:29,760 --> 00:35:36,990
will evaluate a string of 0 as false so

00:35:35,160 --> 00:35:41,820
this conditional check failed and the

00:35:36,990 --> 00:35:46,080
search wasn't working so essentially

00:35:41,820 --> 00:35:49,400
what we needed to do is change this so

00:35:46,080 --> 00:35:52,530
instead of just saying to the query

00:35:49,400 --> 00:35:53,130
you know falsity is this true for your

00:35:52,530 --> 00:35:56,940
false fee

00:35:53,130 --> 00:36:00,869
we have to more specifically ask it does

00:35:56,940 --> 00:36:01,440
this key exists ie is it null and if it

00:36:00,869 --> 00:36:03,869
does exist

00:36:01,440 --> 00:36:05,380
does it have does it have a value does

00:36:03,869 --> 00:36:07,779
it or is it just an empty string

00:36:05,380 --> 00:36:09,309
so we started changing all of our filter

00:36:07,779 --> 00:36:11,559
classes to have something that look like

00:36:09,309 --> 00:36:13,839
this as I was doing this I just thought

00:36:11,559 --> 00:36:15,309
to myself this doesn't feel right this

00:36:13,839 --> 00:36:17,559
feels pretty grotty

00:36:15,309 --> 00:36:21,069
and the reason for that is that this is

00:36:17,559 --> 00:36:22,809
a leaky abstraction our filter classes

00:36:21,069 --> 00:36:25,809
shouldn't know anything about the way

00:36:22,809 --> 00:36:28,119
that cakephp x' requests class deals

00:36:25,809 --> 00:36:32,319
with the concept of keys existing in the

00:36:28,119 --> 00:36:34,869
query string and this all boils down to

00:36:32,319 --> 00:36:37,059
the fact that our filter class has a

00:36:34,869 --> 00:36:40,839
dependency on the request object and

00:36:37,059 --> 00:36:45,609
that is not specific enough a type for

00:36:40,839 --> 00:36:49,690
our use case so the way that we approach

00:36:45,609 --> 00:36:51,579
this and six-step was we created a new

00:36:49,690 --> 00:36:54,400
interface called search parameters and

00:36:51,579 --> 00:36:56,019
we changed the signature of the filters

00:36:54,400 --> 00:36:58,509
to depend on the search parameters

00:36:56,019 --> 00:37:00,940
interface instead as you can see the

00:36:58,509 --> 00:37:03,160
search parameters type search parameters

00:37:00,940 --> 00:37:05,920
the interface has two methods have which

00:37:03,160 --> 00:37:07,809
returns a bool and value which returns

00:37:05,920 --> 00:37:13,440
the value of the thing in the query

00:37:07,809 --> 00:37:16,509
string if it's there we can still use

00:37:13,440 --> 00:37:19,119
cakephp request objects we can still use

00:37:16,509 --> 00:37:21,279
the query string but instead we can now

00:37:19,119 --> 00:37:23,049
wrap that up inside this search

00:37:21,279 --> 00:37:25,450
parameters implementation so here's what

00:37:23,049 --> 00:37:29,109
that would look like we inject the

00:37:25,450 --> 00:37:31,779
request object in an constructor or has

00:37:29,109 --> 00:37:33,940
method wraps up that slightly grotty

00:37:31,779 --> 00:37:36,430
logic about the implementation details

00:37:33,940 --> 00:37:38,979
of take pH please handling of query

00:37:36,430 --> 00:37:41,440
strings so now that's hidden away we

00:37:38,979 --> 00:37:42,759
don't have to worry about it and then we

00:37:41,440 --> 00:37:45,099
have a value method which just returns

00:37:42,759 --> 00:37:47,279
from the query method as we were doing

00:37:45,099 --> 00:37:47,279
before

00:37:54,760 --> 00:38:01,760
the revised filters look like this this

00:37:59,510 --> 00:38:03,590
reads so much better so much more nicely

00:38:01,760 --> 00:38:05,270
than either the previous two versions

00:38:03,590 --> 00:38:08,030
which directly depended on the request

00:38:05,270 --> 00:38:10,040
object it reads like plain English

00:38:08,030 --> 00:38:12,080
doesn't it this is something we strive

00:38:10,040 --> 00:38:14,090
for in our work is to try and write code

00:38:12,080 --> 00:38:17,690
which reads as much like plain English

00:38:14,090 --> 00:38:20,180
as we can so instead of dealing with the

00:38:17,690 --> 00:38:21,680
internals of CakePHP it's now just

00:38:20,180 --> 00:38:24,250
dealing with a nice interface which is

00:38:21,680 --> 00:38:26,630
very specific to what it needs to do

00:38:24,250 --> 00:38:30,080
benefits here of adhering to interface

00:38:26,630 --> 00:38:33,230
segregation our classes are more loosely

00:38:30,080 --> 00:38:34,880
coupled we've given our filter classes

00:38:33,230 --> 00:38:36,800
one less reason to change because it's

00:38:34,880 --> 00:38:39,260
no longer concerned with internal

00:38:36,800 --> 00:38:42,470
implementation details of the framework

00:38:39,260 --> 00:38:44,720
and our filter class itself has moved

00:38:42,470 --> 00:38:46,160
towards being open to extension because

00:38:44,720 --> 00:38:48,680
it's dependent on a very specific

00:38:46,160 --> 00:38:50,510
interface so if we want to change the

00:38:48,680 --> 00:38:52,460
way that we are sending in those search

00:38:50,510 --> 00:38:55,010
parameters let's say we want to use post

00:38:52,460 --> 00:38:57,710
instead of a query string or we want to

00:38:55,010 --> 00:39:00,410
use JSON data on an API call or even if

00:38:57,710 --> 00:39:02,600
we want to make a command-line tool we

00:39:00,410 --> 00:39:10,190
can just create new implementations of

00:39:02,600 --> 00:39:12,320
our interface as PHP developers I think

00:39:10,190 --> 00:39:13,940
it's easy for us to read the definition

00:39:12,320 --> 00:39:16,640
of the interface segregation principle

00:39:13,940 --> 00:39:18,860
and think of an interface like this one

00:39:16,640 --> 00:39:22,540
right an interface is a staying in PHP

00:39:18,860 --> 00:39:27,610
it's an abstract type it's a way of

00:39:22,540 --> 00:39:27,610
providing a contract for our classes but

00:39:28,780 --> 00:39:33,200
Ruby for example is an object-oriented

00:39:31,250 --> 00:39:35,000
language fully object-oriented

00:39:33,200 --> 00:39:36,950
everything in the language in Ruby is an

00:39:35,000 --> 00:39:40,040
object a string is just an object which

00:39:36,950 --> 00:39:43,340
has methods you can call arrays boolean

00:39:40,040 --> 00:39:45,350
is the same but Ruby being more

00:39:43,340 --> 00:39:49,010
object-oriented than PHP doesn't have

00:39:45,350 --> 00:39:51,890
interfaces doesn't have this so how

00:39:49,010 --> 00:39:52,820
would a ruby developer interpret isp if

00:39:51,890 --> 00:39:57,250
they don't have a thing called

00:39:52,820 --> 00:40:01,820
interfaces and the truth is that all

00:39:57,250 --> 00:40:03,900
classes have an interface even if they

00:40:01,820 --> 00:40:05,759
don't explicitly implement one

00:40:03,900 --> 00:40:07,319
so we go back to the IDA classroom

00:40:05,759 --> 00:40:09,930
earlier not going to make the noise

00:40:07,319 --> 00:40:11,849
again don't worry you can see that the

00:40:09,930 --> 00:40:13,589
top there there's no implement keyword

00:40:11,849 --> 00:40:16,319
it's not explicitly implementing an

00:40:13,589 --> 00:40:19,380
interface but it does have an interface

00:40:16,319 --> 00:40:21,660
and it's interfaces just it's public

00:40:19,380 --> 00:40:24,420
methods on their signature which would

00:40:21,660 --> 00:40:26,999
look something like this so this

00:40:24,420 --> 00:40:28,859
interface doesn't exist but you can you

00:40:26,999 --> 00:40:32,279
know it's kind of an abstract idea it's

00:40:28,859 --> 00:40:34,499
out there so we can take this idea and

00:40:32,279 --> 00:40:36,539
it leaves really nicely into a point

00:40:34,499 --> 00:40:39,029
that Dan made in his talks which is the

00:40:36,539 --> 00:40:41,249
ISP in for PHP developers in particular

00:40:39,029 --> 00:40:44,460
isn't really about interfaces but it's

00:40:41,249 --> 00:40:45,869
about types and something that really

00:40:44,460 --> 00:40:49,470
well there's a slide that looked a

00:40:45,869 --> 00:40:52,529
little like that so let's quickly review

00:40:49,470 --> 00:40:54,269
what types are Wikipedia helpfully tells

00:40:52,529 --> 00:40:56,160
us that a type is a classification of

00:40:54,269 --> 00:40:59,819
data which tells the compiler how the

00:40:56,160 --> 00:41:02,940
programmer intends to use the data so in

00:40:59,819 --> 00:41:05,249
PHP we've got complex types and we have

00:41:02,940 --> 00:41:06,869
scalar types now I've slightly adapted

00:41:05,249 --> 00:41:09,239
that division because I think it fits

00:41:06,869 --> 00:41:10,920
this example more nicely so I'm going to

00:41:09,239 --> 00:41:14,400
say PHP have objects and it has

00:41:10,920 --> 00:41:16,410
everything else so in PHP we have two

00:41:14,400 --> 00:41:19,470
types of objects really we have abstract

00:41:16,410 --> 00:41:21,930
types and we have contract concrete

00:41:19,470 --> 00:41:24,690
types so abstracts would be interfaces

00:41:21,930 --> 00:41:26,130
and abstract classes and concrete's are

00:41:24,690 --> 00:41:27,599
anything that you can put the new

00:41:26,130 --> 00:41:31,589
keywords in front of and actually

00:41:27,599 --> 00:41:33,329
instantiate an instance of so we've seen

00:41:31,589 --> 00:41:35,670
examples of interfaces like filter

00:41:33,329 --> 00:41:37,140
abstract classes like duck various

00:41:35,670 --> 00:41:42,269
concrete classes throughout this talk

00:41:37,140 --> 00:41:44,099
and free text or example is is a class

00:41:42,269 --> 00:41:46,710
which evolved type free text but it's

00:41:44,099 --> 00:41:51,539
also a subtype of filter so it is a type

00:41:46,710 --> 00:41:53,970
filter as well so in the other column in

00:41:51,539 --> 00:41:55,920
PHP we have scalars and the razor razor

00:41:53,970 --> 00:41:57,390
technically in the complex type category

00:41:55,920 --> 00:41:59,460
which is where I've had to adapt this

00:41:57,390 --> 00:42:01,349
slightly and I think there's some others

00:41:59,460 --> 00:42:02,640
that aren't on the list there that I've

00:42:01,349 --> 00:42:05,369
missed now but hopefully you get the

00:42:02,640 --> 00:42:06,779
general point in PHP we have objects

00:42:05,369 --> 00:42:10,470
which have methods that we can call and

00:42:06,779 --> 00:42:12,269
then we have other types in other

00:42:10,470 --> 00:42:14,160
languages like Ruby that I mentioned and

00:42:12,269 --> 00:42:16,740
Scala for example

00:42:14,160 --> 00:42:18,750
they are fully object-oriented languages

00:42:16,740 --> 00:42:20,130
everything in the language is an object

00:42:18,750 --> 00:42:22,650
you can instantiate and then call

00:42:20,130 --> 00:42:25,619
methods on even string bulls insert

00:42:22,650 --> 00:42:27,690
cetera so as we were programming in

00:42:25,619 --> 00:42:30,299
Scala for example we had a class which

00:42:27,690 --> 00:42:33,329
was dependent on an array or a class

00:42:30,299 --> 00:42:34,500
which returned an array as a result of

00:42:33,329 --> 00:42:35,970
one of its methods it wouldn't be

00:42:34,500 --> 00:42:38,579
returning an array like we think of it

00:42:35,970 --> 00:42:40,890
in PHP of this giant bucket we can throw

00:42:38,579 --> 00:42:45,210
anything into it would be returning an

00:42:40,890 --> 00:42:46,619
object of type array with methods so if

00:42:45,210 --> 00:42:49,710
we go back to the point I made before

00:42:46,619 --> 00:42:52,260
the interface segregation is about type

00:42:49,710 --> 00:42:58,260
specificity but let's say type

00:42:52,260 --> 00:43:00,299
specificity then we can say well if

00:42:58,260 --> 00:43:02,130
we're depending on an array an array has

00:43:00,299 --> 00:43:04,470
an interface because the class and all

00:43:02,130 --> 00:43:06,990
classes have interfaces we need to ask

00:43:04,470 --> 00:43:10,349
ourselves is the interface of the class

00:43:06,990 --> 00:43:15,299
array specific enough for our use case

00:43:10,349 --> 00:43:17,010
that's what ISP is all about so we don't

00:43:15,299 --> 00:43:19,140
have that luxury in PHP we don't have

00:43:17,010 --> 00:43:21,420
these super amazing objects for

00:43:19,140 --> 00:43:24,480
everything but we can still apply that

00:43:21,420 --> 00:43:26,789
logic and erase as I said best they're

00:43:24,480 --> 00:43:28,799
just this big bucket in PHP they're this

00:43:26,789 --> 00:43:32,839
Swiss Army knife for programming that we

00:43:28,799 --> 00:43:35,670
can use and abuse to do whatever we want

00:43:32,839 --> 00:43:36,450
and I would contend that maybe we

00:43:35,670 --> 00:43:40,289
shouldn't do that

00:43:36,450 --> 00:43:42,510
sometimes so it's quite a common pattern

00:43:40,289 --> 00:43:45,630
to see arrays useful holding

00:43:42,510 --> 00:43:47,430
configuration values or options so this

00:43:45,630 --> 00:43:49,640
is adapted from another real example we

00:43:47,430 --> 00:43:52,710
did at work and we had a date picker

00:43:49,640 --> 00:43:55,470
method on our form helper and the job of

00:43:52,710 --> 00:43:57,690
this method would be to render a date

00:43:55,470 --> 00:43:58,980
picker on a form right pretty

00:43:57,690 --> 00:44:02,579
straightforward functionality pretty

00:43:58,980 --> 00:44:04,559
common functionality and we had two

00:44:02,579 --> 00:44:06,210
arguments to the method one which was

00:44:04,559 --> 00:44:08,819
called field name which would just be

00:44:06,210 --> 00:44:09,990
the field name in the HTML and then

00:44:08,819 --> 00:44:13,440
options which would allow us to

00:44:09,990 --> 00:44:17,760
configure on-the-fly things like the CSS

00:44:13,440 --> 00:44:20,250
classes or whether it's required field

00:44:17,760 --> 00:44:22,039
or not change the text label that sort

00:44:20,250 --> 00:44:24,299
of thing

00:44:22,039 --> 00:44:27,160
problem we're doing it like this is that

00:44:24,299 --> 00:44:29,560
in the class itself in the

00:44:27,160 --> 00:44:32,290
in the method body we've got a half code

00:44:29,560 --> 00:44:34,240
like this to check each option we've got

00:44:32,290 --> 00:44:35,440
to check whether the key exists in the

00:44:34,240 --> 00:44:37,450
array or not and then we've got to check

00:44:35,440 --> 00:44:41,260
the actual value of it doesn't read very

00:44:37,450 --> 00:44:43,780
nicely pretty boring to type it's also

00:44:41,260 --> 00:44:45,790
pretty prone to errors particularly from

00:44:43,780 --> 00:44:47,410
the point of view of the calling code so

00:44:45,790 --> 00:44:49,420
here in this example in the calling code

00:44:47,410 --> 00:44:53,020
I've deliberately misspelled is required

00:44:49,420 --> 00:44:56,020
fields when I run that code I'm not

00:44:53,020 --> 00:44:57,460
going to get any error message so the

00:44:56,020 --> 00:44:59,080
only time I'm going to realize it's not

00:44:57,460 --> 00:45:00,490
working is when I notice that the codes

00:44:59,080 --> 00:45:01,810
not doing what I want and then I've got

00:45:00,490 --> 00:45:03,970
to start debugging and trying to work

00:45:01,810 --> 00:45:06,190
out why and trying to spot this kind of

00:45:03,970 --> 00:45:08,440
thing is a massive pain as I'm sure you

00:45:06,190 --> 00:45:10,660
are aware we've also got no Auto

00:45:08,440 --> 00:45:14,050
completion support I'm a pretty lazy

00:45:10,660 --> 00:45:15,910
coder I really lean on my IDE and it's

00:45:14,050 --> 00:45:18,970
also a completion spool so I always want

00:45:15,910 --> 00:45:21,150
to have it wherever I can so instead of

00:45:18,970 --> 00:45:23,830
using an array we could use an object

00:45:21,150 --> 00:45:27,310
excuse a class so we made a class called

00:45:23,830 --> 00:45:29,230
date picker options and then we can

00:45:27,310 --> 00:45:31,180
define each of the options we want in my

00:45:29,230 --> 00:45:33,670
class so for example is required field

00:45:31,180 --> 00:45:36,310
which will default to self and then we

00:45:33,670 --> 00:45:38,320
can turn that to true and false using

00:45:36,310 --> 00:45:40,210
set required field and we have a getter

00:45:38,320 --> 00:45:42,520
method called is required field which

00:45:40,210 --> 00:45:44,260
just returns the value of it so we're

00:45:42,520 --> 00:45:45,850
doing it like this we add some

00:45:44,260 --> 00:45:47,680
constraints to our options as well

00:45:45,850 --> 00:45:49,120
because now this can only be a boolean

00:45:47,680 --> 00:45:50,470
whereas before someone if they wanted to

00:45:49,120 --> 00:45:53,020
you could assign anything they liked

00:45:50,470 --> 00:45:54,130
into that array but now it has to be a

00:45:53,020 --> 00:45:58,330
boolean because we've got type in

00:45:54,130 --> 00:46:00,490
support likewise for the label which is

00:45:58,330 --> 00:46:02,080
a string we can add additional

00:46:00,490 --> 00:46:04,480
validation to it because we've got a

00:46:02,080 --> 00:46:05,680
setter method so if some is our reason

00:46:04,480 --> 00:46:07,870
we wanted to make sure that our label

00:46:05,680 --> 00:46:12,010
was no longer than 25 characters we can

00:46:07,870 --> 00:46:14,410
do that and we get autocomplete support

00:46:12,010 --> 00:46:16,660
ray so this is what the revised version

00:46:14,410 --> 00:46:19,080
would look like we pass in a date picker

00:46:16,660 --> 00:46:22,330
options instance instead of the array

00:46:19,080 --> 00:46:25,210
the method body now looks much nicer

00:46:22,330 --> 00:46:27,910
it's easy to read easier to reason about

00:46:25,210 --> 00:46:30,250
you can look at that line if options is

00:46:27,910 --> 00:46:30,670
required field and you know exactly what

00:46:30,250 --> 00:46:32,830
it means

00:46:30,670 --> 00:46:36,010
you don't have to try and pass array

00:46:32,830 --> 00:46:37,840
type of stuff to work it out and I'll

00:46:36,010 --> 00:46:39,740
calling code looks nicer as well it's

00:46:37,840 --> 00:46:43,340
more declarative it's

00:46:39,740 --> 00:46:52,160
is easier to to understand its its

00:46:43,340 --> 00:46:54,500
expressive code we can apply that logic

00:46:52,160 --> 00:46:57,470
to other primitive types as well it

00:46:54,500 --> 00:47:01,520
isn't technically connected to ISP but I

00:46:57,470 --> 00:47:03,619
think it's quite a nice little tip it's

00:47:01,520 --> 00:47:05,630
quite common to see functions or methyl

00:47:03,619 --> 00:47:07,660
methyl signatures which have lots of

00:47:05,630 --> 00:47:12,619
billions for enabling or disabling

00:47:07,660 --> 00:47:14,119
certain things so this is adapted from

00:47:12,619 --> 00:47:16,910
something I've seen in the wild so let's

00:47:14,119 --> 00:47:19,220
say this function is a factory a factory

00:47:16,910 --> 00:47:20,720
for an instance of connection and you're

00:47:19,220 --> 00:47:25,369
going to call it and it will give you a

00:47:20,720 --> 00:47:28,940
connection the problem here is that when

00:47:25,369 --> 00:47:32,240
we call the code we've then got this

00:47:28,940 --> 00:47:34,970
horrendous line of brilliance when you

00:47:32,240 --> 00:47:36,440
go and look at that code in a week after

00:47:34,970 --> 00:47:38,780
you forgotten more each of those means

00:47:36,440 --> 00:47:40,369
you're going to look at that and goes of

00:47:38,780 --> 00:47:42,710
course right it's yeah it's starting to

00:47:40,369 --> 00:47:44,510
connect with the true false true all

00:47:42,710 --> 00:47:46,160
right and it's not so bad here because

00:47:44,510 --> 00:47:47,690
we've got the function definition right

00:47:46,160 --> 00:47:50,570
above the function call but in reality

00:47:47,690 --> 00:47:53,930
you're not going to have that so this is

00:47:50,570 --> 00:47:55,190
really hard to reason about this code so

00:47:53,930 --> 00:47:56,750
sometimes you know you might be working

00:47:55,190 --> 00:47:58,220
with a third party library which has a

00:47:56,750 --> 00:48:00,980
front you know a mass function signature

00:47:58,220 --> 00:48:02,810
like that and there's nothing you can

00:48:00,980 --> 00:48:04,670
actually do to improve it but what you

00:48:02,810 --> 00:48:07,310
can do you can wrap around it you can

00:48:04,670 --> 00:48:10,460
you can adapt so you can approach this

00:48:07,310 --> 00:48:11,780
problem using the Builder pattern so if

00:48:10,460 --> 00:48:15,350
we created a classical Connection

00:48:11,780 --> 00:48:17,990
Factory and we pass in whatever we need

00:48:15,350 --> 00:48:19,910
is dependencies and then we have methods

00:48:17,990 --> 00:48:21,740
called enable persist and disable

00:48:19,910 --> 00:48:24,140
persist and those are just going to

00:48:21,740 --> 00:48:26,510
toggle the persist value between true

00:48:24,140 --> 00:48:27,950
and false assesses effectively but we

00:48:26,510 --> 00:48:31,070
haven't used the word set and the method

00:48:27,950 --> 00:48:32,510
name because it reads nicer and each of

00:48:31,070 --> 00:48:35,480
those methods you'll notice will return

00:48:32,510 --> 00:48:37,850
an instance of the same class because we

00:48:35,480 --> 00:48:42,410
can then use fluent method chaining or

00:48:37,850 --> 00:48:45,470
making nice readable code now there are

00:48:42,410 --> 00:48:46,880
other options in that function signature

00:48:45,470 --> 00:48:48,350
that we had on the previous screen we've

00:48:46,880 --> 00:48:50,720
got persist enabled or from there

00:48:48,350 --> 00:48:52,310
disabled faster

00:48:50,720 --> 00:48:54,290
I have enough to fit them all on this

00:48:52,310 --> 00:48:55,580
screen but you have to imagine that

00:48:54,290 --> 00:48:57,140
they're there as well they've got a

00:48:55,580 --> 00:48:59,900
property and then they've got enabling

00:48:57,140 --> 00:49:01,340
disabled methods as well now the most

00:48:59,900 --> 00:49:02,630
important part of this class is this

00:49:01,340 --> 00:49:04,250
function at the bottom the get

00:49:02,630 --> 00:49:06,770
connection so that's the part the rats

00:49:04,250 --> 00:49:09,920
that original connect with those nasty

00:49:06,770 --> 00:49:12,080
boolean which are so hard to read so we

00:49:09,920 --> 00:49:14,000
can wrap that function call in this

00:49:12,080 --> 00:49:15,770
method and we're hiding the

00:49:14,000 --> 00:49:18,170
implementation detail of those billions

00:49:15,770 --> 00:49:19,570
inside this class so now our calling

00:49:18,170 --> 00:49:23,360
class instead of calling the function

00:49:19,570 --> 00:49:25,280
can create a connection factory use its

00:49:23,360 --> 00:49:27,830
fluent interface call the methods and

00:49:25,280 --> 00:49:32,450
set whatever things we want to do and

00:49:27,830 --> 00:49:35,240
then call get connections this is many

00:49:32,450 --> 00:49:40,370
many times nicer to read and easier to

00:49:35,240 --> 00:49:42,560
reason about them the function call but

00:49:40,370 --> 00:49:44,000
yet we had to write more code which as I

00:49:42,560 --> 00:49:55,480
said is something you find you have to

00:49:44,000 --> 00:50:00,280
do more of on your liking better code so

00:49:55,480 --> 00:50:03,140
the final solid principle and the D is

00:50:00,280 --> 00:50:04,910
dependency inversion depends the

00:50:03,140 --> 00:50:07,370
inversion principle states that we

00:50:04,910 --> 00:50:10,580
should depend on abstractions not

00:50:07,370 --> 00:50:15,820
concretions who have heard of dependency

00:50:10,580 --> 00:50:15,820
injections get quite a lot of times

00:50:16,060 --> 00:50:20,450
dependency inversion or the dependency

00:50:18,830 --> 00:50:22,970
inversion principle is what we're trying

00:50:20,450 --> 00:50:28,700
to address when we use dependency

00:50:22,970 --> 00:50:30,980
injection so when we say a class depends

00:50:28,700 --> 00:50:33,200
on abstractions not concretions we're

00:50:30,980 --> 00:50:36,910
talking about a classes dependencies the

00:50:33,200 --> 00:50:38,900
things it needs to get its job done

00:50:36,910 --> 00:50:40,520
we've seen several examples of

00:50:38,900 --> 00:50:42,440
dependencies throughout this talk and

00:50:40,520 --> 00:50:44,150
here's one of them so here's the idle

00:50:42,440 --> 00:50:46,940
class going back to it again all comes

00:50:44,150 --> 00:50:49,640
back to ducks Azim and this time I have

00:50:46,940 --> 00:50:53,090
adapted to the constructor and I have

00:50:49,640 --> 00:50:56,420
removed the type fence and the arguments

00:50:53,090 --> 00:50:57,950
from its signature so instead of passing

00:50:56,420 --> 00:51:00,200
in its dependencies we're going to

00:50:57,950 --> 00:51:01,910
instantiate them in place so we're

00:51:00,200 --> 00:51:03,060
assigning our behavior classes swimming

00:51:01,910 --> 00:51:06,020
duck quacking duck

00:51:03,060 --> 00:51:08,790
flying that to properties by using new

00:51:06,020 --> 00:51:11,490
so this class is now dependent on

00:51:08,790 --> 00:51:13,710
concretions because they are if you like

00:51:11,490 --> 00:51:17,160
concrete it in place we want to change

00:51:13,710 --> 00:51:19,470
the behaviors we have to change the

00:51:17,160 --> 00:51:21,270
source code right which as we've seen in

00:51:19,470 --> 00:51:26,910
open places something we want to try and

00:51:21,270 --> 00:51:28,290
avoid so we can adapt it and change it

00:51:26,910 --> 00:51:30,810
back to something like this where in the

00:51:28,290 --> 00:51:33,000
constructor we're passing in arguments

00:51:30,810 --> 00:51:34,620
we've got type hints and then we're

00:51:33,000 --> 00:51:37,590
assigning two properties inside the

00:51:34,620 --> 00:51:41,760
constructor body but what I want to note

00:51:37,590 --> 00:51:43,440
here is that in this example we've got

00:51:41,760 --> 00:51:46,230
swimming ducks quacking duck and a

00:51:43,440 --> 00:51:48,390
flying duck as the type hence those are

00:51:46,230 --> 00:51:50,640
not the interfaces we created earlier

00:51:48,390 --> 00:51:52,170
those are the concrete classes those are

00:51:50,640 --> 00:51:54,450
things which can be instantiated with

00:51:52,170 --> 00:51:59,670
new and deed we saw that on the previous

00:51:54,450 --> 00:52:01,410
slide but this class is now dependent on

00:51:59,670 --> 00:52:03,570
abstractions even though it's dependent

00:52:01,410 --> 00:52:05,370
on concrete classes because from the

00:52:03,570 --> 00:52:08,010
point of view of this class it doesn't

00:52:05,370 --> 00:52:09,570
know what swimming ducks quacking duck

00:52:08,010 --> 00:52:10,920
and flying that it doesn't know that

00:52:09,570 --> 00:52:12,720
they're concrete classes or whether

00:52:10,920 --> 00:52:15,510
they're interfaces it just knows that

00:52:12,720 --> 00:52:21,030
they are types with methods that it can

00:52:15,510 --> 00:52:22,980
depend on so if we want to change you

00:52:21,030 --> 00:52:25,410
know swimming duck into an interface for

00:52:22,980 --> 00:52:28,190
example at a later time we can do that

00:52:25,410 --> 00:52:31,020
and we don't have to change this class

00:52:28,190 --> 00:52:32,610
so dependency injection and the pen

00:52:31,020 --> 00:52:35,160
managing dependency inversion principle

00:52:32,610 --> 00:52:38,280
it's not necessarily about using

00:52:35,160 --> 00:52:40,050
interfaces like I said we could change

00:52:38,280 --> 00:52:42,660
those concrete classes to be

00:52:40,050 --> 00:52:44,730
abstractions to be abstract classes or

00:52:42,660 --> 00:52:47,160
interfaces if we wanted to in the future

00:52:44,730 --> 00:52:49,620
but the point is the choice is now ours

00:52:47,160 --> 00:52:52,080
it's not hardwired into that other class

00:52:49,620 --> 00:52:55,860
because it's dependent on abstract

00:52:52,080 --> 00:52:57,870
concepts I think we've seen plenty of

00:52:55,860 --> 00:53:01,590
good examples in this talk of the value

00:52:57,870 --> 00:53:03,930
encoding to interfaces but di

00:53:01,590 --> 00:53:07,230
does not mean you always have to do it

00:53:03,930 --> 00:53:09,210
as always evaluated pros and cons of

00:53:07,230 --> 00:53:12,560
each approach and make the appropriate

00:53:09,210 --> 00:53:12,560
choice for your use case

00:53:13,520 --> 00:53:19,430
dependency inversion is not necessarily

00:53:15,800 --> 00:53:21,950
about objects either go back to my

00:53:19,430 --> 00:53:25,340
example of brouilly Ruby and Scala as

00:53:21,950 --> 00:53:26,570
languages have fully object-oriented you

00:53:25,340 --> 00:53:30,050
could have a class which depends on

00:53:26,570 --> 00:53:31,700
strings or boolean or whatever and in

00:53:30,050 --> 00:53:33,740
those languages there still depending on

00:53:31,700 --> 00:53:37,010
objects just in PHP they're not they're

00:53:33,740 --> 00:53:40,220
not objects they're scalars so that has

00:53:37,010 --> 00:53:41,930
an example now a class called MySQL

00:53:40,220 --> 00:53:45,020
connection Factory and in the

00:53:41,930 --> 00:53:46,510
constructor we have the username and

00:53:45,020 --> 00:53:49,790
password for connecting to the database

00:53:46,510 --> 00:53:51,830
these are concrete strings this class is

00:53:49,790 --> 00:53:53,510
dependent on concretions because we

00:53:51,830 --> 00:53:56,360
can't change those strings without

00:53:53,510 --> 00:53:59,000
modifying the class it's in breach of

00:53:56,360 --> 00:54:01,670
OCP and it's in breach of dependency

00:53:59,000 --> 00:54:05,740
inversion a change of credentials

00:54:01,670 --> 00:54:08,780
requires a change in the source code so

00:54:05,740 --> 00:54:10,970
just like using dependency injection for

00:54:08,780 --> 00:54:12,890
objects we can inject strings in from

00:54:10,970 --> 00:54:14,060
the outside as well and it has what this

00:54:12,890 --> 00:54:15,890
looked like we just changed the

00:54:14,060 --> 00:54:19,340
constructor to pass in the values from

00:54:15,890 --> 00:54:21,440
the outside and now it's up to us where

00:54:19,340 --> 00:54:22,730
we store those values we can put them

00:54:21,440 --> 00:54:25,330
wherever we want we can put them in a

00:54:22,730 --> 00:54:30,220
settings file we could put them in

00:54:25,330 --> 00:54:30,220
environment variables it's up to us I

00:54:31,000 --> 00:54:36,560
said before that solid tends to put more

00:54:34,160 --> 00:54:38,960
burden onto the calling code and I think

00:54:36,560 --> 00:54:41,060
this is a good a good example of that so

00:54:38,960 --> 00:54:42,859
you can see like the bad version where

00:54:41,060 --> 00:54:45,859
we're not using dependency injection and

00:54:42,859 --> 00:54:48,770
we're dependent on completions it's two

00:54:45,859 --> 00:54:50,119
words and a semicolon but with

00:54:48,770 --> 00:54:52,369
dependency injection we're having to do

00:54:50,119 --> 00:54:55,040
more rowing to wire stuff together we're

00:54:52,369 --> 00:54:58,010
going to instantiate things and hook

00:54:55,040 --> 00:55:00,100
everything up this is where a dependency

00:54:58,010 --> 00:55:03,230
injection container can help you

00:55:00,100 --> 00:55:06,410
so there's several examples of DIY

00:55:03,230 --> 00:55:10,310
containers in PHP they include a pimple

00:55:06,410 --> 00:55:14,000
or in PHP di Zen service manager

00:55:10,310 --> 00:55:15,830
there's loads of others if you want to

00:55:14,000 --> 00:55:19,240
know more about those I would recommend

00:55:15,830 --> 00:55:21,619
going and reading their documentation

00:55:19,240 --> 00:55:24,190
they're very powerful tools di

00:55:21,619 --> 00:55:26,970
containers

00:55:24,190 --> 00:55:29,920
the trade-off of using them in my

00:55:26,970 --> 00:55:31,869
experience is that it can make your code

00:55:29,920 --> 00:55:33,819
flow a little harder to follow a little

00:55:31,869 --> 00:55:35,589
hard to reason about because you take

00:55:33,819 --> 00:55:37,510
the logic of wiring things together and

00:55:35,589 --> 00:55:39,190
you put it somewhere else that you've

00:55:37,510 --> 00:55:41,049
been going to go and look if you want to

00:55:39,190 --> 00:55:45,430
kind of work out and debug what's going

00:55:41,049 --> 00:55:48,780
on it's I think simplification through

00:55:45,430 --> 00:55:50,950
obfuscation and it's a little bit like

00:55:48,780 --> 00:55:52,299
tidying your house by throwing

00:55:50,950 --> 00:55:55,599
everything into the cupboard under the

00:55:52,299 --> 00:55:57,720
stairs you just moved the burden

00:55:55,599 --> 00:56:01,660
somewhere else

00:55:57,720 --> 00:56:03,690
so di C di containers are really useful

00:56:01,660 --> 00:56:06,130
tool for managing the pendency injection

00:56:03,690 --> 00:56:07,690
but you don't have to use one to do

00:56:06,130 --> 00:56:09,910
dependency injection and you don't have

00:56:07,690 --> 00:56:19,000
to use one to comply with the dependency

00:56:09,910 --> 00:56:20,230
inversion principle either now there

00:56:19,000 --> 00:56:21,420
you've got one more key note and then we

00:56:20,230 --> 00:56:24,819
can go to the party

00:56:21,420 --> 00:56:27,670
so in summary here are a few points that

00:56:24,819 --> 00:56:33,819
I ended up writing down after doing the

00:56:27,670 --> 00:56:35,740
research and writing this talk we spend

00:56:33,819 --> 00:56:40,630
more time reading our code than writing

00:56:35,740 --> 00:56:43,089
so we should optimize for reading as you

00:56:40,630 --> 00:56:45,279
keep our classes small specialized and

00:56:43,089 --> 00:56:47,740
simple because doing that means our

00:56:45,279 --> 00:56:52,150
classes are easier to maintain easier to

00:56:47,740 --> 00:56:54,549
extend easier to refactor we should save

00:56:52,150 --> 00:56:56,260
a composition over inheritance but

00:56:54,549 --> 00:57:00,700
realize that inheritance is a tool that

00:56:56,260 --> 00:57:02,770
has its uses just like any other we

00:57:00,700 --> 00:57:06,640
should make our pipes as specific as we

00:57:02,770 --> 00:57:10,539
can and use arrays sparingly it's not

00:57:06,640 --> 00:57:11,920
just through arrays and everything we

00:57:10,539 --> 00:57:14,289
need to create dependencies on the

00:57:11,920 --> 00:57:19,559
outside and pass them in and use

00:57:14,289 --> 00:57:22,390
interfaces when they're useful finally

00:57:19,559 --> 00:57:25,329
we need to always know our trade-off now

00:57:22,390 --> 00:57:27,309
our tool know the pros and cons be able

00:57:25,329 --> 00:57:31,180
to make the right decisions for our use

00:57:27,309 --> 00:57:33,160
cases thank you very much I've been

00:57:31,180 --> 00:57:35,020
Gareth Ellis this is my first conference

00:57:33,160 --> 00:57:38,630
talk so I really appreciate any feedback

00:57:35,020 --> 00:57:41,090
you can leave on joined in I will tweet

00:57:38,630 --> 00:57:42,740
the slides and a little while which will

00:57:41,090 --> 00:57:44,650
have all of these handy links in if you

00:57:42,740 --> 00:57:55,820
want to go and read any more about it

00:57:44,650 --> 00:57:59,440
and that is it got funky then we've got

00:57:55,820 --> 00:57:59,440
time for one question anyone's gone

00:58:11,479 --> 00:58:15,969
about solid or all the slides or

00:58:13,729 --> 00:58:15,969
whatever

00:58:16,119 --> 00:58:19,489
Wikipedia's got a good start solid and

00:58:18,440 --> 00:58:21,680
then there's an article about each

00:58:19,489 --> 00:58:22,999
individual principle and as loads of

00:58:21,680 --> 00:58:25,339
blog posts where people have written

00:58:22,999 --> 00:58:28,039
their interpretations of the rules the

00:58:25,339 --> 00:58:29,930
head first design patterns talks about

00:58:28,039 --> 00:58:31,279
each design pattern look quite a lot of

00:58:29,930 --> 00:58:33,559
it so this will help you meet this

00:58:31,279 --> 00:58:34,579
guideline and it references solid and

00:58:33,559 --> 00:58:37,509
stuff so that's another really good

00:58:34,579 --> 00:58:40,360
resource okay

00:58:37,509 --> 00:58:46,039
okay thank you very much everyone

00:58:40,360 --> 00:58:46,039

YouTube URL: https://www.youtube.com/watch?v=86Tt2pW9pv4


