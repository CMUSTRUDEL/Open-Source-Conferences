Title: PHP UK Conference 2017 - Adam Englander - Donâ€™t Lose Sleep, Secure Your REST
Publication date: 2017-04-03
Playlist: PHP UK Conference 2017
Description: 
	Are you worried that your REST API may be the next victim of an attack by ruthless hackers? Don't fret. Utilizing the same standards implemented by OAuth 2.0 and OpenID Connect, you can secure your REST API. Open and proven standards are the best ways to secure your REST APIs for now and well into the future. JSON Object Signing and Encryption (JOSE) is the core of a truly secure standards based REST API. In this talk, you will learn how to use the components of JOSE to secure your REAST API for now and the future.
Captions: 
	00:00:03,740 --> 00:00:09,530
good afternoon hope everybody's excited

00:00:07,730 --> 00:00:13,570
to be here and then bright lights from

00:00:09,530 --> 00:00:16,970
big city my name is Adam Englander I'm a

00:00:13,570 --> 00:00:19,160
engineer at Salvation and I'm here to

00:00:16,970 --> 00:00:22,820
talk about something that we've recently

00:00:19,160 --> 00:00:26,329
done using Jose just secured our REST

00:00:22,820 --> 00:00:28,460
API so I want to first I want to give a

00:00:26,329 --> 00:00:31,730
little bit of the background about

00:00:28,460 --> 00:00:32,840
myself at API so maybe you can hopefully

00:00:31,730 --> 00:00:34,910
think I know I'm gonna talk about a

00:00:32,840 --> 00:00:36,710
little bit so this is what I look like

00:00:34,910 --> 00:00:39,500
when I started writing API that was a

00:00:36,710 --> 00:00:42,769
long time ago it was so long ago that

00:00:39,500 --> 00:00:48,620
soap was the new hotness that was a long

00:00:42,769 --> 00:00:50,629
time ago and my career I've actually

00:00:48,620 --> 00:00:52,280
spent which is kind of odd as a PHP

00:00:50,629 --> 00:00:54,079
developer I spent more time in my career

00:00:52,280 --> 00:00:58,909
writing api's and I have building

00:00:54,079 --> 00:01:01,850
websites so since 2001 I've been working

00:00:58,909 --> 00:01:03,379
on a lot of different api's my first one

00:01:01,850 --> 00:01:06,080
was a global authentication service

00:01:03,379 --> 00:01:07,670
although that was Java and then I

00:01:06,080 --> 00:01:09,890
started doing a lot of stuff with API is

00:01:07,670 --> 00:01:13,070
in PHP with a loan application ping tree

00:01:09,890 --> 00:01:15,619
and a loan management system worked full

00:01:13,070 --> 00:01:17,960
on an advertising network API which is

00:01:15,619 --> 00:01:21,649
really my first attempt at a really high

00:01:17,960 --> 00:01:25,130
volume API and then a real-time loan

00:01:21,649 --> 00:01:26,960
risk assessment system which was an API

00:01:25,130 --> 00:01:28,520
that just talked to other API so I got

00:01:26,960 --> 00:01:30,770
to experience how difficult it was to

00:01:28,520 --> 00:01:33,009
make a good API and at the same time

00:01:30,770 --> 00:01:36,200
consume other people's terrible api's

00:01:33,009 --> 00:01:38,060
and in 2015 I started working for where

00:01:36,200 --> 00:01:40,189
I'm working now which is a launch key

00:01:38,060 --> 00:01:41,810
now I Ovation and I work on a

00:01:40,189 --> 00:01:45,310
decentralized multi-factor off with

00:01:41,810 --> 00:01:48,500
authorization API a lot of words and

00:01:45,310 --> 00:01:51,979
through this time some are more secure

00:01:48,500 --> 00:01:53,359
than others I am a little embarrassed to

00:01:51,979 --> 00:01:56,149
say that I was in fin tech and I was

00:01:53,359 --> 00:01:57,619
working on actual financial stuff that

00:01:56,149 --> 00:01:57,950
was nowhere near as secure as it should

00:01:57,619 --> 00:02:00,710
be

00:01:57,950 --> 00:02:02,119
I thought I was doing the right thing

00:02:00,710 --> 00:02:03,500
when I started to work for an actual

00:02:02,119 --> 00:02:07,820
security company I learned just really

00:02:03,500 --> 00:02:10,610
how bad it was but neither of those were

00:02:07,820 --> 00:02:11,990
hacked so and they've gotten better

00:02:10,610 --> 00:02:14,690
since I left so I don't feel too

00:02:11,990 --> 00:02:16,400
terribly bad about it but in all of

00:02:14,690 --> 00:02:17,959
these api's

00:02:16,400 --> 00:02:20,810
I made these experiences felt yourself

00:02:17,959 --> 00:02:25,370
if you're writing ap is often crypto is

00:02:20,810 --> 00:02:27,470
messy when you add the off to the

00:02:25,370 --> 00:02:29,599
message it adds complexity on the

00:02:27,470 --> 00:02:31,069
backend it where you have to be able to

00:02:29,599 --> 00:02:32,000
parse the message to be able to just

00:02:31,069 --> 00:02:34,640
deal with the fact that someone is

00:02:32,000 --> 00:02:35,959
giving you credentials when you remove

00:02:34,640 --> 00:02:38,390
it outside of the message you lose

00:02:35,959 --> 00:02:39,980
context you're not quite sure what's

00:02:38,390 --> 00:02:43,010
going on with what it's actually trying

00:02:39,980 --> 00:02:46,159
to authorize for every implementation

00:02:43,010 --> 00:02:48,340
was specialized every time you did it

00:02:46,159 --> 00:02:50,959
you did it differently it depended on

00:02:48,340 --> 00:02:53,269
what the application was doing what you

00:02:50,959 --> 00:02:54,680
needed to accomplish so every time even

00:02:53,269 --> 00:02:56,959
even in the same company when I would

00:02:54,680 --> 00:02:59,870
move from division to division or just

00:02:56,959 --> 00:03:01,579
one app to another in the same group how

00:02:59,870 --> 00:03:03,620
did it authentication was different how

00:03:01,579 --> 00:03:05,030
did encryption if they did it all was

00:03:03,620 --> 00:03:06,139
very different how you validate the

00:03:05,030 --> 00:03:09,680
request in the response was very

00:03:06,139 --> 00:03:12,139
different and crypto was non-standard

00:03:09,680 --> 00:03:14,060
and static which meant that if you

00:03:12,139 --> 00:03:16,069
wanted to upgrade your crypto that you

00:03:14,060 --> 00:03:18,700
had to completely change your API which

00:03:16,069 --> 00:03:21,319
is not great because if you've been

00:03:18,700 --> 00:03:22,910
working in in development for a while

00:03:21,319 --> 00:03:27,500
you know that hey when I started working

00:03:22,910 --> 00:03:30,230
with PHP and that 2005 API it was

00:03:27,500 --> 00:03:31,810
perfectly okay to use things that we

00:03:30,230 --> 00:03:35,030
would not consider safe now

00:03:31,810 --> 00:03:37,909
absolutely fine then terrible now I mean

00:03:35,030 --> 00:03:40,099
there was a time when a sha-256 password

00:03:37,909 --> 00:03:41,239
was considered super safe right we know

00:03:40,099 --> 00:03:43,699
that's just not the case today

00:03:41,239 --> 00:03:47,540
and the worst part about it is is that

00:03:43,699 --> 00:03:49,549
not experts like myself had to write a

00:03:47,540 --> 00:03:51,590
lot of code that dealt with cryptography

00:03:49,549 --> 00:03:53,120
and signature verification and message

00:03:51,590 --> 00:03:57,079
validation and authentication

00:03:53,120 --> 00:04:00,530
authorization which is not great I'm not

00:03:57,079 --> 00:04:01,639
a fan and I was I mean I was not a fan

00:04:00,530 --> 00:04:03,349
of doing it there and having to learn

00:04:01,639 --> 00:04:04,639
everything but a little bit that you can

00:04:03,349 --> 00:04:09,859
pick up trying to figure it out isn't

00:04:04,639 --> 00:04:11,900
super helpful so for me 2015 changed all

00:04:09,859 --> 00:04:15,709
of that

00:04:11,900 --> 00:04:18,139
IETF RFC 75 23 it may not mean much to

00:04:15,709 --> 00:04:20,570
you but it meant a lot to me and that is

00:04:18,139 --> 00:04:22,460
the JSON web token profile for oauth2

00:04:20,570 --> 00:04:26,419
client authentication authorization

00:04:22,460 --> 00:04:29,469
grant big long word but what that meant

00:04:26,419 --> 00:04:29,469
is that

00:04:29,520 --> 00:04:35,430
javascript object signing and embedding

00:04:31,319 --> 00:04:37,620
or encryption went mainstream and this

00:04:35,430 --> 00:04:39,270
talk is primarily around Jose which is

00:04:37,620 --> 00:04:42,509
the JavaScript object and funny

00:04:39,270 --> 00:04:47,990
encryption and the reason it was such a

00:04:42,509 --> 00:04:50,300
big deal is that this was an RFC where

00:04:47,990 --> 00:04:53,310
authentication authorization encryption

00:04:50,300 --> 00:04:55,710
data integrity validation are not tied

00:04:53,310 --> 00:04:58,289
to the protocol so if you look at all

00:04:55,710 --> 00:05:00,030
these other rfcs they're all basically

00:04:58,289 --> 00:05:01,470
tied to if you're making this kind of

00:05:00,030 --> 00:05:04,319
request and this is your authorization

00:05:01,470 --> 00:05:07,530
it's very rare that you have a gigantic

00:05:04,319 --> 00:05:08,419
specification it's not based on single

00:05:07,530 --> 00:05:11,940
sign-on

00:05:08,419 --> 00:05:14,310
that is around how to encrypt data how

00:05:11,940 --> 00:05:16,550
to transmit data how to verify and

00:05:14,310 --> 00:05:20,009
validate information how to authorize

00:05:16,550 --> 00:05:21,240
and how to authenticate it has nothing

00:05:20,009 --> 00:05:25,650
to do with the the underlying

00:05:21,240 --> 00:05:29,159
implementation and it was used initially

00:05:25,650 --> 00:05:31,949
for OAuth ooofff 2.0 it was added as an

00:05:29,159 --> 00:05:35,580
implementation for all 2.0 which then

00:05:31,949 --> 00:05:38,820
became open ID Connect open ID Connect

00:05:35,580 --> 00:05:40,409
is based on that it was also actually

00:05:38,820 --> 00:05:42,389
earlier little earlier on adopted by

00:05:40,409 --> 00:05:44,550
Fido and if you don't know what these

00:05:42,389 --> 00:05:46,409
things are it's not a big deal it's a

00:05:44,550 --> 00:05:48,870
big deal to me because if you add in one

00:05:46,409 --> 00:05:50,190
more acronym called sam'l that is every

00:05:48,870 --> 00:05:52,889
authentication protocol in the modern

00:05:50,190 --> 00:05:55,919
world so with the exception of sam'l

00:05:52,889 --> 00:05:57,810
which uses some terrible XML all these

00:05:55,919 --> 00:06:01,080
other things to use Jose this javascript

00:05:57,810 --> 00:06:03,090
object signing an encryption and because

00:06:01,080 --> 00:06:05,940
they did that what they did is they

00:06:03,090 --> 00:06:08,009
created I mean there's a lot of IETF

00:06:05,940 --> 00:06:10,560
standards but they added credibility of

00:06:08,009 --> 00:06:13,380
stability of longevity right ooofff is

00:06:10,560 --> 00:06:16,860
not going away a hope an ID is not going

00:06:13,380 --> 00:06:18,630
away Fido may or may not succeed we're

00:06:16,860 --> 00:06:20,069
still finding out I mean my company's a

00:06:18,630 --> 00:06:21,870
member of the phyto Alliance but

00:06:20,069 --> 00:06:25,169
nobody's ever actually brought anything

00:06:21,870 --> 00:06:27,479
out really big but this meant that I

00:06:25,169 --> 00:06:28,979
could use this without worrying about

00:06:27,479 --> 00:06:31,349
whether it's going to go away it's going

00:06:28,979 --> 00:06:32,569
to change drastically right the fact

00:06:31,349 --> 00:06:35,639
that when you log in with Facebook

00:06:32,569 --> 00:06:36,900
you're using Jose tells me that I don't

00:06:35,639 --> 00:06:39,570
have to worry that they're going to have

00:06:36,900 --> 00:06:41,279
some gigantic braking change when they

00:06:39,570 --> 00:06:42,400
find this little bitty bug that destroys

00:06:41,279 --> 00:06:47,920
the world with the

00:06:42,400 --> 00:06:50,680
so I was exciting for me and so when I

00:06:47,920 --> 00:06:54,190
got that we we decided we wanted to use

00:06:50,680 --> 00:06:55,720
this inside our launch key product and a

00:06:54,190 --> 00:06:59,140
lot of this talk is about a case study

00:06:55,720 --> 00:07:02,590
on what we were what we became and how

00:06:59,140 --> 00:07:05,880
he went about that using Hosea because

00:07:02,590 --> 00:07:08,140
it really transformed our entire API and

00:07:05,880 --> 00:07:10,150
to give a little background so launch

00:07:08,140 --> 00:07:13,240
key is a multi-factor authentication and

00:07:10,150 --> 00:07:16,390
authorization service which means you

00:07:13,240 --> 00:07:19,360
use us to authenticate which means it

00:07:16,390 --> 00:07:23,080
needs to be super secure it's got to be

00:07:19,360 --> 00:07:25,540
super secure and so version one was

00:07:23,080 --> 00:07:29,160
before time start off about four years

00:07:25,540 --> 00:07:31,930
ago and it was a the data was rest ish

00:07:29,160 --> 00:07:35,200
it was a really poor representation of

00:07:31,930 --> 00:07:39,580
rest didn't really use HTTP status codes

00:07:35,200 --> 00:07:41,170
very well put a lot of terrible things

00:07:39,580 --> 00:07:47,110
in the query parameters that wrote that

00:07:41,170 --> 00:07:49,510
1024 master of protocol limit it was

00:07:47,110 --> 00:07:51,820
mostly form encoded requests mostly not

00:07:49,510 --> 00:07:55,030
all for post put and delete and it had

00:07:51,820 --> 00:07:57,040
JSON responses so the data was kind of a

00:07:55,030 --> 00:07:58,960
mishmash depending on what got slapped

00:07:57,040 --> 00:08:02,050
on here and there sometimes even had

00:07:58,960 --> 00:08:03,220
like credentials in the in the when we

00:08:02,050 --> 00:08:05,050
were passing JSON there's I think

00:08:03,220 --> 00:08:07,810
there's one end point and the old one

00:08:05,050 --> 00:08:10,150
that passes JSON as the data and the

00:08:07,810 --> 00:08:12,400
encryption is the signature is actually

00:08:10,150 --> 00:08:15,640
in the query parameters it's really it's

00:08:12,400 --> 00:08:18,670
really unpleasant and it but it still

00:08:15,640 --> 00:08:21,660
exists today credentials so it had SCI

00:08:18,670 --> 00:08:25,180
loading credentials for entity types so

00:08:21,660 --> 00:08:26,110
if you needed if you had two different

00:08:25,180 --> 00:08:27,670
things you're interacting with an

00:08:26,110 --> 00:08:29,020
organization level or an application

00:08:27,670 --> 00:08:31,510
level if you had two sets of credentials

00:08:29,020 --> 00:08:33,760
and you just had to use know which one

00:08:31,510 --> 00:08:35,669
you're going to be interacting with it

00:08:33,760 --> 00:08:37,720
used random integers for identifiers

00:08:35,669 --> 00:08:41,530
passwords were sent in an encrypted

00:08:37,720 --> 00:08:43,180
package and password rotation was old

00:08:41,530 --> 00:08:44,980
passwords expiring one after the new

00:08:43,180 --> 00:08:46,900
password was generated method we'd have

00:08:44,980 --> 00:08:48,610
to hash for your new password your old

00:08:46,900 --> 00:08:51,460
password if one of them was good we were

00:08:48,610 --> 00:08:55,090
okay wasn't great but even but it worked

00:08:51,460 --> 00:08:59,680
and for cryptography we had

00:08:55,090 --> 00:09:02,350
good cryptography it was RSA OAP 256 we

00:08:59,680 --> 00:09:04,630
use AES 256 cbc and had really good

00:09:02,350 --> 00:09:07,320
shots of 36 RSA signatures for portions

00:09:04,630 --> 00:09:09,460
of the package but because of the

00:09:07,320 --> 00:09:12,250
limitations on what you can encrypt

00:09:09,460 --> 00:09:15,010
using RSA sometimes we didn't AES which

00:09:12,250 --> 00:09:17,290
meant that you had you had to have a

00:09:15,010 --> 00:09:18,460
shared secret for that to actually be

00:09:17,290 --> 00:09:21,100
work because it's a symmetric encryption

00:09:18,460 --> 00:09:23,860
and some of it which is most of the

00:09:21,100 --> 00:09:25,779
application interaction was using RSA

00:09:23,860 --> 00:09:27,430
for encryption so sometimes was 1 and

00:09:25,779 --> 00:09:31,990
sometimes was the other you never really

00:09:27,430 --> 00:09:34,510
knew on the security side it used did

00:09:31,990 --> 00:09:36,730
replay prevention using our cluster ID

00:09:34,510 --> 00:09:38,320
and a timestamp it did signature

00:09:36,730 --> 00:09:39,700
verification on the password the

00:09:38,320 --> 00:09:42,160
timestamp only because that was the

00:09:39,700 --> 00:09:44,260
encrypted part it encrypted the password

00:09:42,160 --> 00:09:48,700
the timestamp and it rate limited by

00:09:44,260 --> 00:09:50,350
user ID and subject so the good part

00:09:48,700 --> 00:09:54,370
about this this API is that it was

00:09:50,350 --> 00:09:56,380
really secure the API was never

00:09:54,370 --> 00:09:56,800
compromised we had a bug bounty for four

00:09:56,380 --> 00:10:00,820
years

00:09:56,800 --> 00:10:02,890
and it was never compromised it passed a

00:10:00,820 --> 00:10:05,320
ton of static and dynamic analysis by

00:10:02,890 --> 00:10:06,850
top security firms and even you know we

00:10:05,320 --> 00:10:09,750
were recently acquired and we were in

00:10:06,850 --> 00:10:12,100
the acquisition market and had been

00:10:09,750 --> 00:10:13,750
evaluated by some very large security

00:10:12,100 --> 00:10:16,120
companies and we passed all their tests

00:10:13,750 --> 00:10:18,010
because no one's ever been able to

00:10:16,120 --> 00:10:21,280
fabricate an authorization which is

00:10:18,010 --> 00:10:25,360
fantastic but what we care about in this

00:10:21,280 --> 00:10:28,210
room can you use it right it was

00:10:25,360 --> 00:10:32,110
terrible for usability before I was

00:10:28,210 --> 00:10:33,190
working at launch key I I know some of

00:10:32,110 --> 00:10:35,890
the developers there I've worked with

00:10:33,190 --> 00:10:37,089
him at the FinTech job and we had a

00:10:35,890 --> 00:10:41,530
little hackathon and I was like oh I

00:10:37,089 --> 00:10:42,880
want to write you an SDK and I spent a

00:10:41,530 --> 00:10:44,800
day in their office trying to write an

00:10:42,880 --> 00:10:49,510
SDK and I did not finish in a day

00:10:44,800 --> 00:10:51,010
writing an SDK because nothing was the

00:10:49,510 --> 00:10:53,529
same depending on what call you made

00:10:51,010 --> 00:10:54,850
depending on how the data was set up the

00:10:53,529 --> 00:11:00,970
encryption was different from call to

00:10:54,850 --> 00:11:04,240
call it was not restful it just it's

00:11:00,970 --> 00:11:06,310
kind of bizarre to many credentials to

00:11:04,240 --> 00:11:08,480
manage I heard that a lot so I've

00:11:06,310 --> 00:11:09,970
started working at launch key

00:11:08,480 --> 00:11:13,459
my job was to help implementers

00:11:09,970 --> 00:11:15,740
implement our SDK and no one could

00:11:13,459 --> 00:11:18,230
figure out which I would get these chats

00:11:15,740 --> 00:11:19,790
and these emails and people having

00:11:18,230 --> 00:11:22,220
problems and it's they're using the

00:11:19,790 --> 00:11:23,510
wrong keys in the wrong place well it's

00:11:22,220 --> 00:11:24,920
that's not their fault right that's my

00:11:23,510 --> 00:11:26,329
fault because it's a terrible terrible

00:11:24,920 --> 00:11:28,040
way to go about it

00:11:26,329 --> 00:11:30,800
and there was no way to properly rotate

00:11:28,040 --> 00:11:31,250
your financials so if your RS a private

00:11:30,800 --> 00:11:32,570
key

00:11:31,250 --> 00:11:33,889
you're afraid that it might have been

00:11:32,570 --> 00:11:35,779
compromised you need to change it out

00:11:33,889 --> 00:11:37,250
you're going to have downtime because

00:11:35,779 --> 00:11:38,449
you've got to go change in your code

00:11:37,250 --> 00:11:39,949
you've got to go change it on our server

00:11:38,449 --> 00:11:41,990
one of those is going to get done first

00:11:39,949 --> 00:11:47,060
and you're going to have downtime which

00:11:41,990 --> 00:11:48,920
is bad so we moved to version 2

00:11:47,060 --> 00:11:50,480
it was almost awesome but it was an

00:11:48,920 --> 00:11:53,360
attempt at making it better via open

00:11:50,480 --> 00:11:54,860
standards and that's where JSON web

00:11:53,360 --> 00:11:57,730
token came in the first time I really

00:11:54,860 --> 00:12:01,639
actually looked at it because our our

00:11:57,730 --> 00:12:03,829
lead engineer said we're we're going to

00:12:01,639 --> 00:12:05,480
use this and we're going to use this on

00:12:03,829 --> 00:12:06,589
the mobile side because that's what we

00:12:05,480 --> 00:12:08,690
had a lot of control over we have a

00:12:06,589 --> 00:12:10,040
mobile app that we interact with so it

00:12:08,690 --> 00:12:11,420
said we're going to use JSON web token

00:12:10,040 --> 00:12:14,690
to do signatures and all the type of

00:12:11,420 --> 00:12:15,949
stuff with requests back and forth for

00:12:14,690 --> 00:12:19,220
the mobile side and we'll eventually

00:12:15,949 --> 00:12:20,899
move everything else to that and when it

00:12:19,220 --> 00:12:22,420
gave us is that we we started using an

00:12:20,899 --> 00:12:25,160
open standard for data security

00:12:22,420 --> 00:12:28,190
we added private claims for a hash of

00:12:25,160 --> 00:12:32,480
the body so we had a much more we had a

00:12:28,190 --> 00:12:34,940
way better validation process and we had

00:12:32,480 --> 00:12:36,560
a more secure API request format which

00:12:34,940 --> 00:12:38,839
is all fantastic JWT does fantastic

00:12:36,560 --> 00:12:41,089
things for you but we're still missing

00:12:38,839 --> 00:12:43,610
things we were still using custom and

00:12:41,089 --> 00:12:46,100
inconsistent encryption because we

00:12:43,610 --> 00:12:49,519
weren't using jwe we didn't increase the

00:12:46,100 --> 00:12:53,149
restful quality of it we didn't sign the

00:12:49,519 --> 00:12:55,069
entire request we just did the body I'll

00:12:53,149 --> 00:12:57,199
get in that a little bit and we did not

00:12:55,069 --> 00:12:58,760
reduce the quantity of credentials and

00:12:57,199 --> 00:13:00,050
we didn't improve the response so the

00:12:58,760 --> 00:13:01,160
response just kind of came back and you

00:13:00,050 --> 00:13:02,750
had to trust that that was the response

00:13:01,160 --> 00:13:04,250
you're expecting that someone hadn't

00:13:02,750 --> 00:13:05,540
given you a man-in-the-middle attack now

00:13:04,250 --> 00:13:08,420
in our mobile device is not a big deal

00:13:05,540 --> 00:13:11,440
we do certificate pinning but on the

00:13:08,420 --> 00:13:14,420
other side for api's as an implementer

00:13:11,440 --> 00:13:16,010
doing pinning isn't a great thing to do

00:13:14,420 --> 00:13:18,260
if you don't know how to do it and it's

00:13:16,010 --> 00:13:21,350
it can be problematic when search change

00:13:18,260 --> 00:13:24,010
and you have to be kind of up on that

00:13:21,350 --> 00:13:26,450
so we came up with a pi/3 were required

00:13:24,010 --> 00:13:29,900
and we were told that we had to move

00:13:26,450 --> 00:13:31,630
from processing I think it was 3,000

00:13:29,900 --> 00:13:34,000
requests an hour to 10,000 a minute

00:13:31,630 --> 00:13:37,460
which then we got to rewrite our API and

00:13:34,000 --> 00:13:39,020
when we're rewriting our API we decided

00:13:37,460 --> 00:13:41,960
that well let's let's do this right

00:13:39,020 --> 00:13:43,310
let's let's go version 3 and we're going

00:13:41,960 --> 00:13:44,360
to actually do the security stuff right

00:13:43,310 --> 00:13:45,890
because we're going to sense we're

00:13:44,360 --> 00:13:51,050
rewriting everything let's not make it

00:13:45,890 --> 00:13:55,310
hard so what we changed is everything so

00:13:51,050 --> 00:13:57,110
we use JWT JSON web token with custom

00:13:55,310 --> 00:14:00,020
claims to validate the entire request

00:13:57,110 --> 00:14:02,090
and critical portions of the response we

00:14:00,020 --> 00:14:05,660
use JSON web encryption to encrypt the

00:14:02,090 --> 00:14:07,700
request and the response we use JSON web

00:14:05,660 --> 00:14:11,240
algorithms to future-proof our

00:14:07,700 --> 00:14:13,130
cryptography we use JSON web keys for

00:14:11,240 --> 00:14:14,540
credential rollcage rotation and we

00:14:13,130 --> 00:14:16,220
remove that little password that you

00:14:14,540 --> 00:14:18,130
used to send the encrypted thing all

00:14:16,220 --> 00:14:20,420
together is it wasn't necessary anymore

00:14:18,130 --> 00:14:24,380
because we could validate all that stuff

00:14:20,420 --> 00:14:28,940
with RSA and we got some immediate

00:14:24,380 --> 00:14:32,090
benefit on the development side because

00:14:28,940 --> 00:14:34,730
we're able to decouple authorization

00:14:32,090 --> 00:14:36,830
authentication and validation of

00:14:34,730 --> 00:14:39,050
requested responses with the actual

00:14:36,830 --> 00:14:41,720
controller's so we're able to move all

00:14:39,050 --> 00:14:43,310
that to middleware so it when you we

00:14:41,720 --> 00:14:44,690
have to write tasks for our controllers

00:14:43,310 --> 00:14:47,770
because you're doing all this encryption

00:14:44,690 --> 00:14:49,910
and encryption decryption authentication

00:14:47,770 --> 00:14:51,320
signatures validating signatures like

00:14:49,910 --> 00:14:52,970
that's a lot of things that you're doing

00:14:51,320 --> 00:14:57,560
before you even start processing the

00:14:52,970 --> 00:15:00,290
request but all those pieces were part

00:14:57,560 --> 00:15:03,530
of the requests coming in so they were

00:15:00,290 --> 00:15:04,790
tightly coupled and so now with Jose

00:15:03,530 --> 00:15:07,160
you're allowed to separate that out

00:15:04,790 --> 00:15:09,500
where you've got this data that's part

00:15:07,160 --> 00:15:12,080
of your request that still has contact

00:15:09,500 --> 00:15:16,040
but it's not part of your actual request

00:15:12,080 --> 00:15:17,960
packet and so in a stroke of genius we

00:15:16,040 --> 00:15:19,550
decided we'll move it to middleware so

00:15:17,960 --> 00:15:21,200
that all of our controllers deal with is

00:15:19,550 --> 00:15:24,380
the fact that I've got a JSON request

00:15:21,200 --> 00:15:26,060
for an endpoint and that's it all the

00:15:24,380 --> 00:15:27,740
decryption signature validation

00:15:26,060 --> 00:15:29,720
determining what entity is making the

00:15:27,740 --> 00:15:31,070
request determined it has access to be

00:15:29,720 --> 00:15:32,840
able to do that all that happens in

00:15:31,070 --> 00:15:35,540
middleware now from all the information

00:15:32,840 --> 00:15:37,670
that's provided in the JWT

00:15:35,540 --> 00:15:39,350
and they gave us way better unit testing

00:15:37,670 --> 00:15:40,730
all right I don't have to mock six

00:15:39,350 --> 00:15:42,790
hundred interactions before I actually

00:15:40,730 --> 00:15:45,530
get to the code I'm trying to work with

00:15:42,790 --> 00:15:47,030
we had controllers and it's not all of

00:15:45,530 --> 00:15:49,030
security fault but we had controllers

00:15:47,030 --> 00:15:51,080
that were hundreds of lines long

00:15:49,030 --> 00:15:52,970
hundreds of lines long four before it

00:15:51,080 --> 00:15:55,520
got to the single service hundreds of

00:15:52,970 --> 00:16:00,890
lines it's really difficult to test that

00:15:55,520 --> 00:16:02,900
and moving all of this stuff out made it

00:16:00,890 --> 00:16:05,120
so much easier to just add new

00:16:02,900 --> 00:16:08,030
functionality right it would take days

00:16:05,120 --> 00:16:11,120
to add an endpoint in the old system in

00:16:08,030 --> 00:16:12,410
the new system it it's usually if the

00:16:11,120 --> 00:16:14,750
service is already written to interact

00:16:12,410 --> 00:16:16,580
with that part of the data it takes us

00:16:14,750 --> 00:16:17,630
20 30 minutes to write a new endpoints

00:16:16,580 --> 00:16:19,520
people to interact with the existing

00:16:17,630 --> 00:16:21,920
functionality so if I need to move it

00:16:19,520 --> 00:16:23,500
from this part of the this level of the

00:16:21,920 --> 00:16:25,730
API needs to interact with a particular

00:16:23,500 --> 00:16:27,500
service and another level needs to do it

00:16:25,730 --> 00:16:29,030
it's just super easy I know I've already

00:16:27,500 --> 00:16:30,800
got the validation verification I know

00:16:29,030 --> 00:16:32,240
what they have access to the URL so I

00:16:30,800 --> 00:16:33,800
don't have to worry about that I've got

00:16:32,240 --> 00:16:36,470
the entity interacting and I just

00:16:33,800 --> 00:16:38,330
perform the interaction is really really

00:16:36,470 --> 00:16:39,860
streamlining it's really really awesome

00:16:38,330 --> 00:16:43,100
because it was really it was really

00:16:39,860 --> 00:16:46,160
difficult to make changes the other good

00:16:43,100 --> 00:16:50,780
thing that I'm super excited about OSS

00:16:46,160 --> 00:16:52,790
libraries I can now test my API full

00:16:50,780 --> 00:16:56,270
integration test without having to use

00:16:52,790 --> 00:16:58,940
my client SDK it was so hard to write

00:16:56,270 --> 00:17:00,650
all of the code to do the signature

00:16:58,940 --> 00:17:02,210
creation and verification validation

00:17:00,650 --> 00:17:03,530
encryption all that type of stuff

00:17:02,210 --> 00:17:05,420
there's the only way that we could test

00:17:03,530 --> 00:17:08,540
our own systems was using our own SDK so

00:17:05,420 --> 00:17:11,329
if we introduced a bug in our SDK our

00:17:08,540 --> 00:17:15,199
test would fail or not which is actually

00:17:11,329 --> 00:17:17,240
worse the client SDKs became less

00:17:15,199 --> 00:17:19,040
complex I don't have to write all this

00:17:17,240 --> 00:17:21,920
information for doing signatures and

00:17:19,040 --> 00:17:23,690
encryption and decryption and OSS

00:17:21,920 --> 00:17:27,380
contributions are actually possible now

00:17:23,690 --> 00:17:29,240
like we have I think one contributed

00:17:27,380 --> 00:17:34,430
decent SDK out there that the community

00:17:29,240 --> 00:17:36,260
has contributed it's a go SDK but

00:17:34,430 --> 00:17:38,510
speaking from my own personal experience

00:17:36,260 --> 00:17:39,650
of trying to do that I tried to

00:17:38,510 --> 00:17:41,420
implement a launch guess DK and I

00:17:39,650 --> 00:17:44,360
couldn't do it and I had the developers

00:17:41,420 --> 00:17:47,940
in the room with me helping me and I

00:17:44,360 --> 00:17:49,840
still couldn't do it not in a day

00:17:47,940 --> 00:17:51,760
and another one I write all the

00:17:49,840 --> 00:17:54,340
documentation I'm transitioning out of

00:17:51,760 --> 00:17:57,010
that thinking this but documentation

00:17:54,340 --> 00:17:58,299
complexity was reduced you're just using

00:17:57,010 --> 00:18:01,870
this library that's already documented

00:17:58,299 --> 00:18:04,740
somewhere else super helpful the other

00:18:01,870 --> 00:18:07,630
thing that does is it creates you

00:18:04,740 --> 00:18:09,970
uniformly across our API so now in our

00:18:07,630 --> 00:18:11,380
organization works completely switching

00:18:09,970 --> 00:18:13,570
to Jose we've got all these different

00:18:11,380 --> 00:18:15,159
ways to allocation authorization but as

00:18:13,570 --> 00:18:16,299
an organization they found out what we

00:18:15,159 --> 00:18:18,130
were doing and in the review process

00:18:16,299 --> 00:18:20,080
because we do peer review across groups

00:18:18,130 --> 00:18:21,990
they said that's that's a way better way

00:18:20,080 --> 00:18:24,159
of doing this we're all going to do this

00:18:21,990 --> 00:18:26,789
and we actually because we work together

00:18:24,159 --> 00:18:29,289
and killed with a much better solution

00:18:26,789 --> 00:18:30,610
which gives us shared knowledge right

00:18:29,289 --> 00:18:32,470
because if you move from group to group

00:18:30,610 --> 00:18:34,870
trying to figure out how you're doing

00:18:32,470 --> 00:18:36,370
off is usually pretty tough and now we

00:18:34,870 --> 00:18:41,289
also have the option for federated

00:18:36,370 --> 00:18:43,570
authorization and the other good thing

00:18:41,289 --> 00:18:47,470
is that because of the way that JWT

00:18:43,570 --> 00:18:49,510
works is it allowed us to using its own

00:18:47,470 --> 00:18:53,710
internal workings use hierarchical

00:18:49,510 --> 00:18:55,809
authentication because JWT has this idea

00:18:53,710 --> 00:18:58,029
of an issuer and a subject and an

00:18:55,809 --> 00:19:01,510
audience and so what we're able to do is

00:18:58,029 --> 00:19:03,970
say hi I'm ABC organization I would like

00:19:01,510 --> 00:19:08,130
to make this request for application 1 2

00:19:03,970 --> 00:19:10,090
3 I've got an issuer I've got a subject

00:19:08,130 --> 00:19:11,740
inside of my middleware without knowing

00:19:10,090 --> 00:19:13,000
anything else I other know this is an

00:19:11,740 --> 00:19:14,860
issue where this is a subject I can

00:19:13,000 --> 00:19:16,390
determine if this issuers allowed to

00:19:14,860 --> 00:19:19,179
make a request for the subject and if so

00:19:16,390 --> 00:19:20,559
I just pass along and I'm my my

00:19:19,179 --> 00:19:22,750
controller just knows that it has a

00:19:20,559 --> 00:19:27,039
subject entity it's all it knows it's

00:19:22,750 --> 00:19:28,270
just got a subject and it also allows us

00:19:27,039 --> 00:19:33,460
to kind of change it however we want

00:19:28,270 --> 00:19:36,640
with our middleware and jwk JSON web

00:19:33,460 --> 00:19:39,100
Keys allows for identification of the

00:19:36,640 --> 00:19:42,880
credentials used so when someone says hi

00:19:39,100 --> 00:19:45,370
I'm issue or a beefy and I'm using this

00:19:42,880 --> 00:19:46,899
key I can go figure out what that

00:19:45,370 --> 00:19:48,250
information is and if there's

00:19:46,899 --> 00:19:50,260
information that I need to do that

00:19:48,250 --> 00:19:52,390
specifically dealing with this other

00:19:50,260 --> 00:19:53,860
subject I know how to figure out which

00:19:52,390 --> 00:19:55,690
credentials to use for encryption or

00:19:53,860 --> 00:19:58,240
valet consolidation or verification or

00:19:55,690 --> 00:20:01,000
whatever the case may be and I can pass

00:19:58,240 --> 00:20:01,480
that from entity to entity to entity and

00:20:01,000 --> 00:20:03,190
they all

00:20:01,480 --> 00:20:04,750
first and it it's not something special

00:20:03,190 --> 00:20:06,700
that we did the mobile side does this

00:20:04,750 --> 00:20:09,730
and the app side does that before all of

00:20:06,700 --> 00:20:13,330
our stuff is that way but there is some

00:20:09,730 --> 00:20:15,309
bad some way we just have minimal

00:20:13,330 --> 00:20:17,290
support for algorithms and strengths so

00:20:15,309 --> 00:20:20,919
we've had to actually submit pull

00:20:17,290 --> 00:20:25,570
requests for enabling aes-256 or sorry

00:20:20,919 --> 00:20:27,760
RSA Oh a 82 56 it's not a requirement to

00:20:25,570 --> 00:20:29,770
be an implementation it's a it's an

00:20:27,760 --> 00:20:32,320
optional implantation some of them don't

00:20:29,770 --> 00:20:34,360
have it some like we just have no

00:20:32,320 --> 00:20:35,490
support for JSON web encryption like

00:20:34,360 --> 00:20:38,679
objective-c

00:20:35,490 --> 00:20:41,309
we had to actually write our own minimal

00:20:38,679 --> 00:20:43,360
implementation for the stuff that we did

00:20:41,309 --> 00:20:44,679
and unfortunately we didn't find that

00:20:43,360 --> 00:20:45,760
out and until like a week before

00:20:44,679 --> 00:20:49,450
everything was opposed to go live there

00:20:45,760 --> 00:20:51,429
was an implementation but the good part

00:20:49,450 --> 00:20:54,790
about it is is that there's some good

00:20:51,429 --> 00:20:56,290
documentation on that that we have the

00:20:54,790 --> 00:20:58,120
tests that were necessary to actually

00:20:56,290 --> 00:20:59,530
write the implementation so then the RFC

00:20:58,120 --> 00:21:00,970
there's enough information that you can

00:20:59,530 --> 00:21:03,240
actually write an implementation and

00:21:00,970 --> 00:21:06,370
know that it works which is really nice

00:21:03,240 --> 00:21:09,520
and there's some good documentation but

00:21:06,370 --> 00:21:11,230
unfortunately as I discovered you have

00:21:09,520 --> 00:21:13,059
to get a good working knowledge of RFC's

00:21:11,230 --> 00:21:14,470
you have to understand how those how

00:21:13,059 --> 00:21:17,290
they talk in arts fees and if you've

00:21:14,470 --> 00:21:19,179
never done that it's a little weird but

00:21:17,290 --> 00:21:22,870
once you get it you like it makes

00:21:19,179 --> 00:21:25,870
perfect sense and so that's what we did

00:21:22,870 --> 00:21:29,320
and why we did it but how we did it is

00:21:25,870 --> 00:21:31,059
the really really really cool part so we

00:21:29,320 --> 00:21:34,030
did it with Jose Jose and Jose right

00:21:31,059 --> 00:21:36,970
it's all Jose all the time we really

00:21:34,030 --> 00:21:40,419
really jumped in head first and it was

00:21:36,970 --> 00:21:43,330
super important and if you don't know

00:21:40,419 --> 00:21:46,750
what Jose is it's like I said earlier

00:21:43,330 --> 00:21:49,150
the JavaScript flying an encryption but

00:21:46,750 --> 00:21:52,360
it also it encompasses a bunch of pieces

00:21:49,150 --> 00:21:54,549
that are their own little world that

00:21:52,360 --> 00:21:56,919
what make up Jose which is the JSON web

00:21:54,549 --> 00:21:58,750
token I know he's here somewhere

00:21:56,919 --> 00:22:00,220
somebody giving a talk about there is

00:21:58,750 --> 00:22:02,230
Luisa give it a big talk about that

00:22:00,220 --> 00:22:04,000
tomorrow so I'm not going to get super

00:22:02,230 --> 00:22:05,260
detailed on JSON web token if you once

00:22:04,000 --> 00:22:06,880
you see light thing like this is

00:22:05,260 --> 00:22:08,049
something I really want to do go through

00:22:06,880 --> 00:22:10,630
the Lisa's talk I'll tell you all about

00:22:08,049 --> 00:22:13,450
the de WT because he actually writes all

00:22:10,630 --> 00:22:15,250
the libraries JSON web signature which

00:22:13,450 --> 00:22:16,570
is for signing data right it's not

00:22:15,250 --> 00:22:19,870
signing any particular data it's just

00:22:16,570 --> 00:22:21,550
signing data JSON web encryption again

00:22:19,870 --> 00:22:24,640
is just for encrypting data doesn't

00:22:21,550 --> 00:22:27,190
matter what type of data it is JSON web

00:22:24,640 --> 00:22:29,590
algorithm and the JSON web key which I

00:22:27,190 --> 00:22:31,690
misspelled with K to be key a JSON web

00:22:29,590 --> 00:22:35,170
algorithm is basically just a list of

00:22:31,690 --> 00:22:37,450
predefined strings that identifies what

00:22:35,170 --> 00:22:39,610
you used right so if you're using AES

00:22:37,450 --> 00:22:42,490
encryption most of proble use AES

00:22:39,610 --> 00:22:43,330
encryption you're probably using 256 3 2

00:22:42,490 --> 00:22:46,270
4 5 12

00:22:43,330 --> 00:22:48,970
well sorry PHP is 128 or 2 to 6 most the

00:22:46,270 --> 00:22:51,310
time and you're probably hopefully

00:22:48,970 --> 00:22:52,510
you're using CBC and IP using something

00:22:51,310 --> 00:22:56,740
else there's a little string that says

00:22:52,510 --> 00:23:00,190
I'm using AES I used two 5060 sighs and

00:22:56,740 --> 00:23:01,960
I use CBC as the mode so that when you

00:23:00,190 --> 00:23:03,700
get the data you know how to decrypt it

00:23:01,960 --> 00:23:06,580
right that's all about communicating

00:23:03,700 --> 00:23:07,660
what you did so that you can do what you

00:23:06,580 --> 00:23:11,740
need to do once you get the packet from

00:23:07,660 --> 00:23:13,600
the other person and JSON web key is for

00:23:11,740 --> 00:23:14,980
identifying giving the identifying

00:23:13,600 --> 00:23:17,380
information about keys you can even pass

00:23:14,980 --> 00:23:21,100
public keys along with the data we chose

00:23:17,380 --> 00:23:25,090
not to do that but the JSON web token is

00:23:21,100 --> 00:23:30,130
actually just a JSON web signature that

00:23:25,090 --> 00:23:31,270
has a specialized payload so in a JSON

00:23:30,130 --> 00:23:37,090
web signature what kind of gets a little

00:23:31,270 --> 00:23:39,180
bit more with a JWT provides credentials

00:23:37,090 --> 00:23:43,750
there's an optional nonce that we use

00:23:39,180 --> 00:23:45,520
called the a token ID it provides

00:23:43,750 --> 00:23:47,710
timestamp information and duration for

00:23:45,520 --> 00:23:49,750
how long the request is valid we were

00:23:47,710 --> 00:23:52,120
doing all of this manually internally

00:23:49,750 --> 00:23:54,190
where all these pieces here credentials

00:23:52,120 --> 00:23:56,020
not those timestamps and duration of the

00:23:54,190 --> 00:23:59,290
request we did that it was hard-coded

00:23:56,020 --> 00:24:02,440
into our code and we've had to document

00:23:59,290 --> 00:24:04,210
it for everybody else and that you could

00:24:02,440 --> 00:24:05,890
not change if you'd say I only want this

00:24:04,210 --> 00:24:07,540
request valid for 30 seconds too bad

00:24:05,890 --> 00:24:10,780
it's five minutes all right because

00:24:07,540 --> 00:24:13,150
that's what our code says but we're able

00:24:10,780 --> 00:24:14,560
to change that use the data bTW and one

00:24:13,150 --> 00:24:17,800
thing that you are allowed to do is you

00:24:14,560 --> 00:24:19,480
can extend JWT using private claims so

00:24:17,800 --> 00:24:20,830
we extended it using private claims to

00:24:19,480 --> 00:24:22,720
add additional data that were important

00:24:20,830 --> 00:24:27,290
to us which I'll get into that in a

00:24:22,720 --> 00:24:29,750
minute as well so JSON web signature

00:24:27,290 --> 00:24:31,970
has basically it's comprised of three

00:24:29,750 --> 00:24:33,830
segments and that can be expressed in a

00:24:31,970 --> 00:24:36,140
JSON object which nobody actually sends

00:24:33,830 --> 00:24:39,590
around or you can do compact

00:24:36,140 --> 00:24:42,950
sterilization which is three segments of

00:24:39,590 --> 00:24:47,630
URL based 64 encoded data separated by

00:24:42,950 --> 00:24:50,120
dots periods and so you have a header

00:24:47,630 --> 00:24:52,310
and the header is common amongst JWT and

00:24:50,120 --> 00:24:54,650
jwe and it provides information about

00:24:52,310 --> 00:24:56,630
the key so what key did you use to

00:24:54,650 --> 00:24:58,970
encrypt this or so I'm sorry signature

00:24:56,630 --> 00:25:00,200
to sign this what key DS use to sign it

00:24:58,970 --> 00:25:02,900
so that I know which key to use to

00:25:00,200 --> 00:25:04,280
verify the signature what signature

00:25:02,900 --> 00:25:05,960
other words would you use so I know to

00:25:04,280 --> 00:25:08,090
use the same one when I go to verify it

00:25:05,960 --> 00:25:10,730
and also there's optional content

00:25:08,090 --> 00:25:15,310
metadata which we also use to describe

00:25:10,730 --> 00:25:17,360
what's the information in the payload a

00:25:15,310 --> 00:25:20,330
payload is the data to be signed and

00:25:17,360 --> 00:25:22,670
then there's the signature of the header

00:25:20,330 --> 00:25:24,320
and the payload so you take the header

00:25:22,670 --> 00:25:26,690
take the payload little period in

00:25:24,320 --> 00:25:30,140
between you use your algorithms that you

00:25:26,690 --> 00:25:32,060
specified inside your header you do a

00:25:30,140 --> 00:25:33,320
signature you base this before you're

00:25:32,060 --> 00:25:36,740
all encoded and there it is

00:25:33,320 --> 00:25:38,510
it's actually fairly simple okay so web

00:25:36,740 --> 00:25:41,630
encryption is very similar although it

00:25:38,510 --> 00:25:43,840
has more parts and it's also how much

00:25:41,630 --> 00:25:49,220
data and it is dependent on what you do

00:25:43,840 --> 00:25:51,080
it's extremely diverse than what you can

00:25:49,220 --> 00:25:52,940
on the way that you can do it but we

00:25:51,080 --> 00:25:55,490
took it to the absolute extreme because

00:25:52,940 --> 00:25:56,960
that's our job we're a security company

00:25:55,490 --> 00:25:58,310
with a security whether the

00:25:56,960 --> 00:26:01,220
authentication system it needs to be

00:25:58,310 --> 00:26:03,740
secure and so again you have the header

00:26:01,220 --> 00:26:05,480
provides all that information but it

00:26:03,740 --> 00:26:08,330
actually has two different pieces for

00:26:05,480 --> 00:26:11,510
encryption and algorithm because doing

00:26:08,330 --> 00:26:14,270
JSON web encryption there's a thing

00:26:11,510 --> 00:26:16,010
called a Content encryption key and what

00:26:14,270 --> 00:26:18,500
that basically does and what we really

00:26:16,010 --> 00:26:21,050
loved about it is that when you're doing

00:26:18,500 --> 00:26:22,760
content encryption you can use AES

00:26:21,050 --> 00:26:25,100
encryption so you're always using AES

00:26:22,760 --> 00:26:26,930
right most people are familiar with AES

00:26:25,100 --> 00:26:28,420
but the important thing with AES is that

00:26:26,930 --> 00:26:30,980
you have a random initialization vector

00:26:28,420 --> 00:26:32,270
this library handles that the other

00:26:30,980 --> 00:26:35,030
thing that it does is it generates a

00:26:32,270 --> 00:26:37,100
random key so everything that you

00:26:35,030 --> 00:26:39,800
encrypt it gets a brand new key every

00:26:37,100 --> 00:26:40,880
single time and it's using RSA which is

00:26:39,800 --> 00:26:42,770
much more secure

00:26:40,880 --> 00:26:45,320
Danae yes but it takes longer it has

00:26:42,770 --> 00:26:50,150
limited sizes that it can crimp it uses

00:26:45,320 --> 00:26:51,320
RSA to encrypt the keys so you have the

00:26:50,150 --> 00:26:53,510
header information that tells you what

00:26:51,320 --> 00:26:56,930
you're using you generate random keys

00:26:53,510 --> 00:27:00,170
and IVs you encrypt the key you put that

00:26:56,930 --> 00:27:02,000
in part of the packet and then you make

00:27:00,170 --> 00:27:03,890
your encrypted data and then you

00:27:02,000 --> 00:27:06,190
actually do an H Mac of all of that to

00:27:03,890 --> 00:27:09,230
get there so the last pieces are the

00:27:06,190 --> 00:27:10,820
initialization vectors you used for

00:27:09,230 --> 00:27:13,460
Krypton's of payload the encrypted

00:27:10,820 --> 00:27:15,590
payload and then your H Mac that you can

00:27:13,460 --> 00:27:18,290
verify it actually provides verification

00:27:15,590 --> 00:27:19,730
that yes based on the key that's

00:27:18,290 --> 00:27:23,720
encrypted that people can't figure out

00:27:19,730 --> 00:27:25,180
I'm going to sign the all the payloads

00:27:23,720 --> 00:27:27,320
to make sure it hasn't been modified

00:27:25,180 --> 00:27:30,230
well there were things we really liked

00:27:27,320 --> 00:27:32,630
about Jose is both JSON web signature

00:27:30,230 --> 00:27:34,220
and the JSON web encryption they all

00:27:32,630 --> 00:27:36,140
have a signature to verify that it has

00:27:34,220 --> 00:27:38,330
not been modified that's a really big

00:27:36,140 --> 00:27:41,050
deal for us making sure that someone

00:27:38,330 --> 00:27:43,700
can't intercept the message between

00:27:41,050 --> 00:27:45,170
Citibank and ourselves and go and change

00:27:43,700 --> 00:27:47,090
the message so that someone can all kind

00:27:45,170 --> 00:27:48,160
of Kate we did some really crazy stuff

00:27:47,090 --> 00:27:53,900
to make that happen

00:27:48,160 --> 00:27:55,460
Jose made that super super easy talk

00:27:53,900 --> 00:27:57,470
about little bit already so we've JSON

00:27:55,460 --> 00:27:59,420
web algorithm to standardize the format

00:27:57,470 --> 00:28:03,140
of expressing the encryption and

00:27:59,420 --> 00:28:04,670
signatures and you get the ank and the

00:28:03,140 --> 00:28:06,560
allen keys inside of the header and

00:28:04,670 --> 00:28:09,730
that's what comes from and you'll see

00:28:06,560 --> 00:28:12,710
that in just a minute and JSON web key

00:28:09,730 --> 00:28:13,970
which is kind of how it solved a real

00:28:12,710 --> 00:28:17,420
real problem for us like we have a

00:28:13,970 --> 00:28:19,160
serious problem with key rotation and so

00:28:17,420 --> 00:28:21,800
it provides a way of expressing which

00:28:19,160 --> 00:28:23,660
key was used for this packet and every

00:28:21,800 --> 00:28:28,040
packet can be different so you have a

00:28:23,660 --> 00:28:30,670
key and the JSON web key information is

00:28:28,040 --> 00:28:36,230
stored in the header for the jws the jwe

00:28:30,670 --> 00:28:37,220
and how we used it is music to solve

00:28:36,230 --> 00:28:38,480
every problem that we had and we

00:28:37,220 --> 00:28:42,110
literally solved every problem that we

00:28:38,480 --> 00:28:43,730
had right so here's an example of a

00:28:42,110 --> 00:28:47,840
request representation I hope you can

00:28:43,730 --> 00:28:49,100
read it low so it looks like readable so

00:28:47,840 --> 00:28:49,880
this is like here's a standard request

00:28:49,100 --> 00:28:52,460
the only thing you may look a little

00:28:49,880 --> 00:28:53,890
weird is we've got this you see the

00:28:52,460 --> 00:28:56,080
authorization header

00:28:53,890 --> 00:28:57,909
normally if you're using JWT you're

00:28:56,080 --> 00:29:00,159
going to use a bearer token so you would

00:28:57,909 --> 00:29:02,710
have authorization : bearers

00:29:00,159 --> 00:29:04,029
ace and then your bearer token we didn't

00:29:02,710 --> 00:29:06,549
want to confuse people because we are

00:29:04,029 --> 00:29:10,179
not providing a bearer token or using a

00:29:06,549 --> 00:29:12,429
JWT but it's not as a bearer token so we

00:29:10,179 --> 00:29:14,140
gave it our own authentication format

00:29:12,429 --> 00:29:15,580
which is also helpful for us and

00:29:14,140 --> 00:29:17,830
identifying what it is so if we ever

00:29:15,580 --> 00:29:20,399
change the version then if we're doing

00:29:17,830 --> 00:29:23,200
it differently it can be I of a JWT tube

00:29:20,399 --> 00:29:24,940
or however we want to do that and then

00:29:23,200 --> 00:29:26,950
you you see this got the the three

00:29:24,940 --> 00:29:27,909
segments it's much it's very short it's

00:29:26,950 --> 00:29:29,919
not only much longer than that

00:29:27,909 --> 00:29:31,240
but it wouldn't fit on the screen so you

00:29:29,919 --> 00:29:34,299
have three segments that are separated

00:29:31,240 --> 00:29:36,429
by periods and then the data is your

00:29:34,299 --> 00:29:37,779
encrypted data that has five segments

00:29:36,429 --> 00:29:42,210
separated by periods which again is

00:29:37,779 --> 00:29:46,899
really shortened and Oakland is readable

00:29:42,210 --> 00:29:50,830
and so you have your JW header key to be

00:29:46,899 --> 00:29:52,870
TT header with your key ID which

00:29:50,830 --> 00:29:54,429
identifies which key we've used if you

00:29:52,870 --> 00:29:56,830
if you know this stuff at all you'll

00:29:54,429 --> 00:30:00,669
know that that's an md5 fingerprint of

00:29:56,830 --> 00:30:04,870
an RSA key what algorithm we use for the

00:30:00,669 --> 00:30:08,049
signature which is RSA 256 with a shop

00:30:04,870 --> 00:30:13,029
256 and it's the type in the content

00:30:08,049 --> 00:30:16,120
type is a JSON web token and so for key

00:30:13,029 --> 00:30:19,539
rotation that key ID we provide and

00:30:16,120 --> 00:30:21,760
request the response and for if we're

00:30:19,539 --> 00:30:24,100
receiving encrypted data you're going to

00:30:21,760 --> 00:30:25,630
give us the key that you use our public

00:30:24,100 --> 00:30:28,480
key and for us to know which one you use

00:30:25,630 --> 00:30:30,309
you're giving us the ID if we sign the

00:30:28,480 --> 00:30:31,990
request coming to you we told you that

00:30:30,309 --> 00:30:34,269
we signed it with this key if you don't

00:30:31,990 --> 00:30:37,269
have it yet we give you an API endpoint

00:30:34,269 --> 00:30:39,309
to go get it so now we can change out

00:30:37,269 --> 00:30:42,669
keys on systems that are high volume

00:30:39,309 --> 00:30:44,019
that want to cache the key it's super

00:30:42,669 --> 00:30:46,000
important that you're not hitting our

00:30:44,019 --> 00:30:47,380
key getting our public key ever again

00:30:46,000 --> 00:30:48,909
for every single request when you're

00:30:47,380 --> 00:30:50,529
doing 10,000 requests a minute

00:30:48,909 --> 00:30:52,990
alright that's a lot of wasted time

00:30:50,529 --> 00:30:54,610
that's a lot of a lot of horsepower

00:30:52,990 --> 00:30:57,519
going out making requests for something

00:30:54,610 --> 00:30:59,200
that you should already have but it was

00:30:57,519 --> 00:31:02,049
difficult to do that because for if we

00:30:59,200 --> 00:31:03,970
changed our key when you cashed it then

00:31:02,049 --> 00:31:07,240
you can just destroy the world so now

00:31:03,970 --> 00:31:08,770
you can just store the key forever

00:31:07,240 --> 00:31:10,960
because you know that as long as I get

00:31:08,770 --> 00:31:13,630
I'm getting the key ID back and I'm can

00:31:10,960 --> 00:31:15,429
store in my key value store I can store

00:31:13,630 --> 00:31:17,110
the key along with this ID so I can

00:31:15,429 --> 00:31:18,640
determine if I have it or not and if I

00:31:17,110 --> 00:31:20,020
don't I can go get it when I need to go

00:31:18,640 --> 00:31:22,390
get it and I can share that value

00:31:20,020 --> 00:31:25,059
amongst machines so that was a it was

00:31:22,390 --> 00:31:27,580
actually a huge performance increase we

00:31:25,059 --> 00:31:28,630
started using JSON web key because you

00:31:27,580 --> 00:31:30,010
don't have to make a call like that

00:31:28,630 --> 00:31:33,070
every single time you call our system

00:31:30,010 --> 00:31:35,080
and you can also get the current public

00:31:33,070 --> 00:31:38,409
key which gives you an ID and the PEM

00:31:35,080 --> 00:31:39,789
format of your RSA public key so that's

00:31:38,409 --> 00:31:40,510
how we implemented key rotation using

00:31:39,789 --> 00:31:42,789
JWT

00:31:40,510 --> 00:31:44,080
we had already had the ability to get

00:31:42,789 --> 00:31:45,429
our current public key but like I said

00:31:44,080 --> 00:31:46,870
there was no way to identify that

00:31:45,429 --> 00:31:47,380
there's no way to know if you had it

00:31:46,870 --> 00:31:50,529
already

00:31:47,380 --> 00:31:53,440
our solution on the version 1 was send a

00:31:50,529 --> 00:31:55,179
request and we'll pass along the hash of

00:31:53,440 --> 00:31:56,590
the key and it's the same one we won't

00:31:55,179 --> 00:31:58,120
give you any data back so we may we

00:31:56,590 --> 00:31:59,230
spend less data but you're still having

00:31:58,120 --> 00:32:00,580
to make a request

00:31:59,230 --> 00:32:03,429
every single time to see if there's a

00:32:00,580 --> 00:32:05,830
new key so now when you make the request

00:32:03,429 --> 00:32:07,929
you tell us hi I use this key to make

00:32:05,830 --> 00:32:10,450
the request and if that request hasn't

00:32:07,929 --> 00:32:12,789
been completely shut down you can have

00:32:10,450 --> 00:32:14,890
multiple keys at one time but eventually

00:32:12,789 --> 00:32:17,440
they will be disabled for security

00:32:14,890 --> 00:32:18,940
reasons so if you so that's a bad one

00:32:17,440 --> 00:32:21,970
will tell you that it was an invalid

00:32:18,940 --> 00:32:23,500
credential but during the time when

00:32:21,970 --> 00:32:25,029
we're rotating keys you're not going to

00:32:23,500 --> 00:32:26,260
have downtime and you're not gonna have

00:32:25,029 --> 00:32:30,549
to worry about having the wrong key

00:32:26,260 --> 00:32:33,789
cached and so again the way that we do

00:32:30,549 --> 00:32:36,730
that is we have the key ID and then we

00:32:33,789 --> 00:32:37,750
have the URL for the public key the

00:32:36,730 --> 00:32:41,080
korean sometimes needs to make of it

00:32:37,750 --> 00:32:42,820
here I apologize so request

00:32:41,080 --> 00:32:45,909
authorization we use it to solve that

00:32:42,820 --> 00:32:47,380
problem so we do something a little bit

00:32:45,909 --> 00:32:51,940
different with a web token is we do a

00:32:47,380 --> 00:32:52,929
single youth web token web tokens are

00:32:51,940 --> 00:32:54,820
normally you're going to go to a

00:32:52,929 --> 00:32:56,289
federated authority if you're using JWT

00:32:54,820 --> 00:32:57,820
using something like a WAP 2 or Oakley

00:32:56,289 --> 00:33:00,279
ID connect you go to Federation that

00:32:57,820 --> 00:33:01,899
says hi I'm the issuer credentials and

00:33:00,279 --> 00:33:04,029
I'm issuing a credential for this person

00:33:01,899 --> 00:33:06,210
or for this entity or this application

00:33:04,029 --> 00:33:09,850
and it's going to last for however long

00:33:06,210 --> 00:33:11,470
hours are single-use because we want to

00:33:09,850 --> 00:33:13,679
pass those credentials every single time

00:33:11,470 --> 00:33:19,059
because we are the authorization service

00:33:13,679 --> 00:33:21,070
and we use RSA key signature and we also

00:33:19,059 --> 00:33:25,240
have our hierarchical

00:33:21,070 --> 00:33:26,980
a CL on if I want to use my organization

00:33:25,240 --> 00:33:28,600
credentials I don't want to have to deal

00:33:26,980 --> 00:33:30,789
with the fact that I have another two

00:33:28,600 --> 00:33:32,799
levels I just want to use one set of

00:33:30,789 --> 00:33:34,269
credentials to use deal with my hundred

00:33:32,799 --> 00:33:36,039
applications which is actually really

00:33:34,269 --> 00:33:38,769
popular if you have a single sign-on

00:33:36,039 --> 00:33:40,720
system you have the ability to create

00:33:38,769 --> 00:33:42,610
and remove all of these other people

00:33:40,720 --> 00:33:45,580
that are using your single sign-on

00:33:42,610 --> 00:33:47,740
systems create organizations a second

00:33:45,580 --> 00:33:50,620
level inside of yours our system for

00:33:47,740 --> 00:33:51,940
mapping to your system and you may not

00:33:50,620 --> 00:33:53,049
want to have to manage all those creds

00:33:51,940 --> 00:33:55,840
holes you just want one set of

00:33:53,049 --> 00:33:58,690
credentials and we use the token ideas

00:33:55,840 --> 00:34:03,070
and knots and we specifically use that

00:33:58,690 --> 00:34:05,830
not as a replay attack and making sure

00:34:03,070 --> 00:34:08,230
it's just a mental awareness so when you

00:34:05,830 --> 00:34:11,409
send us the jada the token ID and the

00:34:08,230 --> 00:34:14,050
request we're going to resend it back to

00:34:11,409 --> 00:34:16,270
you so that you know that oh yes this is

00:34:14,050 --> 00:34:17,800
the response for my request as opposed

00:34:16,270 --> 00:34:21,179
to somebody sending you a pre generated

00:34:17,800 --> 00:34:24,520
response or sending an old response and

00:34:21,179 --> 00:34:26,379
making it work and then another big

00:34:24,520 --> 00:34:30,669
thing is the private claims in the

00:34:26,379 --> 00:34:34,119
requests so the private request claims

00:34:30,669 --> 00:34:37,210
are we add the method HTTP method and

00:34:34,119 --> 00:34:38,859
the path and a hash of the body and the

00:34:37,210 --> 00:34:40,589
algorithm that we use to hash the body

00:34:38,859 --> 00:34:43,240
so that we know which one it is and

00:34:40,589 --> 00:34:44,649
query parameters now the launch key API

00:34:43,240 --> 00:34:47,200
doesn't use query parameters but that

00:34:44,649 --> 00:34:48,579
was added in for the rest of the

00:34:47,200 --> 00:34:54,040
organizations that have query parameters

00:34:48,579 --> 00:34:55,000
and so our JWT is not terribly readable

00:34:54,040 --> 00:34:57,880
don't worry about so much for the three

00:34:55,000 --> 00:34:59,230
piece real quick but it's fairly large

00:34:57,880 --> 00:35:03,390
we use every single thing that you can

00:34:59,230 --> 00:35:07,300
use inside of a JWT and we add some so

00:35:03,390 --> 00:35:11,200
hierarchical credentials is we have

00:35:07,300 --> 00:35:12,880
issuer subjects and audience so in this

00:35:11,200 --> 00:35:16,089
particular example you have a directory

00:35:12,880 --> 00:35:18,250
which is basically if you have an

00:35:16,089 --> 00:35:21,819
Authenticator your Authenticator has a

00:35:18,250 --> 00:35:23,920
directory of users so you have a

00:35:21,819 --> 00:35:25,810
directory and so that is your issuer and

00:35:23,920 --> 00:35:27,280
it's making an issuer based on a service

00:35:25,810 --> 00:35:31,810
that wants that someone's trying to

00:35:27,280 --> 00:35:33,520
access and so we provide we have you you

00:35:31,810 --> 00:35:34,780
IDs and bases that we've come up with a

00:35:33,520 --> 00:35:36,730
methodology for weak

00:35:34,780 --> 00:35:38,350
determined that what type of part what

00:35:36,730 --> 00:35:40,660
type of entity is making the request how

00:35:38,350 --> 00:35:41,950
to identify that which is the kind of

00:35:40,660 --> 00:35:44,920
like the three-letter code and then a

00:35:41,950 --> 00:35:46,510
UUID and then the audience is lka which

00:35:44,920 --> 00:35:48,010
is the launchkey api so we know if

00:35:46,510 --> 00:35:49,330
you're sitting at the wrong place we can

00:35:48,010 --> 00:35:53,590
just tell you that you're saying it's

00:35:49,330 --> 00:35:55,720
the wrong place timestamp and duration

00:35:53,590 --> 00:35:57,910
so the duration that we have is five

00:35:55,720 --> 00:36:03,340
seconds on our responses we allow up to

00:35:57,910 --> 00:36:06,820
five minutes on the request so that we

00:36:03,340 --> 00:36:09,550
can have four larger windows but the

00:36:06,820 --> 00:36:13,750
thing that we do is we will hash the JWT

00:36:09,550 --> 00:36:14,890
and store it until it expires so make

00:36:13,750 --> 00:36:18,310
sure that you can't replay that same

00:36:14,890 --> 00:36:20,560
token ever again because between the jti

00:36:18,310 --> 00:36:22,090
and the exploration that there's

00:36:20,560 --> 00:36:23,470
uniqueness so amongst that every request

00:36:22,090 --> 00:36:26,520
you make you may make a request the same

00:36:23,470 --> 00:36:28,900
time but you can have a different KPI

00:36:26,520 --> 00:36:32,890
and then because you're setting that we

00:36:28,900 --> 00:36:34,840
can just very quickly just hash the JWT

00:36:32,890 --> 00:36:38,680
and we use that for replay prevention

00:36:34,840 --> 00:36:40,570
and it will exist until the request is

00:36:38,680 --> 00:36:43,570
no longer valid so when you have your

00:36:40,570 --> 00:36:45,780
exploration and you're JWT we'll hash it

00:36:43,570 --> 00:36:47,800
until then because at that point we

00:36:45,780 --> 00:36:49,660
don't need the hash anymore because

00:36:47,800 --> 00:36:51,280
we're quest is no longer valid so that

00:36:49,660 --> 00:36:53,200
has really reduced the amount of the

00:36:51,280 --> 00:36:54,880
information we have for our replay

00:36:53,200 --> 00:36:57,190
prevention because your request is only

00:36:54,880 --> 00:36:58,780
valid for a very short period of time so

00:36:57,190 --> 00:37:02,740
we've managed them really really slim

00:36:58,780 --> 00:37:04,110
that down and again we have enough there

00:37:02,740 --> 00:37:06,700
the JCI is the nonce

00:37:04,110 --> 00:37:09,820
and you'll see in the response it comes

00:37:06,700 --> 00:37:11,440
back and on so you can give us whatever

00:37:09,820 --> 00:37:12,640
you want you just just better not be the

00:37:11,440 --> 00:37:15,960
same thing twice because you'll have a

00:37:12,640 --> 00:37:18,940
problem or at least not for five minutes

00:37:15,960 --> 00:37:20,650
and then we have request validation this

00:37:18,940 --> 00:37:22,090
is one of the big things that we did

00:37:20,650 --> 00:37:24,820
with this is the request validation is

00:37:22,090 --> 00:37:27,490
we created a sub section called request

00:37:24,820 --> 00:37:30,250
and that's where we put the method the

00:37:27,490 --> 00:37:32,290
pass the function used to the hash

00:37:30,250 --> 00:37:34,780
function used and the hash so you'll see

00:37:32,290 --> 00:37:37,480
that the top is the first part of the

00:37:34,780 --> 00:37:42,550
request so we know it's a post request

00:37:37,480 --> 00:37:44,530
and the location is service v3 off the

00:37:42,550 --> 00:37:47,050
path and so we have represented that

00:37:44,530 --> 00:37:48,520
inside of the JWT and that's how we

00:37:47,050 --> 00:37:50,620
verify that someone didn't

00:37:48,520 --> 00:37:52,960
doesn't go and change a post into a

00:37:50,620 --> 00:37:55,240
delete all right

00:37:52,960 --> 00:37:56,590
our old API wasn't restful because we

00:37:55,240 --> 00:37:59,740
didn't want someone to be able to turn a

00:37:56,590 --> 00:38:01,600
post into a delete so delete was under a

00:37:59,740 --> 00:38:04,210
different path so you couldn't just take

00:38:01,600 --> 00:38:05,700
the same request and change the endpoint

00:38:04,210 --> 00:38:08,770
and do something terrible

00:38:05,700 --> 00:38:10,240
made it secure it solved the problem but

00:38:08,770 --> 00:38:12,160
as someone trying to implement that it

00:38:10,240 --> 00:38:15,130
makes no sense to me at all that I

00:38:12,160 --> 00:38:17,020
should have to go to service v3 off /

00:38:15,130 --> 00:38:19,510
delete and post to that to delete

00:38:17,020 --> 00:38:21,400
something right not very restful so

00:38:19,510 --> 00:38:26,200
being able to handle that inside of this

00:38:21,400 --> 00:38:27,610
request claim removed all of that

00:38:26,200 --> 00:38:30,000
weirdness that we had to do to prevent

00:38:27,610 --> 00:38:30,000
that from happening

00:38:30,570 --> 00:38:37,300
response authorization so one of the

00:38:35,740 --> 00:38:39,130
things we've never done before is we'd

00:38:37,300 --> 00:38:41,140
never actually given you the opportunity

00:38:39,130 --> 00:38:43,840
as a user except for one small little

00:38:41,140 --> 00:38:46,000
piece to verify that the entire response

00:38:43,840 --> 00:38:48,310
hasn't been hijacked in the middle now

00:38:46,000 --> 00:38:50,140
the pieces that we did verify and

00:38:48,310 --> 00:38:52,720
encrypt were the things that would allow

00:38:50,140 --> 00:38:54,550
you to hijack a session or to

00:38:52,720 --> 00:38:55,900
impersonate a user or to make that

00:38:54,550 --> 00:38:59,410
service thing to the user hadn't

00:38:55,900 --> 00:39:03,070
responded in a particular way so again

00:38:59,410 --> 00:39:05,560
no one's ever able to actually log in as

00:39:03,070 --> 00:39:09,610
a different user or hijack an account or

00:39:05,560 --> 00:39:11,170
do a mantle attack that worked but to do

00:39:09,610 --> 00:39:13,450
that again we had to just make things

00:39:11,170 --> 00:39:15,450
really weird and it was really unwieldy

00:39:13,450 --> 00:39:19,300
as an implementer to try and figure out

00:39:15,450 --> 00:39:20,560
so what we changed to and this is a

00:39:19,300 --> 00:39:22,240
little weird because you'd never see a

00:39:20,560 --> 00:39:24,880
JWT used or at least I've never seen a

00:39:22,240 --> 00:39:28,210
JW's in response okay so we actually

00:39:24,880 --> 00:39:30,070
have a JWT in the response instead of

00:39:28,210 --> 00:39:31,750
just going with a JIT JSON web signature

00:39:30,070 --> 00:39:34,050
because we wanted to add a bunch of

00:39:31,750 --> 00:39:37,120
custom claims and we also wanted to

00:39:34,050 --> 00:39:39,130
determine what who the issuer was who

00:39:37,120 --> 00:39:41,200
the audiences are hierarchical stuff on

00:39:39,130 --> 00:39:43,300
the response we wanted you to least be

00:39:41,200 --> 00:39:45,400
able to know what who's responding and

00:39:43,300 --> 00:39:47,290
what they're responding about so it had

00:39:45,400 --> 00:39:47,920
more state and it made a little more

00:39:47,290 --> 00:39:51,580
sense to us

00:39:47,920 --> 00:39:52,840
although explaining it to people they it

00:39:51,580 --> 00:39:54,670
gets a little weird for them because I

00:39:52,840 --> 00:39:56,770
wasn't jada me to use it for requests

00:39:54,670 --> 00:40:00,520
that's a bearer token and we don't use

00:39:56,770 --> 00:40:01,970
it like a bear token and like I said we

00:40:00,520 --> 00:40:03,830
were trying to you

00:40:01,970 --> 00:40:05,450
some of the existing stuff because now I

00:40:03,830 --> 00:40:07,880
don't have to make this thing to do this

00:40:05,450 --> 00:40:09,230
crazy stuff to verify that things are

00:40:07,880 --> 00:40:11,599
the way I want them to be this request

00:40:09,230 --> 00:40:13,490
isn't too old that it's a unique

00:40:11,599 --> 00:40:15,230
identifier I can just use the existing

00:40:13,490 --> 00:40:18,890
Jose libraries and they just helmet for

00:40:15,230 --> 00:40:21,560
me so again we do the signature we put

00:40:18,890 --> 00:40:23,930
it in a custom token coming back and we

00:40:21,560 --> 00:40:27,470
also use it that same header when we're

00:40:23,930 --> 00:40:29,240
sending things for server-side event so

00:40:27,470 --> 00:40:30,770
that we don't some people who are

00:40:29,240 --> 00:40:32,630
implementing don't get caught with the

00:40:30,770 --> 00:40:34,430
off header because they might have off

00:40:32,630 --> 00:40:37,750
on their site and bad things might

00:40:34,430 --> 00:40:39,859
happen if we pass them an auth token

00:40:37,750 --> 00:40:41,840
again the hierarchal credentials the

00:40:39,859 --> 00:40:44,810
token ID is not is echoed we have

00:40:41,840 --> 00:40:46,670
private claims to the response so in the

00:40:44,810 --> 00:40:49,790
private response claims we didn't do

00:40:46,670 --> 00:40:52,760
everything if you've ever used so before

00:40:49,790 --> 00:40:54,590
we did JWT we did something that a lot

00:40:52,760 --> 00:40:57,080
of people do they go find successful

00:40:54,590 --> 00:40:59,020
api's and how are they doing it and who

00:40:57,080 --> 00:41:01,599
is secure and what are they doing and

00:40:59,020 --> 00:41:04,369
some of the older API is I worked on

00:41:01,599 --> 00:41:05,750
Amazon's the one right so you go take a

00:41:04,369 --> 00:41:07,670
look well what if Amazon doing and

00:41:05,750 --> 00:41:09,170
Amazon goes through and they they have

00:41:07,670 --> 00:41:11,089
this little one header that tells you

00:41:09,170 --> 00:41:12,170
all of the headers of their signing that

00:41:11,089 --> 00:41:16,280
they have another header where you

00:41:12,170 --> 00:41:17,750
actually have the signing and you have

00:41:16,280 --> 00:41:21,080
to have to be a particular order and

00:41:17,750 --> 00:41:23,240
it's just kind of it's it's very secure

00:41:21,080 --> 00:41:24,740
but again harder to implement so we

00:41:23,240 --> 00:41:27,440
decide that we want to do it this way in

00:41:24,740 --> 00:41:29,270
the JWT and we've identified for our

00:41:27,440 --> 00:41:31,609
particular API and you could certainly

00:41:29,270 --> 00:41:33,260
use the same things less or more add

00:41:31,609 --> 00:41:35,000
what you want these are the things in

00:41:33,260 --> 00:41:36,740
the response that were important to us

00:41:35,000 --> 00:41:38,510
because what we don't want to have

00:41:36,740 --> 00:41:41,000
happen is someone to be able to

00:41:38,510 --> 00:41:43,490
impersonate a response so status codes a

00:41:41,000 --> 00:41:46,310
big one I don't want someone to be able

00:41:43,490 --> 00:41:47,150
to return a 400 invalid request and make

00:41:46,310 --> 00:41:48,500
you think there's something we're all on

00:41:47,150 --> 00:41:50,540
your API when there's nothing wrong with

00:41:48,500 --> 00:41:51,680
your with your request if that someone's

00:41:50,540 --> 00:41:55,940
trying to prevent you from able to log

00:41:51,680 --> 00:41:58,760
in a cache control header I don't want

00:41:55,940 --> 00:42:00,410
someone to do a denial of service on us

00:41:58,760 --> 00:42:01,940
by being able to change my cache control

00:42:00,410 --> 00:42:03,560
header and telling you never to cache it

00:42:01,940 --> 00:42:06,140
or tell you to cache it for an hour when

00:42:03,560 --> 00:42:07,490
you shouldn't be the location header for

00:42:06,140 --> 00:42:10,220
redirect so they can't send you to

00:42:07,490 --> 00:42:11,810
somewhere we don't want you to go and

00:42:10,220 --> 00:42:14,990
then again the body hash the body has

00:42:11,810 --> 00:42:15,720
two algorithm and so if you take a look

00:42:14,990 --> 00:42:18,510
at a standard

00:42:15,720 --> 00:42:21,599
response right it's got your status

00:42:18,510 --> 00:42:22,619
content-type is application Jose letting

00:42:21,599 --> 00:42:27,240
you know that you're going to get that

00:42:22,619 --> 00:42:30,599
weird dotted part in your body cache

00:42:27,240 --> 00:42:31,560
control location which I just put in

00:42:30,599 --> 00:42:33,570
here for reference we don't ever

00:42:31,560 --> 00:42:37,710
actually use it and then again we have

00:42:33,570 --> 00:42:42,180
the JWT so then you have a response

00:42:37,710 --> 00:42:45,150
claim that echoes that so again we have

00:42:42,180 --> 00:42:46,920
the hierarchical potentials the issuer

00:42:45,150 --> 00:42:48,450
coming back is actually the launch key

00:42:46,920 --> 00:42:51,300
API the response is coming back from the

00:42:48,450 --> 00:42:53,400
launch KPI and the subject in the

00:42:51,300 --> 00:42:55,050
audience so that I now know who the

00:42:53,400 --> 00:42:58,170
entity is that should be receiving this

00:42:55,050 --> 00:43:00,000
so in the Java world one thing makes

00:42:58,170 --> 00:43:00,990
requests because it's going outbound and

00:43:00,000 --> 00:43:03,210
then something completely different

00:43:00,990 --> 00:43:04,770
might be getting the actual responses

00:43:03,210 --> 00:43:06,540
back from our server sent events because

00:43:04,770 --> 00:43:08,580
they don't want those applications

00:43:06,540 --> 00:43:09,690
receiving incoming in PHP where we've

00:43:08,580 --> 00:43:11,070
done the same I've done the same thing

00:43:09,690 --> 00:43:12,780
where you'll have all these applications

00:43:11,070 --> 00:43:13,859
that it's okay for them to go out but

00:43:12,780 --> 00:43:16,740
you have this one application that

00:43:13,859 --> 00:43:18,330
receives incoming requests and so when

00:43:16,740 --> 00:43:21,420
you're doing that you know that o launch

00:43:18,330 --> 00:43:24,420
key talk to me and it was giving me a

00:43:21,420 --> 00:43:27,480
response for this particular audience

00:43:24,420 --> 00:43:30,900
about this subject and that's super

00:43:27,480 --> 00:43:33,720
helpful for us of that piece again the

00:43:30,900 --> 00:43:35,460
time stamp alliteration that hey if it's

00:43:33,720 --> 00:43:39,690
more than five seconds old this is bad

00:43:35,460 --> 00:43:42,960
so let's try to do a replay a nonce

00:43:39,690 --> 00:43:44,250
echoed back to you so if you generate

00:43:42,960 --> 00:43:46,349
the nonce you make the request you get a

00:43:44,250 --> 00:43:50,490
response back and they don't match you

00:43:46,349 --> 00:43:52,290
have an attack on going that was one of

00:43:50,490 --> 00:43:53,609
my favorite parts of the the

00:43:52,290 --> 00:43:54,720
implementation is we just wanted to try

00:43:53,609 --> 00:43:56,250
and figure out how to do that and then

00:43:54,720 --> 00:43:57,660
we realize that oh there's this JT I

00:43:56,250 --> 00:43:59,790
think that nobody actually really uses

00:43:57,660 --> 00:44:03,180
but it's super helpful if we decide to

00:43:59,790 --> 00:44:05,760
use that for it and then the validation

00:44:03,180 --> 00:44:07,140
so in your response right this is kind

00:44:05,760 --> 00:44:09,599
of a standard response header it's not

00:44:07,140 --> 00:44:12,420
the whole thing but that entire response

00:44:09,599 --> 00:44:14,250
header and the response body which I did

00:44:12,420 --> 00:44:17,670
include because it's too big is

00:44:14,250 --> 00:44:20,310
completely validated and represented

00:44:17,670 --> 00:44:21,750
inside the date of EP so the same thing

00:44:20,310 --> 00:44:23,820
we did with the request we did again

00:44:21,750 --> 00:44:27,450
month of response and so we have much

00:44:23,820 --> 00:44:30,870
better and we encrypted jaded with data

00:44:27,450 --> 00:44:34,120
encrypted data with jwe

00:44:30,870 --> 00:44:36,550
again we got that jwk the web key for

00:44:34,120 --> 00:44:39,100
giving you key rotation we get the

00:44:36,550 --> 00:44:42,070
combination of RSA an aes encryption so

00:44:39,100 --> 00:44:44,530
random keys and IVs for AES super or

00:44:42,070 --> 00:44:48,070
abusing large pieces of data and RSA to

00:44:44,530 --> 00:44:51,040
make sure it's super secure algorithms

00:44:48,070 --> 00:44:53,770
and modes are always the same for

00:44:51,040 --> 00:44:55,000
requests to the response that's one of

00:44:53,770 --> 00:44:56,620
things that we do is when you send us a

00:44:55,000 --> 00:44:58,990
view encrypt data and you say I'm using

00:44:56,620 --> 00:45:00,850
AES 256 cbc we were turning it back in

00:44:58,990 --> 00:45:05,350
AES 256 cbc because that's what you

00:45:00,850 --> 00:45:06,850
wanted but we do allow a range so we

00:45:05,350 --> 00:45:09,100
allow 256 to 512

00:45:06,850 --> 00:45:10,690
so most users can see 6 was good enough

00:45:09,100 --> 00:45:13,000
for them but some people say I have to

00:45:10,690 --> 00:45:17,110
have 512 so if you want to get like tips

00:45:13,000 --> 00:45:19,870
for mukluks you might want to 512 or if

00:45:17,110 --> 00:45:21,220
your bank you might want 512 right and

00:45:19,870 --> 00:45:22,630
we allow them to do that now we couldn't

00:45:21,220 --> 00:45:24,490
before we had to go with the fact that

00:45:22,630 --> 00:45:26,880
well not every language provides

00:45:24,490 --> 00:45:29,620
anything with sides to beyond 256 so

00:45:26,880 --> 00:45:31,240
we're just going to 256 now we have the

00:45:29,620 --> 00:45:34,720
option for our customers can choose I

00:45:31,240 --> 00:45:36,310
want 512 and they can encrypted 512 and

00:45:34,720 --> 00:45:42,430
we'll send it back to them encrypted

00:45:36,310 --> 00:45:46,240
with AES 512 right get the lanes into

00:45:42,430 --> 00:45:48,670
that so the example for a header is very

00:45:46,240 --> 00:45:50,140
similar to a JWT all right you got your

00:45:48,670 --> 00:45:52,540
key ID you got except you've got

00:45:50,140 --> 00:45:54,970
algorithm and you've got ink so

00:45:52,540 --> 00:45:57,310
algorithm is determining what algorithm

00:45:54,970 --> 00:45:58,000
is used to encrypt the content

00:45:57,310 --> 00:46:00,070
encryption key

00:45:58,000 --> 00:46:03,880
the ank is the actual encryption

00:46:00,070 --> 00:46:07,380
protocol this one AES 256 cbc and the

00:46:03,880 --> 00:46:09,970
signature will be an h-back with sha-512

00:46:07,380 --> 00:46:11,950
these are all listed that's super

00:46:09,970 --> 00:46:13,540
special and something really cool that

00:46:11,950 --> 00:46:15,820
we'd never have before is that it

00:46:13,540 --> 00:46:16,930
actually tells you what is the content I

00:46:15,820 --> 00:46:19,780
put the stuff that's inside its

00:46:16,930 --> 00:46:21,460
encrypted I mean that is so cool like we

00:46:19,780 --> 00:46:23,710
if we might be getting different kinds

00:46:21,460 --> 00:46:25,120
of data I can just determine oh this is

00:46:23,710 --> 00:46:26,470
this data and I can get it that way so

00:46:25,120 --> 00:46:28,780
if we ever change it so you might be

00:46:26,470 --> 00:46:30,070
able to use XML if it's application XML

00:46:28,780 --> 00:46:32,080
I know that this one's XML and you do

00:46:30,070 --> 00:46:34,690
live that way so that's something it's a

00:46:32,080 --> 00:46:37,140
really nice addition that I'd never seen

00:46:34,690 --> 00:46:40,060
before and the encryption stuff which is

00:46:37,140 --> 00:46:42,310
optional and jwe but we use it because

00:46:40,060 --> 00:46:48,170
it's really nice

00:46:42,310 --> 00:46:49,370
and so the big conclusion for me I mean

00:46:48,170 --> 00:46:51,230
I was talking about last night it's a

00:46:49,370 --> 00:46:53,420
speaker they're like how I'm like really

00:46:51,230 --> 00:46:56,420
really psyched about this because it

00:46:53,420 --> 00:46:58,580
made my life so much better it made my

00:46:56,420 --> 00:47:01,610
code so much cleaner

00:46:58,580 --> 00:47:04,790
it made my API so much more secure right

00:47:01,610 --> 00:47:08,020
so much more secure and we're using

00:47:04,790 --> 00:47:10,400
standards that are homogenized across

00:47:08,020 --> 00:47:12,590
well they're going to be homogenized

00:47:10,400 --> 00:47:14,000
across all of our platforms because it

00:47:12,590 --> 00:47:15,860
wasn't something that was specific we

00:47:14,000 --> 00:47:17,630
didn't have to sit down like we did

00:47:15,860 --> 00:47:19,370
before I come up with something well we

00:47:17,630 --> 00:47:20,330
don't want the over-engineer this and

00:47:19,370 --> 00:47:22,580
come up with something that works for

00:47:20,330 --> 00:47:24,830
everyone because who has the time to do

00:47:22,580 --> 00:47:28,670
that right none of us have the time to

00:47:24,830 --> 00:47:31,010
do this massive grand encryption and

00:47:28,670 --> 00:47:32,330
signature verification system that's

00:47:31,010 --> 00:47:33,440
going to work for all of our systems

00:47:32,330 --> 00:47:35,570
we've got you know we have deadlines to

00:47:33,440 --> 00:47:36,860
me we have to get it done fortunately

00:47:35,570 --> 00:47:38,270
there's working groups and a ton of

00:47:36,860 --> 00:47:43,850
people out there using Jose they're

00:47:38,270 --> 00:47:45,800
doing that for you so libraries as far

00:47:43,850 --> 00:47:48,170
as I know there's only one full Jose

00:47:45,800 --> 00:47:54,080
library so if you want to do the whole

00:47:48,170 --> 00:47:55,880
gambit it's funky labs but if you want

00:47:54,080 --> 00:47:57,350
to go there's also another one there's

00:47:55,880 --> 00:48:01,220
actually I think two more for JWT

00:47:57,350 --> 00:48:03,320
but there's only one that's just JDBC

00:48:01,220 --> 00:48:05,840
that supports basically the full range

00:48:03,320 --> 00:48:08,330
and the validation of the jti and that's

00:48:05,840 --> 00:48:10,520
it so he'll be talking about it tomorrow

00:48:08,330 --> 00:48:15,770
afternoon here I don't this room but

00:48:10,520 --> 00:48:17,960
look at the conference please please

00:48:15,770 --> 00:48:22,400
please please please please rate this

00:48:17,960 --> 00:48:23,300
talk please rate this talk and if you

00:48:22,400 --> 00:48:24,710
want to follow up if you have any

00:48:23,300 --> 00:48:28,450
questions I'd love talking about this

00:48:24,710 --> 00:48:31,630
stuff I can do it absolutely forever but

00:48:28,450 --> 00:48:35,300
all that said are there any questions I

00:48:31,630 --> 00:48:37,940
thought there might be a wolf you should

00:48:35,300 --> 00:48:43,120
use you middle wits which Lee so you can

00:48:37,940 --> 00:48:45,710
because the things you use need TQ tools

00:48:43,120 --> 00:48:48,890
so we're using just so using the hose a

00:48:45,710 --> 00:48:51,470
library which is handling all of the

00:48:48,890 --> 00:48:52,670
encryption decryption type stuff so the

00:48:51,470 --> 00:48:54,410
first thing you do is when when it comes

00:48:52,670 --> 00:48:56,210
in we just have layered middleware

00:48:54,410 --> 00:49:01,010
so the first thing that it does is it

00:48:56,210 --> 00:49:03,890
goes and it basically BAE 64 decodes and

00:49:01,010 --> 00:49:08,420
URL decodes the the pieces to get the

00:49:03,890 --> 00:49:13,040
header and the JWT and it determines

00:49:08,420 --> 00:49:15,530
that oh we have this is a what type of

00:49:13,040 --> 00:49:19,730
entity it is pulls up that entity out of

00:49:15,530 --> 00:49:20,870
the database and then determines finds

00:49:19,730 --> 00:49:22,700
the key that it needs to do the

00:49:20,870 --> 00:49:24,980
verification on the signature verify the

00:49:22,700 --> 00:49:26,600
signature so there's actually one piece

00:49:24,980 --> 00:49:27,890
that pulls out the entities and then it

00:49:26,600 --> 00:49:29,600
moves the next piece of middleware that

00:49:27,890 --> 00:49:31,880
goes and validates the signature based

00:49:29,600 --> 00:49:34,730
on the keys and the next thing that it

00:49:31,880 --> 00:49:36,440
does is it verifies that this entity has

00:49:34,730 --> 00:49:40,750
access to that entity and then another

00:49:36,440 --> 00:49:44,330
piece of metal here that determines if

00:49:40,750 --> 00:49:45,680
this particular type of entity can

00:49:44,330 --> 00:49:47,330
access the other type so we've got a

00:49:45,680 --> 00:49:50,060
bunch of different layers that go down

00:49:47,330 --> 00:49:52,520
and then once we validated that this is

00:49:50,060 --> 00:49:54,200
a valid authorization and a valid

00:49:52,520 --> 00:49:57,290
signature and a valid request then we

00:49:54,200 --> 00:49:59,300
actually go and decrypt and then we just

00:49:57,290 --> 00:50:01,340
put that data on the request and ship it

00:49:59,300 --> 00:50:02,600
through so when it gets the controller

00:50:01,340 --> 00:50:05,000
the quota controller just knows I've got

00:50:02,600 --> 00:50:06,830
a JSON object I have a requesting entity

00:50:05,000 --> 00:50:10,700
and I have a subject entity and I deal

00:50:06,830 --> 00:50:12,410
with that so but public is to control in

00:50:10,700 --> 00:50:15,470
your actual code you know it's a good

00:50:12,410 --> 00:50:18,260
entity you know it can it should go up

00:50:15,470 --> 00:50:23,390
an action it it also get all the

00:50:18,260 --> 00:50:26,840
information in terms of the basically

00:50:23,390 --> 00:50:29,540
the payload is it all ready yeah so so

00:50:26,840 --> 00:50:31,580
we we attach we do the database lookup

00:50:29,540 --> 00:50:33,260
on the entities and so the issuer and

00:50:31,580 --> 00:50:35,000
the subject those entities are attached

00:50:33,260 --> 00:50:36,770
as the issuer entity and the subject

00:50:35,000 --> 00:50:38,600
entity so we don't have to go pull it up

00:50:36,770 --> 00:50:41,930
again that was one of the big parts of

00:50:38,600 --> 00:50:43,580
our of our ability to handle more load

00:50:41,930 --> 00:50:46,640
is to reduce the number of times we look

00:50:43,580 --> 00:50:47,990
up entities so the middleware does that

00:50:46,640 --> 00:50:49,190
part of the validation process to get

00:50:47,990 --> 00:50:50,600
the keys it actually looks up those

00:50:49,190 --> 00:50:52,670
entities and stores them in the request

00:50:50,600 --> 00:50:53,660
and it gets passed on and then we have

00:50:52,670 --> 00:50:55,370
another piece of metal that does

00:50:53,660 --> 00:50:57,590
validates the actual data that came

00:50:55,370 --> 00:50:59,330
across in the request because we know

00:50:57,590 --> 00:51:01,130
the end point once we everything is

00:50:59,330 --> 00:51:02,660
valid everything is decrypted then we

00:51:01,130 --> 00:51:04,460
can actually do validate the data and

00:51:02,660 --> 00:51:06,800
then once it gets the controller's it

00:51:04,460 --> 00:51:07,400
knows that it has a good valid request

00:51:06,800 --> 00:51:08,960
we

00:51:07,400 --> 00:51:12,559
the proper data has been properly

00:51:08,960 --> 00:51:14,180
sanitized and then it just returns a

00:51:12,559 --> 00:51:16,220
response and then the middle where it

00:51:14,180 --> 00:51:17,839
goes in the reverse order goes and

00:51:16,220 --> 00:51:26,869
encrypts it and finds it and then ships

00:51:17,839 --> 00:51:30,730
it back thanks can't see very bright

00:51:26,869 --> 00:51:34,730
line I'll ask a question then okay so

00:51:30,730 --> 00:51:38,779
yeah I'm taking the full Josie suite as

00:51:34,730 --> 00:51:40,099
it is you would essentially be am I

00:51:38,779 --> 00:51:42,020
right in assuming you'd essentially be

00:51:40,099 --> 00:51:45,170
racking it your entire communication in

00:51:42,020 --> 00:51:48,619
its own encryption there beyond the need

00:51:45,170 --> 00:51:49,819
of HTTP as well well we know we do ACS

00:51:48,619 --> 00:51:51,289
as well well you would I know but

00:51:49,819 --> 00:51:53,990
desiring like generally it's like

00:51:51,289 --> 00:51:55,970
another envelope of encryption but not

00:51:53,990 --> 00:51:58,549
necessarily things up to the standard or

00:51:55,970 --> 00:52:02,660
the same but it's certainly encrypted of

00:51:58,549 --> 00:52:05,569
the standard of SSL so SSL is RSA or e

00:52:02,660 --> 00:52:07,309
CDH private private public key pairs and

00:52:05,569 --> 00:52:09,200
it uses AES to encrypt the data so

00:52:07,309 --> 00:52:14,170
you're basically using if you're you do

00:52:09,200 --> 00:52:17,569
it using RSA or let the curb encryption

00:52:14,170 --> 00:52:18,619
using AES 256 or better your bit

00:52:17,569 --> 00:52:23,029
basically the same thing you're using

00:52:18,619 --> 00:52:26,809
inside of SSL but for us we know that

00:52:23,029 --> 00:52:28,520
man the middle is possible and we try

00:52:26,809 --> 00:52:30,589
and protect our customers so if someone

00:52:28,520 --> 00:52:32,660
if you're not building your your system

00:52:30,589 --> 00:52:35,660
pinning to our SSL sort or pinning to

00:52:32,660 --> 00:52:37,730
our making sure that this is who we're

00:52:35,660 --> 00:52:39,260
supposed to be talking to you have a

00:52:37,730 --> 00:52:41,930
madam ill attack so we make sure that

00:52:39,260 --> 00:52:43,549
you could never ever view any of our

00:52:41,930 --> 00:52:45,650
authorization data you can never get a

00:52:43,549 --> 00:52:48,200
username all these things so it's and

00:52:45,650 --> 00:52:50,150
that you can you can't just fiddle with

00:52:48,200 --> 00:52:51,890
response coming back so it's a because

00:52:50,150 --> 00:52:53,539
you can't pre share trust you would be

00:52:51,890 --> 00:52:56,210
able to actually guarantee my little

00:52:53,539 --> 00:52:57,440
being prevented with this well the

00:52:56,210 --> 00:53:01,640
pretty sure of the trust the fact that

00:52:57,440 --> 00:53:03,559
so SSL is an open network where you have

00:53:01,640 --> 00:53:05,779
certificate authorities that you have to

00:53:03,559 --> 00:53:06,740
trust so if I go and say oh hi yeah I'm

00:53:05,779 --> 00:53:08,630
just networking here's my certificate

00:53:06,740 --> 00:53:10,940
authority and you go verify against that

00:53:08,630 --> 00:53:12,230
but it's not my know it's not my

00:53:10,940 --> 00:53:14,180
certificate and it's a different

00:53:12,230 --> 00:53:16,250
certificate authority if the certificate

00:53:14,180 --> 00:53:19,099
authority gets hacked that's an open

00:53:16,250 --> 00:53:20,750
network from the trust when you go to

00:53:19,099 --> 00:53:22,670
our dashboard and

00:53:20,750 --> 00:53:23,960
you upload your public key so the trust

00:53:22,670 --> 00:53:25,910
is that you went to our dashboard you

00:53:23,960 --> 00:53:29,150
upload the public key nobody knows what

00:53:25,910 --> 00:53:30,770
those keys are but you and me so that

00:53:29,150 --> 00:53:33,080
your theory so your time publishes a

00:53:30,770 --> 00:53:35,240
public key to your API and then dot B

00:53:33,080 --> 00:53:36,800
right and that we used to encrypt to

00:53:35,240 --> 00:53:38,600
verify their signature is the one that

00:53:36,800 --> 00:53:39,500
we that they sent to us by logging into

00:53:38,600 --> 00:53:41,300
our system with authorization

00:53:39,500 --> 00:53:53,360
credentials that are valid make sense

00:53:41,300 --> 00:53:55,190
okay anyway it's really bright okay if

00:53:53,360 --> 00:53:56,780
there's no more questions and that's it

00:53:55,190 --> 00:53:59,960
all right thank you if you had any

00:53:56,780 --> 00:54:02,060
questions at all or it's a it's a lot to

00:53:59,960 --> 00:54:03,470
sink in and if you're thinking like I

00:54:02,060 --> 00:54:05,900
might think about that let me go look at

00:54:03,470 --> 00:54:07,130
it I'll be here for a while go see his

00:54:05,900 --> 00:54:09,380
talk tomorrow fairest in the day to be

00:54:07,130 --> 00:54:12,380
teased because he'll get more in depth

00:54:09,380 --> 00:54:13,610
from JWT and yeah absolutely just comes

00:54:12,380 --> 00:54:15,740
to me anytime and talking about excel

00:54:13,610 --> 00:54:19,800
talk about the stuff

00:54:15,740 --> 00:54:19,800

YouTube URL: https://www.youtube.com/watch?v=3T3M7sPIUG0


