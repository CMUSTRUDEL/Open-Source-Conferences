Title: PHP UK Conference 2013 - Dave Ingram - API Design: It's Not Rocket Surgery
Publication date: 2013-04-16
Playlist: PHP UK Conference 2013
Description: 
	Many talks discuss REST as if that is all you need to know when building an API. It's a good start, but once you try to build something that works, you will soon discover that it takes a lot more than good resource-centric URL design and HTTP verb use. In this talk, I will discuss what is involved in building an API so you don't need to discover it by yourself. The spectrum ranges from a brief recap of RESTful principles through to handling metadata and even (horror of horrors) documentation. Learning about these fundamentals will allow you to prepare your design before writing a single line of code. You can plan development with this in mind, allowing you to deliver a more capable and flexible API to your customers from day one. It can also make it easier and more enjoyable for people to build against your API, encouraging the growth of applications and an ecosystem around it. This talk has evolved from my own experience as both an API consumer and creator.

Slides: https://speakerdeck.com/dmi/api-design-its-not-rocket-surgery-phpuk13
Captions: 
	00:00:12,950 --> 00:00:20,189
I'm Dave and go I'm a Senior Operations

00:00:17,060 --> 00:00:22,320
guy at data safe now quick plug we're

00:00:20,189 --> 00:00:24,119
hiring we're an awesome company come

00:00:22,320 --> 00:00:26,400
talk to it myself or so my colleagues

00:00:24,119 --> 00:00:27,990
are also around at the conference before

00:00:26,400 --> 00:00:31,349
that I worked for company called group

00:00:27,990 --> 00:00:32,969
spaces for a good few years I have way

00:00:31,349 --> 00:00:35,309
too many projects I've got so many

00:00:32,969 --> 00:00:36,540
things on the go at once it's difficult

00:00:35,309 --> 00:00:38,640
to balance but I'm involved in open

00:00:36,540 --> 00:00:42,300
source I've got involved with joined in

00:00:38,640 --> 00:00:45,390
among other projects and if you want to

00:00:42,300 --> 00:00:48,840
to talk to me or to heckle me or ask

00:00:45,390 --> 00:00:52,890
questions then hit DMI on twitter nice

00:00:48,840 --> 00:00:55,710
short and easy to remember so why am i

00:00:52,890 --> 00:00:57,809
giving this talk I've built quite a few

00:00:55,710 --> 00:01:01,590
api's unfortunately most of them are not

00:00:57,809 --> 00:01:03,719
public so I can't brag about them but

00:01:01,590 --> 00:01:06,900
I've consumed with a lot of api's and

00:01:03,719 --> 00:01:08,610
I've seen what happens when people try

00:01:06,900 --> 00:01:11,850
to build them without really thinking it

00:01:08,610 --> 00:01:14,670
through to begin with also I'm very

00:01:11,850 --> 00:01:17,070
opinionated as I'm sure you'll find out

00:01:14,670 --> 00:01:18,360
so if you as I said if you want to give

00:01:17,070 --> 00:01:20,070
me any feedback afterwards that's

00:01:18,360 --> 00:01:22,020
fantastic I will be responding to each

00:01:20,070 --> 00:01:23,369
and every tweet and also if you could

00:01:22,020 --> 00:01:26,130
leave some feedback on joined in that

00:01:23,369 --> 00:01:28,650
will also be wonderful and just help me

00:01:26,130 --> 00:01:32,520
make sure that that this can all improve

00:01:28,650 --> 00:01:37,020
if it needs to so what this talk isn't

00:01:32,520 --> 00:01:39,540
about is rest a lot of people talk about

00:01:37,020 --> 00:01:41,659
it and that's that's not what I'm going

00:01:39,540 --> 00:01:44,369
to do I mean it's great and all but

00:01:41,659 --> 00:01:47,040
there's so much more to building an API

00:01:44,369 --> 00:01:50,159
than just having you know like you good

00:01:47,040 --> 00:01:52,079
URL design using the right verbs you've

00:01:50,159 --> 00:01:54,470
also got to care about things like the

00:01:52,079 --> 00:01:57,600
headers that you accept some that you

00:01:54,470 --> 00:02:00,090
that you give back the authentication

00:01:57,600 --> 00:02:02,490
the data formats data integrity and

00:02:00,090 --> 00:02:04,259
documentation yes I didn't say

00:02:02,490 --> 00:02:08,009
documentation but we'll come back to

00:02:04,259 --> 00:02:10,860
that later so very very quickly I'm

00:02:08,009 --> 00:02:13,410
going to rush through what most rest

00:02:10,860 --> 00:02:15,140
talks tend cover which is good URL

00:02:13,410 --> 00:02:16,940
design

00:02:15,140 --> 00:02:21,250
my advice on this is to make them

00:02:16,940 --> 00:02:25,940
versioned to make them mean hackable and

00:02:21,250 --> 00:02:27,830
meaningful so that there's a sense of

00:02:25,940 --> 00:02:30,650
structure and those are a natural feel

00:02:27,830 --> 00:02:33,250
to them so something really simple just

00:02:30,650 --> 00:02:35,900
you know v1 for the very first version a

00:02:33,250 --> 00:02:38,920
collection of users a particular user

00:02:35,900 --> 00:02:41,000
and then attributes relating to them and

00:02:38,920 --> 00:02:43,400
building up in a structure that makes

00:02:41,000 --> 00:02:46,280
sense but from a consumer perspective

00:02:43,400 --> 00:02:49,010
they don't care how we've built things

00:02:46,280 --> 00:02:50,690
they don't care if it's really difficult

00:02:49,010 --> 00:02:52,400
to really complex or really expensive

00:02:50,690 --> 00:02:54,560
for you to calculate stuff they just

00:02:52,400 --> 00:02:56,060
want to use it in a way that makes sense

00:02:54,560 --> 00:02:59,360
to them from what they can see on the

00:02:56,060 --> 00:03:03,860
outside so use your common sense

00:02:59,360 --> 00:03:05,990
it's and you've got to try and take step

00:03:03,860 --> 00:03:07,970
back and consider how it's going to see

00:03:05,990 --> 00:03:10,970
him with if you don't have all this deep

00:03:07,970 --> 00:03:15,170
knowledge about the system one of the

00:03:10,970 --> 00:03:18,560
things that I see said about api's from

00:03:15,170 --> 00:03:21,550
time to time less so now fortunately is

00:03:18,560 --> 00:03:24,260
people throwing everything in the URL

00:03:21,550 --> 00:03:26,570
that's not quite what it's for so you

00:03:24,260 --> 00:03:30,860
don't have for example my API slash

00:03:26,570 --> 00:03:32,150
search slash term 1 slash term 2 that's

00:03:30,860 --> 00:03:34,190
what the query string is for that's what

00:03:32,150 --> 00:03:38,780
it's designed to be used for it so it's

00:03:34,190 --> 00:03:41,420
for filtering and maybe some alternate

00:03:38,780 --> 00:03:45,590
representation and flags the use of

00:03:41,420 --> 00:03:47,840
things like that so you use it for for

00:03:45,590 --> 00:03:50,900
example for controlling for paucity you

00:03:47,840 --> 00:03:54,770
don't use it for saying oh I won XML or

00:03:50,900 --> 00:03:56,420
all I want Jason there are more semantic

00:03:54,770 --> 00:03:59,060
ways of doing that you can use it with

00:03:56,420 --> 00:04:01,700
fire extensions or headers but they'll

00:03:59,060 --> 00:04:04,090
come back to that later so just for

00:04:01,700 --> 00:04:07,730
example the search I mentioned earlier

00:04:04,090 --> 00:04:10,610
you want to make sure you're using the

00:04:07,730 --> 00:04:14,000
right tools for the job and again with

00:04:10,610 --> 00:04:18,680
Jason so with formats you can use file

00:04:14,000 --> 00:04:23,720
extensions or an accept header but there

00:04:18,680 --> 00:04:25,970
there are pros and cons verbs again HTTP

00:04:23,720 --> 00:04:27,740
has quite a few only two of them you use

00:04:25,970 --> 00:04:32,000
a lot

00:04:27,740 --> 00:04:36,050
which get input getting post heads often

00:04:32,000 --> 00:04:39,830
also comes up occasionally and as I'm

00:04:36,050 --> 00:04:42,110
sure you all know poets and elites are

00:04:39,830 --> 00:04:44,360
also useful options kind of comes into

00:04:42,110 --> 00:04:48,350
it a bit and that's going to become more

00:04:44,360 --> 00:04:50,560
more popular in the near future but I

00:04:48,350 --> 00:04:55,070
find helpful to think things in terms of

00:04:50,560 --> 00:04:56,120
operating on on a data model as you can

00:04:55,070 --> 00:05:00,169
see there I'm not going to go through it

00:04:56,120 --> 00:05:04,639
all but you unless you're building a

00:05:00,169 --> 00:05:06,800
read-only API like say Google+ because

00:05:04,639 --> 00:05:08,720
you know they want to post you must

00:05:06,800 --> 00:05:12,259
handle getting posts and they're the two

00:05:08,720 --> 00:05:15,680
basic operations and all clients can

00:05:12,259 --> 00:05:18,400
handle those no matter how limited they

00:05:15,680 --> 00:05:20,570
are with the other methods you can

00:05:18,400 --> 00:05:23,389
emulate those if necessary

00:05:20,570 --> 00:05:25,389
so these silky the semantics but still

00:05:23,389 --> 00:05:28,310
support clients that are really limited

00:05:25,389 --> 00:05:31,669
so one example I've seen that I quite

00:05:28,310 --> 00:05:34,010
like for doing this is to have an

00:05:31,669 --> 00:05:36,729
exclamation mark and then the desired

00:05:34,010 --> 00:05:40,639
method name at the end and whose posts

00:05:36,729 --> 00:05:43,039
for forcing that through and that's from

00:05:40,639 --> 00:05:46,070
a semantic point of view because post

00:05:43,039 --> 00:05:49,880
requests are defined to have side

00:05:46,070 --> 00:05:52,699
effects and so they don't get cached and

00:05:49,880 --> 00:05:54,289
they last user if you want to if you're

00:05:52,699 --> 00:05:58,070
doing in a browser if you want to retry

00:05:54,289 --> 00:06:00,409
the requests and so on but one thing to

00:05:58,070 --> 00:06:02,750
remember is that put and delete should

00:06:00,409 --> 00:06:05,900
have the same effect no matter how many

00:06:02,750 --> 00:06:08,690
times they repeated so if you if

00:06:05,900 --> 00:06:11,000
somebody sends a delete message to have

00:06:08,690 --> 00:06:14,090
to take your endpoint then that should

00:06:11,000 --> 00:06:15,590
delete the required object obviously but

00:06:14,090 --> 00:06:17,389
returns success even if they do it

00:06:15,590 --> 00:06:19,729
multiple times in a row because it's not

00:06:17,389 --> 00:06:22,630
going to be anymore deleted it's already

00:06:19,729 --> 00:06:24,800
gotten and a similar thing with put

00:06:22,630 --> 00:06:29,270
you're just updating a resource you're

00:06:24,800 --> 00:06:31,400
over writing it heads is fairly rev and

00:06:29,270 --> 00:06:35,419
PHP will generally deal with that for

00:06:31,400 --> 00:06:37,870
you you can detect it to decide to do

00:06:35,419 --> 00:06:39,590
less work and less processing but

00:06:37,870 --> 00:06:41,930
depending on what you're doing that

00:06:39,590 --> 00:06:46,070
might not be be feasible or useful

00:06:41,930 --> 00:06:48,470
and options is very rare until fairly

00:06:46,070 --> 00:06:50,720
recently with the advent of cause so

00:06:48,470 --> 00:06:54,830
this is something called cross-origin

00:06:50,720 --> 00:06:57,860
resource sharing and that's of kind of

00:06:54,830 --> 00:07:02,120
grand term for getting around the same

00:06:57,860 --> 00:07:04,039
origin restriction in browsers so with

00:07:02,120 --> 00:07:06,320
browser you can only send a request to

00:07:04,039 --> 00:07:08,300
the same domain that you've got the

00:07:06,320 --> 00:07:10,910
original page from if you want to go

00:07:08,300 --> 00:07:12,370
outside of that then usually you're

00:07:10,910 --> 00:07:16,460
stuffed

00:07:12,370 --> 00:07:21,860
but with this standards which works in

00:07:16,460 --> 00:07:24,620
all major browsers of recent version is

00:07:21,860 --> 00:07:26,870
works properly in IE 10 plus it doesn't

00:07:24,620 --> 00:07:29,449
it's not quite the same in lower

00:07:26,870 --> 00:07:31,099
versions of ie it's a different and

00:07:29,449 --> 00:07:32,120
different objects but normally you won't

00:07:31,099 --> 00:07:35,479
have to care about that there are

00:07:32,120 --> 00:07:39,410
wrappers around everything but it allows

00:07:35,479 --> 00:07:41,930
you to send a sense a couple of extra

00:07:39,410 --> 00:07:44,780
headers so origin and allow origin and

00:07:41,930 --> 00:07:47,599
then the API server can then decide yes

00:07:44,780 --> 00:07:49,789
I'm going to allow this request all now

00:07:47,599 --> 00:07:54,320
you know mobi else is allowed to query

00:07:49,789 --> 00:07:56,570
the server from anywhere else this

00:07:54,320 --> 00:07:59,349
brings me nicely onto the topic of

00:07:56,570 --> 00:08:03,530
headers so they're very important things

00:07:59,349 --> 00:08:05,720
to consider they're not just sort of a

00:08:03,530 --> 00:08:07,639
sort of a throwaway Edition you can

00:08:05,720 --> 00:08:10,280
actually do a lot that makes the can

00:08:07,639 --> 00:08:12,830
make your API a lot more clever and make

00:08:10,280 --> 00:08:15,710
people enjoy using it a lot more because

00:08:12,830 --> 00:08:17,750
things just kind of act automatically so

00:08:15,710 --> 00:08:20,960
a couple of examples are the accept

00:08:17,750 --> 00:08:22,520
header which you can use for saying okay

00:08:20,960 --> 00:08:26,030
this client can only handle I don't know

00:08:22,520 --> 00:08:27,919
PNG and not JPEG and then if service

00:08:26,030 --> 00:08:29,840
clever enough it can then return

00:08:27,919 --> 00:08:31,699
resources in the right format or

00:08:29,840 --> 00:08:34,729
transcoding on the fly this can be

00:08:31,699 --> 00:08:36,969
important with video for example so if

00:08:34,729 --> 00:08:40,099
clients can only support a few types

00:08:36,969 --> 00:08:41,990
that's a good way of negotiating that

00:08:40,099 --> 00:08:46,100
without having to explicitly make them

00:08:41,990 --> 00:08:49,160
say I want you know mpeg-4 with these

00:08:46,100 --> 00:08:52,250
type of options and accept language as

00:08:49,160 --> 00:08:53,930
well is useful for deciding how to

00:08:52,250 --> 00:08:55,000
return responses that can be seen by the

00:08:53,930 --> 00:08:57,700
users

00:08:55,000 --> 00:08:59,110
so if you've got any error messages that

00:08:57,700 --> 00:09:00,460
you're returning from your API the users

00:08:59,110 --> 00:09:03,550
will end up sitting or may end up

00:09:00,460 --> 00:09:06,640
sitting and then it's useful to be able

00:09:03,550 --> 00:09:08,050
to localize that in a way that you know

00:09:06,640 --> 00:09:10,150
you don't have to keep asking the client

00:09:08,050 --> 00:09:14,050
most of them will provide that ahead

00:09:10,150 --> 00:09:15,970
automatically also important from mobile

00:09:14,050 --> 00:09:21,010
there are a lot of headers that you can

00:09:15,970 --> 00:09:24,280
use to reduce the overall traffic going

00:09:21,010 --> 00:09:27,070
back and forth and also to reduce the

00:09:24,280 --> 00:09:29,680
work that you guys have to do so there's

00:09:27,070 --> 00:09:32,820
a whole set of them etag and if

00:09:29,680 --> 00:09:36,870
non-match kind of goes paired together

00:09:32,820 --> 00:09:41,250
that an e-tag comes from the server side

00:09:36,870 --> 00:09:43,960
and it just represents they said like a

00:09:41,250 --> 00:09:46,180
short text string so it could be

00:09:43,960 --> 00:09:47,740
absolutely anything you like but it

00:09:46,180 --> 00:09:51,280
uniquely identifies that version of that

00:09:47,740 --> 00:09:53,350
resource and then the if the if match

00:09:51,280 --> 00:09:55,840
headers can be used to say only due

00:09:53,350 --> 00:09:57,550
process this request if it has changed

00:09:55,840 --> 00:09:58,020
or hasn't changed since the last time we

00:09:57,550 --> 00:10:01,180
saw it

00:09:58,020 --> 00:10:04,630
a similar thing we've modified since and

00:10:01,180 --> 00:10:07,210
last modified dates and also don't

00:10:04,630 --> 00:10:08,950
neglect the cache control headers if you

00:10:07,210 --> 00:10:11,110
can push a lot of the work downstream

00:10:08,950 --> 00:10:12,550
towards your clients so it's not hitting

00:10:11,110 --> 00:10:16,360
your server as much then you don't need

00:10:12,550 --> 00:10:17,920
as much need to do as much work one

00:10:16,360 --> 00:10:20,260
other one one of the head of the gets

00:10:17,920 --> 00:10:22,120
mentioned fairly little is the very

00:10:20,260 --> 00:10:26,110
header this is very useful if you're

00:10:22,120 --> 00:10:28,540
using I've varnish internally you can

00:10:26,110 --> 00:10:30,010
say you can provide your own sort of

00:10:28,540 --> 00:10:32,350
extra headers that then get stripped out

00:10:30,010 --> 00:10:35,170
but use that for caching the requests

00:10:32,350 --> 00:10:38,080
and for caching just sections and saying

00:10:35,170 --> 00:10:40,120
this bit varies depending on the user or

00:10:38,080 --> 00:10:45,339
depending on a cookie or depending on

00:10:40,120 --> 00:10:48,280
some other header this is all one good

00:10:45,339 --> 00:10:52,330
using headers and so on but it does come

00:10:48,280 --> 00:10:54,310
with a couple of problems so not all not

00:10:52,330 --> 00:10:56,500
all clients can use all headers if you

00:10:54,310 --> 00:11:00,339
use your own extended headers then there

00:10:56,500 --> 00:11:01,930
is a chance that corporate proxies will

00:11:00,339 --> 00:11:03,209
get in the way and will discard them

00:11:01,930 --> 00:11:05,589
completely because they have a whitelist

00:11:03,209 --> 00:11:08,019
or a particular blacklist I'll just

00:11:05,589 --> 00:11:10,920
strip anything beginning with X -

00:11:08,019 --> 00:11:15,480
also not even standard headers are safe

00:11:10,920 --> 00:11:17,860
so it has been the case where some

00:11:15,480 --> 00:11:19,240
particular corporate proxies have

00:11:17,860 --> 00:11:21,940
stripped out things like the accept

00:11:19,240 --> 00:11:24,639
header so yes you can use them and yes

00:11:21,940 --> 00:11:29,070
the the helpful but have for that

00:11:24,639 --> 00:11:32,019
methods just in case all right

00:11:29,070 --> 00:11:34,420
authentication and authorization this is

00:11:32,019 --> 00:11:36,160
a bit of a sticky topic there are lots

00:11:34,420 --> 00:11:39,610
of different ways of doing this and some

00:11:36,160 --> 00:11:41,860
people tend to roll their own which is

00:11:39,610 --> 00:11:43,959
not again not so common anymore because

00:11:41,860 --> 00:11:46,389
a lot of people use oauth2 over HTTPS

00:11:43,959 --> 00:11:49,839
which is less prefer a pretty good

00:11:46,389 --> 00:11:51,899
solution it's simpler from the

00:11:49,839 --> 00:11:54,490
implementation side than OAuth one

00:11:51,899 --> 00:11:56,290
there's less work to do less things that

00:11:54,490 --> 00:11:59,320
can go wrong and it kind of acts a bit

00:11:56,290 --> 00:12:03,459
like a session cookie just for a fairly

00:11:59,320 --> 00:12:06,550
long live session it does mean that has

00:12:03,459 --> 00:12:09,430
the the insecurity is to come with apps

00:12:06,550 --> 00:12:11,620
as well so if anybody gets hold of the

00:12:09,430 --> 00:12:13,750
token there's nothing to stop them

00:12:11,620 --> 00:12:16,870
impersonating that user and that

00:12:13,750 --> 00:12:19,120
application there are a lot of existing

00:12:16,870 --> 00:12:21,130
libraries for it and many of them are

00:12:19,120 --> 00:12:23,440
quite mature now for all such different

00:12:21,130 --> 00:12:26,380
platforms so that all the mobile

00:12:23,440 --> 00:12:28,569
platforms and all the different server

00:12:26,380 --> 00:12:31,690
side languages for both the client and

00:12:28,569 --> 00:12:33,910
server implementations so it's not

00:12:31,690 --> 00:12:35,410
generally worry for people implement

00:12:33,910 --> 00:12:37,449
against it it's just cases dropping this

00:12:35,410 --> 00:12:39,160
library give it these options and you're

00:12:37,449 --> 00:12:42,790
done

00:12:39,160 --> 00:12:46,990
there is an extension called oath to H

00:12:42,790 --> 00:12:51,130
Mac which uses signatures kind of in a

00:12:46,990 --> 00:12:51,970
similar way to both one and so requests

00:12:51,130 --> 00:12:55,089
are signed

00:12:51,970 --> 00:12:58,000
they can't be repeated and they don't

00:12:55,089 --> 00:13:02,139
give away the the client secrets but

00:12:58,000 --> 00:13:05,050
that's not used very often in in the

00:13:02,139 --> 00:13:07,569
real world so far if it's a security

00:13:05,050 --> 00:13:09,819
critical thing then yes I'd advise it

00:13:07,569 --> 00:13:12,339
but generally you will be doing this

00:13:09,819 --> 00:13:15,130
over HTTPS anyway or if you're not you

00:13:12,339 --> 00:13:17,920
really really should and that should be

00:13:15,130 --> 00:13:20,950
good enough security having said all

00:13:17,920 --> 00:13:24,160
this the original author of

00:13:20,950 --> 00:13:26,470
the earth to spec has said that it's

00:13:24,160 --> 00:13:29,680
become a bit of a corporate in fight and

00:13:26,470 --> 00:13:31,750
it's not really suited to corporations

00:13:29,680 --> 00:13:36,700
it's not really suited to normal users

00:13:31,750 --> 00:13:38,590
so his his official advice is to only

00:13:36,700 --> 00:13:43,060
use it if you follow an existing

00:13:38,590 --> 00:13:45,070
provider very closely or if you know a

00:13:43,060 --> 00:13:47,290
lot about security or if you've already

00:13:45,070 --> 00:13:48,610
started implementing it if on the other

00:13:47,290 --> 00:13:51,010
hand you're about to start something new

00:13:48,610 --> 00:13:54,630
he said you might as well use OAuth one

00:13:51,010 --> 00:13:54,630
because it's well known well understood

00:13:55,830 --> 00:14:01,240
yeah this kind of fits in here I guess

00:13:59,110 --> 00:14:03,250
perhaps questions in the past about rate

00:14:01,240 --> 00:14:05,110
limiting and things like what point

00:14:03,250 --> 00:14:08,140
should I care about limiting people

00:14:05,110 --> 00:14:12,220
using my API and and how do you go about

00:14:08,140 --> 00:14:13,600
this generally when you're starting out

00:14:12,220 --> 00:14:15,300
you're not gonna have very many users

00:14:13,600 --> 00:14:19,180
and so you can afford to get by without

00:14:15,300 --> 00:14:21,870
limiting unless it's a sort of a massive

00:14:19,180 --> 00:14:24,160
launch that spins are eagerly awaited

00:14:21,870 --> 00:14:26,680
and so you can get started to get a feel

00:14:24,160 --> 00:14:28,870
of what sensible limits should be and

00:14:26,680 --> 00:14:31,660
you can do instead of reacts fairly

00:14:28,870 --> 00:14:34,690
manually to it there are some drop-in

00:14:31,660 --> 00:14:37,450
solutions so axel is one that I've heard

00:14:34,690 --> 00:14:42,220
use quite well it's very API axel three

00:14:37,450 --> 00:14:43,450
scale and masher II also provide layers

00:14:42,220 --> 00:14:46,660
that sort of sit in the middle

00:14:43,450 --> 00:14:50,020
to help manage both the authentication

00:14:46,660 --> 00:14:53,680
of clients and also the the rate

00:14:50,020 --> 00:14:57,400
limiting and and handling all of that so

00:14:53,680 --> 00:14:58,720
you don't have to worry but yeah

00:14:57,400 --> 00:15:00,190
generally it shouldn't be a mushroom

00:14:58,720 --> 00:15:01,870
problem especially in the early days

00:15:00,190 --> 00:15:03,700
it's only once you get big or if you're

00:15:01,870 --> 00:15:07,860
charging for use of your API that you

00:15:03,700 --> 00:15:10,630
need to worry about that data formats

00:15:07,860 --> 00:15:13,090
there's a lot of discussion about XML

00:15:10,630 --> 00:15:17,110
versus Jason and yeah what people prefer

00:15:13,090 --> 00:15:18,910
and I'm gonna be I'm sure if my opinions

00:15:17,110 --> 00:15:24,760
here and say that Jason is the one true

00:15:18,910 --> 00:15:26,530
way XML is is great for what if you like

00:15:24,760 --> 00:15:28,660
the corporate style of customers in my

00:15:26,530 --> 00:15:34,000
opinion sort of the enterprise thing but

00:15:28,660 --> 00:15:37,270
is very verbose it repeats itself a lot

00:15:34,000 --> 00:15:40,990
and it can be a bit of a pain to work

00:15:37,270 --> 00:15:42,700
with but one of the key things is to

00:15:40,990 --> 00:15:46,890
have is not just to return the response

00:15:42,700 --> 00:15:49,510
but include out/banned data as well so

00:15:46,890 --> 00:15:52,930
being able to include outbound data like

00:15:49,510 --> 00:15:55,180
out-of-band data like this is very very

00:15:52,930 --> 00:15:57,550
useful especially for systems that have

00:15:55,180 --> 00:15:59,890
notifications so instead of having the

00:15:57,550 --> 00:16:01,120
client continually ping you and say do I

00:15:59,890 --> 00:16:03,540
have any more notifications do I have

00:16:01,120 --> 00:16:07,810
any more notifications to show the user

00:16:03,540 --> 00:16:10,300
you can send it sort of beside do all

00:16:07,810 --> 00:16:11,950
the normal responses and say you know

00:16:10,300 --> 00:16:13,180
yes by the way while you're at it and

00:16:11,950 --> 00:16:15,490
here's some new stuff that's happened

00:16:13,180 --> 00:16:17,830
without having to set up and configure

00:16:15,490 --> 00:16:23,280
any type of say cloud-to-device

00:16:17,830 --> 00:16:27,040
messaging it also lets you use JSONP

00:16:23,280 --> 00:16:29,700
which because it's just loading a script

00:16:27,040 --> 00:16:33,400
tag if the server returns an error code

00:16:29,700 --> 00:16:34,900
an HTTP error then the script will just

00:16:33,400 --> 00:16:37,390
fail to load won't get parsed and won't

00:16:34,900 --> 00:16:40,540
run so what you have to do is to return

00:16:37,390 --> 00:16:43,570
success and then add the the actual

00:16:40,540 --> 00:16:45,400
status code you know failure or whatever

00:16:43,570 --> 00:16:48,430
it might be in a metal block alongside

00:16:45,400 --> 00:16:51,220
it it also gives you a place to put

00:16:48,430 --> 00:16:54,400
things like deprecation information so

00:16:51,220 --> 00:16:56,530
if a particular API is going away soon

00:16:54,400 --> 00:16:59,560
or changing you can add developer notes

00:16:56,530 --> 00:17:01,300
there you can also use it for rate limit

00:16:59,560 --> 00:17:05,709
information as well to make it easy to

00:17:01,300 --> 00:17:09,370
parse and easy to extract yeah so I've

00:17:05,709 --> 00:17:12,459
been through all of that so what about

00:17:09,370 --> 00:17:15,010
XML again everything you can do is

00:17:12,459 --> 00:17:19,420
racing you can do with XML and yeah I'll

00:17:15,010 --> 00:17:21,939
give you can do a lot more if it's the

00:17:19,420 --> 00:17:24,459
sort of thing that's required for your

00:17:21,939 --> 00:17:26,350
particular application then go for it go

00:17:24,459 --> 00:17:27,760
wild if you're just going to include it

00:17:26,350 --> 00:17:30,370
as an option

00:17:27,760 --> 00:17:32,350
I would advise just sticking to one data

00:17:30,370 --> 00:17:34,630
format because it'll make your life a

00:17:32,350 --> 00:17:36,100
lot easier unless you starting to get a

00:17:34,630 --> 00:17:38,670
lot of requests from other people saying

00:17:36,100 --> 00:17:43,690
hey what about there what about this

00:17:38,670 --> 00:17:45,970
most consumers and all most systems will

00:17:43,690 --> 00:17:47,900
have very good very mature fast and

00:17:45,970 --> 00:17:52,060
efficient JSON parsing libraries

00:17:47,900 --> 00:17:54,440
so is one less thing to worry about

00:17:52,060 --> 00:17:58,340
something else that gets bandied about

00:17:54,440 --> 00:18:00,950
with with rest is hypertext is the

00:17:58,340 --> 00:18:03,560
engine of applications state and this is

00:18:00,950 --> 00:18:06,080
a very basically a very long way of

00:18:03,560 --> 00:18:09,490
saying that you include the links to

00:18:06,080 --> 00:18:12,200
what you can do next in the response

00:18:09,490 --> 00:18:16,100
personally I'm not a fan of it it is

00:18:12,200 --> 00:18:20,180
useful to people who are building API

00:18:16,100 --> 00:18:22,010
explorers so they can get so you can

00:18:20,180 --> 00:18:23,870
show useful information to the you know

00:18:22,010 --> 00:18:25,520
to the consumer and say these are the

00:18:23,870 --> 00:18:27,020
kind of things that can happen so if

00:18:25,520 --> 00:18:30,950
you're going through a shopping cart

00:18:27,020 --> 00:18:33,740
process you'd have you're sort of adding

00:18:30,950 --> 00:18:35,240
items to the cart with endpoint would

00:18:33,740 --> 00:18:38,840
then return your response that gives you

00:18:35,240 --> 00:18:41,330
links to the beginnings of the checkout

00:18:38,840 --> 00:18:42,710
process so you can just sort of follow

00:18:41,330 --> 00:18:45,140
those through and you don't have to

00:18:42,710 --> 00:18:48,560
build the URLs and things yourself you

00:18:45,140 --> 00:18:50,500
just have a single entry point it has

00:18:48,560 --> 00:18:52,880
its advantages and disadvantages but

00:18:50,500 --> 00:18:57,800
most the time I'd argue you're not going

00:18:52,880 --> 00:19:00,170
to need it and also don't forget mobile

00:18:57,800 --> 00:19:03,410
browsers and mobile clients do have

00:19:00,170 --> 00:19:05,870
limited bandwidth still many people may

00:19:03,410 --> 00:19:07,940
not use 3G connections may not have them

00:19:05,870 --> 00:19:09,710
available and so you've got to be

00:19:07,940 --> 00:19:12,410
conservative with the amount of data you

00:19:09,710 --> 00:19:16,060
have if people you build their clients

00:19:12,410 --> 00:19:19,070
well and they will support gzip encoding

00:19:16,060 --> 00:19:20,360
so it's less of an issue but that's not

00:19:19,070 --> 00:19:24,590
always the case you can't guarantee

00:19:20,360 --> 00:19:29,440
people are going to build good clients a

00:19:24,590 --> 00:19:33,050
quick word about time stamps there's a

00:19:29,440 --> 00:19:35,990
divide here between making your API

00:19:33,050 --> 00:19:38,510
readable to normal normal people and all

00:19:35,990 --> 00:19:41,480
humans trying to decode it and against

00:19:38,510 --> 00:19:46,040
making it very useful for the of the

00:19:41,480 --> 00:19:48,620
clients to handle having a date in an

00:19:46,040 --> 00:19:50,270
ISO style format looks very nice and

00:19:48,620 --> 00:19:51,470
it's easy for somebody to understand and

00:19:50,270 --> 00:19:54,740
you know you're embedding the timezone

00:19:51,470 --> 00:19:56,810
information and so on but it's extra

00:19:54,740 --> 00:19:59,600
work for the client to actually end up

00:19:56,810 --> 00:20:02,539
decoding it well it's a lot easier for

00:19:59,600 --> 00:20:05,149
them to deal with is just the simple

00:20:02,539 --> 00:20:06,829
second since epoch and if you do need

00:20:05,149 --> 00:20:10,639
timezone information as well then you

00:20:06,829 --> 00:20:14,509
can add that into the response but yeah

00:20:10,639 --> 00:20:18,559
usually it's it's not it will be shown

00:20:14,509 --> 00:20:20,479
in the local timezone of the user so yes

00:20:18,559 --> 00:20:25,399
I don't think human readability is

00:20:20,479 --> 00:20:27,499
essential if it sacrifices convenience

00:20:25,399 --> 00:20:37,849
and efficiency from the machine parsing

00:20:27,499 --> 00:20:39,320
side okay H integrity this kind of with

00:20:37,849 --> 00:20:42,049
a bit of a weird title for this section

00:20:39,320 --> 00:20:46,039
but I'm gonna just cover a lot of stuff

00:20:42,049 --> 00:20:47,839
to do with the date of your passing back

00:20:46,039 --> 00:20:50,359
and forth so one of the important things

00:20:47,839 --> 00:20:51,649
is to make sure that your consumers to

00:20:50,359 --> 00:20:55,459
make it as easy for you consume is to

00:20:51,649 --> 00:20:56,599
cache data as you can because the less

00:20:55,459 --> 00:20:58,669
times they're hitting a serve the less

00:20:56,599 --> 00:21:00,259
work you're doing the last money you

00:20:58,669 --> 00:21:02,209
need to spend in order to get it done

00:21:00,259 --> 00:21:05,929
and the less you have to worry about

00:21:02,209 --> 00:21:08,899
efficiency so just using the simple

00:21:05,929 --> 00:21:11,619
standard headers as I mentioned earlier

00:21:08,899 --> 00:21:16,669
the F modified since and if none match

00:21:11,619 --> 00:21:19,729
will only return a response if the the

00:21:16,669 --> 00:21:22,399
data has changed either in what is what

00:21:19,729 --> 00:21:24,379
it contains for the none match or when

00:21:22,399 --> 00:21:26,839
it was last updated and a similar thing

00:21:24,379 --> 00:21:30,349
with put post put and delete you can say

00:21:26,839 --> 00:21:32,269
only do these if the resource is what I

00:21:30,349 --> 00:21:35,539
knew it to be before and this is

00:21:32,269 --> 00:21:37,249
something you can then use in conflict

00:21:35,539 --> 00:21:40,639
detection which I'll go through in just

00:21:37,249 --> 00:21:42,829
second but so you need to return the the

00:21:40,639 --> 00:21:44,690
relevant response headers to make this

00:21:42,829 --> 00:21:51,159
actually useful and viable for your

00:21:44,690 --> 00:21:54,259
consumers so excuse me so you can use

00:21:51,159 --> 00:21:57,440
HTTP to build preconditions about the

00:21:54,259 --> 00:21:58,849
response to help with data safety and to

00:21:57,440 --> 00:22:00,889
help make sure people don't stomp over

00:21:58,849 --> 00:22:03,649
each other's changes so there are whole

00:22:00,889 --> 00:22:07,549
set of states codes that are useful to

00:22:03,649 --> 00:22:09,879
know about 4:05 is basically you try to

00:22:07,549 --> 00:22:13,519
get from a post only endpoint or similar

00:22:09,879 --> 00:22:14,269
and you should return a list or I think

00:22:13,519 --> 00:22:17,269
must

00:22:14,269 --> 00:22:21,769
list of allowable verbs for that

00:22:17,269 --> 00:22:24,950
endpoint 406 is just I can't give you

00:22:21,769 --> 00:22:25,580
any kind of any content type that you'll

00:22:24,950 --> 00:22:29,089
accept

00:22:25,580 --> 00:22:29,769
so either relax that or go somewhere

00:22:29,089 --> 00:22:35,659
else

00:22:29,769 --> 00:22:36,950
4:12 428 allow you to again stop people

00:22:35,659 --> 00:22:39,080
stumping over each other's changes and

00:22:36,950 --> 00:22:42,049
there is an official status code for the

00:22:39,080 --> 00:22:45,889
to many requests for safety if you've

00:22:42,049 --> 00:22:48,709
throttled somebody rate limited them so

00:22:45,889 --> 00:22:52,700
you stopping race conditions and so you

00:22:48,709 --> 00:22:55,669
have a wiki and somebody is trying to

00:22:52,700 --> 00:22:57,579
update it they're descending in the

00:22:55,669 --> 00:23:01,279
simplest case some HTML content back

00:22:57,579 --> 00:23:02,419
until I update this page if they haven't

00:23:01,279 --> 00:23:04,519
included any of the conflict resolution

00:23:02,419 --> 00:23:07,339
headers it's perfectly acceptable for

00:23:04,519 --> 00:23:09,679
you to essentially to sell them off and

00:23:07,339 --> 00:23:12,649
say no don't do that I'm not going to

00:23:09,679 --> 00:23:14,659
listen until you can prove to me that

00:23:12,649 --> 00:23:18,429
you at least know what the what the

00:23:14,659 --> 00:23:24,859
response was originally and that you you

00:23:18,429 --> 00:23:28,159
would care about any changes so what you

00:23:24,859 --> 00:23:32,959
do is you add the eff modify unmodified

00:23:28,159 --> 00:23:35,959
since and if match headers and the e-tag

00:23:32,959 --> 00:23:37,399
itself can be anything at all so in this

00:23:35,959 --> 00:23:39,440
case it's useful to have it just as a

00:23:37,399 --> 00:23:41,629
revision number for the for the wiki

00:23:39,440 --> 00:23:43,519
page and then the server can say

00:23:41,629 --> 00:23:46,549
actually hey somebody's updated it since

00:23:43,519 --> 00:23:47,149
and so I'm not going to let you fall on

00:23:46,549 --> 00:23:52,429
that request

00:23:47,149 --> 00:23:55,269
fetch it again complain to the user okay

00:23:52,429 --> 00:23:57,950
documentation everybody's favorite topic

00:23:55,269 --> 00:24:01,909
it's really really important I can't

00:23:57,950 --> 00:24:05,539
overstate how vital good documentation

00:24:01,909 --> 00:24:06,799
is to adoption of an API if people can't

00:24:05,539 --> 00:24:08,809
understand what they're doing with it

00:24:06,799 --> 00:24:10,279
what you expect and how to build against

00:24:08,809 --> 00:24:12,379
it they're going to go somewhere else

00:24:10,279 --> 00:24:17,269
because it's just too much effort for

00:24:12,379 --> 00:24:18,979
for them to kick it around so the key

00:24:17,269 --> 00:24:22,820
thing there is to use a lot of examples

00:24:18,979 --> 00:24:24,979
and not to truncate them to show them to

00:24:22,820 --> 00:24:27,620
show you the end users exactly what

00:24:24,979 --> 00:24:28,520
they're going to see and guess when they

00:24:27,620 --> 00:24:32,000
when they're making all of these

00:24:28,520 --> 00:24:34,820
requests and not just assume that they

00:24:32,000 --> 00:24:38,000
will we'll fill in the gaps themselves

00:24:34,820 --> 00:24:40,700
and with documentation it is vital to

00:24:38,000 --> 00:24:42,260
make sure it does actually match the API

00:24:40,700 --> 00:24:45,200
you've built it it does sound like a bit

00:24:42,260 --> 00:24:47,659
of a silly thing but it can be very easy

00:24:45,200 --> 00:24:51,650
for the things you build to get out of

00:24:47,659 --> 00:24:55,309
sync with with the documentation so it's

00:24:51,650 --> 00:24:57,770
not bad idea to add the documentation

00:24:55,309 --> 00:24:59,600
examples to your automated tests so you

00:24:57,770 --> 00:25:01,190
can then say all right now this is file

00:24:59,600 --> 00:25:04,820
we need to update the docs otherwise

00:25:01,190 --> 00:25:06,020
people can get very confused you can't

00:25:04,820 --> 00:25:08,899
guarantee that people are going to

00:25:06,020 --> 00:25:12,590
understand that when you say at this

00:25:08,899 --> 00:25:15,440
point we return an identifier an ID and

00:25:12,590 --> 00:25:19,010
it's an integer that you really mean

00:25:15,440 --> 00:25:21,649
it's an unsigned 64-bit integer because

00:25:19,010 --> 00:25:22,970
people then just do all sorts of

00:25:21,649 --> 00:25:25,279
different possibilities

00:25:22,970 --> 00:25:27,140
they will then blame you when the a when

00:25:25,279 --> 00:25:29,210
the application breaks because they use

00:25:27,140 --> 00:25:34,970
the assigned first two bit instead of

00:25:29,210 --> 00:25:36,830
unsigned 64 so yeah it could be a strain

00:25:34,970 --> 00:25:38,899
could be anything you need to be very

00:25:36,830 --> 00:25:40,909
explicit and you want to make it as easy

00:25:38,899 --> 00:25:45,279
as possible for people to just start

00:25:40,909 --> 00:25:47,899
using this and there are lots of

00:25:45,279 --> 00:25:51,200
documentation tools around and

00:25:47,899 --> 00:25:53,450
interactive consoles so again massery

00:25:51,200 --> 00:25:55,399
are very good they've got a tool called

00:25:53,450 --> 00:25:58,100
i/o docks

00:25:55,399 --> 00:26:01,909
there's Apogee which do I think the

00:25:58,100 --> 00:26:04,909
Twitter API console among many others

00:26:01,909 --> 00:26:09,740
and there's apiary as well which also is

00:26:04,909 --> 00:26:12,529
quite a nice but finally just kind of

00:26:09,740 --> 00:26:14,120
sneak this in was something that can

00:26:12,529 --> 00:26:18,140
also slip by the wayside when you're

00:26:14,120 --> 00:26:23,450
building an API like this is that

00:26:18,140 --> 00:26:26,630
statistics so everybody loves yes seeing

00:26:23,450 --> 00:26:28,580
how things are being used and my advice

00:26:26,630 --> 00:26:30,770
is it's much better to have numbers for

00:26:28,580 --> 00:26:32,809
things you don't need then to come

00:26:30,770 --> 00:26:36,530
across the problem and have no idea

00:26:32,809 --> 00:26:39,049
where the latency might be or if there's

00:26:36,530 --> 00:26:40,730
been a sudden spike in connections you

00:26:39,049 --> 00:26:41,120
need to have all the information you can

00:26:40,730 --> 00:26:42,560
get

00:26:41,120 --> 00:26:45,190
so you can make the best decisions you

00:26:42,560 --> 00:26:47,540
can about capacity planning and

00:26:45,190 --> 00:26:48,710
troubleshooting and of course everyone

00:26:47,540 --> 00:26:51,350
loves graphs they're great for

00:26:48,710 --> 00:26:53,420
management and they're important for

00:26:51,350 --> 00:26:56,780
getting a feel for how the system is

00:26:53,420 --> 00:26:58,910
working how it's running and for

00:26:56,780 --> 00:27:03,140
understanding how the performance works

00:26:58,910 --> 00:27:07,120
best where the bottlenecks might be so

00:27:03,140 --> 00:27:09,890
just as an example of things to measure

00:27:07,120 --> 00:27:11,330
have separate counters for each status

00:27:09,890 --> 00:27:13,520
that you're responding either you're

00:27:11,330 --> 00:27:17,080
returning because it might be that

00:27:13,520 --> 00:27:19,160
you're running this API and all of your

00:27:17,080 --> 00:27:20,330
latency metrics are really really low

00:27:19,160 --> 00:27:21,800
you're returning this forces really

00:27:20,330 --> 00:27:23,420
really quickly and it sounds fantastic

00:27:21,800 --> 00:27:25,570
but none of the customers getting any

00:27:23,420 --> 00:27:28,730
data because all you're doing is sending

00:27:25,570 --> 00:27:30,080
redirection responses instead if you're

00:27:28,730 --> 00:27:32,000
not counting and looking for things like

00:27:30,080 --> 00:27:36,560
that you might have no easy way of

00:27:32,000 --> 00:27:39,170
telling other things like client usage

00:27:36,560 --> 00:27:42,380
is just good to keep an eye on just for

00:27:39,170 --> 00:27:45,440
the general health and things like

00:27:42,380 --> 00:27:47,360
authentication failures can give you an

00:27:45,440 --> 00:27:51,980
idea if somebody's trying to break into

00:27:47,360 --> 00:27:54,710
it or to try and break the system when

00:27:51,980 --> 00:27:57,710
you get to the point of having multiple

00:27:54,710 --> 00:28:00,440
versions of your API once something is

00:27:57,710 --> 00:28:02,600
out you generally can't change it

00:28:00,440 --> 00:28:05,000
it's a bit like extending a class you

00:28:02,600 --> 00:28:09,350
can add more stuff but you can't get rid

00:28:05,000 --> 00:28:11,270
of anything that's already there so it's

00:28:09,350 --> 00:28:12,560
useful to keep track of how many people

00:28:11,270 --> 00:28:14,840
are still using the old version of your

00:28:12,560 --> 00:28:16,160
API and who exactly that is so you can

00:28:14,840 --> 00:28:18,680
start following them up and saying look

00:28:16,160 --> 00:28:21,290
this is going away in three months or

00:28:18,680 --> 00:28:25,010
whatever now you really should look at

00:28:21,290 --> 00:28:26,360
moving and then all the other internal

00:28:25,010 --> 00:28:29,000
things you should be you should be

00:28:26,360 --> 00:28:32,480
keeping track of I hope ya like memory

00:28:29,000 --> 00:28:35,530
usage and disk space DB queries and

00:28:32,480 --> 00:28:38,960
that's the thing I think that's it so

00:28:35,530 --> 00:28:40,160
thank you very much if you want to leave

00:28:38,960 --> 00:28:40,790
feedback and joined in I'd really

00:28:40,160 --> 00:28:43,880
appreciate it

00:28:40,790 --> 00:28:45,740
if you have any questions that I browse

00:28:43,880 --> 00:28:48,550
times cover here please bother me on

00:28:45,740 --> 00:28:53,980
Twitter and I will be posting the slides

00:28:48,550 --> 00:28:53,980
on joined in as well later on thank you

00:28:58,779 --> 00:29:10,549
so you any questions anybody really I'm

00:29:06,350 --> 00:29:14,779
surprised anyone in the other room got a

00:29:10,549 --> 00:29:17,360
question in the other room yeah you

00:29:14,779 --> 00:29:20,840
mentioned the bow set in the version of

00:29:17,360 --> 00:29:25,419
the API in URL string where do you stand

00:29:20,840 --> 00:29:27,799
on doing it using content negotiation so

00:29:25,419 --> 00:29:32,059
using content negotiation for the

00:29:27,799 --> 00:29:34,789
version of the API my feelings about

00:29:32,059 --> 00:29:38,510
that is that if you have the API version

00:29:34,789 --> 00:29:42,440
in the URL it's possible it's a lot

00:29:38,510 --> 00:29:44,360
easier to segment that so to say all

00:29:42,440 --> 00:29:46,309
requests for this particular version go

00:29:44,360 --> 00:29:48,770
to this subset of servers we have a new

00:29:46,309 --> 00:29:51,440
version you can go out there to again

00:29:48,770 --> 00:29:52,700
another specific subset of servers and

00:29:51,440 --> 00:29:55,490
then sort of slowly sunset the other

00:29:52,700 --> 00:29:57,169
ones it also makes it easier for the

00:29:55,490 --> 00:29:58,570
reporting point of view so you can just

00:29:57,169 --> 00:30:00,590
quickly look through your logs and

00:29:58,570 --> 00:30:03,110
without having to make any changes they

00:30:00,590 --> 00:30:05,779
will be logging the URL anyway so you

00:30:03,110 --> 00:30:07,130
can keep track of get some idea of the

00:30:05,779 --> 00:30:09,649
overview of how many people are using

00:30:07,130 --> 00:30:13,220
the different versions but also again

00:30:09,649 --> 00:30:14,720
there's the possibility of really

00:30:13,220 --> 00:30:17,120
restrictive proxies stripping out the

00:30:14,720 --> 00:30:20,990
accept header and so you then lose that

00:30:17,120 --> 00:30:22,760
version information so the safety sake

00:30:20,990 --> 00:30:30,320
and for maximum compatibility

00:30:22,760 --> 00:30:31,690
I'd say the URL is the face to go okay

00:30:30,320 --> 00:30:34,399
anybody else

00:30:31,690 --> 00:30:35,710
hello I've been to the room and just a

00:30:34,399 --> 00:30:38,539
quick question you mentioned about the

00:30:35,710 --> 00:30:40,580
returning of the HTTP status all the

00:30:38,539 --> 00:30:42,980
states of the requests in the master

00:30:40,580 --> 00:30:45,860
object yeah where do you sort of draw

00:30:42,980 --> 00:30:49,279
the line between using the HTTP status

00:30:45,860 --> 00:30:51,860
code as part of the response versus in

00:30:49,279 --> 00:30:53,169
the meta object itself like for a for

00:30:51,860 --> 00:30:55,789
example would you return that as

00:30:53,169 --> 00:30:56,299
metadata or just use the normal status

00:30:55,789 --> 00:31:03,500
code

00:30:56,299 --> 00:31:06,559
sure so the HTTP code should always be

00:31:03,500 --> 00:31:08,090
in the meta response so is is there easy

00:31:06,559 --> 00:31:10,929
to pick up and easy to pars in so you

00:31:08,090 --> 00:31:13,119
remain consistent but if

00:31:10,929 --> 00:31:15,759
I think the only case in which you

00:31:13,119 --> 00:31:21,009
shouldn't use the official HTTP safes

00:31:15,759 --> 00:31:23,409
code in the the headline of the safest

00:31:21,009 --> 00:31:27,460
line of response is if somebody has

00:31:23,409 --> 00:31:29,409
explicitly requested JSONP other than

00:31:27,460 --> 00:31:30,700
that it should always be

00:31:29,409 --> 00:31:34,869
you should always sort of stick to the

00:31:30,700 --> 00:31:35,489
semantics this somatic a to http as much

00:31:34,869 --> 00:31:44,009
as possible

00:31:35,489 --> 00:31:44,009
cool Thanks okay anymore for anymore

00:31:45,059 --> 00:31:52,839
nope all right hastened do me up a room

00:31:49,509 --> 00:31:54,609
oh it's another question the other I'm

00:31:52,839 --> 00:31:57,339
sorry yeah you were talking about I'm

00:31:54,609 --> 00:31:59,109
documenting your api's and you didn't

00:31:57,339 --> 00:32:01,239
talk much about kind of self documenting

00:31:59,109 --> 00:32:03,460
api's and and how those can be done with

00:32:01,239 --> 00:32:05,289
me and with the other verbs as well if

00:32:03,460 --> 00:32:10,509
you could expand on how those relation

00:32:05,289 --> 00:32:13,719
and preferences so say you're asking how

00:32:10,509 --> 00:32:15,700
how I would worry if you kill this

00:32:13,719 --> 00:32:18,190
metadata and verbs to kind of

00:32:15,700 --> 00:32:20,049
automatically document your api's yeah

00:32:18,190 --> 00:32:25,869
and rather than having to explicitly

00:32:20,049 --> 00:32:30,009
document them yes so if you have good

00:32:25,869 --> 00:32:32,940
use of like good URL design and good

00:32:30,009 --> 00:32:34,960
verb use then it's fairly

00:32:32,940 --> 00:32:37,269
straightforward to see once you've got a

00:32:34,960 --> 00:32:43,960
list of what's allowed what it will all

00:32:37,269 --> 00:32:46,989
do if there are tools I think I think

00:32:43,960 --> 00:32:50,049
apiary does this where you can just give

00:32:46,989 --> 00:32:52,359
it a list of the endpoints and the verbs

00:32:50,049 --> 00:32:55,149
and it will generate the basic

00:32:52,359 --> 00:32:56,739
documentation for you I can't remember

00:32:55,149 --> 00:32:58,599
off the top of my head which of those it

00:32:56,739 --> 00:33:02,889
is but is one of the one of the

00:32:58,599 --> 00:33:03,609
documentation tools does that answer

00:33:02,889 --> 00:33:06,909
your question

00:33:03,609 --> 00:33:10,719
that's fine thank you okay we've got

00:33:06,909 --> 00:33:11,859
another question yeah yeah is it worth

00:33:10,719 --> 00:33:14,379
pointing out there's quite a difference

00:33:11,859 --> 00:33:16,839
between generated documentation and

00:33:14,379 --> 00:33:18,009
human written documentation there's kind

00:33:16,839 --> 00:33:19,509
of space for both of those things

00:33:18,009 --> 00:33:20,000
obviously the generated Sophia's gonna

00:33:19,509 --> 00:33:23,030
be a queue

00:33:20,000 --> 00:33:24,740
but with the human written stuff you can

00:33:23,030 --> 00:33:26,990
provide examples you provide usage

00:33:24,740 --> 00:33:29,120
patterns this is how we advise you use

00:33:26,990 --> 00:33:31,130
this is what we we think you can do with

00:33:29,120 --> 00:33:33,340
our FB i--'s which you're never going to

00:33:31,130 --> 00:33:35,990
be able to generate who's always a value

00:33:33,340 --> 00:33:37,940
yes no that is a good point but the

00:33:35,990 --> 00:33:41,240
having the documentation automatically

00:33:37,940 --> 00:33:43,070
generated to begin with is better than

00:33:41,240 --> 00:33:44,930
nothing at all so at least you have

00:33:43,070 --> 00:33:46,940
something for each end point but yes

00:33:44,930 --> 00:33:49,370
having everything custom built you know

00:33:46,940 --> 00:33:51,050
it custom written by an actual person is

00:33:49,370 --> 00:33:55,870
obviously going to be a lot better a lot

00:33:51,050 --> 00:33:59,000
more understandable your question yeah

00:33:55,870 --> 00:34:02,680
still regarding the documentation you

00:33:59,000 --> 00:34:04,610
mentioned that you we should add

00:34:02,680 --> 00:34:07,040
documentation validation on the

00:34:04,610 --> 00:34:11,120
automated tests could you expand a

00:34:07,040 --> 00:34:17,500
little bit on that please sure so one of

00:34:11,120 --> 00:34:19,909
the these things that I've done with a

00:34:17,500 --> 00:34:23,389
internal API which I don't think has

00:34:19,909 --> 00:34:26,330
made it public yet for for group spaces

00:34:23,389 --> 00:34:32,419
was that we had some internal tests

00:34:26,330 --> 00:34:35,899
which would run mock requests against

00:34:32,419 --> 00:34:39,590
our API and all of the data for those

00:34:35,899 --> 00:34:40,730
came from the documentation so the

00:34:39,590 --> 00:34:44,360
documentation listed everything

00:34:40,730 --> 00:34:47,270
including the headers for both the

00:34:44,360 --> 00:34:48,530
requests in the response and then there

00:34:47,270 --> 00:34:51,679
was just something which would pass

00:34:48,530 --> 00:34:53,840
through that documentation looking for

00:34:51,679 --> 00:34:56,270
it was the documentation been sort of

00:34:53,840 --> 00:34:57,890
marked up beforehand and then it would

00:34:56,270 --> 00:35:01,280
just look through the documentation pull

00:34:57,890 --> 00:35:02,720
out those example requests and then use

00:35:01,280 --> 00:35:05,840
them as actual tests just to make sure

00:35:02,720 --> 00:35:07,580
it did something reasonable it's

00:35:05,840 --> 00:35:10,310
something approximating what those

00:35:07,580 --> 00:35:14,970
requests do what the documentation said

00:35:10,310 --> 00:35:18,070
they were going to do Thanks

00:35:14,970 --> 00:35:19,180
okay more questions sorry that's all

00:35:18,070 --> 00:35:21,220
right so it's a little bit surreal

00:35:19,180 --> 00:35:22,360
having I've seen no questions in this

00:35:21,220 --> 00:35:26,050
room where I can see people

00:35:22,360 --> 00:35:29,850
I think everyone feels a lot safer if if

00:35:26,050 --> 00:35:32,350
I can't see them you mentioned about

00:35:29,850 --> 00:35:34,260
monitoring almost everything in your API

00:35:32,350 --> 00:35:37,930
yes how do you do that without

00:35:34,260 --> 00:35:42,760
noticeable performance hit so there are

00:35:37,930 --> 00:35:45,340
lots of there are things that you can do

00:35:42,760 --> 00:35:48,670
to to collect numbers just sort of a

00:35:45,340 --> 00:35:53,230
long site normal can all work but things

00:35:48,670 --> 00:35:56,040
like stats D from Etsy and then

00:35:53,230 --> 00:35:59,980
Graphite's are really good

00:35:56,040 --> 00:36:02,800
primo impact ways of adding monitoring

00:35:59,980 --> 00:36:05,170
to your API so star C you can just push

00:36:02,800 --> 00:36:06,090
things at it very quickly it uses UDP so

00:36:05,170 --> 00:36:09,040
it's non-blocking

00:36:06,090 --> 00:36:10,840
and it will then pass the information on

00:36:09,040 --> 00:36:13,540
to graphite which handles or the

00:36:10,840 --> 00:36:22,060
counting the retention and generates

00:36:13,540 --> 00:36:23,230
pretty graphs Cheers all right that's it

00:36:22,060 --> 00:36:25,480
how's it

00:36:23,230 --> 00:36:27,840
you know sittin here all right thank you

00:36:25,480 --> 00:36:27,840
very much

00:36:39,900 --> 00:36:41,960

YouTube URL: https://www.youtube.com/watch?v=aoiaSkRCObY


