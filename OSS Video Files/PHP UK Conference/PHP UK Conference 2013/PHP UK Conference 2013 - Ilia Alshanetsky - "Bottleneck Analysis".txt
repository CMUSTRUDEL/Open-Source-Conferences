Title: PHP UK Conference 2013 - Ilia Alshanetsky - "Bottleneck Analysis"
Publication date: 2013-04-16
Playlist: PHP UK Conference 2013
Description: 
	A how-to guide on identifying bottlenecks and scalability challenges within web based applications. The session will do an in-depth coverage of the tools involved and how they can be used in real-life situations as well how to go about correctly interpreting the results and correlating them to flaws in the code and/or infrastructure.

Slides: http://ilia.ws/files/phpuk_bottlenecks.pdf
Captions: 
	00:00:08,910 --> 00:00:14,260
and all right so a couple of quick

00:00:12,789 --> 00:00:17,980
things before we start the presentation

00:00:14,260 --> 00:00:19,540
I think we have a fairly short time

00:00:17,980 --> 00:00:21,790
window so I'm going to ask you to try to

00:00:19,540 --> 00:00:24,070
hold up the questions until the end and

00:00:21,790 --> 00:00:27,099
if we won't have time for questions then

00:00:24,070 --> 00:00:28,960
I'll be around both later on today and

00:00:27,099 --> 00:00:31,169
tomorrow so come find me if you have any

00:00:28,960 --> 00:00:35,649
questions around any of the slides or

00:00:31,169 --> 00:00:38,469
anything that comes up so a few quick

00:00:35,649 --> 00:00:40,870
words about myself so I've been working

00:00:38,469 --> 00:00:43,210
on PHP for quite some time worked on

00:00:40,870 --> 00:00:46,600
variety of extensions a little bit unzen

00:00:43,210 --> 00:00:48,910
engine variety of other pieces so kind

00:00:46,600 --> 00:00:51,030
of you know worked with PHP both is a

00:00:48,910 --> 00:00:55,480
user and as a developer of the language

00:00:51,030 --> 00:00:57,880
and my day job I work at a small company

00:00:55,480 --> 00:01:00,130
in Canada code center where we actually

00:00:57,880 --> 00:01:02,290
use PHP and a lot of similar

00:01:00,130 --> 00:01:05,610
technologies to develop enterprise

00:01:02,290 --> 00:01:08,140
applications for home services industry

00:01:05,610 --> 00:01:11,829
so that's kind of where my day-to-day

00:01:08,140 --> 00:01:14,880
experience with PHP comes and from so

00:01:11,829 --> 00:01:18,009
what I wanted to talk about today is

00:01:14,880 --> 00:01:20,079
bottlenecks and I wanted to take a

00:01:18,009 --> 00:01:21,340
slightly different approach then just

00:01:20,079 --> 00:01:24,039
you know saying how you're going to

00:01:21,340 --> 00:01:25,689
optimize your code because that's been

00:01:24,039 --> 00:01:27,969
done many times and you know I've done

00:01:25,689 --> 00:01:30,609
those stocks myself once or twice as

00:01:27,969 --> 00:01:31,929
well but one of the things that I find

00:01:30,609 --> 00:01:34,420
especially when looking at real

00:01:31,929 --> 00:01:37,659
applications is that often looking at

00:01:34,420 --> 00:01:39,130
the programming language being at PHP or

00:01:37,659 --> 00:01:41,109
whatever other scripting language you

00:01:39,130 --> 00:01:43,109
may be using that may not always be the

00:01:41,109 --> 00:01:45,100
source of the actual bottleneck and

00:01:43,109 --> 00:01:47,799
really have to look at the entire

00:01:45,100 --> 00:01:49,479
process of what is going on in terms of

00:01:47,799 --> 00:01:51,429
the request handling and where the

00:01:49,479 --> 00:01:53,799
potential issue is and that ultimately

00:01:51,429 --> 00:01:55,599
is going to tell you wearing to expand

00:01:53,799 --> 00:01:58,959
your efforts in order to try to make

00:01:55,599 --> 00:02:00,670
things better so the way I look at it

00:01:58,959 --> 00:02:03,459
you really have to from a bottle next

00:02:00,670 --> 00:02:05,799
perspective examine the entire task and

00:02:03,459 --> 00:02:07,329
this has begins of the browser and one

00:02:05,799 --> 00:02:09,819
of the common mistakes that a lot of

00:02:07,329 --> 00:02:11,830
developers make is they look at the code

00:02:09,819 --> 00:02:14,170
that they write and say ok let's start

00:02:11,830 --> 00:02:16,420
from that point but really when it comes

00:02:14,170 --> 00:02:18,730
to performance or whatnot the process

00:02:16,420 --> 00:02:20,140
begins from the user and ultimately it's

00:02:18,730 --> 00:02:20,650
the user could judges whether your

00:02:20,140 --> 00:02:22,930
application

00:02:20,650 --> 00:02:25,030
faster whether it's slow or whether it's

00:02:22,930 --> 00:02:26,170
something they want to use and the first

00:02:25,030 --> 00:02:27,640
thing that the user is going to interact

00:02:26,170 --> 00:02:29,319
with is their browser which is

00:02:27,640 --> 00:02:31,599
ultimately the tool that they're using

00:02:29,319 --> 00:02:33,790
to render your particular website so

00:02:31,599 --> 00:02:36,519
that's one of the first things you need

00:02:33,790 --> 00:02:38,859
to take a look at and the browser has a

00:02:36,519 --> 00:02:40,329
whole series of bottlenecks that you

00:02:38,859 --> 00:02:42,459
need to contend with you have things

00:02:40,329 --> 00:02:45,040
like DNS you actually have to translate

00:02:42,459 --> 00:02:46,750
your web URL into the IP address or

00:02:45,040 --> 00:02:50,230
multiple IP addresses if you're using

00:02:46,750 --> 00:02:51,760
things like CDN or similar entities you

00:02:50,230 --> 00:02:53,709
have to look at latency like where is

00:02:51,760 --> 00:02:55,540
your content located is it's taking too

00:02:53,709 --> 00:02:57,370
long to download because your server

00:02:55,540 --> 00:02:58,780
happens to be somewhere in Asia and a

00:02:57,370 --> 00:03:00,639
user happens to be somewhere in North

00:02:58,780 --> 00:03:02,920
America there's you know speed of light

00:03:00,639 --> 00:03:04,780
is fast but it's not you know infinite

00:03:02,920 --> 00:03:07,659
so to speak you also have to look at

00:03:04,780 --> 00:03:09,280
basic things like page size what's

00:03:07,659 --> 00:03:11,470
what's the amount of JavaScript that

00:03:09,280 --> 00:03:13,180
you're loading CSS and all the other

00:03:11,470 --> 00:03:15,099
components and the browser is going to

00:03:13,180 --> 00:03:18,639
need to process in order to generate the

00:03:15,099 --> 00:03:19,989
content for the user now once the

00:03:18,639 --> 00:03:21,250
browser did it think you also have to

00:03:19,989 --> 00:03:22,720
look at the web server and the web

00:03:21,250 --> 00:03:25,030
server does a lot of things that people

00:03:22,720 --> 00:03:27,940
forget about as a cell negotiation being

00:03:25,030 --> 00:03:30,879
one of the big things which is a fairly

00:03:27,940 --> 00:03:32,650
complex process and nowadays because of

00:03:30,879 --> 00:03:34,690
security concerns or whatnot more and

00:03:32,650 --> 00:03:36,909
more websites are switching entirely to

00:03:34,690 --> 00:03:39,540
SSL so that is something you certainly

00:03:36,909 --> 00:03:42,220
need to take a look at things like

00:03:39,540 --> 00:03:43,810
caching compression typically are

00:03:42,220 --> 00:03:45,519
considered to be a good things for

00:03:43,810 --> 00:03:48,069
performance but in some cases they can

00:03:45,519 --> 00:03:49,060
actually be a source of a bottleneck and

00:03:48,069 --> 00:03:52,180
that's something that we'll talk about

00:03:49,060 --> 00:03:55,419
in detail as well and also request

00:03:52,180 --> 00:03:57,370
pre-processing one of the examples that

00:03:55,419 --> 00:03:59,949
I you know like to recall in this case

00:03:57,370 --> 00:04:01,540
is couple of years back somebody asked

00:03:59,949 --> 00:04:03,159
me a question of you know can I take a

00:04:01,540 --> 00:04:05,379
look at their application and figure out

00:04:03,159 --> 00:04:07,269
why it's slow because they couldn't

00:04:05,379 --> 00:04:09,669
figure it out and you know they used the

00:04:07,269 --> 00:04:11,260
standard profiling tools and the

00:04:09,669 --> 00:04:13,720
requests were being generated really

00:04:11,260 --> 00:04:15,099
really quickly but after spending a

00:04:13,720 --> 00:04:17,049
little bit of time of looking at what's

00:04:15,099 --> 00:04:18,579
going on the problem was actually not

00:04:17,049 --> 00:04:20,349
the application it was actually the web

00:04:18,579 --> 00:04:22,690
server because what they had they had a

00:04:20,349 --> 00:04:24,220
ton of mod rewrite rules which if used

00:04:22,690 --> 00:04:26,139
mod rewrite you probably know it's not

00:04:24,220 --> 00:04:27,940
the fastest thing in the world and had

00:04:26,139 --> 00:04:29,680
something like 10 kilobytes of mod

00:04:27,940 --> 00:04:31,960
rewrite rules do all kinds of strange

00:04:29,680 --> 00:04:33,940
euro transformations and that was

00:04:31,960 --> 00:04:35,890
actually taking five times longer

00:04:33,940 --> 00:04:38,140
took the PHP script that they had in the

00:04:35,890 --> 00:04:39,700
back end to generate the content so

00:04:38,140 --> 00:04:42,390
that's just kind of one of the examples

00:04:39,700 --> 00:04:45,100
of things that you need to contend about

00:04:42,390 --> 00:04:47,140
now when it comes to scripting languages

00:04:45,100 --> 00:04:50,470
and I guess this is a PHP conference so

00:04:47,140 --> 00:04:53,470
we'll use PHP is the name you have the

00:04:50,470 --> 00:04:56,380
typical issues like the slow code lock

00:04:53,470 --> 00:04:58,570
contention errors which I have an

00:04:56,380 --> 00:05:00,670
interesting example down line so you

00:04:58,570 --> 00:05:02,490
know the typical issues that you would

00:05:00,670 --> 00:05:05,140
find whenever you're writing your code

00:05:02,490 --> 00:05:06,790
the other bit which you could be

00:05:05,140 --> 00:05:09,010
relating to caching layer or your

00:05:06,790 --> 00:05:10,510
database is the slow queries which you

00:05:09,010 --> 00:05:13,750
know is a common thing that people look

00:05:10,510 --> 00:05:16,260
after lock contention cache misses index

00:05:13,750 --> 00:05:18,910
lacking all those things can be

00:05:16,260 --> 00:05:21,100
potential sources of bottlenecks so at

00:05:18,910 --> 00:05:23,230
the end of the line anywhere throughout

00:05:21,100 --> 00:05:26,590
the web serving stack you can have

00:05:23,230 --> 00:05:30,010
possible problems so lots and lots of

00:05:26,590 --> 00:05:31,570
reasons now one of the as i mentioned

00:05:30,010 --> 00:05:33,490
common mistakes is that people do is

00:05:31,570 --> 00:05:35,260
they use a common tool called the patchy

00:05:33,490 --> 00:05:38,020
bench how many people here use the

00:05:35,260 --> 00:05:40,000
patchy bench okay so quite a few hands

00:05:38,020 --> 00:05:42,669
they run a command similar to this they

00:05:40,000 --> 00:05:44,980
say okay send a thousand requests to a

00:05:42,669 --> 00:05:46,540
euro of my choice and then take a look

00:05:44,980 --> 00:05:49,419
at the bottom portion which basically

00:05:46,540 --> 00:05:52,120
says okay I had no failures um there was

00:05:49,419 --> 00:05:54,220
no errors so to speak I can do about two

00:05:52,120 --> 00:05:56,500
thousand requests per second which means

00:05:54,220 --> 00:05:58,650
excellent you know my application is

00:05:56,500 --> 00:06:01,330
running really really quickly

00:05:58,650 --> 00:06:03,400
unfortunately that still means that the

00:06:01,330 --> 00:06:05,080
user looking at this application may say

00:06:03,400 --> 00:06:07,870
okay you're able to send me the data

00:06:05,080 --> 00:06:10,330
really really quickly but by the time my

00:06:07,870 --> 00:06:12,520
web browser renders the data a whole of

00:06:10,330 --> 00:06:14,650
a lot time passes because as great as

00:06:12,520 --> 00:06:17,110
apache bench is the only thing that it's

00:06:14,650 --> 00:06:19,120
testing is how long does it take for PHP

00:06:17,110 --> 00:06:21,250
to output the content of the page it

00:06:19,120 --> 00:06:24,040
doesn't consider things like external

00:06:21,250 --> 00:06:25,780
resources like CSS javascript images

00:06:24,040 --> 00:06:28,720
whatever other content you may be

00:06:25,780 --> 00:06:30,730
loading as part of that request as well

00:06:28,720 --> 00:06:32,320
as how much processing time the web

00:06:30,730 --> 00:06:34,180
browser is going to need to actually

00:06:32,320 --> 00:06:36,250
convert whatever it is that you're

00:06:34,180 --> 00:06:39,880
sending into content that the user is

00:06:36,250 --> 00:06:42,789
able to see so really the first step of

00:06:39,880 --> 00:06:44,229
bottleneck analysis are profiling is

00:06:42,789 --> 00:06:45,910
really to take a look at the user

00:06:44,229 --> 00:06:46,330
experience and there are some really

00:06:45,910 --> 00:06:48,550
good

00:06:46,330 --> 00:06:52,120
tools that will help you identify some

00:06:48,550 --> 00:06:55,930
common problems that may be related to

00:06:52,120 --> 00:06:58,719
that browser component now one of my

00:06:55,930 --> 00:07:02,199
favorite tools for that is actually the

00:06:58,719 --> 00:07:05,379
chrome web developer tools and this is

00:07:02,199 --> 00:07:07,060
one of the profilers that is generates

00:07:05,379 --> 00:07:10,270
and the website that I've decided to

00:07:07,060 --> 00:07:12,039
analyze is actually a php.net so you

00:07:10,270 --> 00:07:15,129
know let's poke a little bit of fun at

00:07:12,039 --> 00:07:17,379
ourselves if you will so what PHP nappin

00:07:15,129 --> 00:07:19,419
has the first blue line there at the top

00:07:17,379 --> 00:07:21,520
is the actual content of that particular

00:07:19,419 --> 00:07:23,650
page and what you can see from this

00:07:21,520 --> 00:07:26,500
content of the page that it took roughly

00:07:23,650 --> 00:07:29,229
a fifth of a second just to establish

00:07:26,500 --> 00:07:31,509
the connection which means that before

00:07:29,229 --> 00:07:33,009
any processing was done a quarter of a

00:07:31,509 --> 00:07:35,500
second had gone by which means this

00:07:33,009 --> 00:07:39,639
whatever the server was doing was quite

00:07:35,500 --> 00:07:41,529
intensive the other issue was that you

00:07:39,639 --> 00:07:43,419
know PageSpeed so after the connection

00:07:41,529 --> 00:07:45,789
was established how long did it actually

00:07:43,419 --> 00:07:47,680
take for the web server to transmit the

00:07:45,789 --> 00:07:50,500
data back which in this case was another

00:07:47,680 --> 00:07:52,449
you know fifth of a second so maybe

00:07:50,500 --> 00:07:54,190
php.net front page is particularly

00:07:52,449 --> 00:07:56,440
complex because it shows you all kind of

00:07:54,190 --> 00:07:59,289
thought stuff like upcoming conferences

00:07:56,440 --> 00:08:01,900
etc etc etc so that may not necessarily

00:07:59,289 --> 00:08:04,569
be a problem but the other interesting

00:08:01,900 --> 00:08:06,759
bit is it took 1.2 seconds for the user

00:08:04,569 --> 00:08:09,339
to actually receive the page and now

00:08:06,759 --> 00:08:11,500
this is a cheated a little bit I did the

00:08:09,339 --> 00:08:13,240
slide at another conference and if you

00:08:11,500 --> 00:08:15,250
know the Wi-Fi speed at a conference is

00:08:13,240 --> 00:08:17,979
not particularly great so it took a

00:08:15,250 --> 00:08:19,900
while to download the page but from an

00:08:17,979 --> 00:08:21,219
example perspective it's possible that

00:08:19,900 --> 00:08:23,379
you're generating the page really

00:08:21,219 --> 00:08:25,539
quickly but the size of the page makes

00:08:23,379 --> 00:08:27,310
it really long for the browser to

00:08:25,539 --> 00:08:29,529
download so as much as we all like to

00:08:27,310 --> 00:08:31,599
believe that our users have a very fast

00:08:29,529 --> 00:08:33,070
connection that's not always true and

00:08:31,599 --> 00:08:34,690
that's why it's important to look at how

00:08:33,070 --> 00:08:36,519
you can minimize the size of the page

00:08:34,690 --> 00:08:38,890
and what other things you can do to

00:08:36,519 --> 00:08:41,919
reduce the load involved in a data

00:08:38,890 --> 00:08:44,320
transmission now the other interesting

00:08:41,919 --> 00:08:46,750
bit is that there is those I guess

00:08:44,320 --> 00:08:49,300
purple lines which talk about how long

00:08:46,750 --> 00:08:51,339
it took Stu serve static pages so in

00:08:49,300 --> 00:08:53,170
this case it was one of the images that

00:08:51,339 --> 00:08:55,480
is part of the website and what's

00:08:53,170 --> 00:08:58,270
interesting here is that even for a

00:08:55,480 --> 00:08:59,510
static image it took 167 milliseconds

00:08:58,270 --> 00:09:02,150
for the web server to

00:08:59,510 --> 00:09:04,700
transmission of that data so what it

00:09:02,150 --> 00:09:07,040
means is that when it was sending a

00:09:04,700 --> 00:09:09,050
dynamic page which took about two

00:09:07,040 --> 00:09:11,510
hundred milliseconds really only about

00:09:09,050 --> 00:09:12,830
20 milliseconds was probably PHP or

00:09:11,510 --> 00:09:15,920
whatever was used to send the request

00:09:12,830 --> 00:09:18,230
the other 160 milliseconds was something

00:09:15,920 --> 00:09:20,390
that the Webster was doing so that's

00:09:18,230 --> 00:09:22,280
probably a good sign that you having a

00:09:20,390 --> 00:09:24,620
bottleneck on a web server side maybe

00:09:22,280 --> 00:09:26,530
you have too many rewrite rules maybe

00:09:24,620 --> 00:09:28,820
you're having a lot of filtering

00:09:26,530 --> 00:09:30,140
happening maybe you have not security

00:09:28,820 --> 00:09:32,030
installed and it's spending a lot of

00:09:30,140 --> 00:09:33,680
time filtering whatever input is coming

00:09:32,030 --> 00:09:35,540
through and that is a potential issue

00:09:33,680 --> 00:09:37,490
you want to take a look at because just

00:09:35,540 --> 00:09:39,770
from a benchmark of the application you

00:09:37,490 --> 00:09:41,450
may not be able to spot that but when

00:09:39,770 --> 00:09:43,700
you're doing it as a user this is a

00:09:41,450 --> 00:09:47,990
clear issue that you ideally we want to

00:09:43,700 --> 00:09:50,300
address so the other thing you want to

00:09:47,990 --> 00:09:51,800
the other victim if you will don't want

00:09:50,300 --> 00:09:54,890
to take a look at is a pretty popular

00:09:51,800 --> 00:09:56,120
website called Facebook I'm sure most of

00:09:54,890 --> 00:09:57,890
you have access that at one point or

00:09:56,120 --> 00:10:01,250
another so Facebook has a rather

00:09:57,890 --> 00:10:03,590
interesting situation so to serve the

00:10:01,250 --> 00:10:05,570
actual PHP content page they do it in

00:10:03,590 --> 00:10:07,370
about 400 milliseconds which is not

00:10:05,570 --> 00:10:10,130
particularly great but not particularly

00:10:07,370 --> 00:10:12,830
bad but what is interesting is that it

00:10:10,130 --> 00:10:16,430
takes another 400 milliseconds for that

00:10:12,830 --> 00:10:18,560
page to finish effectively loading and

00:10:16,430 --> 00:10:20,570
another 400 milliseconds for all the

00:10:18,560 --> 00:10:22,490
JavaScript and all the content on the

00:10:20,570 --> 00:10:25,100
page to actually be fully realized in

00:10:22,490 --> 00:10:27,260
the browser so even though the backend

00:10:25,100 --> 00:10:29,500
was fairly fast under half a second you

00:10:27,260 --> 00:10:31,910
were able to get the data to the user

00:10:29,500 --> 00:10:33,740
the user looking at the page did not

00:10:31,910 --> 00:10:36,980
actually see this page fully realize

00:10:33,740 --> 00:10:38,480
until almost a second later making the

00:10:36,980 --> 00:10:40,160
entire experience take well over a

00:10:38,480 --> 00:10:42,290
second and that is a potential

00:10:40,160 --> 00:10:43,970
bottleneck because that means that you

00:10:42,290 --> 00:10:45,560
need to figure out what is inside that

00:10:43,970 --> 00:10:47,570
page that is making it take so long

00:10:45,560 --> 00:10:49,400
maybe you want to simplify things maybe

00:10:47,570 --> 00:10:52,370
you want to defer the content because

00:10:49,400 --> 00:10:54,290
clearly whatever it is that is done on

00:10:52,370 --> 00:10:58,570
whichever facebook page that I happened

00:10:54,290 --> 00:11:02,420
to load is not ideal as a consequence

00:10:58,570 --> 00:11:04,910
the other interesting problem of hero

00:11:02,420 --> 00:11:06,590
here is actually the dns lookups and

00:11:04,910 --> 00:11:09,440
this is important for all of you who are

00:11:06,590 --> 00:11:11,450
using cdns or using variety of tricks to

00:11:09,440 --> 00:11:13,640
try to me

00:11:11,450 --> 00:11:15,680
javascript Lodha synchronously when you

00:11:13,640 --> 00:11:17,690
put javascript across multiple servers

00:11:15,680 --> 00:11:19,460
so that it doesn't load one script at a

00:11:17,690 --> 00:11:21,050
time and one of the things that people

00:11:19,460 --> 00:11:23,030
forget frequently is that when you make

00:11:21,050 --> 00:11:24,860
a request to a different domain the

00:11:23,030 --> 00:11:26,960
browser actually needs to resolve that

00:11:24,860 --> 00:11:28,730
particular domain before it can retrieve

00:11:26,960 --> 00:11:30,980
any data and depending on the speed of

00:11:28,730 --> 00:11:33,200
your DNS servers that actually can be a

00:11:30,980 --> 00:11:35,870
fairly long process so in this case you

00:11:33,200 --> 00:11:37,160
can see that one dns lookup to 20

00:11:35,870 --> 00:11:39,710
milliseconds which is pretty quick

00:11:37,160 --> 00:11:41,030
another one took 100 milliseconds and

00:11:39,710 --> 00:11:42,950
you have to add up all of those

00:11:41,030 --> 00:11:45,800
overheads to the entire page request

00:11:42,950 --> 00:11:47,960
speed so once you added up all those

00:11:45,800 --> 00:11:52,010
things you find that a huge part of the

00:11:47,960 --> 00:11:54,440
page oops is actually spent doing dns

00:11:52,010 --> 00:11:56,870
lookups so this is very important if

00:11:54,440 --> 00:11:58,460
you're using multiple cdns for example a

00:11:56,870 --> 00:12:01,850
lot of people could use jQuery they

00:11:58,460 --> 00:12:03,650
would load jQuery from the Google CDN

00:12:01,850 --> 00:12:05,980
and they're in there using something

00:12:03,650 --> 00:12:09,950
like data tables they would load it from

00:12:05,980 --> 00:12:11,060
you know jquery CDN or microsoft CDN

00:12:09,950 --> 00:12:13,220
because they want to have those things

00:12:11,060 --> 00:12:16,210
load in parallel but what they forget is

00:12:13,220 --> 00:12:18,650
that they're trading off one

00:12:16,210 --> 00:12:20,090
optimization for the DNS overhead so

00:12:18,650 --> 00:12:22,580
that is something you want to carefully

00:12:20,090 --> 00:12:25,060
measure and make sure that DNS does not

00:12:22,580 --> 00:12:27,980
become a bottleneck in your application

00:12:25,060 --> 00:12:30,440
the other bit is JavaScript so

00:12:27,980 --> 00:12:34,370
javascript is something that browsers do

00:12:30,440 --> 00:12:36,620
not render in parallel they download it

00:12:34,370 --> 00:12:38,720
and process it synchronously so if you

00:12:36,620 --> 00:12:40,580
have a lot of JavaScript files you can

00:12:38,720 --> 00:12:43,070
end up with a situation like I have here

00:12:40,580 --> 00:12:44,930
where over three seconds is spent

00:12:43,070 --> 00:12:46,550
literally waiting for the previous

00:12:44,930 --> 00:12:48,650
script to load loading the next one and

00:12:46,550 --> 00:12:50,180
so on and even though individual scripts

00:12:48,650 --> 00:12:52,580
are being loaded very very quickly

00:12:50,180 --> 00:12:54,050
because of the large number of them

00:12:52,580 --> 00:12:56,150
because you have a lot of small scripts

00:12:54,050 --> 00:12:58,190
on a single page you actually have a

00:12:56,150 --> 00:13:00,230
continuous delay and because those

00:12:58,190 --> 00:13:01,730
scripts usually are load inside the head

00:13:00,230 --> 00:13:03,950
element that means that the user is

00:13:01,730 --> 00:13:06,020
actually not seeing any content before

00:13:03,950 --> 00:13:08,930
all the JavaScript is loaded so that's

00:13:06,020 --> 00:13:10,880
why it's important in most cases to take

00:13:08,930 --> 00:13:13,280
all of your JavaScript files Cree a

00:13:10,880 --> 00:13:15,980
single large file compress it using a

00:13:13,280 --> 00:13:18,530
variety of JavaScript compression tools

00:13:15,980 --> 00:13:20,690
like Google's closure or y ue compressor

00:13:18,530 --> 00:13:23,210
and then load a single file because then

00:13:20,690 --> 00:13:24,300
you effectively avoid this limitation of

00:13:23,210 --> 00:13:26,100
loading only one

00:13:24,300 --> 00:13:27,720
javascript at the time and you don't

00:13:26,100 --> 00:13:29,580
have to cheat by loading it from

00:13:27,720 --> 00:13:32,400
different domains or different servers

00:13:29,580 --> 00:13:35,730
and suffer the DNS bottleneck if you

00:13:32,400 --> 00:13:37,710
talked about before the other

00:13:35,730 --> 00:13:40,110
interesting situation actually has to do

00:13:37,710 --> 00:13:42,990
with SSL and for this I decided to pick

00:13:40,110 --> 00:13:46,500
on paypal another common website that

00:13:42,990 --> 00:13:49,230
you find so whenever I go to paypal com

00:13:46,500 --> 00:13:51,900
I personally can be bothered to tight ww

00:13:49,230 --> 00:13:55,200
in fact just about any any website I go

00:13:51,900 --> 00:13:57,270
to I don't bother typing www now what

00:13:55,200 --> 00:13:59,130
paypal doubt does is when you type in

00:13:57,270 --> 00:14:03,480
paypal com what they actually is a

00:13:59,130 --> 00:14:06,120
redirect you to www.paypal.com now seems

00:14:03,480 --> 00:14:08,930
like a logical step the only issue with

00:14:06,120 --> 00:14:13,320
that seemingly logical step is that both

00:14:08,930 --> 00:14:15,690
paypal calm and ww paypal com have

00:14:13,320 --> 00:14:17,130
different ssl certificates and which

00:14:15,690 --> 00:14:19,260
means that every single time a

00:14:17,130 --> 00:14:21,840
connection is open the browser has to

00:14:19,260 --> 00:14:23,520
establish a separate ssl connection so

00:14:21,840 --> 00:14:25,740
the cost of that seemingly innocuous

00:14:23,520 --> 00:14:28,200
redirect is actually almost half a

00:14:25,740 --> 00:14:30,960
second spent purely doing the two ssl

00:14:28,200 --> 00:14:33,510
negotiations involved in the process the

00:14:30,960 --> 00:14:36,630
first one took almost 100 milliseconds

00:14:33,510 --> 00:14:39,120
and the next one took another 110 or so

00:14:36,630 --> 00:14:41,400
so lots of time spent doing SSL

00:14:39,120 --> 00:14:43,680
negotiation so a better solution would

00:14:41,400 --> 00:14:45,840
either be to use a catch-all ssl

00:14:43,680 --> 00:14:48,240
certificate which says anything dot

00:14:45,840 --> 00:14:49,730
paypal com would have the same as a cell

00:14:48,240 --> 00:14:52,680
so you don't need to renegotiate or

00:14:49,730 --> 00:14:56,100
simply not redirect the user sparing

00:14:52,680 --> 00:14:57,960
them a lot of time on initial request

00:14:56,100 --> 00:14:59,790
and the initial request is usually is

00:14:57,960 --> 00:15:02,100
the one that's most important because if

00:14:59,790 --> 00:15:04,080
it appears to the user the website is

00:15:02,100 --> 00:15:06,210
taking too long to load their most

00:15:04,080 --> 00:15:07,740
common response nowadays is to open up

00:15:06,210 --> 00:15:09,120
the next website and you lost the

00:15:07,740 --> 00:15:11,850
visitor and if you haven't some

00:15:09,120 --> 00:15:13,710
something like an e-commerce platform or

00:15:11,850 --> 00:15:15,600
a website where you know there's a lot

00:15:13,710 --> 00:15:17,400
of alternatives chances are you could be

00:15:15,600 --> 00:15:20,940
using a lot of losing a lot of users

00:15:17,400 --> 00:15:22,350
simply because of a simple SSL to SSL

00:15:20,940 --> 00:15:24,060
redirect that you're doing it just

00:15:22,350 --> 00:15:25,920
because you want to normalize the domain

00:15:24,060 --> 00:15:29,360
that the user is on so certainly

00:15:25,920 --> 00:15:33,270
something important to take a look at

00:15:29,360 --> 00:15:36,449
another important bottleneck that a lot

00:15:33,270 --> 00:15:38,910
of people forget are actually cookies

00:15:36,449 --> 00:15:41,040
no I live in North America Canada to be

00:15:38,910 --> 00:15:43,589
specific and most of the internet

00:15:41,040 --> 00:15:45,509
connections in Canada on the upstream

00:15:43,589 --> 00:15:47,489
and a downstream are not the same so you

00:15:45,509 --> 00:15:49,589
can download things really quickly but

00:15:47,489 --> 00:15:51,869
when it comes to uploading it's not

00:15:49,589 --> 00:15:54,239
quite dial-up speed but it's only about

00:15:51,869 --> 00:15:57,419
800 kilobits or one megabit which is not

00:15:54,239 --> 00:15:59,189
a whole lot and some websites like to

00:15:57,419 --> 00:16:01,649
accumulate cookies and those cookies

00:15:59,189 --> 00:16:03,660
contain a lot of data so what happens is

00:16:01,649 --> 00:16:05,339
that on every single request the web

00:16:03,660 --> 00:16:07,679
browser needs to transmit a couple of

00:16:05,339 --> 00:16:09,480
kilobytes of data now what's a couple of

00:16:07,679 --> 00:16:11,519
kilobytes it's not a whole lot but those

00:16:09,480 --> 00:16:13,619
couple of kilobytes on a slow upstream

00:16:11,519 --> 00:16:15,899
connection can actually translates to

00:16:13,619 --> 00:16:18,059
seconds or significant fractions of

00:16:15,899 --> 00:16:20,639
seconds in this case again using a

00:16:18,059 --> 00:16:23,309
conference Wi-Fi transmission of about

00:16:20,639 --> 00:16:25,529
eight cookies from a website that I'm

00:16:23,309 --> 00:16:28,410
keeping anonymous took I guess to

00:16:25,529 --> 00:16:30,660
protect the guilty took about 1.1

00:16:28,410 --> 00:16:32,879
seconds which is a pretty significant

00:16:30,660 --> 00:16:34,559
time because that's roughly half the

00:16:32,879 --> 00:16:36,689
time that it takes to render the entire

00:16:34,559 --> 00:16:37,949
page and as you can imagine while the

00:16:36,689 --> 00:16:39,869
web browser is sending the request

00:16:37,949 --> 00:16:41,189
there's not a whole lot that is

00:16:39,869 --> 00:16:43,410
happening for the user they're just

00:16:41,189 --> 00:16:45,539
saying seeing you know a blank page or a

00:16:43,410 --> 00:16:47,339
page in the process of being loaded so

00:16:45,539 --> 00:16:49,470
it's very important to be conscientious

00:16:47,339 --> 00:16:51,679
of how much data you're transmitting an

00:16:49,470 --> 00:16:56,009
each request and cookies are usually the

00:16:51,679 --> 00:16:58,379
major culprit of increasing the size of

00:16:56,009 --> 00:17:02,279
the page in terms of the data

00:16:58,379 --> 00:17:04,380
transmission now if you don't like to

00:17:02,279 --> 00:17:07,110
use chrome there is a very similar to

00:17:04,380 --> 00:17:09,839
found in Firefox at the extension

00:17:07,110 --> 00:17:11,880
Firebug which gives you pretty much the

00:17:09,839 --> 00:17:14,250
exact same information the only thing

00:17:11,880 --> 00:17:15,600
that Firebug does not do is does not

00:17:14,250 --> 00:17:19,049
actually tell you how much time was

00:17:15,600 --> 00:17:20,809
spent doing SSL negotiation which is one

00:17:19,049 --> 00:17:23,789
of the reasons I prefer to use chrome

00:17:20,809 --> 00:17:26,909
and at least up until recently I found

00:17:23,789 --> 00:17:29,760
that Firebug I can make it crash all too

00:17:26,909 --> 00:17:31,740
frequently so I haven't been able to do

00:17:29,760 --> 00:17:34,500
that in chrome as much so that's why I

00:17:31,740 --> 00:17:35,970
prefer that that particular solution but

00:17:34,500 --> 00:17:37,409
in the end the content that they show on

00:17:35,970 --> 00:17:40,830
even the way they were presented is

00:17:37,409 --> 00:17:42,600
largely the same so that's you know

00:17:40,830 --> 00:17:45,690
there's no particular reason to use one

00:17:42,600 --> 00:17:48,360
tool or the other now the challenge with

00:17:45,690 --> 00:17:49,740
these tools is that they all require you

00:17:48,360 --> 00:17:52,410
to be on the testing

00:17:49,740 --> 00:17:54,270
side right and your environment more

00:17:52,410 --> 00:17:56,910
often and not is not representative of

00:17:54,270 --> 00:17:58,410
the users environment I mean I look at

00:17:56,910 --> 00:18:00,840
the laptop so that I can kind of see

00:17:58,410 --> 00:18:03,390
here most of these laptops are fairly

00:18:00,840 --> 00:18:05,730
powerful machines the laptops that are

00:18:03,390 --> 00:18:08,040
being used by your users or their

00:18:05,730 --> 00:18:10,320
desktop computers are probably about a

00:18:08,040 --> 00:18:11,520
third as powerful an average they also

00:18:10,320 --> 00:18:13,470
probably don't have as good of a

00:18:11,520 --> 00:18:15,780
connection that you do in the office so

00:18:13,470 --> 00:18:17,670
testing it from your local environment

00:18:15,780 --> 00:18:20,970
is not really representative of your

00:18:17,670 --> 00:18:22,380
common user base so how do you get the

00:18:20,970 --> 00:18:25,320
same information that you're getting

00:18:22,380 --> 00:18:27,360
from what's a Firebug extension or the

00:18:25,320 --> 00:18:30,059
chrome developer tools without going to

00:18:27,360 --> 00:18:32,160
users and say hey can you launch this

00:18:30,059 --> 00:18:34,170
extension run some profiles and send me

00:18:32,160 --> 00:18:37,290
the data it'd be nice but doesn't really

00:18:34,170 --> 00:18:40,050
happen in practice so there's actually

00:18:37,290 --> 00:18:42,660
an interesting tool that was written by

00:18:40,050 --> 00:18:45,150
a guy named called Philip telus while he

00:18:42,660 --> 00:18:47,820
was working at Yahoo and now you can

00:18:45,150 --> 00:18:50,870
find us to on github called boomerang

00:18:47,820 --> 00:18:54,420
and what boomerang is it's basically a

00:18:50,870 --> 00:18:56,580
JavaScript application that allows that

00:18:54,420 --> 00:18:58,800
sits on the web browser and is going to

00:18:56,580 --> 00:19:00,600
track all of the same parameters or a

00:18:58,800 --> 00:19:05,070
lot of the similar parameters that are

00:19:00,600 --> 00:19:06,510
too like firebug or chrome will actually

00:19:05,070 --> 00:19:09,240
be able to tell you so you can actually

00:19:06,510 --> 00:19:11,130
get the data from your real users and

00:19:09,240 --> 00:19:12,780
determine what is their experience been

00:19:11,130 --> 00:19:14,820
like on your website without actually

00:19:12,780 --> 00:19:16,559
having to ask them to install extensions

00:19:14,820 --> 00:19:19,470
and track data and send that information

00:19:16,559 --> 00:19:21,450
to you and because it's fairly

00:19:19,470 --> 00:19:23,309
lightweight and it doesn't really impact

00:19:21,450 --> 00:19:24,840
the loading of your website the really

00:19:23,309 --> 00:19:26,640
nice thing about is you can actually use

00:19:24,840 --> 00:19:27,960
this in production this is not something

00:19:26,640 --> 00:19:29,760
that you would deploy in a test

00:19:27,960 --> 00:19:31,020
environment rather this is something you

00:19:29,760 --> 00:19:33,030
would turn on in a permanent or

00:19:31,020 --> 00:19:36,720
semi-permanent basis in your live

00:19:33,030 --> 00:19:38,490
environment now using boomerang is very

00:19:36,720 --> 00:19:40,860
simple all you do is you load a single

00:19:38,490 --> 00:19:43,800
our javascript file called boomerang GS

00:19:40,860 --> 00:19:45,840
and then you initialize a beacon which

00:19:43,800 --> 00:19:47,490
is basically a clear pixel which will

00:19:45,840 --> 00:19:50,220
create somewhere in your website and

00:19:47,490 --> 00:19:52,500
that clear pixel would be a URL to which

00:19:50,220 --> 00:19:54,630
it's going to transmit the data and it's

00:19:52,500 --> 00:19:56,520
not a PHP script it's actually a static

00:19:54,630 --> 00:19:58,500
file because the idea is that you're

00:19:56,520 --> 00:20:00,270
going to extract the data from the log

00:19:58,500 --> 00:20:02,050
entries of your web server biet and

00:20:00,270 --> 00:20:04,660
jennex apache

00:20:02,050 --> 00:20:07,000
ever it is that you're using again as to

00:20:04,660 --> 00:20:08,800
reduce the amount of overhead both on

00:20:07,000 --> 00:20:10,420
your server and the amount of time that

00:20:08,800 --> 00:20:12,310
it's going to take to load the content

00:20:10,420 --> 00:20:14,980
because you know to load a single you

00:20:12,310 --> 00:20:16,930
know 40 by pic so we know one pixel file

00:20:14,980 --> 00:20:20,350
is not really going to be very owners on

00:20:16,930 --> 00:20:22,210
any type of connection in a very basic

00:20:20,350 --> 00:20:23,710
implementation you're going to get

00:20:22,210 --> 00:20:26,050
effectively three pieces of information

00:20:23,710 --> 00:20:28,120
one of which is the version of the

00:20:26,050 --> 00:20:30,910
boomerang library that you're using the

00:20:28,120 --> 00:20:33,010
other version is the perceived a time

00:20:30,910 --> 00:20:37,060
that it took for the user to load the

00:20:33,010 --> 00:20:38,740
page so effectively your back-end server

00:20:37,060 --> 00:20:41,320
may say that a page took you know a

00:20:38,740 --> 00:20:43,840
third of a second to load or you know

00:20:41,320 --> 00:20:45,880
hundreds of a second to generate but

00:20:43,840 --> 00:20:48,310
this is a number of milliseconds that

00:20:45,880 --> 00:20:50,110
the user actually took to fully receive

00:20:48,310 --> 00:20:51,910
and to render the page so as far as your

00:20:50,110 --> 00:20:54,640
customers users whatever term you want

00:20:51,910 --> 00:20:56,890
to use perceive this to be this page

00:20:54,640 --> 00:20:59,830
took about a third of a second for them

00:20:56,890 --> 00:21:02,110
to generate and last but not least is

00:20:59,830 --> 00:21:04,210
the URL which was actually requested

00:21:02,110 --> 00:21:07,840
which took this particular amount of

00:21:04,210 --> 00:21:09,460
time now this basic operation is fairly

00:21:07,840 --> 00:21:11,950
limited because you don't really know

00:21:09,460 --> 00:21:14,230
where did the bottleneck occur as much

00:21:11,950 --> 00:21:15,220
as you could see it in the manual tests

00:21:14,230 --> 00:21:18,250
that were done using the browser

00:21:15,220 --> 00:21:19,960
extension but fortunately most modern

00:21:18,250 --> 00:21:22,360
browsers have actually implemented some

00:21:19,960 --> 00:21:24,880
coke called w3c navigation timing API

00:21:22,360 --> 00:21:27,370
and what it is it's an internal browser

00:21:24,880 --> 00:21:30,430
API that actually gives you access to

00:21:27,370 --> 00:21:32,350
the internal data in terms of what it

00:21:30,430 --> 00:21:34,090
took for the browser to load the content

00:21:32,350 --> 00:21:36,070
and giving you the same fine-grained

00:21:34,090 --> 00:21:37,810
pieces of information as you were able

00:21:36,070 --> 00:21:39,820
to access via the extensions that I

00:21:37,810 --> 00:21:42,460
showed manually and this is available in

00:21:39,820 --> 00:21:44,740
chrome 6.0 and above firefox 7 and above

00:21:42,460 --> 00:21:48,130
and even internet explorer as a version

00:21:44,740 --> 00:21:50,410
9.0 supports this information now this

00:21:48,130 --> 00:21:52,120
is not a standard plug in for boomerang

00:21:50,410 --> 00:21:54,010
so if you want to integrate it you have

00:21:52,120 --> 00:21:56,380
to do a couple of extra steps you need

00:21:54,010 --> 00:21:58,780
to clone the boomerang repository get

00:21:56,380 --> 00:22:01,750
into the directory and recompile the

00:21:58,780 --> 00:22:03,940
boomerang GS by turning on the nav

00:22:01,750 --> 00:22:06,900
timings plugin which will give you

00:22:03,940 --> 00:22:09,730
access access to those extra controls

00:22:06,900 --> 00:22:11,860
now what these controls allow you to do

00:22:09,730 --> 00:22:14,710
is basically measure the entire life

00:22:11,860 --> 00:22:15,710
cycle of the request execution so you

00:22:14,710 --> 00:22:17,750
can start from the

00:22:15,710 --> 00:22:19,909
beginning of the user experience which

00:22:17,750 --> 00:22:22,429
is literally the very point in time

00:22:19,909 --> 00:22:24,740
where the browser stopped processing the

00:22:22,429 --> 00:22:26,419
previous page and cleaning up after it

00:22:24,740 --> 00:22:28,940
so to speak and begin loading your

00:22:26,419 --> 00:22:31,010
particular page then you can see when

00:22:28,940 --> 00:22:33,649
the processing began this is the time

00:22:31,010 --> 00:22:35,539
where a request has been transmitted and

00:22:33,649 --> 00:22:37,940
now the browser is waiting for a

00:22:35,539 --> 00:22:41,480
response from the web server to begin

00:22:37,940 --> 00:22:43,279
the rendering process the next important

00:22:41,480 --> 00:22:44,929
point is when the page actually finished

00:22:43,279 --> 00:22:47,750
loading so all the content has been

00:22:44,929 --> 00:22:49,549
received and finally when all of the

00:22:47,750 --> 00:22:51,710
posts loading events have been processed

00:22:49,549 --> 00:22:53,450
so those four points are probably the

00:22:51,710 --> 00:22:55,309
four points that most people want to

00:22:53,450 --> 00:22:56,570
take a look at but you obviously have a

00:22:55,309 --> 00:22:59,029
lot more information and you can

00:22:56,570 --> 00:23:01,549
literally measure the timing of every

00:22:59,029 --> 00:23:05,510
single activity that happens during the

00:23:01,549 --> 00:23:07,490
request serving process and this is the

00:23:05,510 --> 00:23:09,200
raw data that you can see I appreciate

00:23:07,490 --> 00:23:11,090
probably folks who are sitting way in

00:23:09,200 --> 00:23:14,059
the back can see the specific parameters

00:23:11,090 --> 00:23:16,610
but opposed the slides online and it

00:23:14,059 --> 00:23:19,250
gives you in microseconds or oh sorry

00:23:16,610 --> 00:23:21,350
milliseconds the information around when

00:23:19,250 --> 00:23:25,309
each operation started and when each

00:23:21,350 --> 00:23:27,320
operation finished as well as any number

00:23:25,309 --> 00:23:29,510
of redirects that the browser needed to

00:23:27,320 --> 00:23:31,100
process in order to get to the page so

00:23:29,510 --> 00:23:33,080
if you're doing a lot of redirects

00:23:31,100 --> 00:23:34,909
because of rewrites rules or whatever

00:23:33,080 --> 00:23:36,440
you want to do this will actually be

00:23:34,909 --> 00:23:39,830
able to give you that information as

00:23:36,440 --> 00:23:41,539
well now if boomerang is something

00:23:39,830 --> 00:23:42,770
that's a little bit too complicated and

00:23:41,539 --> 00:23:44,809
you don't want to load another bit of

00:23:42,770 --> 00:23:47,779
JavaScript into your application you can

00:23:44,809 --> 00:23:50,120
actually simulate the basic user

00:23:47,779 --> 00:23:53,210
experience timing via this basically a

00:23:50,120 --> 00:23:55,309
two-line PHP JavaScript script so the

00:23:53,210 --> 00:23:58,010
first thing you do is you get the time

00:23:55,309 --> 00:24:00,380
stamps and then you set up an unload

00:23:58,010 --> 00:24:02,529
function that's going to effectively

00:24:00,380 --> 00:24:04,760
create an image tag passing it the

00:24:02,529 --> 00:24:06,559
amount of time that it took to render

00:24:04,760 --> 00:24:08,419
the page as well as their URL of the

00:24:06,559 --> 00:24:10,279
current page so once the page fully

00:24:08,419 --> 00:24:12,440
finishes loading the unload events have

00:24:10,279 --> 00:24:14,360
finished this is going to fire and make

00:24:12,440 --> 00:24:16,760
a request to your web server and then

00:24:14,360 --> 00:24:17,990
from your log files you can use a little

00:24:16,760 --> 00:24:20,029
auks script so you don't even need

00:24:17,990 --> 00:24:23,299
anything particularly sophisticated to

00:24:20,029 --> 00:24:24,919
say extract the data of all the urls it

00:24:23,299 --> 00:24:27,180
were requested that contained string

00:24:24,919 --> 00:24:29,100
page load and tell me how many of their

00:24:27,180 --> 00:24:32,100
requests had occurred and what was the

00:24:29,100 --> 00:24:34,110
average time for all those requests so

00:24:32,100 --> 00:24:35,730
you get a quick summary what was the

00:24:34,110 --> 00:24:37,770
average user experience across your

00:24:35,730 --> 00:24:42,650
entire application that was monitored

00:24:37,770 --> 00:24:44,820
throughout this particular process now

00:24:42,650 --> 00:24:46,710
assuming that you were able to kind of

00:24:44,820 --> 00:24:48,450
validate that the user experience is not

00:24:46,710 --> 00:24:50,910
really the fault of any bottlenecks in

00:24:48,450 --> 00:24:52,350
your application probably the next step

00:24:50,910 --> 00:24:56,010
you want to take a look at is the web

00:24:52,350 --> 00:24:59,040
server itself and to you know monitor

00:24:56,010 --> 00:25:00,990
the web server apache bench is one of

00:24:59,040 --> 00:25:03,990
the simpler tools simply because you'll

00:25:00,990 --> 00:25:05,490
find in just about any linux server on

00:25:03,990 --> 00:25:07,890
windows you can install it fairly easily

00:25:05,490 --> 00:25:09,870
and allows you to do basic operation say

00:25:07,890 --> 00:25:12,090
how many requests what is a concurrency

00:25:09,870 --> 00:25:15,570
you can even send cookies if you need to

00:25:12,090 --> 00:25:17,520
simulate a frente shun process and if

00:25:15,570 --> 00:25:19,710
you want to speed up the process and not

00:25:17,520 --> 00:25:21,240
have the network be the bottleneck

00:25:19,710 --> 00:25:24,450
during your operation you can switch

00:25:21,240 --> 00:25:26,790
from get requests to head requests now

00:25:24,450 --> 00:25:28,590
when you're looking at the Apache bench

00:25:26,790 --> 00:25:30,240
out but there's couple of things that a

00:25:28,590 --> 00:25:32,850
lot of people ignore which is what I

00:25:30,240 --> 00:25:34,140
want to focus on first of all you want

00:25:32,850 --> 00:25:36,870
to take a look at the number of failed

00:25:34,140 --> 00:25:38,550
requests a lot of the times you may get

00:25:36,870 --> 00:25:40,530
a very fast speed but you have a few

00:25:38,550 --> 00:25:42,150
failed requests and failed requests

00:25:40,530 --> 00:25:44,280
could indicate one of two things either

00:25:42,150 --> 00:25:47,100
some of your requests are timing out

00:25:44,280 --> 00:25:49,410
either some of the requests are crashing

00:25:47,100 --> 00:25:54,240
it does happen especially if using PHP

00:25:49,410 --> 00:25:56,370
54 and a PC until recently and you know

00:25:54,240 --> 00:25:57,630
there could be all kinds of things going

00:25:56,370 --> 00:25:58,980
wrong in various points so it's

00:25:57,630 --> 00:26:01,860
important to make sure that this number

00:25:58,980 --> 00:26:03,960
is equal to 0 the other bit of

00:26:01,860 --> 00:26:06,420
information is the connection times and

00:26:03,960 --> 00:26:08,010
a connection times gives you things how

00:26:06,420 --> 00:26:09,780
long it took to establish connection

00:26:08,010 --> 00:26:11,670
what does the processing time what was

00:26:09,780 --> 00:26:13,830
the waiting time and so on so you have

00:26:11,670 --> 00:26:16,680
the basic average which represented by

00:26:13,830 --> 00:26:18,180
mean but medium is probably one of the

00:26:16,680 --> 00:26:20,040
more important numbers you want to take

00:26:18,180 --> 00:26:23,730
a look at because if the median is a

00:26:20,040 --> 00:26:25,680
very large number that means that given

00:26:23,730 --> 00:26:27,450
sufficient time you probably will

00:26:25,680 --> 00:26:29,880
encounter a bottleneck because your

00:26:27,450 --> 00:26:31,830
requests are not within a very small

00:26:29,880 --> 00:26:35,040
range of one another there's actually in

00:26:31,830 --> 00:26:37,620
this case 173 a millisecond difference

00:26:35,040 --> 00:26:39,870
between the fastest and slowest request

00:26:37,620 --> 00:26:40,620
which is a huge amount of time if you're

00:26:39,870 --> 00:26:43,470
talking about

00:26:40,620 --> 00:26:44,700
quasi take an average you know no more

00:26:43,470 --> 00:26:46,740
than three hundred twenty seven

00:26:44,700 --> 00:26:49,170
milliseconds to process from start to

00:26:46,740 --> 00:26:52,500
finish so clearly there is something

00:26:49,170 --> 00:26:54,780
that's going wrong the other bit you

00:26:52,500 --> 00:26:56,250
want to take a look at is the percentage

00:26:54,780 --> 00:26:58,380
of requests served within a certain

00:26:56,250 --> 00:26:59,610
amount of time so if your goal is to say

00:26:58,380 --> 00:27:01,800
that I want ninety percent of my

00:26:59,610 --> 00:27:04,320
requests served and under a quarter of a

00:27:01,800 --> 00:27:05,820
second then you know in this case you're

00:27:04,320 --> 00:27:08,370
actually are hitting that particular

00:27:05,820 --> 00:27:10,110
benchmark but once you go past that you

00:27:08,370 --> 00:27:12,750
can see that there is a you know

00:27:10,110 --> 00:27:14,730
substantial slow down almost a

00:27:12,750 --> 00:27:16,800
50-percent slow down by the time you get

00:27:14,730 --> 00:27:18,300
to the hundred percent I'll and that's

00:27:16,800 --> 00:27:20,490
an important thing to watch for because

00:27:18,300 --> 00:27:21,960
if you're seeing these patterns chances

00:27:20,490 --> 00:27:23,610
are you may want to increase the length

00:27:21,960 --> 00:27:25,710
of the test either by increasing the

00:27:23,610 --> 00:27:27,540
number of requests or the concurrency of

00:27:25,710 --> 00:27:29,100
the requests because it's possible that

00:27:27,540 --> 00:27:30,690
you're not sending enough data to

00:27:29,100 --> 00:27:33,690
actually trigger a bottleneck you're

00:27:30,690 --> 00:27:35,580
just reaching just close enough to have

00:27:33,690 --> 00:27:37,260
the first sign of it but not actually

00:27:35,580 --> 00:27:39,000
have it significantly impact your

00:27:37,260 --> 00:27:42,030
application so that's one of the

00:27:39,000 --> 00:27:43,340
important things to watch for so how do

00:27:42,030 --> 00:27:46,470
you actually go about identifying

00:27:43,340 --> 00:27:48,510
bottlenecks inside the web server so one

00:27:46,470 --> 00:27:51,300
of the very first tests you want to do

00:27:48,510 --> 00:27:52,559
is take a static file doesn't matter

00:27:51,300 --> 00:27:55,800
what it is could be javascript-based

00:27:52,559 --> 00:27:59,670
HTML CSS it could even be an image and

00:27:55,800 --> 00:28:02,370
you want to see you know is the data

00:27:59,670 --> 00:28:04,800
that's being received the same size of

00:28:02,370 --> 00:28:07,140
the data being that the data is on disk

00:28:04,800 --> 00:28:08,760
because of the file is plain text which

00:28:07,140 --> 00:28:10,500
would be true for JavaScript or any of

00:28:08,760 --> 00:28:11,970
those things chances are you missing

00:28:10,500 --> 00:28:14,040
compression and if you're missing

00:28:11,970 --> 00:28:15,929
compression you're probably not making

00:28:14,040 --> 00:28:17,610
the most out of your network bandwidth

00:28:15,929 --> 00:28:19,110
and you're also not making it easier for

00:28:17,610 --> 00:28:21,960
users who don't necessarily have the

00:28:19,110 --> 00:28:23,760
fastest internet connection and with a

00:28:21,960 --> 00:28:25,950
lot of people using common JavaScript

00:28:23,760 --> 00:28:27,540
libraries which even in compact form can

00:28:25,950 --> 00:28:29,550
range anywhere between 30 and 40

00:28:27,540 --> 00:28:31,050
kilobytes being able to compress them

00:28:29,550 --> 00:28:33,570
could actually reduce a significant

00:28:31,050 --> 00:28:36,540
portion of the data involved in the web

00:28:33,570 --> 00:28:38,340
serving process the other interesting

00:28:36,540 --> 00:28:40,920
test you want to do is actually a test

00:28:38,340 --> 00:28:44,610
of your server are you able to max out

00:28:40,920 --> 00:28:46,410
the network traffic with static requests

00:28:44,610 --> 00:28:48,870
and any modern web server that you're

00:28:46,410 --> 00:28:51,780
using be it Apache engine X or whatnot

00:28:48,870 --> 00:28:52,780
should be able to do it like to give you

00:28:51,780 --> 00:28:55,760
a

00:28:52,780 --> 00:28:59,210
basic measurements think if you will if

00:28:55,760 --> 00:29:01,250
you take a three year old Mac Mini not a

00:28:59,210 --> 00:29:04,130
particularly fast computer which has a

00:29:01,250 --> 00:29:05,990
gigabit port it's able using apache to

00:29:04,130 --> 00:29:08,660
saturate that gigabit port which means

00:29:05,990 --> 00:29:09,980
that your limit is a network which is

00:29:08,660 --> 00:29:13,309
actually a good thing because that means

00:29:09,980 --> 00:29:15,530
that the web processing logic is not

00:29:13,309 --> 00:29:17,540
extremely heavy but if your web server

00:29:15,530 --> 00:29:19,580
is not able to saturate the network link

00:29:17,540 --> 00:29:20,990
chances are you probably have some

00:29:19,580 --> 00:29:22,700
overhead on the web server side

00:29:20,990 --> 00:29:24,290
especially when serving static data

00:29:22,700 --> 00:29:26,480
which is why it's a good benchmark to

00:29:24,290 --> 00:29:28,790
run because you don't have the potential

00:29:26,480 --> 00:29:31,780
issues or uncertainties that can come

00:29:28,790 --> 00:29:33,890
out from serving dynamic data like PHP

00:29:31,780 --> 00:29:35,960
the other thing I want to take a look at

00:29:33,890 --> 00:29:38,419
is is there a fluctuation in connection

00:29:35,960 --> 00:29:40,040
times because if there is a fluctuation

00:29:38,419 --> 00:29:41,870
in connection times it could mean one of

00:29:40,040 --> 00:29:43,130
two things it could mean that you're

00:29:41,870 --> 00:29:45,679
having a lot of pre-processing

00:29:43,130 --> 00:29:48,020
directives like URL rewriting or various

00:29:45,679 --> 00:29:50,630
validation or it could also mean that

00:29:48,020 --> 00:29:52,850
you're having some disk i/o issues or

00:29:50,630 --> 00:29:54,169
potentially not enough memory allowing

00:29:52,850 --> 00:29:56,360
the operating system to cache the

00:29:54,169 --> 00:29:58,970
frequently access portions of disk in

00:29:56,360 --> 00:30:00,890
RAM which substantially optimizes the

00:29:58,970 --> 00:30:02,440
speed of processing so that's one of the

00:30:00,890 --> 00:30:05,330
things you also want to take a look at

00:30:02,440 --> 00:30:07,190
and last but not least as you're

00:30:05,330 --> 00:30:09,590
performing the test you also want to be

00:30:07,190 --> 00:30:12,020
monitoring the disk i/o itself to see if

00:30:09,590 --> 00:30:13,940
it's fairly flat or if it's actually

00:30:12,020 --> 00:30:15,860
fluctuating quite a bit and in reality

00:30:13,940 --> 00:30:17,990
because you're requesting static files

00:30:15,860 --> 00:30:20,929
the disk i/o should be completely flat

00:30:17,990 --> 00:30:22,580
because after a first let's say 20 or 30

00:30:20,929 --> 00:30:24,679
requests whichever file you're

00:30:22,580 --> 00:30:26,390
requesting any decent Colonel should be

00:30:24,679 --> 00:30:28,160
already cashing it to memory which means

00:30:26,390 --> 00:30:29,570
it's not really getting the file from

00:30:28,160 --> 00:30:31,130
disk but it actually is getting it out

00:30:29,570 --> 00:30:33,350
of ram without you having to do anything

00:30:31,130 --> 00:30:34,760
if it doesn't happen that means that

00:30:33,350 --> 00:30:37,960
there is some sort of an issue in the

00:30:34,760 --> 00:30:40,070
process and not as a possible bottleneck

00:30:37,960 --> 00:30:42,650
the other bit you want to take a look at

00:30:40,070 --> 00:30:44,179
is the network I oh so what you do is

00:30:42,650 --> 00:30:46,250
would that Pocoyo is you would take a

00:30:44,179 --> 00:30:48,919
page and this time you're actually

00:30:46,250 --> 00:30:50,240
taking HTML page that's roughly the size

00:30:48,919 --> 00:30:52,520
of the normal page that you're

00:30:50,240 --> 00:30:54,410
transmitting to the user and you're

00:30:52,520 --> 00:30:56,270
going to see once again if you're able

00:30:54,410 --> 00:30:57,799
to saturate the network with this

00:30:56,270 --> 00:31:00,080
information and if the answer is yes

00:30:57,799 --> 00:31:02,690
then you say ok can i enable compression

00:31:00,080 --> 00:31:03,710
at this point because now I want to see

00:31:02,690 --> 00:31:06,320
if I can max

00:31:03,710 --> 00:31:09,230
out the throughput of my particular

00:31:06,320 --> 00:31:11,120
machine the other thing you want to

00:31:09,230 --> 00:31:14,480
check which actually ties into the

00:31:11,120 --> 00:31:17,659
kernel is are you able to do the maximum

00:31:14,480 --> 00:31:19,640
number of requests that is a coolant to

00:31:17,659 --> 00:31:22,159
your let's say targeted amount of

00:31:19,640 --> 00:31:23,419
traffic and a meaning how many users are

00:31:22,159 --> 00:31:25,820
going to be accessing your application

00:31:23,419 --> 00:31:27,080
and if the answer is no and one of the

00:31:25,820 --> 00:31:30,080
things you want to take a look at is the

00:31:27,080 --> 00:31:32,480
actual kernel buffer sizes and this is a

00:31:30,080 --> 00:31:35,179
little bit of a tricky topic to explain

00:31:32,480 --> 00:31:37,640
but one of the common misconceptions is

00:31:35,179 --> 00:31:39,919
that when your PHP is transmitting the

00:31:37,640 --> 00:31:42,230
data to the web server it's actually

00:31:39,919 --> 00:31:45,140
sending all the data at once and it's

00:31:42,230 --> 00:31:46,909
done but in reality it's actually being

00:31:45,140 --> 00:31:48,799
sending the data and buffers so what

00:31:46,909 --> 00:31:50,870
happens is PHP takes four kilobytes of

00:31:48,799 --> 00:31:53,120
data gives it to the web server the web

00:31:50,870 --> 00:31:54,860
services okay hold on i'm going to pass

00:31:53,120 --> 00:31:56,870
those four kilobytes to the colonel and

00:31:54,860 --> 00:31:58,610
that colonel says okay web server hold

00:31:56,870 --> 00:32:00,020
on i'm going to send it to the user once

00:31:58,610 --> 00:32:01,669
the user says i've received the data

00:32:00,020 --> 00:32:03,320
colonel is going to come back to the web

00:32:01,669 --> 00:32:05,539
server so i'm ready for the next four

00:32:03,320 --> 00:32:07,700
kilobytes and then the web server goes

00:32:05,539 --> 00:32:09,740
back to PHP and says okay now I'm ready

00:32:07,700 --> 00:32:12,230
for next four kilobytes so the process

00:32:09,740 --> 00:32:14,659
is very owners so a better way would be

00:32:12,230 --> 00:32:17,149
to say okay what I want to do is that

00:32:14,659 --> 00:32:19,850
when I increase the size of my buffers

00:32:17,149 --> 00:32:22,159
in both PHP and the web server and the

00:32:19,850 --> 00:32:23,990
colonel so they can fit a typical page

00:32:22,159 --> 00:32:25,940
in a single buffer so what would happen

00:32:23,990 --> 00:32:28,039
is that the Webster Road past data to

00:32:25,940 --> 00:32:30,049
sorry PHP would pass the data to the web

00:32:28,039 --> 00:32:31,549
server and can say i have no more data

00:32:30,049 --> 00:32:33,260
to sense so you can do whatever you want

00:32:31,549 --> 00:32:34,789
with the data that i gave you the web

00:32:33,260 --> 00:32:36,950
server can do the exact same with the

00:32:34,789 --> 00:32:38,659
colonel and actually move on to serving

00:32:36,950 --> 00:32:41,059
the next request meaning that you have

00:32:38,659 --> 00:32:43,340
less active whether its processes or

00:32:41,059 --> 00:32:44,870
socket connections going at any time on

00:32:43,340 --> 00:32:46,250
the application layer and you're

00:32:44,870 --> 00:32:48,919
uploading as much of the work as

00:32:46,250 --> 00:32:53,090
possible directly to the colonel making

00:32:48,919 --> 00:32:55,070
your applications job a lot simpler so

00:32:53,090 --> 00:32:57,049
the other tests that you want to do is

00:32:55,070 --> 00:32:59,600
actually the scripting language overhead

00:32:57,049 --> 00:33:01,760
because there is some so the first thing

00:32:59,600 --> 00:33:03,799
when it is you take the same page from

00:33:01,760 --> 00:33:05,600
previous example and instead of a dot

00:33:03,799 --> 00:33:08,029
HTML extension to give a dot PHP

00:33:05,600 --> 00:33:09,350
extension and you're doing that

00:33:08,029 --> 00:33:11,299
particular test because you actually

00:33:09,350 --> 00:33:13,220
want to make sure that PHP is not really

00:33:11,299 --> 00:33:16,429
doing any work oh it is doing a stake in

00:33:13,220 --> 00:33:17,299
HTML file passing it through the PHP

00:33:16,429 --> 00:33:20,119
preprocessor

00:33:17,299 --> 00:33:22,100
sending it back to the web server and in

00:33:20,119 --> 00:33:24,529
this case what you're looking for is

00:33:22,100 --> 00:33:26,480
that there shouldn't be more than two

00:33:24,529 --> 00:33:29,149
times speed difference between sending a

00:33:26,480 --> 00:33:31,070
static file and a PHP file and if the

00:33:29,149 --> 00:33:32,749
answer is that there is more than two

00:33:31,070 --> 00:33:35,960
times speed difference probably you're

00:33:32,749 --> 00:33:37,759
not using an opcode cash because PHP has

00:33:35,960 --> 00:33:39,649
to read the file from this every single

00:33:37,759 --> 00:33:41,509
time if it doesn't have to read the file

00:33:39,649 --> 00:33:43,759
from disk every single time there should

00:33:41,509 --> 00:33:45,710
be no more than a two times slow down

00:33:43,759 --> 00:33:48,289
between a static page and the same thing

00:33:45,710 --> 00:33:52,700
as a PHP script so that's kind of an

00:33:48,289 --> 00:33:55,580
important test for PHP now the last bit

00:33:52,700 --> 00:33:57,379
is the ssl overhead now unfortunately

00:33:55,580 --> 00:33:59,179
when it comes to as a cell there is not

00:33:57,379 --> 00:34:02,269
a whole lot you can do you just have to

00:33:59,179 --> 00:34:03,559
I guess endure at the so what you want

00:34:02,269 --> 00:34:06,889
to do with us a cell is you want to take

00:34:03,559 --> 00:34:08,809
a look at is the difference between SSL

00:34:06,889 --> 00:34:10,429
one on ssl connection greater than 100

00:34:08,809 --> 00:34:13,760
milliseconds and if the answer is yes

00:34:10,429 --> 00:34:16,309
you probably want to turn settings such

00:34:13,760 --> 00:34:18,909
as ssl cash you may want to take a look

00:34:16,309 --> 00:34:21,829
at tcp/ip congestion controls in in the

00:34:18,909 --> 00:34:24,409
in the kernel or one of the better

00:34:21,829 --> 00:34:26,629
solutions would actually be to position

00:34:24,409 --> 00:34:28,879
the SSL negotiation at various points

00:34:26,629 --> 00:34:31,460
close to your users so this is where

00:34:28,879 --> 00:34:33,109
things like Amazon AWS or whatnot is

00:34:31,460 --> 00:34:34,819
very helpful because it allows you to

00:34:33,109 --> 00:34:37,069
distribute the server architecture close

00:34:34,819 --> 00:34:38,659
to the user so the latency involved in

00:34:37,069 --> 00:34:41,210
the back-and-forth communication between

00:34:38,659 --> 00:34:42,710
the web server and the client is reduced

00:34:41,210 --> 00:34:44,540
because it is actually quite a bit of

00:34:42,710 --> 00:34:46,520
back and forth that happens during the

00:34:44,540 --> 00:34:48,260
SSL negotiation and that is one of the

00:34:46,520 --> 00:34:50,450
reasons as a cell is such a big

00:34:48,260 --> 00:34:51,950
bottleneck when it is enabled and people

00:34:50,450 --> 00:34:54,079
try to cheat and turn it off in some

00:34:51,950 --> 00:34:56,470
cases and whatnot but that leads to

00:34:54,079 --> 00:34:59,569
security consequences if you will and

00:34:56,470 --> 00:35:01,430
the last bit is compression overhead so

00:34:59,569 --> 00:35:04,099
if doing compression takes more than 10

00:35:01,430 --> 00:35:05,270
20 milliseconds you probably are doing

00:35:04,099 --> 00:35:06,799
it wrong or maybe you said the

00:35:05,270 --> 00:35:12,140
compression to the absolute maximum

00:35:06,799 --> 00:35:14,380
level and that's typically not ideal so

00:35:12,140 --> 00:35:17,750
at this point we finally approached PHP

00:35:14,380 --> 00:35:20,000
halfway through the presentation so when

00:35:17,750 --> 00:35:22,160
it comes to profiling PHP I'm sure a lot

00:35:20,000 --> 00:35:24,500
of you heard about XD bug and XD bug is

00:35:22,160 --> 00:35:26,869
a great tool it's a excellent debugger

00:35:24,500 --> 00:35:29,329
and the author of XD bug is actually at

00:35:26,869 --> 00:35:31,100
this conference Derek so if you use the

00:35:29,329 --> 00:35:33,830
tool find them I'm sure

00:35:31,100 --> 00:35:36,770
derecho appreciate a whiskey or beer

00:35:33,830 --> 00:35:39,140
whatever der alcoholic drink of choice

00:35:36,770 --> 00:35:41,140
you want to offer him but XD bug as a

00:35:39,140 --> 00:35:43,430
profiler unfortunately is not

00:35:41,140 --> 00:35:45,140
particularly good and the reason it's

00:35:43,430 --> 00:35:47,000
not particularly good is because xdebug

00:35:45,140 --> 00:35:48,500
profiler is based around the concept of

00:35:47,000 --> 00:35:50,810
you going to profile a single request

00:35:48,500 --> 00:35:52,400
well profiling a single request doesn't

00:35:50,810 --> 00:35:53,870
really do a whole lot for you because

00:35:52,400 --> 00:35:56,240
there are so many things that can happen

00:35:53,870 --> 00:35:58,250
while you're profiling that request that

00:35:56,240 --> 00:35:59,720
you're not really taking into account

00:35:58,250 --> 00:36:03,110
all the things that could be happening

00:35:59,720 --> 00:36:04,970
at that very time what XH prov does is

00:36:03,110 --> 00:36:06,830
actually says I'm going to profile

00:36:04,970 --> 00:36:08,390
multitude of requests and i'm light

00:36:06,830 --> 00:36:11,390
enough that you can actually turn it on

00:36:08,390 --> 00:36:13,430
in production and and profile a portion

00:36:11,390 --> 00:36:16,550
of the production data so effectively do

00:36:13,430 --> 00:36:19,040
sample sampling profiles and aggregate

00:36:16,550 --> 00:36:21,410
their mutual data so no one good or bad

00:36:19,040 --> 00:36:23,990
run could potentially mislead the

00:36:21,410 --> 00:36:26,660
results of your profiling of your

00:36:23,990 --> 00:36:28,670
application and you can grab XH prof as

00:36:26,660 --> 00:36:30,920
an extension pekel and there is a really

00:36:28,670 --> 00:36:32,960
good web interface to it that was

00:36:30,920 --> 00:36:37,610
written by a guy called Paul Ryan heimer

00:36:32,960 --> 00:36:41,420
that you can find on github now turning

00:36:37,610 --> 00:36:42,950
on XH proof is actually a very easy i

00:36:41,420 --> 00:36:44,540
prefer to cheat a little bit because I

00:36:42,950 --> 00:36:47,780
don't want to modify my code to

00:36:44,540 --> 00:36:50,270
integrate x h prov so used to not very

00:36:47,780 --> 00:36:52,610
commonly known php.ini directives called

00:36:50,270 --> 00:36:54,590
out of repent file and Otto append file

00:36:52,610 --> 00:36:57,140
which effectively allows you to inject a

00:36:54,590 --> 00:37:01,340
in require statement at the beginning at

00:36:57,140 --> 00:37:02,570
the end of the PHP code so the prepend

00:37:01,340 --> 00:37:05,870
file which goes in the beginning

00:37:02,570 --> 00:37:07,280
basically contains the XH prov GUI

00:37:05,870 --> 00:37:09,860
library that's going to log the data

00:37:07,280 --> 00:37:12,440
into a MySQL database the configuration

00:37:09,860 --> 00:37:15,140
script where the MySQL settings are

00:37:12,440 --> 00:37:17,120
stored and finally a function call that

00:37:15,140 --> 00:37:19,850
basically says turn on my profiler and

00:37:17,120 --> 00:37:22,820
start capturing the number of seconds

00:37:19,850 --> 00:37:25,040
that spent in each function call and how

00:37:22,820 --> 00:37:27,170
much memory it was utilized during that

00:37:25,040 --> 00:37:29,960
particular process and at the end of the

00:37:27,170 --> 00:37:32,000
script which is loaded by the footer.php

00:37:29,960 --> 00:37:34,310
which is shown at the bottom you

00:37:32,000 --> 00:37:35,660
basically disable the profiler because

00:37:34,310 --> 00:37:38,300
you don't want to profile the profiler

00:37:35,660 --> 00:37:40,790
kind of so defeating operation and then

00:37:38,300 --> 00:37:42,650
aggregate the runs and execute the

00:37:40,790 --> 00:37:44,529
function call necessary to log the data

00:37:42,650 --> 00:37:46,990
into a MySQL database

00:37:44,529 --> 00:37:49,579
recently they've actually created a

00:37:46,990 --> 00:37:51,619
MongoDB backend which is a little bit

00:37:49,579 --> 00:37:53,839
faster and allows you to aggregate a

00:37:51,619 --> 00:37:55,789
little bit more data but you can use the

00:37:53,839 --> 00:37:57,799
MySQL one fairly effectively just a

00:37:55,789 --> 00:38:01,670
single table where it stores all the

00:37:57,799 --> 00:38:03,079
information now the output from the stew

00:38:01,670 --> 00:38:05,089
is actually available through a web

00:38:03,079 --> 00:38:07,010
interface and I've broken it down into a

00:38:05,089 --> 00:38:10,039
couple of screenshot just so that at

00:38:07,010 --> 00:38:11,450
least some of it is readable so one of

00:38:10,039 --> 00:38:13,640
the first thing you get is that for

00:38:11,450 --> 00:38:15,859
every single unique URL you get the

00:38:13,640 --> 00:38:17,420
total number of historical runs and the

00:38:15,859 --> 00:38:19,460
information that is shown below is

00:38:17,420 --> 00:38:21,380
actually the aggregate of statistics

00:38:19,460 --> 00:38:24,190
across all of these runs so you're never

00:38:21,380 --> 00:38:26,690
analyzing a single request but rather a

00:38:24,190 --> 00:38:28,670
cumulation of requests over a period of

00:38:26,690 --> 00:38:31,220
time which gives you a lot more accurate

00:38:28,670 --> 00:38:33,020
data now for these requests you also

00:38:31,220 --> 00:38:34,640
find out what is the memory usage what

00:38:33,020 --> 00:38:36,829
was the minimum what was the maximum all

00:38:34,640 --> 00:38:39,440
those kind of details you find out the

00:38:36,829 --> 00:38:42,380
execution time again minimums averages

00:38:39,440 --> 00:38:44,359
and maximums on a 95 percentile basis so

00:38:42,380 --> 00:38:47,089
you throw away the exceptions to the

00:38:44,359 --> 00:38:49,910
rule so to speak and you can also get

00:38:47,089 --> 00:38:51,859
this CPU time meaning how much of the

00:38:49,910 --> 00:38:54,339
actual processor time was consumed as

00:38:51,859 --> 00:38:56,420
opposed to this time spent in user time

00:38:54,339 --> 00:38:58,069
now if you don't want to look at the raw

00:38:56,420 --> 00:39:01,220
numbers which I admit can be a little

00:38:58,069 --> 00:39:04,099
boring it'll also draw you pre charts so

00:39:01,220 --> 00:39:06,319
right here and I've profiled the profile

00:39:04,099 --> 00:39:08,990
interface you can clearly see that MySQL

00:39:06,319 --> 00:39:10,670
the big blue section here is the

00:39:08,990 --> 00:39:12,619
bottleneck taking two and a half seconds

00:39:10,670 --> 00:39:14,029
to actually process so right away you

00:39:12,619 --> 00:39:15,859
know what is the first thing you want to

00:39:14,029 --> 00:39:19,220
optimize probably the query that's

00:39:15,859 --> 00:39:21,799
running this thing you also have the per

00:39:19,220 --> 00:39:23,420
function statistics so if you really

00:39:21,799 --> 00:39:24,890
want to delve into the details and kind

00:39:23,420 --> 00:39:27,319
of do the same thing that you'll do in X

00:39:24,890 --> 00:39:29,299
debug with cake as grind and analyze how

00:39:27,319 --> 00:39:32,210
long each function call took you have

00:39:29,299 --> 00:39:33,890
that information available and one of my

00:39:32,210 --> 00:39:36,260
favorite things is you actually get a

00:39:33,890 --> 00:39:39,740
timeline trend telling you what was a

00:39:36,260 --> 00:39:41,809
pattern of the CPU the user usage and

00:39:39,740 --> 00:39:43,819
the memory utilization and whenever you

00:39:41,809 --> 00:39:46,099
have a spike you can probably find out

00:39:43,819 --> 00:39:48,140
that somebody did you know quote unquote

00:39:46,099 --> 00:39:50,869
optimization and try to improve the code

00:39:48,140 --> 00:39:53,210
and you know it clearly did not work as

00:39:50,869 --> 00:39:54,740
intended so it's a great tool for you

00:39:53,210 --> 00:39:56,480
know measuring the impact of what

00:39:54,740 --> 00:39:57,080
developers are doing whether it's a good

00:39:56,480 --> 00:39:59,030
impact

00:39:57,080 --> 00:40:03,380
or not so a good impact depending on a

00:39:59,030 --> 00:40:06,290
situation he also can it will draw you a

00:40:03,380 --> 00:40:08,120
tree such as this which kind of in a

00:40:06,290 --> 00:40:10,160
visual way will tell you the path that

00:40:08,120 --> 00:40:12,260
the code took to actually lead to the

00:40:10,160 --> 00:40:14,990
most expensive part of the operation so

00:40:12,260 --> 00:40:17,000
red is clearly the worst piece and the

00:40:14,990 --> 00:40:19,400
yellow are the steps leading up to it so

00:40:17,000 --> 00:40:20,630
you can kind of see what is the path of

00:40:19,400 --> 00:40:23,780
the application that it took to the

00:40:20,630 --> 00:40:26,630
slowest component now the problem with

00:40:23,780 --> 00:40:29,150
profiling PHP is profiling is a

00:40:26,630 --> 00:40:32,120
bottleneck itself because as great as XH

00:40:29,150 --> 00:40:33,980
prof is to slow down your production

00:40:32,120 --> 00:40:36,770
code by at least ten to fifteen percent

00:40:33,980 --> 00:40:38,630
which is you know quite a bit if you

00:40:36,770 --> 00:40:40,370
take that into account so one of the

00:40:38,630 --> 00:40:42,470
things you want to do is you ideally

00:40:40,370 --> 00:40:44,840
want to look at things like statistical

00:40:42,470 --> 00:40:46,910
sampling so you only let's say profile

00:40:44,840 --> 00:40:48,590
five or ten percent of your requests

00:40:46,910 --> 00:40:50,270
which will give you enough data to make

00:40:48,590 --> 00:40:52,940
decisions on but will not slow down

00:40:50,270 --> 00:40:54,710
every single user the other trick you

00:40:52,940 --> 00:40:56,810
can do is you can try to pre identify

00:40:54,710 --> 00:40:58,700
targets so that you're not profiling the

00:40:56,810 --> 00:41:00,620
application as a whole but rather you

00:40:58,700 --> 00:41:02,720
have so to speak where you suspect the

00:41:00,620 --> 00:41:05,990
low-hanging fruits are and you focus the

00:41:02,720 --> 00:41:07,850
profiling efforts in those areas and one

00:41:05,990 --> 00:41:09,500
of the better techniques but it takes

00:41:07,850 --> 00:41:11,930
quite a bit of effort to set up is

00:41:09,500 --> 00:41:14,180
replay log profiling so what you do is

00:41:11,930 --> 00:41:16,160
you expand your log files to actually

00:41:14,180 --> 00:41:18,260
track every part of the request

00:41:16,160 --> 00:41:20,120
including the pose data so that you can

00:41:18,260 --> 00:41:22,190
then replay that data on a separate

00:41:20,120 --> 00:41:24,410
server outside of production and

00:41:22,190 --> 00:41:26,750
simulate exactly what users were doing

00:41:24,410 --> 00:41:28,220
on the server but that's a little bit

00:41:26,750 --> 00:41:31,850
more of a tricky technique the first two

00:41:28,220 --> 00:41:34,430
are a lot easier to execute so what is

00:41:31,850 --> 00:41:36,980
the simplest one of them is pre

00:41:34,430 --> 00:41:38,930
identifying profiling targets so in

00:41:36,980 --> 00:41:41,060
Apache this is very easy to do you

00:41:38,930 --> 00:41:43,570
modify your log format which is your

00:41:41,060 --> 00:41:45,830
standard Apache log file with the

00:41:43,570 --> 00:41:48,740
interesting acronym it worked out by

00:41:45,830 --> 00:41:50,630
accident deal which is going to give you

00:41:48,740 --> 00:41:53,420
the data how much took time to process

00:41:50,630 --> 00:41:55,250
the information what was the amount of

00:41:53,420 --> 00:41:57,830
data that was received and how many

00:41:55,250 --> 00:41:59,540
bytes were transmitted so it allows you

00:41:57,830 --> 00:42:02,320
to capture a couple of data points that

00:41:59,540 --> 00:42:04,310
hopefully will allow you to identify the

00:42:02,320 --> 00:42:06,350
suspicious or things that are not let

00:42:04,310 --> 00:42:09,230
say ideal and if you happen to be using

00:42:06,350 --> 00:42:10,900
engine X you can get the exact same data

00:42:09,230 --> 00:42:13,900
through slightly

00:42:10,900 --> 00:42:15,640
parameters using the log format where

00:42:13,900 --> 00:42:18,069
you have bites sent request length and

00:42:15,640 --> 00:42:22,270
request time and using this information

00:42:18,069 --> 00:42:23,710
you can then find out areas which you

00:42:22,270 --> 00:42:26,170
know could be a good target for more

00:42:23,710 --> 00:42:27,640
detailed profiling because you know that

00:42:26,170 --> 00:42:29,380
they're taking a little bit longer than

00:42:27,640 --> 00:42:32,319
they should in terms of transmitting the

00:42:29,380 --> 00:42:34,210
data or you know the amount of time that

00:42:32,319 --> 00:42:36,130
it takes to receive the incoming data

00:42:34,210 --> 00:42:40,690
because maybe there is excessive cookies

00:42:36,130 --> 00:42:44,260
or whatnot now the other piece that I

00:42:40,690 --> 00:42:46,210
want to talk about is PHP errors and PHP

00:42:44,260 --> 00:42:48,490
errors is one of those things that even

00:42:46,210 --> 00:42:50,289
the best profiler will not be able to

00:42:48,490 --> 00:42:52,270
really tell you the impact of because

00:42:50,289 --> 00:42:54,250
they kind of hide in between things and

00:42:52,270 --> 00:42:55,510
there is a common misconception that

00:42:54,250 --> 00:42:57,880
there is a such a thing as a harmless

00:42:55,510 --> 00:43:00,130
error who cares about that East Rick

00:42:57,880 --> 00:43:01,599
Tory notice or he deprecated you know

00:43:00,130 --> 00:43:03,490
I'm going to use this version for

00:43:01,599 --> 00:43:04,809
another five years I don't care that

00:43:03,490 --> 00:43:07,299
it's going to get deprecated in version

00:43:04,809 --> 00:43:10,059
5.8 of PHP which is yet to be announced

00:43:07,299 --> 00:43:11,950
for a couple of years but one of the

00:43:10,059 --> 00:43:15,460
things that I kind of did a little micro

00:43:11,950 --> 00:43:17,230
benchmark here is that even the basic

00:43:15,460 --> 00:43:19,240
code which doesn't do anything when you

00:43:17,230 --> 00:43:21,520
have a code that generates a notice

00:43:19,240 --> 00:43:23,589
error which is my first example above

00:43:21,520 --> 00:43:26,470
where I have an undefined variable a it

00:43:23,589 --> 00:43:28,410
is about five times slower than the same

00:43:26,470 --> 00:43:31,900
code that is not generating the error

00:43:28,410 --> 00:43:33,970
now admittedly this example you know I

00:43:31,900 --> 00:43:35,619
did a hundred thousand runs so not very

00:43:33,970 --> 00:43:37,450
practical right I mean you're not going

00:43:35,619 --> 00:43:40,029
to execute the same code presumably in

00:43:37,450 --> 00:43:41,619
your application 100,000 times but let's

00:43:40,029 --> 00:43:43,450
take a look at another different example

00:43:41,619 --> 00:43:45,069
let's say you're actually are logging

00:43:43,450 --> 00:43:47,859
your errors which is a common situation

00:43:45,069 --> 00:43:49,779
for most production applications well in

00:43:47,859 --> 00:43:51,760
this case I actually had to lower my

00:43:49,779 --> 00:43:55,119
benchmark to about a thousand runs and

00:43:51,760 --> 00:43:57,430
when an error occurs it takes almost 16

00:43:55,119 --> 00:44:00,510
of a second with errors on the other

00:43:57,430 --> 00:44:03,789
hand the same code without errors takes

00:44:00,510 --> 00:44:08,230
0.0002 of a second to generate so there

00:44:03,789 --> 00:44:10,930
is a you know a thousand time difference

00:44:08,230 --> 00:44:12,250
between the two operations so this is

00:44:10,930 --> 00:44:14,619
why it's important that when you

00:44:12,250 --> 00:44:17,020
carefully look at errors and actually

00:44:14,619 --> 00:44:19,000
spend the time to fix them now one of

00:44:17,020 --> 00:44:20,470
the easy ways to address errors and kind

00:44:19,000 --> 00:44:22,450
of make sure they're not your bottleneck

00:44:20,470 --> 00:44:24,010
because a profiler error is not a

00:44:22,450 --> 00:44:25,420
function call so whatever

00:44:24,010 --> 00:44:26,830
the overhead that is caused by the error

00:44:25,420 --> 00:44:29,320
is going to be reflected in the function

00:44:26,830 --> 00:44:31,540
is actually to make all of your errors

00:44:29,320 --> 00:44:33,130
be fatal errors so in regardless of

00:44:31,540 --> 00:44:34,390
whether it's a east Richter I notice

00:44:33,130 --> 00:44:36,880
you're going to make the application

00:44:34,390 --> 00:44:38,890
aboard and that's one of the quickest

00:44:36,880 --> 00:44:40,420
and easiest way to get developers to fix

00:44:38,890 --> 00:44:41,980
all their problems all right no matter

00:44:40,420 --> 00:44:44,410
what the error is it's always going to

00:44:41,980 --> 00:44:46,390
break the code right in about two weeks

00:44:44,410 --> 00:44:50,560
just about any code base becomes error

00:44:46,390 --> 00:44:53,140
at least notice an error free now

00:44:50,560 --> 00:44:54,610
cashing bottlenecks now caching is not

00:44:53,140 --> 00:44:56,470
something we often think of a bottleneck

00:44:54,610 --> 00:44:58,360
because caching system is what you

00:44:56,470 --> 00:45:01,140
implement to resolve bottlenecks by

00:44:58,360 --> 00:45:03,700
making your database faster right but

00:45:01,140 --> 00:45:05,140
caching can in fact be a bottleneck so

00:45:03,700 --> 00:45:06,820
one of the things that you want to take

00:45:05,140 --> 00:45:09,310
a look at and I'm using memcache as an

00:45:06,820 --> 00:45:11,590
example because memcache is kind of

00:45:09,310 --> 00:45:14,170
rapidly becoming a de facto standard as

00:45:11,590 --> 00:45:17,830
a caching solution that people use and

00:45:14,170 --> 00:45:19,090
this is a data from memcache stats so

00:45:17,830 --> 00:45:21,370
the first thing you want to take a look

00:45:19,090 --> 00:45:23,320
at is the uptime which is the amount of

00:45:21,370 --> 00:45:25,690
seconds the memcache server was running

00:45:23,320 --> 00:45:28,450
and during that time see how many bytes

00:45:25,690 --> 00:45:30,040
were read or written and if that number

00:45:28,450 --> 00:45:31,600
of bytes happens to be roughly

00:45:30,040 --> 00:45:34,060
equivalent to the size of your network

00:45:31,600 --> 00:45:35,920
pipe guess what you could be maxing out

00:45:34,060 --> 00:45:37,960
your network connection talking back and

00:45:35,920 --> 00:45:39,430
forth with your cache server which means

00:45:37,960 --> 00:45:41,410
you're not really getting the maximum

00:45:39,430 --> 00:45:42,850
performance out of your caching solution

00:45:41,410 --> 00:45:44,590
because of the limitation of your

00:45:42,850 --> 00:45:46,750
network connection so that's one of the

00:45:44,590 --> 00:45:48,490
things to keep an eye out the other

00:45:46,750 --> 00:45:51,940
thing you want to take a look at is how

00:45:48,490 --> 00:45:53,860
much time is actually spent in CPU time

00:45:51,940 --> 00:45:56,740
again over the time of the application

00:45:53,860 --> 00:45:58,630
so divide the our usage system by the

00:45:56,740 --> 00:46:02,620
total uptime and if it happens to be

00:45:58,630 --> 00:46:03,940
more than 0.01 you must be doing

00:46:02,620 --> 00:46:05,710
something wrong because that really

00:46:03,940 --> 00:46:08,200
shouldn't happen your main key memcached

00:46:05,710 --> 00:46:11,500
do some operations that really should

00:46:08,200 --> 00:46:12,790
not be responsible for it the other bit

00:46:11,500 --> 00:46:14,770
you want to take a look at is how much

00:46:12,790 --> 00:46:17,080
time memcache actually spends in user

00:46:14,770 --> 00:46:18,790
CPU time meaning how much work you're

00:46:17,080 --> 00:46:21,070
actually delegating to the memcache

00:46:18,790 --> 00:46:23,260
server that requires internal operation

00:46:21,070 --> 00:46:25,180
and if this happens to be a significant

00:46:23,260 --> 00:46:27,040
number you could be having issues a lock

00:46:25,180 --> 00:46:28,720
contention what are you having to sit on

00:46:27,040 --> 00:46:31,600
a lock while in other processes running

00:46:28,720 --> 00:46:33,550
data to the same segment or you could be

00:46:31,600 --> 00:46:35,610
suffering from a network overhead where

00:46:33,550 --> 00:46:37,929
you're kind of maxing out the total

00:46:35,610 --> 00:46:39,890
connectivity of the process

00:46:37,929 --> 00:46:41,689
the other thing you want to take a look

00:46:39,890 --> 00:46:43,909
at is a number of total connections if

00:46:41,689 --> 00:46:46,069
that number is very large chances are

00:46:43,909 --> 00:46:47,509
you're establishing every new connection

00:46:46,069 --> 00:46:49,579
every time you're talking to the mem

00:46:47,509 --> 00:46:52,119
cache server and establishing a network

00:46:49,579 --> 00:46:54,079
connection is not exactly a free process

00:46:52,119 --> 00:46:56,630
the other thing you want to take a look

00:46:54,079 --> 00:46:58,189
at is the number of mrs. versus hits

00:46:56,630 --> 00:47:00,289
because if you're having a very

00:46:58,189 --> 00:47:02,269
significant number of misses in your

00:47:00,289 --> 00:47:04,819
application which is more than let's say

00:47:02,269 --> 00:47:06,469
ten percent of the time that means that

00:47:04,819 --> 00:47:08,419
you're really not benefiting a whole lot

00:47:06,469 --> 00:47:09,890
out of the cash because most of the time

00:47:08,419 --> 00:47:11,630
you're not getting the data that you're

00:47:09,890 --> 00:47:14,269
looking for or you know way too

00:47:11,630 --> 00:47:16,039
frequently so this is something that you

00:47:14,269 --> 00:47:17,539
want to take a look at and a last bit

00:47:16,039 --> 00:47:19,429
you want to take a look at evictions

00:47:17,539 --> 00:47:21,199
versus a number of times you're writing

00:47:19,429 --> 00:47:23,509
data to the cash because if you have a

00:47:21,199 --> 00:47:25,369
very large number of evictions usually

00:47:23,509 --> 00:47:27,439
that means that you don't have enough

00:47:25,369 --> 00:47:28,849
memory allocated to your mem cache and

00:47:27,439 --> 00:47:31,279
it's actually spending a lot of time

00:47:28,849 --> 00:47:33,259
throwing thing old data out of the

00:47:31,279 --> 00:47:35,029
memcache instance and that is a fairly

00:47:33,259 --> 00:47:37,039
expensive process because when eviction

00:47:35,029 --> 00:47:39,259
occurred internal hash tables which are

00:47:37,039 --> 00:47:42,199
used in by memcache to store the data

00:47:39,259 --> 00:47:44,329
are actually being reshuffled and it's a

00:47:42,199 --> 00:47:45,559
fairly expensive operation which is one

00:47:44,329 --> 00:47:47,659
of the reasons you also want to avoid

00:47:45,559 --> 00:47:49,399
calling delete on memcache keys but

00:47:47,659 --> 00:47:51,589
rather letting the memcache server

00:47:49,399 --> 00:47:53,119
expire them automatically as some

00:47:51,589 --> 00:47:57,559
offload process that's not going to

00:47:53,119 --> 00:47:59,059
affect your application so a database is

00:47:57,559 --> 00:48:02,539
kind of the last bit because I know I'm

00:47:59,059 --> 00:48:05,449
running out of time here so there's

00:48:02,539 --> 00:48:07,339
databases is probably requires a whole

00:48:05,449 --> 00:48:09,199
tutorial to really cover properly so I'm

00:48:07,339 --> 00:48:11,149
just going to focus on a very quick

00:48:09,199 --> 00:48:12,679
thing so the first thing you want to do

00:48:11,149 --> 00:48:14,389
is you want to make sure that you're

00:48:12,679 --> 00:48:16,069
logging the slow queries and that's

00:48:14,389 --> 00:48:19,669
option is available in just about any

00:48:16,069 --> 00:48:21,380
database that you use so you want to log

00:48:19,669 --> 00:48:24,259
in you want to set a parameter to how

00:48:21,380 --> 00:48:26,569
long what what is a long query and for

00:48:24,259 --> 00:48:28,699
whatever reason mysql has a default of

00:48:26,569 --> 00:48:29,959
10 seconds for a slow query which i

00:48:28,699 --> 00:48:32,689
don't know but for me seems a little

00:48:29,959 --> 00:48:35,119
high right so i recommend setting this

00:48:32,689 --> 00:48:36,679
value to a second and the other bit that

00:48:35,119 --> 00:48:38,749
may be worthwhile to explore is

00:48:36,679 --> 00:48:40,549
determine where indexes are not being

00:48:38,749 --> 00:48:42,439
used because if indexes are not being

00:48:40,549 --> 00:48:45,649
used chances are you're not going to

00:48:42,439 --> 00:48:47,929
have a very fast query now when it comes

00:48:45,649 --> 00:48:49,939
to tuning the database this is from from

00:48:47,929 --> 00:48:51,020
mysql and i have to truncate feel about

00:48:49,939 --> 00:48:53,480
300 data point

00:48:51,020 --> 00:48:55,160
poze girl recently celebrated that they

00:48:53,480 --> 00:48:57,740
were able to reduce the number of

00:48:55,160 --> 00:48:59,390
configuration settings to 200 very

00:48:57,740 --> 00:49:01,340
impressive but it's still 200 settings

00:48:59,390 --> 00:49:03,980
so at this point you really have no

00:49:01,340 --> 00:49:06,320
choice but to grab a book you know read

00:49:03,980 --> 00:49:08,510
some blogs and when it comes to data

00:49:06,320 --> 00:49:13,100
based optimization luck is very

00:49:08,510 --> 00:49:15,080
important right so the last bit is the

00:49:13,100 --> 00:49:18,560
operating system so you have a useful

00:49:15,080 --> 00:49:20,510
tool called vmstat not very readable

00:49:18,560 --> 00:49:22,520
right it gives you useful information

00:49:20,510 --> 00:49:24,650
around what your system is doing memory

00:49:22,520 --> 00:49:26,030
disk I all that kind of stuff but it's

00:49:24,650 --> 00:49:28,310
pretty hard to figure out what it's

00:49:26,030 --> 00:49:32,210
actually going on so there is a better

00:49:28,310 --> 00:49:33,590
tool called stat grab and the tool that

00:49:32,210 --> 00:49:35,630
the creator's actually called side are

00:49:33,590 --> 00:49:37,190
and it gives you a top like output where

00:49:35,630 --> 00:49:39,710
it actually formats all the same

00:49:37,190 --> 00:49:41,330
statistics at vmstat does but it gives

00:49:39,710 --> 00:49:43,970
you them in it what I like to call a

00:49:41,330 --> 00:49:45,680
human-readable form so without doing a

00:49:43,970 --> 00:49:47,570
lot of pre-processing you can actually

00:49:45,680 --> 00:49:50,300
understand what is going on in the

00:49:47,570 --> 00:49:51,650
application and you can run it as like

00:49:50,300 --> 00:49:53,480
as a daemon and it's going to keep

00:49:51,650 --> 00:49:55,390
refreshing the data just like top it'll

00:49:53,480 --> 00:49:59,420
tell you what's going on on the server

00:49:55,390 --> 00:50:01,640
so on that note I'm done a little bit

00:49:59,420 --> 00:50:03,410
over time I'm going to pose the slides

00:50:01,640 --> 00:50:04,850
on the blog as well as a joined in link

00:50:03,410 --> 00:50:06,980
at the bottom and I would very much

00:50:04,850 --> 00:50:09,980
appreciate your feedback and if there's

00:50:06,980 --> 00:50:13,420
any questions come find me um during the

00:50:09,980 --> 00:50:13,420
conference thank

00:50:16,110 --> 00:50:18,170
you

00:50:27,500 --> 00:50:29,560

YouTube URL: https://www.youtube.com/watch?v=f8zACyZAE9s


