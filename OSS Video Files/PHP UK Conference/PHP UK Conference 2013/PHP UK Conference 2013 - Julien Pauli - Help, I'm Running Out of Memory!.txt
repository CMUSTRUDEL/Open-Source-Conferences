Title: PHP UK Conference 2013 - Julien Pauli - Help, I'm Running Out of Memory!
Publication date: 2013-04-22
Playlist: PHP UK Conference 2013
Description: 
	Every programmers have already experienced a "Fatal error: Allowed memory size of xxx bytes exhausted" error message. This talk is highly technical and will explain the attendees how memory works inside PHP with understandable words and schemas. We'll start by refreshing minds about what memory is, and how it works on the system and then focus on PHP case by introducing its main memory component known as "Zend Memory Manager". You'll discover how PHP uses memory and above all : how you can figure it out into your everydays scripts and how you can be more efficient about it.
Captions: 
	00:00:14,220 --> 00:00:22,480
so hello everybody i canna

00:00:18,370 --> 00:00:25,240
myself first so I'm Julian Pauline I've

00:00:22,480 --> 00:00:29,440
been programming HP for many years now

00:00:25,240 --> 00:00:33,610
i'm reviewing a PHP internals code so

00:00:29,440 --> 00:00:35,920
since about three four years I'm 55

00:00:33,610 --> 00:00:39,940
Rudy's manager to get away with David

00:00:35,920 --> 00:00:42,270
perhaps you met him maybe somewhere i'm

00:00:39,940 --> 00:00:45,880
working in Paris oh I'm French I

00:00:42,270 --> 00:00:51,220
apologize for my sometimes poor English

00:00:45,880 --> 00:00:55,480
I like writing technical articles about

00:00:51,220 --> 00:00:59,080
PHP about PHP internals and about open

00:00:55,480 --> 00:01:03,510
source software so i'm working at blah

00:00:59,080 --> 00:01:06,450
blah car in Paris it's mostly website

00:01:03,510 --> 00:01:10,750
talking about car sharing you know

00:01:06,450 --> 00:01:15,040
through euros so we have many users we

00:01:10,750 --> 00:01:19,750
have iphone apps android application

00:01:15,040 --> 00:01:26,560
mobile etc and we run PHP PHP 5.3

00:01:19,750 --> 00:01:30,310
actually okay so i'm trying through this

00:01:26,560 --> 00:01:34,540
talk to explain you how memory works in

00:01:30,310 --> 00:01:36,850
a unix system so i expect from you then

00:01:34,540 --> 00:01:39,880
you have a little bit c programming

00:01:36,850 --> 00:01:42,550
experience and somehow sometimes a

00:01:39,880 --> 00:01:46,420
matching code hardware programming we

00:01:42,550 --> 00:01:49,210
won't see any line of code and I guess

00:01:46,420 --> 00:01:52,300
you are all PHP programmers all right

00:01:49,210 --> 00:01:55,630
and you have already experienced out of

00:01:52,300 --> 00:02:00,760
memory on your PHP programs mainly in

00:01:55,630 --> 00:02:03,910
CLI scripts and we try to understand why

00:02:00,760 --> 00:02:08,890
and how memory works in an operating

00:02:03,910 --> 00:02:12,610
system and in PHP okay so what is memory

00:02:08,890 --> 00:02:17,170
we're going to talk about by stack heap

00:02:12,610 --> 00:02:19,900
in a process okay not too deep how to

00:02:17,170 --> 00:02:22,900
measure memory consumption of any

00:02:19,900 --> 00:02:26,890
process then impeach what tools we get

00:02:22,900 --> 00:02:30,550
for that and we're going to try to

00:02:26,890 --> 00:02:33,130
understand how PHP manages memory

00:02:30,550 --> 00:02:35,650
in your script okay how it does to

00:02:33,130 --> 00:02:40,480
allocate and free memory and then how to

00:02:35,650 --> 00:02:43,600
measure PHP memory into a script so

00:02:40,480 --> 00:02:46,300
memory from a hardware point of view you

00:02:43,600 --> 00:02:48,880
all know this i think and i think you

00:02:46,300 --> 00:02:57,310
know memory from a software point of

00:02:48,880 --> 00:03:00,460
view as well it's this ok so in linux it

00:02:57,310 --> 00:03:04,510
will be mainly in linux I don't really

00:03:00,460 --> 00:03:08,920
know windows internals and other UNIX it

00:03:04,510 --> 00:03:13,900
may be different in Linux every process

00:03:08,920 --> 00:03:16,960
can can have can consume the same amount

00:03:13,900 --> 00:03:20,190
of memory were talking about virtual

00:03:16,960 --> 00:03:25,500
memory ok so I think you you help this

00:03:20,190 --> 00:03:30,400
this word before virtual memory is just

00:03:25,500 --> 00:03:34,630
an image of the physical memory that

00:03:30,400 --> 00:03:37,060
your process can allocate ok so when we

00:03:34,630 --> 00:03:39,340
talk about memory mainly we talk about

00:03:37,060 --> 00:03:45,070
virtual memory we cannot allocate

00:03:39,340 --> 00:03:47,890
physical memory from user process ok we

00:03:45,070 --> 00:03:52,480
have to code into the kernel to allocate

00:03:47,890 --> 00:03:55,480
directory physical memory so in Linux

00:03:52,480 --> 00:03:57,959
every process has the illusion of being

00:03:55,480 --> 00:04:01,870
able to allocate the whole memory and

00:03:57,959 --> 00:04:04,380
Linux will by default on the last

00:04:01,870 --> 00:04:09,850
version the colonel will always answer

00:04:04,380 --> 00:04:13,660
yes here is the memory ok so you can you

00:04:09,850 --> 00:04:15,760
can have two processes with a one-match

00:04:13,660 --> 00:04:20,320
in with say to byte of memory

00:04:15,760 --> 00:04:22,480
those two processes can allocate both 2g

00:04:20,320 --> 00:04:25,570
bytes of memory at the same time but the

00:04:22,480 --> 00:04:27,850
colonel won't give 2 gigawatts each

00:04:25,570 --> 00:04:30,880
because the machine and the physical

00:04:27,850 --> 00:04:33,730
hardware only guy on you get 1 times 2

00:04:30,880 --> 00:04:39,669
gigawatts so it's going to swap and it's

00:04:33,730 --> 00:04:43,120
gonna play with internal tables ok so in

00:04:39,669 --> 00:04:44,180
a process like PHP you can allocate

00:04:43,120 --> 00:04:46,610
memory

00:04:44,180 --> 00:04:49,729
you have to manners you can allocate

00:04:46,610 --> 00:04:53,509
memory on something called the stack and

00:04:49,729 --> 00:04:58,009
something called the heap I hope you you

00:04:53,509 --> 00:05:01,460
know you know those those terms so while

00:04:58,009 --> 00:05:05,169
running a process can allocate memory

00:05:01,460 --> 00:05:09,620
and then it can eat more and more memory

00:05:05,169 --> 00:05:13,090
talking about stuck in heap I recall you

00:05:09,620 --> 00:05:18,650
that the starch it's just about a

00:05:13,090 --> 00:05:21,110
function argument pushing so when you

00:05:18,650 --> 00:05:26,180
call function that call function that

00:05:21,110 --> 00:05:28,610
call function etc you you gonna you're

00:05:26,180 --> 00:05:32,199
going to eat more and more memory from

00:05:28,610 --> 00:05:35,570
the stack ok so the starch can exhaust

00:05:32,199 --> 00:05:39,099
memory as far as you call too many

00:05:35,570 --> 00:05:44,840
requisite functions in each other ok

00:05:39,099 --> 00:05:47,780
that's not a very common in inner

00:05:44,840 --> 00:05:50,180
process well it's easy to do just a

00:05:47,780 --> 00:05:53,570
function that calls itself and you're

00:05:50,180 --> 00:05:56,599
gonna exhaust the stack size but the

00:05:53,570 --> 00:06:00,229
most important is the heap memory the

00:05:56,599 --> 00:06:02,960
heat memory its memory that the

00:06:00,229 --> 00:06:06,409
programmer can ask for at any time in

00:06:02,960 --> 00:06:10,300
the process slide ok and PHP is a

00:06:06,409 --> 00:06:14,120
process so PHP can ask for more memory

00:06:10,300 --> 00:06:16,820
from the heap ok using mainly dynamic

00:06:14,120 --> 00:06:21,800
allocation function like a malaka a map

00:06:16,820 --> 00:06:23,990
under linux and the programmer the sea

00:06:21,800 --> 00:06:27,320
programmer has to free this memory by

00:06:23,990 --> 00:06:32,979
hand if it does not then you you have a

00:06:27,320 --> 00:06:38,389
memory leak so how can we monitor memory

00:06:32,979 --> 00:06:42,650
from the stock and from the heap from

00:06:38,389 --> 00:06:46,300
Linux point of view Linux is very very

00:06:42,650 --> 00:06:49,190
clever and give us tools for that

00:06:46,300 --> 00:06:52,610
perhaps you know the prop file system

00:06:49,190 --> 00:06:56,300
under linux okay under the proc file

00:06:52,610 --> 00:07:00,050
system you have a v8 well it's a virtual

00:06:56,300 --> 00:07:04,099
file system and under and the proc you

00:07:00,050 --> 00:07:10,669
have any PID any process will create an

00:07:04,099 --> 00:07:15,380
entry in in this proc file system so if

00:07:10,669 --> 00:07:19,159
you have a process ID 2875 for you can

00:07:15,380 --> 00:07:22,430
ask for is for its status ok just with

00:07:19,159 --> 00:07:24,949
gap and your have information and those

00:07:22,430 --> 00:07:27,680
informations if you look on the web you

00:07:24,949 --> 00:07:31,340
will have difficulties to know what it

00:07:27,680 --> 00:07:33,650
is about you have to mainly what i do is

00:07:31,340 --> 00:07:36,349
opening the kernel source and see what

00:07:33,650 --> 00:07:40,279
happens on that and you have books that

00:07:36,349 --> 00:07:43,669
explain this so mainly you can see the

00:07:40,279 --> 00:07:46,909
virtual memory size this is the size the

00:07:43,669 --> 00:07:50,599
process actually asked for so this

00:07:46,909 --> 00:07:54,349
process is asking for a total of about

00:07:50,599 --> 00:07:58,400
twenty megabyte of virtual memory vitro

00:07:54,349 --> 00:08:01,849
not physical what is actually allocated

00:07:58,400 --> 00:08:05,990
in physical memory is what is called

00:08:01,849 --> 00:08:09,169
resident set size so if you call top or

00:08:05,990 --> 00:08:12,860
tools like that under linux you will see

00:08:09,169 --> 00:08:14,839
mainly the virtual memory size so you

00:08:12,860 --> 00:08:17,659
will have the illusion that your process

00:08:14,839 --> 00:08:21,199
is actually eating 20 megabytes in your

00:08:17,659 --> 00:08:26,029
physical memory it's not the case ok it

00:08:21,199 --> 00:08:28,969
is it can actually ask for 20 megabytes

00:08:26,029 --> 00:08:32,829
about ok but the colonel is actually

00:08:28,969 --> 00:08:38,270
allocating about three hundred kilobytes

00:08:32,829 --> 00:08:41,329
in physical memory and all these virtual

00:08:38,270 --> 00:08:44,420
memory size is divided with you know

00:08:41,329 --> 00:08:47,720
stack and heap and other segments I want

00:08:44,420 --> 00:08:52,520
to talk about so you have the stuck here

00:08:47,720 --> 00:08:54,339
and you have mainly not really true but

00:08:52,520 --> 00:08:58,699
you can consider this is a heap memory

00:08:54,339 --> 00:09:01,939
ok so if you some both you should you

00:08:58,699 --> 00:09:05,000
should have the virtual memory size you

00:09:01,939 --> 00:09:07,939
have other segments I won't talk about

00:09:05,000 --> 00:09:11,449
because it's a little bit complicated ok

00:09:07,939 --> 00:09:15,199
so that's the first the first way to

00:09:11,449 --> 00:09:18,499
monitor memory and linux you can use for

00:09:15,199 --> 00:09:22,129
example the watch command on this and

00:09:18,499 --> 00:09:26,689
then play with your process and you can

00:09:22,129 --> 00:09:30,949
see the memory which is moving so those

00:09:26,689 --> 00:09:34,519
numbers are real ok the colonel gets you

00:09:30,949 --> 00:09:36,799
those numbers so you can trust them at

00:09:34,519 --> 00:09:39,799
least when you don't have Colonel bugs

00:09:36,799 --> 00:09:43,789
some some kernel have bugs and they

00:09:39,799 --> 00:09:45,949
don't really they display numbers that

00:09:43,789 --> 00:09:50,599
are not the real numbers but on the

00:09:45,949 --> 00:09:52,659
latest version it's ok in PHP so PHP is

00:09:50,599 --> 00:09:55,699
a process like any other we just saw

00:09:52,659 --> 00:09:58,279
take care of functions like memory gates

00:09:55,699 --> 00:10:01,309
usage you should all know because memory

00:09:58,279 --> 00:10:03,409
gets usage will give you something you

00:10:01,309 --> 00:10:06,439
don't really know if its heat memories

00:10:03,409 --> 00:10:10,720
that memory if it's virtual memory of

00:10:06,439 --> 00:10:13,729
physical memory okay it's not very very

00:10:10,720 --> 00:10:15,799
good to to trust the numbers at least

00:10:13,729 --> 00:10:17,779
when you don't know what they represent

00:10:15,799 --> 00:10:24,079
that's well what we were going to

00:10:17,779 --> 00:10:27,739
explain next ok so the memory is mainly

00:10:24,079 --> 00:10:31,759
divided in segments and you can ask for

00:10:27,739 --> 00:10:35,239
the memory map with the P map command

00:10:31,759 --> 00:10:37,939
and under linux pass the X argument it's

00:10:35,239 --> 00:10:40,789
better because you don't you want

00:10:37,939 --> 00:10:44,239
sighs and on this process I don't know

00:10:40,789 --> 00:10:48,529
what it is so very small one because

00:10:44,239 --> 00:10:50,720
it's just found with c library this

00:10:48,529 --> 00:10:53,349
process you can see all the memory

00:10:50,720 --> 00:10:56,929
mappings okay and what is called

00:10:53,349 --> 00:11:00,339
anonymous memory mappings mainly could

00:10:56,929 --> 00:11:04,359
represent the heap so the heap is

00:11:00,339 --> 00:11:07,489
divided in several anonymous mappings

00:11:04,359 --> 00:11:10,459
take care of some of them because they

00:11:07,489 --> 00:11:14,689
are not really the heap and the stack is

00:11:10,459 --> 00:11:18,409
a over there so this is just a mapping

00:11:14,689 --> 00:11:21,829
you can do this on PHP process but you

00:11:18,409 --> 00:11:24,259
will have a very very much more library

00:11:21,829 --> 00:11:28,399
linked okay depends on how you compile

00:11:24,259 --> 00:11:33,349
it so you can have even more details

00:11:28,399 --> 00:11:36,859
with the S maps entry which will tell

00:11:33,349 --> 00:11:39,229
you more information if the memory is

00:11:36,859 --> 00:11:42,799
shared because that's a very very very

00:11:39,229 --> 00:11:46,819
tricky thing the colonel is very clever

00:11:42,799 --> 00:11:50,239
trust it and when you have two processes

00:11:46,819 --> 00:11:52,699
using the same libraries you will have

00:11:50,239 --> 00:11:56,269
the illusion that the memory is used

00:11:52,699 --> 00:11:58,609
twice and it's not the case because the

00:11:56,269 --> 00:12:01,909
colonel is very clever clever enough to

00:11:58,609 --> 00:12:04,909
map twice the memory but on the same

00:12:01,909 --> 00:12:06,949
physical memory segment okay when it's

00:12:04,909 --> 00:12:09,609
read only memory mainly for code

00:12:06,949 --> 00:12:13,819
segments so it's very clever about that

00:12:09,609 --> 00:12:18,139
so I let you see this if you want and

00:12:13,819 --> 00:12:20,929
experiment on your own and you have

00:12:18,139 --> 00:12:25,279
tools as well to monitor memory of a

00:12:20,929 --> 00:12:28,819
program for brine okay which is very

00:12:25,279 --> 00:12:31,879
very nice true and for Brian will show

00:12:28,819 --> 00:12:36,009
you how much memory you are using in

00:12:31,879 --> 00:12:39,019
your process at any stage of at any line

00:12:36,009 --> 00:12:41,779
seek of the C code in the process okay

00:12:39,019 --> 00:12:44,899
so you can do this for peach pits very

00:12:41,779 --> 00:12:48,049
interesting to see for example how the

00:12:44,899 --> 00:12:48,620
engine starts how it starts allocating

00:12:48,049 --> 00:12:53,690
memory

00:12:48,620 --> 00:12:56,690
for opcode arrays how the thing we call

00:12:53,690 --> 00:13:01,180
garbage collector allocates very very

00:12:56,690 --> 00:13:04,220
much memory I noticed this recently and

00:13:01,180 --> 00:13:08,030
all you can all you see I recall you

00:13:04,220 --> 00:13:10,790
that all you see with a Volvo crime is a

00:13:08,030 --> 00:13:13,220
viet or memory not physical memory but

00:13:10,790 --> 00:13:16,850
it's not very far but the colonel

00:13:13,220 --> 00:13:20,120
manages this for you ok let's have a

00:13:16,850 --> 00:13:24,710
break and talk about PHP now because

00:13:20,120 --> 00:13:27,500
it's a it's what is interesting here so

00:13:24,710 --> 00:13:30,980
PHP is just a process like all the

00:13:27,500 --> 00:13:35,810
others so you can use the tricks i

00:13:30,980 --> 00:13:38,870
showed you before in PHP ok you have to

00:13:35,810 --> 00:13:43,520
get my pit which keeps your own kid and

00:13:38,870 --> 00:13:46,010
then you can with PHP you can watch its

00:13:43,520 --> 00:13:49,460
own memory consumption with the tools i

00:13:46,010 --> 00:13:53,510
showed you just a few slides before ok

00:13:49,460 --> 00:13:55,970
so you can grab resident set size from

00:13:53,510 --> 00:13:58,610
yourself so you will have a very nice

00:13:55,970 --> 00:14:01,820
crew of how many physical memory is

00:13:58,610 --> 00:14:05,510
allocated by the process ok so just saw

00:14:01,820 --> 00:14:08,510
PHP and see it it will be about 4

00:14:05,510 --> 00:14:13,150
megabytes for java you just switch the

00:14:08,510 --> 00:14:15,560
MTG with belief or bites

00:14:13,150 --> 00:14:19,820
something like that it's a very a very

00:14:15,560 --> 00:14:27,050
interesting to to to to try so try it by

00:14:19,820 --> 00:14:30,670
yourself in PHP so we use a stack ok

00:14:27,050 --> 00:14:34,880
when we call functions and we use a heap

00:14:30,670 --> 00:14:38,110
to use the heap we don't call Emma log

00:14:34,880 --> 00:14:41,030
directly Emma lock is a c function that

00:14:38,110 --> 00:14:43,610
gives memory from the heat ok so you

00:14:41,030 --> 00:14:46,130
call em a large and you tell it i would

00:14:43,610 --> 00:14:49,580
like one megabyte of memory and it gives

00:14:46,130 --> 00:14:52,940
you a pointer on the buffer which is one

00:14:49,580 --> 00:14:57,530
megabyte large it's about ok we don't

00:14:52,940 --> 00:15:02,700
use directly Emma lock in PHP we use a

00:14:57,530 --> 00:15:07,480
layer that's been designed by the PHP

00:15:02,700 --> 00:15:11,230
PHP community mainly steps risky at the

00:15:07,480 --> 00:15:13,510
advance and other people called sin

00:15:11,230 --> 00:15:16,870
memory manager you should have noticed

00:15:13,510 --> 00:15:20,350
this in the PHP information perhaps and

00:15:16,870 --> 00:15:23,290
if you wonder what it is it's if it's

00:15:20,350 --> 00:15:27,600
enabled and it will be if it's enabled

00:15:23,290 --> 00:15:32,710
it's telling you that PHP is using a

00:15:27,600 --> 00:15:35,470
great layer of C code over Emma log

00:15:32,710 --> 00:15:38,110
which is sin memory manager what is it

00:15:35,470 --> 00:15:41,250
about send memory manager it's just

00:15:38,110 --> 00:15:46,740
functions over em alot and three okay

00:15:41,250 --> 00:15:52,870
that gives memory to PHP but memory of

00:15:46,740 --> 00:15:55,150
well known sighs so the layer Zen memory

00:15:52,870 --> 00:15:58,240
manager has been designed to be very

00:15:55,150 --> 00:16:01,300
very cool with the system you know and

00:15:58,240 --> 00:16:04,240
not calling em alot each time you

00:16:01,300 --> 00:16:07,810
require memory because the most shoe you

00:16:04,240 --> 00:16:10,780
call Emma log and the the most you have

00:16:07,810 --> 00:16:13,450
a problem in time because you're going

00:16:10,780 --> 00:16:16,990
to have the heat from fragmentation and

00:16:13,450 --> 00:16:19,120
things like that very hard to understand

00:16:16,990 --> 00:16:22,960
but you can find things on the web like

00:16:19,120 --> 00:16:25,720
that so send memory manager mainly

00:16:22,960 --> 00:16:29,170
allows catching of allocated blocks it

00:16:25,720 --> 00:16:31,020
means that in a lip see when you call

00:16:29,170 --> 00:16:35,710
Emma lock and then you free the buffer

00:16:31,020 --> 00:16:39,490
so it's gone ok but if later you need

00:16:35,710 --> 00:16:42,460
the same size for the same buffer you

00:16:39,490 --> 00:16:46,600
have to require another Emma liqueur in

00:16:42,460 --> 00:16:49,260
then memory manager mainly we use civil

00:16:46,600 --> 00:16:52,780
structures and we'll show you what this

00:16:49,260 --> 00:16:56,500
for PHP variables and each time you

00:16:52,780 --> 00:17:00,370
allocate memory for z4 when you free it

00:16:56,500 --> 00:17:03,190
it's not freed back to lipsy and back to

00:17:00,370 --> 00:17:06,640
the chrono okay it's cached for the

00:17:03,190 --> 00:17:08,829
future course and when we will benchmark

00:17:06,640 --> 00:17:15,190
this on the next slides I will show you

00:17:08,829 --> 00:17:18,880
that PHP is a is a most most PD

00:17:15,190 --> 00:17:21,640
and it's a better behavior when it uses

00:17:18,880 --> 00:17:27,400
10 memory manager but when it's disabled

00:17:21,640 --> 00:17:31,380
okay so here is a test script to

00:17:27,400 --> 00:17:38,110
benchmarks and memory manager okay so

00:17:31,380 --> 00:17:40,420
let's eat some memory okay and this is a

00:17:38,110 --> 00:17:43,570
function you should know ranch it

00:17:40,420 --> 00:17:47,350
creates an array from and it fills in

00:17:43,570 --> 00:17:50,670
the numbers from one to something very

00:17:47,350 --> 00:17:54,810
big so it creates a very big array okay

00:17:50,670 --> 00:17:58,600
so PHP we'd have to allocate many memory

00:17:54,810 --> 00:18:02,590
here okay so let's show the hip usage

00:17:58,600 --> 00:18:07,090
just before allocate memory the hip his

00:18:02,590 --> 00:18:10,330
age after free this memory this will

00:18:07,090 --> 00:18:12,100
stress as well because of arrays are

00:18:10,330 --> 00:18:14,800
hash tables and I will talk you about

00:18:12,100 --> 00:18:18,310
that later how it works internally and

00:18:14,800 --> 00:18:21,460
then call hip again using memory manager

00:18:18,310 --> 00:18:25,630
and not using memory manager some PHP

00:18:21,460 --> 00:18:28,450
5.4 so this is the trick to disable the

00:18:25,630 --> 00:18:31,200
memory manager on the process at one

00:18:28,450 --> 00:18:34,510
time you just pass another environment

00:18:31,200 --> 00:18:37,570
variable use send a log and then when

00:18:34,510 --> 00:18:40,660
you tell it use analog equals zero it

00:18:37,570 --> 00:18:42,850
will directly use em alot and free from

00:18:40,660 --> 00:18:45,040
the deep sea and it short-circuits you

00:18:42,850 --> 00:18:46,990
know you have no memory manager no send

00:18:45,040 --> 00:18:50,950
memory manager anymore for this process

00:18:46,990 --> 00:18:53,380
and what you can see using time so

00:18:50,950 --> 00:18:57,280
benchmarking mainly this script we just

00:18:53,380 --> 00:19:00,430
saw is that it's more efficient when you

00:18:57,280 --> 00:19:02,530
use send memory manager actually then

00:19:00,430 --> 00:19:05,140
when you don't choose it it's little

00:19:02,530 --> 00:19:09,970
okay because it's a little script I let

00:19:05,140 --> 00:19:12,160
you imagine on a very very heavy website

00:19:09,970 --> 00:19:15,280
with lots of classes and lots of

00:19:12,160 --> 00:19:18,160
requests etc it can really make a

00:19:15,280 --> 00:19:21,960
difference okay and about memory

00:19:18,160 --> 00:19:26,350
consumption it's mainly the same okay

00:19:21,960 --> 00:19:28,090
here there is a trick about memory not

00:19:26,350 --> 00:19:31,870
being freed by lipsy

00:19:28,090 --> 00:19:35,500
this is a an internal trick of lipsy but

00:19:31,870 --> 00:19:38,140
we won't talk about it so mainly you use

00:19:35,500 --> 00:19:41,770
a little bit more memory using the

00:19:38,140 --> 00:19:45,190
memory manager okay as you can see but

00:19:41,770 --> 00:19:47,350
you are more efficient from a user point

00:19:45,190 --> 00:19:50,799
of view from a kernel point of view so

00:19:47,350 --> 00:19:56,679
in the total time it's better using send

00:19:50,799 --> 00:20:02,020
memory manager let's use for grind just

00:19:56,679 --> 00:20:06,130
1 l 2 l's so using same memory manager

00:20:02,020 --> 00:20:10,390
we can see that the script we saw just

00:20:06,130 --> 00:20:14,020
before it is to recall you so creating a

00:20:10,390 --> 00:20:19,770
very very very big array using Zen

00:20:14,020 --> 00:20:25,149
memory manager it triggers about a

00:20:19,770 --> 00:20:27,580
22-point 2206 free allocation using

00:20:25,149 --> 00:20:30,340
memory manager and you have about two

00:20:27,580 --> 00:20:33,340
millions allocation not choosing the

00:20:30,340 --> 00:20:36,789
memory manager ok this is because 10

00:20:33,340 --> 00:20:39,490
memory manager when you ask for about

00:20:36,789 --> 00:20:42,850
say something like four bytes Zen memory

00:20:39,490 --> 00:20:46,260
manager will allocate much much more so

00:20:42,850 --> 00:20:50,020
that's one ml of code and it will divide

00:20:46,260 --> 00:20:52,960
the the memory into blocks I will show

00:20:50,020 --> 00:20:56,649
you later okay and then you have less

00:20:52,960 --> 00:21:00,279
Emma log and free calls and less Emma

00:20:56,649 --> 00:21:04,270
log and free calls means more efficient

00:21:00,279 --> 00:21:08,770
let's start less time internal mode and

00:21:04,270 --> 00:21:11,860
it's better for PHP so you can see you

00:21:08,770 --> 00:21:15,640
allocate more memory yes it's about

00:21:11,860 --> 00:21:19,059
about ten percent more ok but you

00:21:15,640 --> 00:21:23,200
allocate and free memory less times and

00:21:19,059 --> 00:21:29,500
it's a very very very less time that not

00:21:23,200 --> 00:21:33,039
choosing as a memory manager ok one more

00:21:29,500 --> 00:21:36,250
test bench dot PHP micro bench you can

00:21:33,039 --> 00:21:40,820
find this in the PHP source code ok it's

00:21:36,250 --> 00:21:42,500
mainly is certainty just f1 function

00:21:40,820 --> 00:21:46,309
or to function called free function

00:21:42,500 --> 00:21:49,309
calls and accessing strings like arrays

00:21:46,309 --> 00:21:53,299
just tests internal structure of the DNG

00:21:49,309 --> 00:21:55,370
and same results okay it's better using

00:21:53,299 --> 00:22:03,320
send memory manager but not not choosing

00:21:55,370 --> 00:22:06,769
it so it's more efficient okay but it

00:22:03,320 --> 00:22:10,009
has a cross it's about ten percent more

00:22:06,769 --> 00:22:12,320
memory and an about ten percent faster

00:22:10,009 --> 00:22:15,379
it really depends on use case because

00:22:12,320 --> 00:22:18,200
when you have a very very big website

00:22:15,379 --> 00:22:21,259
with lots of objects talking about

00:22:18,200 --> 00:22:24,529
frameworks nowadays it's lots lots lots

00:22:21,259 --> 00:22:28,330
of a Moroccan free prevented with memory

00:22:24,529 --> 00:22:34,730
manager so it's a it's better using it

00:22:28,330 --> 00:22:38,179
and what about PHP and PHP lamb you

00:22:34,730 --> 00:22:40,399
write a script okay if you enabled then

00:22:38,179 --> 00:22:43,870
memory manager which is the default case

00:22:40,399 --> 00:22:48,230
okay you have access to two functions

00:22:43,870 --> 00:22:52,309
you know I think memory gets age then we

00:22:48,230 --> 00:22:55,730
get pic usage okay and the memory limit

00:22:52,309 --> 00:22:58,639
parameter you all know and finally you

00:22:55,730 --> 00:23:03,710
have access to one more thing this you

00:22:58,639 --> 00:23:06,919
should know this is the message from San

00:23:03,710 --> 00:23:09,980
memory manager the main goal of San

00:23:06,919 --> 00:23:12,590
memory manager is a control how many

00:23:09,980 --> 00:23:16,279
memory is used by your script and when

00:23:12,590 --> 00:23:18,350
you reach a limit it pays out it shut

00:23:16,279 --> 00:23:21,679
downs and it tells you fat au revoir

00:23:18,350 --> 00:23:25,159
okay so if you disable that memory

00:23:21,679 --> 00:23:27,470
manager you never meet this but you will

00:23:25,159 --> 00:23:31,159
meet other programs if you are too angry

00:23:27,470 --> 00:23:33,110
about memory ok so those functions

00:23:31,159 --> 00:23:36,129
memory gets his age memory get pictures

00:23:33,110 --> 00:23:38,990
edge I guess you know what they do

00:23:36,129 --> 00:23:43,460
should you know what the real parameter

00:23:38,990 --> 00:23:47,210
means and that's what we gonna show you

00:23:43,460 --> 00:23:49,610
now because it's not very detailed in

00:23:47,210 --> 00:23:52,309
the documentation which is real and what

00:23:49,610 --> 00:23:53,159
is teach usage even if we should know

00:23:52,309 --> 00:23:57,899
what

00:23:53,159 --> 00:24:00,929
is ok so a quick word about and memory

00:23:57,899 --> 00:24:03,599
manager internals well this you can find

00:24:00,929 --> 00:24:06,409
this on the PHP wiki I want to explain

00:24:03,599 --> 00:24:11,639
this because it is far far more complex

00:24:06,409 --> 00:24:14,789
ok but i will show you how send memory

00:24:11,639 --> 00:24:17,909
manager works when you allocate memory

00:24:14,789 --> 00:24:20,489
so you create a string you create an

00:24:17,909 --> 00:24:23,450
array you create an object you just call

00:24:20,489 --> 00:24:28,169
a function or something like that you

00:24:23,450 --> 00:24:32,159
need say four or five or 10 10 bytes of

00:24:28,169 --> 00:24:35,369
memory or say 100 battle memory the the

00:24:32,159 --> 00:24:38,369
memory manager will allocate segments I

00:24:35,369 --> 00:24:43,080
told you a few minutes ago and the

00:24:38,369 --> 00:24:47,309
segments are 256 kilobytes by default

00:24:43,080 --> 00:24:51,840
size large so when you create a string

00:24:47,309 --> 00:24:57,570
of 10 10 bytes say for example at PHP

00:24:51,840 --> 00:25:01,649
with allocate 256 kilobytes of memory ok

00:24:57,570 --> 00:25:04,409
and then it will divide the segments ok

00:25:01,649 --> 00:25:07,950
it will use the blocks in the segment's

00:25:04,409 --> 00:25:09,929
to fit future needs so when you free the

00:25:07,950 --> 00:25:13,289
memory and when you allocate more memory

00:25:09,929 --> 00:25:15,960
it won't free it and it won't allocate

00:25:13,289 --> 00:25:20,340
more memory from the system this is very

00:25:15,960 --> 00:25:22,499
clever so you can see a segment as being

00:25:20,340 --> 00:25:26,099
divided in very very very very small

00:25:22,499 --> 00:25:28,349
blocks ok say for example it's not the

00:25:26,099 --> 00:25:31,649
case but say for example one byte per

00:25:28,349 --> 00:25:34,320
block so the memory manager will use

00:25:31,649 --> 00:25:39,989
more and more memory and when it reaches

00:25:34,320 --> 00:25:43,200
the segment size the next call we call

00:25:39,989 --> 00:25:46,039
for another segment that's why you have

00:25:43,200 --> 00:25:46,039
something like that

00:25:47,640 --> 00:25:54,060
okay so you're reaching the limit and

00:25:51,150 --> 00:25:56,580
then when you just reach the limit just

00:25:54,060 --> 00:26:03,120
say I want two more bites okay let's uh

00:25:56,580 --> 00:26:08,160
no k 256 kilobytes I cannot do this here

00:26:03,120 --> 00:26:12,030
is the error message you you you all

00:26:08,160 --> 00:26:16,490
know so it's divided into blocks and it

00:26:12,030 --> 00:26:19,380
gives you all the blocks and this is

00:26:16,490 --> 00:26:23,340
what memory gates usage and memory gets

00:26:19,380 --> 00:26:27,510
usage real is about memory gets usage

00:26:23,340 --> 00:26:32,240
will tell you how many bytes are busy

00:26:27,510 --> 00:26:36,690
occupied in memory okay bye PHP data and

00:26:32,240 --> 00:26:39,780
get usage real this is called the real

00:26:36,690 --> 00:26:43,320
parameter will tell you how much memory

00:26:39,780 --> 00:26:47,070
the allocator has reclaimed from Emma

00:26:43,320 --> 00:26:49,350
log and from your system okay so when

00:26:47,070 --> 00:26:52,110
you call memory gets his age it tells

00:26:49,350 --> 00:26:55,680
you something like hundred kilobytes

00:26:52,110 --> 00:26:58,950
okay let's say 100 kilobytes it's not

00:26:55,680 --> 00:27:01,290
very true because the engine and the

00:26:58,950 --> 00:27:05,250
memory manager has allocated more than

00:27:01,290 --> 00:27:10,170
that okay you have to pass true to see

00:27:05,250 --> 00:27:14,310
how many bytes it has asked from the

00:27:10,170 --> 00:27:18,810
system mainly Emma log okay so don't be

00:27:14,310 --> 00:27:20,520
tricked by a memory get his age and this

00:27:18,810 --> 00:27:23,370
is more credit because we are talking

00:27:20,520 --> 00:27:26,330
about virtual memory and not physical

00:27:23,370 --> 00:27:29,820
memory okay so it's not really the same

00:27:26,330 --> 00:27:35,130
and here is the memory limit so on this

00:27:29,820 --> 00:27:40,170
example we can see that I can eat I have

00:27:35,130 --> 00:27:42,060
a something like this is allocated okay

00:27:40,170 --> 00:27:46,020
this has been allocated but it's not

00:27:42,060 --> 00:27:50,130
used yet so i can use this memory more

00:27:46,020 --> 00:27:53,700
and PHP won't crawl for Emma lodge okay

00:27:50,130 --> 00:27:55,800
and when you reach this limit ok say you

00:27:53,700 --> 00:27:59,030
just want two more bites it will

00:27:55,800 --> 00:28:02,090
allocate one who cygnet okay

00:27:59,030 --> 00:28:06,740
so this will be blue and the red will

00:28:02,090 --> 00:28:08,540
just reach this and when you free it

00:28:06,740 --> 00:28:11,420
will free the segment it's not a later

00:28:08,540 --> 00:28:13,520
case depends on how it works and you

00:28:11,420 --> 00:28:17,750
have a memory limit that you all know in

00:28:13,520 --> 00:28:23,240
a PHP configuration file or through any

00:28:17,750 --> 00:28:26,540
set you should notice so memory limit

00:28:23,240 --> 00:28:29,330
you know it Marrakech is H return the

00:28:26,540 --> 00:28:32,660
size of all allocated segments and

00:28:29,330 --> 00:28:36,470
return the octopod size of all our katie

00:28:32,660 --> 00:28:38,570
segments ok so don't don't be tricked be

00:28:36,470 --> 00:28:41,360
careful about that and pictures age it's

00:28:38,570 --> 00:28:45,710
just a marker you know you allocate you

00:28:41,360 --> 00:28:47,510
allocate so it it remembers how many

00:28:45,710 --> 00:28:50,060
bytes have been allocated and then you

00:28:47,510 --> 00:28:52,340
free but it still remember the mark and

00:28:50,060 --> 00:28:55,340
then you have memory get tix usage it's

00:28:52,340 --> 00:29:02,050
the maximum memory that has been asked

00:28:55,340 --> 00:29:07,250
for from the system by peach ok so it's

00:29:02,050 --> 00:29:11,090
interesting to to understand all that so

00:29:07,250 --> 00:29:13,610
how to reduce PHP memory consumption in

00:29:11,090 --> 00:29:19,580
PHP LAN you allocate variables and

00:29:13,610 --> 00:29:22,250
variables are just just two types you

00:29:19,580 --> 00:29:28,070
know HP type strings integrals it's a

00:29:22,250 --> 00:29:30,710
trap and variables consume memory ok the

00:29:28,070 --> 00:29:33,340
memory is automatically freed by PHP

00:29:30,710 --> 00:29:38,150
when you don't need and when you don't

00:29:33,340 --> 00:29:42,050
use the valuable anymore ok and here

00:29:38,150 --> 00:29:45,830
comes the challenge when does HP free

00:29:42,050 --> 00:29:48,680
memory when don't you need a variable

00:29:45,830 --> 00:29:51,350
anymore you should know this because

00:29:48,680 --> 00:29:54,500
when you pass variables to functions to

00:29:51,350 --> 00:29:57,230
classes and let's a try it can be very

00:29:54,500 --> 00:30:00,890
hard to know how when peach is going to

00:29:57,230 --> 00:30:03,320
free your memory for you so this is a

00:30:00,890 --> 00:30:07,940
this is good to know so internally

00:30:03,320 --> 00:30:09,690
variables are just see fall structures

00:30:07,940 --> 00:30:14,190
ok

00:30:09,690 --> 00:30:17,759
and the Civil structure mainly gotta

00:30:14,190 --> 00:30:22,860
then value inside as you can see the n

00:30:17,759 --> 00:30:28,409
value can actually store any type of PHP

00:30:22,860 --> 00:30:32,279
okay so if you use an integer in PHP you

00:30:28,409 --> 00:30:35,309
will allocate a long value okay if you

00:30:32,279 --> 00:30:38,070
use a float you will have double if you

00:30:35,309 --> 00:30:40,799
use a string if you use an array or if

00:30:38,070 --> 00:30:47,159
use an object okay resources are

00:30:40,799 --> 00:30:51,259
something special I want about so for

00:30:47,159 --> 00:30:57,210
this is stored in a same value which is

00:30:51,259 --> 00:30:59,940
stored in ac4 this is summer things so

00:30:57,210 --> 00:31:03,539
if you remember your memory size of each

00:30:59,940 --> 00:31:06,570
type this is unique say P 64 which

00:31:03,539 --> 00:31:10,129
should we probably run on your servers

00:31:06,570 --> 00:31:13,470
along these eight bytes double as well

00:31:10,129 --> 00:31:16,350
pointer pointer is all about stars okay

00:31:13,470 --> 00:31:20,519
so all stars then you start it's a eight

00:31:16,350 --> 00:31:23,909
byte of memory and a string it's the

00:31:20,519 --> 00:31:27,600
size of the string plus 1 into the cow

00:31:23,909 --> 00:31:29,429
star and the land okay because in PHP

00:31:27,600 --> 00:31:31,860
you have something we call binary

00:31:29,429 --> 00:31:35,659
strings binary strings it means that

00:31:31,860 --> 00:31:39,000
your string can contain the backslash 0

00:31:35,659 --> 00:31:41,850
character okay so we have to know the

00:31:39,000 --> 00:31:46,259
length of the string to pass it not to

00:31:41,850 --> 00:31:48,750
get outbound of the string so what each

00:31:46,259 --> 00:31:51,809
memory is not really that c4 it's what

00:31:48,750 --> 00:31:57,929
you store inside for example if you

00:31:51,809 --> 00:32:01,889
store 124a characters in dollar a then

00:31:57,929 --> 00:32:06,360
you will consume the size of a civil ok

00:32:01,889 --> 00:32:11,700
plus the size of hundred and twenty four

00:32:06,360 --> 00:32:16,710
megabytes bites sorry for for your

00:32:11,700 --> 00:32:19,710
daughter a variable so a huge string can

00:32:16,710 --> 00:32:21,500
consume it's easy to compute for strings

00:32:19,710 --> 00:32:24,050
just counting

00:32:21,500 --> 00:32:26,900
writers at least when we don't talk

00:32:24,050 --> 00:32:29,690
about unicode first unicode it's far

00:32:26,900 --> 00:32:33,260
more complex because you can have a

00:32:29,690 --> 00:32:37,810
character that can consume up to 48

00:32:33,260 --> 00:32:43,130
bytes each and that's why PHP 6 mainly

00:32:37,810 --> 00:32:45,470
has been a has not been released because

00:32:43,130 --> 00:32:48,560
it had a very very huge memory

00:32:45,470 --> 00:32:51,800
consumption not revisit like it work oh

00:32:48,560 --> 00:32:53,990
so when you when you have a something

00:32:51,800 --> 00:32:56,210
like I can see this is from my

00:32:53,990 --> 00:32:58,280
experience some tiger I read code and I

00:32:56,210 --> 00:33:01,130
can see file get contents from a very

00:32:58,280 --> 00:33:03,140
very huge pie will allocate the memory

00:33:01,130 --> 00:33:05,330
for all the characters in the file get

00:33:03,140 --> 00:33:08,390
contents okay so be careful about that

00:33:05,330 --> 00:33:10,760
just choose F open it gets and you

00:33:08,390 --> 00:33:13,340
allocate the fine and it frees the

00:33:10,760 --> 00:33:15,710
buffer when you don't need it so just

00:33:13,340 --> 00:33:18,200
for the data you need and if I get

00:33:15,710 --> 00:33:22,400
contents it's very very huge complex

00:33:18,200 --> 00:33:26,180
array or object as well and resources

00:33:22,400 --> 00:33:28,390
it's something special I won't talk so

00:33:26,180 --> 00:33:31,850
what you want to avoid the speech pin

00:33:28,390 --> 00:33:37,520
duplicate the c4 so now i show you how

00:33:31,850 --> 00:33:40,100
PHP manages the types for you so when

00:33:37,520 --> 00:33:41,990
you say for example you have a string

00:33:40,100 --> 00:33:45,200
and then you put it in another bug

00:33:41,990 --> 00:33:49,160
variable thp-1 duplicate the memory okay

00:33:45,200 --> 00:33:52,240
it's very very cool for that it chooses

00:33:49,160 --> 00:33:55,340
something called ref count you should

00:33:52,240 --> 00:33:58,910
have heard about this before with doubt

00:33:55,340 --> 00:34:04,670
if I go back just few slides this is in

00:33:58,910 --> 00:34:08,389
the input simple up it is okay if count

00:34:04,670 --> 00:34:11,540
and his rep which means has it been

00:34:08,389 --> 00:34:14,480
assigned by reference or not don't

00:34:11,540 --> 00:34:18,770
choose references so i will show you

00:34:14,480 --> 00:34:22,010
it's very very bad so what you want is

00:34:18,770 --> 00:34:25,730
PHP for your memory as soon as possible

00:34:22,010 --> 00:34:27,919
and PHP not duplicate your memory okay

00:34:25,730 --> 00:34:31,460
so you have to understand how variables

00:34:27,919 --> 00:34:32,829
works when you create a string for

00:34:31,460 --> 00:34:35,649
example you see

00:34:32,829 --> 00:34:38,889
example foo and you allocate to a you

00:34:35,649 --> 00:34:42,629
allocate memory for foo this is a memory

00:34:38,889 --> 00:34:46,169
this is a simple okay size of the d 4 +

00:34:42,629 --> 00:34:51,099
free characters value and character but

00:34:46,169 --> 00:34:56,099
prospective ricotta and when you copy it

00:34:51,099 --> 00:35:00,849
to be okay actually PHP will not copy

00:34:56,099 --> 00:35:04,539
the memory okay it will just link the

00:35:00,849 --> 00:35:07,180
beef valuable to the same civil and the

00:35:04,539 --> 00:35:11,009
Red Cloud's represent how many symbols

00:35:07,180 --> 00:35:15,339
how many PHP variable are pointing to

00:35:11,009 --> 00:35:20,619
this memory container in memory which is

00:35:15,339 --> 00:35:23,619
called the ref count so if we use

00:35:20,619 --> 00:35:27,819
something more complex you can see that

00:35:23,619 --> 00:35:32,380
PHP is very time about your memory okay

00:35:27,819 --> 00:35:37,119
when you have p equals a it's okay when

00:35:32,380 --> 00:35:43,239
you change the value of a as you can see

00:35:37,119 --> 00:35:46,390
a locating an integer 17 here then Abby

00:35:43,239 --> 00:35:50,469
is still pointing to foo okay and the

00:35:46,390 --> 00:35:53,229
ref count is decremented by one because

00:35:50,469 --> 00:35:56,140
there is just one variable left on this

00:35:53,229 --> 00:35:59,910
structure okay and when the red count

00:35:56,140 --> 00:36:06,789
which is 0 pH P will free your memory

00:35:59,910 --> 00:36:11,109
okay this is what happens here and you

00:36:06,789 --> 00:36:16,029
can use and set to decrease the ref

00:36:11,109 --> 00:36:18,489
count and set is not free okay and set

00:36:16,029 --> 00:36:21,400
just unlinked a variable from a

00:36:18,489 --> 00:36:23,680
container and decreases a ref count by

00:36:21,400 --> 00:36:27,069
one assuming you're not choosing

00:36:23,680 --> 00:36:31,289
references if you use references all the

00:36:27,069 --> 00:36:33,849
behaviors changed okay you should know

00:36:31,289 --> 00:36:36,940
references because I guess you have

00:36:33,849 --> 00:36:39,089
already used references so you should

00:36:36,940 --> 00:36:42,869
guess what's happening

00:36:39,089 --> 00:36:47,660
in PHP so just don't you them so you can

00:36:42,869 --> 00:36:55,769
see because i often when you use

00:36:47,660 --> 00:36:58,799
references it will and it won't it won't

00:36:55,769 --> 00:37:03,869
do what you think it's going to happen

00:36:58,799 --> 00:37:06,809
and often it does the opposite so it's a

00:37:03,869 --> 00:37:09,119
it forces the engine to duplicate your

00:37:06,809 --> 00:37:11,130
variable when you pass it to a function

00:37:09,119 --> 00:37:13,289
because you got a reference and the

00:37:11,130 --> 00:37:16,559
function doesn't take the parameter by

00:37:13,289 --> 00:37:19,200
reference so if the function is going to

00:37:16,559 --> 00:37:23,819
change the variable if it's a reference

00:37:19,200 --> 00:37:27,539
PHP has to duplicate it calling your

00:37:23,819 --> 00:37:30,119
function and freeing the duplicate when

00:37:27,539 --> 00:37:35,219
you use references so it's not really

00:37:30,119 --> 00:37:38,269
very nice bad behavior so PHP is very

00:37:35,219 --> 00:37:41,940
smart about your your memory don't use

00:37:38,269 --> 00:37:43,799
references to try to help it p hey hey

00:37:41,940 --> 00:37:46,559
you're going to duplicate my variable

00:37:43,799 --> 00:37:49,700
havens River a reference so that you

00:37:46,559 --> 00:37:52,739
won't duplicate it it's often the

00:37:49,700 --> 00:37:58,200
adverse effect okay it's the opposite

00:37:52,739 --> 00:38:00,979
searcher than so be kind about that no

00:37:58,200 --> 00:38:05,910
your ref count I know it's not very very

00:38:00,979 --> 00:38:08,700
easy to keep track of how many valuables

00:38:05,910 --> 00:38:11,579
are pointing to their so so that I know

00:38:08,700 --> 00:38:14,849
this is a very big variable it's a big

00:38:11,579 --> 00:38:17,309
xml pass domdocument or big file get

00:38:14,849 --> 00:38:19,200
contents or big array okay and we've

00:38:17,309 --> 00:38:21,960
arrays it's even more complex because i

00:38:19,200 --> 00:38:23,849
have another valuables inside so you

00:38:21,960 --> 00:38:26,729
have to keep track in your mind with me

00:38:23,849 --> 00:38:30,089
that how many variables are pointing to

00:38:26,729 --> 00:38:34,559
to my memory so that i can free it as

00:38:30,089 --> 00:38:37,999
soon as possible you can see the is rep

00:38:34,559 --> 00:38:37,999
and the ref count

00:38:38,700 --> 00:38:46,690
values using XDA ugh okay XD bug you

00:38:43,240 --> 00:38:50,530
think you know XD back here XD bugs got

00:38:46,690 --> 00:38:53,109
a function which can show you the Israel

00:38:50,530 --> 00:38:55,470
and the ref town of a fireball so when

00:38:53,109 --> 00:38:58,539
you eat when you you smell something

00:38:55,470 --> 00:39:00,640
strange in your script about variables

00:38:58,539 --> 00:39:03,400
or memory not being freed and you're

00:39:00,640 --> 00:39:06,970
expecting it to be freed just use a

00:39:03,400 --> 00:39:09,670
quick XD back to see oh ok i thought i

00:39:06,970 --> 00:39:12,880
thought this variable should should have

00:39:09,670 --> 00:39:15,069
been freed but i see the red count is 22

00:39:12,880 --> 00:39:17,799
more variables some way are pointing to

00:39:15,069 --> 00:39:20,710
it if you really want to know who is

00:39:17,799 --> 00:39:23,530
pointing what variable is pointing to it

00:39:20,710 --> 00:39:25,990
you have to use for grain or GDP down

00:39:23,530 --> 00:39:30,700
level to see it or you have another

00:39:25,990 --> 00:39:32,950
tools which are very interesting PHP

00:39:30,700 --> 00:39:37,740
extension I'll show you which is called

00:39:32,950 --> 00:39:41,200
mem track okay and which can show you

00:39:37,740 --> 00:39:45,160
actually what function is allocating

00:39:41,200 --> 00:39:47,529
memory and what function freeze it's

00:39:45,160 --> 00:39:50,559
actually so and you have a very very

00:39:47,529 --> 00:39:52,450
nice tool but it's complicated spell

00:39:50,559 --> 00:39:57,250
never its syllable it's called massive

00:39:52,450 --> 00:39:59,319
with wall grind and it's a it's very

00:39:57,250 --> 00:40:02,079
nice the most beautiful true I've never

00:39:59,319 --> 00:40:06,760
seen about memory profiling because it

00:40:02,079 --> 00:40:09,760
shows you about each see instruction how

00:40:06,760 --> 00:40:12,250
your memory is going up and then down

00:40:09,760 --> 00:40:14,890
and up and it's something like that and

00:40:12,250 --> 00:40:20,200
if you use eclipse you have graphical

00:40:14,890 --> 00:40:23,049
output so a few more slides just to show

00:40:20,200 --> 00:40:26,440
you a memory profiler called the mem

00:40:23,049 --> 00:40:30,130
prov this is a you can reach it on get

00:40:26,440 --> 00:40:34,569
up ok so here is an example this is just

00:40:30,130 --> 00:40:37,539
an example so allocating a huge string I

00:40:34,569 --> 00:40:38,799
locating an object ok we have you talked

00:40:37,539 --> 00:40:43,180
about object because they are quite

00:40:38,799 --> 00:40:46,210
complicated to track adding the a

00:40:43,180 --> 00:40:49,089
variable in the object and a function

00:40:46,210 --> 00:40:50,750
just loading a file a PHP file ok and

00:40:49,089 --> 00:40:54,020
we'll see that this

00:40:50,750 --> 00:40:57,470
is a very very heavy for memory if you

00:40:54,020 --> 00:41:00,590
have a big script to open and using mem

00:40:57,470 --> 00:41:02,870
prof you have something called member of

00:41:00,590 --> 00:41:05,060
damp cold ground a function which is

00:41:02,870 --> 00:41:10,100
added to PHP when you load the the

00:41:05,060 --> 00:41:12,590
extension and it will put a trace into a

00:41:10,100 --> 00:41:15,980
Phi and this trace you can open it with

00:41:12,590 --> 00:41:19,250
a Turkish Grand like you do for XD back

00:41:15,980 --> 00:41:22,130
or you can use the Google profiler tools

00:41:19,250 --> 00:41:25,790
as well you can open it and you have

00:41:22,130 --> 00:41:29,180
something like that ok this is size of

00:41:25,790 --> 00:41:33,230
memory allocated in megabytes 8

00:41:29,180 --> 00:41:37,150
megabytes hundred nine megabytes to

00:41:33,230 --> 00:41:40,220
megabyte for loader and who has called

00:41:37,150 --> 00:41:44,240
string repeat and string repeat has

00:41:40,220 --> 00:41:47,630
allocated eight megabytes this is what

00:41:44,240 --> 00:41:50,840
we saw on the last script so this is a

00:41:47,630 --> 00:41:53,180
very nice extension because when you can

00:41:50,840 --> 00:41:56,780
when you put it on a framework based

00:41:53,180 --> 00:41:59,390
application sometimes you notice things

00:41:56,780 --> 00:42:02,480
that are not very very nice and then you

00:41:59,390 --> 00:42:05,210
make food requests on get up for for

00:42:02,480 --> 00:42:08,270
those frameworks and you can see you can

00:42:05,210 --> 00:42:10,700
track every function allocating memory

00:42:08,270 --> 00:42:14,390
and everything allocating memory you can

00:42:10,700 --> 00:42:16,700
see that the big array here the range is

00:42:14,390 --> 00:42:19,430
allocating lots of memory about hundred

00:42:16,700 --> 00:42:23,510
megabytes of memory so it's a very very

00:42:19,430 --> 00:42:26,950
huge and the loader as well the loader

00:42:23,510 --> 00:42:29,840
so just requiring a Phi without

00:42:26,950 --> 00:42:33,560
executing the code in it it's passing

00:42:29,840 --> 00:42:39,320
code compiling code to bytecode in the

00:42:33,560 --> 00:42:42,650
engine and this is this takes memory as

00:42:39,320 --> 00:42:45,770
well ok so some time we say oh you have

00:42:42,650 --> 00:42:47,840
a big variable I'll from my point of

00:42:45,770 --> 00:42:49,610
view I say how you're using a very huge

00:42:47,840 --> 00:42:52,610
framework and you're just cutting three

00:42:49,610 --> 00:42:55,760
functions inside so you're passing tons

00:42:52,610 --> 00:42:59,870
of PHP scripts compiling them into bite

00:42:55,760 --> 00:43:02,090
codon and having about 20 30 or 50

00:42:59,870 --> 00:43:03,910
megabytes of just passing the code and

00:43:02,090 --> 00:43:07,550
you call just one two three

00:43:03,910 --> 00:43:10,609
that's a waste okay some confusion

00:43:07,550 --> 00:43:15,700
everything consumes memory in PHP in

00:43:10,609 --> 00:43:18,349
real-world cases it's a big domdocument

00:43:15,700 --> 00:43:20,630
when you use domdocument you know that

00:43:18,349 --> 00:43:25,400
the domdocument actually passes for the

00:43:20,630 --> 00:43:29,330
xml okay big strings big file get

00:43:25,400 --> 00:43:32,570
contents a complex arrays arrays are

00:43:29,330 --> 00:43:36,770
tricky I get things to say with about

00:43:32,570 --> 00:43:39,320
arrays things you should know I will

00:43:36,770 --> 00:43:44,030
tell you later because a amount of time

00:43:39,320 --> 00:43:47,119
now have your results from dd's using

00:43:44,030 --> 00:43:50,570
MySQL native driver is very very smart

00:43:47,119 --> 00:43:55,310
for your memory when you use lib mysql

00:43:50,570 --> 00:43:58,490
you get twice more memory fetching a

00:43:55,310 --> 00:44:03,520
result than with mysql energy okay we

00:43:58,490 --> 00:44:08,599
told about that when 53 was released

00:44:03,520 --> 00:44:11,750
four years ago that my OMG has a deep

00:44:08,599 --> 00:44:14,060
binding into seat values and it's a very

00:44:11,750 --> 00:44:16,670
very much more efficient in memory than

00:44:14,060 --> 00:44:20,060
leave my school so using my skull my

00:44:16,670 --> 00:44:23,900
skull you're pg oats and heavy eczema

00:44:20,060 --> 00:44:26,420
okay so you have to benchmark memory and

00:44:23,900 --> 00:44:28,910
I guess you will give a try to this

00:44:26,420 --> 00:44:31,550
extension it's a little bit buggy

00:44:28,910 --> 00:44:34,460
sometimes little bugs it's very young

00:44:31,550 --> 00:44:38,000
extraction but you can pull request I'll

00:44:34,460 --> 00:44:40,220
know about this and now the PHP across

00:44:38,000 --> 00:44:43,250
the same APC has nothing to do about

00:44:40,220 --> 00:44:45,200
memory consumption reduction it's the

00:44:43,250 --> 00:44:47,859
opposite it allocates a shared memory

00:44:45,200 --> 00:44:54,349
segment very big well it depends on your

00:44:47,859 --> 00:44:58,670
AP 09 I know so be aware know how PHP

00:44:54,349 --> 00:45:01,220
works just Google some things are follow

00:44:58,670 --> 00:45:05,570
internals to see how it works and don't

00:45:01,220 --> 00:45:08,270
assume things without proving them okay

00:45:05,570 --> 00:45:10,340
when I assume oh you're going to you're

00:45:08,270 --> 00:45:14,000
going to have a very

00:45:10,340 --> 00:45:16,880
have a memory problem over there I'm

00:45:14,000 --> 00:45:20,030
just netting it now prove it just make a

00:45:16,880 --> 00:45:23,870
proof of concept a little script use

00:45:20,030 --> 00:45:26,150
tools branch them and show show grabs

00:45:23,870 --> 00:45:28,850
give me numbers give me grow up to two

00:45:26,150 --> 00:45:31,010
proof watch what you think because

00:45:28,850 --> 00:45:34,790
sometimes it's the opposite happening

00:45:31,010 --> 00:45:39,200
and I guess that's all thank you for

00:45:34,790 --> 00:45:44,930
listening you can find resources in the

00:45:39,200 --> 00:45:47,090
wiki ok wikidot php.net you can 5 final

00:45:44,930 --> 00:45:49,850
resources are on my webpage is french

00:45:47,090 --> 00:45:52,460
but you can translate it easily to

00:45:49,850 --> 00:45:54,680
english i'm going to try to translate my

00:45:52,460 --> 00:45:58,310
articles to english but it's very hard

00:45:54,680 --> 00:46:02,030
because it's very long ok and you have

00:45:58,310 --> 00:46:05,120
papers about memory usage in java and in

00:46:02,030 --> 00:46:07,310
python which are very interesting how

00:46:05,120 --> 00:46:09,260
the garbage collector and how the memory

00:46:07,310 --> 00:46:15,230
allocator in the java virtual machine

00:46:09,260 --> 00:46:18,380
works you can also grab mod sealer

00:46:15,230 --> 00:46:20,990
documents about firefox memory manager

00:46:18,380 --> 00:46:25,790
which are as well very interesting we

00:46:20,990 --> 00:46:29,000
get some tricks and put them in PHP when

00:46:25,790 --> 00:46:31,550
we find the two ids i guess i have fun

00:46:29,000 --> 00:46:36,160
just for questions five minutes 10

00:46:31,550 --> 00:46:36,160
minutes 55 minutes for questions

00:46:39,240 --> 00:46:45,690
I am the garbage collector is it cold

00:46:43,440 --> 00:46:49,280
automatically as soon as the ref count

00:46:45,690 --> 00:46:52,080
goes zero or afterwards it has nothing

00:46:49,280 --> 00:46:55,830
well it's wrong but it has nothing to do

00:46:52,080 --> 00:46:58,440
with ref count PHP freeze memory when

00:46:55,830 --> 00:47:00,780
the ref count which is zero no need to

00:46:58,440 --> 00:47:04,290
garbage collect ok garbage collector has

00:47:00,780 --> 00:47:06,240
been introduced to solve the circular

00:47:04,290 --> 00:47:08,580
reference this program you know an

00:47:06,240 --> 00:47:11,670
object pointing to another object things

00:47:08,580 --> 00:47:13,770
like that that cannot be freed easily

00:47:11,670 --> 00:47:16,110
because if you free be then a still

00:47:13,770 --> 00:47:18,570
pointing to be proved you a it's the

00:47:16,110 --> 00:47:21,960
opposite so garbage collector is acting

00:47:18,570 --> 00:47:25,730
just in case of circular references into

00:47:21,960 --> 00:47:33,560
arrays or more easily done with objects

00:47:25,730 --> 00:47:38,700
ok and it consumes memory 200 kilobytes

00:47:33,560 --> 00:47:41,940
yes and another question hi I'm with the

00:47:38,700 --> 00:47:43,980
references to the variables if you've

00:47:41,940 --> 00:47:45,900
got multiple references to kind of the

00:47:43,980 --> 00:47:47,760
same memory allocation you have to

00:47:45,900 --> 00:47:50,550
answer every variable or can you

00:47:47,760 --> 00:47:55,800
actually force all variables to be on

00:47:50,550 --> 00:48:00,480
set for that memory allocation well when

00:47:55,800 --> 00:48:02,880
you use references I had not I have no

00:48:00,480 --> 00:48:05,700
time to put all the slides about that

00:48:02,880 --> 00:48:08,810
but when you use references the behavior

00:48:05,700 --> 00:48:12,390
is changed and because when you you

00:48:08,810 --> 00:48:14,760
modify a variable ok it has to be

00:48:12,390 --> 00:48:17,369
modified on all the variables pointing

00:48:14,760 --> 00:48:20,250
to it if you use references the unset

00:48:17,369 --> 00:48:23,130
behavior is the same ok it just

00:48:20,250 --> 00:48:26,790
decreases the red currant the red count

00:48:23,130 --> 00:48:30,720
by one ok but if you have been using a

00:48:26,790 --> 00:48:34,380
reference the is Rev is flag is set to

00:48:30,720 --> 00:48:37,140
one and when it's set to one it tells

00:48:34,380 --> 00:48:40,710
PHP not to free the memory immediately

00:48:37,140 --> 00:48:44,670
ok now a tasty HP other behavior when

00:48:40,710 --> 00:48:48,150
you pass the variable two functions so

00:48:44,670 --> 00:48:50,600
the unsub behavior is the same using a

00:48:48,150 --> 00:48:52,490
reference or not so if you have a a

00:48:50,600 --> 00:48:55,580
equal to

00:48:52,490 --> 00:48:59,240
be equal m-pesa hey so you have a

00:48:55,580 --> 00:49:01,880
reference if you unset either B or a the

00:48:59,240 --> 00:49:04,670
behavior will be the same okay with

00:49:01,880 --> 00:49:07,460
unset the behavior will be changed when

00:49:04,670 --> 00:49:12,170
you pass your valuable two functions or

00:49:07,460 --> 00:49:14,690
two objects even course that will be one

00:49:12,170 --> 00:49:18,470
bit of thing you have you and you're

00:49:14,690 --> 00:49:26,360
actually on anyone's that I am veil so

00:49:18,470 --> 00:49:29,030
I'm dry can you so door i I don't I come

00:49:26,360 --> 00:49:39,070
here because it can you and via the same

00:49:29,030 --> 00:49:43,700
yes unset dola a dollar p yeah sure no

00:49:39,070 --> 00:49:46,880
you know you can't tell PHP 3ds memory

00:49:43,700 --> 00:49:48,680
now you can't because if you are

00:49:46,880 --> 00:49:50,780
pointing this memory video with other

00:49:48,680 --> 00:49:54,680
variables when you access them and then

00:49:50,780 --> 00:49:59,210
it's accessing freedom it's not very

00:49:54,680 --> 00:50:02,420
good so now you can't you can't tell PHP

00:49:59,210 --> 00:50:04,850
to to unset all the variables pointing

00:50:02,420 --> 00:50:12,070
to the same civil as this variable it's

00:50:04,850 --> 00:50:12,070
not possible anymore question perhaps

00:50:13,460 --> 00:50:16,390
but from up

00:50:19,260 --> 00:50:22,760
okay so thank you

00:50:34,789 --> 00:50:36,849

YouTube URL: https://www.youtube.com/watch?v=sm1HUrnsxLI


