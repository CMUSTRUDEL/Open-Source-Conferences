Title: Stephan HochdÃ¶rfer - The NoSQL Store everyone ignores: PostgreSQL
Publication date: 2015-04-15
Playlist: PHP UK Conference 2015
Description: 
	PostgreSQL is well known being an object-relational database management system. In it`s core PostgreSQL is schema-aware dealing with fixed database tables and column types. However, recent versions of PostgreSQL made it possible to deal with schema-free data. Learn which new features PostgreSQL supports and how to use those features in your PHP application.

https://talks.bitexpert.de/phpuk15-postgres-nosql/
Captions: 
	00:00:06,260 --> 00:00:10,100
so this is a weird talk actually the

00:00:08,750 --> 00:00:11,360
title looks pretty weird I'm talking

00:00:10,100 --> 00:00:14,290
about no sequel and I'm talking about

00:00:11,360 --> 00:00:17,779
Postgres and how to combine these stuff

00:00:14,290 --> 00:00:20,510
who's this crazy guy on stage my name is

00:00:17,779 --> 00:00:22,099
Stefan if you really want to go crazy

00:00:20,510 --> 00:00:25,610
you can try to pronounce my last name

00:00:22,099 --> 00:00:28,820
it's Hoover but you can call me Stefan

00:00:25,610 --> 00:00:30,560
it's okay as you can see by this really

00:00:28,820 --> 00:00:31,009
weird letter in my last name I'm from

00:00:30,560 --> 00:00:32,720
Germany

00:00:31,009 --> 00:00:34,430
I live there I run my own company there

00:00:32,720 --> 00:00:37,760
the company is called bird expert we're

00:00:34,430 --> 00:00:39,710
in business for the last 12 years my

00:00:37,760 --> 00:00:41,660
current role is head of technology which

00:00:39,710 --> 00:00:45,320
basically means I'm a kind of internal

00:00:41,660 --> 00:00:46,670
consultant I help our teams to get get

00:00:45,320 --> 00:00:49,280
the technology up and working and

00:00:46,670 --> 00:00:51,589
educate them and they're like if if any

00:00:49,280 --> 00:00:53,660
questions concerning this talk feel free

00:00:51,589 --> 00:00:56,749
to find me I'll be here the whole day if

00:00:53,660 --> 00:00:59,410
however you don't like or want to talk

00:00:56,749 --> 00:01:01,519
to a German which I can fully understand

00:00:59,410 --> 00:01:04,390
this is my email address this is my

00:01:01,519 --> 00:01:06,920
Twitter account so you can chat online

00:01:04,390 --> 00:01:09,340
so that's me so who are you who have

00:01:06,920 --> 00:01:13,370
used using a relational database at work

00:01:09,340 --> 00:01:15,650
okay cool who of you is more the kind of

00:01:13,370 --> 00:01:21,170
the know psycho guy yeah just Eric

00:01:15,650 --> 00:01:25,460
obviously okay so I think I got covered

00:01:21,170 --> 00:01:30,890
both worlds in this talk let's get

00:01:25,460 --> 00:01:33,890
started um thing is relational databases

00:01:30,890 --> 00:01:36,490
are a kind of a relict from the past

00:01:33,890 --> 00:01:39,230
they got invented in the last century

00:01:36,490 --> 00:01:43,370
they solved our problems we had back

00:01:39,230 --> 00:01:45,200
then but do these problems still exist

00:01:43,370 --> 00:01:47,690
today or are we facing probably

00:01:45,200 --> 00:01:49,010
different problems so that that's a

00:01:47,690 --> 00:01:53,120
valid question that we need to ask

00:01:49,010 --> 00:01:56,140
ourselves who view is still working in a

00:01:53,120 --> 00:01:59,660
traditional waterfall kind Process Model

00:01:56,140 --> 00:02:01,610
no hands up that's awesome sometimes I

00:01:59,660 --> 00:02:03,500
get one or two hands up which is really

00:02:01,610 --> 00:02:05,780
weird these days so probably you all do

00:02:03,500 --> 00:02:11,569
work agile right who've used working

00:02:05,780 --> 00:02:12,800
agile sort of okay working in an agile

00:02:11,569 --> 00:02:16,310
environment and using a relational

00:02:12,800 --> 00:02:19,099
database can be quite complicated

00:02:16,310 --> 00:02:21,019
at least when you think of agile

00:02:19,099 --> 00:02:23,959
the customer has no idea what he really

00:02:21,019 --> 00:02:26,269
wants and so in each iteration you could

00:02:23,959 --> 00:02:28,999
probably change the whole schema of your

00:02:26,269 --> 00:02:31,790
application over and over again and in

00:02:28,999 --> 00:02:33,650
this case no sequel gives us more

00:02:31,790 --> 00:02:35,569
freedom because we simply do not care

00:02:33,650 --> 00:02:39,019
about the schema in the database because

00:02:35,569 --> 00:02:41,120
we don't have any schema well actually

00:02:39,019 --> 00:02:43,069
when we're talking about document stores

00:02:41,120 --> 00:02:44,269
which I assume in this case I know

00:02:43,069 --> 00:02:45,919
they're a couple of are the no sequel

00:02:44,269 --> 00:02:48,109
stores but for the sake of this

00:02:45,919 --> 00:02:52,430
presentation when I say no sequel I mean

00:02:48,109 --> 00:02:54,169
document kind of source so the document

00:02:52,430 --> 00:02:56,030
store does not really limit us we can

00:02:54,169 --> 00:02:58,760
persist any kind of object retrieve it

00:02:56,030 --> 00:03:00,650
back and and just work with it and we

00:02:58,760 --> 00:03:05,480
can change the object per system again

00:03:00,650 --> 00:03:08,629
and do not face any problems um when

00:03:05,480 --> 00:03:11,030
when storing that stuff as it turns out

00:03:08,629 --> 00:03:13,849
there are a bunch of no sequel databases

00:03:11,030 --> 00:03:17,060
some more well-known like couch or

00:03:13,849 --> 00:03:20,719
or edits some less known like hyper

00:03:17,060 --> 00:03:22,010
table hazel kastri thing there is a

00:03:20,719 --> 00:03:24,439
website out there which is called no

00:03:22,010 --> 00:03:27,859
sequel databases org which lists more

00:03:24,439 --> 00:03:29,629
than 150 different implementations which

00:03:27,859 --> 00:03:31,280
gives us developers a really hard time

00:03:29,629 --> 00:03:35,389
figuring out which is the best

00:03:31,280 --> 00:03:38,780
technology for our problem right and as

00:03:35,389 --> 00:03:39,979
it turns out like 10-15 years ago when

00:03:38,780 --> 00:03:41,540
you were a developer and you wanted to

00:03:39,979 --> 00:03:44,269
show your skills you wrote your own

00:03:41,540 --> 00:03:45,349
content management system right these

00:03:44,269 --> 00:03:47,840
days when you want to show off your

00:03:45,349 --> 00:03:50,419
skills you write a no sequel store or a

00:03:47,840 --> 00:03:54,889
dependency injection container so depend

00:03:50,419 --> 00:03:57,290
just get we can classify these no

00:03:54,889 --> 00:03:59,120
databases into certain categories um

00:03:57,290 --> 00:04:02,569
their graph databases like neo4j

00:03:59,120 --> 00:04:04,639
where you store your entities in a graph

00:04:02,569 --> 00:04:06,139
kind of structure we got object

00:04:04,639 --> 00:04:08,540
databases where you persist the whole

00:04:06,139 --> 00:04:10,579
object and you do not need to use an

00:04:08,540 --> 00:04:13,849
object relational mapper that we use to

00:04:10,579 --> 00:04:16,940
do these days there are column based

00:04:13,849 --> 00:04:19,340
stores fun fact you can also use a

00:04:16,940 --> 00:04:21,799
column based store in Postgres a couple

00:04:19,340 --> 00:04:24,289
of extensions which allow it to do so

00:04:21,799 --> 00:04:27,919
there's the ICMS extension and there is

00:04:24,289 --> 00:04:30,500
situs DB arm which kind of simulate the

00:04:27,919 --> 00:04:32,139
column like stores in Postgres and we've

00:04:30,500 --> 00:04:35,409
got key value stores

00:04:32,139 --> 00:04:37,569
um Sting's like Redis and a memcache and

00:04:35,409 --> 00:04:40,360
the like and we got the document stores

00:04:37,569 --> 00:04:42,759
 Couchbase whatnot and we're mostly

00:04:40,360 --> 00:04:46,419
focusing on the bottom two during this

00:04:42,759 --> 00:04:50,199
presentation so why does schema-less

00:04:46,419 --> 00:04:52,960
make sense well first of all schema

00:04:50,199 --> 00:04:55,360
changes can be pretty expensive a couple

00:04:52,960 --> 00:04:57,009
of relational databases which would lock

00:04:55,360 --> 00:04:59,560
the whole table when you do a schema

00:04:57,009 --> 00:05:01,360
change which is probably not a big deal

00:04:59,560 --> 00:05:04,270
if you have just a hundred or a thousand

00:05:01,360 --> 00:05:06,069
records in your database if you're as

00:05:04,270 --> 00:05:08,169
big as Facebook and you would try to do

00:05:06,069 --> 00:05:09,490
schema change it will probably lock the

00:05:08,169 --> 00:05:13,509
whole application for a couple of years

00:05:09,490 --> 00:05:14,469
which is probably not what you want it

00:05:13,509 --> 00:05:16,090
definitely can speed up development

00:05:14,469 --> 00:05:18,909
because you simply do not have to take

00:05:16,090 --> 00:05:20,500
care of of all this schema stuff you

00:05:18,909 --> 00:05:23,409
just persist your objects as they come

00:05:20,500 --> 00:05:25,210
in it's pretty efficient for stuff like

00:05:23,409 --> 00:05:26,469
continuous delivery because I really

00:05:25,210 --> 00:05:28,539
don't care about the database so i just

00:05:26,469 --> 00:05:31,930
deploy my application and it's working

00:05:28,539 --> 00:05:33,909
hopefully and most importantly

00:05:31,930 --> 00:05:35,979
schema-less does not mean unstructured

00:05:33,909 --> 00:05:37,479
like most people say well the schema is

00:05:35,979 --> 00:05:39,969
I have unstructured data but that's not

00:05:37,479 --> 00:05:41,979
true like in in a schema wise database

00:05:39,969 --> 00:05:43,990
each record is structured by itself I

00:05:41,979 --> 00:05:45,490
mean yes this product that I persisted

00:05:43,990 --> 00:05:46,839
like six months ago may look a bit

00:05:45,490 --> 00:05:48,639
different from the product data I'm

00:05:46,839 --> 00:05:51,399
persisting now but that's not a big deal

00:05:48,639 --> 00:05:53,529
obviously I have to take care of that in

00:05:51,399 --> 00:05:56,080
the application space so I need to deal

00:05:53,529 --> 00:05:58,750
with with these situations so how can

00:05:56,080 --> 00:06:01,360
Fosters help us more Postgres is sort of

00:05:58,750 --> 00:06:06,159
a glue who views using Postgres by the

00:06:01,360 --> 00:06:10,000
way okay very few so Postgres is a

00:06:06,159 --> 00:06:12,490
really old database arm it came to life

00:06:10,000 --> 00:06:13,389
in the mid-80s it got open source in the

00:06:12,490 --> 00:06:16,060
mid-90s

00:06:13,389 --> 00:06:18,129
currently we are at version 9.4 which

00:06:16,060 --> 00:06:20,379
was released in December last year and

00:06:18,129 --> 00:06:22,330
pretty cool thing about puskÃ¡s is that

00:06:20,379 --> 00:06:26,050
it's super extensible it has more than

00:06:22,330 --> 00:06:29,589
300 different data types and a few big

00:06:26,050 --> 00:06:31,360
air quotes document type data types so I

00:06:29,589 --> 00:06:33,339
can pick what you need and combine the

00:06:31,360 --> 00:06:38,620
relational part with a document store

00:06:33,339 --> 00:06:39,370
and get the best out of it so depending

00:06:38,620 --> 00:06:42,159
on your problem

00:06:39,370 --> 00:06:44,610
you could either store a document in a

00:06:42,159 --> 00:06:45,830
kind of document orientated fashion or

00:06:44,610 --> 00:06:48,919
you

00:06:45,830 --> 00:06:52,699
the usual relational stuff that process

00:06:48,919 --> 00:06:56,120
supports out-of-the-box but be careful

00:06:52,699 --> 00:06:59,120
what you do um there is this this lady

00:06:56,120 --> 00:07:01,970
Sara Mae who I think it's about two

00:06:59,120 --> 00:07:03,740
years ago published a blog post which

00:07:01,970 --> 00:07:08,539
was titled why you should never use

00:07:03,740 --> 00:07:10,310
 which to be honest it was probably

00:07:08,539 --> 00:07:14,240
not the best title because it's not

00:07:10,310 --> 00:07:18,349
really a problem of but anyway so

00:07:14,240 --> 00:07:20,630
she comes from this team called diaspora

00:07:18,349 --> 00:07:23,599
or she knows the guys who runnin this

00:07:20,630 --> 00:07:26,419
diaspora project this distributed social

00:07:23,599 --> 00:07:28,759
network alternative to Facebook and when

00:07:26,419 --> 00:07:30,650
the guys started developing diaspora

00:07:28,759 --> 00:07:33,050
they figured out hey which kind of data

00:07:30,650 --> 00:07:35,330
store should we use and back in the days

00:07:33,050 --> 00:07:39,080
it was said that social data is not

00:07:35,330 --> 00:07:42,620
relational so they went the document

00:07:39,080 --> 00:07:44,479
path and they picked and they kept

00:07:42,620 --> 00:07:46,520
on developing and figure out hey we

00:07:44,479 --> 00:07:49,009
having a few issues with how we store

00:07:46,520 --> 00:07:51,620
data but we'll just go on and figure out

00:07:49,009 --> 00:07:54,139
how to solve these problems and like a

00:07:51,620 --> 00:07:56,090
year or so later they just stepped back

00:07:54,139 --> 00:07:58,400
a bit and analyzed what was going on and

00:07:56,090 --> 00:08:01,009
they came to the conclusion that these

00:07:58,400 --> 00:08:03,440
problems only existed because they try

00:08:01,009 --> 00:08:08,659
to emulate a relational database on top

00:08:03,440 --> 00:08:10,669
of which simply stupid so what

00:08:08,659 --> 00:08:13,340
they did back then is they ditched

00:08:10,669 --> 00:08:14,930
replace it with my sequel and it's it's

00:08:13,340 --> 00:08:16,610
been said that all their problems were

00:08:14,930 --> 00:08:20,120
gone so it's really important to

00:08:16,610 --> 00:08:24,130
understand what you want to achieve with

00:08:20,120 --> 00:08:27,469
the data to pick the right data store

00:08:24,130 --> 00:08:30,080
back in the days I really thought that

00:08:27,469 --> 00:08:32,180
there are two kinds of applications we

00:08:30,080 --> 00:08:35,029
are dealing with at least in my company

00:08:32,180 --> 00:08:37,370
we had these kind of like enterprise-d

00:08:35,029 --> 00:08:39,110
applications where relations are really

00:08:37,370 --> 00:08:43,279
important they were key to the domain

00:08:39,110 --> 00:08:47,360
and more like the social community kind

00:08:43,279 --> 00:08:51,709
of applications where the relations were

00:08:47,360 --> 00:08:53,990
not so important but after thinking

00:08:51,709 --> 00:08:55,459
about this a bit longer I realized it's

00:08:53,990 --> 00:08:57,770
not the type of application that is

00:08:55,459 --> 00:08:59,089
important it's what I want to do with

00:08:57,770 --> 00:09:01,790
the data do

00:08:59,089 --> 00:09:04,579
I really need this relations or do I not

00:09:01,790 --> 00:09:08,029
need the relations so you have to be

00:09:04,579 --> 00:09:09,980
sure which path you're heading and how

00:09:08,029 --> 00:09:12,499
important the data and the relationships

00:09:09,980 --> 00:09:14,949
between the data is to figure out which

00:09:12,499 --> 00:09:19,009
data store makes the most sense

00:09:14,949 --> 00:09:21,290
so let's going back to Posterous as I

00:09:19,009 --> 00:09:23,809
said both Postgres contains a few schema

00:09:21,290 --> 00:09:26,990
less data types which I'll cover in this

00:09:23,809 --> 00:09:28,670
session talking about arrays which is

00:09:26,990 --> 00:09:31,730
not really schema less data type but

00:09:28,670 --> 00:09:35,259
cool nonetheless there is H store there

00:09:31,730 --> 00:09:38,720
is JSON and JSON be and there is XML oh

00:09:35,259 --> 00:09:41,629
yeah I forgot to say right now you will

00:09:38,720 --> 00:09:46,120
see a shitload of sequel if you can't

00:09:41,629 --> 00:09:49,819
stand that you're probably free to leave

00:09:46,120 --> 00:09:52,839
but don't blame me afterwards what's

00:09:49,819 --> 00:09:56,499
really interesting in in this case is

00:09:52,839 --> 00:09:59,360
this term no sequel was coined in 2009

00:09:56,499 --> 00:10:03,559
the H store data type is in Postgres

00:09:59,360 --> 00:10:05,029
since 2003 since 2006 there is the JSON

00:10:03,559 --> 00:10:07,879
data type there is an extension for it

00:10:05,029 --> 00:10:10,370
it got into into the core distribution

00:10:07,879 --> 00:10:12,379
of prospects back in 92 so for a long

00:10:10,370 --> 00:10:14,509
time we have this crazy weird data types

00:10:12,379 --> 00:10:16,519
but no one really knows about it so that

00:10:14,509 --> 00:10:18,889
was mostly the reason for this talk to

00:10:16,519 --> 00:10:22,660
make you aware of what cool stuff is in

00:10:18,889 --> 00:10:25,910
post press so let's talk about the race

00:10:22,660 --> 00:10:29,139
case you have heard of arrays before who

00:10:25,910 --> 00:10:35,360
using who view is using arrays in PHP I

00:10:29,139 --> 00:10:37,160
want to see all hands up okay great

00:10:35,360 --> 00:10:41,899
so I can have arrays in posters as well

00:10:37,160 --> 00:10:44,959
and you can use arrays in combination

00:10:41,899 --> 00:10:47,029
for almost every built-in basic data

00:10:44,959 --> 00:10:50,509
type as well as in ohms and and custom

00:10:47,029 --> 00:10:53,899
defined types as well it's really cool

00:10:50,509 --> 00:10:58,449
to get rid of one to n relations let's

00:10:53,899 --> 00:11:03,679
say we want to write a blog application

00:10:58,449 --> 00:11:05,480
no idea why but anyway in in a

00:11:03,679 --> 00:11:07,670
traditional relational schema I would

00:11:05,480 --> 00:11:09,620
have a blog post table I would have a

00:11:07,670 --> 00:11:11,649
tax table and I would have a

00:11:09,620 --> 00:11:15,269
relationship table which would map

00:11:11,649 --> 00:11:18,220
od blog post that's three tables for a

00:11:15,269 --> 00:11:20,800
pretty basic problem right it's it looks

00:11:18,220 --> 00:11:23,230
it looks a bit too much and arrays can

00:11:20,800 --> 00:11:25,740
help us in this case so let's get

00:11:23,230 --> 00:11:28,689
started this is how you create an array

00:11:25,740 --> 00:11:30,850
an array column so we create a blog post

00:11:28,689 --> 00:11:33,939
table it contains the title content and

00:11:30,850 --> 00:11:36,220
an array of tags so you just name name

00:11:33,939 --> 00:11:37,300
the field like in this case text and

00:11:36,220 --> 00:11:39,220
then you just add these square brackets

00:11:37,300 --> 00:11:42,279
at the end to indicate that this is an

00:11:39,220 --> 00:11:46,749
array you can also do multi-dimensional

00:11:42,279 --> 00:11:48,459
arrays so if you do really crazy stuff

00:11:46,749 --> 00:11:51,189
you can use that as well as you can see

00:11:48,459 --> 00:11:53,139
you can also specify the length of the

00:11:51,189 --> 00:11:55,990
array like in this case it's three for

00:11:53,139 --> 00:11:57,999
both dimensions postcodes right now it

00:11:55,990 --> 00:12:00,069
doesn't check that so I could make a

00:11:57,999 --> 00:12:02,529
four by four metrics out of that or a

00:12:00,069 --> 00:12:05,949
six by six it doesn't really care at

00:12:02,529 --> 00:12:07,839
least now but this is if I recall

00:12:05,949 --> 00:12:09,220
correctly this is the closest to the

00:12:07,839 --> 00:12:11,619
sequel ninety-two standard as you can

00:12:09,220 --> 00:12:14,559
get so you can if you really want to

00:12:11,619 --> 00:12:17,079
group if you really want to be as close

00:12:14,559 --> 00:12:23,620
as possible to the sequel 92 standard

00:12:17,079 --> 00:12:24,639
use the length having issues anyway I'll

00:12:23,620 --> 00:12:27,399
just keep talking

00:12:24,639 --> 00:12:33,999
so this is how you insert data um you

00:12:27,399 --> 00:12:36,579
have an array keyword crap I'll just

00:12:33,999 --> 00:12:40,809
keep keep talking so you've got an array

00:12:36,579 --> 00:12:43,720
keyword would you grab my ear please so

00:12:40,809 --> 00:12:45,339
this isn't a right keyword you you add

00:12:43,720 --> 00:12:47,470
these square brackets and then you list

00:12:45,339 --> 00:12:51,100
all the all the items that you want to

00:12:47,470 --> 00:12:53,949
store like in this case it strings I can

00:12:51,100 --> 00:12:56,439
perfectly thank you I can store as many

00:12:53,949 --> 00:12:58,049
items as I want so I do not need to have

00:12:56,439 --> 00:13:00,100
a fixed length for each of the items

00:12:58,049 --> 00:13:01,839
it's important to know that this is an

00:13:00,100 --> 00:13:06,970
index based array so it's not a hash map

00:13:01,839 --> 00:13:10,209
like in PHP or if you're sequel driver

00:13:06,970 --> 00:13:12,339
does not support the array syntax you

00:13:10,209 --> 00:13:14,350
could use the the angle brackets and

00:13:12,339 --> 00:13:17,139
list the keys as well so this is

00:13:14,350 --> 00:13:20,019
probably the easiest to get in your in

00:13:17,139 --> 00:13:23,759
your client application how do we select

00:13:20,019 --> 00:13:23,759
data well it's easy

00:13:25,110 --> 00:13:29,400
so we named the column which is tags we

00:13:27,870 --> 00:13:31,620
had these square brackets and then we

00:13:29,400 --> 00:13:33,360
refer to the index given that we have

00:13:31,620 --> 00:13:35,610
two blog posts in the table we select

00:13:33,360 --> 00:13:37,590
them we get two results back obviously

00:13:35,610 --> 00:13:39,810
as you can see the bottom one is empty

00:13:37,590 --> 00:13:41,340
so usually we would get back in null

00:13:39,810 --> 00:13:46,560
value because we are just having two

00:13:41,340 --> 00:13:47,790
entries in this in this row so you have

00:13:46,560 --> 00:13:49,590
to be careful what you do in this case

00:13:47,790 --> 00:13:52,920
it's really important to know that

00:13:49,590 --> 00:13:56,340
arrays are one based indexes or use one

00:13:52,920 --> 00:13:58,050
based indexes so this is really the item

00:13:56,340 --> 00:14:00,660
number three and not the item number

00:13:58,050 --> 00:14:02,820
four this will really confuse you when

00:14:00,660 --> 00:14:07,680
you when we get to the JSON arrays

00:14:02,820 --> 00:14:10,440
because it's slightly different there so

00:14:07,680 --> 00:14:11,910
watch out we can also use arrays for

00:14:10,440 --> 00:14:13,650
filtering for the for the where clause

00:14:11,910 --> 00:14:16,020
like in this case show me all the blog

00:14:13,650 --> 00:14:18,900
posts where tag at the position number

00:14:16,020 --> 00:14:24,000
two is Epsom which will give us both

00:14:18,900 --> 00:14:27,060
records we can also search in an array

00:14:24,000 --> 00:14:29,790
so there is the any function or the any

00:14:27,060 --> 00:14:32,090
keyword where simply say give me all the

00:14:29,790 --> 00:14:36,270
blog posts where any of the tags is

00:14:32,090 --> 00:14:39,630
named blog post which will give me just

00:14:36,270 --> 00:14:43,100
one entry if there is any you guessed it

00:14:39,630 --> 00:14:49,830
there is also all the all keyword oh

00:14:43,100 --> 00:14:56,880
yeah let's try this one feel free anyway

00:14:49,830 --> 00:14:59,130
okay cool thank you that's a lot of fun

00:14:56,880 --> 00:15:01,770
for this morning a session right anyway

00:14:59,130 --> 00:15:04,320
so yeah as I said there is when there's

00:15:01,770 --> 00:15:06,510
the any keyword there's also all I have

00:15:04,320 --> 00:15:08,760
not found any good use case where I want

00:15:06,510 --> 00:15:11,280
to check if an array consists of the

00:15:08,760 --> 00:15:17,310
same value at all maybe there is one

00:15:11,280 --> 00:15:19,260
Ayano however be aware that this can

00:15:17,310 --> 00:15:21,150
lead to performance issues because what

00:15:19,260 --> 00:15:23,460
process is doing in this case it will go

00:15:21,150 --> 00:15:26,670
through all the blog posts and then

00:15:23,460 --> 00:15:29,450
check each array item right so this can

00:15:26,670 --> 00:15:29,450
be quite slow

00:15:31,190 --> 00:15:35,660
that is a very good question I'll come

00:15:33,890 --> 00:15:38,960
to that later on so Derrick was asking

00:15:35,660 --> 00:15:43,910
about indexes just wait maybe five

00:15:38,960 --> 00:15:46,220
slides so yeah so don't overuse that if

00:15:43,910 --> 00:15:49,820
you really need a relation in your

00:15:46,220 --> 00:15:51,860
database then then use that don't just

00:15:49,820 --> 00:15:55,310
go home and change all of your relations

00:15:51,860 --> 00:15:56,930
to erase that does not work what it does

00:15:55,310 --> 00:16:00,650
work technically but it doesn't make

00:15:56,930 --> 00:16:02,240
sense we can also filter using the

00:16:00,650 --> 00:16:04,550
double ampersand operator which is

00:16:02,240 --> 00:16:06,230
called the overlapping operator so at

00:16:04,550 --> 00:16:09,530
least one element on the right hand side

00:16:06,230 --> 00:16:13,840
needs to be contained in the tax which

00:16:09,530 --> 00:16:17,780
will give us both back we can also have

00:16:13,840 --> 00:16:20,570
weight welcome to the weird-looking

00:16:17,780 --> 00:16:22,400
possible operator world so we got this

00:16:20,570 --> 00:16:25,400
add greater sign which is the

00:16:22,400 --> 00:16:27,110
containment operator so at least one of

00:16:25,400 --> 00:16:29,390
the items on the right hand side needs

00:16:27,110 --> 00:16:34,070
to be contained in the tax array so

00:16:29,390 --> 00:16:36,350
either lorem or blog post which will no

00:16:34,070 --> 00:16:37,550
sorry all elements on the right hand

00:16:36,350 --> 00:16:40,970
side need to be contained on the

00:16:37,550 --> 00:16:44,390
left-hand side which will give us just

00:16:40,970 --> 00:16:47,060
the one back that you can see so every

00:16:44,390 --> 00:16:49,280
good blog post application needs a tag

00:16:47,060 --> 00:16:52,730
cloud right because technology is so web

00:16:49,280 --> 00:16:54,560
done to the dough so how can we generate

00:16:52,730 --> 00:16:58,670
a tag cloud from that well that's pretty

00:16:54,560 --> 00:17:06,310
easy as well hang on I'll just explain

00:16:58,670 --> 00:17:08,720
that so there is the unnecessary rows so

00:17:06,310 --> 00:17:10,640
we convert all the arrays that we have

00:17:08,720 --> 00:17:13,270
into secured rows we group them by the

00:17:10,640 --> 00:17:17,120
tag and then we do the count which will

00:17:13,270 --> 00:17:18,740
give us all the tags and the count so we

00:17:17,120 --> 00:17:21,500
have all the information needed to

00:17:18,740 --> 00:17:24,709
generate and pretty awesome tag cloud

00:17:21,500 --> 00:17:28,220
and now we can answer text questions

00:17:24,709 --> 00:17:30,800
can't we use indexes yes we can sort of

00:17:28,220 --> 00:17:33,020
so we can create an index age in index

00:17:30,800 --> 00:17:37,460
so gin stands for generalized inverted

00:17:33,020 --> 00:17:41,390
index on this array and then if we do

00:17:37,460 --> 00:17:45,020
the the containment search we can see in

00:17:41,390 --> 00:17:48,290
the query plan that it will use the end

00:17:45,020 --> 00:17:51,559
for the skin so we have a little bit of

00:17:48,290 --> 00:17:54,740
indexing for the arrays how do we update

00:17:51,559 --> 00:17:56,570
arrays pretty easy we can just overwrite

00:17:54,740 --> 00:18:00,950
the whole array as we've done with the

00:17:56,570 --> 00:18:03,559
insert we can update single items so

00:18:00,950 --> 00:18:05,630
let's check that first as you can see my

00:18:03,559 --> 00:18:10,160
blog post I should have used English

00:18:05,630 --> 00:18:13,309
titles sorry so we got tag one tag two

00:18:10,160 --> 00:18:15,440
and blog post in in the text column we

00:18:13,309 --> 00:18:17,360
can also update a single item by just

00:18:15,440 --> 00:18:19,070
referring to the to the index that we

00:18:17,360 --> 00:18:22,580
want to update like in this case setting

00:18:19,070 --> 00:18:26,450
tag number 3 - Tech 3 which will give

00:18:22,580 --> 00:18:30,740
you this now - something really

00:18:26,450 --> 00:18:33,830
interesting I can add almost any index

00:18:30,740 --> 00:18:36,440
that I want like in this case 5 so the

00:18:33,830 --> 00:18:39,290
update will work fine if we have a look

00:18:36,440 --> 00:18:42,710
what's the outcome of this it will look

00:18:39,290 --> 00:18:47,090
like this there is a null value for each

00:18:42,710 --> 00:18:49,280
index that was not set before yes this

00:18:47,090 --> 00:18:51,559
means if I change the five to fifty

00:18:49,280 --> 00:18:55,360
thousand it will generate a bunch of

00:18:51,559 --> 00:18:58,340
null values which may or may not be good

00:18:55,360 --> 00:19:00,380
and this only works for one-dimensional

00:18:58,340 --> 00:19:01,640
arrays so in the two-dimensional array

00:19:00,380 --> 00:19:05,720
this just doesn't work you get an error

00:19:01,640 --> 00:19:09,559
back we can also do a partial update

00:19:05,720 --> 00:19:11,480
where we say the lower bound : and then

00:19:09,559 --> 00:19:13,790
the upper bound of the items that should

00:19:11,480 --> 00:19:17,150
be updated so the the right-hand

00:19:13,790 --> 00:19:20,240
operator can be bigger than the debounce

00:19:17,150 --> 00:19:22,730
then the length of the bounds and the

00:19:20,240 --> 00:19:24,620
the items would would be skipped so we

00:19:22,730 --> 00:19:26,150
will pick the the left item and then

00:19:24,620 --> 00:19:30,350
just go through the list until all the

00:19:26,150 --> 00:19:32,390
items were correctly updated if you pass

00:19:30,350 --> 00:19:34,960
less items then you want to update you

00:19:32,390 --> 00:19:37,970
will get an error for all these reasons

00:19:34,960 --> 00:19:40,309
so we got a bunch of yeah so we can see

00:19:37,970 --> 00:19:43,850
that's the final state we got tagged one

00:19:40,309 --> 00:19:46,370
to tag five as the name of the tax there

00:19:43,850 --> 00:19:48,350
are a bunch of array functions array

00:19:46,370 --> 00:19:50,809
dims gives us a hint about the

00:19:48,350 --> 00:19:52,910
dimensions of the array upper and lower

00:19:50,809 --> 00:19:57,290
gives me the upper bound the lower bound

00:19:52,910 --> 00:19:58,610
um I can grab the length and I can build

00:19:57,290 --> 00:20:01,280
my own arrays you

00:19:58,610 --> 00:20:03,140
era prepend or an area pen so I can do

00:20:01,280 --> 00:20:06,549
some pretty hardcore magic and in that

00:20:03,140 --> 00:20:11,299
case okay so that's that's pretty cool

00:20:06,549 --> 00:20:19,460
now off to a more document kind of data

00:20:11,299 --> 00:20:24,290
store h2 yes so Derek is asking if I can

00:20:19,460 --> 00:20:26,840
push errors to the end of the array well

00:20:24,290 --> 00:20:29,720
you could do using the array append

00:20:26,840 --> 00:20:32,150
function like doing the update and

00:20:29,720 --> 00:20:34,340
saying I want to refer to this column as

00:20:32,150 --> 00:20:38,450
the first parameter to array append and

00:20:34,340 --> 00:20:41,660
then just add the items I never tried it

00:20:38,450 --> 00:20:47,600
but that's probably obvious solution so

00:20:41,660 --> 00:20:51,140
H store H store is a real yeah kind of

00:20:47,600 --> 00:20:53,030
document store it's containing of key

00:20:51,140 --> 00:20:57,770
value pairs and keys and values need to

00:20:53,030 --> 00:21:00,679
be strings interesting fact if during an

00:20:57,770 --> 00:21:04,100
insert in our update you pass a key

00:21:00,679 --> 00:21:07,760
multiple times there is no real strategy

00:21:04,100 --> 00:21:10,610
which key wins that sounds really

00:21:07,760 --> 00:21:12,200
interesting I have no idea how this is

00:21:10,610 --> 00:21:14,270
implemented eternally if there's a kind

00:21:12,200 --> 00:21:17,000
of rent function or whatnot

00:21:14,270 --> 00:21:18,620
I have no idea so when you insert or

00:21:17,000 --> 00:21:23,059
update data make sure that each of the

00:21:18,620 --> 00:21:25,370
keys is really there on its own each

00:21:23,059 --> 00:21:28,340
store is the only extension that is not

00:21:25,370 --> 00:21:29,960
part of the Pascua score so you need on

00:21:28,340 --> 00:21:33,980
Linux you need to install the Postgres

00:21:29,960 --> 00:21:35,840
country package and then you open your

00:21:33,980 --> 00:21:37,610
your database and then you say create

00:21:35,840 --> 00:21:40,220
extension H store which would register

00:21:37,610 --> 00:21:43,549
this data type or this extension with

00:21:40,220 --> 00:21:46,460
your database and then you're able to to

00:21:43,549 --> 00:21:49,340
use this data type when creating a

00:21:46,460 --> 00:21:50,450
database table so in this case imagine

00:21:49,340 --> 00:21:52,820
we're dealing with the products database

00:21:50,450 --> 00:21:56,570
we are importing all sorts of product

00:21:52,820 --> 00:22:00,320
data from different customers and these

00:21:56,570 --> 00:22:01,820
products look all pretty different like

00:22:00,320 --> 00:22:04,520
they have a few things in common like a

00:22:01,820 --> 00:22:06,679
name a price a description but then a

00:22:04,520 --> 00:22:08,929
bunch of metadata that we simply have no

00:22:06,679 --> 00:22:10,970
idea what's coming in but we need to

00:22:08,929 --> 00:22:12,519
store it somehow

00:22:10,970 --> 00:22:14,859
traditionally I could

00:22:12,519 --> 00:22:20,109
again use the n2m relationship and

00:22:14,859 --> 00:22:23,499
figure that out but sometimes this can

00:22:20,109 --> 00:22:25,919
be pretty tricky especially if let's say

00:22:23,499 --> 00:22:28,499
you want to version these products

00:22:25,919 --> 00:22:31,690
versioning an end-to-end relationship is

00:22:28,499 --> 00:22:33,399
really painful so you want to store as

00:22:31,690 --> 00:22:36,249
much as we can in one table and that's

00:22:33,399 --> 00:22:38,639
that's what H stores for to insert date

00:22:36,249 --> 00:22:41,409
on H store you could do it like this

00:22:38,639 --> 00:22:43,450
it's basically a string comma separated

00:22:41,409 --> 00:22:45,879
values and then we got key value and

00:22:43,450 --> 00:22:51,369
this this little arrow that you probably

00:22:45,879 --> 00:22:52,899
have seen in PHP before and so basically

00:22:51,369 --> 00:22:58,089
we pass it as a string and then cast it

00:22:52,899 --> 00:23:00,249
to the H store data type obviously we

00:22:58,089 --> 00:23:02,679
can filter data or filter items as well

00:23:00,249 --> 00:23:05,559
by referring to the single arrow and

00:23:02,679 --> 00:23:07,809
then specifying the key that we want to

00:23:05,559 --> 00:23:10,659
filter for and pass that as a string

00:23:07,809 --> 00:23:13,239
because obviously as I said before keys

00:23:10,659 --> 00:23:17,289
and values are strings and in in the H

00:23:13,239 --> 00:23:19,119
store in the edge of the data set we get

00:23:17,289 --> 00:23:21,539
both values back but a correct

00:23:19,119 --> 00:23:24,789
as you can see process is not able to

00:23:21,539 --> 00:23:26,409
give the column a real name like cosmas

00:23:24,789 --> 00:23:29,849
doesn't know that the column should be

00:23:26,409 --> 00:23:32,829
color you can use an alias as well if

00:23:29,849 --> 00:23:37,779
you're having issues accessing this this

00:23:32,829 --> 00:23:41,139
information if I access an element that

00:23:37,779 --> 00:23:44,259
is only available in the view of my

00:23:41,139 --> 00:23:46,719
documents I still get all of my elements

00:23:44,259 --> 00:23:48,940
back and the ones where the key is

00:23:46,719 --> 00:23:50,799
missing I'll get a null value which in

00:23:48,940 --> 00:23:52,749
this case is converted to an empty

00:23:50,799 --> 00:23:56,139
string because I'm using the postcodes

00:23:52,749 --> 00:23:58,929
console I can also search for a key in H

00:23:56,139 --> 00:24:00,940
store using the question mark so give me

00:23:58,929 --> 00:24:03,570
all the products where the key weight is

00:24:00,940 --> 00:24:05,950
is available and in the metadata H store

00:24:03,570 --> 00:24:09,509
and it will just give me back the

00:24:05,950 --> 00:24:13,149
product that is matching the criteria I

00:24:09,509 --> 00:24:15,820
can also do a search for a specific set

00:24:13,149 --> 00:24:17,739
of key and value combination using again

00:24:15,820 --> 00:24:20,099
the containment operator so give me all

00:24:17,739 --> 00:24:22,869
the products where color is that red

00:24:20,099 --> 00:24:24,760
which gives me just the one that we have

00:24:22,869 --> 00:24:28,400
in the data store

00:24:24,760 --> 00:24:30,500
similar to the to the previous example

00:24:28,400 --> 00:24:33,550
of the tech now I can figure out all my

00:24:30,500 --> 00:24:37,010
keys that are existent in the H store by

00:24:33,550 --> 00:24:40,670
doing this bit of magic so there is the

00:24:37,010 --> 00:24:43,010
a key function which as the name implies

00:24:40,670 --> 00:24:46,280
gives me back all the keys of an H store

00:24:43,010 --> 00:24:48,110
in form of an array and I used the Una's

00:24:46,280 --> 00:24:51,100
function again to convert the array into

00:24:48,110 --> 00:24:55,250
rows and then I do a select distinct to

00:24:51,100 --> 00:24:57,230
figure out which keys are uniquely in in

00:24:55,250 --> 00:24:59,300
this whole set and I'll get all the keys

00:24:57,230 --> 00:25:01,970
back so this can be interesting for kind

00:24:59,300 --> 00:25:05,530
of drill down search so I figure out

00:25:01,970 --> 00:25:05,530
what what metadata is in there and

00:25:06,310 --> 00:25:10,760
Derrick is asking if this is always a

00:25:08,510 --> 00:25:16,360
full table scan to be honest I have no

00:25:10,760 --> 00:25:20,510
clue that's the closest I can get okay

00:25:16,360 --> 00:25:22,880
again we can deal with indexes gene

00:25:20,510 --> 00:25:27,410
index again so we simply say create an

00:25:22,880 --> 00:25:30,530
index on our metadata column and then

00:25:27,410 --> 00:25:33,320
again if we do the containment search we

00:25:30,530 --> 00:25:36,850
can see that the index is used in the

00:25:33,320 --> 00:25:39,800
search as well to update in datastore

00:25:36,850 --> 00:25:43,850
fairly easy we can override it

00:25:39,800 --> 00:25:46,640
completely completely replace it or we

00:25:43,850 --> 00:25:48,470
could do a kind of partial update using

00:25:46,640 --> 00:25:50,570
the double pipe operator so in this case

00:25:48,470 --> 00:25:54,050
if the key weight is said it would get

00:25:50,570 --> 00:25:57,380
overwritten in the metadata H store if

00:25:54,050 --> 00:25:59,690
it's not there it will be appended if

00:25:57,380 --> 00:26:01,100
you can add items you guessed it we can

00:25:59,690 --> 00:26:03,530
also remove items because that's

00:26:01,100 --> 00:26:06,950
probably what makes sense we use the

00:26:03,530 --> 00:26:09,140
minus operator so in this case we simply

00:26:06,950 --> 00:26:11,630
say remove the key weight from our

00:26:09,140 --> 00:26:15,080
metadata all right the writing operator

00:26:11,630 --> 00:26:19,070
can also be an H store in this case it

00:26:15,080 --> 00:26:21,740
would remove the items which contain the

00:26:19,070 --> 00:26:24,710
combination of keys and values so if

00:26:21,740 --> 00:26:28,670
this combination matches it would be

00:26:24,710 --> 00:26:31,550
removed which is pretty interesting and

00:26:28,670 --> 00:26:35,060
I'll show you in a second why there are

00:26:31,550 --> 00:26:36,980
tons of H store functions as you've seen

00:26:35,060 --> 00:26:38,000
there is an a keys function which may

00:26:36,980 --> 00:26:40,010
gives me all the keys

00:26:38,000 --> 00:26:42,740
there is an eval function which will

00:26:40,010 --> 00:26:44,660
give me all the values I convert H store

00:26:42,740 --> 00:26:49,010
to an array I can convert H door to a

00:26:44,660 --> 00:26:52,550
JSON and have some more fun as well so

00:26:49,010 --> 00:26:54,410
why is H store interesting how many of

00:26:52,550 --> 00:26:56,390
you have implemented auditing in your

00:26:54,410 --> 00:26:59,390
application like figuring out who

00:26:56,390 --> 00:27:02,020
changed what when okay quite a few

00:26:59,390 --> 00:27:06,500
what's that an easy part

00:27:02,020 --> 00:27:08,660
sort of ok so obviously you could try to

00:27:06,500 --> 00:27:12,320
solve this problem on the application

00:27:08,660 --> 00:27:14,300
side which can be a bit tricky or messy

00:27:12,320 --> 00:27:17,060
if you like or you can figure out some

00:27:14,300 --> 00:27:19,490
crazy ways in the database to do so H

00:27:17,060 --> 00:27:21,740
store by itself is pretty cool in this

00:27:19,490 --> 00:27:24,470
case so what we do is we create in table

00:27:21,740 --> 00:27:27,260
audit we have a timestamp for the change

00:27:24,470 --> 00:27:29,840
and then we store the the old value and

00:27:27,260 --> 00:27:31,880
the new value then we add a simple

00:27:29,840 --> 00:27:35,120
trigger which would just populate the

00:27:31,880 --> 00:27:37,970
data by selecting or by converting

00:27:35,120 --> 00:27:41,540
actually the euros into H store elements

00:27:37,970 --> 00:27:43,970
and then we bind the trigger to the

00:27:41,540 --> 00:27:48,710
database or to the database table that

00:27:43,970 --> 00:27:51,800
we want to add it and what this gives us

00:27:48,710 --> 00:27:55,400
is this I can pretty easily figure out

00:27:51,800 --> 00:28:00,350
what changed by using this minus

00:27:55,400 --> 00:28:04,490
operator because as I said before in if

00:28:00,350 --> 00:28:07,310
both of the operands are H stores they

00:28:04,490 --> 00:28:11,780
will remove the matching key value

00:28:07,310 --> 00:28:14,300
combination from both items so it will

00:28:11,780 --> 00:28:16,190
just give me the items that are changed

00:28:14,300 --> 00:28:20,480
like in the first case you see F 1

00:28:16,190 --> 00:28:24,770
change to be F 2 F 2 change to C so this

00:28:20,480 --> 00:28:29,180
is super easy is it okay no reaction

00:28:24,770 --> 00:28:33,050
okay I'll go with that maybe you're just

00:28:29,180 --> 00:28:36,530
confused I don't know anyway so that

00:28:33,050 --> 00:28:42,010
that's pretty cool okay going a bit

00:28:36,530 --> 00:28:45,170
hipster JSON that always gets a laugh

00:28:42,010 --> 00:28:47,480
obviously I can store JSON as a text

00:28:45,170 --> 00:28:50,600
field and probably most of you has done

00:28:47,480 --> 00:28:51,510
have done that in in the past which is

00:28:50,600 --> 00:28:54,570
Oak

00:28:51,510 --> 00:28:56,730
but I mean you can't be really sure that

00:28:54,570 --> 00:28:58,440
this stuff that you stored is really

00:28:56,730 --> 00:29:00,810
JSON right

00:28:58,440 --> 00:29:03,810
so the JSON data type really helps us

00:29:00,810 --> 00:29:06,500
with that there is no RFC for for JSON

00:29:03,810 --> 00:29:11,940
who of you knows the RFC number for this

00:29:06,500 --> 00:29:14,100
stuff no one come on okay it's four for

00:29:11,940 --> 00:29:17,460
six to seven I thought you know that

00:29:14,100 --> 00:29:20,930
stuff anyway so so there's an RC for how

00:29:17,460 --> 00:29:23,670
a JSON object should look like and

00:29:20,930 --> 00:29:25,860
Postgres adheres to that specification

00:29:23,670 --> 00:29:29,580
and just allows to store valid JSON

00:29:25,860 --> 00:29:32,190
objects as I said it it's been available

00:29:29,580 --> 00:29:34,680
as an extension for quite some time it

00:29:32,190 --> 00:29:37,500
came to the core distribution with 9.2

00:29:34,680 --> 00:29:40,320
and it dramatically improved with 9.4

00:29:37,500 --> 00:29:43,200
which I'll cover later on in this talk

00:29:40,320 --> 00:29:45,930
so I don't need any fancy stuff I just

00:29:43,200 --> 00:29:48,450
can say hey we have our table product

00:29:45,930 --> 00:29:52,740
and the metadata part is now JSON and

00:29:48,450 --> 00:29:54,930
that's it inserting stuff is pretty damn

00:29:52,740 --> 00:29:58,620
easy you just have your JSON string add

00:29:54,930 --> 00:30:01,440
it to the database and that's it you can

00:29:58,620 --> 00:30:03,680
add any kind of JSON as long as it's

00:30:01,440 --> 00:30:05,820
valid like in the first case we add

00:30:03,680 --> 00:30:07,650
multiple keys in the second one we have

00:30:05,820 --> 00:30:10,350
just the caller air that's no big deal I

00:30:07,650 --> 00:30:13,500
can also change the color to be an array

00:30:10,350 --> 00:30:15,600
that's that's also possible so you're

00:30:13,500 --> 00:30:18,780
not limited in the structure of the JSON

00:30:15,600 --> 00:30:21,390
as long as it it is as long as it is

00:30:18,780 --> 00:30:23,540
valid JSON it will work if you're

00:30:21,390 --> 00:30:28,500
passing in valid JSON like in this case

00:30:23,540 --> 00:30:30,750
trailing commas Postgres will complain

00:30:28,500 --> 00:30:32,310
and say well this is not valid data i

00:30:30,750 --> 00:30:33,840
can't store it that's pretty cool

00:30:32,310 --> 00:30:38,270
because you can be sure that the stuff

00:30:33,840 --> 00:30:38,270
that is in the database is really JSON

00:30:38,660 --> 00:30:44,550
obviously we can query that stuff we can

00:30:40,770 --> 00:30:46,290
filter it um there is a double arrow

00:30:44,550 --> 00:30:49,200
operator and there's a single arrow

00:30:46,290 --> 00:30:51,410
operator which would just select the

00:30:49,200 --> 00:30:55,200
item so the double arrow one would

00:30:51,410 --> 00:31:00,210
convert whatever we query into a text

00:30:55,200 --> 00:31:02,460
string which gives me the colors that we

00:31:00,210 --> 00:31:04,980
are having in the database as you can

00:31:02,460 --> 00:31:07,860
see the the last product has this array

00:31:04,980 --> 00:31:11,159
so I in my implication would need to

00:31:07,860 --> 00:31:15,899
parse that obviously to prefer the

00:31:11,159 --> 00:31:21,480
process it yes it comes back as a string

00:31:15,899 --> 00:31:25,470
very good very good point Derek I can

00:31:21,480 --> 00:31:29,549
also could be rate irate this is really

00:31:25,470 --> 00:31:32,399
a weird syntax so what we're saying here

00:31:29,549 --> 00:31:36,720
we assume that color is an array and we

00:31:32,399 --> 00:31:39,210
want to create the third item of this

00:31:36,720 --> 00:31:41,700
yeah you're laughing right so this is

00:31:39,210 --> 00:31:45,240
this is not a one based index we're back

00:31:41,700 --> 00:31:49,440
to the zero based index to really

00:31:45,240 --> 00:31:51,120
confuse us so again we get back three

00:31:49,440 --> 00:31:53,399
three rows because we have three

00:31:51,120 --> 00:31:55,889
elements in place and only the last-born

00:31:53,399 --> 00:31:58,200
is a valid array and has a valid element

00:31:55,889 --> 00:32:02,100
at the third place so we get back to

00:31:58,200 --> 00:32:05,779
blue one yeah that's really weird

00:32:02,100 --> 00:32:08,909
anyway again we can use indexes as well

00:32:05,779 --> 00:32:11,639
we can create unique indexes so I can

00:32:08,909 --> 00:32:15,389
say hey I want an unique index on the

00:32:11,639 --> 00:32:18,990
color field of our metadata for whatever

00:32:15,389 --> 00:32:22,230
reason and then if I want to insert

00:32:18,990 --> 00:32:24,470
another product with the color red which

00:32:22,230 --> 00:32:27,389
we already have in in the store

00:32:24,470 --> 00:32:30,179
Postgres will complain and to simply not

00:32:27,389 --> 00:32:31,889
allow that which is really cool I have

00:32:30,179 --> 00:32:34,230
an only use case in that particular way

00:32:31,889 --> 00:32:38,940
but anyway it's really cool it's really

00:32:34,230 --> 00:32:40,950
cool updating JSON well there's just one

00:32:38,940 --> 00:32:43,139
way you have to pass the whole JSON

00:32:40,950 --> 00:32:46,230
object and the database so you can't

00:32:43,139 --> 00:32:47,669
right now do partial updates if I heard

00:32:46,230 --> 00:32:49,470
correctly the post Coast guys are

00:32:47,669 --> 00:32:51,510
working on some crazy ideas of like

00:32:49,470 --> 00:32:53,130
partially updating this JSON stuff but I

00:32:51,510 --> 00:32:55,139
don't think that it's already in there

00:32:53,130 --> 00:32:58,200
so you have to pass the complete JSON

00:32:55,139 --> 00:33:00,539
object there are a bunch of JSON

00:32:58,200 --> 00:33:03,750
functions you could convert an array to

00:33:00,539 --> 00:33:05,880
JSON you can convert a roku json on you

00:33:03,750 --> 00:33:08,190
can figure out the length of an JSON

00:33:05,880 --> 00:33:11,789
array you can grab all the object keys

00:33:08,190 --> 00:33:13,590
and do much more what's really really

00:33:11,789 --> 00:33:16,049
cool is this row to JSON function

00:33:13,590 --> 00:33:18,480
because it allows us to pretty easily

00:33:16,049 --> 00:33:21,330
create what I call in micro J

00:33:18,480 --> 00:33:23,340
in-depth service so this is pretty cool

00:33:21,330 --> 00:33:25,880
for prototyping like in this case we say

00:33:23,340 --> 00:33:28,700
select the row and convert it to JSON

00:33:25,880 --> 00:33:31,290
for the product with the name product C

00:33:28,700 --> 00:33:33,450
which will give me back a valid JSON

00:33:31,290 --> 00:33:35,490
string remember the metadata field

00:33:33,450 --> 00:33:37,470
itself is a JSON string so it just get

00:33:35,490 --> 00:33:40,679
merged into it and we're dealing with a

00:33:37,470 --> 00:33:42,840
perfectly fine JSON result that we can

00:33:40,679 --> 00:33:45,600
easily just send back to the client so

00:33:42,840 --> 00:33:47,520
no need for any fancy code in my

00:33:45,600 --> 00:33:49,470
application to figure out how to convert

00:33:47,520 --> 00:33:52,919
like the road to a JSON object or what

00:33:49,470 --> 00:33:56,120
not in case you don't want to expose

00:33:52,919 --> 00:34:00,120
your exact data structures to the client

00:33:56,120 --> 00:34:03,380
there is a simple neat trick to work

00:34:00,120 --> 00:34:06,179
around that and it's called sub queries

00:34:03,380 --> 00:34:08,879
so in this case we say select this row

00:34:06,179 --> 00:34:10,290
to JSON T from and then sub query and in

00:34:08,879 --> 00:34:13,350
this case we're just selecting name and

00:34:10,290 --> 00:34:15,659
price and we just get this back and

00:34:13,350 --> 00:34:18,030
obviously I could use an alias as well I

00:34:15,659 --> 00:34:19,859
could just change name to title or

00:34:18,030 --> 00:34:22,260
whatnot and the client would not know it

00:34:19,859 --> 00:34:25,379
so this is this is pretty cool I mean

00:34:22,260 --> 00:34:29,609
you could easily write a 5 to 10 line

00:34:25,379 --> 00:34:31,560
code PHP script that would just yeah act

00:34:29,609 --> 00:34:34,260
as a kind of JSON web service and just

00:34:31,560 --> 00:34:39,210
grabs the data from the database so no

00:34:34,260 --> 00:34:45,869
fancy stuff needed on the client-side so

00:34:39,210 --> 00:34:55,109
that was JSON yes deric one more pick

00:34:45,869 --> 00:34:57,119
this one that is a very good coin so the

00:34:55,109 --> 00:34:58,680
question is can I use all the data types

00:34:57,119 --> 00:35:16,080
in there well you see price is not a

00:34:58,680 --> 00:35:19,580
string but price was a column in oh in

00:35:16,080 --> 00:35:22,890
the metadata ok very good point you

00:35:19,580 --> 00:35:28,880
could use types yes JSON is type aware

00:35:22,890 --> 00:35:28,880
so if you use it should be yes yeah

00:35:29,850 --> 00:35:36,840
so let's go back to json b so this was

00:35:34,120 --> 00:35:41,680
added in nine point four specifically

00:35:36,840 --> 00:35:43,900
and the sorry so the B part indicates

00:35:41,680 --> 00:35:45,550
that we're talking about binary well not

00:35:43,900 --> 00:35:48,190
how will you communicate with the

00:35:45,550 --> 00:35:52,240
database but how the database internally

00:35:48,190 --> 00:35:54,760
stores the chasing stuff and the only

00:35:52,240 --> 00:35:56,350
difference is efficiency that's probably

00:35:54,760 --> 00:36:00,700
the best way to put it

00:35:56,350 --> 00:36:02,260
you have to use 9.4 for this from the

00:36:00,700 --> 00:36:04,360
developers point of view it looks

00:36:02,260 --> 00:36:06,460
exactly the same as the json data type

00:36:04,360 --> 00:36:08,650
so we just need to say json B when you

00:36:06,460 --> 00:36:11,290
create a database table and then you can

00:36:08,650 --> 00:36:14,350
insert the documents as before there's

00:36:11,290 --> 00:36:17,410
no real difference for that if you do

00:36:14,350 --> 00:36:19,630
insert a JSON that is not valid as we've

00:36:17,410 --> 00:36:21,580
seen before you still get the same error

00:36:19,630 --> 00:36:22,960
back so from from your point of view

00:36:21,580 --> 00:36:25,360
from the point of view of the developer

00:36:22,960 --> 00:36:29,680
it behaves exactly the same as a JSON

00:36:25,360 --> 00:36:32,590
data type but it does a lot more first

00:36:29,680 --> 00:36:36,910
of all again we can use indexes again

00:36:32,590 --> 00:36:39,790
the gene index which is super efficient

00:36:36,910 --> 00:36:41,260
for searching in our JSON fields so

00:36:39,790 --> 00:36:43,660
again we you can use the containment

00:36:41,260 --> 00:36:47,110
operator to say give me all the products

00:36:43,660 --> 00:36:51,310
where the where it contains a key color

00:36:47,110 --> 00:36:53,980
which is black which returns me

00:36:51,310 --> 00:36:56,500
obviously the right product and if we

00:36:53,980 --> 00:36:59,860
run the explain statement we can see

00:36:56,500 --> 00:37:03,130
that it will use the index as well for

00:36:59,860 --> 00:37:07,900
the skin however this only works if

00:37:03,130 --> 00:37:10,090
color is part of the top-level JSON

00:37:07,900 --> 00:37:12,730
object so it's somewhere down in the

00:37:10,090 --> 00:37:14,530
JSON tree it doesn't work that's

00:37:12,730 --> 00:37:18,640
probably way too complicated to do all

00:37:14,530 --> 00:37:20,350
the mapping anyway we can also look up

00:37:18,640 --> 00:37:22,150
JSON keys by using the question mark

00:37:20,350 --> 00:37:24,790
operator give me all the products where

00:37:22,150 --> 00:37:26,380
the weight key is is part of the

00:37:24,790 --> 00:37:32,380
metadata which will give me the right

00:37:26,380 --> 00:37:35,680
product back and we can can say give me

00:37:32,380 --> 00:37:38,500
all the products where either the key

00:37:35,680 --> 00:37:41,460
weight or color is contained so I can do

00:37:38,500 --> 00:37:41,460
searches there as well

00:37:41,490 --> 00:37:46,410
or if you say the question mark 10%

00:37:44,910 --> 00:37:48,360
operator it says give me all the

00:37:46,410 --> 00:37:51,510
products where the key weight and color

00:37:48,360 --> 00:37:53,220
exists the same time so I can do quite

00:37:51,510 --> 00:37:54,690
some searches in there

00:37:53,220 --> 00:38:00,690
so what's the difference between Jason

00:37:54,690 --> 00:38:02,310
and Jason B well obviously the B part so

00:38:00,690 --> 00:38:05,160
Jason B is really good for complex

00:38:02,310 --> 00:38:06,630
operations as you can see you can you

00:38:05,160 --> 00:38:10,170
can use this indexing part which will

00:38:06,630 --> 00:38:13,050
really speed up operations Jason B does

00:38:10,170 --> 00:38:15,240
need slightly more disk space than Jason

00:38:13,050 --> 00:38:19,470
which shouldn't be a problem these days

00:38:15,240 --> 00:38:21,900
but it's probably good to mention if you

00:38:19,470 --> 00:38:24,360
just want to use Jason for storage you

00:38:21,900 --> 00:38:26,880
use the JSON data type because obviously

00:38:24,360 --> 00:38:28,800
the Jason B part has a kind of

00:38:26,880 --> 00:38:31,200
conversation going on I mean you take

00:38:28,800 --> 00:38:32,880
the JSON stuff that's coming in and you

00:38:31,200 --> 00:38:35,390
have to convert it to binary so there's

00:38:32,880 --> 00:38:38,790
a little overhead added to it obviously

00:38:35,390 --> 00:38:40,950
and depending on the operations that you

00:38:38,790 --> 00:38:45,750
do it it can be you can affect the

00:38:40,950 --> 00:38:49,440
performance pretty much and if you want

00:38:45,750 --> 00:38:52,050
to keep the original data structure that

00:38:49,440 --> 00:38:56,430
you sent to Postgres you should also or

00:38:52,050 --> 00:38:58,830
you have to use JSON so the JSON data

00:38:56,430 --> 00:39:01,380
type will store the stuff that you send

00:38:58,830 --> 00:39:03,570
to it one on one one to one

00:39:01,380 --> 00:39:06,870
while the Jason B one will you have to

00:39:03,570 --> 00:39:08,910
convert it and you have no idea what the

00:39:06,870 --> 00:39:12,660
stuff that you sent previously was all

00:39:08,910 --> 00:39:15,230
about in front of fact because Derek is

00:39:12,660 --> 00:39:18,660
over here there are a couple of

00:39:15,230 --> 00:39:22,980
implementations which emulate on

00:39:18,660 --> 00:39:24,540
top of Postgres for whatever reason so

00:39:22,980 --> 00:39:26,790
there is an implementation called tour

00:39:24,540 --> 00:39:29,670
ODB there is like and there is Mon

00:39:26,790 --> 00:39:32,070
grass which are all kind of applications

00:39:29,670 --> 00:39:34,350
that sit before Posterous and emulate

00:39:32,070 --> 00:39:36,270
MongoDB like they speak the same

00:39:34,350 --> 00:39:38,070
protocol as so your application

00:39:36,270 --> 00:39:40,290
doesn't really know that it's not

00:39:38,070 --> 00:39:43,020
and then they use the JSON data types to

00:39:40,290 --> 00:39:45,450
store that stuff on Postgres so if you

00:39:43,020 --> 00:39:48,740
want to experiment with that and annoy

00:39:45,450 --> 00:39:52,610
Derek you can use these kinds of things

00:39:48,740 --> 00:39:54,030
anyway if you're more the enterprise

00:39:52,610 --> 00:39:55,920
developer you

00:39:54,030 --> 00:39:59,750
probably think JSON is way too hipster

00:39:55,920 --> 00:39:59,750
and then you can go the XML route

00:40:01,190 --> 00:40:06,090
basically the same as JSON you could

00:40:03,900 --> 00:40:09,120
store XML in a text field for whatever

00:40:06,090 --> 00:40:13,260
reason which we probably have done over

00:40:09,120 --> 00:40:15,960
the last last years the J's the the XML

00:40:13,260 --> 00:40:17,760
data type does a bit more it will check

00:40:15,960 --> 00:40:21,210
if the XML is well-formed

00:40:17,760 --> 00:40:24,300
it doesn't do it TDD a DTD check or and

00:40:21,210 --> 00:40:28,010
it does not do an XML schema check it

00:40:24,300 --> 00:40:32,900
simply checks if the XML looks

00:40:28,010 --> 00:40:35,190
well-formed ish XML is part of the core

00:40:32,900 --> 00:40:38,010
which basically means you can just use

00:40:35,190 --> 00:40:41,430
the data type as is just say hey we got

00:40:38,010 --> 00:40:44,510
an we got a column name content which is

00:40:41,430 --> 00:40:48,900
part of which which has the datatype XML

00:40:44,510 --> 00:40:52,550
so I'm not sure about you but we have

00:40:48,900 --> 00:40:56,400
sometimes customers from the enterprise

00:40:52,550 --> 00:40:58,770
field which come up with some crazy

00:40:56,400 --> 00:41:01,080
solutions when it comes to application

00:40:58,770 --> 00:41:03,810
talk to each other like one of them

00:41:01,080 --> 00:41:07,520
invented the famous XML over FTP

00:41:03,810 --> 00:41:10,350
protocol which is as crazy as it sounds

00:41:07,520 --> 00:41:12,270
so our application had to connect an FTP

00:41:10,350 --> 00:41:15,810
server download the XML stuff and then

00:41:12,270 --> 00:41:17,820
process it and like we stored it using

00:41:15,810 --> 00:41:19,410
this in Postgres so we did not sorry on

00:41:17,820 --> 00:41:21,840
disk but just in in the post quest

00:41:19,410 --> 00:41:25,050
database and I said you can store any

00:41:21,840 --> 00:41:28,020
kind of XML doesn't really matter you

00:41:25,050 --> 00:41:30,390
can have attributes whatnot it just

00:41:28,020 --> 00:41:33,780
needs to be well-formed if it's not well

00:41:30,390 --> 00:41:36,480
formed like in this case we are missing

00:41:33,780 --> 00:41:38,970
an enclosing open tag

00:41:36,480 --> 00:41:40,800
Postgres will complain and say hey this

00:41:38,970 --> 00:41:45,540
is not well formed XML

00:41:40,800 --> 00:41:48,870
I can't store it obviously we can query

00:41:45,540 --> 00:41:51,420
XML unfortunately there is just one way

00:41:48,870 --> 00:41:59,310
to do it and we probably all hated XPath

00:41:51,420 --> 00:42:01,020
oh okay great yeah so you can and you

00:41:59,310 --> 00:42:03,290
can use any kind of expert expression in

00:42:01,020 --> 00:42:06,520
there in this case we want to figure out

00:42:03,290 --> 00:42:10,270
the product nodes in the order and

00:42:06,520 --> 00:42:12,760
wrap the the ID attribute which will

00:42:10,270 --> 00:42:16,390
give us this back we get a a bunch of

00:42:12,760 --> 00:42:19,300
arrays back for for each for each set of

00:42:16,390 --> 00:42:21,490
XML that we are found and you probably

00:42:19,300 --> 00:42:22,990
do remember the teched-out example from

00:42:21,490 --> 00:42:26,350
the beginning like this is an array as

00:42:22,990 --> 00:42:28,320
you can see with the curly braces we can

00:42:26,350 --> 00:42:32,010
do some really fancy stuff with that

00:42:28,320 --> 00:42:34,210
something like this hold on I explained

00:42:32,010 --> 00:42:37,420
don't run away

00:42:34,210 --> 00:42:40,360
so what we do here is again we have the

00:42:37,420 --> 00:42:42,010
expand expression which gives us all the

00:42:40,360 --> 00:42:46,210
IDS of all the products that were

00:42:42,010 --> 00:42:48,730
ordered we get an array back we unless

00:42:46,210 --> 00:42:51,340
this array like we we convert it into

00:42:48,730 --> 00:42:53,710
sequel rows then again we group them buy

00:42:51,340 --> 00:42:56,620
it buy it buy the product ID and then we

00:42:53,710 --> 00:42:59,260
count them which will gives us a nice

00:42:56,620 --> 00:43:01,180
little statistic about how often a

00:42:59,260 --> 00:43:04,000
product was ordered in all of these

00:43:01,180 --> 00:43:06,520
xml's now this is pretty neat and pretty

00:43:04,000 --> 00:43:08,440
simple think about how to do how to

00:43:06,520 --> 00:43:10,480
solve that if the XML was stored on disk

00:43:08,440 --> 00:43:15,220
like you need to scan the whole

00:43:10,480 --> 00:43:17,350
directory open the XML s parse them do

00:43:15,220 --> 00:43:20,740
the XPath do the calculations and

00:43:17,350 --> 00:43:23,260
whatnot this is literally a one-liner of

00:43:20,740 --> 00:43:27,430
a secret code which is really amazing at

00:43:23,260 --> 00:43:30,640
least in my point of view we can also

00:43:27,430 --> 00:43:33,040
figure out or use the the XPath

00:43:30,640 --> 00:43:35,620
expression in in the where clause where

00:43:33,040 --> 00:43:38,290
you can say hey show me all the imports

00:43:35,620 --> 00:43:40,590
where a certain XPath exists so that's

00:43:38,290 --> 00:43:43,180
what the expert exists function is for

00:43:40,590 --> 00:43:45,730
again provide a valid XPath expression

00:43:43,180 --> 00:43:48,130
and then we get the the imports back

00:43:45,730 --> 00:43:50,410
that match so if you want to do a quick

00:43:48,130 --> 00:43:55,060
search on on a certain product you can

00:43:50,410 --> 00:43:57,250
do so pretty easily if you remember the

00:43:55,060 --> 00:44:00,370
micro JSON web service I showed you

00:43:57,250 --> 00:44:03,730
before you can also do the more

00:44:00,370 --> 00:44:06,520
enterprise version of that using the

00:44:03,730 --> 00:44:09,760
query to XML function you simply pass in

00:44:06,520 --> 00:44:13,090
a select statement and a few flags and

00:44:09,760 --> 00:44:16,750
then Postgres will spit out a bit of X

00:44:13,090 --> 00:44:19,360
XML code which you then either can

00:44:16,750 --> 00:44:20,059
convert using XSLT to another structure

00:44:19,360 --> 00:44:22,999
or

00:44:20,059 --> 00:44:25,279
just echo back to the client as well so

00:44:22,999 --> 00:44:28,130
again pretty easy pretty simple to write

00:44:25,279 --> 00:44:30,619
just a simple web servers on for testing

00:44:28,130 --> 00:44:31,279
purposes we have a bunch of XML

00:44:30,619 --> 00:44:34,459
functions

00:44:31,279 --> 00:44:37,069
there's XML content to concatenate XML

00:44:34,459 --> 00:44:41,119
strings we got forced to produce the

00:44:37,069 --> 00:44:42,999
sequence of elements an aggregation we

00:44:41,119 --> 00:44:47,390
can figure out if the XML is well-formed

00:44:42,999 --> 00:44:49,549
we can as we have seen create XML from a

00:44:47,390 --> 00:44:52,579
query function we have expert and a

00:44:49,549 --> 00:45:00,019
bunch of others as well so that's it for

00:44:52,579 --> 00:45:03,349
the datatypes now no sicko in most cases

00:45:00,019 --> 00:45:04,969
means a lot of data obviously it's not

00:45:03,349 --> 00:45:07,849
just having no structure or whatnot it

00:45:04,969 --> 00:45:09,259
means dealing with a bunch of data which

00:45:07,849 --> 00:45:13,489
sometimes it's really hard to deal with

00:45:09,259 --> 00:45:16,339
in just one table because performance

00:45:13,489 --> 00:45:18,890
obviously so you can partition your

00:45:16,339 --> 00:45:21,380
database tables as well and like

00:45:18,890 --> 00:45:24,709
splitting one table up into multiple

00:45:21,380 --> 00:45:26,539
physical ones just to increase the query

00:45:24,709 --> 00:45:29,329
performance it's also pretty easily done

00:45:26,539 --> 00:45:33,469
in in Postgres you simply create a a

00:45:29,329 --> 00:45:37,400
master table in this case table country

00:45:33,469 --> 00:45:40,369
containing all the sales stats and then

00:45:37,400 --> 00:45:43,849
we create like child tables where we

00:45:40,369 --> 00:45:47,150
simply say on the child table sales

00:45:43,849 --> 00:45:50,239
stats in 2012 and 2011 inherit or a

00:45:47,150 --> 00:45:54,410
master table and we need to add this

00:45:50,239 --> 00:45:56,660
check this this check instructions so

00:45:54,410 --> 00:46:01,130
that Postgres will know where to look

00:45:56,660 --> 00:46:03,949
when a query contains year 2012 or year

00:46:01,130 --> 00:46:06,709
2011 so postcodes in this case will

00:46:03,949 --> 00:46:09,109
exactly know which table is the target

00:46:06,709 --> 00:46:11,539
table for a specific search because in

00:46:09,109 --> 00:46:13,099
our application we just interact with

00:46:11,539 --> 00:46:15,199
the sales stats table with the master

00:46:13,099 --> 00:46:17,469
table so our application has no clue

00:46:15,199 --> 00:46:21,529
that we have some child tables in place

00:46:17,469 --> 00:46:23,989
and we add a little fancy trigger which

00:46:21,529 --> 00:46:25,429
doesn't really match it's really weird

00:46:23,989 --> 00:46:27,769
looking but it's really easy to

00:46:25,429 --> 00:46:29,959
understand so first of all we figure out

00:46:27,769 --> 00:46:32,869
what year it is what's what's the

00:46:29,959 --> 00:46:33,860
current year create a table name from

00:46:32,869 --> 00:46:35,540
that year

00:46:33,860 --> 00:46:38,690
and then the bottom four lines just

00:46:35,540 --> 00:46:41,390
figure out if this table exists in the

00:46:38,690 --> 00:46:44,630
Postgres catalog of tables if it does

00:46:41,390 --> 00:46:46,760
not exist we simply create it as you've

00:46:44,630 --> 00:46:52,820
just seen and then we just insert the

00:46:46,760 --> 00:46:54,470
data into that specific table so this is

00:46:52,820 --> 00:46:57,380
really cool because our application just

00:46:54,470 --> 00:46:59,150
interacts with one database table with

00:46:57,380 --> 00:47:02,180
the master table and process internally

00:46:59,150 --> 00:47:04,520
like redirects the reads and writes to

00:47:02,180 --> 00:47:08,630
the correct tables whatever correct

00:47:04,520 --> 00:47:11,660
means however this only works if we pass

00:47:08,630 --> 00:47:14,300
the year as a filter element because

00:47:11,660 --> 00:47:16,910
then Postgres exactly knows which table

00:47:14,300 --> 00:47:19,070
to search in if you omit the year

00:47:16,910 --> 00:47:23,590
Postgres would search across all the

00:47:19,070 --> 00:47:25,970
tables which can take quite some time

00:47:23,590 --> 00:47:27,920
other than that oh yeah we have to

00:47:25,970 --> 00:47:30,110
register the trigger as well to make

00:47:27,920 --> 00:47:33,140
things work other than that

00:47:30,110 --> 00:47:36,770
Hospice is pretty awesome it has way

00:47:33,140 --> 00:47:39,100
more stuff to offer the damn coolest

00:47:36,770 --> 00:47:43,190
thing ever are the foreign data wrappers

00:47:39,100 --> 00:47:46,900
which basically means I can expose any

00:47:43,190 --> 00:47:49,130
kind of third party data store as a

00:47:46,900 --> 00:47:53,420
Postgres table in my pasta quest

00:47:49,130 --> 00:47:56,600
database that sounds weird but it

00:47:53,420 --> 00:47:59,450
basically means I could expose a sub web

00:47:56,600 --> 00:48:03,200
service another possible instance a

00:47:59,450 --> 00:48:05,510
Redis server or whatnot as a post quest

00:48:03,200 --> 00:48:08,330
table in my local database and use that

00:48:05,510 --> 00:48:10,340
to join my local data with it and do

00:48:08,330 --> 00:48:12,650
some fancy stuff so that's that's really

00:48:10,340 --> 00:48:15,050
cool in addition to that we have

00:48:12,650 --> 00:48:17,390
arranged data type to store ranges in

00:48:15,050 --> 00:48:20,390
one column which is also pretty neat for

00:48:17,390 --> 00:48:22,040
for searches yeah we've got stuff like

00:48:20,390 --> 00:48:24,310
materialized view conditional indexes

00:48:22,040 --> 00:48:26,750
and a bunch of other cool things

00:48:24,310 --> 00:48:28,760
Postgres by itself is a pretty large

00:48:26,750 --> 00:48:30,380
ecosystem as I said it's it's been

00:48:28,760 --> 00:48:32,630
around for a couple of years we have

00:48:30,380 --> 00:48:35,170
tons of backup and recovery solutions

00:48:32,630 --> 00:48:37,310
clustering solutions replication stuff

00:48:35,170 --> 00:48:41,330
administrative administrative tools

00:48:37,310 --> 00:48:43,910
whatnot so it's a proven technology and

00:48:41,330 --> 00:48:45,170
they're a bunch of little Postgres users

00:48:43,910 --> 00:48:47,360
out there

00:48:45,170 --> 00:48:50,930
companies like Instagram reddit

00:48:47,360 --> 00:48:55,810
Skype Etsy and the like so you should

00:48:50,930 --> 00:48:55,810
try it out thank you

00:49:03,309 --> 00:49:08,989
and before we go into the question mode

00:49:05,719 --> 00:49:11,689
just one final note please go and join

00:49:08,989 --> 00:49:14,329
in rate this talk I'm pretty curious for

00:49:11,689 --> 00:49:20,979
feedback so that's it from my side any

00:49:14,329 --> 00:49:20,979
questions yes one in the front

00:49:21,099 --> 00:49:28,669
hi I have a question about two data

00:49:24,919 --> 00:49:32,449
types the H store and JSON yes those two

00:49:28,669 --> 00:49:34,489
looks for me very similar and JSON seems

00:49:32,449 --> 00:49:36,919
to have all the features the H store has

00:49:34,489 --> 00:49:39,919
so is there an advantage of using H

00:49:36,919 --> 00:49:41,809
store over Jason that is a very good

00:49:39,919 --> 00:49:43,999
question and I missed this point in my

00:49:41,809 --> 00:49:49,189
presentation so thanks for asking

00:49:43,999 --> 00:49:51,319
so JSON basically is just a simple like

00:49:49,189 --> 00:49:53,599
one level store like you have key and

00:49:51,319 --> 00:49:56,089
value and the value is just a string if

00:49:53,599 --> 00:49:58,609
you need like a complex structure you

00:49:56,089 --> 00:50:01,609
have to use JSON like the key can't be

00:49:58,609 --> 00:50:04,399
another H store or whatnot so it has to

00:50:01,609 --> 00:50:08,679
be a simple string so that's probably

00:50:04,399 --> 00:50:22,279
the biggest difference thank you okay

00:50:08,679 --> 00:50:22,789
anyone else go ahead no questions that's

00:50:22,279 --> 00:50:29,869
great

00:50:22,789 --> 00:50:32,089
oh there's one I have a question what

00:50:29,869 --> 00:50:37,609
about support for things like rice

00:50:32,089 --> 00:50:39,109
arrays in PHP mappings so I mean how to

00:50:37,609 --> 00:50:41,959
deal with the data when it comes back

00:50:39,109 --> 00:50:44,089
yeah okay so that pretty much depends on

00:50:41,959 --> 00:50:47,299
the like data access library that you're

00:50:44,089 --> 00:50:50,689
using if I recall correctly doctrine has

00:50:47,299 --> 00:50:53,089
support for arrays maybe JSON but I'm

00:50:50,689 --> 00:50:55,149
not really sure so this really depends

00:50:53,089 --> 00:50:57,559
on on your library that you're using

00:50:55,149 --> 00:50:59,539
like in most cases this stuff comes back

00:50:57,559 --> 00:51:03,909
as a string and you then have to

00:50:59,539 --> 00:51:03,909
manually convert it back and forth

00:51:07,569 --> 00:51:20,470
hey yawen sorry how does the performance

00:51:10,579 --> 00:51:20,470
compare to say manga depends who you ask

00:51:21,430 --> 00:51:27,619
there are some Postgres core

00:51:24,530 --> 00:51:29,420
contributors who did a comparison and

00:51:27,619 --> 00:51:32,119
they say that

00:51:29,420 --> 00:51:35,599
Postgres is more performant than

00:51:32,119 --> 00:51:37,460
it probably really depends on the use

00:51:35,599 --> 00:51:38,869
case and what you want to achieve and as

00:51:37,460 --> 00:51:40,640
always you have to measure it for

00:51:38,869 --> 00:51:43,280
yourself that's probably the most

00:51:40,640 --> 00:51:45,380
accurate answer I can give so it was

00:51:43,280 --> 00:51:46,400
always fast enough for us but in most

00:51:45,380 --> 00:51:48,230
cases we are dealing with small

00:51:46,400 --> 00:51:54,309
applications and not like the big data

00:51:48,230 --> 00:52:03,049
stuff okay that was an easy answer

00:51:54,309 --> 00:52:05,030
anyone else what are we all right and is

00:52:03,049 --> 00:52:07,010
it practicable to store like thousands

00:52:05,030 --> 00:52:09,230
of key values in an H store it is it

00:52:07,010 --> 00:52:12,829
quickly come to a point where it's

00:52:09,230 --> 00:52:14,750
better to be using a separate table it

00:52:12,829 --> 00:52:16,700
probably also depends on what you're

00:52:14,750 --> 00:52:18,980
doing like if you're just storing it

00:52:16,700 --> 00:52:22,369
should be a no-brainer to do that if you

00:52:18,980 --> 00:52:24,290
do like complex searches I have no idea

00:52:22,369 --> 00:52:28,220
- probably doomed but anyway since it's

00:52:24,290 --> 00:52:30,500
a binary store it's actually pretty good

00:52:28,220 --> 00:52:32,240
there excess okay so it's a binary store

00:52:30,500 --> 00:52:35,480
so it should be pretty much optimized

00:52:32,240 --> 00:52:38,569
for that at least compared to the pure

00:52:35,480 --> 00:52:40,549
to the raw JSON one which I forgot to

00:52:38,569 --> 00:52:42,710
mention yeah so the the big difference

00:52:40,549 --> 00:52:44,839
between the raw Jason 1 and Jason B is

00:52:42,710 --> 00:52:47,540
that the Jason one is actually parse

00:52:44,839 --> 00:52:49,700
that each time when you access the D

00:52:47,540 --> 00:52:52,520
column like it's parsed by the v8 engine

00:52:49,700 --> 00:52:54,710
which adds a certain overhead so in that

00:52:52,520 --> 00:52:57,500
case it would really be a performance

00:52:54,710 --> 00:53:04,700
penalty but H store yeah I would suppose

00:52:57,500 --> 00:53:07,520
that it's just fast enough thanks one

00:53:04,700 --> 00:53:12,369
more there's one more one more free no

00:53:07,520 --> 00:53:12,369

YouTube URL: https://www.youtube.com/watch?v=os1-plBMaKU


