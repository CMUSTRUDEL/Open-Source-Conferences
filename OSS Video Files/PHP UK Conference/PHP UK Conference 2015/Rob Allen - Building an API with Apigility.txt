Title: Rob Allen - Building an API with Apigility
Publication date: 2015-04-02
Playlist: PHP UK Conference 2015
Description: 
	Apigility is a project that allows you to easily create a web service without having to worry about the nitty-gritty details. Which details? Well, Apigility will handle content negotiation, error handling, versioning and authentication for you, allowing you to concentrate on your application. In this introductory talk we look at what Apigility is and how to create a simple REST API application, showing how to start using Apigility and how to build a good API using this tool.

http://akrabat.com/wp-content/uploads/2015-02-20-phpuk-apigility.pdf
Captions: 
	00:00:05,400 --> 00:00:11,700
my name's Rob Allen I do stuff with some

00:00:07,830 --> 00:00:13,020
framework - I do lots of several stuff

00:00:11,700 --> 00:00:15,660
I'm one known for doing some framework

00:00:13,020 --> 00:00:18,779
stuff and I've started moving into API

00:00:15,660 --> 00:00:23,160
building I think the industry is moving

00:00:18,779 --> 00:00:25,890
that way as a web industry as a web

00:00:23,160 --> 00:00:27,600
application builders we are slowly

00:00:25,890 --> 00:00:29,699
moving to the situation where we are

00:00:27,600 --> 00:00:31,500
building front-end web sites and put in

00:00:29,699 --> 00:00:34,650
all our business logic into a separate

00:00:31,500 --> 00:00:36,540
API and one of the reasons we are doing

00:00:34,650 --> 00:00:40,350
this is so we are targeting different

00:00:36,540 --> 00:00:42,750
clients now it's not just a website we

00:00:40,350 --> 00:00:45,660
have the web sites we have the mobile

00:00:42,750 --> 00:00:47,610
apps we have other clients who are

00:00:45,660 --> 00:00:48,390
getting at our beta I need you to do

00:00:47,610 --> 00:00:50,790
something with it

00:00:48,390 --> 00:00:53,100
or if we're really lucky we have other

00:00:50,790 --> 00:00:56,370
clients are pushing data into our system

00:00:53,100 --> 00:00:58,170
so take Twitter for instance they get

00:00:56,370 --> 00:01:01,620
their data from third parties pushing

00:00:58,170 --> 00:01:03,770
data into their system and api's are

00:01:01,620 --> 00:01:08,310
good for this this is what api's are for

00:01:03,770 --> 00:01:10,289
so I think we can't be building more

00:01:08,310 --> 00:01:12,929
them who here is build an API so at the

00:01:10,289 --> 00:01:13,410
moment we have to do this because of the

00:01:12,929 --> 00:01:15,690
bright lights

00:01:13,410 --> 00:01:17,310
yeah good few of you half maybe

00:01:15,690 --> 00:01:18,990
something like that and the other half

00:01:17,310 --> 00:01:20,970
of you will be building api's within

00:01:18,990 --> 00:01:25,950
next three years that's where we're

00:01:20,970 --> 00:01:29,910
going however if this works

00:01:25,950 --> 00:01:32,190
api's are hard they're not very easy to

00:01:29,910 --> 00:01:34,380
write well and the reason they're not

00:01:32,190 --> 00:01:36,209
very well hot so they're not very easy

00:01:34,380 --> 00:01:38,610
to write well is that there's lots of

00:01:36,209 --> 00:01:40,319
things to think about with an API like

00:01:38,610 --> 00:01:44,490
there are with websites there are lots

00:01:40,319 --> 00:01:48,270
of features things that you need to

00:01:44,490 --> 00:01:51,300
build into your API that are relatively

00:01:48,270 --> 00:01:53,640
boring the bits that nobody really wants

00:01:51,300 --> 00:01:57,360
to write but they have to be written if

00:01:53,640 --> 00:01:59,849
you're going to have a decent API we

00:01:57,360 --> 00:02:02,250
work on the web so we took in HTTP we

00:01:59,849 --> 00:02:04,679
have things like content negotiation we

00:02:02,250 --> 00:02:07,560
have things like method negotiation we

00:02:04,679 --> 00:02:09,810
have to worry about validation we have

00:02:07,560 --> 00:02:12,270
to worry about versioning authentication

00:02:09,810 --> 00:02:14,790
authorization these are all key features

00:02:12,270 --> 00:02:17,840
of your API that aren't very interesting

00:02:14,790 --> 00:02:17,840
- right

00:02:18,599 --> 00:02:24,790
personal pet peeve of mine is Error

00:02:20,980 --> 00:02:28,030
reporting the amount of api's I consume

00:02:24,790 --> 00:02:31,359
that cannot report error sensibly drives

00:02:28,030 --> 00:02:35,769
me up the wall it's hard to get error

00:02:31,359 --> 00:02:38,890
reporting right and most people don't do

00:02:35,769 --> 00:02:41,230
it so if you're writing an API and at

00:02:38,890 --> 00:02:43,329
least off you are make sure you do good

00:02:41,230 --> 00:02:46,500
error reporting you will make me happy

00:02:43,329 --> 00:02:46,500
that's important

00:02:47,879 --> 00:02:54,340
API scum certainly in terms of web api

00:02:50,829 --> 00:02:57,669
is at least in two major groups we have

00:02:54,340 --> 00:03:03,220
our pc type api so we have restful api

00:02:57,669 --> 00:03:06,040
s-- who here writes RPC api a procedural

00:03:03,220 --> 00:03:08,799
call nobody's prepared to admit it our

00:03:06,040 --> 00:03:11,970
one person I reckon more than more of

00:03:08,799 --> 00:03:11,970
you do that than you realize

00:03:12,120 --> 00:03:19,269
think about an RPC type API is that

00:03:16,379 --> 00:03:22,000
you're running code on the server and

00:03:19,269 --> 00:03:24,310
you're treating it as you are running a

00:03:22,000 --> 00:03:28,269
method of running a function so remote a

00:03:24,310 --> 00:03:31,900
procedural call typical endpoints are

00:03:28,269 --> 00:03:35,319
more verb like send email get current

00:03:31,900 --> 00:03:40,299
time that's the characteristic of an RPC

00:03:35,319 --> 00:03:42,280
type API one of the more classic ones is

00:03:40,299 --> 00:03:46,530
login systems if you're going to log in

00:03:42,280 --> 00:03:49,449
are off to for instance is very RPC like

00:03:46,530 --> 00:03:52,629
and then we have restful api so Leslie

00:03:49,449 --> 00:03:55,329
pies are the cool ones they're the ones

00:03:52,629 --> 00:03:59,709
everyone writes because they work really

00:03:55,329 --> 00:04:04,049
well with HTTP they leverage HTTP and

00:03:59,709 --> 00:04:07,290
the architecture of HTTP very very well

00:04:04,049 --> 00:04:12,370
specifically through two main reasons

00:04:07,290 --> 00:04:15,370
firstly HTTP verbs so we have resources

00:04:12,370 --> 00:04:19,299
on our server and we interact with them

00:04:15,370 --> 00:04:23,320
via HTTP verbs we have post we have get

00:04:19,299 --> 00:04:26,729
we have patch etc so we are describing

00:04:23,320 --> 00:04:29,529
the action we want to take on our

00:04:26,729 --> 00:04:33,939
resource via the HTTP

00:04:29,529 --> 00:04:35,439
he built in system the other thing about

00:04:33,939 --> 00:04:36,299
restful api is is that they are

00:04:35,439 --> 00:04:42,209
stateless

00:04:36,299 --> 00:04:44,619
there is no such thing as a session

00:04:42,209 --> 00:04:48,809
every single thing that you send into

00:04:44,619 --> 00:04:51,819
your servers endpoint via a restful call

00:04:48,809 --> 00:04:53,679
has to be sent in that call you cannot

00:04:51,819 --> 00:04:56,319
depend on anything having been done

00:04:53,679 --> 00:04:58,899
previously or anything that will be done

00:04:56,319 --> 00:05:02,649
in the future that's a key feature of a

00:04:58,899 --> 00:05:05,469
restful api and the side effect of that

00:05:02,649 --> 00:05:10,229
is that you can now cache things well

00:05:05,469 --> 00:05:13,479
you can scale using the built-in HTTP

00:05:10,229 --> 00:05:15,669
infrastructure this is why people like

00:05:13,479 --> 00:05:16,269
at restful api s-- but they don't work

00:05:15,669 --> 00:05:19,299
for everyone

00:05:16,269 --> 00:05:23,709
so our pc still exists and you will

00:05:19,299 --> 00:05:28,449
still write some RPC stuff so that sort

00:05:23,709 --> 00:05:30,189
of side note out the way let's talk

00:05:28,449 --> 00:05:32,229
about a fidelity which is what we're

00:05:30,189 --> 00:05:36,459
here for and it is pronounced Apogee

00:05:32,229 --> 00:05:40,479
leti it's a pun on agility it is not API

00:05:36,459 --> 00:05:44,409
agility Apogee little it's an

00:05:40,479 --> 00:05:48,029
opinionated API builder so the point of

00:05:44,409 --> 00:05:52,149
the tool is to help you write a good API

00:05:48,029 --> 00:05:53,919
without having to do the boring bits so

00:05:52,149 --> 00:05:56,499
from their web page simplify the

00:05:53,919 --> 00:05:58,709
creation and maintenance of useful easy

00:05:56,499 --> 00:06:01,329
to consume a well-structured

00:05:58,709 --> 00:06:06,159
well-structured application programming

00:06:01,329 --> 00:06:09,989
interfaces API the key thing is well

00:06:06,159 --> 00:06:13,329
structured in the same way that

00:06:09,989 --> 00:06:15,849
four-step frameworks provide structure

00:06:13,329 --> 00:06:19,689
to web applications app agility provides

00:06:15,849 --> 00:06:21,789
structure to api's it is API centric it

00:06:19,689 --> 00:06:26,169
provides the structure for you it does

00:06:21,789 --> 00:06:28,839
all the boilerplate there are two key

00:06:26,169 --> 00:06:31,059
components to activity there is the

00:06:28,839 --> 00:06:33,009
administration system that you run in

00:06:31,059 --> 00:06:36,039
development mode that enables you to

00:06:33,009 --> 00:06:39,639
configure your API and to build your API

00:06:36,039 --> 00:06:42,790
it is a web-based system and then there

00:06:39,639 --> 00:06:46,430
is a runtime api engine that

00:06:42,790 --> 00:06:50,990
execute and run sure API there are two

00:06:46,430 --> 00:06:52,760
half to the activity system obviously it

00:06:50,990 --> 00:06:55,010
is written in PHP because we're at page

00:06:52,760 --> 00:06:57,650
four UK it's built on the same framework

00:06:55,010 --> 00:06:59,690
- you don't need to know a lot about

00:06:57,650 --> 00:07:01,640
some framework - in order to choose a

00:06:59,690 --> 00:07:08,330
facility it is just the underlying

00:07:01,640 --> 00:07:09,560
components to the system so how would

00:07:08,330 --> 00:07:12,110
you get started for something like I've

00:07:09,560 --> 00:07:14,270
Jill T it uses composer we're all in

00:07:12,110 --> 00:07:18,410
your digital yesterday or if not who

00:07:14,270 --> 00:07:20,480
he's not using composer good that is a

00:07:18,410 --> 00:07:23,840
great answer everyone uses composer now

00:07:20,480 --> 00:07:26,210
it is the way to do things in 2015 if

00:07:23,840 --> 00:07:28,520
you're in PHP world so you install using

00:07:26,210 --> 00:07:31,400
composers crate project we've now got a

00:07:28,520 --> 00:07:33,110
project called music we turn on

00:07:31,400 --> 00:07:36,050
development mode that's the

00:07:33,110 --> 00:07:38,690
administration interface it is not

00:07:36,050 --> 00:07:40,760
enabled by default so you have to turn

00:07:38,690 --> 00:07:42,890
it on you do not run it on your life

00:07:40,760 --> 00:07:44,900
service because otherwise people could

00:07:42,890 --> 00:07:46,640
go and change your API so you write

00:07:44,900 --> 00:07:49,630
literally because we're running it

00:07:46,640 --> 00:07:52,580
locally we can use a built-in PHP server

00:07:49,630 --> 00:07:56,800
because we're all running PHP 5.4 or

00:07:52,580 --> 00:07:59,510
higher aren't we yes we are an

00:07:56,800 --> 00:08:01,970
opportunity will actually run a 5.3 but

00:07:59,510 --> 00:08:05,210
don't tell anyone 5.4 or above

00:08:01,970 --> 00:08:06,560
don't run end-of-life and you get an

00:08:05,210 --> 00:08:06,860
admin system that looks something like

00:08:06,560 --> 00:08:12,890
that

00:08:06,860 --> 00:08:14,300
it's very pretty right so let's show you

00:08:12,890 --> 00:08:17,060
how it looks in practice

00:08:14,300 --> 00:08:19,580
so let's write a hello world for an API

00:08:17,060 --> 00:08:21,670
so does hello world look like for an API

00:08:19,580 --> 00:08:24,140
system what's useful

00:08:21,670 --> 00:08:27,350
what are most useful things you can do

00:08:24,140 --> 00:08:29,510
for your clients is to create an

00:08:27,350 --> 00:08:33,770
endpoint that will always return

00:08:29,510 --> 00:08:36,680
something so that your clients can be

00:08:33,770 --> 00:08:38,390
sure that your API is up and running we

00:08:36,680 --> 00:08:40,479
could call this a heartbeat we could

00:08:38,390 --> 00:08:42,680
call this an echo we could call this a

00:08:40,479 --> 00:08:44,450
ping it doesn't really matter what we

00:08:42,680 --> 00:08:46,220
call it it's a good practice to have an

00:08:44,450 --> 00:08:49,190
endpoint that your clients can use to

00:08:46,220 --> 00:08:51,890
test their setup to make sure they can

00:08:49,190 --> 00:08:53,480
talk to your API and it turns out it's

00:08:51,890 --> 00:08:55,060
really easy to write so let's write one

00:08:53,480 --> 00:08:58,010
of those

00:08:55,060 --> 00:08:59,990
so this is a screencast so hopefully I

00:08:58,010 --> 00:09:06,410
can manipulate the system well enough to

00:08:59,990 --> 00:09:08,960
run it right so what I've done is I've

00:09:06,410 --> 00:09:11,270
gone to the absentee admin I've clicked

00:09:08,960 --> 00:09:14,690
on settings and it takes me through to

00:09:11,270 --> 00:09:18,530
this page I can then move down to the

00:09:14,690 --> 00:09:22,340
API page and I can create a new API all

00:09:18,530 --> 00:09:25,010
API is neither name we need to have

00:09:22,340 --> 00:09:26,900
something to distinguish one API for

00:09:25,010 --> 00:09:30,050
another we give it a name this one we'll

00:09:26,900 --> 00:09:32,450
call ping it's like paying we hit create

00:09:30,050 --> 00:09:37,580
API and the system person clicks a

00:09:32,450 --> 00:09:39,800
little bit and we now have a API like I

00:09:37,580 --> 00:09:41,990
create an RPC service for this it's nice

00:09:39,800 --> 00:09:45,170
and simple less code involved we like

00:09:41,990 --> 00:09:49,250
that so I go to the RPC services I pick

00:09:45,170 --> 00:09:51,920
create new RPC service I give my service

00:09:49,250 --> 00:09:55,490
a name and I'm not very imaginative

00:09:51,920 --> 00:09:56,870
we'll call the service ping as well and

00:09:55,490 --> 00:10:00,580
then I give it need to give it a route

00:09:56,870 --> 00:10:04,190
to match route to match is the endpoint

00:10:00,580 --> 00:10:06,970
it's a V URL that this particular

00:10:04,190 --> 00:10:09,860
service will run against and other

00:10:06,970 --> 00:10:11,900
unimaginative lis let's call it slash

00:10:09,860 --> 00:10:15,460
pink so if you don't hit slash ping

00:10:11,900 --> 00:10:18,170
you'll hit this particular RPC service

00:10:15,460 --> 00:10:21,800
create the RPC service it was a clicks

00:10:18,170 --> 00:10:28,160
and now we have an RPC API and we've

00:10:21,800 --> 00:10:30,860
created some source code as well in ping

00:10:28,160 --> 00:10:33,740
controller so let's switch to our editor

00:10:30,860 --> 00:10:34,160
and find that pink controller file there

00:10:33,740 --> 00:10:38,000
it is

00:10:34,160 --> 00:10:40,130
hopefully it's big enough to read so

00:10:38,000 --> 00:10:43,700
Abdullah T has created some files on

00:10:40,130 --> 00:10:46,130
disk for you the admin system only

00:10:43,700 --> 00:10:48,590
creates source code so all your source

00:10:46,130 --> 00:10:50,540
code is still in get you can still diff

00:10:48,590 --> 00:10:51,490
you can see exactly what the system has

00:10:50,540 --> 00:10:54,260
done for you

00:10:51,490 --> 00:10:56,690
you can choose not to use it and do it

00:10:54,260 --> 00:10:59,260
all by hand if you wanted to I wouldn't

00:10:56,690 --> 00:11:02,420
recommend that but you can do that and

00:10:59,260 --> 00:11:04,970
here we've got a controller this is

00:11:02,420 --> 00:11:06,499
looking very familiar hopefully to learn

00:11:04,970 --> 00:11:09,469
on who's used a frame

00:11:06,499 --> 00:11:11,869
for and it's a ping controller and it's

00:11:09,469 --> 00:11:15,199
called ping action so when someone hits

00:11:11,869 --> 00:11:18,319
the ping a P I endpoint this action is

00:11:15,199 --> 00:11:20,179
going to run this action is going to do

00:11:18,319 --> 00:11:22,669
nothing at the moment because app

00:11:20,179 --> 00:11:27,979
agility doesn't know what you want to do

00:11:22,669 --> 00:11:29,989
this is a bit you have to write so you

00:11:27,979 --> 00:11:33,379
have to return an array of the data you

00:11:29,989 --> 00:11:38,229
want to send back to the client so I

00:11:33,379 --> 00:11:38,229
need to return an array with the time

00:11:38,319 --> 00:11:41,689
very very simple

00:11:39,949 --> 00:11:43,189
so you hit this end point you'll get act

00:11:41,689 --> 00:11:46,359
back and you'll have the current time

00:11:43,189 --> 00:11:46,359
how hard can that be

00:11:46,899 --> 00:11:53,769
so let's switch to terminal and run a

00:11:50,239 --> 00:11:56,659
command quick sight again

00:11:53,769 --> 00:11:58,819
if you had to write goods API s-- make

00:11:56,659 --> 00:12:01,339
sure you are familiar with how to test

00:11:58,819 --> 00:12:04,909
them the first person that should be

00:12:01,339 --> 00:12:09,019
consuming your API is you learn curl

00:12:04,909 --> 00:12:11,720
their an HTTP learn postman I don't care

00:12:09,019 --> 00:12:16,879
which clients you use but learn a client

00:12:11,720 --> 00:12:19,989
really really well it's very important

00:12:16,879 --> 00:12:22,429
that you exercise your API yourself

00:12:19,989 --> 00:12:24,649
there's nothing like finding usability

00:12:22,429 --> 00:12:25,299
problems with an API if you have to use

00:12:24,649 --> 00:12:29,839
it

00:12:25,299 --> 00:12:31,970
this is curl who here uses curl there

00:12:29,839 --> 00:12:34,489
quite a few of you so cold man assess

00:12:31,970 --> 00:12:35,959
for silent - capital H because I would

00:12:34,489 --> 00:12:38,179
send a header and I'm sending in the

00:12:35,959 --> 00:12:41,179
JSON accept the accept header for

00:12:38,179 --> 00:12:43,159
application Jason my endpoint localhost

00:12:41,179 --> 00:12:46,129
colon 8080 sate because that's where my

00:12:43,159 --> 00:12:48,439
PHP web servers running slash ping my

00:12:46,129 --> 00:12:50,929
endpoint and they got pipe the result

00:12:48,439 --> 00:12:54,559
through a Python module called Jason

00:12:50,929 --> 00:12:55,729
tool which very handily formats my Jason

00:12:54,559 --> 00:12:59,569
for me makes it look pretty

00:12:55,729 --> 00:13:04,849
that's what it does so we run that and

00:12:59,569 --> 00:13:08,769
we get act back with a time 1 4 2 3

00:13:04,849 --> 00:13:08,769
whatever we're done

00:13:09,860 --> 00:13:16,500
so I wrote one letter code I returned

00:13:12,990 --> 00:13:20,570
back with a time stamp on it so what did

00:13:16,500 --> 00:13:26,459
I get as a result of using a bajillion

00:13:20,570 --> 00:13:29,310
writing my own API from scratch I got

00:13:26,459 --> 00:13:33,149
some code app agility created a module

00:13:29,310 --> 00:13:35,339
for me it then created a ping directory

00:13:33,149 --> 00:13:36,779
and put some folders and files in it

00:13:35,339 --> 00:13:39,180
ping controller factory and a ping

00:13:36,779 --> 00:13:40,680
controller the ping controller factory

00:13:39,180 --> 00:13:43,769
should give you a clue that we quite

00:13:40,680 --> 00:13:45,300
like dependency injection nowadays it's

00:13:43,769 --> 00:13:49,139
the way the future of you would test

00:13:45,300 --> 00:13:51,899
anything so dependency injection enables

00:13:49,139 --> 00:13:54,990
you to inject your dependencies into

00:13:51,899 --> 00:13:57,420
your controller in a fairly sane and

00:13:54,990 --> 00:14:00,000
clean way and then ping controller is

00:13:57,420 --> 00:14:04,820
got the action that we actually asked

00:14:00,000 --> 00:14:07,079
you'd all quite easy I got Jason I

00:14:04,820 --> 00:14:13,290
returned an array out of my controller

00:14:07,079 --> 00:14:17,160
Jason was sent to the client so HTT hi

00:14:13,290 --> 00:14:19,740
is another restful command-line run it's

00:14:17,160 --> 00:14:22,980
a lot shorter for typing commands on two

00:14:19,740 --> 00:14:25,470
slides that's why you seen it here so

00:14:22,980 --> 00:14:31,110
yet I get Jason back that's handy hey

00:14:25,470 --> 00:14:33,120
opportunity is opinionated we send back

00:14:31,110 --> 00:14:36,120
Jason we think Jason is a right answer

00:14:33,120 --> 00:14:38,069
if you understand that CSV if you want

00:14:36,120 --> 00:14:40,260
to send back XML if you were to send

00:14:38,069 --> 00:14:42,779
back some other weird format do it

00:14:40,260 --> 00:14:44,100
yourself I'll actually go get module

00:14:42,779 --> 00:14:47,130
from packages because there's bound to

00:14:44,100 --> 00:14:50,250
be one they're out of the box it's Jason

00:14:47,130 --> 00:14:54,029
Jason works really really well it's a

00:14:50,250 --> 00:14:56,370
very nice transfer format we get method

00:14:54,029 --> 00:14:59,730
negotiation for free what do I mean by

00:14:56,370 --> 00:15:03,389
method negotiation I mean that my

00:14:59,730 --> 00:15:06,029
endpoint only accepts get if you try to

00:15:03,389 --> 00:15:08,639
post to my ping endpoint I'm not going

00:15:06,029 --> 00:15:12,300
to accept you said they'd meet data I'm

00:15:08,639 --> 00:15:15,569
not interested so I send back a 405

00:15:12,300 --> 00:15:17,399
method not allowed this is what I talked

00:15:15,569 --> 00:15:19,380
about error reporting as well send back

00:15:17,399 --> 00:15:21,779
the right headers same about the right

00:15:19,380 --> 00:15:22,590
status codes so bit tedious to have to

00:15:21,779 --> 00:15:26,670
do this

00:15:22,590 --> 00:15:29,730
till it is done it for me I also have

00:15:26,670 --> 00:15:32,580
options handling built-in so options is

00:15:29,730 --> 00:15:35,160
one of the methods on HTTP if you hit

00:15:32,580 --> 00:15:37,920
the options method against any end point

00:15:35,160 --> 00:15:41,520
you should get back a list of available

00:15:37,920 --> 00:15:44,010
verbs for that end point that's what it

00:15:41,520 --> 00:15:46,670
should do for you Handclap you've

00:15:44,010 --> 00:15:49,020
actually implemented options in your API

00:15:46,670 --> 00:15:53,570
all right 50 percent of you are writing

00:15:49,020 --> 00:15:53,570
API is one person is implemented options

00:15:54,440 --> 00:16:00,930
error reporting why if you hit an

00:15:59,220 --> 00:16:03,600
endpoint that doesn't exist what should

00:16:00,930 --> 00:16:06,600
happen a 404 should be returned that's

00:16:03,600 --> 00:16:09,150
quite easy we sent that status 404 how

00:16:06,600 --> 00:16:13,830
do we tell our client what's gone wrong

00:16:09,150 --> 00:16:17,790
in a structured manner turns out there's

00:16:13,830 --> 00:16:21,300
a IETF draft RFP on it on its way

00:16:17,790 --> 00:16:24,000
through approval called HTTP HTTP

00:16:21,300 --> 00:16:26,640
problem which is a structured where I've

00:16:24,000 --> 00:16:29,730
returned in errors so if you report your

00:16:26,640 --> 00:16:32,100
errors using HTTP problem then the

00:16:29,730 --> 00:16:33,960
clients can trust what data they get

00:16:32,100 --> 00:16:36,210
back they can start interpreted in this

00:16:33,960 --> 00:16:37,980
state automatically they can stick it

00:16:36,210 --> 00:16:39,810
into things like logstash that Ben was

00:16:37,980 --> 00:16:41,090
talking about yesterday and they can

00:16:39,810 --> 00:16:43,590
start analyzing what's going on

00:16:41,090 --> 00:16:45,780
structured error reporting is really

00:16:43,590 --> 00:16:48,690
really helpful and there's a standard

00:16:45,780 --> 00:16:51,180
for it we implement that standard comes

00:16:48,690 --> 00:16:53,280
with agility so for a for not founded

00:16:51,180 --> 00:16:55,860
your status code we set the right

00:16:53,280 --> 00:16:59,820
content type so application slash

00:16:55,860 --> 00:17:02,580
problem plus Jason and then we send back

00:16:59,820 --> 00:17:05,310
the actual structured data which is a

00:17:02,580 --> 00:17:07,830
detail as Thetis a title and a type

00:17:05,310 --> 00:17:10,010
which can give some clues to your client

00:17:07,830 --> 00:17:12,810
on how to fix the problem

00:17:10,010 --> 00:17:15,000
I'm a big fan of helping my clients

00:17:12,810 --> 00:17:17,910
solve their own problems if they do that

00:17:15,000 --> 00:17:19,920
they won't email me provide as much

00:17:17,910 --> 00:17:24,360
information as you can in your error

00:17:19,920 --> 00:17:28,320
reporting except checking works the same

00:17:24,360 --> 00:17:31,890
way warehouses someone asks for XML I've

00:17:28,320 --> 00:17:34,980
just told you we do Jason somewhere else

00:17:31,890 --> 00:17:36,450
for XML I have to error my error using a

00:17:34,980 --> 00:17:38,159
CTU problem is

00:17:36,450 --> 00:17:40,080
built-in I didn't have to think about

00:17:38,159 --> 00:17:48,210
any of this he just came as part of the

00:17:40,080 --> 00:17:51,570
framework and to get version in it turns

00:17:48,210 --> 00:17:54,179
out that when you write an API you don't

00:17:51,570 --> 00:17:57,179
get it right first time I know this is a

00:17:54,179 --> 00:17:59,340
shock but it turns out that sometimes

00:17:57,179 --> 00:18:01,950
you make mistakes and when you make

00:17:59,340 --> 00:18:05,519
mistakes you end up having to create

00:18:01,950 --> 00:18:07,799
backwards incompatible changes when you

00:18:05,519 --> 00:18:10,769
make a backwards incompatible change you

00:18:07,799 --> 00:18:14,399
upset every client that's ever used your

00:18:10,769 --> 00:18:18,120
API if you do it twice they will go to

00:18:14,399 --> 00:18:21,120
your competitor nobody likes having

00:18:18,120 --> 00:18:23,669
their system stopped working because

00:18:21,120 --> 00:18:26,279
this end point over there has changed

00:18:23,669 --> 00:18:30,779
what it does so we invented versioning

00:18:26,279 --> 00:18:32,850
to solve this problem and we're

00:18:30,779 --> 00:18:37,440
developers so there's more than one way

00:18:32,850 --> 00:18:40,289
to do it obviously the two most common

00:18:37,440 --> 00:18:44,039
ways of doing versioning are media types

00:18:40,289 --> 00:18:47,789
and URL based media types are the proper

00:18:44,039 --> 00:18:50,250
way for some definition of proper when I

00:18:47,789 --> 00:18:52,769
say media type I mean that we changed

00:18:50,250 --> 00:18:55,639
the accept header that our clients are

00:18:52,769 --> 00:18:59,149
using so our clients will request

00:18:55,639 --> 00:19:02,519
application slash VND ping dot v1 or

00:18:59,149 --> 00:19:06,899
pink v2 depending on which version of

00:19:02,519 --> 00:19:08,340
the API they want to receive it's out of

00:19:06,899 --> 00:19:12,389
band it's not part of the actual

00:19:08,340 --> 00:19:16,679
response coming back it's a good way to

00:19:12,389 --> 00:19:20,519
do it so rattled pain to do if you want

00:19:16,679 --> 00:19:22,830
to test in a browser so half the API is

00:19:20,519 --> 00:19:27,570
in the world stick the version in the

00:19:22,830 --> 00:19:29,580
URL it's very pragmatic solution stick

00:19:27,570 --> 00:19:30,960
the version in the URL nobody gets

00:19:29,580 --> 00:19:32,909
confused about which version they're

00:19:30,960 --> 00:19:36,210
using it's right there where they can

00:19:32,909 --> 00:19:38,490
see it add vanilla tea supports both if

00:19:36,210 --> 00:19:40,429
you are particularly religious about it

00:19:38,490 --> 00:19:42,809
you can turn off the one you don't like

00:19:40,429 --> 00:19:45,380
in practice you leave them both on it

00:19:42,809 --> 00:19:45,380
doesn't really matter

00:19:46,610 --> 00:19:54,540
in a fertility a new version is new code

00:19:50,820 --> 00:19:58,830
so your old version continues to run and

00:19:54,540 --> 00:20:00,870
we do this fired namespaces so version

00:19:58,830 --> 00:20:02,370
one lives in a namespace version two

00:20:00,870 --> 00:20:05,160
lists in the namespace when you create

00:20:02,370 --> 00:20:07,110
two version two of your API we copy all

00:20:05,160 --> 00:20:10,290
of version ones code into version two

00:20:07,110 --> 00:20:12,270
and then you go fix the problems version

00:20:10,290 --> 00:20:15,030
one will continue to be the way it was

00:20:12,270 --> 00:20:19,170
before you don't make a mistake and

00:20:15,030 --> 00:20:21,240
accidentally screw up version one so

00:20:19,170 --> 00:20:23,160
here's an example let's say that we get

00:20:21,240 --> 00:20:25,890
fed up with timestamps and we'd actually

00:20:23,160 --> 00:20:29,040
prefer to return a human readable date

00:20:25,890 --> 00:20:32,510
in our ping and knowledge mint

00:20:29,040 --> 00:20:32,510
so we created the version two for that

00:20:32,690 --> 00:20:39,540
this is how the clients will access it

00:20:35,660 --> 00:20:41,070
so if you hit /v 1 slash ping you're

00:20:39,540 --> 00:20:42,540
going to get version 1 you're going to

00:20:41,070 --> 00:20:45,000
get the timestamp just a straight

00:20:42,540 --> 00:20:48,330
integer similarly if you hit applique

00:20:45,000 --> 00:20:52,170
hit slash ping but set an accept header

00:20:48,330 --> 00:20:54,450
of VND dot ping dot v1 plus Jason then

00:20:52,170 --> 00:20:57,270
again you'll get the version 1 copy of

00:20:54,450 --> 00:21:00,950
the code if version 2 we're going to get

00:20:57,270 --> 00:21:06,480
the pretty date time much easier to read

00:21:00,950 --> 00:21:08,960
notice if you do not choose a version we

00:21:06,480 --> 00:21:13,080
default to version 1

00:21:08,960 --> 00:21:17,280
we believe in minimum surprises for our

00:21:13,080 --> 00:21:19,430
clients clients hate surprises every

00:21:17,280 --> 00:21:22,980
possible type of client hates surprises

00:21:19,430 --> 00:21:24,810
so if you haven't set an accepted err

00:21:22,980 --> 00:21:26,040
so if you have set a version you haven't

00:21:24,810 --> 00:21:29,160
done the right accept header you will

00:21:26,040 --> 00:21:36,420
always get version 1 even if the API is

00:21:29,160 --> 00:21:38,010
now on version 3 ok so that's not BC

00:21:36,420 --> 00:21:40,140
that's the features of Apogee leti let's

00:21:38,010 --> 00:21:45,060
move on to talk about the restful side

00:21:40,140 --> 00:21:48,270
of things there are two types of restful

00:21:45,060 --> 00:21:50,460
api built into opportunity or restful

00:21:48,270 --> 00:21:52,350
service as we call them we have database

00:21:50,460 --> 00:21:56,970
connected ones and we have code

00:21:52,350 --> 00:22:04,530
connected ones database connected ones

00:21:56,970 --> 00:22:06,600
are very very simple to implement you

00:22:04,530 --> 00:22:11,100
simply point app agility at the database

00:22:06,600 --> 00:22:14,400
table and you get an API that lets you

00:22:11,100 --> 00:22:17,309
manipulate that database table without

00:22:14,400 --> 00:22:18,840
having to do any additional work so if

00:22:17,309 --> 00:22:22,080
you need to get an API up and running

00:22:18,840 --> 00:22:22,710
quite quickly this is a very good way to

00:22:22,080 --> 00:22:26,580
do it

00:22:22,710 --> 00:22:28,230
it is also remarkably limited because

00:22:26,580 --> 00:22:31,260
it's all the code that's been done

00:22:28,230 --> 00:22:34,190
behind the scenes so code connected ap

00:22:31,260 --> 00:22:37,350
is allowable you to do the work yourself

00:22:34,190 --> 00:22:39,750
you get to control everything about your

00:22:37,350 --> 00:22:41,700
ass'll api how it works what it does

00:22:39,750 --> 00:22:43,440
with the data coming in how it returns

00:22:41,700 --> 00:22:45,470
the correct representation of the

00:22:43,440 --> 00:22:52,950
resource you can do it all yourself

00:22:45,470 --> 00:22:55,020
should you need to which one you pick

00:22:52,950 --> 00:22:57,510
depends on the type of problem you're

00:22:55,020 --> 00:22:59,280
trying to solve I tend to find that when

00:22:57,510 --> 00:23:01,159
I've seen opportunity projects out in

00:22:59,280 --> 00:23:04,130
the world they're a mixture of the two

00:23:01,159 --> 00:23:06,480
that's quite common

00:23:04,130 --> 00:23:10,700
so let's de lavaz greens cast are shown

00:23:06,480 --> 00:23:17,270
how we actually build a restful api a

00:23:10,700 --> 00:23:21,870
database connected one where's my oh

00:23:17,270 --> 00:23:25,530
there we are so here we are the system

00:23:21,870 --> 00:23:28,380
we go to the Settings area to set up a

00:23:25,530 --> 00:23:30,830
database adapter we have to sell a

00:23:28,380 --> 00:23:33,419
fertility how to talk to our database

00:23:30,830 --> 00:23:36,120
it's using PDO so it's all quite easy

00:23:33,419 --> 00:23:38,549
create a new database adapter give it a

00:23:36,120 --> 00:23:42,059
name that we can reference later this is

00:23:38,549 --> 00:23:46,230
a music database so DB music I pick a

00:23:42,059 --> 00:23:48,330
driver that's the list of database

00:23:46,230 --> 00:23:49,890
drivers that we support this is where

00:23:48,330 --> 00:23:51,840
you start seeing some of the underlines

00:23:49,890 --> 00:23:54,720
in framework to code so if same

00:23:51,840 --> 00:23:56,789
framework twos database system can talk

00:23:54,720 --> 00:23:59,370
to a database then app agility can talk

00:23:56,789 --> 00:24:02,789
to it so you've got things like db2

00:23:59,370 --> 00:24:03,360
you've got all the PDO ones sequel

00:24:02,789 --> 00:24:07,230
server

00:24:03,360 --> 00:24:09,809
Postgres etc all in there

00:24:07,230 --> 00:24:11,179
pick one we got paid from SQL so we're

00:24:09,809 --> 00:24:15,090
gonna need to give it a database name

00:24:11,179 --> 00:24:16,500
music we don't need a username Rob you

00:24:15,090 --> 00:24:18,570
need the password - don't you system

00:24:16,500 --> 00:24:21,480
production one two three four five six

00:24:18,570 --> 00:24:25,710
and then we can hit save we've now got

00:24:21,480 --> 00:24:29,820
the database let's go over to the API

00:24:25,710 --> 00:24:33,720
section and create a new API so rather

00:24:29,820 --> 00:24:35,700
majid of Lee we'll call it music we're

00:24:33,720 --> 00:24:38,070
four clicks we get our music API

00:24:35,700 --> 00:24:40,049
this time we got pick a restful service

00:24:38,070 --> 00:24:42,030
so we are create a new restful service

00:24:40,049 --> 00:24:44,460
and here's where you can pick whether

00:24:42,030 --> 00:24:47,280
you want to code connected service or

00:24:44,460 --> 00:24:48,960
whether you want a DB connected one your

00:24:47,280 --> 00:24:51,570
Co connected you simply give it a name

00:24:48,960 --> 00:24:53,460
when you're done if you want database

00:24:51,570 --> 00:24:55,230
connected then you go to the database

00:24:53,460 --> 00:24:57,270
tab and you pick from the list of

00:24:55,230 --> 00:25:00,620
available adapters in this case we have

00:24:57,270 --> 00:25:03,210
our music one and then you specify which

00:25:00,620 --> 00:25:07,250
database table you actually want to

00:25:03,210 --> 00:25:09,690
connect to in this case the album table

00:25:07,250 --> 00:25:13,020
words and clicks we've now got a RESTful

00:25:09,690 --> 00:25:16,740
API chord album like a couple of things

00:25:13,020 --> 00:25:19,770
here it's automatically named our

00:25:16,740 --> 00:25:23,549
endpoint for us so the in point it has

00:25:19,770 --> 00:25:26,490
given us is slash album slash album ID

00:25:23,549 --> 00:25:28,559
and if you look at it the album ID is in

00:25:26,490 --> 00:25:29,309
square brackets which means it's

00:25:28,559 --> 00:25:32,400
optional

00:25:29,309 --> 00:25:35,280
so this endpoint will accept two

00:25:32,400 --> 00:25:39,330
different types of data it will accept a

00:25:35,280 --> 00:25:41,940
collection on slash album and it will

00:25:39,330 --> 00:25:45,929
accept a specific album or specific

00:25:41,940 --> 00:25:48,710
resource on slash album slash 43 or

00:25:45,929 --> 00:25:51,679
something like that so one endpoint is

00:25:48,710 --> 00:25:54,090
supporting two different types of data

00:25:51,679 --> 00:25:57,419
individual albums and the collections of

00:25:54,090 --> 00:26:01,620
albums so you can see that further down

00:25:57,419 --> 00:26:03,929
here where in terms of the accepts check

00:26:01,620 --> 00:26:06,059
in we can choose which verbs to accept

00:26:03,929 --> 00:26:09,000
for entities and which verbs to accept

00:26:06,059 --> 00:26:10,890
the collection we might not want people

00:26:09,000 --> 00:26:13,650
dread to delete every single album in

00:26:10,890 --> 00:26:18,299
the system for instance that choice is

00:26:13,650 --> 00:26:20,999
up to us personally I don't like

00:26:18,299 --> 00:26:24,059
singular in my endpoints

00:26:20,999 --> 00:26:25,649
for collections so I don't like that

00:26:24,059 --> 00:26:28,409
it's called album so I'm going to edit

00:26:25,649 --> 00:26:31,169
that and change it to albums because it

00:26:28,409 --> 00:26:32,849
makes me feel happy so I go to the

00:26:31,169 --> 00:26:35,039
system I choose edit I change it to

00:26:32,849 --> 00:26:38,549
albums I can change other things like

00:26:35,039 --> 00:26:40,379
how many records per page I can change

00:26:38,549 --> 00:26:41,999
whatever else I need to change I ignore

00:26:40,379 --> 00:26:44,489
the rest and just hit save

00:26:41,999 --> 00:26:46,789
so I've altered the end point to be such

00:26:44,489 --> 00:26:51,229
albums over to the browser

00:26:46,789 --> 00:26:55,159
so hopefully browser over to the

00:26:51,229 --> 00:26:57,749
terminal and let's run some more coal

00:26:55,159 --> 00:27:00,209
first one let's hit the slash albums

00:26:57,749 --> 00:27:04,799
endpoint just straight to hit the

00:27:00,209 --> 00:27:06,959
collection what do we get back guess

00:27:04,799 --> 00:27:10,769
what we get some JSON we get the

00:27:06,959 --> 00:27:13,859
collection back and it's embedded in a

00:27:10,769 --> 00:27:16,259
format to make it structured Jason is

00:27:13,859 --> 00:27:18,059
intrinsically not very structured in

00:27:16,259 --> 00:27:20,759
terms of our agreement of what goes

00:27:18,059 --> 00:27:24,569
where so there are standards out there

00:27:20,759 --> 00:27:26,459
that when we use one of those so there

00:27:24,569 --> 00:27:28,529
we go we've got our albums there's four

00:27:26,459 --> 00:27:30,569
or five in here there whatever was at

00:27:28,529 --> 00:27:31,789
Amazon or selling well when I wrote this

00:27:30,569 --> 00:27:34,139
demo

00:27:31,789 --> 00:27:39,059
whoever Meghan Trainor is for instance

00:27:34,139 --> 00:27:41,309
I've got no idea so there we go we've

00:27:39,059 --> 00:27:47,759
got a collection how about if we try to

00:27:41,309 --> 00:27:51,749
create a a new album this time we need

00:27:47,759 --> 00:27:53,129
to post to create a new album in a

00:27:51,749 --> 00:27:55,859
collection or new resource in a

00:27:53,129 --> 00:27:59,429
collection we post to the collection end

00:27:55,859 --> 00:28:01,499
point and we will get a new resource

00:27:59,429 --> 00:28:04,139
within that collection so I use curl

00:28:01,499 --> 00:28:07,019
again I have to send the method which is

00:28:04,139 --> 00:28:09,079
minus X for some weird reason posters

00:28:07,019 --> 00:28:13,079
our method hit the collection end point

00:28:09,079 --> 00:28:16,259
have to set our content type header now

00:28:13,079 --> 00:28:17,699
we have to tell a padilha T what type of

00:28:16,259 --> 00:28:20,789
data we are sending it

00:28:17,699 --> 00:28:22,589
we're destined to Jason accept the

00:28:20,789 --> 00:28:24,829
accept header what data we would like

00:28:22,589 --> 00:28:27,449
come back and then send some data in

00:28:24,829 --> 00:28:32,370
Sanger sending the Charlotteans and

00:28:27,449 --> 00:28:36,159
modern nature and a fidelity

00:28:32,370 --> 00:28:38,380
we'll create my album for me and it will

00:28:36,159 --> 00:28:41,830
return a representation of that album

00:28:38,380 --> 00:28:44,529
back to me so by posting to the

00:28:41,830 --> 00:28:49,240
collection I get back the album itself I

00:28:44,529 --> 00:28:52,840
also get the URL of this particular

00:28:49,240 --> 00:28:55,539
album localhost 8 8 8 slash album slash

00:28:52,840 --> 00:28:59,980
seven as part of that structured beta

00:28:55,539 --> 00:29:02,320
and it's also in the headers so you can

00:28:59,980 --> 00:29:06,539
find out where the end point for your

00:29:02,320 --> 00:29:08,830
new album is so that's quite easy

00:29:06,539 --> 00:29:11,169
looking at the data we decide that

00:29:08,830 --> 00:29:13,389
actually we probably should have spelt

00:29:11,169 --> 00:29:20,470
the title of the album with capital

00:29:13,389 --> 00:29:23,889
letters so to change a resource we put

00:29:20,470 --> 00:29:27,669
to the resources end point now when you

00:29:23,889 --> 00:29:32,350
use put you have to send in every piece

00:29:27,669 --> 00:29:34,380
of data put is a replace so whatever you

00:29:32,350 --> 00:29:36,760
send it will replace whatever

00:29:34,380 --> 00:29:39,159
representation of that resource is on

00:29:36,760 --> 00:29:42,159
that particular end point so although I

00:29:39,159 --> 00:29:45,700
only want to change the title I have to

00:29:42,159 --> 00:29:47,769
pass in the artist as well otherwise it

00:29:45,700 --> 00:29:53,440
will be cleared for me that is what put

00:29:47,769 --> 00:29:55,750
does so here I am put in correcting the

00:29:53,440 --> 00:29:57,880
title and sending the artist in again

00:29:55,750 --> 00:29:59,789
and it works and clips for a bit and

00:29:57,880 --> 00:30:02,139
will return to me again the resource

00:29:59,789 --> 00:30:06,490
quite handily and you have capitalized

00:30:02,139 --> 00:30:10,029
modern nature the other way of doing an

00:30:06,490 --> 00:30:13,000
update in a restful api is patch patch

00:30:10,029 --> 00:30:14,769
is a more recent verb it's not in the

00:30:13,000 --> 00:30:17,470
original standard it's in a later one

00:30:14,769 --> 00:30:21,250
and I've forgotten the numbers there are

00:30:17,470 --> 00:30:24,610
so many numbers with RFC's if you patch

00:30:21,250 --> 00:30:28,240
and use a patch verb you only need to

00:30:24,610 --> 00:30:29,409
send it in the data you are changing so

00:30:28,240 --> 00:30:32,019
in this case I were to change the

00:30:29,409 --> 00:30:34,029
artists name so I only have to send the

00:30:32,019 --> 00:30:36,880
artists data I don't have to send the

00:30:34,029 --> 00:30:39,039
album's title again patch will do the

00:30:36,880 --> 00:30:41,889
right thing for me that's why it was

00:30:39,039 --> 00:30:44,620
invented and again you get a

00:30:41,889 --> 00:30:46,040
representation of the resource once it

00:30:44,620 --> 00:30:48,980
has been updated

00:30:46,040 --> 00:30:52,550
so that's all fine and dandy finally

00:30:48,980 --> 00:30:55,760
delete is the other thing you're likely

00:30:52,550 --> 00:30:58,040
to do with your resources and you send

00:30:55,760 --> 00:31:03,100
the delete verb in and it will delete

00:30:58,040 --> 00:31:05,720
your record and it sends back nothing

00:31:03,100 --> 00:31:12,850
there is no data left you've just

00:31:05,720 --> 00:31:17,260
deleted it located was that fairly clear

00:31:12,850 --> 00:31:21,800
the quick water of how api's work cool

00:31:17,260 --> 00:31:25,430
so what did we get this time absolutely

00:31:21,800 --> 00:31:28,750
no code whatsoever I got a full restful

00:31:25,430 --> 00:31:31,610
crud interface to that database table

00:31:28,750 --> 00:31:33,530
that's quite cool you need to get

00:31:31,610 --> 00:31:35,750
something prototype up get something

00:31:33,530 --> 00:31:37,790
going test out whether this is the right

00:31:35,750 --> 00:31:39,800
sort of data this is a right sort of API

00:31:37,790 --> 00:31:44,360
you want to create this is quite a quick

00:31:39,800 --> 00:31:47,240
way to do that we've got hypermedia

00:31:44,360 --> 00:31:50,630
links in our JSON output so we are

00:31:47,240 --> 00:31:53,060
trying to be compliant with level three

00:31:50,630 --> 00:31:54,890
of the register and maturity model that

00:31:53,060 --> 00:31:58,000
is part and parcel of it you didn't have

00:31:54,890 --> 00:32:00,500
to think about that we've got pagination

00:31:58,000 --> 00:32:03,320
that's quite important for large data

00:32:00,500 --> 00:32:04,280
sets and obviously we've got all the

00:32:03,320 --> 00:32:06,320
other things that we talked about

00:32:04,280 --> 00:32:07,730
earlier so it's still versioned it's

00:32:06,320 --> 00:32:10,370
still got method control it's still got

00:32:07,730 --> 00:32:13,280
content type checking etc that is all

00:32:10,370 --> 00:32:17,770
built in to our prototype or into our

00:32:13,280 --> 00:32:17,770
API without any effort on our part so

00:32:18,070 --> 00:32:26,720
the code this time has gone into the

00:32:23,000 --> 00:32:28,880
music module it's in a folder which is

00:32:26,720 --> 00:32:31,040
called album because that's the name of

00:32:28,880 --> 00:32:34,340
the service I gave it so I can have

00:32:31,040 --> 00:32:37,700
multiple API services within the same

00:32:34,340 --> 00:32:40,280
module so in this case it's the album

00:32:37,700 --> 00:32:41,810
service and it created two classes for

00:32:40,280 --> 00:32:44,780
me two files were created behind the

00:32:41,810 --> 00:32:49,550
scenes a collection class and an entity

00:32:44,780 --> 00:32:51,470
class you don't need such either of

00:32:49,550 --> 00:32:54,890
these files unless you want to do any

00:32:51,470 --> 00:32:56,750
customization personally I've never ever

00:32:54,890 --> 00:32:59,180
touched them if I need to do a

00:32:56,750 --> 00:32:59,419
customized API I would have started with

00:32:59,180 --> 00:33:03,049
a

00:32:59,419 --> 00:33:06,169
connected API database

00:33:03,049 --> 00:33:08,829
DB connected api's work best if you let

00:33:06,169 --> 00:33:08,829
them do their thing

00:33:09,039 --> 00:33:14,629
hypermedia in Jason this is the

00:33:11,989 --> 00:33:17,329
structure we are using so the actual

00:33:14,629 --> 00:33:20,599
data itself the artist CID in the title

00:33:17,329 --> 00:33:23,749
are three top-level elements of the JSON

00:33:20,599 --> 00:33:26,959
object we are using a standard called

00:33:23,749 --> 00:33:30,709
hypermedia application language which is

00:33:26,959 --> 00:33:35,450
another RFC draft it's currently in

00:33:30,709 --> 00:33:38,839
voting I believe this defined structure

00:33:35,450 --> 00:33:44,869
to Jason in the same way as we already

00:33:38,839 --> 00:33:47,359
have structure in XML so the link tag in

00:33:44,869 --> 00:33:49,849
XML or in your X in your HTML you can

00:33:47,359 --> 00:33:52,369
have a rel and then you can have the

00:33:49,849 --> 00:33:54,589
link itself so you can do rel self or

00:33:52,369 --> 00:33:57,529
you could do rel canonical things like

00:33:54,589 --> 00:33:59,779
that in your ace to our websites in

00:33:57,529 --> 00:34:02,629
Jason there is no standard in a moment

00:33:59,779 --> 00:34:05,769
this is standard that will be released

00:34:02,629 --> 00:34:09,200
soon hopefully and it's defined by a

00:34:05,769 --> 00:34:12,379
tech name underscore links on element

00:34:09,200 --> 00:34:14,690
name and then you can have as many links

00:34:12,379 --> 00:34:18,079
as you like each one has got a name

00:34:14,690 --> 00:34:21,349
which is equivalent to rel in HTML and

00:34:18,079 --> 00:34:26,629
then the href or etc so here I have a

00:34:21,349 --> 00:34:30,069
linked self and that whole link section

00:34:26,629 --> 00:34:32,899
is part of something called the

00:34:30,069 --> 00:34:35,690
hypertext as the engine of application

00:34:32,899 --> 00:34:38,629
state which has got the worst acronym in

00:34:35,690 --> 00:34:39,589
the world but you'll come across it one

00:34:38,629 --> 00:34:41,720
of the nice things about this acronym

00:34:39,589 --> 00:34:44,359
incidentally is that it is dead easy to

00:34:41,720 --> 00:34:46,399
Google for which is quite handy and

00:34:44,359 --> 00:34:48,980
there's an article there that I've put

00:34:46,399 --> 00:34:51,440
at the bottom screen by who I filled in

00:34:48,980 --> 00:34:54,789
the guy invented rest about why you

00:34:51,440 --> 00:34:57,380
should have a link section in all your

00:34:54,789 --> 00:34:59,299
resources and all your collections and

00:34:57,380 --> 00:35:02,240
what is really important to the way rest

00:34:59,299 --> 00:35:05,869
works fundamentally that you should be

00:35:02,240 --> 00:35:09,349
trying to get to level 3 of the richest

00:35:05,869 --> 00:35:11,100
immaturity model so the same thing

00:35:09,349 --> 00:35:14,790
happens in the collection

00:35:11,100 --> 00:35:16,320
this time the data of the collection is

00:35:14,790 --> 00:35:18,180
at the top level so the date of the

00:35:16,320 --> 00:35:21,080
collection of top level is a page count

00:35:18,180 --> 00:35:25,170
the page size and total number of items

00:35:21,080 --> 00:35:28,650
that's the collections data then each

00:35:25,170 --> 00:35:32,340
individual album resource is in an array

00:35:28,650 --> 00:35:34,080
within the embedded section this is part

00:35:32,340 --> 00:35:36,180
of what application health loss jason

00:35:34,080 --> 00:35:38,280
specifies so you will find your

00:35:36,180 --> 00:35:41,940
collection data all the album's

00:35:38,280 --> 00:35:45,030
themselves inside the embedded section

00:35:41,940 --> 00:35:47,370
and again we have the link section but

00:35:45,030 --> 00:35:49,530
now because we are in a collection we've

00:35:47,370 --> 00:35:52,110
got pagination coming in so you've got

00:35:49,530 --> 00:35:56,040
first and last in this case as well as

00:35:52,110 --> 00:35:58,860
self pagination itself if you're

00:35:56,040 --> 00:36:01,140
somewhere in the middle of a a set of

00:35:58,860 --> 00:36:02,490
data then you're going to get first last

00:36:01,140 --> 00:36:05,430
previous and next

00:36:02,490 --> 00:36:08,280
that's all provided for you your data is

00:36:05,430 --> 00:36:10,830
nicely paginating your mobile clients

00:36:08,280 --> 00:36:13,740
will love you they are memory

00:36:10,830 --> 00:36:15,270
constrained they really don't like it if

00:36:13,740 --> 00:36:18,540
you send them a hundred thousand objects

00:36:15,270 --> 00:36:20,010
in a collection that's bad I know we did

00:36:18,540 --> 00:36:24,500
it once for joined in it was a real

00:36:20,010 --> 00:36:24,500
mistake paginate your data collections

00:36:26,810 --> 00:36:33,570
so I've just connected a database table

00:36:30,150 --> 00:36:40,460
to the Internet can anyone spot any

00:36:33,570 --> 00:36:40,460
problems yes

00:36:45,980 --> 00:36:52,800
yes people can put in whatever they like

00:36:48,810 --> 00:36:57,360
into my database they can do bad things

00:36:52,800 --> 00:36:59,520
I think we should take it as read this

00:36:57,360 --> 00:37:01,010
day and age to never ever trust anyone

00:36:59,520 --> 00:37:05,490
on the Internet

00:37:01,010 --> 00:37:08,810
so you need to validate and filter any

00:37:05,490 --> 00:37:12,120
data that comes into your system so

00:37:08,810 --> 00:37:14,040
hence it is built into opportunity we

00:37:12,120 --> 00:37:16,380
can't have a database connected API

00:37:14,040 --> 00:37:18,270
where we're taking a database table in

00:37:16,380 --> 00:37:20,460
your mouth Corral and putting it on the

00:37:18,270 --> 00:37:26,010
internet without a way to validate or

00:37:20,460 --> 00:37:28,350
filter so this is built-in as well the

00:37:26,010 --> 00:37:30,630
nice thing about it is that it's

00:37:28,350 --> 00:37:34,470
entirely admin based so it's quite easy

00:37:30,630 --> 00:37:37,320
to do and this is tested whilst you're

00:37:34,470 --> 00:37:41,370
doing the routing so it fails a very

00:37:37,320 --> 00:37:44,910
very quickly and more importantly it

00:37:41,370 --> 00:37:47,640
means that invalid data never hits your

00:37:44,910 --> 00:37:50,160
code the validation of filtering has

00:37:47,640 --> 00:37:51,750
happened before it gets to your code

00:37:50,160 --> 00:37:54,000
base so the bit of code you're writing

00:37:51,750 --> 00:37:56,130
you can trust it's already being

00:37:54,000 --> 00:38:00,840
filtered and validated so that's quite

00:37:56,130 --> 00:38:02,460
handy obviously because we want to be

00:38:00,840 --> 00:38:05,670
well structured that we want to be a

00:38:02,460 --> 00:38:09,780
good API we are going to return the

00:38:05,670 --> 00:38:11,400
correct HTTP status when you get things

00:38:09,780 --> 00:38:16,100
wrong or when your clients gets things

00:38:11,400 --> 00:38:19,440
wrong morally so for hundreds 42s etc

00:38:16,100 --> 00:38:21,390
and again it's done by the admin we like

00:38:19,440 --> 00:38:25,170
the admin so here's another screencast

00:38:21,390 --> 00:38:30,530
we how would we add validation to our

00:38:25,170 --> 00:38:30,530
system where's my

00:38:33,430 --> 00:38:39,619
so here's our album service again this

00:38:37,489 --> 00:38:42,680
time we edit it and we go to the fields

00:38:39,619 --> 00:38:45,559
tab and we can add a new field so I'm

00:38:42,680 --> 00:38:49,160
going to create a field called artist so

00:38:45,559 --> 00:38:53,059
I for each database column I need to

00:38:49,160 --> 00:38:54,979
create a field call it artist hit create

00:38:53,059 --> 00:38:58,190
new field I've now got my artists field

00:38:54,979 --> 00:39:00,499
I can drop it down and then I get some

00:38:58,190 --> 00:39:04,069
field things to fill in firstly I can

00:39:00,499 --> 00:39:06,380
give it a description so the artists

00:39:04,069 --> 00:39:07,999
that created this album I don't let me

00:39:06,380 --> 00:39:08,450
write your documentation not very good

00:39:07,999 --> 00:39:11,749
at it

00:39:08,450 --> 00:39:13,880
I can give it a validation failure

00:39:11,749 --> 00:39:17,180
message some information how you're

00:39:13,880 --> 00:39:20,329
supposed to fill in this field so the

00:39:17,180 --> 00:39:26,559
artists name must be no more than 100

00:39:20,329 --> 00:39:26,559
characters then I could have my filters

00:39:27,640 --> 00:39:37,670
filters will change the data so what a

00:39:34,759 --> 00:39:39,670
filter does is it will manipulate the

00:39:37,670 --> 00:39:42,920
data that comes in from the client

00:39:39,670 --> 00:39:44,589
change it in some way and then pass it

00:39:42,920 --> 00:39:48,549
on to your application

00:39:44,589 --> 00:39:51,499
it's a normalization stage if you like

00:39:48,549 --> 00:39:54,890
it doesn't validate it filters it

00:39:51,499 --> 00:39:56,779
changes the data so there's a number of

00:39:54,890 --> 00:39:58,789
filters available off the batch you can

00:39:56,779 --> 00:40:03,440
add your own obviously in this

00:39:58,789 --> 00:40:06,380
particular case I'm going to type trim I

00:40:03,440 --> 00:40:06,529
suppose so that all that yeah there we

00:40:06,380 --> 00:40:08,420
go

00:40:06,529 --> 00:40:11,989
I'm looking for string trim because I've

00:40:08,420 --> 00:40:14,210
decided that any artist that you send

00:40:11,989 --> 00:40:16,609
into my system will not have trailing

00:40:14,210 --> 00:40:18,710
whitespace it's probably an error on

00:40:16,609 --> 00:40:21,289
your part I can just strip off the

00:40:18,710 --> 00:40:25,700
trailing whitespace don't send me some

00:40:21,289 --> 00:40:28,339
blank spaces not interested I'm also

00:40:25,700 --> 00:40:31,130
making the decision that my artists do

00:40:28,339 --> 00:40:34,609
not have HTML in them so I can strip out

00:40:31,130 --> 00:40:38,450
any HTML tags as well so now I filter by

00:40:34,609 --> 00:40:43,039
data now I can add some validation the

00:40:38,450 --> 00:40:45,469
validation is a yes/no thing so this is

00:40:43,039 --> 00:40:47,119
the point where I'm saying this data is

00:40:45,469 --> 00:40:51,799
not allowed and

00:40:47,119 --> 00:40:53,749
unless it matches this requirement so DB

00:40:51,799 --> 00:40:57,440
record is this digit sir for instance

00:40:53,749 --> 00:40:59,660
email address this data must look like

00:40:57,440 --> 00:41:02,059
an email address if it doesn't look like

00:40:59,660 --> 00:41:04,339
an email address I am not accepting it

00:41:02,059 --> 00:41:07,130
I'm not going to try and guess what you

00:41:04,339 --> 00:41:10,970
meant I'm just saying no that's what

00:41:07,130 --> 00:41:13,069
validation does you just say no in this

00:41:10,970 --> 00:41:14,839
particular case I've got a VAR child 100

00:41:13,069 --> 00:41:18,529
so I guess like a string length field

00:41:14,839 --> 00:41:20,950
validator on sorry and then at my

00:41:18,529 --> 00:41:22,970
validator and I can then set an option

00:41:20,950 --> 00:41:25,130
these are the options for the string

00:41:22,970 --> 00:41:29,900
length one I pick max and I give it a

00:41:25,130 --> 00:41:33,380
value of 100 sone optically complicated

00:41:29,900 --> 00:41:39,440
I've now set up a 100 masculine swear

00:41:33,380 --> 00:41:41,180
string length obviously I do this for

00:41:39,440 --> 00:41:42,980
every other field but I'm not gonna

00:41:41,180 --> 00:41:44,180
waste your time and show you me doing it

00:41:42,980 --> 00:41:51,499
on screencast because that's pretty

00:41:44,180 --> 00:41:54,049
boring just to see I've done it ok so

00:41:51,499 --> 00:41:57,890
there we go that's fields in our admin

00:41:54,049 --> 00:42:01,430
system and we now have validation if we

00:41:57,890 --> 00:42:05,170
post with an empty title or an empty

00:42:01,430 --> 00:42:10,640
artists rather then we're going to get a

00:42:05,170 --> 00:42:14,690
42 42 I'm processable entity it is an

00:42:10,640 --> 00:42:17,059
HTTP problem structured response so

00:42:14,690 --> 00:42:19,579
we've got a detail which is valid ation

00:42:17,059 --> 00:42:22,640
we've got the status code again we have

00:42:19,579 --> 00:42:25,999
the title which is always the same as

00:42:22,640 --> 00:42:29,720
the status code name we have the

00:42:25,999 --> 00:42:31,999
particular part of RFC 26.6 to why we've

00:42:29,720 --> 00:42:33,739
done this and then we give the

00:42:31,999 --> 00:42:39,049
validation messages so all the nice

00:42:33,739 --> 00:42:41,779
things about HTTP HTTP is that we can

00:42:39,049 --> 00:42:44,569
add additional data that's relevant for

00:42:41,779 --> 00:42:46,279
the particular error response we are

00:42:44,569 --> 00:42:49,099
sending so if you're going to fail a

00:42:46,279 --> 00:42:52,190
validation thing it's good manners to

00:42:49,099 --> 00:42:54,259
tell the clients what they failed on so

00:42:52,190 --> 00:42:56,450
in this case value is required and can't

00:42:54,259 --> 00:42:58,989
be empty you could obviously customize

00:42:56,450 --> 00:42:58,989
the messages

00:43:00,130 --> 00:43:05,119
one of the side effects of having done

00:43:02,900 --> 00:43:07,790
this via the administration system is

00:43:05,119 --> 00:43:10,869
that we've now got structured

00:43:07,790 --> 00:43:14,569
information about the data that this API

00:43:10,869 --> 00:43:16,190
accepts if we have structured data about

00:43:14,569 --> 00:43:19,520
something where you can turn it into

00:43:16,190 --> 00:43:23,420
documentation so you get documentation

00:43:19,520 --> 00:43:24,619
for your API for free pretty much you

00:43:23,420 --> 00:43:29,569
still have to write you have to write

00:43:24,619 --> 00:43:32,720
some stuff not me someone else I'm not

00:43:29,569 --> 00:43:34,339
very good - it's automatically populated

00:43:32,720 --> 00:43:38,720
via the validation and the filtering

00:43:34,339 --> 00:43:41,960
admin and it creates an new endpoint on

00:43:38,720 --> 00:43:45,079
your API which is such opportunities

00:43:41,960 --> 00:43:48,230
flash documentation slash API name slash

00:43:45,079 --> 00:43:51,380
version which will provide your clients

00:43:48,230 --> 00:43:55,849
with the documentation about that

00:43:51,380 --> 00:43:58,640
endpoint because it's an opportunity

00:43:55,849 --> 00:44:00,770
system in and of itself it responds to

00:43:58,640 --> 00:44:02,540
both Jason and HTML so you hit it with

00:44:00,770 --> 00:44:05,660
the browser you'll get a pretty format

00:44:02,540 --> 00:44:08,450
if you hit it with an accept JSON header

00:44:05,660 --> 00:44:11,420
then you'll get back jason version of

00:44:08,450 --> 00:44:13,819
your documentation which means your

00:44:11,420 --> 00:44:17,119
clients can then take that data and do

00:44:13,819 --> 00:44:18,920
something with it if they need to and we

00:44:17,119 --> 00:44:20,780
also support swagger so that you can

00:44:18,920 --> 00:44:24,049
export the documentation in swagger

00:44:20,780 --> 00:44:28,760
format - and there you go you get some

00:44:24,049 --> 00:44:31,700
pretty sort of data comes there's some

00:44:28,760 --> 00:44:34,400
sort of information about your albums in

00:44:31,700 --> 00:44:36,770
this case sash albums the get response

00:44:34,400 --> 00:44:40,819
has got these fields this information

00:44:36,770 --> 00:44:44,230
about them first database connected

00:44:40,819 --> 00:44:48,230
services code connected services provide

00:44:44,230 --> 00:44:52,240
more classes there's more places future

00:44:48,230 --> 00:44:54,829
into your own code so here we have a

00:44:52,240 --> 00:44:57,650
loan resource alone collection and a

00:44:54,829 --> 00:45:01,670
loan entity if we're going to create say

00:44:57,650 --> 00:45:04,010
I want to lend out my music albums in

00:45:01,670 --> 00:45:07,609
the role own resource class this is

00:45:04,010 --> 00:45:09,619
equivalent of our PC controller so the

00:45:07,609 --> 00:45:12,520
learning resource class will have eight

00:45:09,619 --> 00:45:15,550
methods in it for for Delia collection

00:45:12,520 --> 00:45:17,620
and for for dinner with entities so

00:45:15,550 --> 00:45:20,370
fetch all create replaced list and

00:45:17,620 --> 00:45:24,310
delete list work on the collection and

00:45:20,370 --> 00:45:30,220
fetch patch update and delete we'll work

00:45:24,310 --> 00:45:32,680
on the entity for single resource you

00:45:30,220 --> 00:45:34,390
have to write your own code so you'll be

00:45:32,680 --> 00:45:36,010
writing your entities you'll be writing

00:45:34,390 --> 00:45:38,290
your own services that do your

00:45:36,010 --> 00:45:42,580
persistence for you that's all your

00:45:38,290 --> 00:45:45,130
problem and then you fill in your

00:45:42,580 --> 00:45:46,840
resource so fetch all for instance you

00:45:45,130 --> 00:45:48,970
might hit your service and call fetch

00:45:46,840 --> 00:45:50,620
all create delete etc you gonna have to

00:45:48,970 --> 00:45:52,840
fill them in yourself you're doing all

00:45:50,620 --> 00:45:56,290
the work we have provided the skeleton

00:45:52,840 --> 00:46:02,080
it's your API you can write as complex

00:45:56,290 --> 00:46:05,340
on API as you would like final thing I

00:46:02,080 --> 00:46:05,340
want to talk about is authentication

00:46:05,400 --> 00:46:11,050
generally it's a good idea to

00:46:07,570 --> 00:46:13,990
authenticate your ap is particularly if

00:46:11,050 --> 00:46:16,300
you're accepting data from outside it's

00:46:13,990 --> 00:46:20,920
not a bad idea to know who has given you

00:46:16,300 --> 00:46:24,070
that data and who screwed up we support

00:46:20,920 --> 00:46:26,350
a variety of authentication methods the

00:46:24,070 --> 00:46:28,990
most common ones are HTTP basic and our

00:46:26,350 --> 00:46:31,210
wolf - if you are writing an internal

00:46:28,990 --> 00:46:36,630
API there's only used within your

00:46:31,210 --> 00:46:40,360
intranet HTTP basic is fine use SSL

00:46:36,630 --> 00:46:42,970
phase 5 it's not a problem if you're

00:46:40,360 --> 00:46:44,980
doing public api's particularly if

00:46:42,970 --> 00:46:48,310
you're doing a public API that has got

00:46:44,980 --> 00:46:51,700
third-party applications that users of

00:46:48,310 --> 00:46:55,060
your service are connecting via a wolf's

00:46:51,700 --> 00:46:56,680
who is of the way to do it don't try and

00:46:55,060 --> 00:47:01,060
invent your own system just use our wolf

00:46:56,680 --> 00:47:02,770
to its built-in that makes it easier if

00:47:01,060 --> 00:47:04,840
you need to connect via authenticate via

00:47:02,770 --> 00:47:06,760
LDAP or something like that then you can

00:47:04,840 --> 00:47:09,040
hook into events within the system and

00:47:06,760 --> 00:47:13,750
do your own authentication it's not a

00:47:09,040 --> 00:47:15,820
problem basically a basic user safety

00:47:13,750 --> 00:47:19,510
password file it's very similar to the

00:47:15,820 --> 00:47:21,310
Apache system detects feed digest I was

00:47:19,510 --> 00:47:23,920
- will use databases because you know

00:47:21,310 --> 00:47:26,380
need creates tokens and things like that

00:47:23,920 --> 00:47:29,350
there's a couple of good resources there

00:47:26,380 --> 00:47:31,960
to learn on how we do it be sure furs

00:47:29,350 --> 00:47:37,170
are off to server is the underlying

00:47:31,960 --> 00:47:37,170
component opportunity uses for OAuth 2

00:47:38,430 --> 00:47:43,300
and it's set up via the admin as you'd

00:47:41,740 --> 00:47:46,300
expect you fill in some information

00:47:43,300 --> 00:47:47,740
about your database and then the process

00:47:46,300 --> 00:47:49,750
is quite simple you need to get an

00:47:47,740 --> 00:47:51,580
access token and then you need to send

00:47:49,750 --> 00:47:52,690
it on subsequent requests so it's a

00:47:51,580 --> 00:47:55,360
client it's not particularly complicated

00:47:52,690 --> 00:47:57,520
once I've gotten access token I send

00:47:55,360 --> 00:48:00,340
that header and because I send that

00:47:57,520 --> 00:48:05,350
header every single time I am still

00:48:00,340 --> 00:48:08,740
stateless no sessions involved the

00:48:05,350 --> 00:48:10,710
password grant type is simplest your

00:48:08,740 --> 00:48:13,150
client sends a username and password

00:48:10,710 --> 00:48:17,800
directly to the OAuth end point and

00:48:13,150 --> 00:48:21,550
returns the access token directly I only

00:48:17,800 --> 00:48:23,980
do this for trusted clients so if you're

00:48:21,550 --> 00:48:25,480
writing the robot app you can allow your

00:48:23,980 --> 00:48:27,520
users to type the username and password

00:48:25,480 --> 00:48:31,960
into the mobile app you can use a

00:48:27,520 --> 00:48:35,410
password grant type if the mobile app is

00:48:31,960 --> 00:48:38,200
not written by you and issue all users

00:48:35,410 --> 00:48:39,580
so type in into it then you don't want

00:48:38,200 --> 00:48:41,590
to be give they don't want to give their

00:48:39,580 --> 00:48:43,810
user and password to that third party

00:48:41,590 --> 00:48:46,870
client and there's an authorization code

00:48:43,810 --> 00:48:49,090
workflow for that particular lawyer so

00:48:46,870 --> 00:48:52,330
in this case the third party client

00:48:49,090 --> 00:48:58,570
redirects to the app agility URL yes you

00:48:52,330 --> 00:49:01,570
can skin it and the user logs in on your

00:48:58,570 --> 00:49:04,360
system and then authorizes the client

00:49:01,570 --> 00:49:07,120
test client in this case and then that

00:49:04,360 --> 00:49:13,480
redirects back to the mobile client with

00:49:07,120 --> 00:49:14,890
the correct access token again so it's

00:49:13,480 --> 00:49:17,500
not particularly complicated to

00:49:14,890 --> 00:49:19,510
implement a wolf - there's not a lot you

00:49:17,500 --> 00:49:24,040
have to do for it it's built into the

00:49:19,510 --> 00:49:27,610
system you get to choose which

00:49:24,040 --> 00:49:29,290
particular methods require an

00:49:27,610 --> 00:49:33,760
authentication or an authorization

00:49:29,290 --> 00:49:36,310
header in order to run so I can tick in

00:49:33,760 --> 00:49:39,340
the admin system that if you're going to

00:49:36,310 --> 00:49:40,090
edit the data post patch put or delete

00:49:39,340 --> 00:49:42,190
then

00:49:40,090 --> 00:49:44,560
would like you to be logged in but if

00:49:42,190 --> 00:49:46,390
you just want to retrieve data no

00:49:44,560 --> 00:49:48,730
problem I don't need you to be logged in

00:49:46,390 --> 00:49:52,420
for that Twitter of course disagrees

00:49:48,730 --> 00:49:55,060
with me on that one obviously you can do

00:49:52,420 --> 00:49:57,160
it via code as well so there's a method

00:49:55,060 --> 00:49:59,530
called this gate identity which you can

00:49:57,160 --> 00:50:02,380
then test if it is an identity object if

00:49:59,530 --> 00:50:04,120
it is then you have a logged in user if

00:50:02,380 --> 00:50:06,600
it isn't you don't have a logged in user

00:50:04,120 --> 00:50:10,360
very very simple code to write

00:50:06,600 --> 00:50:15,310
authentication is very very easy it's

00:50:10,360 --> 00:50:19,660
also very boring so that's it that's an

00:50:15,310 --> 00:50:22,030
introduction to a fragility it provides

00:50:19,660 --> 00:50:24,790
the boring bits that's what I like about

00:50:22,030 --> 00:50:27,010
it it does the stuff that I think is

00:50:24,790 --> 00:50:28,810
fairly tedious to write I think it's the

00:50:27,010 --> 00:50:30,940
sort of stuff that people don't want to

00:50:28,810 --> 00:50:32,800
write so having it baked into a

00:50:30,940 --> 00:50:34,990
framework I think solves a number of

00:50:32,800 --> 00:50:36,640
problems particularly for the type of

00:50:34,990 --> 00:50:39,360
clients I have which are quite

00:50:36,640 --> 00:50:43,180
enterprise-e for content negotiation

00:50:39,360 --> 00:50:46,810
discovery error reporting version etc

00:50:43,180 --> 00:50:53,410
all very very helpful features of this

00:50:46,810 --> 00:51:00,100
tool and I'm talking as anyone got any

00:50:53,410 --> 00:51:03,750
questions all over here we need the man

00:51:00,100 --> 00:51:03,750
with that mic who's disappeared

00:51:06,770 --> 00:51:13,780
you've got the mic man at the front here

00:51:20,500 --> 00:51:36,280
who had question how opportunity

00:51:29,940 --> 00:51:38,230
integrates with testing how'd you test

00:51:36,280 --> 00:51:40,660
your api's you can do it number of

00:51:38,230 --> 00:51:44,770
levels firstly you've got your source

00:51:40,660 --> 00:51:48,490
code needs to worry about and I use PHP

00:51:44,770 --> 00:51:51,190
unit for testing my source code and it's

00:51:48,490 --> 00:51:53,560
no different from testing any other type

00:51:51,190 --> 00:51:55,690
of framework based application which

00:51:53,560 --> 00:51:58,480
means that all your real code should not

00:51:55,690 --> 00:52:00,160
be part of the framework the framework

00:51:58,480 --> 00:52:03,280
is called the framework is doing it

00:52:00,160 --> 00:52:06,160
stuff your code lives in your modules in

00:52:03,280 --> 00:52:08,950
your libraries and you test those so the

00:52:06,160 --> 00:52:10,990
only bit where you're crossing over is

00:52:08,950 --> 00:52:13,000
through the DI container so you're

00:52:10,990 --> 00:52:16,030
injecting your business logic or your

00:52:13,000 --> 00:52:18,849
business code into a Fidelity's resource

00:52:16,030 --> 00:52:21,130
so you only need to unit test a resource

00:52:18,849 --> 00:52:23,320
class which should be really really

00:52:21,130 --> 00:52:25,540
simple because most of the work is

00:52:23,320 --> 00:52:28,420
delegated out to your actual code base

00:52:25,540 --> 00:52:31,560
your actual business logic which is

00:52:28,420 --> 00:52:34,650
independently testable from a fertility

00:52:31,560 --> 00:52:37,510
miner rant but that holds for any

00:52:34,650 --> 00:52:39,730
application you're writing so if you're

00:52:37,510 --> 00:52:41,770
writing a symphony to up or something

00:52:39,730 --> 00:52:44,170
like that for instance or some framework

00:52:41,770 --> 00:52:46,410
tool or laravel or whatever your code

00:52:44,170 --> 00:52:48,849
should live independent of the framework

00:52:46,410 --> 00:52:50,109
if you're doing your job right your code

00:52:48,849 --> 00:52:52,810
will live longer than whichever

00:52:50,109 --> 00:52:54,820
framework you're currently using so keep

00:52:52,810 --> 00:52:56,890
it separate keep it separately tested so

00:52:54,820 --> 00:52:58,869
that's the actual code yourself then

00:52:56,890 --> 00:53:01,630
there's a concept of integration testing

00:52:58,869 --> 00:53:03,270
of some form or another frisbees not bad

00:53:01,630 --> 00:53:06,250
for that and then if you fail at all

00:53:03,270 --> 00:53:08,320
it's so JavaScript based thing it runs

00:53:06,250 --> 00:53:10,869
on mode which I don't understand as well

00:53:08,320 --> 00:53:12,820
as I want to and that hits your end

00:53:10,869 --> 00:53:14,530
points for you and it's obviously

00:53:12,820 --> 00:53:17,230
integration testing at this point and I

00:53:14,530 --> 00:53:22,210
find that quite handy for testing api's

00:53:17,230 --> 00:53:25,960
before I put them live so help any other

00:53:22,210 --> 00:53:28,060
questions and yep I was wondering how

00:53:25,960 --> 00:53:30,970
you would integrate

00:53:28,060 --> 00:53:32,860
code created by a virginity into a

00:53:30,970 --> 00:53:35,680
different framework I assumed all the

00:53:32,860 --> 00:53:39,430
error messages and movie adjacent

00:53:35,680 --> 00:53:42,280
formatting is via one of the classes you

00:53:39,430 --> 00:53:44,440
extend but for example I use laravel

00:53:42,280 --> 00:53:47,140
that already has a base controller that

00:53:44,440 --> 00:53:52,420
the controller's extend so you can't

00:53:47,140 --> 00:53:54,100
extend this not very well no and you've

00:53:52,420 --> 00:53:55,510
got two ways to do it one you can treat

00:53:54,100 --> 00:53:58,120
your API is independent from your

00:53:55,510 --> 00:54:01,560
current system particularly if you split

00:53:58,120 --> 00:54:05,200
up your business logic properly

00:54:01,560 --> 00:54:08,890
alternatively underneath the hood all of

00:54:05,200 --> 00:54:11,650
appaji lets code is separate components

00:54:08,890 --> 00:54:13,950
in packages so there is a component of

00:54:11,650 --> 00:54:17,350
practice that does the JSON formatting

00:54:13,950 --> 00:54:18,820
so you could grab that component out of

00:54:17,350 --> 00:54:21,970
practice and put it into your system

00:54:18,820 --> 00:54:24,910
that however your view model integrates

00:54:21,970 --> 00:54:26,110
in I've got no idea and hooking through

00:54:24,910 --> 00:54:30,280
that way if you need to pull out those

00:54:26,110 --> 00:54:32,350
particular bits your kind of sorts are

00:54:30,280 --> 00:54:34,090
just read using the interesting bits of

00:54:32,350 --> 00:54:51,910
the opportunity tool in your own project

00:54:34,090 --> 00:54:53,440
you could certainly do that the

00:54:51,910 --> 00:54:55,360
documentation that you get out of the

00:54:53,440 --> 00:54:58,150
box if you use the database connected

00:54:55,360 --> 00:55:01,090
one is that still something you can

00:54:58,150 --> 00:55:04,390
achieve with the code base one yeah when

00:55:01,090 --> 00:55:07,620
I use the code connected API service I'm

00:55:04,390 --> 00:55:10,360
still using the same validation system

00:55:07,620 --> 00:55:13,870
because the validation system works over

00:55:10,360 --> 00:55:16,930
any API within a facility and it fails

00:55:13,870 --> 00:55:20,260
early it fails really early in the

00:55:16,930 --> 00:55:22,090
system so I always use the validation

00:55:20,260 --> 00:55:24,520
system built into a facility hence that

00:55:22,090 --> 00:55:26,320
will also works with Co connected and it

00:55:24,520 --> 00:55:26,740
works with DB connected straight off the

00:55:26,320 --> 00:55:28,540
bat

00:55:26,740 --> 00:55:30,070
so you because you're filled in that

00:55:28,540 --> 00:55:35,040
data you get the documentation by

00:55:30,070 --> 00:55:35,040
definition does that answer

00:55:35,140 --> 00:55:42,560
nope hi I was wondering if you have

00:55:39,589 --> 00:55:45,619
implemented validation in your code that

00:55:42,560 --> 00:55:47,589
you said sit separately to the framework

00:55:45,619 --> 00:55:50,180
you're within can you bubble up

00:55:47,589 --> 00:55:55,550
validation messages from there and have

00:55:50,180 --> 00:55:57,680
it have the agility server back yes you

00:55:55,550 --> 00:56:00,079
can very very loosely if you throw an

00:55:57,680 --> 00:56:03,410
exception it turns into an API problem

00:56:00,079 --> 00:56:05,990
response so I do validates my

00:56:03,410 --> 00:56:08,200
independent code because my code goes

00:56:05,990 --> 00:56:10,520
for two in multiple different frameworks

00:56:08,200 --> 00:56:12,260
you've got the API running it and I've

00:56:10,520 --> 00:56:14,540
also got a website that's not talking by

00:56:12,260 --> 00:56:17,690
the API just talks directly so I've got

00:56:14,540 --> 00:56:19,369
one model layer if you like hence I have

00:56:17,690 --> 00:56:22,130
validation in there and it does

00:56:19,369 --> 00:56:24,440
propagate up here I'm little old-school

00:56:22,130 --> 00:56:27,170
so it returns actually returns error

00:56:24,440 --> 00:56:28,760
type objects out of my system and then I

00:56:27,170 --> 00:56:30,500
throw the exceptions within either the

00:56:28,760 --> 00:56:33,020
opportunity code or however I'm doing it

00:56:30,500 --> 00:56:34,579
in the other app yes you can certainly

00:56:33,020 --> 00:56:36,920
do that you don't have to use a

00:56:34,579 --> 00:56:42,440
validation system it's just as

00:56:36,920 --> 00:56:44,380
convenient to do so and honest yes ever

00:56:42,440 --> 00:56:47,270
a question mhm

00:56:44,380 --> 00:56:50,450
where I work for example the front end

00:56:47,270 --> 00:56:53,210
is in angularjs okay so they don't want

00:56:50,450 --> 00:56:55,670
the results page for example twenty

00:56:53,210 --> 00:56:58,579
results for page they want to do the

00:56:55,670 --> 00:57:01,720
paging on the client side okay

00:56:58,579 --> 00:57:05,720
however if I send all of the results

00:57:01,720 --> 00:57:09,980
it's too slow yes then it almost needs

00:57:05,720 --> 00:57:12,700
to be a way to not do paging but you

00:57:09,980 --> 00:57:16,940
know limit the results in some sort of

00:57:12,700 --> 00:57:18,410
based on the size of the result it's

00:57:16,940 --> 00:57:21,140
very difficult do you have any insight

00:57:18,410 --> 00:57:24,920
into that you need to teach your angular

00:57:21,140 --> 00:57:27,770
people to accept the real world very

00:57:24,920 --> 00:57:29,210
roughly we call it pagination but what

00:57:27,770 --> 00:57:34,400
we actually mean is limited limited

00:57:29,210 --> 00:57:36,470
result sets and there is no sane way to

00:57:34,400 --> 00:57:38,569
write an API without limiting result

00:57:36,470 --> 00:57:42,470
sets or collections it has to be done

00:57:38,569 --> 00:57:44,329
and it's not difficult in angular to go

00:57:42,470 --> 00:57:47,210
and do two requests to get all the data

00:57:44,329 --> 00:57:48,470
it's really not hard and the entire app

00:57:47,210 --> 00:57:51,410
agility admin

00:57:48,470 --> 00:57:54,080
that's an angularjs app it talks to an

00:57:51,410 --> 00:57:58,520
app agility at API that actually does

00:57:54,080 --> 00:58:00,520
all the codes creation work so my

00:57:58,520 --> 00:58:03,619
personal view is that you teach your

00:58:00,520 --> 00:58:05,210
endpoint clients your API clones which I

00:58:03,619 --> 00:58:07,400
know they're part of your team or part

00:58:05,210 --> 00:58:10,190
your company to accept the reality of

00:58:07,400 --> 00:58:12,950
how api's work and accept that they have

00:58:10,190 --> 00:58:14,510
to do that this you can't have it both

00:58:12,950 --> 00:58:15,980
ways if you give them all the data it's

00:58:14,510 --> 00:58:19,280
going to be slow and this guy ran out of

00:58:15,980 --> 00:58:23,420
memory on a mobile device so you have to

00:58:19,280 --> 00:58:29,240
give them a window into that device not

00:58:23,420 --> 00:58:32,690
sure that helps and on us thank you for

00:58:29,240 --> 00:58:36,349
a little how does it handle connections

00:58:32,690 --> 00:58:38,810
between entities let's say that artists

00:58:36,349 --> 00:58:42,830
have many albums and if I make a call to

00:58:38,810 --> 00:58:46,520
slash artists / - slash album gems

00:58:42,830 --> 00:58:51,040
get me albums of that honest right in a

00:58:46,520 --> 00:58:54,650
database connected API as of today no

00:58:51,040 --> 00:58:58,940
dates face connected API is our only one

00:58:54,650 --> 00:59:01,609
table one crud system 1.1 is coming the

00:58:58,940 --> 00:59:04,220
next version there's some work being

00:59:01,609 --> 00:59:06,589
done on that for automatic discovery I'm

00:59:04,220 --> 00:59:08,330
not sure how far it will go so the way

00:59:06,589 --> 00:59:10,400
you actually do sub resources and sub

00:59:08,330 --> 00:59:13,070
collections and things like that is via

00:59:10,400 --> 00:59:16,010
the coconuts at API at which point you

00:59:13,070 --> 00:59:17,480
can do what if you like one really

00:59:16,010 --> 00:59:19,280
common way that's being used in the

00:59:17,480 --> 00:59:22,070
number of companies is using doctrine

00:59:19,280 --> 00:59:26,000
and there's a connector from ability to

00:59:22,070 --> 00:59:27,920
doctrine a packages components because

00:59:26,000 --> 00:59:29,060
everything's on packages nowadays so

00:59:27,920 --> 00:59:31,280
you're going to find that component you

00:59:29,060 --> 00:59:36,380
plug it in and now after you've kind of

00:59:31,280 --> 00:59:37,910
doctoring away and go from there all

00:59:36,380 --> 00:59:42,550
right over yourself that's my preferred

00:59:37,910 --> 00:59:42,550

YouTube URL: https://www.youtube.com/watch?v=D_mcntk4tXI


