Title: James Titcumb - Adding 1.21 Gigawatts to Applications with RabbitMQ
Publication date: 2015-04-02
Playlist: PHP UK Conference 2015
Description: 
	As your application grows, you soon realise you need to break up your application into smaller chunks that talk to each other. You could just use web services to interact, or you could take a more robust approach and use the message broker RabbitMQ. In this talk, we will take a look at the techniques you can use to vastly enhance inter-application communication, learn about the core concepts of RabbitMQ, cover how you can scale different parts of your application separately, and modernise your development using a message-oriented architecture.

http://www.slideshare.net/asgrim1/adding-121-gigawatts-to-applications-with-rabbitmq-php-uk-2015
Captions: 
	00:00:05,330 --> 00:00:09,920
um James titcombe nice to see you all

00:00:08,300 --> 00:00:11,809
here why don't awake ready to learn

00:00:09,920 --> 00:00:15,769
things and I'm going to tell you about

00:00:11,809 --> 00:00:18,110
RabbitMQ today I've been doing PHP for

00:00:15,769 --> 00:00:21,500
like 12 13 years I'm Zen certified

00:00:18,110 --> 00:00:23,720
engineer which makes me Pro something

00:00:21,500 --> 00:00:25,520
I run the PHP Hampshire user group down

00:00:23,720 --> 00:00:29,119
the south coast of the UK if you're not

00:00:25,520 --> 00:00:31,970
from the UK I'm also starting a

00:00:29,119 --> 00:00:36,200
conference with a lot of buddies called

00:00:31,970 --> 00:00:37,399
PHP South Coast that's South Coast it'd

00:00:36,200 --> 00:00:39,559
be great if you could come along to that

00:00:37,399 --> 00:00:42,530
as well then more things we've got some

00:00:39,559 --> 00:00:43,820
great speakers anyway I am the

00:00:42,530 --> 00:00:47,030
development manager a place called

00:00:43,820 --> 00:00:50,030
protected Kok and for the context of

00:00:47,030 --> 00:00:52,370
this talk what the sort of things we do

00:00:50,030 --> 00:00:54,260
there are just in-house products so we

00:00:52,370 --> 00:01:00,320
make like a CRM tracking analytic

00:00:54,260 --> 00:01:02,749
systems and the website itself so let's

00:01:00,320 --> 00:01:07,960
move on to the talk what is Message

00:01:02,749 --> 00:01:09,980
Queuing well in its very simplest form a

00:01:07,960 --> 00:01:12,590
message to you is something where you

00:01:09,980 --> 00:01:15,770
can put a message in it puts it in a

00:01:12,590 --> 00:01:18,650
queue and something else takes it out of

00:01:15,770 --> 00:01:22,730
the queue right so we're all fairly

00:01:18,650 --> 00:01:27,050
familiar with really simple queues for

00:01:22,730 --> 00:01:29,750
example an array is a queue when you use

00:01:27,050 --> 00:01:32,930
something like RabbitMQ it's quite nice

00:01:29,750 --> 00:01:35,690
because a term that I actually first

00:01:32,930 --> 00:01:40,220
heard from the guy sitting here was

00:01:35,690 --> 00:01:41,690
fire-and-forget and that means basically

00:01:40,220 --> 00:01:43,370
you you give a message and you can

00:01:41,690 --> 00:01:47,390
forget about what happens to the message

00:01:43,370 --> 00:01:48,680
once it's in the queue so the fancy term

00:01:47,390 --> 00:01:53,390
for this is message oriented

00:01:48,680 --> 00:01:55,490
architecture and it's in concept quite

00:01:53,390 --> 00:01:58,450
similar to something you may we'll a

00:01:55,490 --> 00:02:00,230
little more familiar with which is

00:01:58,450 --> 00:02:01,670
service-oriented architecture

00:02:00,230 --> 00:02:06,410
these are big words and it's the first

00:02:01,670 --> 00:02:07,790
thing in the morning so I apologize what

00:02:06,410 --> 00:02:11,090
it means is you can asynchronously

00:02:07,790 --> 00:02:13,040
process data but you get a synchronous

00:02:11,090 --> 00:02:15,710
acknowledgment that that data is going

00:02:13,040 --> 00:02:18,140
to get processed so you know agreement

00:02:15,710 --> 00:02:19,800
that this data is going to be processed

00:02:18,140 --> 00:02:22,680
later

00:02:19,800 --> 00:02:27,129
it allows you to separate your concerns

00:02:22,680 --> 00:02:28,300
so one of the beauties of RabbitMQ is

00:02:27,129 --> 00:02:31,450
that you can use it with loads of

00:02:28,300 --> 00:02:35,940
different languages PHP c-sharp Java

00:02:31,450 --> 00:02:38,680
node anything anything that talks AMQP

00:02:35,940 --> 00:02:42,569
which stands for advanced message queue

00:02:38,680 --> 00:02:46,209
protocol and this is an iso standard

00:02:42,569 --> 00:02:48,160
protocol now it was in the last year or

00:02:46,209 --> 00:02:51,370
so made into a real standard if you like

00:02:48,160 --> 00:02:55,420
and it's an open protocol so not just

00:02:51,370 --> 00:03:00,700
RabbitMQ speaks AMQP but that's just one

00:02:55,420 --> 00:03:03,810
broker message broker that does so by

00:03:00,700 --> 00:03:05,739
separating out your application a real

00:03:03,810 --> 00:03:08,620
benefit that you're going to get from

00:03:05,739 --> 00:03:12,160
this is that you can scale parts of your

00:03:08,620 --> 00:03:16,629
applications separately which is really

00:03:12,160 --> 00:03:19,599
cool and the separation allows you to do

00:03:16,629 --> 00:03:21,459
background processing while your

00:03:19,599 --> 00:03:24,389
front-end for example our website

00:03:21,459 --> 00:03:26,829
carries on just serving up web pages and

00:03:24,389 --> 00:03:29,139
then in the background we've got

00:03:26,829 --> 00:03:33,310
something processing lots of data making

00:03:29,139 --> 00:03:36,190
reports whatever and the the reason that

00:03:33,310 --> 00:03:37,359
happens and works so well is because you

00:03:36,190 --> 00:03:39,069
only have to wait for the message to be

00:03:37,359 --> 00:03:42,280
queued you don't have to wait for that

00:03:39,069 --> 00:03:43,900
data to be processed and that allows you

00:03:42,280 --> 00:03:50,650
to scale and let's have a quick look at

00:03:43,900 --> 00:03:53,489
how so say for example we have our

00:03:50,650 --> 00:03:58,030
front-end application over on the Left

00:03:53,489 --> 00:04:01,299
we're putting messages into a queue at a

00:03:58,030 --> 00:04:03,760
rate of five per second now a background

00:04:01,299 --> 00:04:06,660
processor can only handle one per second

00:04:03,760 --> 00:04:08,980
it's a bit slow it does something slow

00:04:06,660 --> 00:04:11,079
every second four messages are going to

00:04:08,980 --> 00:04:12,030
build up and the queues are going to

00:04:11,079 --> 00:04:14,910
fill up pretty fast

00:04:12,030 --> 00:04:18,010
so what rabbitmq allows you to do is

00:04:14,910 --> 00:04:21,039
connect another processor and another

00:04:18,010 --> 00:04:23,020
and another until you reach a point

00:04:21,039 --> 00:04:25,229
where all the queues are being processed

00:04:23,020 --> 00:04:28,270
at the same rate as they're being put in

00:04:25,229 --> 00:04:30,450
ice is a really linear simplified

00:04:28,270 --> 00:04:30,450
example

00:04:30,660 --> 00:04:36,870
and in reality the number of consumers

00:04:34,200 --> 00:04:40,260
thank you depends on the average queue

00:04:36,870 --> 00:04:42,750
size how actually fast you want the

00:04:40,260 --> 00:04:44,490
messages to be processed so you have a

00:04:42,750 --> 00:04:46,380
spike in traffic which causes all your

00:04:44,490 --> 00:04:47,760
cues to fill up maybe it doesn't matter

00:04:46,380 --> 00:04:49,260
so much that the data doesn't get

00:04:47,760 --> 00:04:51,210
processed straight away because the

00:04:49,260 --> 00:04:54,210
spike in traffic is going to tail off

00:04:51,210 --> 00:04:58,680
and then your messages can get processed

00:04:54,210 --> 00:05:00,000
after that event has happened but if you

00:04:58,680 --> 00:05:01,980
do need that stuff to be processed

00:05:00,000 --> 00:05:04,980
really quickly you can just connect more

00:05:01,980 --> 00:05:08,640
consumers to process all this data

00:05:04,980 --> 00:05:14,760
coming through right and it allows you

00:05:08,640 --> 00:05:15,900
to scale to demand if you want and when

00:05:14,760 --> 00:05:17,850
you're looking at the queues and thing

00:05:15,900 --> 00:05:18,960
you are they're filling up quick you

00:05:17,850 --> 00:05:20,760
don't want to be doing that all the time

00:05:18,960 --> 00:05:23,490
so you can use monitoring software like

00:05:20,760 --> 00:05:26,640
Nagios or something to monitor the queue

00:05:23,490 --> 00:05:31,290
size check the throughput is fine and

00:05:26,640 --> 00:05:34,080
acceptable okay so so far it's a fairly

00:05:31,290 --> 00:05:36,570
abstract okay what's some real world

00:05:34,080 --> 00:05:39,900
uses what do we use RabbitMQ where I

00:05:36,570 --> 00:05:43,650
work for we use it for sending emails

00:05:39,900 --> 00:05:46,590
because SMTP can be sometimes slow we

00:05:43,650 --> 00:05:50,400
use it send SMS messages because they

00:05:46,590 --> 00:05:52,590
are a little bit slow sometimes we use

00:05:50,400 --> 00:05:54,480
analytics and reporting through the

00:05:52,590 --> 00:05:57,690
system so when we want a report to be

00:05:54,480 --> 00:06:01,860
run in our tracking system that report

00:05:57,690 --> 00:06:05,970
request goes via MQ to be dealt with by

00:06:01,860 --> 00:06:09,030
the by the report reporting server we do

00:06:05,970 --> 00:06:12,300
data warehousing as well so aggregating

00:06:09,030 --> 00:06:15,150
all our data into a much more sane

00:06:12,300 --> 00:06:17,490
format is all done in the background on

00:06:15,150 --> 00:06:21,600
these background servers and also

00:06:17,490 --> 00:06:25,860
logging all of our applications as loads

00:06:21,600 --> 00:06:27,960
and loads of logging and that's done via

00:06:25,860 --> 00:06:31,200
RabbitMQ I'll show you a little example

00:06:27,960 --> 00:06:37,340
in a bit later on if how that actually

00:06:31,200 --> 00:06:37,340
works so why rabbitmq

00:06:39,010 --> 00:06:44,770
it's a question I get asked a lot and

00:06:42,790 --> 00:06:47,260
the answer to that is well it's really

00:06:44,770 --> 00:06:50,080
simple to start with you can get up and

00:06:47,260 --> 00:06:53,080
running with RabbitMQ in not very long

00:06:50,080 --> 00:06:56,590
maybe 20 minutes or so it's really

00:06:53,080 --> 00:06:58,419
flexible though okay so yes it takes in

00:06:56,590 --> 00:07:00,669
a very long to get up and running and

00:06:58,419 --> 00:07:02,980
start understanding the basic concepts

00:07:00,669 --> 00:07:04,810
but it gets really flexible you can

00:07:02,980 --> 00:07:07,750
rescale up this system make it as

00:07:04,810 --> 00:07:09,780
complicated as you like and as I

00:07:07,750 --> 00:07:15,240
mentioned before it's really scalable

00:07:09,780 --> 00:07:18,460
scaleable is cool and another thing is

00:07:15,240 --> 00:07:19,990
say use something or you have experience

00:07:18,460 --> 00:07:23,979
with something called gear man which

00:07:19,990 --> 00:07:25,270
just does a similar sort of job I have

00:07:23,979 --> 00:07:27,760
no idea what's going on with the game

00:07:25,270 --> 00:07:31,030
and server because there's no user

00:07:27,760 --> 00:07:33,430
interface to it you have to write things

00:07:31,030 --> 00:07:35,770
to inspect the cues and so on rabbitmq

00:07:33,430 --> 00:07:38,080
has a great plugin called the management

00:07:35,770 --> 00:07:40,300
console which gives a nice web interface

00:07:38,080 --> 00:07:46,030
which allows you to see what's going on

00:07:40,300 --> 00:07:47,200
much easier what I would say is use what

00:07:46,030 --> 00:07:50,370
works for you right

00:07:47,200 --> 00:07:52,960
if something very straightforward like

00:07:50,370 --> 00:07:54,010
putting a cue into a Redis instance

00:07:52,960 --> 00:07:58,979
works for you

00:07:54,010 --> 00:08:01,300
that's fine but you may find if you

00:07:58,979 --> 00:08:03,729
scale your business or your application

00:08:01,300 --> 00:08:06,460
rather it may be a little bit

00:08:03,729 --> 00:08:09,010
restrictive so RabbitMQ has this power

00:08:06,460 --> 00:08:10,479
to do this really simple stuff but then

00:08:09,010 --> 00:08:12,729
when your business and application

00:08:10,479 --> 00:08:18,100
demands it you can scale it up with the

00:08:12,729 --> 00:08:20,919
business okay so let's install rabbitmq

00:08:18,100 --> 00:08:25,120
guys get a bit more technical now for

00:08:20,919 --> 00:08:28,060
all of this examples I'm using a precise

00:08:25,120 --> 00:08:29,970
64 vagrant VM you can actually download

00:08:28,060 --> 00:08:34,060
this I'll give you the link in a moment

00:08:29,970 --> 00:08:36,610
and it's really easy okay so using

00:08:34,060 --> 00:08:39,490
Ubuntu you just add the Debian

00:08:36,610 --> 00:08:42,820
repository signing key apt-get update

00:08:39,490 --> 00:08:45,820
apt-get install you know the drill so

00:08:42,820 --> 00:08:48,700
the second to last one is rabbitmq

00:08:45,820 --> 00:08:50,260
plugins enable rabbitmq management and

00:08:48,700 --> 00:08:51,070
that's this management console that I

00:08:50,260 --> 00:08:52,390
mentioned

00:08:51,070 --> 00:08:53,800
highly recommend you do that because

00:08:52,390 --> 00:08:56,010
then you'll get your nice web interface

00:08:53,800 --> 00:08:59,410
and you won't get too lost too quickly

00:08:56,010 --> 00:09:02,560
and this is what that management console

00:08:59,410 --> 00:09:03,970
looks like when you first log in it

00:09:02,560 --> 00:09:05,890
gives you an overview of everything it

00:09:03,970 --> 00:09:07,990
gives you your number of queued messages

00:09:05,890 --> 00:09:10,660
the message rates how fast the messages

00:09:07,990 --> 00:09:12,850
are going through your system you get to

00:09:10,660 --> 00:09:15,190
the server information so if you've got

00:09:12,850 --> 00:09:16,720
the number of processes the number of

00:09:15,190 --> 00:09:18,790
connections how much memory is being

00:09:16,720 --> 00:09:21,520
used and so on and if you set up a

00:09:18,790 --> 00:09:23,770
cluster because you can we'll explain

00:09:21,520 --> 00:09:26,080
that later you can see all the nodes in

00:09:23,770 --> 00:09:28,210
the cluster right if you don't

00:09:26,080 --> 00:09:29,350
understand what I'm about to explain

00:09:28,210 --> 00:09:32,710
don't worry because I'm going to cover

00:09:29,350 --> 00:09:34,300
all the terminology that I'm about to

00:09:32,710 --> 00:09:36,490
introduce so this is the connections

00:09:34,300 --> 00:09:38,680
list see the number of connections great

00:09:36,490 --> 00:09:42,430
cool we've got quite a lot going on

00:09:38,680 --> 00:09:43,270
apparently this is the channels so

00:09:42,430 --> 00:09:44,830
there's a distinction between

00:09:43,270 --> 00:09:48,160
connections and channels which I'll

00:09:44,830 --> 00:09:49,750
explain shortly and it caught me out and

00:09:48,160 --> 00:09:52,720
it took me a while to understand but

00:09:49,750 --> 00:09:54,550
I'll get to that this is the list of

00:09:52,720 --> 00:09:55,840
exchanges again don't worry if you don't

00:09:54,550 --> 00:09:58,750
know what any exchange is I'm going to

00:09:55,840 --> 00:10:00,670
explain it and then you get your cues we

00:09:58,750 --> 00:10:02,770
know our queue is right you can view the

00:10:00,670 --> 00:10:05,590
messages in the queue purge the queue or

00:10:02,770 --> 00:10:08,440
basically truncate if you like you can

00:10:05,590 --> 00:10:09,630
see what consumers are consuming that

00:10:08,440 --> 00:10:12,820
queue as well

00:10:09,630 --> 00:10:14,050
okay cool we've had a look at that that

00:10:12,820 --> 00:10:19,120
helps you find your way around things

00:10:14,050 --> 00:10:22,000
really easily so let's dive into writing

00:10:19,120 --> 00:10:24,610
some code excuse me

00:10:22,000 --> 00:10:27,370
let's first look at a really rebase ik

00:10:24,610 --> 00:10:30,490
example a really basic message queue if

00:10:27,370 --> 00:10:33,520
you want to follow along point your

00:10:30,490 --> 00:10:37,390
laptop or phone or tablet at this URL

00:10:33,520 --> 00:10:40,440
now all the code is there and you can

00:10:37,390 --> 00:10:40,440
follow along with it if you like

00:10:41,440 --> 00:10:49,990
so yeah github.com slash as grim / r mq

00:10:45,340 --> 00:10:53,130
- slides should pause just for a moment

00:10:49,990 --> 00:10:53,130
if you want to do that

00:10:54,090 --> 00:10:59,370
okay moments over let's have a look at

00:10:56,700 --> 00:11:00,960
things basic queueing right this is what

00:10:59,370 --> 00:11:03,540
we're trying to do we've got something

00:11:00,960 --> 00:11:05,160
on the Left producing messages to be

00:11:03,540 --> 00:11:07,680
processed it does matter what's in them

00:11:05,160 --> 00:11:09,660
for now and we've got something on the

00:11:07,680 --> 00:11:12,540
right that we want to process that data

00:11:09,660 --> 00:11:15,120
with okay in all our examples our data

00:11:12,540 --> 00:11:16,560
is just going to be a string like this

00:11:15,120 --> 00:11:20,790
is a test message or something like that

00:11:16,560 --> 00:11:23,370
and this is how we're going to

00:11:20,790 --> 00:11:25,830
demonstrate the basic queueing right so

00:11:23,370 --> 00:11:27,720
to start off with we need to include

00:11:25,830 --> 00:11:30,690
some code to talk mqp

00:11:27,720 --> 00:11:33,990
the language that we need to speak now I

00:11:30,690 --> 00:11:38,610
do this with this library from a guy

00:11:33,990 --> 00:11:41,790
called Alvaro Videla and it's a user PHP

00:11:38,610 --> 00:11:44,580
written user land library there is also

00:11:41,790 --> 00:11:47,190
a petal extension but I've not used it

00:11:44,580 --> 00:11:49,020
so I don't know what it's like I've just

00:11:47,190 --> 00:11:51,560
used this you can include it using

00:11:49,020 --> 00:11:57,540
composer because composer is awesome

00:11:51,560 --> 00:11:59,640
who doesn't know what composer is cool

00:11:57,540 --> 00:12:02,130
excellent that's really good

00:11:59,640 --> 00:12:03,180
yeah if you don't use composer highly

00:12:02,130 --> 00:12:08,250
recommend it because you can do things

00:12:03,180 --> 00:12:11,910
like this composer install great cool so

00:12:08,250 --> 00:12:13,950
this is the connection code now this

00:12:11,910 --> 00:12:15,420
imagine this proceeds all of the

00:12:13,950 --> 00:12:17,400
examples I'm going to show you today and

00:12:15,420 --> 00:12:20,160
this is pretty much the same for

00:12:17,400 --> 00:12:22,020
everything the connection is really

00:12:20,160 --> 00:12:23,670
straightforward it's just like

00:12:22,020 --> 00:12:26,370
connecting to a MySQL server for example

00:12:23,670 --> 00:12:33,000
you give it a house to pour the username

00:12:26,370 --> 00:12:34,950
password and the last parameter is the V

00:12:33,000 --> 00:12:37,260
host you can set up virtual hosts and

00:12:34,950 --> 00:12:40,970
stuff we don't use that so I haven't

00:12:37,260 --> 00:12:44,610
really played around with that much so

00:12:40,970 --> 00:12:46,140
the channel on line 6 is what you use to

00:12:44,610 --> 00:12:48,300
interact so I've mentioned previously

00:12:46,140 --> 00:12:51,810
that there's a distinction between

00:12:48,300 --> 00:12:54,450
connections and channels and I found

00:12:51,810 --> 00:12:55,890
this out the hard way when our

00:12:54,450 --> 00:12:59,160
application started performing really

00:12:55,890 --> 00:13:00,930
badly because we'd open lots and lots of

00:12:59,160 --> 00:13:02,850
connections it turns out that's not the

00:13:00,930 --> 00:13:05,370
way to do it what you need to do is open

00:13:02,850 --> 00:13:07,140
one connection and then you can use

00:13:05,370 --> 00:13:07,680
these channels which are like virtual

00:13:07,140 --> 00:13:10,170
connections

00:13:07,680 --> 00:13:13,020
if you like to open lots and lots of

00:13:10,170 --> 00:13:15,300
different message queues through the

00:13:13,020 --> 00:13:17,460
system so just have one connection to

00:13:15,300 --> 00:13:19,200
one server because otherwise you'll find

00:13:17,460 --> 00:13:25,800
your resources run out pretty quickly I

00:13:19,200 --> 00:13:27,510
did that the hard way excuse me so the

00:13:25,800 --> 00:13:30,480
producer is where our messages aren't

00:13:27,510 --> 00:13:31,470
generated created we start off on line

00:13:30,480 --> 00:13:35,730
three

00:13:31,470 --> 00:13:38,310
by declaring the queue using Q declare

00:13:35,730 --> 00:13:40,709
it's really ingenious naming I love it

00:13:38,310 --> 00:13:41,940
so we've got a few arguments going on

00:13:40,709 --> 00:13:45,450
here we've got the first one is the name

00:13:41,940 --> 00:13:48,330
of the queue the next one is passive

00:13:45,450 --> 00:13:50,940
durable exclusive I worry too much about

00:13:48,330 --> 00:13:52,800
what they are okay the last one is auto

00:13:50,940 --> 00:13:56,430
delete which is basically when you

00:13:52,800 --> 00:13:59,070
disconnect the queue will automatically

00:13:56,430 --> 00:14:00,540
get deleted in our example we're not

00:13:59,070 --> 00:14:04,410
going to auto delete the queue but you

00:14:00,540 --> 00:14:08,220
can if you want so on line six we create

00:14:04,410 --> 00:14:10,470
the actual message content itself now as

00:14:08,220 --> 00:14:12,900
I said the actual content of the message

00:14:10,470 --> 00:14:15,240
can be anything you want we use Jason

00:14:12,900 --> 00:14:17,370
because it's fairly interoperable and we

00:14:15,240 --> 00:14:21,810
have some back-end processes that run no

00:14:17,370 --> 00:14:24,300
Jess it it can be anything right you can

00:14:21,810 --> 00:14:24,570
put binary basics to it whatever you

00:14:24,300 --> 00:14:27,120
want

00:14:24,570 --> 00:14:30,540
okay and you just pass it as a parameter

00:14:27,120 --> 00:14:33,540
to this AMQP message object and then we

00:14:30,540 --> 00:14:36,390
use the ingeniously named basic publish

00:14:33,540 --> 00:14:39,029
function on line seven you give it the

00:14:36,390 --> 00:14:40,620
message object that you just created you

00:14:39,029 --> 00:14:42,089
give it the name of an exchange which

00:14:40,620 --> 00:14:43,080
we're going to leave empty for now

00:14:42,089 --> 00:14:47,190
because we don't know what an exchange

00:14:43,080 --> 00:14:48,390
is and a routing key in this case the

00:14:47,190 --> 00:14:49,410
routing key is just the name of the

00:14:48,390 --> 00:14:54,600
queue that we're going to send the

00:14:49,410 --> 00:14:57,029
message to test queue and this is the

00:14:54,600 --> 00:15:00,150
other side of the coin this is the

00:14:57,029 --> 00:15:02,310
consumer now again the connection code

00:15:00,150 --> 00:15:05,940
imagine that's above this I just can't

00:15:02,310 --> 00:15:07,620
fit too much content on a slide and the

00:15:05,940 --> 00:15:11,760
consuming as you can see is done by

00:15:07,620 --> 00:15:13,050
creating a callable so that can be you

00:15:11,760 --> 00:15:15,560
know a static function it could be an

00:15:13,050 --> 00:15:19,200
anonymous function as I've written here

00:15:15,560 --> 00:15:21,660
and you call the basic consume method

00:15:19,200 --> 00:15:24,130
and pass this callable to it

00:15:21,660 --> 00:15:25,600
as again there's a few parameters here

00:15:24,130 --> 00:15:29,800
they are the name of the queue that you

00:15:25,600 --> 00:15:31,540
want to consume an identifier so that

00:15:29,800 --> 00:15:34,840
that's an identifier for you the

00:15:31,540 --> 00:15:38,440
connector it's sometimes useful I've

00:15:34,840 --> 00:15:40,960
left it blank here and yet the most

00:15:38,440 --> 00:15:42,460
important one the last parameter is the

00:15:40,960 --> 00:15:45,340
callback that you want to process and

00:15:42,460 --> 00:15:48,010
this callback gets executed every time a

00:15:45,340 --> 00:15:51,850
message comes in so this function deals

00:15:48,010 --> 00:15:55,120
with each specific message in however

00:15:51,850 --> 00:15:57,460
way you want to the last bit of code is

00:15:55,120 --> 00:15:59,380
the channel weight which is a blocking

00:15:57,460 --> 00:16:02,910
function that basically waits for a

00:15:59,380 --> 00:16:05,470
message and we loop we have a while loop

00:16:02,910 --> 00:16:07,540
that makes sure that a callback is still

00:16:05,470 --> 00:16:08,890
registered if it's registered it will

00:16:07,540 --> 00:16:11,560
carry on looping and waiting for

00:16:08,890 --> 00:16:13,360
messages so as you can see here it's a

00:16:11,560 --> 00:16:16,090
this turns into a long-running process

00:16:13,360 --> 00:16:17,830
okay so if you feel uncomfortable with

00:16:16,090 --> 00:16:22,360
that maybe use a different language I

00:16:17,830 --> 00:16:24,250
don't know but I think PHP now is fine

00:16:22,360 --> 00:16:27,420
for long-running processes we have all

00:16:24,250 --> 00:16:30,130
ours most of us rather running PHP and

00:16:27,420 --> 00:16:32,620
you can do things like interact with

00:16:30,130 --> 00:16:34,570
signals I highly recommend if you want

00:16:32,620 --> 00:16:36,580
to learn a bit more about signals check

00:16:34,570 --> 00:16:39,010
out a book called signaling PHP by Kyle

00:16:36,580 --> 00:16:41,320
Evans that's great for long-running

00:16:39,010 --> 00:16:46,390
processes or you can just use ctrl C to

00:16:41,320 --> 00:16:48,550
quit the process whatever okay so if we

00:16:46,390 --> 00:16:51,100
run this particular code this is what

00:16:48,550 --> 00:16:53,440
this is what it's going to look like the

00:16:51,100 --> 00:16:56,320
background window here is the consumer

00:16:53,440 --> 00:17:00,460
and the foreground is the producer each

00:16:56,320 --> 00:17:02,770
time we run our code on the producer we

00:17:00,460 --> 00:17:05,949
generate my test message and in the

00:17:02,770 --> 00:17:08,880
consumer you can see being echoed it's

00:17:05,949 --> 00:17:08,880
really straightforward okay

00:17:09,430 --> 00:17:12,540
let's get a little bit more complicated

00:17:16,340 --> 00:17:21,770
you learn about exchanges now so I've

00:17:18,680 --> 00:17:23,870
mentioned them a few times and we're

00:17:21,770 --> 00:17:28,100
gonna first look at a type of exchange

00:17:23,870 --> 00:17:31,010
called a fan-out exchange so this is

00:17:28,100 --> 00:17:34,340
what an exchange might look like now a

00:17:31,010 --> 00:17:37,010
fan-out exchange is characterized by the

00:17:34,340 --> 00:17:40,310
fact it sends the same message to all

00:17:37,010 --> 00:17:44,060
connected to use so it duplicates it if

00:17:40,310 --> 00:17:47,570
you like and the consumers could do

00:17:44,060 --> 00:17:50,480
different things with the messages take

00:17:47,570 --> 00:17:52,460
a logging scenario one of these

00:17:50,480 --> 00:17:55,910
consumers could send the log messages to

00:17:52,460 --> 00:17:58,790
a MySQL database for storage another one

00:17:55,910 --> 00:18:00,260
could examine the message and determine

00:17:58,790 --> 00:18:02,360
whether maybe it's a critical system

00:18:00,260 --> 00:18:04,730
error in which case it might send an

00:18:02,360 --> 00:18:06,340
email to you or SMS message saying

00:18:04,730 --> 00:18:08,390
something's broken something like that

00:18:06,340 --> 00:18:10,460
so we can do different things with

00:18:08,390 --> 00:18:13,940
different consumers which is quite cool

00:18:10,460 --> 00:18:15,350
but the message is only sent once you

00:18:13,940 --> 00:18:18,290
don't have to send it for each different

00:18:15,350 --> 00:18:20,960
thing you want to process so that's what

00:18:18,290 --> 00:18:25,760
I found out exchange does we're going to

00:18:20,960 --> 00:18:30,740
write one now in this the producer code

00:18:25,760 --> 00:18:32,180
is actually a little bit simpler if you

00:18:30,740 --> 00:18:33,830
look at this slide carefully you'll

00:18:32,180 --> 00:18:36,860
notice that we don't actually mention a

00:18:33,830 --> 00:18:38,870
cue anywhere and the reason why is

00:18:36,860 --> 00:18:42,560
because we leave the queuing up to the

00:18:38,870 --> 00:18:46,580
exchange the exchange decides where to

00:18:42,560 --> 00:18:48,790
put the messages so instead we call

00:18:46,580 --> 00:18:51,170
exchange declare function this time

00:18:48,790 --> 00:18:53,750
similar sort of parameters the main ones

00:18:51,170 --> 00:18:55,600
is the name that's the name of the

00:18:53,750 --> 00:18:58,580
exchange that you want to publish to and

00:18:55,600 --> 00:19:01,750
then we call basic publish just like

00:18:58,580 --> 00:19:05,180
before create the MQB message object and

00:19:01,750 --> 00:19:07,730
we publish it this time to test exchange

00:19:05,180 --> 00:19:10,010
and we've emitted the last parameter so

00:19:07,730 --> 00:19:11,300
before we put a routing key of test q

00:19:10,010 --> 00:19:13,670
which is the name of the queue that we

00:19:11,300 --> 00:19:15,680
want to publish to this time we're

00:19:13,670 --> 00:19:20,390
emitting that we're just saying send

00:19:15,680 --> 00:19:22,520
this message to test exchange and that's

00:19:20,390 --> 00:19:25,160
it

00:19:22,520 --> 00:19:27,560
so the consumer here the other side of

00:19:25,160 --> 00:19:30,290
the coin is a little bit different this

00:19:27,560 --> 00:19:35,200
time we're calling Q declare but we're

00:19:30,290 --> 00:19:39,350
not actually giving it a Q name mmm okay

00:19:35,200 --> 00:19:42,890
dollar Q open square brackets 0 is the

00:19:39,350 --> 00:19:45,380
resulting Q name so what M rabbitmq does

00:19:42,890 --> 00:19:49,720
here is it generates a temporary Q name

00:19:45,380 --> 00:19:53,150
and it returns the name of that Q great

00:19:49,720 --> 00:19:54,650
in this example I've set the auto-delete

00:19:53,150 --> 00:19:58,100
parameter that I mentioned earlier to

00:19:54,650 --> 00:20:02,480
true so rabbitmq when this consumer

00:19:58,100 --> 00:20:05,290
disconnects would delete that Q and same

00:20:02,480 --> 00:20:07,310
as the producer we call exchange declare

00:20:05,290 --> 00:20:09,740
with the name of the exchange of sleep

00:20:07,310 --> 00:20:11,540
and once we've done that we can do

00:20:09,740 --> 00:20:14,030
something called binding and what we're

00:20:11,540 --> 00:20:19,070
doing is we're binding this Q to the

00:20:14,030 --> 00:20:21,320
exchange okay the rest of the code is

00:20:19,070 --> 00:20:23,300
the same as before so if emitted it here

00:20:21,320 --> 00:20:26,390
it's the while loop and that's pretty

00:20:23,300 --> 00:20:29,720
much it and the in the function and

00:20:26,390 --> 00:20:33,710
everything okay so this is what we look

00:20:29,720 --> 00:20:36,470
like here the produced messages 1 & 2

00:20:33,710 --> 00:20:40,340
are produced when there's no consumers

00:20:36,470 --> 00:20:42,500
running the messages went nowhere we

00:20:40,340 --> 00:20:45,350
connected the first consumer the top one

00:20:42,500 --> 00:20:47,510
and produce messages 3 & 4 and they were

00:20:45,350 --> 00:20:50,690
consumed only by that one that one

00:20:47,510 --> 00:20:53,120
prepare consumer and then we connected a

00:20:50,690 --> 00:20:56,110
second one the bottom of the background

00:20:53,120 --> 00:20:58,370
windows and produce messages 5 & 6 and

00:20:56,110 --> 00:21:01,970
notice that they were consumed by both

00:20:58,370 --> 00:21:05,060
queues so as I mentioned earlier those

00:21:01,970 --> 00:21:09,650
messages fanned out to both consumers

00:21:05,060 --> 00:21:12,470
via the queues cool just a quick word

00:21:09,650 --> 00:21:14,210
about temporary queues as you may have

00:21:12,470 --> 00:21:18,440
spotted already they only listen to the

00:21:14,210 --> 00:21:20,900
current flow of messages so if you've

00:21:18,440 --> 00:21:24,860
not got any consumer connected to that

00:21:20,900 --> 00:21:28,310
queue or exchange then the messages just

00:21:24,860 --> 00:21:31,580
disappear now in some cases that works

00:21:28,310 --> 00:21:34,280
for you for us we like to have all of

00:21:31,580 --> 00:21:35,309
our messages so we don't use temporary

00:21:34,280 --> 00:21:39,179
queues

00:21:35,309 --> 00:21:41,669
it depends on you use case right most of

00:21:39,179 --> 00:21:43,980
the time as I said we use what what is

00:21:41,669 --> 00:21:46,169
called shared or non-exclusive queues

00:21:43,980 --> 00:21:49,110
and that allows the messages to build up

00:21:46,169 --> 00:21:51,570
in the queue while no one's while no one

00:21:49,110 --> 00:21:55,169
is consuming that queue so it depends on

00:21:51,570 --> 00:21:58,169
your use case okay

00:21:55,169 --> 00:22:04,379
another type of exchange is a direct

00:21:58,169 --> 00:22:08,269
exchange they're pretty cool when you

00:22:04,379 --> 00:22:11,549
produce a message you can give it a

00:22:08,269 --> 00:22:13,470
routing key now thinking back to our

00:22:11,549 --> 00:22:14,789
first example we've already given the

00:22:13,470 --> 00:22:18,119
routing key so we've actually already

00:22:14,789 --> 00:22:22,009
used this concept before a routing key

00:22:18,119 --> 00:22:26,070
is like an address a postal address an

00:22:22,009 --> 00:22:27,480
exchange is the sorting office except

00:22:26,070 --> 00:22:31,350
maybe a little bit more reliable than

00:22:27,480 --> 00:22:34,769
Royal Mail the queue itself think of

00:22:31,350 --> 00:22:41,309
that as the delivery person right it's

00:22:34,769 --> 00:22:43,350
delivering to the consumer and by using

00:22:41,309 --> 00:22:45,809
this routing key it gives you a huge

00:22:43,350 --> 00:22:49,830
amount of flexibility about what happens

00:22:45,809 --> 00:22:51,929
to a message and have a look well if you

00:22:49,830 --> 00:22:55,799
send a message with a routing key of

00:22:51,929 --> 00:22:58,200
orange it's going to go to the queues

00:22:55,799 --> 00:22:59,929
that are looking for oranges so you can

00:22:58,200 --> 00:23:02,249
see on each of the queues have labeled

00:22:59,929 --> 00:23:05,610
what sort of messages the queues are

00:23:02,249 --> 00:23:07,679
looking for now the first queue is

00:23:05,610 --> 00:23:09,240
looking for all sorts of things so if we

00:23:07,679 --> 00:23:11,039
send a message with orange it's going to

00:23:09,240 --> 00:23:12,929
go in the first queue but notice it

00:23:11,039 --> 00:23:16,289
doesn't go into the other queues because

00:23:12,929 --> 00:23:17,789
they're not looking for oranges if you

00:23:16,289 --> 00:23:19,019
have a banana it's going to go to the

00:23:17,789 --> 00:23:22,649
first and second queue because they're

00:23:19,019 --> 00:23:24,090
both looking for bananas and apples as

00:23:22,649 --> 00:23:27,450
you might have guessed by now it goes to

00:23:24,090 --> 00:23:30,690
all three queues they're all bound so I

00:23:27,450 --> 00:23:34,619
mentioned this binding binding thing

00:23:30,690 --> 00:23:36,509
earlier it's binding to that routing key

00:23:34,619 --> 00:23:41,549
and we call it when we do the actual

00:23:36,509 --> 00:23:43,860
binding the binding key cool all right

00:23:41,549 --> 00:23:46,230
so this is the producer the only real

00:23:43,860 --> 00:23:49,320
change from our previous exercise is

00:23:46,230 --> 00:23:51,090
that we've now put the routing key in

00:23:49,320 --> 00:23:53,070
this particular script if you're looking

00:23:51,090 --> 00:23:54,389
on github obviously it runs on the

00:23:53,070 --> 00:23:56,370
command line and I've passed this

00:23:54,389 --> 00:23:59,720
routing key in via the command line

00:23:56,370 --> 00:23:59,720
which we'll have a look at in a moment

00:23:59,809 --> 00:24:06,929
so thinking back to the original example

00:24:05,009 --> 00:24:10,649
remember that we had a routing key which

00:24:06,929 --> 00:24:11,159
had the queue name and well why did we

00:24:10,649 --> 00:24:13,379
do that

00:24:11,159 --> 00:24:15,090
well it actually worked because rabbit

00:24:13,379 --> 00:24:19,129
and key will default to using an

00:24:15,090 --> 00:24:21,690
internal exchange that is already set up

00:24:19,129 --> 00:24:24,990
we obviously didn't specify an exchange

00:24:21,690 --> 00:24:27,899
name if you remember and it Ford's it to

00:24:24,990 --> 00:24:30,119
the queue that matches that routing key

00:24:27,899 --> 00:24:35,220
and that is how that worked in the first

00:24:30,119 --> 00:24:36,929
instance so this is the consumer the

00:24:35,220 --> 00:24:40,740
biggest change here is that there is a

00:24:36,929 --> 00:24:42,179
queue bind cur routing key as I

00:24:40,740 --> 00:24:45,269
mentioned that's called a binding key if

00:24:42,179 --> 00:24:47,610
we ran this particular code we would

00:24:45,269 --> 00:24:50,340
receive all messages with a routing key

00:24:47,610 --> 00:24:54,740
of Apple because we bound it to Apple on

00:24:50,340 --> 00:24:57,629
line 7 orange and banana following lines

00:24:54,740 --> 00:25:01,350
so we're listening to lots of different

00:24:57,629 --> 00:25:03,899
types so let's have a look in this

00:25:01,350 --> 00:25:06,480
example I run three consumers in the

00:25:03,899 --> 00:25:08,549
Kim's two consumers are on the Left the

00:25:06,480 --> 00:25:10,590
top one excuse me he's looking for apple

00:25:08,549 --> 00:25:13,080
banana and orange the second one is

00:25:10,590 --> 00:25:15,869
looking for just apple and banana and

00:25:13,080 --> 00:25:18,929
the last one just for apples if I

00:25:15,869 --> 00:25:21,539
produce messages on the right with each

00:25:18,929 --> 00:25:26,669
individual key you can see it processed

00:25:21,539 --> 00:25:29,009
by the appropriate consumer cool that's

00:25:26,669 --> 00:25:31,409
pretty cool because oh we now have an

00:25:29,009 --> 00:25:33,570
address on our messages that define

00:25:31,409 --> 00:25:38,340
where these messages go to and how they

00:25:33,570 --> 00:25:41,700
get processed by RabbitMQ but there's

00:25:38,340 --> 00:25:45,330
more there's another type of exchange

00:25:41,700 --> 00:25:48,360
called a topic exchange and it's pretty

00:25:45,330 --> 00:25:51,330
much the same but we've introduced a new

00:25:48,360 --> 00:25:54,600
concept to the binding keys we've

00:25:51,330 --> 00:25:58,529
introduced the asterisk and the hash or

00:25:54,600 --> 00:26:00,390
pound sign if you're American and they

00:25:58,529 --> 00:26:03,480
have specific meanings

00:26:00,390 --> 00:26:06,750
so an asterisk matches exactly one word

00:26:03,480 --> 00:26:10,110
now a word in a routing key is basically

00:26:06,750 --> 00:26:13,260
a separation with a full stop or dot or

00:26:10,110 --> 00:26:15,840
period whatever you want to call it so

00:26:13,260 --> 00:26:20,040
an asterisk asterisk will match exactly

00:26:15,840 --> 00:26:25,320
one word in that string and a hash sign

00:26:20,040 --> 00:26:27,240
will match zero or more words and just

00:26:25,320 --> 00:26:29,460
by introducing these two little

00:26:27,240 --> 00:26:33,750
characters we've got a huge amounts of

00:26:29,460 --> 00:26:36,690
flexibility now even more than before if

00:26:33,750 --> 00:26:40,230
we send a message to our queues here red

00:26:36,690 --> 00:26:42,420
dot vegetable well the first queue is

00:26:40,230 --> 00:26:44,520
looking for star dot vegetable so that

00:26:42,420 --> 00:26:47,910
message is going to go there and the

00:26:44,520 --> 00:26:50,010
second queue is looking for hash which

00:26:47,910 --> 00:26:53,400
is basically I want all messages thus

00:26:50,010 --> 00:26:55,050
and to this exchange this the last two

00:26:53,400 --> 00:26:56,970
queues they're not looking for the right

00:26:55,050 --> 00:27:00,570
right thing for this message so they

00:26:56,970 --> 00:27:01,770
won't get that message if we send a

00:27:00,570 --> 00:27:04,770
message green dot vegetable with a

00:27:01,770 --> 00:27:06,120
routing key of green dot vegetable it's

00:27:04,770 --> 00:27:09,240
going to go to the third queue as well

00:27:06,120 --> 00:27:15,090
because it's looking for green dot zero

00:27:09,240 --> 00:27:16,650
more things green dot grass not long the

00:27:15,090 --> 00:27:18,060
second queue is going to get it because

00:27:16,650 --> 00:27:19,200
it's looking for everything the third

00:27:18,060 --> 00:27:21,450
queue is going to get it because it's

00:27:19,200 --> 00:27:23,490
looking for green dot zero or more and

00:27:21,450 --> 00:27:26,900
of course there's two words following in

00:27:23,490 --> 00:27:29,040
grass long green dot grass not long and

00:27:26,900 --> 00:27:29,640
the fourth message is also going to get

00:27:29,040 --> 00:27:33,000
it as well

00:27:29,640 --> 00:27:36,000
now I've included this last example to

00:27:33,000 --> 00:27:38,690
demonstrate that although both binding

00:27:36,000 --> 00:27:42,300
keys have matched the routing key here

00:27:38,690 --> 00:27:43,680
the message doesn't get duplicated so

00:27:42,300 --> 00:27:45,000
again that's the question I get asked

00:27:43,680 --> 00:27:48,240
occasionally

00:27:45,000 --> 00:27:50,640
so the message only gets put in that key

00:27:48,240 --> 00:27:57,090
once even though it's matched two

00:27:50,640 --> 00:27:59,420
different binding keys if you gone put a

00:27:57,090 --> 00:27:59,420
question

00:28:01,179 --> 00:28:05,780
so the question is why does it match the

00:28:03,980 --> 00:28:09,620
bottom one well the bottom one is

00:28:05,780 --> 00:28:13,070
looking for star grass star so that will

00:28:09,620 --> 00:28:15,890
match one word grass dog one word which

00:28:13,070 --> 00:28:19,100
matches green grass not long and the

00:28:15,890 --> 00:28:23,590
second binding key here is star dot

00:28:19,100 --> 00:28:28,850
style dot long and that again matches

00:28:23,590 --> 00:28:31,370
okay cool so let's have a look a little

00:28:28,850 --> 00:28:32,740
bit closer a real-world example that I

00:28:31,370 --> 00:28:37,370
mentioned we're going to look into

00:28:32,740 --> 00:28:39,890
logging not that kind of logging okay

00:28:37,370 --> 00:28:44,419
this is how it works on our website okay

00:28:39,890 --> 00:28:46,610
so an HTTP request comes in an explosion

00:28:44,419 --> 00:28:50,120
happens or it's just a little error okay

00:28:46,610 --> 00:28:53,000
or a log message and almost

00:28:50,120 --> 00:28:55,669
simultaneously an mqp message sets get

00:28:53,000 --> 00:28:57,830
sent to RabbitMQ there's a slight wait

00:28:55,669 --> 00:29:00,919
obviously for that message to get queued

00:28:57,830 --> 00:29:04,570
and the HTTP response can be sent

00:29:00,919 --> 00:29:06,980
straight back to the website visitor and

00:29:04,570 --> 00:29:08,600
notice that the message hasn't reached

00:29:06,980 --> 00:29:12,200
the log server yet because we've put it

00:29:08,600 --> 00:29:13,490
in a queue so later on potentially after

00:29:12,200 --> 00:29:15,290
the request is finished

00:29:13,490 --> 00:29:16,820
if the logging server is busy or

00:29:15,290 --> 00:29:18,320
something

00:29:16,820 --> 00:29:20,330
the logging server can then fetch the

00:29:18,320 --> 00:29:23,720
message and store it in a database or do

00:29:20,330 --> 00:29:26,270
whatever it wants so that's how it

00:29:23,720 --> 00:29:28,910
allows you to have a huge amount of

00:29:26,270 --> 00:29:31,760
flexibility just with this really basic

00:29:28,910 --> 00:29:34,790
set up we can use this sort of

00:29:31,760 --> 00:29:37,490
flexibility to say create a consumer

00:29:34,790 --> 00:29:39,290
that logs to the database create another

00:29:37,490 --> 00:29:41,270
consumer that filters off critical

00:29:39,290 --> 00:29:45,470
messages and emails the more sensor text

00:29:41,270 --> 00:29:47,900
message create a temporary queue to

00:29:45,470 --> 00:29:50,390
temporarily inspect debug messages for

00:29:47,900 --> 00:29:54,140
example so yes you could leave debug in

00:29:50,390 --> 00:29:55,429
your production code perhaps and ignore

00:29:54,140 --> 00:29:57,110
it for most of the time but just create

00:29:55,429 --> 00:29:58,850
a temporary queue to listen to that

00:29:57,110 --> 00:30:01,549
if something's gone wrong for example

00:29:58,850 --> 00:30:04,280
and you can get really creative with

00:30:01,549 --> 00:30:07,520
those routing keys so say for example

00:30:04,280 --> 00:30:11,330
you have a log message with a routing

00:30:07,520 --> 00:30:13,730
key of a apt or API dot error describes

00:30:11,330 --> 00:30:14,820
and that there's an error happened with

00:30:13,730 --> 00:30:16,830
our API for exam

00:30:14,820 --> 00:30:19,500
then you could listen to those messages

00:30:16,830 --> 00:30:22,889
with a binding key of hash door API to

00:30:19,500 --> 00:30:26,460
error and it would pick up all the API

00:30:22,889 --> 00:30:27,899
errors a routing key of say if you send

00:30:26,460 --> 00:30:30,600
message with the routing key of app dot

00:30:27,899 --> 00:30:32,250
formed up debug and you wanted to listen

00:30:30,600 --> 00:30:35,429
to all the debug you just create a cue

00:30:32,250 --> 00:30:40,019
hash debug and it just listens to all of

00:30:35,429 --> 00:30:42,630
the debug messages it allows you to do

00:30:40,019 --> 00:30:45,630
lots of parallel processing now note in

00:30:42,630 --> 00:30:47,509
all of the diagrams that I drew there

00:30:45,630 --> 00:30:50,129
was only one consumer per cube but

00:30:47,509 --> 00:30:53,399
thinking about to our very first diagram

00:30:50,129 --> 00:30:58,169
there is lots of background processes or

00:30:53,399 --> 00:31:00,120
consumers listening to one cue and that

00:30:58,169 --> 00:31:00,570
allows you to process lots of things in

00:31:00,120 --> 00:31:04,230
parallel

00:31:00,570 --> 00:31:07,200
you have many consumers per cube now

00:31:04,230 --> 00:31:09,710
note when you do this sort of setup the

00:31:07,200 --> 00:31:11,820
message will only get processed once

00:31:09,710 --> 00:31:13,649
unless it's put back in the queue for

00:31:11,820 --> 00:31:16,649
example you reject the message and say I

00:31:13,649 --> 00:31:19,500
don't want to process this or your

00:31:16,649 --> 00:31:21,740
process dies there was an exception or

00:31:19,500 --> 00:31:23,909
something that killed PHP process and

00:31:21,740 --> 00:31:26,669
that allows for spreading out the load

00:31:23,909 --> 00:31:30,299
you can do many things at once but

00:31:26,669 --> 00:31:34,409
there's a bit of a caveat you need to be

00:31:30,299 --> 00:31:37,200
aware of external factors now there was

00:31:34,409 --> 00:31:38,909
a time when I decided to put sort of to

00:31:37,200 --> 00:31:42,570
three million messages into a queue

00:31:38,909 --> 00:31:45,360
which is fine but then I noticed lots of

00:31:42,570 --> 00:31:47,490
errors happening and the errors were

00:31:45,360 --> 00:31:49,409
actually MySQL dead locking because I

00:31:47,490 --> 00:31:52,230
was trying to process way too much at

00:31:49,409 --> 00:31:53,669
once and MySQL couldn't keep up so it

00:31:52,230 --> 00:31:55,679
kept dead locking because we usually

00:31:53,669 --> 00:31:59,190
know DB and so there's these things that

00:31:55,679 --> 00:32:02,370
happen and I found out that actually

00:31:59,190 --> 00:32:03,830
there is a critical mass for the number

00:32:02,370 --> 00:32:05,909
of consumers for that particular

00:32:03,830 --> 00:32:09,600
background processing I was doing and it

00:32:05,909 --> 00:32:12,000
was about 16 so I could only process 16

00:32:09,600 --> 00:32:14,279
things at once that's fine

00:32:12,000 --> 00:32:20,090
it took a while to get through those few

00:32:14,279 --> 00:32:23,910
million messages but ok

00:32:20,090 --> 00:32:26,340
so I mentioned you can reject messages

00:32:23,910 --> 00:32:30,540
and similarly you can also acknowledge

00:32:26,340 --> 00:32:33,000
messages so by default well it's an

00:32:30,540 --> 00:32:35,490
option you can either Auto automatically

00:32:33,000 --> 00:32:38,429
acknowledge messages or you can manually

00:32:35,490 --> 00:32:43,049
do that now if a message does not get

00:32:38,429 --> 00:32:44,730
acknowledged it could get redeliver to

00:32:43,049 --> 00:32:48,419
another consumer if your process dies

00:32:44,730 --> 00:32:50,850
which is a bit weird so if you forget to

00:32:48,419 --> 00:32:53,240
put in your your knowledge mint call

00:32:50,850 --> 00:32:55,620
your message acknowledgement call and

00:32:53,240 --> 00:32:58,290
your process dies because an exception

00:32:55,620 --> 00:33:00,000
or something then all of those messages

00:32:58,290 --> 00:33:01,919
that you processed but didn't

00:33:00,000 --> 00:33:03,809
acknowledge are gonna get put back in

00:33:01,919 --> 00:33:07,080
the cube by RabbitMQ which is a weird

00:33:03,809 --> 00:33:09,570
thing to happen so if you don't want to

00:33:07,080 --> 00:33:13,790
automatically acknowledge messages make

00:33:09,570 --> 00:33:13,790
sure you acknowledge them appropriately

00:33:13,850 --> 00:33:19,410
I'm going to talk about a few features

00:33:15,929 --> 00:33:21,740
of RabbitMQ another question I get asked

00:33:19,410 --> 00:33:26,340
sometimes is well how'd you get response

00:33:21,740 --> 00:33:28,440
so looking back to our logging diagram

00:33:26,340 --> 00:33:32,460
that we did with with a website message

00:33:28,440 --> 00:33:33,750
error obviously we don't know that that

00:33:32,460 --> 00:33:36,660
has definitely got stored in the logging

00:33:33,750 --> 00:33:39,419
database because the request is already

00:33:36,660 --> 00:33:43,590
ended by that point well one way to do

00:33:39,419 --> 00:33:46,559
this is RPC a remote procedure call the

00:33:43,590 --> 00:33:49,410
client sends a message to your exchange

00:33:46,559 --> 00:33:52,169
or queue with a parameter in an extra

00:33:49,410 --> 00:33:55,230
parameter called reply to and that's the

00:33:52,169 --> 00:33:59,130
name of a queue that it's going to reply

00:33:55,230 --> 00:34:01,049
to so you send this message and then you

00:33:59,130 --> 00:34:04,980
listen on that queue that you just hold

00:34:01,049 --> 00:34:06,900
it I want to response on so the other

00:34:04,980 --> 00:34:09,629
side of the coin the consumer it listens

00:34:06,900 --> 00:34:11,190
just like normal it does the work when

00:34:09,629 --> 00:34:14,700
it receives the message and then it

00:34:11,190 --> 00:34:19,980
sends another message back to the reply

00:34:14,700 --> 00:34:22,260
queue so that the the producer then says

00:34:19,980 --> 00:34:25,260
okay I've got this obviously it's a

00:34:22,260 --> 00:34:28,889
blocking process so you need to figure

00:34:25,260 --> 00:34:31,530
out your use case there unfortunately

00:34:28,889 --> 00:34:33,149
when I first started playing with rabbit

00:34:31,530 --> 00:34:33,590
and cue I was like oh this is really

00:34:33,149 --> 00:34:35,030
cool

00:34:33,590 --> 00:34:38,600
when then I forgot to read the rest of

00:34:35,030 --> 00:34:40,640
the manual and I did it a slightly

00:34:38,600 --> 00:34:43,280
different way which is not the best way

00:34:40,640 --> 00:34:46,850
but we actually do a similar thing to

00:34:43,280 --> 00:34:50,990
how our PC works when we send a message

00:34:46,850 --> 00:34:53,060
into the queue we have an HTTP URL that

00:34:50,990 --> 00:34:55,460
we include in the payload and say this

00:34:53,060 --> 00:34:57,380
is where you send your response so once

00:34:55,460 --> 00:34:59,690
our workers have done some work in

00:34:57,380 --> 00:35:02,810
certain cases we'll send a response to

00:34:59,690 --> 00:35:04,370
that URL you know form of a post packet

00:35:02,810 --> 00:35:08,390
for example saying this is the data I've

00:35:04,370 --> 00:35:09,680
processed and then we've got a web

00:35:08,390 --> 00:35:13,310
service that listens on the other side

00:35:09,680 --> 00:35:14,930
for those for those responses now

00:35:13,310 --> 00:35:16,760
there's actually another way of doing it

00:35:14,930 --> 00:35:19,670
that I thought of and that's to store it

00:35:16,760 --> 00:35:22,520
in a database and have your producer

00:35:19,670 --> 00:35:23,750
pull the database for example fairly

00:35:22,520 --> 00:35:28,610
similar in concept just slightly

00:35:23,750 --> 00:35:31,880
different executions TTL or time to live

00:35:28,610 --> 00:35:34,880
if you're familiar with DNS DNS as a TTL

00:35:31,880 --> 00:35:37,120
similar sort of concepts right now

00:35:34,880 --> 00:35:41,890
there's three types of C TTLs in

00:35:37,120 --> 00:35:46,130
RabbitMQ the first is a / Q message TTL

00:35:41,890 --> 00:35:49,160
as a mouthful and that basically means

00:35:46,130 --> 00:35:53,020
all messages that get put into a queue

00:35:49,160 --> 00:35:56,000
that has a per message per Q message TTL

00:35:53,020 --> 00:35:56,330
they will have the same TTL or time to

00:35:56,000 --> 00:35:58,490
live

00:35:56,330 --> 00:36:01,820
so those messages will drop out the

00:35:58,490 --> 00:36:05,990
bottom of the queue after 30 seconds

00:36:01,820 --> 00:36:08,600
perhaps there's also a per message TTL

00:36:05,990 --> 00:36:11,120
so when you send an individual message

00:36:08,600 --> 00:36:15,170
you can set a unique time to live on

00:36:11,120 --> 00:36:17,060
that message and so that allows for lots

00:36:15,170 --> 00:36:19,220
of different times for each individual

00:36:17,060 --> 00:36:21,950
message to fall out the bottom of the

00:36:19,220 --> 00:36:23,870
queue and what I mean what do I mean by

00:36:21,950 --> 00:36:26,140
falling at the bottom of the queue well

00:36:23,870 --> 00:36:28,670
that message just doesn't get processed

00:36:26,140 --> 00:36:31,010
because you didn't process it in time

00:36:28,670 --> 00:36:32,690
for example now you might think well

00:36:31,010 --> 00:36:33,560
that's a bit odd well if I put a message

00:36:32,690 --> 00:36:36,500
in a queue

00:36:33,560 --> 00:36:37,460
surely I want it to be processed well

00:36:36,500 --> 00:36:39,470
maybe not

00:36:37,460 --> 00:36:45,080
again like I said it depends on your use

00:36:39,470 --> 00:36:46,730
case we have TTL on some submission

00:36:45,080 --> 00:36:50,570
processes too

00:36:46,730 --> 00:36:53,540
we send leads to a third party and in

00:36:50,570 --> 00:36:56,360
that submission we run a cron every two

00:36:53,540 --> 00:37:00,260
minutes so we put a TTL on the messages

00:36:56,360 --> 00:37:02,330
there of one minute so that we don't

00:37:00,260 --> 00:37:06,320
overflow ourselves and try and send the

00:37:02,330 --> 00:37:07,640
same thing twice this will for another

00:37:06,320 --> 00:37:10,850
type of tea Thea I said there was three

00:37:07,640 --> 00:37:13,010
the other one it's a cutie TL and this

00:37:10,850 --> 00:37:15,380
is actually time to live on the queue

00:37:13,010 --> 00:37:20,450
itself so the queue will self-destruct

00:37:15,380 --> 00:37:23,240
after however long you tell it to I not

00:37:20,450 --> 00:37:25,430
come across a use case for it but going

00:37:23,240 --> 00:37:27,440
back to what I was saying earlier about

00:37:25,430 --> 00:37:29,510
the flexibility and scalability in

00:37:27,440 --> 00:37:31,250
things this is one of those things well

00:37:29,510 --> 00:37:33,680
maybe I have this edge case where I want

00:37:31,250 --> 00:37:36,200
to delete queues after 10 seconds or 30

00:37:33,680 --> 00:37:40,970
seconds whatever so you can do that if

00:37:36,200 --> 00:37:43,040
you want now TTLs work really well as

00:37:40,970 --> 00:37:46,820
something something called it DLX or a

00:37:43,040 --> 00:37:50,150
dead letter exchange now a message will

00:37:46,820 --> 00:37:52,400
be dead lettered if a message reaches it

00:37:50,150 --> 00:37:56,090
reaches its TTL so it falls out the

00:37:52,400 --> 00:37:58,370
bottom of the queue and all the consumer

00:37:56,090 --> 00:38:00,190
rejects it so you can say reject this

00:37:58,370 --> 00:38:03,140
message I don't want to process it and

00:38:00,190 --> 00:38:06,740
you've turned off re queuing so there's

00:38:03,140 --> 00:38:09,050
two two requirements that all the queue

00:38:06,740 --> 00:38:12,230
length limit is exceeded now normally

00:38:09,050 --> 00:38:16,720
huge don't have a limit but you can put

00:38:12,230 --> 00:38:19,640
a limit on a queue if you want and so I

00:38:16,720 --> 00:38:22,280
mentioned if a TTL happens or you know

00:38:19,640 --> 00:38:24,320
these other circumstances happen the

00:38:22,280 --> 00:38:26,540
queue the message falls out the bottom

00:38:24,320 --> 00:38:29,170
of the queue well a dead letter exchange

00:38:26,540 --> 00:38:32,900
is something that catches those message

00:38:29,170 --> 00:38:35,300
so a dead letter exchange is just a

00:38:32,900 --> 00:38:39,830
normal exchange and the messages go into

00:38:35,300 --> 00:38:41,420
this exchange and into another cute so a

00:38:39,830 --> 00:38:46,370
common use case for this that I see in

00:38:41,420 --> 00:38:49,280
the wild is the you want to delay the

00:38:46,370 --> 00:38:52,490
processing of a message say for example

00:38:49,280 --> 00:38:55,340
you have a web head with a MySQL

00:38:52,490 --> 00:38:58,280
database and a reporting a data

00:38:55,340 --> 00:39:00,530
processing database

00:38:58,280 --> 00:39:01,670
we have SQL replicate replication from

00:39:00,530 --> 00:39:07,970
the webhead

00:39:01,670 --> 00:39:11,420
to this reporting server and AMQP is

00:39:07,970 --> 00:39:16,220
much faster than sq auric replication so

00:39:11,420 --> 00:39:20,230
what we could do to overcome that issue

00:39:16,220 --> 00:39:23,870
is use a combination of a TTL and indeed

00:39:20,230 --> 00:39:27,620
DLX so when you send a message through

00:39:23,870 --> 00:39:32,240
you could say this message has a TTL of

00:39:27,620 --> 00:39:34,130
five seconds and after five seconds is

00:39:32,240 --> 00:39:36,200
up that message will drop into the dead

00:39:34,130 --> 00:39:41,000
letter exchange and go into a different

00:39:36,200 --> 00:39:43,460
Q and that Q is the one you listen to if

00:39:41,000 --> 00:39:49,580
you want messages delayed by five

00:39:43,460 --> 00:39:52,460
seconds which is useful in some cases so

00:39:49,580 --> 00:39:56,450
you can try all this out

00:39:52,460 --> 00:39:59,810
as a concept if you like without getting

00:39:56,450 --> 00:40:03,110
too technical in fact try RabbitMQ comm

00:39:59,810 --> 00:40:04,400
has a RabbitMQ simulator and basically

00:40:03,110 --> 00:40:06,920
what that allows you to do is draw

00:40:04,400 --> 00:40:09,710
pretty diagrams using the concepts in

00:40:06,920 --> 00:40:12,310
rabbitmq and you can send messages

00:40:09,710 --> 00:40:16,220
through it and see how they react to

00:40:12,310 --> 00:40:17,870
binding keys messages there TTL x' and

00:40:16,220 --> 00:40:20,240
things like that so you can actually

00:40:17,870 --> 00:40:23,290
have a play around with the abstract

00:40:20,240 --> 00:40:27,110
concepts introduced by rabbit and key

00:40:23,290 --> 00:40:29,020
okay one more thing that I'm going to

00:40:27,110 --> 00:40:31,730
talk about today is about infrastructure

00:40:29,020 --> 00:40:33,890
the astute among you might have noticed

00:40:31,730 --> 00:40:36,650
there's a single point of failure well

00:40:33,890 --> 00:40:41,210
what happens if rabbitmq server that

00:40:36,650 --> 00:40:42,770
dies well it's fine because we've got

00:40:41,210 --> 00:40:47,030
this thing called clustering I mentioned

00:40:42,770 --> 00:40:50,270
it way at the start and you can create a

00:40:47,030 --> 00:40:51,770
cluster of RabbitMQ nodes and it

00:40:50,270 --> 00:40:55,670
tolerates the failure of one or more

00:40:51,770 --> 00:40:58,160
nodes up until there's one left and when

00:40:55,670 --> 00:41:01,250
you have this sort of setup I recommend

00:40:58,160 --> 00:41:05,050
using like a load balancer or floating

00:41:01,250 --> 00:41:08,060
IP in low TTL DNS something like that

00:41:05,050 --> 00:41:10,280
don't connect to a node directly let

00:41:08,060 --> 00:41:11,720
something else deal with that for you so

00:41:10,280 --> 00:41:12,260
that you know that the node you are

00:41:11,720 --> 00:41:18,050
connecting to

00:41:12,260 --> 00:41:20,920
is gonna be up so when you set up a

00:41:18,050 --> 00:41:23,930
cluster with RabbitMQ everything is

00:41:20,920 --> 00:41:27,890
replicated that you need to operate the

00:41:23,930 --> 00:41:30,620
cluster except for the queues the queues

00:41:27,890 --> 00:41:32,090
themselves are not replicated they only

00:41:30,620 --> 00:41:34,910
reside on the node that they were

00:41:32,090 --> 00:41:36,890
created on but they are accessible from

00:41:34,910 --> 00:41:38,810
any node so if you connect to the wrong

00:41:36,890 --> 00:41:42,080
node or a queue isn't stored it's okay

00:41:38,810 --> 00:41:43,880
because the messages still get to you so

00:41:42,080 --> 00:41:45,470
it's a sort of a transparent process if

00:41:43,880 --> 00:41:49,370
you like but that's something to be

00:41:45,470 --> 00:41:53,060
aware of there's two types there's a

00:41:49,370 --> 00:41:55,520
disk node and a ram node a disk node

00:41:53,060 --> 00:41:57,770
writes all that all of its cues both to

00:41:55,520 --> 00:42:01,730
ram and to disk so it always goes into

00:41:57,770 --> 00:42:03,380
ram a ram queue performs very marginally

00:42:01,730 --> 00:42:05,440
better you'd think it would be a lot

00:42:03,380 --> 00:42:09,710
better but actually because it disk

00:42:05,440 --> 00:42:15,170
writes to ram and disk the difference

00:42:09,710 --> 00:42:17,570
there is not much I'm gonna mention

00:42:15,170 --> 00:42:21,140
something about a high watermark this

00:42:17,570 --> 00:42:24,050
quarter cell with memory limits on a

00:42:21,140 --> 00:42:27,980
server okay so we have a message queue

00:42:24,050 --> 00:42:31,040
server with one gigabyte erm Ark is

00:42:27,980 --> 00:42:35,420
basically a setting in RabbitMQ that

00:42:31,040 --> 00:42:39,200
allows you to to set how much memory to

00:42:35,420 --> 00:42:42,650
use for a bank you okay what caught us

00:42:39,200 --> 00:42:45,140
out is it by default uses no point four

00:42:42,650 --> 00:42:46,490
percent of your memory so one out

00:42:45,140 --> 00:42:48,680
gigabyte server which you thought out

00:42:46,490 --> 00:42:51,020
gigabyte it'd be fine it was actually

00:42:48,680 --> 00:42:52,580
only using about 400 Meg and I noticed

00:42:51,020 --> 00:42:54,170
that at the same time was and I put

00:42:52,580 --> 00:42:55,220
those two or three million messages it

00:42:54,170 --> 00:42:58,700
oops

00:42:55,220 --> 00:43:00,530
and that broke things a lot because once

00:42:58,700 --> 00:43:02,720
your rabbit and cue server reaches that

00:43:00,530 --> 00:43:04,820
high-water mark it will stop accepting

00:43:02,720 --> 00:43:08,140
new messages so the website went down

00:43:04,820 --> 00:43:10,850
and everything I was in trouble

00:43:08,140 --> 00:43:13,610
so configuring a cluster let's have a

00:43:10,850 --> 00:43:16,280
quick look you can use the CLI a tool

00:43:13,610 --> 00:43:18,680
called rabbitmq CTL it's a little bit

00:43:16,280 --> 00:43:21,050
easier but if the entire cluster dies

00:43:18,680 --> 00:43:23,260
you lose all your configuration so

00:43:21,050 --> 00:43:25,640
probably a safer ways to use

00:43:23,260 --> 00:43:27,190
configuration files and the format's not

00:43:25,640 --> 00:43:29,030
great

00:43:27,190 --> 00:43:31,910
looks a little bit like this there's

00:43:29,030 --> 00:43:33,650
lots of square brackets and curly braces

00:43:31,910 --> 00:43:35,480
and things like that so this is on our

00:43:33,650 --> 00:43:39,830
dev machine notice the high watermark

00:43:35,480 --> 00:43:40,940
I've changed there and if you're ever

00:43:39,830 --> 00:43:42,350
not sure about how to write these

00:43:40,940 --> 00:43:45,740
configuration files just stick some

00:43:42,350 --> 00:43:46,970
curly braces and square brackets in no

00:43:45,740 --> 00:43:50,720
that won't work by the way

00:43:46,970 --> 00:43:52,880
don't bother trying so to set up this

00:43:50,720 --> 00:43:56,780
cluster well first of all we can use the

00:43:52,880 --> 00:43:58,850
cluster status command to inspect the

00:43:56,780 --> 00:44:01,250
state of the cluster if we were to run

00:43:58,850 --> 00:44:03,080
this on each node you'll notice that

00:44:01,250 --> 00:44:05,900
they only aware of themselves they'll

00:44:03,080 --> 00:44:08,030
only show themselves on each node so

00:44:05,900 --> 00:44:12,320
let's create a cluster to join a node

00:44:08,030 --> 00:44:16,130
you use join cluster command on our

00:44:12,320 --> 00:44:17,900
first one we specify - - REM to make it

00:44:16,130 --> 00:44:20,150
an a ram node if you omit this it's a

00:44:17,900 --> 00:44:21,890
disk mote disk node and the last

00:44:20,150 --> 00:44:23,960
parameter here is the hostname of any

00:44:21,890 --> 00:44:25,550
existing node in the cluster so it

00:44:23,960 --> 00:44:27,160
doesn't matter which one just join it

00:44:25,550 --> 00:44:31,910
they're all equal in this cluster

00:44:27,160 --> 00:44:34,610
there's no masters and the second

00:44:31,910 --> 00:44:37,280
command for that reason could be written

00:44:34,610 --> 00:44:41,090
as rabbitmq CTL join cluster rabbit at

00:44:37,280 --> 00:44:42,970
node 1 or no - doesn't matter so if we

00:44:41,090 --> 00:44:45,620
run clade cluster status after this

00:44:42,970 --> 00:44:48,530
you'll see that all of three nodes are

00:44:45,620 --> 00:44:49,790
now joined into the cluster we've made a

00:44:48,530 --> 00:44:53,500
cluster as easy as that

00:44:49,790 --> 00:44:55,790
you'll see do this in configuration

00:44:53,500 --> 00:44:58,340
starting and stopping nodes is easy you

00:44:55,790 --> 00:45:00,170
can restart nodes at will when a node is

00:44:58,340 --> 00:45:02,270
not running it will not appear in the

00:45:00,170 --> 00:45:04,880
running nodes section in cluster status

00:45:02,270 --> 00:45:08,990
they will automatically reconnect if you

00:45:04,880 --> 00:45:11,660
start and stop removing nodes is a

00:45:08,990 --> 00:45:14,330
straight full process - first of all you

00:45:11,660 --> 00:45:17,150
stop the node you want to remove then on

00:45:14,330 --> 00:45:20,570
any existing and running node use the

00:45:17,150 --> 00:45:23,270
forget cluster node command now when you

00:45:20,570 --> 00:45:24,770
bring node 1 back up it will have an

00:45:23,270 --> 00:45:26,240
error and say oh I can't connect to my

00:45:24,770 --> 00:45:28,070
cluster because it thinks it's still in

00:45:26,240 --> 00:45:30,530
a cluster so you have to reset it

00:45:28,070 --> 00:45:32,600
beforehand and finally if you run

00:45:30,530 --> 00:45:37,070
cluster status you'll notice that node 1

00:45:32,600 --> 00:45:39,320
was removed from the cluster ok so I

00:45:37,070 --> 00:45:41,120
mentioned that queues are not replicated

00:45:39,320 --> 00:45:42,650
it's cool they've got a solution for

00:45:41,120 --> 00:45:46,490
that too and we use this

00:45:42,650 --> 00:45:48,410
high-availability it's typically you

00:45:46,490 --> 00:45:50,990
probably use less nodes so it tolerates

00:45:48,410 --> 00:45:52,820
slightly less failure but I've never had

00:45:50,990 --> 00:45:56,990
a rabbit in queue server to go down on

00:45:52,820 --> 00:45:58,490
me that wasn't my fault I still

00:45:56,990 --> 00:46:01,010
recommend the load balance or floating

00:45:58,490 --> 00:46:02,090
IP things like that but the big

00:46:01,010 --> 00:46:04,730
difference here is that queues are

00:46:02,090 --> 00:46:09,080
replicated so it copies the actual queue

00:46:04,730 --> 00:46:10,370
messages to all of the nodes and to do

00:46:09,080 --> 00:46:12,800
that is really simple you set up a

00:46:10,370 --> 00:46:15,770
cluster first and then you use a set

00:46:12,800 --> 00:46:17,480
policy you can do that in the management

00:46:15,770 --> 00:46:19,370
console with the web interface to

00:46:17,480 --> 00:46:22,010
configure these high availability

00:46:19,370 --> 00:46:23,180
parameters now the actual syntax and

00:46:22,010 --> 00:46:26,840
things for that I don't know because I

00:46:23,180 --> 00:46:28,310
didn't do someone else did so as I

00:46:26,840 --> 00:46:30,050
mentioned you can have a go yourself

00:46:28,310 --> 00:46:31,580
some of you may have been following

00:46:30,050 --> 00:46:33,320
along with your phone looking at the

00:46:31,580 --> 00:46:35,780
code and you may have noticed that

00:46:33,320 --> 00:46:38,180
there's a vagrant file there and

00:46:35,780 --> 00:46:40,640
instructions to get set up so you can

00:46:38,180 --> 00:46:44,180
actually play around with the examples

00:46:40,640 --> 00:46:49,580
they've given any time you want go here

00:46:44,180 --> 00:46:52,160
yeah here and clone the repository of so

00:46:49,580 --> 00:46:57,200
you'll need vagrant or use the

00:46:52,160 --> 00:47:00,580
instructions on it on a server ok thank

00:46:57,200 --> 00:47:00,580
you very much are there any questions

00:47:05,390 --> 00:47:10,800
actually was this morning we ask one

00:47:07,320 --> 00:47:13,440
question up front how many people have

00:47:10,800 --> 00:47:17,690
actually used a cue server at all in

00:47:13,440 --> 00:47:20,820
their work before Miami hands cool I

00:47:17,690 --> 00:47:25,830
mean you guys as well okay and how many

00:47:20,820 --> 00:47:26,430
back to use rabbitmq itself okay so it's

00:47:25,830 --> 00:47:29,460
a babe

00:47:26,430 --> 00:47:31,950
80% of used cues and have a 50% of use

00:47:29,460 --> 00:47:37,950
route oh cool

00:47:31,950 --> 00:47:40,580
interesting hi I have one question how

00:47:37,950 --> 00:47:44,790
you solve versioning of your messages

00:47:40,580 --> 00:47:48,240
let's do understand this question or I

00:47:44,790 --> 00:47:51,420
should say say it again how you solve

00:47:48,240 --> 00:47:54,060
versioning of your messages versioning

00:47:51,420 --> 00:47:56,430
yeah well you deploy a new version on

00:47:54,060 --> 00:47:59,610
server you have some old messages in

00:47:56,430 --> 00:48:02,910
queue then new appears and you will

00:47:59,610 --> 00:48:06,570
start your consumer consumers so how you

00:48:02,910 --> 00:48:09,150
do with that okay so I understand yeah

00:48:06,570 --> 00:48:11,700
so if you send a message and you've

00:48:09,150 --> 00:48:12,720
still got your process running well the

00:48:11,700 --> 00:48:14,130
process is still running

00:48:12,720 --> 00:48:17,490
obviously the code hasn't changed

00:48:14,130 --> 00:48:20,790
because PHP does not you know hot code

00:48:17,490 --> 00:48:23,010
swap I think they call it so actually

00:48:20,790 --> 00:48:24,450
what you can do is leave your processor

00:48:23,010 --> 00:48:28,980
running once you've deployed your code

00:48:24,450 --> 00:48:30,480
and yeah if you leave it running then

00:48:28,980 --> 00:48:32,940
it's still going to process those using

00:48:30,480 --> 00:48:34,080
the old code so when you deploy it and

00:48:32,940 --> 00:48:37,020
you're happy that all the messages have

00:48:34,080 --> 00:48:40,410
been processed successfully then you can

00:48:37,020 --> 00:48:44,040
kill that server that process and start

00:48:40,410 --> 00:48:47,010
the new one with the new code typically

00:48:44,040 --> 00:48:48,540
I've not really done that maybe one way

00:48:47,010 --> 00:48:50,340
to do is if you don't care about the

00:48:48,540 --> 00:48:53,010
content of the queues you could purge

00:48:50,340 --> 00:48:55,460
them which obviously deletes all them

00:48:53,010 --> 00:48:57,300
the messages in it it depends how

00:48:55,460 --> 00:48:58,700
violent you want to get with it I

00:48:57,300 --> 00:49:07,160
suppose

00:48:58,700 --> 00:49:07,160
okay any questions in this room okay

00:49:08,090 --> 00:49:13,800
yeah the question is when you do

00:49:11,550 --> 00:49:16,140
clusters and you join nodes together

00:49:13,800 --> 00:49:19,800
there is anything in rabbitmq

00:49:16,140 --> 00:49:24,510
that actually deals with connections and

00:49:19,800 --> 00:49:27,420
network holds now the replication

00:49:24,510 --> 00:49:30,540
doesn't happen yeah network faults are

00:49:27,420 --> 00:49:34,110
an interesting one RabbitMQ is not very

00:49:30,540 --> 00:49:36,440
tolerant of network faults so their

00:49:34,110 --> 00:49:42,840
recommendation is that you don't

00:49:36,440 --> 00:49:46,800
replicate across potentially a wider net

00:49:42,840 --> 00:49:49,710
wide area network so the better way of

00:49:46,800 --> 00:49:53,700
doing that is to use a plug-in called

00:49:49,710 --> 00:49:56,520
shovel now shovel basically takes all

00:49:53,700 --> 00:49:58,830
the contents of a queue and moves it to

00:49:56,520 --> 00:50:01,590
another server shovels them from one to

00:49:58,830 --> 00:50:04,920
the other so if you wanted to replicate

00:50:01,590 --> 00:50:06,620
across you know the internet for example

00:50:04,920 --> 00:50:11,310
I'd recommend doing something like that

00:50:06,620 --> 00:50:19,890
does that answer your question I can't

00:50:11,310 --> 00:50:21,810
see him nodding so cool thank you I'm

00:50:19,890 --> 00:50:23,340
wondering when you use a routing key to

00:50:21,810 --> 00:50:26,640
get a burr topic exchanged you have

00:50:23,340 --> 00:50:28,100
multiple consumers okay you have three

00:50:26,640 --> 00:50:30,870
consumers that can take the same message

00:50:28,100 --> 00:50:33,990
would all three consumers receive the

00:50:30,870 --> 00:50:35,340
message or might only two or one of them

00:50:33,990 --> 00:50:36,900
receive it depending on where they are

00:50:35,340 --> 00:50:40,710
in the cycle if they're only already

00:50:36,900 --> 00:50:43,410
processing and so forth so if you have

00:50:40,710 --> 00:50:45,960
multiple consumers connected to one

00:50:43,410 --> 00:50:48,090
queue the message will only get

00:50:45,960 --> 00:50:50,360
processed by one of those consumers so

00:50:48,090 --> 00:50:53,430
the other consumers won't be aware of it

00:50:50,360 --> 00:50:57,210
the only way that a message could be

00:50:53,430 --> 00:51:00,180
duplicated is by using you know binding

00:50:57,210 --> 00:51:01,680
keys on different hues or using a

00:51:00,180 --> 00:51:05,190
fan-out exchange with multiple queues

00:51:01,680 --> 00:51:07,800
attached to it so when you have multiple

00:51:05,190 --> 00:51:10,050
consumers on one it will only see the

00:51:07,800 --> 00:51:12,050
message once but if you duplicate that

00:51:10,050 --> 00:51:14,730
message out you'll see it multiple times

00:51:12,050 --> 00:51:18,060
okay see for example the example you did

00:51:14,730 --> 00:51:22,410
with logging yeah if you need to make

00:51:18,060 --> 00:51:24,660
certain it's only handled by that

00:51:22,410 --> 00:51:26,250
consumer and then that's consumer again

00:51:24,660 --> 00:51:30,120
logs it to this database service like

00:51:26,250 --> 00:51:31,680
the normal logger will do yeah um so I

00:51:30,120 --> 00:51:33,960
mentioned earlier so we have a

00:51:31,680 --> 00:51:36,030
submission system which submits leads to

00:51:33,960 --> 00:51:37,680
a third party obviously we don't want to

00:51:36,030 --> 00:51:39,480
send that lead multiple times otherwise

00:51:37,680 --> 00:51:41,480
they'll complain that we keep sending

00:51:39,480 --> 00:51:44,900
the same lead

00:51:41,480 --> 00:51:47,160
we are just careful about how we

00:51:44,900 --> 00:51:49,110
architecture that so we as I mentioned

00:51:47,160 --> 00:51:53,220
we use a TTL to make sure that we don't

00:51:49,110 --> 00:51:55,680
cure the same message twice so yeah it's

00:51:53,220 --> 00:51:58,050
it's you just need to be aware of how it

00:51:55,680 --> 00:52:00,450
works in order to overcome you know

00:51:58,050 --> 00:52:03,360
duplicate submissions for example I

00:52:00,450 --> 00:52:06,210
think that's why thank you okay we got

00:52:03,360 --> 00:52:07,770
one in the other room if you use

00:52:06,210 --> 00:52:10,050
temporary queues and turn off at

00:52:07,770 --> 00:52:11,370
knowledge mints what's the maximum kind

00:52:10,050 --> 00:52:15,210
of throughput that you can look at using

00:52:11,370 --> 00:52:18,600
Bob MQ messages per second uh it's

00:52:15,210 --> 00:52:21,990
limited by memory and just how fast the

00:52:18,600 --> 00:52:25,350
server is turning off acknowledgement on

00:52:21,990 --> 00:52:28,770
Iran or on or off doesn't make that much

00:52:25,350 --> 00:52:32,310
of a difference to throughput but if you

00:52:28,770 --> 00:52:33,810
don't acknowledge these messages well as

00:52:32,310 --> 00:52:36,470
I said you can have with scenarios where

00:52:33,810 --> 00:52:39,990
your messages start getting reprocessed

00:52:36,470 --> 00:52:42,690
so three put throughput of any parts of

00:52:39,990 --> 00:52:44,550
rabbitmq is just limited by your network

00:52:42,690 --> 00:52:45,690
speed that how fast the server is and so

00:52:44,550 --> 00:52:48,990
on so it just uses the resources

00:52:45,690 --> 00:52:54,650
available to it that answer your

00:52:48,990 --> 00:52:54,650
question that's yep cool thank you

00:52:56,540 --> 00:53:05,940
you got one Erin no okay got one in the

00:53:01,890 --> 00:53:08,190
other room again hi are the queues

00:53:05,940 --> 00:53:10,080
always first in first out or is there

00:53:08,190 --> 00:53:12,120
anything to change that or to prioritize

00:53:10,080 --> 00:53:14,670
messages so that for example in your

00:53:12,120 --> 00:53:16,230
logging example there might be a high

00:53:14,670 --> 00:53:18,420
priority area that you would deal with

00:53:16,230 --> 00:53:22,590
first before some low-level debug

00:53:18,420 --> 00:53:25,590
messages I don't know for sure there may

00:53:22,590 --> 00:53:27,900
be a prioritization mechanism but I

00:53:25,590 --> 00:53:31,160
don't know it's a good question thank

00:53:27,900 --> 00:53:31,160
you but I can't answer it

00:53:32,450 --> 00:53:36,990
someone suggested in here that you could

00:53:34,589 --> 00:53:38,520
use routing keys for that so yeah that's

00:53:36,990 --> 00:53:41,670
one way if there isn't a prioritization

00:53:38,520 --> 00:53:48,119
feature I don't think there is I've not

00:53:41,670 --> 00:53:51,119
come across it aha there's a priority

00:53:48,119 --> 00:53:52,559
plug-in apparently okay so yes it's

00:53:51,119 --> 00:53:56,180
possible with a plug-in then thank you

00:53:52,559 --> 00:53:56,180
thank you for helping me out this power

00:53:59,809 --> 00:54:06,950
anymore in here anyone else got one more

00:54:04,829 --> 00:54:06,950
in here

00:54:07,549 --> 00:54:13,890
hi when you're declaring all the

00:54:11,279 --> 00:54:16,619
exchanges in the queues do you have to

00:54:13,890 --> 00:54:18,059
keep track to declare them exactly the

00:54:16,619 --> 00:54:20,160
same in both the producer and the

00:54:18,059 --> 00:54:23,940
consumer yes it's like there's nowhere

00:54:20,160 --> 00:54:26,010
to store that configuration yes that's

00:54:23,940 --> 00:54:28,619
the names of the queues and things are

00:54:26,010 --> 00:54:33,420
controlled by your code so if they don't

00:54:28,619 --> 00:54:36,390
match then they're not gonna produce or

00:54:33,420 --> 00:54:39,210
consume the same thing you could store

00:54:36,390 --> 00:54:40,490
it in configuration or hard-code it it's

00:54:39,210 --> 00:54:44,039
you know that's an application

00:54:40,490 --> 00:54:45,980
architecture thing so yeah they need to

00:54:44,039 --> 00:54:57,059
match obviously otherwise they won't

00:54:45,980 --> 00:54:58,799
won't do what you expect yeah indeed for

00:54:57,059 --> 00:55:00,809
our application we store the name of the

00:54:58,799 --> 00:55:03,029
exchanges in the queues in array

00:55:00,809 --> 00:55:06,359
configuration we use that f2 and Zell F

00:55:03,029 --> 00:55:07,650
to love arrays so we store we store the

00:55:06,359 --> 00:55:10,890
names of the queues and exchanges that

00:55:07,650 --> 00:55:13,319
we use in there and we've got that same

00:55:10,890 --> 00:55:15,510
configuration on both the producers and

00:55:13,319 --> 00:55:18,390
the consumers so that that is shared

00:55:15,510 --> 00:55:32,430
code if you like that's one way of doing

00:55:18,390 --> 00:55:34,589
it feature does that the point is that

00:55:32,430 --> 00:55:36,779
cubed it sets a kind of like a one-off

00:55:34,589 --> 00:55:39,750
cue but it's just for replying to that

00:55:36,779 --> 00:55:41,819
particular consumer yes absolutely I am

00:55:39,750 --> 00:55:42,640
I didn't give a code example there but

00:55:41,819 --> 00:55:44,800
when

00:55:42,640 --> 00:55:48,520
you when you're listening for the

00:55:44,800 --> 00:55:50,110
message there you might not have that

00:55:48,520 --> 00:56:06,790
while loop so you were just listen for

00:55:50,110 --> 00:56:10,720
one message then quit if he said

00:56:06,790 --> 00:56:14,080
acknowledgments like a sort of a message

00:56:10,720 --> 00:56:15,580
completed message to the queue so the

00:56:14,080 --> 00:56:18,910
message doesn't get picked up by another

00:56:15,580 --> 00:56:22,750
consumer if the acknowledgement didn't

00:56:18,910 --> 00:56:24,280
set or isn't sent then the same message

00:56:22,750 --> 00:56:29,530
could be picked up again by another

00:56:24,280 --> 00:56:38,290
consumer so is there some locking

00:56:29,530 --> 00:56:40,300
mechanism so if this I I think I see

00:56:38,290 --> 00:56:42,760
what you mean so if if a message is

00:56:40,300 --> 00:56:45,850
currently being processed will any other

00:56:42,760 --> 00:56:50,590
consumer be able to know so RabbitMQ

00:56:45,850 --> 00:56:52,930
will only send the message once so when

00:56:50,590 --> 00:56:54,310
you don't automatically acknowledge and

00:56:52,930 --> 00:56:57,850
you forget to acknowledge that message

00:56:54,310 --> 00:57:01,870
in your code the reason it builds up

00:56:57,850 --> 00:57:04,060
those are non acknowledge messages it's

00:57:01,870 --> 00:57:06,910
because rabbit and queue only tries to

00:57:04,060 --> 00:57:10,930
process things once by default if you

00:57:06,910 --> 00:57:12,910
like so if you don't acknowledge those

00:57:10,930 --> 00:57:14,760
messages it sort of holds them in limbo

00:57:12,910 --> 00:57:17,200
if you like they're still in the queue

00:57:14,760 --> 00:57:19,000
if you look at the management console

00:57:17,200 --> 00:57:23,530
it'll say there's unacknowledged

00:57:19,000 --> 00:57:25,600
messages and the reason why they get

00:57:23,530 --> 00:57:27,190
reprocessed is because when the process

00:57:25,600 --> 00:57:29,590
dies rabbit and queue knows that that

00:57:27,190 --> 00:57:31,420
connection is closed so it says although

00:57:29,590 --> 00:57:34,510
all of these messages haven't yet been

00:57:31,420 --> 00:57:37,000
processed so I'm going to put them back

00:57:34,510 --> 00:57:41,320
in the queue for another consumer to to

00:57:37,000 --> 00:57:45,160
process so while it's being processed no

00:57:41,320 --> 00:57:46,960
it can't get recued if you like but as

00:57:45,160 --> 00:57:49,240
soon as your process dies like exception

00:57:46,960 --> 00:57:53,470
or error or something like that

00:57:49,240 --> 00:57:55,559
then it will get recued but not at the

00:57:53,470 --> 00:58:08,849
same time

00:57:55,559 --> 00:58:12,029
answers the question so the comment for

00:58:08,849 --> 00:58:15,150
those in the other room is that is there

00:58:12,029 --> 00:58:18,199
a way of putting those into a garbage

00:58:15,150 --> 00:58:18,199
collection key or something like that

00:58:21,410 --> 00:58:26,459
possibly I don't know I think I can

00:58:23,849 --> 00:58:28,799
answer that one ever done that yeah if

00:58:26,459 --> 00:58:31,140
you have messages that go on to DLX or

00:58:28,799 --> 00:58:32,430
on to a failure state you can definitely

00:58:31,140 --> 00:58:33,660
riku them onto another queue and over

00:58:32,430 --> 00:58:35,819
the consumer you deal with that kind of

00:58:33,660 --> 00:58:37,529
garbage that was I did explain that yes

00:58:35,819 --> 00:58:39,509
you can absolutely do that

00:58:37,529 --> 00:58:41,459
if you reject a message or something

00:58:39,509 --> 00:58:41,910
like that yes you can tell it to go to a

00:58:41,459 --> 00:58:44,989
DLX

00:58:41,910 --> 00:58:44,989

YouTube URL: https://www.youtube.com/watch?v=0cWcCQSAY5o


