Title: Liam Wiltshire - PHP's biggest bottleneck, MySQL
Publication date: 2015-04-02
Playlist: PHP UK Conference 2015
Description: 
	Every day, PHP devs around the world are approached by stakeholders or managers and asked the same question..."Can't we make our application faster?" Forget adding more RAM, OpCode caching or load balancing - often the problem is much more obvious - mySQL. Every PHP developer knows how to query a table, join tables and many even do funky sub selects and unions, but not everyone knows how mySQL handles all this 'under the hood'. Some developers might be lucky enough to have a DBA to worry about all that - but most of us don't. Covering 8 of the most common issues and tools related to mySQL performance, any PHP developer will be able to soup up their mySQL install like a DBA ninja.

http://www.absolute-design.co.uk/absolute-php-mysql/img0.html
Captions: 
	00:00:00,000 --> 00:00:02,060
you

00:00:05,450 --> 00:00:10,969
my talks about pageviews biggest

00:00:08,000 --> 00:00:12,769
bottleneck which you can argue many many

00:00:10,969 --> 00:00:14,480
things are patriots biggest bottleneck

00:00:12,769 --> 00:00:18,020
but for the sake of this talk we're

00:00:14,480 --> 00:00:20,660
assuming it's my sequel so I'm Lynn work

00:00:18,020 --> 00:00:22,460
sure I've been working with PHP and

00:00:20,660 --> 00:00:25,279
Python and Perl for the last nine years

00:00:22,460 --> 00:00:27,349
or so and the director of development at

00:00:25,279 --> 00:00:29,239
absolute design which is awesome because

00:00:27,349 --> 00:00:31,099
it means I get to pick all the best and

00:00:29,239 --> 00:00:33,500
interesting projects for myself and give

00:00:31,099 --> 00:00:37,850
everything else to someone else I'm a

00:00:33,500 --> 00:00:40,520
fan of beer or wine whiskey kind of any

00:00:37,850 --> 00:00:41,960
alcohol really as I said you know I'm a

00:00:40,520 --> 00:00:43,570
director but I'm still hands-on

00:00:41,960 --> 00:00:45,829
particularly in terms of integrating

00:00:43,570 --> 00:00:48,920
third-party systems kind of interesting

00:00:45,829 --> 00:00:51,800
sorts of problems complex bills that

00:00:48,920 --> 00:00:53,780
sort of thing if you ask me I'm I would

00:00:51,800 --> 00:00:56,720
say I'm an awesome leader and an

00:00:53,780 --> 00:00:59,270
absolutely fantastic facilitator however

00:00:56,720 --> 00:01:01,160
if you ask some of the guys on my team

00:00:59,270 --> 00:01:08,570
then they'd probably tell you on this

00:01:01,160 --> 00:01:11,600
guy so what's the problem with my sequel

00:01:08,570 --> 00:01:14,299
why am I you know complaining about it

00:01:11,600 --> 00:01:16,639
today the the difficulty is that yo

00:01:14,299 --> 00:01:18,139
let's face it we're developers yo we

00:01:16,639 --> 00:01:21,380
trains developers we spend our time

00:01:18,139 --> 00:01:23,719
honing our craft you know in PHP or

00:01:21,380 --> 00:01:25,459
other languages yet we spend our spare

00:01:23,719 --> 00:01:28,639
time learning about new tools to add to

00:01:25,459 --> 00:01:30,350
our tool set new frameworks platforms

00:01:28,639 --> 00:01:32,719
whatever that is new development

00:01:30,350 --> 00:01:35,240
processes whether it's you know tee dee

00:01:32,719 --> 00:01:37,609
dee dee dee dee whatever and we don't

00:01:35,240 --> 00:01:39,740
spend time focusing on my sequel we kind

00:01:37,609 --> 00:01:42,139
of know how it works and yeah we can

00:01:39,740 --> 00:01:44,539
build DB and we get its connective PHP

00:01:42,139 --> 00:01:47,959
and for a lot of developers that's about

00:01:44,539 --> 00:01:50,590
it in most organizations developers are

00:01:47,959 --> 00:01:53,329
expected to do my single by extension

00:01:50,590 --> 00:01:55,579
you know if you re lucky working a large

00:01:53,329 --> 00:01:59,119
organization like a bank then you might

00:01:55,579 --> 00:02:00,619
have one of these guys to call on if I'm

00:01:59,119 --> 00:02:02,479
not sure how I can read that says I am a

00:02:00,619 --> 00:02:04,689
database administrator to save time

00:02:02,479 --> 00:02:10,729
let's just assume that I'm never wrong

00:02:04,689 --> 00:02:12,920
but the reality is you probably don't so

00:02:10,729 --> 00:02:15,590
this isn't a talk about looking at

00:02:12,920 --> 00:02:17,870
complex setups that you know get the

00:02:15,590 --> 00:02:19,310
ultimate in my signal performance those

00:02:17,870 --> 00:02:21,319
setups are perfectly valid

00:02:19,310 --> 00:02:23,540
and justified yeah we're not talking

00:02:21,319 --> 00:02:26,780
about shouting we're not talking about

00:02:23,540 --> 00:02:29,660
you know really large you know

00:02:26,780 --> 00:02:31,220
distributed setups that sort of thing in

00:02:29,660 --> 00:02:32,989
a lot of instances you know there are

00:02:31,220 --> 00:02:35,510
lots of very simple ways you can improve

00:02:32,989 --> 00:02:37,220
your mystical performance just by making

00:02:35,510 --> 00:02:39,050
very small changes that you could go and

00:02:37,220 --> 00:02:41,690
do in the next coffee break to be

00:02:39,050 --> 00:02:44,090
perfectly honest and they'd make a big

00:02:41,690 --> 00:02:46,819
difference yet the important thing is to

00:02:44,090 --> 00:02:48,470
benchmark so not all the things I'm

00:02:46,819 --> 00:02:50,450
going to discuss will work in every

00:02:48,470 --> 00:02:52,790
situation some of them were great in

00:02:50,450 --> 00:02:54,290
certain applications so then my accent

00:02:52,790 --> 00:02:57,380
your application slower in certain

00:02:54,290 --> 00:03:00,410
instances so measure first always always

00:02:57,380 --> 00:03:03,530
measure first make the change on your

00:03:00,410 --> 00:03:05,780
staging box test platform whatever then

00:03:03,530 --> 00:03:07,220
measure again you know if it's made an

00:03:05,780 --> 00:03:08,450
improvement great push down to

00:03:07,220 --> 00:03:11,660
production because not made an

00:03:08,450 --> 00:03:13,190
improvement look at something else there

00:03:11,660 --> 00:03:14,720
are plenty of other ways hasn't said you

00:03:13,190 --> 00:03:16,910
know hardware solutions clustering

00:03:14,720 --> 00:03:19,250
replication but what we're looking for

00:03:16,910 --> 00:03:21,739
here are measurable gains through simple

00:03:19,250 --> 00:03:25,760
improvements and hopefully you can

00:03:21,739 --> 00:03:29,150
become Oh where's he gone addy be ninja

00:03:25,760 --> 00:03:30,739
but the deviant engine areas DB ninja um

00:03:29,150 --> 00:03:33,440
it's a ninja holding a database

00:03:30,739 --> 00:03:34,970
apparently so first we're going to look

00:03:33,440 --> 00:03:37,220
at which hopefully you know you guys

00:03:34,970 --> 00:03:39,530
will all know about anyway are indexes

00:03:37,220 --> 00:03:43,220
some people say it's indices but it's

00:03:39,530 --> 00:03:44,959
nice indexes so most developers already

00:03:43,220 --> 00:03:46,760
have an idea about indexes yet we've all

00:03:44,959 --> 00:03:48,410
defined primary keys we've probably all

00:03:46,760 --> 00:03:50,620
done some foreign relations and we've

00:03:48,410 --> 00:03:55,069
added indexes two columns here in there

00:03:50,620 --> 00:03:57,829
however the way my cycle uses indexes is

00:03:55,069 --> 00:03:59,780
quite intricate and without necessarily

00:03:57,829 --> 00:04:01,910
understanding how how that works they

00:03:59,780 --> 00:04:03,799
may not be as efficient as they could be

00:04:01,910 --> 00:04:05,840
when at the most basic level which

00:04:03,799 --> 00:04:07,819
hopefully all you guys are doing them

00:04:05,840 --> 00:04:10,340
any way you can be they can be used to

00:04:07,819 --> 00:04:11,900
improve the performance of anything

00:04:10,340 --> 00:04:15,680
that's doing filtering or sorting such a

00:04:11,900 --> 00:04:17,419
where clause or an order and if that

00:04:15,680 --> 00:04:19,729
sent that you're not doing and all your

00:04:17,419 --> 00:04:22,370
DBS all your DB tables have a primary

00:04:19,729 --> 00:04:26,090
key and that's it you really should be

00:04:22,370 --> 00:04:27,680
adding indexes so here's a really really

00:04:26,090 --> 00:04:30,710
simple example through all of these

00:04:27,680 --> 00:04:32,300
tests I just set up some basic tables on

00:04:30,710 --> 00:04:34,220
this laptop

00:04:32,300 --> 00:04:36,949
it was kind of just a typical user table

00:04:34,220 --> 00:04:39,860
so it has an email address password a

00:04:36,949 --> 00:04:41,509
user type ID and address ID in which

00:04:39,860 --> 00:04:44,479
then relate to other tables and I

00:04:41,509 --> 00:04:46,400
populated it with 25,000 rose or so so

00:04:44,479 --> 00:04:47,720
it's a really small example but it is

00:04:46,400 --> 00:04:50,720
enough to show kind of some of the

00:04:47,720 --> 00:04:52,970
improvements you can make I wrote a

00:04:50,720 --> 00:04:56,030
really basic test script in PHP just to

00:04:52,970 --> 00:04:58,879
basically loop around 100 times run the

00:04:56,030 --> 00:05:01,069
query and take the timings because doing

00:04:58,879 --> 00:05:04,789
it once is never a you know accurate

00:05:01,069 --> 00:05:08,229
measure I did use my sequel I just

00:05:04,789 --> 00:05:10,430
because it was quick to set up last week

00:05:08,229 --> 00:05:12,409
so in this first instance instead of

00:05:10,430 --> 00:05:14,569
destroying a simple query just based on

00:05:12,409 --> 00:05:16,610
selecting the email address so that top

00:05:14,569 --> 00:05:18,710
1 i've got no indexes on the table at

00:05:16,610 --> 00:05:22,460
all it is just a user table and you can

00:05:18,710 --> 00:05:24,979
see to grab person with a email address

00:05:22,460 --> 00:05:26,990
just made up email address it was taking

00:05:24,979 --> 00:05:29,900
you know the minimum was naught point 3

00:05:26,990 --> 00:05:31,849
the max is not point 6 I've nope not

00:05:29,900 --> 00:05:34,099
sick sorry and the average again was not

00:05:31,849 --> 00:05:35,750
point naught 3 what you'll find with a

00:05:34,099 --> 00:05:37,969
lot of these things is actually the

00:05:35,750 --> 00:05:40,849
indexing even if the speed increases

00:05:37,969 --> 00:05:43,580
aren't large it makes the performance a

00:05:40,849 --> 00:05:45,800
lot more consistent evanescence since it

00:05:43,580 --> 00:05:47,599
does both so the minimum has dropped

00:05:45,800 --> 00:05:50,029
down to no point naught naught naught 6

00:05:47,599 --> 00:05:52,580
and the maximum average again so they've

00:05:50,029 --> 00:05:54,500
all dropped so just by adding a simple

00:05:52,580 --> 00:05:56,150
straightforward index on the email email

00:05:54,500 --> 00:05:59,210
column nothing more complicated than

00:05:56,150 --> 00:06:00,979
that standard btree index it's improved

00:05:59,210 --> 00:06:02,300
it by over thirty percent so as I said

00:06:00,979 --> 00:06:07,090
if you're not putting those indexes in

00:06:02,300 --> 00:06:09,139
place you really should be but indexes

00:06:07,090 --> 00:06:12,139
it might take you a lot more complicated

00:06:09,139 --> 00:06:14,389
than that it's interesting to know what

00:06:12,139 --> 00:06:15,860
indexes should really be used for so

00:06:14,389 --> 00:06:17,870
what intersection should be useful is to

00:06:15,860 --> 00:06:20,150
find groups of interesting rose rather

00:06:17,870 --> 00:06:21,800
than necessarily individual rows so it's

00:06:20,150 --> 00:06:23,900
finally if your index finds 50

00:06:21,800 --> 00:06:26,029
individual rows that's fine but it still

00:06:23,900 --> 00:06:27,620
then has to do 50 independent file reads

00:06:26,029 --> 00:06:31,219
to go and get that data in the database

00:06:27,620 --> 00:06:33,819
which is still going to suck whereas if

00:06:31,219 --> 00:06:36,590
it can find a collection of rows that

00:06:33,819 --> 00:06:38,180
you know could be the ones are looking

00:06:36,590 --> 00:06:40,129
for and it can pull out just a chunk of

00:06:38,180 --> 00:06:42,169
50 rows it might do a bit of extra

00:06:40,129 --> 00:06:44,330
filtering on that if necessary but the

00:06:42,169 --> 00:06:44,849
performance you'll get from that is a

00:06:44,330 --> 00:06:50,770
lot more

00:06:44,849 --> 00:06:52,300
impressive using indexes to avoid the

00:06:50,770 --> 00:06:56,139
need for temporary tables of file sorts

00:06:52,300 --> 00:06:58,330
in a lot of instances if you're doing

00:06:56,139 --> 00:07:00,610
queries where you've got you're trying

00:06:58,330 --> 00:07:02,530
to sort on a column if there's no sort

00:07:00,610 --> 00:07:03,729
there's no index on that sort what it

00:07:02,530 --> 00:07:06,160
has to do is pull out all the rows at

00:07:03,729 --> 00:07:08,280
once so it's found 50 rows from that

00:07:06,160 --> 00:07:10,660
table it then has to create a new table

00:07:08,280 --> 00:07:12,849
temporary table and put all those call

00:07:10,660 --> 00:07:15,280
it those rows back in it and then it has

00:07:12,849 --> 00:07:16,770
to solve that and obviously that's just

00:07:15,280 --> 00:07:19,630
a very inefficient way of doing things

00:07:16,770 --> 00:07:21,940
an equally the ultimate thing is to

00:07:19,630 --> 00:07:23,409
actually try and satisfy entire queries

00:07:21,940 --> 00:07:25,150
without needing to use the table if

00:07:23,409 --> 00:07:27,099
you've got what we call covering index

00:07:25,150 --> 00:07:28,360
so you've got an index that covers let's

00:07:27,099 --> 00:07:31,300
say you want the email address in the

00:07:28,360 --> 00:07:33,039
name if you have an index that has email

00:07:31,300 --> 00:07:34,599
address and name it can grab all the

00:07:33,039 --> 00:07:35,800
records it needs from our index and

00:07:34,599 --> 00:07:38,740
never actually has to read the full

00:07:35,800 --> 00:07:40,780
table at all and obviously that's going

00:07:38,740 --> 00:07:42,039
to be a lot more consistent and a lot

00:07:40,780 --> 00:07:44,020
quicker certainly if it's loading

00:07:42,039 --> 00:07:48,580
indexes into memory then trying to read

00:07:44,020 --> 00:07:51,669
them off the file disk so again using

00:07:48,580 --> 00:07:54,430
the same basic table the same same basic

00:07:51,669 --> 00:07:56,469
database table but with a few different

00:07:54,430 --> 00:07:57,909
queries and we're looking at how an

00:07:56,469 --> 00:08:00,460
index can be used to improve the

00:07:57,909 --> 00:08:04,150
performance of a sort so for this one

00:08:00,460 --> 00:08:05,889
again I've just put an index on the name

00:08:04,150 --> 00:08:09,940
column I mean the name was a 255

00:08:05,889 --> 00:08:11,919
character varchar I think and without an

00:08:09,940 --> 00:08:16,210
index again it's taking naught point

00:08:11,919 --> 00:08:18,430
naught 5 nope no 6 seconds whatever when

00:08:16,210 --> 00:08:19,930
it's being able to use just the index

00:08:18,430 --> 00:08:21,069
it's not having to read the DB table at

00:08:19,930 --> 00:08:23,500
all because we're only looking for the

00:08:21,069 --> 00:08:25,120
name column it's not having to look at

00:08:23,500 --> 00:08:26,740
the DB table is using just the index

00:08:25,120 --> 00:08:29,590
it's doing the sort in the index and

00:08:26,740 --> 00:08:31,750
it's just returning the results direct

00:08:29,590 --> 00:08:33,490
from the index you bring it down to know

00:08:31,750 --> 00:08:34,990
point naught 2 and you see again the

00:08:33,490 --> 00:08:36,370
time is very very consistent there's

00:08:34,990 --> 00:08:39,010
there's not much fluctuation in that

00:08:36,370 --> 00:08:40,870
time at all it makes it you know very

00:08:39,010 --> 00:08:45,100
very reliable very very consistent on

00:08:40,870 --> 00:08:47,560
the time it takes again here's another

00:08:45,100 --> 00:08:50,380
example so this one again is using a

00:08:47,560 --> 00:08:53,980
covering index on name email and user

00:08:50,380 --> 00:08:56,079
level ID and again the speed increases

00:08:53,980 --> 00:08:58,120
here aren't as big but again it's the

00:08:56,079 --> 00:09:00,160
consistency that we're interested in

00:08:58,120 --> 00:09:01,210
so that you know if you look at the top

00:09:00,160 --> 00:09:03,810
one the difference between the minimum

00:09:01,210 --> 00:09:06,850
and the maximum is naught point naught 3

00:09:03,810 --> 00:09:10,000
whereas in the next one down you know

00:09:06,850 --> 00:09:13,360
it's half as it's one less than naught

00:09:10,000 --> 00:09:15,100
point naught naught 5 and you know the

00:09:13,360 --> 00:09:17,589
individual speed but if you're the one

00:09:15,100 --> 00:09:20,320
that gets the slow slower query in the

00:09:17,589 --> 00:09:22,450
top instance compared to getting the

00:09:20,320 --> 00:09:23,800
slow query in the bottom instance that

00:09:22,450 --> 00:09:25,420
is going to make a measurable impact

00:09:23,800 --> 00:09:31,690
certainly if you've got a site being

00:09:25,420 --> 00:09:34,180
used by 50,000 users covered query

00:09:31,690 --> 00:09:35,950
covered indexes like episode covered

00:09:34,180 --> 00:09:37,810
queries like I said where the entire

00:09:35,950 --> 00:09:39,160
result can be pulled from an index will

00:09:37,810 --> 00:09:41,320
produce faster and more consistent

00:09:39,160 --> 00:09:43,170
results particularly when you are kind

00:09:41,320 --> 00:09:46,839
of using where's and sorts as well

00:09:43,170 --> 00:09:48,640
indices are stored on disk when they're

00:09:46,839 --> 00:09:49,720
first created but obviously for the best

00:09:48,640 --> 00:09:51,190
performance you do not store them in

00:09:49,720 --> 00:09:54,670
memory so if you've got some memory to

00:09:51,190 --> 00:09:56,650
throw out my sequel do it can store you

00:09:54,670 --> 00:09:59,200
can give memory to my sequel to use

00:09:56,650 --> 00:10:01,029
specifically for storing indexes and you

00:09:59,200 --> 00:10:03,040
know any indexes in memory is going to

00:10:01,029 --> 00:10:05,860
be much quicker to load than an index on

00:10:03,040 --> 00:10:08,830
disk keep indexes as small as possible

00:10:05,860 --> 00:10:11,320
so use the right data types you know use

00:10:08,830 --> 00:10:13,209
an inverse to begin arguably the

00:10:11,320 --> 00:10:14,470
difference is negligible but again if

00:10:13,209 --> 00:10:16,120
you're trying to scale this up and

00:10:14,470 --> 00:10:18,070
you're talking about thousands of users

00:10:16,120 --> 00:10:21,940
tet1 tens hundreds of thousands of users

00:10:18,070 --> 00:10:23,529
then it will make a difference and if

00:10:21,940 --> 00:10:25,839
you're using the index just for where's

00:10:23,529 --> 00:10:27,490
think about how long you need your index

00:10:25,839 --> 00:10:28,870
to be if you're looking for an email

00:10:27,490 --> 00:10:30,459
address and you're fairly confident

00:10:28,870 --> 00:10:32,110
actually after the first six characters

00:10:30,459 --> 00:10:34,630
each email address is probably going to

00:10:32,110 --> 00:10:37,390
be unique there's no point indexing the

00:10:34,630 --> 00:10:39,160
whole 255 character email address if you

00:10:37,390 --> 00:10:41,200
can index the first six you can't use

00:10:39,160 --> 00:10:44,589
that for sorting so you know do be aware

00:10:41,200 --> 00:10:46,870
of that but for doing where lookups

00:10:44,589 --> 00:10:48,910
often those first six 10 characters

00:10:46,870 --> 00:10:50,410
whatever are enough and it obviously

00:10:48,910 --> 00:10:52,050
means it's much easier to store that in

00:10:50,410 --> 00:10:55,839
memory it's going to use less space

00:10:52,050 --> 00:10:57,670
everyone wins the downsides using

00:10:55,839 --> 00:10:59,589
indexes and this is that trade-off is

00:10:57,670 --> 00:11:01,900
that they do create an additional load

00:10:59,589 --> 00:11:04,120
when you're doing rights so if you've

00:11:01,900 --> 00:11:07,270
got a right heavy application so in this

00:11:04,120 --> 00:11:09,730
updating the database frequently then

00:11:07,270 --> 00:11:11,529
actually the writing of the data back to

00:11:09,730 --> 00:11:13,240
the DB can then become the bottom

00:11:11,529 --> 00:11:16,209
if it's having to constantly update that

00:11:13,240 --> 00:11:19,540
index so again benchmark if you know

00:11:16,209 --> 00:11:21,670
you've got a right heavy application you

00:11:19,540 --> 00:11:23,920
know benchmark your put benchmark both

00:11:21,670 --> 00:11:26,769
reading and writing beforehand then put

00:11:23,920 --> 00:11:30,819
your indexes in and then bench when then

00:11:26,769 --> 00:11:32,850
tested again benchmark it again so next

00:11:30,819 --> 00:11:35,199
one we're gonna look at using explained

00:11:32,850 --> 00:11:37,600
using explain isn't actually a

00:11:35,199 --> 00:11:39,279
performance improvement in itself but

00:11:37,600 --> 00:11:41,769
what it allows you to do is break down

00:11:39,279 --> 00:11:44,379
exactly what a query is doing what we've

00:11:41,769 --> 00:11:46,749
referred to as execution plan so explain

00:11:44,379 --> 00:11:49,089
will show you which indexes can be used

00:11:46,749 --> 00:11:51,910
for any given query and then which index

00:11:49,089 --> 00:11:53,230
my seagull actually decided to use it

00:11:51,910 --> 00:11:54,999
will tell you if there's covering index

00:11:53,230 --> 00:11:57,309
it will tell you how many rows had to be

00:11:54,999 --> 00:11:59,559
scanned it will show you lots of other

00:11:57,309 --> 00:12:01,990
overheads so if it had to use a file

00:11:59,559 --> 00:12:04,660
sort or use a memory table whatever else

00:12:01,990 --> 00:12:08,290
and various other operations that the

00:12:04,660 --> 00:12:09,850
query had to do to be able to process so

00:12:08,290 --> 00:12:11,379
looking at this you can look at kind of

00:12:09,850 --> 00:12:14,290
where the weaknesses in your queries are

00:12:11,379 --> 00:12:16,389
and use these things in a social

00:12:14,290 --> 00:12:18,100
association with the other ideas that

00:12:16,389 --> 00:12:21,040
were talking about to improve the

00:12:18,100 --> 00:12:24,970
performance of those queries so here's

00:12:21,040 --> 00:12:26,709
an example using explain is as simple as

00:12:24,970 --> 00:12:29,379
sticking the word explain in front to

00:12:26,709 --> 00:12:31,809
your query so it's probably a little bit

00:12:29,379 --> 00:12:34,389
smaller I do apologize but I had a

00:12:31,809 --> 00:12:36,309
career here select you don't star a

00:12:34,389 --> 00:12:38,769
dollar a dress worn a dress to a lot

00:12:36,309 --> 00:12:40,029
postcode from users blah blah blah and

00:12:38,769 --> 00:12:41,829
all I've done is stick explain at the

00:12:40,029 --> 00:12:44,980
front of it and you get this execution

00:12:41,829 --> 00:12:48,279
plan back from my sequel so what it does

00:12:44,980 --> 00:12:51,129
is it gives you a row for each table

00:12:48,279 --> 00:12:53,980
within your query so you see I've got

00:12:51,129 --> 00:12:55,600
one for the you table which is the users

00:12:53,980 --> 00:12:58,649
table I want for the a table which is

00:12:55,600 --> 00:13:01,269
the address table it's saying that on

00:12:58,649 --> 00:13:03,160
the user table there actually no keys

00:13:01,269 --> 00:13:05,500
that i can use and on the dress table

00:13:03,160 --> 00:13:07,120
there's only the primary key it's

00:13:05,500 --> 00:13:08,980
telling me how many roses had to look up

00:13:07,120 --> 00:13:12,730
so in this example Biggs I've got no

00:13:08,980 --> 00:13:16,949
indexes it had to scan through 20 5065

00:13:12,730 --> 00:13:19,870
rose to find the person that I wanted

00:13:16,949 --> 00:13:24,309
that's obviously ridiculously

00:13:19,870 --> 00:13:25,360
inefficient and you know it was

00:13:24,309 --> 00:13:27,490
obviously it's something that you

00:13:25,360 --> 00:13:29,260
need to fix straight away so we're going

00:13:27,490 --> 00:13:31,029
to add a couple of indexes we've added

00:13:29,260 --> 00:13:33,550
an index on post code on the address

00:13:31,029 --> 00:13:36,070
table and then we've added an index on

00:13:33,550 --> 00:13:38,560
the address ID on the user table and

00:13:36,070 --> 00:13:41,170
share enough then it's going a look

00:13:38,560 --> 00:13:42,790
we've got lots of lots of primary keys i

00:13:41,170 --> 00:13:45,490
can use now i've got the primary all the

00:13:42,790 --> 00:13:46,750
postcode i've got the dress ID and you

00:13:45,490 --> 00:13:48,940
can see at the end there now it's only

00:13:46,750 --> 00:13:53,140
having to look up 15 rows to find the

00:13:48,940 --> 00:13:55,510
matches it needs so instantly vastly

00:13:53,140 --> 00:13:56,890
vastly more efficient just from running

00:13:55,510 --> 00:14:01,450
that one explained query going right

00:13:56,890 --> 00:14:02,500
stick to indexes on it happy days here's

00:14:01,450 --> 00:14:07,750
another slightly more complicated

00:14:02,500 --> 00:14:12,040
example so again we're using another

00:14:07,750 --> 00:14:13,839
query very very similar query and again

00:14:12,040 --> 00:14:15,220
we're explaining it and you notice here

00:14:13,839 --> 00:14:17,529
that in the extra column on the end here

00:14:15,220 --> 00:14:22,690
we've got using index condition using

00:14:17,529 --> 00:14:24,370
temporary using filesort and what that's

00:14:22,690 --> 00:14:27,250
effectively saying is it is using the

00:14:24,370 --> 00:14:29,350
index for the where clause but it can't

00:14:27,250 --> 00:14:30,970
return all the columns it needs from

00:14:29,350 --> 00:14:33,730
that index so in other words it's not a

00:14:30,970 --> 00:14:37,300
covering index it's using a temporary

00:14:33,730 --> 00:14:38,980
table and it's can't sort on an index so

00:14:37,300 --> 00:14:42,550
it's happening to use a file-based sort

00:14:38,980 --> 00:14:44,230
as well so again we've actually then

00:14:42,550 --> 00:14:46,870
created this covering indexable we're

00:14:44,230 --> 00:14:49,000
talking about so it created an index on

00:14:46,870 --> 00:14:50,680
address ID name and email and you see

00:14:49,000 --> 00:14:52,720
now that on this setting right here it's

00:14:50,680 --> 00:14:54,779
now saying using index so that's telling

00:14:52,720 --> 00:14:58,149
us that it's using a covering index

00:14:54,779 --> 00:15:00,040
which again as we've said before reduces

00:14:58,149 --> 00:15:01,720
the amount of disk reads you have to do

00:15:00,040 --> 00:15:03,880
certainly if it can store that index in

00:15:01,720 --> 00:15:07,480
memory it can pull those columns

00:15:03,880 --> 00:15:09,370
straight from memory so next one to do

00:15:07,480 --> 00:15:11,320
is actually separating data and logic so

00:15:09,370 --> 00:15:15,070
this is kind of my sequel and also PHP

00:15:11,320 --> 00:15:16,660
at the same time we've of yeah we've all

00:15:15,070 --> 00:15:18,760
seen cases and we've all probably built

00:15:16,660 --> 00:15:20,170
queries where all the filtering is put

00:15:18,760 --> 00:15:22,079
into my sequel I mean that's the

00:15:20,170 --> 00:15:24,940
database engine why wouldn't you do that

00:15:22,079 --> 00:15:26,680
however there are plenty of cases we're

00:15:24,940 --> 00:15:29,860
actually doing the filtering in PHP

00:15:26,680 --> 00:15:32,260
would be more efficient so allow the

00:15:29,860 --> 00:15:34,240
most equal to do some basic filtering to

00:15:32,260 --> 00:15:36,579
reduce the reduction salt set but then

00:15:34,240 --> 00:15:39,100
use PHP to filter out the edge cases

00:15:36,579 --> 00:15:39,970
that you don't need it also

00:15:39,100 --> 00:15:41,410
means that you're releasing the my

00:15:39,970 --> 00:15:43,240
sequel connection now much earlier

00:15:41,410 --> 00:15:45,340
because it's got less work to do so

00:15:43,240 --> 00:15:47,290
another query another thread that's

00:15:45,340 --> 00:15:49,230
waiting for my signal connection can

00:15:47,290 --> 00:15:53,500
pick up a connection that much quicker

00:15:49,230 --> 00:15:56,020
who recognizes this query yeah a few of

00:15:53,500 --> 00:15:58,660
you what this query is it's the standard

00:15:56,020 --> 00:16:01,060
way for calculating which points sit

00:15:58,660 --> 00:16:03,040
within a fixed distance fixed radius i

00:16:01,060 --> 00:16:06,190
should say from a certain point it's a

00:16:03,040 --> 00:16:07,510
great circle formula it's often news if

00:16:06,190 --> 00:16:09,160
you've got store locators and you want

00:16:07,510 --> 00:16:13,950
you know oh well in this instance all

00:16:09,160 --> 00:16:17,410
hotels within 25 miles of a given query

00:16:13,950 --> 00:16:19,570
we can do it my sequel that is the query

00:16:17,410 --> 00:16:24,430
in my sequel and as i said it return the

00:16:19,570 --> 00:16:27,130
hotels and that's fine however when we

00:16:24,430 --> 00:16:29,800
run that on a again a test table i

00:16:27,130 --> 00:16:32,890
generated that had 70,000 records i

00:16:29,800 --> 00:16:34,300
think it's taking naught point for I'd

00:16:32,890 --> 00:16:37,420
not put not four seconds fairly

00:16:34,300 --> 00:16:40,180
consistently and it's returning 1164

00:16:37,420 --> 00:16:42,070
rose so is there a way that we can

00:16:40,180 --> 00:16:46,510
improve that by moving the filtering

00:16:42,070 --> 00:16:47,680
into PHP so in this instance what we're

00:16:46,510 --> 00:16:49,270
doing getting as an awful lot of code

00:16:47,680 --> 00:16:51,820
there but what we're effectively doing

00:16:49,270 --> 00:16:52,990
is returning a bounding box so if you

00:16:51,820 --> 00:16:54,970
imagine you've got a square that the

00:16:52,990 --> 00:16:56,740
circle fits within to kind of filter

00:16:54,970 --> 00:16:58,390
down the results but in a really simple

00:16:56,740 --> 00:16:59,800
way so will it you just saying we're lat

00:16:58,390 --> 00:17:02,050
is between this and this and we're long

00:16:59,800 --> 00:17:04,540
is between this and this and then we're

00:17:02,050 --> 00:17:05,830
passing that result set down to PHP to

00:17:04,540 --> 00:17:07,150
pare down the ones that are in the

00:17:05,830 --> 00:17:10,390
corners that actually aren't in the

00:17:07,150 --> 00:17:12,190
circle that we need I did borrow the

00:17:10,390 --> 00:17:15,130
distance a b function because it was

00:17:12,190 --> 00:17:16,660
quicker than writing one arm but you

00:17:15,130 --> 00:17:18,010
know it's effectively doing exactly what

00:17:16,660 --> 00:17:19,870
we were doing in my sequel the

00:17:18,010 --> 00:17:22,000
calculation the formula is exactly the

00:17:19,870 --> 00:17:23,410
same we've not changed the logic the

00:17:22,000 --> 00:17:26,170
results you get back will be exactly the

00:17:23,410 --> 00:17:29,950
same we've just passed the actual job of

00:17:26,170 --> 00:17:33,250
doing that filtering into the PHP and

00:17:29,950 --> 00:17:36,340
look at the difference you know this is

00:17:33,250 --> 00:17:38,770
practically twice as fast you know

00:17:36,340 --> 00:17:41,970
you've gone from you or not but not for

00:17:38,770 --> 00:17:43,990
two no point not one to not point not to

00:17:41,970 --> 00:17:45,610
that's obviously you know if you've got

00:17:43,990 --> 00:17:48,400
store locator that again is being used

00:17:45,610 --> 00:17:49,840
by 50,000 users that difference is going

00:17:48,400 --> 00:17:51,130
to be massive just from actually

00:17:49,840 --> 00:17:53,940
probably writing it in the language

00:17:51,130 --> 00:17:53,940
you're more comfortable with

00:17:53,990 --> 00:17:58,020
so if you've got a lot of data it's

00:17:56,700 --> 00:17:58,950
being used you know that's definitely

00:17:58,020 --> 00:18:02,220
saying that you guys should be looking

00:17:58,950 --> 00:18:04,590
at that's just one example of splitting

00:18:02,220 --> 00:18:05,820
the splitting the filtering logic it can

00:18:04,590 --> 00:18:08,970
also be useful for pagination

00:18:05,820 --> 00:18:09,960
particularly if you're using in a DB I'm

00:18:08,970 --> 00:18:11,190
going to come on to kind of the

00:18:09,960 --> 00:18:14,250
different storage engines a little bit

00:18:11,190 --> 00:18:15,870
later anyway but in a nerdy be the

00:18:14,250 --> 00:18:17,419
counting of the number of rows in the

00:18:15,870 --> 00:18:20,490
table is actually quite expensive

00:18:17,419 --> 00:18:23,280
because unlike my I Sam which keeps a

00:18:20,490 --> 00:18:25,410
metadata record of how many are in DB

00:18:23,280 --> 00:18:26,940
comments all that sort of stuff that

00:18:25,410 --> 00:18:29,429
doesn't exist in in oh it has to go and

00:18:26,940 --> 00:18:32,400
physically get the number of rows so

00:18:29,429 --> 00:18:33,570
comparatively is quite expensive so it

00:18:32,400 --> 00:18:35,520
may well be certain if you've got an

00:18:33,570 --> 00:18:37,559
awful lot of data that actually

00:18:35,520 --> 00:18:40,200
returning the data to PHP and then using

00:18:37,559 --> 00:18:43,110
a red chunk or whatever else to do the

00:18:40,200 --> 00:18:45,750
pagination on your application side is

00:18:43,110 --> 00:18:47,610
quicker bench market some instances it

00:18:45,750 --> 00:18:49,850
won't be quicker don't bother doing it

00:18:47,610 --> 00:18:53,940
some instances it will be quicker as

00:18:49,850 --> 00:18:56,010
yeah fully yo just benchmark test make

00:18:53,940 --> 00:18:58,380
changes test again make more changes

00:18:56,010 --> 00:19:03,990
test again I really can't specify that

00:18:58,380 --> 00:19:07,679
enough query caching is something else

00:19:03,990 --> 00:19:10,950
that we can do you guys have probably

00:19:07,679 --> 00:19:12,750
all seen graphs like this before this is

00:19:10,950 --> 00:19:14,970
a tour communion it's not just for

00:19:12,750 --> 00:19:20,720
munching my secret monitors you know

00:19:14,970 --> 00:19:22,710
disk space cpu load hard disk throughput

00:19:20,720 --> 00:19:27,210
really worth using but that's kind of

00:19:22,710 --> 00:19:29,010
irrelevant query cache won't improve

00:19:27,210 --> 00:19:30,840
performance on an individual crew that's

00:19:29,010 --> 00:19:32,010
all it does it won't instantly speed up

00:19:30,840 --> 00:19:34,140
your query the first time you run it

00:19:32,010 --> 00:19:38,490
that's not clear cache does what query

00:19:34,140 --> 00:19:40,559
caching is is it's a cache that when you

00:19:38,490 --> 00:19:42,150
write it when you run a select query and

00:19:40,559 --> 00:19:44,610
it returns that result set it then

00:19:42,150 --> 00:19:47,760
stores the result of the select in

00:19:44,610 --> 00:19:49,919
memory so that the next time that same

00:19:47,760 --> 00:19:51,510
query is run it doesn't have to go and

00:19:49,919 --> 00:19:53,280
fetch it from the fart the files again

00:19:51,510 --> 00:19:55,380
it leisure goes oh I've already got a

00:19:53,280 --> 00:19:58,230
cache of this result there you go Merry

00:19:55,380 --> 00:20:00,179
Christmas it's most effective when

00:19:58,230 --> 00:20:02,340
you've got a high contention reach high

00:20:00,179 --> 00:20:05,040
contention read heavy site so like a

00:20:02,340 --> 00:20:06,090
blog SMS that sort of thing but it is

00:20:05,040 --> 00:20:08,250
still beneficial on science

00:20:06,090 --> 00:20:10,409
a lot of writing the only downside is

00:20:08,250 --> 00:20:12,630
that each time you do a write that

00:20:10,409 --> 00:20:14,100
affects the result of that crude cash it

00:20:12,630 --> 00:20:15,840
then has to invalidate that cash there

00:20:14,100 --> 00:20:17,460
the next time the crew comes in it has

00:20:15,840 --> 00:20:20,190
to go and fetch you know do the whole

00:20:17,460 --> 00:20:22,710
query again but you know even if you've

00:20:20,190 --> 00:20:24,450
got you know a curry might run 20 times

00:20:22,710 --> 00:20:26,789
before it's invalidated that's still

00:20:24,450 --> 00:20:29,909
going to be more beneficial than having

00:20:26,789 --> 00:20:35,549
to go and run the query 20 times from

00:20:29,909 --> 00:20:37,770
the file system so to configure the

00:20:35,549 --> 00:20:39,779
query cache it's really simple in my

00:20:37,770 --> 00:20:41,880
comp for whatever you're in my circle

00:20:39,779 --> 00:20:43,409
conference file is you turn query

00:20:41,880 --> 00:20:46,039
cashing on with the query cache time

00:20:43,409 --> 00:20:48,480
pickles one you set the signs to

00:20:46,039 --> 00:20:51,809
whatever memory you've got available so

00:20:48,480 --> 00:20:54,870
if you can give it you know if you can

00:20:51,809 --> 00:20:56,580
give it 20 20 meg great if you've got a

00:20:54,870 --> 00:20:58,230
gig to spare and you've got a lot of

00:20:56,580 --> 00:21:00,299
queries going through give it a gig you

00:20:58,230 --> 00:21:02,460
give it whatever memory you can do you

00:21:00,299 --> 00:21:04,409
can always monitor its usage and pair

00:21:02,460 --> 00:21:05,940
that back if you find it's never using

00:21:04,409 --> 00:21:07,500
the memory or if you find actually is

00:21:05,940 --> 00:21:09,630
having to prune a lot of queries in

00:21:07,500 --> 00:21:12,419
other words it can't fit all the prison

00:21:09,630 --> 00:21:15,090
in the cache then you can increase the

00:21:12,419 --> 00:21:17,370
memory size as well so set so I've set

00:21:15,090 --> 00:21:18,779
those configs restarting my sequel and

00:21:17,370 --> 00:21:20,820
you can see that it's saying right my

00:21:18,779 --> 00:21:23,520
crew cash limit over crew cache size

00:21:20,820 --> 00:21:26,669
sorry is the size of specified that is

00:21:23,520 --> 00:21:28,140
turned on that's all working and then

00:21:26,669 --> 00:21:30,330
like what you can then come and look at

00:21:28,140 --> 00:21:33,120
the status so you can see how much

00:21:30,330 --> 00:21:35,279
memory is got how many hits in other

00:21:33,120 --> 00:21:36,690
words how many times have I asked my

00:21:35,279 --> 00:21:38,070
sequel to give me a query result where

00:21:36,690 --> 00:21:40,230
it has been out to pull it from the cash

00:21:38,070 --> 00:21:42,390
how many crews have been inserted into

00:21:40,230 --> 00:21:43,649
the cache how many times we've had to

00:21:42,390 --> 00:21:45,809
prune it because we've run out of memory

00:21:43,649 --> 00:21:47,460
in other words if I've tried to insert a

00:21:45,809 --> 00:21:49,200
result set into the cache and there

00:21:47,460 --> 00:21:51,000
isn't enough disk it will then but isn't

00:21:49,200 --> 00:21:52,799
enough memory it will then bin the

00:21:51,000 --> 00:21:54,059
oldest entry in the cache if it's doing

00:21:52,799 --> 00:21:56,669
that a lot then you know you're probably

00:21:54,059 --> 00:21:58,799
to give it more memory how many queries

00:21:56,669 --> 00:22:01,440
can't be cashed in this case one because

00:21:58,799 --> 00:22:03,870
you can't catch a show variable query

00:22:01,440 --> 00:22:05,820
how many crews are in the cash none

00:22:03,870 --> 00:22:09,330
because I'm going just set it up and the

00:22:05,820 --> 00:22:11,700
blocks which doesn't really matter so

00:22:09,330 --> 00:22:14,490
here's an example this is that great

00:22:11,700 --> 00:22:16,559
circle query again and you see the first

00:22:14,490 --> 00:22:18,059
time again it returned 1000 sees full

00:22:16,559 --> 00:22:20,000
results and it took nor point not five

00:22:18,059 --> 00:22:21,920
seconds once you've run that query

00:22:20,000 --> 00:22:24,500
that is then cash that is stored in the

00:22:21,920 --> 00:22:26,930
query cache if you ran the show status

00:22:24,500 --> 00:22:28,820
again you would see that there is one

00:22:26,930 --> 00:22:31,520
query in the cache so the second time we

00:22:28,820 --> 00:22:32,870
run it look North seconds because it's

00:22:31,520 --> 00:22:35,060
already got the result it's in memory

00:22:32,870 --> 00:22:38,060
it's just gone they go have a nice day

00:22:35,060 --> 00:22:39,620
I'm gonna go to sleep and look if you

00:22:38,060 --> 00:22:44,000
look at the query cache again you see

00:22:39,620 --> 00:22:45,500
that we've had one hit yay and it's

00:22:44,000 --> 00:22:48,380
returned it so it's found the query

00:22:45,500 --> 00:22:53,540
cache and its return that so it's not

00:22:48,380 --> 00:22:56,120
taken up any time at all I said I'll

00:22:53,540 --> 00:22:58,100
come back storage engines so choosing

00:22:56,120 --> 00:22:59,300
the right storage engine as I was

00:22:58,100 --> 00:23:02,240
getting a bit desperate for imagery at

00:22:59,300 --> 00:23:07,610
this point you might be out to guess but

00:23:02,240 --> 00:23:09,440
why not so nodb this is my I Sam there

00:23:07,610 --> 00:23:14,750
are other storage engines available as

00:23:09,440 --> 00:23:16,340
the BBC would say um but in ninety

00:23:14,750 --> 00:23:19,940
percent of cases you're probably using

00:23:16,340 --> 00:23:21,740
one of the two so I'm going to stick to

00:23:19,940 --> 00:23:23,290
those obviously if you're using percona

00:23:21,740 --> 00:23:25,670
then the storage engines are different

00:23:23,290 --> 00:23:29,450
but that's outside the scope of this

00:23:25,670 --> 00:23:31,340
particular talk so as another point to

00:23:29,450 --> 00:23:36,290
note I would generally advise using in

00:23:31,340 --> 00:23:40,190
ODB in most cases if you're unsure which

00:23:36,290 --> 00:23:41,870
one you should use then using a DB but

00:23:40,190 --> 00:23:45,170
there are times where my OH Sam is the

00:23:41,870 --> 00:23:47,240
right choice as a general rule my Sam is

00:23:45,170 --> 00:23:50,210
faster for doing read operations so if

00:23:47,240 --> 00:23:52,190
you've got sa app that's very very

00:23:50,210 --> 00:23:53,810
rarely written to but you're reading

00:23:52,190 --> 00:23:57,190
hundreds of thousands of times then

00:23:53,810 --> 00:24:00,410
that's probably the right choice and

00:23:57,190 --> 00:24:02,780
then likewise nodb is better for right

00:24:00,410 --> 00:24:04,220
to have your applications however it's

00:24:02,780 --> 00:24:05,600
not only about performance wing to my

00:24:04,220 --> 00:24:07,940
storage engines if you're looking for

00:24:05,600 --> 00:24:09,860
acid or near acid compliance it's not

00:24:07,940 --> 00:24:12,320
quite a compliant if you're looking for

00:24:09,860 --> 00:24:14,660
new house of compliance or you're

00:24:12,320 --> 00:24:16,280
looking for foreign key constraints then

00:24:14,660 --> 00:24:19,790
you have to use an ODB you don't have a

00:24:16,280 --> 00:24:21,410
choice likewise in fact if you've got a

00:24:19,790 --> 00:24:23,570
slightly older version of my city cool

00:24:21,410 --> 00:24:25,490
so anything less than 5.6 and you need

00:24:23,570 --> 00:24:27,200
to have a full text index then you have

00:24:25,490 --> 00:24:30,050
to use my OH Sam because conversely

00:24:27,200 --> 00:24:31,970
inner DB didn't support that again your

00:24:30,050 --> 00:24:32,890
best bet is to benchmark try them both

00:24:31,970 --> 00:24:35,110
out

00:24:32,890 --> 00:24:37,150
and have a look at that so it's exactly

00:24:35,110 --> 00:24:39,610
what I did it's the same user table as

00:24:37,150 --> 00:24:41,020
before again very similar very similar

00:24:39,610 --> 00:24:43,150
query just looking up an email address

00:24:41,020 --> 00:24:46,480
and you can see when I did it using the

00:24:43,150 --> 00:24:49,450
nodb storage engine is taking nor point

00:24:46,480 --> 00:24:51,040
to no point 59.3 when we switched over

00:24:49,450 --> 00:24:52,840
to using the my I some storage engine

00:24:51,040 --> 00:24:54,940
not point one not one to not point one

00:24:52,840 --> 00:24:57,390
so again it's not a massive difference

00:24:54,940 --> 00:25:01,360
but it was only a hundred queries on a

00:24:57,390 --> 00:25:02,920
25,000 Road table but there was enough

00:25:01,360 --> 00:25:04,690
of a difference even at that level that

00:25:02,920 --> 00:25:06,790
if you have got an incredibly right

00:25:04,690 --> 00:25:11,910
heavy application you probably should

00:25:06,790 --> 00:25:14,140
take a look at it use the slow query log

00:25:11,910 --> 00:25:15,820
again still getting desperate for

00:25:14,140 --> 00:25:16,960
imagery if anyone wants to suggest any

00:25:15,820 --> 00:25:18,550
better injury for the next I'm I give

00:25:16,960 --> 00:25:22,750
this talk then you know do hit me up on

00:25:18,550 --> 00:25:25,060
Twitter it's at or toys or a turtle

00:25:22,750 --> 00:25:27,280
matinee one of the team slow curry log

00:25:25,060 --> 00:25:29,470
in most applications you will find the

00:25:27,280 --> 00:25:31,180
same pattern occurs most of you queries

00:25:29,470 --> 00:25:33,550
are absolutely fine they run perfectly

00:25:31,180 --> 00:25:37,840
well happy days but you might have one

00:25:33,550 --> 00:25:38,950
or 2 that perform like a dog and the

00:25:37,840 --> 00:25:40,480
problem is with that you've got one or

00:25:38,950 --> 00:25:42,310
two crews it a slow certainly if their

00:25:40,480 --> 00:25:45,100
crews that are used often it then adds

00:25:42,310 --> 00:25:46,600
extra load to the to the server it has

00:25:45,100 --> 00:25:48,760
an impact on everything else those crews

00:25:46,600 --> 00:25:50,890
are slow people start moaning Oh what

00:25:48,760 --> 00:25:53,620
application so slow or do you need a big

00:25:50,890 --> 00:25:56,560
server all that stuff it's not much fun

00:25:53,620 --> 00:25:58,960
for anyone by logging the slow queries

00:25:56,560 --> 00:26:00,970
we can identify the crews that are slow

00:25:58,960 --> 00:26:02,830
and then we can work on ways to improve

00:26:00,970 --> 00:26:05,140
the performance it basically gives us a

00:26:02,830 --> 00:26:07,960
big target of these are things you need

00:26:05,140 --> 00:26:10,090
to be hitting the definition of a slow

00:26:07,960 --> 00:26:12,940
query does depend on the application and

00:26:10,090 --> 00:26:14,290
the context but you know most people

00:26:12,940 --> 00:26:19,000
would agree that query that takes three

00:26:14,290 --> 00:26:21,940
quarters of a second is slow the problem

00:26:19,000 --> 00:26:24,880
with this was that until not that long

00:26:21,940 --> 00:26:27,670
ago my sequel always only allowed second

00:26:24,880 --> 00:26:29,500
resolution of slow queries so when you

00:26:27,670 --> 00:26:33,130
configure your so query log you either

00:26:29,500 --> 00:26:35,860
had to say mar 0 is my slow crew time in

00:26:33,130 --> 00:26:37,900
which case it logged everything or one

00:26:35,860 --> 00:26:39,280
second is my slow query but then it yeah

00:26:37,900 --> 00:26:44,560
not point nine second grade which is

00:26:39,280 --> 00:26:46,570
still slow wouldn't get logged pakona

00:26:44,560 --> 00:26:46,870
fixed it a long time before my sequel

00:26:46,570 --> 00:26:48,880
did

00:26:46,870 --> 00:26:51,430
why it took set off my secret to fix I

00:26:48,880 --> 00:26:52,809
can only say because of Oracle but they

00:26:51,430 --> 00:26:56,980
did finally fix it in five point one

00:26:52,809 --> 00:26:58,960
point two one so here's an example of

00:26:56,980 --> 00:27:01,780
using so career log again back

00:26:58,960 --> 00:27:04,480
interesting my comp slow korea logged

00:27:01,780 --> 00:27:07,450
one turns it on wage once right the slow

00:27:04,480 --> 00:27:09,850
queries to VAR log slow query log sake

00:27:07,450 --> 00:27:12,940
of example and what the long what's a

00:27:09,850 --> 00:27:15,940
slow query consists of so I've chosen or

00:27:12,940 --> 00:27:17,559
point 1 seconds so basically well as

00:27:15,940 --> 00:27:20,440
saying is anything any crew that takes

00:27:17,559 --> 00:27:23,890
longer than nor point 1 seconds is going

00:27:20,440 --> 00:27:25,780
to be put into the lock so again we'll

00:27:23,890 --> 00:27:29,200
come back to the great circle theory

00:27:25,780 --> 00:27:31,420
because it is quite slow this time I

00:27:29,200 --> 00:27:33,610
gave it some weird join basically i made

00:27:31,420 --> 00:27:36,370
this query just horrible and i put a

00:27:33,610 --> 00:27:38,950
stupid join in that makes no sense but

00:27:36,370 --> 00:27:42,580
it made it run terribly look look 1.9

00:27:38,950 --> 00:27:45,040
seconds if you then have a look at the

00:27:42,580 --> 00:27:48,490
slow query log you can see here that

00:27:45,040 --> 00:27:50,679
it's saying second one down sorry that

00:27:48,490 --> 00:27:52,600
here's the query this is how many rows

00:27:50,679 --> 00:27:55,780
were sent it had to look at four hundred

00:27:52,600 --> 00:27:57,940
ninety five thousand rows she's pretty

00:27:55,780 --> 00:28:00,700
impressive and how long the crew time

00:27:57,940 --> 00:28:02,890
was and the lock time and everything

00:28:00,700 --> 00:28:05,440
else so instantly that's telling you

00:28:02,890 --> 00:28:10,840
look this this looks query is one that

00:28:05,440 --> 00:28:12,490
you need to look at because Egypt what

00:28:10,840 --> 00:28:14,800
as i said the definition of the slow

00:28:12,490 --> 00:28:17,110
curry is dependent on context if you've

00:28:14,800 --> 00:28:19,540
got a reporting function that takes 20

00:28:17,110 --> 00:28:21,910
seconds to run but it's only been one

00:28:19,540 --> 00:28:25,120
run once a day in the background at ten

00:28:21,910 --> 00:28:27,309
at night does that really matter no on

00:28:25,120 --> 00:28:29,230
the other hand if you've got to accrue

00:28:27,309 --> 00:28:31,059
that's taking half a second or maybe

00:28:29,230 --> 00:28:33,280
even less maybe quarter of a second or a

00:28:31,059 --> 00:28:35,309
tenth of a second but that query is

00:28:33,280 --> 00:28:38,020
being run every single second of the day

00:28:35,309 --> 00:28:41,320
then that probably is something that you

00:28:38,020 --> 00:28:44,530
need to take a look at so review your so

00:28:41,320 --> 00:28:46,450
career logs regularly use a tool that

00:28:44,530 --> 00:28:47,890
allows you to break it down so there is

00:28:46,450 --> 00:28:50,440
one that comes with my sequel which is

00:28:47,890 --> 00:28:53,350
my sequel dumps like really imaginative

00:28:50,440 --> 00:28:56,020
lee named and what it does is it gives

00:28:53,350 --> 00:28:58,240
you a breakdown of the queries that are

00:28:56,020 --> 00:28:59,500
showing up in slow query love most so if

00:28:58,240 --> 00:29:00,760
you've got one that's showing up a

00:28:59,500 --> 00:29:02,710
hundred times

00:29:00,760 --> 00:29:04,840
when you put the log through my sequel

00:29:02,710 --> 00:29:06,100
dumps low it will be that crew that

00:29:04,840 --> 00:29:07,690
comes out at the top so you know that's

00:29:06,100 --> 00:29:08,920
the first we need to pay attention to if

00:29:07,690 --> 00:29:11,080
you've got one that is only been run

00:29:08,920 --> 00:29:13,260
once you know you'll probably get to at

00:29:11,080 --> 00:29:15,460
some point but it doesn't really matter

00:29:13,260 --> 00:29:17,770
there are other tools as well I

00:29:15,460 --> 00:29:20,170
mentioned pakona a few times because I

00:29:17,770 --> 00:29:22,270
am a fan of park owner and the pakona

00:29:20,170 --> 00:29:24,850
toolkit does have a very good log parser

00:29:22,270 --> 00:29:27,850
as well but for most instances to be

00:29:24,850 --> 00:29:30,370
honest the mattock will dump slow works

00:29:27,850 --> 00:29:32,220
perfectly well I've kind of made a joke

00:29:30,370 --> 00:29:35,050
about how I was struggling for imagery

00:29:32,220 --> 00:29:36,700
no no more so than on this next slide so

00:29:35,050 --> 00:29:38,560
there is an advertising opportunity here

00:29:36,700 --> 00:29:40,450
if anyone wants to advertise on my

00:29:38,560 --> 00:29:45,640
presentation for a very reasonable price

00:29:40,450 --> 00:29:50,620
then let me know understanding data

00:29:45,640 --> 00:29:52,000
types so there's lots of officer data

00:29:50,620 --> 00:29:54,580
types in my sleep corner all these four

00:29:52,000 --> 00:29:58,660
different things you've got int small in

00:29:54,580 --> 00:30:00,400
meeting big in tiny in yeah all sorts of

00:29:58,660 --> 00:30:02,230
data types and a lot of times you can't

00:30:00,400 --> 00:30:06,400
look at them go well kind of what's the

00:30:02,230 --> 00:30:10,060
difference but they are all stored and

00:30:06,400 --> 00:30:11,890
handled very very differently so as a

00:30:10,060 --> 00:30:14,110
general rules it says their numeric data

00:30:11,890 --> 00:30:16,180
types tend to be quicker than string

00:30:14,110 --> 00:30:18,040
text based data types kind of make sense

00:30:16,180 --> 00:30:20,230
you know computers use numbers

00:30:18,040 --> 00:30:22,210
internally converting stuff from a

00:30:20,230 --> 00:30:23,590
string to a number two then do an

00:30:22,210 --> 00:30:25,870
operation on it then convert it back to

00:30:23,590 --> 00:30:31,510
string yeah it's going to be that much

00:30:25,870 --> 00:30:33,280
more work the particular problem tends

00:30:31,510 --> 00:30:35,230
to be the blob and the text columns the

00:30:33,280 --> 00:30:37,210
reason for that is the way my sequel

00:30:35,230 --> 00:30:38,890
stores those and is it actually stores

00:30:37,210 --> 00:30:42,880
them in separate files so you've got

00:30:38,890 --> 00:30:44,710
your database with or you or your kind

00:30:42,880 --> 00:30:46,480
of main data at your database on disk

00:30:44,710 --> 00:30:48,910
with all you main rose in it and then

00:30:46,480 --> 00:30:51,490
there's a second file that it has all

00:30:48,910 --> 00:30:52,660
the blobs in the text the long text and

00:30:51,490 --> 00:30:53,980
that sort of thing it and then it's if

00:30:52,660 --> 00:30:55,840
you'd an accrued that's using both it

00:30:53,980 --> 00:30:57,280
has to read all the DB rose that has go

00:30:55,840 --> 00:30:59,230
and fetch that and then joining it all

00:30:57,280 --> 00:31:00,790
together and then return the row and you

00:30:59,230 --> 00:31:02,620
know it's that's why it becomes very

00:31:00,790 --> 00:31:04,120
inefficient it also means it has to use

00:31:02,620 --> 00:31:06,940
a temporary table because before it can

00:31:04,120 --> 00:31:08,770
do any sorting where's whatever else it

00:31:06,940 --> 00:31:13,060
has to put it all together into a table

00:31:08,770 --> 00:31:14,320
that it can work on and so it's using a

00:31:13,060 --> 00:31:16,090
lot of disk through

00:31:14,320 --> 00:31:19,149
put is using a lot more processor than

00:31:16,090 --> 00:31:21,700
it needs to and that as such it is

00:31:19,149 --> 00:31:24,159
inefficient there is Pullman's penalty

00:31:21,700 --> 00:31:27,309
there so much to do about it if you

00:31:24,159 --> 00:31:29,559
don't need to use a text then don't if

00:31:27,309 --> 00:31:32,950
you can use you know if you're using a

00:31:29,559 --> 00:31:36,279
text field for an email address then

00:31:32,950 --> 00:31:37,870
don't user to 55 HR or whatever else

00:31:36,279 --> 00:31:40,149
sometimes you have to you know if you've

00:31:37,870 --> 00:31:42,130
got a bio you got a file that's stored

00:31:40,149 --> 00:31:44,590
in the DB you haven't got a choice you

00:31:42,130 --> 00:31:46,720
have to use those texts but avoid it

00:31:44,590 --> 00:31:47,830
when you can if you do have to use them

00:31:46,720 --> 00:31:49,809
the best thing I can say is actually

00:31:47,830 --> 00:31:51,580
store them in a different DB table so if

00:31:49,809 --> 00:31:53,919
you imagine if you have like users and

00:31:51,580 --> 00:31:55,480
then a user meta table you're kind of

00:31:53,919 --> 00:31:57,659
core data that you're accessing

00:31:55,480 --> 00:32:00,909
frequently you use the name your

00:31:57,659 --> 00:32:02,919
password name email address those sorts

00:32:00,909 --> 00:32:04,419
things store in your user table and then

00:32:02,919 --> 00:32:05,529
have a separate user underscore meta

00:32:04,419 --> 00:32:08,679
table or whatever you want to call it

00:32:05,529 --> 00:32:11,440
that references you know user ID bio

00:32:08,679 --> 00:32:13,929
profile picture whatever else store that

00:32:11,440 --> 00:32:16,690
away and then only query that when you

00:32:13,929 --> 00:32:18,009
absolutely have too few people nodding

00:32:16,690 --> 00:32:19,929
here so I think that's probably been

00:32:18,009 --> 00:32:25,450
discussed in various offices around the

00:32:19,929 --> 00:32:27,730
UK already but good again you use the

00:32:25,450 --> 00:32:33,100
right data type for the size so many

00:32:27,730 --> 00:32:35,620
times have I seen and done built tables

00:32:33,100 --> 00:32:38,710
with an index an idea primary key and

00:32:35,620 --> 00:32:41,769
I've used the big in data type I don't

00:32:38,710 --> 00:32:45,779
do it now because are you really going

00:32:41,769 --> 00:32:48,610
to have a database table with 4 billion

00:32:45,779 --> 00:32:53,470
294 million nine hundred and sixty seven

00:32:48,610 --> 00:32:57,549
thousand 295 records I would put good

00:32:53,470 --> 00:32:59,740
money on know if you do then obviously

00:32:57,549 --> 00:33:01,509
needs a big in or an unsigned int Penn

00:32:59,740 --> 00:33:04,809
Yan kind of where how many records you

00:33:01,509 --> 00:33:08,230
have got but if you don't need that

00:33:04,809 --> 00:33:11,200
number of records then go and use int or

00:33:08,230 --> 00:33:13,450
if it's like a small lookup table and

00:33:11,200 --> 00:33:15,519
you're only going to have 50 use tinyint

00:33:13,450 --> 00:33:19,600
tynion allows you to go up to 127 if

00:33:15,519 --> 00:33:22,539
it's signed or 256 it's unsigned really

00:33:19,600 --> 00:33:23,679
should know that so if you know you've

00:33:22,539 --> 00:33:25,629
only got a few things you're going to

00:33:23,679 --> 00:33:28,269
ever look at it like a user a user type

00:33:25,629 --> 00:33:33,249
table so if you've got admin user get

00:33:28,269 --> 00:33:36,190
just don't give it a big int please so

00:33:33,249 --> 00:33:39,179
here's an example really ugly use a

00:33:36,190 --> 00:33:42,639
table so we've got a big in for ID but a

00:33:39,179 --> 00:33:47,440
text for bio we've got two begins for

00:33:42,639 --> 00:33:49,690
user level ID and address ID and I think

00:33:47,440 --> 00:33:51,849
I just lit you did a select star for

00:33:49,690 --> 00:33:55,599
this one run it through the test it's

00:33:51,849 --> 00:33:59,349
taking your point 12 seconds no point 26

00:33:55,599 --> 00:34:01,329
nor point 14 we then change it so we're

00:33:59,349 --> 00:34:02,440
using an int for the ID again that

00:34:01,329 --> 00:34:04,809
probably could be small i probably could

00:34:02,440 --> 00:34:07,539
get away with a midden or a smallint but

00:34:04,809 --> 00:34:10,029
we've letters in for this example drop

00:34:07,539 --> 00:34:13,629
the bio table of the bio field because

00:34:10,029 --> 00:34:17,319
we don't need it and made the other IDs

00:34:13,629 --> 00:34:20,649
smalling's run it again and even on yo

00:34:17,319 --> 00:34:22,990
ass fairly small data set it's come down

00:34:20,649 --> 00:34:26,109
to not point 10 nor point one tune up on

00:34:22,990 --> 00:34:27,339
11 so again a lot more consistent you

00:34:26,109 --> 00:34:29,649
know the difference between the minimum

00:34:27,339 --> 00:34:31,720
and the maximum is naught point naught 2

00:34:29,649 --> 00:34:34,480
compared to you know one tenth of a

00:34:31,720 --> 00:34:36,700
second which is a big difference and it

00:34:34,480 --> 00:34:38,770
has made it slightly quicker as well so

00:34:36,700 --> 00:34:41,500
again have a look through your DB scheme

00:34:38,770 --> 00:34:44,319
is you know if you've got 100 users in a

00:34:41,500 --> 00:34:47,129
DB it's not made much difference but if

00:34:44,319 --> 00:34:49,539
you've got 20,000 30,000 50,000 records

00:34:47,129 --> 00:34:52,409
it could actually have more difference

00:34:49,539 --> 00:34:54,849
than I think you know people appreciate

00:34:52,409 --> 00:34:56,740
so kind of coming towards the end of it

00:34:54,849 --> 00:34:58,990
as I mentioned at the beginning there

00:34:56,740 --> 00:35:00,400
isn't a one-size-fits-all you can't just

00:34:58,990 --> 00:35:02,049
go and put all of these on there and

00:35:00,400 --> 00:35:05,020
assume your performance is going to be

00:35:02,049 --> 00:35:06,160
awesome because it probably won't some

00:35:05,020 --> 00:35:09,579
of these approaches will work better

00:35:06,160 --> 00:35:11,589
than others in certain situations so as

00:35:09,579 --> 00:35:14,500
I've said it four or five times I can

00:35:11,589 --> 00:35:16,599
say again benchmark take measurements

00:35:14,500 --> 00:35:17,589
before you make any changes otherwise

00:35:16,599 --> 00:35:19,569
you don't know if your changes have made

00:35:17,589 --> 00:35:21,819
a difference or not make the changes on

00:35:19,569 --> 00:35:25,480
your test platform then benchmark again

00:35:21,819 --> 00:35:27,250
if it has improved happy days if it

00:35:25,480 --> 00:35:31,180
hasn't fine go back to try something

00:35:27,250 --> 00:35:33,190
else and consider scale yeah you might

00:35:31,180 --> 00:35:36,640
say that an improvement of a tenth of a

00:35:33,190 --> 00:35:38,410
second on query isn't an awful lot but

00:35:36,640 --> 00:35:41,580
if you're running that query every

00:35:38,410 --> 00:35:43,710
second then the over at course

00:35:41,580 --> 00:35:45,150
day it's the equivalent to actually two

00:35:43,710 --> 00:35:48,000
point four hours which I think we'd all

00:35:45,150 --> 00:35:50,460
agree is a pretty big saving so that's

00:35:48,000 --> 00:35:52,680
about it thanks for thanks for having me

00:35:50,460 --> 00:35:55,050
if you have any questions then we've got

00:35:52,680 --> 00:35:56,550
some time for that otherwise if you

00:35:55,050 --> 00:35:57,750
leave me some feedback this is the first

00:35:56,550 --> 00:35:59,700
talk I've done on this sort of scale

00:35:57,750 --> 00:36:01,770
I've done kind of user groups and local

00:35:59,700 --> 00:36:04,200
things before so really would appreciate

00:36:01,770 --> 00:36:06,980
the feedback the slides are available in

00:36:04,200 --> 00:36:10,130
the green QR code and we're recruiting

00:36:06,980 --> 00:36:10,130
thanks very much

00:36:19,420 --> 00:36:28,280
damn it yeah thank you very much for the

00:36:25,400 --> 00:36:31,460
talk at two questions actually first one

00:36:28,280 --> 00:36:33,230
is about indexes okay about rebuilding

00:36:31,460 --> 00:36:37,280
them is that something needs to be done

00:36:33,230 --> 00:36:41,780
how regular um is that the news to be

00:36:37,280 --> 00:36:43,670
done no honor on the whole the only

00:36:41,780 --> 00:36:46,040
reason you would need to rebuild indexes

00:36:43,670 --> 00:36:48,260
is if you're regularly deleting records

00:36:46,040 --> 00:36:49,730
or old or updating records which is

00:36:48,260 --> 00:36:51,920
effectively a deleting an insert if

00:36:49,730 --> 00:36:53,180
you're adding new records it doesn't

00:36:51,920 --> 00:36:54,890
make that much of a difference if you're

00:36:53,180 --> 00:36:57,020
deleting records or said you doing lots

00:36:54,890 --> 00:36:58,340
and lots of updates then yes you

00:36:57,020 --> 00:36:59,930
probably would do I wouldn't do its part

00:36:58,340 --> 00:37:01,670
of your daily process but maybe have a

00:36:59,930 --> 00:37:03,530
cron job that goes through and clean

00:37:01,670 --> 00:37:05,990
stuff up on a Sunday night when no one's

00:37:03,530 --> 00:37:07,400
access in the application again it's

00:37:05,990 --> 00:37:08,900
kind of testing what works in your

00:37:07,400 --> 00:37:11,240
environment yeah if you do it manually

00:37:08,900 --> 00:37:12,650
once and actually getting no improvement

00:37:11,240 --> 00:37:14,690
from it then you don't need to do it

00:37:12,650 --> 00:37:16,760
again if actually you go we've

00:37:14,690 --> 00:37:18,830
saved you know nor point three seconds

00:37:16,760 --> 00:37:21,110
on a query then its present that's worth

00:37:18,830 --> 00:37:23,450
doing more regular in future cool and

00:37:21,110 --> 00:37:25,700
yeah just quickly if say you had a CMS

00:37:23,450 --> 00:37:28,280
where people call center people could

00:37:25,700 --> 00:37:29,840
search for customer data and there was

00:37:28,280 --> 00:37:32,030
actually maybe ten columns they could

00:37:29,840 --> 00:37:33,880
search by yeah so the entire dress

00:37:32,030 --> 00:37:35,960
account number email address another

00:37:33,880 --> 00:37:39,280
obviously you wouldn't index every

00:37:35,960 --> 00:37:41,360
single Rovin say the address table and

00:37:39,280 --> 00:37:43,430
what kind of numbers can you get away

00:37:41,360 --> 00:37:45,290
with could you index like half a table

00:37:43,430 --> 00:37:47,570
or is that getting ridiculous already um

00:37:45,290 --> 00:37:49,070
it's really a question actually I'm

00:37:47,570 --> 00:37:56,000
gonna struggle to answer I think damn it

00:37:49,070 --> 00:37:57,950
um again I guess it's a case of you

00:37:56,000 --> 00:37:59,780
wouldn't necessarily as you said in dat

00:37:57,950 --> 00:38:01,070
having an index in every column Sony if

00:37:59,780 --> 00:38:02,360
there's lots and lots of Rights going in

00:38:01,070 --> 00:38:04,670
as well which they probably would be for

00:38:02,360 --> 00:38:09,260
that sort of situation is going to be

00:38:04,670 --> 00:38:11,620
horrible what you could potentially do

00:38:09,260 --> 00:38:19,790
as an alternative I'm trying the

00:38:11,620 --> 00:38:21,860
alternatives now anyone else is i would

00:38:19,790 --> 00:38:23,810
suggest analyzing it so what you know i

00:38:21,860 --> 00:38:24,800
know they can search in every column but

00:38:23,810 --> 00:38:26,570
which ones are the ones they do most

00:38:24,800 --> 00:38:28,430
often you know if we want at the dress

00:38:26,570 --> 00:38:29,360
column if actually most people know that

00:38:28,430 --> 00:38:30,950
custom number

00:38:29,360 --> 00:38:32,750
or they know their name and their only

00:38:30,950 --> 00:38:35,720
searching on the dress column once in

00:38:32,750 --> 00:38:37,640
every five thousand uses then you pretty

00:38:35,720 --> 00:38:39,560
safe with not indexing address column

00:38:37,640 --> 00:38:41,800
and that one time in five thousand they

00:38:39,560 --> 00:38:43,940
use it while it's going to be a bit slow

00:38:41,800 --> 00:38:45,380
you know if on the other hand like the

00:38:43,940 --> 00:38:47,000
customer number because most customers

00:38:45,380 --> 00:38:48,140
know that number again I don't know

00:38:47,000 --> 00:38:49,880
about your particular use case but if

00:38:48,140 --> 00:38:51,620
that's the case then you definitely want

00:38:49,880 --> 00:38:53,120
to be put in the index on there the

00:38:51,620 --> 00:38:55,220
other thing is if they often search by

00:38:53,120 --> 00:38:57,230
groups you can have a multi-column

00:38:55,220 --> 00:38:58,790
vindex so if a lot of people are using

00:38:57,230 --> 00:39:01,340
the customer number and the postcode

00:38:58,790 --> 00:39:03,590
then you can have an index that covers

00:39:01,340 --> 00:39:05,540
both of those the thing to be careful of

00:39:03,590 --> 00:39:07,970
with that is if you have a column that

00:39:05,540 --> 00:39:10,520
if you have an index that is customer

00:39:07,970 --> 00:39:11,840
number first and then postcode if you've

00:39:10,520 --> 00:39:13,940
got a query that's looking up on

00:39:11,840 --> 00:39:15,440
customer number it can use it if you've

00:39:13,940 --> 00:39:17,090
got a crew that's using both a custom

00:39:15,440 --> 00:39:18,830
number and the postcode it can use it

00:39:17,090 --> 00:39:20,840
but if it's only looking up on the

00:39:18,830 --> 00:39:23,770
postcode then it can't because it hasn't

00:39:20,840 --> 00:39:26,570
filtered by the customer number first

00:39:23,770 --> 00:39:28,430
also just to note your query should also

00:39:26,570 --> 00:39:31,010
match the order of your index as well if

00:39:28,430 --> 00:39:34,160
you're using jewel keys it will it would

00:39:31,010 --> 00:39:35,300
yup it will switch around but yeah it

00:39:34,160 --> 00:39:36,320
probably show you there are certainly

00:39:35,300 --> 00:39:46,580
older versions had trouble with it

00:39:36,320 --> 00:39:49,760
anyway I one trick we used to use with

00:39:46,580 --> 00:39:53,600
my exam tables is to make sure the rows

00:39:49,760 --> 00:39:57,170
were fixed with we subsequently moved to

00:39:53,600 --> 00:40:00,500
mostly in ODB so we don't need to use it

00:39:57,170 --> 00:40:04,220
as much but is that still effective and

00:40:00,500 --> 00:40:07,850
I notice you didn't mention that when

00:40:04,220 --> 00:40:10,790
you're talking about my I sense to be

00:40:07,850 --> 00:40:11,900
honest I mean I have done tests on it a

00:40:10,790 --> 00:40:13,490
long time ago the reason I don't mention

00:40:11,900 --> 00:40:16,520
it is because i don't use fix with

00:40:13,490 --> 00:40:18,590
columns as a rule because from tests

00:40:16,520 --> 00:40:20,120
that I've done previously the games were

00:40:18,590 --> 00:40:22,430
negligible certainly compared to some

00:40:20,120 --> 00:40:23,720
other things you can do instead I mean

00:40:22,430 --> 00:40:25,880
the only thing to say with all these

00:40:23,720 --> 00:40:27,860
things his bench market I said via when

00:40:25,880 --> 00:40:29,810
I've done benchmarks in the past i found

00:40:27,860 --> 00:40:33,110
the games you know to be negligible say

00:40:29,810 --> 00:40:35,930
it it wasn't worth it for you know for

00:40:33,110 --> 00:40:37,460
doing its sake but in again in

00:40:35,930 --> 00:40:39,110
particular use case if you try it you

00:40:37,460 --> 00:40:42,890
know build a test table with your data

00:40:39,110 --> 00:40:44,900
run the query a thousand times whatever

00:40:42,890 --> 00:40:47,569
make it a fix with column if it makes a

00:40:44,900 --> 00:40:49,579
substantial difference reboot the table

00:40:47,569 --> 00:40:51,200
which you've changed the data types

00:40:49,579 --> 00:40:52,339
obviously if it there makes us some time

00:40:51,200 --> 00:40:54,500
to a difference then you're probably on

00:40:52,339 --> 00:40:56,119
to a winner if as I would suspect in

00:40:54,500 --> 00:41:03,650
ninety nine percent cases it doesn't

00:40:56,119 --> 00:41:14,500
then you know no harm done so one next

00:41:03,650 --> 00:41:18,260
door hello hello oh jeez hi sorry and

00:41:14,500 --> 00:41:22,369
what would you suggest to improve our

00:41:18,260 --> 00:41:25,190
full text index rebuilding and in

00:41:22,369 --> 00:41:32,000
massive reinsert sand updating of full

00:41:25,190 --> 00:41:35,180
text indexes to be honest that's where I

00:41:32,000 --> 00:41:38,059
would turn to replication it's a bit of

00:41:35,180 --> 00:41:39,109
a cop-out answer but what I don't know

00:41:38,059 --> 00:41:40,220
because it was a little bit quiet in

00:41:39,109 --> 00:41:42,230
here but what would have saying is if

00:41:40,220 --> 00:41:45,230
you've got fooled exit full text indexes

00:41:42,230 --> 00:41:46,880
they can be quite pragmatic to rebuild

00:41:45,230 --> 00:41:49,430
for obvious reason certainly on really

00:41:46,880 --> 00:41:51,259
big tables that's where I would look at

00:41:49,430 --> 00:41:55,039
some point of replication where perhaps

00:41:51,259 --> 00:41:57,470
you've got a right table sorry I write

00:41:55,039 --> 00:41:59,539
DB and then a read DB the both

00:41:57,470 --> 00:42:01,309
configured differently so you can

00:41:59,539 --> 00:42:03,559
basically be doing the rear entry index

00:42:01,309 --> 00:42:05,660
or the rebuild of the index on one and

00:42:03,559 --> 00:42:08,690
crew the other and then once that's done

00:42:05,660 --> 00:42:10,309
you swap ownership on to the back to

00:42:08,690 --> 00:42:12,910
your primary database if you like and

00:42:10,309 --> 00:42:18,890
then you can rien decks the second one

00:42:12,910 --> 00:42:20,119
okay well as one more hand also

00:42:18,890 --> 00:42:23,390
expecting this happen for like 11

00:42:20,119 --> 00:42:25,609
question I could go and get drunk just

00:42:23,390 --> 00:42:27,680
curious stored procedures or anything

00:42:25,609 --> 00:42:30,109
like that performance gains with those

00:42:27,680 --> 00:42:32,599
yeah I mean still procedures it's one of

00:42:30,109 --> 00:42:34,880
the things that we don't use them half

00:42:32,599 --> 00:42:37,519
as much as we should do in PHP I don't

00:42:34,880 --> 00:42:39,829
know why yeah you go and look at you

00:42:37,519 --> 00:42:43,279
know dot net applications and they

00:42:39,829 --> 00:42:44,690
consistent you store procedures again to

00:42:43,279 --> 00:42:46,279
install switches inside I've actually

00:42:44,690 --> 00:42:48,559
used an awful lot of there I know their

00:42:46,279 --> 00:42:51,609
performance gains in doing it but I

00:42:48,559 --> 00:42:51,609
wouldn't be able to quantify them

00:42:57,579 --> 00:43:08,540
anyone over near side aired network with

00:43:00,560 --> 00:43:11,900
you oh no one more thank you for this

00:43:08,540 --> 00:43:14,240
talking sorry from your experience was

00:43:11,900 --> 00:43:17,900
the impact on performance when using

00:43:14,240 --> 00:43:24,980
foreign keys it impacts on phone using

00:43:17,900 --> 00:43:30,650
foreign keys in terms of kind of than

00:43:24,980 --> 00:43:31,970
being slower or I guess it yeah again

00:43:30,650 --> 00:43:34,609
it's one of the things we're actually my

00:43:31,970 --> 00:43:36,020
view is uh you know foreign keys are a

00:43:34,609 --> 00:43:37,700
brilliant idea if anyone has news from

00:43:36,020 --> 00:43:40,730
keys what that basically means is when

00:43:37,700 --> 00:43:42,920
you try and do an insert or an update

00:43:40,730 --> 00:43:44,990
whatever else if you've got a foreign

00:43:42,920 --> 00:43:46,670
key constraint set then it checks

00:43:44,990 --> 00:43:48,560
against the other table that the phone

00:43:46,670 --> 00:43:53,390
key set against that you've got valid

00:43:48,560 --> 00:43:54,710
matching records so at the the company

00:43:53,390 --> 00:43:58,869
where I work at the moment we do some

00:43:54,710 --> 00:44:02,240
work with Magento which as you know is

00:43:58,869 --> 00:44:04,160
lots of users lots of phone keys and

00:44:02,240 --> 00:44:06,680
what it will do is if you try and insert

00:44:04,160 --> 00:44:09,380
an order and you'll send their Kate the

00:44:06,680 --> 00:44:12,980
basket ideas 50 it will manually go and

00:44:09,380 --> 00:44:14,960
check that there is a basket ID a basket

00:44:12,980 --> 00:44:17,410
with an ID or 50 in the basket table

00:44:14,960 --> 00:44:20,750
very very simplified example but it is

00:44:17,410 --> 00:44:23,780
in most cases again the performance

00:44:20,750 --> 00:44:26,450
impact isn't that great you know it is a

00:44:23,780 --> 00:44:28,760
bit of extra extra processing but if

00:44:26,450 --> 00:44:31,010
you've got 10,000 rows and certainly

00:44:28,760 --> 00:44:32,930
been in mind as we send you know your

00:44:31,010 --> 00:44:34,849
foreign key will have its index anyway

00:44:32,930 --> 00:44:36,710
so it is using the index to do that

00:44:34,849 --> 00:44:39,380
check it's not having to do a full table

00:44:36,710 --> 00:44:41,420
search or anything like that it's not

00:44:39,380 --> 00:44:43,940
gonna be massive if you've got

00:44:41,420 --> 00:44:45,950
incredibly large tables and certainly if

00:44:43,940 --> 00:44:48,349
it depends on how important that data

00:44:45,950 --> 00:44:50,300
consistency is if actually someone

00:44:48,349 --> 00:44:52,010
inserts one without a basket ID and it

00:44:50,300 --> 00:44:54,349
then just goes oh it's not really an

00:44:52,010 --> 00:44:55,609
order it doesn't matter then if you've

00:44:54,349 --> 00:44:57,050
got lots and lots of Records you know

00:44:55,609 --> 00:44:58,790
you're talking about you know millions

00:44:57,050 --> 00:45:01,010
of Records probably for this to have an

00:44:58,790 --> 00:45:02,510
impact then again you might look at

00:45:01,010 --> 00:45:04,300
putting that into PHP in the same way as

00:45:02,510 --> 00:45:07,050
we did with the the Great Circle stuff

00:45:04,300 --> 00:45:10,310
but in most cases yeah it

00:45:07,050 --> 00:45:10,310
doesn't have a massive knock-on effect

00:45:12,620 --> 00:45:16,160

YouTube URL: https://www.youtube.com/watch?v=drYy2T23eII


