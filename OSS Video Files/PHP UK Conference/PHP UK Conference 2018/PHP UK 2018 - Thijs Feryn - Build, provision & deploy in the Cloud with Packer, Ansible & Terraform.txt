Title: PHP UK 2018 - Thijs Feryn - Build, provision & deploy in the Cloud with Packer, Ansible & Terraform
Publication date: 2018-03-27
Playlist: PHP UK Conference 2018
Description: 
	In a continuous integration and continuous delivery context, it is hard to reliably deploy code to an environment. When code commits also imply changes to your stack, it gets even more tricky. In this presentation I'll show you how to build vendor-agnostic cloud images using Packer and how to provision the necessary software dependencies using Ansible, including your PHP code. Once the image is in place, we'll use Terraform to deploy these images and create loadbalanced computing instances on various cloud environments in a single configuration format.
Captions: 
	00:00:02,740 --> 00:00:07,960
thank you for taking the time to hang

00:00:05,170 --> 00:00:09,940
out with me and I hope I will I have the

00:00:07,960 --> 00:00:11,590
lights not in my face yet I could look

00:00:09,940 --> 00:00:14,080
at you hope we can have some fun today

00:00:11,590 --> 00:00:15,220
maybe learn a thing or two and I hope

00:00:14,080 --> 00:00:17,140
you're sitting nice and comfortable

00:00:15,220 --> 00:00:19,240
let's pour another drink unless gets

00:00:17,140 --> 00:00:22,539
going let's get going I have to admit

00:00:19,240 --> 00:00:23,950
I'm very very very sick of the cloud not

00:00:22,539 --> 00:00:25,960
necessarily the ideas that they

00:00:23,950 --> 00:00:27,820
represent or the promises of the cloud

00:00:25,960 --> 00:00:30,250
but just the terms because I do a lot of

00:00:27,820 --> 00:00:31,810
presentations about cloud also to

00:00:30,250 --> 00:00:33,100
non-technical people and then I have to

00:00:31,810 --> 00:00:36,010
go to all the fluff I have to talk about

00:00:33,100 --> 00:00:37,480
sass and pass and is and about public

00:00:36,010 --> 00:00:39,520
and private and hybrid and all this

00:00:37,480 --> 00:00:41,500
marketing mumbo jumbo and I'm very very

00:00:39,520 --> 00:00:43,239
much sick of all the fluff that is being

00:00:41,500 --> 00:00:45,880
told now there's this one picture I

00:00:43,239 --> 00:00:47,559
always use and I because of lack of time

00:00:45,880 --> 00:00:49,989
I won't go to the entire game the entire

00:00:47,559 --> 00:00:51,579
spiel but I usually ask people what's on

00:00:49,989 --> 00:00:54,730
that picture and they always tell I see

00:00:51,579 --> 00:00:56,920
a plugin and I see a socket but in fact

00:00:54,730 --> 00:00:58,780
you see a person doing vacuum cleaning

00:00:56,920 --> 00:01:00,610
and what what this entire picture

00:00:58,780 --> 00:01:02,800
represents is a level of abstraction

00:01:00,610 --> 00:01:05,199
that is generated everything behind this

00:01:02,800 --> 00:01:08,229
very wall is none of that person's

00:01:05,199 --> 00:01:09,790
concern and also that metaphor of core

00:01:08,229 --> 00:01:11,170
business core business at that point is

00:01:09,790 --> 00:01:12,970
- vacuum cleaning maybe have some

00:01:11,170 --> 00:01:14,320
visitor visitors in the evening you're

00:01:12,970 --> 00:01:15,640
organizing a party and you want the

00:01:14,320 --> 00:01:17,979
house to be spotless you want it to be

00:01:15,640 --> 00:01:19,810
clean so you do your business but

00:01:17,979 --> 00:01:22,869
there's so much technology and so much

00:01:19,810 --> 00:01:24,580
levels of complexity in that just the

00:01:22,869 --> 00:01:27,159
fact of doing vacuum cleaning that we're

00:01:24,580 --> 00:01:28,840
not aware of we're not aware of how the

00:01:27,159 --> 00:01:30,280
wires are connected behind the sockets

00:01:28,840 --> 00:01:32,049
and how that is connected to the fuse

00:01:30,280 --> 00:01:34,270
box and how that is connected to the

00:01:32,049 --> 00:01:36,520
outside world to Grid and what kind of

00:01:34,270 --> 00:01:38,140
power plants are used to generate that

00:01:36,520 --> 00:01:40,360
electricity that we use just for the

00:01:38,140 --> 00:01:41,830
sheer fact of vacuum cleaning we don't

00:01:40,360 --> 00:01:44,020
know that and that's very much the

00:01:41,830 --> 00:01:45,549
representation of cloud right you apply

00:01:44,020 --> 00:01:47,259
a level of abstraction that is what you

00:01:45,549 --> 00:01:48,970
do and what you gain from that is

00:01:47,259 --> 00:01:50,979
flexibility and you leverage that

00:01:48,970 --> 00:01:52,659
flexibility to generate basically

00:01:50,979 --> 00:01:54,490
operational stability that is the

00:01:52,659 --> 00:01:56,229
promise of the cloud and to enforce that

00:01:54,490 --> 00:01:58,390
you need tons of automation and this

00:01:56,229 --> 00:02:00,340
talk is an automation talk about cloud

00:01:58,390 --> 00:02:02,560
platforms and you might know that

00:02:00,340 --> 00:02:04,960
there's many many many cloud platforms

00:02:02,560 --> 00:02:06,909
out there just to give you an idea these

00:02:04,960 --> 00:02:09,039
are just a couple of popular ones or

00:02:06,909 --> 00:02:11,439
popular cloud platforms some with

00:02:09,039 --> 00:02:13,480
external vendors some stuff you could do

00:02:11,439 --> 00:02:15,010
in-house like OpenStack or VMware or

00:02:13,480 --> 00:02:16,120
what have you so those are the big ones

00:02:15,010 --> 00:02:17,739
and every single

00:02:16,120 --> 00:02:19,450
piece of technology has its own

00:02:17,739 --> 00:02:21,370
automation suite its own rules and tools

00:02:19,450 --> 00:02:23,379
and that makes it a lot more difficult

00:02:21,370 --> 00:02:24,700
to standardize on and once you pick one

00:02:23,379 --> 00:02:26,349
you're gonna usually gonna stick with it

00:02:24,700 --> 00:02:27,879
because the level of efforts you've put

00:02:26,349 --> 00:02:29,920
into it to make it happen are so

00:02:27,879 --> 00:02:31,780
enormous and the budget you assign to it

00:02:29,920 --> 00:02:34,239
in terms of development R&D setting it

00:02:31,780 --> 00:02:36,849
up keeping it maintainable are quite a

00:02:34,239 --> 00:02:38,650
lot and as a consequence you must be

00:02:36,849 --> 00:02:40,269
locked in that to that vendor and that's

00:02:38,650 --> 00:02:42,400
the sweet spot where most of them want

00:02:40,269 --> 00:02:44,220
to keep you now I'm gonna talk about a

00:02:42,400 --> 00:02:47,260
couple of tools primarily about

00:02:44,220 --> 00:02:49,540
terraform and also about Packer and then

00:02:47,260 --> 00:02:51,190
use ansible as a sort of utility to to

00:02:49,540 --> 00:02:53,549
glue it all together and these tools

00:02:51,190 --> 00:02:55,720
should help us build provision

00:02:53,549 --> 00:02:57,910
orchestrate vendor agnostic cloud

00:02:55,720 --> 00:02:59,620
environments that's the goal there are

00:02:57,910 --> 00:03:00,700
some other goals as well so what we want

00:02:59,620 --> 00:03:02,560
to achieve by the end of this

00:03:00,700 --> 00:03:05,500
presentation and I hope you'll agree

00:03:02,560 --> 00:03:07,810
with me on that is a less lock-in less

00:03:05,500 --> 00:03:08,950
vendor looking being in much more of a

00:03:07,810 --> 00:03:11,319
comfortable position to switch from

00:03:08,950 --> 00:03:13,599
provider a to provider B do faster

00:03:11,319 --> 00:03:15,819
deployments scale better based on

00:03:13,599 --> 00:03:17,709
dynamic capacity have better

00:03:15,819 --> 00:03:20,290
reproducibility of our environments by

00:03:17,709 --> 00:03:22,260
just cloning our environments using

00:03:20,290 --> 00:03:24,760
automation to have staging tests

00:03:22,260 --> 00:03:27,220
development environments with little

00:03:24,760 --> 00:03:28,840
effort and a valid copy of our

00:03:27,220 --> 00:03:31,299
production environment also by doing

00:03:28,840 --> 00:03:33,970
lots of automation we reduce the human

00:03:31,299 --> 00:03:36,669
error which is also why the a factor in

00:03:33,970 --> 00:03:38,470
our industry and this is this is

00:03:36,669 --> 00:03:40,450
essentially the promise of the cloud but

00:03:38,470 --> 00:03:43,480
I do not believe in that and people who

00:03:40,450 --> 00:03:47,500
host stuff in the cloud these days like

00:03:43,480 --> 00:03:49,510
lower cost is that really it really the

00:03:47,500 --> 00:03:51,940
flexibility to spend what you want is

00:03:49,510 --> 00:03:54,280
there but lower cost is not really there

00:03:51,940 --> 00:03:55,900
but you can have lower cost if you

00:03:54,280 --> 00:03:57,699
automate more if you have less errors if

00:03:55,900 --> 00:03:59,769
you have less outages you'll have a

00:03:57,699 --> 00:04:01,150
level of operational stability and the

00:03:59,769 --> 00:04:03,370
price you'll have to pay for that is

00:04:01,150 --> 00:04:05,079
less than if you have to do it all

00:04:03,370 --> 00:04:07,599
manually that I agree with now that

00:04:05,079 --> 00:04:09,099
being said hi my name is Stacey

00:04:07,599 --> 00:04:10,540
that is indeed how you pronounce this

00:04:09,099 --> 00:04:12,129
I'm a Dutch speaking Belgium

00:04:10,540 --> 00:04:14,169
I'm tastefully on Twitter please follow

00:04:12,129 --> 00:04:15,669
me there this is an experiment I do at

00:04:14,169 --> 00:04:17,380
every talk I always mention my Twitter

00:04:15,669 --> 00:04:19,449
handle and every time I go through my

00:04:17,380 --> 00:04:20,079
Twitter profile after my talk I see this

00:04:19,449 --> 00:04:22,300
slight bump

00:04:20,079 --> 00:04:23,740
it's just slight bump so let's see if it

00:04:22,300 --> 00:04:26,229
applies if you have questions afterwards

00:04:23,740 --> 00:04:27,700
I'll skip Q&A entirely I'll use the 60

00:04:26,229 --> 00:04:28,960
minutes for the talk I'll be hanging

00:04:27,700 --> 00:04:29,470
around here as well so if you want to

00:04:28,960 --> 00:04:30,760
have

00:04:29,470 --> 00:04:33,120
some some questions or get a

00:04:30,760 --> 00:04:35,620
conversation started get me then or

00:04:33,120 --> 00:04:37,120
otherwise get me on Twitter I'm a

00:04:35,620 --> 00:04:39,610
Technical Evangelist at the Belgian web

00:04:37,120 --> 00:04:41,650
hosting company called combo I also work

00:04:39,610 --> 00:04:42,970
at sentía both of the same group the one

00:04:41,650 --> 00:04:44,950
is as a medium the other one is

00:04:42,970 --> 00:04:46,240
enterprise we more or less dominate to

00:04:44,950 --> 00:04:48,160
market in Belgium the Netherlands and

00:04:46,240 --> 00:04:49,750
Denmark that has nothing to do with the

00:04:48,160 --> 00:04:51,550
UK you might have never heard from us

00:04:49,750 --> 00:04:52,750
that's perfectly fine I'm also the

00:04:51,550 --> 00:04:54,460
author of getting started with varnish

00:04:52,750 --> 00:04:56,590
cache and O'Reilly book that was

00:04:54,460 --> 00:04:58,540
published last year so I'm not just

00:04:56,590 --> 00:05:01,240
about cloud automation I like caching

00:04:58,540 --> 00:05:03,940
and everything in the edge as well

00:05:01,240 --> 00:05:05,920
I'm glad to be here I am particularly

00:05:03,940 --> 00:05:07,930
glad to be in the UK this is my hundred

00:05:05,920 --> 00:05:09,790
and eighty fifth talk of which it's the

00:05:07,930 --> 00:05:11,800
seventeenth I'm doing in the UK and one

00:05:09,790 --> 00:05:13,750
of the best experiences I had was in the

00:05:11,800 --> 00:05:15,010
UK so I'm really grateful that you took

00:05:13,750 --> 00:05:16,870
the time out of your schedule to check

00:05:15,010 --> 00:05:18,790
me out and I hope we can have a good

00:05:16,870 --> 00:05:21,850
time it's my 11th time in London and my

00:05:18,790 --> 00:05:24,970
4 time here at the brewery venue that I

00:05:21,850 --> 00:05:27,400
love so let's get going if you like or

00:05:24,970 --> 00:05:29,680
hate this talk could be either of those

00:05:27,400 --> 00:05:30,280
could be both depending please give me

00:05:29,680 --> 00:05:31,840
feedback

00:05:30,280 --> 00:05:33,940
give me pleat feedback about the good

00:05:31,840 --> 00:05:35,830
parts but also about the bad parts not

00:05:33,940 --> 00:05:37,600
just for me but for organizers as well I

00:05:35,830 --> 00:05:39,070
would love to do this talk and a future

00:05:37,600 --> 00:05:41,980
conference somewhere else in the world

00:05:39,070 --> 00:05:45,120
if you don't agree give me give me some

00:05:41,980 --> 00:05:49,870
criticism maybe tell me how I can prove

00:05:45,120 --> 00:05:51,130
ready yes ok let's do it then we're

00:05:49,870 --> 00:05:52,780
gonna do three things today we're gonna

00:05:51,130 --> 00:05:54,490
build we're gonna provision and we're

00:05:52,780 --> 00:05:56,860
gonna orchestrate those are all fancy

00:05:54,490 --> 00:05:58,750
terms basically the building part is

00:05:56,860 --> 00:06:00,250
we're gonna take application code and

00:05:58,750 --> 00:06:03,280
we're gonna bake it into a virtual

00:06:00,250 --> 00:06:05,710
machine image it comes with the hype

00:06:03,280 --> 00:06:08,470
terms like immutable infrastructure but

00:06:05,710 --> 00:06:09,910
I won't go that far or be that arrogant

00:06:08,470 --> 00:06:11,260
to call it all that but in throughout

00:06:09,910 --> 00:06:12,640
this example throughout this

00:06:11,260 --> 00:06:14,020
presentation we're gonna take some

00:06:12,640 --> 00:06:16,419
application code we're gonna put it in a

00:06:14,020 --> 00:06:17,650
virtual machine image then we're we're

00:06:16,419 --> 00:06:19,240
gonna use Packer for that of course

00:06:17,650 --> 00:06:21,010
that's the technology that I'll discuss

00:06:19,240 --> 00:06:22,390
today then we'll pour some proverbial

00:06:21,010 --> 00:06:24,520
sauce on it that's the provisioning

00:06:22,390 --> 00:06:26,020
partment pour some sauce on our little

00:06:24,520 --> 00:06:27,310
cake the thing we're baking and that

00:06:26,020 --> 00:06:28,630
should be the full stack that should

00:06:27,310 --> 00:06:31,000
contain all the software that is

00:06:28,630 --> 00:06:33,190
required to run our application code

00:06:31,000 --> 00:06:35,950
which is in our VM and once we have that

00:06:33,190 --> 00:06:37,960
VM again we'll use ansible to do that

00:06:35,950 --> 00:06:40,090
and once we have our VM we need to serve

00:06:37,960 --> 00:06:41,979
our dish in the cloud and that will be

00:06:40,090 --> 00:06:43,069
your history Asian part for which we'll

00:06:41,979 --> 00:06:47,389
use tariffs or

00:06:43,069 --> 00:06:49,669
loud and clear okay next steps all of

00:06:47,389 --> 00:06:51,819
this and that's the beauty it falls

00:06:49,669 --> 00:06:54,740
under the infrastructure as codes

00:06:51,819 --> 00:06:56,419
umbrella so that means all these

00:06:54,740 --> 00:06:57,889
configurations that we're using to build

00:06:56,419 --> 00:07:01,099
a virtual machine image to put it in the

00:06:57,889 --> 00:07:02,930
cloud are readable text files so to

00:07:01,099 --> 00:07:04,339
speak and these could be an essential

00:07:02,930 --> 00:07:06,409
part of our git repository where

00:07:04,339 --> 00:07:08,089
application code is it could also be a

00:07:06,409 --> 00:07:10,219
separate repository

00:07:08,089 --> 00:07:13,430
it could be two things depending on how

00:07:10,219 --> 00:07:14,629
you're organized now our mission is to

00:07:13,430 --> 00:07:16,129
create disposable stacks and

00:07:14,629 --> 00:07:18,379
reproducible environments and let's do

00:07:16,129 --> 00:07:20,419
just that and introduce our very first

00:07:18,379 --> 00:07:23,180
technology it's called Packer Packer is

00:07:20,419 --> 00:07:25,249
a product that is open-source but

00:07:23,180 --> 00:07:27,229
there's an enterprise suite around it

00:07:25,249 --> 00:07:28,370
built by the people of Hoshi Corp has a

00:07:27,229 --> 00:07:30,800
core part of people who also invented

00:07:28,370 --> 00:07:32,509
vagrant who has used vagrant before yes

00:07:30,800 --> 00:07:34,669
II thought you would know that well

00:07:32,509 --> 00:07:35,809
that's the same company and it's

00:07:34,669 --> 00:07:37,309
actually an interesting company but

00:07:35,809 --> 00:07:39,889
they're ahead of their time and they're

00:07:37,309 --> 00:07:42,619
figuring out problems that it can occur

00:07:39,889 --> 00:07:44,360
in developments in ops in the clouds and

00:07:42,619 --> 00:07:44,569
figuring out vendor agnostic tools to do

00:07:44,360 --> 00:07:47,029
so

00:07:44,569 --> 00:07:49,639
Packer is just the script of a binary

00:07:47,029 --> 00:07:51,649
written and go and what it does is it

00:07:49,639 --> 00:07:54,649
interacts with cloud providers and it's

00:07:51,649 --> 00:07:56,659
able to build VMs from either of those

00:07:54,649 --> 00:07:58,370
and I think the list is growing by now

00:07:56,659 --> 00:08:00,379
maybe the the list isn't up to date yet

00:07:58,370 --> 00:08:03,830
and they they have new vendors I will

00:08:00,379 --> 00:08:05,539
primarily use AWS Amazon ec2 images and

00:08:03,830 --> 00:08:07,819
OpenStack those are the two things I use

00:08:05,539 --> 00:08:09,979
we do a lot of VMware as well so it's

00:08:07,819 --> 00:08:11,659
quite easy to pick one and it's a single

00:08:09,979 --> 00:08:13,639
syntax just the configuration file a

00:08:11,659 --> 00:08:16,759
JSON file in which you define what you

00:08:13,639 --> 00:08:19,069
need you run the command and it builds

00:08:16,759 --> 00:08:21,409
it and you have a ready to use image at

00:08:19,069 --> 00:08:23,599
your cloud provider so let's do it we'd

00:08:21,409 --> 00:08:25,669
open stack who uses OpenStack in here I

00:08:23,599 --> 00:08:28,249
don't expect to see many hands no one

00:08:25,669 --> 00:08:30,110
just to prove my point I haven't an AWS

00:08:28,249 --> 00:08:32,659
example as well who use this AWS and

00:08:30,110 --> 00:08:34,729
here see yeah okay I expected that but

00:08:32,659 --> 00:08:36,740
just to show you that there's a lot of

00:08:34,729 --> 00:08:38,599
similarities in here so this is a JSON

00:08:36,740 --> 00:08:40,729
file in which I define my configuration

00:08:38,599 --> 00:08:42,740
you see a building stage which I marked

00:08:40,729 --> 00:08:44,810
in reds and a provisioning stage in the

00:08:42,740 --> 00:08:46,940
building stage we'll take a source image

00:08:44,810 --> 00:08:49,060
which you see here that is the

00:08:46,940 --> 00:08:51,170
identifier of my source image in my

00:08:49,060 --> 00:08:53,750
OpenStack installation and we'll use

00:08:51,170 --> 00:08:55,910
that to boot up an image to do all this

00:08:53,750 --> 00:08:56,899
things we need to do in this very stupid

00:08:55,910 --> 00:08:58,819
example I'm install

00:08:56,899 --> 00:09:00,470
enginex by an inline shell script and

00:08:58,819 --> 00:09:01,639
then we need to have some network

00:09:00,470 --> 00:09:03,529
settings to be able to connect to that

00:09:01,639 --> 00:09:06,649
machine and in the end we'll turn that

00:09:03,529 --> 00:09:08,329
into a new image the image is called

00:09:06,649 --> 00:09:10,490
taste foreign underscore and then some

00:09:08,329 --> 00:09:12,350
variable interpolation in which I put

00:09:10,490 --> 00:09:15,139
the current timestamp and that will be

00:09:12,350 --> 00:09:17,720
my ready to use image based on a typical

00:09:15,139 --> 00:09:19,970
Debian stretch so that's a db9 64-bit

00:09:17,720 --> 00:09:21,470
installation with nginx installed and

00:09:19,970 --> 00:09:25,399
that will be my machine image it's just

00:09:21,470 --> 00:09:28,999
an example of course in AWS terms it's

00:09:25,399 --> 00:09:31,879
very similar just maybe some more subtle

00:09:28,999 --> 00:09:33,439
things like you have an ami name and a

00:09:31,879 --> 00:09:35,929
source ami but the rest is more or less

00:09:33,439 --> 00:09:37,279
the same I deliberately left my

00:09:35,929 --> 00:09:38,929
credentials empty I don't want you to be

00:09:37,279 --> 00:09:41,360
logging onto my Amazon account

00:09:38,929 --> 00:09:43,399
preferably so but you probably need to

00:09:41,360 --> 00:09:45,379
have the like for OpenStack you need to

00:09:43,399 --> 00:09:46,759
refer to the endpoint a tenant name some

00:09:45,379 --> 00:09:49,879
key settings well you have to do the

00:09:46,759 --> 00:09:52,519
same thing for Amazon so it's very very

00:09:49,879 --> 00:09:54,860
simple and you run your command Packer

00:09:52,519 --> 00:09:56,269
builds of that JSON file and you end up

00:09:54,860 --> 00:09:59,089
with an image that is already registered

00:09:56,269 --> 00:10:00,980
with your cloud vendor so it's not on

00:09:59,089 --> 00:10:03,889
your local computer it's out there ready

00:10:00,980 --> 00:10:06,949
to use ready to orchestrate this is a

00:10:03,889 --> 00:10:09,050
schematic schematic representation of it

00:10:06,949 --> 00:10:11,329
so what it does that Packer built reads

00:10:09,050 --> 00:10:13,040
your JSON file and calls clouds api's

00:10:11,329 --> 00:10:15,889
and it actually boots up a server there

00:10:13,040 --> 00:10:17,839
so it boots up computing power on which

00:10:15,889 --> 00:10:20,329
it does all the mumbo-jumbo in this case

00:10:17,839 --> 00:10:22,910
a shell provisioning script it stops it

00:10:20,329 --> 00:10:26,029
it takes a snapshot it registers it and

00:10:22,910 --> 00:10:27,740
you're all done and you could use the

00:10:26,029 --> 00:10:29,870
tools like the CLI tools of OpenStack

00:10:27,740 --> 00:10:31,850
and if you do image list you'll see that

00:10:29,870 --> 00:10:34,189
image they're ready to use readily

00:10:31,850 --> 00:10:35,959
available same thing for Amazon if you

00:10:34,189 --> 00:10:38,660
run the command like this you'll see

00:10:35,959 --> 00:10:40,759
that this VM image is ready to use and

00:10:38,660 --> 00:10:42,290
then we just have to use ansible to make

00:10:40,759 --> 00:10:47,360
it enrich it a bit because that stupid

00:10:42,290 --> 00:10:48,889
apt-get install - why nginx command that

00:10:47,360 --> 00:10:50,990
won't completely cut it you you'll need

00:10:48,889 --> 00:10:51,920
a little bit more elaborate systems to

00:10:50,990 --> 00:10:54,649
do that and add something that's just

00:10:51,920 --> 00:10:57,189
the thing who uses ansible in here who

00:10:54,649 --> 00:11:00,049
does not I would rather know that ok

00:10:57,189 --> 00:11:01,939
would say more than 50% use ansible here

00:11:00,049 --> 00:11:02,480
well I'm preaching to the choir but I'll

00:11:01,939 --> 00:11:04,279
still do it

00:11:02,480 --> 00:11:06,799
it's a configuration management system

00:11:04,279 --> 00:11:08,569
it's very similar to tools like chef and

00:11:06,799 --> 00:11:10,430
puppet and salt stack and you know

00:11:08,569 --> 00:11:12,589
cfengine and other stuff

00:11:10,430 --> 00:11:16,520
what it primarily does it is responsible

00:11:12,589 --> 00:11:17,960
for installing software to configure

00:11:16,520 --> 00:11:19,730
your machine and to make sure that the

00:11:17,960 --> 00:11:22,220
full stack is ready so that you have a

00:11:19,730 --> 00:11:23,600
VM image that is provisioned or not even

00:11:22,220 --> 00:11:25,100
if um image you could run it on existing

00:11:23,600 --> 00:11:27,110
infrastructure in a more traditional

00:11:25,100 --> 00:11:29,630
setup and make sure that based on

00:11:27,110 --> 00:11:31,850
playbooks based on sort of recipe you'll

00:11:29,630 --> 00:11:34,160
have a system that is completely up to

00:11:31,850 --> 00:11:35,720
spec and the thing I like about ansible

00:11:34,160 --> 00:11:36,290
is it's very lightweight it's written in

00:11:35,720 --> 00:11:38,510
Python

00:11:36,290 --> 00:11:40,820
there's no agents involved it's just is

00:11:38,510 --> 00:11:42,649
SH commands over the wire and you read

00:11:40,820 --> 00:11:44,690
Yama files play books as they call it

00:11:42,649 --> 00:11:46,670
and you run those and those contain

00:11:44,690 --> 00:11:48,740
instructions on what files should be

00:11:46,670 --> 00:11:50,270
present what permissions they should

00:11:48,740 --> 00:11:52,490
have which packages should be installed

00:11:50,270 --> 00:11:54,320
which services should run and so on and

00:11:52,490 --> 00:11:55,250
so forth there's ways to organize that

00:11:54,320 --> 00:11:56,899
I'll show that in a minute

00:11:55,250 --> 00:11:59,720
and it's basically installing software

00:11:56,899 --> 00:12:01,310
and configuring your server again this

00:11:59,720 --> 00:12:03,470
is not an answerable talk but I'll show

00:12:01,310 --> 00:12:05,660
you a pretty basic playbook

00:12:03,470 --> 00:12:08,120
that I used so what you do is you match

00:12:05,660 --> 00:12:10,100
your hosts to your inventory and in this

00:12:08,120 --> 00:12:12,740
case this could be installed on every

00:12:10,100 --> 00:12:15,290
server in my inventory and I define some

00:12:12,740 --> 00:12:16,459
variables being this is my web folder or

00:12:15,290 --> 00:12:18,290
the code folders that need to be

00:12:16,459 --> 00:12:20,930
synchronized with my VM image in the end

00:12:18,290 --> 00:12:23,630
that's just a variable we do become true

00:12:20,930 --> 00:12:24,680
which is a sort of pseudo Sioux kind of

00:12:23,630 --> 00:12:28,010
approach so that you have root access

00:12:24,680 --> 00:12:29,510
and then you execute a set of tasks this

00:12:28,010 --> 00:12:32,450
is very descriptive right just llamó

00:12:29,510 --> 00:12:35,240
based update our apt repository install

00:12:32,450 --> 00:12:36,800
vim curl nginx PHP our sync do some

00:12:35,240 --> 00:12:38,810
folder stuff you get the message right

00:12:36,800 --> 00:12:40,040
yeah is this clear let's skip it let's

00:12:38,810 --> 00:12:41,480
let's go to the next one

00:12:40,040 --> 00:12:43,790
another thing I'm doing is synchronizing

00:12:41,480 --> 00:12:45,410
my application based on that variable so

00:12:43,790 --> 00:12:47,660
in the end I'll have an engine next I'll

00:12:45,410 --> 00:12:50,420
have PHP my code will be there and I'm

00:12:47,660 --> 00:12:52,370
ready to rock but in real production

00:12:50,420 --> 00:12:54,380
environments you won't keep it that

00:12:52,370 --> 00:12:56,360
simple you'll organize it in a much more

00:12:54,380 --> 00:12:58,310
intricate way and I have a tree here

00:12:56,360 --> 00:13:00,079
which I can show you how you could

00:12:58,310 --> 00:13:01,910
typically do that this is a bit of an

00:13:00,079 --> 00:13:04,160
abstracted version but it would cover it

00:13:01,910 --> 00:13:06,020
so in this tree you see a thing called

00:13:04,160 --> 00:13:08,720
roles and roles are our more-or-less

00:13:06,020 --> 00:13:10,550
modules encapsulated logic that contains

00:13:08,720 --> 00:13:12,950
variables that contain templates that

00:13:10,550 --> 00:13:15,020
contains the full-blown installation for

00:13:12,950 --> 00:13:17,240
a component that could be nginx could be

00:13:15,020 --> 00:13:19,579
MySQL could be PHP could be whatever you

00:13:17,240 --> 00:13:20,900
want to use but it has lots of settings

00:13:19,579 --> 00:13:22,730
you can configure you can tweak and

00:13:20,900 --> 00:13:23,840
you're not exposing yourself to the

00:13:22,730 --> 00:13:25,310
complexity of it all

00:13:23,840 --> 00:13:26,990
so you see here that you have some

00:13:25,310 --> 00:13:29,390
defaults that you can set some handlers

00:13:26,990 --> 00:13:31,910
to restart some meta information tasks

00:13:29,390 --> 00:13:34,490
to execute maybe templates your parse a

00:13:31,910 --> 00:13:35,720
virtual host system a PHP ini file you

00:13:34,490 --> 00:13:38,029
name it but that's all nicely

00:13:35,720 --> 00:13:40,760
encapsulated and you don't really need

00:13:38,029 --> 00:13:43,040
to be exposed to that if you have logic

00:13:40,760 --> 00:13:45,380
that extends that you could easily run

00:13:43,040 --> 00:13:48,320
and include custom tasks have custom

00:13:45,380 --> 00:13:49,820
templates custom files and variables you

00:13:48,320 --> 00:13:52,339
want to extend you do that either on a

00:13:49,820 --> 00:13:53,960
host basis or on a group basis with the

00:13:52,339 --> 00:13:56,690
host basis I mean you can match a host

00:13:53,960 --> 00:13:58,820
and say that host should have X amount

00:13:56,690 --> 00:14:00,710
of PHP workers for example and those PHP

00:13:58,820 --> 00:14:02,660
workers could be defined in your PHP

00:14:00,710 --> 00:14:04,610
role you can extend them at the host

00:14:02,660 --> 00:14:06,050
level if you group certain servers

00:14:04,610 --> 00:14:07,730
let's say you have for web servers and

00:14:06,050 --> 00:14:09,560
you create a group web then you could

00:14:07,730 --> 00:14:12,230
define that these workers are set on a

00:14:09,560 --> 00:14:13,580
group level so basically this is more or

00:14:12,230 --> 00:14:16,520
less the best practices on how to

00:14:13,580 --> 00:14:17,870
organize your ansible stuff and then you

00:14:16,520 --> 00:14:20,900
can apply it on your virtual machines

00:14:17,870 --> 00:14:22,550
and in terms of applying them it is a

00:14:20,900 --> 00:14:24,110
lot cleaner if your PlayBook looks like

00:14:22,550 --> 00:14:26,240
this your include a couple of custom

00:14:24,110 --> 00:14:28,130
tasks and the less the rest is just

00:14:26,240 --> 00:14:30,140
roles and variables are defined

00:14:28,130 --> 00:14:32,240
elsewhere if you would run this

00:14:30,140 --> 00:14:33,710
separately without Packer would look a

00:14:32,240 --> 00:14:34,910
little bit like this ansible playbook

00:14:33,710 --> 00:14:36,680
when your playbook everything gets

00:14:34,910 --> 00:14:39,440
bootstrapped and the end result is that

00:14:36,680 --> 00:14:41,240
you have a set of it's completely up to

00:14:39,440 --> 00:14:44,150
spec and you can run that in tests in

00:14:41,240 --> 00:14:46,460
production in QA you'll have identical

00:14:44,150 --> 00:14:48,110
environments basically but we won't be

00:14:46,460 --> 00:14:49,700
doing that we'll be replacing our

00:14:48,110 --> 00:14:51,589
provisioning part where this used to be

00:14:49,700 --> 00:14:53,510
the shell execution I just put ansible

00:14:51,589 --> 00:14:55,730
in there register our playbook and we're

00:14:53,510 --> 00:14:57,350
good to go and in the background ansible

00:14:55,730 --> 00:14:59,150
run a very complicated one this is the

00:14:57,350 --> 00:15:01,460
one I ran on my laptop this is what

00:14:59,150 --> 00:15:03,320
ansible will do for you in the end it

00:15:01,460 --> 00:15:04,970
will match your inventory dynamically it

00:15:03,320 --> 00:15:06,770
will take the playbook it will register

00:15:04,970 --> 00:15:08,300
all kinds of variables and you're good

00:15:06,770 --> 00:15:10,310
to go so instead of doing the shell

00:15:08,300 --> 00:15:12,500
script we'll doing we're doing much more

00:15:10,310 --> 00:15:15,140
advanced stuff and running our customer

00:15:12,500 --> 00:15:17,900
custom ansible playbooks in the end

00:15:15,140 --> 00:15:19,430
we'll add a little bit more magic and

00:15:17,900 --> 00:15:21,589
we'll add a post processor of the type

00:15:19,430 --> 00:15:23,480
manifest and a manifest is nothing more

00:15:21,589 --> 00:15:25,190
than a JSON file where all the build

00:15:23,480 --> 00:15:27,470
steps are registered you can use that in

00:15:25,190 --> 00:15:29,480
your CI CD pipeline to see what has

00:15:27,470 --> 00:15:31,760
happened so in the end it will store

00:15:29,480 --> 00:15:33,890
your built results with your artifact

00:15:31,760 --> 00:15:35,270
data right there in a readable format

00:15:33,890 --> 00:15:37,320
and this is what it looks like I

00:15:35,270 --> 00:15:39,540
deliberately put in Amazon and an open

00:15:37,320 --> 00:15:42,560
built next to one another you can match

00:15:39,540 --> 00:15:45,720
the last run ID right here like b6

00:15:42,560 --> 00:15:46,770
triple zero that's just that one that's

00:15:45,720 --> 00:15:49,350
the last one and then you could see the

00:15:46,770 --> 00:15:51,600
artifact ID and the artifact ID is a

00:15:49,350 --> 00:15:54,390
given identifier a unique ID that was

00:15:51,600 --> 00:15:57,870
assigned by your cloud provider so in

00:15:54,390 --> 00:16:00,780
this case ef9 oh and what have you this

00:15:57,870 --> 00:16:04,130
is the ID of my freshly-baked image at

00:16:00,780 --> 00:16:06,960
the openstack side and you can use JQ

00:16:04,130 --> 00:16:07,650
just to parse that you used take you as

00:16:06,960 --> 00:16:10,770
well right Mike

00:16:07,650 --> 00:16:12,960
brilliant tool command-line tool just to

00:16:10,770 --> 00:16:14,520
get that artifact ID out of it and here

00:16:12,960 --> 00:16:17,730
I could prove it if I do open stack

00:16:14,520 --> 00:16:19,920
image list that very ID that's the one I

00:16:17,730 --> 00:16:21,450
could use to orchestrate it now I

00:16:19,920 --> 00:16:23,880
recorded a video for that because I

00:16:21,450 --> 00:16:26,190
don't want to bore you sitting here for

00:16:23,880 --> 00:16:28,560
20 minutes waiting at making waiting

00:16:26,190 --> 00:16:30,810
until it gets baked so what I do I've

00:16:28,560 --> 00:16:32,970
sped it up I use some video editing

00:16:30,810 --> 00:16:34,500
software to do it rapidly so we'll do a

00:16:32,970 --> 00:16:37,140
backer build I know this film is rather

00:16:34,500 --> 00:16:38,310
small I tried my best but you don't have

00:16:37,140 --> 00:16:40,890
to read it you just have to see the

00:16:38,310 --> 00:16:42,630
movement and the color just to get a

00:16:40,890 --> 00:16:44,190
sense of it so we're opening it up or

00:16:42,630 --> 00:16:45,660
firing off an image we create

00:16:44,190 --> 00:16:49,050
associating some network settings

00:16:45,660 --> 00:16:51,300
assigning an SSH key running our ansible

00:16:49,050 --> 00:16:52,980
script we're stopping the server once

00:16:51,300 --> 00:16:54,720
the server's fully stopped for creating

00:16:52,980 --> 00:16:56,520
a snapshot of it snapshot gets

00:16:54,720 --> 00:17:00,540
registered as an image and then the end

00:16:56,520 --> 00:17:02,430
result is that you see here EF 9 Oh ad 1

00:17:00,540 --> 00:17:03,630
that's our image create it right there

00:17:02,430 --> 00:17:04,800
and then and then we have to do

00:17:03,630 --> 00:17:06,660
something with that image and that's the

00:17:04,800 --> 00:17:09,120
next step and that's the rest of the

00:17:06,660 --> 00:17:11,189
presentation is using terraform to

00:17:09,120 --> 00:17:12,510
leverage these kinds of things so we

00:17:11,189 --> 00:17:15,060
could use two terms for it we could say

00:17:12,510 --> 00:17:17,850
we'll deploy our image but I think

00:17:15,060 --> 00:17:19,140
deployment is way too simple and it

00:17:17,850 --> 00:17:20,850
doesn't really cover the entire spectrum

00:17:19,140 --> 00:17:23,070
because deploying an image would just

00:17:20,850 --> 00:17:25,949
imply we have a VM we give it the image

00:17:23,070 --> 00:17:28,410
we're done but when you look at it from

00:17:25,949 --> 00:17:30,720
an OpenStack and Asher and Amazon and

00:17:28,410 --> 00:17:32,850
Google clouds perspective the term

00:17:30,720 --> 00:17:34,260
orchestration fits the needs a lot more

00:17:32,850 --> 00:17:36,270
because it's more than just setting up a

00:17:34,260 --> 00:17:37,650
server it's actually launching a virtual

00:17:36,270 --> 00:17:40,200
data center with all these components

00:17:37,650 --> 00:17:41,400
and I won't go all over all them you

00:17:40,200 --> 00:17:43,410
probably know that you need to provide

00:17:41,400 --> 00:17:45,390
IP space and subnets and routing

00:17:43,410 --> 00:17:47,160
information and security information all

00:17:45,390 --> 00:17:49,590
these kinds of things that is rather

00:17:47,160 --> 00:17:50,570
complicated and they depend vender

00:17:49,590 --> 00:17:53,059
provender

00:17:50,570 --> 00:17:56,000
it's perfectly feasible there are tools

00:17:53,059 --> 00:17:58,370
out there in the different cloud vendor

00:17:56,000 --> 00:18:00,830
products like cloud formation for AWS

00:17:58,370 --> 00:18:03,289
there's a heat orchestration suite for

00:18:00,830 --> 00:18:05,299
OpenStack resource manager asher we

00:18:03,289 --> 00:18:07,039
won't be using those will be using

00:18:05,299 --> 00:18:09,830
terraform and terraform directly

00:18:07,039 --> 00:18:11,750
interacts with the api's of those cloud

00:18:09,830 --> 00:18:14,059
vendors so it doesn't use or leverage

00:18:11,750 --> 00:18:17,120
your castration tools it uses the api's

00:18:14,059 --> 00:18:20,029
directly it's also infrastructures code

00:18:17,120 --> 00:18:21,830
so you read human readable files that

00:18:20,029 --> 00:18:24,019
contain all the definitions we want

00:18:21,830 --> 00:18:26,720
vendor agnostic you can plant them in

00:18:24,019 --> 00:18:28,190
advance and it will give you it will

00:18:26,720 --> 00:18:29,120
estimate what it needs to do and show

00:18:28,190 --> 00:18:31,039
you the actions that need to be

00:18:29,120 --> 00:18:32,629
undertaken you can visualize this in a

00:18:31,039 --> 00:18:34,759
graph form you can execute those

00:18:32,629 --> 00:18:37,220
commands this is also a tool that is

00:18:34,759 --> 00:18:39,230
written in go it's a single binary it's

00:18:37,220 --> 00:18:42,259
also by the people the lovely people of

00:18:39,230 --> 00:18:44,179
Hoshi Corp you could you have multiple

00:18:42,259 --> 00:18:46,279
providers you can boot up some stuff

00:18:44,179 --> 00:18:48,080
with Amazon some stuff with Azure you

00:18:46,279 --> 00:18:50,360
can have some Google instances and you

00:18:48,080 --> 00:18:52,730
could in theory and make it all work

00:18:50,360 --> 00:18:55,429
together quite nicely and again it

00:18:52,730 --> 00:18:57,889
interacts with the api's it does not

00:18:55,429 --> 00:19:00,440
leverage their orchestration Suites and

00:18:57,889 --> 00:19:01,580
there's tons more providers this is just

00:19:00,440 --> 00:19:03,500
the list

00:19:01,580 --> 00:19:05,750
baffling list of tools you can use for

00:19:03,500 --> 00:19:09,500
the sake of this presentation I'll only

00:19:05,750 --> 00:19:11,690
use AWS and based on the show of hands

00:19:09,500 --> 00:19:13,039
and what you guys are using I think it

00:19:11,690 --> 00:19:15,320
makes much more sense to stick to that

00:19:13,039 --> 00:19:17,779
so it all starts with a simple TF file

00:19:15,320 --> 00:19:20,090
if you have a directory where you want

00:19:17,779 --> 00:19:21,919
to put all these configurations you just

00:19:20,090 --> 00:19:25,009
put a random TF file I just chose

00:19:21,919 --> 00:19:26,360
main-belt EF but put whatever put bloody

00:19:25,009 --> 00:19:27,980
Evan and it will bootstrap it

00:19:26,360 --> 00:19:29,809
automatically and here's our first

00:19:27,980 --> 00:19:32,990
scenario code on screen that is what you

00:19:29,809 --> 00:19:34,850
like write code on the screen we have a

00:19:32,990 --> 00:19:36,309
set of variables we could have resources

00:19:34,850 --> 00:19:39,740
we could have datasets we could have

00:19:36,309 --> 00:19:41,299
outputs there's differences to it but

00:19:39,740 --> 00:19:42,889
you have to think about it as a way to

00:19:41,299 --> 00:19:44,860
interact with these API so that's the

00:19:42,889 --> 00:19:47,269
premise it interacts with api's

00:19:44,860 --> 00:19:49,549
variables provide input that we can use

00:19:47,269 --> 00:19:51,889
in a later stage so we have a variable

00:19:49,549 --> 00:19:53,960
called ami here which if you follow

00:19:51,889 --> 00:19:54,379
along if you haven't fallen asleep just

00:19:53,960 --> 00:19:56,240
yet

00:19:54,379 --> 00:19:59,269
that's that custom vm image that we just

00:19:56,240 --> 00:20:01,279
baked we're gonna pass that ami that ID

00:19:59,269 --> 00:20:03,860
of our image there and we'll get

00:20:01,279 --> 00:20:04,519
bootstrapped it has a default value if I

00:20:03,860 --> 00:20:06,789
don't provide

00:20:04,519 --> 00:20:09,739
custom value myself it will use

00:20:06,789 --> 00:20:12,559
mid-1870s the official Debian stretch

00:20:09,739 --> 00:20:14,839
image it will just launch a blank Debian

00:20:12,559 --> 00:20:17,450
server if you don't provide a custom my

00:20:14,839 --> 00:20:19,820
what you can do in terraform is either

00:20:17,450 --> 00:20:21,589
have a TF VARs file just the variables

00:20:19,820 --> 00:20:23,779
file where you define the variables that

00:20:21,589 --> 00:20:25,940
you want to use or you can use the - VAR

00:20:23,779 --> 00:20:28,639
command-line argument and pipe a min

00:20:25,940 --> 00:20:30,889
directly into the application once we

00:20:28,639 --> 00:20:33,440
have that we'll bootstrap an instance

00:20:30,889 --> 00:20:34,609
it's of the type AWS instance so

00:20:33,440 --> 00:20:36,589
terraform will be clever enough to

00:20:34,609 --> 00:20:39,799
figure out that that should be an ec2

00:20:36,589 --> 00:20:41,719
image and it's called web we refer to it

00:20:39,799 --> 00:20:43,279
as out as well these names don't really

00:20:41,719 --> 00:20:45,200
collide because you see our use web here

00:20:43,279 --> 00:20:46,700
I use web there I use web there those

00:20:45,200 --> 00:20:49,129
names don't really collide because there

00:20:46,700 --> 00:20:51,619
are a different resource type so we'll

00:20:49,129 --> 00:20:54,079
be doing here is using our ami variable

00:20:51,619 --> 00:20:56,209
either a custom Debian or the stock

00:20:54,079 --> 00:20:58,879
Debian stretch or even our custom image

00:20:56,209 --> 00:21:01,190
and then we'll assign an instance type

00:20:58,879 --> 00:21:02,779
to it I'm using t2 micro right now don't

00:21:01,190 --> 00:21:05,059
use this in production this is just the

00:21:02,779 --> 00:21:06,859
tiniest of tiny for the sake of this

00:21:05,059 --> 00:21:08,570
preparation of this talk I didn't want

00:21:06,859 --> 00:21:11,629
to spend a lot of money so I used the

00:21:08,570 --> 00:21:13,219
tiny ones I have a predefined security

00:21:11,629 --> 00:21:15,799
group which is just the firewall

00:21:13,219 --> 00:21:17,869
settings for web it opens up 443 it

00:21:15,799 --> 00:21:20,029
opens up 80 it gives us access

00:21:17,869 --> 00:21:23,119
throughout HTTP and then we give it some

00:21:20,029 --> 00:21:24,919
tags AWS has a tagging system if you use

00:21:23,119 --> 00:21:27,229
the name tag that will help you in your

00:21:24,919 --> 00:21:29,749
graphical interface to spot it in the

00:21:27,229 --> 00:21:31,879
name column once we've done that we want

00:21:29,749 --> 00:21:34,339
to link the public IP address that is

00:21:31,879 --> 00:21:37,159
associated with that and link it to a

00:21:34,339 --> 00:21:39,049
DNS record but we don't have information

00:21:37,159 --> 00:21:41,450
I don't know the ID right now of my zone

00:21:39,049 --> 00:21:43,279
but what I can use is a data format

00:21:41,450 --> 00:21:45,649
that's a data source and that data

00:21:43,279 --> 00:21:47,659
source will do a get on the API based on

00:21:45,649 --> 00:21:50,989
an identifier and that it identifier is

00:21:47,659 --> 00:21:53,749
named so I have an AWS comm Balcom zone

00:21:50,989 --> 00:21:55,820
at Amazon and I'll retrieve it and I

00:21:53,749 --> 00:21:57,649
could use variable interpolation to get

00:21:55,820 --> 00:21:59,659
the ID from it so what I'm doing here is

00:21:57,649 --> 00:22:01,909
I'm creating a record I'm gonna create

00:21:59,659 --> 00:22:03,889
an a record and a record to DNS record

00:22:01,909 --> 00:22:05,690
where I link the IP address to the host

00:22:03,889 --> 00:22:08,899
name so what i'm doing here is variable

00:22:05,690 --> 00:22:11,239
interpolation de the AWS route 53 zone

00:22:08,899 --> 00:22:13,700
so right here it's called web and i want

00:22:11,239 --> 00:22:15,829
to zone ID so it will fetch that fetch

00:22:13,700 --> 00:22:17,509
that state inject it there and then we

00:22:15,829 --> 00:22:18,350
can have a naming convention to it my

00:22:17,509 --> 00:22:20,059
notes

00:22:18,350 --> 00:22:22,549
should be called taste fitting - web and

00:22:20,059 --> 00:22:25,220
then the name of the zone so that should

00:22:22,549 --> 00:22:27,080
be tasteful in - web dot a w s dot-com

00:22:25,220 --> 00:22:29,240
welcome and we continue on it's an a

00:22:27,080 --> 00:22:30,799
record it's valid for 60 seconds and

00:22:29,240 --> 00:22:32,539
then it the ppl gets refreshed

00:22:30,799 --> 00:22:34,039
that's the theoretical minimum if you

00:22:32,539 --> 00:22:35,570
want to be nice to the Internet increase

00:22:34,039 --> 00:22:37,760
that a bit if you don't want to be nice

00:22:35,570 --> 00:22:39,380
to the Internet leave it at 60 and then

00:22:37,760 --> 00:22:41,900
you'll eventually have an IP address

00:22:39,380 --> 00:22:43,940
linked to it and that is of our AWS

00:22:41,900 --> 00:22:47,030
instance which is also called web grab

00:22:43,940 --> 00:22:49,250
the public IP and that will do its magic

00:22:47,030 --> 00:22:51,169
that will create an instance creating a

00:22:49,250 --> 00:22:52,970
record or change in a record depending

00:22:51,169 --> 00:22:54,890
on its existence and in the end it will

00:22:52,970 --> 00:22:57,230
output those values I want the public IP

00:22:54,890 --> 00:22:59,419
of my web server and I want a hostname

00:22:57,230 --> 00:23:01,549
of my DNS records that's just our main

00:22:59,419 --> 00:23:03,590
TF file once we have that we'll run

00:23:01,549 --> 00:23:05,510
terraform init terraform into this

00:23:03,590 --> 00:23:07,220
clever enough to bootstrap those files

00:23:05,510 --> 00:23:09,559
and to figure out which plugins it needs

00:23:07,220 --> 00:23:11,240
and as you can see it has figured out

00:23:09,559 --> 00:23:13,010
that it needs the AWS plugin the

00:23:11,240 --> 00:23:14,750
provider it will fetch that from its

00:23:13,010 --> 00:23:17,690
repository and it will say hey I have

00:23:14,750 --> 00:23:18,400
provider AWS here version 1.8 I'm ready

00:23:17,690 --> 00:23:20,990
to rock and roll

00:23:18,400 --> 00:23:22,850
you run the planning part and then you

00:23:20,990 --> 00:23:25,460
could already imagine what is going to

00:23:22,850 --> 00:23:28,520
happen and it will you state for that it

00:23:25,460 --> 00:23:30,890
will use remote the remote state that is

00:23:28,520 --> 00:23:33,020
out there so will synchronize with the

00:23:30,890 --> 00:23:34,880
platform see if anything that we've

00:23:33,020 --> 00:23:37,309
defined is already there and it will use

00:23:34,880 --> 00:23:39,049
our data set here to figure out what the

00:23:37,309 --> 00:23:41,059
zone is and then it will show you what

00:23:39,049 --> 00:23:42,500
it needs to do and in this case there's

00:23:41,059 --> 00:23:44,690
only creation part because we had

00:23:42,500 --> 00:23:46,220
nothing there it will install an web

00:23:44,690 --> 00:23:48,710
instance and it will display the

00:23:46,220 --> 00:23:50,900
information that already has the ami the

00:23:48,710 --> 00:23:53,179
fact that we want a single blog device

00:23:50,900 --> 00:23:55,669
we have a security group called web we

00:23:53,179 --> 00:23:57,650
have an attack called web and we have a

00:23:55,669 --> 00:24:00,110
DNS record that needs to be created all

00:23:57,650 --> 00:24:02,120
the rest says compute it and will be

00:24:00,110 --> 00:24:03,770
filled up in the local state we have in

00:24:02,120 --> 00:24:05,480
our directory because state will be

00:24:03,770 --> 00:24:08,270
created and that will be filled up later

00:24:05,480 --> 00:24:09,710
on based on what the API returns once

00:24:08,270 --> 00:24:12,169
you're comfortable doing that you run

00:24:09,710 --> 00:24:14,330
terraform apply and it will create the

00:24:12,169 --> 00:24:15,679
records it will create the server it

00:24:14,330 --> 00:24:17,990
will link the one and the other one

00:24:15,679 --> 00:24:20,270
together what I would also advise you to

00:24:17,990 --> 00:24:22,070
do is if you want to be consistent in

00:24:20,270 --> 00:24:24,080
your state once you do the plan you can

00:24:22,070 --> 00:24:25,460
output the plan to a binary file to bla

00:24:24,080 --> 00:24:26,780
and it will contain your provider

00:24:25,460 --> 00:24:29,390
information your authentication

00:24:26,780 --> 00:24:31,280
information and the entire state that it

00:24:29,390 --> 00:24:32,350
needs to execute and if you do terraform

00:24:31,280 --> 00:24:34,360
apply bla it will

00:24:32,350 --> 00:24:36,340
use just that and again I have a video

00:24:34,360 --> 00:24:38,590
for you explaining how that works how

00:24:36,340 --> 00:24:42,400
you could leverage that again heavily

00:24:38,590 --> 00:24:44,799
sped up we apply it it will create

00:24:42,400 --> 00:24:46,929
everything most of it is computed the

00:24:44,799 --> 00:24:49,059
instance is created recreating a DNS

00:24:46,929 --> 00:24:51,610
records based on that IP address that

00:24:49,059 --> 00:24:53,200
we've got and it just created two

00:24:51,610 --> 00:24:55,000
resources it didn't have to change

00:24:53,200 --> 00:24:56,559
anything it did not have to destroy

00:24:55,000 --> 00:24:59,140
anything and the outputs that are

00:24:56,559 --> 00:25:00,940
registered our host name and the IP that

00:24:59,140 --> 00:25:02,890
is associated with that all of this

00:25:00,940 --> 00:25:05,740
information will be stored in the local

00:25:02,890 --> 00:25:08,110
state even my host name and my public IP

00:25:05,740 --> 00:25:10,419
and if I run terraform output it will

00:25:08,110 --> 00:25:12,520
output those stuff from state so you

00:25:10,419 --> 00:25:14,409
could retrieve it or if you want to use

00:25:12,520 --> 00:25:17,080
that in an automation script you can

00:25:14,409 --> 00:25:18,760
JSON it and it will send it in JSON

00:25:17,080 --> 00:25:20,980
format you can register certain

00:25:18,760 --> 00:25:23,289
variables outputs or input variables as

00:25:20,980 --> 00:25:24,909
sensitive if there are sensitive they

00:25:23,289 --> 00:25:26,799
won't be displayed they'll be used

00:25:24,909 --> 00:25:28,780
internally but to be encrypted in a way

00:25:26,799 --> 00:25:30,429
and if we do terraform show we can

00:25:28,780 --> 00:25:32,710
actually retrieve the state that was

00:25:30,429 --> 00:25:35,590
computed so you run terraform show and

00:25:32,710 --> 00:25:37,960
all these parameters that were supposed

00:25:35,590 --> 00:25:40,860
to be computed are now readable visible

00:25:37,960 --> 00:25:44,470
ready to use and there's tons of them

00:25:40,860 --> 00:25:48,940
too much to care about but our outputs

00:25:44,470 --> 00:25:51,070
are also registered now I were 25

00:25:48,940 --> 00:25:52,840
minutes into this presentation I've

00:25:51,070 --> 00:25:55,299
mentioned the word state quite a lot and

00:25:52,840 --> 00:25:57,400
I need to explain how that works in

00:25:55,299 --> 00:25:59,400
terraform and how why state is so

00:25:57,400 --> 00:26:03,010
important and why this is a very

00:25:59,400 --> 00:26:05,200
colorful feature terraform is the binary

00:26:03,010 --> 00:26:07,240
it reads your files there's a state

00:26:05,200 --> 00:26:09,070
back-end and there's a cloud api it

00:26:07,240 --> 00:26:10,690
synchronizes it with if there's nothing

00:26:09,070 --> 00:26:13,600
there it will fetch it all from the

00:26:10,690 --> 00:26:15,970
cloud api stored in state if it sees

00:26:13,600 --> 00:26:17,830
changes to your TF files it will

00:26:15,970 --> 00:26:19,750
calculate what it already knows and

00:26:17,830 --> 00:26:22,299
synchronize it with what is out there

00:26:19,750 --> 00:26:24,580
and by default state is just a set of

00:26:22,299 --> 00:26:26,860
files these two files a TF state file

00:26:24,580 --> 00:26:29,320
and a backup of that file and in essence

00:26:26,860 --> 00:26:30,669
those files are just JSON files nothing

00:26:29,320 --> 00:26:32,409
more to it you could open them up and

00:26:30,669 --> 00:26:34,780
you'll see all this information in JSON

00:26:32,409 --> 00:26:36,250
files now there's also and I would

00:26:34,780 --> 00:26:37,750
advise you to use that when you run it

00:26:36,250 --> 00:26:41,169
in the production environment to use

00:26:37,750 --> 00:26:42,909
remote state because the state on local

00:26:41,169 --> 00:26:44,950
files it's not synchronized right if you

00:26:42,909 --> 00:26:46,000
work in teams and both of you run the

00:26:44,950 --> 00:26:47,770
script there's no

00:26:46,000 --> 00:26:50,020
way to update the state and you'll

00:26:47,770 --> 00:26:52,540
probably have clashes and locking issues

00:26:50,020 --> 00:26:54,400
things that go wrong when two people

00:26:52,540 --> 00:26:56,620
from the same team maybe at different

00:26:54,400 --> 00:26:58,420
computers who run the same script so you

00:26:56,620 --> 00:27:00,970
have ways to synchronize your state in

00:26:58,420 --> 00:27:02,920
the clouds you can use console or IDE CD

00:27:00,970 --> 00:27:05,350
or GCS you have a bunch of tools

00:27:02,920 --> 00:27:07,090
throughout and that will be near the end

00:27:05,350 --> 00:27:08,950
of the presentation I will use console

00:27:07,090 --> 00:27:11,530
to prove my point and show you how

00:27:08,950 --> 00:27:13,450
useful that remote state is but for now

00:27:11,530 --> 00:27:15,430
let's stick with it and one of the

00:27:13,450 --> 00:27:17,290
consequences of state is if you don't

00:27:15,430 --> 00:27:19,510
apply a high availability plan things

00:27:17,290 --> 00:27:22,180
will go wrong on you this is a terraform

00:27:19,510 --> 00:27:23,860
plan where I'm injecting another custom

00:27:22,180 --> 00:27:26,320
ami this is an example how you pass on

00:27:23,860 --> 00:27:28,750
variables to to terraform I say - VAR

00:27:26,320 --> 00:27:30,160
AMI is that ami now that one is

00:27:28,750 --> 00:27:32,230
different so when I do the planning

00:27:30,160 --> 00:27:34,060
stage there's two things happening

00:27:32,230 --> 00:27:36,310
terraform will try to figure out what it

00:27:34,060 --> 00:27:38,440
needs to do and it will know which API

00:27:36,310 --> 00:27:39,970
calls all available so you see a tilde

00:27:38,440 --> 00:27:43,420
update in place that means there's

00:27:39,970 --> 00:27:44,680
probably a patch or a put call at the

00:27:43,420 --> 00:27:46,720
Amazon site to do it in line without

00:27:44,680 --> 00:27:49,930
having to recreate something but since

00:27:46,720 --> 00:27:52,120
we have changed our AMI and since an AMI

00:27:49,930 --> 00:27:53,500
and the instance that it's running it's

00:27:52,120 --> 00:27:55,930
one and the same you can't just change

00:27:53,500 --> 00:27:57,160
the ami to change the virtual image on a

00:27:55,930 --> 00:27:58,810
machine because that's basically what

00:27:57,160 --> 00:28:00,130
the machine is terraform is clever

00:27:58,810 --> 00:28:02,020
enough to figure out that it first needs

00:28:00,130 --> 00:28:04,060
to destroy the running instance and then

00:28:02,020 --> 00:28:05,890
recreate it in order to get to that

00:28:04,060 --> 00:28:09,550
desired State you see the changes there

00:28:05,890 --> 00:28:12,060
am i evil 1e2 - Oh see that's that's an

00:28:09,550 --> 00:28:14,440
entirely different machine now luckily

00:28:12,060 --> 00:28:16,330
updating the DNS records doesn't require

00:28:14,440 --> 00:28:19,060
us to delete it it could be done you see

00:28:16,330 --> 00:28:21,790
the tilde here in place when you do the

00:28:19,060 --> 00:28:24,250
apply of that you'll have a problem

00:28:21,790 --> 00:28:26,020
because it will be gone it'll say oh

00:28:24,250 --> 00:28:27,310
yeah you want me to change that let me

00:28:26,020 --> 00:28:29,200
delete that instance for you and we'll

00:28:27,310 --> 00:28:31,780
delete it and it will boot it back up

00:28:29,200 --> 00:28:33,670
but since this is just a stupid DNS

00:28:31,780 --> 00:28:36,190
record it will probably be some negative

00:28:33,670 --> 00:28:38,230
caching and you'll have downtime of ten

00:28:36,190 --> 00:28:40,540
minutes and it will be gone and that's

00:28:38,230 --> 00:28:41,890
not something you want so let's make it

00:28:40,540 --> 00:28:43,690
a bit more intricate a bit more

00:28:41,890 --> 00:28:45,550
interesting and let's start adding a

00:28:43,690 --> 00:28:47,920
high availability plan and the tool

00:28:45,550 --> 00:28:49,600
we'll be using within terraform is the

00:28:47,920 --> 00:28:52,480
concept of workspaces having different

00:28:49,600 --> 00:28:54,130
workspaces every workspace so you'll

00:28:52,480 --> 00:28:56,320
have a single terraform project with

00:28:54,130 --> 00:28:59,890
multiple workspaces and every workspace

00:28:56,320 --> 00:29:01,720
has its own state so if you

00:28:59,890 --> 00:29:03,460
run something if you run a plan you

00:29:01,720 --> 00:29:06,000
change the workspace you're on the plan

00:29:03,460 --> 00:29:09,310
again it won't try to delete or update

00:29:06,000 --> 00:29:11,080
anything we'll just fire up an entirely

00:29:09,310 --> 00:29:14,500
new stack of infrastructure which is

00:29:11,080 --> 00:29:16,180
great for Bluegreen deployments now in

00:29:14,500 --> 00:29:18,100
the blue grain green state of mind

00:29:16,180 --> 00:29:19,900
you'll have that entry point and the

00:29:18,100 --> 00:29:21,940
entry point could be a load balancer it

00:29:19,900 --> 00:29:23,770
could be a DNS record it could be an IP

00:29:21,940 --> 00:29:25,600
address and elastic IP address that is

00:29:23,770 --> 00:29:27,250
relinked well you're probably gonna

00:29:25,600 --> 00:29:28,930
start with a single workspace in which

00:29:27,250 --> 00:29:31,030
you're gonna fire up a set of

00:29:28,930 --> 00:29:32,650
infrastructure and then the next piece

00:29:31,030 --> 00:29:34,270
the next part you want to have that new

00:29:32,650 --> 00:29:36,280
deployment ready but you don't want to

00:29:34,270 --> 00:29:38,290
update this you want to stack it up next

00:29:36,280 --> 00:29:39,880
to it do some validation of some sorts

00:29:38,290 --> 00:29:42,430
and then when you're ready you'll switch

00:29:39,880 --> 00:29:43,990
it in a sort of atomic way and you could

00:29:42,430 --> 00:29:45,220
do that in a secondary workspace and

00:29:43,990 --> 00:29:47,260
here are the commands to do so

00:29:45,220 --> 00:29:49,150
so you initialize your terraform project

00:29:47,260 --> 00:29:50,710
you create a new workspace let's say

00:29:49,150 --> 00:29:52,690
it's called workspace 1 you create a

00:29:50,710 --> 00:29:54,910
second one you select the first one you

00:29:52,690 --> 00:29:57,400
plan on apply it will boot up your

00:29:54,910 --> 00:30:00,820
infrastructure and then you could do a

00:29:57,400 --> 00:30:03,550
secondary one change some files change

00:30:00,820 --> 00:30:06,430
some state plan and apply it again and

00:30:03,550 --> 00:30:08,770
you're ready to go and in terms of the

00:30:06,430 --> 00:30:10,930
file system if you lose local state it

00:30:08,770 --> 00:30:12,910
will create a TF state defaulter and a

00:30:10,930 --> 00:30:14,680
half state per workspace and then you

00:30:12,910 --> 00:30:16,930
could switch and run it separately and

00:30:14,680 --> 00:30:19,390
do changes it would be interesting to

00:30:16,930 --> 00:30:22,210
name those workspaces according to your

00:30:19,390 --> 00:30:25,780
pipeline maybe test staging production

00:30:22,210 --> 00:30:27,940
acceptance so on and so forth and the

00:30:25,780 --> 00:30:29,350
good thing is that there's also a

00:30:27,940 --> 00:30:31,300
workspace variable within the

00:30:29,350 --> 00:30:33,550
terraformed a space that will allow you

00:30:31,300 --> 00:30:35,770
to maybe interpolate that data into the

00:30:33,550 --> 00:30:38,080
name of your instance let's say you have

00:30:35,770 --> 00:30:40,450
this very same file and we update a name

00:30:38,080 --> 00:30:41,920
tag and inject the workspace in it if

00:30:40,450 --> 00:30:43,600
it's in a single account and you have

00:30:41,920 --> 00:30:44,920
two workspaces you won't see the

00:30:43,600 --> 00:30:47,560
difference between them it would be

00:30:44,920 --> 00:30:49,660
called phase 4 in web about staging and

00:30:47,560 --> 00:30:51,040
production or deployment one deployment

00:30:49,660 --> 00:30:52,810
to you there's no way to see the

00:30:51,040 --> 00:30:54,610
difference but if you use the workspaces

00:30:52,810 --> 00:30:57,850
and inject it there you'll clearly see

00:30:54,610 --> 00:30:59,380
what is 1 what we also have done in this

00:30:57,850 --> 00:31:01,210
is you don't see the DNS part anymore

00:30:59,380 --> 00:31:03,670
because we've pulled the DNS part out

00:31:01,210 --> 00:31:04,930
because that's let me go back that's the

00:31:03,670 --> 00:31:06,670
atomic switch that needs to happen in

00:31:04,930 --> 00:31:08,110
the end that's a secondary stage that's

00:31:06,670 --> 00:31:09,640
the second terraform project will

00:31:08,110 --> 00:31:11,890
execute because first we have the

00:31:09,640 --> 00:31:13,210
existing information we'll bootstrap the

00:31:11,890 --> 00:31:15,010
second one and that will be a set

00:31:13,210 --> 00:31:16,750
at endpoint a separate validation

00:31:15,010 --> 00:31:18,640
process and once we know that works then

00:31:16,750 --> 00:31:22,390
we want to do the switch and that means

00:31:18,640 --> 00:31:23,830
that then we want VNS to be executed and

00:31:22,390 --> 00:31:26,680
what we'll do here is create a variable

00:31:23,830 --> 00:31:28,210
IP a separate DNS project and inject it

00:31:26,680 --> 00:31:30,280
in the record so once we're done we run

00:31:28,210 --> 00:31:32,470
that secondary terraform project to

00:31:30,280 --> 00:31:36,780
terraform reply pass along the right

00:31:32,470 --> 00:31:38,710
variable like this and get it done just

00:31:36,780 --> 00:31:40,360
for the fun of it

00:31:38,710 --> 00:31:43,300
we're gonna use the NS round-robin don't

00:31:40,360 --> 00:31:46,480
use this as a definitive high

00:31:43,300 --> 00:31:48,430
availability plan but it could work so

00:31:46,480 --> 00:31:50,200
what I want to prove here it's not that

00:31:48,430 --> 00:31:52,660
DNS round-robin is a good idea but that

00:31:50,200 --> 00:31:54,340
you can use multiple instances and that

00:31:52,660 --> 00:31:56,500
you can link those so what we're doing

00:31:54,340 --> 00:31:58,720
here is implementing account very

00:31:56,500 --> 00:32:01,330
account property that says of that

00:31:58,720 --> 00:32:04,060
instance create two or three or five or

00:32:01,330 --> 00:32:06,010
ten and the default is to we can extend

00:32:04,060 --> 00:32:08,020
that via a command line argument or a

00:32:06,010 --> 00:32:10,660
variables file and then we interpolate

00:32:08,020 --> 00:32:12,700
the name again web and then we format it

00:32:10,660 --> 00:32:14,860
counter plus one so that will be web one

00:32:12,700 --> 00:32:17,470
web to web three web four and we'll also

00:32:14,860 --> 00:32:19,150
assign the work space to it and then the

00:32:17,470 --> 00:32:23,170
output the public IP is no longer a

00:32:19,150 --> 00:32:25,120
single IP but is instance web asterisk

00:32:23,170 --> 00:32:27,370
so all the web servers and grab their

00:32:25,120 --> 00:32:30,970
public IP and that will be a list and

00:32:27,370 --> 00:32:33,070
the only thing to do in our next stage

00:32:30,970 --> 00:32:34,690
to keep it a bit secure is to enforce it

00:32:33,070 --> 00:32:36,790
that the input is also of the type list

00:32:34,690 --> 00:32:39,910
that way you can't really pass a single

00:32:36,790 --> 00:32:41,950
IP and records is also a list so that

00:32:39,910 --> 00:32:44,650
doesn't need changing so when you apply

00:32:41,950 --> 00:32:46,480
that you apply a list multiple IP

00:32:44,650 --> 00:32:47,920
addresses and this is just showboating

00:32:46,480 --> 00:32:50,470
this is just me showing you that you can

00:32:47,920 --> 00:32:52,150
fork off and bootstrap multiple

00:32:50,470 --> 00:32:55,540
instances in a single resource of

00:32:52,150 --> 00:32:57,310
definition that was blue green maybe we

00:32:55,540 --> 00:32:59,710
should focus on rolling deployments and

00:32:57,310 --> 00:33:02,230
make it a lot more complicated so

00:32:59,710 --> 00:33:04,960
instead of switching that entry point

00:33:02,230 --> 00:33:07,870
atomically why not and this is very much

00:33:04,960 --> 00:33:10,870
a recap of Mike's presentation about AWS

00:33:07,870 --> 00:33:12,400
this morning we will will have an auto

00:33:10,870 --> 00:33:13,810
scaling group within that auto scaling

00:33:12,400 --> 00:33:16,360
group there's a launch configuration

00:33:13,810 --> 00:33:17,920
that defines what kind of ec2 instances

00:33:16,360 --> 00:33:20,260
what kind of machines we want and it's

00:33:17,920 --> 00:33:21,940
just dynamically adds them so when we do

00:33:20,260 --> 00:33:23,500
a new deployment we'll update that

00:33:21,940 --> 00:33:25,390
launch configuration will create a new

00:33:23,500 --> 00:33:27,070
launch configuration and terraform will

00:33:25,390 --> 00:33:29,230
be clever enough to notify the able

00:33:27,070 --> 00:33:31,600
scaling group and say hey relink this

00:33:29,230 --> 00:33:33,789
new launch configuration and then

00:33:31,600 --> 00:33:35,889
gradually these new machines will boot

00:33:33,789 --> 00:33:38,200
up and the auto scaling group will be

00:33:35,889 --> 00:33:40,059
clever enough to drain information drain

00:33:38,200 --> 00:33:41,889
connections from our previous deployment

00:33:40,059 --> 00:33:44,200
and gradually used in new ones and that

00:33:41,889 --> 00:33:46,990
is a combination of using a load

00:33:44,200 --> 00:33:48,639
balancer and an auto scaling group so

00:33:46,990 --> 00:33:51,070
the auto scaling group is just one of

00:33:48,639 --> 00:33:54,539
the tools I used and I have a poor-man's

00:33:51,070 --> 00:33:58,299
video right here this is just me

00:33:54,539 --> 00:34:00,190
designing really poorly designed it

00:33:58,299 --> 00:34:01,269
schematics but the goal is to show you

00:34:00,190 --> 00:34:03,519
that there's lots of information there

00:34:01,269 --> 00:34:06,279
so we start off let me walk this way

00:34:03,519 --> 00:34:08,980
with a VP see a virtual private cloud is

00:34:06,279 --> 00:34:12,399
that the rides abbreviation in PPC I'm

00:34:08,980 --> 00:34:15,250
not an Amazon certified engineer so lots

00:34:12,399 --> 00:34:18,460
of acronyms here VPC is just our own

00:34:15,250 --> 00:34:21,490
little private environment that had its

00:34:18,460 --> 00:34:24,280
own CIDR so its own IP space we assign a

00:34:21,490 --> 00:34:25,540
set of networks to it to public subnets

00:34:24,280 --> 00:34:27,909
which are hosted in two different data

00:34:25,540 --> 00:34:29,589
centers to private subnets also hosted

00:34:27,909 --> 00:34:30,970
in those two different data centers we

00:34:29,589 --> 00:34:32,800
have an application load balancer

00:34:30,970 --> 00:34:34,599
attached to it an application load

00:34:32,800 --> 00:34:38,819
balancer has targets these targets are

00:34:34,599 --> 00:34:41,319
VMs that it distributes it to these are

00:34:38,819 --> 00:34:43,210
thrown out by the auto scaling group it

00:34:41,319 --> 00:34:46,960
uses a launch configuration we have a

00:34:43,210 --> 00:34:48,879
custom ami we have some cloud cloud

00:34:46,960 --> 00:34:50,800
watch metrics to figure out do we need

00:34:48,879 --> 00:34:53,530
more capacity we need less capacity just

00:34:50,800 --> 00:34:55,270
a lot of work I won't show all the

00:34:53,530 --> 00:34:56,560
details maybe I could publish this on

00:34:55,270 --> 00:34:58,180
github later and distribute it to

00:34:56,560 --> 00:35:00,940
Twitter so you'll have a reason to

00:34:58,180 --> 00:35:02,530
follow me on Twitter but I'll show you

00:35:00,940 --> 00:35:04,060
bits and pieces of the configuration

00:35:02,530 --> 00:35:06,520
just to show you how much you could do

00:35:04,060 --> 00:35:09,579
with terraform so this is our V PC and

00:35:06,520 --> 00:35:13,119
it has the subnet or the the CIDR of

00:35:09,579 --> 00:35:15,220
10000 6/16 and we give it a name and

00:35:13,119 --> 00:35:17,560
then we have a subnet that depends on

00:35:15,220 --> 00:35:19,780
that V PC and that defines another piece

00:35:17,560 --> 00:35:22,930
of subnet information which is hosted in

00:35:19,780 --> 00:35:24,970
EU West 2a so it's in data center to a

00:35:22,930 --> 00:35:26,770
this is also in data center to a and

00:35:24,970 --> 00:35:29,079
that's a private IP space and then we'll

00:35:26,770 --> 00:35:31,420
have probably public IP to that is into

00:35:29,079 --> 00:35:33,040
B and private IP to an ends to B and we

00:35:31,420 --> 00:35:35,890
have some firewalling information that

00:35:33,040 --> 00:35:37,300
they opens up 80 and 443 and 22 and so

00:35:35,890 --> 00:35:37,960
on and so forth and we have our custom

00:35:37,300 --> 00:35:39,890
ami

00:35:37,960 --> 00:35:42,110
now what's a novelty here is that

00:35:39,890 --> 00:35:43,940
using a data source to retrieve BMI in

00:35:42,110 --> 00:35:46,070
my previous example this was just

00:35:43,940 --> 00:35:48,530
injected by a variable something I

00:35:46,070 --> 00:35:51,170
pushed in but what I'm doing now is I'm

00:35:48,530 --> 00:35:54,470
looking for a.m. eyes that are owned by

00:35:51,170 --> 00:35:56,540
user a 2 6 4 8 that's my own user and we

00:35:54,470 --> 00:35:58,670
apply a set of filters it needs h vm

00:35:56,540 --> 00:36:00,110
virtualization as a type and it needs to

00:35:58,670 --> 00:36:02,600
start with days for the underscore

00:36:00,110 --> 00:36:05,330
asterisk and we will take the most

00:36:02,600 --> 00:36:07,460
recent one so every time we push a new

00:36:05,330 --> 00:36:09,320
one via Packer and we run terraform plan

00:36:07,460 --> 00:36:11,120
it will have figured out that there's a

00:36:09,320 --> 00:36:12,530
new version of the ami and it will

00:36:11,120 --> 00:36:14,480
figure out what needs to happen so it

00:36:12,530 --> 00:36:15,920
will create a new launch configuration

00:36:14,480 --> 00:36:18,410
it will update our auto scaling group

00:36:15,920 --> 00:36:21,140
this is our launch configuration it uses

00:36:18,410 --> 00:36:23,480
data AWS ami Tastefully an underscore

00:36:21,140 --> 00:36:26,960
terraformed op ID so it takes ma the ID

00:36:23,480 --> 00:36:30,680
of my latest image it pushes it in there

00:36:26,960 --> 00:36:32,690
it uses these these security groups have

00:36:30,680 --> 00:36:34,640
a load balancer that is also in that

00:36:32,690 --> 00:36:37,190
subnet a listener that listens on port

00:36:34,640 --> 00:36:39,020
80 a target group that also listens on

00:36:37,190 --> 00:36:41,330
port 80 that communicates with a load

00:36:39,020 --> 00:36:42,920
balancer lots of information right lots

00:36:41,330 --> 00:36:44,990
of stuff passing the goal is not to

00:36:42,920 --> 00:36:46,580
teach you how to do this there's plenty

00:36:44,990 --> 00:36:48,140
of resources online about this I just

00:36:46,580 --> 00:36:50,300
want to show you that there's lots of

00:36:48,140 --> 00:36:51,980
moving parts lots of components that you

00:36:50,300 --> 00:36:54,650
can orchestrate and eventually I'll get

00:36:51,980 --> 00:36:56,360
to my point this is the build up we have

00:36:54,650 --> 00:36:58,760
an auto scaling group it has a minimum

00:36:56,360 --> 00:37:00,530
size of three servers and at the maximum

00:36:58,760 --> 00:37:02,660
if it needs the capacity it will have 10

00:37:00,530 --> 00:37:04,460
it uses a launch configuration that I

00:37:02,660 --> 00:37:06,740
previously defined that depended on that

00:37:04,460 --> 00:37:08,780
data source that has my custom am I in

00:37:06,740 --> 00:37:11,900
it it will troll all these instances

00:37:08,780 --> 00:37:14,360
once it Forks it off it boots them up it

00:37:11,900 --> 00:37:16,490
will put them in the target group and it

00:37:14,360 --> 00:37:18,650
will have some more information here

00:37:16,490 --> 00:37:21,230
we're using policies to increase our

00:37:18,650 --> 00:37:24,140
decrease our capacity from our scaling

00:37:21,230 --> 00:37:26,780
group we have a cloud watch metric and

00:37:24,140 --> 00:37:29,120
alarm a high watermark so to speak it

00:37:26,780 --> 00:37:31,490
uses name spacing it uses the AWS

00:37:29,120 --> 00:37:33,260
application ELB namespace so what we're

00:37:31,490 --> 00:37:35,150
doing is we're using metrics that Amazon

00:37:33,260 --> 00:37:37,040
collects from the different components

00:37:35,150 --> 00:37:39,500
and in this case we'll look at the load

00:37:37,040 --> 00:37:41,480
balancer and if the load balancer a

00:37:39,500 --> 00:37:43,310
specific metrics of that the request

00:37:41,480 --> 00:37:45,080
count per target so if you look at the

00:37:43,310 --> 00:37:47,060
load balancer positioned here with all

00:37:45,080 --> 00:37:50,150
your servers there if the amount of

00:37:47,060 --> 00:37:52,370
connections per target per server is 20

00:37:50,150 --> 00:37:53,660
or more within a period an interval of

00:37:52,370 --> 00:37:55,549
60 seconds

00:37:53,660 --> 00:37:56,900
for my test case this is considered the

00:37:55,549 --> 00:37:59,420
high loads we need to trigger more

00:37:56,900 --> 00:38:02,359
servers so we'll use that it will have

00:37:59,420 --> 00:38:04,099
more servers and we do terraform plan

00:38:02,359 --> 00:38:06,049
tariffs or to apply it and all that

00:38:04,099 --> 00:38:08,510
stuff happens and it dynamically deploys

00:38:06,049 --> 00:38:10,970
our new instances if there's if you run

00:38:08,510 --> 00:38:13,099
it again and a new ami was registered

00:38:10,970 --> 00:38:14,569
via our Packer build it will figure it

00:38:13,099 --> 00:38:16,099
out it will create a new launch

00:38:14,569 --> 00:38:17,390
configuration it will update the auto

00:38:16,099 --> 00:38:19,549
scaling group the auto scaling group

00:38:17,390 --> 00:38:20,900
will automatically deploy the new images

00:38:19,549 --> 00:38:23,030
all the ones will be drained all the

00:38:20,900 --> 00:38:24,410
ones will be removed and I could show

00:38:23,030 --> 00:38:26,390
this in a graphical format you could

00:38:24,410 --> 00:38:28,730
just do terraform graph send it to your

00:38:26,390 --> 00:38:34,280
dub binary save it as a PNG and that

00:38:28,730 --> 00:38:36,020
will be it simple right very simple so

00:38:34,280 --> 00:38:38,240
what the point is that I'm trying to

00:38:36,020 --> 00:38:39,950
make is not that terraform is enormously

00:38:38,240 --> 00:38:41,900
powerful and it abstracts lots of the

00:38:39,950 --> 00:38:44,480
complexities because I don't have that

00:38:41,900 --> 00:38:46,609
much AWS experience but by using

00:38:44,480 --> 00:38:49,250
terraform it was very easy to learn how

00:38:46,609 --> 00:38:51,170
it worked but what I will advise you is

00:38:49,250 --> 00:38:53,690
to store it all organize it nicely

00:38:51,170 --> 00:38:56,000
according to its role in separate files

00:38:53,690 --> 00:38:58,430
to keep it simple to keep it readable

00:38:56,000 --> 00:39:00,079
because all that it looks like JSON it's

00:38:58,430 --> 00:39:02,510
not really JSON that all that formatting

00:39:00,079 --> 00:39:04,549
it'll it'll get tedious little bit

00:39:02,510 --> 00:39:05,990
confusing so you want to store your

00:39:04,549 --> 00:39:07,730
provider information there I

00:39:05,990 --> 00:39:10,609
deliberately didn't show you provider

00:39:07,730 --> 00:39:13,700
information because I didn't register my

00:39:10,609 --> 00:39:15,319
my keys or all private information for

00:39:13,700 --> 00:39:17,539
OpenStack or ailable yes I didn't

00:39:15,319 --> 00:39:18,890
register that because I used environment

00:39:17,539 --> 00:39:20,930
variables that were set but you can also

00:39:18,890 --> 00:39:22,640
have a provider construct in which you

00:39:20,930 --> 00:39:24,200
say what the endpoint is where you're

00:39:22,640 --> 00:39:25,940
going to connect and what your access

00:39:24,200 --> 00:39:27,470
key is and your secret key you could

00:39:25,940 --> 00:39:29,510
store that here network information

00:39:27,470 --> 00:39:31,670
computation information may be as as H

00:39:29,510 --> 00:39:33,079
key pair security groups your outputs

00:39:31,670 --> 00:39:35,150
your variables you could store that all

00:39:33,079 --> 00:39:37,549
separately that's a good way of doing it

00:39:35,150 --> 00:39:39,349
but there's even a better way and that's

00:39:37,549 --> 00:39:43,400
by using modules and this is where it

00:39:39,349 --> 00:39:45,619
gets really interesting instead of

00:39:43,400 --> 00:39:48,920
throwing at all in separate files like a

00:39:45,619 --> 00:39:52,010
networking dot EF key parity F you can

00:39:48,920 --> 00:39:54,619
create folders per role like you'll have

00:39:52,010 --> 00:39:56,660
an auto scaling folder and we'll have a

00:39:54,619 --> 00:39:59,690
DNS folder and a launch folder and in

00:39:56,660 --> 00:40:01,789
that you'll have a sort of convention

00:39:59,690 --> 00:40:04,190
the naming convention with a readme file

00:40:01,789 --> 00:40:06,470
a main dot EF that contains your main

00:40:04,190 --> 00:40:07,580
logic and outputs RTF that generates

00:40:06,470 --> 00:40:09,980
outputs

00:40:07,580 --> 00:40:12,680
and variables 30f now the clever part

00:40:09,980 --> 00:40:14,660
about these things our variables contain

00:40:12,680 --> 00:40:17,030
the input outputs are expected to print

00:40:14,660 --> 00:40:19,400
stuff on on screen but if you work from

00:40:17,030 --> 00:40:20,869
it from a modular point of view outputs

00:40:19,400 --> 00:40:22,160
are just like function recurrence it's

00:40:20,869 --> 00:40:24,470
just a way to interact with your main

00:40:22,160 --> 00:40:26,510
logic because in the end all of these

00:40:24,470 --> 00:40:29,390
modules will be bootstrap by your main

00:40:26,510 --> 00:40:32,900
terraform file so outputs are just like

00:40:29,390 --> 00:40:34,520
return true or return bla essentially

00:40:32,900 --> 00:40:37,700
does that and variables are our function

00:40:34,520 --> 00:40:40,490
inputs let's let's take it apart let's

00:40:37,700 --> 00:40:41,869
take our DNS module for example this is

00:40:40,490 --> 00:40:44,180
just boilerplate right don't use this

00:40:41,869 --> 00:40:45,470
and use any of this I'm doing this to

00:40:44,180 --> 00:40:47,390
show you how it works you know our

00:40:45,470 --> 00:40:49,550
previous construction for that DNS

00:40:47,390 --> 00:40:51,560
record well what you could do is define

00:40:49,550 --> 00:40:54,080
a variable called zone name and preset

00:40:51,560 --> 00:40:55,640
it so this now works for AWS dot-com

00:40:54,080 --> 00:40:58,580
Balcom do you want to do it for your own

00:40:55,640 --> 00:41:01,010
zone well then set it in your main file

00:40:58,580 --> 00:41:03,710
later on this is a an input you have

00:41:01,010 --> 00:41:05,720
your record name which is empty we have

00:41:03,710 --> 00:41:07,820
a variable records which is a list and

00:41:05,720 --> 00:41:10,940
has no default value so it's required to

00:41:07,820 --> 00:41:14,450
be extended when we invoke it we have

00:41:10,940 --> 00:41:15,830
our route 53 zone which is our data

00:41:14,450 --> 00:41:17,450
source and then we'll have some

00:41:15,830 --> 00:41:19,550
information about the record some

00:41:17,450 --> 00:41:21,770
interpolation and in the end we'll

00:41:19,550 --> 00:41:24,680
return the DNS endpoint the frequently

00:41:21,770 --> 00:41:27,350
the fully qualified domain name fqdn of

00:41:24,680 --> 00:41:30,340
that record that we created and we'll

00:41:27,350 --> 00:41:34,040
return that and how do we invoke it

00:41:30,340 --> 00:41:35,359
pretty simple we have a module DNS we

00:41:34,040 --> 00:41:37,340
mentioned the folder where it is located

00:41:35,359 --> 00:41:41,869
and we extend the variables that we want

00:41:37,340 --> 00:41:44,720
to extend so I left a record name empty

00:41:41,869 --> 00:41:47,750
so it would be the main zone what we're

00:41:44,720 --> 00:41:50,420
doing here is creating a WW record it

00:41:47,750 --> 00:41:52,220
was a cname record not an a record what

00:41:50,420 --> 00:41:54,140
is the record you want to connect it to

00:41:52,220 --> 00:41:57,170
to blob domain.com

00:41:54,140 --> 00:41:58,609
and you could output it to screen and

00:41:57,170 --> 00:42:02,210
the cool thing about the interpolation

00:41:58,609 --> 00:42:04,430
is you don't go to the native DNS record

00:42:02,210 --> 00:42:07,450
you say module DNS which is that one

00:42:04,430 --> 00:42:09,980
take the DNS endpoint and DNS endpoint

00:42:07,450 --> 00:42:13,280
wasn't output I registered so it's just

00:42:09,980 --> 00:42:15,260
like a function or a method you you put

00:42:13,280 --> 00:42:16,700
input in there you return output and all

00:42:15,260 --> 00:42:19,970
the complexity of what happens behind

00:42:16,700 --> 00:42:21,230
the curtains is abstracted for you you

00:42:19,970 --> 00:42:24,290
can do it that way you have

00:42:21,230 --> 00:42:26,000
working part the networking exposes a VP

00:42:24,290 --> 00:42:28,340
see that VP see information you can use

00:42:26,000 --> 00:42:29,990
that in your load balancing or your

00:42:28,340 --> 00:42:31,880
security groups module networking

00:42:29,990 --> 00:42:33,800
security group ID and you can tie them

00:42:31,880 --> 00:42:37,010
all together and all these pages of

00:42:33,800 --> 00:42:40,850
logic are now compacted into a single

00:42:37,010 --> 00:42:42,230
script reasonably easy to work with this

00:42:40,850 --> 00:42:44,180
is just one way of doing it there's also

00:42:42,230 --> 00:42:46,280
a registry out there out in the open

00:42:44,180 --> 00:42:48,109
called registry terraformed up IO this

00:42:46,280 --> 00:42:49,730
is a screenshot of it and they have all

00:42:48,109 --> 00:42:52,040
kinds of use cases based on providers

00:42:49,730 --> 00:42:54,320
you'll find a lots of AWS stuff so that

00:42:52,040 --> 00:42:56,000
entire VPC thing maybe they have a

00:42:54,320 --> 00:42:57,320
better implementation I'm pretty sure

00:42:56,000 --> 00:42:59,300
they have a better implementation and

00:42:57,320 --> 00:43:02,570
you can use that and you can use that in

00:42:59,300 --> 00:43:04,550
several ways if you use their registry

00:43:02,570 --> 00:43:06,020
you can just use module console and you

00:43:04,550 --> 00:43:07,400
don't need that files on your those

00:43:06,020 --> 00:43:09,230
files on your disk you can just refer to

00:43:07,400 --> 00:43:12,109
the namespace Hoshi Corp and then

00:43:09,230 --> 00:43:14,359
console AWS you do terraformed up in it

00:43:12,109 --> 00:43:16,190
and it'll be clever enough to figure it

00:43:14,359 --> 00:43:17,840
out it will say I'm checking what we

00:43:16,190 --> 00:43:21,080
need so we have an empty directory just

00:43:17,840 --> 00:43:23,540
with that file so again that's the only

00:43:21,080 --> 00:43:24,859
thing that is in your main dot TF it'll

00:43:23,540 --> 00:43:27,050
be clever enough to figure out that it

00:43:24,859 --> 00:43:29,900
needs AWS providers and that it needs

00:43:27,050 --> 00:43:32,780
that plug-in and I'll just run it and

00:43:29,900 --> 00:43:35,540
you're done fairly simple and all the

00:43:32,780 --> 00:43:37,700
complexity is abstracted away it's not

00:43:35,540 --> 00:43:39,830
restricted to the FAC terraform registry

00:43:37,700 --> 00:43:42,890
you can have github repositories or bare

00:43:39,830 --> 00:43:44,510
just standard get repos and there's more

00:43:42,890 --> 00:43:46,640
you can have local files that are for

00:43:44,510 --> 00:43:49,190
registered github bitbucket generic git

00:43:46,640 --> 00:43:50,720
repos mercurial HTTP tree so there's

00:43:49,190 --> 00:43:52,280
plenty of ways to distribute and share

00:43:50,720 --> 00:43:56,060
these modules that you created and that

00:43:52,280 --> 00:43:58,880
you maintain and are reusable right

00:43:56,060 --> 00:44:00,560
still onboard let's go to the final part

00:43:58,880 --> 00:44:03,200
and one of the final parts that's remote

00:44:00,560 --> 00:44:05,560
state so problems I made to you that in

00:44:03,200 --> 00:44:07,640
the end we would talk about remote State

00:44:05,560 --> 00:44:10,130
let me get some of that water first

00:44:07,640 --> 00:44:13,210
before we continue maybe it's a good

00:44:10,130 --> 00:44:13,210
idea to pour some water for yourself

00:44:13,630 --> 00:44:18,619
alright apologies remote state is

00:44:17,060 --> 00:44:18,950
particularly interesting if you work in

00:44:18,619 --> 00:44:21,109
teams

00:44:18,950 --> 00:44:23,480
I explained the difficulties already if

00:44:21,109 --> 00:44:27,260
you have multiple people working on the

00:44:23,480 --> 00:44:29,690
same project you're not 100% sure when

00:44:27,260 --> 00:44:31,940
or what will be executed at what time if

00:44:29,690 --> 00:44:33,530
you use local state if you use the local

00:44:31,940 --> 00:44:34,580
disk and you execute a plan and someone

00:44:33,530 --> 00:44:36,170
else execute the plan

00:44:34,580 --> 00:44:38,540
there's no way to synchronize those

00:44:36,170 --> 00:44:40,430
files in in a standard way so you'll end

00:44:38,540 --> 00:44:42,410
up with a big mess and you can have risk

00:44:40,430 --> 00:44:44,510
downtime but if you have a centralized

00:44:42,410 --> 00:44:46,070
location to store your state remotely

00:44:44,510 --> 00:44:49,040
that will be a lot easier especially

00:44:46,070 --> 00:44:50,270
when working in teams I explained that

00:44:49,040 --> 00:44:55,370
there's plenty of ways to do it

00:44:50,270 --> 00:44:57,470
s3 HTTP gets I like console or you can

00:44:55,370 --> 00:44:59,180
use that CD console is just a key value

00:44:57,470 --> 00:45:01,130
store an advanced key value store Inc

00:44:59,180 --> 00:45:03,350
sort of cluster format it's also by

00:45:01,130 --> 00:45:05,720
Hoshi Corp and it's a way to keep track

00:45:03,350 --> 00:45:07,880
of state do locking setting it up is

00:45:05,720 --> 00:45:09,380
quite easy but when you want to do it on

00:45:07,880 --> 00:45:11,600
your laptop for testing purposes this is

00:45:09,380 --> 00:45:13,700
just a command again it's also a go

00:45:11,600 --> 00:45:15,740
binary single go binary you run it an

00:45:13,700 --> 00:45:17,870
agent load you indicate the location

00:45:15,740 --> 00:45:19,760
really or store all the data files and

00:45:17,870 --> 00:45:21,860
then you say I want a server you want a

00:45:19,760 --> 00:45:23,270
graphical interface to do some searching

00:45:21,860 --> 00:45:24,890
and you want to do it in dev mode when

00:45:23,270 --> 00:45:27,530
you do it in dev mode it won't require a

00:45:24,890 --> 00:45:28,750
cluster with multiple servers and the

00:45:27,530 --> 00:45:32,120
only thing you need to do then is

00:45:28,750 --> 00:45:33,710
provide some TF file well you'll where

00:45:32,120 --> 00:45:35,720
you'll put that construct and say my

00:45:33,710 --> 00:45:38,330
back-end is of the type console this is

00:45:35,720 --> 00:45:40,160
the address local host port 8500 for

00:45:38,330 --> 00:45:42,080
example and this is the namespace the

00:45:40,160 --> 00:45:44,120
path in that key value store where you

00:45:42,080 --> 00:45:45,500
want to store it if you have multiple

00:45:44,120 --> 00:45:47,840
people trying the same thing you will

00:45:45,500 --> 00:45:50,360
get a locking error that will cause you

00:45:47,840 --> 00:45:52,520
so that will prevent from causing you so

00:45:50,360 --> 00:45:54,410
much trouble and this is a good way of

00:45:52,520 --> 00:45:56,270
making sure that things don't go down

00:45:54,410 --> 00:45:58,580
but there's another thing you could do

00:45:56,270 --> 00:46:01,790
you could leverage that and create a

00:45:58,580 --> 00:46:03,530
data source that uses that state because

00:46:01,790 --> 00:46:05,330
throughout these example that I've shown

00:46:03,530 --> 00:46:06,980
you communication between different

00:46:05,330 --> 00:46:09,260
terraform projects happen throughout

00:46:06,980 --> 00:46:11,150
variables or variable files like a

00:46:09,260 --> 00:46:13,100
variable file where all these variables

00:46:11,150 --> 00:46:15,710
will locate it or command-line arguments

00:46:13,100 --> 00:46:16,880
where these variables were set this is

00:46:15,710 --> 00:46:19,190
not always the easiest way and

00:46:16,880 --> 00:46:20,600
especially if you have if different

00:46:19,190 --> 00:46:24,140
stages could run on different machines

00:46:20,600 --> 00:46:25,520
there's no real way to send these IPS

00:46:24,140 --> 00:46:28,670
over or send these commands over the

00:46:25,520 --> 00:46:31,940
wire so what you'll do is keep track of

00:46:28,670 --> 00:46:34,610
the state there you you'll have a data

00:46:31,940 --> 00:46:36,590
source and that DNS record where that IP

00:46:34,610 --> 00:46:38,390
that public IP used to be sent over the

00:46:36,590 --> 00:46:39,680
command line you can just read it from

00:46:38,390 --> 00:46:41,750
there you could just read it from that

00:46:39,680 --> 00:46:45,140
data source so you have a place where

00:46:41,750 --> 00:46:46,640
you set the state that is here we'll

00:46:45,140 --> 00:46:47,759
probably have that somewhere in your

00:46:46,640 --> 00:46:50,519
code

00:46:47,759 --> 00:46:52,049
at the other project you can even rely

00:46:50,519 --> 00:46:54,359
on local state if you want to and read

00:46:52,049 --> 00:46:55,889
that remote state and that will fetch

00:46:54,359 --> 00:46:57,599
all the information you need in this

00:46:55,889 --> 00:46:59,699
case and output that was registered

00:46:57,599 --> 00:47:01,889
which is called public IP and it will

00:46:59,699 --> 00:47:03,749
just take that and store it in there and

00:47:01,889 --> 00:47:06,089
you'll have communication over the wire

00:47:03,749 --> 00:47:08,309
throughout a sort of consensus system

00:47:06,089 --> 00:47:10,739
basically what consul s so instead of

00:47:08,309 --> 00:47:12,749
using CLI uh variables use remote state

00:47:10,739 --> 00:47:14,339
to communicate between the different

00:47:12,749 --> 00:47:18,509
aspects maybe the different projects and

00:47:14,339 --> 00:47:19,739
as a final note does that mean you can

00:47:18,509 --> 00:47:21,269
do hybrid cloud that's one of the

00:47:19,739 --> 00:47:23,339
question that I often get asked because

00:47:21,269 --> 00:47:26,399
you could combine Amazon and Asher and

00:47:23,339 --> 00:47:29,249
you can put Google into it in theory yes

00:47:26,399 --> 00:47:31,469
but we all know that these vendors are

00:47:29,249 --> 00:47:33,389
optimized only for their own toolkit if

00:47:31,469 --> 00:47:35,130
you have to go out there data center and

00:47:33,389 --> 00:47:36,659
go over the public Internet to another

00:47:35,130 --> 00:47:38,669
data center there will be a cost

00:47:36,659 --> 00:47:40,709
involved the connection speed might not

00:47:38,669 --> 00:47:42,659
be what you expect it to be so yes it is

00:47:40,709 --> 00:47:44,849
entirely possible maybe you can use an

00:47:42,659 --> 00:47:46,919
external DNS system that is part of the

00:47:44,849 --> 00:47:48,959
stack and combine it with some VMware

00:47:46,919 --> 00:47:50,849
stuff that is hosted at your company

00:47:48,959 --> 00:47:53,219
that could work fine but I'm not a

00:47:50,849 --> 00:47:56,729
hundred percent sure if combining a sure

00:47:53,219 --> 00:47:59,519
with Amazon and Google all together if

00:47:56,729 --> 00:48:01,380
that would be faster or cheaper if there

00:47:59,519 --> 00:48:03,299
are features that are not in your cloud

00:48:01,380 --> 00:48:05,609
environment of choice yes that could

00:48:03,299 --> 00:48:07,829
work but if you're just using it for the

00:48:05,609 --> 00:48:09,739
sake of redundancy I would go for the

00:48:07,829 --> 00:48:12,389
multi availability zones multi regions

00:48:09,739 --> 00:48:13,679
that was that I would like to thank you

00:48:12,389 --> 00:48:15,719
for being there if you wanted more

00:48:13,679 --> 00:48:18,149
information about what I do about the

00:48:15,719 --> 00:48:19,529
books I write the videos I make the

00:48:18,149 --> 00:48:20,999
presentation I give three and out the U

00:48:19,529 --> 00:48:23,069
is the place if you just want to follow

00:48:20,999 --> 00:48:25,619
me on social those are the spots again

00:48:23,069 --> 00:48:27,479
join then give me feedback help me

00:48:25,619 --> 00:48:29,249
improve this presentation I want to

00:48:27,479 --> 00:48:31,349
travel the world for free I wanted two

00:48:29,249 --> 00:48:32,699
more presentations help me out if you

00:48:31,349 --> 00:48:34,829
liked it please let me know there as

00:48:32,699 --> 00:48:38,689
well and with that being said thanks for

00:48:34,829 --> 00:48:38,689

YouTube URL: https://www.youtube.com/watch?v=myy_DGD9JoU


