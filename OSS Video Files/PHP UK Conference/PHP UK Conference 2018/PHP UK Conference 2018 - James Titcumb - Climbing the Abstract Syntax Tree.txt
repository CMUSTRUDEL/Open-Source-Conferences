Title: PHP UK Conference 2018 - James Titcumb - Climbing the Abstract Syntax Tree
Publication date: 2018-03-27
Playlist: PHP UK Conference 2018
Description: 
	The new Abstract Syntax Tree (AST) in PHP 7 means the way our PHP code is being executed has changed. Understanding this new fundamental compilation step is key to understanding how our code is being run. To demonstrate, James will show how a basic compiler works and how introducing an AST simplifies this process. We’ll look into how these magical time-warp techniques* can also be used in your code to introspect, analyse and modify code in a way that was never possible before. After seeing this talk, you'll have a great insight as to the wonders of an AST, and how it can be applied to both compilers and userland code.
(*actual magic or time-warp not guaranteed)
Captions: 
	00:00:03,710 --> 00:00:07,429
good morning everyone

00:00:05,370 --> 00:00:10,980
how's it going looking for to lunch

00:00:07,429 --> 00:00:13,200
alright we've come to learn today from

00:00:10,980 --> 00:00:15,450
me about abstract syntax trees and a bit

00:00:13,200 --> 00:00:17,850
of how the PHP compiler works

00:00:15,450 --> 00:00:19,980
my name is indeed James titcombe and

00:00:17,850 --> 00:00:22,140
I've been doing PHP since 2002 and I've

00:00:19,980 --> 00:00:23,400
been programming since before that and

00:00:22,140 --> 00:00:25,439
it was all fun

00:00:23,400 --> 00:00:27,330
I'm a zen certified engineer and I work

00:00:25,439 --> 00:00:30,480
for this company called Rove for very Oh

00:00:27,330 --> 00:00:33,000
five fine elephants there is only one

00:00:30,480 --> 00:00:35,640
left for today I'll bring another ten

00:00:33,000 --> 00:00:36,989
tomorrow so if you come and find me if

00:00:35,640 --> 00:00:40,410
you don't get hold of this one at the

00:00:36,989 --> 00:00:41,850
end of the talk come and find me

00:00:40,410 --> 00:00:49,379
tomorrow and I hopefully will have some

00:00:41,850 --> 00:00:51,440
more yes PHP so how many people know

00:00:49,379 --> 00:00:55,079
roughly this cycle of how it works

00:00:51,440 --> 00:00:59,190
already ok ok cool

00:00:55,079 --> 00:01:01,789
so for the benefit of everyone PHP code

00:00:59,190 --> 00:01:04,229
is fed into this thing called a lexer

00:01:01,789 --> 00:01:08,189
don't worry about what it means yet I'll

00:01:04,229 --> 00:01:09,900
explain that in due course this lecture

00:01:08,189 --> 00:01:12,240
generates these things called tokens you

00:01:09,900 --> 00:01:13,920
may have heard of these these tokens are

00:01:12,240 --> 00:01:17,900
then fed into this thing called a parser

00:01:13,920 --> 00:01:20,640
which generates this thing called an AST

00:01:17,900 --> 00:01:23,100
the AST is then compiled by this

00:01:20,640 --> 00:01:26,280
compiler thing to generate these things

00:01:23,100 --> 00:01:27,689
called op codes probably heard of those

00:01:26,280 --> 00:01:28,950
and the off codes are stored in this

00:01:27,689 --> 00:01:31,290
thing called the op cache which

00:01:28,950 --> 00:01:33,090
hopefully you've heard of that and is

00:01:31,290 --> 00:01:36,770
executed in this thing called a virtual

00:01:33,090 --> 00:01:40,079
machine that's basically how PHP works

00:01:36,770 --> 00:01:41,810
the Vic the virtual machine thing is not

00:01:40,079 --> 00:01:44,850
like vagrant or anything like that it's

00:01:41,810 --> 00:01:47,670
like a virtual CPU that executes these

00:01:44,850 --> 00:01:51,329
op codes and runs that makes it do

00:01:47,670 --> 00:01:55,560
things right the AAA AST part of that is

00:01:51,329 --> 00:01:59,520
new in PHP 7 well I say new PHP 7s not

00:01:55,560 --> 00:02:02,820
that new anymore um but it was

00:01:59,520 --> 00:02:04,740
introduced in PHP 7 and it was quite a

00:02:02,820 --> 00:02:08,879
dramatic change to how the engine works

00:02:04,740 --> 00:02:10,259
underneath so let's have a look at how

00:02:08,879 --> 00:02:12,569
this actually works so we start off with

00:02:10,259 --> 00:02:15,720
Alexa right Alexa

00:02:12,569 --> 00:02:19,500
the V LexA in PHP is a generated program

00:02:15,720 --> 00:02:20,970
written in C I say it's generated

00:02:19,500 --> 00:02:23,280
because to write one of these things by

00:02:20,970 --> 00:02:25,019
hand is a bit silly it's time-consuming

00:02:23,280 --> 00:02:27,440
and it's complicated

00:02:25,019 --> 00:02:31,049
so we have a generator to do it for us

00:02:27,440 --> 00:02:33,030
re to see or read to see have you prefer

00:02:31,049 --> 00:02:35,280
to say those things is the lexer

00:02:33,030 --> 00:02:36,720
generator tool the PHP uses there are

00:02:35,280 --> 00:02:38,900
other is available other programming

00:02:36,720 --> 00:02:40,560
languages you will use different ones so

00:02:38,900 --> 00:02:45,030
we have this file

00:02:40,560 --> 00:02:48,480
Zend language scanner dot L this is the

00:02:45,030 --> 00:02:52,379
syntax definition if you like of PHP and

00:02:48,480 --> 00:02:56,640
this describes how the tokens are formed

00:02:52,379 --> 00:02:58,470
and how they're split out and so on and

00:02:56,640 --> 00:03:02,629
this is what it might look like a very

00:02:58,470 --> 00:03:05,459
simple example all right the format is

00:03:02,629 --> 00:03:07,709
quite common it's similar to this thing

00:03:05,459 --> 00:03:10,049
called flex which is stands for fast

00:03:07,709 --> 00:03:12,930
lexical analyzer incidentally that is

00:03:10,049 --> 00:03:15,840
used by h h vm which is the alternative

00:03:12,930 --> 00:03:20,549
PHP runtime that facebook built and now

00:03:15,840 --> 00:03:21,959
only runs hack as far as i know but

00:03:20,549 --> 00:03:24,599
these are a few very simple examples

00:03:21,959 --> 00:03:27,389
right in the angle brackets here we have

00:03:24,599 --> 00:03:29,250
st in scripting so these are the current

00:03:27,389 --> 00:03:34,260
states where these tokens will be

00:03:29,250 --> 00:03:35,819
matched a lexer is a state machine so as

00:03:34,260 --> 00:03:38,819
you go through you can change the state

00:03:35,819 --> 00:03:40,319
of you know where you are so you're in

00:03:38,819 --> 00:03:42,840
scripting or maybe you're in double

00:03:40,319 --> 00:03:45,650
quotes or in a here doc or now doc and

00:03:42,840 --> 00:03:50,819
things like that so you can change the

00:03:45,650 --> 00:03:53,099
context or state right of what tokens

00:03:50,819 --> 00:03:55,169
you're looking for because when you're

00:03:53,099 --> 00:03:58,079
in a string you may be looking for you

00:03:55,169 --> 00:04:00,299
know the dollar to input a variable name

00:03:58,079 --> 00:04:03,930
and things like that to concatenate the

00:04:00,299 --> 00:04:05,910
string for example the next bit is a

00:04:03,930 --> 00:04:08,069
very simple string literals we've

00:04:05,910 --> 00:04:13,049
probably seen these things before like a

00:04:08,069 --> 00:04:15,120
function or die or exit and then what

00:04:13,049 --> 00:04:17,849
happens inside the curly braces is what

00:04:15,120 --> 00:04:21,450
happens when this token is matched so

00:04:17,849 --> 00:04:23,460
when the lecture encounters these tokens

00:04:21,450 --> 00:04:25,349
this thing will happen in this case in

00:04:23,460 --> 00:04:27,450
all of these cases they just return the

00:04:25,349 --> 00:04:30,420
tokens direct

00:04:27,450 --> 00:04:31,920
tea exit is incidentally exactly the

00:04:30,420 --> 00:04:33,690
same in exit and die it doesn't matter

00:04:31,920 --> 00:04:36,920
it returns the same token so it has the

00:04:33,690 --> 00:04:41,730
same meaning and function returns the

00:04:36,920 --> 00:04:43,320
function token so then it puts that

00:04:41,730 --> 00:04:45,900
these out into this thing called the

00:04:43,320 --> 00:04:49,620
output stream of the lexer of the token

00:04:45,900 --> 00:04:51,240
stream right so as I mentioned this it's

00:04:49,620 --> 00:04:53,010
a state machine so the state allows you

00:04:51,240 --> 00:04:55,470
to match different tokens depending on

00:04:53,010 --> 00:04:57,840
where you are and so on so this is an

00:04:55,470 --> 00:05:01,020
example bit-by-bit let's go through it

00:04:57,840 --> 00:05:03,930
this first one will match if we're in

00:05:01,020 --> 00:05:06,420
double quotes back quote or we probably

00:05:03,930 --> 00:05:10,590
know it as back ticks perhaps or here

00:05:06,420 --> 00:05:13,140
doc and we're looking for the string

00:05:10,590 --> 00:05:15,480
dollar curly brace so that we're inside

00:05:13,140 --> 00:05:17,430
a string basically right and when we

00:05:15,480 --> 00:05:19,950
encounter that we will do this thing

00:05:17,430 --> 00:05:21,630
called a YY push state right that's

00:05:19,950 --> 00:05:24,120
basically changed the state to this

00:05:21,630 --> 00:05:25,830
which is looking for variable name right

00:05:24,120 --> 00:05:28,350
so now we're looking for a variable name

00:05:25,830 --> 00:05:30,240
so we're changing the state again and we

00:05:28,350 --> 00:05:33,030
return the token that we've matched to

00:05:30,240 --> 00:05:35,250
the token stream so now we're in this

00:05:33,030 --> 00:05:38,520
state looking for variable name we're

00:05:35,250 --> 00:05:40,830
looking for a variable a label basically

00:05:38,520 --> 00:05:42,960
and followed by a curly brace and

00:05:40,830 --> 00:05:44,430
there's lots of sort of square brackets

00:05:42,960 --> 00:05:47,400
and curly brackets and so on if you get

00:05:44,430 --> 00:05:51,120
them wrong it'll probably break so you

00:05:47,400 --> 00:05:53,550
know don't touch that and then we do

00:05:51,120 --> 00:05:55,500
this thing called copying a semantic

00:05:53,550 --> 00:05:57,210
value basically means that's the name of

00:05:55,500 --> 00:05:59,100
the variable right but that's useful

00:05:57,210 --> 00:06:00,600
information we want to know when we're

00:05:59,100 --> 00:06:02,310
looking at that token we want to know

00:06:00,600 --> 00:06:04,590
what the name of the variable is that we

00:06:02,310 --> 00:06:07,250
matched it's kind of important for the

00:06:04,590 --> 00:06:10,980
engine to know right

00:06:07,250 --> 00:06:12,480
papé state we kind of go back into the

00:06:10,980 --> 00:06:14,730
last state we're in and then we push

00:06:12,480 --> 00:06:17,970
state so we go back into scripting the

00:06:14,730 --> 00:06:19,410
pop state seems kind of perhaps a bit

00:06:17,970 --> 00:06:22,110
redundant but I know maybe there's a

00:06:19,410 --> 00:06:23,460
reason for that I don't know and then of

00:06:22,110 --> 00:06:29,310
course we return the token for the token

00:06:23,460 --> 00:06:31,200
stream we've next stuff all right so now

00:06:29,310 --> 00:06:33,420
all we have is we've broken up our long

00:06:31,200 --> 00:06:35,550
string of PHP code into lots of little

00:06:33,420 --> 00:06:37,230
tokens perhaps with some meaningful

00:06:35,550 --> 00:06:38,960
information like variable names and so

00:06:37,230 --> 00:06:42,270
on

00:06:38,960 --> 00:06:45,599
so given that syntax definition we pass

00:06:42,270 --> 00:06:51,060
these this into re to see this program

00:06:45,599 --> 00:06:53,220
and it generates a C file it's not all

00:06:51,060 --> 00:06:54,569
that readable there's bits of it are

00:06:53,220 --> 00:06:56,610
readable but then there's huge like

00:06:54,569 --> 00:06:58,889
chunks of numbers and letters that are

00:06:56,610 --> 00:07:00,449
really meaningless but you can go ahead

00:06:58,889 --> 00:07:02,970
you can check out the PHP source code

00:07:00,449 --> 00:07:05,009
and you can run Ritu C on this with a

00:07:02,970 --> 00:07:08,160
load of flags which are - - no

00:07:05,009 --> 00:07:11,639
generation day - - case inverted - CBD f

00:07:08,160 --> 00:07:15,389
- OH seeds and language scanner dial and

00:07:11,639 --> 00:07:16,919
so on remember that you probably do but

00:07:15,389 --> 00:07:20,940
you're probably the only person that

00:07:16,919 --> 00:07:22,380
remembers that in this room and that is

00:07:20,940 --> 00:07:24,810
the lecture implementation and that's

00:07:22,380 --> 00:07:27,509
what actually happens right so the next

00:07:24,810 --> 00:07:28,620
stage is the parser the parser kind of

00:07:27,509 --> 00:07:31,319
works in a similar way it's a state

00:07:28,620 --> 00:07:34,130
machine as well fine and we have another

00:07:31,319 --> 00:07:39,509
definition Lang end language parser da

00:07:34,130 --> 00:07:42,449
another meaningless file extension this

00:07:39,509 --> 00:07:44,370
contains the pars of definition and this

00:07:42,449 --> 00:07:46,320
gets a little bit more complicated when

00:07:44,370 --> 00:07:49,080
we're lexing stuff all we're doing is

00:07:46,320 --> 00:07:51,900
breaking up its string into lots of

00:07:49,080 --> 00:07:55,259
little tokens right as I said a parser

00:07:51,900 --> 00:07:58,380
actually tries to make sense of these

00:07:55,259 --> 00:07:59,909
tokens in order and it says well you

00:07:58,380 --> 00:08:02,159
know I could throw a load of random

00:07:59,909 --> 00:08:03,690
words at you like I'm doing now but

00:08:02,159 --> 00:08:05,580
they're actually ordered so that they

00:08:03,690 --> 00:08:08,789
mean something to you and you understand

00:08:05,580 --> 00:08:09,690
what I'm talking about hopefully if I'm

00:08:08,789 --> 00:08:13,469
getting the words in the right order

00:08:09,690 --> 00:08:17,580
that is if I start talking random

00:08:13,469 --> 00:08:19,169
nonsense I'm still using real words but

00:08:17,580 --> 00:08:20,310
in the order they are it doesn't make

00:08:19,169 --> 00:08:23,699
sense and you won't be able to

00:08:20,310 --> 00:08:25,380
understand so actually when you're

00:08:23,699 --> 00:08:27,569
writing a programming language with a

00:08:25,380 --> 00:08:29,370
lexer and parser it works in quite a

00:08:27,569 --> 00:08:32,070
similar way - you know you could

00:08:29,370 --> 00:08:36,000
deconstruct a spoken language or in

00:08:32,070 --> 00:08:38,760
language if you like so the parser tries

00:08:36,000 --> 00:08:40,890
to make sense of these words if you like

00:08:38,760 --> 00:08:44,610
in order and so it's write that work

00:08:40,890 --> 00:08:45,690
that works that's good so we're trying

00:08:44,610 --> 00:08:46,350
to understand the main parts of what's

00:08:45,690 --> 00:08:48,089
going on here

00:08:46,350 --> 00:08:50,490
right first of all these are just labels

00:08:48,089 --> 00:08:52,170
we have two definitions if statement if

00:08:50,490 --> 00:08:56,680
statement without else

00:08:52,170 --> 00:08:58,980
now throughout this you'll encounter two

00:08:56,680 --> 00:09:02,170
other definitions which are quite large

00:08:58,980 --> 00:09:05,020
extra which is expression and statement

00:09:02,170 --> 00:09:06,700
and these are really big definitions so

00:09:05,020 --> 00:09:10,390
I can't fit them on a slide so I've

00:09:06,700 --> 00:09:11,740
omitted them but you know in you know we

00:09:10,390 --> 00:09:13,750
know what an expression is in a

00:09:11,740 --> 00:09:16,810
statement it's so we can kind of put

00:09:13,750 --> 00:09:19,870
that in mentally so we'll look at the F

00:09:16,810 --> 00:09:21,430
statement first basically this says if

00:09:19,870 --> 00:09:25,930
statement can be an if statement without

00:09:21,430 --> 00:09:28,600
else on its own this thing is like

00:09:25,930 --> 00:09:30,550
precedence we don't have to worry too

00:09:28,600 --> 00:09:35,140
much about that it's kind of important

00:09:30,550 --> 00:09:37,690
but we'll skip over it that's fine or it

00:09:35,140 --> 00:09:39,760
can be an if statement without else

00:09:37,690 --> 00:09:45,520
followed by an else followed by a

00:09:39,760 --> 00:09:47,110
statement okay but we also need to know

00:09:45,520 --> 00:09:49,900
what an if statement without else is so

00:09:47,110 --> 00:09:52,420
we can fill in those blanks and that is

00:09:49,900 --> 00:09:54,220
the if token followed by the literal

00:09:52,420 --> 00:09:56,320
open parentheses followed by an

00:09:54,220 --> 00:09:58,060
expression an expression is something to

00:09:56,320 --> 00:09:59,740
return something followed by a closed

00:09:58,060 --> 00:10:01,330
bracket followed by a statement and a

00:09:59,740 --> 00:10:05,980
statement doesn't necessarily return

00:10:01,330 --> 00:10:07,390
something the definition for expression

00:10:05,980 --> 00:10:09,880
statement is huge

00:10:07,390 --> 00:10:12,640
okay so we'll ignore it but you can look

00:10:09,880 --> 00:10:16,660
at the this file in PHP code and see wow

00:10:12,640 --> 00:10:18,520
that's big if you like or it can be an

00:10:16,660 --> 00:10:20,050
if statement without else can also be an

00:10:18,520 --> 00:10:22,420
if statement without else followed by

00:10:20,050 --> 00:10:24,280
else if followed by an open parenthesis

00:10:22,420 --> 00:10:27,520
and expression close parenthesis and a

00:10:24,280 --> 00:10:29,170
statement so the statement just for

00:10:27,520 --> 00:10:31,510
completeness so you can hopefully

00:10:29,170 --> 00:10:34,480
visualize this a bit better includes

00:10:31,510 --> 00:10:37,570
curly braces around the side so I'll see

00:10:34,480 --> 00:10:40,660
you right if brackets an expression that

00:10:37,570 --> 00:10:44,350
returns something boolean or truth e or

00:10:40,660 --> 00:10:46,750
false each maybe and then sometimes you

00:10:44,350 --> 00:10:48,370
have clearly it's optional right if you

00:10:46,750 --> 00:10:50,800
want to do one line most people I think

00:10:48,370 --> 00:10:54,220
use curly braces consistently for their

00:10:50,800 --> 00:10:55,450
if else's and so on but that's included

00:10:54,220 --> 00:10:58,750
in the statement so we don't actually

00:10:55,450 --> 00:11:00,430
see that in this definition so let's

00:10:58,750 --> 00:11:02,170
have a look at some code we know some

00:11:00,430 --> 00:11:04,320
PHP code right

00:11:02,170 --> 00:11:07,190
who doesn't know PHP code

00:11:04,320 --> 00:11:09,480
okay cool you're at the right place then

00:11:07,190 --> 00:11:13,200
alright so we'll try and use those rules

00:11:09,480 --> 00:11:16,410
so the first one matches the first one

00:11:13,200 --> 00:11:18,690
to a few lines of code if statement

00:11:16,410 --> 00:11:21,720
without else and it's got an if token

00:11:18,690 --> 00:11:22,980
open brackets expression statement as I

00:11:21,720 --> 00:11:26,580
said the statement includes the curly

00:11:22,980 --> 00:11:29,130
braces and then it's got else if so

00:11:26,580 --> 00:11:33,830
that's why we match that so the next

00:11:29,130 --> 00:11:36,750
part is match by exactly the same rule

00:11:33,830 --> 00:11:38,550
it matches this the alternative grammar

00:11:36,750 --> 00:11:39,960
if you like that was defined so it

00:11:38,550 --> 00:11:42,450
matches the if statement without else

00:11:39,960 --> 00:11:44,490
and an else if as well an Illinois from

00:11:42,450 --> 00:11:48,600
percents of parenthesis expression close

00:11:44,490 --> 00:11:50,310
Frances statement okay and finally the

00:11:48,600 --> 00:11:52,260
last one if statement matches because

00:11:50,310 --> 00:11:54,510
it's an if statement without else

00:11:52,260 --> 00:11:58,010
followed by an else token followed by

00:11:54,510 --> 00:12:02,190
statement okay with me so far

00:11:58,010 --> 00:12:06,090
some nods good all right cool so if we

00:12:02,190 --> 00:12:08,670
have a look at PHP seven-point whatever

00:12:06,090 --> 00:12:11,220
this doesn't matter it's irrelevant we

00:12:08,670 --> 00:12:12,780
can see it's doing some stuff right it

00:12:11,220 --> 00:12:15,540
has curly brace parts so that's again

00:12:12,780 --> 00:12:17,820
what happens when we match the the

00:12:15,540 --> 00:12:18,900
grammar that's been defined over there's

00:12:17,820 --> 00:12:21,780
something important that I've

00:12:18,900 --> 00:12:24,600
highlighted in big red boxes here right

00:12:21,780 --> 00:12:28,590
in PHP seven the posit puts the abstract

00:12:24,600 --> 00:12:30,690
syntax tree if we go look at PHP five

00:12:28,590 --> 00:12:32,370
the grammar is actually slightly

00:12:30,690 --> 00:12:36,570
different so I've kind of matched it the

00:12:32,370 --> 00:12:39,140
best I can but instead of doing this AST

00:12:36,570 --> 00:12:41,940
stuff we're doing this then do if cond

00:12:39,140 --> 00:12:46,020
which is basically an if statement right

00:12:41,940 --> 00:12:47,580
and the grammar is different and you can

00:12:46,020 --> 00:12:50,180
see we're actually generating op codes

00:12:47,580 --> 00:12:53,730
here directly you know we're doing

00:12:50,180 --> 00:12:56,220
opcode is then jump things like that

00:12:53,730 --> 00:12:59,250
right yeah I have to worry too much

00:12:56,220 --> 00:13:01,590
about what they after fine so the ast is

00:12:59,250 --> 00:13:05,190
new right so going back to the first

00:13:01,590 --> 00:13:08,790
diagram it's this bit here sort of in

00:13:05,190 --> 00:13:12,780
between these two steps is where the ast

00:13:08,790 --> 00:13:16,470
is exists if you like so the result of

00:13:12,780 --> 00:13:18,300
the parser in PHP 7 is the ast the ast

00:13:16,470 --> 00:13:20,190
is then fed into the compiler which

00:13:18,300 --> 00:13:23,750
converts it to opcodes and the opcodes

00:13:20,190 --> 00:13:23,750
are executed and magic happens

00:13:23,870 --> 00:13:27,720
anyone lost it's okay to put your hand

00:13:27,030 --> 00:13:29,280
up it's fine

00:13:27,720 --> 00:13:32,180
okay so I'm going to try and simplify

00:13:29,280 --> 00:13:32,180
this okay

00:13:33,080 --> 00:13:38,310
first of all what is an AST because I

00:13:36,030 --> 00:13:42,420
haven't really explained what it is just

00:13:38,310 --> 00:13:44,340
that it is an AST is just a data

00:13:42,420 --> 00:13:48,660
structure it's a representation of your

00:13:44,340 --> 00:13:52,710
code and that's pretty much it right it

00:13:48,660 --> 00:13:56,610
uses a it's a tree structure hence the

00:13:52,710 --> 00:13:59,010
name tree funnily enough and it's not

00:13:56,610 --> 00:14:02,760
necessarily specific to PHP which is

00:13:59,010 --> 00:14:05,280
kind of interesting it's a data

00:14:02,760 --> 00:14:07,230
structure that says well this is how

00:14:05,280 --> 00:14:11,220
your code is laid out and so on it can

00:14:07,230 --> 00:14:13,080
be modified in theory and oversee if you

00:14:11,220 --> 00:14:15,390
modify the behavior of that it would

00:14:13,080 --> 00:14:17,220
Mari if you modify the tree it would

00:14:15,390 --> 00:14:18,570
modify the behavior of the code because

00:14:17,220 --> 00:14:22,200
basically you're changing the code

00:14:18,570 --> 00:14:24,330
programmatically if you like it can also

00:14:22,200 --> 00:14:26,370
contain some metadata as well things

00:14:24,330 --> 00:14:30,030
like what line number what file it is

00:14:26,370 --> 00:14:32,520
and things like that and this data

00:14:30,030 --> 00:14:35,790
structure that represents your file of

00:14:32,520 --> 00:14:38,610
code or whatever can also be unpassed

00:14:35,790 --> 00:14:41,400
that is to say you regenerate a program

00:14:38,610 --> 00:14:43,800
from from that your source code the

00:14:41,400 --> 00:14:46,110
layout may change because we may ignore

00:14:43,800 --> 00:14:48,300
certain elements of the layout like

00:14:46,110 --> 00:14:50,190
whether you've got a space and so on it

00:14:48,300 --> 00:14:51,540
may and main may or may not be relevant

00:14:50,190 --> 00:14:53,940
to whatever programming languages are

00:14:51,540 --> 00:14:55,380
out and I say that because an ast is a

00:14:53,940 --> 00:14:57,000
representation used in many other

00:14:55,380 --> 00:15:02,760
programming languages as well not just

00:14:57,000 --> 00:15:05,070
PHP so let's have a look at what it

00:15:02,760 --> 00:15:12,240
might look like so we know what this

00:15:05,070 --> 00:15:12,600
does hopefully if we represent this as a

00:15:12,240 --> 00:15:15,780
tree

00:15:12,600 --> 00:15:20,130
it's a brilliantly drawn ASCII tree all

00:15:15,780 --> 00:15:21,660
right we have an echo statement and we

00:15:20,130 --> 00:15:24,270
have a child value of that of a string

00:15:21,660 --> 00:15:26,880
which is a scalar value right and the

00:15:24,270 --> 00:15:29,100
value is hello world and that's it okay

00:15:26,880 --> 00:15:30,780
that's what it might look like so then

00:15:29,100 --> 00:15:32,130
just to demonstrate getting a bit more

00:15:30,780 --> 00:15:35,220
tree like let's do something

00:15:32,130 --> 00:15:37,680
slightly different this does roughly the

00:15:35,220 --> 00:15:39,210
same thing I think there's a bit more

00:15:37,680 --> 00:15:42,390
going on here though if we turn this

00:15:39,210 --> 00:15:44,970
into an abstract syntax tree we have our

00:15:42,390 --> 00:15:46,800
echo statement we have a concatenation

00:15:44,970 --> 00:15:50,550
operator as the child instead of the

00:15:46,800 --> 00:15:52,200
string directly and we the concatenation

00:15:50,550 --> 00:15:55,680
is what's called a binary operator that

00:15:52,200 --> 00:15:57,720
is it takes a left and a right argument

00:15:55,680 --> 00:16:00,720
if you like think of it maybe as a

00:15:57,720 --> 00:16:04,460
function perhaps so the left value is

00:16:00,720 --> 00:16:11,870
the scalar string hello and the right

00:16:04,460 --> 00:16:17,040
operand is the scalar string weld okay

00:16:11,870 --> 00:16:18,090
so let's do a bit of maths on this story

00:16:17,040 --> 00:16:20,910
it's not difficult maths

00:16:18,090 --> 00:16:24,270
hopefully we're going to assign some

00:16:20,910 --> 00:16:30,330
variables and then do this sum a plus

00:16:24,270 --> 00:16:32,010
brackets B times two fine this is what

00:16:30,330 --> 00:16:33,570
the ast for this looks like and you can

00:16:32,010 --> 00:16:36,660
already see it's getting quite big and

00:16:33,570 --> 00:16:38,490
complicated but it's okay at the top if

00:16:36,660 --> 00:16:41,130
you can just about see it we have the

00:16:38,490 --> 00:16:43,620
assigned statement variable a with the

00:16:41,130 --> 00:16:47,130
integer value of one we have B with an

00:16:43,620 --> 00:16:48,660
integer value of three sorry value of

00:16:47,130 --> 00:16:49,980
five and value of three I can't read

00:16:48,660 --> 00:16:51,800
it's really tiny on there so it's

00:16:49,980 --> 00:16:53,550
probably really tiny the back as well

00:16:51,800 --> 00:16:55,680
but then we have the echo statement

00:16:53,550 --> 00:16:57,900
that's the next thing to happen and then

00:16:55,680 --> 00:17:02,220
we have the add operation again that's a

00:16:57,900 --> 00:17:04,920
binary operation has two things to it at

00:17:02,220 --> 00:17:06,180
the left side we have the variable a the

00:17:04,920 --> 00:17:07,829
right side we have another binary

00:17:06,180 --> 00:17:09,510
operation to multiply because that takes

00:17:07,829 --> 00:17:12,150
again two things you multiply two things

00:17:09,510 --> 00:17:14,160
together the left is a variable B and

00:17:12,150 --> 00:17:21,270
the right is just an integer with the

00:17:14,160 --> 00:17:24,810
value with - alright okay so we can

00:17:21,270 --> 00:17:30,930
represent stuff as trees but why well

00:17:24,810 --> 00:17:32,550
there was quite important it was quite

00:17:30,930 --> 00:17:35,970
an important introduction to the PHP

00:17:32,550 --> 00:17:38,970
engine lots of lots of other languages

00:17:35,970 --> 00:17:39,510
already do this so maybe there's a bit

00:17:38,970 --> 00:17:40,770
of full

00:17:39,510 --> 00:17:45,150
you know PHP could be a growed-up

00:17:40,770 --> 00:17:46,200
language and we can have one two but it

00:17:45,150 --> 00:17:49,470
also increases

00:17:46,200 --> 00:17:53,399
maintain maintainability and co quality

00:17:49,470 --> 00:17:56,100
inside PHP itself and it decouples the

00:17:53,399 --> 00:18:02,700
compiler from the parser so we have this

00:17:56,100 --> 00:18:04,500
sort of intermediate thing and that also

00:18:02,700 --> 00:18:07,350
simplified some of the productions from

00:18:04,500 --> 00:18:10,860
the parser as well which is nice so the

00:18:07,350 --> 00:18:14,399
the grammar actually got simpler at the

00:18:10,860 --> 00:18:16,620
cost of some really weird edge cases

00:18:14,399 --> 00:18:18,809
that we don't really care about and if

00:18:16,620 --> 00:18:20,250
you've already migrated to PHP 7 and you

00:18:18,809 --> 00:18:22,260
encountered some of these weird things

00:18:20,250 --> 00:18:26,850
then you shouldn't have been doing weird

00:18:22,260 --> 00:18:32,330
things in the first place perhaps yes

00:18:26,850 --> 00:18:36,500
and it's faster asterisk all right I

00:18:32,330 --> 00:18:39,059
have to call it quantify qualify this

00:18:36,500 --> 00:18:42,210
because there is a particular part of

00:18:39,059 --> 00:18:44,429
that process that is faster so using the

00:18:42,210 --> 00:18:46,500
st means that we can be faster in the

00:18:44,429 --> 00:18:50,789
compilation step right despite this

00:18:46,500 --> 00:18:53,730
extra step it kind of offsets it but the

00:18:50,789 --> 00:18:56,970
runtime difference is kind of negligible

00:18:53,730 --> 00:18:59,010
most of the benefits that we see in PHP

00:18:56,970 --> 00:19:01,620
7 are actually from other optimizations

00:18:59,010 --> 00:19:03,779
like rewriting how the Z vowels work and

00:19:01,620 --> 00:19:06,299
referencing and things like that not

00:19:03,779 --> 00:19:08,820
this part of it so the runtime

00:19:06,299 --> 00:19:13,620
performance is not really changed much

00:19:08,820 --> 00:19:15,840
from this particular change but the in

00:19:13,620 --> 00:19:18,149
the compilation step that actually means

00:19:15,840 --> 00:19:20,130
that it's about 10 to 15% faster which

00:19:18,149 --> 00:19:21,960
is kind of nice but it does require more

00:19:20,130 --> 00:19:26,789
memory because there's all these big old

00:19:21,960 --> 00:19:28,230
data structure that's makes sense but

00:19:26,789 --> 00:19:29,639
once it's compiled down to aren't into

00:19:28,230 --> 00:19:30,809
op codes anyway it doesn't matter

00:19:29,639 --> 00:19:32,279
because you've already compiled the op

00:19:30,809 --> 00:19:35,490
codes then and there in the OP cache and

00:19:32,279 --> 00:19:36,600
we can you refer to those later but the

00:19:35,490 --> 00:19:38,130
reason why it's more efficient is

00:19:36,600 --> 00:19:41,190
because this tree structure is very

00:19:38,130 --> 00:19:43,500
friendly for compilers you know

00:19:41,190 --> 00:19:45,929
computers understand it nicely and you

00:19:43,500 --> 00:19:48,090
can go around this tree and figure

00:19:45,929 --> 00:19:52,169
things out I'll demonstrate that shortly

00:19:48,090 --> 00:19:54,179
so it's very efficient in theory you

00:19:52,169 --> 00:19:55,590
could also do sort of static collapsing

00:19:54,179 --> 00:19:58,889
of nodes and things like that I mean if

00:19:55,590 --> 00:20:00,000
we look at this code we already know

00:19:58,889 --> 00:20:01,470
what the answer is because

00:20:00,000 --> 00:20:02,850
the value will always be the same so

00:20:01,470 --> 00:20:07,170
technically you could just change that

00:20:02,850 --> 00:20:09,120
into an echo the value right and then

00:20:07,170 --> 00:20:11,040
that ast becomes nothing but we won't

00:20:09,120 --> 00:20:13,110
we'll leave it as a big ast right so we

00:20:11,040 --> 00:20:16,710
can draw this a different way like a

00:20:13,110 --> 00:20:19,530
tree but upside down so the exact same

00:20:16,710 --> 00:20:24,480
information here is is here on this

00:20:19,530 --> 00:20:28,590
slide but when we show this as a tree

00:20:24,480 --> 00:20:30,180
and draw it out like this nice tree we

00:20:28,590 --> 00:20:32,490
can do something we can follow a line

00:20:30,180 --> 00:20:36,750
around the graph we can execute each

00:20:32,490 --> 00:20:38,100
node that we touch down in order and if

00:20:36,750 --> 00:20:41,610
we start at the top and go all the way

00:20:38,100 --> 00:20:44,040
around and run all of these if you like

00:20:41,610 --> 00:20:49,680
this is something called a pre-order

00:20:44,040 --> 00:20:51,270
traversal and if you write them down in

00:20:49,680 --> 00:20:54,530
the order that they happened you'll get

00:20:51,270 --> 00:20:58,310
something looks that looks like this and

00:20:54,530 --> 00:21:00,960
in sort of pseudocode pseudocode terms

00:20:58,310 --> 00:21:06,570
that looks the same as the code we've

00:21:00,960 --> 00:21:09,690
written right the PHP code roughly so

00:21:06,570 --> 00:21:12,570
the important thing is the operation or

00:21:09,690 --> 00:21:15,090
the statement is prefixed all right so

00:21:12,570 --> 00:21:19,380
that a sign comes before the variable in

00:21:15,090 --> 00:21:20,790
the scalar value and it's called polish

00:21:19,380 --> 00:21:23,010
notation when we write it down like this

00:21:20,790 --> 00:21:25,530
and it allows us to very very very

00:21:23,010 --> 00:21:27,600
easily see the order of precedence we

00:21:25,530 --> 00:21:29,910
know that we have to multiply something

00:21:27,600 --> 00:21:33,120
first before we can add the value so we

00:21:29,910 --> 00:21:37,490
have to go all the way down multiply B

00:21:33,120 --> 00:21:42,570
by 2 and then we can add a to the the

00:21:37,490 --> 00:21:43,830
result of the multiply operation when

00:21:42,570 --> 00:21:44,940
writing a programming language I've

00:21:43,830 --> 00:21:46,290
mentioned this thing called order of

00:21:44,940 --> 00:21:47,790
precedence when writing a programming

00:21:46,290 --> 00:21:51,420
language order of precedence is really

00:21:47,790 --> 00:21:56,030
important because it defines how things

00:21:51,420 --> 00:22:00,480
behave when the order of operations is

00:21:56,030 --> 00:22:02,640
potentially ambiguous demonstrated by

00:22:00,480 --> 00:22:05,130
this simple math some if you do it two

00:22:02,640 --> 00:22:08,010
different ways you get different results

00:22:05,130 --> 00:22:11,630
so order of precedence is very important

00:22:08,010 --> 00:22:14,670
in the same way in programming languages

00:22:11,630 --> 00:22:15,090
is it seven do we do the multiplication

00:22:14,670 --> 00:22:17,940
first

00:22:15,090 --> 00:22:22,280
or is it nine where we add first and

00:22:17,940 --> 00:22:24,240
then multiply the result we know in

00:22:22,280 --> 00:22:26,490
mathematical that we multiply first

00:22:24,240 --> 00:22:28,710
alright but you can change that

00:22:26,490 --> 00:22:29,970
potentially in a compiler and make it do

00:22:28,710 --> 00:22:35,520
something different which would be

00:22:29,970 --> 00:22:37,980
unexpected perhaps so when we write this

00:22:35,520 --> 00:22:40,170
out in polish notation then we can see

00:22:37,980 --> 00:22:42,360
the order of things that have to happen

00:22:40,170 --> 00:22:44,250
but it's actually kind of backwards

00:22:42,360 --> 00:22:46,920
because you have to go like all the way

00:22:44,250 --> 00:22:51,410
down take the three in the two and

00:22:46,920 --> 00:22:54,390
multiply them together and so on so

00:22:51,410 --> 00:22:56,400
reading left to right we have to say

00:22:54,390 --> 00:22:57,900
well okay we want to add something we've

00:22:56,400 --> 00:22:59,700
got the first thing which is a one but

00:22:57,900 --> 00:23:00,809
then we've got another operator which is

00:22:59,700 --> 00:23:02,790
the multiply so we have to go and do

00:23:00,809 --> 00:23:07,230
something else first so then we descend

00:23:02,790 --> 00:23:09,510
if you like into that so then we can do

00:23:07,230 --> 00:23:12,059
the same thing right so the operator is

00:23:09,510 --> 00:23:13,830
multiply we have left and right and they

00:23:12,059 --> 00:23:16,140
are something that we can do something

00:23:13,830 --> 00:23:20,370
with immediately that's great so we know

00:23:16,140 --> 00:23:22,350
that the values are two and three and so

00:23:20,370 --> 00:23:24,030
we return six from the multiply and then

00:23:22,350 --> 00:23:27,809
we have the value six is the right for

00:23:24,030 --> 00:23:30,000
the end sorry dad and and then we know

00:23:27,809 --> 00:23:34,370
to add one and six and the answer is

00:23:30,000 --> 00:23:37,700
actually seven so we can turn it around

00:23:34,370 --> 00:23:39,780
maybe that's a bit easier to understand

00:23:37,700 --> 00:23:44,160
we have this thing called funnily enough

00:23:39,780 --> 00:23:46,200
reverse polish notation it's kind of

00:23:44,160 --> 00:23:48,360
similar but maybe not as obvious is

00:23:46,200 --> 00:23:49,920
what's going on here it does exactly the

00:23:48,360 --> 00:23:55,200
same thing it's just a different way of

00:23:49,920 --> 00:23:57,210
writing it out to pause this we build a

00:23:55,200 --> 00:24:01,830
stack so we can do this thing called a

00:23:57,210 --> 00:24:03,840
stack interpreter if you like so we've

00:24:01,830 --> 00:24:06,240
got a stack and we're going to step

00:24:03,840 --> 00:24:09,179
through each item one by one if it's not

00:24:06,240 --> 00:24:11,610
operator then we're gonna execute on

00:24:09,179 --> 00:24:14,220
whatever's in this stack otherwise we're

00:24:11,610 --> 00:24:18,270
gonna add it on to the stack all right

00:24:14,220 --> 00:24:19,800
so one by one well this is a number it's

00:24:18,270 --> 00:24:23,010
not an operation so we'll add it to the

00:24:19,800 --> 00:24:24,740
stack the second one's also number so

00:24:23,010 --> 00:24:27,200
we're added to the stack

00:24:24,740 --> 00:24:29,490
it's a number with added to the stack

00:24:27,200 --> 00:24:34,370
fourth one is an operator okay so we

00:24:29,490 --> 00:24:37,830
have to do something now we know that

00:24:34,370 --> 00:24:39,690
the multiply up rater takes two operands

00:24:37,830 --> 00:24:45,660
so we have to take two things off the

00:24:39,690 --> 00:24:49,230
stack 2 and the 3 and then we put the

00:24:45,660 --> 00:24:51,600
result back onto the stack so now we

00:24:49,230 --> 00:24:53,580
have 6 in the stack at the top of the

00:24:51,600 --> 00:24:55,890
stack so the next one is the add

00:24:53,580 --> 00:24:58,290
operator we know we need 2 things for an

00:24:55,890 --> 00:25:00,420
ad because we add two things together so

00:24:58,290 --> 00:25:02,550
we take the two things one in the six

00:25:00,420 --> 00:25:06,660
off and then we put the result back on

00:25:02,550 --> 00:25:10,830
which is indeed 7 and then we've reached

00:25:06,660 --> 00:25:13,860
the end of the input the final result of

00:25:10,830 --> 00:25:15,840
that particular operation is the single

00:25:13,860 --> 00:25:18,870
item left in the stack we know it's 7

00:25:15,840 --> 00:25:22,290
right if you have more than one thing

00:25:18,870 --> 00:25:27,030
left on the stack or no items in the

00:25:22,290 --> 00:25:29,790
stack something's broken ok all right so

00:25:27,030 --> 00:25:32,160
now we have armed ourselves with some

00:25:29,790 --> 00:25:33,660
interesting and dangerous knowledge we

00:25:32,160 --> 00:25:36,320
can now write a compiler very very

00:25:33,660 --> 00:25:38,940
simple one and I'm going to constrain it

00:25:36,320 --> 00:25:42,480
for the sake of keeping it within this

00:25:38,940 --> 00:25:44,790
talk and we're going to use an ast in it

00:25:42,480 --> 00:25:47,210
as well of course so we can do this in

00:25:44,790 --> 00:25:49,620
three easy steps

00:25:47,210 --> 00:25:53,880
don't use this in production now because

00:25:49,620 --> 00:25:55,970
it's terrible if you like github things

00:25:53,880 --> 00:25:58,860
you can have a look at the source code

00:25:55,970 --> 00:26:02,550
on github comm slash as Grimm slash

00:25:58,860 --> 00:26:05,010
basic maths compiler and all the code

00:26:02,550 --> 00:26:07,650
that you'll see on this slide is there

00:26:05,010 --> 00:26:10,380
in its entirety but not slightly

00:26:07,650 --> 00:26:13,680
redacted to fit on tiny little slides on

00:26:10,380 --> 00:26:15,510
this huge screen so first of all when we

00:26:13,680 --> 00:26:20,130
want to write a programming language you

00:26:15,510 --> 00:26:21,690
have to define what's in it our language

00:26:20,130 --> 00:26:24,120
is just going to be basic sums okay

00:26:21,690 --> 00:26:26,760
just maths hence the name basic maths

00:26:24,120 --> 00:26:30,690
compiler all right so we're only going

00:26:26,760 --> 00:26:33,879
to use positive integers so nothing

00:26:30,690 --> 00:26:36,519
negative simplifies things somewhat

00:26:33,879 --> 00:26:37,419
we're going to allow whitespace but

00:26:36,519 --> 00:26:39,580
we're going to ignore it

00:26:37,419 --> 00:26:41,379
and we're going to have four operators

00:26:39,580 --> 00:26:43,960
there's only four things you can do add

00:26:41,379 --> 00:26:46,679
subtract multiply divide and we're only

00:26:43,960 --> 00:26:48,820
going to support one line of input and

00:26:46,679 --> 00:26:50,739
another thing to simplify this even

00:26:48,820 --> 00:26:52,600
further is that we're not going to allow

00:26:50,739 --> 00:26:54,489
any way to override the order of

00:26:52,600 --> 00:26:56,289
precedence so no brackets or anything

00:26:54,489 --> 00:26:59,139
like that to say or execute this bit

00:26:56,289 --> 00:27:02,350
first and all that because it gets a bit

00:26:59,139 --> 00:27:06,399
complicated so first up we write the

00:27:02,350 --> 00:27:09,340
lexer a very simple lexer can be written

00:27:06,399 --> 00:27:13,090
just with regular expressions who loves

00:27:09,340 --> 00:27:18,940
regular expressions who hates them it's

00:27:13,090 --> 00:27:20,289
the other hands right so whether you

00:27:18,940 --> 00:27:23,230
love them or hate them regular regular

00:27:20,289 --> 00:27:24,669
expressions can be used here so we're

00:27:23,230 --> 00:27:27,940
going to define them and notice that all

00:27:24,669 --> 00:27:29,649
of them if you don't know regular

00:27:27,940 --> 00:27:31,929
expression syntax very well the

00:27:29,649 --> 00:27:34,230
circumflex at the start means you always

00:27:31,929 --> 00:27:38,249
match the start of the string okay and

00:27:34,230 --> 00:27:40,509
then we've got the plus or minus

00:27:38,249 --> 00:27:42,549
multiply divide some of them have to be

00:27:40,509 --> 00:27:45,009
escaped with a backslash to make sure

00:27:42,549 --> 00:27:49,239
that they plans properly and so on

00:27:45,009 --> 00:27:52,570
backslash D plus is a number in any

00:27:49,239 --> 00:27:57,119
digit if you like back so S is any white

00:27:52,570 --> 00:27:57,119
space so any amount of white space fine

00:27:57,299 --> 00:28:02,440
but by using that circumflex there we

00:28:00,249 --> 00:28:04,509
ensure that always matching the next

00:28:02,440 --> 00:28:06,100
token not something further on down in

00:28:04,509 --> 00:28:07,509
our string because we want to do this in

00:28:06,100 --> 00:28:09,700
order right we don't want to say oh

00:28:07,509 --> 00:28:11,409
there's a number over there because oh

00:28:09,700 --> 00:28:13,210
the other way around there's a number

00:28:11,409 --> 00:28:15,460
over there yeah because that's gonna

00:28:13,210 --> 00:28:17,470
screw up our lexer so we always want to

00:28:15,460 --> 00:28:19,330
match the start of the string and then

00:28:17,470 --> 00:28:21,820
we move along the string bit by bit all

00:28:19,330 --> 00:28:25,330
right so we're going to step through the

00:28:21,820 --> 00:28:27,509
string like I said bit by bit and what

00:28:25,330 --> 00:28:31,419
this bit of code here does just to

00:28:27,509 --> 00:28:33,669
explain it we analyze from the offset

00:28:31,419 --> 00:28:36,070
onwards each time and we try all of

00:28:33,669 --> 00:28:40,230
those regular expressions each time we

00:28:36,070 --> 00:28:42,909
move the offset on if we match something

00:28:40,230 --> 00:28:44,769
I've used this fancy word lexeme

00:28:42,909 --> 00:28:45,740
basically that's the thing that got

00:28:44,769 --> 00:28:51,290
matched

00:28:45,740 --> 00:28:53,059
see word for that okay and the match is

00:28:51,290 --> 00:28:54,500
just we literally loop through the

00:28:53,059 --> 00:28:56,870
regular expressions and see if any of

00:28:54,500 --> 00:28:58,880
them match that's it if they do great

00:28:56,870 --> 00:28:59,840
we've matched something so we create

00:28:58,880 --> 00:29:01,640
this token object

00:28:59,840 --> 00:29:04,670
I like making objects all over the place

00:29:01,640 --> 00:29:06,800
let's make another object alright so

00:29:04,670 --> 00:29:10,929
that's it that's a lexer done that was

00:29:06,800 --> 00:29:16,610
it Sonne now we need to pass the tokens

00:29:10,929 --> 00:29:18,770
okay before we can do this though we

00:29:16,610 --> 00:29:21,890
need to know the order of precedence as

00:29:18,770 --> 00:29:23,620
I explained this something very

00:29:21,890 --> 00:29:26,600
important for programming languages

00:29:23,620 --> 00:29:31,580
we're gonna use standard operator

00:29:26,600 --> 00:29:33,290
precedence here it's kind of in inverse

00:29:31,580 --> 00:29:35,330
order basically the highest value is the

00:29:33,290 --> 00:29:37,790
most important precedence if you like so

00:29:35,330 --> 00:29:44,120
multiply then divide then add then

00:29:37,790 --> 00:29:46,610
subtract so the list of tokens we get

00:29:44,120 --> 00:29:49,670
from our parser or the array of tokens

00:29:46,610 --> 00:29:51,860
or stack of tokens is it is in the

00:29:49,670 --> 00:29:54,530
correct vernacular we're going to loop

00:29:51,860 --> 00:29:56,540
over that okay and we're going to create

00:29:54,530 --> 00:30:00,230
two other stacks as we as we go through

00:29:56,540 --> 00:30:02,090
this alright we're gonna have our token

00:30:00,230 --> 00:30:05,570
stack which is the output stack so we've

00:30:02,090 --> 00:30:08,300
made sense of this right and a temporary

00:30:05,570 --> 00:30:10,790
operator stack which is going to be we

00:30:08,300 --> 00:30:12,980
gonna chuck stuff in probably operators

00:30:10,790 --> 00:30:18,740
the name may suggest and then take them

00:30:12,980 --> 00:30:22,520
out and so on if the token that we find

00:30:18,740 --> 00:30:24,920
is an operator that is its add subtract

00:30:22,520 --> 00:30:26,630
multiply divide then we're going to do a

00:30:24,920 --> 00:30:33,410
load of other code right so this is

00:30:26,630 --> 00:30:35,990
inside that if block basically if it's a

00:30:33,410 --> 00:30:40,580
operate operator we're gonna put it on

00:30:35,990 --> 00:30:44,660
the operator stack and move on and going

00:30:40,580 --> 00:30:46,640
backwards of it if we find something in

00:30:44,660 --> 00:30:48,230
the operator stack that has a higher

00:30:46,640 --> 00:30:50,870
precedence of the operator that we're

00:30:48,230 --> 00:30:52,580
looking at then we're then going to pop

00:30:50,870 --> 00:30:57,330
it out of the operator stack and put it

00:30:52,580 --> 00:30:59,999
onto the output stack all right

00:30:57,330 --> 00:31:01,739
and then at the end we clean up any

00:30:59,999 --> 00:31:03,570
leftover operators in the operator stack

00:31:01,739 --> 00:31:05,100
and put them onto the output stack so

00:31:03,570 --> 00:31:07,669
then everything ends up on this output

00:31:05,100 --> 00:31:12,330
stack all right and then we return it

00:31:07,669 --> 00:31:14,129
right so what all we're doing here is

00:31:12,330 --> 00:31:16,950
just reordering shuffling the tokens

00:31:14,129 --> 00:31:20,999
around into something that is more

00:31:16,950 --> 00:31:22,799
meaningful to our compiler so let's try

00:31:20,999 --> 00:31:25,110
and visualize this with a an amazingly

00:31:22,799 --> 00:31:27,360
drawn Noda boxes so we're going to go

00:31:25,110 --> 00:31:28,739
through one by one okay this one is a

00:31:27,360 --> 00:31:30,389
value so we're going to put it onto the

00:31:28,739 --> 00:31:32,399
output stack oh this one's an operator

00:31:30,389 --> 00:31:35,669
so pop it onto the push it onto the

00:31:32,399 --> 00:31:37,619
operator stack okay there's nothing of a

00:31:35,669 --> 00:31:41,700
higher precedence there so that's fine

00:31:37,619 --> 00:31:43,259
we can just add it on and then we add

00:31:41,700 --> 00:31:44,909
two to the output stack that's very

00:31:43,259 --> 00:31:47,070
simple the multiply operator comes back

00:31:44,909 --> 00:31:48,629
so it's an operator we check the stack

00:31:47,070 --> 00:31:53,429
if the last thing has a higher

00:31:48,629 --> 00:31:54,989
precedence which it doesn't then we

00:31:53,429 --> 00:31:57,600
would have popped it off but it doesn't

00:31:54,989 --> 00:32:01,289
okay so we just add the multiply on to

00:31:57,600 --> 00:32:03,090
the operator stack finally the last one

00:32:01,289 --> 00:32:04,440
is just a value and then we need to do

00:32:03,090 --> 00:32:05,639
our cleanup we need to take all the

00:32:04,440 --> 00:32:08,909
operators and put them onto the output

00:32:05,639 --> 00:32:12,600
stack okay and does this look familiar

00:32:08,909 --> 00:32:14,190
this is the reverse polish notation we

00:32:12,600 --> 00:32:16,169
looked at so what we've done is we've

00:32:14,190 --> 00:32:17,730
taken this big stream of tokens or

00:32:16,169 --> 00:32:20,070
potentially big stream of tokens and

00:32:17,730 --> 00:32:24,409
we've shuffled them all around into this

00:32:20,070 --> 00:32:27,929
notation that we can use in our compiler

00:32:24,409 --> 00:32:31,470
so now we need to create the ast but

00:32:27,929 --> 00:32:33,210
because we have this order this stack of

00:32:31,470 --> 00:32:36,269
tokens in the right order we can

00:32:33,210 --> 00:32:41,369
actually like take those tokens and very

00:32:36,269 --> 00:32:43,080
simply make them into a tree so we

00:32:41,369 --> 00:32:46,019
progress through the stack again so we

00:32:43,080 --> 00:32:47,759
live in another loop IP is the

00:32:46,019 --> 00:32:49,080
instruction pointer which is useful if

00:32:47,759 --> 00:32:51,299
you start getting a bit more complicated

00:32:49,080 --> 00:32:52,679
and like going back through the stack

00:32:51,299 --> 00:32:54,749
and then forward through the stack and

00:32:52,679 --> 00:32:56,549
so on which we don't have to in this

00:32:54,749 --> 00:32:58,499
compiler it's fine we can ignore that

00:32:56,549 --> 00:33:02,999
but it gets a bit more complicated

00:32:58,499 --> 00:33:05,399
perhaps so it defines where we are in

00:33:02,999 --> 00:33:08,789
the stack so then we just create the ast

00:33:05,399 --> 00:33:10,530
right if it's a value we just say well

00:33:08,789 --> 00:33:13,380
that's an integer value and we give

00:33:10,530 --> 00:33:14,790
the the lexeme we pass the lexeme to it

00:33:13,380 --> 00:33:16,950
and cast it to an integer because it's a

00:33:14,790 --> 00:33:18,570
number right the lexeme is the bits

00:33:16,950 --> 00:33:22,740
that's matched so that's going to be the

00:33:18,570 --> 00:33:26,220
numbers right if it's an operator we

00:33:22,740 --> 00:33:27,960
need to figure out what kind of operator

00:33:26,220 --> 00:33:29,940
it is there's a bit of code that I've

00:33:27,960 --> 00:33:30,240
emitted there but we figure out what it

00:33:29,940 --> 00:33:33,690
is

00:33:30,240 --> 00:33:35,670
store it in dollar note type and then we

00:33:33,690 --> 00:33:38,820
create this ast node so we're

00:33:35,670 --> 00:33:42,810
representing our ast is a tree of PHP

00:33:38,820 --> 00:33:44,670
objects here and because these are all

00:33:42,810 --> 00:33:47,610
binary operators they both need the left

00:33:44,670 --> 00:33:49,500
and the right okay so we passed those so

00:33:47,610 --> 00:33:52,290
we take them off the stack using that

00:33:49,500 --> 00:33:56,550
stack compiler thing alright and we make

00:33:52,290 --> 00:33:57,750
the s2 you know there so there we have

00:33:56,550 --> 00:34:00,720
it it would look something like this

00:33:57,750 --> 00:34:02,970
right we have our ad we have the integer

00:34:00,720 --> 00:34:06,830
value one perhaps and then a multiply

00:34:02,970 --> 00:34:09,120
and we have the two integer values right

00:34:06,830 --> 00:34:11,929
so then we need to go through this we

00:34:09,120 --> 00:34:17,010
have this passed now so we need to

00:34:11,929 --> 00:34:19,290
execute it and again this is quite an

00:34:17,010 --> 00:34:23,700
easy part we're going to create this

00:34:19,290 --> 00:34:25,890
tiny virtual machine it's kind of

00:34:23,700 --> 00:34:27,929
Inception there because PHP is running

00:34:25,890 --> 00:34:29,159
in a virtual machine and we're creating

00:34:27,929 --> 00:34:31,380
a virtual machine in the virtual machine

00:34:29,159 --> 00:34:36,810
and if you run it inside vagrant it's

00:34:31,380 --> 00:34:38,429
inside of another work anyway lulz we

00:34:36,810 --> 00:34:40,050
descend through the abstract syntax tree

00:34:38,429 --> 00:34:41,970
and execute things as we come to them

00:34:40,050 --> 00:34:44,159
that's basically it but we can't execute

00:34:41,970 --> 00:34:45,480
it until we go all the way down the tree

00:34:44,159 --> 00:34:50,360
and figure out what we're trying to

00:34:45,480 --> 00:34:53,610
execute right so we have this recursive

00:34:50,360 --> 00:34:55,320
calling of this compile node function so

00:34:53,610 --> 00:34:58,590
this is like our entry point for our

00:34:55,320 --> 00:35:00,690
compiler so at the top if we know it's a

00:34:58,590 --> 00:35:02,160
binary operator so all the binary

00:35:00,690 --> 00:35:05,220
operators in it is in this particular

00:35:02,160 --> 00:35:06,660
source code extend from this abstract

00:35:05,220 --> 00:35:09,270
binary operator you could do an

00:35:06,660 --> 00:35:11,310
interface that would work as well and

00:35:09,270 --> 00:35:13,890
then we call another function called

00:35:11,310 --> 00:35:16,560
call compiled binary op we'll come to

00:35:13,890 --> 00:35:19,320
that in a moment if it's a scalar value

00:35:16,560 --> 00:35:21,960
ie are integer then we're just going to

00:35:19,320 --> 00:35:23,790
return the value directly that's it

00:35:21,960 --> 00:35:24,420
that's what we need to do there we don't

00:35:23,790 --> 00:35:27,150
have any other

00:35:24,420 --> 00:35:27,710
Oh types we're ignoring whitespace so

00:35:27,150 --> 00:35:29,880
that's it

00:35:27,710 --> 00:35:33,000
so the compiled binary up let's have a

00:35:29,880 --> 00:35:39,420
look this is where kind of the meat of

00:35:33,000 --> 00:35:44,190
it exists now we don't know whether left

00:35:39,420 --> 00:35:46,650
and right are values that we can use

00:35:44,190 --> 00:35:50,730
straight away so actually what we have

00:35:46,650 --> 00:35:52,140
to do is pass left and right into the

00:35:50,730 --> 00:35:57,030
compiled node function so that's where

00:35:52,140 --> 00:35:58,950
the recursion comes from once we've done

00:35:57,030 --> 00:36:01,380
that eventually you know there might be

00:35:58,950 --> 00:36:03,720
another add or multiply whichever

00:36:01,380 --> 00:36:06,270
there's multiply wasn't it so one of the

00:36:03,720 --> 00:36:07,680
sides is going to be multiplied so then

00:36:06,270 --> 00:36:10,559
actually it would go back into compiled

00:36:07,680 --> 00:36:13,049
binary up and then call compiled node on

00:36:10,559 --> 00:36:16,650
the left and right and we get that time

00:36:13,049 --> 00:36:19,349
we'd get integers right so left and

00:36:16,650 --> 00:36:22,650
right eventually hopefully will turn

00:36:19,349 --> 00:36:24,390
into integers and then we figure out the

00:36:22,650 --> 00:36:26,910
the type of the node so whether it's

00:36:24,390 --> 00:36:28,799
multiply sorry abs subtract multiply or

00:36:26,910 --> 00:36:31,619
divide we've got a switch here as you

00:36:28,799 --> 00:36:37,020
can see and we just run it we'll just do

00:36:31,619 --> 00:36:40,250
add subtract multiply divide and that's

00:36:37,020 --> 00:36:42,930
it alright so what does it mean for me

00:36:40,250 --> 00:36:47,450
on the surface this doesn't seem very

00:36:42,930 --> 00:36:52,230
relevant to our day-to-day jobs perhaps

00:36:47,450 --> 00:36:57,119
unless you're Derek but what it does

00:36:52,230 --> 00:36:59,430
mean is that we get a nice bonus along

00:36:57,119 --> 00:37:02,069
with the other optimizations in PHP 7

00:36:59,430 --> 00:37:05,700
and so on that we have faster and more

00:37:02,069 --> 00:37:07,470
efficient code ast is one of those

00:37:05,700 --> 00:37:11,099
reasons faster

00:37:07,470 --> 00:37:13,559
asterisk yeah but it does mean that we

00:37:11,099 --> 00:37:15,750
have some nice scope for optimizations

00:37:13,559 --> 00:37:18,180
in the future as well and I believe some

00:37:15,750 --> 00:37:20,339
of those are sort of being discussed or

00:37:18,180 --> 00:37:24,240
some of them being being amplified as

00:37:20,339 --> 00:37:26,280
well which is nice because we can reason

00:37:24,240 --> 00:37:27,990
about how the code goes together a bit

00:37:26,280 --> 00:37:31,829
nicer so we've got this separation from

00:37:27,990 --> 00:37:35,350
the compiler in the parser so it's kind

00:37:31,829 --> 00:37:38,050
of fun and knowing how the engine works

00:37:35,350 --> 00:37:40,300
helped somewhat I would suggest though

00:37:38,050 --> 00:37:42,960
that just because you know how the

00:37:40,300 --> 00:37:45,760
engine works don't necessarily write

00:37:42,960 --> 00:37:47,230
micro silly optimizations it cell wall

00:37:45,760 --> 00:37:49,570
and know this is going to generate a

00:37:47,230 --> 00:37:53,160
more efficient data structure in the AST

00:37:49,570 --> 00:37:55,510
or whatever no PHP is actually a

00:37:53,160 --> 00:37:59,980
brilliant language for people to write

00:37:55,510 --> 00:38:02,860
terrible code and PHP just deals with it

00:37:59,980 --> 00:38:06,220
right and that's evidenced as well by

00:38:02,860 --> 00:38:07,690
the vast improvements in PHP 7 maybe

00:38:06,220 --> 00:38:10,660
even talked about those earlier I didn't

00:38:07,690 --> 00:38:12,250
see his talk but something I mentioned

00:38:10,660 --> 00:38:18,250
earlier as well the ast isn't actually

00:38:12,250 --> 00:38:20,440
specific to PHP but for most programming

00:38:18,250 --> 00:38:22,860
languages apart from the weird ones that

00:38:20,440 --> 00:38:25,240
will ignore most programming languages

00:38:22,860 --> 00:38:26,620
most programming languages work in

00:38:25,240 --> 00:38:28,150
exactly the same way as I've just

00:38:26,620 --> 00:38:32,320
described we Lex

00:38:28,150 --> 00:38:34,210
stuff pars it compile it and that's

00:38:32,320 --> 00:38:38,740
pretty much how you make a programming

00:38:34,210 --> 00:38:40,930
language except some of them right we'll

00:38:38,740 --> 00:38:43,660
ignore those though so this can actually

00:38:40,930 --> 00:38:46,480
help you understand how your code is put

00:38:43,660 --> 00:38:49,680
together and helps you understand

00:38:46,480 --> 00:38:51,580
actually that syntax is just that

00:38:49,680 --> 00:38:53,440
essentially all the regular languages

00:38:51,580 --> 00:38:54,760
just do roughly the same thing in very

00:38:53,440 --> 00:39:00,760
slightly different way with some weird

00:38:54,760 --> 00:39:04,680
quirks fine so can we use this

00:39:00,760 --> 00:39:08,140
well no unfortunately not at the moment

00:39:04,680 --> 00:39:10,270
the AST is not directly available for

00:39:08,140 --> 00:39:14,470
you to say oh what does the AST look

00:39:10,270 --> 00:39:17,340
like for my code but there are ways we

00:39:14,470 --> 00:39:20,560
can do this why would we want to do this

00:39:17,340 --> 00:39:23,170
well it gets us big insights to our code

00:39:20,560 --> 00:39:24,790
what's going on we can examine the

00:39:23,170 --> 00:39:27,610
structure of the code that's going on

00:39:24,790 --> 00:39:30,700
and we can do some magic things as well

00:39:27,610 --> 00:39:34,540
I like magic things there is this

00:39:30,700 --> 00:39:40,270
extension from Nikita Popov called PHP

00:39:34,540 --> 00:39:43,240
ast and that exposes the ast into

00:39:40,270 --> 00:39:45,160
userland so you could then say well have

00:39:43,240 --> 00:39:46,960
a look at this source code and give me

00:39:45,160 --> 00:39:49,420
the ast for it so it gives you a load of

00:39:46,960 --> 00:39:51,820
objects the downside to this

00:39:49,420 --> 00:39:53,710
depending on your opinions on this is

00:39:51,820 --> 00:39:55,990
it's an extension so you have to then go

00:39:53,710 --> 00:39:57,730
and install an extension if you're on

00:39:55,990 --> 00:39:59,190
perhaps a shared host that might be a

00:39:57,730 --> 00:40:01,660
bit more difficult

00:39:59,190 --> 00:40:04,360
maybe you probably don't want to do that

00:40:01,660 --> 00:40:06,010
in production anyway there but this is

00:40:04,360 --> 00:40:08,080
like how would you would use that right

00:40:06,010 --> 00:40:10,600
so we install the extension whether it's

00:40:08,080 --> 00:40:14,620
by Pekka lor compiling it by hand and

00:40:10,600 --> 00:40:16,030
like a nutter you give it some code in

00:40:14,620 --> 00:40:20,860
this case I'm just giving it a string of

00:40:16,030 --> 00:40:23,830
code you use the pile ast backslash pass

00:40:20,860 --> 00:40:26,200
code function and then we've got this

00:40:23,830 --> 00:40:28,150
ast dump which is basically just to help

00:40:26,200 --> 00:40:31,390
her to make it a bit more readable

00:40:28,150 --> 00:40:33,430
because as you kind of saw even with

00:40:31,390 --> 00:40:35,800
that simple math some the ast got pretty

00:40:33,430 --> 00:40:42,580
big and maybe even impossible to read in

00:40:35,800 --> 00:40:47,470
the back so PHP st is what we can use to

00:40:42,580 --> 00:40:50,080
expose PHP is very own internal abstract

00:40:47,470 --> 00:40:52,800
syntax tree to you there is also another

00:40:50,080 --> 00:40:56,020
extension which I advise you don't use

00:40:52,800 --> 00:41:00,820
because it's madness but it called the

00:40:56,020 --> 00:41:03,520
ast kit is anyone use run kit does

00:41:00,820 --> 00:41:06,670
anyone use run kit in production okay

00:41:03,520 --> 00:41:10,750
cool good run kit if you don't know what

00:41:06,670 --> 00:41:12,700
it is it allows you to like unnotice and

00:41:10,750 --> 00:41:13,720
do things you shouldn't probably to be

00:41:12,700 --> 00:41:16,380
doing and things like that

00:41:13,720 --> 00:41:20,440
so ast kit is written by Sarah Coleman

00:41:16,380 --> 00:41:24,550
and it allows you to modify the ast and

00:41:20,440 --> 00:41:27,190
then execute it so in effect what you

00:41:24,550 --> 00:41:29,440
get is this concept you may have heard

00:41:27,190 --> 00:41:30,580
of called monkey-patching which is where

00:41:29,440 --> 00:41:33,670
you take some code change it before you

00:41:30,580 --> 00:41:36,610
run it right which is quite cool the

00:41:33,670 --> 00:41:38,020
downsides are it's an extension and you

00:41:36,610 --> 00:41:40,680
know this is probably not something you

00:41:38,020 --> 00:41:43,450
want to be doing a production alright

00:41:40,680 --> 00:41:45,940
and it was written as just a bit of an

00:41:43,450 --> 00:41:50,080
experiment right so maybe don't use it

00:41:45,940 --> 00:41:53,020
in production so some usage of this

00:41:50,080 --> 00:41:57,010
extension fairly straightforward we give

00:41:53,020 --> 00:42:00,960
it some code and it exposes these extra

00:41:57,010 --> 00:42:02,830
methods like get child get child graft

00:42:00,960 --> 00:42:05,320
and stuff

00:42:02,830 --> 00:42:08,040
basically what that means is changing

00:42:05,320 --> 00:42:09,910
the true in the if into false alright

00:42:08,040 --> 00:42:11,590
because it's a tree you know you're

00:42:09,910 --> 00:42:14,110
getting the children of the tree and

00:42:11,590 --> 00:42:16,030
things like that and grafting is you

00:42:14,110 --> 00:42:17,350
know you're changing things over and so

00:42:16,030 --> 00:42:19,770
on and then you can execute it so the

00:42:17,350 --> 00:42:21,970
first time you execute it it will say

00:42:19,770 --> 00:42:23,350
this is a triumph and then the second

00:42:21,970 --> 00:42:27,220
time you execute it once it's been

00:42:23,350 --> 00:42:29,020
changed it will say the cake is a lie so

00:42:27,220 --> 00:42:30,960
these are these examples are just taken

00:42:29,020 --> 00:42:34,630
from the read meters I didn't write this

00:42:30,960 --> 00:42:36,880
but it demonstrates what these

00:42:34,630 --> 00:42:39,730
extensions are used for but that's not

00:42:36,880 --> 00:42:44,530
all there is this thing called PHP

00:42:39,730 --> 00:42:46,630
parser again is written by Nikita Popov

00:42:44,530 --> 00:42:49,990
who's the author of the PHP ast

00:42:46,630 --> 00:42:52,150
extension and does a lot of work on PHP

00:42:49,990 --> 00:42:55,540
core so he knows how it works which is a

00:42:52,150 --> 00:42:59,920
good start and it's more or less the

00:42:55,540 --> 00:43:02,830
same as the PHP ast extension but it's

00:42:59,920 --> 00:43:03,940
written in PHP so you can install it

00:43:02,830 --> 00:43:09,880
with composer

00:43:03,940 --> 00:43:11,130
you can say just composer require Nickie

00:43:09,880 --> 00:43:13,450
C PHP Pazza

00:43:11,130 --> 00:43:15,970
so the upsides are is not an extension

00:43:13,450 --> 00:43:18,310
it's very easy for anyone to use

00:43:15,970 --> 00:43:20,800
the downside is and there's a really big

00:43:18,310 --> 00:43:28,600
downside to it it's really really really

00:43:20,800 --> 00:43:31,480
slow because it's written in PHP hmm so

00:43:28,600 --> 00:43:32,920
this is how you use it anyway um there

00:43:31,480 --> 00:43:35,020
are use cases for it I'm just getting

00:43:32,920 --> 00:43:37,360
there just don't disregard this at the

00:43:35,020 --> 00:43:39,190
straightaway because it's slow so this

00:43:37,360 --> 00:43:41,590
is how you'd use it very much in the

00:43:39,190 --> 00:43:43,480
same way as the PHP ast extension you

00:43:41,590 --> 00:43:45,510
give it some code in this case I'm just

00:43:43,480 --> 00:43:50,620
doing some file get contents on whatever

00:43:45,510 --> 00:43:52,660
and calling pars and you'll get this big

00:43:50,620 --> 00:43:55,270
old ast depending on how much code you

00:43:52,660 --> 00:43:57,610
have of course all right so it's very

00:43:55,270 --> 00:44:00,640
simple to get the ast then we can do

00:43:57,610 --> 00:44:03,580
stuff with it right so we have this

00:44:00,640 --> 00:44:05,710
library that I'm going to shamelessly

00:44:03,580 --> 00:44:08,110
plug now I don't care

00:44:05,710 --> 00:44:09,520
it's called better reflection is written

00:44:08,110 --> 00:44:13,510
by me and Marco pavetta

00:44:09,520 --> 00:44:15,310
and in short it's the reflection API

00:44:13,510 --> 00:44:16,210
that you may or may not be familiar with

00:44:15,310 --> 00:44:20,619
in PHP

00:44:16,210 --> 00:44:22,660
but it uses the ast instead it's pretty

00:44:20,619 --> 00:44:26,589
flexible is pretty powerful and it

00:44:22,660 --> 00:44:28,240
allows you to do monkey patching so this

00:44:26,589 --> 00:44:29,589
is roughly how it works I'm not gonna go

00:44:28,240 --> 00:44:31,000
into too much detail because this isn't

00:44:29,589 --> 00:44:35,589
a talk about better reflection which I

00:44:31,000 --> 00:44:37,000
want to make it relevant though we have

00:44:35,589 --> 00:44:39,190
this reflector which is like the public

00:44:37,000 --> 00:44:42,730
API that's how you do reflecting in

00:44:39,190 --> 00:44:44,170
better reflection the source locator is

00:44:42,730 --> 00:44:48,369
basically instructions for better

00:44:44,170 --> 00:44:50,380
reflection to find your code the reason

00:44:48,369 --> 00:44:53,170
why we do this is because we can now

00:44:50,380 --> 00:44:56,170
reflect on code that doesn't exist to

00:44:53,170 --> 00:44:58,680
PHP yet so you could reflect on a load

00:44:56,170 --> 00:45:01,240
of code that hasn't yet been loaded

00:44:58,680 --> 00:45:03,820
change it beforehand and then run it

00:45:01,240 --> 00:45:06,220
right that's the point so this uses PHP

00:45:03,820 --> 00:45:07,510
parser that's like the main part of it

00:45:06,220 --> 00:45:09,369
if you like and then it returns there's

00:45:07,510 --> 00:45:11,530
this reflection it's got all the methods

00:45:09,369 --> 00:45:12,940
that you're most of the methods you're

00:45:11,530 --> 00:45:15,820
used to when you're using normal

00:45:12,940 --> 00:45:18,609
reflection but a few extra ones like get

00:45:15,820 --> 00:45:21,609
ast and get body ast and things like

00:45:18,609 --> 00:45:22,900
that so you can start looking at like

00:45:21,609 --> 00:45:24,400
the content of your methods in your

00:45:22,900 --> 00:45:29,170
classes and functions and things like

00:45:24,400 --> 00:45:31,060
that okay the API is roughly similar

00:45:29,170 --> 00:45:32,800
instead of saying new reflection class

00:45:31,060 --> 00:45:34,300
we have this new better reflection we

00:45:32,800 --> 00:45:36,580
get a class reflector and stuff like

00:45:34,300 --> 00:45:39,760
that as there's there's examples on

00:45:36,580 --> 00:45:41,890
there doesn't really matter too much but

00:45:39,760 --> 00:45:43,119
we're returning this reflection right so

00:45:41,890 --> 00:45:46,210
we're using some same defaults we're

00:45:43,119 --> 00:45:50,109
using whatever autoloaders is registered

00:45:46,210 --> 00:45:53,589
in your SPL autoload add thing which is

00:45:50,109 --> 00:45:55,300
usually going to be composer right so

00:45:53,589 --> 00:45:57,520
anything that can compose composer can

00:45:55,300 --> 00:45:59,530
load we can know too but we don't

00:45:57,520 --> 00:46:02,109
actually have to load it to look at it

00:45:59,530 --> 00:46:04,480
we just grab the source code feed it

00:46:02,109 --> 00:46:08,470
into PHP parser and then we have the

00:46:04,480 --> 00:46:10,720
reflections which is kind of cool so

00:46:08,470 --> 00:46:13,540
this is that source locator and class

00:46:10,720 --> 00:46:15,750
reflector stuff the defaults are that we

00:46:13,540 --> 00:46:17,650
can reflect on PHP is internal source

00:46:15,750 --> 00:46:20,260
because there's a load of stuff there

00:46:17,650 --> 00:46:22,420
and that's an awful mess so even all

00:46:20,260 --> 00:46:26,290
that eval code if you're evil enough to

00:46:22,420 --> 00:46:28,750
be using eval and then your auto load

00:46:26,290 --> 00:46:29,710
one which does some magic under the hood

00:46:28,750 --> 00:46:33,130
which is kind of funny

00:46:29,710 --> 00:46:35,890
it takes the it overwrites your

00:46:33,130 --> 00:46:37,990
filestream wrapper and then it will say

00:46:35,890 --> 00:46:40,300
does your class exist so that will

00:46:37,990 --> 00:46:42,520
trigger your auto loader to say oh open

00:46:40,300 --> 00:46:45,220
this file but instead we've overwritten

00:46:42,520 --> 00:46:46,930
the file stream wrapper and then we stop

00:46:45,220 --> 00:46:49,450
it from actually being loaded we just

00:46:46,930 --> 00:46:52,450
grab the file name and then we restore

00:46:49,450 --> 00:46:54,040
the file stream wrapper and then we have

00:46:52,450 --> 00:46:55,869
the file name so then we can open it

00:46:54,040 --> 00:46:57,640
with PHP parser so that class never

00:46:55,869 --> 00:47:00,010
actually has to be loaded for us to look

00:46:57,640 --> 00:47:02,950
at it we just grab the source code of it

00:47:00,010 --> 00:47:05,410
directly which works in like 99% of

00:47:02,950 --> 00:47:08,680
cases if you're loading your source code

00:47:05,410 --> 00:47:10,390
from something like a database which is

00:47:08,680 --> 00:47:13,810
really weird but you know it wouldn't

00:47:10,390 --> 00:47:16,180
work or if you're loading it from a

00:47:13,810 --> 00:47:17,859
memory stream or something like that

00:47:16,180 --> 00:47:20,080
which is also a bit weird

00:47:17,859 --> 00:47:22,359
most people load them from files right

00:47:20,080 --> 00:47:27,040
that's where we store source code so it

00:47:22,359 --> 00:47:28,750
works most of the time so given a class

00:47:27,040 --> 00:47:31,750
structure like this fairly

00:47:28,750 --> 00:47:33,250
straightforward we get the ast that

00:47:31,750 --> 00:47:36,330
looks like this right so we get all of

00:47:33,250 --> 00:47:39,550
the nodes we get all the structure of

00:47:36,330 --> 00:47:42,280
the code and I've simplified it down

00:47:39,550 --> 00:47:44,980
because that would be huge so we get the

00:47:42,280 --> 00:47:48,369
class node with an array of statements

00:47:44,980 --> 00:47:50,890
so the statements are the body of the

00:47:48,369 --> 00:47:52,270
class and we have the property node and

00:47:50,890 --> 00:47:53,470
the property node has types and

00:47:52,270 --> 00:47:56,260
attributes and things like that we have

00:47:53,470 --> 00:47:57,849
the method node has a type some

00:47:56,260 --> 00:48:00,450
parameters obviously a name and things

00:47:57,849 --> 00:48:02,710
like that statements within the method

00:48:00,450 --> 00:48:03,849
actually we didn't have any statements

00:48:02,710 --> 00:48:07,750
within the method so that should be an

00:48:03,849 --> 00:48:09,430
empty array any any relevant attributes

00:48:07,750 --> 00:48:13,750
like start line end line things like

00:48:09,430 --> 00:48:18,160
that so what can I use better reflection

00:48:13,750 --> 00:48:19,660
for right so we have this ast great so

00:48:18,160 --> 00:48:21,310
we can do some monkey patching as I kind

00:48:19,660 --> 00:48:23,500
of explained you've got a class for

00:48:21,310 --> 00:48:25,710
example my class and it returns five

00:48:23,500 --> 00:48:27,910
very simple all right

00:48:25,710 --> 00:48:29,380
so we can use better reflection to

00:48:27,910 --> 00:48:31,750
reflect on that as I said it kind of

00:48:29,380 --> 00:48:34,089
doesn't necessarily it what sorry it

00:48:31,750 --> 00:48:39,330
doesn't load your code into memory so we

00:48:34,089 --> 00:48:41,440
can grab the ast of that because

00:48:39,330 --> 00:48:43,330
hopefully as you know I'm certain if you

00:48:41,440 --> 00:48:46,060
use rank it you know that once you

00:48:43,330 --> 00:48:49,960
have loaded a class in PHP you can't

00:48:46,060 --> 00:48:53,560
change it that's one of the benefits of

00:48:49,960 --> 00:48:56,680
run kit so we can do this instead we can

00:48:53,560 --> 00:48:59,530
say grabbing the source code find me the

00:48:56,680 --> 00:49:03,640
ast of it make sure you do it before the

00:48:59,530 --> 00:49:05,020
class is loaded of course then we use

00:49:03,640 --> 00:49:07,270
this class loader and we're going to

00:49:05,020 --> 00:49:08,320
cache it in a file right and so we don't

00:49:07,270 --> 00:49:12,640
have to keep doing this over and over

00:49:08,320 --> 00:49:13,750
again do this after all the other walter

00:49:12,640 --> 00:49:15,430
loaders because this class loader

00:49:13,750 --> 00:49:18,400
actually registers its own auto loader

00:49:15,430 --> 00:49:21,130
to go in the way of composer if you like

00:49:18,400 --> 00:49:23,230
and say well if you try and instantiate

00:49:21,130 --> 00:49:25,390
the class that you're looking for and I

00:49:23,230 --> 00:49:27,730
know about this and I've changed it then

00:49:25,390 --> 00:49:32,290
I will make my own evil monkey patched

00:49:27,730 --> 00:49:33,790
version instead so then we can use the

00:49:32,290 --> 00:49:36,520
reflection we can say get method foo

00:49:33,790 --> 00:49:38,200
which is familiar probably if you use

00:49:36,520 --> 00:49:40,150
reflection to get a method of over

00:49:38,200 --> 00:49:42,280
reflection but we also have this new

00:49:40,150 --> 00:49:43,720
function that doesn't exist in call

00:49:42,280 --> 00:49:45,970
reflection called set body from closure

00:49:43,720 --> 00:49:51,460
and we can pass it a closure in this

00:49:45,970 --> 00:49:54,100
case a function that returns 4 you can

00:49:51,460 --> 00:49:55,900
also set the body from a string if you

00:49:54,100 --> 00:49:58,960
don't like writing functions or you can

00:49:55,900 --> 00:50:02,140
pass it a load of ast nodes that are in

00:49:58,960 --> 00:50:04,540
the format of nikita's PHP parser ast

00:50:02,140 --> 00:50:06,670
nodes and it does have like this whole

00:50:04,540 --> 00:50:10,000
way of building ast nodes which is kind

00:50:06,670 --> 00:50:11,470
of nice but basically what we're doing

00:50:10,000 --> 00:50:14,800
is we're making that method return 4

00:50:11,470 --> 00:50:16,510
instead of 5 it's a kind of fairly

00:50:14,800 --> 00:50:18,250
straightforward change so the autoloader

00:50:16,510 --> 00:50:20,620
that we registered that class loader

00:50:18,250 --> 00:50:24,280
will kick in and say oh you're trying to

00:50:20,620 --> 00:50:26,230
instantiate my class and it will allow

00:50:24,280 --> 00:50:29,050
us to load the modified version of that

00:50:26,230 --> 00:50:37,420
code so now it will return for not 5

00:50:29,050 --> 00:50:39,700
hahaha alright so for the PHP engine ast

00:50:37,420 --> 00:50:44,020
is a nice efficient data structure that

00:50:39,700 --> 00:50:46,360
we can use to represent code it means

00:50:44,020 --> 00:50:49,240
that compilation step is faster

00:50:46,360 --> 00:50:50,560
obviously when you factor in the OP

00:50:49,240 --> 00:50:53,290
cache it doesn't make any difference in

00:50:50,560 --> 00:50:55,140
runtime really maybe like the first time

00:50:53,290 --> 00:50:57,730
you run that

00:50:55,140 --> 00:51:00,930
but it provides that nice separation

00:50:57,730 --> 00:51:04,120
from the parser and the compiler but

00:51:00,930 --> 00:51:06,580
what's more useful to us normal

00:51:04,120 --> 00:51:09,580
developers who don't delve into PHP

00:51:06,580 --> 00:51:12,120
score too much not that you're not

00:51:09,580 --> 00:51:14,710
normal Derrick I'm sorry I apologize

00:51:12,120 --> 00:51:16,090
these concepts can be used in userland

00:51:14,710 --> 00:51:17,830
and they are very useful so we've got

00:51:16,090 --> 00:51:21,010
the PHP parser library which means we

00:51:17,830 --> 00:51:23,830
can do this straightaway and we can do

00:51:21,010 --> 00:51:25,750
it slowly of course but we have better

00:51:23,830 --> 00:51:27,610
reflection which is based on PHP parser

00:51:25,750 --> 00:51:29,290
so you can reflect on stuff that's not

00:51:27,610 --> 00:51:31,750
yet loaded and maybe do some kind of

00:51:29,290 --> 00:51:33,550
introspection and things like that or if

00:51:31,750 --> 00:51:38,320
you feel like doing monkey patching then

00:51:33,550 --> 00:51:41,050
maybe do that but for me the biggest

00:51:38,320 --> 00:51:43,150
revelation of this has been in the

00:51:41,050 --> 00:51:48,130
ability to make better static analysis

00:51:43,150 --> 00:51:50,530
tools there was a talk last year in this

00:51:48,130 --> 00:51:53,290
room in fact because I watched it about

00:51:50,530 --> 00:51:54,940
a tool called exa cat which uses the ast

00:51:53,290 --> 00:51:57,010
as well to do static analysis and

00:51:54,940 --> 00:51:58,510
analysis if you're not sure what static

00:51:57,010 --> 00:51:59,800
analysis is it's basically looking at

00:51:58,510 --> 00:52:02,560
your code and seeing where it's going

00:51:59,800 --> 00:52:05,440
wrong not debugging that's a different

00:52:02,560 --> 00:52:07,150
thing it's kind of looking at things

00:52:05,440 --> 00:52:09,670
like types and saying well does this

00:52:07,150 --> 00:52:11,560
function accept the right types that

00:52:09,670 --> 00:52:13,270
it's using and things like that are you

00:52:11,560 --> 00:52:15,040
passing the right types to a function

00:52:13,270 --> 00:52:17,230
obviously if you're using strict type

00:52:15,040 --> 00:52:19,390
declarations that will now throw lots of

00:52:17,230 --> 00:52:22,000
errors but certainly in PHP 5 code and

00:52:19,390 --> 00:52:23,830
before this kind of thing is going to be

00:52:22,000 --> 00:52:25,990
immensely useful so maybe we can use it

00:52:23,830 --> 00:52:28,090
to look at the doc blocks and say well

00:52:25,990 --> 00:52:29,620
you're using this function and passing

00:52:28,090 --> 00:52:31,780
it an integer but the doc blocks a

00:52:29,620 --> 00:52:39,130
string so what's going on it's wrong

00:52:31,780 --> 00:52:43,090
right and just uses phpstorm ok many of

00:52:39,130 --> 00:52:45,160
you it does static analysis as you're

00:52:43,090 --> 00:52:46,540
writing code so when it says the little

00:52:45,160 --> 00:52:48,310
screen underlines and it will say oh

00:52:46,540 --> 00:52:49,420
this doesn't look right that's what it's

00:52:48,310 --> 00:52:52,990
doing is looking at your code it's not

00:52:49,420 --> 00:52:53,440
running it it's statically analyzing it

00:52:52,990 --> 00:52:56,680
right

00:52:53,440 --> 00:53:00,520
there's also another tool called fan pH

00:52:56,680 --> 00:53:05,290
aan not FM which uses the PHP ast it's

00:53:00,520 --> 00:53:07,400
our PHP ast extension and that does a

00:53:05,290 --> 00:53:09,260
load of static analysis as well

00:53:07,400 --> 00:53:11,480
it was originally written by Rasmus and

00:53:09,260 --> 00:53:13,039
then some other people have taken over

00:53:11,480 --> 00:53:14,960
and now maintaining it it's a very

00:53:13,039 --> 00:53:17,770
useful tool and these kind of tools you

00:53:14,960 --> 00:53:20,690
can stick into your CI environment and

00:53:17,770 --> 00:53:22,549
then make sure nothing breaks or nothing

00:53:20,690 --> 00:53:24,980
obvious breaks perhaps it's a better way

00:53:22,549 --> 00:53:28,640
of putting it so it allows you to catch

00:53:24,980 --> 00:53:31,539
your bugs faster so actually it's cool

00:53:28,640 --> 00:53:31,539

YouTube URL: https://www.youtube.com/watch?v=AEfkYUjEuSs


