Title: PHP UK Conference 2018 - Chris Riley - The secrets of Cryptography
Publication date: 2018-03-27
Playlist: PHP UK Conference 2018
Description: 
	Alice and Bob have secrets they want to talk about without Eve being able to listen in. Worse yet, the mischievous Mallory delights in changing messages sent between parties. In such a hostile environment how can Alice talk to Bob without their messages being overheard and how can she be sure that it was Bob that sent the message in the first place? This talk will take a brief look at historic codes and ciphers before taking a look at modern day Cryptography. If you want to be able to know the difference between a block cipher and a stream cipher or get a glimpse into the mathematics behind public key Cryptography this talk is for you.
Captions: 
	00:00:02,510 --> 00:00:08,280
okay so as you probably guessed this is

00:00:05,609 --> 00:00:12,210
a talk about cryptography I warn you

00:00:08,280 --> 00:00:15,839
upfront it's quite theory heavy not a

00:00:12,210 --> 00:00:18,990
great deal of PHP code and I am aware it

00:00:15,839 --> 00:00:24,920
is 4:00 p.m. on Friday so please try and

00:00:18,990 --> 00:00:27,119
stay in the room so some introduction

00:00:24,920 --> 00:00:29,939
what what is it that we talked about we

00:00:27,119 --> 00:00:32,550
talked about cryptography so modern

00:00:29,939 --> 00:00:34,530
cryptography covers sort of three quite

00:00:32,550 --> 00:00:35,940
important areas the first one is

00:00:34,530 --> 00:00:39,780
probably going everyone so thinks of

00:00:35,940 --> 00:00:42,030
first is message privacy that means

00:00:39,780 --> 00:00:44,309
ensuring that any communications between

00:00:42,030 --> 00:00:47,480
two parties can only be read by the

00:00:44,309 --> 00:00:51,239
intended recipient and the sender

00:00:47,480 --> 00:00:53,250
another sort of facets to to modern

00:00:51,239 --> 00:00:55,829
cryptography is be able to verify a

00:00:53,250 --> 00:00:58,739
message that's ensuring that a message

00:00:55,829 --> 00:01:00,210
that you've received is it's the message

00:00:58,739 --> 00:01:02,280
that was actually sent by the person

00:01:00,210 --> 00:01:06,119
that sent it and it's not been tampered

00:01:02,280 --> 00:01:08,580
with between you and the sender and and

00:01:06,119 --> 00:01:10,790
will the final sort of main areas that

00:01:08,580 --> 00:01:14,070
it deals with is identity verification

00:01:10,790 --> 00:01:15,390
so ensuring that the message that you've

00:01:14,070 --> 00:01:16,880
received did actually come from the

00:01:15,390 --> 00:01:18,930
person who claims to have sent it and

00:01:16,880 --> 00:01:21,000
it's not a fake message that you've

00:01:18,930 --> 00:01:22,920
received from someone who's a bit with

00:01:21,000 --> 00:01:27,630
joke on you

00:01:22,920 --> 00:01:29,280
so that's sort of third that area now if

00:01:27,630 --> 00:01:32,040
you've been to any other talks

00:01:29,280 --> 00:01:34,079
maybe this conference or another one on

00:01:32,040 --> 00:01:35,579
application security you better see

00:01:34,079 --> 00:01:39,600
let's talk this I think this is from

00:01:35,579 --> 00:01:42,659
last year or two years ago looks a bit

00:01:39,600 --> 00:01:45,780
like this cryptography is really quite a

00:01:42,659 --> 00:01:47,250
hard thing to to get right especially if

00:01:45,780 --> 00:01:48,920
you start get diving into diet design

00:01:47,250 --> 00:01:51,899
your own algorithms and things like that

00:01:48,920 --> 00:01:53,850
and so the main purpose of this talk is

00:01:51,899 --> 00:01:55,680
to take a brief journey through the

00:01:53,850 --> 00:01:57,299
evolution of cryptography right from the

00:01:55,680 --> 00:01:59,729
very very beginning all the way up to

00:01:57,299 --> 00:02:00,450
the algorithms that we use in today and

00:01:59,729 --> 00:02:02,219
try and give you a bit of an

00:02:00,450 --> 00:02:04,860
appreciation of quite why it's so hard

00:02:02,219 --> 00:02:05,509
and and why it's important to get it

00:02:04,860 --> 00:02:07,920
right

00:02:05,509 --> 00:02:10,619
so I'm gonna start with some historic

00:02:07,920 --> 00:02:13,290
ciphers which actually don't pen and

00:02:10,619 --> 00:02:13,930
paper if you if you want to and then I'm

00:02:13,290 --> 00:02:17,319
gonna move on to some

00:02:13,930 --> 00:02:22,540
workings of of things IAS and RSA crypto

00:02:17,319 --> 00:02:24,939
systems which are in use today so first

00:02:22,540 --> 00:02:26,230
on to the historic ciphers the the first

00:02:24,939 --> 00:02:27,670
one we could take a look at you've

00:02:26,230 --> 00:02:30,340
probably all heard of this one this is a

00:02:27,670 --> 00:02:33,359
shift it's probably about the simplest

00:02:30,340 --> 00:02:36,159
cipher you could you could think up and

00:02:33,359 --> 00:02:38,680
the basic idea is you take a message

00:02:36,159 --> 00:02:40,840
with some words and in order to encrypt

00:02:38,680 --> 00:02:42,900
it you shift characters in the message

00:02:40,840 --> 00:02:46,870
or down the alphabet by fixed amount

00:02:42,900 --> 00:02:48,129
that looks like this and you can see

00:02:46,870 --> 00:02:50,409
we've got like an alphabet at the top

00:02:48,129 --> 00:02:52,689
and then in order to apply the Caesar

00:02:50,409 --> 00:02:55,840
shift transformation encryption on a

00:02:52,689 --> 00:03:01,530
message we sort of shift each letter so

00:02:55,840 --> 00:03:03,730
a becomes the D and then so on so forth

00:03:01,530 --> 00:03:06,310
it's not going to be a very short talk

00:03:03,730 --> 00:03:09,760
if this was the state-of-the-art modern

00:03:06,310 --> 00:03:11,500
cryptography so somewhat what's actually

00:03:09,760 --> 00:03:15,040
wrong with this cipher why why should

00:03:11,500 --> 00:03:17,349
you not use it well turns out that the

00:03:15,040 --> 00:03:19,989
forgiving alphabet there's a very very

00:03:17,349 --> 00:03:21,430
small number of possible keys obviously

00:03:19,989 --> 00:03:24,760
you only got 26 letters in the English

00:03:21,430 --> 00:03:26,620
alphabet and that gives you 25 possible

00:03:24,760 --> 00:03:29,519
different shifts that you can use to

00:03:26,620 --> 00:03:31,780
encode a message using the Caesar shift

00:03:29,519 --> 00:03:33,879
obviously if use of 26 when it just

00:03:31,780 --> 00:03:36,250
encodes back to itself which is very

00:03:33,879 --> 00:03:38,229
useful either even if you were to use

00:03:36,250 --> 00:03:40,540
like binary ASCII and it applies either

00:03:38,229 --> 00:03:44,109
shift you're still only looking at 255

00:03:40,540 --> 00:03:45,579
different possible shifts that would

00:03:44,109 --> 00:03:46,720
mean that any anyone wanted to read a

00:03:45,579 --> 00:03:48,220
message that you've sent that you've

00:03:46,720 --> 00:03:51,069
you've encoded you can see the shift

00:03:48,220 --> 00:03:52,689
could simply just run through right

00:03:51,069 --> 00:03:56,019
little script try every different

00:03:52,689 --> 00:03:57,430
possible shift and see which which one

00:03:56,019 --> 00:03:58,840
made a message that makes sense and

00:03:57,430 --> 00:04:01,299
that'd be really easy for them to

00:03:58,840 --> 00:04:04,419
quickly run through and and decode your

00:04:01,299 --> 00:04:06,099
message this is quite important to us

00:04:04,419 --> 00:04:08,919
because it illustrates a really

00:04:06,099 --> 00:04:10,569
important aspect of a strong cipher it's

00:04:08,919 --> 00:04:12,340
the fact that it's got to have a large

00:04:10,569 --> 00:04:14,349
number of possible keys that's

00:04:12,340 --> 00:04:15,790
preventing any attacker from just

00:04:14,349 --> 00:04:19,630
iterating through them all to try and

00:04:15,790 --> 00:04:23,500
decode your message so move on to maybe

00:04:19,630 --> 00:04:23,979
a another straightforward cipher so an

00:04:23,500 --> 00:04:26,760
eeveelution

00:04:23,979 --> 00:04:26,760
step up

00:04:26,930 --> 00:04:31,880
it's a fusion cipher and this this works

00:04:29,600 --> 00:04:34,100
in a sort of similar way but instead of

00:04:31,880 --> 00:04:37,100
just moving that as up we which randomly

00:04:34,100 --> 00:04:38,660
shuffle them around so you just swap the

00:04:37,100 --> 00:04:41,180
letter a letter in your your plaintext

00:04:38,660 --> 00:04:44,150
for a letter for a different random

00:04:41,180 --> 00:04:48,289
letter okay and this looks a bit like

00:04:44,150 --> 00:04:50,840
this so this this one I've sort of

00:04:48,289 --> 00:04:55,580
picked a an encoding which changes aids

00:04:50,840 --> 00:04:59,389
with Zed a b2 as n c2 Q etc and you do

00:04:55,580 --> 00:05:01,449
that's the entire alphabet how does it

00:04:59,389 --> 00:05:03,470
hold up this one is actually

00:05:01,449 --> 00:05:06,470
significantly better for the state of

00:05:03,470 --> 00:05:09,590
shift ours our algorithm using just

00:05:06,470 --> 00:05:13,490
English for your institution and just

00:05:09,590 --> 00:05:17,840
letters there are four hundred and three

00:05:13,490 --> 00:05:22,099
septillion 291 sextillion 461

00:05:17,840 --> 00:05:25,759
quintillion 126 quadrillion 605 trillion

00:05:22,099 --> 00:05:29,830
635 billion 584 million possible

00:05:25,759 --> 00:05:29,830
different keys it's quite big number so

00:05:29,919 --> 00:05:34,010
with such a large large number of keys

00:05:32,510 --> 00:05:36,949
you'd think that this is a really pretty

00:05:34,010 --> 00:05:38,330
quite strong cipher right while we

00:05:36,949 --> 00:05:41,530
weren't we using a substitution cipher

00:05:38,330 --> 00:05:44,150
to store people's bank details well

00:05:41,530 --> 00:05:45,800
turns out the weakness of the

00:05:44,150 --> 00:05:48,940
substitution cipher doesn't actually

00:05:45,800 --> 00:05:51,620
come from from the low number of keys

00:05:48,940 --> 00:05:54,199
it's security is equivalent to about an

00:05:51,620 --> 00:05:55,460
eighty eight bit key so that's obviously

00:05:54,199 --> 00:06:00,289
not as strong as from the modern ciphers

00:05:55,460 --> 00:06:02,150
that use 128 or 256 bits but it's still

00:06:00,289 --> 00:06:05,419
pretty strong and it's only sort of just

00:06:02,150 --> 00:06:08,650
within our computational capabilities to

00:06:05,419 --> 00:06:11,419
to brute force a key of that size

00:06:08,650 --> 00:06:14,169
instead the substitution cipher falls

00:06:11,419 --> 00:06:16,699
foul of probably the greatest nemesis of

00:06:14,169 --> 00:06:20,150
cryptographic algorithms which is

00:06:16,699 --> 00:06:22,940
statistics okay due to the simplicity of

00:06:20,150 --> 00:06:25,340
the cipher it fails to hide any

00:06:22,940 --> 00:06:27,050
underlying patterns in the in the data

00:06:25,340 --> 00:06:30,590
that you've encrypted with it which

00:06:27,050 --> 00:06:32,060
means that if you want to recover the

00:06:30,590 --> 00:06:34,370
original plaintext if you've got a

00:06:32,060 --> 00:06:36,590
message that someone's sent and you want

00:06:34,370 --> 00:06:37,470
to read it you need to just look for the

00:06:36,590 --> 00:06:40,770
patterns

00:06:37,470 --> 00:06:42,690
if the patterns English text this is a

00:06:40,770 --> 00:06:44,810
graph of all the various letter

00:06:42,690 --> 00:06:48,570
frequencies in in the English language

00:06:44,810 --> 00:06:51,270
so what you can do is you can you can

00:06:48,570 --> 00:06:52,730
count up all the letters in you know

00:06:51,270 --> 00:06:55,980
ciphertext that you've you've

00:06:52,730 --> 00:06:58,140
intercepted and you can put them on the

00:06:55,980 --> 00:07:01,050
graph like this and then you can sort of

00:06:58,140 --> 00:07:03,180
take a bit of a guess and say well the

00:07:01,050 --> 00:07:04,830
letter that occurs most commonly that's

00:07:03,180 --> 00:07:06,330
probably the letter E okay so that's the

00:07:04,830 --> 00:07:09,720
most common letter in in the English

00:07:06,330 --> 00:07:11,190
language and once you've done that you

00:07:09,720 --> 00:07:13,140
can you can guess it maybe fuel this as

00:07:11,190 --> 00:07:15,770
a peak at sort of like around s and T

00:07:13,140 --> 00:07:19,020
and and some of the vowels hey you know

00:07:15,770 --> 00:07:20,130
you can start to decipher bits and once

00:07:19,020 --> 00:07:21,630
you've got little bits you can maybe

00:07:20,130 --> 00:07:23,250
guess at words and say well looks like

00:07:21,630 --> 00:07:24,990
left the word D which is one of most

00:07:23,250 --> 00:07:26,670
common words that gives you call more

00:07:24,990 --> 00:07:28,680
letters you can start decoding it and

00:07:26,670 --> 00:07:31,160
bit by bit you can sort of piece

00:07:28,680 --> 00:07:33,810
together the full text of the message

00:07:31,160 --> 00:07:36,200
takes a little work but you can automate

00:07:33,810 --> 00:07:39,960
it with a with a script quite easily and

00:07:36,200 --> 00:07:46,050
you can decode this on paper even so

00:07:39,960 --> 00:07:49,169
it's not really very strong so we want

00:07:46,050 --> 00:07:52,110
to obviously the substitution cipher is

00:07:49,169 --> 00:07:56,280
quite an old cipher and Durin's to write

00:07:52,110 --> 00:07:58,350
the 1500 1600 people sought to to

00:07:56,280 --> 00:08:00,330
improve upon this because they they sort

00:07:58,350 --> 00:08:03,540
of realized this wasn't hiding the

00:08:00,330 --> 00:08:04,919
patterns quite so well and they came up

00:08:03,540 --> 00:08:10,430
with this cipher called the Vigenere

00:08:04,919 --> 00:08:13,370
cipher now this is one of a group of

00:08:10,430 --> 00:08:15,600
ciphers known as polyalphabetic ciphers

00:08:13,370 --> 00:08:17,580
it's these are so called this because

00:08:15,600 --> 00:08:19,290
instead of just using one possible

00:08:17,580 --> 00:08:22,680
encoding for each each letter in your

00:08:19,290 --> 00:08:25,320
your plaintext it uses several different

00:08:22,680 --> 00:08:27,990
encodings that helps it better disguise

00:08:25,320 --> 00:08:31,800
sort of the underlying patterns in the

00:08:27,990 --> 00:08:35,280
in the plaintext how this works for the

00:08:31,800 --> 00:08:36,659
felissa cipher is in order to to encode

00:08:35,280 --> 00:08:38,909
a message you need to first of all pick

00:08:36,659 --> 00:08:41,400
a key and this simple example here I've

00:08:38,909 --> 00:08:43,800
picked the key T probably not a good

00:08:41,400 --> 00:08:45,300
idea to use that as your your actual key

00:08:43,800 --> 00:08:50,820
but it works quite nicely here for

00:08:45,300 --> 00:08:54,000
example and and what we do is using the

00:08:50,820 --> 00:08:56,220
the letters here we set a to be equal to

00:08:54,000 --> 00:08:58,650
the first letter of the key and we get

00:08:56,220 --> 00:09:03,030
to see the shift for that we do the same

00:08:58,650 --> 00:09:04,470
for E and the same for Y and then we've

00:09:03,030 --> 00:09:06,870
got several different shifts that we use

00:09:04,470 --> 00:09:08,760
one after the other that looks a little

00:09:06,870 --> 00:09:11,100
bit like this so we've got a message

00:09:08,760 --> 00:09:12,450
that we want to hide that's pretty

00:09:11,100 --> 00:09:13,830
pretty secret message you probably don't

00:09:12,450 --> 00:09:17,730
want people people knowing that you're

00:09:13,830 --> 00:09:20,010
about to blow some up you take the key

00:09:17,730 --> 00:09:21,630
and you encode the first letter of your

00:09:20,010 --> 00:09:25,920
message using the first Caesar shift

00:09:21,630 --> 00:09:29,070
represented by the K of letter the

00:09:25,920 --> 00:09:30,600
second one with e next one Y once you

00:09:29,070 --> 00:09:32,850
run out letters in your key you repeat

00:09:30,600 --> 00:09:36,450
it and it looks a bit like that

00:09:32,850 --> 00:09:38,520
so we we continue use it reusing this T

00:09:36,450 --> 00:09:41,520
and we get out the cipher text at the

00:09:38,520 --> 00:09:47,190
bottom so anyone want to guess is this

00:09:41,520 --> 00:09:48,600
cipher secure nope absolutely not now it

00:09:47,190 --> 00:09:51,530
did take a while longer

00:09:48,600 --> 00:09:55,290
to break it and it was credited to

00:09:51,530 --> 00:09:57,980
Charles Babbage who know well known

00:09:55,290 --> 00:10:00,120
historic figure however it wasn't until

00:09:57,980 --> 00:10:02,340
1985 that this was actually recognized

00:10:00,120 --> 00:10:03,570
because it was he did it and the British

00:10:02,340 --> 00:10:04,620
government kind of kept it a bit secret

00:10:03,570 --> 00:10:06,540
because they don't want anyone to know

00:10:04,620 --> 00:10:09,480
they've broken it

00:10:06,540 --> 00:10:11,160
so until then someone else Frederick

00:10:09,480 --> 00:10:12,330
Kisuke had been credited with a

00:10:11,160 --> 00:10:14,130
discovery he discovered it a bit later

00:10:12,330 --> 00:10:17,370
and it's him that the techniques

00:10:14,130 --> 00:10:19,140
actually named after unlike the simple

00:10:17,370 --> 00:10:21,300
substitution cipher you can't actually

00:10:19,140 --> 00:10:24,180
use frequency analysis if you've got a

00:10:21,300 --> 00:10:25,890
ciphertext encode over this and if you

00:10:24,180 --> 00:10:27,150
were to do frequent analysis you'd

00:10:25,890 --> 00:10:30,360
probably see something with a fairly

00:10:27,150 --> 00:10:32,580
flat graph so all the letters to provide

00:10:30,360 --> 00:10:34,080
the keys long enough you'll find that

00:10:32,580 --> 00:10:35,310
that is frequency is a fairly similar to

00:10:34,080 --> 00:10:36,980
each other and there's nothing that you

00:10:35,310 --> 00:10:41,580
can sort of pick out fairly easily

00:10:36,980 --> 00:10:43,560
however despite the fact you can't do

00:10:41,580 --> 00:10:46,050
frequency analysis because the mouthful

00:10:43,560 --> 00:10:48,210
encodings what you can do is you can

00:10:46,050 --> 00:10:52,050
start looking for repeated sequences of

00:10:48,210 --> 00:10:53,610
letters in the ciphertext now what these

00:10:52,050 --> 00:10:56,760
repeated sequences sort of tell you is

00:10:53,610 --> 00:11:00,630
possibly that's where the key has has

00:10:56,760 --> 00:11:02,850
repeated in the in the ciphertext and so

00:11:00,630 --> 00:11:04,960
you can count the distance between these

00:11:02,850 --> 00:11:07,180
repetitions

00:11:04,960 --> 00:11:08,620
and you'll notice that that's

00:11:07,180 --> 00:11:09,070
corresponding to the same word being

00:11:08,620 --> 00:11:11,950
encoded

00:11:09,070 --> 00:11:14,770
and being been 12 that's the part so

00:11:11,950 --> 00:11:17,080
this suggests that learnt that key is a

00:11:14,770 --> 00:11:20,380
multiple 12 well sorry 12 is a multiple

00:11:17,080 --> 00:11:22,420
of that aquiline so the key word that

00:11:20,380 --> 00:11:25,930
possibly been used to encode this text

00:11:22,420 --> 00:11:29,140
could be 2 3 4 6 or even 12 characters

00:11:25,930 --> 00:11:30,850
long and then that absolute helped us to

00:11:29,140 --> 00:11:33,370
narrow down what this the the key that

00:11:30,850 --> 00:11:36,520
was used to encode it might be so what

00:11:33,370 --> 00:11:39,160
you can then do is I mean I'm treating

00:11:36,520 --> 00:11:40,420
Bix I know how long the keys I can take

00:11:39,160 --> 00:11:42,820
a guess that maybe the keys three

00:11:40,420 --> 00:11:45,550
letters long and I split the message

00:11:42,820 --> 00:11:47,950
into three groups taking the first

00:11:45,550 --> 00:11:50,380
letter the fourth letter etc into the

00:11:47,950 --> 00:11:51,970
first group second letter fifth letter

00:11:50,380 --> 00:11:53,700
etc into the second group and the third

00:11:51,970 --> 00:11:56,710
letter and so on into the third group

00:11:53,700 --> 00:12:00,100
you can then perform frequency analysis

00:11:56,710 --> 00:12:02,020
on those those subgroups and it should

00:12:00,100 --> 00:12:05,110
produce a graph that looks similar to

00:12:02,020 --> 00:12:06,670
the one a few slides back once you've

00:12:05,110 --> 00:12:08,470
done that you can sort of take take the

00:12:06,670 --> 00:12:11,140
graph that you're looking at try and

00:12:08,470 --> 00:12:14,260
line up the largest letter with E and

00:12:11,140 --> 00:12:16,240
then that sort of helps you to to work

00:12:14,260 --> 00:12:18,460
out what the the key word is about that

00:12:16,240 --> 00:12:20,680
position wouldn't you've actually done

00:12:18,460 --> 00:12:25,260
that you may never cover the key and

00:12:20,680 --> 00:12:27,880
decode the right message okay now um

00:12:25,260 --> 00:12:29,410
when I first get this talk I I put

00:12:27,880 --> 00:12:30,820
together this little cypher challenge a

00:12:29,410 --> 00:12:32,410
little bit more difficult in the

00:12:30,820 --> 00:12:34,420
beginning a cypher but very very similar

00:12:32,410 --> 00:12:36,210
process so if anybody fancies having a

00:12:34,420 --> 00:12:39,100
go at breaking one of these themselves

00:12:36,210 --> 00:12:40,390
there's a link that I've got it at the

00:12:39,100 --> 00:12:42,850
end of the end of the talk so I'll put

00:12:40,390 --> 00:12:46,660
it back up if you don't manage to copy

00:12:42,850 --> 00:12:49,060
it down right now move on to a different

00:12:46,660 --> 00:12:53,500
cypher this one probably everyone in the

00:12:49,060 --> 00:12:56,610
room I would hope has heard of enigma it

00:12:53,500 --> 00:13:00,790
100 years after the venire cipher that

00:12:56,610 --> 00:13:04,180
went by before the the enigma cipher

00:13:00,790 --> 00:13:06,310
came around what will suit to saw

00:13:04,180 --> 00:13:08,560
several attempts to mechanize

00:13:06,310 --> 00:13:09,640
cryptography so move it from algorithms

00:13:08,560 --> 00:13:12,520
that you could perform on pen and paper

00:13:09,640 --> 00:13:15,730
to actually using machines to perform

00:13:12,520 --> 00:13:17,290
cryptographic operations obviously the

00:13:15,730 --> 00:13:18,269
most famous attempt was the Germans

00:13:17,290 --> 00:13:21,070
Enigma

00:13:18,269 --> 00:13:23,050
although during the war all the major

00:13:21,070 --> 00:13:24,910
powers of Americans and the British

00:13:23,050 --> 00:13:29,070
we're all using machines that worked in

00:13:24,910 --> 00:13:31,420
a fairly similar way to encode their

00:13:29,070 --> 00:13:32,649
attacks I mean the Americans and the

00:13:31,420 --> 00:13:35,950
British one was a little bit more secure

00:13:32,649 --> 00:13:40,149
than magma but same same sort of

00:13:35,950 --> 00:13:43,180
underlying principles so an in machine

00:13:40,149 --> 00:13:48,279
look to be like this made up of four

00:13:43,180 --> 00:13:50,339
parts a keyboard which was for typing

00:13:48,279 --> 00:13:55,690
your message in have a typist to type in

00:13:50,339 --> 00:13:56,950
a set of rotors on the back these actor

00:13:55,690 --> 00:14:01,390
each of these acted as their own

00:13:56,950 --> 00:14:03,250
substitution cipher there were commonly

00:14:01,390 --> 00:14:04,720
three rotors in a machine but some of

00:14:03,250 --> 00:14:07,149
the machines featured up to as many as

00:14:04,720 --> 00:14:10,630
eight of these rotors that could be

00:14:07,149 --> 00:14:13,300
interchanged the military machines that

00:14:10,630 --> 00:14:15,220
the German used had five different

00:14:13,300 --> 00:14:16,630
rotors which they could use in any any

00:14:15,220 --> 00:14:19,269
combination so they could use like

00:14:16,630 --> 00:14:23,199
rotors one two three one day and three

00:14:19,269 --> 00:14:24,910
four five the next day and later on

00:14:23,199 --> 00:14:27,370
throughout the war they expanded this to

00:14:24,910 --> 00:14:28,750
to a set with the total of eight rotors

00:14:27,370 --> 00:14:32,589
which would provide a little bit more

00:14:28,750 --> 00:14:35,829
security and the final component this at

00:14:32,589 --> 00:14:39,940
the front here was a plug board now this

00:14:35,829 --> 00:14:42,399
switched around pairs of letters with

00:14:39,940 --> 00:14:45,610
with wires and you could use up to 13

00:14:42,399 --> 00:14:47,709
different swaps but only usually about

00:14:45,610 --> 00:14:48,399
ten were used this actually was one of

00:14:47,709 --> 00:14:52,089
the features that

00:14:48,399 --> 00:14:53,680
OUP's was gave the Machine quite a lot

00:14:52,089 --> 00:14:56,440
of its security was the ability to flip

00:14:53,680 --> 00:15:00,160
these letters that's quite a lot the

00:14:56,440 --> 00:15:02,019
security came from so this is sort of

00:15:00,160 --> 00:15:06,760
how it looks like inside it's a

00:15:02,019 --> 00:15:08,890
electrical machine and so when a typist

00:15:06,760 --> 00:15:11,140
presses a key on the front of any

00:15:08,890 --> 00:15:12,880
machine an electric current completes

00:15:11,140 --> 00:15:13,769
the circuit which goes through the

00:15:12,880 --> 00:15:16,120
plugboard

00:15:13,769 --> 00:15:18,250
through each one of the rotors and get

00:15:16,120 --> 00:15:19,570
sort of like mangled up then the back of

00:15:18,250 --> 00:15:20,740
machine there's a reflector which is

00:15:19,570 --> 00:15:24,850
literally just a little wires that

00:15:20,740 --> 00:15:27,069
reconnect the circuit back through each

00:15:24,850 --> 00:15:30,190
of the three rotors back through the

00:15:27,069 --> 00:15:30,670
plug board and finally it illuminates a

00:15:30,190 --> 00:15:32,560
lamp

00:15:30,670 --> 00:15:36,520
on the on the top of the top of the

00:15:32,560 --> 00:15:39,790
machine then the radio operator would

00:15:36,520 --> 00:15:42,100
send that letter and then all the rotors

00:15:39,790 --> 00:15:43,510
would move around and when you press it

00:15:42,100 --> 00:15:46,000
the next time it took a different path

00:15:43,510 --> 00:15:48,330
for the machine and came up with a

00:15:46,000 --> 00:15:48,330
different letter

00:15:49,120 --> 00:15:52,930
obviously it stepped the first rotor

00:15:51,370 --> 00:15:54,610
ball at a time I once it gone all the

00:15:52,930 --> 00:15:56,020
way around then that stepped over the

00:15:54,610 --> 00:15:57,640
next one once that had gone all the way

00:15:56,020 --> 00:15:59,470
around it set the next one and so on so

00:15:57,640 --> 00:16:02,290
forth that meant that each letter could

00:15:59,470 --> 00:16:04,390
be encoded in a vast different variety

00:16:02,290 --> 00:16:08,260
of different ways each time you use the

00:16:04,390 --> 00:16:10,600
same letter by changing the mappings

00:16:08,260 --> 00:16:12,340
this way it meant that the mapping of

00:16:10,600 --> 00:16:15,520
the plaintext and ciphertext was

00:16:12,340 --> 00:16:16,690
constantly changing and it makes it

00:16:15,520 --> 00:16:18,430
really difficult to do any sort of like

00:16:16,690 --> 00:16:21,580
frequency analysis or any formal letters

00:16:18,430 --> 00:16:23,410
and and sort of had the the the

00:16:21,580 --> 00:16:24,940
cryptanalysis at Bletchley Park stumped

00:16:23,410 --> 00:16:29,380
for quite a while on on how to actually

00:16:24,940 --> 00:16:31,330
analyze these these messages obviously

00:16:29,380 --> 00:16:33,130
the Enigma is quite famous but one of

00:16:31,330 --> 00:16:37,750
the things it's famous for fact is for

00:16:33,130 --> 00:16:41,440
having been broken a team of British

00:16:37,750 --> 00:16:42,130
cryptographers at Bletchley Park led by

00:16:41,440 --> 00:16:44,410
Alan Turing

00:16:42,130 --> 00:16:48,940
it was also quite a famous guy I've

00:16:44,410 --> 00:16:52,270
heard so designed machines to help them

00:16:48,940 --> 00:16:54,550
break the mechanical ciphers the

00:16:52,270 --> 00:16:56,440
breakthroughs that the team made weren't

00:16:54,550 --> 00:17:00,250
particularly based on weaknesses in the

00:16:56,440 --> 00:17:02,440
cipher and the algorithm itself but

00:17:00,250 --> 00:17:07,089
mostly on certain operational errors

00:17:02,440 --> 00:17:09,459
made by the Germans so examples of those

00:17:07,089 --> 00:17:12,339
errors included choosing bad keys like a

00:17:09,459 --> 00:17:15,600
a a an initial setting for the rotors

00:17:12,339 --> 00:17:18,040
this made it fairly trivial to decode

00:17:15,600 --> 00:17:20,860
and and having predictable message

00:17:18,040 --> 00:17:22,360
structures so for example the first

00:17:20,860 --> 00:17:23,890
message most of the German military

00:17:22,360 --> 00:17:26,170
units would send in the morning would be

00:17:23,890 --> 00:17:30,490
a weather report which would contain the

00:17:26,170 --> 00:17:32,350
German word for weather what up and this

00:17:30,490 --> 00:17:34,660
was a the weakness while the weaknesses

00:17:32,350 --> 00:17:37,240
that the device designed by Alan Turing

00:17:34,660 --> 00:17:42,659
sort of seized upon and it sort of

00:17:37,240 --> 00:17:44,609
looked for the word wetter in in the

00:17:42,659 --> 00:17:46,729
to text and then sort of like stepped

00:17:44,609 --> 00:17:50,159
through all the possible different

00:17:46,729 --> 00:17:52,859
combinations of rotors and and tool

00:17:50,159 --> 00:17:57,210
board settings to try and find this and

00:17:52,859 --> 00:17:59,099
they had full like rooms full of these

00:17:57,210 --> 00:18:00,659
machines that aren't sharing this team

00:17:59,099 --> 00:18:02,759
designed but whenever they got a message

00:18:00,659 --> 00:18:04,799
in first in the morning one of machine

00:18:02,759 --> 00:18:06,570
operators rush in put the missed message

00:18:04,799 --> 00:18:08,789
into the machine it were away for a

00:18:06,570 --> 00:18:10,320
couple hours it find out the key and

00:18:08,789 --> 00:18:12,090
once the Germans only changed the keys

00:18:10,320 --> 00:18:13,679
once a day once the tram the key for the

00:18:12,090 --> 00:18:17,070
day they could decrypt all the messages

00:18:13,679 --> 00:18:19,590
that the Germans were sending for that

00:18:17,070 --> 00:18:22,320
day and obviously that did actually give

00:18:19,590 --> 00:18:23,279
the British and their allies quite a big

00:18:22,320 --> 00:18:26,070
advantage in the war because they knew

00:18:23,279 --> 00:18:30,029
exactly what the Germans were up to

00:18:26,070 --> 00:18:34,289
so obviously this break was quite a big

00:18:30,029 --> 00:18:37,320
thing so we're gonna leave the historic

00:18:34,289 --> 00:18:39,139
ciphers there now we've gone sort of

00:18:37,320 --> 00:18:41,609
through all the way up to sort of

00:18:39,139 --> 00:18:44,119
beginning of the last century with the

00:18:41,609 --> 00:18:45,899
half way through with those machines and

00:18:44,119 --> 00:18:47,309
we're gonna take a look at some of the

00:18:45,899 --> 00:18:51,619
algorithms that are actually useful to

00:18:47,309 --> 00:18:55,679
us today for for storing data securely

00:18:51,619 --> 00:18:57,840
modern-day cryptography beginning we've

00:18:55,679 --> 00:18:58,950
broken down into several different

00:18:57,840 --> 00:19:02,489
problems that we need to be able to

00:18:58,950 --> 00:19:05,970
solve to communicate securely the first

00:19:02,489 --> 00:19:07,259
one those is its confidentiality we need

00:19:05,970 --> 00:19:08,820
to ensure that people other than the

00:19:07,259 --> 00:19:13,019
intended recipient can't read our

00:19:08,820 --> 00:19:15,149
messages there's a wide variety of

00:19:13,019 --> 00:19:18,659
different algorithms which people are

00:19:15,149 --> 00:19:19,979
built for doing this but the probably

00:19:18,659 --> 00:19:21,749
one you want to be using at these at the

00:19:19,979 --> 00:19:26,450
moment is a yes the Advanced Encryption

00:19:21,749 --> 00:19:30,119
standard most of these algorithms are

00:19:26,450 --> 00:19:32,720
symmetric that is they use the same key

00:19:30,119 --> 00:19:35,129
for both encryption and decryption

00:19:32,720 --> 00:19:37,529
there's there's two main classes within

00:19:35,129 --> 00:19:39,749
that stream ciphers which work on

00:19:37,529 --> 00:19:41,190
continuous streams of data and block

00:19:39,749 --> 00:19:42,749
ciphers which break the messenger from

00:19:41,190 --> 00:19:44,399
separate blocks and encrypt each

00:19:42,749 --> 00:19:46,909
separately I'm just showing example of

00:19:44,399 --> 00:19:49,019
each in a few minutes

00:19:46,909 --> 00:19:51,839
another thing that we need to solve is

00:19:49,019 --> 00:19:54,629
is key exchange obviously if if I want

00:19:51,839 --> 00:19:56,129
to communicate with you securely we both

00:19:54,629 --> 00:19:56,350
need to have a key that we can we can

00:19:56,129 --> 00:20:01,450
use

00:19:56,350 --> 00:20:04,419
encrypt messages so what the one ways

00:20:01,450 --> 00:20:07,360
that we we do this is with asymmetric

00:20:04,419 --> 00:20:09,429
ciphers now these ciphers that use a

00:20:07,360 --> 00:20:12,160
different key for encrypting as they do

00:20:09,429 --> 00:20:14,080
for decrypting and then we can sort of

00:20:12,160 --> 00:20:17,200
use this you can give me the the

00:20:14,080 --> 00:20:18,580
encryption key fairly safely I can use

00:20:17,200 --> 00:20:21,039
that to encrypt a message to you but I

00:20:18,580 --> 00:20:22,900
can't subsequently decrypt any messages

00:20:21,039 --> 00:20:25,600
they're encrypted black key only you can

00:20:22,900 --> 00:20:27,910
with the the other part of that key so

00:20:25,600 --> 00:20:30,880
that's quite an important important

00:20:27,910 --> 00:20:33,309
thing that we can do another thing that

00:20:30,880 --> 00:20:36,190
we can do is verify the identity of a

00:20:33,309 --> 00:20:39,130
sender again it works in a similar way

00:20:36,190 --> 00:20:41,169
to key exchange you can sign a message

00:20:39,130 --> 00:20:44,230
using a a private key that you keep with

00:20:41,169 --> 00:20:45,460
keep secret and you can publish a public

00:20:44,230 --> 00:20:48,100
key and you can say this is this is my

00:20:45,460 --> 00:20:49,150
public key and anyone when they receive

00:20:48,100 --> 00:20:51,669
a message from you can use that public

00:20:49,150 --> 00:20:54,490
key to verify that it was signed with

00:20:51,669 --> 00:20:56,890
your private key it's known as a message

00:20:54,490 --> 00:20:59,820
signature and again okay so go into

00:20:56,890 --> 00:21:02,500
detail this later on this section

00:20:59,820 --> 00:21:04,360
another another thing we need to do is

00:21:02,500 --> 00:21:06,490
authenticate a message make sure that it

00:21:04,360 --> 00:21:08,500
hasn't been tampered with

00:21:06,490 --> 00:21:12,280
for this we use cryptographic hash

00:21:08,500 --> 00:21:14,020
functions generally such as sha-256 so

00:21:12,280 --> 00:21:16,840
when you can receive a message you can

00:21:14,020 --> 00:21:18,490
compute the message hash and compare it

00:21:16,840 --> 00:21:20,440
to one that's maybe been sent along with

00:21:18,490 --> 00:21:22,390
the message and and signed with the the

00:21:20,440 --> 00:21:23,830
private key of the sender if it doesn't

00:21:22,390 --> 00:21:25,539
match you can reject the message and say

00:21:23,830 --> 00:21:29,980
someone's messed with s tampered with it

00:21:25,539 --> 00:21:31,510
send me again or whatever obviously you

00:21:29,980 --> 00:21:33,400
need to combine the hash with a secret

00:21:31,510 --> 00:21:34,179
key of some form otherwise if someone

00:21:33,400 --> 00:21:39,039
tampered with it they could just

00:21:34,179 --> 00:21:40,419
recompute the hash and a final thing

00:21:39,039 --> 00:21:41,980
that quite a lot people don't maybe

00:21:40,419 --> 00:21:43,809
realize is a part of modern cryptography

00:21:41,980 --> 00:21:46,929
is the ability to generate random

00:21:43,809 --> 00:21:49,000
numbers so a large number of secure

00:21:46,929 --> 00:21:51,990
protocols rely on being able to generate

00:21:49,000 --> 00:21:55,510
random numbers that are actually random

00:21:51,990 --> 00:21:57,490
one example is with using a public key

00:21:55,510 --> 00:21:59,289
cryptography system you might generate a

00:21:57,490 --> 00:22:02,340
random key to using the symmetric cipher

00:21:59,289 --> 00:22:04,600
and encrypt that with the with the

00:22:02,340 --> 00:22:06,880
public and private keys and send the

00:22:04,600 --> 00:22:08,350
whole lot along now if someone can

00:22:06,880 --> 00:22:09,880
predict the number that came out you're

00:22:08,350 --> 00:22:10,599
an animal generator they can guess what

00:22:09,880 --> 00:22:12,969
that key

00:22:10,599 --> 00:22:13,809
and they can just forget about trying to

00:22:12,969 --> 00:22:17,589
break the algorithm they can just

00:22:13,809 --> 00:22:19,239
decrypt a message so be able to generate

00:22:17,589 --> 00:22:20,429
secure on your numbers it's really

00:22:19,239 --> 00:22:30,009
important

00:22:20,429 --> 00:22:31,839
okay so symmetric ciphers as I sort of

00:22:30,009 --> 00:22:33,190
previously mentioned there's two classes

00:22:31,839 --> 00:22:37,179
of symmetric cipher

00:22:33,190 --> 00:22:39,339
there's block and stream ciphers all of

00:22:37,179 --> 00:22:41,700
these algorithms are really only useful

00:22:39,339 --> 00:22:43,899
for dealing with message confidentiality

00:22:41,700 --> 00:22:45,549
there's no no symmetric algorithms you

00:22:43,899 --> 00:22:48,339
can really use for key exchange the

00:22:45,549 --> 00:22:51,399
moment and it doesn't really solve that

00:22:48,339 --> 00:22:54,700
problem so I'm gonna start by looking at

00:22:51,399 --> 00:22:59,379
stream ciphers how a stream cipher works

00:22:54,700 --> 00:23:03,759
is it produces a constant stream of some

00:22:59,379 --> 00:23:06,309
pseudo random output bytes and you use

00:23:03,759 --> 00:23:07,899
the secret key that you you're using to

00:23:06,309 --> 00:23:11,379
encrypt a message with as a sort of a

00:23:07,899 --> 00:23:13,719
seed to this generator the produced

00:23:11,379 --> 00:23:16,089
bytes from the generator then exhort

00:23:13,719 --> 00:23:17,379
with your plaintext to produce the

00:23:16,089 --> 00:23:19,349
cipher text and then you can send that

00:23:17,379 --> 00:23:22,299
along and the person on the other end

00:23:19,349 --> 00:23:24,489
can produce the same random

00:23:22,299 --> 00:23:26,619
pseudo-random stream of bytes and use

00:23:24,489 --> 00:23:29,190
that exhort with the plaintext over the

00:23:26,619 --> 00:23:31,359
cipher text to recover the plaintext

00:23:29,190 --> 00:23:34,690
it's actually fairly similar to how

00:23:31,359 --> 00:23:36,549
enigma works in a way it's sort of

00:23:34,690 --> 00:23:38,879
stream ciphers sort of evolved from the

00:23:36,549 --> 00:23:41,950
Enigma machine

00:23:38,879 --> 00:23:44,679
there are several stream ciphers that we

00:23:41,950 --> 00:23:47,679
currently use today probably the most

00:23:44,679 --> 00:23:51,700
well-known is rc4 which is used in WEP

00:23:47,679 --> 00:23:56,229
and an SSL but I've chosen a slightly

00:23:51,700 --> 00:23:56,919
different one which is called a 5/1 now

00:23:56,229 --> 00:23:58,239
you've probably ever heard of this

00:23:56,919 --> 00:24:00,549
algorithm but I can almost guarantee

00:23:58,239 --> 00:24:02,829
that every single want to do in this

00:24:00,549 --> 00:24:05,019
room is using it because it's used to

00:24:02,829 --> 00:24:08,259
protect voice and SMS data in mobile

00:24:05,019 --> 00:24:10,179
phones this algorithm has actually been

00:24:08,259 --> 00:24:13,299
broken it's it's no longer considered

00:24:10,179 --> 00:24:17,229
secure it was slightly up a few decades

00:24:13,299 --> 00:24:18,969
ago and now it's it's quite not but it's

00:24:17,229 --> 00:24:22,329
an interesting one to look at there's a

00:24:18,969 --> 00:24:24,220
stream side for example how it sort of

00:24:22,329 --> 00:24:30,190
works is like this diagram

00:24:24,220 --> 00:24:33,460
here so the it's got a big state machine

00:24:30,190 --> 00:24:37,450
in the middle and it consists of three

00:24:33,460 --> 00:24:41,650
registers this with each with each of a

00:24:37,450 --> 00:24:44,169
different size and what it does is each

00:24:41,650 --> 00:24:48,730
time you want a a new bit out of your

00:24:44,169 --> 00:24:50,590
new random number generator it takes the

00:24:48,730 --> 00:24:52,870
the top bit out of each of these

00:24:50,590 --> 00:24:56,980
registers XOR them together and that's

00:24:52,870 --> 00:24:59,700
the output bit that's produced once it's

00:24:56,980 --> 00:25:04,299
done that each of these registers is

00:24:59,700 --> 00:25:08,350
shifted to the left and depending on

00:25:04,299 --> 00:25:11,080
this byte here so it's got these what

00:25:08,350 --> 00:25:13,510
what they called clocking bits and so it

00:25:11,080 --> 00:25:16,809
compares each from the the bits in the

00:25:13,510 --> 00:25:19,090
register and says ok we'll take the

00:25:16,809 --> 00:25:20,980
majority so if they're all zeros the

00:25:19,090 --> 00:25:23,620
majority is 0 and any that match that

00:25:20,980 --> 00:25:25,600
majority bit are clocked I mean that

00:25:23,620 --> 00:25:29,470
don't match it a left so if you've got

00:25:25,600 --> 00:25:31,600
sort of say 1 0 1 the the majority bit

00:25:29,470 --> 00:25:33,700
there is it 1 so any registers that

00:25:31,600 --> 00:25:37,000
match that the first and the third get

00:25:33,700 --> 00:25:38,559
clocked and and move to the left one in

00:25:37,000 --> 00:25:40,990
order to generate a new by onto the back

00:25:38,559 --> 00:25:43,600
here it takes the bits that are colored

00:25:40,990 --> 00:25:49,360
in blue XOR them together and produces a

00:25:43,600 --> 00:25:51,250
a new bit on the end so take a look at

00:25:49,360 --> 00:25:54,820
that in more detail how it actually

00:25:51,250 --> 00:25:56,590
works in a clocks this is the most

00:25:54,820 --> 00:25:58,360
register from the previous diagram you

00:25:56,590 --> 00:26:01,179
can sort see it's got some sort of

00:25:58,360 --> 00:26:03,909
numbers in there and we clock it once

00:26:01,179 --> 00:26:07,690
everything shifts left X all these bits

00:26:03,909 --> 00:26:09,820
and put it back on the end next cycle we

00:26:07,690 --> 00:26:11,650
do the same thing XOR it put it back on

00:26:09,820 --> 00:26:13,620
the end and this generates a a really

00:26:11,650 --> 00:26:15,850
long sequence of different bytes and

00:26:13,620 --> 00:26:19,000
obviously got three of these so you get

00:26:15,850 --> 00:26:24,730
quite a large sequence of random data

00:26:19,000 --> 00:26:28,390
coming out of it ok now stream ciphers

00:26:24,730 --> 00:26:29,500
are quite useful but they do have a few

00:26:28,390 --> 00:26:31,809
things that you need to keep in mind

00:26:29,500 --> 00:26:35,409
when you're using them the first one is

00:26:31,809 --> 00:26:37,570
that keys must not be reused because of

00:26:35,409 --> 00:26:37,900
the way that it combines the output of

00:26:37,570 --> 00:26:42,220
the size

00:26:37,900 --> 00:26:46,059
using X or it will always produce the

00:26:42,220 --> 00:26:47,559
same output bytes so if you produce if

00:26:46,059 --> 00:26:50,140
you encrypt two different messages with

00:26:47,559 --> 00:26:52,090
the same key somebody can actually use

00:26:50,140 --> 00:26:53,800
those two messages to start recovering

00:26:52,090 --> 00:26:56,200
parts of your output stream and

00:26:53,800 --> 00:26:59,650
therefore they can actually decrypt your

00:26:56,200 --> 00:27:02,860
your messages to guard against this a

00:26:59,650 --> 00:27:04,950
lot of stream ciphers include what's

00:27:02,860 --> 00:27:08,020
known as an initialization vector or IV

00:27:04,950 --> 00:27:12,370
which is combined in some way with the

00:27:08,020 --> 00:27:13,900
with the secret key and then you sort of

00:27:12,370 --> 00:27:15,820
send that idea along with your message

00:27:13,900 --> 00:27:17,260
as part of it and then someone use the

00:27:15,820 --> 00:27:19,270
same algorithm to combine that key with

00:27:17,260 --> 00:27:21,010
your IV and then that make sure you're

00:27:19,270 --> 00:27:25,360
always using a different key for each

00:27:21,010 --> 00:27:28,390
message W PEP is actually vulnerable

00:27:25,360 --> 00:27:31,840
because of this although they use an IV

00:27:28,390 --> 00:27:34,330
in the initialization of the rc4

00:27:31,840 --> 00:27:36,790
algorithm the IV that they picked was

00:27:34,330 --> 00:27:38,350
too small which means that over some

00:27:36,790 --> 00:27:40,570
time if you're sending lots of Wi-Fi

00:27:38,350 --> 00:27:43,030
packets back and forth you'll eventually

00:27:40,570 --> 00:27:45,130
repeat not just the secret key but the

00:27:43,030 --> 00:27:47,320
the IVs will repeat that means that once

00:27:45,130 --> 00:27:49,240
want someone detects two messages using

00:27:47,320 --> 00:27:52,300
the same IV they can use those messages

00:27:49,240 --> 00:27:54,640
to decode the output stream and at that

00:27:52,300 --> 00:27:56,950
point they can they can sort of recover

00:27:54,640 --> 00:27:58,540
the key for the network and connect your

00:27:56,950 --> 00:28:01,450
Wi-Fi network and sniff your traffic and

00:27:58,540 --> 00:28:06,360
things which is sort of why we've sort

00:28:01,450 --> 00:28:06,360
of phased out WP in in Wi-Fi these days

00:28:06,990 --> 00:28:11,770
it's kind of easy for an attacker to

00:28:09,040 --> 00:28:14,350
modify a message so let's say you're

00:28:11,770 --> 00:28:18,120
downloading a HTML page for website and

00:28:14,350 --> 00:28:21,100
you're encoding it with a stream cipher

00:28:18,120 --> 00:28:22,900
anyone who can guess that maybe there's

00:28:21,100 --> 00:28:27,520
a JavaScript file in the header of that

00:28:22,900 --> 00:28:28,809
can actually compute a an XOR with what

00:28:27,520 --> 00:28:30,880
they think might be in the message and

00:28:28,809 --> 00:28:32,440
what they really want in the message and

00:28:30,880 --> 00:28:34,600
it's all that into the cipher text and

00:28:32,440 --> 00:28:36,130
that will actually replace it in the

00:28:34,600 --> 00:28:37,450
cipher text and it'll decode to what

00:28:36,130 --> 00:28:41,350
they want it to rather than what was

00:28:37,450 --> 00:28:42,730
sent this means that when you're

00:28:41,350 --> 00:28:43,870
actually using a stream cipher you need

00:28:42,730 --> 00:28:46,090
to make sure you've got some sort of

00:28:43,870 --> 00:28:50,370
message authentication to prevent this

00:28:46,090 --> 00:28:50,370
tampering such as a message hash

00:28:50,850 --> 00:28:56,740
it's also it's not so much a security

00:28:54,100 --> 00:28:59,230
concern more of a practical one most

00:28:56,740 --> 00:29:00,670
stream ciphers require that you run them

00:28:59,230 --> 00:29:03,640
all the way through to decrypt a message

00:29:00,670 --> 00:29:05,920
and you can't sort of arbitrarily seep

00:29:03,640 --> 00:29:07,540
into a stream cipher some of them have

00:29:05,920 --> 00:29:11,110
been designed to allow this but most do

00:29:07,540 --> 00:29:13,720
not this means if you're say you've

00:29:11,110 --> 00:29:17,200
encrypted a huge 50 gig database backup

00:29:13,720 --> 00:29:20,440
using a stream cipher and you need to

00:29:17,200 --> 00:29:23,020
recover one table worth of data from

00:29:20,440 --> 00:29:25,030
that backup and you know that it's 20

00:29:23,020 --> 00:29:26,770
gig away in you're still going to have

00:29:25,030 --> 00:29:29,530
to decrypt the first 20 gig to get to

00:29:26,770 --> 00:29:31,900
that table data you can't just sort of

00:29:29,530 --> 00:29:38,890
seek into it and decrypt just a bit you

00:29:31,900 --> 00:29:43,840
need to be aware of next thing we look

00:29:38,890 --> 00:29:45,700
at is the block cipher their key

00:29:43,840 --> 00:29:48,790
difference between a a block and a

00:29:45,700 --> 00:29:51,520
stream cipher is that where's the stream

00:29:48,790 --> 00:29:54,730
cipher produces bases pseudo-random

00:29:51,520 --> 00:29:56,440
stream we you can use to encrypt a block

00:29:54,730 --> 00:29:58,840
cipher actually works on a block of your

00:29:56,440 --> 00:30:00,280
plain text directly and applies various

00:29:58,840 --> 00:30:04,180
different mathematical transformations

00:30:00,280 --> 00:30:05,890
to it now the the size of block works

00:30:04,180 --> 00:30:08,740
differently depending on the algorithm

00:30:05,890 --> 00:30:11,500
but it's usually much shorter than any

00:30:08,740 --> 00:30:14,860
message you might want to send a s for

00:30:11,500 --> 00:30:18,400
example uses 128-bit blocks older

00:30:14,860 --> 00:30:20,050
ciphers tend to use 64 bits so that's

00:30:18,400 --> 00:30:21,570
that's obviously a lot shorter than any

00:30:20,050 --> 00:30:24,520
any message you're going to want to send

00:30:21,570 --> 00:30:26,530
so you need to break up your message

00:30:24,520 --> 00:30:28,150
into blocks and encrypt each one

00:30:26,530 --> 00:30:32,140
separately and that's where the name

00:30:28,150 --> 00:30:34,720
comes from a block cipher so obviously

00:30:32,140 --> 00:30:36,940
the probably most famous one you've

00:30:34,720 --> 00:30:38,470
heard of is a s and that's kind of like

00:30:36,940 --> 00:30:40,870
they probably the one you'll be using

00:30:38,470 --> 00:30:46,750
for a lot of your day to day encryption

00:30:40,870 --> 00:30:49,300
needs a s was a result of a cryptography

00:30:46,750 --> 00:30:51,790
competition to find a replacement for an

00:30:49,300 --> 00:30:54,100
all of an order encryption standard the

00:30:51,790 --> 00:30:55,690
data encryption standard and it was

00:30:54,100 --> 00:30:58,120
eventually won by a slight variant of

00:30:55,690 --> 00:30:59,530
the rhein gel algorithm now you might

00:30:58,120 --> 00:31:01,960
know if you've been using the m crypt

00:30:59,530 --> 00:31:03,620
extension that there are there is a

00:31:01,960 --> 00:31:05,990
different flavor of

00:31:03,620 --> 00:31:07,490
yes that's just called rind gel and if

00:31:05,990 --> 00:31:10,130
you use the wrong constants with em

00:31:07,490 --> 00:31:13,400
crypt you use that one instead it's not

00:31:10,130 --> 00:31:13,700
quite what you want but if it got you

00:31:13,400 --> 00:31:15,860
there

00:31:13,700 --> 00:31:16,880
fortunately it's been deprecated but if

00:31:15,860 --> 00:31:21,049
anyone's still using it

00:31:16,880 --> 00:31:27,200
someone to look out for so how is works

00:31:21,049 --> 00:31:30,549
is it's got si start off for the message

00:31:27,200 --> 00:31:35,390
and you apply the AES algorithm to it

00:31:30,549 --> 00:31:37,159
repeatedly for a few cycles depending on

00:31:35,390 --> 00:31:38,750
the key length is depending on how many

00:31:37,159 --> 00:31:42,320
how many actual cycles you you run

00:31:38,750 --> 00:31:45,649
through of a s each round of an a s

00:31:42,320 --> 00:31:49,640
consists of four distinct phases which

00:31:45,649 --> 00:31:51,980
is substitute bytes shift rows mixed

00:31:49,640 --> 00:31:55,370
columns and then it's adds a portion of

00:31:51,980 --> 00:32:00,710
the of the secret key to data and then

00:31:55,370 --> 00:32:02,929
it repeats the loop again so each one of

00:32:00,710 --> 00:32:06,049
those rounds is applied every time you

00:32:02,929 --> 00:32:09,770
sort of loop through looking a bit more

00:32:06,049 --> 00:32:13,549
detail the substitute bites it works on

00:32:09,770 --> 00:32:16,370
a block size of 128 bits and it's

00:32:13,549 --> 00:32:21,440
effectively got a substitution cipher

00:32:16,370 --> 00:32:24,770
with a fixed key now the the key had

00:32:21,440 --> 00:32:26,870
actually knows until and avoid a number

00:32:24,770 --> 00:32:28,850
of different algorithmic and

00:32:26,870 --> 00:32:30,890
cryptographic techniques to provide

00:32:28,850 --> 00:32:32,779
defense against various various

00:32:30,890 --> 00:32:35,990
techniques that we use against the

00:32:32,779 --> 00:32:37,399
predecessor des so the the bits and the

00:32:35,990 --> 00:32:40,580
substitution table have been chosen

00:32:37,399 --> 00:32:44,000
specifically and what happens basically

00:32:40,580 --> 00:32:47,299
is it just takes the current bite in the

00:32:44,000 --> 00:32:49,010
state looks up that bite in the

00:32:47,299 --> 00:32:51,559
substitution table and replaces that

00:32:49,010 --> 00:32:55,880
bite in your current block with the bite

00:32:51,559 --> 00:32:59,270
from the substitution table next thing

00:32:55,880 --> 00:33:01,909
that happens is each each row in your

00:32:59,270 --> 00:33:04,669
and your sort of block is shifted using

00:33:01,909 --> 00:33:06,409
a bit shift operation and then you

00:33:04,669 --> 00:33:11,870
select rotate the first bite round to

00:33:06,409 --> 00:33:13,180
the end so sort of that diagram the

00:33:11,870 --> 00:33:16,570
third step

00:33:13,180 --> 00:33:18,700
is better a complicated mathematical

00:33:16,570 --> 00:33:22,480
operation but in fact he does a

00:33:18,700 --> 00:33:24,460
multiplication over each column and it

00:33:22,480 --> 00:33:27,820
does like to sort of like mix up the the

00:33:24,460 --> 00:33:29,320
data a different way for the final round

00:33:27,820 --> 00:33:32,170
of the cipher this steps actually

00:33:29,320 --> 00:33:33,940
skipped over so it doesn't doesn't occur

00:33:32,170 --> 00:33:37,720
in the last round but it's every round

00:33:33,940 --> 00:33:41,560
other than that and then finally it

00:33:37,720 --> 00:33:44,080
takes a bite from your key and it solves

00:33:41,560 --> 00:33:47,620
it with a bite in the block and then

00:33:44,080 --> 00:33:49,720
produces the final output once you've

00:33:47,620 --> 00:33:52,510
gone through all those steps a number of

00:33:49,720 --> 00:33:55,480
times I think it's 14 rounds 420 a bit

00:33:52,510 --> 00:33:58,510
key then you output a block of

00:33:55,480 --> 00:34:00,730
ciphertext it's quite an efficient

00:33:58,510 --> 00:34:02,140
algorithm it's in printing in Hardware

00:34:00,730 --> 00:34:06,820
in quite a lot processes these days so

00:34:02,140 --> 00:34:10,240
it's it's very fast to compute and how

00:34:06,820 --> 00:34:11,770
it works now obviously with the block

00:34:10,240 --> 00:34:16,210
cipher you're going to want to encrypt

00:34:11,770 --> 00:34:17,740
more than 128 bits at a time and so when

00:34:16,210 --> 00:34:19,000
we use a block cipher a message that's

00:34:17,740 --> 00:34:22,840
longer than that we've got to split up

00:34:19,000 --> 00:34:24,250
into blocks however there are quite a

00:34:22,840 --> 00:34:27,550
lot of different ways in which you can

00:34:24,250 --> 00:34:31,770
utilize a block cipher and these are

00:34:27,550 --> 00:34:35,650
known as modes of operations so one mode

00:34:31,770 --> 00:34:36,940
is known as electronic cookbook it's

00:34:35,650 --> 00:34:39,760
probably the one that you'd sort of

00:34:36,940 --> 00:34:42,100
think up first is you literally encrypt

00:34:39,760 --> 00:34:44,530
a block of text and then the next one

00:34:42,100 --> 00:34:46,990
and the next one and just append them

00:34:44,530 --> 00:34:48,700
like that so you've got a plaintext

00:34:46,990 --> 00:34:50,440
you've got a key you do your block

00:34:48,700 --> 00:34:52,540
cipher encryption and you get output

00:34:50,440 --> 00:34:54,880
block you do the next block next block

00:34:52,540 --> 00:34:57,430
and you just start pen them believe it

00:34:54,880 --> 00:35:00,400
or not this is a really bad mode which

00:34:57,430 --> 00:35:02,800
you shouldn't use although block cipher

00:35:00,400 --> 00:35:06,340
produces a really random output and it's

00:35:02,800 --> 00:35:09,100
really difficult to reverse that any

00:35:06,340 --> 00:35:13,150
block any piece of plaintext that's the

00:35:09,100 --> 00:35:15,970
same same 128 bits will come out as a

00:35:13,150 --> 00:35:17,890
ciphertext that's exactly the same this

00:35:15,970 --> 00:35:20,200
actually gives you the same problems as

00:35:17,890 --> 00:35:22,120
with a substitution cipher where someone

00:35:20,200 --> 00:35:24,790
can actually look at single patterns in

00:35:22,120 --> 00:35:26,320
your data obviously it's a bit more

00:35:24,790 --> 00:35:29,930
difficult but

00:35:26,320 --> 00:35:34,670
take a look at this penguin tux Linux

00:35:29,930 --> 00:35:37,970
mascot and that's tux encrypted using a

00:35:34,670 --> 00:35:41,240
s in ECB mode you can quite clearly see

00:35:37,970 --> 00:35:42,980
that that tux is still there now if this

00:35:41,240 --> 00:35:45,650
was an image that maybe you wanted not

00:35:42,980 --> 00:35:47,270
for people not gonna see have it having

00:35:45,650 --> 00:35:53,210
it like that probably wouldn't be your

00:35:47,270 --> 00:35:55,849
your desired result so you should never

00:35:53,210 --> 00:35:57,440
really use ECB mode unless you just

00:35:55,849 --> 00:36:01,540
wanna make cool pop art images like this

00:35:57,440 --> 00:36:05,180
that's that's a legitimate use I guess

00:36:01,540 --> 00:36:07,280
so a bit of an improvement the first

00:36:05,180 --> 00:36:10,570
sort of attempt to fix that sort of

00:36:07,280 --> 00:36:14,930
problem was called cipher block chaining

00:36:10,570 --> 00:36:17,660
how that sort of works is you take an

00:36:14,930 --> 00:36:20,060
issue as a shooter similar to to a

00:36:17,660 --> 00:36:22,040
stream cipher and you feed that in for

00:36:20,060 --> 00:36:23,720
your first block and you actually what

00:36:22,040 --> 00:36:25,970
were your plaintext pass it through a

00:36:23,720 --> 00:36:28,580
block cipher encryption and then you get

00:36:25,970 --> 00:36:30,980
your cipher text for your next block you

00:36:28,580 --> 00:36:33,080
pass that ciphertext back in XOR with

00:36:30,980 --> 00:36:35,089
the plaintext and and pass it through

00:36:33,080 --> 00:36:36,859
and you do that all the way along this

00:36:35,089 --> 00:36:38,210
absence sort of like a randomizer to

00:36:36,859 --> 00:36:40,940
your your plaintext so even if you've

00:36:38,210 --> 00:36:42,830
got two blocks that's same because this

00:36:40,940 --> 00:36:47,119
and this are the same they're going to

00:36:42,830 --> 00:36:48,530
come out differently it's obviously a

00:36:47,119 --> 00:36:49,460
bit similar to a stream cipher in the

00:36:48,530 --> 00:36:52,960
fact that you need an initialization

00:36:49,460 --> 00:36:57,700
vector and you should not reuse those

00:36:52,960 --> 00:37:02,540
but that sort of half solves this the

00:36:57,700 --> 00:37:06,440
problems of the ECB another in the mode

00:37:02,540 --> 00:37:09,920
that's being used is called CTR mode or

00:37:06,440 --> 00:37:11,780
counter mode this is quite a cool mode

00:37:09,920 --> 00:37:14,780
in the fact that it turns a block cipher

00:37:11,780 --> 00:37:18,740
into a stream cipher with a few

00:37:14,780 --> 00:37:19,849
advantages so it completely different

00:37:18,740 --> 00:37:22,369
from the previous two modes that we've

00:37:19,849 --> 00:37:25,910
looked at as we no longer directly

00:37:22,369 --> 00:37:28,970
encrypt our plaintext what we do is we

00:37:25,910 --> 00:37:31,880
start off with a nonce or initialization

00:37:28,970 --> 00:37:36,109
vector again and we have a counter which

00:37:31,880 --> 00:37:38,510
we start 0 0 0 0 and we encrypt that

00:37:36,109 --> 00:37:39,420
instead and explore it with our plain

00:37:38,510 --> 00:37:41,819
text which

00:37:39,420 --> 00:37:43,309
the ciphertext then for that block you

00:37:41,819 --> 00:37:45,450
increment the counter encrypt that

00:37:43,309 --> 00:37:48,569
thanks all right you keep on going until

00:37:45,450 --> 00:37:51,089
you've got enough bytes to encrypt your

00:37:48,569 --> 00:37:53,190
whole message now due to the random

00:37:51,089 --> 00:37:56,220
nature of the the output of a block

00:37:53,190 --> 00:38:00,930
cipher it effectively turns it into a

00:37:56,220 --> 00:38:02,430
stream cipher now obviously with CTR

00:38:00,930 --> 00:38:04,859
mode you need to same precautions as

00:38:02,430 --> 00:38:08,039
with a stream cipher such as not reusing

00:38:04,859 --> 00:38:12,900
the IV and things and ensuring you've

00:38:08,039 --> 00:38:14,760
got a sort of a message authentication

00:38:12,900 --> 00:38:17,579
to to make sure it's something tampered

00:38:14,760 --> 00:38:19,200
with some else that this gives you that

00:38:17,579 --> 00:38:21,619
stream cipher doesn't is you can

00:38:19,200 --> 00:38:25,559
actually seek into your encrypted text

00:38:21,619 --> 00:38:27,480
but if you want to get block 557 all you

00:38:25,559 --> 00:38:30,299
do is take your nonce increment the

00:38:27,480 --> 00:38:33,029
counter to 557 pass it to the block

00:38:30,299 --> 00:38:35,609
cipher and you can decrypt into your

00:38:33,029 --> 00:38:37,349
into your encrypted data you can decrypt

00:38:35,609 --> 00:38:41,880
it and without having to decrypt

00:38:37,349 --> 00:38:44,640
everything up at that point another mode

00:38:41,880 --> 00:38:49,049
which which sort of helps alleviate the

00:38:44,640 --> 00:38:50,220
issue that we had with with CTR mode in

00:38:49,049 --> 00:38:53,670
the fact that it's a stream cipher that

00:38:50,220 --> 00:38:56,730
authentication is glorius counter mode

00:38:53,670 --> 00:38:59,069
what this does is it combines the

00:38:56,730 --> 00:39:00,720
counter mode with an authentication tag

00:38:59,069 --> 00:39:05,329
which helps verify that message hasn't

00:39:00,720 --> 00:39:07,529
been tampered with how that works is

00:39:05,329 --> 00:39:09,059
first of all you've got here you've

00:39:07,529 --> 00:39:11,099
basically got the count you've got the

00:39:09,059 --> 00:39:14,519
counter mode going on up here as well

00:39:11,099 --> 00:39:17,970
but you also have a separate part of

00:39:14,519 --> 00:39:19,619
your key which is off data here which

00:39:17,970 --> 00:39:21,720
goes to a multiplication function and

00:39:19,619 --> 00:39:24,240
then you start exploring it with each

00:39:21,720 --> 00:39:25,410
your ciphertext bytes and you sort of

00:39:24,240 --> 00:39:27,690
chained on lots of different

00:39:25,410 --> 00:39:32,029
multiplications of your ciphertext and

00:39:27,690 --> 00:39:36,119
then finally add on the length of your

00:39:32,029 --> 00:39:38,609
your your cipher text and data and that

00:39:36,119 --> 00:39:41,190
produces you an authentication tag which

00:39:38,609 --> 00:39:43,170
when the person who you send the message

00:39:41,190 --> 00:39:45,269
to receives it they can verify that

00:39:43,170 --> 00:39:46,559
authentication tag before decrypting the

00:39:45,269 --> 00:39:51,580
message and make sure it hasn't been

00:39:46,559 --> 00:39:54,280
tampered with how that works

00:39:51,580 --> 00:39:57,750
so that's that sort of covered off a lot

00:39:54,280 --> 00:39:59,920
of the symmetric ciphers all those

00:39:57,750 --> 00:40:02,050
ciphers we've looked at so far including

00:39:59,920 --> 00:40:05,800
even the historic ones use a single key

00:40:02,050 --> 00:40:07,240
for both encrypting and decrypting that

00:40:05,800 --> 00:40:09,240
leads to a really hollow to solve

00:40:07,240 --> 00:40:11,320
problem which is key distribution

00:40:09,240 --> 00:40:15,880
imagine for a moment that you're an

00:40:11,320 --> 00:40:19,060
undercover agent Alice is undercover and

00:40:15,880 --> 00:40:22,390
in deep in enemy operations and needs to

00:40:19,060 --> 00:40:24,850
get a secret message back to Bob HQ to

00:40:22,390 --> 00:40:28,710
to send mission reports and and tell Bob

00:40:24,850 --> 00:40:32,410
what's the the evil overlord is up to

00:40:28,710 --> 00:40:36,370
and they obviously need to do so without

00:40:32,410 --> 00:40:38,710
the the agents of the enemy Mallory and

00:40:36,370 --> 00:40:42,070
Eve eavesdropping and modifying the

00:40:38,710 --> 00:40:43,990
messages this is where the asymmetric

00:40:42,070 --> 00:40:45,190
ciphers actually comes in because they

00:40:43,990 --> 00:40:47,740
use different keys for encryption and

00:40:45,190 --> 00:40:50,410
decryption we don't need to sort of pre

00:40:47,740 --> 00:40:51,550
share keys so I can just keep on the

00:40:50,410 --> 00:40:54,460
encrypted message to you without having

00:40:51,550 --> 00:40:56,800
to worry about keep my key secure and

00:40:54,460 --> 00:40:58,960
things like that and even if I send the

00:40:56,800 --> 00:41:00,760
message out and it's intercepted and the

00:40:58,960 --> 00:41:02,680
enemy capture it they won't be able to

00:41:00,760 --> 00:41:04,420
search my room and find the key that I

00:41:02,680 --> 00:41:10,290
used to encrypt it because it's a public

00:41:04,420 --> 00:41:14,650
key that the Contin crypto again so

00:41:10,290 --> 00:41:16,710
looking at public key cryptography quite

00:41:14,650 --> 00:41:20,800
good good we're thinking about this is

00:41:16,710 --> 00:41:23,680
think about padlock so it's a padlock

00:41:20,800 --> 00:41:25,210
okay now imagine that I I want to send a

00:41:23,680 --> 00:41:27,250
message on the back of the room although

00:41:25,210 --> 00:41:28,330
I want someone to me what I could do is

00:41:27,250 --> 00:41:30,580
I could give a metal box

00:41:28,330 --> 00:41:31,900
nice nice sturdy metal box and they

00:41:30,580 --> 00:41:35,590
could write bit a message on a piece of

00:41:31,900 --> 00:41:37,690
paper and I could give my padlock okay

00:41:35,590 --> 00:41:39,070
and they could they could attach this

00:41:37,690 --> 00:41:41,560
padlock to the box

00:41:39,070 --> 00:41:43,360
locking it and they could pass them a

00:41:41,560 --> 00:41:45,370
pass the box back from back of the room

00:41:43,360 --> 00:41:48,790
past all you people who we don't really

00:41:45,370 --> 00:41:51,070
trust back to me and none of you unless

00:41:48,790 --> 00:41:52,770
you've got some bolt cutters brute force

00:41:51,070 --> 00:41:54,970
I'm gonna be able to undo that padlock

00:41:52,770 --> 00:41:56,410
but as soon as it gets back to me I've

00:41:54,970 --> 00:41:59,070
got the the private key

00:41:56,410 --> 00:42:02,110
I'm keeping over here I can lock it and

00:41:59,070 --> 00:42:05,140
I can read the message that's kind of

00:42:02,110 --> 00:42:10,660
the same same idea that the public key

00:42:05,140 --> 00:42:14,650
for users well the first and oldest

00:42:10,660 --> 00:42:16,059
public key system is its RSA despite the

00:42:14,650 --> 00:42:17,289
huge amount of protein power

00:42:16,059 --> 00:42:21,400
improvements and things like that we've

00:42:17,289 --> 00:42:23,769
made since its invention it's it's still

00:42:21,400 --> 00:42:26,289
quite a secure algorithm it relies on a

00:42:23,769 --> 00:42:28,799
sort of mathematical problem which is

00:42:26,289 --> 00:42:31,930
quite easy to compute in one direction

00:42:28,799 --> 00:42:36,339
but is really difficult to to reverse

00:42:31,930 --> 00:42:38,019
and how it sort of so if you've just set

00:42:36,339 --> 00:42:40,240
this mathematical problem it's really

00:42:38,019 --> 00:42:42,519
for to reverse but if you happen to know

00:42:40,240 --> 00:42:44,079
a secret that was used when constructing

00:42:42,519 --> 00:42:46,779
the problem its release if you to

00:42:44,079 --> 00:42:48,730
reverse again we have actually come up

00:42:46,779 --> 00:42:50,260
with better public key arms since but

00:42:48,730 --> 00:42:52,299
only about a third to the fact they're

00:42:50,260 --> 00:42:55,019
actually more efficient implementing

00:42:52,299 --> 00:42:58,000
code and they use less CPU cycles to run

00:42:55,019 --> 00:43:00,039
they're not actually much greater in the

00:42:58,000 --> 00:43:02,710
level of security they provide it's just

00:43:00,039 --> 00:43:05,380
you can use shorter keys with them so

00:43:02,710 --> 00:43:09,099
the mathematical problem that RSA is

00:43:05,380 --> 00:43:12,339
based on is exponential in modular

00:43:09,099 --> 00:43:18,609
arithmetic so the idea is that you can

00:43:12,339 --> 00:43:24,519
find three rather large numbers e here D

00:43:18,609 --> 00:43:30,130
and a prime number N and such that when

00:43:24,519 --> 00:43:32,049
you take e to take any number and raise

00:43:30,130 --> 00:43:36,940
it to power of E and then raise its

00:43:32,049 --> 00:43:41,369
power of T it equal to itself modulus de

00:43:36,940 --> 00:43:45,250
prime number n ok so it's sort of cyclic

00:43:41,369 --> 00:43:48,880
now if you've got a message that's been

00:43:45,250 --> 00:43:51,130
encoded like this and you only have e it

00:43:48,880 --> 00:43:54,069
is really really difficult to figure out

00:43:51,130 --> 00:43:56,259
what D is mathematically however if you

00:43:54,069 --> 00:44:00,069
already know D you can actually reverse

00:43:56,259 --> 00:44:01,690
it so you can make this number and any

00:44:00,069 --> 00:44:03,039
publicly available and it can be

00:44:01,690 --> 00:44:04,960
composed as mathematical problem to the

00:44:03,039 --> 00:44:08,279
world safe in the knowledge that it's

00:44:04,960 --> 00:44:11,170
really really hard for them to solve it

00:44:08,279 --> 00:44:15,549
and so in order to actually use this for

00:44:11,170 --> 00:44:18,590
crypto system what you can do is you've

00:44:15,549 --> 00:44:20,150
got my my public key which is e n N

00:44:18,590 --> 00:44:22,280
and you can take the message that you

00:44:20,150 --> 00:44:24,710
want to send to me you can raise it to

00:44:22,280 --> 00:44:26,870
the power of E take its modulus by my

00:44:24,710 --> 00:44:27,530
prime number and and that becomes a

00:44:26,870 --> 00:44:29,630
ciphertext

00:44:27,530 --> 00:44:32,710
you can send that to me say from the

00:44:29,630 --> 00:44:37,730
knowledge that only the person with D

00:44:32,710 --> 00:44:39,260
can do multiplication here and reverse

00:44:37,730 --> 00:44:44,030
the process and turn it back into the

00:44:39,260 --> 00:44:46,550
plaintext am obviously a slight issue

00:44:44,030 --> 00:44:49,100
with this scheme is that the message and

00:44:46,550 --> 00:44:54,710
must be smaller than this this modulus

00:44:49,100 --> 00:44:56,750
use so usually what you'll do with RSA

00:44:54,710 --> 00:44:59,390
and similar public key algorithms is

00:44:56,750 --> 00:45:01,550
that you'll generate a random string

00:44:59,390 --> 00:45:06,590
that you use for a symmetric cipher like

00:45:01,550 --> 00:45:08,990
a s and then you use RSA or the public

00:45:06,590 --> 00:45:12,380
key algorithm to encrypt just the key

00:45:08,990 --> 00:45:13,760
part of the symmetric cipher and then

00:45:12,380 --> 00:45:16,340
you'll send the ciphertext and the

00:45:13,760 --> 00:45:18,350
symmetric cipher the encrypted key to

00:45:16,340 --> 00:45:20,120
your intended recipient they can then

00:45:18,350 --> 00:45:22,220
use their private key to recover the

00:45:20,120 --> 00:45:25,930
random key and then they can decrypt

00:45:22,220 --> 00:45:27,920
message there's a two-stage process and

00:45:25,930 --> 00:45:32,240
and that sort of solves the key

00:45:27,920 --> 00:45:37,220
distribution problem another thing we

00:45:32,240 --> 00:45:37,970
need solve is identification of identity

00:45:37,220 --> 00:45:41,510
verification

00:45:37,970 --> 00:45:42,500
so although Alice and Bob can send

00:45:41,510 --> 00:45:44,210
messages to each other

00:45:42,500 --> 00:45:49,100
securely without Eve being able to

00:45:44,210 --> 00:45:51,530
eavesdrop and recover those messages how

00:45:49,100 --> 00:45:53,750
can they protect from the mischievous

00:45:51,530 --> 00:45:57,410
Mallory who likes to tamper with

00:45:53,750 --> 00:45:59,540
messages and change them turns out you

00:45:57,410 --> 00:46:04,310
can actually use a similar thing with

00:45:59,540 --> 00:46:07,340
RSA if I take a message

00:46:04,310 --> 00:46:10,040
say hash of the ciphertext that I'm

00:46:07,340 --> 00:46:15,440
sending to you and I raise it to the

00:46:10,040 --> 00:46:18,470
power of my private key D I can send

00:46:15,440 --> 00:46:21,440
that as a signature when Bob back in the

00:46:18,470 --> 00:46:22,640
office receives that message he can

00:46:21,440 --> 00:46:25,880
raise it to the power of my public key

00:46:22,640 --> 00:46:27,710
and if it has been signed using my

00:46:25,880 --> 00:46:29,750
private key it will return back to the

00:46:27,710 --> 00:46:31,950
value of the hash he can then hash the

00:46:29,750 --> 00:46:33,680
message check it matches and

00:46:31,950 --> 00:46:36,720
knows that it was sent by Alice

00:46:33,680 --> 00:46:38,130
obviously if it doesn't match then if

00:46:36,720 --> 00:46:39,839
something's gone wrong and he knows that

00:46:38,130 --> 00:46:40,859
the message has been tampered with or or

00:46:39,839 --> 00:46:43,680
didn't come from Alice in the first

00:46:40,859 --> 00:46:45,780
place again in practice that that

00:46:43,680 --> 00:46:47,490
message must be short so the signature

00:46:45,780 --> 00:46:53,099
is usually a cryptographic hash or the

00:46:47,490 --> 00:46:55,710
message might sha-256 or or similar so

00:46:53,099 --> 00:46:57,119
I've covered a selection of all the

00:46:55,710 --> 00:46:58,890
algorithms that are in use today that

00:46:57,119 --> 00:47:02,310
solve quite a lot of the problems in

00:46:58,890 --> 00:47:04,560
modern cryptography so this last five

00:47:02,310 --> 00:47:05,760
minutes or so we're going to look at how

00:47:04,560 --> 00:47:09,300
you'd actually go about implementing

00:47:05,760 --> 00:47:12,630
cryptography in applications if you need

00:47:09,300 --> 00:47:18,150
to do so the first bit of information

00:47:12,630 --> 00:47:19,619
that advice is don't I hope that you've

00:47:18,150 --> 00:47:21,570
sort of got an idea from this talk just

00:47:19,619 --> 00:47:23,880
how how many things you have to sort of

00:47:21,570 --> 00:47:26,640
keep an eye on and how difficult it is

00:47:23,880 --> 00:47:29,150
to actually do these things securely so

00:47:26,640 --> 00:47:31,770
if you've got a need to encrypt data

00:47:29,150 --> 00:47:35,670
don't try and do it yourself as much as

00:47:31,770 --> 00:47:37,230
possible it's very easy to introduce

00:47:35,670 --> 00:47:40,130
vulnerabilities into applications

00:47:37,230 --> 00:47:42,450
through things like side channels

00:47:40,130 --> 00:47:43,859
someone measuring how even if you take a

00:47:42,450 --> 00:47:46,950
s which is a secure algorithm and

00:47:43,859 --> 00:47:48,839
implement it if you don't take care of

00:47:46,950 --> 00:47:51,240
things like how long it takes to encrypt

00:47:48,839 --> 00:47:52,380
the data some might get a retrieve

00:47:51,240 --> 00:47:54,150
information about your key or your

00:47:52,380 --> 00:47:55,950
plaintext just by measuring how long it

00:47:54,150 --> 00:47:59,550
actually takes to encrypt messages and

00:47:55,950 --> 00:48:03,000
things like that so the best bit of

00:47:59,550 --> 00:48:05,900
advice is use an existing implementation

00:48:03,000 --> 00:48:08,490
okay everything I've gone over today is

00:48:05,900 --> 00:48:10,560
battle tested and and hardened and it's

00:48:08,490 --> 00:48:12,930
been pored over by cryptographers for at

00:48:10,560 --> 00:48:16,140
least a decade and there are well known

00:48:12,930 --> 00:48:20,369
well tested well used implementations

00:48:16,140 --> 00:48:22,920
out there use one of those okay most

00:48:20,369 --> 00:48:24,780
Linux distros for example allow you to

00:48:22,920 --> 00:48:26,210
encrypt hard drive partitions that's a

00:48:24,780 --> 00:48:28,530
good starting point

00:48:26,210 --> 00:48:31,920
all the major web servers have support

00:48:28,530 --> 00:48:34,079
for TLS use SSL for your connections

00:48:31,920 --> 00:48:35,550
between between service don't try and

00:48:34,079 --> 00:48:38,130
manually implement in your applications

00:48:35,550 --> 00:48:41,150
some sort of encrypting send over HTTP

00:48:38,130 --> 00:48:42,390
decrypt on the other side just use HTTP

00:48:41,150 --> 00:48:44,410
well-tested

00:48:42,390 --> 00:48:48,339
it's gonna work

00:48:44,410 --> 00:48:50,140
okay another option if you've got eight

00:48:48,339 --> 00:48:52,059
to two remote data centers you could use

00:48:50,140 --> 00:48:54,519
a VPN between the two or maybe an SSH

00:48:52,059 --> 00:48:56,109
tunnel again all these protocols and

00:48:54,519 --> 00:48:57,309
algorithms have been well tested there's

00:48:56,109 --> 00:48:58,480
lots of people going over the source

00:48:57,309 --> 00:48:59,890
code all the time

00:48:58,480 --> 00:49:00,940
they're patching there's security

00:48:59,890 --> 00:49:02,740
vulnerabilities and things like that

00:49:00,940 --> 00:49:07,650
you're benefiting from the knowledge of

00:49:02,740 --> 00:49:07,650
people who who do this all the time okay

00:49:07,740 --> 00:49:14,650
if one of those situations doesn't fit

00:49:11,559 --> 00:49:16,569
your use case if you do actually need to

00:49:14,650 --> 00:49:17,170
implement some cryptography bring in an

00:49:16,569 --> 00:49:20,799
expert

00:49:17,170 --> 00:49:22,029
okay bring in someone to audit your code

00:49:20,799 --> 00:49:27,039
and make sure you've not made any

00:49:22,029 --> 00:49:28,960
mistakes it's it's not a cryptography

00:49:27,039 --> 00:49:32,170
isn't a skill that most developers are

00:49:28,960 --> 00:49:34,029
like really tip-top on so although you

00:49:32,170 --> 00:49:37,450
can probably implement it bring someone

00:49:34,029 --> 00:49:38,710
in an expert an outside consultancy and

00:49:37,450 --> 00:49:42,759
getting to just make sure you've done it

00:49:38,710 --> 00:49:45,009
right it might seem expensive to bring

00:49:42,759 --> 00:49:46,839
someone in to do that but it's nothing

00:49:45,009 --> 00:49:48,519
to patch the costs if you become so

00:49:46,839 --> 00:49:50,619
right if you get hacked and you become

00:49:48,519 --> 00:49:53,349
addicts like actually Addison or Sony

00:49:50,619 --> 00:49:55,359
that sort of forget all that data spewed

00:49:53,349 --> 00:49:57,220
all over the internet especially with

00:49:55,359 --> 00:49:59,650
the the GDP are coming in now

00:49:57,220 --> 00:50:02,230
that's be quite costly if if you

00:49:59,650 --> 00:50:04,839
make a mistake with this stuff so bring

00:50:02,230 --> 00:50:09,369
an expert it'll save you money and worry

00:50:04,839 --> 00:50:12,460
in the long run obviously there's a PHP

00:50:09,369 --> 00:50:13,809
conference so what you need to watch Eve

00:50:12,460 --> 00:50:16,710
what should you do if you actually need

00:50:13,809 --> 00:50:18,730
to encrypt and decrypt stuff in PHP

00:50:16,710 --> 00:50:22,089
there's a lot libraries out there I

00:50:18,730 --> 00:50:24,519
reviewed a lot of them there's quite a

00:50:22,089 --> 00:50:29,680
few that default to using pop-up penguin

00:50:24,519 --> 00:50:30,880
mode and insecure other options and if

00:50:29,680 --> 00:50:32,289
you would just download it with composer

00:50:30,880 --> 00:50:34,720
and be like yep that's the library I'll

00:50:32,289 --> 00:50:36,369
use that you'll end up with a few

00:50:34,720 --> 00:50:38,740
problems like people been out to view

00:50:36,369 --> 00:50:44,380
your images or like pop-up versions of

00:50:38,740 --> 00:50:49,240
them so top my list of recommendations

00:50:44,380 --> 00:50:51,759
is a library that's scot ocke uzuki has

00:50:49,240 --> 00:50:56,019
written it just highlight how it's a

00:50:51,759 --> 00:50:57,279
wrapper around lib sodium which is a

00:50:56,019 --> 00:50:58,150
library that's been written by

00:50:57,279 --> 00:51:00,520
cryptographers

00:50:58,150 --> 00:51:02,559
to limit the amount of choices that

00:51:00,520 --> 00:51:03,940
developers are given you've got what

00:51:02,559 --> 00:51:05,770
implementation of things and that's a

00:51:03,940 --> 00:51:09,160
secure implementation and that's the

00:51:05,770 --> 00:51:11,500
sort of design goal of zip sodium and

00:51:09,160 --> 00:51:14,049
and highlight just provides a high level

00:51:11,500 --> 00:51:16,349
in place for that which is really

00:51:14,049 --> 00:51:18,880
straightforward it looks a bit like this

00:51:16,349 --> 00:51:21,609
that would be how you would encrypt

00:51:18,880 --> 00:51:24,130
something using highlight the wrapper

00:51:21,609 --> 00:51:29,710
around live sodium it's that easy and

00:51:24,130 --> 00:51:33,069
that will be secure okay so if you need

00:51:29,710 --> 00:51:37,990
to do something that's your best option

00:51:33,069 --> 00:51:41,109
lip sodium is in PHP 7.2 you can install

00:51:37,990 --> 00:51:43,660
the extension tackle for versions before

00:51:41,109 --> 00:51:45,670
7.2 if you're in an environment where

00:51:43,660 --> 00:51:48,309
you can't install it Scott's also

00:51:45,670 --> 00:51:49,750
written a polyfill in PHP which you can

00:51:48,309 --> 00:51:55,420
actually include and it's got all the

00:51:49,750 --> 00:51:57,130
same algorithms written PHP so you've

00:51:55,420 --> 00:52:00,250
got a very good range of options though

00:51:57,130 --> 00:52:02,710
if you if you want to use that if for

00:52:00,250 --> 00:52:04,539
some reason you you can't you slip

00:52:02,710 --> 00:52:06,279
sodium for whatever reason maybe you

00:52:04,539 --> 00:52:07,750
need compatibility the legacy system or

00:52:06,279 --> 00:52:13,809
something like that

00:52:07,750 --> 00:52:16,599
diffuse PHP encryption is another good

00:52:13,809 --> 00:52:18,250
library that's implemented in PHP it

00:52:16,599 --> 00:52:20,770
look it uses a lot more the the sort of

00:52:18,250 --> 00:52:25,299
the older style algorithms a yes and an

00:52:20,770 --> 00:52:26,799
RSA for it's it's cryptography and it

00:52:25,299 --> 00:52:29,140
tries to import those in a secure way

00:52:26,799 --> 00:52:30,220
and it will fall back to my open SSL if

00:52:29,140 --> 00:52:34,150
you've got it installed and things like

00:52:30,220 --> 00:52:35,950
that still still be quite performant so

00:52:34,150 --> 00:52:38,529
that's another option it's got a fetish

00:52:35,950 --> 00:52:40,990
in the API to howlite so it's pretty

00:52:38,529 --> 00:52:47,170
much diffuse encrypt and diffusion

00:52:40,990 --> 00:52:48,670
decrypt so it's easy to get right so

00:52:47,170 --> 00:52:50,799
that's pretty much the end of close to

00:52:48,670 --> 00:52:52,420
the end of the talk so I've got a few

00:52:50,799 --> 00:52:54,250
links now for anybody who's interested

00:52:52,420 --> 00:52:56,799
in finding out more there's there's a

00:52:54,250 --> 00:52:59,589
wealth of really interesting stuff on

00:52:56,799 --> 00:53:01,630
cryptography one of the best ones if

00:52:59,589 --> 00:53:04,059
you're interested in the historic side

00:53:01,630 --> 00:53:06,069
of the talk is Simon sings the code book

00:53:04,059 --> 00:53:07,960
he's got a few the ones I went over and

00:53:06,069 --> 00:53:09,190
a few other ones and there's also some

00:53:07,960 --> 00:53:12,109
really interesting case studies on what

00:53:09,190 --> 00:53:13,789
happened when cryptography went wrong

00:53:12,109 --> 00:53:15,019
she's pretty good resource he's also got

00:53:13,789 --> 00:53:17,299
a website where you can actually try out

00:53:15,019 --> 00:53:19,339
some of these ciphers and you can encode

00:53:17,299 --> 00:53:24,289
and decode messages and do things like

00:53:19,339 --> 00:53:26,420
that another good resource if you're

00:53:24,289 --> 00:53:28,369
interested in modern cryptography is

00:53:26,420 --> 00:53:30,079
Bruce Schneier site

00:53:28,369 --> 00:53:32,029
Bruce Schneier a well-known

00:53:30,079 --> 00:53:33,799
cryptographer I work for a lot of

00:53:32,029 --> 00:53:35,660
leading Corp companies on security and

00:53:33,799 --> 00:53:37,549
things like that he also created

00:53:35,660 --> 00:53:39,200
Blowfish and the bcrypt hash function

00:53:37,549 --> 00:53:42,890
which you're hopefully using for your

00:53:39,200 --> 00:53:44,119
passwords so if you do feel like

00:53:42,890 --> 00:53:45,890
starting messing around creating your

00:53:44,119 --> 00:53:48,559
own algorithms he's got a self-study

00:53:45,890 --> 00:53:51,079
course on his website which starts off

00:53:48,559 --> 00:53:52,640
showing you how to I with increasing

00:53:51,079 --> 00:53:55,999
difficulty of algorithms you can have a

00:53:52,640 --> 00:53:57,319
go breaking yourself what one of the

00:53:55,999 --> 00:53:59,029
things you know in order to become a

00:53:57,319 --> 00:54:01,400
good cryptographer you need to get prove

00:53:59,029 --> 00:54:03,170
that you can break other algorithms that

00:54:01,400 --> 00:54:05,329
way anybody anything that you've done

00:54:03,170 --> 00:54:06,619
you you know that if you're really good

00:54:05,329 --> 00:54:08,420
at breaking algorithms and you can't

00:54:06,619 --> 00:54:09,890
break your algorithm it's pretty good

00:54:08,420 --> 00:54:11,210
but if you're just like someone who's

00:54:09,890 --> 00:54:13,849
just turned up me like yeah just men do

00:54:11,210 --> 00:54:15,499
this thing how can we trust that's any

00:54:13,849 --> 00:54:16,309
good well if you've got a proven track

00:54:15,499 --> 00:54:19,099
record i've been out of break

00:54:16,309 --> 00:54:20,599
cryptography and you say it's good and

00:54:19,099 --> 00:54:21,980
probably trust that so if you're

00:54:20,599 --> 00:54:25,670
interested in sort of getting to that

00:54:21,980 --> 00:54:28,160
side it's course it's pretty good the

00:54:25,670 --> 00:54:30,700
final link there is a library called PHP

00:54:28,160 --> 00:54:33,769
crypt do not use this in production

00:54:30,700 --> 00:54:35,420
absolutely not but it includes a pure

00:54:33,769 --> 00:54:37,640
PHP implementation of quite a lot of

00:54:35,420 --> 00:54:38,930
interesting ciphers so you actually have

00:54:37,640 --> 00:54:40,489
a look at the code implementation of

00:54:38,930 --> 00:54:41,869
some of these including the historic

00:54:40,489 --> 00:54:44,539
ones I think it's got an enigma in there

00:54:41,869 --> 00:54:45,920
and a few others it's quite good once I

00:54:44,539 --> 00:54:49,489
look at the source code and see how they

00:54:45,920 --> 00:54:51,440
they tick underneath but yeah obviously

00:54:49,489 --> 00:54:53,440
none of those are suitable for anything

00:54:51,440 --> 00:54:56,529
other than sort of like your own

00:54:53,440 --> 00:55:00,079
personal interest in in cryptography

00:54:56,529 --> 00:55:01,279
right hope everyone sort of learnt

00:55:00,079 --> 00:55:04,249
something from this talk and found

00:55:01,279 --> 00:55:06,739
interesting my my Twitter handles give

00:55:04,249 --> 00:55:08,569
already I've also got get low I get

00:55:06,739 --> 00:55:11,119
hooked with a few few projects and

00:55:08,569 --> 00:55:13,339
things like that one interesting post on

00:55:11,119 --> 00:55:14,569
my blog if anyone's interested I broke

00:55:13,339 --> 00:55:16,730
an errand that someone influenced

00:55:14,569 --> 00:55:18,440
themselves my blog post is actually

00:55:16,730 --> 00:55:21,710
showing why why you shouldn't actually

00:55:18,440 --> 00:55:23,780
do this things and finally there is a

00:55:21,710 --> 00:55:25,430
joined in link

00:55:23,780 --> 00:55:28,270
if if you want to rate this talk let me

00:55:25,430 --> 00:55:28,270

YouTube URL: https://www.youtube.com/watch?v=gU0mAPywm7o


