Title: PHP UK Conference 2018 - Michiel Rook - Database Schema Migrations with Zero Downtime
Publication date: 2018-03-27
Playlist: PHP UK Conference 2018
Description: 
	Does your application or service use a database? When that application changes because of new business requirements, you may need to make changes to the database schema. These database migrations could lead to downtime and can be an obstacle to implementing continuous delivery/deployment. How can we deal with database migrations when we don’t want our end-users to experience downtime, and want to keep releasing? In this talk we’ll discuss non-destructive changes, rollbacks, large data sets, useful tools and a few strategies to migrate our data safely, with minimum disruption to production.
Captions: 
	00:00:03,020 --> 00:00:09,260
my name is Mickey Rock or as most people

00:00:05,569 --> 00:00:11,750
abroad call me Michael or Mike I'm from

00:00:09,260 --> 00:00:15,320
the Netherlands which explains in the

00:00:11,750 --> 00:00:18,380
name today I'll be talking to you about

00:00:15,320 --> 00:00:20,240
database schema migrations and not just

00:00:18,380 --> 00:00:22,480
any schema migration but a schema

00:00:20,240 --> 00:00:25,820
migration that doesn't cause downtime

00:00:22,480 --> 00:00:28,609
before I begin I'd like to introduce

00:00:25,820 --> 00:00:31,730
myself at this point

00:00:28,609 --> 00:00:33,950
I'm a freelance developer and a coach I

00:00:31,730 --> 00:00:38,000
do a lot of consulting and coaching

00:00:33,950 --> 00:00:39,500
around continuous delivery and DevOps if

00:00:38,000 --> 00:00:41,870
at any point you want to reach out to me

00:00:39,500 --> 00:00:44,449
that's my twitter handle handle right

00:00:41,870 --> 00:00:46,850
there I'll also make sure to post the

00:00:44,449 --> 00:00:49,340
slides on there and also on join in of

00:00:46,850 --> 00:00:51,019
course after the talk and if you have

00:00:49,340 --> 00:00:53,600
any further questions later on then

00:00:51,019 --> 00:00:55,219
please reach out to me now I mentioned

00:00:53,600 --> 00:00:57,800
that I do a lot of consulting around

00:00:55,219 --> 00:01:00,739
continuous delivery and for those of you

00:00:57,800 --> 00:01:03,230
that were here last year some of you may

00:01:00,739 --> 00:01:04,879
have been present at one of my other

00:01:03,230 --> 00:01:09,220
talks which is called the road to

00:01:04,879 --> 00:01:12,380
continuous deployment a talk in which I

00:01:09,220 --> 00:01:15,520
explained a case study a project in the

00:01:12,380 --> 00:01:17,480
Netherlands of which I was a part that

00:01:15,520 --> 00:01:19,580
proceeded on to continuous deployment

00:01:17,480 --> 00:01:21,950
which basically means deploy every

00:01:19,580 --> 00:01:23,750
change that is automatically tested and

00:01:21,950 --> 00:01:26,120
verified to production which for that

00:01:23,750 --> 00:01:29,470
particular company resulted in 50 plus

00:01:26,120 --> 00:01:32,690
deployments per day to production a

00:01:29,470 --> 00:01:34,640
company that basically ran a 24/7

00:01:32,690 --> 00:01:37,270
operation so high availability is

00:01:34,640 --> 00:01:41,420
definitely concerned for such a company

00:01:37,270 --> 00:01:44,330
and when you add database migrations in

00:01:41,420 --> 00:01:48,380
the mix changes to database integral to

00:01:44,330 --> 00:01:51,910
databases to database schemas then for

00:01:48,380 --> 00:01:55,130
24/7 company that is highly available

00:01:51,910 --> 00:02:01,280
downtime is unacceptable if you can

00:01:55,130 --> 00:02:04,100
avoid it that is so that talk I've given

00:02:01,280 --> 00:02:06,290
that a few times not just here at PHP UK

00:02:04,100 --> 00:02:10,510
but also at other conferences and one of

00:02:06,290 --> 00:02:13,370
the questions I keep getting asked is

00:02:10,510 --> 00:02:16,110
going to production 50 plus times per

00:02:13,370 --> 00:02:19,140
day that's very cool by

00:02:16,110 --> 00:02:22,320
we have this database and we do schema

00:02:19,140 --> 00:02:24,930
migrations as we do code changes and we

00:02:22,320 --> 00:02:26,940
need to take the database down or the

00:02:24,930 --> 00:02:29,250
app down while we're performing the

00:02:26,940 --> 00:02:31,680
database migration so how can I proceed

00:02:29,250 --> 00:02:33,570
from the situation we're in now to this

00:02:31,680 --> 00:02:36,360
situation you're describing where you're

00:02:33,570 --> 00:02:39,180
going to production 50 times per day so

00:02:36,360 --> 00:02:41,850
that triggered the talk to or triggered

00:02:39,180 --> 00:02:43,890
me to write this song and so here we are

00:02:41,850 --> 00:02:47,490
we're going to talk about database

00:02:43,890 --> 00:02:51,420
schema migrations specifically database

00:02:47,490 --> 00:02:55,260
schema migrations and let's go back to

00:02:51,420 --> 00:02:57,570
what a database schema is well it could

00:02:55,260 --> 00:02:59,910
look something like that a lot of tables

00:02:57,570 --> 00:03:02,700
you have your your keys you have your

00:02:59,910 --> 00:03:05,310
primary keys your foreign keys relations

00:03:02,700 --> 00:03:09,480
between tables you have table structure

00:03:05,310 --> 00:03:11,940
all those things and at some point you

00:03:09,480 --> 00:03:13,950
have a database schema that is not

00:03:11,940 --> 00:03:17,340
sufficient for the direction your

00:03:13,950 --> 00:03:19,260
application is going and then we end up

00:03:17,340 --> 00:03:22,590
with a migration we end up with a change

00:03:19,260 --> 00:03:25,290
to our database and of course this

00:03:22,590 --> 00:03:27,209
change can be manual but at this day and

00:03:25,290 --> 00:03:29,040
age especially if you're going towards

00:03:27,209 --> 00:03:32,700
continuous deployment and automation is

00:03:29,040 --> 00:03:34,620
the name of the game in this talk I'll

00:03:32,700 --> 00:03:38,430
typically refer to database schema

00:03:34,620 --> 00:03:42,660
migrations as being sequel and when we

00:03:38,430 --> 00:03:46,200
consider sequel database migrations most

00:03:42,660 --> 00:03:49,110
tools and most talks and blogs about

00:03:46,200 --> 00:03:52,800
this topic consider a migration to have

00:03:49,110 --> 00:03:55,560
two directions up and down where up

00:03:52,800 --> 00:03:57,420
means I'm going from a previous version

00:03:55,560 --> 00:04:00,090
of my database schema to a new version

00:03:57,420 --> 00:04:02,730
and down means I'm basically going to

00:04:00,090 --> 00:04:06,410
revert that change and go from version X

00:04:02,730 --> 00:04:10,220
plus one back to version X ok now

00:04:06,410 --> 00:04:13,680
typically these migrations are run in

00:04:10,220 --> 00:04:17,160
transactions within your my sequel or

00:04:13,680 --> 00:04:19,769
your Oracle or what have you and let's

00:04:17,160 --> 00:04:22,169
take a typical example tool that you

00:04:19,769 --> 00:04:26,010
would see in the PHP world which is

00:04:22,169 --> 00:04:29,159
doctrine now doctrine when you write a

00:04:26,010 --> 00:04:32,489
migration in doctrine it's basically PHP

00:04:29,159 --> 00:04:35,610
so you would write a simple class which

00:04:32,489 --> 00:04:38,039
extends an abstract migration base class

00:04:35,610 --> 00:04:40,519
and there are two methods in that class

00:04:38,039 --> 00:04:44,429
up and down just as I explained earlier

00:04:40,519 --> 00:04:47,879
the up has some sequel to modify things

00:04:44,429 --> 00:04:50,189
in the forward Direction ended down if

00:04:47,879 --> 00:04:51,779
applicable has some statements equal

00:04:50,189 --> 00:04:54,689
statements to modify things in the

00:04:51,779 --> 00:04:56,519
backwards direction now if you would

00:04:54,689 --> 00:04:58,949
then apply it doctrine make sure that

00:04:56,519 --> 00:05:01,830
the database the version of the database

00:04:58,949 --> 00:05:04,019
is actually trekked so to do that it

00:05:01,830 --> 00:05:06,860
adds another table by default it's

00:05:04,019 --> 00:05:09,360
called migration versions and any

00:05:06,860 --> 00:05:11,819
migration that successfully applies is

00:05:09,360 --> 00:05:14,699
added to that table to indicate to you

00:05:11,819 --> 00:05:16,229
that that migration is actually applied

00:05:14,699 --> 00:05:20,849
to the database and that your database

00:05:16,229 --> 00:05:22,740
is now in state X plus one personally I

00:05:20,849 --> 00:05:26,519
am very much a fan of a tool called

00:05:22,740 --> 00:05:30,050
Flyway which records a little bit more

00:05:26,519 --> 00:05:33,929
context now Flyway in the default mode

00:05:30,050 --> 00:05:37,289
uses straight sequel scripts and it

00:05:33,929 --> 00:05:39,959
actually does not consider down to be a

00:05:37,289 --> 00:05:43,069
valid direction and I'll go into that in

00:05:39,959 --> 00:05:47,249
a little bit so it's just straight SQL

00:05:43,069 --> 00:05:50,939
and when it's applied it also records it

00:05:47,249 --> 00:05:53,129
in a versioning table with the addition

00:05:50,939 --> 00:05:55,829
of a few extra a little bit extra

00:05:53,129 --> 00:05:58,679
metadata in that table so not only do we

00:05:55,829 --> 00:06:01,589
see which changes were applied but also

00:05:58,679 --> 00:06:05,099
when by whom

00:06:01,589 --> 00:06:07,649
what was the script how long did it take

00:06:05,099 --> 00:06:12,209
all those things so it's a little bit

00:06:07,649 --> 00:06:14,639
more information for you to have now I

00:06:12,209 --> 00:06:16,740
talked about the down migration or the

00:06:14,639 --> 00:06:19,860
down direction rather in a migration and

00:06:16,740 --> 00:06:25,019
down means we undo a migration that we

00:06:19,860 --> 00:06:25,169
have done so another word for that would

00:06:25,019 --> 00:06:27,209
be

00:06:25,169 --> 00:06:32,249
roll back rolling back your database

00:06:27,209 --> 00:06:34,289
right now I want to get into where

00:06:32,249 --> 00:06:37,349
they're rolling back or actually rolling

00:06:34,289 --> 00:06:39,360
forward is the way to go now let's let's

00:06:37,349 --> 00:06:42,059
look into why a rollback could be a

00:06:39,360 --> 00:06:43,500
problem let's consider destructive

00:06:42,059 --> 00:06:46,110
changes

00:06:43,500 --> 00:06:48,000
a destructive changes changed could be a

00:06:46,110 --> 00:06:49,770
long-lived lock which means that

00:06:48,000 --> 00:06:52,110
transactions that come in are actually

00:06:49,770 --> 00:06:54,419
blocked or rejected as they come in

00:06:52,110 --> 00:06:56,610
which is a problem you need to store

00:06:54,419 --> 00:06:58,069
those transactions or retry somewhere so

00:06:56,610 --> 00:07:01,500
that's very destructive to your

00:06:58,069 --> 00:07:06,770
businesses at that point renaming things

00:07:01,500 --> 00:07:09,810
is of course destructive and deletion is

00:07:06,770 --> 00:07:14,190
if anything is is the most destructive

00:07:09,810 --> 00:07:18,030
thing now when it comes to for example

00:07:14,190 --> 00:07:21,470
my sequel or especially in the earlier

00:07:18,030 --> 00:07:23,569
versions a lot of the alter table

00:07:21,470 --> 00:07:27,389
statements that you could come up with

00:07:23,569 --> 00:07:30,030
trigger an implicit commit meaning that

00:07:27,389 --> 00:07:33,150
whatever transaction you're in if you do

00:07:30,030 --> 00:07:34,889
an alter table the transaction urine is

00:07:33,150 --> 00:07:37,050
actually automatically committed and a

00:07:34,889 --> 00:07:39,810
new transaction is started or if you're

00:07:37,050 --> 00:07:41,550
at that point and this is hard well it

00:07:39,810 --> 00:07:43,740
can be detected of course but then

00:07:41,550 --> 00:07:44,969
rolling back what would that mean would

00:07:43,740 --> 00:07:46,770
that mean rolling back that new

00:07:44,969 --> 00:07:50,039
transaction and the transaction before

00:07:46,770 --> 00:07:56,849
that as well if you want to view them as

00:07:50,039 --> 00:07:59,490
a single migration bless you so in the

00:07:56,849 --> 00:08:01,409
in the sense of an implicit commit well

00:07:59,490 --> 00:08:03,840
there's no longer a transaction to speak

00:08:01,409 --> 00:08:05,789
of another thing is sharding if you

00:08:03,840 --> 00:08:08,819
shard your database over multiple

00:08:05,789 --> 00:08:11,279
machines and you shard on a specific key

00:08:08,819 --> 00:08:13,319
for example then rolling back means

00:08:11,279 --> 00:08:15,389
going rolling back the schema migration

00:08:13,319 --> 00:08:19,289
means going back to all those machines

00:08:15,389 --> 00:08:22,110
and rolling the schema change back on

00:08:19,289 --> 00:08:24,630
those machines and potentially

00:08:22,110 --> 00:08:26,250
recharging if you have changed your

00:08:24,630 --> 00:08:30,389
shard key for example during that

00:08:26,250 --> 00:08:31,610
migration and one of the more important

00:08:30,389 --> 00:08:33,510
things is if you have multiple

00:08:31,610 --> 00:08:36,270
applications potentially multiple

00:08:33,510 --> 00:08:39,779
services attached to multiple databases

00:08:36,270 --> 00:08:42,060
that have are part of a distributed

00:08:39,779 --> 00:08:46,250
transaction rolling that back is going

00:08:42,060 --> 00:08:49,560
to be difficult if not impossible so

00:08:46,250 --> 00:08:52,050
another way of doing roll backs rather

00:08:49,560 --> 00:08:54,230
than rolling back your transaction would

00:08:52,050 --> 00:08:56,970
be restoring from a backup of course

00:08:54,230 --> 00:08:59,730
that implies that the

00:08:56,970 --> 00:09:01,199
backup is fresh enough young enough and

00:08:59,730 --> 00:09:04,259
that you don't have a lot of updates

00:09:01,199 --> 00:09:07,709
going on between the time of the last

00:09:04,259 --> 00:09:09,810
backup and where you are now because you

00:09:07,709 --> 00:09:11,899
would either lose all that information

00:09:09,810 --> 00:09:14,550
or you need some sort of mechanism to

00:09:11,899 --> 00:09:18,089
capture all that all those changes and

00:09:14,550 --> 00:09:21,000
replay them onto that latest backup that

00:09:18,089 --> 00:09:21,750
you have so I personally consider

00:09:21,000 --> 00:09:25,319
rollbacks

00:09:21,750 --> 00:09:28,610
to not be valid situation or not a valid

00:09:25,319 --> 00:09:31,769
setup in the modern world with databases

00:09:28,610 --> 00:09:34,500
if you can take your database offline 4x

00:09:31,769 --> 00:09:38,430
time sure then you can roll back from

00:09:34,500 --> 00:09:40,259
from a backup but we're here to learn

00:09:38,430 --> 00:09:42,660
about database changes without some

00:09:40,259 --> 00:09:45,480
downtime so in that context I don't

00:09:42,660 --> 00:09:48,709
consider roll backs to be viable now a

00:09:45,480 --> 00:09:52,920
little bit about downtime let's take a

00:09:48,709 --> 00:09:56,220
simple app with a database migrations

00:09:52,920 --> 00:09:59,089
typically in the the pipeline you would

00:09:56,220 --> 00:10:02,550
create a new package or a new tar.gz or

00:09:59,089 --> 00:10:05,399
whatever your deployment artifact is you

00:10:02,550 --> 00:10:08,100
then shut down the application you run

00:10:05,399 --> 00:10:12,899
your database migration deploy your

00:10:08,100 --> 00:10:15,029
package start the application and this

00:10:12,899 --> 00:10:16,740
is very simple there is you don't have

00:10:15,029 --> 00:10:18,269
any you don't have to do anything to

00:10:16,740 --> 00:10:19,740
your database other than run the

00:10:18,269 --> 00:10:22,290
migration of course you don't have to do

00:10:19,740 --> 00:10:24,540
anything fancy the problem is running

00:10:22,290 --> 00:10:26,879
the migration that can take quite a

00:10:24,540 --> 00:10:29,160
while depending on how big your database

00:10:26,879 --> 00:10:32,009
is so that ultimate automatic Lee

00:10:29,160 --> 00:10:33,839
determines the downtime now what if you

00:10:32,009 --> 00:10:34,829
don't want downtime which is why we're

00:10:33,839 --> 00:10:37,620
here

00:10:34,829 --> 00:10:39,149
I don't think downtown is acceptable at

00:10:37,620 --> 00:10:42,629
least not if we can avoid it in this

00:10:39,149 --> 00:10:44,309
case and especially if you start going

00:10:42,629 --> 00:10:46,740
toward things like continuous delivery

00:10:44,309 --> 00:10:49,230
where it continuous deliveries the

00:10:46,740 --> 00:10:51,930
states that your code should always be

00:10:49,230 --> 00:10:54,240
in a releasable state so at any point in

00:10:51,930 --> 00:10:57,199
time I should be able to go into the

00:10:54,240 --> 00:10:59,819
team room and say release now deploy now

00:10:57,199 --> 00:11:01,290
because continuous delivery stipulates

00:10:59,819 --> 00:11:04,769
that we should always be able to do that

00:11:01,290 --> 00:11:07,139
and if the latest migration that you add

00:11:04,769 --> 00:11:08,970
triggers a two-hour downtime then the

00:11:07,139 --> 00:11:10,410
code is obviously not always in a

00:11:08,970 --> 00:11:10,590
releasable state because then you need

00:11:10,410 --> 00:11:14,400
to

00:11:10,590 --> 00:11:16,560
find a deployment window so continuous

00:11:14,400 --> 00:11:18,450
delivery is like that even though the

00:11:16,560 --> 00:11:21,840
deployment to production is still a

00:11:18,450 --> 00:11:24,930
manual trigger it needs to be always

00:11:21,840 --> 00:11:26,430
ready for that to happen now continuous

00:11:24,930 --> 00:11:29,660
deployment what I've been talking about

00:11:26,430 --> 00:11:32,310
is code that passes all the tests and

00:11:29,660 --> 00:11:34,950
all the automatic validations it is

00:11:32,310 --> 00:11:37,110
automatically deployed to production so

00:11:34,950 --> 00:11:40,110
we cannot get away with downtime

00:11:37,110 --> 00:11:44,130
especially if we do it 50 plus the place

00:11:40,110 --> 00:11:49,020
for day so let's take a look at zero

00:11:44,130 --> 00:11:50,570
downtime deployments this is something

00:11:49,020 --> 00:11:53,910
you would do on highly available

00:11:50,570 --> 00:11:56,760
applications or servers so let's imagine

00:11:53,910 --> 00:11:59,280
a load balancer between us between the

00:11:56,760 --> 00:12:01,590
application and the internet and we have

00:11:59,280 --> 00:12:03,120
an app with a version one attached to

00:12:01,590 --> 00:12:05,700
that load balancer behind that load

00:12:03,120 --> 00:12:09,180
balancer now we have AB version two

00:12:05,700 --> 00:12:11,670
ready to go so we we start it and at

00:12:09,180 --> 00:12:13,110
some point it boots and then we add it

00:12:11,670 --> 00:12:16,860
to the load balancer and it starts

00:12:13,110 --> 00:12:20,040
receiving traffic at which point we take

00:12:16,860 --> 00:12:21,900
at v1 out of the load balancer and stop

00:12:20,040 --> 00:12:26,070
the instance or the container or

00:12:21,900 --> 00:12:29,010
whatever if you do this right then your

00:12:26,070 --> 00:12:31,500
end user will never know that app v1 has

00:12:29,010 --> 00:12:33,510
just been replaced with at v2 maybe they

00:12:31,500 --> 00:12:35,340
will see some new functionality but they

00:12:33,510 --> 00:12:38,490
should not have seen any downtime or any

00:12:35,340 --> 00:12:41,610
problems so no downtime now in this case

00:12:38,490 --> 00:12:44,340
we didn't have any migrations so it's

00:12:41,610 --> 00:12:46,440
easy we have no downtime but what if we

00:12:44,340 --> 00:12:49,080
have a certain database state well let's

00:12:46,440 --> 00:12:51,870
go back to MV one and let's assume we

00:12:49,080 --> 00:12:54,780
have a database of version 1 so app V 1

00:12:51,870 --> 00:13:00,800
expect the database to be in State v 1

00:12:54,780 --> 00:13:03,570
as well we then start at V 2 and F V 2

00:13:00,800 --> 00:13:06,090
surprise fries expects the database to

00:13:03,570 --> 00:13:09,510
be in version 2 State so at this point

00:13:06,090 --> 00:13:11,400
we have an inconsistent system at V 1

00:13:09,510 --> 00:13:14,160
expects the database to be in V 1 and V

00:13:11,400 --> 00:13:16,350
2 expects it to be in state V 2 it

00:13:14,160 --> 00:13:20,430
cannot be it cannot have the same States

00:13:16,350 --> 00:13:23,850
or both States concurrently so one of

00:13:20,430 --> 00:13:24,360
the two is going to crash probably or at

00:13:23,850 --> 00:13:29,519
least give

00:13:24,360 --> 00:13:32,310
wrong results so in general to avoid

00:13:29,519 --> 00:13:34,860
that the old app should always work with

00:13:32,310 --> 00:13:36,690
the new database state because of course

00:13:34,860 --> 00:13:38,610
the old app that is running now can not

00:13:36,690 --> 00:13:40,589
predict what the database were in what

00:13:38,610 --> 00:13:42,570
direction the database is going to do go

00:13:40,589 --> 00:13:44,640
so we need to make sure that the

00:13:42,570 --> 00:13:46,470
database change is always backwards

00:13:44,640 --> 00:13:49,200
compatible to what we have running in

00:13:46,470 --> 00:13:50,910
production with highly available setups

00:13:49,200 --> 00:13:52,290
you always need to assume that at least

00:13:50,910 --> 00:13:53,940
two versions of your app are

00:13:52,290 --> 00:13:56,370
concurrently running in production and

00:13:53,940 --> 00:13:59,399
if you adhere to this standard then you

00:13:56,370 --> 00:14:01,680
should be fine so it means that we need

00:13:59,399 --> 00:14:06,029
to decouple we need to decouple a

00:14:01,680 --> 00:14:08,279
database migration from a deployment and

00:14:06,029 --> 00:14:10,529
let's take a look at a few patterns that

00:14:08,279 --> 00:14:12,660
help us to do that one of them is called

00:14:10,529 --> 00:14:15,209
the expand contract pattern which is

00:14:12,660 --> 00:14:16,980
also applicable to code to API

00:14:15,209 --> 00:14:20,700
development but also to database of

00:14:16,980 --> 00:14:22,589
element and it stipulates very strongly

00:14:20,700 --> 00:14:26,279
that we should maintain backwards

00:14:22,589 --> 00:14:30,029
compatibility to whatever other system

00:14:26,279 --> 00:14:32,459
is relying on us so let's take it let's

00:14:30,029 --> 00:14:34,860
look at it from an API perspective we

00:14:32,459 --> 00:14:38,490
have a bunch of clients that are talking

00:14:34,860 --> 00:14:41,029
to an existing API and now we want to

00:14:38,490 --> 00:14:44,339
introduce a new version of that API and

00:14:41,029 --> 00:14:46,470
rather than changing the existing API

00:14:44,339 --> 00:14:48,779
which could probably lead to backwards

00:14:46,470 --> 00:14:51,000
compatibility issues with the three

00:14:48,779 --> 00:14:53,940
clients that we have now we add that new

00:14:51,000 --> 00:14:56,459
API and then we start deep deprecating

00:14:53,940 --> 00:14:58,740
the old API and we say ok you have X

00:14:56,459 --> 00:15:02,610
amount of time to switch over to that

00:14:58,740 --> 00:15:04,980
new API and one by one we switch over

00:15:02,610 --> 00:15:06,930
the clients to the new API at which

00:15:04,980 --> 00:15:08,839
point the existing API is no longer used

00:15:06,930 --> 00:15:12,660
and we can take it out of commission

00:15:08,839 --> 00:15:15,630
right in database terms it means that we

00:15:12,660 --> 00:15:20,029
can only do non-destructive changes and

00:15:15,630 --> 00:15:22,769
let's go deeper into what day would mean

00:15:20,029 --> 00:15:25,769
adding things in general is

00:15:22,769 --> 00:15:27,720
non-destructive especially because your

00:15:25,769 --> 00:15:30,180
old app is not relying on that to be

00:15:27,720 --> 00:15:32,959
there it doesn't even know that it's

00:15:30,180 --> 00:15:35,279
going to be there so adding tables

00:15:32,959 --> 00:15:37,820
non-destructive adding columns to

00:15:35,279 --> 00:15:41,610
existing tables same thing

00:15:37,820 --> 00:15:45,510
creating indices usually nondestructive

00:15:41,610 --> 00:15:50,250
depends on the database technology so

00:15:45,510 --> 00:15:51,960
now we have a bunch of tools or a bunch

00:15:50,250 --> 00:15:55,440
of things that we can do to our database

00:15:51,960 --> 00:15:57,450
to ensure backwards compatibility if we

00:15:55,440 --> 00:16:02,640
do that it means that we can always go a

00:15:57,450 --> 00:16:05,310
dispatch a different code so we migrated

00:16:02,640 --> 00:16:07,320
the database to v2 our app is now v2 in

00:16:05,310 --> 00:16:09,779
production we see a problem with M v2 we

00:16:07,320 --> 00:16:11,310
can always go back to MV one without

00:16:09,779 --> 00:16:14,460
having to touch the database because

00:16:11,310 --> 00:16:17,279
again at v2x backwards-compatible or

00:16:14,460 --> 00:16:20,430
rather the database v2 is backwards

00:16:17,279 --> 00:16:22,470
compatible with app v1 so whatever we do

00:16:20,430 --> 00:16:24,060
to the database in that particular

00:16:22,470 --> 00:16:26,490
change it doesn't really matter we can

00:16:24,060 --> 00:16:29,910
always go one version back in terms of

00:16:26,490 --> 00:16:33,360
the code I want to take you all into a

00:16:29,910 --> 00:16:37,220
little example an example to rename a

00:16:33,360 --> 00:16:40,830
column let's assume we have a table of

00:16:37,220 --> 00:16:43,740
persons that have a first name and a

00:16:40,830 --> 00:16:47,220
surname and we're not very happy with

00:16:43,740 --> 00:16:55,560
the column name surname so we want to

00:16:47,220 --> 00:16:58,200
actually rename that but again without

00:16:55,560 --> 00:17:00,720
introducing downtime so we're going to

00:16:58,200 --> 00:17:03,360
do this in a few steps rather than just

00:17:00,720 --> 00:17:05,870
in one step the first step is we create

00:17:03,360 --> 00:17:08,459
a column in the table with the new name

00:17:05,870 --> 00:17:11,339
so we don't actually touch surname yet

00:17:08,459 --> 00:17:16,439
we just add last name to that person to

00:17:11,339 --> 00:17:18,870
that table right we then start writing

00:17:16,439 --> 00:17:22,199
to both the old and the new columns

00:17:18,870 --> 00:17:24,360
whenever we do an update for example in

00:17:22,199 --> 00:17:26,790
your doctrine entity or something when

00:17:24,360 --> 00:17:29,010
we did set the last name in the entity

00:17:26,790 --> 00:17:32,030
we also make sure to set the surname so

00:17:29,010 --> 00:17:37,140
that it is populated for new objects and

00:17:32,030 --> 00:17:39,960
of course we switch our get last name to

00:17:37,140 --> 00:17:43,230
using the surname in this particular

00:17:39,960 --> 00:17:45,510
case and we may want to add an if there

00:17:43,230 --> 00:17:48,390
that if it's not set yet and we get the

00:17:45,510 --> 00:17:51,250
last name then we start migrating the

00:17:48,390 --> 00:17:53,410
old records so individual

00:17:51,250 --> 00:17:56,370
records that we did not touch we're

00:17:53,410 --> 00:18:00,610
going to update them just to make sure

00:17:56,370 --> 00:18:03,610
that last name is always set in every

00:18:00,610 --> 00:18:09,160
record and then we can start reading

00:18:03,610 --> 00:18:12,970
from the new column at which point we

00:18:09,160 --> 00:18:15,010
can remove the old column and decode to

00:18:12,970 --> 00:18:18,040
deal with this backwards compatibility

00:18:15,010 --> 00:18:21,580
and we actually switched so rather than

00:18:18,040 --> 00:18:23,680
having it in one single step where we

00:18:21,580 --> 00:18:25,420
deployed the change to the database and

00:18:23,680 --> 00:18:27,610
change to the code in in a single

00:18:25,420 --> 00:18:30,550
package in a single deployment we do it

00:18:27,610 --> 00:18:34,030
in in a couple of steps we we split it

00:18:30,550 --> 00:18:37,000
up essentially so cool that's simple

00:18:34,030 --> 00:18:39,370
well not really of course there are a

00:18:37,000 --> 00:18:42,160
few challenges its database technology

00:18:39,370 --> 00:18:44,890
after all one of them is dropping a

00:18:42,160 --> 00:18:46,660
column on a large table depending on the

00:18:44,890 --> 00:18:50,160
database engine that would mean a table

00:18:46,660 --> 00:18:50,160
lock for as long as it takes

00:18:50,250 --> 00:18:59,610
that is a that is a pain in the ass I

00:18:55,360 --> 00:19:04,030
cannot be any more clear about that

00:18:59,610 --> 00:19:06,960
another one is non novel so remember

00:19:04,030 --> 00:19:10,120
that I did add the column and I said

00:19:06,960 --> 00:19:13,480
that it was novel or at least you know I

00:19:10,120 --> 00:19:16,570
added the farc are 255 and nothing else

00:19:13,480 --> 00:19:18,400
so that means it it can be null if you

00:19:16,570 --> 00:19:19,930
say it cannot be null and of course

00:19:18,400 --> 00:19:24,160
everything you need to do you need to

00:19:19,930 --> 00:19:26,110
set a usable default value otherwise you

00:19:24,160 --> 00:19:30,430
would have integrity errands when you

00:19:26,110 --> 00:19:32,770
add new records you can however after

00:19:30,430 --> 00:19:35,340
you've done all your migrations alter

00:19:32,770 --> 00:19:38,260
the column again to make it non nullable

00:19:35,340 --> 00:19:40,600
when you have verified that every single

00:19:38,260 --> 00:19:43,240
record in that database or in the table

00:19:40,600 --> 00:19:46,810
has an actual value for the non-local

00:19:43,240 --> 00:19:50,620
type other interesting things are if you

00:19:46,810 --> 00:19:52,150
migrate primary keys and then you have

00:19:50,620 --> 00:19:56,700
your foreign key constraints and stuff

00:19:52,150 --> 00:20:00,460
like that but those are a little bit I

00:19:56,700 --> 00:20:04,510
think more rare I've never needed to do

00:20:00,460 --> 00:20:07,270
that at least not on an existing table

00:20:04,510 --> 00:20:10,930
I want to discuss the concept of a

00:20:07,270 --> 00:20:13,270
feature toggle with you in the context

00:20:10,930 --> 00:20:15,490
of a database migration database

00:20:13,270 --> 00:20:19,540
migrations and feature toggle well

00:20:15,490 --> 00:20:21,970
feature toggle enables us or helps us to

00:20:19,540 --> 00:20:26,440
enable and disable individual features

00:20:21,970 --> 00:20:29,350
in code at runtime it means that we have

00:20:26,440 --> 00:20:30,760
alternative code paths in the code

00:20:29,350 --> 00:20:33,070
essentially it's a glorified if

00:20:30,760 --> 00:20:35,770
statement if the feature toggles on or

00:20:33,070 --> 00:20:37,840
evaluates to true we have one code path

00:20:35,770 --> 00:20:40,390
is it if it evaluates to false we have

00:20:37,840 --> 00:20:42,490
the other code path and again we can

00:20:40,390 --> 00:20:45,880
switch that at runtime now translating

00:20:42,490 --> 00:20:47,890
that back to an actual application we

00:20:45,880 --> 00:20:50,920
would have two versions of a front-end

00:20:47,890 --> 00:20:52,900
page for example an old one on the left

00:20:50,920 --> 00:20:55,540
and the new one on the right and the

00:20:52,900 --> 00:20:57,910
feature toggle we can switch based on IP

00:20:55,540 --> 00:21:01,180
address for example or a cookie setting

00:20:57,910 --> 00:21:04,000
or whatever to have people see the new

00:21:01,180 --> 00:21:06,070
version depending on what do we allow

00:21:04,000 --> 00:21:08,710
them to see that it's sort of a be

00:21:06,070 --> 00:21:11,410
testing but then on the feature level on

00:21:08,710 --> 00:21:14,980
the functional level applying that to

00:21:11,410 --> 00:21:16,600
databases to database migrations we

00:21:14,980 --> 00:21:18,730
could add a feature toggle and be

00:21:16,600 --> 00:21:22,540
writing to the old and reading from the

00:21:18,730 --> 00:21:25,810
new stages this allows us to do the

00:21:22,540 --> 00:21:28,690
whole code change at once in the single

00:21:25,810 --> 00:21:30,490
deployment and the code for writing to

00:21:28,690 --> 00:21:34,270
the old and the new columns would simply

00:21:30,490 --> 00:21:36,730
remain dormant in production until we

00:21:34,270 --> 00:21:40,120
enable that feature toggle same goes for

00:21:36,730 --> 00:21:42,160
reading from the nukes new column which

00:21:40,120 --> 00:21:43,840
means that we have what we can do did

00:21:42,160 --> 00:21:47,860
the code change at once we can test it

00:21:43,840 --> 00:21:50,710
together and we can even improve and

00:21:47,860 --> 00:21:52,720
iterate on that and test it in staging

00:21:50,710 --> 00:21:55,150
perhaps and at some point when we're

00:21:52,720 --> 00:21:57,790
confident with it we flip the toggle on

00:21:55,150 --> 00:22:00,100
production and hey presto our old column

00:21:57,790 --> 00:22:02,260
or or our new column starts filling with

00:22:00,100 --> 00:22:07,240
data and then we can read from the new

00:22:02,260 --> 00:22:10,030
column now if you do a migration if you

00:22:07,240 --> 00:22:15,820
add migrations you typically want to

00:22:10,030 --> 00:22:17,590
test them as well so I would strongly

00:22:15,820 --> 00:22:18,010
advise to keep them as part of source

00:22:17,590 --> 00:22:20,500
control

00:22:18,010 --> 00:22:22,710
probably with the application that is

00:22:20,500 --> 00:22:27,460
actually using that particular database

00:22:22,710 --> 00:22:30,240
or that that set of tables at least and

00:22:27,460 --> 00:22:35,980
include a testing stage in your pipeline

00:22:30,240 --> 00:22:38,560
so have for example an empty my sequel

00:22:35,980 --> 00:22:40,510
or a sequel light spun up before you run

00:22:38,560 --> 00:22:43,000
your tests and then apply all the

00:22:40,510 --> 00:22:46,690
immigrations to that empty my sequel or

00:22:43,000 --> 00:22:48,250
a sequel light instance just to test

00:22:46,690 --> 00:22:49,480
whether your migrations actually

00:22:48,250 --> 00:22:53,500
actually make any sense

00:22:49,480 --> 00:22:56,320
or did they work you can even add fake

00:22:53,500 --> 00:22:58,720
data to that to see how it would respond

00:22:56,320 --> 00:23:00,460
not just to an empty database where you

00:22:58,720 --> 00:23:03,460
just test the schema changes but also

00:23:00,460 --> 00:23:08,280
how it actually effects data that you

00:23:03,460 --> 00:23:11,590
have and you can even or probably should

00:23:08,280 --> 00:23:14,710
run that on staging and have some

00:23:11,590 --> 00:23:17,770
sensible set of data on your staging or

00:23:14,710 --> 00:23:21,360
acceptance environment which as close as

00:23:17,770 --> 00:23:25,930
possible mirrors the data on production

00:23:21,360 --> 00:23:28,750
as close as possible is becoming more

00:23:25,930 --> 00:23:32,820
and more of a thing especially now with

00:23:28,750 --> 00:23:35,200
the GDP are coming in effect in May

00:23:32,820 --> 00:23:38,170
which depending on how you read it

00:23:35,200 --> 00:23:40,120
stipulates that staging data should be

00:23:38,170 --> 00:23:43,230
anonymized or at least you cannot copy

00:23:40,120 --> 00:23:46,300
production data verbatim to acceptance

00:23:43,230 --> 00:23:49,620
because typically the access controls to

00:23:46,300 --> 00:23:53,710
acceptance are a little bit more open

00:23:49,620 --> 00:23:55,360
than production but you could run all

00:23:53,710 --> 00:23:56,790
that data through a filter or something

00:23:55,360 --> 00:24:00,570
and anonymize all the personal

00:23:56,790 --> 00:24:02,860
identifiable information and again

00:24:00,570 --> 00:24:04,810
referring back to the feature toggle you

00:24:02,860 --> 00:24:06,670
can actually flip a future toggle

00:24:04,810 --> 00:24:11,580
specifically for staging or acceptance

00:24:06,670 --> 00:24:13,960
and then have that test over there okay

00:24:11,580 --> 00:24:17,110
digressing a little bit into no sequel

00:24:13,960 --> 00:24:19,960
land which is also known as no schema

00:24:17,110 --> 00:24:22,300
land which is for our intensive purposes

00:24:19,960 --> 00:24:25,720
is very cool because we don't actually

00:24:22,300 --> 00:24:27,400
have a schema to change there is no

00:24:25,720 --> 00:24:30,100
schema so we don't have to do anything

00:24:27,400 --> 00:24:31,389
to change it but if you do want to do

00:24:30,100 --> 00:24:35,019
database or

00:24:31,389 --> 00:24:37,419
migrations one of the options you have

00:24:35,019 --> 00:24:42,009
is migrate during reads so as you do a

00:24:37,419 --> 00:24:44,739
read you get the document for example

00:24:42,009 --> 00:24:48,190
from a MongoDB or couchdb you get the

00:24:44,739 --> 00:24:50,769
document in memory and then some fields

00:24:48,190 --> 00:24:52,209
will not actually exist because they the

00:24:50,769 --> 00:24:57,009
document has been written before that

00:24:52,209 --> 00:24:58,859
field existed you can then add some

00:24:57,009 --> 00:25:02,499
default values stored out field or

00:24:58,859 --> 00:25:04,119
rename fields in memory and of course

00:25:02,499 --> 00:25:06,219
you have to write that back to the

00:25:04,119 --> 00:25:09,249
database as soon as you are done with

00:25:06,219 --> 00:25:11,049
that migration so in line or in the

00:25:09,249 --> 00:25:13,049
background actually as you do a single

00:25:11,049 --> 00:25:16,299
breed you will have some code that will

00:25:13,049 --> 00:25:17,919
change the document to the new state and

00:25:16,299 --> 00:25:19,749
then immediately write it back to the

00:25:17,919 --> 00:25:22,179
database now that also means that

00:25:19,749 --> 00:25:24,219
depending on what you read you will

00:25:22,179 --> 00:25:27,099
never touch all the records there will

00:25:24,219 --> 00:25:29,529
always be a bunch of records that you

00:25:27,099 --> 00:25:33,099
will not touch or not touch in a long

00:25:29,529 --> 00:25:34,899
time so while this is going on you also

00:25:33,099 --> 00:25:36,789
want to run the background migration on

00:25:34,899 --> 00:25:38,700
all the records you are not going to

00:25:36,789 --> 00:25:42,339
touch or you don't haven't touched yet

00:25:38,700 --> 00:25:44,499
so in chunks take a bunch of documents

00:25:42,339 --> 00:25:48,849
and modify them and write them back to

00:25:44,499 --> 00:25:51,669
the database again the nice thing about

00:25:48,849 --> 00:25:54,700
that is that it has no downtime but it

00:25:51,669 --> 00:25:58,659
does require some housekeeping in that

00:25:54,700 --> 00:26:01,179
you need to maintain a counter or log

00:25:58,659 --> 00:26:03,519
where you've been in terms of the

00:26:01,179 --> 00:26:06,369
background migration and so that you can

00:26:03,519 --> 00:26:10,450
resume with another chunk and another

00:26:06,369 --> 00:26:14,919
chunk okay something I want to talk

00:26:10,450 --> 00:26:18,570
about is another challenge in migrating

00:26:14,919 --> 00:26:21,159
databases and that is a large data set a

00:26:18,570 --> 00:26:23,829
large data sets and dropping columns we

00:26:21,159 --> 00:26:26,079
also talked about that of course but in

00:26:23,829 --> 00:26:29,829
general large data sets mean long

00:26:26,079 --> 00:26:33,669
running migrations which in terms of

00:26:29,829 --> 00:26:35,409
errors you will typically do migrations

00:26:33,669 --> 00:26:37,029
that I've had that run for hours and

00:26:35,409 --> 00:26:40,119
hours they will fail right at the very

00:26:37,029 --> 00:26:44,519
end and rarely in the beginning which is

00:26:40,119 --> 00:26:44,519
annoying to say the least

00:26:44,730 --> 00:26:49,450
because it makes debugging a little bit

00:26:46,899 --> 00:26:51,960
more of a problem long-running queries

00:26:49,450 --> 00:26:55,630
especially if you have migrations debt

00:26:51,960 --> 00:26:58,299
let's say you split a street name in a

00:26:55,630 --> 00:27:00,130
house number that were - that was one

00:26:58,299 --> 00:27:02,679
field and you want to split that now

00:27:00,130 --> 00:27:04,840
that is computationally complicated

00:27:02,679 --> 00:27:07,620
depending on the country you're in but

00:27:04,840 --> 00:27:10,480
if you could write a query to do that

00:27:07,620 --> 00:27:12,309
that could run a very long time and

00:27:10,480 --> 00:27:15,190
that's something that you need to be

00:27:12,309 --> 00:27:17,409
aware of because memory use it's just

00:27:15,190 --> 00:27:19,419
then potentially a problem if you do

00:27:17,409 --> 00:27:22,149
things in memory or also in the

00:27:19,419 --> 00:27:24,279
databases memory and again if you fail

00:27:22,149 --> 00:27:28,210
at some point in a migration or such a

00:27:24,279 --> 00:27:30,070
query where did you stop and can you

00:27:28,210 --> 00:27:33,340
restart or resume from the point where

00:27:30,070 --> 00:27:36,130
you failed and do you record that

00:27:33,340 --> 00:27:39,039
and also what is very important with

00:27:36,130 --> 00:27:41,409
these things is log where you what you

00:27:39,039 --> 00:27:45,299
do and log the progress of where you are

00:27:41,409 --> 00:27:47,529
so again it helps you to debug and

00:27:45,299 --> 00:27:54,340
eventually restart or resume your

00:27:47,529 --> 00:27:56,110
process yeah one of the other strategies

00:27:54,340 --> 00:27:59,889
that is running the migration on a

00:27:56,110 --> 00:28:02,500
failover so let's say we have a

00:27:59,889 --> 00:28:05,230
replicated database we have a master and

00:28:02,500 --> 00:28:08,559
the slave set up and both have the

00:28:05,230 --> 00:28:11,260
schema in version 1.0 and potentially

00:28:08,559 --> 00:28:14,200
even maybe not even a schema but that

00:28:11,260 --> 00:28:16,360
just the database engine version right

00:28:14,200 --> 00:28:18,549
and we want to upgrade either the engine

00:28:16,360 --> 00:28:21,250
version or the schema now one of the

00:28:18,549 --> 00:28:24,460
things you could do is terminate the

00:28:21,250 --> 00:28:28,240
slave replication so you only have

00:28:24,460 --> 00:28:31,240
master and then you modified the slave

00:28:28,240 --> 00:28:33,549
to 2.0 whatever 2.0 is whether that's a

00:28:31,240 --> 00:28:36,179
schema or the engine version and then

00:28:33,549 --> 00:28:39,460
bring it up and bump it to master and

00:28:36,179 --> 00:28:41,260
then immediately you of course the old

00:28:39,460 --> 00:28:43,120
master refers to being a slave and you

00:28:41,260 --> 00:28:45,669
take that offline and you start

00:28:43,120 --> 00:28:49,720
migrating that and then you pull it up

00:28:45,669 --> 00:28:53,019
again and at the replication restarts

00:28:49,720 --> 00:28:54,940
but only in the other direction so what

00:28:53,019 --> 00:28:56,830
was the slave is now the master and vice

00:28:54,940 --> 00:28:59,650
versa

00:28:56,830 --> 00:29:02,260
of course your master or your single

00:28:59,650 --> 00:29:04,419
machine needs to be beefy enough to

00:29:02,260 --> 00:29:06,730
handle the traffic especially if you do

00:29:04,419 --> 00:29:09,340
reads for example from your slaves then

00:29:06,730 --> 00:29:12,190
your master needs to be beefy enough to

00:29:09,340 --> 00:29:17,620
handle this but this is a completely no

00:29:12,190 --> 00:29:20,710
downtime scenario plus if the migration

00:29:17,620 --> 00:29:24,610
on the slave fails it's relatively easy

00:29:20,710 --> 00:29:27,760
to bring it back we can simply pull it

00:29:24,610 --> 00:29:30,130
into replication again and either from

00:29:27,760 --> 00:29:33,039
an empty slave or the last known backup

00:29:30,130 --> 00:29:34,929
and it will catch up to whatever is

00:29:33,039 --> 00:29:36,610
reality on the master and we'll have a

00:29:34,929 --> 00:29:39,100
full cluster again and we can try again

00:29:36,610 --> 00:29:41,679
at that point this is something that for

00:29:39,100 --> 00:29:44,679
example at sea has done quite a few

00:29:41,679 --> 00:29:47,110
times to do their diet database

00:29:44,679 --> 00:29:52,750
migrations and they have seriously large

00:29:47,110 --> 00:29:55,929
databases so another strategy that you

00:29:52,750 --> 00:30:00,309
could use is introduce a message bus or

00:29:55,929 --> 00:30:02,110
queue or something called Kafka but

00:30:00,309 --> 00:30:04,990
there are other technologies as well

00:30:02,110 --> 00:30:06,309
RabbitMQ serves well and let's take a

00:30:04,990 --> 00:30:09,659
look at what there are a world look

00:30:06,309 --> 00:30:13,179
would look like then we have a UI layer

00:30:09,659 --> 00:30:15,970
which sends messages not directly to the

00:30:13,179 --> 00:30:18,220
backend in this case but through a queue

00:30:15,970 --> 00:30:20,020
or through a message bus and those

00:30:18,220 --> 00:30:23,289
messages are then picked up from the

00:30:20,020 --> 00:30:25,450
queue by the backend and processed and

00:30:23,289 --> 00:30:28,330
typically lead to state changes in the

00:30:25,450 --> 00:30:31,360
database and that database is then query

00:30:28,330 --> 00:30:34,240
through a data layer by the UI so we

00:30:31,360 --> 00:30:38,260
have a complete loop now now if we want

00:30:34,240 --> 00:30:41,020
to replace the database technology one

00:30:38,260 --> 00:30:44,440
of the things we could do is simply take

00:30:41,020 --> 00:30:45,850
the backend out for a while and the

00:30:44,440 --> 00:30:48,309
queue will simply start filling up with

00:30:45,850 --> 00:30:50,679
messages there will no up the updates

00:30:48,309 --> 00:30:53,559
will not take place but we won't be down

00:30:50,679 --> 00:30:55,809
we can inform our users that we won't

00:30:53,559 --> 00:30:58,059
process process any updates for the next

00:30:55,809 --> 00:31:01,049
however long we think it's going to take

00:30:58,059 --> 00:31:04,929
we add a new database or a new table and

00:31:01,049 --> 00:31:06,700
then we entry enable the backend and it

00:31:04,929 --> 00:31:09,490
catches up with all the messages that

00:31:06,700 --> 00:31:10,300
are in the queue and then it can process

00:31:09,490 --> 00:31:14,980
those on

00:31:10,300 --> 00:31:18,640
database this leads to a more general

00:31:14,980 --> 00:31:21,060
pattern called CQRS which stands for

00:31:18,640 --> 00:31:24,730
command query responsibility segregation

00:31:21,060 --> 00:31:27,760
which is a mouthful for basically saying

00:31:24,730 --> 00:31:30,970
we separate reading from writing so

00:31:27,760 --> 00:31:33,220
rather than reading and writing to the

00:31:30,970 --> 00:31:36,400
exact same database and database model

00:31:33,220 --> 00:31:39,970
we actually split the two so we write to

00:31:36,400 --> 00:31:42,630
something that is uniquely geared

00:31:39,970 --> 00:31:46,450
towards us writing that data very fast

00:31:42,630 --> 00:31:49,120
or at least very structured and then we

00:31:46,450 --> 00:31:51,960
have one or more database models that

00:31:49,120 --> 00:31:56,290
are geared toward just reading that data

00:31:51,960 --> 00:31:59,020
it also says that we can then store any

00:31:56,290 --> 00:32:02,890
update that we have in a log somewhere

00:31:59,020 --> 00:32:04,900
and CQRS marries very well with the

00:32:02,890 --> 00:32:06,730
thing called event sourcing there's a

00:32:04,900 --> 00:32:10,540
talk later today I think about this

00:32:06,730 --> 00:32:13,120
particular topic and then when you look

00:32:10,540 --> 00:32:15,400
at that particular world it looks a

00:32:13,120 --> 00:32:19,000
little bit similar but rather than

00:32:15,400 --> 00:32:22,050
messages to cue we have the UI sending

00:32:19,000 --> 00:32:25,150
commands to the backend commands

00:32:22,050 --> 00:32:27,430
basically saying to the backend this is

00:32:25,150 --> 00:32:30,220
what I want to achieve and when that's

00:32:27,430 --> 00:32:32,460
all validated by the backend it turns

00:32:30,220 --> 00:32:35,050
into events something has been done and

00:32:32,460 --> 00:32:38,980
those events are then handled and

00:32:35,050 --> 00:32:41,830
replayed as or handled by event handlers

00:32:38,980 --> 00:32:44,470
and they in turn can influence multiple

00:32:41,830 --> 00:32:46,480
databases multiple different databases

00:32:44,470 --> 00:32:49,770
with different schemas different models

00:32:46,480 --> 00:32:52,500
and if I want to have a completely new

00:32:49,770 --> 00:32:56,950
database model based on all those things

00:32:52,500 --> 00:33:01,120
then I can get any of the updates that I

00:32:56,950 --> 00:33:04,780
have in my log apply to the new query

00:33:01,120 --> 00:33:07,180
model and if I have seen the last update

00:33:04,780 --> 00:33:09,040
in my log then I use that new query

00:33:07,180 --> 00:33:11,920
model and otherwise a loop until I have

00:33:09,040 --> 00:33:16,030
replayed the entire event log to my

00:33:11,920 --> 00:33:18,790
database and so I can even use that to

00:33:16,030 --> 00:33:20,530
rebuild staging from scratch use the

00:33:18,790 --> 00:33:23,350
event log or the update log from

00:33:20,530 --> 00:33:24,220
production and rebuild staging just by

00:33:23,350 --> 00:33:27,370
run

00:33:24,220 --> 00:33:31,000
all the updates again onto a fresh empty

00:33:27,370 --> 00:33:32,610
staging database and of course we can

00:33:31,000 --> 00:33:38,530
then run it through a filter to

00:33:32,610 --> 00:33:42,820
anonymize the staging data now a couple

00:33:38,530 --> 00:33:45,010
of tools to help you of course we have

00:33:42,820 --> 00:33:47,140
the simple or the simple we have the

00:33:45,010 --> 00:33:49,690
typical migration tools there's Flyway

00:33:47,140 --> 00:33:52,830
doctrine I talked about thing has

00:33:49,690 --> 00:33:55,780
something for this there's laravel and

00:33:52,830 --> 00:33:59,350
liquid base which is also a very useful

00:33:55,780 --> 00:34:01,120
tool set for these particular things but

00:33:59,350 --> 00:34:03,880
one very cool tool which I found out

00:34:01,120 --> 00:34:08,950
about last year is percona tools online

00:34:03,880 --> 00:34:10,840
schema change and I'm not sure if this

00:34:08,950 --> 00:34:12,760
actually works on a box standard my

00:34:10,840 --> 00:34:15,340
sequel it does work on there Percona

00:34:12,760 --> 00:34:18,810
offering but what's cool about online

00:34:15,340 --> 00:34:21,160
schema change is that it uses triggers

00:34:18,810 --> 00:34:23,770
to do the whole thing we just talked

00:34:21,160 --> 00:34:26,710
about without you having to do all these

00:34:23,770 --> 00:34:29,380
things basically so what it does is it

00:34:26,710 --> 00:34:31,660
creates a shadow copy and that is

00:34:29,380 --> 00:34:35,860
basically your target table and that has

00:34:31,660 --> 00:34:38,320
the new schema version for you so going

00:34:35,860 --> 00:34:40,870
back to the surname last name we would

00:34:38,320 --> 00:34:44,020
have a shadow copy which has the surname

00:34:40,870 --> 00:34:45,910
or rather the last name sorry and not

00:34:44,020 --> 00:34:50,140
discern name and then we have a source

00:34:45,910 --> 00:34:51,669
table which still has surname and online

00:34:50,140 --> 00:34:54,400
schema change then adds a bunch of

00:34:51,669 --> 00:34:56,800
triggers so that any update to the

00:34:54,400 --> 00:34:59,800
source table which is still very much in

00:34:56,800 --> 00:35:03,940
use at that point is forwarded to the

00:34:59,800 --> 00:35:06,160
shadow copy all right and then the tool

00:35:03,940 --> 00:35:08,440
starts copying the source data in small

00:35:06,160 --> 00:35:11,050
chunks from the source table to the

00:35:08,440 --> 00:35:13,030
shadow copy to the target table and at

00:35:11,050 --> 00:35:15,490
some point that process is considered

00:35:13,030 --> 00:35:18,550
complete and then the target table is

00:35:15,490 --> 00:35:21,520
renamed to the source table and without

00:35:18,550 --> 00:35:24,490
the application knowing about it your

00:35:21,520 --> 00:35:27,670
source table has now bumped up in schema

00:35:24,490 --> 00:35:29,920
version and of course the backwards

00:35:27,670 --> 00:35:32,890
compatibility encode principle still

00:35:29,920 --> 00:35:35,890
very much applies because now you have

00:35:32,890 --> 00:35:37,570
in production an app that is not aware

00:35:35,890 --> 00:35:38,560
that under the under the hood

00:35:37,570 --> 00:35:40,660
essentially

00:35:38,560 --> 00:35:42,340
a schema change tool and a bunch of

00:35:40,660 --> 00:35:43,780
triggers are taking care of this so at

00:35:42,340 --> 00:35:47,170
some point the process is going to be

00:35:43,780 --> 00:35:50,680
complete and then your source table is

00:35:47,170 --> 00:35:52,690
no longer in the state that you

00:35:50,680 --> 00:35:55,330
previously had so the app needs to be

00:35:52,690 --> 00:36:01,390
able to handle that of course otherwise

00:35:55,330 --> 00:36:05,740
it would still break okay I want to

00:36:01,390 --> 00:36:07,600
recap this talk if you do database

00:36:05,740 --> 00:36:09,640
schema migration do it in multiple steps

00:36:07,600 --> 00:36:10,570
rather than just a single step of

00:36:09,640 --> 00:36:13,570
deployment

00:36:10,570 --> 00:36:16,180
with the code and don't do any breaking

00:36:13,570 --> 00:36:19,060
changes always maintain backwards

00:36:16,180 --> 00:36:22,090
compatibility if you want to read more

00:36:19,060 --> 00:36:24,120
about this topic then I can heartily

00:36:22,090 --> 00:36:26,440
recommend refactoring databases and

00:36:24,120 --> 00:36:28,450
there's the accompanying website

00:36:26,440 --> 00:36:30,730
database refactoring comm and there's

00:36:28,450 --> 00:36:32,770
another get up link I'll make sure to

00:36:30,730 --> 00:36:34,900
post these slides online and on join in

00:36:32,770 --> 00:36:39,820
later on so you can read that back on

00:36:34,900 --> 00:36:41,890
that alright if you want to reach out to

00:36:39,820 --> 00:36:44,320
me that's my twitter handle my email

00:36:41,890 --> 00:36:46,240
address and my personal blog site and i

00:36:44,320 --> 00:36:48,460
would love for you to leave me some

00:36:46,240 --> 00:36:51,630
feedback on this particular talk at that

00:36:48,460 --> 00:36:51,630

YouTube URL: https://www.youtube.com/watch?v=un-vdrVAX-A


