Title: PHP UK Conference 2018  - Jachim Coudenys - How Doctrine Caching Can Skyrocket Your Application
Publication date: 2018-03-27
Playlist: PHP UK Conference 2018
Description: 
	When people talk about Doctrine (or any ORM for that matter), the performance issue always comes up fairly quickly. Besides the fact that Doctrine will help you develop faster, so a little overhead doesn't really matter, there are numerous options to increase the performance of the application. By understanding how the system works in the first place, a lot of issues can be avoided right away. When you have done everything to avoid these pitfalls, you can bring in the big guns: caching. Doctrine has different caching mechanism and since Doctrine 2.5 "Second Level Cache" was added to our toolbox. After this talk, you should know what the impact is of every cache and how to use it.
Captions: 
	00:00:03,049 --> 00:00:08,910
hello my name is Hakeem ku Denise and I

00:00:07,259 --> 00:00:13,429
work for a company called comb Bell

00:00:08,910 --> 00:00:16,770
we're a hosting company and Belgium and

00:00:13,429 --> 00:00:23,820
next to that I organized a local user

00:00:16,770 --> 00:00:25,800
group and knows him and today we're

00:00:23,820 --> 00:00:27,630
going to talk about how dr. Ian caching

00:00:25,800 --> 00:00:30,449
can correctly because skyrocket your

00:00:27,630 --> 00:00:35,070
application I give this talk before and

00:00:30,449 --> 00:00:37,050
then I had this image as a background as

00:00:35,070 --> 00:00:41,790
of last week I can use the real image

00:00:37,050 --> 00:00:47,760
instead of the simulation so so this

00:00:41,790 --> 00:00:50,700
talk is about doctrine and I will first

00:00:47,760 --> 00:00:52,559
give a small crash course of doctrine

00:00:50,700 --> 00:00:55,350
then I will talk about the internals

00:00:52,559 --> 00:00:59,039
because by knowing how doctrine works

00:00:55,350 --> 00:01:01,770
you can boost the application quite a

00:00:59,039 --> 00:01:05,790
bit and that D at the end I will talk

00:01:01,770 --> 00:01:12,150
about adding cash the doctrine who uses

00:01:05,790 --> 00:01:16,740
doctrine all right excellent so there's

00:01:12,150 --> 00:01:19,409
a small small disclaimer for this talk

00:01:16,740 --> 00:01:20,970
it's only when you're using doctrine

00:01:19,409 --> 00:01:23,580
that it will if you know how the

00:01:20,970 --> 00:01:27,110
internals work that's it was quite waco

00:01:23,580 --> 00:01:30,619
skyrocket your application obviously so

00:01:27,110 --> 00:01:33,420
what is doctrine doctrine is a object

00:01:30,619 --> 00:01:34,890
relational mapper and that is a program

00:01:33,420 --> 00:01:37,740
programming technique for converting

00:01:34,890 --> 00:01:39,240
data between ankle patrol pipe systems

00:01:37,740 --> 00:01:42,090
using object-oriented programming

00:01:39,240 --> 00:01:46,920
languages so what annavaram basically

00:01:42,090 --> 00:01:48,930
this is mapping data from a database

00:01:46,920 --> 00:01:53,189
into objects that you can use in your

00:01:48,930 --> 00:01:55,890
application and vice versa it will then

00:01:53,189 --> 00:01:58,229
translate and the objects look for

00:01:55,890 --> 00:01:59,780
changes in the objects and persistent

00:01:58,229 --> 00:02:04,369
back to the database

00:01:59,780 --> 00:02:07,740
so before we will have a quick

00:02:04,369 --> 00:02:10,229
introduction of doctrine there's there

00:02:07,740 --> 00:02:13,470
some terminology that you have to be

00:02:10,229 --> 00:02:13,860
aware of we have a concept called

00:02:13,470 --> 00:02:16,160
end

00:02:13,860 --> 00:02:22,860
these are just glasses with an identity

00:02:16,160 --> 00:02:26,490
and can have data - it can have

00:02:22,860 --> 00:02:30,420
collections and other stuff and we have

00:02:26,490 --> 00:02:34,020
a mapping mechanism which tells doctrine

00:02:30,420 --> 00:02:36,810
how to map some properties to database

00:02:34,020 --> 00:02:39,780
tables and how to map collections and

00:02:36,810 --> 00:02:44,580
that entity to foreign keys and

00:02:39,780 --> 00:02:47,550
relations in the database we have

00:02:44,580 --> 00:02:52,410
repositories and repositories as a way

00:02:47,550 --> 00:02:56,460
of handling and or of fetching entities

00:02:52,410 --> 00:02:59,220
from the object manager and the object

00:02:56,460 --> 00:03:02,270
or the entity manager is the way we

00:02:59,220 --> 00:03:08,150
interact with dr. inti fetch and store

00:03:02,270 --> 00:03:10,800
entities into the database so there's a

00:03:08,150 --> 00:03:12,540
getting started tutorial on the website

00:03:10,800 --> 00:03:16,620
of doctrine and there is a github

00:03:12,540 --> 00:03:21,560
repository which contains all the code I

00:03:16,620 --> 00:03:26,550
have a small fork of it which automates

00:03:21,560 --> 00:03:32,880
which automates some some things so here

00:03:26,550 --> 00:03:37,680
is my fork and I can run the tutorial

00:03:32,880 --> 00:03:39,239
and it will just show the PHP examples

00:03:37,680 --> 00:03:42,170
and then execute em so you know what's

00:03:39,239 --> 00:03:45,840
what's going on so first of all we just

00:03:42,170 --> 00:03:51,230
install composure and if we install

00:03:45,840 --> 00:03:56,060
composure we have the vendor directory

00:03:51,230 --> 00:04:02,670
here on the screen and we also have some

00:03:56,060 --> 00:04:06,239
basic entities so we have a we have a

00:04:02,670 --> 00:04:10,980
product which has a ID and a name then

00:04:06,239 --> 00:04:13,230
we have a Burke and the Burke has a

00:04:10,980 --> 00:04:16,470
description it can be filed against a

00:04:13,230 --> 00:04:19,470
Burke against the product so it has a

00:04:16,470 --> 00:04:23,070
list of products and it can have it has

00:04:19,470 --> 00:04:26,720
a engineer and an assignee and these are

00:04:23,070 --> 00:04:29,600
the this is the user

00:04:26,720 --> 00:04:35,360
entity which again has a name and then

00:04:29,600 --> 00:04:40,370
some collections referencing D the other

00:04:35,360 --> 00:04:42,290
entities so we have three entities we

00:04:40,370 --> 00:04:44,960
have a mapping system and the mapping

00:04:42,290 --> 00:04:47,210
system here is the annotation mapping so

00:04:44,960 --> 00:04:50,000
here we say we have an ID value we have

00:04:47,210 --> 00:04:51,980
a column of a specific type

00:04:50,000 --> 00:04:56,060
so doctrine notes it has to create a

00:04:51,980 --> 00:04:59,180
voucher we have some relational mapping

00:04:56,060 --> 00:05:05,180
and information so doctoring should know

00:04:59,180 --> 00:05:08,060
what to do so if we install composer we

00:05:05,180 --> 00:05:12,470
have some scripts that we can use and

00:05:08,060 --> 00:05:14,780
here we see we have a schema tool and I

00:05:12,470 --> 00:05:18,920
will drop it because I will create it

00:05:14,780 --> 00:05:21,410
once again and here we will ask the

00:05:18,920 --> 00:05:23,360
schema tool to read all the annotations

00:05:21,410 --> 00:05:27,890
and then just generate a database

00:05:23,360 --> 00:05:32,090
database for us and our case that will

00:05:27,890 --> 00:05:34,880
generate a sequel Lite database so here

00:05:32,090 --> 00:05:38,780
we have a driver and I will just create

00:05:34,880 --> 00:05:40,850
this sequel lights database so I have

00:05:38,780 --> 00:05:46,070
dropped it and I have a new database

00:05:40,850 --> 00:05:50,990
with all the schema definitions that are

00:05:46,070 --> 00:05:52,940
necessary to run this tutorial so it

00:05:50,990 --> 00:05:58,460
says don't do this in production because

00:05:52,940 --> 00:06:02,630
it will just try to execute queries to

00:05:58,460 --> 00:06:04,280
get into the states it should be in and

00:06:02,630 --> 00:06:06,680
if you do this in production you should

00:06:04,280 --> 00:06:10,010
use migrations and I want talked already

00:06:06,680 --> 00:06:18,650
about that so don't do this in

00:06:10,010 --> 00:06:22,130
production so here we have a new script

00:06:18,650 --> 00:06:24,950
a script that will take a arguments and

00:06:22,130 --> 00:06:27,860
it will just add it to the name of the

00:06:24,950 --> 00:06:29,360
product and it will persist the entity

00:06:27,860 --> 00:06:32,240
into the entity manager and then I will

00:06:29,360 --> 00:06:33,710
flush it and the entity manager will

00:06:32,240 --> 00:06:36,320
make sure it is flush to the database

00:06:33,710 --> 00:06:39,980
and give us the ID back so if I execute

00:06:36,320 --> 00:06:44,180
it with or am i will get ID 1

00:06:39,980 --> 00:06:49,670
executed with the basic stuff extraction

00:06:44,180 --> 00:06:52,340
extraction layer I will get id2 and now

00:06:49,670 --> 00:06:55,220
we have two products in the database and

00:06:52,340 --> 00:06:57,830
if we list it we can get a repository

00:06:55,220 --> 00:07:00,320
from the entity manager and then just

00:06:57,830 --> 00:07:02,360
find all the products that were that are

00:07:00,320 --> 00:07:05,900
available and at any database and just

00:07:02,360 --> 00:07:07,220
loop over it and no big surprise we see

00:07:05,900 --> 00:07:14,030
and what we just added to the database

00:07:07,220 --> 00:07:17,030
we can find products directly on ID also

00:07:14,030 --> 00:07:18,800
pretty straightforward where we can

00:07:17,030 --> 00:07:20,840
update a product we find that the

00:07:18,800 --> 00:07:23,450
product based on an ID that was given as

00:07:20,840 --> 00:07:24,910
an argument we give it a new name and

00:07:23,450 --> 00:07:28,540
then we flush it to the database and

00:07:24,910 --> 00:07:32,150
doctrine will take care of all the

00:07:28,540 --> 00:07:35,620
checking what state was changed and what

00:07:32,150 --> 00:07:39,560
it should render to update the database

00:07:35,620 --> 00:07:44,240
so we updates the first product the PHP

00:07:39,560 --> 00:07:46,190
and that's it the user ready state

00:07:44,240 --> 00:07:50,860
forward to I just create a new user and

00:07:46,190 --> 00:07:50,860
I get the ID back and the next thing SD

00:07:52,060 --> 00:08:02,120
s debug will try to scroll because it

00:07:56,930 --> 00:08:06,080
won't be that available so for the book

00:08:02,120 --> 00:08:08,030
we have a report already an assignee ID

00:08:06,080 --> 00:08:09,950
and then a list of products that we want

00:08:08,030 --> 00:08:13,820
to link the book too

00:08:09,950 --> 00:08:17,600
so we just fetch the the user from the

00:08:13,820 --> 00:08:19,460
database we create a new book add some

00:08:17,600 --> 00:08:21,920
values to it and then loop over every

00:08:19,460 --> 00:08:27,950
product ID link it to the back and then

00:08:21,920 --> 00:08:29,960
flush it to the database again no big

00:08:27,950 --> 00:08:32,870
surprise we have a stored entity and

00:08:29,960 --> 00:08:37,220
doctrine takes care of all the linking

00:08:32,870 --> 00:08:42,020
of all the objects we can query some

00:08:37,220 --> 00:08:44,930
more using dql and dql is a variant

00:08:42,020 --> 00:08:48,920
doctrine query language which is a bit

00:08:44,930 --> 00:08:51,240
simpler or more useable and the context

00:08:48,920 --> 00:08:54,089
of doctrine

00:08:51,240 --> 00:08:58,290
to fetch data and then just loop over

00:08:54,089 --> 00:09:02,010
the data and here we see that if we

00:08:58,290 --> 00:09:05,339
fetch the if we fetch the box the

00:09:02,010 --> 00:09:07,800
reporter is also fetched and we can

00:09:05,339 --> 00:09:10,589
access it through the property so we can

00:09:07,800 --> 00:09:15,930
just go through every relation if we

00:09:10,589 --> 00:09:22,709
want so I filed one buck here which

00:09:15,930 --> 00:09:26,490
shows up no big surprise so showing a

00:09:22,709 --> 00:09:30,180
buck just the same and we have as a

00:09:26,490 --> 00:09:33,600
final note a dashboard which gets all

00:09:30,180 --> 00:09:36,570
the books that are that I am an assignee

00:09:33,600 --> 00:09:38,880
of or I reported on and this is just

00:09:36,570 --> 00:09:42,450
again it's showing me how many books are

00:09:38,880 --> 00:09:48,060
open and it displays all the perks are

00:09:42,450 --> 00:09:53,580
filed I talked about repositories and

00:09:48,060 --> 00:09:57,000
repository as a different class and the

00:09:53,580 --> 00:10:00,060
book I mark my class as an entity and

00:09:57,000 --> 00:10:02,850
the Burke repository as the repository

00:10:00,060 --> 00:10:05,160
class so every time I request the

00:10:02,850 --> 00:10:08,690
repository doctrine will just give me

00:10:05,160 --> 00:10:14,089
that and that file and in that file I

00:10:08,690 --> 00:10:18,690
have a bit of I can group commonly

00:10:14,089 --> 00:10:23,640
accessed crevice so this is just a hand

00:10:18,690 --> 00:10:29,370
a handy system tea bundle all the

00:10:23,640 --> 00:10:34,230
queries so no surprise is just exactly

00:10:29,370 --> 00:10:39,750
the same all right

00:10:34,230 --> 00:10:40,320
so we learnt something all right

00:10:39,750 --> 00:10:43,290
excellent

00:10:40,320 --> 00:10:47,339
so if you're not using doctrine this is

00:10:43,290 --> 00:10:49,709
how doctrine works you work with objects

00:10:47,339 --> 00:10:51,149
and you don't mind if you don't you

00:10:49,709 --> 00:10:57,600
don't care how it is persisted in the

00:10:51,149 --> 00:10:59,390
database so the only thing we saw with

00:10:57,600 --> 00:11:01,380
the entity manager is that we persisted

00:10:59,390 --> 00:11:05,320
entities and that we flushed entities

00:11:01,380 --> 00:11:09,660
but how this doctrine does this

00:11:05,320 --> 00:11:12,280
this is like a high-level a high-level

00:11:09,660 --> 00:11:14,590
schema of how of the internals of

00:11:12,280 --> 00:11:16,780
doctrine so on the left side we have our

00:11:14,590 --> 00:11:22,090
own application which can query our

00:11:16,780 --> 00:11:23,830
finds entities and the application we

00:11:22,090 --> 00:11:25,900
update them and then we flush them back

00:11:23,830 --> 00:11:28,030
to the entity manager we can do that

00:11:25,900 --> 00:11:31,120
using repositories or we can just ask

00:11:28,030 --> 00:11:33,580
for a specific entity to the entity

00:11:31,120 --> 00:11:36,190
manager on the other side we have a

00:11:33,580 --> 00:11:39,010
database abstraction layer that's a

00:11:36,190 --> 00:11:45,700
different component and that will take

00:11:39,010 --> 00:11:48,550
care of the different sequel variants

00:11:45,700 --> 00:11:52,390
for like sequel or another database

00:11:48,550 --> 00:11:55,270
sequel or another database and it will

00:11:52,390 --> 00:11:58,630
take care of selects and update and

00:11:55,270 --> 00:12:01,060
delete queries so the big chunk in the

00:11:58,630 --> 00:12:03,730
middle is the entity manager and an

00:12:01,060 --> 00:12:05,740
entity manager or an entity manager is

00:12:03,730 --> 00:12:07,800
the central point where our application

00:12:05,740 --> 00:12:11,470
will communicate the doctrine and

00:12:07,800 --> 00:12:16,720
request entities and give them back to

00:12:11,470 --> 00:12:20,830
dr. ent to manage them and to calculate

00:12:16,720 --> 00:12:24,070
the differences inside the entity

00:12:20,830 --> 00:12:26,050
manager we have a unit of work and a

00:12:24,070 --> 00:12:27,880
unit of work maintains a list of objects

00:12:26,050 --> 00:12:29,950
affected by a business transaction and

00:12:27,880 --> 00:12:31,390
coordinates to writing out of the

00:12:29,950 --> 00:12:34,210
changes and the resolution of

00:12:31,390 --> 00:12:36,910
concurrency problems so everything we

00:12:34,210 --> 00:12:39,100
give to the entity manager the entity

00:12:36,910 --> 00:12:42,400
manager internally stores in the unit of

00:12:39,100 --> 00:12:45,040
work and everything that is changed we

00:12:42,400 --> 00:12:47,400
ask the unit of work what should we do

00:12:45,040 --> 00:12:51,100
to persist the new state to the database

00:12:47,400 --> 00:12:54,700
so it keeps track of all the changes

00:12:51,100 --> 00:13:00,490
that have been made so doctrine knows

00:12:54,700 --> 00:13:05,350
what to write to the database the unit

00:13:00,490 --> 00:13:07,210
of work as well as also is responsible

00:13:05,350 --> 00:13:09,820
for calculating all the differences and

00:13:07,210 --> 00:13:12,100
its uses a concept called transactional

00:13:09,820 --> 00:13:17,110
right behind and transactional word

00:13:12,100 --> 00:13:19,480
behinds means it will

00:13:17,110 --> 00:13:21,280
create a very small window where it

00:13:19,480 --> 00:13:24,040
opens a database transaction and flushes

00:13:21,280 --> 00:13:27,250
all the changes it has calculated to the

00:13:24,040 --> 00:13:29,110
database so if you have a script of a

00:13:27,250 --> 00:13:31,630
web page that is loading and it's taking

00:13:29,110 --> 00:13:33,730
five seconds imagine you open the

00:13:31,630 --> 00:13:37,450
database transaction and then you

00:13:33,730 --> 00:13:39,220
fetched all your records and then you're

00:13:37,450 --> 00:13:41,620
doing some manipulations to it and then

00:13:39,220 --> 00:13:43,750
at the end of the request you commit

00:13:41,620 --> 00:13:45,130
that transaction then you have a lock on

00:13:43,750 --> 00:13:48,610
your database of five seconds and

00:13:45,130 --> 00:13:51,070
transactional right behind is you do all

00:13:48,610 --> 00:13:53,410
the logic and your entities and then you

00:13:51,070 --> 00:13:55,270
give them to the entity manager and the

00:13:53,410 --> 00:13:56,740
moment you call flush then it will

00:13:55,270 --> 00:13:58,210
calculate all the things that all the

00:13:56,740 --> 00:14:00,430
things that have to be done and it will

00:13:58,210 --> 00:14:03,010
open a database transaction flush all

00:14:00,430 --> 00:14:06,730
the update statements or the leave

00:14:03,010 --> 00:14:09,990
statements and then commit it so it's if

00:14:06,730 --> 00:14:16,030
you change your entity it's not directly

00:14:09,990 --> 00:14:18,960
persisted to the database so inside our

00:14:16,030 --> 00:14:22,870
unit of work we have a identity map and

00:14:18,960 --> 00:14:25,090
an identity map ensures that each object

00:14:22,870 --> 00:14:28,330
gets loaded only once by keeping every

00:14:25,090 --> 00:14:31,270
loaded object and a map looks up objects

00:14:28,330 --> 00:14:33,910
using the map when we foreign to them so

00:14:31,270 --> 00:14:36,790
instead of always going to the database

00:14:33,910 --> 00:14:39,130
and fetching an record where they give

00:14:36,790 --> 00:14:41,710
an ID it will first look if it is

00:14:39,130 --> 00:14:44,850
available in the identity map and it

00:14:41,710 --> 00:14:48,340
does that it does that to avoid having

00:14:44,850 --> 00:14:51,340
multiple instances of the same object so

00:14:48,340 --> 00:14:53,770
if you have a user written my name and

00:14:51,340 --> 00:14:55,660
we know it was idea one and we fetch ID

00:14:53,770 --> 00:14:59,850
one it is stored in the entity manager

00:14:55,660 --> 00:15:02,260
and the identity map and if I do a query

00:14:59,850 --> 00:15:04,810
give me all the users with first name yo

00:15:02,260 --> 00:15:07,420
Keem it will do the query but then it

00:15:04,810 --> 00:15:10,020
will see it already has that entity and

00:15:07,420 --> 00:15:14,290
the identity map and then it will just

00:15:10,020 --> 00:15:17,440
return that one to avoid having multiple

00:15:14,290 --> 00:15:21,430
instances because if you then flush the

00:15:17,440 --> 00:15:26,430
entity manager it won't know which

00:15:21,430 --> 00:15:26,430
entity is there as the correct one

00:15:27,540 --> 00:15:33,780
so entities are stored in an identity

00:15:29,550 --> 00:15:36,060
map and they have an a state we have

00:15:33,780 --> 00:15:37,890
four states and doctrine we have the new

00:15:36,060 --> 00:15:39,630
one and this is the one where I just

00:15:37,890 --> 00:15:41,690
create a new product and I haven't

00:15:39,630 --> 00:15:44,250
persisted it to the entity manager so

00:15:41,690 --> 00:15:46,170
doctoring doesn't know about it we have

00:15:44,250 --> 00:15:50,370
the managed one and that's the moment I

00:15:46,170 --> 00:15:54,060
do a persistently on the I persist the

00:15:50,370 --> 00:15:56,280
entity and the entity manager or fi

00:15:54,060 --> 00:15:58,680
fetch it from the database and it's

00:15:56,280 --> 00:16:02,400
managed to see it could be detached if

00:15:58,680 --> 00:16:03,960
he explicitly asked it to be detached or

00:16:02,400 --> 00:16:05,700
if you see realize it because it's not

00:16:03,960 --> 00:16:07,770
an object anymore and then it's to get

00:16:05,700 --> 00:16:11,970
detached or it could be flagged for

00:16:07,770 --> 00:16:14,100
removal so so as I said we use a

00:16:11,970 --> 00:16:16,350
transactional word behind so it's not

00:16:14,100 --> 00:16:18,120
better if you request the removal it's

00:16:16,350 --> 00:16:19,920
not directly removed it just flagged as

00:16:18,120 --> 00:16:22,800
removed and if you fry today they flush

00:16:19,920 --> 00:16:25,520
the entity manager it will affect it

00:16:22,800 --> 00:16:28,020
effectively remove it from the database

00:16:25,520 --> 00:16:30,960
so this is the unit of work and then

00:16:28,020 --> 00:16:34,530
here we have persisters and hydrators

00:16:30,960 --> 00:16:37,260
and a persister is just some kind of

00:16:34,530 --> 00:16:39,180
civilizing to stay cool it has all the

00:16:37,260 --> 00:16:41,940
changes and it knows how to save it to

00:16:39,180 --> 00:16:44,220
the database and the hydrator is the it

00:16:41,940 --> 00:16:47,370
takes the raw data and it hydrates it

00:16:44,220 --> 00:16:49,230
into objects and we have to keep the

00:16:47,370 --> 00:16:51,090
hydration in mind because this is about

00:16:49,230 --> 00:16:53,760
square watt skyrocketing your

00:16:51,090 --> 00:16:55,680
application hydration can take quite a

00:16:53,760 --> 00:16:57,720
while and sometimes you just don't need

00:16:55,680 --> 00:16:59,490
it so if you have raw data and you just

00:16:57,720 --> 00:17:02,400
have to display it you don't need to

00:16:59,490 --> 00:17:05,070
hydrate objects and you can have a bit

00:17:02,400 --> 00:17:08,310
of a performance boost but hydration

00:17:05,070 --> 00:17:12,720
just takes raw data puts it in an object

00:17:08,310 --> 00:17:15,930
that you can interact with another

00:17:12,720 --> 00:17:19,530
concept that is used by the entity

00:17:15,930 --> 00:17:22,470
manager are proxies and proxies are lazy

00:17:19,530 --> 00:17:24,060
loading mechanisms and it is an object

00:17:22,470 --> 00:17:26,040
that doesn't contain all of the data you

00:17:24,060 --> 00:17:29,280
need but it knows how to get it so

00:17:26,040 --> 00:17:33,060
doctrine uses this and collections so if

00:17:29,280 --> 00:17:36,540
you ask for a user and the user has a

00:17:33,060 --> 00:17:37,050
signed box if you don't use proxies or

00:17:36,540 --> 00:17:39,360
label

00:17:37,050 --> 00:17:41,250
lazy loading it will just fetch several

00:17:39,360 --> 00:17:43,620
tips which store the complete

00:17:41,250 --> 00:17:46,140
database into into memory because it's

00:17:43,620 --> 00:17:49,970
it's all related but you don't know when

00:17:46,140 --> 00:17:52,320
you need it so instead of loading the

00:17:49,970 --> 00:17:55,110
properties instead of loading the

00:17:52,320 --> 00:17:58,310
relations at once it will just create a

00:17:55,110 --> 00:18:02,700
proxy object that knows how to load the

00:17:58,310 --> 00:18:05,510
objects so the entity manager just gives

00:18:02,700 --> 00:18:10,590
you fake objects but you shouldn't care

00:18:05,510 --> 00:18:14,070
at least for now why it does this it

00:18:10,590 --> 00:18:16,590
does that so now we know the internal

00:18:14,070 --> 00:18:25,260
workings of doctrine and now we can run

00:18:16,590 --> 00:18:27,420
the Randi tutorial again so if I if I

00:18:25,260 --> 00:18:31,650
run it again with the SQL logger and

00:18:27,420 --> 00:18:33,990
this is just a flag every SQL statement

00:18:31,650 --> 00:18:37,680
that is executed will show up here on

00:18:33,990 --> 00:18:40,020
screen so again composure and stall here

00:18:37,680 --> 00:18:43,860
we drop all the tables from the sequel

00:18:40,020 --> 00:18:45,890
database here we say create our schema

00:18:43,860 --> 00:18:48,960
and you can see that it creates the

00:18:45,890 --> 00:18:49,860
products and all the necessary

00:18:48,960 --> 00:18:52,290
information

00:18:49,860 --> 00:18:54,300
it creates index indexes on order

00:18:52,290 --> 00:18:57,570
foreign keys and so doctrine does a lot

00:18:54,300 --> 00:19:00,470
for you and you don't have to you don't

00:18:57,570 --> 00:19:05,400
have to care about the internal workings

00:19:00,470 --> 00:19:07,790
so if we create a product the moment we

00:19:05,400 --> 00:19:11,210
flush it we'll just start a transaction

00:19:07,790 --> 00:19:15,450
create an insert statement and commit it

00:19:11,210 --> 00:19:17,310
the same way to double products if we

00:19:15,450 --> 00:19:21,570
list the products we'll just create a

00:19:17,310 --> 00:19:24,380
select statement to show a specific one

00:19:21,570 --> 00:19:27,270
it will again select statements and

00:19:24,380 --> 00:19:32,220
surprisingly at its aware statement to

00:19:27,270 --> 00:19:35,430
its and here we have the update so we

00:19:32,220 --> 00:19:38,640
first need to create the entity and to

00:19:35,430 --> 00:19:41,910
the memory so it does a select statement

00:19:38,640 --> 00:19:44,160
we change some some things we flush it

00:19:41,910 --> 00:19:46,140
and when we flush it we'll see that only

00:19:44,160 --> 00:19:47,910
the name has changed so what we'll open

00:19:46,140 --> 00:19:49,770
it transaction this is the transactional

00:19:47,910 --> 00:19:54,290
right behind will open a transaction and

00:19:49,770 --> 00:19:54,290
update all the data in the database

00:19:54,540 --> 00:20:01,860
same for user in the transaction and

00:19:57,380 --> 00:20:04,710
here is where it gets interesting so we

00:20:01,860 --> 00:20:08,850
have the create book and as you can see

00:20:04,710 --> 00:20:12,120
here we will find a user with ID 1 which

00:20:08,850 --> 00:20:14,580
is my ID and it will find a the same

00:20:12,120 --> 00:20:18,330
user also a user 1 but it will use that

00:20:14,580 --> 00:20:21,210
as the engineer and then we will create

00:20:18,330 --> 00:20:23,430
the book itself then loop over every

00:20:21,210 --> 00:20:28,200
product and find the product link it's

00:20:23,430 --> 00:20:30,900
2d book and then flush it and if we

00:20:28,200 --> 00:20:33,420
execute the script you will see that it

00:20:30,900 --> 00:20:37,200
only performs one krabi to the database

00:20:33,420 --> 00:20:39,630
so we request it to users with the same

00:20:37,200 --> 00:20:41,220
ID so it will skip the database query

00:20:39,630 --> 00:20:46,260
and we'll just fetch it from the

00:20:41,220 --> 00:20:49,440
identity map so we have two users with

00:20:46,260 --> 00:20:52,230
one query we have the products and if we

00:20:49,440 --> 00:20:54,390
then save it I'll flush it to the

00:20:52,230 --> 00:20:58,290
database doctoring knows it has to

00:20:54,390 --> 00:21:00,090
create a new books record and that we

00:20:58,290 --> 00:21:05,910
have a many-to-many relationship that it

00:21:00,090 --> 00:21:10,970
has to create statements for that too so

00:21:05,910 --> 00:21:14,280
here we have the dql and that is not

00:21:10,970 --> 00:21:16,740
recognized by the by the database engine

00:21:14,280 --> 00:21:22,560
so it has to create seek SQL for death

00:21:16,740 --> 00:21:26,370
and then here we have a property that we

00:21:22,560 --> 00:21:28,560
can that we can loop over all the

00:21:26,370 --> 00:21:32,490
products and here was where the Alisa

00:21:28,560 --> 00:21:34,500
loading will be will kicking will kick

00:21:32,490 --> 00:21:37,770
in so here we can see that we have a

00:21:34,500 --> 00:21:41,900
query that's was generated it has

00:21:37,770 --> 00:21:44,730
generated a sequel query and this is an

00:21:41,900 --> 00:21:47,160
many to one relationship so we can just

00:21:44,730 --> 00:21:49,800
enjoin the engineer and the reporter and

00:21:47,160 --> 00:21:53,070
it will just load it in one and one go

00:21:49,800 --> 00:21:55,680
and that will loop over the products and

00:21:53,070 --> 00:21:58,170
the products as a proxy object so the

00:21:55,680 --> 00:22:00,840
moment I say get products it will will

00:21:58,170 --> 00:22:04,880
execute the decree and get it from the

00:22:00,840 --> 00:22:07,220
database so if I load the

00:22:04,880 --> 00:22:10,640
and back from a database and don't touch

00:22:07,220 --> 00:22:13,100
the get products methods it won't load

00:22:10,640 --> 00:22:14,590
all the all the objects so this is

00:22:13,100 --> 00:22:16,880
something you have to keep in mind to

00:22:14,590 --> 00:22:21,440
make sure you don't load the complete

00:22:16,880 --> 00:22:25,660
database into memory every time so show

00:22:21,440 --> 00:22:28,760
back here we see the proxy object again

00:22:25,660 --> 00:22:32,090
we get the bug and then the moment we

00:22:28,760 --> 00:22:33,980
had we hit get get engineer it will load

00:22:32,090 --> 00:22:42,050
later load the engineer and formation

00:22:33,980 --> 00:22:46,070
from the database here we have the D

00:22:42,050 --> 00:22:50,620
equal to sequel example and the

00:22:46,070 --> 00:22:54,440
repository is just the same as before so

00:22:50,620 --> 00:22:59,270
we saw all the concepts that we just

00:22:54,440 --> 00:23:01,520
that we just talked about and we can

00:22:59,270 --> 00:23:06,890
start using doctrine a little bit

00:23:01,520 --> 00:23:10,450
smarter yeah to make sure we don't abuse

00:23:06,890 --> 00:23:13,310
it or it's it slows this down

00:23:10,450 --> 00:23:14,990
so another thing where we can get some

00:23:13,310 --> 00:23:18,830
performance gains as understanding how

00:23:14,990 --> 00:23:20,180
the tracking of changes works every time

00:23:18,830 --> 00:23:23,960
you flush it we flush something to the

00:23:20,180 --> 00:23:27,500
database we have to we have to calculate

00:23:23,960 --> 00:23:29,360
in a way how the how the changes what

00:23:27,500 --> 00:23:31,730
changes were there were and how we

00:23:29,360 --> 00:23:34,190
should persist them to the database so I

00:23:31,730 --> 00:23:35,990
quickly go to the some examples if we

00:23:34,190 --> 00:23:38,240
read it we have an object that's in the

00:23:35,990 --> 00:23:40,670
new state we persist it it's Ana managed

00:23:38,240 --> 00:23:42,260
state we flush the entity manager and it

00:23:40,670 --> 00:23:43,880
will create it will calculate all the

00:23:42,260 --> 00:23:46,280
changes that we'll see it with a new

00:23:43,880 --> 00:23:49,340
object and it will create entered

00:23:46,280 --> 00:23:51,230
statements and the transaction thing if

00:23:49,340 --> 00:23:54,320
we get the object we will question

00:23:51,230 --> 00:23:57,260
object we first look at the identity map

00:23:54,320 --> 00:24:02,200
we do a database query we hydrate the

00:23:57,260 --> 00:24:06,770
objects we save it into the identity map

00:24:02,200 --> 00:24:10,280
so the next requests well cut it from

00:24:06,770 --> 00:24:13,040
there if we updated we just do dick

00:24:10,280 --> 00:24:15,020
before stick edit then we change the

00:24:13,040 --> 00:24:17,210
property and we persist it and the

00:24:15,020 --> 00:24:18,230
entity manager but since it is already

00:24:17,210 --> 00:24:20,270
managed

00:24:18,230 --> 00:24:21,770
won't do anything so we just let the

00:24:20,270 --> 00:24:23,630
entitymanager know that we want to

00:24:21,770 --> 00:24:25,970
persist it and that we flush the

00:24:23,630 --> 00:24:27,890
database again it will see it's an

00:24:25,970 --> 00:24:29,750
already existing entity I will create

00:24:27,890 --> 00:24:34,090
update statements for it and it will

00:24:29,750 --> 00:24:37,520
perform a transaction when we delete it

00:24:34,090 --> 00:24:39,530
we ask for removal and only if we flush

00:24:37,520 --> 00:24:43,550
it will actually actually generate

00:24:39,530 --> 00:24:45,860
deletes sequel to delete the object so

00:24:43,550 --> 00:24:52,910
you see that we alway always have this

00:24:45,860 --> 00:24:56,720
calculates changes step and the way it

00:24:52,910 --> 00:24:59,720
is done is by using a specific tracking

00:24:56,720 --> 00:25:02,360
policy doctrine has three different

00:24:59,720 --> 00:25:05,210
tracking policies the default one has

00:25:02,360 --> 00:25:08,390
deferred implicit and this is just the

00:25:05,210 --> 00:25:10,510
default one that will do a property by

00:25:08,390 --> 00:25:14,810
property comparison of all the

00:25:10,510 --> 00:25:17,060
properties and the objects and it will

00:25:14,810 --> 00:25:18,860
do that for everything that is reachable

00:25:17,060 --> 00:25:21,050
from within the identity map

00:25:18,860 --> 00:25:23,450
so everything that is loaded and all the

00:25:21,050 --> 00:25:25,150
relations it has it will just say flush

00:25:23,450 --> 00:25:29,120
to the data flush it to the database and

00:25:25,150 --> 00:25:32,600
it has a copy of all the all the

00:25:29,120 --> 00:25:34,400
entities that are actively tracked with

00:25:32,600 --> 00:25:38,180
all the changes in it and it has a copy

00:25:34,400 --> 00:25:40,280
of that with all the entities that have

00:25:38,180 --> 00:25:42,680
the state of the database so we'll just

00:25:40,280 --> 00:25:44,780
every entity it has it will do a

00:25:42,680 --> 00:25:46,460
property by property comparison and then

00:25:44,780 --> 00:25:49,220
see this one has changed we have to

00:25:46,460 --> 00:25:51,020
update that this one is changed so this

00:25:49,220 --> 00:25:53,000
is the default one but as you can

00:25:51,020 --> 00:25:54,640
imagine if it does on all the objects it

00:25:53,000 --> 00:25:59,420
is the slowest one

00:25:54,640 --> 00:26:02,660
so the second policy is to use the

00:25:59,420 --> 00:26:05,180
default explicit and this is exactly the

00:26:02,660 --> 00:26:08,450
same it will use a property by property

00:26:05,180 --> 00:26:11,810
comparison but the own it will only do

00:26:08,450 --> 00:26:15,080
it on entities that are explicitly

00:26:11,810 --> 00:26:18,830
persisted to the entity manager so if

00:26:15,080 --> 00:26:22,450
there are loaded via a proxy object or

00:26:18,830 --> 00:26:27,880
something like that it won't trigger the

00:26:22,450 --> 00:26:30,980
comparison so here you can boost the

00:26:27,880 --> 00:26:31,700
boosted performance a bit by avoiding

00:26:30,980 --> 00:26:34,940
docks

00:26:31,700 --> 00:26:40,370
- check every every entity that it has

00:26:34,940 --> 00:26:42,830
under under its identity map and it's as

00:26:40,370 --> 00:26:46,120
simple as just adding a new annotation

00:26:42,830 --> 00:26:50,630
which said deferred explicit and it

00:26:46,120 --> 00:26:53,030
works in a different way the third one

00:26:50,630 --> 00:26:56,620
is the most performant one and it is

00:26:53,030 --> 00:27:00,710
notify and it's the most performant one

00:26:56,620 --> 00:27:06,080
because the entity itself is responsible

00:27:00,710 --> 00:27:15,980
for publishing events when something has

00:27:06,080 --> 00:27:18,110
changed this kinds of it's a bit crazy

00:27:15,980 --> 00:27:20,360
if you are using something like doctrine

00:27:18,110 --> 00:27:23,690
to do all the calculations for you and

00:27:20,360 --> 00:27:26,960
then you start using notify tracking

00:27:23,690 --> 00:27:29,660
policy because then you just are

00:27:26,960 --> 00:27:32,510
responsible yourself for saying to

00:27:29,660 --> 00:27:33,980
doctrine this field has changed so it's

00:27:32,510 --> 00:27:36,620
the most performance one because

00:27:33,980 --> 00:27:38,540
doctrine doesn't have to do thing so we

00:27:36,620 --> 00:27:40,520
do this by implementing the event

00:27:38,540 --> 00:27:44,450
listener the event Allah and the entered

00:27:40,520 --> 00:27:47,720
phase and the other phase just gets a

00:27:44,450 --> 00:27:54,020
list of off builds a list of listeners

00:27:47,720 --> 00:27:58,880
and then in your in your entity you have

00:27:54,020 --> 00:28:01,970
to manually notify all the listeners

00:27:58,880 --> 00:28:03,410
that that specific field has changed so

00:28:01,970 --> 00:28:05,930
if you want to go for maximum

00:28:03,410 --> 00:28:10,940
performance do this but then your code

00:28:05,930 --> 00:28:16,840
base will be very polluted to it yeah

00:28:10,940 --> 00:28:21,890
event emissions so further improvements

00:28:16,840 --> 00:28:24,230
we can use a different result format and

00:28:21,890 --> 00:28:27,830
this is the hydration step I mentioned

00:28:24,230 --> 00:28:30,410
before that we are skipping this is

00:28:27,830 --> 00:28:32,780
usually done for read-only data because

00:28:30,410 --> 00:28:35,930
you don't get objects back that you can

00:28:32,780 --> 00:28:38,510
change properties on and then flush back

00:28:35,930 --> 00:28:41,020
to the database so it's more like if you

00:28:38,510 --> 00:28:44,890
have big tables to show you can use a

00:28:41,020 --> 00:28:49,360
every result or something and it's

00:28:44,890 --> 00:28:52,960
only scalar values but it's also

00:28:49,360 --> 00:28:58,690
possible of or it will also give you a

00:28:52,960 --> 00:29:00,610
nested Eric graph so if we have the

00:28:58,690 --> 00:29:03,250
query I showed you before where we do a

00:29:00,610 --> 00:29:07,540
joint of a reporter and some products

00:29:03,250 --> 00:29:12,840
and here we ask for the re result it

00:29:07,540 --> 00:29:15,130
will just generate a nested array with

00:29:12,840 --> 00:29:18,210
with all the data and here you can see

00:29:15,130 --> 00:29:22,330
it is nested because we have all the

00:29:18,210 --> 00:29:27,130
data from the user entity that is added

00:29:22,330 --> 00:29:30,880
to the reporter key so if you just

00:29:27,130 --> 00:29:32,919
fetching data to display on a page don't

00:29:30,880 --> 00:29:42,700
bother with the hydration step just use

00:29:32,919 --> 00:29:44,950
the plain array format if you have for

00:29:42,700 --> 00:29:49,480
instance a logging entity or a lock

00:29:44,950 --> 00:29:51,370
entity you don't want the entity manager

00:29:49,480 --> 00:29:53,260
to calculate all the changes on that

00:29:51,370 --> 00:29:56,590
lock entity you just want to read them

00:29:53,260 --> 00:29:59,679
out and display them so that for that

00:29:56,590 --> 00:30:02,830
you can use read-only entities and it's

00:29:59,679 --> 00:30:05,410
just the flag and the entity where we

00:30:02,830 --> 00:30:07,840
say to doctrine fetch the data from the

00:30:05,410 --> 00:30:10,570
database but if we hit flush just skip

00:30:07,840 --> 00:30:12,460
all the classes all the product classes

00:30:10,570 --> 00:30:16,120
because we don't want to store them back

00:30:12,460 --> 00:30:24,419
in the database I have a quick demo for

00:30:16,120 --> 00:30:24,419
that greed only

00:30:36,140 --> 00:30:47,180
so this is a here we fetch a book and

00:30:44,990 --> 00:30:50,930
the book is not read only so this is the

00:30:47,180 --> 00:30:53,710
normal way of working so we have a an

00:30:50,930 --> 00:30:58,010
existing book and we create a new book

00:30:53,710 --> 00:31:01,310
we persist the new book and change the

00:30:58,010 --> 00:31:04,670
book we already had and if we flush it

00:31:01,310 --> 00:31:06,620
to the database we want to see multiple

00:31:04,670 --> 00:31:08,390
updates or an enteric statement and an

00:31:06,620 --> 00:31:11,510
update statement and if we do it again

00:31:08,390 --> 00:31:14,300
we want to see a update statement so no

00:31:11,510 --> 00:31:17,510
surprise we have a select statement for

00:31:14,300 --> 00:31:19,490
the one we already have then we changed

00:31:17,510 --> 00:31:20,960
the probe we create a new one and we

00:31:19,490 --> 00:31:22,640
change the property of the first one so

00:31:20,960 --> 00:31:26,570
we have a insert statement and an update

00:31:22,640 --> 00:31:28,820
statement and then we change the new

00:31:26,570 --> 00:31:32,990
book again and we have a update

00:31:28,820 --> 00:31:34,790
statement if we have ever at the read

00:31:32,990 --> 00:31:37,340
only flag to the entity to the product

00:31:34,790 --> 00:31:41,450
entity and we do exactly the same but

00:31:37,340 --> 00:31:45,920
with products instead of instead of

00:31:41,450 --> 00:31:48,380
books we will see find statements and

00:31:45,920 --> 00:31:50,630
insert statements but we won't see any

00:31:48,380 --> 00:31:53,360
update statements so here we can see

00:31:50,630 --> 00:31:55,700
that we have a select statement and the

00:31:53,360 --> 00:31:57,230
new one gets persisted but the changing

00:31:55,700 --> 00:31:59,540
of product one is just completely

00:31:57,230 --> 00:32:01,670
ignored and if we change the new product

00:31:59,540 --> 00:32:07,010
its again completely ignored because we

00:32:01,670 --> 00:32:11,360
said it was read-only so if you have if

00:32:07,010 --> 00:32:13,490
you have entities that are only for only

00:32:11,360 --> 00:32:14,720
for displaying things and you don't want

00:32:13,490 --> 00:32:17,060
to persist them back to the database

00:32:14,720 --> 00:32:19,180
just flag them as read-only and you're

00:32:17,060 --> 00:32:21,620
good to go

00:32:19,180 --> 00:32:23,570
another thing you can use is using

00:32:21,620 --> 00:32:26,840
external easy collections so we have the

00:32:23,570 --> 00:32:30,560
proxy objects and these are the default

00:32:26,840 --> 00:32:33,530
way of loading collections so this is

00:32:30,560 --> 00:32:36,770
the lazy loaded one where we inject the

00:32:33,530 --> 00:32:38,780
proxy objects and the moment we use that

00:32:36,770 --> 00:32:42,850
method that will fetch it from the

00:32:38,780 --> 00:32:46,340
database the opposite one is the eager

00:32:42,850 --> 00:32:46,890
loading and the ego loading is just a

00:32:46,340 --> 00:32:51,060
wolf or

00:32:46,890 --> 00:32:54,120
a inner joint every time we load a

00:32:51,060 --> 00:32:56,490
product for instance if we say we want

00:32:54,120 --> 00:32:57,720
the bug and we want to equal out all the

00:32:56,490 --> 00:32:59,820
products associated with it

00:32:57,720 --> 00:33:02,430
it will just use a big inner joint and

00:32:59,820 --> 00:33:06,420
always loads all the products instead of

00:33:02,430 --> 00:33:09,510
lazy loading it from the database extra

00:33:06,420 --> 00:33:14,100
lazy loading is the collections that are

00:33:09,510 --> 00:33:17,130
having an another trick and instead of

00:33:14,100 --> 00:33:23,370
always loading always lazy loading the

00:33:17,130 --> 00:33:27,060
collection when you hit the property or

00:33:23,370 --> 00:33:29,370
if you hit the methods if you do for

00:33:27,060 --> 00:33:31,140
instance accounts on the collection will

00:33:29,370 --> 00:33:34,050
see this account and it won't first

00:33:31,140 --> 00:33:36,780
loads all the items from the database

00:33:34,050 --> 00:33:38,640
and then do a PHP count on top on on the

00:33:36,780 --> 00:33:40,680
collection and return that I will see

00:33:38,640 --> 00:33:43,410
that it is count and we'll do a

00:33:40,680 --> 00:33:47,540
optimized select count from the database

00:33:43,410 --> 00:33:52,020
and give that back it does the same for

00:33:47,540 --> 00:33:54,000
if you say does this object does this

00:33:52,020 --> 00:33:55,850
collection contains an entity then it

00:33:54,000 --> 00:34:01,200
will tries to figure out if it can do a

00:33:55,850 --> 00:34:02,870
difference different yeah a different

00:34:01,200 --> 00:34:07,470
query instead of like loading everything

00:34:02,870 --> 00:34:11,220
and this is done by if you by adding a

00:34:07,470 --> 00:34:13,590
new property TD annotation where you say

00:34:11,220 --> 00:34:20,340
how you want it how you want to fetch to

00:34:13,590 --> 00:34:23,429
work so this is a everything where I can

00:34:20,340 --> 00:34:26,340
tell you about T internals and only by

00:34:23,429 --> 00:34:27,990
using the internal only by using your

00:34:26,340 --> 00:34:33,929
knowledge of the internals of doctrine

00:34:27,990 --> 00:34:36,450
you can avoid a lot of things that make

00:34:33,929 --> 00:34:40,230
over M's kind of hated by some people

00:34:36,450 --> 00:34:42,060
because they just don't understand how

00:34:40,230 --> 00:34:44,429
the internals work and they are abusing

00:34:42,060 --> 00:34:47,159
the entity manager and they saying this

00:34:44,429 --> 00:34:52,440
is very slow it's loading too much from

00:34:47,159 --> 00:34:55,110
the database so you have two or M's

00:34:52,440 --> 00:34:57,149
counts solve every problem so you have

00:34:55,110 --> 00:34:59,550
to know wherever they are good at and

00:34:57,149 --> 00:35:04,410
where they're not good at so

00:34:59,550 --> 00:35:06,930
I hope you have a better idea of when to

00:35:04,410 --> 00:35:10,140
use the ORM and how to optimize some

00:35:06,930 --> 00:35:12,110
constructs but if that's not enough you

00:35:10,140 --> 00:35:16,500
can use caching and doctrine

00:35:12,110 --> 00:35:18,450
so first of all we have a component call

00:35:16,500 --> 00:35:22,160
to dr. Ian cache and this has nothing to

00:35:18,450 --> 00:35:26,640
do with the Wharram but this is just a

00:35:22,160 --> 00:35:30,450
interface which defines that we want to

00:35:26,640 --> 00:35:32,850
fetch data where the cache ID we want to

00:35:30,450 --> 00:35:35,760
see if it is already cached we want to

00:35:32,850 --> 00:35:40,410
save some data with a specific ID and we

00:35:35,760 --> 00:35:43,530
want to delete the cache ID so it has a

00:35:40,410 --> 00:35:44,850
lot of drivers you have a memcache you

00:35:43,530 --> 00:35:48,630
have database drivers you have file

00:35:44,850 --> 00:35:51,270
caching and it is used in a not only

00:35:48,630 --> 00:35:55,830
doctrine but in a difference in other

00:35:51,270 --> 00:35:58,710
projects too so this is the component

00:35:55,830 --> 00:36:04,740
and doctrine uses this component and

00:35:58,710 --> 00:36:09,870
doctrine over m so the ORM can benefit

00:36:04,740 --> 00:36:18,510
from the caching too and we have

00:36:09,870 --> 00:36:22,880
different caches in the Orem so the

00:36:18,510 --> 00:36:26,520
first cache as the metadata cache and

00:36:22,880 --> 00:36:28,500
the metadata Rd and our example the

00:36:26,520 --> 00:36:30,720
annotations where we say to doctrine

00:36:28,500 --> 00:36:34,020
this property maps to this field and a

00:36:30,720 --> 00:36:37,230
database and you can do it they can do

00:36:34,020 --> 00:36:40,800
this by annotations ml or XML and three

00:36:37,230 --> 00:36:42,480
points oh you won't be use you can't use

00:36:40,800 --> 00:36:50,700
Yemen anymore because it will be removed

00:36:42,480 --> 00:36:54,150
so you have XML or annotations but all

00:36:50,700 --> 00:36:58,130
the parsing is something you just have

00:36:54,150 --> 00:37:01,290
to cache because it's useless for every

00:36:58,130 --> 00:37:03,870
request you have on your website to do

00:37:01,290 --> 00:37:07,050
all the logic of okay this field is

00:37:03,870 --> 00:37:09,420
mapped this data to this property so

00:37:07,050 --> 00:37:12,480
this is a cache you have to have on by

00:37:09,420 --> 00:37:14,310
default if you don't use metadata cache

00:37:12,480 --> 00:37:17,220
you just don't care about performance

00:37:14,310 --> 00:37:19,460
and you can leave in the room because

00:37:17,220 --> 00:37:23,670
you don't care you don't care about

00:37:19,460 --> 00:37:26,610
speeding up your website so metadata

00:37:23,670 --> 00:37:29,190
cache is just a flag or a configuration

00:37:26,610 --> 00:37:30,960
injection where you say this is the kind

00:37:29,190 --> 00:37:37,320
of car driver I want to use for the

00:37:30,960 --> 00:37:39,510
annotations or the XML and it will parse

00:37:37,320 --> 00:37:41,340
all the mapping information once put it

00:37:39,510 --> 00:37:44,670
in a cache and then it won't have to be

00:37:41,340 --> 00:37:48,090
loaded again the next one is query cache

00:37:44,670 --> 00:37:51,060
and query cache is not the same as

00:37:48,090 --> 00:37:53,970
quarry caching and my sequel but we have

00:37:51,060 --> 00:37:56,970
a dialect the doctrine query language

00:37:53,970 --> 00:37:58,950
and that has to be translated to an

00:37:56,970 --> 00:38:03,840
sequel statement that the database

00:37:58,950 --> 00:38:07,320
engine can understand and again if you

00:38:03,840 --> 00:38:09,480
do this on every on every page request

00:38:07,320 --> 00:38:12,120
you don't care about performance so

00:38:09,480 --> 00:38:14,430
those two are the ones you have to

00:38:12,120 --> 00:38:19,050
enable by default and you will see a

00:38:14,430 --> 00:38:23,190
spike in performance yeah with two

00:38:19,050 --> 00:38:27,140
simple steps the third option is result

00:38:23,190 --> 00:38:32,060
cache and the result cache stores your

00:38:27,140 --> 00:38:35,760
sequel query result and to a cache that

00:38:32,060 --> 00:38:41,220
doctrine can read again so you can skip

00:38:35,760 --> 00:38:44,450
the round-trip to the database it stores

00:38:41,220 --> 00:38:49,110
the raw data so you still have to

00:38:44,450 --> 00:38:52,110
hydrate all the objects but that's not

00:38:49,110 --> 00:38:54,360
really an issue if you can remove the

00:38:52,110 --> 00:38:56,670
network latency and the round flow to

00:38:54,360 --> 00:39:03,000
the database you will see a big

00:38:56,670 --> 00:39:04,950
performance boost already and a thing to

00:39:03,000 --> 00:39:08,550
keep in mind is that if you did joints

00:39:04,950 --> 00:39:10,170
like I said before if you load a book

00:39:08,550 --> 00:39:13,650
you want to do a join with all the

00:39:10,170 --> 00:39:16,470
products it will have a very big table

00:39:13,650 --> 00:39:18,390
where all the products are listed on a

00:39:16,470 --> 00:39:20,220
line but the book information will be

00:39:18,390 --> 00:39:22,650
repeated every time so this is how a

00:39:20,220 --> 00:39:24,180
joint work and that information will be

00:39:22,650 --> 00:39:29,640
stored as is so if you have

00:39:24,180 --> 00:39:35,160
very big join result sets your cash will

00:39:29,640 --> 00:39:38,579
grow but stories keep service but this

00:39:35,160 --> 00:39:42,349
is something you have to keep in mind so

00:39:38,579 --> 00:39:47,339
you have still have to hydrate objects

00:39:42,349 --> 00:39:50,910
and something you can do to go even

00:39:47,339 --> 00:39:55,760
further is custom caching and custom

00:39:50,910 --> 00:39:59,630
caching is caching the hydrated result

00:39:55,760 --> 00:40:03,000
instead of thank you instead of always

00:39:59,630 --> 00:40:06,359
going to the to the hydrating loop again

00:40:03,000 --> 00:40:09,720
so the hydrated result can be easily

00:40:06,359 --> 00:40:13,049
done by building a decorator of on the

00:40:09,720 --> 00:40:15,480
repository where instead of going to the

00:40:13,049 --> 00:40:17,369
database of fetching all the data from

00:40:15,480 --> 00:40:21,000
the database and hydrating it you can

00:40:17,369 --> 00:40:23,579
store it hydrated in the cash and just

00:40:21,000 --> 00:40:26,430
bypass the report story altogether but

00:40:23,579 --> 00:40:29,160
it's generally a bad idea

00:40:26,430 --> 00:40:31,049
just look at the picture and it's

00:40:29,160 --> 00:40:33,510
generally a bad idea because you are

00:40:31,049 --> 00:40:35,160
civilizing entities and entities have

00:40:33,510 --> 00:40:41,250
collections so you are civilizing

00:40:35,160 --> 00:40:43,260
collections and unsee realising objects

00:40:41,250 --> 00:40:45,450
and big collections and lazy loaded

00:40:43,260 --> 00:40:50,490
collections is just something that will

00:40:45,450 --> 00:40:53,609
blow up in your face so so like I said

00:40:50,490 --> 00:40:56,069
the moment you see realize a object will

00:40:53,609 --> 00:41:00,990
get detached and the object manager

00:40:56,069 --> 00:41:04,589
won't know it exists so this is a pull

00:41:00,990 --> 00:41:07,500
request form from 2011 result casting

00:41:04,589 --> 00:41:11,880
used to cache the highest rated result

00:41:07,500 --> 00:41:14,609
but they revert it at for the reasons I

00:41:11,880 --> 00:41:19,349
just mentioned it's really a pain in the

00:41:14,609 --> 00:41:21,930
ass to figure out what was already

00:41:19,349 --> 00:41:24,180
hydrated and registering it to the

00:41:21,930 --> 00:41:26,549
object manager and saying you already

00:41:24,180 --> 00:41:28,440
know this object just here is a cached

00:41:26,549 --> 00:41:32,369
version so they just skipped it

00:41:28,440 --> 00:41:35,819
altogether and hydrate every time but

00:41:32,369 --> 00:41:38,040
PHP 7 will solve a lot of those issues

00:41:35,819 --> 00:41:41,880
too so it's not really an issue on you

00:41:38,040 --> 00:41:45,660
or so that are the basic castings that

00:41:41,880 --> 00:41:48,960
are available in doctrine and there's a

00:41:45,660 --> 00:41:52,440
new thing since 2.5 and that is the

00:41:48,960 --> 00:41:56,010
second level cashing and second level

00:41:52,440 --> 00:41:59,820
cashing s surprisingly just like second

00:41:56,010 --> 00:42:05,360
level cashing and computer so if we do

00:41:59,820 --> 00:42:08,940
the comparison with doctrine we have the

00:42:05,360 --> 00:42:10,860
CPU is the unit of work and it has a

00:42:08,940 --> 00:42:13,830
level 1 cache and that is the identity

00:42:10,860 --> 00:42:20,460
map then we have the entity manager that

00:42:13,830 --> 00:42:22,050
stores non hydrated data close by and if

00:42:20,460 --> 00:42:24,090
it's not in the second level cache it

00:42:22,050 --> 00:42:31,200
will just go for the memory in our case

00:42:24,090 --> 00:42:35,580
the database so this is small but fast

00:42:31,200 --> 00:42:40,500
this is bigger but less for I know you

00:42:35,580 --> 00:42:42,510
know why he say the the the speed goes

00:42:40,500 --> 00:42:45,720
down the further you go so if you have a

00:42:42,510 --> 00:42:49,890
second level caching you can speed up

00:42:45,720 --> 00:42:54,900
your application a bit more so it

00:42:49,890 --> 00:42:57,210
doesn't cache entity instances at if you

00:42:54,900 --> 00:43:02,280
enable second level cache you only store

00:42:57,210 --> 00:43:05,610
identifiers and the values so it doesn't

00:43:02,280 --> 00:43:09,560
store hydrate hydrate identities

00:43:05,610 --> 00:43:13,350
you just have plain data it still has to

00:43:09,560 --> 00:43:16,440
hydrate and an entity and it is best

00:43:13,350 --> 00:43:20,010
suited for a read-only data but you can

00:43:16,440 --> 00:43:23,430
use it also in normal like you would

00:43:20,010 --> 00:43:26,310
just persist things to the database I

00:43:23,430 --> 00:43:29,370
will show in a moment so we have three

00:43:26,310 --> 00:43:32,040
types we have the entity data the entity

00:43:29,370 --> 00:43:35,690
data is stored with the identifier and

00:43:32,040 --> 00:43:38,430
then a plain and the raw data as values

00:43:35,690 --> 00:43:40,920
we have collection data and it will

00:43:38,430 --> 00:43:45,120
store the owner ID and then a list of

00:43:40,920 --> 00:43:48,830
ID's of the referenced entities in that

00:43:45,120 --> 00:43:51,720
collection so no data here is stored of

00:43:48,830 --> 00:43:54,750
no values are stored here

00:43:51,720 --> 00:43:58,020
we have query data and query query

00:43:54,750 --> 00:44:00,180
second level caching uses the generated

00:43:58,020 --> 00:44:02,160
query attaches that and it will just

00:44:00,180 --> 00:44:05,490
save a list of the IDS that match to

00:44:02,160 --> 00:44:09,180
that result and it will keep the list of

00:44:05,490 --> 00:44:11,820
ID's in permanent cache storage so if

00:44:09,180 --> 00:44:16,530
you use caching on the collection of the

00:44:11,820 --> 00:44:21,540
query you must you must use entity data

00:44:16,530 --> 00:44:24,150
caching or you won't be able to find the

00:44:21,540 --> 00:44:26,849
data so entity caching as

00:44:24,150 --> 00:44:28,500
straightforward you just add a cache

00:44:26,849 --> 00:44:31,020
annotation and you have entered the data

00:44:28,500 --> 00:44:34,140
caching the same for Association caching

00:44:31,020 --> 00:44:39,030
so it is pretty pretty simple to enable

00:44:34,140 --> 00:44:41,490
it and to have the benefits from it the

00:44:39,030 --> 00:44:45,090
caching has a concept of regions and

00:44:41,490 --> 00:44:50,160
regions are used to invalidate caches

00:44:45,090 --> 00:44:52,619
and to have different TTL on caching so

00:44:50,160 --> 00:44:55,500
every type has its own region every

00:44:52,619 --> 00:44:59,400
entity collection has its own region so

00:44:55,500 --> 00:45:02,310
this is used to label of our group bunch

00:44:59,400 --> 00:45:07,500
of cache entries that you can delete

00:45:02,310 --> 00:45:12,140
safely you have some modes you can use

00:45:07,500 --> 00:45:16,109
read-only data which is the safest one

00:45:12,140 --> 00:45:19,859
because if you update things I will just

00:45:16,109 --> 00:45:22,380
skip the will just skip the caching you

00:45:19,859 --> 00:45:26,849
have non-strict readwrite and this is

00:45:22,380 --> 00:45:31,500
used this is a rewrite mode without

00:45:26,849 --> 00:45:34,740
locking so it will just do best effort

00:45:31,500 --> 00:45:37,050
of writing your off or updating your

00:45:34,740 --> 00:45:39,540
data and then you have the read/write

00:45:37,050 --> 00:45:43,200
and that will use a lock on your caching

00:45:39,540 --> 00:45:50,520
layer but your caching driver must

00:45:43,200 --> 00:45:52,410
supports the D locking so we saw the

00:45:50,520 --> 00:45:55,589
entity and the collection cache and the

00:45:52,410 --> 00:45:59,310
query cache we just say we create a

00:45:55,589 --> 00:46:01,950
query this is what we will what we will

00:45:59,310 --> 00:46:04,950
query and we want the entity we want to

00:46:01,950 --> 00:46:13,320
return to be cached

00:46:04,950 --> 00:46:17,760
I will skip the different notes so the

00:46:13,320 --> 00:46:20,520
query cache ignores the second level

00:46:17,760 --> 00:46:22,890
cache just as ignored by deleting and

00:46:20,520 --> 00:46:25,260
abit queries because it just bypasses

00:46:22,890 --> 00:46:29,210
that because you can't cash delete or a

00:46:25,260 --> 00:46:33,570
bit queries so they are directly

00:46:29,210 --> 00:46:37,230
injected in the database but the problem

00:46:33,570 --> 00:46:41,460
there is it won't it won't update the

00:46:37,230 --> 00:46:46,339
cache so you have to do that kind of

00:46:41,460 --> 00:46:49,800
manually but you can do that with some

00:46:46,339 --> 00:46:52,440
methods on the entity manager so here we

00:46:49,800 --> 00:46:54,660
have a hint that we say we just want if

00:46:52,440 --> 00:46:57,060
we update if we perform this query we

00:46:54,660 --> 00:47:00,510
just want to evacuate the complete cache

00:46:57,060 --> 00:47:02,820
so everything will be deleted the safest

00:47:00,510 --> 00:47:05,730
option but you won't have any cash

00:47:02,820 --> 00:47:08,070
anymore if we know we are we are

00:47:05,730 --> 00:47:10,740
updating a country we can say we want to

00:47:08,070 --> 00:47:13,589
update the entity region of this entity

00:47:10,740 --> 00:47:16,680
so all the other caches are intact but

00:47:13,589 --> 00:47:20,430
we want to update only the we want to

00:47:16,680 --> 00:47:23,400
affect only the entity region and to be

00:47:20,430 --> 00:47:26,970
more specific if you're updating is a

00:47:23,400 --> 00:47:30,900
specific specific entity you can evict

00:47:26,970 --> 00:47:34,230
that entity all by itself there's also a

00:47:30,900 --> 00:47:36,500
lot of logic and the background and you

00:47:34,230 --> 00:47:40,319
also have a concept called time-stamped

00:47:36,500 --> 00:47:43,290
regions and this is used by the

00:47:40,319 --> 00:47:48,780
persisters and the background so if we

00:47:43,290 --> 00:47:51,000
fetch everything it will start it will

00:47:48,780 --> 00:47:53,720
store the query that was used here and

00:47:51,000 --> 00:47:57,450
it will store every entry and in

00:47:53,720 --> 00:48:00,500
time-stamped region so the if we asked

00:47:57,450 --> 00:48:03,480
it again it will just load it from the

00:48:00,500 --> 00:48:06,030
from the cache and if we update the

00:48:03,480 --> 00:48:09,050
country and we flush it the next time

00:48:06,030 --> 00:48:12,420
the persister will see that the specific

00:48:09,050 --> 00:48:15,030
cache region has a different time stamp

00:48:12,420 --> 00:48:17,670
than the previous one so it does some

00:48:15,030 --> 00:48:20,970
kind of magic also to

00:48:17,670 --> 00:48:24,260
help you with the probably caching with

00:48:20,970 --> 00:48:27,029
the second level caching invalidation

00:48:24,260 --> 00:48:30,660
there are some limitations if you're

00:48:27,029 --> 00:48:32,910
using second level cache you can't have

00:48:30,660 --> 00:48:35,450
a back office system for something like

00:48:32,910 --> 00:48:38,730
that because the database will be

00:48:35,450 --> 00:48:41,730
updated from another application and you

00:48:38,730 --> 00:48:46,079
are looking to your second level cache

00:48:41,730 --> 00:48:49,980
close by so you won't see any updates so

00:48:46,079 --> 00:48:51,900
it's you can you can use it if you also

00:48:49,980 --> 00:48:57,059
invalidate caches from the other side

00:48:51,900 --> 00:48:59,369
but down the rabbit hole and then you

00:48:57,059 --> 00:49:01,650
the other limitation is that you must

00:48:59,369 --> 00:49:05,190
use single primary keys but that's not

00:49:01,650 --> 00:49:11,460
really an issue because it's easier

00:49:05,190 --> 00:49:15,359
anyway to use single primary keys I have

00:49:11,460 --> 00:49:19,140
a small tutorial on that but I don't

00:49:15,359 --> 00:49:21,799
know if I have time to show it just

00:49:19,140 --> 00:49:21,799
that's right

00:49:28,490 --> 00:49:41,780
so second level cache I will store my

00:49:35,770 --> 00:49:44,359
caching and a data store in file formats

00:49:41,780 --> 00:49:49,070
so here I just say that I wanted to

00:49:44,359 --> 00:49:53,030
create a caching factory with default

00:49:49,070 --> 00:49:55,160
regions so poor region you can specify a

00:49:53,030 --> 00:49:57,260
TTL and stuff like that we just use the

00:49:55,160 --> 00:49:59,210
default one we say we want to use the

00:49:57,260 --> 00:50:00,950
first system cache and it this directory

00:49:59,210 --> 00:50:03,050
and then we just enable the second level

00:50:00,950 --> 00:50:04,970
caching and inject the factory to the

00:50:03,050 --> 00:50:07,990
configuration and the entity manager

00:50:04,970 --> 00:50:15,440
knows it has to use second level caching

00:50:07,990 --> 00:50:18,080
so here we add a read-only method to the

00:50:15,440 --> 00:50:21,920
caching of the products within its own

00:50:18,080 --> 00:50:25,250
region so if we list the products the

00:50:21,920 --> 00:50:27,050
first time at will to waste equal select

00:50:25,250 --> 00:50:34,250
statements and here you can see that's

00:50:27,050 --> 00:50:37,369
the this triggers the second level

00:50:34,250 --> 00:50:41,450
caching to store its data so we have

00:50:37,369 --> 00:50:44,740
three data files with the data of the

00:50:41,450 --> 00:50:48,530
entities and we have a query caching

00:50:44,740 --> 00:50:53,750
entry which just has all the IDS of the

00:50:48,530 --> 00:50:55,609
of the other entities so this is the

00:50:53,750 --> 00:50:57,980
content of the data we have a canted

00:50:55,609 --> 00:51:00,530
cache entry with an ID and the plain

00:50:57,980 --> 00:51:04,220
text of the the underpaint values and

00:51:00,530 --> 00:51:07,430
here we have the query cache so the SQL

00:51:04,220 --> 00:51:12,250
is encoded in the key and we have a list

00:51:07,430 --> 00:51:15,530
of identifiers that match the the query

00:51:12,250 --> 00:51:20,589
so here we execute it again and we see

00:51:15,530 --> 00:51:23,869
the select statements as isn't executed

00:51:20,589 --> 00:51:25,820
the same for products we have we have

00:51:23,869 --> 00:51:28,550
the burke and we mark the products as

00:51:25,820 --> 00:51:30,440
cached the first time we'll fetch the

00:51:28,550 --> 00:51:32,630
burke and at duty will do the lazy

00:51:30,440 --> 00:51:34,460
loading of the products and the second

00:51:32,630 --> 00:51:37,070
time it has the product tank cache and I

00:51:34,460 --> 00:51:41,609
won't generate it won't execute the

00:51:37,070 --> 00:51:44,849
sequel anymore this is an example of the

00:51:41,609 --> 00:51:46,799
rakesh who we just we want a product

00:51:44,849 --> 00:51:51,089
with a specific name and we enable the

00:51:46,799 --> 00:51:55,619
caching on it so first one query second

00:51:51,089 --> 00:52:02,960
one no query and that's the example of

00:51:55,619 --> 00:52:02,960
second level caching in conclusion

00:52:03,440 --> 00:52:09,239
keeping keep in mind how the internals

00:52:05,609 --> 00:52:12,829
work to prefer to M yeah make sure your

00:52:09,239 --> 00:52:12,829
performance as getting better

00:52:13,220 --> 00:52:22,380
always use the query and mapping caching

00:52:17,309 --> 00:52:24,150
and use up code caching yeah because if

00:52:22,380 --> 00:52:27,390
you don't it just another interesting

00:52:24,150 --> 00:52:29,640
end performance if you have heavy query

00:52:27,390 --> 00:52:32,970
heavy Clarice where the large which all

00:52:29,640 --> 00:52:35,730
set cache those queries and give second

00:52:32,970 --> 00:52:38,249
level casting a try you will see if it

00:52:35,730 --> 00:52:41,309
is if it's suitable for your application

00:52:38,249 --> 00:52:43,470
or not but even if you're only just

00:52:41,309 --> 00:52:46,529
caching the entities and not the queries

00:52:43,470 --> 00:52:48,930
or the collections you all will see

00:52:46,529 --> 00:52:52,710
already a performance boost because the

00:52:48,930 --> 00:52:54,630
data is cached locally and finally the

00:52:52,710 --> 00:52:56,460
query cache of the rock doctrine is not

00:52:54,630 --> 00:52:59,099
the same as the second level Cali group

00:52:56,460 --> 00:53:01,019
query cache because this will store the

00:52:59,099 --> 00:53:04,249
raw data from the database and this will

00:53:01,019 --> 00:53:11,670
store a list of identifiers so it's not

00:53:04,249 --> 00:53:14,819
it's not the same the slides will be

00:53:11,670 --> 00:53:18,900
available online on joynton please give

00:53:14,819 --> 00:53:21,200
me feedback and thank you for your

00:53:18,900 --> 00:53:21,200

YouTube URL: https://www.youtube.com/watch?v=PzrbkRZEdHA


