Title: PHP UK Conference 2012 - Masterizing PHP Data Structure 102, by Patrick Allaert
Publication date: 2012-03-20
Playlist: PHP UK Conference 2012
Description: 
	http://www.phpconference.co.uk/talk/masterizing-php-data-structure-102

We all have certainly learned data structures at school: arrays, lists, sets, stacks, queues (LIFO/FIFO), heaps, associative arrays, trees, ... and what do we mostly use in PHP? The "array"! In most cases, we do everything and anything with it but we stumble upon it when profiling code.

During this session, we'll learn again to use the structures appropriately, leaning closer on the way to employ arrays, the SPL and other structures from PHP extensions as well.

 
Patrick Allaert is a freelance system engineer and founder of Libereco Technologies, a Brussels based company specialized in PHP services. Using PHP since the early days of PHP 3, he is contributing/hacking on a wide variety of projects including PHP, eZ Publish, Linux and KDE. In his spare time, he also works on the PHP monitoring extension: APM for which he is the lead developer. Those activities doesn't give him much more time to blog or to tweet (@patrick_allaert).
Captions: 
	00:00:08,610 --> 00:00:12,290
hello can you hear me

00:00:14,099 --> 00:00:19,980
so yes master rising PHP does a

00:00:16,439 --> 00:00:22,919
stricture one or two so if you want to

00:00:19,980 --> 00:00:25,500
learn really the basics of of pitch he

00:00:22,919 --> 00:00:31,140
array integers floats that would be the

00:00:25,500 --> 00:00:33,360
for the 101 but first a little bit about

00:00:31,140 --> 00:00:34,019
me I'm Patrick a lot I found out my

00:00:33,360 --> 00:00:36,269
company

00:00:34,019 --> 00:00:39,480
the miracle technologies Brussels

00:00:36,269 --> 00:00:43,769
company I'm mainly working for easy

00:00:39,480 --> 00:00:46,640
publish or which is a content management

00:00:43,769 --> 00:00:50,160
system which was quite popular now

00:00:46,640 --> 00:00:54,629
wordpress drupal is winning the market

00:00:50,160 --> 00:00:57,239
and i'm also the author of the APM PHP

00:00:54,629 --> 00:01:00,840
extension i will just present it in one

00:00:57,239 --> 00:01:03,390
slide so you know but just just ask me

00:01:00,840 --> 00:01:05,910
after if you want some demo some demo i

00:01:03,390 --> 00:01:09,119
can show you how it works and you're

00:01:05,910 --> 00:01:11,640
here married it is basically AP and

00:01:09,119 --> 00:01:13,850
that's monitoring this tension with all

00:01:11,640 --> 00:01:16,410
the errors you may have on your site and

00:01:13,850 --> 00:01:20,070
you can have some details about what

00:01:16,410 --> 00:01:24,020
what was wrong at that point but i would

00:01:20,070 --> 00:01:32,909
maybe try to demonstrate that after

00:01:24,020 --> 00:01:35,520
master rising today i'd like to to do to

00:01:32,909 --> 00:01:37,799
let you mastering and rising the data

00:01:35,520 --> 00:01:43,439
structure because that a structure in

00:01:37,799 --> 00:01:46,110
PHP is not so rich we have in PHP some

00:01:43,439 --> 00:01:49,649
nettles data types so whenever you have

00:01:46,110 --> 00:01:52,680
a value which in the in internally in

00:01:49,649 --> 00:01:56,399
PHP in the core you have that virus that

00:01:52,680 --> 00:01:59,250
vas is a structure which has a flag

00:01:56,399 --> 00:02:01,140
which tells you whether it's nil boolean

00:01:59,250 --> 00:02:05,189
integers floating point numbers

00:02:01,140 --> 00:02:08,700
constants objects an array but basically

00:02:05,189 --> 00:02:10,950
that's all and you cannot easily extend

00:02:08,700 --> 00:02:15,510
that because this is really the heart of

00:02:10,950 --> 00:02:19,610
PHP there is a bunch more data types

00:02:15,510 --> 00:02:22,250
that exist this is a list of data types

00:02:19,610 --> 00:02:26,280
abstract data types concrete data types

00:02:22,250 --> 00:02:27,250
on Wikipedia you can certainly not see

00:02:26,280 --> 00:02:30,810
them but

00:02:27,250 --> 00:02:34,780
you have heaps doubly linked list trees

00:02:30,810 --> 00:02:36,820
hashes lightmap I just adjust until East

00:02:34,780 --> 00:02:41,050
and so on and so on so plenty of data

00:02:36,820 --> 00:02:44,100
types which are not so not so common

00:02:41,050 --> 00:02:46,840
when you develop in PHP most of the time

00:02:44,100 --> 00:02:49,510
when you create a variable that contains

00:02:46,840 --> 00:02:55,840
different things you name it array and

00:02:49,510 --> 00:02:58,330
only array so I I will try to my point

00:02:55,840 --> 00:03:00,730
here is that we should try to do stick

00:02:58,330 --> 00:03:03,520
with the good names when when defining

00:03:00,730 --> 00:03:06,340
variables so that we know what we are

00:03:03,520 --> 00:03:08,080
talking about with design patterns it's

00:03:06,340 --> 00:03:09,400
a bit the same thing when you call

00:03:08,080 --> 00:03:12,520
something a single term have it

00:03:09,400 --> 00:03:17,080
everybody knows what a single term is we

00:03:12,520 --> 00:03:19,180
don't use it if you have if you have a

00:03:17,080 --> 00:03:21,400
strategy pattern it's a common

00:03:19,180 --> 00:03:23,200
vocabulary so if you use the same for

00:03:21,400 --> 00:03:25,630
the data types you will enrich your

00:03:23,200 --> 00:03:28,860
application and it will become more

00:03:25,630 --> 00:03:31,480
clear when you have to read the code

00:03:28,860 --> 00:03:36,160
first of all I have a little game for

00:03:31,480 --> 00:03:38,680
you so I have a set of pictures and I

00:03:36,160 --> 00:03:44,950
would like you to recognize some data

00:03:38,680 --> 00:03:48,220
structure into these pictures so scream

00:03:44,950 --> 00:03:50,410
when you you understand which data

00:03:48,220 --> 00:03:57,040
structure it is I think you've been

00:03:50,410 --> 00:04:02,560
there so basically that is a a cue of

00:03:57,040 --> 00:04:08,110
course just a few moments after you have

00:04:02,560 --> 00:04:11,590
all these stacks all the stacks of of

00:04:08,110 --> 00:04:13,299
your names this is everybody every time

00:04:11,590 --> 00:04:17,680
you are looking somewhere you can see

00:04:13,299 --> 00:04:25,870
plenty of the descriptor around you next

00:04:17,680 --> 00:04:30,250
one which one is this that's that's our

00:04:25,870 --> 00:04:31,590
set sets of gates nerds dogs everybody's

00:04:30,250 --> 00:04:35,460
here

00:04:31,590 --> 00:04:37,470
a bit more difficult

00:04:35,460 --> 00:04:41,250
I put this picture in at the teach

00:04:37,470 --> 00:04:44,460
people next conference once there was

00:04:41,250 --> 00:04:46,590
one months ago and you could take it's

00:04:44,460 --> 00:04:50,340
it's something which rotates and you

00:04:46,590 --> 00:04:55,730
have to pick the can which is just in

00:04:50,340 --> 00:05:00,690
front of you so someone someone can try

00:04:55,730 --> 00:05:04,080
yes correct okay so some some are really

00:05:00,690 --> 00:05:07,470
obvious of course if I can if I present

00:05:04,080 --> 00:05:11,070
this to you you would say that this is

00:05:07,470 --> 00:05:17,580
really correct you can combine them to

00:05:11,070 --> 00:05:20,030
have more more rich data types so let's

00:05:17,580 --> 00:05:23,730
read the same as the previous one but

00:05:20,030 --> 00:05:27,030
look at the numbers you know I have an

00:05:23,730 --> 00:05:30,710
array of circularbuffer this oh you can

00:05:27,030 --> 00:05:34,110
play with just different data types

00:05:30,710 --> 00:05:39,380
okay this one is more funny what kind of

00:05:34,110 --> 00:05:39,380
the racket is the symmetric

00:05:42,250 --> 00:05:50,180
okay behind hold these data types you

00:05:46,430 --> 00:05:52,640
have some principles with which I wanted

00:05:50,180 --> 00:05:55,370
to show in the next picture it's it's

00:05:52,640 --> 00:05:58,660
kind of difficult to understand this

00:05:55,370 --> 00:06:03,010
principle if I give you this

00:05:58,660 --> 00:06:04,310
no no clue I would have said first-in

00:06:03,010 --> 00:06:15,410
first-out

00:06:04,310 --> 00:06:17,930
I mentioned the array but in PHP when

00:06:15,410 --> 00:06:24,530
you are manipulating an array that's not

00:06:17,930 --> 00:06:28,070
truly under it that's a lot the PHP

00:06:24,530 --> 00:06:30,290
arrays typically an array looks like

00:06:28,070 --> 00:06:34,040
something like this you have a fixed

00:06:30,290 --> 00:06:36,190
size index by a number you can play in C

00:06:34,040 --> 00:06:38,990
you could play with some pointers

00:06:36,190 --> 00:06:43,040
arithmetic stood erect lis be on the

00:06:38,990 --> 00:06:47,300
correct information that is a pure array

00:06:43,040 --> 00:06:50,270
something which is studied PHP arrays

00:06:47,300 --> 00:06:53,510
they can dynamically grow they can be

00:06:50,270 --> 00:06:57,740
iterated in both directions and those

00:06:53,510 --> 00:07:00,860
are all one operations so we can think

00:06:57,740 --> 00:07:04,850
about an implementation based on a

00:07:00,860 --> 00:07:07,400
doubly linked list so you have hats tail

00:07:04,850 --> 00:07:09,950
and you can begin with pointers travails

00:07:07,400 --> 00:07:14,420
traversing all the information in one

00:07:09,950 --> 00:07:16,220
direction or the order and with this

00:07:14,420 --> 00:07:20,540
doubly linked list you it enables

00:07:16,220 --> 00:07:23,120
implementation of lists like juice and

00:07:20,540 --> 00:07:26,090
stack so this is what you can do already

00:07:23,120 --> 00:07:29,810
with that that's not really how HP

00:07:26,090 --> 00:07:32,390
arrays looks like because with a PHP

00:07:29,810 --> 00:07:35,960
array elements are always accessible

00:07:32,390 --> 00:07:41,420
accessible by a key but this key might

00:07:35,960 --> 00:07:45,440
be numeric might be a string so this one

00:07:41,420 --> 00:07:48,500
is it makes these internal structure

00:07:45,440 --> 00:07:52,070
much more complex I don't want to go to

00:07:48,500 --> 00:07:54,150
more they have too much details here

00:07:52,070 --> 00:07:56,400
because I think you're honest

00:07:54,150 --> 00:08:00,419
if he's in this room we'll talk about

00:07:56,400 --> 00:08:03,660
the hashes in PHP internally so just a

00:08:00,419 --> 00:08:07,740
quick overview when you want to have an

00:08:03,660 --> 00:08:11,490
ash table on top of your elements you

00:08:07,740 --> 00:08:14,880
will have an array of pointer buckets

00:08:11,490 --> 00:08:17,430
that will contain the ash the ash

00:08:14,880 --> 00:08:20,760
information and because and thanks to

00:08:17,430 --> 00:08:22,940
that you will you will point on a bucket

00:08:20,760 --> 00:08:25,139
that with itself point to the data and

00:08:22,940 --> 00:08:28,199
with this kind of structure you can

00:08:25,139 --> 00:08:30,750
index something that thanks to a hash

00:08:28,199 --> 00:08:32,580
thanks Ohashi you can directly go on

00:08:30,750 --> 00:08:35,460
your information whether you're using an

00:08:32,580 --> 00:08:36,810
integer or string to access it you can

00:08:35,460 --> 00:08:39,930
go in one direction in the other

00:08:36,810 --> 00:08:44,130
direction but I will skip mentioning all

00:08:39,930 --> 00:08:46,080
the the dynamic aspect of this data

00:08:44,130 --> 00:08:53,000
structure but an array is very complex

00:08:46,080 --> 00:08:55,770
in PHP taking the documentation of PHP

00:08:53,000 --> 00:08:57,870
this type is optimized for several

00:08:55,770 --> 00:09:00,300
different uses it can be treated as an

00:08:57,870 --> 00:09:03,800
array list hash table dictionary

00:09:00,300 --> 00:09:06,330
collection stack you and probably more

00:09:03,800 --> 00:09:09,779
optimized for several different uses

00:09:06,330 --> 00:09:12,180
let's say optimize for anything

00:09:09,779 --> 00:09:13,920
it's about optimized for nothing because

00:09:12,180 --> 00:09:17,850
if you want to do absolutely everything

00:09:13,920 --> 00:09:21,480
yeah I'm an expert PHP Ruby right on the

00:09:17,850 --> 00:09:28,200
wrapper C and so on no you can be you

00:09:21,480 --> 00:09:31,589
can be on on every language so in C when

00:09:28,200 --> 00:09:35,459
you have hundred thousand integers that

00:09:31,589 --> 00:09:39,270
will take about a bit less than one

00:09:35,459 --> 00:09:43,050
minutes in pitch in PHP you will have

00:09:39,270 --> 00:09:46,350
almost 14 megabytes so a PHP variable

00:09:43,050 --> 00:09:50,400
takes about 48 bytes and the overhead of

00:09:46,350 --> 00:09:53,880
Beckett it's twice the size of the value

00:09:50,400 --> 00:09:57,300
itself I'm taking numbers on a 64-bit

00:09:53,880 --> 00:10:00,540
system if you want more details take a

00:09:57,300 --> 00:10:03,300
look at the this URL you will have my

00:10:00,540 --> 00:10:07,130
slides this is a block of nikita popov

00:10:03,300 --> 00:10:07,130
which explains this very well

00:10:07,520 --> 00:10:13,890
let's let's introduce those data

00:10:10,860 --> 00:10:17,790
structures the first one I the first one

00:10:13,890 --> 00:10:22,440
is simple straight we don't have a way

00:10:17,790 --> 00:10:24,600
to we cannot have strips in PHP every

00:10:22,440 --> 00:10:27,540
data structures we have to make them on

00:10:24,600 --> 00:10:33,720
top of the existing internal data types

00:10:27,540 --> 00:10:38,040
a stret is something which consists of a

00:10:33,720 --> 00:10:41,250
series of a severe series of properties

00:10:38,040 --> 00:10:44,490
without any logic so for this there is

00:10:41,250 --> 00:10:46,020
two possibilities or you are using an

00:10:44,490 --> 00:10:50,480
array here

00:10:46,020 --> 00:10:54,930
it's it would be a map or a dictionary

00:10:50,480 --> 00:10:56,760
it works pretty well but you can't

00:10:54,930 --> 00:11:00,090
really have the benefit of a strict

00:10:56,760 --> 00:11:03,660
doing and doing this way another option

00:11:00,090 --> 00:11:05,550
is to use a class with a class you can

00:11:03,660 --> 00:11:09,270
have you can benefit of the constructor

00:11:05,550 --> 00:11:11,070
and define your class that way two

00:11:09,270 --> 00:11:14,640
properties first name last name for a

00:11:11,070 --> 00:11:17,370
person street and just create a simple

00:11:14,640 --> 00:11:20,730
constructor if you want to enforce

00:11:17,370 --> 00:11:22,500
something if you want to enforce the

00:11:20,730 --> 00:11:25,170
fact that you don't want to have some

00:11:22,500 --> 00:11:26,820
big properties on your class you can do

00:11:25,170 --> 00:11:32,910
something with the under stronger skits

00:11:26,820 --> 00:11:35,460
and the scrum the score sets middle the

00:11:32,910 --> 00:11:39,300
advantage of using a class is that no

00:11:35,460 --> 00:11:42,630
with PHP 5.4 it will take less memory

00:11:39,300 --> 00:11:46,830
than then a single than simply an array

00:11:42,630 --> 00:11:49,980
believe me or not so before 5.3 a 5.4

00:11:46,830 --> 00:11:53,820
that was not the case but now it's a

00:11:49,980 --> 00:11:56,760
really consumes less memory one of the

00:11:53,820 --> 00:12:00,360
benefit of strict normally in C is that

00:11:56,760 --> 00:12:02,070
you might use well if it's strongly

00:12:00,360 --> 00:12:04,250
typed you know that you cannot pass

00:12:02,070 --> 00:12:06,600
something else this is what you have

00:12:04,250 --> 00:12:10,250
with a class when you are using the

00:12:06,600 --> 00:12:16,970
class you have something rigid and

00:12:10,250 --> 00:12:16,970
slightly slower that depends not so

00:12:18,220 --> 00:12:24,790
through arrays the array is like in C or

00:12:21,879 --> 00:12:28,930
in other languages well that's pretty

00:12:24,790 --> 00:12:30,550
abused too to create this is in p3 it's

00:12:28,930 --> 00:12:33,850
a fixed size collection where elements

00:12:30,550 --> 00:12:37,930
are each identified by a new numeric

00:12:33,850 --> 00:12:41,579
index so it looks like this and you know

00:12:37,930 --> 00:12:44,949
how to do this with the array in PHP

00:12:41,579 --> 00:12:48,519
another way to do it is using SPL fixed

00:12:44,949 --> 00:12:52,689
array declare this with us with the the

00:12:48,519 --> 00:12:54,850
size of your array at first you can you

00:12:52,689 --> 00:12:58,060
can make it growth but most time you

00:12:54,850 --> 00:13:01,319
probably don't want this and you can use

00:12:58,060 --> 00:13:05,019
this as an array it has a few benefits

00:13:01,319 --> 00:13:08,129
because it uses less memory really

00:13:05,019 --> 00:13:19,120
really less and it's more or less more

00:13:08,129 --> 00:13:22,600
object-oriented cues choose is when you

00:13:19,120 --> 00:13:25,839
have an ordered collection respecting

00:13:22,600 --> 00:13:28,389
the first in first out order and where

00:13:25,839 --> 00:13:32,769
elements are inserted at one hand but

00:13:28,389 --> 00:13:35,649
removed at the other end you are using

00:13:32,769 --> 00:13:38,860
this if you have some you have requests

00:13:35,649 --> 00:13:41,259
to process you make them enter the EQ

00:13:38,860 --> 00:13:48,630
and you want to process them in the same

00:13:41,259 --> 00:13:48,630
order that they arrived this way

00:13:48,959 --> 00:13:53,369
implementing this at beyond in PHP with

00:13:51,660 --> 00:13:58,110
the simple array structure is very

00:13:53,369 --> 00:14:00,300
simple just use adding the elements to

00:13:58,110 --> 00:14:02,879
an array and array shift that will do

00:14:00,300 --> 00:14:08,850
the trick but SPL also provides

00:14:02,879 --> 00:14:11,879
something in addition with has plq you

00:14:08,850 --> 00:14:15,420
can use an object you can use the

00:14:11,879 --> 00:14:18,199
methods of the SPL cube as well as the

00:14:15,420 --> 00:14:23,040
regular syntax you would use with hurry

00:14:18,199 --> 00:14:26,970
and with DQ you can retrieve your

00:14:23,040 --> 00:14:29,249
elements back you can also do operations

00:14:26,970 --> 00:14:30,660
like for each understand SPL queue this

00:14:29,249 --> 00:14:32,850
will give you an iterator and you will

00:14:30,660 --> 00:14:35,279
be able to iterate of D on the elements

00:14:32,850 --> 00:14:40,050
in the other order they appeared in the

00:14:35,279 --> 00:14:42,470
queue I will talk I will talk about the

00:14:40,050 --> 00:14:48,959
benefits of a spill queue right after

00:14:42,470 --> 00:14:52,970
next one is stack internally you have

00:14:48,959 --> 00:14:57,089
about the same options than for queues a

00:14:52,970 --> 00:14:59,399
stack is really looks like a queue the

00:14:57,089 --> 00:15:03,179
only difference is that instead of FIFO

00:14:59,399 --> 00:15:06,179
its level so the last in is the first

00:15:03,179 --> 00:15:08,759
out and elements are inserted and

00:15:06,179 --> 00:15:11,819
removed at the same place at the same

00:15:08,759 --> 00:15:15,629
height so this is typically used if you

00:15:11,819 --> 00:15:17,939
are if you have some recursive methods

00:15:15,629 --> 00:15:20,670
you want to remember something you want

00:15:17,939 --> 00:15:25,740
to and you want to pop the elements

00:15:20,670 --> 00:15:27,540
webstore and so on so that's also

00:15:25,740 --> 00:15:30,029
possible thanks to a doubly linked list

00:15:27,540 --> 00:15:33,660
using an honourary rapid implementation

00:15:30,029 --> 00:15:36,209
just hat you use her report and it will

00:15:33,660 --> 00:15:42,029
gives you the information in the reverse

00:15:36,209 --> 00:15:46,079
order that you entered them if you want

00:15:42,029 --> 00:15:49,529
to use SPL stack that's almost anything

00:15:46,079 --> 00:15:52,019
if you are using forage on your stack

00:15:49,529 --> 00:15:54,059
while you have entered those information

00:15:52,019 --> 00:15:57,720
you will receive them in the reverse

00:15:54,059 --> 00:16:00,569
order so directly after stack array

00:15:57,720 --> 00:16:02,400
equal tree you will do a forage and you

00:16:00,569 --> 00:16:07,589
will receive three to one

00:16:02,400 --> 00:16:11,850
that's really that's really easy the

00:16:07,589 --> 00:16:15,000
advantage of SPL cues and SPL stacks

00:16:11,850 --> 00:16:19,410
over the regular array that because the

00:16:15,000 --> 00:16:22,920
average Strickler is so complex it has

00:16:19,410 --> 00:16:26,190
to because it's optimized for every

00:16:22,920 --> 00:16:28,920
usage is there is many pointers there is

00:16:26,190 --> 00:16:30,990
many the structure is quite heavy and it

00:16:28,920 --> 00:16:34,470
will use much more memory that what you

00:16:30,990 --> 00:16:37,050
have with SPL q has SPL stack an

00:16:34,470 --> 00:16:39,420
advantage if you have something in SPL q

00:16:37,050 --> 00:16:47,760
and spirits that you directly see what

00:16:39,420 --> 00:16:49,890
is the usage of your variable is not to

00:16:47,760 --> 00:16:56,370
mention that you can extend this class

00:16:49,890 --> 00:17:04,709
and give your own extended the meters

00:16:56,370 --> 00:17:09,120
with something on your sets yeah I mean

00:17:04,709 --> 00:17:11,939
the the middle of this of those sets the

00:17:09,120 --> 00:17:15,750
sets is a collection with no particular

00:17:11,939 --> 00:17:20,339
ordering and this is especially suited

00:17:15,750 --> 00:17:22,530
to test whether you whether you you have

00:17:20,339 --> 00:17:25,350
something in a set or outside a set

00:17:22,530 --> 00:17:27,750
we've also the operation like Union

00:17:25,350 --> 00:17:31,500
intersection or the complement

00:17:27,750 --> 00:17:34,230
operations that you can do on the side

00:17:31,500 --> 00:17:36,870
for example the set of very talented PHP

00:17:34,230 --> 00:17:40,920
developers here we can say okay I was in

00:17:36,870 --> 00:17:46,650
the set of PHP UK conference attendees

00:17:40,920 --> 00:17:51,080
you you have said certainly used set

00:17:46,650 --> 00:17:55,410
while you were thinking about an array

00:17:51,080 --> 00:17:58,850
using a set can be you use an array you

00:17:55,410 --> 00:18:01,350
had the information inside the array

00:17:58,850 --> 00:18:06,929
thanks to the in array operation you can

00:18:01,350 --> 00:18:09,480
directly find an element and you have a

00:18:06,929 --> 00:18:12,570
reemerge array intersect already just

00:18:09,480 --> 00:18:15,480
know who has already used a raid to have

00:18:12,570 --> 00:18:20,980
such as that's right raise your hand

00:18:15,480 --> 00:18:23,230
yeah almost everybody okay true

00:18:20,980 --> 00:18:29,590
performance killers it should be ashamed

00:18:23,230 --> 00:18:34,270
you shouldn't do that there is there is

00:18:29,590 --> 00:18:36,520
no origin no true implementation of set

00:18:34,270 --> 00:18:40,750
in PHP but there is there are some

00:18:36,520 --> 00:18:43,690
alternatives I've seen also other miss

00:18:40,750 --> 00:18:45,640
usage of offsets in PHP sometimes you

00:18:43,690 --> 00:18:47,620
want to compare value to against the

00:18:45,640 --> 00:18:50,110
different values and you see a value

00:18:47,620 --> 00:18:53,200
equal but one well too well three and so

00:18:50,110 --> 00:18:56,020
on and so on no no I smarter than this

00:18:53,200 --> 00:18:59,200
I'm using it in array and what I'm

00:18:56,020 --> 00:19:01,059
calling a set so that I have a function

00:18:59,200 --> 00:19:03,429
that will have to loop over all the

00:19:01,059 --> 00:19:07,510
information and that's really heavy you

00:19:03,429 --> 00:19:11,350
you shouldn't do that really if you are

00:19:07,510 --> 00:19:15,250
if you have a static the point here is

00:19:11,350 --> 00:19:17,380
that higher fixed values of course if

00:19:15,250 --> 00:19:22,000
you know your values in advance don't

00:19:17,380 --> 00:19:23,650
use in array don't use a big set just

00:19:22,000 --> 00:19:25,210
use this switch value and then the

00:19:23,650 --> 00:19:25,650
different values and that will do the

00:19:25,210 --> 00:19:30,210
trick

00:19:25,650 --> 00:19:37,600
it's much more simple so now about the

00:19:30,210 --> 00:19:41,110
different possibilities the an array has

00:19:37,600 --> 00:19:43,390
inside a hash mechanism and you have to

00:19:41,110 --> 00:19:45,400
be if you want if you are implementing a

00:19:43,390 --> 00:19:49,539
set you want to benefit of this hash

00:19:45,400 --> 00:19:52,030
mechanism this hash mechanism is it's at

00:19:49,539 --> 00:19:54,880
the level of the key so what we have

00:19:52,030 --> 00:19:59,049
here now is that the information is

00:19:54,880 --> 00:20:02,440
stored inside the key part of the array

00:19:59,049 --> 00:20:06,880
just use the Demel you accept null

00:20:02,440 --> 00:20:10,380
values this way you can easily use each

00:20:06,880 --> 00:20:13,990
set to know whether something is inside

00:20:10,380 --> 00:20:18,010
inside the set or not you have the Union

00:20:13,990 --> 00:20:20,080
Union operator thanks to the plus array

00:20:18,010 --> 00:20:23,080
intercept key read if key and this will

00:20:20,080 --> 00:20:26,320
in a very efficient way it will compute

00:20:23,080 --> 00:20:36,700
the different

00:20:26,320 --> 00:20:41,380
the different operations onset remember

00:20:36,700 --> 00:20:45,220
that with PHP arrays the keys is not of

00:20:41,380 --> 00:20:48,730
the same value internally then the the

00:20:45,220 --> 00:20:51,760
value part so it means that it can only

00:20:48,730 --> 00:20:56,860
store integers and strings if you try to

00:20:51,760 --> 00:21:00,730
use a boolean or a nil value you would

00:20:56,860 --> 00:21:04,330
have this will be converted because only

00:21:00,730 --> 00:21:08,410
integers and strings can can be entered

00:21:04,330 --> 00:21:11,230
here so what about objects for objects

00:21:08,410 --> 00:21:16,600
we have web too we have two

00:21:11,230 --> 00:21:19,300
possibilities there is a function called

00:21:16,600 --> 00:21:22,570
SPL object hash that will give you a

00:21:19,300 --> 00:21:25,960
string which is unique at a specific

00:21:22,570 --> 00:21:28,360
moment at a specific time about an

00:21:25,960 --> 00:21:31,920
object and if you want to have a set of

00:21:28,360 --> 00:21:36,790
objects you can use SPL object hash to

00:21:31,920 --> 00:21:40,090
as the as the key of your of your object

00:21:36,790 --> 00:21:42,610
whenever you want to to check whether an

00:21:40,090 --> 00:21:45,100
object is part of the set you can use a

00:21:42,610 --> 00:21:48,580
set and again this same meter this

00:21:45,100 --> 00:21:50,800
method computes quite quickly it does

00:21:48,580 --> 00:21:56,410
not take into account the information

00:21:50,800 --> 00:22:01,320
inside the objects it just works um on a

00:21:56,410 --> 00:22:05,470
series of of properties of the variable

00:22:01,320 --> 00:22:07,810
you can reuse also use Union arrange as

00:22:05,470 --> 00:22:09,910
a key read if T exactly with the the

00:22:07,810 --> 00:22:11,470
priests method one thing is really

00:22:09,910 --> 00:22:14,890
important if you are using this

00:22:11,470 --> 00:22:19,420
technique is that you are storing the

00:22:14,890 --> 00:22:21,430
object as in the value part this is it

00:22:19,420 --> 00:22:24,520
very important because when you are

00:22:21,430 --> 00:22:27,220
using SPL object hash I mentioned it is

00:22:24,520 --> 00:22:31,150
unique but it is unique at one specific

00:22:27,220 --> 00:22:33,730
moment if I'm if I only have the those

00:22:31,150 --> 00:22:35,890
three objects one two and three and I

00:22:33,730 --> 00:22:39,520
unset object tree and I create a new

00:22:35,890 --> 00:22:40,060
object for my object for given to SPL

00:22:39,520 --> 00:22:42,340
object hash

00:22:40,060 --> 00:22:45,970
can gives me the same key i had

00:22:42,340 --> 00:22:50,220
previously for an object tree so if you

00:22:45,970 --> 00:22:52,180
want it to if you want this to work

00:22:50,220 --> 00:22:55,090
even if your objects that have been

00:22:52,180 --> 00:22:57,270
removed after store a reference of this

00:22:55,090 --> 00:23:00,460
object thanks to the internal reference

00:22:57,270 --> 00:23:02,560
mechanism of PHP you will sure that at

00:23:00,460 --> 00:23:06,430
least one instance of this object

00:23:02,560 --> 00:23:09,100
remains and this will this will ensure

00:23:06,430 --> 00:23:18,220
that SPL object at ash really gives you

00:23:09,100 --> 00:23:20,980
something unique another way

00:23:18,220 --> 00:23:25,360
thanks to SPL II is SPL object storage

00:23:20,980 --> 00:23:27,850
it's it's a very nice class to to

00:23:25,360 --> 00:23:29,860
achieve set operations when you want to

00:23:27,850 --> 00:23:33,580
enter elements you can use the array

00:23:29,860 --> 00:23:35,710
syntax or the attach method and you can

00:23:33,580 --> 00:23:37,630
use it almost like an array when you

00:23:35,710 --> 00:23:40,660
have when it comes to check the

00:23:37,630 --> 00:23:45,420
existence of an object inside this set a

00:23:40,660 --> 00:23:45,420
set the roster object to for example

00:23:47,280 --> 00:23:53,950
word example here the the different

00:23:51,900 --> 00:23:56,970
operation on set like Union intersection

00:23:53,950 --> 00:24:00,490
in compliment is also possible thanks to

00:23:56,970 --> 00:24:07,390
to do at all remove all accept and

00:24:00,490 --> 00:24:10,570
remove all methods thanks to - Derrick

00:24:07,390 --> 00:24:14,370
is directing its Dirk here no the Rick

00:24:10,570 --> 00:24:18,190
has made an extension called quick cash

00:24:14,370 --> 00:24:22,510
quick hash is available in pickle and it

00:24:18,190 --> 00:24:25,570
gives you something really more memory

00:24:22,510 --> 00:24:28,690
efficient when you have to to create a

00:24:25,570 --> 00:24:31,300
set of integers remember that the

00:24:28,690 --> 00:24:36,280
integers start in an array will consumes

00:24:31,300 --> 00:24:39,520
a very big amount of memory so thanks to

00:24:36,280 --> 00:24:42,840
this implementation you can you can have

00:24:39,520 --> 00:24:46,920
about the same benefit of

00:24:42,840 --> 00:24:50,430
of the celebrations but you will consume

00:24:46,920 --> 00:24:54,030
less memory well say it's busy right now

00:24:50,430 --> 00:24:57,000
implementing is set operation or akka

00:24:54,030 --> 00:25:03,630
accessing this like an array so that

00:24:57,000 --> 00:25:06,630
will come really cinch finally and this

00:25:03,630 --> 00:25:10,620
is something I which is very powerful

00:25:06,630 --> 00:25:15,950
but I don't not encounter this a lot in

00:25:10,620 --> 00:25:19,770
implementations you can use bit sets to

00:25:15,950 --> 00:25:22,830
to provide set operations this is only

00:25:19,770 --> 00:25:27,570
possible if you don't have a big amount

00:25:22,830 --> 00:25:29,310
of of different possible values and you

00:25:27,570 --> 00:25:31,880
are already using this if you are

00:25:29,310 --> 00:25:38,610
manipulating the error reporting level

00:25:31,880 --> 00:25:41,760
in this example we have four four

00:25:38,610 --> 00:25:45,990
constants all of them are powers of two

00:25:41,760 --> 00:25:48,210
it means that the bit which is set in

00:25:45,990 --> 00:25:51,540
this number is always at a different

00:25:48,210 --> 00:25:55,050
place and if we want to add something to

00:25:51,540 --> 00:25:58,350
a set we can we can use the pipe

00:25:55,050 --> 00:26:00,720
operator so add or a set back equal it's

00:25:58,350 --> 00:26:04,860
the same as the set equal the last set

00:26:00,720 --> 00:26:08,130
type II error point on this is possible

00:26:04,860 --> 00:26:11,370
if you know in advance the values you

00:26:08,130 --> 00:26:13,800
might have you might have in a set and I

00:26:11,370 --> 00:26:16,940
guess you cannot have more than 64

00:26:13,800 --> 00:26:19,830
values at the same time testing whether

00:26:16,940 --> 00:26:24,060
one of the bit is set it is very simple

00:26:19,830 --> 00:26:25,980
just use the ampersand operator and if

00:26:24,060 --> 00:26:29,520
this will check whether this set which

00:26:25,980 --> 00:26:32,880
is defining error which is that it's the

00:26:29,520 --> 00:26:36,420
last one or the first one is part of the

00:26:32,880 --> 00:26:39,810
set same for same for Union intersection

00:26:36,420 --> 00:26:44,910
and compliment this is the most

00:26:39,810 --> 00:26:50,130
efficient way to to have to have set on

00:26:44,910 --> 00:26:54,930
a series of defined values at first let

00:26:50,130 --> 00:26:56,370
me give give you an example of some kind

00:26:54,930 --> 00:26:58,110
of API I don't

00:26:56,370 --> 00:27:02,820
really like and I see this very often

00:26:58,110 --> 00:27:06,800
while doing some audits it's methods

00:27:02,820 --> 00:27:10,740
which has a bunch of of behavioral

00:27:06,800 --> 00:27:13,080
properties like a remove remove methods

00:27:10,740 --> 00:27:15,390
which has the possibility to remove

00:27:13,080 --> 00:27:17,370
files directories links executables

00:27:15,390 --> 00:27:22,980
and you want to have some controls in

00:27:17,370 --> 00:27:27,410
ten and you're defining all the what

00:27:22,980 --> 00:27:30,990
what the operations are permitted or not

00:27:27,410 --> 00:27:34,650
if I want to use this I will have an API

00:27:30,990 --> 00:27:37,110
like this remove some five to four

00:27:34,650 --> 00:27:40,830
through four faults what effect

00:27:37,110 --> 00:27:43,370
that's not readable at all I see these

00:27:40,830 --> 00:27:47,760
many times and in PHP you also have a

00:27:43,370 --> 00:27:50,000
you also have a function which is using

00:27:47,760 --> 00:27:54,360
the the technique I would suggest here

00:27:50,000 --> 00:27:57,390
this is using the set we just see we

00:27:54,360 --> 00:28:00,809
just see before thanks to a set I

00:27:57,390 --> 00:28:04,260
definitely see what what's the purpose

00:28:00,809 --> 00:28:05,940
of this call and you don't have to you

00:28:04,260 --> 00:28:08,550
are not forced to use the default values

00:28:05,940 --> 00:28:11,429
from your method because otherwise when

00:28:08,550 --> 00:28:16,020
you if I come back here I see through

00:28:11,429 --> 00:28:18,870
first route force okay the first the the

00:28:16,020 --> 00:28:21,809
first two word was that default values

00:28:18,870 --> 00:28:24,870
or not wasn't that my what was my

00:28:21,809 --> 00:28:28,410
intention here I have no clue does that

00:28:24,870 --> 00:28:31,710
one possibly use some will some will

00:28:28,410 --> 00:28:33,660
prefer using a strict to define the

00:28:31,710 --> 00:28:34,950
possible operations that would be a bit

00:28:33,660 --> 00:28:37,740
more whoa

00:28:34,950 --> 00:28:41,160
but personally I have a preference for

00:28:37,740 --> 00:28:46,440
for using bit fields in for this kind of

00:28:41,160 --> 00:28:48,600
set as you've seen there is a to

00:28:46,440 --> 00:28:52,710
implement set there is a bunch of

00:28:48,600 --> 00:28:59,250
possibilities whenever possible use the

00:28:52,710 --> 00:29:02,790
key to store your information this is

00:28:59,250 --> 00:29:06,600
the this is possible in every platform

00:29:02,790 --> 00:29:09,390
you don't require an extension but if

00:29:06,600 --> 00:29:09,910
you know it's a set of integers give it

00:29:09,390 --> 00:29:11,740
a try

00:29:09,910 --> 00:29:14,520
the quick hash extension this is really

00:29:11,740 --> 00:29:16,680
fast this is really memory efficient and

00:29:14,520 --> 00:29:21,190
it works very well

00:29:16,680 --> 00:29:25,930
SPL object storage it's also available

00:29:21,190 --> 00:29:27,910
by default use it some pretend it

00:29:25,930 --> 00:29:30,870
suffers from performance issue

00:29:27,910 --> 00:29:34,870
I've been markets in all possible ways

00:29:30,870 --> 00:29:37,090
with five three five four I don't see

00:29:34,870 --> 00:29:41,440
how it is more or less performant

00:29:37,090 --> 00:29:45,160
than the memory I would say the opposite

00:29:41,440 --> 00:29:48,810
since it consumes less memory and about

00:29:45,160 --> 00:29:54,100
perform at speed performance the same

00:29:48,810 --> 00:29:57,220
and try to get rid of operations like

00:29:54,100 --> 00:29:58,810
array unique when you need a set try to

00:29:57,220 --> 00:30:03,280
use one of the techniques we've just

00:29:58,810 --> 00:30:06,790
seen now rather than transforming a list

00:30:03,280 --> 00:30:11,040
of information that you reduce thank you

00:30:06,790 --> 00:30:11,040
very unique this is not efficient other

00:30:13,890 --> 00:30:22,870
nuts I introduce Matt in the first

00:30:19,030 --> 00:30:25,210
structure about struct a strict can can

00:30:22,870 --> 00:30:27,730
rely on a map to determine this I

00:30:25,210 --> 00:30:30,820
thought it's not my my preferred way a

00:30:27,730 --> 00:30:36,820
map is a collection of key value pairs

00:30:30,820 --> 00:30:41,620
all those keys have to be unique one

00:30:36,820 --> 00:30:46,240
possible implementation is using the

00:30:41,620 --> 00:30:49,420
array using the original array of PHP

00:30:46,240 --> 00:30:52,270
when you have to merge Maps because you

00:30:49,420 --> 00:30:55,660
know they are maps don't use a reemerge

00:30:52,270 --> 00:30:58,360
never this is really not efficient use

00:30:55,660 --> 00:31:01,480
the press operator it's much much faster

00:30:58,360 --> 00:31:04,080
because it involves less variations

00:31:01,480 --> 00:31:04,080
basically

00:31:06,399 --> 00:31:15,109
another kind of map is multi key map you

00:31:11,330 --> 00:31:19,639
have something a bit similar with the

00:31:15,109 --> 00:31:22,519
mice with MySQL you can return the

00:31:19,639 --> 00:31:27,349
elements of the rows either by numeric

00:31:22,519 --> 00:31:30,649
index or index by the by the name of the

00:31:27,349 --> 00:31:34,999
column or you may have both if you want

00:31:30,649 --> 00:31:38,960
your API to be flexible to use one or

00:31:34,999 --> 00:31:42,259
other keys to represent exactly the same

00:31:38,960 --> 00:31:44,509
value and to remain consistent when you

00:31:42,259 --> 00:31:47,659
have to change something you can make

00:31:44,509 --> 00:31:50,749
use of G of the reference the internal

00:31:47,659 --> 00:31:54,529
reference mechanism of PHP in this

00:31:50,749 --> 00:31:58,960
example I'm I'm indexing the the same

00:31:54,529 --> 00:32:07,190
element with different language one uno

00:31:58,960 --> 00:32:11,859
to the way if I dump this I will see

00:32:07,190 --> 00:32:15,619
that if I change the information here

00:32:11,859 --> 00:32:18,259
all the indexes will remain correct and

00:32:15,619 --> 00:32:22,369
point on under my value so I don't have

00:32:18,259 --> 00:32:23,029
to do anything else to to give this this

00:32:22,369 --> 00:32:26,049
facility

00:32:23,029 --> 00:32:35,059
so that's that's sometimes very

00:32:26,049 --> 00:32:41,809
interesting heat when when say heat sink

00:32:35,059 --> 00:32:44,749
sort or sorted order a heat is not is a

00:32:41,809 --> 00:32:48,229
tree based structure where all elements

00:32:44,749 --> 00:32:52,669
are ordered with the biggest key at the

00:32:48,229 --> 00:32:55,070
top so this is an example of how heap

00:32:52,669 --> 00:32:59,259
could be represented if you want to have

00:32:55,070 --> 00:33:05,739
a specific holder like with priorities

00:32:59,259 --> 00:33:05,739
you you can you can design it that way

00:33:06,099 --> 00:33:13,489
using an array you can implement a heap

00:33:10,659 --> 00:33:17,520
every time you enter an information you

00:33:13,489 --> 00:33:20,160
sort it and you have a kind of heap at

00:33:17,520 --> 00:33:23,820
that the way you use this is not

00:33:20,160 --> 00:33:27,330
efficient at all because salt is really

00:33:23,820 --> 00:33:29,880
heavy it will it does not have the

00:33:27,330 --> 00:33:32,610
information that your array is already

00:33:29,880 --> 00:33:35,910
sorted until now so every time you do

00:33:32,610 --> 00:33:39,270
the sort he assumes that the information

00:33:35,910 --> 00:33:44,370
is not yet sorter sorted so that's a bit

00:33:39,270 --> 00:33:48,930
hairy an alternative is to use SPL SPL

00:33:44,370 --> 00:33:51,900
heap SPL min-heap or SPL max heap

00:33:48,930 --> 00:33:54,150
depends on which order you want and

00:33:51,900 --> 00:33:56,280
every time you insert an information

00:33:54,150 --> 00:33:59,340
because of the tree structure internally

00:33:56,280 --> 00:34:07,110
it will all the information will remain

00:33:59,340 --> 00:34:10,020
at every moment sorted note that in my

00:34:07,110 --> 00:34:14,399
previous slide I was sorting at every

00:34:10,020 --> 00:34:17,700
single step this is something you might

00:34:14,399 --> 00:34:20,610
not need heap is really for having

00:34:17,700 --> 00:34:22,440
something which is at all time sorted if

00:34:20,610 --> 00:34:24,419
you have your you're retrieving

00:34:22,440 --> 00:34:27,240
informations and you just want to have

00:34:24,419 --> 00:34:30,000
them sort that just to retrieve them and

00:34:27,240 --> 00:34:31,740
use a unique sort of course but if you

00:34:30,000 --> 00:34:35,190
have a strict rate that you have to to

00:34:31,740 --> 00:34:38,520
constantly modify and it should remain

00:34:35,190 --> 00:34:40,440
sorted then this is really a heap so

00:34:38,520 --> 00:34:43,260
don't become choose between the two and

00:34:40,440 --> 00:34:50,300
this is what SP and min heap and Max Eve

00:34:43,260 --> 00:34:53,370
is useful so hits are much much faster

00:34:50,300 --> 00:34:56,159
implementation to result an array at

00:34:53,370 --> 00:34:58,380
every insertion if you don't require our

00:34:56,159 --> 00:35:01,560
collection to be sorted at every single

00:34:58,380 --> 00:35:06,150
step use an array and a single zone this

00:35:01,560 --> 00:35:08,850
is efficient as I did not mention as

00:35:06,150 --> 00:35:11,940
real priority queue this is something

00:35:08,850 --> 00:35:14,970
really similar it just consists as an

00:35:11,940 --> 00:35:19,610
SPL heap where they're asserting is made

00:35:14,970 --> 00:35:22,760
on the key rather than the value this

00:35:19,610 --> 00:35:22,760
lets say

00:35:24,340 --> 00:35:31,280
bloom filters that looks really strange

00:35:28,690 --> 00:35:34,640
bloom filters is something efficient

00:35:31,280 --> 00:35:38,360
when you want to do it for example have

00:35:34,640 --> 00:35:41,540
some filth very quick filtering or you

00:35:38,360 --> 00:35:43,460
want to access some cash and before

00:35:41,540 --> 00:35:48,470
accessing this cache you want to have a

00:35:43,460 --> 00:35:51,140
very quick operation to to knows whether

00:35:48,470 --> 00:35:53,900
something can be part of your caching

00:35:51,140 --> 00:35:56,090
system or not a bloom filter is a space

00:35:53,900 --> 00:35:58,100
efficient probabilistic this is

00:35:56,090 --> 00:36:01,780
important that a structure used to test

00:35:58,100 --> 00:36:01,780
whether an element is part of a set

00:36:02,050 --> 00:36:07,400
whenever you are using a bloom filter

00:36:04,070 --> 00:36:09,440
it's this kind of set if you have a

00:36:07,400 --> 00:36:11,330
negatives you are sure that your

00:36:09,440 --> 00:36:14,000
information is not there the thing is

00:36:11,330 --> 00:36:17,510
that it can gives you a chew while it is

00:36:14,000 --> 00:36:19,850
absolutely why it is not possible right

00:36:17,510 --> 00:36:23,030
it might not be the case so force

00:36:19,850 --> 00:36:28,100
positives are possible with a bloom

00:36:23,030 --> 00:36:31,850
filter in in Pecola if you have blooming

00:36:28,100 --> 00:36:36,920
blooming is is a PHP extension that lets

00:36:31,850 --> 00:36:40,070
you have bloom filters if here I'm

00:36:36,920 --> 00:36:45,230
defining a bloom filter with a capacity

00:36:40,070 --> 00:36:48,320
of 10 thousands element and an aneroid I

00:36:45,230 --> 00:36:51,650
can decide about the error it whenever I

00:36:48,320 --> 00:36:57,440
add an element in this room filter like

00:36:51,650 --> 00:37:01,100
element and I'm testing has an element

00:36:57,440 --> 00:37:04,670
I'm sure that I will have a troop

00:37:01,100 --> 00:37:08,030
because that's definitely something that

00:37:04,670 --> 00:37:12,560
will be true after this however if I'm

00:37:08,030 --> 00:37:14,480
asking has food thanks to the the number

00:37:12,560 --> 00:37:17,770
of information I've entered my bloom

00:37:14,480 --> 00:37:24,110
filter and thanks to the error rate I I

00:37:17,770 --> 00:37:28,390
set this 1000 most of the time I would

00:37:24,110 --> 00:37:31,130
say food will be 4s food will be false

00:37:28,390 --> 00:37:33,910
but you have to take into account that

00:37:31,130 --> 00:37:33,910
you might have

00:37:34,480 --> 00:37:38,920
you might receive a true which is not a

00:37:37,180 --> 00:37:43,359
problem if you use it correctly because

00:37:38,920 --> 00:37:47,230
you are okay uh it's it's worth seeing

00:37:43,359 --> 00:37:49,720
in my my database for example I'm trying

00:37:47,230 --> 00:37:52,240
to select an information oh I don't have

00:37:49,720 --> 00:37:58,210
it ok so you have to take into account

00:37:52,240 --> 00:38:03,789
about this possibility there are some

00:37:58,210 --> 00:38:08,230
other related projects I didn't mention

00:38:03,789 --> 00:38:10,150
here SPL it comes a bit into different

00:38:08,230 --> 00:38:13,180
ray you had the SPL extension which is

00:38:10,150 --> 00:38:16,029
bundled to PHP which provide all those

00:38:13,180 --> 00:38:18,069
SPL metals we've seen so far but you

00:38:16,029 --> 00:38:20,559
also add SPL tags this is something

00:38:18,069 --> 00:38:24,549
which is not included by default it

00:38:20,559 --> 00:38:28,150
provides you provide you as well in as

00:38:24,549 --> 00:38:31,390
well float SPL innum SPL boot bull and

00:38:28,150 --> 00:38:34,660
SPL string those our classes that will

00:38:31,390 --> 00:38:39,279
do some additional checks and if you

00:38:34,660 --> 00:38:42,130
want a strongly typed PHP you can make

00:38:39,279 --> 00:38:47,259
use of this not sure it is the Buddha

00:38:42,130 --> 00:38:52,900
crush SPL engine is not is not really

00:38:47,259 --> 00:38:55,990
flag very very flexible and but you

00:38:52,900 --> 00:38:59,559
might give them a try if you if you want

00:38:55,990 --> 00:39:04,410
to and really to enforce the types in

00:38:59,559 --> 00:39:04,410
your API this is a matter of choice

00:39:05,400 --> 00:39:14,380
another interesting pickle extensions

00:39:08,380 --> 00:39:18,009
it's ready today it's implements sparse

00:39:14,380 --> 00:39:22,059
dynamic arrays what is what is what are

00:39:18,009 --> 00:39:26,230
sparse dynamic arrays if you have a big

00:39:22,059 --> 00:39:27,910
set a big list of elements where most of

00:39:26,230 --> 00:39:30,099
those elements have the same value for

00:39:27,910 --> 00:39:32,589
example a default value think about a

00:39:30,099 --> 00:39:34,839
board game where you have some position

00:39:32,589 --> 00:39:40,089
and you have an information which is 0

00:39:34,839 --> 00:39:43,650
or 1 to whether you have something at in

00:39:40,089 --> 00:39:46,119
this grid and you have a matrix of

00:39:43,650 --> 00:39:47,940
thousands elements on thousands elements

00:39:46,119 --> 00:39:50,220
this will consume

00:39:47,940 --> 00:39:52,680
a lot of memory because it will remember

00:39:50,220 --> 00:39:55,620
the values for every possible solutions

00:39:52,680 --> 00:39:58,290
a sparse dynamic arrays it's an

00:39:55,620 --> 00:40:01,110
efficient implementation for for those

00:39:58,290 --> 00:40:03,570
kind of structures which contains mostly

00:40:01,110 --> 00:40:08,280
most of the time the same value it will

00:40:03,570 --> 00:40:10,890
always will say this most of the time on

00:40:08,280 --> 00:40:13,710
using a doubly linked list internally to

00:40:10,890 --> 00:40:16,560
remember which elements is played where

00:40:13,710 --> 00:40:19,970
in the industry there is a very good

00:40:16,560 --> 00:40:23,190
library in C which is lip-lip jadi and

00:40:19,970 --> 00:40:26,460
this spec an extension is the link

00:40:23,190 --> 00:40:28,800
between them so if you care about memory

00:40:26,460 --> 00:40:32,000
usage this is definitely something

00:40:28,800 --> 00:40:32,000
interesting interesting

00:40:33,500 --> 00:40:40,770
weak weak references it provides you

00:40:38,010 --> 00:40:45,240
gateway to an object without preventing

00:40:40,770 --> 00:40:47,520
that objects from being collected by the

00:40:45,240 --> 00:40:52,650
garbage collector so if you want to

00:40:47,520 --> 00:40:55,320
remember about an object you you had but

00:40:52,650 --> 00:41:00,270
it may be garbage collected you just

00:40:55,320 --> 00:41:02,670
want to have a trace about its its usage

00:41:00,270 --> 00:41:08,640
take a look like the weak the weak

00:41:02,670 --> 00:41:10,590
references specifications and and give

00:41:08,640 --> 00:41:13,470
it a try to this bagel extension this is

00:41:10,590 --> 00:41:18,609
a speckle extension as well I think I

00:41:13,470 --> 00:41:21,980
think I forgot to link here ok

00:41:18,609 --> 00:41:24,200
as a conclusion try to use the

00:41:21,980 --> 00:41:28,730
appropriate data structure it will keep

00:41:24,200 --> 00:41:31,359
your key your code clean and fast think

00:41:28,730 --> 00:41:35,380
also about the time and the space

00:41:31,359 --> 00:41:40,820
complexity of your of your algorithms

00:41:35,380 --> 00:41:43,849
but mostly use the try to never name an

00:41:40,820 --> 00:41:46,010
array an array adelaar array if it's

00:41:43,849 --> 00:41:49,490
used as a list if it's used as a mat or

00:41:46,010 --> 00:41:52,220
is it's used some in another way because

00:41:49,490 --> 00:42:00,470
it does not help other developers when

00:41:52,220 --> 00:42:09,470
you have to to modify the code this is

00:42:00,470 --> 00:42:12,140
basic you have some questions I just had

00:42:09,470 --> 00:42:15,710
a question about why there isn't an SPL

00:42:12,140 --> 00:42:18,619
set like is there some reason that it's

00:42:15,710 --> 00:42:20,390
complicated to write I mean you said

00:42:18,619 --> 00:42:23,900
that basically there there isn't the SPL

00:42:20,390 --> 00:42:25,430
set to to provide the kind of

00:42:23,900 --> 00:42:28,070
functionality that we get out of arrays

00:42:25,430 --> 00:42:30,650
and I mean I personally would love to be

00:42:28,070 --> 00:42:32,000
able to store int and and do those

00:42:30,650 --> 00:42:34,490
intersections that you're talking about

00:42:32,000 --> 00:42:40,880
is is there a reason it's not programmed

00:42:34,490 --> 00:42:45,080
in PHP I would say yes well it would be

00:42:40,880 --> 00:42:47,810
it might be a good improvement but most

00:42:45,080 --> 00:42:51,250
things in inside the co source code of

00:42:47,810 --> 00:42:54,260
PHP relies on the hash implementations

00:42:51,250 --> 00:42:56,510
really do see the presentation of Yanis

00:42:54,260 --> 00:43:00,530
PHP under the hood I think it will

00:42:56,510 --> 00:43:03,770
present the hash mechanism of of PHP and

00:43:00,530 --> 00:43:06,440
this hash mechanism is probably not the

00:43:03,770 --> 00:43:09,470
the good mechanism to be able to index

00:43:06,440 --> 00:43:12,020
all the different possible values

00:43:09,470 --> 00:43:14,570
it works well this is what is used for

00:43:12,020 --> 00:43:16,970
the the key part of an array but as you

00:43:14,570 --> 00:43:18,890
know you made you might have integers

00:43:16,970 --> 00:43:22,099
you might have strings having an

00:43:18,890 --> 00:43:25,910
implementation that can be that can work

00:43:22,099 --> 00:43:29,359
both on integers on strings on on arrays

00:43:25,910 --> 00:43:32,210
because you might think about a set of

00:43:29,359 --> 00:43:37,099
array and you want to a fish

00:43:32,210 --> 00:43:38,690
we check whether an array is part of the

00:43:37,099 --> 00:43:41,690
set of four arrays and that would be

00:43:38,690 --> 00:43:45,160
very complex so this is why the default

00:43:41,690 --> 00:43:50,119
hash mechanism would not help you there

00:43:45,160 --> 00:43:53,030
if you the only way but that's not

00:43:50,119 --> 00:43:56,240
efficient is to have a big array with

00:43:53,030 --> 00:43:59,000
our list and use in array but it will

00:43:56,240 --> 00:44:08,720
loop over all the elements so it's the

00:43:59,000 --> 00:44:10,369
complexity is Big O and Indian is it's

00:44:08,720 --> 00:44:12,800
very efficient way of persisting these

00:44:10,369 --> 00:44:14,510
ayodhya structures sorry

00:44:12,800 --> 00:44:18,010
is there an efficient way of persisting

00:44:14,510 --> 00:44:18,010
these data structures and restoring them

00:44:18,369 --> 00:44:25,730
not not really this is something you

00:44:22,790 --> 00:44:28,700
always have to do with your persistence

00:44:25,730 --> 00:44:31,400
layer you have you might you might say

00:44:28,700 --> 00:44:35,000
cellulous this default serialize

00:44:31,400 --> 00:44:38,020
serialization in PHP is a bit slow there

00:44:35,000 --> 00:44:41,030
is a know an alternative which is faster

00:44:38,020 --> 00:44:43,760
so you can definitely store your

00:44:41,030 --> 00:44:48,730
information in a cellulites way but it

00:44:43,760 --> 00:44:51,740
does not work every time I would say I

00:44:48,730 --> 00:44:55,160
was recently working with a tree

00:44:51,740 --> 00:44:57,670
structure sorry sorry I was recently

00:44:55,160 --> 00:45:00,170
working with a tree structure in PHP and

00:44:57,670 --> 00:45:02,450
from what I could see there was no sort

00:45:00,170 --> 00:45:05,119
of SPL extension to do that I mean

00:45:02,450 --> 00:45:08,359
what's your recommendation there tree

00:45:05,119 --> 00:45:13,940
structure we don't have there is a per

00:45:08,359 --> 00:45:17,060
project to have trees in PHP but

00:45:13,940 --> 00:45:20,839
basically that's that's not a structure

00:45:17,060 --> 00:45:23,119
which exists in an efficient way in HP

00:45:20,839 --> 00:45:26,770
because you would have you would have

00:45:23,119 --> 00:45:31,070
you would like to benefit of the of

00:45:26,770 --> 00:45:34,960
pointers to do to have full control on

00:45:31,070 --> 00:45:40,430
this you can you can use a structure

00:45:34,960 --> 00:45:42,920
where you are using reference if you if

00:45:40,430 --> 00:45:45,089
you want you can define your own but

00:45:42,920 --> 00:45:47,729
there is no such thing if

00:45:45,089 --> 00:45:49,529
if the goal is to have some priority or

00:45:47,729 --> 00:45:53,909
the goal is to have some sorting you

00:45:49,529 --> 00:45:57,359
have SPL eep but that's the internal I

00:45:53,909 --> 00:46:00,659
don't think you have access to do to use

00:45:57,359 --> 00:46:03,239
the internal mechanism of SPL heap to

00:46:00,659 --> 00:46:05,249
represent any kind of tree that's that's

00:46:03,239 --> 00:46:07,109
not something you have yeah I mean the

00:46:05,249 --> 00:46:11,159
the recommendations I saw were that it

00:46:07,109 --> 00:46:13,559
just you just use an array and then you

00:46:11,159 --> 00:46:15,239
sub arrays as children but when you're

00:46:13,559 --> 00:46:17,069
storing an object you can't obviously

00:46:15,239 --> 00:46:19,229
use that as a key and then you have to

00:46:17,069 --> 00:46:35,249
build a very ugly looking data structure

00:46:19,229 --> 00:46:36,929
around it yeah you said that the adding

00:46:35,249 --> 00:46:39,239
to maps was more efficient than using

00:46:36,929 --> 00:46:41,809
merge Maps but will produce the same

00:46:39,239 --> 00:46:44,609
results so why isn't merge map

00:46:41,809 --> 00:46:47,669
implemented in the same way is the add

00:46:44,609 --> 00:46:53,150
operation just because it does not do

00:46:47,669 --> 00:46:55,890
the same thing if you are a merge we'll

00:46:53,150 --> 00:46:59,489
we'll do some tricks about your if

00:46:55,890 --> 00:47:02,549
you're merging two arrays arrays of

00:46:59,489 --> 00:47:06,269
integers let's add two or at the tourist

00:47:02,549 --> 00:47:08,669
0 1 2 3 you have birth you merge them

00:47:06,269 --> 00:47:11,009
you have insect you you have you always

00:47:08,669 --> 00:47:13,259
have a key an internal one which is

00:47:11,009 --> 00:47:15,809
which will be the same as the value will

00:47:13,259 --> 00:47:19,319
hit 0 1 2 you will have the same key

00:47:15,809 --> 00:47:22,979
this key if this is really a if this is

00:47:19,319 --> 00:47:26,909
really a map and you want to combine

00:47:22,979 --> 00:47:31,829
them you should have 0 1 2 0 1 2 and

00:47:26,909 --> 00:47:33,209
then or 0 1 2 with if this is a hash you

00:47:31,829 --> 00:47:35,279
should have received the same

00:47:33,209 --> 00:47:38,640
information with our image this is not

00:47:35,279 --> 00:47:41,519
the case you will have 0 1 2 0 1 2 so

00:47:38,640 --> 00:47:47,069
the goal of our main array merge is too

00:47:41,519 --> 00:47:48,359
much arrays it's not a map merge so it

00:47:47,069 --> 00:47:50,999
does something different

00:47:48,359 --> 00:47:53,909
don't use don't replace all your a

00:47:50,999 --> 00:47:57,380
remerge with the piece operator only do

00:47:53,909 --> 00:47:57,380
this if this is a map

00:47:57,770 --> 00:48:02,839
have you got any examples of memory

00:48:00,980 --> 00:48:06,580
saving you have if you use these

00:48:02,839 --> 00:48:11,390
techniques about memory usage yeah

00:48:06,580 --> 00:48:15,349
someone computed a project on github to

00:48:11,390 --> 00:48:17,510
to to have all the twelve the the

00:48:15,349 --> 00:48:21,170
memories usage and the speed usage of

00:48:17,510 --> 00:48:27,099
the different techniques I've introduced

00:48:21,170 --> 00:48:31,339
here so basically what you you win with

00:48:27,099 --> 00:48:33,920
SPL and some other structure is the old

00:48:31,339 --> 00:48:36,109
the buckets structure you have in the in

00:48:33,920 --> 00:48:41,000
the arrays that can be really optimized

00:48:36,109 --> 00:48:44,900
especially with as SPL fixed array this

00:48:41,000 --> 00:48:48,109
is but to have a measure it's a bit

00:48:44,900 --> 00:48:51,530
difficult try to I will try to have to

00:48:48,109 --> 00:48:54,440
do slides in the references the this

00:48:51,530 --> 00:48:56,570
github project you can run it with

00:48:54,440 --> 00:48:58,690
different PHP versions and which will

00:48:56,570 --> 00:49:03,170
gives you all the numbers about the

00:48:58,690 --> 00:49:11,320
memory usage and time consumption for

00:49:03,170 --> 00:49:11,320
all operations okay thanks everybody

00:49:22,309 --> 00:49:24,369

YouTube URL: https://www.youtube.com/watch?v=h6LOtN2RgEU


