Title: PHP UK Conference 2012 - PHP under the hood, by Johannes Schlüter
Publication date: 2012-03-22
Playlist: PHP UK Conference 2012
Description: 
	http://www.phpconference.co.uk/talk/php-under-hood

The beauty of PHP is that everybody can read the code and see the inner workings of software. But understanding concepts from reading code isn't often helpful, especially if you are not proficient in that language.

This presentation will take apart many parts of the PHP runtime, describe the concepts behind so attendees understand the inner workings without actually reading C code. Concepts covered include HashTables, the foundation for PHP arrays and many other internal data structures, the reference counting mechanism, which is important for writing efficient code as well as the overall executor.

 
Johannes Schlüter is involved with the PHP community for more than 10 years. As an active contributor to the PHP project he is serving as Release Manager for the PHP 5.3 series. Working on PHP is also part of his job at Oracle's MySQL Engineering team where he is an engineer in the MySQL Connectors and Client Connectivity group. He's blogs regularly and lives in Munich, Germany.
Captions: 
	00:00:07,160 --> 00:00:13,010
thank you so let's talk

00:00:10,220 --> 00:00:14,390
about PHP under the hood trying to

00:00:13,010 --> 00:00:16,090
explain

00:00:14,390 --> 00:00:19,090
things help

00:00:16,090 --> 00:00:23,020
he works what it's doing the idea to

00:00:19,090 --> 00:00:25,180
talk came from some IRC discussion we

00:00:23,020 --> 00:00:27,640
are some person asked a question which

00:00:25,180 --> 00:00:30,640
after you see ways to check for features

00:00:27,640 --> 00:00:33,280
faster is a faster to use extension

00:00:30,640 --> 00:00:37,090
loaded of function exists of course it's

00:00:33,280 --> 00:00:39,220
a stupid thing to do to decide that on

00:00:37,090 --> 00:00:40,540
performance or anything which one to

00:00:39,220 --> 00:00:42,760
choose since you're doing different

00:00:40,540 --> 00:00:44,860
things in the first thing you're really

00:00:42,760 --> 00:00:47,350
checking is the extension loaded can I

00:00:44,860 --> 00:00:49,180
use the extension can I draw some images

00:00:47,350 --> 00:00:51,010
and stuff whereas with the second one

00:00:49,180 --> 00:00:55,149
you're actually checking whether you can

00:00:51,010 --> 00:00:55,690
edit PNG files so you shouldn't use one

00:00:55,149 --> 00:00:59,800
or the other

00:00:55,690 --> 00:01:01,660
buta performance but you to the purpose

00:00:59,800 --> 00:01:03,579
you want to achieve but that made me

00:01:01,660 --> 00:01:05,860
start thinking about what can I tell

00:01:03,579 --> 00:01:08,259
about PHP how does it work

00:01:05,860 --> 00:01:11,229
so maybe people can figure out which one

00:01:08,259 --> 00:01:14,440
is faster I hope I get all my slides

00:01:11,229 --> 00:01:17,970
done in time and I can give you the true

00:01:14,440 --> 00:01:21,160
answer which one is faster but let's see

00:01:17,970 --> 00:01:23,440
Who am I that I'm going to through this

00:01:21,160 --> 00:01:26,380
talk I'm gonna Schluter I'm from Munich

00:01:23,440 --> 00:01:29,289
Germany so sorry for my accent I'm on

00:01:26,380 --> 00:01:32,340
Twitter PHP error at a time I'm working

00:01:29,289 --> 00:01:35,410
for the MySQL engineering team at Oracle

00:01:32,340 --> 00:01:38,619
focusing on PHP and MySQL

00:01:35,410 --> 00:01:41,110
interoperability and at night I'm

00:01:38,619 --> 00:01:43,240
involved in a PHP community doing the

00:01:41,110 --> 00:01:46,509
release management for the 5 3 C areas

00:01:43,240 --> 00:01:48,849
which I always explain something like if

00:01:46,509 --> 00:01:51,550
something is broken it's my fault if

00:01:48,849 --> 00:01:53,709
something greater than 5 3 I can tell

00:01:51,550 --> 00:01:58,690
you who committed it and you can praise

00:01:53,709 --> 00:02:02,259
them so I guess all of you know about a

00:01:58,690 --> 00:02:04,119
PHP lifecycle so PHP is either run as a

00:02:02,259 --> 00:02:06,940
module in the correct server or is

00:02:04,119 --> 00:02:10,319
running as fast CDI so at one moment you

00:02:06,940 --> 00:02:12,849
have to start up and then you have

00:02:10,319 --> 00:02:15,220
multiple requests coming in with a short

00:02:12,849 --> 00:02:17,800
startup and then the script running and

00:02:15,220 --> 00:02:20,280
then we clean up everything cleaning up

00:02:17,800 --> 00:02:24,310
I will talk about it in a moment again

00:02:20,280 --> 00:02:26,560
but basically creating a clean state

00:02:24,310 --> 00:02:28,450
again I'm a bit confused since usually I

00:02:26,560 --> 00:02:29,720
see my slides there but it doesn't work

00:02:28,450 --> 00:02:35,120
at the moment do you

00:02:29,720 --> 00:02:39,110
to all this open office crap that's why

00:02:35,120 --> 00:02:41,000
I always have to look at Ellen so one

00:02:39,110 --> 00:02:43,640
thing about the execution of a PHP

00:02:41,000 --> 00:02:46,640
script which I think most of you should

00:02:43,640 --> 00:02:50,030
know is that PHP is compiled into some

00:02:46,640 --> 00:02:53,030
binary form which we call op codes which

00:02:50,030 --> 00:02:55,250
represents the PHP code on a way lower

00:02:53,030 --> 00:02:57,560
level these op codes are generated on

00:02:55,250 --> 00:03:00,560
each script request and then thrown away

00:02:57,560 --> 00:03:03,740
and if you're using some bytecode cache

00:03:00,560 --> 00:03:06,380
like a PC the net stored in memory but

00:03:03,740 --> 00:03:08,570
from the pure PHP perspective it's a

00:03:06,380 --> 00:03:13,190
clean State on each and every request

00:03:08,570 --> 00:03:17,540
how does this opcode look if you know

00:03:13,190 --> 00:03:21,620
some assembly language or something you

00:03:17,540 --> 00:03:23,630
might have some you might remember it a

00:03:21,620 --> 00:03:25,610
little bit I don't want to go too much

00:03:23,630 --> 00:03:30,220
in detail there's another issue with

00:03:25,610 --> 00:03:34,850
these Open Office stuff now it works

00:03:30,220 --> 00:03:39,280
sorry for that I won't go too much into

00:03:34,850 --> 00:03:42,260
detail where this is a function call so

00:03:39,280 --> 00:03:44,120
this is the same on that level for the

00:03:42,260 --> 00:03:45,800
both examples that I've shown in the

00:03:44,120 --> 00:03:48,590
beginning that's the reason for the

00:03:45,800 --> 00:03:51,880
slide basically showing it would do the

00:03:48,590 --> 00:03:54,350
same thing independently if you do

00:03:51,880 --> 00:03:57,160
extension loaded or function exists it

00:03:54,350 --> 00:04:00,440
would do an init F call and send some

00:03:57,160 --> 00:04:03,049
variable to a internal stack which is

00:04:00,440 --> 00:04:07,130
done later be used when they call when

00:04:03,049 --> 00:04:09,830
the function is actually called these op

00:04:07,130 --> 00:04:12,049
codes then are being executed so I try

00:04:09,830 --> 00:04:14,330
to have very little C code this is an

00:04:12,049 --> 00:04:18,560
actual C code it's simply something like

00:04:14,330 --> 00:04:20,330
it so by default again a stupid an error

00:04:18,560 --> 00:04:22,820
if I do have to load it two times

00:04:20,330 --> 00:04:24,700
don't care I don't know so we have for

00:04:22,820 --> 00:04:27,320
all these up codes like the assign

00:04:24,700 --> 00:04:30,650
Handler and smaller handler some

00:04:27,320 --> 00:04:32,660
functions which do the operation related

00:04:30,650 --> 00:04:36,830
to this and then we have a long loop

00:04:32,660 --> 00:04:39,320
simply always calling this function now

00:04:36,830 --> 00:04:42,650
if you want to do you can do some

00:04:39,320 --> 00:04:43,400
optimizations in PHP by using some other

00:04:42,650 --> 00:04:46,160
execution

00:04:43,400 --> 00:04:49,669
method like you can compile PHP with

00:04:46,160 --> 00:04:51,919
sent VM type equals switch and then you

00:04:49,669 --> 00:04:54,229
get a large function which are large

00:04:51,919 --> 00:04:55,759
switch which has all I don't know how

00:04:54,229 --> 00:04:59,600
many up codes do we have at the moment

00:04:55,759 --> 00:05:01,940
300 or something a long long long

00:04:59,600 --> 00:05:03,530
function which breaks some compilers

00:05:01,940 --> 00:05:06,560
which doesn't work that's one of the

00:05:03,530 --> 00:05:07,910
reasons why we split it up or you can do

00:05:06,560 --> 00:05:09,770
another way which works with some

00:05:07,910 --> 00:05:13,370
compilers which is called computed go to

00:05:09,770 --> 00:05:16,039
that it's going using go to the pointer

00:05:13,370 --> 00:05:16,970
address and then doing that kind of

00:05:16,039 --> 00:05:19,669
stuff

00:05:16,970 --> 00:05:21,770
I guess you usually won't have to know

00:05:19,669 --> 00:05:24,380
it the important part there is it's

00:05:21,770 --> 00:05:26,570
compiled and some opcode and then being

00:05:24,380 --> 00:05:29,030
executed in some way it's not really

00:05:26,570 --> 00:05:31,340
compiled into machine language and then

00:05:29,030 --> 00:05:36,710
it's directly running on the CPU but in

00:05:31,340 --> 00:05:39,830
kind one of these forms then interesting

00:05:36,710 --> 00:05:42,500
things we are also using always includes

00:05:39,830 --> 00:05:46,490
require and the ones versions of these I

00:05:42,500 --> 00:05:47,780
guess everybody of Geonosis and does

00:05:46,490 --> 00:05:49,910
anybody know the difference between

00:05:47,780 --> 00:05:53,449
include and like why I I hope that was

00:05:49,910 --> 00:05:55,820
the case so include gives the warning if

00:05:53,449 --> 00:05:57,800
something fails and require gives a

00:05:55,820 --> 00:06:01,659
fatal error that's the only difference

00:05:57,800 --> 00:06:03,770
so whatever you choose there there's no

00:06:01,659 --> 00:06:06,889
difference besides that in the error

00:06:03,770 --> 00:06:09,349
case they include once and require ones

00:06:06,889 --> 00:06:12,820
are a bit more interesting and hope

00:06:09,349 --> 00:06:15,320
that's the next slide and it is so

00:06:12,820 --> 00:06:19,070
really really breaking it down what's

00:06:15,320 --> 00:06:20,690
happening on an include is the file is

00:06:19,070 --> 00:06:23,260
being opened and compiling these up

00:06:20,690 --> 00:06:25,669
codes and then directly being executed

00:06:23,260 --> 00:06:29,330
whereas when you're doing include once

00:06:25,669 --> 00:06:31,550
we have to do a few more things we have

00:06:29,330 --> 00:06:34,099
to first we have to make sure that we

00:06:31,550 --> 00:06:36,650
have to complete real parts of the fire

00:06:34,099 --> 00:06:39,050
name so we can eat whether the file has

00:06:36,650 --> 00:06:42,289
been included before which is then the

00:06:39,050 --> 00:06:45,470
second step then we open the file and if

00:06:42,289 --> 00:06:47,210
that works we know ok we have this file

00:06:45,470 --> 00:06:49,520
included in the past and on the next

00:06:47,210 --> 00:06:51,620
request we won't have to or next include

00:06:49,520 --> 00:06:54,620
one so require once called wouldn't have

00:06:51,620 --> 00:06:56,580
to do this and then finally it's being

00:06:54,620 --> 00:07:00,110
compiled and executed

00:06:56,580 --> 00:07:03,210
so you can see that the once versions I

00:07:00,110 --> 00:07:05,490
notably have some more stuff to do

00:07:03,210 --> 00:07:07,949
especially those resolving of the pass

00:07:05,490 --> 00:07:10,110
can take some time if you have a nested

00:07:07,949 --> 00:07:12,500
structure with symlinks and all that

00:07:10,110 --> 00:07:12,500
kind of stuff

00:07:13,219 --> 00:07:19,319
next thing we're having in PHP are Rara

00:07:16,349 --> 00:07:21,930
Avis again a short Chris for everybody

00:07:19,319 --> 00:07:29,009
it's a large audience but how many data

00:07:21,930 --> 00:07:33,330
types do we have in PHP nine and ten how

00:07:29,009 --> 00:07:35,520
much so we have null Ian integer float

00:07:33,330 --> 00:07:37,310
string array object resource one two

00:07:35,520 --> 00:07:43,050
three four five six seven eight

00:07:37,310 --> 00:07:44,849
different types types which are often

00:07:43,050 --> 00:07:48,120
forgetting our resources or null that

00:07:44,849 --> 00:07:50,969
null is a value and a type and PHP since

00:07:48,120 --> 00:07:54,650
usually you don't have to care too much

00:07:50,969 --> 00:07:54,650
about types it's a trick question

00:07:55,099 --> 00:08:00,090
there's no type so the question there

00:07:57,599 --> 00:08:02,699
was whether it's callable which we offer

00:08:00,090 --> 00:08:07,740
as a type int as a specific type but

00:08:02,699 --> 00:08:10,139
formerly it's only in the place where

00:08:07,740 --> 00:08:12,690
the is callable is implemented in a

00:08:10,139 --> 00:08:14,550
function calling area there are some

00:08:12,690 --> 00:08:17,430
special handling but for for the

00:08:14,550 --> 00:08:19,319
variable itself the variable itself

00:08:17,430 --> 00:08:21,719
doesn't carry the information whether

00:08:19,319 --> 00:08:24,900
something is callable or not that's

00:08:21,719 --> 00:08:28,860
something which can be defined from

00:08:24,900 --> 00:08:31,080
reading it out looking into it for

00:08:28,860 --> 00:08:33,449
instance if it's a string image create

00:08:31,080 --> 00:08:37,699
from PNG it's a string it's not a

00:08:33,449 --> 00:08:37,699
callable type it's a string type

00:08:46,840 --> 00:08:53,670
okay you can come on stage we have a

00:08:51,370 --> 00:09:00,820
microphone if you want to complain that

00:08:53,670 --> 00:09:04,839
that's fine okay one one thing we are

00:09:00,820 --> 00:09:07,210
doing in PHP is we we optimizing for you

00:09:04,839 --> 00:09:09,400
that you don't that we that you don't

00:09:07,210 --> 00:09:12,580
waste too much memory in different cases

00:09:09,400 --> 00:09:20,080
so what we are expecting in a case like

00:09:12,580 --> 00:09:23,020
this is some stage so we're having the

00:09:20,080 --> 00:09:24,970
function call and inside the function

00:09:23,020 --> 00:09:28,060
you expect that you have a copy of the

00:09:24,970 --> 00:09:29,950
variable and if you do an assignment you

00:09:28,060 --> 00:09:32,860
usually expect to have a copy of the

00:09:29,950 --> 00:09:37,150
variable and a copy usually takes some

00:09:32,860 --> 00:09:39,790
time and some space no time and then

00:09:37,150 --> 00:09:42,310
there's some change and all these things

00:09:39,790 --> 00:09:45,100
have to do with copies of variables

00:09:42,310 --> 00:09:47,410
where on the other side has a feature

00:09:45,100 --> 00:09:50,020
called references where our references

00:09:47,410 --> 00:09:51,850
are aliases to a variable so doing the

00:09:50,020 --> 00:09:54,580
same things with revery ables

00:09:51,850 --> 00:09:58,110
that should all work on this big eraser

00:09:54,580 --> 00:10:01,180
all this change happening happening here

00:09:58,110 --> 00:10:04,360
are shown in big array in the end and

00:10:01,180 --> 00:10:06,160
show up there I hope that's basically

00:10:04,360 --> 00:10:09,940
known to everybody what references and

00:10:06,160 --> 00:10:12,010
copies well now when now we have an

00:10:09,940 --> 00:10:14,320
optimization in PHP that is

00:10:12,010 --> 00:10:17,260
copy-on-write so we don't actually copy

00:10:14,320 --> 00:10:19,660
all the data all the time but we copy it

00:10:17,260 --> 00:10:21,910
only if it's required to have a copy of

00:10:19,660 --> 00:10:27,450
the data so I'm going through a simple

00:10:21,910 --> 00:10:31,000
example here a variable inside PHP is

00:10:27,450 --> 00:10:33,040
represented by a set valve which is the

00:10:31,000 --> 00:10:36,280
internal data structure used for this

00:10:33,040 --> 00:10:38,290
and then there is some name attached to

00:10:36,280 --> 00:10:42,400
it which is stored in some way and

00:10:38,290 --> 00:10:44,740
pointing to these set words and I'm

00:10:42,400 --> 00:10:48,040
having some different variables so I

00:10:44,740 --> 00:10:52,150
drew some what sort of different things

00:10:48,040 --> 00:10:53,920
here since you're doing copy-on-write we

00:10:52,150 --> 00:10:57,430
have to do some reference counting to

00:10:53,920 --> 00:10:59,589
know how many variables like dollar big

00:10:57,430 --> 00:11:00,640
array dollar copy one are currently

00:10:59,589 --> 00:11:03,100
pointing to this

00:11:00,640 --> 00:11:06,269
so we have a ref count reference

00:11:03,100 --> 00:11:09,670
counting field and for handling

00:11:06,269 --> 00:11:12,430
references we have a flag whether these

00:11:09,670 --> 00:11:15,790
are references or copies so what happens

00:11:12,430 --> 00:11:17,920
in this case here we start by an

00:11:15,790 --> 00:11:20,800
assignment of dollar big array with some

00:11:17,920 --> 00:11:25,420
large large large large large amount of

00:11:20,800 --> 00:11:28,089
data and after that we will have one

00:11:25,420 --> 00:11:31,620
variable in memory with a reference

00:11:28,089 --> 00:11:34,810
count of 1 and we then do an assignment

00:11:31,620 --> 00:11:38,050
we don't actually copy it over to a

00:11:34,810 --> 00:11:40,660
second variable in memory but we simply

00:11:38,050 --> 00:11:43,329
increase the counter knowing okay now we

00:11:40,660 --> 00:11:47,230
have two variables pointing to the

00:11:43,329 --> 00:11:50,950
Status structure and don't waste time

00:11:47,230 --> 00:11:55,329
copying it if we do it again same thing

00:11:50,950 --> 00:11:58,930
happens and ref count increases so no

00:11:55,329 --> 00:12:02,050
meditational memory used but simple

00:11:58,930 --> 00:12:04,990
reuse of the memory now if we changed

00:12:02,050 --> 00:12:08,050
one of the copies then we detect OD as a

00:12:04,990 --> 00:12:10,720
change and then we create a copy of the

00:12:08,050 --> 00:12:14,019
data of this array in this case and

00:12:10,720 --> 00:12:17,980
create a new set well lower the

00:12:14,019 --> 00:12:20,649
reference count of the others so copy

00:12:17,980 --> 00:12:24,760
one and big array are still stored here

00:12:20,649 --> 00:12:27,190
now having a ref count of two and copy

00:12:24,760 --> 00:12:29,500
exists with a ref count of one since

00:12:27,190 --> 00:12:33,100
taller copy two is the only one pointing

00:12:29,500 --> 00:12:35,709
to this memory area when we are now

00:12:33,100 --> 00:12:41,380
doing references the RS missing I'm

00:12:35,709 --> 00:12:43,690
sorry again we're doing basically the

00:12:41,380 --> 00:12:46,510
same thing here I'm calling a function

00:12:43,690 --> 00:12:49,540
which takes a reference and so let's

00:12:46,510 --> 00:12:52,360
look into it I have my ref count of 1

00:12:49,540 --> 00:12:54,490
after doing the initial assignment then

00:12:52,360 --> 00:12:56,560
I do the function call here the

00:12:54,490 --> 00:12:59,529
difference is that I'm setting the East

00:12:56,560 --> 00:13:02,140
red flag to 1 since we want a reference

00:12:59,529 --> 00:13:05,110
inside if inside the function and

00:13:02,140 --> 00:13:08,199
increase the ref count to 2 and then I'm

00:13:05,110 --> 00:13:11,170
doing something inside PHP since all

00:13:08,199 --> 00:13:14,930
basically all functions in PHP are

00:13:11,170 --> 00:13:17,330
created in a way to know about this ref

00:13:14,930 --> 00:13:19,160
in scouting and optimized in a way to

00:13:17,330 --> 00:13:23,240
work with reference counting very well

00:13:19,160 --> 00:13:25,580
so basically all functions in PHP expect

00:13:23,240 --> 00:13:29,029
a copy of the data and now we're having

00:13:25,580 --> 00:13:33,350
this is reflect set and if we're now

00:13:29,029 --> 00:13:36,050
creating a copy of it we have to

00:13:33,350 --> 00:13:37,399
actually make it copy since we have some

00:13:36,050 --> 00:13:39,200
references to it and we can't

00:13:37,399 --> 00:13:42,760
distinguish which should be the copy and

00:13:39,200 --> 00:13:42,760
which should be the reference yes deric

00:13:44,320 --> 00:13:47,649
dollar data

00:13:55,180 --> 00:14:01,820
okay right right right

00:13:58,630 --> 00:14:02,540
thanks Derek so it's it's really but

00:14:01,820 --> 00:14:05,779
that's the detail

00:14:02,540 --> 00:14:07,910
oh I simply find it I simply find it to

00:14:05,779 --> 00:14:11,660
make it better explainable to ignore it

00:14:07,910 --> 00:14:14,060
okay you should so be careful about all

00:14:11,660 --> 00:14:15,950
the slides better check it in it Baga if

00:14:14,060 --> 00:14:21,890
you want to have the truth only

00:14:15,950 --> 00:14:25,760
simplification okay so by introducing

00:14:21,890 --> 00:14:28,430
this reference which some people do for

00:14:25,760 --> 00:14:31,279
purposes of doing up an optimization of

00:14:28,430 --> 00:14:35,390
the code oh I don't need a copy I do a

00:14:31,279 --> 00:14:38,720
reference what usually happens is that

00:14:35,390 --> 00:14:43,250
you create additional copies which hurts

00:14:38,720 --> 00:14:46,130
your performance so it's good not to try

00:14:43,250 --> 00:14:48,980
and not trying to be smart and and PHP s

00:14:46,130 --> 00:14:51,740
but simply do the assignment if you want

00:14:48,980 --> 00:14:56,000
to have an assignment do a copy if you

00:14:51,740 --> 00:14:58,850
want a copy and PHP will figure it out

00:14:56,000 --> 00:15:04,040
in at least most of the cases what's

00:14:58,850 --> 00:15:07,550
really to do so just to people again

00:15:04,040 --> 00:15:09,829
reference a certain performance there

00:15:07,550 --> 00:15:13,520
are even some funny things

00:15:09,829 --> 00:15:19,940
anybody can knows the output of this PHP

00:15:13,520 --> 00:15:23,329
script so I'm iterating two times over

00:15:19,940 --> 00:15:28,790
an array and a taller and no it's

00:15:23,329 --> 00:15:31,430
working so oh one two three iterating

00:15:28,790 --> 00:15:36,620
two times and then printing it obviously

00:15:31,430 --> 00:15:40,850
the prints oh one two two absolutely

00:15:36,620 --> 00:15:46,340
clear what happens for those who don't

00:15:40,850 --> 00:15:48,710
see it one or two maybe an audience so

00:15:46,340 --> 00:15:52,010
we are iterating here and saying okay

00:15:48,710 --> 00:15:55,420
the dollar item should always be in

00:15:52,010 --> 00:15:58,940
reference to the current element in the

00:15:55,420 --> 00:16:03,200
in the loop on each step of the

00:15:58,940 --> 00:16:06,200
iteration so on the first step we create

00:16:03,200 --> 00:16:09,080
an we create dollar item and being that

00:16:06,200 --> 00:16:10,940
a reference to the first element in the

00:16:09,080 --> 00:16:16,430
air in the array which were iterating

00:16:10,940 --> 00:16:20,150
over then we are continuing iteration so

00:16:16,430 --> 00:16:25,390
dollar item becomes a reference to that

00:16:20,150 --> 00:16:27,680
element and then we iterate again and

00:16:25,390 --> 00:16:30,680
dollar item becomes a reference to that

00:16:27,680 --> 00:16:34,460
and then it becomes an reference to the

00:16:30,680 --> 00:16:38,470
last element of the array after the

00:16:34,460 --> 00:16:42,320
first iteration finished we are having

00:16:38,470 --> 00:16:44,750
dollar item still available PHP doesn't

00:16:42,320 --> 00:16:48,050
have a local scoping but we have

00:16:44,750 --> 00:16:50,990
function level scoping so dollar item is

00:16:48,050 --> 00:16:53,840
valid all over the complete function and

00:16:50,990 --> 00:16:58,400
this is in or complete file or whatever

00:16:53,840 --> 00:17:00,830
and on a next iteration on the second

00:16:58,400 --> 00:17:03,710
case of this for each dollar item here

00:17:00,830 --> 00:17:08,900
is still a reference to the last element

00:17:03,710 --> 00:17:13,010
in this array there so for each

00:17:08,900 --> 00:17:14,810
iteration there the current element from

00:17:13,010 --> 00:17:17,030
the second iteration will be written

00:17:14,810 --> 00:17:20,510
into dollar item which is a reference to

00:17:17,030 --> 00:17:24,950
this so after the first step the error

00:17:20,510 --> 00:17:28,250
will be 0 1 2 0 since it's the reference

00:17:24,950 --> 00:17:32,870
they're pointing to each other and on

00:17:28,250 --> 00:17:36,320
our next step it's 0 1 2 1 and on the

00:17:32,870 --> 00:17:39,080
next step it's 0 1 2 2 and then it's

00:17:36,320 --> 00:17:41,060
over writing itself by pointing to

00:17:39,080 --> 00:17:42,250
itself and keeping the two at the last

00:17:41,060 --> 00:17:47,240
element

00:17:42,250 --> 00:17:49,820
now in some way a thought okay that's a

00:17:47,240 --> 00:17:52,090
theoretical problem but actually there

00:17:49,820 --> 00:17:54,710
are bug reports about this behavior

00:17:52,090 --> 00:17:57,410
there are people really doing this kind

00:17:54,710 --> 00:17:59,540
of iteration alternating two times over

00:17:57,410 --> 00:18:02,210
the same thing or using references on

00:17:59,540 --> 00:18:05,810
the same radiator and then they want us

00:18:02,210 --> 00:18:09,070
to to unset it very able to not make it

00:18:05,810 --> 00:18:12,620
a reference outside of this iteration

00:18:09,070 --> 00:18:15,500
but as PHP doesn't have to scoping that

00:18:12,620 --> 00:18:18,380
tight but having the scoping bound to

00:18:15,500 --> 00:18:22,400
the current function so always exist in

00:18:18,380 --> 00:18:25,460
a complete function we can't properly do

00:18:22,400 --> 00:18:30,500
it since era sometimes cases value for

00:18:25,460 --> 00:18:35,090
instance break an iteration at some

00:18:30,500 --> 00:18:38,150
termination decision so you decide ok if

00:18:35,090 --> 00:18:41,360
this and this is the case then I do a

00:18:38,150 --> 00:18:43,340
break and after the iteration you want

00:18:41,360 --> 00:18:45,710
to have two access to the last element

00:18:43,340 --> 00:18:48,470
here working on for instance if you have

00:18:45,710 --> 00:18:49,820
some searching algorithm going through

00:18:48,470 --> 00:18:52,190
an array you search for a specific

00:18:49,820 --> 00:18:54,950
element and after you found it

00:18:52,190 --> 00:18:58,880
you want to do something with it then

00:18:54,950 --> 00:19:01,060
you still have to be have you still need

00:18:58,880 --> 00:19:03,590
a way to reference that current element

00:19:01,060 --> 00:19:08,390
therefore we can't unset it in any way

00:19:03,590 --> 00:19:10,880
and have to live with it so in my

00:19:08,390 --> 00:19:13,700
opinion and there's a second issue with

00:19:10,880 --> 00:19:17,150
references that in some way they create

00:19:13,700 --> 00:19:19,460
an API which isn't that intuitive so if

00:19:17,150 --> 00:19:23,030
you look at this function call for

00:19:19,460 --> 00:19:25,880
built-in function of PHP you might not

00:19:23,030 --> 00:19:27,620
be aware when firstly reading it that

00:19:25,880 --> 00:19:31,520
it's actually changing the parameter

00:19:27,620 --> 00:19:34,670
you're passing to it and what might be

00:19:31,520 --> 00:19:39,500
nice is if it would be returned instead

00:19:34,670 --> 00:19:42,200
of being and returned as a return value

00:19:39,500 --> 00:19:46,460
instead of being returned as a reference

00:19:42,200 --> 00:19:48,920
value might make the user interface the

00:19:46,460 --> 00:19:50,990
user reading the code way simpler to

00:19:48,920 --> 00:19:54,980
know okay it's in parameter nothing is

00:19:50,990 --> 00:19:55,490
going to happen and there's a result for

00:19:54,980 --> 00:19:57,410
this there

00:19:55,490 --> 00:19:59,900
a few exceptions vendors can't be done

00:19:57,410 --> 00:20:02,090
and where some benefits there are but

00:19:59,900 --> 00:20:04,370
usually I think it's better to have such

00:20:02,090 --> 00:20:07,850
an API and not use references for

00:20:04,370 --> 00:20:10,700
returning values so another reason why I

00:20:07,850 --> 00:20:16,910
think that references are bad to do in

00:20:10,700 --> 00:20:20,179
PHP so that's my biggest claim don't use

00:20:16,910 --> 00:20:23,360
references and PHP small parent easels

00:20:20,179 --> 00:20:26,150
until you really know that you need them

00:20:23,360 --> 00:20:30,650
since there are there now people come

00:20:26,150 --> 00:20:32,990
and tell me oh wait I I was careful when

00:20:30,650 --> 00:20:36,800
PHP 5 came out and a big change there

00:20:32,990 --> 00:20:39,200
was that objects aren't copied over when

00:20:36,800 --> 00:20:42,410
a function is being called but our

00:20:39,200 --> 00:20:45,500
references well no they aren't

00:20:42,410 --> 00:20:47,480
references and that sounds what happens

00:20:45,500 --> 00:20:52,280
if you pass an object to a function is

00:20:47,480 --> 00:20:56,660
that the set while the internal variable

00:20:52,280 --> 00:20:59,330
is not I'm holding the object itself but

00:20:56,660 --> 00:21:01,820
it's only carrying a handle to the

00:20:59,330 --> 00:21:04,309
actual of an object which is then stored

00:21:01,820 --> 00:21:07,190
in some object storage differently from

00:21:04,309 --> 00:21:09,740
the actual variable in fact there is

00:21:07,190 --> 00:21:12,080
that when this handle is being copied

00:21:09,740 --> 00:21:14,780
you're still working on the same object

00:21:12,080 --> 00:21:17,510
in the end so let's look at this what

00:21:14,780 --> 00:21:20,809
this actually means I have a function

00:21:17,510 --> 00:21:24,220
foo which takes a reference and then I

00:21:20,809 --> 00:21:28,460
assigned a variable inside the function

00:21:24,220 --> 00:21:33,620
and change it from being what is at what

00:21:28,460 --> 00:21:35,660
is passed to being null and I am execute

00:21:33,620 --> 00:21:38,960
this small script and they get null

00:21:35,660 --> 00:21:41,150
since a reference is an alias so if I do

00:21:38,960 --> 00:21:44,900
anything in here it has an effect on the

00:21:41,150 --> 00:21:48,260
outside when I do the same thing with an

00:21:44,900 --> 00:21:51,290
object so I'm passing a new standard

00:21:48,260 --> 00:21:53,750
class passing that as a parameter trying

00:21:51,290 --> 00:21:57,140
in the inside doesn't have an effect on

00:21:53,750 --> 00:22:00,230
the outside since the raven is different

00:21:57,140 --> 00:22:05,900
even though if the even though that the

00:22:00,230 --> 00:22:08,110
object itself is the same to explain

00:22:05,900 --> 00:22:08,110
this

00:22:08,490 --> 00:22:14,309
I have this example here which is

00:22:12,050 --> 00:22:17,429
another case where I'm having an array

00:22:14,309 --> 00:22:20,010
passing it as a copy making and change

00:22:17,429 --> 00:22:22,320
to the array and that doesn't show in

00:22:20,010 --> 00:22:25,920
the outside whereas mint doing the same

00:22:22,320 --> 00:22:30,450
was an object having passing an object

00:22:25,920 --> 00:22:32,610
and changing inside a function it shows

00:22:30,450 --> 00:22:35,280
on the outside so here's the print R and

00:22:32,610 --> 00:22:37,559
a dollar foo exists since we are copying

00:22:35,280 --> 00:22:42,570
the hand still pointing to the same

00:22:37,559 --> 00:22:53,070
element in the am still pointing to the

00:22:42,570 --> 00:22:55,700
same object that's the right term second

00:22:53,070 --> 00:22:55,700
please okay

00:22:58,880 --> 00:23:07,530
so another important part is memory

00:23:02,400 --> 00:23:10,170
management in general so most of the PHP

00:23:07,530 --> 00:23:12,600
memory management is focused on the case

00:23:10,170 --> 00:23:16,200
that we are in a web space and in a

00:23:12,600 --> 00:23:18,540
typical PHP script is running way less

00:23:16,200 --> 00:23:21,390
than a second if a PHP script is running

00:23:18,540 --> 00:23:25,830
longer than a second in most cases

00:23:21,390 --> 00:23:29,400
there's something wrong so the reference

00:23:25,830 --> 00:23:34,470
counting mechanism is a good way to keep

00:23:29,400 --> 00:23:36,179
the variable memory intact and then we

00:23:34,470 --> 00:23:38,160
have another mechanism as that at the

00:23:36,179 --> 00:23:40,500
end of the request we basically throw

00:23:38,160 --> 00:23:44,280
everything away every allocated memory

00:23:40,500 --> 00:23:47,160
which isn't freed in some sane way will

00:23:44,280 --> 00:23:50,580
be freed by force and so we have a clean

00:23:47,160 --> 00:23:53,370
state at the end of the script run now

00:23:50,580 --> 00:23:57,420
there's one issue there which are cyclic

00:23:53,370 --> 00:23:59,309
references so here I'm having two

00:23:57,420 --> 00:24:01,920
objects in this case which are pointing

00:23:59,309 --> 00:24:04,290
to each other when I'm now unsetting

00:24:01,920 --> 00:24:06,960
those the reference count there will

00:24:04,290 --> 00:24:09,870
still be one and there will only be

00:24:06,960 --> 00:24:14,540
deleted from memory once the reference

00:24:09,870 --> 00:24:18,360
count reaches zero this was an issue

00:24:14,540 --> 00:24:21,120
within PHP five two and all below since

00:24:18,360 --> 00:24:22,260
we really relied on the reference

00:24:21,120 --> 00:24:24,419
counting mechanism

00:24:22,260 --> 00:24:28,890
and everything else was thrown away at

00:24:24,419 --> 00:24:32,970
the end of jetty quest with PHP 5-3 no I

00:24:28,890 --> 00:24:35,130
don't have it on the slide we introduced

00:24:32,970 --> 00:24:37,440
a garbage collection mechanism which

00:24:35,130 --> 00:24:40,140
will from time to time go through the

00:24:37,440 --> 00:24:42,330
PHP script and figure out looking for

00:24:40,140 --> 00:24:44,669
all these kind of cyclic references

00:24:42,330 --> 00:24:47,190
where one object is pointing to the

00:24:44,669 --> 00:24:49,140
other and nothing from the outside is

00:24:47,190 --> 00:24:50,760
pointing to it there might even be

00:24:49,140 --> 00:24:53,010
complex or structures like it might have

00:24:50,760 --> 00:24:56,600
three objects for objects pointing to

00:24:53,010 --> 00:24:59,700
each other and with PHP five three

00:24:56,600 --> 00:25:04,470
that's one of the things bare

00:24:59,700 --> 00:25:10,260
object-oriented code oftentimes got real

00:25:04,470 --> 00:25:11,970
real real performance benefits this

00:25:10,260 --> 00:25:17,510
brought an improvement I forgot the

00:25:11,970 --> 00:25:20,549
beginning of my sentence then there's

00:25:17,510 --> 00:25:22,799
with this cleanup in descriptive Renick

00:25:20,549 --> 00:25:25,350
it is script and there's another issue

00:25:22,799 --> 00:25:29,130
which is a kind of a hand and an egg

00:25:25,350 --> 00:25:31,140
problem meaning what should be shut down

00:25:29,130 --> 00:25:33,480
first should be shut down first the

00:25:31,140 --> 00:25:35,970
session handler which is depending on an

00:25:33,480 --> 00:25:39,150
object and writing a file to a file

00:25:35,970 --> 00:25:41,510
stream or should we first delete a file

00:25:39,150 --> 00:25:44,730
stream which is referencing an object

00:25:41,510 --> 00:25:47,580
which implements the stream and which

00:25:44,730 --> 00:25:52,440
order should we take there over at a

00:25:47,580 --> 00:25:54,240
time there are some small changes and

00:25:52,440 --> 00:25:56,990
all of them always got a problem and

00:25:54,240 --> 00:26:02,549
that's basically the order via currently

00:25:56,990 --> 00:26:05,010
with an S having in the system so we

00:26:02,549 --> 00:26:07,860
call it shut down functions so you can

00:26:05,010 --> 00:26:09,990
do register shutdown function and define

00:26:07,860 --> 00:26:13,020
a callback those will be executed first

00:26:09,990 --> 00:26:17,520
then we call all the destructors flush

00:26:13,020 --> 00:26:21,320
output buffers send HTTP headers shut

00:26:17,520 --> 00:26:25,080
down the extensions this triggers the

00:26:21,320 --> 00:26:28,200
session handling code for instance to

00:26:25,080 --> 00:26:31,890
finalize the session handling destroy

00:26:28,200 --> 00:26:34,230
superglobals and then delete everything

00:26:31,890 --> 00:26:36,260
which is remaining there are some issues

00:26:34,230 --> 00:26:39,030
sometimes with this order

00:26:36,260 --> 00:26:41,130
but we're not going to change the order

00:26:39,030 --> 00:26:43,020
until there's a really really really

00:26:41,130 --> 00:26:45,750
good way to do it

00:26:43,020 --> 00:26:49,460
certain every change there causes are

00:26:45,750 --> 00:26:52,980
another issue and the current one works

00:26:49,460 --> 00:26:57,030
for at least 99% of the cases even more

00:26:52,980 --> 00:27:01,130
I guess now let's get back to the

00:26:57,030 --> 00:27:05,970
beginning of this talk which is faster

00:27:01,130 --> 00:27:10,140
extension loaded or function exists so

00:27:05,970 --> 00:27:13,140
who says extension loaded is faster who

00:27:10,140 --> 00:27:17,610
said function exists as faster who says

00:27:13,140 --> 00:27:20,400
it's the same nobody saying the same

00:27:17,610 --> 00:27:24,330
interesting okay let's look at the

00:27:20,400 --> 00:27:29,370
implementation just to have some C code

00:27:24,330 --> 00:27:31,320
in a in the slide this is the

00:27:29,370 --> 00:27:33,660
implementation of the extend extension

00:27:31,320 --> 00:27:36,570
loaded function and we're having some

00:27:33,660 --> 00:27:39,630
variable declarations we're getting m1

00:27:36,570 --> 00:27:42,870
parameter which was passed from the user

00:27:39,630 --> 00:27:45,990
of this function then we create a copy

00:27:42,870 --> 00:27:48,870
which is lower case since the extension

00:27:45,990 --> 00:27:53,940
name is compared only lower case you

00:27:48,870 --> 00:27:55,860
can't have MySQL extension with capital

00:27:53,940 --> 00:27:58,650
Amanda - curl extension with a lowercase

00:27:55,860 --> 00:28:00,390
M but you can only have one of those so

00:27:58,650 --> 00:28:03,210
we have to lowercase it to compare it

00:28:00,390 --> 00:28:07,740
and then we look up in a hash table

00:28:03,210 --> 00:28:10,710
whether it exists or not okay that's the

00:28:07,740 --> 00:28:14,310
implementation then that's

00:28:10,710 --> 00:28:16,860
implementation of function exists there

00:28:14,310 --> 00:28:19,320
we have to do a bit more stuff too small

00:28:16,860 --> 00:28:23,330
written stuff is the same stuff as like

00:28:19,320 --> 00:28:27,600
in extension exists but we have to do

00:28:23,330 --> 00:28:30,780
two more things one is if we are in PHP

00:28:27,600 --> 00:28:33,450
five three or up we have namespaces so

00:28:30,780 --> 00:28:35,820
people might paste the name starting

00:28:33,450 --> 00:28:38,190
with a backslash but the backslash is

00:28:35,820 --> 00:28:40,440
not stored in our function table so we

00:28:38,190 --> 00:28:43,980
have to get rid of it that they're very

00:28:40,440 --> 00:28:46,890
very very very little cause extra cost

00:28:43,980 --> 00:28:49,799
we have in this execution which you

00:28:46,890 --> 00:28:52,049
barely can measure at all depending

00:28:49,799 --> 00:28:55,200
on your CPU you even can't measure it

00:28:52,049 --> 00:29:00,690
and then there's one thing we're having

00:28:55,200 --> 00:29:04,379
in PHP which is the disabled functions

00:29:00,690 --> 00:29:08,269
setting in the php.ini file and there's

00:29:04,379 --> 00:29:10,769
a second check we have to do to see

00:29:08,269 --> 00:29:13,700
whether the function is disabled or not

00:29:10,769 --> 00:29:17,940
to return a correct value

00:29:13,700 --> 00:29:22,139
now from this we might say okay this one

00:29:17,940 --> 00:29:24,539
is the slower one but we have one black

00:29:22,139 --> 00:29:29,489
box in here which is the sent hash find

00:29:24,539 --> 00:29:32,220
function and centage find goes to a hash

00:29:29,489 --> 00:29:36,690
table some hash tables the primary

00:29:32,220 --> 00:29:39,419
primary data structure we are using in

00:29:36,690 --> 00:29:42,059
PHP basically so everything in PHP is

00:29:39,419 --> 00:29:44,639
stored in a hash table the object

00:29:42,059 --> 00:29:49,379
storage is a hash table the array arrays

00:29:44,639 --> 00:29:53,009
are in fact on arrays part s hashes the

00:29:49,379 --> 00:29:56,159
function list is a hash table the class

00:29:53,009 --> 00:29:58,919
list as a hash table and what else there

00:29:56,159 --> 00:30:02,809
isn't PHP it's always a hash table well

00:29:58,919 --> 00:30:08,480
not always but ya know what I mean

00:30:02,809 --> 00:30:11,749
and how do hash tables work well I

00:30:08,480 --> 00:30:11,749
wanted an age

00:30:13,860 --> 00:30:21,340
okay so what we are having is we are

00:30:18,039 --> 00:30:26,169
having an Asian structure we're having a

00:30:21,340 --> 00:30:28,980
key which can be any string and then we

00:30:26,169 --> 00:30:31,059
want to reference some data to it

00:30:28,980 --> 00:30:33,610
now when we are looking at the Machine

00:30:31,059 --> 00:30:36,340
level of our system we have our memory

00:30:33,610 --> 00:30:38,260
area where we can have the addresses so

00:30:36,340 --> 00:30:40,330
we can have a simple array basically as

00:30:38,260 --> 00:30:42,039
a data structure where we can count okay

00:30:40,330 --> 00:30:45,070
I want the first element or I want

00:30:42,039 --> 00:30:47,289
attends element or want a 25th element

00:30:45,070 --> 00:30:50,740
or whatever I need such an data

00:30:47,289 --> 00:30:53,919
structure where I can simply jump to the

00:30:50,740 --> 00:30:55,419
correct address now I can take a hash

00:30:53,919 --> 00:30:59,530
function hash function as a function

00:30:55,419 --> 00:31:01,720
creating a numeric representation of any

00:30:59,530 --> 00:31:05,230
string you're giving it so something

00:31:01,720 --> 00:31:07,900
like md5 is a quite expensive hash

00:31:05,230 --> 00:31:10,120
function even if you're seeing some

00:31:07,900 --> 00:31:17,080
letters in your result that's just

00:31:10,120 --> 00:31:20,159
because you're having 16 bit extra

00:31:17,080 --> 00:31:23,799
decimal representation of the data and

00:31:20,159 --> 00:31:26,470
not a numeric value the md5 could also

00:31:23,799 --> 00:31:29,080
be represented as a large and to make

00:31:26,470 --> 00:31:32,080
numeric value and basically that's what

00:31:29,080 --> 00:31:38,220
we're doing with the hash function we're

00:31:32,080 --> 00:31:41,049
using the what is this DJ DJ XD JB 33

00:31:38,220 --> 00:31:45,280
hash mechanism which is a relatively

00:31:41,049 --> 00:31:48,490
relatively fast hashing function which

00:31:45,280 --> 00:31:51,460
works quite well giving not too many

00:31:48,490 --> 00:31:53,320
conflicts it's not crypto safe like mu

00:31:51,460 --> 00:31:55,900
Phi is not like some of these char

00:31:53,320 --> 00:32:00,669
hashes it's not crypto safe like those

00:31:55,900 --> 00:32:03,640
but it's hopefully good enough talking

00:32:00,669 --> 00:32:08,250
about it in a second and we are getting

00:32:03,640 --> 00:32:10,990
a number in this case the value foo bar

00:32:08,250 --> 00:32:15,730
is being translated to lead to this

00:32:10,990 --> 00:32:18,880
number which I won't read out now if I

00:32:15,730 --> 00:32:21,549
want to now I could use this number as

00:32:18,880 --> 00:32:24,460
an address in my memory which would mean

00:32:21,549 --> 00:32:26,559
I would need to have a memory area which

00:32:24,460 --> 00:32:29,950
could fit that

00:32:26,559 --> 00:32:33,190
amount of values inside my memory area

00:32:29,950 --> 00:32:36,129
which is a bit much since I have to pre

00:32:33,190 --> 00:32:38,379
allocate space for all these elements so

00:32:36,129 --> 00:32:40,929
what I'm actually doing is I'm reducing

00:32:38,379 --> 00:32:44,169
it throwing away the first few bits of

00:32:40,929 --> 00:32:46,809
this value and just apply a table mask

00:32:44,169 --> 00:32:49,539
and get a smaller value if you want to

00:32:46,809 --> 00:32:53,499
know what's working here I have the

00:32:49,539 --> 00:32:56,379
binary mass there so the table mask as

00:32:53,499 --> 00:32:58,779
well you where all the pits are set Tama

00:32:56,379 --> 00:33:03,220
masks usually it's a where you roughly a

00:32:58,779 --> 00:33:04,690
bit higher than the amount of elements

00:33:03,220 --> 00:33:07,590
you're having in your array or in your

00:33:04,690 --> 00:33:11,169
hash table then this is the binary

00:33:07,590 --> 00:33:13,779
representation of this value and if you

00:33:11,169 --> 00:33:16,240
do in binary and operation you only get

00:33:13,779 --> 00:33:18,789
the last digits and all of this in front

00:33:16,240 --> 00:33:21,789
would be zeros so I didn't write them

00:33:18,789 --> 00:33:25,019
down here so now we're having a quite

00:33:21,789 --> 00:33:30,070
smaller value and now for this case we

00:33:25,019 --> 00:33:32,470
write have an memory area which doesn't

00:33:30,070 --> 00:33:35,590
require that amount of values but that's

00:33:32,470 --> 00:33:38,019
the maximum 2047 and that's manageable

00:33:35,590 --> 00:33:43,090
in memory and we can allocate the memory

00:33:38,019 --> 00:33:44,619
and put it there at position 126 now we

00:33:43,090 --> 00:33:46,960
did do two things

00:33:44,619 --> 00:33:49,659
we had a hash function which is encrypt

00:33:46,960 --> 00:33:52,690
or safe and has many conflicts and we

00:33:49,659 --> 00:33:55,240
applying in table mask which is throwing

00:33:52,690 --> 00:33:58,779
away most of the information again so

00:33:55,240 --> 00:34:01,659
one third of the bits is only left in

00:33:58,779 --> 00:34:03,970
our final information so what the result

00:34:01,659 --> 00:34:05,970
of this is that we're having lots and

00:34:03,970 --> 00:34:08,290
lots and lots and lots of collisions

00:34:05,970 --> 00:34:12,190
probably I don't know depends on the

00:34:08,290 --> 00:34:18,220
case and what with the collision happens

00:34:12,190 --> 00:34:21,520
inside the hash table is that in fact at

00:34:18,220 --> 00:34:24,970
the memory position of 126 it's not

00:34:21,520 --> 00:34:27,000
storing the actual element but it's

00:34:24,970 --> 00:34:30,040
having some data structure which is a

00:34:27,000 --> 00:34:34,089
linked list so we can have multiple

00:34:30,040 --> 00:34:37,569
values at the same position so a look-up

00:34:34,089 --> 00:34:39,550
would be calculating that value going to

00:34:37,569 --> 00:34:41,260
the address in memory and Dan

00:34:39,550 --> 00:34:43,360
if there were some collisions go through

00:34:41,260 --> 00:34:46,540
a linked list to find the actual element

00:34:43,360 --> 00:34:49,270
and now we are getting to the issue why

00:34:46,540 --> 00:34:54,280
you all should upgrade to current PHP

00:34:49,270 --> 00:34:56,340
releases like PHP 5 3 10 since it was

00:34:54,280 --> 00:35:02,410
discovered that there was a small issue

00:34:56,340 --> 00:35:04,720
with this handling here that as I said

00:35:02,410 --> 00:35:06,460
everything in PHP is a hash table so

00:35:04,720 --> 00:35:08,980
dollar underscore get dollar underscore

00:35:06,460 --> 00:35:14,680
post the hash tables and an attacker

00:35:08,980 --> 00:35:17,740
could create post values which end up

00:35:14,680 --> 00:35:21,280
with the same value here 126 for

00:35:17,740 --> 00:35:23,380
instance and create a post request

00:35:21,280 --> 00:35:25,270
having lots and lots and lots and lots

00:35:23,380 --> 00:35:28,990
and lots and lots and lots of these

00:35:25,270 --> 00:35:31,270
values in there and thus creates a long

00:35:28,990 --> 00:35:33,760
long long linked list and for each

00:35:31,270 --> 00:35:37,150
operation this dollar get array we have

00:35:33,760 --> 00:35:40,980
to look through this long linked list

00:35:37,150 --> 00:35:47,260
and that takes some time and that

00:35:40,980 --> 00:35:50,170
created a possibility to create a denial

00:35:47,260 --> 00:35:52,180
of service attack ad or attack which

00:35:50,170 --> 00:35:53,620
slowed down the operation since the CPU

00:35:52,180 --> 00:35:56,770
was running through this list and

00:35:53,620 --> 00:35:58,240
finding the element so that's the reason

00:35:56,770 --> 00:36:00,700
why you should really update to a

00:35:58,240 --> 00:36:03,700
current PHP version we have known small

00:36:00,700 --> 00:36:06,900
issue while doing the fix so we didn't

00:36:03,700 --> 00:36:12,370
have only 5 3 9 but 5 through 10

00:36:06,900 --> 00:36:15,970
not very good but that's life and so

00:36:12,370 --> 00:36:18,160
update to the latest version and that's

00:36:15,970 --> 00:36:21,100
basically the overview I wanted to give

00:36:18,160 --> 00:36:24,040
you about some of the workings of PHP if

00:36:21,100 --> 00:36:27,190
you have questions we have a few minutes

00:36:24,040 --> 00:36:29,440
left so I am be happy to answer their

00:36:27,190 --> 00:36:33,130
questions if you want to write a talk or

00:36:29,440 --> 00:36:36,640
want to read the slides again it's all

00:36:33,130 --> 00:36:38,650
on this URL if we if you want to praise

00:36:36,640 --> 00:36:41,520
me on Twitter and that's my handle

00:36:38,650 --> 00:36:44,130
there's my URL and email thanks

00:36:41,520 --> 00:36:46,870
questions you know when you were

00:36:44,130 --> 00:36:48,550
explaining the cycling references yes

00:36:46,870 --> 00:36:51,250
and the garbage collection and stuff

00:36:48,550 --> 00:36:52,360
like that how would you solve that for

00:36:51,250 --> 00:36:53,420
example because you don't have it in

00:36:52,360 --> 00:36:55,460
5.24

00:36:53,420 --> 00:36:58,160
all right so if you wanted to unset it

00:36:55,460 --> 00:37:00,200
properly and reset the ref counts would

00:36:58,160 --> 00:37:01,970
you have to unset that all the

00:37:00,200 --> 00:37:04,280
properties manual is and then the object

00:37:01,970 --> 00:37:05,990
itself or is that is that any way of

00:37:04,280 --> 00:37:08,569
doing it actually yeah that's a perfect

00:37:05,990 --> 00:37:14,030
way for doing this by upgrading to a at

00:37:08,569 --> 00:37:16,010
a PHP version for instance for this

00:37:14,030 --> 00:37:22,040
issue that's a good reason to update

00:37:16,010 --> 00:37:23,359
from 5 2 to 5 3 and seriously yes like

00:37:22,040 --> 00:37:26,200
you said you would have to do it

00:37:23,359 --> 00:37:29,390
manually I'm setting all the references

00:37:26,200 --> 00:37:31,730
any other questions which was the faster

00:37:29,390 --> 00:37:36,319
in the end which was was it depends okay

00:37:31,730 --> 00:37:39,349
sorry I forgot to mention that thanks

00:37:36,319 --> 00:37:42,530
for reminding me I would have it in the

00:37:39,349 --> 00:37:47,150
nodes which I can see right now so what

00:37:42,530 --> 00:37:49,609
actually happens is there are some cases

00:37:47,150 --> 00:37:51,829
where we have some conflicts in the

00:37:49,609 --> 00:37:55,760
function or in the extension list so I

00:37:51,829 --> 00:37:58,369
have a case where dude did dump these

00:37:55,760 --> 00:38:01,250
lists and dumpty hash values and I had a

00:37:58,369 --> 00:38:05,630
case where three functions she had to

00:38:01,250 --> 00:38:07,880
say in value and then if you hit it it

00:38:05,630 --> 00:38:09,650
was slower if you didn't hit it it was

00:38:07,880 --> 00:38:11,809
faster so it depended on the function or

00:38:09,650 --> 00:38:13,730
in the exception you're looking at which

00:38:11,809 --> 00:38:15,500
then depends on your configuration how

00:38:13,730 --> 00:38:22,460
many functions you have so I can tell

00:38:15,500 --> 00:38:25,220
you you shouldn't really use such

00:38:22,460 --> 00:38:27,260
features depending on performance but

00:38:25,220 --> 00:38:29,960
make the code readable if you want to

00:38:27,260 --> 00:38:31,940
get the GD functions check the extension

00:38:29,960 --> 00:38:33,950
if you want a specific function which

00:38:31,940 --> 00:38:35,299
might be optional check for the function

00:38:33,950 --> 00:38:36,859
and that's the way to do it

00:38:35,299 --> 00:38:38,960
and make sure you name your functions

00:38:36,859 --> 00:38:44,660
correctly so you get the hash values

00:38:38,960 --> 00:38:47,030
that don't collide I actually did that

00:38:44,660 --> 00:38:50,359
in the earlier versions PHP one and two

00:38:47,030 --> 00:38:55,490
my hash was the string length of the

00:38:50,359 --> 00:38:56,839
function so so was a very it wasn't

00:38:55,490 --> 00:38:58,160
didn't have very many buckets there are

00:38:56,839 --> 00:39:00,680
lots of linked lists but I would name

00:38:58,160 --> 00:39:02,359
function such that it went into one of

00:39:00,680 --> 00:39:04,760
the buckets that didn't have very many

00:39:02,359 --> 00:39:07,020
collisions yet so some function names

00:39:04,760 --> 00:39:10,160
were slightly longer slightly shorter

00:39:07,020 --> 00:39:10,160
just to get them into the right bucket

00:39:11,660 --> 00:39:15,900
so one question I've been asked a few

00:39:13,950 --> 00:39:19,470
times I never know the answer to if I've

00:39:15,900 --> 00:39:21,600
got over here yeah so I've got some

00:39:19,470 --> 00:39:23,040
values in variables and I've got some

00:39:21,600 --> 00:39:25,770
literal strings and I want to combine

00:39:23,040 --> 00:39:28,050
them all into one string is it faster to

00:39:25,770 --> 00:39:30,060
concatenate or is it faster to have the

00:39:28,050 --> 00:39:34,970
variables inside a double quoted string

00:39:30,060 --> 00:39:44,430
and interpolate good question

00:39:34,970 --> 00:39:56,970
benchmark it profile it so in what was

00:39:44,430 --> 00:39:59,670
your result so an issue there is about

00:39:56,970 --> 00:40:01,670
the amount of copies and real locations

00:39:59,670 --> 00:40:05,100
and how much memory is being p.m.

00:40:01,670 --> 00:40:17,720
allocated where I guess you can make a

00:40:05,100 --> 00:40:21,240
good prediction in a good way well and

00:40:17,720 --> 00:40:25,170
so so comment was whether we could do

00:40:21,240 --> 00:40:27,390
some optimization in PHP for that we are

00:40:25,170 --> 00:40:29,550
not doing optimizations while compiling

00:40:27,390 --> 00:40:34,830
the PHP script that's where does what

00:40:29,550 --> 00:40:38,880
happened should happen and so we don't

00:40:34,830 --> 00:40:40,680
have that since basically when we're

00:40:38,880 --> 00:40:42,390
compiling the PHP script we're looking

00:40:40,680 --> 00:40:44,460
at a situation that we're throwing it

00:40:42,390 --> 00:40:46,020
away anyways again at the end of the

00:40:44,460 --> 00:40:51,240
scripts are spending much time on

00:40:46,020 --> 00:40:53,520
optimization doesn't benefit us there so

00:40:51,240 --> 00:40:56,610
one might think about it but it's

00:40:53,520 --> 00:41:02,730
currently not on the high priority list

00:40:56,610 --> 00:41:04,400
I want to ask about when the destructors

00:41:02,730 --> 00:41:08,610
are called

00:41:04,400 --> 00:41:14,550
is the structure code when variable

00:41:08,610 --> 00:41:17,800
leaves well when you have as a reference

00:41:14,550 --> 00:41:22,359
count as 0 or

00:41:17,800 --> 00:41:27,460
or could it be delay it until garbage

00:41:22,359 --> 00:41:29,800
collector kicks in the so the the you

00:41:27,460 --> 00:41:37,270
have your object and the object has a

00:41:29,800 --> 00:41:38,800
destructor and it the variable including

00:41:37,270 --> 00:41:41,800
the object of freedom and a reference

00:41:38,800 --> 00:41:43,690
count is reaching zero so at the end of

00:41:41,800 --> 00:41:45,790
the function if it's the last reference

00:41:43,690 --> 00:41:48,430
to the object then the destructor will

00:41:45,790 --> 00:41:52,150
recall at that time if there's an cyclic

00:41:48,430 --> 00:41:55,270
reference at the GC runs then it will be

00:41:52,150 --> 00:41:58,000
run during that Tracy run if it's in

00:41:55,270 --> 00:42:01,830
shutdown it will run during the shutdown

00:41:58,000 --> 00:42:06,760
time and that order I was showing before

00:42:01,830 --> 00:42:08,500
my question there this is a bit general

00:42:06,760 --> 00:42:10,180
but do you have any advice for people

00:42:08,500 --> 00:42:13,720
looking to get involved in the

00:42:10,180 --> 00:42:17,589
development of PHP yes you go to a

00:42:13,720 --> 00:42:21,220
recent URL Baxter php.net slash random

00:42:17,589 --> 00:42:23,980
and you get some current park you can

00:42:21,220 --> 00:42:26,140
look into which might be a bit hard to

00:42:23,980 --> 00:42:30,099
figure out since there are many parts

00:42:26,140 --> 00:42:32,710
which are bit complicated then I don't

00:42:30,099 --> 00:42:36,520
know what your previous knowledge about

00:42:32,710 --> 00:42:38,500
it is but to make it a bit general there

00:42:36,520 --> 00:42:41,589
are different ways to help out the PHP

00:42:38,500 --> 00:42:43,570
project some do you have to do a C code

00:42:41,589 --> 00:42:45,940
and many don't have to do directly with

00:42:43,570 --> 00:42:47,920
C code like going through the

00:42:45,940 --> 00:42:50,950
documentation we have this edit or

00:42:47,920 --> 00:42:53,250
php.net editor where you can anonymously

00:42:50,950 --> 00:42:56,730
log in edit the PHP documentation

00:42:53,250 --> 00:42:59,109
submitted as a patch very helpful and

00:42:56,730 --> 00:43:04,180
documentation is one of the things which

00:42:59,109 --> 00:43:06,369
made PHP really really successful then

00:43:04,180 --> 00:43:09,520
you can go to the bugs page as I

00:43:06,369 --> 00:43:11,859
mentioned look through the open box and

00:43:09,520 --> 00:43:14,440
start just writing a comment yes I can

00:43:11,859 --> 00:43:18,010
verify it here's a shorter reproducing

00:43:14,440 --> 00:43:20,109
case you might try to look into the PHP

00:43:18,010 --> 00:43:23,500
code to do this there's an website

00:43:20,109 --> 00:43:25,810
called an ell expert php.net which is

00:43:23,500 --> 00:43:28,480
quite nice to browse the PHP source code

00:43:25,810 --> 00:43:30,890
to search through it and each function

00:43:28,480 --> 00:43:35,089
in there is a link leaving

00:43:30,890 --> 00:43:37,220
new today definition and that's all for

00:43:35,089 --> 00:43:40,309
self-study you can also get some books

00:43:37,220 --> 00:43:42,859
about PHP internal stairs and sarah's

00:43:40,309 --> 00:43:45,559
book extending in a bedding PHP which

00:43:42,859 --> 00:43:49,039
explains some of the basic stuff about

00:43:45,559 --> 00:43:53,150
PHP and if all that doesn't help and as

00:43:49,039 --> 00:43:57,380
an often friendly IRC channel on F net

00:43:53,150 --> 00:44:02,000
and PHP dot pickle where many of the

00:43:57,380 --> 00:44:04,730
core developers are and help answering

00:44:02,000 --> 00:44:08,390
questions and and as the internals list

00:44:04,730 --> 00:44:10,640
and a pickle death list while internals

00:44:08,390 --> 00:44:13,839
you sometimes have some flame wars and

00:44:10,640 --> 00:44:20,180
pickle def yes sometimes more productive

00:44:13,839 --> 00:44:22,789
answers okay I just got one little

00:44:20,180 --> 00:44:26,480
question yes could you go back to the

00:44:22,789 --> 00:44:29,119
the page shutdown sequence yes I was

00:44:26,480 --> 00:44:31,789
just looking for the other thing same

00:44:29,119 --> 00:44:33,859
time and the resources and someone once

00:44:31,789 --> 00:44:36,109
asked me and I didn't know the answer if

00:44:33,859 --> 00:44:38,690
I put a print statement in a destructor

00:44:36,109 --> 00:44:42,230
of an object which is in a session will

00:44:38,690 --> 00:44:54,559
I see the printout you're in the session

00:44:42,230 --> 00:44:57,049
a session is finished at that stage if I

00:44:54,559 --> 00:44:59,630
put in the destructor I've got a print

00:44:57,049 --> 00:45:04,190
statement okay then the object is in the

00:44:59,630 --> 00:45:07,369
dollar session quite early before the

00:45:04,190 --> 00:45:09,470
output buffers flushed even though it's

00:45:07,369 --> 00:45:11,900
in the session yes okay cool

00:45:09,470 --> 00:45:17,000
no no no answer this question two years

00:45:11,900 --> 00:45:19,970
do you like any other last questions in

00:45:17,000 --> 00:45:22,759
a long-running PHP script yeah how often

00:45:19,970 --> 00:45:27,049
when does the guy which collector run so

00:45:22,759 --> 00:45:28,970
deep the garbage collector I'm not 100%

00:45:27,049 --> 00:45:30,710
sure but I think it depends on the

00:45:28,970 --> 00:45:34,130
amount of area it's you're having and

00:45:30,710 --> 00:45:35,450
that triggers at some random time but

00:45:34,130 --> 00:45:37,819
you shouldn't rely on it you can't

00:45:35,450 --> 00:45:40,849
forget if you really know now it's a

00:45:37,819 --> 00:45:43,940
good time for instance after running a

00:45:40,849 --> 00:45:44,670
huge test case or something there's a

00:45:43,940 --> 00:45:48,269
funk

00:45:44,670 --> 00:45:52,140
G C underscore run or something like

00:45:48,269 --> 00:45:55,289
that they collect cycles GC collect

00:45:52,140 --> 00:45:59,519
cycles which will trigger the garbage

00:45:55,289 --> 00:46:02,400
collection but usually the best thing is

00:45:59,519 --> 00:46:04,349
not to care too much about it since all

00:46:02,400 --> 00:46:06,089
these things might change and then

00:46:04,349 --> 00:46:10,079
behave a little bit different on a next

00:46:06,089 --> 00:46:13,319
version usually PHP tries to be smart

00:46:10,079 --> 00:46:15,420
enough so you don't have to try to be

00:46:13,319 --> 00:46:19,710
smarter than PHP it's always a little

00:46:15,420 --> 00:46:21,630
bit problematic so you say that the AB

00:46:19,710 --> 00:46:23,460
the destructor is caught when an object

00:46:21,630 --> 00:46:25,170
goes out of scope is the memory freed up

00:46:23,460 --> 00:46:27,569
at the same time or does that happen to

00:46:25,170 --> 00:46:29,369
the garbage collection cycle padmi sorry

00:46:27,569 --> 00:46:30,900
the memory of an object is that freed up

00:46:29,369 --> 00:46:32,760
low when he goes out of scope the

00:46:30,900 --> 00:46:36,900
district court or in the garbage

00:46:32,760 --> 00:46:41,099
collector cycle in this shutdown and I

00:46:36,900 --> 00:46:42,750
think here in the shutdown case when

00:46:41,099 --> 00:46:45,240
calling the destruct it just caused the

00:46:42,750 --> 00:46:47,609
destruct it doesn't just an object goes

00:46:45,240 --> 00:46:49,950
out of scope and I yeah and when going

00:46:47,609 --> 00:46:53,700
out of scope after calling to discuss it

00:46:49,950 --> 00:46:55,529
will be freed and thrown away here so in

00:46:53,700 --> 00:46:57,900
the example that you had with the

00:46:55,529 --> 00:47:00,420
function and passing a variable in by

00:46:57,900 --> 00:47:02,160
reference when you said don't park don't

00:47:00,420 --> 00:47:03,690
use references so let's say you've got a

00:47:02,160 --> 00:47:05,880
function and the function needs to

00:47:03,690 --> 00:47:08,250
modify a global variable so you could do

00:47:05,880 --> 00:47:10,049
it by using global variable name or you

00:47:08,250 --> 00:47:12,089
could do it through the global super

00:47:10,049 --> 00:47:14,190
global what's what's the best way of

00:47:12,089 --> 00:47:16,410
doing it then if you've got a function

00:47:14,190 --> 00:47:19,769
that needs the modify global variable if

00:47:16,410 --> 00:47:24,230
you're not passing it by reference so if

00:47:19,769 --> 00:47:24,230
you want to change something globally

00:47:25,430 --> 00:47:31,200
let me think if you if you use the

00:47:28,559 --> 00:47:33,869
global statement you're basically

00:47:31,200 --> 00:47:35,730
creating a reference which isn't from

00:47:33,869 --> 00:47:40,009
from the cost or something not too bad

00:47:35,730 --> 00:47:42,710
if you're using the dollar global array

00:47:40,009 --> 00:47:45,990
that's directly going to the hash table

00:47:42,710 --> 00:47:49,140
shouldn't cost much either so from from

00:47:45,990 --> 00:47:51,329
the cost side there's no big difference

00:47:49,140 --> 00:47:53,640
then again it's more about coding style

00:47:51,329 --> 00:47:56,190
and what you prefer for your code base

00:47:53,640 --> 00:47:58,119
to look like I try to avoid any

00:47:56,190 --> 00:47:59,559
discussion about which

00:47:58,119 --> 00:48:01,809
nicer to read or something like that

00:47:59,559 --> 00:48:06,240
since that's a quite subjective question

00:48:01,809 --> 00:48:06,240
and I guess that's what it boils down to

00:48:06,960 --> 00:48:12,099
not not it's really notable I hope

00:48:10,930 --> 00:48:17,700
there's no more questions because we run

00:48:12,099 --> 00:48:17,700
out of time thank you

00:48:20,990 --> 00:48:23,050
you

00:48:30,040 --> 00:48:32,100

YouTube URL: https://www.youtube.com/watch?v=bxxIXPc9IR8


