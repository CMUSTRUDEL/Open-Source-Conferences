Title: PHP Generics Today (almost) - Dave Liddament - PHP UK 2020
Publication date: 2020-03-11
Playlist: PHP UK Conference 2020
Description: 
	Support for generics is high up many PHP developersâ€™ wish lists. This talk is a deep dive into generics, their benefits and how, with existing tools, we can get the power of generics today.
Captions: 
	00:00:02,690 --> 00:00:07,160
so I'm going to be talking about

00:00:04,250 --> 00:00:10,670
generics and the reason I'm talking

00:00:07,160 --> 00:00:12,860
about generics is I believe they can

00:00:10,670 --> 00:00:15,199
help us write more understandable robust

00:00:12,860 --> 00:00:17,119
and reliable code and the reason I

00:00:15,199 --> 00:00:19,190
believe that is because I've worked in

00:00:17,119 --> 00:00:20,660
other programming languages where

00:00:19,190 --> 00:00:24,410
generics has been part of the language

00:00:20,660 --> 00:00:27,230
and I've seen the benefits so hopefully

00:00:24,410 --> 00:00:29,840
by the end of this talk you'll agree

00:00:27,230 --> 00:00:32,119
with me that they would be useful now

00:00:29,840 --> 00:00:35,120
generics isn't parts of the PHP language

00:00:32,119 --> 00:00:37,429
at the moment and I doubt it will be for

00:00:35,120 --> 00:00:39,289
awhile but what I am going to

00:00:37,429 --> 00:00:42,230
demonstrate is how you can use existing

00:00:39,289 --> 00:00:47,629
tools to almost give us the benefits of

00:00:42,230 --> 00:00:48,979
generics now I just want to make sure

00:00:47,629 --> 00:00:51,499
you're going to invest an hour of your

00:00:48,979 --> 00:00:53,659
time wisely I've marked this as an

00:00:51,499 --> 00:00:56,539
intermediate talk and my assumed

00:00:53,659 --> 00:00:58,370
knowledge my starting point is that you

00:00:56,539 --> 00:01:01,280
understands the type declaration that

00:00:58,370 --> 00:01:03,440
the type int in that in that method

00:01:01,280 --> 00:01:05,570
signature that function signature for

00:01:03,440 --> 00:01:08,870
process so you understand what the user

00:01:05,570 --> 00:01:11,030
is doing there and you can see that if

00:01:08,870 --> 00:01:12,650
we if we use this code and there would

00:01:11,030 --> 00:01:14,080
be an issue that's kind of my starting

00:01:12,650 --> 00:01:17,120
point

00:01:14,080 --> 00:01:19,310
conversely my ending point and if you

00:01:17,120 --> 00:01:22,430
already understand the annotations here

00:01:19,310 --> 00:01:26,600
things like app templates and a pattern

00:01:22,430 --> 00:01:29,540
class string and you already use some or

00:01:26,600 --> 00:01:31,070
PHP Stan maybe maybe you won't get much

00:01:29,540 --> 00:01:35,060
out of this but if you're somewhere in

00:01:31,070 --> 00:01:38,090
between stay on and hopefully you know

00:01:35,060 --> 00:01:43,100
something say anyone wants to move now's

00:01:38,090 --> 00:01:44,510
a good time oh wow really okay so the

00:01:43,100 --> 00:01:46,490
journey we're gonna take there's four

00:01:44,510 --> 00:01:49,670
main areas we're gonna talk first of all

00:01:46,490 --> 00:01:51,710
first first of all about what's our

00:01:49,670 --> 00:01:54,410
genomics then we're gonna do a deep dive

00:01:51,710 --> 00:01:56,630
into generics we're then going to see

00:01:54,410 --> 00:02:02,120
how we can use them now and I'll finish

00:01:56,630 --> 00:02:05,480
with a few thoughts so what are generics

00:02:02,120 --> 00:02:06,920
I want to talk very briefly this before

00:02:05,480 --> 00:02:09,200
we do generics about the benefits of

00:02:06,920 --> 00:02:12,050
type safety so specifically with this

00:02:09,200 --> 00:02:14,140
example there are in the context of this

00:02:12,050 --> 00:02:17,880
talk three areas

00:02:14,140 --> 00:02:21,459
and three benefits of this the first is

00:02:17,880 --> 00:02:24,010
that we have by having that type

00:02:21,459 --> 00:02:26,770
declaration of user it gives other

00:02:24,010 --> 00:02:29,020
developers clear unambiguous typed

00:02:26,770 --> 00:02:31,990
information we know if we're going to

00:02:29,020 --> 00:02:36,640
call process we have to call it with a

00:02:31,990 --> 00:02:39,160
user object we have a one-time check if

00:02:36,640 --> 00:02:40,959
we call process as we are here with

00:02:39,160 --> 00:02:43,209
something as string anything that's not

00:02:40,959 --> 00:02:45,700
a user that code will fail and it will

00:02:43,209 --> 00:02:47,680
fail when we try and call process so

00:02:45,700 --> 00:02:50,830
we've got a runtime check there to

00:02:47,680 --> 00:02:53,290
protectors against mistakes but best of

00:02:50,830 --> 00:02:55,840
all we've all just done static analysis

00:02:53,290 --> 00:02:58,150
right now we've looked at that code we

00:02:55,840 --> 00:03:01,120
don't have to run it and we can see that

00:02:58,150 --> 00:03:03,519
there is an issue so static analysis

00:03:01,120 --> 00:03:05,739
another major benefit and the reason

00:03:03,519 --> 00:03:09,160
these are all benefits if we think of

00:03:05,739 --> 00:03:12,580
the cost of a bug generally the later we

00:03:09,160 --> 00:03:14,260
find a bug the more costly it is so if

00:03:12,580 --> 00:03:16,060
we have some kind of continuous

00:03:14,260 --> 00:03:18,340
integration that may be running some

00:03:16,060 --> 00:03:20,380
kind of static analysis tool it could

00:03:18,340 --> 00:03:24,130
potentially find a whole class of bugs

00:03:20,380 --> 00:03:27,760
to do with height errors at the time we

00:03:24,130 --> 00:03:30,730
run CI and better still if we have an

00:03:27,760 --> 00:03:33,760
IDE that could give us real-time static

00:03:30,730 --> 00:03:35,709
analysis and providing we've added type

00:03:33,760 --> 00:03:37,690
information it can tell us about

00:03:35,709 --> 00:03:40,510
mistakes as we're writing them so we can

00:03:37,690 --> 00:03:46,870
fix mistakes almost at the point we add

00:03:40,510 --> 00:03:50,100
them in so what about generics imagine

00:03:46,870 --> 00:03:53,079
we have a class that represents a queue

00:03:50,100 --> 00:03:56,350
now a queue could contain anything it

00:03:53,079 --> 00:03:56,739
could be delegates waiting to get their

00:03:56,350 --> 00:03:59,650
lunch

00:03:56,739 --> 00:04:02,110
it could be jobs waiting to be executed

00:03:59,650 --> 00:04:06,430
it could be a queue of strings a queue

00:04:02,110 --> 00:04:08,980
of users a queue of books so for this

00:04:06,430 --> 00:04:11,560
very simple queue we've got two methods

00:04:08,980 --> 00:04:13,720
one is a way of adding something to the

00:04:11,560 --> 00:04:16,590
back of the queue and getnext takes

00:04:13,720 --> 00:04:20,799
thing from the front of the queue and

00:04:16,590 --> 00:04:23,860
the issue we have here is at the time of

00:04:20,799 --> 00:04:26,560
writing the queue code the queue pass we

00:04:23,860 --> 00:04:27,960
don't know the type of data for that

00:04:26,560 --> 00:04:31,780
queue will hold

00:04:27,960 --> 00:04:33,280
and there's no web knowing because it

00:04:31,780 --> 00:04:35,350
doesn't look you could be used in many

00:04:33,280 --> 00:04:37,600
different ways on one day it will be

00:04:35,350 --> 00:04:38,980
holding a string and some other time it

00:04:37,600 --> 00:04:43,450
will be holding a book and some other

00:04:38,980 --> 00:04:47,160
time a user so if you look at this

00:04:43,450 --> 00:04:49,450
function call to get Q it returns our Q

00:04:47,160 --> 00:04:52,450
but we don't know anything about that Q

00:04:49,450 --> 00:04:54,970
if we think about what types of entities

00:04:52,450 --> 00:04:56,260
are in the Q that's just not known we'd

00:04:54,970 --> 00:04:57,600
have to go and look at a lot more of the

00:04:56,260 --> 00:05:01,060
code to find that out

00:04:57,600 --> 00:05:03,820
there's no runtime check that we can add

00:05:01,060 --> 00:05:06,700
in to make sure that our Q's are holding

00:05:03,820 --> 00:05:08,740
the correct information and we can't do

00:05:06,700 --> 00:05:10,990
any static analysis we can't look at

00:05:08,740 --> 00:05:18,190
this now and know if there's an issue or

00:05:10,990 --> 00:05:24,280
not so one way around this is we could

00:05:18,190 --> 00:05:28,210
make a typed Q class when we construct

00:05:24,280 --> 00:05:31,240
it we record the type of the object that

00:05:28,210 --> 00:05:33,100
we want to store in the Q and we also

00:05:31,240 --> 00:05:36,580
construct an instance of the Q behind

00:05:33,100 --> 00:05:38,920
the scenes and then our add method when

00:05:36,580 --> 00:05:40,840
we add the item the first thing we do is

00:05:38,920 --> 00:05:44,170
we check that the item we are adding to

00:05:40,840 --> 00:05:46,870
the Q is of the correct type if it isn't

00:05:44,170 --> 00:05:49,960
we throw a type error and if it is of

00:05:46,870 --> 00:05:51,850
the correct type we add X to the Q this

00:05:49,960 --> 00:05:54,730
is our like a private Q behind the

00:05:51,850 --> 00:05:56,920
scenes so this type Q there's no way we

00:05:54,730 --> 00:05:59,260
can get something in there is not of the

00:05:56,920 --> 00:06:05,590
right type and I'll get mess and get

00:05:59,260 --> 00:06:08,140
next method is just a wrapper so we

00:06:05,590 --> 00:06:10,270
instantiate this Q like so and we would

00:06:08,140 --> 00:06:14,110
say I'm making a type Q and in this case

00:06:10,270 --> 00:06:18,640
I want it to contain objects of type of

00:06:14,110 --> 00:06:19,840
user so this means if we ran some code

00:06:18,640 --> 00:06:21,820
like this where we're trying to add

00:06:19,840 --> 00:06:24,910
something of type user to the user Q

00:06:21,820 --> 00:06:28,420
this would all be fine but conversely if

00:06:24,910 --> 00:06:33,760
we tried to add a string to our type Q

00:06:28,420 --> 00:06:36,700
our user Q this would fail so we think

00:06:33,760 --> 00:06:38,860
about this as a solution the same code

00:06:36,700 --> 00:06:41,320
works for any type if we need another Q

00:06:38,860 --> 00:06:44,170
and that holds books we just create a

00:06:41,320 --> 00:06:48,370
another type q and we do book : : class

00:06:44,170 --> 00:06:50,500
in the constructor we have runtime

00:06:48,370 --> 00:06:53,560
checks if we try to add something to the

00:06:50,500 --> 00:06:58,120
queue that is not the right type then we

00:06:53,560 --> 00:07:00,460
will get a type error thrown but there

00:06:58,120 --> 00:07:02,980
is a problem with the solution we can't

00:07:00,460 --> 00:07:05,470
do any static analysis on it we can't

00:07:02,980 --> 00:07:07,510
just look at something without looking

00:07:05,470 --> 00:07:12,550
at the context in how that key was

00:07:07,510 --> 00:07:18,220
instantiated to know what type this Q is

00:07:12,550 --> 00:07:21,960
expecting so there's another solution we

00:07:18,220 --> 00:07:25,840
could make a specific user q object

00:07:21,960 --> 00:07:29,200
again behind the scenes it's just it has

00:07:25,840 --> 00:07:32,440
this like generic Q and we've got our ad

00:07:29,200 --> 00:07:35,380
and get next methods but importantly we

00:07:32,440 --> 00:07:39,160
add type information to the ad and the

00:07:35,380 --> 00:07:43,210
return type and we've constructed like

00:07:39,160 --> 00:07:45,040
this music u equals new user Q and again

00:07:43,210 --> 00:07:47,260
if you try to add a user that would all

00:07:45,040 --> 00:07:51,280
be fine but if you try to have something

00:07:47,260 --> 00:07:54,490
that wasn't user would fail again with a

00:07:51,280 --> 00:07:57,370
type error so let's think of the pros

00:07:54,490 --> 00:07:58,780
and cons of this approach unfortunately

00:07:57,370 --> 00:08:01,120
the same code it doesn't work for any

00:07:58,780 --> 00:08:04,720
type so we have to rewrite we have to

00:08:01,120 --> 00:08:08,080
create our own class for each type of

00:08:04,720 --> 00:08:10,930
data we want to hold but we do get

00:08:08,080 --> 00:08:13,800
runtime checks and we can apply static

00:08:10,930 --> 00:08:17,790
analysis to this

00:08:13,800 --> 00:08:20,710
so both these solutions are non-ideal

00:08:17,790 --> 00:08:22,150
now in languages which support generics

00:08:20,710 --> 00:08:23,920
we can do something like this we can

00:08:22,150 --> 00:08:26,290
have our Q and then we can put this

00:08:23,920 --> 00:08:28,720
thing in angle brackets a tea and the

00:08:26,290 --> 00:08:31,240
tea just means at the time we're writing

00:08:28,720 --> 00:08:33,460
the Q we don't know what type this Q

00:08:31,240 --> 00:08:37,539
will hold it's kind of a template for

00:08:33,460 --> 00:08:38,860
later and then when we add we say we

00:08:37,539 --> 00:08:41,919
don't give the specific type we say

00:08:38,860 --> 00:08:45,760
we're adding something of type T and our

00:08:41,919 --> 00:08:47,380
turn type is something of type T so at

00:08:45,760 --> 00:08:48,730
the time we write Q we don't know how

00:08:47,380 --> 00:08:50,650
it's going to be used by the time we

00:08:48,730 --> 00:08:52,970
instantiate Q we will give it that

00:08:50,650 --> 00:08:55,759
missing information

00:08:52,970 --> 00:08:58,939
so instead of creating a cute cue like

00:08:55,759 --> 00:09:00,439
this we in the other languages that

00:08:58,939 --> 00:09:02,029
support your notes we can do something

00:09:00,439 --> 00:09:04,220
like this so we're saying we're nu Q and

00:09:02,029 --> 00:09:06,949
in the angle brackets we're saying it's

00:09:04,220 --> 00:09:09,379
the type user so that means behind the

00:09:06,949 --> 00:09:14,389
scenes wherever we had tea that gets

00:09:09,379 --> 00:09:17,660
replaced with the type user so as before

00:09:14,389 --> 00:09:19,399
it will correctly know it'll have the

00:09:17,660 --> 00:09:21,319
one time checks to know if we're adding

00:09:19,399 --> 00:09:22,939
something that's probably user and if we

00:09:21,319 --> 00:09:26,449
try and do something with isn't type

00:09:22,939 --> 00:09:28,850
user it will fail and the benefits of

00:09:26,449 --> 00:09:31,220
this solution is the same code works for

00:09:28,850 --> 00:09:36,560
any type we only have to write the cue

00:09:31,220 --> 00:09:38,509
class once we have runtime checks and we

00:09:36,560 --> 00:09:43,100
can apply static analysis to find bugs

00:09:38,509 --> 00:09:45,500
upfront so here's our three possible

00:09:43,100 --> 00:09:48,470
solutions the first two are possible and

00:09:45,500 --> 00:09:49,459
with PHP today but they have some

00:09:48,470 --> 00:09:51,769
problems

00:09:49,459 --> 00:09:56,259
the final one it would be great if PHP

00:09:51,769 --> 00:09:58,579
supported it but it's not yet possible

00:09:56,259 --> 00:10:00,829
so you might be thinking I've got bit

00:09:58,579 --> 00:10:04,910
deja vu I'm sure I've seen something

00:10:00,829 --> 00:10:06,769
like this before what about when we do

00:10:04,910 --> 00:10:08,149
things like say app return and then

00:10:06,769 --> 00:10:11,750
we've got user opening close square

00:10:08,149 --> 00:10:14,089
brackets is that not generic set and it

00:10:11,750 --> 00:10:16,399
kind of is and so if we look at this

00:10:14,089 --> 00:10:19,189
code here we can see get users is

00:10:16,399 --> 00:10:22,370
returning an array and from the dock

00:10:19,189 --> 00:10:24,920
block we can guess that the we can

00:10:22,370 --> 00:10:26,839
conclude that what we're returning is

00:10:24,920 --> 00:10:28,639
something of type user and an array

00:10:26,839 --> 00:10:31,670
where all the values in that array are

00:10:28,639 --> 00:10:34,790
of type user so when we iterate over

00:10:31,670 --> 00:10:37,129
that and we're calling process user we

00:10:34,790 --> 00:10:39,709
would guess that the object we are

00:10:37,129 --> 00:10:42,470
passing to process use it is of type

00:10:39,709 --> 00:10:47,240
user and looking at this we would say

00:10:42,470 --> 00:10:49,910
well that's all all fine but the problem

00:10:47,240 --> 00:10:53,750
is this is not actually checked by the

00:10:49,910 --> 00:10:55,699
language at all so if we have a function

00:10:53,750 --> 00:10:59,029
process users which is expecting to take

00:10:55,699 --> 00:11:01,670
an array of users and we call process

00:10:59,029 --> 00:11:04,279
users passing in an array where one of

00:11:01,670 --> 00:11:05,670
the items is a user and the other item

00:11:04,279 --> 00:11:08,499
is a string

00:11:05,670 --> 00:11:11,949
the code will not fail at a time we call

00:11:08,499 --> 00:11:13,509
process user it might fail later but it

00:11:11,949 --> 00:11:17,680
won't fail at this time there will be no

00:11:13,509 --> 00:11:19,749
type error so that's a bit of a shame

00:11:17,680 --> 00:11:22,360
you might say well are there tools that

00:11:19,749 --> 00:11:24,249
can enforce these checks and the answer

00:11:22,360 --> 00:11:26,499
is there are tools that can enforce

00:11:24,249 --> 00:11:29,800
these checks tools like Psalm fan and

00:11:26,499 --> 00:11:31,749
PHP Stan if you're not using these tools

00:11:29,800 --> 00:11:35,860
I would strongly recommend investigating

00:11:31,749 --> 00:11:38,920
them they are incredible so if we pass

00:11:35,860 --> 00:11:40,839
this code in Psalm and it would look at

00:11:38,920 --> 00:11:42,459
it and it would find some errors and

00:11:40,839 --> 00:11:44,199
specifically it would highlight the

00:11:42,459 --> 00:11:47,439
error here to say we're calling process

00:11:44,199 --> 00:11:50,170
users and we should be giving it an

00:11:47,439 --> 00:11:51,579
array where each entry in the array or

00:11:50,170 --> 00:11:53,319
each value in the array is of type user

00:11:51,579 --> 00:11:59,980
but it's correctly highlighting here

00:11:53,319 --> 00:12:03,730
that it isn't so how does this work with

00:11:59,980 --> 00:12:08,139
our Q example from earlier and what we

00:12:03,730 --> 00:12:10,569
can't do in PHP is we can't use this way

00:12:08,139 --> 00:12:13,750
of documenting templates because it's

00:12:10,569 --> 00:12:15,790
not syntactically correct so if we gave

00:12:13,750 --> 00:12:19,629
code like this to PHP it would just fail

00:12:15,790 --> 00:12:21,759
they really fail at parsing time so

00:12:19,629 --> 00:12:26,079
instead we move the type of information

00:12:21,759 --> 00:12:29,050
to dot blocks and we for the class you

00:12:26,079 --> 00:12:31,959
might say app template at that sign

00:12:29,050 --> 00:12:35,769
template and then T so this is telling

00:12:31,959 --> 00:12:38,199
our static analyzers that the Q is a

00:12:35,769 --> 00:12:40,990
template it will hold something that we

00:12:38,199 --> 00:12:46,420
don't know yet we will find out a later

00:12:40,990 --> 00:12:52,120
and and then we do a pram T and then we

00:12:46,420 --> 00:12:54,100
do a pattern T so what we can't express

00:12:52,120 --> 00:12:58,720
in the language we have to express

00:12:54,100 --> 00:13:01,779
through dot blots and then how do we

00:12:58,720 --> 00:13:04,240
tell the static analyzer that we're

00:13:01,779 --> 00:13:07,329
dealing with a Q that contains users

00:13:04,240 --> 00:13:10,179
again in the dot block we need to do at

00:13:07,329 --> 00:13:13,569
VAR q and then the angle brackets with a

00:13:10,179 --> 00:13:16,269
user we say so this tells the static

00:13:13,569 --> 00:13:19,199
analyzer that our Q object is actually a

00:13:16,269 --> 00:13:19,199
queue of users

00:13:20,190 --> 00:13:27,040
so that's a a recap sometimes write code

00:13:24,910 --> 00:13:29,050
for objects like you where at the time

00:13:27,040 --> 00:13:31,270
we write it we do not know what

00:13:29,050 --> 00:13:34,240
information what what type of data we'll

00:13:31,270 --> 00:13:36,340
hold and so we can tell staffing

00:13:34,240 --> 00:13:39,360
analyzers at later later about this by

00:13:36,340 --> 00:13:42,670
using and the annotation at template and

00:13:39,360 --> 00:13:44,800
when we create a queue we give the

00:13:42,670 --> 00:13:48,430
static analyzer the information it needs

00:13:44,800 --> 00:13:50,920
again in the annotation unfortunately

00:13:48,430 --> 00:13:54,370
this isn't supported by PHP at the

00:13:50,920 --> 00:13:57,430
moment so instead we use tools like some

00:13:54,370 --> 00:14:04,450
and PHP Stan to validate that everything

00:13:57,430 --> 00:14:07,120
is correct okay so that was first

00:14:04,450 --> 00:14:08,560
section and what are generics we're now

00:14:07,120 --> 00:14:10,000
going to do a bit of a deep dive into

00:14:08,560 --> 00:14:13,990
generics we're going to look at five

00:14:10,000 --> 00:14:17,710
areas sometimes this gets a bit

00:14:13,990 --> 00:14:20,020
complicated if you if you get lost don't

00:14:17,710 --> 00:14:22,480
worry I will share with you at the end a

00:14:20,020 --> 00:14:25,330
git repo which has full of examples of

00:14:22,480 --> 00:14:26,200
all these code snippets so you can

00:14:25,330 --> 00:14:29,920
actually have a look at them for

00:14:26,200 --> 00:14:31,750
yourself and so you stick with me and

00:14:29,920 --> 00:14:33,340
but if you do lose it then just come

00:14:31,750 --> 00:14:37,930
back for the third section where we'll

00:14:33,340 --> 00:14:39,910
show you how this all fits together okay

00:14:37,930 --> 00:14:43,540
so the first of the five I'd like to

00:14:39,910 --> 00:14:45,550
talk about our collections so imagine we

00:14:43,540 --> 00:14:48,130
have some code like this we've got a for

00:14:45,550 --> 00:14:52,870
each and we're calling the get employees

00:14:48,130 --> 00:14:55,600
method of the business class we can see

00:14:52,870 --> 00:14:58,150
that this get employees it would turn

00:14:55,600 --> 00:15:00,430
something of type array and we can look

00:14:58,150 --> 00:15:02,440
in the doc blocks to see that it's an

00:15:00,430 --> 00:15:10,300
array where all the values are of type

00:15:02,440 --> 00:15:13,780
employee and so we know the type of

00:15:10,300 --> 00:15:15,670
employee in our for loop is of objects

00:15:13,780 --> 00:15:18,190
employee but we're not sure what the

00:15:15,670 --> 00:15:21,490
name is it would however have to be an

00:15:18,190 --> 00:15:23,470
int or a string in this case but we're

00:15:21,490 --> 00:15:25,120
calling welcome passing in the key of

00:15:23,470 --> 00:15:27,660
whatever is coming back from game

00:15:25,120 --> 00:15:30,570
employees and we are expecting that

00:15:27,660 --> 00:15:33,070
sorry

00:15:30,570 --> 00:15:35,230
we are expecting that to be a type

00:15:33,070 --> 00:15:37,720
string now an array you could have keys

00:15:35,230 --> 00:15:39,670
of either insourced rings and it could

00:15:37,720 --> 00:15:42,490
actually have a mixture of both so

00:15:39,670 --> 00:15:44,860
looking at this code we can't guarantee

00:15:42,490 --> 00:15:47,770
that it's correct that's static analysis

00:15:44,860 --> 00:15:50,320
maybe it's correct maybe it isn't and if

00:15:47,770 --> 00:15:53,380
we gave this codes to Psalms have a look

00:15:50,320 --> 00:15:54,970
at it would complain it would say that

00:15:53,380 --> 00:15:56,860
we're calling welcome and we don't know

00:15:54,970 --> 00:16:02,170
what type we cannot guarantee that we're

00:15:56,860 --> 00:16:05,140
calling welcome with type string so how

00:16:02,170 --> 00:16:07,780
do we get around that what we can do is

00:16:05,140 --> 00:16:09,460
we can change that we can change the

00:16:07,780 --> 00:16:11,350
information we give for slightly so

00:16:09,460 --> 00:16:14,050
instead of saying out return employee

00:16:11,350 --> 00:16:16,330
open close square brackets we can say

00:16:14,050 --> 00:16:19,990
app return array and we've got the angle

00:16:16,330 --> 00:16:23,200
brackets string comma employee and what

00:16:19,990 --> 00:16:26,560
that means is the array keys are all of

00:16:23,200 --> 00:16:30,580
type string and the array values are all

00:16:26,560 --> 00:16:34,390
of type employee so that means we now

00:16:30,580 --> 00:16:36,160
know that name is of type string we're

00:16:34,390 --> 00:16:38,410
calling welcome with something that is

00:16:36,160 --> 00:16:41,590
of type string so we know that is all

00:16:38,410 --> 00:16:43,210
correct and our static analyzers would

00:16:41,590 --> 00:16:45,640
look at what's going on in the get

00:16:43,210 --> 00:16:47,710
employees method and if you ever try to

00:16:45,640 --> 00:16:50,050
put something into the raid that it

00:16:47,710 --> 00:16:51,850
returns where the key is in a string or

00:16:50,050 --> 00:16:54,690
the value isn't an employee it will

00:16:51,850 --> 00:16:54,690
complain about that

00:16:58,700 --> 00:17:02,960
so with the raise we can express the

00:17:00,740 --> 00:17:05,209
information we need in a number of ways

00:17:02,960 --> 00:17:07,339
if we're just interested in what the

00:17:05,209 --> 00:17:10,190
value type is we can just do something

00:17:07,339 --> 00:17:12,410
like this we have array angle brackets

00:17:10,190 --> 00:17:16,220
and V it's just telling us what the type

00:17:12,410 --> 00:17:19,220
of the values are if we're interested in

00:17:16,220 --> 00:17:21,050
the type of the keys and the value then

00:17:19,220 --> 00:17:23,510
we have to give both the key and the

00:17:21,050 --> 00:17:25,720
value types now for arrays the key

00:17:23,510 --> 00:17:31,310
values can only be of type string or

00:17:25,720 --> 00:17:33,380
type int and of course we might be using

00:17:31,310 --> 00:17:35,270
some kind of collection library for

00:17:33,380 --> 00:17:39,160
example doctrines collections are

00:17:35,270 --> 00:17:42,980
library they have an array collection

00:17:39,160 --> 00:17:45,170
object and you would give the additional

00:17:42,980 --> 00:17:50,390
information about that array collection

00:17:45,170 --> 00:17:52,790
in the same way here and I've done

00:17:50,390 --> 00:17:54,500
things like T and K and V they're just

00:17:52,790 --> 00:17:56,330
conventions you don't have to use those

00:17:54,500 --> 00:17:58,610
they're just like variable names you can

00:17:56,330 --> 00:18:03,170
name them however you like but the

00:17:58,610 --> 00:18:05,450
convention is that's normally T and the

00:18:03,170 --> 00:18:08,510
key and value K and V that's that's

00:18:05,450 --> 00:18:10,670
where they came from so that's first

00:18:08,510 --> 00:18:17,150
thing and that kind of covers off arrays

00:18:10,670 --> 00:18:19,670
collections we can also use generics

00:18:17,150 --> 00:18:22,880
just on functions so we've got a very

00:18:19,670 --> 00:18:25,220
simple function here I think it's only

00:18:22,880 --> 00:18:27,680
value really is to demonstrate generics

00:18:25,220 --> 00:18:31,910
it takes a value and then just returns

00:18:27,680 --> 00:18:34,460
it and again we've got template T so at

00:18:31,910 --> 00:18:38,740
the time we've written mirror we don't

00:18:34,460 --> 00:18:42,590
know and what it will be reflecting and

00:18:38,740 --> 00:18:46,400
but we do know that whatever type value

00:18:42,590 --> 00:18:48,080
is is the same type that we returned so

00:18:46,400 --> 00:18:50,780
if we have some code that looks like

00:18:48,080 --> 00:18:52,580
this we're calling mirror we're passing

00:18:50,780 --> 00:18:55,220
there v so we're passing an integer to

00:18:52,580 --> 00:18:59,860
it so we know that the value we get back

00:18:55,220 --> 00:18:59,860
from mirror will also be of integer

00:19:08,050 --> 00:19:13,000
okay so another slightly more advanced

00:19:10,830 --> 00:19:16,150
version and perhaps something that's

00:19:13,000 --> 00:19:19,000
slightly more you has a slight bit of

00:19:16,150 --> 00:19:22,390
use we could have a function called as a

00:19:19,000 --> 00:19:26,350
as array it takes a value and it returns

00:19:22,390 --> 00:19:28,960
an array of those values so again we can

00:19:26,350 --> 00:19:30,700
see that we're passing to it something

00:19:28,960 --> 00:19:33,130
that's an integer so we know that T in

00:19:30,700 --> 00:19:35,710
this case will be of type int in the

00:19:33,130 --> 00:19:37,480
case it's used here and we can see that

00:19:35,710 --> 00:19:39,940
what we're turning we're returning an

00:19:37,480 --> 00:19:43,870
array of something of type T so we know

00:19:39,940 --> 00:19:52,930
in this case values will be an array of

00:19:43,870 --> 00:19:56,020
integers it's also something called a

00:19:52,930 --> 00:19:58,180
class string so we can represent classes

00:19:56,020 --> 00:20:00,370
and we can either have their fully

00:19:58,180 --> 00:20:02,560
qualified name or we can take the class

00:20:00,370 --> 00:20:06,700
name and do colon colon class and behind

00:20:02,560 --> 00:20:08,680
the scenes that results in the same the

00:20:06,700 --> 00:20:13,120
same string and my preference is always

00:20:08,680 --> 00:20:15,570
a second one on that list so imagine we

00:20:13,120 --> 00:20:18,280
have a dependency injection of container

00:20:15,570 --> 00:20:21,130
we're only interested in for this one

00:20:18,280 --> 00:20:23,620
method which is called make we pass in

00:20:21,130 --> 00:20:26,350
the name of the class that we want to

00:20:23,620 --> 00:20:31,300
its create and then it returns an

00:20:26,350 --> 00:20:33,820
instantiated version of that so if we

00:20:31,300 --> 00:20:35,710
call this code here person and we're

00:20:33,820 --> 00:20:39,220
passing it personal colon colon class

00:20:35,710 --> 00:20:43,900
what we expected to return is a person

00:20:39,220 --> 00:20:45,820
object the issue we have here is there's

00:20:43,900 --> 00:20:48,700
no way a static analyzer can assert

00:20:45,820 --> 00:20:50,650
that's really happened I kind of just

00:20:48,700 --> 00:20:52,420
have to hope it's it's is the case the

00:20:50,650 --> 00:20:58,690
best we know here is person is of type

00:20:52,420 --> 00:21:01,300
object so once again we can add the at

00:20:58,690 --> 00:21:03,220
template T and we have this new thing

00:21:01,300 --> 00:21:05,830
here which is class string and then

00:21:03,220 --> 00:21:08,140
angle brackets T so that means we're

00:21:05,830 --> 00:21:10,900
expecting the string that we pass in not

00:21:08,140 --> 00:21:15,040
to be any old string but a string that

00:21:10,900 --> 00:21:19,570
represents and the native ever the fully

00:21:15,040 --> 00:21:21,580
qualified name of an object and what

00:21:19,570 --> 00:21:24,960
this is telling us is that T

00:21:21,580 --> 00:21:27,480
we'll be whatever that object is and

00:21:24,960 --> 00:21:31,360
we're returning something of that type

00:21:27,480 --> 00:21:34,330
so now we've got enough information to

00:21:31,360 --> 00:21:35,830
say to our static analyzer we're asking

00:21:34,330 --> 00:21:38,860
it to create something of type person

00:21:35,830 --> 00:21:42,759
person : : class so it knows in this

00:21:38,860 --> 00:21:46,509
case that person will be the dollar

00:21:42,759 --> 00:21:48,759
person that is that the make method

00:21:46,509 --> 00:21:54,330
returns will be in this case of type

00:21:48,759 --> 00:21:54,330
person and we get that from here

00:21:59,720 --> 00:22:05,240
another thing we do is extend templates

00:22:02,570 --> 00:22:08,179
so in the same way in PHP can extend

00:22:05,240 --> 00:22:10,700
classes you can extend arses and also

00:22:08,179 --> 00:22:13,029
extend the templates so a place where

00:22:10,700 --> 00:22:16,639
this is done quite commonly is

00:22:13,029 --> 00:22:18,649
repositories so if you're using doctrine

00:22:16,639 --> 00:22:21,769
repository you you might see something

00:22:18,649 --> 00:22:23,929
like this so abstract repository class

00:22:21,769 --> 00:22:25,730
it could be of any type of A+ you could

00:22:23,929 --> 00:22:29,320
hold anything it could hold users it

00:22:25,730 --> 00:22:32,750
could hold books it could hold talks and

00:22:29,320 --> 00:22:35,059
we've got a couple of methods on on here

00:22:32,750 --> 00:22:38,179
the first is find all and that just

00:22:35,059 --> 00:22:41,120
returns an array of all of the items in

00:22:38,179 --> 00:22:44,720
that repository and then we've got fine

00:22:41,120 --> 00:22:46,250
by ID and just like so in this case

00:22:44,720 --> 00:22:48,289
we're gonna return something that's

00:22:46,250 --> 00:22:51,440
either a Type C or if it's not at the

00:22:48,289 --> 00:22:52,519
repository it'll be something we know so

00:22:51,440 --> 00:23:00,950
we can do that just as we would in

00:22:52,519 --> 00:23:03,500
normal if we knew the type in advance so

00:23:00,950 --> 00:23:05,539
we've got our abstract class repository

00:23:03,500 --> 00:23:07,519
and we know it is a repository and we'll

00:23:05,539 --> 00:23:10,669
hold something of type T which we don't

00:23:07,519 --> 00:23:13,009
know at the moment now imagine we have a

00:23:10,669 --> 00:23:15,710
user repository the user repository

00:23:13,009 --> 00:23:17,779
extends for posit or E and the

00:23:15,710 --> 00:23:19,610
interesting bit here is in the doc block

00:23:17,779 --> 00:23:22,610
we can see we've got something that says

00:23:19,610 --> 00:23:24,529
at extends and what this is telling our

00:23:22,610 --> 00:23:28,129
static analyzers is that we're extending

00:23:24,529 --> 00:23:30,559
the repository and we've got the user in

00:23:28,129 --> 00:23:32,809
angle brackets so that is saying that

00:23:30,559 --> 00:23:38,090
the repository T in this case is of type

00:23:32,809 --> 00:23:41,330
user and what that means is the find by

00:23:38,090 --> 00:23:44,299
ID that was a method in the parent class

00:23:41,330 --> 00:23:46,279
and we know that what we will be

00:23:44,299 --> 00:23:48,889
returning is something used in this case

00:23:46,279 --> 00:23:50,809
will either be a type user or it will be

00:23:48,889 --> 00:23:56,179
null if there is no use of that record

00:23:50,809 --> 00:23:57,590
ID and that's kind of how we get that

00:23:56,179 --> 00:24:01,929
information that's how we know the type

00:23:57,590 --> 00:24:01,929
of of T of user

00:24:04,070 --> 00:24:07,440
this is one final thing I'm going to do

00:24:06,300 --> 00:24:11,850
in this deep dive I'm going to talk

00:24:07,440 --> 00:24:13,440
about how we restrict types and you can

00:24:11,850 --> 00:24:16,170
probably explain the whole of generics

00:24:13,440 --> 00:24:17,520
with cats and dogs and animals imagine

00:24:16,170 --> 00:24:20,580
we've gone animal we've got dog which

00:24:17,520 --> 00:24:23,460
extends animal the dog can bark we've

00:24:20,580 --> 00:24:27,780
got a cat that extends animal the cat

00:24:23,460 --> 00:24:30,570
can meow similar to what we had last

00:24:27,780 --> 00:24:33,270
time we've got in his face called animal

00:24:30,570 --> 00:24:37,230
game and again we've said it's a

00:24:33,270 --> 00:24:40,650
template T and then we've also got this

00:24:37,230 --> 00:24:46,440
single method which is called play and

00:24:40,650 --> 00:24:48,420
it takes something of type T so we've

00:24:46,440 --> 00:24:50,820
got dog game and this instead of

00:24:48,420 --> 00:24:52,470
extending and a ball game animal game is

00:24:50,820 --> 00:24:55,800
interface that implements animal game

00:24:52,470 --> 00:24:59,540
and when we were extending classes we

00:24:55,800 --> 00:25:01,680
had at extends now we have at implements

00:24:59,540 --> 00:25:04,680
so this is very similar to our last

00:25:01,680 --> 00:25:06,930
example at the moment and what this

00:25:04,680 --> 00:25:09,180
means is that we've got an animal game

00:25:06,930 --> 00:25:12,000
and it's the dog specific version of it

00:25:09,180 --> 00:25:14,970
so when we play with our animal we know

00:25:12,000 --> 00:25:22,230
in this case the animal must be a dog so

00:25:14,970 --> 00:25:24,140
it's okay to make the dog bark and if we

00:25:22,230 --> 00:25:28,080
did something similar where we've got

00:25:24,140 --> 00:25:29,850
again that dog game but we mistakenly

00:25:28,080 --> 00:25:31,260
think that the animal is a cat our

00:25:29,850 --> 00:25:35,270
static analyzer will tell us we made a

00:25:31,260 --> 00:25:40,860
mistake here because a dog can't me out

00:25:35,270 --> 00:25:43,710
but here's the new thing what if we have

00:25:40,860 --> 00:25:45,660
a class called car which is nothing to

00:25:43,710 --> 00:25:48,150
do with animals and then we say car

00:25:45,660 --> 00:25:51,180
implements animal game it doesn't really

00:25:48,150 --> 00:25:54,450
make sense and we've got a implements

00:25:51,180 --> 00:25:56,970
animal game car so the problem is car

00:25:54,450 --> 00:25:58,950
isn't really type of animal but actually

00:25:56,970 --> 00:26:02,550
our static analyzer wouldn't complain at

00:25:58,950 --> 00:26:05,840
this moment in time so what we need to

00:26:02,550 --> 00:26:09,860
do is we need to restrict the type

00:26:05,840 --> 00:26:13,770
that's he can be to just animals in our

00:26:09,860 --> 00:26:16,290
animal game interface so that's what

00:26:13,770 --> 00:26:16,820
this template T of animal that that

00:26:16,290 --> 00:26:19,039
means

00:26:16,820 --> 00:26:21,889
we try and instantiate something we try

00:26:19,039 --> 00:26:24,889
and extend something where the animal is

00:26:21,889 --> 00:26:27,259
of type car it will go well car is not

00:26:24,889 --> 00:26:29,809
an animal so this is not allowed whereas

00:26:27,259 --> 00:26:32,630
if we try and extend something that is a

00:26:29,809 --> 00:26:38,929
flight animal in this case cats that is

00:26:32,630 --> 00:26:41,779
allowed so you might be thinking well

00:26:38,929 --> 00:26:44,840
that's all very well but how does this

00:26:41,779 --> 00:26:46,519
actually help us and it helps us just

00:26:44,840 --> 00:26:49,279
like it did with the type of information

00:26:46,519 --> 00:26:50,809
on the process method we are

00:26:49,279 --> 00:26:52,279
communicating additional type

00:26:50,809 --> 00:26:54,529
information so this is two other

00:26:52,279 --> 00:26:57,169
developers and in this case two tools

00:26:54,529 --> 00:27:00,830
like static analyzers so if we look at

00:26:57,169 --> 00:27:02,750
this we know here that our array the

00:27:00,830 --> 00:27:05,240
array key is of type string and where

00:27:02,750 --> 00:27:07,490
whole and the value is translation so

00:27:05,240 --> 00:27:10,490
that's useful to other developers it is

00:27:07,490 --> 00:27:12,879
useful for static analyzers and because

00:27:10,490 --> 00:27:15,889
they can find bugs and sooner and

00:27:12,879 --> 00:27:19,610
remember the sooner we find bugs be

00:27:15,889 --> 00:27:20,990
cheaper those bugs are to fix so if we

00:27:19,610 --> 00:27:23,419
could get to know X in some language we

00:27:20,990 --> 00:27:25,399
already have the type you know the type

00:27:23,419 --> 00:27:28,580
system we currently have offers benefits

00:27:25,399 --> 00:27:30,740
in finding bugs earlier and the bitless

00:27:28,580 --> 00:27:38,929
missing or any of the PHP type system is

00:27:30,740 --> 00:27:41,929
the generics so this is why this talk

00:27:38,929 --> 00:27:44,090
was here and what I hope you will agree

00:27:41,929 --> 00:27:46,250
with me now is that using generics can

00:27:44,090 --> 00:27:52,549
help us write more understandable robust

00:27:46,250 --> 00:27:55,580
and reliable code that worm is right

00:27:52,549 --> 00:27:57,379
okay so and if I lost you in the deep

00:27:55,580 --> 00:27:58,399
dive if you can come back now we're

00:27:57,379 --> 00:28:01,970
going to talk about how we actually

00:27:58,399 --> 00:28:04,399
using generics now so as I said it's not

00:28:01,970 --> 00:28:06,620
possible at a language level so

00:28:04,399 --> 00:28:09,100
typically what we do now is we write

00:28:06,620 --> 00:28:12,710
codes and then and then we can run it

00:28:09,100 --> 00:28:15,019
but all we need somewhere in our process

00:28:12,710 --> 00:28:17,840
is this extra step where we do the

00:28:15,019 --> 00:28:22,850
static analysis so certainly as part of

00:28:17,840 --> 00:28:28,340
our CI and maybe before you start before

00:28:22,850 --> 00:28:30,680
you even commit your code in and if we

00:28:28,340 --> 00:28:34,040
want this to work if we want our static

00:28:30,680 --> 00:28:35,720
analysis to give us correct results we

00:28:34,040 --> 00:28:39,740
have to provide type information for

00:28:35,720 --> 00:28:44,450
everything including generics and we can

00:28:39,740 --> 00:28:47,060
use Sam or PHP Stan or orfan probably

00:28:44,450 --> 00:28:50,060
for this kind of I think Sam is probably

00:28:47,060 --> 00:28:51,980
the as as of today I think Sam is

00:28:50,060 --> 00:28:54,740
probably the most advanced of the tools

00:28:51,980 --> 00:28:58,130
when it comes to type checking but these

00:28:54,740 --> 00:29:01,660
tools are constantly evolving so maybe

00:28:58,130 --> 00:29:01,660
that advice won't be right next week

00:29:01,870 --> 00:29:07,010
installing Sam is pretty easy the other

00:29:05,180 --> 00:29:10,610
tools are similar you just do a composer

00:29:07,010 --> 00:29:15,260
require and sum all of these tools

00:29:10,610 --> 00:29:18,620
require some kind of config Sam you can

00:29:15,260 --> 00:29:20,810
just create it yourself you just run it

00:29:18,620 --> 00:29:23,030
the first time with the - I initialize

00:29:20,810 --> 00:29:25,210
you tell it where your code is in this

00:29:23,030 --> 00:29:27,680
example it's the source directory and

00:29:25,210 --> 00:29:31,460
you give it a number and I think psalm

00:29:27,680 --> 00:29:33,830
is between 1 and 8 or 1 and 7 and 1 is

00:29:31,460 --> 00:29:35,870
the strictest and if you want to do what

00:29:33,830 --> 00:29:38,900
I'm advocating here these tools have to

00:29:35,870 --> 00:29:43,550
be run on their strictest and settings

00:29:38,900 --> 00:29:45,530
and then you just run it word of warning

00:29:43,550 --> 00:29:51,770
if you do this on in resistant code base

00:29:45,530 --> 00:29:53,750
and you might get a lot of issues but

00:29:51,770 --> 00:29:57,740
anyway and that and the other tools are

00:29:53,750 --> 00:29:59,540
very similar to this so the next thing

00:29:57,740 --> 00:30:01,370
we have we might have our perfect code

00:29:59,540 --> 00:30:03,380
base we might have type we might have

00:30:01,370 --> 00:30:04,850
put type declarations everywhere we

00:30:03,380 --> 00:30:06,530
might have putting all the dock blocks

00:30:04,850 --> 00:30:10,490
we need to give all the information we

00:30:06,530 --> 00:30:12,520
require about generics but our perfect

00:30:10,490 --> 00:30:14,870
code probably doesn't sit in isolation

00:30:12,520 --> 00:30:18,050
we are probably interacting with

00:30:14,870 --> 00:30:25,250
frameworks and third-party libraries and

00:30:18,050 --> 00:30:25,700
third-party code so what do we do with

00:30:25,250 --> 00:30:27,680
these things

00:30:25,700 --> 00:30:29,900
there's good chance that some of these

00:30:27,680 --> 00:30:32,570
frameworks and third-party codes won't

00:30:29,900 --> 00:30:35,360
have the additional information you need

00:30:32,570 --> 00:30:38,540
to safely do static analysis and for

00:30:35,360 --> 00:30:40,370
good reason and a lot of these a lot of

00:30:38,540 --> 00:30:42,140
this is quite new so maybe the

00:30:40,370 --> 00:30:44,730
frameworks or certain versions of the

00:30:42,140 --> 00:30:47,040
frameworks were written before

00:30:44,730 --> 00:30:49,230
this came became it's not even

00:30:47,040 --> 00:30:54,540
mainstream but before before a lot of

00:30:49,230 --> 00:30:56,010
this was was around and third-party

00:30:54,540 --> 00:30:57,299
libraries might say well I don't want

00:30:56,010 --> 00:30:58,710
some of these annotations because

00:30:57,299 --> 00:30:59,730
they're not really part of the language

00:30:58,710 --> 00:31:02,100
they're not really part there's not even

00:30:59,730 --> 00:31:04,799
a PSR that supports them so I don't want

00:31:02,100 --> 00:31:07,350
my code polluted with with that so those

00:31:04,799 --> 00:31:10,169
might be reasons why people aren't going

00:31:07,350 --> 00:31:12,030
to engage or don't engage the best thing

00:31:10,169 --> 00:31:13,530
we can do is try and get those who are

00:31:12,030 --> 00:31:16,340
writing third-party libraries on board

00:31:13,530 --> 00:31:18,900
and some are already doing this doctrine

00:31:16,340 --> 00:31:21,480
PHP units and the web notes are

00:31:18,900 --> 00:31:22,679
assertions library are all examples now

00:31:21,480 --> 00:31:24,540
if you go and look at their latest

00:31:22,679 --> 00:31:28,410
versions they have these additional

00:31:24,540 --> 00:31:30,000
annotations in if you are gonna try and

00:31:28,410 --> 00:31:32,220
get third-party libraries on boards

00:31:30,000 --> 00:31:34,350
before you do any work at least engage

00:31:32,220 --> 00:31:36,750
with the maintainer the seif there would

00:31:34,350 --> 00:31:39,390
be any interest in doing that and I

00:31:36,750 --> 00:31:40,950
think it's a two step process the first

00:31:39,390 --> 00:31:43,860
one is to add in the additional

00:31:40,950 --> 00:31:45,960
annotations and an even better it would

00:31:43,860 --> 00:31:51,870
be to introduce the static analyzers to

00:31:45,960 --> 00:31:53,640
their to their build process now if for

00:31:51,870 --> 00:31:56,179
whatever reason the third-party

00:31:53,640 --> 00:31:59,669
libraries aren't gonna get on board or

00:31:56,179 --> 00:32:04,260
for whatever reason then we have to work

00:31:59,669 --> 00:32:07,950
with that so one example I had is I was

00:32:04,260 --> 00:32:09,270
using a tool which you gave it you could

00:32:07,950 --> 00:32:11,990
give it in so if you give it strings you

00:32:09,270 --> 00:32:15,780
give anything and it returned a hash of

00:32:11,990 --> 00:32:23,250
whatever you gave it and if we look at

00:32:15,780 --> 00:32:24,750
the sorry if we look at at this the way

00:32:23,250 --> 00:32:26,910
I was using it I was always passing an

00:32:24,750 --> 00:32:28,980
ID and if we look at the method

00:32:26,910 --> 00:32:30,809
signature for encode it looks like it

00:32:28,980 --> 00:32:32,990
doesn't take anything it's not expecting

00:32:30,809 --> 00:32:35,490
any any parameters at all

00:32:32,990 --> 00:32:40,100
so static analyzers say I'm pretty sure

00:32:35,490 --> 00:32:42,780
you're not calling an encode correct so

00:32:40,100 --> 00:32:45,030
one way around this is we could create a

00:32:42,780 --> 00:32:48,900
clean interface to whatever we're using

00:32:45,030 --> 00:32:52,049
so we've got our clean hasher we inject

00:32:48,900 --> 00:32:54,510
the actual hasher in inter constructor

00:32:52,049 --> 00:32:56,340
and then we have our own encode method

00:32:54,510 --> 00:32:58,230
where we're specifically saying I'm

00:32:56,340 --> 00:33:00,000
expecting something of type int

00:32:58,230 --> 00:33:03,600
I'll give you something back as string

00:33:00,000 --> 00:33:05,160
and then this means that when we call

00:33:03,600 --> 00:33:07,440
this our static analyzer we'll look at

00:33:05,160 --> 00:33:09,330
it and go yep I'm expecting clean hasha

00:33:07,440 --> 00:33:11,669
to be called with an integer that's what

00:33:09,330 --> 00:33:14,669
you've given it and it is returning a

00:33:11,669 --> 00:33:17,760
string so this is one way of approaching

00:33:14,669 --> 00:33:20,309
our interface between our perfect code

00:33:17,760 --> 00:33:22,250
and other other bits of code which from

00:33:20,309 --> 00:33:27,630
the perspective of static analysis is

00:33:22,250 --> 00:33:31,590
not perfect another way we can do this

00:33:27,630 --> 00:33:34,049
is using stubs so imagine our dependency

00:33:31,590 --> 00:33:36,090
injection example from before if we

00:33:34,049 --> 00:33:38,309
looked at our third-party library and

00:33:36,090 --> 00:33:40,590
this is where this is all the

00:33:38,309 --> 00:33:43,490
information they give we need to provide

00:33:40,590 --> 00:33:46,380
more information so we could make a

00:33:43,490 --> 00:33:50,299
stubs file and we would save this in our

00:33:46,380 --> 00:33:52,290
project and maybe like under the stubs

00:33:50,299 --> 00:33:54,929
directory so something away from the

00:33:52,290 --> 00:33:56,970
source code and we would copy out the

00:33:54,929 --> 00:34:00,900
namespace and the class declaration and

00:33:56,970 --> 00:34:03,419
for every method we're interested in we

00:34:00,900 --> 00:34:06,059
would copy it into our stub and we don't

00:34:03,419 --> 00:34:08,429
give it any implementation details at

00:34:06,059 --> 00:34:12,960
all but we can give it additional

00:34:08,429 --> 00:34:15,179
information in the dot block and what

00:34:12,960 --> 00:34:17,490
this means is the static analyzer will

00:34:15,179 --> 00:34:18,780
look at it you would configure some and

00:34:17,490 --> 00:34:22,470
say this is where you'll find all the

00:34:18,780 --> 00:34:25,619
stub files and some would would take

00:34:22,470 --> 00:34:28,230
this over the other information that it

00:34:25,619 --> 00:34:30,389
finds but you have to be incredibly

00:34:28,230 --> 00:34:32,520
careful doing this because if you put

00:34:30,389 --> 00:34:35,100
some information here that is wrong than

00:34:32,520 --> 00:34:37,139
the static analyzer well it will take

00:34:35,100 --> 00:34:38,730
that information so it's garbage in

00:34:37,139 --> 00:34:40,950
garbage out which you have to make sure

00:34:38,730 --> 00:34:46,169
that we're giving the static analyzer

00:34:40,950 --> 00:34:48,570
the correct information all the static

00:34:46,169 --> 00:34:51,389
analyzers allow you to write plugins and

00:34:48,570 --> 00:34:52,830
this is probably needed where from the

00:34:51,389 --> 00:34:55,320
framelits have got a bit of magic going

00:34:52,830 --> 00:34:57,570
on and the problem with this is they're

00:34:55,320 --> 00:35:00,300
specific to each tool so if I wrote

00:34:57,570 --> 00:35:03,150
Montes arm it wouldn't work on PHP Stan

00:35:00,300 --> 00:35:05,550
and compared to all the other solutions

00:35:03,150 --> 00:35:08,750
I proposed this is certainly an order of

00:35:05,550 --> 00:35:08,750
magnitude more difficult

00:35:10,750 --> 00:35:19,610
so kind of as a summary for this section

00:35:13,760 --> 00:35:22,400
um we would add in static analysis to

00:35:19,610 --> 00:35:24,140
our process so we drive the code we'd

00:35:22,400 --> 00:35:26,420
have some static analysis and then we'd

00:35:24,140 --> 00:35:29,420
run the code and our static analyzer

00:35:26,420 --> 00:35:31,580
needs to know the types of everything so

00:35:29,420 --> 00:35:32,930
if we are interfacing with something

00:35:31,580 --> 00:35:35,030
else like a framework or a third-party

00:35:32,930 --> 00:35:42,440
library we might have to give that

00:35:35,030 --> 00:35:46,850
information somehow ok so I'm going to

00:35:42,440 --> 00:35:49,880
wrap up with some thoughts and so the

00:35:46,850 --> 00:35:53,120
title was PHP generics now brackets

00:35:49,880 --> 00:35:56,450
almost and you might be asking why

00:35:53,120 --> 00:35:59,270
almost because it seems like I proposed

00:35:56,450 --> 00:36:02,990
something where we can have the power to

00:35:59,270 --> 00:36:06,470
know X now and if you try doing what

00:36:02,990 --> 00:36:08,900
I've suggested there are a few friction

00:36:06,470 --> 00:36:10,400
points and probably the biggest one is

00:36:08,900 --> 00:36:12,110
that the IDs

00:36:10,400 --> 00:36:15,230
don't necessarily understand this

00:36:12,110 --> 00:36:19,780
additional these new types of

00:36:15,230 --> 00:36:24,940
annotations so for example here I've got

00:36:19,780 --> 00:36:28,100
the way of expressing and the key and

00:36:24,940 --> 00:36:30,950
the value information of an array and

00:36:28,100 --> 00:36:33,500
the problem with this is that this tool

00:36:30,950 --> 00:36:36,500
doesn't understand that and what's worse

00:36:33,500 --> 00:36:38,630
is before it knew at least the type of

00:36:36,500 --> 00:36:43,910
the value now it doesn't even know that

00:36:38,630 --> 00:36:46,070
as well and I would and this is a this

00:36:43,910 --> 00:36:48,560
is a bit of an issue really and there

00:36:46,070 --> 00:36:50,840
are some ways you can mitigate it so

00:36:48,560 --> 00:36:53,690
what you can do is you can use the

00:36:50,840 --> 00:36:56,240
normal out return annotation say this is

00:36:53,690 --> 00:36:58,250
something of employees and you can give

00:36:56,240 --> 00:37:00,620
the additional information that the

00:36:58,250 --> 00:37:03,860
static analyzer requires by having some

00:37:00,620 --> 00:37:06,860
- return at PHP stan has PHP Spanish

00:37:03,860 --> 00:37:10,150
return and actually Psalm and PHP Stan

00:37:06,860 --> 00:37:14,120
understand each other's annotations you

00:37:10,150 --> 00:37:17,120
can do this in a lot of cases but there

00:37:14,120 --> 00:37:21,440
are times when you can't so this doesn't

00:37:17,120 --> 00:37:23,490
completely solve the problem essentially

00:37:21,440 --> 00:37:25,650
what we really need is a stand

00:37:23,490 --> 00:37:28,250
for this and once we've got a standard

00:37:25,650 --> 00:37:31,050
all of the tools can adopt that standard

00:37:28,250 --> 00:37:33,300
and that will make creating code easier

00:37:31,050 --> 00:37:37,500
and then the standard will also help all

00:37:33,300 --> 00:37:40,260
the libraries getting bored as well so

00:37:37,500 --> 00:37:42,270
thoughts about how we could implement

00:37:40,260 --> 00:37:45,420
the standard the best one would be full

00:37:42,270 --> 00:37:47,730
language support there's a link later

00:37:45,420 --> 00:37:51,780
which goes into details why that's

00:37:47,730 --> 00:37:54,660
potentially difficult maybe maybe a PSR

00:37:51,780 --> 00:37:56,730
or maybe some other way of all the

00:37:54,660 --> 00:37:58,560
interested parties sitting down and

00:37:56,730 --> 00:38:03,480
saying let's agree this is how things

00:37:58,560 --> 00:38:04,890
are going to be done and more crazy blue

00:38:03,480 --> 00:38:08,220
sky thinking which we should probably

00:38:04,890 --> 00:38:13,140
completely disregard but maybe the

00:38:08,220 --> 00:38:16,050
language that rpm there are our C's for

00:38:13,140 --> 00:38:19,710
implementing I say proper annotations

00:38:16,050 --> 00:38:22,830
language level annotations in PHP and if

00:38:19,710 --> 00:38:26,670
that happened then we could properly

00:38:22,830 --> 00:38:28,680
define these additional annotations and

00:38:26,670 --> 00:38:31,260
then the static analyzers could could

00:38:28,680 --> 00:38:33,510
use them so this would be better than a

00:38:31,260 --> 00:38:37,040
dot block solution because they would be

00:38:33,510 --> 00:38:39,420
more formally defined so in this case

00:38:37,040 --> 00:38:41,970
instead of having a dot block

00:38:39,420 --> 00:38:46,890
that is one of the proposed methods of

00:38:41,970 --> 00:38:49,170
doing annotations in PHP and even more

00:38:46,890 --> 00:38:51,600
crazy suggestion is you could add the

00:38:49,170 --> 00:38:54,810
syntax of generics to the language and

00:38:51,600 --> 00:38:59,070
and you would take that information just

00:38:54,810 --> 00:39:01,080
as far as the ast so let's explain that

00:38:59,070 --> 00:39:02,910
just quickly when you've got your PHP

00:39:01,080 --> 00:39:06,450
code there's a number of steps it goes

00:39:02,910 --> 00:39:07,320
through before gets executed so at a

00:39:06,450 --> 00:39:10,140
very high level

00:39:07,320 --> 00:39:15,060
you've got your PHP code it then goes

00:39:10,140 --> 00:39:16,680
through a tokenizer and stage and that

00:39:15,060 --> 00:39:18,900
would lead modifying if we were going to

00:39:16,680 --> 00:39:22,890
add add add it into the syntax of

00:39:18,900 --> 00:39:24,690
language either these two solutions form

00:39:22,890 --> 00:39:27,420
the tokens you create something called

00:39:24,690 --> 00:39:30,359
an abstract syntax tree and that is a

00:39:27,420 --> 00:39:33,930
graphical a graph of your entire code

00:39:30,359 --> 00:39:36,710
base and the static analyzers that I've

00:39:33,930 --> 00:39:39,770
talked about PHP Stan

00:39:36,710 --> 00:39:42,410
and some and I imagine phpstorm I'm not

00:39:39,770 --> 00:39:44,150
sure they probably well first you

00:39:42,410 --> 00:39:45,530
definitely look at the ast so the

00:39:44,150 --> 00:39:48,470
abstract syntax tree to get all that

00:39:45,530 --> 00:39:50,000
information so if we could get all the

00:39:48,470 --> 00:39:52,130
generic information into the abstract

00:39:50,000 --> 00:39:54,500
syntax tree it will be in in a

00:39:52,130 --> 00:39:57,770
consistent way that all the tools can

00:39:54,500 --> 00:39:59,540
use it but what probably happening in

00:39:57,770 --> 00:40:01,099
these proposals here we're not going for

00:39:59,540 --> 00:40:02,540
full language supports is that

00:40:01,099 --> 00:40:05,210
information wouldn't get through to the

00:40:02,540 --> 00:40:07,160
black code so the VM would have no

00:40:05,210 --> 00:40:14,270
knowledge of it so you wouldn't get your

00:40:07,160 --> 00:40:16,369
runtime checks now if we're doing

00:40:14,270 --> 00:40:19,010
templates we might be sacrificing

00:40:16,369 --> 00:40:21,099
runtime checks it's quite possible that

00:40:19,010 --> 00:40:24,200
our code at the moment doesn't have

00:40:21,099 --> 00:40:26,420
one-time checks in any way but we're

00:40:24,200 --> 00:40:28,670
certainly removing any of these runtime

00:40:26,420 --> 00:40:30,170
checks so that means we have to make

00:40:28,670 --> 00:40:34,010
sure that our tools are correctly

00:40:30,170 --> 00:40:35,930
reporting everything and the problem of

00:40:34,010 --> 00:40:37,580
that is all bets are off is there any

00:40:35,930 --> 00:40:41,450
missing or incorrect type of information

00:40:37,580 --> 00:40:42,920
so if you have a legacy code base it's

00:40:41,450 --> 00:40:44,570
going to be quite a lot of efforts to

00:40:42,920 --> 00:40:49,150
get all the information you need to

00:40:44,570 --> 00:40:51,260
successfully do this kind of analysis

00:40:49,150 --> 00:40:53,380
but if you're starting from scratch

00:40:51,260 --> 00:40:59,119
I definitely recommend this approach and

00:40:53,380 --> 00:41:01,609
and if we were in a position where we

00:40:59,119 --> 00:41:05,270
could I mean with essentially trusting

00:41:01,609 --> 00:41:08,210
our staffing and ours analyzers to do

00:41:05,270 --> 00:41:11,300
all our type checking for generics well

00:41:08,210 --> 00:41:14,780
if we're trusting it to do that why stop

00:41:11,300 --> 00:41:16,250
there we could actually remove type

00:41:14,780 --> 00:41:18,349
checks completely we could have this

00:41:16,250 --> 00:41:19,700
stage where you've got our codes and

00:41:18,349 --> 00:41:21,640
before we actually deploy it to

00:41:19,700 --> 00:41:24,230
production we run our static analysis

00:41:21,640 --> 00:41:26,270
its type checked everything it says

00:41:24,230 --> 00:41:28,580
everything's alright and then we will

00:41:26,270 --> 00:41:29,869
remove type checks and while we've

00:41:28,580 --> 00:41:33,500
removed type checks where there's a

00:41:29,869 --> 00:41:37,339
performance penalty in checking them I

00:41:33,500 --> 00:41:39,320
think if you leave in int type to a int

00:41:37,339 --> 00:41:41,480
type hints then I think there is a

00:41:39,320 --> 00:41:42,859
performance boost but I believe with a

00:41:41,480 --> 00:41:48,349
lot of the other ones actually slows

00:41:42,859 --> 00:41:49,970
things down having these type checks so

00:41:48,349 --> 00:41:50,630
you might say well there why don't we

00:41:49,970 --> 00:41:54,140
just use

00:41:50,630 --> 00:41:57,650
Java or some other language and there's

00:41:54,140 --> 00:41:59,539
lots of good reasons to use PHP what are

00:41:57,650 --> 00:42:03,109
the major benefits of PHP is you can

00:41:59,539 --> 00:42:05,630
pick and the level of code quality you

00:42:03,109 --> 00:42:07,579
want you can go and do all the things

00:42:05,630 --> 00:42:09,289
I'm proposing which is it's quite high

00:42:07,579 --> 00:42:13,849
level and this is quite a high level of

00:42:09,289 --> 00:42:16,190
engineering and involved or you can just

00:42:13,849 --> 00:42:17,539
make some really simple you know if you

00:42:16,190 --> 00:42:19,339
do some minor script you're only going

00:42:17,539 --> 00:42:21,200
to run once you don't need to worry

00:42:19,339 --> 00:42:24,230
about doing all of this all of this

00:42:21,200 --> 00:42:26,539
stuff the other thing is languages like

00:42:24,230 --> 00:42:29,029
Java they have this compilations stage

00:42:26,539 --> 00:42:32,779
and one of the great things about PHP

00:42:29,029 --> 00:42:36,140
which was alluded to in the keynotes is

00:42:32,779 --> 00:42:38,089
you can just make a change hit f5 and

00:42:36,140 --> 00:42:40,579
you can see it and you don't have any of

00:42:38,089 --> 00:42:42,440
this long process we kind of skip this

00:42:40,579 --> 00:42:45,769
whole compile process and that is a

00:42:42,440 --> 00:42:47,660
really great thing about PHP and of

00:42:45,769 --> 00:42:49,250
course PHP developers are much happier

00:42:47,660 --> 00:42:54,170
than Java developers I could say that

00:42:49,250 --> 00:42:55,579
I've been both so that's kind of what

00:42:54,170 --> 00:42:57,529
we've discussed today we've looked at

00:42:55,579 --> 00:43:02,000
watching outs are we've done a deep dive

00:42:57,529 --> 00:43:04,809
into generics and we've looked at ways

00:43:02,000 --> 00:43:08,960
we could actually add in static analysis

00:43:04,809 --> 00:43:10,670
into our into our build process now and

00:43:08,960 --> 00:43:12,529
you kind of get the powers of it and

00:43:10,670 --> 00:43:14,390
you've kind of seen maybe some of the

00:43:12,529 --> 00:43:16,490
limitations and maybe what happens has

00:43:14,390 --> 00:43:19,910
to happen next in the community to get

00:43:16,490 --> 00:43:21,680
closer to generics and the benefits are

00:43:19,910 --> 00:43:24,920
we're adding clarity to our codes and

00:43:21,680 --> 00:43:27,950
we're enabling us to find a whole range

00:43:24,920 --> 00:43:31,089
of type related errors earlier which

00:43:27,950 --> 00:43:33,710
then reduces the cost of static analysis

00:43:31,089 --> 00:43:35,569
and that's kind of how we use it now we

00:43:33,710 --> 00:43:39,259
write our code we put it through static

00:43:35,569 --> 00:43:41,420
analysis and then that gets run but yeah

00:43:39,259 --> 00:43:43,839
the next step really I think is either

00:43:41,420 --> 00:43:46,819
standards or full language

00:43:43,839 --> 00:43:49,550
implementation I've been Dave Redmon's

00:43:46,819 --> 00:44:02,630
thank you for listening

00:43:49,550 --> 00:44:11,480
I think many questions they've made them

00:44:02,630 --> 00:44:13,520
too difficult we're using static

00:44:11,480 --> 00:44:17,000
analysis right now and one of the things

00:44:13,520 --> 00:44:19,820
I really want to do is get more with

00:44:17,000 --> 00:44:21,980
generics and stuff but colleagues are a

00:44:19,820 --> 00:44:25,870
bit hesitant because it removes runtime

00:44:21,980 --> 00:44:30,500
checks so how would you convince them

00:44:25,870 --> 00:44:32,170
well the first question is are some of

00:44:30,500 --> 00:44:34,790
these runtime checks actually there

00:44:32,170 --> 00:44:36,320
because if you look at the the example I

00:44:34,790 --> 00:44:38,120
had right and start where you've got the

00:44:36,320 --> 00:44:40,430
you know I'm returning users and I've

00:44:38,120 --> 00:44:42,710
got open closed brackets in that code

00:44:40,430 --> 00:44:45,290
there were no one-time checks so I would

00:44:42,710 --> 00:44:47,830
check if they really were and and that

00:44:45,290 --> 00:44:50,900
would be my first point and then

00:44:47,830 --> 00:44:52,040
probably it's something we there are

00:44:50,900 --> 00:44:54,230
times you just have to remove the

00:44:52,040 --> 00:44:57,740
one-time checks and but there are

00:44:54,230 --> 00:45:01,690
probably ways around it which is less

00:44:57,740 --> 00:45:04,490
optimal code to put to put them in so

00:45:01,690 --> 00:45:05,810
that might be a discussion unless you

00:45:04,490 --> 00:45:08,540
can unless you've got something it's

00:45:05,810 --> 00:45:09,890
really easy to kind of explain over we

00:45:08,540 --> 00:45:11,390
might need to kind of sit down with a

00:45:09,890 --> 00:45:12,920
bit of paper and the answer is you might

00:45:11,390 --> 00:45:18,950
not be able to move those those one-time

00:45:12,920 --> 00:45:22,040
checks so it depends on if you use

00:45:18,950 --> 00:45:28,790
something like Psalm it tells you how

00:45:22,040 --> 00:45:31,220
much what percentage of of all the types

00:45:28,790 --> 00:45:33,380
it has inferred or understands so if

00:45:31,220 --> 00:45:35,660
that's a high number probably what

00:45:33,380 --> 00:45:37,310
you're doing it is safe to remove those

00:45:35,660 --> 00:45:40,370
slap checks and if that's a low

00:45:37,310 --> 00:45:42,340
percentage then you're probably gonna

00:45:40,370 --> 00:45:44,570
have to have some kind of compromise

00:45:42,340 --> 00:45:48,910
which probably hasn't really helped you

00:45:44,570 --> 00:45:48,910
but thank you

00:45:52,619 --> 00:45:57,730
hello a couple of questions one of them

00:45:55,480 --> 00:46:01,599
is which idea is support this right now

00:45:57,730 --> 00:46:03,160
and the other one is if the syntax is

00:46:01,599 --> 00:46:06,369
more or less the same for all the tools

00:46:03,160 --> 00:46:11,980
you know sound PHP Stan or Ori or are

00:46:06,369 --> 00:46:13,869
there major differences so the first

00:46:11,980 --> 00:46:16,359
question is unfortunately no IDE

00:46:13,869 --> 00:46:17,170
supports only none of them support like

00:46:16,359 --> 00:46:19,599
the template

00:46:17,170 --> 00:46:22,359
none of them support the array note

00:46:19,599 --> 00:46:26,530
annotation way you've got the key and

00:46:22,359 --> 00:46:30,490
the value so if anyone is working for an

00:46:26,530 --> 00:46:36,030
IDE for PHP then please can you read him

00:46:30,490 --> 00:46:39,670
and the second one is do these tools so

00:46:36,030 --> 00:46:41,619
on the face of it these they both

00:46:39,670 --> 00:46:46,900
understand each other's annotations and

00:46:41,619 --> 00:46:48,550
they act largely the same even in the

00:46:46,900 --> 00:46:51,820
examples I've done this there's a github

00:46:48,550 --> 00:46:54,160
repository third one down there if you

00:46:51,820 --> 00:46:58,930
there's about I think there's eight or

00:46:54,160 --> 00:47:00,640
nine examples and both Psalm and PHP

00:46:58,930 --> 00:47:02,440
Stan have these online playgrounds so

00:47:00,640 --> 00:47:04,150
you can take the code snippets and put

00:47:02,440 --> 00:47:07,569
it into the into the online playground

00:47:04,150 --> 00:47:09,760
and even in the relatively simple

00:47:07,569 --> 00:47:13,750
examples I've got there are a couple of

00:47:09,760 --> 00:47:19,810
differences between the tools and these

00:47:13,750 --> 00:47:21,030
things so psalm has had templates for

00:47:19,810 --> 00:47:23,730
over a year

00:47:21,030 --> 00:47:26,859
PHP Stan added them in at around

00:47:23,730 --> 00:47:29,440
December so they are it is still quite

00:47:26,859 --> 00:47:32,349
new they are really responsive if you

00:47:29,440 --> 00:47:33,819
raise issues on them and they believe

00:47:32,349 --> 00:47:38,790
there are issues they are really

00:47:33,819 --> 00:47:42,599
responsive about fixing them so and I

00:47:38,790 --> 00:47:45,990
think they will normalize towards a

00:47:42,599 --> 00:47:48,640
standard eventually and but there are

00:47:45,990 --> 00:47:52,660
subtle differences even in evening code

00:47:48,640 --> 00:47:54,460
that looks looks the same so but because

00:47:52,660 --> 00:47:57,579
they're so responsive to fixing these

00:47:54,460 --> 00:47:59,740
things you know next week they might be

00:47:57,579 --> 00:48:01,660
more aligned and I certainly know that

00:47:59,740 --> 00:48:03,340
the authors of Salman

00:48:01,660 --> 00:48:04,840
a PhD standing on the same

00:48:03,340 --> 00:48:08,920
that channel and they often kind of

00:48:04,840 --> 00:48:11,910
discuss things with each other so yes I

00:48:08,920 --> 00:48:11,910
answered your question

00:48:18,670 --> 00:48:27,090
I was one of the bank I'm all right in

00:48:23,740 --> 00:48:29,830
thinking that there's a way to add the

00:48:27,090 --> 00:48:33,460
static analyzer to an existing code base

00:48:29,830 --> 00:48:37,510
where you can say only one the static

00:48:33,460 --> 00:48:41,440
and not static in our analyzer on newly

00:48:37,510 --> 00:48:43,390
committed code so you can really moving

00:48:41,440 --> 00:48:45,150
forward but it doesn't particularly fall

00:48:43,390 --> 00:48:52,030
over when you're working with old code

00:48:45,150 --> 00:48:55,780
yeah so Psalm and PHP Stan have

00:48:52,030 --> 00:48:57,610
baselining facility and I've actually

00:48:55,780 --> 00:49:00,730
written a base liner for tools that

00:48:57,610 --> 00:49:02,560
don't have base lining facilities so you

00:49:00,730 --> 00:49:06,250
can do that and you can progressively

00:49:02,560 --> 00:49:08,260
improve the quality of your code base in

00:49:06,250 --> 00:49:10,300
that way so you can maybe you can you

00:49:08,260 --> 00:49:13,800
can run your analysis you can fix

00:49:10,300 --> 00:49:15,970
whatever issues are most critical and

00:49:13,800 --> 00:49:19,630
then you can play a baseline so you

00:49:15,970 --> 00:49:21,790
won't see those problems again and as a

00:49:19,630 --> 00:49:23,620
static analysis approach that that is

00:49:21,790 --> 00:49:25,980
very that I would advocate doing that

00:49:23,620 --> 00:49:31,090
and I've advocated that sir to everyone

00:49:25,980 --> 00:49:33,970
the issue of and it kind of goes back to

00:49:31,090 --> 00:49:36,160
the first question and if you want to

00:49:33,970 --> 00:49:39,400
apply this to if you want to apply this

00:49:36,160 --> 00:49:42,760
kind of generics analysis to be a

00:49:39,400 --> 00:49:44,350
hundred percent sure that the static

00:49:42,760 --> 00:49:45,580
analysis tool is telling you the right

00:49:44,350 --> 00:49:48,700
answers and there were no false

00:49:45,580 --> 00:49:51,040
positives and no false negatives or

00:49:48,700 --> 00:49:53,230
whatever the other way around you have

00:49:51,040 --> 00:49:57,760
to have the complete information so if

00:49:53,230 --> 00:50:00,040
you have a legacy code base then you can

00:49:57,760 --> 00:50:02,200
certainly put this information in but

00:50:00,040 --> 00:50:05,560
I'm not sure I would trust it completely

00:50:02,200 --> 00:50:08,290
because there might be bits of

00:50:05,560 --> 00:50:10,480
information that are missing and what

00:50:08,290 --> 00:50:14,130
you can try and do is if you've got a

00:50:10,480 --> 00:50:17,770
legacy code base and you're working on a

00:50:14,130 --> 00:50:20,800
contained bit of that code base if you

00:50:17,770 --> 00:50:22,960
work out the boundary so if you work out

00:50:20,800 --> 00:50:24,700
all the entry points if you've got a new

00:50:22,960 --> 00:50:26,200
a new bit of code and it's almost

00:50:24,700 --> 00:50:29,770
completely separated from anything

00:50:26,200 --> 00:50:31,540
you've done if you work out that

00:50:29,770 --> 00:50:32,480
boundary of that code and water all the

00:50:31,540 --> 00:50:36,530
other reacts

00:50:32,480 --> 00:50:38,030
entry points to that which will probably

00:50:36,530 --> 00:50:39,980
not be all the public methods and

00:50:38,030 --> 00:50:42,260
probably be a smaller space and that

00:50:39,980 --> 00:50:44,270
then if you kind of protect your

00:50:42,260 --> 00:50:47,990
boundary to that you can apply this

00:50:44,270 --> 00:50:49,670
analysis to just that chunk of code and

00:50:47,990 --> 00:50:51,560
you just need to make sure that any bits

00:50:49,670 --> 00:50:54,260
where you're communicating from legacy

00:50:51,560 --> 00:50:56,540
code base in to this new function into

00:50:54,260 --> 00:50:59,000
this new bit you could use things like

00:50:56,540 --> 00:51:01,160
assertions to check you know the data

00:50:59,000 --> 00:51:03,700
really is on the genetics that the data

00:51:01,160 --> 00:51:07,010
really is what you expect it to be and

00:51:03,700 --> 00:51:08,690
but if you're just if you've got a huge

00:51:07,010 --> 00:51:10,849
code base and you're just adding little

00:51:08,690 --> 00:51:13,760
bits here and there but the base lining

00:51:10,849 --> 00:51:17,420
will definitely help but you can't

00:51:13,760 --> 00:51:19,880
guarantee what I'm proposing here but

00:51:17,420 --> 00:51:33,050
you should you should still do it that

00:51:19,880 --> 00:51:36,740
does that make sense yeah just a small

00:51:33,050 --> 00:51:39,380
comment so I'm also working on a legacy

00:51:36,740 --> 00:51:41,119
code base and I'm using fan this one's a

00:51:39,380 --> 00:51:43,160
comment that it also has pretty good

00:51:41,119 --> 00:51:45,770
directors for disabling lots of its

00:51:43,160 --> 00:51:47,180
rules in a directory basis so that's a

00:51:45,770 --> 00:51:49,490
really nice ways that have gradually

00:51:47,180 --> 00:51:52,010
adopted in your code base so you can say

00:51:49,490 --> 00:51:53,319
ignore everything in my 10 top level

00:51:52,010 --> 00:51:55,730
directories and then sort of slowly

00:51:53,319 --> 00:51:58,510
enable one rule at a time for someone

00:51:55,730 --> 00:51:59,720
small sub component of your application

00:51:58,510 --> 00:52:02,630
yes

00:51:59,720 --> 00:52:04,970
and you can you can do approach if does

00:52:02,630 --> 00:52:08,329
I haven't used fan myself does it have a

00:52:04,970 --> 00:52:11,119
baseline facility oh can you define what

00:52:08,329 --> 00:52:14,510
that is a baseline so can you take all

00:52:11,119 --> 00:52:15,829
your results that you have now so let's

00:52:14,510 --> 00:52:18,020
say it looks to your codebase and it's

00:52:15,829 --> 00:52:19,760
found a thousand issues can you say I

00:52:18,020 --> 00:52:22,760
want to make that my baseline and I only

00:52:19,760 --> 00:52:24,740
want you to add in you tell me about new

00:52:22,760 --> 00:52:26,569
issues yeah that's right yes so you can

00:52:24,740 --> 00:52:28,130
store sort of an issues directory where

00:52:26,569 --> 00:52:30,050
it'll tell you like these statements in

00:52:28,130 --> 00:52:31,490
these lines and sort of the exception to

00:52:30,050 --> 00:52:34,339
the rule anything new it'll mark as a

00:52:31,490 --> 00:52:38,540
Russian of that yeah okay and again this

00:52:34,339 --> 00:52:40,760
is an approach you can do and but it's

00:52:38,540 --> 00:52:42,319
kind of like the last I mean it's a bit

00:52:40,760 --> 00:52:43,730
I lastly you still and there's an issue

00:52:42,319 --> 00:52:44,630
entire if you want to do what I'm

00:52:43,730 --> 00:52:46,170
proposing with the generics you

00:52:44,630 --> 00:52:49,340
everything needs to be known

00:52:46,170 --> 00:52:52,350
so you'll always have these issues with

00:52:49,340 --> 00:52:53,760
legacy code bases where you've you're

00:52:52,350 --> 00:52:58,170
ignoring bits of it or you annoying

00:52:53,760 --> 00:53:05,940
existing issues I don't if that answers

00:52:58,170 --> 00:53:07,890
a question or okay I mean I'm happy to

00:53:05,940 --> 00:53:09,240
discuss this I just catch me around the

00:53:07,890 --> 00:53:13,470
conference if you want to ask any

00:53:09,240 --> 00:53:16,500
questions other anymore okay and there's

00:53:13,470 --> 00:53:19,080
a jointing talk please let me know how

00:53:16,500 --> 00:53:21,720
it can be made better and/or come and

00:53:19,080 --> 00:53:26,070
see me the slides there on my website

00:53:21,720 --> 00:53:28,680
have a look at the the code snippets in

00:53:26,070 --> 00:53:31,050
in the github repo if this is of

00:53:28,680 --> 00:53:33,680
interest and definitely check out the

00:53:31,050 --> 00:53:37,490
static analyzers if you haven't already

00:53:33,680 --> 00:53:37,490

YouTube URL: https://www.youtube.com/watch?v=N2PENQpQVjQ


