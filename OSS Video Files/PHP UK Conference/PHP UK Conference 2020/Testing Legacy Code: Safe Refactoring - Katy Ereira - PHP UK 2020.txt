Title: Testing Legacy Code: Safe Refactoring - Katy Ereira - PHP UK 2020
Publication date: 2020-03-11
Playlist: PHP UK Conference 2020
Description: 
	I can't test this code because it's legacy. I need to update the code to make it testable. How can I manage that, without breaking existing functionality? I'll need to write some tests, but... argh!
Captions: 
	00:00:02,760 --> 00:00:08,180
okay so I'm here today to talk to

00:00:05,069 --> 00:00:12,510
everyone about your most favorite thing

00:00:08,180 --> 00:00:14,039
legacy code no matter where you are on

00:00:12,510 --> 00:00:15,690
your software engineering journey

00:00:14,039 --> 00:00:17,779
whether you're a newbie or seasoned

00:00:15,690 --> 00:00:20,099
developer you are going to encounter

00:00:17,779 --> 00:00:22,730
legacy code it's not a case of if it's

00:00:20,099 --> 00:00:25,769
when it can be really overwhelming

00:00:22,730 --> 00:00:27,720
though legacy code is horrible when you

00:00:25,769 --> 00:00:30,179
see it it just confuses you you don't

00:00:27,720 --> 00:00:33,329
know what's going on it's just yeah

00:00:30,179 --> 00:00:35,670
horrible no one yeah okay so today I

00:00:33,329 --> 00:00:38,910
want to talk to you about a lot of

00:00:35,670 --> 00:00:41,879
tactics to help you tame the beasts that

00:00:38,910 --> 00:00:43,829
is legacy code and hopefully you can

00:00:41,879 --> 00:00:46,670
start viewing it as an asset to your

00:00:43,829 --> 00:00:48,989
company and not just something horrible

00:00:46,670 --> 00:00:52,109
so first of all I want to talk

00:00:48,989 --> 00:00:54,809
what exactly is legacy code there are a

00:00:52,109 --> 00:00:56,489
few definitions for legacy code and so

00:00:54,809 --> 00:00:57,840
legacy code in my view is any code that

00:00:56,489 --> 00:00:59,969
you didn't write just now and I mean

00:00:57,840 --> 00:01:01,530
within the past five minutes okay like

00:00:59,969 --> 00:01:04,290
it becomes the legacy pretty much

00:01:01,530 --> 00:01:06,590
immediately it can also be code that's

00:01:04,290 --> 00:01:09,300
resulting from incorrect assumptions

00:01:06,590 --> 00:01:13,170
code that was built using unsupported

00:01:09,300 --> 00:01:17,600
technology for example PHP 5.6 now and

00:01:13,170 --> 00:01:19,170
also code there isn't tested and

00:01:17,600 --> 00:01:21,390
refactoring is something that we're

00:01:19,170 --> 00:01:24,510
going to do a bit off and what is

00:01:21,390 --> 00:01:27,060
refactoring it is updating an existing

00:01:24,510 --> 00:01:28,380
code base but in such a way that he

00:01:27,060 --> 00:01:30,990
doesn't actually change the application

00:01:28,380 --> 00:01:34,020
logic you can use it to improve the code

00:01:30,990 --> 00:01:38,100
structure and you usually approach it in

00:01:34,020 --> 00:01:41,520
very small incremental steps why would

00:01:38,100 --> 00:01:44,310
you refactor to improve other developers

00:01:41,520 --> 00:01:47,730
understanding of the code that improves

00:01:44,310 --> 00:01:48,900
developer velocity get more done you can

00:01:47,730 --> 00:01:50,850
also improve the applications

00:01:48,900 --> 00:01:52,920
performance so for example if you're

00:01:50,850 --> 00:01:54,150
changing in algorithms lightly see it

00:01:52,920 --> 00:01:57,720
achieve the same result but in a more

00:01:54,150 --> 00:01:59,520
performant manner you can use it to

00:01:57,720 --> 00:02:02,210
introduce new technology for example

00:01:59,520 --> 00:02:04,530
upgrading your applications to PHP 7 and

00:02:02,210 --> 00:02:06,660
it also helps you to better accommodate

00:02:04,530 --> 00:02:10,410
changes in your code when things are

00:02:06,660 --> 00:02:12,659
just generally a bit more sane unit

00:02:10,410 --> 00:02:15,730
testing is also why I'm going to cover

00:02:12,659 --> 00:02:18,340
today unit testing it

00:02:15,730 --> 00:02:20,620
a verification that each individual unit

00:02:18,340 --> 00:02:23,950
of your application works as you

00:02:20,620 --> 00:02:26,080
intended it to a unit in definition of

00:02:23,950 --> 00:02:28,620
unit would be a component part of your

00:02:26,080 --> 00:02:33,459
software application so for example a

00:02:28,620 --> 00:02:35,170
function or a piece of behavior and just

00:02:33,459 --> 00:02:36,790
a small note here it's that I am going

00:02:35,170 --> 00:02:38,560
to be talking about unit testing during

00:02:36,790 --> 00:02:40,390
this presentation but unit testing is

00:02:38,560 --> 00:02:42,129
not a substitute for all other types of

00:02:40,390 --> 00:02:43,959
testing there are lots of different ways

00:02:42,129 --> 00:02:46,000
to test your code and your application

00:02:43,959 --> 00:02:46,959
and this is just one of them so please

00:02:46,000 --> 00:02:52,000
bear this in mind

00:02:46,959 --> 00:02:54,129
I love unit testing because it helps you

00:02:52,000 --> 00:02:57,280
to document your system you can look at

00:02:54,129 --> 00:03:00,069
the test and see what people intended to

00:02:57,280 --> 00:03:02,109
be happening in your application it also

00:03:00,069 --> 00:03:03,760
helps you to prevent regressions so if

00:03:02,109 --> 00:03:05,140
you change something in your code and it

00:03:03,760 --> 00:03:07,299
breaks something your unit tests are

00:03:05,140 --> 00:03:09,040
hopefully going to alert you to that you

00:03:07,299 --> 00:03:11,019
can also use unit tests to test

00:03:09,040 --> 00:03:13,569
integration with new technology so if

00:03:11,019 --> 00:03:14,590
you're upgrading your application and it

00:03:13,569 --> 00:03:18,519
also helps you validate your product

00:03:14,590 --> 00:03:21,280
requirements but there's a slight

00:03:18,519 --> 00:03:28,299
paradox when it comes to unit testing

00:03:21,280 --> 00:03:30,700
and legacy code in that you can't write

00:03:28,299 --> 00:03:33,430
the tests for your code because it's

00:03:30,700 --> 00:03:36,280
legacy and it's untested and it's

00:03:33,430 --> 00:03:38,590
horrible and it's really difficult and

00:03:36,280 --> 00:03:40,450
you need to refactor it but you can't

00:03:38,590 --> 00:03:42,220
refactor it either until it's tested

00:03:40,450 --> 00:03:46,060
because things could go wrong and be

00:03:42,220 --> 00:03:48,489
horrible so I've got a solution for you

00:03:46,060 --> 00:03:53,799
on we're gonna rewrite the entire code

00:03:48,489 --> 00:03:55,650
base sounds like a great idea no don't

00:03:53,799 --> 00:03:59,319
do that please

00:03:55,650 --> 00:04:01,959
that is a false economy I have a better

00:03:59,319 --> 00:04:03,879
solution for you all and we're going to

00:04:01,959 --> 00:04:06,579
form just enough refactoring on our

00:04:03,879 --> 00:04:09,190
existing code base so that we can make

00:04:06,579 --> 00:04:11,769
the code testable then we're going to

00:04:09,190 --> 00:04:15,599
write tests for our code lather rinse

00:04:11,769 --> 00:04:15,599
repeat and profit

00:04:18,380 --> 00:04:22,640
we are at a PHP conference if I'm gonna

00:04:20,780 --> 00:04:24,560
make a few assumptions I'm assuming the

00:04:22,640 --> 00:04:27,260
PHP developers and do you have a

00:04:24,560 --> 00:04:32,950
customer terminal with composer and I'm

00:04:27,260 --> 00:04:36,500
going to introduce a few tools so sorry

00:04:32,950 --> 00:04:39,940
the main unit testing framework in the

00:04:36,500 --> 00:04:39,940
PHP ecosystem is PHP unit

00:04:40,130 --> 00:04:46,640
I didn't update this slide I believe PHP

00:04:43,400 --> 00:04:48,830
unit 9 is out now but there are older

00:04:46,640 --> 00:04:51,230
versions so even if your PHP code base

00:04:48,830 --> 00:04:53,030
happens to be a particularly legacy 5.6

00:04:51,230 --> 00:04:55,160
for example there are still versions

00:04:53,030 --> 00:04:57,320
that you can use so you can still go and

00:04:55,160 --> 00:05:00,860
implement the techniques that I'm going

00:04:57,320 --> 00:05:03,500
to be explaining today it's really easy

00:05:00,860 --> 00:05:05,240
to install if you have composer you want

00:05:03,500 --> 00:05:06,740
to do composer required - slash dev

00:05:05,240 --> 00:05:10,910
because you don't need unit tests in

00:05:06,740 --> 00:05:12,320
production PHP unit PHP unit and then

00:05:10,910 --> 00:05:15,710
you can test that it works using vendor

00:05:12,320 --> 00:05:21,080
bin PHP unit - - version should give you

00:05:15,710 --> 00:05:22,700
doubt fit display so a unit test so

00:05:21,080 --> 00:05:25,460
people that haven't done much unit

00:05:22,700 --> 00:05:28,810
testing before I'll briefly explain what

00:05:25,460 --> 00:05:32,660
a unit test looks like so a unit test is

00:05:28,810 --> 00:05:37,400
usually a class that extends the PHP

00:05:32,660 --> 00:05:40,250
unit base test case and inside this test

00:05:37,400 --> 00:05:44,180
class we have a group of functions and

00:05:40,250 --> 00:05:46,970
each function is a test and you usually

00:05:44,180 --> 00:05:49,100
have for example a class a test class

00:05:46,970 --> 00:05:51,590
that is testing one of your classes in

00:05:49,100 --> 00:05:53,720
your actual application and then each

00:05:51,590 --> 00:05:56,270
function is testing each different

00:05:53,720 --> 00:05:58,850
behavior of that class so in this

00:05:56,270 --> 00:06:00,860
example we have example test that has

00:05:58,850 --> 00:06:03,920
one test in it and it's to test the

00:06:00,860 --> 00:06:06,050
output or the result of some function so

00:06:03,920 --> 00:06:07,820
within our test function we're running

00:06:06,050 --> 00:06:10,280
the thing that we want to test that's

00:06:07,820 --> 00:06:12,350
the underlined sum function and we want

00:06:10,280 --> 00:06:16,130
to assert that when we do run that

00:06:12,350 --> 00:06:18,950
function it returns the value of true so

00:06:16,130 --> 00:06:22,160
if we were to run this test hopefully we

00:06:18,950 --> 00:06:25,100
would get the correct output and to run

00:06:22,160 --> 00:06:27,110
our tests and I've put all of my tests

00:06:25,100 --> 00:06:29,630
in a directory called tests so I'm doing

00:06:27,110 --> 00:06:30,680
vendor bin PHP unit tests to tell it

00:06:29,630 --> 00:06:32,310
where my tests are and I should run it

00:06:30,680 --> 00:06:33,930
and you get a nice

00:06:32,310 --> 00:06:39,990
it's a little dot to say yet the test

00:06:33,930 --> 00:06:42,180
pass everything's working great there's

00:06:39,990 --> 00:06:46,890
another thing that I want to introduce

00:06:42,180 --> 00:06:49,800
and that it's mocking mocking is really

00:06:46,890 --> 00:06:53,190
useful in unit testing is it enables you

00:06:49,800 --> 00:06:55,290
to create test doubles so if you're

00:06:53,190 --> 00:06:57,210
testing one particular part of your

00:06:55,290 --> 00:06:58,770
application it probably is going to

00:06:57,210 --> 00:06:59,850
depend on other parts of your

00:06:58,770 --> 00:07:02,130
application because nothing really

00:06:59,850 --> 00:07:04,440
exists in a vacuum and you don't

00:07:02,130 --> 00:07:06,810
necessarily want to use real objects in

00:07:04,440 --> 00:07:07,860
your tests you might have unintended

00:07:06,810 --> 00:07:10,440
consequences

00:07:07,860 --> 00:07:12,660
or behaves strangely or just be overly

00:07:10,440 --> 00:07:16,980
complex so mocking allows you to create

00:07:12,660 --> 00:07:18,920
test versions of objects in your code it

00:07:16,980 --> 00:07:21,570
helps you to verify the behavior

00:07:18,920 --> 00:07:24,810
regardless of what that test object is

00:07:21,570 --> 00:07:29,700
doing and isolates what is exactly that

00:07:24,810 --> 00:07:34,650
you're trying to test a bit of a caution

00:07:29,700 --> 00:07:38,460
when it comes to mocking it's nice to

00:07:34,650 --> 00:07:41,850
mock dependencies when you need to but

00:07:38,460 --> 00:07:43,560
try not to mock everything because your

00:07:41,850 --> 00:07:46,050
code does not exist in a vacuum and

00:07:43,560 --> 00:07:49,890
sometimes you mock things and think the

00:07:46,050 --> 00:07:51,780
protests pass only because you really

00:07:49,890 --> 00:07:54,300
told them to pass and not because they

00:07:51,780 --> 00:07:55,560
actually would in a real world scenario

00:07:54,300 --> 00:07:58,170
and that's the morning about

00:07:55,560 --> 00:08:01,170
tautological testing and which often

00:07:58,170 --> 00:08:04,290
happens if you were to mock the system

00:08:01,170 --> 00:08:07,100
under test please under no circumstances

00:08:04,290 --> 00:08:09,870
no matter how tempting it is do this

00:08:07,100 --> 00:08:16,680
because then you're not really testing

00:08:09,870 --> 00:08:19,350
anything so PHP unit does have some

00:08:16,680 --> 00:08:23,070
mocking abilities built in already but I

00:08:19,350 --> 00:08:26,400
prefer to use this library mockery I

00:08:23,070 --> 00:08:28,860
find it easy to understand it to use and

00:08:26,400 --> 00:08:30,750
you can install it again using composure

00:08:28,860 --> 00:08:31,800
composure required - - dev mockery

00:08:30,750 --> 00:08:32,790
mockery cuz hopefully you're not

00:08:31,800 --> 00:08:36,450
creating more cob jects in your

00:08:32,790 --> 00:08:39,830
application code and this is how you

00:08:36,450 --> 00:08:43,920
would create a test object using mockery

00:08:39,830 --> 00:08:45,150
you do mockery code on : mock and then

00:08:43,920 --> 00:08:46,950
pass it in then

00:08:45,150 --> 00:08:48,690
name of the class that you want to mock

00:08:46,950 --> 00:08:50,880
and it will create a version of that

00:08:48,690 --> 00:08:52,140
class for the correct types so possibly

00:08:50,880 --> 00:08:58,310
your type printing but it is actually a

00:08:52,140 --> 00:09:01,980
just a dummy and you can perform

00:08:58,310 --> 00:09:04,590
expectations on your mock objects so in

00:09:01,980 --> 00:09:06,120
this instance we're saying that at some

00:09:04,590 --> 00:09:09,000
point during the execution of our code

00:09:06,120 --> 00:09:11,460
this mock object should receive a call

00:09:09,000 --> 00:09:13,110
to the method method it should only

00:09:11,460 --> 00:09:15,540
receive a call to that method once and

00:09:13,110 --> 00:09:18,090
when it does it should always return the

00:09:15,540 --> 00:09:19,980
value true this is not asserting on the

00:09:18,090 --> 00:09:22,680
return value of that method we are

00:09:19,980 --> 00:09:26,490
telling it that it will return true and

00:09:22,680 --> 00:09:31,620
that allows us to essentially force the

00:09:26,490 --> 00:09:32,880
flow of our application when you're

00:09:31,620 --> 00:09:36,240
using mockery you have to remember to

00:09:32,880 --> 00:09:39,150
close it this is just a side thing if

00:09:36,240 --> 00:09:41,190
you don't close your mockery after

00:09:39,150 --> 00:09:42,300
you've done it it won't count the number

00:09:41,190 --> 00:09:45,030
of times the things have been called and

00:09:42,300 --> 00:09:54,660
so you'll get failed tests so just

00:09:45,030 --> 00:09:58,470
something to bear in mind just a

00:09:54,660 --> 00:10:00,420
disclaimer the following examples are

00:09:58,470 --> 00:10:02,160
going to be deliberately simple you're

00:10:00,420 --> 00:10:04,920
probably never gonna see anything like

00:10:02,160 --> 00:10:07,380
this in your real application code I've

00:10:04,920 --> 00:10:09,510
made them simple so that hopefully you

00:10:07,380 --> 00:10:11,340
can learn to identify the patterns that

00:10:09,510 --> 00:10:13,440
are gonna be a problematic when it comes

00:10:11,340 --> 00:10:15,120
to legacy code and when you've learned

00:10:13,440 --> 00:10:17,280
to identify them you can apply the

00:10:15,120 --> 00:10:21,150
techniques that I will explain to you to

00:10:17,280 --> 00:10:22,800
tame your legacy code so I'm going to go

00:10:21,150 --> 00:10:26,190
through a bunch of different different

00:10:22,800 --> 00:10:30,150
scenarios basic code

00:10:26,190 --> 00:10:32,420
so the first tricky testing scenario

00:10:30,150 --> 00:10:39,480
that we're going to cover today is

00:10:32,420 --> 00:10:41,790
interfering output and when I say

00:10:39,480 --> 00:10:46,380
interfering output I mean something like

00:10:41,790 --> 00:10:48,900
an echo or a print in your code so here

00:10:46,380 --> 00:10:51,150
we have a function yodel that if you

00:10:48,900 --> 00:10:53,280
parse it a tune will echo that tune back

00:10:51,150 --> 00:10:56,940
to you otherwise it'll just start its

00:10:53,280 --> 00:10:59,149
own little yodel great so how are we

00:10:56,940 --> 00:11:02,510
gonna test this

00:10:59,149 --> 00:11:05,190
there are two possible branches to this

00:11:02,510 --> 00:11:07,110
we can either test with what we can test

00:11:05,190 --> 00:11:09,420
what happens when we don't give it

00:11:07,110 --> 00:11:10,860
something to echo and we can test what

00:11:09,420 --> 00:11:13,610
should happen when we do give it

00:11:10,860 --> 00:11:17,160
something to echo so we've created only

00:11:13,610 --> 00:11:18,810
unit testing class giving it a name and

00:11:17,160 --> 00:11:20,279
we've got our two methods in there each

00:11:18,810 --> 00:11:22,500
one is a different unit that it's

00:11:20,279 --> 00:11:24,930
testing and in the first one we're gonna

00:11:22,500 --> 00:11:26,459
test our yodel without being par setting

00:11:24,930 --> 00:11:28,760
parameters and then the second one we're

00:11:26,459 --> 00:11:30,959
gonna test the echo yodel sounds great

00:11:28,760 --> 00:11:35,010
I'm gonna run these tests and something

00:11:30,959 --> 00:11:37,620
weird happens the output is actually in

00:11:35,010 --> 00:11:38,970
our test runner there's also another

00:11:37,620 --> 00:11:40,860
thing to note here is that it says there

00:11:38,970 --> 00:11:43,470
were too risky tests because if you

00:11:40,860 --> 00:11:45,570
notice in our example we're not actually

00:11:43,470 --> 00:11:47,580
testing anything we're just executing

00:11:45,570 --> 00:11:49,740
these methods nothing's actually being

00:11:47,580 --> 00:11:55,050
asserted so that's why it's considered

00:11:49,740 --> 00:11:57,600
risky so how do we deal with this kind

00:11:55,050 --> 00:11:59,610
of scenario and and just imagine for a

00:11:57,600 --> 00:12:00,990
moment that this you might encounter in

00:11:59,610 --> 00:12:04,170
an old application where you haven't

00:12:00,990 --> 00:12:05,880
really separated concerns so for example

00:12:04,170 --> 00:12:08,700
if you've got a render function that

00:12:05,880 --> 00:12:10,350
ends up printing an entire HTML page and

00:12:08,700 --> 00:12:15,620
then you get that in your test Runner

00:12:10,350 --> 00:12:18,450
and it's very confusing and long so

00:12:15,620 --> 00:12:20,250
anyway first off we're going to prevent

00:12:18,450 --> 00:12:24,480
that from happening we're gonna stop our

00:12:20,250 --> 00:12:26,850
output being like vomited out into our

00:12:24,480 --> 00:12:29,640
test runner for starters we're gonna try

00:12:26,850 --> 00:12:31,830
and cut to that output so that we can

00:12:29,640 --> 00:12:37,680
actually perform assertions on our

00:12:31,830 --> 00:12:40,980
capture output so PHP has the output

00:12:37,680 --> 00:12:43,800
buffer which we can start up using OB

00:12:40,980 --> 00:12:45,150
underscore starts and anything executed

00:12:43,800 --> 00:12:46,950
after this point anything that is

00:12:45,150 --> 00:12:50,730
printed or echoed will be captured by

00:12:46,950 --> 00:12:54,000
the output buffer and then we can

00:12:50,730 --> 00:12:55,350
sandwich it between OB and clean which

00:12:54,000 --> 00:12:56,279
is where it will say okay we don't we're

00:12:55,350 --> 00:12:59,760
not interested in anything that's

00:12:56,279 --> 00:13:02,250
outputted after this point and to get

00:12:59,760 --> 00:13:04,920
the contents of our output buffer we're

00:13:02,250 --> 00:13:06,570
going to use OB get contents and we're

00:13:04,920 --> 00:13:08,900
going to assign that to our variable

00:13:06,570 --> 00:13:08,900
output

00:13:09,540 --> 00:13:12,180
and now we have something that we can

00:13:10,740 --> 00:13:15,240
actually assert on because we've got a

00:13:12,180 --> 00:13:15,959
variable with some data in it so we can

00:13:15,240 --> 00:13:19,920
use phpunit

00:13:15,959 --> 00:13:26,100
and say this assert equals only output

00:13:19,920 --> 00:13:28,380
and our tests pass similarly we can do

00:13:26,100 --> 00:13:30,810
the same thing for our other branch

00:13:28,380 --> 00:13:32,790
alternative branch where we are passing

00:13:30,810 --> 00:13:35,600
it you ought to echo back at us we can

00:13:32,790 --> 00:13:44,699
assert on that value and it is also

00:13:35,600 --> 00:13:46,709
successful and passes another thing the

00:13:44,699 --> 00:13:49,279
second thing you're probably likely to

00:13:46,709 --> 00:13:54,120
encounter in your legacy code it's a

00:13:49,279 --> 00:13:55,709
static method calls there are some

00:13:54,120 --> 00:13:58,110
reasons that people don't like static

00:13:55,709 --> 00:14:02,310
methods and the difficulty to test them

00:13:58,110 --> 00:14:02,970
is probably one of them so anyway we are

00:14:02,310 --> 00:14:06,690
Vegeta

00:14:02,970 --> 00:14:09,029
and we have a scanner and we seen Goku

00:14:06,690 --> 00:14:12,120
and we want to see what his power level

00:14:09,029 --> 00:14:13,740
is and if his power level is over 9000

00:14:12,120 --> 00:14:15,720
we're gonna be like it's over 9000

00:14:13,740 --> 00:14:18,329
otherwise it's like our case you

00:14:15,720 --> 00:14:20,399
suppress one so this is our method i'll

00:14:18,329 --> 00:14:21,810
get power level method that gets the

00:14:20,399 --> 00:14:26,910
result of go because power level and

00:14:21,810 --> 00:14:29,790
returns the correct response so again

00:14:26,910 --> 00:14:32,220
we're going to create our test class and

00:14:29,790 --> 00:14:34,680
we've got two possible scenarios here

00:14:32,220 --> 00:14:37,050
either Goku's power level is over 9000

00:14:34,680 --> 00:14:39,149
or it's not so we're gonna call power

00:14:37,050 --> 00:14:42,000
level and you know we're gonna turn on

00:14:39,149 --> 00:14:46,079
the result now if we actually look at

00:14:42,000 --> 00:14:47,310
Goku the power level method the static

00:14:46,079 --> 00:14:50,370
power level method on Goku is always

00:14:47,310 --> 00:14:53,279
going to return five thousand which

00:14:50,370 --> 00:14:54,839
means this is fine because five thousand

00:14:53,279 --> 00:14:56,790
is under 9000 so he's always gonna

00:14:54,839 --> 00:14:59,430
return five thousand and it's gonna be

00:14:56,790 --> 00:15:01,769
suppressed but if we want to test the

00:14:59,430 --> 00:15:03,149
branch of it's over 9,000 then it's not

00:15:01,769 --> 00:15:07,259
gonna work because it's never gonna be

00:15:03,149 --> 00:15:09,899
here of 9,000 so how do we deal with

00:15:07,259 --> 00:15:13,319
this kind of scenario we're going to

00:15:09,899 --> 00:15:16,220
create a new mock Goku using mockery

00:15:13,319 --> 00:15:18,810
aliasing nice bring that in a minute

00:15:16,220 --> 00:15:20,670
we're gonna force the return value of

00:15:18,810 --> 00:15:21,870
kokis power level to be nine thousand

00:15:20,670 --> 00:15:22,600
and one which is indeed over nine

00:15:21,870 --> 00:15:24,890
thousand

00:15:22,600 --> 00:15:26,209
and we're gonna have to run our tests

00:15:24,890 --> 00:15:29,480
and separate processes it's kind of a

00:15:26,209 --> 00:15:32,230
weird thing I'll explain in a minute so

00:15:29,480 --> 00:15:36,470
we're gonna create our Super Saiyan Goku

00:15:32,230 --> 00:15:38,750
using mockery Mach alias : and then his

00:15:36,470 --> 00:15:41,870
class name they're probably with

00:15:38,750 --> 00:15:43,399
aliasing is that it completely overrides

00:15:41,870 --> 00:15:45,440
the classes that already exist in your

00:15:43,399 --> 00:15:47,149
application so you can only create an

00:15:45,440 --> 00:15:49,040
alias if your class hasn't already been

00:15:47,149 --> 00:15:51,980
loaded for example via Auto loading

00:15:49,040 --> 00:15:54,050
which is why you can't use the k1 :

00:15:51,980 --> 00:15:56,690
class magic thing you actually have to

00:15:54,050 --> 00:16:01,430
type the fully qualified name in the

00:15:56,690 --> 00:16:05,120
alias so here yeah we have a Super

00:16:01,430 --> 00:16:06,320
Saiyan Goku we're going to say that at

00:16:05,120 --> 00:16:07,459
some point during the execution of this

00:16:06,320 --> 00:16:08,779
code it's going to receive a call to

00:16:07,459 --> 00:16:16,399
power level and when it does its get a

00:16:08,779 --> 00:16:19,670
return 9010 one yeah now our test is

00:16:16,399 --> 00:16:25,640
successful so we can we've tested our

00:16:19,670 --> 00:16:28,970
two branches so yeah and now about using

00:16:25,640 --> 00:16:31,339
alias because it does override the

00:16:28,970 --> 00:16:37,279
classes in your application it's kind of

00:16:31,339 --> 00:16:39,380
not recommended so yeah and this is this

00:16:37,279 --> 00:16:40,880
is from the mockery documentation it

00:16:39,380 --> 00:16:41,899
clearly says that even though it is

00:16:40,880 --> 00:16:43,279
supported that you probably shouldn't

00:16:41,899 --> 00:16:47,690
use that so there there isn't there are

00:16:43,279 --> 00:16:48,890
a couple of other ways to solve this but

00:16:47,690 --> 00:16:52,370
the problem that it's going to present

00:16:48,890 --> 00:16:53,959
you is that when you run your tests it's

00:16:52,370 --> 00:16:55,279
probably getting complain there because

00:16:53,959 --> 00:16:56,779
you have some tests later that wants to

00:16:55,279 --> 00:16:58,910
use the actual real class and not the

00:16:56,779 --> 00:17:01,010
class that you created that's a mock so

00:16:58,910 --> 00:17:02,690
it's gonna complain oh this class

00:17:01,010 --> 00:17:04,579
already exists you can't do anything so

00:17:02,690 --> 00:17:07,520
what you'll end up doing is having to

00:17:04,579 --> 00:17:10,730
run the tests in your mocked class in a

00:17:07,520 --> 00:17:12,559
separate process and disable the global

00:17:10,730 --> 00:17:14,660
state so that it forgets that you've

00:17:12,559 --> 00:17:17,630
mocked the class after it runs this test

00:17:14,660 --> 00:17:21,890
we which is fine it works but it's very

00:17:17,630 --> 00:17:24,589
very slow so not great but you know if

00:17:21,890 --> 00:17:25,760
this gets you one step closer to testing

00:17:24,589 --> 00:17:27,970
your legacy code then it's real good

00:17:25,760 --> 00:17:27,970
right

00:17:30,210 --> 00:17:35,850
the third thing that we're going to

00:17:33,690 --> 00:17:40,850
consider today is hard-coded

00:17:35,850 --> 00:17:44,429
dependencies such as this

00:17:40,850 --> 00:17:46,200
we're in Britain I'm British and my

00:17:44,429 --> 00:17:48,539
outlook on life depends a lot on what

00:17:46,200 --> 00:17:52,499
the weather is like which is to be fair

00:17:48,539 --> 00:17:55,320
mainly gray and horrible so I have a

00:17:52,499 --> 00:17:57,600
method here get outlook which creates a

00:17:55,320 --> 00:17:58,950
new weather forecast and it looks at the

00:17:57,600 --> 00:18:00,830
forecast and if it's sunny then it feels

00:17:58,950 --> 00:18:02,909
like my class are full I'm great and

00:18:00,830 --> 00:18:04,279
otherwise my glass feels like it's

00:18:02,909 --> 00:18:06,480
half-empty and I'm kind of a pessimist

00:18:04,279 --> 00:18:08,519
and it's getting returned the value the

00:18:06,480 --> 00:18:13,289
glass is half empty or full depending on

00:18:08,519 --> 00:18:14,909
what the weather forecast is great well

00:18:13,289 --> 00:18:16,409
the problem me is my weather forecast is

00:18:14,909 --> 00:18:18,259
just about as good as any real rebel

00:18:16,409 --> 00:18:20,490
forecast admit it's pretty round and

00:18:18,259 --> 00:18:22,200
sometimes it's sunny sometimes it's not

00:18:20,490 --> 00:18:25,259
sometimes it's correct sometimes it's

00:18:22,200 --> 00:18:28,309
not and yeah all sunny is sunny methods

00:18:25,259 --> 00:18:30,330
and returns a random boolean value great

00:18:28,309 --> 00:18:32,249
but we all want to test our two

00:18:30,330 --> 00:18:34,440
scenarios whether our glass half-full or

00:18:32,249 --> 00:18:38,850
glass is half-empty we need to get the

00:18:34,440 --> 00:18:41,970
result of our outlook and assert on that

00:18:38,850 --> 00:18:43,139
result but half the time these tests are

00:18:41,970 --> 00:18:46,440
gonna pass and half the time they're

00:18:43,139 --> 00:18:47,759
gonna fail which isn't great because

00:18:46,440 --> 00:18:52,169
behind all our tests to be a bit

00:18:47,759 --> 00:18:54,179
consistent and so yeah we're going to

00:18:52,169 --> 00:18:56,970
look again to mockery and we're gonna

00:18:54,179 --> 00:18:58,679
mock all weather forecasts using a

00:18:56,970 --> 00:19:02,460
mockery over right this time

00:18:58,679 --> 00:19:04,289
not alias we're gonna force the return

00:19:02,460 --> 00:19:05,700
value of is sunny to be true or false

00:19:04,289 --> 00:19:08,399
depending on what branch that we want to

00:19:05,700 --> 00:19:10,710
test and we can perform a certain space

00:19:08,399 --> 00:19:12,539
on those mocked return values and again

00:19:10,710 --> 00:19:14,940
we're gonna have to look a run your

00:19:12,539 --> 00:19:18,210
tests in separate processes because

00:19:14,940 --> 00:19:20,909
mockery override intercepts a class on

00:19:18,210 --> 00:19:22,769
creation so you would use an override

00:19:20,909 --> 00:19:24,149
for non static methods when you're

00:19:22,769 --> 00:19:26,700
creating your hard-coded dependency on

00:19:24,149 --> 00:19:28,350
the fly but you would use alias for

00:19:26,700 --> 00:19:30,809
static methods because alias creates a

00:19:28,350 --> 00:19:36,019
whole new class and override intercepts

00:19:30,809 --> 00:19:38,609
existing class and turns into a mock so

00:19:36,019 --> 00:19:41,700
here's mockery come in we're gonna use

00:19:38,609 --> 00:19:43,760
overload weather forecast you can use

00:19:41,700 --> 00:19:44,990
the magic Kuro : class

00:19:43,760 --> 00:19:46,010
you don't have to type out the fully

00:19:44,990 --> 00:19:47,990
qualified name because it's an

00:19:46,010 --> 00:19:51,320
interceptor rather than the creation of

00:19:47,990 --> 00:19:52,640
a class and we're going to say that at

00:19:51,320 --> 00:19:54,650
some point it should receive a call to

00:19:52,640 --> 00:19:57,560
is sunny and when it does it should

00:19:54,650 --> 00:19:59,810
return true and in that case our glass

00:19:57,560 --> 00:20:01,970
should be half full great that works and

00:19:59,810 --> 00:20:03,080
again the other way around if we want to

00:20:01,970 --> 00:20:05,270
test the other branch we're gonna say oh

00:20:03,080 --> 00:20:06,340
it's gonna return false and our glass is

00:20:05,270 --> 00:20:09,830
half empty

00:20:06,340 --> 00:20:10,940
right but again you're gonna probably

00:20:09,830 --> 00:20:12,740
find that you don't have to run your

00:20:10,940 --> 00:20:14,090
test in a separate process because there

00:20:12,740 --> 00:20:16,280
were probably other tests in your suite

00:20:14,090 --> 00:20:19,100
that are testing the forecast you don't

00:20:16,280 --> 00:20:21,260
want to be mocked so in order for them

00:20:19,100 --> 00:20:22,940
not to all be mocked you need to run a

00:20:21,260 --> 00:20:24,770
test in a separate process I'm just fine

00:20:22,940 --> 00:20:26,900
it gets you moving on the way towards

00:20:24,770 --> 00:20:29,930
testing great cool and but it's it's

00:20:26,900 --> 00:20:32,900
slow so there's a better way we can

00:20:29,930 --> 00:20:34,250
refactor this and so we're gonna

00:20:32,900 --> 00:20:35,840
refactor the code to use an injector

00:20:34,250 --> 00:20:37,160
dependency we're gonna mock that

00:20:35,840 --> 00:20:40,280
injector dependency and we're gonna

00:20:37,160 --> 00:20:42,230
inject the mock dependency and then we

00:20:40,280 --> 00:20:46,360
can remove that annotation so here who

00:20:42,230 --> 00:20:49,280
here has heard of dependency injection

00:20:46,360 --> 00:20:54,530
almost everyone okay who can confidently

00:20:49,280 --> 00:20:57,050
explain what dependency injection is few

00:20:54,530 --> 00:21:01,910
of you okay right so I'm gonna demystify

00:20:57,050 --> 00:21:03,890
this for you here we have or get outlook

00:21:01,910 --> 00:21:05,810
and our new weather forecast this is a

00:21:03,890 --> 00:21:07,700
hard-coded dependency because we are

00:21:05,810 --> 00:21:13,010
creating the dependency within our

00:21:07,700 --> 00:21:15,880
actual method instead we can inject our

00:21:13,010 --> 00:21:19,100
dependency using dependency injection

00:21:15,880 --> 00:21:21,950
that is creating a dependency outside of

00:21:19,100 --> 00:21:24,440
our method and passing it in just by a

00:21:21,950 --> 00:21:28,300
parameter and that is the essence of

00:21:24,440 --> 00:21:34,970
dependency injection dependency injected

00:21:28,300 --> 00:21:37,400
now you know so in this case this is a

00:21:34,970 --> 00:21:41,060
safe refactor because I've given it a

00:21:37,400 --> 00:21:42,440
default parameter value of null and then

00:21:41,060 --> 00:21:45,380
in our next line when I'm getting the

00:21:42,440 --> 00:21:47,000
weather forecast I can either use the

00:21:45,380 --> 00:21:48,830
dependency that has been injected or I

00:21:47,000 --> 00:21:50,300
can do what it was doing already anyway

00:21:48,830 --> 00:21:52,400
so the behavior hasn't actually changed

00:21:50,300 --> 00:21:54,440
we can just create a new weather

00:21:52,400 --> 00:21:56,510
forecast on the fly if one is not being

00:21:54,440 --> 00:21:57,570
passed this means you don't need to go

00:21:56,510 --> 00:21:59,490
through your whole applique

00:21:57,570 --> 00:22:02,460
and change all of the signatures to this

00:21:59,490 --> 00:22:08,400
method it just works and we've got our

00:22:02,460 --> 00:22:11,880
dependency injection in place so in our

00:22:08,400 --> 00:22:13,170
tests it means we can create a mock of

00:22:11,880 --> 00:22:15,780
our weather forecast

00:22:13,170 --> 00:22:17,400
we don't need need to use overload

00:22:15,780 --> 00:22:20,130
anymore we can just give it the class

00:22:17,400 --> 00:22:23,610
name and create a whole new mocked class

00:22:20,130 --> 00:22:25,370
and that leaves all the other craters of

00:22:23,610 --> 00:22:27,900
this class untouched which is great

00:22:25,370 --> 00:22:30,540
we're gonna say it should receive sunny

00:22:27,900 --> 00:22:32,910
and return true and we're gonna inject

00:22:30,540 --> 00:22:35,700
that dependency into our get outlook

00:22:32,910 --> 00:22:37,490
method and hooray this works and we

00:22:35,700 --> 00:22:48,800
don't need this anymore

00:22:37,490 --> 00:22:52,080
cool that's solved there's another thing

00:22:48,800 --> 00:22:54,680
that you commonly encounter in legacy

00:22:52,080 --> 00:22:57,840
code and those are ungraceful exits and

00:22:54,680 --> 00:23:01,530
the first kind of ungraceful exit I want

00:22:57,840 --> 00:23:07,770
to explain and demonstrate today is the

00:23:01,530 --> 00:23:09,390
redirect so and you're the knights of

00:23:07,770 --> 00:23:12,540
the round table and you want to enter

00:23:09,390 --> 00:23:14,520
the cave catalog but there is a rather

00:23:12,540 --> 00:23:18,900
particular oddities or there may or may

00:23:14,520 --> 00:23:20,100
not be a killer rabbit with so if you do

00:23:18,900 --> 00:23:22,350
encounter a killer rabbit you're going

00:23:20,100 --> 00:23:23,880
to run away and but if you don't then

00:23:22,350 --> 00:23:28,080
call behold we're gonna enter the cave

00:23:23,880 --> 00:23:31,560
okay I don't cool so again we have our

00:23:28,080 --> 00:23:34,020
two branches to this you can either

00:23:31,560 --> 00:23:36,870
enter the cave safely there's no killer

00:23:34,020 --> 00:23:37,680
rabbit you're good or there is a killer

00:23:36,870 --> 00:23:40,670
rabbit there and you're gonna have to

00:23:37,680 --> 00:23:40,670
run away you're gonna have to redirect

00:23:42,050 --> 00:23:46,770
but when you run these tests or when you

00:23:45,000 --> 00:23:48,300
run these methods in these tests you're

00:23:46,770 --> 00:23:50,940
going to quickly find that everything

00:23:48,300 --> 00:23:53,790
goes a bit weird because there's a

00:23:50,940 --> 00:23:55,980
header change in there because the

00:23:53,790 --> 00:23:57,900
redirect is that is setting a header so

00:23:55,980 --> 00:23:59,910
you find that you need to run it in

00:23:57,900 --> 00:24:02,250
separate process just to the it doesn't

00:23:59,910 --> 00:24:05,430
confuse the entire test suite so that's

00:24:02,250 --> 00:24:06,930
that's one thing and so when we try to

00:24:05,430 --> 00:24:08,640
enter our cave panel

00:24:06,930 --> 00:24:10,290
safely and there's no rabbit there it's

00:24:08,640 --> 00:24:11,290
pretty simple because nothing nothing

00:24:10,290 --> 00:24:13,150
redirects our

00:24:11,290 --> 00:24:16,360
so we just continue with the execution

00:24:13,150 --> 00:24:20,260
in the function and hold yeah it returns

00:24:16,360 --> 00:24:21,660
correctly but we want to assert that

00:24:20,260 --> 00:24:25,330
when there is a killer rabbit in the way

00:24:21,660 --> 00:24:27,630
that we don't get behold but the odd

00:24:25,330 --> 00:24:31,360
thing is in this scenario that we do

00:24:27,630 --> 00:24:34,510
that's because in a test runner we don't

00:24:31,360 --> 00:24:38,860
have any headers or redirection or

00:24:34,510 --> 00:24:42,730
things like that in place so if we go

00:24:38,860 --> 00:24:44,500
back to our method it gets to the killer

00:24:42,730 --> 00:24:47,290
of it it goes okay I'm gonna redirect

00:24:44,500 --> 00:24:49,060
but it doesn't because it's in a console

00:24:47,290 --> 00:24:52,720
it's a test run it's not going to do and

00:24:49,060 --> 00:24:55,090
then it continues the execution and it

00:24:52,720 --> 00:24:56,650
returns the hold still this would this

00:24:55,090 --> 00:24:57,730
wouldn't happen if you were running this

00:24:56,650 --> 00:24:59,400
in a browser because you would get

00:24:57,730 --> 00:25:05,170
redirected and the execution would stop

00:24:59,400 --> 00:25:06,880
but in the test Runner it does so we

00:25:05,170 --> 00:25:09,160
need to remember that if we're

00:25:06,880 --> 00:25:11,020
anticipating that a user is going to be

00:25:09,160 --> 00:25:13,870
redirected or the execution is going to

00:25:11,020 --> 00:25:18,610
stop then we actually make the execution

00:25:13,870 --> 00:25:20,260
stop that is to put return or continue

00:25:18,610 --> 00:25:21,840
or break or whatever it is to exit the

00:25:20,260 --> 00:25:25,780
execution of your method after

00:25:21,840 --> 00:25:27,700
redirecting or you could technically get

00:25:25,780 --> 00:25:29,830
the header and put it right at the end

00:25:27,700 --> 00:25:31,480
of your methods so that there's nothing

00:25:29,830 --> 00:25:37,450
that could potentially do after that

00:25:31,480 --> 00:25:38,920
point so this is safe refactor in that

00:25:37,450 --> 00:25:40,180
the actual behavior of the method hasn't

00:25:38,920 --> 00:25:41,560
changed because after you've been

00:25:40,180 --> 00:25:43,780
redirect it would have exited it would

00:25:41,560 --> 00:25:45,250
have stopped execution anyway so this is

00:25:43,780 --> 00:25:48,010
a way that you can make your tests well

00:25:45,250 --> 00:25:48,490
can everything is saying or the other

00:25:48,010 --> 00:25:52,570
way around

00:25:48,490 --> 00:25:53,830
return early so there the header is the

00:25:52,570 --> 00:25:55,330
very last step and you don't continue

00:25:53,830 --> 00:25:59,800
executing something and get unintended

00:25:55,330 --> 00:26:01,060
consequences cool and we're inserting

00:25:59,800 --> 00:26:03,940
that when there is a killer rabbit in

00:26:01,060 --> 00:26:05,530
the way that we don't get behold we

00:26:03,940 --> 00:26:10,420
don't get to enter the cave humi run

00:26:05,530 --> 00:26:15,150
away there's another type of one

00:26:10,420 --> 00:26:15,150
graceful exit you know what's coming

00:26:22,120 --> 00:26:25,440
[Laughter]

00:26:25,750 --> 00:26:33,710
so yeah we have brexit we have our

00:26:30,559 --> 00:26:35,299
brexit method and if we remain oh we're

00:26:33,710 --> 00:26:44,750
gonna say bollocks to brexit and if

00:26:35,299 --> 00:26:47,149
we're not we're gonna exit so we want to

00:26:44,750 --> 00:26:47,960
test our two branches this method each

00:26:47,149 --> 00:26:49,940
method either

00:26:47,960 --> 00:26:51,980
we're brexit ER and there is always that

00:26:49,940 --> 00:26:53,450
we're gonna exit we're gonna crash and

00:26:51,980 --> 00:26:55,070
burn and everything's gonna be horrible

00:26:53,450 --> 00:26:57,159
or we're Oh Manor and everything will be

00:26:55,070 --> 00:26:57,159
fine

00:26:57,880 --> 00:27:02,929
so in our tests remaining a function we

00:27:00,860 --> 00:27:04,909
have a brexit our remainder is true and

00:27:02,929 --> 00:27:06,080
we're gonna set the result of that

00:27:04,909 --> 00:27:09,860
function is so this says bollocks to

00:27:06,080 --> 00:27:13,490
brexit cool successful but when we're a

00:27:09,860 --> 00:27:16,100
bachelor and we run this method and we

00:27:13,490 --> 00:27:17,899
want to assert the result is empty it

00:27:16,100 --> 00:27:20,510
never gets there because exit does

00:27:17,899 --> 00:27:21,860
completely exit whatever your execution

00:27:20,510 --> 00:27:26,539
party is it completely exits the test

00:27:21,860 --> 00:27:27,890
runner so we need to think about

00:27:26,539 --> 00:27:32,919
refactoring this so that we can get this

00:27:27,890 --> 00:27:36,350
tested I like to create a wrapper around

00:27:32,919 --> 00:27:39,409
that exit functionality to remove it

00:27:36,350 --> 00:27:43,070
from the method and then we can inject

00:27:39,409 --> 00:27:47,690
that wrapper and mock it so that we're

00:27:43,070 --> 00:27:49,640
gonna create sort of a fake brexit with

00:27:47,690 --> 00:27:55,250
a bit of safe refactoring using our

00:27:49,640 --> 00:28:01,669
magical dependency injection so here's

00:27:55,250 --> 00:28:06,020
our wraparound brexit it's Boris and

00:28:01,669 --> 00:28:10,309
he's gonna get brexit done and he's

00:28:06,020 --> 00:28:12,440
gonna complete the exit cool fine and we

00:28:10,309 --> 00:28:15,289
have our brexit method and we're gonna

00:28:12,440 --> 00:28:16,730
pass in our Boris dependency and again

00:28:15,289 --> 00:28:19,100
we're gonna give it a default value of

00:28:16,730 --> 00:28:21,289
null because this is a safe refactor we

00:28:19,100 --> 00:28:24,080
won't need to change any of our calls to

00:28:21,289 --> 00:28:26,960
practice it because it will use a null

00:28:24,080 --> 00:28:29,630
value and if the value is null it will

00:28:26,960 --> 00:28:31,100
go and create a new Boris on the fly so

00:28:29,630 --> 00:28:34,899
yeah you know how to change any of you

00:28:31,100 --> 00:28:36,980
existing code and instead of exiting

00:28:34,899 --> 00:28:41,360
we're just gonna be Boris and we're

00:28:36,980 --> 00:28:43,820
gonna get brexit done so cool in our

00:28:41,360 --> 00:28:46,880
test brexit method we're gonna create a

00:28:43,820 --> 00:28:48,380
mock of Boris which is always fun um and

00:28:46,880 --> 00:28:51,820
we're just gonna make him do nothing

00:28:48,380 --> 00:28:54,080
he's just gonna sit there and silly and

00:28:51,820 --> 00:28:55,280
then we're going to but we've got to

00:28:54,080 --> 00:28:57,500
make sure that our first parameter

00:28:55,280 --> 00:29:01,039
brexit remainder is false and we're

00:28:57,500 --> 00:29:05,780
going to pass in the mock Boris and yeah

00:29:01,039 --> 00:29:09,049
this works and don't try and unit test

00:29:05,780 --> 00:29:10,429
Boris because all he does is exit and it

00:29:09,049 --> 00:29:11,990
would be kind of pointless and I know

00:29:10,429 --> 00:29:13,880
that means that you're not gonna have a

00:29:11,990 --> 00:29:15,020
hundred percent coverage but it's just

00:29:13,880 --> 00:29:18,340
kind of a trade-off that you have to

00:29:15,020 --> 00:29:18,340
make when it comes to testing Mexico

00:29:24,600 --> 00:29:29,800
this is another thing that you're going

00:29:27,640 --> 00:29:31,210
to encounter probably in legacy code and

00:29:29,800 --> 00:29:32,890
in code in general to be first

00:29:31,210 --> 00:29:34,000
interaction with the file system so

00:29:32,890 --> 00:29:35,679
we're going to take a trip back to the

00:29:34,000 --> 00:29:37,360
90s I remember but we had all those web

00:29:35,679 --> 00:29:38,590
pages on like Geocities and they had all

00:29:37,360 --> 00:29:42,040
the animated gifts and stuff like that

00:29:38,590 --> 00:29:43,480
and also a hit counter because it was

00:29:42,040 --> 00:29:45,850
very important to show up you show

00:29:43,480 --> 00:29:46,210
people how many people actually visited

00:29:45,850 --> 00:29:50,260
your website

00:29:46,210 --> 00:29:52,480
so this is our hit counter now it has a

00:29:50,260 --> 00:29:54,520
method which counts it and we have a hit

00:29:52,480 --> 00:29:55,960
counter file we're going to read the

00:29:54,520 --> 00:29:57,910
content so if I hit counter file and

00:29:55,960 --> 00:30:02,220
then we're gonna increment it by one and

00:29:57,910 --> 00:30:06,220
save that Mac cool you want to test this

00:30:02,220 --> 00:30:09,429
so we test can't hit and we need to find

00:30:06,220 --> 00:30:11,410
the contents of that file before we can

00:30:09,429 --> 00:30:12,850
to hit so that's where we're getting our

00:30:11,410 --> 00:30:14,890
count before we're going to count the

00:30:12,850 --> 00:30:18,670
hit we're going to get the contents

00:30:14,890 --> 00:30:20,620
again and then assert that the value

00:30:18,670 --> 00:30:25,090
after a hit that's been counted is equal

00:30:20,620 --> 00:30:27,040
to one plus they count prior to that but

00:30:25,090 --> 00:30:28,720
there's some problems with this because

00:30:27,040 --> 00:30:31,360
you're artificially inflating your hit

00:30:28,720 --> 00:30:32,650
count and that would be frowned upon is

00:30:31,360 --> 00:30:34,210
every time you run your test you're

00:30:32,650 --> 00:30:37,059
actually I'm incrementing the value in

00:30:34,210 --> 00:30:38,860
that file so that gets kind of annoying

00:30:37,059 --> 00:30:40,090
and interfering and yeah it just looks

00:30:38,860 --> 00:30:42,880
like way more popular than you actually

00:30:40,090 --> 00:30:44,650
are so we're gonna have to refactor this

00:30:42,880 --> 00:30:46,300
as well and again we're going to return

00:30:44,650 --> 00:30:48,070
to our trusty dependency injection and

00:30:46,300 --> 00:30:49,179
instead of hard-coding the file name

00:30:48,070 --> 00:30:52,600
which is a dependency we're going to

00:30:49,179 --> 00:30:55,900
inject that and we're going to create a

00:30:52,600 --> 00:30:57,040
test double hit counter file and we're

00:30:55,900 --> 00:30:58,570
gonna reset the contents of their file

00:30:57,040 --> 00:30:59,800
after each test just to keep it clean

00:30:58,570 --> 00:31:02,140
and make sure you don't end up with a

00:30:59,800 --> 00:31:05,650
file with a gazillion hits just a bit

00:31:02,140 --> 00:31:08,309
simpler so here's our dependency

00:31:05,650 --> 00:31:10,270
injection at work again we have a file

00:31:08,309 --> 00:31:12,760
parameter and we're going to give it a

00:31:10,270 --> 00:31:15,400
default value equal to the value that

00:31:12,760 --> 00:31:17,770
was already in the file so that we can

00:31:15,400 --> 00:31:19,840
either give it a new file name to use

00:31:17,770 --> 00:31:21,580
for example a test file or we'll just

00:31:19,840 --> 00:31:26,290
use the file name that was already in

00:31:21,580 --> 00:31:28,240
there anyway cool so instead of using

00:31:26,290 --> 00:31:30,640
our actual hit counter file in our tests

00:31:28,240 --> 00:31:32,140
we're going to use test hit counter text

00:31:30,640 --> 00:31:34,720
which is a test version of our hit

00:31:32,140 --> 00:31:36,160
counter we're gonna inject that

00:31:34,720 --> 00:31:40,950
dependency

00:31:36,160 --> 00:31:42,970
and everything works in our teardown

00:31:40,950 --> 00:31:47,260
we're going to do just file put contents

00:31:42,970 --> 00:31:49,090
and reset our counter to zero in theory

00:31:47,260 --> 00:31:50,860
we could just assert previously that the

00:31:49,090 --> 00:31:52,480
account would always be one after

00:31:50,860 --> 00:31:53,680
running this method because if it has a

00:31:52,480 --> 00:31:56,140
zero and its begin with them reason

00:31:53,680 --> 00:31:58,210
resetting the contents after each test

00:31:56,140 --> 00:32:02,050
run then it's always going to be one so

00:31:58,210 --> 00:32:03,880
it kind of simplifies things a bit but

00:32:02,050 --> 00:32:07,090
there's a better way because with this

00:32:03,880 --> 00:32:09,550
you're maintaining a test hit counter

00:32:07,090 --> 00:32:10,750
file it kind of shutters things up it's

00:32:09,550 --> 00:32:12,010
a bit messy you have to make sure that's

00:32:10,750 --> 00:32:14,830
committed and make sure no one changes

00:32:12,010 --> 00:32:17,710
the value of it so yeah there's another

00:32:14,830 --> 00:32:20,680
way and I'm gonna introduce a tool today

00:32:17,710 --> 00:32:25,990
called VFS stream which creates a fake

00:32:20,680 --> 00:32:30,280
or virtual file system so instead of

00:32:25,990 --> 00:32:31,990
doing this test hit counter file we can

00:32:30,280 --> 00:32:35,130
create a new virtual fast stream easy

00:32:31,990 --> 00:32:38,590
VFS stream go and call and set up and

00:32:35,130 --> 00:32:41,410
then we can create a new hit counter

00:32:38,590 --> 00:32:43,630
farm using VFS stream new file give it a

00:32:41,410 --> 00:32:45,100
file name tell it where it wants to put

00:32:43,630 --> 00:32:46,510
it just in the virtual file stream and

00:32:45,100 --> 00:32:50,470
we're going to set the contents of that

00:32:46,510 --> 00:32:54,240
file and then instead of a string file

00:32:50,470 --> 00:32:58,540
name we can pass it hit counter file URL

00:32:54,240 --> 00:33:00,520
which behaves in the same way as file

00:32:58,540 --> 00:33:03,820
name to any other file on your system

00:33:00,520 --> 00:33:06,820
it's virtual and we can always assert

00:33:03,820 --> 00:33:10,180
that it's going to equal one after we've

00:33:06,820 --> 00:33:14,170
counted a hit because it's setting the

00:33:10,180 --> 00:33:18,340
content zero before we test run so yeah

00:33:14,170 --> 00:33:19,620
that's a quite handy we can just get rid

00:33:18,340 --> 00:33:23,160
of this stuff now we don't need him

00:33:19,620 --> 00:33:23,160
makes things simpler

00:33:25,320 --> 00:33:31,770
everyone let's forget you right just

00:33:27,300 --> 00:33:33,090
maybe not in your code base so yeah

00:33:31,770 --> 00:33:34,260
spaghetti code that's that that's the

00:33:33,090 --> 00:33:37,830
thing that you're gonna mean cancer

00:33:34,260 --> 00:33:41,550
okay so I have a polonaise and and and

00:33:37,830 --> 00:33:43,440
for some reason well okay I have a

00:33:41,550 --> 00:33:45,990
polonaise they can be either eaten or

00:33:43,440 --> 00:33:48,030
not my plates for it's not I can't eat

00:33:45,990 --> 00:33:49,550
the polonaise and I can check whether or

00:33:48,030 --> 00:33:54,540
not the Bolognese has already been eaten

00:33:49,550 --> 00:33:57,240
and it also has parmesan and looking

00:33:54,540 --> 00:33:58,740
into our eat method if we've already

00:33:57,240 --> 00:34:02,310
eaten a BA today - can't eat it again

00:33:58,740 --> 00:34:04,710
obviously it'd be weird if it doesn't

00:34:02,310 --> 00:34:05,700
have panties on it or if I've eaten the

00:34:04,710 --> 00:34:08,580
Parmesan cheese on it

00:34:05,700 --> 00:34:10,020
I want more parmesan on my bolognaise

00:34:08,580 --> 00:34:12,810
because I quite like prom zone and it

00:34:10,020 --> 00:34:14,340
doesn't taste right without it um also I

00:34:12,810 --> 00:34:19,500
need to have garlic bread from

00:34:14,340 --> 00:34:21,150
hypotenuse because okay so I've got to

00:34:19,500 --> 00:34:22,620
have the garlic bread and if I'm eating

00:34:21,150 --> 00:34:24,810
the bone names I'm gonna eat bread as

00:34:22,620 --> 00:34:26,669
well and if I'm eating the polonaise I'm

00:34:24,810 --> 00:34:30,570
getting the pumps out as well and then

00:34:26,669 --> 00:34:33,870
it's gonna say eaten to be true this is

00:34:30,570 --> 00:34:35,820
a bit weird because it's spaghetti and

00:34:33,870 --> 00:34:37,350
I'm not sure why spaghetti is concerned

00:34:35,820 --> 00:34:39,780
about whether or not I'm also eating

00:34:37,350 --> 00:34:43,320
garlic bread or Parmesan cheese to be

00:34:39,780 --> 00:34:44,730
fair so yeah this is this is literal

00:34:43,320 --> 00:34:46,080
spaghetti code there are lots of

00:34:44,730 --> 00:34:47,580
dependencies in there so kind of

00:34:46,080 --> 00:34:49,200
intermingle no one who knows what's

00:34:47,580 --> 00:34:50,179
going on don't really know what to

00:34:49,200 --> 00:34:53,010
expect

00:34:50,179 --> 00:34:54,690
so if we want to test something like

00:34:53,010 --> 00:34:56,370
this we create our bond and ace test

00:34:54,690 --> 00:34:58,230
file and we want to test what happens

00:34:56,370 --> 00:34:59,970
when we eat the polonaise so we're gonna

00:34:58,230 --> 00:35:04,230
create any Bolognese and we're gonna eat

00:34:59,970 --> 00:35:07,500
it and yeah this works we're gonna set

00:35:04,230 --> 00:35:12,360
that after we live on an ace there is a

00:35:07,500 --> 00:35:14,220
needy but there are a few tricky things

00:35:12,360 --> 00:35:16,080
about this because when you test

00:35:14,220 --> 00:35:17,460
something like that it does execute all

00:35:16,080 --> 00:35:19,320
of the code in there so it's going to

00:35:17,460 --> 00:35:21,570
look like in your test coverage that

00:35:19,320 --> 00:35:24,270
we've also covered a bit of parmesan and

00:35:21,570 --> 00:35:27,060
a bit of garlic bread which is a bit

00:35:24,270 --> 00:35:29,490
misleading so there's a covers

00:35:27,060 --> 00:35:31,260
annotation in PHP unit which you can use

00:35:29,490 --> 00:35:33,720
to specify what it is exactly these you

00:35:31,260 --> 00:35:36,060
intended to test so when it comes to

00:35:33,720 --> 00:35:37,770
spaghetti code you can tell it that

00:35:36,060 --> 00:35:38,880
actually although you've executed this

00:35:37,770 --> 00:35:40,500
function which has had

00:35:38,880 --> 00:35:42,599
side effects is everything's tangled up

00:35:40,500 --> 00:35:44,549
that I had only intended to test the

00:35:42,599 --> 00:35:46,440
pollinators and it will discard the

00:35:44,549 --> 00:35:49,980
coverage for everything else that is

00:35:46,440 --> 00:35:53,160
come into contact with I also like to

00:35:49,980 --> 00:35:56,210
create reusable expectations so for

00:35:53,160 --> 00:36:00,650
example I might illustrate different

00:35:56,210 --> 00:36:03,809
process branches or scenarios that occur

00:36:00,650 --> 00:36:10,200
in multiple times or I want to test

00:36:03,809 --> 00:36:12,660
multiple times in spaghetti code so yeah

00:36:10,200 --> 00:36:14,039
yeah they're handy covers annotation so

00:36:12,660 --> 00:36:15,569
when I eat the Bolognese I'm telling it

00:36:14,039 --> 00:36:17,609
that I only actually intended to test

00:36:15,569 --> 00:36:22,109
the polonaise class and not everything

00:36:17,609 --> 00:36:25,019
else that seems to come with it and I

00:36:22,109 --> 00:36:27,329
want to test now that when I try to eat

00:36:25,019 --> 00:36:30,210
a Bala nice ribbon eaten then it can't

00:36:27,329 --> 00:36:31,680
be in again and I also want to test that

00:36:30,210 --> 00:36:33,869
when I eat a Bolognese hasn't already

00:36:31,680 --> 00:36:37,650
been eaten that the correct behaviors

00:36:33,869 --> 00:36:39,150
occur so here are two tests one of these

00:36:37,650 --> 00:36:43,109
it's already been eaten and one that

00:36:39,150 --> 00:36:45,869
hasn't when I run these tests I kind of

00:36:43,109 --> 00:36:48,119
want to check that when I'm eating a

00:36:45,869 --> 00:36:51,539
polonaise it hasn't been eaten that I

00:36:48,119 --> 00:36:53,759
also eat garlic bread so I've created a

00:36:51,539 --> 00:36:57,059
private function in my unit test class

00:36:53,759 --> 00:36:59,309
which is expected to be eaten which

00:36:57,059 --> 00:37:01,170
creates a mock of garlic bread and

00:36:59,309 --> 00:37:04,140
overrode because it's a hot code of

00:37:01,170 --> 00:37:07,410
dependency and I'm gonna say that if I

00:37:04,140 --> 00:37:09,240
am garlic bread should be eaten so that

00:37:07,410 --> 00:37:11,000
I can use this expect garlic bread to be

00:37:09,240 --> 00:37:13,619
eaten

00:37:11,000 --> 00:37:16,250
elsewhere in my chest so when I'm eating

00:37:13,619 --> 00:37:19,220
a Bolognese that hasn't yet been eaten I

00:37:16,250 --> 00:37:21,809
don't want to expect to eat garlic bread

00:37:19,220 --> 00:37:24,599
but when I am eating an uneaten

00:37:21,809 --> 00:37:27,809
polonaise I do expect to also be eating

00:37:24,599 --> 00:37:31,619
garlic bread and that's just sort of one

00:37:27,809 --> 00:37:35,359
way of taming this spaghetti code whilst

00:37:31,619 --> 00:37:35,359
you attempt to refactor it a bit

00:37:43,370 --> 00:37:48,840
another thing that you're likely to

00:37:46,350 --> 00:37:54,870
encounter in any code is the private

00:37:48,840 --> 00:37:56,460
method so I have MC Hammer here and you

00:37:54,870 --> 00:38:01,080
say stop he's gonna say can't touch this

00:37:56,460 --> 00:38:03,000
and that's gonna return hammer time so

00:38:01,080 --> 00:38:04,860
cool we can test can't touch this we're

00:38:03,000 --> 00:38:07,200
gonna create any MC Hammer we're going

00:38:04,860 --> 00:38:08,520
to call can't touch this and when that

00:38:07,200 --> 00:38:12,780
is when that happens we're gonna set

00:38:08,520 --> 00:38:14,580
that it returns one hammer time but we

00:38:12,780 --> 00:38:17,190
can't we get an error because can't

00:38:14,580 --> 00:38:20,510
touch this it's a private method so how

00:38:17,190 --> 00:38:25,440
are we supposed to test this well don't

00:38:20,510 --> 00:38:28,380
just leave it test the public methods

00:38:25,440 --> 00:38:32,360
that use the private methods so they get

00:38:28,380 --> 00:38:36,150
tested by proxy that counts that's

00:38:32,360 --> 00:38:40,470
absolutely fine private methods are as

00:38:36,150 --> 00:38:42,540
they say private they are implementation

00:38:40,470 --> 00:38:47,760
details you shouldn't really care about

00:38:42,540 --> 00:38:54,540
them anyway so yeah feel free to ignore

00:38:47,760 --> 00:38:57,420
those so instead we're gonna test stop

00:38:54,540 --> 00:38:59,300
and indeed that calls can't touch this

00:38:57,420 --> 00:39:01,680
which indeed returns hammer time and

00:38:59,300 --> 00:39:10,050
I'll test it successful and there are no

00:39:01,680 --> 00:39:14,310
errors great so to recap I've explained

00:39:10,050 --> 00:39:17,370
a bunch of scenarios that you're likely

00:39:14,310 --> 00:39:20,100
to encounter in your work with legacy

00:39:17,370 --> 00:39:21,900
code hopefully you will be able to

00:39:20,100 --> 00:39:24,300
recognize some of these patterns and

00:39:21,900 --> 00:39:27,360
understand some of the techniques that

00:39:24,300 --> 00:39:29,910
you can employ to get these tested and

00:39:27,360 --> 00:39:33,000
once you've got them tested you can

00:39:29,910 --> 00:39:33,950
refactor happily safely nothing's gonna

00:39:33,000 --> 00:39:36,810
go wrong

00:39:33,950 --> 00:39:39,390
legacy code is not something that you

00:39:36,810 --> 00:39:42,330
should fear or you need to fear legacy

00:39:39,390 --> 00:39:45,450
code is an assets legacy code is what

00:39:42,330 --> 00:39:47,430
you are being paid to maintain and you

00:39:45,450 --> 00:39:49,530
didn't have to write it and now

00:39:47,430 --> 00:39:51,900
hopefully you understand you don't need

00:39:49,530 --> 00:39:54,200
to rewrite it either

00:39:51,900 --> 00:39:54,200

YouTube URL: https://www.youtube.com/watch?v=U5BkMJpv_ZQ


