Title: How De-normalizing Your Data with JSON Can Boost Query Performance - David Stokes - PHP UK 2019
Publication date: 2019-03-22
Playlist: PHP UK Conference 2019
Description: 
	Database joins can be expensive and you can reduce dives into the indexes/data by using JSON columns. By loading data kept in smaller 'stub' tables into main tables it is possible to minimize joins for simple data like address, phone numbers, and the like in schemaless JSON documents. Yes, third normal form or better has advantages at many levels but it is a design that is costly for many-to-many relations! It is very easy to refactor data is is often stagnant or infrequently updated to take advantage of hybrid SQL/NoSQL databases to greatly increase overall query performance plus increase code readability. This approach can completely change your ideas on data architecture and provide easy mutability for future changes.
Captions: 
	00:00:03,650 --> 00:00:12,599
today we're talking about hybrid

00:00:06,109 --> 00:00:16,830
databases databases have really changed

00:00:12,599 --> 00:00:18,180
a lot in the past 40 years especially in

00:00:16,830 --> 00:00:20,730
the open-source arena there's been a lot

00:00:18,180 --> 00:00:28,140
of developments that are rather

00:00:20,730 --> 00:00:29,580
interesting now of course this diet now

00:00:28,140 --> 00:00:31,199
I want to start off with a quick history

00:00:29,580 --> 00:00:35,460
lesson for those of you without gray

00:00:31,199 --> 00:00:37,829
hair or not prematurely bald the first

00:00:35,460 --> 00:00:40,230
computers really only had we're talking

00:00:37,829 --> 00:00:42,090
about electronic computers not the

00:00:40,230 --> 00:00:44,030
people who actually did computations in

00:00:42,090 --> 00:00:47,399
the knowledge bruh head only memory

00:00:44,030 --> 00:00:49,079
later came punch cards to pinch tape

00:00:47,399 --> 00:00:52,140
your tapes real tapes and all the other

00:00:49,079 --> 00:00:54,329
fun bits there a long long long gone and

00:00:52,140 --> 00:00:56,850
disk drives if you could find them were

00:00:54,329 --> 00:01:02,100
rather expensive very slow and

00:00:56,850 --> 00:01:04,019
physically very very large now you

00:01:02,100 --> 00:01:06,090
couldn't you had to read everything from

00:01:04,019 --> 00:01:07,650
beginning to end it's like you couldn't

00:01:06,090 --> 00:01:08,939
stop a book in the middle if you wanted

00:01:07,650 --> 00:01:11,880
to know something you had to start at

00:01:08,939 --> 00:01:13,770
page 1 and go to page n so if you're

00:01:11,880 --> 00:01:16,979
processing some data you went all the

00:01:13,770 --> 00:01:20,790
way from a to Zed all the time really

00:01:16,979 --> 00:01:22,320
fun well somewhere along the way people

00:01:20,790 --> 00:01:24,210
sided well I just don't want to do that

00:01:22,320 --> 00:01:26,430
I want to be able to skip around in the

00:01:24,210 --> 00:01:29,939
data there's got to be some way how to

00:01:26,430 --> 00:01:32,479
do that so the first step was to force

00:01:29,939 --> 00:01:34,770
all records to have a uniform length

00:01:32,479 --> 00:01:37,380
because if everything is uniform links

00:01:34,770 --> 00:01:41,220
you know if it's 100 bits long you know

00:01:37,380 --> 00:01:44,790
a bit 101 the second record starts so

00:01:41,220 --> 00:01:46,320
how do you do that well if you want to

00:01:44,790 --> 00:01:49,049
get to the records that you want and a

00:01:46,320 --> 00:01:51,540
set of data they start figuring out ways

00:01:49,049 --> 00:01:54,840
on how to get hashes or keys into each

00:01:51,540 --> 00:01:56,969
record and use that as that use that

00:01:54,840 --> 00:02:01,799
index as a map to get to the records

00:01:56,969 --> 00:02:04,200
that you wanted and in the mid 50s early

00:02:01,799 --> 00:02:07,259
60s they camp the idea called index

00:02:04,200 --> 00:02:09,300
sequential access method this where the

00:02:07,259 --> 00:02:12,270
records were made into logical sized

00:02:09,300 --> 00:02:13,800
blocks all the same size and that was

00:02:12,270 --> 00:02:16,500
really done so you can skip ahead

00:02:13,800 --> 00:02:21,090
tape drives anyone here actually used a

00:02:16,500 --> 00:02:23,430
tape drive a couple of you big bulky

00:02:21,090 --> 00:02:27,090
devices if you're really lucky you might

00:02:23,430 --> 00:02:30,930
have 2400 bits per inch on the tape not

00:02:27,090 --> 00:02:32,670
really that guess so the great thing

00:02:30,930 --> 00:02:34,290
about I Sam is that you didn't have to

00:02:32,670 --> 00:02:36,390
read in everything to find a record you

00:02:34,290 --> 00:02:39,600
could skip around but it was limited in

00:02:36,390 --> 00:02:41,520
size usually had a single key any sort

00:02:39,600 --> 00:02:43,110
of dating relationship between different

00:02:41,520 --> 00:02:47,400
tables or different records was very

00:02:43,110 --> 00:02:50,910
very messy and you are very much limited

00:02:47,400 --> 00:02:54,450
by memory on the machine this gentleman

00:02:50,910 --> 00:02:56,550
Edgar Codd was an IBM researcher who was

00:02:54,450 --> 00:02:58,470
asked find a better way to go out and

00:02:56,550 --> 00:03:00,540
get our data and we're mainly looking at

00:02:58,470 --> 00:03:02,370
ways not to duplicate stuff because disk

00:03:00,540 --> 00:03:04,500
drives are so expensive and we're

00:03:02,370 --> 00:03:06,240
looking for a way on how to break data

00:03:04,500 --> 00:03:08,880
and the little component bits to make it

00:03:06,240 --> 00:03:12,240
easier to find little bits of

00:03:08,880 --> 00:03:14,330
information so we came up with something

00:03:12,240 --> 00:03:16,800
called structured query language

00:03:14,330 --> 00:03:18,480
ironically for him IBM had another

00:03:16,800 --> 00:03:20,040
product that wasn't structured query

00:03:18,480 --> 00:03:21,570
language they wanted to sell so they

00:03:20,040 --> 00:03:24,060
kind of tried to stifle what he was

00:03:21,570 --> 00:03:25,650
doing and the only reason we have SQL

00:03:24,060 --> 00:03:27,450
today is because it kept talking to

00:03:25,650 --> 00:03:29,310
customers everyone here talks to your

00:03:27,450 --> 00:03:30,870
customers right so if your bosses are

00:03:29,310 --> 00:03:33,660
telling you no and you want it in anyway

00:03:30,870 --> 00:03:35,459
talk to your customers and once I

00:03:33,660 --> 00:03:40,500
mentioned earlier his main goal was the

00:03:35,459 --> 00:03:41,910
minimum duplication of data so as people

00:03:40,500 --> 00:03:43,320
started moving away from my Sam they're

00:03:41,910 --> 00:03:45,020
looking for better performance they were

00:03:43,320 --> 00:03:47,490
looking for things that would scale and

00:03:45,020 --> 00:03:49,440
the main thing that everyone wanted at

00:03:47,490 --> 00:03:51,450
the time was transactions they wanted to

00:03:49,440 --> 00:03:52,950
be able to make sure things like bank

00:03:51,450 --> 00:03:55,140
account transactions went through

00:03:52,950 --> 00:03:59,400
properly and weren't aborted in the

00:03:55,140 --> 00:04:01,080
middle of the incident so part of that

00:03:59,400 --> 00:04:02,610
came up with the idea of normalizing

00:04:01,080 --> 00:04:04,530
your data if you're going to take

00:04:02,610 --> 00:04:06,570
someone's address you're going to break

00:04:04,530 --> 00:04:07,950
it down into a similar format for

00:04:06,570 --> 00:04:11,010
everybody so you'd have a first name

00:04:07,950 --> 00:04:13,830
last name street address one maybe

00:04:11,010 --> 00:04:17,700
street address two city name postal cold

00:04:13,830 --> 00:04:20,549
country code all that normalizing data

00:04:17,700 --> 00:04:22,320
is very rigorous it's very hard to do at

00:04:20,549 --> 00:04:23,389
a large scale that's why a lot of folks

00:04:22,320 --> 00:04:25,710
don't do it proper

00:04:23,389 --> 00:04:27,380
but if you really want performance of a

00:04:25,710 --> 00:04:29,520
structured query language database

00:04:27,380 --> 00:04:31,080
that's the way to do it because you have

00:04:29,520 --> 00:04:32,760
to force your data into these little

00:04:31,080 --> 00:04:36,060
relations to be able to tie things

00:04:32,760 --> 00:04:37,680
together now all this was driven by the

00:04:36,060 --> 00:04:39,600
cost model this was something that

00:04:37,680 --> 00:04:41,729
Oracle developed in the early years and

00:04:39,600 --> 00:04:43,410
the idea was if you know what it costs

00:04:41,729 --> 00:04:45,300
to go out and get this piece of

00:04:43,410 --> 00:04:47,340
information but there's multiple ways to

00:04:45,300 --> 00:04:49,889
do that try to pick the cheapest way to

00:04:47,340 --> 00:04:54,780
do that now cheapness here being defined

00:04:49,889 --> 00:04:57,540
as disk reads this is all based on past

00:04:54,780 --> 00:05:01,040
statistics and like past statistics they

00:04:57,540 --> 00:05:03,540
can be misleading much like a GPS that

00:05:01,040 --> 00:05:05,550
you know that the eight one two three

00:05:03,540 --> 00:05:07,590
was open yesterday there was the fast

00:05:05,550 --> 00:05:09,210
way to get back to your house but today

00:05:07,590 --> 00:05:11,580
there's some sort of protests there and

00:05:09,210 --> 00:05:15,590
the optimizer doesn't know about that so

00:05:11,580 --> 00:05:19,470
the cost model isn't always the best

00:05:15,590 --> 00:05:21,210
so most people like me from database

00:05:19,470 --> 00:05:23,430
companies coming talking folks like you

00:05:21,210 --> 00:05:26,669
we're telling you go out and normalize

00:05:23,430 --> 00:05:28,650
your data so experts like me have been

00:05:26,669 --> 00:05:30,630
preaching this for upwards of 40 years

00:05:28,650 --> 00:05:32,820
tell me that you really need to make

00:05:30,630 --> 00:05:35,669
sure that you package your data properly

00:05:32,820 --> 00:05:39,330
and that you have to set up complex

00:05:35,669 --> 00:05:41,280
relations with your tables usually this

00:05:39,330 --> 00:05:43,650
Rumi requires that you have to have a

00:05:41,280 --> 00:05:45,510
DBA to come in set up the relations set

00:05:43,650 --> 00:05:48,180
up the table set up the indexes give you

00:05:45,510 --> 00:05:51,210
permission to go out and write to the to

00:05:48,180 --> 00:05:54,590
the data and get things going so you had

00:05:51,210 --> 00:05:58,500
to go through the DBA as a choke point

00:05:54,590 --> 00:06:00,750
well about ten years ago the no SQL

00:05:58,500 --> 00:06:02,400
world started coming along and they were

00:06:00,750 --> 00:06:04,620
frustrated on things like MySQL's

00:06:02,400 --> 00:06:08,580
inability to quickly change the schemas

00:06:04,620 --> 00:06:09,840
of their tables in a fast fashion and of

00:06:08,580 --> 00:06:12,300
course with any new technology that

00:06:09,840 --> 00:06:15,300
comes out it's always marked as the end

00:06:12,300 --> 00:06:17,220
of the last technology so for many years

00:06:15,300 --> 00:06:19,349
I was hearing that Oh relational

00:06:17,220 --> 00:06:21,289
databases are going to be gone no SQL is

00:06:19,349 --> 00:06:23,880
going to take over everything

00:06:21,289 --> 00:06:25,229
no one scaled up a databases are really

00:06:23,880 --> 00:06:27,330
good they have a lot of functions but

00:06:25,229 --> 00:06:29,520
they've until recently lacked a lot of

00:06:27,330 --> 00:06:32,159
functions acid compliance for

00:06:29,520 --> 00:06:35,550
transactions is just now getting

00:06:32,159 --> 00:06:39,060
implemented rigor to your data you can't

00:06:35,550 --> 00:06:40,860
do with a schema less data a lot of no

00:06:39,060 --> 00:06:43,200
sql's don't really have good logical

00:06:40,860 --> 00:06:46,260
operators doing exclusive ORS where

00:06:43,200 --> 00:06:47,700
anne's are gonna butter them up but the

00:06:46,260 --> 00:06:49,380
good news is you didn't need a DBA you

00:06:47,700 --> 00:06:50,700
didn't have that choke point anymore you

00:06:49,380 --> 00:06:52,050
could literally listen to your boss who

00:06:50,700 --> 00:06:53,940
said hey don't worry about your coding

00:06:52,050 --> 00:06:55,050
go out and start coding will tell you

00:06:53,940 --> 00:06:56,430
what the data it will tell you about the

00:06:55,050 --> 00:06:58,140
product later just go ahead and start

00:06:56,430 --> 00:07:00,210
coding I have this little check mark on

00:06:58,140 --> 00:07:02,070
my Gantt chart go ahead and code will

00:07:00,210 --> 00:07:06,600
tell you what you're doing later anyone

00:07:02,070 --> 00:07:07,890
working a company like that and the

00:07:06,600 --> 00:07:09,480
other great thing about new SQL is

00:07:07,890 --> 00:07:10,980
you've had the ability to have mutable

00:07:09,480 --> 00:07:13,440
data which means you can change it on

00:07:10,980 --> 00:07:16,140
the fly you have an IOT sensor that

00:07:13,440 --> 00:07:17,610
suddenly starts giving you a new bit of

00:07:16,140 --> 00:07:19,710
information you can instantly throw it

00:07:17,610 --> 00:07:21,660
in the database without having to rely

00:07:19,710 --> 00:07:23,070
on the DBA going up to set up the column

00:07:21,660 --> 00:07:26,700
and the index and all the other stuff

00:07:23,070 --> 00:07:28,950
and getting the queries right so in the

00:07:26,700 --> 00:07:30,570
past couple of years the new SQL vendors

00:07:28,950 --> 00:07:33,170
have added things like indexes more

00:07:30,570 --> 00:07:35,190
logical operators they're adding

00:07:33,170 --> 00:07:38,280
transactions is having some

00:07:35,190 --> 00:07:39,780
teething issues there meanwhile most of

00:07:38,280 --> 00:07:43,380
the SQL vendors have gone out and added

00:07:39,780 --> 00:07:45,990
JSON data types Oracle Microsoft MySQL

00:07:43,380 --> 00:07:47,790
Postgres Postgres being Postgres of

00:07:45,990 --> 00:07:53,040
course added two types of JSON operators

00:07:47,790 --> 00:07:54,330
or data types and we relational vendors

00:07:53,040 --> 00:07:56,580
looking for ways to leverage this

00:07:54,330 --> 00:07:57,810
feature and about a year and a half ago

00:07:56,580 --> 00:08:00,510
I was talking to one of our engineers

00:07:57,810 --> 00:08:04,500
dr. Charles Bell and I said well how are

00:08:00,510 --> 00:08:07,110
you using the no sequel features in

00:08:04,500 --> 00:08:09,200
MySQL and other databases to your

00:08:07,110 --> 00:08:13,140
advantage and that was kind of the

00:08:09,200 --> 00:08:14,280
embryonic start of this talk well let

00:08:13,140 --> 00:08:17,010
that's the end of the history lesson

00:08:14,280 --> 00:08:18,390
let's go on to the fun stuff two and a

00:08:17,010 --> 00:08:20,910
half years ago three years ago my school

00:08:18,390 --> 00:08:22,080
introduced a JSON data type this is

00:08:20,910 --> 00:08:25,590
basically I want to get you a bite

00:08:22,080 --> 00:08:27,480
payload per column bot DB for

00:08:25,590 --> 00:08:30,750
reference is about sixteen megabytes

00:08:27,480 --> 00:08:33,240
we have 24 to 30 supporting functions

00:08:30,750 --> 00:08:34,410
depending on the release you're on and

00:08:33,240 --> 00:08:36,720
it's probably the main reason more

00:08:34,410 --> 00:08:38,760
people have upgraded from MySQL 505 one

00:08:36,720 --> 00:08:41,040
five five five six two five seven and

00:08:38,760 --> 00:08:43,920
later to eight and on top of it it's

00:08:41,040 --> 00:08:46,760
also the heart of our new protocol which

00:08:43,920 --> 00:08:49,410
we clever we call the X protocol our new

00:08:46,760 --> 00:08:51,509
API which we call the X eight

00:08:49,410 --> 00:08:56,519
gie and gives you the ability to use

00:08:51,509 --> 00:08:59,879
MySQL without the SQL so let's make up a

00:08:56,519 --> 00:09:01,199
totally springless fantasy business

00:08:59,879 --> 00:09:02,490
where i'm going to stop doing what I'm

00:09:01,199 --> 00:09:05,790
doing now and I'm gonna go in and start

00:09:02,490 --> 00:09:07,170
making guitars but being a bit head I

00:09:05,790 --> 00:09:10,199
want to go out in there and set up all

00:09:07,170 --> 00:09:12,180
my own behind the scenes infrastructure

00:09:10,199 --> 00:09:15,959
so for my guitar shop I'm going to have

00:09:12,180 --> 00:09:18,660
all sorts of databases for accounting

00:09:15,959 --> 00:09:20,370
employees customers parts suppliers and

00:09:18,660 --> 00:09:22,829
products we're going to narrow this down

00:09:20,370 --> 00:09:26,610
to just a product database for the

00:09:22,829 --> 00:09:27,930
guitars now guitars have been around for

00:09:26,610 --> 00:09:30,839
a couple hundred years and everyone kind

00:09:27,930 --> 00:09:32,189
of knows this familiar shape you might

00:09:30,839 --> 00:09:34,050
even have one of these sitting around in

00:09:32,189 --> 00:09:36,029
your your closet gathering dust

00:09:34,050 --> 00:09:38,009
hopefully not but hopefully you're

00:09:36,029 --> 00:09:39,240
playing it on a regular basis now

00:09:38,009 --> 00:09:40,589
there's a different type of guitars for

00:09:39,240 --> 00:09:43,709
different needs that some people like

00:09:40,589 --> 00:09:45,540
the classic Martin acoustic other people

00:09:43,709 --> 00:09:48,779
watch electric guitars they even like

00:09:45,540 --> 00:09:50,129
electric guitars with two necks maybe

00:09:48,779 --> 00:09:52,949
you don't like to next what you want the

00:09:50,129 --> 00:09:58,019
extra strings maybe you have other

00:09:52,949 --> 00:10:00,480
issues I just love the expression on his

00:09:58,019 --> 00:10:02,310
face or maybe you have some other

00:10:00,480 --> 00:10:04,019
quality or quirk in your personality

00:10:02,310 --> 00:10:06,600
needs to be satisfied by having five

00:10:04,019 --> 00:10:08,699
necks on your guitar now if you're

00:10:06,600 --> 00:10:10,439
making custom guitars you are going to

00:10:08,699 --> 00:10:12,300
have a paying customer usually with cash

00:10:10,439 --> 00:10:16,439
he's gonna come up and saying I want

00:10:12,300 --> 00:10:18,120
something like that they wouldn't

00:10:16,439 --> 00:10:22,350
recognize this guitar and or the hands

00:10:18,120 --> 00:10:25,639
of the person holding it this is a 60

00:10:22,350 --> 00:10:29,009
year old Martin om and classical guitar

00:10:25,639 --> 00:10:31,139
the owner of it bought it because his

00:10:29,009 --> 00:10:32,130
previous guitar gets stepped on now you

00:10:31,139 --> 00:10:35,850
may not be able to see where you're

00:10:32,130 --> 00:10:38,430
sitting but this guitar has a sound hole

00:10:35,850 --> 00:10:39,059
which you'd expect it also has another

00:10:38,430 --> 00:10:42,149
hole there

00:10:39,059 --> 00:10:43,769
that's from 50 years of playing with

00:10:42,149 --> 00:10:46,350
guitar picks and actually wearing the

00:10:43,769 --> 00:10:48,509
wood away this is Willie Nelson's guitar

00:10:46,350 --> 00:10:51,930
called trigger there's actually a

00:10:48,509 --> 00:10:53,910
gentleman in Austin Texas who every few

00:10:51,930 --> 00:10:56,610
weeks has to go through and maintain

00:10:53,910 --> 00:10:58,769
this guitar so for those of you

00:10:56,610 --> 00:11:01,490
about having a legacy code base please

00:10:58,769 --> 00:11:01,490
remember this picture

00:11:01,689 --> 00:11:07,189
so time to get to work I've decided that

00:11:05,420 --> 00:11:08,689
my database is okay I'm gonna go out and

00:11:07,189 --> 00:11:12,589
get my wood and I'm gonna actually start

00:11:08,689 --> 00:11:13,910
carving up the wood to make guitars but

00:11:12,589 --> 00:11:15,199
I want to be able to record the

00:11:13,910 --> 00:11:17,509
information on the guitar I'm going to

00:11:15,199 --> 00:11:18,829
want some sort of serial number usually

00:11:17,509 --> 00:11:21,649
for most manufacturers they have a

00:11:18,829 --> 00:11:23,629
serial number with an embedded date the

00:11:21,649 --> 00:11:25,670
serial number might note whether it's an

00:11:23,629 --> 00:11:28,309
acoustic-electric a certain body style

00:11:25,670 --> 00:11:30,980
materials parts there's a lot of parts

00:11:28,309 --> 00:11:32,749
to go in a guitar the tuning pegs to

00:11:30,980 --> 00:11:34,549
tighten the strings the strings the

00:11:32,749 --> 00:11:38,149
frets the glue the screws the wiring

00:11:34,549 --> 00:11:39,619
switches two pickups the strap holders

00:11:38,149 --> 00:11:43,160
and all the other stuff there's just a

00:11:39,619 --> 00:11:46,519
lot of parts so naturally we'd want to

00:11:43,160 --> 00:11:48,679
go out there and fully normalize all our

00:11:46,519 --> 00:11:51,319
data which when you realize all the

00:11:48,679 --> 00:11:52,939
subcategories all the sub parts and all

00:11:51,319 --> 00:11:56,420
the things you can break down a guitar

00:11:52,939 --> 00:11:58,579
suddenly you have a whole bunch of stuff

00:11:56,420 --> 00:12:01,040
and somebody's going to call you up and

00:11:58,579 --> 00:12:02,809
say tell me about my new guitar here's

00:12:01,040 --> 00:12:06,410
my serial number please tell me all

00:12:02,809 --> 00:12:09,740
about my guitar and a simple thing like

00:12:06,410 --> 00:12:11,299
the body might be basically a wooden box

00:12:09,740 --> 00:12:14,389
might not even be wooden it could be

00:12:11,299 --> 00:12:17,749
aluminum could be plastic it can be any

00:12:14,389 --> 00:12:19,339
sort of materials by the way the Gibson

00:12:17,749 --> 00:12:21,559
guitar company three or four years ago

00:12:19,339 --> 00:12:23,899
got contacted by the US government said

00:12:21,559 --> 00:12:26,059
all that Brazilian rosewood all that

00:12:23,899 --> 00:12:28,249
ebony you have prove to us that you have

00:12:26,059 --> 00:12:30,649
the proper import licenses for those

00:12:28,249 --> 00:12:32,899
wood so you have to actually keep track

00:12:30,649 --> 00:12:34,549
of all that information by the way that

00:12:32,899 --> 00:12:36,290
almost broke the Gibson guitar company

00:12:34,549 --> 00:12:39,610
they couldn't prove where they had all

00:12:36,290 --> 00:12:41,449
their stuff due too sloppy bookkeeping

00:12:39,610 --> 00:12:44,929
also if you have electric guitar you

00:12:41,449 --> 00:12:46,189
might have one or more pickups you might

00:12:44,929 --> 00:12:47,360
make them in-house you can actually go

00:12:46,189 --> 00:12:49,249
out and buy the various parts and put

00:12:47,360 --> 00:12:52,779
them together you can buy them from any

00:12:49,249 --> 00:12:56,029
number of vendors they have different

00:12:52,779 --> 00:12:57,679
qualifications and assembly features

00:12:56,029 --> 00:13:00,589
they come in different colors wiring

00:12:57,679 --> 00:13:01,999
options and I think it's real messy so

00:13:00,589 --> 00:13:04,160
as you can see we quickly go down the

00:13:01,999 --> 00:13:05,360
rabbit hole of the normalized data where

00:13:04,160 --> 00:13:08,179
we start off with our table for the

00:13:05,360 --> 00:13:10,339
guitar we look at where the body is we

00:13:08,179 --> 00:13:13,100
look at the the neck construction have

00:13:10,339 --> 00:13:14,540
another link to the tuners

00:13:13,100 --> 00:13:16,240
the fretboard might be different

00:13:14,540 --> 00:13:18,830
material might be the same material

00:13:16,240 --> 00:13:21,680
might have multiple necks might have

00:13:18,830 --> 00:13:22,760
different frets so we've gone through

00:13:21,680 --> 00:13:27,710
all this and we haven't even talked

00:13:22,760 --> 00:13:28,670
about the colors or the inlays I mean

00:13:27,710 --> 00:13:29,720
there's a whole bunch of variable

00:13:28,670 --> 00:13:31,580
options that if you're going to sit

00:13:29,720 --> 00:13:33,200
there and normalize this data you are

00:13:31,580 --> 00:13:35,510
going to be there at a long time doing

00:13:33,200 --> 00:13:37,280
this and if I'm making your tars I don't

00:13:35,510 --> 00:13:38,600
want to sit there and play making tables

00:13:37,280 --> 00:13:41,030
I want to actually go out there and make

00:13:38,600 --> 00:13:43,100
guitars now in engineering terms they

00:13:41,030 --> 00:13:45,650
call this finite element analysis you

00:13:43,100 --> 00:13:47,420
keep digging down and digging down and

00:13:45,650 --> 00:13:50,450
digging down until you get to the nth

00:13:47,420 --> 00:13:51,920
degree if you're a small business you

00:13:50,450 --> 00:13:54,260
can't afford to do this if you're a

00:13:51,920 --> 00:13:56,000
small developer working a small house

00:13:54,260 --> 00:13:57,350
you can't go down this rabbit hole for

00:13:56,000 --> 00:13:58,730
your customers on every time or you're

00:13:57,350 --> 00:14:02,480
just gonna be stuck in the database

00:13:58,730 --> 00:14:05,270
forever now this is the database world

00:14:02,480 --> 00:14:07,430
known as a many-to-many join each time

00:14:05,270 --> 00:14:09,590
you do this you have to dive into the

00:14:07,430 --> 00:14:12,590
index table and from the index table

00:14:09,590 --> 00:14:15,140
dive into the data table so here we dive

00:14:12,590 --> 00:14:18,320
into one index to one table into a

00:14:15,140 --> 00:14:20,540
second index into another table which

00:14:18,320 --> 00:14:22,700
might actually be several records there

00:14:20,540 --> 00:14:24,980
and yet again into a third one so we

00:14:22,700 --> 00:14:28,840
have at least six dives into the indexes

00:14:24,980 --> 00:14:32,480
and data not exactly a cheap operation

00:14:28,840 --> 00:14:34,640
so what I'm going to do is I'm going to

00:14:32,480 --> 00:14:37,130
use the JSON data type and I'm going to

00:14:34,640 --> 00:14:39,530
come up with a minimal normalized set of

00:14:37,130 --> 00:14:41,750
data and anything else kind of a

00:14:39,530 --> 00:14:44,120
grab-bag I'm going to throw into that

00:14:41,750 --> 00:14:45,800
Jason column I have a gigabyte of

00:14:44,120 --> 00:14:47,240
information I can store in there if I

00:14:45,800 --> 00:14:52,250
need more than that I can add in another

00:14:47,240 --> 00:14:54,500
column of the same data type now great

00:14:52,250 --> 00:14:56,920
thing about the JSON is that it's

00:14:54,500 --> 00:14:59,330
mutable if someone comes in and says hey

00:14:56,920 --> 00:15:02,690
changed the color from Dupont number red

00:14:59,330 --> 00:15:04,910
to purple number fifteen I can do that

00:15:02,690 --> 00:15:08,630
on the fly I don't have to go back and

00:15:04,910 --> 00:15:11,000
really worry about hitting the the

00:15:08,630 --> 00:15:13,130
database for the relational tables I can

00:15:11,000 --> 00:15:17,330
do it on the fly and the JSON data if I

00:15:13,130 --> 00:15:19,610
want to pull that out I can later so

00:15:17,330 --> 00:15:20,870
since the daytime data is mutable we can

00:15:19,610 --> 00:15:22,850
add out of the stuff so if they come in

00:15:20,870 --> 00:15:24,830
and say I want a baloney enlace

00:15:22,850 --> 00:15:26,000
someplace on there it's very easy to

00:15:24,830 --> 00:15:30,320
just to plug that in

00:15:26,000 --> 00:15:31,940
the data once again is mutable so if I

00:15:30,320 --> 00:15:33,440
later need to normalize some piece of

00:15:31,940 --> 00:15:34,850
information like the production data

00:15:33,440 --> 00:15:36,980
it's like we want to know the date

00:15:34,850 --> 00:15:38,810
started location when it was roughly

00:15:36,980 --> 00:15:40,490
finished when the paint started when the

00:15:38,810 --> 00:15:42,440
paint finished in the final assembly and

00:15:40,490 --> 00:15:43,730
then most importantly for someone with a

00:15:42,440 --> 00:15:45,950
small business and when it shipped to

00:15:43,730 --> 00:15:48,500
the customer we can go out and extract

00:15:45,950 --> 00:15:52,970
stuff from the JSON data and normalize

00:15:48,500 --> 00:15:54,290
that as needed now since I'm here from

00:15:52,970 --> 00:15:56,480
MySQL I got to talk about our MySQL

00:15:54,290 --> 00:16:00,140
documents store this is a schema list

00:15:56,480 --> 00:16:01,550
JSON no SQL database the good news for

00:16:00,140 --> 00:16:04,880
most of you is you no longer have to

00:16:01,550 --> 00:16:08,810
embed strings of SQL in your code yeah

00:16:04,880 --> 00:16:11,390
got one whoo we also use a very modern

00:16:08,810 --> 00:16:14,450
style for the API I hope you're going to

00:16:11,390 --> 00:16:16,550
like it and the also the big option is

00:16:14,450 --> 00:16:19,160
that you can go in to the same data at

00:16:16,550 --> 00:16:20,900
the same time from the no sequel side to

00:16:19,160 --> 00:16:24,340
the sequel side so it gives you the best

00:16:20,900 --> 00:16:26,960
of both worlds now this is what our

00:16:24,340 --> 00:16:28,610
architecture looks like on the left-hand

00:16:26,960 --> 00:16:30,380
side your application talks to a mass

00:16:28,610 --> 00:16:33,110
scale connector which hopefully you all

00:16:30,380 --> 00:16:36,290
of you is either MySQL eye or PDO if

00:16:33,110 --> 00:16:40,520
you're using the old MySQL and you're on

00:16:36,290 --> 00:16:43,910
PHP 5/5 or earlier please bow your head

00:16:40,520 --> 00:16:48,380
and disgrace and leave the conference on

00:16:43,910 --> 00:16:50,600
the right-hand side hey I actually have

00:16:48,380 --> 00:16:57,170
a customer near me that's running last

00:16:50,600 --> 00:16:58,370
ql4 one with PDP PHP 5-3 that I wrote 15

00:16:57,170 --> 00:16:59,990
years ago but it only does one

00:16:58,370 --> 00:17:02,330
application and they know that's it's

00:16:59,990 --> 00:17:03,380
bad and then won't let me upgrade it but

00:17:02,330 --> 00:17:05,770
on the right hand side we have our new

00:17:03,380 --> 00:17:09,770
shell with our new protocol our new crud

00:17:05,770 --> 00:17:11,480
and SQL supporting protocol by the way

00:17:09,770 --> 00:17:16,250
our standard protocols 20-some odd years

00:17:11,480 --> 00:17:18,740
old and is showing some aging pains our

00:17:16,250 --> 00:17:21,380
new protocols built on Google protobufs

00:17:18,740 --> 00:17:22,790
so it's not tightly TechEd but it's a

00:17:21,380 --> 00:17:25,430
lot better so it's going to help reduce

00:17:22,790 --> 00:17:28,760
SQL injection has a lot of other

00:17:25,430 --> 00:17:30,980
features for managing things like in ODB

00:17:28,760 --> 00:17:33,440
cluster by using our new shell if you're

00:17:30,980 --> 00:17:35,960
running Moscow 5 7 you type check for

00:17:33,440 --> 00:17:36,830
upgrade put in your host parameters and

00:17:35,960 --> 00:17:39,560
we'll tell you what you need to change

00:17:36,830 --> 00:17:40,850
before you do a 5 7 8 o upgrade

00:17:39,560 --> 00:17:43,100
but the most important thing for we're

00:17:40,850 --> 00:17:46,960
talking about today is the new protocol

00:17:43,100 --> 00:17:49,250
that you talked to the JSON collections

00:17:46,960 --> 00:17:50,390
I'm not sure how bad this is to read in

00:17:49,250 --> 00:17:52,640
the back hopefully you can see it on the

00:17:50,390 --> 00:17:53,840
side thing here's our new shell by the

00:17:52,640 --> 00:17:56,630
way the new shell has three modes

00:17:53,840 --> 00:18:00,020
JavaScript Python built-in interpreters

00:17:56,630 --> 00:18:03,620
for that and SQL a lot of neat features

00:18:00,020 --> 00:18:06,080
in there so I come in here I create a

00:18:03,620 --> 00:18:08,500
collection called Dave guitar Dave

00:18:06,080 --> 00:18:10,580
guitar add put it in the first record

00:18:08,500 --> 00:18:12,500
away we go

00:18:10,580 --> 00:18:16,130
great thing about the new shell is that

00:18:12,500 --> 00:18:18,170
you can use it to prototype data to get

00:18:16,130 --> 00:18:21,860
started by the way the API is pretty

00:18:18,170 --> 00:18:26,000
much the same Python JavaScript PHP C++

00:18:21,860 --> 00:18:29,960
what are their language you want and if

00:18:26,000 --> 00:18:31,250
I do dave underscore guitar dot find it

00:18:29,960 --> 00:18:36,350
will come back and give me out all all

00:18:31,250 --> 00:18:38,060
the information I can also index the

00:18:36,350 --> 00:18:40,700
data I can either do it from Wizard

00:18:38,060 --> 00:18:42,260
document store from the SQL side so we

00:18:40,700 --> 00:18:44,660
can actually index the data for faster

00:18:42,260 --> 00:18:47,390
searches on the backend side behind the

00:18:44,660 --> 00:18:49,460
protocol the optimizer does basically

00:18:47,390 --> 00:18:50,660
the same thing to your data that makes

00:18:49,460 --> 00:18:59,210
it very efficient for you to be able to

00:18:50,660 --> 00:19:01,190
get information out now I can also it

00:18:59,210 --> 00:19:02,570
was the new API when we asked for

00:19:01,190 --> 00:19:06,770
certain fields if I want I could say I

00:19:02,570 --> 00:19:10,280
just want the type field I can also go

00:19:06,770 --> 00:19:12,140
out there and if I don't specify as I

00:19:10,280 --> 00:19:13,970
didn't hear the type equals Les Paul I

00:19:12,140 --> 00:19:15,740
can actually go out there and just say

00:19:13,970 --> 00:19:18,820
okay find me all the records and give me

00:19:15,740 --> 00:19:22,040
the type and sort it by the type the

00:19:18,820 --> 00:19:23,330
guys who designed our API were very

00:19:22,040 --> 00:19:24,590
thorough and they looked what's out

00:19:23,330 --> 00:19:27,260
there and they also we're looking what

00:19:24,590 --> 00:19:29,360
we support for the sequel side and this

00:19:27,260 --> 00:19:31,070
is just one railroad diagram you can see

00:19:29,360 --> 00:19:33,320
for fine that we have all the standard

00:19:31,070 --> 00:19:36,320
things you're used to search conditions

00:19:33,320 --> 00:19:40,070
age over 25 fields I want the age and

00:19:36,320 --> 00:19:43,310
postal code group by having sort limits

00:19:40,070 --> 00:19:46,940
offsets and locks so this does support

00:19:43,310 --> 00:19:49,790
transactions so for those of you who are

00:19:46,940 --> 00:19:51,140
tired of having your IDE blow up on

00:19:49,790 --> 00:19:53,360
stuff like this because it can't help

00:19:51,140 --> 00:19:55,460
you are

00:19:53,360 --> 00:19:56,660
our new API I think is a little bit

00:19:55,460 --> 00:19:59,809
easier to read a little bit easier to

00:19:56,660 --> 00:20:01,850
comprehend so rather than doing a select

00:19:59,809 --> 00:20:04,549
from people we're job like dollar job

00:20:01,850 --> 00:20:08,000
and age greater than dollar age we can

00:20:04,549 --> 00:20:10,549
say find job like variable job and age

00:20:08,000 --> 00:20:11,770
greater than variable age bind those

00:20:10,549 --> 00:20:16,850
variables in there

00:20:11,770 --> 00:20:19,250
executed by the way this also works with

00:20:16,850 --> 00:20:21,290
tables so if you want to use the new API

00:20:19,250 --> 00:20:23,750
and you want to do it with your existing

00:20:21,290 --> 00:20:26,450
tables or new tables you setup it's very

00:20:23,750 --> 00:20:28,070
similar the thing is instead of fine you

00:20:26,450 --> 00:20:29,390
know how the keyword select so we're

00:20:28,070 --> 00:20:32,990
gonna select name and district from a

00:20:29,390 --> 00:20:34,370
table called city where the district is

00:20:32,990 --> 00:20:35,990
like a variable named District we'll

00:20:34,370 --> 00:20:38,840
plug in the name Texas into that

00:20:35,990 --> 00:20:43,010
variable we want the first 25 records go

00:20:38,840 --> 00:20:47,780
out and do the fetch all also something

00:20:43,010 --> 00:20:51,260
you can do with our no sequel software

00:20:47,780 --> 00:20:53,120
is very complex analytics this is

00:20:51,260 --> 00:20:55,520
something you can't do in or the

00:20:53,120 --> 00:20:58,970
other no SQL s this is actually a very

00:20:55,520 --> 00:21:01,100
very interesting piece of code JSON

00:20:58,970 --> 00:21:05,380
table is a function that lets you take

00:21:01,100 --> 00:21:08,450
this unstructured no SQL JSON data and

00:21:05,380 --> 00:21:10,640
temporarily turn it into a relational

00:21:08,450 --> 00:21:12,169
table once you have in a relational

00:21:10,640 --> 00:21:13,940
table you can use all the other

00:21:12,169 --> 00:21:17,120
relational tools out there for analytics

00:21:13,940 --> 00:21:19,220
in this case what we're doing is we're

00:21:17,120 --> 00:21:21,860
going to rank a whole bunch of grades

00:21:19,220 --> 00:21:24,140
for restaurants in New York we're gonna

00:21:21,860 --> 00:21:25,970
rank them by the cuisine giving you the

00:21:24,140 --> 00:21:27,980
highest average score or the top order

00:21:25,970 --> 00:21:31,640
and then we're gonna feed that into a

00:21:27,980 --> 00:21:33,890
common table expression CT es are a fast

00:21:31,640 --> 00:21:35,270
way to write sub queries sub query is

00:21:33,890 --> 00:21:38,090
going to be a pain in the butt to write

00:21:35,270 --> 00:21:40,580
CT es are easier to write easier to

00:21:38,090 --> 00:21:43,630
comprehend and easier to modify so in

00:21:40,580 --> 00:21:46,040
this we're taking our nois SQL data

00:21:43,630 --> 00:21:48,429
turning into pulling out the average

00:21:46,040 --> 00:21:50,780
grades for the restaurants and then

00:21:48,429 --> 00:21:52,940
ranking that by the average score and

00:21:50,780 --> 00:21:54,080
giving you the highest one by cuisine so

00:21:52,940 --> 00:21:55,340
if you want to know the best Indian

00:21:54,080 --> 00:21:58,549
restaurant in the five boroughs of New

00:21:55,340 --> 00:22:00,940
York or the best Italian this will get

00:21:58,549 --> 00:22:00,940
it for you

00:22:01,620 --> 00:22:05,520
and if you don't want to rewrite your

00:22:03,299 --> 00:22:08,909
old queries but you want to use the new

00:22:05,520 --> 00:22:10,590
protocol we came up with a little SQL

00:22:08,909 --> 00:22:12,470
operator so you can plug in your old

00:22:10,590 --> 00:22:15,330
queries and take advantage of the new

00:22:12,470 --> 00:22:17,460
protocol so mentioned earlier the new

00:22:15,330 --> 00:22:21,240
shell comes with three modes JavaScript

00:22:17,460 --> 00:22:23,390
Python and SQL I was in the Dominican

00:22:21,240 --> 00:22:25,770
Republic last weekend working with a

00:22:23,390 --> 00:22:27,659
Python group that's starting a new

00:22:25,770 --> 00:22:29,309
conference there and there are some

00:22:27,659 --> 00:22:30,929
things I couldn't do with Python they're

00:22:29,309 --> 00:22:32,880
able to be rather easily it's all there

00:22:30,929 --> 00:22:36,690
on your screen so if you want to somehow

00:22:32,880 --> 00:22:40,409
ETL your data or change it on the fly

00:22:36,690 --> 00:22:42,779
you can write ad-hoc reports also we

00:22:40,409 --> 00:22:45,330
have a bulk loader for JSON by the way

00:22:42,779 --> 00:22:46,740
this bulk loader now understands JSON B

00:22:45,330 --> 00:22:48,929
so if you have stuff you're importing

00:22:46,740 --> 00:22:51,870
from we know how to handle that

00:22:48,929 --> 00:22:55,070
it's very fast in this case in just over

00:22:51,870 --> 00:22:57,470
two seconds it read in 25,000 records

00:22:55,070 --> 00:23:04,110
very quick very neat

00:22:57,470 --> 00:23:04,919
so hybrid databases what is it a good

00:23:04,110 --> 00:23:12,120
idea or not

00:23:04,919 --> 00:23:13,620
well it's not really a panacea for best

00:23:12,120 --> 00:23:15,179
performance out of a database when you

00:23:13,620 --> 00:23:16,649
have hundreds of millions of Records

00:23:15,179 --> 00:23:18,919
you're probably going to want to use

00:23:16,649 --> 00:23:21,870
third fourth or fifth normalized form

00:23:18,919 --> 00:23:23,549
you want everything fully normalized you

00:23:21,870 --> 00:23:26,100
want to have everything indexed properly

00:23:23,549 --> 00:23:27,929
and you're going to have very carefully

00:23:26,100 --> 00:23:30,029
developed queries because you have

00:23:27,929 --> 00:23:32,850
millions of transactions going on at any

00:23:30,029 --> 00:23:34,380
one time unfortunately that's not the

00:23:32,850 --> 00:23:36,740
business case for most of you these days

00:23:34,380 --> 00:23:36,740
anymore

00:23:36,940 --> 00:23:41,320
so if you work in a world where you have

00:23:39,549 --> 00:23:43,570
that many transactions and nothing

00:23:41,320 --> 00:23:45,909
really changes you don't really need

00:23:43,570 --> 00:23:49,389
mutable data this is great

00:23:45,909 --> 00:23:51,129
non-hybrid databases are great but if

00:23:49,389 --> 00:23:52,299
you're in a in an environment where you

00:23:51,129 --> 00:23:54,309
don't know the data structures or

00:23:52,299 --> 00:23:55,629
they're changing all the time

00:23:54,309 --> 00:23:56,919
you really don't have a big need for

00:23:55,629 --> 00:23:58,419
data you're talking hundreds of

00:23:56,919 --> 00:24:02,830
thousands of records not millions or

00:23:58,419 --> 00:24:04,809
billions and you really have a data set

00:24:02,830 --> 00:24:06,249
that's in flux most the time something

00:24:04,809 --> 00:24:08,889
new is coming in something olds going

00:24:06,249 --> 00:24:10,269
out things are changing all the time you

00:24:08,889 --> 00:24:14,710
might want to start looking in at a

00:24:10,269 --> 00:24:17,139
hybrid database by the way masks ul8 has

00:24:14,710 --> 00:24:18,669
been out for about a year now big

00:24:17,139 --> 00:24:21,279
features we talked about yesterday by

00:24:18,669 --> 00:24:24,749
Gabby and her talk I won't really go

00:24:21,279 --> 00:24:28,599
into any of those details except for

00:24:24,749 --> 00:24:31,450
resource groups you can actually nail

00:24:28,599 --> 00:24:33,999
certain CPUs on your system hopefully

00:24:31,450 --> 00:24:37,330
it's a multiple CPU system for a batch

00:24:33,999 --> 00:24:40,989
group or a fast payment group or

00:24:37,330 --> 00:24:43,419
something like that and in your query in

00:24:40,989 --> 00:24:45,309
the in a comment you put in there this

00:24:43,419 --> 00:24:47,049
goes to this resource group the

00:24:45,309 --> 00:24:48,249
optimizer will dedicate those queries

00:24:47,049 --> 00:24:50,590
and make sure that it only goes to those

00:24:48,249 --> 00:24:53,859
CPU so you can actually dedicate part of

00:24:50,590 --> 00:24:56,129
your server by the way if you're dealing

00:24:53,859 --> 00:24:59,039
with JSON or MySQL please buy my book I

00:24:56,129 --> 00:25:01,899
think I gave away my last copy yesterday

00:24:59,039 --> 00:25:03,639
it's 120 some odd pages

00:25:01,899 --> 00:25:05,950
it's very concise if you've read the

00:25:03,639 --> 00:25:07,899
MySQL manuals on the JSON data type

00:25:05,950 --> 00:25:09,369
they're not exactly the clearest things

00:25:07,899 --> 00:25:12,239
in the world and I have some very

00:25:09,369 --> 00:25:15,639
interesting and very concise examples

00:25:12,239 --> 00:25:17,919
also if you're looking for more

00:25:15,639 --> 00:25:21,669
information on the pec extension for the

00:25:17,919 --> 00:25:24,340
x dev api for PHP i have a link up there

00:25:21,669 --> 00:25:26,649
for the manual on how to get it running

00:25:24,340 --> 00:25:30,249
have another link for the MySQL document

00:25:26,649 --> 00:25:35,019
store also a link to the X J of API user

00:25:30,249 --> 00:25:38,950
guide also two weeks ago in Miami I had

00:25:35,019 --> 00:25:40,539
an X dev API tutorial the links are out

00:25:38,950 --> 00:25:43,090
there and the information is actually on

00:25:40,539 --> 00:25:47,259
my github account under PHP X dev API

00:25:43,090 --> 00:25:50,849
and with that I've run through my

00:25:47,259 --> 00:25:50,849
schpeel what questions do you have

00:25:53,700 --> 00:26:08,350
[Applause]

00:26:01,440 --> 00:26:10,570
yes sir you mentioned that there is a

00:26:08,350 --> 00:26:14,080
small impact on performance if you are

00:26:10,570 --> 00:26:17,470
using your not normalizing data and just

00:26:14,080 --> 00:26:20,590
dumping it into a JSON type string yeah

00:26:17,470 --> 00:26:22,000
how much would it be for example and can

00:26:20,590 --> 00:26:25,179
you index the data that is inside the

00:26:22,000 --> 00:26:28,270
JSON yes you can you can index today's

00:26:25,179 --> 00:26:30,010
jada within the JSON you can also use a

00:26:28,270 --> 00:26:31,210
generated column to pull that data out

00:26:30,010 --> 00:26:32,919
of the JSON and put it into a

00:26:31,210 --> 00:26:35,860
materialized column within the SQL

00:26:32,919 --> 00:26:37,150
relational tables performance I'm not

00:26:35,860 --> 00:26:37,750
seeing anything more than three to four

00:26:37,150 --> 00:26:39,669
percent

00:26:37,750 --> 00:26:40,840
unfortunately Oracle doesn't want me

00:26:39,669 --> 00:26:42,940
giving benchmarks is I'm not the

00:26:40,840 --> 00:26:44,470
benchmark guy the benchmark guy keeps

00:26:42,940 --> 00:26:47,980
telling me yeah I'll get it to you next

00:26:44,470 --> 00:26:49,210
week since little February so I don't

00:26:47,980 --> 00:26:50,980
really have any hard numbers I can give

00:26:49,210 --> 00:26:55,650
you but my gut feeling is three to four

00:26:50,980 --> 00:26:55,650
percent okay thank you thank you

00:26:57,690 --> 00:27:03,299
any other questions

00:26:59,700 --> 00:27:03,299
it's a quiet group

00:27:08,110 --> 00:27:14,929
so far for text search which way is

00:27:12,530 --> 00:27:19,970
being preferred to use it or is being

00:27:14,929 --> 00:27:22,550
still using old unnormalized database or

00:27:19,970 --> 00:27:25,640
using session processor adjacent as

00:27:22,550 --> 00:27:27,020
possible as a performer wise for total

00:27:25,640 --> 00:27:29,480
text search which is better the new

00:27:27,020 --> 00:27:31,820
protocol the old protocol right now I'd

00:27:29,480 --> 00:27:34,490
say the old protocol but give us a few

00:27:31,820 --> 00:27:36,860
months we're working on other things by

00:27:34,490 --> 00:27:39,260
the way we just released 8 o 15 two

00:27:36,860 --> 00:27:40,850
weeks ago 8 or 16 will be out in April

00:27:39,260 --> 00:27:42,770
and for those who've always wanted check

00:27:40,850 --> 00:27:44,410
constraints which is something that

00:27:42,770 --> 00:27:46,700
we've accepted but never actually

00:27:44,410 --> 00:27:49,190
implemented that's gonna be out there at

00:27:46,700 --> 00:27:50,929
8 or 16 but for now if you're doing

00:27:49,190 --> 00:27:53,090
especially in ODB full-text search use

00:27:50,929 --> 00:27:55,970
the old protocol now you could actually

00:27:53,090 --> 00:27:58,400
read in that data in the JSON pull it

00:27:55,970 --> 00:27:59,960
out with a general generated column and

00:27:58,400 --> 00:28:02,059
do the full-text search on that which is

00:27:59,960 --> 00:28:09,380
probably the way I'd recommend to do

00:28:02,059 --> 00:28:14,500
that okay

00:28:09,380 --> 00:28:16,250
hi PHP in my sequel they have a

00:28:14,500 --> 00:28:20,270
wonderful love story

00:28:16,250 --> 00:28:29,840
why isn't PHP in the console only Python

00:28:20,270 --> 00:28:34,010
in jest actually I got the question last

00:28:29,840 --> 00:28:37,250
week why was it Perl in there I don't

00:28:34,010 --> 00:28:39,190
know I I know a lot of the analytic

00:28:37,250 --> 00:28:42,409
folks are doing a lot of stuff with

00:28:39,190 --> 00:28:43,970
Python and of course as a PHP programmer

00:28:42,409 --> 00:28:48,590
that means you only know about eighteen

00:28:43,970 --> 00:28:50,260
JavaScript frameworks it's one of those

00:28:48,590 --> 00:28:52,010
things I don't know why they didn't put

00:28:50,260 --> 00:28:55,309
PHP in there

00:28:52,010 --> 00:28:58,010
I think PHP is a little more heavyweight

00:28:55,309 --> 00:29:00,950
than either Python or JavaScript right

00:28:58,010 --> 00:29:02,360
now I can talk to the guys who are in

00:29:00,950 --> 00:29:05,419
charge of that I'm not sure why they

00:29:02,360 --> 00:29:07,130
didn't put it in PHP but basically my

00:29:05,419 --> 00:29:10,669
career for the past 25 years has been

00:29:07,130 --> 00:29:12,530
thanks to Monty witness David x mark and

00:29:10,669 --> 00:29:16,299
Rasmus lured or because I basically been

00:29:12,530 --> 00:29:16,299

YouTube URL: https://www.youtube.com/watch?v=Y7Z1vwbG7rY


