Title: Storing Non-Scalar Data - Derick Rethans - PHP UK Conference 2019
Publication date: 2019-03-22
Playlist: PHP UK Conference 2019
Description: 
	In this presentation we will look at storing complex data in a single field. Many noSQL solutions are created around this (such as Redis’ lists, sets and hashes; MongoDB’s records), and many relational database now also support storing complex data in a single field through specific data types (such as PostGreSQL’s JSONB or hstore). Each of the different database engines support different things, and handle these data types in different ways. In this session we compare the different approaches to storage, indexing and interactions with these data types in different databases.
Captions: 
	00:00:03,589 --> 00:00:07,649
it's so hi I'm Derek I have no

00:00:06,000 --> 00:00:10,980
introduction Aries lights so I'll just

00:00:07,649 --> 00:00:13,700
get Jim straight into the subject which

00:00:10,980 --> 00:00:17,970
is a subject of storing non scalar data

00:00:13,700 --> 00:00:20,160
so non scalar data is more complicated

00:00:17,970 --> 00:00:22,740
things than just your standard strings

00:00:20,160 --> 00:00:24,539
numbers and boolean s-- so they're they

00:00:22,740 --> 00:00:27,060
tend to be erased you nested objects

00:00:24,539 --> 00:00:29,480
your arrays of objects it tends to be a

00:00:27,060 --> 00:00:32,520
more natural way how you would store

00:00:29,480 --> 00:00:34,350
application objects in a database in

00:00:32,520 --> 00:00:38,399
different ways and traditionally people

00:00:34,350 --> 00:00:41,670
with relational databases you get to do

00:00:38,399 --> 00:00:44,190
that with different types of patterns if

00:00:41,670 --> 00:00:45,750
any of you have seen a Eevee or

00:00:44,190 --> 00:00:48,480
something like that it's a way of

00:00:45,750 --> 00:00:51,390
storing a single object with lots of not

00:00:48,480 --> 00:00:54,420
necessarily defined properties in a

00:00:51,390 --> 00:00:58,649
relational database but in the last

00:00:54,420 --> 00:01:00,420
years decades maybe even more and more

00:00:58,649 --> 00:01:02,879
different types of databases showed up

00:01:00,420 --> 00:01:06,990
no it's called databases as they're

00:01:02,879 --> 00:01:10,320
called in which many different flavors

00:01:06,990 --> 00:01:12,060
exists between the intention of storing

00:01:10,320 --> 00:01:14,369
data in a more natural way as it would

00:01:12,060 --> 00:01:16,860
show up for applications so that is the

00:01:14,369 --> 00:01:20,820
non scalar data that I'm having him so a

00:01:16,860 --> 00:01:22,710
few examples here for example if any of

00:01:20,820 --> 00:01:26,580
you've ever written a blog application I

00:01:22,710 --> 00:01:28,170
certainly have a long time ago it's it's

00:01:26,580 --> 00:01:30,869
also a common thing that you tag a

00:01:28,170 --> 00:01:33,630
specific posts with multiple tags right

00:01:30,869 --> 00:01:35,549
so in this case the tags that I pick

00:01:33,630 --> 00:01:37,560
here from Oakland Street Map data Open

00:01:35,549 --> 00:01:40,020
Street Map beta is free data each

00:01:37,560 --> 00:01:43,649
objects you seen a map can be tagged

00:01:40,020 --> 00:01:45,180
with many different tags but storing

00:01:43,649 --> 00:01:46,710
this kind of information in relational

00:01:45,180 --> 00:01:48,329
database what you would often do is well

00:01:46,710 --> 00:01:51,000
you have to create an extra table with

00:01:48,329 --> 00:01:55,770
this to store the taxon that you can

00:01:51,000 --> 00:01:57,479
then link to your articles so you

00:01:55,770 --> 00:01:59,490
actually storing in an array of tags

00:01:57,479 --> 00:02:01,920
separately from where you usually store

00:01:59,490 --> 00:02:03,600
your data which is more complicated on

00:02:01,920 --> 00:02:06,030
the way of doing ends and then

00:02:03,600 --> 00:02:08,090
separately there's examples like you

00:02:06,030 --> 00:02:10,080
have promised careful product catalogs

00:02:08,090 --> 00:02:13,500
if you have a product catalog

00:02:10,080 --> 00:02:15,900
I always take Amazon's example here

00:02:13,500 --> 00:02:19,290
I'm pretty sure not many of you operator

00:02:15,900 --> 00:02:21,810
of the skilled Amazon here but of course

00:02:19,290 --> 00:02:24,480
there's product catalogs you can store

00:02:21,810 --> 00:02:26,520
about books as well as in my example

00:02:24,480 --> 00:02:29,910
whiskey Sarit and Wilson sells whiskies

00:02:26,520 --> 00:02:30,960
in the UK sorry handy and of course all

00:02:29,910 --> 00:02:32,610
these different products will have

00:02:30,960 --> 00:02:35,820
different properties like a risky

00:02:32,610 --> 00:02:37,860
doesn't have a number of pages may makes

00:02:35,820 --> 00:02:41,490
no sense right and similarly book

00:02:37,860 --> 00:02:44,490
doesn't have in them have a alcohol

00:02:41,490 --> 00:02:45,840
percentage for example or a distillery

00:02:44,490 --> 00:02:48,000
attached to that necessarily right so

00:02:45,840 --> 00:02:50,220
you have different properties but it's

00:02:48,000 --> 00:02:53,010
still part of something that is a

00:02:50,220 --> 00:02:54,720
product and traditionally relational

00:02:53,010 --> 00:02:57,870
database don't handle storing their data

00:02:54,720 --> 00:02:59,970
particularly very well or unless yeah it

00:02:57,870 --> 00:03:02,190
gets very complicated sometimes alright

00:02:59,970 --> 00:03:04,020
so what is this presentation not about

00:03:02,190 --> 00:03:07,350
it also important I'm not going to talk

00:03:04,020 --> 00:03:08,880
about how he's store this data in a

00:03:07,350 --> 00:03:11,520
scalable way I'm not going to talk about

00:03:08,880 --> 00:03:15,120
high availability I'm not going to go

00:03:11,520 --> 00:03:16,620
into an in-depth technology covering of

00:03:15,120 --> 00:03:19,170
all the things I'm mentioning here

00:03:16,620 --> 00:03:21,360
because I'll be talking for days and I

00:03:19,170 --> 00:03:23,790
only have 57 minutes left

00:03:21,360 --> 00:03:25,560
and also not talk about benchmarks so

00:03:23,790 --> 00:03:29,310
benchmark is always a bit of a tricky

00:03:25,560 --> 00:03:30,989
point because you can't really benchmark

00:03:29,310 --> 00:03:33,510
to different knows go solutions against

00:03:30,989 --> 00:03:35,730
its order because they are all there to

00:03:33,510 --> 00:03:37,230
do something very different so it makes

00:03:35,730 --> 00:03:38,760
no sense to compare these things

00:03:37,230 --> 00:03:42,870
together so I won't be talking about

00:03:38,760 --> 00:03:44,760
that alright so the things that we're

00:03:42,870 --> 00:03:46,680
going to have a look at in the next 50

00:03:44,760 --> 00:03:48,900
minutes or so is we're going to look at

00:03:46,680 --> 00:03:52,049
different database types for storing

00:03:48,900 --> 00:03:55,170
known scalar data and go a little bit

00:03:52,049 --> 00:03:56,940
into how what sort of data you can store

00:03:55,170 --> 00:03:57,720
in these different types and what

00:03:56,940 --> 00:03:59,340
they're good for

00:03:57,720 --> 00:04:01,440
but then going to have a look at query

00:03:59,340 --> 00:04:02,880
manipulating data indexes a little bit

00:04:01,440 --> 00:04:06,650
and then we have a conclusion areum's

00:04:02,880 --> 00:04:09,269
and then some Q&A as oh all right so

00:04:06,650 --> 00:04:10,680
different database how many database

00:04:09,269 --> 00:04:14,100
types do you think there are different

00:04:10,680 --> 00:04:16,410
database types guess guess you've heard

00:04:14,100 --> 00:04:21,150
of relational databases right key value

00:04:16,410 --> 00:04:23,280
stores there's a document data stores

00:04:21,150 --> 00:04:24,750
there's xml data stores there are so

00:04:23,280 --> 00:04:27,180
many of them out all right there's an

00:04:24,750 --> 00:04:30,630
article on wikipedia i believe that this

00:04:27,180 --> 00:04:31,860
57 different types now to be honest I

00:04:30,630 --> 00:04:34,470
think they've been a little bit too far

00:04:31,860 --> 00:04:35,880
were debts and I tend to want to group

00:04:34,470 --> 00:04:37,620
them together in about four different

00:04:35,880 --> 00:04:40,199
categories of which we'll be talking

00:04:37,620 --> 00:04:42,300
about three of them and not talking

00:04:40,199 --> 00:04:44,759
about relational databases in this

00:04:42,300 --> 00:04:46,949
presentation so the simple one is key

00:04:44,759 --> 00:04:49,050
value stores key value stores what I

00:04:46,949 --> 00:04:51,630
really good at they're usually really

00:04:49,050 --> 00:04:53,520
small really fast and all the operations

00:04:51,630 --> 00:04:57,360
that you can do with these are on the

00:04:53,520 --> 00:05:00,509
key owning but minor variations but

00:04:57,360 --> 00:05:03,840
usually on key only but what they do

00:05:00,509 --> 00:05:06,449
allow for often is that the values that

00:05:03,840 --> 00:05:08,669
you store with these keys they don't

00:05:06,449 --> 00:05:10,020
have to be simple numbers or strings or

00:05:08,669 --> 00:05:12,030
boolean's or something like that

00:05:10,020 --> 00:05:15,180
they allow you to store more rich data

00:05:12,030 --> 00:05:17,130
as a single value for a specific key an

00:05:15,180 --> 00:05:19,620
example that we'll be looking at here is

00:05:17,130 --> 00:05:24,020
for example Redis memcache is another

00:05:19,620 --> 00:05:27,509
variant of this group of databases then

00:05:24,020 --> 00:05:31,380
so diving a little bit deeper into Redis

00:05:27,509 --> 00:05:34,620
so in Redis the keys are binary safe

00:05:31,380 --> 00:05:37,349
strings these values on reddit's are

00:05:34,620 --> 00:05:39,750
also binary safe strings but it strings

00:05:37,349 --> 00:05:41,639
between quotes because it does do clever

00:05:39,750 --> 00:05:44,130
things with numbers so numbers are also

00:05:41,639 --> 00:05:45,449
stored as strings but you can also still

00:05:44,130 --> 00:05:49,650
do calculations with them so they're

00:05:45,449 --> 00:05:51,780
string strings but beyond these it also

00:05:49,650 --> 00:05:53,880
allows you to store lists and sets and

00:05:51,780 --> 00:05:57,120
hashes sorted sets and a whole bunch of

00:05:53,880 --> 00:05:59,159
other thing that are sometimes a lot

00:05:57,120 --> 00:06:02,759
more natural to how an application deals

00:05:59,159 --> 00:06:05,580
with the data so the interaction with

00:06:02,759 --> 00:06:08,699
this happens to read a seal I or period

00:06:05,580 --> 00:06:11,130
esperadas which is a composer

00:06:08,699 --> 00:06:13,229
installable library that helps you do

00:06:11,130 --> 00:06:15,449
these things or you can talk to it with

00:06:13,229 --> 00:06:16,949
telnet if you really wanted to at the

00:06:15,449 --> 00:06:18,930
exams that I've been showing here are

00:06:16,949 --> 00:06:20,310
with Vettes CLI which is a very simple

00:06:18,930 --> 00:06:22,500
way of doing it if you're doing this

00:06:20,310 --> 00:06:26,610
through PHP application you'd be using

00:06:22,500 --> 00:06:29,699
TLS espionage and I've spoken to normal

00:06:26,610 --> 00:06:32,610
strings so the way how the raddest

00:06:29,699 --> 00:06:34,470
protocol works is kind of very very

00:06:32,610 --> 00:06:36,860
simple it's a command-line interface

00:06:34,470 --> 00:06:38,880
that you talk to over network connection

00:06:36,860 --> 00:06:40,270
except that there's some binary

00:06:38,880 --> 00:06:42,580
information here that

00:06:40,270 --> 00:06:47,110
you can't see because I'm using this

00:06:42,580 --> 00:06:49,419
through the Venice CLI tool so the data

00:06:47,110 --> 00:06:52,240
that comes back is a little bit more

00:06:49,419 --> 00:06:55,270
rich than just strings which are the

00:06:52,240 --> 00:06:57,910
commands that you gave it to so all the

00:06:55,270 --> 00:06:59,830
commands in Redis start often with a

00:06:57,910 --> 00:07:02,470
single letter or multiple letters to

00:06:59,830 --> 00:07:06,789
indicate what type of data we are

00:07:02,470 --> 00:07:11,199
operating on so D s in s @ stands for

00:07:06,789 --> 00:07:13,720
sets and a set of data is a collection

00:07:11,199 --> 00:07:14,800
of data that belongs to specifically so

00:07:13,720 --> 00:07:18,039
what I'm doing in this first example

00:07:14,800 --> 00:07:21,280
here that I'm quit using the key whiskey

00:07:18,039 --> 00:07:24,070
: Glenfiddich : tack that is one single

00:07:21,280 --> 00:07:26,440
key because our operations you do are on

00:07:24,070 --> 00:07:28,690
a single key you need to do something

00:07:26,440 --> 00:07:32,889
clever about being able to store

00:07:28,690 --> 00:07:35,199
properties of objects so well the key

00:07:32,889 --> 00:07:39,729
here basically says that our data type

00:07:35,199 --> 00:07:42,220
is a whiskey our unique identifier is

00:07:39,729 --> 00:07:44,740
grant fit of - 12 and a property that

00:07:42,220 --> 00:07:47,590
we're storing with as are the tanks so

00:07:44,740 --> 00:07:50,169
the set name is whiskey : Glen filler 12

00:07:47,590 --> 00:07:52,720
: tanks and then the values that we're

00:07:50,169 --> 00:07:54,789
adding to the set is what we doing as a

00:07:52,720 --> 00:07:56,590
second argument here so in this case

00:07:54,789 --> 00:07:59,349
we're tagging that this whiskey is

00:07:56,590 --> 00:08:00,789
fruity and has vanilla in it and if you

00:07:59,349 --> 00:08:02,560
add another element to the set that's

00:08:00,789 --> 00:08:03,909
already in there it will tell you by

00:08:02,560 --> 00:08:06,099
using the 0 as returned

00:08:03,909 --> 00:08:08,080
that's this element is already there so

00:08:06,099 --> 00:08:10,180
set doesn't allow you to store the same

00:08:08,080 --> 00:08:13,539
value multiple times because that's

00:08:10,180 --> 00:08:16,240
won't be a set anymore or you can add

00:08:13,539 --> 00:08:17,979
things to it if you want a space in it's

00:08:16,240 --> 00:08:20,680
in your names then you need to also

00:08:17,979 --> 00:08:21,940
double quotes from PHP itself you

00:08:20,680 --> 00:08:23,710
interact slightly different whether they

00:08:21,940 --> 00:08:27,180
have nice names for all the operators I

00:08:23,710 --> 00:08:29,440
don't have an example that though so

00:08:27,180 --> 00:08:31,030
after all the elements to do sets you

00:08:29,440 --> 00:08:33,900
can of course do operations against

00:08:31,030 --> 00:08:38,200
astern trying to figure out whether a

00:08:33,900 --> 00:08:41,289
tank or in a word a string is a member

00:08:38,200 --> 00:08:44,920
of the set so a ucs is member operator

00:08:41,289 --> 00:08:47,350
and I'm basically I'm trying here is the

00:08:44,920 --> 00:08:49,089
whiskey tank with the word PT and as you

00:08:47,350 --> 00:08:50,980
can see in the first bit here we haven't

00:08:49,089 --> 00:08:52,480
added that so the return value of this

00:08:50,980 --> 00:08:55,480
is going to be 0

00:08:52,480 --> 00:08:57,190
as members return to you all the members

00:08:55,480 --> 00:08:59,350
of this episode as all the ones we have

00:08:57,190 --> 00:09:03,310
set in the first example so these are

00:08:59,350 --> 00:09:04,720
red assets it's a a way of storing this

00:09:03,310 --> 00:09:06,850
information and you can then then

00:09:04,720 --> 00:09:08,200
operations against this data type and

00:09:06,850 --> 00:09:09,430
those operations are at sama

00:09:08,200 --> 00:09:12,070
corporations you don't have to pull the

00:09:09,430 --> 00:09:14,440
data down compared in your your PHP

00:09:12,070 --> 00:09:16,240
application or all application modified

00:09:14,440 --> 00:09:18,520
and stored back all those operators are

00:09:16,240 --> 00:09:20,170
atomic operations which is important to

00:09:18,520 --> 00:09:22,150
know because that is how you interact

00:09:20,170 --> 00:09:24,280
with almost all the know the soil

00:09:22,150 --> 00:09:26,200
database you need to figure out the best

00:09:24,280 --> 00:09:28,690
optimal operations you can do only a

00:09:26,200 --> 00:09:30,690
data type in order to not run into race

00:09:28,690 --> 00:09:33,460
conditions and to make optimal storage

00:09:30,690 --> 00:09:36,790
make use of the the capabilities of the

00:09:33,460 --> 00:09:38,860
databases so rather sets are very good

00:09:36,790 --> 00:09:40,510
way of quickly doing this whereas

00:09:38,860 --> 00:09:42,280
usually runs into memory in in memory

00:09:40,510 --> 00:09:44,530
although you can back it up to disk as

00:09:42,280 --> 00:09:47,020
well and there's base of doing that but

00:09:44,530 --> 00:09:49,750
it's a very quick way of doing this kind

00:09:47,020 --> 00:09:54,550
of operations it's really really fast to

00:09:49,750 --> 00:09:56,110
do some similar things there's also a

00:09:54,550 --> 00:10:00,670
hash data type they work like

00:09:56,110 --> 00:10:02,770
associative arrays in PHP so H the first

00:10:00,670 --> 00:10:05,110
letter here stands now for hash and when

00:10:02,770 --> 00:10:07,030
you do a hash set again we use the key

00:10:05,110 --> 00:10:09,100
in this case it's the props key of the

00:10:07,030 --> 00:10:10,900
benefits whiskey and we say that the

00:10:09,100 --> 00:10:14,920
distillery is associated with this is

00:10:10,900 --> 00:10:17,410
called been novice and then with H M set

00:10:14,920 --> 00:10:20,800
M is a letter that often comes after the

00:10:17,410 --> 00:10:22,810
first reticence from multi means we can

00:10:20,800 --> 00:10:24,070
set multiple values and one go so in

00:10:22,810 --> 00:10:26,080
this case he's setting the properties

00:10:24,070 --> 00:10:29,100
region Scotland Highlands as well as age

00:10:26,080 --> 00:10:32,740
19 at the same time again one operation

00:10:29,100 --> 00:10:35,200
doing multiple things and then

00:10:32,740 --> 00:10:37,030
retrieving is also possible using H get

00:10:35,200 --> 00:10:38,800
all if you ask for the properties and

00:10:37,030 --> 00:10:41,290
then what you get on the Redis command

00:10:38,800 --> 00:10:43,390
line script if she gets key value key

00:10:41,290 --> 00:10:45,780
values always different values in your

00:10:43,390 --> 00:10:48,160
in your result which is kind of Oakland

00:10:45,780 --> 00:10:49,690
pirata spiritus handles that a lot

00:10:48,160 --> 00:10:51,810
better and you get actually an

00:10:49,690 --> 00:10:54,520
associative array back so that's better

00:10:51,810 --> 00:10:56,620
beyond that you can also retrieve single

00:10:54,520 --> 00:10:58,600
elements of this hash we're using H gets

00:10:56,620 --> 00:11:00,910
and you can see that even though we set

00:10:58,600 --> 00:11:03,880
the value as 19 as a number it still

00:11:00,910 --> 00:11:05,590
comes back as a string 19 so the strings

00:11:03,880 --> 00:11:08,230
are a bit tricky

00:11:05,590 --> 00:11:10,779
all right so there was a quick overview

00:11:08,230 --> 00:11:12,970
of Redis it's a very simple way of

00:11:10,779 --> 00:11:15,670
dealing with very specific data types

00:11:12,970 --> 00:11:17,410
but because it is all in memory it is

00:11:15,670 --> 00:11:20,230
really fast way of handling that

00:11:17,410 --> 00:11:22,740
information so Redis is often used for

00:11:20,230 --> 00:11:25,690
either kind of caching information or

00:11:22,740 --> 00:11:28,029
doing on-the-fly calculations of quick

00:11:25,690 --> 00:11:29,339
things that are always available and it

00:11:28,029 --> 00:11:34,960
doesn't particularly matter very much

00:11:29,339 --> 00:11:36,640
sorry an intention is that you can

00:11:34,960 --> 00:11:41,440
always build back this data formal

00:11:36,640 --> 00:11:43,960
information so I give me one second yes

00:11:41,440 --> 00:11:47,400
this always happens about five minutes

00:11:43,960 --> 00:11:47,400
in I'm sorry

00:11:48,540 --> 00:12:00,250
so a little bit further than it's gone

00:11:54,190 --> 00:12:03,640
some music going on here so a little bit

00:12:00,250 --> 00:12:05,860
more feature-rich than what Redis or key

00:12:03,640 --> 00:12:09,250
value stores are are the document data

00:12:05,860 --> 00:12:12,280
stores and the document data stores are

00:12:09,250 --> 00:12:15,820
often feature parity with relational

00:12:12,280 --> 00:12:18,670
databases not always normal all specific

00:12:15,820 --> 00:12:22,570
cases but it tend to be built for having

00:12:18,670 --> 00:12:24,520
a to be able to run on distributed

00:12:22,570 --> 00:12:30,160
networks so I really have to do this

00:12:24,520 --> 00:12:37,420
because always going to annoy me instead

00:12:30,160 --> 00:12:40,030
of the sounds so you some humor in there

00:12:37,420 --> 00:12:43,060
I started the date the document data

00:12:40,030 --> 00:12:44,680
stores allow for to store more virtually

00:12:43,060 --> 00:12:48,360
information that you can interact with

00:12:44,680 --> 00:12:51,160
in many other things than just the key

00:12:48,360 --> 00:12:53,709
so there's now possible to do operations

00:12:51,160 --> 00:12:55,720
on keys and values you can do searchers

00:12:53,709 --> 00:12:58,380
own values and not just on the keys like

00:12:55,720 --> 00:13:01,600
you can do with key value stores and

00:12:58,380 --> 00:13:04,660
often if you see examples of document

00:13:01,600 --> 00:13:06,550
stores they are all will show you the

00:13:04,660 --> 00:13:10,200
data in a JSON format because the JSON

00:13:06,550 --> 00:13:13,120
format is a slightly richer data type

00:13:10,200 --> 00:13:15,220
however most document most document

00:13:13,120 --> 00:13:17,800
stores will not actually store the

00:13:15,220 --> 00:13:19,390
information as JSON on this because it's

00:13:17,800 --> 00:13:21,250
a text format that you need to

00:13:19,390 --> 00:13:24,760
all the time which is really inefficient

00:13:21,250 --> 00:13:27,490
right so examples of document stores are

00:13:24,760 --> 00:13:30,910
for example MongoDB or couch TV elastic

00:13:27,490 --> 00:13:33,760
search and all fetching much work in the

00:13:30,910 --> 00:13:36,040
same sort of way or at least the way how

00:13:33,760 --> 00:13:38,530
you can how your data modeling for these

00:13:36,040 --> 00:13:41,560
databases works of course things like

00:13:38,530 --> 00:13:45,160
monitor being couch to be they are there

00:13:41,560 --> 00:13:47,940
are like I call it their their databases

00:13:45,160 --> 00:13:51,100
right there storing data elastic search

00:13:47,940 --> 00:13:52,900
has a different aspect to it where it is

00:13:51,100 --> 00:13:55,510
really good as a full-text search index

00:13:52,900 --> 00:13:58,420
you can also use it as a database sort

00:13:55,510 --> 00:14:00,970
of but it isn't meant for it I mean

00:13:58,420 --> 00:14:02,320
another set search your search indexes

00:14:00,970 --> 00:14:04,690
aren't always necessarily up to date

00:14:02,320 --> 00:14:07,450
immediately is which is something you

00:14:04,690 --> 00:14:09,100
expect from a database right I mean if

00:14:07,450 --> 00:14:12,490
you write it and your read data it

00:14:09,100 --> 00:14:14,460
should be there immediately from from

00:14:12,490 --> 00:14:16,600
the same server if you talk to it

00:14:14,460 --> 00:14:19,360
difference between Mon remain Cal to be

00:14:16,600 --> 00:14:22,360
are mostly around how you write data to

00:14:19,360 --> 00:14:24,910
it I'm only being single master Cal

00:14:22,360 --> 00:14:26,800
should be being multi master but by

00:14:24,910 --> 00:14:29,290
having these differences you get all our

00:14:26,800 --> 00:14:31,840
points of contentions in all the

00:14:29,290 --> 00:14:34,900
different ways on how you store data or

00:14:31,840 --> 00:14:37,690
rather how you distribute this data

00:14:34,900 --> 00:14:39,700
among the multiple notes so although

00:14:37,690 --> 00:14:41,680
they are all a little bit similar it

00:14:39,700 --> 00:14:43,150
also a little bit different again I

00:14:41,680 --> 00:14:45,010
can't go into detail between all of it

00:14:43,150 --> 00:14:47,140
because I'd be talking for days so I

00:14:45,010 --> 00:14:48,970
have to focus on one on database so

00:14:47,140 --> 00:14:52,170
talking about monger to be most because

00:14:48,970 --> 00:14:54,340
I know it the best thing and so the

00:14:52,170 --> 00:14:55,870
first line is a bit controversial too

00:14:54,340 --> 00:14:57,970
moment servants also that's about too

00:14:55,870 --> 00:14:59,800
much but among Ruby is it's like any

00:14:57,970 --> 00:15:01,240
other day talk things I've been talking

00:14:59,800 --> 00:15:04,000
about it's something you can use for

00:15:01,240 --> 00:15:05,740
free it doesn't cost you any money so

00:15:04,000 --> 00:15:08,530
the documents are stored as decent on

00:15:05,740 --> 00:15:11,560
this so Beeson is a binary way of

00:15:08,530 --> 00:15:14,380
storing JSON information except that it

00:15:11,560 --> 00:15:17,380
has a few additional data types so it's

00:15:14,380 --> 00:15:19,660
like a date/time stamp for example or

00:15:17,380 --> 00:15:21,250
there's binary data and those data type

00:15:19,660 --> 00:15:23,140
is something that normally Jason doesn't

00:15:21,250 --> 00:15:26,320
have so there's a few extra data types

00:15:23,140 --> 00:15:29,680
Toronto Manasa so the interaction from

00:15:26,320 --> 00:15:32,440
phone within say PHP or any other

00:15:29,680 --> 00:15:33,220
language you can think of what you do is

00:15:32,440 --> 00:15:34,930
you build data

00:15:33,220 --> 00:15:37,899
structures in such application just like

00:15:34,930 --> 00:15:42,029
there were normal variables and then you

00:15:37,899 --> 00:15:44,290
can transfer those through a client

00:15:42,029 --> 00:15:46,300
through PHP extension like you have to

00:15:44,290 --> 00:15:48,490
my school sanctioned that's among the B

00:15:46,300 --> 00:15:50,829
extension or an elasticsearch extension

00:15:48,490 --> 00:15:54,279
or things like that it's the way they

00:15:50,829 --> 00:15:56,019
will take this information put it in a

00:15:54,279 --> 00:15:57,790
different format over the network and

00:15:56,019 --> 00:16:01,839
then the database stores it into its own

00:15:57,790 --> 00:16:03,550
formats right so the documents that you

00:16:01,839 --> 00:16:05,980
interact with from your application will

00:16:03,550 --> 00:16:08,170
be as natural PHP objects you can just

00:16:05,980 --> 00:16:12,189
say sort of speech P object for me and

00:16:08,170 --> 00:16:13,839
it'll gets orders for you but I mean

00:16:12,189 --> 00:16:16,600
there's always going to be some gotchas

00:16:13,839 --> 00:16:18,970
in here of course but what it does mean

00:16:16,600 --> 00:16:21,730
is that of course in a PHP if you have

00:16:18,970 --> 00:16:23,889
an object a single property can be an

00:16:21,730 --> 00:16:25,180
array right and an array in a

00:16:23,889 --> 00:16:28,180
traditionally in a relational database

00:16:25,180 --> 00:16:31,779
it counts really store an array of

00:16:28,180 --> 00:16:33,430
values for a specific fields or you can

00:16:31,779 --> 00:16:35,769
do that if you serialize that speech

00:16:33,430 --> 00:16:39,629
PCEHR lies drug which I'm sure some of

00:16:35,769 --> 00:16:42,629
you have done in the past I know I have

00:16:39,629 --> 00:16:45,339
so yeah those documents are a richer

00:16:42,629 --> 00:16:47,110
because they can store these arrays they

00:16:45,339 --> 00:16:49,050
can also store arrays of objects or

00:16:47,110 --> 00:16:52,000
nested objects and so on and soon I'm

00:16:49,050 --> 00:16:54,279
going to be interact with through a PHP

00:16:52,000 --> 00:16:56,230
extension called MongoDB and to make

00:16:54,279 --> 00:16:58,540
things easier to use you also use a

00:16:56,230 --> 00:17:02,649
optional composing soluble library

00:16:58,540 --> 00:17:05,860
called monger V / MongoDB alright so

00:17:02,649 --> 00:17:06,909
some examples here as I said most of the

00:17:05,860 --> 00:17:09,309
examples that you see an online

00:17:06,909 --> 00:17:11,860
documentation will be with a JSON

00:17:09,309 --> 00:17:13,870
documents the things that I'm talking

00:17:11,860 --> 00:17:15,610
about here how does documents look like

00:17:13,870 --> 00:17:17,829
will also apply for how to be an elastic

00:17:15,610 --> 00:17:20,860
search virtually no differences in

00:17:17,829 --> 00:17:22,179
whatsoever so what are the things in it

00:17:20,860 --> 00:17:25,419
what are the important things in a well

00:17:22,179 --> 00:17:28,270
first of all you have a unique ID you

00:17:25,419 --> 00:17:32,169
can a unique ID is basically a primary

00:17:28,270 --> 00:17:35,500
key if you don't set on yourself it will

00:17:32,169 --> 00:17:39,580
automatically generate a complicated

00:17:35,500 --> 00:17:41,799
number we usually advise to use like if

00:17:39,580 --> 00:17:43,120
you have a unique key some already use

00:17:41,799 --> 00:17:44,530
it yourself don't come up with something

00:17:43,120 --> 00:17:46,990
near that you don't have to invent so

00:17:44,530 --> 00:17:51,220
this underscore ID field issue

00:17:46,990 --> 00:17:54,040
primary key but them there are values

00:17:51,220 --> 00:17:57,100
that have extra things in there so the

00:17:54,040 --> 00:17:58,809
words Fields has four words in it and

00:17:57,100 --> 00:18:00,820
they are stored as an array they're not

00:17:58,809 --> 00:18:02,350
going to be serialized or anything like

00:18:00,820 --> 00:18:05,800
that they really just sort us in the

00:18:02,350 --> 00:18:09,040
ring and similarly the field badges is

00:18:05,800 --> 00:18:11,920
an array and each element in array is an

00:18:09,040 --> 00:18:13,420
object with key value pairs again this

00:18:11,920 --> 00:18:15,220
is also that you can just store and you

00:18:13,420 --> 00:18:17,290
don't have to worry about this and you

00:18:15,220 --> 00:18:21,429
can even query this directly through the

00:18:17,290 --> 00:18:24,280
query languages so as an example here

00:18:21,429 --> 00:18:29,230
just to look at how simple this insert

00:18:24,280 --> 00:18:33,010
data is first thing we do is we require

00:18:29,230 --> 00:18:34,690
the the library don't compose installed

00:18:33,010 --> 00:18:37,960
library because it provides a nice

00:18:34,690 --> 00:18:42,730
interface to it we define a variable

00:18:37,960 --> 00:18:44,380
called whiskey's which we define as we

00:18:42,730 --> 00:18:47,290
make a connection with MongoDB clients

00:18:44,380 --> 00:18:50,350
use the DRAM I Oh database and the

00:18:47,290 --> 00:18:53,200
whiskey collection collection among

00:18:50,350 --> 00:18:55,480
Arabi is your table it's equivalent to a

00:18:53,200 --> 00:18:58,210
table so the whiskey's variable here is

00:18:55,480 --> 00:18:59,950
now the table or collection objects that

00:18:58,210 --> 00:19:01,990
we can do operations on like insert

00:18:59,950 --> 00:19:06,429
update delete your corporation we can

00:19:01,990 --> 00:19:09,670
think of some documents the basic

00:19:06,429 --> 00:19:11,620
element that you store are often either

00:19:09,670 --> 00:19:14,320
represented in associative arrays like

00:19:11,620 --> 00:19:17,140
I've done here or our PHP objects and

00:19:14,320 --> 00:19:19,600
the driver allows you to map different

00:19:17,140 --> 00:19:21,070
data types depending on which fuel to

00:19:19,600 --> 00:19:23,380
all the data types when you're hydrating

00:19:21,070 --> 00:19:24,580
or dehydrating again can't really go in

00:19:23,380 --> 00:19:25,990
there because I'm not going to have the

00:19:24,580 --> 00:19:29,290
time for that but there's a lot more

00:19:25,990 --> 00:19:31,570
things possible than just looking these

00:19:29,290 --> 00:19:33,910
at normal PHP objects or associative

00:19:31,570 --> 00:19:35,830
arrays so but what I'm doing here is

00:19:33,910 --> 00:19:38,140
that with insert while I'm inserting a

00:19:35,830 --> 00:19:42,070
single documents and we didn't serve

00:19:38,140 --> 00:19:45,400
many you insert multiple documents it

00:19:42,070 --> 00:19:51,880
isn't that complicated to to to make use

00:19:45,400 --> 00:19:54,250
of this all right so I bombs meninos go

00:19:51,880 --> 00:19:56,110
databases solids adding support for

00:19:54,250 --> 00:19:57,970
these richer data types that I've shown

00:19:56,110 --> 00:19:59,930
you believe avetis or the document

00:19:57,970 --> 00:20:02,600
stores with MongoDB

00:19:59,930 --> 00:20:06,680
many relational databases also started

00:20:02,600 --> 00:20:08,630
adding data types to functionality to

00:20:06,680 --> 00:20:10,880
store death kind of extra data because

00:20:08,630 --> 00:20:12,800
they must have seen well lots of people

00:20:10,880 --> 00:20:14,360
find this useful and that's all this

00:20:12,800 --> 00:20:17,630
functionality to relational databases

00:20:14,360 --> 00:20:20,270
own because I mean how many of you have

00:20:17,630 --> 00:20:22,390
had formal relational database theory

00:20:20,270 --> 00:20:28,190
and uni at some point must be some yeah

00:20:22,390 --> 00:20:30,020
right and that is really nice it has

00:20:28,190 --> 00:20:32,870
allows you to make the most optimal

00:20:30,020 --> 00:20:37,429
database scheme to store it in your

00:20:32,870 --> 00:20:39,410
database but it isn't always the most

00:20:37,429 --> 00:20:42,130
optimal way of interacting with your

00:20:39,410 --> 00:20:45,080
data form your application right I mean

00:20:42,130 --> 00:20:48,410
I'm pretty sure many of you will have

00:20:45,080 --> 00:20:50,390
taken shortcuts to make data easy to

00:20:48,410 --> 00:20:54,050
query or easy to store from application

00:20:50,390 --> 00:20:57,920
or to avoid having 20 weight joints all

00:20:54,050 --> 00:21:01,700
right I mean they happen so these

00:20:57,920 --> 00:21:04,190
additional data types that I've added

00:21:01,700 --> 00:21:09,050
are good for storing this or

00:21:04,190 --> 00:21:11,630
unstructured data that we have seen with

00:21:09,050 --> 00:21:13,670
both say Redis as well as mongery an

00:21:11,630 --> 00:21:15,890
examples of databases that don't so are

00:21:13,670 --> 00:21:20,059
one might impose fiscal if you go even

00:21:15,890 --> 00:21:22,760
back traditionally IBM db2 would allow

00:21:20,059 --> 00:21:25,640
you to store similar things in its xml

00:21:22,760 --> 00:21:27,530
database right I mean xml database is a

00:21:25,640 --> 00:21:30,530
whole different can of worms again but

00:21:27,530 --> 00:21:32,270
um I mean XML so of course is a richer

00:21:30,530 --> 00:21:35,179
data format than just your standard

00:21:32,270 --> 00:21:37,220
numbers and and strings so the examples

00:21:35,179 --> 00:21:38,840
of this group are my own Postgres Co all

00:21:37,220 --> 00:21:41,540
we talked mostly about posters go here

00:21:38,840 --> 00:21:43,190
because in my opinion has a slightly

00:21:41,540 --> 00:21:45,050
better implementation or it allows a

00:21:43,190 --> 00:21:49,700
little bit more functionality which

00:21:45,050 --> 00:21:53,929
makes it a better target for comparing

00:21:49,700 --> 00:21:56,990
it alright so just like Redis Bosco has

00:21:53,929 --> 00:22:00,550
actually different types of data types

00:21:56,990 --> 00:22:04,490
to store different types of data

00:22:00,550 --> 00:22:06,620
primarily there's H store which is your

00:22:04,490 --> 00:22:10,820
associative array kind of variant

00:22:06,620 --> 00:22:12,530
there's Jason and Jason B so you can see

00:22:10,820 --> 00:22:13,610
that I haven't highlighted Jason because

00:22:12,530 --> 00:22:15,740
nobody would ever use

00:22:13,610 --> 00:22:18,440
anymore but it was the first on their

00:22:15,740 --> 00:22:20,540
attitude to Jason B variant the be

00:22:18,440 --> 00:22:24,560
standing for binary is an optimized

00:22:20,540 --> 00:22:27,770
version of soaring as information very

00:22:24,560 --> 00:22:31,160
similar to the besom form on a daily for

00:22:27,770 --> 00:22:33,140
example and postcodes has a much richer

00:22:31,160 --> 00:22:35,330
query indexes for demise go for this

00:22:33,140 --> 00:22:37,070
data type I also like that

00:22:35,330 --> 00:22:40,880
post-classical has also an elephant as a

00:22:37,070 --> 00:22:44,330
logo so I prefer to use that and so how

00:22:40,880 --> 00:22:47,210
does an h2 look like well basically what

00:22:44,330 --> 00:22:50,600
you do is you store a JSON document into

00:22:47,210 --> 00:22:52,580
a single data type so in order to make

00:22:50,600 --> 00:22:56,600
use of this you need to activate the h2

00:22:52,580 --> 00:22:58,310
extension which I'm I have to admit some

00:22:56,600 --> 00:23:00,950
of these slides are written maybe half

00:22:58,310 --> 00:23:02,870
year ago this technology and post Cosco

00:23:00,950 --> 00:23:06,740
moves very fast so I might be slightly

00:23:02,870 --> 00:23:09,080
outdated here when I looked at this you

00:23:06,740 --> 00:23:11,780
still had to activate the h2 extension

00:23:09,080 --> 00:23:15,260
it is quite possible that you don't have

00:23:11,780 --> 00:23:18,320
to do this anymore now so bit is

00:23:15,260 --> 00:23:20,990
extension available we then created

00:23:18,320 --> 00:23:23,600
table we created table users with a

00:23:20,990 --> 00:23:26,750
single field called H doc and the type

00:23:23,600 --> 00:23:28,820
of this data type is H store this is not

00:23:26,750 --> 00:23:30,530
something that most people do because at

00:23:28,820 --> 00:23:32,450
least you'd have a unique primary key

00:23:30,530 --> 00:23:34,520
and things like that right but I try to

00:23:32,450 --> 00:23:35,810
make this as easy the example as simple

00:23:34,520 --> 00:23:40,760
as possible so I left all these things

00:23:35,810 --> 00:23:44,930
out and in the last block here as I'm

00:23:40,760 --> 00:23:47,750
inserting into users a disassociative

00:23:44,930 --> 00:23:49,820
array but how am i inserting this as you

00:23:47,750 --> 00:23:51,530
can see I'm storing this as a string now

00:23:49,820 --> 00:23:53,780
I know that's a little bit hard to see

00:23:51,530 --> 00:23:55,580
somewhere but there is a single single

00:23:53,780 --> 00:23:57,470
quotes here the single quotes here to

00:23:55,580 --> 00:23:58,910
show that you stored it as a string

00:23:57,470 --> 00:24:01,280
because interactions with a relational

00:23:58,910 --> 00:24:05,780
database are always going to be true

00:24:01,280 --> 00:24:07,490
strings but probably the exception of

00:24:05,780 --> 00:24:10,190
sending values through prepared queries

00:24:07,490 --> 00:24:11,600
where they will have the possibility of

00:24:10,190 --> 00:24:14,840
not using strings but most of

00:24:11,600 --> 00:24:17,330
interactions especially from PHP if you

00:24:14,840 --> 00:24:18,770
don't do anything with it any query that

00:24:17,330 --> 00:24:21,170
will come back from same is called the

00:24:18,770 --> 00:24:23,990
data types will still be strings right I

00:24:21,170 --> 00:24:25,160
mean PDO just a little bit better so

00:24:23,990 --> 00:24:26,630
there's all the things to it but

00:24:25,160 --> 00:24:27,300
traditionally you would only get a

00:24:26,630 --> 00:24:28,920
string back

00:24:27,300 --> 00:24:31,970
because there was a standard way of

00:24:28,920 --> 00:24:35,850
interacting through SQL now

00:24:31,970 --> 00:24:37,890
interestingly there are a few

00:24:35,850 --> 00:24:41,430
limitations to what you can do at a

00:24:37,890 --> 00:24:43,050
Chester Sage store although you can see

00:24:41,430 --> 00:24:45,180
that we're storing it as string and a

00:24:43,050 --> 00:24:47,130
number it basically stores it as a

00:24:45,180 --> 00:24:49,860
string anyway so it is you can't really

00:24:47,130 --> 00:24:51,900
do operations on these values you can't

00:24:49,860 --> 00:24:56,940
for example increment the number by one

00:24:51,900 --> 00:24:59,490
for a count if you feel or add or login

00:24:56,940 --> 00:25:03,540
an extra time it can't just simply bump

00:24:59,490 --> 00:25:05,100
that number but it will have things like

00:25:03,540 --> 00:25:09,510
strings and billions and numbers in that

00:25:05,100 --> 00:25:11,760
so well PostgreSQL wants to do it h2r so

00:25:09,510 --> 00:25:13,200
this is some extra information that we

00:25:11,760 --> 00:25:15,630
can tag to things so that we are already

00:25:13,200 --> 00:25:16,800
storing in a database so it's an example

00:25:15,630 --> 00:25:18,840
I was talking a little bit about

00:25:16,800 --> 00:25:20,940
OpenStreetMap and storing text with it

00:25:18,840 --> 00:25:23,250
right because in OpenStreetMap the data

00:25:20,940 --> 00:25:25,800
model is like well everything has a type

00:25:23,250 --> 00:25:31,530
which is either note or way or relation

00:25:25,800 --> 00:25:32,880
it has an ID number from 1 to 4 and 1/2

00:25:31,530 --> 00:25:35,850
billion or whatever the number is at the

00:25:32,880 --> 00:25:39,090
moment and then it has tags that you can

00:25:35,850 --> 00:25:41,280
just cook up yourself there is a

00:25:39,090 --> 00:25:43,440
standard set of tanks that people are

00:25:41,280 --> 00:25:44,970
Gris with to using because if you have a

00:25:43,440 --> 00:25:46,950
road well you need to know what type of

00:25:44,970 --> 00:25:48,810
road it is and what its name is and

00:25:46,950 --> 00:25:50,370
people need to agree on what the names

00:25:48,810 --> 00:25:53,280
for these texts otherwise you can't make

00:25:50,370 --> 00:25:55,830
a nice map out of it right but as all

00:25:53,280 --> 00:25:58,800
our other people then all that

00:25:55,830 --> 00:26:00,510
information for say cycling

00:25:58,800 --> 00:26:02,340
infrastructure on these roads so they

00:26:00,510 --> 00:26:05,370
came up with a scheme to the odds

00:26:02,340 --> 00:26:07,830
additional tanks to put in addition to

00:26:05,370 --> 00:26:10,080
this object to this road for this

00:26:07,830 --> 00:26:11,970
information and nothing stops any other

00:26:10,080 --> 00:26:13,350
user from adding additional information

00:26:11,970 --> 00:26:15,990
to it with the own tank schemes that I

00:26:13,350 --> 00:26:17,940
come up with now if you want to draw

00:26:15,990 --> 00:26:22,520
maps out of this the way how this

00:26:17,940 --> 00:26:26,430
usually works is you do a query and then

00:26:22,520 --> 00:26:28,290
bidders information you search for roads

00:26:26,430 --> 00:26:32,010
or you search for cycling infrastructure

00:26:28,290 --> 00:26:34,080
you can then draw something but because

00:26:32,010 --> 00:26:37,290
the amount of tanks that a specific

00:26:34,080 --> 00:26:38,580
object can have is unbound and upfront

00:26:37,290 --> 00:26:40,470
undefined

00:26:38,580 --> 00:26:41,160
how are you going to index all that

00:26:40,470 --> 00:26:42,780
information

00:26:41,160 --> 00:26:44,610
I mean you can't really clear create a

00:26:42,780 --> 00:26:45,930
column for every single tank that you

00:26:44,610 --> 00:26:48,500
come up with because you end up having

00:26:45,930 --> 00:26:51,750
hundreds of thousands of columns

00:26:48,500 --> 00:26:54,180
databases don't handle that there's no

00:26:51,750 --> 00:26:58,410
database I know they can handle that but

00:26:54,180 --> 00:27:00,600
what you can do is for the tags that are

00:26:58,410 --> 00:27:02,850
not necessarily agreed upon

00:27:00,600 --> 00:27:05,100
you can still chuck them in an H store

00:27:02,850 --> 00:27:07,860
because she can still query against this

00:27:05,100 --> 00:27:09,660
to do your map drawing without having to

00:27:07,860 --> 00:27:10,680
create a column for every single tag

00:27:09,660 --> 00:27:15,630
that you come up with

00:27:10,680 --> 00:27:18,660
so the an H store it's really good for

00:27:15,630 --> 00:27:20,340
handling this kind of of data stored

00:27:18,660 --> 00:27:22,530
where you have a common set of

00:27:20,340 --> 00:27:24,720
information that everybody agrees on and

00:27:22,530 --> 00:27:27,390
then a whole bunch of other things that

00:27:24,720 --> 00:27:29,040
you don't so the the query against an H

00:27:27,390 --> 00:27:31,530
store is not going to be as far as doing

00:27:29,040 --> 00:27:33,450
an index query against a normal field

00:27:31,530 --> 00:27:36,000
salary combination but it's still

00:27:33,450 --> 00:27:38,370
possible to do and you can also if you

00:27:36,000 --> 00:27:40,680
retrieve this fill back in your

00:27:38,370 --> 00:27:41,940
application and you can do all the

00:27:40,680 --> 00:27:45,390
things that is like render the

00:27:41,940 --> 00:27:48,720
information in this h2r without too much

00:27:45,390 --> 00:27:51,300
complications so H store is used in

00:27:48,720 --> 00:27:55,770
OpenStreetMap projects to do this kind

00:27:51,300 --> 00:27:58,050
of stuff the other data type that people

00:27:55,770 --> 00:28:00,330
use with Postgres goes to Jason B data

00:27:58,050 --> 00:28:03,180
type and adjacent B data type is very

00:28:00,330 --> 00:28:05,670
similar how you can interact with that

00:28:03,180 --> 00:28:07,790
as what document data stores like Mona

00:28:05,670 --> 00:28:11,310
being couch to be an elastic search Jim

00:28:07,790 --> 00:28:15,360
and it can be you can create indexes on

00:28:11,310 --> 00:28:17,820
it and unlike my scores Jason type or

00:28:15,360 --> 00:28:19,490
Postgres calls jason type the indexes

00:28:17,820 --> 00:28:22,340
you can set on that are very different

00:28:19,490 --> 00:28:28,110
from what you would normally do on

00:28:22,340 --> 00:28:30,120
relational database data like we don't

00:28:28,110 --> 00:28:32,160
really set things up like unique indexes

00:28:30,120 --> 00:28:34,230
or an index on a specific fuel or

00:28:32,160 --> 00:28:36,330
compound field you set them on a

00:28:34,230 --> 00:28:37,980
specific data type and there's different

00:28:36,330 --> 00:28:38,430
indexes I'll get back to that in a

00:28:37,980 --> 00:28:41,550
moment

00:28:38,430 --> 00:28:43,170
so Jason B data type supports richer

00:28:41,550 --> 00:28:44,850
data types than the values compared to H

00:28:43,170 --> 00:28:48,240
store because an H there is just really

00:28:44,850 --> 00:28:51,090
key value and the values can be things

00:28:48,240 --> 00:28:53,760
like arrays or nested objects whereas

00:28:51,090 --> 00:28:54,690
with the Jason B data type he can store

00:28:53,760 --> 00:28:56,519
that information

00:28:54,690 --> 00:28:59,580
so again let's have a look at how that

00:28:56,519 --> 00:29:02,129
looks like since out of H store we're

00:28:59,580 --> 00:29:05,369
using D Jason B data type and in there

00:29:02,129 --> 00:29:06,989
we now insert a string which is a JSON

00:29:05,369 --> 00:29:08,249
document and it's formatted according

00:29:06,989 --> 00:29:10,470
exactly to Jason

00:29:08,249 --> 00:29:12,869
basically what I've done but I created

00:29:10,470 --> 00:29:16,080
this example by copying pasting the

00:29:12,869 --> 00:29:19,369
information I had in my example

00:29:16,080 --> 00:29:21,629
and I just put insert into users values

00:29:19,369 --> 00:29:23,909
quotation mark in front of it that's the

00:29:21,629 --> 00:29:26,970
only thing I've changed them and then

00:29:23,909 --> 00:29:28,950
British data of the sort post Cuzco will

00:29:26,970 --> 00:29:31,169
parse this when you send it to the

00:29:28,950 --> 00:29:33,090
database stored in a binary format so

00:29:31,169 --> 00:29:34,470
that you can create indexes on it and do

00:29:33,090 --> 00:29:40,409
queries against all those different data

00:29:34,470 --> 00:29:43,080
types all right so now we have stored

00:29:40,409 --> 00:29:45,239
data it's probably useful to have a look

00:29:43,080 --> 00:29:48,210
at how we can query for this data

00:29:45,239 --> 00:29:51,499
because database is pretty useless if

00:29:48,210 --> 00:29:53,849
you can't get the data out all right so

00:29:51,499 --> 00:29:55,799
with Redis we already looked a little

00:29:53,849 --> 00:29:57,450
bit I'll address how we can do this

00:29:55,799 --> 00:29:59,039
right well do you remember the example

00:29:57,450 --> 00:30:01,950
about the sets that you can use SS

00:29:59,039 --> 00:30:03,659
member to see whether a specific values

00:30:01,950 --> 00:30:06,059
and member of assets or you can get all

00:30:03,659 --> 00:30:08,309
of them back by s numbers similarly for

00:30:06,059 --> 00:30:10,679
the hashes there's an H get all to get

00:30:08,309 --> 00:30:13,289
all the key value combinations and H M

00:30:10,679 --> 00:30:15,899
gets to get only specific hash keys out

00:30:13,289 --> 00:30:17,789
of that but there's a few other data

00:30:15,899 --> 00:30:20,549
types that are allow for more specific

00:30:17,789 --> 00:30:24,269
query type so L range in that range

00:30:20,549 --> 00:30:26,789
allow you to retrieve a list of elements

00:30:24,269 --> 00:30:28,499
from a left position the starting

00:30:26,789 --> 00:30:29,999
positioning array so your right

00:30:28,499 --> 00:30:31,649
positioning the end position and the

00:30:29,999 --> 00:30:34,080
array and there's different variants

00:30:31,649 --> 00:30:36,210
there's a sorted version where all the

00:30:34,080 --> 00:30:38,519
values are sorted already for you so you

00:30:36,210 --> 00:30:39,809
dive through it yourself or insert order

00:30:38,519 --> 00:30:43,440
so that's the difference between the L

00:30:39,809 --> 00:30:45,929
and the ztm so you can do optimized

00:30:43,440 --> 00:30:50,279
queries against these very specific data

00:30:45,929 --> 00:30:52,590
types looking at more gonna be among

00:30:50,279 --> 00:30:56,399
going to be has a much richer a data

00:30:52,590 --> 00:30:59,369
query language it is it it it isn't SQL

00:30:56,399 --> 00:31:01,129
but it has nearly or it says function

00:30:59,369 --> 00:31:03,509
like this on par with query

00:31:01,129 --> 00:31:06,650
functionality form what you used to in

00:31:03,509 --> 00:31:08,240
SQL but it looks very different

00:31:06,650 --> 00:31:10,850
but once you look at it it is actually

00:31:08,240 --> 00:31:12,410
that complicated so this example is an

00:31:10,850 --> 00:31:16,430
example from the manga ruby shell so I'm

00:31:12,410 --> 00:31:18,080
not doing this true PHP but if you want

00:31:16,430 --> 00:31:20,360
to transfer this to help PHP does this

00:31:18,080 --> 00:31:22,790
what you change is you are a dollar sign

00:31:20,360 --> 00:31:25,820
in front of DB and you change the dots

00:31:22,790 --> 00:31:28,400
to an error and then of course you don't

00:31:25,820 --> 00:31:30,890
type Jason you use a PHP variable data

00:31:28,400 --> 00:31:32,990
structure it so that it's not I mean the

00:31:30,890 --> 00:31:35,510
API is are exactly the same it's just a

00:31:32,990 --> 00:31:37,760
different language so what we're doing

00:31:35,510 --> 00:31:40,910
here in this query what we're finding is

00:31:37,760 --> 00:31:44,440
refining all the documents where region

00:31:40,910 --> 00:31:48,080
underscore slug equals columns ila and

00:31:44,440 --> 00:31:51,140
the rating is larger than 3 or greater

00:31:48,080 --> 00:31:54,500
than or equal to 3 these operations with

00:31:51,140 --> 00:31:59,900
a dollar sign are query operators these

00:31:54,500 --> 00:32:03,020
are a so because this is done as in

00:31:59,900 --> 00:32:05,630
JavaScript syntax your PHP syntax you

00:32:03,020 --> 00:32:08,540
don't build up a string to do queries

00:32:05,630 --> 00:32:10,190
like in SQL query they're all strings

00:32:08,540 --> 00:32:11,510
right I don't understand there's

00:32:10,190 --> 00:32:13,309
prepared queries where you can replace

00:32:11,510 --> 00:32:17,750
your question marks which values that

00:32:13,309 --> 00:32:18,830
are not being put in as a string before

00:32:17,750 --> 00:32:21,380
it gets sent to the database they're

00:32:18,830 --> 00:32:23,179
different part of the protocol but in

00:32:21,380 --> 00:32:25,280
general you always have to build strings

00:32:23,179 --> 00:32:28,790
to interact with it by writing SQL query

00:32:25,280 --> 00:32:30,380
so it is a slight benefit here is by

00:32:28,790 --> 00:32:33,290
doing it in the declarative way is that

00:32:30,380 --> 00:32:36,110
it tends to be a bit harder to get like

00:32:33,290 --> 00:32:38,150
SQL or noski injections because the

00:32:36,110 --> 00:32:40,670
values are just values in sent of

00:32:38,150 --> 00:32:43,280
strings so you don't have to think about

00:32:40,670 --> 00:32:46,070
escaping yourself and things like that

00:32:43,280 --> 00:32:47,840
having said that you can still get nose

00:32:46,070 --> 00:32:53,450
cone injections by doing queries that

00:32:47,840 --> 00:32:55,910
you know shouldn't do so all the other

00:32:53,450 --> 00:32:58,100
requirements are for for dealing with

00:32:55,910 --> 00:33:00,559
input data correctly still hold true for

00:32:58,100 --> 00:33:03,260
notice called database system all right

00:33:00,559 --> 00:33:05,870
so the query here is refining all the

00:33:03,260 --> 00:33:07,490
documents where region is Scotland ila

00:33:05,870 --> 00:33:09,620
and the rating is larger than 3 or

00:33:07,490 --> 00:33:10,910
larger than greater than 3 and we only

00:33:09,620 --> 00:33:13,700
want two fields back that are called

00:33:10,910 --> 00:33:15,740
whiskey rating and age and pretty makes

00:33:13,700 --> 00:33:19,340
that looks nicely instead of speaking

00:33:15,740 --> 00:33:21,009
irrelevant string so we have this

00:33:19,340 --> 00:33:23,659
equality match

00:33:21,009 --> 00:33:26,089
we have this match with a query operator

00:33:23,659 --> 00:33:28,159
and then we have the projection and a

00:33:26,089 --> 00:33:30,559
projection is you list basically all the

00:33:28,159 --> 00:33:33,009
fields that in SQL you lose select star

00:33:30,559 --> 00:33:45,190
but instead of the star you now have

00:33:33,009 --> 00:33:51,739
sorry can no Biscay rating an age sorry

00:33:45,190 --> 00:33:54,709
okay that's a good question because the

00:33:51,739 --> 00:33:57,469
projection you because it is Java syntax

00:33:54,709 --> 00:33:59,690
you can't just have a single word and

00:33:57,469 --> 00:34:03,139
it's a hash right so you need to have a

00:33:59,690 --> 00:34:05,119
key in a value now the key area is the

00:34:03,139 --> 00:34:07,699
name of the field the value is either 1

00:34:05,119 --> 00:34:09,919
or 0 if it's one that means include it

00:34:07,699 --> 00:34:12,679
if it's zero it means excluded so you

00:34:09,919 --> 00:34:14,779
can you can either include fields that

00:34:12,679 --> 00:34:17,599
you want or you can exclude some fields

00:34:14,779 --> 00:34:21,289
that you don't want that's what about

00:34:17,599 --> 00:34:21,829
different things so if there's some

00:34:21,289 --> 00:34:28,220
water

00:34:21,829 --> 00:34:30,559
that'd be great it's all coming up thank

00:34:28,220 --> 00:34:32,960
you very much all right so if I rewrite

00:34:30,559 --> 00:34:34,309
this query in SQL you get a query like

00:34:32,960 --> 00:34:38,089
this right he gets like whiskey waiting

00:34:34,309 --> 00:34:40,789
age from check-ins where regions like u

00:34:38,089 --> 00:34:45,679
equals : toilet and then rating as large

00:34:40,789 --> 00:34:47,480
or equal to 3 right so an additional way

00:34:45,679 --> 00:34:49,519
of doing queries among rubies with code

00:34:47,480 --> 00:34:52,399
is the aggregation framework and the

00:34:49,519 --> 00:34:54,679
aggregation framework is a set of

00:34:52,399 --> 00:35:00,200
operations that you define that are run

00:34:54,679 --> 00:35:02,990
in order own a collection or a table so

00:35:00,200 --> 00:35:05,720
what aggravates us it we've defined two

00:35:02,990 --> 00:35:13,130
operations here this match and group so

00:35:05,720 --> 00:35:14,869
the matched stage alright in the match

00:35:13,130 --> 00:35:19,279
stage but we're now matching is not a

00:35:14,869 --> 00:35:22,880
specific value but we're using a value

00:35:19,279 --> 00:35:25,910
prefix so it allows you to use regular

00:35:22,880 --> 00:35:29,000
expressions which you anchor a bit a

00:35:25,910 --> 00:35:31,039
carrot to the start of the string you

00:35:29,000 --> 00:35:33,170
need to do that otherwise it doesn't

00:35:31,039 --> 00:35:33,800
make use of an index in a similar way as

00:35:33,170 --> 00:35:37,220
if

00:35:33,800 --> 00:35:41,690
in escrow use find sorry select blahblah

00:35:37,220 --> 00:35:44,300
from table where field like something if

00:35:41,690 --> 00:35:46,130
you don't have if you have the percent

00:35:44,300 --> 00:35:47,960
at the start of that string it can also

00:35:46,130 --> 00:35:50,720
not make use of index because the base

00:35:47,960 --> 00:35:52,670
has strings the index a usually you can

00:35:50,720 --> 00:35:55,700
only do that vendor anchor to the start

00:35:52,670 --> 00:35:57,830
of the string in any case what I'm

00:35:55,700 --> 00:36:00,620
trying to find is all the whiskey's

00:35:57,830 --> 00:36:03,710
where the region is in Scotland's all

00:36:00,620 --> 00:36:05,120
the countries also make whiskey so

00:36:03,710 --> 00:36:08,360
that's what we're doing this match and

00:36:05,120 --> 00:36:10,940
then the second step to group stage

00:36:08,360 --> 00:36:13,820
we then group all that all the things

00:36:10,940 --> 00:36:16,250
that we've found after the first step we

00:36:13,820 --> 00:36:18,140
group them by region and then create a

00:36:16,250 --> 00:36:19,640
list of all the whiskey's that we find

00:36:18,140 --> 00:36:21,200
by this region and put that in the

00:36:19,640 --> 00:36:23,900
whiskey field this looks kind of

00:36:21,200 --> 00:36:25,250
complicated if you want to know more

00:36:23,900 --> 00:36:27,020
about her aggregation framework works

00:36:25,250 --> 00:36:31,220
come talk to me later I'm going to run

00:36:27,020 --> 00:36:34,040
out of time if I go in there too deep so

00:36:31,220 --> 00:36:37,520
for each of the matched documents we

00:36:34,040 --> 00:36:39,800
creating this bucket call in index by

00:36:37,520 --> 00:36:41,570
the region name and then be adding the

00:36:39,800 --> 00:36:44,590
data to so the result of this query

00:36:41,570 --> 00:36:44,590
would be something like this

00:36:44,990 --> 00:36:49,970
I pretty fighters a little bit because

00:36:47,300 --> 00:36:52,460
the ID the region slug has gone but the

00:36:49,970 --> 00:36:54,710
ID failure is now the name of the of the

00:36:52,460 --> 00:36:56,270
region itself but you can see that the

00:36:54,710 --> 00:36:58,370
result of this is an array of all the

00:36:56,270 --> 00:37:00,740
different whiskeys so you can do quite a

00:36:58,370 --> 00:37:02,750
bit which it queries with is that you

00:37:00,740 --> 00:37:04,370
will you come to an s-curve right you

00:37:02,750 --> 00:37:06,980
can ask well you usually traditionally

00:37:04,370 --> 00:37:11,060
you can't return a value that is an

00:37:06,980 --> 00:37:12,860
array of values of course unless you use

00:37:11,060 --> 00:37:19,340
the jason be datatype from post Cosco

00:37:12,860 --> 00:37:21,470
alright so queries with the jason be

00:37:19,340 --> 00:37:27,110
datatype in post glasgow or h store in

00:37:21,470 --> 00:37:29,780
this case are by using specific extra

00:37:27,110 --> 00:37:31,580
SQL operators I don't necessarily

00:37:29,780 --> 00:37:34,580
remember the names of these operate

00:37:31,580 --> 00:37:37,190
reticles have funny names and you know

00:37:34,580 --> 00:37:38,840
just don't remember the nice one so in

00:37:37,190 --> 00:37:41,390
this example we have a document that

00:37:38,840 --> 00:37:43,790
four fields we have ID location count

00:37:41,390 --> 00:37:47,020
unique in his admin to get a value for a

00:37:43,790 --> 00:37:48,880
king you see that we use this

00:37:47,020 --> 00:37:50,590
our operator and the arrow operator

00:37:48,880 --> 00:37:53,950
basically says give me the field is

00:37:50,590 --> 00:37:55,660
admin for the field H stock a joke was

00:37:53,950 --> 00:37:59,080
the name that from the previous examples

00:37:55,660 --> 00:38:04,030
so that will basically give me for every

00:37:59,080 --> 00:38:05,500
document in users the is admin flag and

00:38:04,030 --> 00:38:09,790
the only thing is output it's pretty

00:38:05,500 --> 00:38:11,260
useless but this isn't a sample here so

00:38:09,790 --> 00:38:13,330
what you can also do is you can use

00:38:11,260 --> 00:38:15,430
normal escrow operators on those filters

00:38:13,330 --> 00:38:18,550
also in the second example here is that

00:38:15,430 --> 00:38:22,150
we're going to show all the underscore

00:38:18,550 --> 00:38:25,420
ID values for all the users where the

00:38:22,150 --> 00:38:27,820
field counts unique is larger than ten

00:38:25,420 --> 00:38:29,680
it's basically brother says users that

00:38:27,820 --> 00:38:32,320
have logged in more than ten times and

00:38:29,680 --> 00:38:34,270
then for those we want the owner Square

00:38:32,320 --> 00:38:38,770
D values which is the unique identifier

00:38:34,270 --> 00:38:41,590
for a user now because of course upfront

00:38:38,770 --> 00:38:43,960
you never know which fields and values

00:38:41,590 --> 00:38:46,720
you have it is also possible to find out

00:38:43,960 --> 00:38:49,330
whether those fields actually exist in

00:38:46,720 --> 00:38:51,070
the data so in this case the third

00:38:49,330 --> 00:38:55,570
example you are able to select H doc

00:38:51,070 --> 00:38:59,320
question mark H basically says if this

00:38:55,570 --> 00:39:01,270
field exists return return boolean

00:38:59,320 --> 00:39:04,810
through I think it actually does so you

00:39:01,270 --> 00:39:07,300
can text so you can test for keys

00:39:04,810 --> 00:39:10,450
existing which is well you sometimes

00:39:07,300 --> 00:39:13,090
need to know that right and then in the

00:39:10,450 --> 00:39:15,160
last example which is probably the most

00:39:13,090 --> 00:39:16,380
uncertain that SQL that I've seen in a

00:39:15,160 --> 00:39:19,120
bomb

00:39:16,380 --> 00:39:22,390
you can use H drop the name of the field

00:39:19,120 --> 00:39:25,780
and then we can check by this em

00:39:22,390 --> 00:39:28,980
presents created and sign where the key

00:39:25,780 --> 00:39:32,560
value pair location london-uk

00:39:28,980 --> 00:39:34,270
notice the double quotes around the key

00:39:32,560 --> 00:39:36,700
and a value and a single quotes around

00:39:34,270 --> 00:39:38,920
the whole thing which we need to cost us

00:39:36,700 --> 00:39:41,770
an H store which is the colon colon H

00:39:38,920 --> 00:39:43,660
journey ends basically what this does is

00:39:41,770 --> 00:39:48,840
it selects all the documents and users

00:39:43,660 --> 00:39:51,240
where there's a safe field in the H doc

00:39:48,840 --> 00:39:53,890
sorry where there is a key value

00:39:51,240 --> 00:39:56,620
combination in the H doc field that

00:39:53,890 --> 00:39:59,140
matches location long in the UK that is

00:39:56,620 --> 00:40:01,000
what it says this gets more complicated

00:39:59,140 --> 00:40:05,170
I think it doesn't look as

00:40:01,000 --> 00:40:07,660
in my opinion as how no school databases

00:40:05,170 --> 00:40:09,370
do this because their query language is

00:40:07,660 --> 00:40:11,860
made to do this kind of thing whereas

00:40:09,370 --> 00:40:15,630
SQL sort of has this bolted on and I'm

00:40:11,860 --> 00:40:18,400
also not entirely sure of the

00:40:15,630 --> 00:40:21,160
standardization process of these

00:40:18,400 --> 00:40:22,750
additional operators I know people are

00:40:21,160 --> 00:40:25,360
trying to standardize what all these

00:40:22,750 --> 00:40:27,400
things mean but if it's new technology

00:40:25,360 --> 00:40:30,210
and databases implement them in a

00:40:27,400 --> 00:40:32,560
slightly different way is kind of hairy

00:40:30,210 --> 00:40:34,180
from what I know both my school and

00:40:32,560 --> 00:40:37,180
Postgres will do implement those same

00:40:34,180 --> 00:40:41,260
data types so that's for each store if

00:40:37,180 --> 00:40:43,990
you look at Jason B it is similar you

00:40:41,260 --> 00:40:47,590
can both the arrow as well as the double

00:40:43,990 --> 00:40:50,950
arrow and a double arrow is a little bit

00:40:47,590 --> 00:40:52,930
better because instead of returning a

00:40:50,950 --> 00:40:55,480
string with the value 'not it will

00:40:52,930 --> 00:40:57,600
actually pull the data out of the string

00:40:55,480 --> 00:41:02,200
and return it as a normal data type so

00:40:57,600 --> 00:41:07,390
most often people use the - arrow arrow

00:41:02,200 --> 00:41:09,130
instead of the - arrow operator and by

00:41:07,390 --> 00:41:10,930
doing this kind of queries it becomes

00:41:09,130 --> 00:41:14,500
important what kind of indexes you use

00:41:10,930 --> 00:41:18,430
now normally what you have on a index

00:41:14,500 --> 00:41:20,650
fields if you do normal create index you

00:41:18,430 --> 00:41:24,820
create a b-tree index you get a b3 index

00:41:20,650 --> 00:41:26,440
on fuel and values in order to discard

00:41:24,820 --> 00:41:30,220
of queries to make it go fast without

00:41:26,440 --> 00:41:33,310
having to scan the whole table you have

00:41:30,220 --> 00:41:36,490
to create an index on h-dog email so

00:41:33,310 --> 00:41:38,230
post fiscal knows if there's an adjacent

00:41:36,490 --> 00:41:40,360
B data type you can actually set an

00:41:38,230 --> 00:41:41,610
index on sub fields in there without you

00:41:40,360 --> 00:41:44,500
having to do anything about that

00:41:41,610 --> 00:41:45,880
so in this case you just like you

00:41:44,500 --> 00:41:48,460
normally would have an index on email

00:41:45,880 --> 00:41:53,830
you're not having an index on the email

00:41:48,460 --> 00:41:56,560
field inside this Jason B data type all

00:41:53,830 --> 00:41:59,820
right so we again find the ID for the

00:41:56,560 --> 00:42:04,840
email address which is my email address

00:41:59,820 --> 00:42:08,410
second example we finding we now using

00:42:04,840 --> 00:42:10,330
the is not know s call operator

00:42:08,410 --> 00:42:13,000
operators and how he covers let's call

00:42:10,330 --> 00:42:14,800
an operator which is the same thing as

00:42:13,000 --> 00:42:16,780
you how you otherwise would do it if

00:42:14,800 --> 00:42:19,510
to check whether this value is know or

00:42:16,780 --> 00:42:21,190
not which you can also use to see better

00:42:19,510 --> 00:42:23,440
the field actually exists because

00:42:21,190 --> 00:42:26,590
unknown existing field has a value of no

00:42:23,440 --> 00:42:28,360
in this case now then in the third

00:42:26,590 --> 00:42:30,640
example we're going to be more

00:42:28,360 --> 00:42:33,700
complicated and we're using this at

00:42:30,640 --> 00:42:39,460
greater than operator to find out

00:42:33,700 --> 00:42:42,300
whether there's a word the word London

00:42:39,460 --> 00:42:44,650
whether that is part of the array

00:42:42,300 --> 00:42:46,600
associated with the word field okay this

00:42:44,650 --> 00:42:51,190
could be complicated so as you see the

00:42:46,600 --> 00:42:53,680
words field here has four values the

00:42:51,190 --> 00:42:55,720
query that we do here is a subset of

00:42:53,680 --> 00:42:58,570
this because it only matches words

00:42:55,720 --> 00:43:00,520
London which is a subset of the document

00:42:58,570 --> 00:43:02,860
and hence will then return it as a

00:43:00,520 --> 00:43:05,110
result if I would have used words Paris

00:43:02,860 --> 00:43:06,510
for example because it doesn't match it

00:43:05,110 --> 00:43:08,530
wouldn't return it

00:43:06,510 --> 00:43:12,400
additionally if I would have drawn words

00:43:08,530 --> 00:43:14,110
London comma UK it would also find it

00:43:12,400 --> 00:43:17,020
because it's still subsets of this

00:43:14,110 --> 00:43:20,290
document in order to do this kind of

00:43:17,020 --> 00:43:24,660
queries those girls call recommends that

00:43:20,290 --> 00:43:31,060
you use H in index and a gin stands for

00:43:24,660 --> 00:43:33,250
the G sorry because my generative index

00:43:31,060 --> 00:43:35,140
something like that generators inverted

00:43:33,250 --> 00:43:37,360
index basically is at the index type

00:43:35,140 --> 00:43:40,510
that allows you to make multiple values

00:43:37,360 --> 00:43:45,520
to a single single document sorry single

00:43:40,510 --> 00:43:49,590
records which is a way of basically

00:43:45,520 --> 00:43:52,480
indexing all the key and values in this

00:43:49,590 --> 00:43:54,640
Jason B data type in one bucket so you

00:43:52,480 --> 00:43:58,180
can do queries against that in one go

00:43:54,640 --> 00:43:59,740
without having to do it on specific

00:43:58,180 --> 00:44:01,930
fields like we do for in the first

00:43:59,740 --> 00:44:04,420
example here where we look specifically

00:44:01,930 --> 00:44:08,620
up data against the email field in the H

00:44:04,420 --> 00:44:10,600
doc field I know I'm using the same word

00:44:08,620 --> 00:44:14,470
a lot over and over again it gets

00:44:10,600 --> 00:44:15,940
confusing officer Wang suggests in the

00:44:14,470 --> 00:44:17,470
last example what I want to show that

00:44:15,940 --> 00:44:18,940
how we should update or add the fields I

00:44:17,470 --> 00:44:20,770
already mentioned when we looked at

00:44:18,940 --> 00:44:22,630
Vettes before that it is important to

00:44:20,770 --> 00:44:24,340
use atomic operators to do operations on

00:44:22,630 --> 00:44:28,300
the data what you don't want to do is

00:44:24,340 --> 00:44:31,570
retrieve the records in your application

00:44:28,300 --> 00:44:34,210
an extra field to the H doc type which

00:44:31,570 --> 00:44:37,300
in order to that you basically have to

00:44:34,210 --> 00:44:37,630
rewrite a string not ideal way of doing

00:44:37,300 --> 00:44:39,820
that

00:44:37,630 --> 00:44:41,770
so what post-classical allows you to do

00:44:39,820 --> 00:44:43,990
is actually update or add fields by

00:44:41,770 --> 00:44:46,750
using the colon not the pipe pipe

00:44:43,990 --> 00:44:48,730
operator which basically are the fields

00:44:46,750 --> 00:44:54,220
value combination country Europe that's

00:44:48,730 --> 00:44:56,170
not a country sorry or if you want to

00:44:54,220 --> 00:44:59,680
remove the fields you can use - instead

00:44:56,170 --> 00:45:01,660
of pipe pipe okay I'm going to change

00:44:59,680 --> 00:45:02,500
that the country to eat a continent or

00:45:01,660 --> 00:45:04,480
her to change the name of the country

00:45:02,500 --> 00:45:07,600
for something else all right

00:45:04,480 --> 00:45:09,760
um alright so that's the interaction

00:45:07,600 --> 00:45:12,640
with a bit of different data type so a

00:45:09,760 --> 00:45:14,350
bit a bit more about indexes the indexes

00:45:12,640 --> 00:45:18,310
and Vettes they're only going to be on

00:45:14,350 --> 00:45:20,260
your primary key and if you want to do

00:45:18,310 --> 00:45:23,650
more if you must have a compound index

00:45:20,260 --> 00:45:27,490
as I've shown you before you use it it

00:45:23,650 --> 00:45:30,580
is a a preference to use the colon

00:45:27,490 --> 00:45:31,780
there's no there's no heart requirement

00:45:30,580 --> 00:45:34,570
for using a column but it is what people

00:45:31,780 --> 00:45:36,430
tend to do but some of the data

00:45:34,570 --> 00:45:39,550
structures provide additional indexes

00:45:36,430 --> 00:45:41,260
right if you have a set for example even

00:45:39,550 --> 00:45:42,850
though your primary key is still the

00:45:41,260 --> 00:45:45,070
first one there's still sort of index on

00:45:42,850 --> 00:45:47,830
the value because it knows not to add

00:45:45,070 --> 00:45:49,900
multiple multiple the same values to the

00:45:47,830 --> 00:45:51,310
set so there's some indexing going in

00:45:49,900 --> 00:45:54,100
there so and similarly if you have like

00:45:51,310 --> 00:45:56,500
a sorted list or something it also just

00:45:54,100 --> 00:45:59,610
that kind of additional indexing to make

00:45:56,500 --> 00:46:01,900
the queries be faster without you having

00:45:59,610 --> 00:46:04,480
specifically having to create an index

00:46:01,900 --> 00:46:06,340
it is part of the data type that you are

00:46:04,480 --> 00:46:07,590
using for storing the data which is kind

00:46:06,340 --> 00:46:11,110
of handy

00:46:07,590 --> 00:46:13,890
so among the B indexes they are on

00:46:11,110 --> 00:46:16,810
normal fields as you'd expect

00:46:13,890 --> 00:46:19,930
you can set unique keys you can set

00:46:16,810 --> 00:46:22,810
indexes so you have the song you can set

00:46:19,930 --> 00:46:24,940
indexes on a nested fields like if you

00:46:22,810 --> 00:46:28,360
remember from a protocol exam where we

00:46:24,940 --> 00:46:30,760
at h doc arrow email you set an index on

00:46:28,360 --> 00:46:32,440
the email field with inside h doc which

00:46:30,760 --> 00:46:36,010
is what manga ruby uses with the dot

00:46:32,440 --> 00:46:39,310
instead of the arrow and you can set an

00:46:36,010 --> 00:46:42,250
index on words on the field words the

00:46:39,310 --> 00:46:47,460
field words will now have multiple value

00:46:42,250 --> 00:46:49,480
associated with that field unlike

00:46:47,460 --> 00:46:51,810
post-classical which allows you to do

00:46:49,480 --> 00:46:54,040
this on the whole data type only in

00:46:51,810 --> 00:46:56,560
mongrel you can do this on specific

00:46:54,040 --> 00:47:00,310
fields inside the document status story

00:46:56,560 --> 00:47:02,320
so it's a little bit more precise on

00:47:00,310 --> 00:47:04,690
what you store your indexes on making it

00:47:02,320 --> 00:47:05,790
of course if you'd be more precise with

00:47:04,690 --> 00:47:08,110
you in the actually end up storing

00:47:05,790 --> 00:47:09,640
indexes of a smaller size because you

00:47:08,110 --> 00:47:12,730
have to store your information or or

00:47:09,640 --> 00:47:15,130
less information in there so poster also

00:47:12,730 --> 00:47:19,510
has this gene index the conference

00:47:15,130 --> 00:47:22,920
really doesn't work here apologies then

00:47:19,510 --> 00:47:24,810
again picking red and blue and purple

00:47:22,920 --> 00:47:28,990
should have seen that coming

00:47:24,810 --> 00:47:31,000
but this gin index is a really quick way

00:47:28,990 --> 00:47:34,150
of creating this index on all the data

00:47:31,000 --> 00:47:36,640
inside an H store and it is you're going

00:47:34,150 --> 00:47:41,740
to have to do something in order to not

00:47:36,640 --> 00:47:43,630
have it table scam and so yeah so there

00:47:41,740 --> 00:47:46,480
are two types for Jason B fields there

00:47:43,630 --> 00:47:51,090
is a kV or just a V key value or just a

00:47:46,480 --> 00:47:54,310
value I think in general people will use

00:47:51,090 --> 00:47:55,780
the standard or just key value and it

00:47:54,310 --> 00:47:57,700
allows you to map multiple values

00:47:55,780 --> 00:48:00,070
through single documents so in this case

00:47:57,700 --> 00:48:02,950
all the the combination like named lam

00:48:00,070 --> 00:48:06,790
25 for Glen Alban or worth glam

00:48:02,950 --> 00:48:09,490
words Alban Albert's 25 they all show up

00:48:06,790 --> 00:48:11,980
in this index so that you can quickly

00:48:09,490 --> 00:48:13,360
relate to a single record that come

00:48:11,980 --> 00:48:16,090
towards that information in this data

00:48:13,360 --> 00:48:19,000
type so with this I just showed you

00:48:16,090 --> 00:48:21,280
before you can do these key value

00:48:19,000 --> 00:48:26,590
matches so we creating the index here

00:48:21,280 --> 00:48:28,600
with us using gin on properties so you

00:48:26,590 --> 00:48:30,310
have to specify which type of index you

00:48:28,600 --> 00:48:31,990
use for it if you want to create a

00:48:30,310 --> 00:48:36,550
b-tree index you don't have to specify

00:48:31,990 --> 00:48:43,540
the gin thing so it will then index this

00:48:36,550 --> 00:48:45,340
whole whole property's fills and similar

00:48:43,540 --> 00:48:48,540
if this index is also used when you do

00:48:45,340 --> 00:48:51,820
this array containing and match right so

00:48:48,540 --> 00:48:54,490
to query index so we create the index

00:48:51,820 --> 00:48:55,380
own properties word so that is a more

00:48:54,490 --> 00:48:58,170
specific

00:48:55,380 --> 00:49:00,810
type of index to then be able to match

00:48:58,170 --> 00:49:02,250
the properties to see whether in this

00:49:00,810 --> 00:49:04,680
case with the question mark we trying to

00:49:02,250 --> 00:49:09,330
find whether the value album actually

00:49:04,680 --> 00:49:11,640
matches inside the words fields I've

00:49:09,330 --> 00:49:13,620
shown you only very simple operations

00:49:11,640 --> 00:49:15,540
you can do this data I mean I can

00:49:13,620 --> 00:49:17,610
probably give it told that last several

00:49:15,540 --> 00:49:19,290
hours on all the different operation

00:49:17,610 --> 00:49:24,420
that you can do with this data again not

00:49:19,290 --> 00:49:26,130
having the time for that so we'll get it

00:49:24,420 --> 00:49:28,920
going here a few more words about

00:49:26,130 --> 00:49:30,330
manipulating data so I've already

00:49:28,920 --> 00:49:32,760
mentioned is a few times obey how you

00:49:30,330 --> 00:49:34,830
interact with data you may need to make

00:49:32,760 --> 00:49:38,010
sure that you do this in an atomic way

00:49:34,830 --> 00:49:40,020
you can use it with transactions or you

00:49:38,010 --> 00:49:42,330
can make use of all the operations that

00:49:40,020 --> 00:49:44,160
work on all the specific data type but

00:49:42,330 --> 00:49:49,320
is always going to be a preferred way of

00:49:44,160 --> 00:49:51,450
doing it so that's the atomicity so you

00:49:49,320 --> 00:49:53,790
shouldn't do retrieve manipulate and

00:49:51,450 --> 00:49:55,320
store this is true for any database

00:49:53,790 --> 00:49:57,180
interaction you ever have with any

00:49:55,320 --> 00:50:02,880
database you can think of so this should

00:49:57,180 --> 00:50:05,220
not be anything new so venice has a bit

00:50:02,880 --> 00:50:08,100
of extra operations here that allows you

00:50:05,220 --> 00:50:11,060
to work on things that you've already

00:50:08,100 --> 00:50:13,620
stored so remember that we have the

00:50:11,060 --> 00:50:16,220
invaders we have the properties and in

00:50:13,620 --> 00:50:19,560
this case the property for H is 19

00:50:16,220 --> 00:50:21,210
returned as a string but you can do Inc

00:50:19,560 --> 00:50:23,340
or H increment

00:50:21,210 --> 00:50:29,430
they get difficult to pronounce those

00:50:23,340 --> 00:50:30,600
operations H in B I don't know they need

00:50:29,430 --> 00:50:32,610
to come over something slightly better

00:50:30,600 --> 00:50:34,470
than I think but what that does allow

00:50:32,610 --> 00:50:35,820
you to is take the fields and then use a

00:50:34,470 --> 00:50:37,980
value that you're going to add to the

00:50:35,820 --> 00:50:38,400
fields so even though it is stored as a

00:50:37,980 --> 00:50:40,620
string

00:50:38,400 --> 00:50:41,930
you can still do numerical operations to

00:50:40,620 --> 00:50:44,220
strings that look like numbers and

00:50:41,930 --> 00:50:46,850
because there's an atomic operation it's

00:50:44,220 --> 00:50:49,830
also really fast that happens in place

00:50:46,850 --> 00:50:52,110
and it's basically a free thing to do

00:50:49,830 --> 00:50:55,980
well nothing is ever free but it's just

00:50:52,110 --> 00:50:58,710
a really fast operation and this is used

00:50:55,980 --> 00:51:01,140
in many applications where you keep

00:50:58,710 --> 00:51:04,860
counters like visitor counters or or

00:51:01,140 --> 00:51:06,360
anything like that or if anybody still

00:51:04,860 --> 00:51:08,160
uses Foursquare like how many people

00:51:06,360 --> 00:51:10,339
have checked into specific vania right

00:51:08,160 --> 00:51:12,779
all the kind of things

00:51:10,339 --> 00:51:15,539
Redis is a really good database for

00:51:12,779 --> 00:51:17,309
doing this for also if you lose the data

00:51:15,539 --> 00:51:18,719
it's kind of annoying but you cannot

00:51:17,309 --> 00:51:21,410
should always be able to build it back

00:51:18,719 --> 00:51:25,319
from data you've already stored on disk

00:51:21,410 --> 00:51:27,209
and then there's all the things like the

00:51:25,319 --> 00:51:29,459
automic operational sets how they spoke

00:51:27,209 --> 00:51:34,049
about this SS and the elements to set or

00:51:29,459 --> 00:51:35,910
RS ram from remove and Amazon and then

00:51:34,049 --> 00:51:37,589
there's transactions as you zone so am

00:51:35,910 --> 00:51:40,829
I'm going to be a similar thing never do

00:51:37,589 --> 00:51:42,150
this never do a query update you value

00:51:40,829 --> 00:51:45,229
and I'm stored again you get race

00:51:42,150 --> 00:51:47,549
conditions among abhi has operations

00:51:45,229 --> 00:51:49,019
starting with a dollar sign which if

00:51:47,549 --> 00:51:50,130
you're using PHP is kind of annoying

00:51:49,019 --> 00:51:51,869
because you really need to make sure

00:51:50,130 --> 00:51:53,209
you're not using double quote you need

00:51:51,869 --> 00:51:56,999
to use single quotes for everything

00:51:53,209 --> 00:51:58,799
otherwise you got weird results and in

00:51:56,999 --> 00:52:01,349
this case what this query says in the

00:51:58,799 --> 00:52:06,209
first example it says increment the

00:52:01,349 --> 00:52:08,369
subfield 2017 0 to 0-2 in a field steps

00:52:06,209 --> 00:52:12,630
underscore mate and increase it by seven

00:52:08,369 --> 00:52:15,180
thousand 124 as a automic operation is

00:52:12,630 --> 00:52:15,949
kind of handy it also has operations for

00:52:15,180 --> 00:52:18,420
sets

00:52:15,949 --> 00:52:22,469
although mongrel B doesn't have a set

00:52:18,420 --> 00:52:24,829
datatype per se there are operations in

00:52:22,469 --> 00:52:28,140
the query language that allow you to

00:52:24,829 --> 00:52:30,029
deal with specific erase s they were

00:52:28,140 --> 00:52:33,599
sets by using these operators so adds

00:52:30,029 --> 00:52:35,369
two sets basically says add the word

00:52:33,599 --> 00:52:37,170
open three map to tags

00:52:35,369 --> 00:52:40,079
unless it's already there and then just

00:52:37,170 --> 00:52:42,660
ignore the operation similarly can you

00:52:40,079 --> 00:52:44,640
do things like push to push things to

00:52:42,660 --> 00:52:45,839
the end of an array and you remember

00:52:44,640 --> 00:52:48,329
that in Postgres so you could do that

00:52:45,839 --> 00:52:51,479
with a pipe pipe operate try to add an

00:52:48,329 --> 00:52:54,180
extra field to it similarly among gonna

00:52:51,479 --> 00:52:56,069
be allows you to say push tanks so what

00:52:54,180 --> 00:53:00,690
we're doing here is that we're adding to

00:52:56,069 --> 00:53:03,420
the tax property the values mon gonna be

00:53:00,690 --> 00:53:06,569
an ex debug and then after we've known

00:53:03,420 --> 00:53:09,239
that we only take the last two elements

00:53:06,569 --> 00:53:10,680
and everything else that we discard okay

00:53:09,239 --> 00:53:12,839
in this example that is kind of silly

00:53:10,680 --> 00:53:15,809
because we've just added two elements

00:53:12,839 --> 00:53:17,279
and then we only keep the last elements

00:53:15,809 --> 00:53:19,589
that we have but what you can use this

00:53:17,279 --> 00:53:22,469
for is that you are the comments to a

00:53:19,589 --> 00:53:22,980
blog post and then by using slice -10

00:53:22,469 --> 00:53:24,750
you

00:53:22,980 --> 00:53:26,580
make sure that you only store the last

00:53:24,750 --> 00:53:28,140
ten comments with a specific blog post

00:53:26,580 --> 00:53:30,630
and this is all one single operation

00:53:28,140 --> 00:53:32,640
without you from application having to

00:53:30,630 --> 00:53:36,690
create transactions and this kind of

00:53:32,640 --> 00:53:38,940
things so as I said all those knows call

00:53:36,690 --> 00:53:41,280
database as well as opposed to adjacent

00:53:38,940 --> 00:53:44,760
be datatype have these operation that

00:53:41,280 --> 00:53:47,850
you really want to use okay schema

00:53:44,760 --> 00:53:50,130
validation in a relational database

00:53:47,850 --> 00:53:51,750
well the schema validation because you

00:53:50,130 --> 00:53:54,690
have to create a schema upfront right

00:53:51,750 --> 00:53:57,210
but but all those extra modern datatypes

00:53:54,690 --> 00:53:58,800
now you don't describe this kheema of

00:53:57,210 --> 00:54:01,950
these of the data that you store in

00:53:58,800 --> 00:54:03,690
there up front in relation in the

00:54:01,950 --> 00:54:06,690
relational database with these data type

00:54:03,690 --> 00:54:08,820
you generally cannot enforce this schema

00:54:06,690 --> 00:54:11,700
on the data that you store in there

00:54:08,820 --> 00:54:15,000
it's retranslated treated as a bucket of

00:54:11,700 --> 00:54:18,600
data but of course the things that you

00:54:15,000 --> 00:54:21,030
want to enforce the structure of you

00:54:18,600 --> 00:54:23,369
gonna store in this Jason B data type

00:54:21,030 --> 00:54:27,330
anyway you sort us as normal fields in

00:54:23,369 --> 00:54:29,910
your in your records with knows call a

00:54:27,330 --> 00:54:30,869
databases it isn't generally possible to

00:54:29,910 --> 00:54:32,930
enforce a schema

00:54:30,869 --> 00:54:35,850
although the databases have been adding

00:54:32,930 --> 00:54:37,980
functionality to this I can't remember

00:54:35,850 --> 00:54:40,080
but a cow should be is anything for it

00:54:37,980 --> 00:54:43,080
but MongoDB allows you for example to

00:54:40,080 --> 00:54:45,390
set up a validator and a validator is

00:54:43,080 --> 00:54:48,470
basically a way of running a query

00:54:45,390 --> 00:54:51,000
against a document has been updated or

00:54:48,470 --> 00:54:53,550
inserted to see whether it match a

00:54:51,000 --> 00:54:56,910
specific query the validator and if it

00:54:53,550 --> 00:55:00,030
matches if it if the document would be

00:54:56,910 --> 00:55:02,910
found by running this query it it's

00:55:00,030 --> 00:55:06,300
considered being validated so this is a

00:55:02,910 --> 00:55:08,010
way of enforcing a schema why not have

00:55:06,300 --> 00:55:09,390
by still not having to create a schema

00:55:08,010 --> 00:55:11,490
upfront for example so that this

00:55:09,390 --> 00:55:12,720
possible thing to do I think the latest

00:55:11,490 --> 00:55:15,750
version of Moe going to be actually

00:55:12,720 --> 00:55:18,359
extend this language to JSON schema so

00:55:15,750 --> 00:55:20,760
if you use that it is a lot richer than

00:55:18,359 --> 00:55:23,910
what moment we originally had before

00:55:20,760 --> 00:55:27,359
JSON schema existed for example alright

00:55:23,910 --> 00:55:29,160
so conclusions the way how you store

00:55:27,359 --> 00:55:33,630
non-scalar date and different databases

00:55:29,160 --> 00:55:35,609
this varies wildly it's important to

00:55:33,630 --> 00:55:36,650
pick the right to for the job right I

00:55:35,609 --> 00:55:39,950
would

00:55:36,650 --> 00:55:42,490
but usually recommend people use Redis

00:55:39,950 --> 00:55:44,900
for this very quick in memory operations

00:55:42,490 --> 00:55:46,280
because it's really good at that but

00:55:44,900 --> 00:55:50,350
Redis isn't particularly very good at

00:55:46,280 --> 00:55:52,880
scaling it's beyond a single machine a

00:55:50,350 --> 00:55:54,710
relational database such as post goes

00:55:52,880 --> 00:55:56,510
through to Jason B data type or my skull

00:55:54,710 --> 00:55:59,240
but it's Jason type which is also

00:55:56,510 --> 00:56:01,160
getting better and better over time if

00:55:59,240 --> 00:56:02,870
you're already having an application

00:56:01,160 --> 00:56:04,760
using a relational database and you need

00:56:02,870 --> 00:56:07,910
to store some extra unstructured data

00:56:04,760 --> 00:56:09,680
that doesn't happen very often then use

00:56:07,910 --> 00:56:11,840
a relational database and use the Jason

00:56:09,680 --> 00:56:13,880
B or Jason types as additional to store

00:56:11,840 --> 00:56:16,730
additional information if your

00:56:13,880 --> 00:56:19,250
application is already either highly

00:56:16,730 --> 00:56:21,320
unstructured with some data it's just

00:56:19,250 --> 00:56:23,210
like that using a knows called database

00:56:21,320 --> 00:56:25,850
like couch TV or elastic search or

00:56:23,210 --> 00:56:27,020
MongoDB is the right tool for the job

00:56:25,850 --> 00:56:29,210
there right because it's already

00:56:27,020 --> 00:56:31,730
architect and search way in addition

00:56:29,210 --> 00:56:34,100
most knows well solutions are also built

00:56:31,730 --> 00:56:36,410
to be run on a distributed platform say

00:56:34,100 --> 00:56:38,660
if you need to have easier failover

00:56:36,410 --> 00:56:40,760
capabilities or distributed writes and

00:56:38,660 --> 00:56:45,080
recent things like that relational

00:56:40,760 --> 00:56:46,670
databases tend to be less good for that

00:56:45,080 --> 00:56:48,740
because they have not been architected

00:56:46,670 --> 00:56:51,230
for that right there are thirty forty

00:56:48,740 --> 00:56:52,490
years old where the way how you scale

00:56:51,230 --> 00:56:57,260
your database which you get a bigger

00:56:52,490 --> 00:56:58,910
machine most of the time and then there

00:56:57,260 --> 00:57:00,830
are some data types that work better

00:56:58,910 --> 00:57:03,770
with some database like having the sets

00:57:00,830 --> 00:57:06,890
it's probably Redis would be a much more

00:57:03,770 --> 00:57:08,840
natural fit for that then you do that in

00:57:06,890 --> 00:57:11,810
a relational database or even in a

00:57:08,840 --> 00:57:12,830
document database so those are the

00:57:11,810 --> 00:57:16,130
different things that you need to look

00:57:12,830 --> 00:57:18,800
at many different possibilities there as

00:57:16,130 --> 00:57:23,890
I said be capitalist 57 different types

00:57:18,800 --> 00:57:28,610
of knows call databases or is it more

00:57:23,890 --> 00:57:30,890
exotic features than dollars so yeah if

00:57:28,610 --> 00:57:32,180
you have things that you don't think

00:57:30,890 --> 00:57:34,910
that fits with the things I've just

00:57:32,180 --> 00:57:36,260
spoken about today have a look at what

00:57:34,910 --> 00:57:38,900
else is outer and there's a lot of

00:57:36,260 --> 00:57:43,720
different things out there having said

00:57:38,900 --> 00:57:43,720
that are any queries we have two minutes

00:57:44,230 --> 00:57:51,749
that's one right up front him

00:57:47,130 --> 00:57:55,920
use the mic please would you recommend

00:57:51,749 --> 00:57:58,109
any of these for storing events if

00:57:55,920 --> 00:58:01,549
you're using libraries such as Broadway

00:57:58,109 --> 00:58:07,349
for or Rock going to the complexity of a

00:58:01,549 --> 00:58:10,229
dedicated event store so when you say

00:58:07,349 --> 00:58:13,079
events so you don't mean time series

00:58:10,229 --> 00:58:14,190
data right is it just offense but

00:58:13,079 --> 00:58:15,869
everything that happens through your

00:58:14,190 --> 00:58:19,229
application and you want to throw in a

00:58:15,869 --> 00:58:21,329
big log basically see that right yes

00:58:19,229 --> 00:58:24,019
something like event-driven architecture

00:58:21,329 --> 00:58:28,099
where you write your domain events I

00:58:24,019 --> 00:58:30,869
don't think it particularly matters much

00:58:28,099 --> 00:58:32,400
but what you need to do I don't think

00:58:30,869 --> 00:58:34,910
I'd use Redis for it because Redis is

00:58:32,400 --> 00:58:38,059
not good as a system of Records

00:58:34,910 --> 00:58:40,859
neither's elasticsearch in this case

00:58:38,059 --> 00:58:42,449
both relational database as well as say

00:58:40,859 --> 00:58:44,369
couch to be among going to be as no

00:58:42,449 --> 00:58:46,109
school data so would be perfect fit for

00:58:44,369 --> 00:58:48,989
that right I mean at that point you just

00:58:46,109 --> 00:58:50,519
need to start figuring out I need to you

00:58:48,989 --> 00:58:54,079
need to run some benchmarks for this the

00:58:50,519 --> 00:58:57,359
fastest data store for you or similarly

00:58:54,079 --> 00:58:59,190
good point about thinking about which

00:58:57,359 --> 00:59:02,099
one to use which one I'm most familiar

00:58:59,190 --> 00:59:03,930
with or do I really fancy playing with

00:59:02,099 --> 00:59:05,609
something else and figuring out how that

00:59:03,930 --> 00:59:08,339
works for me right so these are the

00:59:05,609 --> 00:59:10,349
concerns there but because an intense

00:59:08,339 --> 00:59:13,619
store itself they don't really have

00:59:10,349 --> 00:59:16,219
unstructured data very much it doesn't

00:59:13,619 --> 00:59:18,349
particularly matter in my opinion

00:59:16,219 --> 00:59:27,089
anything else

00:59:18,349 --> 00:59:28,829
no questions oh right him we had a

00:59:27,089 --> 00:59:30,839
technical problem which we are trying to

00:59:28,829 --> 00:59:33,029
solve using no sequel but I wanted to

00:59:30,839 --> 00:59:35,309
know for example the way no sequel works

00:59:33,029 --> 00:59:36,539
is there's no definite schema so one day

00:59:35,309 --> 00:59:38,190
some object might differ from other

00:59:36,539 --> 00:59:40,049
changes normally for example one did not

00:59:38,190 --> 00:59:41,880
judge my half-filled Conn name the other

00:59:40,049 --> 00:59:44,519
one might not hmm so if there is

00:59:41,880 --> 00:59:46,559
possible to have an index on this key

00:59:44,519 --> 00:59:48,239
called name and then tell the no sequel

00:59:46,559 --> 00:59:50,819
database that if you find this key

00:59:48,239 --> 00:59:53,190
called name index it and then I want to

00:59:50,819 --> 00:59:55,559
pull out everything which has that name

00:59:53,190 --> 01:00:00,390
and then if it doesn't have it ignore it

00:59:55,559 --> 01:00:00,930
yes so how should we handle that in a

01:00:00,390 --> 01:00:03,120
different

01:00:00,930 --> 01:00:06,120
because you need to create different

01:00:03,120 --> 01:00:08,610
soil from mangabey I know you can create

01:00:06,120 --> 01:00:11,370
an index on the fields and you can

01:00:08,610 --> 01:00:12,810
create sparse index on this field which

01:00:11,370 --> 01:00:14,100
means that any documents where this

01:00:12,810 --> 01:00:17,910
field doesn't exist just don't show up

01:00:14,100 --> 01:00:20,220
in your index or you can make a non

01:00:17,910 --> 01:00:23,820
sparse index where the fields will show

01:00:20,220 --> 01:00:27,630
up but the value will be no is that

01:00:23,820 --> 01:00:30,360
should be possibly anything else one

01:00:27,630 --> 01:00:33,270
right here and then I'd be I've run over

01:00:30,360 --> 01:00:35,820
time so this going to be the last on hey

01:00:33,270 --> 01:00:38,640
so notice to the beginning of the talk

01:00:35,820 --> 01:00:40,380
you said there's four database types you

01:00:38,640 --> 01:00:44,130
only mentioned three from what I've

01:00:40,380 --> 01:00:48,270
dated basis the one honest cool thanks

01:00:44,130 --> 01:00:49,950
yep yes I realized that later during the

01:00:48,270 --> 01:00:52,230
talk I'm and forgot to mention graph

01:00:49,950 --> 01:00:54,510
databases but there's always an eagle

01:00:52,230 --> 01:00:57,630
yes person in the front row right you're

01:00:54,510 --> 01:01:01,230
forgiven yes yes craft databases do all

01:00:57,630 --> 01:01:04,140
the big big time all right one more

01:01:01,230 --> 01:01:07,830
slight key Arcos who doesn't love key

01:01:04,140 --> 01:01:09,870
archives at a QR code will go to my my

01:01:07,830 --> 01:01:11,790
website where you can download the

01:01:09,870 --> 01:01:13,770
slides of this presentation it also has

01:01:11,790 --> 01:01:16,380
a list of resources if you want to do a

01:01:13,770 --> 01:01:18,510
little bit more reading if you have

01:01:16,380 --> 01:01:21,960
further questions comments I am in a

01:01:18,510 --> 01:01:26,490
conference email me I'm getting better

01:01:21,960 --> 01:01:28,260
at answering emails no there's no loss

01:01:26,490 --> 01:01:32,300
I'm getting better at doing that

01:01:28,260 --> 01:01:32,300

YouTube URL: https://www.youtube.com/watch?v=sIJithgF6f0


