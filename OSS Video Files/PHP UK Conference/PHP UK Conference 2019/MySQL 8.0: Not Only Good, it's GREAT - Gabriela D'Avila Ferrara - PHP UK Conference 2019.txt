Title: MySQL 8.0: Not Only Good, it's GREAT - Gabriela D'Avila Ferrara - PHP UK Conference 2019
Publication date: 2019-03-22
Playlist: PHP UK Conference 2019
Description: 
	Learn in this talk the new out of the box features of the most popular database in the world! It will blow your mind what you can do with just plain old SQL. Come on and watch the live demo!
Captions: 
	00:00:00,269 --> 00:00:10,200
I even made the funnest sticker of the

00:00:07,049 --> 00:00:13,170
the big band and put it on the slides

00:00:10,200 --> 00:00:15,030
just to be a bit more original because I

00:00:13,170 --> 00:00:18,359
give this talking before but it's

00:00:15,030 --> 00:00:21,630
revamped so if you watch it it's gonna

00:00:18,359 --> 00:00:24,449
have some different stuff I'm Gabriela

00:00:21,630 --> 00:00:26,220
Davila Ferrara but I prefer to go by

00:00:24,449 --> 00:00:30,660
Gabby because is that easier for

00:00:26,220 --> 00:00:34,320
everybody I work at Google cloud and I'm

00:00:30,660 --> 00:00:35,969
a developer advocate but that means I

00:00:34,320 --> 00:00:38,610
was actually a software engineer for

00:00:35,969 --> 00:00:41,550
twelve years before before becoming a

00:00:38,610 --> 00:00:42,960
developer advocate and if you want to

00:00:41,550 --> 00:00:46,559
learn more about me just follow me on

00:00:42,960 --> 00:00:48,170
Twitter or my website and it's DM open

00:00:46,559 --> 00:00:53,399
so you don't need to follow me at all

00:00:48,170 --> 00:00:58,140
it's up to you so my secret now as of

00:00:53,399 --> 00:01:01,199
this moment is version 8 0 15 I want to

00:00:58,140 --> 00:01:04,880
know from the audience who's here is

00:01:01,199 --> 00:01:09,750
running my Seco ain't raise your hand

00:01:04,880 --> 00:01:14,640
no one Wow okay that's gonna be fun

00:01:09,750 --> 00:01:19,830
five seven okay but are you using the

00:01:14,640 --> 00:01:22,680
JSON features okay

00:01:19,830 --> 00:01:26,880
that's okay there's a lot of cool stuff

00:01:22,680 --> 00:01:29,460
on my secret point 0.15 it's from what I

00:01:26,880 --> 00:01:34,110
see they've been releasing you minor

00:01:29,460 --> 00:01:36,210
versions every three months but I don't

00:01:34,110 --> 00:01:39,390
work Oracle so I don't know how long

00:01:36,210 --> 00:01:42,530
it's gonna be the next one this one is

00:01:39,390 --> 00:01:45,090
from February and it has a following

00:01:42,530 --> 00:01:48,770
before a brief history and they've can

00:01:45,090 --> 00:01:52,680
correct me if I'm wrong my signal was

00:01:48,770 --> 00:01:56,369
created in 1995 and it was created to

00:01:52,680 --> 00:02:01,170
handle app from 10 to 100 million rows

00:01:56,369 --> 00:02:05,520
or under 100 megabytes table so I don't

00:02:01,170 --> 00:02:08,009
ofor from the my isin era you know which

00:02:05,520 --> 00:02:12,540
was way faster the I know to be at the

00:02:08,009 --> 00:02:15,569
time now supports terabyte size data I

00:02:12,540 --> 00:02:19,019
have seen really really big databases

00:02:15,569 --> 00:02:23,370
running mysql and like not just only the

00:02:19,019 --> 00:02:28,439
plain version but the forks that are

00:02:23,370 --> 00:02:30,840
around too and for instance I seen the

00:02:28,439 --> 00:02:33,239
big ones that I saw had 10 terabytes on

00:02:30,840 --> 00:02:37,409
and sometimes I work I have all one of

00:02:33,239 --> 00:02:39,450
my great 38 terabytes to to to your

00:02:37,409 --> 00:02:41,930
service and they're like yeah we only

00:02:39,450 --> 00:02:46,349
support up to date today and but if

00:02:41,930 --> 00:02:49,319
that's how big God supports secret

00:02:46,349 --> 00:02:51,359
centers near sequel 2016 so if you don't

00:02:49,319 --> 00:02:53,879
know they win revise the secret

00:02:51,359 --> 00:02:57,689
standards every so often every tweet two

00:02:53,879 --> 00:03:00,450
or three years but some stuffs just from

00:02:57,689 --> 00:03:02,819
2000 to 2003 became available like

00:03:00,450 --> 00:03:05,780
window functions and cities como table

00:03:02,819 --> 00:03:08,849
expressions so it's kind of hard balance

00:03:05,780 --> 00:03:13,859
so what is awesome now what is exciting

00:03:08,849 --> 00:03:18,150
ah well for me while would be awesome

00:03:13,859 --> 00:03:21,090
and please take note it's partial

00:03:18,150 --> 00:03:22,859
indexes I don't know if it's it's a

00:03:21,090 --> 00:03:25,799
which create indexes just with a

00:03:22,859 --> 00:03:28,979
condition on the database so that would

00:03:25,799 --> 00:03:31,879
be awesome and instead of select star

00:03:28,979 --> 00:03:36,379
maybe have an except that would be nice

00:03:31,879 --> 00:03:42,989
so those are my on my wish list please

00:03:36,379 --> 00:03:44,909
but so this is one of the new things not

00:03:42,989 --> 00:03:46,919
the monistic defaults for table creation

00:03:44,909 --> 00:03:49,409
that doesn't mean anything if you don't

00:03:46,919 --> 00:03:51,690
know what it's there it could be

00:03:49,409 --> 00:03:54,510
deterministic and could be not what I'm

00:03:51,690 --> 00:03:57,569
trying to tell you because oh my god

00:03:54,510 --> 00:04:01,979
that's finally there it's you can have

00:03:57,569 --> 00:04:04,229
functions and expressions on the create

00:04:01,979 --> 00:04:06,870
table statements before you could only

00:04:04,229 --> 00:04:09,959
have one timestamp for daytime with

00:04:06,870 --> 00:04:13,049
current date for instance or just a

00:04:09,959 --> 00:04:20,609
constant like number one for integer or

00:04:13,049 --> 00:04:22,770
string for VAR shore shore so now they

00:04:20,609 --> 00:04:24,930
finally are supporting built-in

00:04:22,770 --> 00:04:26,010
functions functions are already on the

00:04:24,930 --> 00:04:29,150
database

00:04:26,010 --> 00:04:32,810
to be the fault called by default and

00:04:29,150 --> 00:04:37,410
what does that mean in the end is that

00:04:32,810 --> 00:04:42,450
you have more power you have now support

00:04:37,410 --> 00:04:45,300
for yo I D my signal now is they try to

00:04:42,450 --> 00:04:47,910
show up as an also document store that's

00:04:45,300 --> 00:04:52,470
why I asked about the JSON features if

00:04:47,910 --> 00:04:55,650
you're using or not and UUID a great

00:04:52,470 --> 00:04:59,250
part of that because allows more

00:04:55,650 --> 00:05:01,740
reliable ID generation than

00:04:59,250 --> 00:05:03,720
autoincrement there was a bug about

00:05:01,740 --> 00:05:08,040
autoincrement that took like 10 years to

00:05:03,720 --> 00:05:13,710
be fixed so that's one example that

00:05:08,040 --> 00:05:18,330
would be more suitable and this is an

00:05:13,710 --> 00:05:21,060
example of a table having the UUID so

00:05:18,330 --> 00:05:23,880
here you see you you ideas being called

00:05:21,060 --> 00:05:28,830
you could use before but not on the

00:05:23,880 --> 00:05:31,500
create table statement now you call the

00:05:28,830 --> 00:05:34,200
UUID and transform to binary form and

00:05:31,500 --> 00:05:34,980
save as binary this is just a

00:05:34,200 --> 00:05:36,750
recommendation

00:05:34,980 --> 00:05:39,630
you could save as a string I don't

00:05:36,750 --> 00:05:45,240
recommend it but like save as a binary

00:05:39,630 --> 00:05:48,270
form as a primary key also so there is a

00:05:45,240 --> 00:05:57,750
demo that I did in here showing up how

00:05:48,270 --> 00:06:03,000
that works so I'm gonna use my blog

00:05:57,750 --> 00:06:06,980
database and I don't know if I have the

00:06:03,000 --> 00:06:09,900
table users for have I'm gonna drop it

00:06:06,980 --> 00:06:13,220
so this is the code that is shown in the

00:06:09,900 --> 00:06:16,830
slide as I said before it's a binary

00:06:13,220 --> 00:06:19,260
it's not know and so which means you can

00:06:16,830 --> 00:06:21,090
omit it on the insert you can only

00:06:19,260 --> 00:06:22,890
search user name and it's gonna generate

00:06:21,090 --> 00:06:26,600
for you like they do with the auto

00:06:22,890 --> 00:06:31,880
increment I new UUID

00:06:26,600 --> 00:06:34,620
so I'm gonna create it I'm gonna select

00:06:31,880 --> 00:06:37,590
it's gonna be empty because I have no

00:06:34,620 --> 00:06:40,580
records on it as I said before you can

00:06:37,590 --> 00:06:43,020
omit the use of

00:06:40,580 --> 00:06:44,940
the primary key in this case because

00:06:43,020 --> 00:06:49,710
they aren't automatically generated for

00:06:44,940 --> 00:06:53,310
you and it's gonna insert the UUID but

00:06:49,710 --> 00:06:56,400
if you select star from users now you're

00:06:53,310 --> 00:06:58,500
gonna see a weird thing because it's in

00:06:56,400 --> 00:07:02,130
binary form and you don't want that you

00:06:58,500 --> 00:07:06,110
want the UUID so that's when this comes

00:07:02,130 --> 00:07:10,200
to life when you convert from binary to

00:07:06,110 --> 00:07:11,940
UUID and show the username and this

00:07:10,200 --> 00:07:15,320
there it is it looks the same but if

00:07:11,940 --> 00:07:17,820
you're looking here it's a bit different

00:07:15,320 --> 00:07:20,550
I'm going to drop the table again and

00:07:17,820 --> 00:07:22,980
I'm gonna show you a use case for an

00:07:20,550 --> 00:07:25,950
expression why would you want to do that

00:07:22,980 --> 00:07:28,760
not just a new UID but other things

00:07:25,950 --> 00:07:31,169
let's say you want to have every

00:07:28,760 --> 00:07:34,080
registration of your user on your

00:07:31,169 --> 00:07:36,630
website or application you wanted to

00:07:34,080 --> 00:07:38,880
have an expiration date and you want to

00:07:36,630 --> 00:07:40,820
set up for a year or two years from the

00:07:38,880 --> 00:07:43,530
date that the person will register

00:07:40,820 --> 00:07:46,710
usually you would keep checking that on

00:07:43,530 --> 00:07:51,390
the code like the registration date is

00:07:46,710 --> 00:07:55,080
it lesser or equal to the date of today

00:07:51,390 --> 00:07:58,560
and doing massive dates is kind of not

00:07:55,080 --> 00:08:02,280
nice so there is a way to do that

00:07:58,560 --> 00:08:04,680
already saving on the database I'm gonna

00:08:02,280 --> 00:08:06,810
create the table user I'm gonna copy

00:08:04,680 --> 00:08:14,270
this part here so I don't have to type

00:08:06,810 --> 00:08:18,919
again and as a said before you can have

00:08:14,270 --> 00:08:22,050
created ads which was the default as

00:08:18,919 --> 00:08:25,940
timestamp not now

00:08:22,050 --> 00:08:31,890
that's gonna generate the default

00:08:25,940 --> 00:08:35,960
current timestamp and now I'm gonna do

00:08:31,890 --> 00:08:35,960
it with an expiration date

00:08:41,750 --> 00:08:47,009
in our current timestamp but when you

00:08:45,029 --> 00:08:49,740
work with expressions in each put it

00:08:47,009 --> 00:08:52,879
between parentheses and I'm gonna set up

00:08:49,740 --> 00:08:56,339
from the current timestamp plus one

00:08:52,879 --> 00:09:03,779
interval of one year it could be any

00:08:56,339 --> 00:09:08,569
interval here and I'm gonna create the

00:09:03,779 --> 00:09:08,569
table oh I think I need to drop it first

00:09:08,660 --> 00:09:15,300
let me see

00:09:11,389 --> 00:09:18,209
they created already chopped so when I

00:09:15,300 --> 00:09:27,959
insert the data again again I just need

00:09:18,209 --> 00:09:29,939
to insert the users and select it you're

00:09:27,959 --> 00:09:34,069
gonna see that that case expiration date

00:09:29,939 --> 00:09:38,220
is actually a year from the date that

00:09:34,069 --> 00:09:41,189
was the creator add there is multiple

00:09:38,220 --> 00:09:46,500
use cases that's just an example that I

00:09:41,189 --> 00:09:48,750
thought you could put a previous column

00:09:46,500 --> 00:09:51,389
that's already declared on the

00:09:48,750 --> 00:09:55,800
expression and do another expression as

00:09:51,389 --> 00:09:59,540
default like times price total sprite

00:09:55,800 --> 00:10:02,970
price times quantity for instance and

00:09:59,540 --> 00:10:04,920
with the definition there so this is one

00:10:02,970 --> 00:10:07,709
reason why you would want to have

00:10:04,920 --> 00:10:09,769
functions however if you have a custom

00:10:07,709 --> 00:10:12,209
function it's not gonna work

00:10:09,769 --> 00:10:14,959
because it's only the building functions

00:10:12,209 --> 00:10:14,959
on MySQL

00:10:19,030 --> 00:10:27,910
another thing that always bugged my mind

00:10:22,180 --> 00:10:30,280
was user management was not easy how

00:10:27,910 --> 00:10:32,800
many people here Google every time they

00:10:30,280 --> 00:10:36,460
install MySQL how to grant permission to

00:10:32,800 --> 00:10:40,320
the root user outside of localhost like

00:10:36,460 --> 00:10:43,990
and then that happens to colorful right

00:10:40,320 --> 00:10:48,490
so now you could create a DBA role they

00:10:43,990 --> 00:10:51,010
have roles so with this new user

00:10:48,490 --> 00:10:52,930
management now you can have reusable

00:10:51,010 --> 00:10:56,080
permission and roles so I can create a

00:10:52,930 --> 00:10:58,840
role for DBA and I can use it for myself

00:10:56,080 --> 00:11:01,320
I can use it for bath and I can use for

00:10:58,840 --> 00:11:05,820
anyone that I want without having to

00:11:01,320 --> 00:11:09,790
memorize all that grant that's usually

00:11:05,820 --> 00:11:11,650
gigantic and has a password policy so

00:11:09,790 --> 00:11:14,380
you can set up how set up the new

00:11:11,650 --> 00:11:17,590
password if if you can reuse the

00:11:14,380 --> 00:11:20,980
password that you use before then

00:11:17,590 --> 00:11:24,190
expiration date on that and the rotation

00:11:20,980 --> 00:11:27,670
how long it's valid for so you can have

00:11:24,190 --> 00:11:30,730
user management of that so there is a

00:11:27,670 --> 00:11:32,860
problem on 5:7 now if you do a grant I

00:11:30,730 --> 00:11:36,310
don't know if it's already stopping you

00:11:32,860 --> 00:11:39,940
but gives you a warning that if you try

00:11:36,310 --> 00:11:42,490
to create a user using grant it's gonna

00:11:39,940 --> 00:11:45,040
say you need to create use create user

00:11:42,490 --> 00:11:47,230
not grant to grant permission because

00:11:45,040 --> 00:11:51,160
grant should only be to grant

00:11:47,230 --> 00:11:53,980
permissions not to create users with

00:11:51,160 --> 00:11:56,650
that because it's not creating new users

00:11:53,980 --> 00:11:59,680
you don't need to use flush privileges

00:11:56,650 --> 00:12:03,100
anymore every time you create a new user

00:11:59,680 --> 00:12:04,630
and grant them permissions and saves you

00:12:03,100 --> 00:12:07,630
from googling and going to stack

00:12:04,630 --> 00:12:11,560
overflow every time so I have an example

00:12:07,630 --> 00:12:13,990
here I want a read-only user you create

00:12:11,560 --> 00:12:17,200
the role in this case I call read-only

00:12:13,990 --> 00:12:22,600
and I'm only applying to the app

00:12:17,200 --> 00:12:25,540
database to the read-only role so anyone

00:12:22,600 --> 00:12:28,800
that I create now and it gets rid only

00:12:25,540 --> 00:12:32,140
can only read from the app database

00:12:28,800 --> 00:12:34,149
that's an example of creating a user

00:12:32,140 --> 00:12:36,640
that didn't change much you put the user

00:12:34,149 --> 00:12:39,550
and by the way Gabriela

00:12:36,640 --> 00:12:42,160
at percent white card percentage and

00:12:39,550 --> 00:12:44,769
Gabriela at localhost there are two

00:12:42,160 --> 00:12:48,180
different users they're not the same so

00:12:44,769 --> 00:12:52,110
you need to pay attention to that and I

00:12:48,180 --> 00:12:56,230
just instead of saying grant select

00:12:52,110 --> 00:13:00,430
again I just say grant read-only to me -

00:12:56,230 --> 00:13:03,160
Gabriela at wild card and it's done if

00:13:00,430 --> 00:13:06,760
you change anything on the permissions

00:13:03,160 --> 00:13:09,579
you don't need to change on the user so

00:13:06,760 --> 00:13:13,620
one thing is tied to another making it

00:13:09,579 --> 00:13:18,880
easier to do user or user management

00:13:13,620 --> 00:13:23,860
there are new stuff under the hood the

00:13:18,880 --> 00:13:26,170
default that it's really important if

00:13:23,860 --> 00:13:29,500
you're using 570 probably using Latin 1

00:13:26,170 --> 00:13:33,339
or utf-8 there's no talk showing how to

00:13:29,500 --> 00:13:36,220
hack a database just using utf-8 if

00:13:33,339 --> 00:13:38,709
you're using utf-8 please even though

00:13:36,220 --> 00:13:42,160
five seven five seven supported use the

00:13:38,709 --> 00:13:45,640
tf8 and before as your default not

00:13:42,160 --> 00:13:51,160
watching one or just utf-8 because it's

00:13:45,640 --> 00:13:53,470
not as secure it's secure there's I saw

00:13:51,160 --> 00:13:55,300
the stock is really scary and I was like

00:13:53,470 --> 00:13:57,910
whoa I did not know if could that could

00:13:55,300 --> 00:13:59,709
do that on the database and one of the

00:13:57,910 --> 00:14:01,810
improvements means you can have

00:13:59,709 --> 00:14:08,410
mathematical equations now inside the

00:14:01,810 --> 00:14:10,390
database and emojis plus snps which in

00:14:08,410 --> 00:14:12,550
this case means if I have a weird

00:14:10,390 --> 00:14:14,920
language that I just invented with weird

00:14:12,550 --> 00:14:16,089
characters I could support it that's

00:14:14,920 --> 00:14:22,720
what it means

00:14:16,089 --> 00:14:27,690
oh by the way sure set is the

00:14:22,720 --> 00:14:33,279
configuration of the Curtis at where the

00:14:27,690 --> 00:14:36,070
how its you're gonna store the beta and

00:14:33,279 --> 00:14:40,240
collation is how you're gonna compare

00:14:36,070 --> 00:14:43,000
the data so it's important to he also

00:14:40,240 --> 00:14:45,699
changed to that thing that's a bit ugly

00:14:43,000 --> 00:14:47,169
imminent but

00:14:45,699 --> 00:14:50,199
what he means is I'm gonna break it down

00:14:47,169 --> 00:14:55,899
when they start I'm studying my secret

00:14:50,199 --> 00:15:00,309
since 2016 and at the time the the ISO

00:14:55,899 --> 00:15:03,489
version for emojis or stuff like that

00:15:00,309 --> 00:15:08,579
was 9.0 and but they are like in version

00:15:03,489 --> 00:15:11,949
11 already so they supported the f8 9

00:15:08,579 --> 00:15:15,040
pointer that's why this year 900 and the

00:15:11,949 --> 00:15:17,949
AIC I it's because accent insensitive

00:15:15,040 --> 00:15:20,470
like my last name has an accent so you

00:15:17,949 --> 00:15:23,980
wouldn't matter if you compare with or

00:15:20,470 --> 00:15:26,980
without it and case insensitive which

00:15:23,980 --> 00:15:29,499
also doesn't matter but in each pay

00:15:26,980 --> 00:15:32,470
attention to if case it's case

00:15:29,499 --> 00:15:36,999
insensitive and you're storing a hashed

00:15:32,470 --> 00:15:39,669
password you may want to to to change

00:15:36,999 --> 00:15:41,739
the collation of that column for

00:15:39,669 --> 00:15:46,379
password to be case sensitive because

00:15:41,739 --> 00:15:46,379
some hashes have difference between

00:15:46,559 --> 00:15:53,199
capital letters or not couple of letters

00:15:49,139 --> 00:15:55,480
and there is a weird bug where the sushi

00:15:53,199 --> 00:15:59,049
emoji was equal to the beer mochi there

00:15:55,480 --> 00:16:03,819
is a blog post on the my sequel server

00:15:59,049 --> 00:16:05,739
team which I put it in there it's

00:16:03,819 --> 00:16:09,850
because the coalition this both

00:16:05,739 --> 00:16:12,609
collisions that they had something was

00:16:09,850 --> 00:16:15,399
making them compare one to another and

00:16:12,609 --> 00:16:17,980
this person found out just because of

00:16:15,399 --> 00:16:20,259
the sushi merge in the B emoji when he

00:16:17,980 --> 00:16:23,799
compared one to another and that means

00:16:20,259 --> 00:16:26,230
like if he was comparing the wrong it

00:16:23,799 --> 00:16:29,289
would compare other characters wrong -

00:16:26,230 --> 00:16:32,649
so that's why coalition is important so

00:16:29,289 --> 00:16:35,889
if you go to my sequence do not use

00:16:32,649 --> 00:16:38,799
general CI or Unicode CI use the default

00:16:35,889 --> 00:16:44,369
which it is this one or codes or case

00:16:38,799 --> 00:16:46,899
sensitive other the 14 variables

00:16:44,369 --> 00:16:48,669
replication if you use it will binary

00:16:46,899 --> 00:16:53,139
login it's an able by default you don't

00:16:48,669 --> 00:16:55,239
need to enabler anymore there is a new

00:16:53,139 --> 00:16:57,879
plugin for education if you try my

00:16:55,239 --> 00:16:59,070
secret on the older application may have

00:16:57,879 --> 00:17:01,110
trouble

00:16:59,070 --> 00:17:03,470
because it's using a new plugin for

00:17:01,110 --> 00:17:07,860
education there uses shacho for

00:17:03,470 --> 00:17:09,990
authentication military default value

00:17:07,860 --> 00:17:12,540
for timestamp on columns there are not

00:17:09,990 --> 00:17:14,370
no so if you'd have a column that's not

00:17:12,540 --> 00:17:15,660
know and use this time step it's going

00:17:14,370 --> 00:17:20,030
to give you an error if you don't send

00:17:15,660 --> 00:17:24,449
that any if you don't set a default and

00:17:20,030 --> 00:17:26,600
there is a new Derrick a dedicated new

00:17:24,449 --> 00:17:31,260
variable that's for dedicated servers

00:17:26,600 --> 00:17:33,750
sometimes you're running on on a VM and

00:17:31,260 --> 00:17:35,910
the VM is the only purpose dominium is

00:17:33,750 --> 00:17:37,950
to be a database and you don't know how

00:17:35,910 --> 00:17:40,410
to turn that the tiny on the database

00:17:37,950 --> 00:17:43,080
which I don't so I just said I'd have to

00:17:40,410 --> 00:17:45,570
own a let it control for me the

00:17:43,080 --> 00:17:48,440
variables they are necessary this is not

00:17:45,570 --> 00:17:51,660
an approach what we do in production but

00:17:48,440 --> 00:17:53,510
it's like a small thing that just proof

00:17:51,660 --> 00:17:55,950
of concept you can do it and let it

00:17:53,510 --> 00:18:03,050
define for you what is good and what is

00:17:55,950 --> 00:18:08,580
not index s made me happy because

00:18:03,050 --> 00:18:11,550
although Mexico has most of people use I

00:18:08,580 --> 00:18:16,020
know DB and there's other angels like

00:18:11,550 --> 00:18:20,310
federated engines my item doc would you

00:18:16,020 --> 00:18:23,580
be and memory memory for instance allows

00:18:20,310 --> 00:18:25,770
you to create a hash index or if

00:18:23,580 --> 00:18:28,980
ukrainian temporary table also create a

00:18:25,770 --> 00:18:31,230
hash index but normal tapes are beaten

00:18:28,980 --> 00:18:34,920
or motives are v3 and there are b3

00:18:31,230 --> 00:18:39,770
because b3 is on the market sis 1970s it

00:18:34,920 --> 00:18:42,690
is efficient and they had a problem

00:18:39,770 --> 00:18:47,190
because they did not support it the same

00:18:42,690 --> 00:18:50,820
index as before until 5-7 this is what

00:18:47,190 --> 00:18:53,550
it was the syntax would allow you to add

00:18:50,820 --> 00:18:55,770
ascending or descending so you could try

00:18:53,550 --> 00:18:59,100
now on your five six five five

00:18:55,770 --> 00:19:01,110
installation and that's not gonna give

00:18:59,100 --> 00:19:04,380
you any errors it's gonna say that

00:19:01,110 --> 00:19:05,880
created the index is setting but there's

00:19:04,380 --> 00:19:09,140
a caveat when you look at the

00:19:05,880 --> 00:19:12,930
documentation because for future

00:19:09,140 --> 00:19:16,080
extensions of my sequel they would

00:19:12,930 --> 00:19:18,330
currently they are post but ignored and

00:19:16,080 --> 00:19:21,120
the first time I discovered this I got

00:19:18,330 --> 00:19:25,140
so angry because I need a date on this

00:19:21,120 --> 00:19:30,450
any order and was not working but I

00:19:25,140 --> 00:19:32,400
started like like I know someone that

00:19:30,450 --> 00:19:34,890
works there or I was like I need the

00:19:32,400 --> 00:19:36,810
same taxes please put it on and you know

00:19:34,890 --> 00:19:39,450
and not because of me of course they

00:19:36,810 --> 00:19:40,470
didn't they were because of me but they

00:19:39,450 --> 00:19:43,260
finally did it

00:19:40,470 --> 00:19:47,640
or mystically and that's how I feel it

00:19:43,260 --> 00:19:49,620
like it's freedom finally you could say

00:19:47,640 --> 00:19:52,020
it's a b-tree you could reverse it and

00:19:49,620 --> 00:19:55,290
it could get the same result but on my

00:19:52,020 --> 00:19:57,540
Tsukuba didn't work like that before so

00:19:55,290 --> 00:20:04,200
I'm gonna leave you for with new with a

00:19:57,540 --> 00:20:07,140
bit more just teasing so that's the

00:20:04,200 --> 00:20:09,570
syntax now it's the same syntax you know

00:20:07,140 --> 00:20:11,430
it's no longer ignore and no longer

00:20:09,570 --> 00:20:14,520
forcibly created as a sailing because

00:20:11,430 --> 00:20:18,210
you would say that it's descending but

00:20:14,520 --> 00:20:22,770
would create as assigning which it's not

00:20:18,210 --> 00:20:25,590
cool so actually works now the cool

00:20:22,770 --> 00:20:29,370
thing about that it's even though you're

00:20:25,590 --> 00:20:32,520
not using the index on a descending

00:20:29,370 --> 00:20:36,060
manner like I did it in here it's gonna

00:20:32,520 --> 00:20:39,060
use the index anyway it's gonna it's

00:20:36,060 --> 00:20:41,730
gonna know that's they already has I

00:20:39,060 --> 00:20:43,500
indexing username that's this any it's

00:20:41,730 --> 00:20:45,720
kinda okay I'm gonna get up from the

00:20:43,500 --> 00:20:50,550
other part of it and transverse it from

00:20:45,720 --> 00:20:54,650
there so that's one one thing that made

00:20:50,550 --> 00:20:57,300
performance improvements on a lot of

00:20:54,650 --> 00:21:00,540
databases so so if you use a lot of this

00:20:57,300 --> 00:21:02,040
and access this descending queries maybe

00:21:00,540 --> 00:21:04,200
just a forgetting to my secrets gonna

00:21:02,040 --> 00:21:07,470
gain a lot of performance because of

00:21:04,200 --> 00:21:10,320
that creating that kind of indexing so

00:21:07,470 --> 00:21:12,840
another one are invisible in taxes and

00:21:10,320 --> 00:21:16,140
that one I was surprised because I never

00:21:12,840 --> 00:21:19,530
heard of this concept before I have a

00:21:16,140 --> 00:21:22,320
table users it's kind of just username

00:21:19,530 --> 00:21:24,930
and create it out and updated at and I

00:21:22,320 --> 00:21:26,870
do have a I forgot to put any here but I

00:21:24,930 --> 00:21:29,520
do have a

00:21:26,870 --> 00:21:33,270
in acts on username because I'm gonna

00:21:29,520 --> 00:21:36,150
search by username so with invisible

00:21:33,270 --> 00:21:39,720
need access it's not used by the

00:21:36,150 --> 00:21:43,200
optimizer so if you put an index as

00:21:39,720 --> 00:21:46,650
invisible the optimizer did not run on

00:21:43,200 --> 00:21:49,200
the query so you think why the hell

00:21:46,650 --> 00:21:51,140
would I do that if it's not gonna be

00:21:49,200 --> 00:21:56,130
used what I'm going to put an invisible

00:21:51,140 --> 00:21:59,700
well there's a lot of reasons because

00:21:56,130 --> 00:22:01,559
every index is visible by default and to

00:21:59,700 --> 00:22:04,559
create an invisible one you just put it

00:22:01,559 --> 00:22:09,059
as invisible and one of the reasons is

00:22:04,559 --> 00:22:12,090
to drop by index or create an index it's

00:22:09,059 --> 00:22:13,470
a really costly operation it takes a

00:22:12,090 --> 00:22:17,669
while and depends on the size of your

00:22:13,470 --> 00:22:20,880
table I had an eight-course machine with

00:22:17,669 --> 00:22:23,190
52 gigabytes of RAM and on a table with

00:22:20,880 --> 00:22:25,799
50 million records it took two minutes

00:22:23,190 --> 00:22:27,600
to create an index that's fast but not

00:22:25,799 --> 00:22:31,740
everybody can afford to have a machine

00:22:27,600 --> 00:22:35,549
like that so the thing is sometimes you

00:22:31,740 --> 00:22:38,610
create too much in taxes and the one

00:22:35,549 --> 00:22:41,909
index starts to get away in the way of

00:22:38,610 --> 00:22:45,299
another so if you can just disable it

00:22:41,909 --> 00:22:48,000
put its invisible you can debug better

00:22:45,299 --> 00:22:51,510
your query so it's more for the bug

00:22:48,000 --> 00:22:53,190
purposes only as invisible even if you

00:22:51,510 --> 00:22:56,600
create as invisible doesn't mean it's

00:22:53,190 --> 00:23:00,330
not updated it continues being updated

00:22:56,600 --> 00:23:04,110
but it won't it's not used by the query

00:23:00,330 --> 00:23:05,940
planner you can toggle the visibility so

00:23:04,110 --> 00:23:08,370
if you create as invisible or visible

00:23:05,940 --> 00:23:11,820
and want to change it you just do an

00:23:08,370 --> 00:23:16,490
outer table author index and to

00:23:11,820 --> 00:23:16,490
invisible or visible that's just that

00:23:16,909 --> 00:23:23,429
that's an example of the query cost so

00:23:21,270 --> 00:23:26,789
I'm looking for a username called fake

00:23:23,429 --> 00:23:30,120
fancy it's just it's all generated

00:23:26,789 --> 00:23:33,510
usernames because of GDP or so I just

00:23:30,120 --> 00:23:37,289
use added adjectives to the user names

00:23:33,510 --> 00:23:38,730
and with the visible index the cost was

00:23:37,289 --> 00:23:42,440
0 98

00:23:38,730 --> 00:23:45,510
and only one road so it found one row on

00:23:42,440 --> 00:23:48,840
invisible access just turning it as

00:23:45,510 --> 00:23:51,750
invisible it did a full table scan on

00:23:48,840 --> 00:23:56,280
five million rows of five million users

00:23:51,750 --> 00:23:58,679
that I had just toggle on and off this

00:23:56,280 --> 00:24:05,010
is a demonstration because the cool

00:23:58,679 --> 00:24:18,799
thing about that it's because it is fast

00:24:05,010 --> 00:24:18,799
to do it so first I'm gonna show you my

00:24:21,919 --> 00:24:38,000
order by username it found me and that's

00:24:33,720 --> 00:24:38,000
not the right database sorry about it

00:24:39,410 --> 00:24:43,370
and if you look here

00:24:48,360 --> 00:24:56,970
that's all those results and it does use

00:24:51,990 --> 00:25:06,029
the index and if I change to the sending

00:24:56,970 --> 00:25:07,529
because I created as a setting using the

00:25:06,029 --> 00:25:12,110
X condition the same index that I

00:25:07,529 --> 00:25:16,740
created before but backward index scan

00:25:12,110 --> 00:25:21,779
so it still uses it now that right now

00:25:16,740 --> 00:25:25,830
the index is visible if I toggle the

00:25:21,779 --> 00:25:31,080
visibility to invisible it's gonna be a

00:25:25,830 --> 00:25:35,779
fast operation already changed and when

00:25:31,080 --> 00:25:40,289
I do the explain of the same query it

00:25:35,779 --> 00:25:44,549
uses type all fun and rows here it's

00:25:40,289 --> 00:25:46,230
five million just to be doing a like I'm

00:25:44,549 --> 00:25:50,130
not going to run it because it's gonna

00:25:46,230 --> 00:25:53,970
take forever but that's just the explain

00:25:50,130 --> 00:25:57,419
if we're not used to it so target

00:25:53,970 --> 00:26:00,149
toggling on and off helps you debug the

00:25:57,419 --> 00:26:03,899
the the queries and my of course is that

00:26:00,149 --> 00:26:06,179
over simplistic example but if you have

00:26:03,899 --> 00:26:11,220
too many indexes you may want to use

00:26:06,179 --> 00:26:17,429
that instead of dropping your index and

00:26:11,220 --> 00:26:22,080
creating indexes again and you saw how

00:26:17,429 --> 00:26:24,750
fast was and it was fast because they my

00:26:22,080 --> 00:26:27,600
secret before had two algorithms to run

00:26:24,750 --> 00:26:29,700
outer tables and that kind of stuff and

00:26:27,600 --> 00:26:33,450
one was in place and the other one was

00:26:29,700 --> 00:26:35,399
copy you know probably copy very well

00:26:33,450 --> 00:26:38,220
because every time you added a column

00:26:35,399 --> 00:26:43,169
would copy the whole table again rename

00:26:38,220 --> 00:26:46,740
it and job the old table now they have

00:26:43,169 --> 00:26:50,549
an instant algorithm with instance you

00:26:46,740 --> 00:26:52,380
can add columns without without doing

00:26:50,549 --> 00:26:55,529
any place or cooperation which means you

00:26:52,380 --> 00:27:01,310
can add instantaneously a column to the

00:26:55,529 --> 00:27:05,360
table without having to wait that long

00:27:01,310 --> 00:27:07,190
there's there's limitations you need to

00:27:05,360 --> 00:27:10,310
be appending a column to a table what

00:27:07,190 --> 00:27:15,470
that means you do not use like I'm gonna

00:27:10,310 --> 00:27:19,160
create the I don't know status and add

00:27:15,470 --> 00:27:23,030
after username if I do add after put

00:27:19,160 --> 00:27:25,940
after username it's gonna have to wish

00:27:23,030 --> 00:27:27,650
shift the table so it's gonna be a copy

00:27:25,940 --> 00:27:29,330
operation so it's not gonna be

00:27:27,650 --> 00:27:32,150
spontaneously but if you're just adding

00:27:29,330 --> 00:27:34,430
on the end just a penny and you don't

00:27:32,150 --> 00:27:36,530
care about the order about the the

00:27:34,430 --> 00:27:39,530
columns it's got a miscellaneous and

00:27:36,530 --> 00:27:42,860
must not have a default value on the new

00:27:39,530 --> 00:27:44,930
column it can be not no but it cannot

00:27:42,860 --> 00:27:46,910
have a default value because again then

00:27:44,930 --> 00:27:47,840
someone I have to copy the table all

00:27:46,910 --> 00:27:53,180
over again

00:27:47,840 --> 00:27:55,580
he naming table modifying columns ritual

00:27:53,180 --> 00:27:57,650
columns if before on five seven they

00:27:55,580 --> 00:28:00,650
were in place operation which is still

00:27:57,650 --> 00:28:04,460
fast but now they're innocent and if you

00:28:00,650 --> 00:28:06,530
change the default on a column it should

00:28:04,460 --> 00:28:09,680
be also instant because of our feature

00:28:06,530 --> 00:28:13,760
called data dictionary that's on MySQL

00:28:09,680 --> 00:28:16,880
eight it's it it changed the

00:28:13,760 --> 00:28:20,900
architecture of how things work under

00:28:16,880 --> 00:28:24,230
the hood and now a lot of the changes

00:28:20,900 --> 00:28:26,510
that you do you do to a metadata you

00:28:24,230 --> 00:28:28,580
don't do it to the table to the file

00:28:26,510 --> 00:28:31,100
itself it's just a matter data change

00:28:28,580 --> 00:28:35,600
which you lead sometimes to interesting

00:28:31,100 --> 00:28:38,270
bugs like on my sequel 8 0 13 they found

00:28:35,600 --> 00:28:41,750
a bug if you rename the table and had a

00:28:38,270 --> 00:28:43,580
foreign keys you would lose consistency

00:28:41,750 --> 00:28:46,750
the foreign keys would not work

00:28:43,580 --> 00:28:49,670
just because you rename the table so

00:28:46,750 --> 00:28:51,980
there's still got either so keep up to

00:28:49,670 --> 00:28:57,100
date always in fear database of your

00:28:51,980 --> 00:29:01,340
minimal versions and this is an example

00:28:57,100 --> 00:29:04,340
I'm adding a column total to orders it's

00:29:01,340 --> 00:29:05,780
a decimal column and I'm forcing the

00:29:04,340 --> 00:29:09,770
algorithm to be instant

00:29:05,780 --> 00:29:10,340
it took 0.26 seconds which is really

00:29:09,770 --> 00:29:14,400
fast

00:29:10,340 --> 00:29:19,080
for table that has 50 million records

00:29:14,400 --> 00:29:22,110
which took 7.8 seconds to count so was

00:29:19,080 --> 00:29:26,180
faster to add a column and then took out

00:29:22,110 --> 00:29:29,760
how many rows I have on that table

00:29:26,180 --> 00:29:31,890
but with all as you see I did put not

00:29:29,760 --> 00:29:36,000
know but I did not put a default value

00:29:31,890 --> 00:29:38,190
so you can have not know on there both

00:29:36,000 --> 00:29:41,040
sugars had a problem as far as I know if

00:29:38,190 --> 00:29:44,130
it needed to be knowable to be able to

00:29:41,040 --> 00:29:50,160
be instantly added in my secret can do

00:29:44,130 --> 00:29:56,730
if not know which is which is nice now I

00:29:50,160 --> 00:30:00,750
want to stop for a minute because we're

00:29:56,730 --> 00:30:03,450
using usually what we call all ltp

00:30:00,750 --> 00:30:08,270
databases which my sequin posters are

00:30:03,450 --> 00:30:15,170
all LT P stands for online transaction I

00:30:08,270 --> 00:30:20,250
forgot the P okay I'll enter lines

00:30:15,170 --> 00:30:23,280
transactions and the OLAP which is for

00:30:20,250 --> 00:30:26,630
analytical queries its online analytical

00:30:23,280 --> 00:30:26,630
I forgot to pee again

00:30:27,620 --> 00:30:36,570
my security features that OLAP database

00:30:32,070 --> 00:30:41,730
for instance like bigquery has because

00:30:36,570 --> 00:30:44,180
it's columnar into OLTP database which

00:30:41,730 --> 00:30:47,850
means you could do analytical queries

00:30:44,180 --> 00:30:51,810
inside my sequel now without having to

00:30:47,850 --> 00:30:53,940
create a ETL send it to whatever

00:30:51,810 --> 00:30:57,080
database you do columnar database you'd

00:30:53,940 --> 00:30:59,940
want a little analytics on but you

00:30:57,080 --> 00:31:05,490
should not abuse it that's why I said

00:30:59,940 --> 00:31:08,610
stop because it's not performance is not

00:31:05,490 --> 00:31:12,270
as good as it would be for normal crude

00:31:08,610 --> 00:31:15,920
curved queries so the first one its

00:31:12,270 --> 00:31:19,560
window functions window functions are

00:31:15,920 --> 00:31:22,140
they are able to analyze the rows of a

00:31:19,560 --> 00:31:26,400
given result set if you use a window

00:31:22,140 --> 00:31:27,720
function it does not change what is on

00:31:26,400 --> 00:31:32,549
the results

00:31:27,720 --> 00:31:38,100
it's gonna look on the result and give

00:31:32,549 --> 00:31:39,809
you insight what on what you have it's

00:31:38,100 --> 00:31:42,240
like when you're going

00:31:39,809 --> 00:31:45,450
it's like menu if your camera phone

00:31:42,240 --> 00:31:47,190
you're here seeing me speak and you put

00:31:45,450 --> 00:31:50,399
your camera to take a picture me and you

00:31:47,190 --> 00:31:52,620
have a frame and I'm the result set this

00:31:50,399 --> 00:31:57,419
room is the result side but you can move

00:31:52,620 --> 00:32:00,929
the frame and see details of it that's

00:31:57,419 --> 00:32:04,769
the same idea or you just can pick over

00:32:00,929 --> 00:32:09,149
it as we say it pick over the result set

00:32:04,769 --> 00:32:12,149
of a window so you can use to enumerate

00:32:09,149 --> 00:32:16,980
rows like use rule number count how many

00:32:12,149 --> 00:32:22,049
rows you have aggregated sums let's say

00:32:16,980 --> 00:32:24,210
a comers you have a court and the user

00:32:22,049 --> 00:32:30,690
let's say bought a chair and bought a

00:32:24,210 --> 00:32:33,899
table or and you want to calculate how

00:32:30,690 --> 00:32:36,539
much is expanding not a total of the

00:32:33,899 --> 00:32:39,000
bill but like for each item how much I'm

00:32:36,539 --> 00:32:40,919
accumulating for each turns for each

00:32:39,000 --> 00:32:45,269
item there on go adding it to the court

00:32:40,919 --> 00:32:48,360
you can do that with some rank you rank

00:32:45,269 --> 00:32:52,139
the results based on any parameter that

00:32:48,360 --> 00:32:56,190
you have or look that's cool in my

00:32:52,139 --> 00:33:00,899
opinion on the row before or after the

00:32:56,190 --> 00:33:03,690
row you are which is leading like and I

00:33:00,899 --> 00:33:08,159
have an example for you I have an order

00:33:03,690 --> 00:33:10,529
stable and it's data generator so the

00:33:08,159 --> 00:33:14,519
updated add could be different from the

00:33:10,529 --> 00:33:18,769
creator add and before after so I'm

00:33:14,519 --> 00:33:22,200
sorry for that but I'm gonna create this

00:33:18,769 --> 00:33:26,159
disable and this is the result that I

00:33:22,200 --> 00:33:29,850
get it I want to look at creator at for

00:33:26,159 --> 00:33:33,539
this user this six five four three two

00:33:29,850 --> 00:33:38,940
one user and I want to know when it was

00:33:33,539 --> 00:33:41,550
the previous order that the user had if

00:33:38,940 --> 00:33:43,770
you're doing PHP you have an array

00:33:41,550 --> 00:33:47,280
a result set and you can look at the

00:33:43,770 --> 00:33:50,730
next item of the array or the previous I

00:33:47,280 --> 00:33:53,940
wonder array and give you the result but

00:33:50,730 --> 00:33:58,800
your King have also this on the psychic

00:33:53,940 --> 00:34:03,150
Uri so lag means I'm getting the row

00:33:58,800 --> 00:34:05,250
before so I'm getting from created at

00:34:03,150 --> 00:34:09,690
which is the the item that I'm

00:34:05,250 --> 00:34:11,429
interested on over create it at again

00:34:09,690 --> 00:34:13,980
the same height and I'm interested on on

00:34:11,429 --> 00:34:19,200
the ascending order so because I want to

00:34:13,980 --> 00:34:21,419
order before and then delete which it is

00:34:19,200 --> 00:34:24,890
the order that come after so I'm saying

00:34:21,419 --> 00:34:28,919
here give me the created add column at

00:34:24,890 --> 00:34:32,850
the row before me and the creator add

00:34:28,919 --> 00:34:39,810
column and the row after me it's gonna

00:34:32,850 --> 00:34:42,240
look like this here is no because before

00:34:39,810 --> 00:34:45,750
the first order there's no other first

00:34:42,240 --> 00:34:50,010
order so it's gonna be no so the right

00:34:45,750 --> 00:34:52,409
one for the second line is actually the

00:34:50,010 --> 00:34:56,120
next order for the first one so it's the

00:34:52,409 --> 00:35:03,320
lead however it's it's it's the lead

00:34:56,120 --> 00:35:03,320
however for the third line is the lag

00:35:04,250 --> 00:35:09,150
it's a bit complicated when you see a

00:35:07,080 --> 00:35:12,150
first but like you could see for

00:35:09,150 --> 00:35:15,660
instance you can do an elite analytics

00:35:12,150 --> 00:35:20,010
on this and see oh how much time does it

00:35:15,660 --> 00:35:22,920
take for a user to do order again on my

00:35:20,010 --> 00:35:25,100
website and you do one minus an order

00:35:22,920 --> 00:35:29,100
and you have the interval in days or

00:35:25,100 --> 00:35:33,300
seconds or years whatever so that's one

00:35:29,100 --> 00:35:38,010
use case for that so previous order in X

00:35:33,300 --> 00:35:41,000
order break down the function itself

00:35:38,010 --> 00:35:45,110
like the column that you're working on

00:35:41,000 --> 00:35:51,240
how many rows before after the first one

00:35:45,110 --> 00:35:53,890
was proceeding and the window so we're

00:35:51,240 --> 00:35:57,760
developers we hate repetition

00:35:53,890 --> 00:36:03,070
we like dry and this I mean I love

00:35:57,760 --> 00:36:08,310
writing sequel and but I hate copying

00:36:03,070 --> 00:36:10,330
pasting and I try for me this is them

00:36:08,310 --> 00:36:13,060
there's a lot of discussion about this

00:36:10,330 --> 00:36:16,450
lately well like it's visual that this

00:36:13,060 --> 00:36:19,090
this thing for me but there's one thing

00:36:16,450 --> 00:36:24,160
that helps you which it is named in the

00:36:19,090 --> 00:36:27,250
windows so it's the same you declare a

00:36:24,160 --> 00:36:30,340
window which are called me dates and I

00:36:27,250 --> 00:36:33,280
said what that window is and I when I

00:36:30,340 --> 00:36:36,550
use lag and lead I said that I'm using

00:36:33,280 --> 00:36:39,970
over dates that way if I change my

00:36:36,550 --> 00:36:43,020
window I don't have to change my select

00:36:39,970 --> 00:36:48,280
again and it can have multiple windows

00:36:43,020 --> 00:36:50,310
per query also I have a demonstration of

00:36:48,280 --> 00:36:50,310
that

00:36:55,960 --> 00:37:05,530
so this is the quay that we have on the

00:36:59,040 --> 00:37:08,560
on the slide and was pretty fast to run

00:37:05,530 --> 00:37:13,080
we saw there's 50 million orders there

00:37:08,560 --> 00:37:18,060
and this is my problem given three users

00:37:13,080 --> 00:37:24,600
get me the top five orders of each user

00:37:18,060 --> 00:37:24,600
ID so a lot of people would disservice

00:37:24,610 --> 00:37:32,260
what I do is is this let's first rank it

00:37:29,020 --> 00:37:35,200
let's rank what are the top orders of

00:37:32,260 --> 00:37:37,930
these users so I'm gonna be placing here

00:37:35,200 --> 00:37:41,560
and gonna copy because it's gonna be

00:37:37,930 --> 00:37:48,340
faster that way I'm gonna remove the lag

00:37:41,560 --> 00:37:51,100
and the lead those are the users I put

00:37:48,340 --> 00:38:04,260
it in here already that I'm interested

00:37:51,100 --> 00:38:04,260
on so if I do this wait a moment users

00:38:11,050 --> 00:38:17,740
those are all the orders for those users

00:38:13,660 --> 00:38:26,890
that are on my system so I limit for ten

00:38:17,740 --> 00:38:29,350
now let me remove the limit 29 so I

00:38:26,890 --> 00:38:32,440
won't know the five per per user so I

00:38:29,350 --> 00:38:39,940
should have 15 right so let's rank it

00:38:32,440 --> 00:38:40,990
I'm gonna rank and when I rank I need to

00:38:39,940 --> 00:38:44,280
say over what

00:38:40,990 --> 00:38:50,050
that's my window so I'm gonna rank over

00:38:44,280 --> 00:38:54,700
user ID partition by it's like a group

00:38:50,050 --> 00:39:02,620
by but it's a bit different partition by

00:38:54,700 --> 00:39:07,120
user ID and order by total descending

00:39:02,620 --> 00:39:09,810
and it's gonna give me the ranked result

00:39:07,120 --> 00:39:09,810
for everything

00:39:10,380 --> 00:39:14,250
let me put in here yes

00:39:20,420 --> 00:39:31,369
and to make it easier I'm gonna remove

00:39:23,390 --> 00:39:36,410
the credit at the order ID so for this

00:39:31,369 --> 00:39:41,630
user - - - - this is the the order with

00:39:36,410 --> 00:39:45,680
most expensive so you can see the price

00:39:41,630 --> 00:39:48,410
and the second one more expensive and

00:39:45,680 --> 00:39:51,019
the third one more expensive and so on

00:39:48,410 --> 00:39:54,799
and so on but I only want this top free

00:39:51,019 --> 00:39:58,220
how you do that I feel we're writing on

00:39:54,799 --> 00:40:00,400
PHP you just get a top three of all the

00:39:58,220 --> 00:40:03,079
results

00:40:00,400 --> 00:40:05,390
that's where I common table expressions

00:40:03,079 --> 00:40:07,849
come in because remember window

00:40:05,390 --> 00:40:10,549
functions do not change the result set I

00:40:07,849 --> 00:40:13,760
cannot change this result but I can't

00:40:10,549 --> 00:40:18,400
build on top of it so I'm gonna build on

00:40:13,760 --> 00:40:25,819
top of this I'm gonna say this is mine

00:40:18,400 --> 00:40:28,599
ranked orders and it's defined as this

00:40:25,819 --> 00:40:33,559
query that we just created

00:40:28,599 --> 00:40:39,369
and I'm gonna filter it I just need to

00:40:33,559 --> 00:40:45,619
filter now I need to filter from ranked

00:40:39,369 --> 00:40:51,559
orders where the rank order as last or

00:40:45,619 --> 00:40:58,869
equal to five I wanted so it should have

00:40:51,559 --> 00:41:03,890
15 results and as you can see 1 2 3 4 5

00:40:58,869 --> 00:41:10,309
1 2 3 4 5 1 2 3 4 5 that's the power of

00:41:03,890 --> 00:41:11,720
window functions inside the common type

00:41:10,309 --> 00:41:13,369
of expression which I'm going to explain

00:41:11,720 --> 00:41:17,569
right now how it works

00:41:13,369 --> 00:41:21,890
the sum you could say I want to know how

00:41:17,569 --> 00:41:28,460
much accumulated spent the user had so

00:41:21,890 --> 00:41:31,860
if you do a sum on total over

00:41:28,460 --> 00:41:31,860
[Music]

00:41:35,480 --> 00:41:43,100
it's gonna give you the Toro order how

00:41:39,810 --> 00:41:45,330
much that user is spent on everything

00:41:43,100 --> 00:41:53,930
that's for this user

00:41:45,330 --> 00:41:53,930
wait / partition by user ID

00:41:59,020 --> 00:42:04,420
so each user spend that amount of money

00:42:01,570 --> 00:42:12,900
on all the orders but you can have a

00:42:04,420 --> 00:42:12,900
aggregated one if you order by 90

00:42:16,270 --> 00:42:23,940
so you see wait a moment

00:42:35,609 --> 00:42:43,619
so it's it's ugly but like it's how it

00:42:40,709 --> 00:42:45,269
looks like if you say partition by user

00:42:43,619 --> 00:42:50,749
ID because you're getting for that user

00:42:45,269 --> 00:42:53,099
the cumulative spanning rose unbowed

00:42:50,749 --> 00:42:57,259
proceeding the rules there are before so

00:42:53,099 --> 00:43:00,450
the first rule I spent total of

00:42:57,259 --> 00:43:02,999
twenty-two hundred something and the

00:43:00,450 --> 00:43:07,079
other one two hundred something so the

00:43:02,999 --> 00:43:09,989
sum of those two rows of 409 and then

00:43:07,079 --> 00:43:13,079
the sum of the three rows is 532

00:43:09,989 --> 00:43:15,690
something and so on and so on

00:43:13,079 --> 00:43:18,599
so you could actually then create

00:43:15,690 --> 00:43:20,729
another table expression to see the

00:43:18,599 --> 00:43:24,749
difference of spanning between one thing

00:43:20,729 --> 00:43:32,940
and another so that's why we call it

00:43:24,749 --> 00:43:34,890
analytical queries I showed you a common

00:43:32,940 --> 00:43:38,430
table expression but I didn't explain to

00:43:34,890 --> 00:43:42,449
you what it is it's similar to create

00:43:38,430 --> 00:43:44,519
temporary table but you don't need to

00:43:42,449 --> 00:43:47,670
create privilege you just need to have a

00:43:44,519 --> 00:43:51,329
Select privilege to use it you can

00:43:47,670 --> 00:43:55,769
reference other cities if those already

00:43:51,329 --> 00:43:58,920
define I created a city and I could use

00:43:55,769 --> 00:44:01,199
it on another city and you know join

00:43:58,920 --> 00:44:04,400
them together and I have a beautiful

00:44:01,199 --> 00:44:09,329
query with all the analytics that I want

00:44:04,400 --> 00:44:12,329
it can be recursive too and it's easier

00:44:09,329 --> 00:44:16,799
to read then a sub query it is would be

00:44:12,329 --> 00:44:19,140
a sub query of five then a query and

00:44:16,799 --> 00:44:21,749
then the sub query to get the results

00:44:19,140 --> 00:44:24,809
that you want I'm going to show you a

00:44:21,749 --> 00:44:26,999
bit of worker subsidies because they are

00:44:24,809 --> 00:44:32,519
useful for you hierarchical data who

00:44:26,999 --> 00:44:34,650
here uses WordPress who here knows what

00:44:32,519 --> 00:44:37,440
you have categories and other sub

00:44:34,650 --> 00:44:40,369
categories and then there's sub sub

00:44:37,440 --> 00:44:43,289
categories which are hierarchical data

00:44:40,369 --> 00:44:47,999
there probably I didn't look at the code

00:44:43,289 --> 00:44:49,200
or crying that high structure that

00:44:47,999 --> 00:44:54,900
traversal

00:44:49,200 --> 00:44:57,569
in the PHP code not in the database but

00:44:54,900 --> 00:45:02,039
you can do that on the database instead

00:44:57,569 --> 00:45:04,859
of doing that on your coat so base code

00:45:02,039 --> 00:45:08,579
comes first it's all recursion starts

00:45:04,859 --> 00:45:11,579
with a simple case then a second query

00:45:08,579 --> 00:45:13,289
comes after a Union statement and the

00:45:11,579 --> 00:45:17,339
stop condition should be on the

00:45:13,289 --> 00:45:20,430
recursive call so because there is a

00:45:17,339 --> 00:45:22,380
problem of that or how much recursion

00:45:20,430 --> 00:45:25,920
you can do and by the faults I think

00:45:22,380 --> 00:45:29,880
it's 500 recursions I increase for this

00:45:25,920 --> 00:45:32,069
demo but you should put aware to know

00:45:29,880 --> 00:45:36,750
where what is your breaking point for

00:45:32,069 --> 00:45:41,130
the recursion so I have my category C on

00:45:36,750 --> 00:45:44,490
my blog and I'm I have animal and plants

00:45:41,130 --> 00:45:46,829
as main categories and although all the

00:45:44,490 --> 00:45:49,559
other ones are child children for other

00:45:46,829 --> 00:45:53,400
categories that's an example of

00:45:49,559 --> 00:45:55,109
hierarchical data but I want to traverse

00:45:53,400 --> 00:46:07,490
that tree that's what I said that I was

00:45:55,109 --> 00:46:07,490
once tried to do okay where's mine okay

00:46:08,200 --> 00:46:17,200
I'm not gonna look at that so I'm gonna

00:46:13,900 --> 00:46:20,109
start here it's like the other one you

00:46:17,200 --> 00:46:24,010
start with it with but you say recursive

00:46:20,109 --> 00:46:26,260
you give it a name I'm gonna call it a

00:46:24,010 --> 00:46:29,069
tree but I don't think it's a tree but

00:46:26,260 --> 00:46:33,910
I'll call it call it a tree and then

00:46:29,069 --> 00:46:35,319
what are the fields of that that table

00:46:33,910 --> 00:46:40,950
that I'm creating because I'm creating a

00:46:35,319 --> 00:46:46,089
table here so it's gonna be that level

00:46:40,950 --> 00:46:49,359
name the path because I want to know the

00:46:46,089 --> 00:46:54,640
path of the hierarchical data and the

00:46:49,359 --> 00:46:59,380
node ID and then you need to do the

00:46:54,640 --> 00:47:02,410
definition again basic case first

00:46:59,380 --> 00:47:04,260
so the basic case is going to be that

00:47:02,410 --> 00:47:08,859
level equal to one

00:47:04,260 --> 00:47:11,410
I'm gonna call root as my first name but

00:47:08,859 --> 00:47:16,990
Mexico has a problem of that you cannot

00:47:11,410 --> 00:47:21,130
use text as a recursive field or wash or

00:47:16,990 --> 00:47:25,020
only Shore so if I recognize it is a

00:47:21,130 --> 00:47:27,339
shore and it's 4/4 and if I have like

00:47:25,020 --> 00:47:30,849
the word animal which is higher than

00:47:27,339 --> 00:47:34,890
four so would give me an error so I need

00:47:30,849 --> 00:47:38,559
to cast this as a washer that's bigger

00:47:34,890 --> 00:47:44,200
short that's bigger which I'm gonna do

00:47:38,559 --> 00:47:46,690
two five five in here and the same thing

00:47:44,200 --> 00:47:49,780
for the path because the path could get

00:47:46,690 --> 00:47:52,869
big and I'm gonna use the maximum that I

00:47:49,780 --> 00:47:58,869
can in here which is this number of

00:47:52,869 --> 00:48:01,210
negative numbers and what is my first

00:47:58,869 --> 00:48:04,150
note it's Europe because point and

00:48:01,210 --> 00:48:07,869
animal their parent ID it was zero so

00:48:04,150 --> 00:48:11,859
that's my first use case if I do select

00:48:07,869 --> 00:48:18,180
star from tree I should get one result

00:48:11,859 --> 00:48:20,750
only for now now comes the recursion you

00:48:18,180 --> 00:48:26,120
doing Union all

00:48:20,750 --> 00:48:29,900
and then I select I have my glue in here

00:48:26,120 --> 00:48:31,490
because sometimes I forget and you're

00:48:29,900 --> 00:48:37,640
gonna sell X I'm gonna leave it blank

00:48:31,490 --> 00:48:43,840
for now from tree and from categories

00:48:37,640 --> 00:48:45,980
I'm sorry and inner join on three and

00:48:43,840 --> 00:48:50,300
I'll explain later

00:48:45,980 --> 00:48:52,490
so from the first one is my duct level

00:48:50,300 --> 00:48:55,160
for each recursion I'm gonna increase

00:48:52,490 --> 00:48:59,480
the depth level in one so it's that

00:48:55,160 --> 00:49:01,550
level plus one the name is gonna be the

00:48:59,480 --> 00:49:04,640
same I want to show the name of the

00:49:01,550 --> 00:49:12,320
category so it's gonna be categories dot

00:49:04,640 --> 00:49:15,500
name now I want to show the path I'm

00:49:12,320 --> 00:49:18,380
gonna use a function that my SQL has

00:49:15,500 --> 00:49:19,040
which is concat word separator I don't

00:49:18,380 --> 00:49:21,920
know if you know it

00:49:19,040 --> 00:49:26,200
which means concatenate the string and

00:49:21,920 --> 00:49:29,300
add this character to it is splitted on

00:49:26,200 --> 00:49:33,320
the path because I want to keep the path

00:49:29,300 --> 00:49:36,820
so on three paths with the name that I

00:49:33,320 --> 00:49:40,280
just got which is categories dot name

00:49:36,820 --> 00:49:45,680
and in the end I want to know the note

00:49:40,280 --> 00:49:47,180
ID which it is categories ID however my

00:49:45,680 --> 00:49:50,960
inner join is incomplete here I'm

00:49:47,180 --> 00:49:56,510
enjoying the tree on what on the tree

00:49:50,960 --> 00:50:02,260
the node ID it's equal to the categories

00:49:56,510 --> 00:50:06,770
for it category ID and that should work

00:50:02,260 --> 00:50:10,330
technically speaking I hope let me

00:50:06,770 --> 00:50:10,330
organize it okay

00:50:11,420 --> 00:50:23,450
okay Oh wrong database what and it did

00:50:20,269 --> 00:50:26,920
work but it's hard to read a bit I'm

00:50:23,450 --> 00:50:31,339
gonna do an improvement here order by

00:50:26,920 --> 00:50:33,309
path to be easier to see the path and in

00:50:31,339 --> 00:50:39,140
the end you have the Traverse tree of

00:50:33,309 --> 00:50:40,400
all the categories of a table I didn't

00:50:39,140 --> 00:50:42,950
need to put a stopping condition because

00:50:40,400 --> 00:50:45,319
I only have like 11 so I didn't reach

00:50:42,950 --> 00:50:52,069
maximal dots but you should have

00:50:45,319 --> 00:50:57,529
something like where that level last so

00:50:52,069 --> 00:51:00,109
a code 5 for instance and then it's

00:50:57,529 --> 00:51:04,460
going to give you the same result that's

00:51:00,109 --> 00:51:07,250
a use case for recursive city so instead

00:51:04,460 --> 00:51:09,260
of reusing your script to go querying

00:51:07,250 --> 00:51:19,609
all the time together the stuff in it

00:51:09,260 --> 00:51:23,180
you can use that to be able to get it so

00:51:19,609 --> 00:51:25,490
that's gonna be on or share the slide

00:51:23,180 --> 00:51:29,119
this is the base case as I said before

00:51:25,490 --> 00:51:38,869
and this is the query that I wrote same

00:51:29,119 --> 00:51:42,200
same query and now sub queries I don't

00:51:38,869 --> 00:51:50,599
like sub queries but they are useful

00:51:42,200 --> 00:51:52,789
sometimes who here did this everybody no

00:51:50,599 --> 00:51:55,250
come on everybody did this at least once

00:51:52,789 --> 00:51:59,869
you never put a sub query inside a

00:51:55,250 --> 00:52:03,289
select never okay I'll pretend that I

00:51:59,869 --> 00:52:04,819
believe you so I'm not I'm having two

00:52:03,289 --> 00:52:07,940
sub queries here and there are the same

00:52:04,819 --> 00:52:13,880
sub queries I'm just getting the ID and

00:52:07,940 --> 00:52:16,549
the total from the table orders should

00:52:13,880 --> 00:52:21,380
be an easier way to do that instead of

00:52:16,549 --> 00:52:24,850
getting it this way there is its

00:52:21,380 --> 00:52:29,030
collateral and its new oh I see Kuwait

00:52:24,850 --> 00:52:33,230
whatever it's like a for each innings

00:52:29,030 --> 00:52:35,540
for each row on this result please do

00:52:33,230 --> 00:52:38,570
this query and the several returning

00:52:35,540 --> 00:52:41,540
only one column which you only have

00:52:38,570 --> 00:52:43,820
access on the select you can return how

00:52:41,540 --> 00:52:47,360
many columns you want because it's

00:52:43,820 --> 00:52:50,420
creating a lateral table to your users

00:52:47,360 --> 00:52:53,030
that's why it's called lateral and you

00:52:50,420 --> 00:52:56,240
see here I call it total orders and I

00:52:53,030 --> 00:52:59,980
use as ID and total here to be able to

00:52:56,240 --> 00:53:03,830
show it performance-wise

00:52:59,980 --> 00:53:11,740
the other ones better for now depends on

00:53:03,830 --> 00:53:14,510
how many columns you're bringing but on

00:53:11,740 --> 00:53:18,010
variability on my opinion this is better

00:53:14,510 --> 00:53:18,010
to read then the other one is

00:53:23,820 --> 00:53:33,160
and I'm just gonna show it's not a job

00:53:29,320 --> 00:53:39,520
it's a lateral joint the problem is you

00:53:33,160 --> 00:53:43,780
my query I'm gonna show you here the use

00:53:39,520 --> 00:53:46,840
cases I want the biggest order of the

00:53:43,780 --> 00:53:49,510
user on a joint you would have no

00:53:46,840 --> 00:53:53,070
control over that you could use a group

00:53:49,510 --> 00:53:56,650
by to get the maximum order you're right

00:53:53,070 --> 00:53:58,360
but then I couldn't get the same ID on

00:53:56,650 --> 00:54:00,640
the same row because when you use an

00:53:58,360 --> 00:54:02,980
aggregator the only guarantee is that

00:54:00,640 --> 00:54:05,260
column it doesn't guarantee the column

00:54:02,980 --> 00:54:09,760
that's next to it you would have to do

00:54:05,260 --> 00:54:12,430
twice so that's one example that's the

00:54:09,760 --> 00:54:15,810
same query and what I want to show you

00:54:12,430 --> 00:54:15,810
it's how they behave

00:54:21,510 --> 00:54:25,770
so this I'm gonna pin this result

00:54:24,030 --> 00:54:33,960
because I want to compare to the one

00:54:25,770 --> 00:54:36,840
using tomorrow which it is this one it's

00:54:33,960 --> 00:54:39,570
not the same result and there's a reason

00:54:36,840 --> 00:54:41,700
why when you do the sub-query here this

00:54:39,570 --> 00:54:43,410
one is with the sub-query you're getting

00:54:41,700 --> 00:54:46,920
all the users and then looking for

00:54:43,410 --> 00:54:48,840
orders that the user has if it doesn't

00:54:46,920 --> 00:54:51,980
have in your order is gonna return no

00:54:48,840 --> 00:54:54,750
which makes sense but the lateral

00:54:51,980 --> 00:54:58,710
guarantees that you're not gonna have a

00:54:54,750 --> 00:55:00,300
user that doesn't have orders it's like

00:54:58,710 --> 00:55:04,640
I in their joint that's why it's called

00:55:00,300 --> 00:55:04,640

YouTube URL: https://www.youtube.com/watch?v=tADkhBB-oIg


