Title: Massively Scaled High Performance Web Services with PHP -  Demin Yin - PHP UK Conference 2019
Publication date: 2019-03-22
Playlist: PHP UK Conference 2019
Description: 
	Over the years, software teams have questioned if PHP is a good choice for building web services. In this talk, I will share how we use PHP on the backend for Glu Mobileâ€™s flagship mobile game Design Home, enabling it to regularly rank amongst the top free mobile games - both in downloads and grossing - since its launch in the Apple App Store and the Google Play Store in Q4 2016. Design Home reaches over 1 million daily active users, serving over 100,000 requests per minute while maintaining a user base of over 30 million players. To date, over 1 billion designs have been made by players. We will deep dive into the thought processes, development, testing and deployment strategy, showcasing what we have achieved with PHP and why we love it and rely on it. My goal is to share with the community that, when done the right way, PHP can be used to build and maintain reliable, massively-scalable and high-performance backends using web services.
Captions: 
	00:00:03,440 --> 00:00:08,010
my name is Jamie and today I'm going to

00:00:06,150 --> 00:00:12,420
talk about high-performance

00:00:08,010 --> 00:00:14,969
microservices with PHP a little bit

00:00:12,420 --> 00:00:17,970
about myself I'm a staff software

00:00:14,969 --> 00:00:21,300
engineer at Glu Mobile and I have been

00:00:17,970 --> 00:00:23,130
playing with PHP for many years since

00:00:21,300 --> 00:00:26,220
the year 2000 and work for different

00:00:23,130 --> 00:00:28,340
companies in China and other states and

00:00:26,220 --> 00:00:32,910
you can find me on Twitter

00:00:28,340 --> 00:00:36,450
oke ha here's what I'm going to talk

00:00:32,910 --> 00:00:39,660
about today first I will give a brief

00:00:36,450 --> 00:00:41,790
introduction about design home the

00:00:39,660 --> 00:00:45,120
mobile game that we have been working on

00:00:41,790 --> 00:00:47,250
in those three years then I will discuss

00:00:45,120 --> 00:00:49,860
different improvements different efforts

00:00:47,250 --> 00:00:53,010
we have made to make our

00:00:49,860 --> 00:00:57,420
api's our microservices extremely fast

00:00:53,010 --> 00:01:00,660
on production after that I'm going to

00:00:57,420 --> 00:01:03,359
discuss what else we could do to make

00:01:00,660 --> 00:01:08,360
our micro-services even faster on

00:01:03,359 --> 00:01:08,360
production to push the limit of PHP

00:01:09,020 --> 00:01:19,520
first an overview on design home and

00:01:15,240 --> 00:01:23,340
some PEC and microsoft says behind it

00:01:19,520 --> 00:01:25,380
his own home is a mobile game that we

00:01:23,340 --> 00:01:29,369
have been developing since about three

00:01:25,380 --> 00:01:32,159
years ago since January 2016 they had

00:01:29,369 --> 00:01:35,400
reached some top positions both in the

00:01:32,159 --> 00:01:40,259
US App Store for iPhones and in the u.s.

00:01:35,400 --> 00:01:44,100
Google Play Store and we have a part of

00:01:40,259 --> 00:01:47,189
a minion tali active users over 14

00:01:44,100 --> 00:01:52,439
million words every single day and we

00:01:47,189 --> 00:01:56,219
have our opinion designs update our main

00:01:52,439 --> 00:01:58,700
API service serves about a hundred

00:01:56,219 --> 00:02:02,549
thousand a PR course every single minute

00:01:58,700 --> 00:02:07,079
with average response time about 56

00:02:02,549 --> 00:02:10,140
minutes econds as of now last month it

00:02:07,079 --> 00:02:12,890
was - about 60 minutes seconds and we

00:02:10,140 --> 00:02:17,220
discussed how we achieved that for

00:02:12,890 --> 00:02:21,060
60 milliseconds to 56 minute seconds it

00:02:17,220 --> 00:02:23,760
all we are very proud what we have

00:02:21,060 --> 00:02:26,790
achieved and like to have this

00:02:23,760 --> 00:02:29,580
experience to share our experience on

00:02:26,790 --> 00:02:35,819
how to build high-performance micro

00:02:29,580 --> 00:02:39,390
services for design home we'll use

00:02:35,819 --> 00:02:42,720
different micro services on the back end

00:02:39,390 --> 00:02:44,880
as you can see from the right side for

00:02:42,720 --> 00:02:48,540
this talk I'm going to use the inbox

00:02:44,880 --> 00:02:52,920
micro service as an example for

00:02:48,540 --> 00:02:56,790
discussion this inbox service it

00:02:52,920 --> 00:03:00,860
provides REST API with different crud

00:02:56,790 --> 00:03:04,019
endpoints to manage inbox messages and

00:03:00,860 --> 00:03:08,670
we use different tools for that we use

00:03:04,019 --> 00:03:11,489
PHP seven we use nginx we use composer

00:03:08,670 --> 00:03:13,860
to manage different third-party

00:03:11,489 --> 00:03:19,070
libraries including those libraries

00:03:13,860 --> 00:03:23,489
developed by ourselves and we deploy our

00:03:19,070 --> 00:03:26,870
production instance in easiest Amazon

00:03:23,489 --> 00:03:30,209
SES and also we use different tools for

00:03:26,870 --> 00:03:35,730
logging for testing for debugging and

00:03:30,209 --> 00:03:39,510
for secure check purpose we use Redis

00:03:35,730 --> 00:03:42,450
and Couchbase to store those messages on

00:03:39,510 --> 00:03:45,420
the back end and this inbox microservice

00:03:42,450 --> 00:03:50,910
is well appeased microswitches

00:03:45,420 --> 00:03:54,299
we build on average we have about 30

00:03:50,910 --> 00:03:57,389
sorry 14,000 requests per minute and it

00:03:54,299 --> 00:04:00,359
during peak hours we have about 34,000

00:03:57,389 --> 00:04:05,930
requests per minute with an average

00:04:00,359 --> 00:04:05,930
response time Naslund nine milliseconds

00:04:07,160 --> 00:04:13,799
here is a list of PHP tools PHP

00:04:10,650 --> 00:04:18,150
extensions that we use in most our PHP

00:04:13,799 --> 00:04:20,459
micro services like PHP 7 we use some

00:04:18,150 --> 00:04:24,330
cool features in cage 7 like type

00:04:20,459 --> 00:04:25,250
decorations we use composer we use of

00:04:24,330 --> 00:04:29,660
cash

00:04:25,250 --> 00:04:32,570
we do data cache with a PC you and way

00:04:29,660 --> 00:04:36,890
to distribute cache using radius or some

00:04:32,570 --> 00:04:40,840
scales and if needed we do chain cache

00:04:36,890 --> 00:04:43,790
as well we do different tests unit has

00:04:40,840 --> 00:04:48,080
back part tests to test our API

00:04:43,790 --> 00:04:51,140
endpoints some team McCoy's feature test

00:04:48,080 --> 00:04:55,190
or functional test but I feel the

00:04:51,140 --> 00:04:58,460
similar to each other also we try to do

00:04:55,190 --> 00:05:01,600
PHP the right way using different best

00:04:58,460 --> 00:05:06,800
practice from the community to make our

00:05:01,600 --> 00:05:10,070
microservices reliable fast so I feel

00:05:06,800 --> 00:05:13,880
this as something that we look into the

00:05:10,070 --> 00:05:16,190
first when building PHP applications and

00:05:13,880 --> 00:05:19,520
in this talk I'm not going to discuss

00:05:16,190 --> 00:05:22,730
any of these things in detail instead

00:05:19,520 --> 00:05:30,560
I'm going to discuss something extra on

00:05:22,730 --> 00:05:33,140
top of this list but before the

00:05:30,560 --> 00:05:38,419
discussion I have two more notes to

00:05:33,140 --> 00:05:42,020
mention first most our APRs appeared

00:05:38,419 --> 00:05:44,840
with PHP FP m and n jacks so here when I

00:05:42,020 --> 00:05:51,950
talk about PHP most time I'm talking

00:05:44,840 --> 00:05:55,250
about PHP FP m and certainly will not

00:05:51,950 --> 00:05:56,930
talk about those tours or extension or

00:05:55,250 --> 00:06:01,010
something being used in our micro

00:05:56,930 --> 00:06:02,930
services it may not just about PHP serve

00:06:01,010 --> 00:06:09,620
it could be some tools software that

00:06:02,930 --> 00:06:11,720
work with PHP or relate to PHP so now we

00:06:09,620 --> 00:06:14,930
are going to discuss some different

00:06:11,720 --> 00:06:20,229
improvements that we have made to make

00:06:14,930 --> 00:06:23,000
our APRs very fast as said previously we

00:06:20,229 --> 00:06:26,510
start our development but three years

00:06:23,000 --> 00:06:29,300
ago and in these three years we have

00:06:26,510 --> 00:06:32,750
made tens or even hundreds of different

00:06:29,300 --> 00:06:36,710
efforts improvements to speed up our

00:06:32,750 --> 00:06:38,380
micro services and I won't be able to

00:06:36,710 --> 00:06:41,230
discuss all of them here

00:06:38,380 --> 00:06:45,970
is talk so I'm going to discuss some key

00:06:41,230 --> 00:06:48,190
improvements that we have made so I cook

00:06:45,970 --> 00:06:51,010
those key improvements into four

00:06:48,190 --> 00:06:53,790
different categories here web server

00:06:51,010 --> 00:06:56,830
actually processing data storage

00:06:53,790 --> 00:06:59,980
hardware and network and an each

00:06:56,830 --> 00:07:08,350
category I will discuss three different

00:06:59,980 --> 00:07:15,550
improvements we made first use tour

00:07:08,350 --> 00:07:18,280
Christ ph7 containers as web server we

00:07:15,550 --> 00:07:22,600
used to have a single API service that

00:07:18,280 --> 00:07:26,970
does most of jobs in the background now

00:07:22,600 --> 00:07:30,100
for design home we start speeding those

00:07:26,970 --> 00:07:33,130
tasks those components in two different

00:07:30,100 --> 00:07:37,270
micro services as you can see from the

00:07:33,130 --> 00:07:42,190
right column here so what are the

00:07:37,270 --> 00:07:45,730
benefits here we're concerned that okay

00:07:42,190 --> 00:07:47,920
we have a legacy system here with

00:07:45,730 --> 00:07:50,290
hundreds of thousands or probably even

00:07:47,920 --> 00:07:53,340
millions of language code written by

00:07:50,290 --> 00:07:56,770
different developers at different level

00:07:53,340 --> 00:08:01,060
now you can imagine how hard it could be

00:07:56,770 --> 00:08:03,490
to write testing code for it how

00:08:01,060 --> 00:08:08,410
difficult it could be to upgrade your

00:08:03,490 --> 00:08:11,350
PHP to do major versions and how

00:08:08,410 --> 00:08:14,830
dangerous it could be to refactor this

00:08:11,350 --> 00:08:18,750
legacy system and how painful it could

00:08:14,830 --> 00:08:21,640
be like to talk about issues in it also

00:08:18,750 --> 00:08:24,370
how long it could take for the

00:08:21,640 --> 00:08:28,300
developers to get familiar with your

00:08:24,370 --> 00:08:29,950
system I'm not quite sure if you have

00:08:28,300 --> 00:08:32,610
experienced this or not

00:08:29,950 --> 00:08:39,099
but I did have experienced all these

00:08:32,610 --> 00:08:41,860
persons now think about that we use

00:08:39,099 --> 00:08:44,260
different micro service here to do

00:08:41,860 --> 00:08:48,400
different jobs each of those those

00:08:44,260 --> 00:08:51,910
Microsoft's here small simple and easy

00:08:48,400 --> 00:08:52,810
to maintain it's very easy to write

00:08:51,910 --> 00:08:56,370
testing code

00:08:52,810 --> 00:09:01,209
for each of them it's easy to upgrade

00:08:56,370 --> 00:09:06,670
them to new version of PHP separately

00:09:01,209 --> 00:09:08,410
and is easier to debug those issues in

00:09:06,670 --> 00:09:10,899
those micro-services because they are

00:09:08,410 --> 00:09:13,569
small they are simple and for the

00:09:10,899 --> 00:09:16,660
developers they can easy to get familiar

00:09:13,569 --> 00:09:23,410
with one of those micro-services first

00:09:16,660 --> 00:09:28,120
to warm them up so besides decoupling

00:09:23,410 --> 00:09:31,269
our macro services we use talker to

00:09:28,120 --> 00:09:34,420
develop to deploy our images into Amazon

00:09:31,269 --> 00:09:37,930
SES and there are lots of benefits using

00:09:34,420 --> 00:09:41,709
talker so it helps to improve indistinct

00:09:37,930 --> 00:09:44,589
I'll our DM environments and it's easy

00:09:41,709 --> 00:09:47,500
to upgrade your web server you PHP in

00:09:44,589 --> 00:09:52,920
environments Tullio versions and it's

00:09:47,500 --> 00:09:56,560
easy to debug issues in them I would say

00:09:52,920 --> 00:10:03,850
talker is a must-have tool for PHP

00:09:56,560 --> 00:10:06,009
development today the thing is that ok

00:10:03,850 --> 00:10:09,220
we have so many different micro services

00:10:06,009 --> 00:10:11,680
here and they are being maintained by

00:10:09,220 --> 00:10:14,709
different developers so when creating

00:10:11,680 --> 00:10:17,649
those talk images some of them may use

00:10:14,709 --> 00:10:21,189
like Ubuntu as base image some of them

00:10:17,649 --> 00:10:23,110
may use Debian as base image and we

00:10:21,189 --> 00:10:25,990
could use some other stuff as base

00:10:23,110 --> 00:10:29,290
images we have so many different images

00:10:25,990 --> 00:10:32,610
it's hard to maintain and manage those

00:10:29,290 --> 00:10:35,880
images and the other thing is that

00:10:32,610 --> 00:10:40,120
assuming that you use Ubuntu or Debian

00:10:35,880 --> 00:10:43,509
to build your image and you use apt to

00:10:40,120 --> 00:10:46,329
install PHP and some software there so

00:10:43,509 --> 00:10:49,449
when you rebuild your image you could

00:10:46,329 --> 00:10:52,300
accidentally bring your PHP from do

00:10:49,449 --> 00:10:55,720
versions even you don't make any changes

00:10:52,300 --> 00:10:57,880
in your system in your code your PHP

00:10:55,720 --> 00:11:01,059
code operate automatically in those

00:10:57,880 --> 00:11:04,660
stock images when being rebuilt so this

00:11:01,059 --> 00:11:05,240
is kind of dangers and we don't want

00:11:04,660 --> 00:11:08,809
that

00:11:05,240 --> 00:11:11,990
ten so what we do is that okay we'll use

00:11:08,809 --> 00:11:16,220
a bunch of base images created by

00:11:11,990 --> 00:11:19,369
ourselves which works on different PHP

00:11:16,220 --> 00:11:23,329
micro-services we build we have three

00:11:19,369 --> 00:11:26,300
main base images here the pH fpm one is

00:11:23,329 --> 00:11:30,619
what is being used to create different

00:11:26,300 --> 00:11:33,769
rest HP micro-services we use the pH

00:11:30,619 --> 00:11:36,709
weekly this image if we need to create

00:11:33,769 --> 00:11:39,110
some Joker instances we also have a

00:11:36,709 --> 00:11:41,410
North base image pure twist war is

00:11:39,110 --> 00:11:46,459
something we want to do something

00:11:41,410 --> 00:11:49,689
asynchronously and when we create those

00:11:46,459 --> 00:11:54,019
space images we have certain rules here

00:11:49,689 --> 00:11:56,149
we don't use the tag data steny where we

00:11:54,019 --> 00:12:00,589
don't think it's reliable okay

00:11:56,149 --> 00:12:03,829
and our tags here matched with PHP

00:12:00,589 --> 00:12:05,540
versions if we see a tag like seven

00:12:03,829 --> 00:12:09,290
point three but what it means okay

00:12:05,540 --> 00:12:13,579
this space image use PHP in point three

00:12:09,290 --> 00:12:16,490
point one and if an image being tagged

00:12:13,579 --> 00:12:18,230
in a pin use on production we are not

00:12:16,490 --> 00:12:21,040
going to change it anymore we're not

00:12:18,230 --> 00:12:23,420
going to rebuild anymore it's frozen

00:12:21,040 --> 00:12:26,389
it's never going to be changed anymore

00:12:23,420 --> 00:12:29,809
unless something very important you're

00:12:26,389 --> 00:12:32,240
probably wondering okay what if like we

00:12:29,809 --> 00:12:35,389
found a security issue in the image we

00:12:32,240 --> 00:12:39,139
are using on production well in that

00:12:35,389 --> 00:12:41,809
case we are going to build image but tag

00:12:39,139 --> 00:12:45,319
it with something slight differently

00:12:41,809 --> 00:12:50,209
like seven point three point 1-1 or same

00:12:45,319 --> 00:12:53,019
point three port 1 test 2 and also all

00:12:50,209 --> 00:12:57,679
these images they are being built and

00:12:53,019 --> 00:13:00,199
being deployed intact manually we don't

00:12:57,679 --> 00:13:03,350
have any continuous integration jobs to

00:13:00,199 --> 00:13:04,790
do that automatically it's dangerous so

00:13:03,350 --> 00:13:09,199
by doing all these things

00:13:04,790 --> 00:13:12,589
now we take their efforts to build those

00:13:09,199 --> 00:13:16,910
micro services to build those images and

00:13:12,589 --> 00:13:19,000
it's easy and safe to upgrade PHP to new

00:13:16,910 --> 00:13:21,550
versions across different

00:13:19,000 --> 00:13:24,130
microservices and it's easy to fix

00:13:21,550 --> 00:13:31,990
security issues and to make improvements

00:13:24,130 --> 00:13:34,660
across different microservices now we

00:13:31,990 --> 00:13:37,030
also used different tools PHP tools and

00:13:34,660 --> 00:13:39,970
some other tools during development and

00:13:37,030 --> 00:13:42,790
deployment some of those tools being

00:13:39,970 --> 00:13:46,930
integrated into our base images already

00:13:42,790 --> 00:13:49,750
and for error handling error reporting

00:13:46,930 --> 00:13:52,870
we mainly use the relic and park slag

00:13:49,750 --> 00:13:56,950
and fill this to us so amazing and we

00:13:52,870 --> 00:13:59,740
like them a lot and for secure checks we

00:13:56,950 --> 00:14:04,390
use sonic qube and the sense your labs

00:13:59,740 --> 00:14:06,550
secret checker these two tours work on

00:14:04,390 --> 00:14:10,660
different parts of your PHP source code

00:14:06,550 --> 00:14:13,030
like for sonic qube it shared possible

00:14:10,660 --> 00:14:13,660
coding issues in a code written by

00:14:13,030 --> 00:14:17,110
yourself

00:14:13,660 --> 00:14:20,170
in your project while since you left

00:14:17,110 --> 00:14:22,720
secret checker is to check those

00:14:20,170 --> 00:14:25,839
security vulnerabilities in the

00:14:22,720 --> 00:14:29,680
third-party libraries being used in your

00:14:25,839 --> 00:14:33,250
project through composer both of them

00:14:29,680 --> 00:14:36,490
will use everywhere under 40 bug and

00:14:33,250 --> 00:14:43,500
profiling we mainly use black file and X

00:14:36,490 --> 00:14:50,680
debug in our images now actually

00:14:43,500 --> 00:14:53,260
processing where here's the thing like

00:14:50,680 --> 00:14:55,510
if ready to send out some emails in our

00:14:53,260 --> 00:14:58,060
PHP request or if we need to send out a

00:14:55,510 --> 00:15:01,900
pushing notification all these things

00:14:58,060 --> 00:15:03,850
don't have to be done first before we

00:15:01,900 --> 00:15:06,250
have HP's response being sent back

00:15:03,850 --> 00:15:10,390
through clients these things can be done

00:15:06,250 --> 00:15:12,310
in the background and in PHP we have

00:15:10,390 --> 00:15:15,520
different ways to do background

00:15:12,310 --> 00:15:18,370
processing we could use an external

00:15:15,520 --> 00:15:21,250
program here to do it on the back one

00:15:18,370 --> 00:15:23,890
silently we could register a PHP

00:15:21,250 --> 00:15:27,640
shutdown function to the death just like

00:15:23,890 --> 00:15:30,280
Park flag we could also use a separate

00:15:27,640 --> 00:15:33,100
job queues of server to do that in case

00:15:30,280 --> 00:15:38,320
our job our task is heavier

00:15:33,100 --> 00:15:40,900
and also and appear to fpm we could

00:15:38,320 --> 00:15:44,140
consider to use a function called fast

00:15:40,900 --> 00:15:47,500
GG a finished request to the death there

00:15:44,140 --> 00:15:48,370
are some other options but probably not

00:15:47,500 --> 00:15:51,610
that reliable

00:15:48,370 --> 00:15:55,570
I'm not going to diss them here for us

00:15:51,610 --> 00:15:57,730
in our PHP micro-services most time we

00:15:55,570 --> 00:16:02,410
choose the last option here to use

00:15:57,730 --> 00:16:05,500
function fast CGF finish request what it

00:16:02,410 --> 00:16:10,270
does is to flash all your response data

00:16:05,500 --> 00:16:13,510
to the client first so let's see how it

00:16:10,270 --> 00:16:15,640
works we have two piece of code here

00:16:13,510 --> 00:16:21,580
they are pretty much similar to each

00:16:15,640 --> 00:16:24,490
other but if we check the right side one

00:16:21,580 --> 00:16:27,490
it has a function called fast gf into

00:16:24,490 --> 00:16:30,190
Kraske so what's the difference of these

00:16:27,490 --> 00:16:34,900
two when they being executed and the PHP

00:16:30,190 --> 00:16:37,270
fpm let's take a look at the left side

00:16:34,900 --> 00:16:41,200
one it tries to print out number one

00:16:37,270 --> 00:16:44,880
first then register a PHP Chardon

00:16:41,200 --> 00:16:48,360
function to print out number three then

00:16:44,880 --> 00:16:51,640
create an object of an alarmist class

00:16:48,360 --> 00:16:55,780
which has a district method to print out

00:16:51,640 --> 00:16:58,960
lamp o4 then if you try to print out the

00:16:55,780 --> 00:17:01,660
mature than Corexit to terminate the

00:16:58,960 --> 00:17:04,900
execution so number five here won't be

00:17:01,660 --> 00:17:08,200
print out at all and now we've reached

00:17:04,900 --> 00:17:09,940
the end of this PHP script but it

00:17:08,200 --> 00:17:14,920
doesn't mean there's nothing around

00:17:09,940 --> 00:17:18,190
after that first those PHP shutdown

00:17:14,920 --> 00:17:21,340
functions will be executed in order so

00:17:18,190 --> 00:17:25,210
dem astray will be print out next after

00:17:21,340 --> 00:17:29,460
number two after that those destruct

00:17:25,210 --> 00:17:32,560
methods of those are construct objects

00:17:29,460 --> 00:17:36,340
will be executed in random order so

00:17:32,560 --> 00:17:39,130
number four will be print out last so

00:17:36,340 --> 00:17:43,270
for the left side the output is one two

00:17:39,130 --> 00:17:46,570
three four now let's take a look on the

00:17:43,270 --> 00:17:48,759
right side every since during exiting is

00:17:46,570 --> 00:17:51,779
the same order and it takes about the

00:17:48,759 --> 00:17:55,690
same amount of time for the right side

00:17:51,779 --> 00:17:58,659
but once the function call fast you

00:17:55,690 --> 00:18:02,259
finish where's being caught here if you

00:17:58,659 --> 00:18:06,130
flushed the response to the client first

00:18:02,259 --> 00:18:08,409
which is when only at this point so one

00:18:06,130 --> 00:18:11,230
will be sent back to HP clients they

00:18:08,409 --> 00:18:15,070
will continue to execute whatever after

00:18:11,230 --> 00:18:18,490
so two three four maybe will be print

00:18:15,070 --> 00:18:22,269
out in your PHP fpm process but won't be

00:18:18,490 --> 00:18:25,889
sent back to a client the output you are

00:18:22,269 --> 00:18:32,679
going to see from HP client is just one

00:18:25,889 --> 00:18:36,220
so here's the tricky part by using this

00:18:32,679 --> 00:18:39,250
function call fast CGA finish request we

00:18:36,220 --> 00:18:43,539
don't save any time to actually execute

00:18:39,250 --> 00:18:46,029
the whole PHP process but we could send

00:18:43,539 --> 00:18:52,330
back actually responds much much earlier

00:18:46,029 --> 00:18:55,870
before the whole PHP process finishes so

00:18:52,330 --> 00:18:58,710
here's how we make our APS faster by

00:18:55,870 --> 00:19:01,809
doing background processing like that

00:18:58,710 --> 00:19:05,139
we've in fact some of our micro services

00:19:01,809 --> 00:19:08,470
to perform some of operations after

00:19:05,139 --> 00:19:11,460
having h field response sending back to

00:19:08,470 --> 00:19:15,429
the client like for teaching messages

00:19:11,460 --> 00:19:19,360
what we do is that okay we do some basic

00:19:15,429 --> 00:19:21,820
data validation first then we send a

00:19:19,360 --> 00:19:25,360
successful response back to the client

00:19:21,820 --> 00:19:29,049
without any database interactions then

00:19:25,360 --> 00:19:34,960
we delete the message from the tear base

00:19:29,049 --> 00:19:38,830
in background so by doing that as you

00:19:34,960 --> 00:19:42,700
can see here we decrease our response

00:19:38,830 --> 00:19:45,309
time from about 13 minutes econds to

00:19:42,700 --> 00:19:50,919
nine minute seconds for the inbox

00:19:45,309 --> 00:19:53,710
microservice well some people might

00:19:50,919 --> 00:19:55,840
wondering that okay you are doing things

00:19:53,710 --> 00:19:58,750
in background we don't have much

00:19:55,840 --> 00:20:00,640
visibility on those jobs those talks

00:19:58,750 --> 00:20:04,820
what if there's something

00:20:00,640 --> 00:20:06,350
you know happens in peg 1 well there are

00:20:04,820 --> 00:20:08,420
more things you need to do other than

00:20:06,350 --> 00:20:10,700
just putting your tasks in background

00:20:08,420 --> 00:20:13,430
for processing you need to do some

00:20:10,700 --> 00:20:15,980
basket is a validation first making sure

00:20:13,430 --> 00:20:20,780
your input data won't cause issues in

00:20:15,980 --> 00:20:23,860
background processing we do exponential

00:20:20,780 --> 00:20:27,410
sorry exponential back-off to make sure

00:20:23,860 --> 00:20:30,140
those tasks being performed properly in

00:20:27,410 --> 00:20:32,990
background and also in case there's

00:20:30,140 --> 00:20:35,510
anything wrong anything happens we lock

00:20:32,990 --> 00:20:37,700
them with report them properly so that

00:20:35,510 --> 00:20:41,900
we could get them address properly their

00:20:37,700 --> 00:20:46,690
own so this background processing

00:20:41,900 --> 00:20:50,320
implementation has some limitations and

00:20:46,690 --> 00:20:52,790
also if your son have something heavier

00:20:50,320 --> 00:20:55,370
you probably shouldn't do it like that

00:20:52,790 --> 00:21:00,050
you probably should sing about to have a

00:20:55,370 --> 00:21:02,440
separate job queue to do that also like

00:21:00,050 --> 00:21:06,770
if you have neck locks being used here

00:21:02,440 --> 00:21:10,010
ok you need to make sure to unlock your

00:21:06,770 --> 00:21:13,700
resource properly before to impact on

00:21:10,010 --> 00:21:17,660
processing otherwise so other requests

00:21:13,700 --> 00:21:20,090
could be blocked because of that so we

00:21:17,660 --> 00:21:22,250
have some more detailed discussions and

00:21:20,090 --> 00:21:24,500
the implementations about this

00:21:22,250 --> 00:21:31,160
background processing approach and you

00:21:24,500 --> 00:21:35,300
can check those links here so lots of

00:21:31,160 --> 00:21:36,500
sites support HP compression and many

00:21:35,300 --> 00:21:40,250
published EMS

00:21:36,500 --> 00:21:44,480
frameworks have it implement and enabled

00:21:40,250 --> 00:21:48,860
by default like to pour WordPress Joomla

00:21:44,480 --> 00:21:52,580
and as PHP developers when we create our

00:21:48,860 --> 00:21:54,710
own micro services and we probably want

00:21:52,580 --> 00:21:59,600
to do the same thing to have HP

00:21:54,710 --> 00:22:03,260
compression be enabled but does it

00:21:59,600 --> 00:22:07,870
really work on our micro services does

00:22:03,260 --> 00:22:11,990
it work as should that we always work

00:22:07,870 --> 00:22:13,910
probably no probably no I'm going to

00:22:11,990 --> 00:22:18,380
show how we improved

00:22:13,910 --> 00:22:21,830
compression on our microservices when

00:22:18,380 --> 00:22:24,590
doing hv compression in ng x the first

00:22:21,830 --> 00:22:28,250
thing you want to do is probably to have

00:22:24,590 --> 00:22:31,310
this directive GZ own being there to

00:22:28,250 --> 00:22:34,870
have HV compression can own but that's

00:22:31,310 --> 00:22:39,320
not enough you need to have another one

00:22:34,870 --> 00:22:42,290
to specify what type of responses that

00:22:39,320 --> 00:22:44,840
should be compressed okay if you check

00:22:42,290 --> 00:22:47,330
online and the chapters in GX confusions

00:22:44,840 --> 00:22:51,440
and you could probably always see these

00:22:47,330 --> 00:22:56,540
two but they are not enough especially

00:22:51,440 --> 00:23:00,650
for our case where we use Amazon

00:22:56,540 --> 00:23:04,220
CloudFront as CDN service and here is

00:23:00,650 --> 00:23:07,070
Racine if you have you nginx running

00:23:04,220 --> 00:23:12,020
behind this CDN or some proxy server

00:23:07,070 --> 00:23:14,990
okay then nginx may not know that you're

00:23:12,020 --> 00:23:18,230
sitting or proxy server support HP

00:23:14,990 --> 00:23:21,830
compression in that case your HP

00:23:18,230 --> 00:23:25,400
response won't be compressed by nginx

00:23:21,830 --> 00:23:29,300
at all if there is running behind CDN or

00:23:25,400 --> 00:23:30,020
proxy server so to make sure actually

00:23:29,300 --> 00:23:32,660
compression

00:23:30,020 --> 00:23:35,120
always work even behind the city or some

00:23:32,660 --> 00:23:38,810
proxy server we need to have one more

00:23:35,120 --> 00:23:43,910
directive here called cheesy proxied

00:23:38,810 --> 00:23:45,830
with proper values in there so now it

00:23:43,910 --> 00:23:50,060
seems that we're in a very good shape

00:23:45,830 --> 00:23:54,190
still not yet enough there are two more

00:23:50,060 --> 00:23:56,540
things we do to think about why is

00:23:54,190 --> 00:24:01,760
cheesy compression level

00:23:56,540 --> 00:24:03,590
the other one is cheesy minimal ends the

00:24:01,760 --> 00:24:07,670
compression level is to set a

00:24:03,590 --> 00:24:09,920
compression level average response the

00:24:07,670 --> 00:24:13,600
varies between 1 to 9 where whines

00:24:09,920 --> 00:24:17,750
deeply compressed and for minimal ends

00:24:13,600 --> 00:24:20,180
it is to set minimum length of a

00:24:17,750 --> 00:24:23,600
response that should be compressed a

00:24:20,180 --> 00:24:26,120
default value is 20 and the for

00:24:23,600 --> 00:24:26,930
compression ability for value is 1 both

00:24:26,120 --> 00:24:31,490
of them

00:24:26,930 --> 00:24:35,260
not optimized at all let's say if you

00:24:31,490 --> 00:24:38,750
said millions to one one byte only and

00:24:35,260 --> 00:24:40,880
when the response being compressed the

00:24:38,750 --> 00:24:43,940
output would be way more than one part

00:24:40,880 --> 00:24:48,080
it's it doesn't help any to compress a

00:24:43,940 --> 00:24:52,940
response with just one bite in it so how

00:24:48,080 --> 00:24:54,470
to configure this to properly for us we

00:24:52,940 --> 00:24:56,600
choose a compression level five

00:24:54,470 --> 00:25:02,030
something in between the visual

00:24:56,600 --> 00:25:05,320
propagate and for minimum names we used

00:25:02,030 --> 00:25:10,970
to set at one hundred and twenty bytes

00:25:05,320 --> 00:25:15,380
but it's not a optimized value Chris

00:25:10,970 --> 00:25:20,059
Holland suggests that okay it's better

00:25:15,380 --> 00:25:24,490
to set it at a smallest tipic well you

00:25:20,059 --> 00:25:28,820
will network packed size like 1500 bytes

00:25:24,490 --> 00:25:32,240
and to you because if response is death

00:25:28,820 --> 00:25:34,970
length let's say 1500 bytes it's going

00:25:32,240 --> 00:25:38,179
to fit in in a packet no matter if you

00:25:34,970 --> 00:25:41,110
compress it or not and the way totally

00:25:38,179 --> 00:25:46,030
agree with that so now we set it at

00:25:41,110 --> 00:25:53,000
twelve hundred and eighty 80 bytes and

00:25:46,030 --> 00:25:55,400
thanks Chris for that so now it seems

00:25:53,000 --> 00:25:57,890
that we have everything set on the

00:25:55,400 --> 00:26:00,440
engine side but still it's not enough

00:25:57,890 --> 00:26:03,230
it doesn't mean actually compression

00:26:00,440 --> 00:26:06,050
will work as should in our PHP

00:26:03,230 --> 00:26:12,170
applications yes one motion video check

00:26:06,050 --> 00:26:15,940
on the pH fpm side if HP header content

00:26:12,170 --> 00:26:20,059
is not set in it in PHP responds

00:26:15,940 --> 00:26:23,179
properly nginx we always compress the

00:26:20,059 --> 00:26:27,260
response even its length is less than

00:26:23,179 --> 00:26:30,440
the minimal ins so here's the thing if

00:26:27,260 --> 00:26:34,160
we don't have this particular header set

00:26:30,440 --> 00:26:38,120
properly in our pH fpm process and send

00:26:34,160 --> 00:26:40,580
it back to ngx then we are always going

00:26:38,120 --> 00:26:42,919
to compress the response in

00:26:40,580 --> 00:26:46,510
Jax no even like the response it's just

00:26:42,919 --> 00:26:49,700
about one fight long so different

00:26:46,510 --> 00:26:52,370
frameworks having that particular head

00:26:49,700 --> 00:26:57,500
set different day like for Slim's three

00:26:52,370 --> 00:27:01,010
they always has that had the contents

00:26:57,500 --> 00:27:04,940
had been said properly by default but

00:27:01,010 --> 00:27:07,970
for lumen nerville now they don't have

00:27:04,940 --> 00:27:10,070
that particular headset at all so if you

00:27:07,970 --> 00:27:13,010
happen to use their veil or lumen to

00:27:10,070 --> 00:27:18,470
build your micro services the problem is

00:27:13,010 --> 00:27:22,370
that your HP response we always be

00:27:18,470 --> 00:27:25,570
compressed always and that's not what we

00:27:22,370 --> 00:27:29,750
want to prevent that from happening

00:27:25,570 --> 00:27:33,049
where we create a middleware to for

00:27:29,750 --> 00:27:37,429
their way and lumen to inject that

00:27:33,049 --> 00:27:41,809
header in HP response that's how we get

00:27:37,429 --> 00:27:50,210
the HP compression parts Tom probably in

00:27:41,809 --> 00:27:53,269
our micro services complication

00:27:50,210 --> 00:27:57,860
so there is a very common feature

00:27:53,269 --> 00:28:01,639
request there which is to fit the data

00:27:57,860 --> 00:28:04,130
to the client side so if we have data

00:28:01,639 --> 00:28:08,080
push sorry server push being enabled

00:28:04,130 --> 00:28:11,450
like in HP to it's fairly easy but

00:28:08,080 --> 00:28:14,240
almost all our PHP micro services do use

00:28:11,450 --> 00:28:17,750
actually one in that case what we have

00:28:14,240 --> 00:28:21,169
to do is to hit the server again and

00:28:17,750 --> 00:28:23,840
again to fetch the data and it's

00:28:21,169 --> 00:28:26,720
terrible because first every single time

00:28:23,840 --> 00:28:28,970
we hit the server we are going to make

00:28:26,720 --> 00:28:33,559
some database queries to get the data

00:28:28,970 --> 00:28:35,419
and it's expensive and in case there are

00:28:33,559 --> 00:28:37,490
so many different users they are doing

00:28:35,419 --> 00:28:39,769
the same thing at the same time to fetch

00:28:37,490 --> 00:28:44,260
data from server it's going to be even

00:28:39,769 --> 00:28:49,220
worse so here's how we address the issue

00:28:44,260 --> 00:28:54,440
first we do Taylor cache on a suicide if

00:28:49,220 --> 00:28:57,169
possible and also we use the last model

00:28:54,440 --> 00:29:01,129
and if modified since headers and a

00:28:57,169 --> 00:29:03,740
return HP three or four responses back

00:29:01,129 --> 00:29:08,539
to a client if there is no any new data

00:29:03,740 --> 00:29:11,840
to be feed to the console so that to

00:29:08,539 --> 00:29:14,840
benefits clear the first we reduced

00:29:11,840 --> 00:29:17,269
network i/o because for HP three or four

00:29:14,840 --> 00:29:20,029
responses there is no an imported

00:29:17,269 --> 00:29:23,899
content in a response the response is

00:29:20,029 --> 00:29:27,200
very small attorney and on the server

00:29:23,899 --> 00:29:29,629
side when we need between HP's three or

00:29:27,200 --> 00:29:32,929
four responses back we don't need to

00:29:29,629 --> 00:29:36,799
make that many database queries some

00:29:32,929 --> 00:29:39,799
heavy queries to fetch user data in that

00:29:36,799 --> 00:29:44,570
case reduce the database operations as

00:29:39,799 --> 00:29:47,690
well so there are some other HP headers

00:29:44,570 --> 00:29:58,629
that you may consider to use to use this

00:29:47,690 --> 00:29:58,629
kind of implementation now data storage

00:29:59,259 --> 00:30:05,779
we use no Seco just to make our

00:30:02,350 --> 00:30:07,549
microservices fast and there there are

00:30:05,779 --> 00:30:11,509
many many different options you could

00:30:07,549 --> 00:30:15,519
choose from like Redis touch base air

00:30:11,509 --> 00:30:18,860
spark MongoDB and we choose to use

00:30:15,519 --> 00:30:23,029
various and MongoDB for our inbox

00:30:18,860 --> 00:30:26,750
microservice radius is very handy

00:30:23,029 --> 00:30:29,090
especially like for supporting simple

00:30:26,750 --> 00:30:32,659
data and it has some very interesting

00:30:29,090 --> 00:30:36,799
data structure like set and sort of

00:30:32,659 --> 00:30:40,190
these there Couchbase is just like

00:30:36,799 --> 00:30:42,019
memcache T but with persistent data

00:30:40,190 --> 00:30:45,519
storage and some more features there

00:30:42,019 --> 00:30:49,309
both of them are extremely fast and also

00:30:45,519 --> 00:30:52,250
they can expire data automatically from

00:30:49,309 --> 00:30:54,919
your system but there are also some

00:30:52,250 --> 00:30:58,820
limitations when we use this kind of no

00:30:54,919 --> 00:31:01,669
Seco solutions it's not like Mexico not

00:30:58,820 --> 00:31:04,970
like a DBMS there's no fancy queries

00:31:01,669 --> 00:31:06,770
available and also there is no something

00:31:04,970 --> 00:31:11,510
like index being fair

00:31:06,770 --> 00:31:14,360
and you need to make sure to compress to

00:31:11,510 --> 00:31:20,540
sterilize you data properly to save disk

00:31:14,360 --> 00:31:23,470
space for our case where we have

00:31:20,540 --> 00:31:26,690
thousands of messages being created

00:31:23,470 --> 00:31:29,660
being stored the ping sent out every

00:31:26,690 --> 00:31:33,500
single minute and our database keep

00:31:29,660 --> 00:31:37,880
increasing all the time so we have to

00:31:33,500 --> 00:31:40,130
fight against Network IO and to save

00:31:37,880 --> 00:31:42,680
disk space that's one of the biggest

00:31:40,130 --> 00:31:46,810
challenges to us and we have tried many

00:31:42,680 --> 00:31:49,910
many different ways to resolve that like

00:31:46,810 --> 00:31:52,280
for larger messages we try to compress

00:31:49,910 --> 00:31:54,890
them first before saving them to card

00:31:52,280 --> 00:31:57,710
base and we also try to use some

00:31:54,890 --> 00:32:00,730
features in card base like card base

00:31:57,710 --> 00:32:04,910
encoder to sterilize those data better

00:32:00,730 --> 00:32:07,700
when sing them in card base and for

00:32:04,910 --> 00:32:09,950
certain messages like announcements they

00:32:07,700 --> 00:32:13,040
are pretty similar to each other for

00:32:09,950 --> 00:32:15,920
different users in that case we don't

00:32:13,040 --> 00:32:18,290
have to save the whole message for each

00:32:15,920 --> 00:32:21,140
user we could just create a message

00:32:18,290 --> 00:32:23,120
template then store the message template

00:32:21,140 --> 00:32:25,820
ID or something along with some

00:32:23,120 --> 00:32:30,770
variables for different users into card

00:32:25,820 --> 00:32:33,110
base and also for certain fears let's

00:32:30,770 --> 00:32:36,470
say assuming we have a field called

00:32:33,110 --> 00:32:38,960
expiration and where our messages are in

00:32:36,470 --> 00:32:41,450
JSON format but we don't have to use

00:32:38,960 --> 00:32:44,480
expiration as field them we could

00:32:41,450 --> 00:32:48,740
probably just use e and feed them just

00:32:44,480 --> 00:32:51,950
to save space also there are certain

00:32:48,740 --> 00:32:55,580
messages that don't have to be in system

00:32:51,950 --> 00:32:58,390
forever in that case we use some TD

00:32:55,580 --> 00:33:01,250
airfields to get those messages expired

00:32:58,390 --> 00:33:04,850
automatically from our system from

00:33:01,250 --> 00:33:08,690
Couchbase from rails so that's our

00:33:04,850 --> 00:33:12,220
effort to fight against those Iowa and

00:33:08,690 --> 00:33:12,220
little bit disk space

00:33:14,610 --> 00:33:20,560
besides all these efforts we also want

00:33:18,760 --> 00:33:22,810
to make sure that our database

00:33:20,560 --> 00:33:25,540
operations are fast

00:33:22,810 --> 00:33:29,290
so for greatest operations there are two

00:33:25,540 --> 00:33:32,560
main drivers here Weiss PHP readies it's

00:33:29,290 --> 00:33:37,510
a C extension the other one is pure IDs

00:33:32,560 --> 00:33:40,030
it's a library written in PHP we'll use

00:33:37,510 --> 00:33:41,970
the second one period is because like

00:33:40,030 --> 00:33:45,400
three years ago

00:33:41,970 --> 00:33:47,590
PHP Redis is not yet ready for PHP seven

00:33:45,400 --> 00:33:50,380
so we have to wait stay with periodic

00:33:47,590 --> 00:33:54,670
skier but the problem is period is is

00:33:50,380 --> 00:33:57,880
that it's very nice but it's a little

00:33:54,670 --> 00:34:01,450
bit slow and it costs more memory so

00:33:57,880 --> 00:34:04,750
later on we did a refactor to use PHP

00:34:01,450 --> 00:34:06,910
radius instead and let's see what's the

00:34:04,750 --> 00:34:13,690
difference between these two when

00:34:06,910 --> 00:34:16,990
talking about performance so before when

00:34:13,690 --> 00:34:20,770
we use period is the response time is

00:34:16,990 --> 00:34:24,910
about 16 minutes seconds for the inbox

00:34:20,770 --> 00:34:27,790
microservice after the refactor we start

00:34:24,910 --> 00:34:31,660
using PHP reduce the response time

00:34:27,790 --> 00:34:36,010
reduced from about 16 milliseconds to 11

00:34:31,660 --> 00:34:39,810
minute seconds and there are more ways

00:34:36,010 --> 00:34:44,200
to make various operations even faster

00:34:39,810 --> 00:34:48,040
like you could use pipelining to speed

00:34:44,200 --> 00:34:50,080
up you various queries also introduced

00:34:48,040 --> 00:34:54,360
there are persistent connections

00:34:50,080 --> 00:34:54,360
available if you want to use them

00:34:57,430 --> 00:35:04,799
hardware and that work that's the

00:35:02,349 --> 00:35:04,799
question

00:35:05,819 --> 00:35:13,869
how did a way to cut deployment before

00:35:08,890 --> 00:35:18,880
on production we're back to a few years

00:35:13,869 --> 00:35:21,730
ago what we do was that we check our new

00:35:18,880 --> 00:35:23,799
PHP source code first we sync those PHP

00:35:21,730 --> 00:35:27,029
source code to different production

00:35:23,799 --> 00:35:31,480
servers with an unpacked our PHP code

00:35:27,029 --> 00:35:34,420
from the server replace PHP code on

00:35:31,480 --> 00:35:37,180
those production servers then flush

00:35:34,420 --> 00:35:39,640
caches on each of those production

00:35:37,180 --> 00:35:42,519
servers that's how we did production

00:35:39,640 --> 00:35:46,079
deployment before their issues with this

00:35:42,519 --> 00:35:50,380
approach first during the deployment

00:35:46,079 --> 00:35:52,720
your api's may break some requests may

00:35:50,380 --> 00:35:55,539
break because of that especially when we

00:35:52,720 --> 00:35:59,680
switch our PHP code the second thing is

00:35:55,539 --> 00:36:02,380
that in case we introduce any parks in

00:35:59,680 --> 00:36:04,960
the deployment the text time the final

00:36:02,380 --> 00:36:08,470
issue and we probably have to make not

00:36:04,960 --> 00:36:10,930
commit a patch to fix ratio to make

00:36:08,470 --> 00:36:14,170
another deployment all these things take

00:36:10,930 --> 00:36:20,339
time and during that time your micro

00:36:14,170 --> 00:36:24,309
services are done so now for design home

00:36:20,339 --> 00:36:28,029
we started using Amazon SES to host our

00:36:24,309 --> 00:36:31,269
micro services so when we do include

00:36:28,029 --> 00:36:34,690
deployment what we do is that we create

00:36:31,269 --> 00:36:37,839
talk images first that image has pitched

00:36:34,690 --> 00:36:40,720
FM and nginx built in as web server

00:36:37,839 --> 00:36:43,749
along with our data's PHP source code

00:36:40,720 --> 00:36:47,170
there we then don't a bunch of deal

00:36:43,749 --> 00:36:49,809
instances in Amazon SES and once those

00:36:47,170 --> 00:36:52,269
near instances with new coding stable

00:36:49,809 --> 00:36:56,559
enough we start training collections

00:36:52,269 --> 00:36:59,380
from those old instances so during this

00:36:56,559 --> 00:37:02,019
process we always have certain amount of

00:36:59,380 --> 00:37:05,470
production instance running to serve

00:37:02,019 --> 00:37:09,730
traffic so there is no any ton time here

00:37:05,470 --> 00:37:10,510
and in case we have a party introduced

00:37:09,730 --> 00:37:12,820
in

00:37:10,510 --> 00:37:16,270
the image we created and the we do to do

00:37:12,820 --> 00:37:18,820
a repair it's very easy because we still

00:37:16,270 --> 00:37:21,370
have those old images being there with

00:37:18,820 --> 00:37:23,590
old source code been there what we could

00:37:21,370 --> 00:37:27,580
do is that okay we bring up a bunch of

00:37:23,590 --> 00:37:30,880
instances with old images and take down

00:37:27,580 --> 00:37:34,690
those new images those new continues

00:37:30,880 --> 00:37:39,640
with new images so running back is

00:37:34,690 --> 00:37:42,550
pretty easy here as well and let's say

00:37:39,640 --> 00:37:44,260
one of the production instance is not

00:37:42,550 --> 00:37:48,460
healthy probably running out of memory

00:37:44,260 --> 00:37:52,000
or something where in that case M is

00:37:48,460 --> 00:37:55,300
amazonia's will notice it because each

00:37:52,000 --> 00:37:58,900
instance has health and health check and

00:37:55,300 --> 00:38:02,200
point being there when a particular

00:37:58,900 --> 00:38:05,890
instance is not healthy Amazon will try

00:38:02,200 --> 00:38:09,610
to start a deal container to replace

00:38:05,890 --> 00:38:11,860
that unhealthy one so by doing that we

00:38:09,610 --> 00:38:14,320
always have almost same amount of

00:38:11,860 --> 00:38:20,740
production instance there to serve the

00:38:14,320 --> 00:38:23,500
traffic so another very nice feature is

00:38:20,740 --> 00:38:25,870
auto scanning like today early on

00:38:23,500 --> 00:38:29,740
Thursday we have some big sale in our

00:38:25,870 --> 00:38:33,250
game so like today we have more traffic

00:38:29,740 --> 00:38:36,100
coming and in that case we probably need

00:38:33,250 --> 00:38:39,820
more servers there to serve the traffic

00:38:36,100 --> 00:38:42,760
and in mzs it will notice no changes

00:38:39,820 --> 00:38:46,240
that okay the motors coming it will not

00:38:42,760 --> 00:38:48,880
appoint more instances to serve this

00:38:46,240 --> 00:38:51,760
extra traffic so in case we don't have

00:38:48,880 --> 00:38:53,970
that many traffic now it will reduce the

00:38:51,760 --> 00:39:02,470
amount of production instances

00:38:53,970 --> 00:39:06,280
automatically so we have different given

00:39:02,470 --> 00:39:10,960
environments in Amazon SES we have like

00:39:06,280 --> 00:39:13,750
test are sick dev staging production and

00:39:10,960 --> 00:39:17,740
all these things have a lot for our

00:39:13,750 --> 00:39:19,930
development purpose and especially we

00:39:17,740 --> 00:39:23,350
have a staging environment which is very

00:39:19,930 --> 00:39:24,130
very helpful to us because when we need

00:39:23,350 --> 00:39:27,220
to

00:39:24,130 --> 00:39:30,460
some sing big some major changes to

00:39:27,220 --> 00:39:32,920
production we can always test it in our

00:39:30,460 --> 00:39:36,490
staging raman first make sure everything

00:39:32,920 --> 00:39:40,000
is ok and it's pretty safe to that on

00:39:36,490 --> 00:39:41,770
staging and also if we have some

00:39:40,000 --> 00:39:43,510
production issues some parks on

00:39:41,770 --> 00:39:46,570
production and we want to add and fight

00:39:43,510 --> 00:39:49,900
we don't help do it on production we can

00:39:46,570 --> 00:39:52,030
test it in our stage in Romans which

00:39:49,900 --> 00:40:00,400
works pretty similar to a production

00:39:52,030 --> 00:40:06,160
environment hardware upgrade this helps

00:40:00,400 --> 00:40:09,010
a lot to make our aps much faster so in

00:40:06,160 --> 00:40:13,270
it appears we used to use C for

00:40:09,010 --> 00:40:16,660
instances and last year we upgrade our

00:40:13,270 --> 00:40:20,440
instances topped CPU tab the memory and

00:40:16,660 --> 00:40:24,070
also we have a future code enhance

00:40:20,440 --> 00:40:26,640
networking enabled in our ec2 instances

00:40:24,070 --> 00:40:30,940
and that's a very amazing feature there

00:40:26,640 --> 00:40:34,690
with this hardware upgrades which

00:40:30,940 --> 00:40:37,720
reduced our API responses from about 18

00:40:34,690 --> 00:40:42,490
minutes econds to 50 milliseconds for

00:40:37,720 --> 00:40:46,000
our main service where you're probably

00:40:42,490 --> 00:40:47,800
wondering that we're okay I did a

00:40:46,000 --> 00:40:51,610
hardware upgrade probably I'm going to

00:40:47,800 --> 00:40:54,130
spend more money for that probably but

00:40:51,610 --> 00:40:56,470
not exactly because when you upgrade

00:40:54,130 --> 00:40:58,780
your hardware okay each of your

00:40:56,470 --> 00:41:02,740
production instance crew serve more

00:40:58,780 --> 00:41:05,620
traffic so like last month waited

00:41:02,740 --> 00:41:08,950
another hardware upgrade so doubled our

00:41:05,620 --> 00:41:13,540
CPU and memory resources again but

00:41:08,950 --> 00:41:16,690
meantime we reduced the total number of

00:41:13,540 --> 00:41:20,070
instances on production to half cut them

00:41:16,690 --> 00:41:22,900
down to half so as you can see here

00:41:20,070 --> 00:41:28,080
doing hardware upgrade may not always

00:41:22,900 --> 00:41:28,080
cost that much money as you sing apart

00:41:29,070 --> 00:41:37,460
so

00:41:31,010 --> 00:41:40,130
moving everything into VPC so we started

00:41:37,460 --> 00:41:44,210
using Amazon virtual private cloud about

00:41:40,130 --> 00:41:47,030
one half year ago it's not just to make

00:41:44,210 --> 00:41:50,810
our micro services safe it helps a lot

00:41:47,030 --> 00:41:54,050
to speed up our micro services what we

00:41:50,810 --> 00:41:57,230
have tried is to move our instances

00:41:54,050 --> 00:42:01,099
closer to each other and move them to

00:41:57,230 --> 00:42:03,290
same locations and also for

00:42:01,099 --> 00:42:06,829
communications between micro services

00:42:03,290 --> 00:42:10,579
and the databases we use internal

00:42:06,829 --> 00:42:15,320
network instead of internet for that so

00:42:10,579 --> 00:42:17,960
by doing that it makes our API

00:42:15,320 --> 00:42:20,089
communications much much faster than

00:42:17,960 --> 00:42:24,829
before including those database

00:42:20,089 --> 00:42:31,190
operations let's take just check another

00:42:24,829 --> 00:42:34,400
example here so last month with another

00:42:31,190 --> 00:42:38,180
upgrade not only just to upgrade those

00:42:34,400 --> 00:42:41,510
hardware but also we relocate our micro

00:42:38,180 --> 00:42:47,650
services those their base notes so by

00:42:41,510 --> 00:42:47,650
doing that for couch based operations so

00:42:48,819 --> 00:42:58,180
the those operation time reduced from

00:42:52,730 --> 00:43:01,300
about 10 milliseconds to 5 milliseconds

00:42:58,180 --> 00:43:04,160
so having said all these things

00:43:01,300 --> 00:43:08,660
migrating to a top layers helped us a

00:43:04,160 --> 00:43:11,270
lot to make our APRs faster but it did

00:43:08,660 --> 00:43:14,150
take us a long time lots of different

00:43:11,270 --> 00:43:17,380
efforts to make things down the right

00:43:14,150 --> 00:43:17,380
way in adapters

00:43:23,690 --> 00:43:30,749
well when we start working on our

00:43:28,130 --> 00:43:33,569
microservices for design home back to

00:43:30,749 --> 00:43:36,329
three years ago we were very very small

00:43:33,569 --> 00:43:39,119
team we don't have much different

00:43:36,329 --> 00:43:41,670
resource so we have to use some best

00:43:39,119 --> 00:43:46,200
practice from industry from the

00:43:41,670 --> 00:43:51,960
community like HP one like rest api is

00:43:46,200 --> 00:43:55,230
like ph fpm but now okay we have more

00:43:51,960 --> 00:43:58,019
developers we have more resources now we

00:43:55,230 --> 00:44:00,690
can look into some more scenes to make

00:43:58,019 --> 00:44:04,170
our aps even better even faster so

00:44:00,690 --> 00:44:07,980
here's something that we want to look

00:44:04,170 --> 00:44:10,369
into to make our micro services even

00:44:07,980 --> 00:44:10,369
better

00:44:10,430 --> 00:44:18,660
so for pH fpm so there's different

00:44:14,759 --> 00:44:21,119
create frameworks like Falcon and also

00:44:18,660 --> 00:44:23,309
we weren't talking to the routing parts

00:44:21,119 --> 00:44:26,819
because I feel that ok

00:44:23,309 --> 00:44:29,819
for most PHP frameworks the raw routing

00:44:26,819 --> 00:44:32,599
part seems a little bit slow so but we

00:44:29,819 --> 00:44:36,150
don't have a solution for that yet and

00:44:32,599 --> 00:44:38,970
for asynchronous operations we are

00:44:36,150 --> 00:44:43,650
looking to solutions like PHP or EMP but

00:44:38,970 --> 00:44:46,739
we prefer better with swore especially

00:44:43,650 --> 00:44:49,950
so for which works very nicely if we

00:44:46,739 --> 00:44:54,180
want to pute microservices on a backhand

00:44:49,950 --> 00:44:58,950
side and forth network protocols we

00:44:54,180 --> 00:45:03,720
still use HP one which is not that great

00:44:58,950 --> 00:45:07,589
for packing micro services so we want to

00:45:03,720 --> 00:45:10,470
look into HP 2 and also we want to look

00:45:07,589 --> 00:45:13,829
into some other protocols like the task

00:45:10,470 --> 00:45:17,700
protocol the task protocol is a binary

00:45:13,829 --> 00:45:20,910
protocol it's different from JSON

00:45:17,700 --> 00:45:26,400
because for recreational message let's

00:45:20,910 --> 00:45:30,150
say is about 54 bytes but if we convert

00:45:26,400 --> 00:45:36,610
into this message in task protocol it

00:45:30,150 --> 00:45:39,270
has only about 16 bytes 80% des so

00:45:36,610 --> 00:45:42,940
there is something we want to explore

00:45:39,270 --> 00:45:48,730
later on to make our PHP microservices

00:45:42,940 --> 00:45:51,000
even better even faster Ness and my talk

00:45:48,730 --> 00:46:02,039
today thanks

00:45:51,000 --> 00:46:02,039
[Applause]

00:46:03,330 --> 00:46:08,650
hello

00:46:04,750 --> 00:46:10,690
you mentioned New Relic before and I

00:46:08,650 --> 00:46:13,119
have a question have you tried any open

00:46:10,690 --> 00:46:16,390
source alternatives to New Relic like

00:46:13,119 --> 00:46:20,320
zabbix or something like that you're

00:46:16,390 --> 00:46:23,500
really right have you tried zabbix or

00:46:20,320 --> 00:46:30,340
anything like opens or open source

00:46:23,500 --> 00:46:33,310
alternative to New Relic where we have

00:46:30,340 --> 00:46:37,510
been using your relic for a couple years

00:46:33,310 --> 00:46:39,550
a couple years more than five and with

00:46:37,510 --> 00:46:42,070
you and that you know it's a commercial

00:46:39,550 --> 00:46:45,160
product but it is also as a free version

00:46:42,070 --> 00:46:48,250
with you is very very helpful helps a

00:46:45,160 --> 00:46:51,010
lot for tracking performance especially

00:46:48,250 --> 00:46:55,030
between different deployments now we see

00:46:51,010 --> 00:46:57,160
like for each deployment if we our ApS

00:46:55,030 --> 00:46:59,560
getting slower or better and there could

00:46:57,160 --> 00:47:02,560
be many other options as well but for

00:46:59,560 --> 00:47:04,510
now which are stay with the red and I

00:47:02,560 --> 00:47:07,210
would say there is another good feature

00:47:04,510 --> 00:47:09,220
in the relic is that when we check the

00:47:07,210 --> 00:47:12,180
performance we want to measure the

00:47:09,220 --> 00:47:15,310
performance of different parts in you

00:47:12,180 --> 00:47:17,590
guys like how much time being spent

00:47:15,310 --> 00:47:20,140
already sparred how much time being

00:47:17,590 --> 00:47:22,240
spent on on Couchbase part how much time

00:47:20,140 --> 00:47:25,030
being spent to make external HP cores

00:47:22,240 --> 00:47:27,640
and the erotic could you know get all

00:47:25,030 --> 00:47:36,460
these things being sought out and for

00:47:27,640 --> 00:47:38,710
you it's a few it's very handy yes we

00:47:36,460 --> 00:47:40,900
have limited resources you can't be

00:47:38,710 --> 00:47:48,760
couldn't explore all those great you

00:47:40,900 --> 00:47:52,270
know things thank you this is a question

00:47:48,760 --> 00:47:54,550
about your containers do you combine PHP

00:47:52,270 --> 00:47:57,690
fbml nginx into a single container and

00:47:54,550 --> 00:48:00,840
if so how do you manage the processes

00:47:57,690 --> 00:48:05,460
when when you bring the container up

00:48:00,840 --> 00:48:09,790
that's the okay as I said before

00:48:05,460 --> 00:48:14,480
managing those PHP images

00:48:09,790 --> 00:48:18,800
it's a painful scene right what we do

00:48:14,480 --> 00:48:21,650
right now is that we don't use apt to

00:48:18,800 --> 00:48:25,010
install PHP or any other period software

00:48:21,650 --> 00:48:27,890
we built them from source code so that

00:48:25,010 --> 00:48:30,170
we know okay when we install PHP into a

00:48:27,890 --> 00:48:33,140
particular piece image it's always of

00:48:30,170 --> 00:48:35,960
that particular version not any like

00:48:33,140 --> 00:48:38,930
patches or minor version thing upgrade

00:48:35,960 --> 00:48:41,240
so that we peered from source code a

00:48:38,930 --> 00:48:45,290
question is more round if you combine

00:48:41,240 --> 00:48:47,600
nginx and PHP PHP M processes in the

00:48:45,290 --> 00:48:49,460
same container and how do you manage

00:48:47,600 --> 00:48:52,760
both those processes when you start the

00:48:49,460 --> 00:48:54,980
container they have to be sorry

00:48:52,760 --> 00:48:57,560
they it's better to put both of them

00:48:54,980 --> 00:48:59,870
into the same image if you put them into

00:48:57,560 --> 00:49:01,970
separate images it doesn't help much but

00:48:59,870 --> 00:49:05,180
also if you put them into separate

00:49:01,970 --> 00:49:07,250
images you need to use TCP connections

00:49:05,180 --> 00:49:10,130
between the two images for the

00:49:07,250 --> 00:49:13,430
communication between PHP FM and ng acts

00:49:10,130 --> 00:49:14,570
but if you use soft file full of

00:49:13,430 --> 00:49:17,930
communication pingatore

00:49:14,570 --> 00:49:19,880
it's going to be more efficient do you

00:49:17,930 --> 00:49:21,860
have anything that starts both the

00:49:19,880 --> 00:49:26,600
processes are like a startup script or a

00:49:21,860 --> 00:49:29,570
process manager you mean to manage nginx

00:49:26,600 --> 00:49:32,360
and PHP fpm processes we'll see when you

00:49:29,570 --> 00:49:34,010
start the container it starts with a

00:49:32,360 --> 00:49:38,210
single command so how do you bring both

00:49:34,010 --> 00:49:43,370
okay we use the supervisor D awesome

00:49:38,210 --> 00:49:45,830
thank you it's a very nice software we

00:49:43,370 --> 00:49:48,260
use it everywhere and we try to use some

00:49:45,830 --> 00:49:50,660
other solutions some other piece images

00:49:48,260 --> 00:49:54,400
but we now we prove more on supervised

00:49:50,660 --> 00:49:54,400
field that's great thanks very much

00:50:01,549 --> 00:50:10,740
hi so the question is specific to ECS it

00:50:07,559 --> 00:50:13,589
has to launch types I'm assuming you're

00:50:10,740 --> 00:50:17,569
you're using easy to launch type have

00:50:13,589 --> 00:50:20,940
you play with the Fargate lunch type and

00:50:17,569 --> 00:50:23,760
how does it behave in terms of

00:50:20,940 --> 00:50:27,769
performance if you have explore that

00:50:23,760 --> 00:50:31,140
there are different strategies to launch

00:50:27,769 --> 00:50:35,579
ec2 instances during deployment and we

00:50:31,140 --> 00:50:37,470
mainly use two replicas replica or and

00:50:35,579 --> 00:50:39,720
the daemon sets they work differently

00:50:37,470 --> 00:50:42,599
but you have to dig into those details

00:50:39,720 --> 00:50:45,210
because as I said it's caused us a lot

00:50:42,599 --> 00:50:48,660
of time to like thing with different

00:50:45,210 --> 00:50:51,359
confusions to make them work better for

00:50:48,660 --> 00:50:54,869
a third deployment example I mentioned

00:50:51,359 --> 00:50:57,000
here it's about the replica but we don't

00:50:54,869 --> 00:50:59,789
use it actually we don't use it for now

00:50:57,000 --> 00:51:01,950
on our main service we use another one

00:50:59,789 --> 00:51:04,980
called team assets it's more reliable

00:51:01,950 --> 00:51:08,430
but it takes more time for production

00:51:04,980 --> 00:51:10,680
deployment the one you mentioned we

00:51:08,430 --> 00:51:14,549
probably used in some micro-services but

00:51:10,680 --> 00:51:17,430
I don't have much impression which high

00:51:14,549 --> 00:51:20,220
knowing what you know now where would

00:51:17,430 --> 00:51:25,799
you advise a team to start optimizing in

00:51:20,220 --> 00:51:27,569
which so knowing what you know now where

00:51:25,799 --> 00:51:29,250
would you advise a team to start

00:51:27,569 --> 00:51:33,240
optimizing if they were to start

00:51:29,250 --> 00:51:35,519
optimizing don't get it

00:51:33,240 --> 00:51:36,990
sorry father I'll try once again so

00:51:35,519 --> 00:51:39,390
you've mentioned four different

00:51:36,990 --> 00:51:41,960
categories of optimizations right where

00:51:39,390 --> 00:51:45,529
would this team should start doing

00:51:41,960 --> 00:51:51,420
optimizations if they are starting now I

00:51:45,529 --> 00:51:54,539
still have a hard time to catch so with

00:51:51,420 --> 00:51:59,279
Serie so the team start work on first

00:51:54,539 --> 00:52:01,529
right probably we can talk about later

00:51:59,279 --> 00:52:03,269
on but I still have a hard time you know

00:52:01,529 --> 00:52:05,299
to catch what you're saying sorry about

00:52:03,269 --> 00:52:05,299
that

00:52:06,089 --> 00:52:12,780
morning I'm just interested in your app

00:52:09,750 --> 00:52:15,320
performance in with the real world

00:52:12,780 --> 00:52:17,340
so even though you're doing brilliant

00:52:15,320 --> 00:52:20,550
reduction in performance in terms of

00:52:17,340 --> 00:52:22,410
response times internally how are you

00:52:20,550 --> 00:52:24,630
seeing performance with people with

00:52:22,410 --> 00:52:27,000
mobile devices and the networks that

00:52:24,630 --> 00:52:28,860
they use are these optimizations helping

00:52:27,000 --> 00:52:30,810
lots or are you still finding the

00:52:28,860 --> 00:52:33,030
response times to actual end users are

00:52:30,810 --> 00:52:35,670
still fairly sluggish and what have you

00:52:33,030 --> 00:52:38,490
done around that that's another big

00:52:35,670 --> 00:52:42,620
challenge to us about to support like

00:52:38,490 --> 00:52:47,280
slow mobile devices and the slow Network

00:52:42,620 --> 00:52:49,710
we we still working with it and it's not

00:52:47,280 --> 00:52:52,200
only just to make changes on our plaque

00:52:49,710 --> 00:52:54,540
and micro-services side we also do to

00:52:52,200 --> 00:52:58,500
make changes improvements on the mobile

00:52:54,540 --> 00:53:01,980
side on the client side it's going to be

00:52:58,500 --> 00:53:04,830
a long talk and long discussion I don't

00:53:01,980 --> 00:53:07,350
have a short answer for it but from

00:53:04,830 --> 00:53:09,990
Perkins our perspective ok if I want to

00:53:07,350 --> 00:53:12,480
address the issue I won't do it which I

00:53:09,990 --> 00:53:17,570
probably won't do it with PHP fpm I'm

00:53:12,480 --> 00:53:23,640
going to do it with some other protocols

00:53:17,570 --> 00:53:27,290
probably other than at HP one yeah and

00:53:23,640 --> 00:53:31,890
that's why I'm mentioning another

00:53:27,290 --> 00:53:36,690
another piece image the swar extension

00:53:31,890 --> 00:53:40,160
there that's a very handy PHP extension

00:53:36,690 --> 00:53:47,640
to address the issue about slow Network

00:53:40,160 --> 00:53:51,750
yeah I write to use services on there

00:53:47,640 --> 00:53:59,400
the rest like API get with excuse me do

00:53:51,750 --> 00:54:03,540
you say API get with API gateway I'm not

00:53:59,400 --> 00:54:09,570
quite sure if I understand your question

00:54:03,540 --> 00:54:12,120
correctly but you mean that when you set

00:54:09,570 --> 00:54:13,710
up your production instances and the

00:54:12,120 --> 00:54:20,040
it's being processed through some

00:54:13,710 --> 00:54:24,900
gateway where two things

00:54:20,040 --> 00:54:29,010
first our containers or our instances

00:54:24,900 --> 00:54:32,790
are running inside Amazon SES and we use

00:54:29,010 --> 00:54:35,520
absolute Muslim cloud front as Didion to

00:54:32,790 --> 00:54:40,530
serve this traffic but for develop

00:54:35,520 --> 00:54:45,780
environments we use some proxy server to

00:54:40,530 --> 00:54:47,160
route those traffic internally is that

00:54:45,780 --> 00:54:50,220
what are you asking

00:54:47,160 --> 00:54:52,710
no it's just modifying it like would you

00:54:50,220 --> 00:54:55,770
use API get where to then go to cloud

00:54:52,710 --> 00:55:00,690
front then to ECS so you can define your

00:54:55,770 --> 00:55:04,550
resources more like a ops question I

00:55:00,690 --> 00:55:04,550
don't have much information about that

00:55:05,660 --> 00:55:08,660
yeah

00:55:10,970 --> 00:55:16,099
we're in the very beginning on your

00:55:13,040 --> 00:55:18,349
slide presentation it's like second or

00:55:16,099 --> 00:55:20,809
third you mentioned that main service is

00:55:18,349 --> 00:55:24,710
talking to database and rest of services

00:55:20,809 --> 00:55:26,690
are behind the main service so no none

00:55:24,710 --> 00:55:29,900
of the services has access to database

00:55:26,690 --> 00:55:37,730
or they just go to main service again

00:55:29,900 --> 00:55:42,020
and again for data okay here's to see

00:55:37,730 --> 00:55:44,510
each micro service on a back-end right

00:55:42,020 --> 00:55:47,510
they could have their own database they

00:55:44,510 --> 00:55:51,349
don't talk to the database for the main

00:55:47,510 --> 00:55:52,760
micro service so like for the inbox

00:55:51,349 --> 00:55:54,980
micro service as me

00:55:52,760 --> 00:55:58,730
it has its own database in the reddest

00:55:54,980 --> 00:56:01,520
database and a card database they don't

00:55:58,730 --> 00:56:06,470
share the same database because like for

00:56:01,520 --> 00:56:10,339
example okay like for our moderation so

00:56:06,470 --> 00:56:11,180
is it used my Seco which we don't use my

00:56:10,339 --> 00:56:13,790
see anywhere else

00:56:11,180 --> 00:56:17,089
especially on the main service so my

00:56:13,790 --> 00:56:26,059
Seco is just used for a particular micro

00:56:17,089 --> 00:56:28,130
service behind yeah okay but persistence

00:56:26,059 --> 00:56:31,010
between the service is how your Inbox

00:56:28,130 --> 00:56:33,589
service knows which message these users

00:56:31,010 --> 00:56:36,069
belongs to or what is your that

00:56:33,589 --> 00:56:39,280
mechanism of evaluating authorization

00:56:36,069 --> 00:56:42,940
users authorizing data among services

00:56:39,280 --> 00:56:46,190
how do you do that I mean JWT or some

00:56:42,940 --> 00:56:50,510
internal local tokens or whatever like

00:56:46,190 --> 00:56:53,049
some kind of identifies their case they

00:56:50,510 --> 00:56:56,329
see only the main micro service is

00:56:53,049 --> 00:56:59,180
publicly available to look on site to

00:56:56,329 --> 00:57:02,270
the mobile game but all other micro

00:56:59,180 --> 00:57:04,670
services they are in V PC and we have

00:57:02,270 --> 00:57:07,819
like firewall they are making sure

00:57:04,670 --> 00:57:11,329
they're not accept or accessible from

00:57:07,819 --> 00:57:14,329
outside of the VC from anywhere only the

00:57:11,329 --> 00:57:18,589
main API service could communicate with

00:57:14,329 --> 00:57:20,300
all those back-end Mac services that's a

00:57:18,589 --> 00:57:22,820
secure consent so

00:57:20,300 --> 00:57:25,700
but it does mean that when we make rest

00:57:22,820 --> 00:57:27,620
api is caused from the main service to

00:57:25,700 --> 00:57:29,540
those micro services we don't have any

00:57:27,620 --> 00:57:31,250
meditation know we still have meditation

00:57:29,540 --> 00:57:34,400
but something pretty simple

00:57:31,250 --> 00:57:39,530
something like HTV basic very basic

00:57:34,400 --> 00:57:41,270
ossification and the way we are not yet

00:57:39,530 --> 00:57:44,780
sure you know if there any has a better

00:57:41,270 --> 00:57:54,650
solution you know for security purpose

00:57:44,780 --> 00:57:57,500
but for now that works well yeah thank

00:57:54,650 --> 00:57:59,960
you well as question on the same topic

00:57:57,500 --> 00:58:02,060
how the main service communicate with

00:57:59,960 --> 00:58:09,290
all the underlying service is a raster

00:58:02,060 --> 00:58:13,130
Rho TCP or whatever well we still use HP

00:58:09,290 --> 00:58:14,780
one the rest appear cause I wish we

00:58:13,130 --> 00:58:17,150
could improve it later on but for now

00:58:14,780 --> 00:58:20,510
all those communications are based on HD

00:58:17,150 --> 00:58:22,940
one rest appears I'm not going to say is

00:58:20,510 --> 00:58:25,300
the best solution but that's what we are

00:58:22,940 --> 00:58:25,300

YouTube URL: https://www.youtube.com/watch?v=_Yjk7EcZ2dI


