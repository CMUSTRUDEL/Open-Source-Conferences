Title: More Secrets of Cryptography - Chris Riley - PHP UK Conference 2019
Publication date: 2019-03-22
Playlist: PHP UK Conference 2019
Description: 
	Alice and Bob have covered the basics of secure communication but cryptography can offer us more than this. After a brief refresher on the basics, we'll take a look at some of these other aspects of cryptography including hash functions, elliptic curves and quantum cryptography. Then we'll take a look at some practical applications answering questions such as: can I trust a web of trust? or should I use a block chain for this?
Captions: 
	00:00:03,440 --> 00:00:09,240
this talk is more secretive photography

00:00:07,319 --> 00:00:12,269
it's obviously going to be covering

00:00:09,240 --> 00:00:14,690
quite a few cryptographic topics the

00:00:12,269 --> 00:00:17,580
idea I had with this talk was to cover

00:00:14,690 --> 00:00:19,560
more interesting areas that I failed to

00:00:17,580 --> 00:00:20,820
fit into the first talk I gave on this

00:00:19,560 --> 00:00:23,070
topic which I have to give it this

00:00:20,820 --> 00:00:24,359
conference last year I don't suppose

00:00:23,070 --> 00:00:27,539
anyone was here last year and saw that

00:00:24,359 --> 00:00:30,119
talk whew cool well don't worry if you

00:00:27,539 --> 00:00:32,910
haven't this probably like completely

00:00:30,119 --> 00:00:34,440
some alone it's completely new topics so

00:00:32,910 --> 00:00:35,850
need quick refresher on all sort of

00:00:34,440 --> 00:00:41,370
cryptography to start off with to make

00:00:35,850 --> 00:00:42,780
sure everyone's up to speed so I mean

00:00:41,370 --> 00:00:44,309
one of the first questions that sort of

00:00:42,780 --> 00:00:46,559
comes up is why why do I actually need

00:00:44,309 --> 00:00:48,390
cryptography what what makes it

00:00:46,559 --> 00:00:50,520
important there's something to sort of

00:00:48,390 --> 00:00:52,680
use in in development work

00:00:50,520 --> 00:00:54,480
it's get gets a lot of attention in the

00:00:52,680 --> 00:00:55,379
media I mean when I wrote this talk

00:00:54,480 --> 00:00:57,149
there was quite a lot of talk from

00:00:55,379 --> 00:00:59,730
politicians about putting back doors

00:00:57,149 --> 00:01:02,820
into encrypted messaging services and

00:00:59,730 --> 00:01:04,439
things like that and and also a lot of

00:01:02,820 --> 00:01:08,549
news about my Bitcoin you might have

00:01:04,439 --> 00:01:11,280
heard and obviously with the rise of the

00:01:08,549 --> 00:01:12,930
Internet and the fact that we're

00:01:11,280 --> 00:01:14,850
collecting yet more and more data on

00:01:12,930 --> 00:01:17,070
people and more day or more more and

00:01:14,850 --> 00:01:20,790
more sense of information it's becoming

00:01:17,070 --> 00:01:23,040
vital to make use of more security

00:01:20,790 --> 00:01:25,740
around that data to make sure that it

00:01:23,040 --> 00:01:27,420
doesn't get into the wrong hands you you

00:01:25,740 --> 00:01:31,170
if you watch the news

00:01:27,420 --> 00:01:34,460
you're quite regularly see companies

00:01:31,170 --> 00:01:38,340
that have been breached and have lost

00:01:34,460 --> 00:01:39,960
reams of customer data ranging from just

00:01:38,340 --> 00:01:42,150
emails and passwords to to more

00:01:39,960 --> 00:01:45,479
sensitive medical information or

00:01:42,150 --> 00:01:47,070
financial information so cryptography is

00:01:45,479 --> 00:01:50,220
becoming more and more important to help

00:01:47,070 --> 00:01:52,729
protect this information and and stop it

00:01:50,220 --> 00:01:54,720
fall into the wrong hands

00:01:52,729 --> 00:01:58,500
what do actually mean when we're talking

00:01:54,720 --> 00:02:00,770
about cryptography so there's quite a

00:01:58,500 --> 00:02:03,240
few areas the modern cryptography covers

00:02:00,770 --> 00:02:04,560
the first one is is probably the most

00:02:03,240 --> 00:02:05,880
obvious one the one that you probably

00:02:04,560 --> 00:02:06,450
think of immediately if someone asks you

00:02:05,880 --> 00:02:09,869
this question

00:02:06,450 --> 00:02:12,120
it's confidentiality we need to ensure

00:02:09,869 --> 00:02:14,819
that anyone who isn't

00:02:12,120 --> 00:02:17,069
intended recipient of a message isn't

00:02:14,819 --> 00:02:20,069
the isn't authorized to view some data

00:02:17,069 --> 00:02:21,120
can't do so we've got hundreds of

00:02:20,069 --> 00:02:23,159
different algorithms which is doing

00:02:21,120 --> 00:02:26,220
developed over the years which can be

00:02:23,159 --> 00:02:28,409
used to provide confidentiality AES is

00:02:26,220 --> 00:02:30,420
currently one of the most widely used

00:02:28,409 --> 00:02:33,379
standards and it's probably the best one

00:02:30,420 --> 00:02:36,239
to use for just ensuring confidentiality

00:02:33,379 --> 00:02:38,700
most of these algorithms are what we

00:02:36,239 --> 00:02:40,230
call symmetric algorithms this means

00:02:38,700 --> 00:02:42,390
that the you use the same encryption key

00:02:40,230 --> 00:02:43,739
for both encrypting the data and in

00:02:42,390 --> 00:02:45,930
decrypting it later on when you want to

00:02:43,739 --> 00:02:48,720
read it again and there are two main

00:02:45,930 --> 00:02:50,430
classes of algorithm here those stream

00:02:48,720 --> 00:02:53,819
ciphers which you can use to work on a

00:02:50,430 --> 00:02:55,500
continuous stream of data that might be

00:02:53,819 --> 00:02:57,150
more useful for streaming it if you've

00:02:55,500 --> 00:02:59,849
got like a continuously going connection

00:02:57,150 --> 00:03:02,459
like SSH for example and then you've got

00:02:59,849 --> 00:03:03,930
block ciphers like AES which break the

00:03:02,459 --> 00:03:07,709
message up into small blocks and encrypt

00:03:03,930 --> 00:03:09,239
each one individually modes of operation

00:03:07,709 --> 00:03:11,159
you have to be a bit more careful with

00:03:09,239 --> 00:03:14,459
block ciphers because you can actually

00:03:11,159 --> 00:03:16,680
introduce some weaknesses if you if you

00:03:14,459 --> 00:03:17,940
don't implement it quite right stream

00:03:16,680 --> 00:03:19,049
ciphers a little bit safe in that

00:03:17,940 --> 00:03:21,989
respect but they do have their own

00:03:19,049 --> 00:03:25,319
downsides no I don't cover much on those

00:03:21,989 --> 00:03:29,280
today but it's useful to know that the

00:03:25,319 --> 00:03:32,340
two exists another area that the modern

00:03:29,280 --> 00:03:35,010
cryptography has to cover is key

00:03:32,340 --> 00:03:39,870
exchange if you want to talk to someone

00:03:35,010 --> 00:03:43,260
else you need to get a agree on a secret

00:03:39,870 --> 00:03:45,680
key one of the ways we can do this is

00:03:43,260 --> 00:03:48,629
using what we call asymmetric

00:03:45,680 --> 00:03:51,449
cryptography that is where you can have

00:03:48,629 --> 00:03:54,870
a different key for encrypting to the

00:03:51,449 --> 00:03:56,340
one used for decrypting that means if

00:03:54,870 --> 00:03:58,500
you're if you want someone to go talk to

00:03:56,340 --> 00:04:00,359
you confidentially you can put the key

00:03:58,500 --> 00:04:03,060
used for encrypting and it's a public

00:04:00,359 --> 00:04:04,769
key out in the world because anyone

00:04:03,060 --> 00:04:06,690
anyone can use that key to encrypt a

00:04:04,769 --> 00:04:08,069
message for you but they can't then use

00:04:06,690 --> 00:04:09,569
that decrypt messages that people are

00:04:08,069 --> 00:04:12,120
sending you so you can keep the other

00:04:09,569 --> 00:04:15,030
half that key the private part secret to

00:04:12,120 --> 00:04:16,289
you and that means that anyone can

00:04:15,030 --> 00:04:18,989
communicate with you without you having

00:04:16,289 --> 00:04:23,090
to specifically go to them and agree on

00:04:18,989 --> 00:04:23,090
a shared symmetric key to use

00:04:24,060 --> 00:04:29,500
another area that we get into is his

00:04:26,950 --> 00:04:32,080
identity proving that when you receive a

00:04:29,500 --> 00:04:35,110
message that it actually came from the

00:04:32,080 --> 00:04:36,520
person you thought it did this actually

00:04:35,110 --> 00:04:39,610
works in a very similar way to key

00:04:36,520 --> 00:04:42,130
exchange but in Reverse you can use an

00:04:39,610 --> 00:04:43,630
algorithm in which the the encryption

00:04:42,130 --> 00:04:45,970
key is kept secret but the decryption

00:04:43,630 --> 00:04:49,090
key is made public that means that you

00:04:45,970 --> 00:04:51,880
can encrypt a message as a signature

00:04:49,090 --> 00:04:53,290
with your private key and anyone in the

00:04:51,880 --> 00:04:55,060
world can decrypt it and verify that it

00:04:53,290 --> 00:04:57,100
came from you

00:04:55,060 --> 00:05:01,230
this is known as a message signature

00:04:57,100 --> 00:05:03,910
usually another area that we get into is

00:05:01,230 --> 00:05:05,680
authentication how do we know that the

00:05:03,910 --> 00:05:10,150
message that that you actually received

00:05:05,680 --> 00:05:13,120
was the one that was sent again for this

00:05:10,150 --> 00:05:15,700
we tend to use hash functions such as

00:05:13,120 --> 00:05:17,950
sha-256 when you receive a message

00:05:15,700 --> 00:05:20,680
that's the one sent if they send the

00:05:17,950 --> 00:05:23,140
hash along with it you can compare the

00:05:20,680 --> 00:05:26,050
data sent with the hash value of the

00:05:23,140 --> 00:05:28,780
message and by either signing that hash

00:05:26,050 --> 00:05:30,490
or by including secret key within the

00:05:28,780 --> 00:05:35,680
hash you can verify that message hasn't

00:05:30,490 --> 00:05:37,270
been tampered with so I did mention

00:05:35,680 --> 00:05:38,710
briefly that we've got the difference

00:05:37,270 --> 00:05:41,290
between symmetric encryption and

00:05:38,710 --> 00:05:42,640
asymmetric there's two class of

00:05:41,290 --> 00:05:44,980
algorithm each have the different

00:05:42,640 --> 00:05:47,350
purpose symmetric algorithms as I say

00:05:44,980 --> 00:05:49,450
have a single key we use for both

00:05:47,350 --> 00:05:51,850
encrypting and decrypting they're

00:05:49,450 --> 00:05:53,380
generally a lot faster at working you

00:05:51,850 --> 00:05:56,170
can encrypt data much quicker with a

00:05:53,380 --> 00:05:58,900
symmetric algorithm they're optimized to

00:05:56,170 --> 00:06:00,160
run really quickly asymmetric however

00:05:58,900 --> 00:06:01,840
them is on the other hand you have the

00:06:00,160 --> 00:06:03,310
two keys one for encryption and

00:06:01,840 --> 00:06:07,480
decryption there are a lot more

00:06:03,310 --> 00:06:09,700
complication computationally complex so

00:06:07,480 --> 00:06:12,940
what will tend to do is use the two in

00:06:09,700 --> 00:06:14,590
combination you will derive a random

00:06:12,940 --> 00:06:16,930
encryption key for your data encrypt

00:06:14,590 --> 00:06:20,500
your gigabytes of images or whatever

00:06:16,930 --> 00:06:22,210
that you want to send with your randomly

00:06:20,500 --> 00:06:23,740
generated key and then you link crypt

00:06:22,210 --> 00:06:26,700
just the key a small amount of data

00:06:23,740 --> 00:06:28,930
using this slower asymmetric algorithm

00:06:26,700 --> 00:06:30,310
you could possibly think about this if

00:06:28,930 --> 00:06:32,250
you want it's like a physical

00:06:30,310 --> 00:06:34,150
representation you think of a padlock

00:06:32,250 --> 00:06:35,710
okay

00:06:34,150 --> 00:06:37,840
had lots got a key it's got a lock I

00:06:35,710 --> 00:06:41,680
could pass someone back in the room a

00:06:37,840 --> 00:06:42,610
little box metal box and a padlock they

00:06:41,680 --> 00:06:45,010
could write a message on a piece of

00:06:42,610 --> 00:06:46,840
paper put it in the box and pass it to

00:06:45,010 --> 00:06:47,950
the front of the room nobody provide

00:06:46,840 --> 00:06:50,200
they've clicked that panel lock shut

00:06:47,950 --> 00:06:52,780
nobody who's passing it forward and

00:06:50,200 --> 00:06:54,130
helping me out with this demonstration

00:06:52,780 --> 00:06:56,110
would it would be able to look in that

00:06:54,130 --> 00:06:57,550
box and find out what the message is but

00:06:56,110 --> 00:07:00,160
once it comes to me at the front I can

00:06:57,550 --> 00:07:03,280
use my key to unlock the padlock padlock

00:07:00,160 --> 00:07:07,600
off the box and read the message it's

00:07:03,280 --> 00:07:12,610
kind of similar concept how asymmetric

00:07:07,600 --> 00:07:15,160
cryptography works so one of the

00:07:12,610 --> 00:07:18,610
original asymmetric algorithms

00:07:15,160 --> 00:07:20,470
you've probably heard of RSA now this

00:07:18,610 --> 00:07:22,930
algorithm relied on the difficulty in

00:07:20,470 --> 00:07:25,150
reversing multiplication in modular

00:07:22,930 --> 00:07:26,470
arithmetic to construct a function which

00:07:25,150 --> 00:07:28,780
was really easy to compute in one

00:07:26,470 --> 00:07:30,130
direction but really hard to compute in

00:07:28,780 --> 00:07:33,850
the other direction really hard to undo

00:07:30,130 --> 00:07:35,830
the function however you could make it

00:07:33,850 --> 00:07:38,470
much easier to reverse that computation

00:07:35,830 --> 00:07:42,060
if you had a secret piece of knowledge

00:07:38,470 --> 00:07:44,320
that you computed upfront now RSA is

00:07:42,060 --> 00:07:46,540
quite an old algorithm and it's a bit

00:07:44,320 --> 00:07:48,490
out of date now both advances in

00:07:46,540 --> 00:07:50,020
mathematical theory and in computational

00:07:48,490 --> 00:07:52,390
power I've meant that in order to be

00:07:50,020 --> 00:07:56,400
secure today you need to use quite large

00:07:52,390 --> 00:07:57,550
keys with RSA generally between 2048 and

00:07:56,400 --> 00:08:00,610
00:07:57,550 --> 00:08:03,100
bit keys obviously when you're dealing

00:08:00,610 --> 00:08:05,080
with fairly large size of encryption

00:08:03,100 --> 00:08:07,030
keys it requires quite a bit of

00:08:05,080 --> 00:08:10,270
processing power to try to compute the

00:08:07,030 --> 00:08:11,890
encryptions whereas that's probably not

00:08:10,270 --> 00:08:12,220
a problem on a really powerful laptop

00:08:11,890 --> 00:08:14,590
like this

00:08:12,220 --> 00:08:16,330
the MacBooks and other development

00:08:14,590 --> 00:08:18,280
laptops you've got if you're thinking

00:08:16,330 --> 00:08:20,920
about small embedded internet of things

00:08:18,280 --> 00:08:23,980
devices which have running on battery

00:08:20,920 --> 00:08:25,120
power and they have limited processing

00:08:23,980 --> 00:08:27,870
they want to do as little work as

00:08:25,120 --> 00:08:30,160
possible while still remaining secure

00:08:27,870 --> 00:08:32,290
now this is where elliptic curves can

00:08:30,160 --> 00:08:35,110
come in live to curve cryptography is

00:08:32,290 --> 00:08:38,260
much more much more modern more advanced

00:08:35,110 --> 00:08:40,210
and it's it's based on a different

00:08:38,260 --> 00:08:43,720
mathematical problem which is much

00:08:40,210 --> 00:08:46,020
harder to reverse we can therefore get

00:08:43,720 --> 00:08:49,860
away with much shorter keys

00:08:46,020 --> 00:08:51,380
a 224 bit elliptic curve key can provide

00:08:49,860 --> 00:08:56,580
a similar level of security as a

00:08:51,380 --> 00:08:58,410
2048-bit or a psyche so one of the first

00:08:56,580 --> 00:09:00,480
we're going to look at today is how

00:08:58,410 --> 00:09:05,640
elliptic curve cryptography actually

00:09:00,480 --> 00:09:10,709
works so what exactly is an elliptic

00:09:05,640 --> 00:09:13,649
curve basically it's an equation a

00:09:10,709 --> 00:09:15,420
mathematical equation they always take a

00:09:13,649 --> 00:09:18,450
similar form to this where you have a

00:09:15,420 --> 00:09:21,089
wide squared term on one side and an X

00:09:18,450 --> 00:09:23,339
cubed term and some other X terms on the

00:09:21,089 --> 00:09:26,850
right-hand side obviously that's quite

00:09:23,339 --> 00:09:29,370
mathematical and and abstract that is an

00:09:26,850 --> 00:09:33,600
example equation which is used for the

00:09:29,370 --> 00:09:35,339
curve 255 1/9 that's what libel sodium

00:09:33,600 --> 00:09:37,350
uses under the hood for its elliptic

00:09:35,339 --> 00:09:39,089
curve cryptography you don't need to

00:09:37,350 --> 00:09:40,740
remember that equation at all - Timm

00:09:39,089 --> 00:09:44,970
fluent it but that's that's kind of what

00:09:40,740 --> 00:09:47,790
it looks like probably easier is to

00:09:44,970 --> 00:09:53,310
ignore the equations and think of it

00:09:47,790 --> 00:09:55,940
it's visual form a curve on a graph now

00:09:53,310 --> 00:09:57,899
a few interesting points to know

00:09:55,940 --> 00:10:03,029
elliptic curve always has this sort of

00:09:57,899 --> 00:10:04,290
general kinked format and so else that's

00:10:03,029 --> 00:10:06,870
interesting about is it's always

00:10:04,290 --> 00:10:08,250
symmetrical around the x-axis this is

00:10:06,870 --> 00:10:09,930
really important property in the curve

00:10:08,250 --> 00:10:13,079
and then what we actually use to compute

00:10:09,930 --> 00:10:16,020
functions on it now if we would actually

00:10:13,079 --> 00:10:17,370
want to actually build the crypto system

00:10:16,020 --> 00:10:20,250
we need to define some basic

00:10:17,370 --> 00:10:24,420
mathematical functions the first one we

00:10:20,250 --> 00:10:28,620
define is called the dot function now

00:10:24,420 --> 00:10:30,899
this relies on that realizing that

00:10:28,620 --> 00:10:33,990
symmetry but also another really

00:10:30,899 --> 00:10:37,440
interesting property of two curves if

00:10:33,990 --> 00:10:39,450
you take two points P and Q on a curve

00:10:37,440 --> 00:10:41,630
any elliptic curve which which matches

00:10:39,450 --> 00:10:44,029
that equation from the first slide and

00:10:41,630 --> 00:10:47,220
you draw a straight line between them

00:10:44,029 --> 00:10:50,820
that's a straight line here it will

00:10:47,220 --> 00:10:52,980
intersect the curve in exactly one of

00:10:50,820 --> 00:10:55,620
the place so straight line drawn through

00:10:52,980 --> 00:10:57,810
two points on a curve will hit the curve

00:10:55,620 --> 00:11:00,449
exactly once more somewhere

00:10:57,810 --> 00:11:02,279
it might be a long way off but you can

00:11:00,449 --> 00:11:04,259
guarantee that if you extend that line

00:11:02,279 --> 00:11:08,220
to infinity in both directions it will

00:11:04,259 --> 00:11:10,439
hit the curve game once the dot function

00:11:08,220 --> 00:11:13,170
is based on this act of finding that

00:11:10,439 --> 00:11:18,300
intersection point and then reflecting

00:11:13,170 --> 00:11:22,230
it in the x-axis so if I said to you I

00:11:18,300 --> 00:11:24,120
wanted to compute P dot P dot Q you

00:11:22,230 --> 00:11:27,149
would draw this straight line find the

00:11:24,120 --> 00:11:29,910
point and reflecting the x-axis and the

00:11:27,149 --> 00:11:35,579
result of P dot Q is that point are down

00:11:29,910 --> 00:11:37,740
the bottom if we take this function an

00:11:35,579 --> 00:11:40,769
elliptic curve as being similar to an

00:11:37,740 --> 00:11:42,769
addition function with normal numbers we

00:11:40,769 --> 00:11:44,879
can start to find by defining a

00:11:42,769 --> 00:11:48,480
multiplication function through repeated

00:11:44,879 --> 00:11:51,420
usage of this so we could multiply P by

00:11:48,480 --> 00:11:53,879
Q and get R and then we do it again and

00:11:51,420 --> 00:11:57,089
multiply P by R to get another value and

00:11:53,879 --> 00:12:00,449
that'll be multiplication that's sort of

00:11:57,089 --> 00:12:01,740
works bit like this to apply the dot

00:12:00,449 --> 00:12:04,189
function to a single point we've

00:12:01,740 --> 00:12:06,240
obviously done this I've gone here

00:12:04,189 --> 00:12:08,100
reflected it got this another point and

00:12:06,240 --> 00:12:11,610
we drew another line we get the

00:12:08,100 --> 00:12:14,370
intersection point and that becomes so

00:12:11,610 --> 00:12:15,750
we've submitted he applied that that

00:12:14,370 --> 00:12:18,480
mathematical operation and we've got

00:12:15,750 --> 00:12:24,660
multiplication so effective done as a

00:12:18,480 --> 00:12:25,829
three dot there now this function has is

00:12:24,660 --> 00:12:29,550
the basis of elliptic curve cryptography

00:12:25,829 --> 00:12:31,980
because it has a really really useful

00:12:29,550 --> 00:12:34,470
thing about it is that if I give you

00:12:31,980 --> 00:12:36,089
this point and this point and tell you

00:12:34,470 --> 00:12:39,839
that I've applied the dot function to it

00:12:36,089 --> 00:12:42,139
a number of times it is really hard to

00:12:39,839 --> 00:12:44,429
compute how many times I've done it

00:12:42,139 --> 00:12:46,350
reversing that modification without

00:12:44,429 --> 00:12:48,179
knowing how many times the dot functions

00:12:46,350 --> 00:12:50,399
and applied it is computationally very

00:12:48,179 --> 00:12:55,740
difficult and this forms the basis of my

00:12:50,399 --> 00:12:56,759
crypto system now obviously the diagram

00:12:55,740 --> 00:12:58,160
from the previous slide is a really good

00:12:56,759 --> 00:13:00,959
way of visualizing an elliptic curve

00:12:58,160 --> 00:13:04,230
however it's not quite how we use them

00:13:00,959 --> 00:13:07,439
in practice to get a representation that

00:13:04,230 --> 00:13:09,449
is is useful for cryptography we

00:13:07,439 --> 00:13:10,900
restrict the points on the curve to just

00:13:09,449 --> 00:13:13,750
the integer values so

00:13:10,900 --> 00:13:15,339
obviously curve is a continuous line but

00:13:13,750 --> 00:13:17,350
we break it off and we say only the ones

00:13:15,339 --> 00:13:22,360
that are whole numbers are what we're

00:13:17,350 --> 00:13:24,160
gonna use and we also don't want a curve

00:13:22,360 --> 00:13:27,040
that extends off to infinity in every

00:13:24,160 --> 00:13:28,690
direction because computers have slight

00:13:27,040 --> 00:13:30,370
problems dealing with numbers that are

00:13:28,690 --> 00:13:32,650
infinitely large they're much better at

00:13:30,370 --> 00:13:36,279
working on consigned confined space of

00:13:32,650 --> 00:13:38,650
numbers so what we also do is we we

00:13:36,279 --> 00:13:39,730
apply modulus function to the curve and

00:13:38,650 --> 00:13:41,320
we say okay we're going to draw the

00:13:39,730 --> 00:13:43,000
curve and when it hits the edge of our

00:13:41,320 --> 00:13:44,860
boundary when it hits a particular upper

00:13:43,000 --> 00:13:47,860
bound we're going to just reflect it

00:13:44,860 --> 00:13:51,100
around wrap it around okay so you curve

00:13:47,860 --> 00:13:52,660
just wraps around and continues and what

00:13:51,100 --> 00:13:53,560
you end up if you plot this result is

00:13:52,660 --> 00:13:55,529
something that looks a bit like this

00:13:53,560 --> 00:13:58,330
graph and you just have all these points

00:13:55,529 --> 00:14:03,250
which are a curve restricted to that

00:13:58,330 --> 00:14:06,250
that modular space however if you do

00:14:03,250 --> 00:14:07,900
this all those previous functions the

00:14:06,250 --> 00:14:10,990
dot function the multiplication they

00:14:07,900 --> 00:14:12,160
still work provided that you also wrap

00:14:10,990 --> 00:14:13,150
around when you're when you're drawing

00:14:12,160 --> 00:14:15,070
your line between the two points

00:14:13,150 --> 00:14:16,930
providing you also wrap that round when

00:14:15,070 --> 00:14:18,520
it hits the edge it continues to work

00:14:16,930 --> 00:14:21,130
and it'll continue to eventually land on

00:14:18,520 --> 00:14:23,110
land on a point and we can compute these

00:14:21,130 --> 00:14:25,270
these computations quite quite quickly

00:14:23,110 --> 00:14:27,640
quite efficiently and that's that's how

00:14:25,270 --> 00:14:31,890
we base it once I do that that's a curve

00:14:27,640 --> 00:14:35,410
cryptography so once you've got a curve

00:14:31,890 --> 00:14:37,959
like all in the previous slide in order

00:14:35,410 --> 00:14:41,560
to to actually do a key exchange using

00:14:37,959 --> 00:14:43,560
it you and your new communications

00:14:41,560 --> 00:14:46,240
partner would have to agree upon a

00:14:43,560 --> 00:14:50,800
particular curve pick take the curve

00:14:46,240 --> 00:14:53,830
equation probably wanna pick p25 255 1/9

00:14:50,800 --> 00:14:55,450
put us in Lib sodium and you need to

00:14:53,830 --> 00:14:58,209
pick a point on that curve that's called

00:14:55,450 --> 00:15:00,400
a generator point and obviously the

00:14:58,209 --> 00:15:04,870
modulus for the the curve what point you

00:15:00,400 --> 00:15:09,550
wrap around out then what we need to do

00:15:04,870 --> 00:15:11,520
is select a random integer D and then we

00:15:09,550 --> 00:15:16,000
compute a point on the curve that is the

00:15:11,520 --> 00:15:19,420
result of multiplying G by P D times so

00:15:16,000 --> 00:15:20,650
you compute another point yeah so you

00:15:19,420 --> 00:15:25,140
apply that dot function over and over

00:15:20,650 --> 00:15:25,140
again based on the number you've picked

00:15:25,310 --> 00:15:31,320
we can then exchange the public keys

00:15:29,670 --> 00:15:34,680
which is the point that you've generated

00:15:31,320 --> 00:15:37,500
based on that D value so Alice has

00:15:34,680 --> 00:15:41,430
picked a a D value a random computed the

00:15:37,500 --> 00:15:42,570
P point for that that integer Bob has

00:15:41,430 --> 00:15:43,650
done the same they've both got a

00:15:42,570 --> 00:15:45,120
different value they've got a different

00:15:43,650 --> 00:15:51,150
point on the curve they swapped them

00:15:45,120 --> 00:15:53,220
over at that point Alice takes her D

00:15:51,150 --> 00:15:54,810
point and continues multiplying

00:15:53,220 --> 00:15:55,560
continues a dot function from the point

00:15:54,810 --> 00:15:58,680
that Bob gave her

00:15:55,560 --> 00:16:00,840
Bob does the same and just like

00:15:58,680 --> 00:16:03,240
multiplication in in normal mathematics

00:16:00,840 --> 00:16:05,130
if you multiply two by three and three

00:16:03,240 --> 00:16:06,810
by two you get the same result if you

00:16:05,130 --> 00:16:08,130
don't elliptic curve apply the dot

00:16:06,810 --> 00:16:10,980
function you get the same result

00:16:08,130 --> 00:16:12,180
so if you take Bob's random number

00:16:10,980 --> 00:16:14,370
Alice's random number

00:16:12,180 --> 00:16:16,290
apply them both to the same generator

00:16:14,370 --> 00:16:19,470
point you'll get the same point

00:16:16,290 --> 00:16:20,640
they've computed a shared secret which

00:16:19,470 --> 00:16:22,920
no one else who's part of that

00:16:20,640 --> 00:16:25,380
communication can do because they don't

00:16:22,920 --> 00:16:27,950
know the secret D values that they they

00:16:25,380 --> 00:16:30,450
generated at the start of the protocol

00:16:27,950 --> 00:16:31,980
so both parties now have this this

00:16:30,450 --> 00:16:35,610
shared secret the shared point on the

00:16:31,980 --> 00:16:40,590
curve and then we can use that as a

00:16:35,610 --> 00:16:44,640
basis for actually encrypting data that

00:16:40,590 --> 00:16:46,680
kind of works like this we've got a bit

00:16:44,640 --> 00:16:49,980
bit more visual for people learn better

00:16:46,680 --> 00:16:51,990
visually Alice generates her point it

00:16:49,980 --> 00:16:56,130
generates a random integer a Bob does

00:16:51,990 --> 00:16:59,130
the same they calculate a times their

00:16:56,130 --> 00:17:00,900
generator point swap them over and then

00:16:59,130 --> 00:17:07,410
do it again to calculate their shared

00:17:00,900 --> 00:17:10,740
secret okay now our protocol as it

00:17:07,410 --> 00:17:14,340
stands does have a slight flaw if Alice

00:17:10,740 --> 00:17:16,320
and Bob are unable to to exchange public

00:17:14,340 --> 00:17:19,800
keys in a secure manner eg in person

00:17:16,320 --> 00:17:23,570
then it's possible that a attacker a

00:17:19,800 --> 00:17:27,020
third party could get in the middle and

00:17:23,570 --> 00:17:30,120
intercept their key exchange protocol

00:17:27,020 --> 00:17:33,720
how this could happen is if we've got

00:17:30,120 --> 00:17:35,220
our attacker here Eve gets in between

00:17:33,720 --> 00:17:36,450
the communications intercepts that

00:17:35,220 --> 00:17:39,029
network connection

00:17:36,450 --> 00:17:40,440
between Alice and Bob she knows she

00:17:39,029 --> 00:17:43,200
performed the key exchange protocol

00:17:40,440 --> 00:17:45,210
separately with Alice and separately is

00:17:43,200 --> 00:17:48,570
Bob pretending to be each of them to

00:17:45,210 --> 00:17:50,490
each other okay and then Eve can

00:17:48,570 --> 00:17:52,019
calculate these two shared secrets and

00:17:50,490 --> 00:17:54,990
then when Alice sends a message to Bob

00:17:52,019 --> 00:17:57,929
Eve can decrypt it using the shared

00:17:54,990 --> 00:17:59,789
secret that she's generated I'm sort of

00:17:57,929 --> 00:18:01,320
on the down low with with Alice

00:17:59,789 --> 00:18:03,330
ari encrypt it with the shared secret

00:18:01,320 --> 00:18:09,260
she's generated with Bob but retain a

00:18:03,330 --> 00:18:09,260
copy the plain text of that message now

00:18:09,799 --> 00:18:14,070
that problem we've sort of touched upon

00:18:12,210 --> 00:18:15,630
is it's coming on to the next topic I'm

00:18:14,070 --> 00:18:17,929
gonna cover in this in this talk which

00:18:15,630 --> 00:18:21,950
is a web of trust

00:18:17,929 --> 00:18:24,570
how can Bob trust that a public key that

00:18:21,950 --> 00:18:27,149
he thinks might belong to Alice actually

00:18:24,570 --> 00:18:28,889
does unless unless actually meet in

00:18:27,149 --> 00:18:31,409
person unless he got sort of confident

00:18:28,889 --> 00:18:33,240
say hey here's my private key it's my

00:18:31,409 --> 00:18:35,190
public key you can use that to contact

00:18:33,240 --> 00:18:37,289
me securely you know you can look at my

00:18:35,190 --> 00:18:39,419
delegate batch you know I'm Chris I can

00:18:37,289 --> 00:18:41,159
give you my key and say okay you can now

00:18:39,419 --> 00:18:42,809
use that you trust that it's me because

00:18:41,159 --> 00:18:44,669
we've met in person exchange those keys

00:18:42,809 --> 00:18:49,019
if we doing that over an unsecured

00:18:44,669 --> 00:18:50,639
channel over the Internet how do you how

00:18:49,019 --> 00:18:53,519
do you make sure that that's that's been

00:18:50,639 --> 00:18:56,130
done correctly one option we might

00:18:53,519 --> 00:18:57,990
decide to go with is just trust that

00:18:56,130 --> 00:18:59,399
that our initial communication was

00:18:57,990 --> 00:19:01,679
actually secure and nobody got in the

00:18:59,399 --> 00:19:02,850
middle of it you know it's fairly

00:19:01,679 --> 00:19:03,779
unlikely that someone's gonna be

00:19:02,850 --> 00:19:05,399
sniffing your connection and

00:19:03,779 --> 00:19:09,840
deliberately man in the middling your

00:19:05,399 --> 00:19:12,570
connections so that might be an option

00:19:09,840 --> 00:19:14,070
we take ssh often uses this if you if

00:19:12,570 --> 00:19:16,320
you notice when you SSH into a server

00:19:14,070 --> 00:19:19,880
and it says hey this Keys not recognized

00:19:16,320 --> 00:19:22,860
do you trust it and you always go yes

00:19:19,880 --> 00:19:25,409
that's basically how it's working it's a

00:19:22,860 --> 00:19:27,750
policy of trust on first use but if you

00:19:25,409 --> 00:19:29,340
also notice if you've a regenerates the

00:19:27,750 --> 00:19:30,630
keys on your license a server that

00:19:29,340 --> 00:19:32,070
you've locked into you'll get this

00:19:30,630 --> 00:19:34,860
really big banner message that says your

00:19:32,070 --> 00:19:36,600
keys have changed and it refused to let

00:19:34,860 --> 00:19:37,850
you connect until you use their actually

00:19:36,600 --> 00:19:42,450
I know about that I change them

00:19:37,850 --> 00:19:44,399
deliberately it's okay so so that trust

00:19:42,450 --> 00:19:45,510
on first use policy means that you get a

00:19:44,399 --> 00:19:46,679
warning if someone tries to

00:19:45,510 --> 00:19:50,059
man-in-the-middle your connection after

00:19:46,679 --> 00:19:50,059
you've set it up for the first time

00:19:50,169 --> 00:19:58,460
but we can also do it in a different way

00:19:52,580 --> 00:20:00,020
so with without symmetric asymmetric

00:19:58,460 --> 00:20:03,070
ciphers we can compute these shared

00:20:00,020 --> 00:20:06,320
secrets even over an insecure Channel

00:20:03,070 --> 00:20:08,929
but obviously we're still open to that

00:20:06,320 --> 00:20:10,640
man in the middle attack problem well

00:20:08,929 --> 00:20:12,440
what they can do even if you've not met

00:20:10,640 --> 00:20:16,309
in person if you have a trusted third

00:20:12,440 --> 00:20:21,020
party let's call him Trent very trusted

00:20:16,309 --> 00:20:22,789
person very very trustworthy and Alice

00:20:21,020 --> 00:20:24,620
knows Trent personally no they've been

00:20:22,789 --> 00:20:26,270
to conferences together they said you

00:20:24,620 --> 00:20:28,940
know they know each other she trusts him

00:20:26,270 --> 00:20:30,440
and and Trent's also flown over to

00:20:28,940 --> 00:20:33,260
America to call the talks over there and

00:20:30,440 --> 00:20:37,130
he's mad he's mad Bob in person and he

00:20:33,260 --> 00:20:39,500
has bob's key what Trent can do is he

00:20:37,130 --> 00:20:41,510
can say well okay Alice I know you've

00:20:39,500 --> 00:20:45,140
not met Bob personally I can I can vouch

00:20:41,510 --> 00:20:46,610
for him I can say hey this is this is

00:20:45,140 --> 00:20:49,010
Bob's public key he gave it to me

00:20:46,610 --> 00:20:50,720
personally and when he actually flies

00:20:49,010 --> 00:20:53,419
over to her to America you can say okay

00:20:50,720 --> 00:20:56,000
Bob I've met Alice personally this is

00:20:53,419 --> 00:20:58,039
her key and he can sign that key with

00:20:56,000 --> 00:20:59,809
his keys and that means that you can you

00:20:58,039 --> 00:21:03,020
can do that process even if you don't

00:20:59,809 --> 00:21:04,700
meet in person so let's go say okay

00:21:03,020 --> 00:21:06,289
you've got my key can you can you sign a

00:21:04,700 --> 00:21:08,870
message and say hey this is my key and

00:21:06,289 --> 00:21:10,549
send it to Bob and then Bob can trust it

00:21:08,870 --> 00:21:11,289
provided he trusts Trent which I'm sure

00:21:10,549 --> 00:21:14,030
he does

00:21:11,289 --> 00:21:16,309
he can trust that key is a key Alice's

00:21:14,030 --> 00:21:18,230
and that starts to start how you build

00:21:16,309 --> 00:21:20,570
up this this both trust Chloe see if

00:21:18,230 --> 00:21:22,909
Alice then needs to be introduced to our

00:21:20,570 --> 00:21:24,620
Bob's contacts Bob can say okay well I'm

00:21:22,909 --> 00:21:27,710
going to sign the public key of of my

00:21:24,620 --> 00:21:30,770
friend Craig and and send it over to you

00:21:27,710 --> 00:21:36,010
Alice now Alice can trust again provide

00:21:30,770 --> 00:21:37,880
the she trusts Bob the crate is crate so

00:21:36,010 --> 00:21:41,750
question is can you trust

00:21:37,880 --> 00:21:43,880
however trust well yes this is exactly

00:21:41,750 --> 00:21:46,549
how our sort of entire public

00:21:43,880 --> 00:21:48,530
infrastructure works at the moment when

00:21:46,549 --> 00:21:51,770
you go onto a website it presents you

00:21:48,530 --> 00:21:54,289
with a an SSL certificate which says you

00:21:51,770 --> 00:21:56,059
know this this depending on how much

00:21:54,289 --> 00:21:57,919
they paid for their certificate it might

00:21:56,059 --> 00:21:59,299
say that it's a particular company or it

00:21:57,919 --> 00:22:01,150
might just say it belongs to a

00:21:59,299 --> 00:22:03,190
particular domain

00:22:01,150 --> 00:22:07,320
and that certificate will come with the

00:22:03,190 --> 00:22:09,640
signature from a key issuing authority

00:22:07,320 --> 00:22:11,230
like let's encrypt or one of the ones

00:22:09,640 --> 00:22:12,880
you have to pay for and what they will

00:22:11,230 --> 00:22:14,710
do is they will they will do some sort

00:22:12,880 --> 00:22:16,480
of test to make sure that the person is

00:22:14,710 --> 00:22:18,370
either who they say they are or that

00:22:16,480 --> 00:22:20,850
they they have control over that domain

00:22:18,370 --> 00:22:23,950
let's encrypt all this automatically

00:22:20,850 --> 00:22:28,720
gives you a challenge so if you own the

00:22:23,950 --> 00:22:31,420
domain cryptography comm you you can set

00:22:28,720 --> 00:22:33,190
up a challenge for a particular file on

00:22:31,420 --> 00:22:34,870
your web server let's encrypt we'll go

00:22:33,190 --> 00:22:36,790
and verify that automatically and it'll

00:22:34,870 --> 00:22:39,520
issue you an SSL certificate which it

00:22:36,790 --> 00:22:42,850
signs with its key and says yes I have

00:22:39,520 --> 00:22:45,400
verified that this public key belongs to

00:22:42,850 --> 00:22:47,170
cryptography calm when a user then goes

00:22:45,400 --> 00:22:48,940
in their browser and loads that

00:22:47,170 --> 00:22:52,210
certificate up their browser is

00:22:48,940 --> 00:22:53,800
preloaded with with certificates keys

00:22:52,210 --> 00:22:55,600
from sort of major certificate

00:22:53,800 --> 00:22:56,820
authorities and they can verify the

00:22:55,600 --> 00:22:59,980
signature from the certificate authority

00:22:56,820 --> 00:23:02,260
that's issued that key and say yes okay

00:22:59,980 --> 00:23:03,760
that SSL certificate is trustworthy it

00:23:02,260 --> 00:23:06,670
does belong to that website we can trust

00:23:03,760 --> 00:23:09,250
it and that's exactly how everything

00:23:06,670 --> 00:23:13,960
works so yeah you really do need to

00:23:09,250 --> 00:23:17,320
trust this web of trust okay so next

00:23:13,960 --> 00:23:18,970
topic we now move on to is a slightly

00:23:17,320 --> 00:23:19,890
different one to have a look at the hash

00:23:18,970 --> 00:23:22,780
functions

00:23:19,890 --> 00:23:23,679
so hash function is a really really

00:23:22,780 --> 00:23:27,850
important part of modern-day

00:23:23,679 --> 00:23:29,830
cryptography the main use is for

00:23:27,850 --> 00:23:33,550
protecting the integrity of data as part

00:23:29,830 --> 00:23:36,280
of H max key or combining the digital

00:23:33,550 --> 00:23:38,830
signature from a symmetric algorithm but

00:23:36,280 --> 00:23:41,500
another use of hash functions is to

00:23:38,830 --> 00:23:43,300
derive encryption keys from user

00:23:41,500 --> 00:23:45,429
provided passwords if you take a

00:23:43,300 --> 00:23:47,860
password from the user and you pass it

00:23:45,429 --> 00:23:50,440
through the sha-256 I've lots and lots

00:23:47,860 --> 00:23:52,960
of times you can derive a strong random

00:23:50,440 --> 00:23:54,880
ish encryption key which you can then

00:23:52,960 --> 00:23:56,320
use to encrypt some data that's how a

00:23:54,880 --> 00:23:57,940
lot of the like the password protected

00:23:56,320 --> 00:23:59,740
zip files and things like that they all

00:23:57,940 --> 00:24:01,120
do that they derive a key using a I use

00:23:59,740 --> 00:24:02,679
a hash function from the password you

00:24:01,120 --> 00:24:03,370
provide they don't actually use the

00:24:02,679 --> 00:24:07,300
password as a

00:24:03,370 --> 00:24:09,160
encryption key I'm gonna take a look at

00:24:07,300 --> 00:24:13,810
what what our hash function actually

00:24:09,160 --> 00:24:14,620
needs to do an ideal hash function has a

00:24:13,810 --> 00:24:16,509
few properties

00:24:14,620 --> 00:24:19,570
the first of which is it should be quick

00:24:16,509 --> 00:24:23,139
and easy to compute a hash for any given

00:24:19,570 --> 00:24:24,610
piece of data if I give you a file it

00:24:23,139 --> 00:24:26,019
shouldn't take you months and months of

00:24:24,610 --> 00:24:27,159
computational activity to compute its

00:24:26,019 --> 00:24:28,929
hash it should be really fast it's

00:24:27,159 --> 00:24:33,399
really quick you need to do it a lot and

00:24:28,929 --> 00:24:35,409
you do use a verification the one

00:24:33,399 --> 00:24:36,789
exception to this of course is if you

00:24:35,409 --> 00:24:38,769
using hash functions for protecting

00:24:36,789 --> 00:24:40,600
passwords they need to be really slow

00:24:38,769 --> 00:24:44,080
because you don't want people to just

00:24:40,600 --> 00:24:46,090
brute-force the hash but but the most

00:24:44,080 --> 00:24:50,080
uses for verifying data you need to be

00:24:46,090 --> 00:24:52,899
quick it should also be really difficult

00:24:50,080 --> 00:24:57,549
to compute a piece of data the hashes to

00:24:52,899 --> 00:24:59,110
a given value for most functions the

00:24:57,549 --> 00:25:01,779
fastest way of doing it is by brute

00:24:59,110 --> 00:25:03,490
force if you want to have a char - five

00:25:01,779 --> 00:25:05,950
six hash that spells out something funny

00:25:03,490 --> 00:25:07,029
and you'll get commits you're going to

00:25:05,950 --> 00:25:08,769
have to sit there and brute-force

00:25:07,029 --> 00:25:10,210
different commit messages over and over

00:25:08,769 --> 00:25:13,749
and over again until you actually get

00:25:10,210 --> 00:25:15,399
the hash that you want there are

00:25:13,749 --> 00:25:17,740
actually some tools out there little -

00:25:15,399 --> 00:25:19,980
you tweet you'll get commit messages to

00:25:17,740 --> 00:25:23,830
give you a prefix on your commit hashes

00:25:19,980 --> 00:25:24,909
they're quite fun to play with but it's

00:25:23,830 --> 00:25:26,590
really difficult to do you could have

00:25:24,909 --> 00:25:28,320
brute force you would have changed

00:25:26,590 --> 00:25:31,450
things over and over and over again and

00:25:28,320 --> 00:25:32,740
that that's a much more computation

00:25:31,450 --> 00:25:36,369
intensive than just computing the hash

00:25:32,740 --> 00:25:37,570
once and this this is actually a

00:25:36,369 --> 00:25:39,539
property of a hash function which makes

00:25:37,570 --> 00:25:42,279
them useful for the proof-of-work

00:25:39,539 --> 00:25:45,179
function which is using modern crypto

00:25:42,279 --> 00:25:47,499
currencies don't talk about that later

00:25:45,179 --> 00:25:49,419
another property that it's important for

00:25:47,499 --> 00:25:51,429
a hash function to have is it should be

00:25:49,419 --> 00:25:53,830
very unlikely that two different

00:25:51,429 --> 00:25:58,330
messages will have the same hash if I

00:25:53,830 --> 00:26:00,399
take a piece of text and I add a full

00:25:58,330 --> 00:26:02,049
stop at the end it should hash to

00:26:00,399 --> 00:26:03,820
something completely different to the

00:26:02,049 --> 00:26:05,740
original piece of text there should be a

00:26:03,820 --> 00:26:07,210
lot of change it shouldn't be obvious it

00:26:05,740 --> 00:26:08,499
should be easy to predict what the hash

00:26:07,210 --> 00:26:14,019
is going to be if I change a piece of

00:26:08,499 --> 00:26:18,820
the text there was a bit of an issue

00:26:14,019 --> 00:26:21,700
with md5 and that cryptographers worked

00:26:18,820 --> 00:26:25,360
out how you could set up a piece of data

00:26:21,700 --> 00:26:27,670
so that you could compute two pieces of

00:26:25,360 --> 00:26:30,040
data which hash to the same value

00:26:27,670 --> 00:26:32,590
this was quite bad because it meant you

00:26:30,040 --> 00:26:35,140
could Forge signatures on documents so

00:26:32,590 --> 00:26:37,960
remember the ssl certificates that we

00:26:35,140 --> 00:26:41,290
have that trusted what their researchers

00:26:37,960 --> 00:26:42,790
managed to do was create a certificate

00:26:41,290 --> 00:26:44,890
signing request and send it off to a

00:26:42,790 --> 00:26:46,360
certificate authority significant

00:26:44,890 --> 00:26:47,530
authority went okay yep fine

00:26:46,360 --> 00:26:50,170
we'll sign that we'll say it belongs to

00:26:47,530 --> 00:26:53,230
you we verified it but they had computed

00:26:50,170 --> 00:26:56,770
upfront and of the document which hashed

00:26:53,230 --> 00:26:58,870
the same value and they had the same md5

00:26:56,770 --> 00:27:00,580
hash as the signature as a certificate

00:26:58,870 --> 00:27:02,800
they had submitted which meant they

00:27:00,580 --> 00:27:04,000
switched the two over and they they got

00:27:02,800 --> 00:27:05,320
themselves a certificate which was

00:27:04,000 --> 00:27:07,930
actually trust it not just to verify

00:27:05,320 --> 00:27:11,350
their own website but to verify any

00:27:07,930 --> 00:27:13,240
website which obviously is quite quite a

00:27:11,350 --> 00:27:15,190
bad foreigner ability so they could

00:27:13,240 --> 00:27:17,620
pretend to be any website in the world

00:27:15,190 --> 00:27:21,240
and your browser would trust them that's

00:27:17,620 --> 00:27:25,000
kind of why we don't use md5 anymore

00:27:21,240 --> 00:27:26,620
yeah so we're going to take a look at

00:27:25,000 --> 00:27:27,850
not md5 because that's broken and

00:27:26,620 --> 00:27:29,920
horrible and you shouldn't be using it

00:27:27,850 --> 00:27:31,750
we're gonna look at char two which is

00:27:29,920 --> 00:27:33,130
probably one of those common hash

00:27:31,750 --> 00:27:35,770
algorithms at the moment and pour the

00:27:33,130 --> 00:27:37,300
one you've been reusing most these kind

00:27:35,770 --> 00:27:40,720
of things

00:27:37,300 --> 00:27:44,170
the sha-2 family is our whole group of

00:27:40,720 --> 00:27:47,070
algorithms which they're a call they're

00:27:44,170 --> 00:27:49,300
identical but they a very small details

00:27:47,070 --> 00:27:52,120
such as the size of the data that being

00:27:49,300 --> 00:27:54,160
worked on in one go the the starting

00:27:52,120 --> 00:27:56,220
constants of the the hash function and

00:27:54,160 --> 00:27:58,930
the length of the output so you have

00:27:56,220 --> 00:28:02,260
sha-256 which gives you 256 the output

00:27:58,930 --> 00:28:03,820
you can have sha-512 which is a 512

00:28:02,260 --> 00:28:06,030
output and there are few of the ways you

00:28:03,820 --> 00:28:09,280
can configure it where you get like a

00:28:06,030 --> 00:28:12,460
sha-256 / 512 which is the first 256

00:28:09,280 --> 00:28:14,170
bits which are 512 output and there's

00:28:12,460 --> 00:28:15,310
those little bit various combinations

00:28:14,170 --> 00:28:22,710
that you can use depending on what you

00:28:15,310 --> 00:28:30,040
need for your use case so sha-256 works

00:28:22,710 --> 00:28:33,520
on blocks of data of 512 bits and that

00:28:30,040 --> 00:28:37,450
extends up to 1,024 bits when you move

00:28:33,520 --> 00:28:39,250
up to sha-512 so before hashing any any

00:28:37,450 --> 00:28:40,820
message we need to a bit of preparation

00:28:39,250 --> 00:28:43,250
on that message because

00:28:40,820 --> 00:28:46,789
has to work on blocks of exactly 512 or

00:28:43,250 --> 00:28:48,080
102 4 bits so what we do is we take the

00:28:46,789 --> 00:28:50,990
piece of data that you want to hash and

00:28:48,080 --> 00:28:53,990
we append a single single one bit to the

00:28:50,990 --> 00:28:57,710
data this is sort of marker

00:28:53,990 --> 00:28:59,419
we then pad the data out with zeros

00:28:57,710 --> 00:29:02,000
until the total length of the piece of

00:28:59,419 --> 00:29:05,419
data that you want to hash is 64 bits

00:29:02,000 --> 00:29:08,840
less than the next multiple of 512

00:29:05,419 --> 00:29:10,580
and then finally a 64-bit integer

00:29:08,840 --> 00:29:12,980
representing the length the data as a

00:29:10,580 --> 00:29:15,019
whole is appended so then you've got a

00:29:12,980 --> 00:29:19,240
piece of data that is exactly a multiple

00:29:15,019 --> 00:29:24,379
of 512 or 102 four bits long

00:29:19,240 --> 00:29:26,509
acquaintances taking this photo the next

00:29:24,379 --> 00:29:30,110
thing that we need to do is we split

00:29:26,509 --> 00:29:33,950
that message up into the 512 bit or 102

00:29:30,110 --> 00:29:36,080
4 bit blocks we need to work on and then

00:29:33,950 --> 00:29:38,419
there's a preparation phase which

00:29:36,080 --> 00:29:39,289
expands that data route to two hundred

00:29:38,419 --> 00:29:42,860
and forty eight bits

00:29:39,289 --> 00:29:45,350
now it does this by taking the original

00:29:42,860 --> 00:29:47,240
data shifting it by a set amount and

00:29:45,350 --> 00:29:50,419
then X luring it back with the original

00:29:47,240 --> 00:29:52,789
original block and appending it so you

00:29:50,419 --> 00:29:54,590
still get four copies where you sort of

00:29:52,789 --> 00:29:58,190
shifted and rotate it and XOR it

00:29:54,590 --> 00:29:59,269
together and then it goes into a

00:29:58,190 --> 00:30:04,159
function that looks a bit like this

00:29:59,269 --> 00:30:06,590
maybe looks a bit complicated but it's

00:30:04,159 --> 00:30:08,210
it's actually quite simple it's it's

00:30:06,590 --> 00:30:10,039
called a prescient function and it works

00:30:08,210 --> 00:30:12,860
individually on each block of data one

00:30:10,039 --> 00:30:15,409
at a time you have these eight registers

00:30:12,860 --> 00:30:17,539
at the top which are the first time

00:30:15,409 --> 00:30:19,730
you're the first block of the hash it

00:30:17,539 --> 00:30:21,710
initializes them to some set constants

00:30:19,730 --> 00:30:23,120
now these are sort of like magic nothing

00:30:21,710 --> 00:30:26,480
up my sleeve numbers so it generated

00:30:23,120 --> 00:30:28,759
from the Merrit various mathematical

00:30:26,480 --> 00:30:31,820
constants and they're designed to make

00:30:28,759 --> 00:30:33,529
sure that there's no accusation that the

00:30:31,820 --> 00:30:36,169
hash has been deliberately sort of

00:30:33,529 --> 00:30:38,029
tampered with by a by by a third-party

00:30:36,169 --> 00:30:42,289
and to make make sure that it's actually

00:30:38,029 --> 00:30:44,570
secure on subsequent blocks it those

00:30:42,289 --> 00:30:49,610
ones are initialized with the the output

00:30:44,570 --> 00:30:53,000
of the previous block then we take our

00:30:49,610 --> 00:30:54,230
children 48 bit expanded state and we

00:30:53,000 --> 00:30:58,130
iterate just four

00:30:54,230 --> 00:31:01,130
so we've got those registers we applied

00:30:58,130 --> 00:31:06,799
these Excel functions down the side we

00:31:01,130 --> 00:31:11,840
mix in one 64-bit word sorry 32-bit word

00:31:06,799 --> 00:31:15,410
64 32-bit words in 248 bit to mix that

00:31:11,840 --> 00:31:17,720
in throw X or mix these things through

00:31:15,410 --> 00:31:20,480
shift them all right by one and that

00:31:17,720 --> 00:31:23,480
drops into the a this state then becomes

00:31:20,480 --> 00:31:27,140
the the starting state over here for the

00:31:23,480 --> 00:31:29,630
next 32 bits and you keep on going you

00:31:27,140 --> 00:31:31,880
iterate through do that entirely for one

00:31:29,630 --> 00:31:34,070
block and then you move on to the next

00:31:31,880 --> 00:31:35,690
block you keep on going keep on going

00:31:34,070 --> 00:31:37,340
iterating this function over and over

00:31:35,690 --> 00:31:39,320
and over again until you've done all the

00:31:37,340 --> 00:31:42,559
blocks of data in your your function and

00:31:39,320 --> 00:31:46,400
then the resulting eight registers there

00:31:42,559 --> 00:31:49,010
becomes your 256 bit output hash okay

00:31:46,400 --> 00:31:53,030
that's how it it's right so over and

00:31:49,010 --> 00:31:54,799
over this function is really really hard

00:31:53,030 --> 00:31:57,500
to sort of run in Reverse because it

00:31:54,799 --> 00:31:59,330
deliberately Masha's up and loses data

00:31:57,500 --> 00:32:01,340
and these sort of functions at the side

00:31:59,330 --> 00:32:06,350
here which is what makes the hash

00:32:01,340 --> 00:32:07,460
function secure now obviously we've got

00:32:06,350 --> 00:32:11,000
a hash function a lot of things we can

00:32:07,460 --> 00:32:12,500
do with it just verifying data but

00:32:11,000 --> 00:32:14,030
there's also some interesting data

00:32:12,500 --> 00:32:16,280
structures that we can build using

00:32:14,030 --> 00:32:18,980
cryptographic hash functions one of

00:32:16,280 --> 00:32:21,860
these knowns are a Merkle tree or a hash

00:32:18,980 --> 00:32:24,320
tree you may be familiar with these

00:32:21,860 --> 00:32:27,530
structures as popular version control

00:32:24,320 --> 00:32:29,809
software like it and some file sharing

00:32:27,530 --> 00:32:31,640
programs actually like BitTorrent and

00:32:29,809 --> 00:32:35,000
things like that use them for verifying

00:32:31,640 --> 00:32:37,669
data there they're quite useful for this

00:32:35,000 --> 00:32:39,950
selective because what-what were you

00:32:37,669 --> 00:32:43,100
what you essentially do is you you build

00:32:39,950 --> 00:32:45,559
a hash and it's it's kind of strict like

00:32:43,100 --> 00:32:49,040
hey one of the options is you structure

00:32:45,559 --> 00:32:52,700
like a binary tree and each each node in

00:32:49,040 --> 00:32:55,820
the tree is labeled with the hash of its

00:32:52,700 --> 00:32:57,290
chart notes and so sorry works if you

00:32:55,820 --> 00:32:58,400
want to verify a huge file let's see

00:32:57,290 --> 00:33:00,890
you've got a big video file

00:32:58,400 --> 00:33:02,390
let's send video this talk it's up on on

00:33:00,890 --> 00:33:04,220
YouTube and you want to you want to

00:33:02,390 --> 00:33:06,650
distribute it using sums of distributed

00:33:04,220 --> 00:33:09,800
file sharing program like BitTorrent

00:33:06,650 --> 00:33:10,970
what BitTorrent will do is in order to

00:33:09,800 --> 00:33:14,210
make sure that your doubt and what your

00:33:10,970 --> 00:33:16,070
downloading is is correct when you've

00:33:14,210 --> 00:33:18,920
got it it will split the file up into

00:33:16,070 --> 00:33:21,430
loads of chunks at the bottom here it'll

00:33:18,920 --> 00:33:25,190
take a hash of each one of those chunks

00:33:21,430 --> 00:33:27,350
okay and you've got like on here we've

00:33:25,190 --> 00:33:29,240
got four chunks for hashes we've split

00:33:27,350 --> 00:33:32,510
the video into four parts of hashed each

00:33:29,240 --> 00:33:34,760
one of them we then take a hash of those

00:33:32,510 --> 00:33:37,250
two hashes appended together and we need

00:33:34,760 --> 00:33:39,530
to say on this side those and then we've

00:33:37,250 --> 00:33:41,540
got this hash at the top here which is a

00:33:39,530 --> 00:33:43,670
hash the two twos below that so we'll

00:33:41,540 --> 00:33:46,220
see that so you've got this whole tree

00:33:43,670 --> 00:33:48,740
of hashes now that means if you start

00:33:46,220 --> 00:33:51,309
downloading a chunk of the video file

00:33:48,740 --> 00:33:53,059
this one of someone asked about that and

00:33:51,309 --> 00:33:55,520
there's some one goes wrong in

00:33:53,059 --> 00:33:57,530
transmission you've not quite got all

00:33:55,520 --> 00:33:59,320
the bits in the right order the hash

00:33:57,530 --> 00:34:01,550
will fail and you've got this little

00:33:59,320 --> 00:34:03,200
fell that and you don't have to download

00:34:01,550 --> 00:34:05,570
the whole video before you work out that

00:34:03,200 --> 00:34:06,500
something's wrong with it so you can

00:34:05,570 --> 00:34:07,580
just throw away this chunk and

00:34:06,500 --> 00:34:09,470
redownload it instead of having to

00:34:07,580 --> 00:34:12,590
redownload the whole file so it's quite

00:34:09,470 --> 00:34:14,120
useful you actually tell which bit of

00:34:12,590 --> 00:34:15,860
the file is corrupted and you only have

00:34:14,120 --> 00:34:18,860
to download a really small extra chunk

00:34:15,860 --> 00:34:20,720
of it obviously this this structure is

00:34:18,860 --> 00:34:22,520
really good for a static piece of data a

00:34:20,720 --> 00:34:25,100
video for example that's not gonna

00:34:22,520 --> 00:34:26,690
change it's not very useful if you're

00:34:25,100 --> 00:34:28,940
constantly changing the data because

00:34:26,690 --> 00:34:30,500
whenever you change a piece of data here

00:34:28,940 --> 00:34:32,720
you're going to recompute this hash this

00:34:30,500 --> 00:34:33,889
hash and this hash so if every time you

00:34:32,720 --> 00:34:36,950
change a bit of data you buddy compute

00:34:33,889 --> 00:34:38,270
those hashes all the way at the top so

00:34:36,950 --> 00:34:41,450
another way we could structure a a

00:34:38,270 --> 00:34:46,240
Merkle tree is a bit like this it's a

00:34:41,450 --> 00:34:51,379
crime or a linked list type of hash tree

00:34:46,240 --> 00:34:56,690
and what we do here is we we take the

00:34:51,379 --> 00:34:58,460
first piece sort of the list and we we

00:34:56,690 --> 00:34:59,510
hash the data and that's becomes that

00:34:58,460 --> 00:35:02,330
the hash that we used for the first

00:34:59,510 --> 00:35:04,940
chunk the second chunk we take a hash

00:35:02,330 --> 00:35:07,130
the data and a hash of the previous

00:35:04,940 --> 00:35:09,050
block now this is a very similar

00:35:07,130 --> 00:35:12,140
structure to how git works when you

00:35:09,050 --> 00:35:14,750
commit something it takes the hash of

00:35:12,140 --> 00:35:17,270
the parent commits and the hash of the

00:35:14,750 --> 00:35:19,130
commit message and the files you've

00:35:17,270 --> 00:35:19,690
committed hashes that all together and

00:35:19,130 --> 00:35:22,950
that

00:35:19,690 --> 00:35:22,950
come to commit hash for your new commit

00:35:23,280 --> 00:35:27,880
apparently you you can also use this

00:35:25,450 --> 00:35:30,160
structure as the basis for a currency I

00:35:27,880 --> 00:35:31,270
mean I'm not expecting many people in

00:35:30,160 --> 00:35:33,839
the room to have heard of this but

00:35:31,270 --> 00:35:38,349
happens with you've heard of Bitcoin a

00:35:33,839 --> 00:35:39,490
few few people I don't got any yeah one

00:35:38,349 --> 00:35:42,010
or two okay cool

00:35:39,490 --> 00:35:44,650
so it's a Bitcoin takes back that

00:35:42,010 --> 00:35:47,170
concept of a hash chain quite a bit

00:35:44,650 --> 00:35:51,130
further to create what's known as a

00:35:47,170 --> 00:35:52,270
blockchain and it uses this blockchain

00:35:51,130 --> 00:35:54,310
to publicly store data about

00:35:52,270 --> 00:35:59,710
transactions between Bitcoin addresses

00:35:54,310 --> 00:36:01,000
Bitcoin users so I mean there was a talk

00:35:59,710 --> 00:36:04,180
on blockchain so I'm I'm gonna be doing

00:36:01,000 --> 00:36:06,790
a little bit on this but going to what a

00:36:04,180 --> 00:36:10,569
blockchain is it's basically a miracle

00:36:06,790 --> 00:36:16,180
tree the basis of any block chaining is

00:36:10,569 --> 00:36:17,800
going to be a miracle tree it's all of

00:36:16,180 --> 00:36:20,829
the other property there is no central

00:36:17,800 --> 00:36:22,510
authority so there is no no one person

00:36:20,829 --> 00:36:24,910
that can say that's a valid data item

00:36:22,510 --> 00:36:29,290
that isn't okay so there's no authority

00:36:24,910 --> 00:36:31,930
that owns the data structure anyone in

00:36:29,290 --> 00:36:33,339
the world can run a node and they can

00:36:31,930 --> 00:36:35,470
participate in the blockchain they can

00:36:33,339 --> 00:36:41,500
validate the data and they can add data

00:36:35,470 --> 00:36:43,540
to it multiple Forks of a Bach chain may

00:36:41,500 --> 00:36:45,520
exist at one time it may be possible

00:36:43,540 --> 00:36:47,859
that several different people have

00:36:45,520 --> 00:36:51,310
different views of what the the current

00:36:47,859 --> 00:36:53,619
state of the blockchain is and that

00:36:51,310 --> 00:36:55,869
means that we also need to have some

00:36:53,619 --> 00:36:58,480
sort of consensus algorithm to determine

00:36:55,869 --> 00:37:02,079
which fork is the one that we want to

00:36:58,480 --> 00:37:03,849
accept bitcoins consensus algorithm is

00:37:02,079 --> 00:37:05,440
generally the the deepest tree the

00:37:03,849 --> 00:37:07,599
longest longest string at the highest

00:37:05,440 --> 00:37:09,520
block it's carry the one that's accepted

00:37:07,599 --> 00:37:11,079
so if you've got two forks that you're

00:37:09,520 --> 00:37:12,280
comparing I'm once called more blocking

00:37:11,079 --> 00:37:15,460
than the other you take that one and

00:37:12,280 --> 00:37:17,410
continue working with that one although

00:37:15,460 --> 00:37:22,300
other systems use different consensus

00:37:17,410 --> 00:37:24,790
algorithms but talk on that so and the

00:37:22,300 --> 00:37:26,740
the consensus algorithm must only

00:37:24,790 --> 00:37:29,440
require data which is contained within

00:37:26,740 --> 00:37:31,089
the blockchain so there shouldn't be any

00:37:29,440 --> 00:37:32,650
like private or secret data that you

00:37:31,089 --> 00:37:33,570
need to get to run that consensus

00:37:32,650 --> 00:37:35,760
algorithm to make

00:37:33,570 --> 00:37:37,620
all those blocks of valid all the data

00:37:35,760 --> 00:37:44,970
should already be present on the on the

00:37:37,620 --> 00:37:46,890
chain itself so briefly have a look at

00:37:44,970 --> 00:37:48,690
how how Bitcoin and actually this is

00:37:46,890 --> 00:37:53,370
fairly similar to how it works as well

00:37:48,690 --> 00:37:57,030
but Bitcoin works it's a data structure

00:37:53,370 --> 00:38:00,090
built for transactions so ultimately a

00:37:57,030 --> 00:38:02,130
transaction is our simple level

00:38:00,090 --> 00:38:05,250
somebody's got some Bitcoin and they've

00:38:02,130 --> 00:38:09,210
signed signed a message is actually that

00:38:05,250 --> 00:38:11,490
says I transfer three of my bitcoins to

00:38:09,210 --> 00:38:13,740
this address and they've they've signed

00:38:11,490 --> 00:38:17,220
that with an elliptic curve key let's

00:38:13,740 --> 00:38:21,410
start made a signature and they've

00:38:17,220 --> 00:38:24,090
committed that as a sort of block okay

00:38:21,410 --> 00:38:26,070
now when that's submitted to the network

00:38:24,090 --> 00:38:27,390
it will sort of validate that yes you do

00:38:26,070 --> 00:38:29,820
actually have three bitcoins to give

00:38:27,390 --> 00:38:31,920
someone and then if they have that

00:38:29,820 --> 00:38:36,080
transaction will be accepted till then

00:38:31,920 --> 00:38:36,080
be appended to a block of transactions

00:38:36,410 --> 00:38:41,520
once you've got a bunch of transactions

00:38:38,850 --> 00:38:45,240
in a block they have a sort of a block

00:38:41,520 --> 00:38:49,670
header which contains a hash of all the

00:38:45,240 --> 00:38:49,670
data a hash of the previous block and

00:38:50,420 --> 00:38:57,150
some smaller information like there at

00:38:52,770 --> 00:38:58,770
the time and a random string you know

00:38:57,150 --> 00:39:00,840
it's a mine a Bitcoin in order to

00:38:58,770 --> 00:39:02,280
actually generate a ballet block we have

00:39:00,840 --> 00:39:05,100
to do is you have to change that random

00:39:02,280 --> 00:39:06,630
number over and over and try and find a

00:39:05,100 --> 00:39:08,430
hash remember I was talking about this

00:39:06,630 --> 00:39:09,930
earlier how it's quite hard to do the

00:39:08,430 --> 00:39:11,670
beginnings of a certain number of zeros

00:39:09,930 --> 00:39:14,010
based on the difficulty value of the

00:39:11,670 --> 00:39:15,090
network at a time which is computed

00:39:14,010 --> 00:39:17,070
relative to the number of people

00:39:15,090 --> 00:39:18,870
participating in the network more people

00:39:17,070 --> 00:39:21,150
participating the harder it gets

00:39:18,870 --> 00:39:22,890
Bitcoin is designed to try make sure

00:39:21,150 --> 00:39:23,790
that one block his mind roughly every

00:39:22,890 --> 00:39:27,150
ten minutes

00:39:23,790 --> 00:39:28,380
and so it varies that difficulty how

00:39:27,150 --> 00:39:29,730
many zeros you have to have it off run

00:39:28,380 --> 00:39:32,400
in your hash before you'll be accepted

00:39:29,730 --> 00:39:34,470
as a ballot block once you've once you

00:39:32,400 --> 00:39:36,570
found a random value that actually

00:39:34,470 --> 00:39:38,880
hashes to something with enough zeros at

00:39:36,570 --> 00:39:40,080
the front you can publish that block out

00:39:38,880 --> 00:39:42,690
to the network and say hey I found a

00:39:40,080 --> 00:39:44,700
block and as a reward you get a few

00:39:42,690 --> 00:39:46,740
Bitcoin yourself that's that's exactly

00:39:44,700 --> 00:39:52,200
how the network works

00:39:46,740 --> 00:39:53,520
so some of the question that kind of

00:39:52,200 --> 00:39:56,400
comes up which is kind of a bit of an

00:39:53,520 --> 00:39:59,430
interesting abstract - why do bitcoins

00:39:56,400 --> 00:40:01,650
actually have value it's a question

00:39:59,430 --> 00:40:03,660
that's been asked me mostly by people my

00:40:01,650 --> 00:40:05,940
friends who are not very technical why

00:40:03,660 --> 00:40:09,480
why is this crazy behind Bitcoin why why

00:40:05,940 --> 00:40:10,350
do people want them so much and for a

00:40:09,480 --> 00:40:13,490
while I was having to answer this

00:40:10,350 --> 00:40:15,690
question so I don't really know I don't

00:40:13,490 --> 00:40:16,890
understand why they have value myself

00:40:15,690 --> 00:40:18,000
sorry for this talk I did a bit of

00:40:16,890 --> 00:40:20,220
research and how to look into the

00:40:18,000 --> 00:40:21,210
history of currencies which is quite

00:40:20,220 --> 00:40:23,430
interesting if you want to go ahead and

00:40:21,210 --> 00:40:26,250
do it research yourself but essentially

00:40:23,430 --> 00:40:28,440
we started off with the ten pound note

00:40:26,250 --> 00:40:30,420
in your pocket that was literally an IOU

00:40:28,440 --> 00:40:32,400
it was you could tell that the Bank of

00:40:30,420 --> 00:40:34,050
England and they will exchange it for

00:40:32,400 --> 00:40:36,210
ten pounds worth of gold

00:40:34,050 --> 00:40:39,119
so it's backed by a precious material

00:40:36,210 --> 00:40:40,590
that was rare and that actually the

00:40:39,119 --> 00:40:43,590
oldest is quite useful material to have

00:40:40,590 --> 00:40:46,320
around we use it for making nice jewelry

00:40:43,590 --> 00:40:48,330
we use it for like circuit board plays

00:40:46,320 --> 00:40:52,130
anything for that so it it was backed by

00:40:48,330 --> 00:40:54,960
the presence of a valuable resource

00:40:52,130 --> 00:40:56,990
more recently government's moved away

00:40:54,960 --> 00:40:59,490
from that and they sort of said well

00:40:56,990 --> 00:41:01,320
storing loads of gold back our currency

00:40:59,490 --> 00:41:03,330
is a little bit inefficient or as we

00:41:01,320 --> 00:41:05,940
could just say well we're gonna back it

00:41:03,330 --> 00:41:08,420
by guarantee so we're gonna guarantee

00:41:05,940 --> 00:41:10,350
that the pounds are worth pounds and

00:41:08,420 --> 00:41:12,869
this is strengthened by the fact that

00:41:10,350 --> 00:41:15,300
issue got a tax bill in the UK you have

00:41:12,869 --> 00:41:16,650
to pay it using pound coins well I mean

00:41:15,300 --> 00:41:19,560
pound sterling

00:41:16,650 --> 00:41:24,540
so it has legal weight because the

00:41:19,560 --> 00:41:25,680
government backs it Bitcoin has kind of

00:41:24,540 --> 00:41:27,830
neither of these it's not backed by a

00:41:25,680 --> 00:41:32,460
precious resource it's not backed by a

00:41:27,830 --> 00:41:35,270
trusted Authority so it's kind of trying

00:41:32,460 --> 00:41:38,040
to rebuild the idea of the scarcity of a

00:41:35,270 --> 00:41:40,320
mineral by making the coins himself

00:41:38,040 --> 00:41:42,150
scarce but they themselves do not any

00:41:40,320 --> 00:41:44,310
intrinsic value so the value attributed

00:41:42,150 --> 00:41:45,900
to them is really only based on the fact

00:41:44,310 --> 00:41:48,390
that people who have them think they're

00:41:45,900 --> 00:41:51,869
worth something which to me is quite

00:41:48,390 --> 00:41:55,410
worrying I don't know about anyone else

00:41:51,869 --> 00:41:56,310
but yeah that's us that's kind of the

00:41:55,410 --> 00:41:58,109
answer that I came up with to this

00:41:56,310 --> 00:41:59,750
question is that they have value because

00:41:58,109 --> 00:42:04,730
people think they have value

00:41:59,750 --> 00:42:07,540
but it um so well the file questions I

00:42:04,730 --> 00:42:10,610
propose that this talk would answer is

00:42:07,540 --> 00:42:14,120
should use a blockchain for a given

00:42:10,610 --> 00:42:16,730
problem and the answer I'm going to give

00:42:14,120 --> 00:42:22,310
you for most of your cases is probably

00:42:16,730 --> 00:42:24,050
not a blockchain as do public blockchain

00:42:22,310 --> 00:42:26,210
comes into its own when you need to go

00:42:24,050 --> 00:42:29,360
reach a consensus on current state

00:42:26,210 --> 00:42:31,010
without some central authority in most

00:42:29,360 --> 00:42:33,110
cases if you're building a system as a

00:42:31,010 --> 00:42:35,720
company you will be that central

00:42:33,110 --> 00:42:38,960
authority okay you will be the trusted

00:42:35,720 --> 00:42:42,860
party that is allowed to to write to

00:42:38,960 --> 00:42:44,750
your datastore so you probably don't

00:42:42,860 --> 00:42:46,190
need to use a blockchain for that what

00:42:44,750 --> 00:42:48,200
you can do if you need some sort of

00:42:46,190 --> 00:42:49,160
guarantees on sort of audit ability and

00:42:48,200 --> 00:42:50,960
things like that there are a few

00:42:49,160 --> 00:42:53,030
solutions you can do which are nearly a

00:42:50,960 --> 00:42:55,820
blockchain but not quite which a little

00:42:53,030 --> 00:42:57,860
bit less computationally intensive one

00:42:55,820 --> 00:42:59,510
of the examples you could do is if you

00:42:57,860 --> 00:43:01,910
want to verify that your data hasn't

00:42:59,510 --> 00:43:03,920
been tampered with you could put it into

00:43:01,910 --> 00:43:06,980
a Merkel tree either using a streaming

00:43:03,920 --> 00:43:12,440
structure like it or using a block tree

00:43:06,980 --> 00:43:15,290
for for static data and you could

00:43:12,440 --> 00:43:17,000
periodically take the hash of your your

00:43:15,290 --> 00:43:18,440
latest piece of data you've inserted and

00:43:17,000 --> 00:43:20,870
you could publish that publicly

00:43:18,440 --> 00:43:22,610
somewhere to a blockchain like Bitcoin

00:43:20,870 --> 00:43:24,770
so you don't need to run your own you

00:43:22,610 --> 00:43:27,080
can just publish the hash into a public

00:43:24,770 --> 00:43:28,430
bit ledger and you verified that every

00:43:27,080 --> 00:43:32,780
piece of data behind that can't be

00:43:28,430 --> 00:43:34,670
tampered with very easily that's one

00:43:32,780 --> 00:43:36,410
option you could sort of go with another

00:43:34,670 --> 00:43:38,480
option if you've got lots of people that

00:43:36,410 --> 00:43:40,760
you want to be to write what you could

00:43:38,480 --> 00:43:43,160
do is you could have a similar structure

00:43:40,760 --> 00:43:44,480
data structure the Merkel tree and you

00:43:43,160 --> 00:43:46,310
could say each block a data to be

00:43:44,480 --> 00:43:49,130
committed to this tree has to be signed

00:43:46,310 --> 00:43:50,720
by a key so you've got four or five

00:43:49,130 --> 00:43:52,670
parties they're contributing to this

00:43:50,720 --> 00:43:56,630
this chain you can give each one of them

00:43:52,670 --> 00:43:58,970
a private key and you can say to all the

00:43:56,630 --> 00:44:01,000
parties only trust blocks which have

00:43:58,970 --> 00:44:03,320
been signed by one of these five keys

00:44:01,000 --> 00:44:04,880
okay so you don't need to go to the

00:44:03,320 --> 00:44:06,280
whole effort of building a proof work

00:44:04,880 --> 00:44:08,870
function you can just use regular

00:44:06,280 --> 00:44:11,810
signatures to build a sort of a web of

00:44:08,870 --> 00:44:13,750
trust effectively on top of your data

00:44:11,810 --> 00:44:16,310
structure

00:44:13,750 --> 00:44:19,550
okay well that was the sort of the last

00:44:16,310 --> 00:44:22,460
ask a question in this talk so much I

00:44:19,550 --> 00:44:25,000
hope everyone's enjoyed the talk and

00:44:22,460 --> 00:44:33,590
anyone with any questions

00:44:25,000 --> 00:44:33,590
[Applause]

00:44:43,450 --> 00:44:49,220
but what about LA so you mentioned the

00:44:46,730 --> 00:44:51,410
Weber trust in your opinion is let's

00:44:49,220 --> 00:44:53,089
encrypt breaking this web of trust it's

00:44:51,410 --> 00:44:56,259
been quite a few stories about where

00:44:53,089 --> 00:45:00,079
it's been used because it's free to

00:44:56,259 --> 00:45:03,319
verify dodgy sites I don't think it is

00:45:00,079 --> 00:45:05,299
know what let's encrypt does I think I

00:45:03,319 --> 00:45:06,859
think it's the fact that I think the

00:45:05,299 --> 00:45:09,529
problem actually wasn't let's encrypt it

00:45:06,859 --> 00:45:11,720
was what was there before so a lot of a

00:45:09,529 --> 00:45:13,059
lot of companies built up a business

00:45:11,720 --> 00:45:15,049
around the idea that they could verify

00:45:13,059 --> 00:45:17,059
identity on the internet and say that

00:45:15,049 --> 00:45:21,519
this website belongs to PayPal or this

00:45:17,059 --> 00:45:24,140
website belongs to to some company and

00:45:21,519 --> 00:45:25,700
let's encrypt doesn't do that but people

00:45:24,140 --> 00:45:27,470
have sort of come to believe that having

00:45:25,700 --> 00:45:29,299
that padlock there means that it's

00:45:27,470 --> 00:45:31,150
verified that it's a company whereas

00:45:29,299 --> 00:45:33,619
what it really is is it verifies that

00:45:31,150 --> 00:45:35,210
you are talking to the server that is

00:45:33,619 --> 00:45:37,249
responsible that domain and no one's

00:45:35,210 --> 00:45:40,640
tampered with your connection that's all

00:45:37,249 --> 00:45:42,920
it really signifies so let's encrypt has

00:45:40,640 --> 00:45:44,660
really just highlighted a problem with

00:45:42,920 --> 00:45:52,160
the existing business models of or

00:45:44,660 --> 00:46:04,809
certificate authorities question anyone

00:45:52,160 --> 00:46:04,809
else any other questions Mike

00:46:09,480 --> 00:46:15,720
I have a question regarding usually all

00:46:12,170 --> 00:46:19,260
the cryptographic technologies they get

00:46:15,720 --> 00:46:21,390
outdated one after another what is your

00:46:19,260 --> 00:46:22,890
view about the 'quran technologies when

00:46:21,390 --> 00:46:26,280
will they get our data then what would

00:46:22,890 --> 00:46:28,680
be next so I think one of the biggest

00:46:26,280 --> 00:46:32,099
things that's sort of seems to be coming

00:46:28,680 --> 00:46:36,390
but not quite yet is its quantum stuff

00:46:32,099 --> 00:46:40,770
which that that's that makes current

00:46:36,390 --> 00:46:43,050
crypto systems quite vulnerable that's

00:46:40,770 --> 00:46:46,230
what quantum computer can do is you can

00:46:43,050 --> 00:46:48,839
compute a function hmm

00:46:46,230 --> 00:46:50,880
how to explain this very simply so you

00:46:48,839 --> 00:46:52,680
you have a regular computer you have

00:46:50,880 --> 00:46:53,910
bits there either one or zero okay

00:46:52,680 --> 00:46:55,260
that's how it works right the very

00:46:53,910 --> 00:46:57,960
bottom right the very bottom level

00:46:55,260 --> 00:47:01,800
you've got binary now quantum computers

00:46:57,960 --> 00:47:04,890
work on qubits which can be both 1 and 0

00:47:01,800 --> 00:47:06,480
at the same time a bit bit takes a bit

00:47:04,890 --> 00:47:08,300
of getting your head around but what you

00:47:06,480 --> 00:47:11,280
can therefore do is you can compute

00:47:08,300 --> 00:47:13,680
every value of function in one go and

00:47:11,280 --> 00:47:16,950
the idea of how how economy works it

00:47:13,680 --> 00:47:19,170
changes the probability such that the

00:47:16,950 --> 00:47:22,349
values that you put in come out to the

00:47:19,170 --> 00:47:24,119
right value and it so breaks down a

00:47:22,349 --> 00:47:29,670
quantum function and creates the answer

00:47:24,119 --> 00:47:32,700
in that way now what that does for

00:47:29,670 --> 00:47:34,500
something like AES is you you can

00:47:32,700 --> 00:47:36,750
actually create a quantum function which

00:47:34,500 --> 00:47:38,309
you can brute force is much more

00:47:36,750 --> 00:47:41,190
efficiently than just trying every key

00:47:38,309 --> 00:47:42,869
then you would on a normal computer but

00:47:41,190 --> 00:47:45,960
it turns out that only actually reduces

00:47:42,869 --> 00:47:49,140
the complexity from sort of save

00:47:45,960 --> 00:47:50,839
encrypts all the s with a 256 bit key if

00:47:49,140 --> 00:47:54,510
you had a quantum computer right now

00:47:50,839 --> 00:47:57,619
that could break a s it would only bring

00:47:54,510 --> 00:48:00,780
it down to the level security of aes-128

00:47:57,619 --> 00:48:02,730
where it actually actually hits home

00:48:00,780 --> 00:48:05,010
what's really difficult with the quantum

00:48:02,730 --> 00:48:07,049
is all the the elliptic curve stuff

00:48:05,010 --> 00:48:11,190
there are far more efficient algorithms

00:48:07,049 --> 00:48:13,349
for doing that on quantum computers and

00:48:11,190 --> 00:48:16,020
so there's actually quite a few bits of

00:48:13,349 --> 00:48:17,400
research happening now on to crane

00:48:16,020 --> 00:48:19,410
algorithms which are actually resistant

00:48:17,400 --> 00:48:20,610
to quantum computers as well as regular

00:48:19,410 --> 00:48:21,930
computers

00:48:20,610 --> 00:48:23,670
if you're interested that there's

00:48:21,930 --> 00:48:24,870
there's quite a few things around I

00:48:23,670 --> 00:48:26,280
could probably a few people on Twitter

00:48:24,870 --> 00:48:28,830
to follow who sort of post things about

00:48:26,280 --> 00:48:31,290
it I just seem afterwards but yeah

00:48:28,830 --> 00:48:32,760
that's so next steps are sort of looking

00:48:31,290 --> 00:48:35,940
at the sort of post quantum

00:48:32,760 --> 00:48:37,890
cryptographic landscape really because

00:48:35,940 --> 00:48:40,050
at some point someone's going to create

00:48:37,890 --> 00:48:41,130
one that works probably and at which

00:48:40,050 --> 00:48:44,160
point everyone's gonna be madly

00:48:41,130 --> 00:48:56,670
scrambling to use something that's not

00:48:44,160 --> 00:48:58,440
breakable I think you just like I'm just

00:48:56,670 --> 00:49:00,390
wondering right between the web server

00:48:58,440 --> 00:49:03,240
and the database right the communication

00:49:00,390 --> 00:49:05,130
is not encrypted right how we can

00:49:03,240 --> 00:49:08,880
increase the communication between web

00:49:05,130 --> 00:49:10,320
server and the database so let's go back

00:49:08,880 --> 00:49:12,270
to really implementation details right

00:49:10,320 --> 00:49:14,010
in the actual algorithms but you can

00:49:12,270 --> 00:49:16,140
it's between your web server and

00:49:14,010 --> 00:49:18,360
database you can surf an ssl connection

00:49:16,140 --> 00:49:23,610
between them quite easily my scroll

00:49:18,360 --> 00:49:28,470
supports Isis our logins three three or

00:49:23,610 --> 00:49:30,150
six my skill you will use right when we

00:49:28,470 --> 00:49:32,610
try to connect from the application

00:49:30,150 --> 00:49:34,950
server to the mysic well right it's not

00:49:32,610 --> 00:49:37,710
encrypted itself if you try to encrypt

00:49:34,950 --> 00:49:39,780
the things right it won't work for let's

00:49:37,710 --> 00:49:42,120
think about the PHP kind of things right

00:49:39,780 --> 00:49:44,220
when PHP tried to connect it we try to

00:49:42,120 --> 00:49:45,090
connect on any port right but that's not

00:49:44,220 --> 00:49:47,490
encrypted

00:49:45,090 --> 00:49:51,300
you can set you can set my scroll up on

00:49:47,490 --> 00:49:53,310
to on to Isis how person you were taught

00:49:51,300 --> 00:49:54,750
to David Stokes he's hanging around in

00:49:53,310 --> 00:49:56,370
the exhibitor area if you go and talk to

00:49:54,750 --> 00:49:58,350
him he's one of my strolls like Deverell

00:49:56,370 --> 00:50:00,480
and he'll probably able to help you get

00:49:58,350 --> 00:50:05,270
your myscholar set up with a encrypted

00:50:00,480 --> 00:50:05,270
connection all right thank you

00:50:09,109 --> 00:50:16,579
Thanks do you ever see there being like

00:50:13,910 --> 00:50:18,680
progression on the web of trusts so if

00:50:16,579 --> 00:50:21,709
like you know if I need to trust someone

00:50:18,680 --> 00:50:25,130
on the other side of the world do you

00:50:21,709 --> 00:50:28,459
ever see there being a solution for

00:50:25,130 --> 00:50:30,559
ensuring like you know the original key

00:50:28,459 --> 00:50:32,029
exchange is not tampered with because

00:50:30,559 --> 00:50:34,400
it's because it seems like that would be

00:50:32,029 --> 00:50:37,099
the main thing to attack rather than not

00:50:34,400 --> 00:50:38,689
the algorithms themselves but the bit at

00:50:37,099 --> 00:50:41,749
the very beginning do you ever see a

00:50:38,689 --> 00:50:44,359
solution for that it's quite difficult

00:50:41,749 --> 00:50:48,019
to to resolve that sort of initial I

00:50:44,359 --> 00:50:49,519
mean for a long while cryptography we

00:50:48,019 --> 00:50:53,589
didn't have asymmetric cryptography at

00:50:49,519 --> 00:50:56,930
all and I mean you've had like German

00:50:53,589 --> 00:50:59,299
u-boats with books full of today's

00:50:56,930 --> 00:51:00,650
encryption keys and you'd have British

00:50:59,299 --> 00:51:03,319
commandos storming them into stealing

00:51:00,650 --> 00:51:04,160
them so so for a while we didn't

00:51:03,319 --> 00:51:06,309
actually have a solution to that problem

00:51:04,160 --> 00:51:09,380
so I think we've only just touched the

00:51:06,309 --> 00:51:10,459
tip of what's potentially possible so I

00:51:09,380 --> 00:51:14,739
hopefully there will be a better

00:51:10,459 --> 00:51:14,739
solution to come all right thanks

00:51:19,180 --> 00:51:29,540
any other questions okay that's it okay

00:51:27,800 --> 00:51:31,010
well I'll just finish if you want to

00:51:29,540 --> 00:51:34,190
follow me on Twitter I might give up

00:51:31,010 --> 00:51:35,960
already I've got a github there with a

00:51:34,190 --> 00:51:39,140
few different bits and pieces on there

00:51:35,960 --> 00:51:41,000
and my blog which I believe the slides

00:51:39,140 --> 00:51:43,250
for this talk about on that they will be

00:51:41,000 --> 00:51:44,480
very soon if they're not already in

00:51:43,250 --> 00:51:46,820
almost all slides my other talks up

00:51:44,480 --> 00:51:48,800
there you've probably also noticed I

00:51:46,820 --> 00:51:50,930
sort of run PHP Yorkshire if anyone's

00:51:48,800 --> 00:51:52,580
interested in coming the the event is on

00:51:50,930 --> 00:51:56,240
the 13th of April this year so about two

00:51:52,580 --> 00:51:57,770
months time and we've got a few last I

00:51:56,240 --> 00:52:01,130
checked at about 15 early bird tickets

00:51:57,770 --> 00:52:03,110
left if you use the discount code PHP UK

00:52:01,130 --> 00:52:06,380
2019 you'll get a further six pounds off

00:52:03,110 --> 00:52:07,970
that price that's quite cool and if

00:52:06,380 --> 00:52:10,520
anybody wants an elephant and sell them

00:52:07,970 --> 00:52:11,360
so come see me later invite an elephant

00:52:10,520 --> 00:52:13,810
very cool

00:52:11,360 --> 00:52:13,810

YouTube URL: https://www.youtube.com/watch?v=Nny7xf-anfU


