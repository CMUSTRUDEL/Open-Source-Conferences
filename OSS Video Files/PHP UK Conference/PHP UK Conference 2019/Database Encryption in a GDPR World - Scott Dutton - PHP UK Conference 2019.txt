Title: Database Encryption in a GDPR World - Scott Dutton - PHP UK Conference 2019
Publication date: 2019-03-22
Playlist: PHP UK Conference 2019
Description: 
	15 years ago, plain text password storing was normal with some using MD5. We look back now and wonder what we were thinking! With GDPR and people thinking more about personal details, its about time we caught up and started storing them securely. There are many uses for personal data and is often sought after by criminals for targeting people. How can you prevent your customers data being used in these attacks ? Encrypting your database is a fantastic way! PHP is the first language to have modern encryption built in to the core, This talk will show you how to use these methods to allow your data to be secure and also not lose the speed which you can currently search for this data in your application. This talk will touch on architecture and will be focused on MySQL although the same techniques can be used for any storage engine.
Captions: 
	00:00:04,100 --> 00:00:08,670
so before we talk about encryption was

00:00:07,200 --> 00:00:10,710
gonna think back to about 15 years ago

00:00:08,670 --> 00:00:13,139
Harry Potter and the Goblet of Fire was

00:00:10,710 --> 00:00:14,849
the big movie that year so it's you know

00:00:13,139 --> 00:00:17,039
a while ago but it's not a crazy amount

00:00:14,849 --> 00:00:19,109
of time ago most applications store

00:00:17,039 --> 00:00:23,640
their passwords in plain text crypt or

00:00:19,109 --> 00:00:27,480
md5 open wall released PHP pass to

00:00:23,640 --> 00:00:29,010
combat this and some of the big projects

00:00:27,480 --> 00:00:30,539
talking up at the time the biggest

00:00:29,010 --> 00:00:33,690
answer on Stack Overflow for how to

00:00:30,539 --> 00:00:36,420
securely store passwords was this answer

00:00:33,690 --> 00:00:41,190
right here so md5 is still safe

00:00:36,420 --> 00:00:43,290
according to this and it's not

00:00:41,190 --> 00:00:45,719
particularly very well and the idea of

00:00:43,290 --> 00:00:47,730
stay is trying to give advice that age

00:00:45,719 --> 00:00:49,079
as well and you know we don't look back

00:00:47,730 --> 00:00:50,539
and think that was a terrible things

00:00:49,079 --> 00:00:54,350
though

00:00:50,539 --> 00:00:56,190
so people who didn't take that advice

00:00:54,350 --> 00:00:58,590
these sites have been breached

00:00:56,190 --> 00:01:00,750
subsequently the number in brackets it's

00:00:58,590 --> 00:01:03,270
the amount of passwords successfully

00:01:00,750 --> 00:01:05,700
recovered using this saying using this

00:01:03,270 --> 00:01:07,560
hashing method so sure while myspace got

00:01:05,700 --> 00:01:08,880
pretty high space LinkedIn on Yahoo

00:01:07,560 --> 00:01:10,080
pretty much got all of their passwords

00:01:08,880 --> 00:01:13,439
recovered even though the usually

00:01:10,080 --> 00:01:15,330
shaolong md5 again similar similar sort

00:01:13,439 --> 00:01:17,070
of numbers Purdue last.fm he harmony all

00:01:15,330 --> 00:01:18,299
of them almost all of the passwords got

00:01:17,070 --> 00:01:20,220
recovered the ones that didn't get

00:01:18,299 --> 00:01:22,409
recovered they were the ones that are

00:01:20,220 --> 00:01:24,750
actually quite secure so if people use

00:01:22,409 --> 00:01:25,830
in my you know 35 character passwords

00:01:24,750 --> 00:01:27,420
and their password manager they're the

00:01:25,830 --> 00:01:29,340
ones that didn't get recovered if you

00:01:27,420 --> 00:01:30,350
use them sort of like 16 characters that

00:01:29,340 --> 00:01:32,220
you would have been recovered and

00:01:30,350 --> 00:01:35,009
probably the most famous is the

00:01:32,220 --> 00:01:37,530
plaintext RockYou that's now included in

00:01:35,009 --> 00:01:39,180
kali linux as default so that's a word

00:01:37,530 --> 00:01:42,840
list that you can just use and iterate

00:01:39,180 --> 00:01:44,100
through so these people who haven't used

00:01:42,840 --> 00:01:50,729
best practices even though they're

00:01:44,100 --> 00:01:52,500
available the time so at the time

00:01:50,729 --> 00:01:55,740
even back then one that all these

00:01:52,500 --> 00:01:58,200
breached be crypt was was the thing that

00:01:55,740 --> 00:02:00,149
came out in 1999 these recites that used

00:01:58,200 --> 00:02:01,740
to be crypt and how much of their

00:02:00,149 --> 00:02:05,670
database when they got leaked

00:02:01,740 --> 00:02:08,220
how much of them got reversed so Dropbox

00:02:05,670 --> 00:02:11,110
totally reversed I'm sorry got leaked

00:02:08,220 --> 00:02:14,730
and then 2000 is 22% of their scar

00:02:11,110 --> 00:02:17,320
got that plaintext passwords exposed

00:02:14,730 --> 00:02:20,470
sha-256 which came out in 2001

00:02:17,320 --> 00:02:22,060
again it's it was available the time all

00:02:20,470 --> 00:02:24,100
of these all of the other sites got

00:02:22,060 --> 00:02:26,260
released but no one used it and similar

00:02:24,100 --> 00:02:30,430
numbers here so in the in the low

00:02:26,260 --> 00:02:31,750
percentages and about 35 are gone to his

00:02:30,430 --> 00:02:33,310
probably if you restore the passwords

00:02:31,750 --> 00:02:35,620
today and you're looking for scheme this

00:02:33,310 --> 00:02:37,030
was probably one you should go with but

00:02:35,620 --> 00:02:39,990
there's not enough information about

00:02:37,030 --> 00:02:44,230
leaks fly economics at that 8-bit League

00:02:39,990 --> 00:02:46,420
the variability so between the low like

00:02:44,230 --> 00:02:48,340
the three and whomp cents to the 21 and

00:02:46,420 --> 00:02:49,600
34 it's down to password reuse so people

00:02:48,340 --> 00:02:52,440
have used the old breaches where they've

00:02:49,600 --> 00:02:54,610
already reverse the passwords and then

00:02:52,440 --> 00:02:55,750
and they just tried those same passwords

00:02:54,610 --> 00:02:58,720
with the same credentials and it's just

00:02:55,750 --> 00:03:00,520
worked on the next one so even though

00:02:58,720 --> 00:03:02,050
they're much more secure that the higher

00:03:00,520 --> 00:03:04,720
numbers are purely down so the other

00:03:02,050 --> 00:03:09,100
sites that haven't haven't done so well

00:03:04,720 --> 00:03:10,360
with securing our passwords so we think

00:03:09,100 --> 00:03:11,620
about the value of the day if you if

00:03:10,360 --> 00:03:13,150
your database does leak you think about

00:03:11,620 --> 00:03:15,940
the value of it and the obvious ones are

00:03:13,150 --> 00:03:17,830
credit cards so if a credit card plane

00:03:15,940 --> 00:03:19,959
tax credit card info gets leaked it's

00:03:17,830 --> 00:03:26,530
quite obvious how people can it use that

00:03:19,959 --> 00:03:27,670
to for financial gain merchant services

00:03:26,530 --> 00:03:29,110
are actually cracking down on credit

00:03:27,670 --> 00:03:30,910
cards so it's much harder to use credit

00:03:29,110 --> 00:03:32,500
cards as people would have used them ten

00:03:30,910 --> 00:03:33,970
years ago because you can't just use

00:03:32,500 --> 00:03:36,190
thousands of credit cards anymore you

00:03:33,970 --> 00:03:38,260
merchant service will stop our passwords

00:03:36,190 --> 00:03:40,170
they're used more for like logging into

00:03:38,260 --> 00:03:42,610
other services and trying to extract

00:03:40,170 --> 00:03:44,560
money from other services so if you log

00:03:42,610 --> 00:03:46,870
in to Amazon with someone's password you

00:03:44,560 --> 00:03:48,760
used to be able to just change the ship

00:03:46,870 --> 00:03:51,100
and rush ship it to you and then using

00:03:48,760 --> 00:03:52,630
that password you get money out the same

00:03:51,100 --> 00:03:54,400
thing happens with email addresses so

00:03:52,630 --> 00:03:56,470
people log in to your email with the

00:03:54,400 --> 00:03:58,120
password they send spam email to all of

00:03:56,470 --> 00:04:01,420
your friends because it becomes from you

00:03:58,120 --> 00:04:03,100
it's more trustworthy so they get their

00:04:01,420 --> 00:04:04,739
product of however is that they're

00:04:03,100 --> 00:04:07,630
getting their money out of it

00:04:04,739 --> 00:04:09,580
PII this is quite a new one and how it's

00:04:07,630 --> 00:04:10,420
being used people don't often think that

00:04:09,580 --> 00:04:13,810
personal identifiable information

00:04:10,420 --> 00:04:15,489
leaking is as much of an issue I've got

00:04:13,810 --> 00:04:19,359
some examples which would really show

00:04:15,489 --> 00:04:21,910
the value of pi being leaked so talk

00:04:19,359 --> 00:04:23,380
talk does everyone know the talk talk

00:04:21,910 --> 00:04:24,310
got leaked a few years ago it's probably

00:04:23,380 --> 00:04:27,820
one of those

00:04:24,310 --> 00:04:30,600
talk about database leaks of the UK

00:04:27,820 --> 00:04:34,390
history there was two trust-based comes

00:04:30,600 --> 00:04:36,610
this based honest on the early days the

00:04:34,390 --> 00:04:39,790
first one when it wasn't really publicly

00:04:36,610 --> 00:04:41,800
known was people would ring the the

00:04:39,790 --> 00:04:43,630
customers from the database because have

00:04:41,800 --> 00:04:45,730
the the phone number the account number

00:04:43,630 --> 00:04:48,490
all of their details that ring the

00:04:45,730 --> 00:04:49,840
person say that the paid their internet

00:04:48,490 --> 00:04:53,380
this month they need to pay 30 power now

00:04:49,840 --> 00:04:55,000
or or risk being cut off to prove that

00:04:53,380 --> 00:04:56,890
they were definitely from talk talk they

00:04:55,000 --> 00:04:58,360
worth give you the talks or quit your

00:04:56,890 --> 00:05:00,580
cat or customer ID because how else

00:04:58,360 --> 00:05:02,170
would they know that so people did

00:05:00,580 --> 00:05:03,580
believe that their internet was gonna be

00:05:02,170 --> 00:05:08,200
cut off and pay the 30 pounds over the

00:05:03,580 --> 00:05:11,050
phone so lots of lots of 30 pounds later

00:05:08,200 --> 00:05:13,980
people people lost a lot of money to it

00:05:11,050 --> 00:05:16,510
the second one was what was known about

00:05:13,980 --> 00:05:19,210
they would ring up the same people like

00:05:16,510 --> 00:05:21,700
the same group of people and say sorry

00:05:19,210 --> 00:05:24,130
you I'm from Sauk talked with lost all

00:05:21,700 --> 00:05:26,050
the data we're gonna give you a hundred

00:05:24,130 --> 00:05:29,860
pound compensation to do that we just

00:05:26,050 --> 00:05:33,760
need your bank details and that hands is

00:05:29,860 --> 00:05:34,980
predictably as as it seems so people

00:05:33,760 --> 00:05:37,090
would give over their bank details

00:05:34,980 --> 00:05:38,770
trying to get this wonder pounds and

00:05:37,090 --> 00:05:44,500
they don't get the hundred pounds in the

00:05:38,770 --> 00:05:48,310
bank shell story the IRS is the american

00:05:44,500 --> 00:05:49,330
tax system they they the tax system in

00:05:48,310 --> 00:05:52,360
america works slightly differently to

00:05:49,330 --> 00:05:55,450
the UK so in america you get like one

00:05:52,360 --> 00:05:57,430
tax bill every year so at the end of the

00:05:55,450 --> 00:05:58,900
year people pay in paying monthly

00:05:57,430 --> 00:06:00,760
amounts because you get one bills of

00:05:58,900 --> 00:06:02,530
people paying monthly just to try and

00:06:00,760 --> 00:06:04,060
estimate where they are and a lot of

00:06:02,530 --> 00:06:06,640
people aims to overpay so they get a

00:06:04,060 --> 00:06:08,140
refund when when the tax he runs rather

00:06:06,640 --> 00:06:12,190
than have it attacked bill at the end of

00:06:08,140 --> 00:06:14,770
the year and then people have to log

00:06:12,190 --> 00:06:17,070
into the IRS system to do this and log

00:06:14,770 --> 00:06:20,500
into the IRS system they they've got a

00:06:17,070 --> 00:06:22,510
system where you you tell them where you

00:06:20,500 --> 00:06:23,950
worked in a certain year what your

00:06:22,510 --> 00:06:26,080
address was in a certain year that they

00:06:23,950 --> 00:06:28,210
ask you questions that only you should

00:06:26,080 --> 00:06:30,100
know about yourself that clearly isn't

00:06:28,210 --> 00:06:31,780
true and lots of companies are leaking

00:06:30,100 --> 00:06:34,960
your data so people

00:06:31,780 --> 00:06:37,390
attackers would log in the day the tax

00:06:34,960 --> 00:06:37,700
deadline opened submit your tax return

00:06:37,390 --> 00:06:39,920
for

00:06:37,700 --> 00:06:43,400
get the check back say that here's all

00:06:39,920 --> 00:06:45,430
the money that save them to paid way or

00:06:43,400 --> 00:06:48,050
overpaid socks get the big big check

00:06:45,430 --> 00:06:50,450
then that cash that early days you've

00:06:48,050 --> 00:06:52,490
got like another month or so before you

00:06:50,450 --> 00:06:55,010
have to submit your tax cut so you log

00:06:52,490 --> 00:06:56,090
on legitimately to do that and by that

00:06:55,010 --> 00:06:57,890
time you realize that someone's all

00:06:56,090 --> 00:07:00,200
these major tax return for you and I

00:06:57,890 --> 00:07:02,150
think it was a half of half a billion

00:07:00,200 --> 00:07:04,280
dollars lost by this just by people

00:07:02,150 --> 00:07:07,550
sending checks to people they thought

00:07:04,280 --> 00:07:08,870
were other people and again that

00:07:07,550 --> 00:07:11,050
wouldn't have happened if everyone's

00:07:08,870 --> 00:07:13,190
personal date wasn't already out there

00:07:11,050 --> 00:07:14,810
emails with passwords and phone numbers

00:07:13,190 --> 00:07:18,110
so this is this is quite new really this

00:07:14,810 --> 00:07:20,450
started last year you'd get any magic

00:07:18,110 --> 00:07:22,190
everyone's receive these emails yet the

00:07:20,450 --> 00:07:24,500
email say and that here's your password

00:07:22,190 --> 00:07:25,520
I packed all of your accounts of I've

00:07:24,500 --> 00:07:27,620
seen you've been on some interesting

00:07:25,520 --> 00:07:30,440
websites I've got videos of that and

00:07:27,620 --> 00:07:31,940
unless you release unless you pay this

00:07:30,440 --> 00:07:33,470
Bitcoin and we release it to all your

00:07:31,940 --> 00:07:35,150
friends they didn't really have anything

00:07:33,470 --> 00:07:37,160
but because they had your password and

00:07:35,150 --> 00:07:38,660
sometimes your phone number on there it

00:07:37,160 --> 00:07:40,700
made people believe that they genuinely

00:07:38,660 --> 00:07:43,480
were in that system again that's just

00:07:40,700 --> 00:07:45,830
another use of personal data and a

00:07:43,480 --> 00:07:49,160
competition wins sit this is similar to

00:07:45,830 --> 00:07:52,550
the talk talk on so I've received one of

00:07:49,160 --> 00:07:55,940
these in December last year I got a text

00:07:52,550 --> 00:08:00,170
message by my dated officer leave it

00:07:55,940 --> 00:08:02,450
said where I was so it the supermarket

00:08:00,170 --> 00:08:03,860
closest to me it had the ask the closest

00:08:02,450 --> 00:08:05,180
to me it said that i'd won their their

00:08:03,860 --> 00:08:08,720
ruffle this year by just by buying

00:08:05,180 --> 00:08:10,190
something from master and to claim it I

00:08:08,720 --> 00:08:11,540
need to click on this link fill in my

00:08:10,190 --> 00:08:13,370
details and they'll send me the money

00:08:11,540 --> 00:08:15,800
over and it's the same thing as before

00:08:13,370 --> 00:08:18,290
they just want your bank details but it

00:08:15,800 --> 00:08:19,940
makes it look real by giving the real

00:08:18,290 --> 00:08:21,110
branch that you were nearby like most

00:08:19,940 --> 00:08:22,940
people shop in there that close to

00:08:21,110 --> 00:08:24,440
supermarket the supermarket is all

00:08:22,940 --> 00:08:25,880
public information you can you can log

00:08:24,440 --> 00:08:28,040
on and find out where all supermarkets

00:08:25,880 --> 00:08:29,180
are you know where the address is for

00:08:28,040 --> 00:08:30,410
the first time because you've got the

00:08:29,180 --> 00:08:33,410
postcode and you can just find out which

00:08:30,410 --> 00:08:34,760
one's nearest so again it's it's not the

00:08:33,410 --> 00:08:36,020
use of personal data where people don't

00:08:34,760 --> 00:08:38,870
realize that giving more money away

00:08:36,020 --> 00:08:41,599
giving more information away to to lose

00:08:38,870 --> 00:08:43,970
the money and breaches really are

00:08:41,599 --> 00:08:47,420
getting bigger Marriott's lost 500

00:08:43,970 --> 00:08:50,060
million records which is you know huge

00:08:47,420 --> 00:08:51,170
if Marriott's was a continent this is

00:08:50,060 --> 00:08:52,509
where he would sit in the continents

00:08:51,170 --> 00:08:55,490
popular

00:08:52,509 --> 00:08:56,870
it really really is a huge leak that

00:08:55,490 --> 00:09:04,220
long honey it have lots and lots of info

00:08:56,870 --> 00:09:06,139
in it Kim's a journalist sweeted saying

00:09:04,220 --> 00:09:07,370
that should they not encrypt in your

00:09:06,139 --> 00:09:08,870
passports qualified criminal negligence

00:09:07,370 --> 00:09:10,370
it probably showed really you should be

00:09:08,870 --> 00:09:12,860
encrypting all of your day of it if it's

00:09:10,370 --> 00:09:15,139
if it's personal to a user and can be

00:09:12,860 --> 00:09:18,079
used in other ways you should be trying

00:09:15,139 --> 00:09:22,519
to encrypt it this one actually happened

00:09:18,079 --> 00:09:24,019
yesterday a small found date on secure

00:09:22,519 --> 00:09:26,839
database in China that was doing

00:09:24,019 --> 00:09:30,230
real-time tracking of people so it uses

00:09:26,839 --> 00:09:31,339
facial recognition and you can pretty

00:09:30,230 --> 00:09:32,930
much log into the state base because

00:09:31,339 --> 00:09:34,430
there's no authentication on it just

00:09:32,930 --> 00:09:36,829
from any way I find out exactly where

00:09:34,430 --> 00:09:39,649
people were along with loads of their

00:09:36,829 --> 00:09:42,740
information and it really is quite scary

00:09:39,649 --> 00:09:46,519
how much data gets leaked because ship

00:09:42,740 --> 00:09:48,350
in our and secure it later right and

00:09:46,519 --> 00:09:51,860
it's not just hackers that do bad stuff

00:09:48,350 --> 00:09:53,839
with information morrison's all of their

00:09:51,860 --> 00:09:56,120
staff leaked one of the senior auditors

00:09:53,839 --> 00:09:58,430
leaked all of the data I think now in

00:09:56,120 --> 00:10:00,680
prison for for it but there's still a

00:09:58,430 --> 00:10:02,870
huge piece of data that's now out there

00:10:00,680 --> 00:10:04,519
because someone leaked it Heathrow

00:10:02,870 --> 00:10:05,959
Airport someone lost the memory stick

00:10:04,519 --> 00:10:08,199
which included all travel details people

00:10:05,959 --> 00:10:10,910
including the Queen's travel itinerary

00:10:08,199 --> 00:10:13,610
again it's crazy how much people will

00:10:10,910 --> 00:10:17,089
just lose data with no encryption on it

00:10:13,610 --> 00:10:18,980
a third of councils so imagine all of

00:10:17,089 --> 00:10:19,610
the data that you can start on you it's

00:10:18,980 --> 00:10:22,009
huge

00:10:19,610 --> 00:10:23,420
they lost that they've all reported lost

00:10:22,009 --> 00:10:27,350
or stolen data in the past five years

00:10:23,420 --> 00:10:29,019
and a UK head teacher I'm not sure how

00:10:27,350 --> 00:10:31,550
many people heard about this there was a

00:10:29,019 --> 00:10:32,689
head teacher who moved schools took all

00:10:31,550 --> 00:10:34,040
of that old school state with them to

00:10:32,689 --> 00:10:37,790
the new school extract it all on the

00:10:34,040 --> 00:10:40,610
network and downside using that data in

00:10:37,790 --> 00:10:43,610
a fight well badly rarely so he even got

00:10:40,610 --> 00:10:45,050
sucked for it but its head teachers of

00:10:43,610 --> 00:10:47,120
the equivalent of like a CEO in most

00:10:45,050 --> 00:10:48,350
places and most like companies so it's

00:10:47,120 --> 00:10:49,699
even like senior people in companies

00:10:48,350 --> 00:10:54,399
that way you can't really trust with

00:10:49,699 --> 00:10:57,740
their so does anyone know who this is

00:10:54,399 --> 00:10:58,279
that's wrong that's right he runs have I

00:10:57,740 --> 00:11:00,889
been phoned

00:10:58,279 --> 00:11:04,699
he'll he's ten sent two types of emails

00:11:00,889 --> 00:11:05,120
the first one is your data has been

00:11:04,699 --> 00:11:07,460
leaked

00:11:05,120 --> 00:11:11,120
by some of the company and the second

00:11:07,460 --> 00:11:13,310
one is slightly more scary of he's

00:11:11,120 --> 00:11:14,810
trying to verify her date of reach so if

00:11:13,310 --> 00:11:17,570
you receive one of these this is this is

00:11:14,810 --> 00:11:20,120
gonna be a really bad day at work he's

00:11:17,570 --> 00:11:21,470
received a date number of your your data

00:11:20,120 --> 00:11:27,980
and he's just trying to verify them that

00:11:21,470 --> 00:11:29,230
actually is your data so security is

00:11:27,980 --> 00:11:32,210
hard

00:11:29,230 --> 00:11:34,220
Snyder's law is any person can invent it

00:11:32,210 --> 00:11:35,690
security system so clever that he she or

00:11:34,220 --> 00:11:36,830
he cannot think how to break it that

00:11:35,690 --> 00:11:39,740
also means that lots of people can't

00:11:36,830 --> 00:11:43,400
think how to break it and with gdpr

00:11:39,740 --> 00:11:47,480
it's it's a lot more a lot more focused

00:11:43,400 --> 00:11:49,490
on customer data they suggest encryption

00:11:47,480 --> 00:11:52,130
although they they suggest that all of

00:11:49,490 --> 00:11:54,710
your data is encrypted and they even say

00:11:52,130 --> 00:11:55,820
the loss of an encrypted storage medium

00:11:54,710 --> 00:11:57,380
which holds personal data is not

00:11:55,820 --> 00:11:59,240
necessarily because they did they breach

00:11:57,380 --> 00:12:01,279
so if all these people for had this data

00:11:59,240 --> 00:12:03,170
are encrypted it's not necessarily

00:12:01,279 --> 00:12:05,990
considered a breach if they lose it and

00:12:03,170 --> 00:12:07,490
if you do use encryption then the

00:12:05,990 --> 00:12:09,770
authorities must positively consider the

00:12:07,490 --> 00:12:11,300
use of encryption and whether or whether

00:12:09,770 --> 00:12:14,810
a fine is imposed or what amount in

00:12:11,300 --> 00:12:16,640
fines imposed so if you're looking for

00:12:14,810 --> 00:12:19,100
ways to sort of tell people that you

00:12:16,640 --> 00:12:20,930
need to have encryption this is a great

00:12:19,100 --> 00:12:22,370
one because it reduces the liability of

00:12:20,930 --> 00:12:29,330
your company if your data is encrypted

00:12:22,370 --> 00:12:30,950
properly oh and you can underestimate

00:12:29,330 --> 00:12:33,860
the importance of good key management so

00:12:30,950 --> 00:12:36,589
bounce a bit more this later but if you

00:12:33,860 --> 00:12:37,910
if you lose one of your so you want a

00:12:36,589 --> 00:12:39,230
good day if one of your servers get

00:12:37,910 --> 00:12:41,240
breach you leaves your key or your data

00:12:39,230 --> 00:12:42,560
and then you should really rotate that

00:12:41,240 --> 00:12:46,130
but we'll show you how that happens

00:12:42,560 --> 00:12:48,140
later on so what can do to fix it so

00:12:46,130 --> 00:12:50,480
Dropbox they had their passwords leaked

00:12:48,140 --> 00:12:55,240
and now they have one of the best

00:12:50,480 --> 00:12:57,500
password storage methods possibly really

00:12:55,240 --> 00:13:00,310
so the passwords in the center of it

00:12:57,500 --> 00:13:03,170
they then sha-512 it then bcrypt it then

00:13:00,310 --> 00:13:06,770
then encrypt the whole thing so going

00:13:03,170 --> 00:13:09,110
through layer by layer the sha-512 is to

00:13:06,770 --> 00:13:10,790
make the string consistent length and

00:13:09,110 --> 00:13:13,370
use every bit of the string bcrypt only

00:13:10,790 --> 00:13:14,959
uses the first 72 characters so that the

00:13:13,370 --> 00:13:17,630
sha-512 uses the whole string so it can

00:13:14,959 --> 00:13:18,170
be longer than 72 characters and it's

00:13:17,630 --> 00:13:21,620
consist

00:13:18,170 --> 00:13:23,720
so bcrypt longer passwords take longer -

00:13:21,620 --> 00:13:26,990
it's a harsh all I'm saying sure around

00:13:23,720 --> 00:13:28,190
time we by doing this you kind of get

00:13:26,990 --> 00:13:30,080
around a lot and it's much more

00:13:28,190 --> 00:13:35,840
consistent and then on top of all of

00:13:30,080 --> 00:13:37,310
that is the as2 five-six encryption the

00:13:35,840 --> 00:13:39,110
point of that is if your database leaks

00:13:37,310 --> 00:13:40,640
then people haven't got the hashes

00:13:39,110 --> 00:13:44,210
anymore they've got data that they can't

00:13:40,640 --> 00:13:46,580
use so it's just adding layers to secure

00:13:44,210 --> 00:13:49,870
a and all good security is like an ogre

00:13:46,580 --> 00:13:52,910
it has layers so ogres have layers

00:13:49,870 --> 00:13:56,210
security as like here's August have

00:13:52,910 --> 00:13:58,570
layers security as layers so what can we

00:13:56,210 --> 00:14:02,230
do to add layers to our database for

00:13:58,570 --> 00:14:04,460
security so firewall the database off

00:14:02,230 --> 00:14:06,050
surprisingly people don't do this as

00:14:04,460 --> 00:14:07,550
often as they should it should be the

00:14:06,050 --> 00:14:09,080
first thing you do the you database

00:14:07,550 --> 00:14:11,510
shouldn't be accessible by anyone put

00:14:09,080 --> 00:14:13,580
your applications clearly the Chinese

00:14:11,510 --> 00:14:17,450
database for that was all leaked because

00:14:13,580 --> 00:14:18,890
it was accessible from the outside have

00:14:17,450 --> 00:14:22,490
only the trusted clients on your network

00:14:18,890 --> 00:14:23,570
connect to it so not not even you entire

00:14:22,490 --> 00:14:24,890
network should be able to connect to it

00:14:23,570 --> 00:14:27,440
just just the ones that you trust to

00:14:24,890 --> 00:14:30,080
connect to it and then though with those

00:14:27,440 --> 00:14:31,310
applications you minimum access so if

00:14:30,080 --> 00:14:33,440
you only need to select from a few

00:14:31,310 --> 00:14:35,750
tables only give the permissions for

00:14:33,440 --> 00:14:40,220
those few tables full disk encryption

00:14:35,750 --> 00:14:42,110
it's it's ok I don't really recommend

00:14:40,220 --> 00:14:45,470
doing it for servers there's there's a

00:14:42,110 --> 00:14:46,930
lot of slide in my later on but what

00:14:45,470 --> 00:14:50,450
more can you do

00:14:46,930 --> 00:14:52,930
so looking at this code this is this is

00:14:50,450 --> 00:14:55,000
used quite well that everywhere rarely

00:14:52,930 --> 00:14:57,550
self unit connections to the database

00:14:55,000 --> 00:15:01,580
aquaria it calculated from the users and

00:14:57,550 --> 00:15:03,620
then you iterate over it if this was if

00:15:01,580 --> 00:15:04,850
this was used as an API everyone would

00:15:03,620 --> 00:15:07,250
be saying that there's no encryption now

00:15:04,850 --> 00:15:08,900
HTTPS isn't used but that's never really

00:15:07,250 --> 00:15:10,460
the case for databases nobody considers

00:15:08,900 --> 00:15:14,660
it it's it's actually quite easy to use

00:15:10,460 --> 00:15:16,940
encryption with my echo I just tell my

00:15:14,660 --> 00:15:18,920
scars to verify the certificate to keep

00:15:16,940 --> 00:15:21,230
it the past if occur at this exists with

00:15:18,920 --> 00:15:23,180
PDO as well but it should be the first

00:15:21,230 --> 00:15:24,350
part that you do because people can if

00:15:23,180 --> 00:15:26,390
someone does breach a part of your

00:15:24,350 --> 00:15:28,400
network then they can sniff the network

00:15:26,390 --> 00:15:29,570
traffic to the database which is now all

00:15:28,400 --> 00:15:31,390
playing and you all of your customer

00:15:29,570 --> 00:15:33,970
data is going all over this plane

00:15:31,390 --> 00:15:37,089
traffic if it's encrypted you can't

00:15:33,970 --> 00:15:39,820
sniff any more so encryption arrest this

00:15:37,089 --> 00:15:42,100
was the this from this mention before

00:15:39,820 --> 00:15:45,279
disk level encryption you this can't

00:15:42,100 --> 00:15:46,420
start without a password it's if it can

00:15:45,279 --> 00:15:48,130
keep starting servers you need to be

00:15:46,420 --> 00:15:49,870
there site your password in it's much

00:15:48,130 --> 00:15:51,190
better for devices which haven't got

00:15:49,870 --> 00:15:54,160
five lines of a lability so my laptop

00:15:51,190 --> 00:15:55,450
dies full disk encryption because if I

00:15:54,160 --> 00:15:57,370
take it somewhere in its our power tree

00:15:55,450 --> 00:15:59,769
then people can't use it but my servers

00:15:57,370 --> 00:16:03,880
there on all the time so it's just a

00:15:59,769 --> 00:16:05,560
slight slowdown really I wouldn't really

00:16:03,880 --> 00:16:07,360
recommend using the the full disk

00:16:05,560 --> 00:16:11,500
encryption unless you require to for

00:16:07,360 --> 00:16:13,029
audit reasons your backups so when

00:16:11,500 --> 00:16:14,410
you're when you've done your backups you

00:16:13,029 --> 00:16:16,149
don't keep on the same server you send

00:16:14,410 --> 00:16:17,290
that somewhere else that's now you're

00:16:16,149 --> 00:16:20,320
back up to now playing tap somewhere

00:16:17,290 --> 00:16:24,160
else all of your PIN marks there until

00:16:20,320 --> 00:16:25,779
MySQL 8.1 for I think eight point 0.14

00:16:24,160 --> 00:16:27,399
although you've been logs weren't

00:16:25,779 --> 00:16:30,070
weren't able to be encrypted either so

00:16:27,399 --> 00:16:31,899
any other MySQL service that you had

00:16:30,070 --> 00:16:34,180
when they were trying to keep up to date

00:16:31,899 --> 00:16:37,480
with your application they weren't

00:16:34,180 --> 00:16:39,300
encrypted so again you'd add traffic the

00:16:37,480 --> 00:16:42,459
me sniffed

00:16:39,300 --> 00:16:44,079
so what can we do about it and the

00:16:42,459 --> 00:16:46,360
answer really I think is application

00:16:44,079 --> 00:16:48,430
level encryption so now your application

00:16:46,360 --> 00:16:49,899
knows the keys you databases your store

00:16:48,430 --> 00:16:51,310
and date you database it's got no idea

00:16:49,899 --> 00:16:55,089
what any of this data is it's just

00:16:51,310 --> 00:16:57,040
storing like chunks of data it

00:16:55,089 --> 00:16:58,810
encourages the one application one key

00:16:57,040 --> 00:17:03,130
approach so only one application can

00:16:58,810 --> 00:17:04,839
talks that data and it still allows

00:17:03,130 --> 00:17:07,059
scaling so you can still also scale you

00:17:04,839 --> 00:17:08,319
can still do all of that it's a little

00:17:07,059 --> 00:17:10,630
bit more difficult from fluent because

00:17:08,319 --> 00:17:13,030
you've now got you know got to do a user

00:17:10,630 --> 00:17:14,169
application a lot more for stuff that it

00:17:13,030 --> 00:17:15,520
wouldn't have been used for previously

00:17:14,169 --> 00:17:19,500
and we've got some examples about in a

00:17:15,520 --> 00:17:25,860
minute so any any security system has

00:17:19,500 --> 00:17:29,290
the CIA triad and that that means

00:17:25,860 --> 00:17:33,309
confidentiality so is the datee whole

00:17:29,290 --> 00:17:34,600
secret can everyone see it integrity can

00:17:33,309 --> 00:17:36,610
you trust a beta how'd you notice I've

00:17:34,600 --> 00:17:40,240
been tampered with and availability is

00:17:36,610 --> 00:17:42,520
there available so confidentiality well

00:17:40,240 --> 00:17:46,410
access controls are there you can see it

00:17:42,520 --> 00:17:46,410
does that date have any protection

00:17:46,750 --> 00:17:50,800
integrity if someone changed how would

00:17:49,360 --> 00:17:52,720
you know that I find it's a gritty quite

00:17:50,800 --> 00:17:53,950
scary if someone's in certain records or

00:17:52,720 --> 00:17:56,920
changing your records how would you ever

00:17:53,950 --> 00:17:59,260
know that if you restored it back off or

00:17:56,920 --> 00:18:02,320
you're certain it's a match you saw your

00:17:59,260 --> 00:18:03,370
replicas or a complete match could

00:18:02,320 --> 00:18:05,020
someone have changed one of them and

00:18:03,370 --> 00:18:07,240
introduced something odd in your

00:18:05,020 --> 00:18:09,490
application that that gives them a

00:18:07,240 --> 00:18:11,740
benefit somehow how would you ever know

00:18:09,490 --> 00:18:14,350
that that's that the scary question in

00:18:11,740 --> 00:18:15,670
the temporary availability this is

00:18:14,350 --> 00:18:17,500
probably the most talked about one is

00:18:15,670 --> 00:18:20,680
the day available to those who need it

00:18:17,500 --> 00:18:22,000
so DDoS attacks they're common to attack

00:18:20,680 --> 00:18:26,410
availability they're trying to remove

00:18:22,000 --> 00:18:28,630
the availability of the application does

00:18:26,410 --> 00:18:30,280
the does whatever it is come back in a

00:18:28,630 --> 00:18:31,990
timely fashion so if you of you're using

00:18:30,280 --> 00:18:34,360
database can you get your answers back

00:18:31,990 --> 00:18:36,330
in a timely fashion and is it off all

00:18:34,360 --> 00:18:39,280
the time

00:18:36,330 --> 00:18:41,260
so looking at how we do the encryption

00:18:39,280 --> 00:18:42,510
the easy way and I've done this a few

00:18:41,260 --> 00:18:45,010
times

00:18:42,510 --> 00:18:47,710
MySQL it's quite useful it comes with

00:18:45,010 --> 00:18:50,200
this AES encryption where you pass the

00:18:47,710 --> 00:18:52,330
texture encrypt in with the key and it

00:18:50,200 --> 00:18:55,180
will just encrypt it and yura way

00:18:52,330 --> 00:18:57,610
MySQL defaults to AES what once wait

00:18:55,180 --> 00:18:59,200
which NIST as a secure until 2030 it's

00:18:57,610 --> 00:19:00,610
still indexable because whatever goes in

00:18:59,200 --> 00:19:03,150
is exactly the same as what comes out so

00:19:00,610 --> 00:19:08,650
you just index there the results of this

00:19:03,150 --> 00:19:10,930
so it's still nice and faster search but

00:19:08,650 --> 00:19:13,510
it's not particularly secure so here's

00:19:10,930 --> 00:19:17,230
some some data that was encrypted with

00:19:13,510 --> 00:19:20,380
it you can see it's a surname because

00:19:17,230 --> 00:19:22,990
based on the column and back down here

00:19:20,380 --> 00:19:27,040
is a list of data they've got encrypted

00:19:22,990 --> 00:19:28,630
with it which looking at on its own you

00:19:27,040 --> 00:19:30,700
would never be able to get back when you

00:19:28,630 --> 00:19:33,070
start adding I didn't dimensions to the

00:19:30,700 --> 00:19:34,900
data so first name you can see that the

00:19:33,070 --> 00:19:37,960
first name here matches the second line

00:19:34,900 --> 00:19:42,430
here and it happens again they're there

00:19:37,960 --> 00:19:45,040
and these are these are things where my

00:19:42,430 --> 00:19:46,930
first name is also a common surname so

00:19:45,040 --> 00:19:48,880
that could be my first name that could

00:19:46,930 --> 00:19:50,800
be my turn it like a beef my first name

00:19:48,880 --> 00:19:52,180
as well so Scott Scott that's a

00:19:50,800 --> 00:19:54,220
different name that has that

00:19:52,180 --> 00:19:57,970
characteristic where it can be a first

00:19:54,220 --> 00:19:58,790
name can be a surname and again if you

00:19:57,970 --> 00:20:00,830
add another domain

00:19:58,790 --> 00:20:02,420
into it like department you can start

00:20:00,830 --> 00:20:04,520
using public information like LinkedIn

00:20:02,420 --> 00:20:06,920
to try and work out who these people are

00:20:04,520 --> 00:20:08,900
and it actually just becomes a big

00:20:06,920 --> 00:20:10,820
portal people who like programming to

00:20:08,900 --> 00:20:12,350
get the feeling of the buzz when when

00:20:10,820 --> 00:20:13,220
they get something right you get a huge

00:20:12,350 --> 00:20:15,740
feeling of course when you start

00:20:13,220 --> 00:20:18,160
connecting these things together as

00:20:15,740 --> 00:20:21,470
always there's an xkcd for everything

00:20:18,160 --> 00:20:24,290
when the Adobe passwords leak they left

00:20:21,470 --> 00:20:27,530
the hints as plain text and it it's

00:20:24,290 --> 00:20:28,910
basically a crossword puzzle and you're

00:20:27,530 --> 00:20:30,350
trying to avoid that with you they have

00:20:28,910 --> 00:20:34,780
a people shouldn't be able to piece back

00:20:30,350 --> 00:20:43,430
bits of data to try to work out what the

00:20:34,780 --> 00:20:45,460
what the encrypted parva is so this is

00:20:43,430 --> 00:20:48,440
also a famous example so unencrypted

00:20:45,460 --> 00:20:50,830
there's the sock penguin encrypted with

00:20:48,440 --> 00:20:53,930
ECB there's kind of also that Dr penguin

00:20:50,830 --> 00:20:55,040
so people when they fed this data to it

00:20:53,930 --> 00:20:56,750
would think oh yeah that's all it's all

00:20:55,040 --> 00:20:58,970
different now it is definitely encrypted

00:20:56,750 --> 00:21:01,010
but true encryption just looks like

00:20:58,970 --> 00:21:05,450
noise so it's hard to be able to tell

00:21:01,010 --> 00:21:07,340
the difference between those two and not

00:21:05,450 --> 00:21:10,760
knowingly using ECB ECB is electronic

00:21:07,340 --> 00:21:11,960
cookbook and it's it's quite an old way

00:21:10,760 --> 00:21:13,610
of doing things that work on blocks and

00:21:11,960 --> 00:21:17,660
that's why it that's why the blocks end

00:21:13,610 --> 00:21:19,940
up like this so other issues you network

00:21:17,660 --> 00:21:23,030
traffic and your binary logs in your

00:21:19,940 --> 00:21:25,580
backups so if you're using this a if

00:21:23,030 --> 00:21:27,050
you're using the AES encrypt all of your

00:21:25,580 --> 00:21:31,010
network traffic you still send a lots

00:21:27,050 --> 00:21:33,260
with MySQL with the plaintext data sorry

00:21:31,010 --> 00:21:34,760
with the encryption key because both

00:21:33,260 --> 00:21:36,140
servers need to know another they may

00:21:34,760 --> 00:21:37,700
serve on the application server

00:21:36,140 --> 00:21:40,970
you've been logs have all those updates

00:21:37,700 --> 00:21:42,020
as well and your backups all have your

00:21:40,970 --> 00:21:43,910
backups will have that same sort of

00:21:42,020 --> 00:21:45,050
information there so you've not really

00:21:43,910 --> 00:21:46,700
solved a lot of problems

00:21:45,050 --> 00:21:48,860
you can't salt it to make it a bit

00:21:46,700 --> 00:21:52,580
better but it's not a proper solution

00:21:48,860 --> 00:21:57,430
really you need to store the salt on

00:21:52,580 --> 00:22:00,860
each row it doesn't change over time so

00:21:57,430 --> 00:22:02,600
every time you you do something LLL go

00:22:00,860 --> 00:22:05,420
back to the same method there's no sort

00:22:02,600 --> 00:22:08,960
of random about it and the weak sauce

00:22:05,420 --> 00:22:10,550
just slow down the guest attempts so it

00:22:08,960 --> 00:22:12,000
just it makes the crossword puzzle

00:22:10,550 --> 00:22:14,100
slightly hard of somebody it

00:22:12,000 --> 00:22:16,350
actually stop it so in terms of CIA

00:22:14,100 --> 00:22:18,810
we've got we've got the availability

00:22:16,350 --> 00:22:23,130
really the CNT I don't really exist so

00:22:18,810 --> 00:22:25,830
it's a No so what else can we do if you

00:22:23,130 --> 00:22:31,130
search for PHP encryption you get open

00:22:25,830 --> 00:22:35,970
SSL encrypt open SSL encrypt the

00:22:31,130 --> 00:22:37,170
signature for it it really does need

00:22:35,970 --> 00:22:38,730
somebody who's quite interested in

00:22:37,170 --> 00:22:41,220
cryptography to understand what all of

00:22:38,730 --> 00:22:44,850
this is Ivy's initialization vector who

00:22:41,220 --> 00:22:47,040
knows what others hey Dave no idea tag

00:22:44,850 --> 00:22:48,240
banks it's all it's all random stuff

00:22:47,040 --> 00:22:50,550
then you shouldn't need to know all of

00:22:48,240 --> 00:22:51,930
this it should be much easier the other

00:22:50,550 --> 00:22:53,460
one that comes up quite a lot is m crypt

00:22:51,930 --> 00:22:56,940
but it's deprecated it's not being

00:22:53,460 --> 00:22:58,410
maintained forever so even though when

00:22:56,940 --> 00:23:00,300
you search for lot of these things open

00:22:58,410 --> 00:23:05,100
SSL I prefer no encrypt the top results

00:23:00,300 --> 00:23:06,840
please don't use them as of PHP 7.2

00:23:05,100 --> 00:23:08,010
we're the first modern language first

00:23:06,840 --> 00:23:09,480
language to have modern encryption built

00:23:08,010 --> 00:23:12,180
in so the lib sodium's now baked into

00:23:09,480 --> 00:23:13,410
the core of it with most things

00:23:12,180 --> 00:23:16,380
simplicity is the best but not with

00:23:13,410 --> 00:23:18,300
encryption but the the simplicity is

00:23:16,380 --> 00:23:20,250
hidden by by lib sodium lib sodium

00:23:18,300 --> 00:23:21,210
there's a lot behind the scenes it does

00:23:20,250 --> 00:23:25,160
a lot of stuff that you won't know it's

00:23:21,210 --> 00:23:26,880
doing so how can we use it

00:23:25,160 --> 00:23:29,850
unfortunately because it's still quite

00:23:26,880 --> 00:23:34,200
new this is the PHP documentation as of

00:23:29,850 --> 00:23:36,360
now it doesn't really get you anywhere

00:23:34,200 --> 00:23:37,530
and when you look at one of the

00:23:36,360 --> 00:23:42,140
functions it just says it's not

00:23:37,530 --> 00:23:44,250
currently documented fortunately

00:23:42,140 --> 00:23:45,780
peregrination ships they've they've got

00:23:44,250 --> 00:23:48,240
a book on it and it is very very good

00:23:45,780 --> 00:23:50,190
I'm not sure why why these things aren't

00:23:48,240 --> 00:23:52,860
in the official documentation but these

00:23:50,190 --> 00:23:55,560
are the people that really pushed pushed

00:23:52,860 --> 00:23:57,030
lib sodium into PHP so definitely

00:23:55,560 --> 00:23:59,850
recommend looking there for the for the

00:23:57,030 --> 00:24:03,530
user guides and this is how you would

00:23:59,850 --> 00:24:06,330
use it so you first create you nonce

00:24:03,530 --> 00:24:08,160
announced is number used only once and

00:24:06,330 --> 00:24:12,230
it was clear that nobody in the UK was

00:24:08,160 --> 00:24:14,580
ever consulted about the name then

00:24:12,230 --> 00:24:15,990
working from the inside in so you get

00:24:14,580 --> 00:24:17,580
yourself your secret box with the

00:24:15,990 --> 00:24:18,630
message you encrypt in your passing the

00:24:17,580 --> 00:24:20,640
nonce that you've just generated up

00:24:18,630 --> 00:24:23,130
there and the key so that the secret key

00:24:20,640 --> 00:24:24,510
for your application you then append

00:24:23,130 --> 00:24:25,590
your dance to it and basically for the

00:24:24,510 --> 00:24:29,040
the entire thing

00:24:25,590 --> 00:24:30,570
and for security use sodium m0 which

00:24:29,040 --> 00:24:31,920
just zeros out the memory so people

00:24:30,570 --> 00:24:33,180
can't even look at the memory of your

00:24:31,920 --> 00:24:36,420
server and work out what's there and

00:24:33,180 --> 00:24:38,160
then you return the ciphertext so it

00:24:36,420 --> 00:24:42,720
really is quite easy to use crypto

00:24:38,160 --> 00:24:46,170
secret box it does education and I think

00:24:42,720 --> 00:24:48,990
on the next slide so it uses Joshua 20

00:24:46,170 --> 00:24:51,510
and Polly 1 3 or 5 so cha-cha 20 provide

00:24:48,990 --> 00:24:53,100
your encryption and poly 1 3 or 5 price

00:24:51,510 --> 00:24:55,650
do that occasionally a Mac around the

00:24:53,100 --> 00:24:57,480
whole thing so if somebody changes one

00:24:55,650 --> 00:24:59,970
part of it then the Mac doesn't on skate

00:24:57,480 --> 00:25:04,710
and the child's fancy then doesn't even

00:24:59,970 --> 00:25:07,530
get used so it really is encryption with

00:25:04,710 --> 00:25:09,780
integrity which is you can't do it with

00:25:07,530 --> 00:25:12,360
open SSL brave it's it's clunky this is

00:25:09,780 --> 00:25:14,040
baked in it's that easy to use or

00:25:12,360 --> 00:25:16,440
handled internally and you don't have to

00:25:14,040 --> 00:25:18,030
worry about anything so now your Salzman

00:25:16,440 --> 00:25:19,560
replace for the nonce so not just use

00:25:18,030 --> 00:25:21,990
that one time so if I encrypt the same

00:25:19,560 --> 00:25:26,490
word twice it'll be completely different

00:25:21,990 --> 00:25:29,940
each time it's verified by mark it's not

00:25:26,490 --> 00:25:31,170
quite CIA still it's closer p.m. great

00:25:29,940 --> 00:25:34,110
your availability could evidence out

00:25:31,170 --> 00:25:35,880
different so you can't index it so all

00:25:34,110 --> 00:25:37,680
of your data is now 100% secure but

00:25:35,880 --> 00:25:38,880
you've got to a full table scan and a

00:25:37,680 --> 00:25:41,550
full decrypt every time you want to use

00:25:38,880 --> 00:25:44,010
it which is the less than ideal if

00:25:41,550 --> 00:25:45,570
you've got very large databases it takes

00:25:44,010 --> 00:25:46,920
quite a while so the size of database we

00:25:45,570 --> 00:25:48,600
have a Sykes talked about six hours to

00:25:46,920 --> 00:25:50,040
encrypt and you don't want every query

00:25:48,600 --> 00:25:53,760
do taking six hours in your database

00:25:50,040 --> 00:25:56,040
that'll upset a lot of people so

00:25:53,760 --> 00:25:57,930
thinking about how how to make the

00:25:56,040 --> 00:25:59,130
indexing faster you have to think about

00:25:57,930 --> 00:26:00,510
what computers the good are and there

00:25:59,130 --> 00:26:04,050
they've got a comparing numbers and

00:26:00,510 --> 00:26:06,900
basic operations with numbers and that

00:26:04,050 --> 00:26:12,600
leads to a bloom filter a bloom filter

00:26:06,900 --> 00:26:13,890
is it has two outcomes it outcome one is

00:26:12,600 --> 00:26:15,270
it's definitely not the date you're

00:26:13,890 --> 00:26:18,090
looking for and I'll come to is it could

00:26:15,270 --> 00:26:20,550
be the day you looking for so it's

00:26:18,090 --> 00:26:25,350
exactly like an old style phonebook

00:26:20,550 --> 00:26:27,600
so if you if you look for ass then Scott

00:26:25,350 --> 00:26:28,860
could be on the page or it could not be

00:26:27,600 --> 00:26:30,030
on the page but if you look if you look

00:26:28,860 --> 00:26:33,750
in a Scott it's definitely not on the

00:26:30,030 --> 00:26:36,600
page it's it's as simple stuff so a

00:26:33,750 --> 00:26:38,730
plain text example you bloom filter

00:26:36,600 --> 00:26:39,389
would just be be acid bring like a list

00:26:38,730 --> 00:26:41,549
of everyone so you

00:26:39,389 --> 00:26:43,469
result sir first one you can for Scott

00:26:41,549 --> 00:26:45,929
so you'd say yeah that's it you carry on

00:26:43,469 --> 00:26:48,719
looping through it Sarah no Sam no

00:26:45,929 --> 00:26:49,979
summer no sky no Sam you all know so

00:26:48,719 --> 00:26:51,899
you've got it in the result set and

00:26:49,979 --> 00:26:54,329
you've had to filter that in PHP but

00:26:51,899 --> 00:26:57,799
it's it's a much smaller result set and

00:26:54,329 --> 00:26:57,799
you've got the day you're looking for

00:26:58,879 --> 00:27:03,359
but to scale up 26 characters you still

00:27:01,769 --> 00:27:05,820
need to read one 26th of your database

00:27:03,359 --> 00:27:07,469
for a hundred thousand records that's

00:27:05,820 --> 00:27:10,739
like nearly four thousand records and

00:27:07,469 --> 00:27:12,119
you do have information leakage so the

00:27:10,739 --> 00:27:14,940
start letters an ass and that really

00:27:12,119 --> 00:27:16,079
does help with trying to crack these

00:27:14,940 --> 00:27:18,209
things because you've got information

00:27:16,079 --> 00:27:20,669
that you already know about it so what

00:27:18,209 --> 00:27:22,320
we do to change that we can use

00:27:20,669 --> 00:27:24,839
different functions for it so sodium has

00:27:22,320 --> 00:27:27,859
something called crypto short hash this

00:27:24,839 --> 00:27:30,239
crc32 which is used for every TCP

00:27:27,859 --> 00:27:32,429
connection that verifies that everything

00:27:30,239 --> 00:27:34,709
is correct and ax X hat which is it's

00:27:32,429 --> 00:27:38,879
lightning fast it's used for a lot of

00:27:34,709 --> 00:27:42,329
video streaming truncate these if you

00:27:38,879 --> 00:27:43,829
need them ideally you want you want

00:27:42,329 --> 00:27:48,059
collisions and you bloom filter we don't

00:27:43,829 --> 00:27:50,489
want lots of collisions in it so these

00:27:48,059 --> 00:27:51,839
this here returns a 64-bit number which

00:27:50,489 --> 00:27:53,399
is absolutely massive most people don't

00:27:51,839 --> 00:27:54,809
need that you'll probably need about 16

00:27:53,399 --> 00:27:59,609
to 20 bits of it depending on your data

00:27:54,809 --> 00:28:00,749
size but you'll have to basically meant

00:27:59,609 --> 00:28:03,570
for number that's heart about half of

00:28:00,749 --> 00:28:06,869
your data size for your for the size of

00:28:03,570 --> 00:28:09,359
your bloom filler so the encrypted

00:28:06,869 --> 00:28:10,529
example so these are now these are our

00:28:09,359 --> 00:28:12,119
values that have been through these

00:28:10,529 --> 00:28:13,979
functions and it's exactly the same

00:28:12,119 --> 00:28:16,379
thing as the bloom filter before so this

00:28:13,979 --> 00:28:17,820
value here there's nine of them these

00:28:16,379 --> 00:28:19,589
could be the same they could be

00:28:17,820 --> 00:28:21,719
different who knows you've got a loop

00:28:19,589 --> 00:28:24,959
throughout everyone's try out so you'd

00:28:21,719 --> 00:28:28,349
look up your key so it's deterministic

00:28:24,959 --> 00:28:30,209
each time so if you do like crc32 Scott

00:28:28,349 --> 00:28:31,739
that could be that number and then

00:28:30,209 --> 00:28:33,989
you've got a loop through all of those

00:28:31,739 --> 00:28:39,359
nine and decrypt it to verify it's the

00:28:33,989 --> 00:28:40,379
right value so here is the all nine of

00:28:39,359 --> 00:28:42,119
these rows you'd have to loop through

00:28:40,379 --> 00:28:45,450
each one decrypt that and make sure that

00:28:42,119 --> 00:28:47,099
email is what you're looking for and

00:28:45,450 --> 00:28:48,839
then return the correct value if people

00:28:47,099 --> 00:28:50,399
have used generators in PHP before this

00:28:48,839 --> 00:28:52,580
is a fantastic use case for generators

00:28:50,399 --> 00:28:53,990
if you haven't used generators

00:28:52,580 --> 00:28:56,380
for this gesture looking them off you

00:28:53,990 --> 00:28:58,940
basically use the yield keyword and then

00:28:56,380 --> 00:29:00,440
your function carry on and then when it

00:28:58,940 --> 00:29:02,750
needs more day or to go back and get

00:29:00,440 --> 00:29:04,669
more data out of function so it's it's a

00:29:02,750 --> 00:29:07,570
slightly different concept boy though

00:29:04,669 --> 00:29:10,519
they're very very good in this instance

00:29:07,570 --> 00:29:11,960
so the final result is you can finally

00:29:10,519 --> 00:29:14,149
hit the index you bloom filter slice hit

00:29:11,960 --> 00:29:15,830
the index because that is a much smaller

00:29:14,149 --> 00:29:19,820
result you've got collisions and it's

00:29:15,830 --> 00:29:20,899
much safer you there is still secure and

00:29:19,820 --> 00:29:24,200
it can be taken further if you need to

00:29:20,899 --> 00:29:26,750
so you finally got your your CIA all

00:29:24,200 --> 00:29:30,070
three F I'm and your index is now really

00:29:26,750 --> 00:29:33,919
fast again and all your data is secure

00:29:30,070 --> 00:29:36,679
so how do you move to encryption the

00:29:33,919 --> 00:29:38,510
easiest solution is get the change ready

00:29:36,679 --> 00:29:40,610
in application put your application in

00:29:38,510 --> 00:29:42,409
maintenance mode run a jobs to loop over

00:29:40,610 --> 00:29:43,760
you database encrypt all this data make

00:29:42,409 --> 00:29:46,399
you make your bloom filters and your

00:29:43,760 --> 00:29:47,450
indexes change the structure sorry

00:29:46,399 --> 00:29:49,669
change structure encrypt that all add

00:29:47,450 --> 00:29:51,409
the indexes release that change and then

00:29:49,669 --> 00:29:54,019
end your maintenance mode clearly

00:29:51,409 --> 00:29:56,330
there's downtime there so although it's

00:29:54,019 --> 00:29:57,529
easy it's not it's not really feasible

00:29:56,330 --> 00:29:58,940
people don't really want to have

00:29:57,529 --> 00:30:01,909
downtime to do these sort of things so

00:29:58,940 --> 00:30:03,169
how to deal without downtime so first

00:30:01,909 --> 00:30:05,840
step you'll add your new columns or

00:30:03,169 --> 00:30:07,820
however you want to do it and you can't

00:30:05,840 --> 00:30:09,139
like one one single column for all of

00:30:07,820 --> 00:30:13,429
you in crypt a date or multiple columns

00:30:09,139 --> 00:30:14,779
however you decide really you change

00:30:13,429 --> 00:30:17,269
your application to read both the

00:30:14,779 --> 00:30:19,970
encrypted and the plaintext versions so

00:30:17,269 --> 00:30:21,409
at this point in time your your plain

00:30:19,970 --> 00:30:23,179
text and your encrypted ones are being

00:30:21,409 --> 00:30:25,909
you written but only the playing

00:30:23,179 --> 00:30:27,919
sections are being rad we're on a back

00:30:25,909 --> 00:30:29,149
population script to move over all of

00:30:27,919 --> 00:30:31,100
your old data from your plain text

00:30:29,149 --> 00:30:33,500
version to your encrypted version so

00:30:31,100 --> 00:30:36,620
however long that takes and then you run

00:30:33,500 --> 00:30:37,760
a second job to verify that just to make

00:30:36,620 --> 00:30:40,370
sure that everything has actually moved

00:30:37,760 --> 00:30:41,450
as you expect it so remember that at

00:30:40,370 --> 00:30:42,830
this point you're still reading from the

00:30:41,450 --> 00:30:46,340
plaintext so all of these all of this

00:30:42,830 --> 00:30:47,809
new stuff isn't being used when you're

00:30:46,340 --> 00:30:49,730
happy that everything's down it's all

00:30:47,809 --> 00:30:51,289
fine you change your applications to

00:30:49,730 --> 00:30:52,519
read from the encrypted columns so now

00:30:51,289 --> 00:30:54,889
your plain text ones are still there but

00:30:52,519 --> 00:30:56,000
they're not being read from and you can

00:30:54,889 --> 00:30:57,350
monitor your performance you can make

00:30:56,000 --> 00:31:01,279
sure that everything is down moving over

00:30:57,350 --> 00:31:02,510
properly the next bit is to remove the

00:31:01,279 --> 00:31:04,130
read permissions from the old columns

00:31:02,510 --> 00:31:06,230
and the reason you remove the read

00:31:04,130 --> 00:31:08,179
permissions is because if some

00:31:06,230 --> 00:31:09,740
application that you've missed suddenly

00:31:08,179 --> 00:31:10,790
stops working it's very easy to add the

00:31:09,740 --> 00:31:12,470
read provisions back in if you've

00:31:10,790 --> 00:31:14,720
dropped the column it's not as easy to

00:31:12,470 --> 00:31:17,200
add all the out there back in so remove

00:31:14,720 --> 00:31:19,490
the read missions from that one column

00:31:17,200 --> 00:31:21,200
and then change your applications write

00:31:19,490 --> 00:31:22,700
only the encrypted and then once you

00:31:21,200 --> 00:31:23,870
happy that everything is there you can

00:31:22,700 --> 00:31:25,790
remove the plane attacks column just

00:31:23,870 --> 00:31:27,650
drop them all of your date and I should

00:31:25,790 --> 00:31:30,440
be fully encrypted I in a safe way that

00:31:27,650 --> 00:31:31,610
required no downtime and after all that

00:31:30,440 --> 00:31:33,470
you can sleep better at night knowing

00:31:31,610 --> 00:31:36,080
that your data is fully encrypted and

00:31:33,470 --> 00:31:38,360
even if your database does Li nobody can

00:31:36,080 --> 00:31:42,110
use all of the data from that all of

00:31:38,360 --> 00:31:44,720
your customers data is safe I remember

00:31:42,110 --> 00:31:45,620
to use an interface in all of this I see

00:31:44,720 --> 00:31:46,910
quite a lot of people when they

00:31:45,620 --> 00:31:48,260
influence lot of things to do with

00:31:46,910 --> 00:31:49,720
health statements and it gets really

00:31:48,260 --> 00:31:51,620
really messy just use your interface

00:31:49,720 --> 00:31:52,790
putting his face in there that does the

00:31:51,620 --> 00:31:54,740
right important interfacing that was the

00:31:52,790 --> 00:31:56,720
reading and usually dependency injection

00:31:54,740 --> 00:31:58,190
framework - or a feature toggle

00:31:56,720 --> 00:32:01,549
framework to switch between which one

00:31:58,190 --> 00:32:03,320
gets used it makes it really nice dan

00:32:01,549 --> 00:32:05,960
aykroyd got a fantastic presentation on

00:32:03,320 --> 00:32:07,850
interface set creation if you've got

00:32:05,960 --> 00:32:08,860
time give out a watch it's really really

00:32:07,850 --> 00:32:11,870
useful

00:32:08,860 --> 00:32:13,340
so something pre-made the encryption

00:32:11,870 --> 00:32:14,360
we've just talked about Paragon

00:32:13,340 --> 00:32:17,299
initiative we've got something called

00:32:14,360 --> 00:32:18,200
cipher suite if you're just using basic

00:32:17,299 --> 00:32:20,270
encryption like we just talked about

00:32:18,200 --> 00:32:23,570
then definitely just use that that'll

00:32:20,270 --> 00:32:26,150
solve most people's use cases it's all

00:32:23,570 --> 00:32:28,549
in lib sodium and it's all it's all

00:32:26,150 --> 00:32:29,840
really well-written it's got hooks like

00:32:28,549 --> 00:32:32,000
doctrine and stuff like that so be using

00:32:29,840 --> 00:32:34,730
doctrine it all just links into it it's

00:32:32,000 --> 00:32:36,140
really really good it makes it very easy

00:32:34,730 --> 00:32:37,640
to move to it but if you've got

00:32:36,140 --> 00:32:39,770
something that's slightly more complex

00:32:37,640 --> 00:32:40,330
it's a bit harder to move to things like

00:32:39,770 --> 00:32:43,250
that

00:32:40,330 --> 00:32:46,460
so you've got for example application a

00:32:43,250 --> 00:32:48,559
application B right reading well bond

00:32:46,460 --> 00:32:51,230
read and writes the database ones just

00:32:48,559 --> 00:32:53,480
write to the database or if you've got

00:32:51,230 --> 00:32:54,679
like a reporting server that reads from

00:32:53,480 --> 00:32:56,480
the database and your application reads

00:32:54,679 --> 00:32:58,850
and writes to it it's bit more hard it's

00:32:56,480 --> 00:33:02,720
been more difficult cell because you

00:32:58,850 --> 00:33:04,910
can't just have that wonky system so

00:33:02,720 --> 00:33:06,080
ideally a chance for a refactor if you

00:33:04,910 --> 00:33:07,820
can make the application a 2-pound

00:33:06,080 --> 00:33:09,140
application be dependent application a

00:33:07,820 --> 00:33:11,450
which then reads and writes the database

00:33:09,140 --> 00:33:13,010
that's sometimes not feasible but if it

00:33:11,450 --> 00:33:16,909
is that's definitely the way forward all

00:33:13,010 --> 00:33:18,169
right if your reporting server is it

00:33:16,909 --> 00:33:19,309
probably really shouldn't be reading any

00:33:18,169 --> 00:33:19,789
of this personal data so you can

00:33:19,309 --> 00:33:21,619
publicly

00:33:19,789 --> 00:33:23,779
as it is but if it does read it then you

00:33:21,619 --> 00:33:27,379
need to maybe refactor it's a regional

00:33:23,779 --> 00:33:29,269
application and stuff but if you can't

00:33:27,379 --> 00:33:31,519
then you can use asymmetric asymmetric

00:33:29,269 --> 00:33:33,200
encryption so this is what's known as a

00:33:31,519 --> 00:33:39,470
hybrid cryptosystems is used by things

00:33:33,200 --> 00:33:41,389
like GPG and what's up so this base this

00:33:39,470 --> 00:33:43,100
is when you have like a group message

00:33:41,389 --> 00:33:44,419
and what's off everyone's message gets

00:33:43,100 --> 00:33:46,129
individually encrypted but everyone

00:33:44,419 --> 00:33:48,200
couldn't decrypt it oh no this is how

00:33:46,129 --> 00:33:50,479
this is how you do it live sodium so

00:33:48,200 --> 00:33:55,159
again you'd get your you get you one

00:33:50,479 --> 00:33:57,619
time key so your nonce you'd encrypt

00:33:55,159 --> 00:33:59,989
your data with that key yes yeah so you

00:33:57,619 --> 00:34:01,460
think it's Arnon so you get your key

00:33:59,989 --> 00:34:03,229
you'd get your password but randomly

00:34:01,460 --> 00:34:05,359
generated you'd encrypt you date with

00:34:03,229 --> 00:34:06,889
that randomly generated key and then you

00:34:05,359 --> 00:34:09,950
decrypt that key with the public key of

00:34:06,889 --> 00:34:11,869
each application so each application

00:34:09,950 --> 00:34:14,720
needs to have its own public key

00:34:11,869 --> 00:34:15,980
encrypted with have its own King Rock

00:34:14,720 --> 00:34:18,679
equipped with this public key so that

00:34:15,980 --> 00:34:21,290
I'll be different then you would save

00:34:18,679 --> 00:34:23,089
all of the data something like this so

00:34:21,290 --> 00:34:25,520
your applications application one's got

00:34:23,089 --> 00:34:27,409
its secret encrypted with our forms key

00:34:25,520 --> 00:34:29,990
and application Sue's guide secret

00:34:27,409 --> 00:34:35,000
cryptid with the other one and payload

00:34:29,990 --> 00:34:37,010
is that the shared payload so to read it

00:34:35,000 --> 00:34:39,500
you would look up the bloom filter value

00:34:37,010 --> 00:34:40,700
as before you'd find the data row and

00:34:39,500 --> 00:34:43,040
then look up the application

00:34:40,700 --> 00:34:44,780
applications prolifically decrypt the

00:34:43,040 --> 00:34:46,069
secret decrypt the data and then you've

00:34:44,780 --> 00:34:47,720
got everything you need to achieve it

00:34:46,069 --> 00:34:51,500
needs to be filtered and then maybe move

00:34:47,720 --> 00:34:52,639
on so as an example here is your JSON

00:34:51,500 --> 00:34:54,950
array containing all the encrypted data

00:34:52,639 --> 00:34:56,929
you find that you have your application

00:34:54,950 --> 00:34:59,750
to so you'd get the you local

00:34:56,929 --> 00:35:03,170
application to you then decrypt the

00:34:59,750 --> 00:35:05,960
secret so that it's now now known to

00:35:03,170 --> 00:35:08,119
application to you then use that secret

00:35:05,960 --> 00:35:10,579
to decrypt the payload and then get just

00:35:08,119 --> 00:35:15,290
the payload out of it and this is how

00:35:10,579 --> 00:35:17,960
they look in code so when you're

00:35:15,290 --> 00:35:19,190
decrypting it you decode that that array

00:35:17,960 --> 00:35:21,650
that we had there and make sure you

00:35:19,190 --> 00:35:25,069
throw throw arrows on exceptions

00:35:21,650 --> 00:35:27,950
sorry throw exceptions if there's any

00:35:25,069 --> 00:35:29,660
error or you'd look up your application

00:35:27,950 --> 00:35:31,369
in the for loop and if you've got it

00:35:29,660 --> 00:35:33,460
then you get a key if there's no found

00:35:31,369 --> 00:35:35,680
key then you say you can't decrypt

00:35:33,460 --> 00:35:37,359
and then you use the same decrypt

00:35:35,680 --> 00:35:39,270
version that we saw earlier just with a

00:35:37,359 --> 00:35:43,030
single key this time passing in the

00:35:39,270 --> 00:35:44,830
application keys private key to get it

00:35:43,030 --> 00:35:48,099
and then you would decrypt the whole

00:35:44,830 --> 00:35:52,000
thing so it's quite quite easy to do

00:35:48,099 --> 00:35:52,869
it's not many lines of code you bloom

00:35:52,000 --> 00:35:54,130
filters become a little bit more

00:35:52,869 --> 00:35:59,020
difficult because you either need to

00:35:54,130 --> 00:36:01,150
have a the secret key so before we have

00:35:59,020 --> 00:36:02,800
a secret keeper for the application now

00:36:01,150 --> 00:36:05,349
you can either use no secret key

00:36:02,800 --> 00:36:08,230
so just literally pass in the data to

00:36:05,349 --> 00:36:09,550
crc32 for example or you can use a

00:36:08,230 --> 00:36:11,260
global one so everything every one

00:36:09,550 --> 00:36:13,150
application is the same key or you can

00:36:11,260 --> 00:36:14,770
just use per application so each

00:36:13,150 --> 00:36:17,470
applications go its own key and each

00:36:14,770 --> 00:36:18,760
application xanga its own index that's a

00:36:17,470 --> 00:36:20,830
lot harder to get to but if you're using

00:36:18,760 --> 00:36:22,480
things like advanced or sin it's a bit

00:36:20,830 --> 00:36:24,609
easier because you say that this date

00:36:22,480 --> 00:36:25,869
has changed and then each each

00:36:24,609 --> 00:36:29,349
application can then generate their own

00:36:25,869 --> 00:36:30,160
bloom fillers so if you are if you have

00:36:29,349 --> 00:36:32,080
got like an event-driven architecture

00:36:30,160 --> 00:36:35,740
then per application is quite easy if

00:36:32,080 --> 00:36:37,869
you haven't global is much easier and

00:36:35,740 --> 00:36:41,230
some things to be aware of when you do

00:36:37,869 --> 00:36:43,210
these sort of things truncated data so

00:36:41,230 --> 00:36:46,740
MySQL is quite helpful in the fact that

00:36:43,210 --> 00:36:49,480
if you just insert stuff into it

00:36:46,740 --> 00:36:51,640
they'll just say yeah final I'll I'll

00:36:49,480 --> 00:36:53,320
try and do the best I can so the four

00:36:51,640 --> 00:36:54,400
five seven the default was to silently

00:36:53,320 --> 00:36:56,950
tional cater string so you've got a

00:36:54,400 --> 00:36:58,869
column that's defined as char one you

00:36:56,950 --> 00:37:01,440
insert two characters into it it just

00:36:58,869 --> 00:37:04,599
stores a and gives you a warning it's

00:37:01,440 --> 00:37:06,280
it's quite useful in some cases because

00:37:04,599 --> 00:37:08,670
you still get a lot of data but now

00:37:06,280 --> 00:37:10,960
you've got that mark ontology encryption

00:37:08,670 --> 00:37:12,160
if you've lost a single value of it your

00:37:10,960 --> 00:37:16,089
map doesn't pass anymore which means

00:37:12,160 --> 00:37:18,310
you've lost all of the data so it really

00:37:16,089 --> 00:37:19,690
you should really try to enable your

00:37:18,310 --> 00:37:23,920
applications to throw errors when when

00:37:19,690 --> 00:37:26,050
this or things happen because if if it

00:37:23,920 --> 00:37:27,160
happened you've lost that data then so

00:37:26,050 --> 00:37:28,390
this is one of the things you should be

00:37:27,160 --> 00:37:30,270
checking for when you verify in the

00:37:28,390 --> 00:37:34,210
application is doing things correctly

00:37:30,270 --> 00:37:36,310
case sensitivity again MySQL is helpful

00:37:34,210 --> 00:37:37,109
that you probably don't realize it does

00:37:36,310 --> 00:37:41,020
this a lot of time

00:37:37,109 --> 00:37:42,790
it defaults to lasting one Swedish case

00:37:41,020 --> 00:37:44,880
insensitive for less than a hour greater

00:37:42,790 --> 00:37:48,030
than a it defaults the UTF am only by

00:37:44,880 --> 00:37:50,290
accents and sensitive on case in sense

00:37:48,030 --> 00:37:51,730
your application probably depends on it

00:37:50,290 --> 00:37:54,790
you probably know your application

00:37:51,730 --> 00:37:56,320
depends on it but if you search for like

00:37:54,790 --> 00:37:57,400
an uppercase to version email address or

00:37:56,320 --> 00:37:59,109
a lowercase version of an email address

00:37:57,400 --> 00:38:01,030
it doesn't matter when you encrypt it

00:37:59,109 --> 00:38:02,380
and your your bloom fillers then do Mar

00:38:01,030 --> 00:38:04,750
so you need to make your bloom fillers

00:38:02,380 --> 00:38:06,970
do this whole thing as well so the easy

00:38:04,750 --> 00:38:08,260
way to do art is just to string slower

00:38:06,970 --> 00:38:09,550
or anything that goes and you bloom

00:38:08,260 --> 00:38:15,070
filters and store the the lowercase

00:38:09,550 --> 00:38:17,680
version of it you probably you probably

00:38:15,070 --> 00:38:19,000
need to make sure that you can't get

00:38:17,680 --> 00:38:22,630
your data back out when you when you do

00:38:19,000 --> 00:38:28,000
these things white space as well the SQL

00:38:22,630 --> 00:38:29,410
standard SQL 92 it is it requires you

00:38:28,000 --> 00:38:31,869
pub the string so that the strings

00:38:29,410 --> 00:38:35,380
compared are exactly the same length so

00:38:31,869 --> 00:38:36,970
if you compare like one one word with a

00:38:35,380 --> 00:38:39,490
space at the end of it on one word

00:38:36,970 --> 00:38:40,660
without a space to the end of it it adds

00:38:39,490 --> 00:38:42,460
to the space to the end of the first

00:38:40,660 --> 00:38:45,550
word and then compares those two strings

00:38:42,460 --> 00:38:47,890
they're now identical so it says that

00:38:45,550 --> 00:38:49,359
they match and when you do things like

00:38:47,890 --> 00:38:51,760
are it's basically trimming it for you

00:38:49,359 --> 00:38:54,609
but your application again problem might

00:38:51,760 --> 00:38:56,290
depend on it so you need to check are

00:38:54,609 --> 00:38:58,660
there's DB fiddle if you want to play

00:38:56,290 --> 00:39:00,100
with up but it happens for most major

00:38:58,660 --> 00:39:02,230
database engines that anyone that

00:39:00,100 --> 00:39:04,930
follows SQL 92 which is a good chunk of

00:39:02,230 --> 00:39:11,080
them it's just not an obvious thing

00:39:04,930 --> 00:39:12,640
there does performance tweaks so you can

00:39:11,080 --> 00:39:16,330
change your color your column collation

00:39:12,640 --> 00:39:17,920
so lasting ones fine for it because it's

00:39:16,330 --> 00:39:19,240
now just base64 encoded data it's

00:39:17,920 --> 00:39:21,520
probably the only time I've ever suggest

00:39:19,240 --> 00:39:25,570
you use last in one over utf-8 but you

00:39:21,520 --> 00:39:29,050
can save a lot on storage if you do need

00:39:25,570 --> 00:39:30,400
to save on storage if you your row

00:39:29,050 --> 00:39:33,010
format should be done I mean if you have

00:39:30,400 --> 00:39:35,410
multiple multiple big strings need it in

00:39:33,010 --> 00:39:37,810
your tables if it isn't dynamic which is

00:39:35,410 --> 00:39:41,730
like when you've got like all the tables

00:39:37,810 --> 00:39:43,900
then you have issues with with the only

00:39:41,730 --> 00:39:45,190
it stores all the data off somewhere

00:39:43,900 --> 00:39:46,840
else so you have actually like

00:39:45,190 --> 00:39:48,040
performance issues with that dynamic

00:39:46,840 --> 00:39:49,300
there's no performance issues so you can

00:39:48,040 --> 00:39:50,619
saw everything individually if you

00:39:49,300 --> 00:39:53,770
haven't got that I make just story it

00:39:50,619 --> 00:39:56,290
was one big JSON blob after five seven

00:39:53,770 --> 00:39:58,030
is the default so if if you using that

00:39:56,290 --> 00:39:59,140
then you definitely I using dynamic but

00:39:58,030 --> 00:40:00,100
always check with your DBA view all

00:39:59,140 --> 00:40:01,320
right or about any other performance on

00:40:00,100 --> 00:40:03,190
that

00:40:01,320 --> 00:40:05,260
compression something they get to talk

00:40:03,190 --> 00:40:07,960
about quite a lot encrypted date is

00:40:05,260 --> 00:40:11,170
slightly bigger so people say coming to

00:40:07,960 --> 00:40:14,350
compress it but HTTPS breach and crime

00:40:11,170 --> 00:40:17,320
they both attack the compression layer

00:40:14,350 --> 00:40:18,700
before they got encrypted so you don't

00:40:17,320 --> 00:40:21,790
don't compress it and I should know the

00:40:18,700 --> 00:40:23,380
apps and the certain is safe against the

00:40:21,790 --> 00:40:25,450
the types of attack that happened in

00:40:23,380 --> 00:40:28,060
those two it's not then it's not much

00:40:25,450 --> 00:40:29,620
bigger I just pay for the storage cypher

00:40:28,060 --> 00:40:31,210
text isn't compressible so they even try

00:40:29,620 --> 00:40:34,630
to fit in Krita don't try to compress

00:40:31,210 --> 00:40:39,220
that just store it house is unique keys

00:40:34,630 --> 00:40:41,770
so sometimes personal data is used for

00:40:39,220 --> 00:40:44,140
the unique keys you need to move that to

00:40:41,770 --> 00:40:45,370
the application now it's quite commonly

00:40:44,140 --> 00:40:46,840
you to the email address so you put a

00:40:45,370 --> 00:40:50,380
unique constraint on the email address

00:40:46,840 --> 00:40:51,700
and now your application has to do that

00:40:50,380 --> 00:40:53,230
logic so the application that has to

00:40:51,700 --> 00:40:58,480
look up to your email address has been

00:40:53,230 --> 00:41:00,040
used before so anywhere where you have

00:40:58,480 --> 00:41:01,450
got a unique key in your databases make

00:41:00,040 --> 00:41:03,370
sure that that isn't user personal data

00:41:01,450 --> 00:41:04,300
thyself to change application to also do

00:41:03,370 --> 00:41:08,110
that after you've started your

00:41:04,300 --> 00:41:09,580
encryption fuzzy matches so something

00:41:08,110 --> 00:41:11,470
else people do is they want to know

00:41:09,580 --> 00:41:13,810
where email addresses are like hotmail

00:41:11,470 --> 00:41:16,240
com so anyone who's using hotmail or

00:41:13,810 --> 00:41:18,070
like the salary between x and y so

00:41:16,240 --> 00:41:20,860
they'll get a list of people who earn a

00:41:18,070 --> 00:41:22,390
certain amount it's possible but these

00:41:20,860 --> 00:41:24,340
things need to be known in Devon see you

00:41:22,390 --> 00:41:26,860
build your bloom filter on the the main

00:41:24,340 --> 00:41:28,210
part so you just flip out the domain

00:41:26,860 --> 00:41:29,920
part build your bloom filter on there

00:41:28,210 --> 00:41:32,560
just the hotmail.com part or just the

00:41:29,920 --> 00:41:33,730
gmail.com part and that would be a

00:41:32,560 --> 00:41:36,160
separate balloon field so that you can

00:41:33,730 --> 00:41:38,020
unlock off each town but it has to be

00:41:36,160 --> 00:41:39,130
known in advance you can't just someone

00:41:38,020 --> 00:41:41,260
cards come along and say I need to know

00:41:39,130 --> 00:41:43,810
this now because it involved decrypt and

00:41:41,260 --> 00:41:45,370
all of your rows to work out the salary

00:41:43,810 --> 00:41:46,540
between X and that why it's harder cuz

00:41:45,370 --> 00:41:51,130
it's a billion value I've got a slide

00:41:46,540 --> 00:41:53,920
now in a minute it's harder but it's

00:41:51,130 --> 00:41:58,900
it's still possible it's just it's

00:41:53,920 --> 00:42:00,190
difficult key management so if you lose

00:41:58,900 --> 00:42:03,490
the key now you lose all of your data

00:42:00,190 --> 00:42:05,770
which is quite important because that

00:42:03,490 --> 00:42:07,750
keys only like 16 bytes or something

00:42:05,770 --> 00:42:09,310
crazy for that now represents your

00:42:07,750 --> 00:42:11,830
entire day so if whatever reason you

00:42:09,310 --> 00:42:13,780
lose that you've lost everything

00:42:11,830 --> 00:42:14,560
keeping it humidity which can be hard

00:42:13,780 --> 00:42:16,570
like that

00:42:14,560 --> 00:42:18,790
your applications to scale do you need

00:42:16,570 --> 00:42:19,930
to know that certain people will need to

00:42:18,790 --> 00:42:21,400
know that in the verses of they need to

00:42:19,930 --> 00:42:24,240
be able to restore a backup for example

00:42:21,400 --> 00:42:26,170
they'll need to be able to get a key

00:42:24,240 --> 00:42:28,120
auto-scaling complicates a little bit

00:42:26,170 --> 00:42:29,170
because whatever spearing off those

00:42:28,120 --> 00:42:30,430
servers now needs to be able to pull

00:42:29,170 --> 00:42:31,870
that key on the box but there are

00:42:30,430 --> 00:42:35,140
solutions for it

00:42:31,870 --> 00:42:36,910
HSM is the probably the best solution

00:42:35,140 --> 00:42:39,070
but they're very expensive it'll be a

00:42:36,910 --> 00:42:41,440
Stauffer KMS as well which they they

00:42:39,070 --> 00:42:44,590
have the HSM for you and they they just

00:42:41,440 --> 00:42:48,940
solve what your portion of it on the HSM

00:42:44,590 --> 00:42:50,860
so if you are using AWS kms is fine if

00:42:48,940 --> 00:42:52,720
you're not using AWS vault is very very

00:42:50,860 --> 00:42:54,490
good I'd definitely recommend use

00:42:52,720 --> 00:42:57,790
involve of this there's other secret key

00:42:54,490 --> 00:42:59,050
management systems if you can they'll

00:42:57,790 --> 00:43:05,530
probably stick to those to that they are

00:42:59,050 --> 00:43:06,730
really good your key rotation so you

00:43:05,530 --> 00:43:09,370
need to think about how you're gonna

00:43:06,730 --> 00:43:10,390
rotate your keys so when you rotate it's

00:43:09,370 --> 00:43:12,250
going to be basically the same process

00:43:10,390 --> 00:43:14,320
and move into encryption because you'll

00:43:12,250 --> 00:43:17,320
need to put the new encrypted rows in

00:43:14,320 --> 00:43:19,930
there and you basically go along that

00:43:17,320 --> 00:43:22,300
same process again if your key is

00:43:19,930 --> 00:43:23,680
compromised you need to think about get

00:43:22,300 --> 00:43:25,630
rid of all your data and rotating it all

00:43:23,680 --> 00:43:28,270
because if someone ever does then breach

00:43:25,630 --> 00:43:30,370
your data then they've got the key for

00:43:28,270 --> 00:43:32,920
it as well so you've you've basically

00:43:30,370 --> 00:43:34,960
wash your data if someone breaches your

00:43:32,920 --> 00:43:36,370
data first then you've you save just so

00:43:34,960 --> 00:43:37,750
we wrote a lock here again if you either

00:43:36,370 --> 00:43:40,210
won't get breaches make sure you can

00:43:37,750 --> 00:43:41,410
rotate them and it's possible so you can

00:43:40,210 --> 00:43:43,630
even think about rotating on a certain

00:43:41,410 --> 00:43:45,430
time period so every six months for

00:43:43,630 --> 00:43:47,890
example if you never get breached

00:43:45,430 --> 00:43:49,720
you can then date when some attackers

00:43:47,890 --> 00:43:51,250
got your data you'll be able to know

00:43:49,720 --> 00:43:53,080
exactly when they were in your network

00:43:51,250 --> 00:43:57,370
and hopefully actually be able to help

00:43:53,080 --> 00:43:59,320
flush in the mouth moving data cache

00:43:57,370 --> 00:44:00,040
this one this one's actually quite

00:43:59,320 --> 00:44:03,250
common as well

00:44:00,040 --> 00:44:04,450
so using red or some memcache you pull

00:44:03,250 --> 00:44:06,370
out all this data from the database you

00:44:04,450 --> 00:44:08,860
decrypt it all I think I'll just throw

00:44:06,370 --> 00:44:10,450
it all in in Redis because now it's

00:44:08,860 --> 00:44:12,640
lightning fast to look up again but

00:44:10,450 --> 00:44:14,410
you've basically just moved your your

00:44:12,640 --> 00:44:18,010
unencrypted availa to Redis and read

00:44:14,410 --> 00:44:20,980
it's called a lot less they secure it

00:44:18,010 --> 00:44:22,450
around it then sort of like well but

00:44:20,980 --> 00:44:24,970
you've basically smoothly from one day a

00:44:22,450 --> 00:44:26,260
star to another so if you asked if you

00:44:24,970 --> 00:44:27,430
are using reddit in memcache make sure

00:44:26,260 --> 00:44:28,339
you understood gear store in the

00:44:27,430 --> 00:44:29,719
encrypted verge

00:44:28,339 --> 00:44:34,190
and just decrypt every time your

00:44:29,719 --> 00:44:35,390
application needs a low entropy data so

00:44:34,190 --> 00:44:38,809
this is the boolean values we talked

00:44:35,390 --> 00:44:42,589
about before it's hard your you need to

00:44:38,809 --> 00:44:43,940
avoid avoid storing it your indexes

00:44:42,589 --> 00:44:45,559
probably didn't work I actually thought

00:44:43,940 --> 00:44:47,089
they did before MySQL doesn't

00:44:45,559 --> 00:44:48,349
particularly work well any database

00:44:47,089 --> 00:44:52,759
doesn't work perfectly well with boolean

00:44:48,349 --> 00:44:55,940
data indexed because unless they're

00:44:52,759 --> 00:44:56,959
roughly equal one of them is always one

00:44:55,940 --> 00:44:58,009
of the ones gonna be higher than the

00:44:56,959 --> 00:44:59,150
other so like it's gonna be more false

00:44:58,009 --> 00:45:01,400
than two years or more trues and falses

00:44:59,150 --> 00:45:02,749
at which point most database engines

00:45:01,400 --> 00:45:05,029
will be like commercials do a full table

00:45:02,749 --> 00:45:06,589
scan cuz it's gonna be quicker to do the

00:45:05,029 --> 00:45:10,039
full table scamming is to look up each

00:45:06,589 --> 00:45:11,989
row individually from the index you can

00:45:10,039 --> 00:45:15,499
do boolean's you can't just you can't

00:45:11,989 --> 00:45:18,349
store it there's two ways that you can

00:45:15,499 --> 00:45:19,640
do it really can just store it with with

00:45:18,349 --> 00:45:21,709
another bit of the data so that it gets

00:45:19,640 --> 00:45:25,219
a bit more entropy or you can put some

00:45:21,709 --> 00:45:27,199
fake values enter their seed the bloom

00:45:25,219 --> 00:45:29,150
filter of horses there's more more

00:45:27,199 --> 00:45:32,900
values that don't match in the bloom

00:45:29,150 --> 00:45:34,910
filter submit you bloom filter is really

00:45:32,900 --> 00:45:36,170
just as long as not everything marches

00:45:34,910 --> 00:45:37,609
that that's what you trying to get so

00:45:36,170 --> 00:45:38,749
and you don't be able to look up just

00:45:37,609 --> 00:45:40,130
the bloom filter and get your data back

00:45:38,749 --> 00:45:42,289
you need you need some ones that don't

00:45:40,130 --> 00:45:45,819
match but only replication for Noah she

00:45:42,289 --> 00:45:50,859
needs to put some more day room and

00:45:45,819 --> 00:45:53,779
timing attacks so now because you're

00:45:50,859 --> 00:45:55,699
with like my request for example will

00:45:53,779 --> 00:45:58,969
have other customers they are in their

00:45:55,699 --> 00:46:01,579
way to try to filter out this is the

00:45:58,969 --> 00:46:04,249
this is what happens when PHP does

00:46:01,579 --> 00:46:05,690
string equal so if you do like one

00:46:04,249 --> 00:46:08,269
string equals equals equals another

00:46:05,690 --> 00:46:09,349
string this is the the process goes

00:46:08,269 --> 00:46:10,940
through so it checks the string length

00:46:09,349 --> 00:46:13,880
equals the string length of the second

00:46:10,940 --> 00:46:15,619
string if that's true then it carries on

00:46:13,880 --> 00:46:18,140
if it's false it exits very early so you

00:46:15,619 --> 00:46:22,699
it it's quite it's quite surprising how

00:46:18,140 --> 00:46:25,269
much date you can get from this so that

00:46:22,699 --> 00:46:27,410
if you if you can try this at home

00:46:25,269 --> 00:46:29,809
writing a simple script just to compare

00:46:27,410 --> 00:46:31,279
two strings when they're strings that

00:46:29,809 --> 00:46:32,900
match it's actually quite a bit slower

00:46:31,279 --> 00:46:34,910
so you can really tell it do it if

00:46:32,900 --> 00:46:36,619
you're a bit like 15 or 20 times you'd

00:46:34,910 --> 00:46:37,519
be able to tell how big that data is not

00:46:36,619 --> 00:46:40,099
knowing what that data is

00:46:37,519 --> 00:46:41,809
and then there's and string equals Val

00:46:40,099 --> 00:46:44,180
that

00:46:41,809 --> 00:46:45,769
on your architecture it's it's all it's

00:46:44,180 --> 00:46:46,819
all been rewritten now but basically

00:46:45,769 --> 00:46:49,999
just loops through character by

00:46:46,819 --> 00:46:51,769
character so the more of your string

00:46:49,999 --> 00:46:54,829
matches the slower it gets and you can

00:46:51,769 --> 00:46:56,119
work out slowly again over time what

00:46:54,829 --> 00:46:58,729
that they are is being compared against

00:46:56,119 --> 00:47:00,890
so instead of using triple equals you

00:46:58,729 --> 00:47:03,529
use hash equals which is time in attack

00:47:00,890 --> 00:47:04,789
safe any time when there's call the

00:47:03,529 --> 00:47:07,059
customer data rain including your

00:47:04,789 --> 00:47:10,130
request make sure you use hash equals

00:47:07,059 --> 00:47:12,609
and uh thank you for listening has any

00:47:10,130 --> 00:47:12,609
questions

00:47:16,719 --> 00:47:31,459
there's the cyber buttons yes part of

00:47:26,630 --> 00:47:35,799
CIA integrity and a lot of your talk was

00:47:31,459 --> 00:47:44,319
about encryption is there a particular

00:47:35,799 --> 00:47:44,319
you mentioned the example yep

00:47:47,169 --> 00:47:52,669
so lip sodium does all of that the

00:47:49,910 --> 00:47:56,660
entire row you mean or just the day

00:47:52,669 --> 00:47:59,719
you're looking at it's like they're so

00:47:56,660 --> 00:48:09,140
lib sodium does all of it built-in so go

00:47:59,719 --> 00:48:11,709
back who ever it was so so there's lab

00:48:09,140 --> 00:48:11,709
sodium one

00:48:15,800 --> 00:48:33,950
sorry so live sodium when you do the

00:48:30,110 --> 00:48:36,350
when you use the the crypto secret box

00:48:33,950 --> 00:48:37,640
that does all of the integrity foyer if

00:48:36,350 --> 00:48:40,430
it's the entire row that you're looking

00:48:37,640 --> 00:48:41,720
at then then you were just again that

00:48:40,430 --> 00:48:43,370
you can't just get the integrity out of

00:48:41,720 --> 00:48:46,130
this so you just used the poly one three

00:48:43,370 --> 00:48:47,210
or five again for the whole row all

00:48:46,130 --> 00:48:48,740
you're really defending it's there

00:48:47,210 --> 00:48:51,020
though is somebody having access to your

00:48:48,740 --> 00:48:52,580
database and moving one one slight bit

00:48:51,020 --> 00:48:55,430
of data to another bit of data so like

00:48:52,580 --> 00:48:57,650
one one portion of the data to another

00:48:55,430 --> 00:49:02,450
another row so it's kind of a known to

00:48:57,650 --> 00:49:04,730
talk there for most cases using live

00:49:02,450 --> 00:49:06,140
sodium clips of our trip so secret box

00:49:04,730 --> 00:49:07,940
will do all that for you so you have to

00:49:06,140 --> 00:49:10,640
worry about any of it but if you do need

00:49:07,940 --> 00:49:12,890
the whole row then just use the poly one

00:49:10,640 --> 00:49:14,030
three or five methods of it if you if

00:49:12,890 --> 00:49:15,680
you look at the lip sodium card there's

00:49:14,030 --> 00:49:19,510
this one I'll just use the poly one

00:49:15,680 --> 00:49:19,510
three or five portion thank you

00:49:39,849 --> 00:49:46,420
hello thanks for the talk I wanted to

00:49:43,790 --> 00:49:49,280
ask you about how do you maintain your

00:49:46,420 --> 00:49:52,400
development environment in this respect

00:49:49,280 --> 00:49:54,890
do you also on your local machine in

00:49:52,400 --> 00:49:59,540
development cluster we also maintain all

00:49:54,890 --> 00:50:00,950
these ciphers security key rotation yeah

00:49:59,540 --> 00:50:03,380
you should be trying to keep it in that

00:50:00,950 --> 00:50:05,359
but don't use the same key as live so

00:50:03,380 --> 00:50:08,960
each environment shove its own sequel

00:50:05,359 --> 00:50:11,060
key the you'll your dev environment your

00:50:08,960 --> 00:50:12,400
stage environment they should be using

00:50:11,060 --> 00:50:15,050
things like faker to generate the data

00:50:12,400 --> 00:50:17,329
so there's no actual customer data in

00:50:15,050 --> 00:50:19,280
there and each one of them should should

00:50:17,329 --> 00:50:20,660
represent live with the same way of it's

00:50:19,280 --> 00:50:22,520
still encrypted all of this fake day has

00:50:20,660 --> 00:50:24,920
now encrypted for everyone knows that he

00:50:22,520 --> 00:50:27,760
is the difference unlife nobody knows

00:50:24,920 --> 00:50:30,020
the game okay so you're for example

00:50:27,760 --> 00:50:32,960
maintaining a world solution in your

00:50:30,020 --> 00:50:35,210
development cluster just the security

00:50:32,960 --> 00:50:38,150
rules the key rotational this is relaxed

00:50:35,210 --> 00:50:41,869
yeah we don't we have actually rotated

00:50:38,150 --> 00:50:43,010
any keys writing yet but yeah I would

00:50:41,869 --> 00:50:44,599
try and make your dev environmentally

00:50:43,010 --> 00:50:46,130
staging virus much as closer to you live

00:50:44,599 --> 00:50:48,859
ones as possible when you start

00:50:46,130 --> 00:50:49,910
introducing that differences that's when

00:50:48,859 --> 00:50:51,920
you start getting weird errors that you

00:50:49,910 --> 00:50:53,569
can't use do them reproduce so you

00:50:51,920 --> 00:50:55,310
should always try a dev stage and then

00:50:53,569 --> 00:50:56,990
put it alive when you have happier

00:50:55,310 --> 00:50:58,310
things working but everything in life

00:50:56,990 --> 00:51:02,859
should be kind of replicated and

00:50:58,310 --> 00:51:02,859
devastating okay thank you very much

00:51:06,930 --> 00:51:10,440
when I've done a bit of encryption our

00:51:08,700 --> 00:51:12,240
stuffs come out as binary what would you

00:51:10,440 --> 00:51:15,150
recommend storing is hex or binary in

00:51:12,240 --> 00:51:17,010
the database I've stored it as hex just

00:51:15,150 --> 00:51:20,040
so it's a bit more readable but binary

00:51:17,010 --> 00:51:23,310
works as well yeah it's just a bit

00:51:20,040 --> 00:51:24,420
easier for people to work with it

00:51:23,310 --> 00:51:26,520
doesn't really make a difference either

00:51:24,420 --> 00:51:27,870
way if you're comfortable looking at it

00:51:26,520 --> 00:51:29,190
in binary then then go for it

00:51:27,870 --> 00:51:30,900
people kind of like to see it in their

00:51:29,190 --> 00:51:32,850
database the engines that they can still

00:51:30,900 --> 00:51:34,560
read it but you can't lead a binary day

00:51:32,850 --> 00:51:42,180
you end up with weird characters so

00:51:34,560 --> 00:51:45,810
hexans fine is something you said during

00:51:42,180 --> 00:51:48,480
the migration you think so would you

00:51:45,810 --> 00:51:52,080
recommend obviously the classic database

00:51:48,480 --> 00:51:54,120
you have columns of data stored once you

00:51:52,080 --> 00:51:57,300
go to encryptions it make more sense to

00:51:54,120 --> 00:52:00,390
just have a blob with unstructured data

00:51:57,300 --> 00:52:02,850
and then one thing it really is up to

00:52:00,390 --> 00:52:04,500
you so the way we've done it is to have

00:52:02,850 --> 00:52:06,690
an encrypted version of each one so

00:52:04,500 --> 00:52:09,840
there's like a surname encrypted stand

00:52:06,690 --> 00:52:12,120
Oliver there's loads of columns the you

00:52:09,840 --> 00:52:13,860
know news the benefit of liars each

00:52:12,120 --> 00:52:17,580
because you get more data back with the

00:52:13,860 --> 00:52:18,900
requests anyway if you had ever in a big

00:52:17,580 --> 00:52:20,970
blob you'd be and loads and loads data

00:52:18,900 --> 00:52:22,500
back from you bloom filters if you put

00:52:20,970 --> 00:52:23,880
it in just the day you want like just

00:52:22,500 --> 00:52:25,710
the surname or just the email address

00:52:23,880 --> 00:52:27,900
it really is reduced the network time

00:52:25,710 --> 00:52:30,360
down so it depends on your application

00:52:27,900 --> 00:52:32,660
it's easier to use it's one big blob but

00:52:30,360 --> 00:52:34,590
I think it's about users mail or columns

00:52:32,660 --> 00:52:38,010
check with your specific application

00:52:34,590 --> 00:52:41,790
then yeah so you still have individual

00:52:38,010 --> 00:52:43,230
bloom filters for each so notice that

00:52:41,790 --> 00:52:46,920
the bloom filters I store in a separate

00:52:43,230 --> 00:52:49,050
table usually with a like the first

00:52:46,920 --> 00:52:51,210
there's like two two columns in their

00:52:49,050 --> 00:52:52,680
first column is the what type of data is

00:52:51,210 --> 00:52:54,990
second column is the bloom filter value

00:52:52,680 --> 00:52:57,990
so we still like surname bloom filter

00:52:54,990 --> 00:52:59,760
same bloom filter that's how I store my

00:52:57,990 --> 00:53:00,600
blue filters but you can store if the

00:52:59,760 --> 00:53:02,910
bloom filter in mine

00:53:00,600 --> 00:53:04,020
the difficulty with Estonia in line is

00:53:02,910 --> 00:53:05,820
if you need to start doing things like

00:53:04,020 --> 00:53:07,050
your likes and your 40 matches then you

00:53:05,820 --> 00:53:08,220
need each and know the column for each

00:53:07,050 --> 00:53:09,390
one of them I mean it quickly gets out

00:53:08,220 --> 00:53:12,150
of hand if you've got aloft columns to

00:53:09,390 --> 00:53:14,640
maintain so the data itself I store in

00:53:12,150 --> 00:53:15,810
different columns but the the bloom

00:53:14,640 --> 00:53:18,050
filters I store in this table and he

00:53:15,810 --> 00:53:18,050
drove

00:53:21,779 --> 00:53:30,279
so if you have the data so different

00:53:25,569 --> 00:53:33,309
databases like DynamoDB or my field they

00:53:30,279 --> 00:53:35,710
offer an encryption at rest so the data

00:53:33,309 --> 00:53:38,410
is all encrypted at rest

00:53:35,710 --> 00:53:41,410
why should we go for the blue blue

00:53:38,410 --> 00:53:43,150
filter and so the encryption rest it

00:53:41,410 --> 00:53:45,220
really only defends against when your

00:53:43,150 --> 00:53:47,259
applications offline when it when your

00:53:45,220 --> 00:53:48,670
applications work in it may as well not

00:53:47,259 --> 00:53:52,809
be there because you still read in the

00:53:48,670 --> 00:53:55,299
plaintext values out so if for example

00:53:52,809 --> 00:53:57,309
if you've got a nice ql injection attack

00:53:55,299 --> 00:53:58,720
on your website if you've got full disk

00:53:57,309 --> 00:54:00,130
encryption people still get your entire

00:53:58,720 --> 00:54:01,720
database i won't make a difference if

00:54:00,130 --> 00:54:02,950
you've got the application level

00:54:01,720 --> 00:54:04,839
encryption they won't be able to get the

00:54:02,950 --> 00:54:06,369
whole database out and even if they do

00:54:04,839 --> 00:54:08,710
get the whole database now it's it's

00:54:06,369 --> 00:54:11,920
fully encrypted so your application

00:54:08,710 --> 00:54:13,329
level so yet that you full disk

00:54:11,920 --> 00:54:14,710
encryption it defends against some

00:54:13,329 --> 00:54:15,940
things but I don't think it defends in

00:54:14,710 --> 00:54:18,269
service very well because they're always

00:54:15,940 --> 00:54:18,269
armed

00:54:27,099 --> 00:54:32,949
I just want the front as well just for

00:54:31,509 --> 00:54:35,319
my projects and team perspective how

00:54:32,949 --> 00:54:37,119
long did it take you to go from all

00:54:35,319 --> 00:54:39,099
plain text in the database to fully

00:54:37,119 --> 00:54:41,920
encrypted and how many of your team are

00:54:39,099 --> 00:54:44,380
fully you know understanding the way

00:54:41,920 --> 00:54:48,039
this works we're still trying to get it

00:54:44,380 --> 00:54:50,769
in so we I've used on all the projects

00:54:48,039 --> 00:54:53,920
at Sykes we're trying to get in the peak

00:54:50,769 --> 00:54:56,049
period to travel is in January so it was

00:54:53,920 --> 00:54:57,489
a bit risky to go for this January as

00:54:56,049 --> 00:54:58,959
soon as the peak periods over we're

00:54:57,489 --> 00:55:00,789
gonna look again in properly and now

00:54:58,959 --> 00:55:03,759
we've got proof concepts were working

00:55:00,789 --> 00:55:05,049
with and things like that but in terms

00:55:03,759 --> 00:55:06,910
of lots of developers using it

00:55:05,049 --> 00:55:08,920
we've not kind of got there yeah I've

00:55:06,910 --> 00:55:13,199
used on smaller projects my own but

00:55:08,920 --> 00:55:13,199
we're still moving in Sykes at Vernon

00:55:13,890 --> 00:55:20,729
has questions from the front sorry

00:55:26,920 --> 00:55:32,300
yeah thank you for your talk it was a

00:55:29,360 --> 00:55:34,310
lot of useful information but I was

00:55:32,300 --> 00:55:36,290
wondering will you make your slides

00:55:34,310 --> 00:55:38,570
available afterwards yeah they'll all be

00:55:36,290 --> 00:55:40,340
enjoyed in straight after so yeah have a

00:55:38,570 --> 00:55:43,460
look on joined in rate this all quiet

00:55:40,340 --> 00:55:49,610
either don't know these lights and look

00:55:43,460 --> 00:55:51,940
at yeah yeah yeah thank you any other

00:55:49,610 --> 00:55:51,940
questions

00:55:59,430 --> 00:56:06,270
hi-yah this is about caching yeah so you

00:56:04,200 --> 00:56:08,400
mentioned that we need to store the

00:56:06,270 --> 00:56:10,200
encrypted data and then we need to

00:56:08,400 --> 00:56:11,569
decrypt it angry every time so is it

00:56:10,200 --> 00:56:13,680
going to affect the performance at all

00:56:11,569 --> 00:56:16,289
very very slightly so that the

00:56:13,680 --> 00:56:17,730
performance you actually it's a bit

00:56:16,289 --> 00:56:20,609
weird performance because you're using

00:56:17,730 --> 00:56:22,440
the bloom filters now and they're based

00:56:20,609 --> 00:56:25,020
on numbers so based on integer columns

00:56:22,440 --> 00:56:26,369
so for the database lookup a no saw

00:56:25,020 --> 00:56:28,950
strictly cash but the database lookup

00:56:26,369 --> 00:56:31,220
yes light speed increased by by using

00:56:28,950 --> 00:56:34,529
bloom filters rather than text searching

00:56:31,220 --> 00:56:35,700
and yet a slight decrease by the by

00:56:34,529 --> 00:56:38,460
having the encrypted value then

00:56:35,700 --> 00:56:41,220
decrypted said for the caches you'll

00:56:38,460 --> 00:56:42,359
just get a slight decrease but for for

00:56:41,220 --> 00:56:44,819
the application as I was writing it was

00:56:42,359 --> 00:56:48,539
about three percent decrease of speed so

00:56:44,819 --> 00:56:49,710
it wasn't noticeable but you one of the

00:56:48,539 --> 00:56:50,609
things as you move into it you need to

00:56:49,710 --> 00:56:52,380
make sure that you performance is that

00:56:50,609 --> 00:56:55,470
if it isn't there there's probably some

00:56:52,380 --> 00:56:57,480
reason why isn't that the chart when

00:56:55,470 --> 00:57:01,079
he's designed for most for most

00:56:57,480 --> 00:57:01,980
architects to be really fast so it's

00:57:01,079 --> 00:57:04,170
probably not going to be the bottleneck

00:57:01,980 --> 00:57:06,059
in application but have your monitoring

00:57:04,170 --> 00:57:07,920
turned on there's loads of things like

00:57:06,059 --> 00:57:09,839
day a dog New Relic that they monitor

00:57:07,920 --> 00:57:10,859
your applications performance when you

00:57:09,839 --> 00:57:12,230
do start doing these things make sure

00:57:10,859 --> 00:57:14,190
that you definitely do monitor it though

00:57:12,230 --> 00:57:18,539
it shouldn't make much of a difference

00:57:14,190 --> 00:57:20,660
you performance them thank you any other

00:57:18,539 --> 00:57:20,660
questions

00:57:21,349 --> 00:57:27,289
right at the back right the back room

00:57:31,490 --> 00:57:36,660
hi I'm curious about the key management

00:57:34,350 --> 00:57:38,760
you mentioned the fact that if you're

00:57:36,660 --> 00:57:41,700
not careful with the keys losing 16

00:57:38,760 --> 00:57:43,170
bytes loses you all of you data yeah and

00:57:41,700 --> 00:57:45,630
there wasn't I wasn't really addressed

00:57:43,170 --> 00:57:48,830
in the talk is this any advice you can

00:57:45,630 --> 00:57:48,830
give for dealing with that

00:57:49,290 --> 00:57:54,240
so vault is very good I will try and use

00:57:51,540 --> 00:57:55,830
vault or the H HSN HSM you get the

00:57:54,240 --> 00:57:59,640
guaranteed safety with it

00:57:55,830 --> 00:58:02,640
vault is trying to be the HSM really so

00:57:59,640 --> 00:58:04,260
it's managing your keys for you but the

00:58:02,640 --> 00:58:05,130
difficulty is that a lot of people might

00:58:04,260 --> 00:58:07,230
have access to vault

00:58:05,130 --> 00:58:10,830
so it's from trying to reduce the amount

00:58:07,230 --> 00:58:12,060
of people with it but but making sure it

00:58:10,830 --> 00:58:13,470
is still secure in that environment so

00:58:12,060 --> 00:58:15,030
only the applications need to know it

00:58:13,470 --> 00:58:21,090
are in there and make sure you backup

00:58:15,030 --> 00:58:25,830
your vault obviously and it's a hardware

00:58:21,090 --> 00:58:27,690
security module so it's basically a

00:58:25,830 --> 00:58:31,800
hardware key that stores all of your

00:58:27,690 --> 00:58:32,820
your stuff for you they're expensive but

00:58:31,800 --> 00:58:35,190
they're very good

00:58:32,820 --> 00:58:38,340
I think Amazon's is about 16 grand a

00:58:35,190 --> 00:58:39,780
year so if you don't currently have HSM

00:58:38,340 --> 00:58:42,630
I wouldn't recommend just using it for

00:58:39,780 --> 00:58:46,220
this use something like kms or vault but

00:58:42,630 --> 00:58:46,220

YouTube URL: https://www.youtube.com/watch?v=RTZXgxYGOWA


