Title: PHP UK Conference 2016 - Jordi Boggiano - How I learned to stop worrying and love Regex
Publication date: 2016-03-17
Playlist: PHP UK Conference 2016
Description: 
	This session will cover Regular Expressions from the basics to the darkest corners of this arcane art. Regular Expressions at the core come in handy to achieve validation and text manipulation tasks. In the day to day life of a developer, becoming comfortable with them opens up many more use cases. As one of the tortured souls that actually enjoys writing - and reading - regexes, Jordi will share his passion so that you too can see there is no reason to worry.

Slides at http://slides.seld.be/?file=2016-02-1...
Captions: 
	00:00:08,320 --> 00:00:13,360
so just a quick void of interval

00:00:10,840 --> 00:00:17,830
why I did this talk and why like what

00:00:13,360 --> 00:00:19,990
I'm trying to do with this I see lots of

00:00:17,830 --> 00:00:23,140
people being scared about like scale of

00:00:19,990 --> 00:00:25,029
regular expressions often I'm not using

00:00:23,140 --> 00:00:27,460
them because they think is like they do

00:00:25,029 --> 00:00:31,630
they will be unhittable or not

00:00:27,460 --> 00:00:34,390
maintainable and so on so I thought if

00:00:31,630 --> 00:00:35,890
maybe this misunderstanding like

00:00:34,390 --> 00:00:37,570
misunderstanding is the cause for the

00:00:35,890 --> 00:00:38,980
fear so I thought if we go through

00:00:37,570 --> 00:00:41,320
everything and just like make sure

00:00:38,980 --> 00:00:43,270
everyone gets a good understanding you

00:00:41,320 --> 00:00:47,079
you might be less afraid of using them

00:00:43,270 --> 00:00:51,730
so we'll see how that goes but i'll try

00:00:47,079 --> 00:00:53,980
and do that so shortly about me i'm

00:00:51,730 --> 00:00:55,420
walking these days at team up calm few

00:00:53,980 --> 00:00:59,710
people asked me that yesterday evening

00:00:55,420 --> 00:01:04,089
so that's that's that otherwise i'm

00:00:59,710 --> 00:01:07,660
still doing composure and so on so let's

00:01:04,089 --> 00:01:11,770
stop with some some history it all

00:01:07,660 --> 00:01:15,940
started in the in the 50s where Steven

00:01:11,770 --> 00:01:19,119
Cole clean I was a mathematician hold

00:01:15,940 --> 00:01:22,840
paper about natural languages I girl

00:01:19,119 --> 00:01:25,060
languages say and that was kind of the

00:01:22,840 --> 00:01:27,490
basis for regular expressions so it

00:01:25,060 --> 00:01:31,720
included some of the like some of the

00:01:27,490 --> 00:01:33,520
syntax we see but then like for 10 years

00:01:31,720 --> 00:01:36,580
nothing happened and then ken Thompson

00:01:33,520 --> 00:01:41,709
came around and about this like early

00:01:36,580 --> 00:01:44,560
days editor called QE QE d and that was

00:01:41,709 --> 00:01:46,810
like using regular expressions too much

00:01:44,560 --> 00:01:49,569
like to do searchin and so in the in the

00:01:46,810 --> 00:01:51,759
files then few years later he started

00:01:49,569 --> 00:01:56,140
working on linux and built another

00:01:51,759 --> 00:01:58,390
editor like ed that also had those

00:01:56,140 --> 00:02:02,530
features in and one of the features was

00:01:58,390 --> 00:02:06,550
also like called gap in a way it was

00:02:02,530 --> 00:02:09,340
just like GE /a /p that was meaning like

00:02:06,550 --> 00:02:12,580
just do a global search for regular

00:02:09,340 --> 00:02:14,440
expression and print the results and so

00:02:12,580 --> 00:02:17,140
that's kind of the name well the name

00:02:14,440 --> 00:02:19,180
grab came from right so was just

00:02:17,140 --> 00:02:24,230
extracted out of the editor into the its

00:02:19,180 --> 00:02:26,959
own command then like in the 80s

00:02:24,230 --> 00:02:28,700
talking like 30 years after the initial

00:02:26,959 --> 00:02:33,140
paper which everything is canon that's

00:02:28,700 --> 00:02:35,480
how how slow this this evolved we have

00:02:33,140 --> 00:02:39,590
told that just took it in and added a

00:02:35,480 --> 00:02:40,849
bunch of features ten years later pcl he

00:02:39,590 --> 00:02:43,790
came about that's like the

00:02:40,849 --> 00:02:46,849
perl-compatible devotion so it's just a

00:02:43,790 --> 00:02:49,069
celebrity that we re implements a bunch

00:02:46,849 --> 00:02:52,280
of the pearl features and that's what's

00:02:49,069 --> 00:02:57,920
used in PHP so if you do a preg match in

00:02:52,280 --> 00:03:00,110
PHP you're using the pc a library yeah

00:02:57,920 --> 00:03:02,959
by know like PC Ellie has a lot of more

00:03:00,110 --> 00:03:06,170
features than tall so it's like pearl is

00:03:02,959 --> 00:03:10,819
the compatible one sort of it's

00:03:06,170 --> 00:03:14,269
complicated but then finally we have the

00:03:10,819 --> 00:03:15,950
the world like grape that became a verb

00:03:14,269 --> 00:03:23,209
in a noun and in the Oxford Dictionary

00:03:15,950 --> 00:03:28,730
so like what 50 years later so one thing

00:03:23,209 --> 00:03:31,069
though to mention is in like the concept

00:03:28,730 --> 00:03:32,750
of regular expressions is it's a

00:03:31,069 --> 00:03:34,910
mathematical concept so it's fairly

00:03:32,750 --> 00:03:38,540
limited in some ways like to express

00:03:34,910 --> 00:03:40,250
some very strict things and like vague

00:03:38,540 --> 00:03:41,630
axis as we have them nowadays and

00:03:40,250 --> 00:03:46,099
programming languages can do a lot more

00:03:41,630 --> 00:03:48,230
so so they go beyond the mathematical

00:03:46,099 --> 00:03:50,959
concept and I think for that is good to

00:03:48,230 --> 00:03:52,910
call them like axis and not not regular

00:03:50,959 --> 00:03:55,130
expressions because there are kind of

00:03:52,910 --> 00:03:59,540
two separate things so I'm trying to use

00:03:55,130 --> 00:04:02,650
reg ex as a term for this if you want to

00:03:59,540 --> 00:04:05,889
say regex instead it's fine i guess i

00:04:02,650 --> 00:04:11,169
don't know what to collect one is but

00:04:05,889 --> 00:04:14,540
i'll just say reg ex so let's dive in

00:04:11,169 --> 00:04:17,690
concepts first just a few moons for the

00:04:14,540 --> 00:04:20,900
talk we have patterns so patterns are

00:04:17,690 --> 00:04:23,330
just like the regular expressions there

00:04:20,900 --> 00:04:25,699
and yellow the subject string is what

00:04:23,330 --> 00:04:28,190
you're matching against and the match is

00:04:25,699 --> 00:04:31,760
is what comes out to it like out of the

00:04:28,190 --> 00:04:35,229
reg ex engine so patterns are made of

00:04:31,760 --> 00:04:37,550
characters and metacharacters simple

00:04:35,229 --> 00:04:37,940
actual characters or anything that is

00:04:37,550 --> 00:04:40,790
not

00:04:37,940 --> 00:04:43,190
meta collector and we'll go through the

00:04:40,790 --> 00:04:45,080
metal ones but basically yeah those

00:04:43,190 --> 00:04:48,500
those to kind of match the same they

00:04:45,080 --> 00:04:51,800
match this this youth wing this is pace

00:04:48,500 --> 00:04:53,570
after if you wanna escape metacharacters

00:04:51,800 --> 00:04:56,000
you can escape them with the backslash

00:04:53,570 --> 00:04:58,010
as usual oh you can also use the

00:04:56,000 --> 00:05:01,430
backslash capital Q and backslash

00:04:58,010 --> 00:05:05,530
capital e to do like quote and quote so

00:05:01,430 --> 00:05:10,360
everything between those is just escaped

00:05:05,530 --> 00:05:12,890
so those two a kind of equivalent and

00:05:10,360 --> 00:05:14,870
then to get a bit more interesting we

00:05:12,890 --> 00:05:16,610
have character classes I guess you're

00:05:14,870 --> 00:05:18,980
all familiar with these as well but I

00:05:16,610 --> 00:05:23,000
just go through to everything so so

00:05:18,980 --> 00:05:25,250
we're on the same page so those just

00:05:23,000 --> 00:05:26,450
define like that with between the

00:05:25,250 --> 00:05:28,130
brackets that we have a set of

00:05:26,450 --> 00:05:30,830
characters and we say okay we want to

00:05:28,130 --> 00:05:34,520
match one of these so this has to match

00:05:30,830 --> 00:05:36,680
one of either a B C or D and then we can

00:05:34,520 --> 00:05:38,510
extend that with ranges with the dash we

00:05:36,680 --> 00:05:40,880
can say okay any character between this

00:05:38,510 --> 00:05:42,530
and that code point it's important to

00:05:40,880 --> 00:05:45,440
know that is code points and not just

00:05:42,530 --> 00:05:49,040
characters because if you if you do a

00:05:45,440 --> 00:05:50,690
capital A two lowercase Z since these

00:05:49,040 --> 00:05:54,020
are code points you just look at the the

00:05:50,690 --> 00:05:56,780
ASCII table and like between all this

00:05:54,020 --> 00:05:58,220
you have a bunch of garbage collectors

00:05:56,780 --> 00:06:01,010
in the middle there that you probably

00:05:58,220 --> 00:06:04,550
didn't mean to walk to match so just

00:06:01,010 --> 00:06:06,380
keep in mind that this is a it's not

00:06:04,550 --> 00:06:09,680
smart like it doesn't understand your

00:06:06,380 --> 00:06:13,520
meaning it's just computers right code

00:06:09,680 --> 00:06:16,370
points that's it you can negate the

00:06:13,520 --> 00:06:18,490
class with the kite so just I think the

00:06:16,370 --> 00:06:25,580
correct means anything that is not

00:06:18,490 --> 00:06:27,710
between a to z and in a space and

00:06:25,580 --> 00:06:29,960
finally again escaping it just use the

00:06:27,710 --> 00:06:31,669
back stash but most things don't have to

00:06:29,960 --> 00:06:33,890
be escaped actually within the the

00:06:31,669 --> 00:06:35,419
character class is only a few characters

00:06:33,890 --> 00:06:38,120
have a special meaning and those are

00:06:35,419 --> 00:06:41,450
like the slash to get the closing

00:06:38,120 --> 00:06:45,850
bracket in the dash so you don't need to

00:06:41,450 --> 00:06:45,850
go about like escaping datsun and so on

00:06:46,180 --> 00:06:50,910
you can use these again like if you

00:06:49,039 --> 00:06:54,180
think back to code points

00:06:50,910 --> 00:06:56,130
with the hexa hexadecimal escape cause

00:06:54,180 --> 00:07:00,810
like this you can do anything that's

00:06:56,130 --> 00:07:04,620
between hex 0 and 1 F which is like the

00:07:00,810 --> 00:07:06,660
range of non-printable like control

00:07:04,620 --> 00:07:08,190
characters if you want to remove all

00:07:06,660 --> 00:07:11,700
these from the string for example that

00:07:08,190 --> 00:07:13,920
there would be a good way to do that you

00:07:11,700 --> 00:07:16,560
can also match unicode which can be

00:07:13,920 --> 00:07:19,740
interesting if you want to match really

00:07:16,560 --> 00:07:22,650
weird characters again like the deranged

00:07:19,740 --> 00:07:25,230
is still the same in still good points

00:07:22,650 --> 00:07:29,300
and you have this X with the curly

00:07:25,230 --> 00:07:32,880
braces to go beyond the like the first

00:07:29,300 --> 00:07:34,530
255 characters you can use the

00:07:32,880 --> 00:07:40,980
characters in line as well it's exactly

00:07:34,530 --> 00:07:43,530
the same it looks a lot more fun then we

00:07:40,980 --> 00:07:45,660
have like since those character classes

00:07:43,530 --> 00:07:47,370
tend to be a pain to write like because

00:07:45,660 --> 00:07:50,910
they get very verbose there's a bunch of

00:07:47,370 --> 00:07:54,660
shortcuts for them so the world one is

00:07:50,910 --> 00:07:57,870
just any World collectors so any a to z

00:07:54,660 --> 00:08:00,240
capital or lowercase numbers an

00:07:57,870 --> 00:08:07,530
underscore not entirely sure why but

00:08:00,240 --> 00:08:09,600
let's just the definition so you have

00:08:07,530 --> 00:08:12,330
the world one and you have the opposite

00:08:09,600 --> 00:08:14,970
to the the backslash capital W is the

00:08:12,330 --> 00:08:16,770
reverse its any non world character you

00:08:14,970 --> 00:08:20,610
have the same four digits with D and

00:08:16,770 --> 00:08:24,690
white space with s and then you have a

00:08:20,610 --> 00:08:26,850
million others for all the like unicode

00:08:24,690 --> 00:08:29,400
style character classes so if you want

00:08:26,850 --> 00:08:31,740
to match any tie character for example

00:08:29,400 --> 00:08:34,260
there is a class for that so it's like

00:08:31,740 --> 00:08:36,120
it's going to be back / PL and then some

00:08:34,260 --> 00:08:40,410
code for thai i don't remember but oh

00:08:36,120 --> 00:08:42,599
just white tie i think and like every

00:08:40,410 --> 00:08:44,700
alphabet has a class and all the all

00:08:42,599 --> 00:08:46,380
those types of characters like the wheel

00:08:44,700 --> 00:08:48,570
circles i had in there in the previous

00:08:46,380 --> 00:08:50,460
example they're also part of some class

00:08:48,570 --> 00:08:54,990
of characters we can match specific

00:08:50,460 --> 00:08:59,610
groups like that the dot means anything

00:08:54,990 --> 00:09:02,160
but a new line and that's quite

00:08:59,610 --> 00:09:03,380
important it's like anything but a new

00:09:02,160 --> 00:09:08,160
line

00:09:03,380 --> 00:09:11,430
and you might know that if you add this

00:09:08,160 --> 00:09:15,300
s modifier at the end then the dot means

00:09:11,430 --> 00:09:18,360
really anything anything so in that case

00:09:15,300 --> 00:09:20,640
what what it kind of maps to is this

00:09:18,360 --> 00:09:23,550
like this the second example there is a

00:09:20,640 --> 00:09:25,770
backslash s malbec / capital s that

00:09:23,550 --> 00:09:28,950
means anything that's a space or not a

00:09:25,770 --> 00:09:30,690
space so that means anything right I

00:09:28,950 --> 00:09:34,020
just point this out because for example

00:09:30,690 --> 00:09:36,330
in in JavaScript you don't have the S

00:09:34,020 --> 00:09:37,980
modifier so if you want to match really

00:09:36,330 --> 00:09:40,890
anything you have to do it yourself

00:09:37,980 --> 00:09:43,740
using this kind of hack it's good to

00:09:40,890 --> 00:09:50,190
know Mike just to to have a clue how to

00:09:43,740 --> 00:09:53,010
do it then we have sub patterns so sub

00:09:50,190 --> 00:09:56,700
patterns are just like the one basis the

00:09:53,010 --> 00:09:59,370
parenthesis in this case we match bomb

00:09:56,700 --> 00:10:01,170
or boys using the alternations with the

00:09:59,370 --> 00:10:04,470
pipe you do an alternation is basically

00:10:01,170 --> 00:10:09,300
if else so it's either that or that will

00:10:04,470 --> 00:10:13,020
match one good thing there to note is

00:10:09,300 --> 00:10:16,770
you can name them and that's a thing is

00:10:13,020 --> 00:10:18,690
very important if you look at this this

00:10:16,770 --> 00:10:21,290
sort of example where you have a peg

00:10:18,690 --> 00:10:23,670
match then you store the matches

00:10:21,290 --> 00:10:26,490
typically you're going to have the match

00:10:23,670 --> 00:10:28,709
0 match 1 match 2 and so on and like the

00:10:26,490 --> 00:10:31,529
one is the first player in places and

00:10:28,709 --> 00:10:33,240
two second places and so on now if you

00:10:31,529 --> 00:10:35,430
have like eight matching groups this

00:10:33,240 --> 00:10:38,250
tend to become quite painful just

00:10:35,430 --> 00:10:40,170
because you know it's like not extremely

00:10:38,250 --> 00:10:42,209
readable is as if you would write like

00:10:40,170 --> 00:10:46,650
code with your variables being all

00:10:42,209 --> 00:10:48,830
numbers which is be insane the other

00:10:46,650 --> 00:10:51,300
issue is if you modify the reg ex and

00:10:48,830 --> 00:10:55,110
add something in the beginning all the

00:10:51,300 --> 00:10:57,029
offsets are shifted by one right like

00:10:55,110 --> 00:11:01,020
all everything that follows is just like

00:10:57,029 --> 00:11:02,790
plus 1 and in the counter so that tends

00:11:01,020 --> 00:11:06,600
to introduce bugs fairly easily when you

00:11:02,790 --> 00:11:09,360
modify regexes so for that reason I

00:11:06,600 --> 00:11:12,150
would really advise you to to name them

00:11:09,360 --> 00:11:13,520
so you just do this like ? tea and then

00:11:12,150 --> 00:11:17,180
you have a name in the

00:11:13,520 --> 00:11:20,090
angle brackets and using that in your

00:11:17,180 --> 00:11:21,500
match other you get like match and then

00:11:20,090 --> 00:11:26,330
a key that with the with the name you

00:11:21,500 --> 00:11:28,940
sign so it's a lot easier also i forgot

00:11:26,330 --> 00:11:31,070
mentioned if you have any questions feel

00:11:28,940 --> 00:11:39,710
free to interrupt at any time and if

00:11:31,070 --> 00:11:42,410
you're in the other room I'm sorry so as

00:11:39,710 --> 00:11:45,980
I mentioned like alternations Bob or

00:11:42,410 --> 00:11:47,870
Bobby problem is the engine when it's

00:11:45,980 --> 00:11:51,350
matches something is like okay I much

00:11:47,870 --> 00:11:52,790
Bob so that's fine it stops there so in

00:11:51,350 --> 00:11:54,860
this case that's not exactly what you

00:11:52,790 --> 00:11:59,240
meant so if you swap them and have the

00:11:54,860 --> 00:12:02,930
most specific first whoops that's not

00:11:59,240 --> 00:12:05,510
what I meant to do most specifically

00:12:02,930 --> 00:12:06,980
first you just you will match the

00:12:05,510 --> 00:12:09,920
correct thing because it will first

00:12:06,980 --> 00:12:12,950
expand the Bobby and then it will find

00:12:09,920 --> 00:12:17,180
Bob if needed you can also write it with

00:12:12,950 --> 00:12:21,460
an optional sub button and this

00:12:17,180 --> 00:12:24,770
introduces this this concept of like

00:12:21,460 --> 00:12:26,570
quantifiers for for optional things

00:12:24,770 --> 00:12:29,810
right like the the parentheses there

00:12:26,570 --> 00:12:33,350
with the B is optional and this applies

00:12:29,810 --> 00:12:35,870
to the whole the whole parenthesis so

00:12:33,350 --> 00:12:37,610
quantifiers and they're mostly there to

00:12:35,870 --> 00:12:40,460
kind of deal with the uncertainty

00:12:37,610 --> 00:12:44,120
because typically if you use reg exist

00:12:40,460 --> 00:12:45,470
because you can't do like a 28 equality

00:12:44,120 --> 00:12:47,240
on something right if you know exactly

00:12:45,470 --> 00:12:50,270
what the options are you can just match

00:12:47,240 --> 00:12:52,610
on that but if you have some uncertainty

00:12:50,270 --> 00:12:54,050
than the reg exes are quite nice so

00:12:52,610 --> 00:12:59,240
there are few quantifiers that allow you

00:12:54,050 --> 00:13:01,490
to describe this the ? 401 time so

00:12:59,240 --> 00:13:04,790
that's just it's not there oh it's there

00:13:01,490 --> 00:13:07,730
and the star is the same but it's like

00:13:04,790 --> 00:13:09,830
it can be there multiple times and plus

00:13:07,730 --> 00:13:12,530
it has to be there at least once we can

00:13:09,830 --> 00:13:14,540
be there still many times and then if

00:13:12,530 --> 00:13:17,600
you need very specific rules you can use

00:13:14,540 --> 00:13:19,730
the curly braces to two circuits between

00:13:17,600 --> 00:13:24,470
like two and three times this has to be

00:13:19,730 --> 00:13:27,889
there so just some quick examples in

00:13:24,470 --> 00:13:31,670
this case Jamaican all Jamaicans

00:13:27,889 --> 00:13:34,279
is valid right ? only applies to the s

00:13:31,670 --> 00:13:38,149
because there are no braces so it only

00:13:34,279 --> 00:13:42,290
applies to what directly precedes it in

00:13:38,149 --> 00:13:45,739
this case we match sto sto like any

00:13:42,290 --> 00:13:49,480
amount of Oz is valid there we want at

00:13:45,739 --> 00:13:52,699
least one all but more is also ok and

00:13:49,480 --> 00:13:55,819
finally this one is a bit more weird if

00:13:52,699 --> 00:13:59,980
we want to match a pair of is at least

00:13:55,819 --> 00:14:02,449
once but maybe twice what we get is like

00:13:59,980 --> 00:14:03,859
first we get the matching group that has

00:14:02,449 --> 00:14:07,429
four of them in right because we've

00:14:03,859 --> 00:14:10,489
matched two pairs but then maximum we

00:14:07,429 --> 00:14:13,309
say maximum two pairs of a's so after it

00:14:10,489 --> 00:14:15,199
match to we do stops and then we will

00:14:13,309 --> 00:14:17,299
create a second matching GoPro it's like

00:14:15,199 --> 00:14:20,089
okay I got two more pairs and then

00:14:17,299 --> 00:14:26,269
finally we have only one pair so much

00:14:20,089 --> 00:14:28,249
one pair and that's fine then we can

00:14:26,269 --> 00:14:30,829
turn these into lazy quite files so by

00:14:28,249 --> 00:14:33,669
default as I show like they just take as

00:14:30,829 --> 00:14:40,819
much as they can write with this example

00:14:33,669 --> 00:14:42,399
we just take like two pails if we can if

00:14:40,819 --> 00:14:44,540
we make that lazy with a question mark

00:14:42,399 --> 00:14:46,730
so in this case the question mark

00:14:44,540 --> 00:14:50,329
doesn't mean like zero once that's a bit

00:14:46,730 --> 00:14:52,819
of a twist there if you put a question

00:14:50,329 --> 00:14:55,220
mark on a quantifier it just turns the

00:14:52,819 --> 00:14:56,720
quantifier into a lazy quantifier which

00:14:55,220 --> 00:14:59,089
means it's going to match as little as

00:14:56,720 --> 00:15:04,309
it can and just like stopped once it's

00:14:59,089 --> 00:15:06,499
certified satisfy the doors so in this

00:15:04,309 --> 00:15:08,929
case you see just match these pails like

00:15:06,499 --> 00:15:14,059
single pairs every time because that's

00:15:08,929 --> 00:15:16,819
just good enough what this can be useful

00:15:14,059 --> 00:15:19,069
for is like for an example of you know

00:15:16,819 --> 00:15:22,429
like people always say don't match HTML

00:15:19,069 --> 00:15:24,829
with regexes you could still do it I

00:15:22,429 --> 00:15:26,419
guess but anyway just highlights the

00:15:24,829 --> 00:15:28,999
problem very well because typically in

00:15:26,419 --> 00:15:33,049
HTML if you match if you want to get the

00:15:28,999 --> 00:15:35,689
contents of one tag like 1am tag and you

00:15:33,049 --> 00:15:37,549
have to well it's just by default with

00:15:35,689 --> 00:15:40,360
dot plus is going to match as much as it

00:15:37,549 --> 00:15:42,490
can until the last /em is fine

00:15:40,360 --> 00:15:44,800
and that's not really what you meant to

00:15:42,490 --> 00:15:47,500
do I guess so if you add the question

00:15:44,800 --> 00:15:50,190
mark on the + you make the plus lazy so

00:15:47,500 --> 00:15:55,019
it stops as soon as it finds the /em and

00:15:50,190 --> 00:15:55,019
there it just fixes the use case

00:16:02,010 --> 00:16:06,459
possessive quantifiers a can of the

00:16:04,540 --> 00:16:08,829
opposite of the lazy one I mean we have

00:16:06,459 --> 00:16:10,750
so by default are greedy then we have

00:16:08,829 --> 00:16:13,959
lazy to step down one notch and

00:16:10,750 --> 00:16:17,140
possessive is like making them sort of

00:16:13,959 --> 00:16:20,649
alpha greedy where they just it says do

00:16:17,140 --> 00:16:24,640
not give up your matches so that's quite

00:16:20,649 --> 00:16:27,670
difficult to explain but I have an

00:16:24,640 --> 00:16:30,190
example so in this case we see we have

00:16:27,670 --> 00:16:35,010
trigger but like we matched wigger where

00:16:30,190 --> 00:16:38,890
the first G is has a plus alright so

00:16:35,010 --> 00:16:41,050
what happens like in the first use get

00:16:38,890 --> 00:16:42,940
in the in the first line there the the

00:16:41,050 --> 00:16:46,690
first G with the plus we'll match both

00:16:42,940 --> 00:16:49,660
and then it tries to too much against

00:16:46,690 --> 00:16:51,519
the E and it cannot match that like

00:16:49,660 --> 00:16:53,589
against the second G because that just

00:16:51,519 --> 00:16:55,990
doesn't match so it will say okay okay

00:16:53,589 --> 00:16:59,079
I'm just by default I'm greedy so I

00:16:55,990 --> 00:17:01,779
consumed both geez but it's fine i can

00:16:59,079 --> 00:17:03,910
drop one so it just goes back drops one

00:17:01,779 --> 00:17:06,939
of the g's and then the second G can

00:17:03,910 --> 00:17:08,949
match their is fine in the second case

00:17:06,939 --> 00:17:11,250
we have three it's the same processed

00:17:08,949 --> 00:17:14,110
will consume three first and dropped two

00:17:11,250 --> 00:17:17,740
so that the second one in the in the

00:17:14,110 --> 00:17:20,260
pattern can be matched if we turn this

00:17:17,740 --> 00:17:22,959
into possessive using just adding a plus

00:17:20,260 --> 00:17:25,990
to the quantifier then it doesn't match

00:17:22,959 --> 00:17:28,809
anything anymore because after the first

00:17:25,990 --> 00:17:32,230
one has consumed both G's or the 3 g's

00:17:28,809 --> 00:17:34,870
in the in the second line it can't go

00:17:32,230 --> 00:17:37,299
back it cannot give up on some of the

00:17:34,870 --> 00:17:40,270
things it matched so it's just saying

00:17:37,299 --> 00:17:42,640
okay well that's it like there is no

00:17:40,270 --> 00:17:45,490
more g to consume after all so I can you

00:17:42,640 --> 00:17:49,860
know it's not matching if this wasn't

00:17:45,490 --> 00:17:49,860
clear I have more examples after so

00:17:51,690 --> 00:17:57,280
ankles just let you define like ankle

00:17:55,690 --> 00:17:59,560
points in the swing right so it's just

00:17:57,280 --> 00:18:04,000
saying okay this must be the beginning

00:17:59,560 --> 00:18:08,410
of the swing or the end of the swing if

00:18:04,000 --> 00:18:10,690
you if you have the M modifier let's

00:18:08,410 --> 00:18:12,370
just say it's multi line so the anchor

00:18:10,690 --> 00:18:15,930
points become end in the beginning of

00:18:12,370 --> 00:18:18,510
the line of each line in your string

00:18:15,930 --> 00:18:20,710
instead of being like end of the string

00:18:18,510 --> 00:18:22,990
so that would look like this if you

00:18:20,710 --> 00:18:25,230
imagine like any kind of amount of

00:18:22,990 --> 00:18:27,720
emails in a string that's multi-line

00:18:25,230 --> 00:18:30,460
this this would look something like that

00:18:27,720 --> 00:18:36,220
don't use this email pattern in

00:18:30,460 --> 00:18:38,710
production but it's just a demo this is

00:18:36,220 --> 00:18:40,840
one problem though the dollar is

00:18:38,710 --> 00:18:42,550
actually like the definition of it is

00:18:40,840 --> 00:18:45,250
not really the end of the string is the

00:18:42,550 --> 00:18:48,100
end of the string all just before a new

00:18:45,250 --> 00:18:50,830
line at the end of the string so if you

00:18:48,100 --> 00:18:55,080
if your swing is terminated by a new

00:18:50,830 --> 00:18:58,240
line the dollar will still match which

00:18:55,080 --> 00:19:00,880
can be okay but can also mess you up I

00:18:58,240 --> 00:19:02,920
think depending what you do like in this

00:19:00,880 --> 00:19:05,470
case if you validate the email in which

00:19:02,920 --> 00:19:09,610
is say okay I want to check do I have an

00:19:05,470 --> 00:19:11,940
email in this swing and that's it like

00:19:09,610 --> 00:19:16,090
is this string just made of an email

00:19:11,940 --> 00:19:18,640
then you say okay yes it matches now do

00:19:16,090 --> 00:19:20,770
you use the result of the match like if

00:19:18,640 --> 00:19:22,810
you use what you matched right like the

00:19:20,770 --> 00:19:25,180
green part here then is fine because you

00:19:22,810 --> 00:19:26,980
extracted the image out of it but if you

00:19:25,180 --> 00:19:29,710
use the original string because you

00:19:26,980 --> 00:19:32,440
think okay it's valid email then you

00:19:29,710 --> 00:19:34,540
certainly stole something with is a new

00:19:32,440 --> 00:19:37,290
line at the end which probably isn't

00:19:34,540 --> 00:19:39,910
what you meant to do and might induce

00:19:37,290 --> 00:19:43,690
some amount of issues that I can't even

00:19:39,910 --> 00:19:47,080
conceive of so just be aware of that and

00:19:43,690 --> 00:19:51,700
maybe don't use it you can use the the

00:19:47,080 --> 00:19:54,340
backslash lowercase Z and so the capital

00:19:51,700 --> 00:19:56,740
A and lock is said like the equivalent

00:19:54,340 --> 00:19:58,720
of this correct in dollar I accepting

00:19:56,740 --> 00:20:00,490
mean really like the absolute beginning

00:19:58,720 --> 00:20:02,710
of the string and absolute end of the

00:20:00,490 --> 00:20:05,100
swing and I believe this also applies

00:20:02,710 --> 00:20:09,910
with the multi-line

00:20:05,100 --> 00:20:11,650
the multi-line modifier so if you need

00:20:09,910 --> 00:20:14,110
too much multiple lines and don't use

00:20:11,650 --> 00:20:15,790
these but if you really want to make

00:20:14,110 --> 00:20:22,570
sure you have ankles that are meaningful

00:20:15,790 --> 00:20:25,480
that's probably a bit safer back

00:20:22,570 --> 00:20:28,090
references let you do things like here

00:20:25,480 --> 00:20:31,540
if you want to match a single quotes or

00:20:28,090 --> 00:20:33,190
double quoted strings like if we take

00:20:31,540 --> 00:20:35,410
the naive approach of saying okay I have

00:20:33,190 --> 00:20:37,780
a quote that single quote double quote

00:20:35,410 --> 00:20:41,440
then I have some stuff like world

00:20:37,780 --> 00:20:43,990
characters and then I have again a

00:20:41,440 --> 00:20:46,270
single or double quote we see the

00:20:43,990 --> 00:20:48,580
problem that we match the the mixed one

00:20:46,270 --> 00:20:50,980
like the last the last quoted string is

00:20:48,580 --> 00:20:53,560
not actually valid right it has a single

00:20:50,980 --> 00:20:56,710
quote another Bell quote so that's not

00:20:53,560 --> 00:20:59,290
really what we want to do we can easily

00:20:56,710 --> 00:21:03,190
fix that with the back headphones so

00:20:59,290 --> 00:21:06,370
just adding a sub pattern there on the

00:21:03,190 --> 00:21:08,230
on the first like first quote and then

00:21:06,370 --> 00:21:11,470
we just reference it with the backslash

00:21:08,230 --> 00:21:15,010
one and so we say at this point i want

00:21:11,470 --> 00:21:17,500
to have what matched in the first one so

00:21:15,010 --> 00:21:20,110
it doesn't copy paste the first pattern

00:21:17,500 --> 00:21:24,250
really it copy paste the result of what

00:21:20,110 --> 00:21:26,830
the first sub pattern matched so in this

00:21:24,250 --> 00:21:29,830
case we see okay like in the mixed one

00:21:26,830 --> 00:21:32,140
it will say a guy had a single quote so

00:21:29,830 --> 00:21:36,760
it needs a single quote there and it

00:21:32,140 --> 00:21:39,190
doesn't match you can again do this with

00:21:36,760 --> 00:21:42,730
the wizard named sub patterns and do

00:21:39,190 --> 00:21:44,970
like a reference with two to the to the

00:21:42,730 --> 00:21:47,980
name and not just the index so that's

00:21:44,970 --> 00:21:51,040
bit more clarity so obviously bit longer

00:21:47,980 --> 00:21:53,860
but if you have long long regular

00:21:51,040 --> 00:22:00,430
expressions i think it's it's safer that

00:21:53,860 --> 00:22:05,370
way look Ahead's that you like look

00:22:00,430 --> 00:22:12,970
behind and after value behind them and

00:22:05,370 --> 00:22:16,060
after what you're currently matching so

00:22:12,970 --> 00:22:17,810
if we want to match like words that are

00:22:16,060 --> 00:22:21,410
surrounded with wildcards

00:22:17,810 --> 00:22:25,850
again naive approach she's a wild card

00:22:21,410 --> 00:22:28,130
world characters another wild card it's

00:22:25,850 --> 00:22:30,050
fine i get walks right but we match the

00:22:28,130 --> 00:22:32,600
wild cards which maybe we don't want to

00:22:30,050 --> 00:22:34,160
like for doing and I like a markdown

00:22:32,600 --> 00:22:35,780
pass or something we want to just

00:22:34,160 --> 00:22:39,910
extract the world we don't want to have

00:22:35,780 --> 00:22:42,890
to clean up the wild cards in this case

00:22:39,910 --> 00:22:46,430
we can just use those does look ahead

00:22:42,890 --> 00:22:50,050
and look behind and doing this we just

00:22:46,430 --> 00:22:54,050
say I want to have like World characters

00:22:50,050 --> 00:22:57,320
but there I want to check that before it

00:22:54,050 --> 00:23:00,140
is a wild card and after it is a wild

00:22:57,320 --> 00:23:02,270
card so this syntax there is the like

00:23:00,140 --> 00:23:06,350
I'm not gonna read that out loud because

00:23:02,270 --> 00:23:09,710
it's crazy but you're just asserting

00:23:06,350 --> 00:23:12,050
that there is something equal to that

00:23:09,710 --> 00:23:14,510
before and after but this is just an

00:23:12,050 --> 00:23:16,520
assertion it's not it's not capturing

00:23:14,510 --> 00:23:20,120
like it's not matching anything so you

00:23:16,520 --> 00:23:24,250
don't find it in the match but it is

00:23:20,120 --> 00:23:24,250
still like asserted that this is effect

00:23:26,320 --> 00:23:32,060
now if you want to do the reverse like

00:23:29,450 --> 00:23:35,390
match anything that's not surrounded by

00:23:32,060 --> 00:23:39,410
wild cards we just say okay I'm gonna

00:23:35,390 --> 00:23:41,090
use the not like I said that there is no

00:23:39,410 --> 00:23:47,360
wild card before and I said that there

00:23:41,090 --> 00:23:49,940
is no wild card after it's fine ish you

00:23:47,360 --> 00:23:51,530
might spot the problem there that we're

00:23:49,940 --> 00:23:54,050
starting to much like the middle of the

00:23:51,530 --> 00:23:56,780
world because obviously yeah like if you

00:23:54,050 --> 00:23:59,300
before the e there is no wild card so

00:23:56,780 --> 00:24:02,000
it's fine and after the second eat is

00:23:59,300 --> 00:24:06,410
also no wild card so this looks like a

00:24:02,000 --> 00:24:11,390
world without white girls around it so

00:24:06,410 --> 00:24:15,800
how we solve this there is one more like

00:24:11,390 --> 00:24:19,660
shortcut that we can use the backstage

00:24:15,800 --> 00:24:23,060
be the Baxters be expands to this whole

00:24:19,660 --> 00:24:26,690
gigantic thing that looks quite complex

00:24:23,060 --> 00:24:28,790
but really all it says is is that you

00:24:26,690 --> 00:24:30,870
either have a non world character

00:24:28,790 --> 00:24:33,630
followed by a world character

00:24:30,870 --> 00:24:36,840
oh you have a world character followed

00:24:33,630 --> 00:24:39,270
by a non world character so I've done

00:24:36,840 --> 00:24:41,250
made sense but it basically just means

00:24:39,270 --> 00:24:44,220
you're at the wall boundary like you

00:24:41,250 --> 00:24:45,780
have something that's a little nando

00:24:44,220 --> 00:24:49,110
skull on one side and not on the other

00:24:45,780 --> 00:24:52,559
side or the other way around so if you

00:24:49,110 --> 00:24:55,710
just apply that just add them again

00:24:52,559 --> 00:24:58,110
since these are just assertions they

00:24:55,710 --> 00:25:00,809
don't match anything and we solve the

00:24:58,110 --> 00:25:05,280
problem because if it's twice to match

00:25:00,809 --> 00:25:07,380
the EE there before the decay after the

00:25:05,280 --> 00:25:11,150
CP those are like what characters well

00:25:07,380 --> 00:25:11,150
not at the boundary so it does not match

00:25:11,840 --> 00:25:26,700
again if there are any questions feel

00:25:16,110 --> 00:25:31,170
free conditionals just one word don't

00:25:26,700 --> 00:25:33,330
use them like it it's probably not a

00:25:31,170 --> 00:25:35,370
good idea I can less you really know

00:25:33,330 --> 00:25:37,950
what you're doing and you really need

00:25:35,370 --> 00:25:40,679
them in one pattern you're usually

00:25:37,950 --> 00:25:42,900
better of just doing doing the match and

00:25:40,679 --> 00:25:45,090
then doing your logic in PHP or whatever

00:25:42,900 --> 00:25:46,800
language you're using just saying okay I

00:25:45,090 --> 00:25:49,290
match that I didn't match that so I'm

00:25:46,800 --> 00:25:52,290
going to another query like another preg

00:25:49,290 --> 00:25:54,800
match and so on because they tend to

00:25:52,290 --> 00:25:58,200
create like fairly convoluted stuff

00:25:54,800 --> 00:26:02,220
throwing don't want to delve into that

00:25:58,200 --> 00:26:05,580
too long we have the limiters which are

00:26:02,220 --> 00:26:08,220
traditionally slashes because I think

00:26:05,580 --> 00:26:10,530
because well in in like pearl and

00:26:08,220 --> 00:26:12,840
JavaScript and so on is kind of the only

00:26:10,530 --> 00:26:16,260
delimiter that's allowed so people tend

00:26:12,840 --> 00:26:19,230
to default to that but really kind of

00:26:16,260 --> 00:26:21,030
makes me mad because well we're working

00:26:19,230 --> 00:26:23,220
with the web and it would match a lot of

00:26:21,030 --> 00:26:25,770
URLs like it's fairly common use case to

00:26:23,220 --> 00:26:28,080
do a preg match on some URL thing and

00:26:25,770 --> 00:26:29,550
then you end up having to escape all the

00:26:28,080 --> 00:26:31,860
slashes not because there are

00:26:29,550 --> 00:26:33,960
metacharacter but because you made it

00:26:31,860 --> 00:26:38,880
your delimiter and then certainly like

00:26:33,960 --> 00:26:40,500
your pattern looks quite horrible if you

00:26:38,880 --> 00:26:44,820
just use something else like curly

00:26:40,500 --> 00:26:46,649
braces you don't have that problem so

00:26:44,820 --> 00:26:48,389
I would say like if you're in PHP you

00:26:46,649 --> 00:26:54,870
can do that if you're in JavaScript you

00:26:48,389 --> 00:26:57,149
can't but yeah that's just life pcre is

00:26:54,870 --> 00:27:02,580
pretty nice I wish it was used

00:26:57,149 --> 00:27:05,399
everywhere another like little dip just

00:27:02,580 --> 00:27:09,299
in case you want to use double quotes I

00:27:05,399 --> 00:27:13,679
would say don't because again like in

00:27:09,299 --> 00:27:16,309
PHP if you have a single quoted pattern

00:27:13,679 --> 00:27:20,669
like this and you want to match like

00:27:16,309 --> 00:27:23,340
literally just just the backslash and a

00:27:20,669 --> 00:27:25,980
dollar you actually need for backslash

00:27:23,340 --> 00:27:27,870
is already there because each pair of

00:27:25,980 --> 00:27:31,529
backstage we will resolve after the

00:27:27,870 --> 00:27:33,330
string resolution 221 backslash then

00:27:31,529 --> 00:27:36,990
you're left with one pair of black /

00:27:33,330 --> 00:27:39,389
that you can then like escape for the

00:27:36,990 --> 00:27:42,720
leg exchanging too much a backslash like

00:27:39,389 --> 00:27:44,879
it's just you know it's too many

00:27:42,720 --> 00:27:46,679
backslashes if you add like double

00:27:44,879 --> 00:27:49,879
quotes to that and have even more stuff

00:27:46,679 --> 00:27:49,879
to escape you're going to go nuts

00:27:51,200 --> 00:27:55,529
modifiers I mentioned a couple of them

00:27:53,309 --> 00:27:58,289
already but just just to quickly go over

00:27:55,529 --> 00:28:01,289
you have the I to make it case

00:27:58,289 --> 00:28:03,990
insensitive multi-line i mentioned

00:28:01,289 --> 00:28:07,340
single line as well the U is used if you

00:28:03,990 --> 00:28:10,830
need to address any unicode like

00:28:07,340 --> 00:28:12,480
character class or even the character

00:28:10,830 --> 00:28:16,409
escapes like if you need to do that then

00:28:12,480 --> 00:28:19,019
you need to add the Unicode flag the D

00:28:16,409 --> 00:28:21,809
makes the dollar the equivalent of the

00:28:19,019 --> 00:28:23,730
backstitch dead thing I just makes the

00:28:21,809 --> 00:28:26,190
dollar actually match the end of the

00:28:23,730 --> 00:28:31,110
string and not this end or maybe a new

00:28:26,190 --> 00:28:33,240
line that's another way to do it if you

00:28:31,110 --> 00:28:37,980
really want to keep using the the dollar

00:28:33,240 --> 00:28:40,470
sign to marked the end of the string and

00:28:37,980 --> 00:28:43,679
then finally we have the X which allows

00:28:40,470 --> 00:28:46,289
you to add white space and like more

00:28:43,679 --> 00:28:51,929
comments and I would say that's probably

00:28:46,289 --> 00:28:53,460
a good idea because like if if you have

00:28:51,929 --> 00:28:56,629
something like this for example let's

00:28:53,460 --> 00:29:00,840
not extremely self-descriptive

00:28:56,629 --> 00:29:03,450
like the you know the this backslash x1

00:29:00,840 --> 00:29:07,740
F for a nine I don't know who knows all

00:29:03,450 --> 00:29:10,289
the Unicode these caves but you probably

00:29:07,740 --> 00:29:13,769
don't so if you use the x modifier you

00:29:10,289 --> 00:29:16,559
can just expand that and have have a

00:29:13,769 --> 00:29:18,330
bunch of comments and so you have you

00:29:16,559 --> 00:29:21,659
know you say ok there's like a pile of

00:29:18,330 --> 00:29:28,610
poo character and so that's a lot more

00:29:21,659 --> 00:29:31,590
clear now one thing to take care of is

00:29:28,610 --> 00:29:33,210
like you see here we had a space in

00:29:31,590 --> 00:29:37,470
between right we have the googly eye

00:29:33,210 --> 00:29:41,519
thing and then a space and then the pile

00:29:37,470 --> 00:29:43,769
of poo so as you see with the ex

00:29:41,519 --> 00:29:45,899
modifier is okay space is actually don't

00:29:43,769 --> 00:29:48,570
matter like they are not relevant if you

00:29:45,899 --> 00:29:50,940
want to match explicitly a space here

00:29:48,570 --> 00:29:52,769
you need to escape it so you need to say

00:29:50,940 --> 00:29:57,049
okay that's that's the natural space not

00:29:52,769 --> 00:29:57,049
just like some white space in my pattern

00:29:57,649 --> 00:30:04,529
this I would argue is very important as

00:30:00,629 --> 00:30:07,289
well like just if you want to to improve

00:30:04,529 --> 00:30:10,710
readability so just as an example we

00:30:07,289 --> 00:30:13,309
have an extremely long pattern that's in

00:30:10,710 --> 00:30:18,809
composer is made to match the license

00:30:13,309 --> 00:30:21,720
don't ask the the package license is

00:30:18,809 --> 00:30:25,080
just like dis dis standard for that and

00:30:21,720 --> 00:30:28,799
so this long pattern and page 2 of the

00:30:25,080 --> 00:30:30,779
long pattern is as just doing that when

00:30:28,799 --> 00:30:32,940
you see it's a bunch of conditionals and

00:30:30,779 --> 00:30:35,250
like back references to things and so on

00:30:32,940 --> 00:30:37,110
says it's getting really complex but

00:30:35,250 --> 00:30:39,000
it's also down the line it's a lot of

00:30:37,110 --> 00:30:41,059
comments like this quite a lot of

00:30:39,000 --> 00:30:44,759
content in there is just comments and

00:30:41,059 --> 00:30:47,309
without that if you like contact it all

00:30:44,759 --> 00:30:50,340
to one long thing without y space or

00:30:47,309 --> 00:30:56,580
comments like forget it there's no way

00:30:50,340 --> 00:31:00,289
ever anyone will touch this ok so that

00:30:56,580 --> 00:31:00,289
there was that for the features a thing

00:31:02,180 --> 00:31:08,730
now let's look at the engine and like

00:31:04,860 --> 00:31:10,500
how they actually walk I mentioned this

00:31:08,730 --> 00:31:13,140
shortly already but like the first match

00:31:10,500 --> 00:31:16,080
wins so if once it found a match it just

00:31:13,140 --> 00:31:19,230
stops there so we need to keep that in

00:31:16,080 --> 00:31:23,610
mind with that you will usually notice

00:31:19,230 --> 00:31:26,220
it anyway pretty quickly the other point

00:31:23,610 --> 00:31:28,440
is that the the engine prefers to match

00:31:26,220 --> 00:31:30,840
like the whole pattern and not to match

00:31:28,440 --> 00:31:34,080
the whole pattern so if if it had

00:31:30,840 --> 00:31:38,820
something like in this case if you look

00:31:34,080 --> 00:31:41,190
at what really happens in the engine now

00:31:38,820 --> 00:31:42,690
in the second one very so you can I get

00:31:41,190 --> 00:31:46,980
maybe how to follow if you don't see the

00:31:42,690 --> 00:31:49,980
laser you have on the left you cannot

00:31:46,980 --> 00:31:51,840
try to use words in the laser on the

00:31:49,980 --> 00:31:54,480
left you have the the pattern that's

00:31:51,840 --> 00:31:55,740
like so you have two heads in the engine

00:31:54,480 --> 00:31:57,270
you have one head that follows the

00:31:55,740 --> 00:32:00,270
pattern and you have one head that

00:31:57,270 --> 00:32:01,710
follows the string and on the left you

00:32:00,270 --> 00:32:05,880
have the pattern on the right the

00:32:01,710 --> 00:32:09,450
subject string so it just goes in it

00:32:05,880 --> 00:32:11,460
matches the set of set fool I'd match is

00:32:09,450 --> 00:32:15,390
set so it's happy jumps at the end of

00:32:11,460 --> 00:32:18,390
that on line 7 I jumps to ball and it

00:32:15,390 --> 00:32:20,910
tries to match bar but that doesn't

00:32:18,390 --> 00:32:23,280
happen so it's okay I can't match the

00:32:20,910 --> 00:32:25,230
overall thing so I gotta go back and try

00:32:23,280 --> 00:32:27,720
something else so you see this web

00:32:25,230 --> 00:32:31,080
backtrack there that just means the the

00:32:27,720 --> 00:32:34,380
head on the a.d.d pattern level like the

00:32:31,080 --> 00:32:36,420
left left hand side the head just went

00:32:34,380 --> 00:32:40,050
back into the pattern to try something

00:32:36,420 --> 00:32:42,480
else oh like it just backtracks to some

00:32:40,050 --> 00:32:44,910
position so in this case we try the

00:32:42,480 --> 00:32:46,740
other bunch of setups at foo and it

00:32:44,910 --> 00:32:48,990
matches again match is set foo and at

00:32:46,740 --> 00:32:52,170
the end line 15 it tries again too much

00:32:48,990 --> 00:32:56,850
bar in this case it was so we matched

00:32:52,170 --> 00:32:58,950
successfully but you see that like since

00:32:56,850 --> 00:33:01,530
it couldn't match with the first one

00:32:58,950 --> 00:33:03,900
like even though we we have this this

00:33:01,530 --> 00:33:05,520
first pattern here we use settle settle

00:33:03,900 --> 00:33:07,680
which is not really the right way to do

00:33:05,520 --> 00:33:11,480
it it still found a way too much because

00:33:07,680 --> 00:33:11,480
it like it had to

00:33:14,820 --> 00:33:20,560
so as I explained here we have this back

00:33:17,410 --> 00:33:23,980
tracking now if we take this again this

00:33:20,560 --> 00:33:25,960
email pattern and we try to two subjects

00:33:23,980 --> 00:33:28,540
twing like one that's a valid email like

00:33:25,960 --> 00:33:31,270
food at bout that code at UK the other

00:33:28,540 --> 00:33:32,800
one is bout that code at UK dat foo and

00:33:31,270 --> 00:33:34,570
then as it dot at the end and that's the

00:33:32,800 --> 00:33:37,000
key points that the dot at the end is

00:33:34,570 --> 00:33:38,650
really invalid the food in it in itself

00:33:37,000 --> 00:33:40,240
is not really a big issue it like it

00:33:38,650 --> 00:33:42,790
could be a valid subdomain these days

00:33:40,240 --> 00:33:44,950
you just like I don't even know what a

00:33:42,790 --> 00:33:49,630
valid subdue me like top-level domains

00:33:44,950 --> 00:33:53,160
anymore so the button looks like this

00:33:49,630 --> 00:33:55,600
right you have not add sign and then

00:33:53,160 --> 00:33:58,030
like one or more times then you have an

00:33:55,600 --> 00:34:01,270
at sign and then you have like the first

00:33:58,030 --> 00:34:04,390
part of the domain followed by a dot and

00:34:01,270 --> 00:34:06,340
then another domain thoughts and this

00:34:04,390 --> 00:34:08,860
whole block at the end can be multiple

00:34:06,340 --> 00:34:10,630
times as well because like in the UK

00:34:08,860 --> 00:34:12,010
with the dot code that UK need to match

00:34:10,630 --> 00:34:17,560
more than one right or if you have

00:34:12,010 --> 00:34:19,679
subdomains you also need to so if we

00:34:17,560 --> 00:34:23,320
look at some like the successful match

00:34:19,679 --> 00:34:25,179
we have again like it goes through and

00:34:23,320 --> 00:34:27,429
it matches everything like until the

00:34:25,179 --> 00:34:31,390
domain it's very very straightforward

00:34:27,429 --> 00:34:33,970
and then we have nine ten we have the

00:34:31,390 --> 00:34:40,480
first backpack because it sees okay like

00:34:33,970 --> 00:34:43,570
after it matched the bar the dot co

00:34:40,480 --> 00:34:46,240
either so it matches that co then I

00:34:43,570 --> 00:34:47,740
jumps at the end and it's like okay I

00:34:46,240 --> 00:34:49,780
have a plus there so I need to keep

00:34:47,740 --> 00:34:53,320
trying so just keep trying and it

00:34:49,780 --> 00:34:55,030
matches the UK as well then it keeps

00:34:53,320 --> 00:34:58,210
trying but there's nothing left so I

00:34:55,030 --> 00:35:00,340
just said okay like I'm I'm done here 9

00:34:58,210 --> 00:35:06,300
13 it back fact there's not too much so

00:35:00,340 --> 00:35:09,130
it just finishes with that jumps out and

00:35:06,300 --> 00:35:10,900
and checks that this like the dollar is

00:35:09,130 --> 00:35:15,370
matching so how we at the end of the

00:35:10,900 --> 00:35:18,370
swing yes good successful match now we

00:35:15,370 --> 00:35:22,960
look at the other one so the the invalid

00:35:18,370 --> 00:35:23,740
email there you see what's called like

00:35:22,960 --> 00:35:27,330
Tippi

00:35:23,740 --> 00:35:30,940
the catastrophic backtracking pattern

00:35:27,330 --> 00:35:33,490
well like again it is pretty much the

00:35:30,940 --> 00:35:35,950
same until this line 16 well we just

00:35:33,490 --> 00:35:38,500
matched everything and then still it's

00:35:35,950 --> 00:35:41,730
in the in the in the plaster it tries to

00:35:38,500 --> 00:35:45,820
match it matches the dot that's fine but

00:35:41,730 --> 00:35:50,520
then it tries to much line 17 tries to

00:35:45,820 --> 00:35:55,360
match the some more domain world and

00:35:50,520 --> 00:35:57,520
there is just nothing so it says okay

00:35:55,360 --> 00:36:00,820
well that didn't work so I'm just going

00:35:57,520 --> 00:36:03,520
to backtrack and there's two things

00:36:00,820 --> 00:36:06,100
while backtracking it back tracks like

00:36:03,520 --> 00:36:08,590
on the left side but it also drops some

00:36:06,100 --> 00:36:11,770
characters on the right so it just it

00:36:08,590 --> 00:36:13,990
says okay like if I drop the dot and I

00:36:11,770 --> 00:36:17,410
act so it kind of drops the whole match

00:36:13,990 --> 00:36:19,990
here then jumps out and sees you know

00:36:17,410 --> 00:36:22,960
maybe that's going to walk so we have to

00:36:19,990 --> 00:36:26,020
try look is there like are we at the end

00:36:22,960 --> 00:36:28,660
of the swing now nope okay that didn't

00:36:26,020 --> 00:36:32,260
work alright so let's go back back back

00:36:28,660 --> 00:36:35,800
again we were here so just drop the last

00:36:32,260 --> 00:36:38,680
oh and try again are we not at the end

00:36:35,800 --> 00:36:41,380
of the swing nope damn okay stop another

00:36:38,680 --> 00:36:43,690
oh and again and again again so you see

00:36:41,380 --> 00:36:48,700
they just like drops everything I

00:36:43,690 --> 00:36:52,780
character by character and this this can

00:36:48,700 --> 00:36:55,359
lead to situations where you have like

00:36:52,780 --> 00:36:57,310
this ever saying you exceeded the

00:36:55,359 --> 00:37:01,660
backtracking limit which is usually a

00:36:57,310 --> 00:37:04,150
one or two millions so it seems very

00:37:01,660 --> 00:37:07,869
high but you see that with just a silly

00:37:04,150 --> 00:37:10,270
quail I got like a CD pattern if I

00:37:07,869 --> 00:37:14,020
submit an email that's you know to make

00:37:10,270 --> 00:37:15,940
it two megabytes of Swing then is gonna

00:37:14,020 --> 00:37:20,470
drop them one by one and then those two

00:37:15,940 --> 00:37:25,020
million they come quickly so how do we

00:37:20,470 --> 00:37:27,280
fix that we just make it possessive so

00:37:25,020 --> 00:37:31,210
you might remember this possessive

00:37:27,280 --> 00:37:32,650
quantifiers so we just add a plus so if

00:37:31,210 --> 00:37:34,390
you look just on the on the left-hand

00:37:32,650 --> 00:37:39,069
side i just added a plus

00:37:34,390 --> 00:37:42,250
inside the domain bit where we just say

00:37:39,069 --> 00:37:45,849
like the world characters that you match

00:37:42,250 --> 00:37:48,880
you cannot give them up so in this case

00:37:45,849 --> 00:37:51,730
we still have some backtracking but only

00:37:48,880 --> 00:37:53,529
so much as we have dots because every

00:37:51,730 --> 00:37:56,019
group of letters will just be dropped at

00:37:53,529 --> 00:37:58,450
once is it can't like give one up and

00:37:56,019 --> 00:38:00,789
try again give one up try again it just

00:37:58,450 --> 00:38:03,849
says okay like this whole block it

00:38:00,789 --> 00:38:06,549
didn't match so just give it up at once

00:38:03,849 --> 00:38:09,160
and then you see at the end it goes back

00:38:06,549 --> 00:38:11,799
really quickly just like in three lines

00:38:09,160 --> 00:38:14,380
it every time it takes okay are we we at

00:38:11,799 --> 00:38:17,220
the end nope okay top the whole thing we

00:38:14,380 --> 00:38:20,079
at the end nope again again so we just

00:38:17,220 --> 00:38:21,819
we reach the same conclusion right that

00:38:20,079 --> 00:38:24,880
this is not valid email but we do it

00:38:21,819 --> 00:38:28,680
much faster so it went like from 32

00:38:24,880 --> 00:38:32,140
steps to 20 but if i post megabyte of

00:38:28,680 --> 00:38:36,339
email address you go from like a million

00:38:32,140 --> 00:38:39,009
steps to steal 20 oh you know like the

00:38:36,339 --> 00:38:41,200
difference can be quite big so i hope

00:38:39,009 --> 00:38:42,970
this clarifies really did the possessive

00:38:41,200 --> 00:38:46,480
quantifiers and what they are good for

00:38:42,970 --> 00:38:48,339
like generally you want to use them but

00:38:46,480 --> 00:38:53,500
it's it's a bit hard sometimes through

00:38:48,339 --> 00:38:55,569
to know where to use them so like i tend

00:38:53,500 --> 00:38:57,579
not to do it by default but it's really

00:38:55,569 --> 00:38:59,410
good help to do to remember because

00:38:57,579 --> 00:39:02,170
sometimes you have some performance

00:38:59,410 --> 00:39:06,190
issues and then using that skin can

00:39:02,170 --> 00:39:11,380
really save you just a quick note about

00:39:06,190 --> 00:39:14,170
the legit so in PHP 7 we have they

00:39:11,380 --> 00:39:15,819
enabled like pcr eejit so you have the

00:39:14,170 --> 00:39:18,099
just-in-time compilation there for the

00:39:15,819 --> 00:39:22,539
patterns and that makes it quite a lot

00:39:18,099 --> 00:39:26,920
faster so the faster i got there like on

00:39:22,539 --> 00:39:33,250
this this test so the jit would be like

00:39:26,920 --> 00:39:36,700
the 1x and so without the jet i got just

00:39:33,250 --> 00:39:40,480
like twice as slow so it's quite good if

00:39:36,700 --> 00:39:42,580
you double the performance there the

00:39:40,480 --> 00:39:45,340
problem i had though is

00:39:42,580 --> 00:39:47,380
like you see on the top button that

00:39:45,340 --> 00:39:49,180
didn't use the possessive quantifiers on

00:39:47,380 --> 00:39:53,200
really big files it would just like

00:39:49,180 --> 00:39:56,860
clash with the JIT so that's not really

00:39:53,200 --> 00:39:59,650
ideal but then again like there was a

00:39:56,860 --> 00:40:01,630
performance issue anyway right so like

00:39:59,650 --> 00:40:04,390
we we were like six times slower and

00:40:01,630 --> 00:40:08,170
then with the GT dude cash which kind of

00:40:04,390 --> 00:40:10,390
highlighted the issue and then once we

00:40:08,170 --> 00:40:12,130
fix the pattern we just carry three dick

00:40:10,390 --> 00:40:16,210
fast and then with the JIT it's even

00:40:12,130 --> 00:40:19,090
faster so use it or don't i'm not sure

00:40:16,210 --> 00:40:24,400
but it's there I thing is disabled by

00:40:19,090 --> 00:40:29,470
default so just a few few sample use

00:40:24,400 --> 00:40:31,690
cases of like things you can use reg ex

00:40:29,470 --> 00:40:35,800
is falling like day to day basis i would

00:40:31,690 --> 00:40:39,760
say like one thing i do a lot is social

00:40:35,800 --> 00:40:43,570
code not using an ID because i don't use

00:40:39,760 --> 00:40:46,840
an ID so it's like I understand that a

00:40:43,570 --> 00:40:50,200
lot of this is easier with an ID but I

00:40:46,840 --> 00:40:52,330
end up searching a lot with regexes and

00:40:50,200 --> 00:40:54,670
like in some cases I think you know

00:40:52,330 --> 00:40:56,380
stuff like this you can't do it like PHP

00:40:54,670 --> 00:40:58,600
stone is really good but it's not that

00:40:56,380 --> 00:41:01,960
good you can't ask it for any function

00:40:58,600 --> 00:41:05,410
call to dysfunction with this argument I

00:41:01,960 --> 00:41:07,090
think and less like I should stop saying

00:41:05,410 --> 00:41:11,860
that because one day guy is gonna come

00:41:07,090 --> 00:41:14,350
up like no we fixed it I think you still

00:41:11,860 --> 00:41:16,780
can so anyway like this is a simple way

00:41:14,350 --> 00:41:19,690
right and what I want to highlight here

00:41:16,780 --> 00:41:22,750
is that like this pattern is completely

00:41:19,690 --> 00:41:25,720
wrong like it's obviously this doesn't

00:41:22,750 --> 00:41:28,300
match only if the if test so you have

00:41:25,720 --> 00:41:30,070
like football and then just we want to

00:41:28,300 --> 00:41:33,760
have a bracket here to know that we're

00:41:30,070 --> 00:41:37,210
in a function call then we have random

00:41:33,760 --> 00:41:39,160
anything and then test right and I use

00:41:37,210 --> 00:41:41,920
the back stairs be there because let's

00:41:39,160 --> 00:41:44,080
say I want the string test I don't want

00:41:41,920 --> 00:41:46,060
to do the whole pattern is the you know

00:41:44,080 --> 00:41:47,710
the single quotes or double quotes and

00:41:46,060 --> 00:41:49,600
so on I just want the string test

00:41:47,710 --> 00:41:50,500
somehow they limited it doesn't matter

00:41:49,600 --> 00:41:53,089
much

00:41:50,500 --> 00:41:55,849
so this won't match it only if it's the

00:41:53,089 --> 00:41:58,250
third but it matches and it's probably

00:41:55,849 --> 00:42:01,700
good enough and that's I think it's very

00:41:58,250 --> 00:42:05,900
important is to see like what the domain

00:42:01,700 --> 00:42:08,089
is and you know what what can you get

00:42:05,900 --> 00:42:10,490
away with anyway like depending on the

00:42:08,089 --> 00:42:13,250
on the exact situation you might need to

00:42:10,490 --> 00:42:15,920
be more or less straight so if you if

00:42:13,250 --> 00:42:18,859
you get like 200 results with that maybe

00:42:15,920 --> 00:42:21,349
just add some more specificity but by

00:42:18,859 --> 00:42:23,059
default this folding and I walk like if

00:42:21,349 --> 00:42:24,770
you if you find 10 results in your code

00:42:23,059 --> 00:42:28,480
base you can probably go through them

00:42:24,770 --> 00:42:28,480
quicker than you will treat your legs

00:42:28,779 --> 00:42:35,390
like similarly next another again like

00:42:33,500 --> 00:42:38,270
these are not perfect example but i

00:42:35,390 --> 00:42:40,430
think they highlight something if we

00:42:38,270 --> 00:42:43,700
want to have let's see we have a class

00:42:40,430 --> 00:42:45,980
foo and so we usually store it in a

00:42:43,700 --> 00:42:47,510
dollar fool all right but if you are not

00:42:45,980 --> 00:42:49,880
consistent this is not going to work

00:42:47,510 --> 00:42:51,980
like if you search for something that's

00:42:49,880 --> 00:42:54,829
called foo and then we called set

00:42:51,980 --> 00:42:56,270
something on it it depends a bit how

00:42:54,829 --> 00:42:58,490
your code like if you feel more

00:42:56,270 --> 00:43:01,700
consistent it will pay up and pay back

00:42:58,490 --> 00:43:07,819
at that point but might not apply to all

00:43:01,700 --> 00:43:09,799
club is stripping stuff it's really easy

00:43:07,819 --> 00:43:12,289
with like plague replace you if you say

00:43:09,799 --> 00:43:16,010
you want to remove a prefix he could do

00:43:12,289 --> 00:43:20,510
this you know using a if likes to pose

00:43:16,010 --> 00:43:22,279
like if there's a you know I 00 in a

00:43:20,510 --> 00:43:24,200
substring like saying okay if the first

00:43:22,279 --> 00:43:26,210
characters of that string are those for

00:43:24,200 --> 00:43:28,640
first characters then I'm gonna do

00:43:26,210 --> 00:43:30,650
substring and remove them sure but then

00:43:28,640 --> 00:43:33,980
you have like a if block and so on I

00:43:30,650 --> 00:43:36,319
think that's a lot easier like that just

00:43:33,980 --> 00:43:38,390
have one line and it's it's pretty clear

00:43:36,319 --> 00:43:44,029
and readable like I think anyone can

00:43:38,390 --> 00:43:46,039
pretty quickly understand it similarly

00:43:44,029 --> 00:43:51,230
for like trading white space for example

00:43:46,039 --> 00:43:55,520
very simple this one may be not very

00:43:51,230 --> 00:43:57,910
simple I just led I don't want to go

00:43:55,520 --> 00:44:01,190
through it like in extreme details but

00:43:57,910 --> 00:44:03,140
it's just it's what we're using composer

00:44:01,190 --> 00:44:05,090
for for finding

00:44:03,140 --> 00:44:08,930
classes like when you use the class map

00:44:05,090 --> 00:44:12,350
or to load stuff this just has to find a

00:44:08,930 --> 00:44:14,180
class like any class in any file doesn't

00:44:12,350 --> 00:44:16,430
matter how it's called or in which path

00:44:14,180 --> 00:44:20,330
it is just like scans all the files and

00:44:16,430 --> 00:44:25,250
finds classes so this has to be like

00:44:20,330 --> 00:44:27,980
really correct inflexible and at first

00:44:25,250 --> 00:44:29,570
we used like token get all because

00:44:27,980 --> 00:44:32,030
that's the obvious way to do this

00:44:29,570 --> 00:44:34,490
correctly to talk and get all so that

00:44:32,030 --> 00:44:37,250
you get the PHP tokenizer that tweeze

00:44:34,490 --> 00:44:38,960
the file he turns you now is like all

00:44:37,250 --> 00:44:40,310
the tokens in that files you can loop

00:44:38,960 --> 00:44:42,350
through them and when you find a class

00:44:40,310 --> 00:44:44,570
token you know you got a class named

00:44:42,350 --> 00:44:47,170
following so just go to the next token

00:44:44,570 --> 00:44:51,170
get the class name easy and collect

00:44:47,170 --> 00:44:53,630
problem is there's someone out there

00:44:51,170 --> 00:44:56,930
with a file that has like two megabytes

00:44:53,630 --> 00:45:00,530
of PHP in it I don't know why but it's

00:44:56,930 --> 00:45:04,310
just life there's a lot of stuff out

00:45:00,530 --> 00:45:06,260
there that you wouldn't expect and token

00:45:04,310 --> 00:45:09,350
get all in these cases will just blow up

00:45:06,260 --> 00:45:10,790
because like memory usage which goes

00:45:09,350 --> 00:45:12,920
through the roof because it passes the

00:45:10,790 --> 00:45:15,920
whole file and like creates a token for

00:45:12,920 --> 00:45:17,870
every real thing and so you just explode

00:45:15,920 --> 00:45:20,750
the memory usage so we had to pretty

00:45:17,870 --> 00:45:23,090
early on replace that simple some other

00:45:20,750 --> 00:45:26,240
solution and so what we ended up doing

00:45:23,090 --> 00:45:28,070
there is I'm doing something that by

00:45:26,240 --> 00:45:30,590
default you might thing is completely

00:45:28,070 --> 00:45:33,440
nuts and impossible because if you think

00:45:30,590 --> 00:45:36,560
about it matching class followed by some

00:45:33,440 --> 00:45:39,260
name in a PHP file like a lot of stuff

00:45:36,560 --> 00:45:41,570
can go on you typically you're going to

00:45:39,260 --> 00:45:44,630
have at class or something annotation in

00:45:41,570 --> 00:45:46,400
the comments or someone just having a

00:45:44,630 --> 00:45:48,290
sentence what is the world class you

00:45:46,400 --> 00:45:50,960
needing some come in somewhere or like a

00:45:48,290 --> 00:45:53,960
string that has class whatever you know

00:45:50,960 --> 00:45:56,360
this like a lot of stuff can go on so

00:45:53,960 --> 00:45:58,310
what we just have to do there is like we

00:45:56,360 --> 00:46:01,190
move the uncertainty in like clean up

00:45:58,310 --> 00:46:04,430
the domain to a level that we can

00:46:01,190 --> 00:46:06,410
actually apply reg access to it and so

00:46:04,430 --> 00:46:08,570
if you look at the main steps it's like

00:46:06,410 --> 00:46:11,510
removing all the other Hill dogs in the

00:46:08,570 --> 00:46:14,720
no dogs so that's just those are easy to

00:46:11,510 --> 00:46:16,790
match with regexes you remove them

00:46:14,720 --> 00:46:19,550
we remove all the strings after that

00:46:16,790 --> 00:46:21,109
because those are all so easy and again

00:46:19,550 --> 00:46:22,460
like they're you know if we mess up and

00:46:21,109 --> 00:46:25,400
remove a string in the comment it

00:46:22,460 --> 00:46:28,040
doesn't matter right so it's all about

00:46:25,400 --> 00:46:32,300
like having the right order and and kind

00:46:28,040 --> 00:46:35,599
of knowing the domain then we remove

00:46:32,300 --> 00:46:37,580
like non PHP code and at the end were

00:46:35,599 --> 00:46:40,640
left with something that's like kind of

00:46:37,580 --> 00:46:43,310
just PHP enough that we can match class

00:46:40,640 --> 00:46:52,190
followed by some class name and it as

00:46:43,310 --> 00:46:54,380
far as I know never fails yeah just also

00:46:52,190 --> 00:46:56,480
really short example if you wanna split

00:46:54,380 --> 00:46:59,000
tags let's say if you have like a user

00:46:56,480 --> 00:47:01,220
submitted tag list that can be the spit

00:46:59,000 --> 00:47:04,220
by spaces or commas because people are

00:47:01,220 --> 00:47:06,530
just inconsistent well that's a good way

00:47:04,220 --> 00:47:09,230
to do it you split by anything that's a

00:47:06,530 --> 00:47:10,760
space or a comma and you can have even

00:47:09,230 --> 00:47:13,130
like three commas and we'll just group

00:47:10,760 --> 00:47:14,690
them into one so you don't get weird

00:47:13,130 --> 00:47:20,450
issues like with explode or you would

00:47:14,690 --> 00:47:22,940
get like empty other entries and just a

00:47:20,450 --> 00:47:25,880
real quick note about grep if you use

00:47:22,940 --> 00:47:29,420
grep use whether I grabbed all the grip

00:47:25,880 --> 00:47:31,550
is the dash capital e because without

00:47:29,420 --> 00:47:35,330
that like by default grape uses the

00:47:31,550 --> 00:47:36,980
POSIX regular expressions and I don't

00:47:35,330 --> 00:47:39,830
know why exactly but they thought it was

00:47:36,980 --> 00:47:42,260
a good idea understand out to make all

00:47:39,830 --> 00:47:45,859
the metacharacters non metacharacters by

00:47:42,260 --> 00:47:47,710
default so if you have like braces and a

00:47:45,859 --> 00:47:50,150
question mark to make something optional

00:47:47,710 --> 00:47:52,640
you're going to have to escape the

00:47:50,150 --> 00:47:54,349
places and the question mark to make

00:47:52,640 --> 00:47:56,240
them into metacharacters which is

00:47:54,349 --> 00:47:58,660
completely backwards from everywhere

00:47:56,240 --> 00:48:03,020
else you use like axis so it's like I

00:47:58,660 --> 00:48:05,330
don't get this but that's just yeah how

00:48:03,020 --> 00:48:10,040
it is so definitely use that I'll just

00:48:05,330 --> 00:48:13,310
have an alias or something so a quick

00:48:10,040 --> 00:48:17,839
question considering all you may be

00:48:13,310 --> 00:48:24,940
learned who would say that this matches

00:48:17,839 --> 00:48:24,940
oh I'm gonna give you a tune two seconds

00:48:24,990 --> 00:48:39,450
oh okay who would say that doesn't match

00:48:35,300 --> 00:48:43,200
ok a few timid hands I would say that it

00:48:39,450 --> 00:48:46,320
does match did you just raise your hand

00:48:43,200 --> 00:48:50,640
that both know okay i'm not sure like i

00:48:46,320 --> 00:48:52,290
lost like okay so we have very few timid

00:48:50,640 --> 00:48:57,960
hands and many people that don't even

00:48:52,290 --> 00:49:00,930
there so it does not match and like the

00:48:57,960 --> 00:49:03,930
reason is again that this this is just

00:49:00,930 --> 00:49:06,000
like this ? equal you it's just

00:49:03,930 --> 00:49:08,400
asserting its a look ahead assertion

00:49:06,000 --> 00:49:11,760
that there is you following but it does

00:49:08,400 --> 00:49:15,690
not match it does not capture to you so

00:49:11,760 --> 00:49:19,470
if you think back to the 22 engine heads

00:49:15,690 --> 00:49:21,510
like it's it looks on the on the right

00:49:19,470 --> 00:49:23,670
side it looks that the string has

00:49:21,510 --> 00:49:27,390
something and then if that match is it

00:49:23,670 --> 00:49:29,760
moves the left hand engine head like the

00:49:27,390 --> 00:49:31,320
pattern had moves but the match head

00:49:29,760 --> 00:49:35,730
does not move it doesn't capture

00:49:31,320 --> 00:49:37,440
anything so this like just if you just

00:49:35,730 --> 00:49:40,020
match that and will match the queue

00:49:37,440 --> 00:49:43,830
because it's followed by you you it does

00:49:40,020 --> 00:49:45,630
not capture you so afterwards like on

00:49:43,830 --> 00:49:49,830
the top pattern I would try to match

00:49:45,630 --> 00:49:54,320
your eye and it just can't now who got

00:49:49,830 --> 00:49:54,320
this and he's very sure about the answer

00:49:55,369 --> 00:50:05,670
okay so how do we remain sane while

00:50:01,740 --> 00:50:09,780
using reg exes just be aware of

00:50:05,670 --> 00:50:13,530
limitations definitely like again like

00:50:09,780 --> 00:50:15,780
if we think back to this this policy of

00:50:13,530 --> 00:50:20,010
like never use vague axis for matching

00:50:15,780 --> 00:50:23,280
HTML it's like I don't really agree I

00:50:20,010 --> 00:50:25,859
mean yes it's probably a bad idea if you

00:50:23,280 --> 00:50:29,940
want to match any HTML document because

00:50:25,859 --> 00:50:31,380
yes the HTML standard has like enough

00:50:29,940 --> 00:50:33,869
stuff to shoot yourself in the foot

00:50:31,380 --> 00:50:35,690
that's for sure like you can't do it

00:50:33,869 --> 00:50:38,390
safely for any document

00:50:35,690 --> 00:50:41,569
but if you know the domain and you know

00:50:38,390 --> 00:50:43,609
that you know you have clean HTML that

00:50:41,569 --> 00:50:45,980
you ran through HTML purify or whatever

00:50:43,609 --> 00:50:49,150
and like you know that you only want to

00:50:45,980 --> 00:50:52,790
look for this exact pattern and that

00:50:49,150 --> 00:50:54,470
then is fine you know if you think okay

00:50:52,790 --> 00:50:57,079
this is applicable in this case it's

00:50:54,470 --> 00:51:00,079
good and it will save me a lot of time

00:50:57,079 --> 00:51:02,030
then by all means do it but you just

00:51:00,079 --> 00:51:05,720
have to think and like now the domain

00:51:02,030 --> 00:51:11,990
now the nada limitations as well of

00:51:05,720 --> 00:51:14,359
regular expressions in general if you

00:51:11,990 --> 00:51:17,900
match stuff I think you should keep it

00:51:14,359 --> 00:51:21,170
like fairly restrictive to begin with

00:51:17,900 --> 00:51:23,890
because if you go like dot all you know

00:51:21,170 --> 00:51:27,230
just dot plus everything all the time

00:51:23,890 --> 00:51:31,940
you're going to have surprises and the

00:51:27,230 --> 00:51:34,089
poly won't be good surprises so I think

00:51:31,940 --> 00:51:36,200
if you start like fairly restrictive

00:51:34,089 --> 00:51:38,210
then you're gonna have like false

00:51:36,200 --> 00:51:41,569
negatives well you see okay like this

00:51:38,210 --> 00:51:43,700
didn't matter it should have then sure I

00:51:41,569 --> 00:51:48,020
just extended the reg ex true to make

00:51:43,700 --> 00:51:49,790
sure that it matches and when you do

00:51:48,020 --> 00:51:54,410
that like another thing to really

00:51:49,790 --> 00:51:56,660
consider is testing like if you let's

00:51:54,410 --> 00:51:59,900
say if you would like to do TDD and you

00:51:56,660 --> 00:52:01,609
never got to I think like building a

00:51:59,900 --> 00:52:04,670
complex where x is the perfect example

00:52:01,609 --> 00:52:06,950
for tdd because it's extremely simple to

00:52:04,670 --> 00:52:08,420
have a list of things that should match

00:52:06,950 --> 00:52:11,869
a list of things that shouldn't match

00:52:08,420 --> 00:52:14,510
you put those in tests with like the

00:52:11,869 --> 00:52:18,680
data provider in in peace unit and then

00:52:14,510 --> 00:52:20,540
you run through your your reg ex and you

00:52:18,680 --> 00:52:22,910
see okay is it passing or not so you can

00:52:20,540 --> 00:52:24,950
easily build the test cases first and

00:52:22,910 --> 00:52:28,520
then walk on the legs to make it pass

00:52:24,950 --> 00:52:30,800
more and more of those tests and you

00:52:28,520 --> 00:52:32,630
really want to do that because once you

00:52:30,800 --> 00:52:34,790
have to modify your eggs in two months

00:52:32,630 --> 00:52:36,410
like you probably won't remember all the

00:52:34,790 --> 00:52:38,329
edge cases you have to think of back

00:52:36,410 --> 00:52:41,300
then so if like if you don't have a

00:52:38,329 --> 00:52:44,020
comprehensive test case this might also

00:52:41,300 --> 00:52:44,020
get quite nasty

00:52:44,230 --> 00:52:51,319
um boundaries are good to keep in mind

00:52:48,230 --> 00:52:53,510
as well like if you do matching so too

00:52:51,319 --> 00:52:55,940
much that something is present into

00:52:53,510 --> 00:52:57,859
something else the the backstitch be is

00:52:55,940 --> 00:53:00,230
good because it says okay it is

00:52:57,859 --> 00:53:04,369
somewhere in and it is at this wall

00:53:00,230 --> 00:53:05,960
boundary like it's usually useful if you

00:53:04,369 --> 00:53:08,420
do validation though you really want to

00:53:05,960 --> 00:53:10,220
use the ankles to make sure that you

00:53:08,420 --> 00:53:12,410
validate the whole swing and not just

00:53:10,220 --> 00:53:18,589
that he did that you have a valid email

00:53:12,410 --> 00:53:21,559
in this long blob of thing finally

00:53:18,589 --> 00:53:24,349
document like really remember to use

00:53:21,559 --> 00:53:28,010
those those named sub patterns and use

00:53:24,349 --> 00:53:29,930
the ex modifier to to expand and and be

00:53:28,010 --> 00:53:33,410
able to have comments and more like

00:53:29,930 --> 00:53:35,900
clarity with the white space so that's

00:53:33,410 --> 00:53:42,280
that for me I hope that you a bit less

00:53:35,900 --> 00:53:42,280
scared now yeah Thank

00:53:50,910 --> 00:53:57,850
just if we have questions we have five

00:53:55,150 --> 00:54:01,240
minutes I just have like three resources

00:53:57,850 --> 00:54:03,310
real quick but think of questions so

00:54:01,240 --> 00:54:06,280
regular expressions the info is the

00:54:03,310 --> 00:54:09,609
Bible of regexes like it has all the

00:54:06,280 --> 00:54:11,290
info and it has also all the info about

00:54:09,609 --> 00:54:13,600
all the engines and all the languages

00:54:11,290 --> 00:54:15,070
and so on so if you have to use

00:54:13,600 --> 00:54:17,350
JavaScript for example that will tell

00:54:15,070 --> 00:54:20,170
you okay this is not available you know

00:54:17,350 --> 00:54:23,440
so this is quite interesting regul X is

00:54:20,170 --> 00:54:25,840
the one I used for the flow chart style

00:54:23,440 --> 00:54:27,550
thing so it expands patterns but only

00:54:25,840 --> 00:54:31,240
suppose JavaScript so not extremely

00:54:27,550 --> 00:54:34,630
flexible and the last one like x 101 has

00:54:31,240 --> 00:54:36,670
the debugger view that you saw well you

00:54:34,630 --> 00:54:41,170
see the engine head and then the the

00:54:36,670 --> 00:54:42,940
pattern and the match and so this one is

00:54:41,170 --> 00:54:47,020
really useful and this one supports full

00:54:42,940 --> 00:54:53,080
pcre so PHP style regexes thank you any

00:54:47,020 --> 00:54:55,230
questions also if you have feedback if

00:54:53,080 --> 00:54:59,890
you want the slides once again about

00:54:55,230 --> 00:55:02,950
qatar HTML tags or maybe any tax i think

00:54:59,890 --> 00:55:05,680
you on the slide you shown a few open

00:55:02,950 --> 00:55:09,190
closed tags in a parallel what about the

00:55:05,680 --> 00:55:12,430
nested tax does lazy helps with nested

00:55:09,190 --> 00:55:14,530
know like if you have for sure if you

00:55:12,430 --> 00:55:17,200
need to match like nested HTML stuff

00:55:14,530 --> 00:55:20,619
you're gonna be in a world of pain with

00:55:17,200 --> 00:55:22,780
the ex like it might be again possible

00:55:20,619 --> 00:55:24,700
in some limited kids but I don't think

00:55:22,780 --> 00:55:27,460
it's worth it like there are definitely

00:55:24,700 --> 00:55:30,330
better tools for that so don't like

00:55:27,460 --> 00:55:35,109
you're gonna waste your time you know so

00:55:30,330 --> 00:55:37,800
yeah it's really depends on on the what

00:55:35,109 --> 00:55:37,800
you're trying to do

00:55:38,510 --> 00:55:56,280
anything else this will coming to the

00:55:44,160 --> 00:55:58,400
other two all gone damn ok nothing thank

00:55:56,280 --> 00:55:58,400

YouTube URL: https://www.youtube.com/watch?v=OqUsf6LQzPg


