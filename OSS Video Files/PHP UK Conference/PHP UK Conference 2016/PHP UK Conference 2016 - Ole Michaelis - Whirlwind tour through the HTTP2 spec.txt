Title: PHP UK Conference 2016 - Ole Michaelis - Whirlwind tour through the HTTP2 spec
Publication date: 2016-03-16
Playlist: PHP UK Conference 2016
Description: 
	The HTTP protocol has come a long way since its first version HTTP V0.9 in 1991 and with the final release of the HTTP2 spec at the beginning of 2016 a whole next chapter of web development is ahead of us! After a quick tour through the protocol history, we will mine the gems from in HTTP/2 spec and see why this is an awesome step for a modern web. What can you already use today? And why today's best practices are tomorrow's antipatterns?
Captions: 
	00:00:04,920 --> 00:00:15,120
all right everyone hi I'm German so I

00:00:11,190 --> 00:00:17,369
like to start on time so we can check

00:00:15,120 --> 00:00:20,420
the first cliche welcome to the

00:00:17,369 --> 00:00:23,130
whirlwind tour through the HTTP to spec

00:00:20,420 --> 00:00:25,230
this is the thing I have to pronounce

00:00:23,130 --> 00:00:27,240
quite often yet so better get used to my

00:00:25,230 --> 00:00:30,390
weird pronunciation on that I'm not a

00:00:27,240 --> 00:00:33,269
native ok so it's labeled whirlwind tour

00:00:30,390 --> 00:00:36,239
I try to make it well wind as good as

00:00:33,269 --> 00:00:39,180
it's possible in 60 minutes so it's not

00:00:36,239 --> 00:00:41,970
that well but kind of wind before we

00:00:39,180 --> 00:00:44,519
start I'd actually like to know who if

00:00:41,970 --> 00:00:48,120
you already uses HTTP to in production

00:00:44,519 --> 00:00:51,120
hands up one two three alright that's

00:00:48,120 --> 00:00:52,860
awesome appreciate that a lot for the

00:00:51,120 --> 00:00:54,960
other ones also for the ones who using

00:00:52,860 --> 00:00:57,869
it at actually I hope I have tons of

00:00:54,960 --> 00:00:59,909
stuff new for you and actually to get a

00:00:57,869 --> 00:01:02,040
good look behind the scenes whenever I'm

00:00:59,909 --> 00:01:05,100
talking about HIV 2 i'm giving this talk

00:01:02,040 --> 00:01:07,799
that a few questions and that pop up

00:01:05,100 --> 00:01:10,350
quite frequently so i won't get these

00:01:07,799 --> 00:01:13,170
out of our way so we can do the deep

00:01:10,350 --> 00:01:14,430
dive in this back right so let's start

00:01:13,170 --> 00:01:17,039
with that i like to make a little quiz

00:01:14,430 --> 00:01:22,350
so let's see um hands up if you think

00:01:17,039 --> 00:01:26,130
yes is it you two really done 45 Wow

00:01:22,350 --> 00:01:28,670
yesterday's since a year um is SSN

00:01:26,130 --> 00:01:31,439
mandatory ends up with you think yes

00:01:28,670 --> 00:01:35,909
that's on the quarter that's wrong it's

00:01:31,439 --> 00:01:38,609
not but all implementations you will see

00:01:35,909 --> 00:01:42,509
in the wild are only working with https

00:01:38,609 --> 00:01:44,609
so um this back supports both ways doing

00:01:42,509 --> 00:01:47,100
it encrypted and not encrypted but every

00:01:44,609 --> 00:01:49,200
browser implementation and also the like

00:01:47,100 --> 00:01:52,679
the big service only support the ssl

00:01:49,200 --> 00:01:58,890
version so it's kind of right isn't made

00:01:52,679 --> 00:02:00,539
by google I'll one yeah no it's not um

00:01:58,890 --> 00:02:02,670
what speedy that might be the obvious

00:02:00,539 --> 00:02:04,799
next question right it's in it's a

00:02:02,670 --> 00:02:07,619
different protocol it's it's something

00:02:04,799 --> 00:02:09,479
like legally or like from the from the

00:02:07,619 --> 00:02:11,039
specs and from the RFC perspective it's

00:02:09,479 --> 00:02:13,769
something completely different from the

00:02:11,039 --> 00:02:18,340
contents we'll discuss this later but

00:02:13,769 --> 00:02:21,519
it's similar it's a2g plain text

00:02:18,340 --> 00:02:25,239
hands up no one great it's not it's

00:02:21,519 --> 00:02:27,760
binary I had asked impressed ends up if

00:02:25,239 --> 00:02:29,410
you think IRAs are compressed I'll have

00:02:27,760 --> 00:02:32,560
the audience that's true how does our

00:02:29,410 --> 00:02:34,890
compress and i will also talk how they

00:02:32,560 --> 00:02:37,930
how the compression actually works I'm

00:02:34,890 --> 00:02:40,810
my favorite question with hiv-1 wants to

00:02:37,930 --> 00:02:45,250
work what do you think oh come on

00:02:40,810 --> 00:02:48,010
obviously browser still support HTTP 10

00:02:45,250 --> 00:02:50,410
0 and we will never drop the support for

00:02:48,010 --> 00:02:53,140
that because we completely break the web

00:02:50,410 --> 00:02:55,450
so if you deploy your web server make

00:02:53,140 --> 00:02:59,440
sure it supports like all versions of

00:02:55,450 --> 00:03:02,440
that great so that we get this out of

00:02:59,440 --> 00:03:04,989
our way I like to talk a little bit of

00:03:02,440 --> 00:03:08,860
history and this is important because

00:03:04,989 --> 00:03:11,379
you have to understand what's wrong with

00:03:08,860 --> 00:03:14,440
HTTP and why it is that way in order to

00:03:11,379 --> 00:03:15,970
understand why the new versions cool so

00:03:14,440 --> 00:03:17,709
you first have to understand why it

00:03:15,970 --> 00:03:23,079
sucks and then to see why the new one is

00:03:17,709 --> 00:03:25,660
good so let's start in 1989 sir tim

00:03:23,079 --> 00:03:28,269
berners-lee imagined his idea of the

00:03:25,660 --> 00:03:30,160
World Wide Web it's browsers acting as

00:03:28,269 --> 00:03:32,950
editors connecting all the different

00:03:30,160 --> 00:03:35,500
universities and research facilities to

00:03:32,950 --> 00:03:38,200
edit collaborate and create research

00:03:35,500 --> 00:03:40,739
documents that was the idea browsers in

00:03:38,200 --> 00:03:44,650
the initial draft should act as editors

00:03:40,739 --> 00:03:49,540
this idea somehow got lost on the way in

00:03:44,650 --> 00:03:54,720
1991 the first version of HP 09 was

00:03:49,540 --> 00:03:57,760
released and documented moving along in

00:03:54,720 --> 00:04:02,530
1992 there was actually the first draft

00:03:57,760 --> 00:04:06,489
for version 1.0 four years later they

00:04:02,530 --> 00:04:09,400
published it as RFC 1945 just one year

00:04:06,489 --> 00:04:12,910
later they figured it was so they

00:04:09,400 --> 00:04:15,220
released 1.1 so one has some obvious

00:04:12,910 --> 00:04:17,979
flaws you can reward Wikipedia won't go

00:04:15,220 --> 00:04:23,979
too deep into detail on that but 11 was

00:04:17,979 --> 00:04:29,890
released on 1997 and roc 2068 and then

00:04:23,979 --> 00:04:31,409
in 1998 there was RFC 2326 who if you

00:04:29,890 --> 00:04:35,879
know what that does

00:04:31,409 --> 00:04:40,349
what the specifies anyone it was

00:04:35,879 --> 00:04:42,479
released April first it is actually the

00:04:40,349 --> 00:04:46,139
RFC specifying how interconnected

00:04:42,479 --> 00:04:49,649
machines should interact with each other

00:04:46,139 --> 00:04:51,599
for making coffee and the HTTP protocol

00:04:49,649 --> 00:04:54,619
obviously cannot make coffee so it

00:04:51,599 --> 00:04:59,580
should respond with 418 I'm a teapot

00:04:54,619 --> 00:05:04,739
okay that was specified this RC let's

00:04:59,580 --> 00:05:06,959
move along okay 1999 RFC 2616 were

00:05:04,739 --> 00:05:09,569
completely replacing the old

00:05:06,959 --> 00:05:11,429
specification and that was because the

00:05:09,569 --> 00:05:14,789
ossification was kind of not clear in

00:05:11,429 --> 00:05:16,169
the way it was written down the actual

00:05:14,789 --> 00:05:18,329
implementation didn't change and the

00:05:16,169 --> 00:05:21,689
actual way how it had behaved didn't

00:05:18,329 --> 00:05:23,550
change but the way how it was written

00:05:21,689 --> 00:05:25,919
down and how the RFC was structured

00:05:23,550 --> 00:05:28,909
changed so it made the old one complete

00:05:25,919 --> 00:05:32,099
absolute then lots of stuff happened

00:05:28,909 --> 00:05:35,509
lots of little RFC's got released I

00:05:32,099 --> 00:05:38,369
guess around 1 million about cashing on

00:05:35,509 --> 00:05:42,360
in this episode and this time frame and

00:05:38,369 --> 00:05:44,249
then in 2007 the ift forms the HTV HTTP

00:05:42,360 --> 00:05:45,719
bit working group and as far as Google

00:05:44,249 --> 00:05:51,719
told me business and Latin word for two

00:05:45,719 --> 00:05:55,649
and um that job was to consolidate all

00:05:51,719 --> 00:05:58,800
the all the rfcs flung around regarding

00:05:55,649 --> 00:06:02,659
this 1.1 protocol and you will see in a

00:05:58,800 --> 00:06:07,259
bit and what the result of that was in

00:06:02,659 --> 00:06:11,069
early 2012 the ift also put out the call

00:06:07,259 --> 00:06:13,199
for proposals for hv to and in november

00:06:11,069 --> 00:06:16,469
that year google handed in the speedy

00:06:13,199 --> 00:06:19,529
protocol as kind of a base draft to

00:06:16,469 --> 00:06:21,229
iterate over to actually create hb2 so

00:06:19,529 --> 00:06:26,369
here you see how it is related right

00:06:21,229 --> 00:06:30,229
speedy is the base hiv-2 like came out

00:06:26,369 --> 00:06:35,550
of its like the successor of that and

00:06:30,229 --> 00:06:37,409
when we move on in 2014 that was the

00:06:35,550 --> 00:06:41,279
actual result of the edge of this

00:06:37,409 --> 00:06:43,949
working group they made all the RFC's

00:06:41,279 --> 00:06:44,860
regarding hp11 obsolete and released six

00:06:43,949 --> 00:06:49,289
new ones

00:06:44,860 --> 00:06:51,520
and the whole the D complete HIV 11

00:06:49,289 --> 00:06:56,310
documentation or specification is in

00:06:51,520 --> 00:06:59,199
these six documents so constellated

00:06:56,310 --> 00:07:01,090
consolidated all the other ones this was

00:06:59,199 --> 00:07:02,259
a pretty important step especially if

00:07:01,090 --> 00:07:04,020
you want to implement these kind of

00:07:02,259 --> 00:07:06,659
browsers at this service or browsers

00:07:04,020 --> 00:07:12,460
because all DRC was so scattered and

00:07:06,659 --> 00:07:15,550
somewhere even outdated so in May last

00:07:12,460 --> 00:07:19,210
year which is 10 months ago now each of

00:07:15,550 --> 00:07:21,460
you was released on RFC 7540 I'm

00:07:19,210 --> 00:07:23,319
dropping all this RFC numbers because I

00:07:21,460 --> 00:07:26,979
personally find pretty interesting to

00:07:23,319 --> 00:07:28,629
read through these but we will we don't

00:07:26,979 --> 00:07:31,180
have lots of text on the slide so if you

00:07:28,629 --> 00:07:32,919
want to read them yourself I can really

00:07:31,180 --> 00:07:37,150
recommend checking them out very

00:07:32,919 --> 00:07:38,949
interesting so at the end of 2015 so the

00:07:37,150 --> 00:07:40,900
end of last year twenty two percent of

00:07:38,949 --> 00:07:42,250
all internet traffic was already hb2 and

00:07:40,900 --> 00:07:45,520
things this is quite an impressive

00:07:42,250 --> 00:07:48,400
number right and due to the fact that HP

00:07:45,520 --> 00:07:50,490
to only works under ssl in the in the

00:07:48,400 --> 00:07:53,650
wild like in the actual implementations

00:07:50,490 --> 00:07:56,229
it makes sense to compare the number of

00:07:53,650 --> 00:07:58,930
82 traffic to the encrypted traffic of

00:07:56,229 --> 00:08:01,779
the web then if we do this conversion hv

00:07:58,930 --> 00:08:04,719
to already has thirty five percent of

00:08:01,779 --> 00:08:07,779
the whole htps traffic that's over

00:08:04,719 --> 00:08:14,259
one-third um that's pretty great i think

00:08:07,779 --> 00:08:17,830
i hope that's not the fire alarm I know

00:08:14,259 --> 00:08:19,509
it's blinking really weird um but we'll

00:08:17,830 --> 00:08:24,969
move on unless someone walks in and

00:08:19,509 --> 00:08:27,430
screams burning okay um so that was kind

00:08:24,969 --> 00:08:29,919
of the history and now to get us all the

00:08:27,430 --> 00:08:32,110
same on the same start I also like to

00:08:29,919 --> 00:08:35,800
talk really quick about the age of two

00:08:32,110 --> 00:08:39,250
basics first of all HTT HTT P is plain

00:08:35,800 --> 00:08:40,750
text so I can just spin out my telnet my

00:08:39,250 --> 00:08:42,789
terminal here and do a little tender

00:08:40,750 --> 00:08:45,130
demo so I can just open up a TCP

00:08:42,789 --> 00:08:48,640
connection to the Google server on port

00:08:45,130 --> 00:08:51,040
80 and then I can just type in the zip

00:08:48,640 --> 00:08:53,319
protocol right in plain text so I start

00:08:51,040 --> 00:08:56,290
with the status line then the host which

00:08:53,319 --> 00:08:58,190
is necessary and then you own a new line

00:08:56,290 --> 00:09:01,640
this actually makes the Google server

00:08:58,190 --> 00:09:04,070
spun I think that's pretty cool I hope

00:09:01,640 --> 00:09:06,320
you can see enough of that to actually

00:09:04,070 --> 00:09:08,480
make sense for that this will not be

00:09:06,320 --> 00:09:10,640
possible with a chibi to anymore so you

00:09:08,480 --> 00:09:14,330
can't really like tinker around that you

00:09:10,640 --> 00:09:17,140
need to have special tools it's

00:09:14,330 --> 00:09:20,270
stateless you probably all know that and

00:09:17,140 --> 00:09:22,310
this statelessness makes it super

00:09:20,270 --> 00:09:25,100
flexible and we use it for everything

00:09:22,310 --> 00:09:27,920
right we use it for uploads use it for

00:09:25,100 --> 00:09:31,310
downloads we use it for streaming we use

00:09:27,920 --> 00:09:32,720
it for api's and not only documents

00:09:31,310 --> 00:09:34,670
right it was intended to only serve

00:09:32,720 --> 00:09:38,390
documents even the idea of having assets

00:09:34,670 --> 00:09:41,780
was not the first back and but does the

00:09:38,390 --> 00:09:45,560
fact that was so flexible we could do so

00:09:41,780 --> 00:09:47,360
many things with that and if you if you

00:09:45,560 --> 00:09:49,550
see how much it is used its kind of the

00:09:47,360 --> 00:09:53,390
protocol of the web right so it's really

00:09:49,550 --> 00:09:55,940
a thing used very often but this also

00:09:53,390 --> 00:09:58,670
brought in some problems right due to

00:09:55,940 --> 00:10:01,970
the fact that was not invented to serve

00:09:58,670 --> 00:10:05,600
all these purposes and the web was not

00:10:01,970 --> 00:10:09,920
invented in that way hmv to it should be

00:10:05,600 --> 00:10:14,360
11 which is almost eight years old no 20

00:10:09,920 --> 00:10:17,540
18 years old it the web matron since

00:10:14,360 --> 00:10:20,150
then right in the last 18 years um the

00:10:17,540 --> 00:10:22,730
web has involved pretty much and here I

00:10:20,150 --> 00:10:25,550
have a graph graphing the last five

00:10:22,730 --> 00:10:27,710
years the total request size and the

00:10:25,550 --> 00:10:31,130
total transfer size and both numbers are

00:10:27,710 --> 00:10:33,650
doubled right just in the last five

00:10:31,130 --> 00:10:36,830
years and I think this will this graph

00:10:33,650 --> 00:10:40,070
will even continue the average website

00:10:36,830 --> 00:10:44,360
has 38 connections TC different TCP

00:10:40,070 --> 00:10:47,210
connections to load 11 website um this

00:10:44,360 --> 00:10:48,860
is this is a huge number and this brings

00:10:47,210 --> 00:10:50,600
a lot of problems and I think the

00:10:48,860 --> 00:10:52,580
biggest problem is what I call request

00:10:50,600 --> 00:10:55,700
bonanza this is not the official word

00:10:52,580 --> 00:10:56,870
for that so don't go for that I don't

00:10:55,700 --> 00:10:58,339
know what the results would be but it's

00:10:56,870 --> 00:11:01,430
probably not the problem I'm talking

00:10:58,339 --> 00:11:02,839
about here but what I mean it's probably

00:11:01,430 --> 00:11:04,610
thing you all know about so you have the

00:11:02,839 --> 00:11:06,920
browser here on your left and the sub on

00:11:04,610 --> 00:11:08,480
the right and in the browser is going to

00:11:06,920 --> 00:11:10,580
fetch an asset for now example it's in

00:11:08,480 --> 00:11:11,480
this HTML the server response and then

00:11:10,580 --> 00:11:13,779
in the index

00:11:11,480 --> 00:11:15,470
well you will find another acid

00:11:13,779 --> 00:11:18,260
surprising that you will find another

00:11:15,470 --> 00:11:19,850
asset then you fetch this acid and while

00:11:18,260 --> 00:11:22,970
passing this asset you will find even

00:11:19,850 --> 00:11:26,149
more assets right and you all do it back

00:11:22,970 --> 00:11:29,779
and forth so there's no real no real

00:11:26,149 --> 00:11:32,449
deal T to fetch things in parallel we'll

00:11:29,779 --> 00:11:35,420
talk about this in a second all this

00:11:32,449 --> 00:11:37,190
adds a ton of latency right and in all

00:11:35,420 --> 00:11:39,769
the recent years we have optimized for

00:11:37,190 --> 00:11:41,889
throughput and not or while that

00:11:39,769 --> 00:11:44,240
ignoring latency right we all like

00:11:41,889 --> 00:11:46,699
concatenating assets which is great for

00:11:44,240 --> 00:11:49,550
having good throughput but due to the

00:11:46,699 --> 00:11:51,649
rise of mobile we really see all the

00:11:49,550 --> 00:11:53,449
problems because this route code with 4G

00:11:51,649 --> 00:11:57,320
is pretty good right but the latency is

00:11:53,449 --> 00:11:59,149
still so when you load a lot of

00:11:57,320 --> 00:12:00,380
assets on different TCP connections you

00:11:59,149 --> 00:12:02,420
always have this overhead of

00:12:00,380 --> 00:12:06,110
establishing a connection making the

00:12:02,420 --> 00:12:07,399
handshake of its encrypted and how does

00:12:06,110 --> 00:12:10,430
it look like in the wild well i have an

00:12:07,399 --> 00:12:13,250
example here so I'm this is the verge I

00:12:10,430 --> 00:12:14,930
don't read that but it's apparently a

00:12:13,250 --> 00:12:17,360
good example and you will see in a

00:12:14,930 --> 00:12:19,519
second why so i will just load the verge

00:12:17,360 --> 00:12:20,990
in my browser and we will watch the

00:12:19,519 --> 00:12:22,790
network tab to see what's actually going

00:12:20,990 --> 00:12:25,730
on here so i have a little video here

00:12:22,790 --> 00:12:27,560
and let's fire it out and you see the

00:12:25,730 --> 00:12:29,810
first initial request already tagged

00:12:27,560 --> 00:12:35,360
some time here then you see some more

00:12:29,810 --> 00:12:38,569
assets assets assets whatever this is

00:12:35,360 --> 00:12:39,829
real time by the way right so i'm still

00:12:38,569 --> 00:12:43,699
waiting for the website so i have typed

00:12:39,829 --> 00:12:46,220
it already hit enter but nothing oh it's

00:12:43,699 --> 00:12:49,220
loaded and nobody can read this but

00:12:46,220 --> 00:12:51,949
trust me it's 12 seconds so loading the

00:12:49,220 --> 00:12:55,940
merge to the load event takes 12 seconds

00:12:51,949 --> 00:12:57,620
and i didn't like I'm cut my connection

00:12:55,940 --> 00:12:59,540
there it's just what I have at home and

00:12:57,620 --> 00:13:03,649
it's not like to add of a connection I'm

00:12:59,540 --> 00:13:07,339
living in a bigger city um I have 15 mb

00:13:03,649 --> 00:13:09,949
sing not sing but it should be right

00:13:07,339 --> 00:13:12,589
it's just a regular thing and it should

00:13:09,949 --> 00:13:14,930
it shouldn't take 12 seconds to load an

00:13:12,589 --> 00:13:18,019
average website I think and what I found

00:13:14,930 --> 00:13:21,140
even more interesting is that is not in

00:13:18,019 --> 00:13:25,040
12 seconds it is the whole web shot the

00:13:21,140 --> 00:13:25,520
whole website is 1.5 megabytes so while

00:13:25,040 --> 00:13:27,230
I'm here

00:13:25,520 --> 00:13:28,760
I'm surfing on a roaming plan and had 50

00:13:27,230 --> 00:13:31,010
megabytes included so I cannot even look

00:13:28,760 --> 00:13:36,430
this page 50 times unless my data plan

00:13:31,010 --> 00:13:41,390
is exhausted and also um this page takes

00:13:36,430 --> 00:13:44,990
170 requests to load completely 170

00:13:41,390 --> 00:13:47,600
imagine that not on not over all

00:13:44,990 --> 00:13:50,960
different hosts but i think this points

00:13:47,600 --> 00:13:54,680
out all the problems we actually have in

00:13:50,960 --> 00:13:56,690
the web on performance wise so in order

00:13:54,680 --> 00:13:58,940
to do it deeper introspection to that

00:13:56,690 --> 00:14:00,980
the same video but just slowed it down a

00:13:58,940 --> 00:14:02,450
little bit so we can better see what's

00:14:00,980 --> 00:14:05,090
going on here so there you see the

00:14:02,450 --> 00:14:07,730
initial request here you see that it

00:14:05,090 --> 00:14:10,180
starts downloading resources at the same

00:14:07,730 --> 00:14:13,220
time so it start at the same time but

00:14:10,180 --> 00:14:15,260
look that how this pattern looks like

00:14:13,220 --> 00:14:16,520
right this important what we also see

00:14:15,260 --> 00:14:19,670
here what I think is pretty interesting

00:14:16,520 --> 00:14:22,130
we have this wonderful waterfall right

00:14:19,670 --> 00:14:23,630
to really see that another resource

00:14:22,130 --> 00:14:29,270
trinkets another resource triggers

00:14:23,630 --> 00:14:31,250
another resource again same numbers just

00:14:29,270 --> 00:14:32,780
a bit more of loading time you will see

00:14:31,250 --> 00:14:34,910
all different you'll even see here for

00:14:32,780 --> 00:14:36,860
example this is an hd2 request so I

00:14:34,910 --> 00:14:39,650
think some of these advertisement

00:14:36,860 --> 00:14:45,710
networks I'm already upgraded but most

00:14:39,650 --> 00:14:47,360
of stuff is 11 all right I got mad so I

00:14:45,710 --> 00:14:50,360
did what I what I always do when I got

00:14:47,360 --> 00:14:51,770
mad dumb on Twitter and it's not

00:14:50,360 --> 00:14:54,020
something against the verge in

00:14:51,770 --> 00:14:56,120
particular right I mean if you just load

00:14:54,020 --> 00:14:59,480
your company's website take a look at

00:14:56,120 --> 00:15:01,040
the stats and see how bad you are my

00:14:59,480 --> 00:15:03,350
company's pretty bad as this as well so

00:15:01,040 --> 00:15:05,930
I don't want to blame only third parties

00:15:03,350 --> 00:15:08,480
then let's take a look at the pattern i

00:15:05,930 --> 00:15:10,400
just pointed out when i say it's not

00:15:08,480 --> 00:15:13,060
possible to fetch requests in parallel

00:15:10,400 --> 00:15:16,130
your fist admire holy you're wrong

00:15:13,060 --> 00:15:17,870
actually you can transfer mode resource

00:15:16,130 --> 00:15:20,000
on the same connection it's called

00:15:17,870 --> 00:15:22,340
connection sharing but this thing

00:15:20,000 --> 00:15:23,660
suffers from a huge problem so this is

00:15:22,340 --> 00:15:26,810
what the browser does right so the

00:15:23,660 --> 00:15:29,030
browser fetches or asks for three

00:15:26,810 --> 00:15:31,490
different resources so in our case at

00:15:29,030 --> 00:15:35,630
zenith HTML the feature CSS and then no

00:15:31,490 --> 00:15:38,660
exam escaped but HTTP 11 has one huge

00:15:35,630 --> 00:15:42,230
problem the response has no identify us

00:15:38,660 --> 00:15:46,009
so the server must respond in the same

00:15:42,230 --> 00:15:49,370
order the resources were requested and

00:15:46,009 --> 00:15:52,639
if you think of your average PHP file or

00:15:49,370 --> 00:15:54,170
your PHP server this file is the one

00:15:52,639 --> 00:15:57,589
takes longest right because the other

00:15:54,170 --> 00:16:00,589
one has a static so the browser can at

00:15:57,589 --> 00:16:03,410
the server is not able to deliver the to

00:16:00,589 --> 00:16:05,779
answer the requests it actually could at

00:16:03,410 --> 00:16:08,720
this moment in time but rather it has to

00:16:05,779 --> 00:16:11,360
wait until the site is generated that

00:16:08,720 --> 00:16:13,550
the client can make the mapping so no

00:16:11,360 --> 00:16:16,009
this is request this is the acid i

00:16:13,550 --> 00:16:20,449
requested first so the first answer I

00:16:16,009 --> 00:16:24,769
get is probably dead acid so let's recap

00:16:20,449 --> 00:16:27,199
here on the whole blocking well it's the

00:16:24,769 --> 00:16:28,759
autumn matters right so the order in

00:16:27,199 --> 00:16:32,420
which you request appears is important

00:16:28,759 --> 00:16:33,920
the slowest request blocks there are no

00:16:32,420 --> 00:16:35,660
workarounds which i think is

00:16:33,920 --> 00:16:37,339
particularly interesting because it's

00:16:35,660 --> 00:16:39,170
just a limitation of the protocol and

00:16:37,339 --> 00:16:42,130
this is one of the one of the reasons

00:16:39,170 --> 00:16:44,720
why hp2 was designed the way it is and

00:16:42,130 --> 00:16:49,459
therefore it's often unused most browser

00:16:44,720 --> 00:16:51,350
just turned it off right but s

00:16:49,459 --> 00:16:54,680
developers really endeavored right we

00:16:51,350 --> 00:16:58,240
really really tried to to work around

00:16:54,680 --> 00:17:00,709
these issues and as I don't know humans

00:16:58,240 --> 00:17:04,699
we try to use the way of Ali's defense

00:17:00,709 --> 00:17:07,490
so rather than just opening up the big

00:17:04,699 --> 00:17:09,230
the big bottle and like figuring out the

00:17:07,490 --> 00:17:12,169
protocol how we can improve the web is

00:17:09,230 --> 00:17:13,760
general we just improved our project so

00:17:12,169 --> 00:17:15,289
we came up with that your spriting right

00:17:13,760 --> 00:17:16,699
putting all the different images in one

00:17:15,289 --> 00:17:19,459
huge image and that's positioning it

00:17:16,699 --> 00:17:21,829
with CSS huge or not real

00:17:19,459 --> 00:17:23,240
 but huge overhead if you just

00:17:21,829 --> 00:17:26,000
want to update one image and then your

00:17:23,240 --> 00:17:28,010
try to build tooling around that and add

00:17:26,000 --> 00:17:30,350
a lot of complexity right just to solve

00:17:28,010 --> 00:17:32,750
the one problem concatenating one of my

00:17:30,350 --> 00:17:35,179
favorites dumping all your string by

00:17:32,750 --> 00:17:39,530
string based assets below each other and

00:17:35,179 --> 00:17:40,940
hope nothing breaks domain charting this

00:17:39,530 --> 00:17:43,669
is particularly worse when you upgrade

00:17:40,940 --> 00:17:45,500
to HP to we'll see later why but this

00:17:43,669 --> 00:17:46,760
just means that your surf assets from

00:17:45,500 --> 00:17:49,100
different domains in order to work

00:17:46,760 --> 00:17:52,640
around the limitation that there that

00:17:49,100 --> 00:17:56,540
can only be 55 requests

00:17:52,640 --> 00:17:58,940
in in parallel to one domain also lots

00:17:56,540 --> 00:18:01,370
of stuff got in line based on the size

00:17:58,940 --> 00:18:03,800
so this also adds a lot of complexity to

00:18:01,370 --> 00:18:05,900
the project and I've seen the weirdest

00:18:03,800 --> 00:18:08,750
pre-loading hacks right my company is

00:18:05,900 --> 00:18:10,100
the best example for that what we do is

00:18:08,750 --> 00:18:12,190
like on every landing page so whenever

00:18:10,100 --> 00:18:15,440
you type in general calm and come to any

00:18:12,190 --> 00:18:16,970
20 landing page we will load the

00:18:15,440 --> 00:18:19,570
complete application JavaScript and CSS

00:18:16,970 --> 00:18:22,040
just that your browser have the cash

00:18:19,570 --> 00:18:24,620
this violates so many software

00:18:22,040 --> 00:18:27,590
architecture rules that it's like really

00:18:24,620 --> 00:18:29,810
hard to be with but this is just how

00:18:27,590 --> 00:18:32,300
what many people do and this is just the

00:18:29,810 --> 00:18:33,740
way of these defense they're also cookie

00:18:32,300 --> 00:18:36,170
free domains and I have this little

00:18:33,740 --> 00:18:39,110
Asterix here because it is a great idea

00:18:36,170 --> 00:18:40,910
and please keep on doing this even and

00:18:39,110 --> 00:18:42,710
then your protocol variants so in

00:18:40,910 --> 00:18:52,490
general we try to save all the different

00:18:42,710 --> 00:18:56,030
requests right so now we have talked

00:18:52,490 --> 00:18:58,220
about what's the actual problem with the

00:18:56,030 --> 00:19:00,860
protocols we are using at the moment but

00:18:58,220 --> 00:19:02,660
I also want to bring in the solution to

00:19:00,860 --> 00:19:05,510
this right and how this can be fixed

00:19:02,660 --> 00:19:07,760
right now because the tools are there as

00:19:05,510 --> 00:19:10,130
I mentioned at the beginning so let's

00:19:07,760 --> 00:19:12,260
take a look at HP to first of all 82 is

00:19:10,130 --> 00:19:14,330
compatible so it's not breaking the web

00:19:12,260 --> 00:19:17,240
the scheme with the scheme would stay

00:19:14,330 --> 00:19:19,910
knows you know user will ever see an HP

00:19:17,240 --> 00:19:22,340
to in there in the browser bar and the

00:19:19,910 --> 00:19:24,470
whole semantics day so we will keep

00:19:22,340 --> 00:19:27,400
continuing having requests will keep

00:19:24,470 --> 00:19:30,230
continuing having responses headers

00:19:27,400 --> 00:19:32,690
methods all this stuff stays the same

00:19:30,230 --> 00:19:34,100
but all the like this is the layer we

00:19:32,690 --> 00:19:36,170
are operating on and which will be the

00:19:34,100 --> 00:19:40,670
same but all the underlying stuff

00:19:36,170 --> 00:19:43,010
completely changed out I will discuss

00:19:40,670 --> 00:19:45,100
this in detail in a second first let's

00:19:43,010 --> 00:19:50,030
have a look on how up great looks like

00:19:45,100 --> 00:19:51,980
upgrading from one from hv 1122 first

00:19:50,030 --> 00:19:53,510
let's take a look at the specs so this

00:19:51,980 --> 00:19:56,420
is very theoretical thing because you

00:19:53,510 --> 00:19:57,830
will never see it in the wild so on the

00:19:56,420 --> 00:19:59,900
non encrypted connection it will just

00:19:57,830 --> 00:20:03,110
use an upgrade header so here you see a

00:19:59,900 --> 00:20:04,909
request so it's doing the gap the host

00:20:03,110 --> 00:20:07,279
the connection and then the

00:20:04,909 --> 00:20:09,139
update header it tells to which protocol

00:20:07,279 --> 00:20:11,059
the client wants to upgrade then it also

00:20:09,139 --> 00:20:12,440
sends the H to settings and you will see

00:20:11,059 --> 00:20:15,169
in a second where this is important here

00:20:12,440 --> 00:20:18,619
so this ever sees this request and what

00:20:15,169 --> 00:20:21,830
the server if it's supporting the H to

00:20:18,619 --> 00:20:24,259
see protocol will respond with an H

00:20:21,830 --> 00:20:25,820
should be 101 switching protocols gel to

00:20:24,259 --> 00:20:28,580
which protocol is going to upgrade and

00:20:25,820 --> 00:20:31,009
then new line new line and directly

00:20:28,580 --> 00:20:33,739
start with binary traffic and this is

00:20:31,009 --> 00:20:35,869
why even in the request and the client

00:20:33,739 --> 00:20:39,739
has to send the settings because the

00:20:35,869 --> 00:20:41,330
client has to specify the kind of the

00:20:39,739 --> 00:20:43,729
boundaries they are acting on on the

00:20:41,330 --> 00:20:45,289
protocol for example max package size

00:20:43,729 --> 00:20:48,019
concurrent streams and this kind of

00:20:45,289 --> 00:20:49,789
stuff and in order to make to avoid this

00:20:48,019 --> 00:20:52,729
back and forth loop the client is always

00:20:49,789 --> 00:20:54,470
sending out this one and because this

00:20:52,729 --> 00:20:56,299
would add up so much more traffic on the

00:20:54,470 --> 00:21:00,320
web this is one reason why they drop the

00:20:56,299 --> 00:21:02,389
idea of doing this in the wild then

00:21:00,320 --> 00:21:05,239
there's the connection upgrade on a

00:21:02,389 --> 00:21:08,029
secured connection and this will be a

00:21:05,239 --> 00:21:12,470
lot of acronyms in here but bear with me

00:21:08,029 --> 00:21:15,259
for a second upgrading HP 1122 on a TLS

00:21:12,470 --> 00:21:19,099
connection is done by a LPN a LPN is

00:21:15,259 --> 00:21:21,139
specified in RFC 7301 and actually LPN

00:21:19,099 --> 00:21:24,919
is not the complete acronym actually

00:21:21,139 --> 00:21:27,019
it's GLS LVN so it's the transport layer

00:21:24,919 --> 00:21:28,879
security application protocol

00:21:27,019 --> 00:21:32,299
application layer protocol negotiation

00:21:28,879 --> 00:21:35,599
protocols if this makes any sense to

00:21:32,299 --> 00:21:37,879
make this even more confusing a LPN is

00:21:35,599 --> 00:21:42,619
based on NPM which was invented by

00:21:37,879 --> 00:21:46,759
Google for speed anyway how does it look

00:21:42,619 --> 00:21:48,950
like in in on the protocol so this is

00:21:46,759 --> 00:21:51,019
the ssl handshake and this is the part

00:21:48,950 --> 00:21:54,229
which is interesting for us because when

00:21:51,019 --> 00:21:56,989
you have the TLS um extension called a

00:21:54,229 --> 00:21:58,820
LPN the client office a set of protocols

00:21:56,989 --> 00:22:02,239
its support and the server can just pick

00:21:58,820 --> 00:22:03,559
one that's that's it is how they are

00:22:02,239 --> 00:22:06,289
they can negotiate on the protocol

00:22:03,559 --> 00:22:12,019
pretty easy and then there's all this

00:22:06,289 --> 00:22:15,190
handshake security stuff little hats up

00:22:12,019 --> 00:22:18,590
here you've seen h 2 and h 2 c and

00:22:15,190 --> 00:22:20,510
unless in the in the 11 protocol

00:22:18,590 --> 00:22:23,419
the longer version here is the non

00:22:20,510 --> 00:22:26,419
encrypted so H to see is clear text and

00:22:23,419 --> 00:22:28,340
h2 is the encrypted one why is it I

00:22:26,419 --> 00:22:31,490
think the reason is pretty funny because

00:22:28,340 --> 00:22:36,260
the string h to see is reserved in the

00:22:31,490 --> 00:22:38,539
APN identifier space but it describes a

00:22:36,260 --> 00:22:39,830
protocol that does not even use TLS so

00:22:38,539 --> 00:22:42,860
they're like two weird things in the

00:22:39,830 --> 00:22:44,929
first why should this ring for the clear

00:22:42,860 --> 00:22:47,179
text version be in the protocol spec for

00:22:44,929 --> 00:22:50,450
the encrypted version and then why is

00:22:47,179 --> 00:22:52,520
there something in the identifier space

00:22:50,450 --> 00:22:53,720
which is not used by it so they

00:22:52,520 --> 00:22:58,490
definitely lacking garbage collection

00:22:53,720 --> 00:23:01,490
here HT v 2 is multiplexed it's using

00:22:58,490 --> 00:23:02,929
streams and this is the one feature to

00:23:01,490 --> 00:23:05,990
actually work around all the limitation

00:23:02,929 --> 00:23:08,270
we just discussed it can transfer

00:23:05,990 --> 00:23:09,950
multiple resources on a single

00:23:08,270 --> 00:23:12,169
connection so on a single TCP connection

00:23:09,950 --> 00:23:15,549
we have here this is one physical TCP

00:23:12,169 --> 00:23:20,419
connection as far as it is get physical

00:23:15,549 --> 00:23:24,169
and there are logically streams on that

00:23:20,419 --> 00:23:26,240
and the streams contains of frames if

00:23:24,169 --> 00:23:27,980
you look at the data transferred it's

00:23:26,240 --> 00:23:31,159
just frames transferred on one

00:23:27,980 --> 00:23:33,350
connection but a frame always belongs to

00:23:31,159 --> 00:23:35,419
a stream so thinking of that in this

00:23:33,350 --> 00:23:37,820
model makes way more sense because that

00:23:35,419 --> 00:23:42,679
can't be any frame not belonging to a

00:23:37,820 --> 00:23:44,720
stream and the stream or frame can be

00:23:42,679 --> 00:23:46,460
anything we'll take a look deeper on

00:23:44,720 --> 00:23:49,909
this in a second and the stream is

00:23:46,460 --> 00:23:52,610
always one request response cycle it can

00:23:49,909 --> 00:23:55,010
be it also can't stream can exist

00:23:52,610 --> 00:23:57,409
without having request response but

00:23:55,010 --> 00:24:00,110
there cannot be any request response

00:23:57,409 --> 00:24:03,950
without a stream and there cannot be two

00:24:00,110 --> 00:24:05,210
requests responses on one stream so

00:24:03,950 --> 00:24:09,890
let's take a deeper look at the frames

00:24:05,210 --> 00:24:12,039
frames are binary and now the first spec

00:24:09,890 --> 00:24:14,450
part comes this is actual frame layout

00:24:12,039 --> 00:24:16,730
let's have a look how this looks like

00:24:14,450 --> 00:24:18,590
that's the binary frame and it starts

00:24:16,730 --> 00:24:21,740
out with the length then there's the

00:24:18,590 --> 00:24:24,649
type of 8-bit and the flags a reserve

00:24:21,740 --> 00:24:27,110
bit and then there's the stream

00:24:24,649 --> 00:24:29,210
identifier of 31 bit and then that's

00:24:27,110 --> 00:24:31,940
actual frame payload so this is kind of

00:24:29,210 --> 00:24:32,440
a generic frame header for all the

00:24:31,940 --> 00:24:35,520
frames

00:24:32,440 --> 00:24:37,780
we will see in a second so when it was

00:24:35,520 --> 00:24:39,400
reading through this back I actually

00:24:37,780 --> 00:24:42,340
found that one and in the specs it said

00:24:39,400 --> 00:24:45,490
this bit has always been has always to

00:24:42,340 --> 00:24:48,220
be zero ignore it and I think what why

00:24:45,490 --> 00:24:49,750
it's even in there then and I was

00:24:48,220 --> 00:24:51,460
industry it's not mentioned in the docs

00:24:49,750 --> 00:24:53,680
why why it is in there right it's just

00:24:51,460 --> 00:24:55,960
said it is zero ignore it and there's no

00:24:53,680 --> 00:24:58,180
no additional reasoning I got really

00:24:55,960 --> 00:25:01,840
curious so I went out and asked the

00:24:58,180 --> 00:25:05,340
author of the spec and it turns out it's

00:25:01,840 --> 00:25:08,140
for platforms who does not support

00:25:05,340 --> 00:25:10,360
unsigned integers so they can just use

00:25:08,140 --> 00:25:15,370
signed integers and do whatever with

00:25:10,360 --> 00:25:18,040
this bit well okay so we can support

00:25:15,370 --> 00:25:19,480
this platform great now let's take a

00:25:18,040 --> 00:25:20,860
look at the different types of frames we

00:25:19,480 --> 00:25:22,870
have the first one and that's one you

00:25:20,860 --> 00:25:24,850
will see most of the time in in

00:25:22,870 --> 00:25:26,920
production in the real world that's a

00:25:24,850 --> 00:25:29,790
data frame it actually carries all kind

00:25:26,920 --> 00:25:33,280
of data it can be an asset can be armed

00:25:29,790 --> 00:25:36,550
it can be HTML it can be whatever it's

00:25:33,280 --> 00:25:40,330
just binary data and this actually come

00:25:36,550 --> 00:25:42,430
this of the path length this specifies

00:25:40,330 --> 00:25:44,590
the padding you see here and then the

00:25:42,430 --> 00:25:47,680
actual data padding is a security

00:25:44,590 --> 00:25:50,320
feature because TLS an SSL protects the

00:25:47,680 --> 00:25:52,870
content itself but it is really bad at

00:25:50,320 --> 00:25:55,630
protecting the length of the content so

00:25:52,870 --> 00:25:57,960
attackers can guess the length of your

00:25:55,630 --> 00:26:02,070
content and this is an attack vector and

00:25:57,960 --> 00:26:02,070
this is why they added the padding

00:26:06,470 --> 00:26:13,640
I don't know that sorry I check out the

00:26:11,659 --> 00:26:15,530
specs they're pretty comprehensive on

00:26:13,640 --> 00:26:18,620
that so that huge sections about

00:26:15,530 --> 00:26:21,230
protocol security and then there's the

00:26:18,620 --> 00:26:23,320
priority frame which is type 0 0 x2 it

00:26:21,230 --> 00:26:26,210
has the stream dependency and the weight

00:26:23,320 --> 00:26:29,299
so hav two uses weighted dependencies

00:26:26,210 --> 00:26:31,640
and I will have a section later on this

00:26:29,299 --> 00:26:33,590
how this actually works in detail then

00:26:31,640 --> 00:26:37,460
this the reset stream frame this

00:26:33,590 --> 00:26:40,580
indicates an error on one stream so when

00:26:37,460 --> 00:26:42,169
there's an passing error on one side the

00:26:40,580 --> 00:26:43,880
other side can just close that one

00:26:42,169 --> 00:26:46,370
particular stream while keeping up the

00:26:43,880 --> 00:26:49,610
connection then there's a settings frame

00:26:46,370 --> 00:26:52,340
settings belong to the complete

00:26:49,610 --> 00:26:54,470
connection and these are for example how

00:26:52,340 --> 00:26:56,780
many streams that can be in parallel

00:26:54,470 --> 00:26:58,760
what's the max size for data packages

00:26:56,780 --> 00:27:02,870
and this kind of stuff and it's always

00:26:58,760 --> 00:27:05,120
key value there are also bunch more and

00:27:02,870 --> 00:27:07,610
we'll go through a few more in this talk

00:27:05,120 --> 00:27:09,620
but for the rest check out the specs I

00:27:07,610 --> 00:27:12,520
think I have covered the most

00:27:09,620 --> 00:27:15,289
interesting here here I have an actual

00:27:12,520 --> 00:27:18,110
implementation example so this is the

00:27:15,289 --> 00:27:19,130
pink package type 06 with the

00:27:18,110 --> 00:27:22,640
acknowledgement flag so the

00:27:19,130 --> 00:27:24,200
acknowledgement flags flag is that the

00:27:22,640 --> 00:27:26,900
receiver should actually send back a

00:27:24,200 --> 00:27:28,130
pink frame hopefully without the

00:27:26,900 --> 00:27:31,580
Englishman flag because it would go

00:27:28,130 --> 00:27:34,669
paint on them so what do we have here

00:27:31,580 --> 00:27:37,280
first there's the links and the spec

00:27:34,669 --> 00:27:38,870
says that the pink package has to be 64

00:27:37,280 --> 00:27:41,270
bit length the length is just for they

00:27:38,870 --> 00:27:44,240
just for the content so it's not for the

00:27:41,270 --> 00:27:47,419
headers then there's this type type is

00:27:44,240 --> 00:27:49,340
specified by the spec at 66 then there's

00:27:47,419 --> 00:27:53,120
the flag the flags are also specified

00:27:49,340 --> 00:27:56,840
per frame in the specs so the X flag is

00:27:53,120 --> 00:27:58,549
so x1 then there's the one bit we are

00:27:56,840 --> 00:28:00,919
always ignoring and then there's a

00:27:58,549 --> 00:28:03,890
stream ready what I particularly like

00:28:00,919 --> 00:28:06,409
and want to point out here is that when

00:28:03,890 --> 00:28:09,500
I see this remedy I can tell that this

00:28:06,409 --> 00:28:12,130
one is from the server because clients

00:28:09,500 --> 00:28:15,169
use odd numbers and server uses even

00:28:12,130 --> 00:28:18,530
this way they avoid any collisions on

00:28:15,169 --> 00:28:20,029
the ids and I think this pretty cool so

00:28:18,530 --> 00:28:21,739
everyone can just take

00:28:20,029 --> 00:28:25,099
take their own stream of these and they

00:28:21,739 --> 00:28:29,059
never collide and then there's 64 bit of

00:28:25,099 --> 00:28:32,749
bacteria specified in the protocol so

00:28:29,059 --> 00:28:34,340
with this at hand you can implement what

00:28:32,749 --> 00:28:36,830
you have already in your web server

00:28:34,340 --> 00:28:38,869
right and you would solve most of the

00:28:36,830 --> 00:28:41,269
problems we have like head of line

00:28:38,869 --> 00:28:43,219
blocking optimizing for latency others

00:28:41,269 --> 00:28:45,590
kind of stuff could be completely solved

00:28:43,219 --> 00:28:48,409
by the stuff we saw but this is just

00:28:45,590 --> 00:28:49,999
half of this back because the authors

00:28:48,409 --> 00:28:53,239
said when we're doing a new version

00:28:49,999 --> 00:28:56,179
anyway let's really improve the web so

00:28:53,239 --> 00:29:00,440
there are a few things which are not NH

00:28:56,179 --> 00:29:02,419
which in HTTP one yet um they're not

00:29:00,440 --> 00:29:05,869
around on the web yet and I want to talk

00:29:02,419 --> 00:29:08,210
about this as well the first one is a

00:29:05,869 --> 00:29:10,009
thing called server push and server push

00:29:08,210 --> 00:29:11,749
is a feature which you can think of a

00:29:10,009 --> 00:29:15,080
direct connection from the server into

00:29:11,749 --> 00:29:17,479
the browser's cache right so what does

00:29:15,080 --> 00:29:21,589
it do imagine a client requests in the

00:29:17,479 --> 00:29:23,539
next HTML the server can tell I know

00:29:21,589 --> 00:29:25,639
you're going to request the index HTML

00:29:23,539 --> 00:29:27,499
here but I know that you're going to

00:29:25,639 --> 00:29:30,049
need this JavaScript and this CSS file

00:29:27,499 --> 00:29:33,229
as well so without the client actually

00:29:30,049 --> 00:29:36,200
asking for it this is I think one of the

00:29:33,229 --> 00:29:37,999
biggest changes and one of the things of

00:29:36,200 --> 00:29:39,700
the biggest impact in the whole protocol

00:29:37,999 --> 00:29:42,729
and I think this can make the web

00:29:39,700 --> 00:29:44,659
enormously faster there are no actual

00:29:42,729 --> 00:29:46,789
implementations or like generic

00:29:44,659 --> 00:29:50,869
implementations at hand yeah but I think

00:29:46,789 --> 00:29:54,649
this is pretty promising you got the pun

00:29:50,869 --> 00:29:57,919
with promising okay so there's the frame

00:29:54,649 --> 00:29:59,210
which actually initializes the push it's

00:29:57,919 --> 00:30:00,679
pretty similar to the hatter frame

00:29:59,210 --> 00:30:03,739
because it basically is a header but

00:30:00,679 --> 00:30:06,669
it's initialized by the server so it has

00:30:03,739 --> 00:30:09,049
a path length one reserved bit then the

00:30:06,669 --> 00:30:11,179
soon-to-be stream ID so this is a

00:30:09,049 --> 00:30:12,739
service stream ID and then there's a

00:30:11,179 --> 00:30:15,049
header block fragment I will talk about

00:30:12,739 --> 00:30:17,809
this in a second as well and then

00:30:15,049 --> 00:30:20,960
there's the padding so that's about

00:30:17,809 --> 00:30:24,019
server push it also sort supports flow

00:30:20,960 --> 00:30:28,369
control so client and server both can

00:30:24,019 --> 00:30:32,899
wire transmitting data change the weight

00:30:28,369 --> 00:30:33,770
of assets so while receiving that they

00:30:32,899 --> 00:30:37,130
can change

00:30:33,770 --> 00:30:40,520
which acid is more important now and my

00:30:37,130 --> 00:30:42,440
favorite example of this could be an

00:30:40,520 --> 00:30:45,680
image gallery so imagine you have a long

00:30:42,440 --> 00:30:47,960
HTML page and browsers could implement a

00:30:45,680 --> 00:30:50,600
way that they're not going to fetch the

00:30:47,960 --> 00:30:54,110
images which are not in the viewport yet

00:30:50,600 --> 00:30:56,300
and as you scroll down they can start

00:30:54,110 --> 00:30:57,770
fetching it and if you jump and they

00:30:56,300 --> 00:30:59,630
even have fetched some images but they

00:30:57,770 --> 00:31:01,640
are out of the current view port they

00:30:59,630 --> 00:31:04,280
can still continue fetching the ones

00:31:01,640 --> 00:31:07,010
they don't need yet but they can

00:31:04,280 --> 00:31:08,780
reprioritize the other ones so they can

00:31:07,010 --> 00:31:12,530
change priorities both sides can change

00:31:08,780 --> 00:31:15,680
priorities while transmitting they do

00:31:12,530 --> 00:31:17,480
this by weighted dependencies and for me

00:31:15,680 --> 00:31:19,220
this is always hard to like reason about

00:31:17,480 --> 00:31:23,020
so I also want to bring a little example

00:31:19,220 --> 00:31:25,670
here this is done by a priority three

00:31:23,020 --> 00:31:29,390
this graphics I kind of rebuild from a

00:31:25,670 --> 00:31:31,280
presentation from moto e jae bok I have

00:31:29,390 --> 00:31:35,510
a link on my slides you can find on join

00:31:31,280 --> 00:31:38,000
in and he has done a complete talk just

00:31:35,510 --> 00:31:41,060
about how this prioritization in h2

00:31:38,000 --> 00:31:43,190
works it's pretty insightful lots of

00:31:41,060 --> 00:31:47,900
lots of details in there and I love that

00:31:43,190 --> 00:31:50,480
so here we have one screams during 0

00:31:47,900 --> 00:31:53,150
this is always the initial the initial

00:31:50,480 --> 00:31:56,300
stream and this is the dependency so

00:31:53,150 --> 00:31:57,800
streamwood III depends on 3-0 here we

00:31:56,300 --> 00:32:00,200
have another stream stream of five

00:31:57,800 --> 00:32:02,480
letters committee here in the middle and

00:32:00,200 --> 00:32:05,110
this is the weight then we have another

00:32:02,480 --> 00:32:09,800
stream unity seven and three mati nine

00:32:05,110 --> 00:32:12,830
here so let's try to understand what's

00:32:09,800 --> 00:32:15,320
going on here first as I mentioned the

00:32:12,830 --> 00:32:17,240
in the at the very bottom at the very

00:32:15,320 --> 00:32:19,250
top there's three mary 0 that's the

00:32:17,240 --> 00:32:23,090
initial stream at the initial stream ID

00:32:19,250 --> 00:32:24,410
is always 0 and a default wait so when

00:32:23,090 --> 00:32:28,970
there's no way it's specified is always

00:32:24,410 --> 00:32:31,550
16 and stream id3 should receive two

00:32:28,970 --> 00:32:33,590
thirds of the available resources so

00:32:31,550 --> 00:32:36,380
that you can see here and here for this

00:32:33,590 --> 00:32:38,510
two-thirds and stream it is seven should

00:32:36,380 --> 00:32:41,480
receive half of the resources of three

00:32:38,510 --> 00:32:44,360
mati three so they split because they're

00:32:41,480 --> 00:32:47,580
both 16 all the resource out going on

00:32:44,360 --> 00:32:49,290
5050 right even though it's one

00:32:47,580 --> 00:32:53,130
not fifty-fifty here but it's 5050 here

00:32:49,290 --> 00:32:55,170
so they split it up even more that's

00:32:53,130 --> 00:32:56,930
very theoretical and I want to bring an

00:32:55,170 --> 00:33:00,810
example how that actually looks like in

00:32:56,930 --> 00:33:02,850
in Firefox because our that was a the

00:33:00,810 --> 00:33:05,610
one example in the talk and I want to

00:33:02,850 --> 00:33:07,620
just show it off so imagine there is a

00:33:05,610 --> 00:33:09,990
request starting now and I will have

00:33:07,620 --> 00:33:12,390
another example later on where you see

00:33:09,990 --> 00:33:15,630
the same pattern what Firefox does is

00:33:12,390 --> 00:33:17,220
just opening up new streams so it's

00:33:15,630 --> 00:33:19,140
binding up this dependency tree there's

00:33:17,220 --> 00:33:22,020
nothing transferred yet right so it's

00:33:19,140 --> 00:33:26,100
just pinning up this tree and then it

00:33:22,020 --> 00:33:29,060
starts with the HTML document prioritize

00:33:26,100 --> 00:33:32,910
but they had a frame then some CSS files

00:33:29,060 --> 00:33:36,480
they go up here then some JavaScript

00:33:32,910 --> 00:33:38,310
files also in the ad then and the

00:33:36,480 --> 00:33:42,540
browser might find some images in the

00:33:38,310 --> 00:33:45,480
body so they go below here so same same

00:33:42,540 --> 00:33:47,760
priority as the 13 or same dependency as

00:33:45,480 --> 00:33:50,010
the HTML document and when the browser

00:33:47,760 --> 00:33:52,620
then also finds some JavaScript at the

00:33:50,010 --> 00:33:54,360
bottom so maybe I'm right before the

00:33:52,620 --> 00:33:58,530
body closing tag this what most of us do

00:33:54,360 --> 00:33:59,850
right they will go below to marry 5 your

00:33:58,530 --> 00:34:01,950
most urgent question might be why they

00:33:59,850 --> 00:34:06,150
doing it this way and the answers I

00:34:01,950 --> 00:34:08,520
don't know but what I know is that this

00:34:06,150 --> 00:34:11,490
is the most efficient strategy compared

00:34:08,520 --> 00:34:14,580
across browsers this is because Google

00:34:11,490 --> 00:34:17,430
Google's Chrome still has the strategy

00:34:14,580 --> 00:34:20,280
they used for speedy and this changed a

00:34:17,430 --> 00:34:22,620
lot so what they do I mean it's not like

00:34:20,280 --> 00:34:24,600
super slow and the difference is kind of

00:34:22,620 --> 00:34:27,060
kind of really small but this is the

00:34:24,600 --> 00:34:28,470
most efficient way of doing it and what

00:34:27,060 --> 00:34:30,450
I also find pretty interesting is that

00:34:28,470 --> 00:34:33,420
the Internet Explorer they just don't

00:34:30,450 --> 00:34:35,790
really use this so every every stream

00:34:33,420 --> 00:34:39,900
they open depends on the euro so it's a

00:34:35,790 --> 00:34:41,910
flat thing um but I mean that's not a

00:34:39,900 --> 00:34:43,530
that's not a big thing in a big deal

00:34:41,910 --> 00:34:46,290
right I mean it's it's totally okay it

00:34:43,530 --> 00:34:48,180
will work and um it's just a it's just

00:34:46,290 --> 00:34:51,570
an option where they can gain some speed

00:34:48,180 --> 00:34:53,400
in the future so now let's talk about

00:34:51,570 --> 00:34:54,720
the compressed headers we were just

00:34:53,400 --> 00:34:56,100
talking about this at the beginning so

00:34:54,720 --> 00:34:59,610
how does are compressed in the protocol

00:34:56,100 --> 00:35:00,960
and this is how it looks like so here's

00:34:59,610 --> 00:35:03,540
the harris frame it

00:35:00,960 --> 00:35:06,630
type 0 X 1 it starts with the Pat

00:35:03,540 --> 00:35:09,420
Lange's the 0 bit the stream dependency

00:35:06,630 --> 00:35:12,150
so the stream this new stream depends on

00:35:09,420 --> 00:35:14,369
so I had a a header frame always also

00:35:12,150 --> 00:35:18,450
opens up or push promised opens up a new

00:35:14,369 --> 00:35:19,980
stream and then the weight and there's a

00:35:18,450 --> 00:35:24,030
header block fragment which is binary

00:35:19,980 --> 00:35:25,680
data and then there's a panning so how

00:35:24,030 --> 00:35:28,230
does this header black a header block

00:35:25,680 --> 00:35:29,730
Franklin look like well the header block

00:35:28,230 --> 00:35:32,790
frankland is actually specified in

00:35:29,730 --> 00:35:35,280
another RFC it's RFC 75 41 and it's

00:35:32,790 --> 00:35:38,640
called H pack so each peg has a more or

00:35:35,280 --> 00:35:43,080
less generic generic RFC generic way to

00:35:38,640 --> 00:35:46,980
compress key value pairs from server to

00:35:43,080 --> 00:35:50,490
client and it's actually the technique

00:35:46,980 --> 00:35:54,060
is using is it consists of a static

00:35:50,490 --> 00:35:56,369
table and a dynamic table and the end

00:35:54,060 --> 00:35:59,490
coder decides what's going in the

00:35:56,369 --> 00:36:02,339
dynamic table so how does it look like

00:35:59,490 --> 00:36:04,380
here um we have an example so this is

00:36:02,339 --> 00:36:06,750
request headers even if looks like essed

00:36:04,380 --> 00:36:09,210
headers we have the massive guide with a

00:36:06,750 --> 00:36:11,880
scheme HTTPS if the host Jimmy com

00:36:09,210 --> 00:36:13,260
passes resource news agencies Mozilla

00:36:11,880 --> 00:36:15,570
and the custom header has some custom

00:36:13,260 --> 00:36:17,430
value and this is static table the

00:36:15,570 --> 00:36:19,410
static table is just part of the RFC and

00:36:17,430 --> 00:36:21,480
you're just if you're implementing this

00:36:19,410 --> 00:36:22,950
you would just like copy paste it from

00:36:21,480 --> 00:36:25,859
there and bring it into some kind of

00:36:22,950 --> 00:36:27,330
data structure you can look it up and I

00:36:25,859 --> 00:36:30,030
think this one is particularly

00:36:27,330 --> 00:36:32,670
interesting because method gat might be

00:36:30,030 --> 00:36:34,470
one of the most sent headers in the web

00:36:32,670 --> 00:36:38,160
right because this is what most of stuff

00:36:34,470 --> 00:36:41,730
is doing on the web and when I'm surfing

00:36:38,160 --> 00:36:43,800
with my browser on my one connection my

00:36:41,730 --> 00:36:47,280
user agent probably won't change and

00:36:43,800 --> 00:36:49,260
also the host won't change right so this

00:36:47,280 --> 00:36:51,270
is why this might change from user agent

00:36:49,260 --> 00:36:52,830
user agent and even like from different

00:36:51,270 --> 00:36:56,520
connections to connections but it will

00:36:52,830 --> 00:36:58,920
stay in one connection and here you see

00:36:56,520 --> 00:37:02,369
the one exception from the statelessness

00:36:58,920 --> 00:37:05,089
we mentioned so the the compression

00:37:02,369 --> 00:37:08,099
table and especially the dynamic part is

00:37:05,089 --> 00:37:11,220
stateful but it belongs to one

00:37:08,099 --> 00:37:14,400
connection so on one connection there is

00:37:11,220 --> 00:37:19,950
state in the client and the server

00:37:14,400 --> 00:37:22,589
right so you have to keep the table the

00:37:19,950 --> 00:37:24,779
connection table to belonging to them to

00:37:22,589 --> 00:37:28,829
the actual socket if you're implementing

00:37:24,779 --> 00:37:32,099
a Sabha and how does it how would the

00:37:28,829 --> 00:37:34,770
encoded headers look like well so the

00:37:32,099 --> 00:37:37,170
request header method get you can look

00:37:34,770 --> 00:37:40,020
it up here by index two would be just

00:37:37,170 --> 00:37:41,670
index 2 in the encode headers then steam

00:37:40,020 --> 00:37:44,910
htps something you will see pretty often

00:37:41,670 --> 00:37:48,270
will be id seven and so on at the forest

00:37:44,910 --> 00:37:51,299
this one is interesting because here we

00:37:48,270 --> 00:37:55,049
have index index 19 which is not on here

00:37:51,299 --> 00:37:57,029
but I'm pretty sure is path and it

00:37:55,049 --> 00:38:01,740
doesn't have a value like authority here

00:37:57,029 --> 00:38:03,720
or referral and these drinks are half

00:38:01,740 --> 00:38:08,700
been encoded out hug will happen in a

00:38:03,720 --> 00:38:12,150
second and the encoder decides if the

00:38:08,700 --> 00:38:14,490
server should add this values or the

00:38:12,150 --> 00:38:16,500
headers like in this example to the

00:38:14,490 --> 00:38:20,520
aesthetic table to the dynamic tables

00:38:16,500 --> 00:38:22,170
all right that's one other um another

00:38:20,520 --> 00:38:24,660
other funny side note in here have you

00:38:22,170 --> 00:38:25,950
noticed something here it's actually

00:38:24,660 --> 00:38:28,140
spelled wrong and that's not me being

00:38:25,950 --> 00:38:30,359
stupid this is how it is in the actual

00:38:28,140 --> 00:38:32,849
spec and what I didn't know where you

00:38:30,359 --> 00:38:34,619
know that before is that it is wrong in

00:38:32,849 --> 00:38:36,390
this back there was a typo in the

00:38:34,619 --> 00:38:39,329
initial each everyone once back it has

00:38:36,390 --> 00:38:41,130
been like that forever and if you check

00:38:39,329 --> 00:38:42,599
out the actual implementations most of

00:38:41,130 --> 00:38:45,869
the server and kind of limitations

00:38:42,599 --> 00:38:49,049
supports both ways of writing it right

00:38:45,869 --> 00:38:51,599
the correct way in the wrong way and in

00:38:49,049 --> 00:38:54,150
a Tuesday decided to not change it so

00:38:51,599 --> 00:38:56,520
you'll still find this error this typo

00:38:54,150 --> 00:38:59,069
in the edge packs back I think that's

00:38:56,520 --> 00:39:00,480
kind of funny well let's take a look at

00:38:59,069 --> 00:39:03,000
half an encoding who even knows what

00:39:00,480 --> 00:39:05,010
happen in holiness and how it works okay

00:39:03,000 --> 00:39:07,230
that's about five hands that's pretty

00:39:05,010 --> 00:39:08,670
good so I want to try to explain it in

00:39:07,230 --> 00:39:11,880
one minute so that the five will just

00:39:08,670 --> 00:39:14,190
raise your hands won't get bored but

00:39:11,880 --> 00:39:17,460
also that I can just bring you out

00:39:14,190 --> 00:39:20,099
others on board so haven't encoding one

00:39:17,460 --> 00:39:21,359
minute um we want to encode this ring

00:39:20,099 --> 00:39:22,890
Mississippi River and the idea of

00:39:21,359 --> 00:39:26,069
Huffman encoding is actually that

00:39:22,890 --> 00:39:28,020
characters which secure often take the

00:39:26,069 --> 00:39:31,110
least space in the encoded value

00:39:28,020 --> 00:39:34,070
right so here the eye and the s probably

00:39:31,110 --> 00:39:37,080
might be encoded pretty short so

00:39:34,070 --> 00:39:39,090
Mississippi Mississippi River has 17

00:39:37,080 --> 00:39:42,540
characters where each character's is a

00:39:39,090 --> 00:39:43,710
bit so this results 136 bits first thing

00:39:42,540 --> 00:39:46,860
you do if you want to encode it you

00:39:43,710 --> 00:39:49,050
count the characters so m1 I 5s four and

00:39:46,860 --> 00:39:51,960
so on then you just order them by

00:39:49,050 --> 00:39:55,350
occurrence or by a half an acre so we

00:39:51,960 --> 00:39:56,460
have I five as for p2 and so on so next

00:39:55,350 --> 00:39:59,490
thing you do you start at the very

00:39:56,460 --> 00:40:01,730
lowest lowest values combine like

00:39:59,490 --> 00:40:05,450
concatenate the characters and sum up

00:40:01,730 --> 00:40:11,730
the numbers so you would get a space to

00:40:05,450 --> 00:40:15,330
next is MV to PR for so then we go over

00:40:11,730 --> 00:40:19,260
to MV e space for PR em ve space aight

00:40:15,330 --> 00:40:22,560
then there's is nine and i spr em ve

00:40:19,260 --> 00:40:25,800
space 17 so you see we get always get up

00:40:22,560 --> 00:40:28,800
to the 17 here again um hopefully it's

00:40:25,800 --> 00:40:30,030
not too many mistakes next thing you do

00:40:28,800 --> 00:40:32,610
is you walk down every branch

00:40:30,030 --> 00:40:35,820
combination you have no first you assign

00:40:32,610 --> 00:40:38,670
zeros to the left branch side and once

00:40:35,820 --> 00:40:40,200
to the right hand side and then you walk

00:40:38,670 --> 00:40:46,020
down every possible combination you have

00:40:40,200 --> 00:40:48,480
like here here so I is 0 0 s 01 p is 100

00:40:46,020 --> 00:40:51,210
and so and so forth and with that you

00:40:48,480 --> 00:40:53,190
got your encoding table so with that

00:40:51,210 --> 00:40:57,120
table you can actually compress the

00:40:53,190 --> 00:41:00,690
string Mississippi River the compression

00:40:57,120 --> 00:41:02,310
table has to be has to be to go with no

00:41:00,690 --> 00:41:05,670
result and half an encoding to actually

00:41:02,310 --> 00:41:08,280
be able to encode it again so the string

00:41:05,670 --> 00:41:11,550
itself is 64 bits plus the table you was

00:41:08,280 --> 00:41:12,840
still safe around seventy percent if you

00:41:11,550 --> 00:41:16,830
encode the string Mississippi River like

00:41:12,840 --> 00:41:19,800
that so the Huffman encoding is a pretty

00:41:16,830 --> 00:41:22,110
good choice to do that and what the H

00:41:19,800 --> 00:41:24,390
packs bag also does the h pecs pecs come

00:41:22,110 --> 00:41:27,750
with a complete Huffman encoding table

00:41:24,390 --> 00:41:29,100
so they analyzed a lot of traffic I

00:41:27,750 --> 00:41:30,570
don't know I don't know the numbers but

00:41:29,100 --> 00:41:33,300
it just was reading this bag of this

00:41:30,570 --> 00:41:36,000
after this this afternoon and they have

00:41:33,300 --> 00:41:37,890
like one or two pages Huffman table

00:41:36,000 --> 00:41:39,600
which you just copy over to

00:41:37,890 --> 00:41:40,520
implementation and then you don't have

00:41:39,600 --> 00:41:42,680
to transfer the

00:41:40,520 --> 00:41:44,030
table right so the lookup can be done by

00:41:42,680 --> 00:41:47,840
this table which is in this back and

00:41:44,030 --> 00:41:51,340
they said they created this table by

00:41:47,840 --> 00:41:55,270
analyzing a lot of headers in the web I

00:41:51,340 --> 00:41:59,810
think this is particularly interesting

00:41:55,270 --> 00:42:01,880
well now I want to take a look on how HP

00:41:59,810 --> 00:42:04,370
looks like in the in the real world

00:42:01,880 --> 00:42:06,890
right so first of all it's already here

00:42:04,370 --> 00:42:09,200
and we have a few we have a few minutes

00:42:06,890 --> 00:42:11,930
spare so I really want to want to do a

00:42:09,200 --> 00:42:16,280
little demo here so let's see if we can

00:42:11,930 --> 00:42:20,960
get if we can get this working ooh my

00:42:16,280 --> 00:42:23,000
emails you don't see that it's good all

00:42:20,960 --> 00:42:25,310
right bro now you can see my emails

00:42:23,000 --> 00:42:29,540
right oh there you see my HP

00:42:25,310 --> 00:42:34,010
complementation all right let's go over

00:42:29,540 --> 00:42:35,960
here whoops this is always an open up a

00:42:34,010 --> 00:42:38,630
new type it's also feature of Michelle

00:42:35,960 --> 00:42:40,490
it takes long but it's worth it all

00:42:38,630 --> 00:42:44,900
right so what we're doing here what way

00:42:40,490 --> 00:42:49,280
too fast um so I use a tool ng HTTP i

00:42:44,900 --> 00:42:50,810
pass a few flags V is verbose and is I

00:42:49,280 --> 00:42:53,210
guess it's discarding the actual

00:42:50,810 --> 00:42:55,780
download content and you with whatever I

00:42:53,210 --> 00:43:05,110
forget it what's that oh you can see it

00:42:55,780 --> 00:43:11,510
that is well let's like that no

00:43:05,110 --> 00:43:13,660
yeah no right ok awesome that ok I

00:43:11,510 --> 00:43:15,860
think it's going to work at this yeah

00:43:13,660 --> 00:43:20,750
actually I don't know how to move it

00:43:15,860 --> 00:43:27,410
over it now ah ok let's do it like that

00:43:20,750 --> 00:43:31,579
I hope this

00:43:27,410 --> 00:43:34,460
awesome okay let's relate that okay so

00:43:31,579 --> 00:43:36,740
we have tool ng HTTP and we're passing a

00:43:34,460 --> 00:43:38,450
few flags and i'm using the goal and

00:43:36,740 --> 00:43:40,490
implementation of the SEO to server

00:43:38,450 --> 00:43:43,280
because they have a pretty good

00:43:40,490 --> 00:43:45,559
implementation they shipped it with 16

00:43:43,280 --> 00:43:48,440
so they just released it and they put up

00:43:45,559 --> 00:43:50,780
this version of the server to check that

00:43:48,440 --> 00:43:52,460
implementation and that people

00:43:50,780 --> 00:43:55,220
implementing the protocol can also check

00:43:52,460 --> 00:43:56,660
against their implementation and let's

00:43:55,220 --> 00:43:59,119
just fire it up and then analyze what's

00:43:56,660 --> 00:44:01,579
happening there first of all is just

00:43:59,119 --> 00:44:04,010
connected and then they negotiate it to

00:44:01,579 --> 00:44:07,039
the protocol h2 which is the encrypted

00:44:04,010 --> 00:44:08,690
protocol via LPN right then the client

00:44:07,039 --> 00:44:11,660
is sending some settings let's take a

00:44:08,690 --> 00:44:13,460
look it's max concurrent streams arm so

00:44:11,660 --> 00:44:16,160
we can send 100 max and currents dreams

00:44:13,460 --> 00:44:19,190
and the initial window size then it's

00:44:16,160 --> 00:44:22,700
opening up some new frames so street 3 5

00:44:19,190 --> 00:44:24,589
7 9 11 and 13 and then it's sending some

00:44:22,700 --> 00:44:27,410
headers so the request headers and what

00:44:24,589 --> 00:44:30,079
you see here is Colin method get Patrick

00:44:27,410 --> 00:44:32,750
info so just the same thing we just saw

00:44:30,079 --> 00:44:35,059
and what I want to point out because

00:44:32,750 --> 00:44:37,490
this might be kind of weird to you is

00:44:35,059 --> 00:44:41,450
that there's this column headers right

00:44:37,490 --> 00:44:44,180
and then lower down cased in order to

00:44:41,450 --> 00:44:45,890
keep the semantics of the HTTP protocol

00:44:44,180 --> 00:44:47,720
these information has to be preserved

00:44:45,890 --> 00:44:50,599
right before that it was part of the

00:44:47,720 --> 00:44:53,119
status line so it has to be in every

00:44:50,599 --> 00:44:56,510
request but now that it should stay

00:44:53,119 --> 00:44:58,339
there they got injected into these Colin

00:44:56,510 --> 00:45:00,380
headers for everything which was part of

00:44:58,339 --> 00:45:04,819
the status lines known this column

00:45:00,380 --> 00:45:06,440
headers I don't have the hex dumb

00:45:04,819 --> 00:45:08,359
version here but we can check in a sec

00:45:06,440 --> 00:45:10,010
as well so then we received some

00:45:08,359 --> 00:45:12,859
settings then there's an acknowledgement

00:45:10,010 --> 00:45:16,220
for the settings we just received then

00:45:12,859 --> 00:45:19,760
we receive the headers so status 200

00:45:16,220 --> 00:45:21,980
connection type and then we're sending

00:45:19,760 --> 00:45:22,970
another another acknowledgment for the

00:45:21,980 --> 00:45:26,089
settings so as you see it's all

00:45:22,970 --> 00:45:28,190
happening in parallel so this receive

00:45:26,089 --> 00:45:29,900
settings are so these parts belong

00:45:28,190 --> 00:45:31,520
together but due to the fact that it's

00:45:29,900 --> 00:45:34,099
all happening in parallel it can happen

00:45:31,520 --> 00:45:36,140
that the headers we receive are already

00:45:34,099 --> 00:45:38,000
here and the request is almost over but

00:45:36,140 --> 00:45:41,060
we still do the acknowledgment saying

00:45:38,000 --> 00:45:42,410
which is going on then receive some data

00:45:41,060 --> 00:45:45,370
and then we're sending the go away frame

00:45:42,410 --> 00:45:48,410
which is actually closing a connection

00:45:45,370 --> 00:45:49,640
let's see if I can just call right so

00:45:48,410 --> 00:45:53,810
you have the same thing but just for the

00:45:49,640 --> 00:45:58,550
heck stump I want I this is the actual

00:45:53,810 --> 00:45:59,990
content but what you see here is the

00:45:58,550 --> 00:46:02,000
actual headers though these are the

00:45:59,990 --> 00:46:03,860
compressed headers and if you want to

00:46:02,000 --> 00:46:05,300
that's what I just mentioned that stuff

00:46:03,860 --> 00:46:07,070
I'm doing at the moment so i want to

00:46:05,300 --> 00:46:09,470
write an implementation for that so it's

00:46:07,070 --> 00:46:12,350
just copying over the sex am so the tool

00:46:09,470 --> 00:46:16,250
nghe p is pretty pretty nifty and i can

00:46:12,350 --> 00:46:20,860
really recommend using that wow I have

00:46:16,250 --> 00:46:20,860
another thing I really like to show um

00:46:21,370 --> 00:46:29,800
to see my notes right no you don't

00:46:24,350 --> 00:46:31,940
that's good my notes on my castle okay

00:46:29,800 --> 00:46:33,530
you're allowed to see that all right

00:46:31,940 --> 00:46:35,300
this is the gold line of limitation side

00:46:33,530 --> 00:46:37,300
I was just crying from a console and

00:46:35,300 --> 00:46:41,390
they have a demo called goofer tiles

00:46:37,300 --> 00:46:44,510
what is good for tiles let's just

00:46:41,390 --> 00:46:45,680
request the goo fatales demo with 200

00:46:44,510 --> 00:46:47,420
milliseconds agencies but I've got

00:46:45,680 --> 00:46:50,150
enough time to explain it so the goofy

00:46:47,420 --> 00:46:53,390
child's image is not one big image it is

00:46:50,150 --> 00:46:57,490
lots of small images and we're receiving

00:46:53,390 --> 00:46:59,510
in here tile by tile and I just going to

00:46:57,490 --> 00:47:03,830
put a bit more here is it big enough

00:46:59,510 --> 00:47:07,760
yeah right so if you receive it with 30

00:47:03,830 --> 00:47:09,380
seconds milliseconds latency on an HP 11

00:47:07,760 --> 00:47:13,670
connection this is how the image would

00:47:09,380 --> 00:47:16,220
build up again 11 is optimized for

00:47:13,670 --> 00:47:19,640
throughput not for leniency now if I do

00:47:16,220 --> 00:47:21,920
the same thing with HIV too and also 30

00:47:19,640 --> 00:47:24,440
milliseconds latency the image below

00:47:21,920 --> 00:47:25,970
like this because we have 30

00:47:24,440 --> 00:47:28,280
milliseconds at the very beginning and

00:47:25,970 --> 00:47:31,100
then all toilets could send it the same

00:47:28,280 --> 00:47:33,710
at the same time all right so I think in

00:47:31,100 --> 00:47:34,700
this demo it makes total sense so 200

00:47:33,710 --> 00:47:40,220
seconds you might see it a little bit

00:47:34,700 --> 00:47:41,540
better and here every tile has again

00:47:40,220 --> 00:47:43,550
because it's opening of a new connection

00:47:41,540 --> 00:47:45,770
right so it's waiting again 200

00:47:43,550 --> 00:47:49,590
milliseconds 20 milliseconds for each

00:47:45,770 --> 00:47:55,590
child okay

00:47:49,590 --> 00:48:01,110
I think let's know the demo right that

00:47:55,590 --> 00:48:03,600
tons of tons of the same was around you

00:48:01,110 --> 00:48:06,360
can check out an image in the ends of my

00:48:03,600 --> 00:48:08,130
slides as tons of links but now let's

00:48:06,360 --> 00:48:10,560
take a look at the at the browsers

00:48:08,130 --> 00:48:13,290
actually supporting it as it just saw

00:48:10,560 --> 00:48:16,590
was using Safari so sec Safari is using

00:48:13,290 --> 00:48:17,970
it and what do we do when we want to

00:48:16,590 --> 00:48:20,550
check if something is supported by

00:48:17,970 --> 00:48:22,740
current browsers we go to can I use and

00:48:20,550 --> 00:48:25,320
here you see every recent browser does

00:48:22,740 --> 00:48:27,720
support it and if you check the number

00:48:25,320 --> 00:48:30,150
I'm German so I checked the number for

00:48:27,720 --> 00:48:32,130
Germany and Germany is the support is

00:48:30,150 --> 00:48:36,840
seventy-three percent and even global

00:48:32,130 --> 00:48:39,300
it's over sixty percent support so can I

00:48:36,840 --> 00:48:44,130
use has this nice feature that you can

00:48:39,300 --> 00:48:48,300
display by relative usage and this looks

00:48:44,130 --> 00:48:49,680
like that so due to the fact that three

00:48:48,300 --> 00:48:51,510
people raise their hand if they're

00:48:49,680 --> 00:48:55,350
actually using it I might ask you why

00:48:51,510 --> 00:48:58,730
are you optimizing for this right every

00:48:55,350 --> 00:49:01,950
other every other browser supports it

00:48:58,730 --> 00:49:03,570
right if you see here firefox does it

00:49:01,950 --> 00:49:05,670
for very long time chrome does it for

00:49:03,570 --> 00:49:09,720
almost every version here you see in the

00:49:05,670 --> 00:49:14,700
next Dora this is version 11 um so

00:49:09,720 --> 00:49:16,620
that's like that high whoa okay here you

00:49:14,700 --> 00:49:19,260
see in the latest iOS release and iOS

00:49:16,620 --> 00:49:21,150
had the great adoption rate it's also

00:49:19,260 --> 00:49:24,870
supported same for the latest too far

00:49:21,150 --> 00:49:27,240
release it's also in there the window

00:49:24,870 --> 00:49:28,680
the windows I has a little bit of a

00:49:27,240 --> 00:49:30,720
different color because it only works

00:49:28,680 --> 00:49:32,490
with Windows 10 for whatever reason I

00:49:30,720 --> 00:49:36,720
don't know that is stupid implemented

00:49:32,490 --> 00:49:39,360
correctly um yeah so my question is why

00:49:36,720 --> 00:49:40,920
optimizes with this and then let's talk

00:49:39,360 --> 00:49:42,570
about the service right because the web

00:49:40,920 --> 00:49:44,520
is made of clients and service and now

00:49:42,570 --> 00:49:46,680
that I really proved you that there is

00:49:44,520 --> 00:49:49,760
no reason to not use it on the client

00:49:46,680 --> 00:49:53,340
side let's take a look at the service so

00:49:49,760 --> 00:49:55,170
on the in order to understand the like

00:49:53,340 --> 00:49:56,670
the impact of a browser supporting it I

00:49:55,170 --> 00:49:58,980
think it's interesting to check the

00:49:56,670 --> 00:50:00,480
market share so really rough numbers

00:49:58,980 --> 00:50:03,099
here but it just looked them up on the

00:50:00,480 --> 00:50:05,650
Internet the Apache has almost 40

00:50:03,099 --> 00:50:08,109
send of marker on the web the Microsoft

00:50:05,650 --> 00:50:09,819
is service almost 30 engineer's almost

00:50:08,109 --> 00:50:11,499
15 what I found particularly interesting

00:50:09,819 --> 00:50:13,359
that the google web server which you

00:50:11,499 --> 00:50:16,569
cannot deploy on your own already has

00:50:13,359 --> 00:50:19,359
two percent of the global traffic sick

00:50:16,569 --> 00:50:22,119
and then there's any other web servers

00:50:19,359 --> 00:50:24,130
like I don't know self-written ones Puma

00:50:22,119 --> 00:50:26,829
application servers all in the wild I

00:50:24,130 --> 00:50:28,059
don't know the rest so Google Apps LS

00:50:26,829 --> 00:50:30,089
that with that because it's like the

00:50:28,059 --> 00:50:32,529
sauce number as the smallest number here

00:50:30,089 --> 00:50:34,059
nothing published but we know that they

00:50:32,529 --> 00:50:36,249
dropped support for speedy februari last

00:50:34,059 --> 00:50:39,700
year so they probably had support for

00:50:36,249 --> 00:50:42,789
each of two then Apache has support

00:50:39,700 --> 00:50:44,890
since July last year so where's into 24

00:50:42,789 --> 00:50:47,259
12 and the next has support since July

00:50:44,890 --> 00:50:50,979
last year sorry sent him last year and

00:50:47,259 --> 00:50:52,420
which is version 1 95 and even is has

00:50:50,979 --> 00:50:56,049
support since Windows 10 and Windows

00:50:52,420 --> 00:50:58,660
Server 2016 so every reasoned Sabha has

00:50:56,049 --> 00:51:00,220
supported as well and upgrading and

00:50:58,660 --> 00:51:01,390
using it is actually super easy so let's

00:51:00,220 --> 00:51:03,519
take a look and engine X and apache

00:51:01,390 --> 00:51:06,160
because that's what i guess most of you

00:51:03,519 --> 00:51:07,900
use in the PHP environment right so

00:51:06,160 --> 00:51:09,910
using an Apache it's actually 19 change

00:51:07,900 --> 00:51:11,529
this is all you need you just have to

00:51:09,910 --> 00:51:14,529
load the module that's another

00:51:11,529 --> 00:51:17,170
prerequisite as I mentioned um you have

00:51:14,529 --> 00:51:18,999
to use SSL already and because it only

00:51:17,170 --> 00:51:21,670
the implementation only works one when

00:51:18,999 --> 00:51:23,619
ssl is enabled so you just have to load

00:51:21,670 --> 00:51:24,819
the module and that said this part is

00:51:23,619 --> 00:51:27,519
already optional it's just about the

00:51:24,819 --> 00:51:28,900
logging now let's take a look at

00:51:27,519 --> 00:51:30,940
engineers and i really love the

00:51:28,900 --> 00:51:33,339
engineers implementation so this is the

00:51:30,940 --> 00:51:34,599
engine X this is the block you already

00:51:33,339 --> 00:51:38,079
have here you're listening on a certain

00:51:34,599 --> 00:51:40,690
port and you just have to add that like

00:51:38,079 --> 00:51:42,960
five characters that's it it's a five

00:51:40,690 --> 00:51:46,359
characters change right so if you have a

00:51:42,960 --> 00:51:48,849
decent version of engine X just add this

00:51:46,359 --> 00:51:52,089
for five characters and then you enable

00:51:48,849 --> 00:51:54,069
them right and with that enable you can

00:51:52,089 --> 00:51:58,660
do like craziest things but I will talk

00:51:54,069 --> 00:52:01,079
about that in a second um so I just say

00:51:58,660 --> 00:52:03,700
that by I think you're only wrong

00:52:01,079 --> 00:52:05,079
because we are not we are holding it

00:52:03,700 --> 00:52:06,999
wrong but I'm standing here and you're

00:52:05,079 --> 00:52:09,219
sitting there so I just want to find it

00:52:06,999 --> 00:52:11,469
that way I think we as developers

00:52:09,219 --> 00:52:12,819
holding it wrong we are not using the

00:52:11,469 --> 00:52:14,079
features like server push and flow

00:52:12,819 --> 00:52:15,999
control and even though if you would

00:52:14,079 --> 00:52:16,630
upgrade um the way I just showed you

00:52:15,999 --> 00:52:18,340
won't

00:52:16,630 --> 00:52:19,720
use it as well because in the actual

00:52:18,340 --> 00:52:22,210
information there's no way to actually

00:52:19,720 --> 00:52:25,960
using that because push and server push

00:52:22,210 --> 00:52:27,610
is actually something the the

00:52:25,960 --> 00:52:29,830
application has to decide what to push

00:52:27,610 --> 00:52:31,570
and not the server and there is no way

00:52:29,830 --> 00:52:33,520
from the application to talk to the web

00:52:31,570 --> 00:52:35,470
server I mean there is one but it's not

00:52:33,520 --> 00:52:38,110
supporting ish we do and and the idea of

00:52:35,470 --> 00:52:40,330
sending commands and so this fcgi for

00:52:38,110 --> 00:52:41,920
example but there's no idea how several

00:52:40,330 --> 00:52:44,460
push could be implemented same for flow

00:52:41,920 --> 00:52:46,870
control right the server has somehow to

00:52:44,460 --> 00:52:49,180
decide itself if it want to change it

00:52:46,870 --> 00:52:52,570
but if you're writing any programming

00:52:49,180 --> 00:52:55,600
language might it be TP ruby elixir

00:52:52,570 --> 00:52:57,100
whatsoever can't unless you're writing

00:52:55,600 --> 00:52:58,630
the server at the moment right and

00:52:57,100 --> 00:53:00,820
interacting with the server directly

00:52:58,630 --> 00:53:02,890
there's no way when you're on this

00:53:00,820 --> 00:53:08,370
abstraction layer of application servers

00:53:02,890 --> 00:53:08,370
and applications to communicate here I

00:53:09,660 --> 00:53:15,010
think the solution for this is armed

00:53:12,670 --> 00:53:16,420
either we come up with a new kind of

00:53:15,010 --> 00:53:21,190
protocol for application servers and

00:53:16,420 --> 00:53:23,830
applications to do this or to use this

00:53:21,190 --> 00:53:26,310
with actual Network middlewares so what

00:53:23,830 --> 00:53:28,960
about writing a proxy you reverse proxy

00:53:26,310 --> 00:53:31,180
who's just cashing the index files and

00:53:28,960 --> 00:53:33,250
then build up a mapping of the actual

00:53:31,180 --> 00:53:35,320
page you requested and the assets in

00:53:33,250 --> 00:53:36,760
there and when it sees the request to

00:53:35,320 --> 00:53:39,010
just pass it through the request but

00:53:36,760 --> 00:53:40,870
sending out the assets needed I think

00:53:39,010 --> 00:53:42,610
this could this could working this could

00:53:40,870 --> 00:53:44,650
be working I tried to implement this an

00:53:42,610 --> 00:53:47,290
engineer salua when engine takes have

00:53:44,650 --> 00:53:49,720
the support but I figured that the API

00:53:47,290 --> 00:53:51,790
is like poorly documented would be wrong

00:53:49,720 --> 00:53:53,500
because it's not documented so it's not

00:53:51,790 --> 00:53:55,960
poor document it's not a few minute and

00:53:53,500 --> 00:53:57,940
maybe this changed it was in September

00:53:55,960 --> 00:53:59,470
last year maybe it's way better now and

00:53:57,940 --> 00:54:03,190
you can just implement it with a few

00:53:59,470 --> 00:54:05,370
lines of code I guess so what I want you

00:54:03,190 --> 00:54:08,350
to take away from this talk is really

00:54:05,370 --> 00:54:10,000
optimized like upgrade and then optimize

00:54:08,350 --> 00:54:12,880
you should stop concatenating files

00:54:10,000 --> 00:54:15,850
because this is just a workaround we did

00:54:12,880 --> 00:54:17,560
in 11 which is absolutely not not

00:54:15,850 --> 00:54:19,600
feasible anymore in a world where you

00:54:17,560 --> 00:54:21,040
optimize for to write and you all know

00:54:19,600 --> 00:54:23,770
the pain we have with concatenating

00:54:21,040 --> 00:54:25,900
imagine your JavaScript application that

00:54:23,770 --> 00:54:28,360
your application is which is like about

00:54:25,900 --> 00:54:29,750
a megabyte files and then there's one

00:54:28,360 --> 00:54:31,820
library which update

00:54:29,750 --> 00:54:34,580
and the thing you have to do is if to

00:54:31,820 --> 00:54:36,830
send out again the whole JavaScript

00:54:34,580 --> 00:54:38,660
there's no way because it's just one

00:54:36,830 --> 00:54:40,790
block right there's no differentiation

00:54:38,660 --> 00:54:42,380
between the files and you could have

00:54:40,790 --> 00:54:45,380
this right you can just include all the

00:54:42,380 --> 00:54:47,330
JavaScript files and you don't get a

00:54:45,380 --> 00:54:50,360
penalty for this anymore so

00:54:47,330 --> 00:54:52,790
concatenating is there's no reason to do

00:54:50,360 --> 00:54:55,550
that anymore same for spriting right it

00:54:52,790 --> 00:54:58,880
was it was the thing we had to do we had

00:54:55,550 --> 00:55:02,060
to optimize 44 the 11 protocol but it's

00:54:58,880 --> 00:55:03,650
not there's not any more and this is the

00:55:02,060 --> 00:55:05,480
most important one right stop the main

00:55:03,650 --> 00:55:07,460
charting because all the upsides I did

00:55:05,480 --> 00:55:11,120
with just discussing our per connection

00:55:07,460 --> 00:55:13,160
and if you chart it across domains you

00:55:11,120 --> 00:55:15,170
will lose like all the upsides because

00:55:13,160 --> 00:55:19,570
you will have shared header compression

00:55:15,170 --> 00:55:21,980
tables / connection you can't do the

00:55:19,570 --> 00:55:23,210
rebalancing and the reprioritization of

00:55:21,980 --> 00:55:25,190
assets when they are two different

00:55:23,210 --> 00:55:27,680
connections so this is the most

00:55:25,190 --> 00:55:30,140
important one stop the main charting and

00:55:27,680 --> 00:55:31,550
I want to propose to really trash the

00:55:30,140 --> 00:55:34,400
asset pipeline because you don't need it

00:55:31,550 --> 00:55:36,410
anymore this is obviously just the

00:55:34,400 --> 00:55:39,080
half-truths and it's like with a big

00:55:36,410 --> 00:55:40,610
claim because if you use coffeescript or

00:55:39,080 --> 00:55:43,160
something yeah browser don't support it

00:55:40,610 --> 00:55:44,600
you have to compile it or transpile it

00:55:43,160 --> 00:55:47,030
but all the stuff i mentioned before

00:55:44,600 --> 00:55:50,060
like concatenating and this it's just

00:55:47,030 --> 00:55:52,370
you know need it just throw it away and

00:55:50,060 --> 00:55:53,750
remove all the complexity right you want

00:55:52,370 --> 00:55:57,350
to jump on like if you have a deal with

00:55:53,750 --> 00:55:59,240
backpack it's like it's adding

00:55:57,350 --> 00:56:02,120
complexity where it's not there's no

00:55:59,240 --> 00:56:03,950
need to have complexity anymore so I

00:56:02,120 --> 00:56:06,380
want really to encourage you to start

00:56:03,950 --> 00:56:08,440
using HP to not only upgrading but

00:56:06,380 --> 00:56:12,020
really make use of the features

00:56:08,440 --> 00:56:13,970
declutter your big JavaScript blob stops

00:56:12,020 --> 00:56:16,610
writing this kind of stuff and upgrade

00:56:13,970 --> 00:56:19,910
it right there's almost no the reason

00:56:16,610 --> 00:56:21,440
not to do it we always optimized for the

00:56:19,910 --> 00:56:23,810
majority of our users right and check

00:56:21,440 --> 00:56:26,240
user base if you're supporting a website

00:56:23,810 --> 00:56:27,170
which is almost only IE 8 users well

00:56:26,240 --> 00:56:28,850
then you should probably you don't

00:56:27,170 --> 00:56:33,670
upgrade right but this is hopefully

00:56:28,850 --> 00:56:35,960
nothing I have to tell you well um

00:56:33,670 --> 00:56:37,940
something I really want to I wouldn't

00:56:35,960 --> 00:56:39,860
really want to do is to give my company

00:56:37,940 --> 00:56:41,540
little shout out so i have this five

00:56:39,860 --> 00:56:43,290
seconds of fireworks for them they

00:56:41,540 --> 00:56:46,980
actually gave me the time to work

00:56:43,290 --> 00:56:49,650
this and they actually help me coming

00:56:46,980 --> 00:56:51,240
here preparing all this stuff and if you

00:56:49,650 --> 00:56:53,160
want to know more about building

00:56:51,240 --> 00:56:54,570
websites with our awesome website

00:56:53,160 --> 00:56:56,400
builder or whacking Hamburg's the most

00:56:54,570 --> 00:56:59,970
wonderful city in germany please just

00:56:56,400 --> 00:57:02,340
come to me and ask me and also one other

00:56:59,970 --> 00:57:04,440
little detail is my name so I'm only

00:57:02,340 --> 00:57:06,480
machetes and if you got any feedback to

00:57:04,440 --> 00:57:08,610
me please just tweet me this is like the

00:57:06,480 --> 00:57:10,620
best way to approach me I'm just so just

00:57:08,610 --> 00:57:13,290
jump on twitter follow me at coasters

00:57:10,620 --> 00:57:16,020
drop me any line you have come here

00:57:13,290 --> 00:57:17,670
afterwards after the talk this is my

00:57:16,020 --> 00:57:19,500
github what I always liked what i always

00:57:17,670 --> 00:57:21,210
want to point out get up has this

00:57:19,500 --> 00:57:22,800
following feature and I know if someone

00:57:21,210 --> 00:57:24,180
I don't know if someone who uses it by

00:57:22,800 --> 00:57:26,580
the things that's but if you

00:57:24,180 --> 00:57:29,460
want is this thing you do just follow me

00:57:26,580 --> 00:57:32,250
get up check out my homepage concepts of

00:57:29,460 --> 00:57:34,500
you on my side projects that i owe and

00:57:32,250 --> 00:57:36,570
so coded the awesome web conference in

00:57:34,500 --> 00:57:38,340
Hamburg I have this stickers with me so

00:57:36,570 --> 00:57:40,980
if you want to grab a sticker just come

00:57:38,340 --> 00:57:43,730
here after this talk and this is all I

00:57:40,980 --> 00:57:43,730
got thank you very much

00:57:52,190 --> 00:58:01,160
we have do we want to do questions okay

00:57:56,100 --> 00:58:01,160
oh yeah there's question so let's see a

00:58:02,240 --> 00:58:06,750
couple of questions one thing just to

00:58:05,340 --> 00:58:09,720
one there other questions as well so

00:58:06,750 --> 00:58:13,010
pick your top priority okay I'll take

00:58:09,720 --> 00:58:16,830
the other one that and it was just the

00:58:13,010 --> 00:58:19,290
the actual payload is GZ right is that

00:58:16,830 --> 00:58:21,630
that's that's true isn't it and they use

00:58:19,290 --> 00:58:25,230
gzip compression on the payload in HTTP

00:58:21,630 --> 00:58:28,800
too and with that being the case would

00:58:25,230 --> 00:58:31,440
you then argue also to stop minifying as

00:58:28,800 --> 00:58:33,060
well on the basis that there's no point

00:58:31,440 --> 00:58:34,680
if it's going to get compressed anyway

00:58:33,060 --> 00:58:37,380
it's again just a bit of extra

00:58:34,680 --> 00:58:39,420
complexity it's not needed right there

00:58:37,380 --> 00:58:42,330
will be my recommendation if you minify

00:58:39,420 --> 00:58:44,100
you would gain some some some better

00:58:42,330 --> 00:58:46,140
results because minifying also like

00:58:44,100 --> 00:58:49,560
shorts variable names and stuff this is

00:58:46,140 --> 00:58:51,930
something Jesus doesn't do but in favor

00:58:49,560 --> 00:58:53,880
of like removing complexity I would say

00:58:51,930 --> 00:58:55,770
yes to it but this something like this

00:58:53,880 --> 00:58:57,870
is a decision everyone has to like do on

00:58:55,770 --> 00:59:01,530
their own it's not something which is

00:58:57,870 --> 00:59:08,640
like special to the protocol okay other

00:59:01,530 --> 00:59:10,770
questions you mentioned domain shouting

00:59:08,640 --> 00:59:12,510
and what have you but what about cdns

00:59:10,770 --> 00:59:14,730
and things like that where you do have

00:59:12,510 --> 00:59:17,310
connections to different providers for

00:59:14,730 --> 00:59:18,960
assets is it worth not doing that

00:59:17,310 --> 00:59:21,270
anymore and I think it bring them under

00:59:18,960 --> 00:59:23,640
one server I think City ends are great

00:59:21,270 --> 00:59:25,710
and if you like if you manage to get

00:59:23,640 --> 00:59:28,020
audio traffic through one CDN on one

00:59:25,710 --> 00:59:28,920
host this is great right and then hope

00:59:28,020 --> 00:59:31,050
that your city and provide are

00:59:28,920 --> 00:59:33,960
implemented right but they usually have

00:59:31,050 --> 00:59:36,450
11 host right and they just if they just

00:59:33,960 --> 00:59:38,790
managed to have in one connection that's

00:59:36,450 --> 00:59:41,670
completely fine so I think the city

00:59:38,790 --> 00:59:43,650
anthem is like CDNs CD ends are not a

00:59:41,670 --> 00:59:46,680
problem here right if they implemented

00:59:43,650 --> 00:59:49,290
poorly that might be a problem and I

00:59:46,680 --> 00:59:50,880
think CDN are a good solution to this to

00:59:49,290 --> 00:59:55,560
this whole upgrading problem in general

00:59:50,880 --> 00:59:57,570
because not every web server especially

00:59:55,560 --> 00:59:59,070
if you have application servers so

00:59:57,570 --> 01:00:01,730
implemented in language and not the

00:59:59,070 --> 01:00:03,320
generic ones like engineers or Apache

01:00:01,730 --> 01:00:04,640
city ends are a good way to upgrade

01:00:03,320 --> 01:00:06,680
because they can give you all the

01:00:04,640 --> 01:00:08,869
upsides right they cash the actual acids

01:00:06,680 --> 01:00:10,670
and can deliver the assets for you

01:00:08,869 --> 01:00:12,980
because they have them in the cash and

01:00:10,670 --> 01:00:15,380
your server with it just may be just

01:00:12,980 --> 01:00:18,980
rendering HTML pages then don't even

01:00:15,380 --> 01:00:20,900
need MHP to write it's a city and it has

01:00:18,980 --> 01:00:22,850
a good implementation it can handle that

01:00:20,900 --> 01:00:24,560
for you so it can handle the HTV to

01:00:22,850 --> 01:00:27,140
connection on the one hand and then just

01:00:24,560 --> 01:00:30,050
transform it so transformed the one to

01:00:27,140 --> 01:00:33,950
the two part but this is always about

01:00:30,050 --> 01:00:36,800
implementation yeah how practical and

01:00:33,950 --> 01:00:39,859
easy is it to arrange a fallback to HTTP

01:00:36,800 --> 01:00:42,650
1.1 if the calling browser doesn't

01:00:39,859 --> 01:00:44,900
support doesn't support that because the

01:00:42,650 --> 01:00:47,420
transparency of switching apache is

01:00:44,900 --> 01:00:49,700
quite quite quick and easy so the only

01:00:47,420 --> 01:00:51,230
question remaining would be how easy is

01:00:49,700 --> 01:00:53,450
it to fall back for the older older

01:00:51,230 --> 01:00:55,250
browsers as we are there's almost no

01:00:53,450 --> 01:00:57,619
like there's almost no penalty there's

01:00:55,250 --> 01:00:59,869
actually no penalty because when you

01:00:57,619 --> 01:01:03,890
like the Apache has dlp an extension and

01:00:59,869 --> 01:01:06,859
it doesn't like it supports hiv-1 as

01:01:03,890 --> 01:01:10,490
well right so it's not only sending h2

01:01:06,859 --> 01:01:12,710
as protocols so it sends I guess it

01:01:10,490 --> 01:01:14,540
should be one and two and whatever it

01:01:12,710 --> 01:01:17,660
supports as well and then the server

01:01:14,540 --> 01:01:19,730
just picks right so when the client

01:01:17,660 --> 01:01:24,230
supports that that's solely find this no

01:01:19,730 --> 01:01:27,010
thank you Oh penalty here in the front

01:01:24,230 --> 01:01:27,010
of this question

01:01:27,119 --> 01:01:33,720
I think we doesn't do two more question

01:01:30,210 --> 01:01:35,329
let's say that you have one or more

01:01:33,720 --> 01:01:39,019
proxies in front of your web server

01:01:35,329 --> 01:01:42,119
which part of the chain has to implement

01:01:39,019 --> 01:01:45,180
HTTP to protocol all over them the first

01:01:42,119 --> 01:01:48,900
one the first one you hit because it's

01:01:45,180 --> 01:01:50,789
via TLS so intermediaries don't see the

01:01:48,900 --> 01:01:54,900
traffic they just see an encrypted blob

01:01:50,789 --> 01:01:57,420
of TCP so the first one has to like do

01:01:54,900 --> 01:02:07,700
the SSL termination and then I'm handle

01:01:57,420 --> 01:02:11,190
all this okay yeah thanks last one is a

01:02:07,700 --> 01:02:12,960
cache posting URLs still value or a

01:02:11,190 --> 01:02:15,299
weight by way to do that in HD BTW i

01:02:12,960 --> 01:02:17,999
think it is like the caching mechanisms

01:02:15,299 --> 01:02:19,650
are has almost stayed the same so

01:02:17,999 --> 01:02:20,930
whatever you did before I'm is

01:02:19,650 --> 01:02:23,309
definitely a good way to doing it

01:02:20,930 --> 01:02:26,309
talking about attacks for example or

01:02:23,309 --> 01:02:28,740
just putting the M time in the UL this

01:02:26,309 --> 01:02:31,619
is all very valid and um this is the

01:02:28,740 --> 01:02:33,299
fact that we are not talking about City

01:02:31,619 --> 01:02:34,799
instant stuff I think it's maybe even

01:02:33,299 --> 01:02:37,170
more important but this depends on you

01:02:34,799 --> 01:02:38,609
set up but this is not something the

01:02:37,170 --> 01:02:40,410
protocol takes away from you it just

01:02:38,609 --> 01:02:42,569
offers the same mechanism which has been

01:02:40,410 --> 01:02:44,670
around before like cache control headers

01:02:42,569 --> 01:02:46,980
and stuff I was just wondering if

01:02:44,670 --> 01:02:49,619
there's a way to achieve push so like

01:02:46,980 --> 01:02:51,029
mom but if people are using anyway this

01:02:49,619 --> 01:02:52,650
depends how you implement it right I

01:02:51,029 --> 01:02:55,160
mean you can upgrade an asset which is

01:02:52,650 --> 01:02:58,559
in the browser in the browser cache and

01:02:55,160 --> 01:03:01,440
if you'd like it's it's just doing the

01:02:58,559 --> 01:03:05,960
look up by path right so if you have the

01:03:01,440 --> 01:03:09,089
M time in the in the in the actual path

01:03:05,960 --> 01:03:10,739
upgrading doesn't like it is a different

01:03:09,089 --> 01:03:12,809
asset for the browser right even though

01:03:10,739 --> 01:03:14,730
it's just changed a little bit so then

01:03:12,809 --> 01:03:15,839
operating it the server push doesn't

01:03:14,730 --> 01:03:18,089
make a lot of sense if you don't have

01:03:15,839 --> 01:03:20,970
that and you have etags so if i push

01:03:18,089 --> 01:03:22,619
could help you here well thank you give

01:03:20,970 --> 01:03:24,460
awesome okay that's it thank you very

01:03:22,619 --> 01:03:26,520
much

01:03:24,460 --> 01:03:26,520

YouTube URL: https://www.youtube.com/watch?v=sRo98KNmBuM


