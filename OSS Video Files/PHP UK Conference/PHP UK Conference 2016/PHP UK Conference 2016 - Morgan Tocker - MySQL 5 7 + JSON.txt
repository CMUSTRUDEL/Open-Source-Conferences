Title: PHP UK Conference 2016 - Morgan Tocker - MySQL 5 7 + JSON
Publication date: 2016-03-16
Playlist: PHP UK Conference 2016
Description: 
	With the newly added JSON support in MySQL, you can combine the flexibility of NoSQL with the strength of a relational database. In this session, Morgan will explain the new JSON datatype, and the new set of functions for handling JSON documents, available storage and indexing options. In addition, he will present benchmarks showing how much one can expect from the MySQL server in different use case scenarios.
Captions: 
	00:00:04,840 --> 00:00:10,670
so hello everyone thank you for coming

00:00:08,049 --> 00:00:13,280
my name is Morgan talker I work on the

00:00:10,670 --> 00:00:14,600
MySQL product management team I just

00:00:13,280 --> 00:00:17,510
joined this team a couple of months ago

00:00:14,600 --> 00:00:19,940
I product manage the mysql server my

00:00:17,510 --> 00:00:22,939
buyer outlining probably says that I

00:00:19,940 --> 00:00:25,460
worked on the community team I've worked

00:00:22,939 --> 00:00:28,330
with MySQL for just over 10 years now I

00:00:25,460 --> 00:00:31,640
originally joined the MySQL team in 2006

00:00:28,330 --> 00:00:34,940
what I'm talking about today is one very

00:00:31,640 --> 00:00:36,530
specific feature of MySQL 57 which is

00:00:34,940 --> 00:00:38,660
your new ability to be able to store

00:00:36,530 --> 00:00:43,039
unstructured data along with your

00:00:38,660 --> 00:00:44,510
structured data I will have a disclaimer

00:00:43,039 --> 00:00:46,670
and say that if you don't know what

00:00:44,510 --> 00:00:51,320
Jason is it will make this talk a little

00:00:46,670 --> 00:00:52,789
bit hard but I will try for the 15

00:00:51,320 --> 00:00:56,149
second version and say that it's a way

00:00:52,789 --> 00:01:00,170
of replacing XML and how you store data

00:00:56,149 --> 00:01:02,090
and it's commonly used in api's so our

00:01:00,170 --> 00:01:04,030
gender today is as I said I'm really

00:01:02,090 --> 00:01:07,220
speaking about this new Jason feature

00:01:04,030 --> 00:01:08,900
before I get to that I want to talk a

00:01:07,220 --> 00:01:11,480
little bit about us tell you about the

00:01:08,900 --> 00:01:14,870
MySQL team how we release software on

00:01:11,480 --> 00:01:16,880
why this release is very important with

00:01:14,870 --> 00:01:18,730
database software with infrastructure

00:01:16,880 --> 00:01:22,130
software we can't release new versions

00:01:18,730 --> 00:01:24,110
that frequently so 57 is just under

00:01:22,130 --> 00:01:26,660
three years in development and we're

00:01:24,110 --> 00:01:29,000
very happy with the functionality that

00:01:26,660 --> 00:01:30,650
we've been able to deliver for you my

00:01:29,000 --> 00:01:32,870
main part of the talk will be describing

00:01:30,650 --> 00:01:34,190
that new Jason experience it's comprised

00:01:32,870 --> 00:01:36,800
with a few different features that are

00:01:34,190 --> 00:01:39,170
working together and then the end of my

00:01:36,800 --> 00:01:41,840
talk will be described now that you have

00:01:39,170 --> 00:01:44,150
this new functionality should you be

00:01:41,840 --> 00:01:46,480
using it and should you be replacing how

00:01:44,150 --> 00:01:48,920
you've traditionally been storing data

00:01:46,480 --> 00:01:51,710
so i want to say please interrupt me and

00:01:48,920 --> 00:01:54,680
ask questions I love questions I'm

00:01:51,710 --> 00:01:57,860
giving this talk on the back of a 20 day

00:01:54,680 --> 00:02:00,740
tour through Europe launching mysql 57

00:01:57,860 --> 00:02:02,030
and it's exciting for me you know if

00:02:00,740 --> 00:02:03,560
there's always challenges and there's

00:02:02,030 --> 00:02:07,070
always interaction so that's that's

00:02:03,560 --> 00:02:09,489
trying to achieve that so to introduce

00:02:07,070 --> 00:02:12,170
us and to talk about the MySQL team

00:02:09,489 --> 00:02:15,010
mysql 57 was developed by the largest

00:02:12,170 --> 00:02:17,800
engineering team to ever work on mysql

00:02:15,010 --> 00:02:20,050
we joined the oracle team in

00:02:17,800 --> 00:02:21,810
january twenty to ten in that time we've

00:02:20,050 --> 00:02:25,450
doubled the size of the engineering team

00:02:21,810 --> 00:02:28,810
with 3x the size of the QA team in

00:02:25,450 --> 00:02:30,760
particular we know that for a database

00:02:28,810 --> 00:02:32,590
server you care about quality and so

00:02:30,760 --> 00:02:34,420
we've made sure that we've made big

00:02:32,590 --> 00:02:37,390
strides in improving this wherever we

00:02:34,420 --> 00:02:39,430
can and another small facet of that is

00:02:37,390 --> 00:02:42,190
we've increased the size of the support

00:02:39,430 --> 00:02:43,360
team and this turns out to be important

00:02:42,190 --> 00:02:46,690
whether or not you're a paying customer

00:02:43,360 --> 00:02:48,280
as we loop them in to to really make

00:02:46,690 --> 00:02:49,480
sure that we backport the right bug

00:02:48,280 --> 00:02:51,490
fixes and we don't introduce

00:02:49,480 --> 00:02:54,010
incompatibilities as we're fixing things

00:02:51,490 --> 00:02:56,440
in GA releases there's another aspect to

00:02:54,010 --> 00:02:58,120
quality which means no surprises even if

00:02:56,440 --> 00:03:00,850
it does mean a fix so we're very careful

00:02:58,120 --> 00:03:03,310
with that takes two to three years to

00:03:00,850 --> 00:03:08,110
develop a new GA release MySQL 57 it

00:03:03,310 --> 00:03:10,510
went GA in October 2015 you may have

00:03:08,110 --> 00:03:13,420
heard us talking about MySQL 57 for some

00:03:10,510 --> 00:03:15,100
time this is because we have a set of

00:03:13,420 --> 00:03:17,860
preview releases that you can also

00:03:15,100 --> 00:03:20,260
download to try out to get early access

00:03:17,860 --> 00:03:21,760
to mysql so i want to describe those

00:03:20,260 --> 00:03:23,620
other preview releases because

00:03:21,760 --> 00:03:27,160
inevitably will be coming out with

00:03:23,620 --> 00:03:29,500
preview leases of mysql 58 as well we

00:03:27,160 --> 00:03:31,630
release two types of preview releases

00:03:29,500 --> 00:03:33,190
wanna code dmoz or develop a milestone

00:03:31,630 --> 00:03:36,580
releases and the other code labs

00:03:33,190 --> 00:03:39,070
releases to be a developer milestone

00:03:36,580 --> 00:03:41,110
release when we develop a set of new

00:03:39,070 --> 00:03:43,060
features we ensure that it has a high

00:03:41,110 --> 00:03:45,430
level review to make sure that it works

00:03:43,060 --> 00:03:47,980
with all existing features we have a

00:03:45,430 --> 00:03:50,170
couple of low-level reviews in terms of

00:03:47,980 --> 00:03:52,270
code quality and code architecture and

00:03:50,170 --> 00:03:55,270
we aim for eighty percent plus code

00:03:52,270 --> 00:03:57,880
coverage before we are presented to you

00:03:55,270 --> 00:03:59,320
in a milestone so this is your

00:03:57,880 --> 00:04:01,480
opportunity to be able to give us

00:03:59,320 --> 00:04:03,190
feedback with our new features we say

00:04:01,480 --> 00:04:04,780
that this is not an alpha this is not a

00:04:03,190 --> 00:04:07,120
beta we know that with infrastructure

00:04:04,780 --> 00:04:09,280
software people are scared of that this

00:04:07,120 --> 00:04:10,570
is a developer milestone release that's

00:04:09,280 --> 00:04:13,000
approximately of release candidate

00:04:10,570 --> 00:04:14,530
quality this is a good opportunity for

00:04:13,000 --> 00:04:17,470
you to be able to give us feedback as

00:04:14,530 --> 00:04:19,570
once things go to GA sometimes to not

00:04:17,470 --> 00:04:22,210
break compatibility it's very hard to

00:04:19,570 --> 00:04:25,000
fix or change things so some of our top

00:04:22,210 --> 00:04:27,729
users are using dmrs as early adopters

00:04:25,000 --> 00:04:29,289
and giving us great feedback the other

00:04:27,729 --> 00:04:31,009
type of release that we put out is a

00:04:29,289 --> 00:04:33,169
labs release

00:04:31,009 --> 00:04:35,059
Labs is our way of saying it's not ready

00:04:33,169 --> 00:04:37,729
it's really not it hasn't passed that

00:04:35,059 --> 00:04:40,069
that feature quality code coverage high

00:04:37,729 --> 00:04:42,610
level architecture but we want your

00:04:40,069 --> 00:04:44,839
feedback because this is a directional

00:04:42,610 --> 00:04:48,169
this is this is where the product is

00:04:44,839 --> 00:04:50,740
going and this too out there on our labs

00:04:48,169 --> 00:04:53,509
my school com web site at the moment

00:04:50,740 --> 00:04:55,759
that are really interesting one is we

00:04:53,509 --> 00:04:58,490
have group replication which is like a

00:04:55,759 --> 00:05:00,289
master master replication clustering

00:04:58,490 --> 00:05:01,999
system where you can read from any

00:05:00,289 --> 00:05:05,330
server and you can write from any server

00:05:01,999 --> 00:05:06,800
and the other labs release that we we

00:05:05,330 --> 00:05:08,029
have out at the moment that's really

00:05:06,800 --> 00:05:11,419
interesting is we have something called

00:05:08,029 --> 00:05:13,629
out data dictionary labs release we're

00:05:11,419 --> 00:05:16,279
trying to replace some of the core

00:05:13,629 --> 00:05:18,199
plumbing of MySQL if you're a long time

00:05:16,279 --> 00:05:20,360
user you're familiar with us using these

00:05:18,199 --> 00:05:22,610
frm files for storing data dictionary

00:05:20,360 --> 00:05:24,169
we're transitioning to be able to store

00:05:22,610 --> 00:05:25,819
our data dictionary and in order to be

00:05:24,169 --> 00:05:28,149
internally it's one of the largest

00:05:25,819 --> 00:05:31,129
projects that we've ever attempted and

00:05:28,149 --> 00:05:35,539
this will ship some time in the future

00:05:31,129 --> 00:05:37,490
not in MySQL 57 so with that I said yes

00:05:35,539 --> 00:05:41,719
the final product the one that you can

00:05:37,490 --> 00:05:44,330
deploy your apps in GA October 2015 what

00:05:41,719 --> 00:05:46,279
were the main features this was what

00:05:44,330 --> 00:05:48,559
went out in the press release saying you

00:05:46,279 --> 00:05:51,139
know hello world time to start using

00:05:48,559 --> 00:05:53,509
mysql 50 we differentiated into two

00:05:51,139 --> 00:05:54,800
categories we said that it's it's great

00:05:53,509 --> 00:05:59,029
on performance and it's great on

00:05:54,800 --> 00:06:02,659
manageability and i'm zooming in on that

00:05:59,029 --> 00:06:04,699
Jason topic in manageability and I will

00:06:02,659 --> 00:06:06,889
answer questions on some of these other

00:06:04,699 --> 00:06:08,479
things as we have time at the end i

00:06:06,889 --> 00:06:11,080
think that jason is a good story in it

00:06:08,479 --> 00:06:14,360
it is very applicable to all audiences

00:06:11,080 --> 00:06:16,689
but if you're an administrator of mysql

00:06:14,360 --> 00:06:19,580
the some nice things in terms of

00:06:16,689 --> 00:06:22,339
replication has a lot of improvements we

00:06:19,580 --> 00:06:26,330
can apply replication in parallel on

00:06:22,339 --> 00:06:29,149
slaves far more efficiently and in a

00:06:26,330 --> 00:06:30,680
previous position I was doing a lot of

00:06:29,149 --> 00:06:32,779
performance consulting with with

00:06:30,680 --> 00:06:34,849
customers and one thing that I observed

00:06:32,779 --> 00:06:36,919
the most is those that have performance

00:06:34,849 --> 00:06:40,159
problems don't have them because the

00:06:36,919 --> 00:06:41,509
database server is slow per say they

00:06:40,159 --> 00:06:43,999
have performance problems because they

00:06:41,509 --> 00:06:44,600
don't have the visibility to be able to

00:06:43,999 --> 00:06:46,190
see what

00:06:44,600 --> 00:06:49,910
happening in their database server and

00:06:46,190 --> 00:06:52,130
we have two big improvements in terms of

00:06:49,910 --> 00:06:55,700
our performance schemer and our sis

00:06:52,130 --> 00:06:59,210
schema on a fresh MySQL 57 installation

00:06:55,700 --> 00:07:01,760
I can say select star from sis statement

00:06:59,210 --> 00:07:03,890
underscore analysis I can find my top 10

00:07:01,760 --> 00:07:06,350
slow queries and I can start optimizing

00:07:03,890 --> 00:07:07,670
straightaway there's there's a lot of

00:07:06,350 --> 00:07:09,830
things you can do once you have that

00:07:07,670 --> 00:07:13,820
visibility and I think we're extremely

00:07:09,830 --> 00:07:15,710
strong in this area so that was the that

00:07:13,820 --> 00:07:18,860
was the kind of high-level press release

00:07:15,710 --> 00:07:20,450
version of what's new the other

00:07:18,860 --> 00:07:22,910
alternative view that i want to show you

00:07:20,450 --> 00:07:25,070
of what's new is i created at our

00:07:22,910 --> 00:07:27,620
website and i call it the complete list

00:07:25,070 --> 00:07:30,410
of features calm and I had everything

00:07:27,620 --> 00:07:33,170
that's new so if you're a long time user

00:07:30,410 --> 00:07:35,240
uh there's just under 200 items that I

00:07:33,170 --> 00:07:39,440
discovered from going through change

00:07:35,240 --> 00:07:41,240
locks this website works on mobile if we

00:07:39,440 --> 00:07:43,970
get to the end we cover all the Jason

00:07:41,240 --> 00:07:46,430
stuff and you want to ask me some arcane

00:07:43,970 --> 00:07:48,410
question about number 27 under some

00:07:46,430 --> 00:07:50,240
category I'll do my best to be able to

00:07:48,410 --> 00:07:52,190
answer i can describe moister than here

00:07:50,240 --> 00:07:53,690
but i just wanted to show that for

00:07:52,190 --> 00:07:56,120
quantity just so you don't think that

00:07:53,690 --> 00:07:59,270
Jason was the only thing that we've

00:07:56,120 --> 00:08:01,100
added in why SQL 57 there's a lot of

00:07:59,270 --> 00:08:05,060
stuff that we've added and it's all

00:08:01,100 --> 00:08:06,530
extremely valuable the last thing that I

00:08:05,060 --> 00:08:08,750
want to mention when I said let's talk

00:08:06,530 --> 00:08:11,180
about us to start with is say that we're

00:08:08,750 --> 00:08:14,210
committed to build a business around the

00:08:11,180 --> 00:08:15,950
MySQL product and we do so by selling a

00:08:14,210 --> 00:08:18,950
subscription called MySQL enterprise

00:08:15,950 --> 00:08:20,840
where everything that I've described to

00:08:18,950 --> 00:08:22,850
date is available in enterprise and it's

00:08:20,840 --> 00:08:25,430
in community we release additional

00:08:22,850 --> 00:08:28,220
functionality on top of and around the

00:08:25,430 --> 00:08:30,740
MySQL server with a mysql server itself

00:08:28,220 --> 00:08:32,740
supporting plugins so we have things

00:08:30,740 --> 00:08:35,599
like a firewall to be able to blacklist

00:08:32,740 --> 00:08:38,450
certain queries to prevent SQL injection

00:08:35,599 --> 00:08:40,280
we can authenticate against ldap servers

00:08:38,450 --> 00:08:42,349
we can order it so you can see what

00:08:40,280 --> 00:08:44,690
activities happen by what uses i'm

00:08:42,349 --> 00:08:46,370
borrowing tool a backup tool and of

00:08:44,690 --> 00:08:49,940
course we have access to our support

00:08:46,370 --> 00:08:53,870
team however with that we're on to the

00:08:49,940 --> 00:08:57,170
main event we're talking about Jason so

00:08:53,870 --> 00:08:59,150
there are three features that work

00:08:57,170 --> 00:09:02,450
together to be able to create this new

00:08:59,150 --> 00:09:05,920
MySQL 57 Jason experience they are

00:09:02,450 --> 00:09:08,810
feature one a native JSON data type

00:09:05,920 --> 00:09:12,530
feature to a set of functions to be able

00:09:08,810 --> 00:09:15,350
to manipulate and search and access and

00:09:12,530 --> 00:09:18,140
retrieve data on the server side with

00:09:15,350 --> 00:09:21,050
Jason and feature three is we have a set

00:09:18,140 --> 00:09:23,000
of generated columns which I'll describe

00:09:21,050 --> 00:09:24,560
each of these in more detail the

00:09:23,000 --> 00:09:28,790
generated columns allow us to apply

00:09:24,560 --> 00:09:31,130
indexes on our JSON data so to start

00:09:28,790 --> 00:09:34,070
with let's describe the JSON data type

00:09:31,130 --> 00:09:36,770
and let's say what's new here I have the

00:09:34,070 --> 00:09:40,280
most trivial of examples I created table

00:09:36,770 --> 00:09:42,589
I call an employee's say it's going to

00:09:40,280 --> 00:09:46,040
column data and the type of this is

00:09:42,589 --> 00:09:48,050
Jason so previously well and currently

00:09:46,040 --> 00:09:51,350
you could have had an int could have a

00:09:48,050 --> 00:09:55,520
char or voucher now you can have Jason

00:09:51,350 --> 00:09:57,650
and you insert into this column valid

00:09:55,520 --> 00:10:01,250
Jason as i have here and you retrieve

00:09:57,650 --> 00:10:03,410
from this valid jason and internally the

00:10:01,250 --> 00:10:06,170
way that we stole this is not like that

00:10:03,410 --> 00:10:08,360
we store this in a more optimal way to

00:10:06,170 --> 00:10:12,860
be able to retrieve and access this data

00:10:08,360 --> 00:10:14,690
and to try to sort of describe a few of

00:10:12,860 --> 00:10:17,870
the technical specs behind this data

00:10:14,690 --> 00:10:20,630
type we follow the rules of JavaScript

00:10:17,870 --> 00:10:23,390
and the JSON format and jason says that

00:10:20,630 --> 00:10:25,280
it's only utf-8 character set so we

00:10:23,390 --> 00:10:28,430
don't implement other character sets for

00:10:25,280 --> 00:10:29,930
this type I'll go with this data type is

00:10:28,430 --> 00:10:33,680
to be able to optimize it for read

00:10:29,930 --> 00:10:35,870
intensive workloads and part of that is

00:10:33,680 --> 00:10:38,390
when you do an insert or you an update

00:10:35,870 --> 00:10:39,710
and you insert Jason that's when we're

00:10:38,390 --> 00:10:41,600
doing the passing that's when we're

00:10:39,710 --> 00:10:43,400
doing the validation and we're saving

00:10:41,600 --> 00:10:44,839
this in a binary format and then it's

00:10:43,400 --> 00:10:47,630
going to be very fast to be able to

00:10:44,839 --> 00:10:49,520
access it you can think of this type is

00:10:47,630 --> 00:10:51,520
a little bit similar to like a blob data

00:10:49,520 --> 00:10:55,190
type where we store each document

00:10:51,520 --> 00:10:57,110
internally in in a mysql row where we

00:10:55,190 --> 00:10:59,990
have a dictionary and then we have fixed

00:10:57,110 --> 00:11:04,490
offsets for fast access to each of the

00:10:59,990 --> 00:11:07,329
elements in an adjacent document some

00:11:04,490 --> 00:11:10,329
other parts of the text back

00:11:07,329 --> 00:11:12,730
for this we support all of the types

00:11:10,329 --> 00:11:15,970
that the javascript does which is

00:11:12,730 --> 00:11:18,220
actually fairly limited we also extend

00:11:15,970 --> 00:11:20,439
this internally to be able to support

00:11:18,220 --> 00:11:21,970
all of the MySQL types and have the

00:11:20,439 --> 00:11:24,579
ability to extend this further and

00:11:21,970 --> 00:11:26,319
feature and I will describe sort of

00:11:24,579 --> 00:11:29,259
towards the end of my deck how this

00:11:26,319 --> 00:11:30,939
extension works but it gives really

00:11:29,259 --> 00:11:32,829
clean really nice integration between

00:11:30,939 --> 00:11:34,540
the document wall and the MySQL world

00:11:32,829 --> 00:11:36,459
and that we extend this and this is

00:11:34,540 --> 00:11:38,259
similar to other formats like these on

00:11:36,459 --> 00:11:41,649
if you're familiar with it it has that

00:11:38,259 --> 00:11:44,739
extension of a JavaScript so we'll

00:11:41,649 --> 00:11:48,459
summarize the the JSON data type by

00:11:44,739 --> 00:11:51,309
saying well Morgan currently I could

00:11:48,459 --> 00:11:53,739
store Jason in text or vach or blog why

00:11:51,309 --> 00:11:54,999
would I use this data type I want to say

00:11:53,739 --> 00:11:58,029
that there's two distinctive advantages

00:11:54,999 --> 00:12:00,850
why you want to use this data type and I

00:11:58,029 --> 00:12:02,730
will back up this claim in just a little

00:12:00,850 --> 00:12:05,829
bit when I show performance numbers but

00:12:02,730 --> 00:12:08,410
feature one is that you insert into the

00:12:05,829 --> 00:12:11,799
JSON data type valid Jason so you get

00:12:08,410 --> 00:12:14,230
some validation by using a native JSON

00:12:11,799 --> 00:12:15,970
data type and the second reason is that

00:12:14,230 --> 00:12:18,910
it's very efficient particularly for

00:12:15,970 --> 00:12:20,889
retrieval we do have the ability in

00:12:18,910 --> 00:12:23,350
future to be able to add additional

00:12:20,889 --> 00:12:25,079
advantages I'll talk a little bit about

00:12:23,350 --> 00:12:28,929
roadmap when I get to the end as well

00:12:25,079 --> 00:12:30,910
one thing that might be nice is that if

00:12:28,929 --> 00:12:33,369
you had a really big JSON document and

00:12:30,910 --> 00:12:35,379
you just made a small change if we could

00:12:33,369 --> 00:12:37,119
just you know make that small change on

00:12:35,379 --> 00:12:38,980
the disk when we're doing right activity

00:12:37,119 --> 00:12:40,869
or send it over the network is the small

00:12:38,980 --> 00:12:43,149
change in we don't currently have that

00:12:40,869 --> 00:12:46,869
that feature but it may come in future

00:12:43,149 --> 00:12:48,610
so these two points are both true

00:12:46,869 --> 00:12:52,329
currently and very true they're very

00:12:48,610 --> 00:12:54,100
useful for your applications so let's

00:12:52,329 --> 00:12:56,679
that's feature one we have a native JSON

00:12:54,100 --> 00:13:00,040
data type feature two is we have a set

00:12:56,679 --> 00:13:01,749
of functions so if you had a lot of

00:13:00,040 --> 00:13:03,759
Jason on your server and you wanted to

00:13:01,749 --> 00:13:07,149
be able to do some mass migration or

00:13:03,759 --> 00:13:08,470
some mass update it could be painful if

00:13:07,149 --> 00:13:10,119
you had to pull it all into your

00:13:08,470 --> 00:13:11,829
application extract it across the

00:13:10,119 --> 00:13:14,589
network make a change and then send it

00:13:11,829 --> 00:13:16,959
back it's useful if you have some

00:13:14,589 --> 00:13:19,029
scripting ability in SQL to be able to

00:13:16,959 --> 00:13:20,680
modify it or access just part of the

00:13:19,029 --> 00:13:23,770
document and then send it across the net

00:13:20,680 --> 00:13:26,290
work so we have about 20 functions I'll

00:13:23,770 --> 00:13:27,790
start off with the simplest one and i'll

00:13:26,290 --> 00:13:30,220
start off with an example that doesn't

00:13:27,790 --> 00:13:32,230
have any tables I'm just on my mysql

00:13:30,220 --> 00:13:34,360
command line client creating a variable

00:13:32,230 --> 00:13:36,490
called document i'm assigning into that

00:13:34,360 --> 00:13:40,450
some valid jason this is a JSON array

00:13:36,490 --> 00:13:43,000
and then I'm running adjacent extract

00:13:40,450 --> 00:13:44,649
function so you're able to say extract

00:13:43,000 --> 00:13:48,940
out of this variable that I call

00:13:44,649 --> 00:13:51,190
document the first element or the second

00:13:48,940 --> 00:13:53,529
element depending on how you count in

00:13:51,190 --> 00:13:56,709
that we're starting from zero as our

00:13:53,529 --> 00:13:58,990
first number this is a way of being able

00:13:56,709 --> 00:14:02,589
to just extract out as of highlight and

00:13:58,990 --> 00:14:06,390
read the value 20 so Jason extract is

00:14:02,589 --> 00:14:09,640
one of those functions this works on

00:14:06,390 --> 00:14:11,770
Jason native data types it works on

00:14:09,640 --> 00:14:14,740
strings that assign in variables it

00:14:11,770 --> 00:14:18,250
works on if you stored text ruv sword

00:14:14,740 --> 00:14:19,779
valid jason in a text column this is one

00:14:18,250 --> 00:14:22,839
of the common functions that you would

00:14:19,779 --> 00:14:25,300
be using that syntax where it says

00:14:22,839 --> 00:14:28,300
dollar and then brackets 1 this is what

00:14:25,300 --> 00:14:30,160
we call adjacent path if you're familiar

00:14:28,300 --> 00:14:32,170
with JavaScript you're probably familiar

00:14:30,160 --> 00:14:34,690
with jquery and you're familiar with

00:14:32,170 --> 00:14:38,890
something like CSS selectors to be able

00:14:34,690 --> 00:14:40,570
to extract out part of your Dom our

00:14:38,890 --> 00:14:42,610
syntax is a little bit different to that

00:14:40,570 --> 00:14:45,610
but the concept is similar it's very

00:14:42,610 --> 00:14:48,070
easy to learn how to do this a dollar

00:14:45,610 --> 00:14:52,810
and then bracket one or dollar dot and

00:14:48,070 --> 00:14:54,790
then a JavaScript object it also is

00:14:52,810 --> 00:14:56,950
easier because we have a shorthand

00:14:54,790 --> 00:14:59,589
operator to be able to not say the full

00:14:56,950 --> 00:15:02,230
jason extract but just on a column name

00:14:59,589 --> 00:15:04,959
you can say dash greater than and then

00:15:02,230 --> 00:15:07,089
quotations you can mention adjacent path

00:15:04,959 --> 00:15:08,800
and this is the example that i'll be

00:15:07,089 --> 00:15:11,770
showing in my slides this is a little

00:15:08,800 --> 00:15:16,089
bit of syntactic sugar that's easier to

00:15:11,770 --> 00:15:18,310
use than using a fool jason extract so i

00:15:16,089 --> 00:15:19,300
want to show you some performance data

00:15:18,310 --> 00:15:22,600
and i'm going to show you some examples

00:15:19,300 --> 00:15:25,329
and I I'm going to use a sample data set

00:15:22,600 --> 00:15:27,279
that you can download and reproduce the

00:15:25,329 --> 00:15:29,339
city of San Francisco has a project

00:15:27,279 --> 00:15:33,010
called open data many cities have this

00:15:29,339 --> 00:15:34,510
they basically allow you as a citizen to

00:15:33,010 --> 00:15:37,540
get involved in the

00:15:34,510 --> 00:15:41,410
operating of your municipality so from

00:15:37,540 --> 00:15:43,270
various parts of how each individual

00:15:41,410 --> 00:15:45,460
Department operate you know when this is

00:15:43,270 --> 00:15:46,690
presented to you as a citizen you can

00:15:45,460 --> 00:15:50,020
make good decisions and recommendations

00:15:46,690 --> 00:15:51,790
and data mashups and so forth what I

00:15:50,020 --> 00:15:54,400
grabbed from San Francisco friend data

00:15:51,790 --> 00:15:57,070
was two hundred thousand documents Jason

00:15:54,400 --> 00:16:01,930
documents that represented parcels of

00:15:57,070 --> 00:16:04,510
land so city buildings essentially not

00:16:01,930 --> 00:16:05,890
very exciting maybe but real life data

00:16:04,510 --> 00:16:07,480
is good to show performance numbers

00:16:05,890 --> 00:16:10,090
rather than something that's purely

00:16:07,480 --> 00:16:12,210
fabricated so I imported this into my

00:16:10,090 --> 00:16:14,980
skew all in a very document-oriented way

00:16:12,210 --> 00:16:18,160
the parcels of land are called features

00:16:14,980 --> 00:16:19,720
i created a features table i created a

00:16:18,160 --> 00:16:22,570
primary key that was just auto increment

00:16:19,720 --> 00:16:25,480
and i created a feature column that is

00:16:22,570 --> 00:16:27,070
jason as i said you can download this

00:16:25,480 --> 00:16:31,030
data and you can reproduce the same

00:16:27,070 --> 00:16:33,340
result each one of these documents they

00:16:31,030 --> 00:16:35,350
look roughly like this the details not

00:16:33,340 --> 00:16:37,390
too important but they have a set of

00:16:35,350 --> 00:16:41,440
geographic coordinates to describe where

00:16:37,390 --> 00:16:43,840
this this lot is this feature and they

00:16:41,440 --> 00:16:46,360
have a set of properties because a

00:16:43,840 --> 00:16:48,820
building has to be on a street streets

00:16:46,360 --> 00:16:50,800
got a name streets kind of number maybe

00:16:48,820 --> 00:16:54,130
it's got some sort of lot number that's

00:16:50,800 --> 00:16:56,230
used for property taxes or so forth but

00:16:54,130 --> 00:16:58,510
I've imported it just into a table that

00:16:56,230 --> 00:16:59,860
I code features and I as I said I've

00:16:58,510 --> 00:17:02,620
done this in a very document-oriented

00:16:59,860 --> 00:17:06,310
way where it's basically all just stored

00:17:02,620 --> 00:17:09,339
in in one column so I want to run some

00:17:06,310 --> 00:17:11,949
queries on this on this sample data the

00:17:09,339 --> 00:17:13,959
first query that I want to show you it's

00:17:11,949 --> 00:17:18,100
just how natural it is to be able to

00:17:13,959 --> 00:17:21,310
extract using that that JSON extract

00:17:18,100 --> 00:17:23,760
operator and specifying adjacent path to

00:17:21,310 --> 00:17:27,280
say inside of that document in the

00:17:23,760 --> 00:17:30,490
properties I want to find something

00:17:27,280 --> 00:17:32,170
that's on the street market street if

00:17:30,490 --> 00:17:33,790
you're familiar with san francisco this

00:17:32,170 --> 00:17:36,070
is one of the main streets that runs

00:17:33,790 --> 00:17:37,990
through san francisco so surely in this

00:17:36,070 --> 00:17:40,720
data set that there must be at least a

00:17:37,990 --> 00:17:42,880
couple of entries there's a lot of

00:17:40,720 --> 00:17:45,070
entries so I said limit one and we can

00:17:42,880 --> 00:17:47,070
see that that we're returning back just

00:17:45,070 --> 00:17:48,840
basically the first entry that matches

00:17:47,070 --> 00:17:52,930
invalid

00:17:48,840 --> 00:17:55,420
so the thing about scheme alice is that

00:17:52,930 --> 00:17:58,270
not all of my documents necessarily have

00:17:55,420 --> 00:18:00,160
to follow the set same structure so

00:17:58,270 --> 00:18:01,300
might be interesting to see in these two

00:18:00,160 --> 00:18:05,050
hundred thousand documents that have

00:18:01,300 --> 00:18:08,170
imported to any of them not have a

00:18:05,050 --> 00:18:11,830
property's Street mentioned any of these

00:18:08,170 --> 00:18:13,390
not on a street that's no one and the

00:18:11,830 --> 00:18:15,580
way that I would write that query it's

00:18:13,390 --> 00:18:17,980
very natural and this is a document to

00:18:15,580 --> 00:18:19,810
SQL integration to say that i would say

00:18:17,980 --> 00:18:23,440
select star from features where feature

00:18:19,810 --> 00:18:27,520
and then the same path here properties

00:18:23,440 --> 00:18:29,170
street is null and in my sample data set

00:18:27,520 --> 00:18:31,150
at least that's not the case everything

00:18:29,170 --> 00:18:34,840
is specified that it has a property

00:18:31,150 --> 00:18:37,300
start street but in your data set this

00:18:34,840 --> 00:18:40,120
could frequently be be useful as a type

00:18:37,300 --> 00:18:43,060
of career that you would write I'll also

00:18:40,120 --> 00:18:45,100
point out that i'm using a feature and

00:18:43,060 --> 00:18:48,730
in the json extract operator with a path

00:18:45,100 --> 00:18:51,100
in my where clause this is valid this

00:18:48,730 --> 00:18:53,890
syntax as a list of columns that i could

00:18:51,100 --> 00:18:58,930
have in my select list as well you can

00:18:53,890 --> 00:19:01,330
use it however you would like to ok so

00:18:58,930 --> 00:19:03,970
my claim was that this JSON data type is

00:19:01,330 --> 00:19:06,700
fast that's something that i said was a

00:19:03,970 --> 00:19:09,340
design goal of it and i also did briefly

00:19:06,700 --> 00:19:10,750
mention that the jason extract operator

00:19:09,340 --> 00:19:14,380
and the jason functions they will work

00:19:10,750 --> 00:19:17,080
on variables text and the native json

00:19:14,380 --> 00:19:18,850
data type so what I'm going to show you

00:19:17,080 --> 00:19:21,340
now is I've constructed a very naive

00:19:18,850 --> 00:19:23,290
query where I'm intentionally having to

00:19:21,340 --> 00:19:26,680
scan through all 200,000 of these

00:19:23,290 --> 00:19:28,030
documents which could be potentially

00:19:26,680 --> 00:19:29,230
slow there's a lot of work that has to

00:19:28,030 --> 00:19:32,590
happen to be able to scan through

00:19:29,230 --> 00:19:34,300
200,000 so you wouldn't run this query

00:19:32,590 --> 00:19:37,240
on your production system it's it's

00:19:34,300 --> 00:19:38,380
naive but I'm saying select distinct to

00:19:37,240 --> 00:19:41,170
be able to have to look through all of

00:19:38,380 --> 00:19:43,260
them haven't added any indexes yet and

00:19:41,170 --> 00:19:45,580
I'm finding the distinct feature type

00:19:43,260 --> 00:19:49,570
it's part of the document and the answer

00:19:45,580 --> 00:19:53,170
is just the feature type is a feature so

00:19:49,570 --> 00:19:54,640
if i run this when my schema is as i

00:19:53,170 --> 00:19:58,780
showed you a couple slides back the

00:19:54,640 --> 00:20:01,690
native json data type to look at 200,000

00:19:58,780 --> 00:20:04,779
of these in memory

00:20:01,690 --> 00:20:06,610
it takes one point two five seconds if I

00:20:04,779 --> 00:20:08,500
alter the table and I convert the data

00:20:06,610 --> 00:20:10,570
type from what was jason to be text

00:20:08,500 --> 00:20:13,360
takes ten times that amount of time it

00:20:10,570 --> 00:20:16,840
takes twelve point eight five seconds so

00:20:13,360 --> 00:20:18,850
we do have quite an efficient access by

00:20:16,840 --> 00:20:20,919
not having to pass by not having to

00:20:18,850 --> 00:20:22,870
validate the document just storing it in

00:20:20,919 --> 00:20:26,529
a binary format with just these fixed

00:20:22,870 --> 00:20:28,929
offsets you can get a better time

00:20:26,529 --> 00:20:30,549
experience in this in production even

00:20:28,929 --> 00:20:33,820
further because we have the ability to

00:20:30,549 --> 00:20:36,460
index this data which is my segue to

00:20:33,820 --> 00:20:38,259
feature three said we have a data type

00:20:36,460 --> 00:20:41,440
we have a set of functions and we have

00:20:38,259 --> 00:20:43,509
the ability to index so to be able to

00:20:41,440 --> 00:20:45,730
index jason i first have to introduce

00:20:43,509 --> 00:20:47,980
this function called jet this feature

00:20:45,730 --> 00:20:50,500
called generated columns it's not

00:20:47,980 --> 00:20:52,269
specific to Jason but it's specific to

00:20:50,500 --> 00:20:55,659
the Jason experience that we created

00:20:52,269 --> 00:20:58,539
with with 57 so what a generated column

00:20:55,659 --> 00:21:00,129
is I have a table i call my table t1 i

00:20:58,539 --> 00:21:02,529
have the schema here and the visual

00:21:00,129 --> 00:21:04,870
representation just up here which might

00:21:02,529 --> 00:21:07,750
be a little bit easy to follow I I have

00:21:04,870 --> 00:21:10,149
a primary key code ID I have another

00:21:07,750 --> 00:21:13,509
column called my integer and then I have

00:21:10,149 --> 00:21:16,539
a virtual generated column defined as my

00:21:13,509 --> 00:21:18,519
integer plus one and you can see in my

00:21:16,539 --> 00:21:20,259
table schema it's got this expression to

00:21:18,519 --> 00:21:23,649
say that it's a column my integer plus

00:21:20,259 --> 00:21:27,879
one is an integer defined as my integer

00:21:23,649 --> 00:21:30,399
plus one virtual columns they don't

00:21:27,879 --> 00:21:33,519
really exist in the real life their

00:21:30,399 --> 00:21:35,620
virtual they don't take up memory they

00:21:33,519 --> 00:21:38,610
don't take up disk space they're

00:21:35,620 --> 00:21:42,610
generated on demand an application

00:21:38,610 --> 00:21:44,320
client it can't see the difference but I

00:21:42,610 --> 00:21:47,639
want to assure you these don't really

00:21:44,320 --> 00:21:50,289
exists there are virtual columns and

00:21:47,639 --> 00:21:52,870
here I have an expression to be able to

00:21:50,289 --> 00:21:56,769
say that this virtual column my integer

00:21:52,870 --> 00:21:58,269
plus 1 is my integer plus 1 you may be

00:21:56,769 --> 00:22:01,600
able to see where I'm building up to

00:21:58,269 --> 00:22:05,460
here this expression could be one of

00:22:01,600 --> 00:22:08,289
these Jason paths and once I have a

00:22:05,460 --> 00:22:11,619
virtual column then I can actually add

00:22:08,289 --> 00:22:14,330
an index and then I can make the query

00:22:11,619 --> 00:22:16,899
really efficient

00:22:14,330 --> 00:22:19,340
so let's do that that's my next slide

00:22:16,899 --> 00:22:22,100
let's show how to do a virtual column

00:22:19,340 --> 00:22:25,669
using JSON data on our sample data set

00:22:22,100 --> 00:22:28,039
from the city of San Francisco part of

00:22:25,669 --> 00:22:30,320
my schema from that that previous query

00:22:28,039 --> 00:22:34,460
was to extract out this this column

00:22:30,320 --> 00:22:36,409
called type I say alter table features

00:22:34,460 --> 00:22:38,929
add a new column it's a virtual column

00:22:36,409 --> 00:22:41,240
feature type I have to choose a data

00:22:38,929 --> 00:22:43,760
type for it now and I'm choosing far cha

00:22:41,240 --> 00:22:45,710
30s by data type this is where we're

00:22:43,760 --> 00:22:47,389
mapping between the document world and

00:22:45,710 --> 00:22:49,639
their relational world so we do have to

00:22:47,389 --> 00:22:52,880
choose a data type for the first time so

00:22:49,639 --> 00:22:55,039
it has some schema there and we're

00:22:52,880 --> 00:22:58,820
saying extract out using this Jason path

00:22:55,039 --> 00:23:01,070
feature type Jason when we do this this

00:22:58,820 --> 00:23:02,840
change is basically instant it's only

00:23:01,070 --> 00:23:06,230
metadata that has to change it's

00:23:02,840 --> 00:23:08,360
completely virtual but the next step it

00:23:06,230 --> 00:23:10,190
does take some time the time that it

00:23:08,360 --> 00:23:11,899
takes to build the index once I've added

00:23:10,190 --> 00:23:15,380
the virtual column i can add an index

00:23:11,899 --> 00:23:18,409
and then my previous query becomes very

00:23:15,380 --> 00:23:21,350
fast we can go down from one point two

00:23:18,409 --> 00:23:26,059
five seconds to 0.06 seconds in this

00:23:21,350 --> 00:23:27,559
case from what was 12 seconds prior I'm

00:23:26,059 --> 00:23:29,419
riding the query here to say select

00:23:27,559 --> 00:23:31,130
distinct feature type by the virtual

00:23:29,419 --> 00:23:33,860
column I could also use the original

00:23:31,130 --> 00:23:36,590
expression and our optimizer internally

00:23:33,860 --> 00:23:39,049
I can frequently find out that there was

00:23:36,590 --> 00:23:40,909
a virtual column with an index that

00:23:39,049 --> 00:23:42,500
supports the same expression that I've

00:23:40,909 --> 00:23:45,159
mentioned here so you can actually keep

00:23:42,500 --> 00:23:48,200
it in the original query form as well

00:23:45,159 --> 00:23:49,610
but this is how we index Jason by

00:23:48,200 --> 00:23:51,620
extracting part of it to a virtual

00:23:49,610 --> 00:23:54,049
column and then adding an index on top

00:23:51,620 --> 00:23:56,899
of it and i would say that your time

00:23:54,049 --> 00:23:59,330
difference what i said the previous

00:23:56,899 --> 00:24:02,179
slide was or the previous example was a

00:23:59,330 --> 00:24:05,120
naive example because i was just trying

00:24:02,179 --> 00:24:07,039
to run a query to look at everything i

00:24:05,120 --> 00:24:08,630
would say that this is a very real life

00:24:07,039 --> 00:24:09,760
example that you'd get this time

00:24:08,630 --> 00:24:12,590
difference and it would be much better

00:24:09,760 --> 00:24:14,419
this is because indexes they have

00:24:12,590 --> 00:24:15,860
logarithmic search they divide and

00:24:14,419 --> 00:24:18,620
conquer divide and conquer divide and

00:24:15,860 --> 00:24:22,600
conquer and they really do reduce time

00:24:18,620 --> 00:24:25,490
on big data sets by a significant amount

00:24:22,600 --> 00:24:27,700
so generated columns allows us to add

00:24:25,490 --> 00:24:30,730
indexes on JSON data

00:24:27,700 --> 00:24:33,460
it allows us to add indexes on XML data

00:24:30,730 --> 00:24:36,010
or any other type of data we just have

00:24:33,460 --> 00:24:38,200
to use built-in deterministic functions

00:24:36,010 --> 00:24:40,409
in MySQL for whatever you use is this

00:24:38,200 --> 00:24:43,659
expression that's the only restriction

00:24:40,409 --> 00:24:45,250
and you may have heard of this feature

00:24:43,659 --> 00:24:47,529
described in other databases is

00:24:45,250 --> 00:24:49,090
something like a functional index this

00:24:47,529 --> 00:24:51,940
is the equivalent just with slightly

00:24:49,090 --> 00:24:54,639
different syntax the ability to index on

00:24:51,940 --> 00:24:56,409
an expression I'll actually clarify that

00:24:54,639 --> 00:24:58,600
what I've described so far is something

00:24:56,409 --> 00:25:02,139
something called virtual generated

00:24:58,600 --> 00:25:04,299
columns there is a second variety the

00:25:02,139 --> 00:25:07,510
second variety of generated columns is

00:25:04,299 --> 00:25:09,760
called stored we can actually with this

00:25:07,510 --> 00:25:12,580
optional keyword make sure that they

00:25:09,760 --> 00:25:14,409
really exist this will take memory in

00:25:12,580 --> 00:25:17,049
this will take disk space and will take

00:25:14,409 --> 00:25:20,590
time to be able to add a store generated

00:25:17,049 --> 00:25:23,080
column whether you choose stored or

00:25:20,590 --> 00:25:25,570
virtual it's important to point out that

00:25:23,080 --> 00:25:27,429
in both cases you're able to add indexes

00:25:25,570 --> 00:25:29,559
on top of that virtual column on top of

00:25:27,429 --> 00:25:31,389
that generated column so therefore i

00:25:29,559 --> 00:25:33,669
would say that in most cases you want to

00:25:31,389 --> 00:25:34,779
use virtual columns and then on top of

00:25:33,669 --> 00:25:38,380
the virtual columns you want to add

00:25:34,779 --> 00:25:40,029
indexes my next slide points out the

00:25:38,380 --> 00:25:41,980
restrictions with virtual columns there

00:25:40,029 --> 00:25:45,820
and that that will apply a little bit

00:25:41,980 --> 00:25:47,409
more context to why we need both so if

00:25:45,820 --> 00:25:49,330
you wanted to be able to add an index on

00:25:47,409 --> 00:25:51,340
a virtual column and the virtual column

00:25:49,330 --> 00:25:54,100
and the index type you want to add was a

00:25:51,340 --> 00:25:55,779
primary key this is like no go you can't

00:25:54,100 --> 00:25:58,240
do this with virtual generated columns

00:25:55,779 --> 00:26:02,590
or if you wanted a full text search

00:25:58,240 --> 00:26:04,510
index or at geospatial artery index this

00:26:02,590 --> 00:26:07,059
is a no go as well with virtual columns

00:26:04,510 --> 00:26:09,190
it's not supported in that case you need

00:26:07,059 --> 00:26:11,820
to use the stored variety of generated

00:26:09,190 --> 00:26:14,080
columns this is a very specific

00:26:11,820 --> 00:26:16,720
restriction we would love to be able to

00:26:14,080 --> 00:26:19,630
lift lift some of these restrictions in

00:26:16,720 --> 00:26:21,820
future perhaps I i I'm pretty

00:26:19,630 --> 00:26:23,980
comfortable however that that it's quite

00:26:21,820 --> 00:26:28,179
small in use case and that most indexes

00:26:23,980 --> 00:26:31,559
will just be regular be trees any

00:26:28,179 --> 00:26:31,559
questions about generated columns

00:26:33,730 --> 00:26:46,870
no okay what about indexing and when you

00:26:42,340 --> 00:26:50,830
try to index a field of the JSON what

00:26:46,870 --> 00:26:53,290
will happen with some entry does not

00:26:50,830 --> 00:26:56,080
contain the field how it's being treated

00:26:53,290 --> 00:26:58,270
yeah absolutely great question so I foot

00:26:56,080 --> 00:26:59,830
back to an example to show you because

00:26:58,270 --> 00:27:04,630
it'll be a little bit easier to see sir

00:26:59,830 --> 00:27:07,420
um being schema-less feature type may

00:27:04,630 --> 00:27:10,720
not be in every record that's fine it

00:27:07,420 --> 00:27:13,960
will be a null there is the requirement

00:27:10,720 --> 00:27:16,750
there in our default SQL mode that it

00:27:13,960 --> 00:27:19,710
must be no or it must match this data

00:27:16,750 --> 00:27:21,760
type so if it returns back the the

00:27:19,710 --> 00:27:24,460
expression you've got here returns back

00:27:21,760 --> 00:27:27,190
an array or or something that's larger

00:27:24,460 --> 00:27:29,050
than watch our 30 you would get an error

00:27:27,190 --> 00:27:29,830
as you try and insert new documents

00:27:29,050 --> 00:27:33,340
because they wouldn't pass that

00:27:29,830 --> 00:27:35,770
definition yeah yeah so you could use

00:27:33,340 --> 00:27:38,590
some sort of extra functions to do

00:27:35,770 --> 00:27:40,780
truncation in your expression or do

00:27:38,590 --> 00:27:42,100
casting or something like that but at

00:27:40,780 --> 00:27:45,280
the end of the day you must return null

00:27:42,100 --> 00:27:47,230
or it must match this data type that

00:27:45,280 --> 00:27:49,860
you've specified here this is our

00:27:47,230 --> 00:27:52,960
mapping between the completely free

00:27:49,860 --> 00:27:55,240
document world and the MySQL world to be

00:27:52,960 --> 00:28:01,470
able to add indexes it has to have maps

00:27:55,240 --> 00:28:01,470
that data type yeah another question

00:28:01,860 --> 00:28:08,380
John generated columns be based on user

00:28:05,530 --> 00:28:11,800
defined functions around the my sequel

00:28:08,380 --> 00:28:13,930
built-in functions currently its MySQL

00:28:11,800 --> 00:28:16,990
built-in functions we have heard this

00:28:13,930 --> 00:28:19,020
request before for udfs it's kind of an

00:28:16,990 --> 00:28:21,790
artificial limitation that that we

00:28:19,020 --> 00:28:24,070
didn't allow udfs because we were kind

00:28:21,790 --> 00:28:25,990
of worried that they might not be

00:28:24,070 --> 00:28:29,400
deterministic but that features been

00:28:25,990 --> 00:28:29,400
noted and we might lift that in future

00:28:34,890 --> 00:28:43,299
the the stored generated column values

00:28:40,390 --> 00:28:44,919
if you're updating rose to they kind of

00:28:43,299 --> 00:28:47,470
stay in line with the original kind of

00:28:44,919 --> 00:28:50,289
vet what have you sat on that yeah

00:28:47,470 --> 00:28:52,539
that's right so um virtual columns are

00:28:50,289 --> 00:28:53,950
obviously virtual and I didn't read off

00:28:52,539 --> 00:28:56,770
my sideways mention there you can't

00:28:53,950 --> 00:28:58,390
update them virtual columns or any

00:28:56,770 --> 00:29:02,530
generated columns that they're just read

00:28:58,390 --> 00:29:04,390
only but the stored variety obviously

00:29:02,530 --> 00:29:06,490
data really exists for that they are

00:29:04,390 --> 00:29:08,919
what we call material and they are

00:29:06,490 --> 00:29:10,299
updated automatically as you do any

00:29:08,919 --> 00:29:20,440
operations there maintained is

00:29:10,299 --> 00:29:21,340
consistent okay whoa one more it's a

00:29:20,440 --> 00:29:23,230
good opportunity to ask questions

00:29:21,340 --> 00:29:37,650
because then I can move on to some other

00:29:23,230 --> 00:29:37,650
stuff for this just but that's right

00:29:41,940 --> 00:29:47,409
this is this is what happens when you

00:29:44,770 --> 00:29:48,900
try and update a generated column you

00:29:47,409 --> 00:29:53,650
get a nasty little error like this one

00:29:48,900 --> 00:29:56,740
even if it's stored yeah yeah sorry it's

00:29:53,650 --> 00:29:58,090
not possible it's not allowed yeah and

00:29:56,740 --> 00:30:01,330
this is actually an interesting question

00:29:58,090 --> 00:30:05,429
because if you use like an older version

00:30:01,330 --> 00:30:08,140
of MySQL dump that wasn't from MySQL 57

00:30:05,429 --> 00:30:09,669
it sees generated columns like the

00:30:08,140 --> 00:30:12,789
normal columns and then when you try and

00:30:09,669 --> 00:30:15,190
restore the restore doesn't work yeah

00:30:12,789 --> 00:30:18,970
it's a very special sort of new feature

00:30:15,190 --> 00:30:22,919
and you can't update them if we allowed

00:30:18,970 --> 00:30:22,919
that it would cause all sorts of pain

00:30:33,860 --> 00:30:38,610
just a quick question about the DJ's own

00:30:36,870 --> 00:30:40,740
document so I guess you can't do

00:30:38,610 --> 00:30:43,590
aggregations directly on those types

00:30:40,740 --> 00:30:46,350
right so you have to have the virtual

00:30:43,590 --> 00:30:47,880
columns mapped from the adjacent type to

00:30:46,350 --> 00:30:50,850
be able to do aggregations know you

00:30:47,880 --> 00:30:52,170
could you could so actually when I had

00:30:50,850 --> 00:30:55,260
this slide up I pointed out that i'm

00:30:52,170 --> 00:30:57,240
using this path expression in my where

00:30:55,260 --> 00:30:58,950
course but you could use this in your

00:30:57,240 --> 00:31:00,630
select cause you could use in your group

00:30:58,950 --> 00:31:03,390
by it can be used in any part at all

00:31:00,630 --> 00:31:05,400
that's cool so if you've done something

00:31:03,390 --> 00:31:07,410
like a public to benchmark or something

00:31:05,400 --> 00:31:08,970
is that how that compares to the normal

00:31:07,410 --> 00:31:11,250
columns like just a VAR charles

00:31:08,970 --> 00:31:14,700
something when doing applications the

00:31:11,250 --> 00:31:19,010
performance wise i can't think of

00:31:14,700 --> 00:31:21,780
anything we've published generally I

00:31:19,010 --> 00:31:26,270
benchmarks interesting because they're

00:31:21,780 --> 00:31:30,420
so easy to kind of cheat and so forth

00:31:26,270 --> 00:31:33,150
what I think is also where it might not

00:31:30,420 --> 00:31:35,760
be a good benchmark is is because in

00:31:33,150 --> 00:31:37,860
real production you're not doing this

00:31:35,760 --> 00:31:41,580
sort of stuff which I said was naive

00:31:37,860 --> 00:31:44,340
just to give a rough indication you're

00:31:41,580 --> 00:31:46,590
using indexes and the indexing

00:31:44,340 --> 00:31:48,480
performance of the generated columns is

00:31:46,590 --> 00:31:50,940
the same as it is for other columns

00:31:48,480 --> 00:31:53,070
because we're when we create the index

00:31:50,940 --> 00:31:55,260
we are materializing as the data type

00:31:53,070 --> 00:31:57,809
which is a relational type so there's no

00:31:55,260 --> 00:31:59,760
additional overhead by this I say that

00:31:57,809 --> 00:32:06,490
kind of works around your question yeah

00:31:59,760 --> 00:32:12,940
thank you that's Karen thank you okay

00:32:06,490 --> 00:32:14,710
I yeah it's it's not it's not quite a

00:32:12,940 --> 00:32:17,200
binary tree but it's it's a dictionary

00:32:14,710 --> 00:32:19,990
with some fixed offsets into the tree of

00:32:17,200 --> 00:32:21,550
the items yeah we have a work log which

00:32:19,990 --> 00:32:23,890
is our internal task system that

00:32:21,550 --> 00:32:25,510
describes how it works in more detail

00:32:23,890 --> 00:32:27,460
there's a couple of extra nuances

00:32:25,510 --> 00:32:31,590
because we've got the provision to do

00:32:27,460 --> 00:32:35,170
some padding and other stuff but yeah

00:32:31,590 --> 00:32:37,600
okay excellent thank you for the

00:32:35,170 --> 00:32:39,730
questions i said i love questions that's

00:32:37,600 --> 00:32:42,460
that's show some more jason functions

00:32:39,730 --> 00:32:44,170
though that this this has some power

00:32:42,460 --> 00:32:46,630
here for you to be able to use this

00:32:44,170 --> 00:32:48,820
functionality so something that I didn't

00:32:46,630 --> 00:32:52,809
point out on my slide explicitly but

00:32:48,820 --> 00:32:54,160
when you extract out from a scene

00:32:52,809 --> 00:32:56,440
extract functional the shorthand

00:32:54,160 --> 00:32:59,410
operator it actually returns it to you

00:32:56,440 --> 00:33:01,780
as valid Jason and it denotes that it's

00:32:59,410 --> 00:33:04,540
in the JSON data type by having these

00:33:01,780 --> 00:33:06,100
quotes around it you can see here when I

00:33:04,540 --> 00:33:07,630
show you my next slide very briefly it's

00:33:06,100 --> 00:33:10,450
got these quotes saying this is a JSON

00:33:07,630 --> 00:33:12,460
data type frequently you might find that

00:33:10,450 --> 00:33:14,410
you want to maybe cast this is a string

00:33:12,460 --> 00:33:16,660
before you return this so you can use

00:33:14,410 --> 00:33:18,370
adjacent unquote function which will

00:33:16,660 --> 00:33:23,140
convert it to a string and just return

00:33:18,370 --> 00:33:25,300
you that the data in this raw form you

00:33:23,140 --> 00:33:28,030
may want to as part of learning this

00:33:25,300 --> 00:33:30,340
path syntax I said it's quite quite easy

00:33:28,030 --> 00:33:33,910
but you may want to use something like

00:33:30,340 --> 00:33:36,850
adjacent search function to allow you to

00:33:33,910 --> 00:33:38,890
find out what the exact path is for some

00:33:36,850 --> 00:33:41,800
particular element of data that you know

00:33:38,890 --> 00:33:44,530
what's in there so here I knew that in

00:33:41,800 --> 00:33:47,710
the column called feature I said match

00:33:44,530 --> 00:33:49,150
one of the word market street and I knew

00:33:47,710 --> 00:33:50,620
it was in there and basically returned

00:33:49,150 --> 00:33:53,580
back to me the valid path of where

00:33:50,620 --> 00:33:55,840
Market Street was and then I could use

00:33:53,580 --> 00:33:59,950
that if I wanted to to write the

00:33:55,840 --> 00:34:01,300
reciprocal query which is I and here for

00:33:59,950 --> 00:34:04,870
the gentleman asked a question here's an

00:34:01,300 --> 00:34:06,670
example using the adjacent path in the

00:34:04,870 --> 00:34:09,220
select list to be able to return back

00:34:06,670 --> 00:34:13,050
and also see that that matches to market

00:34:09,220 --> 00:34:17,050
street so a useful function Jason search

00:34:13,050 --> 00:34:19,820
it expects that you say match one or

00:34:17,050 --> 00:34:22,930
match one or many and it pretty much

00:34:19,820 --> 00:34:26,740
works is you would expect to search too

00:34:22,930 --> 00:34:29,810
we have a JSON array function JSON array

00:34:26,740 --> 00:34:33,380
accepts any number of arguments it

00:34:29,810 --> 00:34:36,260
returns back a valid JSON array and you

00:34:33,380 --> 00:34:38,390
can construct this array using columns

00:34:36,260 --> 00:34:41,900
as i have here i had a primary key code

00:34:38,390 --> 00:34:44,510
ID and other Jason path queries to be

00:34:41,900 --> 00:34:46,130
able to construct that and then I could

00:34:44,510 --> 00:34:48,020
kind of nest functions ever I wanted to

00:34:46,130 --> 00:34:49,520
in a few slides forward I've got a Jason

00:34:48,020 --> 00:34:51,260
replace function so I could replace

00:34:49,520 --> 00:34:55,280
something whatever was there with an

00:34:51,260 --> 00:34:57,800
array the another function sort of

00:34:55,280 --> 00:35:00,950
related to jason array and something

00:34:57,800 --> 00:35:05,480
strange hamlin slide is Jason object it

00:35:00,950 --> 00:35:09,170
accepts an even number of arguments the

00:35:05,480 --> 00:35:13,040
odd values of the keys of the object and

00:35:09,170 --> 00:35:15,080
the even values of the values so in

00:35:13,040 --> 00:35:18,800
create objects we can create a race and

00:35:15,080 --> 00:35:21,620
we can replace to be able to just modify

00:35:18,800 --> 00:35:23,930
part of our document rather than doing

00:35:21,620 --> 00:35:26,630
an update to replace everything by

00:35:23,930 --> 00:35:31,280
saying Jason replace of this column at

00:35:26,630 --> 00:35:32,810
this path whatever was there I want you

00:35:31,280 --> 00:35:34,660
to replace it with something new which

00:35:32,810 --> 00:35:38,030
is adjacent array that I'm constructing

00:35:34,660 --> 00:35:40,430
so as I said you can do quite a lot of

00:35:38,030 --> 00:35:42,440
work server-side without having to pull

00:35:40,430 --> 00:35:45,020
this data into your application make

00:35:42,440 --> 00:35:46,610
modifications and send it back and so

00:35:45,020 --> 00:35:48,050
then you don't have to worry about dot

00:35:46,610 --> 00:35:49,910
across the network you don't have to

00:35:48,050 --> 00:35:51,800
worry about locks being held for large

00:35:49,910 --> 00:35:54,860
period of time it's really quite

00:35:51,800 --> 00:35:57,260
efficient to be able to do this so I've

00:35:54,860 --> 00:35:59,990
showed you just a few of the functions

00:35:57,260 --> 00:36:02,990
that are available there are more

00:35:59,990 --> 00:36:05,390
available what I have on my slide here

00:36:02,990 --> 00:36:07,340
is the full set that ship with MySQL 57

00:36:05,390 --> 00:36:11,630
and what I've highlighted in bold other

00:36:07,340 --> 00:36:13,310
ones for which I had examples for it's

00:36:11,630 --> 00:36:15,410
probably just one more function that

00:36:13,310 --> 00:36:17,930
I'll point out as useful besides the

00:36:15,410 --> 00:36:22,280
ones that are involved which is this

00:36:17,930 --> 00:36:24,170
function called Jason valid so many of

00:36:22,280 --> 00:36:26,600
you are already storing Jason in your

00:36:24,170 --> 00:36:28,430
database you may want to upgrade to be

00:36:26,600 --> 00:36:32,420
able to use the new date of Jason data

00:36:28,430 --> 00:36:33,870
type Jason valid you could say select

00:36:32,420 --> 00:36:37,170
star from my table

00:36:33,870 --> 00:36:39,090
Jason valid column equals zero and you

00:36:37,170 --> 00:36:41,070
could find the ones that are invalid fix

00:36:39,090 --> 00:36:42,840
them and then you could alter your table

00:36:41,070 --> 00:36:46,590
to be able to say that data type is new

00:36:42,840 --> 00:36:48,840
is now the native JSON data type so

00:36:46,590 --> 00:36:52,080
because these will work on on the native

00:36:48,840 --> 00:36:54,930
type and variables and text and so forth

00:36:52,080 --> 00:36:57,810
they're quite flexible in being able to

00:36:54,930 --> 00:37:00,240
do all that so recap and say three

00:36:57,810 --> 00:37:02,720
features a data type functions and

00:37:00,240 --> 00:37:06,840
generated columns there's maybe feature

00:37:02,720 --> 00:37:09,270
3.5 if such a thing that exists which is

00:37:06,840 --> 00:37:12,510
where I said that these integrate very

00:37:09,270 --> 00:37:13,860
nicely with the MySQL type system so i

00:37:12,510 --> 00:37:16,920
want to show just a couple of simple

00:37:13,860 --> 00:37:19,950
examples to say that if i created a

00:37:16,920 --> 00:37:21,630
document as Jason and I'm trying to do

00:37:19,950 --> 00:37:23,490
on one side so i'm using cost operator

00:37:21,630 --> 00:37:25,410
be able to achieve that that cost the

00:37:23,490 --> 00:37:28,860
value one is Jason and I compare it to

00:37:25,410 --> 00:37:32,220
the MySQL one it compares and it says

00:37:28,860 --> 00:37:34,680
this is the same and if I compared to

00:37:32,220 --> 00:37:38,070
Jason documents that have a key of numb

00:37:34,680 --> 00:37:40,770
and then a value of 1.1 the to json

00:37:38,070 --> 00:37:42,990
documents they compare and they say that

00:37:40,770 --> 00:37:44,760
they're equal as well and actually if I

00:37:42,990 --> 00:37:46,860
do some small transformations on these

00:37:44,760 --> 00:37:48,980
Jason documents like if they had the

00:37:46,860 --> 00:37:51,540
same data but the keys are out of order

00:37:48,980 --> 00:37:54,140
they compare and they say that they're

00:37:51,540 --> 00:37:57,360
equal and this works with all of my SQL

00:37:54,140 --> 00:37:59,520
type systems like date datetime as well

00:37:57,360 --> 00:38:02,310
where we can get this comparison in this

00:37:59,520 --> 00:38:05,730
integration so you can do a join between

00:38:02,310 --> 00:38:08,100
what's mysql data type of some link in

00:38:05,730 --> 00:38:10,140
one table and you're Jason daughter as

00:38:08,100 --> 00:38:14,730
well and the integration is really quite

00:38:10,140 --> 00:38:16,260
seamless so with that we move to the

00:38:14,730 --> 00:38:20,220
last pot and we say now that we have

00:38:16,260 --> 00:38:23,730
this new feature should we use it is it

00:38:20,220 --> 00:38:27,090
a good idea and it's up to you what you

00:38:23,730 --> 00:38:30,240
what you proceed and use but I want to

00:38:27,090 --> 00:38:34,080
talk about advantages for both cases to

00:38:30,240 --> 00:38:37,950
start with our old relation away using

00:38:34,080 --> 00:38:41,610
columns that's so 1990s what's the

00:38:37,950 --> 00:38:43,410
advantage to this with big application's

00:38:41,610 --> 00:38:46,080
sometimes you find that you spend a lot

00:38:43,410 --> 00:38:47,369
of your code handling edge cases edge

00:38:46,080 --> 00:38:51,240
cases of anything

00:38:47,369 --> 00:38:53,779
and when you have fewer edge cases when

00:38:51,240 --> 00:38:57,180
you can rely on some consistency and

00:38:53,779 --> 00:39:01,140
fewer variations or permutations of your

00:38:57,180 --> 00:39:04,819
data it may be useful so you may be able

00:39:01,140 --> 00:39:06,779
to enforce this sort of restriction or

00:39:04,819 --> 00:39:08,880
control at some other part of your

00:39:06,779 --> 00:39:10,970
application maybe your application can

00:39:08,880 --> 00:39:13,529
manage this schema very efficiently but

00:39:10,970 --> 00:39:15,930
certainly the database offers this is a

00:39:13,529 --> 00:39:18,180
feature and it can be useful it can be

00:39:15,930 --> 00:39:19,680
useful to be able to restrict all of

00:39:18,180 --> 00:39:23,339
these options that are possible and that

00:39:19,680 --> 00:39:27,359
you have some enforced control can be

00:39:23,339 --> 00:39:30,029
restricting too but it can be useful I'm

00:39:27,359 --> 00:39:32,160
storing is Jason it tends to be more

00:39:30,029 --> 00:39:35,190
flexible and there are some things that

00:39:32,160 --> 00:39:37,109
really need flexibility and an example

00:39:35,190 --> 00:39:40,349
that I like to highlight is say i'm a

00:39:37,109 --> 00:39:43,650
software as a service provider i have

00:39:40,349 --> 00:39:45,749
many customers one of my customers has

00:39:43,650 --> 00:39:48,630
asked for some customization they want

00:39:45,749 --> 00:39:51,539
some custom fields and in a relational

00:39:48,630 --> 00:39:54,900
way I think this is painful to be able

00:39:51,539 --> 00:39:56,700
to make those customizations sometimes I

00:39:54,900 --> 00:39:59,549
try and talk my customer out of it to

00:39:56,700 --> 00:40:01,440
not have to do it and what has kind of

00:39:59,549 --> 00:40:04,319
traditionally been the way that you do

00:40:01,440 --> 00:40:06,630
this in a relational database is you

00:40:04,319 --> 00:40:10,890
have these auxiliary tables and you

00:40:06,630 --> 00:40:13,680
store data in eav entity attribute value

00:40:10,890 --> 00:40:16,289
kind of similar to key value pairs of

00:40:13,680 --> 00:40:18,180
extra attributes for this customer in a

00:40:16,289 --> 00:40:22,890
way of being schema-less in a database

00:40:18,180 --> 00:40:24,749
way eav tends to hit a couple of pain

00:40:22,890 --> 00:40:27,930
points in-house outta basis work

00:40:24,749 --> 00:40:30,359
internally very short rows have more

00:40:27,930 --> 00:40:33,029
overhead because we have metadata per

00:40:30,359 --> 00:40:35,369
row that ends up adding up and it tends

00:40:33,029 --> 00:40:38,519
not to generate good curry execution

00:40:35,369 --> 00:40:40,859
plans for the optimizer that that has to

00:40:38,519 --> 00:40:42,960
execute queries internally so when I

00:40:40,859 --> 00:40:46,529
think of this problem and I think of

00:40:42,960 --> 00:40:49,410
JSON data type I can't think of a good

00:40:46,529 --> 00:40:51,569
reason to use the AV I would prefer to

00:40:49,410 --> 00:40:55,049
use the JSON data type basically every

00:40:51,569 --> 00:40:56,549
time I've gone over my head in head this

00:40:55,049 --> 00:40:58,739
problem a few times and I just think

00:40:56,549 --> 00:41:00,600
that the jason is a better way to be

00:40:58,739 --> 00:41:04,950
able to store anything that's of

00:41:00,600 --> 00:41:06,510
of variable attributes the other thing

00:41:04,950 --> 00:41:09,530
that's kind of nice about doing it in

00:41:06,510 --> 00:41:13,410
Jason for this same problem continued is

00:41:09,530 --> 00:41:16,530
that it's generally more performant it

00:41:13,410 --> 00:41:18,210
naturally allows an optimization called

00:41:16,530 --> 00:41:20,700
denormalization where you're grouping

00:41:18,210 --> 00:41:24,390
stuff that's frequently access together

00:41:20,700 --> 00:41:26,490
to be stored together this can be a

00:41:24,390 --> 00:41:28,370
performance problem to write this case

00:41:26,490 --> 00:41:31,260
is to normalize in cases to denormalize

00:41:28,370 --> 00:41:33,030
but generally if you're accessing the

00:41:31,260 --> 00:41:35,760
stuff together you want it stored

00:41:33,030 --> 00:41:37,920
together because the the clustering of

00:41:35,760 --> 00:41:39,480
stuff together means fewer logical pages

00:41:37,920 --> 00:41:41,430
that you have to access and you know

00:41:39,480 --> 00:41:43,470
results in better memory fit and all

00:41:41,430 --> 00:41:45,780
sorts of things so I think that this is

00:41:43,470 --> 00:41:50,850
a valid optimization that's not true for

00:41:45,780 --> 00:41:52,710
eav for example and we also have the

00:41:50,850 --> 00:41:54,390
nice thing that as our tables get bigger

00:41:52,710 --> 00:41:55,890
we don't have schema changes if we want

00:41:54,390 --> 00:41:57,740
to change the schema we just start

00:41:55,890 --> 00:42:00,540
sending different data to the server

00:41:57,740 --> 00:42:02,520
we've made this problem less of a

00:42:00,540 --> 00:42:06,240
problem in more recent versions of MySQL

00:42:02,520 --> 00:42:08,100
where we can add indexes and make table

00:42:06,240 --> 00:42:10,860
changes some table changes without

00:42:08,100 --> 00:42:13,320
blocking the tables from so they can

00:42:10,860 --> 00:42:14,550
still write it and the operation happens

00:42:13,320 --> 00:42:15,990
in the background but it's still not

00:42:14,550 --> 00:42:17,910
problem-free does a lot of stuff

00:42:15,990 --> 00:42:21,690
internally even if it makes it happen

00:42:17,910 --> 00:42:23,610
online and I think that it's very good

00:42:21,690 --> 00:42:26,160
for prototyping to be able to just start

00:42:23,610 --> 00:42:29,760
sending values to the server that that

00:42:26,160 --> 00:42:31,680
point I mentioned prior as well there is

00:42:29,760 --> 00:42:34,110
such a case that we may be able to find

00:42:31,680 --> 00:42:36,210
some happy medium but between the two

00:42:34,110 --> 00:42:37,530
and I sort of did describe the happy

00:42:36,210 --> 00:42:39,840
medium when I described the SAS

00:42:37,530 --> 00:42:41,400
application it was the variable stuff

00:42:39,840 --> 00:42:43,770
that I wanted to be in the JSON columns

00:42:41,400 --> 00:42:46,350
but if we take maybe another example and

00:42:43,770 --> 00:42:49,230
and we look at my laptop and we try and

00:42:46,350 --> 00:42:50,630
model my laptop maybe i'm selling pc

00:42:49,230 --> 00:42:54,240
components or something like that

00:42:50,630 --> 00:42:55,800
there's some commonality and maybe on a

00:42:54,240 --> 00:42:57,480
lot of pages i need to know the name of

00:42:55,800 --> 00:42:59,940
the product or the name of the pot

00:42:57,480 --> 00:43:03,150
whether it's RAM or you know it's a cpu

00:42:59,940 --> 00:43:04,760
I need to know the price I might need to

00:43:03,150 --> 00:43:07,020
know the vendor for some categorization

00:43:04,760 --> 00:43:09,920
but then there's some stuff that's very

00:43:07,020 --> 00:43:13,020
category specific like I might have

00:43:09,920 --> 00:43:14,460
coors core count four cpus and I might

00:43:13,020 --> 00:43:17,730
have gigabytes from memory

00:43:14,460 --> 00:43:19,230
or gigabytes for ssds and I think this

00:43:17,730 --> 00:43:21,200
is another opportunity where you could

00:43:19,230 --> 00:43:23,700
have those attributes is Jason if

00:43:21,200 --> 00:43:26,790
there's some per category differences

00:43:23,700 --> 00:43:29,190
rather than having everything scheme

00:43:26,790 --> 00:43:31,020
adore everything skinless there's some

00:43:29,190 --> 00:43:35,700
natural stuff that's that's common and

00:43:31,020 --> 00:43:37,589
could be valuable to have it enforced um

00:43:35,700 --> 00:43:39,720
so that's that's more or less it I just

00:43:37,589 --> 00:43:42,660
have one slide left besides some links

00:43:39,720 --> 00:43:45,270
and that's to say where we're headed I'm

00:43:42,660 --> 00:43:47,030
very happy with v one of our Jason

00:43:45,270 --> 00:43:49,859
experience I think it's very compelling

00:43:47,030 --> 00:43:51,780
we have some opportunities for some

00:43:49,859 --> 00:43:54,300
optimization if you have large Jason

00:43:51,780 --> 00:43:56,849
documents where we could do a partial

00:43:54,300 --> 00:44:00,869
right internally that I did mention

00:43:56,849 --> 00:44:02,520
prior I would say that this is not a big

00:44:00,869 --> 00:44:06,210
deal in most cases it's good to keep

00:44:02,520 --> 00:44:07,619
your JSON documents small because even

00:44:06,210 --> 00:44:09,839
though will support Jason documents off

00:44:07,619 --> 00:44:11,970
up to a gigabyte it's still row level

00:44:09,839 --> 00:44:14,099
locking so if you've got multiple people

00:44:11,970 --> 00:44:17,750
trying to edit big documents at once it

00:44:14,099 --> 00:44:20,640
might not be perfect for performance I

00:44:17,750 --> 00:44:22,230
mentioned that we have limitations on

00:44:20,640 --> 00:44:24,780
virtual columns where you can't have

00:44:22,230 --> 00:44:26,220
full text or GIS indexes with virtual

00:44:24,780 --> 00:44:29,010
generated columns you need this stored

00:44:26,220 --> 00:44:30,750
and the last point I haven't described

00:44:29,010 --> 00:44:35,609
yet what we think it'd be really

00:44:30,750 --> 00:44:38,580
interesting is I if it's truly scheme

00:44:35,609 --> 00:44:40,920
Alice even a document I had phone number

00:44:38,580 --> 00:44:42,619
and there could be one phone number or

00:44:40,920 --> 00:44:45,450
there could be three phone numbers

00:44:42,619 --> 00:44:47,849
wouldn't it be really nice to be able to

00:44:45,450 --> 00:44:49,830
index it so they could index that array

00:44:47,849 --> 00:44:51,359
of values for phone number and there

00:44:49,830 --> 00:44:54,330
could be multiple entries in the index

00:44:51,359 --> 00:44:56,670
for each individual row and we call that

00:44:54,330 --> 00:44:58,140
a multi value index the ability to do

00:44:56,670 --> 00:44:59,490
that so we don't support that that

00:44:58,140 --> 00:45:02,190
currently but we think this brings

00:44:59,490 --> 00:45:04,609
exciting opportunities so we hope to

00:45:02,190 --> 00:45:07,440
head in that direction in the future and

00:45:04,609 --> 00:45:08,849
as my last slide is just some links so

00:45:07,440 --> 00:45:11,190
when you download my slide deck you can

00:45:08,849 --> 00:45:14,220
find out more information on how this

00:45:11,190 --> 00:45:17,940
feature works and with that I'll say any

00:45:14,220 --> 00:45:22,220
questions I lots of them okay I'll go

00:45:17,940 --> 00:45:22,220
for this one first it's okay I think

00:45:24,529 --> 00:45:30,630
hi correct me if I'm wrong but previous

00:45:28,799 --> 00:45:33,479
versions of Mexico when you would do

00:45:30,630 --> 00:45:36,390
some other table and text fields or it

00:45:33,479 --> 00:45:38,670
would copy the whole table again huh so

00:45:36,390 --> 00:45:42,170
how does gonna work for migrating foam

00:45:38,670 --> 00:45:44,039
and json text field two adjacent table

00:45:42,170 --> 00:45:47,190
performance-wise i'm telling this

00:45:44,039 --> 00:45:50,910
because i had a big table like 700

00:45:47,190 --> 00:45:52,200
megabytes and 200 million rows and every

00:45:50,910 --> 00:45:55,200
time I needed to do an alterative on

00:45:52,200 --> 00:45:59,450
that table was painful yeah yeah so if

00:45:55,200 --> 00:46:01,739
you add a column oh you change data type

00:45:59,450 --> 00:46:04,259
those sorts of things have to rebuild

00:46:01,739 --> 00:46:06,719
the column I have to rebuild the table

00:46:04,259 --> 00:46:08,130
but if you add index or something like

00:46:06,719 --> 00:46:10,319
that that doesn't have to rebuild the

00:46:08,130 --> 00:46:12,989
table that just has to rebuild the index

00:46:10,319 --> 00:46:17,819
so within that subset of those

00:46:12,989 --> 00:46:19,890
operations we can add columns without

00:46:17,819 --> 00:46:22,589
blocking reads or writes we can't change

00:46:19,890 --> 00:46:23,880
the data type without blocking rights we

00:46:22,589 --> 00:46:27,150
have to block rights to be able to do

00:46:23,880 --> 00:46:28,499
that and that's a current limitation you

00:46:27,150 --> 00:46:31,019
can get around this in a number of ways

00:46:28,499 --> 00:46:32,910
you could add the column to a slave

00:46:31,019 --> 00:46:34,380
first and then you could make it a

00:46:32,910 --> 00:46:38,039
master because we're application is

00:46:34,380 --> 00:46:40,619
logical or you can use triggers to be

00:46:38,039 --> 00:46:42,660
able to create a shadow table and then

00:46:40,619 --> 00:46:45,180
promote that shadow table to master and

00:46:42,660 --> 00:46:48,029
that's very common as well I will note

00:46:45,180 --> 00:46:50,849
on triggers we did make one improvement

00:46:48,029 --> 00:46:52,529
that's very useful in in mysql 57 which

00:46:50,849 --> 00:46:54,930
is you can have multiple triggers per

00:46:52,529 --> 00:46:57,059
event per table and that does make this

00:46:54,930 --> 00:46:59,759
use case for that a little bit better

00:46:57,059 --> 00:47:04,049
but yeah I did point that out as this is

00:46:59,759 --> 00:47:05,759
one of the limitations painful schema

00:47:04,049 --> 00:47:09,150
changes that you have in the in the

00:47:05,759 --> 00:47:10,829
structured world and I love to make

00:47:09,150 --> 00:47:13,499
improvements there but that's the

00:47:10,829 --> 00:47:16,440
current state just another nice

00:47:13,499 --> 00:47:20,579
questions okay subject so one of the

00:47:16,440 --> 00:47:22,920
problems I faced it was heiio from text

00:47:20,579 --> 00:47:24,660
fields reading it it went like I

00:47:22,920 --> 00:47:26,670
discovered eyes are configuration on my

00:47:24,660 --> 00:47:29,069
sequel where it tries to calculate the

00:47:26,670 --> 00:47:31,469
Rose sighs and if it's too big it

00:47:29,069 --> 00:47:34,319
equates a temporary table behind so you

00:47:31,469 --> 00:47:36,480
have a high I 0 input I did every change

00:47:34,319 --> 00:47:40,080
from ec2 two RDS instant

00:47:36,480 --> 00:47:41,460
on amazon and like Iowa's just went

00:47:40,080 --> 00:47:42,990
through the roof and then we discovered

00:47:41,460 --> 00:47:44,880
was it because of the tax field right

00:47:42,990 --> 00:47:46,560
because a text field can have up to four

00:47:44,880 --> 00:47:50,010
megabytes and it was different from the

00:47:46,560 --> 00:47:52,170
configuration there so how read works on

00:47:50,010 --> 00:47:54,330
Jason feels right that like if you have

00:47:52,170 --> 00:47:56,100
a lot of access to that will create them

00:47:54,330 --> 00:47:59,310
for our table behind and stuff like that

00:47:56,100 --> 00:48:01,260
yeah so the behavior is similar ish but

00:47:59,310 --> 00:48:06,960
a little bit different here in mysql 57

00:48:01,260 --> 00:48:08,760
so if you use a text or blog or jason it

00:48:06,960 --> 00:48:11,130
can't use the memory storage engine for

00:48:08,760 --> 00:48:13,920
temporary materialization for execution

00:48:11,130 --> 00:48:16,619
it has to switch to its disk space disk

00:48:13,920 --> 00:48:19,080
based method which in earlier versions

00:48:16,619 --> 00:48:22,410
was my eyes em now it uses in 0 DB to be

00:48:19,080 --> 00:48:23,760
able to do that i do think that energy

00:48:22,410 --> 00:48:26,730
is a little bit more efficient at that

00:48:23,760 --> 00:48:28,680
because baby my sickle creates a

00:48:26,730 --> 00:48:30,600
temporary table why because it's where

00:48:28,680 --> 00:48:33,869
it's going to be bag right because it's

00:48:30,600 --> 00:48:35,550
a text field and try to to return to you

00:48:33,869 --> 00:48:37,859
the value that that's why i'm saying not

00:48:35,550 --> 00:48:39,570
using memory at sunny storages yes it

00:48:37,859 --> 00:48:41,580
creates a memory is able to retrieve me

00:48:39,570 --> 00:48:43,710
the results yeah but the memory table is

00:48:41,580 --> 00:48:45,390
probably my eyes em in privates it's

00:48:43,710 --> 00:48:47,040
probably not in ur TV because we only

00:48:45,390 --> 00:48:50,730
added a switch to be able to switch that

00:48:47,040 --> 00:48:52,109
to nodb i think in in 57 so maybe more

00:48:50,730 --> 00:48:54,480
efficient there's some other

00:48:52,109 --> 00:48:56,970
optimizations in that area where sort

00:48:54,480 --> 00:49:00,420
buffer is now pack 2 variable length in

00:48:56,970 --> 00:49:05,190
mysql 57 so some of those aggregates can

00:49:00,420 --> 00:49:08,430
be more efficient sometimes there are

00:49:05,190 --> 00:49:10,710
better indexes for you know filtering

00:49:08,430 --> 00:49:12,150
predicates and so forth or other tweaks

00:49:10,710 --> 00:49:13,500
that you can make to your query to be

00:49:12,150 --> 00:49:17,640
able to reduce the size of that

00:49:13,500 --> 00:49:19,170
temporary table that's the most generic

00:49:17,640 --> 00:49:23,430
advice that i have without seeing the

00:49:19,170 --> 00:49:25,050
query yeah our next question at the back

00:49:23,430 --> 00:49:32,240
because they they may not always get

00:49:25,050 --> 00:49:35,070
opportunities you showed us the

00:49:32,240 --> 00:49:37,890
comparisons against text and jason there

00:49:35,070 --> 00:49:40,710
have you done any comparisons using no

00:49:37,890 --> 00:49:45,630
sequel databases holding json data with

00:49:40,710 --> 00:49:47,130
yeah i get asked this question of it no

00:49:45,630 --> 00:49:49,440
surprise I mean we added this

00:49:47,130 --> 00:49:49,920
functionality it is competitive but it

00:49:49,440 --> 00:49:51,930
is also

00:49:49,920 --> 00:49:53,309
other quest of our customers they have

00:49:51,930 --> 00:49:54,569
the same needs as everyone else they

00:49:53,309 --> 00:49:58,500
want to be able to store unstructured

00:49:54,569 --> 00:50:02,599
data um benchmarks are terrible and

00:49:58,500 --> 00:50:05,790
they're so easy to cheat that it's funny

00:50:02,599 --> 00:50:07,740
if someone created an industry benchmark

00:50:05,790 --> 00:50:10,500
then we could show our scores to it I

00:50:07,740 --> 00:50:13,530
think benchmarking someone else's

00:50:10,500 --> 00:50:16,950
database and saying why it should isn't

00:50:13,530 --> 00:50:18,690
really good when a lot of your customers

00:50:16,950 --> 00:50:20,880
are corporate and and people expect

00:50:18,690 --> 00:50:23,549
better ethics from Oracle so it's just

00:50:20,880 --> 00:50:26,670
hard territory to be able to to do that

00:50:23,549 --> 00:50:28,470
I can't stress that enough it's really

00:50:26,670 --> 00:50:30,900
easy to cheat in benchmarks there's the

00:50:28,470 --> 00:50:31,920
floor with every one of them and and and

00:50:30,900 --> 00:50:34,650
we want to hold ourselves to a higher

00:50:31,920 --> 00:50:44,069
standard sorry i don't have no miss

00:50:34,650 --> 00:50:45,839
comparing yeah will this j something a

00:50:44,069 --> 00:50:50,040
little bit with a bit delay in the

00:50:45,839 --> 00:50:51,780
oracle also yeah yes sir what I mean I I

00:50:50,040 --> 00:50:53,450
speak to the MySQL team of the oracle

00:50:51,780 --> 00:50:56,309
team but what I want to say is that

00:50:53,450 --> 00:50:58,619
Jason is a draft specification for the

00:50:56,309 --> 00:51:01,349
SQL standard well I think we have a very

00:50:58,619 --> 00:51:05,819
good implementation of that this is also

00:51:01,349 --> 00:51:08,339
present in Postgres oracle DB to Siegel

00:51:05,819 --> 00:51:10,980
server SQL Lite and some other databases

00:51:08,339 --> 00:51:13,680
improbably offending we're all moving

00:51:10,980 --> 00:51:16,470
towards this direction wonder yeah I

00:51:13,680 --> 00:51:18,390
think you can expect we've all jump the

00:51:16,470 --> 00:51:20,059
gun and we've all added it before it's

00:51:18,390 --> 00:51:23,790
actually a standard it's still a draft

00:51:20,059 --> 00:51:25,619
but I think without speaking for those

00:51:23,790 --> 00:51:31,170
other databases you'll frequently see

00:51:25,619 --> 00:51:35,339
this appear yeah I well I was close

00:51:31,170 --> 00:51:39,150
faster that way okay what sighs Jason is

00:51:35,339 --> 00:51:41,730
too big for this field yeah so I what

00:51:39,150 --> 00:51:43,619
sighs Jason is too big I like to tell

00:51:41,730 --> 00:51:46,500
people that Jason is the same size as a

00:51:43,619 --> 00:51:47,700
row a little bit bigger someone's a

00:51:46,500 --> 00:51:49,260
little bit bigger because there's a nice

00:51:47,700 --> 00:51:51,119
use case here you can read data from

00:51:49,260 --> 00:51:54,240
api's and stream it to the database and

00:51:51,119 --> 00:51:55,829
then process it later it's too big if it

00:51:54,240 --> 00:51:58,260
starts having contention because it's

00:51:55,829 --> 00:52:00,180
still row level locking or if you're

00:51:58,260 --> 00:52:02,130
updating it frequently and just updating

00:52:00,180 --> 00:52:03,200
a smaller part of the document this

00:52:02,130 --> 00:52:05,060
could have

00:52:03,200 --> 00:52:06,770
some right amplification happening in

00:52:05,060 --> 00:52:11,359
the background as you updated so you

00:52:06,770 --> 00:52:14,599
wouldn't advise putting in JSON data

00:52:11,359 --> 00:52:17,359
like the data that's being starting

00:52:14,599 --> 00:52:19,040
blobs or text fields yeah I mean it's

00:52:17,359 --> 00:52:20,060
it's very similar to a blob or text

00:52:19,040 --> 00:52:22,460
internally so it makes no difference

00:52:20,060 --> 00:52:25,910
there will you choose Jason text or blob

00:52:22,460 --> 00:52:28,010
but but typically if you're storing not

00:52:25,910 --> 00:52:30,050
one customer but many customers in an

00:52:28,010 --> 00:52:33,710
individual column that's the wrong

00:52:30,050 --> 00:52:39,859
design it should be one row per customer

00:52:33,710 --> 00:52:44,750
yeah okay there was some more questions

00:52:39,859 --> 00:52:46,490
back that way so the hands up before no

00:52:44,750 --> 00:52:47,869
okay sorry it's another benchmark

00:52:46,490 --> 00:52:51,079
question but it was on one of your

00:52:47,869 --> 00:52:53,329
slides your your sales pitch I your

00:52:51,079 --> 00:52:56,210
sales pitch slide said that my school 57

00:52:53,329 --> 00:52:58,579
was three times as fast as 56 right is

00:52:56,210 --> 00:53:03,560
that a real world sort of performance

00:52:58,579 --> 00:53:09,339
where I expect to see that so have you

00:53:03,560 --> 00:53:12,140
cheated on the benchmark well out yeah

00:53:09,339 --> 00:53:14,750
so we are allowed to compare to our self

00:53:12,140 --> 00:53:16,849
I think that's fine it's comparing to

00:53:14,750 --> 00:53:19,430
others that I said was bad so you can't

00:53:16,849 --> 00:53:21,380
catch me on that one um I can tell you

00:53:19,430 --> 00:53:24,859
where we get the number from this is a

00:53:21,380 --> 00:53:27,670
peak number on a big server we can now

00:53:24,859 --> 00:53:29,690
do 1.6 million queries per second

00:53:27,670 --> 00:53:31,880
previously our number was the third of

00:53:29,690 --> 00:53:34,339
that I don't think everyone is running

00:53:31,880 --> 00:53:36,440
these big service but something to

00:53:34,339 --> 00:53:38,359
consider is that each GA release is

00:53:36,440 --> 00:53:42,190
supported for eight years in total and

00:53:38,359 --> 00:53:44,210
not all workloads charred perfectly

00:53:42,190 --> 00:53:45,589
related to working set and some other

00:53:44,210 --> 00:53:48,380
complexities so I think it's great

00:53:45,589 --> 00:53:50,900
insurance to be able to know that we can

00:53:48,380 --> 00:53:54,430
scale on big systems with that future in

00:53:50,900 --> 00:53:54,430
mind yeah

00:53:56,190 --> 00:54:13,980
two more questions here when it comes to

00:54:10,480 --> 00:54:17,320
JSON object and you've got nested

00:54:13,980 --> 00:54:19,810
objects or hierarchical data what is

00:54:17,320 --> 00:54:22,570
there a limitation on the depth of the

00:54:19,810 --> 00:54:24,940
day so you can plan no no limitation on

00:54:22,570 --> 00:54:27,730
the depths just a limitation from the

00:54:24,940 --> 00:54:29,650
practical amount of rollover locking and

00:54:27,730 --> 00:54:34,840
if you update it that we must rewrite

00:54:29,650 --> 00:54:36,190
the full thing yeah so I like to say if

00:54:34,840 --> 00:54:39,430
you need a rule of thumb keep the

00:54:36,190 --> 00:54:45,280
full-size an egg render even though the

00:54:39,430 --> 00:54:48,760
maximum size is gigabyte um you said

00:54:45,280 --> 00:54:52,870
relational ways are so 1990s hoses

00:54:48,760 --> 00:54:54,490
joking do you think that well but but in

00:54:52,870 --> 00:54:56,860
seriousness do you think that

00:54:54,490 --> 00:54:58,480
schema-less is the way that MySQL will

00:54:56,860 --> 00:55:01,840
eventually go or will you always hold

00:54:58,480 --> 00:55:04,210
out as relational first and jasons like

00:55:01,840 --> 00:55:06,270
your added extra we are committed to

00:55:04,210 --> 00:55:09,270
improving this use case even further

00:55:06,270 --> 00:55:09,270
yeah

00:55:09,930 --> 00:55:18,109
thank you I have a question about if

00:55:15,030 --> 00:55:21,030
you're doing a select on a Jason and

00:55:18,109 --> 00:55:23,339
column on a particular key that's in

00:55:21,030 --> 00:55:26,040
there using the path can you do any sort

00:55:23,339 --> 00:55:28,619
of operator on that can you do like can

00:55:26,040 --> 00:55:31,680
you do you know all sorts of string

00:55:28,619 --> 00:55:33,809
operators on those values the right so

00:55:31,680 --> 00:55:35,730
there is another function that you can

00:55:33,809 --> 00:55:39,210
do some sort of like similar to adjacent

00:55:35,730 --> 00:55:42,089
search I forget the exact function

00:55:39,210 --> 00:55:44,760
arguments to be able to do that but but

00:55:42,089 --> 00:55:53,910
you can do a a wild-card match in in

00:55:44,760 --> 00:55:55,589
those functions thank you just to follow

00:55:53,910 --> 00:55:58,020
on from a question earlier one where

00:55:55,589 --> 00:56:01,230
you're talking about the possible

00:55:58,020 --> 00:56:03,119
standardization of this feature across

00:56:01,230 --> 00:56:04,740
SQL right and is the implementation

00:56:03,119 --> 00:56:06,599
you've just described in the methods

00:56:04,740 --> 00:56:08,339
that you've just described kind of is

00:56:06,599 --> 00:56:10,470
that kind of matching up to this some

00:56:08,339 --> 00:56:12,750
draft standard so that it actually will

00:56:10,470 --> 00:56:15,450
look quite similar across the across the

00:56:12,750 --> 00:56:16,650
Beast yeah this you know if you just had

00:56:15,450 --> 00:56:18,380
to go your own way because there's

00:56:16,650 --> 00:56:22,740
nothing really ready yet kind of thing

00:56:18,380 --> 00:56:24,299
both okay um so let me pull up the list

00:56:22,740 --> 00:56:26,819
of Jason functions because that's kind

00:56:24,299 --> 00:56:29,430
of interesting right when we put out a

00:56:26,819 --> 00:56:32,400
labs release which was our first preview

00:56:29,430 --> 00:56:34,500
of this Jason functionality we actually

00:56:32,400 --> 00:56:37,020
named all the functions instead of Jason

00:56:34,500 --> 00:56:40,230
underscore something JSN underscore or

00:56:37,020 --> 00:56:42,480
something to be able to not I basically

00:56:40,230 --> 00:56:43,980
take the namespace of what inevitably be

00:56:42,480 --> 00:56:45,420
the standard that could have different

00:56:43,980 --> 00:56:48,839
arguments for each of these functions

00:56:45,420 --> 00:56:50,790
and so forth and we got overwhelming

00:56:48,839 --> 00:56:54,480
feedback from people saying this is just

00:56:50,790 --> 00:56:56,849
bad for usability you should call it

00:56:54,480 --> 00:56:59,400
Jason and everyone else had called it

00:56:56,849 --> 00:57:01,040
Jason and so we're all in the same boat

00:56:59,400 --> 00:57:04,730
that if the standard chooses a different

00:57:01,040 --> 00:57:07,980
implementation reconciliation and

00:57:04,730 --> 00:57:10,720
maintaining backwards compatibility may

00:57:07,980 --> 00:57:12,830
be interesting yeah

00:57:10,720 --> 00:57:15,020
yeah we maybe we might have to have a

00:57:12,830 --> 00:57:16,880
mode saying you know how we should

00:57:15,020 --> 00:57:19,550
behave standards-compliant on non

00:57:16,880 --> 00:57:23,060
standards-compliant we are committed to

00:57:19,550 --> 00:57:24,890
following the standards where I you know

00:57:23,060 --> 00:57:26,540
we don't break backwards compatibility

00:57:24,890 --> 00:57:31,130
in doing so so it's not changed for the

00:57:26,540 --> 00:57:33,109
sake of change and and I would like to

00:57:31,130 --> 00:57:35,390
be able to follow that in future but

00:57:33,109 --> 00:57:37,010
every database jumped the gun we all

00:57:35,390 --> 00:57:39,560
implemented this before it's a standard

00:57:37,010 --> 00:57:41,330
I think it would be great to be a

00:57:39,560 --> 00:57:53,630
standard it makes a lot of sense to me

00:57:41,330 --> 00:57:55,869
this use case okay thanks okay I think

00:57:53,630 --> 00:57:55,869

YouTube URL: https://www.youtube.com/watch?v=rC0Hat5GV6g


