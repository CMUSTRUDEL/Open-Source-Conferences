Title: PHP UK Conference 2016 - Juozas KaziukÄ—nas - From PHP to Machine Code
Publication date: 2016-03-17
Playlist: PHP UK Conference 2016
Description: 
	What exactly happens when you run `php example.com`? I wanted to answer this, so I decided to build my own PHP interpreter. Let me tell you what I learned and what does fancy words like opcodes and bytecode cache mean. With now two main rivals the standard PHP and HHVM from Facebook, there are plenty of choices to run your code fast. But they are both complicated projects, making it hard to understand the inner workings. Rather than relying on them to magically do the right thing, understand the principles of programming languages.
Captions: 
	00:00:10,960 --> 00:00:18,850
is my mic on okay so this talk is from

00:00:16,180 --> 00:00:20,470
PHP t machine goes it probably is the

00:00:18,850 --> 00:00:22,840
most useless thing you will hear today

00:00:20,470 --> 00:00:25,990
it will teach it I think it will teach

00:00:22,840 --> 00:00:29,500
you nothing but my goal is to give a

00:00:25,990 --> 00:00:31,210
sense of understand meant on how

00:00:29,500 --> 00:00:33,760
computers work so if you if you learn

00:00:31,210 --> 00:00:36,040
anything is the skill you can apply to

00:00:33,760 --> 00:00:37,239
any programming language and it tool you

00:00:36,040 --> 00:00:39,670
will use in the future because you will

00:00:37,239 --> 00:00:44,109
know how they actually function down to

00:00:39,670 --> 00:00:48,489
the machine level so my name is Joe I've

00:00:44,109 --> 00:00:51,510
spoken to be here before and I think two

00:00:48,489 --> 00:00:54,609
years ago currently live in New York

00:00:51,510 --> 00:00:57,519
spend most of my days building all sorts

00:00:54,609 --> 00:00:59,859
of internet projects and I was recently

00:00:57,519 --> 00:01:01,870
deported from the United States so

00:00:59,859 --> 00:01:03,339
that's what I did when I was deported I

00:01:01,870 --> 00:01:05,560
built this thing which I'm going to talk

00:01:03,339 --> 00:01:09,310
about if anyone wants to talk about

00:01:05,560 --> 00:01:12,760
immigration and the US law I can give a

00:01:09,310 --> 00:01:16,360
talk about that as well anyway let's get

00:01:12,760 --> 00:01:19,119
to the real things so a question I had

00:01:16,360 --> 00:01:21,579
is when when you type this in your arm

00:01:19,119 --> 00:01:23,710
in order to terminal no matter what

00:01:21,579 --> 00:01:25,930
operating system you use what has

00:01:23,710 --> 00:01:28,780
actually happened in your machine like I

00:01:25,930 --> 00:01:31,659
i know i'm writing source code as a text

00:01:28,780 --> 00:01:33,100
file it almost looks like english i run

00:01:31,659 --> 00:01:35,770
this one command and all of a sudden

00:01:33,100 --> 00:01:39,640
things come out or probably syntax error

00:01:35,770 --> 00:01:41,320
comes out so I had like I had no idea

00:01:39,640 --> 00:01:47,020
how it works I needed to look at anymore

00:01:41,320 --> 00:01:49,240
so i looked at c++ and c++ of course has

00:01:47,020 --> 00:01:51,520
two steps so you compile your source

00:01:49,240 --> 00:01:53,380
code source code first some magic

00:01:51,520 --> 00:01:56,259
happens to your source code and then you

00:01:53,380 --> 00:01:59,049
run it on i guess the same operating

00:01:56,259 --> 00:02:00,880
system you just compiled and then it

00:01:59,049 --> 00:02:03,909
works so there are two steps PHP seem to

00:02:00,880 --> 00:02:06,390
have one so i started looking at that

00:02:03,909 --> 00:02:10,080
and the first thing I learned was that a

00:02:06,390 --> 00:02:14,200
compiler all it does it just translates

00:02:10,080 --> 00:02:15,610
source code to let say machine code I'm

00:02:14,200 --> 00:02:17,830
kind of simplifying the concept of

00:02:15,610 --> 00:02:21,490
machine code is it compiled it to a set

00:02:17,830 --> 00:02:23,110
of instructions so compilers don't

00:02:21,490 --> 00:02:24,120
really do any sort of magical things we

00:02:23,110 --> 00:02:26,280
don't just

00:02:24,120 --> 00:02:29,580
I will come up with things all they do

00:02:26,280 --> 00:02:30,989
is translate your source code to machine

00:02:29,580 --> 00:02:33,239
code almost like a one-to-one mapping

00:02:30,989 --> 00:02:35,099
especially languages like seeds like

00:02:33,239 --> 00:02:36,720
sometimes very close to just one to one

00:02:35,099 --> 00:02:38,700
mapping they're like translate every

00:02:36,720 --> 00:02:41,040
line of Sita a set of assembler commands

00:02:38,700 --> 00:02:43,110
for example but this doesn't seem to

00:02:41,040 --> 00:02:45,329
relate to page piano so how this PHP

00:02:43,110 --> 00:02:49,349
does things well this tree does all this

00:02:45,329 --> 00:02:51,000
at runtime almost all this at runtime so

00:02:49,349 --> 00:02:52,620
that's what that was kind of obvious of

00:02:51,000 --> 00:02:54,680
course Peters have a compiled step so it

00:02:52,620 --> 00:02:56,910
has to be doing all this central time

00:02:54,680 --> 00:02:59,129
still I had no idea how any of this

00:02:56,910 --> 00:03:01,319
actually functions it's not like I've

00:02:59,129 --> 00:03:03,450
not participated in the PHP internal so

00:03:01,319 --> 00:03:06,450
don't really know the fundamentals of

00:03:03,450 --> 00:03:09,890
that so I was left to reading books and

00:03:06,450 --> 00:03:12,780
that's very boring so I try to look at

00:03:09,890 --> 00:03:15,690
like faster paps how can I actually

00:03:12,780 --> 00:03:19,049
learn how compilers work for languages

00:03:15,690 --> 00:03:20,970
like PHP without having to spend I don't

00:03:19,049 --> 00:03:23,069
know months or years reading books and

00:03:20,970 --> 00:03:26,760
watching tutorials and doing all the

00:03:23,069 --> 00:03:28,349
things so as the hacker I was like no

00:03:26,760 --> 00:03:32,069
I'm going to do I'm going to build one

00:03:28,349 --> 00:03:34,290
so an obvious resolution came to my mind

00:03:32,069 --> 00:03:36,150
I was like let's instead of trying to

00:03:34,290 --> 00:03:39,359
learn it there's like hack together a

00:03:36,150 --> 00:03:41,700
project which would do that thing which

00:03:39,359 --> 00:03:43,169
was a compiled HP so there's a saying

00:03:41,700 --> 00:03:44,639
that like you should everyone should

00:03:43,169 --> 00:03:47,099
write their own that framework and then

00:03:44,639 --> 00:03:47,940
never use it I did the same thing like

00:03:47,099 --> 00:03:51,410
if you everyone should write their own

00:03:47,940 --> 00:03:56,760
compiler and then never use it again and

00:03:51,410 --> 00:03:59,730
that's what I did so last year I built

00:03:56,760 --> 00:04:02,419
this project called PI HP look at that

00:03:59,730 --> 00:04:04,769
like an obvious name it has Python it

00:04:02,419 --> 00:04:10,379
it's all open source it's all available

00:04:04,769 --> 00:04:13,440
on github as the name suggests it's of

00:04:10,379 --> 00:04:15,239
course written in Python there's a

00:04:13,440 --> 00:04:17,250
there's a list of reasons why i did in

00:04:15,239 --> 00:04:19,049
python i'm going to go in them in detail

00:04:17,250 --> 00:04:21,389
but that's all this if you've done

00:04:19,049 --> 00:04:24,210
Python before you can just go to github

00:04:21,389 --> 00:04:26,310
check out the source code run it and

00:04:24,210 --> 00:04:27,720
it'll actually work python is a pretty

00:04:26,310 --> 00:04:29,520
simple language you can actually read

00:04:27,720 --> 00:04:32,280
the code there easily and it's actually

00:04:29,520 --> 00:04:34,590
much more readable than at least a PHP

00:04:32,280 --> 00:04:37,810
core would be so what sort of things

00:04:34,590 --> 00:04:41,730
does it do well it runs any PHP

00:04:37,810 --> 00:04:45,970
except they use the usable parts so it's

00:04:41,730 --> 00:04:48,070
it turns a tiny subset of PHP because I

00:04:45,970 --> 00:04:50,590
did that almost in a test driven

00:04:48,070 --> 00:04:52,720
development way where I was like PHP

00:04:50,590 --> 00:04:55,270
source code has this file called bench

00:04:52,720 --> 00:04:58,090
PHP this macro micro benchmarks file

00:04:55,270 --> 00:04:59,320
that's ten ten different functions and

00:04:58,090 --> 00:05:02,500
make tents different things like array

00:04:59,320 --> 00:05:03,880
access passing by reference loops if

00:05:02,500 --> 00:05:05,740
statements all sort of different things

00:05:03,880 --> 00:05:08,350
we're just calling a function thousand

00:05:05,740 --> 00:05:10,060
times so my goal was let's implement

00:05:08,350 --> 00:05:12,280
just that it's implement enough

00:05:10,060 --> 00:05:16,060
functionality so can run the bench file

00:05:12,280 --> 00:05:19,740
it performs the same tasks as the page

00:05:16,060 --> 00:05:22,389
view corbould but but now written by me

00:05:19,740 --> 00:05:26,320
so of course you can't run symphony on

00:05:22,389 --> 00:05:28,150
it just yet it's written in Python it's

00:05:26,320 --> 00:05:30,400
very simple it's just think a couple

00:05:28,150 --> 00:05:33,760
thousands of lines and is super super

00:05:30,400 --> 00:05:36,220
fast I'll come back to performance a bit

00:05:33,760 --> 00:05:39,910
later it's very very fast it's probably

00:05:36,220 --> 00:05:42,039
at least three three times fast 70 HP

00:05:39,910 --> 00:05:45,760
seven and i think it was five times

00:05:42,039 --> 00:05:48,760
faster than PHP 556 i'll come back why

00:05:45,760 --> 00:05:51,340
it's actually that fast also has some

00:05:48,760 --> 00:05:55,900
interesting features so everyone has

00:05:51,340 --> 00:05:58,960
heard of PHP six and the problem PHP six

00:05:55,900 --> 00:06:01,510
tries to solve is that if you have a

00:05:58,960 --> 00:06:05,020
Unicode string currently in PHP and if

00:06:01,510 --> 00:06:07,180
you try to access characters what you

00:06:05,020 --> 00:06:09,910
expect to get back our is these

00:06:07,180 --> 00:06:13,120
different letters but actually you what

00:06:09,910 --> 00:06:17,200
you would get is two halves of the first

00:06:13,120 --> 00:06:18,400
letter so you run it in any like any PHP

00:06:17,200 --> 00:06:20,110
installation right now you can get to

00:06:18,400 --> 00:06:23,340
gush remarks because it's trying to

00:06:20,110 --> 00:06:28,180
print like half of the Unicode character

00:06:23,340 --> 00:06:29,590
and because because because what what

00:06:28,180 --> 00:06:31,389
I've done we'll just use Python and

00:06:29,590 --> 00:06:35,800
python is a unique code language in the

00:06:31,389 --> 00:06:39,100
first place it's the only existing PHP 6

00:06:35,800 --> 00:06:40,479
implementation on a planet it actually

00:06:39,100 --> 00:06:43,150
works like this it's not a fake slide

00:06:40,479 --> 00:06:45,340
everything in pipe in PHP is actually

00:06:43,150 --> 00:06:48,340
unicode both function names variable

00:06:45,340 --> 00:06:50,289
names strings everything is uniquely so

00:06:48,340 --> 00:06:51,110
if you want to use unicode then you want

00:06:50,289 --> 00:06:57,020
to be like peach

00:06:51,110 --> 00:06:59,600
certified you can use PI HP so that's

00:06:57,020 --> 00:07:02,750
that so that's a fun part let's actually

00:06:59,600 --> 00:07:04,630
get to the basics so before I come back

00:07:02,750 --> 00:07:07,550
to talking about how actually page PHP

00:07:04,630 --> 00:07:11,990
functions and sort of logic i use for it

00:07:07,550 --> 00:07:14,330
I want to go through the fundamentals of

00:07:11,990 --> 00:07:16,330
interpreters I guess the fundamentals of

00:07:14,330 --> 00:07:19,040
compilers so any programming language

00:07:16,330 --> 00:07:22,040
any dynamic programming language has

00:07:19,040 --> 00:07:25,100
three steps three steps like that Python

00:07:22,040 --> 00:07:27,080
Ruby PHP any one you pick I guess

00:07:25,100 --> 00:07:28,670
JavaScript as well they all go through

00:07:27,080 --> 00:07:31,190
these three steps you parse the source

00:07:28,670 --> 00:07:34,810
of source code first you come up these

00:07:31,190 --> 00:07:37,130
things called up codes then you run them

00:07:34,810 --> 00:07:39,290
one of the first lessons are learned is

00:07:37,130 --> 00:07:40,820
when it comes to up code cache this

00:07:39,290 --> 00:07:43,430
thing you're supposed to be using and I

00:07:40,820 --> 00:07:46,580
hope you're all using is it caches these

00:07:43,430 --> 00:07:48,260
two first steps so when you install up

00:07:46,580 --> 00:07:51,080
code cache when you enable up code cache

00:07:48,260 --> 00:07:54,440
all it does it just skips these first

00:07:51,080 --> 00:07:57,800
two steps and go straight execution why

00:07:54,440 --> 00:07:59,780
is that because parsing doesn't change

00:07:57,800 --> 00:08:01,340
the files doesn't change and then of

00:07:59,780 --> 00:08:03,260
course generating the machine code out

00:08:01,340 --> 00:08:04,850
of it also doesn't change as long as

00:08:03,260 --> 00:08:07,580
your source code doesn't change so when

00:08:04,850 --> 00:08:11,180
you install up code cache that's what it

00:08:07,580 --> 00:08:12,860
does it skips the first two steps of of

00:08:11,180 --> 00:08:14,360
execution of course that's why it's so

00:08:12,860 --> 00:08:15,230
much faster to use opcode cash and

00:08:14,360 --> 00:08:17,330
that's why everyone should use it

00:08:15,230 --> 00:08:18,680
because it has no drawbacks but it just

00:08:17,330 --> 00:08:21,820
skips the first two steps which are

00:08:18,680 --> 00:08:24,260
repetitive anyway so the first step is

00:08:21,820 --> 00:08:26,330
something you could do really fast so

00:08:24,260 --> 00:08:29,630
even if opcode even without using things

00:08:26,330 --> 00:08:31,640
like opcode cash PHP can run through

00:08:29,630 --> 00:08:34,550
this super quickly like in a matter of

00:08:31,640 --> 00:08:36,920
milliseconds and the first step is to

00:08:34,550 --> 00:08:38,720
parse the source code file which is just

00:08:36,920 --> 00:08:42,590
currently it is just a massive strain

00:08:38,720 --> 00:08:45,140
into a list of tokens a data structure

00:08:42,590 --> 00:08:48,860
we can use to play around them and plug

00:08:45,140 --> 00:08:52,600
into different parts since PHP 7 also if

00:08:48,860 --> 00:08:55,220
i'm not mistaken PHP also has a

00:08:52,600 --> 00:08:57,860
additional step which is it creates a

00:08:55,220 --> 00:09:01,250
thing called a SD tree which is the

00:08:57,860 --> 00:09:03,410
abstract source code tree so we go from

00:09:01,250 --> 00:09:04,150
a source code file being just a massive

00:09:03,410 --> 00:09:06,310
string

00:09:04,150 --> 00:09:08,740
to a source code file being represented

00:09:06,310 --> 00:09:13,030
as a nested data structure we should

00:09:08,740 --> 00:09:14,650
then we can use to build for a logic so

00:09:13,030 --> 00:09:16,750
some of the tools which do static

00:09:14,650 --> 00:09:18,520
analysis for four different programming

00:09:16,750 --> 00:09:20,740
languages for PHP included that's what

00:09:18,520 --> 00:09:22,390
they do they partial source code that

00:09:20,740 --> 00:09:24,490
build the source code tree and now I

00:09:22,390 --> 00:09:27,370
have this code structure I can play

00:09:24,490 --> 00:09:30,010
around and inspect your source code but

00:09:27,370 --> 00:09:32,920
that's the first video most of the

00:09:30,010 --> 00:09:37,840
languages have these things called

00:09:32,920 --> 00:09:40,360
grammas so even PHP has this almost

00:09:37,840 --> 00:09:43,420
looking exactly the same just thousand

00:09:40,360 --> 00:09:46,990
times longer and then see in piyush be

00:09:43,420 --> 00:09:48,370
just a bit a bunch of texts but all

00:09:46,990 --> 00:09:50,950
programming language is exactly the same

00:09:48,370 --> 00:09:55,300
they define the programming language as

00:09:50,950 --> 00:09:57,850
a recursive set of statements which we

00:09:55,300 --> 00:09:59,500
can plug that in like you give us a par

00:09:57,850 --> 00:10:01,780
service and you give a partial source

00:09:59,500 --> 00:10:04,030
file and it's able to pick out these

00:10:01,780 --> 00:10:05,500
statements so you can see in this house

00:10:04,030 --> 00:10:06,880
if statement is defined like an if

00:10:05,500 --> 00:10:10,150
statement can have a comparison

00:10:06,880 --> 00:10:12,850
expression a statement or a comparison

00:10:10,150 --> 00:10:14,910
expression statement else branch and you

00:10:12,850 --> 00:10:17,680
define all of the language in this file

00:10:14,910 --> 00:10:21,100
if you sort of a format and then you can

00:10:17,680 --> 00:10:23,410
build very fast parsers and in this step

00:10:21,100 --> 00:10:27,370
we also rename all the variables student

00:10:23,410 --> 00:10:31,030
two numbers as well so if I have a file

00:10:27,370 --> 00:10:32,020
like that I call the spunk PHP actually

00:10:31,030 --> 00:10:34,230
has a function for that you can call

00:10:32,020 --> 00:10:36,670
token underscore get underscore all and

00:10:34,230 --> 00:10:39,520
prints out all the tokens in my source

00:10:36,670 --> 00:10:41,110
file probably something you don't really

00:10:39,520 --> 00:10:42,960
want to look at unless you're building

00:10:41,110 --> 00:10:45,580
source code analysis or static analysis

00:10:42,960 --> 00:10:48,070
but that's what tokens look like you can

00:10:45,580 --> 00:10:51,820
see that every piece of code is now

00:10:48,070 --> 00:10:54,550
represented by by token so we be dropped

00:10:51,820 --> 00:10:57,040
like code specific structure we drop new

00:10:54,550 --> 00:10:58,930
lines we dropped spaces really we can

00:10:57,040 --> 00:11:00,280
all remove all the white space and now

00:10:58,930 --> 00:11:02,500
we're left with just a bunch of tokens

00:11:00,280 --> 00:11:06,610
and then we can take one more step and

00:11:02,500 --> 00:11:08,800
we can generate unnecessary structure of

00:11:06,610 --> 00:11:10,480
course it's much more usable and much

00:11:08,800 --> 00:11:12,550
more easier to kind of play around if

00:11:10,480 --> 00:11:14,080
you have an essence structure as opposed

00:11:12,550 --> 00:11:16,730
to just having a list so that's what PHP

00:11:14,080 --> 00:11:19,820
does as of the latest version are

00:11:16,730 --> 00:11:22,850
internally I different like a new thing

00:11:19,820 --> 00:11:24,769
I learned through this is that as you're

00:11:22,850 --> 00:11:26,149
doing source code analysis source code

00:11:24,769 --> 00:11:27,800
parsing and then you're like shipping

00:11:26,149 --> 00:11:29,990
out all the variable names images using

00:11:27,800 --> 00:11:32,510
an American Texas because it is faster

00:11:29,990 --> 00:11:34,519
you can do a lot of like neat features

00:11:32,510 --> 00:11:39,620
at the same time solenn PHP added

00:11:34,519 --> 00:11:41,630
namespaces all it all it does is that it

00:11:39,620 --> 00:11:44,899
takes a namespace from the top of the

00:11:41,630 --> 00:11:48,110
file and appends the string to every

00:11:44,899 --> 00:11:51,230
class name in the file they're called

00:11:48,110 --> 00:11:53,600
fully qualified class names so if you

00:11:51,230 --> 00:11:56,660
like if you think this namespace support

00:11:53,600 --> 00:11:58,250
is some kind of a crazy execution time

00:11:56,660 --> 00:12:00,380
thing where it figures out where the

00:11:58,250 --> 00:12:02,300
classes are where the name says are it's

00:12:00,380 --> 00:12:05,360
not that sophisticated it's actually

00:12:02,300 --> 00:12:08,120
very simple and basic where it at the

00:12:05,360 --> 00:12:10,459
parsing time of thing it takes a

00:12:08,120 --> 00:12:12,110
namespace it takes all the class all the

00:12:10,459 --> 00:12:14,779
class names appends them together and

00:12:12,110 --> 00:12:17,180
now it kind of removes the concept of

00:12:14,779 --> 00:12:19,190
namespaces all it has left of RVs long

00:12:17,180 --> 00:12:22,610
class names with full name space name's

00:12:19,190 --> 00:12:26,149
Prue need it does a similar thing for

00:12:22,610 --> 00:12:28,850
traits again you would think trade is

00:12:26,149 --> 00:12:31,040
traits is some kind of God clever hour

00:12:28,850 --> 00:12:33,170
runtime thing it doesn't actually happen

00:12:31,040 --> 00:12:34,790
in runtime you can do that while you're

00:12:33,170 --> 00:12:38,839
parsing the file all you do is copy and

00:12:34,790 --> 00:12:40,639
paste every single trade block to your

00:12:38,839 --> 00:12:42,319
class again I'm simplifying that of

00:12:40,639 --> 00:12:43,850
course there's more more involved but

00:12:42,319 --> 00:12:46,190
that's ultimately what it does it just

00:12:43,850 --> 00:12:48,560
takes a trade every time it's used in

00:12:46,190 --> 00:12:51,350
the class it just copy and paste the

00:12:48,560 --> 00:12:53,510
little bit of source code into that

00:12:51,350 --> 00:12:55,040
that's it so as you've seen as I'm

00:12:53,510 --> 00:12:56,510
parsing a file I can already do some

00:12:55,040 --> 00:13:00,920
kind of optimizations and clever hacks

00:12:56,510 --> 00:13:04,010
to go from usable features just to still

00:13:00,920 --> 00:13:07,339
the same list of tokens but again tokens

00:13:04,010 --> 00:13:09,319
are not not useful yet we can't run them

00:13:07,339 --> 00:13:12,880
so we have to come up these things

00:13:09,319 --> 00:13:16,760
called up codes a list of up codes is

00:13:12,880 --> 00:13:18,709
what's now on a bytecode and the best

00:13:16,760 --> 00:13:21,519
way I can describe what an opcode is is

00:13:18,709 --> 00:13:25,430
basically a virtual assembler command

00:13:21,519 --> 00:13:28,339
that's at least how I think about it if

00:13:25,430 --> 00:13:31,360
you ever written any assembler and I

00:13:28,339 --> 00:13:33,709
kind of feel sorry for you if you have

00:13:31,360 --> 00:13:37,970
that's what of course look like if you

00:13:33,709 --> 00:13:39,470
actually dumped out the output of PHP up

00:13:37,970 --> 00:13:43,279
codes they look like almost like an

00:13:39,470 --> 00:13:46,519
assembler command we can catch these

00:13:43,279 --> 00:13:48,680
results and we can also use a bunch of

00:13:46,519 --> 00:13:51,019
extensions or just an online tool to

00:13:48,680 --> 00:13:53,059
dump the up course for any source file

00:13:51,019 --> 00:13:56,050
of PHP you can look at that then you can

00:13:53,059 --> 00:13:58,430
like look for interesting things so if

00:13:56,050 --> 00:14:03,160
we look back is the same file we just

00:13:58,430 --> 00:14:06,680
had and run for this feel the extension

00:14:03,160 --> 00:14:08,569
these four up codes describe our source

00:14:06,680 --> 00:14:10,009
code so we went from parsing it to

00:14:08,569 --> 00:14:12,040
having this esta tree and I'll be

00:14:10,009 --> 00:14:14,480
generated a list of op codes which

00:14:12,040 --> 00:14:17,180
ignoring all the kind of debugging

00:14:14,480 --> 00:14:20,839
information at the top there's just a

00:14:17,180 --> 00:14:22,550
little assembler code I have and it's

00:14:20,839 --> 00:14:25,639
pretty obvious what it does it does

00:14:22,550 --> 00:14:29,389
variable assignation by numeric index

00:14:25,639 --> 00:14:31,160
main principle numeric index I mean in

00:14:29,389 --> 00:14:32,569
freeze a result because most of the

00:14:31,160 --> 00:14:35,240
statements return results but that's

00:14:32,569 --> 00:14:36,410
like implementation egos and then the

00:14:35,240 --> 00:14:39,230
last thing is just returns for

00:14:36,410 --> 00:14:40,879
successful parsing that's all it is like

00:14:39,230 --> 00:14:43,459
that's that's what you need for

00:14:40,879 --> 00:14:46,850
execution is to generate misslisa pop

00:14:43,459 --> 00:14:52,819
codes from a source file it gets the

00:14:46,850 --> 00:14:54,649
more interesting though actually just

00:14:52,819 --> 00:14:57,620
give it a sub that's what it looks like

00:14:54,649 --> 00:14:59,689
but it gets more interesting though so

00:14:57,620 --> 00:15:02,449
when I was looking at implementing that

00:14:59,689 --> 00:15:05,629
myself the question I had is if my list

00:15:02,449 --> 00:15:07,480
of up codes is it's a flat structure

00:15:05,629 --> 00:15:09,980
it's just a sequential list of commands

00:15:07,480 --> 00:15:12,709
how on earth I'm supposed to implement

00:15:09,980 --> 00:15:16,519
if statements how like how do I branch

00:15:12,709 --> 00:15:18,769
out into true and l's branches depending

00:15:16,519 --> 00:15:21,709
on the condition if all like if my

00:15:18,769 --> 00:15:24,259
bicycle dish is a massive list and the

00:15:21,709 --> 00:15:26,779
way it works is just you use labels so

00:15:24,259 --> 00:15:28,519
when PHP added labels it's not a new

00:15:26,779 --> 00:15:30,470
concept labels has been around for a

00:15:28,519 --> 00:15:33,559
very long time and actually you can use

00:15:30,470 --> 00:15:35,870
labels to implement any conditional

00:15:33,559 --> 00:15:37,699
structure an if statement a wild

00:15:35,870 --> 00:15:39,860
statement of for each statement of for

00:15:37,699 --> 00:15:42,980
statement all these code block

00:15:39,860 --> 00:15:44,150
structures can all boil down to using

00:15:42,980 --> 00:15:48,680
labels

00:15:44,150 --> 00:15:51,020
how does it work so I have color

00:15:48,680 --> 00:15:55,520
highlighting to kind of show showcase

00:15:51,020 --> 00:15:56,810
the the logic in there as you can see my

00:15:55,520 --> 00:15:59,600
if statement is still there so I'm

00:15:56,810 --> 00:16:02,060
comparing my variable to the string and

00:15:59,600 --> 00:16:05,960
rather have a little jump statement and

00:16:02,060 --> 00:16:12,410
that jump depends on the result so if

00:16:05,960 --> 00:16:15,560
it's true if it's true it continues

00:16:12,410 --> 00:16:18,830
running and then jumps here if it's

00:16:15,560 --> 00:16:21,200
false it jumps here and then continues

00:16:18,830 --> 00:16:23,240
running that's how if statements work

00:16:21,200 --> 00:16:24,590
that's how loops work the only

00:16:23,240 --> 00:16:27,380
difference in the loop is that instead

00:16:24,590 --> 00:16:29,390
of jumping or like instead of in a loop

00:16:27,380 --> 00:16:31,820
instead of continuing running the loop

00:16:29,390 --> 00:16:34,520
would just bat jump back to the top and

00:16:31,820 --> 00:16:36,800
just keep running that's all this that's

00:16:34,520 --> 00:16:39,800
how if statements and that's how loops

00:16:36,800 --> 00:16:42,590
work in the sequential manner like that

00:16:39,800 --> 00:16:48,770
you just use labels and jump statements

00:16:42,590 --> 00:16:51,800
to jump around super easy and then the

00:16:48,770 --> 00:16:56,600
last step we're left with is to actually

00:16:51,800 --> 00:17:01,160
execute our source code so now that we

00:16:56,600 --> 00:17:04,580
have a list of up codes our bytecode all

00:17:01,160 --> 00:17:07,880
we have to do is to run for every single

00:17:04,580 --> 00:17:12,680
one of them in a loop and execute a

00:17:07,880 --> 00:17:14,300
little piece of code for it so if it's a

00:17:12,680 --> 00:17:16,160
variable X ignatian we assign some

00:17:14,300 --> 00:17:18,589
variable some memory block we have and

00:17:16,160 --> 00:17:21,740
depending on the implementation whatever

00:17:18,589 --> 00:17:29,840
the engine decides to give it its stored

00:17:21,740 --> 00:17:33,500
in some place zend engine is the part of

00:17:29,840 --> 00:17:38,090
the PHP core which does bad we call them

00:17:33,500 --> 00:17:41,270
virtual machines because um it almost

00:17:38,090 --> 00:17:46,120
acts like an actual machine so it takes

00:17:41,270 --> 00:17:51,440
our virtual assembler and runs it but

00:17:46,120 --> 00:17:53,270
here's the here's the comparison so we

00:17:51,440 --> 00:17:55,250
had but we have byte code which is kind

00:17:53,270 --> 00:17:56,850
of like machine code we had sent we have

00:17:55,250 --> 00:17:58,260
zendegim which

00:17:56,850 --> 00:18:01,220
Electronics is kind of like an operating

00:17:58,260 --> 00:18:04,140
system so this level of abstraction

00:18:01,220 --> 00:18:07,980
which makes our bytecode act like it's

00:18:04,140 --> 00:18:11,100
some kind of a special assembler code so

00:18:07,980 --> 00:18:14,400
to run through the steps arm but first

00:18:11,100 --> 00:18:17,880
the first thing we had is the little AST

00:18:14,400 --> 00:18:20,030
tree of our source code the next thing

00:18:17,880 --> 00:18:23,340
we did means we generated a list of

00:18:20,030 --> 00:18:26,070
commands a list of up codes represented

00:18:23,340 --> 00:18:32,730
here as a PHP array and now we can run

00:18:26,070 --> 00:18:34,230
them this is really the only thing

00:18:32,730 --> 00:18:37,680
involved in running programming

00:18:34,230 --> 00:18:40,470
languages like any implementation PHP

00:18:37,680 --> 00:18:43,200
core itself somewhere has a loop which

00:18:40,470 --> 00:18:46,800
looks exactly like this this is like the

00:18:43,200 --> 00:18:48,090
key the golden key of of programming

00:18:46,800 --> 00:18:52,730
languages like the dynamic programming

00:18:48,090 --> 00:18:55,830
languages and what it does is it runs

00:18:52,730 --> 00:18:59,790
from a first command to the end of the

00:18:55,830 --> 00:19:02,340
list for every single command gets a

00:18:59,790 --> 00:19:05,000
handler for that command makes it do

00:19:02,340 --> 00:19:07,890
things for it if the command returns

00:19:05,000 --> 00:19:11,040
some value it returns but returns from

00:19:07,890 --> 00:19:13,470
execution if it's a jump statement it

00:19:11,040 --> 00:19:16,250
jumps to a different position and if not

00:19:13,470 --> 00:19:19,380
it just keeps ringing through that list

00:19:16,250 --> 00:19:21,360
again depending on implementation this

00:19:19,380 --> 00:19:24,750
loop might look much much more

00:19:21,360 --> 00:19:27,600
complicated but in reality it usually is

00:19:24,750 --> 00:19:29,400
just this it's just all it is a little

00:19:27,600 --> 00:19:32,460
simple loop we're just running for every

00:19:29,400 --> 00:19:37,410
command and when it comes to our

00:19:32,460 --> 00:19:39,570
implementation of actual opcodes all we

00:19:37,410 --> 00:19:43,290
have to do is we have to play more play

00:19:39,570 --> 00:19:45,930
around this concept of a frame a piece

00:19:43,290 --> 00:19:47,510
of memory or restoring the elbows so

00:19:45,930 --> 00:19:50,040
when it comes to assigning something

00:19:47,510 --> 00:19:52,620
that op code itself has a variable name

00:19:50,040 --> 00:19:54,570
or gets usually a variable index and

00:19:52,620 --> 00:19:57,300
when someone calls us we just take

00:19:54,570 --> 00:20:01,260
whatever the values and we store it in

00:19:57,300 --> 00:20:03,600
the frame if we have to return from a

00:20:01,260 --> 00:20:05,730
function call from a program itself we

00:20:03,600 --> 00:20:08,100
take whatever value is on top of the

00:20:05,730 --> 00:20:09,440
stack and we return it back to the

00:20:08,100 --> 00:20:12,630
execution

00:20:09,440 --> 00:20:15,180
that's all involved an interesting thing

00:20:12,630 --> 00:20:18,300
though and the one where spent the most

00:20:15,180 --> 00:20:22,290
time probably agonizing about is how do

00:20:18,300 --> 00:20:25,800
you do function calls page he has these

00:20:22,290 --> 00:20:27,150
interesting complications because for

00:20:25,800 --> 00:20:30,600
example it has access to global

00:20:27,150 --> 00:20:33,300
variables so my function which has its

00:20:30,600 --> 00:20:35,910
own scope can still sometimes access

00:20:33,300 --> 00:20:40,559
with parents cope that's what was an

00:20:35,910 --> 00:20:42,090
implementation hurdle but when it ball

00:20:40,559 --> 00:20:43,710
down to actually implementing it what

00:20:42,090 --> 00:20:46,950
it's like boiled down to figuring how it

00:20:43,710 --> 00:20:49,770
works all of this is when it comes to

00:20:46,950 --> 00:20:52,679
calling a function I'm basically running

00:20:49,770 --> 00:20:56,040
the same execution loop just for the

00:20:52,679 --> 00:20:58,440
function inside so all I'm doing is

00:20:56,040 --> 00:21:00,780
creating a new memory frame which I'm

00:20:58,440 --> 00:21:02,520
saying is this function has a new memory

00:21:00,780 --> 00:21:04,050
scope so all the variables inside the

00:21:02,520 --> 00:21:06,630
function are not accessible from outside

00:21:04,050 --> 00:21:08,760
but it also has a parent scope which if

00:21:06,630 --> 00:21:12,030
you have global defined I can still

00:21:08,760 --> 00:21:13,770
access things in a parent scope then I'm

00:21:12,030 --> 00:21:17,010
just running the same interpreter so

00:21:13,770 --> 00:21:18,300
it's a nested interpreter run and this

00:21:17,010 --> 00:21:23,340
is when it clicked for me I was like

00:21:18,300 --> 00:21:25,740
when PHP says max maximum method level

00:21:23,340 --> 00:21:29,010
reach which is effing by default 100 it

00:21:25,740 --> 00:21:31,350
says that to you because this is how its

00:21:29,010 --> 00:21:33,690
implemented so it can't let you keep

00:21:31,350 --> 00:21:35,210
creating these nested frames of data

00:21:33,690 --> 00:21:37,730
structures and can't keep letting you

00:21:35,210 --> 00:21:39,710
calling nested functions in of itself

00:21:37,730 --> 00:21:42,600
because that takes a lot of resources

00:21:39,710 --> 00:21:45,960
eventually duplicate so much memory all

00:21:42,600 --> 00:21:48,120
these in my case did so that's why most

00:21:45,960 --> 00:21:50,400
of the most of the language have nested

00:21:48,120 --> 00:21:52,350
limits because to implement them you

00:21:50,400 --> 00:21:53,910
also have to nest you keep be having to

00:21:52,350 --> 00:21:55,470
go deeper and deeper and deeper so

00:21:53,910 --> 00:21:58,890
eventually when I was running our

00:21:55,470 --> 00:22:00,600
benchmarks I was like well if if I'm

00:21:58,890 --> 00:22:03,780
calling a function from a function and

00:22:00,600 --> 00:22:05,940
at the 10,000th level I'm trying to

00:22:03,780 --> 00:22:09,660
access a global variable but it has to

00:22:05,940 --> 00:22:12,360
go through 10,000 data frames to figure

00:22:09,660 --> 00:22:14,370
out go to variable is back it becomes

00:22:12,360 --> 00:22:17,370
super tricky so that's what languages

00:22:14,370 --> 00:22:19,230
limit you how deep you can go in the

00:22:17,370 --> 00:22:22,200
nest is recursive calls and that's why

00:22:19,230 --> 00:22:22,770
some people would say Oh recursive

00:22:22,200 --> 00:22:25,680
function

00:22:22,770 --> 00:22:27,750
are slower than implementing loops like

00:22:25,680 --> 00:22:29,490
this is a classic example of programming

00:22:27,750 --> 00:22:32,900
which is implemented for Fibonacci

00:22:29,490 --> 00:22:34,890
sequence the easiest solution is to use

00:22:32,900 --> 00:22:36,750
recursive functions for that but

00:22:34,890 --> 00:22:38,670
actually the fastest solution is to use

00:22:36,750 --> 00:22:41,220
loops for that because the recursive

00:22:38,670 --> 00:22:43,350
function is expensive because we have to

00:22:41,220 --> 00:22:44,970
do this that's where recursive functions

00:22:43,350 --> 00:22:46,470
are more expensive we have to create new

00:22:44,970 --> 00:22:49,080
scopes variables we have to figure out

00:22:46,470 --> 00:22:51,150
where variables went and one back it's a

00:22:49,080 --> 00:22:55,200
bit more complicated so we can't really

00:22:51,150 --> 00:22:59,430
optimize them so if we want to define

00:22:55,200 --> 00:23:01,560
that this is what happens when we are

00:22:59,430 --> 00:23:04,770
talking about parsing PHP and running in

00:23:01,560 --> 00:23:07,890
machine code we parse every line of

00:23:04,770 --> 00:23:11,100
source code we come up with this fake

00:23:07,890 --> 00:23:13,200
assembler code we call bytecode we cache

00:23:11,100 --> 00:23:17,240
it or we don't cash it when you run it

00:23:13,200 --> 00:23:21,720
involve virtual machine that's all this

00:23:17,240 --> 00:23:24,360
but an interesting thing is our virtual

00:23:21,720 --> 00:23:26,670
machine can be written anything because

00:23:24,360 --> 00:23:29,850
the actual machine code which gets

00:23:26,670 --> 00:23:33,600
executed is the machine code or our VM

00:23:29,850 --> 00:23:36,930
calling low-level operations soz nvm is

00:23:33,600 --> 00:23:38,340
implemented in see that's the compiled

00:23:36,930 --> 00:23:40,950
party which ends up actually getting

00:23:38,340 --> 00:23:43,680
generating these machine codes my Python

00:23:40,950 --> 00:23:45,330
code is what we can call as the one

00:23:43,680 --> 00:23:48,150
calling the machine codes because that's

00:23:45,330 --> 00:23:51,380
the last step which actions of calling

00:23:48,150 --> 00:23:55,850
system i 0 or printing things or the

00:23:51,380 --> 00:24:00,140
accessing memory so why why does anyone

00:23:55,850 --> 00:24:02,580
want to do this and why has facebook

00:24:00,140 --> 00:24:06,300
spent years trying to come up with their

00:24:02,580 --> 00:24:10,230
own implementation of page fee of course

00:24:06,300 --> 00:24:12,660
it's all about performance the competing

00:24:10,230 --> 00:24:14,190
are the computing compiler success

00:24:12,660 --> 00:24:17,430
because people are always trying to come

00:24:14,190 --> 00:24:19,410
up with faster ways to run code if you

00:24:17,430 --> 00:24:21,660
can run something faster it's always

00:24:19,410 --> 00:24:23,490
always better I don't know if you just

00:24:21,660 --> 00:24:26,910
saw it like I was just reading this

00:24:23,490 --> 00:24:29,360
morning about this asp.net just became

00:24:26,910 --> 00:24:31,560
like 10 times faster because if they

00:24:29,360 --> 00:24:34,020
whatever new thing Microsoft released

00:24:31,560 --> 00:24:36,030
just made it that much faster so if you

00:24:34,020 --> 00:24:37,110
can make these sort of improvements it's

00:24:36,030 --> 00:24:40,140
amazing and that's what

00:24:37,110 --> 00:24:42,179
Facebook try to do why does it apply to

00:24:40,140 --> 00:24:44,730
a page fee because I guess PHP is kind

00:24:42,179 --> 00:24:46,770
of slow ish so some people some people

00:24:44,730 --> 00:24:52,130
would say well PHP slow facebook said

00:24:46,770 --> 00:24:54,090
PHP slow let's build something faster I

00:24:52,130 --> 00:24:57,240
kind of thought about it as well like

00:24:54,090 --> 00:24:59,280
I'm running this bench file what I can

00:24:57,240 --> 00:25:01,170
do to my source code to make it faster

00:24:59,280 --> 00:25:02,580
what I can do to my implementation to

00:25:01,170 --> 00:25:06,809
make it actually faster like how it can

00:25:02,580 --> 00:25:10,350
beat the slowness of PHP and the reason

00:25:06,809 --> 00:25:12,600
the reason why PHP is slow as compared

00:25:10,350 --> 00:25:15,179
to I know things like C is because it's

00:25:12,600 --> 00:25:17,490
not specialized so another lesson I

00:25:15,179 --> 00:25:21,299
learned is that if you want to write

00:25:17,490 --> 00:25:24,030
fast code the only way you can achieve

00:25:21,299 --> 00:25:25,890
that is by specializing when it comes to

00:25:24,030 --> 00:25:28,549
execution of languages and execution of

00:25:25,890 --> 00:25:32,549
like programming language level

00:25:28,549 --> 00:25:36,030
optimizations you specify by using types

00:25:32,549 --> 00:25:38,100
usually so that's the first there's the

00:25:36,030 --> 00:25:41,490
first thing if you don't use types which

00:25:38,100 --> 00:25:45,090
PHP doesn't use types is you can't

00:25:41,490 --> 00:25:47,610
really optimized to the same degree as C

00:25:45,090 --> 00:25:51,600
would because C specialized she knows

00:25:47,610 --> 00:25:53,309
what the variable type is and i was

00:25:51,600 --> 00:25:56,130
listening out to one of the core

00:25:53,309 --> 00:25:58,500
developer tops of PHP in nikita and he

00:25:56,130 --> 00:26:00,600
said that PHP has come to the point

00:25:58,500 --> 00:26:02,400
where it you can't really do a lot of

00:26:00,600 --> 00:26:04,290
clever hacks anymore to the source code

00:26:02,400 --> 00:26:06,210
of it the only way you can optimize it

00:26:04,290 --> 00:26:09,840
is by reducing memory structures and

00:26:06,210 --> 00:26:11,520
making less I 02 memory that's how

00:26:09,840 --> 00:26:15,570
languages normally is get optimized just

00:26:11,520 --> 00:26:18,360
store lesson memory and access it the

00:26:15,570 --> 00:26:20,250
least on the possible time if P in PHP

00:26:18,360 --> 00:26:22,530
case if we're storing these generalized

00:26:20,250 --> 00:26:26,190
data structures so if you try to store a

00:26:22,530 --> 00:26:27,929
list of tau millen integers it takes

00:26:26,190 --> 00:26:30,450
much more space than see wood and

00:26:27,929 --> 00:26:36,780
because it takes much more space it is

00:26:30,450 --> 00:26:41,760
also slower I tried I'd really try to

00:26:36,780 --> 00:26:43,980
implement the eval function in PHP ah I

00:26:41,760 --> 00:26:45,960
couldn't figure out how you did so the

00:26:43,980 --> 00:26:48,750
problem of eval and I guess the reason

00:26:45,960 --> 00:26:50,760
why I know YC doesn't really have evil

00:26:48,750 --> 00:26:51,450
I'm sure that it's a white I did but wyd

00:26:50,760 --> 00:26:53,220
see buddy

00:26:51,450 --> 00:26:55,860
other than I vivo because evil requires

00:26:53,220 --> 00:26:58,620
us to run through the same three steps

00:26:55,860 --> 00:27:01,769
at execution time so now we have to ship

00:26:58,620 --> 00:27:03,870
our source code different with a living

00:27:01,769 --> 00:27:07,590
person in a living compiler inside of it

00:27:03,870 --> 00:27:09,600
so again we can't generate a slimmed

00:27:07,590 --> 00:27:12,299
down version of our execution if we have

00:27:09,600 --> 00:27:13,769
also ship a parcel in peach PK it's not

00:27:12,299 --> 00:27:16,200
a big deal because we're not shipping

00:27:13,769 --> 00:27:17,909
actually compiled HP but in C code we

00:27:16,200 --> 00:27:21,539
can't just ship an executable which also

00:27:17,909 --> 00:27:24,570
contains all the sea toolkit just able

00:27:21,539 --> 00:27:27,090
to compile things run them so when it

00:27:24,570 --> 00:27:29,789
comes to things like eval if you want to

00:27:27,090 --> 00:27:33,659
support them you give up a lot of extra

00:27:29,789 --> 00:27:35,399
performance I think these always crazy

00:27:33,659 --> 00:27:37,889
dynamic features all these things like

00:27:35,399 --> 00:27:42,600
magic access and all these crazy things

00:27:37,889 --> 00:27:45,210
they work fast ish but they are never as

00:27:42,600 --> 00:27:48,690
fast as direct access because on every

00:27:45,210 --> 00:27:50,580
access or like every command HP runs it

00:27:48,690 --> 00:27:53,909
keeps having to figure out what exactly

00:27:50,580 --> 00:27:56,580
are you doing so the less of them you

00:27:53,909 --> 00:27:58,789
use and the less of them programming

00:27:56,580 --> 00:28:02,250
languages have the faster it can become

00:27:58,789 --> 00:28:05,190
so for example JavaScript computer who

00:28:02,250 --> 00:28:08,240
had this thing called assembler GS which

00:28:05,190 --> 00:28:10,919
is just a subset of a set of JavaScript

00:28:08,240 --> 00:28:13,769
removing all the slow parts so kind of

00:28:10,919 --> 00:28:16,830
removing everything else before somebody

00:28:13,769 --> 00:28:18,990
is they removed all the dynamic crazy

00:28:16,830 --> 00:28:20,519
thing called things which is still thing

00:28:18,990 --> 00:28:22,110
is just all the JavaScript but we

00:28:20,519 --> 00:28:24,929
removed all of it and they can compile

00:28:22,110 --> 00:28:28,500
it and B&BS fastest see super

00:28:24,929 --> 00:28:31,620
interesting so how do we achieve that

00:28:28,500 --> 00:28:33,059
like I talked about specializing code we

00:28:31,620 --> 00:28:35,190
can only do so much to optimize our

00:28:33,059 --> 00:28:38,100
source code by parsing it cleverly or

00:28:35,190 --> 00:28:40,049
like by storing some crazy caches we

00:28:38,100 --> 00:28:43,320
can't really do so much so how we can

00:28:40,049 --> 00:28:45,809
specialize it and still use dynamic

00:28:43,320 --> 00:28:48,230
functionality well it's called jet

00:28:45,809 --> 00:28:50,370
everyone had anyone has seen mr. before

00:28:48,230 --> 00:28:53,610
yes so most people have heard of it

00:28:50,370 --> 00:28:56,340
before I guess in PHP it was made famous

00:28:53,610 --> 00:28:58,019
the most by Facebook and their HH vm

00:28:56,340 --> 00:29:01,139
implementation it's been used in other

00:28:58,019 --> 00:29:04,890
languages in other environments what

00:29:01,139 --> 00:29:08,310
does get me what it means that in so

00:29:04,890 --> 00:29:11,790
love our specializing code ahead of time

00:29:08,310 --> 00:29:13,800
instead of us coming up with these great

00:29:11,790 --> 00:29:16,290
data structures instead of coming up

00:29:13,800 --> 00:29:19,890
with fast code paths we just let the

00:29:16,290 --> 00:29:22,230
code run and then as it's running you're

00:29:19,890 --> 00:29:24,150
collecting statistical information and

00:29:22,230 --> 00:29:26,400
when we're using that to recompile the

00:29:24,150 --> 00:29:28,770
code at runtime and you might be

00:29:26,400 --> 00:29:31,470
thinking oh so you're recompiling the

00:29:28,770 --> 00:29:33,120
college is running that sounds slow it's

00:29:31,470 --> 00:29:34,980
actually not as slow because we let the

00:29:33,120 --> 00:29:37,350
code run for a thousand times they

00:29:34,980 --> 00:29:40,800
figure out that the parts of code we can

00:29:37,350 --> 00:29:42,930
really optimize and then we compile them

00:29:40,800 --> 00:29:45,210
in to optimize versions of them and then

00:29:42,930 --> 00:29:47,730
we replace them so if you if you imagine

00:29:45,210 --> 00:29:50,400
the website if you leave it running for

00:29:47,730 --> 00:29:52,260
a week a day in it's faster then it

00:29:50,400 --> 00:29:54,330
becomes faster faster and faster in

00:29:52,260 --> 00:29:56,310
touch as it runs until it reaches the

00:29:54,330 --> 00:29:57,840
maximum point again depends on how

00:29:56,310 --> 00:30:00,900
source code is different things involved

00:29:57,840 --> 00:30:03,390
and that's what allows dynamic languages

00:30:00,900 --> 00:30:05,790
to be really fast nowadays is that we

00:30:03,390 --> 00:30:08,280
can optimize them on execution and

00:30:05,790 --> 00:30:10,230
that's like I'm like I think it's the

00:30:08,280 --> 00:30:12,480
right way to do things for most people

00:30:10,230 --> 00:30:15,000
because I don't have to think ahead of

00:30:12,480 --> 00:30:17,460
time how I can tweak this data searcher

00:30:15,000 --> 00:30:20,310
how can tweak miss this call tov I write

00:30:17,460 --> 00:30:22,560
my code as fast as i can and i left the

00:30:20,310 --> 00:30:25,080
compiler to figure out these sort of

00:30:22,560 --> 00:30:26,790
things so PHP doesn't you p core

00:30:25,080 --> 00:30:28,320
itself doesn't use that yet but i'm

00:30:26,790 --> 00:30:32,130
showing that in the future we might see

00:30:28,320 --> 00:30:38,040
it so it gets used in practice in this

00:30:32,130 --> 00:30:42,210
way so here's here's a piece of the PHP

00:30:38,040 --> 00:30:44,730
bench file and the thing it's testing is

00:30:42,210 --> 00:30:49,080
both loops and then accessing variables

00:30:44,730 --> 00:30:51,450
multiple times so the question is can

00:30:49,080 --> 00:30:53,700
you optimize the source code in any way

00:30:51,450 --> 00:30:58,110
like is there anything you can do to

00:30:53,700 --> 00:31:00,600
make this faster outside of rewriting it

00:30:58,110 --> 00:31:02,910
in different languages probably not like

00:31:00,600 --> 00:31:05,610
this I mean I don't see any performance

00:31:02,910 --> 00:31:06,900
drains I mean you can probably do some

00:31:05,610 --> 00:31:08,460
micro optimizations make a variable

00:31:06,900 --> 00:31:11,250
shorter that's going to make things

00:31:08,460 --> 00:31:13,110
faster but outside of it there's nothing

00:31:11,250 --> 00:31:17,820
you can do like that's as SAS is going

00:31:13,110 --> 00:31:20,050
to get but if we run this code

00:31:17,820 --> 00:31:23,830
we're very easily and very quickly

00:31:20,050 --> 00:31:25,870
realize all these numbers are integers

00:31:23,830 --> 00:31:29,320
and all these variables are integers as

00:31:25,870 --> 00:31:31,210
well so we don't have to check of them

00:31:29,320 --> 00:31:34,240
being integers when we have to check is

00:31:31,210 --> 00:31:36,010
this variable less than a melon we don't

00:31:34,240 --> 00:31:40,450
have to check arbys both integers and

00:31:36,010 --> 00:31:42,610
like do this crazy type manipulations we

00:31:40,450 --> 00:31:43,960
could just trust them to be integers so

00:31:42,610 --> 00:31:47,380
we let them for a run for a thousand

00:31:43,960 --> 00:31:51,220
times and then we compile it by figure

00:31:47,380 --> 00:31:56,290
our hot lips a concept of a hot loop is

00:31:51,220 --> 00:31:59,500
that we detect parts of code which a get

00:31:56,290 --> 00:32:01,960
called a lot so it gets called so many

00:31:59,500 --> 00:32:04,420
times that we know if statistical

00:32:01,960 --> 00:32:06,520
significance they don't change that the

00:32:04,420 --> 00:32:08,590
path is always the same so if it comes

00:32:06,520 --> 00:32:10,570
to an if statement we know that it's

00:32:08,590 --> 00:32:11,980
always the true branch so we can

00:32:10,570 --> 00:32:13,480
actually just ignore the else branch

00:32:11,980 --> 00:32:15,700
altogether because it's never actually

00:32:13,480 --> 00:32:17,740
getting cold also we can figure out the

00:32:15,700 --> 00:32:20,320
variable types because we know it's

00:32:17,740 --> 00:32:21,940
always an integer we checked it now we

00:32:20,320 --> 00:32:26,440
can just remove all the checks for

00:32:21,940 --> 00:32:28,590
variable types and just let it run as if

00:32:26,440 --> 00:32:30,910
everything is an integer and of course

00:32:28,590 --> 00:32:33,610
with dynamic languages there's still

00:32:30,910 --> 00:32:35,650
some kind of a path from somewhere work

00:32:33,610 --> 00:32:38,110
and maybe college with a string but then

00:32:35,650 --> 00:32:40,030
it will just crash like on running

00:32:38,110 --> 00:32:45,310
recompile it again and then keep running

00:32:40,030 --> 00:32:47,530
anyway so yeah but that's how you make

00:32:45,310 --> 00:32:50,940
that's how we make dynamic languages

00:32:47,530 --> 00:32:53,710
really fast is you can't really optimize

00:32:50,940 --> 00:32:56,080
parsers and interpreters that much which

00:32:53,710 --> 00:32:59,710
there is a boundary but you can optimize

00:32:56,080 --> 00:33:02,890
data structures really well and that's

00:32:59,710 --> 00:33:06,520
what made pie HP very fast as well is

00:33:02,890 --> 00:33:10,360
that it uses jit so when it came to PI

00:33:06,520 --> 00:33:13,360
HP which is like an assault python it's

00:33:10,360 --> 00:33:16,180
actually uses this this open source

00:33:13,360 --> 00:33:18,370
project from Python world called PI pi

00:33:16,180 --> 00:33:21,010
so pi python he also has a similar

00:33:18,370 --> 00:33:23,320
problem where python is actually a very

00:33:21,010 --> 00:33:26,200
slow language so they try to fix that by

00:33:23,320 --> 00:33:28,660
creating a competing compiler called pi

00:33:26,200 --> 00:33:29,290
PI and the same way Facebook did that

00:33:28,660 --> 00:33:32,890
with

00:33:29,290 --> 00:33:35,500
um so they build pipe i and and and

00:33:32,890 --> 00:33:37,480
build together of that a subset of

00:33:35,500 --> 00:33:40,600
Python called our Python which you can

00:33:37,480 --> 00:33:42,520
use to build interpreters and that's

00:33:40,600 --> 00:33:44,590
what they used and because it comes to

00:33:42,520 --> 00:33:46,870
all these tools for me to enable jit it

00:33:44,590 --> 00:33:49,330
was just a bunch of change of lines I

00:33:46,870 --> 00:33:52,210
change them it works and because it's

00:33:49,330 --> 00:33:53,650
still all Python it's unit tested and if

00:33:52,210 --> 00:33:55,450
you can run it as a normal Python

00:33:53,650 --> 00:33:57,340
program and just it works I think it's a

00:33:55,450 --> 00:34:01,000
total of a couple of thousand lines so

00:33:57,340 --> 00:34:02,680
it's super easy to read and if you want

00:34:01,000 --> 00:34:04,600
to make it fast then you just run from

00:34:02,680 --> 00:34:07,380
this our Python compiler stage it

00:34:04,600 --> 00:34:10,419
generates a task executable menu use it

00:34:07,380 --> 00:34:13,210
so you might be thinking why on earth

00:34:10,419 --> 00:34:15,220
would you do this which is right a right

00:34:13,210 --> 00:34:17,020
thing to ask are you should you should

00:34:15,220 --> 00:34:18,550
definitely know do it but it did it

00:34:17,020 --> 00:34:21,010
because I realized well if I want to

00:34:18,550 --> 00:34:23,380
look at the PHP internals there's no way

00:34:21,010 --> 00:34:26,110
I can figure the figure things out that

00:34:23,380 --> 00:34:29,169
quickly so when it comes to execution

00:34:26,110 --> 00:34:31,179
loops like yes now have found that loop

00:34:29,169 --> 00:34:33,429
in PHP and I can kind of see how it

00:34:31,179 --> 00:34:35,830
works but if you just look at it like

00:34:33,429 --> 00:34:37,450
it's just too much like now I've had

00:34:35,830 --> 00:34:40,900
people like ask me like also how this

00:34:37,450 --> 00:34:43,600
PHP do like comparisons from a string to

00:34:40,900 --> 00:34:45,250
float and I kind of I delve in into the

00:34:43,600 --> 00:34:46,960
source code of PHP and I looked at the C

00:34:45,250 --> 00:34:49,390
code and all the thousands of lines and

00:34:46,960 --> 00:34:51,910
it kind of makes sense now but to start

00:34:49,390 --> 00:34:53,290
and just go all deep in just didn't feel

00:34:51,910 --> 00:34:56,530
like something I want to do at my free

00:34:53,290 --> 00:34:59,350
time so that's what I did instead so it

00:34:56,530 --> 00:35:01,570
was super easy to write it in Python and

00:34:59,350 --> 00:35:04,780
it still did all the things I want to do

00:35:01,570 --> 00:35:07,420
and now I can actually prototype any PHP

00:35:04,780 --> 00:35:08,620
feature any PHP feature in a matter of

00:35:07,420 --> 00:35:11,530
minutes so when it comes to adding

00:35:08,620 --> 00:35:14,050
unicode support i just change all the

00:35:11,530 --> 00:35:16,540
strange to be unicode in my Python level

00:35:14,050 --> 00:35:18,100
and also in PHP became Unicode and when

00:35:16,540 --> 00:35:20,260
it came to adding output buffering I

00:35:18,100 --> 00:35:22,420
just added this variable where I'm

00:35:20,260 --> 00:35:25,870
storing out but as a string and then

00:35:22,420 --> 00:35:28,890
that's it like that's what these tools

00:35:25,870 --> 00:35:32,560
allow you to do so if you want to try it

00:35:28,890 --> 00:35:35,620
yourself there's a few things so first

00:35:32,560 --> 00:35:37,770
of all there's a PHP interpreter written

00:35:35,620 --> 00:35:41,940
in PHP which is

00:35:37,770 --> 00:35:43,530
which is the fun one if so if you want

00:35:41,940 --> 00:35:45,030
to play around the interpreters if you

00:35:43,530 --> 00:35:49,830
look at how they work and if you want to

00:35:45,030 --> 00:35:52,440
try them yourself PHP PHP is the one to

00:35:49,830 --> 00:35:54,570
use um again it does all the things you

00:35:52,440 --> 00:35:56,190
expect it to do you can implement your

00:35:54,570 --> 00:35:58,890
own features you can replace that dollar

00:35:56,190 --> 00:36:02,610
sign of a pound sign and run it and it's

00:35:58,890 --> 00:36:05,630
super easy to do that if you want to try

00:36:02,610 --> 00:36:10,400
a Python version of that which is

00:36:05,630 --> 00:36:13,350
similar to the PHP PHP one just faster

00:36:10,400 --> 00:36:15,870
you can do that as well it's all give as

00:36:13,350 --> 00:36:20,220
well if you want to use any of this for

00:36:15,870 --> 00:36:25,130
production are HTTP m of course it's a

00:36:20,220 --> 00:36:28,380
tool to use HTM is a stable jet

00:36:25,130 --> 00:36:30,240
interpreter built by Facebook so if you

00:36:28,380 --> 00:36:33,630
have production loads and origin

00:36:30,240 --> 00:36:36,630
experiment with JIT compilers HTM is we

00:36:33,630 --> 00:36:43,140
want to use again everything everything

00:36:36,630 --> 00:36:49,110
is on on github yes there's one more

00:36:43,140 --> 00:36:55,710
thing so I talked I talked about the

00:36:49,110 --> 00:36:56,850
fact that our VM is is the last step

00:36:55,710 --> 00:37:01,350
which does the actual machine

00:36:56,850 --> 00:37:03,360
translation so pinter PHP core is

00:37:01,350 --> 00:37:06,630
written in C that's the part which does

00:37:03,360 --> 00:37:09,630
the actual posts to the system level my

00:37:06,630 --> 00:37:12,780
thing is written in Python that's a part

00:37:09,630 --> 00:37:14,910
which does the machine calls so you

00:37:12,780 --> 00:37:17,340
might be saying so where you can push it

00:37:14,910 --> 00:37:22,950
more like what more crazy things you can

00:37:17,340 --> 00:37:25,530
build that well since our vm can be

00:37:22,950 --> 00:37:29,480
built in anything it should be built in

00:37:25,530 --> 00:37:29,480
anything so

00:37:30,309 --> 00:37:39,740
I present to you a new revolutionary

00:37:36,440 --> 00:37:43,460
project which is going to change with

00:37:39,740 --> 00:37:47,450
the lines of PHP it's called piyush pjs

00:37:43,460 --> 00:37:49,190
and it is actually a real thing it's not

00:37:47,450 --> 00:37:53,660
like it's not just a slide it's a real

00:37:49,190 --> 00:37:59,240
thing and it works and what it is is

00:37:53,660 --> 00:38:00,950
this so it's a Python compiler brilliant

00:37:59,240 --> 00:38:03,170
Python which when it gets compiled to

00:38:00,950 --> 00:38:06,140
see code then that C code gets

00:38:03,170 --> 00:38:08,059
translated to JavaScript and then you

00:38:06,140 --> 00:38:12,410
take that JavaScript and you Pro it at

00:38:08,059 --> 00:38:14,029
the know Jas runtime and it works you

00:38:12,410 --> 00:38:17,079
can also do it in a browser so you can

00:38:14,029 --> 00:38:19,250
make you can take your PHP application

00:38:17,079 --> 00:38:25,730
and then you can run in the browser and

00:38:19,250 --> 00:38:29,630
and laughs that's how it crashes this is

00:38:25,730 --> 00:38:31,819
like this is how it looks like so that

00:38:29,630 --> 00:38:35,000
thing is that it's a PHP file then I

00:38:31,819 --> 00:38:36,769
have javascript file which is created by

00:38:35,000 --> 00:38:39,740
compiling Python to see to JavaScript

00:38:36,769 --> 00:38:41,569
I'd rather have a node runtime which

00:38:39,740 --> 00:38:45,109
runs the bench file so if you ever run

00:38:41,569 --> 00:38:47,690
bench file that's what you've seen you

00:38:45,109 --> 00:38:49,970
might be wondering why on the ref is

00:38:47,690 --> 00:38:54,259
it's that slow so it takes 24 seconds I

00:38:49,970 --> 00:38:56,119
think PHP seven takes one second it's

00:38:54,259 --> 00:39:00,619
that slow because i have no idea whites

00:38:56,119 --> 00:39:06,200
let slow because the PHP dot V and oj s

00:39:00,619 --> 00:39:08,539
is a 24 megabyte javascript file full of

00:39:06,200 --> 00:39:12,440
numbers and like loops and I have no

00:39:08,539 --> 00:39:16,849
idea how it even works but it works

00:39:12,440 --> 00:39:18,200
actually so it runs any any any pipe HP

00:39:16,849 --> 00:39:21,259
you want any pastries worry about life

00:39:18,200 --> 00:39:24,049
and and kind of jokingly and

00:39:21,259 --> 00:39:27,890
realistically though a neat thing about

00:39:24,049 --> 00:39:31,400
this anything about pie HP judge as is

00:39:27,890 --> 00:39:34,369
there is two things first thing it's not

00:39:31,400 --> 00:39:36,740
it's not translating your PHP code to

00:39:34,369 --> 00:39:38,630
JavaScript it's like it's not trying to

00:39:36,740 --> 00:39:42,559
replicate a PHP functionality in

00:39:38,630 --> 00:39:44,120
JavaScript it's an actual PHP vm running

00:39:42,559 --> 00:39:45,770
as a chance with implement

00:39:44,120 --> 00:39:49,580
so it does it sound output buffering

00:39:45,770 --> 00:39:52,280
does its own I oh it does its own access

00:39:49,580 --> 00:39:55,130
to memory all of it is implemented in

00:39:52,280 --> 00:39:57,170
JavaScript which means and that's the

00:39:55,130 --> 00:40:03,140
second part you could use similar tools

00:39:57,170 --> 00:40:04,460
like that in the future to run PHP in

00:40:03,140 --> 00:40:07,120
any environment which supports

00:40:04,460 --> 00:40:10,790
javascript like recently my mozilla

00:40:07,120 --> 00:40:13,940
build Firefox OS which used apps build

00:40:10,790 --> 00:40:16,100
with javascript and HTML and you could

00:40:13,940 --> 00:40:17,810
use that to run PHP on it on your phone

00:40:16,100 --> 00:40:19,220
and I think once they saw let me give

00:40:17,810 --> 00:40:22,670
this talk we just recently shut down

00:40:19,220 --> 00:40:26,600
Firefox OS because we're like Rita 1pg

00:40:22,670 --> 00:40:28,910
on the on the phone and then recently I

00:40:26,600 --> 00:40:31,220
also learned that my sequel no has Jason

00:40:28,910 --> 00:40:33,110
support and I'm pretty sure they are not

00:40:31,220 --> 00:40:35,510
willing to admit that but soon enough

00:40:33,110 --> 00:40:38,030
you'll be able to run JavaScript as

00:40:35,510 --> 00:40:44,030
MapReduce for example for your my sequel

00:40:38,030 --> 00:40:46,940
data I can't wait for the day when I'll

00:40:44,030 --> 00:40:48,950
be able to run my symphony app inside of

00:40:46,940 --> 00:40:51,200
my sequel and then use my sequel as data

00:40:48,950 --> 00:40:55,160
storage that's like the ultimate web

00:40:51,200 --> 00:40:57,230
scale and this actually idea comes from

00:40:55,160 --> 00:40:59,660
this talk of salt which is much better

00:40:57,230 --> 00:41:01,850
than the talk you just saw actually by a

00:40:59,660 --> 00:41:05,120
lot it's it's called the birth and death

00:41:01,850 --> 00:41:08,000
of JavaScript and this super funny guy

00:41:05,120 --> 00:41:09,400
destroy all software com talks about the

00:41:08,000 --> 00:41:12,350
future of JavaScript and the fact that

00:41:09,400 --> 00:41:15,020
since we have now these crazy smart

00:41:12,350 --> 00:41:17,480
compilers which can compile any C code

00:41:15,020 --> 00:41:19,730
to JavaScript you can run things like

00:41:17,480 --> 00:41:21,980
Firefox instead of chrome instead of

00:41:19,730 --> 00:41:23,930
Safari because ultimately everything

00:41:21,980 --> 00:41:26,710
boils down to see ultimately everything

00:41:23,930 --> 00:41:29,510
can be bought down the JavaScript

00:41:26,710 --> 00:41:32,120
completely useless yet it proves my

00:41:29,510 --> 00:41:34,580
point that my vm can be written in any

00:41:32,120 --> 00:41:37,790
language because always doing is just

00:41:34,580 --> 00:41:42,620
running a bunch of byte code does anyone

00:41:37,790 --> 00:41:43,730
have any questions yes yeah can we bring

00:41:42,620 --> 00:41:47,060
the mic stand because it's better if

00:41:43,730 --> 00:41:50,100
it's record if you're if you're going to

00:41:47,060 --> 00:41:53,950
ask does it support laravel now

00:41:50,100 --> 00:41:55,540
no no I wasn't back on the slide you

00:41:53,950 --> 00:41:58,270
gave about the hot loops thing and the

00:41:55,540 --> 00:41:59,620
optimization you said is there any way

00:41:58,270 --> 00:42:01,000
that you can optimize that and looking

00:41:59,620 --> 00:42:02,620
at that I'd argue that there is a very

00:42:01,000 --> 00:42:05,370
obvious way you can optimize it don't

00:42:02,620 --> 00:42:08,320
call it it doesn't actually do anything

00:42:05,370 --> 00:42:10,690
there's no references going into it

00:42:08,320 --> 00:42:12,730
there's no return value so would you

00:42:10,690 --> 00:42:13,960
argue that or you're getting Medvedev

00:42:12,730 --> 00:42:16,660
aguila dinner had a function called

00:42:13,960 --> 00:42:19,060
format functions no as in all the

00:42:16,660 --> 00:42:21,880
function does is it signs variables

00:42:19,060 --> 00:42:24,490
inside the Sun scope increments them and

00:42:21,880 --> 00:42:26,140
then exits yes lieutenant so should a

00:42:24,490 --> 00:42:27,760
compiler optimize that out because it

00:42:26,140 --> 00:42:30,040
actually doesn't do anything or are the

00:42:27,760 --> 00:42:31,960
secondary characteristics like execution

00:42:30,040 --> 00:42:35,650
time in memory use something that a

00:42:31,960 --> 00:42:37,710
compiler should persist I would say the

00:42:35,650 --> 00:42:41,740
smart compilers actually do look at

00:42:37,710 --> 00:42:43,330
unused dead code and I think a good JIT

00:42:41,740 --> 00:42:45,430
compiler would realize the fact that you

00:42:43,330 --> 00:42:47,530
never actually called or in our user

00:42:45,430 --> 00:42:50,710
durable and would actually just never

00:42:47,530 --> 00:42:52,150
call it I'm not sure if mine one does

00:42:50,710 --> 00:42:54,340
i'm not sure that even the facebook does

00:42:52,150 --> 00:42:56,620
work that one but a lot of them do that

00:42:54,340 --> 00:42:59,320
a lot a lot of them do that like even

00:42:56,620 --> 00:43:02,890
even if you go back ten years ago when

00:42:59,320 --> 00:43:05,680
php4 had these opcode optimizers like

00:43:02,890 --> 00:43:07,510
zend optimizer and then x optimized or

00:43:05,680 --> 00:43:09,190
whatever what they would do at a time

00:43:07,510 --> 00:43:10,990
they would do the same thing just on the

00:43:09,190 --> 00:43:12,700
opcode level so it would look at the

00:43:10,990 --> 00:43:14,320
opcode and figure out the paths which

00:43:12,700 --> 00:43:16,990
should never use the magician remove it

00:43:14,320 --> 00:43:19,210
and then optimize your code we should

00:43:16,990 --> 00:43:22,720
did by removing things you're you're a

00:43:19,210 --> 00:43:26,200
hundred percent right yeah but that's

00:43:22,720 --> 00:43:28,630
also like not exactly trivial to

00:43:26,200 --> 00:43:33,550
detecting that code is not exactly true

00:43:28,630 --> 00:43:36,280
though you have to you yeah so I have

00:43:33,550 --> 00:43:39,760
two questions regarding the assembly

00:43:36,280 --> 00:43:41,350
stage is it possible to tell PHP in some

00:43:39,760 --> 00:43:42,490
ways if you like put on your Superman

00:43:41,350 --> 00:43:45,550
robe and think you're smarter than the

00:43:42,490 --> 00:43:48,070
compiler to tell it to maybe unroll

00:43:45,550 --> 00:43:50,140
loops and stuff like that I mean it's

00:43:48,070 --> 00:43:53,530
norm normally a mistake in PHP doesn't

00:43:50,140 --> 00:43:55,780
are all loops yet not yet okay but some

00:43:53,530 --> 00:43:57,850
some compilers do that some of my eyes

00:43:55,780 --> 00:44:00,130
do I know sly mean in some certain cases

00:43:57,850 --> 00:44:01,810
when you really like a dead end and you

00:44:00,130 --> 00:44:02,570
think okay I just need raw speed right

00:44:01,810 --> 00:44:05,660
now and

00:44:02,570 --> 00:44:08,390
I have no way of getting like this code

00:44:05,660 --> 00:44:09,950
better and I know that I mean I had a

00:44:08,390 --> 00:44:11,570
lot of memory so there would be no

00:44:09,950 --> 00:44:14,750
problem in putting like hell of a lot of

00:44:11,570 --> 00:44:17,000
op codes right so he couldn't is so not

00:44:14,750 --> 00:44:18,980
right now not right now okay but it's

00:44:17,000 --> 00:44:21,350
possible and some languages do that what

00:44:18,980 --> 00:44:24,200
he's talking about it's just replacing a

00:44:21,350 --> 00:44:26,600
loop by just replicating the loop as

00:44:24,200 --> 00:44:29,900
many times as we loop runs scroll down

00:44:26,600 --> 00:44:32,090
rolling rooms okay next thing is how

00:44:29,900 --> 00:44:34,880
does like PHP and I mean any compiler

00:44:32,090 --> 00:44:36,950
handle the thing when like dynamic names

00:44:34,880 --> 00:44:39,560
and dynamic typing I mean if you have

00:44:36,950 --> 00:44:42,260
like this long variable name assigned to

00:44:39,560 --> 00:44:44,690
an integer and then suddenly down some

00:44:42,260 --> 00:44:46,430
some some guy have like just assigned a

00:44:44,690 --> 00:44:49,460
whole array to it or anything like that

00:44:46,430 --> 00:44:51,890
so that was how does it work in dynamic

00:44:49,460 --> 00:44:53,300
languages a variable is always boxed so

00:44:51,890 --> 00:44:55,730
it's represented by a bigger data

00:44:53,300 --> 00:44:58,610
structure so your variable is never I

00:44:55,730 --> 00:45:02,000
never actually has an end it has this

00:44:58,610 --> 00:45:04,250
structure in PHP is called Z Val in my

00:45:02,000 --> 00:45:06,260
own it's just an object which contains

00:45:04,250 --> 00:45:09,830
an actual integer so if you decide to

00:45:06,260 --> 00:45:12,620
change that an array the variable stayed

00:45:09,830 --> 00:45:16,910
Zeebo it's just the inside of it now has

00:45:12,620 --> 00:45:19,160
a different like low level type just

00:45:16,910 --> 00:45:21,650
follow-up question to that would you I

00:45:19,160 --> 00:45:24,890
mean if that were to happen is that like

00:45:21,650 --> 00:45:27,860
a I mean is that bad for performance

00:45:24,890 --> 00:45:30,830
like it as I think that's bad for memory

00:45:27,860 --> 00:45:33,890
usage of anything okay because every PHP

00:45:30,830 --> 00:45:35,570
variable takes fifty six bytes some

00:45:33,890 --> 00:45:37,400
amount of bytes which are much larger

00:45:35,570 --> 00:45:39,560
than a single variable would be because

00:45:37,400 --> 00:45:41,030
as evil says or have space for an

00:45:39,560 --> 00:45:42,440
integer I have space for a float I have

00:45:41,030 --> 00:45:45,320
space for a string I have space for all

00:45:42,440 --> 00:45:47,090
these different things and it's only one

00:45:45,320 --> 00:45:48,800
of them actions are being used but

00:45:47,090 --> 00:45:50,690
that's what you need because if I have a

00:45:48,800 --> 00:45:53,930
comparison function the comparison

00:45:50,690 --> 00:45:56,990
function accepts to Z valves unpacks

00:45:53,930 --> 00:45:58,970
them figures out if we compare them so

00:45:56,990 --> 00:46:01,070
it does extreme to flow test you always

00:45:58,970 --> 00:46:03,860
crazy things and then it returns

00:46:01,070 --> 00:46:05,840
whatever float wrapped again in a zero

00:46:03,860 --> 00:46:08,810
but you can't you can't just call you

00:46:05,840 --> 00:46:10,280
can't just build comparison functions

00:46:08,810 --> 00:46:12,380
for all the different matches of types

00:46:10,280 --> 00:46:13,490
and because there's no types it's all

00:46:12,380 --> 00:46:17,090
just packed

00:46:13,490 --> 00:46:19,760
in a box structure I did a did the same

00:46:17,090 --> 00:46:22,340
thing like in my little project every

00:46:19,760 --> 00:46:27,380
variable is represented often if in an

00:46:22,340 --> 00:46:30,260
instance of type durable so as a float

00:46:27,380 --> 00:46:31,580
just extends the terrible class but as

00:46:30,260 --> 00:46:33,320
far as we're kind of the low level is

00:46:31,580 --> 00:46:35,900
concerned with every variable is the

00:46:33,320 --> 00:46:40,250
same type that's what you need basically

00:46:35,900 --> 00:46:42,110
it's just you have the same type there

00:46:40,250 --> 00:46:44,619
is slowish and memory consumption that's

00:46:42,110 --> 00:46:47,590
what page b7 is so much faster because

00:46:44,619 --> 00:46:53,090
eval so meticulous space for most of the

00:46:47,590 --> 00:47:01,700
causes does anyone have any more

00:46:53,090 --> 00:47:03,170
questions yep so very briefly have you

00:47:01,700 --> 00:47:04,700
any idea what you just did to dev ops

00:47:03,170 --> 00:47:06,440
and what are we going to use on april

00:47:04,700 --> 00:47:09,470
first when we can't use the PHP for the

00:47:06,440 --> 00:47:18,560
front end gag anymore just use

00:47:09,470 --> 00:47:21,200
javascript for everything i was just

00:47:18,560 --> 00:47:24,560
going to ask and does the PHP seven

00:47:21,200 --> 00:47:26,750
scalar type hinting help in terms of

00:47:24,560 --> 00:47:29,869
optimizing how it stores variables do

00:47:26,750 --> 00:47:32,390
you know if i'm not mistaken not yet i

00:47:29,869 --> 00:47:34,869
don't think it's you i don't think it's

00:47:32,390 --> 00:47:37,220
used yet for execution right

00:47:34,869 --> 00:47:38,840
optimization it could be used in the

00:47:37,220 --> 00:47:40,880
future I would say I can't see a reason

00:47:38,840 --> 00:47:44,240
why not yeah because that would help a

00:47:40,880 --> 00:47:45,680
lot it doesn't fit in the slide but

00:47:44,240 --> 00:47:47,900
basically any time you access the

00:47:45,680 --> 00:47:49,670
variable in PHP it has to anytime you

00:47:47,900 --> 00:47:53,869
try to compare it or act or do anything

00:47:49,670 --> 00:47:55,430
with it it has to basically loot do an

00:47:53,869 --> 00:47:57,109
if statement and figure out what type is

00:47:55,430 --> 00:47:58,880
it and do all sorts of crazy migration

00:47:57,109 --> 00:48:01,670
so anytime you have a string and you

00:47:58,880 --> 00:48:03,170
compared to an integer yet over again as

00:48:01,670 --> 00:48:05,060
to compare types figure out that they

00:48:03,170 --> 00:48:08,450
don't match loop for this thing trying

00:48:05,060 --> 00:48:10,070
to match a type type matching group so

00:48:08,450 --> 00:48:11,570
there's a caster instance and do all

00:48:10,070 --> 00:48:14,000
these crazy things it seems like that

00:48:11,570 --> 00:48:17,890
would be a really simple performance

00:48:14,000 --> 00:48:17,890
they may you should contribute that

00:48:18,030 --> 00:48:25,890
yes I'm sure it's yeah it's up it sounds

00:48:22,830 --> 00:48:27,870
obvious and simple I don't know why it

00:48:25,890 --> 00:48:31,380
doesn't do that yet I'm sure it's not

00:48:27,870 --> 00:48:33,780
that simple nothing ever is I think

00:48:31,380 --> 00:48:36,810
Paige he also tried to sue as far as I

00:48:33,780 --> 00:48:40,410
know PHP also try to have jet for PHP 7

00:48:36,810 --> 00:48:42,930
but the prototype which is end the thing

00:48:40,410 --> 00:48:45,780
built ended up actually being not that

00:48:42,930 --> 00:48:48,090
fast compared to what PHP had any way

00:48:45,780 --> 00:48:50,400
and introduced so much complexity that

00:48:48,090 --> 00:48:52,530
not adding it in the first place but i

00:48:50,400 --> 00:48:54,390
can't i can't see it being added in the

00:48:52,530 --> 00:48:58,290
future it's just usually for a project

00:48:54,390 --> 00:48:59,820
like as big as PHP core even the simple

00:48:58,290 --> 00:49:01,320
things sometimes take a long time

00:48:59,820 --> 00:49:02,660
because it's so low level and there's

00:49:01,320 --> 00:49:05,190
only so many people who know that stuff

00:49:02,660 --> 00:49:10,110
which I'm not so I don't know I'm just

00:49:05,190 --> 00:49:12,240
talking any more questions I kept

00:49:10,110 --> 00:49:15,690
thinking of you know how you know

00:49:12,240 --> 00:49:18,990
templates generics work so if you have

00:49:15,690 --> 00:49:21,450
like a method the depends on and type

00:49:18,990 --> 00:49:25,230
which is a list of something and that

00:49:21,450 --> 00:49:26,970
something is not defined at you know at

00:49:25,230 --> 00:49:29,760
the template level at the genetic level

00:49:26,970 --> 00:49:33,690
and then if you have something like that

00:49:29,760 --> 00:49:35,310
for the Z val was Eve out that you what

00:49:33,690 --> 00:49:36,690
you need is that you get a list of

00:49:35,310 --> 00:49:38,280
something and you don't know whether

00:49:36,690 --> 00:49:40,220
something is and you can use the other

00:49:38,280 --> 00:49:42,480
field to determine what a few days and

00:49:40,220 --> 00:49:44,220
the worst that can happen is that you

00:49:42,480 --> 00:49:46,050
end up having a list of an integer with

00:49:44,220 --> 00:49:49,110
just an integer inside or a list of an

00:49:46,050 --> 00:49:53,220
that would be maybe something to explore

00:49:49,110 --> 00:49:57,600
for PHP diversion join me to repeat

00:49:53,220 --> 00:50:00,750
yes okay so so if you have like another

00:49:57,600 --> 00:50:02,520
concept of generics or a template so

00:50:00,750 --> 00:50:05,460
imagine that you have a list of

00:50:02,520 --> 00:50:07,800
something yeah as a like abstract type

00:50:05,460 --> 00:50:11,280
and that's something and then your use

00:50:07,800 --> 00:50:13,650
eval with this truck and in intent we

00:50:11,280 --> 00:50:15,900
have the name that the name of the type

00:50:13,650 --> 00:50:18,300
has one field of the struct and the

00:50:15,900 --> 00:50:20,940
other one the value will be a list of

00:50:18,300 --> 00:50:23,850
something yes safe to say the type is an

00:50:20,940 --> 00:50:27,240
integer the value is a list with one

00:50:23,850 --> 00:50:31,380
integer Nina if it's a hash table then

00:50:27,240 --> 00:50:33,509
you can have a list more complex list

00:50:31,380 --> 00:50:35,250
similar to the hash table that we have

00:50:33,509 --> 00:50:39,500
in zend at the moment so that probably

00:50:35,250 --> 00:50:42,089
it would save memory space I'm or not I

00:50:39,500 --> 00:50:43,710
don't even know how it works how you got

00:50:42,089 --> 00:50:48,359
a cat counts for that in the memory I

00:50:43,710 --> 00:50:50,970
have a list of generic no one else I'm

00:50:48,359 --> 00:50:57,950
just sick ok I'll try myself have no

00:50:50,970 --> 00:51:04,200
idea I'll write a compiler Ephixa know

00:50:57,950 --> 00:51:05,849
any more questions ok just a small point

00:51:04,200 --> 00:51:08,009
if anyone wants to try it my little

00:51:05,849 --> 00:51:10,559
thing it comes with a darker file so you

00:51:08,009 --> 00:51:12,890
can you can just run it on any Linux or

00:51:10,559 --> 00:51:15,000
any mac OS or any Windows machine

00:51:12,890 --> 00:51:18,779
because all the dependencies are inside

00:51:15,000 --> 00:51:22,230
of it very cool web just one question on

00:51:18,779 --> 00:51:24,630
what level like in the opcode or below

00:51:22,230 --> 00:51:27,240
would you try implementing something

00:51:24,630 --> 00:51:30,329
like tail call optimization for

00:51:27,240 --> 00:51:35,990
recursion you know instead of increasing

00:51:30,329 --> 00:51:35,990
the stack by frame just going to a label

00:51:37,250 --> 00:51:44,880
discussions on what level so it goes on

00:51:40,079 --> 00:51:48,029
all code level yes in the execution hope

00:51:44,880 --> 00:51:49,799
you will try to figure out that sorry I

00:51:48,029 --> 00:51:54,150
think I think you would divide in the

00:51:49,799 --> 00:51:55,440
execution ok like thanks thing you just

00:51:54,150 --> 00:51:57,089
have to try it like when I took like

00:51:55,440 --> 00:52:00,420
even if the simple things I was like so

00:51:57,089 --> 00:52:03,779
how do i do output buffering which is a

00:52:00,420 --> 00:52:07,410
global variable access by any like any

00:52:03,779 --> 00:52:08,759
context and it's it breaks a lot of

00:52:07,410 --> 00:52:10,950
things so I spent like two weeks trying

00:52:08,759 --> 00:52:13,259
to tell the output buffering but any

00:52:10,950 --> 00:52:15,630
sort of opportunities any sort of these

00:52:13,259 --> 00:52:19,740
global thing concepts or end up being

00:52:15,630 --> 00:52:21,210
pretty complicated or like like even

00:52:19,740 --> 00:52:22,440
things like passing things I've arable

00:52:21,210 --> 00:52:25,349
ended up taking a lot of time because

00:52:22,440 --> 00:52:28,170
passing things by reference yeah so when

00:52:25,349 --> 00:52:29,400
it comes optimizations like you can like

00:52:28,170 --> 00:52:31,880
it's funny thing that you can see like

00:52:29,400 --> 00:52:34,349
PHP actually the core even has a

00:52:31,880 --> 00:52:37,369
basically of folder call optimizations

00:52:34,349 --> 00:52:39,299
as a bunch of these optimizations and

00:52:37,369 --> 00:52:40,740
depending on what sort of optimization

00:52:39,299 --> 00:52:44,060
it is you can either run it on source

00:52:40,740 --> 00:52:46,740
code level on our know sparse

00:52:44,060 --> 00:52:49,890
source code tree you can run it on the

00:52:46,740 --> 00:52:52,050
opcode level it depends on what

00:52:49,890 --> 00:52:55,500
information you want to know about it so

00:52:52,050 --> 00:52:57,869
up codes are more about execution source

00:52:55,500 --> 00:52:59,130
code or more about just the raw of it so

00:52:57,869 --> 00:53:00,960
in the source code stage you don't know

00:52:59,130 --> 00:53:04,020
what's going to be called yet because

00:53:00,960 --> 00:53:06,150
it's just did your source code and all

00:53:04,020 --> 00:53:10,290
of code level you know actual access

00:53:06,150 --> 00:53:12,300
patterns of things optimizers are very

00:53:10,290 --> 00:53:13,890
difficult someone said like writing a

00:53:12,300 --> 00:53:16,140
compiler compared to writing a JIT

00:53:13,890 --> 00:53:19,440
compiler it's like day and night so

00:53:16,140 --> 00:53:21,540
writing or compiler is easy writing a

00:53:19,440 --> 00:53:24,410
JIT compiler is ten times more difficult

00:53:21,540 --> 00:53:28,710
because writing these optimizers on

00:53:24,410 --> 00:53:30,480
arbitrarily source code files is pretty

00:53:28,710 --> 00:53:34,339
damn complicated you have to take into

00:53:30,480 --> 00:53:36,440
account like memory CPU speed and

00:53:34,339 --> 00:53:38,940
compile time and figure out which is

00:53:36,440 --> 00:53:41,970
more valuable which you should do

00:53:38,940 --> 00:53:44,310
instead of doing a number one you can

00:53:41,970 --> 00:53:51,599
probably take one more question just

00:53:44,310 --> 00:53:53,160
enough time for one more have a room is

00:53:51,599 --> 00:53:58,680
trying to compile Java scripts stunned

00:53:53,160 --> 00:54:01,380
faces from the other side what's so it

00:53:58,680 --> 00:54:04,410
like it's nothing it might be your heart

00:54:01,380 --> 00:54:06,329
again so if you have any questions you

00:54:04,410 --> 00:54:09,329
can tweet me or just drop me an email

00:54:06,329 --> 00:54:12,420
even if you have questions about how

00:54:09,329 --> 00:54:14,640
internal is function I will try to

00:54:12,420 --> 00:54:16,530
pretend like i know and i will try to

00:54:14,640 --> 00:54:18,540
help you but that's also like a learning

00:54:16,530 --> 00:54:20,250
experience by like having questions i've

00:54:18,540 --> 00:54:22,440
been trying to figure out how these sort

00:54:20,250 --> 00:54:25,230
of things function it's an interesting

00:54:22,440 --> 00:54:28,140
thing to learn but i hope that you now

00:54:25,230 --> 00:54:31,349
have a better understanding of i guess

00:54:28,140 --> 00:54:33,119
why PHP is not as fast as c code like

00:54:31,349 --> 00:54:36,630
what is the actual reason and why things

00:54:33,119 --> 00:54:40,109
like compilers make it faster and what

00:54:36,630 --> 00:54:42,510
how things like opcode cash do and what

00:54:40,109 --> 00:54:45,810
this factual opcode thing everyone keeps

00:54:42,510 --> 00:54:48,289
talking about that's it that's wonderful

00:54:45,810 --> 00:54:51,779
thank you very much

00:54:48,289 --> 00:54:54,019
and you had to help us I hear teamed up

00:54:51,779 --> 00:54:54,019

YouTube URL: https://www.youtube.com/watch?v=Tm_awZP0vFY


