Title: PHP UK Conference 2016 - Marco Pivetta - Doctrine ORM Good Practices and Tricks
Publication date: 2016-03-16
Playlist: PHP UK Conference 2016
Description: 
	Doctrine ORM is a complex tool that enables development of very advanced applications, but are you actually using it correctly? What if you have been using the ORM incorrectly or in an inefficient way? We are going to inspect the advantages and disadvantages of various approaches to application design with this Data mapper, and come up with a set of best practices that will be useful for your projects.
Captions: 
	00:00:05,170 --> 00:00:10,610
nice to be here first time in London

00:00:08,140 --> 00:00:13,129
nice to be here for a conference I mean

00:00:10,610 --> 00:00:17,060
at least I have something to do I'm

00:00:13,129 --> 00:00:19,370
Marco you may know me as a Premier's on

00:00:17,060 --> 00:00:21,080
the Internet my primary job is annoying

00:00:19,370 --> 00:00:23,930
people on Twitter on reddit and

00:00:21,080 --> 00:00:27,200
everything else as a side job I am a

00:00:23,930 --> 00:00:29,180
software developer this is the avatar

00:00:27,200 --> 00:00:31,550
for those who have more like image

00:00:29,180 --> 00:00:33,710
memory I work for a company called Rove

00:00:31,550 --> 00:00:35,960
we are consultants so we come in your

00:00:33,710 --> 00:00:41,269
company and we either mess it up or fix

00:00:35,960 --> 00:00:44,719
it depends on the roll of the dice I'm

00:00:41,269 --> 00:00:47,269
part of the same framework team and I am

00:00:44,719 --> 00:00:49,699
part of the doctrine team so I'm pretty

00:00:47,269 --> 00:00:53,710
much the guy that you have to blame if

00:00:49,699 --> 00:00:55,850
doctrine is so slow in releases okay so

00:00:53,710 --> 00:00:57,920
we're talking about doctrine project I

00:00:55,850 --> 00:00:59,809
have to introduce the project first we

00:00:57,920 --> 00:01:02,120
are a group of persistence oriented

00:00:59,809 --> 00:01:04,250
projects I want to make this very clear

00:01:02,120 --> 00:01:07,670
because a lot of people like just think

00:01:04,250 --> 00:01:11,600
doctrine and always DRM now it's a lot

00:01:07,670 --> 00:01:13,189
of projects and we pretty much deal with

00:01:11,600 --> 00:01:16,820
everything that has to do with loading

00:01:13,189 --> 00:01:19,280
and saving stuff so we are looking for

00:01:16,820 --> 00:01:21,110
contributors if you think you have some

00:01:19,280 --> 00:01:26,090
experience in loading saving stuff I

00:01:21,110 --> 00:01:28,670
mean has anybody not done it okay

00:01:26,090 --> 00:01:31,100
just poke me you must be prepared to

00:01:28,670 --> 00:01:33,289
take like very unpopular decisions it's

00:01:31,100 --> 00:01:37,130
about saying no rather than just merging

00:01:33,289 --> 00:01:40,369
stuff okay so but feel free to poke me

00:01:37,130 --> 00:01:42,320
and I'll gladly like wiring the team if

00:01:40,369 --> 00:01:45,799
you think you want to help out and be

00:01:42,320 --> 00:01:49,000
useful so we're talking about doctrine

00:01:45,799 --> 00:01:53,119
RM in this talk for how many here use it

00:01:49,000 --> 00:01:56,149
how many do not use it how many totally

00:01:53,119 --> 00:02:01,399
hate it it's perfectly legit ok that's

00:01:56,149 --> 00:02:05,210
fine ok I hate it as well so

00:02:01,399 --> 00:02:08,209
it's a jsr 3:17 which is pretty much

00:02:05,210 --> 00:02:09,560
just like our PSRs kind of except it's

00:02:08,209 --> 00:02:12,769
done by people that know their stuff

00:02:09,560 --> 00:02:14,599
skidding is hibernate inspired so I have

00:02:12,769 --> 00:02:16,670
to mention hibernate because hibernate

00:02:14,599 --> 00:02:20,269
is actually the project we kind of like

00:02:16,670 --> 00:02:22,459
to kai Diaz from and it's a GPL based so

00:02:20,269 --> 00:02:23,840
we have to mention them besides that

00:02:22,459 --> 00:02:29,120
they're awesome they know what they do

00:02:23,840 --> 00:02:30,800
so just cheering them and we are talking

00:02:29,120 --> 00:02:33,349
about best practices specifically so

00:02:30,800 --> 00:02:36,049
best practices this is mostly around I

00:02:33,349 --> 00:02:37,450
realize that but we'll see about that we

00:02:36,049 --> 00:02:40,010
have some good and constructive

00:02:37,450 --> 00:02:43,430
suggestions in here it's not just about

00:02:40,010 --> 00:02:45,610
how not to do it so first of all when

00:02:43,430 --> 00:02:49,970
you start with doctrine you need to know

00:02:45,610 --> 00:02:53,840
the enemy the tool chain that you use

00:02:49,970 --> 00:02:57,049
might actually seem useful but it is

00:02:53,840 --> 00:03:00,079
actually enemy you have to do it so

00:02:57,049 --> 00:03:01,910
don't like throw everything in and hope

00:03:00,079 --> 00:03:04,810
that it will fix problems automatically

00:03:01,910 --> 00:03:08,420
you need to use this thing to actually

00:03:04,810 --> 00:03:11,060
use the toolset and understand what it

00:03:08,420 --> 00:03:13,400
does so first of all just fix that part

00:03:11,060 --> 00:03:16,400
read the documentation please somebody

00:03:13,400 --> 00:03:17,870
may not agree but yeah I think it's kind

00:03:16,400 --> 00:03:21,049
of like the central point where you want

00:03:17,870 --> 00:03:22,940
to start and I'm at fault as for this as

00:03:21,049 --> 00:03:25,040
well I started using doctrine I remember

00:03:22,940 --> 00:03:26,870
I didn't read the documentation I just

00:03:25,040 --> 00:03:29,450
started and use it from some example

00:03:26,870 --> 00:03:31,130
that I saw started using it and then at

00:03:29,450 --> 00:03:34,010
some point I wasn't understanding and

00:03:31,130 --> 00:03:35,750
went into reading the code I mean I took

00:03:34,010 --> 00:03:38,440
a lot of shortcuts that we're actually

00:03:35,750 --> 00:03:41,269
not really shortcuts so please read it

00:03:38,440 --> 00:03:43,340
it's not the nicest documentation but if

00:03:41,269 --> 00:03:46,250
you want to help out again please poke

00:03:43,340 --> 00:03:49,010
me so first of all you need to make sure

00:03:46,250 --> 00:03:52,730
that you are using the or m in the

00:03:49,010 --> 00:03:55,459
appropriate context one thing that I see

00:03:52,730 --> 00:03:57,200
is that people just start a project and

00:03:55,459 --> 00:04:00,049
they say oh it's a symphony project it's

00:03:57,200 --> 00:04:01,940
gonna be like standard like that or it's

00:04:00,049 --> 00:04:06,019
a larval project and going to start and

00:04:01,940 --> 00:04:07,280
use that approach everyone kind of

00:04:06,019 --> 00:04:09,859
misses the point that the project is

00:04:07,280 --> 00:04:12,919
around the business part and it's not

00:04:09,859 --> 00:04:13,850
about doctrine or symphony or larval

00:04:12,919 --> 00:04:15,500
it's about

00:04:13,850 --> 00:04:18,130
what you need to build for the business

00:04:15,500 --> 00:04:22,930
to work so think about that first

00:04:18,130 --> 00:04:25,280
what is doctoring for so first of all

00:04:22,930 --> 00:04:27,920
doctrine is designed around this thing

00:04:25,280 --> 00:04:31,400
this is OLTP online transaction

00:04:27,920 --> 00:04:34,190
processing this means pretty much kind

00:04:31,400 --> 00:04:37,070
of like take the shopping cart add an

00:04:34,190 --> 00:04:39,440
item commit take the shopping cart add

00:04:37,070 --> 00:04:41,710
an item commit that's easy online

00:04:39,440 --> 00:04:45,350
transaction or take the shopping cart

00:04:41,710 --> 00:04:48,200
checkout comment you see it's really

00:04:45,350 --> 00:04:50,420
tiny stuff every time little tiny

00:04:48,200 --> 00:04:53,330
actions and we execute them and that is

00:04:50,420 --> 00:04:56,180
what online transaction processing is it

00:04:53,330 --> 00:05:00,260
allows us to pretty much enable DDD

00:04:56,180 --> 00:05:03,500
concept that is kind of a lie but just

00:05:00,260 --> 00:05:06,410
it kind of enabled you to do some DDD to

00:05:03,500 --> 00:05:08,270
some extent I'm not sure if there were

00:05:06,410 --> 00:05:12,640
any DDD talks I didn't really follow on

00:05:08,270 --> 00:05:14,930
that but you should follow up on that

00:05:12,640 --> 00:05:16,820
there's a great mailing list that you

00:05:14,930 --> 00:05:21,110
should follow if you are interested in

00:05:16,820 --> 00:05:24,140
the topic is DVD in PHP org so just go

00:05:21,110 --> 00:05:25,820
and get subscribe because it's really

00:05:24,140 --> 00:05:27,650
useful you just throw in your problem

00:05:25,820 --> 00:05:29,540
and people start reasoning about it

00:05:27,650 --> 00:05:31,400
which is really good and remember it's

00:05:29,540 --> 00:05:33,200
not about your larval or Symphony or

00:05:31,400 --> 00:05:35,930
same framework or whatever problem

00:05:33,200 --> 00:05:37,940
it's about your business problem okay

00:05:35,930 --> 00:05:40,430
it's a library for fast prototyping this

00:05:37,940 --> 00:05:42,620
means that you start and throw stuff in

00:05:40,430 --> 00:05:44,720
you code your objects you keep going

00:05:42,620 --> 00:05:47,900
with use cases and use cases and the

00:05:44,720 --> 00:05:49,700
database is just a detail so you have to

00:05:47,900 --> 00:05:51,920
deal with this if you have like some

00:05:49,700 --> 00:05:53,720
people telling you this is the database

00:05:51,920 --> 00:05:55,700
and you need to work with it then

00:05:53,720 --> 00:05:59,060
probably doctrine is not the right tool

00:05:55,700 --> 00:06:00,800
already for that okay so I'm already

00:05:59,060 --> 00:06:03,530
excluding a lot of use case that I'm

00:06:00,800 --> 00:06:06,710
fairly sure at least thirty percent in

00:06:03,530 --> 00:06:10,070
here are kind of using repeatedly over

00:06:06,710 --> 00:06:11,660
their job okay just think about it every

00:06:10,070 --> 00:06:14,960
time you have one of those users use

00:06:11,660 --> 00:06:16,490
cases like external database that is

00:06:14,960 --> 00:06:19,310
predefined you probably don't want to

00:06:16,490 --> 00:06:21,140
have doctrine anyway object oriented

00:06:19,310 --> 00:06:24,250
first again if you don't want object

00:06:21,140 --> 00:06:26,090
oriented then don't use it and it's very

00:06:24,250 --> 00:06:28,930
important

00:06:26,090 --> 00:06:31,699
to not use doctrine in a few use cases

00:06:28,930 --> 00:06:34,160
dynamic date structures like kind of

00:06:31,699 --> 00:06:38,870
like MongoDB style you have mixed data

00:06:34,160 --> 00:06:41,990
or Magento who uses Magento who tried to

00:06:38,870 --> 00:06:45,620
map it to the doctrine system Wow at

00:06:41,990 --> 00:06:47,630
least that not but the idea is that you

00:06:45,620 --> 00:06:50,960
don't want to have like these structures

00:06:47,630 --> 00:06:53,630
with entity attribute values or Mixit

00:06:50,960 --> 00:06:55,250
data or data that is no and then is zero

00:06:53,630 --> 00:06:57,410
and then it's a string and there's a

00:06:55,250 --> 00:07:00,380
number changes every time it's about

00:06:57,410 --> 00:07:03,440
being strict about types you want to

00:07:00,380 --> 00:07:05,180
have your clear object structures so you

00:07:03,440 --> 00:07:08,180
have to have very well-defined data

00:07:05,180 --> 00:07:10,180
structure inside your mental model first

00:07:08,180 --> 00:07:13,220
you can't just throw in makes a beta

00:07:10,180 --> 00:07:15,110
it's not for reporting this is where

00:07:13,220 --> 00:07:18,800
pretty much everyone complains always so

00:07:15,110 --> 00:07:21,680
slow okay it's not about reporting there

00:07:18,800 --> 00:07:24,560
is an amazing language that is kind of

00:07:21,680 --> 00:07:26,600
becoming popular they started using it

00:07:24,560 --> 00:07:32,060
some in the recent years somewhere in

00:07:26,600 --> 00:07:35,289
the 70s and it's called SQL okay it is a

00:07:32,060 --> 00:07:37,850
query language so use it for that please

00:07:35,289 --> 00:07:40,970
okay there is SQL for that don't use

00:07:37,850 --> 00:07:42,919
doctrine for that so let's go with some

00:07:40,970 --> 00:07:45,620
more constructive stuff this I realize

00:07:42,919 --> 00:07:48,680
it's kind of like it sad intro set from

00:07:45,620 --> 00:07:51,919
Romania and it is of course we start

00:07:48,680 --> 00:07:54,530
from the entities first thing that needs

00:07:51,919 --> 00:07:56,900
to be clear is that the entities are

00:07:54,530 --> 00:07:59,539
part of how you reason about the problem

00:07:56,900 --> 00:08:02,750
and they're not part of how the or I'm

00:07:59,539 --> 00:08:05,960
reasons about problem so your entities

00:08:02,750 --> 00:08:08,180
first of all work weed out the RM so you

00:08:05,960 --> 00:08:10,669
should code them first make them work

00:08:08,180 --> 00:08:13,490
and doctrine is for now outside your

00:08:10,669 --> 00:08:19,340
problem space it will bring problems and

00:08:13,490 --> 00:08:21,410
later ok you will have trouble but first

00:08:19,340 --> 00:08:24,039
of all start writing without your M in

00:08:21,410 --> 00:08:27,560
mind it should work without the database

00:08:24,039 --> 00:08:30,229
can you design a system that just still

00:08:27,560 --> 00:08:32,539
realizes objects into like a file and DC

00:08:30,229 --> 00:08:35,510
realizes them and makes it work have you

00:08:32,539 --> 00:08:38,240
ever tried that as an exercise you know

00:08:35,510 --> 00:08:39,310
just take your typical blog post article

00:08:38,240 --> 00:08:41,289
whatever

00:08:39,310 --> 00:08:43,330
example and instead of storing it into a

00:08:41,289 --> 00:08:46,690
database table just stir it in a txt

00:08:43,330 --> 00:08:49,420
file as serialize data give it a try can

00:08:46,690 --> 00:08:50,800
you do that does it work if it works

00:08:49,420 --> 00:08:52,900
then maybe it's okay

00:08:50,800 --> 00:08:55,779
if it doesn't then it means that you're

00:08:52,900 --> 00:08:57,970
already coupling with the database might

00:08:55,779 --> 00:09:00,610
be a choice but then you probably are

00:08:57,970 --> 00:09:04,390
designing it not the way you should use

00:09:00,610 --> 00:09:06,960
this tool and it is mostly represent

00:09:04,390 --> 00:09:10,750
your domain so you are talking about

00:09:06,960 --> 00:09:12,600
concepts inside the problem space of

00:09:10,750 --> 00:09:15,670
your business

00:09:12,600 --> 00:09:17,110
whereas the RM and the database are just

00:09:15,670 --> 00:09:19,360
for low V loading and saving stuff

00:09:17,110 --> 00:09:21,520
they're not important okay

00:09:19,360 --> 00:09:23,380
everyone just starts designing tables

00:09:21,520 --> 00:09:25,960
and stuff like that you should instead

00:09:23,380 --> 00:09:27,970
design the entities first you start

00:09:25,960 --> 00:09:31,089
designing these problems how they

00:09:27,970 --> 00:09:33,640
interact with each other okay and then

00:09:31,089 --> 00:09:35,890
the database comes after so the database

00:09:33,640 --> 00:09:37,420
is actually a side effect of having

00:09:35,890 --> 00:09:39,940
these problems you design the problem

00:09:37,420 --> 00:09:43,390
and then the solution comes after that

00:09:39,940 --> 00:09:47,410
kind of automatically which is again a

00:09:43,390 --> 00:09:48,790
false promise but all right which means

00:09:47,410 --> 00:09:50,560
that also the mapping stuff like

00:09:48,790 --> 00:09:52,300
annotations and all the stuff depending

00:09:50,560 --> 00:09:54,970
whether you want to use annotation it's

00:09:52,300 --> 00:09:58,810
ml or I don't know Yolo you

00:09:54,970 --> 00:10:02,140
yamo whatever you should pretty much

00:09:58,810 --> 00:10:04,900
design the mappings after that let's

00:10:02,140 --> 00:10:08,260
start with designing some entities this

00:10:04,900 --> 00:10:11,730
is pretty much a family ER right so who

00:10:08,260 --> 00:10:16,810
writes this kind of entity yeah yeah

00:10:11,730 --> 00:10:18,850
right don't okay this is pretty much a

00:10:16,810 --> 00:10:22,420
user object user name/password set

00:10:18,850 --> 00:10:26,470
username get user name get password set

00:10:22,420 --> 00:10:29,260
password PHP seven's type hints fancy

00:10:26,470 --> 00:10:31,480
stuff but this is not really useful this

00:10:29,260 --> 00:10:34,750
is an array with type ends there's

00:10:31,480 --> 00:10:37,920
nothing useful in this and these are not

00:10:34,750 --> 00:10:40,480
typed arrays that is what a record is a

00:10:37,920 --> 00:10:43,630
record doesn't have an interaction with

00:10:40,480 --> 00:10:45,580
the real world it's just data and entity

00:10:43,630 --> 00:10:50,520
instead is a representation of the

00:10:45,580 --> 00:10:53,140
problem inside your business kind of so

00:10:50,520 --> 00:10:55,329
entities instead have it behavior

00:10:53,140 --> 00:10:57,070
so you want to go into the

00:10:55,329 --> 00:10:58,720
object-oriented API you have to think

00:10:57,070 --> 00:11:01,779
about how objects talk to each other

00:10:58,720 --> 00:11:03,250
instead of what the objects contain so

00:11:01,779 --> 00:11:05,860
instead of saying and thinking about the

00:11:03,250 --> 00:11:09,720
problem what does the user contain you

00:11:05,860 --> 00:11:13,209
can think about a problem such as like

00:11:09,720 --> 00:11:16,120
can the user tell me his username okay

00:11:13,209 --> 00:11:18,510
you just turn it into like things that

00:11:16,120 --> 00:11:21,700
you can ask to objects rather than

00:11:18,510 --> 00:11:23,380
things that you can actually store in

00:11:21,700 --> 00:11:24,610
objects you don't think about the state

00:11:23,380 --> 00:11:26,560
you think about the interactions that

00:11:24,610 --> 00:11:28,839
you can have with them it's just a bit

00:11:26,560 --> 00:11:32,529
of a shift in how you think about the

00:11:28,839 --> 00:11:35,079
API how the internal state is designed

00:11:32,529 --> 00:11:36,790
is irrelevant and if you actually start

00:11:35,079 --> 00:11:39,160
designing internal state you are going

00:11:36,790 --> 00:11:42,430
to have a lot of hidden coupling inside

00:11:39,160 --> 00:11:43,870
your objects which is just kind of

00:11:42,430 --> 00:11:47,560
coming in causing some problems later

00:11:43,870 --> 00:11:49,720
and we'll see that so you can design any

00:11:47,560 --> 00:11:52,240
state after that you can think of it as

00:11:49,720 --> 00:11:54,970
like writing public methods that are

00:11:52,240 --> 00:11:57,750
empty that don't do anything and then

00:11:54,970 --> 00:12:00,579
writing the tests the tests fail and

00:11:57,750 --> 00:12:02,529
after you make the tests pass you have

00:12:00,579 --> 00:12:04,480
defined how the data is saved inside

00:12:02,529 --> 00:12:09,610
your objects so you can move the data

00:12:04,480 --> 00:12:11,079
around however you prefer yeah it leads

00:12:09,610 --> 00:12:13,660
to terrible coupling if you start

00:12:11,079 --> 00:12:15,550
thinking of your entities as records you

00:12:13,660 --> 00:12:18,790
are going to be frozen into this mindset

00:12:15,550 --> 00:12:21,370
of the database kind of you kind of

00:12:18,790 --> 00:12:23,140
oriented API you can move things around

00:12:21,370 --> 00:12:25,120
you can decouple it you can move things

00:12:23,140 --> 00:12:27,070
around it's not a big deal so here's a

00:12:25,120 --> 00:12:29,500
better example of the user object so a

00:12:27,070 --> 00:12:31,690
user object has some state we're going

00:12:29,500 --> 00:12:33,250
to skip on that then here's an

00:12:31,690 --> 00:12:35,470
interesting one this is a good

00:12:33,250 --> 00:12:38,529
suggestion I would say we have a to

00:12:35,470 --> 00:12:41,230
nickname now to nickname is not really

00:12:38,529 --> 00:12:43,959
different from cat nickname or get user

00:12:41,230 --> 00:12:46,060
name but the idea is that I'm not

00:12:43,959 --> 00:12:48,370
getting some state we are transforming

00:12:46,060 --> 00:12:50,560
the object into something else so as you

00:12:48,370 --> 00:12:52,390
could call it a cast in that case it's

00:12:50,560 --> 00:12:54,579
more of a psychological thing rather

00:12:52,390 --> 00:12:56,920
than I actually changing the API we're

00:12:54,579 --> 00:12:58,240
still getting some state practically but

00:12:56,920 --> 00:13:00,100
firmly outside it doesn't look like

00:12:58,240 --> 00:13:02,500
we're getting some state we're

00:13:00,100 --> 00:13:04,329
transforming it in something else we

00:13:02,500 --> 00:13:05,770
have an authentication method so we can

00:13:04,329 --> 00:13:06,820
authenticate with the password that

00:13:05,770 --> 00:13:09,240
callable which is

00:13:06,820 --> 00:13:11,760
maybe some password hash compatible API

00:13:09,240 --> 00:13:14,530
and then we have a change password

00:13:11,760 --> 00:13:16,660
change password which does rehash the

00:13:14,530 --> 00:13:19,450
password with some callable which again

00:13:16,660 --> 00:13:22,060
hashes the password so this is kind of a

00:13:19,450 --> 00:13:24,100
way to you see we're avoiding setting

00:13:22,060 --> 00:13:26,710
things we're telling the object what to

00:13:24,100 --> 00:13:28,330
do and the object may even reject these

00:13:26,710 --> 00:13:30,670
interactions we may just say you know

00:13:28,330 --> 00:13:34,180
your data is not good just for an

00:13:30,670 --> 00:13:36,580
exception if you don't need any behavior

00:13:34,180 --> 00:13:40,180
if you don't have any behavior you don't

00:13:36,580 --> 00:13:41,800
need an RM it's most probably just going

00:13:40,180 --> 00:13:46,630
to cause you more problems than what

00:13:41,800 --> 00:13:48,400
you're solving okay so respect the law

00:13:46,630 --> 00:13:50,440
of Demeter anybody familiar with the law

00:13:48,400 --> 00:13:54,550
well anybody not familiar with the law

00:13:50,440 --> 00:13:59,920
of Demeter no not shy not problem okay

00:13:54,550 --> 00:14:02,560
so the law of Demeter is I I prefer

00:13:59,920 --> 00:14:04,810
explaining it with the game there is

00:14:02,560 --> 00:14:07,780
this game which I don't know the name in

00:14:04,810 --> 00:14:10,120
English to be honest you do it in

00:14:07,780 --> 00:14:11,950
kindergarten well when you're a kid you

00:14:10,120 --> 00:14:13,990
say word to the next person and the next

00:14:11,950 --> 00:14:16,630
person says it to be another person and

00:14:13,990 --> 00:14:19,750
so on and so on and you throw in Lion on

00:14:16,630 --> 00:14:22,770
one side and snake comes on comes out

00:14:19,750 --> 00:14:25,090
and yet completely other side sorry

00:14:22,770 --> 00:14:28,780
Chinese whispers oh thank you I'm gonna

00:14:25,090 --> 00:14:30,820
write it down that is what the law of

00:14:28,780 --> 00:14:33,040
Demeter is about so instead of like

00:14:30,820 --> 00:14:36,430
having these big chains of things like

00:14:33,040 --> 00:14:38,260
that you call you avoid that and you

00:14:36,430 --> 00:14:41,560
just talk to your direct neighbor and

00:14:38,260 --> 00:14:44,350
that's it okay otherwise you get all

00:14:41,560 --> 00:14:46,810
these chain calls which I don't know if

00:14:44,350 --> 00:14:49,780
it was Marik here did you call it a

00:14:46,810 --> 00:14:51,490
train wreck I don't remember but yeah

00:14:49,780 --> 00:14:53,040
chained calls if you look at them it

00:14:51,490 --> 00:14:56,380
looks exactly like a train wreck

00:14:53,040 --> 00:14:58,930
it's if China is so here we have an

00:14:56,380 --> 00:15:01,570
example it's kind of subtle but here's

00:14:58,930 --> 00:15:03,340
what we have we have a user so we coded

00:15:01,570 --> 00:15:06,010
the interaction so we have a method

00:15:03,340 --> 00:15:07,570
which is has access to so this user

00:15:06,010 --> 00:15:11,290
pretty much allows us to check a

00:15:07,570 --> 00:15:15,210
resource for access control so what we

00:15:11,290 --> 00:15:17,950
do is we filter all the access levels

00:15:15,210 --> 00:15:19,340
accessible to the role that is assigned

00:15:17,950 --> 00:15:22,160
to this user

00:15:19,340 --> 00:15:24,710
then we check whether that particular

00:15:22,160 --> 00:15:28,310
access level guarantees me access to

00:15:24,710 --> 00:15:30,290
that resource so this is Mic Check so

00:15:28,310 --> 00:15:33,320
what I'm doing here is I'm traversing

00:15:30,290 --> 00:15:35,780
the graph I'm jumping one time to roll

00:15:33,320 --> 00:15:37,700
and then I'm jumping another time and

00:15:35,780 --> 00:15:39,620
get the access levels and then I assume

00:15:37,700 --> 00:15:43,340
the access levels are in a particular

00:15:39,620 --> 00:15:45,860
data structure that I know and then for

00:15:43,340 --> 00:15:48,800
every access level I'm assuming I'm

00:15:45,860 --> 00:15:51,710
going to execute an operation so this is

00:15:48,800 --> 00:15:53,720
a typical diamond limiter violation it's

00:15:51,710 --> 00:15:56,750
a bit hidden but you should just stop

00:15:53,720 --> 00:15:59,690
here you should have stopped here so you

00:15:56,750 --> 00:16:03,260
can just refactor it out and you change

00:15:59,690 --> 00:16:05,360
it like that so your role now has the

00:16:03,260 --> 00:16:08,990
responsibility of telling whether your

00:16:05,360 --> 00:16:11,240
user has access or not so this is just

00:16:08,990 --> 00:16:15,290
one suggestion but it makes it so much

00:16:11,240 --> 00:16:16,910
easier to reason about the problem it is

00:16:15,290 --> 00:16:18,620
actually shifting away stuff you're

00:16:16,910 --> 00:16:21,560
still going to have this loop somewhere

00:16:18,620 --> 00:16:24,440
else but you only have one level of

00:16:21,560 --> 00:16:27,980
jumping through state okay we are

00:16:24,440 --> 00:16:29,060
avoiding interacting with state it is

00:16:27,980 --> 00:16:31,730
much more expressive

00:16:29,060 --> 00:16:33,380
I mean arguably it is much easier to

00:16:31,730 --> 00:16:35,750
test you can mock it out you can do

00:16:33,380 --> 00:16:37,700
whatever you prefer there you have less

00:16:35,750 --> 00:16:41,240
coupling you have only one level you

00:16:37,700 --> 00:16:44,420
have only imports from one class and not

00:16:41,240 --> 00:16:45,800
from the contents of that class it's

00:16:44,420 --> 00:16:50,020
much more flexible you can replace it

00:16:45,800 --> 00:16:53,960
and it's much easier to get rid of it so

00:16:50,020 --> 00:16:55,940
that leads to pretty much the same kind

00:16:53,960 --> 00:16:59,660
of like conclusion there you pretty much

00:16:55,940 --> 00:17:03,320
disallow any access to the collections

00:16:59,660 --> 00:17:05,830
inside your entities from outside so

00:17:03,320 --> 00:17:11,240
here's we here we have another example

00:17:05,830 --> 00:17:13,010
so our user has a list of buns okay this

00:17:11,240 --> 00:17:16,040
is obviously accessing again with the

00:17:13,010 --> 00:17:18,530
getter approach but it's just an example

00:17:16,040 --> 00:17:20,240
for the sake of the example here so we

00:17:18,530 --> 00:17:24,320
access the banns and then we have

00:17:20,240 --> 00:17:26,990
somewhere a command handler a controller

00:17:24,320 --> 00:17:29,840
whatever this is okay a listener

00:17:26,990 --> 00:17:32,000
whatever this is which bans a user by ID

00:17:29,840 --> 00:17:32,960
so what I'm doing is I'm getting the

00:17:32,000 --> 00:17:37,009
user

00:17:32,960 --> 00:17:40,809
the repository and then I'm getting the

00:17:37,009 --> 00:17:44,480
buns of a user and I'm adding a button

00:17:40,809 --> 00:17:47,389
I'm banning that user you see that

00:17:44,480 --> 00:17:49,279
there's some fiddling around here so

00:17:47,389 --> 00:17:52,549
what happens is that I'm just modifying

00:17:49,279 --> 00:17:55,519
the state of the collection which is by

00:17:52,549 --> 00:17:58,279
reference containing inside the user so

00:17:55,519 --> 00:18:00,499
I'm modifying like the state through

00:17:58,279 --> 00:18:02,929
different indirection levels and that

00:18:00,499 --> 00:18:05,570
makes it really really hard to debug and

00:18:02,929 --> 00:18:07,970
something goes wrong so what you do is

00:18:05,570 --> 00:18:10,879
you keep them hidden you never expose

00:18:07,970 --> 00:18:13,369
them or you cast them or dereference

00:18:10,879 --> 00:18:16,159
them so what you can do is you can just

00:18:13,369 --> 00:18:17,809
cast a collection to array so here

00:18:16,159 --> 00:18:19,580
instead of returning a collection you

00:18:17,809 --> 00:18:22,940
either return a new collection or you

00:18:19,580 --> 00:18:25,100
return a an array which is dereferenced

00:18:22,940 --> 00:18:27,679
so you don't allow any modification on

00:18:25,100 --> 00:18:29,809
that object or what you can do is you

00:18:27,679 --> 00:18:33,529
indeed transform it into an interaction

00:18:29,809 --> 00:18:38,029
so your user now can be banned you can

00:18:33,529 --> 00:18:40,970
ban him well or Markus banned whatever

00:18:38,029 --> 00:18:42,559
and then you just call it like that so

00:18:40,970 --> 00:18:44,720
you see we're removing interaction

00:18:42,559 --> 00:18:48,649
levels again it's pretty much again

00:18:44,720 --> 00:18:53,289
similar to the previous law entity

00:18:48,649 --> 00:18:56,110
validity who does entity validate yeah I

00:18:53,289 --> 00:18:58,940
did it as well so it's not a big deal

00:18:56,110 --> 00:19:01,789
you shouldn't really do that it's not

00:18:58,940 --> 00:19:04,249
really something that should ever happen

00:19:01,789 --> 00:19:07,580
why did your entity get to an invalid

00:19:04,249 --> 00:19:10,690
state there is no invalid state ok sorry

00:19:07,580 --> 00:19:13,070
my slides get chucked trying on this but

00:19:10,690 --> 00:19:15,559
entities should always be in invalid

00:19:13,070 --> 00:19:18,590
state you should always have valid state

00:19:15,559 --> 00:19:21,259
inside of an entity after construct ok

00:19:18,590 --> 00:19:24,889
there should never be an invalid data in

00:19:21,259 --> 00:19:27,110
on anything that is like data that is

00:19:24,889 --> 00:19:29,269
kind of like squishy you're not sure if

00:19:27,110 --> 00:19:31,100
it's valid or if it's invalid it may

00:19:29,269 --> 00:19:32,929
change over time and the validity may

00:19:31,100 --> 00:19:35,210
change over time you just move it to a

00:19:32,929 --> 00:19:37,700
different concept move it into a

00:19:35,210 --> 00:19:39,619
completely separate object what you can

00:19:37,700 --> 00:19:42,830
do is you can create an object which is

00:19:39,619 --> 00:19:46,260
like a user from input form for example

00:19:42,830 --> 00:19:48,390
which may be valid or invalid over time

00:19:46,260 --> 00:19:50,490
depending on how the data is populated

00:19:48,390 --> 00:19:52,679
into the user but then when you have the

00:19:50,490 --> 00:19:55,200
user entity that's it

00:19:52,679 --> 00:19:57,360
is valid you can't push any more invalid

00:19:55,200 --> 00:19:58,919
data into it because once it got into

00:19:57,360 --> 00:20:02,520
your persistence of your system it's

00:19:58,919 --> 00:20:05,160
just a moving bug you save an object and

00:20:02,520 --> 00:20:07,830
one year later it causes a bug the time

00:20:05,160 --> 00:20:09,900
that happens a lot of times so this

00:20:07,830 --> 00:20:12,750
applies to any kind of temporary state

00:20:09,900 --> 00:20:14,340
anything that is like transient and you

00:20:12,750 --> 00:20:16,620
don't really know when it's gonna be

00:20:14,340 --> 00:20:19,470
valid just create a data transfer object

00:20:16,620 --> 00:20:22,350
a new object that has these rules about

00:20:19,470 --> 00:20:24,210
validity and once you can convert it

00:20:22,350 --> 00:20:27,710
into valid state then it can become an

00:20:24,210 --> 00:20:30,600
entity so you stay valid after construct

00:20:27,710 --> 00:20:32,630
regardless of what the database says it

00:20:30,600 --> 00:20:35,700
has to be valid after construct and

00:20:32,630 --> 00:20:37,530
there is a very quick solution to avoid

00:20:35,700 --> 00:20:40,290
having VC breaks on the constructor

00:20:37,530 --> 00:20:42,090
which is pretty much added naming adding

00:20:40,290 --> 00:20:44,549
named constructors everywhere which

00:20:42,090 --> 00:20:47,610
means you have a public static function

00:20:44,549 --> 00:20:50,940
from form data public static function

00:20:47,610 --> 00:20:54,960
from serialized state public static

00:20:50,940 --> 00:20:57,030
function from API data something like

00:20:54,960 --> 00:20:59,130
that so you keep adding those methods

00:20:57,030 --> 00:21:01,140
instead of modifying the constructor

00:20:59,130 --> 00:21:03,059
every time your requirements about input

00:21:01,140 --> 00:21:04,590
data change you just add a new method

00:21:03,059 --> 00:21:08,510
and a different way of building the

00:21:04,590 --> 00:21:12,900
object since we keep the state valid and

00:21:08,510 --> 00:21:15,570
we avoid interactions about state this

00:21:12,900 --> 00:21:19,760
means that these things also go away we

00:21:15,570 --> 00:21:21,480
don't deal with setters anymore so a

00:21:19,760 --> 00:21:26,809
sector doesn't really mean anything

00:21:21,480 --> 00:21:29,700
anyway so just get rid of it yeah so

00:21:26,809 --> 00:21:33,570
since we say that we can like say from

00:21:29,700 --> 00:21:36,270
API data from form data and so on we can

00:21:33,570 --> 00:21:39,360
also get to some more strict rules about

00:21:36,270 --> 00:21:41,309
this which are pretty much avoiding any

00:21:39,360 --> 00:21:42,929
coupling with the application layer now

00:21:41,309 --> 00:21:45,090
coupling with the application layer is

00:21:42,929 --> 00:21:49,320
bad for you because you are coding an

00:21:45,090 --> 00:21:51,690
application that will work for six

00:21:49,320 --> 00:21:54,990
months and that's okay but it may also

00:21:51,690 --> 00:21:56,669
work for twenty years okay and the

00:21:54,990 --> 00:21:59,710
framework that you using may not be

00:21:56,669 --> 00:22:01,420
supported anymore in 20 years

00:21:59,710 --> 00:22:03,640
how many people have a framework that

00:22:01,420 --> 00:22:05,380
has been online for 20 years how many

00:22:03,640 --> 00:22:09,150
people use JavaScript and have to change

00:22:05,380 --> 00:22:09,150
that every week right

00:22:09,400 --> 00:22:12,430
seriously just don't couple with the

00:22:11,290 --> 00:22:14,470
application layer this means that

00:22:12,430 --> 00:22:16,840
regardless if you like laravel now or

00:22:14,470 --> 00:22:19,540
symphony now is in framework now just

00:22:16,840 --> 00:22:23,740
don't think in the box okay you have to

00:22:19,540 --> 00:22:27,370
keep it out of your core logic so here

00:22:23,740 --> 00:22:29,590
we have two kind of bad examples one is

00:22:27,370 --> 00:22:31,300
we have a user controller that has a

00:22:29,590 --> 00:22:34,900
register action and then we have the

00:22:31,300 --> 00:22:39,910
user form binding to a new user so we

00:22:34,900 --> 00:22:43,480
have two violations here one is why can

00:22:39,910 --> 00:22:45,670
I create an empty user I what is the

00:22:43,480 --> 00:22:48,280
date and the user why is the user valid

00:22:45,670 --> 00:22:50,590
in this state I didn't provide any idea

00:22:48,280 --> 00:22:52,600
I didn't provide any user name so the

00:22:50,590 --> 00:22:54,970
user in this case already violates the

00:22:52,600 --> 00:22:57,700
rule about the constructor after

00:22:54,970 --> 00:23:00,130
construct it must be valid and in second

00:22:57,700 --> 00:23:02,230
place I have this form which interacts

00:23:00,130 --> 00:23:04,420
directly with the state of the user

00:23:02,230 --> 00:23:07,030
which makes it really really really

00:23:04,420 --> 00:23:09,340
squishy and what happens in those cases

00:23:07,030 --> 00:23:12,880
is that people start to modify the user

00:23:09,340 --> 00:23:14,860
to make the form work instead of

00:23:12,880 --> 00:23:16,960
adapting the form to the user they do

00:23:14,860 --> 00:23:18,910
the opposite you start adding getters

00:23:16,960 --> 00:23:22,020
and setters because the form changed and

00:23:18,910 --> 00:23:26,440
has more fields or the fields changed

00:23:22,020 --> 00:23:28,600
the other one is a bit better so what we

00:23:26,440 --> 00:23:31,900
do is we just save a user from forum

00:23:28,600 --> 00:23:32,440
data given a form now this one is much

00:23:31,900 --> 00:23:35,160
better

00:23:32,440 --> 00:23:37,870
but you still have some coupling because

00:23:35,160 --> 00:23:39,850
inside the from form data which is

00:23:37,870 --> 00:23:41,710
inside the core logic of your

00:23:39,850 --> 00:23:43,960
application you will have a type int

00:23:41,710 --> 00:23:46,540
against some kind of object which comes

00:23:43,960 --> 00:23:48,220
from the framework which means that when

00:23:46,540 --> 00:23:51,700
you upgrade you will have to rewrite

00:23:48,220 --> 00:23:53,860
this method which may be fine but it is

00:23:51,700 --> 00:23:56,800
a dependency and things will go wrong

00:23:53,860 --> 00:24:00,520
when you have to change the system so

00:23:56,800 --> 00:24:05,710
foreign components are bad okay right

00:24:00,520 --> 00:24:07,660
both symfony form and then form are

00:24:05,710 --> 00:24:09,910
totally terrible like both of them

00:24:07,660 --> 00:24:12,130
there's no exclusion all the form

00:24:09,910 --> 00:24:13,590
components are terrible at this there

00:24:12,130 --> 00:24:16,780
are solutions to the

00:24:13,590 --> 00:24:19,720
which are to use a data transfer object

00:24:16,780 --> 00:24:22,600
again so what you do is well anybody

00:24:19,720 --> 00:24:24,340
using Symphony or is in framework yeah

00:24:22,600 --> 00:24:26,650
I'm sorry I'm not really familiar with

00:24:24,340 --> 00:24:28,420
the larval form system there but in

00:24:26,650 --> 00:24:30,940
symphony in the firm you take an object

00:24:28,420 --> 00:24:33,460
you bind it to the form and then the

00:24:30,940 --> 00:24:35,920
form does it's magic kind of like how it

00:24:33,460 --> 00:24:38,950
works what you can do is instead of

00:24:35,920 --> 00:24:41,020
having a the entity bound to the form

00:24:38,950 --> 00:24:42,670
you create this secondary object this

00:24:41,020 --> 00:24:45,280
data transfer object which we talked

00:24:42,670 --> 00:24:48,850
about before which can have this invalid

00:24:45,280 --> 00:24:50,500
state and you push anything in there you

00:24:48,850 --> 00:24:52,630
start adding fields to that remove

00:24:50,500 --> 00:24:54,760
fields from that and so on and then you

00:24:52,630 --> 00:24:57,310
push all the data there and then you

00:24:54,760 --> 00:24:59,080
create the entity after that from these

00:24:57,310 --> 00:25:01,540
data transfer objects so once the data

00:24:59,080 --> 00:25:03,850
transfer object says okay all the data

00:25:01,540 --> 00:25:10,170
is here we now can convert it into an

00:25:03,850 --> 00:25:13,090
entity all right lifecycle callbacks I

00:25:10,170 --> 00:25:16,230
generally tell to avoid them

00:25:13,090 --> 00:25:21,040
so because lifecycle callbacks are

00:25:16,230 --> 00:25:23,200
pretty much a persistence hack now who

00:25:21,040 --> 00:25:25,840
uses them again I know there's love

00:25:23,200 --> 00:25:28,870
that's a lot of people again there are

00:25:25,840 --> 00:25:31,290
legit use cases for them but you can

00:25:28,870 --> 00:25:33,670
think of a lifecycle callback as

00:25:31,290 --> 00:25:37,360
serialized and uncivilized

00:25:33,670 --> 00:25:39,370
but database specific okay you don't

00:25:37,360 --> 00:25:42,220
want to save I don't know a big image

00:25:39,370 --> 00:25:46,000
inside the entity you want to store it

00:25:42,220 --> 00:25:47,620
in s3 a video or something that kind of

00:25:46,000 --> 00:25:48,400
educators you probably don't want to

00:25:47,620 --> 00:25:51,340
deal with it

00:25:48,400 --> 00:25:53,760
in DRAM but you probably don't want to

00:25:51,340 --> 00:25:56,440
land that stuff inside your database

00:25:53,760 --> 00:25:58,150
instead you just use lifecycle Kobach

00:25:56,440 --> 00:26:02,080
move stuff around and make it work

00:25:58,150 --> 00:26:05,340
somehow what happens is that of a lot of

00:26:02,080 --> 00:26:07,690
people cause business-business

00:26:05,340 --> 00:26:10,930
interactions inside this lifecycle

00:26:07,690 --> 00:26:14,680
callbacks now think about it would you

00:26:10,930 --> 00:26:16,570
ever implement an object which is JSON

00:26:14,680 --> 00:26:18,490
sur le table okay

00:26:16,570 --> 00:26:20,590
which means you call jason serialize and

00:26:18,490 --> 00:26:23,590
it calls that method on your object and

00:26:20,590 --> 00:26:26,509
that sends an email every time is here

00:26:23,590 --> 00:26:28,969
lies an object does that make any sense

00:26:26,509 --> 00:26:30,739
that is exactly what happens when you

00:26:28,969 --> 00:26:32,779
implement business logic inside the life

00:26:30,739 --> 00:26:36,559
cycle comeback it's exactly the same

00:26:32,779 --> 00:26:37,279
logic so kind of avoid them for that

00:26:36,559 --> 00:26:40,249
stuff

00:26:37,279 --> 00:26:42,979
there are use cases but they are instead

00:26:40,249 --> 00:26:48,759
this realized and uncivilized specific

00:26:42,979 --> 00:26:48,759
do or I'm contexts so keep that in mind

00:26:49,269 --> 00:26:54,679
right

00:26:50,539 --> 00:26:59,269
avoid auto-generated identifiers now

00:26:54,679 --> 00:27:03,739
this goes back to this example this user

00:26:59,269 --> 00:27:06,229
object like when I build this like does

00:27:03,739 --> 00:27:09,819
it have an identity it's an entity right

00:27:06,229 --> 00:27:13,159
an entity by definition is pretty much a

00:27:09,819 --> 00:27:16,749
container of stuff and it has an ID

00:27:13,159 --> 00:27:24,259
assigned to it that is what an entity is

00:27:16,749 --> 00:27:26,269
so every time you have an entity with

00:27:24,259 --> 00:27:28,729
out generated identifiers on a database

00:27:26,269 --> 00:27:31,609
this means that your entity will not

00:27:28,729 --> 00:27:35,059
have an ID until after you saved it

00:27:31,609 --> 00:27:38,299
added a to the database okay this means

00:27:35,059 --> 00:27:41,539
that you can like just create the object

00:27:38,299 --> 00:27:44,299
and it is not having any an ID this is

00:27:41,539 --> 00:27:45,949
invalid state okay so it's obviously

00:27:44,299 --> 00:27:49,399
violating one of the rules that I said

00:27:45,949 --> 00:27:50,959
before you will have also some kind of

00:27:49,399 --> 00:27:52,549
pitfalls so you are going to have

00:27:50,959 --> 00:27:55,069
blocking operations between each other

00:27:52,549 --> 00:27:56,929
so when you have like inserts related to

00:27:55,069 --> 00:27:59,239
each other you have to wait for this

00:27:56,929 --> 00:28:01,579
insert to be finished before you can do

00:27:59,239 --> 00:28:03,409
that insert and then you need the next

00:28:01,579 --> 00:28:05,719
insert and so on and so forth

00:28:03,409 --> 00:28:07,219
so you have kind of operations that are

00:28:05,719 --> 00:28:10,069
blocking each other that is not relevant

00:28:07,219 --> 00:28:13,190
because the doctrine system doesn't

00:28:10,069 --> 00:28:15,499
really currently allow bulk inserts we

00:28:13,190 --> 00:28:17,659
are working on it but if you code

00:28:15,499 --> 00:28:20,389
without incremental identifiers we

00:28:17,659 --> 00:28:22,789
cannot do bulk into inserts because we

00:28:20,389 --> 00:28:25,909
need to loop through every insert and

00:28:22,789 --> 00:28:27,529
get the last inserted identifier in

00:28:25,909 --> 00:28:30,619
order to populate it back into your

00:28:27,529 --> 00:28:32,539
object and make it valid so your orem is

00:28:30,619 --> 00:28:36,709
already fixing your data layer for you

00:28:32,539 --> 00:28:39,229
and data is appearing by magic which is

00:28:36,709 --> 00:28:40,269
kind of also one of the things that

00:28:39,229 --> 00:28:43,479
interestingly

00:28:40,269 --> 00:28:45,339
is confusing newcomers I mean it makes

00:28:43,479 --> 00:28:48,009
sense for everyone that used the RM for

00:28:45,339 --> 00:28:50,639
a period of time but for the newcomers

00:28:48,009 --> 00:28:54,149
they ask where does this idea come from

00:28:50,639 --> 00:28:57,369
and it also is a very good question

00:28:54,149 --> 00:28:59,080
you can do very complicated multi

00:28:57,369 --> 00:29:01,899
request transactions so you can't create

00:28:59,080 --> 00:29:03,580
an object and then say keep it on the

00:29:01,899 --> 00:29:05,289
side and then I'm going to do some other

00:29:03,580 --> 00:29:07,749
stuff and then I'm going to commit it

00:29:05,289 --> 00:29:12,579
later so you also have some problems

00:29:07,749 --> 00:29:14,349
there and again validity and

00:29:12,579 --> 00:29:17,139
interestingly your object doesn't work

00:29:14,349 --> 00:29:18,909
without the database so now you cannot

00:29:17,139 --> 00:29:20,919
write the example that I asked you to

00:29:18,909 --> 00:29:22,809
kind of think about before where you

00:29:20,919 --> 00:29:26,950
just create an object store it into a

00:29:22,809 --> 00:29:28,570
txt file and make it work there is a

00:29:26,950 --> 00:29:31,509
simple solution to that what you can do

00:29:28,570 --> 00:29:34,659
is you just use a UUID so what you do is

00:29:31,509 --> 00:29:37,629
you create just a very big integer

00:29:34,659 --> 00:29:41,639
that's what I you UID is for those who

00:29:37,629 --> 00:29:45,579
stare store uu IDs as 36 charters where

00:29:41,639 --> 00:29:48,039
because they do it so what you do is

00:29:45,579 --> 00:29:50,379
just this that's how you implement it

00:29:48,039 --> 00:29:54,369
and it's as simple as that there's a

00:29:50,379 --> 00:29:56,679
library built by Ben Ramsay and it works

00:29:54,369 --> 00:29:58,479
awesome and that's how you use it it's

00:29:56,679 --> 00:30:00,849
as simple as that and you can put it

00:29:58,479 --> 00:30:02,440
everywhere and I'm currently designing

00:30:00,849 --> 00:30:04,539
all my new systems with that and it's

00:30:02,440 --> 00:30:06,909
just amazing you're simplifying the

00:30:04,539 --> 00:30:12,519
problems by a lot with very minimal

00:30:06,909 --> 00:30:14,769
overhead you can pretty much say oh yeah

00:30:12,519 --> 00:30:16,869
but now I have the IDS that are not

00:30:14,769 --> 00:30:18,579
suitable I can sort them because I you

00:30:16,869 --> 00:30:21,070
you it is pretty much a random number

00:30:18,579 --> 00:30:27,279
it's a very random number to give you an

00:30:21,070 --> 00:30:30,969
idea of how random it is if you kept

00:30:27,279 --> 00:30:34,409
generating new you IDs for a hundred

00:30:30,969 --> 00:30:37,659
years with a million you IDs per second

00:30:34,409 --> 00:30:40,329
you would probably have 50% of a chance

00:30:37,659 --> 00:30:42,759
of having one collision okay that's how

00:30:40,329 --> 00:30:46,209
random of you you idea is so you can

00:30:42,759 --> 00:30:50,559
safely use them as a replacement for any

00:30:46,209 --> 00:30:52,269
kind of sequence instead you just pretty

00:30:50,559 --> 00:30:54,330
much can get rid of this and you just

00:30:52,269 --> 00:30:57,029
add the date/time field somewhere

00:30:54,330 --> 00:31:00,059
okay so we simplified the ideas as well

00:30:57,029 --> 00:31:02,860
now what we can do is we can also

00:31:00,059 --> 00:31:04,659
simplify this sequence problem we just

00:31:02,860 --> 00:31:08,980
add date times but we can also simplify

00:31:04,659 --> 00:31:11,950
identifiers in general so let's get rid

00:31:08,980 --> 00:31:14,799
of derived primary keys so this is a

00:31:11,950 --> 00:31:17,139
normalization thing in databases you

00:31:14,799 --> 00:31:19,000
tend to normalize stuff so every time

00:31:17,139 --> 00:31:21,309
you have a field which is part of a

00:31:19,000 --> 00:31:23,590
primary key but reference is another

00:31:21,309 --> 00:31:25,899
field that's where you have a derived

00:31:23,590 --> 00:31:28,240
primarily so you just rather get rid of

00:31:25,899 --> 00:31:30,220
it this pretty much means that in deorum

00:31:28,240 --> 00:31:33,399
you don't use any field that is an ID

00:31:30,220 --> 00:31:34,059
and it is a to one Association just

00:31:33,399 --> 00:31:35,919
don't do it

00:31:34,059 --> 00:31:38,970
it doesn't really bring you anything

00:31:35,919 --> 00:31:41,500
just create a new circuit field and

00:31:38,970 --> 00:31:43,960
store it there that's perfectly okay for

00:31:41,500 --> 00:31:46,480
the other field you just create a unique

00:31:43,960 --> 00:31:48,639
constraint and then you deal with the

00:31:46,480 --> 00:31:51,010
duplication problems at application

00:31:48,639 --> 00:31:53,769
level and you let it crash if it goes

00:31:51,010 --> 00:31:55,899
back to the database but there is no

00:31:53,769 --> 00:31:58,210
real reason to have the right primary

00:31:55,899 --> 00:32:00,700
keys except normalizing because the book

00:31:58,210 --> 00:32:02,169
told you to do that you don't need to

00:32:00,700 --> 00:32:06,490
have everything in third normal form

00:32:02,169 --> 00:32:08,679
there is no point in doing that and what

00:32:06,490 --> 00:32:10,600
you should do is every time you tend to

00:32:08,679 --> 00:32:13,210
normalize too much you should think

00:32:10,600 --> 00:32:14,799
about whether it actually brings

00:32:13,210 --> 00:32:16,360
something from a business perfect

00:32:14,799 --> 00:32:19,510
perspective does the business actually

00:32:16,360 --> 00:32:21,370
need it do you need any normalization

00:32:19,510 --> 00:32:23,440
there or are you just doing it because

00:32:21,370 --> 00:32:27,760
you like the nice normalization problem

00:32:23,440 --> 00:32:30,220
of databases in general so the same for

00:32:27,760 --> 00:32:31,990
composite from primary Keys composite

00:32:30,220 --> 00:32:33,850
primary keys which is pretty much just a

00:32:31,990 --> 00:32:37,330
primary key spanning over more than one

00:32:33,850 --> 00:32:41,169
field or column they're pretty much not

00:32:37,330 --> 00:32:43,059
necessary okay just don't use them

00:32:41,169 --> 00:32:45,039
this is obviously not a hundred percent

00:32:43,059 --> 00:32:46,960
rule okay and I'm not telling you oh my

00:32:45,039 --> 00:32:49,690
god this guy is going completely crazy

00:32:46,960 --> 00:32:51,760
he's telling us not to use primary keys

00:32:49,690 --> 00:32:53,230
as they were designed to be used I'm

00:32:51,760 --> 00:32:55,360
just telling you how it works what

00:32:53,230 --> 00:32:57,970
better in this context you just assign a

00:32:55,360 --> 00:33:00,309
ID on your own and everything else is

00:32:57,970 --> 00:33:02,049
just a constraint and you make it fail

00:33:00,309 --> 00:33:05,049
if you try to insert duplicate data in

00:33:02,049 --> 00:33:06,700
the database but you don't deal with the

00:33:05,049 --> 00:33:07,620
unique constraint problem inside the

00:33:06,700 --> 00:33:12,040
application

00:33:07,620 --> 00:33:14,530
okay is there any reason not to just use

00:33:12,040 --> 00:33:15,880
a surrogate field no it's just an

00:33:14,530 --> 00:33:18,640
optimization that you're doing here

00:33:15,880 --> 00:33:20,470
there and it's just complicating how you

00:33:18,640 --> 00:33:23,080
fetch data and save data inside your

00:33:20,470 --> 00:33:24,910
database does it really make a

00:33:23,080 --> 00:33:28,660
difference for me the mine perspective

00:33:24,910 --> 00:33:31,330
not really in most cases if it does then

00:33:28,660 --> 00:33:35,380
do it but in most cases you don't really

00:33:31,330 --> 00:33:38,770
have this problem alright so um kinda

00:33:35,380 --> 00:33:41,860
slowing down here favor immutable

00:33:38,770 --> 00:33:44,410
entities one thing that is really cool

00:33:41,860 --> 00:33:46,000
that you can do is in doctrine 2.5

00:33:44,410 --> 00:33:48,190
there's this component which is called

00:33:46,000 --> 00:33:50,020
the second level cache just kind of

00:33:48,190 --> 00:33:54,820
enable it and it kind of makes things

00:33:50,020 --> 00:33:56,470
faster sometimes but what you can do is

00:33:54,820 --> 00:33:58,720
you can pretty much just either make

00:33:56,470 --> 00:34:00,240
entities immutable or design data

00:33:58,720 --> 00:34:03,820
structures in such a way that our

00:34:00,240 --> 00:34:05,800
append-only here's a an example so you

00:34:03,820 --> 00:34:08,800
have a private message inside I don't

00:34:05,800 --> 00:34:10,900
know message board or whatever and then

00:34:08,800 --> 00:34:12,850
you have a from a to a message and

00:34:10,900 --> 00:34:16,630
they're read which is an array a

00:34:12,850 --> 00:34:18,400
collection of who read message so what

00:34:16,630 --> 00:34:20,169
you do is you can strike this object and

00:34:18,400 --> 00:34:23,620
then you have an interaction which says

00:34:20,169 --> 00:34:25,300
read and the user reads the message so

00:34:23,620 --> 00:34:28,090
every time you have an interaction with

00:34:25,300 --> 00:34:32,950
read you are simply going to create a

00:34:28,090 --> 00:34:35,860
new message read okay and that's it and

00:34:32,950 --> 00:34:38,470
message read looks like this it doesn't

00:34:35,860 --> 00:34:40,780
have any interaction or well it may have

00:34:38,470 --> 00:34:43,210
gutters eventually or you may have some

00:34:40,780 --> 00:34:45,550
kind of serialization for it but that's

00:34:43,210 --> 00:34:47,770
it you create an object you push it to

00:34:45,550 --> 00:34:49,960
the collection so this is an append-only

00:34:47,770 --> 00:34:52,270
data structure it is going to grow over

00:34:49,960 --> 00:34:54,040
time but it's not a big deal because to

00:34:52,270 --> 00:34:56,350
be honest we got enough hard drives

00:34:54,040 --> 00:34:58,540
plate space and data bases are really

00:34:56,350 --> 00:35:01,120
efficient at dealing with lots of data

00:34:58,540 --> 00:35:03,040
but it is really really simple

00:35:01,120 --> 00:35:06,010
you keep appending instead of saying

00:35:03,040 --> 00:35:06,730
yeah message rad it goes from false to

00:35:06,010 --> 00:35:08,950
true

00:35:06,730 --> 00:35:10,900
you just keep appending so you know who

00:35:08,950 --> 00:35:14,200
read it so you're also having an

00:35:10,900 --> 00:35:16,030
auditing log as a side-effect and you

00:35:14,200 --> 00:35:18,460
may also apply different business rules

00:35:16,030 --> 00:35:20,650
like how many times was it rad or when

00:35:18,460 --> 00:35:21,250
was it read the first time this object

00:35:20,650 --> 00:35:23,190
may just

00:35:21,250 --> 00:35:26,950
store at a time when it was created

00:35:23,190 --> 00:35:31,180
kinda useful right immutable data is

00:35:26,950 --> 00:35:33,760
really simple to reason about and I can

00:35:31,180 --> 00:35:35,560
cache it forever since it's not going to

00:35:33,760 --> 00:35:38,620
change I can just plug in the caffeine

00:35:35,560 --> 00:35:40,780
component here and any data coming from

00:35:38,620 --> 00:35:42,040
that assuming is in my cache I'm never

00:35:40,780 --> 00:35:44,170
going to query it again

00:35:42,040 --> 00:35:46,510
so my database doesn't need to be

00:35:44,170 --> 00:35:51,100
queried again ever for that particular

00:35:46,510 --> 00:35:53,530
kind of empty it is predictable you can

00:35:51,100 --> 00:35:56,530
kind of do predictions based on previous

00:35:53,530 --> 00:35:58,540
data you can see how data is going to in

00:35:56,530 --> 00:36:00,220
which direction you're going if it's

00:35:58,540 --> 00:36:03,670
going up down whatever you want to do

00:36:00,220 --> 00:36:06,430
and you can do historical analysis I

00:36:03,670 --> 00:36:09,130
mean counting or seeing who inserted

00:36:06,430 --> 00:36:11,020
first I record stuff like that so it's

00:36:09,130 --> 00:36:13,120
really really useful you may look at

00:36:11,020 --> 00:36:16,030
different concepts for that there are

00:36:13,120 --> 00:36:18,220
even other components that are not DRM

00:36:16,030 --> 00:36:21,580
that allow you to do event sourcing

00:36:18,220 --> 00:36:24,940
there's even dedicated storages for that

00:36:21,580 --> 00:36:28,720
but as for another talk avoid soft

00:36:24,940 --> 00:36:33,280
release soft deletes are kind of a

00:36:28,720 --> 00:36:35,830
broken concept they come from an age

00:36:33,280 --> 00:36:38,650
where everything had to stay in one

00:36:35,830 --> 00:36:40,630
database everything had to stay in one

00:36:38,650 --> 00:36:43,900
database because of performance issues

00:36:40,630 --> 00:36:45,880
because you had 700 tables in the same

00:36:43,900 --> 00:36:48,600
database and I'm fairly sure everyone

00:36:45,880 --> 00:36:52,750
here has one or two projects with that

00:36:48,600 --> 00:36:54,400
but they bring a big problem with them

00:36:52,750 --> 00:36:57,040
first of all they break some

00:36:54,400 --> 00:36:58,840
immutability so you're not really having

00:36:57,040 --> 00:37:00,340
immutable data you just have this data

00:36:58,840 --> 00:37:03,190
that changes instead of just

00:37:00,340 --> 00:37:05,230
disappearing it really changes but you

00:37:03,190 --> 00:37:09,010
break data integrity now you have

00:37:05,230 --> 00:37:11,110
foreign keys referencing some data that

00:37:09,010 --> 00:37:14,770
may not exist anymore because it's soft

00:37:11,110 --> 00:37:16,540
deleted but it's not really deleted so

00:37:14,770 --> 00:37:19,420
now you have like kind of a broken

00:37:16,540 --> 00:37:21,310
Association there so all this stuff that

00:37:19,420 --> 00:37:24,430
we fought for which is data integrity

00:37:21,310 --> 00:37:26,370
that's why you use an RDM our DBMS and

00:37:24,430 --> 00:37:29,710
not like something like MongoDB

00:37:26,370 --> 00:37:32,400
depending on your use case that's kind

00:37:29,710 --> 00:37:35,140
of gone so what is the point

00:37:32,400 --> 00:37:38,019
you're breaking validity as well here

00:37:35,140 --> 00:37:40,809
so soft deletes are pretty much coming

00:37:38,019 --> 00:37:43,390
from this idea where everything has to

00:37:40,809 --> 00:37:46,210
still exist in the same database and you

00:37:43,390 --> 00:37:47,079
cannot ever lose data if you have this

00:37:46,210 --> 00:37:49,109
kind of problem

00:37:47,079 --> 00:37:51,309
why not implement an audit log instead

00:37:49,109 --> 00:37:53,279
every time you delete something you're

00:37:51,309 --> 00:37:56,589
going to add their records somewhere

00:37:53,279 --> 00:37:59,069
simple right it's a good solution does

00:37:56,589 --> 00:38:02,890
your use case really also includes

00:37:59,069 --> 00:38:05,079
restoring deleted data ok did somebody

00:38:02,890 --> 00:38:07,390
ask you to build the feature to restore

00:38:05,079 --> 00:38:09,849
deleted data or are you just thinking

00:38:07,390 --> 00:38:12,009
too much forward and it's something that

00:38:09,849 --> 00:38:14,890
nobody will ever need or maybe you can

00:38:12,009 --> 00:38:17,109
just restore a backup ok I'm not even

00:38:14,890 --> 00:38:21,609
joking you just restore a backup it's

00:38:17,109 --> 00:38:24,279
perfectly ok sometimes soft deletes can

00:38:21,609 --> 00:38:27,700
pretty much always be replaced by some

00:38:24,279 --> 00:38:30,819
more some concept that is more near to

00:38:27,700 --> 00:38:33,519
your use case this is something that was

00:38:30,819 --> 00:38:37,509
interesting and a company I did some

00:38:33,519 --> 00:38:41,619
consulting for last year they have huge

00:38:37,509 --> 00:38:43,720
machinery by huge machinery I mean a

00:38:41,619 --> 00:38:47,230
single machine could fit this entire

00:38:43,720 --> 00:38:50,109
room ok and they used to press metal

00:38:47,230 --> 00:38:52,769
pieces now what happens is that they

00:38:50,109 --> 00:38:56,980
produce a hundred million pieces of this

00:38:52,769 --> 00:38:58,930
metal stuff and then they get rid of the

00:38:56,980 --> 00:39:00,549
machine because they need the building

00:38:58,930 --> 00:39:03,819
to build another machine to make a

00:39:00,549 --> 00:39:06,119
different piece right you're not really

00:39:03,819 --> 00:39:08,799
deleting that machine where does that

00:39:06,119 --> 00:39:11,920
machinery all go what happens is that

00:39:08,799 --> 00:39:14,859
they just take it put it in boxes ship

00:39:11,920 --> 00:39:15,609
it somewhere in people or whatever so

00:39:14,859 --> 00:39:18,160
it's our hived

00:39:15,609 --> 00:39:20,619
right it's a very different concept from

00:39:18,160 --> 00:39:23,109
deleted so they used this soft delete

00:39:20,619 --> 00:39:26,680
concept to be able to like turn on and

00:39:23,109 --> 00:39:29,920
off these machines but now they had

00:39:26,680 --> 00:39:32,140
problems where they like had like which

00:39:29,920 --> 00:39:33,999
piece was produced by which machine and

00:39:32,140 --> 00:39:35,950
they had referential integrity issues

00:39:33,999 --> 00:39:38,259
because the machines that were soft

00:39:35,950 --> 00:39:40,599
deleted where marked as deleted and

00:39:38,259 --> 00:39:42,249
could not be referenced so you see we

00:39:40,599 --> 00:39:43,900
still have these problems instead we

00:39:42,249 --> 00:39:46,450
replaced it with the problem of our

00:39:43,900 --> 00:39:49,010
hiving and that was a perfect fit

00:39:46,450 --> 00:39:51,290
you just had little marker that

00:39:49,010 --> 00:39:52,340
said this entry this machine is not

00:39:51,290 --> 00:39:56,450
active anymore

00:39:52,340 --> 00:39:58,630
we are hived it very simple right okay

00:39:56,450 --> 00:40:02,420
mapping driver choices this is just

00:39:58,630 --> 00:40:05,870
necessary because I'm I have my

00:40:02,420 --> 00:40:08,450
preferences on that so in private

00:40:05,870 --> 00:40:11,150
packages just use annotations don't go

00:40:08,450 --> 00:40:13,700
overboard unless you're writing software

00:40:11,150 --> 00:40:15,610
that should last for forever you're

00:40:13,700 --> 00:40:18,650
perfectly fine with annotations

00:40:15,610 --> 00:40:20,930
annotations are simple to read any

00:40:18,650 --> 00:40:23,540
junior developer can understand how they

00:40:20,930 --> 00:40:26,450
work maybe he will configure them wrong

00:40:23,540 --> 00:40:27,890
a couple times this will happen but they

00:40:26,450 --> 00:40:29,750
work they are simple to understand and

00:40:27,890 --> 00:40:33,740
they're very near to the code they

00:40:29,750 --> 00:40:38,630
affect directly for public stuff

00:40:33,740 --> 00:40:40,850
oh this died for public stuff please use

00:40:38,630 --> 00:40:42,710
Excel mappings and that is because

00:40:40,850 --> 00:40:45,080
everyone will be able to take your

00:40:42,710 --> 00:40:46,790
open-source package and replace the

00:40:45,080 --> 00:40:49,040
mappings with some other mappings from a

00:40:46,790 --> 00:40:52,370
different file so please use external

00:40:49,040 --> 00:40:54,260
mappings for public stuff for llam I'll

00:40:52,370 --> 00:40:56,860
gamble you if you use it don't don't do

00:40:54,260 --> 00:41:01,400
it it really it's a bad idea

00:40:56,860 --> 00:41:02,840
lazy are eager loading this is also one

00:41:01,400 --> 00:41:05,810
of those things that you should not

00:41:02,840 --> 00:41:08,570
really look at when building your system

00:41:05,810 --> 00:41:10,910
initially I see a lot of system where

00:41:08,570 --> 00:41:14,570
you go in and you see everything marked

00:41:10,910 --> 00:41:17,930
as extra lazy by default or eager by

00:41:14,570 --> 00:41:19,340
default don't do it you just figure it

00:41:17,930 --> 00:41:21,890
out later while you're working in the

00:41:19,340 --> 00:41:25,520
system eager loading is pretty much

00:41:21,890 --> 00:41:28,100
useless while we build it with this

00:41:25,520 --> 00:41:31,040
eager loading eager loading is far from

00:41:28,100 --> 00:41:32,930
completely working so the idea was that

00:41:31,040 --> 00:41:35,330
every time you have an association and

00:41:32,930 --> 00:41:38,810
you have this eager annotation or a

00:41:35,330 --> 00:41:40,610
marker you are going to pretty much do a

00:41:38,810 --> 00:41:42,560
join automatically and you're going to

00:41:40,610 --> 00:41:44,990
fetch the Associated data in one query

00:41:42,560 --> 00:41:49,430
this doesn't really happen because the

00:41:44,990 --> 00:41:52,000
RM is far from a magic box it is still

00:41:49,430 --> 00:41:56,420
kind of a magic box but it's just tricks

00:41:52,000 --> 00:41:58,790
okay so pretty much don't use it extra

00:41:56,420 --> 00:42:02,450
lazy on the other side you will have to

00:41:58,790 --> 00:42:02,779
use it in some cases but the point of X

00:42:02,450 --> 00:42:06,019
really

00:42:02,779 --> 00:42:07,999
is kind of giving you also warning like

00:42:06,019 --> 00:42:10,189
here you have something that goes out of

00:42:07,999 --> 00:42:12,140
the boundaries of what an online

00:42:10,189 --> 00:42:14,359
transaction processing system should do

00:42:12,140 --> 00:42:17,719
so now you have a collection with like a

00:42:14,359 --> 00:42:19,759
thousand items and million items I think

00:42:17,719 --> 00:42:21,289
about it you start looping over one of

00:42:19,759 --> 00:42:23,150
those collections by accident and

00:42:21,289 --> 00:42:25,339
suddenly your system crashes because

00:42:23,150 --> 00:42:28,099
there's no memory or because it loads

00:42:25,339 --> 00:42:31,189
the entire table inside your memory and

00:42:28,099 --> 00:42:33,640
maybe I don't know it goes into swapping

00:42:31,189 --> 00:42:35,959
and your system goes completely offline

00:42:33,640 --> 00:42:38,419
depending on memory limits and stuff

00:42:35,959 --> 00:42:40,130
like that but they are high risk areas

00:42:38,419 --> 00:42:42,409
so every time you have extra lazy you

00:42:40,130 --> 00:42:45,229
have to be very careful about what

00:42:42,409 --> 00:42:47,239
you're doing there so you are at the

00:42:45,229 --> 00:42:49,519
limits of what your M can do you should

00:42:47,239 --> 00:42:51,079
probably just stop and look at whether

00:42:49,519 --> 00:42:53,449
you still need your M for that

00:42:51,079 --> 00:42:55,699
particular data and you need to be very

00:42:53,449 --> 00:42:59,659
careful about transaction size and

00:42:55,699 --> 00:43:01,309
performance in that case bi-directional

00:42:59,659 --> 00:43:04,279
associations that comes directly from

00:43:01,309 --> 00:43:05,869
the manual just avoid them don't use

00:43:04,279 --> 00:43:08,359
them by default don't make everything be

00:43:05,869 --> 00:43:11,619
directional so think about your use case

00:43:08,359 --> 00:43:14,179
if you have a object referencing some

00:43:11,619 --> 00:43:17,059
parts the parts don't need to know in

00:43:14,179 --> 00:43:21,109
which system they are okay it's the

00:43:17,059 --> 00:43:22,789
object containing them all right they

00:43:21,109 --> 00:43:25,640
bring some overhead you are going to

00:43:22,789 --> 00:43:28,189
hydrate data both in both directions and

00:43:25,640 --> 00:43:30,979
that is a lot of moving stuff around

00:43:28,189 --> 00:43:32,749
that your M does for you so you know you

00:43:30,979 --> 00:43:34,400
only want to code the associations that

00:43:32,749 --> 00:43:36,559
are strictly necessary to make your

00:43:34,400 --> 00:43:39,109
business logic work goes back to

00:43:36,559 --> 00:43:41,449
initially we first implemented public

00:43:39,109 --> 00:43:43,759
API how your objects talk to each other

00:43:41,449 --> 00:43:47,989
and then the state internal to these

00:43:43,759 --> 00:43:50,359
objects comes after that if you need to

00:43:47,989 --> 00:43:52,699
like do some complex dql queries that

00:43:50,359 --> 00:43:55,219
traverse the associations in various

00:43:52,699 --> 00:43:58,429
directions just hack them together or

00:43:55,219 --> 00:44:01,429
use SQL I mean SQL is perfectly valid in

00:43:58,429 --> 00:44:03,979
guess in this case so what you can do is

00:44:01,429 --> 00:44:05,569
you can have custom repositories custom

00:44:03,979 --> 00:44:08,630
repositories will give you some very

00:44:05,569 --> 00:44:10,759
expressive API you know exactly what

00:44:08,630 --> 00:44:14,089
you're looking at and they're very

00:44:10,759 --> 00:44:16,670
verbose so you have a user repository

00:44:14,089 --> 00:44:19,549
which says find users that have in

00:44:16,670 --> 00:44:24,109
subscription there is no way somebody

00:44:19,549 --> 00:44:26,660
can read it wrong I mean it is really

00:44:24,109 --> 00:44:30,549
simple and then you had you can have any

00:44:26,660 --> 00:44:33,019
kind of hell here you can do SQL dql

00:44:30,549 --> 00:44:34,490
MongoDB MapReduce operation you can do

00:44:33,019 --> 00:44:37,119
whatever I want you want you can use

00:44:34,490 --> 00:44:39,589
caching what you want doesn't matter

00:44:37,119 --> 00:44:41,510
there's another approach which I like

00:44:39,589 --> 00:44:44,630
much better lately and that's just

00:44:41,510 --> 00:44:46,160
because of kind of more functional

00:44:44,630 --> 00:44:49,160
approaches that I'm taking although this

00:44:46,160 --> 00:44:52,190
is not functional at all because of

00:44:49,160 --> 00:44:54,260
state retention but you have an object

00:44:52,190 --> 00:44:57,260
which is users that have a monthly

00:44:54,260 --> 00:44:59,029
subscription and you can call this many

00:44:57,260 --> 00:45:00,980
many times and it will just pretty much

00:44:59,029 --> 00:45:03,339
execute the query so it's the exact same

00:45:00,980 --> 00:45:08,359
thing as this one I just moved this

00:45:03,339 --> 00:45:11,450
method to the class name alright I moved

00:45:08,359 --> 00:45:13,849
it to the top so what you do is you

00:45:11,450 --> 00:45:15,920
simply have a single function which is a

00:45:13,849 --> 00:45:18,109
report and you can just open a directory

00:45:15,920 --> 00:45:19,760
and see all the different reports that

00:45:18,109 --> 00:45:22,839
you coded and what you support in your

00:45:19,760 --> 00:45:26,029
system which is really useful

00:45:22,839 --> 00:45:28,250
repositories are services same as these

00:45:26,029 --> 00:45:32,150
query functions kind of that I shown you

00:45:28,250 --> 00:45:34,609
and you should treat them as laps so you

00:45:32,150 --> 00:45:37,460
have to deal with the problems of

00:45:34,609 --> 00:45:41,059
service location so you can avoid having

00:45:37,460 --> 00:45:44,089
anything to do with this thing this get

00:45:41,059 --> 00:45:47,750
repository entity manager get repository

00:45:44,089 --> 00:45:50,480
is a service locator and it is coded as

00:45:47,750 --> 00:45:53,690
a utility method to make it quick to

00:45:50,480 --> 00:45:55,880
work with but the repositories inside

00:45:53,690 --> 00:45:58,490
your system are part of your domain

00:45:55,880 --> 00:46:00,680
logic and it should not really come from

00:45:58,490 --> 00:46:04,640
the tool you should inject them instead

00:46:00,680 --> 00:46:06,529
so this kind of API has the same exact

00:46:04,640 --> 00:46:08,180
problems of an S of a service locator

00:46:06,529 --> 00:46:09,829
you now have an object and you don't

00:46:08,180 --> 00:46:11,900
know if the object is exactly what you

00:46:09,829 --> 00:46:14,059
expected so you will have some problems

00:46:11,900 --> 00:46:17,000
instead you have to inject them in the

00:46:14,059 --> 00:46:18,980
constructor okay past the repository to

00:46:17,000 --> 00:46:23,509
your constructor and you're going to be

00:46:18,980 --> 00:46:27,289
fine our suggestions you can say

00:46:23,509 --> 00:46:30,109
separate get and find methods this is

00:46:27,289 --> 00:46:32,859
really really useful so what you do is

00:46:30,109 --> 00:46:36,769
you have two versions of the same API

00:46:32,859 --> 00:46:39,650
we'd find you can have a method that

00:46:36,769 --> 00:46:42,710
returns no it can fail it can return an

00:46:39,650 --> 00:46:46,400
empty array you can do all of this but

00:46:42,710 --> 00:46:49,249
we'd get it cannot gat is always

00:46:46,400 --> 00:46:50,809
supposed to return something and if it

00:46:49,249 --> 00:46:52,999
doesn't return something it should throw

00:46:50,809 --> 00:46:55,069
an exception and it's really really easy

00:46:52,999 --> 00:46:58,339
to implement and it simplifies things by

00:46:55,069 --> 00:47:00,499
a lot so this is like get by slug and it

00:46:58,339 --> 00:47:03,079
will give you a blog post and if it

00:47:00,499 --> 00:47:06,529
cannot find a blog post it will throw a

00:47:03,079 --> 00:47:08,839
blog post not found exception from the

00:47:06,529 --> 00:47:11,630
slug okay it will tell you I couldn't

00:47:08,839 --> 00:47:14,420
find a blog post by this slug okay and

00:47:11,630 --> 00:47:16,369
this really simplifies things because

00:47:14,420 --> 00:47:18,859
now every consumer of the repository

00:47:16,369 --> 00:47:22,130
doesn't have to deal with the case of no

00:47:18,859 --> 00:47:23,690
it always expects something and the case

00:47:22,130 --> 00:47:25,309
where you don't have that particular

00:47:23,690 --> 00:47:28,099
record will throw an exception

00:47:25,309 --> 00:47:30,470
in this case in this particular logic in

00:47:28,099 --> 00:47:33,140
this particular repository case you can

00:47:30,470 --> 00:47:36,049
just catch this exception and transform

00:47:33,140 --> 00:47:38,720
it into a 404 page for now you can make

00:47:36,049 --> 00:47:41,089
it crash and make a 500 it's perfectly

00:47:38,720 --> 00:47:42,079
okay but later on if you want to make it

00:47:41,089 --> 00:47:46,489
more restitch

00:47:42,079 --> 00:47:51,789
you can do it for a for two-phase commit

00:47:46,489 --> 00:47:55,789
I'm going to skip on that but here's a

00:47:51,789 --> 00:47:57,799
suggestion that I can give you between

00:47:55,789 --> 00:48:01,099
different services that deal with

00:47:57,799 --> 00:48:03,440
similar concepts but kind of share state

00:48:01,099 --> 00:48:07,130
you can actually call the entity manager

00:48:03,440 --> 00:48:09,049
clear method now one of the advantages

00:48:07,130 --> 00:48:11,299
of doctrine is that since it keeps

00:48:09,049 --> 00:48:14,630
everything in memory you're not going to

00:48:11,299 --> 00:48:16,279
repeat queries for fetching data now

00:48:14,630 --> 00:48:19,549
since you have the second level cache

00:48:16,279 --> 00:48:22,160
component this is not not true anymore

00:48:19,549 --> 00:48:24,499
okay since you are saving and loading

00:48:22,160 --> 00:48:26,539
data and this data goes into second

00:48:24,499 --> 00:48:28,999
level cache every time you do a direct

00:48:26,539 --> 00:48:32,210
fetch it is probably going to load from

00:48:28,999 --> 00:48:34,880
the cache this means that you can pretty

00:48:32,210 --> 00:48:37,880
much clear at the end of pretty much

00:48:34,880 --> 00:48:39,950
every kind of code execution that is

00:48:37,880 --> 00:48:43,279
like domain logic you execute the

00:48:39,950 --> 00:48:44,059
service method and you just clear this

00:48:43,279 --> 00:48:46,430
means that you

00:48:44,059 --> 00:48:48,650
don't have any transient state that

00:48:46,430 --> 00:48:51,890
wasn't safe that is shady that is moving

00:48:48,650 --> 00:48:54,140
around you just avoid that instead what

00:48:51,890 --> 00:48:55,759
you do is you just pass from one service

00:48:54,140 --> 00:48:57,559
to the other instead of passing a user

00:48:55,759 --> 00:48:59,869
object from one service to the next

00:48:57,559 --> 00:49:02,930
service you pass the identifier of the

00:48:59,869 --> 00:49:07,449
user okay so you have different

00:49:02,930 --> 00:49:10,160
boundaries like invoicing system and a

00:49:07,449 --> 00:49:12,019
shipping system okay so you have

00:49:10,160 --> 00:49:14,719
products in invoicing and products in

00:49:12,019 --> 00:49:18,170
shipping you pass the product ID from

00:49:14,719 --> 00:49:20,209
shipping to invoicing or vice versa the

00:49:18,170 --> 00:49:21,979
other direction okay you decide how to

00:49:20,209 --> 00:49:24,529
do that but instead of passing the

00:49:21,979 --> 00:49:26,359
product itself and sharing the same

00:49:24,529 --> 00:49:29,299
entity you just pass IDs here and there

00:49:26,359 --> 00:49:31,160
and this avoids any particular strange

00:49:29,299 --> 00:49:33,019
state conditions where you don't know if

00:49:31,160 --> 00:49:35,119
you can flush or not because that

00:49:33,019 --> 00:49:38,900
happens a lot you don't know who is

00:49:35,119 --> 00:49:41,479
responsible for flushing something so

00:49:38,900 --> 00:49:45,979
you just pass IDs around simplifies by a

00:49:41,479 --> 00:49:49,219
lot okay keep normalization under

00:49:45,979 --> 00:49:51,589
control we are talking about real world

00:49:49,219 --> 00:49:53,719
applications we're not trying to solve

00:49:51,589 --> 00:49:56,029
the problem of storing everything inside

00:49:53,719 --> 00:49:59,239
a perfect schema that represents the

00:49:56,029 --> 00:50:02,539
world okay every time I see these like

00:49:59,239 --> 00:50:04,069
giant object graphs of 500 entities

00:50:02,539 --> 00:50:07,069
where everything has to be its own

00:50:04,069 --> 00:50:08,959
entity and so ours for just freaking

00:50:07,069 --> 00:50:11,329
made adjacent field and stuff it with

00:50:08,959 --> 00:50:14,869
stuff okay that's it it's really really

00:50:11,329 --> 00:50:17,420
simple okay so keep the normalization

00:50:14,869 --> 00:50:20,269
freaks under control you know like just

00:50:17,420 --> 00:50:22,249
take them and you know put them in trash

00:50:20,269 --> 00:50:24,339
bin or something I'm just not going to

00:50:22,249 --> 00:50:28,099
suggest it bully people but seriously

00:50:24,339 --> 00:50:31,789
tell them is okay to pretty much store

00:50:28,099 --> 00:50:36,170
some data in not perfect database

00:50:31,789 --> 00:50:37,749
oriented approaches all right so you may

00:50:36,170 --> 00:50:40,910
need to get your DBA

00:50:37,749 --> 00:50:42,709
okay a better suggestion is to talk to

00:50:40,910 --> 00:50:45,619
him and let him understand your needs

00:50:42,709 --> 00:50:48,319
we're not talking about 70's style

00:50:45,619 --> 00:50:51,229
database normalization we're not talking

00:50:48,319 --> 00:50:53,509
about single database and the problem is

00:50:51,229 --> 00:50:56,150
that Academical and practical knowledge

00:50:53,509 --> 00:50:57,650
really differs here you may have a

00:50:56,150 --> 00:51:00,500
super-efficient of appliqu

00:50:57,650 --> 00:51:02,150
from a memory perspective but then super

00:51:00,500 --> 00:51:04,819
complicated logic to make a query that

00:51:02,150 --> 00:51:07,700
is efficient or you can just stuff the

00:51:04,819 --> 00:51:11,089
data in and non-normalized way into your

00:51:07,700 --> 00:51:13,339
database and it actually works alright

00:51:11,089 --> 00:51:16,730
about performance there's a completely

00:51:13,339 --> 00:51:19,130
other talk about it I'm just going to

00:51:16,730 --> 00:51:21,859
tell you where to look at when you

00:51:19,130 --> 00:51:23,990
profile there was some there were some

00:51:21,859 --> 00:51:27,829
talks about X debug I'm not sure if it

00:51:23,990 --> 00:51:29,480
was also about profiling but there are

00:51:27,829 --> 00:51:31,460
some hotspots that you need to check

00:51:29,480 --> 00:51:32,839
when you look for performance so what

00:51:31,460 --> 00:51:34,940
you do is you look at the unit of work

00:51:32,839 --> 00:51:38,270
which is pretty much everything that

00:51:34,940 --> 00:51:42,020
goes in memory goes here you want to

00:51:38,270 --> 00:51:44,839
look at dql how dql translates the query

00:51:42,020 --> 00:51:46,760
if you're using a paginate ER and the

00:51:44,839 --> 00:51:49,130
paginate er is slow instead of trying to

00:51:46,760 --> 00:51:52,599
hack the paginate er just write a custom

00:51:49,130 --> 00:51:55,400
query yourself it works perfectly okay

00:51:52,599 --> 00:51:57,740
okay the paginate er is a monster it's

00:51:55,400 --> 00:51:59,690
terrible all that code in there is done

00:51:57,740 --> 00:52:02,750
for some kind of compatibility with

00:51:59,690 --> 00:52:06,740
Oracle DBMS SQL and who knows what our

00:52:02,750 --> 00:52:08,720
engine that doesn't support SQL 92 so

00:52:06,740 --> 00:52:11,720
please don't use the paginate er for

00:52:08,720 --> 00:52:14,240
everything repositories custom

00:52:11,720 --> 00:52:16,609
repositories all the way just kill the

00:52:14,240 --> 00:52:19,400
custom repositories you can make a very

00:52:16,609 --> 00:52:20,839
complicated query that doesn't really

00:52:19,400 --> 00:52:23,420
fetch the data in the format that you

00:52:20,839 --> 00:52:26,180
want but returns the thousand entries

00:52:23,420 --> 00:52:28,069
that follow this 10,000 complicated

00:52:26,180 --> 00:52:30,049
business rules instead of doing that you

00:52:28,069 --> 00:52:33,020
can just fetch the 10,000 identifiers

00:52:30,049 --> 00:52:36,349
and then pass them to an in query a

00:52:33,020 --> 00:52:38,150
query with an in condition in it alright

00:52:36,349 --> 00:52:39,980
and the second level cache there's an

00:52:38,150 --> 00:52:42,170
entire talk on this but there's

00:52:39,980 --> 00:52:44,270
documentation about it you should try it

00:52:42,170 --> 00:52:46,609
out it is going to make a big difference

00:52:44,270 --> 00:52:48,589
on the performance of your application

00:52:46,609 --> 00:52:51,890
so you have to profile those hotspots

00:52:48,589 --> 00:52:54,289
and measuring is really the only way to

00:52:51,890 --> 00:52:57,950
get performance there so just write a

00:52:54,289 --> 00:53:01,700
feature and then profile alright there's

00:52:57,950 --> 00:53:04,490
other stuff about it so to recap since

00:53:01,700 --> 00:53:07,579
it's late except for the keynote I'm

00:53:04,490 --> 00:53:10,250
still holding you back here code the

00:53:07,579 --> 00:53:11,510
mine first instead of thinking oh I'm

00:53:10,250 --> 00:53:14,180
going to use this tool

00:53:11,510 --> 00:53:15,890
or that tool or the other tool you have

00:53:14,180 --> 00:53:19,040
to think about what the business needs

00:53:15,890 --> 00:53:23,390
and doctrine may not be the fit for you

00:53:19,040 --> 00:53:27,140
okay you may even just do pure SQL based

00:53:23,390 --> 00:53:29,120
applications that's your preference do

00:53:27,140 --> 00:53:32,860
not normalize without the need for it

00:53:29,120 --> 00:53:35,420
normalization must be a requirement that

00:53:32,860 --> 00:53:36,920
comes from business stuff not a

00:53:35,420 --> 00:53:38,690
requirement just for the sake of

00:53:36,920 --> 00:53:41,780
building a requirement because you want

00:53:38,690 --> 00:53:45,250
to make it nice and shiny okay you're

00:53:41,780 --> 00:53:48,230
just building more problems there and

00:53:45,250 --> 00:53:50,300
use different databases like don't store

00:53:48,230 --> 00:53:53,000
everything in a single database all the

00:53:50,300 --> 00:53:55,760
clogs are valid logs normal logs are

00:53:53,000 --> 00:53:58,100
valid copying data is valid using just

00:53:55,760 --> 00:54:01,070
backups is valid for the soft deletes

00:53:58,100 --> 00:54:04,280
problem and the point is that

00:54:01,070 --> 00:54:07,520
transactional data is not your reporting

00:54:04,280 --> 00:54:09,380
data okay what you deal with like saving

00:54:07,520 --> 00:54:11,390
and loading shopping carts is not

00:54:09,380 --> 00:54:14,000
necessarily the table that will be used

00:54:11,390 --> 00:54:15,650
to generate analytics reports on who

00:54:14,000 --> 00:54:17,630
both or not

00:54:15,650 --> 00:54:19,090
what shopping cart you don't need to

00:54:17,630 --> 00:54:21,550
store everything in the same database

00:54:19,090 --> 00:54:25,400
all right that's all I have for now

00:54:21,550 --> 00:54:31,610
thank you very much please just feel

00:54:25,400 --> 00:54:35,090
free to ask any questions right I'm just

00:54:31,610 --> 00:54:37,430
a MongoDB version of torturing on LY but

00:54:35,090 --> 00:54:41,210
you said we shouldn't use the arm for

00:54:37,430 --> 00:54:43,340
 type of yeah I Namek type database

00:54:41,210 --> 00:54:45,670
no what I mean is that you shouldn't

00:54:43,340 --> 00:54:49,040
have data that is not following

00:54:45,670 --> 00:54:52,630
predictable form so you shouldn't have

00:54:49,040 --> 00:54:55,820
data that is like an integer or a string

00:54:52,630 --> 00:54:56,360
depending on a case-by-case basis that's

00:54:55,820 --> 00:54:58,130
what I mean

00:54:56,360 --> 00:54:59,540
but the is actually a pill for

00:54:58,130 --> 00:55:01,160
that purpose which means is so you

00:54:59,540 --> 00:55:03,800
shouldn't use that you shouldn't use the

00:55:01,160 --> 00:55:06,320
or M for that the MongoDB is just fine

00:55:03,800 --> 00:55:08,330
MongoDB system is perfectly fine for

00:55:06,320 --> 00:55:10,370
that you just use a document storage you

00:55:08,330 --> 00:55:12,860
stuff it with things every time you

00:55:10,370 --> 00:55:14,630
fetch data you have to validate it every

00:55:12,860 --> 00:55:16,340
time you fetch it every time you store

00:55:14,630 --> 00:55:17,540
it you have to validate it but that's

00:55:16,340 --> 00:55:19,940
because you're shifting the

00:55:17,540 --> 00:55:22,730
responsibility of data validation from

00:55:19,940 --> 00:55:24,830
the constraint at DB level into your

00:55:22,730 --> 00:55:25,370
application and you're going to assume

00:55:24,830 --> 00:55:27,020
that the

00:55:25,370 --> 00:55:28,790
a base layer is not changing the data

00:55:27,020 --> 00:55:30,830
which is something that there really

00:55:28,790 --> 00:55:32,720
doesn't happen in most databases because

00:55:30,830 --> 00:55:35,270
somebody's going to write the stored

00:55:32,720 --> 00:55:45,800
procedure or a trigger that does magic

00:55:35,270 --> 00:55:48,080
and so on thank you yeah thank you

00:55:45,800 --> 00:55:50,770
what's the difference between the object

00:55:48,080 --> 00:55:53,600
manager and the entity manager the

00:55:50,770 --> 00:55:55,670
object manager is the interface

00:55:53,600 --> 00:55:57,860
implemented by the entity manager so

00:55:55,670 --> 00:55:59,750
what we did is we extracted the

00:55:57,860 --> 00:56:02,000
interface common to the different

00:55:59,750 --> 00:56:04,700
persistence systems inside document

00:56:02,000 --> 00:56:06,410
project in where move the remove the

00:56:04,700 --> 00:56:09,290
interface into doctrine common and

00:56:06,410 --> 00:56:12,260
that's some very minimal API on how to

00:56:09,290 --> 00:56:17,980
interact with the persistence layer in a

00:56:12,260 --> 00:56:17,980
unit of work fashion thank you all right

00:56:22,450 --> 00:56:28,640
you said at the beginning don't use RMS

00:56:25,220 --> 00:56:31,880
for reporting yes and then you gave us

00:56:28,640 --> 00:56:36,590
an example of get nickname for a user so

00:56:31,880 --> 00:56:40,070
if I wanted that nickname return in a

00:56:36,590 --> 00:56:41,570
reporting so how would I do that and

00:56:40,070 --> 00:56:43,700
what would I use if it's not the earth

00:56:41,570 --> 00:56:46,520
so let's say the nickname is not

00:56:43,700 --> 00:56:48,620
composed by just a field yeah yeah let's

00:56:46,520 --> 00:56:52,370
say the technique name is computed what

00:56:48,620 --> 00:56:54,350
you could do is instead of using

00:56:52,370 --> 00:56:56,570
directly the same database that you're

00:56:54,350 --> 00:56:58,580
using for the transactional data

00:56:56,570 --> 00:57:01,460
assuming that it's a very complex

00:56:58,580 --> 00:57:04,790
computation something like verify if

00:57:01,460 --> 00:57:07,780
password is up-to-date what you can do

00:57:04,790 --> 00:57:10,910
is you just actually create a batch

00:57:07,780 --> 00:57:13,130
processing that copies the data into

00:57:10,910 --> 00:57:15,560
something else which is more reporting

00:57:13,130 --> 00:57:17,780
friendly what you can do is indeed in

00:57:15,560 --> 00:57:19,640
those cases you can use listeners or you

00:57:17,780 --> 00:57:22,130
can use even database level triggers

00:57:19,640 --> 00:57:24,650
that when you do operations on the

00:57:22,130 --> 00:57:27,170
database just copy over the data into a

00:57:24,650 --> 00:57:31,760
more reporting friendly data structure

00:57:27,170 --> 00:57:34,670
but that is because the analytics and

00:57:31,760 --> 00:57:36,350
reporting are usually subsystems of your

00:57:34,670 --> 00:57:38,720
production system they are not really

00:57:36,350 --> 00:57:40,369
usually part of the core domain

00:57:38,720 --> 00:57:42,859
so what happens is that you are just

00:57:40,369 --> 00:57:44,540
writing first the application that

00:57:42,859 --> 00:57:46,720
allows you to display a nickname or

00:57:44,540 --> 00:57:49,730
verify if somebody has a database

00:57:46,720 --> 00:57:51,680
password hash that needs updating and

00:57:49,730 --> 00:57:53,869
then you have a sub system that has the

00:57:51,680 --> 00:57:55,819
reporting on that and that sub system

00:57:53,869 --> 00:57:58,069
comes later that's the point you keep it

00:57:55,819 --> 00:58:00,109
separate and you make sure that the data

00:57:58,069 --> 00:58:02,089
is copied over and it has its own

00:58:00,109 --> 00:58:04,250
queries its own optimization of the

00:58:02,089 --> 00:58:05,750
database its own schema depending on

00:58:04,250 --> 00:58:07,849
their requirements that you have there

00:58:05,750 --> 00:58:09,560
instead of stuffing everything in the

00:58:07,849 --> 00:58:17,290
first database which has completely

00:58:09,560 --> 00:58:21,920
different use cases right thanks right

00:58:17,290 --> 00:58:25,790
well I think that's it I'm gonna leave

00:58:21,920 --> 00:58:28,750
you cur to Dickie nut and catch you

00:58:25,790 --> 00:58:28,750

YouTube URL: https://www.youtube.com/watch?v=rzGeNYC3oz0


