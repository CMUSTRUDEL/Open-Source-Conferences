Title: PHP UK Conference 2016 - Matthew Turland - Mocking Dependencies in Unit Tests with Phake
Publication date: 2016-03-16
Playlist: PHP UK Conference 2016
Description: 
	Reports of the death of TDD have been greatly exaggerated. All but the most trivial of applications make use of the OOP principle of composition and as such require mocking of dependencies in unit tests. While PHPUnit has become the de facto unit testing framework for many projects, its bundled mocking API can leave something to be desired. This presentation is an introduction to Phake, an alternative mocking library with a more concise and intuitive API and a more substantial feature set that removes the headaches from mocking.
Captions: 
	00:00:04,490 --> 00:00:08,240
first I'm going to talk about the

00:00:06,109 --> 00:00:10,490
general practice of mocking what it is

00:00:08,240 --> 00:00:15,019
how it works why we do it all the

00:00:10,490 --> 00:00:18,470
related terminology etc I'm also going

00:00:15,019 --> 00:00:20,630
to discuss how the mocking libraries for

00:00:18,470 --> 00:00:22,250
a PHP that are out there function at a

00:00:20,630 --> 00:00:26,029
high levels that you understand how they

00:00:22,250 --> 00:00:27,800
work so you can better use them and then

00:00:26,029 --> 00:00:30,109
I'm going to dive into some of the more

00:00:27,800 --> 00:00:33,220
commonly used features of specific

00:00:30,109 --> 00:00:37,909
library called fake I will be drawing

00:00:33,220 --> 00:00:40,900
some correlations and insofar as how PHP

00:00:37,909 --> 00:00:43,309
units own mocking library functions and

00:00:40,900 --> 00:00:47,809
points of integration that fake offers

00:00:43,309 --> 00:00:50,869
with PHP unit where they're relevant all

00:00:47,809 --> 00:00:52,400
right so first off if you are not

00:00:50,869 --> 00:00:54,619
already relatively well familiar with

00:00:52,400 --> 00:00:55,729
PHP as a language and its object model a

00:00:54,619 --> 00:00:58,640
lot of this talk is probably gonna be

00:00:55,729 --> 00:01:00,019
over your head so apologies we just we

00:00:58,640 --> 00:01:03,619
have a limited amount of time to cover

00:01:00,019 --> 00:01:06,650
this material lastly to a lesser degree

00:01:03,619 --> 00:01:08,509
knowing phpunit will help as I said I'll

00:01:06,650 --> 00:01:09,500
be mentioning it several times in the

00:01:08,509 --> 00:01:10,969
talks or if you're already familiar with

00:01:09,500 --> 00:01:15,649
it a lot of stuff flower we make sense

00:01:10,969 --> 00:01:18,380
to you to some degree okay so I'm going

00:01:15,649 --> 00:01:20,240
to get right in here um installing fake

00:01:18,380 --> 00:01:23,240
is relatively simple how many people

00:01:20,240 --> 00:01:24,710
familiar with composer have used it good

00:01:23,240 --> 00:01:28,670
I like that number of fans needs to go

00:01:24,710 --> 00:01:30,170
up but good start so you have the option

00:01:28,670 --> 00:01:33,259
to insult with composer you can also

00:01:30,170 --> 00:01:34,280
clone the git repository directly to my

00:01:33,259 --> 00:01:36,950
knowledge there aren't any other

00:01:34,280 --> 00:01:38,630
installation options that are offered I

00:01:36,950 --> 00:01:44,780
highly recommend just using composer

00:01:38,630 --> 00:01:46,939
makes things a lot easier if it does

00:01:44,780 --> 00:01:49,729
have documentation on then i have i

00:01:46,939 --> 00:01:53,450
recommend you review it there are areas

00:01:49,729 --> 00:01:55,130
of it that are a bit sparse or may be

00:01:53,450 --> 00:01:58,219
able to be improved in terms of the

00:01:55,130 --> 00:02:00,079
examples so the maintainer if i'll show

00:01:58,219 --> 00:02:02,149
you here in a second is very receptive

00:02:00,079 --> 00:02:03,530
to pull requests and suggestions and

00:02:02,149 --> 00:02:04,939
improvements i know that because i've

00:02:03,530 --> 00:02:11,030
had to go back and forth with him of it

00:02:04,939 --> 00:02:13,640
myself so check that out okay so this is

00:02:11,030 --> 00:02:15,560
mike a very friendly receptive to

00:02:13,640 --> 00:02:17,200
feedback i filed multiple bug reports

00:02:15,560 --> 00:02:20,239
PRS with them

00:02:17,200 --> 00:02:22,040
there are a few things that are not

00:02:20,239 --> 00:02:24,769
quite fully baked yet that I'll mention

00:02:22,040 --> 00:02:27,260
further in the talk as we find them but

00:02:24,769 --> 00:02:29,060
mike has several other repositories if

00:02:27,260 --> 00:02:30,709
you've worked with the DB unit extension

00:02:29,060 --> 00:02:31,580
to PHP enid at all he was responsible

00:02:30,709 --> 00:02:35,480
for writing that into original

00:02:31,580 --> 00:02:40,370
incarnation so great guy all right so

00:02:35,480 --> 00:02:42,709
unit testing um there's been a big focus

00:02:40,370 --> 00:02:45,739
on testing in general in our industry

00:02:42,709 --> 00:02:47,360
within the past few years unit testing

00:02:45,739 --> 00:02:48,799
tends to be the form that most people

00:02:47,360 --> 00:02:51,079
are familiar with it's the form that

00:02:48,799 --> 00:02:54,829
tends to be emphasized the most when

00:02:51,079 --> 00:02:57,799
talking about testing a lot of people

00:02:54,829 --> 00:02:59,959
don't necessarily learn as part of that

00:02:57,799 --> 00:03:01,910
education the different types of tests

00:02:59,959 --> 00:03:04,790
there are how they're different and when

00:03:01,910 --> 00:03:05,959
it's more appropriate to use them so in

00:03:04,790 --> 00:03:07,489
unit testing I wanted to stress that

00:03:05,959 --> 00:03:10,519
what you're trying to do is test the

00:03:07,489 --> 00:03:12,109
lowest level parts of your code and

00:03:10,519 --> 00:03:15,230
importantly you're doing them in

00:03:12,109 --> 00:03:17,209
isolation from each other so that when

00:03:15,230 --> 00:03:18,620
you're testing one piece of code that

00:03:17,209 --> 00:03:23,060
may be dependent on another piece of

00:03:18,620 --> 00:03:25,040
code that you are properly limiting the

00:03:23,060 --> 00:03:26,480
code that you're actually testing to the

00:03:25,040 --> 00:03:27,859
class under test rather than testing

00:03:26,480 --> 00:03:29,060
both of them together because that's a

00:03:27,859 --> 00:03:32,630
different type of testing that we'll

00:03:29,060 --> 00:03:34,299
talk about here in a minute okay so most

00:03:32,630 --> 00:03:36,530
of you have probably heard of phpunit

00:03:34,299 --> 00:03:38,209
there are a few other testing frameworks

00:03:36,530 --> 00:03:39,530
out there but by and large it tends to

00:03:38,209 --> 00:03:43,280
be sort of the de facto one that people

00:03:39,530 --> 00:03:44,900
tend to use out in the community it's

00:03:43,280 --> 00:03:47,269
modeled if you've used a unit before you

00:03:44,900 --> 00:03:50,620
probably will recognize a lot of

00:03:47,269 --> 00:03:52,940
concepts from from its Java counterpart

00:03:50,620 --> 00:03:54,590
so Sebastian Bergman is the maintainer

00:03:52,940 --> 00:03:57,620
of each unit along with a lot of other

00:03:54,590 --> 00:03:58,940
supporting libraries for it a great guy

00:03:57,620 --> 00:04:01,280
we talked back and forth over the years

00:03:58,940 --> 00:04:04,099
I don't think he's here unfortunately

00:04:01,280 --> 00:04:05,329
but you can check out more posts from

00:04:04,099 --> 00:04:07,069
him he's got a blog he talks about

00:04:05,329 --> 00:04:11,690
phpunit quite a bit that is a great

00:04:07,069 --> 00:04:13,849
resource okay so integration testing is

00:04:11,690 --> 00:04:17,599
the other type of testing that I alluded

00:04:13,849 --> 00:04:18,739
to and this is where you test points

00:04:17,599 --> 00:04:20,539
where you're actually combining multiple

00:04:18,739 --> 00:04:23,810
different sets of code generally

00:04:20,539 --> 00:04:26,960
speaking classes in your code base and

00:04:23,810 --> 00:04:28,550
you're testing those integrations one

00:04:26,960 --> 00:04:29,400
rather interesting example that I saw

00:04:28,550 --> 00:04:30,600
visually and

00:04:29,400 --> 00:04:32,850
personally I didn't capture at the time

00:04:30,600 --> 00:04:34,770
was two doors in the building that are

00:04:32,850 --> 00:04:37,050
set side by side that opened this way

00:04:34,770 --> 00:04:38,310
and individually the doors open to sign

00:04:37,050 --> 00:04:39,960
but if you try to open them both at the

00:04:38,310 --> 00:04:41,669
same time they hit each other and they

00:04:39,960 --> 00:04:43,050
don't open that's an example of where

00:04:41,669 --> 00:04:45,479
unit tests would pass but the

00:04:43,050 --> 00:04:51,030
integration tests would fail to give you

00:04:45,479 --> 00:04:52,710
an idea so as an example one specific

00:04:51,030 --> 00:04:54,180
form of integration testing that I

00:04:52,710 --> 00:04:57,470
mentioned before is database testing

00:04:54,180 --> 00:05:01,949
which the DB unit extension to phpunit

00:04:57,470 --> 00:05:04,229
covers that's work so if you've ever had

00:05:01,949 --> 00:05:05,580
a test like this this is not a unit test

00:05:04,229 --> 00:05:08,070
this is an integration test and it's

00:05:05,580 --> 00:05:09,330
very important to distinguish them for

00:05:08,070 --> 00:05:13,350
reasons that will go into here in a

00:05:09,330 --> 00:05:17,190
second so where unit tests are more

00:05:13,350 --> 00:05:19,229
appropriate is our cases where say you

00:05:17,190 --> 00:05:20,699
co is contacting a third-party API you

00:05:19,229 --> 00:05:22,620
don't necessarily want to hit the API

00:05:20,699 --> 00:05:25,349
actively in as part of your test you

00:05:22,620 --> 00:05:27,810
want to limit that to production so this

00:05:25,349 --> 00:05:29,250
may be a good case we're not mocking

00:05:27,810 --> 00:05:32,789
we'll do something for you essentially

00:05:29,250 --> 00:05:35,940
it will let you inject a fake version of

00:05:32,789 --> 00:05:38,280
the client for this API and have that

00:05:35,940 --> 00:05:39,990
code simply return a response as if it

00:05:38,280 --> 00:05:41,340
actually hit the service so that you're

00:05:39,990 --> 00:05:46,880
able to test but you don't actually have

00:05:41,340 --> 00:05:51,090
to hit the active service yourself one

00:05:46,880 --> 00:05:54,120
con to this is that if I have a piece of

00:05:51,090 --> 00:05:57,320
code and it's dependent on a separate

00:05:54,120 --> 00:06:00,710
class if i change that dependent class

00:05:57,320 --> 00:06:03,720
tests from both suites may start to fail

00:06:00,710 --> 00:06:05,789
whereas with mocking since you're

00:06:03,720 --> 00:06:08,190
specifically programming behavior into

00:06:05,789 --> 00:06:10,830
the mock objects if you change the

00:06:08,190 --> 00:06:12,990
dependent class your test won't

00:06:10,830 --> 00:06:16,199
necessarily fail for the code that's

00:06:12,990 --> 00:06:17,340
dependent on it so it's important to

00:06:16,199 --> 00:06:19,050
understand that in cases with an

00:06:17,340 --> 00:06:20,760
integration test if i change an

00:06:19,050 --> 00:06:22,169
underlying class in a way that's not

00:06:20,760 --> 00:06:23,490
compatible both tests would start

00:06:22,169 --> 00:06:28,139
failing and i wouldn't necessarily know

00:06:23,490 --> 00:06:30,330
why so this is an example of a class

00:06:28,139 --> 00:06:33,000
that we might like to test so here i'm

00:06:30,330 --> 00:06:36,000
programming a client for a specific rest

00:06:33,000 --> 00:06:37,349
service i'm using the guzzle HTTP client

00:06:36,000 --> 00:06:40,860
library which if you're not familiar is

00:06:37,349 --> 00:06:41,700
great check it out um so I'm injecting

00:06:40,860 --> 00:06:44,400
an instance

00:06:41,700 --> 00:06:47,640
of the low-level HTTP client but Gullah

00:06:44,400 --> 00:06:49,110
provides into the constructor here and

00:06:47,640 --> 00:06:50,850
then somewhere else in the class i'm

00:06:49,110 --> 00:06:54,890
actually using that client to hit the

00:06:50,850 --> 00:06:58,590
web service so we want to be able to

00:06:54,890 --> 00:07:00,990
test my class but we don't want to rely

00:06:58,590 --> 00:07:02,460
on guzzles implementation of this

00:07:00,990 --> 00:07:03,980
interface in order to be able to do it

00:07:02,460 --> 00:07:06,390
because of something doesn't change 'as

00:07:03,980 --> 00:07:07,410
well then suddenly i attest that may be

00:07:06,390 --> 00:07:08,670
feeling a little bit of place and i

00:07:07,410 --> 00:07:10,500
don't know why i mean not necessarily

00:07:08,670 --> 00:07:14,190
realize that the update and upgrade say

00:07:10,500 --> 00:07:15,660
caused it all i want to know by my unit

00:07:14,190 --> 00:07:19,610
tests for this class is that the

00:07:15,660 --> 00:07:19,610
functionality in this class is correct

00:07:20,090 --> 00:07:27,930
anybody heard the phrase test levels

00:07:22,260 --> 00:07:30,870
before few of you okay okay so when I

00:07:27,930 --> 00:07:32,690
talk about mock objects what I mean is

00:07:30,870 --> 00:07:36,180
basically that we're going to create

00:07:32,690 --> 00:07:38,340
objects that in the case of my previous

00:07:36,180 --> 00:07:41,250
code example that I used will have the

00:07:38,340 --> 00:07:43,530
same public interface as this client

00:07:41,250 --> 00:07:45,090
that I'm injecting but the thing is is

00:07:43,530 --> 00:07:47,120
that I will basically tell those methods

00:07:45,090 --> 00:07:49,950
exactly how to behave I'll tell them

00:07:47,120 --> 00:07:51,030
what values to return I'll tell them if

00:07:49,950 --> 00:07:54,000
they need to do anything that may be

00:07:51,030 --> 00:07:55,740
specific to the test I'm basically

00:07:54,000 --> 00:07:57,630
taking the original logic out of the

00:07:55,740 --> 00:07:59,520
equation and I'm telling it ok this is

00:07:57,630 --> 00:08:02,250
the behavior that I want to test my code

00:07:59,520 --> 00:08:03,780
with so if you return this value I'm

00:08:02,250 --> 00:08:05,100
going to test for this if you want to

00:08:03,780 --> 00:08:09,440
return that value want to test for that

00:08:05,100 --> 00:08:12,570
and test levels are what let us do this

00:08:09,440 --> 00:08:13,920
so yeah the term test levels is used to

00:08:12,570 --> 00:08:16,200
sort of a more general phrase to

00:08:13,920 --> 00:08:18,510
encompass a few different concepts one

00:08:16,200 --> 00:08:20,820
of these is mock objects so essentially

00:08:18,510 --> 00:08:24,000
these are objects that like I say mimic

00:08:20,820 --> 00:08:25,740
the same public interface and the

00:08:24,000 --> 00:08:27,960
behavior of the actual class in a

00:08:25,740 --> 00:08:30,120
controlled way so I could for example

00:08:27,960 --> 00:08:31,320
create a lock of this HTTP client and

00:08:30,120 --> 00:08:33,150
then say i want you to return this

00:08:31,320 --> 00:08:35,849
specific response this is the behavior

00:08:33,150 --> 00:08:44,280
that i want you two to exhibit while i'm

00:08:35,849 --> 00:08:46,700
testing the specific code ok so we have

00:08:44,280 --> 00:08:50,760
something of a problem we can't just

00:08:46,700 --> 00:08:53,760
create mock objects from anything we

00:08:50,760 --> 00:08:54,960
actually have to create objects that in

00:08:53,760 --> 00:08:56,940
particular will pass

00:08:54,960 --> 00:08:59,970
type in checks so if you notice in my

00:08:56,940 --> 00:09:02,940
cover back here sorry then the

00:08:59,970 --> 00:09:05,030
constructor I'm type hinting the client

00:09:02,940 --> 00:09:08,580
interface variable that I want to eject

00:09:05,030 --> 00:09:10,320
so in order for this to work with my

00:09:08,580 --> 00:09:11,640
order for this mock that I want to

00:09:10,320 --> 00:09:15,810
reject to work with my code it has to

00:09:11,640 --> 00:09:19,530
pass this check so given thp object

00:09:15,810 --> 00:09:22,380
sorry ph peets object model if i want to

00:09:19,530 --> 00:09:25,890
mock a class then the mock object has to

00:09:22,380 --> 00:09:27,030
be a subclass of it essentially if i

00:09:25,890 --> 00:09:30,020
want to mock an interface the mock

00:09:27,030 --> 00:09:32,250
object has to implement that interface

00:09:30,020 --> 00:09:33,810
so any the one these circumstances the

00:09:32,250 --> 00:09:35,220
mock object that would be able to pass

00:09:33,810 --> 00:09:38,580
in and it would pass the type in check

00:09:35,220 --> 00:09:40,500
and be able to go on its merry way okay

00:09:38,580 --> 00:09:43,980
so this is an example of what mocking an

00:09:40,500 --> 00:09:45,720
object actually looks like in fake so

00:09:43,980 --> 00:09:47,240
taking my previous example if I have

00:09:45,720 --> 00:09:50,310
this West client that I want to test

00:09:47,240 --> 00:09:52,290
I've got this test case I want to test

00:09:50,310 --> 00:09:54,030
the its constructor to make sure that

00:09:52,290 --> 00:09:58,520
the dependency injection works

00:09:54,030 --> 00:10:01,170
sufficiently so I'm calling a the mock

00:09:58,520 --> 00:10:03,390
static method on the fake class i'm

00:10:01,170 --> 00:10:06,600
specifying the class that I want to get

00:10:03,390 --> 00:10:09,210
a mock object of and then I'm passing it

00:10:06,600 --> 00:10:11,460
in now you'll see just for the purposes

00:10:09,210 --> 00:10:14,220
of example I'm outputting something here

00:10:11,460 --> 00:10:17,730
which is the class that the mock object

00:10:14,220 --> 00:10:19,110
is an instance of and you'll see it's it

00:10:17,730 --> 00:10:21,390
looks like garbage here and i'll explain

00:10:19,110 --> 00:10:24,990
a bit more as we go along why this is

00:10:21,390 --> 00:10:26,580
the way it is but for the moment just to

00:10:24,990 --> 00:10:28,730
give you an idea what mocking an object

00:10:26,580 --> 00:10:31,920
and fake looks like at a very simplistic

00:10:28,730 --> 00:10:37,710
circumstance that's what this code

00:10:31,920 --> 00:10:39,600
reflects okay so if I have a mock object

00:10:37,710 --> 00:10:41,820
and I want to replace the pave yer of a

00:10:39,600 --> 00:10:45,240
specific method that process is called

00:10:41,820 --> 00:10:49,020
stomach so if i wanted to return

00:10:45,240 --> 00:10:51,390
specific values throw an exception or

00:10:49,020 --> 00:10:55,710
something of that nature stuffing would

00:10:51,390 --> 00:10:57,600
be what I would be doing so let's take

00:10:55,710 --> 00:10:59,700
an actual look at some code so here in

00:10:57,600 --> 00:11:01,380
my rest client I've got a method called

00:10:59,700 --> 00:11:06,900
get thing and I'm passing it some

00:11:01,380 --> 00:11:08,570
specific ID um so further down I'm

00:11:06,900 --> 00:11:10,190
actually calling the get method

00:11:08,570 --> 00:11:13,160
on the client that I've injected the

00:11:10,190 --> 00:11:16,280
instance of the guzzle client and I'm

00:11:13,160 --> 00:11:18,620
passing it in a specific URL that

00:11:16,280 --> 00:11:20,780
includes the ID that I passed and I get

00:11:18,620 --> 00:11:22,190
a response back and then at that point I

00:11:20,780 --> 00:11:24,560
take that response object and I'm

00:11:22,190 --> 00:11:27,380
returning the response in the

00:11:24,560 --> 00:11:30,260
responsible body which I'm assuming to

00:11:27,380 --> 00:11:31,940
bj's on so what we're going to have to

00:11:30,260 --> 00:11:35,030
do here is we have to modify the

00:11:31,940 --> 00:11:37,640
behavior of the client object such that

00:11:35,030 --> 00:11:39,350
when i call get it's going to return a

00:11:37,640 --> 00:11:40,930
response object as would be appropriate

00:11:39,350 --> 00:11:44,180
if I was actually hitting the service

00:11:40,930 --> 00:11:47,450
then we have to take that response

00:11:44,180 --> 00:11:51,820
object and stub its JSON method so that

00:11:47,450 --> 00:11:51,820
it returns the right thing essentially

00:11:52,510 --> 00:11:57,620
so when doing this sorry to go back real

00:11:55,910 --> 00:11:59,480
quick too in doing this what will end up

00:11:57,620 --> 00:12:01,520
happening is that get thing will return

00:11:59,480 --> 00:12:03,800
whatever the response objects JSON

00:12:01,520 --> 00:12:06,560
method stub returns and I'll be able to

00:12:03,800 --> 00:12:10,760
verify that my method does exactly what

00:12:06,560 --> 00:12:12,710
you see here so looking at what a test

00:12:10,760 --> 00:12:16,060
like this would look like um I'm not

00:12:12,710 --> 00:12:18,020
I've omitted a lot of the phpunit

00:12:16,060 --> 00:12:20,600
boilerplate code just for the sake of

00:12:18,020 --> 00:12:21,890
simplicity so just consider that you

00:12:20,600 --> 00:12:23,570
would have these use directives at the

00:12:21,890 --> 00:12:27,080
top of your test suite and then the code

00:12:23,570 --> 00:12:29,480
below it would be one of your tests so

00:12:27,080 --> 00:12:31,070
here I've got the data that I would

00:12:29,480 --> 00:12:34,040
assume the web service will be returning

00:12:31,070 --> 00:12:36,860
for this specific request for the down

00:12:34,040 --> 00:12:40,340
I'm calling fake mock I need to get my

00:12:36,860 --> 00:12:41,780
response mock object that the client

00:12:40,340 --> 00:12:44,960
will return when I actually make the

00:12:41,780 --> 00:12:47,570
request because at that point I need to

00:12:44,960 --> 00:12:51,940
say okay on this response mock I needed

00:12:47,570 --> 00:12:51,940
to JSON method to return this data

00:12:52,840 --> 00:12:57,980
following that I'm knocking the client

00:12:55,400 --> 00:12:59,540
and then I am Telling it when this get

00:12:57,980 --> 00:13:00,860
request comes through then this get

00:12:59,540 --> 00:13:02,210
method is called then I need you to

00:13:00,860 --> 00:13:05,630
return this month response object that

00:13:02,210 --> 00:13:08,540
I've created so at that point I inject

00:13:05,630 --> 00:13:12,050
the mock HTTP client into my rest client

00:13:08,540 --> 00:13:13,820
class I call the public method on that

00:13:12,050 --> 00:13:17,360
rest client get thing pass of the value

00:13:13,820 --> 00:13:19,400
and then when I get that thing back I'm

00:13:17,360 --> 00:13:21,890
checking it against the data that I told

00:13:19,400 --> 00:13:22,190
the response to return to verify that my

00:13:21,890 --> 00:13:25,190
meth

00:13:22,190 --> 00:13:27,320
get thing actually makes the request get

00:13:25,190 --> 00:13:29,480
the response back returns to JSON

00:13:27,320 --> 00:13:30,440
equivalent I know it's a bit much to

00:13:29,480 --> 00:13:33,400
follow is anybody have any questions

00:13:30,440 --> 00:13:41,690
before we move on is this make sense

00:13:33,400 --> 00:13:43,190
good all right so um there are several

00:13:41,690 --> 00:13:45,590
different behaviors that you can use

00:13:43,190 --> 00:13:47,350
when you stub methods a fake refers to

00:13:45,590 --> 00:13:49,990
these answers I haven't really seen a

00:13:47,350 --> 00:13:52,160
consistent use of terminology there so

00:13:49,990 --> 00:13:53,360
phpunit sone mugging library may be

00:13:52,160 --> 00:13:57,080
trying something different they call it

00:13:53,360 --> 00:14:01,070
something different um so by default all

00:13:57,080 --> 00:14:03,080
mock object methods in a fake mock

00:14:01,070 --> 00:14:04,610
object will return null that's a default

00:14:03,080 --> 00:14:07,210
behavior they won't do anything else

00:14:04,610 --> 00:14:09,440
otherwise that's basically I know I um

00:14:07,210 --> 00:14:11,690
so other things that you can do you can

00:14:09,440 --> 00:14:13,760
have it return a specific value you can

00:14:11,690 --> 00:14:16,370
have it invoke a call back this callback

00:14:13,760 --> 00:14:18,110
will receive any arguments that the mock

00:14:16,370 --> 00:14:19,790
objects method receives when you call it

00:14:18,110 --> 00:14:21,830
and then we'll return whatever that

00:14:19,790 --> 00:14:24,170
callback returns so effectively allows

00:14:21,830 --> 00:14:26,090
you to do it to inject some specific

00:14:24,170 --> 00:14:29,150
logic into the stub that you want to

00:14:26,090 --> 00:14:31,880
have happen it can also throw an

00:14:29,150 --> 00:14:33,680
exception that's that's the use case

00:14:31,880 --> 00:14:35,180
that you want to test a fake also allows

00:14:33,680 --> 00:14:36,830
you to program your own custom answers

00:14:35,180 --> 00:14:40,180
if you want to go even further than this

00:14:36,830 --> 00:14:40,180
but these are kind of your basic ones

00:14:40,450 --> 00:14:48,260
alright so there are some other issues

00:14:45,140 --> 00:14:51,500
with this whole marketing process excuse

00:14:48,260 --> 00:14:53,150
me um so you'll remember earlier that I

00:14:51,500 --> 00:14:55,280
said that if I wanted to knock a class

00:14:53,150 --> 00:14:58,940
essentially what this what fake is doing

00:14:55,280 --> 00:15:01,730
is creating a subclass of the classes

00:14:58,940 --> 00:15:04,130
that I'm mocking and then I'm able to

00:15:01,730 --> 00:15:05,780
create stubs on those methods now in the

00:15:04,130 --> 00:15:07,670
case of private methods there was those

00:15:05,780 --> 00:15:09,770
are not accessible to subclasses they

00:15:07,670 --> 00:15:13,720
can't be invoked by a subclass only the

00:15:09,770 --> 00:15:17,870
original parent class can see them so

00:15:13,720 --> 00:15:21,050
you can test private methods directly in

00:15:17,870 --> 00:15:23,089
fact there's a feature in PHP's

00:15:21,050 --> 00:15:25,310
reflection library that was added

00:15:23,089 --> 00:15:27,860
specifically for this purpose to where

00:15:25,310 --> 00:15:31,130
you can actually change the

00:15:27,860 --> 00:15:33,110
accessibility of the method the only

00:15:31,130 --> 00:15:34,120
caveat to this is that the method itself

00:15:33,110 --> 00:15:36,100
can't be invoked

00:15:34,120 --> 00:15:38,320
directly effectively what PHP is doing

00:15:36,100 --> 00:15:40,420
is giving you a reference to that method

00:15:38,320 --> 00:15:44,230
that you can call in the context of some

00:15:40,420 --> 00:15:45,370
specific object and I'll show you a bit

00:15:44,230 --> 00:15:49,480
more what that looks like in a second

00:15:45,370 --> 00:15:51,040
it's a bit odd but so fake does have a

00:15:49,480 --> 00:15:54,040
feature to support calling non public

00:15:51,040 --> 00:15:55,570
methods on mocks um it's a little

00:15:54,040 --> 00:15:56,500
difficult to follow hopefully the

00:15:55,570 --> 00:15:57,820
example that I'll show you here in a

00:15:56,500 --> 00:16:01,630
minute will kind of clarify how it works

00:15:57,820 --> 00:16:04,120
um overall though I would generally

00:16:01,630 --> 00:16:06,100
encourage you to test private methods by

00:16:04,120 --> 00:16:09,310
calling the public methods that call

00:16:06,100 --> 00:16:13,390
them it's just easier to deal with saves

00:16:09,310 --> 00:16:14,740
you a lot of headache so let's look at

00:16:13,390 --> 00:16:18,700
some actual examples what this looks

00:16:14,740 --> 00:16:22,210
like so here I've got a class it's got a

00:16:18,700 --> 00:16:26,350
private method that I want to be able to

00:16:22,210 --> 00:16:27,610
invoke so what I'm doing is I've got a

00:16:26,350 --> 00:16:30,339
parameter that I want to pass it called

00:16:27,610 --> 00:16:32,710
DB row I'm calling the partial mock

00:16:30,339 --> 00:16:35,710
method of fake passing it the name of

00:16:32,710 --> 00:16:39,190
the class it's giving me the mock object

00:16:35,710 --> 00:16:41,200
instance I am then taking that incidence

00:16:39,190 --> 00:16:45,250
passing it to fakes make visible method

00:16:41,200 --> 00:16:47,650
and at that point um I'm able to invoke

00:16:45,250 --> 00:16:51,000
any nonpublic methods on the subject

00:16:47,650 --> 00:16:53,440
directly as you can see here um I

00:16:51,000 --> 00:16:55,540
believe this worse under the hood by

00:16:53,440 --> 00:16:58,330
using some proxies there's some sort of

00:16:55,540 --> 00:16:59,529
dark magic there that I don't quite

00:16:58,330 --> 00:17:06,900
understand to be perfectly honest it's

00:16:59,529 --> 00:17:08,920
out typically speaking there's also the

00:17:06,900 --> 00:17:11,380
method by which you can use the

00:17:08,920 --> 00:17:13,089
reflection api that i mentioned to do

00:17:11,380 --> 00:17:16,660
this directly i believe fake uses this

00:17:13,089 --> 00:17:18,400
under the hood somewhere um so what I'm

00:17:16,660 --> 00:17:21,699
doing is I've got my class I've got my

00:17:18,400 --> 00:17:23,170
private method I'm instinct sheeting

00:17:21,699 --> 00:17:24,910
reflection method specifying the class

00:17:23,170 --> 00:17:26,439
in the method that I want to invoke I'm

00:17:24,910 --> 00:17:28,059
calling said accessible on that

00:17:26,439 --> 00:17:30,760
reflection method instance and passing

00:17:28,059 --> 00:17:32,440
it true and then at that point on that

00:17:30,760 --> 00:17:34,240
same method instance i'm calling invoke

00:17:32,440 --> 00:17:37,870
and I'm passing it an instance of the

00:17:34,240 --> 00:17:40,120
class so this method will be invoked in

00:17:37,870 --> 00:17:42,610
the context of this class as though this

00:17:40,120 --> 00:17:44,140
instance was represented by the special

00:17:42,610 --> 00:17:46,990
disc variable that you'd normally see in

00:17:44,140 --> 00:17:47,800
classes this is another option generally

00:17:46,990 --> 00:17:49,420
speaking

00:17:47,800 --> 00:17:51,250
as I said it's probably better to just

00:17:49,420 --> 00:17:53,350
test private methods by invoking public

00:17:51,250 --> 00:17:57,700
ones your tests end up being a lot less

00:17:53,350 --> 00:17:59,110
messy for it okay so what other problems

00:17:57,700 --> 00:18:00,520
static methods can't be stubbed because

00:17:59,110 --> 00:18:04,990
they're bound to the original parent

00:18:00,520 --> 00:18:06,640
class name um you can do this if you are

00:18:04,990 --> 00:18:11,620
using late static binding in your class

00:18:06,640 --> 00:18:12,850
that's a whole subject on its own um I'd

00:18:11,620 --> 00:18:14,560
have included some references here in

00:18:12,850 --> 00:18:17,980
both bacon phpunit as to how this works

00:18:14,560 --> 00:18:20,080
and i'll show you an example um and fake

00:18:17,980 --> 00:18:22,840
i'm not quite sure this is working right

00:18:20,080 --> 00:18:24,760
yet holding mike will fix it he's aware

00:18:22,840 --> 00:18:27,790
of the problem so but just to give you

00:18:24,760 --> 00:18:29,890
an idea of how it should work um I've

00:18:27,790 --> 00:18:31,450
got my class I've got a public property

00:18:29,890 --> 00:18:33,010
called lager I've got a method that

00:18:31,450 --> 00:18:35,470
actually does something with this long

00:18:33,010 --> 00:18:38,470
our object in particular it calls this

00:18:35,470 --> 00:18:41,650
static log data method on it by default

00:18:38,470 --> 00:18:43,960
i'm using the string logger which refers

00:18:41,650 --> 00:18:45,490
to a lower class somewhere so that when

00:18:43,960 --> 00:18:48,400
this static method is invoked it's just

00:18:45,490 --> 00:18:50,110
invoked based on the class name now the

00:18:48,400 --> 00:18:53,170
way that I understand it what PHP will

00:18:50,110 --> 00:18:55,660
do is that if logger as part of that log

00:18:53,170 --> 00:18:57,490
data call is an instance PHP will just

00:18:55,660 --> 00:19:00,160
resolve it to the class and then invoke

00:18:57,490 --> 00:19:03,400
the corresponding static method that's

00:19:00,160 --> 00:19:06,100
how it's supposed to work so in my test

00:19:03,400 --> 00:19:08,410
chair I'm creating a mock object for the

00:19:06,100 --> 00:19:11,800
logger I'm invoking the method on my

00:19:08,410 --> 00:19:14,950
actual foo class and then calling a fake

00:19:11,800 --> 00:19:17,830
verify to confirm that the log data

00:19:14,950 --> 00:19:21,370
method was actually called with whatever

00:19:17,830 --> 00:19:23,590
parameters were available so just

00:19:21,370 --> 00:19:25,030
something to be aware of in case it does

00:19:23,590 --> 00:19:29,380
start working in a release fairly soon

00:19:25,030 --> 00:19:34,720
but there's an easier way that I tend to

00:19:29,380 --> 00:19:35,980
recommend is that well one tried to

00:19:34,720 --> 00:19:37,060
avoid using statics in the first place

00:19:35,980 --> 00:19:38,770
quite honestly I think they're more of

00:19:37,060 --> 00:19:41,830
an edge case feature in the language but

00:19:38,770 --> 00:19:45,100
that's my opinion so how you can do this

00:19:41,830 --> 00:19:47,350
is that if say your code has to make a

00:19:45,100 --> 00:19:48,460
call to a static method in some of the

00:19:47,350 --> 00:19:51,970
library you're probably going to find

00:19:48,460 --> 00:19:53,440
yourself in that situation um what i'm

00:19:51,970 --> 00:19:54,660
doing here is that I've got this class

00:19:53,440 --> 00:19:58,540
with a static method that I want to call

00:19:54,660 --> 00:20:01,380
I've got my own class that's actually

00:19:58,540 --> 00:20:04,650
calling it what I'm basically doing here

00:20:01,380 --> 00:20:06,360
taking that static method call wrapping

00:20:04,650 --> 00:20:08,460
in an instance method and I'm just

00:20:06,360 --> 00:20:10,680
invoking the static method and returning

00:20:08,460 --> 00:20:13,650
whatever it returns because at this

00:20:10,680 --> 00:20:15,690
point because the protected method is

00:20:13,650 --> 00:20:17,070
well sorry because my instance method is

00:20:15,690 --> 00:20:19,860
protected and because it's an instance

00:20:17,070 --> 00:20:25,590
method when I get to around you actually

00:20:19,860 --> 00:20:27,090
marking my class what i can do is sub

00:20:25,590 --> 00:20:28,950
the instance method that i've created

00:20:27,090 --> 00:20:31,730
essentially so that's one way of sort of

00:20:28,950 --> 00:20:37,500
indirectly stubbing a static method it's

00:20:31,730 --> 00:20:42,720
not the pretty but it works so that's an

00:20:37,500 --> 00:20:44,670
option to be aware of okay final methods

00:20:42,720 --> 00:20:47,520
I think are the last large problem and

00:20:44,670 --> 00:20:50,520
i'll talk about as far as the whole way

00:20:47,520 --> 00:20:51,720
that mocking works so if you're not

00:20:50,520 --> 00:20:54,240
familiar with final essentially it

00:20:51,720 --> 00:20:56,640
prevents you from overriding methods or

00:20:54,240 --> 00:20:59,490
the case of classes extending classes so

00:20:56,640 --> 00:21:03,390
you can't stop final methods and you

00:20:59,490 --> 00:21:06,570
can't mock or stub final classes so if

00:21:03,390 --> 00:21:09,120
you notice in my example here if you do

00:21:06,570 --> 00:21:11,730
attempt to stub a final method if the

00:21:09,120 --> 00:21:13,320
code will run but the behavior will not

00:21:11,730 --> 00:21:15,300
actually be changed this tub will not

00:21:13,320 --> 00:21:16,890
actually take effect so to speak the

00:21:15,300 --> 00:21:23,850
original behavior will be invoked so

00:21:16,890 --> 00:21:26,160
just something to be aware of ok so this

00:21:23,850 --> 00:21:27,690
code example is fairly similar to the

00:21:26,160 --> 00:21:29,490
last one that I used with static methods

00:21:27,690 --> 00:21:31,710
essentially I'm just wrapping the final

00:21:29,490 --> 00:21:33,270
method call and an instance method of

00:21:31,710 --> 00:21:34,650
another class and then I'm stuffing that

00:21:33,270 --> 00:21:36,990
instance method so it's the exact same

00:21:34,650 --> 00:21:43,350
approach allows you to get around this

00:21:36,990 --> 00:21:45,180
issue just an option again not not my

00:21:43,350 --> 00:21:49,350
preference I just didn't refer but that

00:21:45,180 --> 00:21:50,610
doesn't use final in general but ok this

00:21:49,350 --> 00:21:54,990
sorry there's one of the small caveat

00:21:50,610 --> 00:21:56,940
you can stub any method um because the

00:21:54,990 --> 00:21:59,220
way that fake mock objects work under

00:21:56,940 --> 00:22:01,470
the hood they actually do use call all

00:21:59,220 --> 00:22:05,790
ready themselves for making all the

00:22:01,470 --> 00:22:07,670
mocking magic magic happen so if for

00:22:05,790 --> 00:22:10,500
some reason you do want the stub call

00:22:07,670 --> 00:22:12,669
and that's instance what you can do is

00:22:10,500 --> 00:22:14,889
you can either stop the method that call

00:22:12,669 --> 00:22:18,789
would trigger the because it doesn't

00:22:14,889 --> 00:22:21,539
exist when you call it or you can use a

00:22:18,789 --> 00:22:24,220
special notation to stub call itself so

00:22:21,539 --> 00:22:26,649
in that instance on my last two lines

00:22:24,220 --> 00:22:28,629
here I'm calling a win call method with

00:22:26,649 --> 00:22:29,739
on fake passing it the name of the

00:22:28,629 --> 00:22:32,139
method that I would be calling that

00:22:29,739 --> 00:22:33,820
doesn't actually exist the second

00:22:32,139 --> 00:22:35,799
parameter is any arguments that I would

00:22:33,820 --> 00:22:38,950
want to Pat passed to that method when

00:22:35,799 --> 00:22:40,960
it's called as specifying the mock

00:22:38,950 --> 00:22:42,220
object that I expect the method to be

00:22:40,960 --> 00:22:45,639
called on and then i'm specifying the

00:22:42,220 --> 00:22:47,499
stuff that i want to be used so aside

00:22:45,639 --> 00:22:48,999
from call though pretty much any other

00:22:47,499 --> 00:22:54,090
method should be able to be mocked or

00:22:48,999 --> 00:22:56,379
stubs rather excuse me as normal so

00:22:54,090 --> 00:22:58,600
there may be instances where depending

00:22:56,379 --> 00:23:00,700
on what parameters are passed into a

00:22:58,600 --> 00:23:02,559
specific method of the mock object you

00:23:00,700 --> 00:23:04,600
may want to vary the stuff that's used

00:23:02,559 --> 00:23:06,970
so here what I'm doing is I've got a

00:23:04,600 --> 00:23:08,230
class it takes it as one method takes

00:23:06,970 --> 00:23:11,859
two parameters and it just returns the

00:23:08,230 --> 00:23:13,480
sum so when I mock this class I mean

00:23:11,859 --> 00:23:14,769
obviously I'm going to want to vary the

00:23:13,480 --> 00:23:17,950
return value based on the parameters

00:23:14,769 --> 00:23:19,659
that are passed in so i specify that if

00:23:17,950 --> 00:23:21,340
i call add with 0 and 2 i wanted to

00:23:19,659 --> 00:23:25,359
return to if i call it with 2 and

00:23:21,340 --> 00:23:27,159
negative 2 11 to return 0 so if suming

00:23:25,359 --> 00:23:28,690
you want to have multiple calls to the

00:23:27,159 --> 00:23:30,940
same method with different arguments

00:23:28,690 --> 00:23:32,590
exhibit different behavior this would be

00:23:30,940 --> 00:23:38,080
how you would specify that the mock

00:23:32,590 --> 00:23:40,869
objects should behave this way ok if you

00:23:38,080 --> 00:23:42,850
want to make multiple calls to the same

00:23:40,869 --> 00:23:46,149
method with the same arguments and still

00:23:42,850 --> 00:23:48,460
have the east of behavior very what you

00:23:46,149 --> 00:23:49,989
do in that instance is you start to stub

00:23:48,460 --> 00:23:52,090
the method as normal you just call a

00:23:49,989 --> 00:23:54,009
fake when pass at the mock specify the

00:23:52,090 --> 00:23:56,739
method that you want to call and then

00:23:54,009 --> 00:24:00,940
you chain multiple then return calls off

00:23:56,739 --> 00:24:02,409
of that method in the case of if you

00:24:00,940 --> 00:24:04,359
want to return to value the other stubs

00:24:02,409 --> 00:24:07,570
should answer it should work the same

00:24:04,359 --> 00:24:09,249
way so for the first it'll match to the

00:24:07,570 --> 00:24:11,649
first call second to the second call and

00:24:09,249 --> 00:24:13,720
then the last time that I chain if I say

00:24:11,649 --> 00:24:15,340
I called read bites a fourth time it

00:24:13,720 --> 00:24:20,200
would use the last return value that I

00:24:15,340 --> 00:24:21,610
specified any questions so far are we

00:24:20,200 --> 00:24:27,740
good

00:24:21,610 --> 00:24:29,900
okay all right um so if you want to

00:24:27,740 --> 00:24:32,420
override stuffs a good use case for this

00:24:29,900 --> 00:24:34,429
is say your mock object is going to

00:24:32,420 --> 00:24:36,140
exhibit the same behavior like ninety

00:24:34,429 --> 00:24:38,480
percent of the time in your tests and

00:24:36,140 --> 00:24:40,460
you don't want to have to specify all

00:24:38,480 --> 00:24:44,750
the setup for that mock object each test

00:24:40,460 --> 00:24:47,120
method what you can do is the case of

00:24:44,750 --> 00:24:49,040
phpunit and your setup method where you

00:24:47,120 --> 00:24:52,070
would normally put any logic that's

00:24:49,040 --> 00:24:54,410
going to be used on each test you can

00:24:52,070 --> 00:24:57,169
put in that ninety ninety-five percent

00:24:54,410 --> 00:24:59,630
behavior set up in there and then and

00:24:57,169 --> 00:25:01,669
tests where you don't want the mock to

00:24:59,630 --> 00:25:04,700
behave that way you can then simply

00:25:01,669 --> 00:25:08,900
overwrite the stub by redefining it in

00:25:04,700 --> 00:25:11,540
the test so say when the original

00:25:08,900 --> 00:25:13,820
behavior i want the getvalue method on

00:25:11,540 --> 00:25:16,130
this mock object to return 42 in most of

00:25:13,820 --> 00:25:18,770
my cases and then for one test I wanted

00:25:16,130 --> 00:25:20,840
to return 37 instead in that test I

00:25:18,770 --> 00:25:22,610
would simply put in this 37 line and

00:25:20,840 --> 00:25:26,240
then in my setup method I would have put

00:25:22,610 --> 00:25:29,330
in this 42 line and that would work so

00:25:26,240 --> 00:25:31,100
bearing in mind anytime you configure a

00:25:29,330 --> 00:25:34,309
stub the same way it will overwrite

00:25:31,100 --> 00:25:41,990
whatever was there before so something

00:25:34,309 --> 00:25:44,059
to be aware of okay so let's say that

00:25:41,990 --> 00:25:45,730
you don't want to stuff a method let's

00:25:44,059 --> 00:25:49,570
say that you have a method that simply

00:25:45,730 --> 00:25:51,980
has some internal effect on state um

00:25:49,570 --> 00:25:53,210
that you don't want you're not going to

00:25:51,980 --> 00:25:55,130
have anything that's returned you have

00:25:53,210 --> 00:25:57,530
nothing you can really verify as a

00:25:55,130 --> 00:25:58,820
result of the method being called you

00:25:57,530 --> 00:26:04,250
just want to know that the method was

00:25:58,820 --> 00:26:05,630
called by your code um so fake this type

00:26:04,250 --> 00:26:08,720
effectively functions is it's sort of a

00:26:05,630 --> 00:26:10,400
tape recorder where it will record all

00:26:08,720 --> 00:26:13,549
the calls that are made on the mock

00:26:10,400 --> 00:26:15,740
object and then after those calls happen

00:26:13,549 --> 00:26:17,720
you can then tell fake okay I need you

00:26:15,740 --> 00:26:21,650
to verify that this specific method was

00:26:17,720 --> 00:26:25,130
called with these arguments so as an

00:26:21,650 --> 00:26:27,590
example of this let's say that I have in

00:26:25,130 --> 00:26:29,540
one of a what's called an event-driven

00:26:27,590 --> 00:26:30,119
application those seem to be becoming

00:26:29,540 --> 00:26:32,549
more popular

00:26:30,119 --> 00:26:34,649
these days and I've got an event emitter

00:26:32,549 --> 00:26:35,909
class it has an emit method I can pass

00:26:34,649 --> 00:26:38,099
it the name of an event and some

00:26:35,909 --> 00:26:40,349
arguments and then let's say I have a

00:26:38,099 --> 00:26:43,079
plug in class that uses this event

00:26:40,349 --> 00:26:45,149
emitter and when I call a method on the

00:26:43,079 --> 00:26:47,249
plug in class it has to event emit a

00:26:45,149 --> 00:26:49,589
specific event notice I'm not returning

00:26:47,249 --> 00:26:51,419
a value from him it it does whatever it

00:26:49,589 --> 00:26:52,649
does but it doesn't give me a result

00:26:51,419 --> 00:26:55,169
back so I have no way to verify that it

00:26:52,649 --> 00:26:57,599
was called by result value so what I

00:26:55,169 --> 00:27:00,829
need to do is write a call to fake to

00:26:57,599 --> 00:27:03,029
verify that this call actually happens

00:27:00,829 --> 00:27:05,519
so this is what that would look like I'm

00:27:03,029 --> 00:27:08,399
creating a mock object for the event

00:27:05,519 --> 00:27:10,499
emitter passing that to the plug in

00:27:08,399 --> 00:27:12,749
class I'm calling my method that should

00:27:10,499 --> 00:27:15,749
fire off the event and then i'm using

00:27:12,749 --> 00:27:17,459
fakes verify method to verify that the

00:27:15,749 --> 00:27:19,169
emit method was called with the

00:27:17,459 --> 00:27:20,729
arguments that i passed to it when i

00:27:19,169 --> 00:27:22,079
called you thing which i need to fix

00:27:20,729 --> 00:27:27,269
because apparently that's a typo on the

00:27:22,079 --> 00:27:30,299
code example sorry anyways everyone

00:27:27,269 --> 00:27:32,129
follow what's going on here okay other

00:27:30,299 --> 00:27:37,049
than that one error I think my code

00:27:32,129 --> 00:27:40,469
sample was correct alright so let's say

00:27:37,049 --> 00:27:41,789
that I want to verify multiple locations

00:27:40,469 --> 00:27:43,709
of the same method but with different

00:27:41,789 --> 00:27:46,439
parameter values I can do that as well

00:27:43,709 --> 00:27:48,689
so here I've got a class got a method

00:27:46,439 --> 00:27:51,509
that i want to stub or rather verify

00:27:48,689 --> 00:27:55,529
calls for excuse me um so i create a

00:27:51,509 --> 00:27:56,789
mock of this class i invoked my method

00:27:55,529 --> 00:27:58,409
with the two different arguments and

00:27:56,789 --> 00:28:01,859
then at that point i'm able to call

00:27:58,409 --> 00:28:03,389
fakes verify method specify the method

00:28:01,859 --> 00:28:04,199
that should have been called and specify

00:28:03,389 --> 00:28:05,819
the argument that should have been

00:28:04,199 --> 00:28:07,349
passed to it when it was called note

00:28:05,819 --> 00:28:09,929
that i'm actually in doing these

00:28:07,349 --> 00:28:11,429
verifications out of order fake doesn't

00:28:09,929 --> 00:28:12,719
care about that in this context all

00:28:11,429 --> 00:28:15,029
cares about is that the methods were

00:28:12,719 --> 00:28:17,069
invoked at some point it doesn't have

00:28:15,029 --> 00:28:19,199
any concept of them being invoked and

00:28:17,069 --> 00:28:21,389
relation to each other in this example

00:28:19,199 --> 00:28:26,879
now we're going to talk about how to

00:28:21,389 --> 00:28:28,739
make it do that next so I've got a class

00:28:26,879 --> 00:28:30,479
it's got several methods I need to

00:28:28,739 --> 00:28:32,939
verify that they're executed in some

00:28:30,479 --> 00:28:34,409
order maybe you've got an ecommerce

00:28:32,939 --> 00:28:37,079
project and you may need to send off

00:28:34,409 --> 00:28:38,579
orders to fulfillment the validator

00:28:37,079 --> 00:28:39,470
credit card send an email whatever you

00:28:38,579 --> 00:28:42,090
need to do

00:28:39,470 --> 00:28:43,890
and you may want to do these things in a

00:28:42,090 --> 00:28:45,930
certain order because if something if

00:28:43,890 --> 00:28:47,910
there's an issue in the process you want

00:28:45,930 --> 00:28:50,790
to stop it at that point say just

00:28:47,910 --> 00:28:52,860
hypothetical so I've got my class I'm

00:28:50,790 --> 00:28:55,410
creating my mock object I'm invoking

00:28:52,860 --> 00:28:57,780
these methods fake has an in order

00:28:55,410 --> 00:29:00,630
method and all I'm basically doing is

00:28:57,780 --> 00:29:03,000
wrapping all of my other verify calls in

00:29:00,630 --> 00:29:06,150
this method and what fake will do is

00:29:03,000 --> 00:29:07,560
verify the do thing was called at some

00:29:06,150 --> 00:29:09,060
point thereafter do other thing was

00:29:07,560 --> 00:29:11,130
called at some point thereafter do last

00:29:09,060 --> 00:29:12,780
thing was called it doesn't care about

00:29:11,130 --> 00:29:14,160
any calls in between it just carries

00:29:12,780 --> 00:29:16,020
that these calls happen and that they

00:29:14,160 --> 00:29:22,290
happen in this order in relation to each

00:29:16,020 --> 00:29:28,620
other that clear as mud better hopefully

00:29:22,290 --> 00:29:29,940
yeah alright if for some reason you have

00:29:28,620 --> 00:29:31,170
a method did you expect to be called

00:29:29,940 --> 00:29:33,330
multiple times with the same parameters

00:29:31,170 --> 00:29:36,720
I'm not honestly not sure exactly with

00:29:33,330 --> 00:29:37,950
the use case for this is but um so in

00:29:36,720 --> 00:29:39,300
this instance what I'm doing is I'm

00:29:37,950 --> 00:29:40,710
invoking the method that I'm testing

00:29:39,300 --> 00:29:44,070
using the same code as the previous

00:29:40,710 --> 00:29:46,410
example what i'm doing here is when i

00:29:44,070 --> 00:29:48,930
specified that i want to do a method

00:29:46,410 --> 00:29:50,640
verification on this mock object as a

00:29:48,930 --> 00:29:53,160
second parameter to verify i'm

00:29:50,640 --> 00:29:55,890
specifying a return value of fake times

00:29:53,160 --> 00:29:57,630
two so this will confirm that this

00:29:55,890 --> 00:30:00,420
method was invoked twice with these

00:29:57,630 --> 00:30:02,040
parameters there are other things that

00:30:00,420 --> 00:30:03,330
the methods you can use off of fake so

00:30:02,040 --> 00:30:04,890
you can verify that it was invoked at

00:30:03,330 --> 00:30:08,070
least this many times that most as many

00:30:04,890 --> 00:30:15,750
times excuse me or never which I think

00:30:08,070 --> 00:30:17,640
it's just an alias for x 0 okay if you

00:30:15,750 --> 00:30:19,170
for some reason want to verify that no

00:30:17,640 --> 00:30:22,950
interaction with the mock happens at all

00:30:19,170 --> 00:30:25,080
say you make a call to a rest service

00:30:22,950 --> 00:30:26,610
that call fails you want to verify that

00:30:25,080 --> 00:30:28,890
you don't interact with your database

00:30:26,610 --> 00:30:32,010
store any data that is the result of

00:30:28,890 --> 00:30:34,470
that call because the rest of the call

00:30:32,010 --> 00:30:36,960
failed so in this instance I've got a

00:30:34,470 --> 00:30:39,720
thing Dewar class I've got a stuff to a

00:30:36,960 --> 00:30:42,120
class that depends on it and then based

00:30:39,720 --> 00:30:44,040
on this do thing parameter that I'm

00:30:42,120 --> 00:30:47,700
passing to do stuff it may or may not

00:30:44,040 --> 00:30:49,309
invoke the method on the thing to our

00:30:47,700 --> 00:30:53,130
class

00:30:49,309 --> 00:30:55,500
so when I might thing to her pass it the

00:30:53,130 --> 00:30:57,270
stuff doer I call do stuff with a value

00:30:55,500 --> 00:30:59,580
of fall so at this point I know that the

00:30:57,270 --> 00:31:01,169
do thing method on my thing do our class

00:30:59,580 --> 00:31:03,450
should not be invoked because of the

00:31:01,169 --> 00:31:05,309
value that I'm passing to do stuff so at

00:31:03,450 --> 00:31:07,169
that point I can tell fake okay verify

00:31:05,309 --> 00:31:08,490
that no interaction happens with this

00:31:07,169 --> 00:31:12,260
mock optic because I know that it

00:31:08,490 --> 00:31:12,260
shouldn't based on what I'm passing it

00:31:14,570 --> 00:31:21,149
okay so going further with that if I

00:31:19,289 --> 00:31:22,740
want to verify that some interaction may

00:31:21,149 --> 00:31:25,440
have happened but no interaction happens

00:31:22,740 --> 00:31:28,020
after a certain point I can do that as

00:31:25,440 --> 00:31:31,350
well so same code is the previous

00:31:28,020 --> 00:31:33,600
example when I'm calling do stuff with

00:31:31,350 --> 00:31:36,120
true at that point the thing doer method

00:31:33,600 --> 00:31:38,399
should be called I know that so at this

00:31:36,120 --> 00:31:39,990
point I tell fake ok so our actions may

00:31:38,399 --> 00:31:41,730
have happened before now but after this

00:31:39,990 --> 00:31:43,380
point where I'm telling you no further

00:31:41,730 --> 00:31:47,850
interactions should happen verify that

00:31:43,380 --> 00:31:51,960
for me so the code in this test because

00:31:47,850 --> 00:31:54,299
my next line invokes the do stuff method

00:31:51,960 --> 00:32:03,450
such that the thing method won't be

00:31:54,299 --> 00:32:06,240
invoked this test should pass alright so

00:32:03,450 --> 00:32:08,669
this is an instance where I want to

00:32:06,240 --> 00:32:12,480
basically tell fake ok I'm going to tell

00:32:08,669 --> 00:32:14,700
you what calls I want to verify I want

00:32:12,480 --> 00:32:17,940
you to check that only these halls were

00:32:14,700 --> 00:32:20,850
ever made on this mock so then all of my

00:32:17,940 --> 00:32:22,559
previous examples we told fake what

00:32:20,850 --> 00:32:24,960
verification what method calls we were

00:32:22,559 --> 00:32:27,210
expecting other method calls can still

00:32:24,960 --> 00:32:30,149
happen we're just not telling fake to

00:32:27,210 --> 00:32:31,980
verify them so if for some reason you

00:32:30,149 --> 00:32:33,539
want to say verify that these methods

00:32:31,980 --> 00:32:36,659
and only these methods are called this

00:32:33,539 --> 00:32:39,899
is how you would do it um in this

00:32:36,659 --> 00:32:41,880
example I've got a my filter class and

00:32:39,899 --> 00:32:46,529
that's going to receive an instance of

00:32:41,880 --> 00:32:48,720
my list class here so this filter has a

00:32:46,529 --> 00:32:50,190
method called add even to list and the

00:32:48,720 --> 00:32:53,669
whole point is just to add even numbers

00:32:50,190 --> 00:32:56,309
to a list object that I give it so after

00:32:53,669 --> 00:32:59,549
I make this call at this point the list

00:32:56,309 --> 00:33:01,600
should have two and four in it so when I

00:32:59,549 --> 00:33:03,549
call fake verify I'm telling

00:33:01,600 --> 00:33:05,860
you should expect a call to a push

00:33:03,549 --> 00:33:09,190
method with the number two and with the

00:33:05,860 --> 00:33:13,720
number four and no other calls should

00:33:09,190 --> 00:33:15,640
occur on that mock so given that again

00:33:13,720 --> 00:33:16,809
the assuming the code worked the way

00:33:15,640 --> 00:33:24,220
that you would think it would looking at

00:33:16,809 --> 00:33:25,780
this example the test would pass okay so

00:33:24,220 --> 00:33:27,160
verifying that's what magic methods

00:33:25,780 --> 00:33:32,289
basically works the same way as it does

00:33:27,160 --> 00:33:34,780
with stubbing them so in here instead of

00:33:32,289 --> 00:33:36,789
calling when I'm just simply calling

00:33:34,780 --> 00:33:39,130
verifying and passing it the same name

00:33:36,789 --> 00:33:42,700
as the method that i would expect to be

00:33:39,130 --> 00:33:44,500
called again because the double

00:33:42,700 --> 00:33:46,600
underscore call matic magic method is

00:33:44,500 --> 00:33:48,250
used by fake you have to call a

00:33:46,600 --> 00:33:50,620
different method to check that it was

00:33:48,250 --> 00:33:52,659
invoked so I'm calling verify column

00:33:50,620 --> 00:33:54,190
method with giving it the name of the

00:33:52,659 --> 00:33:56,740
method the arguments that I expect to be

00:33:54,190 --> 00:33:57,970
passed and then calling is called on

00:33:56,740 --> 00:34:01,480
with the mock that I expected it to be

00:33:57,970 --> 00:34:09,010
invoked on so essentially the same story

00:34:01,480 --> 00:34:12,419
second verse okay um you may be testing

00:34:09,010 --> 00:34:16,690
code where you do not necessarily know

00:34:12,419 --> 00:34:18,730
the specific value that I stub will

00:34:16,690 --> 00:34:20,530
receive when it's called you mean

00:34:18,730 --> 00:34:23,139
there's something about that value you

00:34:20,530 --> 00:34:24,399
may know that it's a greater than 10 but

00:34:23,139 --> 00:34:26,980
you don't know exactly what the math

00:34:24,399 --> 00:34:30,040
what the value is going to be um so in

00:34:26,980 --> 00:34:32,619
that instance phpunit actually has what

00:34:30,040 --> 00:34:38,050
it calls constraints which you can pass

00:34:32,619 --> 00:34:39,730
in place of um a specific value when you

00:34:38,050 --> 00:34:41,139
are stuffing a method to say that okay I

00:34:39,730 --> 00:34:42,820
don't know what this method is going to

00:34:41,139 --> 00:34:44,109
receive on this mock object when it's

00:34:42,820 --> 00:34:44,940
called but just know that this is you

00:34:44,109 --> 00:34:50,590
know it's going to meet these criteria

00:34:44,940 --> 00:34:53,619
um so fake supports using these methods

00:34:50,590 --> 00:34:55,060
of phpunit greater than 10 it's just a

00:34:53,619 --> 00:34:56,230
particular example it's got a number of

00:34:55,060 --> 00:35:01,560
different constraints and I've like to a

00:34:56,230 --> 00:35:04,920
list of them up here um you can also

00:35:01,560 --> 00:35:07,060
implement your own matters using fakes

00:35:04,920 --> 00:35:10,720
interfaces so you can implement class

00:35:07,060 --> 00:35:12,550
with using this interface and say it

00:35:10,720 --> 00:35:14,800
should take this argument and then

00:35:12,550 --> 00:35:16,990
verify that it meets this criteria

00:35:14,800 --> 00:35:20,080
so this allows for a lot of flexibility

00:35:16,990 --> 00:35:25,750
and code reuse with regard to verifying

00:35:20,080 --> 00:35:27,990
the nature of your stub parameters okay

00:35:25,750 --> 00:35:31,330
here's a few more examples of these um

00:35:27,990 --> 00:35:32,980
so for individual parameters phpunit has

00:35:31,330 --> 00:35:34,180
in anything constraint that it would

00:35:32,980 --> 00:35:36,550
just take whatever and will always

00:35:34,180 --> 00:35:37,930
return true so you can use that if you

00:35:36,550 --> 00:35:41,100
don't know anything about the perimeter

00:35:37,930 --> 00:35:44,710
other than that it should be there um

00:35:41,100 --> 00:35:48,520
let's see for the case of when you want

00:35:44,710 --> 00:35:50,110
to stub a method and you don't really

00:35:48,520 --> 00:35:51,400
care what the parameters are you just

00:35:50,110 --> 00:35:52,660
expect it to always have the same

00:35:51,400 --> 00:35:55,270
behavior regardless of what parameters

00:35:52,660 --> 00:35:58,000
are passed to it you would call it this

00:35:55,270 --> 00:36:00,400
way so fake when mock you specify the

00:35:58,000 --> 00:36:03,160
method name note that i'm not calling it

00:36:00,400 --> 00:36:05,560
with parenthesis here a fake will

00:36:03,160 --> 00:36:06,610
interpret this as okay they're stuffing

00:36:05,560 --> 00:36:08,590
this method but they don't care what

00:36:06,610 --> 00:36:11,770
passed in so at that point you can

00:36:08,590 --> 00:36:14,640
simply chain normally and it will use

00:36:11,770 --> 00:36:17,140
that stub for all calls to that method

00:36:14,640 --> 00:36:19,630
lastly if there are cases where your

00:36:17,140 --> 00:36:21,480
stubbing a method and it may have a lot

00:36:19,630 --> 00:36:24,160
of parameters that you don't care about

00:36:21,480 --> 00:36:25,330
you can simply in the place of the first

00:36:24,160 --> 00:36:27,130
parameter that you don't care about

00:36:25,330 --> 00:36:31,720
specify fake ignore remaining and it

00:36:27,130 --> 00:36:34,180
will simply use that stub for any cases

00:36:31,720 --> 00:36:35,710
where in this specific example foo and

00:36:34,180 --> 00:36:37,930
bar passes the first and second

00:36:35,710 --> 00:36:39,400
parameters but it doesn't matter what

00:36:37,930 --> 00:36:48,130
the rest are it'll just simply return

00:36:39,400 --> 00:36:52,630
bar for all those cases okay um there

00:36:48,130 --> 00:36:55,750
may be cases where I want to UM capture

00:36:52,630 --> 00:36:59,140
specific parameters say they may be

00:36:55,750 --> 00:37:00,910
objects that may be of a complex nature

00:36:59,140 --> 00:37:03,460
and I want to verify multiple things

00:37:00,910 --> 00:37:05,380
about those objects using PHP in its

00:37:03,460 --> 00:37:07,600
assertions I can simply call fake

00:37:05,380 --> 00:37:10,510
capture when I saw what I'm doing the

00:37:07,600 --> 00:37:12,490
verification and what fake will do is it

00:37:10,510 --> 00:37:15,010
will look verify that the method call

00:37:12,490 --> 00:37:18,490
actually happened and then whatever was

00:37:15,010 --> 00:37:19,930
passed um this fake capture call will

00:37:18,490 --> 00:37:21,460
store it in this variable which I'm

00:37:19,930 --> 00:37:24,460
passing in by reference and then at that

00:37:21,460 --> 00:37:25,400
point I can do whatever it is that I

00:37:24,460 --> 00:37:28,430
want to do any

00:37:25,400 --> 00:37:29,990
checks on those parameters so that's

00:37:28,430 --> 00:37:31,310
mainly the use case for this is that if

00:37:29,990 --> 00:37:33,680
you have complex objects or some other

00:37:31,310 --> 00:37:35,290
sort of type that you don't necessarily

00:37:33,680 --> 00:37:42,250
just want to use simple constraints for

00:37:35,290 --> 00:37:48,910
this is I hate a feature to use okay um

00:37:42,250 --> 00:37:48,910
so in verifications um if we want to

00:37:49,030 --> 00:37:54,830
capture parameters but we want to also

00:37:51,830 --> 00:37:57,560
perform constraint checks on them at the

00:37:54,830 --> 00:38:00,020
same time that's what this would allow

00:37:57,560 --> 00:38:02,900
so in this case both capturing all

00:38:00,020 --> 00:38:06,920
forums and in line when I change this

00:38:02,900 --> 00:38:09,530
this win call um I'm passing in a

00:38:06,920 --> 00:38:11,060
constraint in this case it's the is type

00:38:09,530 --> 00:38:13,100
constraint i'm specifying that it should

00:38:11,060 --> 00:38:16,580
be an array this is one of each be in

00:38:13,100 --> 00:38:19,580
its constraints so that constraint will

00:38:16,580 --> 00:38:21,320
be applied to this perimeter when I

00:38:19,580 --> 00:38:22,850
capture it and at that point if it

00:38:21,320 --> 00:38:31,010
doesn't match the verification test will

00:38:22,850 --> 00:38:33,290
fail okay um one of the criticisms that

00:38:31,010 --> 00:38:36,380
I got when I first gave this talk was

00:38:33,290 --> 00:38:37,940
that a lot of people already had test

00:38:36,380 --> 00:38:41,560
suite setup where they were already

00:38:37,940 --> 00:38:43,670
using PHP units native mocking and they

00:38:41,560 --> 00:38:45,020
effectively they were in an organization

00:38:43,670 --> 00:38:46,400
large enough that if they were going to

00:38:45,020 --> 00:38:48,170
affect the change of using a library

00:38:46,400 --> 00:38:51,740
like fake that they needed to be able to

00:38:48,170 --> 00:38:53,180
make a business case for it so I've

00:38:51,740 --> 00:38:56,660
added on these slides to kind of show

00:38:53,180 --> 00:39:00,770
you a PhD in its native mocking behavior

00:38:56,660 --> 00:39:02,150
as compared to what fake tubs so both of

00:39:00,770 --> 00:39:04,790
the examples here when I'm trying to

00:39:02,150 --> 00:39:06,770
create a mock object um these have the

00:39:04,790 --> 00:39:09,110
same effect there are two different

00:39:06,770 --> 00:39:11,750
styles of calling the bottom one is

00:39:09,110 --> 00:39:13,180
older the top one was added more

00:39:11,750 --> 00:39:19,070
recently to make code a bit more

00:39:13,180 --> 00:39:21,650
semantically meaningful so all of these

00:39:19,070 --> 00:39:25,160
calls will result in basically what fake

00:39:21,650 --> 00:39:26,150
does when you simply call fake mock PHP

00:39:25,160 --> 00:39:28,640
and it offers a lot of different

00:39:26,150 --> 00:39:31,220
features some of these I haven't really

00:39:28,640 --> 00:39:35,030
found a use for like when you mock the

00:39:31,220 --> 00:39:38,560
class you can actually specify the name

00:39:35,030 --> 00:39:41,380
of the mock subclass that it will create

00:39:38,560 --> 00:39:45,580
um I've I can't recall a single instance

00:39:41,380 --> 00:39:47,560
where I fatties that feature so um calls

00:39:45,580 --> 00:39:49,420
like this if you need to override some

00:39:47,560 --> 00:39:51,430
specific aspect of the mocks behavior

00:39:49,420 --> 00:39:54,340
can be cumbersome and difficult to read

00:39:51,430 --> 00:39:55,570
so this is one instance where it simply

00:39:54,340 --> 00:39:57,100
makes your test Suites better because

00:39:55,570 --> 00:40:02,470
you can understand how to glance exactly

00:39:57,100 --> 00:40:04,720
what's going on okay with regard to

00:40:02,470 --> 00:40:06,160
phpunit stubbing features one thing that

00:40:04,720 --> 00:40:09,280
I don't like about the design is that

00:40:06,160 --> 00:40:12,490
can fights the api's for subbing in for

00:40:09,280 --> 00:40:15,850
verification and this limits how you can

00:40:12,490 --> 00:40:20,770
use it so in this instance I'm saying

00:40:15,850 --> 00:40:23,110
that on this HTTP object I should expect

00:40:20,770 --> 00:40:26,530
the get method to be called exactly once

00:40:23,110 --> 00:40:28,930
um a lot of people will take this code

00:40:26,530 --> 00:40:30,790
example and read that this means get

00:40:28,930 --> 00:40:32,860
will be called once with this parameter

00:40:30,790 --> 00:40:35,170
and it may be called other times which

00:40:32,860 --> 00:40:36,550
is not correct this is expecting that

00:40:35,170 --> 00:40:38,290
the method will be called exactly once

00:40:36,550 --> 00:40:43,540
with the specific parameter and it will

00:40:38,290 --> 00:40:46,030
have this specific behavior um so the

00:40:43,540 --> 00:40:48,130
fake code for this is a bit longer but

00:40:46,030 --> 00:40:52,960
it's clearer as to what's going on and

00:40:48,130 --> 00:40:55,120
this also gives me the ability to change

00:40:52,960 --> 00:40:56,590
how many times I expect the method to be

00:40:55,120 --> 00:40:58,210
called or if I don't care how often it's

00:40:56,590 --> 00:40:59,200
called I don't care about stubbing it I

00:40:58,210 --> 00:41:01,540
don't have to worry about the

00:40:59,200 --> 00:41:05,680
verification side effects of PHP and its

00:41:01,540 --> 00:41:10,300
API so that's essentially the the

00:41:05,680 --> 00:41:12,490
advantage here with these AP is ok if

00:41:10,300 --> 00:41:14,170
you want this tub multiple calls in my

00:41:12,490 --> 00:41:17,080
opinion the way for doing this in PHP

00:41:14,170 --> 00:41:18,730
unit is kind of messy essentially they

00:41:17,080 --> 00:41:22,240
implemented doing it two different ways

00:41:18,730 --> 00:41:26,200
so you can use what they call a value

00:41:22,240 --> 00:41:28,120
map where you specify the arguments that

00:41:26,200 --> 00:41:29,770
you expect to receive and then the

00:41:28,120 --> 00:41:31,450
return value that you want to use and

00:41:29,770 --> 00:41:36,970
you have to do this for every single

00:41:31,450 --> 00:41:39,280
call that may happen the other way is

00:41:36,970 --> 00:41:43,570
that you can actually specify a callback

00:41:39,280 --> 00:41:46,590
which is equivalent to two using it the

00:41:43,570 --> 00:41:48,580
then return callbacks answer and fake

00:41:46,590 --> 00:41:50,110
that will receive the arguments that are

00:41:48,580 --> 00:41:51,460
passed in stuff you can perform some

00:41:50,110 --> 00:41:53,020
custom logic and then

00:41:51,460 --> 00:41:54,490
whatever values are appropriate but I

00:41:53,020 --> 00:41:57,880
mean quite honestly for the use case

00:41:54,490 --> 00:42:00,700
this gets kind of cumbersome so compared

00:41:57,880 --> 00:42:03,550
with fakes API where I can simply in

00:42:00,700 --> 00:42:05,140
line very semantically specify okay I

00:42:03,550 --> 00:42:07,480
expect do seem to be called with these

00:42:05,140 --> 00:42:10,800
arguments and the return this value it's

00:42:07,480 --> 00:42:13,060
very readable it's very straightforward

00:42:10,800 --> 00:42:14,650
you can tell exactly how it should work

00:42:13,060 --> 00:42:16,060
by looking at the code as opposed to if

00:42:14,650 --> 00:42:17,440
you haven't read the documentation for

00:42:16,060 --> 00:42:18,610
these features you may not quite

00:42:17,440 --> 00:42:21,580
understand it by just looking at the

00:42:18,610 --> 00:42:23,740
code necessarily I just think it's it

00:42:21,580 --> 00:42:28,680
makes the test suite more readable do it

00:42:23,740 --> 00:42:31,720
this way okay this is a big one um

00:42:28,680 --> 00:42:34,000
because the api's here are conflated the

00:42:31,720 --> 00:42:36,670
way that I would verify order and PHP

00:42:34,000 --> 00:42:40,690
unit is that i would call expects with

00:42:36,670 --> 00:42:41,860
the this at and i would specify an index

00:42:40,690 --> 00:42:44,170
of the call that i want to verify

00:42:41,860 --> 00:42:45,310
starting from zero the problem with this

00:42:44,170 --> 00:42:47,950
is that it makes your test to be very

00:42:45,310 --> 00:42:50,410
brittle so this will allow you to verify

00:42:47,950 --> 00:42:53,800
order but if i have to inject a call and

00:42:50,410 --> 00:42:55,480
at any point in this order it will

00:42:53,800 --> 00:42:57,220
suddenly cause tests to fail off to go

00:42:55,480 --> 00:42:58,870
back look at the indexes remember the

00:42:57,220 --> 00:43:00,460
order of calls it's just very very

00:42:58,870 --> 00:43:02,380
cumbersome and it's not very readable

00:43:00,460 --> 00:43:03,670
and because these stubbing and

00:43:02,380 --> 00:43:05,580
verification AV eyes are going to fight

00:43:03,670 --> 00:43:10,000
it this is the only way to verify order

00:43:05,580 --> 00:43:11,530
in that API compared with as I mentioned

00:43:10,000 --> 00:43:13,060
earlier in the case of fake I make the

00:43:11,530 --> 00:43:15,580
same verify calls that I would normally

00:43:13,060 --> 00:43:17,230
make the differences is I don't have to

00:43:15,580 --> 00:43:18,580
worry about indexes at all and I don't

00:43:17,230 --> 00:43:20,560
have to worry about any calls that may

00:43:18,580 --> 00:43:22,660
happen in between if all i care about is

00:43:20,560 --> 00:43:25,120
that these specific methods were called

00:43:22,660 --> 00:43:27,670
in the specific order I can express that

00:43:25,120 --> 00:43:29,200
and it's not fragile at all if I have to

00:43:27,670 --> 00:43:35,470
add a call in between these it will

00:43:29,200 --> 00:43:37,090
continue to work just fine okay um i

00:43:35,470 --> 00:43:38,770
have had at least one person that I know

00:43:37,090 --> 00:43:41,350
who's had a lot of experience with a

00:43:38,770 --> 00:43:43,150
different library called mockery if you

00:43:41,350 --> 00:43:45,940
know the droid Brady he's the author of

00:43:43,150 --> 00:43:48,400
that one it has a lot of the same

00:43:45,940 --> 00:43:49,690
features it's basically sort of six one

00:43:48,400 --> 00:43:51,940
half dozen to the other there's no

00:43:49,690 --> 00:43:53,080
feature so far as I know that one has

00:43:51,940 --> 00:43:55,860
the other doesn't that makes it

00:43:53,080 --> 00:43:58,720
significantly better than the other I

00:43:55,860 --> 00:44:01,609
just found that for me personally fakes

00:43:58,720 --> 00:44:03,349
API made more sense when I read it

00:44:01,609 --> 00:44:07,579
I thought you to understand code written

00:44:03,349 --> 00:44:09,319
using it more easily that may be a

00:44:07,579 --> 00:44:11,210
cultural thing i'm not sure but if you

00:44:09,319 --> 00:44:12,650
look at face api and you don't really

00:44:11,210 --> 00:44:15,980
quite get it or it just doesn't really

00:44:12,650 --> 00:44:19,880
click with you Makka reason is another

00:44:15,980 --> 00:44:22,430
library you can check out I think of it

00:44:19,880 --> 00:44:23,569
as kind of like Apple or Android people

00:44:22,430 --> 00:44:26,839
tend to like one of not together for the

00:44:23,569 --> 00:44:29,809
most part the other option that I know

00:44:26,839 --> 00:44:31,400
of is a library called prophecy phpunit

00:44:29,809 --> 00:44:33,319
those actually offer native integration

00:44:31,400 --> 00:44:34,819
with this library I haven't looked at it

00:44:33,319 --> 00:44:38,029
too extensively i think it was added in

00:44:34,819 --> 00:44:42,619
4.5 so I relatively speaking it's a

00:44:38,029 --> 00:44:45,920
recent addition um so I would encourage

00:44:42,619 --> 00:44:47,450
you mostly just because i have used PHP

00:44:45,920 --> 00:44:49,759
units native mocking extensively and

00:44:47,450 --> 00:44:52,039
I've run into these pain points time and

00:44:49,759 --> 00:44:53,720
time again that if you're experiencing

00:44:52,039 --> 00:44:55,670
some of the same frustrations that you

00:44:53,720 --> 00:44:57,349
checked out these libraries it doesn't

00:44:55,670 --> 00:44:58,670
have to be fake in particular like I say

00:44:57,349 --> 00:45:03,349
it's just the one that I use personally

00:44:58,670 --> 00:45:05,930
um so that is all the material that i

00:45:03,349 --> 00:45:07,460
have um if you have any questions

00:45:05,930 --> 00:45:11,630
comments discussion we can do that now

00:45:07,460 --> 00:45:12,950
um obligatory plug one I work commas the

00:45:11,630 --> 00:45:15,380
company that I work forward you'll see

00:45:12,950 --> 00:45:16,430
me wearing your shirt today if you want

00:45:15,380 --> 00:45:19,849
to talk about the company they're hiring

00:45:16,430 --> 00:45:22,329
so I'm here for that again you can go to

00:45:19,849 --> 00:45:26,930
my site for slides you can reach me

00:45:22,329 --> 00:45:28,579
using all of these and lastly again

00:45:26,930 --> 00:45:29,989
please please please i really appreciate

00:45:28,579 --> 00:45:32,329
feedback on joined in so I'd appreciate

00:45:29,989 --> 00:45:34,420
it if you would leave me some so thank

00:45:32,329 --> 00:45:34,420
you

00:45:39,369 --> 00:45:45,799
so any Q&A anybody have any questions at

00:45:42,349 --> 00:45:51,559
all yes I think love somebody running

00:45:45,799 --> 00:45:56,359
back to the mixer hi can we integrate

00:45:51,559 --> 00:46:00,140
fake with PHP spec um I haven't use PHP

00:45:56,359 --> 00:46:02,420
spec extensively what I can tell you is

00:46:00,140 --> 00:46:05,210
that i showed points of integration with

00:46:02,420 --> 00:46:07,489
phpunit but fake so far as i know is not

00:46:05,210 --> 00:46:09,710
dependent on that it does use it for its

00:46:07,489 --> 00:46:11,359
own unit tests but in terms of having

00:46:09,710 --> 00:46:15,289
dependencies that doesn't depend on PHP

00:46:11,359 --> 00:46:16,970
and specifically so not knowing anything

00:46:15,289 --> 00:46:21,170
again about PHP spec I would assume

00:46:16,970 --> 00:46:22,670
theoretically it as possible alpha keep

00:46:21,170 --> 00:46:33,920
an ear out for anybody who's had that

00:46:22,670 --> 00:46:37,630
experience anybody else yes sir hey so

00:46:33,920 --> 00:46:40,190
when you run fake verify and

00:46:37,630 --> 00:46:41,779
verification fells I presume it just

00:46:40,190 --> 00:46:44,119
throws an exception or something yes

00:46:41,779 --> 00:46:46,130
phpunit you want it to kind of show a

00:46:44,119 --> 00:46:47,989
nice error message as if you were using

00:46:46,130 --> 00:46:49,369
like a sir or something yes that's

00:46:47,989 --> 00:46:51,140
exactly what happens so it will throw an

00:46:49,369 --> 00:46:52,999
exception and cause PHP units normal

00:46:51,140 --> 00:46:54,170
failure behavior to kick in and the

00:46:52,999 --> 00:46:55,730
exception message will include more

00:46:54,170 --> 00:46:58,220
information about exactly what caused it

00:46:55,730 --> 00:46:59,660
to fail fake is actually very good for

00:46:58,220 --> 00:47:02,749
that I've found that it will tell you

00:46:59,660 --> 00:47:03,890
okay you expected this method to be

00:47:02,749 --> 00:47:05,690
called this many times with these

00:47:03,890 --> 00:47:07,999
parameters that's not actually what

00:47:05,690 --> 00:47:11,180
happened there was no interaction with

00:47:07,999 --> 00:47:12,380
this mark or this this stuff was called

00:47:11,180 --> 00:47:14,390
but it was called with these different

00:47:12,380 --> 00:47:15,619
parameters it's very good about denoting

00:47:14,390 --> 00:47:16,819
exactly what the difference was between

00:47:15,619 --> 00:47:19,970
what you expected and what actually

00:47:16,819 --> 00:47:22,089
happened so think when do the one in the

00:47:19,970 --> 00:47:22,089
back

00:47:28,150 --> 00:47:35,059
hey if you mentioned about if you're

00:47:32,930 --> 00:47:38,480
mocking a private method to seize the

00:47:35,059 --> 00:47:40,309
public method would use it instead do

00:47:38,480 --> 00:47:42,170
you see any problem with just trying to

00:47:40,309 --> 00:47:50,569
make your private methods protected

00:47:42,170 --> 00:47:52,099
instead um so it depends um my I've

00:47:50,569 --> 00:47:55,309
worked in a lot of different settings

00:47:52,099 --> 00:47:57,079
before in one of those I was responsible

00:47:55,309 --> 00:48:00,200
for maintaining a framework that a lot

00:47:57,079 --> 00:48:01,369
of the rest of the company used I can

00:48:00,200 --> 00:48:03,200
tell you that depending on the size of

00:48:01,369 --> 00:48:04,700
your organization in those sorts of

00:48:03,200 --> 00:48:10,130
situations education can be very

00:48:04,700 --> 00:48:13,609
difficult so I think Stefan creep said

00:48:10,130 --> 00:48:15,589
this best any be careful when you

00:48:13,609 --> 00:48:16,519
declare methods as being non private

00:48:15,589 --> 00:48:18,339
because at that point you have to

00:48:16,519 --> 00:48:22,430
maintain them for the rest of your life

00:48:18,339 --> 00:48:24,319
so in that instance when we didn't use

00:48:22,430 --> 00:48:26,900
private methods quite often I found we

00:48:24,319 --> 00:48:28,869
give the other users of the framework

00:48:26,900 --> 00:48:33,319
and I've rope to hang themselves with so

00:48:28,869 --> 00:48:35,269
um I guess that's its religious that

00:48:33,319 --> 00:48:37,880
depends protected does make stuffing a

00:48:35,269 --> 00:48:41,690
lot easier there are cases where private

00:48:37,880 --> 00:48:43,069
is called for I tend to find its lesser

00:48:41,690 --> 00:48:44,210
used at least in my own code a lot of

00:48:43,069 --> 00:48:45,319
other programmers on the other end of

00:48:44,210 --> 00:48:48,130
the extreme where they make anything

00:48:45,319 --> 00:48:51,559
that's not public private by default so

00:48:48,130 --> 00:48:53,150
it's going to vary as to you know if

00:48:51,559 --> 00:48:54,109
you're doing with legacy code base or if

00:48:53,150 --> 00:48:55,640
you're dealing to the code base that a

00:48:54,109 --> 00:48:58,069
lot of other users and your company use

00:48:55,640 --> 00:49:03,549
as to which decision you should make in

00:48:58,069 --> 00:49:03,549
my opinion all right anybody else

00:49:07,450 --> 00:49:15,550
area all right and I really like the

00:49:13,070 --> 00:49:18,110
clear api's that stuff is brilliant

00:49:15,550 --> 00:49:22,040
that's coming from experience using and

00:49:18,110 --> 00:49:23,870
mockery so it's very similar stuff but

00:49:22,040 --> 00:49:29,840
my question is does that come at a cost

00:49:23,870 --> 00:49:33,380
of say rather than using HP unit instead

00:49:29,840 --> 00:49:39,170
so in terms of flight I guess execution

00:49:33,380 --> 00:49:41,990
time does it have any impact on the type

00:49:39,170 --> 00:49:44,480
of running year for the test week I mean

00:49:41,990 --> 00:49:47,960
I honestly I I haven't seen that it has

00:49:44,480 --> 00:49:51,140
um it's possible that it would with a

00:49:47,960 --> 00:49:52,730
fat uh sweet that was fairly large if

00:49:51,140 --> 00:49:54,260
there have been any performance studies

00:49:52,730 --> 00:49:55,670
done in that regard i'm not aware of

00:49:54,260 --> 00:49:57,140
them but in terms of my own personal

00:49:55,670 --> 00:49:59,360
experience I haven't noticed a

00:49:57,140 --> 00:50:08,920
difference just notice what the code is

00:49:59,360 --> 00:50:11,810
a lot cleaner anybody else don't be shy

00:50:08,920 --> 00:50:13,460
three two one okay um all right well if

00:50:11,810 --> 00:50:14,720
you happen to think of a question later

00:50:13,460 --> 00:50:16,670
or you just don't feel comfortable

00:50:14,720 --> 00:50:18,440
asking one publicly please come find me

00:50:16,670 --> 00:50:21,670
I'm at your disposal and thank you again

00:50:18,440 --> 00:50:21,670

YouTube URL: https://www.youtube.com/watch?v=6fNL5U1FUiI


