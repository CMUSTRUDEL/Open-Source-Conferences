Title: PHP UK Conference 2016 - Georgiana Gligor - Large scale websites performance optimisation tricks
Publication date: 2016-03-17
Playlist: PHP UK Conference 2016
Description: 
	Practical lessons learned while revamping a US airline website to resist huge Black Friday and Cyber Monday traffic values. Using HTTP status codes and PHP cleverly, we have made parallel requests possible, so that the user experience is greatly enhanced, and we pre-cache resource-consuming user searches. All on a solid Symfony2 foundation.
Captions: 
	00:00:09,750 --> 00:00:14,730
thank you very much welcome to the

00:00:11,700 --> 00:00:18,480
afternoon session I'm very pleased that

00:00:14,730 --> 00:00:21,000
we have such a whole audience that the

00:00:18,480 --> 00:00:25,770
room is full I'm sure you will learn

00:00:21,000 --> 00:00:27,810
some new things from the stock a very

00:00:25,770 --> 00:00:32,400
few words about myself not not to take

00:00:27,810 --> 00:00:34,620
you too long with I'm developing large

00:00:32,400 --> 00:00:38,070
scale web applications for the past 13

00:00:34,620 --> 00:00:40,110
years on the lamp stack says the labs

00:00:38,070 --> 00:00:43,350
that wasn't such a good player in the

00:00:40,110 --> 00:00:46,739
enterprise world and people were kind of

00:00:43,350 --> 00:00:51,360
dismissing it for not being as rational

00:00:46,739 --> 00:00:54,360
as Java for example in the past 10 years

00:00:51,360 --> 00:00:57,480
I've been migrating from the back-end

00:00:54,360 --> 00:00:59,899
development roll through devops which is

00:00:57,480 --> 00:01:03,210
very close to my heart and then I

00:00:59,899 --> 00:01:07,050
started doing architecture consultancy

00:01:03,210 --> 00:01:14,010
and I also started a PHP group in

00:01:07,050 --> 00:01:18,000
cluj-napoca while hometown more more on

00:01:14,010 --> 00:01:20,430
the actual project is the customer for

00:01:18,000 --> 00:01:22,770
which we were delivering this

00:01:20,430 --> 00:01:26,430
application is the low cost airline a

00:01:22,770 --> 00:01:29,400
very similar to Reiner or easyjet don't

00:01:26,430 --> 00:01:32,310
let this fool you there are by no means

00:01:29,400 --> 00:01:36,439
a small company they affect a very large

00:01:32,310 --> 00:01:40,500
company judge by European standards and

00:01:36,439 --> 00:01:42,930
in 2015 there have been one of the top

00:01:40,500 --> 00:01:46,200
three most performed profitable allies

00:01:42,930 --> 00:01:48,630
in the world and they have a record

00:01:46,200 --> 00:01:51,810
streak of more than forty four

00:01:48,630 --> 00:01:59,610
consecutive profitable quarters which is

00:01:51,810 --> 00:02:05,969
a very impressive thing for a company by

00:01:59,610 --> 00:02:08,459
linking more than I'm sorry their

00:02:05,969 --> 00:02:12,090
strategy is to connect touristic

00:02:08,459 --> 00:02:15,150
destinations with underserved US cities

00:02:12,090 --> 00:02:17,430
but therefore creating a market instead

00:02:15,150 --> 00:02:19,500
of cannibalizing from the existing

00:02:17,430 --> 00:02:22,120
market they bring new customers in and

00:02:19,500 --> 00:02:25,269
they fly them to touristic destinations

00:02:22,120 --> 00:02:27,099
so as they don't even have competition

00:02:25,269 --> 00:02:32,980
on more than ninety percent of the rods

00:02:27,099 --> 00:02:35,860
we are serving a very particular aspect

00:02:32,980 --> 00:02:38,650
of this airline as compared to others is

00:02:35,860 --> 00:02:40,629
that they don't use the GPS maybe you

00:02:38,650 --> 00:02:44,110
know which ideas are global distribution

00:02:40,629 --> 00:02:46,690
systems that like world spine or Sabra

00:02:44,110 --> 00:02:49,690
are models maybe this name sound

00:02:46,690 --> 00:02:52,690
familiar most of the major players in

00:02:49,690 --> 00:02:55,150
the airline industry delegate the

00:02:52,690 --> 00:02:57,840
responsibility of forms of their

00:02:55,150 --> 00:03:01,780
availability to somebody else at GDS and

00:02:57,840 --> 00:03:04,780
this customer doesn't do that they have

00:03:01,780 --> 00:03:12,700
their own reservation engine and deliver

00:03:04,780 --> 00:03:16,769
information based on that one in order

00:03:12,700 --> 00:03:19,540
to sell tickets but they don't use any

00:03:16,769 --> 00:03:23,440
other means that their own website

00:03:19,540 --> 00:03:26,290
platform and additionally there for a

00:03:23,440 --> 00:03:28,959
call center facility where you can pick

00:03:26,290 --> 00:03:31,239
up the phone and make reservation over

00:03:28,959 --> 00:03:34,269
the phone with the person on the other

00:03:31,239 --> 00:03:36,340
line end of the line will just follow

00:03:34,269 --> 00:03:39,849
the same booking process as you would

00:03:36,340 --> 00:03:43,750
yourself on the website it helps a lot

00:03:39,849 --> 00:03:51,629
of people it's quite quite heavy traffic

00:03:43,750 --> 00:03:53,769
as well I have a very brief schema of

00:03:51,629 --> 00:03:56,049
representing that they tough loss in the

00:03:53,769 --> 00:03:58,540
legacy application so a couple of years

00:03:56,049 --> 00:04:03,449
ago when we were tasked with tasked with

00:03:58,540 --> 00:04:05,680
this project and they had a back office

00:04:03,449 --> 00:04:08,349
interests where they were administering

00:04:05,680 --> 00:04:13,000
all the information pushing it to the

00:04:08,349 --> 00:04:16,539
data layer and the the only customers

00:04:13,000 --> 00:04:18,760
for this data were the web reservation

00:04:16,539 --> 00:04:22,419
portal and the call center application

00:04:18,760 --> 00:04:26,380
that I explained earlier this schema is

00:04:22,419 --> 00:04:28,479
only here to serve for showing the

00:04:26,380 --> 00:04:31,000
concept it's by no means a complete

00:04:28,479 --> 00:04:32,249
diagram of how the legacy application

00:04:31,000 --> 00:04:36,079
was looking like when we

00:04:32,249 --> 00:04:40,439
um when we were tasked to refactor it

00:04:36,079 --> 00:04:42,599
what I wanted to see in this diagram is

00:04:40,439 --> 00:04:45,689
also the different types of data that

00:04:42,599 --> 00:04:47,429
live in the data layer first of all that

00:04:45,689 --> 00:04:50,009
they are the reservations that have

00:04:47,429 --> 00:04:52,289
already happened and for some of them

00:04:50,009 --> 00:04:55,619
you have to make an online check-in but

00:04:52,289 --> 00:04:57,809
this is a historical data basically the

00:04:55,619 --> 00:05:01,859
second type of information is the

00:04:57,809 --> 00:05:05,159
availability information where we tell

00:05:01,859 --> 00:05:08,549
people if they are more flights

00:05:05,159 --> 00:05:10,949
available and what the prices are it's a

00:05:08,549 --> 00:05:15,449
very complex pricing scheme for flight

00:05:10,949 --> 00:05:18,539
it's not like the normal pricing for

00:05:15,449 --> 00:05:21,479
product will just put a number as they

00:05:18,539 --> 00:05:24,989
go in batches of tickets and it also

00:05:21,479 --> 00:05:27,329
depends on the moment how long are you

00:05:24,989 --> 00:05:30,359
making the reservation before the actual

00:05:27,329 --> 00:05:33,479
flight and the price changes so a lot of

00:05:30,359 --> 00:05:37,469
complex rules on that then the third

00:05:33,479 --> 00:05:39,389
type of data is the static one so all

00:05:37,469 --> 00:05:42,329
kind of information about the flight

00:05:39,389 --> 00:05:44,069
itself but also about is the additional

00:05:42,329 --> 00:05:49,319
absurd products that this company

00:05:44,069 --> 00:05:51,329
selling our static data we will talk a

00:05:49,319 --> 00:05:57,360
little bit more about this particular

00:05:51,329 --> 00:06:00,659
one later when we were tasked with this

00:05:57,360 --> 00:06:04,739
project the mail environment from the

00:06:00,659 --> 00:06:07,289
customer was to enable a end-user to

00:06:04,739 --> 00:06:09,959
purchase full travel experience based on

00:06:07,289 --> 00:06:12,149
the destination so instead of just

00:06:09,959 --> 00:06:14,579
selling cheap plane tickets as Darrell

00:06:12,149 --> 00:06:16,169
low-cost carrier they sell a lot of

00:06:14,579 --> 00:06:18,899
other things centered around the

00:06:16,169 --> 00:06:21,929
destination so imagine you want to take

00:06:18,899 --> 00:06:23,369
home weekend trip you do purchase the

00:06:21,929 --> 00:06:26,459
plane tickets but you also have to

00:06:23,369 --> 00:06:29,639
reserve a hotel and maybe rent a car in

00:06:26,459 --> 00:06:33,239
the United States is quite common to to

00:06:29,639 --> 00:06:37,279
do that and maybe over the weekend you

00:06:33,239 --> 00:06:39,839
want to spend some time at some local

00:06:37,279 --> 00:06:42,439
attractions so they also sell tickets

00:06:39,839 --> 00:06:42,439
for those

00:06:45,290 --> 00:06:51,920
what will the constraints that our

00:06:47,880 --> 00:06:51,920
customer imposed on the solution the

00:06:51,980 --> 00:06:59,010
in-house reservations engine is written

00:06:54,960 --> 00:07:01,290
in Java and they keep it internally so

00:06:59,010 --> 00:07:04,640
the java team is located on with the

00:07:01,290 --> 00:07:07,590
customer premises we were tasked to

00:07:04,640 --> 00:07:10,050
recreate the web facing part using the

00:07:07,590 --> 00:07:12,360
lamp stack you know when you have a

00:07:10,050 --> 00:07:15,450
polyglot technology stack things are not

00:07:12,360 --> 00:07:17,940
as smooth as in then normal cases when

00:07:15,450 --> 00:07:20,640
you just have the same things over and

00:07:17,940 --> 00:07:22,710
over again like the traditional gauge be

00:07:20,640 --> 00:07:24,690
and my sequel and everything it's much

00:07:22,710 --> 00:07:26,220
more complex and the interactions

00:07:24,690 --> 00:07:28,590
between the different teams and the

00:07:26,220 --> 00:07:33,480
different skill sets required large

00:07:28,590 --> 00:07:37,410
amount of communication that everybody

00:07:33,480 --> 00:07:39,600
needed to handle as the second very

00:07:37,410 --> 00:07:42,600
important thing was that the customer

00:07:39,600 --> 00:07:45,960
was located on the pacific time zone and

00:07:42,600 --> 00:07:48,870
our developers were in the UK and in

00:07:45,960 --> 00:07:51,600
romania so stretching over ten time

00:07:48,870 --> 00:07:54,090
zones in terms of communication for a

00:07:51,600 --> 00:07:56,790
team it's not the most simple thing that

00:07:54,090 --> 00:07:59,730
you can do and it was a real challenge

00:07:56,790 --> 00:08:03,990
we were basically a non stop shop of

00:07:59,730 --> 00:08:06,870
developers it was a very great right to

00:08:03,990 --> 00:08:09,300
be honest but we developed some

00:08:06,870 --> 00:08:13,950
mechanisms that I will show a little bit

00:08:09,300 --> 00:08:16,260
later as well to overcome working too

00:08:13,950 --> 00:08:19,919
much on a different time zone than the

00:08:16,260 --> 00:08:21,510
one who are living in and of course the

00:08:19,919 --> 00:08:24,990
other constraint was booked completely

00:08:21,510 --> 00:08:28,250
replaced the monolithic application that

00:08:24,990 --> 00:08:28,250
the customer initially had

00:08:33,829 --> 00:08:42,029
the ID change was planned over a span of

00:08:38,939 --> 00:08:45,689
several years but the web facing part

00:08:42,029 --> 00:08:48,500
was quite critical because the website

00:08:45,689 --> 00:08:52,410
card our website already had problems

00:08:48,500 --> 00:08:56,459
when there were large traffic spikes so

00:08:52,410 --> 00:08:59,279
our deadline wasn't a couple of years it

00:08:56,459 --> 00:09:01,439
was one calendar year until next cyber

00:08:59,279 --> 00:09:03,149
monday we had to be up earning with

00:09:01,439 --> 00:09:06,899
everything with the complete user

00:09:03,149 --> 00:09:08,930
experience so how did we divide the

00:09:06,899 --> 00:09:12,810
calendar year into several milestones

00:09:08,930 --> 00:09:15,209
you can do just one single delivery

00:09:12,810 --> 00:09:19,500
first we tackle to the booking of

00:09:15,209 --> 00:09:21,899
meaning you start from the customer

00:09:19,500 --> 00:09:26,879
choosing the departure and destination

00:09:21,899 --> 00:09:28,680
Airport and do all the upselling until

00:09:26,879 --> 00:09:31,379
the pavement moment and the booking

00:09:28,680 --> 00:09:35,069
confirmation that was the first

00:09:31,379 --> 00:09:37,339
milestone the second one was to

00:09:35,069 --> 00:09:39,779
implement the online check-in experience

00:09:37,339 --> 00:09:42,750
which is much smaller one but also

00:09:39,779 --> 00:09:44,879
allows upsells of different products or

00:09:42,750 --> 00:09:46,949
if you didn't buy a rental car initially

00:09:44,879 --> 00:09:49,410
maybe you want to change your mind in

00:09:46,949 --> 00:09:53,029
white the second time during online

00:09:49,410 --> 00:09:55,379
checking our third milestone was

00:09:53,029 --> 00:09:58,559
completely dedicated to performance

00:09:55,379 --> 00:10:00,870
testing and tuning so in preparation for

00:09:58,559 --> 00:10:04,230
cyber monday we run different test and

00:10:00,870 --> 00:10:09,949
tune all the systems that we already had

00:10:04,230 --> 00:10:09,949
working and run automated tests on

00:10:12,480 --> 00:10:21,000
I will show you a little bit about the

00:10:16,440 --> 00:10:25,709
technologists like it wasn't a very

00:10:21,000 --> 00:10:28,709
simple thing to try to explain and put

00:10:25,709 --> 00:10:32,130
it in a diagram I will try to explain as

00:10:28,709 --> 00:10:36,360
much as I can but feel free to ask any

00:10:32,130 --> 00:10:41,510
questions yeah so interrupt me and ask

00:10:36,360 --> 00:10:46,829
me something if it's not very clear the

00:10:41,510 --> 00:10:49,470
data itself with the three kinds of data

00:10:46,829 --> 00:10:56,449
availability existing reservations and

00:10:49,470 --> 00:11:01,560
static data is sitting on on the bottom

00:10:56,449 --> 00:11:05,970
the only items accessing this data were

00:11:01,560 --> 00:11:08,730
a layer of Java services which are

00:11:05,970 --> 00:11:12,209
transactional by nature but what they do

00:11:08,730 --> 00:11:15,449
is that they finds the access to the

00:11:12,209 --> 00:11:18,750
actual database because if we wanted

00:11:15,449 --> 00:11:21,449
later too and we did to improve as the

00:11:18,750 --> 00:11:24,750
underlying data structures we could do

00:11:21,449 --> 00:11:26,839
that and not modify anything on top of

00:11:24,750 --> 00:11:26,839
it

00:11:34,270 --> 00:11:40,660
the Java services which will present to

00:11:38,980 --> 00:11:44,200
the actual booking engine with an

00:11:40,660 --> 00:11:49,120
in-house can be consumed by different

00:11:44,200 --> 00:11:52,980
clients let's call the client the web

00:11:49,120 --> 00:11:56,830
facing part is the very high traffic

00:11:52,980 --> 00:11:59,530
that we needed to isolate and actually

00:11:56,830 --> 00:12:03,100
if this was our delivery of the web

00:11:59,530 --> 00:12:05,080
fashiongirl applications but they could

00:12:03,100 --> 00:12:07,420
also be consumed by internal

00:12:05,080 --> 00:12:10,030
applications I showed them here as

00:12:07,420 --> 00:12:19,810
third-party in in the lack of a better

00:12:10,030 --> 00:12:22,720
name so on the web facing bits how did

00:12:19,810 --> 00:12:25,720
we actually do it we wrote the thin

00:12:22,720 --> 00:12:30,220
layer of PHP services on top of the

00:12:25,720 --> 00:12:33,340
reservations engine why do I call it a

00:12:30,220 --> 00:12:36,520
thin layer well because it has very

00:12:33,340 --> 00:12:39,970
small jason footprint so the

00:12:36,520 --> 00:12:44,710
communication in and out of those PHP

00:12:39,970 --> 00:12:50,230
services need to be very tiny in order

00:12:44,710 --> 00:12:52,270
to make it performant for its client its

00:12:50,230 --> 00:12:55,390
clients are JavaScript single page

00:12:52,270 --> 00:12:57,610
applications that serve the different

00:12:55,390 --> 00:12:59,860
purposes so if you are going through the

00:12:57,610 --> 00:13:02,500
booking path you have one single page

00:12:59,860 --> 00:13:05,920
application if you are going to do an

00:13:02,500 --> 00:13:08,800
online check-in there's a second single

00:13:05,920 --> 00:13:12,010
page application and so on as a back

00:13:08,800 --> 00:13:14,590
office you know can be done in any other

00:13:12,010 --> 00:13:20,950
technology but all of them will consume

00:13:14,590 --> 00:13:23,140
the same layer of PHP services maybe you

00:13:20,950 --> 00:13:26,290
are wondering why choose a single page

00:13:23,140 --> 00:13:28,510
application if you have PHP developers

00:13:26,290 --> 00:13:31,800
in house can't be just deliver some HTML

00:13:28,510 --> 00:13:34,270
front end on top of the services well

00:13:31,800 --> 00:13:36,190
the problem with the web facing

00:13:34,270 --> 00:13:39,280
applications is that they need to be

00:13:36,190 --> 00:13:43,450
really fast but you can't measure cost

00:13:39,280 --> 00:13:46,000
so in work on the perceived performance

00:13:43,450 --> 00:13:47,710
of your application by delivering a

00:13:46,000 --> 00:13:50,400
single page application that this

00:13:47,710 --> 00:13:54,490
it was in the client browser and then

00:13:50,400 --> 00:13:57,610
communicate with the PHP layer based on

00:13:54,490 --> 00:13:59,620
those very small Jason footprint and for

00:13:57,610 --> 00:14:02,980
the user average everything will appear

00:13:59,620 --> 00:14:06,520
as if it was working very fast even if

00:14:02,980 --> 00:14:08,380
the SBA may be a bit heavier at the

00:14:06,520 --> 00:14:18,700
customer doesn't feel it because they

00:14:08,380 --> 00:14:20,440
only load this thing was another

00:14:18,700 --> 00:14:24,730
question I received when I delivered

00:14:20,440 --> 00:14:27,730
this dog in much smaller groups was why

00:14:24,730 --> 00:14:31,420
do we need all this complexity what is

00:14:27,730 --> 00:14:34,030
it good for what in the time frame of

00:14:31,420 --> 00:14:38,350
one year we didn't even have one year

00:14:34,030 --> 00:14:40,480
for delivering the the actual

00:14:38,350 --> 00:14:45,070
functionality we need work in parallel

00:14:40,480 --> 00:14:47,770
so if you'd ask a game to deliver the

00:14:45,070 --> 00:14:49,630
PHP services you can't ask another team

00:14:47,770 --> 00:14:52,930
to deliver the single page applications

00:14:49,630 --> 00:14:54,760
and they can work in parallel so you

00:14:52,930 --> 00:14:57,700
effectively double your speed of

00:14:54,760 --> 00:15:02,470
development and deliver the full

00:14:57,700 --> 00:15:04,960
functional product in the end oh there

00:15:02,470 --> 00:15:10,080
are some security aspects that we needed

00:15:04,960 --> 00:15:15,250
to handle because of the call center

00:15:10,080 --> 00:15:17,800
required user authentication and it

00:15:15,250 --> 00:15:21,880
could the application itself could only

00:15:17,800 --> 00:15:27,130
be accessed from the VPN from the cloud

00:15:21,880 --> 00:15:29,530
premises so in order to skip

00:15:27,130 --> 00:15:33,670
implementing user logins and

00:15:29,530 --> 00:15:37,240
authentications and permissions we went

00:15:33,670 --> 00:15:40,600
to something already on the market that

00:15:37,240 --> 00:15:43,270
does this extremely well and this is the

00:15:40,600 --> 00:15:46,840
family of products known as the CMS so

00:15:43,270 --> 00:15:48,880
CMS's do manage content there are

00:15:46,840 --> 00:15:50,710
content management systems but before

00:15:48,880 --> 00:15:53,020
you get to manage the content you have

00:15:50,710 --> 00:15:55,750
to have all the user authentication in

00:15:53,020 --> 00:15:59,980
place so we just selected the CMS not

00:15:55,750 --> 00:16:02,860
not best option but the one that got us

00:15:59,980 --> 00:16:06,400
faster fastest in the market we chose

00:16:02,860 --> 00:16:11,320
tuple as a CMS I know it's not ideal but

00:16:06,400 --> 00:16:16,210
it worked and it was much easier to

00:16:11,320 --> 00:16:18,550
secure than other CMS's so we actually

00:16:16,210 --> 00:16:29,430
balanced the choice between perfect code

00:16:18,550 --> 00:16:34,240
and time-to-market so in all this

00:16:29,430 --> 00:16:37,750
technology items that I mentioned where

00:16:34,240 --> 00:16:42,520
exactly do they live and how to make

00:16:37,750 --> 00:16:44,860
them communicate with each other we

00:16:42,520 --> 00:16:51,250
introduced the architectural notion of a

00:16:44,860 --> 00:16:54,370
silo I will explain you very in a very

00:16:51,250 --> 00:16:59,590
simplistic way what the silo is we took

00:16:54,370 --> 00:17:04,449
each and every application and prepared

00:16:59,590 --> 00:17:06,880
a server fraid so the Drupal was

00:17:04,449 --> 00:17:09,839
packaged with the JavaScript single page

00:17:06,880 --> 00:17:12,730
application and deployed on one machine

00:17:09,839 --> 00:17:15,370
the symphony services were packed and

00:17:12,730 --> 00:17:18,160
deployed on another machine and then the

00:17:15,370 --> 00:17:19,660
cash was kept separate because access to

00:17:18,160 --> 00:17:24,370
it needed to be configured differently

00:17:19,660 --> 00:17:26,320
and if you put all of these things

00:17:24,370 --> 00:17:28,540
together you get like three machines

00:17:26,320 --> 00:17:30,970
which is obviously not the case if you

00:17:28,540 --> 00:17:33,790
want the scalable architecture you put

00:17:30,970 --> 00:17:35,890
multiple front-end machines and multiple

00:17:33,790 --> 00:17:37,600
bucking machines and we actually did

00:17:35,890 --> 00:17:40,420
some performance testing how many

00:17:37,600 --> 00:17:43,420
front-end boxes doing it how many

00:17:40,420 --> 00:17:45,940
back-end boxes do we need and when we

00:17:43,420 --> 00:17:49,330
obtained the number that delivered the

00:17:45,940 --> 00:17:52,120
end-to-end functionality of respecting

00:17:49,330 --> 00:17:56,980
the service level agreement we said okay

00:17:52,120 --> 00:18:00,300
all these machines represent a silo why

00:17:56,980 --> 00:18:00,300
only a solo

00:18:02,230 --> 00:18:07,460
because now you can go and scale

00:18:04,940 --> 00:18:09,890
everything horizontally so we put the

00:18:07,460 --> 00:18:12,830
full application in one silo let's say

00:18:09,890 --> 00:18:16,220
it takes 10 machines in after

00:18:12,830 --> 00:18:18,920
measurement in one scenario and then you

00:18:16,220 --> 00:18:22,670
raise another silo of 10 machines and

00:18:18,920 --> 00:18:25,400
another side of 10 machines on demand if

00:18:22,670 --> 00:18:29,120
you don't need it you don't like all the

00:18:25,400 --> 00:18:32,420
setup you can't achieve these things

00:18:29,120 --> 00:18:35,150
manually so we do have a great devops

00:18:32,420 --> 00:18:39,140
team that automated all of these things

00:18:35,150 --> 00:18:42,890
with the ansible so i strongly recommend

00:18:39,140 --> 00:18:46,280
you do the same if you don't have their

00:18:42,890 --> 00:18:49,780
skills in house try to get some they are

00:18:46,280 --> 00:18:49,780
very very good

00:19:00,780 --> 00:19:09,420
I I want to explain a little bit how we

00:19:05,910 --> 00:19:11,640
do the upgrades of the software it's not

00:19:09,420 --> 00:19:14,640
very intuitive but once you get it you

00:19:11,640 --> 00:19:17,130
will definitely like it there is there

00:19:14,640 --> 00:19:21,540
was one hard requirement you can't have

00:19:17,130 --> 00:19:24,600
the website down at all so not like at

00:19:21,540 --> 00:19:27,720
night for one minute no you can't have

00:19:24,600 --> 00:19:31,080
it offline so what do you do you take

00:19:27,720 --> 00:19:35,180
one silo down and have the f5 load

00:19:31,080 --> 00:19:39,480
balancer serve the website using the

00:19:35,180 --> 00:19:41,820
remaining one or two silos it proud all

00:19:39,480 --> 00:19:44,280
the traffic in there and in the first

00:19:41,820 --> 00:19:45,780
silo you do the upgrade so you put all

00:19:44,280 --> 00:19:52,020
the new code and online functionality

00:19:45,780 --> 00:19:55,170
and then declare it as live for the f5

00:19:52,020 --> 00:19:57,600
load balancer and then slowly traffic

00:19:55,170 --> 00:20:00,210
will be routed to it so all of a sudden

00:19:57,600 --> 00:20:02,360
you have the old application and the new

00:20:00,210 --> 00:20:05,580
application running at the same time

00:20:02,360 --> 00:20:09,510
without anybody noticing that you have

00:20:05,580 --> 00:20:12,990
done an upgrade and then take the second

00:20:09,510 --> 00:20:17,370
silo down and upgrade that one as well

00:20:12,990 --> 00:20:19,050
and let's say things go wrong you still

00:20:17,370 --> 00:20:23,240
have the website running because you

00:20:19,050 --> 00:20:26,460
made the upgrade on the first silo so

00:20:23,240 --> 00:20:29,400
even if it's not intuitive it's very

00:20:26,460 --> 00:20:34,980
powerful you have to session stickiness

00:20:29,400 --> 00:20:37,050
for this so you have to tell f5 that

00:20:34,980 --> 00:20:41,430
once the session is open for specific

00:20:37,050 --> 00:20:44,310
silo it has to keep with all the next

00:20:41,430 --> 00:20:47,190
request from that user inside the silo

00:20:44,310 --> 00:20:50,130
because you want the same version of the

00:20:47,190 --> 00:20:52,080
application to be served to that user so

00:20:50,130 --> 00:20:54,660
taking a silo down is not instantaneous

00:20:52,080 --> 00:20:57,000
you have to wait for the sessions to

00:20:54,660 --> 00:20:59,160
drain out all the users to finish what

00:20:57,000 --> 00:21:04,730
they were doing on the website it takes

00:20:59,160 --> 00:21:07,260
10 minutes maybe but only when nobody is

00:21:04,730 --> 00:21:09,440
interacting with that silo you can take

00:21:07,260 --> 00:21:09,440
it down

00:21:10,159 --> 00:21:17,760
can you spot an additional benefit other

00:21:14,220 --> 00:21:21,419
than keeping from the actual application

00:21:17,760 --> 00:21:24,929
live all the time what does can we do

00:21:21,419 --> 00:21:29,039
with so many silos and the different

00:21:24,929 --> 00:21:32,610
versions of the same software awesome

00:21:29,039 --> 00:21:35,429
that's exactly what they did and the

00:21:32,610 --> 00:21:37,620
marketing was really happy that they got

00:21:35,429 --> 00:21:38,669
this for free what did you say we

00:21:37,620 --> 00:21:40,830
couldn't hear you in the other room the

00:21:38,669 --> 00:21:42,179
answer was a be testing I thought it was

00:21:40,830 --> 00:21:52,679
gonna be I be testing hey thank you

00:21:42,179 --> 00:21:55,860
thanks okay I promise this will get more

00:21:52,679 --> 00:21:59,130
technical it's now all architecture and

00:21:55,860 --> 00:22:03,299
a lot of words and maybe it's mmm it's

00:21:59,130 --> 00:22:05,159
not very fun in the beginning I

00:22:03,299 --> 00:22:10,649
mentioned you that one of the types of

00:22:05,159 --> 00:22:13,320
data is the static data so basically we

00:22:10,649 --> 00:22:16,669
asked ourselves why go through all the

00:22:13,320 --> 00:22:19,980
trouble of setting so many items and the

00:22:16,669 --> 00:22:22,049
stacks if every time you need to show

00:22:19,980 --> 00:22:25,110
something on the user screen you have to

00:22:22,049 --> 00:22:33,799
go inside and hit the database was the

00:22:25,110 --> 00:22:38,029
point so of course the answer is caching

00:22:33,799 --> 00:22:47,279
how how did we use caching in this

00:22:38,029 --> 00:22:51,529
particular setup we took the static data

00:22:47,279 --> 00:22:57,350
out of the bottom layer and promoted

00:22:51,529 --> 00:23:01,289
much upper in the Arab I'd leave them

00:22:57,350 --> 00:23:03,390
eat these services that consume this

00:23:01,289 --> 00:23:04,919
cash and maintain it because somebody

00:23:03,390 --> 00:23:08,159
also has to populate it with the

00:23:04,919 --> 00:23:10,230
information were very happy that they

00:23:08,159 --> 00:23:12,929
didn't have to go through the Java stack

00:23:10,230 --> 00:23:15,720
at all imagine you want to show one of

00:23:12,929 --> 00:23:18,250
the hotels that we want to let people

00:23:15,720 --> 00:23:20,050
stay in you can't get the hotel

00:23:18,250 --> 00:23:22,150
and the hotel description and image

00:23:20,050 --> 00:23:25,510
every time from the tablets or from the

00:23:22,150 --> 00:23:28,030
file system it's not going to work so

00:23:25,510 --> 00:23:31,270
our technical solution for caching was a

00:23:28,030 --> 00:23:37,090
varnish varnish is a very powerful

00:23:31,270 --> 00:23:40,570
workhorse and it delivered very very

00:23:37,090 --> 00:23:43,260
good things all of our static

00:23:40,570 --> 00:23:48,310
information was being pre-calculated

00:23:43,260 --> 00:23:50,460
when deploying a new silo the new

00:23:48,310 --> 00:23:52,810
version of the application we also

00:23:50,460 --> 00:23:55,930
prefetched all the information in cash

00:23:52,810 --> 00:24:00,060
so then everybody coming and asking for

00:23:55,930 --> 00:24:04,660
data they were instantly hitting varnish

00:24:00,060 --> 00:24:07,150
it is also added to the total deployment

00:24:04,660 --> 00:24:11,370
time so you can't do these things by

00:24:07,150 --> 00:24:15,550
magic you have to take time to go and

00:24:11,370 --> 00:24:23,610
populate also the cash not only wait for

00:24:15,550 --> 00:24:23,610
the sessions to drain out of a silo and

00:24:24,240 --> 00:24:30,120
by bringing it so close to the client

00:24:27,360 --> 00:24:32,370
browser we were also able to have the

00:24:30,120 --> 00:24:36,179
single page applications make requests

00:24:32,370 --> 00:24:38,670
directly to the caf so not even go from

00:24:36,179 --> 00:24:42,200
JavaScript PHP and then to varnish they

00:24:38,670 --> 00:24:47,580
went directly i will show you

00:24:42,200 --> 00:24:53,610
immediately a more clear diagram on how

00:24:47,580 --> 00:24:55,950
that happens so silo is just a generic

00:24:53,610 --> 00:24:59,160
concept right a bunch of servers with

00:24:55,950 --> 00:25:01,910
different targets some of them are doing

00:24:59,160 --> 00:25:07,100
the front end the others at the back end

00:25:01,910 --> 00:25:07,100
but what exactly do i put in a silo

00:25:07,790 --> 00:25:14,250
first of all we use varnish as a

00:25:10,760 --> 00:25:16,559
dispatcher mechanism and hide all the

00:25:14,250 --> 00:25:22,380
interactions with the silo behind

00:25:16,559 --> 00:25:26,429
varnish the drupal and single page

00:25:22,380 --> 00:25:29,760
applications are one box right each so

00:25:26,429 --> 00:25:33,679
front-end boxes the symphony machines

00:25:29,760 --> 00:25:37,920
are the backend boxes then you have

00:25:33,679 --> 00:25:40,590
memcache for sessions because sessions

00:25:37,920 --> 00:25:43,650
in the database are so slow every time

00:25:40,590 --> 00:25:46,350
and then the static data which we

00:25:43,650 --> 00:25:50,090
completely separated from memcache so

00:25:46,350 --> 00:25:53,600
static data was file system based and

00:25:50,090 --> 00:25:57,660
varnish communicating to the static data

00:25:53,600 --> 00:25:59,970
was much faster because then it could

00:25:57,660 --> 00:26:04,830
already catch all the static information

00:25:59,970 --> 00:26:06,660
straighten varnish so imagine a call

00:26:04,830 --> 00:26:15,090
center agent receives a phone call and

00:26:06,660 --> 00:26:18,030
logs in once they do this the heat

00:26:15,090 --> 00:26:21,030
varnish which then routes the request to

00:26:18,030 --> 00:26:23,280
the front end Bob's they perform the

00:26:21,030 --> 00:26:27,059
authentication right come with their

00:26:23,280 --> 00:26:29,550
username and password and then the

00:26:27,059 --> 00:26:31,920
single page application written in

00:26:29,550 --> 00:26:34,580
javascript is the only one interacting

00:26:31,920 --> 00:26:34,580
any further

00:26:35,409 --> 00:26:43,119
the customer on the other end of the

00:26:38,659 --> 00:26:48,589
phone line asks for a specific route and

00:26:43,119 --> 00:26:51,440
some days they make the search but once

00:26:48,589 --> 00:26:55,159
this happens so once you select the

00:26:51,440 --> 00:26:58,099
destination and the time frame you can

00:26:55,159 --> 00:27:00,669
immediately cash even availability

00:26:58,099 --> 00:27:05,749
information and promote it to memcache

00:27:00,669 --> 00:27:09,469
so then the user will get all the

00:27:05,749 --> 00:27:12,139
information almost for free even if it's

00:27:09,469 --> 00:27:14,330
very dynamic information like

00:27:12,139 --> 00:27:20,960
availability which is subject to change

00:27:14,330 --> 00:27:23,509
every couple of seconds so how do you

00:27:20,960 --> 00:27:26,239
populate the cap you pick the actual

00:27:23,509 --> 00:27:28,820
availability information from the Java

00:27:26,239 --> 00:27:32,450
layer so subsequently from the database

00:27:28,820 --> 00:27:34,009
and enrich it with the static data so we

00:27:32,450 --> 00:27:36,080
put in the hotel name in the hotel

00:27:34,009 --> 00:27:38,599
description another thing you add this

00:27:36,080 --> 00:27:43,399
information and then write the

00:27:38,599 --> 00:27:46,879
destination Jason in memcache all the

00:27:43,399 --> 00:27:49,969
further requests will go and hit varnish

00:27:46,879 --> 00:27:53,629
and memcache directly this is very fast

00:27:49,969 --> 00:27:56,119
and very powerful I will not tell you

00:27:53,629 --> 00:27:58,940
numbers because I'm not be believer in

00:27:56,119 --> 00:28:01,519
statistics so I I won't tell you how

00:27:58,940 --> 00:28:06,729
many times this improved the actual user

00:28:01,519 --> 00:28:06,729
experience but it improved it by a lot

00:28:09,729 --> 00:28:15,109
ok so this was the very trying

00:28:13,009 --> 00:28:18,409
architecture bit what about the

00:28:15,109 --> 00:28:21,139
developers right we said the development

00:28:18,409 --> 00:28:24,200
team will spread over ten time zones and

00:28:21,139 --> 00:28:27,049
it's not really funny to have to work in

00:28:24,200 --> 00:28:30,169
the middle of the night so what we

00:28:27,049 --> 00:28:33,109
collocated were the actual teams doing

00:28:30,169 --> 00:28:36,169
is the front end or back end services so

00:28:33,109 --> 00:28:40,009
each team was co-located and the way

00:28:36,169 --> 00:28:43,789
these teams communicated work through

00:28:40,009 --> 00:28:46,489
fixtures so we upfront when and wrote

00:28:43,789 --> 00:28:48,820
all the contracts between various layers

00:28:46,489 --> 00:28:52,460
of the application

00:28:48,820 --> 00:28:55,130
each of the components can be seen as a

00:28:52,460 --> 00:29:00,049
black box if you want so just write them

00:28:55,130 --> 00:29:02,659
Jason's that go in and ones that go out

00:29:00,049 --> 00:29:05,809
and then the front end guys can just go

00:29:02,659 --> 00:29:08,530
and code against those pictures right to

00:29:05,809 --> 00:29:12,799
their own automated destitute

00:29:08,530 --> 00:29:15,320
independently they just hope the back

00:29:12,799 --> 00:29:18,530
end guys will respect these contracts

00:29:15,320 --> 00:29:21,530
and the back end guys go and pick the

00:29:18,530 --> 00:29:24,919
pictures and work in order to implement

00:29:21,530 --> 00:29:27,860
with that functionality the same goes

00:29:24,919 --> 00:29:32,179
for the Java layer so all of these

00:29:27,860 --> 00:29:34,549
separations were very straight and it it

00:29:32,179 --> 00:29:40,490
really helped us work in parallel at

00:29:34,549 --> 00:29:43,340
normal decent times during the day so if

00:29:40,490 --> 00:29:46,190
we are to summarize what fixture basted

00:29:43,340 --> 00:29:49,250
development looks like basically it

00:29:46,190 --> 00:29:52,400
enforces discussing contract beforehand

00:29:49,250 --> 00:29:55,970
so you have two types of items that you

00:29:52,400 --> 00:29:58,130
need to discuss the happy flow when

00:29:55,970 --> 00:30:00,830
everything goes fine this is how the

00:29:58,130 --> 00:30:04,039
information will look like and then you

00:30:00,830 --> 00:30:06,950
go through the negative scenarios like

00:30:04,039 --> 00:30:08,950
what if something is not available what

00:30:06,950 --> 00:30:12,679
if that they tend the cash has expired

00:30:08,950 --> 00:30:15,289
what if something else happens all of

00:30:12,679 --> 00:30:18,710
these things are at least 14 it was and

00:30:15,289 --> 00:30:20,780
planned accordingly so you can view how

00:30:18,710 --> 00:30:23,690
your next week or couple of weeks will

00:30:20,780 --> 00:30:28,990
look like which is quite awesome if you

00:30:23,690 --> 00:30:34,490
ask any manager another thing that

00:30:28,990 --> 00:30:38,090
really helped us was that every

00:30:34,490 --> 00:30:39,740
developer could run their own part of

00:30:38,090 --> 00:30:43,909
the application or the individual

00:30:39,740 --> 00:30:46,730
machine the total setup is very complex

00:30:43,909 --> 00:30:50,140
and nobody will really want to run it on

00:30:46,730 --> 00:30:53,690
a single laptop so the independence that

00:30:50,140 --> 00:30:59,290
fixtures offered the our developers was

00:30:53,690 --> 00:31:01,060
very appreciated and of course the post

00:30:59,290 --> 00:31:05,400
lity to test independently each

00:31:01,060 --> 00:31:05,400
component is quite a light bonus

00:31:14,940 --> 00:31:29,720
okay this will get even funnier so does

00:31:21,690 --> 00:31:29,720
anybody know what to form is no content

00:31:31,940 --> 00:31:41,580
okay we have an answer from here so

00:31:37,460 --> 00:31:43,950
you're very right the to offer is

00:31:41,580 --> 00:31:49,200
actually an HTTP status code it

00:31:43,950 --> 00:31:51,600
represents a success code saying that

00:31:49,200 --> 00:31:55,230
everything went fine but it doesn't

00:31:51,600 --> 00:31:58,470
offer anything in return so the specific

00:31:55,230 --> 00:32:00,900
bit about to offer is that the actual

00:31:58,470 --> 00:32:04,560
content that it is transmitted back as a

00:32:00,900 --> 00:32:08,190
response is 0 you can't put anything in

00:32:04,560 --> 00:32:13,170
the responsible 24 request the response

00:32:08,190 --> 00:32:17,430
I mean so why is this a trick and what

00:32:13,170 --> 00:32:19,890
do you actually do with it what the back

00:32:17,430 --> 00:32:22,680
end says okay I received a request thank

00:32:19,890 --> 00:32:24,600
you very much it can validate the

00:32:22,680 --> 00:32:26,850
request and if it's not valid it written

00:32:24,600 --> 00:32:30,150
of course it different status code but

00:32:26,850 --> 00:32:32,370
if everything is ok it just in the back

00:32:30,150 --> 00:32:34,590
end you go and continue doing the work

00:32:32,370 --> 00:32:39,330
the actual processing maybe it's heavier

00:32:34,590 --> 00:32:41,670
and the client basically the JavaScript

00:32:39,330 --> 00:32:44,580
application can continue doing other

00:32:41,670 --> 00:32:53,220
things like loading images and offering

00:32:44,580 --> 00:32:55,590
the user the perceived speed so I just

00:32:53,220 --> 00:32:59,130
put together a diagram to feel a little

00:32:55,590 --> 00:33:02,630
bit how this is happening let's say the

00:32:59,130 --> 00:33:07,320
user come in comes in the search for

00:33:02,630 --> 00:33:10,880
flight crew tomorrow it will hit Drupal

00:33:07,320 --> 00:33:14,250
because that's the front layer and

00:33:10,880 --> 00:33:18,180
Drupal we just post the search data to

00:33:14,250 --> 00:33:20,730
the thin layer of PHP services which

00:33:18,180 --> 00:33:23,220
will immediately validate it and return

00:33:20,730 --> 00:33:26,810
to offer no content saying thank you I

00:33:23,220 --> 00:33:29,360
received this request I will go and

00:33:26,810 --> 00:33:32,100
deliver it

00:33:29,360 --> 00:33:33,960
so what happens here is that the

00:33:32,100 --> 00:33:36,200
symphony layer will perform the actual

00:33:33,960 --> 00:33:39,390
flight search in the Java layer and

00:33:36,200 --> 00:33:41,850
we'll get all the availability

00:33:39,390 --> 00:33:45,270
information straight from the oven so

00:33:41,850 --> 00:33:48,600
this is not getting information but it

00:33:45,270 --> 00:33:52,080
will put all the data amid immediately

00:33:48,600 --> 00:33:56,580
into memcache so all the next steps of a

00:33:52,080 --> 00:33:58,020
user journey will happen only discussing

00:33:56,580 --> 00:34:01,190
with memcache you don't need to go to

00:33:58,020 --> 00:34:04,980
Java layer anymore and hedge heavy data

00:34:01,190 --> 00:34:08,610
so Drupal after receiving the success

00:34:04,980 --> 00:34:10,800
code will go and initialize the

00:34:08,610 --> 00:34:13,230
JavaScript single application with all

00:34:10,800 --> 00:34:17,460
the information about the search both

00:34:13,230 --> 00:34:19,919
the user and will update the UI to the

00:34:17,460 --> 00:34:22,830
next step so the user will see something

00:34:19,919 --> 00:34:25,409
is happening while the back end layer

00:34:22,830 --> 00:34:30,990
still fetches the data and write it into

00:34:25,409 --> 00:34:34,320
memcache and then the UI will constantly

00:34:30,990 --> 00:34:37,080
pull memcache do have data from yet do

00:34:34,320 --> 00:34:39,629
have any new information about this

00:34:37,080 --> 00:34:42,780
search and once the flight information

00:34:39,629 --> 00:34:45,919
is there which is usually almost

00:34:42,780 --> 00:34:48,480
immediately so the user doesn't see this

00:34:45,919 --> 00:34:51,629
it will just hatched the flights and

00:34:48,480 --> 00:34:53,609
roll them on the user screen but this

00:34:51,629 --> 00:34:57,830
particular way of doing things allows

00:34:53,609 --> 00:35:02,430
you to have a fallback mechanism in case

00:34:57,830 --> 00:35:04,560
the Java services go slower and the user

00:35:02,430 --> 00:35:07,410
still sees that something is happening

00:35:04,560 --> 00:35:10,470
in their user interface and eventually

00:35:07,410 --> 00:35:15,840
the flights will arrive and will be

00:35:10,470 --> 00:35:18,690
displayed on the screen another place

00:35:15,840 --> 00:35:22,260
where we use the 204 trick was not in

00:35:18,690 --> 00:35:26,040
the front end but in the back end when

00:35:22,260 --> 00:35:30,530
doing very large batch processing we

00:35:26,040 --> 00:35:34,230
discovered that the same trick can apply

00:35:30,530 --> 00:35:36,119
so of course you going check for

00:35:34,230 --> 00:35:41,570
permissions is the person calling this

00:35:36,119 --> 00:35:41,570
method allowed to do this operation

00:35:42,279 --> 00:35:52,400
get the request and validated and if

00:35:49,460 --> 00:35:55,160
everything goes okay the batch

00:35:52,400 --> 00:35:57,499
processing can start but first of all we

00:35:55,160 --> 00:36:00,710
just returned to her no content and then

00:35:57,499 --> 00:36:03,229
go and work on all the atoms and the

00:36:00,710 --> 00:36:09,589
collie is non blocking in this moment

00:36:03,229 --> 00:36:12,440
which is quite important so how do you

00:36:09,589 --> 00:36:14,930
actually implement this in PHP just

00:36:12,440 --> 00:36:17,180
because it's a HP conference with we

00:36:14,930 --> 00:36:20,210
can't go without showing some some of

00:36:17,180 --> 00:36:23,630
the meat it's very simple you put the

00:36:20,210 --> 00:36:26,720
header specifying the tofranil content

00:36:23,630 --> 00:36:30,499
and you must say that content length is

00:36:26,720 --> 00:36:33,410
true and not return anything and just do

00:36:30,499 --> 00:36:37,940
flush or will be flush depends on what

00:36:33,410 --> 00:36:42,200
you what your code is we did it in

00:36:37,940 --> 00:36:45,069
symphony so in symphony there is a very

00:36:42,200 --> 00:36:49,999
nice class it's called streamed response

00:36:45,069 --> 00:36:54,170
which helps you implement this you set

00:36:49,999 --> 00:36:58,039
the status code go for add the closing

00:36:54,170 --> 00:37:03,190
connection header and then you place an

00:36:58,039 --> 00:37:03,190
empty callback function in the response

00:37:07,140 --> 00:37:09,950
like this

00:37:11,869 --> 00:37:19,210
a mandatory step that is sometimes the

00:37:15,460 --> 00:37:22,099
skipped and prone to bugs is the

00:37:19,210 --> 00:37:23,869
preparation of the response that needs

00:37:22,099 --> 00:37:26,480
to be compliant with the HTTP

00:37:23,869 --> 00:37:29,809
specification and then you just send it

00:37:26,480 --> 00:37:33,140
over the wire the really interesting

00:37:29,809 --> 00:37:35,180
part is the callback function that does

00:37:33,140 --> 00:37:36,710
nothing in this case so if you want to

00:37:35,180 --> 00:37:38,329
implement the same thing but with the

00:37:36,710 --> 00:37:42,880
different status code and you want to

00:37:38,329 --> 00:37:45,380
actually return items data you just

00:37:42,880 --> 00:37:53,599
instead of doing nothing you just write

00:37:45,380 --> 00:37:58,970
the normal implementation ok so this

00:37:53,599 --> 00:38:02,539
event I told you that we use them topher

00:37:58,970 --> 00:38:04,279
for backing application that we used

00:38:02,539 --> 00:38:07,309
internally it's an event logging system

00:38:04,279 --> 00:38:10,220
so imagine all of these machines with

00:38:07,309 --> 00:38:12,470
different purposes have to load data and

00:38:10,220 --> 00:38:15,380
you can't go and read the application

00:38:12,470 --> 00:38:19,309
log of each machine when something goes

00:38:15,380 --> 00:38:22,069
wrong to just get an event logging

00:38:19,309 --> 00:38:23,390
system that is flowing all the log in to

00:38:22,069 --> 00:38:27,710
the same place so we can actually

00:38:23,390 --> 00:38:30,289
saturate using the tool for mechanism

00:38:27,710 --> 00:38:31,999
you can send information even from the

00:38:30,289 --> 00:38:34,279
front end and also from the back end

00:38:31,999 --> 00:38:36,140
component they just throw detain the log

00:38:34,279 --> 00:38:37,849
and because they get the topher no

00:38:36,140 --> 00:38:43,160
content they can quickly go and process

00:38:37,849 --> 00:38:45,859
the rest of the information something

00:38:43,160 --> 00:38:50,200
like this you just send it out below and

00:38:45,859 --> 00:38:54,200
then the tofranil content comes back and

00:38:50,200 --> 00:38:57,619
then the actual processing can take

00:38:54,200 --> 00:38:59,029
place independently so I have two

00:38:57,619 --> 00:39:02,119
screenshots from our internal

00:38:59,029 --> 00:39:06,950
application this is how it looks like we

00:39:02,119 --> 00:39:10,220
tagged every component you see Drupal

00:39:06,950 --> 00:39:12,999
symphony Ross web is the Java layer and

00:39:10,220 --> 00:39:16,430
the JavaScript single page application

00:39:12,999 --> 00:39:19,269
we color coded them to be able to find

00:39:16,430 --> 00:39:19,269
things faster

00:39:20,260 --> 00:39:26,680
and you can immediately see how long

00:39:23,110 --> 00:39:32,260
each request took and how long each

00:39:26,680 --> 00:39:35,020
service actually worked and if you zoom

00:39:32,260 --> 00:39:37,090
in on one of these things you can see

00:39:35,020 --> 00:39:42,250
the event the start and the end event

00:39:37,090 --> 00:39:43,660
and the date you can even in the latest

00:39:42,250 --> 00:39:46,840
version of the application you can even

00:39:43,660 --> 00:39:51,120
go inside and see the request and the

00:39:46,840 --> 00:39:56,280
responses straight from this timeline I

00:39:51,120 --> 00:40:02,800
will have to go a little bit faster yeah

00:39:56,280 --> 00:40:05,680
next topic on down lessons learned was

00:40:02,800 --> 00:40:07,390
error handling so after talking about

00:40:05,680 --> 00:40:10,000
the architecture and the Topher trick

00:40:07,390 --> 00:40:13,030
the next thing is how did we discuss the

00:40:10,000 --> 00:40:15,010
contract for fixtures outside of the

00:40:13,030 --> 00:40:17,320
heavy flow so the heavy flow is

00:40:15,010 --> 00:40:20,140
something that everybody jumps to

00:40:17,320 --> 00:40:24,730
implement but when it comes to handling

00:40:20,140 --> 00:40:27,700
errors things need to be discussed a bit

00:40:24,730 --> 00:40:31,020
further so we split the errors into two

00:40:27,700 --> 00:40:36,820
types the recoverable ones which the

00:40:31,020 --> 00:40:40,090
application can actually come back and

00:40:36,820 --> 00:40:42,970
serve the user for the same search so

00:40:40,090 --> 00:40:45,670
let's say that there was a selector

00:40:42,970 --> 00:40:49,300
hotel which is no longer available you

00:40:45,670 --> 00:40:51,820
return the user to the hotel choosing

00:40:49,300 --> 00:40:54,160
page and say this is no longer available

00:40:51,820 --> 00:40:56,920
please select a different hotel this is

00:40:54,160 --> 00:41:00,370
a recoverable error but non recoverable

00:40:56,920 --> 00:41:04,750
er is when something goes really bad so

00:41:00,370 --> 00:41:09,180
we used for exact status codes for all

00:41:04,750 --> 00:41:12,340
the cover of errors conflict was

00:41:09,180 --> 00:41:13,810
specifically used for the case 12 people

00:41:12,340 --> 00:41:16,480
wanted to book the same seat in the

00:41:13,810 --> 00:41:19,030
plane you had a conflict but you didn't

00:41:16,480 --> 00:41:21,010
know until both of them got to the end

00:41:19,030 --> 00:41:23,440
up to booking path one of them did

00:41:21,010 --> 00:41:26,320
purchase the seat and the other one got

00:41:23,440 --> 00:41:28,180
the 49 conflict and we instructed the

00:41:26,320 --> 00:41:31,750
user interface what was the step that

00:41:28,180 --> 00:41:33,280
needed to be displayed to the user when

00:41:31,750 --> 00:41:37,000
they were taken back so

00:41:33,280 --> 00:41:39,790
don't say this is this seat is taken

00:41:37,000 --> 00:41:42,760
just click here to go to the seat

00:41:39,790 --> 00:41:44,740
selection page no you just do this thing

00:41:42,760 --> 00:41:48,730
inside the JavaScript single page

00:41:44,740 --> 00:41:52,990
application and for the actual problems

00:41:48,730 --> 00:41:58,090
where a server dies or worse we used

00:41:52,990 --> 00:42:00,310
five exact status code this is quite

00:41:58,090 --> 00:42:02,230
simple you don't have many of them you

00:42:00,310 --> 00:42:04,810
just say something is completely wrong

00:42:02,230 --> 00:42:06,940
we cannot recover your search your

00:42:04,810 --> 00:42:13,870
booking so you have to start all over

00:42:06,940 --> 00:42:16,750
again and because of the complexity of

00:42:13,870 --> 00:42:18,730
the application not only did we catch a

00:42:16,750 --> 00:42:21,730
lot of data but we also needed to

00:42:18,730 --> 00:42:24,280
execute things in parallel which is not

00:42:21,730 --> 00:42:29,890
very trivial in PHP but it can be done

00:42:24,280 --> 00:42:35,020
and I'm sure a lot of you have worked

00:42:29,890 --> 00:42:41,340
with Cu RL functions to access certain

00:42:35,020 --> 00:42:44,380
data there is another side of the story

00:42:41,340 --> 00:42:48,670
the multi curl functions allow you to

00:42:44,380 --> 00:42:52,750
execute things at the same time and they

00:42:48,670 --> 00:42:54,490
are quite old there I think they have 10

00:42:52,750 --> 00:42:57,070
years of implementation but what people

00:42:54,490 --> 00:43:00,550
don't normally know about them so i

00:42:57,070 --> 00:43:04,360
encourage you to to have a read and play

00:43:00,550 --> 00:43:07,470
with them they're very powerful one

00:43:04,360 --> 00:43:11,350
thing must be said that when you start

00:43:07,470 --> 00:43:13,690
executing multiple things in PHP using

00:43:11,350 --> 00:43:15,550
curl multi specifically you have to wait

00:43:13,690 --> 00:43:18,660
for the longest request to finish

00:43:15,550 --> 00:43:24,610
processing before we move on to the next

00:43:18,660 --> 00:43:30,300
line code and if used leftover mechanism

00:43:24,610 --> 00:43:34,950
you can get around that quite easily and

00:43:30,300 --> 00:43:38,710
a very short example of how we used this

00:43:34,950 --> 00:43:41,380
actual current multi in practice so

00:43:38,710 --> 00:43:43,390
monster flights were selected right you

00:43:41,380 --> 00:43:45,840
make a search for a specification

00:43:43,390 --> 00:43:47,970
destination for some dates but

00:43:45,840 --> 00:43:51,810
then you decide with your flight you

00:43:47,970 --> 00:43:54,090
want to do back and then we were

00:43:51,810 --> 00:43:57,000
searching in parallels for the available

00:43:54,090 --> 00:44:01,080
hotels in those time frames for the

00:43:57,000 --> 00:44:05,130
vehicles Sid map for the two flights

00:44:01,080 --> 00:44:06,930
that were selected by the user and when

00:44:05,130 --> 00:44:09,380
you see product it's bought tickets to

00:44:06,930 --> 00:44:12,420
various events happening in that

00:44:09,380 --> 00:44:16,740
destination location in the time frame

00:44:12,420 --> 00:44:19,290
all of these were executed in parallel

00:44:16,740 --> 00:44:22,560
and then all the information about this

00:44:19,290 --> 00:44:26,280
was specifically tied to the search that

00:44:22,560 --> 00:44:29,670
the user was making initially and was

00:44:26,280 --> 00:44:32,870
placed in memcache for a very quick

00:44:29,670 --> 00:44:36,150
access so then when the user interface

00:44:32,870 --> 00:44:37,770
was updated to the next step they could

00:44:36,150 --> 00:44:49,440
fetch in the hotel information straight

00:44:37,770 --> 00:44:52,830
from memcache and I want to quickly sum

00:44:49,440 --> 00:44:56,430
this up that inside of a symphony

00:44:52,830 --> 00:44:59,640
service when we talked about the static

00:44:56,430 --> 00:45:04,380
data this is how things were happening

00:44:59,640 --> 00:45:08,420
in real life so at the request comes in

00:45:04,380 --> 00:45:12,390
to the PHP service and the availability

00:45:08,420 --> 00:45:14,850
heavy data coming from Java is mixed and

00:45:12,390 --> 00:45:17,280
matched with the static data about to

00:45:14,850 --> 00:45:23,180
the hotel or about the destination and

00:45:17,280 --> 00:45:27,630
then the results were kept very quick

00:45:23,180 --> 00:45:32,390
conclusions I hope I didn't bore you too

00:45:27,630 --> 00:45:36,300
much so the first architectural item

00:45:32,390 --> 00:45:38,370
that we learned by writing the

00:45:36,300 --> 00:45:42,260
application I thinking about it were the

00:45:38,370 --> 00:45:45,060
silos a very powerful concept that I

00:45:42,260 --> 00:45:47,310
strongly recommend you to explore if you

00:45:45,060 --> 00:45:50,990
have really large applications it's

00:45:47,310 --> 00:45:50,990
worth the work

00:45:52,130 --> 00:45:57,420
static data being brought as close to

00:45:54,930 --> 00:45:59,400
the customer as possible allows the

00:45:57,420 --> 00:46:01,650
actual end user to think that the

00:45:59,400 --> 00:46:04,170
application is very fast even if some

00:46:01,650 --> 00:46:08,279
parts of it are not necessarily as fast

00:46:04,170 --> 00:46:12,769
as perceived fixture based development

00:46:08,279 --> 00:46:16,650
help us overcome the timezone issue and

00:46:12,769 --> 00:46:19,019
to discipline our teams into writing

00:46:16,650 --> 00:46:23,220
code that respected certain

00:46:19,019 --> 00:46:25,829
specifications I don't like the

00:46:23,220 --> 00:46:29,549
microservices word so I said I wrote

00:46:25,829 --> 00:46:33,710
here delegate responsibility and write

00:46:29,549 --> 00:46:36,329
as small services as possible and have a

00:46:33,710 --> 00:46:38,369
central controller delegate the

00:46:36,329 --> 00:46:40,589
responsibility to them in our case the

00:46:38,369 --> 00:46:42,990
search for hotels and vehicles and other

00:46:40,589 --> 00:46:45,359
things each of them had the very

00:46:42,990 --> 00:46:48,150
specific purpose that was only

00:46:45,359 --> 00:46:50,039
dispatched from a tiny piece of code

00:46:48,150 --> 00:46:51,960
saying okay I were going to fight all

00:46:50,039 --> 00:46:56,220
these things in parallel instead of

00:46:51,960 --> 00:46:58,579
doing everything in one place and of

00:46:56,220 --> 00:47:01,190
course executing things in parallel is

00:46:58,579 --> 00:47:08,960
something that really helped our

00:47:01,190 --> 00:47:08,960
application speed overall any questions

00:47:10,490 --> 00:47:13,490
yeah

00:47:14,890 --> 00:47:20,380
how did you handle scaling payments and

00:47:18,089 --> 00:47:21,760
did you like work directly with cloud

00:47:20,380 --> 00:47:23,650
providers to do that or is that

00:47:21,760 --> 00:47:26,829
something that you didn't deal with the

00:47:23,650 --> 00:47:29,470
more the Java level yeah fortunately the

00:47:26,829 --> 00:47:35,589
payments mmm we're done in the Java

00:47:29,470 --> 00:47:39,880
layer and during one cyber monday the

00:47:35,589 --> 00:47:41,950
actual payment provider crashed so after

00:47:39,880 --> 00:47:45,160
a couple of hours of people buying

00:47:41,950 --> 00:47:47,619
tickets like crazy and none of the

00:47:45,160 --> 00:47:53,460
application items died but the payment

00:47:47,619 --> 00:48:02,410
provided it so mmm it really depends on

00:47:53,460 --> 00:48:09,369
how much traffic they can handle no now

00:48:02,410 --> 00:48:13,240
it's an exclusive contract did that

00:48:09,369 --> 00:48:16,049
answer your question okay thank you any

00:48:13,240 --> 00:48:16,049
other questions

00:48:17,250 --> 00:48:22,140
so you sent the request off to the

00:48:20,190 --> 00:48:25,080
symphony services using multi-car the

00:48:22,140 --> 00:48:26,640
item is told that you're essentially

00:48:25,080 --> 00:48:29,210
making a promise that our items going to

00:48:26,640 --> 00:48:32,070
come back into memcache how do you

00:48:29,210 --> 00:48:35,010
instruct that the item is in memcache

00:48:32,070 --> 00:48:36,510
you using the 204 trick there as well or

00:48:35,010 --> 00:48:37,830
you just returning for it for from

00:48:36,510 --> 00:48:42,750
memcache to say this item is not

00:48:37,830 --> 00:48:48,870
available your keep trying yeah so if I

00:48:42,750 --> 00:48:54,410
understand your question correctly is if

00:48:48,870 --> 00:48:54,410
we are returning for force in case of I

00:48:55,340 --> 00:49:00,210
think you have to ask the question again

00:48:57,360 --> 00:49:02,520
I'm sorry that's okay so you say you're

00:49:00,210 --> 00:49:03,420
going to get the seats back so you send

00:49:02,520 --> 00:49:05,580
the service to get the seats

00:49:03,420 --> 00:49:08,130
availability the front-end layers then

00:49:05,580 --> 00:49:11,640
got a 20 full response to say the back

00:49:08,130 --> 00:49:14,280
ends doing something please wait is that

00:49:11,640 --> 00:49:17,790
right to my understanding the polling

00:49:14,280 --> 00:49:19,800
mechanism for memcache um says something

00:49:17,790 --> 00:49:22,110
like okay go 10 times to mem cache and

00:49:19,800 --> 00:49:24,030
try to fetch the seats but if you fail

00:49:22,110 --> 00:49:26,760
to get them 10 times this is an

00:49:24,030 --> 00:49:31,380
unrecoverable error the booking cannot

00:49:26,760 --> 00:49:33,750
continue or in some other cases if the

00:49:31,380 --> 00:49:36,390
tickets for local shows don't show up

00:49:33,750 --> 00:49:38,790
that's a coverable error we don't

00:49:36,390 --> 00:49:42,960
necessarily want to sell those so it it

00:49:38,790 --> 00:49:46,790
really depends on the business logic but

00:49:42,960 --> 00:49:50,220
the Palio mechanism is set to retry

00:49:46,790 --> 00:49:52,800
every couple of seconds so you wait 10 2

00:49:50,220 --> 00:49:56,010
seconds you go to my BF say ok do we

00:49:52,800 --> 00:49:58,470
have the day tired no ok wait then two

00:49:56,010 --> 00:50:01,770
more seconds try again and at some point

00:49:58,470 --> 00:50:04,500
after I think we eventually set the

00:50:01,770 --> 00:50:08,160
number to 10 but it was obtained through

00:50:04,500 --> 00:50:10,530
trial and error it just gave up and said

00:50:08,160 --> 00:50:13,460
okay this is a real problem we can't

00:50:10,530 --> 00:50:13,460
continue with the booking

00:50:15,710 --> 00:50:20,400
you know what their upgrades to the

00:50:18,120 --> 00:50:23,550
system and when you replace once I love

00:50:20,400 --> 00:50:26,160
it another one how did you handle the

00:50:23,550 --> 00:50:28,260
database layer if there was if one side

00:50:26,160 --> 00:50:30,000
of that you upgraded introduce new

00:50:28,260 --> 00:50:32,910
functionality that wasn't that was

00:50:30,000 --> 00:50:39,300
changing the data layer how did you

00:50:32,910 --> 00:50:42,360
handle that what the actual Java

00:50:39,300 --> 00:50:44,010
services so if the new sila was

00:50:42,360 --> 00:50:46,590
introducing new functionality or new

00:50:44,010 --> 00:50:48,660
features that required new items in the

00:50:46,590 --> 00:50:50,820
database or new a new structure of the

00:50:48,660 --> 00:50:53,790
database but the other silos were still

00:50:50,820 --> 00:50:58,170
using the previous structure how did you

00:50:53,790 --> 00:51:01,140
have that problem or digit no actually

00:50:58,170 --> 00:51:04,380
it's not a problem because from the Java

00:51:01,140 --> 00:51:08,160
services you get the data that you need

00:51:04,380 --> 00:51:10,290
but the front end version knows what

00:51:08,160 --> 00:51:12,840
information comes from Java and what not

00:51:10,290 --> 00:51:17,940
and it updates itself according to that

00:51:12,840 --> 00:51:20,430
so the old version receives the same

00:51:17,940 --> 00:51:24,750
Jason from Java and the new version

00:51:20,430 --> 00:51:29,090
received receives any hostage Jason and

00:51:24,750 --> 00:51:33,750
processes that one is that ok thank you

00:51:29,090 --> 00:51:35,880
thank you quick question um you talked

00:51:33,750 --> 00:51:37,560
about the the Java Java layer all the

00:51:35,880 --> 00:51:39,150
way down that was in-house the you

00:51:37,560 --> 00:51:41,930
probably weren't the client developing

00:51:39,150 --> 00:51:45,030
that did you go so far as to right there

00:51:41,930 --> 00:51:46,670
was the word the license the interface

00:51:45,030 --> 00:51:48,840
piece and what you would expect

00:51:46,670 --> 00:51:51,480
transactionally from that each time and

00:51:48,840 --> 00:51:54,120
how did that work with that team yes so

00:51:51,480 --> 00:51:56,340
that's how we actually started working

00:51:54,120 --> 00:51:59,280
with fixtures because we need to develop

00:51:56,340 --> 00:52:01,380
a common language between of all these

00:51:59,280 --> 00:52:04,770
web facing components and the Java layer

00:52:01,380 --> 00:52:07,470
and this is where the first fixtures

00:52:04,770 --> 00:52:10,950
came from and then we discovered the

00:52:07,470 --> 00:52:13,200
actual power of the concept and used the

00:52:10,950 --> 00:52:17,330
same idea in the communication between

00:52:13,200 --> 00:52:17,330
the web facing components themselves

00:52:18,900 --> 00:52:27,839
more questions they're all smiling in

00:52:24,210 --> 00:52:31,380
there but no more question is there any

00:52:27,839 --> 00:52:33,839
reason why you do not use any queuing

00:52:31,380 --> 00:52:37,440
technology like RabbitMQ also what you

00:52:33,839 --> 00:52:42,900
do all the time consuming work inside a

00:52:37,440 --> 00:52:46,319
request cycle now yes actually there is

00:52:42,900 --> 00:52:49,529
a very strong reason I'm not sure you

00:52:46,319 --> 00:52:52,140
will like it but them as the messaging q

00:52:49,529 --> 00:52:53,819
creates a single point of failure you

00:52:52,140 --> 00:52:56,339
can't have a message queue that has a

00:52:53,819 --> 00:52:58,740
fallback so if there is a problem in the

00:52:56,339 --> 00:53:02,180
message in queue you lose all the

00:52:58,740 --> 00:53:05,339
messages or add in place in process and

00:53:02,180 --> 00:53:09,599
if you go back to older technologies

00:53:05,339 --> 00:53:13,500
like the ones we used you don't have

00:53:09,599 --> 00:53:18,000
that so it's better to use simple let's

00:53:13,500 --> 00:53:19,680
lamp stack concept that allow you to go

00:53:18,000 --> 00:53:22,349
and scale everything horizontally

00:53:19,680 --> 00:53:25,680
instead of creating one single point of

00:53:22,349 --> 00:53:29,220
failure that will eventually by two yes

00:53:25,680 --> 00:53:31,619
when you least expect it okay so you

00:53:29,220 --> 00:53:33,680
have thought about it thank you thank

00:53:31,619 --> 00:53:33,680
you

00:53:44,790 --> 00:53:51,300
hi it's a question about your silos am i

00:53:49,590 --> 00:53:54,390
understanding it right that you bundled

00:53:51,300 --> 00:53:57,540
your your Drupal your single page

00:53:54,390 --> 00:54:02,960
application and your symphony API all

00:53:57,540 --> 00:54:02,960
together in one silo is that correct

00:54:03,110 --> 00:54:08,160
yeah so am I correct in understanding

00:54:05,520 --> 00:54:11,270
that your silo contains your Drupal code

00:54:08,160 --> 00:54:15,930
your single page application and your

00:54:11,270 --> 00:54:19,260
symphony yes API I'm wondering why you

00:54:15,930 --> 00:54:21,450
bonded them all three together and why

00:54:19,260 --> 00:54:23,550
didn't you separate the api out into its

00:54:21,450 --> 00:54:27,240
own layer so you can load balance it so

00:54:23,550 --> 00:54:29,390
if you're getting lots of hits to your

00:54:27,240 --> 00:54:31,860
front end you can scale it up and

00:54:29,390 --> 00:54:33,630
because you got that load balancing and

00:54:31,860 --> 00:54:35,460
you'll have cash in there as well you

00:54:33,630 --> 00:54:36,810
wouldn't have to scale that up so I'm

00:54:35,460 --> 00:54:40,200
just wondering why you were bundled it

00:54:36,810 --> 00:54:42,450
all together it is hidden behind them

00:54:40,200 --> 00:54:43,890
that your proxy but they didn't add it

00:54:42,450 --> 00:54:47,790
to the diagram because it would have

00:54:43,890 --> 00:54:49,970
become more crowded if you look at the I

00:54:47,790 --> 00:54:52,530
have to Drupal and despair boxes and

00:54:49,970 --> 00:54:55,410
those are hidden behind the native proxy

00:54:52,530 --> 00:54:57,270
and then in this diagram i just showed

00:54:55,410 --> 00:55:00,090
three symphony boxes for the back end

00:54:57,270 --> 00:55:03,090
they also stay behind the native proxy

00:55:00,090 --> 00:55:05,490
but the actual numbers how many backend

00:55:03,090 --> 00:55:08,520
boxes you get in one silo were obtained

00:55:05,490 --> 00:55:12,450
using load testing and real measurements

00:55:08,520 --> 00:55:15,060
so the actual shape of a silo it wasn't

00:55:12,450 --> 00:55:16,740
predetermined that is why I think this

00:55:15,060 --> 00:55:19,860
kind of architecture is quite flexible

00:55:16,740 --> 00:55:23,280
because it allows you to change it even

00:55:19,860 --> 00:55:27,780
after everything is in production okay

00:55:23,280 --> 00:55:35,990
so it's a silo a collection of boxes yes

00:55:27,780 --> 00:55:35,990
okay good more questions

00:55:39,900 --> 00:55:45,869
oh if there are any further questions um

00:55:42,599 --> 00:55:49,319
I'll be around the whole so you can come

00:55:45,869 --> 00:55:50,730
and ask me even more things what's a

00:55:49,319 --> 00:55:52,940
smiling faces in heaven thank you very

00:55:50,730 --> 00:55:52,940

YouTube URL: https://www.youtube.com/watch?v=7L5qvCjgHko


