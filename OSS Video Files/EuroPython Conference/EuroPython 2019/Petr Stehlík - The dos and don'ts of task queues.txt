Title: Petr Stehlík - The dos and don'ts of task queues
Publication date: 2019-09-03
Playlist: EuroPython 2019
Description: 
	"The dos and don'ts of task queues
[EuroPython 2019 - Talk - 2019-07-10 - Shanghai]
[Basel, CH]

By Petr Stehlík

At Kiwi.com we heavily rely on task queues and asynchronous execution of code to process large amounts of requests coming to our back-ends. With the separation of our codebase to microservices, we can quickly try new tools and different approaches to process these large volumes of requests. The microservice we’ll be talking about is making unreliable slow 3rd party services reliable and asynchronous with a bit of business logic sprinkled on top of it. We’ll tell a failure story of ours but resulting in a valuable lesson.

Most of our services use Celery and it’s the go-to tool for new services as well but we wanted to be different with this new microservice. RQ is the next best choice for task queues and it is presented as simpler and more straightforward than Celery. That can definitely be true but after 3 weeks of research, development and struggling we found out the unpleasant truth about being simple and making the right choices. We won’t talk about comparing the frameworks but rather about the approach on how to experiment with new things in your environment. After that, we’ll present our current setup which can take upon any number of tasks*. How we orchestrate the app and continuously integrate and deploy and what fun things await ahead of us in the development.

*Conditions may apply.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/
Captions: 
	00:00:03,290 --> 00:00:09,299
so once again my name is feather Stalag

00:00:06,269 --> 00:00:11,130
and I work at tv.com and I'm

00:00:09,299 --> 00:00:13,830
specifically a Python developer at the

00:00:11,130 --> 00:00:16,980
finance tribe where we solve all the

00:00:13,830 --> 00:00:20,040
money problems in Kiwi so although all

00:00:16,980 --> 00:00:22,230
the money that goes through us the

00:00:20,040 --> 00:00:24,509
outline of my talk is quite short so

00:00:22,230 --> 00:00:26,880
first of all define and talk about what

00:00:24,509 --> 00:00:28,800
the task queue is then I will tell you a

00:00:26,880 --> 00:00:31,619
short story I will show you examples

00:00:28,800 --> 00:00:34,680
versus the reality then the final setup

00:00:31,619 --> 00:00:38,250
of how we do it and lessons learned and

00:00:34,680 --> 00:00:41,489
if we have time we will do some Q&A so

00:00:38,250 --> 00:00:43,589
task queues first let's define what a

00:00:41,489 --> 00:00:46,739
task queue is I was trying to find a

00:00:43,589 --> 00:00:50,070
simple sentence how to define it I felt

00:00:46,739 --> 00:00:51,989
miserably so task queue is a parallel

00:00:50,070 --> 00:00:56,159
execution of discrete tasks without

00:00:51,989 --> 00:00:58,199
blocking we are here with Python so most

00:00:56,159 --> 00:01:01,350
what comes to your mind is usually

00:00:58,199 --> 00:01:04,229
salary or our queue or something like

00:01:01,350 --> 00:01:06,900
this high-level but that's not usually

00:01:04,229 --> 00:01:09,180
just that's the tip of the iceberg

00:01:06,900 --> 00:01:11,480
actually because the task queues can be

00:01:09,180 --> 00:01:15,270
found in the hardware in CPUs GPUs

00:01:11,480 --> 00:01:20,760
everywhere this low so we can generalize

00:01:15,270 --> 00:01:23,160
it quite a lot to ask you or basically

00:01:20,760 --> 00:01:26,040
the major major part for a task queues

00:01:23,160 --> 00:01:28,590
are the queue itself the task that needs

00:01:26,040 --> 00:01:31,200
to be done the producer of the task and

00:01:28,590 --> 00:01:33,210
the consumer of the task you can imagine

00:01:31,200 --> 00:01:36,440
it like you're on the market and you're

00:01:33,210 --> 00:01:39,120
trying to buy a banana or another fruit

00:01:36,440 --> 00:01:41,100
so you have the queue you have the task

00:01:39,120 --> 00:01:43,890
to buy a banana you have the producer

00:01:41,100 --> 00:01:49,560
and the consumer as the as the customer

00:01:43,890 --> 00:01:51,450
and one who is selling the bananas so we

00:01:49,560 --> 00:01:53,850
got what we now know what is a task

00:01:51,450 --> 00:01:57,210
queue so what did it what is it for you

00:01:53,850 --> 00:01:59,010
know and the most usual use case is to

00:01:57,210 --> 00:02:02,670
decouple long running tasks from a

00:01:59,010 --> 00:02:04,680
synchronous call like your your job

00:02:02,670 --> 00:02:06,390
takes a couple of seconds but the coins

00:02:04,680 --> 00:02:08,759
don't have to wait for it on the API

00:02:06,390 --> 00:02:11,819
response so you would you know the

00:02:08,759 --> 00:02:14,189
result beforehand so you will just reply

00:02:11,819 --> 00:02:14,730
that you accepted the task and you're

00:02:14,189 --> 00:02:17,489
working

00:02:14,730 --> 00:02:19,980
it and then synchronously you can work

00:02:17,489 --> 00:02:24,569
on it and eventually you can for example

00:02:19,980 --> 00:02:26,700
call up a book to to mark it as done or

00:02:24,569 --> 00:02:31,170
some send an error to the external

00:02:26,700 --> 00:02:33,180
service for tasks in task use we can

00:02:31,170 --> 00:02:35,190
also do something politically like we

00:02:33,180 --> 00:02:38,010
don't have to rely on a low-level cron

00:02:35,190 --> 00:02:40,319
in Linux so we can do it in high level

00:02:38,010 --> 00:02:43,430
with more monitoring more control we can

00:02:40,319 --> 00:02:46,260
do it more granular granular and so on

00:02:43,430 --> 00:02:48,030
then actually in Kiwi we used it to

00:02:46,260 --> 00:02:50,190
break down software to more isolated

00:02:48,030 --> 00:02:53,540
pieces like to break down monolithic

00:02:50,190 --> 00:02:56,129
applications to micro services or if

00:02:53,540 --> 00:02:59,010
micro service is too big just you know

00:02:56,129 --> 00:03:02,849
break it down to a task and that Q and Q

00:02:59,010 --> 00:03:05,190
it and work on it that's it with the

00:03:02,849 --> 00:03:07,739
decoupling we can also minimize the wait

00:03:05,190 --> 00:03:09,989
time as I mentioned and the latency and

00:03:07,739 --> 00:03:12,450
response time all together so it all

00:03:09,989 --> 00:03:14,220
comes together and when you combine

00:03:12,450 --> 00:03:17,430
everything it will increase the

00:03:14,220 --> 00:03:20,310
throughput of your system so this is

00:03:17,430 --> 00:03:24,510
what a task who is good for now the

00:03:20,310 --> 00:03:26,819
story we have this a small let's call it

00:03:24,510 --> 00:03:29,730
micro service for handling accounting

00:03:26,819 --> 00:03:33,480
data mainly invoices and it's called

00:03:29,730 --> 00:03:35,190
fantasy if you if you have watched all

00:03:33,480 --> 00:03:38,940
the Italian movies you will know that

00:03:35,190 --> 00:03:42,989
fantasy is a series of films about an

00:03:38,940 --> 00:03:46,859
unfortunate accountant so that's where

00:03:42,989 --> 00:03:49,200
the name came from and imagine it like

00:03:46,859 --> 00:03:52,739
that we have a REST API in the front

00:03:49,200 --> 00:03:56,450
and then we have the handler and the

00:03:52,739 --> 00:03:59,519
tasks and the queues the initial design

00:03:56,450 --> 00:04:02,669
you know counted on quite a lot of Q's

00:03:59,519 --> 00:04:05,400
there was a web hook library we should

00:04:02,669 --> 00:04:07,620
have used JSON web tokens everything

00:04:05,400 --> 00:04:12,269
these fancy names and fancy technologies

00:04:07,620 --> 00:04:15,750
that you usually hear about on some

00:04:12,269 --> 00:04:19,019
tutorials well there were two of us

00:04:15,750 --> 00:04:23,039
developing it and we spent three weeks

00:04:19,019 --> 00:04:26,280
with with this with working on frontal

00:04:23,039 --> 00:04:28,960
on the fantasy 2.0 and we were deciding

00:04:26,280 --> 00:04:33,280
what tasks you framework we should you

00:04:28,960 --> 00:04:35,680
so sorry wrong slide and we were

00:04:33,280 --> 00:04:37,330
deciding like during the whole

00:04:35,680 --> 00:04:39,550
development and during the whole

00:04:37,330 --> 00:04:42,280
development quite the dangerous

00:04:39,550 --> 00:04:46,420
sentences were set the first one is new

00:04:42,280 --> 00:04:48,460
is always better so you know okay we got

00:04:46,420 --> 00:04:50,260
this old piece of software it was like

00:04:48,460 --> 00:04:51,520
curated two years ago so we need to

00:04:50,260 --> 00:04:53,980
rewrite it definitely because it

00:04:51,520 --> 00:04:56,290
definitely doesn't work we don't care to

00:04:53,980 --> 00:04:59,110
understand it so we will rewrite it and

00:04:56,290 --> 00:05:02,200
maybe in two years we can do it again

00:04:59,110 --> 00:05:05,320
because new is always better right think

00:05:02,200 --> 00:05:08,290
outside the box you know because you

00:05:05,320 --> 00:05:10,420
don't you just know better

00:05:08,290 --> 00:05:13,180
you know so you can you can imagine

00:05:10,420 --> 00:05:15,250
yourself like the pro the super duper

00:05:13,180 --> 00:05:18,400
programmer that knows everything and do

00:05:15,250 --> 00:05:21,280
everything better I know everything I

00:05:18,400 --> 00:05:23,920
need like why why would like Harry

00:05:21,280 --> 00:05:26,710
reading the documentation or you know

00:05:23,920 --> 00:05:28,300
some best practices or whatever or you

00:05:26,710 --> 00:05:32,260
know just how to set up the application

00:05:28,300 --> 00:05:34,050
itself and I said I can do it better

00:05:32,260 --> 00:05:37,390
that's one of the most dangerous ones

00:05:34,050 --> 00:05:39,280
because usually when you're using a

00:05:37,390 --> 00:05:41,410
framework it's done by a couple of

00:05:39,280 --> 00:05:44,080
really experienced guys and they know

00:05:41,410 --> 00:05:47,260
what they are doing sometimes it's not

00:05:44,080 --> 00:05:52,660
it's not true always but some general

00:05:47,260 --> 00:05:53,410
rule is yes and you don't have to always

00:05:52,660 --> 00:05:55,600
do better

00:05:53,410 --> 00:05:58,830
you know sometimes do a bit worse and it

00:05:55,600 --> 00:06:03,550
will turn out a bit better in the end

00:05:58,830 --> 00:06:06,880
and with that this sentence is set there

00:06:03,550 --> 00:06:10,300
was this small three week window of the

00:06:06,880 --> 00:06:12,340
two developers developing and then at

00:06:10,300 --> 00:06:17,470
the end of the three weeks suddenly

00:06:12,340 --> 00:06:19,600
realizing it doesn't work it's like it's

00:06:17,470 --> 00:06:22,690
a really bad application like it won't

00:06:19,600 --> 00:06:26,170
scale it won't it won't be maintainable

00:06:22,690 --> 00:06:27,700
and actually the setup would be harder

00:06:26,170 --> 00:06:31,080
then

00:06:27,700 --> 00:06:33,790
with the usual one that we have in Kiwi

00:06:31,080 --> 00:06:36,730
so we basically lost three weeks of

00:06:33,790 --> 00:06:40,060
development type time because we didn't

00:06:36,730 --> 00:06:44,350
decided okay we use thread is a reddish

00:06:40,060 --> 00:06:47,980
cues or simply our cue framework so

00:06:44,350 --> 00:06:52,630
implement it and then we changed it to

00:06:47,980 --> 00:06:56,170
salary changing to salary took us around

00:06:52,630 --> 00:07:00,160
16 hours compared to three weeks of

00:06:56,170 --> 00:07:02,950
development time and so we waste it

00:07:00,160 --> 00:07:05,800
effectively six weeks of Persons time

00:07:02,950 --> 00:07:09,520
and that's why I'm actually here to tell

00:07:05,800 --> 00:07:12,220
you why why it all happened and what

00:07:09,520 --> 00:07:14,280
would be the best practice for you so

00:07:12,220 --> 00:07:18,190
the first thing why it happened was

00:07:14,280 --> 00:07:20,830
examples versus reality because in both

00:07:18,190 --> 00:07:24,040
like RQ and salary you have these

00:07:20,830 --> 00:07:25,630
beautiful examples of a simple app just

00:07:24,040 --> 00:07:29,320
how to scaffold the app you know like

00:07:25,630 --> 00:07:31,330
five lines and that's it right like yeah

00:07:29,320 --> 00:07:34,630
that's easy let's do it you know because

00:07:31,330 --> 00:07:37,600
because red is ready or RQ its

00:07:34,630 --> 00:07:39,940
lightweight so lets you use RQ instead

00:07:37,600 --> 00:07:43,270
of the giant salary that handles

00:07:39,940 --> 00:07:46,090
everything for you you know but in

00:07:43,270 --> 00:07:49,840
reality we suddenly need repeater for

00:07:46,090 --> 00:07:51,610
the tasks in our queue but included so

00:07:49,840 --> 00:07:55,210
you have to write it yourself and then

00:07:51,610 --> 00:07:57,820
this kind of ugly mask was created to

00:07:55,210 --> 00:08:02,140
actually do a repetition without not

00:07:57,820 --> 00:08:04,570
much conflict configuration in it don't

00:08:02,140 --> 00:08:07,270
try to read it just that's just to scare

00:08:04,570 --> 00:08:09,850
you off you know but surprise surprise

00:08:07,270 --> 00:08:12,760
in salary it's included so you just need

00:08:09,850 --> 00:08:14,290
to put some things in the decorator five

00:08:12,760 --> 00:08:16,930
lines and you're done you don't have to

00:08:14,290 --> 00:08:18,580
you don't have to write fifty and you

00:08:16,930 --> 00:08:20,830
have it all parameterised it's all

00:08:18,580 --> 00:08:24,850
explained it's all documented and you

00:08:20,830 --> 00:08:26,320
you're sure it will work but also be

00:08:24,850 --> 00:08:29,440
careful because when we are implementing

00:08:26,320 --> 00:08:32,530
salary and we saw the five line example

00:08:29,440 --> 00:08:35,260
of how easily it is to integrate we

00:08:32,530 --> 00:08:37,990
ended up with over 250 changes in the

00:08:35,260 --> 00:08:41,020
whole repo which was at that time around

00:08:37,990 --> 00:08:42,940
lines so almost a quarter of the project

00:08:41,020 --> 00:08:46,029
was changed because we implemented

00:08:42,940 --> 00:08:49,750
salary so we are also mindful about this

00:08:46,029 --> 00:08:51,459
and suddenly we have a working

00:08:49,750 --> 00:08:53,110
application that's maintainable it's

00:08:51,459 --> 00:08:54,250
running on salary which we are using

00:08:53,110 --> 00:08:56,860
throughout the whole Kiwi

00:08:54,250 --> 00:08:59,500
so we can get help anytime anywhere from

00:08:56,860 --> 00:09:01,480
any one of our colleagues who are more

00:08:59,500 --> 00:09:02,860
experienced in some areas some more or

00:09:01,480 --> 00:09:05,709
less experienced in some of us so we can

00:09:02,860 --> 00:09:07,959
you know brainstorm together and if this

00:09:05,709 --> 00:09:10,720
we came in our finance drive we came to

00:09:07,959 --> 00:09:12,670
a final setup of how we actually do it

00:09:10,720 --> 00:09:16,690
how we scaffold our application how we

00:09:12,670 --> 00:09:19,720
develop them so first we are using of

00:09:16,690 --> 00:09:24,600
course patent and post-grad on top of it

00:09:19,720 --> 00:09:28,209
we have a flask or currently a AO HTTP

00:09:24,600 --> 00:09:30,940
together then we have a connection that

00:09:28,209 --> 00:09:33,279
takes care of the rest API of course we

00:09:30,940 --> 00:09:36,610
have celery for broker we are using

00:09:33,279 --> 00:09:38,170
readies on AWS so it's managed we are

00:09:36,610 --> 00:09:40,779
using multiple deploy targets in our

00:09:38,170 --> 00:09:43,450
continuous integration pipeline and we

00:09:40,779 --> 00:09:45,640
are using clocks i/o and data doc for

00:09:43,450 --> 00:09:47,560
monitoring and we are slowly shifting

00:09:45,640 --> 00:09:49,390
everything to the dock and when

00:09:47,560 --> 00:09:51,190
something goes bad and really bad we are

00:09:49,390 --> 00:09:58,170
using sentry and pager duty for

00:09:51,190 --> 00:10:01,089
notifying us so that's how we do it and

00:09:58,170 --> 00:10:04,450
that's how that's how the fantasy

00:10:01,089 --> 00:10:06,790
application was developed as well I will

00:10:04,450 --> 00:10:09,160
break down all the points here so you

00:10:06,790 --> 00:10:12,399
can know a bit better with Python we are

00:10:09,160 --> 00:10:16,029
always trying or always trying to shift

00:10:12,399 --> 00:10:18,310
to Python 3.6 and when we are starting a

00:10:16,029 --> 00:10:22,060
new project we are always doing it 3.6

00:10:18,310 --> 00:10:23,410
for newer usually 3.7 mode there also as

00:10:22,060 --> 00:10:25,089
I mentioned in the beginning we are

00:10:23,410 --> 00:10:27,310
trying to break everything down from

00:10:25,089 --> 00:10:30,459
monolithic architecture to microservice

00:10:27,310 --> 00:10:34,500
architecture and using the excuse and a

00:10:30,459 --> 00:10:38,529
synchronous processing with flask and a

00:10:34,500 --> 00:10:40,570
HTTP these are the go-to frameworks for

00:10:38,529 --> 00:10:43,120
us because we have boilerplate for the

00:10:40,570 --> 00:10:44,770
for them and we can scaffold them quite

00:10:43,120 --> 00:10:48,820
quickly thanks to cookie cutter

00:10:44,770 --> 00:10:49,930
templates on the right you can see the

00:10:48,820 --> 00:10:51,550
example in floss

00:10:49,930 --> 00:10:54,160
and how we scare how we basically

00:10:51,550 --> 00:10:57,220
instantiate the whole fantasy

00:10:54,160 --> 00:11:00,280
application with all the monitoring all

00:10:57,220 --> 00:11:04,090
the all the sentry exception caching and

00:11:00,280 --> 00:11:09,340
everything just a quick question who

00:11:04,090 --> 00:11:11,770
knows what an API open API 3 is okay not

00:11:09,340 --> 00:11:14,020
many so I will explain a bit with

00:11:11,770 --> 00:11:16,680
connection that's affray that's like an

00:11:14,020 --> 00:11:20,140
extension or a framework it's actually

00:11:16,680 --> 00:11:22,930
for flask and I wish TTP and a couple of

00:11:20,140 --> 00:11:24,790
others and it implements the open API

00:11:22,930 --> 00:11:28,180
freeze specification so basically when

00:11:24,790 --> 00:11:30,910
you specify a yellow schema of your of

00:11:28,180 --> 00:11:33,580
your API and it generates a

00:11:30,910 --> 00:11:37,140
documentation and validation for your

00:11:33,580 --> 00:11:40,690
API so you have a beautiful specular UI

00:11:37,140 --> 00:11:42,580
useful for other developers and you can

00:11:40,690 --> 00:11:47,550
actually test it there you have examples

00:11:42,580 --> 00:11:50,530
and it's generally useful so take a note

00:11:47,550 --> 00:11:53,590
connection or open API 3 it's way to go

00:11:50,530 --> 00:11:56,470
and just a side note open API 3 is the

00:11:53,590 --> 00:11:58,660
successor of swagger swagger

00:11:56,470 --> 00:12:02,380
specification it was just renamed so

00:11:58,660 --> 00:12:03,280
some lot of thing is if connection we

00:12:02,380 --> 00:12:04,990
are also using token-based

00:12:03,280 --> 00:12:09,040
authentication and when it's needed

00:12:04,990 --> 00:12:10,570
authorization so we don't do you know

00:12:09,040 --> 00:12:13,360
jason web tokens because they are too

00:12:10,570 --> 00:12:16,830
complicated you just need a secret as a

00:12:13,360 --> 00:12:20,350
bearer token and you're good to go

00:12:16,830 --> 00:12:23,260
sorry we follow the best practices which

00:12:20,350 --> 00:12:26,620
I will present shortly and if Redis on

00:12:23,260 --> 00:12:29,140
AWS we are using it because it's managed

00:12:26,620 --> 00:12:32,380
it's reliable and it's easy to deploy so

00:12:29,140 --> 00:12:34,930
we don't loose any any tasks when

00:12:32,380 --> 00:12:38,190
something happens and for example

00:12:34,930 --> 00:12:38,190
something goes wrong really wrong

00:12:38,820 --> 00:12:43,840
multiple deployed targets we are usually

00:12:41,200 --> 00:12:45,670
deploying HTTP API the REST API itself

00:12:43,840 --> 00:12:48,250
and together with that we are also

00:12:45,670 --> 00:12:51,010
deploying workers periodic workers and

00:12:48,250 --> 00:12:53,710
so on and so on and the beautiful guys

00:12:51,010 --> 00:12:55,840
from platform team created a really

00:12:53,710 --> 00:12:58,810
useful useful thing for us it's called

00:12:55,840 --> 00:13:00,440
crane and it's available on github on

00:12:58,810 --> 00:13:03,980
our Kiwi comm account

00:13:00,440 --> 00:13:08,720
and it will help you to easily deploy to

00:13:03,980 --> 00:13:11,589
Ranger why I get lop CI and it it can

00:13:08,720 --> 00:13:14,240
help you with a messaging channels or

00:13:11,589 --> 00:13:18,410
relevant people if if when you are

00:13:14,240 --> 00:13:20,480
releasing if locks are when data doc we

00:13:18,410 --> 00:13:22,670
are using it extensively lock everything

00:13:20,480 --> 00:13:26,810
like when it doesn't lock it doesn't

00:13:22,670 --> 00:13:29,300
happen and with that a doc and renew is

00:13:26,810 --> 00:13:31,430
development we are slowly moving there

00:13:29,300 --> 00:13:34,209
with all the locks because we can join

00:13:31,430 --> 00:13:36,920
the tracing and locks together so we can

00:13:34,209 --> 00:13:39,889
stitch everything with the APM they

00:13:36,920 --> 00:13:42,949
provide so that's that's a thing to

00:13:39,889 --> 00:13:44,810
consider as well sentry is when

00:13:42,949 --> 00:13:46,759
something goes wrong so an exception

00:13:44,810 --> 00:13:48,980
happens it's log the stack trace its

00:13:46,759 --> 00:13:51,079
loft and we can reproduce the problem

00:13:48,980 --> 00:13:53,480
itself and then something really goes

00:13:51,079 --> 00:13:55,730
wrong we are using pager duty to wake

00:13:53,480 --> 00:13:56,540
our developers 3:00 a.m. for nothing

00:13:55,730 --> 00:13:59,110
basically

00:13:56,540 --> 00:14:03,829
but hey you get money for it you know

00:13:59,110 --> 00:14:06,680
because you're on call right so lessons

00:14:03,829 --> 00:14:12,529
learned the why we are all here mainly

00:14:06,680 --> 00:14:16,699
you first thing use Redis or AMQP broker

00:14:12,529 --> 00:14:18,769
never a database for salary you may ask

00:14:16,699 --> 00:14:20,540
why because you know that you already

00:14:18,769 --> 00:14:24,160
have a database in your system so why

00:14:20,540 --> 00:14:24,160
not use it well it's very simple

00:14:32,500 --> 00:14:41,540
let me just wait for the Kiana yeah so

00:14:38,480 --> 00:14:44,390
never a database because imagine that

00:14:41,540 --> 00:14:48,170
you have like 20 50 workers in your

00:14:44,390 --> 00:14:50,600
setup and each of the workers needs to

00:14:48,170 --> 00:14:53,060
ask the database like hey are there any

00:14:50,600 --> 00:14:55,010
new tasks that I can take and the

00:14:53,060 --> 00:14:56,480
database usually replies know because

00:14:55,010 --> 00:14:59,000
you have 50 workers and then sometimes

00:14:56,480 --> 00:15:01,250
it replies yes so imagine that you have

00:14:59,000 --> 00:15:04,550
like 50 queries to the database a second

00:15:01,250 --> 00:15:06,800
just from the workers and suddenly your

00:15:04,550 --> 00:15:09,740
product goes white you go to production

00:15:06,800 --> 00:15:13,220
and it's used by millions of people and

00:15:09,740 --> 00:15:16,850
suddenly the base starts failing it

00:15:13,220 --> 00:15:21,710
starts to timeout it starts to you know

00:15:16,850 --> 00:15:24,260
underperform why because the brokers or

00:15:21,710 --> 00:15:28,040
because it's serving as a broker because

00:15:24,260 --> 00:15:30,050
it's a it's over how overwhelmed by the

00:15:28,040 --> 00:15:32,990
by the workers because it's always

00:15:30,050 --> 00:15:36,170
asking for new stuff so having a lot of

00:15:32,990 --> 00:15:37,150
sessions open and generally you're going

00:15:36,170 --> 00:15:41,240
to crash

00:15:37,150 --> 00:15:43,220
read this or AMQP broker are designed

00:15:41,240 --> 00:15:46,310
for this and they are independent system

00:15:43,220 --> 00:15:47,930
so if they crash it happens but you

00:15:46,310 --> 00:15:51,530
definitely backup sonorities right or

00:15:47,930 --> 00:15:56,380
replicas here is a small example how to

00:15:51,530 --> 00:15:59,240
set up a bro brokers for for AMQP and

00:15:56,380 --> 00:16:02,240
for salary sir

00:15:59,240 --> 00:16:04,880
so for readies for for Redis you need to

00:16:02,240 --> 00:16:07,010
install an extension for salary so it's

00:16:04,880 --> 00:16:08,690
and then you can easily use it just

00:16:07,010 --> 00:16:12,560
install Redis and you're good to go you

00:16:08,690 --> 00:16:17,210
know that's easy second thing to learn

00:16:12,560 --> 00:16:19,130
pass simple objects to the task when you

00:16:17,210 --> 00:16:21,860
have for example an overarm

00:16:19,130 --> 00:16:25,339
a model database model populated with

00:16:21,860 --> 00:16:27,620
data you updated it and use you commit

00:16:25,339 --> 00:16:30,020
it right and then you pass it to the to

00:16:27,620 --> 00:16:30,820
the task and you can work on it again so

00:16:30,020 --> 00:16:33,220
you don't have to do

00:16:30,820 --> 00:16:37,000
and then you commit it again in the task

00:16:33,220 --> 00:16:38,980
I see where this might go because the

00:16:37,000 --> 00:16:41,740
simple because the object is quite

00:16:38,980 --> 00:16:46,270
complicated and it can go stale quite

00:16:41,740 --> 00:16:48,910
quickly so when you when you when you

00:16:46,270 --> 00:16:52,480
put the object or to a synchronous

00:16:48,910 --> 00:16:54,520
processing it can go stale without you

00:16:52,480 --> 00:16:58,420
knowing and then you will create a

00:16:54,520 --> 00:17:01,180
conflict in the database and so on it's

00:16:58,420 --> 00:17:03,400
much better to pass just the primary key

00:17:01,180 --> 00:17:06,270
of the object and then cure it again and

00:17:03,400 --> 00:17:09,700
have fresh new data that you can rely on

00:17:06,270 --> 00:17:11,680
with that you will you will avoid these

00:17:09,700 --> 00:17:13,240
kind of problems which are really hard

00:17:11,680 --> 00:17:17,440
to debug because it's basically a race

00:17:13,240 --> 00:17:22,270
condition for doing thing do not write

00:17:17,440 --> 00:17:24,190
for tasks inside tasks with this I will

00:17:22,270 --> 00:17:27,160
talk a bit more about it and explain it

00:17:24,190 --> 00:17:28,990
later on but when you're waiting for

00:17:27,160 --> 00:17:31,480
tasks inside tasks you are creating an

00:17:28,990 --> 00:17:33,700
endless loop if you have repetitions if

00:17:31,480 --> 00:17:35,830
you don't have a retry limit and

00:17:33,700 --> 00:17:38,620
everything so we'll end up with a stuck

00:17:35,830 --> 00:17:40,510
task that is endlessly trying to do

00:17:38,620 --> 00:17:43,540
something and it's blocking everything

00:17:40,510 --> 00:17:48,430
basically so you can end up with quite

00:17:43,540 --> 00:17:50,280
quite a haywire in your system this

00:17:48,430 --> 00:17:53,050
comes together with the set retry limit

00:17:50,280 --> 00:17:55,120
it basically tells salary how many times

00:17:53,050 --> 00:17:57,520
you can retry the task and then just

00:17:55,120 --> 00:17:59,860
give up racing exception and just mark

00:17:57,520 --> 00:18:03,850
it as action and successful and handle

00:17:59,860 --> 00:18:06,220
it yourself it's really easy it's in the

00:18:03,850 --> 00:18:08,340
decorator itself just make three tries

00:18:06,220 --> 00:18:10,900
and you're good to go

00:18:08,340 --> 00:18:13,180
you out to retry for this is a really

00:18:10,900 --> 00:18:15,940
handy feature because you can specify an

00:18:13,180 --> 00:18:18,430
exception on which the task will be

00:18:15,940 --> 00:18:19,990
retried but again don't forget the max

00:18:18,430 --> 00:18:22,480
three tries otherwise you can end up

00:18:19,990 --> 00:18:25,270
with an endless loop of a single task

00:18:22,480 --> 00:18:26,370
which is which is occupying one of your

00:18:25,270 --> 00:18:28,840
workers

00:18:26,370 --> 00:18:32,260
so you just define the exception that

00:18:28,840 --> 00:18:35,560
you want to be repeated and again you're

00:18:32,260 --> 00:18:38,040
good to go we are slowly building the

00:18:35,560 --> 00:18:40,960
decorator you see so it's not multi-line

00:18:38,040 --> 00:18:41,870
use right right back off true and retry

00:18:40,960 --> 00:18:45,290
jitter

00:18:41,870 --> 00:18:48,920
the back off you are you are specifying

00:18:45,290 --> 00:18:50,660
that the retry will be and and and that

00:18:48,920 --> 00:18:54,290
wait time between the rate rise will

00:18:50,660 --> 00:18:57,620
increase linearly there's there's a

00:18:54,290 --> 00:18:59,900
beautiful there's a beautiful formula

00:18:57,620 --> 00:19:02,000
for that on Wikipedia but don't bother

00:18:59,900 --> 00:19:04,460
it will just prolong the periods of time

00:19:02,000 --> 00:19:07,850
for example when you have an API that

00:19:04,460 --> 00:19:09,860
you rely on and it has a 500 error you

00:19:07,850 --> 00:19:11,600
can wait one second first and then they

00:19:09,860 --> 00:19:13,880
tried again it's down it's still down

00:19:11,600 --> 00:19:14,240
then you wait four seconds it's still

00:19:13,880 --> 00:19:16,160
down

00:19:14,240 --> 00:19:18,410
nevermind is you know five second down

00:19:16,160 --> 00:19:20,090
time is a fine right but then you wait

00:19:18,410 --> 00:19:22,820
for another fifteen seconds or so and

00:19:20,090 --> 00:19:26,240
suddenly the server is up your task is

00:19:22,820 --> 00:19:28,700
done and you're happy to go again with

00:19:26,240 --> 00:19:31,430
the retractor this is very useful when

00:19:28,700 --> 00:19:34,100
you have lots of and lots of the same

00:19:31,430 --> 00:19:36,320
tasks happening at the same time because

00:19:34,100 --> 00:19:39,500
when the retry is happening the jitter

00:19:36,320 --> 00:19:41,810
will add a small amount of time or the

00:19:39,500 --> 00:19:44,180
or subtract that lost time from the back

00:19:41,810 --> 00:19:46,220
off so the repetition of the task

00:19:44,180 --> 00:19:48,620
doesn't happen at the exactly same time

00:19:46,220 --> 00:19:51,560
so you don't basically do those the

00:19:48,620 --> 00:19:56,480
other service for example and again

00:19:51,560 --> 00:19:59,060
retry quarks always set the limit set

00:19:56,480 --> 00:20:03,800
hard and soft time limits a soft time

00:19:59,060 --> 00:20:06,740
limit is basically telling you that you

00:20:03,800 --> 00:20:09,740
know you should end so and gracefully

00:20:06,740 --> 00:20:12,620
and the time limit itself is hard and it

00:20:09,740 --> 00:20:16,910
will mercy it will kill without mercy

00:20:12,620 --> 00:20:21,830
and then again exception and error

00:20:16,910 --> 00:20:24,320
handling will happen use bind for a bit

00:20:21,830 --> 00:20:29,600
of extra oomph in your task basically

00:20:24,320 --> 00:20:33,350
meaning that you will get a reference to

00:20:29,600 --> 00:20:37,280
the task itself so you can unlock more

00:20:33,350 --> 00:20:40,880
you can retry with the contextual info

00:20:37,280 --> 00:20:42,230
actually so if you you can you can for

00:20:40,880 --> 00:20:44,600
example this side if you have a network

00:20:42,230 --> 00:20:47,600
error you don't try five more times but

00:20:44,600 --> 00:20:50,930
if you have a an integrity or error or

00:20:47,600 --> 00:20:52,460
anything you just will give up or you

00:20:50,930 --> 00:20:54,720
will just log it and give up because

00:20:52,460 --> 00:20:58,290
it's the fault of the data are not the

00:20:54,720 --> 00:21:00,000
of the API itself so you can use for

00:20:58,290 --> 00:21:03,810
example logging as you can see here we

00:21:00,000 --> 00:21:06,630
look to standard out and we are using

00:21:03,810 --> 00:21:08,430
that haddock to get actually the the

00:21:06,630 --> 00:21:09,450
stats for for the task if it was

00:21:08,430 --> 00:21:14,670
successful or not

00:21:09,450 --> 00:21:18,330
in quite easy manner separate queues for

00:21:14,670 --> 00:21:20,940
demanding tasks imagine that you have a

00:21:18,330 --> 00:21:23,430
task that communicates with a very very

00:21:20,940 --> 00:21:25,890
slow API it takes like 10 seconds to

00:21:23,430 --> 00:21:29,010
actually get a response from it and then

00:21:25,890 --> 00:21:32,730
you have a task that usually uses the

00:21:29,010 --> 00:21:36,090
superfast API that is like milliseconds

00:21:32,730 --> 00:21:38,910
to do and you have a single and you have

00:21:36,090 --> 00:21:41,190
a single cube for that you can imagine

00:21:38,910 --> 00:21:43,080
that the long running tasks will starve

00:21:41,190 --> 00:21:46,110
out eventually because they will be

00:21:43,080 --> 00:21:48,180
always preferred for the shorter tasks

00:21:46,110 --> 00:21:51,090
that will happen often and they will

00:21:48,180 --> 00:21:54,030
come more often and eventually the long

00:21:51,090 --> 00:21:57,090
running tasks will will go stale

00:21:54,030 --> 00:21:59,880
eventually so it's always better to

00:21:57,090 --> 00:22:02,100
separate these kind of tasks to their

00:21:59,880 --> 00:22:04,380
own queues like for example here you

00:22:02,100 --> 00:22:06,960
have a fast and slow queue this is a

00:22:04,380 --> 00:22:09,270
like a generic example really it's

00:22:06,960 --> 00:22:13,710
better always to name it a bit more

00:22:09,270 --> 00:22:15,960
precisely and then we apply I think you

00:22:13,710 --> 00:22:18,450
just you just specify the queue and

00:22:15,960 --> 00:22:20,760
you're good to go it will help you

00:22:18,450 --> 00:22:23,280
tremendously and of course when you have

00:22:20,760 --> 00:22:26,370
multiple queues always don't forget to

00:22:23,280 --> 00:22:31,710
deploy multiple workers which handle

00:22:26,370 --> 00:22:34,200
only that specific queue prefer

00:22:31,710 --> 00:22:38,610
importance in atomicity and because I'm

00:22:34,200 --> 00:22:42,170
a lazy developer I remember the whole

00:22:38,610 --> 00:22:46,620
the full description or definition of

00:22:42,170 --> 00:22:49,440
idempotency atomicity so I asked good

00:22:46,620 --> 00:22:51,270
auntie Vicky pedia to help me here but

00:22:49,440 --> 00:22:54,540
it impotency basically means when you

00:22:51,270 --> 00:22:56,880
call one resource multiple times it will

00:22:54,540 --> 00:23:00,210
always produce the same result and

00:22:56,880 --> 00:23:03,330
atomicity means that when you call the

00:23:00,210 --> 00:23:05,010
task it will appear to the to the system

00:23:03,330 --> 00:23:08,240
as atomic meaning it will happen

00:23:05,010 --> 00:23:08,240
instantly and without

00:23:08,720 --> 00:23:15,510
to sum it up you shred this or I am Q P

00:23:13,080 --> 00:23:17,880
both simple objects to the task don't

00:23:15,510 --> 00:23:20,880
wait for tasks inside tasks set retry

00:23:17,880 --> 00:23:24,990
limit use auto retry use back Hof's use

00:23:20,880 --> 00:23:27,870
jitter use time limit use bind and use

00:23:24,990 --> 00:23:29,130
separate queues and always prefer it

00:23:27,870 --> 00:23:33,630
impotency and atomicity

00:23:29,130 --> 00:23:35,070
those are lessons learned and there are

00:23:33,630 --> 00:23:36,450
also things to consider with salary

00:23:35,070 --> 00:23:40,080
because it's a really really powerful

00:23:36,450 --> 00:23:42,690
framework so you should always take into

00:23:40,080 --> 00:23:45,059
into consideration what can go wrong

00:23:42,690 --> 00:23:47,190
there as well because we salary you're

00:23:45,059 --> 00:23:50,070
sharing the codebase between producer

00:23:47,190 --> 00:23:53,010
and consumer so you need to be real

00:23:50,070 --> 00:23:56,460
careful about circular imports the way

00:23:53,010 --> 00:23:59,250
of how the imports work and what will

00:23:56,460 --> 00:24:02,039
load when the worker is starting and

00:23:59,250 --> 00:24:04,049
what will what will load when the server

00:24:02,039 --> 00:24:07,169
is starting or the producer is starting

00:24:04,049 --> 00:24:10,159
you salary to its full potential

00:24:07,169 --> 00:24:15,270
read the salary docs they are huge but

00:24:10,159 --> 00:24:17,250
it's a nice evening rate like when you

00:24:15,270 --> 00:24:19,760
have nothing to do come on let's let's

00:24:17,250 --> 00:24:22,320
let's read our workers today you know

00:24:19,760 --> 00:24:23,850
you don't have to read it carefully and

00:24:22,320 --> 00:24:25,710
you know remember everything like every

00:24:23,850 --> 00:24:27,870
param that is there you know just

00:24:25,710 --> 00:24:29,880
remember that something like this is

00:24:27,870 --> 00:24:32,730
there and you can use it because

00:24:29,880 --> 00:24:38,480
eventually you can use it it might come

00:24:32,730 --> 00:24:42,419
in handy so be mindful read the docs and

00:24:38,480 --> 00:24:45,690
also always bearing in mind that you are

00:24:42,419 --> 00:24:47,400
using third-party api's and they don't

00:24:45,690 --> 00:24:50,490
have to scale as well as your

00:24:47,400 --> 00:24:52,770
application so be mindful because the

00:24:50,490 --> 00:24:56,809
developers of that third party API might

00:24:52,770 --> 00:24:56,809
not be happy when you shoot them down

00:24:57,140 --> 00:25:03,330
that's most of my talk done thanks for

00:25:00,780 --> 00:25:06,840
listening and I would like to invite you

00:25:03,330 --> 00:25:10,340
to our today's party after your Python

00:25:06,840 --> 00:25:14,130
where you can win flight vouchers and

00:25:10,340 --> 00:25:15,090
this is an invitation party so with it

00:25:14,130 --> 00:25:19,679
are boo

00:25:15,090 --> 00:25:20,490
and it's somewhere somewhere there on

00:25:19,679 --> 00:25:22,200
the left

00:25:20,490 --> 00:25:26,070
I was trying like to pinpoint the

00:25:22,200 --> 00:25:28,230
location and you can definitely talk to

00:25:26,070 --> 00:25:33,509
us I will be there after the lunch so we

00:25:28,230 --> 00:25:36,419
can do so we can talk together and find

00:25:33,509 --> 00:25:38,340
out about more about the party and also

00:25:36,419 --> 00:25:42,570
more info about the party is at the meet

00:25:38,340 --> 00:25:45,779
Kiwi dot-com so small a small thing

00:25:42,570 --> 00:25:47,519
there there's a small error I'm still a

00:25:45,779 --> 00:25:51,409
Python engineer I am NOT an engineering

00:25:47,519 --> 00:25:54,499
manager there so it's waiting for me

00:25:51,409 --> 00:25:54,499
thank you

00:25:57,410 --> 00:26:03,320
okay we have about three more minutes

00:26:01,700 --> 00:26:11,620
for questions so if there is any

00:26:03,320 --> 00:26:11,620
questions yes of course flour is allowed

00:26:12,060 --> 00:26:15,180
[Music]

00:26:18,100 --> 00:26:24,080
yes definitely it's nice thing to have

00:26:20,450 --> 00:26:26,900
but you need to know how to use it

00:26:24,080 --> 00:26:28,940
actually so yes for monitoring like for

00:26:26,900 --> 00:26:33,080
more granular monitoring I definitely

00:26:28,940 --> 00:26:35,810
recommend it but honestly I personally I

00:26:33,080 --> 00:26:37,700
prefer my own monitoring like in the

00:26:35,810 --> 00:26:49,460
data dock where I can get alerts and

00:26:37,700 --> 00:26:52,000
everything for for what exactly if you

00:26:49,460 --> 00:26:54,320
if you design as well you don't need it

00:26:52,000 --> 00:26:58,160
but we can talk about it later

00:26:54,320 --> 00:27:01,400
okay there was one more right thanks for

00:26:58,160 --> 00:27:04,460
the talk you said that you migrating to

00:27:01,400 --> 00:27:06,680
a HTTP so what's your experience when

00:27:04,460 --> 00:27:08,720
you are using iOS gtp and salary and

00:27:06,680 --> 00:27:12,950
have you investigated

00:27:08,720 --> 00:27:16,850
I think enable take a system like a are

00:27:12,950 --> 00:27:19,370
cures some other things with a HTTP we

00:27:16,850 --> 00:27:20,900
are still alike in quite early stage so

00:27:19,370 --> 00:27:23,480
we don't have like a long term

00:27:20,900 --> 00:27:27,830
experience with it but basically if you

00:27:23,480 --> 00:27:30,920
understand the icing piratical it's kind

00:27:27,830 --> 00:27:33,530
of ok I said we don't have we didn't

00:27:30,920 --> 00:27:35,510
have a big problems with it yet ok so

00:27:33,530 --> 00:27:37,970
you know lesson to learn that no

00:27:35,510 --> 00:27:43,540
expensive things to learn

00:27:37,970 --> 00:27:49,930
I think I would like to know how you do

00:27:43,540 --> 00:27:51,970
your health checks on the salary workers

00:27:49,930 --> 00:27:54,250
I mean health checks yeah do you do

00:27:51,970 --> 00:27:57,550
health checks and we have quite a few

00:27:54,250 --> 00:28:01,810
and we recently put up but the house

00:27:57,550 --> 00:28:03,790
checks are taking a lot of processing so

00:28:01,810 --> 00:28:05,680
we were wondering if you are doing it

00:28:03,790 --> 00:28:09,400
right I would like to know how you do it

00:28:05,680 --> 00:28:11,920
we don't do have to have checks we do

00:28:09,400 --> 00:28:17,020
logging and through the logs we can see

00:28:11,920 --> 00:28:19,330
what is happening and with that we are

00:28:17,020 --> 00:28:21,070
usually deploying quite often so if

00:28:19,330 --> 00:28:23,110
you're for example asking about the

00:28:21,070 --> 00:28:25,390
memory consumption and the memory leaks

00:28:23,110 --> 00:28:27,670
we don't we don't care about them

00:28:25,390 --> 00:28:31,540
because we are restarting regularly the

00:28:27,670 --> 00:28:35,080
workers and we have the like Rancher

00:28:31,540 --> 00:28:37,300
itself or any container management can

00:28:35,080 --> 00:28:41,080
be set up to restart regular air to

00:28:37,300 --> 00:28:43,660
return to a healthy state so there are

00:28:41,080 --> 00:28:46,660
health checks but mostly for the whole

00:28:43,660 --> 00:28:48,580
API or for the whole application to see

00:28:46,660 --> 00:28:50,350
whether the database is stable or the

00:28:48,580 --> 00:28:52,450
connection to database is stable if

00:28:50,350 --> 00:28:55,000
everything is communicating properly or

00:28:52,450 --> 00:28:57,610
anything like that but we can talk about

00:28:55,000 --> 00:29:01,420
it later on

00:28:57,610 --> 00:29:01,420

YouTube URL: https://www.youtube.com/watch?v=gV01ZPxWuZg


