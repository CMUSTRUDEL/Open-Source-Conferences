Title: Alisa Dammer - Python vs Rust for Simulation
Publication date: 2019-09-03
Playlist: EuroPython 2019
Description: 
	"Python vs Rust for Simulation
[EuroPython 2019 - Talk - 2019-07-10 - PyCharm]
[Basel, CH]

By Alisa Dammer

Both Python and Rust are getting more and more popularity. Although it is unfair to compare them directly, this talk aims to provide a clear comparison with a pre-defined criteria applied to a specific use-case. 
Writing a simulation engine is very similar to writing a game engine and requires certain features from a language or framework.
Possible comparison criteria: 
1. Performance
2. Simplicity
3. Amount of code necessary for a MVP
4. Utilities: docs, tests, profile
5. Compatibility

Tl;dr
Do I want to go back to Python after Rust? Maybe+)



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/
Captions: 
	00:00:03,320 --> 00:00:10,070
hello everybody since recently actually

00:00:07,310 --> 00:00:12,830
machine learning engineer at free now or

00:00:10,070 --> 00:00:15,290
former my taxi and I do a lot of

00:00:12,830 --> 00:00:16,849
back-end development and putting models

00:00:15,290 --> 00:00:19,340
from our data scientists onto production

00:00:16,849 --> 00:00:22,759
but not only just putting into web

00:00:19,340 --> 00:00:24,680
service or into some bad jobs but trying

00:00:22,759 --> 00:00:28,130
to optimize them so that we have certain

00:00:24,680 --> 00:00:31,340
threshold on the our performance this is

00:00:28,130 --> 00:00:33,110
also why I stumbled across rust and as

00:00:31,340 --> 00:00:35,360
previous speaker here told you about

00:00:33,110 --> 00:00:38,150
BIOS tree I also tried it out and it was

00:00:35,360 --> 00:00:42,530
very promising but right now I'm working

00:00:38,150 --> 00:00:46,730
on simulation for our business purposes

00:00:42,530 --> 00:00:49,850
and the question of what should be

00:00:46,730 --> 00:00:52,430
executed how fast how expensive in terms

00:00:49,850 --> 00:00:56,900
of scalability or maybe development time

00:00:52,430 --> 00:00:58,400
all different points they are kind of

00:00:56,900 --> 00:01:00,350
important right now this is why I

00:00:58,400 --> 00:01:08,210
decided to present this topic as well

00:01:00,350 --> 00:01:10,190
here so what is a simulation in a very

00:01:08,210 --> 00:01:13,040
simple manner simulation is an

00:01:10,190 --> 00:01:16,550
abstraction of some event so you can

00:01:13,040 --> 00:01:23,060
think a state machine is technically a

00:01:16,550 --> 00:01:26,360
simulation an example would be for

00:01:23,060 --> 00:01:29,390
instance how the water flows through the

00:01:26,360 --> 00:01:31,580
pipes in a system or how the blood goes

00:01:29,390 --> 00:01:33,260
through our veins and then for instance

00:01:31,580 --> 00:01:36,440
you have another reason how the blood

00:01:33,260 --> 00:01:38,750
flow behaves there so all of this can be

00:01:36,440 --> 00:01:43,030
created in a simulation so it's just a

00:01:38,750 --> 00:01:45,380
program that recreates some real event

00:01:43,030 --> 00:01:46,909
the there are different types of

00:01:45,380 --> 00:01:49,720
simulation normally you will see

00:01:46,909 --> 00:01:53,299
continuous simulations which are

00:01:49,720 --> 00:01:55,850
implementation of mathematic models for

00:01:53,299 --> 00:02:00,290
instance that are continuous they define

00:01:55,850 --> 00:02:02,750
the whole flow of the logic a very

00:02:00,290 --> 00:02:06,590
well-known example would be a game of

00:02:02,750 --> 00:02:08,269
life or for instance in chemistry how

00:02:06,590 --> 00:02:10,399
different chemicals react with each

00:02:08,269 --> 00:02:12,109
other and fine sense whether you're

00:02:10,399 --> 00:02:13,879
going to get an explosion or not this

00:02:12,109 --> 00:02:14,750
can be also played in a continuous way

00:02:13,879 --> 00:02:17,780
in the same

00:02:14,750 --> 00:02:21,590
nation a second type is discrete event

00:02:17,780 --> 00:02:25,580
simulation which is that it covers most

00:02:21,590 --> 00:02:28,820
of man-made systems for instance post

00:02:25,580 --> 00:02:30,980
office so event occurs and something

00:02:28,820 --> 00:02:34,220
happens only when somebody's in the post

00:02:30,980 --> 00:02:37,459
office I as a customer or manufacturing

00:02:34,220 --> 00:02:39,440
pipeline logistics systems and stuff

00:02:37,459 --> 00:02:42,410
like that can be used in a discrete

00:02:39,440 --> 00:02:44,120
event simulation but right now there are

00:02:42,410 --> 00:02:45,950
a lot of papers and most of the

00:02:44,120 --> 00:02:49,030
production ready simulation frameworks

00:02:45,950 --> 00:02:52,910
are mixed where you can define certain

00:02:49,030 --> 00:02:54,380
event dispatching system that says ok do

00:02:52,910 --> 00:02:56,000
three sources are dispatched and then

00:02:54,380 --> 00:02:58,430
the system decides how to proceed

00:02:56,000 --> 00:02:59,900
further or if there any other side

00:02:58,430 --> 00:03:02,870
effects that can be described in a

00:02:59,900 --> 00:03:05,060
continuous way for instance forestry is

00:03:02,870 --> 00:03:08,810
a good example because you have a

00:03:05,060 --> 00:03:10,610
natural way of forest to grow or recover

00:03:08,810 --> 00:03:13,870
from a fire for instance but again you

00:03:10,610 --> 00:03:18,650
can dispatch discrete events like men

00:03:13,870 --> 00:03:21,830
planted forests or men created fire so

00:03:18,650 --> 00:03:27,670
it's a mixture pose and obviously it

00:03:21,830 --> 00:03:30,410
requires more development time involved

00:03:27,670 --> 00:03:32,989
there are numerous tools in all

00:03:30,410 --> 00:03:35,330
languages you can imagine find since

00:03:32,989 --> 00:03:37,580
frameworks libraries game engine

00:03:35,330 --> 00:03:40,100
simulation technically can be seen as a

00:03:37,580 --> 00:03:43,549
game engine without manual or human

00:03:40,100 --> 00:03:44,840
input and of course people build it from

00:03:43,549 --> 00:03:48,320
scratch with different programming

00:03:44,840 --> 00:03:50,030
languages there are just some examples

00:03:48,320 --> 00:03:52,730
that you can use for instance you can

00:03:50,030 --> 00:03:55,190
use unity to simulate how people will

00:03:52,730 --> 00:03:59,660
learn by providing some model that will

00:03:55,190 --> 00:04:01,880
replace the human input for instance the

00:03:59,660 --> 00:04:04,280
model will learn how to drive a car in

00:04:01,880 --> 00:04:08,540
Mario Kart or stuff like that that can

00:04:04,280 --> 00:04:11,180
be considered a simulation but in my

00:04:08,540 --> 00:04:14,239
case like there are different things you

00:04:11,180 --> 00:04:15,739
need to consider when choosing whether

00:04:14,239 --> 00:04:17,690
you want to go with a framework or a

00:04:15,739 --> 00:04:18,979
library or how you want to use the

00:04:17,690 --> 00:04:19,850
simulation whether you need the

00:04:18,979 --> 00:04:22,610
simulation in

00:04:19,850 --> 00:04:25,400
your business so four main things are

00:04:22,610 --> 00:04:27,680
cost if you go with closed-source thing

00:04:25,400 --> 00:04:31,010
it might cost you a lot or it might

00:04:27,680 --> 00:04:34,340
result in a lot of development hours

00:04:31,010 --> 00:04:37,430
that also directly is translated into

00:04:34,340 --> 00:04:38,900
cost than speed of the simulation you

00:04:37,430 --> 00:04:40,880
probably don't want to simulate

00:04:38,900 --> 00:04:43,250
something with real-time or near

00:04:40,880 --> 00:04:46,580
real-time speed right like why then

00:04:43,250 --> 00:04:48,740
bother the second the third point is Cal

00:04:46,580 --> 00:04:50,060
ability for instance you want to run

00:04:48,740 --> 00:04:52,370
different scenarios

00:04:50,060 --> 00:04:54,140
you cannot just wait for one to finish

00:04:52,370 --> 00:04:56,960
and then start another one so you want

00:04:54,140 --> 00:04:58,610
to for instance horizontally scale it so

00:04:56,960 --> 00:05:00,230
you want to put it into a service you

00:04:58,610 --> 00:05:02,030
want to put it into clout you want to

00:05:00,230 --> 00:05:04,190
provide some resources you need to know

00:05:02,030 --> 00:05:05,870
how the framework that you've chosen or

00:05:04,190 --> 00:05:09,220
your written behaves in this way as well

00:05:05,870 --> 00:05:13,430
the force and one of the most important

00:05:09,220 --> 00:05:15,440
points is extensibility if you are using

00:05:13,430 --> 00:05:18,640
something that is already there like a

00:05:15,440 --> 00:05:21,530
backbone library or even a ready

00:05:18,640 --> 00:05:24,680
framework you might run into situation

00:05:21,530 --> 00:05:27,320
where you have a very important business

00:05:24,680 --> 00:05:29,450
use case which is not covered but by

00:05:27,320 --> 00:05:32,180
this framework so you either have to pay

00:05:29,450 --> 00:05:34,460
the company to extend the framework or

00:05:32,180 --> 00:05:37,780
you have to do it yourself and again it

00:05:34,460 --> 00:05:40,220
translates almost directly into a cost

00:05:37,780 --> 00:05:42,260
so whenever you decide to do something

00:05:40,220 --> 00:05:45,200
you need to keep an eye those for and

00:05:42,260 --> 00:05:47,780
for this presentation I decided to go

00:05:45,200 --> 00:05:50,530
with very similar situation that I have

00:05:47,780 --> 00:05:53,450
on my work which is we're gonna simulate

00:05:50,530 --> 00:05:56,180
dispatch of taxi to a request or a

00:05:53,450 --> 00:05:59,150
customer so we're gonna have a world

00:05:56,180 --> 00:06:02,240
that has that can spawns with a certain

00:05:59,150 --> 00:06:05,450
chance of P a request we can have only

00:06:02,240 --> 00:06:08,060
max and requests which can be described

00:06:05,450 --> 00:06:11,060
as you can only have thousand passengers

00:06:08,060 --> 00:06:13,010
in using your app and one passenger one

00:06:11,060 --> 00:06:16,190
request at a time it's not possible for

00:06:13,010 --> 00:06:19,670
a passenger to request a taxi to a point

00:06:16,190 --> 00:06:21,230
and B point because how would you do it

00:06:19,670 --> 00:06:23,770
because you have only one physical body

00:06:21,230 --> 00:06:25,040
what would you do would you split I

00:06:23,770 --> 00:06:27,620
don't know

00:06:25,040 --> 00:06:31,410
then requests can be assigned to a free

00:06:27,620 --> 00:06:34,810
car only we don't have something like

00:06:31,410 --> 00:06:38,680
shuttle buses it's just pure car one

00:06:34,810 --> 00:06:40,090
request one car request can be cancelled

00:06:38,680 --> 00:06:42,760
after certain amount of time it they

00:06:40,090 --> 00:06:44,950
then don't get assigned which again is

00:06:42,760 --> 00:06:47,020
the real situation from taxi business

00:06:44,950 --> 00:06:50,110
passengers are not waiting longer than

00:06:47,020 --> 00:06:54,550
let's say 15 minutes they will just get

00:06:50,110 --> 00:06:57,430
a bus or a different taxi driver cars

00:06:54,550 --> 00:07:00,610
can be either free or occupied we do not

00:06:57,430 --> 00:07:02,800
have any other use cases and we will

00:07:00,610 --> 00:07:08,260
simulate one day which means we will

00:07:02,800 --> 00:07:10,870
simulate 24 x 60 60 tix so one second is

00:07:08,260 --> 00:07:14,760
our atomic unit of time that will be

00:07:10,870 --> 00:07:14,760
drive driving the whole simulation

00:07:14,910 --> 00:07:20,140
criteria so the talk is called peyten

00:07:18,010 --> 00:07:22,240
versus rest so we have to somehow

00:07:20,140 --> 00:07:24,430
compare them objectively or semi

00:07:22,240 --> 00:07:27,040
objectively and these are criterias I

00:07:24,430 --> 00:07:29,260
came up with the objective criteria is

00:07:27,040 --> 00:07:32,140
our amount of code you need to at least

00:07:29,260 --> 00:07:34,480
prototype your floo than testing

00:07:32,140 --> 00:07:36,670
simplicity how many packages they are

00:07:34,480 --> 00:07:39,880
for testing is it simple to write a test

00:07:36,670 --> 00:07:42,250
is it just how much time you would spend

00:07:39,880 --> 00:07:44,980
on it documentation generation and

00:07:42,250 --> 00:07:46,000
documentation available because probably

00:07:44,980 --> 00:07:47,880
you're not going to write everything

00:07:46,000 --> 00:07:50,560
yourself you might need some additional

00:07:47,880 --> 00:07:53,290
libraries and crates performance

00:07:50,560 --> 00:07:56,230
obviously is important memory usage is

00:07:53,290 --> 00:08:00,190
also important because of cost and

00:07:56,230 --> 00:08:02,800
scalability points and ecosystem will

00:08:00,190 --> 00:08:04,690
play later a big role once you have your

00:08:02,800 --> 00:08:07,360
prototype in place for instance if you

00:08:04,690 --> 00:08:09,970
have already existing business system

00:08:07,360 --> 00:08:12,280
that has for instance Hadoop and Co you

00:08:09,970 --> 00:08:15,640
might run into problems where your

00:08:12,280 --> 00:08:19,060
simulation has no official adapters or

00:08:15,640 --> 00:08:21,610
connectors to hive or Hadoop itself or

00:08:19,060 --> 00:08:23,650
like there just know Christ and you have

00:08:21,610 --> 00:08:25,570
to either write it yourself or rewrite

00:08:23,650 --> 00:08:28,630
it again in the language that has the

00:08:25,570 --> 00:08:30,340
libraries and language versions the

00:08:28,630 --> 00:08:34,180
previous speaker mentioned it already

00:08:30,340 --> 00:08:35,740
but it sometimes play crucial roles on

00:08:34,180 --> 00:08:38,560
time and doesn't so you also have to

00:08:35,740 --> 00:08:41,020
evaluate this risk the subjective two

00:08:38,560 --> 00:08:43,870
points are called simplicity all

00:08:41,020 --> 00:08:45,910
visually is if I have more experience in

00:08:43,870 --> 00:08:47,560
we'll say ah it's easy I don't

00:08:45,910 --> 00:08:49,450
understand fine at all I will spend one

00:08:47,560 --> 00:08:52,420
hour in rust and one day in Titan and

00:08:49,450 --> 00:08:55,529
vice versa and the second one is

00:08:52,420 --> 00:08:58,180
development speed they are connected but

00:08:55,529 --> 00:09:00,670
development speed is piden is

00:08:58,180 --> 00:09:03,430
notoriously known for allowing people to

00:09:00,670 --> 00:09:05,110
fast prototype with other languages

00:09:03,430 --> 00:09:08,860
especially aesthetically type languages

00:09:05,110 --> 00:09:10,510
you have to think first what structures

00:09:08,860 --> 00:09:13,330
you want to use how you want to present

00:09:10,510 --> 00:09:15,550
your program how is the flow not of the

00:09:13,330 --> 00:09:17,589
logic but the whole flow of the program

00:09:15,550 --> 00:09:20,260
where objects are going memory

00:09:17,589 --> 00:09:23,170
collection all that so you have to put

00:09:20,260 --> 00:09:28,330
some time in advance saying all that

00:09:23,170 --> 00:09:31,900
let's go to our presentation so I will

00:09:28,330 --> 00:09:35,350
show you a couple of codes we will start

00:09:31,900 --> 00:09:40,170
with piden first so the implementations

00:09:35,350 --> 00:09:43,180
are identical with a slight change or

00:09:40,170 --> 00:09:46,410
unique things that only rust has or only

00:09:43,180 --> 00:09:50,140
piden has otherwise you have the same

00:09:46,410 --> 00:09:54,040
struct or class which is request request

00:09:50,140 --> 00:09:56,620
has person you UID which is its unique

00:09:54,040 --> 00:09:58,600
ID driver ID that can be assigned it's

00:09:56,620 --> 00:10:01,600
technically an option so there is non

00:09:58,600 --> 00:10:04,420
driver or there is a driver remaining

00:10:01,600 --> 00:10:08,260
lifetime and fulfillment time these are

00:10:04,420 --> 00:10:10,720
parameters that will make our request

00:10:08,260 --> 00:10:12,970
either be canceled or being fulfilled

00:10:10,720 --> 00:10:15,730
and either life is a utility function

00:10:12,970 --> 00:10:20,650
that will tell us that yes still kicking

00:10:15,730 --> 00:10:23,680
still working another is a taxi which

00:10:20,650 --> 00:10:25,540
has ID so that we can see in the logs

00:10:23,680 --> 00:10:27,550
what request was assigned to what taxi

00:10:25,540 --> 00:10:30,700
if we have slightly more complicated

00:10:27,550 --> 00:10:34,120
logic of assignment other than random to

00:10:30,700 --> 00:10:37,150
random and then we have our world world

00:10:34,120 --> 00:10:39,010
is just a container that binds it all

00:10:37,150 --> 00:10:43,150
together so it has this main loop that

00:10:39,010 --> 00:10:45,150
says until I have time or in this day of

00:10:43,150 --> 00:10:48,930
simulation do this and

00:10:45,150 --> 00:10:51,860
do this will happen spawn creation if we

00:10:48,930 --> 00:10:57,450
can assignment if there are free cars

00:10:51,860 --> 00:10:59,450
update so this ticking for instance all

00:10:57,450 --> 00:11:01,890
the requests that are pending will start

00:10:59,450 --> 00:11:03,600
decaying and all requests are in

00:11:01,890 --> 00:11:06,570
progress will start being fulfilled and

00:11:03,600 --> 00:11:07,680
the cleanup that will say this one is

00:11:06,570 --> 00:11:10,110
already done

00:11:07,680 --> 00:11:12,510
free the taxi allow it to be used in the

00:11:10,110 --> 00:11:15,330
next cycle in the assignment and put

00:11:12,510 --> 00:11:17,690
this progress request in to cancelled

00:11:15,330 --> 00:11:22,170
all finished

00:11:17,690 --> 00:11:25,140
so you can see all of this in the

00:11:22,170 --> 00:11:26,820
attributes and functions so the world

00:11:25,140 --> 00:11:29,670
will have run time this is amount of

00:11:26,820 --> 00:11:33,570
seconds it will run for age is current

00:11:29,670 --> 00:11:36,810
step request pond chance is again this

00:11:33,570 --> 00:11:39,360
random chance to spawn a request max

00:11:36,810 --> 00:11:41,250
active request is the limiter of how

00:11:39,360 --> 00:11:44,310
many active requests we can have at once

00:11:41,250 --> 00:11:48,690
active mean balls in progress plus

00:11:44,310 --> 00:11:50,430
spending and taxes taxes as I said

00:11:48,690 --> 00:11:53,250
before can be free and occupied and

00:11:50,430 --> 00:11:55,470
requests are spread into four groups

00:11:53,250 --> 00:11:59,370
pending progress finished and canceled

00:11:55,470 --> 00:12:02,370
by the state and execution then we have

00:11:59,370 --> 00:12:05,339
maybe spawn request which is obvious if

00:12:02,370 --> 00:12:07,890
we can span spawner request that's not

00:12:05,339 --> 00:12:12,270
we have not reach our max we will do it

00:12:07,890 --> 00:12:15,209
with random channel chance then we have

00:12:12,270 --> 00:12:18,000
distribute if there is a taxi in three

00:12:15,209 --> 00:12:20,790
taxis we will try to attempt or we will

00:12:18,000 --> 00:12:22,620
assign this car to a first known

00:12:20,790 --> 00:12:26,790
assigned request so there is no special

00:12:22,620 --> 00:12:30,150
logic yet the update request is exactly

00:12:26,790 --> 00:12:32,459
that tick down either remaining waiting

00:12:30,150 --> 00:12:35,760
time or fulfillment time the cleanup is

00:12:32,459 --> 00:12:40,580
just put into next state if I have to

00:12:35,760 --> 00:12:44,040
and the main loop is while we have time

00:12:40,580 --> 00:12:45,510
do all the steps one up to another I'm

00:12:44,040 --> 00:12:49,320
not going to run this program for the

00:12:45,510 --> 00:12:52,230
whole day because it's actually slow so

00:12:49,320 --> 00:12:56,720
I will be going back to the presentation

00:12:52,230 --> 00:13:01,980
slide sorry before fine

00:12:56,720 --> 00:13:04,769
so all of our criterias will translate

00:13:01,980 --> 00:13:07,230
into quiet small amount of code to

00:13:04,769 --> 00:13:10,680
prototype our flow it's actually 94

00:13:07,230 --> 00:13:14,940
without documentation our performance is

00:13:10,680 --> 00:13:19,410
for one day without printing into a

00:13:14,940 --> 00:13:22,440
console is 210 seconds I did it with

00:13:19,410 --> 00:13:25,560
hyperfine which gives it like several

00:13:22,440 --> 00:13:27,449
runs and uses average so it's believable

00:13:25,560 --> 00:13:29,430
number it's not like I run it once with

00:13:27,449 --> 00:13:33,029
couple of different programs running in

00:13:29,430 --> 00:13:35,430
the background memory usage just just

00:13:33,029 --> 00:13:37,290
remember this number so for this

00:13:35,430 --> 00:13:41,510
execution piden are located on the hip

00:13:37,290 --> 00:13:43,829
about 35 megabytes and it's small and

00:13:41,510 --> 00:13:46,410
tests I don't have to tell you about

00:13:43,829 --> 00:13:49,170
Python tests it's gorgeous it's cool you

00:13:46,410 --> 00:13:51,089
can either use unity tests or dog tests

00:13:49,170 --> 00:13:53,339
if you don't have if you don't want to

00:13:51,089 --> 00:13:55,560
bother or you can have some additional

00:13:53,339 --> 00:13:58,769
like PI test packages or something

00:13:55,560 --> 00:14:01,560
completely different like nose tests the

00:13:58,769 --> 00:14:04,320
echo system is amazing tell me at least

00:14:01,560 --> 00:14:08,310
one use case that is not applicable to

00:14:04,320 --> 00:14:10,560
Python the version of Python should not

00:14:08,310 --> 00:14:12,690
be a problem at all starting 3.6

00:14:10,560 --> 00:14:14,760
sometimes you might run into rendering

00:14:12,690 --> 00:14:18,630
problems but it's a slightly different

00:14:14,760 --> 00:14:22,649
issue and it dependent on the OS that

00:14:18,630 --> 00:14:25,079
you are running it on I've spent about

00:14:22,649 --> 00:14:28,019
an hour writing this program so I will

00:14:25,079 --> 00:14:29,910
say it's quite fast the simplicity of

00:14:28,019 --> 00:14:31,860
the code you can judge for yourself but

00:14:29,910 --> 00:14:33,510
I will say it's also quite cool it's

00:14:31,860 --> 00:14:36,420
easy to understand what it's happening

00:14:33,510 --> 00:14:40,350
and not only by the structure but like

00:14:36,420 --> 00:14:42,660
from the Python code itself ok so now

00:14:40,350 --> 00:14:44,839
I'll have the second contender which is

00:14:42,660 --> 00:14:44,839
rust

00:14:46,740 --> 00:14:53,310
as you can see it looks very similar you

00:14:49,890 --> 00:14:55,620
have to use imports this use STD

00:14:53,310 --> 00:14:59,790
something is just an import to use

00:14:55,620 --> 00:15:03,000
certain structure or function from a

00:14:59,790 --> 00:15:04,890
trade then you have these things are

00:15:03,000 --> 00:15:07,380
called macros you probably saw it from

00:15:04,890 --> 00:15:09,410
the previous speaker they will give you

00:15:07,380 --> 00:15:13,220
over the implementation of this

00:15:09,410 --> 00:15:15,360
functionality into your strategy just

00:15:13,220 --> 00:15:17,910
simplification so we have the same

00:15:15,360 --> 00:15:20,880
request you can see right now struct as

00:15:17,910 --> 00:15:23,040
a class that has ID remaining waiting

00:15:20,880 --> 00:15:26,130
time assigned taxi which is now option

00:15:23,040 --> 00:15:30,450
so again it can be non or in this case

00:15:26,130 --> 00:15:35,160
UID and fulfillment time then we have

00:15:30,450 --> 00:15:37,560
our request implementation it's in rust

00:15:35,160 --> 00:15:40,200
you can create a constructor directly

00:15:37,560 --> 00:15:42,000
and this is let's say utility function

00:15:40,200 --> 00:15:45,540
where you also can provide some default

00:15:42,000 --> 00:15:49,020
values if you want to I have it here so

00:15:45,540 --> 00:15:51,959
and is alive the next one would be taxi

00:15:49,020 --> 00:15:55,260
which looks almost the same way as the

00:15:51,959 --> 00:15:57,690
Python one with implementation of the

00:15:55,260 --> 00:16:03,060
new function and then we are at our

00:15:57,690 --> 00:16:05,490
world that has be very same fields that

00:16:03,060 --> 00:16:08,640
title class as well has runtime age

00:16:05,490 --> 00:16:12,060
request functions max active requires

00:16:08,640 --> 00:16:15,750
taxis is a vector like list in Python

00:16:12,060 --> 00:16:18,390
would be a vector in rust then active

00:16:15,750 --> 00:16:21,630
request and archive request I have them

00:16:18,390 --> 00:16:23,610
separately and not United as a one hash

00:16:21,630 --> 00:16:26,100
map you could do this as well but this

00:16:23,610 --> 00:16:28,110
was the idea to go with at the first so

00:16:26,100 --> 00:16:30,240
it's not completely optimal

00:16:28,110 --> 00:16:33,300
implementation and rust but something

00:16:30,240 --> 00:16:36,360
that works then you have the new

00:16:33,300 --> 00:16:38,360
function for the world you have the RNG

00:16:36,360 --> 00:16:40,529
for random you have to pass it through

00:16:38,360 --> 00:16:44,279
in comparison to peyten

00:16:40,529 --> 00:16:47,270
that can just use it as a global then we

00:16:44,279 --> 00:16:49,980
have a utility function print and

00:16:47,270 --> 00:16:52,320
implementation for that then maybe spawn

00:16:49,980 --> 00:16:55,230
request you already seen it's very

00:16:52,320 --> 00:16:57,720
similar distribute and fulfilled request

00:16:55,230 --> 00:17:00,570
is slightly different you now can see

00:16:57,720 --> 00:17:02,820
this in term you'll find which

00:17:00,570 --> 00:17:04,410
in rust you have a concept of mutable

00:17:02,820 --> 00:17:07,140
and immutable you probably all know that

00:17:04,410 --> 00:17:09,060
and you have to think in advance whether

00:17:07,140 --> 00:17:10,830
you want to change certain structures or

00:17:09,060 --> 00:17:13,170
not where you want to reference them or

00:17:10,830 --> 00:17:14,910
not and stuff like that you normally get

00:17:13,170 --> 00:17:17,910
used to this after a couple of days

00:17:14,910 --> 00:17:20,100
writing rust but it is something that is

00:17:17,910 --> 00:17:23,550
very different from fighting just to

00:17:20,100 --> 00:17:27,240
notice then update request is the same

00:17:23,550 --> 00:17:29,250
and then we have clean up requests which

00:17:27,240 --> 00:17:33,300
is slightly different in comparison to

00:17:29,250 --> 00:17:38,580
pieden due to this concept of borrowing

00:17:33,300 --> 00:17:43,860
and borrowing and reference checking so

00:17:38,580 --> 00:17:45,570
you cannot just say one a vector from an

00:17:43,860 --> 00:17:47,070
element from vector just append to a

00:17:45,570 --> 00:17:48,960
different vector because there's going

00:17:47,070 --> 00:17:51,840
to be movement and you have only one

00:17:48,960 --> 00:17:54,720
owner at a time just ask me later about

00:17:51,840 --> 00:17:57,570
technical details so that we don't spend

00:17:54,720 --> 00:17:59,490
too much time on this but it's just the

00:17:57,570 --> 00:18:01,110
way it is it still is kind

00:17:59,490 --> 00:18:05,130
understandable from the code that you

00:18:01,110 --> 00:18:07,070
can see then you can have like you have

00:18:05,130 --> 00:18:11,690
your run till done which is the same

00:18:07,070 --> 00:18:15,420
this display function is just air

00:18:11,690 --> 00:18:16,920
implementation for print Russ does not

00:18:15,420 --> 00:18:18,510
always by default house print

00:18:16,920 --> 00:18:24,830
possibility for every stroke you have

00:18:18,510 --> 00:18:29,430
and then we have our main so what does

00:18:24,830 --> 00:18:31,080
rust tell us it results in hundred sixty

00:18:29,430 --> 00:18:34,320
lines of code without documentation

00:18:31,080 --> 00:18:37,620
documentation was with three slashes and

00:18:34,320 --> 00:18:42,840
performance was one day with no logging

00:18:37,620 --> 00:18:47,450
is 154 milliseconds we're verses Titan

00:18:42,840 --> 00:18:51,770
200 seconds the memory usage is a

00:18:47,450 --> 00:18:55,020
magnitude less than piden it actually is

00:18:51,770 --> 00:18:59,790
heap allocation and not stack so there

00:18:55,020 --> 00:19:02,790
are some shady business done there I say

00:18:59,790 --> 00:19:06,210
I must say but in pure hippo location

00:19:02,790 --> 00:19:08,610
Russ just bit spite and add the

00:19:06,210 --> 00:19:12,020
different criteria were the simplicity

00:19:08,610 --> 00:19:14,690
of the code so I would

00:19:12,020 --> 00:19:16,280
it's subjective and you would understand

00:19:14,690 --> 00:19:19,490
from reading the code twice or three

00:19:16,280 --> 00:19:21,710
times if you never did it before but

00:19:19,490 --> 00:19:25,070
it's still type of wins in this regard

00:19:21,710 --> 00:19:28,160
then amount of time I spend on writing

00:19:25,070 --> 00:19:29,690
this one is one day because my first

00:19:28,160 --> 00:19:33,740
implementation actually I managed to

00:19:29,690 --> 00:19:37,760
make it quadratic time so it never ended

00:19:33,740 --> 00:19:39,610
I run off patients before that so you

00:19:37,760 --> 00:19:42,050
really have to invest time in advance

00:19:39,610 --> 00:19:44,630
thinking of okay what am I doing here

00:19:42,050 --> 00:19:46,370
also you will fight with the compiler a

00:19:44,630 --> 00:19:50,510
lot in the beginning but he is your

00:19:46,370 --> 00:19:56,950
friend so if it compiles it works

00:19:50,510 --> 00:19:59,240
the other one was test cargo is the

00:19:56,950 --> 00:20:01,460
manager package manager for instance and

00:19:59,240 --> 00:20:06,260
everything man adjourn in rust you can

00:20:01,460 --> 00:20:08,540
arouse around just cargo chests with and

00:20:06,260 --> 00:20:10,580
write the test in the same file as your

00:20:08,540 --> 00:20:13,970
normal program or in a different file

00:20:10,580 --> 00:20:16,490
and just annotate it with hash tag test

00:20:13,970 --> 00:20:20,420
which is a macro for tests then

00:20:16,490 --> 00:20:23,780
ecosystem is not that good at all in

00:20:20,420 --> 00:20:25,790
comparison to piden it can be in a

00:20:23,780 --> 00:20:29,090
certain domains like embedded

00:20:25,790 --> 00:20:31,070
programming or finance low-level

00:20:29,090 --> 00:20:33,440
programming in general right now it's

00:20:31,070 --> 00:20:36,590
catching up on web services as well but

00:20:33,440 --> 00:20:38,590
peyten is very much ahead and again the

00:20:36,590 --> 00:20:42,040
situation where you have something like

00:20:38,590 --> 00:20:45,170
presto and Hadoop or - Hadoop on your

00:20:42,040 --> 00:20:48,050
business use case just forget up there

00:20:45,170 --> 00:20:55,280
is no crate in rust for using those as

00:20:48,050 --> 00:20:58,760
cool layers yeah so let's have a more

00:20:55,280 --> 00:21:01,340
visual comparison so amount of code rust

00:20:58,760 --> 00:21:03,860
is about two times more code it can be

00:21:01,340 --> 00:21:05,330
even more or about the same amount if

00:21:03,860 --> 00:21:08,480
you know how to write your program but

00:21:05,330 --> 00:21:11,450
for beginners Python is that clear clean

00:21:08,480 --> 00:21:14,450
advantage there the simplicity is it

00:21:11,450 --> 00:21:18,550
both case is very simple both languages

00:21:14,450 --> 00:21:22,580
are trying to keep it very simple and

00:21:18,550 --> 00:21:24,290
usable documentation I would have said

00:21:22,580 --> 00:21:26,690
that it's good in both cases but

00:21:24,290 --> 00:21:29,060
rust has one killer feature for me and

00:21:26,690 --> 00:21:31,520
which is you can have offline

00:21:29,060 --> 00:21:33,700
documentation served on your local

00:21:31,520 --> 00:21:36,290
server for instance HTTP Python server

00:21:33,700 --> 00:21:38,450
accessible offline if you have it cached

00:21:36,290 --> 00:21:42,560
with your cargo so you can build your

00:21:38,450 --> 00:21:43,700
project and you have it offline doesn't

00:21:42,560 --> 00:21:46,400
matter whether you have internet or not

00:21:43,700 --> 00:21:46,940
which is as far as I know not the case

00:21:46,400 --> 00:21:50,480
for peyten

00:21:46,940 --> 00:21:52,190
this is why for pieden I left no mark or

00:21:50,480 --> 00:21:54,520
color for this one and Rousseau said

00:21:52,190 --> 00:21:54,520
like yes

00:21:54,800 --> 00:22:01,100
memory efficiency duh performance you

00:21:59,210 --> 00:22:03,230
saw it

00:22:01,100 --> 00:22:05,000
echo system by the way there were no

00:22:03,230 --> 00:22:07,610
paralyzation in the program so it can

00:22:05,000 --> 00:22:10,940
run even faster and quiet cheaper for

00:22:07,610 --> 00:22:13,310
that matter echo system Titan is a clear

00:22:10,940 --> 00:22:17,330
advantage there there is no denying that

00:22:13,310 --> 00:22:19,910
versions in piden you should have no

00:22:17,330 --> 00:22:24,050
problems if you got rid of your pattern

00:22:19,910 --> 00:22:25,820
to hopefully and in rust

00:22:24,050 --> 00:22:27,860
it will depend whether you have to use

00:22:25,820 --> 00:22:30,410
nightly or not stable has most of the

00:22:27,860 --> 00:22:32,150
features nightly has really nice

00:22:30,410 --> 00:22:34,640
features that you might need or might

00:22:32,150 --> 00:22:36,680
note depending on how deep you want to

00:22:34,640 --> 00:22:39,230
go in your implementations since we are

00:22:36,680 --> 00:22:41,930
using a writing from scratch use case

00:22:39,230 --> 00:22:43,940
and development simplicity and

00:22:41,930 --> 00:22:47,360
development speed I am a Python

00:22:43,940 --> 00:22:53,840
developer not a res developer so this is

00:22:47,360 --> 00:22:55,430
biased for me so would you write rather

00:22:53,840 --> 00:22:58,070
in rust or in tight in your simulation

00:22:55,430 --> 00:22:59,810
if you need one to be honest I don't

00:22:58,070 --> 00:23:03,070
know because you have to consider your

00:22:59,810 --> 00:23:07,280
pain points first like cost scalability

00:23:03,070 --> 00:23:09,380
your extensibility and speed because at

00:23:07,280 --> 00:23:11,450
some point if you go for patent you have

00:23:09,380 --> 00:23:14,270
to do optimization like it always

00:23:11,450 --> 00:23:16,160
happens and optimization can take quite

00:23:14,270 --> 00:23:17,900
a lot of your resources in terms of

00:23:16,160 --> 00:23:20,270
development time in terms of even

00:23:17,900 --> 00:23:22,670
getting some libraries that are not open

00:23:20,270 --> 00:23:25,970
source or whatever at the same time if

00:23:22,670 --> 00:23:27,860
you go with rust you will be very slow

00:23:25,970 --> 00:23:30,620
in the beginning maybe even very

00:23:27,860 --> 00:23:32,800
frustrated but the end results always

00:23:30,620 --> 00:23:35,360
were said you won't be able to reach

00:23:32,800 --> 00:23:36,659
this performance with pipe in pure code

00:23:35,360 --> 00:23:40,379
without any side

00:23:36,659 --> 00:23:42,210
or whatever usage so I'm sorry for not

00:23:40,379 --> 00:23:43,979
giving you the exact answer on this

00:23:42,210 --> 00:23:46,470
question you have to consider for

00:23:43,979 --> 00:23:50,399
yourself depending on what simulation

00:23:46,470 --> 00:23:52,259
you're writing how fast should it be how

00:23:50,399 --> 00:23:54,210
scalable should it be how simple should

00:23:52,259 --> 00:23:58,799
it be in the end for other users to use

00:23:54,210 --> 00:24:01,859
it if you want to have simple okie fast

00:23:58,799 --> 00:24:05,190
and right now simulation then go with

00:24:01,859 --> 00:24:09,109
pipe if you are able to invest time then

00:24:05,190 --> 00:24:09,109
consider us thank you

00:24:17,059 --> 00:24:27,629
so I think we have time for questions if

00:24:20,009 --> 00:24:32,129
there are any did you try to run your

00:24:27,629 --> 00:24:35,070
simulation spy pie not yet but in

00:24:32,129 --> 00:24:41,789
previous years we actually had a similar

00:24:35,070 --> 00:24:44,699
program and we me I try to use PI three

00:24:41,789 --> 00:24:47,459
sightsee piden and pi pi pi pi from the

00:24:44,699 --> 00:24:48,929
box gave me 30% of performance

00:24:47,459 --> 00:24:52,409
improvement which is still not the

00:24:48,929 --> 00:24:54,989
magnitude or several magnitudes and also

00:24:52,409 --> 00:24:58,049
pi pi is not compatible with all

00:24:54,989 --> 00:24:59,429
packages for instance iechyd if again

00:24:58,049 --> 00:25:01,259
I'm a machine learning engineer it's my

00:24:59,429 --> 00:25:03,809
biggest pain we use Sai kit and we

00:25:01,259 --> 00:25:05,909
cannot use pi pi for that matter to be

00:25:03,809 --> 00:25:08,039
Fairbrass probably we'll always have

00:25:05,909 --> 00:25:10,349
problems with that as well but yes I

00:25:08,039 --> 00:25:14,359
tried by PI in a similar situation it

00:25:10,349 --> 00:25:14,359
didn't perform as well as rust

00:25:19,520 --> 00:25:24,020
thanks for the talk they were

00:25:20,840 --> 00:25:26,150
interesting tell me about the business

00:25:24,020 --> 00:25:28,370
of writing simulations it's a big thing

00:25:26,150 --> 00:25:31,210
like is it critical to the business how

00:25:28,370 --> 00:25:34,880
many people work on that I will say

00:25:31,210 --> 00:25:37,250
simulation is the next big buzzword in

00:25:34,880 --> 00:25:39,370
industry for instance I can give you a

00:25:37,250 --> 00:25:43,520
couple examples from mobility industry

00:25:39,370 --> 00:25:45,140
Tesla uber my taxi we all writing

00:25:43,520 --> 00:25:47,900
simulations for slightly different

00:25:45,140 --> 00:25:50,210
purposes for instance Tesla has a giant

00:25:47,900 --> 00:25:52,880
and very complex simulator for autopilot

00:25:50,210 --> 00:25:54,679
to test some new features before they

00:25:52,880 --> 00:25:58,370
roll it out into the streets

00:25:54,679 --> 00:26:01,429
so to avoid certain fatal flaws or to

00:25:58,370 --> 00:26:05,600
catch them slightly earlier uber has

00:26:01,429 --> 00:26:08,179
simulator for marketing purposes and in

00:26:05,600 --> 00:26:11,240
my taxi we are developing it for in the

00:26:08,179 --> 00:26:12,860
first row for development purposes

00:26:11,240 --> 00:26:14,750
meaning we want to speed up our

00:26:12,860 --> 00:26:16,670
development cycle for instance we have a

00:26:14,750 --> 00:26:18,590
team that works on allocation so

00:26:16,670 --> 00:26:22,670
connecting driver and a passenger and

00:26:18,590 --> 00:26:24,380
they have a brilliant idea but until

00:26:22,670 --> 00:26:26,630
they put it into production and run an

00:26:24,380 --> 00:26:28,880
a/b test for some times they don't know

00:26:26,630 --> 00:26:30,350
whether it was worth it or not we can

00:26:28,880 --> 00:26:32,780
even lose people if it was a bad

00:26:30,350 --> 00:26:34,280
decision so we are one what we are doing

00:26:32,780 --> 00:26:38,920
we are building a simulation that will

00:26:34,280 --> 00:26:41,450
allow them to at least cut the bad ideas

00:26:38,920 --> 00:26:44,300
also you can test certain things like

00:26:41,450 --> 00:26:48,830
how would my system react if we have a

00:26:44,300 --> 00:26:52,780
strike suddenly we have small supply

00:26:48,830 --> 00:26:55,400
like we have instead of 200 cars one car

00:26:52,780 --> 00:26:57,890
we still want to make money so we will

00:26:55,400 --> 00:27:00,140
probably have to serve our best

00:26:57,890 --> 00:27:02,480
customers first and stuff like that you

00:27:00,140 --> 00:27:04,640
just cannot replay it in the real world

00:27:02,480 --> 00:27:07,190
also from your historical data is kind

00:27:04,640 --> 00:27:08,870
of hard because it's just historical and

00:27:07,190 --> 00:27:12,790
not flexible and this is where

00:27:08,870 --> 00:27:16,700
simulation kicks in also simulations are

00:27:12,790 --> 00:27:19,010
very used for data generation purposes

00:27:16,700 --> 00:27:21,290
for instance if you want to not only

00:27:19,010 --> 00:27:23,150
test your system on robustness like ok

00:27:21,290 --> 00:27:25,670
this service works there because it's

00:27:23,150 --> 00:27:27,770
coming in but you want to produce some

00:27:25,670 --> 00:27:29,400
edge cases and you want to test

00:27:27,770 --> 00:27:31,890
it's like aunt went

00:27:29,400 --> 00:27:39,570
and why's that simulation can also help

00:27:31,890 --> 00:27:41,550
you Thanks I thank you for a

00:27:39,570 --> 00:27:43,290
presentation you've mentioned about data

00:27:41,550 --> 00:27:46,470
generation and I know that there are

00:27:43,290 --> 00:27:49,080
papers for using machine learning models

00:27:46,470 --> 00:27:52,010
to speed up simulations you're basically

00:27:49,080 --> 00:27:55,710
using input and output from the

00:27:52,010 --> 00:27:58,680
simulation has then data set and data

00:27:55,710 --> 00:28:02,130
set for our model have you heard or

00:27:58,680 --> 00:28:04,350
considered using that yeah the thing

00:28:02,130 --> 00:28:07,920
that we are building and it's quiet like

00:28:04,350 --> 00:28:11,640
quite famous is agent based simulations

00:28:07,920 --> 00:28:14,280
so we have trained models of drivers or

00:28:11,640 --> 00:28:16,470
passengers or for instance your baristas

00:28:14,280 --> 00:28:20,700
if you are talking about coffee shop or

00:28:16,470 --> 00:28:22,830
even customers that are learned from

00:28:20,700 --> 00:28:24,900
historical data for instance I have a

00:28:22,830 --> 00:28:27,330
customer agent that learned that he's

00:28:24,900 --> 00:28:29,820
and sorry for the word and he

00:28:27,330 --> 00:28:31,890
likes and leaving no tips and spilling

00:28:29,820 --> 00:28:33,750
coffee everywhere so you would have

00:28:31,890 --> 00:28:37,680
something like this on your simulation

00:28:33,750 --> 00:28:41,010
so I don't know exactly how would you

00:28:37,680 --> 00:28:44,070
use models to speed up simulation itself

00:28:41,010 --> 00:28:51,090
but using models in the simulation is

00:28:44,070 --> 00:28:53,420
quite very often ticking thank you thank

00:28:51,090 --> 00:28:53,420
you for you

00:28:56,200 --> 00:28:58,819

YouTube URL: https://www.youtube.com/watch?v=kytvDxxedWY


