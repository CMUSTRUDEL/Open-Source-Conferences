Title: Max Bélanger - How to ship a Python app to a hundred million desktops
Publication date: 2019-09-23
Playlist: EuroPython 2019
Description: 
	"How to ship a Python app to a hundred million desktops
[EuroPython 2019 - Talk - 2019-07-11 - Shanghai]
[Basel, CH]

By Max Bélanger

Python is widely used to write scripts and tools, but did you know that it can also be used to build client-side end-user applications? Crossing the gap from script to app can be challenging: Join us to learn how to write modern, high quality desktop apps in Python!

At Dropbox, we’ve been fans of Python from the very beginning: we’ll take you on a tour of our app for Windows/macOS/Linux and share our “lessons learned” from over 10 years of development.

We’ll share best practices and techniques for shipping Python code to hundreds of millions of devices: discover how to maximize security, improve performance and guarantee stability.

We’ll explore the key choices we made and why: learn how we migrated to Python 3 by simultaneously shipping both versions, or how we use HTML to power our GUI (a la Electron).

We’ll reveal our favorite tools and libraries: learn how we scaled from a few engineers to over 100 and added support for other programming languages (like Rust). 

The goal of this talk is to share our learnings from using Python on Windows, macOS and Linux to encourage the use of Python when building Desktop apps.
- We also want to recognize the third-party libraries we’ve used (and their authors) to raise their profile with the overall community.
- We hope this will inspire attendees to write more desktop Python code, and raise awareness for this use case with the community as a whole. 

We intend to speak to any Python developer/engineer or enthusiast who makes use of Python in a Desktop environment (or wants to), whether it’s to make scripts, tools or apps.
We do not expect knowledge of any specific third-party Python libraries; in fact, we hope to draw attention to and recognize many libraries we’ve found useful.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/
Captions: 
	00:00:05,769 --> 00:00:09,080
all right

00:00:07,309 --> 00:00:13,969
could everyone hear me hello hello

00:00:09,080 --> 00:00:16,640
everyone I'm max I'm an engineer at

00:00:13,969 --> 00:00:19,130
Dropbox I've been there like like the

00:00:16,640 --> 00:00:21,830
very kind introduction mentioned for a

00:00:19,130 --> 00:00:23,060
long time I speak actually speak French

00:00:21,830 --> 00:00:25,310
so this is very exciting for me because

00:00:23,060 --> 00:00:28,370
I get to hopefully practice it a little

00:00:25,310 --> 00:00:29,810
bit this this this conference

00:00:28,370 --> 00:00:31,160
although funny enough you'll notice I

00:00:29,810 --> 00:00:34,880
probably to you I'll probably have an

00:00:31,160 --> 00:00:35,390
accent in both languages so why why am I

00:00:34,880 --> 00:00:37,940
here

00:00:35,390 --> 00:00:39,829
well Dropbox loves Python so in fact our

00:00:37,940 --> 00:00:41,900
very first lines of code ever were

00:00:39,829 --> 00:00:43,489
written in Python some of our key

00:00:41,900 --> 00:00:45,800
infrastructure is also written in Python

00:00:43,489 --> 00:00:46,700
our apps for Windows Mac and Linux are

00:00:45,800 --> 00:00:48,739
also running Python

00:00:46,700 --> 00:00:50,600
basically we're fans we've used it all

00:00:48,739 --> 00:00:54,170
we've used a sink or multi-processing

00:00:50,600 --> 00:00:57,170
pickle sadly we've done many many things

00:00:54,170 --> 00:00:58,460
with Python and we really like it Python

00:00:57,170 --> 00:01:01,370
is kind of widely known as a

00:00:58,460 --> 00:01:03,200
general-purpose language it's kind of

00:01:01,370 --> 00:01:05,180
the the phrases its batteries included

00:01:03,200 --> 00:01:07,040
it has a really strong standard library

00:01:05,180 --> 00:01:09,260
so we liked it because as a start-up you

00:01:07,040 --> 00:01:10,760
know it's great you can it's really good

00:01:09,260 --> 00:01:13,070
for prototyping and you can you can get

00:01:10,760 --> 00:01:15,380
going really quickly it's pretty popular

00:01:13,070 --> 00:01:16,850
for back-end development of course and

00:01:15,380 --> 00:01:18,440
for a bunch of other use cases as well

00:01:16,850 --> 00:01:21,560
but what you may not know is that you

00:01:18,440 --> 00:01:23,710
can build client-side and user apps in

00:01:21,560 --> 00:01:27,020
Python now this is a bit less common

00:01:23,710 --> 00:01:30,170
it's not the road most travel but this

00:01:27,020 --> 00:01:32,900
this is something we've applied so so

00:01:30,170 --> 00:01:35,299
you want to make an app what exactly is

00:01:32,900 --> 00:01:37,729
an app so - I guess for the purpose of

00:01:35,299 --> 00:01:41,210
this talk let's define an app as some

00:01:37,729 --> 00:01:43,070
software that you writes that is

00:01:41,210 --> 00:01:45,979
installed on a user's device by that

00:01:43,070 --> 00:01:48,500
user and that complies with that devices

00:01:45,979 --> 00:01:51,259
platform so in this case by platform I

00:01:48,500 --> 00:01:53,150
mean basically the operating system the

00:01:51,259 --> 00:01:56,630
platform is important because it defines

00:01:53,150 --> 00:01:59,270
both what the app is so that means the

00:01:56,630 --> 00:02:01,340
format that the app has to take and also

00:01:59,270 --> 00:02:03,229
what the app can do so that usually

00:02:01,340 --> 00:02:05,840
means the frameworks or the API is that

00:02:03,229 --> 00:02:08,479
the app can use now pythons batteries

00:02:05,840 --> 00:02:09,950
are are kind of great in a sense but

00:02:08,479 --> 00:02:11,959
they're also bad in this case because

00:02:09,950 --> 00:02:13,370
they hide all of this from you so when

00:02:11,959 --> 00:02:14,520
you're using Python you have an

00:02:13,370 --> 00:02:16,500
interpreter and you have

00:02:14,520 --> 00:02:17,910
and you get to not really have to care

00:02:16,500 --> 00:02:19,950
as to whether you're running the script

00:02:17,910 --> 00:02:21,150
on a Mac or on Windows most of the time

00:02:19,950 --> 00:02:23,280
anyway

00:02:21,150 --> 00:02:25,580
so to build an app using Python you kind

00:02:23,280 --> 00:02:28,200
of have to look behind the curtain so

00:02:25,580 --> 00:02:30,030
this isn't exactly a common use case for

00:02:28,200 --> 00:02:32,760
Python and it's not really directly

00:02:30,030 --> 00:02:34,800
served by its by its standard library so

00:02:32,760 --> 00:02:37,350
crossing the gap from a script to an app

00:02:34,800 --> 00:02:39,000
can be pretty challenging but it is

00:02:37,350 --> 00:02:41,340
absolutely possible and we've been able

00:02:39,000 --> 00:02:43,170
to do it at Dropbox so there are many

00:02:41,340 --> 00:02:45,210
many topics to cover but there are four

00:02:43,170 --> 00:02:46,800
large areas I'd like to explore and what

00:02:45,210 --> 00:02:48,810
I'll do is I'll walk you through our

00:02:46,800 --> 00:02:50,100
journey into building an app and I'll

00:02:48,810 --> 00:02:51,860
point out some of the more interesting

00:02:50,100 --> 00:02:55,500
decisions and lessons that we've learned

00:02:51,860 --> 00:02:57,210
I also want to share some of the some of

00:02:55,500 --> 00:02:59,160
our favorite Python libraries that are

00:02:57,210 --> 00:03:01,230
open source that we've been using and

00:02:59,160 --> 00:03:02,580
it's actually quite fitting that we're

00:03:01,230 --> 00:03:04,740
doing this a euro Python because many of

00:03:02,580 --> 00:03:08,580
those were written by people in Europe

00:03:04,740 --> 00:03:09,750
actually so first up we'll talk about

00:03:08,580 --> 00:03:12,150
integrating with the platform's

00:03:09,750 --> 00:03:13,830
frameworks so this is where the app or

00:03:12,150 --> 00:03:15,720
where the OS defines what the app can do

00:03:13,830 --> 00:03:17,880
and that's the first step into building

00:03:15,720 --> 00:03:21,150
it out second we'll look at how to

00:03:17,880 --> 00:03:24,270
package an app into into a format that

00:03:21,150 --> 00:03:25,980
is recognized by the OS third we'll talk

00:03:24,270 --> 00:03:27,900
about what happens after you've packaged

00:03:25,980 --> 00:03:29,340
and and how you can monitor your app and

00:03:27,900 --> 00:03:33,810
sort of evolve it gradually over time

00:03:29,340 --> 00:03:36,170
and finally we'll go into beyond Python

00:03:33,810 --> 00:03:37,890
and I'll get to what that means exactly

00:03:36,170 --> 00:03:40,560
in a minute

00:03:37,890 --> 00:03:42,960
so let's start with the first section so

00:03:40,560 --> 00:03:45,480
for an app to work it needs to be able

00:03:42,960 --> 00:03:47,160
to use the platform's frameworks so to

00:03:45,480 --> 00:03:51,720
build an app that basically means you'll

00:03:47,160 --> 00:03:53,100
need to use the OSS api's directly we've

00:03:51,720 --> 00:03:55,350
been calling this kind of unlocking the

00:03:53,100 --> 00:03:57,570
platform's binaries or the platform's

00:03:55,350 --> 00:03:59,820
batteries so why would you want to use

00:03:57,570 --> 00:04:01,230
OS api's you know there's perfectly this

00:03:59,820 --> 00:04:04,590
perfectly good standard library in

00:04:01,230 --> 00:04:06,660
Python well each platform has very

00:04:04,590 --> 00:04:09,210
specific api's and some of them have use

00:04:06,660 --> 00:04:10,650
cases that only really make sense on the

00:04:09,210 --> 00:04:12,450
type of device supported by that

00:04:10,650 --> 00:04:16,560
platform so we found out very quickly

00:04:12,450 --> 00:04:19,109
that POSIX module or OS wasn't quite

00:04:16,560 --> 00:04:21,270
enough for us and that's really because

00:04:19,109 --> 00:04:23,700
it kind of turns into this lowest common

00:04:21,270 --> 00:04:25,979
denominator so platon Python supports so

00:04:23,700 --> 00:04:28,380
many OSS and platforms the sort of

00:04:25,979 --> 00:04:31,440
results standard library that it has

00:04:28,380 --> 00:04:33,870
is a bit of the generic look that of

00:04:31,440 --> 00:04:35,460
something that works on all of these in

00:04:33,870 --> 00:04:37,590
some cases you're gonna have use cases

00:04:35,460 --> 00:04:39,600
where you're gonna want to use the

00:04:37,590 --> 00:04:41,610
platform's api's directly and this you

00:04:39,600 --> 00:04:44,370
know your mileage may vary but for us

00:04:41,610 --> 00:04:45,930
this was very very common and for

00:04:44,370 --> 00:04:48,180
example since our job is to sync files

00:04:45,930 --> 00:04:50,040
and to actually smooth out the

00:04:48,180 --> 00:04:51,720
differences between Windows and Mac and

00:04:50,040 --> 00:04:53,130
Linux it's actually important that we

00:04:51,720 --> 00:04:55,740
see with those different where those

00:04:53,130 --> 00:04:57,540
differences are so all of this is to say

00:04:55,740 --> 00:04:58,860
really it's it's likely if you're

00:04:57,540 --> 00:05:04,530
building an app you're gonna need to at

00:04:58,860 --> 00:05:06,300
some point use some OS api's directly so

00:05:04,530 --> 00:05:09,570
how should we go about using those api's

00:05:06,300 --> 00:05:12,950
now most platforms sadly don't directly

00:05:09,570 --> 00:05:15,240
support Python as a first-class language

00:05:12,950 --> 00:05:17,490
to use those api you're going to need

00:05:15,240 --> 00:05:20,310
bindings and what we mean by that are

00:05:17,490 --> 00:05:24,000
ways of projecting non python api is

00:05:20,310 --> 00:05:25,920
into python these are great because they

00:05:24,000 --> 00:05:26,970
let you use those api is from python as

00:05:25,920 --> 00:05:29,370
though python was a first-class

00:05:26,970 --> 00:05:31,020
supported language but bindings aren't

00:05:29,370 --> 00:05:33,180
free that's the our first lesson their

00:05:31,020 --> 00:05:36,330
bindings are actually relatively costly

00:05:33,180 --> 00:05:38,160
if you're not careful and also one

00:05:36,330 --> 00:05:39,780
really important thing the native

00:05:38,160 --> 00:05:40,890
compilers and tool chains are always

00:05:39,780 --> 00:05:42,750
going to have a little bit of an

00:05:40,890 --> 00:05:45,630
advantage no matter how much glue you're

00:05:42,750 --> 00:05:47,790
able to introduce so keeping that in

00:05:45,630 --> 00:05:50,430
mind let's start with the most common

00:05:47,790 --> 00:05:52,110
types of bindings c so almost this is

00:05:50,430 --> 00:05:55,050
very common almost every single platform

00:05:52,110 --> 00:05:57,240
has a C API we've used a lot of C types

00:05:55,050 --> 00:05:58,680
I think there are tens of thousands of

00:05:57,240 --> 00:06:01,140
lines of C types probably in our code

00:05:58,680 --> 00:06:03,120
base this is kind of a canonical way to

00:06:01,140 --> 00:06:05,580
do this in the Python the C API and

00:06:03,120 --> 00:06:06,870
these works really well at first but

00:06:05,580 --> 00:06:08,160
they didn't really aged well and the

00:06:06,870 --> 00:06:10,650
reason for that is something that I

00:06:08,160 --> 00:06:12,690
think the C FFI team explains really

00:06:10,650 --> 00:06:15,090
well in their Docs which is C types

00:06:12,690 --> 00:06:16,350
operates at the API level and what you

00:06:15,090 --> 00:06:18,750
really want most of the time is to

00:06:16,350 --> 00:06:21,000
operate at the API level so what we mean

00:06:18,750 --> 00:06:23,010
here is that you because you have to

00:06:21,000 --> 00:06:24,870
write these bindings manually it's

00:06:23,010 --> 00:06:26,670
really easy to make a mistake because

00:06:24,870 --> 00:06:28,320
these are generally meant to be used

00:06:26,670 --> 00:06:30,570
with the compiler not meant to be used

00:06:28,320 --> 00:06:33,150
with with this type of jumping so let's

00:06:30,570 --> 00:06:36,479
take an example here's an example of

00:06:33,150 --> 00:06:39,240
some C's very simple simple C API that

00:06:36,479 --> 00:06:40,350
you might want to use what you need to

00:06:39,240 --> 00:06:41,760
do and if you know C type this will

00:06:40,350 --> 00:06:43,920
really be neat to you but some

00:06:41,760 --> 00:06:45,540
this usable from Python you have to

00:06:43,920 --> 00:06:47,100
manually write bindings that kind of

00:06:45,540 --> 00:06:50,310
teach Python what this means and how to

00:06:47,100 --> 00:06:53,700
use it so the equivalent C types would

00:06:50,310 --> 00:06:55,830
look something like this so once you do

00:06:53,700 --> 00:06:57,210
this you're able to you're able to call

00:06:55,830 --> 00:06:59,580
the function and this is basically

00:06:57,210 --> 00:07:01,080
something where you tell you tell Python

00:06:59,580 --> 00:07:03,180
hey this structure exists it has these

00:07:01,080 --> 00:07:06,960
fields this is a function this is a

00:07:03,180 --> 00:07:08,970
result type the archetypes etc but the

00:07:06,960 --> 00:07:10,830
warning here is that you don't have any

00:07:08,970 --> 00:07:14,700
compiler in fact your your you have

00:07:10,830 --> 00:07:16,280
complete control here really once you've

00:07:14,700 --> 00:07:18,930
created this and you call a function

00:07:16,280 --> 00:07:21,060
Python just kind of jumps and hopes for

00:07:18,930 --> 00:07:22,980
the best so if you make a mistake which

00:07:21,060 --> 00:07:26,520
turns out is actually pretty easy if you

00:07:22,980 --> 00:07:28,350
use the wrong type for example it might

00:07:26,520 --> 00:07:31,320
actually still work but then caused a

00:07:28,350 --> 00:07:32,910
crash later down the line so the worst

00:07:31,320 --> 00:07:34,890
case scenario here happened for us when

00:07:32,910 --> 00:07:37,110
we moved on Mac OS from 32-bit to 64-bit

00:07:34,890 --> 00:07:39,030
support because almost all pointers

00:07:37,110 --> 00:07:41,520
change ties but then this had very

00:07:39,030 --> 00:07:43,560
subtle effects on structs and the only

00:07:41,520 --> 00:07:44,940
way for us to really detect where we

00:07:43,560 --> 00:07:46,770
made mistakes was to wait for the

00:07:44,940 --> 00:07:50,970
segmentation faults to come in which was

00:07:46,770 --> 00:07:52,650
not great so C types is the basic way

00:07:50,970 --> 00:07:53,820
but there's a much better way the

00:07:52,650 --> 00:07:56,880
alternative here is to write Python

00:07:53,820 --> 00:07:59,070
extensions and this is this is much

00:07:56,880 --> 00:08:01,410
better now these are written in C they

00:07:59,070 --> 00:08:02,640
use the Python C API but they're great

00:08:01,410 --> 00:08:04,980
because they let you leverage the

00:08:02,640 --> 00:08:07,200
compiler which is safer so rather than

00:08:04,980 --> 00:08:08,940
just jumping and hoping for the best you

00:08:07,200 --> 00:08:11,040
actually generate and these are great

00:08:08,940 --> 00:08:13,230
examples of libraries to let you do this

00:08:11,040 --> 00:08:14,820
C F if I buy pi pi is amazing we also

00:08:13,230 --> 00:08:16,770
use scythe on in some cases where you

00:08:14,820 --> 00:08:18,030
need really complex bindings but these

00:08:16,770 --> 00:08:19,590
are great because they generate a C

00:08:18,030 --> 00:08:22,080
extension and then the C extension is

00:08:19,590 --> 00:08:23,640
compiled and it actually uses the real

00:08:22,080 --> 00:08:26,460
header of the C library that you're

00:08:23,640 --> 00:08:27,570
looking for and so this is this means

00:08:26,460 --> 00:08:29,360
that if you do make a mistake with a

00:08:27,570 --> 00:08:31,260
type the compiler will yell at you and

00:08:29,360 --> 00:08:32,760
one of the nice things you learn about

00:08:31,260 --> 00:08:35,360
software engineering is that the earlier

00:08:32,760 --> 00:08:37,349
your yelled at by compiler the better

00:08:35,360 --> 00:08:39,300
quick honorable mention for scythe on

00:08:37,349 --> 00:08:40,620
it's actually really really great we use

00:08:39,300 --> 00:08:43,020
a lot of C FFI but that's mostly because

00:08:40,620 --> 00:08:45,480
we don't need the complexity that scythe

00:08:43,020 --> 00:08:49,830
on sort of gives us the ability to deal

00:08:45,480 --> 00:08:51,570
with most of the time so that covers C

00:08:49,830 --> 00:08:54,930
but that's nowhere near the end of the

00:08:51,570 --> 00:08:59,040
story many platforms actually have non

00:08:54,930 --> 00:09:00,510
api's some platforms a C++ API

00:08:59,040 --> 00:09:02,430
C and these are actually quite common

00:09:00,510 --> 00:09:04,920
but binding C++ is much harder than

00:09:02,430 --> 00:09:07,410
binding C because C plus plus is very

00:09:04,920 --> 00:09:10,680
very complex because of things like

00:09:07,410 --> 00:09:14,240
mangling templates etc it has a stable

00:09:10,680 --> 00:09:16,500
ABI but it really is quite complex so

00:09:14,240 --> 00:09:19,620
there are solutions here things like

00:09:16,500 --> 00:09:22,350
swig zip boost Python but these tend to

00:09:19,620 --> 00:09:26,430
be really really bulky now our favorites

00:09:22,350 --> 00:09:28,440
so far is pi bind 11 by Wenzel jacob

00:09:26,430 --> 00:09:31,470
who's that I think this works at EPFL

00:09:28,440 --> 00:09:35,010
here this is incredible this library is

00:09:31,470 --> 00:09:37,290
amazing he uses C++ 11 14 17 features

00:09:35,010 --> 00:09:39,630
its header only and it generates a

00:09:37,290 --> 00:09:41,610
Python extension for you using the types

00:09:39,630 --> 00:09:43,800
that you're actually linking against

00:09:41,610 --> 00:09:47,640
it's it's really it's really fantastic

00:09:43,800 --> 00:09:49,350
and it's been really helpful for us so

00:09:47,640 --> 00:09:52,410
now that we've talked about generic epi

00:09:49,350 --> 00:09:54,450
is let's go into each platform so let's

00:09:52,410 --> 00:09:57,209
start with Mac Mac is one of the OS as

00:09:54,450 --> 00:09:59,880
we support when while it does have a

00:09:57,209 --> 00:10:01,440
POSIX API because it's BSD like the vast

00:09:59,880 --> 00:10:03,180
majority of its API is are actually

00:10:01,440 --> 00:10:04,950
written in Objective C now these are

00:10:03,180 --> 00:10:06,420
object oriented they have a runtime they

00:10:04,950 --> 00:10:09,089
have memory management so you have to do

00:10:06,420 --> 00:10:11,100
ref counting so not really the best

00:10:09,089 --> 00:10:12,540
thing to try to integrate as it's at the

00:10:11,100 --> 00:10:14,850
c-types level even though you could

00:10:12,540 --> 00:10:17,400
technically do that that's probably a

00:10:14,850 --> 00:10:19,140
bad idea there's an awesome project that

00:10:17,400 --> 00:10:21,660
we've used very extensively it's called

00:10:19,140 --> 00:10:24,360
PI op C by Ronald a certain who I think

00:10:21,660 --> 00:10:26,540
I saw at the conference actually so and

00:10:24,360 --> 00:10:28,920
this allows you to use directly

00:10:26,540 --> 00:10:31,320
Objective C in Python as though it were

00:10:28,920 --> 00:10:33,660
a first-class language and let's look at

00:10:31,320 --> 00:10:35,310
what this would mean so this is some

00:10:33,660 --> 00:10:37,500
sample objective-c that lets you show a

00:10:35,310 --> 00:10:41,040
notification we use this quite a bunch

00:10:37,500 --> 00:10:44,070
to show little warnings when you when

00:10:41,040 --> 00:10:46,890
you sync files for example and this is

00:10:44,070 --> 00:10:49,290
the Objective C version but this is what

00:10:46,890 --> 00:10:50,100
it looks like in PI op C so it's

00:10:49,290 --> 00:10:51,690
actually quite similar

00:10:50,100 --> 00:10:52,740
of course there's it has to deal with

00:10:51,690 --> 00:10:55,829
the fact that you know there are no

00:10:52,740 --> 00:10:57,660
square brackets in Python but the

00:10:55,829 --> 00:10:59,220
equivalent here shows you that the power

00:10:57,660 --> 00:11:01,010
of having Python act as a first-class

00:10:59,220 --> 00:11:03,060
language it's very similar with

00:11:01,010 --> 00:11:04,650
something like this you can actually go

00:11:03,060 --> 00:11:06,900
and read the Apple docs and just start

00:11:04,650 --> 00:11:08,400
writing code directly as though you were

00:11:06,900 --> 00:11:10,320
writing Objective C and this is really

00:11:08,400 --> 00:11:15,180
powerful the result is something like

00:11:10,320 --> 00:11:17,820
that let's save a minute to talk about

00:11:15,180 --> 00:11:20,760
Windows because Windows is the most

00:11:17,820 --> 00:11:22,650
popular West in the world sadly if you

00:11:20,760 --> 00:11:24,960
are targeting Windows as we do there are

00:11:22,650 --> 00:11:28,500
a lot a lot a lot of AP is that you can

00:11:24,960 --> 00:11:30,660
use some are in C but many are object

00:11:28,500 --> 00:11:33,570
oriented using component object model or

00:11:30,660 --> 00:11:35,310
comm which if you're not familiar is a

00:11:33,570 --> 00:11:38,010
multi-language standard that lets you do

00:11:35,310 --> 00:11:40,320
object oriented api's it's generally

00:11:38,010 --> 00:11:41,850
used with c++ and it gives you access to

00:11:40,320 --> 00:11:43,410
things like the shell api so if there's

00:11:41,850 --> 00:11:44,700
any windows programmers out there this

00:11:43,410 --> 00:11:47,340
is how you like make shortcuts for

00:11:44,700 --> 00:11:49,620
example on the desktop now you could try

00:11:47,340 --> 00:11:51,330
to bind those using c types but this is

00:11:49,620 --> 00:11:54,500
so much more complex than calling a

00:11:51,330 --> 00:11:57,150
function it is very verbose don't try it

00:11:54,500 --> 00:12:00,780
we have we tried that very briefly and

00:11:57,150 --> 00:12:02,280
it did not go very well what is much

00:12:00,780 --> 00:12:04,500
better is to leverage the work done by

00:12:02,280 --> 00:12:06,260
experts and the legendary mark Hammond

00:12:04,500 --> 00:12:09,420
and PI 132 is something that we've

00:12:06,260 --> 00:12:11,730
personally loved this gives you really

00:12:09,420 --> 00:12:14,520
simple access to not only the C API is

00:12:11,730 --> 00:12:16,440
but also more complex comm a P is in

00:12:14,520 --> 00:12:19,170
Windows this API is almost twenty years

00:12:16,440 --> 00:12:21,930
old now this library it's actually on PI

00:12:19,170 --> 00:12:23,580
P I now which is great we actually use

00:12:21,930 --> 00:12:24,990
this to manage things like ECL so there

00:12:23,580 --> 00:12:26,400
are some struck for example and the

00:12:24,990 --> 00:12:28,770
windows API is that are very very

00:12:26,400 --> 00:12:30,510
complicated and this is just provides

00:12:28,770 --> 00:12:34,230
these nice pythonic wrappers around all

00:12:30,510 --> 00:12:36,420
that and this is just great now Windows

00:12:34,230 --> 00:12:38,520
being Windows there's always another new

00:12:36,420 --> 00:12:41,550
API lurking around the corner

00:12:38,520 --> 00:12:43,260
the newest windows API is coming from

00:12:41,550 --> 00:12:45,900
Windows 10 are based on something called

00:12:43,260 --> 00:12:47,490
WinRT or the windows runtime this is

00:12:45,900 --> 00:12:49,710
actually very similar to come but they

00:12:47,490 --> 00:12:51,540
added a whole bunch of enhancements

00:12:49,710 --> 00:12:54,510
comes almost 30 years old and so this is

00:12:51,540 --> 00:12:56,520
a much more modern replacement this set

00:12:54,510 --> 00:12:59,130
of API is includes things like core

00:12:56,520 --> 00:13:00,840
routines and asynchronous functions this

00:12:59,130 --> 00:13:02,400
is also where most of the new API is are

00:13:00,840 --> 00:13:04,620
being introduced by Microsoft so things

00:13:02,400 --> 00:13:06,830
like the machine learning API is when ml

00:13:04,620 --> 00:13:09,000
are actually only available through this

00:13:06,830 --> 00:13:10,470
this can be a bit challenging because

00:13:09,000 --> 00:13:12,510
there aren't really bindings there

00:13:10,470 --> 00:13:14,070
weren't until recently there's a brand

00:13:12,510 --> 00:13:15,990
new project out of Microsoft called X

00:13:14,070 --> 00:13:18,690
Lang that actually introduces Python

00:13:15,990 --> 00:13:20,100
bindings for WinRT highly recommend you

00:13:18,690 --> 00:13:20,370
check that out it's really impressive is

00:13:20,100 --> 00:13:22,350
very

00:13:20,370 --> 00:13:24,720
cool we're not using it yet but this

00:13:22,350 --> 00:13:27,029
actually also integrates with pythons

00:13:24,720 --> 00:13:28,410
async io proteins unless you call the

00:13:27,029 --> 00:13:31,560
all of these directly which is really

00:13:28,410 --> 00:13:34,140
really sweet so now that we've looked at

00:13:31,560 --> 00:13:36,779
how we would use api's let's dive into

00:13:34,140 --> 00:13:38,520
an example so that's probably the most

00:13:36,779 --> 00:13:40,110
common type of platform integration

00:13:38,520 --> 00:13:42,630
you'll want to do is to try to write a

00:13:40,110 --> 00:13:45,270
GUI so you'll want to write a user

00:13:42,630 --> 00:13:47,279
interface now this is because you know

00:13:45,270 --> 00:13:49,050
most of your apps or most of your tzer's

00:13:47,279 --> 00:13:50,279
aren't gonna integrate interact with

00:13:49,050 --> 00:13:51,600
your app the way a developer would

00:13:50,279 --> 00:13:53,820
they're gonna want some sort of visual

00:13:51,600 --> 00:13:56,010
interaction things like with buttons and

00:13:53,820 --> 00:13:57,750
windows and stuff like that this is

00:13:56,010 --> 00:13:59,910
actually a great example of a battery

00:13:57,750 --> 00:14:02,730
that isn't really included in Python

00:13:59,910 --> 00:14:07,290
there is tickle there's tkinter but that

00:14:02,730 --> 00:14:10,170
is kind of the exception so this is the

00:14:07,290 --> 00:14:11,730
Preferences window in Dropbox today it's

00:14:10,170 --> 00:14:13,110
actually all written in Python in fact

00:14:11,730 --> 00:14:17,310
it's all written in PI option this is

00:14:13,110 --> 00:14:19,620
the cocoa version so how do we go about

00:14:17,310 --> 00:14:22,200
building this and this comes this leads

00:14:19,620 --> 00:14:24,120
me to sort of the main key choice that

00:14:22,200 --> 00:14:26,220
we had to make which is what library do

00:14:24,120 --> 00:14:28,170
you pick and there's kind of two classes

00:14:26,220 --> 00:14:31,050
of UI libraries you might want to use

00:14:28,170 --> 00:14:34,110
there's the native ones so this is where

00:14:31,050 --> 00:14:36,480
you would use bindings to write or to

00:14:34,110 --> 00:14:38,040
directly use each platform's UI library

00:14:36,480 --> 00:14:42,089
so typically each OS is going to have

00:14:38,040 --> 00:14:43,529
its own UI library that is dominant your

00:14:42,089 --> 00:14:47,339
other option is to use a third-party

00:14:43,529 --> 00:14:49,770
library so you bind to that but then

00:14:47,339 --> 00:14:52,920
that library does the job of integrating

00:14:49,770 --> 00:14:54,900
with each OS as UI now the trade-off

00:14:52,920 --> 00:14:56,820
here is convenience versus control so

00:14:54,900 --> 00:14:58,290
third-party libraries are much more

00:14:56,820 --> 00:15:00,270
convenient because they almost always

00:14:58,290 --> 00:15:02,490
cover more than one platform so that

00:15:00,270 --> 00:15:04,730
means you can write your Python once and

00:15:02,490 --> 00:15:07,050
then it will work on more than one OS

00:15:04,730 --> 00:15:10,350
picking a native library however it

00:15:07,050 --> 00:15:12,510
gives you only that platform but it

00:15:10,350 --> 00:15:14,700
gives you much more camor control but

00:15:12,510 --> 00:15:16,920
what that means though is that if you if

00:15:14,700 --> 00:15:19,380
you use cocoa on win on Mac and then you

00:15:16,920 --> 00:15:23,190
use win32 on Windows you are gonna be

00:15:19,380 --> 00:15:25,950
writing it twice so what we actually

00:15:23,190 --> 00:15:29,790
decided to do is both which is a bit

00:15:25,950 --> 00:15:32,370
weird but bear with me so on Mac we use

00:15:29,790 --> 00:15:33,900
cocoa and we use PI objective-c so we

00:15:32,370 --> 00:15:36,030
use a native library on Mac and then

00:15:33,900 --> 00:15:38,250
Windows and Linux we actually use cute

00:15:36,030 --> 00:15:40,110
or cutie and then we use PI cutes

00:15:38,250 --> 00:15:43,140
bindings to do that so why don't we pick

00:15:40,110 --> 00:15:45,120
a third-party library for one OS and and

00:15:43,140 --> 00:15:47,700
a native library for the other in our

00:15:45,120 --> 00:15:49,710
cases because draw boxes UI is tiny or

00:15:47,700 --> 00:15:51,270
at least at the time it was we only have

00:15:49,710 --> 00:15:53,010
a little icon we have a couple of

00:15:51,270 --> 00:15:54,990
windows we don't have a lot we have

00:15:53,010 --> 00:15:57,150
basically a very small footprint and we

00:15:54,990 --> 00:15:59,100
wanted the the field to be very native

00:15:57,150 --> 00:16:00,690
on each platform we wanted people to

00:15:59,100 --> 00:16:03,780
feel like this was really a part of

00:16:00,690 --> 00:16:07,230
their of their OS and on Mac cocoa is by

00:16:03,780 --> 00:16:08,970
far the best but on Windows cute

00:16:07,230 --> 00:16:11,310
actually gave us the quality that we

00:16:08,970 --> 00:16:12,870
needed and so basically we were able to

00:16:11,310 --> 00:16:17,730
combine the two in a solution that was

00:16:12,870 --> 00:16:20,160
that was generally acceptable so to

00:16:17,730 --> 00:16:21,270
conclude this section I want to talk a

00:16:20,160 --> 00:16:24,810
little bit about what makes an app

00:16:21,270 --> 00:16:26,070
different from a script so the the sort

00:16:24,810 --> 00:16:27,630
of main point here is that an app is

00:16:26,070 --> 00:16:30,060
going to have a very different shape to

00:16:27,630 --> 00:16:32,040
a script first it's going to be

00:16:30,060 --> 00:16:34,950
long-lived whereas scripts tend to be

00:16:32,040 --> 00:16:36,300
shorter lived really you're apt and

00:16:34,950 --> 00:16:38,670
stick around as long as the user needs

00:16:36,300 --> 00:16:41,340
it they you know that can be arbitrarily

00:16:38,670 --> 00:16:42,390
long second you're going the shape of

00:16:41,340 --> 00:16:44,850
your app is going to be more reactive

00:16:42,390 --> 00:16:46,320
rather than proactive so for example

00:16:44,850 --> 00:16:48,630
you're gonna be spending a lot of time

00:16:46,320 --> 00:16:51,470
waiting for the user to do something so

00:16:48,630 --> 00:16:53,520
that you can do something in response

00:16:51,470 --> 00:16:54,840
with that usually means is that your

00:16:53,520 --> 00:16:56,250
your color your code is gonna be

00:16:54,840 --> 00:16:58,500
callback driven and so you're gonna

00:16:56,250 --> 00:17:00,510
you're gonna write callbacks in Python

00:16:58,500 --> 00:17:02,960
basically to do things once the UI tells

00:17:00,510 --> 00:17:05,160
you something happened and finally

00:17:02,960 --> 00:17:06,660
you're going to enter the world of

00:17:05,160 --> 00:17:08,370
threading and the reason for that is

00:17:06,660 --> 00:17:10,950
that in almost all UI frameworks the

00:17:08,370 --> 00:17:13,500
main thread is special it's there to

00:17:10,950 --> 00:17:14,730
deal with the users input and so

00:17:13,500 --> 00:17:16,740
generally that's going to mean doing

00:17:14,730 --> 00:17:18,810
work on on other threats so let's look

00:17:16,740 --> 00:17:22,680
at this visually because this is mostly

00:17:18,810 --> 00:17:25,380
just rambling so a script is a very

00:17:22,680 --> 00:17:27,830
simple straight line it kind of starts

00:17:25,380 --> 00:17:30,090
and it stops when its job is is done

00:17:27,830 --> 00:17:32,280
typically you give it input before you

00:17:30,090 --> 00:17:34,530
start and you receive the output after

00:17:32,280 --> 00:17:38,130
the script ends now an app is a bit

00:17:34,530 --> 00:17:39,660
different an app isn't gonna stop

00:17:38,130 --> 00:17:42,570
deterministically it's going to stop

00:17:39,660 --> 00:17:43,950
when the user is done with it so it

00:17:42,570 --> 00:17:45,300
might not terminate for a while so

00:17:43,950 --> 00:17:45,910
really the shape of your app is going to

00:17:45,300 --> 00:17:48,160
be

00:17:45,910 --> 00:17:49,630
a loop so the app will basically just

00:17:48,160 --> 00:17:53,350
keep repeating something over and over

00:17:49,630 --> 00:17:55,240
again and at every run of the loop it

00:17:53,350 --> 00:17:57,340
will process inputs from the user and

00:17:55,240 --> 00:17:59,470
produce outputs it will keep doing this

00:17:57,340 --> 00:18:01,930
over and over again and that's kind of

00:17:59,470 --> 00:18:03,280
the usual shape of an app now what that

00:18:01,930 --> 00:18:05,380
means though is that if while your main

00:18:03,280 --> 00:18:07,540
thread is busy doing this the actual

00:18:05,380 --> 00:18:09,460
work that you want your app to do is

00:18:07,540 --> 00:18:11,800
gonna happen on another thread or in

00:18:09,460 --> 00:18:13,140
some sort of background a system of some

00:18:11,800 --> 00:18:15,220
kind

00:18:13,140 --> 00:18:16,900
now we'll get back to threading a bit

00:18:15,220 --> 00:18:19,840
later but if you're not all of these

00:18:16,900 --> 00:18:21,490
gooey libraries typically have helpers

00:18:19,840 --> 00:18:26,200
to help you sort of manage threading in

00:18:21,490 --> 00:18:29,230
this way so let's recap every platform

00:18:26,200 --> 00:18:31,060
is different you are probably going to

00:18:29,230 --> 00:18:33,940
need to use some platform native API so

00:18:31,060 --> 00:18:35,710
if not a lot bindings are definitely not

00:18:33,940 --> 00:18:37,540
free there's some cost associated with

00:18:35,710 --> 00:18:39,220
each of them but there are off-the-shelf

00:18:37,540 --> 00:18:40,840
or open source solutions that can really

00:18:39,220 --> 00:18:43,300
really really reduce maintenance cost

00:18:40,840 --> 00:18:44,710
and finally well apps are not like

00:18:43,300 --> 00:18:51,450
scripts and you're probably going to be

00:18:44,710 --> 00:18:53,530
multi-threaded so now that we can

00:18:51,450 --> 00:18:56,350
integrate with a platform and now that

00:18:53,530 --> 00:18:57,700
we have a shape of an app your customer

00:18:56,350 --> 00:19:00,310
is still going to be the end user here

00:18:57,700 --> 00:19:02,650
so to obtain your app they're gonna need

00:19:00,310 --> 00:19:03,790
to be able to get it somehow and that

00:19:02,650 --> 00:19:05,440
means we're gonna need to package the

00:19:03,790 --> 00:19:08,400
app in a way that's easy for a user to

00:19:05,440 --> 00:19:10,720
get so how do we get into users hands

00:19:08,400 --> 00:19:12,820
before we get into that one quick detour

00:19:10,720 --> 00:19:14,680
so we talked about using third party

00:19:12,820 --> 00:19:16,690
bindings and I think we've demonstrated

00:19:14,680 --> 00:19:19,270
so far that like a pie pie is your

00:19:16,690 --> 00:19:20,470
friend there are tons of great packages

00:19:19,270 --> 00:19:24,340
out there that can help control costs

00:19:20,470 --> 00:19:26,830
but using third party code in this case

00:19:24,340 --> 00:19:28,540
means shipping it to and so it's really

00:19:26,830 --> 00:19:30,790
important to take precautions when you

00:19:28,540 --> 00:19:32,410
do that for example with licensing and

00:19:30,790 --> 00:19:34,690
user software is very different from

00:19:32,410 --> 00:19:39,400
cloud-based software in the licensing

00:19:34,690 --> 00:19:40,990
world so securely taking dependencies is

00:19:39,400 --> 00:19:42,550
actually really really important we have

00:19:40,990 --> 00:19:45,040
a whole process of Dropbox to deal with

00:19:42,550 --> 00:19:45,850
this what's one thing the important

00:19:45,040 --> 00:19:47,830
thing to remember with third-party

00:19:45,850 --> 00:19:50,860
depp's is that they become part of your

00:19:47,830 --> 00:19:52,240
app it is part of your code now so we

00:19:50,860 --> 00:19:54,310
came up with four rules that we apply

00:19:52,240 --> 00:19:57,370
when when we deal with these so first

00:19:54,310 --> 00:19:59,170
build everything yourself so don't trust

00:19:57,370 --> 00:19:59,460
binaries now this isn't a huge problem

00:19:59,170 --> 00:20:01,710
with

00:19:59,460 --> 00:20:04,110
Python because pythons interpreted but

00:20:01,710 --> 00:20:07,740
if you have a choice between a binary or

00:20:04,110 --> 00:20:09,360
a source code take the source code the

00:20:07,740 --> 00:20:10,770
reason for that is that the second rule

00:20:09,360 --> 00:20:12,360
which is you can audit that code so you

00:20:10,770 --> 00:20:15,059
can look at it and really see what it

00:20:12,360 --> 00:20:16,679
does you should really try to spend the

00:20:15,059 --> 00:20:20,399
time to assess the code you intend to

00:20:16,679 --> 00:20:21,779
use before you ship it third pin the

00:20:20,399 --> 00:20:23,730
versions of your dependencies and check

00:20:21,779 --> 00:20:25,320
the hashes this is really important to

00:20:23,730 --> 00:20:27,299
protect from remote breaches so if you

00:20:25,320 --> 00:20:30,330
don't do this it's very easy for you to

00:20:27,299 --> 00:20:31,649
make a new build one day realize that

00:20:30,330 --> 00:20:33,090
there's a new version of some dependency

00:20:31,649 --> 00:20:34,679
you're using but that but if that

00:20:33,090 --> 00:20:38,549
versions compromised now your app is

00:20:34,679 --> 00:20:39,899
compromised too and finally make sure to

00:20:38,549 --> 00:20:41,970
add to the licenses so you should really

00:20:39,899 --> 00:20:44,179
understand and accept the terms of all

00:20:41,970 --> 00:20:46,110
the licenses of the each package you use

00:20:44,179 --> 00:20:48,899
because if you're not careful that can

00:20:46,110 --> 00:20:52,140
be really bad so let's take a look at

00:20:48,899 --> 00:20:53,880
this is a very very small snippet of our

00:20:52,140 --> 00:20:56,010
requirements file draw box is actually a

00:20:53,880 --> 00:20:59,399
drop I thought package so it has a

00:20:56,010 --> 00:21:01,140
requirements txt this shows a couple of

00:20:59,399 --> 00:21:03,210
our dependencies and you'll notice the

00:21:01,140 --> 00:21:06,120
version selectors so we always fully

00:21:03,210 --> 00:21:07,620
select exactly which version we want and

00:21:06,120 --> 00:21:11,279
we also patch the house the hash

00:21:07,620 --> 00:21:12,840
parameter which prevents the the package

00:21:11,279 --> 00:21:15,480
from being randomly tampered with so if

00:21:12,840 --> 00:21:18,179
someone would were to somehow man in the

00:21:15,480 --> 00:21:20,309
middle between us and and pipe I and say

00:21:18,179 --> 00:21:22,679
oh no actually version you know 1 12 0

00:21:20,309 --> 00:21:28,500
of 6 is actually this then we would

00:21:22,679 --> 00:21:30,570
detect that we would fail so as another

00:21:28,500 --> 00:21:32,970
tip isolating your environment is a

00:21:30,570 --> 00:21:35,279
pretty good way of maintaining control

00:21:32,970 --> 00:21:36,539
so pip and even virtual and 4 great we

00:21:35,279 --> 00:21:38,820
actually have an internal tool we use to

00:21:36,539 --> 00:21:40,260
wrap virtual ends and this is good

00:21:38,820 --> 00:21:42,210
because it means all of your developers

00:21:40,260 --> 00:21:44,850
are gonna have a consistent view of all

00:21:42,210 --> 00:21:46,350
of your dependencies it's really

00:21:44,850 --> 00:21:50,159
important that everyone gets the same

00:21:46,350 --> 00:21:51,419
thing ok so how do you take all this

00:21:50,159 --> 00:21:53,669
first party code and all this third

00:21:51,419 --> 00:21:57,419
party code and you turn all that into an

00:21:53,669 --> 00:22:00,059
app now as a reminder each app format

00:21:57,419 --> 00:22:01,740
varies from one platform to the next so

00:22:00,059 --> 00:22:04,200
there are basically four things that you

00:22:01,740 --> 00:22:05,909
want one you want to build the sort of

00:22:04,200 --> 00:22:08,929
native entry point that on Windows

00:22:05,909 --> 00:22:11,190
that's a dot exe on Mac that's a dot app

00:22:08,929 --> 00:22:12,360
second you actually want to ship Python

00:22:11,190 --> 00:22:14,549
itself

00:22:12,360 --> 00:22:17,100
so that means by the Python DLL or the

00:22:14,549 --> 00:22:18,809
Python framework third you want to take

00:22:17,100 --> 00:22:21,750
all of your dot pies and turn those into

00:22:18,809 --> 00:22:23,070
py C's and finally you want to compile

00:22:21,750 --> 00:22:28,049
your Python extension so you want to

00:22:23,070 --> 00:22:30,660
make shared objects or or py DS this is

00:22:28,049 --> 00:22:33,450
a lot of work but thankfully there are

00:22:30,660 --> 00:22:35,070
solutions out there and the most common

00:22:33,450 --> 00:22:38,580
solution so these are what we've been

00:22:35,070 --> 00:22:40,740
calling the freezer libraries and these

00:22:38,580 --> 00:22:43,140
basically what they do is they turn your

00:22:40,740 --> 00:22:44,850
script into a platform-specific binary

00:22:43,140 --> 00:22:46,679
they do all of those four steps for you

00:22:44,850 --> 00:22:48,179
I think one of the most popular ones

00:22:46,679 --> 00:22:50,640
right now is PI installer it's

00:22:48,179 --> 00:22:53,610
cross-platform it's it's a it seems to

00:22:50,640 --> 00:22:54,990
be to have really caught on on Mac OS

00:22:53,610 --> 00:22:59,850
actually for many years we used PI to

00:22:54,990 --> 00:23:02,520
app also by the same authors biopsy one

00:22:59,850 --> 00:23:05,240
quick tip though some of these will give

00:23:02,520 --> 00:23:08,220
you the option not to ship Python itself

00:23:05,240 --> 00:23:10,290
that's actually a very bad idea so if

00:23:08,220 --> 00:23:12,090
you decide not to Shiv Python what that

00:23:10,290 --> 00:23:14,370
app will do is it'll try to use the

00:23:12,090 --> 00:23:15,809
system Python if there is one and that

00:23:14,370 --> 00:23:18,330
can be very dangerous because it means

00:23:15,809 --> 00:23:19,850
other packages can be available to your

00:23:18,330 --> 00:23:22,290
app and since Python is very dynamic

00:23:19,850 --> 00:23:24,120
those can actually tamper with how your

00:23:22,290 --> 00:23:26,820
app executes so it's really important to

00:23:24,120 --> 00:23:30,780
isolate and control your your your

00:23:26,820 --> 00:23:32,100
Python environment one other random

00:23:30,780 --> 00:23:34,169
thing while I'm at it which is you

00:23:32,100 --> 00:23:36,570
should also try to remove doc strings so

00:23:34,169 --> 00:23:40,530
by default if you I think if you pass an

00:23:36,570 --> 00:23:42,780
optimized command to compile when you

00:23:40,530 --> 00:23:45,059
make it pyc it will not remove doc

00:23:42,780 --> 00:23:47,040
strings so we obviously use docstrings

00:23:45,059 --> 00:23:49,710
internally to as a form of commenting

00:23:47,040 --> 00:23:51,660
and so you might want to actually remove

00:23:49,710 --> 00:23:53,790
those somehow as like a post commit

00:23:51,660 --> 00:23:55,799
because otherwise people can probably go

00:23:53,790 --> 00:23:57,510
find your py season read your call all

00:23:55,799 --> 00:24:01,919
of your comments which which could be

00:23:57,510 --> 00:24:03,299
bad unless you actually want them to

00:24:01,919 --> 00:24:05,970
reverse engineer your code which which

00:24:03,299 --> 00:24:07,530
is perfectly fine now a bit of

00:24:05,970 --> 00:24:09,419
foreshadowing freezers do have a little

00:24:07,530 --> 00:24:14,220
bit of or a few limitations and we'll

00:24:09,419 --> 00:24:15,600
get into those you know in a moment so

00:24:14,220 --> 00:24:18,000
once you have all of this it's time to

00:24:15,600 --> 00:24:19,410
distribute so I won't go into too much

00:24:18,000 --> 00:24:21,690
detail here because at this point it's

00:24:19,410 --> 00:24:23,550
not really Python specific it's like

00:24:21,690 --> 00:24:25,320
shipping any other app but but again

00:24:23,550 --> 00:24:26,010
this is going to be platform specific so

00:24:25,320 --> 00:24:28,440
it's going to be

00:24:26,010 --> 00:24:30,360
to each to each OS like on a Mac for

00:24:28,440 --> 00:24:32,429
example you can distribute directly so

00:24:30,360 --> 00:24:33,660
you can zip up the dot app and and just

00:24:32,429 --> 00:24:35,940
offer that and there's pretty good

00:24:33,660 --> 00:24:38,340
affordances in the OS to to install that

00:24:35,940 --> 00:24:40,080
you can also go through the App Store on

00:24:38,340 --> 00:24:41,820
Windows this sort of typical thing is to

00:24:40,080 --> 00:24:44,040
further bundle everything into an

00:24:41,820 --> 00:24:45,419
installer using MSI or some other

00:24:44,040 --> 00:24:47,669
technology like that there's also the

00:24:45,419 --> 00:24:50,280
Windows Store if you're daring and

00:24:47,669 --> 00:24:52,500
finally one quick tip so automatic

00:24:50,280 --> 00:24:55,340
updates are really great we use that

00:24:52,500 --> 00:24:57,870
very early on but being able to

00:24:55,340 --> 00:25:00,720
automatically deploy new updates to your

00:24:57,870 --> 00:25:02,250
users is really key when you're dealing

00:25:00,720 --> 00:25:04,230
with bugs you're dealing with crashes

00:25:02,250 --> 00:25:05,460
it's great to not to have to rely or

00:25:04,230 --> 00:25:07,440
Taffet or to have to make the user

00:25:05,460 --> 00:25:09,690
download an update and apply it to be

00:25:07,440 --> 00:25:11,480
able to fix their their install their

00:25:09,690 --> 00:25:13,350
installation and there are some great

00:25:11,480 --> 00:25:15,150
third-party tools on there like squirrel

00:25:13,350 --> 00:25:16,590
or sparkle that let you do that and

00:25:15,150 --> 00:25:19,230
those will work fine once you've package

00:25:16,590 --> 00:25:24,830
your app into or put your package all

00:25:19,230 --> 00:25:28,200
your Python into a native app so to

00:25:24,830 --> 00:25:29,820
recap the the packaging section so

00:25:28,200 --> 00:25:31,710
dependencies become part of your app

00:25:29,820 --> 00:25:33,360
that's that's kind of the first the

00:25:31,710 --> 00:25:35,400
first thing we found out really quickly

00:25:33,360 --> 00:25:37,679
second python itself should be a part of

00:25:35,400 --> 00:25:39,330
your app two freezers are great because

00:25:37,679 --> 00:25:41,370
they let you kind of automate this whole

00:25:39,330 --> 00:25:44,040
thing and finally distribution is going

00:25:41,370 --> 00:25:45,530
to be platform specific so while there

00:25:44,040 --> 00:25:47,730
are some tools that can help you there

00:25:45,530 --> 00:25:49,799
once you have once you've turned your

00:25:47,730 --> 00:25:50,970
Python code into a native app that's

00:25:49,799 --> 00:25:55,620
where you have to start looking at each

00:25:50,970 --> 00:25:57,390
platform a bit separately so let's talk

00:25:55,620 --> 00:26:00,690
about monitoring now so once you have

00:25:57,390 --> 00:26:02,790
real users using this thing that does

00:26:00,690 --> 00:26:04,679
not mean the job is done in fact some of

00:26:02,790 --> 00:26:07,169
the most interesting work happens once

00:26:04,679 --> 00:26:08,450
you have something out there so we'll

00:26:07,169 --> 00:26:11,190
start with something a bit obvious

00:26:08,450 --> 00:26:12,600
logging so logging is pretty important

00:26:11,190 --> 00:26:14,640
it's really the key to understanding how

00:26:12,600 --> 00:26:17,010
your apps actually behaving in the wild

00:26:14,640 --> 00:26:19,950
the logging module is the obvious choice

00:26:17,010 --> 00:26:21,780
here but there are many alternatives now

00:26:19,950 --> 00:26:23,850
apps one thing to remember though is

00:26:21,780 --> 00:26:26,040
that when you're actually dealing with

00:26:23,850 --> 00:26:27,870
an end-user application the apps don't

00:26:26,040 --> 00:26:29,429
generally have standard streams so

00:26:27,870 --> 00:26:32,040
standard out or standard air aren't

00:26:29,429 --> 00:26:33,929
generally readily available in fact on

00:26:32,040 --> 00:26:35,580
Windows if you try to print to those for

00:26:33,929 --> 00:26:39,150
too long you'll eventually crash because

00:26:35,580 --> 00:26:39,990
you'll run out of buffer space so in

00:26:39,150 --> 00:26:41,910
this case

00:26:39,990 --> 00:26:43,380
the thing that we suggest is to redirect

00:26:41,910 --> 00:26:45,690
those to a file somewhere that you can

00:26:43,380 --> 00:26:48,180
conveniently scoop up as part of like a

00:26:45,690 --> 00:26:50,550
bug report or something some platforms

00:26:48,180 --> 00:26:52,080
also have specialized logging so for

00:26:50,550 --> 00:26:53,760
example on Windows there's an output

00:26:52,080 --> 00:26:55,310
d-bots debug string function that lets

00:26:53,760 --> 00:26:57,810
you route these to a specialized

00:26:55,310 --> 00:27:00,150
debugger or the debugger inside Visual

00:26:57,810 --> 00:27:04,860
Studio on Mac there are api's you can

00:27:00,150 --> 00:27:06,090
use to target the console but in fact

00:27:04,860 --> 00:27:08,730
many freezers will actually do this

00:27:06,090 --> 00:27:10,490
streamer direction for you but this is

00:27:08,730 --> 00:27:14,730
something to keep in mind

00:27:10,490 --> 00:27:16,350
so also important is crashing so to an

00:27:14,730 --> 00:27:18,420
end-user a crash is not just to frost

00:27:16,350 --> 00:27:20,400
the frustrating experience it is also

00:27:18,420 --> 00:27:23,340
bad for your brand and negatively

00:27:20,400 --> 00:27:25,470
affects how people perceive your app now

00:27:23,340 --> 00:27:26,850
a fun misconception is that because

00:27:25,470 --> 00:27:29,550
you're using Python that means you can't

00:27:26,850 --> 00:27:31,590
crash that is definitely not true

00:27:29,550 --> 00:27:33,000
things like exceptions that bubble up

00:27:31,590 --> 00:27:35,310
all the way to the top of a thread for

00:27:33,000 --> 00:27:37,140
example can cause a crash there are also

00:27:35,310 --> 00:27:39,390
native crashes so you can actually have

00:27:37,140 --> 00:27:42,630
low level crashes in inside Python

00:27:39,390 --> 00:27:44,790
itself or inside extensions a common

00:27:42,630 --> 00:27:47,430
cause of these can be things like bugs

00:27:44,790 --> 00:27:49,770
and bindings which is something we

00:27:47,430 --> 00:27:51,600
discussed earlier now in our case you

00:27:49,770 --> 00:27:53,280
know not running is bad because it means

00:27:51,600 --> 00:27:55,080
your files aren't syncing and so and

00:27:53,280 --> 00:27:57,990
also with millions of installs there's

00:27:55,080 --> 00:27:59,190
no such thing as a rare bug so really

00:27:57,990 --> 00:28:01,350
shouldn't you should try not to rely on

00:27:59,190 --> 00:28:03,540
users reporting errors to you if you can

00:28:01,350 --> 00:28:06,660
set up automatic crash reporting that's

00:28:03,540 --> 00:28:08,250
really better now one of the best and

00:28:06,660 --> 00:28:10,620
simplest solutions for this is fault

00:28:08,250 --> 00:28:12,600
handler now this is now a part of a

00:28:10,620 --> 00:28:13,980
standard library which is great and what

00:28:12,600 --> 00:28:16,350
that lets you do is catch low-level

00:28:13,980 --> 00:28:19,260
signals what we did for a long time is

00:28:16,350 --> 00:28:21,360
we basically would intercept any kind of

00:28:19,260 --> 00:28:23,280
crashing signal we would collect as much

00:28:21,360 --> 00:28:25,200
information as we could and we would

00:28:23,280 --> 00:28:26,910
upload a tiny report to our server

00:28:25,200 --> 00:28:28,470
saying we crashed here's what we could

00:28:26,910 --> 00:28:30,870
find out and then we would use that to

00:28:28,470 --> 00:28:33,150
debug now over time you know fault

00:28:30,870 --> 00:28:35,300
handler wasn't quite enough he doesn't

00:28:33,150 --> 00:28:37,470
catch everything especially on windows

00:28:35,300 --> 00:28:40,800
because signals are kind of more of a

00:28:37,470 --> 00:28:42,480
UNIX thing and it turns out you can't

00:28:40,800 --> 00:28:44,490
really rely on a process that's in the

00:28:42,480 --> 00:28:48,810
process or like that's currently dying

00:28:44,490 --> 00:28:50,370
to really report reliably so what we

00:28:48,810 --> 00:28:51,840
actually do is we move to crash pad

00:28:50,370 --> 00:28:52,800
which is something that's a Google

00:28:51,840 --> 00:28:54,540
project that

00:28:52,800 --> 00:28:56,730
run separately so it's a little helper

00:28:54,540 --> 00:28:58,470
app that runs alongside yours and that's

00:28:56,730 --> 00:28:59,820
really much more reliable but there's a

00:28:58,470 --> 00:29:01,860
whole bunch of solutions out there

00:28:59,820 --> 00:29:03,780
things like PL crash reporter for

00:29:01,860 --> 00:29:06,120
example or there's also complete turnkey

00:29:03,780 --> 00:29:07,560
solutions like sentry that will do all

00:29:06,120 --> 00:29:10,110
of this basically for you including the

00:29:07,560 --> 00:29:11,520
reporting actually if you're curious

00:29:10,110 --> 00:29:12,720
about how we did crash bad there's

00:29:11,520 --> 00:29:14,640
something on our blog from a colleague

00:29:12,720 --> 00:29:16,860
of mine there's a really good blog post

00:29:14,640 --> 00:29:19,320
about that goes into how we symbolic

00:29:16,860 --> 00:29:20,670
eight Python stack traces so what's

00:29:19,320 --> 00:29:22,710
weird in our case is that we have a lot

00:29:20,670 --> 00:29:25,080
of Python code and then code from other

00:29:22,710 --> 00:29:27,300
languages so it's it's common to have a

00:29:25,080 --> 00:29:30,360
crashing stack trace that has a lot of

00:29:27,300 --> 00:29:31,710
PI eval exact frame EXO I believe which

00:29:30,360 --> 00:29:33,360
doesn't tell you a lot about what's

00:29:31,710 --> 00:29:35,810
happening and what we actually did is we

00:29:33,360 --> 00:29:38,370
built a system that lets us symbolic a

00:29:35,810 --> 00:29:40,650
Python stack frames in line so you can

00:29:38,370 --> 00:29:42,150
actually see the entire stack stack

00:29:40,650 --> 00:29:44,280
trace including the Python function

00:29:42,150 --> 00:29:45,750
calls so this is really cool and if

00:29:44,280 --> 00:29:49,920
you're curious about that check out the

00:29:45,750 --> 00:29:51,660
Dropbox tech blog so earlier we talked

00:29:49,920 --> 00:29:53,640
about how building a UI means entering

00:29:51,660 --> 00:29:55,680
the world of threading so let's get back

00:29:53,640 --> 00:29:57,180
to that for a moment so now that you're

00:29:55,680 --> 00:30:00,150
building an app that means you're gonna

00:29:57,180 --> 00:30:01,470
be front and center so your users are

00:30:00,150 --> 00:30:02,850
gonna be interacting with that thing and

00:30:01,470 --> 00:30:05,760
that means responsiveness is very

00:30:02,850 --> 00:30:07,920
important so your users might not all be

00:30:05,760 --> 00:30:09,630
running the sort of monster dev machine

00:30:07,920 --> 00:30:11,580
that you have and so you should really

00:30:09,630 --> 00:30:15,030
strive to make your app run as fast as

00:30:11,580 --> 00:30:16,350
possible on any device so let's go over

00:30:15,030 --> 00:30:17,640
a few tips and these are things that

00:30:16,350 --> 00:30:20,430
we've that we've learned over the years

00:30:17,640 --> 00:30:22,440
so first don't block the main thread and

00:30:20,430 --> 00:30:24,270
you may have heard this one before but

00:30:22,440 --> 00:30:26,700
as a reminder the main thread is there

00:30:24,270 --> 00:30:30,420
to respond to the users interactions

00:30:26,700 --> 00:30:32,160
with your app so once once it starts

00:30:30,420 --> 00:30:33,990
executing those Python callbacks it

00:30:32,160 --> 00:30:36,330
needs to be able to respond and get back

00:30:33,990 --> 00:30:39,120
to doing that as soon as possible so to

00:30:36,330 --> 00:30:41,880
maximize that try not to do any kind of

00:30:39,120 --> 00:30:44,610
sleeps or costly work in the main thread

00:30:41,880 --> 00:30:46,140
itself delegate basically anything that

00:30:44,610 --> 00:30:48,540
can take a while to a background thread

00:30:46,140 --> 00:30:50,250
or to somewhere else what's nice is that

00:30:48,540 --> 00:30:51,810
like I said most UI libraries actually

00:30:50,250 --> 00:30:56,340
include ways for you to do this really

00:30:51,810 --> 00:30:58,830
easily second try to avoid noisy

00:30:56,340 --> 00:31:00,570
callbacks so I mentioned that apps are

00:30:58,830 --> 00:31:03,720
callback driven now it's really tempting

00:31:00,570 --> 00:31:05,210
to register a lot of callbacks to give

00:31:03,720 --> 00:31:08,210
the user a lot of feedback

00:31:05,210 --> 00:31:09,920
now try to limit this though because or

00:31:08,210 --> 00:31:12,050
better yet use api's that don't require

00:31:09,920 --> 00:31:13,640
noisy callbacks and so you might want to

00:31:12,050 --> 00:31:16,100
ask yourself like how often you truly

00:31:13,640 --> 00:31:17,990
need to respond to user interaction a

00:31:16,100 --> 00:31:19,730
sort of extreme example is do you really

00:31:17,990 --> 00:31:22,450
need to know every time the user moves

00:31:19,730 --> 00:31:24,710
the mouse by a single pixel probably not

00:31:22,450 --> 00:31:27,860
and if you remove those your app will

00:31:24,710 --> 00:31:30,800
tend to be less sluggish tip number

00:31:27,860 --> 00:31:33,170
three so try to move CPU bound work

00:31:30,800 --> 00:31:37,280
outside of Python altogether so this

00:31:33,170 --> 00:31:39,140
one's really interesting because CPU

00:31:37,280 --> 00:31:41,960
intensive work is not kind of known to

00:31:39,140 --> 00:31:43,490
be very fast in Python that's why things

00:31:41,960 --> 00:31:45,740
like hash Lib for example actually

00:31:43,490 --> 00:31:47,180
implement the costly work in C and the

00:31:45,740 --> 00:31:48,470
nice thing about this is if you use

00:31:47,180 --> 00:31:50,690
another language it'll be a bit faster

00:31:48,470 --> 00:31:52,850
but more importantly you can actually

00:31:50,690 --> 00:31:55,580
drop the Gil or the global interpreter

00:31:52,850 --> 00:31:57,650
lock this is nice because this will

00:31:55,580 --> 00:31:59,720
actually prevent or where this will

00:31:57,650 --> 00:32:01,490
actually allow you to paralyze and use

00:31:59,720 --> 00:32:02,720
more of the cores on the device now if

00:32:01,490 --> 00:32:06,650
you're not familiar with a global lock

00:32:02,720 --> 00:32:09,080
it is a sort of feature of C Python that

00:32:06,650 --> 00:32:10,850
means that Python code from multiple

00:32:09,080 --> 00:32:13,640
threads can't actually execute in

00:32:10,850 --> 00:32:16,400
parallel in or at least truly in

00:32:13,640 --> 00:32:19,460
parallel but by but by actually taking

00:32:16,400 --> 00:32:21,560
CPU bound work and putting it in C or in

00:32:19,460 --> 00:32:24,260
another language and dropping the the

00:32:21,560 --> 00:32:25,670
Gil you can actually start to use

00:32:24,260 --> 00:32:27,710
multiple threads and so if you actually

00:32:25,670 --> 00:32:29,930
look at the Activity Monitor for draw

00:32:27,710 --> 00:32:32,510
box you'll notice that if you're sinking

00:32:29,930 --> 00:32:33,800
heavily we don't use 100% CPU use more

00:32:32,510 --> 00:32:35,450
like four or five hundred percent or

00:32:33,800 --> 00:32:37,340
something which is another problem but

00:32:35,450 --> 00:32:41,780
we are using all of your course which is

00:32:37,340 --> 00:32:46,010
good and tip for use Python 3 I think

00:32:41,780 --> 00:32:47,720
Rita will like me for this one so the

00:32:46,010 --> 00:32:49,760
main thread is callback driven right and

00:32:47,720 --> 00:32:52,160
it's written in Python so your callbacks

00:32:49,760 --> 00:32:54,740
are in Python and Python has a global

00:32:52,160 --> 00:32:58,010
interpreter lock so it's subject to a

00:32:54,740 --> 00:32:59,480
lock you might be thinking well max

00:32:58,010 --> 00:33:01,310
didn't you say we shouldn't block on the

00:32:59,480 --> 00:33:02,420
main thread and grabbing a lock is one

00:33:01,310 --> 00:33:04,310
such thing that could block the main

00:33:02,420 --> 00:33:07,430
thread well yes

00:33:04,310 --> 00:33:09,890
theoretically Python by its nature means

00:33:07,430 --> 00:33:12,920
that the main thread might be blocked on

00:33:09,890 --> 00:33:15,440
waiting to acquire the Gil itself and

00:33:12,920 --> 00:33:16,930
this is actually particularly bad in

00:33:15,440 --> 00:33:18,400
Python to the

00:33:16,930 --> 00:33:21,160
because Python three skill was rewritten

00:33:18,400 --> 00:33:22,690
and is much better but it's usually

00:33:21,160 --> 00:33:24,280
starts showing up when you have a lot of

00:33:22,690 --> 00:33:25,120
threads now this is unlikely to be a

00:33:24,280 --> 00:33:27,610
problem for you

00:33:25,120 --> 00:33:28,720
but we have a lot of threads now and so

00:33:27,610 --> 00:33:30,640
we kind of hit that problem really

00:33:28,720 --> 00:33:32,440
relatively quickly it's still actually

00:33:30,640 --> 00:33:34,750
technically possible in Python 3 but

00:33:32,440 --> 00:33:36,670
very very unlikely but the way we fixed

00:33:34,750 --> 00:33:39,010
that is we have a Python fork of C

00:33:36,670 --> 00:33:41,680
Python so we actually patch pythons Gil

00:33:39,010 --> 00:33:44,050
to always prefer the main thread if it's

00:33:41,680 --> 00:33:45,360
ever waiting and so that kind of solves

00:33:44,050 --> 00:33:48,940
that problem

00:33:45,360 --> 00:33:50,650
ok so let's recap monitoring shipping is

00:33:48,940 --> 00:33:52,480
just the beginning

00:33:50,650 --> 00:33:53,590
logging and crash reporting are great

00:33:52,480 --> 00:33:55,870
because they help you build confidence

00:33:53,590 --> 00:33:59,490
and finally responsiveness is really

00:33:55,870 --> 00:33:59,490
important and so you should invest in it

00:34:00,000 --> 00:34:05,350
ok now let's get to the the

00:34:02,530 --> 00:34:07,840
controversial part so over time your

00:34:05,350 --> 00:34:09,880
needs may start to change so in many

00:34:07,840 --> 00:34:13,270
areas we actually kind of we feel like

00:34:09,880 --> 00:34:14,770
we reach the limits of Python we either

00:34:13,270 --> 00:34:16,990
chose to use another programming

00:34:14,770 --> 00:34:19,030
language for some for some tasks or we

00:34:16,990 --> 00:34:21,160
were made to in some cases the platforms

00:34:19,030 --> 00:34:23,740
are very stringent and require you to do

00:34:21,160 --> 00:34:25,180
certain things using native code and

00:34:23,740 --> 00:34:27,220
that can lead to some pretty interesting

00:34:25,180 --> 00:34:32,350
changes that we made that I'll quickly

00:34:27,220 --> 00:34:33,730
touch upon so for example I just

00:34:32,350 --> 00:34:37,150
mentioned using C for performance

00:34:33,730 --> 00:34:39,370
reasons the nice part here is that you

00:34:37,150 --> 00:34:40,780
can actually use bindings here too so

00:34:39,370 --> 00:34:42,430
the only difference is that rather than

00:34:40,780 --> 00:34:46,060
target third party code you're targeting

00:34:42,430 --> 00:34:48,100
your own code so for example a Dropbox

00:34:46,060 --> 00:34:50,380
we're now increasingly using rusts for

00:34:48,100 --> 00:34:51,550
some of our components and there's a

00:34:50,380 --> 00:34:54,280
whole bunch of reasons why we really

00:34:51,550 --> 00:34:55,840
like it but the the sort of type safety

00:34:54,280 --> 00:34:59,290
that comes from that comes from that

00:34:55,840 --> 00:35:01,510
language is relatively popular but don't

00:34:59,290 --> 00:35:05,140
underestimate how this type of change

00:35:01,510 --> 00:35:07,150
and how this can add up so because draw

00:35:05,140 --> 00:35:09,610
box is a Python package so at first we

00:35:07,150 --> 00:35:11,470
relied on set of tools as our build

00:35:09,610 --> 00:35:14,260
system so we were basically have a set

00:35:11,470 --> 00:35:16,750
up pi and this is that also how freezer

00:35:14,260 --> 00:35:19,330
scripts actually work but the nor the

00:35:16,750 --> 00:35:21,310
more non Python code you introduce the

00:35:19,330 --> 00:35:22,690
harder this is gonna get you will

00:35:21,310 --> 00:35:24,550
eventually ask yourself the question

00:35:22,690 --> 00:35:27,580
like should everything be a Python

00:35:24,550 --> 00:35:31,080
extension can anything be a python

00:35:27,580 --> 00:35:33,580
extension and the answer is No

00:35:31,080 --> 00:35:35,530
actually there are some tools that very

00:35:33,580 --> 00:35:37,900
cleverly hack around this like milk

00:35:35,530 --> 00:35:40,150
snake which does this for rust actually

00:35:37,900 --> 00:35:42,520
but but in general this didn't really

00:35:40,150 --> 00:35:46,300
work out for us so in our case this

00:35:42,520 --> 00:35:48,340
wasn't quite enough we developed so many

00:35:46,300 --> 00:35:51,010
non platinum Python platform

00:35:48,340 --> 00:35:54,130
integrations like app extensions or

00:35:51,010 --> 00:35:56,410
kernel extensions on Mac that freezer

00:35:54,130 --> 00:35:58,780
tools as a reminder can only package

00:35:56,410 --> 00:36:00,610
Python code and extensions so it became

00:35:58,780 --> 00:36:05,530
really really hard to package the rest

00:36:00,610 --> 00:36:07,240
of this this stuff with the app and this

00:36:05,530 --> 00:36:09,070
added up so much and the platform's

00:36:07,240 --> 00:36:10,630
became so constraining if you do Mac

00:36:09,070 --> 00:36:12,910
development you'll see that Apple is

00:36:10,630 --> 00:36:15,580
quite a bit restrictive these days about

00:36:12,910 --> 00:36:17,590
what you can do we decided to flip that

00:36:15,580 --> 00:36:19,840
on his head so we actually stopped using

00:36:17,590 --> 00:36:23,740
freezers and we moved to embedding

00:36:19,840 --> 00:36:26,080
instead now what does this mean so in

00:36:23,740 --> 00:36:28,930
freezing remember you take a script and

00:36:26,080 --> 00:36:30,700
you turn it into an app in embedding you

00:36:28,930 --> 00:36:34,120
already have an app but you use the

00:36:30,700 --> 00:36:35,710
Python C API to run Python code really

00:36:34,120 --> 00:36:37,600
the only main difference this made was

00:36:35,710 --> 00:36:39,280
that we could stop using setup tools as

00:36:37,600 --> 00:36:42,760
our build system we now have another

00:36:39,280 --> 00:36:45,340
custom build system really this reflects

00:36:42,760 --> 00:36:47,230
the plurality of languages now now in

00:36:45,340 --> 00:36:48,970
our code base Python is no longer alone

00:36:47,230 --> 00:36:50,650
and it's no longer the dominant

00:36:48,970 --> 00:36:52,540
programming language even though it

00:36:50,650 --> 00:36:54,670
still drives the core of our of our

00:36:52,540 --> 00:36:55,800
desktop app this is definitely unique to

00:36:54,670 --> 00:36:59,140
Dropbox

00:36:55,800 --> 00:37:00,790
one last thing to talk about web

00:36:59,140 --> 00:37:03,220
technologies so you may have heard of

00:37:00,790 --> 00:37:06,370
electron it's relatively popular out

00:37:03,220 --> 00:37:08,080
there one of the issues that we've

00:37:06,370 --> 00:37:09,520
noticed is that well every platform is

00:37:08,080 --> 00:37:11,110
different and that can lead to code

00:37:09,520 --> 00:37:14,320
duplication right we made the choice

00:37:11,110 --> 00:37:15,880
back in the day to have a sort of Mac UI

00:37:14,320 --> 00:37:20,080
in a Windows UI and so that meant we had

00:37:15,880 --> 00:37:22,300
to write it twice eventually because we

00:37:20,080 --> 00:37:23,860
wanted to make more complex UI in fact

00:37:22,300 --> 00:37:25,600
we recently announced a new UI that's

00:37:23,860 --> 00:37:28,120
that's pretty it's like a full window

00:37:25,600 --> 00:37:29,680
it's a bit more complicated you might

00:37:28,120 --> 00:37:31,750
not be willing to pay the price of

00:37:29,680 --> 00:37:36,040
writing it twice it might be too much

00:37:31,750 --> 00:37:37,990
and meanwhile HTML and JavaScript have

00:37:36,040 --> 00:37:40,380
become very popular and very good at

00:37:37,990 --> 00:37:42,370
this actually in electrons popularity is

00:37:40,380 --> 00:37:43,040
generally well deserved the developer

00:37:42,370 --> 00:37:46,460
experiences

00:37:43,040 --> 00:37:50,150
good so we were building new complex UI

00:37:46,460 --> 00:37:52,880
the requirements changed so we decided

00:37:50,150 --> 00:37:56,450
to actually use HTML and JavaScript for

00:37:52,880 --> 00:37:57,500
that new draw box UI and the reason for

00:37:56,450 --> 00:38:00,230
that was that this thing was going to be

00:37:57,500 --> 00:38:01,910
complex enough the HTML was really

00:38:00,230 --> 00:38:03,370
well-suited for rich dynamics you

00:38:01,910 --> 00:38:05,270
dynamic UIs

00:38:03,370 --> 00:38:08,030
especially with react and things like

00:38:05,270 --> 00:38:10,880
that that that this really was going to

00:38:08,030 --> 00:38:12,410
simplify our lives now the good news is

00:38:10,880 --> 00:38:14,330
we don't actually use electron now the

00:38:12,410 --> 00:38:16,730
good news is that because we use QT that

00:38:14,330 --> 00:38:19,790
actually comes with a very good HTML

00:38:16,730 --> 00:38:21,860
renderer cue web engine on Mac we

00:38:19,790 --> 00:38:24,830
actually considered using the system's

00:38:21,860 --> 00:38:26,060
webviews WK webview but in the end this

00:38:24,830 --> 00:38:27,500
has some problems so we're actually

00:38:26,060 --> 00:38:30,080
using the chromium embedded framework

00:38:27,500 --> 00:38:32,900
there but basically the way this works

00:38:30,080 --> 00:38:34,490
is that the view and view models or the

00:38:32,900 --> 00:38:36,980
view and the controller layers if you're

00:38:34,490 --> 00:38:38,600
familiar with MVC are in typescript but

00:38:36,980 --> 00:38:40,490
then the model and most of the business

00:38:38,600 --> 00:38:42,620
logic remains in Python and what we did

00:38:40,490 --> 00:38:45,350
is we kind of made a custom bridge

00:38:42,620 --> 00:38:46,940
between the the model and the view model

00:38:45,350 --> 00:38:49,790
so we have a bridge between typescript

00:38:46,940 --> 00:38:52,220
and Python that is also my PI enabled by

00:38:49,790 --> 00:38:56,140
the way that that lets us kind of

00:38:52,220 --> 00:38:56,140
straddle the two worlds like that

00:38:56,470 --> 00:39:01,520
okay so let's recap the beyond Python

00:38:58,850 --> 00:39:03,110
sections so Python may not always be the

00:39:01,520 --> 00:39:05,080
best tool for the job you might be

00:39:03,110 --> 00:39:07,460
forced to use another tool for the job

00:39:05,080 --> 00:39:10,100
freezers are going to be limited to

00:39:07,460 --> 00:39:11,950
shipping Python code and you can you can

00:39:10,100 --> 00:39:13,880
enhance them but that has limits

00:39:11,950 --> 00:39:15,580
embedding is great because it gives you

00:39:13,880 --> 00:39:17,930
complete control over your app and

00:39:15,580 --> 00:39:19,280
finally your requirements will change so

00:39:17,930 --> 00:39:22,790
you have to be ready to adapt when that

00:39:19,280 --> 00:39:24,650
happens now I have a minute and so

00:39:22,790 --> 00:39:26,540
there's a bonus round of a few

00:39:24,650 --> 00:39:30,500
interesting things that I thought I'd

00:39:26,540 --> 00:39:32,030
mention really quickly so first we now

00:39:30,500 --> 00:39:33,530
have a very large team working on the

00:39:32,030 --> 00:39:36,080
desktop app when I started it was much

00:39:33,530 --> 00:39:37,070
smaller we are now I think more I don't

00:39:36,080 --> 00:39:39,860
actually know the exact number but it's

00:39:37,070 --> 00:39:41,090
a lot mating and maintaining a code base

00:39:39,860 --> 00:39:42,980
like that with a large team can get

00:39:41,090 --> 00:39:45,140
pretty challenging and so here's some of

00:39:42,980 --> 00:39:46,760
the things we did to make that just

00:39:45,140 --> 00:39:49,430
easier so first we have something we

00:39:46,760 --> 00:39:52,070
call it commit queue so rather than just

00:39:49,430 --> 00:39:54,020
accepting commits directly all commits

00:39:52,070 --> 00:39:55,930
are fully CI tested before landings

00:39:54,020 --> 00:39:57,580
pretty much like pull requests

00:39:55,930 --> 00:39:58,840
and that means that you can't land

00:39:57,580 --> 00:40:01,720
anything that actually breaks the build

00:39:58,840 --> 00:40:03,940
this has been a game changer for us

00:40:01,720 --> 00:40:06,220
second we actually support debugging

00:40:03,940 --> 00:40:08,050
directly using pi dev D so so in fact a

00:40:06,220 --> 00:40:10,150
lot of people use PI charm and vs code

00:40:08,050 --> 00:40:11,800
internally and you can debug the app

00:40:10,150 --> 00:40:13,540
directly from from that it's actually

00:40:11,800 --> 00:40:16,210
possible to fruit to debug an app even

00:40:13,540 --> 00:40:18,910
though python is is packaged in in a dot

00:40:16,210 --> 00:40:21,670
out for example we use my PI for static

00:40:18,910 --> 00:40:24,130
typing everywhere that is HUGE

00:40:21,670 --> 00:40:26,650
when you have a large code base we've

00:40:24,130 --> 00:40:27,940
now we're now at 60% plus coverage which

00:40:26,650 --> 00:40:29,920
is really nice

00:40:27,940 --> 00:40:32,470
and finally we actually built a custom

00:40:29,920 --> 00:40:34,480
linter easing asteroid to detect

00:40:32,470 --> 00:40:37,570
patterns of things we don't like and so

00:40:34,480 --> 00:40:38,800
we add rules lint rules overtime on top

00:40:37,570 --> 00:40:41,950
of things like flaky

00:40:38,800 --> 00:40:45,340
Pepe etc so these are some of the things

00:40:41,950 --> 00:40:47,410
we did to grow the team let's talk about

00:40:45,340 --> 00:40:49,780
Python 3 because I mentioned Python 2

00:40:47,410 --> 00:40:52,990
earlier we initially were a Python 2 5

00:40:49,780 --> 00:40:55,150
then a 2 7 app for the longest time the

00:40:52,990 --> 00:40:57,880
move to embedding rather than freezing

00:40:55,150 --> 00:41:00,340
actually is what helped us to migrate to

00:40:57,880 --> 00:41:02,020
Python 3 in a way we did that is we

00:41:00,340 --> 00:41:04,270
eventually moved to a hybrid syntax

00:41:02,020 --> 00:41:07,270
where we had both Python 2 and Python 3

00:41:04,270 --> 00:41:09,520
supported and we would selectively

00:41:07,270 --> 00:41:11,680
choose whether to run in Python 3 or in

00:41:09,520 --> 00:41:13,750
Python 2 at runtime and the only reason

00:41:11,680 --> 00:41:16,450
we were able to do that was because if

00:41:13,750 --> 00:41:18,250
you control using the Python C API you

00:41:16,450 --> 00:41:20,950
can actually link against both python 2

00:41:18,250 --> 00:41:23,080
and 3 and so we actually for a time we

00:41:20,950 --> 00:41:24,880
actually shift both python 2 and 3 in

00:41:23,080 --> 00:41:26,650
our app and then we would gradually

00:41:24,880 --> 00:41:28,780
migrate people over a kind of one by one

00:41:26,650 --> 00:41:32,680
and we're now running Python 37 and

00:41:28,780 --> 00:41:34,510
we're very happy so with that I think I

00:41:32,680 --> 00:41:36,010
have a few minutes left hopefully and so

00:41:34,510 --> 00:41:38,170
I think I think we'll take a few

00:41:36,010 --> 00:41:39,610
questions but I hope I didn't ramble on

00:41:38,170 --> 00:41:44,610
too much thank you very much for coming

00:41:39,610 --> 00:41:44,610
this was really fun and yeah thank you

00:41:44,710 --> 00:41:50,900
[Music]

00:41:48,350 --> 00:41:54,480
[Applause]

00:41:50,900 --> 00:41:56,220
yeah thank you very much it's time about

00:41:54,480 --> 00:41:58,790
two minutes time left for questions so

00:41:56,220 --> 00:41:58,790
are there any questions

00:42:02,609 --> 00:42:09,010
question about cute yeah I know a very

00:42:05,799 --> 00:42:12,700
very large code base so how did you make

00:42:09,010 --> 00:42:14,740
it first that it's low footprint as you

00:42:12,700 --> 00:42:19,359
said in the slide and second did you out

00:42:14,740 --> 00:42:20,920
it all all of the cuties code yes the

00:42:19,359 --> 00:42:24,190
the first question was how do we kind of

00:42:20,920 --> 00:42:27,220
limit cutes footprints we actually so we

00:42:24,190 --> 00:42:29,200
actually altered cutes built to only

00:42:27,220 --> 00:42:31,000
ship very specific components that we

00:42:29,200 --> 00:42:33,640
needed and so we found out that most of

00:42:31,000 --> 00:42:35,559
the most of the libraries in cute we

00:42:33,640 --> 00:42:36,670
don't we didn't actually need and so we

00:42:35,559 --> 00:42:38,710
actually stripped out I'd say like

00:42:36,670 --> 00:42:40,270
almost half of the queue libraries

00:42:38,710 --> 00:42:43,539
themselves although we do ship quite web

00:42:40,270 --> 00:42:45,760
engine which is quite large I think

00:42:43,539 --> 00:42:50,020
that's the second question was did we

00:42:45,760 --> 00:42:52,119
audit all of cutes code I I don't know

00:42:50,020 --> 00:42:54,819
if I can answer that question I I think

00:42:52,119 --> 00:42:59,230
we did we did do a complete review and

00:42:54,819 --> 00:43:01,539
we do we do effectively trust cute as a

00:42:59,230 --> 00:43:05,770
library but yes it is a lot of code but

00:43:01,539 --> 00:43:11,880
yeah we did look at it yeah okay another

00:43:05,770 --> 00:43:18,150
question since as a win32 package on Mac

00:43:11,880 --> 00:43:23,740
maybe it would be similar to UNMIK this

00:43:18,150 --> 00:43:27,970
mech the kind of native similar way like

00:43:23,740 --> 00:43:29,349
with C yeah I think I didn't I said I

00:43:27,970 --> 00:43:32,520
think the mic was dropping out so I

00:43:29,349 --> 00:43:32,520
didn't really hear most of your question

00:43:34,190 --> 00:43:46,790
[Music]

00:43:35,720 --> 00:43:47,810
Oh interesting so something do we just

00:43:46,790 --> 00:43:50,030
make sure I understand the question like

00:43:47,810 --> 00:43:59,390
do we see a third-party library similar

00:43:50,030 --> 00:44:01,579
to PI 132 for for Mac yeah so I don't

00:43:59,390 --> 00:44:04,520
think we have any plans to release our

00:44:01,579 --> 00:44:06,890
work there now although we did actually

00:44:04,520 --> 00:44:08,480
upstream many of our fixes to see Python

00:44:06,890 --> 00:44:11,450
over the years and so we did contribute

00:44:08,480 --> 00:44:13,640
those back to the community honestly the

00:44:11,450 --> 00:44:17,119
best the best tool for Mac is PI op

00:44:13,640 --> 00:44:18,859
sheet the the bindings to be able to

00:44:17,119 --> 00:44:21,130
call the objective-c API is on Mac OS

00:44:18,859 --> 00:44:23,690
are really the most of what you need

00:44:21,130 --> 00:44:27,050
because apples api's are generally very

00:44:23,690 --> 00:44:30,200
very rich and so so the the binding work

00:44:27,050 --> 00:44:32,180
there is generally quite good and Mac is

00:44:30,200 --> 00:44:34,310
it as an OS is a very uniform API so you

00:44:32,180 --> 00:44:36,950
don't you don't have like the multiple

00:44:34,310 --> 00:44:38,300
surface areas the Windows has so so on

00:44:36,950 --> 00:44:40,430
Mac I would definitely recommend PI up

00:44:38,300 --> 00:44:41,450
see yeah ok thank you very much we're

00:44:40,430 --> 00:44:42,770
out of time thank you

00:44:41,450 --> 00:44:43,120
let's have another round of applause for

00:44:42,770 --> 00:44:50,599
Mac's

00:44:43,120 --> 00:44:50,599

YouTube URL: https://www.youtube.com/watch?v=BS2_DrN0pw4


