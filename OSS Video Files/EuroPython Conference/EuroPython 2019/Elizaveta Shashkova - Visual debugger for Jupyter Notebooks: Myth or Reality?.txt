Title: Elizaveta Shashkova - Visual debugger for Jupyter Notebooks: Myth or Reality?
Publication date: 2019-09-03
Playlist: EuroPython 2019
Description: 
	"Visual debugger for Jupyter Notebooks: Myth or Reality?
[EuroPython 2019 - Talk - 2019-07-10 - MongoDB  [PyData track]
[Basel, CH]

By Elizaveta Shashkova

Many Python developers like Jupyter Notebooks for their flexibility: they are very useful for interactive prototyping, scientific experiments, visualizations and many other tasks. There are different development tools which make working with Jupyter Notebooks easier and smoother, but all of them lack very important feature: visual debugger. Since Jupyter Kernel is a usual Python process, it looks reasonably to use one of existing Python debuggers with it. But is it really possible? 

In this talk we’ll try to understand how Python debugger should be changed to work with Jupyter cells and how these changes are already implemented in the PyCharm IDE. After that we’ll look into the whole Jupyter architecture and try to understand which bottlenecks in it prevent creation of universal Jupyter debugger at the moment.  

This talk requires a basic knowledge of Jupyter Notebooks and understanding of Python functions and objects. It will be interesting for people who want to learn internals of the tools they use every day. Also it might be an inspiration for people who want to implement a visual debugger in their favourite IDE.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/
Captions: 
	00:00:02,830 --> 00:00:07,670
hello everyone my name is Elizabeth

00:00:05,720 --> 00:00:09,559
Ashish cava and today I want to tell

00:00:07,670 --> 00:00:12,520
about visual debugger for Jupiter

00:00:09,559 --> 00:00:15,980
notebooks first let me introduce myself

00:00:12,520 --> 00:00:18,980
I'm software developer at JetBrains I am

00:00:15,980 --> 00:00:21,380
working on the Python IDE and currently

00:00:18,980 --> 00:00:25,849
I'm focused on debugger and data science

00:00:21,380 --> 00:00:27,919
tools we always write code with bugs but

00:00:25,849 --> 00:00:30,919
productive developer is not developer

00:00:27,919 --> 00:00:33,440
who write code without box but developer

00:00:30,919 --> 00:00:36,230
who can quickly find and fix them and

00:00:33,440 --> 00:00:39,710
visual debugger is a tool which can help

00:00:36,230 --> 00:00:41,690
you to do it really efficiently we do

00:00:39,710 --> 00:00:44,300
debuggers for Python files exist in

00:00:41,690 --> 00:00:46,100
almost every idea nowadays but they

00:00:44,300 --> 00:00:48,620
usually can't work with Jupiter

00:00:46,100 --> 00:00:51,109
notebooks because Jupiter notebook

00:00:48,620 --> 00:00:53,750
doesn't contain only Python source code

00:00:51,109 --> 00:00:56,600
it's a sequence of cells with different

00:00:53,750 --> 00:00:59,449
types of content including Python source

00:00:56,600 --> 00:01:02,539
code and exactly like code in Python

00:00:59,449 --> 00:01:06,200
files code in Jupiter notebooks made

00:01:02,539 --> 00:01:07,910
content may contain bugs the most

00:01:06,200 --> 00:01:10,190
popular ways to find bugs in Jupiter

00:01:07,910 --> 00:01:12,980
notebooks nowadays are either print

00:01:10,190 --> 00:01:15,980
statements or common light by your IP TB

00:01:12,980 --> 00:01:19,280
to be honest but these ways are not very

00:01:15,980 --> 00:01:21,430
useful print statements requires a code

00:01:19,280 --> 00:01:24,770
modification inside yourself and

00:01:21,430 --> 00:01:27,860
rerunning call yourself to get

00:01:24,770 --> 00:01:30,350
additional information and IP TB

00:01:27,860 --> 00:01:33,140
debugger is based on built-in PDP

00:01:30,350 --> 00:01:35,870
debugger produces a lot of output during

00:01:33,140 --> 00:01:39,350
the Box session and requires remembering

00:01:35,870 --> 00:01:42,680
all these comments to evaluate some

00:01:39,350 --> 00:01:45,110
variable or to put breakpoint also there

00:01:42,680 --> 00:01:47,780
are some visual wrappers for IP DB like

00:01:45,110 --> 00:01:51,650
big city bugger for example but they all

00:01:47,780 --> 00:01:54,050
have the same limitation like IP DB for

00:01:51,650 --> 00:01:56,320
example you can't add report during

00:01:54,050 --> 00:01:59,750
program execution you need to wait for

00:01:56,320 --> 00:02:00,820
program to suspend and to ask you next

00:01:59,750 --> 00:02:04,340
comment

00:02:00,820 --> 00:02:06,620
the good news is you can see the whole

00:02:04,340 --> 00:02:09,470
Jupiter ecosystem legs very important to

00:02:06,620 --> 00:02:11,810
visual debugger and the good news is

00:02:09,470 --> 00:02:13,969
that recently visual debugger for

00:02:11,810 --> 00:02:15,680
Jupiter notebooks was implemented in the

00:02:13,969 --> 00:02:19,189
Python professional by

00:02:15,680 --> 00:02:22,099
he and today I'll try to explain how it

00:02:19,189 --> 00:02:25,400
was done so the answer from the for the

00:02:22,099 --> 00:02:27,349
question from the title is of course

00:02:25,400 --> 00:02:31,340
reality because otherwise my talk

00:02:27,349 --> 00:02:33,319
wouldn't exist and I've already said use

00:02:31,340 --> 00:02:36,230
of Python files and Jupiter notebooks

00:02:33,319 --> 00:02:39,430
have at least one thing in common both

00:02:36,230 --> 00:02:41,719
of them contain Python source code

00:02:39,430 --> 00:02:45,170
debuggers for Python already exist so

00:02:41,719 --> 00:02:47,450
let's learn how they work and which part

00:02:45,170 --> 00:02:50,780
we can reuse to build our Jupiter

00:02:47,450 --> 00:02:53,930
debugger the most patent buyers are

00:02:50,780 --> 00:02:55,669
based on built-in tracing function which

00:02:53,930 --> 00:02:59,090
allows you to Minotaur program execution

00:02:55,669 --> 00:03:01,250
so you can define your custom tracing

00:02:59,090 --> 00:03:05,480
function pass it to set trace function

00:03:01,250 --> 00:03:08,269
in C's module and it will report you all

00:03:05,480 --> 00:03:10,639
the events happening in your program as

00:03:08,269 --> 00:03:14,090
you can see tracing function takes three

00:03:10,639 --> 00:03:16,730
arguments frame event and arc frame is

00:03:14,090 --> 00:03:19,819
an object which contains information of

00:03:16,730 --> 00:03:21,949
the current place in the program event

00:03:19,819 --> 00:03:25,970
is event which happened in this place

00:03:21,949 --> 00:03:26,569
and arc is an argument of this event we

00:03:25,970 --> 00:03:28,280
defined

00:03:26,569 --> 00:03:30,709
simple tracing function which prints

00:03:28,280 --> 00:03:33,680
line number and event which happened on

00:03:30,709 --> 00:03:36,799
this one line number and let's check how

00:03:33,680 --> 00:03:38,780
it works on a simple example simple

00:03:36,799 --> 00:03:43,250
function greet neighbors which sends

00:03:38,780 --> 00:03:45,769
greetings to our neighbors on the first

00:03:43,250 --> 00:03:48,489
line when we call our function the event

00:03:45,769 --> 00:03:49,909
call arrives on the first line because

00:03:48,489 --> 00:03:52,629
Python called

00:03:49,909 --> 00:03:55,609
these function grid neighbors then

00:03:52,629 --> 00:03:58,549
finally execute the second line so the

00:03:55,609 --> 00:04:01,909
event line arrives on the second line

00:03:58,549 --> 00:04:03,919
then interpreter executes lines three

00:04:01,909 --> 00:04:08,659
and four and we receiving the following

00:04:03,919 --> 00:04:11,180
events and output hi Mars appears after

00:04:08,659 --> 00:04:13,849
that during the second loop iteration

00:04:11,180 --> 00:04:18,590
pass and execute lines three and four

00:04:13,849 --> 00:04:23,000
again and an event hi Venus appears in

00:04:18,590 --> 00:04:25,430
output and after that we are returning

00:04:23,000 --> 00:04:28,240
from function so we're executing Python

00:04:25,430 --> 00:04:32,410
execute line five

00:04:28,240 --> 00:04:36,550
event line and events return appears in

00:04:32,410 --> 00:04:38,230
on the line five okay how can we use

00:04:36,550 --> 00:04:41,080
this tracing function to implement

00:04:38,230 --> 00:04:43,150
breakpoints in our debugger on each

00:04:41,080 --> 00:04:45,669
program event tracing function receives

00:04:43,150 --> 00:04:48,220
it receives a frame object which

00:04:45,669 --> 00:04:50,680
contains not only line numbers like

00:04:48,220 --> 00:04:53,200
we've seen in our example but also a

00:04:50,680 --> 00:04:56,350
file name of the current code which is

00:04:53,200 --> 00:04:59,320
stored in code object breakpoint also

00:04:56,350 --> 00:05:03,850
has a file name and a line where user

00:04:59,320 --> 00:05:06,070
put it so on each call we can compare

00:05:03,850 --> 00:05:08,470
breakpoints file name with frames file

00:05:06,070 --> 00:05:12,160
name Brit points line number with frames

00:05:08,470 --> 00:05:15,090
live number and if this values equal we

00:05:12,160 --> 00:05:18,910
can suspend our program in this place

00:05:15,090 --> 00:05:22,960
cool so this is how python debuggers

00:05:18,910 --> 00:05:26,229
work and how we can use tracing function

00:05:22,960 --> 00:05:28,300
to implement break points but execution

00:05:26,229 --> 00:05:31,479
of python code in jupiter notebook files

00:05:28,300 --> 00:05:34,900
differs from usual Python files using

00:05:31,479 --> 00:05:37,360
pattern files and in the next part let's

00:05:34,900 --> 00:05:39,640
learn how to Peter execute Python code

00:05:37,360 --> 00:05:42,490
and what we should change in existing

00:05:39,640 --> 00:05:46,530
Python debugger to implement Jupiter

00:05:42,490 --> 00:05:49,240
breakpoints red points in Jupiter files

00:05:46,530 --> 00:05:51,789
you browse your Jupiter notebook in a

00:05:49,240 --> 00:05:54,490
front-end for example to support Jupiter

00:05:51,789 --> 00:05:56,889
notebooks in Python we implemented our

00:05:54,490 --> 00:05:59,410
custom front-end which works similarly

00:05:56,889 --> 00:06:00,970
to the default one so when you run the

00:05:59,410 --> 00:06:02,979
first cell in your notebook

00:06:00,970 --> 00:06:05,770
it starts and I pass internal and

00:06:02,979 --> 00:06:08,260
establishes connection to it i person

00:06:05,770 --> 00:06:11,410
kernel is in fact Python process which

00:06:08,260 --> 00:06:15,580
works similarly to the idle so it's

00:06:11,410 --> 00:06:18,639
running in a loop and waits for the next

00:06:15,580 --> 00:06:21,010
comment to be executed so when you

00:06:18,639 --> 00:06:23,710
execute yourself front-end sends its

00:06:21,010 --> 00:06:25,810
source code ipython Colonel I pass and

00:06:23,710 --> 00:06:29,260
colonel compiles it to our code object

00:06:25,810 --> 00:06:33,039
execute it and sense result back to

00:06:29,260 --> 00:06:35,740
Jupiter notebook the most interesting

00:06:33,039 --> 00:06:38,470
part for us here is how kernel executes

00:06:35,740 --> 00:06:40,820
this code for every cell execution

00:06:38,470 --> 00:06:43,610
colonel generates an unique name

00:06:40,820 --> 00:06:46,880
for every sub for every cell and passes

00:06:43,610 --> 00:06:49,640
this name as a file name.for generated

00:06:46,880 --> 00:06:52,850
code object usually kernel hides this

00:06:49,640 --> 00:06:55,130
information from users and but it stores

00:06:52,850 --> 00:06:58,130
all this generated code object in its

00:06:55,130 --> 00:07:01,730
internals that's why when you define

00:06:58,130 --> 00:07:04,340
some function in the first cell executed

00:07:01,730 --> 00:07:06,620
it after that you can call this function

00:07:04,340 --> 00:07:10,910
in another cell because I pass and

00:07:06,620 --> 00:07:13,010
kernel saved it for you to implement

00:07:10,910 --> 00:07:15,560
breakpoints in usual puzzle files we can

00:07:13,010 --> 00:07:17,840
use pair file named line number to

00:07:15,560 --> 00:07:20,300
define a place in a source code because

00:07:17,840 --> 00:07:23,480
this payer unique landed identifies a

00:07:20,300 --> 00:07:27,050
location over point or some source code

00:07:23,480 --> 00:07:29,480
position but in Jupiter notebooks it

00:07:27,050 --> 00:07:31,520
doesn't work because each cell is a

00:07:29,480 --> 00:07:34,460
separate code snippet with its own line

00:07:31,520 --> 00:07:37,580
numbers inside and all cells allocated

00:07:34,460 --> 00:07:41,290
in the same file so we can't reduce this

00:07:37,580 --> 00:07:44,120
the same pair for Jupiter breakpoints

00:07:41,290 --> 00:07:45,680
but we already know that I pass on

00:07:44,120 --> 00:07:48,010
kernel generates all the necessary

00:07:45,680 --> 00:07:50,600
information during cell execution

00:07:48,010 --> 00:07:54,560
executed cell has a generated file name

00:07:50,600 --> 00:07:57,110
and it is in internal line numbers so we

00:07:54,560 --> 00:08:02,030
can use this pair to define a unique

00:07:57,110 --> 00:08:03,920
location of our code great but the

00:08:02,030 --> 00:08:06,320
problem is that this generated

00:08:03,920 --> 00:08:09,710
information is available only in iPad

00:08:06,320 --> 00:08:11,780
kernel and not in our ID and when

00:08:09,710 --> 00:08:14,180
debugger sends some message to the IDE

00:08:11,780 --> 00:08:17,510
in about for example debugger suspension

00:08:14,180 --> 00:08:20,330
I'm suspended in some place this message

00:08:17,510 --> 00:08:22,340
contains generated file name but IDE

00:08:20,330 --> 00:08:25,130
doesn't know which cell is suspended

00:08:22,340 --> 00:08:27,680
because can't find its source code it

00:08:25,130 --> 00:08:32,120
was generated in on ipython kernel site

00:08:27,680 --> 00:08:34,729
in the IDE we can introduce some cell

00:08:32,120 --> 00:08:37,550
identifiers for example to find their

00:08:34,729 --> 00:08:39,680
locations in the editor but we still

00:08:37,550 --> 00:08:43,010
need to find a source mapping between

00:08:39,680 --> 00:08:47,060
these two objects cell identifier in the

00:08:43,010 --> 00:08:48,800
editor and generated file name I spent a

00:08:47,060 --> 00:08:52,040
lot of time trying to understand how to

00:08:48,800 --> 00:08:54,410
implement it and solution appeared to be

00:08:52,040 --> 00:08:58,180
quite simple there are two

00:08:54,410 --> 00:09:00,860
which helped during an implementation

00:08:58,180 --> 00:09:03,740
firstly in the IDE as I've already said

00:09:00,860 --> 00:09:05,960
we have a custom jupiter front-end that

00:09:03,740 --> 00:09:08,420
means that we can control all sales

00:09:05,960 --> 00:09:11,150
execution inside our jupiter notebook

00:09:08,420 --> 00:09:12,950
that means that for example we can drag

00:09:11,150 --> 00:09:15,740
all the cells which were executed during

00:09:12,950 --> 00:09:19,580
the session or send some additional

00:09:15,740 --> 00:09:22,070
comments the second thing was which

00:09:19,580 --> 00:09:24,800
helped to implement it was a silent cell

00:09:22,070 --> 00:09:28,100
cell execution supported in in jupiter

00:09:24,800 --> 00:09:30,920
that means that when you can execute

00:09:28,100 --> 00:09:32,930
some code in a silent mode so it will be

00:09:30,920 --> 00:09:35,600
executed in the context of the iPass

00:09:32,930 --> 00:09:38,270
internal but it won't be added to by

00:09:35,600 --> 00:09:41,480
passing out to colonel history and it

00:09:38,270 --> 00:09:44,210
won't increase execution counter how did

00:09:41,480 --> 00:09:47,990
we use it to support to support source

00:09:44,210 --> 00:09:50,300
mapping now before sending a real cell

00:09:47,990 --> 00:09:54,230
code we can send several youtube

00:09:50,300 --> 00:09:56,390
comments in a silent mode for example we

00:09:54,230 --> 00:09:59,450
can send resent a comment which purchase

00:09:56,390 --> 00:10:01,850
function for name generation and saves

00:09:59,450 --> 00:10:05,120
currently generated name to debugger

00:10:01,850 --> 00:10:07,490
instance also we can sign up the sent

00:10:05,120 --> 00:10:11,540
information about currently executed

00:10:07,490 --> 00:10:14,570
cell ID and save this value to debugger

00:10:11,540 --> 00:10:17,180
instance as well that means that one

00:10:14,570 --> 00:10:18,980
cell is started to execute we already

00:10:17,180 --> 00:10:21,410
know all the necessary information about

00:10:18,980 --> 00:10:25,340
mapping because it's saved in our

00:10:21,410 --> 00:10:27,550
debugger instance and inside our jupiter

00:10:25,340 --> 00:10:30,320
tracing function we can do the following

00:10:27,550 --> 00:10:33,740
when execution is suspended inside a

00:10:30,320 --> 00:10:35,810
coat with some generated name we can map

00:10:33,740 --> 00:10:37,820
this generated name to the cell

00:10:35,810 --> 00:10:40,430
identifier which is stored in our

00:10:37,820 --> 00:10:43,280
debugger instance and then send a

00:10:40,430 --> 00:10:45,080
message to the ID side and now this

00:10:43,280 --> 00:10:48,170
message doesn't contain a generated name

00:10:45,080 --> 00:10:52,150
but it contains a cell identifier in the

00:10:48,170 --> 00:10:55,790
editor and after that the ID can quickly

00:10:52,150 --> 00:10:58,990
find the cell its source code in the

00:10:55,790 --> 00:11:02,180
editor and highlight a suspended line

00:10:58,990 --> 00:11:05,060
that's how Jupiter breakpoints were

00:11:02,180 --> 00:11:06,550
implemented now we know how I pass

00:11:05,060 --> 00:11:10,360
internal works

00:11:06,550 --> 00:11:13,750
and how we can define source mapping for

00:11:10,360 --> 00:11:16,510
Jupiter breakpoints but we still have

00:11:13,750 --> 00:11:19,150
two separate entities the ID and I

00:11:16,510 --> 00:11:23,230
passing the ipython kernel and they

00:11:19,150 --> 00:11:25,630
should be able to communicate somehow as

00:11:23,230 --> 00:11:27,310
I already said we have an ID instance

00:11:25,630 --> 00:11:30,010
with its custom jupiter front-end

00:11:27,310 --> 00:11:32,560
implemented there and i pass an kernel

00:11:30,010 --> 00:11:35,080
which executes our comments but for the

00:11:32,560 --> 00:11:39,280
bugger it isn't enough to send just a

00:11:35,080 --> 00:11:41,440
source code for execution or some

00:11:39,280 --> 00:11:43,180
comments in silent mode we also need to

00:11:41,440 --> 00:11:46,780
send a lot of little information

00:11:43,180 --> 00:11:49,960
something like user added breakpoint in

00:11:46,780 --> 00:11:52,420
cell number 3 line number 2 or when

00:11:49,960 --> 00:11:55,090
debugger is suspended it should be able

00:11:52,420 --> 00:11:59,650
to send a message like I'm suspended in

00:11:55,090 --> 00:12:00,910
some place in the cell that means that

00:11:59,650 --> 00:12:03,640
debugger needs some additional

00:12:00,910 --> 00:12:07,240
communication channel with ipython

00:12:03,640 --> 00:12:09,250
kernel when I started to think about it

00:12:07,240 --> 00:12:11,890
I realized that there are two possible

00:12:09,250 --> 00:12:14,200
solutions for this problem the first one

00:12:11,890 --> 00:12:17,680
is to establish an additional connection

00:12:14,200 --> 00:12:20,290
to I pass and kernel and the second one

00:12:17,680 --> 00:12:24,280
is to reuse existing Jupiter channels

00:12:20,290 --> 00:12:26,050
the first one is the simplest one and

00:12:24,280 --> 00:12:30,460
it's the first thing that came to my

00:12:26,050 --> 00:12:32,380
mind but it has some limitations and the

00:12:30,460 --> 00:12:35,350
reason of these limitations is in

00:12:32,380 --> 00:12:37,300
Jupiter architecture this is more

00:12:35,350 --> 00:12:39,940
detailed scheme of Jupiter communication

00:12:37,300 --> 00:12:43,000
model this is a front end when front-end

00:12:39,940 --> 00:12:46,180
contains two I pass internal it doesn't

00:12:43,000 --> 00:12:48,580
connect directly it connects via kernel

00:12:46,180 --> 00:12:51,940
proxy which connects two I pass and

00:12:48,580 --> 00:12:54,850
kernel via WebSockets and if we want to

00:12:51,940 --> 00:12:57,010
avoid Jupiter messaging architecture we

00:12:54,850 --> 00:12:59,500
can establish only one dark socket

00:12:57,010 --> 00:13:01,540
connection to I path internal and of

00:12:59,500 --> 00:13:03,730
course it isn't always possible for

00:13:01,540 --> 00:13:07,060
example if your kernel is located far

00:13:03,730 --> 00:13:10,780
far away in some cloud you can't connect

00:13:07,060 --> 00:13:12,430
to it without proxy so the solution with

00:13:10,780 --> 00:13:14,800
additional connection is currently

00:13:12,430 --> 00:13:16,930
implemented in by charm professional but

00:13:14,800 --> 00:13:19,789
it works only if you can establish a

00:13:16,930 --> 00:13:22,619
direct connection to I bison kernel

00:13:19,789 --> 00:13:25,709
but to Peter college it have a rich

00:13:22,619 --> 00:13:29,489
messaging architecture maybe we can try

00:13:25,709 --> 00:13:32,729
to use it yes my present Colonel has

00:13:29,489 --> 00:13:36,059
five sockets here I shown three the most

00:13:32,729 --> 00:13:39,539
important of them which sends cells for

00:13:36,059 --> 00:13:43,289
execution sends output back to front end

00:13:39,539 --> 00:13:46,169
and requests user input it would be

00:13:43,289 --> 00:13:48,689
possible possible to reuse some of them

00:13:46,169 --> 00:13:52,439
in our debugger but there is another

00:13:48,689 --> 00:13:55,049
serious limitation in Jupiter I present

00:13:52,439 --> 00:13:57,029
Colonel runs a tornado event loop in the

00:13:55,049 --> 00:13:59,699
main thread which processes execution

00:13:57,029 --> 00:14:02,879
events also there is a second event loop

00:13:59,699 --> 00:14:06,029
in a separate thread which processes

00:14:02,879 --> 00:14:09,749
output comments each of this event loops

00:14:06,029 --> 00:14:12,419
is a single threaded that means that if

00:14:09,749 --> 00:14:15,089
some comments started to execute event

00:14:12,419 --> 00:14:17,220
loop is busy and the following comments

00:14:15,089 --> 00:14:20,069
will be executed only when execution is

00:14:17,220 --> 00:14:22,409
finished and the following messages with

00:14:20,069 --> 00:14:24,269
some the park information which will

00:14:22,409 --> 00:14:27,509
sense there the same channel will be

00:14:24,269 --> 00:14:29,850
blocked but the problem is that debug

00:14:27,509 --> 00:14:32,639
information should be sent exactly

00:14:29,850 --> 00:14:35,299
during cell execution it's useless

00:14:32,639 --> 00:14:37,799
when execution is already finished that

00:14:35,299 --> 00:14:39,989
means that in the current Jupiter

00:14:37,799 --> 00:14:42,539
architecture is impossible to reuse

00:14:39,989 --> 00:14:46,409
existing channels for sending debug

00:14:42,539 --> 00:14:49,439
information but wait everybody knows

00:14:46,409 --> 00:14:51,600
that IP DB works for both local and

00:14:49,439 --> 00:14:55,829
remote cases and it doesn't require any

00:14:51,600 --> 00:14:57,899
connection how does it do it if you

00:14:55,829 --> 00:15:01,109
remember of workflow with I PDB a

00:14:57,899 --> 00:15:04,109
debugger you understand how it works to

00:15:01,109 --> 00:15:08,879
go IPTV debugger inside your jupiter

00:15:04,109 --> 00:15:11,279
notebook you need to add a call to set

00:15:08,879 --> 00:15:13,919
res final set trace function inside

00:15:11,279 --> 00:15:17,220
yourself and after that debugger starts

00:15:13,919 --> 00:15:19,470
a suspense and asks you for sample for

00:15:17,220 --> 00:15:22,589
some comment you type some comment

00:15:19,470 --> 00:15:25,889
debugger receives it does some actions

00:15:22,589 --> 00:15:28,679
and us asks you for the next comment you

00:15:25,889 --> 00:15:33,250
type it again debugger receives it and

00:15:28,679 --> 00:15:36,460
so on and so on so an IP DB

00:15:33,250 --> 00:15:39,460
debug session is in fact as is in fact a

00:15:36,460 --> 00:15:43,410
sequence of request reply comments which

00:15:39,460 --> 00:15:46,630
colonel sends to front end and back and

00:15:43,410 --> 00:15:52,210
it works so because it's based on

00:15:46,630 --> 00:15:54,400
built-in input function and it can reuse

00:15:52,210 --> 00:15:56,560
an existing input channel because its

00:15:54,400 --> 00:15:59,500
input function for sending the back

00:15:56,560 --> 00:16:02,350
comments it works but it has some

00:15:59,500 --> 00:16:04,540
limitations for example if you started

00:16:02,350 --> 00:16:06,910
to execute some long-running sell at a

00:16:04,540 --> 00:16:08,950
debugger and realized that you forgot to

00:16:06,910 --> 00:16:11,770
put break points and breakpoint in some

00:16:08,950 --> 00:16:14,260
important place you have no chance to do

00:16:11,770 --> 00:16:17,470
it with IP DB you need to wait for

00:16:14,260 --> 00:16:19,420
programs to suspend and ask you for the

00:16:17,470 --> 00:16:21,520
next comment and only after that you can

00:16:19,420 --> 00:16:24,490
add your breakpoint or execute some

00:16:21,520 --> 00:16:26,980
stepping comment it's okay for common

00:16:24,490 --> 00:16:28,600
light debugger but we can't reuse the

00:16:26,980 --> 00:16:31,480
same technique in our visual debugger

00:16:28,600 --> 00:16:33,430
because in our visual debugger we want

00:16:31,480 --> 00:16:35,980
to have an ability to put breakpoint

00:16:33,430 --> 00:16:39,970
even when the bog debugger is running

00:16:35,980 --> 00:16:43,260
and to make program suspend in this

00:16:39,970 --> 00:16:45,600
place where we edit this breakpoint

00:16:43,260 --> 00:16:48,760
that's why in the current implementation

00:16:45,600 --> 00:16:51,100
in Python professional I decided to

00:16:48,760 --> 00:16:53,140
establish an additional connection and

00:16:51,100 --> 00:16:58,090
send all the buck util comments

00:16:53,140 --> 00:17:00,400
separately from Jupiter channels well in

00:16:58,090 --> 00:17:02,730
this part we've learned how a period

00:17:00,400 --> 00:17:06,069
debugger sends his little comments and

00:17:02,730 --> 00:17:11,199
why it was implemented this way also

00:17:06,069 --> 00:17:14,680
we've learned how i p DB works inside so

00:17:11,199 --> 00:17:17,140
it looks like now our visual debugger is

00:17:14,680 --> 00:17:20,170
ready let me remember you how we built

00:17:17,140 --> 00:17:23,100
it today firstly we define a tracing

00:17:20,170 --> 00:17:27,100
function which can work with code

00:17:23,100 --> 00:17:29,770
generated by i passing colonel secondly

00:17:27,100 --> 00:17:33,160
we created a mapping between editor and

00:17:29,770 --> 00:17:36,780
generated code for cells we used silent

00:17:33,160 --> 00:17:40,630
cell execution to implement it and

00:17:36,780 --> 00:17:42,310
features of our custom front-end and

00:17:40,630 --> 00:17:44,710
after that we establish the debugger

00:17:42,310 --> 00:17:47,410
connection for sending comments from the

00:17:44,710 --> 00:17:50,920
ide side to eye to eye pass and kernel

00:17:47,410 --> 00:17:53,830
and back so today we've learned how to

00:17:50,920 --> 00:17:57,340
peter visual debugger is implemented and

00:17:53,830 --> 00:17:59,440
that means that is time for the most

00:17:57,340 --> 00:18:02,740
entertaining part for you and the most

00:17:59,440 --> 00:18:05,070
horrifying part for me a live demo in

00:18:02,740 --> 00:18:05,070
fighter

00:18:19,510 --> 00:18:28,860
here it is yeah can you see everything

00:18:24,330 --> 00:18:32,110
well this is Jupiter notebook in Python

00:18:28,860 --> 00:18:35,169
you can see cells are allocated on the

00:18:32,110 --> 00:18:38,980
left side and Jupiter notebook preview

00:18:35,169 --> 00:18:42,250
is located on the right side you can

00:18:38,980 --> 00:18:44,230
work with cells as if they are located

00:18:42,250 --> 00:18:47,679
in one pass on file

00:18:44,230 --> 00:18:51,190
and it's important thing to notice that

00:18:47,679 --> 00:18:54,190
we don't convert Jupiter notebook to a

00:18:51,190 --> 00:18:56,110
Python file it is still the real I in

00:18:54,190 --> 00:18:58,299
Jupiter notebook with I pine Bay

00:18:56,110 --> 00:19:01,179
extension which is located in your

00:18:58,299 --> 00:19:04,480
project on the disk we just show our

00:19:01,179 --> 00:19:11,370
custom presentation so you can work with

00:19:04,480 --> 00:19:11,370
it like it is in one big Python file and

00:19:12,480 --> 00:19:18,970
you can use both features of Python

00:19:16,480 --> 00:19:21,730
editor usual white Python editor in

00:19:18,970 --> 00:19:24,929
Python and features of Jupiter notebooks

00:19:21,730 --> 00:19:28,919
for example when you type code you can

00:19:24,929 --> 00:19:32,500
use the same code completion which works

00:19:28,919 --> 00:19:34,389
or for example here we have some

00:19:32,500 --> 00:19:36,880
function you can quickly navigate to

00:19:34,389 --> 00:19:40,570
function declaration auto any variable

00:19:36,880 --> 00:19:43,240
declaration and even it even if this

00:19:40,570 --> 00:19:46,200
declaration was in other cell pycharm

00:19:43,240 --> 00:19:49,299
will navigate you to the correct place

00:19:46,200 --> 00:19:53,380
but also you can use features of Python

00:19:49,299 --> 00:19:55,299
so for example you can run cell and you

00:19:53,380 --> 00:19:58,179
can see it was executed and output

00:19:55,299 --> 00:20:00,429
appeared here in the notebook and it's

00:19:58,179 --> 00:20:03,279
stored in Jupiter notebook so it works

00:20:00,429 --> 00:20:05,710
exactly like your default front end for

00:20:03,279 --> 00:20:11,019
Jupiter notebooks also there are many

00:20:05,710 --> 00:20:14,710
other actions for example in the Python

00:20:11,019 --> 00:20:18,100
2013 don't - it will be available to run

00:20:14,710 --> 00:20:21,700
all cells in your notebook or start

00:20:18,100 --> 00:20:25,240
kernel on all clean outputs and do a lot

00:20:21,700 --> 00:20:28,110
of other things well but we came here to

00:20:25,240 --> 00:20:32,139
check that our visual debugger works

00:20:28,110 --> 00:20:32,900
let's put breakpoint here we put it here

00:20:32,139 --> 00:20:37,430
on the second

00:20:32,900 --> 00:20:39,800
and run the box'll debugger is suspended

00:20:37,430 --> 00:20:43,220
as you remember we defined a tracing

00:20:39,800 --> 00:20:46,070
function it established source mapping

00:20:43,220 --> 00:20:49,700
between editor and Carol and then sent

00:20:46,070 --> 00:20:52,790
comment to our editor and we found a

00:20:49,700 --> 00:20:55,370
place where it should be suspended you

00:20:52,790 --> 00:20:59,510
can see variable values here you can

00:20:55,370 --> 00:21:02,960
expand them check their values and for

00:20:59,510 --> 00:21:07,400
example resume programming great simple

00:21:02,960 --> 00:21:08,810
breakpoints work let's look the next

00:21:07,400 --> 00:21:11,630
cell

00:21:08,810 --> 00:21:13,550
this is grid neighbor's function which

00:21:11,630 --> 00:21:16,580
we've already seen today when we

00:21:13,550 --> 00:21:17,210
discussed tracing functions let's put a

00:21:16,580 --> 00:21:20,960
breakpoint here

00:21:17,210 --> 00:21:22,790
and debug this cell as well during the

00:21:20,960 --> 00:21:26,060
talk I had time to discuss on the

00:21:22,790 --> 00:21:28,640
breakpoints but the very important part

00:21:26,060 --> 00:21:31,580
of every debugger is stepping comments

00:21:28,640 --> 00:21:35,440
and they were implemented in Python

00:21:31,580 --> 00:21:38,990
let's try check that is here in words I

00:21:35,440 --> 00:21:41,420
can press here step into and debugger

00:21:38,990 --> 00:21:44,830
steps into a function declaration in

00:21:41,420 --> 00:21:47,690
this cell here we can also execute

00:21:44,830 --> 00:21:51,920
stepping comments you can see its values

00:21:47,690 --> 00:21:54,830
it changes and after that we can go step

00:21:51,920 --> 00:21:58,040
again and continue our stepping comments

00:21:54,830 --> 00:22:02,720
in the cell in the cell where it was

00:21:58,040 --> 00:22:05,660
executed great so stepping in the

00:22:02,720 --> 00:22:09,260
current cell works quite fine let's

00:22:05,660 --> 00:22:11,660
consider a more complicated code sample

00:22:09,260 --> 00:22:15,950
there is a lot of code but it's quite

00:22:11,660 --> 00:22:18,920
simple we have a list of planets and we

00:22:15,950 --> 00:22:22,370
iterate over these planets print its

00:22:18,920 --> 00:22:24,470
name for each planets search for its

00:22:22,370 --> 00:22:27,740
neighbors the left one and the right one

00:22:24,470 --> 00:22:30,890
if they exist and call the same grid

00:22:27,740 --> 00:22:33,620
neighbors function after that and sleep

00:22:30,890 --> 00:22:40,540
for two seconds because we like city

00:22:33,620 --> 00:22:40,540
well let's execute our cell and debugger

00:22:40,570 --> 00:22:44,170
okay

00:22:41,920 --> 00:22:46,600
execution is started you can see output

00:22:44,170 --> 00:22:50,230
appears but I forgot to put breakpoint

00:22:46,600 --> 00:22:52,480
here let's add breakpoint and yeah we

00:22:50,230 --> 00:22:56,080
added breakpoint and debugger suspended

00:22:52,480 --> 00:22:58,390
exactly inside our cell this is the

00:22:56,080 --> 00:23:01,240
thing that isn't possible currently in

00:22:58,390 --> 00:23:03,700
IPTV you you can't add break point but

00:23:01,240 --> 00:23:09,730
in pycharm with our visual debugger we

00:23:03,700 --> 00:23:12,670
can do it we also can iterate here for

00:23:09,730 --> 00:23:16,960
example we can check where we stopped we

00:23:12,670 --> 00:23:20,200
can select this planets II evaluate this

00:23:16,960 --> 00:23:24,670
expression and we're stopped in Jupiter

00:23:20,200 --> 00:23:27,430
planet great also we can execute step

00:23:24,670 --> 00:23:29,860
into again where we call in grid

00:23:27,430 --> 00:23:33,160
neighbor's function and we navigate it

00:23:29,860 --> 00:23:37,810
to the correct place where function was

00:23:33,160 --> 00:23:42,480
defined even it was defined in other

00:23:37,810 --> 00:23:46,720
cell okay we can resume our execution

00:23:42,480 --> 00:23:49,960
remove breakpoint great we are checked

00:23:46,720 --> 00:23:53,560
neighbors for Jupiter but I would like

00:23:49,960 --> 00:23:55,540
to learn what neighbors for arañas and I

00:23:53,560 --> 00:23:58,270
don't want to do a lot of stepping

00:23:55,540 --> 00:24:01,000
stepping commons and press with you many

00:23:58,270 --> 00:24:05,140
many times for that I can put breakpoint

00:24:01,000 --> 00:24:11,730
and then I can set condition for my

00:24:05,140 --> 00:24:14,260
breakpoint so I can select this one

00:24:11,730 --> 00:24:18,060
suspend my program

00:24:14,260 --> 00:24:22,960
if only the name of the planet is Ronis

00:24:18,060 --> 00:24:27,160
okay and start our debugging session

00:24:22,960 --> 00:24:28,560
again that's just hi this let's start

00:24:27,160 --> 00:24:32,190
our debug session

00:24:28,560 --> 00:24:35,650
let's check output starting to appear

00:24:32,190 --> 00:24:42,250
but we are waiting for our condition to

00:24:35,650 --> 00:24:44,260
work it's okay we're suspended were

00:24:42,250 --> 00:24:47,080
suspended in let's check we are

00:24:44,260 --> 00:24:49,300
suspended in the correct place the

00:24:47,080 --> 00:24:51,640
current planet name is era knows yeah so

00:24:49,300 --> 00:24:55,550
that means that condition for our

00:24:51,640 --> 00:24:59,950
breakpoint is really worked and we can

00:24:55,550 --> 00:25:03,890
check the name of neighbors 4runners

00:24:59,950 --> 00:25:05,020
neighbors our Saturn and Neptune that's

00:25:03,890 --> 00:25:10,070
correct

00:25:05,020 --> 00:25:14,870
great we can add breakpoints even during

00:25:10,070 --> 00:25:18,340
the back session if you do a lot of some

00:25:14,870 --> 00:25:21,770
data science work and you might do a lot

00:25:18,340 --> 00:25:25,340
when you work with Jupiter notebooks you

00:25:21,770 --> 00:25:28,730
might work a lot with numpy and race or

00:25:25,340 --> 00:25:30,740
pandas data series and you know it's

00:25:28,730 --> 00:25:33,920
quite it's sometimes it's quite

00:25:30,740 --> 00:25:37,580
difficult to check values in this data

00:25:33,920 --> 00:25:40,790
sense erase you can press here in your

00:25:37,580 --> 00:25:44,270
variable here and it will be opened in a

00:25:40,790 --> 00:25:47,510
beautiful window as a table and you can

00:25:44,270 --> 00:25:54,350
work inspect its values type some slices

00:25:47,510 --> 00:25:57,440
and do anything you want for your with

00:25:54,350 --> 00:25:59,450
your code okay so we've checked that

00:25:57,440 --> 00:26:02,330
visual debugger for Jupiter notebooks

00:25:59,450 --> 00:26:07,840
really works I didn't cheat you during

00:26:02,330 --> 00:26:12,500
my talk that's excellent news and then

00:26:07,840 --> 00:26:16,370
let's go back okay do you might talk

00:26:12,500 --> 00:26:19,460
today we learned how to build a visual

00:26:16,370 --> 00:26:22,850
debugger for Jupiter notebooks and that

00:26:19,460 --> 00:26:24,680
means that now after my talk you can

00:26:22,850 --> 00:26:27,650
implement visual debugger for Jupiter

00:26:24,680 --> 00:26:31,370
notebooks in your favorite IDE if it's

00:26:27,650 --> 00:26:33,800
for some reasons not Python and if it is

00:26:31,370 --> 00:26:38,090
by term I've already implemented it for

00:26:33,800 --> 00:26:41,060
you so you can try it right now thank

00:26:38,090 --> 00:26:43,260
you very much for coming to my talk now

00:26:41,060 --> 00:26:54,589
I'm ready to answer to your questions

00:26:43,260 --> 00:26:54,589
[Applause]

00:26:56,610 --> 00:27:01,800
thanks for the tote I've got one

00:26:59,310 --> 00:27:03,720
question when you register a set trace

00:27:01,800 --> 00:27:07,260
function yeah the program is running

00:27:03,720 --> 00:27:11,330
slower is the program running slower

00:27:07,260 --> 00:27:11,330
when you have this a trace function

00:27:15,440 --> 00:27:20,490
you're the burghers based on the set

00:27:17,820 --> 00:27:23,490
trace yes a trace function which does a

00:27:20,490 --> 00:27:26,160
lot of things when it is activated the

00:27:23,490 --> 00:27:29,180
program runs slower it's activated when

00:27:26,160 --> 00:27:32,730
you passed your function to a set trace

00:27:29,180 --> 00:27:36,750
it's activated in the next frame which

00:27:32,730 --> 00:27:43,200
was called so in this as you can see in

00:27:36,750 --> 00:27:50,040
this example where was it here it is so

00:27:43,200 --> 00:27:53,430
you can see we set this for the it will

00:27:50,040 --> 00:27:56,790
be applied to the next frame which will

00:27:53,430 --> 00:27:59,040
be executed so here we're calling next

00:27:56,790 --> 00:28:03,300
function grid neighbors so we're

00:27:59,040 --> 00:28:06,330
entering the next frame and it is

00:28:03,300 --> 00:28:08,880
activated in this function yeah and it

00:28:06,330 --> 00:28:15,150
should return tracing function should

00:28:08,880 --> 00:28:18,990
return it's ok here it is

00:28:15,150 --> 00:28:22,050
it should return tracing function in the

00:28:18,990 --> 00:28:25,520
current frame or it could return none

00:28:22,050 --> 00:28:28,560
and the tracing will be stopped okay and

00:28:25,520 --> 00:28:31,920
is it possible to unregister

00:28:28,560 --> 00:28:34,470
the trace function so they revert effect

00:28:31,920 --> 00:28:38,040
of all right yeah yeah yeah you should

00:28:34,470 --> 00:28:40,650
you should call CC trace known and so

00:28:38,040 --> 00:28:43,140
that's when you push on the play button

00:28:40,650 --> 00:28:45,110
that's what it does something similar

00:28:43,140 --> 00:28:50,660
yeah yeah if you don't have the

00:28:45,110 --> 00:28:50,660
breakpoints maybe okay thanks thank you

00:28:51,620 --> 00:28:56,570
I have another question for you to

00:28:54,110 --> 00:28:59,809
connect to the kernel to add a new

00:28:56,570 --> 00:29:02,630
connection yeah did you had to modify

00:28:59,809 --> 00:29:05,390
the kernel to build a custom kernel or

00:29:02,630 --> 00:29:07,430
is it done in the set rest function no

00:29:05,390 --> 00:29:10,700
no it's only set erase function we're

00:29:07,430 --> 00:29:15,530
connecting we're silently executing this

00:29:10,700 --> 00:29:17,540
comment which connects to our debugger

00:29:15,530 --> 00:29:20,390
yeah and we are storing the debugger

00:29:17,540 --> 00:29:23,000
instance in science journal so it

00:29:20,390 --> 00:29:25,640
doesn't modify kernel when we're just

00:29:23,000 --> 00:29:27,950
setting this tracing function and you

00:29:25,640 --> 00:29:32,179
have an idea of the performance impact

00:29:27,950 --> 00:29:34,130
of this function yeah it's as usual for

00:29:32,179 --> 00:29:36,559
debuggers of course it makes your

00:29:34,130 --> 00:29:38,800
program execution a bit slower and

00:29:36,559 --> 00:29:42,020
sometimes much slower if you have some

00:29:38,800 --> 00:29:44,420
very a lot of computations yeah but I

00:29:42,020 --> 00:29:46,610
think it's anyway it's faster than to

00:29:44,420 --> 00:29:49,550
add print statements and rerun your cell

00:29:46,610 --> 00:29:54,470
many many times so on average it's

00:29:49,550 --> 00:29:57,190
slower but you usually you even don't

00:29:54,470 --> 00:29:57,190
notice it

00:30:05,570 --> 00:30:09,450
more questions thank you very much for

00:30:08,880 --> 00:30:11,820
coming

00:30:09,450 --> 00:30:14,160
you can always finally add the pycharm

00:30:11,820 --> 00:30:16,560
booth during the whole conference so

00:30:14,160 --> 00:30:18,510
feel free to come and asks me any

00:30:16,560 --> 00:30:21,990
questions about my talk about by charm

00:30:18,510 --> 00:30:27,099
or about anything you want thank you

00:30:21,990 --> 00:30:27,099

YouTube URL: https://www.youtube.com/watch?v=XHNSYfkKnOQ


