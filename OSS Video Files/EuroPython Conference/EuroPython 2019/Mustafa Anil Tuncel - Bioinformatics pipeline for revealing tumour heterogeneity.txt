Title: Mustafa Anil Tuncel - Bioinformatics pipeline for revealing tumour heterogeneity
Publication date: 2019-09-03
Playlist: EuroPython 2019
Description: 
	"Bioinformatics pipeline for revealing tumour heterogeneity
[EuroPython 2019 - Talk - 2019-07-10 - Singapore [PyData track]
[Basel, CH]

By Mustafa Anil Tuncel

Reproducibility of research is a common issue in science, especially in computationally expensive research fields e.g. cancer research.
A comprehensive picture of the genomic aberrations that occur during tumour progression and the resulting intra-tumour heterogeneity, is essential for personalised and precise cancer therapies. With the change in the tumour environment under treatment, heterogeneity allows the tumour additional ways to evolve resistance, such that intra-tumour genomic diversity is a cause of relapse and treatment failure.  Earlier bulk sequencing technologies were incapable of determining the diversity in the tumour. br /
Single-cell DNA sequencing - a recent sequencing technology - offers resolution down to the level of individual cells and is playing an increasingly important role in this field. 
We present a reproducible and scalable Python data analysis pipeline that employs a statistical model and an MCMC algorithm to infer the evolutionary history of copy number alterations of a tumour from single cells. The pipeline is built using Python, Conda environment management system and the Snakemake workflow management system. The pipeline starts from the raw sequencing files and a settings file for parameter configurations. After running the data analysis, pipeline produces report and figures to inform the treatment decision of the cancer patient.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:03,770 --> 00:00:08,460
thank you very much

00:00:06,240 --> 00:00:10,620
saya this talk is about the

00:00:08,460 --> 00:00:14,839
bioinformatics pipeline we are due

00:00:10,620 --> 00:00:18,990
looking at ETH Zurich and yeah here is a

00:00:14,839 --> 00:00:20,939
just introduction so here's just some

00:00:18,990 --> 00:00:24,330
research interests that I have so we are

00:00:20,939 --> 00:00:28,380
working on data analysis pipelines and

00:00:24,330 --> 00:00:33,560
bioinformatics my machine learning also

00:00:28,380 --> 00:00:33,560
we are developing some new methods to

00:00:33,710 --> 00:00:39,440
explain certain biological data sets and

00:00:37,110 --> 00:00:43,289
previously I had some work with

00:00:39,440 --> 00:00:45,600
recommender systems so that's also one

00:00:43,289 --> 00:00:48,410
of my research interests here I have

00:00:45,600 --> 00:00:52,890
yeah here let's get up LinkedIn Twitter

00:00:48,410 --> 00:00:55,379
information there and the outline of

00:00:52,890 --> 00:00:57,930
this talk is so I will first introduce

00:00:55,379 --> 00:01:01,530
the problem I will give you some basic

00:00:57,930 --> 00:01:04,800
biological information later I will talk

00:01:01,530 --> 00:01:09,170
about it so called DNA mutation tree so

00:01:04,800 --> 00:01:11,850
there are our model for for representing

00:01:09,170 --> 00:01:14,310
mutations on the DNA and then I will

00:01:11,850 --> 00:01:16,770
talk about the pipeline and

00:01:14,310 --> 00:01:22,980
bioinformatics stuff that we are doing

00:01:16,770 --> 00:01:25,740
to address the cancer research and yeah

00:01:22,980 --> 00:01:28,020
so I'll start with the biology

00:01:25,740 --> 00:01:30,120
background I'm not a biologist so my

00:01:28,020 --> 00:01:32,940
both my masters and bachelor's were in

00:01:30,120 --> 00:01:35,520
computer science so don't worry I can't

00:01:32,940 --> 00:01:39,750
go into much detail when it comes to

00:01:35,520 --> 00:01:45,540
biology so we are working on cancer

00:01:39,750 --> 00:01:48,870
research and so the the data we have so

00:01:45,540 --> 00:01:50,550
is coming from some Hospital some

00:01:48,870 --> 00:01:52,560
patients go there get their tissue

00:01:50,550 --> 00:01:55,980
sequenced and then we're analyzing it

00:01:52,560 --> 00:01:58,950
and providing a a report to the

00:01:55,980 --> 00:02:03,480
clinician to base his treatment decision

00:01:58,950 --> 00:02:06,480
and the previous so they let me explain

00:02:03,480 --> 00:02:11,460
what a cell is so cell is the smallest

00:02:06,480 --> 00:02:13,500
living thing in the human body and when

00:02:11,460 --> 00:02:16,110
cells come together they form tissues

00:02:13,500 --> 00:02:18,330
like a muscle tissue it is consisting

00:02:16,110 --> 00:02:20,520
of different muscle cells and then the

00:02:18,330 --> 00:02:23,400
tissues come together to represent the

00:02:20,520 --> 00:02:27,390
organ organs become systems and systems

00:02:23,400 --> 00:02:30,330
become the organism that's the high

00:02:27,390 --> 00:02:33,540
school biology information that is

00:02:30,330 --> 00:02:36,240
required for this talk so the previous

00:02:33,540 --> 00:02:38,760
technologies so then when we want to

00:02:36,240 --> 00:02:42,770
analyze the cancer tissue the previous

00:02:38,760 --> 00:02:45,810
technologies were able to retrieve the

00:02:42,770 --> 00:02:48,270
information at the tissue level like the

00:02:45,810 --> 00:02:50,670
operation is called sequencing the the

00:02:48,270 --> 00:02:52,500
biological sample arrives to the lab and

00:02:50,670 --> 00:02:55,500
then it gets sequence and as a result we

00:02:52,500 --> 00:02:57,360
get the yeah we have the digital

00:02:55,500 --> 00:03:00,090
information about it so that we can run

00:02:57,360 --> 00:03:02,880
our analysis and the previous

00:03:00,090 --> 00:03:05,580
technologies that were sequencing based

00:03:02,880 --> 00:03:07,920
on tissues they were not able to detect

00:03:05,580 --> 00:03:10,410
the heterogeneity among different cells

00:03:07,920 --> 00:03:12,450
because the so in the tissue you just

00:03:10,410 --> 00:03:14,700
get the average of the cells therefore

00:03:12,450 --> 00:03:16,680
you get the most dominant mutation but

00:03:14,700 --> 00:03:18,720
you you ignore all the other mutations

00:03:16,680 --> 00:03:22,200
and as a result in the treatments when

00:03:18,720 --> 00:03:24,390
you have the treatment for the most

00:03:22,200 --> 00:03:28,620
dominant mutation sometimes the other

00:03:24,390 --> 00:03:32,880
ones also pop up and this is why single

00:03:28,620 --> 00:03:35,549
cell sequencing has an importance now

00:03:32,880 --> 00:03:38,670
and the new technology allows us to go

00:03:35,549 --> 00:03:42,660
into single cell detail it singles our

00:03:38,670 --> 00:03:45,030
resolution and yeah from the from the

00:03:42,660 --> 00:03:49,320
single cells okay we have we have this

00:03:45,030 --> 00:03:54,000
DNA inside the cell which has the which

00:03:49,320 --> 00:03:55,799
contains the genetic information and DNA

00:03:54,000 --> 00:03:57,840
sometimes have mutations and some of

00:03:55,799 --> 00:04:00,000
those mutations are known to be

00:03:57,840 --> 00:04:03,660
associated with certain diseases and

00:04:00,000 --> 00:04:05,580
here we are so in the talk I will talk

00:04:03,660 --> 00:04:10,049
about our efforts to model those

00:04:05,580 --> 00:04:12,269
mutations so the the mutation we are

00:04:10,049 --> 00:04:14,549
considering is from the family of

00:04:12,269 --> 00:04:17,850
mutations called structural mutations it

00:04:14,549 --> 00:04:19,440
is called copy number variation and so

00:04:17,850 --> 00:04:23,550
here on the on the figure there is this

00:04:19,440 --> 00:04:26,910
blue part on one genome and on the

00:04:23,550 --> 00:04:29,070
second figure it has duplicated so this

00:04:26,910 --> 00:04:29,790
is a dis very different ation so the

00:04:29,070 --> 00:04:31,440
variation

00:04:29,790 --> 00:04:33,450
copy number on the left there was just

00:04:31,440 --> 00:04:34,560
one copy of the balloon but on the right

00:04:33,450 --> 00:04:36,930
there are two copies

00:04:34,560 --> 00:04:40,890
so those copy number variations can be

00:04:36,930 --> 00:04:42,450
there duplications or deletions and so

00:04:40,890 --> 00:04:44,640
we are going to be analyzing those copy

00:04:42,450 --> 00:04:49,680
number variations at the singles high

00:04:44,640 --> 00:04:53,010
resolution those mutations they have so

00:04:49,680 --> 00:04:55,410
they have this family sort of

00:04:53,010 --> 00:04:58,680
relationship because one when a mutation

00:04:55,410 --> 00:05:00,420
happens sometimes other mutations just

00:04:58,680 --> 00:05:01,950
spend from the parent one so there are

00:05:00,420 --> 00:05:04,680
child mutations and then

00:05:01,950 --> 00:05:07,560
supplementation's they have ancestors as

00:05:04,680 --> 00:05:12,030
well and therefore therefore we are

00:05:07,560 --> 00:05:15,030
modeling them in a tree fashion so don't

00:05:12,030 --> 00:05:17,490
not necessarily binary but it's a it's a

00:05:15,030 --> 00:05:21,840
tree to represent the mutation

00:05:17,490 --> 00:05:24,150
information so the genome is divided

00:05:21,840 --> 00:05:28,070
into different regions here those

00:05:24,150 --> 00:05:30,930
regions are just meaningful parts of DNA

00:05:28,070 --> 00:05:33,180
that are associated with certain

00:05:30,930 --> 00:05:36,510
functionality in the certain

00:05:33,180 --> 00:05:38,550
functionality of life let's say and here

00:05:36,510 --> 00:05:42,540
the route 1 so route 1 doesn't have any

00:05:38,550 --> 00:05:44,700
mutations the other ones have I'm not

00:05:42,540 --> 00:05:47,460
sure if it is have readable they are but

00:05:44,700 --> 00:05:50,490
so they are presenting those copy number

00:05:47,460 --> 00:05:53,160
profiles so this one says or one plus

00:05:50,490 --> 00:05:56,670
one so in region one there is one extra

00:05:53,160 --> 00:06:00,570
copy and all of the all of the single

00:05:56,670 --> 00:06:04,710
cells that are represented by this pink

00:06:00,570 --> 00:06:09,060
circle are going to have one more extra

00:06:04,710 --> 00:06:12,330
copy of that region and and it goes on

00:06:09,060 --> 00:06:14,460
like this so it's a tree where we have a

00:06:12,330 --> 00:06:18,270
dictionary of regions and then we

00:06:14,460 --> 00:06:20,280
contain the extra or missing copy number

00:06:18,270 --> 00:06:22,890
information and this is what we are

00:06:20,280 --> 00:06:27,000
trying to learn so we have a machine

00:06:22,890 --> 00:06:31,470
learning model to learn the best suited

00:06:27,000 --> 00:06:34,410
tree for a given cancer sample and the

00:06:31,470 --> 00:06:37,440
way we are learning is by using a multi

00:06:34,410 --> 00:06:41,130
chain Monte Carlo Markov chain scheme

00:06:37,440 --> 00:06:43,650
and CMC so for each tree we have a we

00:06:41,130 --> 00:06:45,840
have a mean of scoring yet

00:06:43,650 --> 00:06:50,280
using a Drishti multinomial model I

00:06:45,840 --> 00:06:52,350
won't bore you with the formulation but

00:06:50,280 --> 00:06:56,430
we can discuss about it if you are

00:06:52,350 --> 00:06:59,220
interested in after the talk so for a

00:06:56,430 --> 00:07:02,580
given tree and they and the sample data

00:06:59,220 --> 00:07:05,160
we have a way of scoring yet its tells

00:07:02,580 --> 00:07:08,729
how likely it is to observe this data

00:07:05,160 --> 00:07:12,389
this tree given this data and then we

00:07:08,729 --> 00:07:13,740
are able to by using an MC MC scheme we

00:07:12,389 --> 00:07:17,310
are able to move from one tree to

00:07:13,740 --> 00:07:19,680
another and then we will scored the next

00:07:17,310 --> 00:07:22,350
tree as well and then we will see how

00:07:19,680 --> 00:07:24,030
good the second tree is and if it is

00:07:22,350 --> 00:07:26,130
significantly better than the first one

00:07:24,030 --> 00:07:28,289
we will discard the previous tree and we

00:07:26,130 --> 00:07:31,110
will update the model with the next tree

00:07:28,289 --> 00:07:35,070
and we continue like this it will get it

00:07:31,110 --> 00:07:36,870
usually takes lots of iterations on real

00:07:35,070 --> 00:07:39,990
data it is Millions

00:07:36,870 --> 00:07:42,510
and this so that the blood points are

00:07:39,990 --> 00:07:44,850
the MC MC moves we define so here I will

00:07:42,510 --> 00:07:47,160
talk about it the first one is prune and

00:07:44,850 --> 00:07:51,180
reattach so we randomly pick one node

00:07:47,160 --> 00:07:54,510
from the tree we pick T the brown one

00:07:51,180 --> 00:07:57,419
and it has it happens to have two two

00:07:54,510 --> 00:07:58,800
children we just prune it and then we

00:07:57,419 --> 00:08:01,470
reattach it somewhere in the tree

00:07:58,800 --> 00:08:03,060
randomly just we just prune something

00:08:01,470 --> 00:08:06,539
randomly and attach it somewhere else

00:08:03,060 --> 00:08:09,479
and afterwards we we scored the next

00:08:06,539 --> 00:08:11,610
tree as well and if it is significantly

00:08:09,479 --> 00:08:15,979
better than the previous we keep this

00:08:11,610 --> 00:08:15,979
one we discard the other and we continue

00:08:16,010 --> 00:08:22,260
another move we have is called at remove

00:08:19,710 --> 00:08:24,449
node so we pick a node and then we

00:08:22,260 --> 00:08:28,260
randomly we randomly generate another

00:08:24,449 --> 00:08:29,880
node as a child of that node and then we

00:08:28,260 --> 00:08:34,979
see if this tree is better than the

00:08:29,880 --> 00:08:41,039
other and another one is condense and

00:08:34,979 --> 00:08:44,159
split so here we have so we have a we

00:08:41,039 --> 00:08:48,270
take one note alongside with its parent

00:08:44,159 --> 00:08:50,850
and then we condense them into just one

00:08:48,270 --> 00:08:52,500
so these two for the the second one got

00:08:50,850 --> 00:08:55,780
swallowed into the parent they became

00:08:52,500 --> 00:08:57,820
just one and then we see

00:08:55,780 --> 00:09:00,220
we test if this one represents to data

00:08:57,820 --> 00:09:04,300
better than the other this move in fact

00:09:00,220 --> 00:09:07,120
this could be done by different at and

00:09:04,300 --> 00:09:08,860
remove notes so we but the reason we

00:09:07,120 --> 00:09:11,110
have this one is to help with the

00:09:08,860 --> 00:09:13,810
convergence because by insertion and

00:09:11,110 --> 00:09:20,800
deletion we would have to use too much

00:09:13,810 --> 00:09:23,140
iterations but here is just a simple and

00:09:20,800 --> 00:09:28,690
each of the move we have in the Markov

00:09:23,140 --> 00:09:30,610
chain so it it is reversible like from

00:09:28,690 --> 00:09:32,260
from the from the tree on the right hand

00:09:30,610 --> 00:09:36,130
side we are able to go back to the tree

00:09:32,260 --> 00:09:39,250
on the left and we are externally making

00:09:36,130 --> 00:09:43,870
sure that it is equally probable to move

00:09:39,250 --> 00:09:45,310
from left tray to the right tree to from

00:09:43,870 --> 00:09:47,770
right through to the left tree otherwise

00:09:45,310 --> 00:09:51,640
the Markov chain wouldn't be in balance

00:09:47,770 --> 00:10:00,730
and it would it would cost a certain

00:09:51,640 --> 00:10:05,500
biases and yeah so this is so this this

00:10:00,730 --> 00:10:08,430
one is a tree Lord we learned from from

00:10:05,500 --> 00:10:11,589
a real data this data was from a brain

00:10:08,430 --> 00:10:13,390
from a mouse brain and yeah we again

00:10:11,589 --> 00:10:16,420
started with a random tree and after

00:10:13,390 --> 00:10:18,130
millions of iterations this tree happens

00:10:16,420 --> 00:10:21,850
to be the one that is explaining the

00:10:18,130 --> 00:10:26,290
mouse brain tumor evolutions the best on

00:10:21,850 --> 00:10:29,140
the right hand side and below is the is

00:10:26,290 --> 00:10:31,410
the original data matrix we are getting

00:10:29,140 --> 00:10:33,940
after the sequencing experiment and then

00:10:31,410 --> 00:10:36,580
the figure above is how we can

00:10:33,940 --> 00:10:42,360
reconstruct it from the tree from the

00:10:36,580 --> 00:10:42,360
evolutionary tree we learned and

00:10:46,249 --> 00:10:54,169
continue yeah so this was B so this was

00:10:49,679 --> 00:10:57,389
how we are that we were defining the

00:10:54,169 --> 00:11:00,509
model or you have we're modeling the

00:10:57,389 --> 00:11:02,609
heterogeneity into marbeth in in real

00:11:00,509 --> 00:11:04,429
life we have many more things in

00:11:02,609 --> 00:11:07,229
addition to it so the first thing is

00:11:04,429 --> 00:11:09,749
reproducibility of the research we want

00:11:07,229 --> 00:11:12,119
any other Research Institute to just

00:11:09,749 --> 00:11:15,899
read our paper and then able to

00:11:12,119 --> 00:11:20,039
reproduce the results second requirement

00:11:15,899 --> 00:11:22,979
is scalability because in in genomics so

00:11:20,039 --> 00:11:25,319
in the past 10 years the cost of

00:11:22,979 --> 00:11:28,589
sequencing has been decreasing faster

00:11:25,319 --> 00:11:31,979
than the Moore's law as a result this is

00:11:28,589 --> 00:11:33,779
producing more genomic data every day

00:11:31,979 --> 00:11:35,279
and it is the growing rate is

00:11:33,779 --> 00:11:36,629
exponential there's too much genomic

00:11:35,279 --> 00:11:39,419
data produced therefore the

00:11:36,629 --> 00:11:42,569
bioinformatics methods have to be able

00:11:39,419 --> 00:11:47,910
to scale and this is the requirement we

00:11:42,569 --> 00:11:50,489
have we often use multiple programming

00:11:47,910 --> 00:11:53,819
languages the three model it was so the

00:11:50,489 --> 00:11:55,889
MCM three parts was built in C++ since

00:11:53,819 --> 00:11:58,679
it was requiring too many iterations

00:11:55,889 --> 00:12:00,589
there for performance and as many of the

00:11:58,679 --> 00:12:03,600
machine learning frameworks out there

00:12:00,589 --> 00:12:05,789
this so for this we also decided to C++

00:12:03,600 --> 00:12:07,949
but many other parts are written in

00:12:05,789 --> 00:12:12,299
Python and sometimes we even need to use

00:12:07,949 --> 00:12:16,499
our certain statistical methods are only

00:12:12,299 --> 00:12:21,809
implemented there and a multi processing

00:12:16,499 --> 00:12:23,579
because we are so the this data is so

00:12:21,809 --> 00:12:25,039
well I cannot run the experiments on my

00:12:23,579 --> 00:12:28,949
local machine we are using the

00:12:25,039 --> 00:12:33,629
computational clusters and since we have

00:12:28,949 --> 00:12:36,569
multiple nodes so we we try to make use

00:12:33,629 --> 00:12:38,819
of multi processing a lot and yeah

00:12:36,569 --> 00:12:42,059
cluster execution for two reasons one

00:12:38,819 --> 00:12:44,429
there is not enough memory in my local

00:12:42,059 --> 00:12:48,359
second there's not enough time because

00:12:44,429 --> 00:12:50,279
we need to run things in parallel and

00:12:48,359 --> 00:12:53,220
the resources management so for each

00:12:50,279 --> 00:12:56,669
task each by automatic tasks we are

00:12:53,220 --> 00:12:57,240
doing we need to define the memory time

00:12:56,669 --> 00:12:59,790
and the

00:12:57,240 --> 00:13:03,240
space requirements other right into it

00:12:59,790 --> 00:13:07,220
in order to better utilize the cluster

00:13:03,240 --> 00:13:09,779
and we often need to look at the

00:13:07,220 --> 00:13:13,649
statistics about the resource usages in

00:13:09,779 --> 00:13:18,000
order to better to in the cluster

00:13:13,649 --> 00:13:20,550
execution and to achieve this we are

00:13:18,000 --> 00:13:22,910
using yeah among many things we are

00:13:20,550 --> 00:13:26,940
using this workflow management systems

00:13:22,910 --> 00:13:29,700
so it is the one we are using is called

00:13:26,940 --> 00:13:31,850
snake make it is similar to GNU make it

00:13:29,700 --> 00:13:34,800
just Kalos its paradigm but it has the

00:13:31,850 --> 00:13:39,200
pythonic syntax and see I like this

00:13:34,800 --> 00:13:42,080
figure I took it from I guess one of the

00:13:39,200 --> 00:13:49,709
previous snake Mac talk somebody gave

00:13:42,080 --> 00:13:54,360
yeah so this just explains it in a in a

00:13:49,709 --> 00:13:56,279
small diagram so else might make is a

00:13:54,360 --> 00:13:59,640
workflow management system in Python it

00:13:56,279 --> 00:14:02,100
is consisting of different different

00:13:59,640 --> 00:14:03,779
programs and those programs have

00:14:02,100 --> 00:14:05,670
dependencies between each other some of

00:14:03,779 --> 00:14:08,850
them are providing output to the others

00:14:05,670 --> 00:14:10,770
some of them are running in parallel not

00:14:08,850 --> 00:14:14,270
depending on each other and then they

00:14:10,770 --> 00:14:20,880
are getting merged connected in the end

00:14:14,270 --> 00:14:22,709
and yeah so this snake make is a so it

00:14:20,880 --> 00:14:24,779
is provided as a Python package you can

00:14:22,709 --> 00:14:26,880
just keep it installed snake make and it

00:14:24,779 --> 00:14:31,200
has exactly the same Python syntax with

00:14:26,880 --> 00:14:32,970
a few extensions over it and it's all

00:14:31,200 --> 00:14:37,500
off stage and you make paradigm which

00:14:32,970 --> 00:14:39,750
which is well established and yeah so it

00:14:37,500 --> 00:14:42,450
so the workflows are defined in rules

00:14:39,750 --> 00:14:45,360
and those rules are trying to create the

00:14:42,450 --> 00:14:47,070
output given the input file and the

00:14:45,360 --> 00:14:49,560
workflow management system is

00:14:47,070 --> 00:14:53,610
automatically defining the dependencies

00:14:49,560 --> 00:14:56,730
between different rules and by using

00:14:53,610 --> 00:15:00,510
snake make we can make use of all the

00:14:56,730 --> 00:15:02,310
existing Python libraries and unlike

00:15:00,510 --> 00:15:04,920
other workflow management systems out

00:15:02,310 --> 00:15:06,870
there like when I need to use some

00:15:04,920 --> 00:15:08,610
Python functionality inside the workflow

00:15:06,870 --> 00:15:09,870
I mean to write a Python script and I

00:15:08,610 --> 00:15:14,399
need to

00:15:09,870 --> 00:15:16,709
make it executable so that I can access

00:15:14,399 --> 00:15:19,800
it from from the shell but in snake make

00:15:16,709 --> 00:15:21,629
you can you can just use all the

00:15:19,800 --> 00:15:23,279
functionality of Python as it is you

00:15:21,629 --> 00:15:28,170
don't need to wrap them in two different

00:15:23,279 --> 00:15:30,120
different scripts automated logging of

00:15:28,170 --> 00:15:31,860
the status so since workflow management

00:15:30,120 --> 00:15:35,610
systems are consisting of multiple

00:15:31,860 --> 00:15:37,980
programs sometimes even implemented in

00:15:35,610 --> 00:15:39,689
different languages when something

00:15:37,980 --> 00:15:41,970
crashes you need to know which one

00:15:39,689 --> 00:15:43,800
crashed and why it crashed and if

00:15:41,970 --> 00:15:46,019
possible you may want to continue with

00:15:43,800 --> 00:15:48,509
the rest of the workflow or you may want

00:15:46,019 --> 00:15:51,269
to stop there but logging here is very

00:15:48,509 --> 00:15:56,220
important and snake makers providing a

00:15:51,269 --> 00:15:59,639
very automated logging of all of the

00:15:56,220 --> 00:16:04,680
error warning and the status of each

00:15:59,639 --> 00:16:06,439
each row Snecma came out in automatics

00:16:04,680 --> 00:16:09,360
domain but it is a general-purpose

00:16:06,439 --> 00:16:13,410
love-love definition language so it can

00:16:09,360 --> 00:16:18,480
be used in any any domain it's not

00:16:13,410 --> 00:16:23,689
domain-specific and I will show you some

00:16:18,480 --> 00:16:28,949
example here syntax so the rule is

00:16:23,689 --> 00:16:32,309
basically a task that needs to be done

00:16:28,949 --> 00:16:35,850
so the rule can be depending on the so

00:16:32,309 --> 00:16:39,059
the rule may use a shell or Python code

00:16:35,850 --> 00:16:42,180
itself or it can it can use I guess

00:16:39,059 --> 00:16:46,319
there's their support for our scripts as

00:16:42,180 --> 00:16:48,899
well so here this row is going to take

00:16:46,319 --> 00:16:53,100
two inputs one is called

00:16:48,899 --> 00:16:55,949
get you know that FA the other is fasiq'

00:16:53,100 --> 00:16:58,170
and then once these two inputs are

00:16:55,949 --> 00:17:00,600
provided the rule will automatically

00:16:58,170 --> 00:17:02,579
execute the shell command and then it

00:17:00,600 --> 00:17:03,980
will provide the output if it fails to

00:17:02,579 --> 00:17:06,329
provide the output it will crash

00:17:03,980 --> 00:17:10,649
otherwise the rule will be successful

00:17:06,329 --> 00:17:12,299
and the next rule may may begin here in

00:17:10,649 --> 00:17:17,209
the shell command there's this curly

00:17:12,299 --> 00:17:19,980
curly braces so it is it is how to tell

00:17:17,209 --> 00:17:21,750
so it is a way of communicating between

00:17:19,980 --> 00:17:23,980
the shell command and the input files

00:17:21,750 --> 00:17:25,540
because in otherwise if you want

00:17:23,980 --> 00:17:29,220
invoke the same rule from the shell you

00:17:25,540 --> 00:17:32,799
just need to yeah do some extra work

00:17:29,220 --> 00:17:36,880
likewise the output there also serving

00:17:32,799 --> 00:17:39,730
is solving the same purpose and here is

00:17:36,880 --> 00:17:42,220
one extra feature of snake make is if

00:17:39,730 --> 00:17:45,460
you can have wildcards so the sample

00:17:42,220 --> 00:17:48,940
here between the curly brackets it is

00:17:45,460 --> 00:17:51,850
known to be a wild card and this feature

00:17:48,940 --> 00:17:53,950
I like very much because without using a

00:17:51,850 --> 00:17:57,460
workflow management system this is very

00:17:53,950 --> 00:17:59,799
hard to achieve so I will let me explain

00:17:57,460 --> 00:18:01,990
you what it is so in the second line of

00:17:59,799 --> 00:18:06,760
the input it looks at the data directory

00:18:01,990 --> 00:18:11,070
okay go to data samples and then find

00:18:06,760 --> 00:18:13,840
all of the fast queue files that have

00:18:11,070 --> 00:18:16,690
that match certain criteria this can be

00:18:13,840 --> 00:18:19,480
a regular expression this can be just

00:18:16,690 --> 00:18:22,059
anything like a dot first QB don't ask

00:18:19,480 --> 00:18:25,650
us we don't ask you and then for each of

00:18:22,059 --> 00:18:32,340
those input file create the output that

00:18:25,650 --> 00:18:35,830
contains the same wildcard and for each

00:18:32,340 --> 00:18:39,610
input we have so the the shell command

00:18:35,830 --> 00:18:42,100
gets executed and so if without changing

00:18:39,610 --> 00:18:45,490
any line of codes we can basically make

00:18:42,100 --> 00:18:47,919
it scale just by just by using those

00:18:45,490 --> 00:18:49,510
wild cards and those wild cards so we

00:18:47,919 --> 00:18:52,450
can even use them across different rules

00:18:49,510 --> 00:18:54,370
like whatever created from this java

00:18:52,450 --> 00:18:58,240
tool use the exact same thing in the

00:18:54,370 --> 00:19:00,700
python rule and produce the output

00:18:58,240 --> 00:19:03,429
automatically and handle the

00:19:00,700 --> 00:19:05,590
dependencies automatically and by means

00:19:03,429 --> 00:19:07,809
of dependency there is so before snake

00:19:05,590 --> 00:19:11,679
make runs it created this direct acyclic

00:19:07,809 --> 00:19:14,440
graph of the jobs this one is from one

00:19:11,679 --> 00:19:16,679
of our simulation studies so at first

00:19:14,440 --> 00:19:20,200
one two three four first rules are

00:19:16,679 --> 00:19:22,750
executed in in order first one finishes

00:19:20,200 --> 00:19:24,669
second one begins and so on but at some

00:19:22,750 --> 00:19:27,010
point there are multiple ones because

00:19:24,669 --> 00:19:29,740
these ones do not have dependencies and

00:19:27,010 --> 00:19:32,620
they can run in parallel parallel and

00:19:29,740 --> 00:19:35,110
they likewise the last row of rules

00:19:32,620 --> 00:19:36,620
there also they also may run in parallel

00:19:35,110 --> 00:19:40,309
but each one is depending on

00:19:36,620 --> 00:19:42,650
previous one and afterwards we have this

00:19:40,309 --> 00:19:47,230
aggregation at the end it is similar to

00:19:42,650 --> 00:19:50,210
the MPI paradigm basically you can run

00:19:47,230 --> 00:19:56,240
things distributed and you can aggregate

00:19:50,210 --> 00:19:59,720
them and this direct a cyclic graph of

00:19:56,240 --> 00:20:02,600
job so this is this is created

00:19:59,720 --> 00:20:04,940
automatically we don't need to tell them

00:20:02,600 --> 00:20:06,559
look okay first do this rule then the

00:20:04,940 --> 00:20:09,590
second rule then the third rule

00:20:06,559 --> 00:20:11,960
we there's a way of enforcing workflow

00:20:09,590 --> 00:20:14,179
management system to do that but by

00:20:11,960 --> 00:20:17,030
using the inputs and outputs it is

00:20:14,179 --> 00:20:21,730
automatically detecting the direct

00:20:17,030 --> 00:20:25,010
acyclic graph of the job execution and

00:20:21,730 --> 00:20:28,340
here I will show you one more realistic

00:20:25,010 --> 00:20:31,730
to make file so this is a complete make

00:20:28,340 --> 00:20:33,559
fire from for a very basic example so

00:20:31,730 --> 00:20:36,140
here I want to show you how similar it

00:20:33,559 --> 00:20:40,760
is to Python syntax it is basically at

00:20:36,140 --> 00:20:43,340
item so it's a Python library in fact

00:20:40,760 --> 00:20:46,580
and in the first first lines we are

00:20:43,340 --> 00:20:48,440
importing some title modules it can't

00:20:46,580 --> 00:20:50,360
they can be built in modules or custom

00:20:48,440 --> 00:20:53,720
modules like the secondary analysis here

00:20:50,360 --> 00:20:58,250
and this is yeah just regular Python

00:20:53,720 --> 00:21:01,190
later we have this config that is so

00:20:58,250 --> 00:21:03,950
it's the configuration file and since so

00:21:01,190 --> 00:21:05,990
I mean in a program there are often

00:21:03,950 --> 00:21:07,790
parameters and it work full of a set of

00:21:05,990 --> 00:21:10,250
program so there are more parameters and

00:21:07,790 --> 00:21:14,450
therefore it's a common practice to have

00:21:10,250 --> 00:21:17,090
configuration files separated and the

00:21:14,450 --> 00:21:18,920
main workflow and in snake make there's

00:21:17,090 --> 00:21:21,770
this dictionary called config it is

00:21:18,920 --> 00:21:23,690
built-in and when you are invoking snake

00:21:21,770 --> 00:21:25,940
make you can just specify a config file

00:21:23,690 --> 00:21:28,280
and it will be automatically parsed this

00:21:25,940 --> 00:21:30,350
way you don't have to you so this way

00:21:28,280 --> 00:21:33,770
you separate the workflow and and the

00:21:30,350 --> 00:21:36,530
config and the rest is so there's here

00:21:33,770 --> 00:21:40,250
just a Python function you can have any

00:21:36,530 --> 00:21:43,309
Python functions list comprehensions all

00:21:40,250 --> 00:21:46,880
the Python syntactic stuff but the

00:21:43,309 --> 00:21:48,710
difference here is the rule so yeah

00:21:46,880 --> 00:21:50,029
there's this rule and there's

00:21:48,710 --> 00:21:52,190
input/output like in the

00:21:50,029 --> 00:21:54,679
last example but here instead of shell

00:21:52,190 --> 00:21:59,019
there is this run commands and which is

00:21:54,679 --> 00:22:02,899
just accepting Python code so we have

00:21:59,019 --> 00:22:05,809
yes some Python code here to go through

00:22:02,899 --> 00:22:09,549
the files in one directory and do some

00:22:05,809 --> 00:22:13,460
stuff there and in the end create this

00:22:09,549 --> 00:22:15,769
file which happens to be the output and

00:22:13,460 --> 00:22:18,830
yeah so this is how simple it is

00:22:15,769 --> 00:22:21,889
compared to other workflow languages you

00:22:18,830 --> 00:22:24,769
just you are within the scope of Python

00:22:21,889 --> 00:22:34,580
and you can you can make use of that yes

00:22:24,769 --> 00:22:45,200
please yes yes you can you can mix those

00:22:34,580 --> 00:22:48,229
two exactly so good question yeah so

00:22:45,200 --> 00:22:49,909
personally I usually use to make syntax

00:22:48,229 --> 00:22:52,940
I usually call everything from the shell

00:22:49,909 --> 00:22:54,859
even if it is Python I I may have Python

00:22:52,940 --> 00:22:56,779
classes but I will write an executable

00:22:54,859 --> 00:22:59,269
in Python and call it from the shell

00:22:56,779 --> 00:23:02,109
that way I can better manage the the

00:22:59,269 --> 00:23:05,029
outputs and the logs standard error

00:23:02,109 --> 00:23:07,639
under warnings does this way if this

00:23:05,029 --> 00:23:10,009
crashes here the next file will

00:23:07,639 --> 00:23:20,119
terminates and the other way is much

00:23:10,009 --> 00:23:23,149
easier to deal with it and yeah so this

00:23:20,119 --> 00:23:25,580
is an example config file so conflicts

00:23:23,149 --> 00:23:28,999
designers made make so it's a support to

00:23:25,580 --> 00:23:31,309
syntax two formats one is Jason the

00:23:28,999 --> 00:23:33,289
other is y mo llamo has the advantage of

00:23:31,309 --> 00:23:37,700
allowing commands but jason has the

00:23:33,289 --> 00:23:41,570
advantage of easily being easily

00:23:37,700 --> 00:23:43,940
serializable I mean because I often

00:23:41,570 --> 00:23:45,909
create the Jason's from some Python

00:23:43,940 --> 00:23:49,249
dictionaries I automate certain tasks

00:23:45,909 --> 00:23:52,460
therefore in this example I use Jason

00:23:49,249 --> 00:23:55,190
but here you can use any config file and

00:23:52,460 --> 00:24:00,409
you can use any other Python parser for

00:23:55,190 --> 00:24:02,690
the config this is the support it is one

00:24:00,409 --> 00:24:03,220
of the two supported syntax is in snake

00:24:02,690 --> 00:24:07,090
make

00:24:03,220 --> 00:24:09,460
and they had the execution also say a

00:24:07,090 --> 00:24:12,900
snake make is automatically configurable

00:24:09,460 --> 00:24:16,360
with LSF scheduler you can just pass it

00:24:12,900 --> 00:24:18,640
and in the config file given that you

00:24:16,360 --> 00:24:20,470
define the resources for each job like

00:24:18,640 --> 00:24:22,419
this much memory for this job that much

00:24:20,470 --> 00:24:25,150
memory for the second job snake make

00:24:22,419 --> 00:24:28,929
automatically will create subtasks sub

00:24:25,150 --> 00:24:33,549
jobs on the clusters and that way you

00:24:28,929 --> 00:24:36,039
can give how much so you can specify how

00:24:33,549 --> 00:24:38,500
much memory or how much runtime or how

00:24:36,039 --> 00:24:41,110
much disk space you want to give to each

00:24:38,500 --> 00:24:44,440
job I'll be very quick so and another

00:24:41,110 --> 00:24:48,340
thing technology we are using is hdf5 -

00:24:44,440 --> 00:24:51,130
hierarchical data formats yet our binary

00:24:48,340 --> 00:24:54,520
easy to manipulate this comes very handy

00:24:51,130 --> 00:24:56,530
in genomics because we usually make use

00:24:54,520 --> 00:24:58,240
of metadata and it so display they are

00:24:56,530 --> 00:25:00,429
storing the data alongside with the

00:24:58,240 --> 00:25:02,919
metadata and since in the pipeline we

00:25:00,429 --> 00:25:05,429
are using c++ sometimes python and

00:25:02,919 --> 00:25:08,169
sometimes are we need to have a common

00:25:05,429 --> 00:25:10,350
serialized visible format and we cannot

00:25:08,169 --> 00:25:14,970
use people we cannot import people in

00:25:10,350 --> 00:25:17,799
c++ or vice versa so this binary file of

00:25:14,970 --> 00:25:19,900
so there is another use of hdf5

00:25:17,799 --> 00:25:26,679
basically we can use it and we can load

00:25:19,900 --> 00:25:27,640
the exact same thing and then yeah and

00:25:26,679 --> 00:25:30,400
we can

00:25:27,640 --> 00:25:34,659
so the hdf5 allow us to just connect to

00:25:30,400 --> 00:25:36,340
some data and perform operations on a

00:25:34,659 --> 00:25:39,549
subset of it without having to load

00:25:36,340 --> 00:25:44,049
everything into memory which is also

00:25:39,549 --> 00:25:47,320
quite handy and yeah this is the last

00:25:44,049 --> 00:25:49,179
slide of it one before the last one so

00:25:47,320 --> 00:25:51,490
in ace in python there are two rappers

00:25:49,179 --> 00:25:53,830
one is pi tables which is high-level a

00:25:51,490 --> 00:25:57,340
very nice wrapper of a snare 5 that

00:25:53,830 --> 00:26:01,320
interacts with pandas and the other is H

00:25:57,340 --> 00:26:05,799
5py which is very similar to the C++ API

00:26:01,320 --> 00:26:08,890
and yeah so this this was the outline

00:26:05,799 --> 00:26:11,130
basically the problem at hand our

00:26:08,890 --> 00:26:14,049
statistical model and the bioinformatics

00:26:11,130 --> 00:26:16,360
parts the pipeline and the tools we are

00:26:14,049 --> 00:26:17,059
using to deal with that and the feature

00:26:16,360 --> 00:26:20,929
works

00:26:17,059 --> 00:26:23,149
we will get published a method first the

00:26:20,929 --> 00:26:25,610
statistical method we will compare two

00:26:23,149 --> 00:26:28,039
other methods we will have evaluations

00:26:25,610 --> 00:26:30,409
on real date is simulated data and we

00:26:28,039 --> 00:26:33,320
will show it some real data and later

00:26:30,409 --> 00:26:35,840
this pipeline is going to be wrapped up

00:26:33,320 --> 00:26:39,740
we will do all the findings to other

00:26:35,840 --> 00:26:43,340
languages and we will provide it on

00:26:39,740 --> 00:26:45,019
github open softly and yeah this

00:26:43,340 --> 00:27:00,139
concludes the talk thank you very much

00:26:45,019 --> 00:27:05,690
for attention quick Q&A if anyone has

00:27:00,139 --> 00:27:09,799
any questions just go microphones yes

00:27:05,690 --> 00:27:12,429
please go to the microphone there just

00:27:09,799 --> 00:27:16,850
like yeah the closest microphone to you

00:27:12,429 --> 00:27:20,360
if I understand correctly snake mate is

00:27:16,850 --> 00:27:22,610
compatible with singularity so if your

00:27:20,360 --> 00:27:25,580
project using singularity or not

00:27:22,610 --> 00:27:28,580
oh I'm just wondering that I don't know

00:27:25,580 --> 00:27:32,600
what singularity is kind of container

00:27:28,580 --> 00:27:36,139
technology I get done but maybe probably

00:27:32,600 --> 00:27:38,649
I just I just out of topic maybe we can

00:27:36,139 --> 00:27:38,649
discuss it

00:27:49,590 --> 00:27:56,670
okay if no one else then lunch will be

00:27:53,880 --> 00:27:59,810
served soon I think of rats hungry yeah

00:27:56,670 --> 00:28:04,869
so let's give a round of applause

00:27:59,810 --> 00:28:04,869

YouTube URL: https://www.youtube.com/watch?v=i0BlJpDQW_U


