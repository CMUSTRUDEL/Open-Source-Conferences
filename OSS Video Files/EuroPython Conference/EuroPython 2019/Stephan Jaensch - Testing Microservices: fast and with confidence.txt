Title: Stephan Jaensch - Testing Microservices: fast and with confidence
Publication date: 2019-09-23
Playlist: EuroPython 2019
Description: 
	"Testing Microservices: fast and with confidence
[EuroPython 2019 - Talk - 2019-07-11 - Shanghai]
[Basel, CH]

By Stephan Jaensch

A main advantage of microservices is improved developer velocity. One roadblock to achieving it is giving developers the confidence that their changes are correct and safe, which is a challenging problem in such a distributed architecture. Typical approaches involve relying on automated end-to-end testing, which is costly to set up, develop tests for and run.

In this talk I will explore an approach to testing that does not require the presence of any external dependencies (not even ""fake"" or ""test double"" implementations of them), but provides many of the benefits of an end-to-end test. Come by to learn about how we can use a downstream service's API specification to make sure the system under test interacts with it in the correct way (""contract testing"") - a key ingredient missing from most unit or integration test setups. We'll then go even further to cover testing scenarios that previously could only be covered with end-to-end tests: how to maintain and validate state of your downstream dependencies.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/
Captions: 
	00:00:03,970 --> 00:00:12,460
[Applause]

00:00:07,950 --> 00:00:15,219
hi everyone very happy to be here yes

00:00:12,460 --> 00:00:17,740
like you said my name is Stefan I'm a

00:00:15,219 --> 00:00:19,780
tech lead at Yelp and in this talk I'm

00:00:17,740 --> 00:00:24,310
going to take you a little bit on a

00:00:19,780 --> 00:00:26,740
journey of testing services at Yelp and

00:00:24,310 --> 00:00:29,410
actually this journey started or rather

00:00:26,740 --> 00:00:30,970
me talking about it started already two

00:00:29,410 --> 00:00:33,340
years ago because I gave a talk two

00:00:30,970 --> 00:00:35,110
years ago at you're a Python and it was

00:00:33,340 --> 00:00:38,560
also about testing and it was also about

00:00:35,110 --> 00:00:41,980
testing services so just a quick recap

00:00:38,560 --> 00:00:45,010
like what did I talk about back then if

00:00:41,980 --> 00:00:47,680
we look at the testing pyramid my talk

00:00:45,010 --> 00:00:49,810
back then was really focused on the on

00:00:47,680 --> 00:00:52,329
the top end of that pyramid or what is

00:00:49,810 --> 00:00:54,100
supposed to be the top and so on

00:00:52,329 --> 00:00:56,410
end-to-end tests or what sometimes I

00:00:54,100 --> 00:00:58,450
call system tests in inside Europe we

00:00:56,410 --> 00:01:00,700
often call them acceptance tests and

00:00:58,450 --> 00:01:02,079
these are the slowest and most expensive

00:01:00,700 --> 00:01:04,239
tests to run

00:01:02,079 --> 00:01:06,430
since typically what you do is you spin

00:01:04,239 --> 00:01:08,409
up each of your dependencies and then

00:01:06,430 --> 00:01:12,159
their dependencies and so on and so

00:01:08,409 --> 00:01:15,700
forth and that is obviously not always a

00:01:12,159 --> 00:01:17,380
fast or cheap thing to do so why do we

00:01:15,700 --> 00:01:21,039
do this why was I talking about just

00:01:17,380 --> 00:01:22,630
these tests the reason is this because

00:01:21,039 --> 00:01:24,609
when you have many services and we do

00:01:22,630 --> 00:01:27,689
have many services at Yelp they're all

00:01:24,609 --> 00:01:31,469
interconnected you have this huge graph

00:01:27,689 --> 00:01:33,909
your code is split across repositories

00:01:31,469 --> 00:01:36,609
when you execute your code it's

00:01:33,909 --> 00:01:38,799
separated by a network layer and so

00:01:36,609 --> 00:01:41,170
actually verifying the correctness of

00:01:38,799 --> 00:01:44,079
this whole system is no trivial task and

00:01:41,170 --> 00:01:46,029
end-to-end tests help significantly in

00:01:44,079 --> 00:01:47,920
that effort because you do try to

00:01:46,029 --> 00:01:50,560
replicate something that is like as

00:01:47,920 --> 00:01:52,539
close to production as possible and so

00:01:50,560 --> 00:01:56,799
you you actually gain confidence that

00:01:52,539 --> 00:01:58,659
everything works well together obviously

00:01:56,799 --> 00:02:00,490
better it would be better to use

00:01:58,659 --> 00:02:03,310
something like unit tests more but the

00:02:00,490 --> 00:02:06,549
problem with unit tests is that in as

00:02:03,310 --> 00:02:08,880
long as I as soon as you test something

00:02:06,549 --> 00:02:12,040
that interacts with an outside system

00:02:08,880 --> 00:02:14,200
you have to use mocking for that

00:02:12,040 --> 00:02:16,659
and especially with something as that

00:02:14,200 --> 00:02:19,810
can get complicated like service API

00:02:16,659 --> 00:02:22,239
calls it's not always easy to make sure

00:02:19,810 --> 00:02:24,219
that you get to Mach right so sometimes

00:02:22,239 --> 00:02:25,840
a test can fail and you don't know is

00:02:24,219 --> 00:02:28,840
your code wrong or is the mock Rome

00:02:25,840 --> 00:02:30,489
otherwise a test might pass but actually

00:02:28,840 --> 00:02:34,500
your code is still buggy you just

00:02:30,489 --> 00:02:37,750
adapted the mark to fit your buggy code

00:02:34,500 --> 00:02:39,250
so that's why I'd Yelp our testing

00:02:37,750 --> 00:02:41,469
permit doesn't really look that much

00:02:39,250 --> 00:02:43,870
like a permit it's it's more like it's a

00:02:41,469 --> 00:02:45,430
lot of unit tests and then maybe a few

00:02:43,870 --> 00:02:48,010
integration tests and then again

00:02:45,430 --> 00:02:50,709
actually quite a lot of end-to-end or

00:02:48,010 --> 00:02:52,959
acceptance tests and that's why we we

00:02:50,709 --> 00:02:55,540
invested in in making end-to-end tests

00:02:52,959 --> 00:02:58,209
easier to write easier to run and that's

00:02:55,540 --> 00:03:00,129
why I gave it gave a talk about it about

00:02:58,209 --> 00:03:02,829
well running end to end tests more

00:03:00,129 --> 00:03:04,689
quickly and how to manage state and in

00:03:02,829 --> 00:03:07,480
all of these other services that you

00:03:04,689 --> 00:03:11,169
that you're including in your tests but

00:03:07,480 --> 00:03:13,389
it turns out they are not just slow

00:03:11,169 --> 00:03:16,690
these end-to-end tests they can also be

00:03:13,389 --> 00:03:20,440
flaky this is an extreme example here

00:03:16,690 --> 00:03:22,690
but yeah we were actually running into

00:03:20,440 --> 00:03:24,099
issues due to us spinning up all of

00:03:22,690 --> 00:03:26,739
these other services in docker

00:03:24,099 --> 00:03:28,840
containers needing to create state in

00:03:26,739 --> 00:03:32,229
all of these or some of these other

00:03:28,840 --> 00:03:34,720
services so we had talked of failures we

00:03:32,229 --> 00:03:36,609
had request timeouts and we had high

00:03:34,720 --> 00:03:39,220
hardware requirements so in this extreme

00:03:36,609 --> 00:03:42,340
example the Box we used to run the test

00:03:39,220 --> 00:03:44,430
was just simply too small but still this

00:03:42,340 --> 00:03:47,590
is like not something that scales

00:03:44,430 --> 00:03:49,810
infinitely since we also have like a

00:03:47,590 --> 00:03:52,620
large more or less and turns out like

00:03:49,810 --> 00:03:55,900
yes it's almost always used in some form

00:03:52,620 --> 00:03:57,519
again a lot of other services so we

00:03:55,900 --> 00:04:01,569
actually continued our investment how

00:03:57,519 --> 00:04:03,609
can we make this run better and here

00:04:01,569 --> 00:04:05,739
this is a different view from Jenkins we

00:04:03,609 --> 00:04:08,979
are actually able to to run these

00:04:05,739 --> 00:04:10,959
acceptance tests and to end tests in a

00:04:08,979 --> 00:04:15,370
reasonable amount of time and with no

00:04:10,959 --> 00:04:19,090
errors and we use mountebank which is an

00:04:15,370 --> 00:04:21,370
open source project to do this so what

00:04:19,090 --> 00:04:23,110
we do is we we record like when we do

00:04:21,370 --> 00:04:24,770
these full test runs with all of the

00:04:23,110 --> 00:04:26,990
dependencies we were

00:04:24,770 --> 00:04:28,370
the communication between our service

00:04:26,990 --> 00:04:30,710
and the other service or actually like

00:04:28,370 --> 00:04:33,470
with all within all of the services that

00:04:30,710 --> 00:04:36,770
that we spin up and then we can play

00:04:33,470 --> 00:04:38,570
them back and we actually even I think

00:04:36,770 --> 00:04:41,870
like many companies do this we even

00:04:38,570 --> 00:04:43,910
augmented it a bit too so that when we

00:04:41,870 --> 00:04:46,940
record these requests and responses we

00:04:43,910 --> 00:04:49,840
we know about the context so which test

00:04:46,940 --> 00:04:52,070
is this so we actually don't rely on

00:04:49,840 --> 00:04:54,590
executing the tests in order we can

00:04:52,070 --> 00:04:57,380
actually like paralyzed them or shuffle

00:04:54,590 --> 00:04:59,090
them around and it will still when you

00:04:57,380 --> 00:05:01,550
call like a service ten different times

00:04:59,090 --> 00:05:03,860
from ten different tests it will always

00:05:01,550 --> 00:05:07,640
return the answer within that test

00:05:03,860 --> 00:05:09,890
context and I would say this is actually

00:05:07,640 --> 00:05:13,100
what for example Martin Fowler describes

00:05:09,890 --> 00:05:16,550
as a contract testing it was self

00:05:13,100 --> 00:05:19,550
initializing fakes how he how he calls

00:05:16,550 --> 00:05:21,290
it and it does eliminate most of the

00:05:19,550 --> 00:05:23,660
flakiness that we saw due to time old

00:05:21,290 --> 00:05:26,540
issues there are still some talk of

00:05:23,660 --> 00:05:28,660
flakiness there plus it only helps when

00:05:26,540 --> 00:05:31,190
you can like do this in replay mode

00:05:28,660 --> 00:05:35,330
record mode it still has all of the

00:05:31,190 --> 00:05:38,060
problems I mentioned and we do need to

00:05:35,330 --> 00:05:40,610
run tests and record mode actually at

00:05:38,060 --> 00:05:42,860
least once during an engineer like doing

00:05:40,610 --> 00:05:44,540
a feature branch because if you change

00:05:42,860 --> 00:05:47,180
the behavior of your service or the

00:05:44,540 --> 00:05:49,670
pattern of services it calls you

00:05:47,180 --> 00:05:54,350
typically have to re-record the these

00:05:49,670 --> 00:05:56,750
interactions so maybe making end-to-end

00:05:54,350 --> 00:06:01,030
tests a better and better is not the

00:05:56,750 --> 00:06:03,410
solution what can we do contract testing

00:06:01,030 --> 00:06:05,150
there's like many articles and papers

00:06:03,410 --> 00:06:07,430
about it I just picked this one

00:06:05,150 --> 00:06:09,470
definition contract testing is writing

00:06:07,430 --> 00:06:11,630
tests to ensure that the explicit and

00:06:09,470 --> 00:06:14,330
implicit contracts of your microservices

00:06:11,630 --> 00:06:15,770
work as advertised and in this talk

00:06:14,330 --> 00:06:19,010
specifically I'm going to focus on

00:06:15,770 --> 00:06:21,140
consumer contract testing so testing the

00:06:19,010 --> 00:06:26,600
contract from the consumer so the caller

00:06:21,140 --> 00:06:29,450
of another service and oftentimes like I

00:06:26,600 --> 00:06:31,160
described people mean or talk about

00:06:29,450 --> 00:06:33,770
contrast testing they say like testing

00:06:31,160 --> 00:06:35,690
against a real instance or like a real

00:06:33,770 --> 00:06:36,500
instance that has a special isolated

00:06:35,690 --> 00:06:38,750
mode that doesn't

00:06:36,500 --> 00:06:42,680
acquire any of its dependencies or maybe

00:06:38,750 --> 00:06:45,710
a stub or a fake but what if we could

00:06:42,680 --> 00:06:49,190
like use in process testing like like

00:06:45,710 --> 00:06:51,680
unit testing but with so with Marx but

00:06:49,190 --> 00:06:53,990
with validated Marx so we're actually

00:06:51,680 --> 00:06:58,340
able to validate that the marks we

00:06:53,990 --> 00:07:01,550
provide adhere to the contract and this

00:06:58,340 --> 00:07:03,830
is what what I'm going to talk about it

00:07:01,550 --> 00:07:06,710
turns out that IDL we can already do

00:07:03,830 --> 00:07:08,480
that and we could actually do that for

00:07:06,710 --> 00:07:11,360
each and every request that is done

00:07:08,480 --> 00:07:12,919
between two services to explain that I'm

00:07:11,360 --> 00:07:16,580
going to talk a little bit about how we

00:07:12,919 --> 00:07:23,840
do service to service requests just very

00:07:16,580 --> 00:07:26,870
quickly and Yelp each service has an API

00:07:23,840 --> 00:07:28,700
specification and this will be our

00:07:26,870 --> 00:07:31,669
contract or this is actually the

00:07:28,700 --> 00:07:33,500
contract we use open API or swagger how

00:07:31,669 --> 00:07:35,600
it has been called for a long time for

00:07:33,500 --> 00:07:38,419
that but there's like other systems as

00:07:35,600 --> 00:07:41,270
well that you can use just as well and

00:07:38,419 --> 00:07:44,600
when we talk to another service we have

00:07:41,270 --> 00:07:47,000
a client library this client library is

00:07:44,600 --> 00:07:49,310
for each destination service or

00:07:47,000 --> 00:07:49,700
producing service we have a client

00:07:49,310 --> 00:07:52,729
library

00:07:49,700 --> 00:07:54,530
it is versioned and it ships with a

00:07:52,729 --> 00:07:57,229
swagger especially the specification of

00:07:54,530 --> 00:07:59,510
open API specification for that service

00:07:57,229 --> 00:08:01,430
we're calling so each point in time

00:07:59,510 --> 00:08:02,840
whenever this specification changes we

00:08:01,430 --> 00:08:06,790
create a new version of the client

00:08:02,840 --> 00:08:09,530
library and then people can use it and

00:08:06,790 --> 00:08:11,750
when you to make these API calls what

00:08:09,530 --> 00:08:14,120
you really make is this Python function

00:08:11,750 --> 00:08:16,250
calls and in this client library does

00:08:14,120 --> 00:08:17,870
all of the magic in the background we

00:08:16,250 --> 00:08:20,000
actually like the main part of that

00:08:17,870 --> 00:08:22,040
client library is is an open source

00:08:20,000 --> 00:08:26,750
library called privado that that you can

00:08:22,040 --> 00:08:29,530
check out that we maintain so how does

00:08:26,750 --> 00:08:31,780
that help us in in having like fast

00:08:29,530 --> 00:08:34,940
testing that provides a similar

00:08:31,780 --> 00:08:37,250
confidence like end-to-end tests at

00:08:34,940 --> 00:08:39,620
least in some respects well if we look

00:08:37,250 --> 00:08:42,620
at how internally this client library

00:08:39,620 --> 00:08:44,990
works there's like several steps that

00:08:42,620 --> 00:08:48,040
are executed first of all it takes this

00:08:44,990 --> 00:08:50,110
function call and from the information

00:08:48,040 --> 00:08:52,570
encoded in that function call so not

00:08:50,110 --> 00:08:54,579
only like the arguments that we pass in

00:08:52,570 --> 00:08:56,589
but also the name of the function it it

00:08:54,579 --> 00:09:00,550
constructs the request by looking at a

00:08:56,589 --> 00:09:02,620
API specification it then marshals the

00:09:00,550 --> 00:09:05,320
data which it's the process of

00:09:02,620 --> 00:09:08,410
converting like Python objects and data

00:09:05,320 --> 00:09:11,410
into the on the wire format which forces

00:09:08,410 --> 00:09:13,740
JSON typically and then it has the

00:09:11,410 --> 00:09:16,540
option of actually validating that

00:09:13,740 --> 00:09:19,389
marshal data like that on the wire data

00:09:16,540 --> 00:09:22,779
against a specification and making sure

00:09:19,389 --> 00:09:24,970
it is valid and then it sends out the

00:09:22,779 --> 00:09:26,740
HTTP request it comes in and it goes

00:09:24,970 --> 00:09:30,339
like the other way around

00:09:26,740 --> 00:09:31,959
so this response because that's like we

00:09:30,339 --> 00:09:33,910
you can actually use different HTTP

00:09:31,959 --> 00:09:36,850
clients so at first it's adapted for

00:09:33,910 --> 00:09:39,370
privado then optionally again validate

00:09:36,850 --> 00:09:46,089
it and then on Marshall so transferred

00:09:39,370 --> 00:09:48,790
into Python objects so what could we do

00:09:46,089 --> 00:09:51,370
here what if instead of like when you

00:09:48,790 --> 00:09:53,920
typically use unit tests you would like

00:09:51,370 --> 00:09:55,029
mock out the whole function call like

00:09:53,920 --> 00:09:57,130
you have this function call that

00:09:55,029 --> 00:09:59,500
translates to making a service request

00:09:57,130 --> 00:10:02,980
you mock it out and you provide a return

00:09:59,500 --> 00:10:05,350
value what if we didn't do that but we

00:10:02,980 --> 00:10:07,990
let most of our client library machinery

00:10:05,350 --> 00:10:10,630
actually run we just made sure it

00:10:07,990 --> 00:10:13,510
doesn't call the remote service and we

00:10:10,630 --> 00:10:16,240
provide the mark we provide is like the

00:10:13,510 --> 00:10:18,069
on the wire format for the response and

00:10:16,240 --> 00:10:20,019
then we let it run through the

00:10:18,069 --> 00:10:21,459
validation and the validation is

00:10:20,019 --> 00:10:23,319
actually done by a library called

00:10:21,459 --> 00:10:25,660
Swagger's back validator which in turn

00:10:23,319 --> 00:10:28,569
uses JSON schema so it's actually like

00:10:25,660 --> 00:10:32,790
I'm pretty good at making sure the data

00:10:28,569 --> 00:10:36,190
is valid according to our contract and

00:10:32,790 --> 00:10:37,690
since we know the contract what we can

00:10:36,190 --> 00:10:41,949
actually do we couldn't even provide a

00:10:37,690 --> 00:10:44,199
default mark for free so developers can

00:10:41,949 --> 00:10:45,730
specify it but we look like we look at

00:10:44,199 --> 00:10:47,740
the structure of the response we know

00:10:45,730 --> 00:10:49,690
all all of the fields all of the values

00:10:47,740 --> 00:10:52,360
all of the sub objects and we can

00:10:49,690 --> 00:10:56,079
provide a default default data for it so

00:10:52,360 --> 00:10:58,420
if we look at at a code example as you

00:10:56,079 --> 00:11:00,339
can see here all we need to do is we

00:10:58,420 --> 00:11:01,330
need to patch the client lip so that's

00:11:00,339 --> 00:11:05,200
like one

00:11:01,330 --> 00:11:07,540
all we do which is actually am a context

00:11:05,200 --> 00:11:09,640
manager and anywhere in our code where

00:11:07,540 --> 00:11:12,370
we use this specific client library it

00:11:09,640 --> 00:11:15,430
will just be replaced with our our mock

00:11:12,370 --> 00:11:17,560
machinery and then we call our our

00:11:15,430 --> 00:11:19,690
function here which you can all assume

00:11:17,560 --> 00:11:22,120
like does other service like does this

00:11:19,690 --> 00:11:24,190
service call and you can see it returns

00:11:22,120 --> 00:11:26,529
data even though we never specified a

00:11:24,190 --> 00:11:28,510
mark and yes it's like initialized to

00:11:26,529 --> 00:11:30,640
some default in this case we're integer

00:11:28,510 --> 00:11:33,209
zero for Strings it's the empty string

00:11:30,640 --> 00:11:36,850
and so on and so forth it knows these

00:11:33,209 --> 00:11:40,180
names for the for the days because

00:11:36,850 --> 00:11:43,029
that's like an enumeration actually yeah

00:11:40,180 --> 00:11:45,190
and that is it and it turns out in the

00:11:43,029 --> 00:11:46,899
open API specification you can even

00:11:45,190 --> 00:11:49,570
provide for each response you can

00:11:46,899 --> 00:11:51,910
provide an example response and if the

00:11:49,570 --> 00:11:53,589
ad is present we actually use that so we

00:11:51,910 --> 00:11:56,410
don't use like zeros and empty strings

00:11:53,589 --> 00:11:58,029
but the developer of the other service

00:11:56,410 --> 00:12:01,720
can provide an example response which

00:11:58,029 --> 00:12:03,279
will be used but of course there's many

00:12:01,720 --> 00:12:05,980
test scenarios we don't want some

00:12:03,279 --> 00:12:10,720
default data so obviously it's also

00:12:05,980 --> 00:12:13,329
possible to provide your own data like

00:12:10,720 --> 00:12:15,070
in this case you can see I set the

00:12:13,329 --> 00:12:17,860
return value and also the HTTP status

00:12:15,070 --> 00:12:20,589
code that is to be returned you can also

00:12:17,860 --> 00:12:23,380
like you know from mark because we

00:12:20,589 --> 00:12:24,910
internally we obviously we use mark you

00:12:23,380 --> 00:12:27,730
can also provide a side-effect so you

00:12:24,910 --> 00:12:31,570
can actually do almost anything raise an

00:12:27,730 --> 00:12:34,120
exception or whatever yeah and and this

00:12:31,570 --> 00:12:36,820
works but this is actually not different

00:12:34,120 --> 00:12:40,300
from just patching on your own and and

00:12:36,820 --> 00:12:43,240
doing marking so what happens if the

00:12:40,300 --> 00:12:44,770
return value I provide here is not a

00:12:43,240 --> 00:12:47,430
valid according to our contract

00:12:44,770 --> 00:12:50,589
according to our service specification

00:12:47,430 --> 00:12:53,440
well what happens is actually not that

00:12:50,589 --> 00:12:55,089
impressive but I hope you can read it

00:12:53,440 --> 00:12:57,190
but basically you get a JSON schema

00:12:55,089 --> 00:13:00,100
error in this specific case the error I

00:12:57,190 --> 00:13:02,680
produced I provided a response the

00:13:00,100 --> 00:13:05,740
specification said in the response there

00:13:02,680 --> 00:13:08,380
should be a field named ID and my

00:13:05,740 --> 00:13:10,930
response didn't have it so there was an

00:13:08,380 --> 00:13:14,070
error same thing if I said like the ID

00:13:10,930 --> 00:13:15,750
field is supposed to be an integer and

00:13:14,070 --> 00:13:17,460
provide a string it would also complain

00:13:15,750 --> 00:13:19,610
is actually something that we deal with

00:13:17,460 --> 00:13:23,580
internally because obviously internally

00:13:19,610 --> 00:13:26,400
IDs are integers but whenever we like to

00:13:23,580 --> 00:13:29,100
external api's then we provide them as

00:13:26,400 --> 00:13:32,100
strings so there's always the potential

00:13:29,100 --> 00:13:33,360
for confusion there yeah and this means

00:13:32,100 --> 00:13:36,330
like your marks will actually be

00:13:33,360 --> 00:13:39,000
validated against against your contract

00:13:36,330 --> 00:13:40,230
and you don't have to spin up anything

00:13:39,000 --> 00:13:43,320
you don't even need more than one

00:13:40,230 --> 00:13:48,090
process for testing and it it it is

00:13:43,320 --> 00:13:50,100
extremely fast so let me summarize this

00:13:48,090 --> 00:13:51,620
a little bit and and still talk a bit

00:13:50,100 --> 00:13:54,060
more about it

00:13:51,620 --> 00:13:56,070
end-to-end tests on scale infinitely

00:13:54,060 --> 00:13:59,700
that I mentioned that so we need a

00:13:56,070 --> 00:14:01,890
solution to that contract tests are

00:13:59,700 --> 00:14:04,350
supposed to help here I didn't get into

00:14:01,890 --> 00:14:07,680
too much detail what what contract

00:14:04,350 --> 00:14:09,150
testing actually is but you what I mean

00:14:07,680 --> 00:14:12,660
by that at the other side we can like

00:14:09,150 --> 00:14:15,470
leverage existing infrastructure to do

00:14:12,660 --> 00:14:18,030
consumer driven contract testing and

00:14:15,470 --> 00:14:21,630
essentially what this means for you as a

00:14:18,030 --> 00:14:24,120
developer you get way more confidence in

00:14:21,630 --> 00:14:27,060
when you do the testing you're used to

00:14:24,120 --> 00:14:29,910
from unit testing as opposed to doing

00:14:27,060 --> 00:14:32,850
just unit testing so the goal here was

00:14:29,910 --> 00:14:35,970
and is to gain way more confidence in

00:14:32,850 --> 00:14:38,220
these cheap tests and so having to do

00:14:35,970 --> 00:14:41,040
fewer of those expensive tests that are

00:14:38,220 --> 00:14:44,940
expensive to run and also sometimes of

00:14:41,040 --> 00:14:48,000
pain to develop one thing I'll mention

00:14:44,940 --> 00:14:51,090
is that we are relying on the fact that

00:14:48,000 --> 00:14:53,330
our service that service we're calling

00:14:51,090 --> 00:14:56,580
and we're testing against adheres to its

00:14:53,330 --> 00:14:59,550
specification so if that service does

00:14:56,580 --> 00:15:02,400
are backwards incompatible change we

00:14:59,550 --> 00:15:05,540
won't detect it there's other tools like

00:15:02,400 --> 00:15:08,250
pact or a post man actually has no

00:15:05,540 --> 00:15:10,970
framework for doing contract testing

00:15:08,250 --> 00:15:14,400
that they deal better with this and that

00:15:10,970 --> 00:15:16,350
not only like do consumer-driven testing

00:15:14,400 --> 00:15:19,130
but then also do this testing against a

00:15:16,350 --> 00:15:21,450
producer like the destination service

00:15:19,130 --> 00:15:23,459
this solution here doesn't help with

00:15:21,450 --> 00:15:26,249
that but

00:15:23,459 --> 00:15:30,809
we have developed a tool that is

00:15:26,249 --> 00:15:32,459
supposed to help you detect backwards

00:15:30,809 --> 00:15:33,779
and compatible specification changes

00:15:32,459 --> 00:15:35,249
because that is another thing I actually

00:15:33,779 --> 00:15:37,079
talked about this in the past as well

00:15:35,249 --> 00:15:39,480
here at Europe Python that's another

00:15:37,079 --> 00:15:41,759
pain point developers inadvertently

00:15:39,480 --> 00:15:44,429
making changes to API specifications

00:15:41,759 --> 00:15:45,480
that are backwards incompatible so if

00:15:44,429 --> 00:15:47,249
you're interested in that we have

00:15:45,480 --> 00:15:49,559
something that is called swagger spec

00:15:47,249 --> 00:15:52,079
compatibility that's open sourced and

00:15:49,559 --> 00:15:54,540
that you incorporate to hopefully make

00:15:52,079 --> 00:15:58,199
sure your service remains true to its

00:15:54,540 --> 00:15:59,910
contract and that is it already I'll

00:15:58,199 --> 00:16:02,160
mention that we are hiring and we are

00:15:59,910 --> 00:16:04,529
sponsoring so please find us at the

00:16:02,160 --> 00:16:07,709
booth we'd love to talk to all of you

00:16:04,529 --> 00:16:11,730
we do have European offices at Yelp in

00:16:07,709 --> 00:16:13,529
Hamburg Germany and in London and thank

00:16:11,730 --> 00:16:15,390
you for your time love to hear your

00:16:13,529 --> 00:16:22,800
questions

00:16:15,390 --> 00:16:25,150
[Applause]

00:16:22,800 --> 00:16:26,680
for questions please come to the

00:16:25,150 --> 00:16:32,590
microphones or raise your hand and I can

00:16:26,680 --> 00:16:35,170
bring your microphone so maybe I can

00:16:32,590 --> 00:16:37,900
start it off and how do you deal with

00:16:35,170 --> 00:16:40,300
the consistency of values so you in the

00:16:37,900 --> 00:16:43,060
open API spec if you gives you types and

00:16:40,300 --> 00:16:45,010
structure but how do you do it deal with

00:16:43,060 --> 00:16:47,950
values especially like consistency

00:16:45,010 --> 00:16:49,330
between different fields reply yes

00:16:47,950 --> 00:16:51,550
that's a very good question and that's

00:16:49,330 --> 00:16:54,730
exactly one of the limitations of this

00:16:51,550 --> 00:16:56,770
approach so when when you when you read

00:16:54,730 --> 00:16:59,410
about contract testing it's it's not

00:16:56,770 --> 00:17:02,200
about the specific values so this won't

00:16:59,410 --> 00:17:04,329
test it it's not you're not able to well

00:17:02,200 --> 00:17:06,520
within swagger open API you you are able

00:17:04,329 --> 00:17:08,260
to set some restrictions for values and

00:17:06,520 --> 00:17:10,540
so we we will actually test for those

00:17:08,260 --> 00:17:14,430
but yeah like fields that depend on each

00:17:10,540 --> 00:17:17,470
other strings that have like an

00:17:14,430 --> 00:17:18,310
elaborate meaning like locales or

00:17:17,470 --> 00:17:21,100
something like that

00:17:18,310 --> 00:17:23,230
it won't be covered here you'll need to

00:17:21,100 --> 00:17:25,720
do more elaborate testing for that and

00:17:23,230 --> 00:17:27,640
maybe you need like something that is

00:17:25,720 --> 00:17:31,780
more like an end-to-end test to to do

00:17:27,640 --> 00:17:34,360
these sorts of verifications I was going

00:17:31,780 --> 00:17:36,220
to ask about the open ipi spec and I

00:17:34,360 --> 00:17:39,250
noticed you probably use swagger which

00:17:36,220 --> 00:17:40,420
is opening API spec 2-0 right so you

00:17:39,250 --> 00:17:42,460
have a chance to actually ruin something

00:17:40,420 --> 00:17:45,580
for my company because we just finished

00:17:42,460 --> 00:17:48,430
writing our like client library system

00:17:45,580 --> 00:17:50,710
for open API specs free zero and last

00:17:48,430 --> 00:17:53,320
time we look into bravado it didn't have

00:17:50,710 --> 00:17:54,940
any chance of appearing there so do you

00:17:53,320 --> 00:17:56,740
know anything about plans in profit to

00:17:54,940 --> 00:17:58,630
actually support the newest open API

00:17:56,740 --> 00:18:00,730
spec yeah that's a good question

00:17:58,630 --> 00:18:04,330
unfortunately currently there are no

00:18:00,730 --> 00:18:07,720
plans so if you want to use the newest

00:18:04,330 --> 00:18:10,330
spec test other tools out there that was

00:18:07,720 --> 00:18:12,070
actually a talk by I forgot the name

00:18:10,330 --> 00:18:14,080
like yes there's actually people like

00:18:12,070 --> 00:18:17,010
doing create Python development for open

00:18:14,080 --> 00:18:19,540
API 3 so there's like I think there's

00:18:17,010 --> 00:18:22,780
tooling like bravado I don't know if

00:18:19,540 --> 00:18:25,720
it's as the official generator but like

00:18:22,780 --> 00:18:28,090
no one likes cogeneration so yeah yeah

00:18:25,720 --> 00:18:31,150
and I think somebody also did like a

00:18:28,090 --> 00:18:33,370
pyramid integration for open API 3 so

00:18:31,150 --> 00:18:35,230
yes if you

00:18:33,370 --> 00:18:37,750
why're that currently at Yelp we don't

00:18:35,230 --> 00:18:39,880
have tooling around that so ours is

00:18:37,750 --> 00:18:45,340
still about the version 2 of the spec

00:18:39,880 --> 00:18:47,740
thanks you mentioned that you record

00:18:45,340 --> 00:18:50,590
your requests and responses in and turn

00:18:47,740 --> 00:18:53,200
tests we actually do a fairly similar

00:18:50,590 --> 00:18:56,830
thing and I was just I'm just curious

00:18:53,200 --> 00:19:01,090
about your opinion so essentially as

00:18:56,830 --> 00:19:03,880
part of our tests we run tests against

00:19:01,090 --> 00:19:05,770
the API of each service using a tool

00:19:03,880 --> 00:19:08,740
called hoverfly I don't know if you're

00:19:05,770 --> 00:19:12,220
familiar which essentially records

00:19:08,740 --> 00:19:14,980
requests and responses as well and as

00:19:12,220 --> 00:19:17,830
part of our build artifact we publish

00:19:14,980 --> 00:19:20,530
the recordings of that service of

00:19:17,830 --> 00:19:23,260
requests and responses which is then

00:19:20,530 --> 00:19:26,020
consumed by other builds so in our

00:19:23,260 --> 00:19:28,060
continuous integration platform when one

00:19:26,020 --> 00:19:31,240
service is built and changes interface

00:19:28,060 --> 00:19:33,730
its recordings will change and any

00:19:31,240 --> 00:19:37,540
service dependent on that will pick up

00:19:33,730 --> 00:19:39,790
the recordings and run it's sort of

00:19:37,540 --> 00:19:40,690
integration tests against these

00:19:39,790 --> 00:19:43,350
recordings

00:19:40,690 --> 00:19:47,740
have you tried something like that I

00:19:43,350 --> 00:19:49,450
think that's a great idea No so up to

00:19:47,740 --> 00:19:51,580
the point of sharing that between

00:19:49,450 --> 00:19:55,510
services that's pretty much what we do

00:19:51,580 --> 00:19:58,000
as well but we haven't looked into

00:19:55,510 --> 00:19:59,980
sharing that between services yet like

00:19:58,000 --> 00:20:02,290
because what we did is like I mentioned

00:19:59,980 --> 00:20:04,600
we actually like have stuff like we

00:20:02,290 --> 00:20:06,760
added stuff to PI tests so like with

00:20:04,600 --> 00:20:08,920
each request it sends like the context

00:20:06,760 --> 00:20:10,920
of the test so that because like

00:20:08,920 --> 00:20:13,270
oftentimes you do multiple calls right

00:20:10,920 --> 00:20:15,040
but yeah I mean that sounds like like a

00:20:13,270 --> 00:20:18,130
great idea to like further enhance

00:20:15,040 --> 00:20:21,340
enhance the system it does take several

00:20:18,130 --> 00:20:23,680
processes though essentially you spin it

00:20:21,340 --> 00:20:26,050
up as a separate docker container and

00:20:23,680 --> 00:20:29,440
use it as a proxy that then records or

00:20:26,050 --> 00:20:32,530
mocks out any replies yeah I mean that's

00:20:29,440 --> 00:20:34,180
that's the same force like the test

00:20:32,530 --> 00:20:36,190
recording and replaying that's still

00:20:34,180 --> 00:20:39,390
multi-process for sure yeah absolutely

00:20:36,190 --> 00:20:39,390
ok great thank you

00:20:39,650 --> 00:20:51,679
any other questions thanks for a great

00:20:46,940 --> 00:20:55,929
talk have you consider its part above in

00:20:51,679 --> 00:21:02,270
stitch your York audits by yourself

00:20:55,929 --> 00:21:09,970
library its mites client I mean pretty

00:21:02,270 --> 00:21:15,340
buff can do client and without any

00:21:09,970 --> 00:21:18,020
efforts yeah so um that's I think mostly

00:21:15,340 --> 00:21:20,299
historical decision please I hope I'm

00:21:18,020 --> 00:21:21,980
answering the question correctly your

00:21:20,299 --> 00:21:23,270
question was about like why don't we

00:21:21,980 --> 00:21:25,880
have like a different system for

00:21:23,270 --> 00:21:27,980
generating clients right so that's

00:21:25,880 --> 00:21:29,710
absolutely something we looked into and

00:21:27,980 --> 00:21:32,210
that we might actually do in the future

00:21:29,710 --> 00:21:34,190
so the way privado works internally is

00:21:32,210 --> 00:21:37,270
actually like very dynamic whereas

00:21:34,190 --> 00:21:40,580
inside yelp we have switched to these

00:21:37,270 --> 00:21:41,990
static client libraries that still use

00:21:40,580 --> 00:21:43,700
privado internally but actually don't

00:21:41,990 --> 00:21:45,890
use the dynamic nature of privado

00:21:43,700 --> 00:21:48,260
anymore so that's definitely I think

00:21:45,890 --> 00:21:50,630
that's mainly due to the effort involved

00:21:48,260 --> 00:21:52,279
in in changing that why we haven't done

00:21:50,630 --> 00:21:56,559
that yet but that would definitely be

00:21:52,279 --> 00:21:56,559
like you suggested a great improvement

00:21:59,890 --> 00:22:08,120
hi thanks for your talk do you use any

00:22:04,419 --> 00:22:10,460
strategy for sharing schema and and

00:22:08,120 --> 00:22:14,899
forces schema between different micro

00:22:10,460 --> 00:22:25,940
services but to implement API guidelines

00:22:14,899 --> 00:22:28,159
inside your company I don't know about

00:22:25,940 --> 00:22:30,679
simplified or streamlined what we do

00:22:28,159 --> 00:22:33,200
have is a central repository where each

00:22:30,679 --> 00:22:35,450
version of each service specification

00:22:33,200 --> 00:22:38,270
gets posted to so you can imagine that

00:22:35,450 --> 00:22:40,669
as really just a version git repository

00:22:38,270 --> 00:22:43,970
and whenever developers make a change to

00:22:40,669 --> 00:22:46,279
an API specification a new version for

00:22:43,970 --> 00:22:48,200
that service will be posted there so we

00:22:46,279 --> 00:22:51,200
definitely after tooling for you to

00:22:48,200 --> 00:22:52,909
interact with these API specifications

00:22:51,200 --> 00:22:54,470
and figure out what chain

00:22:52,909 --> 00:22:57,139
and things like that that's actually how

00:22:54,470 --> 00:22:58,340
we implemented the tool that detects

00:22:57,139 --> 00:23:00,499
whether you're doing a backwards

00:22:58,340 --> 00:23:02,749
incompatible change it actually looks at

00:23:00,499 --> 00:23:05,359
the code as it is now

00:23:02,749 --> 00:23:07,489
just like the Gamo or json for the spec

00:23:05,359 --> 00:23:08,499
and then fetches previous versions and

00:23:07,489 --> 00:23:12,529
things like that

00:23:08,499 --> 00:23:15,109
yeah but in in the end it doesn't really

00:23:12,529 --> 00:23:18,049
for example it doesn't help for having

00:23:15,109 --> 00:23:22,779
for making sure that that all of our api

00:23:18,049 --> 00:23:22,779
specs are consistent things like that

00:23:23,440 --> 00:23:32,120
any more questions not the case so let's

00:23:29,090 --> 00:23:35,830
think Jeff and again for us my stuff

00:23:32,120 --> 00:23:35,830

YouTube URL: https://www.youtube.com/watch?v=5NV5QWMGzcc


