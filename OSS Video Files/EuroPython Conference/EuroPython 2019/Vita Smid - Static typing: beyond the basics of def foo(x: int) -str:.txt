Title: Vita Smid - Static typing: beyond the basics of def foo(x: int) -str:
Publication date: 2019-09-23
Playlist: EuroPython 2019
Description: 
	"Static typing: beyond the basics of def foo(x: int) -str:
[EuroPython 2019 - Talk - 2019-07-10 - Boston]
[Basel, CH]

By Vita Smid

The Python community has been warming up to static typing for a few years now. You may have seen talks that did a great job of introducing the basic concepts, mypy, and high-level strategies to cover existing code bases.

We need to go deeper.

Let’s talk about the challenges you inevitably encounter when you try to type-check a large code base. One full of many moving parts, complex architectures, metaprogramming tricks, and interfaces with a dozen other packages.

Static type checking is very powerful – when you use it to maximum advantage and explain your code to the typechecker accurately. We will cover a few tools at your disposal: generics, signature overloads, protocols, custom mypy plug-ins, and more.

There is more than just tools, though. Behind them all are universal concepts valid in any language. I hope to convince you that thinking in terms of the type system helps you write better code…



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/
Captions: 
	00:00:02,939 --> 00:00:09,690
how many of you already use my two to

00:00:06,450 --> 00:00:13,200
check your production code wow that's

00:00:09,690 --> 00:00:16,199
quite a lot for those who aren't this

00:00:13,200 --> 00:00:18,599
might be a little bit steep in the

00:00:16,199 --> 00:00:21,499
beginning but I hope I won't scare you

00:00:18,599 --> 00:00:24,960
away from my buyer

00:00:21,499 --> 00:00:28,679
my name is Vita I'm a software engineer

00:00:24,960 --> 00:00:31,259
and now a co-founder of of a company

00:00:28,679 --> 00:00:34,850
called corn plain we started five years

00:00:31,259 --> 00:00:38,370
ago and what we do is we trade stocks

00:00:34,850 --> 00:00:42,120
mostly in Europe and we do that

00:00:38,370 --> 00:00:46,410
automatically and semi-automatically we

00:00:42,120 --> 00:00:50,520
are based in Prague and everything we do

00:00:46,410 --> 00:00:53,610
on the back end is in Python 3.7 at this

00:00:50,520 --> 00:00:57,480
point and we also happen to use a lot of

00:00:53,610 --> 00:00:59,490
async IO and I like to think we were

00:00:57,480 --> 00:01:05,670
very early to start using type

00:00:59,490 --> 00:01:09,899
annotations and my PI so static typing

00:01:05,670 --> 00:01:13,109
is still quite anything to the Python

00:01:09,899 --> 00:01:16,020
ecosystem and the community we're still

00:01:13,109 --> 00:01:21,049
learning how to use it and the tooling

00:01:16,020 --> 00:01:24,329
is still being actively developed and

00:01:21,049 --> 00:01:27,810
for those reasons it is sometimes a bit

00:01:24,329 --> 00:01:32,359
difficult to maybe not get started with

00:01:27,810 --> 00:01:37,709
static typing but to actually cover

00:01:32,359 --> 00:01:41,789
complex code bases with static types but

00:01:37,709 --> 00:01:44,819
despite these challenges I believe it is

00:01:41,789 --> 00:01:48,179
really worth it because when it is done

00:01:44,819 --> 00:01:51,119
properly it can help you avoid a lot of

00:01:48,179 --> 00:01:53,429
mistakes and in the box before you even

00:01:51,119 --> 00:01:59,039
run your program before you even run

00:01:53,429 --> 00:02:03,950
your unit tests I'm going to talk and

00:01:59,039 --> 00:02:06,899
two chapters the first one is the

00:02:03,950 --> 00:02:09,780
high-level approach you might want to

00:02:06,899 --> 00:02:12,300
take when you when you have a big

00:02:09,780 --> 00:02:13,980
codebase and you want to cover it with

00:02:12,300 --> 00:02:18,299
my pie

00:02:13,980 --> 00:02:21,930
and then we'll talk about a few examples

00:02:18,299 --> 00:02:24,750
of code that is not the usual hello

00:02:21,930 --> 00:02:30,450
world function and how you might go on

00:02:24,750 --> 00:02:32,340
about typing that and in the end I'll

00:02:30,450 --> 00:02:34,069
remind you that it really is worth it

00:02:32,340 --> 00:02:42,840
even though it will look a bit

00:02:34,069 --> 00:02:44,519
complicated sometimes so I mentioned

00:02:42,840 --> 00:02:48,329
before that we started using static

00:02:44,519 --> 00:02:50,549
typing quite early at a point where we

00:02:48,329 --> 00:02:54,870
already had a couple hundred thousand

00:02:50,549 --> 00:02:57,840
lines of code and my vibe was very early

00:02:54,870 --> 00:03:00,440
back then and it's it was crashing on

00:02:57,840 --> 00:03:03,750
the code I don't mean spitting out

00:03:00,440 --> 00:03:08,549
typing errors but actually crashing so

00:03:03,750 --> 00:03:15,120
we had to start gradually and only cover

00:03:08,549 --> 00:03:17,970
our code step by step and a big lesson

00:03:15,120 --> 00:03:20,700
we learned unfortunately not in the

00:03:17,970 --> 00:03:23,700
beginning but over time was that the

00:03:20,700 --> 00:03:26,130
default mypie configuration is quite

00:03:23,700 --> 00:03:28,739
lenient and if you don't make it

00:03:26,130 --> 00:03:32,250
slightly stricter than the default is

00:03:28,739 --> 00:03:35,010
you might learn a few bad habits that

00:03:32,250 --> 00:03:37,440
will come and bite you later and you

00:03:35,010 --> 00:03:40,290
will still have to fix your code and

00:03:37,440 --> 00:03:45,690
their annotations so I would recommend

00:03:40,290 --> 00:03:48,780
you whatever the code is that you're

00:03:45,690 --> 00:03:50,910
going to run my file on I would

00:03:48,780 --> 00:03:53,790
recommend you to have full coverage

00:03:50,910 --> 00:03:56,760
meaning there are no functions which

00:03:53,790 --> 00:03:59,790
have no type annotations or partial

00:03:56,760 --> 00:04:03,709
annotations so these are the config

00:03:59,790 --> 00:04:03,709
options you you might use for that

00:04:03,950 --> 00:04:10,980
second these are optional but you might

00:04:07,919 --> 00:04:14,220
want to consider them these restrict

00:04:10,980 --> 00:04:18,389
some forms of dynamic typing in your

00:04:14,220 --> 00:04:21,720
code some of these options are difficult

00:04:18,389 --> 00:04:23,380
to enable but if you can do it or if

00:04:21,720 --> 00:04:29,980
you're starting with a new code base

00:04:23,380 --> 00:04:33,730
definitely use them and this you really

00:04:29,980 --> 00:04:36,490
want to do with my pie and and static

00:04:33,730 --> 00:04:39,250
typing it's sometimes easy to fall into

00:04:36,490 --> 00:04:41,350
a trap where you think you know what

00:04:39,250 --> 00:04:44,830
you're doing on youth or you think you

00:04:41,350 --> 00:04:47,230
know what my bi is doing and it might

00:04:44,830 --> 00:04:49,900
not immediately tell you that your

00:04:47,230 --> 00:04:52,120
understanding is not quite correct so

00:04:49,900 --> 00:04:54,330
enabling some warnings will help you

00:04:52,120 --> 00:04:54,330
with that

00:04:56,850 --> 00:05:03,280
since covering an existing large code

00:05:00,820 --> 00:05:04,750
base is a huge amount of work you want

00:05:03,280 --> 00:05:09,070
to go step by step

00:05:04,750 --> 00:05:11,440
so you begin by opting in meaning urine

00:05:09,070 --> 00:05:17,230
might bite only on the modules you've

00:05:11,440 --> 00:05:20,230
already covered and you might even start

00:05:17,230 --> 00:05:22,990
with a single module with a very small

00:05:20,230 --> 00:05:26,530
step and then you then you just keep

00:05:22,990 --> 00:05:29,320
adding on and you want to defend your

00:05:26,530 --> 00:05:32,410
progress by adding this check in to your

00:05:29,320 --> 00:05:34,750
CI pipeline so it runs before your test

00:05:32,410 --> 00:05:36,850
to do and then of course you never want

00:05:34,750 --> 00:05:39,850
to make that list smaller you only ever

00:05:36,850 --> 00:05:42,520
want to expand it what worked well for

00:05:39,850 --> 00:05:44,380
us was doing an internal hackathon where

00:05:42,520 --> 00:05:48,580
a couple of developers stayed at the

00:05:44,380 --> 00:05:51,970
office overnight and worked hard to to

00:05:48,580 --> 00:05:54,430
increase our coverage and we're still

00:05:51,970 --> 00:06:01,300
not completely there so we might have to

00:05:54,430 --> 00:06:03,400
do a few more sleepovers when you go the

00:06:01,300 --> 00:06:06,910
opt-in route you need to deal with

00:06:03,400 --> 00:06:09,730
imports because you are covering maybe

00:06:06,910 --> 00:06:12,850
just a few modules but those modules

00:06:09,730 --> 00:06:15,790
might be importing other code which you

00:06:12,850 --> 00:06:18,460
maybe are not ready to check in the

00:06:15,790 --> 00:06:22,630
beginning so this is how you tell my bi

00:06:18,460 --> 00:06:27,430
to not complain too much about other

00:06:22,630 --> 00:06:30,910
modules a word of warning that follow

00:06:27,430 --> 00:06:34,930
imports directive has another option

00:06:30,910 --> 00:06:37,200
called skip the documentation warns you

00:06:34,930 --> 00:06:42,080
not to use that we did

00:06:37,200 --> 00:06:45,210
and it was a terrible idea don't do it

00:06:42,080 --> 00:06:47,130
at some point when your opt-in list is

00:06:45,210 --> 00:06:49,140
sufficiently long you might you

00:06:47,130 --> 00:06:52,260
definitely want to switch to opt-out

00:06:49,140 --> 00:06:56,640
meaning you're on my PI on everything by

00:06:52,260 --> 00:07:00,570
default except for some modules that you

00:06:56,640 --> 00:07:04,020
exclude in your config and of course

00:07:00,570 --> 00:07:06,000
there might be dozens of these ignored

00:07:04,020 --> 00:07:08,430
modules in the beginning when your

00:07:06,000 --> 00:07:11,490
exclude list is huge but then of course

00:07:08,430 --> 00:07:14,210
over time you work to make that list

00:07:11,490 --> 00:07:17,730
smaller and smaller until it disappears

00:07:14,210 --> 00:07:20,460
the benefit of getting to opt-out is

00:07:17,730 --> 00:07:23,790
that any new code you add to your any

00:07:20,460 --> 00:07:27,080
new modules you add to your project will

00:07:23,790 --> 00:07:27,080
be checked by default

00:07:28,640 --> 00:07:40,200
covering unit tests is a tricky matter

00:07:35,960 --> 00:07:42,030
despite me recommending or strict strict

00:07:40,200 --> 00:07:44,870
configuration from my PI

00:07:42,030 --> 00:07:47,820
I will backtrack on that for tests and

00:07:44,870 --> 00:07:52,380
just make my PI a little bit more

00:07:47,820 --> 00:07:55,050
lenient for reasons explained in this

00:07:52,380 --> 00:07:57,150
code sample by the way I'm going to put

00:07:55,050 --> 00:07:59,700
the slides up online so you don't have

00:07:57,150 --> 00:08:04,890
to date photos of everything there will

00:07:59,700 --> 00:08:07,710
be a lot of configuration and code when

00:08:04,890 --> 00:08:10,470
you use mocks and monkey patching in

00:08:07,710 --> 00:08:13,290
your tests which you often do there is

00:08:10,470 --> 00:08:16,170
no way to explain that to my PI as of

00:08:13,290 --> 00:08:20,670
yet it is a very complicated problem see

00:08:16,170 --> 00:08:26,700
so you just need to ignore those places

00:08:20,670 --> 00:08:28,980
where were you monkey patch but despite

00:08:26,700 --> 00:08:31,700
these challenges I would urge you not to

00:08:28,980 --> 00:08:34,890
ignore all your test files completely

00:08:31,700 --> 00:08:36,660
because even when you partially cover

00:08:34,890 --> 00:08:39,479
them with my PI you will get some

00:08:36,660 --> 00:08:41,630
benefits because my PI will be able to

00:08:39,479 --> 00:08:44,889
check that your tests are using your

00:08:41,630 --> 00:08:46,779
your tested code as

00:08:44,889 --> 00:08:51,519
intended meaning the annotations are

00:08:46,779 --> 00:08:55,540
being respected if you build your own

00:08:51,519 --> 00:08:57,970
Python packages you should know that

00:08:55,540 --> 00:09:00,249
even when they do you have type

00:08:57,970 --> 00:09:03,129
annotations in their code and mypie

00:09:00,249 --> 00:09:05,859
passes on them if you use that package

00:09:03,129 --> 00:09:08,169
somewhere else my pie will not follow

00:09:05,859 --> 00:09:10,389
those annotations by default so you need

00:09:08,169 --> 00:09:13,029
to tell it it's very simple you just

00:09:10,389 --> 00:09:17,139
need a marker file added to the package

00:09:13,029 --> 00:09:19,899
and that's it but unless you do that you

00:09:17,139 --> 00:09:23,019
don't benefit from from annotations and

00:09:19,899 --> 00:09:28,199
packages when you use third-party

00:09:23,019 --> 00:09:31,419
packages which might not have type hints

00:09:28,199 --> 00:09:34,089
there's a few options you have you might

00:09:31,419 --> 00:09:38,679
write stubs this is something we don't

00:09:34,089 --> 00:09:40,809
really do so I won't go into detail you

00:09:38,679 --> 00:09:46,239
might want to ignore all third-party

00:09:40,809 --> 00:09:49,209
packages or better use ignore again very

00:09:46,239 --> 00:09:56,009
explicitly ignore just those that don't

00:09:49,209 --> 00:09:59,889
have annotations so now that you know

00:09:56,009 --> 00:10:01,779
generally how to approach a codebase we

00:09:59,889 --> 00:10:05,249
can talk about a few examples of what

00:10:01,779 --> 00:10:05,249
you might find in your codebase

00:10:08,070 --> 00:10:15,480
the first example a very useful

00:10:12,630 --> 00:10:20,220
frequently used tool generics and type

00:10:15,480 --> 00:10:23,490
variables who here has heard of these or

00:10:20,220 --> 00:10:26,160
maybe even used them wow that's that's

00:10:23,490 --> 00:10:31,050
really good I think this is one of the

00:10:26,160 --> 00:10:32,760
most useful and needed features let's

00:10:31,050 --> 00:10:36,540
take the example of a weighted average

00:10:32,760 --> 00:10:39,210
which is a very simple formula simple

00:10:36,540 --> 00:10:42,740
computation where you add up values and

00:10:39,210 --> 00:10:45,060
you average them using weights and

00:10:42,740 --> 00:10:49,170
critically we will want to implement

00:10:45,060 --> 00:10:51,660
this average as incrementally updatable

00:10:49,170 --> 00:10:54,890
meaning you can keep on adding values to

00:10:51,660 --> 00:10:58,260
the average and getting back the result

00:10:54,890 --> 00:11:00,810
so you might start by writing a very

00:10:58,260 --> 00:11:04,110
simple class for example that starts

00:11:00,810 --> 00:11:07,590
with some internal pre computed values

00:11:04,110 --> 00:11:10,320
and you will be able to add a weighted

00:11:07,590 --> 00:11:15,090
value to the class up to the to the

00:11:10,320 --> 00:11:16,890
average and then you just add a simple

00:11:15,090 --> 00:11:20,940
method that that can calculate the

00:11:16,890 --> 00:11:24,510
average at any time you will notice that

00:11:20,940 --> 00:11:28,590
we are using floats as the data type in

00:11:24,510 --> 00:11:30,330
there so we are explicitly saying that

00:11:28,590 --> 00:11:35,280
we can only calculate averages for

00:11:30,330 --> 00:11:37,050
floats but imagine you not only want to

00:11:35,280 --> 00:11:40,530
do that but you might also want to use

00:11:37,050 --> 00:11:44,600
decimals which is a an arbitrary

00:11:40,530 --> 00:11:48,000
precision data type in Python so of

00:11:44,600 --> 00:11:50,160
course as written as annotated that

00:11:48,000 --> 00:11:53,640
class will work for floats as expected

00:11:50,160 --> 00:11:55,440
and of course it will not work in

00:11:53,640 --> 00:11:59,550
decimals because you said your values

00:11:55,440 --> 00:12:02,400
were going to be floats by the way the

00:11:59,550 --> 00:12:06,060
revealed type function is extremely

00:12:02,400 --> 00:12:08,490
useful that is provided by my PI so it's

00:12:06,060 --> 00:12:11,610
undefined at runtime but for debugging

00:12:08,490 --> 00:12:15,320
what might buy things your variables are

00:12:11,610 --> 00:12:15,320
it is a very useful function

00:12:16,250 --> 00:12:24,080
if you want to allow floats or decimals

00:12:19,820 --> 00:12:26,450
a good good way to do that is to

00:12:24,080 --> 00:12:29,540
parameterize your your weighted average

00:12:26,450 --> 00:12:33,910
so you make it a so-called generic class

00:12:29,540 --> 00:12:36,710
and you say it is permit rised by this

00:12:33,910 --> 00:12:39,680
type variable which we called algebra

00:12:36,710 --> 00:12:42,680
type in this example and we restricted

00:12:39,680 --> 00:12:48,080
that type variable to either be a float

00:12:42,680 --> 00:12:50,570
or a decimal then your original class

00:12:48,080 --> 00:12:53,840
will be very similar to the previous

00:12:50,570 --> 00:12:57,080
version but you will suddenly have a

00:12:53,840 --> 00:12:58,880
small trouble with the number zero by

00:12:57,080 --> 00:13:02,930
the way this code block contains a very

00:12:58,880 --> 00:13:04,550
small lie maybe some of you can see it

00:13:02,930 --> 00:13:08,030
but it's not very important at this

00:13:04,550 --> 00:13:10,370
point it works and then in the rest of

00:13:08,030 --> 00:13:13,670
your class instead of saying float you

00:13:10,370 --> 00:13:17,330
will be saying algebra type so you've

00:13:13,670 --> 00:13:20,060
permit rised the type now when you want

00:13:17,330 --> 00:13:23,690
to use that class when you instantiate

00:13:20,060 --> 00:13:27,050
it you need to add the value for that

00:13:23,690 --> 00:13:31,070
type parameter when you create the

00:13:27,050 --> 00:13:33,440
instance like this so the first few

00:13:31,070 --> 00:13:37,250
lines are a weighted average of floats

00:13:33,440 --> 00:13:39,950
and you can see that it also returns a

00:13:37,250 --> 00:13:43,910
float and of course the second part is a

00:13:39,950 --> 00:13:46,160
weighted average of decimals what is

00:13:43,910 --> 00:13:48,620
nice is once you create a weighted

00:13:46,160 --> 00:13:50,330
average of a certain type you cannot

00:13:48,620 --> 00:13:55,400
change your mind and start mixing the

00:13:50,330 --> 00:13:59,110
times that is desired there is an even

00:13:55,400 --> 00:14:03,560
possibly nicer and cleaner solution

00:13:59,110 --> 00:14:05,480
which is to say actually what I need to

00:14:03,560 --> 00:14:08,300
do with my numbers is to add them

00:14:05,480 --> 00:14:10,040
multiply and divide them so I don't care

00:14:08,300 --> 00:14:12,020
if those are floats or decimals or

00:14:10,040 --> 00:14:15,170
something else ideally I would just say

00:14:12,020 --> 00:14:17,600
there are real numbers so in theory that

00:14:15,170 --> 00:14:20,750
sounds great but in practice the

00:14:17,600 --> 00:14:23,360
abstract number types in Python don't

00:14:20,750 --> 00:14:27,560
really work that well or aren't that

00:14:23,360 --> 00:14:32,030
useful yet and this is a good example of

00:14:27,560 --> 00:14:38,360
of typing in Python being quite

00:14:32,030 --> 00:14:40,970
pragmatic it isn't an ideal world it is

00:14:38,360 --> 00:14:42,920
a pragmatic world and you need to be

00:14:40,970 --> 00:14:45,410
pragmatic to you so your type

00:14:42,920 --> 00:14:47,810
annotations often won't be perfect they

00:14:45,410 --> 00:14:51,730
won't perfectly describe what you had in

00:14:47,810 --> 00:14:51,730
mind but they will approximate it

00:14:53,620 --> 00:15:01,210
another very important examples example

00:14:57,770 --> 00:15:05,240
is understanding the difference between

00:15:01,210 --> 00:15:08,090
nominal and structural typing so these

00:15:05,240 --> 00:15:11,780
are fancy sounding words but it's

00:15:08,090 --> 00:15:14,870
nothing complicated nominal typing you

00:15:11,780 --> 00:15:20,120
already know that's that deals with

00:15:14,870 --> 00:15:22,160
class inheritance so animal examples

00:15:20,120 --> 00:15:25,810
seem to be popular in computer science

00:15:22,160 --> 00:15:29,300
for some reason so I went with one and

00:15:25,810 --> 00:15:32,060
there's a base class of an animal and

00:15:29,300 --> 00:15:34,310
then we have a duck that apart from

00:15:32,060 --> 00:15:38,750
whatever behavior animal has can also

00:15:34,310 --> 00:15:41,120
quack and then suppose we want to make a

00:15:38,750 --> 00:15:46,910
function that accepts something that can

00:15:41,120 --> 00:15:49,550
quack and make it quack so as annotated

00:15:46,910 --> 00:15:51,410
here this works because it's it's very

00:15:49,550 --> 00:15:53,839
trivial you're just telling my point

00:15:51,410 --> 00:15:59,530
that your function needs a duck because

00:15:53,839 --> 00:16:02,480
only Dax can quad and and that classes

00:15:59,530 --> 00:16:04,550
however imagine you wanted to have

00:16:02,480 --> 00:16:06,650
another animal that can quack and you

00:16:04,550 --> 00:16:10,760
want that function to work for that

00:16:06,650 --> 00:16:13,550
animal too so we could create a penguin

00:16:10,760 --> 00:16:17,330
which possibly makes sounds close to

00:16:13,550 --> 00:16:19,520
quacking but it would be wrong to

00:16:17,330 --> 00:16:20,240
inherit that from a duck that would be

00:16:19,520 --> 00:16:23,120
very wrong

00:16:20,240 --> 00:16:25,220
so you just inherit from animal but then

00:16:23,120 --> 00:16:27,200
of course your make it quack function

00:16:25,220 --> 00:16:28,930
doesn't work because it was told to

00:16:27,200 --> 00:16:34,820
expect ducks

00:16:28,930 --> 00:16:37,160
so nominal typing means you use you use

00:16:34,820 --> 00:16:41,110
classes and class hierarchy when

00:16:37,160 --> 00:16:41,110
specifying the types you need

00:16:41,540 --> 00:16:48,860
in contrast to that we can be talking

00:16:46,310 --> 00:16:51,110
about structural typing where you where

00:16:48,860 --> 00:16:54,440
you describe your types in terms of the

00:16:51,110 --> 00:16:57,610
capabilities they have so here you're

00:16:54,440 --> 00:17:00,440
creating a thing called protocol in

00:16:57,610 --> 00:17:04,900
other languages you might have heard the

00:17:00,440 --> 00:17:09,110
term an interface or maybe a trait and

00:17:04,900 --> 00:17:12,020
this this is actual code those free dots

00:17:09,110 --> 00:17:14,390
are valid Python syntax in case you

00:17:12,020 --> 00:17:16,939
didn't know and this really just tells

00:17:14,390 --> 00:17:21,410
my wire that there is an interface or

00:17:16,939 --> 00:17:26,809
protocol called can't walk which exposes

00:17:21,410 --> 00:17:30,679
a public method called quack and when we

00:17:26,809 --> 00:17:32,929
declared this and change our function

00:17:30,679 --> 00:17:36,650
slightly so it now accepts something

00:17:32,929 --> 00:17:40,550
anything that can quack then this will

00:17:36,650 --> 00:17:42,440
work for both animals and the

00:17:40,550 --> 00:17:45,500
interesting thing is that we didn't have

00:17:42,440 --> 00:17:48,080
to inherit from that protocol that

00:17:45,500 --> 00:17:52,280
protocol is a class but that is more of

00:17:48,080 --> 00:17:54,980
a syntactic convenience and now any

00:17:52,280 --> 00:17:58,190
object that will have a quack method

00:17:54,980 --> 00:18:02,420
will meet the requirements of this

00:17:58,190 --> 00:18:06,610
function so this is very useful for for

00:18:02,420 --> 00:18:06,610
duck typing pun intended

00:18:10,910 --> 00:18:19,680
another example we encountered is when

00:18:14,100 --> 00:18:21,870
you want to somewhat define your own

00:18:19,680 --> 00:18:26,430
type without creating an entirely new

00:18:21,870 --> 00:18:29,220
time a very simple example of that is

00:18:26,430 --> 00:18:31,920
when you have a function called place

00:18:29,220 --> 00:18:35,520
order maybe that accepts a price and

00:18:31,920 --> 00:18:41,280
quantity of some Goods that you're

00:18:35,520 --> 00:18:43,320
buying maybe and it doesn't matter what

00:18:41,280 --> 00:18:47,130
it does with that maybe it will save it

00:18:43,320 --> 00:18:48,570
in a database or whatever and wouldn't

00:18:47,130 --> 00:18:51,660
it be nice if we could somehow

00:18:48,570 --> 00:18:55,350
differentiate between a price decimal

00:18:51,660 --> 00:18:58,280
and a quantity decimal they really are

00:18:55,350 --> 00:19:00,960
just decimals but there is a very clear

00:18:58,280 --> 00:19:05,490
semantic difference between prices and

00:19:00,960 --> 00:19:08,340
quantities if we could do that it would

00:19:05,490 --> 00:19:10,020
make our code more readable because when

00:19:08,340 --> 00:19:12,570
you read those annotations you will

00:19:10,020 --> 00:19:14,820
clearly see this is of type price and

00:19:12,570 --> 00:19:18,750
this is of type desc of type quantity

00:19:14,820 --> 00:19:20,370
and it would also make it hard to mix

00:19:18,750 --> 00:19:22,500
them up so you wouldn't be able to

00:19:20,370 --> 00:19:27,750
accidentally pass a quantity in place of

00:19:22,500 --> 00:19:29,520
price I I come from a company that

00:19:27,750 --> 00:19:33,240
trades into financial markets and

00:19:29,520 --> 00:19:35,820
confusing prices and quantities or buy

00:19:33,240 --> 00:19:41,550
and sell is not a mistake you want to

00:19:35,820 --> 00:19:45,780
make so the first option that you might

00:19:41,550 --> 00:19:49,110
think of is to alias a type so you say

00:19:45,780 --> 00:19:50,940
there is there is something called price

00:19:49,110 --> 00:19:52,590
and it really is equal to decimal and

00:19:50,940 --> 00:19:56,040
then you can use that price is a

00:19:52,590 --> 00:19:59,070
constructor but that works but

00:19:56,040 --> 00:20:01,050
unfortunately that doesn't create a new

00:19:59,070 --> 00:20:03,930
type this is just a convenience for you

00:20:01,050 --> 00:20:05,820
so you don't have to type so much it

00:20:03,930 --> 00:20:07,680
does make it a code easier to read when

00:20:05,820 --> 00:20:11,160
you suddenly start writing price instead

00:20:07,680 --> 00:20:14,540
of decimal but as for type safety you

00:20:11,160 --> 00:20:14,540
get absolutely no benefit

00:20:15,170 --> 00:20:21,070
another option that exists in the typing

00:20:17,750 --> 00:20:25,340
module is a function called new type

00:20:21,070 --> 00:20:30,950
which kind of aliases an existing type

00:20:25,340 --> 00:20:33,980
but it is a true alias in the sense that

00:20:30,950 --> 00:20:39,920
my PI now and understands that it is a

00:20:33,980 --> 00:20:41,810
price and not a decimal so what what

00:20:39,920 --> 00:20:43,640
this does is you can still create

00:20:41,810 --> 00:20:47,600
decimals but then you need to wrap them

00:20:43,640 --> 00:20:50,780
in your price type and from that point

00:20:47,600 --> 00:20:55,130
onwards my buy knows it's a price not a

00:20:50,780 --> 00:20:57,830
decimal and if we define a function that

00:20:55,130 --> 00:21:02,150
takes a price you will see you can't

00:20:57,830 --> 00:21:04,820
pass a bare decimal to it and you can

00:21:02,150 --> 00:21:07,280
even pass a quantity to it even though

00:21:04,820 --> 00:21:10,580
it really is another decimal so this is

00:21:07,280 --> 00:21:14,540
what we wanted and we are now able to

00:21:10,580 --> 00:21:17,930
differentiate between the types this all

00:21:14,540 --> 00:21:21,650
works to a point once you start

00:21:17,930 --> 00:21:24,830
modifying the values you're back to the

00:21:21,650 --> 00:21:27,560
original type because really it is just

00:21:24,830 --> 00:21:30,860
a decimal under the hood and once you

00:21:27,560 --> 00:21:34,370
start making operations meaning calling

00:21:30,860 --> 00:21:37,070
methods on that type it will return back

00:21:34,370 --> 00:21:40,460
the original type so there is a

00:21:37,070 --> 00:21:44,080
limitation you should be aware of the

00:21:40,460 --> 00:21:47,870
only perfectly correct solution of

00:21:44,080 --> 00:21:49,910
defining a new type is to actually

00:21:47,870 --> 00:21:55,580
define a new class and implement your

00:21:49,910 --> 00:21:58,400
type and the behavior you want so that

00:21:55,580 --> 00:22:01,010
is nice and clean but of course you will

00:21:58,400 --> 00:22:02,900
pay a runtime price because your price

00:22:01,010 --> 00:22:06,320
implementation will probably not be

00:22:02,900 --> 00:22:07,910
faster than there than be the decimal

00:22:06,320 --> 00:22:13,910
type that's already in Python

00:22:07,910 --> 00:22:18,110
implemented in C so that way lie a lot

00:22:13,910 --> 00:22:21,940
of interesting dilemmas about preferring

00:22:18,110 --> 00:22:24,620
static typing purity or preferring

00:22:21,940 --> 00:22:31,640
pragmatic runtime performance

00:22:24,620 --> 00:22:36,320
and simplicity now in Python you can do

00:22:31,640 --> 00:22:38,929
a lot of meta programming a lot of lot

00:22:36,320 --> 00:22:42,919
of magical tricks and my PI cannot

00:22:38,929 --> 00:22:44,690
always understand them a good example of

00:22:42,919 --> 00:22:48,020
that is the data classes module that's

00:22:44,690 --> 00:22:51,470
new in Python 3.7 or if you're familiar

00:22:48,020 --> 00:22:53,900
with Django then Django models are an

00:22:51,470 --> 00:22:56,799
example of meta programming that myapi

00:22:53,900 --> 00:22:59,690
wouldn't be able to figure out by itself

00:22:56,799 --> 00:23:01,669
so you actually are able to write

00:22:59,690 --> 00:23:07,850
plug-ins for my PI that help it

00:23:01,669 --> 00:23:11,929
understand magical code this is even

00:23:07,850 --> 00:23:13,909
newer than my PI itself there isn't much

00:23:11,929 --> 00:23:16,880
in the way of documentation yet and

00:23:13,909 --> 00:23:22,059
there's just a few working plugins out

00:23:16,880 --> 00:23:26,330
there we also had to write a plug-in and

00:23:22,059 --> 00:23:28,460
if you need to go that way too then you

00:23:26,330 --> 00:23:30,799
might find our plugin useful because

00:23:28,460 --> 00:23:36,770
it's got twice as many comments as it

00:23:30,799 --> 00:23:39,260
has code and so this is a bit hard at

00:23:36,770 --> 00:23:42,620
this moment you probably won't need it

00:23:39,260 --> 00:23:48,710
but if you do I'm sure this will all get

00:23:42,620 --> 00:23:51,169
easier over time the final example I'd

00:23:48,710 --> 00:23:54,679
like to share is overloading function

00:23:51,169 --> 00:23:58,520
signatures that means properly typing

00:23:54,679 --> 00:24:01,370
the case where your function might take

00:23:58,520 --> 00:24:04,610
different sets of types of parameters

00:24:01,370 --> 00:24:09,710
and return different types of results

00:24:04,610 --> 00:24:13,809
based on the parameters a simple example

00:24:09,710 --> 00:24:16,820
is is having something that's indexable

00:24:13,809 --> 00:24:19,700
like a list is but let's let's say it's

00:24:16,820 --> 00:24:23,450
it's your own type so here we could have

00:24:19,700 --> 00:24:25,820
a series of numbers and we want to be

00:24:23,450 --> 00:24:28,669
able to index individual numbers but

00:24:25,820 --> 00:24:31,309
also slices and we want my apply to

00:24:28,669 --> 00:24:33,740
understand that when we use a single

00:24:31,309 --> 00:24:36,580
index a single value is returned and

00:24:33,740 --> 00:24:42,669
when we use a slice than a sequence of

00:24:36,580 --> 00:24:45,039
this return so we begin by creating a

00:24:42,669 --> 00:24:47,380
generic class this should be familiar to

00:24:45,039 --> 00:24:52,690
you by now like I said it's a very

00:24:47,380 --> 00:24:57,909
common tool and what we need to do next

00:24:52,690 --> 00:25:01,390
is to explain the two versions of the

00:24:57,909 --> 00:25:05,909
square brackets operator which is called

00:25:01,390 --> 00:25:09,159
dunder get item in Python so these two

00:25:05,909 --> 00:25:11,889
they look like method definitions they

00:25:09,159 --> 00:25:14,500
actually are but they don't have anybody

00:25:11,889 --> 00:25:16,330
again those three dots are exactly what

00:25:14,500 --> 00:25:19,539
you want to put in there and you

00:25:16,330 --> 00:25:21,700
annotate them with an with an overload

00:25:19,539 --> 00:25:26,250
decorator coming from the typing module

00:25:21,700 --> 00:25:31,779
and all they do is they explain to my PI

00:25:26,250 --> 00:25:36,130
what are the possible ways of of calling

00:25:31,779 --> 00:25:38,440
those methods and then you just add the

00:25:36,130 --> 00:25:42,250
actual implementation which in this case

00:25:38,440 --> 00:25:44,559
is very trivial and that real

00:25:42,250 --> 00:25:46,990
implementation has to be typed so that

00:25:44,559 --> 00:25:49,860
it includes all the versions of the

00:25:46,990 --> 00:25:55,389
signatures that you mentioned previously

00:25:49,860 --> 00:25:57,190
so this is a bit wording but it actually

00:25:55,389 --> 00:26:04,720
makes a lot of sense once you get used

00:25:57,190 --> 00:26:08,139
to it the syntax is easy to understand I

00:26:04,720 --> 00:26:11,049
had a lot more in store for this talk

00:26:08,139 --> 00:26:13,539
but I had to cut a lot so to to fit into

00:26:11,049 --> 00:26:19,210
the time limit so I only have seven

00:26:13,539 --> 00:26:21,490
takeaways for you one is to try and make

00:26:19,210 --> 00:26:26,320
your life harder by using stricter

00:26:21,490 --> 00:26:28,240
configuration than the default is second

00:26:26,320 --> 00:26:31,840
is to go bit by bit

00:26:28,240 --> 00:26:35,139
don't take too much on in the beginning

00:26:31,840 --> 00:26:39,399
and go module by module and get to opt

00:26:35,139 --> 00:26:41,380
out when you can definitely learn to

00:26:39,399 --> 00:26:44,049
work with generics and type variables

00:26:41,380 --> 00:26:47,610
because those are your friends you will

00:26:44,049 --> 00:26:47,610
be meeting them quite a lot

00:26:48,810 --> 00:26:54,540
learn to use protocols because they are

00:26:51,540 --> 00:26:57,450
very much in line with the dynamic

00:26:54,540 --> 00:27:00,210
spirit of Python so you don't have to

00:26:57,450 --> 00:27:05,730
create classes for everything just for

00:27:00,210 --> 00:27:08,640
static typing be aware of new type

00:27:05,730 --> 00:27:10,440
because it can add more semantics to

00:27:08,640 --> 00:27:12,990
your types not everything has to be a

00:27:10,440 --> 00:27:18,480
decimal or an integer you can call it

00:27:12,990 --> 00:27:21,600
user ID or price or quantity writing

00:27:18,480 --> 00:27:24,300
plugins is hard but it is so important

00:27:21,600 --> 00:27:26,480
for my pipe to spread and become more

00:27:24,300 --> 00:27:31,790
popular that I'm sure it will get easier

00:27:26,480 --> 00:27:35,970
eventually and the last example

00:27:31,790 --> 00:27:38,100
overloading looks like boilerplate but

00:27:35,970 --> 00:27:45,860
it's not very that complicated and just

00:27:38,100 --> 00:27:50,430
useful so who here thinks that typing is

00:27:45,860 --> 00:27:55,260
complicated after this talk I certainly

00:27:50,430 --> 00:27:58,650
do but there are good reasons for that

00:27:55,260 --> 00:28:00,990
one is that we have to learn and

00:27:58,650 --> 00:28:04,560
understand new concepts as developers

00:28:00,990 --> 00:28:06,630
and that is great because they they

00:28:04,560 --> 00:28:11,120
force us to think about our code more

00:28:06,630 --> 00:28:14,190
and in ways we perhaps didn't before and

00:28:11,120 --> 00:28:18,080
another reason is that the tooling is

00:28:14,190 --> 00:28:21,060
still quite young and it's developing

00:28:18,080 --> 00:28:27,870
very fast very actively but there still

00:28:21,060 --> 00:28:31,710
is a lot of issues to cover and if I may

00:28:27,870 --> 00:28:34,400
just one final sentence that is once

00:28:31,710 --> 00:28:36,800
this becomes more popular and

00:28:34,400 --> 00:28:40,760
more prevalent once we learn how to use

00:28:36,800 --> 00:28:42,980
this then all our codes will be much

00:28:40,760 --> 00:28:45,200
less error-prone and development will be

00:28:42,980 --> 00:28:50,100
more fun I can already see that in

00:28:45,200 --> 00:29:02,490
smaller projects thank you

00:28:50,100 --> 00:29:02,490
[Applause]

00:29:08,440 --> 00:29:16,940
one short question somebody's close to

00:29:12,530 --> 00:29:20,120
microphone thank you for your talk

00:29:16,940 --> 00:29:22,540
I have a question so beyond primitive

00:29:20,120 --> 00:29:25,700
type annotations do you think that

00:29:22,540 --> 00:29:28,400
optimizing for a human which Python says

00:29:25,700 --> 00:29:32,710
readability counts and that kind of PAP

00:29:28,400 --> 00:29:35,870
twenty things and optimizing for machine

00:29:32,710 --> 00:29:43,340
mypie in this case is a zero-sum game or

00:29:35,870 --> 00:29:45,500
it's kind of something else at this

00:29:43,340 --> 00:29:49,510
point we are making concessions to my

00:29:45,500 --> 00:29:52,430
mind definitely we are adding code and

00:29:49,510 --> 00:29:56,210
structures to the code that we maybe

00:29:52,430 --> 00:29:59,780
would not do otherwise but I don't think

00:29:56,210 --> 00:30:02,930
the gap is too big and if it is done

00:29:59,780 --> 00:30:05,060
correctly then you might be making the

00:30:02,930 --> 00:30:07,730
code easier to read for humans as well

00:30:05,060 --> 00:30:10,660
when you alias your your complicated

00:30:07,730 --> 00:30:13,910
type annotations and use them cautiously

00:30:10,660 --> 00:30:17,810
then I don't think we lose all that much

00:30:13,910 --> 00:30:19,400
very little and we gain a lot all right

00:30:17,810 --> 00:30:21,170
it's very hot topic but we are running

00:30:19,400 --> 00:30:21,870
out of time so thanks again Vito for

00:30:21,170 --> 00:30:22,080
this nice talk

00:30:21,870 --> 00:30:27,839
[Music]

00:30:22,080 --> 00:30:27,839

YouTube URL: https://www.youtube.com/watch?v=UQo-ebJk4a4


