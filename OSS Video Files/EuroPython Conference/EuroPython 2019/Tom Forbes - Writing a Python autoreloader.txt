Title: Tom Forbes - Writing a Python autoreloader
Publication date: 2019-09-03
Playlist: EuroPython 2019
Description: 
	"Writing a Python autoreloader
[EuroPython 2019 - Talk - 2019-07-10 - Shanghai]
[Basel, CH]

By Tom Forbes

Reloading your code changes quickly is an integral part of the development experience in frameworks like Django and Flask that developers have come to rely on. But how do they work under the hood and what challenges do you face while writing one?

In this talk I will explore how I refactored the autoreload implementation in Django 2.2 and the lessons I learned along the way (hint: it's surprisingly complex!). I will also be introducing a library I've developed to simplify this if you ever find yourself writing your own.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:04,490 --> 00:00:10,559
can you guys all hear me we'll work him

00:00:06,990 --> 00:00:12,240
okay so yeah my name is Tom I'm gonna

00:00:10,559 --> 00:00:15,330
talk today about writing an auditory

00:00:12,240 --> 00:00:17,610
loader in Python so broken the talk down

00:00:15,330 --> 00:00:20,100
into four sections we're going to talk

00:00:17,610 --> 00:00:22,710
about what naughty reloaded it is when

00:00:20,100 --> 00:00:24,539
talk about Django's implementation we're

00:00:22,710 --> 00:00:26,250
gonna talk about how I've rebuilt it I'm

00:00:24,539 --> 00:00:29,939
gonna talk about the aftermath of how

00:00:26,250 --> 00:00:33,120
what happened after I rebuilt it sounds

00:00:29,939 --> 00:00:35,190
good so firstly what is not a relator

00:00:33,120 --> 00:00:36,989
like auger programmers I googled this

00:00:35,190 --> 00:00:39,809
and nothing came up which surprised me

00:00:36,989 --> 00:00:41,399
there was no definition of an auto

00:00:39,809 --> 00:00:43,379
reloader though it's a common

00:00:41,399 --> 00:00:45,469
development term sorry about this

00:00:43,379 --> 00:00:48,390
definition which sounds sufficiently

00:00:45,469 --> 00:00:50,309
technical and vague so it's a component

00:00:48,390 --> 00:00:51,899
in a larger system that detects and

00:00:50,309 --> 00:00:54,870
applies changes to source code without

00:00:51,899 --> 00:00:56,520
developer interaction so raise your

00:00:54,870 --> 00:00:58,770
hands here if you use an auto B loader

00:00:56,520 --> 00:01:00,329
in your day-to-day life in some kind of

00:00:58,770 --> 00:01:02,969
framework so yeah pretty much everyone

00:01:00,329 --> 00:01:04,649
right raise your hands if you could

00:01:02,969 --> 00:01:10,380
write one or you know in detail how it

00:01:04,649 --> 00:01:11,369
works so okay one of the half people so

00:01:10,380 --> 00:01:13,860
this is why I find them interesting

00:01:11,369 --> 00:01:16,049
they're really common every developer

00:01:13,860 --> 00:01:18,000
almost developers use them they're a

00:01:16,049 --> 00:01:20,159
critical part of frameworks like Django

00:01:18,000 --> 00:01:22,650
if the author really doesn't work and

00:01:20,159 --> 00:01:24,330
we'll find out later it's kind of a big

00:01:22,650 --> 00:01:26,759
deal even though they're not a

00:01:24,330 --> 00:01:28,320
production thing they're not really well

00:01:26,759 --> 00:01:30,090
understood and they're really language

00:01:28,320 --> 00:01:31,320
specific an auto related in Python is

00:01:30,090 --> 00:01:34,110
very different from naughty Relater in

00:01:31,320 --> 00:01:35,490
JavaScript so as an example of material

00:01:34,110 --> 00:01:36,780
ADA a really simple one will be

00:01:35,490 --> 00:01:39,479
automatically refreshing your browser

00:01:36,780 --> 00:01:41,189
tab every time you change a HTML file or

00:01:39,479 --> 00:01:45,420
a JavaScript file that's an auto

00:01:41,189 --> 00:01:47,340
reloader so a special case of an auto

00:01:45,420 --> 00:01:50,189
relator is a hot reloader and this is

00:01:47,340 --> 00:01:51,659
the holy grail of watery loaders because

00:01:50,189 --> 00:01:54,540
they're really fast and really efficient

00:01:51,659 --> 00:01:57,360
so it reloads the changes to your code

00:01:54,540 --> 00:01:59,549
without restarting the system so a

00:01:57,360 --> 00:02:01,200
really simple example of this is

00:01:59,549 --> 00:02:03,630
changing the style sheet on a web page

00:02:01,200 --> 00:02:05,430
this is kind of hot reloading the

00:02:03,630 --> 00:02:07,079
browser can take the changes to the

00:02:05,430 --> 00:02:09,090
style sheet and it can apply the new

00:02:07,079 --> 00:02:13,090
styles to the page without refreshing

00:02:09,090 --> 00:02:15,099
the tab you can hot reload CSS

00:02:13,090 --> 00:02:17,290
and these are impossible to write and

00:02:15,099 --> 00:02:18,940
safely in Python in the general case and

00:02:17,290 --> 00:02:20,500
I'll tell you why and a special

00:02:18,940 --> 00:02:21,879
shout-out to Erlang where you HOT reload

00:02:20,500 --> 00:02:23,830
code while deploying that's how you

00:02:21,879 --> 00:02:25,690
deploy code in Erlang you hot reload it

00:02:23,830 --> 00:02:28,840
in production I wouldn't suggest doing

00:02:25,690 --> 00:02:30,069
that him Python so you might say Tom

00:02:28,840 --> 00:02:31,989
Python has reload

00:02:30,069 --> 00:02:35,170
isn't that a hot reloader isn't this

00:02:31,989 --> 00:02:37,840
implementation hot reloading a module so

00:02:35,170 --> 00:02:39,519
reload does nothing but re import the

00:02:37,840 --> 00:02:41,950
module all it does is you give it a

00:02:39,519 --> 00:02:43,660
module and it just reinforce it so yes

00:02:41,950 --> 00:02:46,090
this is technically hot reloading a

00:02:43,660 --> 00:02:48,730
single module but you need a lot more

00:02:46,090 --> 00:02:49,810
before this is a hot real odor I don't

00:02:48,730 --> 00:02:51,370
know how well that translates into other

00:02:49,810 --> 00:02:53,290
languages on that English but what I

00:02:51,370 --> 00:02:55,540
mean is reloading a single module is

00:02:53,290 --> 00:02:58,209
very different than hot reloading an

00:02:55,540 --> 00:03:01,209
entire system or components within an

00:02:58,209 --> 00:03:03,400
entire system and the reason for this is

00:03:01,209 --> 00:03:05,410
dependencies are the enemy of a hot

00:03:03,400 --> 00:03:08,379
reloading and Python modules have lots

00:03:05,410 --> 00:03:09,610
of inter dependencies so all hot reload

00:03:08,379 --> 00:03:11,709
is a one thing in common they all

00:03:09,610 --> 00:03:13,989
leverage language or framework features

00:03:11,709 --> 00:03:16,390
that manage dependencies between things

00:03:13,989 --> 00:03:18,340
so in Erlang the example everything uses

00:03:16,390 --> 00:03:20,650
message-passing so if you want a hot

00:03:18,340 --> 00:03:22,389
reload component in an ER Lang system

00:03:20,650 --> 00:03:24,220
you can just bring it down and you can

00:03:22,389 --> 00:03:25,720
bring it up again the messages there's

00:03:24,220 --> 00:03:27,730
no dependencies between things the

00:03:25,720 --> 00:03:29,769
dependency is message passing which is

00:03:27,730 --> 00:03:32,709
quite easy to it's quite a nice

00:03:29,769 --> 00:03:34,569
interface to hot reload on CSS it's not

00:03:32,709 --> 00:03:36,489
really a programming language so you can

00:03:34,569 --> 00:03:38,019
just take it down remove the style sheet

00:03:36,489 --> 00:03:39,190
from the page and add a new one and the

00:03:38,019 --> 00:03:42,579
browser takes care of the rest

00:03:39,190 --> 00:03:44,230
react Jas has a hot reloader and it

00:03:42,579 --> 00:03:45,959
leverages how react components work

00:03:44,230 --> 00:03:47,980
themselves so react is all about

00:03:45,959 --> 00:03:49,660
removing components from a page and

00:03:47,980 --> 00:03:51,639
adding them again and having react take

00:03:49,660 --> 00:03:53,829
care of laying out the page for you or

00:03:51,639 --> 00:03:55,480
rendering the HTML so hot reloading a

00:03:53,829 --> 00:03:57,160
component react it's just deleting the

00:03:55,480 --> 00:03:59,200
component and adding a new one which is

00:03:57,160 --> 00:04:02,500
really quite nice and reactive it is how

00:03:59,200 --> 00:04:05,319
it works so imagine that you could write

00:04:02,500 --> 00:04:07,510
a hot reloader in Python this is a

00:04:05,319 --> 00:04:08,739
little bit wordy you import a function

00:04:07,510 --> 00:04:10,419
inside your module so you have a

00:04:08,739 --> 00:04:13,389
function a module your module dot pipe

00:04:10,419 --> 00:04:14,889
from another module import some function

00:04:13,389 --> 00:04:17,620
ok so you have a reference to that

00:04:14,889 --> 00:04:19,419
function in your in your module you then

00:04:17,620 --> 00:04:21,070
the replace the code in some function

00:04:19,419 --> 00:04:23,770
with some new code so you've rewritten

00:04:21,070 --> 00:04:25,780
it you fixed a bug or something after

00:04:23,770 --> 00:04:26,780
your hot reloading kicks in what does

00:04:25,780 --> 00:04:29,210
your module

00:04:26,780 --> 00:04:30,620
some function reference if your

00:04:29,210 --> 00:04:32,630
reference is the old code then your hot

00:04:30,620 --> 00:04:36,770
reloader hasn't worked properly so it's

00:04:32,630 --> 00:04:39,220
not right okay so you could go through

00:04:36,770 --> 00:04:42,200
and find all modules or all references

00:04:39,220 --> 00:04:45,620
or places that reference the sum

00:04:42,200 --> 00:04:47,330
function function you could then pop we

00:04:45,620 --> 00:04:48,380
load those as well and you could cascade

00:04:47,330 --> 00:04:49,730
or then find all the modules that

00:04:48,380 --> 00:04:51,500
reference the module that what reference

00:04:49,730 --> 00:04:55,010
is that one and you can go through the

00:04:51,500 --> 00:04:55,820
whole tree of objects this is it just

00:04:55,010 --> 00:04:58,130
sounds complicated

00:04:55,820 --> 00:05:00,050
it sounds really complicated and it's

00:04:58,130 --> 00:05:02,570
really impossible to do in the general

00:05:00,050 --> 00:05:05,480
case for any given Python program it's

00:05:02,570 --> 00:05:07,700
impossible to do that safely so for

00:05:05,480 --> 00:05:12,410
limited smaller cases it may work for

00:05:07,700 --> 00:05:14,330
example ipython has a hot real odor if

00:05:12,410 --> 00:05:16,250
it works in a lot of cases but it works

00:05:14,330 --> 00:05:18,169
your leverages how ipython is just a

00:05:16,250 --> 00:05:19,669
shell right so you don't we load an

00:05:18,169 --> 00:05:22,900
entire program you kind of hot reload

00:05:19,669 --> 00:05:25,310
parts of the repple that you're using

00:05:22,900 --> 00:05:27,590
and similarly if you have a single

00:05:25,310 --> 00:05:29,419
reference to something then you cannot

00:05:27,590 --> 00:05:31,460
reload that safely you can use reload if

00:05:29,419 --> 00:05:33,229
you have one reference to one module you

00:05:31,460 --> 00:05:35,180
can call reload and you can replace the

00:05:33,229 --> 00:05:38,229
reference that's not reloading that

00:05:35,180 --> 00:05:40,640
works but to do it in the general case

00:05:38,229 --> 00:05:41,990
you will end up with bugs and what's

00:05:40,640 --> 00:05:44,060
worse than having what a relator that

00:05:41,990 --> 00:05:46,310
doesn't work is a auto-related that you

00:05:44,060 --> 00:05:48,260
can't trust so if you end up with some

00:05:46,310 --> 00:05:50,419
bugs in development hard crackdown ones

00:05:48,260 --> 00:05:52,400
you're missing something's not right and

00:05:50,419 --> 00:05:52,850
it's because the hot reloader hasn't

00:05:52,400 --> 00:05:54,410
worked properly

00:05:52,850 --> 00:05:55,789
that's a terrible development experience

00:05:54,410 --> 00:05:59,539
you're going to be chasing spending time

00:05:55,789 --> 00:06:03,020
chasing bugs that don't exist so how do

00:05:59,539 --> 00:06:05,610
we reload code in Python we turn it off

00:06:03,020 --> 00:06:08,530
and on again

00:06:05,610 --> 00:06:10,210
we start the process on every Co change

00:06:08,530 --> 00:06:12,370
over and over again

00:06:10,210 --> 00:06:14,110
so this is kind of like refresh in the

00:06:12,370 --> 00:06:16,420
browser window every time you make a

00:06:14,110 --> 00:06:18,340
change to a javascript file you lose all

00:06:16,420 --> 00:06:20,560
the state in the process so you lose any

00:06:18,340 --> 00:06:22,030
connections that are open etc and it

00:06:20,560 --> 00:06:26,230
starts again from fresh this ensures

00:06:22,030 --> 00:06:28,180
that the system or the program is is

00:06:26,230 --> 00:06:29,890
right all of the it works pretty much

00:06:28,180 --> 00:06:31,240
rather than a hot reloader where you

00:06:29,890 --> 00:06:35,020
might have some kind of bugs or you

00:06:31,240 --> 00:06:36,610
can't reload code properly so this is

00:06:35,020 --> 00:06:38,470
how Django the Django water-related

00:06:36,610 --> 00:06:41,230
works so when you unmanaged up I run

00:06:38,470 --> 00:06:43,330
server Jenko we execute to manage top I

00:06:41,230 --> 00:06:46,360
run server again with a specific

00:06:43,330 --> 00:06:48,250
environment variable set the child

00:06:46,360 --> 00:06:49,780
process actually runs Django so it runs

00:06:48,250 --> 00:06:51,460
the entire framework it imports all your

00:06:49,780 --> 00:06:53,290
modules and does all the stuff that you

00:06:51,460 --> 00:06:56,590
want it to do and it watches for any

00:06:53,290 --> 00:07:00,700
file changes when a change is detected

00:06:56,590 --> 00:07:02,980
it exits with exit code 3 and the parent

00:07:00,700 --> 00:07:04,480
Django process restart so if the exits

00:07:02,980 --> 00:07:06,730
through another code it's an unexpected

00:07:04,480 --> 00:07:09,130
error and it terminates or it shows your

00:07:06,730 --> 00:07:10,720
message that's useful so it's quite a

00:07:09,130 --> 00:07:12,490
simple loop you have a process that's

00:07:10,720 --> 00:07:14,980
kind of a supervisor and it will restart

00:07:12,490 --> 00:07:16,600
the trial process when it exits and this

00:07:14,980 --> 00:07:19,870
is the most common and the simplest form

00:07:16,600 --> 00:07:21,130
of lottery loader so a little bit the

00:07:19,870 --> 00:07:24,220
history of the general waterbury loader

00:07:21,130 --> 00:07:27,340
the first commitment in 2005 no major

00:07:24,220 --> 00:07:30,640
changes into 2013 when I notify support

00:07:27,340 --> 00:07:32,470
was added KQ support was added in 2013

00:07:30,640 --> 00:07:33,460
and it was removed one month later which

00:07:32,470 --> 00:07:35,950
is never a good sign

00:07:33,460 --> 00:07:38,530
I'll talk about what I know to find kqr

00:07:35,950 --> 00:07:40,840
later on but the point here is Django

00:07:38,530 --> 00:07:42,220
code is definitely is usually very high

00:07:40,840 --> 00:07:44,470
quality and there's lots of emphasis on

00:07:42,220 --> 00:07:46,390
testing and readability the auto-related

00:07:44,470 --> 00:07:48,670
ester to me is definitely an old and

00:07:46,390 --> 00:07:50,590
crafty part of Django the code was very

00:07:48,670 --> 00:07:52,330
different and purely because it was

00:07:50,590 --> 00:07:53,110
something that wasn't well understood it

00:07:52,330 --> 00:07:55,780
kind of worked

00:07:53,110 --> 00:07:57,340
don't touch it leave it alone the code

00:07:55,780 --> 00:08:00,130
was definitely not idiomatic and it was

00:07:57,340 --> 00:08:01,330
very hard to extend and it was a pen

00:08:00,130 --> 00:08:03,190
down the code right everyone seen this

00:08:01,330 --> 00:08:05,890
he kind of just chucked features on etc

00:08:03,190 --> 00:08:06,880
you bolt on any hope it works so there

00:08:05,890 --> 00:08:08,650
were some new features that we wanted to

00:08:06,880 --> 00:08:10,230
add to the whatever loader that just

00:08:08,650 --> 00:08:12,670
wouldn't have worked with the current

00:08:10,230 --> 00:08:16,330
implementation so we needed to rewrite

00:08:12,670 --> 00:08:18,350
it so the summary so far an author

00:08:16,330 --> 00:08:20,270
glider is a common development tool

00:08:18,350 --> 00:08:23,300
hot reloaders are really hard to write

00:08:20,270 --> 00:08:25,370
in Python Python Auto relators restart

00:08:23,300 --> 00:08:27,170
the process on code changes and the

00:08:25,370 --> 00:08:30,740
jungle water odor was old and hard to

00:08:27,170 --> 00:08:32,660
extend okay so to the fun part we're

00:08:30,740 --> 00:08:33,979
going to rebuild the autorai later so I

00:08:32,660 --> 00:08:37,130
like breaking things down into sections

00:08:33,979 --> 00:08:38,990
so there's three or four steps first one

00:08:37,130 --> 00:08:40,490
is we need to find files to monitor we

00:08:38,990 --> 00:08:42,560
can't reload on code changes if we don't

00:08:40,490 --> 00:08:45,020
know what code will changing all we need

00:08:42,560 --> 00:08:46,840
to watch for we need to wait for the

00:08:45,020 --> 00:08:49,040
changes and we need to trigger a reload

00:08:46,840 --> 00:08:50,600
we need to make it testable of course

00:08:49,040 --> 00:08:52,640
especially if you're refactoring an

00:08:50,600 --> 00:08:54,110
older implementation and bonus points

00:08:52,640 --> 00:08:55,580
make it efficient you shouldn't

00:08:54,110 --> 00:08:59,960
prematurely up to my stuff so get it

00:08:55,580 --> 00:09:01,850
working and then optimize things cool so

00:08:59,960 --> 00:09:03,770
finally for smarter everyone here notice

00:09:01,850 --> 00:09:05,500
its modules its contains all the modules

00:09:03,770 --> 00:09:08,090
that are currently loaded by python

00:09:05,500 --> 00:09:10,550
python has quite a few modules so just

00:09:08,090 --> 00:09:12,050
running a hello world on I PI my Python

00:09:10,550 --> 00:09:15,560
has six hundred and forty two modules

00:09:12,050 --> 00:09:17,240
loaded Python itself just importing sis

00:09:15,560 --> 00:09:21,650
and printing the Len this module says

00:09:17,240 --> 00:09:24,950
forty two what was loaded there's quite

00:09:21,650 --> 00:09:26,690
a few modules and sometimes things that

00:09:24,950 --> 00:09:28,760
are not modules end up in sis modules

00:09:26,690 --> 00:09:30,560
this modules is effectively a dictionary

00:09:28,760 --> 00:09:32,300
and it can be modified by arbitrary

00:09:30,560 --> 00:09:35,050
python code so some libraries do some

00:09:32,300 --> 00:09:38,420
crazy things especially in development

00:09:35,050 --> 00:09:39,830
for example the typing to iron isn't a

00:09:38,420 --> 00:09:42,410
module even though it since his modules

00:09:39,830 --> 00:09:43,190
it's a class and this was actually a bug

00:09:42,410 --> 00:09:45,770
in the django auto-related

00:09:43,190 --> 00:09:47,990
implementation i naively assumed the

00:09:45,770 --> 00:09:52,190
things in sis modules and modules which

00:09:47,990 --> 00:09:54,020
isn't true and python imports are really

00:09:52,190 --> 00:09:57,830
dynamic as well it's one of the most

00:09:54,020 --> 00:09:59,450
flexible and best parts of python you

00:09:57,830 --> 00:10:02,420
can port from zip files you can put from

00:09:59,450 --> 00:10:05,990
PI C files you can write arbitrary

00:10:02,420 --> 00:10:09,530
loaders in Python to do random things on

00:10:05,990 --> 00:10:11,720
imports so this guy here wrote a sixty

00:10:09,530 --> 00:10:14,390
lines of code he wrote a importer the

00:10:11,720 --> 00:10:16,280
imports code directly from github so you

00:10:14,390 --> 00:10:18,830
can do from github under school condor

00:10:16,280 --> 00:10:20,420
whoever got username import project and

00:10:18,830 --> 00:10:22,610
it will import that code download the

00:10:20,420 --> 00:10:25,580
code from github install it or make it

00:10:22,610 --> 00:10:28,260
available to python and it's there don't

00:10:25,580 --> 00:10:30,209
do this in production but

00:10:28,260 --> 00:10:31,829
there's a lot of magic than going to

00:10:30,209 --> 00:10:33,540
imports they're not as simple as a file

00:10:31,829 --> 00:10:36,180
in the file system and a module in

00:10:33,540 --> 00:10:38,040
memory the more common use cases for

00:10:36,180 --> 00:10:40,200
these kind of loaders are PI test PI

00:10:38,040 --> 00:10:43,200
test rewrites the bytecode of your test

00:10:40,200 --> 00:10:45,089
files so it changes the assert keywords

00:10:43,200 --> 00:10:48,779
that years into a function call that PI

00:10:45,089 --> 00:10:51,660
tests can do things with syphon as well

00:10:48,779 --> 00:10:54,029
which is a library for letting you write

00:10:51,660 --> 00:10:56,760
C extension models modules in a nicer

00:10:54,029 --> 00:10:59,399
syntax in C it can import you can

00:10:56,760 --> 00:11:02,519
compile the module on import which is

00:10:59,399 --> 00:11:03,449
quite handy in development I guess so

00:11:02,519 --> 00:11:05,610
yeah there isn't always a mapping

00:11:03,449 --> 00:11:07,800
between a module and a actual unique

00:11:05,610 --> 00:11:11,130
file or you could have two modules with

00:11:07,800 --> 00:11:13,260
the same file etc so what can you do

00:11:11,130 --> 00:11:15,300
what can you import code directly from

00:11:13,260 --> 00:11:17,310
github in development you can't redo

00:11:15,300 --> 00:11:18,990
anything the point here is is the

00:11:17,310 --> 00:11:21,149
imports are very dynamic and not all

00:11:18,990 --> 00:11:24,510
changes can be detected so we can try

00:11:21,149 --> 00:11:26,160
our best to detect them and this is a

00:11:24,510 --> 00:11:29,279
really simple I'm an implementation of

00:11:26,160 --> 00:11:31,949
something to list all the files that are

00:11:29,279 --> 00:11:34,380
installed or all modules that'll load it

00:11:31,949 --> 00:11:36,329
so each module has a spec attribute and

00:11:34,380 --> 00:11:39,390
that module that object has an origin

00:11:36,329 --> 00:11:43,350
which is the path to the to the location

00:11:39,390 --> 00:11:45,089
which can be a zip file etc etc all of

00:11:43,350 --> 00:11:46,529
these code samples are really simplistic

00:11:45,089 --> 00:11:49,320
so the actual implementation in Django

00:11:46,529 --> 00:11:50,190
is over 40 lines long it wouldn't fit I

00:11:49,320 --> 00:11:52,709
actually was going to include a slide

00:11:50,190 --> 00:11:54,990
with it on but it the code just didn't

00:11:52,709 --> 00:11:56,250
work it was too big but this is

00:11:54,990 --> 00:11:58,230
conceptually what we want to do we want

00:11:56,250 --> 00:12:00,209
to iterate over 6 modules and we want to

00:11:58,230 --> 00:12:04,560
return a list of all of the file paths

00:12:00,209 --> 00:12:06,720
we want to monitor pretty simple so we

00:12:04,560 --> 00:12:08,370
found the files want to monitor we want

00:12:06,720 --> 00:12:11,339
to watch for changes and trigger a

00:12:08,370 --> 00:12:14,089
reload so all file systems report the

00:12:11,339 --> 00:12:17,220
last modification time of a file

00:12:14,089 --> 00:12:18,420
so there's function OS stat you can give

00:12:17,220 --> 00:12:21,149
it a file path and it returns the

00:12:18,420 --> 00:12:23,519
structure one of the fields on the

00:12:21,149 --> 00:12:26,490
structure is the EM time which is the

00:12:23,519 --> 00:12:28,410
last modification time of the file and

00:12:26,490 --> 00:12:30,660
we can use this exact changes to a file

00:12:28,410 --> 00:12:32,370
and the important thing to know here is

00:12:30,660 --> 00:12:33,990
that the last modification time is

00:12:32,370 --> 00:12:35,579
pretty abstract it can mean different

00:12:33,990 --> 00:12:38,490
things on different platforms and

00:12:35,579 --> 00:12:41,580
operating systems so file systems can be

00:12:38,490 --> 00:12:44,100
weird HFS which was the default fastest

00:12:41,580 --> 00:12:46,050
on Mac OS before the latest version had

00:12:44,100 --> 00:12:47,670
a one second time resolution so there

00:12:46,050 --> 00:12:49,260
was no nanoseconds in a previous slide

00:12:47,670 --> 00:12:51,870
that's the timestamp including

00:12:49,260 --> 00:12:54,090
nanoseconds HFS would just be to the

00:12:51,870 --> 00:12:55,890
second Windows has a hundred millisecond

00:12:54,090 --> 00:12:59,460
intervals so files may appear in the

00:12:55,890 --> 00:13:01,710
future Linux it depends on your hardware

00:12:59,460 --> 00:13:03,570
clock so the current time in the Linux

00:13:01,710 --> 00:13:06,330
kernel is cached in memory and is

00:13:03,570 --> 00:13:09,750
updated by some kind of clock every 10

00:13:06,330 --> 00:13:12,360
milliseconds normally Python does a

00:13:09,750 --> 00:13:14,400
great job about abstracting operating

00:13:12,360 --> 00:13:15,900
system specifics away but you really

00:13:14,400 --> 00:13:17,160
can't escape from the realities of the

00:13:15,900 --> 00:13:19,860
file system that you're running on a

00:13:17,160 --> 00:13:21,810
case in point Mac OS has a case and

00:13:19,860 --> 00:13:24,120
sensitive file system by default which

00:13:21,810 --> 00:13:26,370
isn't something you can abstract away so

00:13:24,120 --> 00:13:27,660
there could be different system calls or

00:13:26,370 --> 00:13:30,210
different ways that you find the last

00:13:27,660 --> 00:13:31,980
modification time of a file on different

00:13:30,210 --> 00:13:34,290
platforms I think a no-strike that away

00:13:31,980 --> 00:13:38,460
what the actual modification time means

00:13:34,290 --> 00:13:40,860
you can't abstract away network file

00:13:38,460 --> 00:13:42,750
systems can be even weirder and they

00:13:40,860 --> 00:13:45,450
mess things up completely os that is

00:13:42,750 --> 00:13:46,650
generally really fast except if it's on

00:13:45,450 --> 00:13:48,510
the network file system that could

00:13:46,650 --> 00:13:51,240
require like a network access right so

00:13:48,510 --> 00:13:53,730
if you're for some reason developing a

00:13:51,240 --> 00:13:55,320
system on a network file system and that

00:13:53,730 --> 00:13:57,180
network file system lives on the other

00:13:55,320 --> 00:13:57,990
side of the world for whatever reason

00:13:57,180 --> 00:13:59,880
you want to do that

00:13:57,990 --> 00:14:02,550
you know the stack could have a huge

00:13:59,880 --> 00:14:03,990
latency clocks might be under sink as

00:14:02,550 --> 00:14:05,580
well if you have two developers working

00:14:03,990 --> 00:14:06,900
on it one clock might be completely

00:14:05,580 --> 00:14:08,970
wrong one clock might be right

00:14:06,900 --> 00:14:10,680
see you you end up with the one

00:14:08,970 --> 00:14:13,230
developer writing a file the other

00:14:10,680 --> 00:14:15,450
developer reads the file or the author -

00:14:13,230 --> 00:14:17,040
reloaded kicks in and the files the

00:14:15,450 --> 00:14:19,890
times are different times of one year in

00:14:17,040 --> 00:14:21,470
the future one you in the past and the

00:14:19,890 --> 00:14:24,450
time can be set by anything it doesn't

00:14:21,470 --> 00:14:27,000
the you can change the mod of last

00:14:24,450 --> 00:14:28,980
modification time of a file arbitrarily

00:14:27,000 --> 00:14:32,340
it doesn't mean that the file has been

00:14:28,980 --> 00:14:33,540
modified and the end time not changing

00:14:32,340 --> 00:14:35,970
doesn't mean the file hasn't been

00:14:33,540 --> 00:14:37,500
modified so the reason we use this

00:14:35,970 --> 00:14:39,720
despite all these limitations is it's

00:14:37,500 --> 00:14:40,860
really easy to implement it's generally

00:14:39,720 --> 00:14:42,570
efficient unless you're running on a

00:14:40,860 --> 00:14:43,950
really weird network file system and

00:14:42,570 --> 00:14:46,740
it's a pretty good cross-platform

00:14:43,950 --> 00:14:49,380
support so here's a really simple

00:14:46,740 --> 00:14:52,170
implementation of an autoloader or that

00:14:49,380 --> 00:14:55,020
uses stat so we have function called

00:14:52,170 --> 00:14:57,510
watch files we have a dictionary the map

00:14:55,020 --> 00:14:59,100
the file paths that we've seen - and the

00:14:57,510 --> 00:15:01,589
modification time as reported by the

00:14:59,100 --> 00:15:03,750
file system we have a while true loop

00:15:01,589 --> 00:15:05,520
and we go through and iterate through

00:15:03,750 --> 00:15:08,790
each of the files returned from the

00:15:05,520 --> 00:15:11,370
previous function that we wrote we call

00:15:08,790 --> 00:15:12,899
arrest at on the path and we get the

00:15:11,370 --> 00:15:15,570
modification time and we get the

00:15:12,899 --> 00:15:17,880
previous modification time and if they

00:15:15,570 --> 00:15:20,810
differ then we exit with exit code three

00:15:17,880 --> 00:15:24,029
otherwise we sleep for one second okay

00:15:20,810 --> 00:15:25,290
so really simple obviously there's a lot

00:15:24,029 --> 00:15:27,330
more to this if the file doesn't exist

00:15:25,290 --> 00:15:31,260
if it's been deleted etc etc this is

00:15:27,330 --> 00:15:33,510
again as a simplistic implementation so

00:15:31,260 --> 00:15:35,850
we found faster Marta we can watch for

00:15:33,510 --> 00:15:39,089
check wait for changes so how do you

00:15:35,850 --> 00:15:40,649
make it testable so when I was

00:15:39,089 --> 00:15:41,640
researching this talk I went through and

00:15:40,649 --> 00:15:43,589
looked at a bunch of other projects that

00:15:41,640 --> 00:15:45,180
use an auto relator it surprised me

00:15:43,589 --> 00:15:47,640
there are not many tests watery letters

00:15:45,180 --> 00:15:49,560
in the wider ecosystem so the tornado

00:15:47,640 --> 00:15:52,170
project has two flasks us three and

00:15:49,560 --> 00:15:53,640
permit has six most of these are high

00:15:52,170 --> 00:15:56,640
level integration tests they're like

00:15:53,640 --> 00:15:59,180
spawn a process touch a file a cert of

00:15:56,640 --> 00:16:01,079
the process exits through Mexico three

00:15:59,180 --> 00:16:02,850
the point here is not to shame these

00:16:01,079 --> 00:16:04,140
projects into saying oh it sucks they

00:16:02,850 --> 00:16:06,860
don't have any tests the point here is

00:16:04,140 --> 00:16:08,910
that is a hard thing to test usually

00:16:06,860 --> 00:16:11,880
obviously these water relievers work

00:16:08,910 --> 00:16:13,890
very well and more tests doesn't always

00:16:11,880 --> 00:16:16,200
mean that it works but it's a hard thing

00:16:13,890 --> 00:16:18,390
to test and the reason is is an auto Rio

00:16:16,200 --> 00:16:20,070
de is generally an infinite loop the

00:16:18,390 --> 00:16:22,020
runs and threads I realized in a big

00:16:20,070 --> 00:16:24,300
ball of external state which is the file

00:16:22,020 --> 00:16:26,700
system and each of these things is hard

00:16:24,300 --> 00:16:28,680
to test by themselves but they're even

00:16:26,700 --> 00:16:30,060
harder when you combine them together so

00:16:28,680 --> 00:16:33,390
how do you make things accessible and

00:16:30,060 --> 00:16:37,110
this isn't some crazy idea that I've had

00:16:33,390 --> 00:16:39,120
it's just to use generators so if we

00:16:37,110 --> 00:16:42,120
make our water-related implementation a

00:16:39,120 --> 00:16:44,220
generator the only modification we do is

00:16:42,120 --> 00:16:47,070
that a parameter telling the function

00:16:44,220 --> 00:16:49,649
how long to sleep for and we use after

00:16:47,070 --> 00:16:52,200
each iteration of the loop and it lets

00:16:49,649 --> 00:16:56,130
you write slightly better tests so this

00:16:52,200 --> 00:16:58,770
is a simple test we create a reloader

00:16:56,130 --> 00:17:00,390
creates the generator we call next on it

00:16:58,770 --> 00:17:02,700
which ticks so does one tick of the loop

00:17:00,390 --> 00:17:05,250
then it hits the yield and returns to

00:17:02,700 --> 00:17:08,060
this test we fiddle with a file somehow

00:17:05,250 --> 00:17:09,350
we mutate the state of the disk

00:17:08,060 --> 00:17:11,900
and then we call next again and it

00:17:09,350 --> 00:17:13,400
should exit with ASA code three so this

00:17:11,900 --> 00:17:15,380
is we have a way to pause the auto

00:17:13,400 --> 00:17:16,970
relator essentially and it allows us to

00:17:15,380 --> 00:17:18,920
make changes to the file system and then

00:17:16,970 --> 00:17:20,720
resume them so you can extend this test

00:17:18,920 --> 00:17:22,040
to work with symbolic links permission

00:17:20,720 --> 00:17:26,420
errors files being intermittently

00:17:22,040 --> 00:17:29,180
available etc etc so we made a little

00:17:26,420 --> 00:17:32,630
bit more testable and how do we make it

00:17:29,180 --> 00:17:35,300
efficient so surprisingly there were two

00:17:32,630 --> 00:17:36,710
slow parts to the auto relator in Django

00:17:35,300 --> 00:17:39,050
the first one is iterate in the modules

00:17:36,710 --> 00:17:40,160
which surprised me and the second one is

00:17:39,050 --> 00:17:42,830
checking for file system modifications

00:17:40,160 --> 00:17:44,480
on an SSD checking for the file system

00:17:42,830 --> 00:17:44,960
modifications when I wear stat is really

00:17:44,480 --> 00:17:46,760
quite fast

00:17:44,960 --> 00:17:48,620
it's arrange the modules every second

00:17:46,760 --> 00:17:51,920
was the slowest part especially ever

00:17:48,620 --> 00:17:54,890
really large and grant with maybe 5,000

00:17:51,920 --> 00:17:58,340
modules loaded so how do we make it

00:17:54,890 --> 00:17:59,720
efficient we can just use LRU cache so

00:17:58,340 --> 00:18:01,880
we have a function the one we wrote

00:17:59,720 --> 00:18:03,920
before get files to watch we call

00:18:01,880 --> 00:18:05,060
another function with the frozen set of

00:18:03,920 --> 00:18:07,850
all of the modules that we have

00:18:05,060 --> 00:18:10,460
currently loaded that function the

00:18:07,850 --> 00:18:13,220
system or jewels files takes the modules

00:18:10,460 --> 00:18:15,350
and it has an LRU cache on it and it

00:18:13,220 --> 00:18:18,020
returns the the same implementation that

00:18:15,350 --> 00:18:20,480
we had before so in reality like sis

00:18:18,020 --> 00:18:21,980
modules can change but after an app is

00:18:20,480 --> 00:18:23,930
booted it doesn't really change that

00:18:21,980 --> 00:18:26,000
much you might import something in a

00:18:23,930 --> 00:18:28,220
function so it can mutate but in the

00:18:26,000 --> 00:18:30,020
happy path it doesn't so you can just

00:18:28,220 --> 00:18:31,490
cache the results of all of this and you

00:18:30,020 --> 00:18:34,100
can skip all the processing or checking

00:18:31,490 --> 00:18:35,960
if it's a zip file resolving siblings

00:18:34,100 --> 00:18:38,690
etc it can all just be cached into a

00:18:35,960 --> 00:18:40,610
single list and returns without needing

00:18:38,690 --> 00:18:42,560
to iterate through them in the Jango

00:18:40,610 --> 00:18:45,320
implementation on this MacBook with a

00:18:42,560 --> 00:18:46,970
solid-state drive it took up 30% at the

00:18:45,320 --> 00:18:51,800
time of the each water-related tick

00:18:46,970 --> 00:18:53,270
which was quite a lot of time so can we

00:18:51,800 --> 00:18:55,550
skip the standard library

00:18:53,270 --> 00:18:58,670
raise your hands here is anyone doing a

00:18:55,550 --> 00:19:01,070
debugging experience or process edited a

00:18:58,670 --> 00:19:03,980
system library file standard library

00:19:01,070 --> 00:19:06,290
farm ok so it happens but not very many

00:19:03,980 --> 00:19:08,810
people maybe a specific type of

00:19:06,290 --> 00:19:09,950
developer would in the general case no

00:19:08,810 --> 00:19:12,680
one really does that the average

00:19:09,950 --> 00:19:13,550
developer don't need to so it would be

00:19:12,680 --> 00:19:15,560
quite good if we could just skip

00:19:13,550 --> 00:19:17,210
watching them we could just skip all of

00:19:15,560 --> 00:19:18,470
the system packages or the sounded

00:19:17,210 --> 00:19:19,180
library we don't need to rewatch them

00:19:18,470 --> 00:19:21,940
they don't read each

00:19:19,180 --> 00:19:24,490
change this is actually a lot harder

00:19:21,940 --> 00:19:27,610
than it sounds because how do we know

00:19:24,490 --> 00:19:29,260
where the standard library is I googled

00:19:27,610 --> 00:19:30,250
it I got to a stack overflow answer I

00:19:29,260 --> 00:19:31,870
was like okay good

00:19:30,250 --> 00:19:34,030
this is gonna be simple there were 20

00:19:31,870 --> 00:19:35,410
answers and each of them were different

00:19:34,030 --> 00:19:38,410
which is never a good thing

00:19:35,410 --> 00:19:41,470
so the first one was this gets I

00:19:38,410 --> 00:19:42,850
packages that's cool it's not available

00:19:41,470 --> 00:19:46,510
in a virtual environment so that's no

00:19:42,850 --> 00:19:48,730
good we can call this function that

00:19:46,510 --> 00:19:50,410
works but it returns a single path some

00:19:48,730 --> 00:19:53,200
Linux distributions have more than one

00:19:50,410 --> 00:19:55,420
site packages directory so I went to IRC

00:19:53,200 --> 00:19:56,890
and I asked and I was like okay I feel

00:19:55,420 --> 00:19:58,330
like I'm pretty experienced with Python

00:19:56,890 --> 00:20:00,360
I've never need to do this before why is

00:19:58,330 --> 00:20:02,680
it so hard like am I missing something

00:20:00,360 --> 00:20:04,030
someone linked me to a project I think

00:20:02,680 --> 00:20:05,590
it was related to coverage and I

00:20:04,030 --> 00:20:07,300
couldn't find the code snippet for this

00:20:05,590 --> 00:20:08,800
but it used five or six different ways

00:20:07,300 --> 00:20:10,660
to trying to take the standard library

00:20:08,800 --> 00:20:13,780
and it fell back to checking whether

00:20:10,660 --> 00:20:16,810
site packages is in the path of the file

00:20:13,780 --> 00:20:19,690
so at this point it boils down to risk

00:20:16,810 --> 00:20:21,580
versus reward it might not be safe to do

00:20:19,690 --> 00:20:23,590
this in all cases what happens if your

00:20:21,580 --> 00:20:25,720
project is called site packages for

00:20:23,590 --> 00:20:26,770
whatever reason and if you make a

00:20:25,720 --> 00:20:29,440
mistake then it's going to frustrate

00:20:26,770 --> 00:20:30,730
users you auto reloader won't work in

00:20:29,440 --> 00:20:32,560
all cases and that's just not a nice

00:20:30,730 --> 00:20:34,630
place to be in and now I've got watery

00:20:32,560 --> 00:20:36,250
Road I could find does this so what the

00:20:34,630 --> 00:20:38,290
games could be huge you could reduce the

00:20:36,250 --> 00:20:41,770
number of packages or modules you are

00:20:38,290 --> 00:20:43,750
searching for by 70 80 percent it's not

00:20:41,770 --> 00:20:46,300
safe to do in the general case so it

00:20:43,750 --> 00:20:49,000
doesn't get done but we can do is use

00:20:46,300 --> 00:20:50,440
file system notifications so calling

00:20:49,000 --> 00:20:51,880
stat repeatedly is kind of wasteful

00:20:50,440 --> 00:20:53,410
you're just asking are we nearly there

00:20:51,880 --> 00:20:55,060
yeah I would need there yet there yet

00:20:53,410 --> 00:20:56,920
it'd be nice if the operating system can

00:20:55,060 --> 00:20:58,900
tell you all your current systems can

00:20:56,920 --> 00:21:00,670
tell you when that file is modified so

00:20:58,900 --> 00:21:03,010
you say you tell me when this file was

00:21:00,670 --> 00:21:06,790
modified and then you just wait and the

00:21:03,010 --> 00:21:08,320
operating system will tell you so each

00:21:06,790 --> 00:21:12,400
platform has different ways of handling

00:21:08,320 --> 00:21:14,530
this watchdog is a Python library and it

00:21:12,400 --> 00:21:16,360
implements five different ways and it's

00:21:14,530 --> 00:21:19,150
three thousand lines of code and they're

00:21:16,360 --> 00:21:20,920
all file system notifications on

00:21:19,150 --> 00:21:23,050
operating systems or directory based

00:21:20,920 --> 00:21:24,310
whereas we care about files which makes

00:21:23,050 --> 00:21:25,690
it a little bit harder because you get

00:21:24,310 --> 00:21:27,700
notifications for any file in a

00:21:25,690 --> 00:21:28,750
directory which has changed and you need

00:21:27,700 --> 00:21:30,320
to filter them out and make sure that

00:21:28,750 --> 00:21:32,520
it's only files you care about

00:21:30,320 --> 00:21:33,810
notifies also potentially expensive

00:21:32,520 --> 00:21:35,280
they're generally designed for

00:21:33,810 --> 00:21:37,230
longer-term monitoring their design for

00:21:35,280 --> 00:21:39,420
a demon that's watching a bunch of files

00:21:37,230 --> 00:21:43,170
and it performs an action when a change

00:21:39,420 --> 00:21:44,730
is made in our in our flow we're going

00:21:43,170 --> 00:21:46,470
to create and destroy them quickly every

00:21:44,730 --> 00:21:47,940
time a Python process shuts down Jango

00:21:46,470 --> 00:21:50,700
restarts it has to create a new watch

00:21:47,940 --> 00:21:55,170
thing with the kernel and it's gonna use

00:21:50,700 --> 00:21:56,790
more resource than it should so this is

00:21:55,170 --> 00:21:58,950
the actual feature that we wanted to add

00:21:56,790 --> 00:22:01,020
to the jungle to reload it was using a

00:21:58,950 --> 00:22:03,360
system called watch man from Facebook so

00:22:01,020 --> 00:22:05,460
Watchmen is a demon runs on your machine

00:22:03,360 --> 00:22:07,460
and it handles all of the key

00:22:05,460 --> 00:22:10,200
differences between platforms for you

00:22:07,460 --> 00:22:12,510
you register watches web app it does the

00:22:10,200 --> 00:22:15,600
right thing and it returns changes to

00:22:12,510 --> 00:22:17,310
you over a socket and it handles gate

00:22:15,600 --> 00:22:18,360
changes which is the one of the reasons

00:22:17,310 --> 00:22:20,370
you want to add watchman in the first

00:22:18,360 --> 00:22:22,710
place if you change if you check out a

00:22:20,370 --> 00:22:24,510
new branch and get you're gonna have

00:22:22,710 --> 00:22:26,160
hundreds of notifications flying at your

00:22:24,510 --> 00:22:29,010
process setting that everything's been

00:22:26,160 --> 00:22:30,630
changed but with this it will wait until

00:22:29,010 --> 00:22:32,700
all of the checkout has finished and

00:22:30,630 --> 00:22:33,960
then it will send one single bulk update

00:22:32,700 --> 00:22:35,700
telling you that the process is finished

00:22:33,960 --> 00:22:37,380
otherwise what might happen is your

00:22:35,700 --> 00:22:39,720
process receives one file has been

00:22:37,380 --> 00:22:41,490
changed me to check out it's going to

00:22:39,720 --> 00:22:43,080
restart and it's going to be in an

00:22:41,490 --> 00:22:44,730
inconsistent state if the checkout is

00:22:43,080 --> 00:22:47,490
still happening after the Jango process

00:22:44,730 --> 00:22:48,810
has been started and the daemon can be

00:22:47,490 --> 00:22:50,310
shared with our projects so if you have

00:22:48,810 --> 00:22:52,260
like a javascript reject that also uses

00:22:50,310 --> 00:22:54,780
watchman quite a few of them do they can

00:22:52,260 --> 00:22:57,450
share the watches and generally make it

00:22:54,780 --> 00:22:58,080
more efficient so this is how we do in

00:22:57,450 --> 00:23:00,390
pseudo code

00:22:58,080 --> 00:23:02,550
we've watchman we connect to some kind

00:23:00,390 --> 00:23:05,430
of watchman server we tell it what files

00:23:02,550 --> 00:23:07,890
to watch and in the wild true loop we

00:23:05,430 --> 00:23:09,930
just tell it to wait just wait some a

00:23:07,890 --> 00:23:11,640
socket for a message from the watchman

00:23:09,930 --> 00:23:14,070
daemon and if there any changes we exit

00:23:11,640 --> 00:23:15,090
with exit code three and this way we

00:23:14,070 --> 00:23:17,370
don't write any platform-specific code

00:23:15,090 --> 00:23:20,910
and we don't have any issues regarding

00:23:17,370 --> 00:23:22,170
weird OS X versions that don't use a

00:23:20,910 --> 00:23:25,440
particular library or something like

00:23:22,170 --> 00:23:32,010
that cool so we made it efficient as

00:23:25,440 --> 00:23:34,890
well so the aftermath the code was much

00:23:32,010 --> 00:23:36,390
more modern and is easy to extend it was

00:23:34,890 --> 00:23:39,540
faster and he can use Watchmen if

00:23:36,390 --> 00:23:41,670
available there were 72 tests this isn't

00:23:39,540 --> 00:23:43,440
Jenga and it's no longer at dark corner

00:23:41,670 --> 00:23:45,360
of Jango I might be a little bit biased

00:23:43,440 --> 00:23:46,830
saying that and seeing as I wrote it but

00:23:45,360 --> 00:23:48,929
it was certainly my opinion a little bit

00:23:46,830 --> 00:23:51,870
better so it's all good I'm a genius

00:23:48,929 --> 00:23:53,009
work first time test for green ship etc

00:23:51,870 --> 00:23:56,009
everyone's happy

00:23:53,009 --> 00:23:59,039
not quite these are all issues from the

00:23:56,009 --> 00:24:02,820
Jango ticket tracker after we released

00:23:59,039 --> 00:24:06,090
the in version 2.2 the new whatever load

00:24:02,820 --> 00:24:09,210
up there were quite a few of them

00:24:06,090 --> 00:24:11,220
unfortunately so more tests doesn't

00:24:09,210 --> 00:24:13,200
always mean that it works so this is my

00:24:11,220 --> 00:24:14,970
favourite issue and the issue is it

00:24:13,200 --> 00:24:16,370
doesn't work on Windows essentially

00:24:14,970 --> 00:24:20,940
without using much man

00:24:16,370 --> 00:24:22,139
so it doesn't work intermittently so

00:24:20,940 --> 00:24:24,149
this is I want to highlight this because

00:24:22,139 --> 00:24:25,710
this is a great example of how you can

00:24:24,149 --> 00:24:27,929
make what seems to be a really simple

00:24:25,710 --> 00:24:29,549
optimization that makes sense I have it

00:24:27,929 --> 00:24:32,159
completely backfire in a way that you

00:24:29,549 --> 00:24:34,379
don't know why so in the Jango

00:24:32,159 --> 00:24:35,909
implementation I discussed before we

00:24:34,379 --> 00:24:37,649
might not be watching we might be

00:24:35,909 --> 00:24:40,019
watching for a file that doesn't exist

00:24:37,649 --> 00:24:42,629
yet Jango some files Python files on

00:24:40,019 --> 00:24:45,720
Jango if they are there that's a change

00:24:42,629 --> 00:24:47,850
so for example the models dot pi if you

00:24:45,720 --> 00:24:50,879
were to create a directory river model

00:24:47,850 --> 00:24:51,330
stop by and add that file the stat

00:24:50,879 --> 00:24:53,759
reloader

00:24:51,330 --> 00:24:55,889
would the first tick the first time in

00:24:53,759 --> 00:24:57,659
the text the file is there it doesn't

00:24:55,889 --> 00:24:59,519
pick that up as a modification because

00:24:57,659 --> 00:25:01,350
it's the first time it's seen it only

00:24:59,519 --> 00:25:03,179
the second modification where it can

00:25:01,350 --> 00:25:05,879
compare the modification time of the

00:25:03,179 --> 00:25:08,429
previous time to the current time does

00:25:05,879 --> 00:25:12,210
it reload so I was like okay and that's

00:25:08,429 --> 00:25:16,679
the corner case need to fix that so we

00:25:12,210 --> 00:25:18,899
store the last time of a loop and if the

00:25:16,679 --> 00:25:21,000
previous M time is none which means that

00:25:18,899 --> 00:25:23,309
we haven't seen this before and the

00:25:21,000 --> 00:25:26,490
modification time of the file is greater

00:25:23,309 --> 00:25:30,120
than the time of the last loop then we

00:25:26,490 --> 00:25:33,000
then we reload okay this doesn't work on

00:25:30,120 --> 00:25:36,240
Windows 25% of the time and I could

00:25:33,000 --> 00:25:38,549
never work out why so you would restart

00:25:36,240 --> 00:25:39,779
the process would restart and he just

00:25:38,549 --> 00:25:41,429
wouldn't work but then you would restart

00:25:39,779 --> 00:25:43,320
it manually and it would work and all

00:25:41,429 --> 00:25:44,580
other platforms it worked fine if you

00:25:43,320 --> 00:25:46,110
know windows and you want to tell me why

00:25:44,580 --> 00:25:48,419
this is please because it's keeps me up

00:25:46,110 --> 00:25:49,559
at night and I don't know but the point

00:25:48,419 --> 00:25:51,299
here is you get all kinds of strange

00:25:49,559 --> 00:25:53,309
behavior across different operating

00:25:51,299 --> 00:25:55,350
systems across different discs different

00:25:53,309 --> 00:25:56,539
configurations and in simple

00:25:55,350 --> 00:25:58,279
translations can bite you

00:25:56,539 --> 00:26:00,219
so keep it simple if you're writing your

00:25:58,279 --> 00:26:03,019
own and keep it really simple

00:26:00,219 --> 00:26:05,809
in conclusion don't make your own Auto

00:26:03,019 --> 00:26:08,089
reloader use this library this is the

00:26:05,809 --> 00:26:09,649
library from pylons called hapa and this

00:26:08,089 --> 00:26:11,749
is a fantastic library in the abstract

00:26:09,649 --> 00:26:13,639
of this talk you may have seen I was

00:26:11,749 --> 00:26:15,259
going to present a library that I wrote

00:26:13,639 --> 00:26:17,209
myself that took all of this knowledge

00:26:15,259 --> 00:26:19,639
and distilled it into a library this is

00:26:17,209 --> 00:26:22,399
that library the someone else's written

00:26:19,639 --> 00:26:23,599
probably better than I could so check it

00:26:22,399 --> 00:26:24,559
out if you are writing around framework

00:26:23,599 --> 00:26:27,589
and you want to add an author relator

00:26:24,559 --> 00:26:30,349
it's really good cool

00:26:27,589 --> 00:26:32,179
I just like to thank on Phaedo who's my

00:26:30,349 --> 00:26:34,879
company I work for they're paying me to

00:26:32,179 --> 00:26:37,039
come here and give this talk we are in

00:26:34,879 --> 00:26:38,089
the business of identity verification we

00:26:37,039 --> 00:26:40,339
is a really interesting problem space

00:26:38,089 --> 00:26:42,829
from the theoretical like what is an

00:26:40,339 --> 00:26:44,359
identity to the more interesting how do

00:26:42,829 --> 00:26:46,190
you handle millions of identity checks

00:26:44,359 --> 00:26:47,869
as fast as possible with as little

00:26:46,190 --> 00:26:49,669
forward as possible so if you're

00:26:47,869 --> 00:26:51,259
interested in May of this on-feed I

00:26:49,669 --> 00:26:52,879
specifically come talk to me afterwards

00:26:51,259 --> 00:26:57,609
send me an email or check our careers

00:26:52,879 --> 00:26:57,609
page any questions

00:27:06,410 --> 00:27:19,710
so we have time for a couple of

00:27:09,360 --> 00:27:22,320
questions so that's how to reload I

00:27:19,710 --> 00:27:24,480
handle it properly if any to us to weird

00:27:22,320 --> 00:27:26,910
stuff from saving files like creating a

00:27:24,480 --> 00:27:29,010
copy of health and we name it can you

00:27:26,910 --> 00:27:31,320
save it again I'm sorry I like many

00:27:29,010 --> 00:27:33,300
other tough nowadays do like save saving

00:27:31,320 --> 00:27:36,660
so it doesn't overwrite the file but

00:27:33,300 --> 00:27:39,060
rather create a new one and then yeah so

00:27:36,660 --> 00:27:40,890
watch man handles that for you quite

00:27:39,060 --> 00:27:42,450
nicely as well so it looks at common

00:27:40,890 --> 00:27:44,400
patterns where you create a separate

00:27:42,450 --> 00:27:45,990
file and then you do an atomic move the

00:27:44,400 --> 00:27:47,790
stack we loader handles that as well

00:27:45,990 --> 00:27:50,040
because it doesn't watch for the new

00:27:47,790 --> 00:27:51,630
file third dot new file which has then

00:27:50,040 --> 00:27:54,330
moved so as far as it knows the

00:27:51,630 --> 00:27:58,100
individual path has been changed but not

00:27:54,330 --> 00:27:58,100
the other one okay

00:28:11,720 --> 00:28:18,980
hey if real a restarting the process

00:28:16,519 --> 00:28:21,049
isn't really an option let's say you

00:28:18,980 --> 00:28:23,960
have plugins for an application and you

00:28:21,049 --> 00:28:25,399
can still kind of control how the code

00:28:23,960 --> 00:28:28,460
in the plugin looks because they're

00:28:25,399 --> 00:28:30,529
defining the API we say reloading

00:28:28,460 --> 00:28:34,070
without restarting is possible or just

00:28:30,529 --> 00:28:36,230
don't so with so the the exclusion for

00:28:34,070 --> 00:28:38,059
hot relator is a plugin system where you

00:28:36,230 --> 00:28:41,320
have a single reference to that plug-in

00:28:38,059 --> 00:28:43,519
or you control the plug-in and you can

00:28:41,320 --> 00:28:45,649
safely or you know that you can safely

00:28:43,519 --> 00:28:47,690
delete the reference and Riaan Porter

00:28:45,649 --> 00:28:50,330
it doesn't always work if you have for

00:28:47,690 --> 00:28:53,419
example AC module extension module to

00:28:50,330 --> 00:28:55,009
that plug-in relies on it might have

00:28:53,419 --> 00:28:57,830
some initial ization code you can't

00:28:55,009 --> 00:28:59,750
really safely hop reload those at all so

00:28:57,830 --> 00:29:02,179
it depends you can write to hot reloader

00:28:59,750 --> 00:29:04,100
in some specific cases a plug-in one in

00:29:02,179 --> 00:29:07,639
general pure Python plugin one is is

00:29:04,100 --> 00:29:09,289
definitely one of those but it safer if

00:29:07,639 --> 00:29:11,059
you find into weird issues to just

00:29:09,289 --> 00:29:12,889
restart the process so a good

00:29:11,059 --> 00:29:15,169
implementation might be both if you can

00:29:12,889 --> 00:29:16,940
detect a change if you can somehow diff

00:29:15,169 --> 00:29:19,340
the changes and work out what needs to

00:29:16,940 --> 00:29:21,889
be updated you could hop reload simple

00:29:19,340 --> 00:29:36,409
changes and then fall back to a restart

00:29:21,889 --> 00:29:38,509
if if needed thank you watchman years

00:29:36,409 --> 00:29:41,470
ago yeah when it just came out is there

00:29:38,509 --> 00:29:45,769
a P I better now easier to use the API

00:29:41,470 --> 00:29:48,080
is better ish but it's still a little

00:29:45,769 --> 00:29:49,909
bit harder than I would have liked to

00:29:48,080 --> 00:29:51,590
use the simplistic code that I showed

00:29:49,909 --> 00:29:53,179
where you register a file is nothing

00:29:51,590 --> 00:29:54,769
like you need to do you need to work out

00:29:53,179 --> 00:29:56,539
its directory basis you need to work out

00:29:54,769 --> 00:29:57,519
the set of files which common

00:29:56,539 --> 00:29:59,299
directories do you want to watch

00:29:57,519 --> 00:30:01,909
minimizing the amount of directories

00:29:59,299 --> 00:30:02,960
that you do watch it doesn't take care

00:30:01,909 --> 00:30:04,730
of any of that for you but in general

00:30:02,960 --> 00:30:06,409
it's quite nice I mean the simplistic

00:30:04,730 --> 00:30:08,299
case you say watch this and you just get

00:30:06,409 --> 00:30:10,100
notifications on a soccer and it

00:30:08,299 --> 00:30:12,139
provides utilities for filtering out

00:30:10,100 --> 00:30:14,419
specific files regular expressions or my

00:30:12,139 --> 00:30:16,009
files etc in a way that's quite

00:30:14,419 --> 00:30:17,450
cross-platform and takes a lot of code

00:30:16,009 --> 00:30:19,299
off you but it's definitely more

00:30:17,450 --> 00:30:22,220
complicated than I would like

00:30:19,299 --> 00:30:23,340
alright let's thank all my game thank

00:30:22,220 --> 00:30:25,400
you very much

00:30:23,340 --> 00:30:25,400
you

00:30:26,040 --> 00:30:29,390

YouTube URL: https://www.youtube.com/watch?v=IghyoR6ld60


