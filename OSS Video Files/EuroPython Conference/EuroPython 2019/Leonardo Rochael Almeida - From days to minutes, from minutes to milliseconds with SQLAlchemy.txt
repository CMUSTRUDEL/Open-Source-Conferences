Title: Leonardo Rochael Almeida - From days to minutes, from minutes to milliseconds with SQLAlchemy
Publication date: 2019-09-03
Playlist: EuroPython 2019
Description: 
	"From days to minutes, from minutes to milliseconds with SQLAlchemy
[EuroPython 2019 - Talk - 2019-07-10 - Boston]
[Basel, CH]

By Leonardo Rochael Almeida

Object Relational Mappers (ORMs) are awesome enhancers of developer productivity. The freedom of having the library write that SQL and give you back a useful, rich model instance (or a bunch of them) instead of just a tuple or a list of records is simply amazing.

But if you forget you have an actual database behind all that convenience, then it'll bite you back, usually when you've been in production for a while, after you've accumulated enough data that your once speedy application starts slowing down do a crawl.

Databases work best when you ask them once for (or to do) a bunch of stuff, instead of asking them lots of times for small stuff.

We'll discuss how innocent looking attribute accesses on your model instances translate to sequential queries (the infamous N+1 problem).

Then we'll go through some practical solutions, taken from real cases, that resulted in massive speed ups. We'll cover how changes in Python code resulted in changes to the resulting SQL Queries.

We'll see solutions not only for queries, but also for inserts and updates, which tend to be less well documented.

Though this talk focuses on SQLAlchemy, the lessons should be applicable to most ORMs in most programing languages. The ideas discussed, and solutions proposed are also valid for any storage back-end, not only SQL databases.

This talk is geared towards Python developers with systems that talk to databases. It should be accessible to anyone who already programs in Python (early intermediary level), but will be most useful for developers with projects talking to SQL databases, specially using an ORM like SQLAlchemy. Attendees will learn to detect how N+1 query situations arise and how to work around them effectively. They will also learn how to do mass inserts and mass updates with SQLAlchemy.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:03,280 --> 00:00:06,360
[Applause]

00:00:07,069 --> 00:00:14,059
okay so Leo I'm a tech lead at Giroux

00:00:10,740 --> 00:00:18,360
which is a fin check in Brazil it's a

00:00:14,059 --> 00:00:20,460
company that provides credit for people

00:00:18,360 --> 00:00:21,680
who once a who needs a quick loan

00:00:20,460 --> 00:00:25,259
[Music]

00:00:21,680 --> 00:00:29,669
I'm a no I'm no expert not particular

00:00:25,259 --> 00:00:33,120
expert in SQL or SQL alchemy or or

00:00:29,669 --> 00:00:35,760
Emma's in general but I've learned a few

00:00:33,120 --> 00:00:37,469
lessons optimizing some code in my

00:00:35,760 --> 00:00:42,000
company last year that I would like to

00:00:37,469 --> 00:00:44,780
pass along so Giroux as I said the

00:00:42,000 --> 00:00:47,670
FinTech in Brazil our stack is mostly

00:00:44,780 --> 00:00:50,969
Python parameter scale alchemy Postgres

00:00:47,670 --> 00:00:53,719
there is some MongoDB some celery some

00:00:50,969 --> 00:00:53,719
Java somewhere

00:00:53,899 --> 00:00:58,800
we have been carving out this monolith

00:00:56,940 --> 00:01:01,409
that we started it with in different

00:00:58,800 --> 00:01:03,120
services and so some new services get

00:01:01,409 --> 00:01:06,360
written in some different languages but

00:01:03,120 --> 00:01:09,299
most of most of the time we end up

00:01:06,360 --> 00:01:15,990
picking Python pyramid SQL alchemy and

00:01:09,299 --> 00:01:19,740
progress and I really like a CL alchemy

00:01:15,990 --> 00:01:22,049
well it has two aspects it's the core

00:01:19,740 --> 00:01:25,110
which is basically a DSL for

00:01:22,049 --> 00:01:27,719
constructing SQL queries using Python

00:01:25,110 --> 00:01:32,070
constructs and then on top of that you

00:01:27,719 --> 00:01:35,969
have the or M which is which helps you

00:01:32,070 --> 00:01:39,689
map tables to classes and records of

00:01:35,969 --> 00:01:44,670
those tables two instances of of those

00:01:39,689 --> 00:01:46,799
classes and for a programmer who know

00:01:44,670 --> 00:01:49,009
mostly knows Python it's off obviously a

00:01:46,799 --> 00:01:53,310
lot more comfortable dealing with the

00:01:49,009 --> 00:02:02,969
instances of an or M and it is juggling

00:01:53,310 --> 00:02:06,869
SQL and we at Giroux use the or m most

00:02:02,969 --> 00:02:10,160
of the time and we tend to use very

00:02:06,869 --> 00:02:12,610
little the SQL alchemy car for writing

00:02:10,160 --> 00:02:17,790
SQL constructs directly

00:02:12,610 --> 00:02:20,200
I think as he lock me is awesome however

00:02:17,790 --> 00:02:22,540
whenever you choose a framework it's

00:02:20,200 --> 00:02:26,740
usually good if you know what the frame

00:02:22,540 --> 00:02:28,270
worker is doing behind your back because

00:02:26,740 --> 00:02:29,920
frame work still require you to make

00:02:28,270 --> 00:02:31,780
decisions about how to use them and

00:02:29,920 --> 00:02:33,250
knowing the underlying patterns is

00:02:31,780 --> 00:02:39,310
essential if you were to make wise

00:02:33,250 --> 00:02:41,740
choices so using the RM is really

00:02:39,310 --> 00:02:45,010
comfortable as I said you declare your

00:02:41,740 --> 00:02:47,200
class you get instances from it and then

00:02:45,010 --> 00:02:49,330
you're manipulating it with the

00:02:47,200 --> 00:02:51,670
attributes and the methods like there is

00:02:49,330 --> 00:02:54,550
no SQL database behind it and that's

00:02:51,670 --> 00:02:58,840
really comfortable but it's also a

00:02:54,550 --> 00:03:01,450
problem because the database is an

00:02:58,840 --> 00:03:03,520
external system most of the time you

00:03:01,450 --> 00:03:08,500
should actually treat it as if it were

00:03:03,520 --> 00:03:10,720
an API of foreign system because it is

00:03:08,500 --> 00:03:14,230
really it is an external system you're

00:03:10,720 --> 00:03:16,980
talking through through tcp/ip

00:03:14,230 --> 00:03:22,680
connection or a UNIX socket connection

00:03:16,980 --> 00:03:22,680
in the API - that just happens to be SQL

00:03:24,269 --> 00:03:30,760
so what happens then is that you're

00:03:28,120 --> 00:03:32,890
writing your Python code and it looks

00:03:30,760 --> 00:03:37,810
like perfectly normal Python code but

00:03:32,890 --> 00:03:39,120
end up doing bad performance access to

00:03:37,810 --> 00:03:41,950
your database

00:03:39,120 --> 00:03:44,290
it's a noticeable and novel a lot of

00:03:41,950 --> 00:03:46,450
volumes like when you're developing or

00:03:44,290 --> 00:03:48,850
when you just go into production so you

00:03:46,450 --> 00:03:50,800
get lulled into this false sense of

00:03:48,850 --> 00:03:55,780
security that everything is going fine

00:03:50,800 --> 00:03:58,120
but then after a while you your database

00:03:55,780 --> 00:04:01,090
starts to crawl your application takes

00:03:58,120 --> 00:04:05,230
too long the fix for that of course is

00:04:01,090 --> 00:04:07,269
to let the database - its job you need

00:04:05,230 --> 00:04:09,640
to be aware of the implicit queries that

00:04:07,269 --> 00:04:13,230
your or M is doing whenever you access

00:04:09,640 --> 00:04:16,060
your instances in your classes

00:04:13,230 --> 00:04:17,590
especially when you have relationships

00:04:16,060 --> 00:04:20,859
between your instances that map to

00:04:17,590 --> 00:04:22,610
different tables in your database those

00:04:20,859 --> 00:04:28,039
are the ones that tend to

00:04:22,610 --> 00:04:32,439
to to cause them the most bad matter of

00:04:28,039 --> 00:04:35,689
axises you should try to do only

00:04:32,439 --> 00:04:39,879
approximately only one or a constant

00:04:35,689 --> 00:04:42,560
number of queries to your database per

00:04:39,879 --> 00:04:46,939
HTTP requests or API requests or

00:04:42,560 --> 00:04:48,680
background job and you should avoid as

00:04:46,939 --> 00:04:51,520
much as possible looping through

00:04:48,680 --> 00:04:53,990
instances of your model in Python code

00:04:51,520 --> 00:04:59,690
because the database is a lot better at

00:04:53,990 --> 00:05:01,460
doing that you should also be mindful of

00:04:59,690 --> 00:05:04,190
the amount of round trips you do you

00:05:01,460 --> 00:05:06,009
should try to try to do only a fixed

00:05:04,190 --> 00:05:09,379
number of queries per request because

00:05:06,009 --> 00:05:11,270
every round trip costs time but it also

00:05:09,379 --> 00:05:14,240
should be mindful of the amount of data

00:05:11,270 --> 00:05:17,419
you're pulling out of the DB when you do

00:05:14,240 --> 00:05:21,400
some requests so I'm going to talk about

00:05:17,419 --> 00:05:25,099
specific cases here that I've optimized

00:05:21,400 --> 00:05:29,690
we had this report that we ran one that

00:05:25,099 --> 00:05:31,370
we still run about once a month and in

00:05:29,690 --> 00:05:34,159
the beginning it was really fast as

00:05:31,370 --> 00:05:38,810
years passed it was taking over 24 hours

00:05:34,159 --> 00:05:43,310
to run so let's talk a little bit about

00:05:38,810 --> 00:05:47,960
Giroux I don't know if it's readable but

00:05:43,310 --> 00:05:49,639
Jerusalem Pannu it provides loans for

00:05:47,960 --> 00:05:51,199
people who access our website we do

00:05:49,639 --> 00:05:54,199
everything online and you snap your

00:05:51,199 --> 00:05:55,789
documents and then we after you're happy

00:05:54,199 --> 00:05:59,389
and do a credit analysis we send money

00:05:55,789 --> 00:06:02,210
to your bank and then you you pay back

00:05:59,389 --> 00:06:05,569
your loan by by paying Bank slips and

00:06:02,210 --> 00:06:08,089
you never have to actually face you can

00:06:05,569 --> 00:06:09,860
actually you you we're designed so that

00:06:08,089 --> 00:06:12,949
you don't actually can you cannot

00:06:09,860 --> 00:06:16,279
actually visit us to talk about your

00:06:12,949 --> 00:06:18,440
cases everything's done online and an

00:06:16,279 --> 00:06:21,770
early funding model for us to get money

00:06:18,440 --> 00:06:25,069
to lend to people was that Giroux

00:06:21,770 --> 00:06:28,639
created this funding company separate

00:06:25,069 --> 00:06:31,219
funding company that issued the benchers

00:06:28,639 --> 00:06:34,069
the manger is like an official loan from

00:06:31,219 --> 00:06:35,750
a company that the market can buy to to

00:06:34,069 --> 00:06:36,520
give money to the company without

00:06:35,750 --> 00:06:38,560
becoming

00:06:36,520 --> 00:06:43,930
partner will have how to being a stock

00:06:38,560 --> 00:06:46,090
option so the company would issue new

00:06:43,930 --> 00:06:48,039
the ventures every six months and these

00:06:46,090 --> 00:06:52,120
debentures had a contract that said that

00:06:48,039 --> 00:06:55,000
whatever the the loans the borrower's

00:06:52,120 --> 00:06:57,120
would pay back would be the payback for

00:06:55,000 --> 00:06:59,800
the the people who purchased the

00:06:57,120 --> 00:07:02,139
debentures so the company was never

00:06:59,800 --> 00:07:03,490
insolvent of course we still want to

00:07:02,139 --> 00:07:06,060
have a good credit model otherwise

00:07:03,490 --> 00:07:11,080
people will not want to buy other majors

00:07:06,060 --> 00:07:13,870
so we reissued the ventures every six

00:07:11,080 --> 00:07:15,310
months and the mentor holders by these

00:07:13,870 --> 00:07:19,000
debentures they put money in the company

00:07:15,310 --> 00:07:22,150
and so he grant loans without money and

00:07:19,000 --> 00:07:24,190
the borrower's pay back those loans and

00:07:22,150 --> 00:07:29,710
at the beginning of every month we look

00:07:24,190 --> 00:07:32,610
at what was what we got from and pay

00:07:29,710 --> 00:07:34,840
back once a month the debenture holders

00:07:32,610 --> 00:07:37,479
of course it's a lot more complicated

00:07:34,840 --> 00:07:40,840
than that because part of the money is

00:07:37,479 --> 00:07:43,449
the amortization which is the money that

00:07:40,840 --> 00:07:45,099
the venture holder actually lent us and

00:07:43,449 --> 00:07:46,990
then on top of that you have the premium

00:07:45,099 --> 00:07:50,919
which is what you are paying on top of

00:07:46,990 --> 00:07:52,990
what the adventure holder put in so that

00:07:50,919 --> 00:07:55,690
they can be happy with their investment

00:07:52,990 --> 00:07:58,779
and taxes affect only the premium

00:07:55,690 --> 00:08:01,150
another memorization and taxes you pay

00:07:58,779 --> 00:08:03,279
less taxes the longer it takes you to

00:08:01,150 --> 00:08:04,449
paralyzation so we do dances with the

00:08:03,279 --> 00:08:06,400
numbers like we are only paying

00:08:04,449 --> 00:08:10,500
amortization for a while instead of

00:08:06,400 --> 00:08:13,779
being premium then we save a little bit

00:08:10,500 --> 00:08:16,419
because in Brazil you cannot only pay

00:08:13,779 --> 00:08:18,190
premium so we have to save some of their

00:08:16,419 --> 00:08:19,810
memorization and then start paying back

00:08:18,190 --> 00:08:21,190
the premium and then paint them written

00:08:19,810 --> 00:08:23,650
authorization last so there's a whole

00:08:21,190 --> 00:08:27,580
list of numbers but that only happened

00:08:23,650 --> 00:08:30,099
in later the bencher issuances the first

00:08:27,580 --> 00:08:32,800
debentures issuances we were paying back

00:08:30,099 --> 00:08:35,760
from the principle of the loans that we

00:08:32,800 --> 00:08:40,810
granted to the Mertes ation and from the

00:08:35,760 --> 00:08:43,149
and from the premium of the loans that

00:08:40,810 --> 00:08:46,839
granted the priming of the debenture

00:08:43,149 --> 00:08:48,690
holders and the entity-relationship

00:08:46,839 --> 00:08:51,920
model looks

00:08:48,690 --> 00:08:55,920
what like this you have you have the

00:08:51,920 --> 00:08:57,540
debenture holder the debenture belongs

00:08:55,920 --> 00:08:59,730
to the major holder entered the major

00:08:57,540 --> 00:09:03,450
series the Dmitriy series has an account

00:08:59,730 --> 00:09:05,850
all the operations from borrowing and

00:09:03,450 --> 00:09:07,950
the payout come from these accounts so

00:09:05,850 --> 00:09:10,320
we have a bunch of operations and if

00:09:07,950 --> 00:09:14,670
that sounds awfully complicated don't

00:09:10,320 --> 00:09:18,650
worry gets a lot worse so let's look a

00:09:14,670 --> 00:09:22,380
little bit at the code how do we

00:09:18,650 --> 00:09:26,790
actually code that so first you have

00:09:22,380 --> 00:09:30,650
this eat this base class from SQL

00:09:26,790 --> 00:09:33,090
alchemy we declare it by putting some

00:09:30,650 --> 00:09:36,830
creating our own base class which you

00:09:33,090 --> 00:09:40,380
called here or M class and we added a

00:09:36,830 --> 00:09:45,300
convenient class method here it's

00:09:40,380 --> 00:09:48,900
actually probably yeah so what we do

00:09:45,300 --> 00:09:53,930
here we take the SQL alchemy DB session

00:09:48,900 --> 00:09:57,060
and make it easily available inside the

00:09:53,930 --> 00:09:59,790
class so that you can say oh I have my

00:09:57,060 --> 00:10:02,760
model dot query and then you can apply

00:09:59,790 --> 00:10:04,800
apply filters order by joins with other

00:10:02,760 --> 00:10:07,140
classes and things like that so it's a

00:10:04,800 --> 00:10:14,640
little convenience attribute in the

00:10:07,140 --> 00:10:17,280
class and so this base here there's this

00:10:14,640 --> 00:10:20,280
method this function from SQL alchemy

00:10:17,280 --> 00:10:22,350
that makes this the Raps it's Oram class

00:10:20,280 --> 00:10:25,200
and you have this magical base class

00:10:22,350 --> 00:10:28,050
here which we then have to use in all

00:10:25,200 --> 00:10:29,790
the models that we declare so like we

00:10:28,050 --> 00:10:32,490
said the debenture which is the thing

00:10:29,790 --> 00:10:34,710
that we sell to the debenture holders

00:10:32,490 --> 00:10:39,000
which is like the loan that the venture

00:10:34,710 --> 00:10:44,210
holder is granting to us it has its

00:10:39,000 --> 00:10:44,210
database key it has a serial number

00:10:44,240 --> 00:10:49,080
which is it which is very different from

00:10:46,770 --> 00:10:53,149
the ID because the serial number repeats

00:10:49,080 --> 00:10:57,259
inside every debentures

00:10:53,149 --> 00:10:58,939
series where else the ID is constantly

00:10:57,259 --> 00:11:02,089
different for all the debentures no

00:10:58,939 --> 00:11:04,819
matter what there's a sale price because

00:11:02,089 --> 00:11:07,279
if you buy at the bane tree at the

00:11:04,819 --> 00:11:10,519
beginning of the series you buy it close

00:11:07,279 --> 00:11:12,559
to the official debenture price but if

00:11:10,519 --> 00:11:14,869
you buy it later it costs you more

00:11:12,559 --> 00:11:19,279
because it's the price of opportunity

00:11:14,869 --> 00:11:25,279
for being late to the party and so we

00:11:19,279 --> 00:11:30,469
have a sale date here we are continuing

00:11:25,279 --> 00:11:32,989
the same class so those here were black

00:11:30,469 --> 00:11:36,799
girl or attributes of the class which

00:11:32,989 --> 00:11:44,599
get mapped to columns in the database in

00:11:36,799 --> 00:11:46,159
a table called the danger the here we

00:11:44,599 --> 00:11:47,959
are talking about the same class but

00:11:46,159 --> 00:11:50,149
here we see some relationships so we

00:11:47,959 --> 00:11:52,459
have this holder ID which is also

00:11:50,149 --> 00:11:54,589
regular column a regular integer column

00:11:52,459 --> 00:11:58,489
but then we add a declaration that it's

00:11:54,589 --> 00:12:04,039
a foreign key into the the ID column of

00:11:58,489 --> 00:12:08,139
the debenture holder table and on top of

00:12:04,039 --> 00:12:11,569
that we declare the holder relationship

00:12:08,139 --> 00:12:16,729
which has as foreign keys the holder ID

00:12:11,569 --> 00:12:20,119
that we just declared so this way I get

00:12:16,729 --> 00:12:23,419
a holder attribute on my the bencher

00:12:20,119 --> 00:12:26,539
instance which fetches me the debenture

00:12:23,419 --> 00:12:28,369
holder instance transparently for me but

00:12:26,539 --> 00:12:30,169
this transparently means it's doing a

00:12:28,369 --> 00:12:32,779
query to the database at least once

00:12:30,169 --> 00:12:35,509
during the session SQL alchemy actually

00:12:32,779 --> 00:12:37,069
will cache that instance so that so that

00:12:35,509 --> 00:12:39,829
it doesn't fetch it again every time I

00:12:37,069 --> 00:12:42,019
assess that access the attribute but

00:12:39,829 --> 00:12:44,419
still needs me mindful but the first

00:12:42,019 --> 00:12:47,379
time I accessed this holder attribute

00:12:44,419 --> 00:12:52,519
there's gonna be an SQL query unless I

00:12:47,379 --> 00:12:54,799
play some tricks on it so as I showed in

00:12:52,519 --> 00:12:58,459
the graph the debenture also has a

00:12:54,799 --> 00:13:00,480
relationship to the series to the

00:12:58,459 --> 00:13:03,080
debenture series that is

00:13:00,480 --> 00:13:05,870
and that this issuing is the venture and

00:13:03,080 --> 00:13:11,970
again we have a serious relationship

00:13:05,870 --> 00:13:13,200
mapping to these to this column the

00:13:11,970 --> 00:13:14,910
interesting that there's another

00:13:13,200 --> 00:13:17,490
interesting aspect here which is this

00:13:14,910 --> 00:13:21,660
back raff we saw here we saw it here at

00:13:17,490 --> 00:13:26,220
the holder declaration as well what this

00:13:21,660 --> 00:13:29,970
does is create the benchers attribute in

00:13:26,220 --> 00:13:36,450
the debenture holder class that points

00:13:29,970 --> 00:13:39,930
to an iterable kind of a list of the

00:13:36,450 --> 00:13:42,330
dangers that I can conveniently access

00:13:39,930 --> 00:13:45,930
from the point of view of the debater

00:13:42,330 --> 00:13:48,600
holder same thing here in the the

00:13:45,930 --> 00:13:51,830
venture series I get a debentures

00:13:48,600 --> 00:13:55,800
attribute there which is an iterable of

00:13:51,830 --> 00:13:59,940
the benchers that points to that the

00:13:55,800 --> 00:14:02,490
major series there is this lazy dynamic

00:13:59,940 --> 00:14:05,730
here what does it mean it that actually

00:14:02,490 --> 00:14:09,230
tells you what kind of iterable it is if

00:14:05,730 --> 00:14:12,030
you don't say anything it will create

00:14:09,230 --> 00:14:14,070
lazy attributes that the first time you

00:14:12,030 --> 00:14:16,490
access it will make a query to the

00:14:14,070 --> 00:14:19,230
database and bring back a Python list

00:14:16,490 --> 00:14:23,700
but if you do like I did here and say

00:14:19,230 --> 00:14:26,700
dynamic then instead the dangerous

00:14:23,700 --> 00:14:31,710
attribute inside the meteor series will

00:14:26,700 --> 00:14:35,220
be a query object pretty much like this

00:14:31,710 --> 00:14:38,880
query of the discrete object here that

00:14:35,220 --> 00:14:43,140
allows me to apply filter order by and

00:14:38,880 --> 00:14:46,800
other things like that so by doing these

00:14:43,140 --> 00:14:51,780
dynamic relationships I enable the

00:14:46,800 --> 00:14:54,750
application to lazily get a query object

00:14:51,780 --> 00:14:57,840
apply another other operations on top of

00:14:54,750 --> 00:15:03,990
it like filtering ordering joining with

00:14:57,840 --> 00:15:06,420
other relationships and only then up

00:15:03,990 --> 00:15:07,950
only when I try to eat irate over it it

00:15:06,420 --> 00:15:12,490
goes to the database and fetches the

00:15:07,950 --> 00:15:17,920
data so I

00:15:12,490 --> 00:15:19,300
had to debug an issue that was found by

00:15:17,920 --> 00:15:21,279
the financial people that we were not

00:15:19,300 --> 00:15:22,660
paying exactly what we should be paying

00:15:21,279 --> 00:15:25,560
the major holders there was some

00:15:22,660 --> 00:15:29,790
discrepancy and I started debugging this

00:15:25,560 --> 00:15:32,740
hours-long report it took hours because

00:15:29,790 --> 00:15:36,760
well the report itself took about five

00:15:32,740 --> 00:15:39,160
hours but it also dependent on another

00:15:36,760 --> 00:15:40,870
process that cashed some information and

00:15:39,160 --> 00:15:43,540
this other process also took about four

00:15:40,870 --> 00:15:45,279
hours and that was for each debenture

00:15:43,540 --> 00:15:46,690
series that we had and not bad that by

00:15:45,279 --> 00:15:50,770
the point we had about six de mentir

00:15:46,690 --> 00:15:53,860
series so the whole run of reports took

00:15:50,770 --> 00:15:56,140
more than a day and I was sort of a

00:15:53,860 --> 00:16:00,010
beginner I said well that this this is

00:15:56,140 --> 00:16:03,910
taking too much time so i enabled SQL

00:16:00,010 --> 00:16:06,850
alchemy to do debugging for me if you if

00:16:03,910 --> 00:16:09,070
you take the standard Python logging you

00:16:06,850 --> 00:16:12,070
take the SQL alchemy engine logger and

00:16:09,070 --> 00:16:15,250
set the log level to info it will log

00:16:12,070 --> 00:16:17,290
every query if you set it to debug it

00:16:15,250 --> 00:16:19,720
will log every query and the results and

00:16:17,290 --> 00:16:21,490
when it locks the queries it locks the

00:16:19,720 --> 00:16:25,060
parameters that are used by the query as

00:16:21,490 --> 00:16:26,440
well so i enabled a logging in and start

00:16:25,060 --> 00:16:29,800
running the report and suddenly I'm

00:16:26,440 --> 00:16:37,959
seeing gobs and gobs of the same query

00:16:29,800 --> 00:16:42,600
repeated over and over and over so what

00:16:37,959 --> 00:16:42,600
I did let me find

00:16:48,020 --> 00:16:58,339
so let's see some code that's not

00:16:53,690 --> 00:16:59,630
readable right uh the people in the back

00:16:58,339 --> 00:17:05,270
can you read it nope

00:16:59,630 --> 00:17:09,050
how about now yep the people in the back

00:17:05,270 --> 00:17:15,949
and read it okay now for me it was

00:17:09,050 --> 00:17:18,500
raided right okay so let's see if I can

00:17:15,949 --> 00:17:21,220
show the things I think I'm gonna switch

00:17:18,500 --> 00:17:21,220
the mirror mode

00:17:31,590 --> 00:17:36,440
so

00:17:33,050 --> 00:17:36,440
[Music]

00:17:48,360 --> 00:17:56,640
so this is gonna be kind of hard to to

00:17:52,710 --> 00:17:58,649
fit all the code in this space but the

00:17:56,640 --> 00:18:00,899
kind of things that were being done here

00:17:58,649 --> 00:18:03,899
so we have this total paid in what does

00:18:00,899 --> 00:18:06,240
this method here do it gets all the

00:18:03,899 --> 00:18:08,039
money that was paid in the dangers of

00:18:06,240 --> 00:18:12,450
that debenture series this is a method

00:18:08,039 --> 00:18:15,659
of the debenture series class and so you

00:18:12,450 --> 00:18:19,740
can call it by specifying a period if

00:18:15,659 --> 00:18:21,450
you want and it gets the debentures that

00:18:19,740 --> 00:18:23,700
are owned by someone that the measures

00:18:21,450 --> 00:18:26,360
that were actually sold and this is this

00:18:23,700 --> 00:18:29,460
is a property that that brings the

00:18:26,360 --> 00:18:31,880
debentures related to this adventure

00:18:29,460 --> 00:18:36,330
series that actually have owners and

00:18:31,880 --> 00:18:40,039
it's adding filters here if you pass the

00:18:36,330 --> 00:18:43,559
start date or end date and then it's

00:18:40,039 --> 00:18:47,190
doing us some of the sale price of all

00:18:43,559 --> 00:18:49,710
these Dementors the the moments where

00:18:47,190 --> 00:18:52,769
the code actually goes to the database

00:18:49,710 --> 00:18:57,809
to fetch is the moment where it er is

00:18:52,769 --> 00:19:00,960
called into this object and what is the

00:18:57,809 --> 00:19:04,380
this is doing here is taking a huge

00:19:00,960 --> 00:19:07,620
number of the ventures pulling all their

00:19:04,380 --> 00:19:10,080
columns from the database just to sum

00:19:07,620 --> 00:19:12,059
their price now when you look at this

00:19:10,080 --> 00:19:14,309
it's perfectly reasonable python code

00:19:12,059 --> 00:19:15,539
right you're summing the sale price of a

00:19:14,309 --> 00:19:18,419
bunch of the ventures that's exactly

00:19:15,539 --> 00:19:21,029
what you want but here you are pulling a

00:19:18,419 --> 00:19:24,570
huge amount of information from the

00:19:21,029 --> 00:19:26,970
database just to get the sum of what is

00:19:24,570 --> 00:19:29,190
essentially a column and if we had done

00:19:26,970 --> 00:19:33,799
something if instead of sale price we

00:19:29,190 --> 00:19:33,799
are done than something like d dot

00:19:34,010 --> 00:19:39,570
series they're analogous that d dot

00:19:37,049 --> 00:19:41,820
series dot sale price then not only

00:19:39,570 --> 00:19:44,460
would I be fetching a bunch of queries

00:19:41,820 --> 00:19:47,039
but a bunch of information with all its

00:19:44,460 --> 00:19:50,010
columns for each point in the loop I

00:19:47,039 --> 00:19:51,750
would be fetching another record in the

00:19:50,010 --> 00:19:53,669
database with all its columns and then

00:19:51,750 --> 00:19:58,880
some it this is called that n plus 1

00:19:53,669 --> 00:20:02,090
select problem so instead of doing that

00:19:58,880 --> 00:20:05,240
what I did here i created this phone

00:20:02,090 --> 00:20:06,890
from call get column so for query what's

00:20:05,240 --> 00:20:13,400
the critic where is the danger so you

00:20:06,890 --> 00:20:15,620
see it's the same word here and here but

00:20:13,400 --> 00:20:17,480
then I'm going into the class instead of

00:20:15,620 --> 00:20:20,720
the instance to get the sale price

00:20:17,480 --> 00:20:25,070
column so I did not not actually have to

00:20:20,720 --> 00:20:27,500
write SQL by hand to have SQL alchemy do

00:20:25,070 --> 00:20:30,770
a performant query for me what does this

00:20:27,500 --> 00:20:33,700
get column sum for query here do it's

00:20:30,770 --> 00:20:33,700
right here

00:20:34,000 --> 00:20:40,460
first it gets the query is assumed it

00:20:37,100 --> 00:20:42,679
assumes the iterable is a query it drops

00:20:40,460 --> 00:20:46,610
whatever ordering it has explained later

00:20:42,679 --> 00:20:50,929
why and replaces all that it was going

00:20:46,610 --> 00:20:53,600
to fetch with a single expression which

00:20:50,929 --> 00:20:57,549
is this call as sum of the column what

00:20:53,600 --> 00:20:59,690
is call as summits right here it's using

00:20:57,549 --> 00:21:02,240
SQL alchemy func

00:20:59,690 --> 00:21:05,840
sum which is a representation of the sum

00:21:02,240 --> 00:21:07,490
function of the database around the

00:21:05,840 --> 00:21:08,960
column now this doesn't need to be an

00:21:07,490 --> 00:21:10,580
actual column this this could be a

00:21:08,960 --> 00:21:13,520
column in our expression or anything

00:21:10,580 --> 00:21:16,640
that feels like a column to a scalar

00:21:13,520 --> 00:21:18,679
alchemy so it's using the sum from that

00:21:16,640 --> 00:21:23,750
the the sum aggregating function from

00:21:18,679 --> 00:21:27,890
the database and and then it's calling

00:21:23,750 --> 00:21:32,090
coalesce with zero to it why is it doing

00:21:27,890 --> 00:21:34,370
that because in SQL if you do a sum of a

00:21:32,090 --> 00:21:37,880
bunch of records of a column of a bunch

00:21:34,370 --> 00:21:39,799
of records but this sequence of records

00:21:37,880 --> 00:21:43,700
has no records in it instead of getting

00:21:39,799 --> 00:21:45,770
a zero get a no or if you have records

00:21:43,700 --> 00:21:48,679
but all the columns in those records are

00:21:45,770 --> 00:21:50,929
no you're gonna get an old back but most

00:21:48,679 --> 00:21:52,820
cases when I want to use a sum I

00:21:50,929 --> 00:21:55,850
actually want a zero back in those cases

00:21:52,820 --> 00:21:59,480
so I create this call as sum function to

00:21:55,850 --> 00:22:02,720
return a sum of a column or a zero if

00:21:59,480 --> 00:22:04,250
there is no Lin there please ignore the

00:22:02,720 --> 00:22:08,140
filters and label for a while we are

00:22:04,250 --> 00:22:11,179
going to go back to it later so I

00:22:08,140 --> 00:22:15,470
replace all the entities in the query

00:22:11,179 --> 00:22:18,020
with just the call as sum of

00:22:15,470 --> 00:22:19,909
offers a specific column and if you

00:22:18,020 --> 00:22:24,710
remember it it was the dangers not sale

00:22:19,909 --> 00:22:27,470
price and the end now the reason why I

00:22:24,710 --> 00:22:29,360
drop whatever order in the query had is

00:22:27,470 --> 00:22:32,270
because since I'm calling an aggregating

00:22:29,360 --> 00:22:37,309
function either I have to have a group

00:22:32,270 --> 00:22:40,010
by clause on the SQL or whatever

00:22:37,309 --> 00:22:41,630
ordering I have and whatever ordering I

00:22:40,010 --> 00:22:45,320
have needs to be part of this group by

00:22:41,630 --> 00:22:47,049
or I cannot have an order so I make sure

00:22:45,320 --> 00:22:50,210
there is no order in this query

00:22:47,049 --> 00:22:53,179
especially since I'm not using a group

00:22:50,210 --> 00:22:55,429
by here in this case and which means

00:22:53,179 --> 00:22:58,010
that the database will return a single

00:22:55,429 --> 00:22:59,960
record and in this case a single record

00:22:58,010 --> 00:23:03,679
with a single column which is the sum

00:22:59,960 --> 00:23:05,539
I'm asking because of that I'm calling

00:23:03,679 --> 00:23:08,270
the scholar method from SQL alchemy

00:23:05,539 --> 00:23:10,909
which does exactly that it gives me the

00:23:08,270 --> 00:23:13,280
number that is in the value not

00:23:10,909 --> 00:23:15,110
necessary number but the value that is

00:23:13,280 --> 00:23:17,110
in the single column of the single

00:23:15,110 --> 00:23:20,659
record of the query there is just dead

00:23:17,110 --> 00:23:23,090
if the query is not a single record with

00:23:20,659 --> 00:23:25,010
a single color it raises an error but

00:23:23,090 --> 00:23:28,700
this is a very convenient function when

00:23:25,010 --> 00:23:32,870
I want just a number which is a sum of a

00:23:28,700 --> 00:23:38,110
column so coming back here instead of

00:23:32,870 --> 00:23:38,110
looping through a huge number of objects

00:23:39,429 --> 00:23:44,419
with all their columns just to get the

00:23:41,750 --> 00:23:46,700
sale price I'm asking the db2 the

00:23:44,419 --> 00:23:50,150
database to bring me exactly this sum

00:23:46,700 --> 00:23:53,559
that I want and I got that in the diff

00:23:50,150 --> 00:23:57,530
with a single line that's very readable

00:23:53,559 --> 00:24:01,309
so in this calculate total paid out

00:23:57,530 --> 00:24:03,409
which is everything that I have already

00:24:01,309 --> 00:24:06,200
paid to the debenture holders they have

00:24:03,409 --> 00:24:07,730
the same issue but here instead they

00:24:06,200 --> 00:24:11,020
were looking at the payouts which were

00:24:07,730 --> 00:24:15,169
the operations of payment operations and

00:24:11,020 --> 00:24:16,880
then I replaced by the same thing going

00:24:15,169 --> 00:24:22,000
back a little going under a little bit

00:24:16,880 --> 00:24:22,000
more there was this whole method here

00:24:24,670 --> 00:24:30,910
it was called calculate total values

00:24:27,100 --> 00:24:33,760
involved which was doing a huge amount

00:24:30,910 --> 00:24:35,740
of those things getting the sum of a

00:24:33,760 --> 00:24:39,670
bunch of operations these was taking a

00:24:35,740 --> 00:24:43,060
very long time and the operations were

00:24:39,670 --> 00:24:45,520
all result of calling these methods here

00:24:43,060 --> 00:24:47,140
paper corporations earning operations

00:24:45,520 --> 00:25:00,360
are in tax operations and things like

00:24:47,140 --> 00:25:00,360
that so when I looked at those methods

00:25:01,290 --> 00:25:05,530
let's search for the one of these

00:25:03,520 --> 00:25:08,040
methods here for example or any

00:25:05,530 --> 00:25:08,040
operations

00:25:16,600 --> 00:25:22,460
so what it was doing it was looking at

00:25:20,570 --> 00:25:26,770
self dot operations which is one of

00:25:22,460 --> 00:25:30,290
those query relationships that I showed

00:25:26,770 --> 00:25:33,860
filtering by specific tag filtering it

00:25:30,290 --> 00:25:36,170
by some specific dates and returning

00:25:33,860 --> 00:25:38,120
them and all these operations rufio

00:25:36,170 --> 00:25:39,530
operations ernie operations earning

00:25:38,120 --> 00:25:45,020
taxes operations we're doing the same

00:25:39,530 --> 00:25:50,420
thing so what I did first was to factor

00:25:45,020 --> 00:25:53,240
out the data filters and create this

00:25:50,420 --> 00:25:55,940
class that's really just a record that

00:25:53,240 --> 00:25:59,180
thats collecting filters so a payback

00:25:55,940 --> 00:26:02,390
filter as this criteria source type

00:25:59,180 --> 00:26:04,100
equals note tags envelope payback guru

00:26:02,390 --> 00:26:07,280
face this filter earnest is these

00:26:04,100 --> 00:26:10,160
filters etc etc and what it did with

00:26:07,280 --> 00:26:13,940
those was I refactor those other methods

00:26:10,160 --> 00:26:18,950
to get those operations call this

00:26:13,940 --> 00:26:22,960
operations operations in period which is

00:26:18,950 --> 00:26:26,680
where I figured out the the data queries

00:26:22,960 --> 00:26:38,120
the the data filtering of the operations

00:26:26,680 --> 00:26:41,750
and replace those with with the filters

00:26:38,120 --> 00:26:45,860
applied why is that useful because then

00:26:41,750 --> 00:26:52,880
I could also do this other method here

00:26:45,860 --> 00:26:55,310
called calculate operation summary which

00:26:52,880 --> 00:26:58,940
returns a single record what record is

00:26:55,310 --> 00:27:03,650
that it takes all those operations the

00:26:58,940 --> 00:27:07,340
same period order by none replace all

00:27:03,650 --> 00:27:09,530
the entities with the summary columns

00:27:07,340 --> 00:27:10,970
why why I call them summary because just

00:27:09,530 --> 00:27:12,710
like a bestiary is a collection of

00:27:10,970 --> 00:27:17,060
beasts a summary is a collection of sums

00:27:12,710 --> 00:27:23,300
and that's exactly what this method does

00:27:17,060 --> 00:27:27,230
it takes a call as some of the same

00:27:23,300 --> 00:27:29,820
columns that we were looking at giving

00:27:27,230 --> 00:27:33,000
them a labels

00:27:29,820 --> 00:27:37,040
that are like the variables that were

00:27:33,000 --> 00:27:39,450
being collected in that method above and

00:27:37,040 --> 00:27:43,680
returning those as the columns that I'm

00:27:39,450 --> 00:27:45,630
gonna put in the query and because these

00:27:43,680 --> 00:27:47,700
is a call as sum and I'm not doing a

00:27:45,630 --> 00:27:49,770
group by the result of this queue is

00:27:47,700 --> 00:27:52,350
going to be a single record which is why

00:27:49,770 --> 00:28:02,640
I call the one method that returns that

00:27:52,350 --> 00:28:05,640
single record so when I use this method

00:28:02,640 --> 00:28:08,870
here I get back this operation summary

00:28:05,640 --> 00:28:12,140
which is a record that has as attributes

00:28:08,870 --> 00:28:20,910
that labels that I pass to the columns

00:28:12,140 --> 00:28:23,670
so when when we we get here that's

00:28:20,910 --> 00:28:25,890
that's why we have this label parameter

00:28:23,670 --> 00:28:30,210
here in koalas some so that I could give

00:28:25,890 --> 00:28:33,870
that specific label to my some sameen

00:28:30,210 --> 00:28:39,210
column and what is this filter here

00:28:33,870 --> 00:28:41,390
there is this characteristic in SQL

00:28:39,210 --> 00:28:44,990
where if you have an aggregation

00:28:41,390 --> 00:28:47,880
function in a column like sum or average

00:28:44,990 --> 00:28:50,250
you don't necessarily need to do that

00:28:47,880 --> 00:28:51,810
over the whole of the records or or the

00:28:50,250 --> 00:28:54,510
whole or the records of a group you can

00:28:51,810 --> 00:28:57,140
actually apply further filtering what

00:28:54,510 --> 00:28:57,140
does that look like

00:29:03,210 --> 00:29:07,679
so that isn't readable right

00:29:08,460 --> 00:29:16,620
is it readable now okay one more just be

00:29:13,600 --> 00:29:16,620
sure so

00:29:22,190 --> 00:29:28,460
so yeah yeah this is nice to show as

00:29:25,640 --> 00:29:33,500
well I have the some of those models

00:29:28,460 --> 00:29:35,420
that I declared I created the major

00:29:33,500 --> 00:29:37,430
holder added into the database

00:29:35,420 --> 00:29:43,730
flushed it so that it has this it's a

00:29:37,430 --> 00:29:47,600
primary key and here I show what a query

00:29:43,730 --> 00:29:51,890
for the main shirt looks like in SQL

00:29:47,600 --> 00:29:55,850
alchemy you can print a query and it

00:29:51,890 --> 00:29:59,990
gives you this ringside version with the

00:29:55,850 --> 00:30:01,670
parameters there in place so I but it's

00:29:59,990 --> 00:30:04,390
nice to know what what the permit is

00:30:01,670 --> 00:30:06,920
gonna be so I created this function that

00:30:04,390 --> 00:30:10,310
formats and colorize this output and

00:30:06,920 --> 00:30:13,630
tells me what are the parameters so if I

00:30:10,310 --> 00:30:18,620
do the bencher query but filtered by

00:30:13,630 --> 00:30:20,510
created bigger ten today and holder it

00:30:18,620 --> 00:30:24,710
will equal a certain holder that

00:30:20,510 --> 00:30:28,400
variable that I created just about it

00:30:24,710 --> 00:30:30,850
generates this query to the database so

00:30:28,400 --> 00:30:34,840
you can see that it has created here and

00:30:30,850 --> 00:30:37,520
the debenture holder and i can see what

00:30:34,840 --> 00:30:44,330
parameters is going to pass so created

00:30:37,520 --> 00:30:46,340
is a date time with this value and the

00:30:44,330 --> 00:30:50,030
parallel one here which is the debenture

00:30:46,340 --> 00:30:51,110
holder has this integral value here

00:30:50,030 --> 00:30:53,540
which is the primary key of the

00:30:51,110 --> 00:30:55,880
debenture holder that there was doing it

00:30:53,540 --> 00:30:58,820
as the future now the nice thing about

00:30:55,880 --> 00:31:01,820
here is that I'm actually comparing the

00:30:58,820 --> 00:31:03,800
relationship object not the ID of the

00:31:01,820 --> 00:31:12,290
object here but it translates me into

00:31:03,800 --> 00:31:13,970
comparing the ID in the query so so here

00:31:12,290 --> 00:31:18,230
I created the bench were added to a

00:31:13,970 --> 00:31:19,580
series the debenture series object is

00:31:18,230 --> 00:31:21,440
it's actually complicated for

00:31:19,580 --> 00:31:26,870
relationships so I created a factory for

00:31:21,440 --> 00:31:28,730
it so and here I can check that the

00:31:26,870 --> 00:31:31,190
holder ID in the bencher holder is

00:31:28,730 --> 00:31:35,810
exactly the ID of the debenture holder

00:31:31,190 --> 00:31:38,290
that I created so when I look at the

00:31:35,810 --> 00:31:41,690
of the Demeter holder just like I said

00:31:38,290 --> 00:31:45,530
it's a query that selects all the

00:31:41,690 --> 00:31:51,440
benchers that match that the venture

00:31:45,530 --> 00:31:54,590
holder if I also filter by the venture

00:31:51,440 --> 00:31:56,090
state and sale date then I get this

00:31:54,590 --> 00:31:59,270
other query here without these

00:31:56,090 --> 00:32:02,570
parameters replaced so going back to our

00:31:59,270 --> 00:32:04,670
optimization the debenture serious

00:32:02,570 --> 00:32:09,290
operations is this query over operations

00:32:04,670 --> 00:32:11,480
here and when I asked for Giroux few

00:32:09,290 --> 00:32:13,760
operations which was that method it's

00:32:11,480 --> 00:32:15,790
the same inquiry over operations but

00:32:13,760 --> 00:32:27,800
with added filters in the where clause

00:32:15,790 --> 00:32:31,300
right that means okay so here is what I

00:32:27,800 --> 00:32:33,230
did with the operation summary I

00:32:31,300 --> 00:32:37,310
replaced all the columns in the

00:32:33,230 --> 00:32:39,620
operations with those columns and since

00:32:37,310 --> 00:32:42,230
the formatter wasn't very good I did my

00:32:39,620 --> 00:32:49,580
own formatting here let me show that

00:32:42,230 --> 00:32:51,560
instead so instead of think since I

00:32:49,580 --> 00:32:53,630
added those filters at the column level

00:32:51,560 --> 00:32:55,820
instead of putting those hilter's at the

00:32:53,630 --> 00:33:00,680
where clause it's actually putting those

00:32:55,820 --> 00:33:02,900
filters along with the sum this is very

00:33:00,680 --> 00:33:05,120
useful for things like I want to know

00:33:02,900 --> 00:33:07,010
the percentage of clients that have a

00:33:05,120 --> 00:33:10,310
certain characteristic over all of the

00:33:07,010 --> 00:33:13,040
clients I can do that by doing a sum

00:33:10,310 --> 00:33:14,780
filter and dividing that by the Sun

00:33:13,040 --> 00:33:16,970
without the filter and the database

00:33:14,780 --> 00:33:19,070
fetches that for me I don't need to do

00:33:16,970 --> 00:33:21,050
two queries one work one with the where

00:33:19,070 --> 00:33:23,570
clause run without and then dividing it

00:33:21,050 --> 00:33:26,000
at the item side I can have the database

00:33:23,570 --> 00:33:32,240
do that for me at the database side so

00:33:26,000 --> 00:33:35,720
here we have the operation summary it

00:33:32,240 --> 00:33:37,940
creates a bunch of columns which has

00:33:35,720 --> 00:33:43,670
they have these filters and doing the

00:33:37,940 --> 00:33:49,240
respective sums for me so here we have

00:33:43,670 --> 00:33:49,240
paid back operations and here we have

00:33:50,140 --> 00:33:55,040
so you have these tags here and these

00:33:53,030 --> 00:33:56,720
tags are there here so we have note

00:33:55,040 --> 00:33:59,150
paybacks and fees and earnings and

00:33:56,720 --> 00:34:04,520
things like that so it's filtering them

00:33:59,150 --> 00:34:06,380
ask the Select clause in the where

00:34:04,520 --> 00:34:08,750
clause it's just making sure it's

00:34:06,380 --> 00:34:10,990
selecting the operations with the right

00:34:08,750 --> 00:34:15,880
state belonging to the right account

00:34:10,990 --> 00:34:19,929
ending the right time range that I asked

00:34:15,880 --> 00:34:22,880
so with a single hit to the database I

00:34:19,929 --> 00:34:24,350
selected subsections of all their

00:34:22,880 --> 00:34:26,720
operations did a bunch of calculations

00:34:24,350 --> 00:34:30,320
for them and got exactly the information

00:34:26,720 --> 00:34:33,860
that I wanted and with these kinds of

00:34:30,320 --> 00:34:38,090
things I got completely read off of the

00:34:33,860 --> 00:34:42,380
cache and brought down the time of the

00:34:38,090 --> 00:34:45,110
report from nine hours per series down

00:34:42,380 --> 00:34:47,810
to four hours per series why four hours

00:34:45,110 --> 00:34:49,280
because the rest of the of the time it

00:34:47,810 --> 00:34:51,740
was not just a report he's actually

00:34:49,280 --> 00:34:53,480
inserting the debenture payments ended

00:34:51,740 --> 00:34:55,880
into the database because next time I

00:34:53,480 --> 00:34:57,860
wanted to run this report I wanted to

00:34:55,880 --> 00:34:59,900
run a difference and in anything that

00:34:57,860 --> 00:35:01,370
was not collected correctly or any

00:34:59,900 --> 00:35:08,710
rounding errors should be paid in the

00:35:01,370 --> 00:35:18,230
next month so to optimize the insertion

00:35:08,710 --> 00:35:20,800
I had this I had in the system let me

00:35:18,230 --> 00:35:20,800
locate it here

00:35:26,220 --> 00:35:44,140
so the the report already had some

00:35:33,760 --> 00:35:49,360
optimization done before which was to

00:35:44,140 --> 00:35:50,890
calculate the insert query for each the

00:35:49,360 --> 00:35:53,770
venture payment the venture payout

00:35:50,890 --> 00:35:59,100
manually but it was still calculating

00:35:53,770 --> 00:36:04,090
one insert for the bencher every month

00:35:59,100 --> 00:36:07,210
of course most of these in most of these

00:36:04,090 --> 00:36:10,300
inserts were they look exactly the same

00:36:07,210 --> 00:36:12,910
because all the debentures bought by the

00:36:10,300 --> 00:36:19,770
major holder in a certain date have the

00:36:12,910 --> 00:36:23,380
same calculations so they were cashing

00:36:19,770 --> 00:36:25,780
the the calculations by sale date and

00:36:23,380 --> 00:36:30,660
holder ID but still they were looping

00:36:25,780 --> 00:36:34,590
through all the debentures and then

00:36:30,660 --> 00:36:38,980
creating those inserts one by one

00:36:34,590 --> 00:36:43,150
instead of that what I did was to loop

00:36:38,980 --> 00:36:44,740
through only the each integral ization

00:36:43,150 --> 00:36:46,450
and interval is asian is the set of the

00:36:44,740 --> 00:36:51,340
ventures bought by a holder in a

00:36:46,450 --> 00:36:54,000
specific day so I created this criteria

00:36:51,340 --> 00:36:58,960
which is the integral ization columns

00:36:54,000 --> 00:37:01,270
which is the holder ad in sale date I'm

00:36:58,960 --> 00:37:04,590
adding a count of the danger so that I

00:37:01,270 --> 00:37:09,610
can do the proper calculations I'm

00:37:04,590 --> 00:37:11,560
joining the the bencher holders and the

00:37:09,610 --> 00:37:14,560
in the series here so that it fetches

00:37:11,560 --> 00:37:17,800
everything at the same time and I'm

00:37:14,560 --> 00:37:20,920
asking for a distinct query so that the

00:37:17,800 --> 00:37:24,940
database only fetches one debenture per

00:37:20,920 --> 00:37:27,850
integral ization and because of the

00:37:24,940 --> 00:37:29,620
distinct I need this ordered by the

00:37:27,850 --> 00:37:31,210
intergeneration columns and the major

00:37:29,620 --> 00:37:33,450
series number what does the query look

00:37:31,210 --> 00:37:33,450
like

00:37:34,920 --> 00:37:41,910
so because I asked for distinct as

00:37:40,380 --> 00:37:47,880
Kellogg me rendered this as this

00:37:41,910 --> 00:37:49,829
distinct own query here and then

00:37:47,880 --> 00:37:52,529
selected all the information from the

00:37:49,829 --> 00:37:56,789
debentures but only of one debenture per

00:37:52,529 --> 00:37:59,339
integral ization and then it joined that

00:37:56,789 --> 00:38:01,410
information it's kind of hard to be read

00:37:59,339 --> 00:38:03,269
here but it joined that information with

00:38:01,410 --> 00:38:05,460
the similar information I need it like

00:38:03,269 --> 00:38:08,339
this some of the dimensions paid in and

00:38:05,460 --> 00:38:10,109
things like that so it goes with a

00:38:08,339 --> 00:38:11,670
single hit of the database fetches all

00:38:10,109 --> 00:38:15,029
the information and then I can loop and

00:38:11,670 --> 00:38:18,720
it's all calculated but the most

00:38:15,029 --> 00:38:20,819
important part here is that instead of

00:38:18,720 --> 00:38:25,410
calculating the inserts by hand

00:38:20,819 --> 00:38:28,529
I get the debenture payout table and ask

00:38:25,410 --> 00:38:31,049
for an insert query and then instead of

00:38:28,529 --> 00:38:35,220
a regular insert I do an insert from

00:38:31,049 --> 00:38:39,569
select and I select from the integral is

00:38:35,220 --> 00:38:43,559
Asian debentures replacing the entities

00:38:39,569 --> 00:38:48,299
with the columns that I need to populate

00:38:43,559 --> 00:38:56,930
one debenture payout what does that look

00:38:48,299 --> 00:38:59,640
like so here I do the same query and

00:38:56,930 --> 00:39:01,950
what it does is does the insert into the

00:38:59,640 --> 00:39:05,940
major payout all the columns that I

00:39:01,950 --> 00:39:09,329
selected and what is it what is

00:39:05,940 --> 00:39:11,160
inserting is a select of all those

00:39:09,329 --> 00:39:13,710
parameters some parameters are constant

00:39:11,160 --> 00:39:17,130
some other parameters are from the

00:39:13,710 --> 00:39:19,529
Select and then it's mapping all those

00:39:17,130 --> 00:39:22,799
information so instead of doing search

00:39:19,529 --> 00:39:24,900
one by one manually written in SQL from

00:39:22,799 --> 00:39:27,509
the Python side I'm asking me I'm

00:39:24,900 --> 00:39:31,619
actually asking the DB to do the inserts

00:39:27,509 --> 00:39:34,609
for me and that brought down the the the

00:39:31,619 --> 00:39:40,109
the report time down to 15 minutes

00:39:34,609 --> 00:39:43,019
from nine hours per the major series the

00:39:40,109 --> 00:39:44,700
last optimization I did and this is the

00:39:43,019 --> 00:39:46,390
one that justifies the from minutes

00:39:44,700 --> 00:39:53,770
milliseconds

00:39:46,390 --> 00:39:56,380
is the IAP - i optimize a page rendering

00:39:53,770 --> 00:39:58,950
based based on how much time it was

00:39:56,380 --> 00:40:06,100
wasting authorizing the user

00:39:58,950 --> 00:40:16,810
let me find here so during the

00:40:06,100 --> 00:40:19,060
authorization phase a while rendering

00:40:16,810 --> 00:40:20,619
specific page it was checking the user

00:40:19,060 --> 00:40:22,660
had permission to see certain bits of

00:40:20,619 --> 00:40:26,800
information this is a server-side

00:40:22,660 --> 00:40:29,680
rendering so it's not so so fun to do

00:40:26,800 --> 00:40:30,940
these days but it was doing user doesn't

00:40:29,680 --> 00:40:33,580
mean that has permission

00:40:30,940 --> 00:40:35,770
except that admin is actually a property

00:40:33,580 --> 00:40:37,420
that does a query to the database so it

00:40:35,770 --> 00:40:40,440
was doing a query to the database every

00:40:37,420 --> 00:40:43,090
time and then asking if again getting a

00:40:40,440 --> 00:40:45,700
or M record and asking if it has

00:40:43,090 --> 00:40:48,250
permission which is an which also goes

00:40:45,700 --> 00:40:49,840
to the database to fetch if if that

00:40:48,250 --> 00:40:51,480
permission belongs to the user it was

00:40:49,840 --> 00:40:55,600
doing that all the time

00:40:51,480 --> 00:40:58,390
so just looking at this at this code I

00:40:55,600 --> 00:41:03,400
already said well just pull that has

00:40:58,390 --> 00:41:05,460
permission out and but the the the

00:41:03,400 --> 00:41:08,640
biggest part of the optimization

00:41:05,460 --> 00:41:09,990
actually happening happened

00:41:08,640 --> 00:41:13,450
[Music]

00:41:09,990 --> 00:41:17,200
well I replaced the property by a Phi

00:41:13,450 --> 00:41:24,190
which caches the property and fetches

00:41:17,200 --> 00:41:28,090
only once but also instead of having

00:41:24,190 --> 00:41:30,310
those profiles be dynamic queries I did

00:41:28,090 --> 00:41:32,710
the opposite I pulled all profiles at

00:41:30,310 --> 00:41:35,740
once also through a escharotomy

00:41:32,710 --> 00:41:41,500
relationship so if we have this all

00:41:35,740 --> 00:41:44,230
profiles relationship here that is not a

00:41:41,500 --> 00:41:47,080
dynamic query it goes to the database

00:41:44,230 --> 00:41:49,330
once when it's a sex acts is except

00:41:47,080 --> 00:41:50,859
accessed and pulls a list and so we have

00:41:49,330 --> 00:41:53,980
a Python list every time you access it

00:41:50,859 --> 00:41:55,810
and then I created a get matching

00:41:53,980 --> 00:41:57,820
profiles which is the Python file loops

00:41:55,810 --> 00:41:59,140
through this list now the thing is is a

00:41:57,820 --> 00:42:02,200
tiny list

00:41:59,140 --> 00:42:04,180
the roles of our user is a tiny list so

00:42:02,200 --> 00:42:06,069
it actually makes sense here to pull the

00:42:04,180 --> 00:42:08,349
calculation out of the database into the

00:42:06,069 --> 00:42:12,210
Python side because I'm minimizing the

00:42:08,349 --> 00:42:23,829
amount of data that is circulating and

00:42:12,210 --> 00:42:27,839
the other big part here is that while

00:42:23,829 --> 00:42:27,839
fetching the user for the authentication

00:42:30,809 --> 00:42:35,499
no it's not this let me see no it's here

00:42:33,940 --> 00:42:38,589
well fetching the user for the

00:42:35,499 --> 00:42:42,940
authentication I'm actually instructing

00:42:38,589 --> 00:42:45,940
its instructing SQL alchemy to giant

00:42:42,940 --> 00:42:49,089
load all the profiles and join load of

00:42:45,940 --> 00:42:51,400
those profiles all the permissions so it

00:42:49,089 --> 00:42:54,609
does the single query pulling the user

00:42:51,400 --> 00:42:56,859
all its profiles and all the other their

00:42:54,609 --> 00:42:59,589
permissions in a single hedge of the

00:42:56,859 --> 00:43:02,109
database and now when I access the

00:42:59,589 --> 00:43:04,029
properties of this linked data

00:43:02,109 --> 00:43:06,400
structured I'm not going to the database

00:43:04,029 --> 00:43:08,259
anymore and that brought down the page

00:43:06,400 --> 00:43:11,920
to up they took minutes to render down

00:43:08,259 --> 00:43:14,769
to milliseconds now

00:43:11,920 --> 00:43:26,559
so in conclusion and yes there is a

00:43:14,769 --> 00:43:29,619
conclusion okay yes to figure out what

00:43:26,559 --> 00:43:31,269
was happening I abused this there's this

00:43:29,619 --> 00:43:34,779
patent package called slow log which is

00:43:31,269 --> 00:43:36,880
good for WSGI up applications when a

00:43:34,779 --> 00:43:39,339
request is taking too long it starts

00:43:36,880 --> 00:43:42,609
dumping stack traces into a log file

00:43:39,339 --> 00:43:45,190
it's perfect to see what is wasting time

00:43:42,609 --> 00:43:47,140
where without um having to be there when

00:43:45,190 --> 00:43:49,480
things go slow you can just go to log

00:43:47,140 --> 00:43:51,549
file and retrieve it and then I saw that

00:43:49,480 --> 00:43:52,470
that function there with the admin was

00:43:51,549 --> 00:44:00,759
its lowest one

00:43:52,470 --> 00:44:03,730
so in conclusion our ends are very nice

00:44:00,759 --> 00:44:06,579
too

00:44:03,730 --> 00:44:08,770
get started if your programmer in a not

00:44:06,579 --> 00:44:10,900
very familiar with SQL it's a good way

00:44:08,770 --> 00:44:13,810
to get started I'm not this dissing on

00:44:10,900 --> 00:44:17,470
an RMS here and I love using or m's but

00:44:13,810 --> 00:44:19,390
you should understand your SQL read the

00:44:17,470 --> 00:44:21,280
Select documentation of your database

00:44:19,390 --> 00:44:24,609
and try to understand what every bit

00:44:21,280 --> 00:44:26,589
does there I figured out the that you

00:44:24,609 --> 00:44:27,790
could apply filter we're inside some

00:44:26,589 --> 00:44:31,030
columns by reading the Select

00:44:27,790 --> 00:44:32,800
documentation understand group by in

00:44:31,030 --> 00:44:36,160
aggregations and how aggregations reduce

00:44:32,800 --> 00:44:37,800
the cardinality of your functions learn

00:44:36,160 --> 00:44:40,270
about aggregation functions with filters

00:44:37,800 --> 00:44:42,010
learn about distinct on and window

00:44:40,270 --> 00:44:44,050
expressions that will help you write SQL

00:44:42,010 --> 00:44:47,740
that fetches things are efficiently and

00:44:44,050 --> 00:44:50,170
then studi SQL alchemy be aware of the

00:44:47,740 --> 00:44:52,599
underlying peer is that it does push as

00:44:50,170 --> 00:44:56,200
much work as possible to the DB but not

00:44:52,599 --> 00:44:58,900
too much because sometimes your career

00:44:56,200 --> 00:45:02,339
is going to spend hours and that's it

00:44:58,900 --> 00:45:02,339
thank you very much

00:45:05,760 --> 00:45:11,059
[Applause]

00:45:11,660 --> 00:45:17,060
but I'll be around if you have any just

00:45:14,250 --> 00:45:17,060

YouTube URL: https://www.youtube.com/watch?v=Sq1TDj8mIrs


