Title: Kanianthra Chandy - IoTPy: Python + Streams + Agents for Streaming Applications
Publication date: 2020-09-15
Playlist: EuroPython 2020
Description: 
	"IoTPy: Python + Streams + Agents for Streaming Applications
EuroPython 2020 - Talk - 2020-07-23 - Brian
Online

By Kanianthra Chandy

Sensors, social media, news feeds, webcams and other sources generate streams of data which are analyzed to control actuators, generate alerts, and feed displays. These applications process streams on onboard computers, such as the Raspberry Pi, connected directly to sensors, and send summarized information to the cloud for further processing. These applications have two characteristics: (1) Concurrency: The applications are concurrent using multiple threads to connect to sensors and actuators, shared memory across multiple processes on multicore machines and message passing for distributed systems spanning multiple computers. (2) Data Analysis: The applications use programs from a variety of libraries including those for signal processing, machine learning and natural language processing.

Developers of streaming applications can use open-source software to deal with both characteristics. Concurrency: multiprocessing.Array can be used to construct shared-memory multiprocessing Python programs in multicore computers, and frameworks such as APMQ and Kafka can be used to build distributed applications. Data Analysis: A vast collection of open-source Python libraries can be used to analyze data in streams. Developers of streaming applications encounter an impedance mismatch between the software libraries that address these two characteristics. The next paragraph describes the mismatch and how IoTPy addresses it. 

Programs in most software libraries apply a function to data, get results, and terminate execution. By contrast, streaming applications are perpetual processes that analyze endless streams of data. IoTPy helps developers: (1) build non-terminating streaming applications by harnessing conventional terminating programs from Pythonâ€™s huge base of libraries and (2) create multithreaded, multicore and distributed Python applications by simply connecting streams to each other.

https://www.AssembleSoftware.com



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2020.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:06,480 --> 00:00:12,719
this talk is about

00:00:09,120 --> 00:00:16,720
yo tip i yot pie it's python

00:00:12,719 --> 00:00:18,880
streams asian for streaming applications

00:00:16,720 --> 00:00:21,439
so i think you can just start sharing

00:00:18,880 --> 00:00:21,439
your screen

00:00:21,520 --> 00:00:25,359
and we should be ready to go

00:00:26,160 --> 00:00:29,359
so for everyone please remember so this

00:00:28,800 --> 00:00:32,559
talk is

00:00:29,359 --> 00:00:34,800
30 minutes and after the talk

00:00:32,559 --> 00:00:35,600
uh at the end of the tour we are going

00:00:34,800 --> 00:00:38,559
to have a

00:00:35,600 --> 00:00:38,960
few minutes for q a so you can click in

00:00:38,559 --> 00:00:41,440
the q

00:00:38,960 --> 00:00:42,239
a bottom and write your question and i'm

00:00:41,440 --> 00:00:45,840
going to ask

00:00:42,239 --> 00:00:45,840
it later

00:00:45,920 --> 00:00:52,000
and after the talk

00:00:49,200 --> 00:00:53,680
we have a discord channel where you can

00:00:52,000 --> 00:00:54,480
continue the discussion or if you have

00:00:53,680 --> 00:00:58,079
any question

00:00:54,480 --> 00:01:01,280
where okay

00:00:58,079 --> 00:01:02,800
so thank you very much so this is an

00:01:01,280 --> 00:01:06,159
invitation

00:01:02,800 --> 00:01:08,960
it's an invitation to help build a free

00:01:06,159 --> 00:01:10,080
open source python package so that

00:01:08,960 --> 00:01:13,040
everybody

00:01:10,080 --> 00:01:14,960
can monitor analyze and respond to

00:01:13,040 --> 00:01:18,320
streams of data

00:01:14,960 --> 00:01:22,479
my name is mani chandi and my co-author

00:01:18,320 --> 00:01:24,880
is deepak narayana each sensor

00:01:22,479 --> 00:01:26,560
in the internet of things generates a

00:01:24,880 --> 00:01:28,799
data stream

00:01:26,560 --> 00:01:30,240
an airplane generates a stream of its

00:01:28,799 --> 00:01:32,320
locations

00:01:30,240 --> 00:01:34,400
and the microphone generates an audio

00:01:32,320 --> 00:01:37,280
stream

00:01:34,400 --> 00:01:40,400
social media generates streams twitter

00:01:37,280 --> 00:01:43,119
generates streams of tweets

00:01:40,400 --> 00:01:44,000
now we have technology that can help us

00:01:43,119 --> 00:01:48,399
analyze

00:01:44,000 --> 00:01:51,040
streams inexpensive onboard computers

00:01:48,399 --> 00:01:51,920
such as the raspberry pi loaded with

00:01:51,040 --> 00:01:55,920
python

00:01:51,920 --> 00:01:59,520
are connected directly to sensors

00:01:55,920 --> 00:02:02,799
powerful libraries such as sci-fi

00:01:59,520 --> 00:02:04,799
can be used to analyze streams the cloud

00:02:02,799 --> 00:02:05,759
is another resource for this variety of

00:02:04,799 --> 00:02:08,959
python

00:02:05,759 --> 00:02:11,599
api services

00:02:08,959 --> 00:02:13,760
so would you help to build a free open

00:02:11,599 --> 00:02:14,959
source python package that everybody can

00:02:13,760 --> 00:02:18,480
use

00:02:14,959 --> 00:02:21,520
using free or inexpensive technology

00:02:18,480 --> 00:02:24,239
to solve this important problem

00:02:21,520 --> 00:02:24,879
so i started working on this many years

00:02:24,239 --> 00:02:27,840
ago

00:02:24,879 --> 00:02:29,599
and you can see some of the work at

00:02:27,840 --> 00:02:32,319
github

00:02:29,599 --> 00:02:34,160
and i started iot pi because i had

00:02:32,319 --> 00:02:37,360
worked on many applications

00:02:34,160 --> 00:02:38,720
with similar structures we were

00:02:37,360 --> 00:02:41,760
rewriting

00:02:38,720 --> 00:02:42,879
rather than reusing code one of the

00:02:41,760 --> 00:02:47,040
applications

00:02:42,879 --> 00:02:50,400
is the celtic community seismic network

00:02:47,040 --> 00:02:51,440
csm is a team of celtic scientists and

00:02:50,400 --> 00:02:54,560
engineers

00:02:51,440 --> 00:02:55,519
some of whom are listed here csn has

00:02:54,560 --> 00:02:59,920
deployed

00:02:55,519 --> 00:03:02,879
about 700 inexpensive accelerometers

00:02:59,920 --> 00:03:05,360
all over the los angeles unified school

00:03:02,879 --> 00:03:08,480
district area

00:03:05,360 --> 00:03:12,560
so each red dot represents

00:03:08,480 --> 00:03:15,680
a school and a sensor in that school

00:03:12,560 --> 00:03:18,560
i want to emphasize the community aspect

00:03:15,680 --> 00:03:19,360
of the community seismic network we'll

00:03:18,560 --> 00:03:21,840
see

00:03:19,360 --> 00:03:22,640
that school administrators students

00:03:21,840 --> 00:03:25,360
parents

00:03:22,640 --> 00:03:28,720
indeed the entire community can benefit

00:03:25,360 --> 00:03:31,920
from harnessing streams

00:03:28,720 --> 00:03:32,239
i'm going to show you i'm going to show

00:03:31,920 --> 00:03:34,720
you

00:03:32,239 --> 00:03:36,879
a video but you may not be very clear so

00:03:34,720 --> 00:03:38,159
this video was created by professor rob

00:03:36,879 --> 00:03:41,680
clayton at caltech

00:03:38,159 --> 00:03:44,959
which shows accelerations in schools

00:03:41,680 --> 00:03:46,319
so each dot represents a school and the

00:03:44,959 --> 00:03:48,959
color represents

00:03:46,319 --> 00:03:50,319
intensity now this kind of video this

00:03:48,959 --> 00:03:51,840
kind of information about how the earth

00:03:50,319 --> 00:03:56,319
is shaking in schools

00:03:51,840 --> 00:03:56,319
is immensely valuable for everybody

00:03:56,640 --> 00:04:00,319
i've had the opportunity to work with

00:03:59,040 --> 00:04:04,080
many groups

00:04:00,319 --> 00:04:07,040
working on streams analyzing tweets

00:04:04,080 --> 00:04:08,560
a home hazard station detecting

00:04:07,040 --> 00:04:12,319
radiation

00:04:08,560 --> 00:04:12,319
structural health monitoring

00:04:13,519 --> 00:04:20,320
and all these stream applications

00:04:17,120 --> 00:04:23,360
have aspects in common they have threads

00:04:20,320 --> 00:04:24,639
that interface with data sources or

00:04:23,360 --> 00:04:26,320
actuators

00:04:24,639 --> 00:04:29,280
streams are processed right where

00:04:26,320 --> 00:04:33,120
they're generated on onboard computers

00:04:29,280 --> 00:04:35,360
in shared memory and in the cloud

00:04:33,120 --> 00:04:38,479
all these applications acquire and

00:04:35,360 --> 00:04:38,479
process streams

00:04:40,560 --> 00:04:46,960
so iot pi creates

00:04:43,680 --> 00:04:49,120
a common abstraction across this variety

00:04:46,960 --> 00:04:53,040
of stream applications

00:04:49,120 --> 00:04:56,240
moreover we hope that this abstraction

00:04:53,040 --> 00:04:57,440
blends with the way you program lends

00:04:56,240 --> 00:05:00,320
with pythonistic

00:04:57,440 --> 00:05:00,320
programming

00:05:00,479 --> 00:05:05,680
now we have two problems to solve to get

00:05:02,720 --> 00:05:08,479
a package that everybody can use

00:05:05,680 --> 00:05:10,160
firstly why those libraries weren't

00:05:08,479 --> 00:05:12,160
written for streams

00:05:10,160 --> 00:05:13,680
and streams are processed using

00:05:12,160 --> 00:05:16,320
different types of concurrency

00:05:13,680 --> 00:05:18,320
threads shared memory message processing

00:05:16,320 --> 00:05:20,880
and the package for everybody

00:05:18,320 --> 00:05:24,560
should offer a unifying approach let's

00:05:20,880 --> 00:05:27,600
look at the first problem

00:05:24,560 --> 00:05:28,160
a typical python function takes input

00:05:27,600 --> 00:05:30,320
data

00:05:28,160 --> 00:05:32,400
such as an array a function like an

00:05:30,320 --> 00:05:36,160
invert matrix

00:05:32,400 --> 00:05:40,800
takes the data and generates an output

00:05:36,160 --> 00:05:44,000
a inverse and then the function stops

00:05:40,800 --> 00:05:46,639
by contrast what we want is something

00:05:44,000 --> 00:05:49,759
persistent something that lives forever

00:05:46,639 --> 00:05:53,199
we want an agent that acquires

00:05:49,759 --> 00:05:56,160
data continuously and produces data

00:05:53,199 --> 00:05:56,160
continuously

00:05:57,280 --> 00:06:01,600
so the abstraction for an agent is very

00:06:00,560 --> 00:06:04,319
simple

00:06:01,600 --> 00:06:05,199
it's a black box actually pink in this

00:06:04,319 --> 00:06:09,919
example

00:06:05,199 --> 00:06:13,440
with inputs a b and outputs x y z

00:06:09,919 --> 00:06:16,639
and everything here is persistent

00:06:13,440 --> 00:06:18,479
it lasts forever

00:06:16,639 --> 00:06:20,560
so for example we might be able to

00:06:18,479 --> 00:06:22,080
instantiate this agent by calling a

00:06:20,560 --> 00:06:24,560
python function f

00:06:22,080 --> 00:06:27,600
with his example in streams a b and out

00:06:24,560 --> 00:06:27,600
streams x y and z

00:06:27,919 --> 00:06:33,440
now here's the tricky part so the agent

00:06:31,360 --> 00:06:34,880
is persistent and his inputs xy in this

00:06:33,440 --> 00:06:38,319
example are persist

00:06:34,880 --> 00:06:41,120
persistent and associated with the agent

00:06:38,319 --> 00:06:42,560
is an action in this example the action

00:06:41,120 --> 00:06:48,800
is to make y

00:06:42,560 --> 00:06:52,240
equal to g of x so

00:06:48,800 --> 00:06:55,120
if the agent's goal is established

00:06:52,240 --> 00:06:55,599
in other words if y is equal to x plus 1

00:06:55,120 --> 00:06:58,720
in this

00:06:55,599 --> 00:07:00,160
case so if x is 1 and y is 2 the agent's

00:06:58,720 --> 00:07:02,639
goal is established

00:07:00,160 --> 00:07:05,440
so the agent is quiescent or idle it's

00:07:02,639 --> 00:07:05,440
got nothing to do

00:07:05,759 --> 00:07:11,280
if however the input changes so for

00:07:09,039 --> 00:07:14,560
example the input is two

00:07:11,280 --> 00:07:17,919
then the condition is violated

00:07:14,560 --> 00:07:21,919
because y is no longer x 1

00:07:17,919 --> 00:07:21,919
so the agent becomes active

00:07:23,360 --> 00:07:26,960
and when the agent becomes active at

00:07:26,000 --> 00:07:29,919
some point

00:07:26,960 --> 00:07:31,280
in the future an active agent

00:07:29,919 --> 00:07:34,319
re-establishes his

00:07:31,280 --> 00:07:37,199
goal so in this case changes y

00:07:34,319 --> 00:07:37,199
to become three

00:07:37,680 --> 00:07:42,560
the problem is that we don't know

00:07:40,080 --> 00:07:45,759
exactly when

00:07:42,560 --> 00:07:49,599
an agent will take a step so for

00:07:45,759 --> 00:07:52,400
example if the inputs are 0 1 2 3 4

00:07:49,599 --> 00:07:53,120
and the initial output y is 0 you would

00:07:52,400 --> 00:07:56,240
expect

00:07:53,120 --> 00:08:00,800
the output to go 0 1 2 3 4

00:07:56,240 --> 00:08:04,240
5. however if the agent only sees

00:08:00,800 --> 00:08:04,639
inputs two and four the output will be

00:08:04,240 --> 00:08:08,479
zero

00:08:04,639 --> 00:08:10,960
three five it'll skip some steps

00:08:08,479 --> 00:08:11,759
now what this means is that if you have

00:08:10,960 --> 00:08:14,879
two

00:08:11,759 --> 00:08:18,000
identical agents here z

00:08:14,879 --> 00:08:18,960
and w both of which are computing y plus

00:08:18,000 --> 00:08:22,960
four

00:08:18,960 --> 00:08:22,960
they might produce different outputs

00:08:23,360 --> 00:08:26,639
so the tricky part and we'll talk about

00:08:25,280 --> 00:08:29,199
this a little later

00:08:26,639 --> 00:08:31,840
is to use streams to obtain desired

00:08:29,199 --> 00:08:33,599
outcomes whatever the desired outcome is

00:08:31,840 --> 00:08:35,279
sometimes it's non-deterministic

00:08:33,599 --> 00:08:37,279
sometimes it's deterministic

00:08:35,279 --> 00:08:38,399
and it uses theories developed by j

00:08:37,279 --> 00:08:42,240
their misra

00:08:38,399 --> 00:08:45,200
and also ideas from kisha bengali

00:08:42,240 --> 00:08:45,839
now i'm going to slow down and talk

00:08:45,200 --> 00:08:49,200
about

00:08:45,839 --> 00:08:52,240
a very specific kind of shared object

00:08:49,200 --> 00:08:56,080
the shared object could be anything

00:08:52,240 --> 00:08:59,360
it could be a graph it could be

00:08:56,080 --> 00:09:00,560
it could be a simple stream but let's

00:08:59,360 --> 00:09:03,519
look at

00:09:00,560 --> 00:09:04,720
just a single stream so you can think of

00:09:03,519 --> 00:09:10,080
a stream

00:09:04,720 --> 00:09:13,200
as a tape an agent can read the entirety

00:09:10,080 --> 00:09:13,600
but it writes only at the tail of the

00:09:13,200 --> 00:09:15,440
tape

00:09:13,600 --> 00:09:17,120
and it keeps writing to the tail of the

00:09:15,440 --> 00:09:20,320
tape

00:09:17,120 --> 00:09:23,120
and as i said when this input

00:09:20,320 --> 00:09:25,279
changes an agent becomes active if his

00:09:23,120 --> 00:09:27,600
output doesn't match his input

00:09:25,279 --> 00:09:29,920
and at some time later the agent takes a

00:09:27,600 --> 00:09:29,920
step

00:09:30,480 --> 00:09:34,560
here is an acoustics example developed

00:09:34,080 --> 00:09:38,560
by

00:09:34,560 --> 00:09:40,530
deepak and it produces a shimmer

00:09:38,560 --> 00:09:41,680
in an input so

00:09:40,530 --> 00:09:45,279
[Music]

00:09:41,680 --> 00:09:48,880
the sensors and actuators are shown

00:09:45,279 --> 00:09:51,600
in ellipses so for example the top right

00:09:48,880 --> 00:09:53,279
we have a thread that interfaces with a

00:09:51,600 --> 00:09:56,640
sensor a microphone

00:09:53,279 --> 00:09:59,120
that produces a stream called spoken

00:09:56,640 --> 00:10:01,360
and this is the stream of data values

00:09:59,120 --> 00:10:04,160
from the microphone

00:10:01,360 --> 00:10:05,200
the agent here called echo spoken gets

00:10:04,160 --> 00:10:08,320
two streams

00:10:05,200 --> 00:10:08,800
spoken and echo and produces a scene

00:10:08,320 --> 00:10:11,279
called

00:10:08,800 --> 00:10:12,880
heard sound which then feeds an agent

00:10:11,279 --> 00:10:15,120
called pitch shift

00:10:12,880 --> 00:10:17,760
which outputs a stream called pitch

00:10:15,120 --> 00:10:21,440
change which also feeds an actuator

00:10:17,760 --> 00:10:21,440
in this case a speaker

00:10:22,800 --> 00:10:29,760
it's when you go from

00:10:26,399 --> 00:10:34,320
a diagram to code

00:10:29,760 --> 00:10:37,920
the diagram is the code in other words

00:10:34,320 --> 00:10:41,120
you just write a function which

00:10:37,920 --> 00:10:44,240
exactly represents an agent so for

00:10:41,120 --> 00:10:45,279
the top we have a function f which takes

00:10:44,240 --> 00:10:48,480
inputs y

00:10:45,279 --> 00:10:52,160
and z produces an output x

00:10:48,480 --> 00:10:55,440
and we create that agent just by calling

00:10:52,160 --> 00:10:58,800
f now f is

00:10:55,440 --> 00:11:02,399
this agent is now going to live forever

00:10:58,800 --> 00:11:05,360
and we expect inputs and outputs

00:11:02,399 --> 00:11:08,000
to live forever so the law as long as

00:11:05,360 --> 00:11:11,760
the microphone is running

00:11:08,000 --> 00:11:14,320
the agents exist when the microphone

00:11:11,760 --> 00:11:15,600
stops and we declare that there's no

00:11:14,320 --> 00:11:20,320
further input

00:11:15,600 --> 00:11:20,320
the agents will step themselves down

00:11:20,640 --> 00:11:24,959
now a network of agents could be an

00:11:23,600 --> 00:11:28,480
agent as well

00:11:24,959 --> 00:11:31,600
so for example we can create a network

00:11:28,480 --> 00:11:35,440
an agent gh by combining

00:11:31,600 --> 00:11:35,760
agents g and h and the combined agent gh

00:11:35,440 --> 00:11:40,240
has

00:11:35,760 --> 00:11:40,240
input x and outputs y and z

00:11:41,519 --> 00:11:48,480
next let's look at how we

00:11:44,720 --> 00:11:51,200
use python to create atoms

00:11:48,480 --> 00:11:52,160
because the key idea in all of this is

00:11:51,200 --> 00:11:55,200
to harness

00:11:52,160 --> 00:11:56,720
the power of python's libraries to

00:11:55,200 --> 00:12:00,160
create these

00:11:56,720 --> 00:12:03,600
persistent non-terminating agents

00:12:00,160 --> 00:12:05,279
so we start with a function f

00:12:03,600 --> 00:12:06,639
that operates on a boundary data

00:12:05,279 --> 00:12:11,360
structure like an array

00:12:06,639 --> 00:12:13,680
standard python function and terminates

00:12:11,360 --> 00:12:15,839
what we're going to do is to wrap that

00:12:13,680 --> 00:12:18,160
function

00:12:15,839 --> 00:12:19,519
with another function g from the iot by

00:12:18,160 --> 00:12:22,639
library

00:12:19,519 --> 00:12:28,000
and wrapping f in g

00:12:22,639 --> 00:12:28,000
creates this persistent agent

00:12:29,760 --> 00:12:36,000
so let's look at a simple example

00:12:32,959 --> 00:12:40,160
so here we're declaring streams

00:12:36,000 --> 00:12:43,200
s and t happens to be

00:12:40,160 --> 00:12:45,200
in this case a numpy array so think of

00:12:43,200 --> 00:12:48,399
the stream

00:12:45,200 --> 00:12:51,760
as a numpy array of arbitrary

00:12:48,399 --> 00:12:54,880
length and goes on forever each

00:12:51,760 --> 00:12:57,360
element of this numpy array is itself

00:12:54,880 --> 00:12:59,760
a two by two array in this case an array

00:12:57,360 --> 00:13:03,040
of floats

00:12:59,760 --> 00:13:04,480
so we've now just declared two things

00:13:03,040 --> 00:13:07,839
that go on forever

00:13:04,480 --> 00:13:07,839
off type array

00:13:08,000 --> 00:13:15,200
now here is an example

00:13:11,360 --> 00:13:18,959
of how we wrap

00:13:15,200 --> 00:13:19,680
a python function with an iot by

00:13:18,959 --> 00:13:23,600
function

00:13:19,680 --> 00:13:26,320
to create this persistent agent

00:13:23,600 --> 00:13:27,600
in this example the function we are

00:13:26,320 --> 00:13:30,240
wrapping

00:13:27,600 --> 00:13:31,519
this matrix inverter that we get from

00:13:30,240 --> 00:13:34,800
numpy that's the np

00:13:31,519 --> 00:13:38,720
linear algebra invert so it's wrapped

00:13:34,800 --> 00:13:42,160
and now we've created a persistent agent

00:13:38,720 --> 00:13:45,279
with input stream s output stream t

00:13:42,160 --> 00:13:49,760
that expects to get a sequence

00:13:45,279 --> 00:13:53,040
of matrices that produces a sequence

00:13:49,760 --> 00:13:57,279
of inverse matrices and this will go on

00:13:53,040 --> 00:14:01,680
as long as the data comes in

00:13:57,279 --> 00:14:03,839
now iot5 has a library of these agents

00:14:01,680 --> 00:14:05,440
and library these functions to create

00:14:03,839 --> 00:14:07,839
agents and what i hope

00:14:05,440 --> 00:14:09,839
we would do together if we collaborate

00:14:07,839 --> 00:14:12,800
is to add to this library

00:14:09,839 --> 00:14:12,800
make it richer

00:14:13,120 --> 00:14:22,240
here is another way in which you can use

00:14:17,839 --> 00:14:25,440
priority pi so instead of having

00:14:22,240 --> 00:14:28,560
explicit core you can use a decorator

00:14:25,440 --> 00:14:29,440
here is a decorator called map w also

00:14:28,560 --> 00:14:33,040
from the iot

00:14:29,440 --> 00:14:35,680
by library it's map window

00:14:33,040 --> 00:14:36,959
so the undecorated function subtract

00:14:35,680 --> 00:14:39,760
mean

00:14:36,959 --> 00:14:41,120
is subtracting a mean from a window

00:14:39,760 --> 00:14:44,800
which is an array

00:14:41,120 --> 00:14:47,600
or a list it's just a regular call

00:14:44,800 --> 00:14:48,959
call the array get the result the

00:14:47,600 --> 00:14:52,800
decorated function

00:14:48,959 --> 00:14:56,000
by contrast is now going to operate

00:14:52,800 --> 00:14:56,480
on an endless stream and it's going to

00:14:56,000 --> 00:14:59,680
look at

00:14:56,480 --> 00:15:02,560
sequences of windows that slide

00:14:59,680 --> 00:15:02,959
with a step size of one and it's going

00:15:02,560 --> 00:15:06,240
to

00:15:02,959 --> 00:15:06,800
keep producing output for as long as the

00:15:06,240 --> 00:15:11,120
input

00:15:06,800 --> 00:15:13,199
remains alive once again

00:15:11,120 --> 00:15:15,040
i hope you would help add to these

00:15:13,199 --> 00:15:18,240
decorators

00:15:15,040 --> 00:15:21,600
now an agent can have state

00:15:18,240 --> 00:15:24,959
so in this example here's an agent

00:15:21,600 --> 00:15:25,199
where function f on the top left takes

00:15:24,959 --> 00:15:28,480
an

00:15:25,199 --> 00:15:32,560
input element of the input stream

00:15:28,480 --> 00:15:36,639
and the agent's state it returns

00:15:32,560 --> 00:15:39,839
the output element of the output stream

00:15:36,639 --> 00:15:41,040
and the next state of the agent in this

00:15:39,839 --> 00:15:43,680
example

00:15:41,040 --> 00:15:45,120
the state of the agent is the last value

00:15:43,680 --> 00:15:48,480
read

00:15:45,120 --> 00:15:50,800
so for example if the input is 1 4 9

00:15:48,480 --> 00:15:51,600
16 then the state of the agent is going

00:15:50,800 --> 00:15:56,079
to be

00:15:51,600 --> 00:15:58,079
1 4 9 16 and so forth so that the output

00:15:56,079 --> 00:15:59,360
in this example is going to be the

00:15:58,079 --> 00:16:03,040
difference

00:15:59,360 --> 00:16:05,040
between the current value of the input

00:16:03,040 --> 00:16:06,880
and the previous value of the input

00:16:05,040 --> 00:16:09,040
because the state remembers what the

00:16:06,880 --> 00:16:12,079
previous value was

00:16:09,040 --> 00:16:12,560
you can also have a function f that's

00:16:12,079 --> 00:16:14,720
wrapped

00:16:12,560 --> 00:16:15,920
and this function could be a method of a

00:16:14,720 --> 00:16:18,079
class

00:16:15,920 --> 00:16:20,240
so you can have very rich functions with

00:16:18,079 --> 00:16:22,959
all kinds of state information

00:16:20,240 --> 00:16:24,560
and other information that gets wrapped

00:16:22,959 --> 00:16:28,399
by an iot by function

00:16:24,560 --> 00:16:32,399
to create this persistent agent

00:16:28,399 --> 00:16:36,560
you can also use streams

00:16:32,399 --> 00:16:40,079
in a functional form in this example

00:16:36,560 --> 00:16:43,680
w x y z d

00:16:40,079 --> 00:16:47,199
are all strings we can create

00:16:43,680 --> 00:16:50,560
b by using this functional form

00:16:47,199 --> 00:16:53,519
so exactly as written and

00:16:50,560 --> 00:16:54,320
each of these functions f g h are

00:16:53,519 --> 00:16:58,480
functions

00:16:54,320 --> 00:17:01,120
from streams to streams and once you

00:16:58,480 --> 00:17:03,600
write this equation we now have

00:17:01,120 --> 00:17:04,799
persistent agents and persistent inputs

00:17:03,600 --> 00:17:08,559
and persistent outputs

00:17:04,799 --> 00:17:09,360
they'll keep living as long as the

00:17:08,559 --> 00:17:12,000
inputs

00:17:09,360 --> 00:17:12,000
are aligned

00:17:12,959 --> 00:17:19,199
now let's look at the second challenge

00:17:17,120 --> 00:17:21,520
we've got so many different ways in

00:17:19,199 --> 00:17:25,120
which streams are processed

00:17:21,520 --> 00:17:27,520
threads shared memory distributed memory

00:17:25,120 --> 00:17:30,640
and what we would like is a uniform way

00:17:27,520 --> 00:17:33,120
of handling all of them

00:17:30,640 --> 00:17:35,120
the way we do that is think of it in

00:17:33,120 --> 00:17:38,799
just one way

00:17:35,120 --> 00:17:40,799
you always connect an output to an input

00:17:38,799 --> 00:17:42,559
that's the only way we're going to think

00:17:40,799 --> 00:17:44,840
about concurrency whether it's a thread

00:17:42,559 --> 00:17:47,039
or shared memory message passing or

00:17:44,840 --> 00:17:49,360
whatever

00:17:47,039 --> 00:17:51,200
so for example let's look at how we

00:17:49,360 --> 00:17:54,640
would deal with

00:17:51,200 --> 00:17:58,880
a shared memory process

00:17:54,640 --> 00:18:02,559
in a multi-core computer once again

00:17:58,880 --> 00:18:05,600
a box in this case the top box f

00:18:02,559 --> 00:18:08,000
is just a black box with inputs

00:18:05,600 --> 00:18:09,200
and outputs in this case inputs y z and

00:18:08,000 --> 00:18:13,280
output x

00:18:09,200 --> 00:18:16,559
it happens to be running as a process

00:18:13,280 --> 00:18:18,960
as opposed to an agent in a process

00:18:16,559 --> 00:18:19,919
or a thread in a process but as far as

00:18:18,960 --> 00:18:24,720
we're concerned

00:18:19,919 --> 00:18:28,720
it's just another black box and we def

00:18:24,720 --> 00:18:31,600
and we define this agent

00:18:28,720 --> 00:18:32,960
in this example if we if you're using

00:18:31,600 --> 00:18:36,000
multi-core

00:18:32,960 --> 00:18:38,320
as addict a dictionary

00:18:36,000 --> 00:18:39,200
let's look at that dictionary we name

00:18:38,320 --> 00:18:42,880
the process

00:18:39,200 --> 00:18:45,520
v0 it's got an agent function f

00:18:42,880 --> 00:18:46,799
and remember f could itself be a network

00:18:45,520 --> 00:18:51,039
of agents

00:18:46,799 --> 00:18:54,080
it has inputs y z and output x

00:18:51,039 --> 00:18:57,280
we similarly create

00:18:54,080 --> 00:18:58,880
a process for f for g and h and that's

00:18:57,280 --> 00:19:01,440
it

00:18:58,880 --> 00:19:02,400
so we don't really have to think

00:19:01,440 --> 00:19:05,520
separately

00:19:02,400 --> 00:19:09,440
oh this is a multi-process

00:19:05,520 --> 00:19:11,520
computer in a multi-core system

00:19:09,440 --> 00:19:13,760
what happens if we have a distributed

00:19:11,520 --> 00:19:16,320
system we would use

00:19:13,760 --> 00:19:16,880
for example the advanced queuing message

00:19:16,320 --> 00:19:21,280
through

00:19:16,880 --> 00:19:23,600
protocol we have implementations in pica

00:19:21,280 --> 00:19:25,120
but the point i want to bring back to

00:19:23,600 --> 00:19:26,640
you is

00:19:25,120 --> 00:19:28,400
what you've got to think about is

00:19:26,640 --> 00:19:29,919
connecting an output to an input

00:19:28,400 --> 00:19:32,799
in the background we've got all these

00:19:29,919 --> 00:19:32,799
things going on

00:19:33,919 --> 00:19:39,120
here is snippet of code to publish a

00:19:37,760 --> 00:19:41,919
stream

00:19:39,120 --> 00:19:44,000
so you publish a stream to a publisher

00:19:41,919 --> 00:19:47,039
here is a pica publisher specified by

00:19:44,000 --> 00:19:49,600
rooting key and exchange in a local host

00:19:47,039 --> 00:19:50,840
but what do you have to do all you got

00:19:49,600 --> 00:19:53,039
to do is say

00:19:50,840 --> 00:19:53,679
publisher dot publish why where why is

00:19:53,039 --> 00:19:56,720
the stream

00:19:53,679 --> 00:20:00,559
and the stream goes out similarly

00:19:56,720 --> 00:20:00,559
for receiving data from a stream

00:20:02,240 --> 00:20:07,600
it's important to realize that iot by

00:20:05,280 --> 00:20:09,120
adds to your programming style it's not

00:20:07,600 --> 00:20:11,520
like you stop programming

00:20:09,120 --> 00:20:13,679
in the declarative in in procedural

00:20:11,520 --> 00:20:17,039
style or object oriented or functional

00:20:13,679 --> 00:20:21,520
or whatever style you like best

00:20:17,039 --> 00:20:25,039
you mix and match agents with your style

00:20:21,520 --> 00:20:29,360
so you use live tv libraries

00:20:25,039 --> 00:20:29,360
and agents only when you need to

00:20:30,159 --> 00:20:33,520
iot buy can be used for very different

00:20:32,640 --> 00:20:36,080
applications

00:20:33,520 --> 00:20:37,039
than looking at sensors here's an

00:20:36,080 --> 00:20:40,240
example

00:20:37,039 --> 00:20:43,120
where we're simulating temperatures

00:20:40,240 --> 00:20:45,200
in an object over time so the

00:20:43,120 --> 00:20:46,640
temperature at a spot in the object

00:20:45,200 --> 00:20:50,159
depends on the temperature of its

00:20:46,640 --> 00:20:53,360
neighbors and is changing over time

00:20:50,159 --> 00:20:56,320
this is a science simulation not at all

00:20:53,360 --> 00:20:57,360
like getting sensors from a microphone

00:20:56,320 --> 00:21:00,400
yet

00:20:57,360 --> 00:21:01,679
the key to using the same structure to

00:21:00,400 --> 00:21:03,919
solve this problem

00:21:01,679 --> 00:21:05,919
is to realize that the temperature at a

00:21:03,919 --> 00:21:08,320
given point

00:21:05,919 --> 00:21:12,080
is just a stream the temperature changes

00:21:08,320 --> 00:21:14,720
over time and that's a stream of values

00:21:12,080 --> 00:21:15,760
iot pi has a collection of jupiter

00:21:14,720 --> 00:21:17,760
notebooks

00:21:15,760 --> 00:21:19,360
that i'd encourage you to look at that's

00:21:17,760 --> 00:21:23,520
the best way to see what

00:21:19,360 --> 00:21:23,520
iot can do and cannot do

00:21:24,080 --> 00:21:31,200
we have extensive documentation

00:21:27,360 --> 00:21:34,080
in a website called assemblesoftware.com

00:21:31,200 --> 00:21:37,600
it tells you what iot wires goals are

00:21:34,080 --> 00:21:37,600
and what its limitations are

00:21:38,080 --> 00:21:44,320
now this very short presentation

00:21:41,280 --> 00:21:46,400
leaves out a lot for example

00:21:44,320 --> 00:21:48,559
it leaves out a lot about the previous

00:21:46,400 --> 00:21:51,200
work and there's an immense amount of

00:21:48,559 --> 00:21:53,840
work that's been done

00:21:51,200 --> 00:21:54,320
moreover there's been so much wonderful

00:21:53,840 --> 00:21:57,200
work

00:21:54,320 --> 00:21:57,520
done on streaming frameworks most of

00:21:57,200 --> 00:21:59,360
which

00:21:57,520 --> 00:22:02,720
though has to deal with streaming

00:21:59,360 --> 00:22:02,720
frameworks in the cloud

00:22:02,880 --> 00:22:09,039
i haven't talked about timing issues

00:22:05,200 --> 00:22:09,039
which are critical for many applications

00:22:09,440 --> 00:22:12,480
but we'll have to discuss that at some

00:22:11,280 --> 00:22:16,320
later site

00:22:12,480 --> 00:22:18,240
later time here are some books

00:22:16,320 --> 00:22:19,600
that i worked on on streams and

00:22:18,240 --> 00:22:23,120
parallelism

00:22:19,600 --> 00:22:25,120
i worked with roy shorter of gartner

00:22:23,120 --> 00:22:26,640
very lucky to be able to work with him

00:22:25,120 --> 00:22:30,080
on event processing

00:22:26,640 --> 00:22:32,960
and that book has lots of examples

00:22:30,080 --> 00:22:33,919
of streams and agents it's also a

00:22:32,960 --> 00:22:35,679
website

00:22:33,919 --> 00:22:37,360
i've worked with they've misread the

00:22:35,679 --> 00:22:39,520
parallel aspects of it

00:22:37,360 --> 00:22:41,360
that's apparel program design book and

00:22:39,520 --> 00:22:42,880
the communications acm picture on the

00:22:41,360 --> 00:22:46,640
right shows

00:22:42,880 --> 00:22:51,120
a paper by michael faulkner at caltech

00:22:46,640 --> 00:22:53,919
using your phone as a quick detector

00:22:51,120 --> 00:22:55,840
finally i'm going to wrap up with an

00:22:53,919 --> 00:22:59,679
invitation to you

00:22:55,840 --> 00:23:03,679
my goal today is very specific

00:22:59,679 --> 00:23:05,440
i want to help create a free

00:23:03,679 --> 00:23:08,000
open source python package that

00:23:05,440 --> 00:23:10,880
everybody say a high school student

00:23:08,000 --> 00:23:12,320
anybody anywhere in the world can use

00:23:10,880 --> 00:23:14,720
free technology

00:23:12,320 --> 00:23:16,320
or very inexpensive technology a two

00:23:14,720 --> 00:23:18,559
dollar sensor

00:23:16,320 --> 00:23:19,600
for this vitally important class of

00:23:18,559 --> 00:23:21,760
problems

00:23:19,600 --> 00:23:23,360
please look at these you can go to

00:23:21,760 --> 00:23:25,840
simple software

00:23:23,360 --> 00:23:27,200
iot pi you can look at read the docs for

00:23:25,840 --> 00:23:30,720
documentation

00:23:27,200 --> 00:23:34,080
and you can download using um

00:23:30,720 --> 00:23:37,520
pi thank you very much

00:23:34,080 --> 00:23:40,799
and we can click glad to take questions

00:23:37,520 --> 00:23:40,799
thank you thank you very much

00:23:44,720 --> 00:23:50,960
okay so we have time for

00:23:47,760 --> 00:23:52,720
a few questions so if anyone has a

00:23:50,960 --> 00:23:54,559
question you just can

00:23:52,720 --> 00:23:56,080
raise your hand and i can enable your

00:23:54,559 --> 00:23:59,679
microsoft and you can

00:23:56,080 --> 00:24:02,960
your microphone sorry no microsoft

00:23:59,679 --> 00:24:02,960
so we have the first one

00:24:03,279 --> 00:24:07,279
marius is saying a lot of what you

00:24:06,320 --> 00:24:11,600
presented

00:24:07,279 --> 00:24:14,720
reminds me to the reactive experience

00:24:11,600 --> 00:24:18,080
uh for example the library rx

00:24:14,720 --> 00:24:22,080
spy and he's asking was his

00:24:18,080 --> 00:24:22,080
was it a source of inspiration

00:24:22,159 --> 00:24:26,480
no uh sorry so there was a lot of work

00:24:24,960 --> 00:24:29,039
done on reactive programming and

00:24:26,480 --> 00:24:32,159
reactive programming is certainly

00:24:29,039 --> 00:24:33,919
the source of inspiration however i

00:24:32,159 --> 00:24:36,480
thank you for telling me about lx5 i

00:24:33,919 --> 00:24:38,400
didn't know about it

00:24:36,480 --> 00:24:40,080
so this is valuable information to me

00:24:38,400 --> 00:24:42,400
and i'll be glad to look at it

00:24:40,080 --> 00:24:44,159
but the source of inspiration was more

00:24:42,400 --> 00:24:46,640
the theory

00:24:44,159 --> 00:24:47,919
as well as all these applications the

00:24:46,640 --> 00:24:51,919
seismic network

00:24:47,919 --> 00:24:51,919
radiation detection on twitter

00:24:52,159 --> 00:24:58,159
cool perfect so any other questions

00:24:55,760 --> 00:24:59,360
is also possible if i can open the

00:24:58,159 --> 00:25:02,559
microsoft the

00:24:59,360 --> 00:25:05,360
microphone for anyone that wants to ask

00:25:02,559 --> 00:25:05,360
question live

00:25:07,039 --> 00:25:09,360
okay

00:25:13,279 --> 00:25:18,240
we have one one more um

00:25:18,480 --> 00:25:24,640
so artem is asking

00:25:21,600 --> 00:25:27,840
what iot pie can already do and

00:25:24,640 --> 00:25:28,720
he's asking if can it be applied to home

00:25:27,840 --> 00:25:30,720
sensors

00:25:28,720 --> 00:25:32,080
like a door or a window that kind of

00:25:30,720 --> 00:25:35,600
things

00:25:32,080 --> 00:25:39,039
yes yes so it's you can download

00:25:35,600 --> 00:25:42,080
um priority pi and play around with it

00:25:39,039 --> 00:25:46,320
play around with the jupyter notebooks

00:25:42,080 --> 00:25:50,080
and then it works with python 2.7

00:25:46,320 --> 00:25:52,240
and above so it uses a shared memory

00:25:50,080 --> 00:25:53,679
for multi-core computers like with

00:25:52,240 --> 00:25:57,440
raspberry pi

00:25:53,679 --> 00:26:01,600
with four processors four cores

00:25:57,440 --> 00:26:05,919
and 2.7 python you can use iot pi

00:26:01,600 --> 00:26:08,960
for shared memory on your raspberry pi

00:26:05,919 --> 00:26:11,039
and hook your raspberry pi to sensors so

00:26:08,960 --> 00:26:12,640
that's all ready and set up

00:26:11,039 --> 00:26:16,159
and of course you've got to connect

00:26:12,640 --> 00:26:16,159
whatever sensor you want to use

00:26:20,400 --> 00:26:25,520
okay so i think that's all

00:26:23,440 --> 00:26:27,600
thank you very much for presenting

00:26:25,520 --> 00:26:30,720
speakers are the most important

00:26:27,600 --> 00:26:32,240
ingredient for a conference so thank you

00:26:30,720 --> 00:26:34,640
very much

00:26:32,240 --> 00:26:35,520
and if everyone wants to continue the

00:26:34,640 --> 00:26:37,760
discussion

00:26:35,520 --> 00:26:38,799
in discord there is a channel the

00:26:37,760 --> 00:26:42,320
channel is a

00:26:38,799 --> 00:26:44,960
talk iot pie so you can go there and

00:26:42,320 --> 00:26:46,799
ask more questions and have a chat so

00:26:44,960 --> 00:26:52,000
thank you very much have a nice day

00:26:46,799 --> 00:26:52,000

YouTube URL: https://www.youtube.com/watch?v=AYkxrCaFG6s


