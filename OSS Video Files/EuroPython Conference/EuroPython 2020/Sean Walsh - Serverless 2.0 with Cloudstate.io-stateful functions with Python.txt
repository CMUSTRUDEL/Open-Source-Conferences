Title: Sean Walsh - Serverless 2.0 with Cloudstate.io-stateful functions with Python
Publication date: 2020-09-15
Playlist: EuroPython 2020
Description: 
	"Serverless 2.0 with Cloudstate.io-stateful functions with Python
EuroPython 2020 - Talk - 2020-07-23 - Brian
Online

By Sean Walsh

Serverless is revolutionary and will dominate the future of Cloud. Function-as-a-Service (FaaS) however—with its stateless and short-lived functions is only the first step. 

What’s needed is a next-generation Serverless platform and programming model for general-purpose application development in the new world of real-time data and event-driven systems. What is missing is ways to manage distributed state in a scalable and available fashion, support for long-lived virtual stateful services, ways to physically co-locate data and processing, and options for choosing the right data consistency model for the job.

This talk will discuss the challenges, requirements, and introduce you to our proposed solution: Cloudstate—an Open Source project building the next generation Stateful Serverless, running on Kubernetes, Akka, gRPC, Knative, and GraalVM, with polyglot support for Python, Java, Go, JavaScript, Swift, Scala, Python, Kotlin, and more.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2020.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:07,839 --> 00:00:12,000
so

00:00:08,160 --> 00:00:15,200
scene talk is about serverless 2.0

00:00:12,000 --> 00:00:16,560
using closed state dot io and stateful

00:00:15,200 --> 00:00:20,080
functions with python

00:00:16,560 --> 00:00:20,960
yeah really interesting yeah i'd like to

00:00:20,080 --> 00:00:23,920
talk about

00:00:20,960 --> 00:00:24,720
oh uh should i start yeah you're gonna

00:00:23,920 --> 00:00:26,080
start but i

00:00:24,720 --> 00:00:28,720
i don't know if you if you are sharing

00:00:26,080 --> 00:00:30,960
your skin that's no very cool so yeah

00:00:28,720 --> 00:00:32,160
i'd like to talk today about um cloud

00:00:30,960 --> 00:00:35,280
state i o it's

00:00:32,160 --> 00:00:37,760
an open source uh uh around

00:00:35,280 --> 00:00:40,640
what we like to call serverless2o uh

00:00:37,760 --> 00:00:42,399
which is actually stateful serverless

00:00:40,640 --> 00:00:44,719
versus the stateless serverless we've

00:00:42,399 --> 00:00:48,079
been used to with things like amazon

00:00:44,719 --> 00:00:48,640
lambda function as a service i'm sean

00:00:48,079 --> 00:00:51,760
walsh

00:00:48,640 --> 00:00:54,960
i'm field cto and clyde evangelist with

00:00:51,760 --> 00:00:57,199
lightbend who is behind this effort

00:00:54,960 --> 00:00:58,000
so berkeley recently made a prediction

00:00:57,199 --> 00:00:59,600
that serverless

00:00:58,000 --> 00:01:01,039
computer computing is going to dominate

00:00:59,600 --> 00:01:04,879
the future of cloud

00:01:01,039 --> 00:01:06,880
and we agree so why serverless 2.0 why

00:01:04,879 --> 00:01:08,960
the next iteration

00:01:06,880 --> 00:01:10,720
function as a service was a great start

00:01:08,960 --> 00:01:13,680
it gave us the mechanisms

00:01:10,720 --> 00:01:16,560
a way of thinking around creating these

00:01:13,680 --> 00:01:17,920
components that we can begin to manage

00:01:16,560 --> 00:01:19,840
and take away the operational

00:01:17,920 --> 00:01:21,280
difficulties on behalf of developers

00:01:19,840 --> 00:01:23,680
but it was only the first step and we

00:01:21,280 --> 00:01:25,759
need to iterate

00:01:23,680 --> 00:01:27,280
function as a service is not equal to

00:01:25,759 --> 00:01:30,000
serverless serverless can be much

00:01:27,280 --> 00:01:31,200
more we need to be able to allow

00:01:30,000 --> 00:01:33,920
coarsegrain what we call

00:01:31,200 --> 00:01:35,680
general purpose applications to exist in

00:01:33,920 --> 00:01:36,479
serverless so not exactly what you would

00:01:35,680 --> 00:01:39,360
call

00:01:36,479 --> 00:01:41,200
a little uh fine grain function but

00:01:39,360 --> 00:01:42,560
maybe an entire application

00:01:41,200 --> 00:01:45,200
might be able to be deployed to a

00:01:42,560 --> 00:01:48,000
serverless platform

00:01:45,200 --> 00:01:48,799
so function as a service to revisit

00:01:48,000 --> 00:01:51,040
great for

00:01:48,799 --> 00:01:52,840
embarrassingly parallel processing

00:01:51,040 --> 00:01:56,000
orchestration stateless

00:01:52,840 --> 00:01:58,079
applications job schedule orchestration

00:01:56,000 --> 00:01:59,119
things like that especially things that

00:01:58,079 --> 00:02:02,320
are

00:01:59,119 --> 00:02:03,920
very low impact on the database

00:02:02,320 --> 00:02:07,200
quickly being able to retrieve data make

00:02:03,920 --> 00:02:10,160
a decision and write data back

00:02:07,200 --> 00:02:11,760
what it's bad at is reasoning about as a

00:02:10,160 --> 00:02:14,160
holistic application

00:02:11,760 --> 00:02:15,760
making any sort of serverless platform

00:02:14,160 --> 00:02:17,840
guarantees around

00:02:15,760 --> 00:02:18,959
uh two reactive tenants one is called

00:02:17,840 --> 00:02:20,480
responsiveness

00:02:18,959 --> 00:02:21,760
and the other one's called resilience

00:02:20,480 --> 00:02:22,959
you need to be able to make these

00:02:21,760 --> 00:02:24,879
assumptions

00:02:22,959 --> 00:02:26,160
that these characteristics exist to be

00:02:24,879 --> 00:02:28,959
able to have any kind of a

00:02:26,160 --> 00:02:31,760
serverless platform and again general

00:02:28,959 --> 00:02:33,840
purpose applications

00:02:31,760 --> 00:02:36,160
so function as a service gave us the

00:02:33,840 --> 00:02:38,879
abstraction of communication

00:02:36,160 --> 00:02:40,959
uh and it works great as long as

00:02:38,879 --> 00:02:44,239
everything is fast flowing

00:02:40,959 --> 00:02:46,640
and smooth and any given function isn't

00:02:44,239 --> 00:02:49,760
probably trying to do too much

00:02:46,640 --> 00:02:52,160
so the message is input the function

00:02:49,760 --> 00:02:53,599
is hosted somewhere it does some

00:02:52,160 --> 00:02:55,280
thinking

00:02:53,599 --> 00:02:56,879
and then a message comes out simple as

00:02:55,280 --> 00:02:58,480
that

00:02:56,879 --> 00:03:00,640
and the operational concerns are handled

00:02:58,480 --> 00:03:03,440
for us um it's the first steps of

00:03:00,640 --> 00:03:03,440
of being opsless

00:03:03,920 --> 00:03:08,159
so um here's here's a little bit of a

00:03:06,000 --> 00:03:10,000
beginning of the problem so message in

00:03:08,159 --> 00:03:12,319
the function now is doing something in

00:03:10,000 --> 00:03:14,080
the middle it's reading from a database

00:03:12,319 --> 00:03:16,840
maybe more than one database maybe it's

00:03:14,080 --> 00:03:18,800
doing joins um and then a message goes

00:03:16,840 --> 00:03:20,640
out

00:03:18,800 --> 00:03:22,480
the big problem here is that that

00:03:20,640 --> 00:03:24,879
database interaction

00:03:22,480 --> 00:03:25,920
is a really big black box we have no

00:03:24,879 --> 00:03:29,360
idea what's going on

00:03:25,920 --> 00:03:31,040
there's no guidelines to manage it

00:03:29,360 --> 00:03:32,480
that means if you're equating one

00:03:31,040 --> 00:03:34,560
function to another

00:03:32,480 --> 00:03:36,080
you really can't do it because they do

00:03:34,560 --> 00:03:38,239
very different things

00:03:36,080 --> 00:03:40,400
there's no systematic way to reason

00:03:38,239 --> 00:03:42,400
about what each one's doing

00:03:40,400 --> 00:03:44,560
that function is a black box what is

00:03:42,400 --> 00:03:47,760
missing here

00:03:44,560 --> 00:03:48,400
is state so far when we talk about

00:03:47,760 --> 00:03:50,720
stateless

00:03:48,400 --> 00:03:53,120
applications they really are stateful um

00:03:50,720 --> 00:03:55,840
but that state exists in your database

00:03:53,120 --> 00:03:56,879
um it's a little bit unnatural because

00:03:55,840 --> 00:03:59,599
things in space

00:03:56,879 --> 00:04:01,599
like us and our cars and our phones

00:03:59,599 --> 00:04:03,599
those things have a current state

00:04:01,599 --> 00:04:04,640
they're not separate from their state um

00:04:03,599 --> 00:04:06,239
i think that's a

00:04:04,640 --> 00:04:07,360
that's a problematic concept from the

00:04:06,239 --> 00:04:10,239
beginning but something we're very used

00:04:07,360 --> 00:04:10,239
to as developers

00:04:10,319 --> 00:04:15,360
so serverless 2.0 what we propose is

00:04:13,439 --> 00:04:16,320
that real-time database access has to be

00:04:15,360 --> 00:04:18,160
removed

00:04:16,320 --> 00:04:20,000
uh to allow this sort of autonomy and

00:04:18,160 --> 00:04:22,320
reliability of our functions

00:04:20,000 --> 00:04:25,360
to be able to uh reason about them in in

00:04:22,320 --> 00:04:27,199
a way that's uniform

00:04:25,360 --> 00:04:30,080
we can't make these guarantees if we're

00:04:27,199 --> 00:04:32,240
passing an entire data set to a function

00:04:30,080 --> 00:04:33,199
of saying hey here's all the data set do

00:04:32,240 --> 00:04:34,240
what you need to do

00:04:33,199 --> 00:04:37,120
because we're trying to create an

00:04:34,240 --> 00:04:40,160
abstraction or to allow unbridled reads

00:04:37,120 --> 00:04:43,759
uh from within those functions as as can

00:04:40,160 --> 00:04:45,120
exist and function as a service

00:04:43,759 --> 00:04:46,960
so function does service again

00:04:45,120 --> 00:04:48,960
abstracting over communication

00:04:46,960 --> 00:04:50,639
the message comes in the function does

00:04:48,960 --> 00:04:52,800
some thinking read some data and the

00:04:50,639 --> 00:04:55,520
message comes out

00:04:52,800 --> 00:04:56,240
staple serverless we do the same sort of

00:04:55,520 --> 00:04:58,000
thing

00:04:56,240 --> 00:05:00,160
the message comes in from a user or

00:04:58,000 --> 00:05:01,759
another system uh the function does some

00:05:00,160 --> 00:05:05,840
thinking and the message comes out but

00:05:01,759 --> 00:05:07,440
also we are sending state in at some

00:05:05,840 --> 00:05:09,199
point in time probably

00:05:07,440 --> 00:05:10,720
at initialization time we're sending

00:05:09,199 --> 00:05:13,199
state in and

00:05:10,720 --> 00:05:14,479
the user function is then holding its

00:05:13,199 --> 00:05:16,000
individual state

00:05:14,479 --> 00:05:18,400
on behalf of whatever domain it's

00:05:16,000 --> 00:05:20,639
serving it's able to make the decision

00:05:18,400 --> 00:05:22,880
without having to talk to a database

00:05:20,639 --> 00:05:25,039
and then when it makes a decision the

00:05:22,880 --> 00:05:26,000
new state goes out somewhere

00:05:25,039 --> 00:05:28,160
because it will need to be

00:05:26,000 --> 00:05:30,000
reinstantiated at a future point in time

00:05:28,160 --> 00:05:32,240
or it might have to be reinstantiated

00:05:30,000 --> 00:05:34,320
because it's on an unhealthy node

00:05:32,240 --> 00:05:35,600
and it has to be reinstantiated

00:05:34,320 --> 00:05:37,520
somewhere else

00:05:35,600 --> 00:05:39,280
so we've really just introduced this

00:05:37,520 --> 00:05:40,080
concept of state but that's not quite

00:05:39,280 --> 00:05:42,160
enough

00:05:40,080 --> 00:05:44,080
again we can't pass the entire data set

00:05:42,160 --> 00:05:46,960
in as part of this flow we have to

00:05:44,080 --> 00:05:46,960
figure something out

00:05:47,520 --> 00:05:50,800
it's under cloud state

00:05:51,199 --> 00:05:54,960
so cloud state is this i'm going to read

00:05:53,280 --> 00:05:57,120
this route cloud state is

00:05:54,960 --> 00:05:58,080
distributed clustered and stateful cloud

00:05:57,120 --> 00:06:00,000
runtime

00:05:58,080 --> 00:06:01,919
providing a zero ops experience with

00:06:00,000 --> 00:06:03,680
polyglot client support

00:06:01,919 --> 00:06:06,479
what we'd like to say is essentially

00:06:03,680 --> 00:06:08,160
serverless 2.0

00:06:06,479 --> 00:06:10,479
it's open source best of breed

00:06:08,160 --> 00:06:13,199
harnessing on all the all the power

00:06:10,479 --> 00:06:14,720
of open source technologies uh while

00:06:13,199 --> 00:06:15,520
removing the complexity as much as

00:06:14,720 --> 00:06:17,600
possible

00:06:15,520 --> 00:06:19,199
from things like kubernetes and whatever

00:06:17,600 --> 00:06:22,560
database you're going to be using

00:06:19,199 --> 00:06:24,639
would be it's spanner be it sql no sql

00:06:22,560 --> 00:06:26,000
we really just lift lift it up to make

00:06:24,639 --> 00:06:27,280
it so developers

00:06:26,000 --> 00:06:28,880
don't need to think about the ins and

00:06:27,280 --> 00:06:30,880
outs all these things you leave it to

00:06:28,880 --> 00:06:32,720
this platform

00:06:30,880 --> 00:06:34,479
so you wouldn't worry about uh the

00:06:32,720 --> 00:06:35,440
complexity of just of distributed

00:06:34,479 --> 00:06:38,800
systems

00:06:35,440 --> 00:06:40,639
high scale systems um managing your

00:06:38,800 --> 00:06:42,400
service meshes your databases

00:06:40,639 --> 00:06:44,560
the state how does the state get to the

00:06:42,400 --> 00:06:45,360
function uh those things are all matched

00:06:44,560 --> 00:06:48,560
for you

00:06:45,360 --> 00:06:50,599
um routing recovery failover all those

00:06:48,560 --> 00:06:52,240
things are inherent and then

00:06:50,599 --> 00:06:53,280
operationalizing and running your

00:06:52,240 --> 00:06:55,919
applications

00:06:53,280 --> 00:06:57,360
um it's really just a matter of hooking

00:06:55,919 --> 00:06:59,199
into a cli

00:06:57,360 --> 00:07:00,960
into your build process and it

00:06:59,199 --> 00:07:02,160
automatically automatically go into

00:07:00,960 --> 00:07:03,440
whatever environment

00:07:02,160 --> 00:07:05,520
and be running and then you'll have all

00:07:03,440 --> 00:07:08,000
the benefits of a stateful platform

00:07:05,520 --> 00:07:09,759
that is elastic and scalable and all

00:07:08,000 --> 00:07:11,280
this

00:07:09,759 --> 00:07:14,479
so some of the technical highlights of

00:07:11,280 --> 00:07:18,319
cloud state is it's polyglot

00:07:14,479 --> 00:07:21,680
any computing language that has grpc

00:07:18,319 --> 00:07:25,360
capabilities is fair game to be a

00:07:21,680 --> 00:07:27,440
a client for cloud state so no longer

00:07:25,360 --> 00:07:28,880
do you need to have a team that is

00:07:27,440 --> 00:07:30,960
comfortable in a language and you need

00:07:28,880 --> 00:07:33,680
to find platforms for that language

00:07:30,960 --> 00:07:35,120
this is a language agnostic platform

00:07:33,680 --> 00:07:36,400
everyone should be able to play

00:07:35,120 --> 00:07:40,400
and i think it's important enough that

00:07:36,400 --> 00:07:40,400
that's that's a really important concept

00:07:40,560 --> 00:07:44,000
it's got really great state models so

00:07:42,400 --> 00:07:46,560
event sourcing that's really important

00:07:44,000 --> 00:07:48,879
for us i i alluded to the fact that you

00:07:46,560 --> 00:07:51,039
can't pass the entire data set in

00:07:48,879 --> 00:07:53,199
there's one useful constraint that we

00:07:51,039 --> 00:07:54,560
found to make this all possible

00:07:53,199 --> 00:07:56,639
and that is event source and i'll talk

00:07:54,560 --> 00:07:59,280
more about that in a few

00:07:56,639 --> 00:08:00,879
command query responsibility segregation

00:07:59,280 --> 00:08:02,160
uh which we're also calling domain

00:08:00,879 --> 00:08:03,919
projections so

00:08:02,160 --> 00:08:05,280
your reads are separate from your rights

00:08:03,919 --> 00:08:07,120
of your system so your

00:08:05,280 --> 00:08:08,960
your events are modeled and the events

00:08:07,120 --> 00:08:10,400
or the events and then any number of

00:08:08,960 --> 00:08:11,120
interested parties could take those

00:08:10,400 --> 00:08:12,560
events

00:08:11,120 --> 00:08:15,520
and paint whatever picture across the

00:08:12,560 --> 00:08:18,400
system they want asynchronously

00:08:15,520 --> 00:08:20,000
key value store uh create update create

00:08:18,400 --> 00:08:21,680
read update delete

00:08:20,000 --> 00:08:23,280
and in advance one of the advanced

00:08:21,680 --> 00:08:27,120
topics i find

00:08:23,280 --> 00:08:28,800
is crdts conflict-free replicated data

00:08:27,120 --> 00:08:31,199
types

00:08:28,800 --> 00:08:32,000
if you're not familiar they're a highly

00:08:31,199 --> 00:08:35,680
available

00:08:32,000 --> 00:08:37,919
distributed uh sort of a read source

00:08:35,680 --> 00:08:39,519
and it's a it's a multiple structures

00:08:37,919 --> 00:08:40,959
that keep in sync

00:08:39,519 --> 00:08:42,800
so when you go to read something it'll

00:08:40,959 --> 00:08:44,720
be in memory um

00:08:42,800 --> 00:08:46,880
and if you're talking in a cluster it'll

00:08:44,720 --> 00:08:49,839
be very highly available in almost every

00:08:46,880 --> 00:08:51,760
single node that you're running

00:08:49,839 --> 00:08:53,360
and we're also polydb so it's whatever

00:08:51,760 --> 00:08:56,399
whatever database

00:08:53,360 --> 00:08:58,399
you choose it'll hook into cloud state

00:08:56,399 --> 00:09:01,200
seamlessly

00:08:58,399 --> 00:09:02,640
um so the at a high level the

00:09:01,200 --> 00:09:06,880
technologies that we're using

00:09:02,640 --> 00:09:10,720
are acca open source concurrency toolkit

00:09:06,880 --> 00:09:13,279
grpc which is the way we're able to

00:09:10,720 --> 00:09:14,320
uh have a low level communication

00:09:13,279 --> 00:09:16,800
between

00:09:14,320 --> 00:09:18,399
the cloud state mechanisms and internals

00:09:16,800 --> 00:09:19,120
to whatever language you're implementing

00:09:18,399 --> 00:09:21,519
in

00:09:19,120 --> 00:09:23,519
um as well as a contract with the

00:09:21,519 --> 00:09:25,040
outside for your users

00:09:23,519 --> 00:09:26,720
you could you could have people call

00:09:25,040 --> 00:09:29,920
into cloud state services

00:09:26,720 --> 00:09:32,800
using grpc or rest or anything else um

00:09:29,920 --> 00:09:33,920
uh k native growl growl is important

00:09:32,800 --> 00:09:35,600
because

00:09:33,920 --> 00:09:37,279
across these different languages some of

00:09:35,600 --> 00:09:38,720
them are jvm languages

00:09:37,279 --> 00:09:40,320
um they have a little bit of baggage

00:09:38,720 --> 00:09:41,519
there's garbage collection

00:09:40,320 --> 00:09:43,680
things like that we need to be able to

00:09:41,519 --> 00:09:46,080
compile everything with a native image

00:09:43,680 --> 00:09:47,200
um that will be able to guarantee

00:09:46,080 --> 00:09:50,800
sub-second

00:09:47,200 --> 00:09:52,640
uh startup of pods and kubernetes um

00:09:50,800 --> 00:09:55,040
which really again gives us these

00:09:52,640 --> 00:09:56,880
guarantees that we could be elastic and

00:09:55,040 --> 00:09:58,080
quickly scale up new nodes

00:09:56,880 --> 00:10:00,800
and all this of course running on

00:09:58,080 --> 00:10:00,800
kubernetes

00:10:03,200 --> 00:10:07,680
so i alluded to the fact that we've got

00:10:05,920 --> 00:10:09,680
a useful constraint

00:10:07,680 --> 00:10:11,760
um and this is by a theologian believe

00:10:09,680 --> 00:10:13,200
it or not his and he said that freedom

00:10:11,760 --> 00:10:14,079
is not so much the absence of

00:10:13,200 --> 00:10:16,000
restrictions

00:10:14,079 --> 00:10:17,600
as finding the right ones the liberating

00:10:16,000 --> 00:10:19,839
restrictions so sometimes

00:10:17,600 --> 00:10:21,680
a restriction can actually set you free

00:10:19,839 --> 00:10:23,440
as we think in this case

00:10:21,680 --> 00:10:26,399
so this constraint for us is event

00:10:23,440 --> 00:10:27,760
sourcing for cloud state

00:10:26,399 --> 00:10:30,160
so some of the benefits of event

00:10:27,760 --> 00:10:33,600
sourcing it's a single source of truth

00:10:30,160 --> 00:10:37,120
full history it allows for this

00:10:33,600 --> 00:10:40,560
memory image this durable state

00:10:37,120 --> 00:10:42,720
running inside of some encapsulation

00:10:40,560 --> 00:10:43,760
in this case it's a a cloud state we

00:10:42,720 --> 00:10:47,519
call entity or

00:10:43,760 --> 00:10:50,640
crdt or a crud entity

00:10:47,519 --> 00:10:52,480
and it allows the building of the state

00:10:50,640 --> 00:10:55,120
from the events over time because events

00:10:52,480 --> 00:10:58,240
are a time series

00:10:55,120 --> 00:11:00,160
it avoids object relational mismatch

00:10:58,240 --> 00:11:01,440
a lot of that's also in combination with

00:11:00,160 --> 00:11:03,200
cqrs

00:11:01,440 --> 00:11:04,480
um which is the way to separate your

00:11:03,200 --> 00:11:06,399
reads from your rights

00:11:04,480 --> 00:11:07,839
um i don't know how many of us have gone

00:11:06,399 --> 00:11:09,440
and designed a system

00:11:07,839 --> 00:11:11,360
and we've laid everything out according

00:11:09,440 --> 00:11:13,279
to domain and we're very proud of it

00:11:11,360 --> 00:11:15,440
and then the ui people come over and say

00:11:13,279 --> 00:11:17,440
hey i need this and i need that and we

00:11:15,440 --> 00:11:18,959
just pollute our domain

00:11:17,440 --> 00:11:20,480
the read and write concerns of your

00:11:18,959 --> 00:11:21,120
system are two completely different

00:11:20,480 --> 00:11:23,440
things

00:11:21,120 --> 00:11:26,240
and they are equally important one

00:11:23,440 --> 00:11:28,079
shouldn't affect the other

00:11:26,240 --> 00:11:30,160
and allow subscriptions to the state

00:11:28,079 --> 00:11:32,560
changes so you subscribe

00:11:30,160 --> 00:11:33,920
to events and the event is usually

00:11:32,560 --> 00:11:35,040
useful for different parties for

00:11:33,920 --> 00:11:37,279
different reasons

00:11:35,040 --> 00:11:38,880
um i like to use the term state is in

00:11:37,279 --> 00:11:41,040
the eye of the beholder

00:11:38,880 --> 00:11:42,160
um you could have a state of something

00:11:41,040 --> 00:11:44,399
let's just say

00:11:42,160 --> 00:11:46,480
uh an airline flight and there's all

00:11:44,399 --> 00:11:48,399
kinds of characteristics of flight

00:11:46,480 --> 00:11:49,600
but ground control cares about very

00:11:48,399 --> 00:11:52,399
different things than

00:11:49,600 --> 00:11:54,000
in flight control um so it's it's

00:11:52,399 --> 00:11:55,279
important to bear that in mind state is

00:11:54,000 --> 00:11:57,839
not something to be shared across

00:11:55,279 --> 00:11:57,839
different processes

00:11:57,920 --> 00:12:02,880
it has mechanical sympathy you're only

00:12:00,160 --> 00:12:04,560
ever appending with events

00:12:02,880 --> 00:12:06,800
so this is how event sourcing works with

00:12:04,560 --> 00:12:08,480
cloud state

00:12:06,800 --> 00:12:10,800
we have our user function we're also

00:12:08,480 --> 00:12:14,000
calling then an entity the entity

00:12:10,800 --> 00:12:16,079
is that holder of state

00:12:14,000 --> 00:12:18,000
now when you instantiate it the event

00:12:16,079 --> 00:12:18,639
log is replayed so all the events in the

00:12:18,000 --> 00:12:20,800
past

00:12:18,639 --> 00:12:22,880
on behalf of this entity are replayed to

00:12:20,800 --> 00:12:24,800
it and it's building up its current

00:12:22,880 --> 00:12:26,240
state um

00:12:24,800 --> 00:12:27,600
i don't know if i talk about snapshots

00:12:26,240 --> 00:12:28,399
here i probably don't if you have the

00:12:27,600 --> 00:12:30,160
question

00:12:28,399 --> 00:12:32,000
um if there are a real lot of events

00:12:30,160 --> 00:12:33,760
where there's a concept of snapshot

00:12:32,000 --> 00:12:37,440
so you start with a state snapshot and

00:12:33,760 --> 00:12:39,440
then you re you overlay the events since

00:12:37,440 --> 00:12:40,880
just in case uh so the events come in

00:12:39,440 --> 00:12:42,399
build up your state

00:12:40,880 --> 00:12:44,480
and now you're ready for business your

00:12:42,399 --> 00:12:47,760
commands are coming in

00:12:44,480 --> 00:12:48,480
um somebody's saying hey you add a

00:12:47,760 --> 00:12:51,279
contact

00:12:48,480 --> 00:12:52,639
to a to a customer and you're looking at

00:12:51,279 --> 00:12:53,279
your state you're saying okay i can do

00:12:52,639 --> 00:12:55,920
that

00:12:53,279 --> 00:12:57,120
you add the contact and you say hey i

00:12:55,920 --> 00:12:59,360
added the contact or

00:12:57,120 --> 00:13:01,200
i'm about to add the contact and then

00:12:59,360 --> 00:13:03,440
the event is contact added

00:13:01,200 --> 00:13:05,120
and it's now um in the system of record

00:13:03,440 --> 00:13:06,480
and when you instantiate again that'll

00:13:05,120 --> 00:13:08,720
then will be played back to you so you

00:13:06,480 --> 00:13:10,399
can then build up that state

00:13:08,720 --> 00:13:12,639
so you'll see that contact in memory in

00:13:10,399 --> 00:13:13,600
the future and the state will also be

00:13:12,639 --> 00:13:16,000
reflected

00:13:13,600 --> 00:13:16,880
um inside the entity that has just

00:13:16,000 --> 00:13:18,880
written the event

00:13:16,880 --> 00:13:20,800
it'll update its state in memory as it

00:13:18,880 --> 00:13:23,200
does so

00:13:20,800 --> 00:13:24,560
so the happy path for one of these

00:13:23,200 --> 00:13:27,279
functions

00:13:24,560 --> 00:13:29,920
is the uh the user issues a command to

00:13:27,279 --> 00:13:31,920
to do something on the domain

00:13:29,920 --> 00:13:34,720
it goes into a mailbox all of these

00:13:31,920 --> 00:13:37,360
entities are bounded by a mailbox um it

00:13:34,720 --> 00:13:39,600
so there's no issues with concurrency

00:13:37,360 --> 00:13:42,639
there's no blocking at all

00:13:39,600 --> 00:13:43,680
these functions uh fully process a

00:13:42,639 --> 00:13:45,519
message

00:13:43,680 --> 00:13:47,279
and event it out before even thinking

00:13:45,519 --> 00:13:49,279
about going and getting another message

00:13:47,279 --> 00:13:51,760
off the mailbox

00:13:49,279 --> 00:13:53,360
and so that command does some thinking

00:13:51,760 --> 00:13:55,120
looks at its state

00:13:53,360 --> 00:13:57,680
issues a new event which goes to the

00:13:55,120 --> 00:14:00,480
event log which may be subscribed to

00:13:57,680 --> 00:14:01,040
through some event bus now let's talk

00:14:00,480 --> 00:14:03,839
about the

00:14:01,040 --> 00:14:03,839
unhappy path

00:14:04,800 --> 00:14:08,800
so the sad path this is recovering from

00:14:06,720 --> 00:14:10,639
failure

00:14:08,800 --> 00:14:12,399
so we we have our event log we're

00:14:10,639 --> 00:14:14,560
replaying our events

00:14:12,399 --> 00:14:15,600
uh it's it's actually building up state

00:14:14,560 --> 00:14:17,120
in the function

00:14:15,600 --> 00:14:18,800
and now we're ready for business again

00:14:17,120 --> 00:14:20,079
in comes our command and now it goes

00:14:18,800 --> 00:14:22,560
events

00:14:20,079 --> 00:14:23,199
and you can also do crud so in some

00:14:22,560 --> 00:14:27,040
cases

00:14:23,199 --> 00:14:28,720
event sourcing cqrs crdts

00:14:27,040 --> 00:14:30,880
they're all pretty advanced concepts you

00:14:28,720 --> 00:14:32,399
might have just a subsystem which is

00:14:30,880 --> 00:14:35,440
just a user

00:14:32,399 --> 00:14:36,399
um maybe a user and a phone number or

00:14:35,440 --> 00:14:37,760
something like that

00:14:36,399 --> 00:14:40,079
you know how many things you really need

00:14:37,760 --> 00:14:41,360
to do on that does it really need events

00:14:40,079 --> 00:14:44,959
you could use the current state model

00:14:41,360 --> 00:14:47,600
and you can use crud we can handle that

00:14:44,959 --> 00:14:49,600
so in that case we just use snapshots

00:14:47,600 --> 00:14:51,440
your snapshot comes in to you

00:14:49,600 --> 00:14:52,959
you put it in memory and then you're

00:14:51,440 --> 00:14:54,079
processing messages and you're sending

00:14:52,959 --> 00:14:58,240
the snapshot back up

00:14:54,079 --> 00:14:59,760
back out every time

00:14:58,240 --> 00:15:00,959
so what is the architecture for

00:14:59,760 --> 00:15:02,720
something like this so again we're

00:15:00,959 --> 00:15:05,760
running on kubernetes

00:15:02,720 --> 00:15:07,680
um and we've got a series of pods that

00:15:05,760 --> 00:15:10,480
represent your user functions

00:15:07,680 --> 00:15:12,800
so um you've got replication here um you

00:15:10,480 --> 00:15:15,519
can have any number of these as required

00:15:12,800 --> 00:15:16,880
um if you're running one user function

00:15:15,519 --> 00:15:18,320
you probably would never need more than

00:15:16,880 --> 00:15:20,000
a couple pods one pod

00:15:18,320 --> 00:15:21,680
um but you can host multiple user

00:15:20,000 --> 00:15:23,120
functions in one image

00:15:21,680 --> 00:15:24,639
um and therefore it's useful to have

00:15:23,120 --> 00:15:26,240
more than one pod you can scale it up

00:15:24,639 --> 00:15:28,240
and down

00:15:26,240 --> 00:15:29,920
so your user functions live on these

00:15:28,240 --> 00:15:31,600
pods in whatever language

00:15:29,920 --> 00:15:32,959
you've implemented communicating via

00:15:31,600 --> 00:15:34,720
grpc

00:15:32,959 --> 00:15:37,279
and then we have the cloud state proxy

00:15:34,720 --> 00:15:40,399
which is the akka sidecar on these pods

00:15:37,279 --> 00:15:42,959
which spans these pods and so

00:15:40,399 --> 00:15:44,240
akka is actually receiving the messages

00:15:42,959 --> 00:15:46,320
from the users

00:15:44,240 --> 00:15:47,759
and it's communicating to your user code

00:15:46,320 --> 00:15:49,680
via grpc

00:15:47,759 --> 00:15:50,800
your user code is doing all the logic

00:15:49,680 --> 00:15:53,759
all the thinking

00:15:50,800 --> 00:15:55,040
um it's just all of the the uh the

00:15:53,759 --> 00:15:57,360
traffic control

00:15:55,040 --> 00:15:58,399
and the uh the ability to write the

00:15:57,360 --> 00:16:00,560
events and

00:15:58,399 --> 00:16:02,639
and and to be able to play back your

00:16:00,560 --> 00:16:04,320
state all that is on the left side

00:16:02,639 --> 00:16:07,279
um user functions doing all the business

00:16:04,320 --> 00:16:08,800
logic and the the akka sidecar is also

00:16:07,279 --> 00:16:09,839
communicating in real time to the data

00:16:08,800 --> 00:16:13,120
store whenever

00:16:09,839 --> 00:16:13,120
necessary or asynchronously

00:16:13,279 --> 00:16:19,120
so um so that aca sidecar lives on each

00:16:16,639 --> 00:16:22,720
pod alongside your user code

00:16:19,120 --> 00:16:25,600
um it spans those but it is also

00:16:22,720 --> 00:16:26,079
a cluster in itself so akka cluster

00:16:25,600 --> 00:16:28,720
exists

00:16:26,079 --> 00:16:30,880
for your for your um your application

00:16:28,720 --> 00:16:32,399
which is a series of these functions

00:16:30,880 --> 00:16:35,839
you've got a cluster that could be

00:16:32,399 --> 00:16:38,079
expanded and contracted to do its

00:16:35,839 --> 00:16:39,040
and so that's how the communication

00:16:38,079 --> 00:16:41,199
location

00:16:39,040 --> 00:16:42,399
location you might have a user function

00:16:41,199 --> 00:16:44,720
on pod three

00:16:42,399 --> 00:16:45,680
um that all of these are singletons

00:16:44,720 --> 00:16:47,360
really uh

00:16:45,680 --> 00:16:48,880
they might be represented by your user

00:16:47,360 --> 00:16:52,320
function in multiple

00:16:48,880 --> 00:16:55,120
pods but in in akka you've got

00:16:52,320 --> 00:16:56,639
a cohort which is a persistent actor

00:16:55,120 --> 00:16:58,480
which is also a singleton

00:16:56,639 --> 00:17:00,399
and so it needs to be quickly located

00:16:58,480 --> 00:17:04,640
within that cluster across these pods

00:17:00,399 --> 00:17:08,720
aka takes care of all that

00:17:04,640 --> 00:17:12,000
so again grpc communication gossip

00:17:08,720 --> 00:17:13,679
location uh location routing to wherever

00:17:12,000 --> 00:17:15,600
things are located

00:17:13,679 --> 00:17:16,799
talking to your data store while that's

00:17:15,600 --> 00:17:18,400
happening so

00:17:16,799 --> 00:17:21,120
if we look at cloud data as a managed

00:17:18,400 --> 00:17:21,120
service now

00:17:21,919 --> 00:17:28,000
you could pay as you go as you can with

00:17:25,360 --> 00:17:30,080
function as a service on-demand instance

00:17:28,000 --> 00:17:32,400
creation passivation failover

00:17:30,080 --> 00:17:33,840
auto scaling up and down of pods only

00:17:32,400 --> 00:17:34,799
paying for what you're using at any

00:17:33,840 --> 00:17:37,919
given time

00:17:34,799 --> 00:17:40,480
just like function as a service uh

00:17:37,919 --> 00:17:42,000
zero ops so automated uh really

00:17:40,480 --> 00:17:44,960
automated everything

00:17:42,000 --> 00:17:46,320
all that all that state failure

00:17:44,960 --> 00:17:49,280
provisioning

00:17:46,320 --> 00:17:50,240
routing deployment all the upgrading uh

00:17:49,280 --> 00:17:52,080
canary

00:17:50,240 --> 00:17:54,960
deployments things like that all would

00:17:52,080 --> 00:17:58,080
be part of the platform

00:17:54,960 --> 00:18:00,400
a little bit about multi-tenancy

00:17:58,080 --> 00:18:01,840
my opinion functional services

00:18:00,400 --> 00:18:04,640
inadequate bulkheading

00:18:01,840 --> 00:18:06,240
um maybe not in all cases but i know it

00:18:04,640 --> 00:18:07,919
has happened in aws

00:18:06,240 --> 00:18:09,840
uh where your neighbor's function can

00:18:07,919 --> 00:18:12,240
hug resources

00:18:09,840 --> 00:18:14,080
uh it's not in cloud state if you're

00:18:12,240 --> 00:18:15,520
doing kubernetes correctly if your

00:18:14,080 --> 00:18:17,679
hardware set up right

00:18:15,520 --> 00:18:19,039
you know you really got this clean

00:18:17,679 --> 00:18:21,840
separation of things

00:18:19,039 --> 00:18:22,240
via the pods and really good bulkheading

00:18:21,840 --> 00:18:25,280
and

00:18:22,240 --> 00:18:27,039
even at the data level uh where you're

00:18:25,280 --> 00:18:28,559
you're assigning different databases to

00:18:27,039 --> 00:18:30,000
different tenants

00:18:28,559 --> 00:18:31,520
you know you don't share big data

00:18:30,000 --> 00:18:33,200
databases cross tenants i think that's

00:18:31,520 --> 00:18:36,160
probably the wrong way to go

00:18:33,200 --> 00:18:37,919
and complete security to the extent that

00:18:36,160 --> 00:18:41,200
kubernetes has security

00:18:37,919 --> 00:18:41,200
do these clear separations

00:18:41,600 --> 00:18:45,679
so um quick look at what a three-tier

00:18:44,320 --> 00:18:46,640
architecture looks like what we're so

00:18:45,679 --> 00:18:48,559
used to

00:18:46,640 --> 00:18:49,919
what we call a stateless application

00:18:48,559 --> 00:18:51,679
looks a lot like this

00:18:49,919 --> 00:18:53,760
um you've got the middleware on the in

00:18:51,679 --> 00:18:54,720
the you know the back end running in the

00:18:53,760 --> 00:18:57,600
middle there

00:18:54,720 --> 00:18:58,640
um in a number of pods you've got a load

00:18:57,600 --> 00:19:00,799
balancer

00:18:58,640 --> 00:19:03,679
uh in the front on the left there and

00:19:00,799 --> 00:19:07,200
you've got a big database on the right

00:19:03,679 --> 00:19:10,080
every single request will have to go

00:19:07,200 --> 00:19:11,120
to the load balancer to one of the pods

00:19:10,080 --> 00:19:13,360
one of the uh

00:19:11,120 --> 00:19:14,799
the the nodes in the middle it's gonna

00:19:13,360 --> 00:19:15,200
definitely have to hit a database at

00:19:14,799 --> 00:19:17,679
least

00:19:15,200 --> 00:19:18,880
once um it's probably gonna have some

00:19:17,679 --> 00:19:20,320
chatter in the middle

00:19:18,880 --> 00:19:21,919
um it's probably gonna hit the database

00:19:20,320 --> 00:19:22,559
again after and then it's gonna return

00:19:21,919 --> 00:19:27,120
some data

00:19:22,559 --> 00:19:27,120
so it's very noisy noise equals risk

00:19:28,400 --> 00:19:32,400
reactive architecture is a lot different

00:19:31,520 --> 00:19:35,039
in that

00:19:32,400 --> 00:19:36,799
your database is still there it's it's

00:19:35,039 --> 00:19:38,240
needed as an event log but it's not

00:19:36,799 --> 00:19:41,679
needed in real time

00:19:38,240 --> 00:19:44,480
the database interaction is never needed

00:19:41,679 --> 00:19:45,360
uh for your functions to do their job in

00:19:44,480 --> 00:19:47,840
real time

00:19:45,360 --> 00:19:49,440
um the data is already in the functions

00:19:47,840 --> 00:19:50,880
the state's already in the functions

00:19:49,440 --> 00:19:52,400
they're doing all the work and when

00:19:50,880 --> 00:19:53,520
they've done some work they say hey by

00:19:52,400 --> 00:19:56,240
the way database

00:19:53,520 --> 00:19:58,000
here for next time uh so you really have

00:19:56,240 --> 00:20:00,880
a much reduced risk in

00:19:58,000 --> 00:20:00,880
noise factor here

00:20:01,280 --> 00:20:04,640
so um just a very high level of the

00:20:03,679 --> 00:20:06,640
architecture

00:20:04,640 --> 00:20:08,559
you know from the bottom up you've of

00:20:06,640 --> 00:20:10,320
course got any number of uh

00:20:08,559 --> 00:20:11,600
you know any if it's a database it could

00:20:10,320 --> 00:20:15,600
be part of a cloud state

00:20:11,600 --> 00:20:19,760
instance um spanner new sql no sql

00:20:15,600 --> 00:20:21,679
sql all running on kubernetes

00:20:19,760 --> 00:20:23,039
k native um i'm gonna have to take that

00:20:21,679 --> 00:20:24,159
box away we're not actually utilizing

00:20:23,039 --> 00:20:26,880
that right now

00:20:24,159 --> 00:20:28,720
we're new uh we are utilizing uh growl

00:20:26,880 --> 00:20:32,480
vm for native image

00:20:28,720 --> 00:20:34,080
and very hard um utilization on akka

00:20:32,480 --> 00:20:35,919
because akka's uh clustering

00:20:34,080 --> 00:20:38,559
capabilities and its

00:20:35,919 --> 00:20:40,400
persistent actors are the underpinnings

00:20:38,559 --> 00:20:43,760
of the cloud state entities

00:20:40,400 --> 00:20:45,520
um now the above that are the actual um

00:20:43,760 --> 00:20:47,600
methodologies we're able to create with

00:20:45,520 --> 00:20:50,720
that which is the event sourcing

00:20:47,600 --> 00:20:51,039
uh crud domain projections were which

00:20:50,720 --> 00:20:53,600
are

00:20:51,039 --> 00:20:54,799
views um based upon events happening

00:20:53,600 --> 00:20:56,559
across your system

00:20:54,799 --> 00:20:57,840
um that are kept in sync and built for

00:20:56,559 --> 00:20:59,440
you by cloud state

00:20:57,840 --> 00:21:00,960
um that way when you go to read for a

00:20:59,440 --> 00:21:03,520
display it's already waiting for

00:21:00,960 --> 00:21:04,799
you in memory um or in a record in a

00:21:03,520 --> 00:21:08,000
database somewhere

00:21:04,799 --> 00:21:09,840
uh key value store similar to redis and

00:21:08,000 --> 00:21:11,280
these count click free replicated data

00:21:09,840 --> 00:21:11,919
types if you have the need you know what

00:21:11,280 --> 00:21:15,200
it is

00:21:11,919 --> 00:21:15,600
crdts and then all these languages plus

00:21:15,200 --> 00:21:18,480
plus

00:21:15,600 --> 00:21:19,360
across any language that has jrpc can be

00:21:18,480 --> 00:21:22,559
supported

00:21:19,360 --> 00:21:23,600
um istio for your load balancer and then

00:21:22,559 --> 00:21:25,600
any

00:21:23,600 --> 00:21:26,799
any mainstream communication protocol

00:21:25,600 --> 00:21:30,240
grpc

00:21:26,799 --> 00:21:31,919
http rest kafka what have you um will

00:21:30,240 --> 00:21:34,159
work

00:21:31,919 --> 00:21:35,760
so let's look at some code i'm going to

00:21:34,159 --> 00:21:36,720
make a little admission before i go into

00:21:35,760 --> 00:21:39,120
this

00:21:36,720 --> 00:21:41,440
i did a lot of python uh it was in

00:21:39,120 --> 00:21:43,679
health and wellness it was for loading

00:21:41,440 --> 00:21:45,039
a new system with billions and billions

00:21:43,679 --> 00:21:47,200
and millions of records

00:21:45,039 --> 00:21:48,799
um that's the extent of my python

00:21:47,200 --> 00:21:51,120
expertise but i did

00:21:48,799 --> 00:21:53,039
take some python sample code from our

00:21:51,120 --> 00:21:54,480
python cloud state library so

00:21:53,039 --> 00:21:56,960
you can glean something from it a little

00:21:54,480 --> 00:21:58,480
bit but please do check out the github

00:21:56,960 --> 00:22:00,480
repo when i'm finished i'll give you the

00:21:58,480 --> 00:22:02,320
link

00:22:00,480 --> 00:22:04,159
so to be able to have a cloud state

00:22:02,320 --> 00:22:05,520
application um regardless of what

00:22:04,159 --> 00:22:05,919
language you're going to be implementing

00:22:05,520 --> 00:22:08,880
it

00:22:05,919 --> 00:22:11,200
you've got to set up your your protobufs

00:22:08,880 --> 00:22:13,440
for the grpc protocol

00:22:11,200 --> 00:22:15,600
this is going to be all the behavior of

00:22:13,440 --> 00:22:17,200
your application at a functional level

00:22:15,600 --> 00:22:19,679
so in this case we're talking about a

00:22:17,200 --> 00:22:20,320
shopping cart and the shopping cart

00:22:19,679 --> 00:22:22,320
we're going to

00:22:20,320 --> 00:22:24,159
model the messages for interacting with

00:22:22,320 --> 00:22:25,919
a cart the one thing you'd like to do

00:22:24,159 --> 00:22:26,799
with the shopping cart is add a line

00:22:25,919 --> 00:22:28,559
item

00:22:26,799 --> 00:22:29,840
and it would have a product id a name

00:22:28,559 --> 00:22:33,120
and a quantity

00:22:29,840 --> 00:22:34,960
uh and a user id if you see that we're

00:22:33,120 --> 00:22:35,760
also marking it as a cloud state entity

00:22:34,960 --> 00:22:39,039
key

00:22:35,760 --> 00:22:40,720
so any entity in cloud state needs to be

00:22:39,039 --> 00:22:42,400
sharded um

00:22:40,720 --> 00:22:45,039
with a unique key so what you're doing

00:22:42,400 --> 00:22:48,559
is instead of having a a database

00:22:45,039 --> 00:22:51,280
on disk uh that has a unique key

00:22:48,559 --> 00:22:52,480
which would be user id you've got these

00:22:51,280 --> 00:22:54,720
distributed functions

00:22:52,480 --> 00:22:56,640
in memory in a cluster that are sharded

00:22:54,720 --> 00:22:58,640
by user id so it's a similar concept to

00:22:56,640 --> 00:23:01,120
a database table

00:22:58,640 --> 00:23:02,159
if you're not familiar with protobufs

00:23:01,120 --> 00:23:04,480
you'll see that

00:23:02,159 --> 00:23:06,159
when you say string user id equals one

00:23:04,480 --> 00:23:07,200
you're saying that the data type of

00:23:06,159 --> 00:23:09,039
course is string

00:23:07,200 --> 00:23:10,400
what am i calling it and then what is

00:23:09,039 --> 00:23:12,640
the ordinal of it

00:23:10,400 --> 00:23:14,480
one two three and four the ordinal of

00:23:12,640 --> 00:23:16,400
these attributes

00:23:14,480 --> 00:23:18,559
remove line item again you have to you

00:23:16,400 --> 00:23:21,600
tell us the user id which is the id

00:23:18,559 --> 00:23:23,679
of the function um and then what is the

00:23:21,600 --> 00:23:24,720
mandatory attribute for removing a line

00:23:23,679 --> 00:23:26,880
item um

00:23:24,720 --> 00:23:28,240
it's a product id in this case um

00:23:26,880 --> 00:23:30,000
there's a the ability to get the

00:23:28,240 --> 00:23:31,520
shopping cart if you'd like to view it

00:23:30,000 --> 00:23:33,679
um in that case you just need to be able

00:23:31,520 --> 00:23:37,600
to give the user id okay

00:23:33,679 --> 00:23:40,080
um uh you have uh line items here

00:23:37,600 --> 00:23:41,600
which are part of a cart um and we

00:23:40,080 --> 00:23:42,799
modeled that here with line item and

00:23:41,600 --> 00:23:46,159
then it's used

00:23:42,799 --> 00:23:48,960
as a repeated um collection of items

00:23:46,159 --> 00:23:48,960
inside of cart

00:23:49,360 --> 00:23:52,880
and so now we can have our service that

00:23:51,039 --> 00:23:56,000
uses those messages

00:23:52,880 --> 00:23:56,640
uh in our grp service called shopping

00:23:56,000 --> 00:24:00,000
cart

00:23:56,640 --> 00:24:02,159
um so we can add an item um and we can

00:24:00,000 --> 00:24:04,080
remove an item we can get our cart

00:24:02,159 --> 00:24:06,320
uh if you're not very friendly with

00:24:04,080 --> 00:24:08,240
protobuffs this is a really cool feature

00:24:06,320 --> 00:24:10,559
so out of the box if you do a cloud

00:24:08,240 --> 00:24:12,240
state implementation using python

00:24:10,559 --> 00:24:14,240
any other language you're going to

00:24:12,240 --> 00:24:16,080
implement this grpc backend

00:24:14,240 --> 00:24:17,919
for this service um what you're going to

00:24:16,080 --> 00:24:20,000
get for free here is if you

00:24:17,919 --> 00:24:21,039
include this optional section you're

00:24:20,000 --> 00:24:24,080
going to get

00:24:21,039 --> 00:24:26,720
rest just by default so

00:24:24,080 --> 00:24:27,919
you get grpc and rest at the same time

00:24:26,720 --> 00:24:30,080
that's what the meaning of those things

00:24:27,919 --> 00:24:30,080
are

00:24:31,039 --> 00:24:36,960
and then there's also another um

00:24:34,880 --> 00:24:37,919
uh file here which is actually your

00:24:36,960 --> 00:24:40,320
domain

00:24:37,919 --> 00:24:41,840
so you can model your domain objects

00:24:40,320 --> 00:24:43,679
also again in protobuf

00:24:41,840 --> 00:24:46,960
uh makes them much easier to share and

00:24:43,679 --> 00:24:50,000
return as data when you have callers

00:24:46,960 --> 00:24:52,000
so again line item uh an item added

00:24:50,000 --> 00:24:54,880
event so i talked about event sourcing

00:24:52,000 --> 00:24:56,480
this is our event for item added um it's

00:24:54,880 --> 00:24:58,559
got a line item inside of it

00:24:56,480 --> 00:24:59,679
this is our event for item removed below

00:24:58,559 --> 00:25:01,279
that

00:24:59,679 --> 00:25:02,720
and then we also have our shopping cart

00:25:01,279 --> 00:25:03,919
state so we'd like to be able to return

00:25:02,720 --> 00:25:06,000
that to a user

00:25:03,919 --> 00:25:09,039
um so we just have a message called cart

00:25:06,000 --> 00:25:09,039
repeatedline items

00:25:09,440 --> 00:25:15,360
so this is what it looks like in python

00:25:12,559 --> 00:25:17,520
to actually model one of these now

00:25:15,360 --> 00:25:18,799
so it's not a real lot of code it's a

00:25:17,520 --> 00:25:20,400
shopping cart you're going to be able to

00:25:18,799 --> 00:25:22,320
have billions of them in memory

00:25:20,400 --> 00:25:23,679
given that you've got enough cloud

00:25:22,320 --> 00:25:26,720
hardware in place

00:25:23,679 --> 00:25:28,400
and cloud state installed it's

00:25:26,720 --> 00:25:30,480
fairly guaranteed that you could model

00:25:28,400 --> 00:25:32,159
the world there's there's no limitation

00:25:30,480 --> 00:25:33,840
if you've got enough of these nodes

00:25:32,159 --> 00:25:36,320
and all you need to do is mark it

00:25:33,840 --> 00:25:38,559
appropriately as a

00:25:36,320 --> 00:25:40,159
an entity a data class um there's a

00:25:38,559 --> 00:25:41,840
little more code in the sample that i

00:25:40,159 --> 00:25:43,440
think you should probably take a look at

00:25:41,840 --> 00:25:45,600
where it specifies

00:25:43,440 --> 00:25:47,600
what this underscore shopping cart and

00:25:45,600 --> 00:25:48,799
the file descriptor are it's uh it's a

00:25:47,600 --> 00:25:50,400
little bit busy

00:25:48,799 --> 00:25:52,159
but um this is some of the code what it

00:25:50,400 --> 00:25:54,400
looks like to create a shopping cart

00:25:52,159 --> 00:25:56,400
in in there uh you'll see that you'd

00:25:54,400 --> 00:25:59,120
like to snapshot it

00:25:56,400 --> 00:26:00,640
it'll this is a callback function that

00:25:59,120 --> 00:26:02,400
is going to actually call for your

00:26:00,640 --> 00:26:05,840
snapshot when appropriate

00:26:02,400 --> 00:26:07,200
um if we look further

00:26:05,840 --> 00:26:08,880
we'll see that there's a snapshot

00:26:07,200 --> 00:26:10,880
handler handle snapshot

00:26:08,880 --> 00:26:12,960
this is your call back from cloud state

00:26:10,880 --> 00:26:15,919
saying hey here's your cloud start

00:26:12,960 --> 00:26:17,679
you your uh your state and you would um

00:26:15,919 --> 00:26:20,080
you'd set your state in your cart

00:26:17,679 --> 00:26:21,679
your internal state to that and then

00:26:20,080 --> 00:26:24,159
you'll have the event handlers

00:26:21,679 --> 00:26:25,600
item added um you would then every item

00:26:24,159 --> 00:26:27,360
added would be called back into you and

00:26:25,600 --> 00:26:29,760
you would add them to your state

00:26:27,360 --> 00:26:32,559
um so it's all very call back based you

00:26:29,760 --> 00:26:35,520
just implement these annotations and

00:26:32,559 --> 00:26:36,880
you're you're in business and remove

00:26:35,520 --> 00:26:39,120
item if you're interested that's what

00:26:36,880 --> 00:26:41,360
remove item would look like

00:26:39,120 --> 00:26:44,159
you take your item out of the cart and

00:26:41,360 --> 00:26:46,400
you return empty

00:26:44,159 --> 00:26:48,400
so on behalf of the cloud state team

00:26:46,400 --> 00:26:50,080
we'd like to say thanks

00:26:48,400 --> 00:26:52,799
we'd love to see your interest we are

00:26:50,080 --> 00:26:54,720
always looking for contributors

00:26:52,799 --> 00:26:56,080
any questions you might have we'd love

00:26:54,720 --> 00:26:58,000
to hear about them

00:26:56,080 --> 00:27:00,000
um the full sample i'm going to leave

00:26:58,000 --> 00:27:02,159
this up for a few secs

00:27:00,000 --> 00:27:03,840
this is where the python support and

00:27:02,159 --> 00:27:05,039
with the widget shopping cart sample

00:27:03,840 --> 00:27:06,480
exists

00:27:05,039 --> 00:27:08,080
i encourage you to pull it down from

00:27:06,480 --> 00:27:11,279
github and take a look and

00:27:08,080 --> 00:27:11,279
and run it and play with it

00:27:11,840 --> 00:27:16,480
so uh that's that's all i have and uh

00:27:14,880 --> 00:27:21,840
let me

00:27:16,480 --> 00:27:21,840
plant my volume here

00:27:23,790 --> 00:27:26,960
[Applause]

00:27:28,970 --> 00:27:35,200
[Applause]

00:27:32,000 --> 00:27:40,159
thank you okay

00:27:35,200 --> 00:27:43,120
so we have time for questions

00:27:40,159 --> 00:27:43,120
there is a first one

00:27:43,200 --> 00:27:49,120
is for andre he's asking if it only runs

00:27:46,559 --> 00:27:52,399
in kubernetes

00:27:49,120 --> 00:27:54,000
yes yeah kubernetes in our experience is

00:27:52,399 --> 00:27:56,159
the way the world has gone

00:27:54,000 --> 00:27:57,360
um we made a little bit of a bad bet

00:27:56,159 --> 00:28:00,960
using um

00:27:57,360 --> 00:28:02,720
tcos some years ago and it's very clear

00:28:00,960 --> 00:28:06,320
that kubernetes is

00:28:02,720 --> 00:28:06,320
is where the world is going for cloud

00:28:06,640 --> 00:28:12,880
okay so any other questions

00:28:10,080 --> 00:28:14,880
if anyone wants to use a microphone to

00:28:12,880 --> 00:28:18,159
ask a question we can also do that

00:28:14,880 --> 00:28:19,039
just raise your hand click the right

00:28:18,159 --> 00:28:22,320
hand button

00:28:19,039 --> 00:28:22,320
and i can enable that

00:28:23,039 --> 00:28:27,120
or choose click in the queue and i am

00:28:25,760 --> 00:28:31,840
asked a question

00:28:27,120 --> 00:28:31,840
let me check on the channel just in case

00:28:37,919 --> 00:28:40,880
okay so

00:28:41,600 --> 00:28:47,760
let's call no takers

00:28:45,600 --> 00:28:49,279
all right thanks everybody yeah so thank

00:28:47,760 --> 00:28:51,679
you very much

00:28:49,279 --> 00:28:52,799
thank you for presenting um enjoy the

00:28:51,679 --> 00:28:59,840
rest of the conference

00:28:52,799 --> 00:28:59,840

YouTube URL: https://www.youtube.com/watch?v=Er7YbFC6Zp8


