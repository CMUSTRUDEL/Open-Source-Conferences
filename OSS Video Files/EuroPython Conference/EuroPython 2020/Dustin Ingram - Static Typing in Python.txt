Title: Dustin Ingram - Static Typing in Python
Publication date: 2020-09-15
Playlist: EuroPython 2020
Description: 
	"Static Typing in Python
EuroPython 2020 - Talk - 2020-07-23 - Microsoft
Online

By Dustin Ingram

Python is well-known as a programming language without static types. This means that you don’t need to say what a given variable will hold, or whether your function will return a string or an integer (or sometimes one, and sometimes another!). This has historically made Python a very flexible and beginner-friendly language.

In this talk, we’ll discuss the advantages and disadvantages to a static type system, as well as recent efforts to introduce static typing to Python via optional “type hints” and various tools to aid in adding types to Python code. We’ll see what this means for Python, for Python programmers, and what the future has in store for Python’s type system.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2020.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:06,000 --> 00:00:10,559
for making this possible

00:00:07,520 --> 00:00:12,559
so uh next up we have uh dustin ingram

00:00:10,559 --> 00:00:14,240
he's a developer advocate at google

00:00:12,559 --> 00:00:16,480
focused on supporting the python

00:00:14,240 --> 00:00:17,760
community on google cloud he's also a

00:00:16,480 --> 00:00:20,240
director of the python software

00:00:17,760 --> 00:00:21,840
foundation a maintainer of pi pi and an

00:00:20,240 --> 00:00:26,080
organizer for the pi

00:00:21,840 --> 00:00:28,320
texas conference uh so um

00:00:26,080 --> 00:00:29,279
welcome uh dustin ingram very glad to

00:00:28,320 --> 00:00:32,160
have you here

00:00:29,279 --> 00:00:33,520
thanks jason uh so uh i could probably

00:00:32,160 --> 00:00:34,960
guess for that intro but where are you

00:00:33,520 --> 00:00:38,079
streaming from

00:00:34,960 --> 00:00:39,840
i'm based in austin texas austin is it

00:00:38,079 --> 00:00:43,360
uh hot and sunny there

00:00:39,840 --> 00:00:46,640
it is right now yeah awesome

00:00:43,360 --> 00:00:48,800
well i will turn it over to you and uh

00:00:46,640 --> 00:00:51,200
awesome all right let me share miss

00:00:48,800 --> 00:00:51,200
karine

00:00:55,280 --> 00:01:01,600
is all good

00:00:58,640 --> 00:01:02,719
okay so hey like you said i'm dustin uh

00:01:01,600 --> 00:01:04,720
i'm a developer advocate

00:01:02,719 --> 00:01:07,119
at google i am a director for the python

00:01:04,720 --> 00:01:08,560
software foundation and i work on pipi

00:01:07,119 --> 00:01:10,799
uh i'm not here to talk about any of

00:01:08,560 --> 00:01:12,560
that today um i'm here talking about

00:01:10,799 --> 00:01:16,400
static typing in python

00:01:12,560 --> 00:01:19,040
so quick pop quiz is python dynamically

00:01:16,400 --> 00:01:19,600
or statically typed and so sort of think

00:01:19,040 --> 00:01:20,960
in your head

00:01:19,600 --> 00:01:22,799
maybe what is the answer to this

00:01:20,960 --> 00:01:25,439
question

00:01:22,799 --> 00:01:26,000
so the answer is that python is

00:01:25,439 --> 00:01:28,960
dynamically

00:01:26,000 --> 00:01:29,920
typed but it can optionally be as

00:01:28,960 --> 00:01:31,920
statically typed

00:01:29,920 --> 00:01:34,320
as you want it to be uh and so that

00:01:31,920 --> 00:01:36,079
answer might not make sense to you

00:01:34,320 --> 00:01:37,439
if you've even if you've used python for

00:01:36,079 --> 00:01:37,840
a while or if you are familiar with

00:01:37,439 --> 00:01:40,240
other

00:01:37,840 --> 00:01:41,200
static languages and that's okay that's

00:01:40,240 --> 00:01:42,640
kind of the point of this talk we're

00:01:41,200 --> 00:01:44,320
going to talk about what that means

00:01:42,640 --> 00:01:45,920
and so the steps to understand the

00:01:44,320 --> 00:01:47,600
answer to that question are sort of this

00:01:45,920 --> 00:01:49,920
we need to talk about

00:01:47,600 --> 00:01:51,200
types in python just regular types type

00:01:49,920 --> 00:01:53,439
systems in general across

00:01:51,200 --> 00:01:54,960
other languages we'll talk about dynamic

00:01:53,439 --> 00:01:55,920
typing in python and then finally we'll

00:01:54,960 --> 00:01:58,799
be able to talk about

00:01:55,920 --> 00:02:00,560
static typing in python and once we

00:01:58,799 --> 00:02:02,079
understand those things

00:02:00,560 --> 00:02:04,079
we'll talk about how to use static

00:02:02,079 --> 00:02:05,759
typing when you should use it and maybe

00:02:04,079 --> 00:02:07,200
sometimes when you shouldn't use static

00:02:05,759 --> 00:02:08,640
typing

00:02:07,200 --> 00:02:10,479
so let's talk about types and

00:02:08,640 --> 00:02:12,959
specifically let's talk about type

00:02:10,479 --> 00:02:14,480
the built-in keyword in python and you

00:02:12,959 --> 00:02:16,959
might be familiar with this

00:02:14,480 --> 00:02:18,879
so type tells you what something is what

00:02:16,959 --> 00:02:21,280
an object is or what a variable is

00:02:18,879 --> 00:02:22,080
so if i call type 42 python will tell me

00:02:21,280 --> 00:02:24,319
that it is class

00:02:22,080 --> 00:02:26,000
int so i know that that's an integer and

00:02:24,319 --> 00:02:29,440
i can do the same thing with floats

00:02:26,000 --> 00:02:30,080
and strings and lists so you might say

00:02:29,440 --> 00:02:31,519
okay

00:02:30,080 --> 00:02:33,200
i recognize these as built-ins they tell

00:02:31,519 --> 00:02:34,400
me what types things are but i can also

00:02:33,200 --> 00:02:35,840
use them to

00:02:34,400 --> 00:02:37,760
change types or do sometimes what we

00:02:35,840 --> 00:02:39,760
call type casting and you'd be

00:02:37,760 --> 00:02:41,200
you'd be right right i could take a

00:02:39,760 --> 00:02:43,120
variable a

00:02:41,200 --> 00:02:45,599
and when i assign it to the value we say

00:02:43,120 --> 00:02:47,680
that a is a type of an integer

00:02:45,599 --> 00:02:50,000
and i could cast it i could use that

00:02:47,680 --> 00:02:51,599
float built in to turn it into a float

00:02:50,000 --> 00:02:53,840
and i can use a string built in to turn

00:02:51,599 --> 00:02:55,680
that into a string and use list

00:02:53,840 --> 00:02:56,959
built in to turn that into a really ugly

00:02:55,680 --> 00:02:59,680
list

00:02:56,959 --> 00:03:01,040
so i imagine some folks watching might

00:02:59,680 --> 00:03:03,120
have had a weird bug where they

00:03:01,040 --> 00:03:04,080
accidentally got a string turned into a

00:03:03,120 --> 00:03:07,760
list

00:03:04,080 --> 00:03:08,959
and guess what that is a type error you

00:03:07,760 --> 00:03:10,879
if you've experienced that before you're

00:03:08,959 --> 00:03:13,599
definitely in the right place

00:03:10,879 --> 00:03:15,280
so why does python let that happen so it

00:03:13,599 --> 00:03:16,959
would seem like these are the only

00:03:15,280 --> 00:03:18,640
types that are available to us right the

00:03:16,959 --> 00:03:19,200
things that we can cast from one type to

00:03:18,640 --> 00:03:21,599
the other

00:03:19,200 --> 00:03:23,760
but these are actually just classes that

00:03:21,599 --> 00:03:24,560
happen to have corresponding built-ins

00:03:23,760 --> 00:03:25,840
in python

00:03:24,560 --> 00:03:28,799
so basically it's kind of just doing

00:03:25,840 --> 00:03:31,200
class matching here right we can say

00:03:28,799 --> 00:03:32,799
whether the number 42 is an instance of

00:03:31,200 --> 00:03:33,440
the class int and when we call type it

00:03:32,799 --> 00:03:36,319
gives us that

00:03:33,440 --> 00:03:36,720
same class back so um it's sort of this

00:03:36,319 --> 00:03:39,120
just

00:03:36,720 --> 00:03:40,560
just a class and it's a sort of a

00:03:39,120 --> 00:03:42,959
shortcut or an alias for that

00:03:40,560 --> 00:03:44,080
that class name but there are other

00:03:42,959 --> 00:03:45,280
class types

00:03:44,080 --> 00:03:47,519
as well that don't correspond to

00:03:45,280 --> 00:03:50,080
built-ins so for example

00:03:47,519 --> 00:03:51,840
none we've all sort of you know used the

00:03:50,080 --> 00:03:54,080
none built in and we've seen none

00:03:51,840 --> 00:03:56,159
type before but they're not the same

00:03:54,080 --> 00:03:58,400
similarly for a function we don't say

00:03:56,159 --> 00:04:00,799
you know when we initialize a function

00:03:58,400 --> 00:04:01,280
we don't instantiate a class we say def

00:04:00,799 --> 00:04:02,640
func

00:04:01,280 --> 00:04:04,560
but that has a class underneath the two

00:04:02,640 --> 00:04:05,920
there's a function class and same for

00:04:04,560 --> 00:04:07,120
ellipsis and actually lots of other

00:04:05,920 --> 00:04:08,640
things as well

00:04:07,120 --> 00:04:10,480
and the place where you can sort of find

00:04:08,640 --> 00:04:11,680
the classes that represent all these

00:04:10,480 --> 00:04:12,480
things in python that we might want to

00:04:11,680 --> 00:04:14,080
interact with

00:04:12,480 --> 00:04:16,000
is from the types module so you can

00:04:14,080 --> 00:04:17,440
import types this comes with python

00:04:16,000 --> 00:04:19,519
and you get a whole list of different

00:04:17,440 --> 00:04:20,959
types of types and the kind of fun thing

00:04:19,519 --> 00:04:22,880
about these is

00:04:20,959 --> 00:04:25,199
if you wanted to you could instantiate a

00:04:22,880 --> 00:04:27,199
class with a function type and

00:04:25,199 --> 00:04:28,960
put things inside but actually that that

00:04:27,199 --> 00:04:30,800
gets pretty long and verbose and

00:04:28,960 --> 00:04:33,280
it's a lot nicer to just write normal

00:04:30,800 --> 00:04:34,720
python

00:04:33,280 --> 00:04:36,639
so when we say the python is a

00:04:34,720 --> 00:04:38,720
dynamically typed language what we mean

00:04:36,639 --> 00:04:41,280
is that a variable once it's defined

00:04:38,720 --> 00:04:42,639
can be any type we can initialize the

00:04:41,280 --> 00:04:43,919
variable we can set it to be one type

00:04:42,639 --> 00:04:46,720
then we can change it

00:04:43,919 --> 00:04:48,240
so for example uh what type is a here

00:04:46,720 --> 00:04:50,479
right i'm importing random and i'm

00:04:48,240 --> 00:04:51,919
taking a random choice from this list

00:04:50,479 --> 00:04:53,600
and that list includes an integer of

00:04:51,919 --> 00:04:55,280
float in the string so when i call type

00:04:53,600 --> 00:04:56,720
of a

00:04:55,280 --> 00:04:58,639
this could be anything it could be any

00:04:56,720 --> 00:05:01,840
of those three types that uh

00:04:58,639 --> 00:05:03,600
i put in the random options and so it

00:05:01,840 --> 00:05:04,400
could be a string it could be an end or

00:05:03,600 --> 00:05:05,919
could be a float

00:05:04,400 --> 00:05:08,000
and python doesn't care python lets us

00:05:05,919 --> 00:05:10,400
set a to be any of these values

00:05:08,000 --> 00:05:12,240
their value types and that is what we

00:05:10,400 --> 00:05:14,320
mean by dynamic typing

00:05:12,240 --> 00:05:16,160
this means that arguments and return

00:05:14,320 --> 00:05:18,080
types of a function can also

00:05:16,160 --> 00:05:19,759
be any type the same is true for a

00:05:18,080 --> 00:05:21,280
function as it is for variables the

00:05:19,759 --> 00:05:22,560
things that we return from functions or

00:05:21,280 --> 00:05:25,520
that we pass to functions

00:05:22,560 --> 00:05:27,199
they can also be any type so in python

00:05:25,520 --> 00:05:29,360
we write a function like this

00:05:27,199 --> 00:05:30,960
how do we know what types this function

00:05:29,360 --> 00:05:32,160
is expecting right so if you saw this

00:05:30,960 --> 00:05:34,320
function somewhere

00:05:32,160 --> 00:05:35,280
and you didn't know what it does what

00:05:34,320 --> 00:05:37,520
would you expect

00:05:35,280 --> 00:05:38,400
the argument types and the return type

00:05:37,520 --> 00:05:40,320
to be

00:05:38,400 --> 00:05:42,320
so you might say okay well i'm seeing

00:05:40,320 --> 00:05:42,639
that it's uh adding things together so

00:05:42,320 --> 00:05:44,479
these

00:05:42,639 --> 00:05:45,919
maybe these are integers right and you'd

00:05:44,479 --> 00:05:48,000
be right you could call this

00:05:45,919 --> 00:05:49,759
from a k function with integers and it

00:05:48,000 --> 00:05:50,639
would give you the sum of all those

00:05:49,759 --> 00:05:53,120
integers

00:05:50,639 --> 00:05:54,240
but you could also call from key with

00:05:53,120 --> 00:05:56,240
strings

00:05:54,240 --> 00:05:57,680
and it would concatenate the strings

00:05:56,240 --> 00:05:59,280
into a single string

00:05:57,680 --> 00:06:00,800
and actually this works for lists and

00:05:59,280 --> 00:06:02,800
really anything else that would support

00:06:00,800 --> 00:06:04,240
this addition operator in python

00:06:02,800 --> 00:06:05,840
so we can say that the arguments to

00:06:04,240 --> 00:06:06,240
frobnecke and the return type of foreign

00:06:05,840 --> 00:06:08,880
decay

00:06:06,240 --> 00:06:10,319
are dynamic and then this can cause

00:06:08,880 --> 00:06:11,680
problems though right because if we

00:06:10,319 --> 00:06:12,479
don't have any way to sort of guarantee

00:06:11,680 --> 00:06:15,199
what the

00:06:12,479 --> 00:06:16,800
arguments are we can have type errors so

00:06:15,199 --> 00:06:17,440
for example if i call it with two

00:06:16,800 --> 00:06:20,080
integers

00:06:17,440 --> 00:06:20,720
and a string we can't do this because

00:06:20,080 --> 00:06:22,560
the

00:06:20,720 --> 00:06:24,000
addition operator doesn't let us mix

00:06:22,560 --> 00:06:25,600
types like this and so we get a type

00:06:24,000 --> 00:06:27,840
error because we're trying to

00:06:25,600 --> 00:06:29,440
combine integers and strings together in

00:06:27,840 --> 00:06:32,319
the body of the function

00:06:29,440 --> 00:06:33,520
all right so that's pretty confusing how

00:06:32,319 --> 00:06:36,000
can we fix it

00:06:33,520 --> 00:06:36,800
um so one thing we could do is write

00:06:36,000 --> 00:06:39,440
really long

00:06:36,800 --> 00:06:41,039
and detailed docs strings about what the

00:06:39,440 --> 00:06:42,880
function expects and what the

00:06:41,039 --> 00:06:44,479
function should return this is great for

00:06:42,880 --> 00:06:47,759
developers and sometimes we do this

00:06:44,479 --> 00:06:49,039
uh i don't do this this is a lot of work

00:06:47,759 --> 00:06:50,400
and it's a lot of work to maintain this

00:06:49,039 --> 00:06:52,160
documentation

00:06:50,400 --> 00:06:53,599
and on top of that writing these

00:06:52,160 --> 00:06:55,599
comments while they're

00:06:53,599 --> 00:06:57,440
helpful for developers doesn't actually

00:06:55,599 --> 00:06:58,880
guarantee that someone using your

00:06:57,440 --> 00:07:00,240
function is calling it correctly right

00:06:58,880 --> 00:07:02,160
these are just sort of like

00:07:00,240 --> 00:07:03,599
when you're reading the source code it

00:07:02,160 --> 00:07:05,599
tells you how to use the function

00:07:03,599 --> 00:07:07,520
but it doesn't give you any guarantees

00:07:05,599 --> 00:07:08,560
at all

00:07:07,520 --> 00:07:10,560
one thing that could give you some

00:07:08,560 --> 00:07:12,400
guarantees is if you assert it on the

00:07:10,560 --> 00:07:14,560
type of every single argument

00:07:12,400 --> 00:07:17,039
and of the return type every time this

00:07:14,560 --> 00:07:17,599
function is called so i can assert on a

00:07:17,039 --> 00:07:19,360
b and c

00:07:17,599 --> 00:07:20,880
that they're integers i can do my

00:07:19,360 --> 00:07:22,000
business logic inside the function and

00:07:20,880 --> 00:07:23,280
then i can assert

00:07:22,000 --> 00:07:25,199
on what the return type is and then

00:07:23,280 --> 00:07:27,520
finally return it

00:07:25,199 --> 00:07:29,280
we don't usually do this either what we

00:07:27,520 --> 00:07:30,400
usually

00:07:29,280 --> 00:07:32,400
we're trying to avoid this for is

00:07:30,400 --> 00:07:34,080
because every assertion here

00:07:32,400 --> 00:07:35,840
is just a little bit of overhead right

00:07:34,080 --> 00:07:37,680
it's another line of code we have to run

00:07:35,840 --> 00:07:39,280
uh it's an extra check and actually this

00:07:37,680 --> 00:07:42,560
can also be wrong right

00:07:39,280 --> 00:07:43,840
um it's sort of dependent on whether the

00:07:42,560 --> 00:07:45,280
developer has written the assertion

00:07:43,840 --> 00:07:47,680
correctly or remembered to add the

00:07:45,280 --> 00:07:49,919
assertion to their function so there's

00:07:47,680 --> 00:07:51,680
things that could go wrong here as well

00:07:49,919 --> 00:07:53,599
and we don't do this very often so what

00:07:51,680 --> 00:07:55,680
do we do instead so instead

00:07:53,599 --> 00:07:57,120
in python we do something that we call

00:07:55,680 --> 00:07:58,720
duct typing

00:07:57,120 --> 00:08:00,560
which is that if it walks like a duck

00:07:58,720 --> 00:08:01,280
and it quacks like a duck it is probably

00:08:00,560 --> 00:08:04,400
a duck right

00:08:01,280 --> 00:08:07,120
we rely on how the variable is used

00:08:04,400 --> 00:08:08,319
to sort of determine what type it it

00:08:07,120 --> 00:08:10,960
should be

00:08:08,319 --> 00:08:12,800
and so for some for some examples uh in

00:08:10,960 --> 00:08:16,000
each of these you can kind of guess

00:08:12,800 --> 00:08:17,360
what the variable bar is based on what

00:08:16,000 --> 00:08:19,360
is being done with it so in the first

00:08:17,360 --> 00:08:21,520
one you can tell we're iterating over it

00:08:19,360 --> 00:08:23,039
so it's probably like a list

00:08:21,520 --> 00:08:25,360
could be a string though it's hard to

00:08:23,039 --> 00:08:26,720
tell in the second one we're comparing

00:08:25,360 --> 00:08:27,599
it to zero with the greater than

00:08:26,720 --> 00:08:29,680
operator so

00:08:27,599 --> 00:08:31,759
bar is probably some kind of number like

00:08:29,680 --> 00:08:34,880
an integer or a float

00:08:31,759 --> 00:08:37,120
um and in the last one uh we're

00:08:34,880 --> 00:08:38,320
we're you know calling it right but it's

00:08:37,120 --> 00:08:39,760
kind of ambiguous and the last one it

00:08:38,320 --> 00:08:41,200
could be a function

00:08:39,760 --> 00:08:42,800
it could be a class i don't know what

00:08:41,200 --> 00:08:45,440
i'm going to get back for foo

00:08:42,800 --> 00:08:47,360
in each of these so it could be anything

00:08:45,440 --> 00:08:49,440
and

00:08:47,360 --> 00:08:50,640
yeah the the ambiguity here if we wanted

00:08:49,440 --> 00:08:52,880
to reduce the ambiguity

00:08:50,640 --> 00:08:54,320
is what static typing would give us so

00:08:52,880 --> 00:08:56,640
static typing

00:08:54,320 --> 00:08:58,720
means that the variables and return

00:08:56,640 --> 00:09:00,959
types and argument types of function

00:08:58,720 --> 00:09:02,240
are defined and they will not change so

00:09:00,959 --> 00:09:04,320
there are actually lots of

00:09:02,240 --> 00:09:05,680
statically typed languages i want to

00:09:04,320 --> 00:09:07,760
show you some examples real quick just

00:09:05,680 --> 00:09:11,360
so you can see what they look like

00:09:07,760 --> 00:09:12,959
so i this is c

00:09:11,360 --> 00:09:14,399
this is the same from the key function

00:09:12,959 --> 00:09:14,800
but written in c so you can see that

00:09:14,399 --> 00:09:16,560
there's

00:09:14,800 --> 00:09:19,200
it's declaring int for the return type

00:09:16,560 --> 00:09:21,519
and in for all the variable types

00:09:19,200 --> 00:09:23,120
this is java it's a pretty obvious if

00:09:21,519 --> 00:09:24,320
you use java before because java has

00:09:23,120 --> 00:09:26,320
this public static

00:09:24,320 --> 00:09:28,720
incantation at the beginning but also

00:09:26,320 --> 00:09:30,880
declares argument types to be integers

00:09:28,720 --> 00:09:31,760
um this is rust so rust has really

00:09:30,880 --> 00:09:33,360
fine-grained

00:09:31,760 --> 00:09:35,440
control of the integer type so that's an

00:09:33,360 --> 00:09:38,160
unsigned 8-bit integer that it's

00:09:35,440 --> 00:09:40,640
accepting and returning and this last

00:09:38,160 --> 00:09:42,240
one is typescript uh so in javascript

00:09:40,640 --> 00:09:43,360
uh javascript doesn't have stack types

00:09:42,240 --> 00:09:44,399
but there's a variant of it called

00:09:43,360 --> 00:09:46,399
typescript

00:09:44,399 --> 00:09:47,760
and in javascript all numbers are the

00:09:46,399 --> 00:09:49,600
same thing they are a number

00:09:47,760 --> 00:09:51,519
so in typescript there is only the

00:09:49,600 --> 00:09:53,760
number type so everything

00:09:51,519 --> 00:09:55,600
passes argument and this function is uh

00:09:53,760 --> 00:09:57,040
the number type

00:09:55,600 --> 00:09:59,040
so we can sort of put languages into two

00:09:57,040 --> 00:10:02,000
categories dynamic and statically typed

00:09:59,040 --> 00:10:02,959
you can see that python right in this

00:10:02,000 --> 00:10:04,959
slide is in the

00:10:02,959 --> 00:10:06,640
uh dynamic category and things like c

00:10:04,959 --> 00:10:07,760
and rust and java and typescript are in

00:10:06,640 --> 00:10:08,880
the static category

00:10:07,760 --> 00:10:10,720
but we have to put a little asterisk

00:10:08,880 --> 00:10:11,120
here because python is kind of an odd

00:10:10,720 --> 00:10:14,560
duck

00:10:11,120 --> 00:10:16,000
and kind of we can do static typing with

00:10:14,560 --> 00:10:18,240
it as well and technically ruby's going

00:10:16,000 --> 00:10:20,320
to get something very similar to python

00:10:18,240 --> 00:10:21,519
at the end of this year i think last

00:10:20,320 --> 00:10:22,880
time i checked but

00:10:21,519 --> 00:10:25,680
for now i'll leave it in the dynamic

00:10:22,880 --> 00:10:28,240
column so like i said before

00:10:25,680 --> 00:10:28,800
python is dynamically typed but can

00:10:28,240 --> 00:10:30,959
optionally

00:10:28,800 --> 00:10:33,120
be as statically typed as you want to be

00:10:30,959 --> 00:10:35,680
so this wasn't always true

00:10:33,120 --> 00:10:36,959
and the story of how python became a

00:10:35,680 --> 00:10:38,160
language that can optionally be

00:10:36,959 --> 00:10:40,240
statically typed

00:10:38,160 --> 00:10:41,440
is also kind of the story of static

00:10:40,240 --> 00:10:44,480
typing

00:10:41,440 --> 00:10:46,240
at dropbox so dropbox is a large python

00:10:44,480 --> 00:10:49,680
shop they use a lot of python

00:10:46,240 --> 00:10:51,600
a lot of pythonistas work there and

00:10:49,680 --> 00:10:52,800
there are some things sort of in their

00:10:51,600 --> 00:10:56,000
journey from

00:10:52,800 --> 00:10:59,279
going from untyped to typed python code

00:10:56,000 --> 00:11:00,079
that led up to you know static typing as

00:10:59,279 --> 00:11:01,440
we know it in python

00:11:00,079 --> 00:11:02,880
today so i'm going to give you just a

00:11:01,440 --> 00:11:04,720
quick overview of everything sort of the

00:11:02,880 --> 00:11:06,800
progression of static typing

00:11:04,720 --> 00:11:08,480
um and how dropbox is involved and that

00:11:06,800 --> 00:11:11,920
kind of thing

00:11:08,480 --> 00:11:14,480
so in 2006 uh we have pep3107

00:11:11,920 --> 00:11:15,680
uh this came out in python3 and this

00:11:14,480 --> 00:11:16,240
allowed us to do something called

00:11:15,680 --> 00:11:18,800
function

00:11:16,240 --> 00:11:20,160
annotations uh so it allows us to take a

00:11:18,800 --> 00:11:23,279
function like this

00:11:20,160 --> 00:11:23,920
and add basically any metadata that we

00:11:23,279 --> 00:11:26,480
want

00:11:23,920 --> 00:11:27,600
to argument and annotate the arguments

00:11:26,480 --> 00:11:29,839
and return values

00:11:27,600 --> 00:11:31,040
so thing to know here is that this has

00:11:29,839 --> 00:11:33,279
zero effect on

00:11:31,040 --> 00:11:34,720
execution of the function but what it

00:11:33,279 --> 00:11:39,040
gives us is a nice

00:11:34,720 --> 00:11:40,480
little attribute on the function

00:11:39,040 --> 00:11:42,320
of the annotation so it will actually

00:11:40,480 --> 00:11:43,920
evaluate the annotations put them in

00:11:42,320 --> 00:11:45,760
this nice little dick based on the

00:11:43,920 --> 00:11:48,720
variable and the return type

00:11:45,760 --> 00:11:49,279
uh i'm not sure what would happen if uh

00:11:48,720 --> 00:11:51,680
yeah

00:11:49,279 --> 00:11:51,680
you were

00:11:52,399 --> 00:11:56,079
passing an argument named return i guess

00:11:54,000 --> 00:11:57,440
maybe that's probably not not found or

00:11:56,079 --> 00:11:59,519
is frowned upon but

00:11:57,440 --> 00:12:00,639
um yeah you would get those annotations

00:11:59,519 --> 00:12:02,639
 and that

00:12:00,639 --> 00:12:03,920
anything that was uh sort of putting

00:12:02,639 --> 00:12:05,519
together this function would have access

00:12:03,920 --> 00:12:08,320
to these annotations

00:12:05,519 --> 00:12:10,560
as this is interesting uh and the pep

00:12:08,320 --> 00:12:12,560
included a bunch of uh

00:12:10,560 --> 00:12:14,399
ideas about what this could be used for

00:12:12,560 --> 00:12:16,079
and they all kind of boiled down to

00:12:14,399 --> 00:12:18,399
typing and then maybe some other stuff

00:12:16,079 --> 00:12:21,120
like documentation

00:12:18,399 --> 00:12:21,760
so this allowed us to write a function

00:12:21,120 --> 00:12:23,279
like this

00:12:21,760 --> 00:12:25,600
if we wanted to do you know evaluate

00:12:23,279 --> 00:12:28,399
typing with it i could

00:12:25,600 --> 00:12:30,720
as the annotation pass this class or the

00:12:28,399 --> 00:12:33,200
keyword that represents that class

00:12:30,720 --> 00:12:34,880
and then when i access the annotations

00:12:33,200 --> 00:12:36,079
it would tell me what i had written in

00:12:34,880 --> 00:12:37,600
my source code as the

00:12:36,079 --> 00:12:39,120
annotation for those variables in the

00:12:37,600 --> 00:12:40,560
return type

00:12:39,120 --> 00:12:42,480
but that's all it gives us it doesn't

00:12:40,560 --> 00:12:44,240
give us a way to evaluate whether this

00:12:42,480 --> 00:12:45,040
function was being used correctly or

00:12:44,240 --> 00:12:47,760
whether these

00:12:45,040 --> 00:12:49,040
uh return types and were actually being

00:12:47,760 --> 00:12:52,000
returned

00:12:49,040 --> 00:12:53,360
and it only gives us a way to annotate

00:12:52,000 --> 00:12:54,880
functions it doesn't give us a way to

00:12:53,360 --> 00:12:56,240
annotate any variables

00:12:54,880 --> 00:12:58,959
or anything that might be used within

00:12:56,240 --> 00:13:01,839
the function or outside the function

00:12:58,959 --> 00:13:03,680
so around this time yucatan toslo was

00:13:01,839 --> 00:13:04,639
working on his phd research at the

00:13:03,680 --> 00:13:06,160
university of cambridge

00:13:04,639 --> 00:13:08,320
and his research was about the

00:13:06,160 --> 00:13:11,040
unification of a statically typed

00:13:08,320 --> 00:13:12,800
and dynamically typed language and he

00:13:11,040 --> 00:13:13,600
wanted to use the same language for

00:13:12,800 --> 00:13:15,040
everything from a

00:13:13,600 --> 00:13:18,000
tiny script that doesn't need static

00:13:15,040 --> 00:13:20,320
typing to a sprawling multi-million line

00:13:18,000 --> 00:13:22,480
code base and he was also focused on the

00:13:20,320 --> 00:13:24,720
gradual growth he wanted to be able to

00:13:22,480 --> 00:13:26,639
slowly migrate from an untyped prototype

00:13:24,720 --> 00:13:28,000
to a statically typed product

00:13:26,639 --> 00:13:29,360
uh everything from you know take that

00:13:28,000 --> 00:13:30,720
little script and slowly migrate to

00:13:29,360 --> 00:13:31,680
something that was large and statically

00:13:30,720 --> 00:13:33,040
typed

00:13:31,680 --> 00:13:34,560
and this is the idea that you basically

00:13:33,040 --> 00:13:35,920
don't have to do it all at once right he

00:13:34,560 --> 00:13:38,399
wanted to be able to

00:13:35,920 --> 00:13:40,000
make static typing completely optional

00:13:38,399 --> 00:13:43,040
so he published

00:13:40,000 --> 00:13:44,480
his thesis in 2011

00:13:43,040 --> 00:13:46,160
and it said something basically along

00:13:44,480 --> 00:13:47,600
these lines he found that adding a

00:13:46,160 --> 00:13:49,760
static type system to a dynamically

00:13:47,600 --> 00:13:50,399
typed language can be a really invasive

00:13:49,760 --> 00:13:52,079
change

00:13:50,399 --> 00:13:54,079
would require coordinated modification

00:13:52,079 --> 00:13:55,760
of the programs virtual machines

00:13:54,079 --> 00:13:57,279
development tools basically everything

00:13:55,760 --> 00:13:59,040
that the language touches would have to

00:13:57,279 --> 00:14:00,880
be changed but

00:13:59,040 --> 00:14:03,199
he found that adding an optional

00:14:00,880 --> 00:14:04,639
optional pluggable type system

00:14:03,199 --> 00:14:06,880
would not affect the runtime semantics

00:14:04,639 --> 00:14:08,720
of the program and could be added to a

00:14:06,880 --> 00:14:10,800
language without affecting the existing

00:14:08,720 --> 00:14:12,160
code or tools so it sounds really great

00:14:10,800 --> 00:14:13,760
it sounds great for python because

00:14:12,160 --> 00:14:15,680
you know we're already set as a dynamic

00:14:13,760 --> 00:14:16,000
language being able to statically type

00:14:15,680 --> 00:14:19,279
things

00:14:16,000 --> 00:14:20,959
optionally makes a lot of sense so at

00:14:19,279 --> 00:14:23,199
2013 at pycon us

00:14:20,959 --> 00:14:25,199
he introduced something called my pi so

00:14:23,199 --> 00:14:27,360
if you've heard of my pi before

00:14:25,199 --> 00:14:29,600
what he introduced was not exactly what

00:14:27,360 --> 00:14:31,760
you might think of my pi

00:14:29,600 --> 00:14:32,959
at the time in 2013 when he gave this

00:14:31,760 --> 00:14:35,360
talk

00:14:32,959 --> 00:14:36,800
my pie was described as a experimental

00:14:35,360 --> 00:14:38,480
variant of python

00:14:36,800 --> 00:14:40,480
that supports writing programs that mix

00:14:38,480 --> 00:14:43,279
dynamic and static typing

00:14:40,480 --> 00:14:45,279
so in his research he wasn't able to use

00:14:43,279 --> 00:14:47,440
python as the language

00:14:45,279 --> 00:14:49,120
that he was using to do his research and

00:14:47,440 --> 00:14:50,079
so instead he created his own sort of

00:14:49,120 --> 00:14:52,240
variant

00:14:50,079 --> 00:14:53,519
um which he's doing research so it sort

00:14:52,240 --> 00:14:54,959
of makes sense that he could

00:14:53,519 --> 00:14:56,880
create a variant just to sort of prove

00:14:54,959 --> 00:14:58,320
his theories his variant looked like

00:14:56,880 --> 00:14:59,680
this and this he actually called the

00:14:58,320 --> 00:15:01,680
variant my pi

00:14:59,680 --> 00:15:03,360
um and the variant looked like this you

00:15:01,680 --> 00:15:04,320
can tell it kind of looks like python if

00:15:03,360 --> 00:15:05,760
you squint at it

00:15:04,320 --> 00:15:08,240
but there's some other stuff happening

00:15:05,760 --> 00:15:08,800
here um like you can see where the

00:15:08,240 --> 00:15:10,880
function

00:15:08,800 --> 00:15:12,160
fib is being declared as an integer and

00:15:10,880 --> 00:15:13,199
and the argument type kind of looks like

00:15:12,160 --> 00:15:15,279
a function annotation that we were

00:15:13,199 --> 00:15:17,839
talking about before

00:15:15,279 --> 00:15:19,839
so it kind of looked like python but

00:15:17,839 --> 00:15:21,040
wasn't python but you could compile it

00:15:19,839 --> 00:15:23,040
to python

00:15:21,040 --> 00:15:24,399
and so the issue was that uh even with

00:15:23,040 --> 00:15:26,160
the function annotations

00:15:24,399 --> 00:15:28,560
python couldn't support everything that

00:15:26,160 --> 00:15:29,920
was necessary to be statically typed

00:15:28,560 --> 00:15:31,839
and so what happened he presented this

00:15:29,920 --> 00:15:33,199
at pycon and he talked to guido

00:15:31,839 --> 00:15:35,040
afterwards and

00:15:33,199 --> 00:15:36,880
guido said basically let's drop the

00:15:35,040 --> 00:15:38,560
custom syntax let's drop the variant on

00:15:36,880 --> 00:15:41,759
the language and let's just do this in

00:15:38,560 --> 00:15:42,320
regular python 3. um so my pi also

00:15:41,759 --> 00:15:44,480
included

00:15:42,320 --> 00:15:45,600
a type checker for the variant and that

00:15:44,480 --> 00:15:48,240
is actually

00:15:45,600 --> 00:15:48,639
uh what we think of as my pi today and

00:15:48,240 --> 00:15:50,320
that

00:15:48,639 --> 00:15:52,000
since it was now modified to check

00:15:50,320 --> 00:15:54,560
python itself

00:15:52,000 --> 00:15:55,600
so in 2014 we got pet 483 this is the

00:15:54,560 --> 00:15:56,399
theory of type hints and this is

00:15:55,600 --> 00:15:58,720
basically

00:15:56,399 --> 00:16:00,639
guido putting down his ideas about how

00:15:58,720 --> 00:16:02,000
static typing should work in python

00:16:00,639 --> 00:16:04,160
and his ideas sort of aligned pretty

00:16:02,000 --> 00:16:05,759
well with what yuko was working on um

00:16:04,160 --> 00:16:07,279
so he said that typing should be

00:16:05,759 --> 00:16:08,480
optional adding annotations

00:16:07,279 --> 00:16:10,480
shouldn't affect the runtime of the

00:16:08,480 --> 00:16:12,000
program shouldn't get in your way

00:16:10,480 --> 00:16:14,000
an annotated function should behave

00:16:12,000 --> 00:16:14,800
exactly the same as an unannotated

00:16:14,000 --> 00:16:16,560
function

00:16:14,800 --> 00:16:17,759
and i think this has probably had a lot

00:16:16,560 --> 00:16:20,160
to do with the lessons we learned from

00:16:17,759 --> 00:16:22,639
the python 2 to 3 migration we wanted

00:16:20,160 --> 00:16:24,399
a adoption of stack typing to not be a

00:16:22,639 --> 00:16:26,240
breaking change not require a huge

00:16:24,399 --> 00:16:28,240
migration that kind of thing

00:16:26,240 --> 00:16:29,839
uh he wanted it to be gradual and this

00:16:28,240 --> 00:16:31,440
allows us to annotate only one part of a

00:16:29,839 --> 00:16:32,240
program or even just one function of a

00:16:31,440 --> 00:16:34,560
program

00:16:32,240 --> 00:16:36,720
and sort of leverage the aspects of both

00:16:34,560 --> 00:16:38,959
dynamic and static typing together

00:16:36,720 --> 00:16:40,399
he wanted to add variable annotations uh

00:16:38,959 --> 00:16:41,360
so we could annotate more than just a

00:16:40,399 --> 00:16:42,959
function

00:16:41,360 --> 00:16:45,360
and so that means that we could do

00:16:42,959 --> 00:16:46,880
something like this instead of uh

00:16:45,360 --> 00:16:48,720
having our variable these pads be

00:16:46,880 --> 00:16:49,920
unannotated we could add a comment like

00:16:48,720 --> 00:16:51,920
this

00:16:49,920 --> 00:16:54,240
call the type comment and this sort of

00:16:51,920 --> 00:16:57,600
gives us a type annotation for that line

00:16:54,240 --> 00:16:59,839
without changing the python syntax

00:16:57,600 --> 00:17:00,959
and he wanted to be able to support type

00:16:59,839 --> 00:17:02,959
hinting for python too

00:17:00,959 --> 00:17:04,799
because function annotations only

00:17:02,959 --> 00:17:07,120
existed in python 3 at the time

00:17:04,799 --> 00:17:08,880
so he wanted it to be possible for it

00:17:07,120 --> 00:17:09,520
even the people stuck with python 2 to

00:17:08,880 --> 00:17:11,600
continue

00:17:09,520 --> 00:17:13,360
to be able to adopt static typing so

00:17:11,600 --> 00:17:15,760
that means that in python 3 we could

00:17:13,360 --> 00:17:17,919
write these nice function annotations

00:17:15,760 --> 00:17:20,000
but in python 2 we could fall back onto

00:17:17,919 --> 00:17:21,439
these type comments even for the

00:17:20,000 --> 00:17:23,120
the function definition and that kind of

00:17:21,439 --> 00:17:24,799
stuff

00:17:23,120 --> 00:17:26,400
he introduced some special type

00:17:24,799 --> 00:17:28,319
constructs which were sort of building

00:17:26,400 --> 00:17:31,600
blocks and could use to define

00:17:28,319 --> 00:17:33,120
types so that you know adopted all the

00:17:31,600 --> 00:17:34,720
existing types like int and float and

00:17:33,120 --> 00:17:37,120
then created some new types that come

00:17:34,720 --> 00:17:39,280
from the typing built-in module

00:17:37,120 --> 00:17:40,640
like any any would be a wild card for

00:17:39,280 --> 00:17:42,480
matching any type

00:17:40,640 --> 00:17:43,840
union would combine two types together

00:17:42,480 --> 00:17:46,320
into a single type

00:17:43,840 --> 00:17:47,919
optional is the union of none and

00:17:46,320 --> 00:17:50,799
basically any type that you want

00:17:47,919 --> 00:17:52,320
tuples subtypes for collections that

00:17:50,799 --> 00:17:53,520
kind of thing

00:17:52,320 --> 00:17:54,880
so that would let us write a function

00:17:53,520 --> 00:17:55,760
like this once we have special type

00:17:54,880 --> 00:17:58,240
constructs

00:17:55,760 --> 00:17:59,600
we could say that the last argument to

00:17:58,240 --> 00:18:00,320
this from the key function could be an

00:17:59,600 --> 00:18:02,160
integer

00:18:00,320 --> 00:18:03,919
or it could be a float but the first two

00:18:02,160 --> 00:18:05,919
have to be integers and then

00:18:03,919 --> 00:18:07,039
we could similarly define the return

00:18:05,919 --> 00:18:09,039
type to also be

00:18:07,039 --> 00:18:11,440
the union of intent flow dependent on

00:18:09,039 --> 00:18:13,280
what was passed into it

00:18:11,440 --> 00:18:14,720
it also defined some container classes

00:18:13,280 --> 00:18:16,000
so these are things like lists and

00:18:14,720 --> 00:18:18,000
dictionaries so we can

00:18:16,000 --> 00:18:19,039
type the keys or values of a dictionary

00:18:18,000 --> 00:18:21,360
for example

00:18:19,039 --> 00:18:22,640
so like i could define a list that

00:18:21,360 --> 00:18:24,559
contains all integers

00:18:22,640 --> 00:18:26,160
and trying to append a string would fail

00:18:24,559 --> 00:18:26,880
i could define a dick that has a key of

00:18:26,160 --> 00:18:30,080
a string

00:18:26,880 --> 00:18:31,840
value of an integer and similarly

00:18:30,080 --> 00:18:34,000
trying to go against the typing would

00:18:31,840 --> 00:18:35,760
fail the type checker

00:18:34,000 --> 00:18:38,559
it also introduced some generic types

00:18:35,760 --> 00:18:40,320
for when classes and functions behave in

00:18:38,559 --> 00:18:42,160
a sort of generic way

00:18:40,320 --> 00:18:44,080
so we could do things like this just say

00:18:42,160 --> 00:18:46,559
that work accepts an iterable

00:18:44,080 --> 00:18:48,400
gave us some aliases as well so if we

00:18:46,559 --> 00:18:50,320
wanted to we could union all the

00:18:48,400 --> 00:18:52,720
numbers together into a single number

00:18:50,320 --> 00:18:55,039
class and be more like javascript

00:18:52,720 --> 00:18:56,000
and next in 2014 we got type hints and

00:18:55,039 --> 00:18:58,240
this was uh

00:18:56,000 --> 00:18:59,919
given to us in python 3.5 which was the

00:18:58,240 --> 00:19:01,679
least with that support

00:18:59,919 --> 00:19:03,200
we got syntax for variable annotations

00:19:01,679 --> 00:19:06,240
so that let us go from

00:19:03,200 --> 00:19:09,520
the comment style syntax to pure

00:19:06,240 --> 00:19:10,960
inline python we can annotate variables

00:19:09,520 --> 00:19:12,160
we can initialize variables with types

00:19:10,960 --> 00:19:12,960
without actually having to give them a

00:19:12,160 --> 00:19:16,240
value

00:19:12,960 --> 00:19:16,799
similarly for classes in python 36 we

00:19:16,240 --> 00:19:18,559
got

00:19:16,799 --> 00:19:20,000
526 support which almost had everything

00:19:18,559 --> 00:19:21,520
we needed last thing

00:19:20,000 --> 00:19:23,200
that we needed to finish the puzzle was

00:19:21,520 --> 00:19:25,760
a type checker

00:19:23,200 --> 00:19:27,120
so the difference between type checkers

00:19:25,760 --> 00:19:29,600
here is static and dynamic

00:19:27,120 --> 00:19:31,520
so my pi at this point had fully

00:19:29,600 --> 00:19:32,799
transitioned to a static type checker

00:19:31,520 --> 00:19:33,679
that means it's going to check all of

00:19:32,799 --> 00:19:36,160
your code

00:19:33,679 --> 00:19:36,720
at rest and it works kind of like this

00:19:36,160 --> 00:19:38,320
you would

00:19:36,720 --> 00:19:40,480
install it from pip you would create a

00:19:38,320 --> 00:19:43,840
python file

00:19:40,480 --> 00:19:43,840
okay and you would

00:19:44,480 --> 00:19:47,679
define a python file and then run mypi

00:19:46,320 --> 00:19:48,400
on it and it would tell you when you're

00:19:47,679 --> 00:19:51,760
using

00:19:48,400 --> 00:19:53,200
types correctly or incorrectly

00:19:51,760 --> 00:19:54,880
so at this point there are actually lots

00:19:53,200 --> 00:19:56,559
of static type checkers and

00:19:54,880 --> 00:19:58,960
academic dynamic type checkers as well

00:19:56,559 --> 00:20:01,600
which would check your types at runtime

00:19:58,960 --> 00:20:03,600
so basically all the big python shops

00:20:01,600 --> 00:20:05,919
had their own type checker

00:20:03,600 --> 00:20:07,440
and still do actually so dropbox

00:20:05,919 --> 00:20:09,360
basically owns the development of my pi

00:20:07,440 --> 00:20:11,360
google has a tool called pi type

00:20:09,360 --> 00:20:12,559
facebook has pi or microsoft says pyrite

00:20:11,360 --> 00:20:14,400
and actually um

00:20:12,559 --> 00:20:16,159
some editors have type checkers built

00:20:14,400 --> 00:20:17,520
into them like pycharm

00:20:16,159 --> 00:20:19,600
and then yeah there's a bunch of dynamic

00:20:17,520 --> 00:20:21,520
type checkers as well i think those are

00:20:19,600 --> 00:20:25,919
not quite as popular because they do

00:20:21,520 --> 00:20:27,280
add a limitation at runtime

00:20:25,919 --> 00:20:29,120
so one of the questions i get a lot

00:20:27,280 --> 00:20:30,240
about this are the differences between

00:20:29,120 --> 00:20:32,000
the static type checkers

00:20:30,240 --> 00:20:33,440
because if they're just implementing the

00:20:32,000 --> 00:20:34,000
standards like what could possibly be

00:20:33,440 --> 00:20:36,240
the difference maybe

00:20:34,000 --> 00:20:37,440
one's a little bit faster than the other

00:20:36,240 --> 00:20:39,919
uh so i'll talk about the

00:20:37,440 --> 00:20:42,000
the big sort of philosophy philosophical

00:20:39,919 --> 00:20:43,840
differences between my pi and pi type

00:20:42,000 --> 00:20:45,200
which i'll call cross-function inference

00:20:43,840 --> 00:20:46,559
and runtime linears and these are sort

00:20:45,200 --> 00:20:48,960
of comes down to a difference in

00:20:46,559 --> 00:20:51,440
philosophy about the behavior

00:20:48,960 --> 00:20:53,039
so for cross-function inference here's

00:20:51,440 --> 00:20:55,200
an unannotated file

00:20:53,039 --> 00:20:56,559
and if i were to run this in python i

00:20:55,200 --> 00:20:58,000
would get a type error right because

00:20:56,559 --> 00:21:00,159
what i'm trying to do here

00:20:58,000 --> 00:21:01,280
is concatenate a string with an integer

00:21:00,159 --> 00:21:02,960
and that would fail

00:21:01,280 --> 00:21:05,200
so just executing python i get a type

00:21:02,960 --> 00:21:07,039
error if i run this through my pi

00:21:05,200 --> 00:21:08,720
uh it actually succeeds it doesn't tell

00:21:07,039 --> 00:21:11,039
me there's anything wrong here

00:21:08,720 --> 00:21:12,799
uh if i run it with pi type however it

00:21:11,039 --> 00:21:14,000
will give me an error and the problem is

00:21:12,799 --> 00:21:15,600
that my pi

00:21:14,000 --> 00:21:17,520
doesn't have the ability to infer types

00:21:15,600 --> 00:21:19,760
across multiple function calls

00:21:17,520 --> 00:21:21,919
and pi type does um so pi type says well

00:21:19,760 --> 00:21:24,240
that's going to be a runtime error

00:21:21,919 --> 00:21:26,400
we need to to raise an exception or fail

00:21:24,240 --> 00:21:29,360
the type checker here

00:21:26,400 --> 00:21:30,720
similarly the another difference in

00:21:29,360 --> 00:21:32,640
philosophy is sort of

00:21:30,720 --> 00:21:34,640
whether functions that succeed at

00:21:32,640 --> 00:21:36,960
runtime should be type errors or not

00:21:34,640 --> 00:21:38,960
so in python i can annotate a list to

00:21:36,960 --> 00:21:41,360
contain only strings but then

00:21:38,960 --> 00:21:42,400
you know it's totally valid to append an

00:21:41,360 --> 00:21:44,000
integer to it

00:21:42,400 --> 00:21:45,679
that won't actually create a type error

00:21:44,000 --> 00:21:48,880
in python

00:21:45,679 --> 00:21:50,640
and so in uh if we run this it works

00:21:48,880 --> 00:21:52,400
just totally fine

00:21:50,640 --> 00:21:54,000
if we run it with pi type it says there

00:21:52,400 --> 00:21:55,760
are no problems this won't create a

00:21:54,000 --> 00:21:57,120
runtime type error

00:21:55,760 --> 00:21:58,880
mypie is a little more strict though it

00:21:57,120 --> 00:22:00,799
will say well you define the type for

00:21:58,880 --> 00:22:03,200
that list to be

00:22:00,799 --> 00:22:04,480
a integer and or is a string and you try

00:22:03,200 --> 00:22:06,960
to put an integer in it so

00:22:04,480 --> 00:22:08,400
that will fail all right some more

00:22:06,960 --> 00:22:09,840
questions you might just be saying all

00:22:08,400 --> 00:22:13,280
right why

00:22:09,840 --> 00:22:14,720
why and when should we use static typing

00:22:13,280 --> 00:22:16,240
so first i'll talk about when you

00:22:14,720 --> 00:22:18,400
shouldn't use stack typing which i think

00:22:16,240 --> 00:22:19,919
is basically never

00:22:18,400 --> 00:22:22,000
i think stock titling you should just

00:22:19,919 --> 00:22:22,799
use at your leisure or as liberally as

00:22:22,000 --> 00:22:24,720
you want

00:22:22,799 --> 00:22:26,000
you should be able to experiment with it

00:22:24,720 --> 00:22:28,080
one thing i'll notice that static

00:22:26,000 --> 00:22:29,760
typing is not a replacement for unit

00:22:28,080 --> 00:22:31,360
tests and there is a bit of similarity

00:22:29,760 --> 00:22:32,720
here sometimes unit tests end up looking

00:22:31,360 --> 00:22:33,360
a lot like type checking you know you

00:22:32,720 --> 00:22:35,520
sort of

00:22:33,360 --> 00:22:37,200
pass certain things in and assert on the

00:22:35,520 --> 00:22:40,480
output of the function whether it

00:22:37,200 --> 00:22:42,960
errors or succeeds but really unit tests

00:22:40,480 --> 00:22:43,600
are just a bad type system in reality

00:22:42,960 --> 00:22:46,320
you probably

00:22:43,600 --> 00:22:47,200
should do both so when should you use

00:22:46,320 --> 00:22:50,240
stack typing

00:22:47,200 --> 00:22:52,640
basically use as much as possible

00:22:50,240 --> 00:22:53,919
you know use it whenever you can you

00:22:52,640 --> 00:22:54,240
should definitely use static typing when

00:22:53,919 --> 00:22:55,760
you're

00:22:54,240 --> 00:22:56,960
millions lines of scale so if you're

00:22:55,760 --> 00:22:58,720
dropbox or google you've probably

00:22:56,960 --> 00:22:59,600
already invested a lot in static typing

00:22:58,720 --> 00:23:01,520
in python

00:22:59,600 --> 00:23:04,400
and actually dropbox found that at their

00:23:01,520 --> 00:23:06,080
scale dynamic actually was a liability

00:23:04,400 --> 00:23:08,720
for python it made it really

00:23:06,080 --> 00:23:10,000
hard to understand how functions and how

00:23:08,720 --> 00:23:13,120
a code base would work and

00:23:10,000 --> 00:23:14,799
began to improv in impact productivity

00:23:13,120 --> 00:23:16,080
so all those companies have invested a

00:23:14,799 --> 00:23:17,600
lot of money in the work that was

00:23:16,080 --> 00:23:19,919
already done here

00:23:17,600 --> 00:23:21,840
and you know the lack of typing you know

00:23:19,919 --> 00:23:23,360
you can think of it as a liability once

00:23:21,840 --> 00:23:25,679
you get to be that big

00:23:23,360 --> 00:23:27,679
made a little handy graph so the time to

00:23:25,679 --> 00:23:29,679
start thinking about static typing

00:23:27,679 --> 00:23:31,280
when is not when you're the size of

00:23:29,679 --> 00:23:32,240
dropbox or google but sometime before

00:23:31,280 --> 00:23:34,720
that so you're

00:23:32,240 --> 00:23:36,080
probably here this is when you should

00:23:34,720 --> 00:23:37,360
start thinking about adding type

00:23:36,080 --> 00:23:38,559
annotations

00:23:37,360 --> 00:23:40,880
here's when you'll probably actually do

00:23:38,559 --> 00:23:42,480
it but that's okay you can gradually add

00:23:40,880 --> 00:23:43,679
it as you go

00:23:42,480 --> 00:23:45,360
you should also use static typing when

00:23:43,679 --> 00:23:47,200
your code is confusing so let's be

00:23:45,360 --> 00:23:48,159
honest we've all written confusing code

00:23:47,200 --> 00:23:49,760
before

00:23:48,159 --> 00:23:51,600
some people like to say that annotations

00:23:49,760 --> 00:23:52,720
are machine verified documentation

00:23:51,600 --> 00:23:54,960
that's true

00:23:52,720 --> 00:23:56,080
if you feel like you need to document a

00:23:54,960 --> 00:23:57,679
confusing function

00:23:56,080 --> 00:23:59,440
specifically the input output types of

00:23:57,679 --> 00:24:00,720
it for example you should probably just

00:23:59,440 --> 00:24:02,480
statically type it because that will be

00:24:00,720 --> 00:24:04,799
just as clear and then you can do static

00:24:02,480 --> 00:24:06,000
analysis on it as well

00:24:04,799 --> 00:24:07,600
you should also use static typing when

00:24:06,000 --> 00:24:08,720
your code is for public consumption for

00:24:07,600 --> 00:24:10,320
example if you're going to put it on

00:24:08,720 --> 00:24:12,320
pipi as a module

00:24:10,320 --> 00:24:13,840
so adding type annotations helps

00:24:12,320 --> 00:24:14,799
third-party developers that want to use

00:24:13,840 --> 00:24:17,520
your module know

00:24:14,799 --> 00:24:18,240
how to use it it also lets ides do auto

00:24:17,520 --> 00:24:20,880
completion

00:24:18,240 --> 00:24:22,640
and tell you how to use consume the api

00:24:20,880 --> 00:24:24,320
and then if your users are already using

00:24:22,640 --> 00:24:25,760
static typing in their code base and

00:24:24,320 --> 00:24:26,480
they want to pull in something from your

00:24:25,760 --> 00:24:27,919
library

00:24:26,480 --> 00:24:30,400
they will absolutely love that your

00:24:27,919 --> 00:24:32,080
support stack typing as well

00:24:30,400 --> 00:24:34,640
another place you can use static typing

00:24:32,080 --> 00:24:36,640
is before migrating or refactoring

00:24:34,640 --> 00:24:37,840
so before you make a big change go and

00:24:36,640 --> 00:24:39,600
add some static types

00:24:37,840 --> 00:24:42,240
move things around and see if any of the

00:24:39,600 --> 00:24:44,000
typing breaks that's probably a bug

00:24:42,240 --> 00:24:46,240
and finally you can use static typing

00:24:44,000 --> 00:24:48,720
just to experiment with static typing

00:24:46,240 --> 00:24:49,279
uh it doesn't hurt it's totally painless

00:24:48,720 --> 00:24:51,600
and

00:24:49,279 --> 00:24:53,039
it's just be a fun way to learn about a

00:24:51,600 --> 00:24:55,440
new part of python

00:24:53,039 --> 00:24:57,120
so to wrap up how to use stack typing in

00:24:55,440 --> 00:24:58,640
just five easy steps first you have to

00:24:57,120 --> 00:25:00,080
migrate to python greater than

00:24:58,640 --> 00:25:01,600
or equal to six now this is actually

00:25:00,080 --> 00:25:02,880
optional you can use type comments in

00:25:01,600 --> 00:25:04,400
any version but

00:25:02,880 --> 00:25:06,400
let's be honest you should migrate to

00:25:04,400 --> 00:25:07,840
python 3 anyway

00:25:06,400 --> 00:25:09,840
install type checker locally i don't

00:25:07,840 --> 00:25:11,279
care which one it is but

00:25:09,840 --> 00:25:12,720
install it and integrate it into your

00:25:11,279 --> 00:25:13,440
editor so that it runs automatically

00:25:12,720 --> 00:25:15,760
when you

00:25:13,440 --> 00:25:17,279
write or save a file and then you can

00:25:15,760 --> 00:25:19,520
start optionally typing your code base

00:25:17,279 --> 00:25:21,520
start with the most complex function or

00:25:19,520 --> 00:25:23,039
the easiest to understand function don't

00:25:21,520 --> 00:25:23,840
try to do it all at once remember it's

00:25:23,039 --> 00:25:26,640
intentionally

00:25:23,840 --> 00:25:29,200
a gradual process and pick sort of

00:25:26,640 --> 00:25:31,440
critical areas and start there

00:25:29,200 --> 00:25:33,279
last or second or last uh run the side

00:25:31,440 --> 00:25:34,960
checker with your linting put it in ci

00:25:33,279 --> 00:25:37,200
and have it just run there anyways

00:25:34,960 --> 00:25:38,799
assuming that you have ci

00:25:37,200 --> 00:25:40,240
and finally convince all your co-workers

00:25:38,799 --> 00:25:41,600
to join you so if you need help

00:25:40,240 --> 00:25:43,039
convincing them feel free to send them

00:25:41,600 --> 00:25:45,360
my way

00:25:43,039 --> 00:25:46,480
uh thanks everyone to the talks and i

00:25:45,360 --> 00:25:48,080
want to give a quick shout out and thank

00:25:46,480 --> 00:25:48,400
you to the organizers as well this has

00:25:48,080 --> 00:25:49,760
been

00:25:48,400 --> 00:25:51,760
a really amazing seamless online

00:25:49,760 --> 00:25:53,279
conference and

00:25:51,760 --> 00:25:55,039
they absolutely deserve your thanks as

00:25:53,279 --> 00:25:57,200
well so thank you everyone and thanks

00:25:55,039 --> 00:26:00,799
for your attention

00:25:57,200 --> 00:26:03,030
absolutely thank you so much um

00:26:00,799 --> 00:26:08,480
i am supposed to be able to play this

00:26:03,030 --> 00:26:12,080
[Applause]

00:26:08,480 --> 00:26:13,760
audience and so yeah so i have one

00:26:12,080 --> 00:26:15,039
question uh here oh wow actually this

00:26:13,760 --> 00:26:17,440
has gone up to five

00:26:15,039 --> 00:26:18,799
um in the last few seconds but we don't

00:26:17,440 --> 00:26:19,440
have time for five we'll do as many as

00:26:18,799 --> 00:26:21,440
we can

00:26:19,440 --> 00:26:22,480
uh so anybody if we don't get to your

00:26:21,440 --> 00:26:25,360
question uh

00:26:22,480 --> 00:26:26,880
uh uh look and discord for talk static

00:26:25,360 --> 00:26:27,600
typing you talk to dustin there some

00:26:26,880 --> 00:26:31,600
more

00:26:27,600 --> 00:26:34,720
uh but uh let me see here so um

00:26:31,600 --> 00:26:36,640
uh someone said is there any tool which

00:26:34,720 --> 00:26:37,120
can build api docs are the return types

00:26:36,640 --> 00:26:39,120
of each

00:26:37,120 --> 00:26:42,080
function by extracting static type

00:26:39,120 --> 00:26:44,960
annotations from your python code

00:26:42,080 --> 00:26:47,360
uh so you're saying automatically

00:26:44,960 --> 00:26:50,480
building documentation from

00:26:47,360 --> 00:26:51,919
static type annotations

00:26:50,480 --> 00:26:53,279
yeah i think there's some stuff that

00:26:51,919 --> 00:26:55,279
exists and definitely there's a lot of

00:26:53,279 --> 00:26:56,559
the documentation tools now will

00:26:55,279 --> 00:26:58,559
take into account whether you have

00:26:56,559 --> 00:26:59,840
statically typed uh a function so you

00:26:58,559 --> 00:27:00,799
don't need those long talk strings that

00:26:59,840 --> 00:27:02,799
i was showing

00:27:00,799 --> 00:27:04,000
um for in order for your api

00:27:02,799 --> 00:27:06,559
documentation or your

00:27:04,000 --> 00:27:07,760
you know module documentation to pick up

00:27:06,559 --> 00:27:09,679
and show what the

00:27:07,760 --> 00:27:11,360
expected values are for so i haven't

00:27:09,679 --> 00:27:13,279
actually used any of them personally

00:27:11,360 --> 00:27:14,720
but yeah i i imagine that some of the

00:27:13,279 --> 00:27:15,520
more prominent documentation tools

00:27:14,720 --> 00:27:18,480
definitely should

00:27:15,520 --> 00:27:20,000
should be supporting that yeah okay um

00:27:18,480 --> 00:27:22,159
francesco asks how can one

00:27:20,000 --> 00:27:23,520
combine type annotations to perform

00:27:22,159 --> 00:27:26,080
static type checks with my

00:27:23,520 --> 00:27:28,480
pi with detailed docs strings so it's

00:27:26,080 --> 00:27:30,159
kind of along those same lines

00:27:28,480 --> 00:27:31,360
oh so you already have detailed doc

00:27:30,159 --> 00:27:32,799
strings and you want to add type

00:27:31,360 --> 00:27:33,039
annotations yeah that's a good question

00:27:32,799 --> 00:27:35,440
i

00:27:33,039 --> 00:27:37,200
i'm not actually familiar with a a way

00:27:35,440 --> 00:27:40,480
to do that so it's sort of

00:27:37,200 --> 00:27:42,080
uh i guess there are type checkers that

00:27:40,480 --> 00:27:42,960
check doc strings and there are type

00:27:42,080 --> 00:27:45,520
checkers that check

00:27:42,960 --> 00:27:48,799
static typing annotations i'm not sure

00:27:45,520 --> 00:27:50,399
if there's any that do both uh

00:27:48,799 --> 00:27:51,919
i'll try and find out and i'll let you

00:27:50,399 --> 00:27:54,320
know in the chat

00:27:51,919 --> 00:27:56,240
uh someone says what about my pyc is

00:27:54,320 --> 00:27:58,000
there a future for compiled python using

00:27:56,240 --> 00:28:00,320
type hints

00:27:58,000 --> 00:28:02,080
i think there might be uh i don't know a

00:28:00,320 --> 00:28:04,559
whole lot about my pyc

00:28:02,080 --> 00:28:06,640
but yeah definitely i can connect you

00:28:04,559 --> 00:28:07,760
with folks that are working on that and

00:28:06,640 --> 00:28:09,679
yeah there's some interesting

00:28:07,760 --> 00:28:11,360
developments there i think

00:28:09,679 --> 00:28:13,919
all right well once again thank you very

00:28:11,360 --> 00:28:16,150
much thanks

00:28:13,919 --> 00:28:24,079
great to be here

00:28:16,150 --> 00:28:24,079

YouTube URL: https://www.youtube.com/watch?v=cmmPDYa0gWo


