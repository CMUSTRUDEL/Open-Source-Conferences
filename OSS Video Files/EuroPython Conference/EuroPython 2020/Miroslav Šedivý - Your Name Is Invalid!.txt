Title: Miroslav Šedivý - Your Name Is Invalid!
Publication date: 2020-09-15
Playlist: EuroPython 2020
Description: 
	"Your Name Is Invalid!
EuroPython 2020 - Talk - 2020-07-23 - Microsoft
Online

By Miroslav Šedivý

People have names. Most people do. People have first names and last names. Many people do. People have any sorts of names that often don't fit fixed fields in the forms. These names may contain letters, accented letters, and other characters, that may cause problems to your code depending on the encoding you use. They may look differently in uppercase and lowercase, or may not be case foldable at all. Searching and sorting these names may be tricky too. And if you design an application, web form, and/or database dealing with personal names, you'll have to take that into account.

This talk is not about GDPR, but will help you to use the best tools to handle encoding and locales in Python and prevent your application from appearing in my talk and in uxfails memes.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2020.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:07,200 --> 00:00:11,920
welcome

00:00:08,000 --> 00:00:15,280
to the next afternoon session

00:00:11,920 --> 00:00:19,359
our next speaker is miroslav

00:00:15,280 --> 00:00:22,400
shadivi he will talk about

00:00:19,359 --> 00:00:23,439
your name is invalid names of people

00:00:22,400 --> 00:00:26,960
cannot be invalid

00:00:23,439 --> 00:00:29,119
your app shouldn't and he will mention

00:00:26,960 --> 00:00:33,040
many things i guess

00:00:29,119 --> 00:00:37,040
about these wrong names so okay

00:00:33,040 --> 00:00:40,079
miro please start thank you

00:00:37,040 --> 00:00:44,410
hi let me introduce myself my name is

00:00:40,079 --> 00:00:46,320
miroslav uh

00:00:44,410 --> 00:00:48,960
[Music]

00:00:46,320 --> 00:00:50,719
we have still some problems with the

00:00:48,960 --> 00:00:53,360
transmission

00:00:50,719 --> 00:00:55,440
wait wait wait hey hey we couldn't

00:00:53,360 --> 00:00:57,680
prepare that beforehand

00:00:55,440 --> 00:00:59,520
i will have to switch something here no

00:00:57,680 --> 00:01:02,879
no that's not still ah now

00:00:59,520 --> 00:01:04,400
okay my name is miroslav and sometimes i

00:01:02,879 --> 00:01:05,760
still see somewhere that my name is

00:01:04,400 --> 00:01:07,280
invalid

00:01:05,760 --> 00:01:09,280
if you want to pronounce it correctly

00:01:07,280 --> 00:01:10,799
this is the ipa how to pronounce it and

00:01:09,280 --> 00:01:13,760
this is how to type it on a standard

00:01:10,799 --> 00:01:16,240
keyboard layout with uh compost key

00:01:13,760 --> 00:01:16,240
i forget

00:01:17,040 --> 00:01:21,840
and if you would like to see the region

00:01:20,240 --> 00:01:22,960
with the best the german wine and the

00:01:21,840 --> 00:01:24,640
best french beer

00:01:22,960 --> 00:01:26,560
come to siesta carson we do a lot of

00:01:24,640 --> 00:01:27,759
great stuff with white and other open

00:01:26,560 --> 00:01:30,159
source technology

00:01:27,759 --> 00:01:31,840
originally i was born in slovakia i

00:01:30,159 --> 00:01:34,960
studied in france and now i'm in

00:01:31,840 --> 00:01:38,960
germany what we are going to speak about

00:01:34,960 --> 00:01:41,439
today first about strings and names in

00:01:38,960 --> 00:01:43,200
python so how the string spikes work

00:01:41,439 --> 00:01:44,640
encoding normalizing case holding

00:01:43,200 --> 00:01:47,840
sorting and

00:01:44,640 --> 00:01:49,280
regular expressions and then about names

00:01:47,840 --> 00:01:52,159
on the web

00:01:49,280 --> 00:01:53,600
about the apps about databases how to

00:01:52,159 --> 00:01:57,119
work with the names

00:01:53,600 --> 00:01:59,759
correctly and how to

00:01:57,119 --> 00:02:00,960
allow or test whether a name is valid or

00:01:59,759 --> 00:02:06,000
not

00:02:00,960 --> 00:02:08,479
so in python 3 there are two types of

00:02:06,000 --> 00:02:09,039
of objects that work with strings the

00:02:08,479 --> 00:02:11,280
first is

00:02:09,039 --> 00:02:12,720
standard string that for each character

00:02:11,280 --> 00:02:15,840
knows more than one million

00:02:12,720 --> 00:02:17,360
possible possible characters

00:02:15,840 --> 00:02:19,360
that's unicode and that is something

00:02:17,360 --> 00:02:20,720
that is in the working memory so you

00:02:19,360 --> 00:02:22,560
work with that but you don't

00:02:20,720 --> 00:02:24,400
send it over network or store into a

00:02:22,560 --> 00:02:25,280
file and there are bytes with two

00:02:24,400 --> 00:02:28,160
hundred and six

00:02:25,280 --> 00:02:29,040
twenty fifty six uh possible uh

00:02:28,160 --> 00:02:32,400
combinations

00:02:29,040 --> 00:02:33,680
uh that are used to store data on file

00:02:32,400 --> 00:02:36,480
and or network

00:02:33,680 --> 00:02:36,800
and you have to combine or you have to

00:02:36,480 --> 00:02:39,680
uh

00:02:36,800 --> 00:02:41,440
convert between these somehow so for

00:02:39,680 --> 00:02:43,200
example if your string

00:02:41,440 --> 00:02:44,480
is your name is chuck norris and you

00:02:43,200 --> 00:02:47,200
just encode it you get

00:02:44,480 --> 00:02:48,080
a series of the bytes that looks uh

00:02:47,200 --> 00:02:50,640
almost the same

00:02:48,080 --> 00:02:51,519
and the other way around from bytes back

00:02:50,640 --> 00:02:53,360
to uh

00:02:51,519 --> 00:02:54,720
string you convert it with using the

00:02:53,360 --> 00:02:56,480
decode method

00:02:54,720 --> 00:02:58,239
uh the bias you can see them with you

00:02:56,480 --> 00:02:58,720
can recognize them but they have a small

00:02:58,239 --> 00:03:01,040
b

00:02:58,720 --> 00:03:02,560
before this quote and the strings they

00:03:01,040 --> 00:03:05,280
have nothing

00:03:02,560 --> 00:03:05,840
um if you encode them standardly in

00:03:05,280 --> 00:03:08,560
python

00:03:05,840 --> 00:03:09,680
it uses utf-8 as a standard accounting

00:03:08,560 --> 00:03:11,840
but

00:03:09,680 --> 00:03:13,040
in this case it will be 12 characters as

00:03:11,840 --> 00:03:16,840
a string or 12

00:03:13,040 --> 00:03:18,800
bytes as bytes so there is no

00:03:16,840 --> 00:03:20,159
difference but for example if you have

00:03:18,800 --> 00:03:22,800
the german name miller

00:03:20,159 --> 00:03:24,560
and you encode it then from six

00:03:22,800 --> 00:03:26,239
characters you will get seven bytes

00:03:24,560 --> 00:03:29,440
because the letter u

00:03:26,239 --> 00:03:32,799
uml is uh will be written

00:03:29,440 --> 00:03:34,400
or stored as two bytes yeah

00:03:32,799 --> 00:03:36,239
if you have chinese name this is not a

00:03:34,400 --> 00:03:36,879
name this is new house simple hello in

00:03:36,239 --> 00:03:39,519
chinese

00:03:36,879 --> 00:03:40,319
from two chinese characters in utf-8 it

00:03:39,519 --> 00:03:43,360
will be stored

00:03:40,319 --> 00:03:46,480
as six bytes

00:03:43,360 --> 00:03:46,799
um there are other encodings utf-8 is

00:03:46,480 --> 00:03:49,599
the

00:03:46,799 --> 00:03:50,799
relatively the newest one although it is

00:03:49,599 --> 00:03:53,920
over two decades old

00:03:50,799 --> 00:03:54,319
um there is ascii that is around since

00:03:53,920 --> 00:03:57,519
many

00:03:54,319 --> 00:03:59,439
uh many thousands of years um

00:03:57,519 --> 00:04:01,200
and if your name is struck maurice of

00:03:59,439 --> 00:04:04,560
course you can be encoded in

00:04:01,200 --> 00:04:06,239
any um encoding and actually you are the

00:04:04,560 --> 00:04:08,799
one who decides about the encoding

00:04:06,239 --> 00:04:09,760
but in this case uh chuck norris with 12

00:04:08,799 --> 00:04:13,120
characters will be

00:04:09,760 --> 00:04:16,000
encoded into 12 uh bytes using ascii

00:04:13,120 --> 00:04:17,359
but if you have the name miller you

00:04:16,000 --> 00:04:18,959
cannot do it with ascii

00:04:17,359 --> 00:04:20,799
you can do it for example with latin one

00:04:18,959 --> 00:04:22,240
that knows more characters that knows

00:04:20,799 --> 00:04:24,880
even this

00:04:22,240 --> 00:04:26,400
and in this case the uh six uh

00:04:24,880 --> 00:04:29,520
characters will be encoded

00:04:26,400 --> 00:04:30,479
as six bytes using that in one my last

00:04:29,520 --> 00:04:32,160
name shavi

00:04:30,479 --> 00:04:34,320
comes from czechoslovakia which doesn't

00:04:32,160 --> 00:04:37,759
use latin one it uses uh latin two

00:04:34,320 --> 00:04:40,240
alphabet or encoding and um

00:04:37,759 --> 00:04:41,440
our six characters will be encoded as

00:04:40,240 --> 00:04:43,759
six bytes

00:04:41,440 --> 00:04:45,240
but always a byte is something that has

00:04:43,759 --> 00:04:47,919
only

00:04:45,240 --> 00:04:49,919
156 possibilities so you don't have the

00:04:47,919 --> 00:04:51,440
information which encoding it is in

00:04:49,919 --> 00:04:53,120
in this case we knew that we are going

00:04:51,440 --> 00:04:55,280
to use latin one or latin two

00:04:53,120 --> 00:04:57,040
but normally you don't know which

00:04:55,280 --> 00:04:59,680
recovery it is

00:04:57,040 --> 00:05:00,400
so and sometimes it can happen something

00:04:59,680 --> 00:05:03,600
like this

00:05:00,400 --> 00:05:07,520
that i get a male here in germany where

00:05:03,600 --> 00:05:10,160
that types my last name wrongly

00:05:07,520 --> 00:05:12,800
how is it possible that instead of that

00:05:10,160 --> 00:05:16,160
s with karen i get a question mark

00:05:12,800 --> 00:05:17,919
uh do they use python so if

00:05:16,160 --> 00:05:19,280
i take my last name and encode it with

00:05:17,919 --> 00:05:22,880
latin 2 i will get

00:05:19,280 --> 00:05:25,280
the correct six bytes the

00:05:22,880 --> 00:05:26,560
verizon but there is no question mark if

00:05:25,280 --> 00:05:29,520
i do it with latino one

00:05:26,560 --> 00:05:30,000
i will get a unicode uh error because

00:05:29,520 --> 00:05:32,560
the

00:05:30,000 --> 00:05:33,039
cannot be encoded in latin one there is

00:05:32,560 --> 00:05:36,080
in the

00:05:33,039 --> 00:05:40,800
those 256 possible bytes of

00:05:36,080 --> 00:05:43,520
uh but in one the letter h is not there

00:05:40,800 --> 00:05:45,600
but in python you can define an error

00:05:43,520 --> 00:05:46,160
what to do in the case of error default

00:05:45,600 --> 00:05:49,680
is

00:05:46,160 --> 00:05:50,080
raise an exception but it is possible to

00:05:49,680 --> 00:05:52,720
say

00:05:50,080 --> 00:05:54,720
replace it with something and replace

00:05:52,720 --> 00:05:57,199
default is a question mark

00:05:54,720 --> 00:05:59,759
so if you encode some string that

00:05:57,199 --> 00:06:01,759
contains characters that are outside of

00:05:59,759 --> 00:06:03,280
the encoding so for example sure in the

00:06:01,759 --> 00:06:05,280
case of letting one

00:06:03,280 --> 00:06:07,440
and you say in the case of error replace

00:06:05,280 --> 00:06:08,319
it it will automatically replace it with

00:06:07,440 --> 00:06:12,000
a question mark

00:06:08,319 --> 00:06:14,880
and this is probably how this happened

00:06:12,000 --> 00:06:16,560
you can even do something more you can

00:06:14,880 --> 00:06:17,680
define your own function if you don't

00:06:16,560 --> 00:06:19,520
want question mark

00:06:17,680 --> 00:06:21,199
the whole time and you can register an

00:06:19,520 --> 00:06:24,720
error and

00:06:21,199 --> 00:06:25,360
codex and then okay if i use the errors

00:06:24,720 --> 00:06:29,120
method

00:06:25,360 --> 00:06:31,520
replace randomly for example call this

00:06:29,120 --> 00:06:32,840
lambda function that gives a random

00:06:31,520 --> 00:06:35,440
[Music]

00:06:32,840 --> 00:06:38,160
digit and this x start

00:06:35,440 --> 00:06:39,680
plus plus one means that then go on with

00:06:38,160 --> 00:06:42,720
the next character you can

00:06:39,680 --> 00:06:45,840
define more movements around uh

00:06:42,720 --> 00:06:47,759
such cases so in this case i can tell if

00:06:45,840 --> 00:06:48,560
i want to encode my last name with latin

00:06:47,759 --> 00:06:51,360
one

00:06:48,560 --> 00:06:52,240
and if a character is not cannot be

00:06:51,360 --> 00:06:55,120
encoded

00:06:52,240 --> 00:06:56,000
and then put there some random digit in

00:06:55,120 --> 00:06:58,639
this case

00:06:56,000 --> 00:07:00,560
number five for example and this is

00:06:58,639 --> 00:07:03,759
probably how

00:07:00,560 --> 00:07:05,440
they are doing it some random characters

00:07:03,759 --> 00:07:06,880
sometimes there is a space sometimes

00:07:05,440 --> 00:07:08,560
there is no space

00:07:06,880 --> 00:07:10,000
sometimes there is something like this

00:07:08,560 --> 00:07:12,319
sometimes there is an

00:07:10,000 --> 00:07:12,620
inverted question mark actually all

00:07:12,319 --> 00:07:14,160
three

00:07:12,620 --> 00:07:17,840
[Music]

00:07:14,160 --> 00:07:21,440
pictures come from the same company

00:07:17,840 --> 00:07:24,000
that has different um

00:07:21,440 --> 00:07:24,560
means of communication like letter like

00:07:24,000 --> 00:07:27,360
card

00:07:24,560 --> 00:07:28,720
customer card or uh on online form

00:07:27,360 --> 00:07:32,000
although i have entered it

00:07:28,720 --> 00:07:34,560
correctly in the web form when i signed

00:07:32,000 --> 00:07:38,720
up for their service

00:07:34,560 --> 00:07:42,400
there are some other cases here i'm some

00:07:38,720 --> 00:07:45,440
no-name german flying

00:07:42,400 --> 00:07:46,720
company that has uh huge airplanes but

00:07:45,440 --> 00:07:49,199
have problem with their

00:07:46,720 --> 00:07:50,879
form they tell me hey you can only enter

00:07:49,199 --> 00:07:53,599
letters in the adult's last name

00:07:50,879 --> 00:07:54,479
field what are letters my last name

00:07:53,599 --> 00:07:57,520
consists

00:07:54,479 --> 00:07:59,520
only of letters what is the letter in

00:07:57,520 --> 00:08:03,039
python 3 you can do something like this

00:07:59,520 --> 00:08:06,800
you can uh give variable

00:08:03,039 --> 00:08:09,840
the name that that is not pure ascii

00:08:06,800 --> 00:08:10,960
that consists of other characters um but

00:08:09,840 --> 00:08:13,840
you can do that

00:08:10,960 --> 00:08:14,879
but you cannot give a variable a name

00:08:13,840 --> 00:08:16,960
consisting of

00:08:14,879 --> 00:08:18,960
starting with a number but sure it's not

00:08:16,960 --> 00:08:21,440
a number it's a character it's a letter

00:08:18,960 --> 00:08:23,919
uh how do how does python know that show

00:08:21,440 --> 00:08:26,879
is a letter but a smiley is not a letter

00:08:23,919 --> 00:08:28,479
question mark is not a library um there

00:08:26,879 --> 00:08:31,840
is unicode data

00:08:28,479 --> 00:08:32,800
that has the standard module unicode

00:08:31,840 --> 00:08:35,680
data

00:08:32,800 --> 00:08:36,240
that has the method category and name so

00:08:35,680 --> 00:08:38,000
you give it

00:08:36,240 --> 00:08:39,680
a character and it will tell you which

00:08:38,000 --> 00:08:41,919
category and name with this

00:08:39,680 --> 00:08:44,320
so in this case i gave there a few

00:08:41,919 --> 00:08:47,200
numbers and smiley and dot and so on

00:08:44,320 --> 00:08:48,240
and there you see all these characters

00:08:47,200 --> 00:08:51,760
and then you see two letters

00:08:48,240 --> 00:08:54,000
two letters there is ll lu set as

00:08:51,760 --> 00:08:55,839
p-o-s-o and so on and then there is the

00:08:54,000 --> 00:08:58,320
official name of the character

00:08:55,839 --> 00:08:59,760
so uh everything that these two

00:08:58,320 --> 00:09:02,320
characters when they start with an

00:08:59,760 --> 00:09:04,560
l it means a letter l l is a lowercase

00:09:02,320 --> 00:09:07,360
letter l u is uppercase letter

00:09:04,560 --> 00:09:08,560
and so it is defined every character in

00:09:07,360 --> 00:09:11,519
the unicode is defined

00:09:08,560 --> 00:09:12,240
it has it belongs to some category and

00:09:11,519 --> 00:09:14,800
that it has

00:09:12,240 --> 00:09:15,440
um it is a letter or not so you can use

00:09:14,800 --> 00:09:18,080
the shaft

00:09:15,440 --> 00:09:19,279
as the capital letter sharp as uh as a

00:09:18,080 --> 00:09:22,399
variable name

00:09:19,279 --> 00:09:25,360
uh these are all the

00:09:22,399 --> 00:09:26,640
categories that we are going to see a

00:09:25,360 --> 00:09:29,839
little bit later how we can

00:09:26,640 --> 00:09:32,080
use them um also if you open

00:09:29,839 --> 00:09:33,360
character map application you will see

00:09:32,080 --> 00:09:35,760
all the information about

00:09:33,360 --> 00:09:37,839
the character and you can use actually

00:09:35,760 --> 00:09:41,200
the name to

00:09:37,839 --> 00:09:44,399
put the to write the character with

00:09:41,200 --> 00:09:47,519
backslash and capital n and uh

00:09:44,399 --> 00:09:50,000
with carli braces

00:09:47,519 --> 00:09:51,360
case holding case folding means the

00:09:50,000 --> 00:09:52,240
conversion between uppercase and

00:09:51,360 --> 00:09:54,160
lowercase

00:09:52,240 --> 00:09:55,279
um obviously we have some letters in the

00:09:54,160 --> 00:09:59,040
lowercase we

00:09:55,279 --> 00:10:01,360
got upper to uppercase and vice versa

00:09:59,040 --> 00:10:02,160
it has a few exceptions so for example

00:10:01,360 --> 00:10:04,320
the sharp s

00:10:02,160 --> 00:10:05,519
the german sharp s lowercase converts to

00:10:04,320 --> 00:10:07,519
s as uppercase

00:10:05,519 --> 00:10:09,680
although there is official sharpest

00:10:07,519 --> 00:10:11,440
uppercase character

00:10:09,680 --> 00:10:13,519
the other way around it converts

00:10:11,440 --> 00:10:16,240
correctly

00:10:13,519 --> 00:10:18,000
and so it works for most other

00:10:16,240 --> 00:10:19,200
characters between uppercase lowercase

00:10:18,000 --> 00:10:20,880
of course you have for example chinese

00:10:19,200 --> 00:10:21,920
kind of just about support something

00:10:20,880 --> 00:10:25,200
like that

00:10:21,920 --> 00:10:26,320
um but there is also with this uppercase

00:10:25,200 --> 00:10:28,640
and lowercase there is

00:10:26,320 --> 00:10:30,640
one problem even in the basic ascii

00:10:28,640 --> 00:10:31,440
there is one ascii pair over case

00:10:30,640 --> 00:10:34,640
uppercase

00:10:31,440 --> 00:10:38,880
that we like the western english

00:10:34,640 --> 00:10:42,720
european language group did wrong

00:10:38,880 --> 00:10:45,839
which one is it it's i you see if i

00:10:42,720 --> 00:10:46,959
take lowercase i i do it to uppercase i

00:10:45,839 --> 00:10:48,720
get this and

00:10:46,959 --> 00:10:51,120
the other way around as well with from

00:10:48,720 --> 00:10:53,279
the uppercase i i get the lowercase y

00:10:51,120 --> 00:10:56,480
you see the difference a lowercase i has

00:10:53,279 --> 00:10:58,839
a dot the uppercase i doesn't have a dot

00:10:56,480 --> 00:11:01,440
how do you explain that to someone from

00:10:58,839 --> 00:11:03,360
turkey because they have

00:11:01,440 --> 00:11:04,560
the i with the lowercase uppercase that

00:11:03,360 --> 00:11:08,079
is e

00:11:04,560 --> 00:11:09,279
and i without dot or lowercase uppercase

00:11:08,079 --> 00:11:12,480
that is

00:11:09,279 --> 00:11:13,200
and when they convert between these two

00:11:12,480 --> 00:11:15,120
pairs of

00:11:13,200 --> 00:11:17,200
characters they always get the other one

00:11:15,120 --> 00:11:19,680
so

00:11:17,200 --> 00:11:20,320
so if you want to work with turkish text

00:11:19,680 --> 00:11:21,839
you have to

00:11:20,320 --> 00:11:24,399
import international components for

00:11:21,839 --> 00:11:27,600
unicode library and then

00:11:24,399 --> 00:11:30,720
work a little bit more complicated

00:11:27,600 --> 00:11:35,200
code that converts between the

00:11:30,720 --> 00:11:38,160
turkish pairs of e and correctly

00:11:35,200 --> 00:11:39,920
normalization is something different if

00:11:38,160 --> 00:11:40,560
you have already your unicode text and

00:11:39,920 --> 00:11:42,000
you think

00:11:40,560 --> 00:11:44,399
okay that's great i can now work with

00:11:42,000 --> 00:11:47,519
that i can access the characters

00:11:44,399 --> 00:11:49,920
the length and everything you will get

00:11:47,519 --> 00:11:51,040
probably two strings that look the same

00:11:49,920 --> 00:11:54,240
and they are not the same

00:11:51,040 --> 00:11:56,800
because when they are normalized um

00:11:54,240 --> 00:11:58,079
they will be divided uh or some

00:11:56,800 --> 00:12:00,240
characters will be

00:11:58,079 --> 00:12:01,200
split in two characters so for example

00:12:00,240 --> 00:12:03,600
the first word

00:12:01,200 --> 00:12:04,240
has three characters the second one is

00:12:03,600 --> 00:12:07,680
ooh with

00:12:04,240 --> 00:12:10,480
uh dots like the resist mode

00:12:07,680 --> 00:12:10,880
and the second version has this theories

00:12:10,480 --> 00:12:14,480
is

00:12:10,880 --> 00:12:17,839
behind the u so the first u is

00:12:14,480 --> 00:12:20,959
standard um standard u

00:12:17,839 --> 00:12:22,160
um with ascii value of 117 and the

00:12:20,959 --> 00:12:23,920
second one is

00:12:22,160 --> 00:12:26,560
there then comes this combining the

00:12:23,920 --> 00:12:29,040
resist that is of the category m

00:12:26,560 --> 00:12:29,680
n which is means a combining character

00:12:29,040 --> 00:12:31,920
and

00:12:29,680 --> 00:12:33,360
also this is not an error but you see

00:12:31,920 --> 00:12:34,320
that the whole line is a little bit

00:12:33,360 --> 00:12:36,560
offset uh

00:12:34,320 --> 00:12:38,079
to the left uh this means that this

00:12:36,560 --> 00:12:41,120
combining the resist doesn't have

00:12:38,079 --> 00:12:44,000
a width and if you can

00:12:41,120 --> 00:12:45,279
convert between those two versions like

00:12:44,000 --> 00:12:48,639
the normalized and the

00:12:45,279 --> 00:12:49,360
normalized um and between the normal

00:12:48,639 --> 00:12:51,279
forms

00:12:49,360 --> 00:12:53,360
um and they will not be the same so it

00:12:51,279 --> 00:12:55,680
means that if you have a lot of text

00:12:53,360 --> 00:12:56,639
try to normalize them or normalize them

00:12:55,680 --> 00:12:59,760
to one

00:12:56,639 --> 00:13:01,760
form and only then compare them

00:12:59,760 --> 00:13:03,440
um with this combining theories and

00:13:01,760 --> 00:13:07,519
there are plenty of combining characters

00:13:03,440 --> 00:13:11,279
you can do some fun stuff uh you can

00:13:07,519 --> 00:13:12,800
put more uh characters after each other

00:13:11,279 --> 00:13:14,480
and then you can get something like this

00:13:12,800 --> 00:13:15,440
this is actual listing overflow answer

00:13:14,480 --> 00:13:19,120
to the question

00:13:15,440 --> 00:13:20,639
how to use uh how to parse html with

00:13:19,120 --> 00:13:21,920
regular expressions so you see at the

00:13:20,639 --> 00:13:23,680
end there are some characters with

00:13:21,920 --> 00:13:27,360
plenty plenty plenty of

00:13:23,680 --> 00:13:29,839
combining characters alphabetic sorting

00:13:27,360 --> 00:13:31,040
that's not so easy if you just sort the

00:13:29,839 --> 00:13:32,959
standard titan sort

00:13:31,040 --> 00:13:35,279
using the standard python sort you will

00:13:32,959 --> 00:13:37,519
not get the alphabetical order

00:13:35,279 --> 00:13:39,120
because you see that there are some uh

00:13:37,519 --> 00:13:39,680
uppercase lowercase then you have some

00:13:39,120 --> 00:13:42,959
other

00:13:39,680 --> 00:13:44,399
letters uh what's the new like latin one

00:13:42,959 --> 00:13:46,320
letters then there is some latin tubes

00:13:44,399 --> 00:13:47,760
like this sure and then the sharpest

00:13:46,320 --> 00:13:48,240
comes at the end because it has a really

00:13:47,760 --> 00:13:52,240
high

00:13:48,240 --> 00:13:52,240
unicode value

00:13:52,399 --> 00:13:56,000
you can use local so you start local

00:13:55,040 --> 00:13:57,839
with the german

00:13:56,000 --> 00:13:59,120
for example and then you sort this

00:13:57,839 --> 00:14:01,680
characters and we will get the

00:13:59,120 --> 00:14:03,760
unload between a and b but if your

00:14:01,680 --> 00:14:06,639
locale is for example swedish

00:14:03,760 --> 00:14:08,160
then it will be uh different because in

00:14:06,639 --> 00:14:10,560
swedish all the umlauts are at

00:14:08,160 --> 00:14:12,079
n and there are some other exceptions

00:14:10,560 --> 00:14:15,839
for example in hungarian

00:14:12,079 --> 00:14:18,399
the cs pronounced as che is

00:14:15,839 --> 00:14:19,839
extra letter between c and d in the

00:14:18,399 --> 00:14:21,600
chicken slovak we have plenty of

00:14:19,839 --> 00:14:23,680
characters with currents that we put

00:14:21,600 --> 00:14:26,160
just behind the respective letter

00:14:23,680 --> 00:14:27,040
there is ch pronounced as which is

00:14:26,160 --> 00:14:29,519
between h and

00:14:27,040 --> 00:14:30,079
i and for example in french they have

00:14:29,519 --> 00:14:33,199
even more

00:14:30,079 --> 00:14:33,760
rules it means that they con they sort

00:14:33,199 --> 00:14:36,160
everything

00:14:33,760 --> 00:14:37,120
according to ascii but if there are

00:14:36,160 --> 00:14:40,720
exons they

00:14:37,120 --> 00:14:42,880
sort them from the end of uh the word so

00:14:40,720 --> 00:14:46,639
first they sort the last syllable and

00:14:42,880 --> 00:14:48,800
then the penultimate and then and so on

00:14:46,639 --> 00:14:49,920
so there are plenty of rules the problem

00:14:48,800 --> 00:14:52,959
with locale is

00:14:49,920 --> 00:14:54,880
if you do that in your library then the

00:14:52,959 --> 00:14:56,800
local of the whole process will be

00:14:54,880 --> 00:14:58,880
changed this means that

00:14:56,800 --> 00:15:00,079
if you have some multilingual program

00:14:58,880 --> 00:15:02,480
that has to

00:15:00,079 --> 00:15:03,360
have the input of several users at the

00:15:02,480 --> 00:15:05,199
same time such as

00:15:03,360 --> 00:15:06,800
web server and you switch the local the

00:15:05,199 --> 00:15:10,000
whole time it will

00:15:06,800 --> 00:15:12,000
there will cause um

00:15:10,000 --> 00:15:13,360
so that's why there is this icu that we

00:15:12,000 --> 00:15:14,880
have used already to convert the

00:15:13,360 --> 00:15:18,000
lowercase application storage

00:15:14,880 --> 00:15:21,360
um that you can use to sort something

00:15:18,000 --> 00:15:23,680
uh without changing the of the system

00:15:21,360 --> 00:15:24,800
i have read there are some

00:15:23,680 --> 00:15:27,680
recommendations to use

00:15:24,800 --> 00:15:28,399
pius usca also some unicode collocation

00:15:27,680 --> 00:15:31,519
algorithm

00:15:28,399 --> 00:15:32,560
calculator algorithm um the difference

00:15:31,519 --> 00:15:35,680
between these two is

00:15:32,560 --> 00:15:36,240
the pi uca doesn't define which letter

00:15:35,680 --> 00:15:38,720
which

00:15:36,240 --> 00:15:40,240
locate or which language it uses it has

00:15:38,720 --> 00:15:43,279
a great database uh

00:15:40,240 --> 00:15:47,199
included that and it's announced

00:15:43,279 --> 00:15:47,199
that it works very well for

00:15:47,759 --> 00:15:54,880
for characters outside of english um

00:15:51,199 --> 00:15:58,399
yes you can use it if you only need some

00:15:54,880 --> 00:15:58,720
english list sorted list and you want to

00:15:58,399 --> 00:16:01,839
have

00:15:58,720 --> 00:16:04,160
those other characters included at

00:16:01,839 --> 00:16:05,600
some not so bad position but don't use

00:16:04,160 --> 00:16:09,279
this if you have

00:16:05,600 --> 00:16:11,440
pure germans swedish or czech texts

00:16:09,279 --> 00:16:13,519
because it doesn't use the specific

00:16:11,440 --> 00:16:14,880
sorting of the specific language or that

00:16:13,519 --> 00:16:18,079
case i would prefer to use

00:16:14,880 --> 00:16:20,480
icu at the end

00:16:18,079 --> 00:16:22,160
unicode regular expressions so let's

00:16:20,480 --> 00:16:25,360
have a look at this text there is newton

00:16:22,160 --> 00:16:25,920
lincoln uh space one two three and i

00:16:25,360 --> 00:16:29,600
want to

00:16:25,920 --> 00:16:31,920
extract the word linking

00:16:29,600 --> 00:16:33,519
inside of this so all correct all

00:16:31,920 --> 00:16:34,560
characters between a z uppercase

00:16:33,519 --> 00:16:37,360
lowercase

00:16:34,560 --> 00:16:37,839
it will split it will ignore this umlaut

00:16:37,360 --> 00:16:40,720
and will

00:16:37,839 --> 00:16:41,600
return to like two words like that it's

00:16:40,720 --> 00:16:44,240
wrong

00:16:41,600 --> 00:16:45,839
if i say i want uh backlash w so all

00:16:44,240 --> 00:16:47,680
alpha numerical characters

00:16:45,839 --> 00:16:49,759
the there are also numeric characters so

00:16:47,680 --> 00:16:50,880
i will return to return also the one two

00:16:49,759 --> 00:16:53,759
three that i want to

00:16:50,880 --> 00:16:54,320
want to have and in that case we will

00:16:53,759 --> 00:16:57,440
have to

00:16:54,320 --> 00:16:58,800
uh use the regex it is a third-party uh

00:16:57,440 --> 00:17:01,920
library that works

00:16:58,800 --> 00:17:05,199
100 like the standard re works

00:17:01,920 --> 00:17:07,039
and only has a few functions extra

00:17:05,199 --> 00:17:08,799
and in this case with backslash p you

00:17:07,039 --> 00:17:10,799
can define any code characters

00:17:08,799 --> 00:17:12,079
that belong to some category and you

00:17:10,799 --> 00:17:15,360
have seen at the beginning this

00:17:12,079 --> 00:17:17,360
capital l means uh that it is a letter

00:17:15,360 --> 00:17:19,439
and you can also define something like l

00:17:17,360 --> 00:17:20,400
u for uppercase letters l for lowercase

00:17:19,439 --> 00:17:21,839
letters and so on

00:17:20,400 --> 00:17:23,919
you have to see that at the beginning in

00:17:21,839 --> 00:17:26,799
the list of categories and in that case

00:17:23,919 --> 00:17:26,799
we get the word

00:17:27,039 --> 00:17:30,080
hey i came here for python but i say for

00:17:28,799 --> 00:17:31,840
the names so

00:17:30,080 --> 00:17:34,240
this was the python part now let's have

00:17:31,840 --> 00:17:38,480
a look at the names

00:17:34,240 --> 00:17:40,080
um if i were with you in the

00:17:38,480 --> 00:17:41,679
normal offline conference i would just

00:17:40,080 --> 00:17:44,000
ask raise your hand who

00:17:41,679 --> 00:17:44,720
can write their first and last name like

00:17:44,000 --> 00:17:46,240
this

00:17:44,720 --> 00:17:48,480
i don't know how many of you can write

00:17:46,240 --> 00:17:51,039
it uh later in the discussion

00:17:48,480 --> 00:17:53,120
but probably okay i can tell my first

00:17:51,039 --> 00:17:54,720
name miroslav my last name should be

00:17:53,120 --> 00:17:56,240
but maybe some of you have something

00:17:54,720 --> 00:17:58,640
like a middle name

00:17:56,240 --> 00:17:59,520
or something petronemic or metronomics

00:17:58,640 --> 00:18:01,919
name in

00:17:59,520 --> 00:18:03,440
like portuguese or in swedish sorry in

00:18:01,919 --> 00:18:06,080
spanish

00:18:03,440 --> 00:18:07,039
there is last name first name in many

00:18:06,080 --> 00:18:10,160
asian

00:18:07,039 --> 00:18:12,000
languages or in hungarian

00:18:10,160 --> 00:18:14,960
there is name number if we have some

00:18:12,000 --> 00:18:17,280
popes or queens or things here

00:18:14,960 --> 00:18:19,280
or there is some simple name but there

00:18:17,280 --> 00:18:22,160
is also something like the name of the

00:18:19,280 --> 00:18:23,520
of the father uh and that you are a son

00:18:22,160 --> 00:18:26,000
or a daughter of the fathers or

00:18:23,520 --> 00:18:28,960
for example in icelandic if your name is

00:18:26,000 --> 00:18:28,960
sigur johansson

00:18:29,919 --> 00:18:34,720
it means that you have to use or

00:18:33,200 --> 00:18:36,559
work with these names a little bit

00:18:34,720 --> 00:18:38,240
differently because

00:18:36,559 --> 00:18:40,120
sigur johansson doesn't mean that it's a

00:18:38,240 --> 00:18:43,120
mystery handsome there is no mystery

00:18:40,120 --> 00:18:43,120
handsome

00:18:44,559 --> 00:18:48,559
and you will find them in the phone list

00:18:47,280 --> 00:18:51,679
phone book you will find them as

00:18:48,559 --> 00:18:54,320
s like and not

00:18:51,679 --> 00:18:54,960
as j because they are they don't sort

00:18:54,320 --> 00:18:58,160
their names

00:18:54,960 --> 00:18:59,840
according to this petronas name by the

00:18:58,160 --> 00:19:03,520
name of their phone

00:18:59,840 --> 00:19:03,520
of course there are plenty of phones

00:19:04,160 --> 00:19:09,600
and so on um in different languages

00:19:07,520 --> 00:19:11,200
and many times you just don't know

00:19:09,600 --> 00:19:12,799
whether to put it together with the last

00:19:11,200 --> 00:19:13,280
name or first name or somewhere in the

00:19:12,799 --> 00:19:16,240
beginning

00:19:13,280 --> 00:19:16,880
how to solve them yeah of course some

00:19:16,240 --> 00:19:20,320
vectors

00:19:16,880 --> 00:19:23,280
in some languages the doctor became

00:19:20,320 --> 00:19:24,320
the part of your last name so how to do

00:19:23,280 --> 00:19:26,080
it correctly

00:19:24,320 --> 00:19:27,840
actually if someone if you ask for a

00:19:26,080 --> 00:19:29,760
name just ask for the full name

00:19:27,840 --> 00:19:31,360
right let someone write their full name

00:19:29,760 --> 00:19:33,760
and then you can ask how they

00:19:31,360 --> 00:19:35,360
should call you so for example mr t he

00:19:33,760 --> 00:19:36,240
says oh my first name is mister my

00:19:35,360 --> 00:19:39,679
middle name is

00:19:36,240 --> 00:19:43,120
dot or period and my last name is t

00:19:39,679 --> 00:19:44,000
um and then even if you can write it

00:19:43,120 --> 00:19:46,720
correctly

00:19:44,000 --> 00:19:48,400
you will sometimes get uh error message

00:19:46,720 --> 00:19:50,160
like hey please enter characters from

00:19:48,400 --> 00:19:53,200
the european character set only

00:19:50,160 --> 00:19:57,200
this happened in germany my last name

00:19:53,200 --> 00:20:01,679
is not far away from germany

00:19:57,200 --> 00:20:05,440
um sorry what's european character said

00:20:01,679 --> 00:20:07,679
and the same service a few pages later

00:20:05,440 --> 00:20:09,919
please enter a full valid name they

00:20:07,679 --> 00:20:12,559
didn't want to accept my name

00:20:09,919 --> 00:20:14,480
and my name is valid so the names of

00:20:12,559 --> 00:20:16,880
people cannot be made

00:20:14,480 --> 00:20:18,799
so if you work with names in some forms

00:20:16,880 --> 00:20:20,559
don't assume anything

00:20:18,799 --> 00:20:22,240
don't put random limit on their length

00:20:20,559 --> 00:20:22,799
minimum maximum there is no minimum

00:20:22,240 --> 00:20:25,679
there is no

00:20:22,799 --> 00:20:26,960
maximum so for example tp lunchtroom uh

00:20:25,679 --> 00:20:28,880
logs uh

00:20:26,960 --> 00:20:31,600
her name is like this this or a

00:20:28,880 --> 00:20:33,120
character regardless

00:20:31,600 --> 00:20:34,799
this was some german minister a few

00:20:33,120 --> 00:20:36,960
years ago his name

00:20:34,799 --> 00:20:38,159
even appeared on wikipedia with a typo

00:20:36,960 --> 00:20:41,440
and even he didn't

00:20:38,159 --> 00:20:43,039
see that don't use stop words so if

00:20:41,440 --> 00:20:45,360
there it's um

00:20:43,039 --> 00:20:46,080
stop word or like rude words in your

00:20:45,360 --> 00:20:47,760
language

00:20:46,080 --> 00:20:49,200
it can be a perfect word in another

00:20:47,760 --> 00:20:52,320
language

00:20:49,200 --> 00:20:54,559
the all family members don't have

00:20:52,320 --> 00:20:55,520
necessarily the same name so for example

00:20:54,559 --> 00:20:58,159
all the male

00:20:55,520 --> 00:20:59,120
uh members of my family are shelby or

00:20:58,159 --> 00:21:02,960
the male

00:20:59,120 --> 00:21:04,480
female members of my family are shiva

00:21:02,960 --> 00:21:06,159
don't assume anything different

00:21:04,480 --> 00:21:07,840
transcription from non-latin alphabet so

00:21:06,159 --> 00:21:08,880
for example if you have the russian name

00:21:07,840 --> 00:21:11,120
checho

00:21:08,880 --> 00:21:13,039
in all your every european languages

00:21:11,120 --> 00:21:15,200
types it a little bit differently

00:21:13,039 --> 00:21:16,159
and other way around so for example i

00:21:15,200 --> 00:21:17,919
was in russia

00:21:16,159 --> 00:21:20,559
twice with the same passport and i got

00:21:17,919 --> 00:21:23,760
two visa and both times my last name was

00:21:20,559 --> 00:21:26,880
typed differently in this alphabet or

00:21:23,760 --> 00:21:26,880
in chinese the same

00:21:27,039 --> 00:21:30,880
if you use something like maiden name or

00:21:29,200 --> 00:21:32,799
nay know that then they change

00:21:30,880 --> 00:21:34,400
differently those two

00:21:32,799 --> 00:21:36,159
uh one letter name is probably not an

00:21:34,400 --> 00:21:38,960
initial so bin will be uh

00:21:36,159 --> 00:21:40,480
motherboard that b is not a variation so

00:21:38,960 --> 00:21:44,000
actually you should accept almost

00:21:40,480 --> 00:21:46,720
all printable characters

00:21:44,000 --> 00:21:47,200
um hello my name is mr noah my name

00:21:46,720 --> 00:21:48,960
makes

00:21:47,200 --> 00:21:50,640
me invisible to computers an article i

00:21:48,960 --> 00:21:51,360
don't understand how someone can program

00:21:50,640 --> 00:21:54,400
something that

00:21:51,360 --> 00:21:56,480
doesn't accept the last name

00:21:54,400 --> 00:21:57,520
or the same with this bobby little bobby

00:21:56,480 --> 00:22:01,039
tables

00:21:57,520 --> 00:22:04,880
please don't do that um

00:22:01,039 --> 00:22:07,679
yeah the the names of the streets and

00:22:04,880 --> 00:22:08,960
uh cities and so on um the most

00:22:07,679 --> 00:22:11,039
widespread name of

00:22:08,960 --> 00:22:12,159
uh street in germany is of course

00:22:11,039 --> 00:22:13,679
unbunched

00:22:12,159 --> 00:22:17,039
so one-way street you see it almost

00:22:13,679 --> 00:22:19,760
everywhere now um

00:22:17,039 --> 00:22:20,320
how in german this strasse like street

00:22:19,760 --> 00:22:23,919
is with

00:22:20,320 --> 00:22:27,280
the sharp s you will find a lot of

00:22:23,919 --> 00:22:29,840
american lists of german companies

00:22:27,280 --> 00:22:31,520
with this bee capital and instead of

00:22:29,840 --> 00:22:33,840
russia faces

00:22:31,520 --> 00:22:35,679
so the names of the places or somewhere

00:22:33,840 --> 00:22:40,159
in

00:22:35,679 --> 00:22:43,360
scandinavia indonesia

00:22:40,159 --> 00:22:45,280
in france and then if the hint question

00:22:43,360 --> 00:22:47,039
is what is your mother's maiden name

00:22:45,280 --> 00:22:48,320
at least six characters or they ask you

00:22:47,039 --> 00:22:50,480
for your place of birth

00:22:48,320 --> 00:22:51,679
at least six characters no it doesn't

00:22:50,480 --> 00:22:53,360
work like that

00:22:51,679 --> 00:22:56,320
or on the other hand you have places

00:22:53,360 --> 00:22:56,320
like hanval buchwinger

00:22:56,480 --> 00:23:03,679
that are a little bit longer or crunchy

00:23:00,559 --> 00:23:05,120
somewhere in poland or sometimes you

00:23:03,679 --> 00:23:06,960
even don't take an interest because you

00:23:05,120 --> 00:23:09,520
just describe very well where you want

00:23:06,960 --> 00:23:11,280
to get your own

00:23:09,520 --> 00:23:12,960
there is a long list of falsehoods

00:23:11,280 --> 00:23:14,720
programmers believe about names i'm not

00:23:12,960 --> 00:23:15,840
going to read everything have a look at

00:23:14,720 --> 00:23:19,120
that

00:23:15,840 --> 00:23:20,080
so if you are working with the names of

00:23:19,120 --> 00:23:22,159
people

00:23:20,080 --> 00:23:24,559
i now ignore gdpr everything i

00:23:22,159 --> 00:23:26,559
programmatically respect their names

00:23:24,559 --> 00:23:28,000
and don't break the locals or use the

00:23:26,559 --> 00:23:30,960
icu

00:23:28,000 --> 00:23:32,559
uh convert hamburger principle com

00:23:30,960 --> 00:23:34,400
convert from by system as soon as

00:23:32,559 --> 00:23:36,080
possible and convert back to bytes as

00:23:34,400 --> 00:23:38,080
late as possible

00:23:36,080 --> 00:23:39,520
utf-8 is school python's three is cool

00:23:38,080 --> 00:23:40,880
because two your spike is three and you

00:23:39,520 --> 00:23:43,240
df-8

00:23:40,880 --> 00:23:44,480
if you tell your user because of your

00:23:43,240 --> 00:23:47,600
spitefulness

00:23:44,480 --> 00:23:50,000
ignorance lazyness or something that

00:23:47,600 --> 00:23:51,760
their name is invalid it is not called

00:23:50,000 --> 00:23:54,240
there is a twitter account

00:23:51,760 --> 00:23:55,760
your name is dalit it's not is invalid

00:23:54,240 --> 00:23:56,559
it is your name is valid because there

00:23:55,760 --> 00:23:59,600
is a limit on

00:23:56,559 --> 00:24:02,799
the character's twitter

00:23:59,600 --> 00:24:05,360
um that will maybe where

00:24:02,799 --> 00:24:05,919
your case can appear if you do something

00:24:05,360 --> 00:24:08,159
like that

00:24:05,919 --> 00:24:10,640
don't do that be nice that's all thank

00:24:08,159 --> 00:24:10,640
you very much

00:24:16,720 --> 00:24:23,919
thank you very much are there

00:24:20,480 --> 00:24:26,240
any questions i see there is a first

00:24:23,919 --> 00:24:28,960
question unfortunately i can't read it

00:24:26,240 --> 00:24:32,720
it's probably the wrong encoding

00:24:28,960 --> 00:24:36,080
so while you can type in questions

00:24:32,720 --> 00:24:39,760
i i do actually have a question um

00:24:36,080 --> 00:24:40,799
at the moment i'm always using utf-8 for

00:24:39,760 --> 00:24:43,760
anything

00:24:40,799 --> 00:24:45,200
everything actually and is there a

00:24:43,760 --> 00:24:49,039
reason not to use

00:24:45,200 --> 00:24:52,240
utf-8 and when and why and

00:24:49,039 --> 00:24:54,080
yeah if if you control both ends

00:24:52,240 --> 00:24:56,320
of the communication or you have some

00:24:54,080 --> 00:24:57,600
power to do that use utf-8

00:24:56,320 --> 00:24:59,600
of course there are cases where you can

00:24:57,600 --> 00:25:00,000
use it if you are programming some

00:24:59,600 --> 00:25:01,919
special

00:25:00,000 --> 00:25:03,360
printer or something that doesn't

00:25:01,919 --> 00:25:04,880
support

00:25:03,360 --> 00:25:07,520
it but if you control both ends of

00:25:04,880 --> 00:25:07,520
communication

00:25:10,159 --> 00:25:16,480
okay any more questions

00:25:14,080 --> 00:25:16,480
you can

00:25:18,559 --> 00:25:23,440
you can click this q and a button down

00:25:21,200 --> 00:25:26,720
on your screen if you are in zoom

00:25:23,440 --> 00:25:28,880
and ask your questions there

00:25:26,720 --> 00:25:28,880
my

00:25:29,760 --> 00:25:33,440
yes there is a question coming in no

00:25:31,600 --> 00:25:37,039
don't worry i read the questions for you

00:25:33,440 --> 00:25:39,039
okay um johnny zhang is asking

00:25:37,039 --> 00:25:40,240
some older chinese software is still

00:25:39,039 --> 00:25:42,960
using big

00:25:40,240 --> 00:25:44,960
five so what are your thoughts about

00:25:42,960 --> 00:25:49,039
that

00:25:44,960 --> 00:25:51,520
override it if you can rewrite it okay

00:25:49,039 --> 00:25:51,520
why that

00:25:53,360 --> 00:26:00,320
what's the major drawback of big five

00:25:56,559 --> 00:26:03,679
i've never used that i'm

00:26:00,320 --> 00:26:04,000
so but sometimes it would be nice to

00:26:03,679 --> 00:26:06,559
have

00:26:04,000 --> 00:26:08,840
one encoding that works everywhere

00:26:06,559 --> 00:26:11,520
because you have also

00:26:08,840 --> 00:26:14,799
combined documents

00:26:11,520 --> 00:26:17,600
in my case i have also used some chinese

00:26:14,799 --> 00:26:18,880
characters within the european and syria

00:26:17,600 --> 00:26:20,240
league and so on so

00:26:18,880 --> 00:26:21,679
it's nice to have if you want to have

00:26:20,240 --> 00:26:22,840
muttling or the cameras anything anyway

00:26:21,679 --> 00:26:25,840
you need something that works for

00:26:22,840 --> 00:26:25,840
everyone

00:26:26,240 --> 00:26:30,640
okay so are there more questions

00:26:31,200 --> 00:26:38,240
you can always ask miro later in

00:26:34,559 --> 00:26:41,200
discord just um press

00:26:38,240 --> 00:26:42,720
command and k in discord and then you

00:26:41,200 --> 00:26:45,520
see a window and you can

00:26:42,720 --> 00:26:46,799
enter invalid there and then you will

00:26:45,520 --> 00:26:50,159
see the channel

00:26:46,799 --> 00:26:53,360
talk your name is invalid and there

00:26:50,159 --> 00:26:55,039
are you get already got big applause

00:26:53,360 --> 00:26:58,640
there

00:26:55,039 --> 00:27:02,080
um really great talk

00:26:58,640 --> 00:27:05,200
poignant and entertaining so

00:27:02,080 --> 00:27:08,960
while other people are maybe

00:27:05,200 --> 00:27:11,840
asking more questions last chance

00:27:08,960 --> 00:27:13,200
if not um please go oh even more

00:27:11,840 --> 00:27:15,520
applause in the channel

00:27:13,200 --> 00:27:17,200
so if not please mirror go to the

00:27:15,520 --> 00:27:19,039
channel

00:27:17,200 --> 00:27:20,320
your name is invalid and maybe there are

00:27:19,039 --> 00:27:24,240
more questions

00:27:20,320 --> 00:27:27,360
there and in the meantime

00:27:24,240 --> 00:27:30,799
we maybe have time

00:27:27,360 --> 00:27:30,799
for another advertisement

00:27:32,840 --> 00:27:46,799
okay bye thank you

00:27:36,000 --> 00:27:46,799

YouTube URL: https://www.youtube.com/watch?v=IuZBTjaphsY


