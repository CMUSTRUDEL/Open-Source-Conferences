Title: Eran Friedman - Boosting simulation performance with Python
Publication date: 2020-09-21
Playlist: EuroPython 2020
Description: 
	"Boosting simulation performance with Python
EuroPython 2020 - Talk - 2020-07-23 - Parrot Data Science
Online

By Eran Friedman

Our product uses a fleet of real (not virtual) robots to perform different tasks in a fulfillment warehouse. Simulation is an essential tool in this kind of product: it allows to perform regression tests and test new features without the need for real and expensive hardware, to compare the impact of different algorithms and optimizations, to inject failures, and more.

Tasks performed by physical robots take time (movement over the warehouse, box lifting, etc.), but in simulation, where virtual robots are used, there is no need to wait all that time. I will describe our implementation of the Discrete-Event Simulation approach which allows us to simulate hours of real-life in minutes.

Shortening simulation time improves the development process by providing faster feedback to developers and quicker CI and testing cycles. Another powerful advantage is a more deterministic simulation - using this approach, each component in the system gets equal opportunity (CPU time) in each time tick, which is not affected by the underlying machine that the simulation is running on. Also, it is possible to simulate any date and hour easily, and by that we wouldn't panic before the ""Y2K bug"".

I will elaborate on some challenges we encountered: time leak of event-driven components, differences between dev and production environments and running a distributed simulation due to the transition to microservices.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2020.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:06,480 --> 00:00:12,160
first on the list we have

00:00:08,400 --> 00:00:14,240
um aaron friedman uh who

00:00:12,160 --> 00:00:15,360
uh just finished his master's of science

00:00:14,240 --> 00:00:17,279
computer science in the field of

00:00:15,360 --> 00:00:20,480
computational geometry

00:00:17,279 --> 00:00:23,439
and uh he is a

00:00:20,480 --> 00:00:25,279
python developer working at fabric

00:00:23,439 --> 00:00:26,720
formerly known as common sense robotics

00:00:25,279 --> 00:00:28,960
involved in system architecture and

00:00:26,720 --> 00:00:30,880
development and he's going to be talking

00:00:28,960 --> 00:00:32,640
about boosting simulation performance

00:00:30,880 --> 00:00:36,480
with python

00:00:32,640 --> 00:00:37,920
so uh uh iran thank you for uh joining

00:00:36,480 --> 00:00:39,920
us

00:00:37,920 --> 00:00:41,600
thank you for having me thank you for

00:00:39,920 --> 00:00:44,960
the introduction

00:00:41,600 --> 00:00:46,960
so where are you streaming from sorry

00:00:44,960 --> 00:00:50,559
where are you streaming from oh okay

00:00:46,960 --> 00:00:52,800
einstein from tel aviv is that

00:00:50,559 --> 00:00:53,840
nice yeah excellent how's the weather

00:00:52,800 --> 00:00:58,399
there

00:00:53,840 --> 00:01:01,520
ah really hot really it's cool yeah

00:00:58,399 --> 00:01:02,960
excellent well i will turn this over to

00:01:01,520 --> 00:01:13,840
you then

00:01:02,960 --> 00:01:13,840
and uh okay thank you very much

00:01:14,159 --> 00:01:17,680
okay so again everyone and thank you for

00:01:16,400 --> 00:01:20,400
being here

00:01:17,680 --> 00:01:22,640
uh you're probably here because you run

00:01:20,400 --> 00:01:25,200
any kind of simulation or integration

00:01:22,640 --> 00:01:27,200
test at your work

00:01:25,200 --> 00:01:29,280
now how many of you would like to spend

00:01:27,200 --> 00:01:31,280
less time on waiting for them to finish

00:01:29,280 --> 00:01:34,159
and to have more time for coding or for

00:01:31,280 --> 00:01:36,479
solving bugs if you write some

00:01:34,159 --> 00:01:37,840
so i'm glad you're here today you will

00:01:36,479 --> 00:01:39,920
see how you can use the

00:01:37,840 --> 00:01:41,759
discrete event simulation approach to

00:01:39,920 --> 00:01:43,840
simulate your system

00:01:41,759 --> 00:01:45,600
and now how and how it will allow you to

00:01:43,840 --> 00:01:49,280
simulate hours of your system

00:01:45,600 --> 00:01:49,280
in minutes or even in seconds

00:01:49,439 --> 00:01:52,960
so before i talk about our annual

00:01:52,079 --> 00:01:54,880
simulation

00:01:52,960 --> 00:01:56,719
let me tell you what we do in fabric and

00:01:54,880 --> 00:01:58,719
what we simulate

00:01:56,719 --> 00:01:59,920
before i show you the video i need to

00:01:58,719 --> 00:02:02,240
switch the shelling

00:01:59,920 --> 00:02:02,240
mode

00:02:04,560 --> 00:02:10,720
okay in fabric we

00:02:08,160 --> 00:02:11,920
build a fulfillment warehouse for online

00:02:10,720 --> 00:02:14,319
orders

00:02:11,920 --> 00:02:15,920
most of the work is done by robots we

00:02:14,319 --> 00:02:18,480
have two types of

00:02:15,920 --> 00:02:21,040
robots the first type is called leaf

00:02:18,480 --> 00:02:23,200
robot you can see it now in the video

00:02:21,040 --> 00:02:24,879
and the second type is called ground

00:02:23,200 --> 00:02:27,599
robot which moves on the

00:02:24,879 --> 00:02:29,840
ground on the floor together they

00:02:27,599 --> 00:02:30,800
cooperate and help us to fulfill the

00:02:29,840 --> 00:02:33,200
orders

00:02:30,800 --> 00:02:35,280
and it works like that the lift robot

00:02:33,200 --> 00:02:35,680
takes notes from the shelving units

00:02:35,280 --> 00:02:37,920
would

00:02:35,680 --> 00:02:38,879
put the tote on the ground robot the

00:02:37,920 --> 00:02:40,959
ground robot

00:02:38,879 --> 00:02:42,560
brings the toad into picking stations

00:02:40,959 --> 00:02:45,760
where the items are picked and later

00:02:42,560 --> 00:02:45,760
delivered to the customers

00:02:45,840 --> 00:02:51,840
just exit the mode

00:02:54,480 --> 00:03:01,040
all right so my name is iran

00:02:58,080 --> 00:03:02,000
i work at fabric for about four years

00:03:01,040 --> 00:03:03,840
now i mainly

00:03:02,000 --> 00:03:06,159
focus on the development of this cute

00:03:03,840 --> 00:03:07,440
robot but before that i was involved in

00:03:06,159 --> 00:03:10,080
different areas in the

00:03:07,440 --> 00:03:10,959
system one of them is the simulation

00:03:10,080 --> 00:03:14,560
infrastructure

00:03:10,959 --> 00:03:14,560
which i will present to you today

00:03:15,200 --> 00:03:19,920
we start by seeing why simulations are

00:03:17,599 --> 00:03:22,400
so important

00:03:19,920 --> 00:03:24,239
then we'll see how to use the discrete

00:03:22,400 --> 00:03:26,239
event simulation approach and how to do

00:03:24,239 --> 00:03:28,000
it in python

00:03:26,239 --> 00:03:29,920
then i'll talk about some challenges we

00:03:28,000 --> 00:03:32,159
encountered and how we

00:03:29,920 --> 00:03:33,040
deal with them and finally how to

00:03:32,159 --> 00:03:35,440
distribute

00:03:33,040 --> 00:03:38,640
the multi-threaded simulation into a

00:03:35,440 --> 00:03:38,640
multi-process simulation

00:03:38,959 --> 00:03:43,920
so first what exactly we simulate so

00:03:41,760 --> 00:03:45,599
usually the term simulation means a tool

00:03:43,920 --> 00:03:49,280
that imitates the behavior of

00:03:45,599 --> 00:03:51,920
a system in our case it is not exactly

00:03:49,280 --> 00:03:53,280
the case or let's take a look in this

00:03:51,920 --> 00:03:56,080
very simplified

00:03:53,280 --> 00:03:56,720
door of our system we have the back end

00:03:56,080 --> 00:03:59,840
which is

00:03:56,720 --> 00:04:00,560
which is a pure software it manages the

00:03:59,840 --> 00:04:02,959
activity of

00:04:00,560 --> 00:04:03,680
the system to manage the orders from

00:04:02,959 --> 00:04:06,799
clients

00:04:03,680 --> 00:04:08,879
the stock the motion of the robots it

00:04:06,799 --> 00:04:11,200
sends commands to the robot and receives

00:04:08,879 --> 00:04:13,280
telemeters back from the robot

00:04:11,200 --> 00:04:16,799
so in this simulation tool that i will

00:04:13,280 --> 00:04:18,959
talk about we simulate only the robots

00:04:16,799 --> 00:04:20,560
we run the system the back-end just as

00:04:18,959 --> 00:04:22,560
it runs in production but

00:04:20,560 --> 00:04:24,160
instead of communicating with the real

00:04:22,560 --> 00:04:26,560
robot it communicates with virtual

00:04:24,160 --> 00:04:28,639
robots

00:04:26,560 --> 00:04:30,639
this is the decoupling of software and

00:04:28,639 --> 00:04:32,560
hardware is extremely important today

00:04:30,639 --> 00:04:34,720
when we all work from home due to the

00:04:32,560 --> 00:04:38,960
corona virus and the

00:04:34,720 --> 00:04:42,080
access to the order is very limited

00:04:38,960 --> 00:04:44,160
this tool has several more usages first

00:04:42,080 --> 00:04:46,400
it is used as a testing tool

00:04:44,160 --> 00:04:48,000
when developer write new code as long as

00:04:46,400 --> 00:04:51,280
the code doesn't turn on the

00:04:48,000 --> 00:04:54,560
robot then it is one of the options to

00:04:51,280 --> 00:04:56,320
test the code it is also used as our

00:04:54,560 --> 00:04:59,759
as part of our regression test in the

00:04:56,320 --> 00:04:59,759
continuous integration system

00:04:59,919 --> 00:05:03,520
also in a complex system it's difficult

00:05:02,080 --> 00:05:06,000
to know how

00:05:03,520 --> 00:05:06,639
a new algorithm or optimization will

00:05:06,000 --> 00:05:09,520
affect the

00:05:06,639 --> 00:05:10,000
system the kpis of the system so this is

00:05:09,520 --> 00:05:12,639
the place

00:05:10,000 --> 00:05:15,280
to evaluate it before running it in

00:05:12,639 --> 00:05:15,280
production

00:05:16,400 --> 00:05:19,840
again robots and the other is very

00:05:18,479 --> 00:05:22,400
limited and

00:05:19,840 --> 00:05:24,160
very expensive and this decoupling of

00:05:22,400 --> 00:05:25,919
software and double allows us to run

00:05:24,160 --> 00:05:28,320
as many simulations as we need on the

00:05:25,919 --> 00:05:28,320
cloud

00:05:29,199 --> 00:05:33,120
we use this tool to evaluate the new

00:05:31,440 --> 00:05:33,840
warehouse before investing money in

00:05:33,120 --> 00:05:36,639
construction

00:05:33,840 --> 00:05:37,280
we can run the system on a new layout

00:05:36,639 --> 00:05:39,280
and see

00:05:37,280 --> 00:05:41,360
what kpis we can reach and how many

00:05:39,280 --> 00:05:43,840
robots are needed to reach this kpi for

00:05:41,360 --> 00:05:43,840
example

00:05:44,639 --> 00:05:49,120
in simulation it is very easy to inject

00:05:46,880 --> 00:05:50,400
failures in the robots and by that to

00:05:49,120 --> 00:05:53,840
improve the availability and the

00:05:50,400 --> 00:05:53,840
robustness of the system

00:05:56,400 --> 00:06:00,080
we also have an integration center in

00:05:59,039 --> 00:06:02,479
our offices

00:06:00,080 --> 00:06:03,840
an integration lab in our offices where

00:06:02,479 --> 00:06:07,120
we can test the

00:06:03,840 --> 00:06:09,680
code with the real robots but it's not

00:06:07,120 --> 00:06:11,919
as big as the production warehouse

00:06:09,680 --> 00:06:13,600
so simulation is the only place you can

00:06:11,919 --> 00:06:17,600
run it on a big setups

00:06:13,600 --> 00:06:17,600
before running it in the production

00:06:18,400 --> 00:06:21,759
oh we saw we saw what we simulate and

00:06:21,280 --> 00:06:23,440
the

00:06:21,759 --> 00:06:25,440
what usage we do with the simulation

00:06:23,440 --> 00:06:26,639
tool now let's talk about how we run the

00:06:25,440 --> 00:06:28,240
simulation

00:06:26,639 --> 00:06:30,240
or the approach we are using is called

00:06:28,240 --> 00:06:32,160
disk event simulation

00:06:30,240 --> 00:06:34,639
in this approach continuous operations

00:06:32,160 --> 00:06:37,600
are modeled by instant events

00:06:34,639 --> 00:06:40,000
for example if we want to simulate an

00:06:37,600 --> 00:06:42,080
elevator then the events can be

00:06:40,000 --> 00:06:44,080
door is open elevator right button

00:06:42,080 --> 00:06:46,080
pressed and so on

00:06:44,080 --> 00:06:48,400
and the simulation also maintains its

00:06:46,080 --> 00:06:50,000
own clock and it immediately moves from

00:06:48,400 --> 00:06:50,560
one event to the next event and that's

00:06:50,000 --> 00:06:53,440
how the

00:06:50,560 --> 00:06:55,599
time can run faster than the real time

00:06:53,440 --> 00:06:58,080
in our simulation we

00:06:55,599 --> 00:07:00,319
do it a little bit different we treat

00:06:58,080 --> 00:07:03,599
the time as the events

00:07:00,319 --> 00:07:05,039
and then each we divide the time into

00:07:03,599 --> 00:07:07,919
time ticks and then each time

00:07:05,039 --> 00:07:09,440
we calculate the new state of the robots

00:07:07,919 --> 00:07:10,160
so we simulate the operations of the

00:07:09,440 --> 00:07:12,560
robot

00:07:10,160 --> 00:07:14,479
which are move turning passing through

00:07:12,560 --> 00:07:16,720
from one over to another robot

00:07:14,479 --> 00:07:19,520
let's take an example let's let's see

00:07:16,720 --> 00:07:21,599
the move operation of the robot

00:07:19,520 --> 00:07:22,720
let's say that a robot can move in two

00:07:21,599 --> 00:07:24,800
meters per second

00:07:22,720 --> 00:07:26,240
and we choose to have 10 time ticks in a

00:07:24,800 --> 00:07:29,280
second

00:07:26,240 --> 00:07:33,199
so at first the robot is located at

00:07:29,280 --> 00:07:36,560
x0 and assuming it got a move operation

00:07:33,199 --> 00:07:38,160
then the next time tick will be 0.1

00:07:36,560 --> 00:07:40,880
and the robot will calculate the new

00:07:38,160 --> 00:07:42,560
state which is 20 centimeters

00:07:40,880 --> 00:07:44,879
then again the next time they could be

00:07:42,560 --> 00:07:47,680
in 0.2 and robot will calculate the new

00:07:44,879 --> 00:07:50,000
location which is 40 centimeters

00:07:47,680 --> 00:07:51,120
and notice that in this approach the

00:07:50,000 --> 00:07:53,840
robot was never

00:07:51,120 --> 00:07:54,960
between 20 to 40 centimeters it

00:07:53,840 --> 00:07:58,319
immediately moves from

00:07:54,960 --> 00:08:00,960
from one set to the next and in reality

00:07:58,319 --> 00:08:02,400
the robot anyway sends telemetries to

00:08:00,960 --> 00:08:05,120
our backend

00:08:02,400 --> 00:08:06,639
few times in a second so the behavior

00:08:05,120 --> 00:08:08,879
looks the same for the back and it is

00:08:06,639 --> 00:08:13,039
discrete anyway and we don't lose

00:08:08,879 --> 00:08:14,800
any information by doing so

00:08:13,039 --> 00:08:16,960
so this is the idea of the discrete

00:08:14,800 --> 00:08:18,000
event simulation now to implement it in

00:08:16,960 --> 00:08:20,319
python we use the

00:08:18,000 --> 00:08:22,240
simple library simple is an open source

00:08:20,319 --> 00:08:24,840
library it is a

00:08:22,240 --> 00:08:26,160
framework for discrete event simulation

00:08:24,840 --> 00:08:28,720
is

00:08:26,160 --> 00:08:29,520
very simple and well documented and

00:08:28,720 --> 00:08:33,200
there's a lot of

00:08:29,520 --> 00:08:35,519
samples on the web and it is also

00:08:33,200 --> 00:08:36,479
lightweight i mean that it doesn't try

00:08:35,519 --> 00:08:39,279
to help you to

00:08:36,479 --> 00:08:40,080
simulate your components it just give

00:08:39,279 --> 00:08:41,760
you the framework

00:08:40,080 --> 00:08:43,440
to implement the discrete event

00:08:41,760 --> 00:08:46,080
simulation

00:08:43,440 --> 00:08:46,720
before we see how to do it in the code

00:08:46,080 --> 00:08:50,320
let's see

00:08:46,720 --> 00:08:52,560
let's understand the idea of simple

00:08:50,320 --> 00:08:54,640
so to be to understand simple you need

00:08:52,560 --> 00:08:57,040
to be familiar with the three objects

00:08:54,640 --> 00:08:58,800
the first one is environment the second

00:08:57,040 --> 00:08:59,839
one is process and the third one is the

00:08:58,800 --> 00:09:01,839
events

00:08:59,839 --> 00:09:03,519
the environment is the main object that

00:09:01,839 --> 00:09:06,480
manages the world simulation

00:09:03,519 --> 00:09:08,000
it has the simulation clock and it has

00:09:06,480 --> 00:09:10,480
an event queue

00:09:08,000 --> 00:09:11,360
process represents the component we want

00:09:10,480 --> 00:09:13,600
to simulate

00:09:11,360 --> 00:09:14,560
so in this example we have two processes

00:09:13,600 --> 00:09:18,080
one for

00:09:14,560 --> 00:09:21,279
orbit zero and one for robot one

00:09:18,080 --> 00:09:23,440
now at first the processes adds the

00:09:21,279 --> 00:09:26,000
initial event in the queue

00:09:23,440 --> 00:09:27,519
so we have two events one for robot zero

00:09:26,000 --> 00:09:29,120
and one for robot one

00:09:27,519 --> 00:09:31,279
and when we start the environment it

00:09:29,120 --> 00:09:33,120
takes the first event from the queue

00:09:31,279 --> 00:09:34,640
it runs it so it calculates the new

00:09:33,120 --> 00:09:36,800
state of the robot

00:09:34,640 --> 00:09:38,880
and before it is done it adds the next

00:09:36,800 --> 00:09:41,279
event of that robot in the queue

00:09:38,880 --> 00:09:43,839
and then again it takes the first event

00:09:41,279 --> 00:09:46,640
from the queue which now

00:09:43,839 --> 00:09:48,000
belongs to robot one again calculates

00:09:46,640 --> 00:09:50,480
the new state

00:09:48,000 --> 00:09:52,080
it's the next the next state of robot

00:09:50,480 --> 00:09:54,000
one

00:09:52,080 --> 00:09:55,680
into the queue and then again it will

00:09:54,000 --> 00:09:56,800
take the next event from the queue which

00:09:55,680 --> 00:09:59,200
this time

00:09:56,800 --> 00:10:00,160
uh which again belongs to robot zero but

00:09:59,200 --> 00:10:03,360
this time

00:10:00,160 --> 00:10:04,920
it is in time 0.1 so it will update the

00:10:03,360 --> 00:10:07,920
clock to

00:10:04,920 --> 00:10:10,560
0.1 so this is the

00:10:07,920 --> 00:10:11,440
very basic idea of how simple works now

00:10:10,560 --> 00:10:14,560
let's see

00:10:11,440 --> 00:10:16,240
how to do it in the code so in the code

00:10:14,560 --> 00:10:19,040
you'll see a very simple example of

00:10:16,240 --> 00:10:21,600
using the the same pipe and in this

00:10:19,040 --> 00:10:24,480
example we'll conduct a race of robots

00:10:21,600 --> 00:10:28,399
it's let's say that a robot can move

00:10:24,480 --> 00:10:28,399
somewhere between two to four meters

00:10:29,200 --> 00:10:33,279
okay so let's go over the code and then

00:10:31,040 --> 00:10:35,120
we also will run it

00:10:33,279 --> 00:10:36,720
so here we define that we have three

00:10:35,120 --> 00:10:39,760
robots in the

00:10:36,720 --> 00:10:42,000
race the race is going to last for

00:10:39,760 --> 00:10:43,680
30 seconds and we choose 12 to time

00:10:42,000 --> 00:10:46,560
peaks in a second so we'll have the time

00:10:43,680 --> 00:10:48,880
tick after every half a second

00:10:46,560 --> 00:10:51,120
here we implement a very simple robot we

00:10:48,880 --> 00:10:54,000
only implement the move operation

00:10:51,120 --> 00:10:55,680
as you can see it is a python generator

00:10:54,000 --> 00:10:56,560
so at first all the locations of the

00:10:55,680 --> 00:10:59,600
robot is

00:10:56,560 --> 00:11:02,160
zero each iteration of the while

00:10:59,600 --> 00:11:02,720
is a time peak so so it will calculate

00:11:02,160 --> 00:11:05,200
the new

00:11:02,720 --> 00:11:07,040
location to make it interesting use the

00:11:05,200 --> 00:11:09,440
random function

00:11:07,040 --> 00:11:11,120
notice that they i provide the function

00:11:09,440 --> 00:11:12,240
one and two because we said that the

00:11:11,120 --> 00:11:14,000
robot moves

00:11:12,240 --> 00:11:15,440
between two to four meters and we have

00:11:14,000 --> 00:11:19,120
two time ticks in a second

00:11:15,440 --> 00:11:21,279
so it is one to two here after second

00:11:19,120 --> 00:11:24,399
then the robot will print the simulation

00:11:21,279 --> 00:11:26,399
time the robot id and the new location

00:11:24,399 --> 00:11:28,480
and it will tell the environment that

00:11:26,399 --> 00:11:30,160
the next time it wants to run is in half

00:11:28,480 --> 00:11:33,200
a second

00:11:30,160 --> 00:11:34,959
so here we initialize our environment we

00:11:33,200 --> 00:11:36,079
register the simple process into the

00:11:34,959 --> 00:11:39,360
environment

00:11:36,079 --> 00:11:40,399
and run the environment it's now on the

00:11:39,360 --> 00:11:42,880
race

00:11:40,399 --> 00:11:44,880
i'm going to to run the code remember

00:11:42,880 --> 00:11:48,240
that the race is

00:11:44,880 --> 00:11:49,200
is about 30 seconds and of course it is

00:11:48,240 --> 00:11:52,399
not going to take

00:11:49,200 --> 00:11:52,959
30 seconds i use the time command which

00:11:52,399 --> 00:11:56,399
will print

00:11:52,959 --> 00:11:59,760
the time it took the program to one

00:11:56,399 --> 00:12:02,880
so as you can see it lasted

00:11:59,760 --> 00:12:03,360
less than one second so i said each of

00:12:02,880 --> 00:12:11,600
you

00:12:03,360 --> 00:12:14,800
20 about 29 seconds

00:12:11,600 --> 00:12:16,880
okay so an important point to

00:12:14,800 --> 00:12:18,240
be aware of is that all the simple

00:12:16,880 --> 00:12:20,480
process of the components we are

00:12:18,240 --> 00:12:23,360
simulating run in the same thread

00:12:20,480 --> 00:12:24,079
as you could see it is using a python

00:12:23,360 --> 00:12:27,200
generator

00:12:24,079 --> 00:12:27,839
and the environment runs each event at a

00:12:27,200 --> 00:12:29,839
time

00:12:27,839 --> 00:12:31,200
and i'll talk about it again in few

00:12:29,839 --> 00:12:33,120
slides

00:12:31,200 --> 00:12:35,040
also the parameters that affect the

00:12:33,120 --> 00:12:37,600
runtime of the simulation

00:12:35,040 --> 00:12:38,160
obviously the number of components the

00:12:37,600 --> 00:12:39,839
more

00:12:38,160 --> 00:12:41,600
components we are simulating then the

00:12:39,839 --> 00:12:45,120
more calculations we have to do

00:12:41,600 --> 00:12:47,279
therefore slower simulation and also the

00:12:45,120 --> 00:12:49,200
time to go on lowerity the bigger

00:12:47,279 --> 00:12:50,240
granularity then again more calculation

00:12:49,200 --> 00:12:53,279
in a second

00:12:50,240 --> 00:12:55,839
and the slower simulation

00:12:53,279 --> 00:12:56,880
the mode i described so far is called as

00:12:55,839 --> 00:12:59,120
fast as possible

00:12:56,880 --> 00:13:00,720
it means that the simulation tries to

00:12:59,120 --> 00:13:02,560
run the fastest it can

00:13:00,720 --> 00:13:04,160
it immediately moves from one event to

00:13:02,560 --> 00:13:06,399
the next event

00:13:04,160 --> 00:13:07,519
simpa also allows to run in a real-time

00:13:06,399 --> 00:13:09,360
mode where

00:13:07,519 --> 00:13:11,040
it tries to follow the real time it will

00:13:09,360 --> 00:13:11,920
run an event and before moving to the

00:13:11,040 --> 00:13:13,920
next event

00:13:11,920 --> 00:13:15,440
it will wait until the time of the next

00:13:13,920 --> 00:13:18,639
event will come

00:13:15,440 --> 00:13:19,920
now why would we want to do this i mean

00:13:18,639 --> 00:13:22,079
in the first thought you would think

00:13:19,920 --> 00:13:23,200
that we always want to run the fastest

00:13:22,079 --> 00:13:26,000
we can

00:13:23,200 --> 00:13:27,200
but you may want uh to do some manual

00:13:26,000 --> 00:13:30,880
testing in your

00:13:27,200 --> 00:13:32,880
system like a rest call so whatever

00:13:30,880 --> 00:13:34,800
or you also may want to combine real

00:13:32,880 --> 00:13:37,040
hardware with your simulation

00:13:34,800 --> 00:13:39,680
so these are good reasons to run it in a

00:13:37,040 --> 00:13:39,680
real-time mode

00:13:41,760 --> 00:13:45,600
deploying the discord event simulation

00:13:43,760 --> 00:13:48,639
approach has several benefits

00:13:45,600 --> 00:13:49,600
the most obvious one is that it makes

00:13:48,639 --> 00:13:52,720
the

00:13:49,600 --> 00:13:54,560
development more efficient when

00:13:52,720 --> 00:13:55,760
developers finish the right code and we

00:13:54,560 --> 00:13:58,320
test it then

00:13:55,760 --> 00:13:59,440
you will get a faster feedback and also

00:13:58,320 --> 00:14:02,639
you get a shorter

00:13:59,440 --> 00:14:04,240
ci but as you can imagine from the

00:14:02,639 --> 00:14:05,600
previous slide when i talked about

00:14:04,240 --> 00:14:08,480
parameters that affect the

00:14:05,600 --> 00:14:10,480
runtime if we run the simulation with

00:14:08,480 --> 00:14:11,920
many many robots then it may be that the

00:14:10,480 --> 00:14:15,360
simulation will even

00:14:11,920 --> 00:14:17,440
run slower than the real time but this

00:14:15,360 --> 00:14:18,079
is still an advantage because that way

00:14:17,440 --> 00:14:20,880
the

00:14:18,079 --> 00:14:21,279
result of the simulation api will still

00:14:20,880 --> 00:14:24,560
be

00:14:21,279 --> 00:14:26,399
realistic it means i mean that

00:14:24,560 --> 00:14:28,480
in every time people the robot will get

00:14:26,399 --> 00:14:31,120
the chance to do the calculations

00:14:28,480 --> 00:14:32,240
the the to calculate the new the new

00:14:31,120 --> 00:14:36,000
state

00:14:32,240 --> 00:14:37,199
and that's how the time will not run too

00:14:36,000 --> 00:14:39,600
fast

00:14:37,199 --> 00:14:40,560
um from the same reason it is also

00:14:39,600 --> 00:14:43,440
determining its

00:14:40,560 --> 00:14:44,720
deterministic it doesn't matter if you

00:14:43,440 --> 00:14:47,360
run it on a strong

00:14:44,720 --> 00:14:48,480
machine on the on the cloud or on your

00:14:47,360 --> 00:14:49,920
private laptop

00:14:48,480 --> 00:14:52,079
the runtime of the simulation will be

00:14:49,920 --> 00:14:53,440
affected but the result will be

00:14:52,079 --> 00:14:55,440
deterministic

00:14:53,440 --> 00:14:57,040
and also it is agnostic to profiling and

00:14:55,440 --> 00:14:59,680
debugging still will get the same

00:14:57,040 --> 00:15:02,399
results

00:14:59,680 --> 00:15:03,040
uh last using this approach will also

00:15:02,399 --> 00:15:05,920
allow you

00:15:03,040 --> 00:15:07,120
very easy to simulate any date or any

00:15:05,920 --> 00:15:09,040
time of the day

00:15:07,120 --> 00:15:10,639
like you can run the system like it is

00:15:09,040 --> 00:15:12,959
the weekend or

00:15:10,639 --> 00:15:13,760
any special time that is interesting for

00:15:12,959 --> 00:15:16,320
you

00:15:13,760 --> 00:15:17,040
and simply for example you just need to

00:15:16,320 --> 00:15:18,959
provide

00:15:17,040 --> 00:15:21,680
the initial time to the environment and

00:15:18,959 --> 00:15:25,120
this is that simple

00:15:21,680 --> 00:15:27,040
and then this bug wouldn't happen if

00:15:25,120 --> 00:15:30,480
we wouldn't be panicked before the

00:15:27,040 --> 00:15:30,480
millennium bug if we add this

00:15:31,680 --> 00:15:36,320
okay so far i showed you how to simulate

00:15:34,639 --> 00:15:37,440
robots using the discrete event

00:15:36,320 --> 00:15:39,360
simulation

00:15:37,440 --> 00:15:41,440
but recorded at the beginning i

00:15:39,360 --> 00:15:43,199
mentioned that we want to run our

00:15:41,440 --> 00:15:45,279
system our back-end together with the

00:15:43,199 --> 00:15:48,240
simulated robots

00:15:45,279 --> 00:15:48,880
now our back-end is a multi-threaded

00:15:48,240 --> 00:15:51,920
system

00:15:48,880 --> 00:15:52,399
it has several threads that get messages

00:15:51,920 --> 00:15:55,040
and they

00:15:52,399 --> 00:15:56,639
react to them the messages can be either

00:15:55,040 --> 00:15:59,600
telemeters from robots

00:15:56,639 --> 00:16:00,240
input from the user and orders from

00:15:59,600 --> 00:16:03,519
customer

00:16:00,240 --> 00:16:05,759
and such and can you think

00:16:03,519 --> 00:16:08,399
what is the problem of running the back

00:16:05,759 --> 00:16:11,600
end together with the robots

00:16:08,399 --> 00:16:14,000
so the problem is that the robots

00:16:11,600 --> 00:16:14,880
may run the time too fast and the back

00:16:14,000 --> 00:16:17,440
the back end

00:16:14,880 --> 00:16:20,320
wouldn't have the time to do the work

00:16:17,440 --> 00:16:22,560
like it would do in the real time

00:16:20,320 --> 00:16:24,800
simply as a support for event-driven

00:16:22,560 --> 00:16:27,360
processes but as i mentioned before

00:16:24,800 --> 00:16:28,399
all the simple process run all the

00:16:27,360 --> 00:16:31,680
simple processes

00:16:28,399 --> 00:16:33,600
are in the in the single thread so it

00:16:31,680 --> 00:16:33,920
will change the behavior of our backend

00:16:33,600 --> 00:16:37,040
and

00:16:33,920 --> 00:16:38,240
we already had a similar experience when

00:16:37,040 --> 00:16:40,399
we used the

00:16:38,240 --> 00:16:41,839
event monkey patch which make your

00:16:40,399 --> 00:16:43,680
system

00:16:41,839 --> 00:16:45,600
your thread cooperative and once the

00:16:43,680 --> 00:16:47,440
system like it is wanted

00:16:45,600 --> 00:16:48,639
it did improve the performance of the

00:16:47,440 --> 00:16:50,160
system but

00:16:48,639 --> 00:16:53,199
later we found out that we have some

00:16:50,160 --> 00:16:55,279
bugs that we couldn't see in simulation

00:16:53,199 --> 00:16:57,519
therefore the solution of a simple for

00:16:55,279 --> 00:16:59,920
event driven processes is

00:16:57,519 --> 00:17:02,320
not good enough for us so we came up

00:16:59,920 --> 00:17:05,360
with our own solution

00:17:02,320 --> 00:17:06,640
in simulation we create another simple

00:17:05,360 --> 00:17:08,880
process

00:17:06,640 --> 00:17:10,720
which in every time tick it holds the

00:17:08,880 --> 00:17:12,160
time until the event driven threads will

00:17:10,720 --> 00:17:15,120
do the work

00:17:12,160 --> 00:17:15,760
it is done good by calling the join on

00:17:15,120 --> 00:17:18,000
the

00:17:15,760 --> 00:17:18,959
threads queue and the join function

00:17:18,000 --> 00:17:21,919
waits until the

00:17:18,959 --> 00:17:23,439
queue is is getting empty and that's how

00:17:21,919 --> 00:17:24,079
we make sure that the event driven

00:17:23,439 --> 00:17:28,000
thread will

00:17:24,079 --> 00:17:32,559
have the time to handle the the events

00:17:28,000 --> 00:17:35,600
let's see an example in the code

00:17:32,559 --> 00:17:38,400
okay so in this example we'll see uh

00:17:35,600 --> 00:17:39,679
we'll have uh one event driven thread

00:17:38,400 --> 00:17:42,480
which listen to a queue

00:17:39,679 --> 00:17:44,240
get a message and print it to the screen

00:17:42,480 --> 00:17:46,080
and another robot which in every time

00:17:44,240 --> 00:17:49,200
tick will send the telemet a message

00:17:46,080 --> 00:17:50,400
to the event event so let's go over the

00:17:49,200 --> 00:17:53,200
code

00:17:50,400 --> 00:17:55,679
and this time we'll have a time peak one

00:17:53,200 --> 00:17:57,919
time ticking every one second

00:17:55,679 --> 00:17:59,600
for now we'll just show you the problem

00:17:57,919 --> 00:18:02,480
so if you know about this class

00:17:59,600 --> 00:18:04,559
we'll see it later so this is a simple

00:18:02,480 --> 00:18:05,440
implementation of an event-driven thread

00:18:04,559 --> 00:18:07,919
what it is doing

00:18:05,440 --> 00:18:08,960
is listening to the queue printing the

00:18:07,919 --> 00:18:12,840
message to the

00:18:08,960 --> 00:18:14,400
screen and that's it here we implement

00:18:12,840 --> 00:18:17,600
another

00:18:14,400 --> 00:18:21,120
simple robot in each iteration it adds

00:18:17,600 --> 00:18:22,480
a message in the event driven view and

00:18:21,120 --> 00:18:24,400
kills the counter and tests the

00:18:22,480 --> 00:18:28,320
environment it will run again

00:18:24,400 --> 00:18:31,600
in one second so again we initialize the

00:18:28,320 --> 00:18:34,000
environment this time to see the problem

00:18:31,600 --> 00:18:37,120
we use the regular python queue

00:18:34,000 --> 00:18:41,120
we start the event driven thread we

00:18:37,120 --> 00:18:44,160
register the environment and and run it

00:18:41,120 --> 00:18:44,160
so let's run it

00:18:47,280 --> 00:18:51,679
so just remember we are going to we are

00:18:49,600 --> 00:18:53,360
going to run the simulation for 50

00:18:51,679 --> 00:18:55,280
seconds and in each second

00:18:53,360 --> 00:18:56,720
the robot will send a message to the

00:18:55,280 --> 00:18:59,919
event driven thread which should

00:18:56,720 --> 00:19:01,760
point it to this game so run it and as

00:18:59,919 --> 00:19:03,520
you can see we don't see any message in

00:19:01,760 --> 00:19:05,200
the screen and this is exactly the

00:19:03,520 --> 00:19:07,440
problem that i described

00:19:05,200 --> 00:19:11,200
the robot did send 50 messages but the

00:19:07,440 --> 00:19:15,200
event eventually didn't have the time to

00:19:11,200 --> 00:19:17,840
handle them so let's see how we solve it

00:19:15,200 --> 00:19:18,799
we we know it from the python queue and

00:19:17,840 --> 00:19:21,760
in simulation

00:19:18,799 --> 00:19:22,880
we add another simple process that in

00:19:21,760 --> 00:19:25,039
each time tick

00:19:22,880 --> 00:19:26,880
it will call the join on the queue and

00:19:25,039 --> 00:19:28,880
then we'll again tell the

00:19:26,880 --> 00:19:30,640
environment it will run again in one

00:19:28,880 --> 00:19:34,640
second in the next time

00:19:30,640 --> 00:19:34,640
so let's use this skill this time

00:19:36,840 --> 00:19:39,840
okay

00:19:39,919 --> 00:19:44,559
so let's run the example again this time

00:19:42,000 --> 00:19:46,559
with our cue

00:19:44,559 --> 00:19:48,160
and as you can see it's of the problem

00:19:46,559 --> 00:19:50,640
the the you see

00:19:48,160 --> 00:19:52,880
the usage of the join helps the event

00:19:50,640 --> 00:19:55,360
event ads to handle their

00:19:52,880 --> 00:19:55,360
messages

00:19:57,039 --> 00:20:00,720
so as you kids you could see in the

00:19:58,960 --> 00:20:02,720
example the

00:20:00,720 --> 00:20:03,919
event even thread is not really aware of

00:20:02,720 --> 00:20:05,600
simply

00:20:03,919 --> 00:20:07,120
and that's what i meant that we run our

00:20:05,600 --> 00:20:09,039
product our backend

00:20:07,120 --> 00:20:10,960
in simulation just as it runs in the

00:20:09,039 --> 00:20:12,559
production it doesn't we're

00:20:10,960 --> 00:20:15,120
aware whether it is a production or

00:20:12,559 --> 00:20:15,120
simulation

00:20:15,440 --> 00:20:18,880
with the extension that the backend

00:20:17,679 --> 00:20:21,280
cannot call the

00:20:18,880 --> 00:20:22,400
default time functionality because in

00:20:21,280 --> 00:20:23,840
simulation

00:20:22,400 --> 00:20:25,520
they are not relevant right we have a

00:20:23,840 --> 00:20:27,440
different clock so

00:20:25,520 --> 00:20:29,440
we wrapped all that functionality in our

00:20:27,440 --> 00:20:30,720
own module and the backend just calls

00:20:29,440 --> 00:20:32,720
this module

00:20:30,720 --> 00:20:34,799
and this module knows whether it is

00:20:32,720 --> 00:20:38,159
simulation of production and calls the

00:20:34,799 --> 00:20:41,440
right functions last we

00:20:38,159 --> 00:20:43,120
in simulation we print the simulation

00:20:41,440 --> 00:20:44,720
timestamp in the log because when you

00:20:43,120 --> 00:20:46,799
are debugging

00:20:44,720 --> 00:20:49,840
the simulation you care more about the

00:20:46,799 --> 00:20:49,840
simulation time

00:20:50,080 --> 00:20:54,559
now eventually we also moved to

00:20:52,720 --> 00:20:58,080
microservices just like

00:20:54,559 --> 00:20:58,799
just like everyone else and we again we

00:20:58,080 --> 00:21:01,679
wanted

00:20:58,799 --> 00:21:03,280
the simulation to grant our system to

00:21:01,679 --> 00:21:03,520
run the simulation just like it runs in

00:21:03,280 --> 00:21:05,919
the

00:21:03,520 --> 00:21:06,799
production so it means that this time we

00:21:05,919 --> 00:21:08,720
don't

00:21:06,799 --> 00:21:11,120
use a multi-threaded simulation but we

00:21:08,720 --> 00:21:12,960
want to distribute the simulation

00:21:11,120 --> 00:21:14,559
we said that simpari doesn't support a

00:21:12,960 --> 00:21:16,720
multi-threaded simulation for

00:21:14,559 --> 00:21:18,559
so for sure it doesn't support

00:21:16,720 --> 00:21:21,440
multi-process simulation

00:21:18,559 --> 00:21:22,240
so we came up with that solution in a

00:21:21,440 --> 00:21:24,400
simulation

00:21:22,240 --> 00:21:25,520
we run another service called barrier

00:21:24,400 --> 00:21:27,760
server

00:21:25,520 --> 00:21:29,679
and the responsibility of this service

00:21:27,760 --> 00:21:30,559
is to sync the time of the other

00:21:29,679 --> 00:21:32,720
services

00:21:30,559 --> 00:21:34,480
to prevent one service to run faster

00:21:32,720 --> 00:21:38,720
than the other services

00:21:34,480 --> 00:21:41,120
so all the other services look the same

00:21:38,720 --> 00:21:42,960
as they described so far the same as the

00:21:41,120 --> 00:21:43,520
multi-threaded simulation each one of

00:21:42,960 --> 00:21:47,360
them has

00:21:43,520 --> 00:21:50,240
its own local senpai and all of them

00:21:47,360 --> 00:21:51,280
pick a shared time tick and it rolls

00:21:50,240 --> 00:21:53,120
like that

00:21:51,280 --> 00:21:54,960
at the beginning they initialize the

00:21:53,120 --> 00:21:58,320
senpai they do

00:21:54,960 --> 00:22:00,080
each service is doing this work and

00:21:58,320 --> 00:22:02,159
once the share time tick arrived they

00:22:00,080 --> 00:22:05,440
send the ready message to

00:22:02,159 --> 00:22:06,080
the service then a service holds that

00:22:05,440 --> 00:22:08,480
message

00:22:06,080 --> 00:22:10,159
and until he gets the message from all

00:22:08,480 --> 00:22:12,559
the other services

00:22:10,159 --> 00:22:14,000
and once you got them you send them the

00:22:12,559 --> 00:22:16,159
approval and then

00:22:14,000 --> 00:22:18,240
they can move to the next antique that's

00:22:16,159 --> 00:22:21,679
how we prevent one service to one faster

00:22:18,240 --> 00:22:23,200
from the other services notice that

00:22:21,679 --> 00:22:24,799
since the service sends the ready

00:22:23,200 --> 00:22:26,240
message to the server

00:22:24,799 --> 00:22:27,840
until he gets the approval the time

00:22:26,240 --> 00:22:29,280
holds for him he waits for the other

00:22:27,840 --> 00:22:32,080
services to which the

00:22:29,280 --> 00:22:32,080
that's time too

00:22:34,480 --> 00:22:40,559
so i finished the slides i think we have

00:22:37,840 --> 00:22:43,280
a few minutes for questions and then i

00:22:40,559 --> 00:22:43,280
just sum up

00:22:44,400 --> 00:22:50,880
awesome thank you very much

00:22:47,080 --> 00:22:53,919
[Applause]

00:22:50,880 --> 00:22:56,400
so i do have a couple of uh one question

00:22:53,919 --> 00:22:58,640
so far if anyone has any questions um

00:22:56,400 --> 00:23:00,880
please post it in the q a here on uh

00:22:58,640 --> 00:23:04,720
zoom or you can uh also

00:23:00,880 --> 00:23:06,720
uh post it in the um parrot track

00:23:04,720 --> 00:23:08,320
uh chat room over on discord which i'm

00:23:06,720 --> 00:23:11,360
keeping an eye on as well

00:23:08,320 --> 00:23:13,360
uh anyway so uh rude vanderhome asks

00:23:11,360 --> 00:23:16,159
are you familiar with the other python

00:23:13,360 --> 00:23:18,080
des called salabim

00:23:16,159 --> 00:23:19,200
yeah i heard about it i think it is

00:23:18,080 --> 00:23:22,240
quite new maybe

00:23:19,200 --> 00:23:25,280
2017. so before we started

00:23:22,240 --> 00:23:25,919
it wasn't exist but anyway i checked it

00:23:25,280 --> 00:23:28,159
and

00:23:25,919 --> 00:23:29,679
it looks pretty pretty similar to simple

00:23:28,159 --> 00:23:33,679
i think it also uses

00:23:29,679 --> 00:23:34,559
generators and it has also the notion of

00:23:33,679 --> 00:23:37,200
environment

00:23:34,559 --> 00:23:40,240
i think but i know i didn't really try

00:23:37,200 --> 00:23:42,240
it we already used the simple and

00:23:40,240 --> 00:23:43,360
i also didn't see much comparisons of

00:23:42,240 --> 00:23:46,240
them so

00:23:43,360 --> 00:23:46,799
if if someone is aware of it is familiar

00:23:46,240 --> 00:23:51,679
with it

00:23:46,799 --> 00:23:53,760
i'd like to hear in the discord system

00:23:51,679 --> 00:23:54,720
i also have another question actually

00:23:53,760 --> 00:23:57,360
also from

00:23:54,720 --> 00:23:58,799
vanderham he says how does the message

00:23:57,360 --> 00:24:03,600
messaging between the

00:23:58,799 --> 00:24:06,480
barrier service work so this is a

00:24:03,600 --> 00:24:09,200
depends on your implementation it

00:24:06,480 --> 00:24:11,039
depends how your services

00:24:09,200 --> 00:24:13,200
communicate in our case we use the

00:24:11,039 --> 00:24:16,840
message queue for this

00:24:13,200 --> 00:24:21,919
so but you can do it with the rest or

00:24:16,840 --> 00:24:21,919
sockets any other messaging

00:24:23,679 --> 00:24:27,120
all right excellent um

00:24:27,200 --> 00:24:31,440
so it looks like um

00:24:31,520 --> 00:24:37,010
that's all i have at the moment um okay

00:24:34,720 --> 00:24:40,210
so once again thank you very much

00:24:37,010 --> 00:24:40,210
[Applause]

00:24:41,360 --> 00:24:44,799
and uh yeah if anyone wants to chat with

00:24:43,760 --> 00:24:47,279
um

00:24:44,799 --> 00:24:49,039
um afterwards he is um you can look up

00:24:47,279 --> 00:24:51,919
uh his room uh

00:24:49,039 --> 00:24:52,880
which i believe is uh boosting uh sim

00:24:51,919 --> 00:24:56,480
performance

00:24:52,880 --> 00:24:59,679
in um uh discord and uh

00:24:56,480 --> 00:25:02,799
aaron you wanted to do a quick recap

00:24:59,679 --> 00:25:05,279
yeah first thank you so

00:25:02,799 --> 00:25:07,039
yeah so what we saw in the talk we saw

00:25:05,279 --> 00:25:08,799
just how important

00:25:07,039 --> 00:25:11,840
the simulation is especially for an

00:25:08,799 --> 00:25:14,000
hardware company like ours

00:25:11,840 --> 00:25:16,480
and the discrete event simulation has

00:25:14,000 --> 00:25:18,960
some more benefits with it

00:25:16,480 --> 00:25:20,799
and again if you want to do it in senpai

00:25:18,960 --> 00:25:23,840
and in python you can do it in simple

00:25:20,799 --> 00:25:27,360
also there is the beam module

00:25:23,840 --> 00:25:30,000
library if you want to run the

00:25:27,360 --> 00:25:32,000
simulation with your system then you may

00:25:30,000 --> 00:25:34,240
suffer timely you just need to make sure

00:25:32,000 --> 00:25:37,039
that all the components are tied to the

00:25:34,240 --> 00:25:40,480
time somehow with the clock

00:25:37,039 --> 00:25:41,360
and then finally the the extension of

00:25:40,480 --> 00:25:43,120
the

00:25:41,360 --> 00:25:44,720
simulation into the distributed

00:25:43,120 --> 00:25:45,840
simulation was really straightforward

00:25:44,720 --> 00:25:49,360
for us and

00:25:45,840 --> 00:25:52,000
really took us a couple of days to do it

00:25:49,360 --> 00:25:52,640
so that's it thank you very much for

00:25:52,000 --> 00:25:57,840
listening

00:25:52,640 --> 00:25:57,840
hope you enjoyed

00:25:58,390 --> 00:26:04,640
[Applause]

00:26:02,559 --> 00:26:04,640

YouTube URL: https://www.youtube.com/watch?v=HHTd-eCnQ-8


