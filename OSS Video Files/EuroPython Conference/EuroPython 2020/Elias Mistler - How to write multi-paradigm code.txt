Title: Elias Mistler - How to write multi-paradigm code
Publication date: 2020-09-15
Playlist: EuroPython 2020
Description: 
	"How to write multi-paradigm code
EuroPython 2020 - Talk - 2020-07-23 - Microsoft
Online

By Elias Mistler

Python is a powerful multi-paradigm language which combines elements of object-orientation and functional programming. Both concepts can be really powerful if used right. But what if you use them together? It can be pragmatic and very efficient, but things can also get messy really quickly.

This talk explores peaceful co-existence of oo-classes and pure functions in the same code base. The focus is on identifying the right tool for the right job and bringing together the best of both. The main topics are:


Code Structure
Data Structures
State Handling
Multiple implementations


Prerequisites:
There are no formal prerequisites for this course, although it is recommended that participants have a strong background in Python and its code structuring mechanisms, as well as a deep understanding of at least one of the paradigms of OOP and FP.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2020.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:06,879 --> 00:00:09,760
okay

00:00:07,440 --> 00:00:13,040
so now we have 10 o'clock and we can

00:00:09,760 --> 00:00:15,759
start with the next session

00:00:13,040 --> 00:00:17,119
we have elias mistler who is going to

00:00:15,759 --> 00:00:20,000
join us and give a talk

00:00:17,119 --> 00:00:21,279
about how to write multi-paradigm code

00:00:20,000 --> 00:00:23,359
without making a mess

00:00:21,279 --> 00:00:24,800
and elias is a principal machine

00:00:23,359 --> 00:00:26,240
learning engineer from

00:00:24,800 --> 00:00:28,240
previs i hope i pronounced that

00:00:26,240 --> 00:00:31,599
correctly

00:00:28,240 --> 00:00:34,719
he's doing a lot of machine learning and

00:00:31,599 --> 00:00:36,880
he has he's going to talk about

00:00:34,719 --> 00:00:38,879
using both object orientation and

00:00:36,880 --> 00:00:42,160
functional programming together

00:00:38,879 --> 00:00:45,600
and how to make those two play

00:00:42,160 --> 00:00:48,000
nicely so let's head on to

00:00:45,600 --> 00:00:49,840
to earliest elias can you please start

00:00:48,000 --> 00:00:52,800
sharing your screen

00:00:49,840 --> 00:00:54,000
of course of course the second section

00:00:52,800 --> 00:00:56,239
right right

00:00:54,000 --> 00:00:56,239
here

00:00:57,520 --> 00:01:00,640
excellent and i'll mute

00:01:01,120 --> 00:01:05,600
okay well thank you mark for the

00:01:02,879 --> 00:01:08,720
introduction and thank you everyone for

00:01:05,600 --> 00:01:09,200
for joining um what is now the first

00:01:08,720 --> 00:01:12,960
talk

00:01:09,200 --> 00:01:15,200
here um so

00:01:12,960 --> 00:01:17,040
as mark already introduced this about

00:01:15,200 --> 00:01:20,240
multi-paradigm programming

00:01:17,040 --> 00:01:23,920
uh in python just gonna say

00:01:20,240 --> 00:01:27,200
sort of i've got an introduction here

00:01:23,920 --> 00:01:29,840
we basically already said uh provise

00:01:27,200 --> 00:01:31,520
the company i work with is an invoicing

00:01:29,840 --> 00:01:33,360
finance company

00:01:31,520 --> 00:01:34,880
and we use machine learning on large

00:01:33,360 --> 00:01:36,880
corporate data sets

00:01:34,880 --> 00:01:38,000
to predict whether invoices will be paid

00:01:36,880 --> 00:01:40,479
in the future

00:01:38,000 --> 00:01:41,600
and then to finance invoices and improve

00:01:40,479 --> 00:01:44,799
the cash flow

00:01:41,600 --> 00:01:48,320
of small and medium enterprises

00:01:44,799 --> 00:01:49,280
uh i myself am a machine or yeah machine

00:01:48,320 --> 00:01:52,640
learning engineer

00:01:49,280 --> 00:01:54,640
principal um and

00:01:52,640 --> 00:01:56,240
my main responsibility is sort of

00:01:54,640 --> 00:01:57,840
integrating our machine learning

00:01:56,240 --> 00:02:00,399
algorithms into our

00:01:57,840 --> 00:02:02,560
invoice processing platform but i also

00:02:00,399 --> 00:02:06,159
do all sorts of other data

00:02:02,560 --> 00:02:08,000
integration pieces um operational

00:02:06,159 --> 00:02:11,280
tooling around the company just making

00:02:08,000 --> 00:02:15,200
sure everything works front to back

00:02:11,280 --> 00:02:17,280
um basically from this whole integration

00:02:15,200 --> 00:02:18,400
from these integration approaches i work

00:02:17,280 --> 00:02:20,879
with different

00:02:18,400 --> 00:02:23,280
people with very different mindsets

00:02:20,879 --> 00:02:25,680
working in different paradigms we've got

00:02:23,280 --> 00:02:27,440
closure engineers who are very much on

00:02:25,680 --> 00:02:28,160
the functional programming side and i

00:02:27,440 --> 00:02:30,080
picked up

00:02:28,160 --> 00:02:31,200
a lot of things from them that i found

00:02:30,080 --> 00:02:32,800
really useful

00:02:31,200 --> 00:02:34,560
but obviously there's a lot of object

00:02:32,800 --> 00:02:36,319
orientation going on

00:02:34,560 --> 00:02:38,879
in python as well and i kind of just

00:02:36,319 --> 00:02:40,800
want to share

00:02:38,879 --> 00:02:42,800
some of my learnings from bringing those

00:02:40,800 --> 00:02:44,959
together and what i found particularly

00:02:42,800 --> 00:02:49,120
useful

00:02:44,959 --> 00:02:50,959
so um there are four main

00:02:49,120 --> 00:02:52,160
things that i want to go into they all

00:02:50,959 --> 00:02:54,720
overlap a little bit

00:02:52,160 --> 00:02:56,239
because you can't and distill it fully

00:02:54,720 --> 00:02:59,280
away from each other

00:02:56,239 --> 00:03:00,560
but their code structure then data

00:02:59,280 --> 00:03:04,080
structures

00:03:00,560 --> 00:03:05,360
um how we deal with state handling and

00:03:04,080 --> 00:03:08,000
how we deal with multiple

00:03:05,360 --> 00:03:12,480
implementations for sort of the same

00:03:08,000 --> 00:03:12,480
uh the same concept the same problem

00:03:12,560 --> 00:03:15,840
right as some introduction we've

00:03:14,800 --> 00:03:18,879
basically said it

00:03:15,840 --> 00:03:21,840
to a degree already python itself is a

00:03:18,879 --> 00:03:23,040
multi-paradigm language unlike i

00:03:21,840 --> 00:03:25,440
mentioned closures

00:03:23,040 --> 00:03:27,360
on the functional programming side uh

00:03:25,440 --> 00:03:29,760
java is a good example on a sort of

00:03:27,360 --> 00:03:33,120
fully object oriented side

00:03:29,760 --> 00:03:35,519
python is very pragmatic very in between

00:03:33,120 --> 00:03:37,280
it doesn't buy into the dogmatic

00:03:35,519 --> 00:03:39,120
sticking to one side of it

00:03:37,280 --> 00:03:41,040
but just brings it all together unless

00:03:39,120 --> 00:03:43,120
you decide

00:03:41,040 --> 00:03:45,599
and an important point that i want to

00:03:43,120 --> 00:03:48,799
make before we get started is

00:03:45,599 --> 00:03:51,840
those two paradigms are concepts

00:03:48,799 --> 00:03:53,599
they're not a matter of syntax

00:03:51,840 --> 00:03:54,959
so just because something is written

00:03:53,599 --> 00:03:56,959
inside of a class

00:03:54,959 --> 00:03:59,040
doesn't mean it's properly object

00:03:56,959 --> 00:04:00,400
oriented and just because it's written

00:03:59,040 --> 00:04:03,680
in a standalone

00:04:00,400 --> 00:04:05,439
function or procedure even does

00:04:03,680 --> 00:04:07,760
definitely not mean it's functional

00:04:05,439 --> 00:04:11,439
programming

00:04:07,760 --> 00:04:13,840
so just a quick

00:04:11,439 --> 00:04:15,280
sort of trying to catch everyone in

00:04:13,840 --> 00:04:18,400
about the principles

00:04:15,280 --> 00:04:20,079
object orientation is from my

00:04:18,400 --> 00:04:21,440
point of view just revolves around this

00:04:20,079 --> 00:04:24,560
idea of mutable

00:04:21,440 --> 00:04:27,199
data structures that is things that we

00:04:24,560 --> 00:04:27,680
change in place that have a status a

00:04:27,199 --> 00:04:30,960
state

00:04:27,680 --> 00:04:33,360
that we change um it deals with that

00:04:30,960 --> 00:04:35,600
typically with a rich type system of

00:04:33,360 --> 00:04:38,080
classes that are interconnected

00:04:35,600 --> 00:04:39,199
in particular class hierarchies and the

00:04:38,080 --> 00:04:41,040
principles

00:04:39,199 --> 00:04:43,240
of object orientation which are

00:04:41,040 --> 00:04:47,600
inheritance abstraction

00:04:43,240 --> 00:04:47,600
encapsulation and polymorphism

00:04:48,960 --> 00:04:53,199
as much as object orientation is about

00:04:50,880 --> 00:04:54,720
mutable data structures

00:04:53,199 --> 00:04:57,440
functional programming is about

00:04:54,720 --> 00:05:00,880
immutable data structures

00:04:57,440 --> 00:05:01,919
and it typically relies on simple data

00:05:00,880 --> 00:05:04,400
types

00:05:01,919 --> 00:05:05,680
and uses pure functions pure functions

00:05:04,400 --> 00:05:08,160
means it's a function

00:05:05,680 --> 00:05:10,400
that has no side effects uses no global

00:05:08,160 --> 00:05:13,840
variables it's sort of encapsulated

00:05:10,400 --> 00:05:15,520
in itself and it's item-potent so

00:05:13,840 --> 00:05:18,160
if you call the same function with the

00:05:15,520 --> 00:05:20,479
same inputs you can always expect to

00:05:18,160 --> 00:05:23,039
get the same outputs no matter the state

00:05:20,479 --> 00:05:25,199
of any other part in the system

00:05:23,039 --> 00:05:27,199
that's sort of the core principle there

00:05:25,199 --> 00:05:29,680
um and often these things are

00:05:27,199 --> 00:05:30,720
evaluated lazy so you can sort of nest

00:05:29,680 --> 00:05:34,160
your function calls

00:05:30,720 --> 00:05:36,080
before they're even executed that's the

00:05:34,160 --> 00:05:38,000
the two sides of the principle

00:05:36,080 --> 00:05:39,360
and because this can be a bit dry i

00:05:38,000 --> 00:05:41,440
thought i'm gonna

00:05:39,360 --> 00:05:42,800
use an example going through the

00:05:41,440 --> 00:05:45,919
presentation i've

00:05:42,800 --> 00:05:47,520
chosen to pick sudoku which is sort of

00:05:45,919 --> 00:05:50,240
this

00:05:47,520 --> 00:05:51,520
uh a way of a number crossword riddle if

00:05:50,240 --> 00:05:53,919
you like

00:05:51,520 --> 00:05:54,639
it's a nine by nine grid uh with numbers

00:05:53,919 --> 00:05:58,160
from

00:05:54,639 --> 00:06:00,400
one to nine and each row column or

00:05:58,160 --> 00:06:01,759
or three by three block so each of these

00:06:00,400 --> 00:06:03,680
here

00:06:01,759 --> 00:06:05,280
should contain the numbers one through

00:06:03,680 --> 00:06:06,880
nine so and

00:06:05,280 --> 00:06:08,960
what you get here on the left side this

00:06:06,880 --> 00:06:09,360
is typically the the problem that you

00:06:08,960 --> 00:06:11,120
get

00:06:09,360 --> 00:06:12,720
and then you start filling in numbers

00:06:11,120 --> 00:06:17,120
till you've solved the whole thing

00:06:12,720 --> 00:06:19,680
and that is the solution to the sudoku

00:06:17,120 --> 00:06:21,360
now with that as a background let's dive

00:06:19,680 --> 00:06:23,759
right in

00:06:21,360 --> 00:06:24,639
so the first thing i want to talk about

00:06:23,759 --> 00:06:28,319
is code

00:06:24,639 --> 00:06:30,400
structure and the way i'm going to do

00:06:28,319 --> 00:06:30,880
this is sort of compare the oo and the

00:06:30,400 --> 00:06:33,199
fp

00:06:30,880 --> 00:06:35,840
side to one another and then sort of

00:06:33,199 --> 00:06:38,960
find a sensible middle ground maybe

00:06:35,840 --> 00:06:42,000
try to take the best of both

00:06:38,960 --> 00:06:44,479
um we're going to start from this uh

00:06:42,000 --> 00:06:45,280
this string here which is a sudoku

00:06:44,479 --> 00:06:48,560
definition

00:06:45,280 --> 00:06:51,199
as per this open sudoku website

00:06:48,560 --> 00:06:53,039
just to be clear how we understand this

00:06:51,199 --> 00:06:55,919
the first nine digits

00:06:53,039 --> 00:06:56,560
are sort of the first row of the sudoku

00:06:55,919 --> 00:06:58,560
riddle

00:06:56,560 --> 00:06:59,919
the second nine and the second line and

00:06:58,560 --> 00:07:03,680
so forth so this

00:06:59,919 --> 00:07:05,199
fully describes the original state

00:07:03,680 --> 00:07:07,360
and i'm just going to run this because

00:07:05,199 --> 00:07:10,240
all the code in this thing

00:07:07,360 --> 00:07:11,039
is run live i do have some more code

00:07:10,240 --> 00:07:13,280
files in the

00:07:11,039 --> 00:07:15,039
in in the background just to keep the

00:07:13,280 --> 00:07:16,479
implementations like short and narrow

00:07:15,039 --> 00:07:18,560
here uh but i'm

00:07:16,479 --> 00:07:20,479
um that's all shared along with the

00:07:18,560 --> 00:07:22,240
slides on its own repo so you can

00:07:20,479 --> 00:07:24,800
later on have a play around with it

00:07:22,240 --> 00:07:28,400
yourself if you like as well

00:07:24,800 --> 00:07:30,880
okay without further ado uh 100

00:07:28,400 --> 00:07:32,240
way to implement this would be a factory

00:07:30,880 --> 00:07:35,759
function so i'm going to

00:07:32,240 --> 00:07:36,800
create a sudoku class here and for for

00:07:35,759 --> 00:07:39,680
now i'm just

00:07:36,800 --> 00:07:41,759
going to put a grid an array on there

00:07:39,680 --> 00:07:44,720
which is the 9x9 grid

00:07:41,759 --> 00:07:46,240
i'm going to change that later but then

00:07:44,720 --> 00:07:46,800
i'm going to add this from string

00:07:46,240 --> 00:07:49,280
function

00:07:46,800 --> 00:07:50,720
as a as a static method or as a class

00:07:49,280 --> 00:07:53,759
method onto this

00:07:50,720 --> 00:07:55,599
so i'm explicitly putting this function

00:07:53,759 --> 00:07:57,360
onto this class in a in an

00:07:55,599 --> 00:07:59,360
object-oriented way

00:07:57,360 --> 00:08:01,520
and then i can use it like this with the

00:07:59,360 --> 00:08:04,240
example that we've just seen

00:08:01,520 --> 00:08:04,879
um and what i'm getting is obviously an

00:08:04,240 --> 00:08:07,840
instance of

00:08:04,879 --> 00:08:08,319
sudoku where the grid is this nine by

00:08:07,840 --> 00:08:12,319
nine

00:08:08,319 --> 00:08:15,120
array the

00:08:12,319 --> 00:08:17,360
this is fairly explicit high context

00:08:15,120 --> 00:08:17,840
which makes it very easy to find and use

00:08:17,360 --> 00:08:19,919
like

00:08:17,840 --> 00:08:21,440
everyone's seen this kind of thing knows

00:08:19,919 --> 00:08:24,560
how to use it how to

00:08:21,440 --> 00:08:25,599
even start it because most ides allow

00:08:24,560 --> 00:08:29,360
you to just go

00:08:25,599 --> 00:08:32,880
sudoku dot and you find your

00:08:29,360 --> 00:08:34,640
you find that functionality now

00:08:32,880 --> 00:08:36,640
in the functional world how would you do

00:08:34,640 --> 00:08:37,440
it you would actually isolate that

00:08:36,640 --> 00:08:40,080
function

00:08:37,440 --> 00:08:41,839
and write something like this i'm going

00:08:40,080 --> 00:08:42,320
to go into the implementation a little

00:08:41,839 --> 00:08:45,600
bit

00:08:42,320 --> 00:08:49,680
more just after this but it just

00:08:45,600 --> 00:08:52,880
stands on its own in an item-potent way

00:08:49,680 --> 00:08:56,560
and you can use it by just applying it

00:08:52,880 --> 00:08:58,160
to your input gives you a grid

00:08:56,560 --> 00:09:00,080
but it's just the grid it doesn't know

00:08:58,160 --> 00:09:03,519
it's a sudoku we'll go into that

00:09:00,080 --> 00:09:06,160
a bit further down the line as well so

00:09:03,519 --> 00:09:07,440
this is entirely free of any assumptions

00:09:06,160 --> 00:09:09,760
about the use case

00:09:07,440 --> 00:09:11,200
and because of that it's really easy to

00:09:09,760 --> 00:09:13,519
reuse or generalize

00:09:11,200 --> 00:09:14,880
so i could parse completely different

00:09:13,519 --> 00:09:16,880
things from a sudoku

00:09:14,880 --> 00:09:19,920
with that exact same function because it

00:09:16,880 --> 00:09:22,800
doesn't know of its context

00:09:19,920 --> 00:09:24,800
so how do we bring that together and

00:09:22,800 --> 00:09:28,000
that is

00:09:24,800 --> 00:09:30,320
a way that i like to doing this is

00:09:28,000 --> 00:09:32,320
saying we have this function here we

00:09:30,320 --> 00:09:34,880
keep the pure function with all of it

00:09:32,320 --> 00:09:36,399
its benefits in fact they even went as

00:09:34,880 --> 00:09:38,800
far here and said i'm going to

00:09:36,399 --> 00:09:40,080
generalize this to any square matrix and

00:09:38,800 --> 00:09:42,880
be able to pass

00:09:40,080 --> 00:09:45,600
any square matrix with this but we can

00:09:42,880 --> 00:09:48,320
also create our sudoku class

00:09:45,600 --> 00:09:49,360
and essentially just use this function

00:09:48,320 --> 00:09:52,959
on the class

00:09:49,360 --> 00:09:56,560
to have this sort of high context

00:09:52,959 --> 00:10:00,320
uh use case as well so what we end up is

00:09:56,560 --> 00:10:02,480
we've got both um makes our

00:10:00,320 --> 00:10:04,160
code very tidy and reusable because it's

00:10:02,480 --> 00:10:06,880
nicely chunked up

00:10:04,160 --> 00:10:08,480
it generalizes really well because i've

00:10:06,880 --> 00:10:11,360
demonstrated it here by just

00:10:08,480 --> 00:10:13,519
generalizing this function

00:10:11,360 --> 00:10:14,560
it works in any context it works for any

00:10:13,519 --> 00:10:16,480
user

00:10:14,560 --> 00:10:18,000
and because you still have the high

00:10:16,480 --> 00:10:21,519
context class it's

00:10:18,000 --> 00:10:24,399
very easy to use and explore as well so

00:10:21,519 --> 00:10:26,560
from my point of view this is sort of a

00:10:24,399 --> 00:10:30,399
good way of just bringing

00:10:26,560 --> 00:10:30,399
together the best of both worlds

00:10:30,880 --> 00:10:37,200
okay let's look at the implementation

00:10:34,320 --> 00:10:39,680
and you you can probably guess it from

00:10:37,200 --> 00:10:39,680
the title

00:10:39,920 --> 00:10:45,360
the object oriented or it's really more

00:10:43,519 --> 00:10:46,079
from a procedural world but following

00:10:45,360 --> 00:10:49,040
the mutable

00:10:46,079 --> 00:10:50,240
data principle the approach would here

00:10:49,040 --> 00:10:52,720
would be

00:10:50,240 --> 00:10:54,000
you create an empty array at first with

00:10:52,720 --> 00:10:57,040
the outputs

00:10:54,000 --> 00:10:58,160
then you iterate over the inputs that

00:10:57,040 --> 00:11:01,200
you have

00:10:58,160 --> 00:11:01,680
and append to your outputs for every for

00:11:01,200 --> 00:11:04,720
every

00:11:01,680 --> 00:11:05,839
digit that you have in the input works

00:11:04,720 --> 00:11:08,560
fine

00:11:05,839 --> 00:11:08,959
um but this one here comes to mind for

00:11:08,560 --> 00:11:10,560
me

00:11:08,959 --> 00:11:12,640
i would have written it shorter but i

00:11:10,560 --> 00:11:15,519
didn't have the time that is

00:11:12,640 --> 00:11:16,480
because i find this very easy to write

00:11:15,519 --> 00:11:18,560
but it can be a

00:11:16,480 --> 00:11:19,680
bit tedious to read and reconstruct

00:11:18,560 --> 00:11:21,839
construct so

00:11:19,680 --> 00:11:23,279
looking at this what was actually the

00:11:21,839 --> 00:11:26,240
high level intention what

00:11:23,279 --> 00:11:28,320
was meant to be be done and then because

00:11:26,240 --> 00:11:29,120
you're fairly explicit about the the

00:11:28,320 --> 00:11:31,680
variables

00:11:29,120 --> 00:11:32,560
and and the appending this can be quite

00:11:31,680 --> 00:11:34,800
error prone

00:11:32,560 --> 00:11:37,519
and if you write this kind of thing a

00:11:34,800 --> 00:11:40,720
lot you probably know what i mean

00:11:37,519 --> 00:11:42,160
but what's the alternative and that's

00:11:40,720 --> 00:11:43,279
the piece that i really like from the

00:11:42,160 --> 00:11:46,160
functional world

00:11:43,279 --> 00:11:48,079
that is the idea of mapping because what

00:11:46,160 --> 00:11:50,880
we really wanted to do there

00:11:48,079 --> 00:11:52,240
was take our inputs and apply this

00:11:50,880 --> 00:11:56,959
integer function

00:11:52,240 --> 00:12:00,720
to each element in the input sequence

00:11:56,959 --> 00:12:04,079
now a little disclaimer int is actually

00:12:00,720 --> 00:12:06,079
uh a class it just acts like a function

00:12:04,079 --> 00:12:08,240
which kind of just proves the point that

00:12:06,079 --> 00:12:11,040
python is multi-paradigm but i'm just

00:12:08,240 --> 00:12:13,279
going to leave that aside for now

00:12:11,040 --> 00:12:14,639
so what are we doing here we're mapping

00:12:13,279 --> 00:12:16,880
so we're applying

00:12:14,639 --> 00:12:18,079
the this in i'm just going to call it

00:12:16,880 --> 00:12:20,639
function we're

00:12:18,079 --> 00:12:21,519
mapping the int function over our inputs

00:12:20,639 --> 00:12:23,519
and just

00:12:21,519 --> 00:12:24,959
because like i said earlier this is a

00:12:23,519 --> 00:12:28,079
lazy operation which is

00:12:24,959 --> 00:12:30,560
forced to be a tuple uh which makes it

00:12:28,079 --> 00:12:32,959
non-lazy and then we've got our output

00:12:30,560 --> 00:12:35,839
values here

00:12:32,959 --> 00:12:38,000
if that's a bit unclear sort of in with

00:12:35,839 --> 00:12:39,680
the order of execution there is a trick

00:12:38,000 --> 00:12:41,120
that i like to use from the tools

00:12:39,680 --> 00:12:43,519
library

00:12:41,120 --> 00:12:44,639
which is we can just force this to be

00:12:43,519 --> 00:12:46,959
left to right

00:12:44,639 --> 00:12:47,680
with this thread last function which is

00:12:46,959 --> 00:12:50,160
essentially

00:12:47,680 --> 00:12:52,320
creating a pipeline from left to right

00:12:50,160 --> 00:12:54,560
saying take our raw examples

00:12:52,320 --> 00:12:56,320
map it over the int function and then

00:12:54,560 --> 00:12:59,519
turn it all into a tuple two

00:12:56,320 --> 00:12:59,519
to collect the outputs

00:12:59,600 --> 00:13:03,760
so um this is a comparatively concise

00:13:03,279 --> 00:13:05,920
way

00:13:03,760 --> 00:13:07,040
of expressing the same thing that we had

00:13:05,920 --> 00:13:09,519
before

00:13:07,040 --> 00:13:11,360
and it's really much closer to the

00:13:09,519 --> 00:13:12,639
intention because what we wanted to do

00:13:11,360 --> 00:13:16,399
was just to apply this

00:13:12,639 --> 00:13:17,200
uh this function integer to all of our

00:13:16,399 --> 00:13:19,120
inputs which is

00:13:17,200 --> 00:13:21,040
exactly what we're saying here we're not

00:13:19,120 --> 00:13:24,079
telling it to loop

00:13:21,040 --> 00:13:25,120
um i think that makes it really easy to

00:13:24,079 --> 00:13:27,760
read

00:13:25,120 --> 00:13:29,360
you might disagree at this point which i

00:13:27,760 --> 00:13:30,959
did as well when i saw it for the very

00:13:29,360 --> 00:13:33,600
first time

00:13:30,959 --> 00:13:34,000
but once you're used to the syntax this

00:13:33,600 --> 00:13:36,720
becomes

00:13:34,000 --> 00:13:38,639
much much easier to read than those

00:13:36,720 --> 00:13:40,480
tedious for loops

00:13:38,639 --> 00:13:42,399
it can take a little longer to write

00:13:40,480 --> 00:13:45,120
though because you have to be

00:13:42,399 --> 00:13:45,760
a bit clearer about the actual intention

00:13:45,120 --> 00:13:48,079
i have to

00:13:45,760 --> 00:13:49,519
try to abstract things a bit more but i

00:13:48,079 --> 00:13:53,279
would argue that's a good thing and it

00:13:49,519 --> 00:13:53,279
makes you a better software engineer

00:13:53,360 --> 00:14:00,240
so um yeah just as a side note

00:13:57,920 --> 00:14:01,600
python has this great syntax of list

00:14:00,240 --> 00:14:04,720
comprehensions as well

00:14:01,600 --> 00:14:06,959
which is uh

00:14:04,720 --> 00:14:09,600
a bit of a mix of both worlds and it

00:14:06,959 --> 00:14:12,320
works really well as well

00:14:09,600 --> 00:14:14,240
it's kind of easy to read and write but

00:14:12,320 --> 00:14:16,000
you really have to be careful never use

00:14:14,240 --> 00:14:18,480
lambda functions inside of list

00:14:16,000 --> 00:14:21,680
comprehensions also never define

00:14:18,480 --> 00:14:24,160
functions within a for loop by the way

00:14:21,680 --> 00:14:25,680
because those won't behave as you want

00:14:24,160 --> 00:14:28,959
them to

00:14:25,680 --> 00:14:30,880
i'll leave that as as it stands and

00:14:28,959 --> 00:14:32,079
if you do things like that just make

00:14:30,880 --> 00:14:33,680
sure

00:14:32,079 --> 00:14:36,000
those don't get too long and too

00:14:33,680 --> 00:14:37,040
complicated because you do want it to be

00:14:36,000 --> 00:14:39,600
easy to read

00:14:37,040 --> 00:14:41,120
so pull any sort of more intricate logic

00:14:39,600 --> 00:14:43,279
out into its own function

00:14:41,120 --> 00:14:46,320
and then use the function inside the

00:14:43,279 --> 00:14:50,560
list comprehension or inside your

00:14:46,320 --> 00:14:53,760
pipeline from earlier right

00:14:50,560 --> 00:14:56,240
just another quick example on this

00:14:53,760 --> 00:14:57,279
the opposite of parsing just or not

00:14:56,240 --> 00:14:59,920
quite the opposite

00:14:57,279 --> 00:15:02,639
but similarly when we want to take our

00:14:59,920 --> 00:15:05,519
internal object and just display it

00:15:02,639 --> 00:15:08,079
in the object-oriented world we would

00:15:05,519 --> 00:15:09,600
implement this representation function

00:15:08,079 --> 00:15:12,399
which i've done here in this class that

00:15:09,600 --> 00:15:15,600
i'm loading

00:15:12,399 --> 00:15:18,160
and then once we've done that it's

00:15:15,600 --> 00:15:19,040
straightforward we just let this thing

00:15:18,160 --> 00:15:20,880
display

00:15:19,040 --> 00:15:22,160
there's no further thing that we need to

00:15:20,880 --> 00:15:24,800
do this is a built-in

00:15:22,160 --> 00:15:26,160
this is this behaves clever so that

00:15:24,800 --> 00:15:29,600
makes it really easy to

00:15:26,160 --> 00:15:31,360
to get a nice representation the

00:15:29,600 --> 00:15:34,000
functional way there is a bit more

00:15:31,360 --> 00:15:36,800
explicit in that we would say

00:15:34,000 --> 00:15:38,560
well to really get this sudoku all the

00:15:36,800 --> 00:15:41,199
way i'm using the pipeline again

00:15:38,560 --> 00:15:41,759
we're taking our raw input we're pausing

00:15:41,199 --> 00:15:43,920
it to

00:15:41,759 --> 00:15:46,000
the internal format then we're

00:15:43,920 --> 00:15:49,519
formatting it for display

00:15:46,000 --> 00:15:51,839
and then we're printing it um

00:15:49,519 --> 00:15:53,600
i explicitly kept printing outside of

00:15:51,839 --> 00:15:57,199
there because printing

00:15:53,600 --> 00:15:58,560
per se is a side effect so i don't want

00:15:57,199 --> 00:16:01,279
it in this function to keep this

00:15:58,560 --> 00:16:01,279
function pure

00:16:02,240 --> 00:16:06,560
that being said the output is kind of

00:16:04,639 --> 00:16:09,839
the same

00:16:06,560 --> 00:16:09,839
well it's exactly the same

00:16:11,440 --> 00:16:16,880
so the multi-paradigm is always

00:16:14,639 --> 00:16:18,720
yeah why don't we just do both or take

00:16:16,880 --> 00:16:22,000
the best of both

00:16:18,720 --> 00:16:24,320
and here similar approach just define

00:16:22,000 --> 00:16:25,600
the function as as a pure function

00:16:24,320 --> 00:16:29,759
reusable

00:16:25,600 --> 00:16:31,759
and then enhance your sudoku class by

00:16:29,759 --> 00:16:34,720
using that function so keep the class a

00:16:31,759 --> 00:16:37,040
bit shallower and keep your

00:16:34,720 --> 00:16:39,279
sort of reusable chunks of logic outside

00:16:37,040 --> 00:16:39,279
of it

00:16:39,600 --> 00:16:42,959
okay that's as much as i want to say

00:16:41,680 --> 00:16:45,839
about the first part

00:16:42,959 --> 00:16:46,720
let's look a bit more at data structures

00:16:45,839 --> 00:16:49,920
and here

00:16:46,720 --> 00:16:51,040
so you see the example sort of going

00:16:49,920 --> 00:16:54,240
forward

00:16:51,040 --> 00:16:56,880
now we're going to use that sudoku grid

00:16:54,240 --> 00:16:58,639
up till now i just modeled it as a as an

00:16:56,880 --> 00:17:01,360
array

00:16:58,639 --> 00:17:01,759
but let's see what we can actually do in

00:17:01,360 --> 00:17:03,600
an

00:17:01,759 --> 00:17:05,600
object-oriented context you might want

00:17:03,600 --> 00:17:08,480
to do something like this

00:17:05,600 --> 00:17:10,319
you might want to model each sort of

00:17:08,480 --> 00:17:13,600
small square with a digit

00:17:10,319 --> 00:17:16,000
as this square class

00:17:13,600 --> 00:17:16,880
then you might want to create an

00:17:16,000 --> 00:17:19,199
abstract

00:17:16,880 --> 00:17:20,799
square collection which just ties a

00:17:19,199 --> 00:17:23,039
number of these together

00:17:20,799 --> 00:17:24,480
typically nine for rows columns and

00:17:23,039 --> 00:17:27,199
blocks

00:17:24,480 --> 00:17:29,440
but if you want more well a sudoku is

00:17:27,199 --> 00:17:29,760
really a collection of 81 squares as

00:17:29,440 --> 00:17:33,280
well

00:17:29,760 --> 00:17:35,679
9x9 um but to make it all

00:17:33,280 --> 00:17:38,480
nice and explicit you would say well

00:17:35,679 --> 00:17:40,400
sudoku is also really

00:17:38,480 --> 00:17:42,080
knows its other square collections it

00:17:40,400 --> 00:17:44,320
knows its rows its columns

00:17:42,080 --> 00:17:46,320
it blocks so you you've got a very

00:17:44,320 --> 00:17:48,720
explicit structure there that you can

00:17:46,320 --> 00:17:48,720
work with

00:17:48,799 --> 00:17:53,039
so that gives us this nice instance here

00:17:51,760 --> 00:17:55,440
that where we can say well

00:17:53,039 --> 00:17:57,280
just give me your eighth row or give me

00:17:55,440 --> 00:17:58,640
a particular square give me all the

00:17:57,280 --> 00:18:01,200
information about it

00:17:58,640 --> 00:18:03,039
in this case we know where the square is

00:18:01,200 --> 00:18:03,919
what the digit is that is currently

00:18:03,039 --> 00:18:06,240
filled in

00:18:03,919 --> 00:18:07,919
and whether it's locked so whether this

00:18:06,240 --> 00:18:10,720
was

00:18:07,919 --> 00:18:12,480
whether this was an input from our

00:18:10,720 --> 00:18:15,840
original thing or maybe something we

00:18:12,480 --> 00:18:15,840
filled in later on

00:18:16,000 --> 00:18:20,799
right so that assumes

00:18:19,120 --> 00:18:23,440
certain usage patterns because you're

00:18:20,799 --> 00:18:27,039
putting a lot of context into it

00:18:23,440 --> 00:18:29,600
um that in turn makes it very intuitive

00:18:27,039 --> 00:18:31,919
to explore but it's also fairly rigid

00:18:29,600 --> 00:18:33,760
and it requires a lot of boilerplate

00:18:31,919 --> 00:18:35,600
proof is here the implementation of this

00:18:33,760 --> 00:18:39,120
was 120 lines

00:18:35,600 --> 00:18:43,200
um just for sort of

00:18:39,120 --> 00:18:46,400
defining the classes setups etc

00:18:43,200 --> 00:18:48,400
so what's the alternative uh functional

00:18:46,400 --> 00:18:50,559
programming is all about simplicity

00:18:48,400 --> 00:18:52,640
so here we just say you know what this

00:18:50,559 --> 00:18:55,440
thing is a nine by nine grid

00:18:52,640 --> 00:18:56,000
it's a grid of shape nine by nine and of

00:18:55,440 --> 00:19:00,080
data type

00:18:56,000 --> 00:19:02,640
int done so three lines instead of 120

00:19:00,080 --> 00:19:05,120
very simplistic we can use it in the

00:19:02,640 --> 00:19:07,600
same way as before so after we've passed

00:19:05,120 --> 00:19:10,799
our input we can validate it

00:19:07,600 --> 00:19:13,280
with this thing again this is a well

00:19:10,799 --> 00:19:15,200
schema is a multi-paradigm uh language

00:19:13,280 --> 00:19:16,480
in its own right which is why we have

00:19:15,200 --> 00:19:18,400
sort of a

00:19:16,480 --> 00:19:20,320
instance method here so you can always

00:19:18,400 --> 00:19:22,960
do your chain with those as well

00:19:20,320 --> 00:19:24,880
as long as they're immutable well we get

00:19:22,960 --> 00:19:27,520
to that

00:19:24,880 --> 00:19:28,240
um so this is a very minimalist approach

00:19:27,520 --> 00:19:32,160
obviously

00:19:28,240 --> 00:19:34,240
with zero or close to zero boilerplate

00:19:32,160 --> 00:19:35,760
there is absolutely no structure no

00:19:34,240 --> 00:19:39,200
context on

00:19:35,760 --> 00:19:39,760
on the data structure itself beyond this

00:19:39,200 --> 00:19:42,720
is a nine

00:19:39,760 --> 00:19:44,000
by nine grid which can make it a bit

00:19:42,720 --> 00:19:46,320
harder to explore

00:19:44,000 --> 00:19:47,679
but it also makes it easier to reuse as

00:19:46,320 --> 00:19:51,200
i kind of

00:19:47,679 --> 00:19:52,480
pointed towards before so but what's the

00:19:51,200 --> 00:19:55,679
best of both

00:19:52,480 --> 00:20:00,000
um and i can obviously only give my

00:19:55,679 --> 00:20:03,360
a very opinionated answer but here we go

00:20:00,000 --> 00:20:05,600
so why don't we create a sudoku class

00:20:03,360 --> 00:20:09,200
that gives the whole thing some context

00:20:05,600 --> 00:20:11,440
similar like i did it did before

00:20:09,200 --> 00:20:12,799
but actually underneath that there is

00:20:11,440 --> 00:20:14,080
just the grid so we're using the

00:20:12,799 --> 00:20:16,480
simplicity there

00:20:14,080 --> 00:20:18,400
and we don't model all these rows

00:20:16,480 --> 00:20:21,760
columns collections

00:20:18,400 --> 00:20:23,840
uh explicitly that's implementation

00:20:21,760 --> 00:20:26,880
detail and we can do that in a very

00:20:23,840 --> 00:20:29,200
very elegant simplistic way

00:20:26,880 --> 00:20:29,919
but we then do tie it together on this

00:20:29,200 --> 00:20:32,720
class

00:20:29,919 --> 00:20:33,200
maybe have some nice um functionality on

00:20:32,720 --> 00:20:36,480
here

00:20:33,200 --> 00:20:37,520
and adds context and just um brings it

00:20:36,480 --> 00:20:40,320
all together

00:20:37,520 --> 00:20:43,679
i like to call it like a shallow wiring

00:20:40,320 --> 00:20:46,320
class or anything like that

00:20:43,679 --> 00:20:46,960
yes i said that here as well so it saves

00:20:46,320 --> 00:20:48,960
a lot of

00:20:46,960 --> 00:20:50,400
code but it does have the context for

00:20:48,960 --> 00:20:53,520
the user

00:20:50,400 --> 00:20:56,159
and at the same time comes with all the

00:20:53,520 --> 00:20:58,159
benefits of being able to sort of take

00:20:56,159 --> 00:21:02,880
small chunks of your logic take them out

00:20:58,159 --> 00:21:06,640
make them reusable and concise

00:21:02,880 --> 00:21:09,440
okay um on to the next part about

00:21:06,640 --> 00:21:10,640
state handling here it's going to be

00:21:09,440 --> 00:21:12,799
about

00:21:10,640 --> 00:21:15,360
we have the sudoku now we have a grid

00:21:12,799 --> 00:21:17,360
we've passed it from an input source

00:21:15,360 --> 00:21:19,360
uh but now we want to start filling

00:21:17,360 --> 00:21:21,760
things in because at the end of the talk

00:21:19,360 --> 00:21:22,799
uh we kind of want to have a solver that

00:21:21,760 --> 00:21:25,600
automatically

00:21:22,799 --> 00:21:26,880
solves that sudoku so let's think about

00:21:25,600 --> 00:21:30,080
the next step how do we

00:21:26,880 --> 00:21:31,520
fill in the digits and for this

00:21:30,080 --> 00:21:33,200
i'm using a multi-paradigm

00:21:31,520 --> 00:21:36,799
implementation right away

00:21:33,200 --> 00:21:38,480
inspired by pandas and it's um in place

00:21:36,799 --> 00:21:40,400
concept because i think that just

00:21:38,480 --> 00:21:43,280
showcases very nicely

00:21:40,400 --> 00:21:45,760
what mutable and immutable means and

00:21:43,280 --> 00:21:47,760
also that it's not necessarily tied to

00:21:45,760 --> 00:21:49,840
a certain syntax it's all one classes

00:21:47,760 --> 00:21:52,799
here

00:21:49,840 --> 00:21:55,600
um so i'm just gonna create a blank

00:21:52,799 --> 00:21:57,840
sudoku here just blank nine by nine grid

00:21:55,600 --> 00:22:00,080
so i can show you a few operations on

00:21:57,840 --> 00:22:00,080
that

00:22:02,320 --> 00:22:10,880
the mutable way of interacting with this

00:22:07,120 --> 00:22:13,200
is change it in place so

00:22:10,880 --> 00:22:14,400
i've made it explicit here by saying in

00:22:13,200 --> 00:22:17,600
place equals true

00:22:14,400 --> 00:22:19,600
and we're setting at x y zero zero so

00:22:17,600 --> 00:22:21,039
at the top left corner we're setting a

00:22:19,600 --> 00:22:22,799
seven

00:22:21,039 --> 00:22:24,240
and then well the seven is in this

00:22:22,799 --> 00:22:27,200
sudoku

00:22:24,240 --> 00:22:27,600
done dusted um so we've changed it in

00:22:27,200 --> 00:22:31,200
place

00:22:27,600 --> 00:22:34,960
that seems natural like duh i changed it

00:22:31,200 --> 00:22:35,360
now it's changed um it means there is no

00:22:34,960 --> 00:22:37,760
way

00:22:35,360 --> 00:22:40,240
back no no history we're changing

00:22:37,760 --> 00:22:44,080
everything as we go along

00:22:40,240 --> 00:22:46,320
um but what is the alternative

00:22:44,080 --> 00:22:47,919
so there the alternative isn't the

00:22:46,320 --> 00:22:51,360
immutable way

00:22:47,919 --> 00:22:53,200
of saying in place false so here we're

00:22:51,360 --> 00:22:56,480
saying we're setting this digit

00:22:53,200 --> 00:22:58,880
but actually not on this sudoku

00:22:56,480 --> 00:22:59,679
instead what we're getting back is this

00:22:58,880 --> 00:23:03,919
new

00:22:59,679 --> 00:23:07,600
sudoku here with the digit 4

00:23:03,919 --> 00:23:10,000
set um

00:23:07,600 --> 00:23:11,440
the big difference probably only shows

00:23:10,000 --> 00:23:14,080
up when i then go and say

00:23:11,440 --> 00:23:15,919
wait but what was the sudoku and that's

00:23:14,080 --> 00:23:17,039
still as it was before where we have the

00:23:15,919 --> 00:23:20,640
seven filled in

00:23:17,039 --> 00:23:22,960
but we don't have the four filled in yet

00:23:20,640 --> 00:23:24,559
so we we now have two different versions

00:23:22,960 --> 00:23:27,280
of it

00:23:24,559 --> 00:23:27,919
and that makes it really easy to use

00:23:27,280 --> 00:23:31,200
this

00:23:27,919 --> 00:23:34,880
parallelize this it's very efficient

00:23:31,200 --> 00:23:37,600
avoids any concurrency errors because

00:23:34,880 --> 00:23:38,320
you simply have to synchronize less

00:23:37,600 --> 00:23:40,159
state

00:23:38,320 --> 00:23:41,440
between any nodes that makes it

00:23:40,159 --> 00:23:44,080
efficient and also

00:23:41,440 --> 00:23:45,200
helps with the errors uh i could

00:23:44,080 --> 00:23:47,440
probably give a

00:23:45,200 --> 00:23:50,480
whole talk on why that's the case but

00:23:47,440 --> 00:23:51,120
let's keep that aside um because you

00:23:50,480 --> 00:23:53,200
have this

00:23:51,120 --> 00:23:54,720
before after picture as well that gives

00:23:53,200 --> 00:23:57,840
you some natural

00:23:54,720 --> 00:23:58,960
versioning and also like like i've shown

00:23:57,840 --> 00:24:01,440
before with

00:23:58,960 --> 00:24:02,159
pipelines it lends itself very well to

00:24:01,440 --> 00:24:04,320
that

00:24:02,159 --> 00:24:07,120
but it also in this in this

00:24:04,320 --> 00:24:09,440
multi-paradigm syntax with classes

00:24:07,120 --> 00:24:10,159
lends itself very well to method

00:24:09,440 --> 00:24:12,080
training

00:24:10,159 --> 00:24:13,520
and that's uh one thing that i want to

00:24:12,080 --> 00:24:15,760
highlight

00:24:13,520 --> 00:24:17,279
is now you can do something like this

00:24:15,760 --> 00:24:19,440
say sudoku

00:24:17,279 --> 00:24:21,600
said digit said another said another

00:24:19,440 --> 00:24:24,159
digit and what you're getting back

00:24:21,600 --> 00:24:25,200
is obviously this change thing with

00:24:24,159 --> 00:24:28,080
these

00:24:25,200 --> 00:24:29,360
digits set but also we've not changed

00:24:28,080 --> 00:24:32,480
the original one

00:24:29,360 --> 00:24:34,400
so you could from there try to solve the

00:24:32,480 --> 00:24:35,360
whole thing and then go ah maybe i did

00:24:34,400 --> 00:24:37,360
something wrong

00:24:35,360 --> 00:24:38,880
backtrack to the original version or to

00:24:37,360 --> 00:24:41,919
a version before

00:24:38,880 --> 00:24:46,480
you can save versions this can be really

00:24:41,919 --> 00:24:51,279
handy in different application contexts

00:24:46,480 --> 00:24:54,159
so uh my recommendation is

00:24:51,279 --> 00:24:56,159
um i learned a lot from bringing more

00:24:54,159 --> 00:24:58,840
functional programming into

00:24:56,159 --> 00:25:00,640
my code and making it by that more

00:24:58,840 --> 00:25:02,960
multi-paradigm

00:25:00,640 --> 00:25:03,840
and the idea of immutable data

00:25:02,960 --> 00:25:05,440
structures

00:25:03,840 --> 00:25:06,960
really really helps with a lot of

00:25:05,440 --> 00:25:10,640
applications i find

00:25:06,960 --> 00:25:11,840
so try out things like a frozen data

00:25:10,640 --> 00:25:14,080
class

00:25:11,840 --> 00:25:15,360
named tuples which are essentially sort

00:25:14,080 --> 00:25:18,240
of

00:25:15,360 --> 00:25:19,840
kind of act like dictionaries and like

00:25:18,240 --> 00:25:23,679
tuples at the same time

00:25:19,840 --> 00:25:26,320
but they're immutable uh frozen dick and

00:25:23,679 --> 00:25:27,520
frozen and persistent map are

00:25:26,320 --> 00:25:31,200
probably

00:25:27,520 --> 00:25:33,440
the uh the equivalent yeah they are

00:25:31,200 --> 00:25:37,039
probably the same which is a frozen

00:25:33,440 --> 00:25:40,080
equivalent of a dictionary

00:25:37,039 --> 00:25:42,960
um then we've got

00:25:40,080 --> 00:25:44,320
yeah use mutable data structures in

00:25:42,960 --> 00:25:47,520
immutable ways as well

00:25:44,320 --> 00:25:51,039
so if you have a dictionary

00:25:47,520 --> 00:25:53,600
then still maybe don't set

00:25:51,039 --> 00:25:54,240
things in place but rather use something

00:25:53,600 --> 00:25:56,159
from this

00:25:54,240 --> 00:25:57,919
tools library which i've mentioned

00:25:56,159 --> 00:26:01,200
before because it's

00:25:57,919 --> 00:26:03,919
it's my favorite library in python

00:26:01,200 --> 00:26:04,880
and there's sort of associate functions

00:26:03,919 --> 00:26:07,520
for example where

00:26:04,880 --> 00:26:09,520
you have you give it your input

00:26:07,520 --> 00:26:11,600
dictionary a key and a value and what

00:26:09,520 --> 00:26:14,400
you get back is a new dictionary

00:26:11,600 --> 00:26:16,640
with that additional key and value pair

00:26:14,400 --> 00:26:19,919
set

00:26:16,640 --> 00:26:21,840
um also an idea try to keep functions

00:26:19,919 --> 00:26:22,720
pure and id important try to pull them

00:26:21,840 --> 00:26:25,279
out of

00:26:22,720 --> 00:26:26,159
your classes and make them very reusable

00:26:25,279 --> 00:26:28,480
and then

00:26:26,159 --> 00:26:30,159
use classes where configuration and

00:26:28,480 --> 00:26:34,880
state is more required or

00:26:30,159 --> 00:26:37,440
desired to wire it all together

00:26:34,880 --> 00:26:38,559
um just one more example of how this

00:26:37,440 --> 00:26:41,760
works in pandas

00:26:38,559 --> 00:26:42,559
i'm just going to create um a data frame

00:26:41,760 --> 00:26:45,600
here and

00:26:42,559 --> 00:26:48,240
just a couple of random numbers

00:26:45,600 --> 00:26:49,360
but then i can do a nice message saying

00:26:48,240 --> 00:26:52,320
here saying

00:26:49,360 --> 00:26:54,000
assign a new column assign another new

00:26:52,320 --> 00:26:57,120
column based on that one

00:26:54,000 --> 00:27:00,480
you work a lot with lambdas on these

00:26:57,120 --> 00:27:02,480
and then maybe drop some rows and

00:27:00,480 --> 00:27:04,559
that gives me this output here don't

00:27:02,480 --> 00:27:05,279
worry too much about the content it's

00:27:04,559 --> 00:27:08,000
just a

00:27:05,279 --> 00:27:11,039
dummy example but also we still have the

00:27:08,000 --> 00:27:13,919
unchanged original data frame

00:27:11,039 --> 00:27:15,840
and that i found extremely helpful when

00:27:13,919 --> 00:27:18,399
dealing with jupiter notebooks

00:27:15,840 --> 00:27:20,720
because people tend to jump around in

00:27:18,399 --> 00:27:23,840
jupiter notebooks are not just executed

00:27:20,720 --> 00:27:24,559
sort of front to back top down but if

00:27:23,840 --> 00:27:27,840
you want to

00:27:24,559 --> 00:27:30,000
go back and you've changed a data frame

00:27:27,840 --> 00:27:31,120
somewhere it can get really messy really

00:27:30,000 --> 00:27:33,360
quickly

00:27:31,120 --> 00:27:34,480
whereas if you treat your data in a more

00:27:33,360 --> 00:27:36,799
immutable way

00:27:34,480 --> 00:27:37,760
then you can go back and just re-execute

00:27:36,799 --> 00:27:39,919
any cells

00:27:37,760 --> 00:27:42,480
and it won't make it won't really make a

00:27:39,919 --> 00:27:44,000
difference you can always

00:27:42,480 --> 00:27:46,240
you can jump around more and you have

00:27:44,000 --> 00:27:48,559
more self-contained

00:27:46,240 --> 00:27:50,080
pieces of logic which again makes the

00:27:48,559 --> 00:27:51,760
whole thing more reusable

00:27:50,080 --> 00:27:53,679
and because it's more self-contained and

00:27:51,760 --> 00:27:56,080
more reusable it's also

00:27:53,679 --> 00:27:57,440
closer to production ready i've noticed

00:27:56,080 --> 00:28:00,880
this a lot

00:27:57,440 --> 00:28:00,880
we've well i've

00:28:01,120 --> 00:28:05,600
talked to the wider data science team

00:28:03,039 --> 00:28:08,320
and got them to basically write all the

00:28:05,600 --> 00:28:10,960
jupiter notebooks for new algorithms new

00:28:08,320 --> 00:28:12,720
data analysis pieces and that more in

00:28:10,960 --> 00:28:15,679
this immutable style

00:28:12,720 --> 00:28:16,480
and since then my job got really a lot

00:28:15,679 --> 00:28:18,640
easier

00:28:16,480 --> 00:28:20,159
of taking these things and putting them

00:28:18,640 --> 00:28:22,480
into a production system

00:28:20,159 --> 00:28:24,080
because it's just more

00:28:22,480 --> 00:28:26,000
[Music]

00:28:24,080 --> 00:28:28,320
things that are easier to take out and

00:28:26,000 --> 00:28:28,320
use

00:28:28,840 --> 00:28:34,880
okay um last main

00:28:32,240 --> 00:28:35,600
main part is how do we deal with

00:28:34,880 --> 00:28:38,880
multiple

00:28:35,600 --> 00:28:40,080
implementations and here we're going to

00:28:38,880 --> 00:28:43,440
actually look at now

00:28:40,080 --> 00:28:45,520
solving the sudoku so

00:28:43,440 --> 00:28:49,039
one thing that i thought about you know

00:28:45,520 --> 00:28:52,720
solving this was a deterministic solver

00:28:49,039 --> 00:28:53,360
um based on a mask so we would create a

00:28:52,720 --> 00:28:56,480
mask

00:28:53,360 --> 00:29:00,320
sort of that only

00:28:56,480 --> 00:29:01,520
shows you the fields where you could put

00:29:00,320 --> 00:29:04,000
a digit in

00:29:01,520 --> 00:29:05,520
so it's where could you in theory you

00:29:04,000 --> 00:29:08,799
put this digit

00:29:05,520 --> 00:29:09,919
and that per digit so you create these

00:29:08,799 --> 00:29:13,520
masks

00:29:09,919 --> 00:29:16,320
then fill any unambiguous ones

00:29:13,520 --> 00:29:18,720
so where there's in the mask just one

00:29:16,320 --> 00:29:22,080
possible place where a digit could be

00:29:18,720 --> 00:29:24,960
within its row column or block

00:29:22,080 --> 00:29:25,360
and then you just keep repeating that

00:29:24,960 --> 00:29:28,799
that

00:29:25,360 --> 00:29:29,919
alone works well for very easy sudokus

00:29:28,799 --> 00:29:31,840
that have a

00:29:29,919 --> 00:29:33,279
clear solution but it's actually

00:29:31,840 --> 00:29:34,880
insufficient when you get to the harder

00:29:33,279 --> 00:29:36,000
ones because they can have multiple

00:29:34,880 --> 00:29:38,240
solutions

00:29:36,000 --> 00:29:40,880
so a deterministic solution is just not

00:29:38,240 --> 00:29:43,679
going to get you there fully

00:29:40,880 --> 00:29:46,080
so i created a random solution as well

00:29:43,679 --> 00:29:49,200
also uses the same concept of a mask

00:29:46,080 --> 00:29:51,360
because we want to still solve it by the

00:29:49,200 --> 00:29:53,679
rules right

00:29:51,360 --> 00:29:54,640
but then we just fill a random digit and

00:29:53,679 --> 00:29:57,039
we just

00:29:54,640 --> 00:29:58,000
repeat that and keep doing it the

00:29:57,039 --> 00:29:59,919
problem is

00:29:58,000 --> 00:30:02,240
that we often back ourselves into a

00:29:59,919 --> 00:30:04,559
corner with that approach so we have to

00:30:02,240 --> 00:30:06,799
backtrack and rerun the whole thing

00:30:04,559 --> 00:30:08,320
um and you have to rerun it so often it

00:30:06,799 --> 00:30:11,760
makes it prohibitively slow

00:30:08,320 --> 00:30:14,080
i think i um

00:30:11,760 --> 00:30:15,200
i tried with a hundred thousand runs

00:30:14,080 --> 00:30:17,760
that was

00:30:15,200 --> 00:30:18,480
definitely not enough and the million

00:30:17,760 --> 00:30:21,520
rows took

00:30:18,480 --> 00:30:24,720
a million tries took too long for me to

00:30:21,520 --> 00:30:27,039
for my patients so what i did instead

00:30:24,720 --> 00:30:28,240
was bring it together into a combined

00:30:27,039 --> 00:30:30,000
approach

00:30:28,240 --> 00:30:32,559
and here we're just saying run it

00:30:30,000 --> 00:30:35,360
deterministic as long as you can

00:30:32,559 --> 00:30:38,399
and once you sort of run out of moves

00:30:35,360 --> 00:30:41,120
then try a random step

00:30:38,399 --> 00:30:42,640
and go back to deterministic and just

00:30:41,120 --> 00:30:44,640
keep iterating that

00:30:42,640 --> 00:30:46,480
you might still need a few tries because

00:30:44,640 --> 00:30:49,039
of the the randomness

00:30:46,480 --> 00:30:50,320
but this is actually a really really uh

00:30:49,039 --> 00:30:52,480
effective solution

00:30:50,320 --> 00:30:55,200
it's still fairly simple but it's an

00:30:52,480 --> 00:30:57,279
effective solution

00:30:55,200 --> 00:30:59,200
the big question is how do we get those

00:30:57,279 --> 00:31:02,840
together so

00:30:59,200 --> 00:31:05,840
how do we organize our code to reflect

00:31:02,840 --> 00:31:05,840
that

00:31:07,360 --> 00:31:11,519
the let's look at the object-oriented

00:31:09,279 --> 00:31:13,279
way first again

00:31:11,519 --> 00:31:15,679
so you would probably create something

00:31:13,279 --> 00:31:19,039
like this a hierarchy of solvers

00:31:15,679 --> 00:31:21,200
so there's the abstract idea of a solver

00:31:19,039 --> 00:31:24,880
at the top

00:31:21,200 --> 00:31:26,799
then we probably want something like a

00:31:24,880 --> 00:31:28,880
step based solver

00:31:26,799 --> 00:31:31,600
that just sort of handles iteration

00:31:28,880 --> 00:31:34,240
retrying

00:31:31,600 --> 00:31:36,080
and uh running steps again and again

00:31:34,240 --> 00:31:39,679
that sort of thing

00:31:36,080 --> 00:31:43,039
then one implementation of that or one

00:31:39,679 --> 00:31:45,279
sort of abstract sub class of that is a

00:31:43,039 --> 00:31:47,360
mask-based solver so that implements our

00:31:45,279 --> 00:31:49,600
logic of creating a mask

00:31:47,360 --> 00:31:50,799
and then running the step so it kind of

00:31:49,600 --> 00:31:54,000
is a mask-based

00:31:50,799 --> 00:31:58,080
step-based solver really

00:31:54,000 --> 00:31:59,760
so then our actual implementations of

00:31:58,080 --> 00:32:02,480
deterministic and random

00:31:59,760 --> 00:32:04,640
solver can just be underneath and those

00:32:02,480 --> 00:32:06,910
essentially now just implement

00:32:04,640 --> 00:32:10,039
the step that is taken

00:32:06,910 --> 00:32:10,039
[Music]

00:32:12,240 --> 00:32:18,399
and then the combination would

00:32:15,279 --> 00:32:21,279
just use those two classes so it has a

00:32:18,399 --> 00:32:23,760
it knows those mask-based solvers and

00:32:21,279 --> 00:32:27,679
combines them

00:32:23,760 --> 00:32:30,159
um a solution could some

00:32:27,679 --> 00:32:30,880
look something like this uh or the use

00:32:30,159 --> 00:32:32,640
case could look

00:32:30,880 --> 00:32:34,320
something like this we instantiate our

00:32:32,640 --> 00:32:36,799
sudoku as we added before

00:32:34,320 --> 00:32:37,360
we instantiate a solver we tell the

00:32:36,799 --> 00:32:39,919
solver

00:32:37,360 --> 00:32:41,679
to solve the sudoku that that we gave it

00:32:39,919 --> 00:32:45,200
and then we have a look at the solution

00:32:41,679 --> 00:32:48,720
and there it is oh and

00:32:45,200 --> 00:32:53,519
let's try the combined one yeah

00:32:48,720 --> 00:32:53,519
works the same glad so

00:32:54,080 --> 00:33:00,000
what is yeah what what is the

00:32:57,200 --> 00:33:00,559
idea of that we have a mutable data

00:33:00,000 --> 00:33:04,080
access

00:33:00,559 --> 00:33:07,360
like similar issues as before it does

00:33:04,080 --> 00:33:08,640
it can make things a tiny bit faster but

00:33:07,360 --> 00:33:12,000
it's usually not

00:33:08,640 --> 00:33:13,440
uh worth it unless you're really in a

00:33:12,000 --> 00:33:15,760
performance critical

00:33:13,440 --> 00:33:19,039
environment and even then the difference

00:33:15,760 --> 00:33:19,039
can be minute

00:33:20,159 --> 00:33:23,600
i do find that when you organize your

00:33:23,120 --> 00:33:26,240
code in

00:33:23,600 --> 00:33:28,000
in a way like this you end up with a lot

00:33:26,240 --> 00:33:29,440
of single method classes because you

00:33:28,000 --> 00:33:30,880
kind of just have to split the

00:33:29,440 --> 00:33:33,600
functionalities apart

00:33:30,880 --> 00:33:35,120
in order to be able to reuse them but if

00:33:33,600 --> 00:33:38,640
you have a single method

00:33:35,120 --> 00:33:40,720
class why is it not just a function i

00:33:38,640 --> 00:33:42,720
i struggle to to understand the logic

00:33:40,720 --> 00:33:43,039
there uh because all you're doing is

00:33:42,720 --> 00:33:46,320
you're

00:33:43,039 --> 00:33:48,799
adding boilerplate so

00:33:46,320 --> 00:33:49,760
it seems to me just a complicated design

00:33:48,799 --> 00:33:53,519
for simple

00:33:49,760 --> 00:33:56,799
functionality but again similar

00:33:53,519 --> 00:33:59,919
things apply as before it does have

00:33:56,799 --> 00:34:03,120
some use for the user because it's

00:33:59,919 --> 00:34:06,240
it's a straightforward way of using it

00:34:03,120 --> 00:34:09,040
so what's what's uh yeah

00:34:06,240 --> 00:34:11,119
just a word count for proof that it has

00:34:09,040 --> 00:34:14,000
a bit of boilerplate

00:34:11,119 --> 00:34:15,200
um what's the functional approach to

00:34:14,000 --> 00:34:17,280
that

00:34:15,200 --> 00:34:20,560
well we just create these functions and

00:34:17,280 --> 00:34:23,760
then sort of worry about wiring them up

00:34:20,560 --> 00:34:24,320
later we have a function that creates a

00:34:23,760 --> 00:34:27,440
mask

00:34:24,320 --> 00:34:29,440
we have these individual step functions

00:34:27,440 --> 00:34:30,480
the combined step function i i forgot

00:34:29,440 --> 00:34:32,079
the arrows there

00:34:30,480 --> 00:34:34,399
actually uses the random and

00:34:32,079 --> 00:34:37,440
deterministic steps

00:34:34,399 --> 00:34:40,639
and we've got this solve function that

00:34:37,440 --> 00:34:42,320
iterates over them so kind of

00:34:40,639 --> 00:34:44,240
similar idea of splitting the

00:34:42,320 --> 00:34:47,440
functionality up but just

00:34:44,240 --> 00:34:49,520
broken down into the actual pieces of of

00:34:47,440 --> 00:34:51,679
logic

00:34:49,520 --> 00:34:54,320
the use case looks a bit different and

00:34:51,679 --> 00:34:57,980
you kind of need more

00:34:54,320 --> 00:34:59,839
context there to be able to run this

00:34:57,980 --> 00:35:03,280
[Music]

00:34:59,839 --> 00:35:04,000
so we can wire pre-wire a function

00:35:03,280 --> 00:35:06,960
called

00:35:04,000 --> 00:35:08,560
solve combined by saying it's solve with

00:35:06,960 --> 00:35:10,240
this combined step

00:35:08,560 --> 00:35:12,240
and then we can run it like we did

00:35:10,240 --> 00:35:12,800
before with our pipeline taking a raw

00:35:12,240 --> 00:35:16,079
example

00:35:12,800 --> 00:35:19,680
parse it solve it format it print it

00:35:16,079 --> 00:35:19,680
and there we go same output

00:35:22,400 --> 00:35:30,160
getting some feedback here at the

00:35:24,560 --> 00:35:33,440
talkback channel

00:35:30,160 --> 00:35:35,680
okay brilliant thank you so

00:35:33,440 --> 00:35:35,680
um

00:35:37,119 --> 00:35:40,320
let's see so this makes the

00:35:39,160 --> 00:35:42,800
responsibilities

00:35:40,320 --> 00:35:45,920
uh very clear per function it's a very

00:35:42,800 --> 00:35:48,320
simple pragmatic design

00:35:45,920 --> 00:35:50,079
once you know how to use it it's very

00:35:48,320 --> 00:35:52,160
easy to introspect and combine in

00:35:50,079 --> 00:35:55,440
different ways as well

00:35:52,160 --> 00:35:57,680
and it's uh much more concise

00:35:55,440 --> 00:35:59,599
the code itself is more concise and on

00:35:57,680 --> 00:36:00,400
top of that we don't actually have any

00:35:59,599 --> 00:36:03,359
of the

00:36:00,400 --> 00:36:04,480
the base module with the uh boilerplate

00:36:03,359 --> 00:36:07,839
code so we are really

00:36:04,480 --> 00:36:10,480
saving a lot of code writing here

00:36:07,839 --> 00:36:12,000
but like i said it's you have to know a

00:36:10,480 --> 00:36:15,760
bit more about the library to

00:36:12,000 --> 00:36:15,760
do your wiring so

00:36:16,000 --> 00:36:20,240
where do we go from that what's the

00:36:17,440 --> 00:36:24,079
multi paradigm solution

00:36:20,240 --> 00:36:26,000
um and here i've you could opt for

00:36:24,079 --> 00:36:27,920
a class like we've done before to do the

00:36:26,000 --> 00:36:29,680
wiring but i kind of just wanted to

00:36:27,920 --> 00:36:33,119
showcase that you can do it

00:36:29,680 --> 00:36:35,119
um in a slightly different

00:36:33,119 --> 00:36:36,400
way this time leaning a bit more to the

00:36:35,119 --> 00:36:39,520
functional side than the

00:36:36,400 --> 00:36:42,560
object side to do this and that is

00:36:39,520 --> 00:36:44,960
i'm create i've created a solving

00:36:42,560 --> 00:36:47,040
function here that does the wiring

00:36:44,960 --> 00:36:49,280
mainly in a functional way

00:36:47,040 --> 00:36:50,400
but we're still using the sudoku the

00:36:49,280 --> 00:36:53,359
higher context

00:36:50,400 --> 00:36:54,320
class to represent the actual sudoku but

00:36:53,359 --> 00:36:57,520
we're running

00:36:54,320 --> 00:36:59,520
this uh solving function over it so here

00:36:57,520 --> 00:37:00,240
we've basically flipped it around rather

00:36:59,520 --> 00:37:02,240
than putting

00:37:00,240 --> 00:37:05,040
a pure function on a class we're now

00:37:02,240 --> 00:37:06,880
using uh

00:37:05,040 --> 00:37:08,320
we're using the class as an input and

00:37:06,880 --> 00:37:11,440
the pure function is

00:37:08,320 --> 00:37:14,320
the sort of top level entry point

00:37:11,440 --> 00:37:15,920
and yeah take my word for it this runs

00:37:14,320 --> 00:37:19,119
perfectly fine

00:37:15,920 --> 00:37:20,240
um so this brings together this

00:37:19,119 --> 00:37:22,480
simplicity and

00:37:20,240 --> 00:37:24,160
and clarity of the functional

00:37:22,480 --> 00:37:26,160
programming but it also

00:37:24,160 --> 00:37:27,440
makes sure you have all the the high

00:37:26,160 --> 00:37:29,440
context

00:37:27,440 --> 00:37:31,760
of a sudoku that makes it really easy to

00:37:29,440 --> 00:37:35,760
explore the actual sudoku itself

00:37:31,760 --> 00:37:37,440
and then you just want to call solve

00:37:35,760 --> 00:37:39,440
with the input of that class you've

00:37:37,440 --> 00:37:42,560
prepared

00:37:39,440 --> 00:37:44,960
um if you really want you can sort of

00:37:42,560 --> 00:37:46,079
create i'll i'd call this a solving

00:37:44,960 --> 00:37:49,359
configuration

00:37:46,079 --> 00:37:50,400
where you say we've got um a step

00:37:49,359 --> 00:37:52,720
function here

00:37:50,400 --> 00:37:54,560
we've got a maximum number of tries and

00:37:52,720 --> 00:37:55,680
then we're just going to use the solve

00:37:54,560 --> 00:37:58,960
function that i just

00:37:55,680 --> 00:38:02,400
showed you and put it on a class

00:37:58,960 --> 00:38:05,680
so i'm making this callable here as well

00:38:02,400 --> 00:38:07,280
so i wouldn't necessarily recommend this

00:38:05,680 --> 00:38:09,520
i just want to showcase here

00:38:07,280 --> 00:38:10,800
that you can sort of make the lines blur

00:38:09,520 --> 00:38:13,119
between what's the function

00:38:10,800 --> 00:38:15,040
and what's what's a class with this

00:38:13,119 --> 00:38:17,440
callable syntax

00:38:15,040 --> 00:38:18,160
and here we can say well take our raw

00:38:17,440 --> 00:38:20,160
example

00:38:18,160 --> 00:38:21,839
this time pars it with the from string

00:38:20,160 --> 00:38:25,359
method on our

00:38:21,839 --> 00:38:29,119
multi-paradigm class and then thread

00:38:25,359 --> 00:38:32,640
this class into a solving configuration

00:38:29,119 --> 00:38:36,720
uh using the combined step and trying

00:38:32,640 --> 00:38:39,680
a maximum number of a hundred times

00:38:36,720 --> 00:38:41,040
also that works perfectly fine and um

00:38:39,680 --> 00:38:43,839
like i said this is just

00:38:41,040 --> 00:38:46,880
now giving you some ideas on how you can

00:38:43,839 --> 00:38:49,760
combine things together

00:38:46,880 --> 00:38:50,079
right that's the main parts i just want

00:38:49,760 --> 00:38:52,000
to

00:38:50,079 --> 00:38:53,599
give some key takeaways and then open up

00:38:52,000 --> 00:38:55,280
for questions

00:38:53,599 --> 00:38:56,880
i'm going to do this fairly quickly

00:38:55,280 --> 00:38:57,839
though because we're running short on

00:38:56,880 --> 00:39:01,280
time

00:38:57,839 --> 00:39:03,839
so object orientation just some

00:39:01,280 --> 00:39:05,359
observations it's typically a fairly

00:39:03,839 --> 00:39:07,520
top-down design

00:39:05,359 --> 00:39:09,680
you create larger very topical

00:39:07,520 --> 00:39:12,640
structures and you're quite explicit

00:39:09,680 --> 00:39:14,640
about high context

00:39:12,640 --> 00:39:15,760
you bring functionality and data

00:39:14,640 --> 00:39:18,560
together in an

00:39:15,760 --> 00:39:19,520
in a topical way it leads to very

00:39:18,560 --> 00:39:21,359
intuitive

00:39:19,520 --> 00:39:23,040
use cases it makes it all very

00:39:21,359 --> 00:39:24,960
explorable

00:39:23,040 --> 00:39:26,640
uh functional programming is very much

00:39:24,960 --> 00:39:30,400
the other way around going

00:39:26,640 --> 00:39:32,640
more in a bottom up fashion

00:39:30,400 --> 00:39:33,839
tries to simplify everything as much as

00:39:32,640 --> 00:39:36,000
possible

00:39:33,839 --> 00:39:37,680
and put it into small chunks of things

00:39:36,000 --> 00:39:38,800
that you can actually reuse functions

00:39:37,680 --> 00:39:41,520
that you can reuse

00:39:38,800 --> 00:39:42,400
and that are entirely separate from the

00:39:41,520 --> 00:39:44,480
data

00:39:42,400 --> 00:39:46,240
so there's a high isolation and we have

00:39:44,480 --> 00:39:50,000
a low context

00:39:46,240 --> 00:39:52,960
that typically leads to very reusable

00:39:50,000 --> 00:39:57,119
things tidy and concise code i find if

00:39:52,960 --> 00:39:59,680
you do it right um and the use cases are

00:39:57,119 --> 00:40:01,200
a bit more flexible uh just a quick side

00:39:59,680 --> 00:40:03,599
note to keep your toe

00:40:01,200 --> 00:40:05,920
code tidy and concise you do need to

00:40:03,599 --> 00:40:08,400
work a bit more with modules

00:40:05,920 --> 00:40:09,680
uh then you would have to in a purely

00:40:08,400 --> 00:40:11,839
object-oriented way

00:40:09,680 --> 00:40:14,319
but there's enough means and ways to

00:40:11,839 --> 00:40:16,400
structure your code

00:40:14,319 --> 00:40:17,599
um so what does that mean for

00:40:16,400 --> 00:40:20,160
multi-paradigm

00:40:17,599 --> 00:40:20,800
it's a pick and mix of both worlds

00:40:20,160 --> 00:40:23,599
warning

00:40:20,800 --> 00:40:24,640
you can pick and makes the worst of both

00:40:23,599 --> 00:40:28,160
worlds

00:40:24,640 --> 00:40:30,720
try not to do that but i i think

00:40:28,160 --> 00:40:31,920
i've shown you probably some useful ways

00:40:30,720 --> 00:40:36,079
of combining

00:40:31,920 --> 00:40:40,160
um use pure functions in a mutable

00:40:36,079 --> 00:40:42,160
context so just bring that all together

00:40:40,160 --> 00:40:43,680
good thing is no side effects no

00:40:42,160 --> 00:40:46,000
problems you can always use the pure

00:40:43,680 --> 00:40:48,800
functions in a mutable context and you

00:40:46,000 --> 00:40:50,240
shouldn't get any problems the other way

00:40:48,800 --> 00:40:52,160
around when you use

00:40:50,240 --> 00:40:54,000
something that works with mutable data

00:40:52,160 --> 00:40:55,359
in an immutable context

00:40:54,000 --> 00:40:57,680
then you want to make sure you're

00:40:55,359 --> 00:40:58,480
explicit about it and use a copy to

00:40:57,680 --> 00:41:01,599
modify

00:40:58,480 --> 00:41:02,480
a copy and modify pattern so just to

00:41:01,599 --> 00:41:05,119
make sure you're not

00:41:02,480 --> 00:41:07,040
changing your inputs and by that keep it

00:41:05,119 --> 00:41:08,000
immutable for the context that is

00:41:07,040 --> 00:41:11,359
required

00:41:08,000 --> 00:41:13,920
so ideally you end up with both

00:41:11,359 --> 00:41:14,480
intuitive and flexible use cases and you

00:41:13,920 --> 00:41:17,440
end up

00:41:14,480 --> 00:41:21,200
with both something that's explorable

00:41:17,440 --> 00:41:24,480
and has very reusable components

00:41:21,200 --> 00:41:28,480
yeah i like four minutes left

00:41:24,480 --> 00:41:30,640
okay perfect um mine is including q

00:41:28,480 --> 00:41:32,400
a so if you want to do q a then we

00:41:30,640 --> 00:41:35,280
should switch to

00:41:32,400 --> 00:41:36,000
okay thanks mark um yeah so favorite

00:41:35,280 --> 00:41:38,079
approach

00:41:36,000 --> 00:41:39,359
iterate with a rebel and that's where

00:41:38,079 --> 00:41:40,079
i'm going to wrap up so we have some

00:41:39,359 --> 00:41:43,839
times

00:41:40,079 --> 00:41:43,839
for time for questions

00:41:47,839 --> 00:41:53,200
okay excellent thank you very much elias

00:41:50,880 --> 00:41:55,200
that was a very very interesting talk

00:41:53,200 --> 00:41:56,960
and sorry sorry i had to cut you a bit

00:41:55,200 --> 00:41:59,359
short

00:41:56,960 --> 00:42:00,640
um we do have a couple of questions we

00:41:59,359 --> 00:42:02,319
don't have we have

00:42:00,640 --> 00:42:03,760
three minutes left for questions so i'm

00:42:02,319 --> 00:42:05,040
just going to read them from top to

00:42:03,760 --> 00:42:06,560
bottom

00:42:05,040 --> 00:42:08,160
so first question there how do you

00:42:06,560 --> 00:42:11,200
recommend organizing your helper

00:42:08,160 --> 00:42:13,520
functions in a module

00:42:11,200 --> 00:42:16,560
um that depends very much on what the

00:42:13,520 --> 00:42:20,000
context is about see

00:42:16,560 --> 00:42:22,560
um i would generally

00:42:20,000 --> 00:42:24,480
start writing them in one module where

00:42:22,560 --> 00:42:26,000
whatever you use them for and then sort

00:42:24,480 --> 00:42:27,520
of start breaking them out when you

00:42:26,000 --> 00:42:28,640
realize hey this is something that i

00:42:27,520 --> 00:42:31,359
could reuse

00:42:28,640 --> 00:42:32,720
maybe put it into a utility library or

00:42:31,359 --> 00:42:35,520
into a topical

00:42:32,720 --> 00:42:36,560
library or even just in a sub module

00:42:35,520 --> 00:42:39,359
pull them out when it

00:42:36,560 --> 00:42:41,040
starts to look like hey this is not just

00:42:39,359 --> 00:42:42,960
for this particular use case

00:42:41,040 --> 00:42:45,839
this could or will be more useful in

00:42:42,960 --> 00:42:45,839
others as well

00:42:46,400 --> 00:42:53,839
okay great thanks next question is why

00:42:49,920 --> 00:42:53,839
data class and not name tuple

00:42:54,000 --> 00:43:00,640
um i use data classes

00:42:57,280 --> 00:43:01,839
here to just show um get rid of some

00:43:00,640 --> 00:43:03,920
boilerplate

00:43:01,839 --> 00:43:06,480
i showed you the 120 lines that was

00:43:03,920 --> 00:43:08,240
already with using data classes

00:43:06,480 --> 00:43:10,000
so i used them mostly for the object

00:43:08,240 --> 00:43:12,720
oriented context here

00:43:10,000 --> 00:43:13,280
and then just kept going to keep it to

00:43:12,720 --> 00:43:16,960
keep

00:43:13,280 --> 00:43:20,079
it sort of similar in the talk um

00:43:16,960 --> 00:43:22,160
frozen data classes and named tuples

00:43:20,079 --> 00:43:23,599
really if you just use them this way

00:43:22,160 --> 00:43:26,079
there's no

00:43:23,599 --> 00:43:28,240
considerable considerable difference

00:43:26,079 --> 00:43:31,520
i've definitely used name tuples as well

00:43:28,240 --> 00:43:35,680
with some functionality on them

00:43:31,520 --> 00:43:38,000
okay great see one more question

00:43:35,680 --> 00:43:41,760
why should you not use lambda inside

00:43:38,000 --> 00:43:44,800
list comprehensions just for readability

00:43:41,760 --> 00:43:46,400
um no not just for a readability there

00:43:44,800 --> 00:43:48,319
is a

00:43:46,400 --> 00:43:50,160
uh i don't know what the correct term

00:43:48,319 --> 00:43:52,480
there is but there is a a problem with

00:43:50,160 --> 00:43:54,000
context generally that a for loop

00:43:52,480 --> 00:43:57,200
doesn't have

00:43:54,000 --> 00:43:59,760
a context so if you if you end up

00:43:57,200 --> 00:44:02,000
for example defining sort of slight

00:43:59,760 --> 00:44:03,200
tangent if you define a function inside

00:44:02,000 --> 00:44:06,720
a for loop

00:44:03,200 --> 00:44:08,960
and then you sort of memorize that

00:44:06,720 --> 00:44:10,640
function for later use

00:44:08,960 --> 00:44:12,480
you're actually going to override the

00:44:10,640 --> 00:44:14,880
function and only be left with the one

00:44:12,480 --> 00:44:17,440
of the last iteration of the loop

00:44:14,880 --> 00:44:19,119
so you can really get yourself into some

00:44:17,440 --> 00:44:21,760
unexpected behavior

00:44:19,119 --> 00:44:24,160
there and that same principle translates

00:44:21,760 --> 00:44:27,280
to lambda functions inside the loop

00:44:24,160 --> 00:44:27,760
so if you if you directly execute

00:44:27,280 --> 00:44:29,520
something

00:44:27,760 --> 00:44:31,040
you know in a list comprehension you

00:44:29,520 --> 00:44:32,800
don't actually need a lambda

00:44:31,040 --> 00:44:35,040
but as soon as you start to do something

00:44:32,800 --> 00:44:38,319
say with pandas inside the loop

00:44:35,040 --> 00:44:40,480
with a lambda df and then

00:44:38,319 --> 00:44:42,000
use something on the data frame it will

00:44:40,480 --> 00:44:45,200
not do what you want it to do

00:44:42,000 --> 00:44:46,800
so just try to avoid it okay thank you

00:44:45,200 --> 00:44:48,240
very much i think that was the last

00:44:46,800 --> 00:44:51,040
question that we can take

00:44:48,240 --> 00:44:52,319
i would like to ask the attendees who

00:44:51,040 --> 00:44:55,040
had more questions

00:44:52,319 --> 00:44:56,400
to go to the the talk channel that we

00:44:55,040 --> 00:44:59,440
have for this talk which is

00:44:56,400 --> 00:45:02,480
talk write multi-paradigm code and

00:44:59,440 --> 00:45:03,200
uh then you can ask additional questions

00:45:02,480 --> 00:45:06,480
there

00:45:03,200 --> 00:45:09,680
and the leaders can then answer those

00:45:06,480 --> 00:45:11,359
so thank you very much elias for for the

00:45:09,680 --> 00:45:16,640
nice session

00:45:11,359 --> 00:45:16,640
let me try to run a short applause for

00:45:16,839 --> 00:45:19,839
you

00:45:26,319 --> 00:45:28,400

YouTube URL: https://www.youtube.com/watch?v=RHPFPhaLu58


