Title: Philip Jones - An ASGI Server from scratch
Publication date: 2020-09-15
Playlist: EuroPython 2020
Description: 
	"An ASGI Server from scratch
EuroPython 2020 - Talk - 2020-07-23 - Brian
Online

By Philip Jones

I intend for this to be a fairly advanced talk that shows the steps required to go from a TCP echo server to a basic HTTP/1 ASGI server using asyncio for the IO. This is aimed at people who've read about asyncio, coroutines, etc and want to see them used in practice.

This is a tutorial on how to build a HTTP/1 ASGI server using asyncio. I plan to start by building a TCP echo server and then add HTTP parsing and ASGI compliance.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2020.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:06,160 --> 00:00:09,599
okay

00:00:06,720 --> 00:00:11,599
this seems to work i hope at least um

00:00:09,599 --> 00:00:15,200
we're back from the lunch break

00:00:11,599 --> 00:00:18,560
and um we have

00:00:15,200 --> 00:00:21,279
with us already waiting our first

00:00:18,560 --> 00:00:22,960
speaker for this block in the brian room

00:00:21,279 --> 00:00:25,840
uh

00:00:22,960 --> 00:00:26,560
i'm going to invite uh let's see does it

00:00:25,840 --> 00:00:28,560
work

00:00:26,560 --> 00:00:30,400
hey i'm going to invite philip jones

00:00:28,560 --> 00:00:32,880
from my night uh

00:00:30,400 --> 00:00:33,920
philip where are you calling us from uh

00:00:32,880 --> 00:00:37,440
london today

00:00:33,920 --> 00:00:40,399
in the uk that's nice and have you been

00:00:37,440 --> 00:00:43,520
working from home all the time

00:00:40,399 --> 00:00:47,280
yeah like like almost everybody

00:00:43,520 --> 00:00:48,079
um you're involved with a lot of uh

00:00:47,280 --> 00:00:51,840
asynchronous

00:00:48,079 --> 00:00:55,280
um um projects like quo type account

00:00:51,840 --> 00:00:58,800
and where else do people know you from

00:00:55,280 --> 00:01:00,559
uh was probably that maybe from uh

00:00:58,800 --> 00:01:02,399
helping maintain the pilots libraries as

00:01:00,559 --> 00:01:03,520
well but probably those if people know

00:01:02,399 --> 00:01:05,199
me

00:01:03,520 --> 00:01:08,720
yeah and today you're going to show us

00:01:05,199 --> 00:01:11,840
how to do our own asynchronous uh

00:01:08,720 --> 00:01:13,360
gi server from scratch right yep so

00:01:11,840 --> 00:01:14,240
we're real we're really looking forward

00:01:13,360 --> 00:01:16,960
to that

00:01:14,240 --> 00:01:17,439
so you please start your screen share

00:01:16,960 --> 00:01:22,560
and

00:01:17,439 --> 00:01:22,560
show us how we can do this at home okay

00:01:25,040 --> 00:01:31,920
so hopefully you can see

00:01:29,200 --> 00:01:31,920
if it's correct

00:01:33,759 --> 00:01:39,280
yep i presume you can see everything i

00:01:37,520 --> 00:01:40,159
can't hear you if you can but i might be

00:01:39,280 --> 00:01:42,560
if it's good

00:01:40,159 --> 00:01:44,960
so yes so i'm gonna talk today about

00:01:42,560 --> 00:01:46,880
building an ascii server from scratch

00:01:44,960 --> 00:01:48,880
uh quite what that means and everything

00:01:46,880 --> 00:01:51,040
about it i'll explain in a minute

00:01:48,880 --> 00:01:52,799
uh you can probably find the slides in

00:01:51,040 --> 00:01:54,880
quite a number of places at the moment

00:01:52,799 --> 00:01:57,040
but you can also find them on my site

00:01:54,880 --> 00:02:00,079
which is pgjones.dev

00:01:57,040 --> 00:02:01,200
excuse me and you can find the slides on

00:02:00,079 --> 00:02:02,799
the talks page

00:02:01,200 --> 00:02:04,640
i've also got some code to go along with

00:02:02,799 --> 00:02:06,320
this which you can find on github

00:02:04,640 --> 00:02:08,160
under my name pg jones if you look for

00:02:06,320 --> 00:02:09,679
ascii server from scratch so all the

00:02:08,160 --> 00:02:10,800
code i've got in these slides is also

00:02:09,679 --> 00:02:12,160
available on github

00:02:10,800 --> 00:02:14,480
so hopefully that will make things a bit

00:02:12,160 --> 00:02:15,680
easier uh before i get into the talk

00:02:14,480 --> 00:02:16,720
itself i'll just tell you a bit about

00:02:15,680 --> 00:02:18,319
myself so

00:02:16,720 --> 00:02:20,400
i think you already know about the open

00:02:18,319 --> 00:02:21,280
source work i do and you can find me

00:02:20,400 --> 00:02:23,760
here

00:02:21,280 --> 00:02:24,959
you can find me as pg jones on github

00:02:23,760 --> 00:02:26,560
and gitlab

00:02:24,959 --> 00:02:28,160
and on twitter if you wanted to tweet me

00:02:26,560 --> 00:02:30,560
you need to remember this extra d

00:02:28,160 --> 00:02:32,400
i was too slow to get the pg jones so

00:02:30,560 --> 00:02:35,200
there's an extra d there

00:02:32,400 --> 00:02:36,080
and uh as i just said at the start of

00:02:35,200 --> 00:02:38,879
this year i

00:02:36,080 --> 00:02:40,640
i co-founded manage which at the time

00:02:38,879 --> 00:02:42,560
seemed like a great time for it

00:02:40,640 --> 00:02:44,879
since then it's proved a little harder

00:02:42,560 --> 00:02:47,680
uh what monetary is is it's a

00:02:44,879 --> 00:02:48,160
financial tool for people in the uk so

00:02:47,680 --> 00:02:50,480
what it

00:02:48,160 --> 00:02:51,280
provides you is financial planning tools

00:02:50,480 --> 00:02:53,440
and

00:02:51,280 --> 00:02:54,640
guidance to effectively become your own

00:02:53,440 --> 00:02:56,160
financial advisor

00:02:54,640 --> 00:02:57,519
so if you're in the uk and you're

00:02:56,160 --> 00:02:59,200
interested in your finances please have

00:02:57,519 --> 00:03:02,720
a look at monet

00:02:59,200 --> 00:03:05,360
okay on to the talk so our aim today

00:03:02,720 --> 00:03:06,319
is to build this green box in the middle

00:03:05,360 --> 00:03:08,720
so

00:03:06,319 --> 00:03:10,560
i we have a client talking to us and we

00:03:08,720 --> 00:03:12,959
can talk to some ascii app

00:03:10,560 --> 00:03:14,319
and ascii which i'll come to in a minute

00:03:12,959 --> 00:03:15,519
it's basically the definition the

00:03:14,319 --> 00:03:18,720
interface between

00:03:15,519 --> 00:03:19,840
our server and any app but of course we

00:03:18,720 --> 00:03:20,800
need to be able to understand what the

00:03:19,840 --> 00:03:24,239
client does

00:03:20,800 --> 00:03:25,680
and whilst ascii can do more than http

00:03:24,239 --> 00:03:27,519
it could do web sockets and stuff like

00:03:25,680 --> 00:03:28,879
that uh for time constraints i'm just

00:03:27,519 --> 00:03:32,080
going to focus on http

00:03:28,879 --> 00:03:34,799
so sorry about that okay uh

00:03:32,080 --> 00:03:36,959
to kind of like introduce why you'd want

00:03:34,799 --> 00:03:38,319
to do this and what you need to consider

00:03:36,959 --> 00:03:40,640
i think you just need to say a little

00:03:38,319 --> 00:03:41,840
bit about asynco and the async await

00:03:40,640 --> 00:03:45,360
keywords

00:03:41,840 --> 00:03:46,560
so uh the joy if you in my eyes of

00:03:45,360 --> 00:03:48,560
a sink and a weight is they're very

00:03:46,560 --> 00:03:51,120
explicit it's very clear

00:03:48,560 --> 00:03:52,959
what's going on and what parts of code

00:03:51,120 --> 00:03:53,439
could yield control back to the event

00:03:52,959 --> 00:03:56,000
loop

00:03:53,439 --> 00:03:57,120
and what couldn't the downside of this

00:03:56,000 --> 00:03:59,760
of course is that

00:03:57,120 --> 00:04:01,599
a curry team function and async def

00:03:59,760 --> 00:04:03,360
can't be run itself if you just call it

00:04:01,599 --> 00:04:05,360
it's just going to return you a codeine

00:04:03,360 --> 00:04:06,319
and do nothing what you need to have is

00:04:05,360 --> 00:04:09,439
an event loop

00:04:06,319 --> 00:04:10,959
run it for you for example like this

00:04:09,439 --> 00:04:13,360
of course the bonus of that is the event

00:04:10,959 --> 00:04:15,360
loop can then interleave the i o

00:04:13,360 --> 00:04:17,280
that's the whole point and know when to

00:04:15,360 --> 00:04:17,519
yield and in our case what we're going

00:04:17,280 --> 00:04:19,840
to

00:04:17,519 --> 00:04:20,880
be interested in is creating a server

00:04:19,840 --> 00:04:24,479
and listening

00:04:20,880 --> 00:04:28,160
so this is the start server command

00:04:24,479 --> 00:04:31,280
so brief introduction there to kind of

00:04:28,160 --> 00:04:34,000
introduce asgi i'm going to start by

00:04:31,280 --> 00:04:36,160
talking very briefly about wgs gi which

00:04:34,000 --> 00:04:38,960
is the web server gateway interface

00:04:36,160 --> 00:04:40,720
so if you're using pretty much any kind

00:04:38,960 --> 00:04:42,800
of

00:04:40,720 --> 00:04:44,320
framework in python at the moment

00:04:42,800 --> 00:04:45,120
particularly django flask you're almost

00:04:44,320 --> 00:04:48,320
certainly using

00:04:45,120 --> 00:04:50,000
wsgi whiskey and what it is in its

00:04:48,320 --> 00:04:51,919
simplest form is a definition of the

00:04:50,000 --> 00:04:54,479
interface between the server

00:04:51,919 --> 00:04:56,160
and the app so between any server and

00:04:54,479 --> 00:04:58,479
your django or flask app

00:04:56,160 --> 00:04:59,280
and what it says is the server will call

00:04:58,479 --> 00:05:02,240
a

00:04:59,280 --> 00:05:04,160
a callable that takes two arguments an

00:05:02,240 --> 00:05:06,080
environ and a start response

00:05:04,160 --> 00:05:07,520
so your app at the very least has to be

00:05:06,080 --> 00:05:09,440
this callable

00:05:07,520 --> 00:05:11,199
and the environ is a dictionary that

00:05:09,440 --> 00:05:13,360
fully describes the request

00:05:11,199 --> 00:05:14,639
and start response is a callable that

00:05:13,360 --> 00:05:16,400
the your app

00:05:14,639 --> 00:05:17,840
uses to tell the server when it's ready

00:05:16,400 --> 00:05:20,160
to start responding

00:05:17,840 --> 00:05:21,120
and this callable takes two arguments

00:05:20,160 --> 00:05:23,919
the status

00:05:21,120 --> 00:05:26,800
and then a list of headers and then this

00:05:23,919 --> 00:05:28,800
callable should yield or return the body

00:05:26,800 --> 00:05:31,680
so if you're familiar with http the

00:05:28,800 --> 00:05:34,800
server figures out what the request is

00:05:31,680 --> 00:05:36,840
calls this callable and then your app

00:05:34,800 --> 00:05:38,000
will start the response and return the

00:05:36,840 --> 00:05:41,120
body

00:05:38,000 --> 00:05:41,120
so this is all very good

00:05:41,199 --> 00:05:44,000
it's actually worked really well in the

00:05:42,479 --> 00:05:45,280
python community but you can see it's

00:05:44,000 --> 00:05:48,720
got no async

00:05:45,280 --> 00:05:51,759
so it doesn't work if i think of weight

00:05:48,720 --> 00:05:52,000
and so your app can't be asynchronous so

00:05:51,759 --> 00:05:55,360
this

00:05:52,000 --> 00:05:57,199
is where asgi comes in which i always

00:05:55,360 --> 00:05:58,479
pronounce is ascii but i'm sure others

00:05:57,199 --> 00:06:00,160
do it differently which is the

00:05:58,479 --> 00:06:01,120
asynchronous server gateway interface

00:06:00,160 --> 00:06:04,720
and it's heavily

00:06:01,120 --> 00:06:06,639
influenced by wsgi as you can tell by

00:06:04,720 --> 00:06:09,039
the name and

00:06:06,639 --> 00:06:10,800
to kind of show the comparison with that

00:06:09,039 --> 00:06:12,240
with the whiskey example i showed there

00:06:10,800 --> 00:06:14,479
the interface is that you have a

00:06:12,240 --> 00:06:16,720
callable this time it's asynchronous

00:06:14,479 --> 00:06:19,039
that takes a scope and two more

00:06:16,720 --> 00:06:20,800
callables that receive an ascend

00:06:19,039 --> 00:06:22,880
now the scope is very similar to the

00:06:20,800 --> 00:06:24,240
environment it's a dictionary that fully

00:06:22,880 --> 00:06:25,440
describes the request

00:06:24,240 --> 00:06:28,080
but it doesn't say anything about the

00:06:25,440 --> 00:06:30,080
body this time now the application has

00:06:28,080 --> 00:06:32,240
to get the body by receiving it

00:06:30,080 --> 00:06:33,280
so it can call this receive and then

00:06:32,240 --> 00:06:34,960
when it's done

00:06:33,280 --> 00:06:36,880
it can send messages back to the server

00:06:34,960 --> 00:06:37,360
using the send as you can see here so we

00:06:36,880 --> 00:06:39,280
send

00:06:37,360 --> 00:06:41,120
we say the response is ready to start

00:06:39,280 --> 00:06:43,280
with the status code and some headers

00:06:41,120 --> 00:06:45,280
and then we send the body so this is

00:06:43,280 --> 00:06:48,479
pretty much the same as the wsgi

00:06:45,280 --> 00:06:49,759
version except for asgi so this is our

00:06:48,479 --> 00:06:51,120
interface effectively

00:06:49,759 --> 00:06:52,880
this and the definition of these

00:06:51,120 --> 00:06:55,199
messages that go between

00:06:52,880 --> 00:06:56,240
uh the server and the app is is what we

00:06:55,199 --> 00:06:59,520
need to build

00:06:56,240 --> 00:07:01,520
on that site okay so

00:06:59,520 --> 00:07:03,199
just to hopefully clarify was talking

00:07:01,520 --> 00:07:06,160
about there so

00:07:03,199 --> 00:07:08,400
we're building this server sdi is the

00:07:06,160 --> 00:07:10,479
interface between the server and the app

00:07:08,400 --> 00:07:11,759
and the real advantage i forgot to say

00:07:10,479 --> 00:07:13,919
really is that you can

00:07:11,759 --> 00:07:15,680
switch out any ascii server for any

00:07:13,919 --> 00:07:16,080
other ascii 7 not have to change your

00:07:15,680 --> 00:07:17,759
app

00:07:16,080 --> 00:07:19,680
which is good at the moment there's like

00:07:17,759 --> 00:07:22,080
daphne unicorn hypercon

00:07:19,680 --> 00:07:22,960
you can just choose between and

00:07:22,080 --> 00:07:25,199
hopefully your own

00:07:22,960 --> 00:07:26,639
at the end of this talk of course we

00:07:25,199 --> 00:07:27,919
need to do this part so i'm going to

00:07:26,639 --> 00:07:29,680
focus on this part now

00:07:27,919 --> 00:07:32,080
the connection between the server and

00:07:29,680 --> 00:07:34,319
the clients

00:07:32,080 --> 00:07:36,160
so this is actually it turns out for

00:07:34,319 --> 00:07:39,440
this talk mostly asynchronous

00:07:36,160 --> 00:07:43,199
bit here and uh what we need to do

00:07:39,440 --> 00:07:45,840
is open uh a socket on the server

00:07:43,199 --> 00:07:47,759
listen for incoming connections and then

00:07:45,840 --> 00:07:49,680
do something with that data

00:07:47,759 --> 00:07:51,440
and this example i'm going to start with

00:07:49,680 --> 00:07:52,160
is just going to send every byte it

00:07:51,440 --> 00:07:55,199
receives

00:07:52,160 --> 00:07:56,400
back to the client so if we start in the

00:07:55,199 --> 00:07:58,080
main

00:07:56,400 --> 00:08:01,759
we use the start server command i

00:07:58,080 --> 00:08:01,759
mentioned earlier to create a server

00:08:02,160 --> 00:08:07,360
and this server is going to listen

00:08:05,599 --> 00:08:08,879
on the host and port and every

00:08:07,360 --> 00:08:10,639
connection is going to call

00:08:08,879 --> 00:08:12,000
echo server callable which i'm going to

00:08:10,639 --> 00:08:13,840
get to in a minute

00:08:12,000 --> 00:08:15,680
and then the server itself if we just

00:08:13,840 --> 00:08:17,599
await its forever

00:08:15,680 --> 00:08:19,280
methods then it will just serve for as

00:08:17,599 --> 00:08:21,120
long as you don't interrupt it

00:08:19,280 --> 00:08:23,360
so very simple and we can run this main

00:08:21,120 --> 00:08:23,840
in the async run or some other way which

00:08:23,360 --> 00:08:26,160
i

00:08:23,840 --> 00:08:27,680
spoke about earlier so it's a server a

00:08:26,160 --> 00:08:28,639
bit that we're really interested in so

00:08:27,680 --> 00:08:30,800
every connection

00:08:28,639 --> 00:08:31,759
this a new task is going to be created

00:08:30,800 --> 00:08:34,240
running this

00:08:31,759 --> 00:08:36,000
codeine function and this is going to

00:08:34,240 --> 00:08:36,800
take a reader and a writer and that's

00:08:36,000 --> 00:08:38,719
exactly as

00:08:36,800 --> 00:08:40,080
you'd expect the reader reads messages

00:08:38,719 --> 00:08:43,360
from the client and the writer

00:08:40,080 --> 00:08:46,000
writes them back so a simple echo server

00:08:43,360 --> 00:08:46,880
simply needs to listen to everything the

00:08:46,000 --> 00:08:48,480
reader sends

00:08:46,880 --> 00:08:50,320
until it indicates it's done which is

00:08:48,480 --> 00:08:53,040
the attender file

00:08:50,320 --> 00:08:54,000
so it reads up to 100 bytes and then

00:08:53,040 --> 00:08:55,839
writes it back

00:08:54,000 --> 00:08:57,839
and then for a bit of flow control it

00:08:55,839 --> 00:09:00,640
waits for the client to have

00:08:57,839 --> 00:09:01,760
received that data i'm not going to talk

00:09:00,640 --> 00:09:03,760
more in this talk for

00:09:01,760 --> 00:09:05,040
time reasons about flow control but if

00:09:03,760 --> 00:09:06,800
you do go down the route writing your

00:09:05,040 --> 00:09:08,480
own server this is really important

00:09:06,800 --> 00:09:09,920
very easy to get wrong it's actually

00:09:08,480 --> 00:09:12,160
quite a pain

00:09:09,920 --> 00:09:13,600
anyway so we read the data write it back

00:09:12,160 --> 00:09:15,839
out then when the

00:09:13,600 --> 00:09:17,760
client said it's done we close so this

00:09:15,839 --> 00:09:19,200
is entirely controlled by the client

00:09:17,760 --> 00:09:20,959
the server doesn't actually decide when

00:09:19,200 --> 00:09:23,760
to close the connection so as long as

00:09:20,959 --> 00:09:26,800
the client plays nice it should be good

00:09:23,760 --> 00:09:29,760
so let's test it so if i run it this way

00:09:26,800 --> 00:09:30,399
i can connect using a tool called telnet

00:09:29,760 --> 00:09:32,480
and

00:09:30,399 --> 00:09:33,920
then i can type in hello and the server

00:09:32,480 --> 00:09:35,680
is going to send it back to me

00:09:33,920 --> 00:09:37,120
i can type in goodbye the server's going

00:09:35,680 --> 00:09:38,720
to send it back and then i can

00:09:37,120 --> 00:09:40,320
close the connection and the server is

00:09:38,720 --> 00:09:42,160
going to close it so it's done

00:09:40,320 --> 00:09:43,519
everything we wanted to do which is

00:09:42,160 --> 00:09:45,680
great

00:09:43,519 --> 00:09:47,839
again this code's in the github repo if

00:09:45,680 --> 00:09:50,480
you want to play around yourself

00:09:47,839 --> 00:09:51,440
so what we've done now is is figured out

00:09:50,480 --> 00:09:53,440
how to do this

00:09:51,440 --> 00:09:54,880
connection here so we can send bytes

00:09:53,440 --> 00:09:55,519
back and forth between the client and

00:09:54,880 --> 00:09:58,640
server

00:09:55,519 --> 00:10:00,480
which is great but what these bytes uh

00:09:58,640 --> 00:10:02,720
are actually going to be formatted in or

00:10:00,480 --> 00:10:05,839
or the protocol is going to be http

00:10:02,720 --> 00:10:07,600
so we really need to understand that so

00:10:05,839 --> 00:10:09,760
let's move on to that

00:10:07,600 --> 00:10:11,839
so i think if you're a president in the

00:10:09,760 --> 00:10:14,959
last talk you saw a snippet of this

00:10:11,839 --> 00:10:17,120
as well i'm going to focus on hp1

00:10:14,959 --> 00:10:19,040
i'll talk a bit about hp2 and hp3 later

00:10:17,120 --> 00:10:20,240
on but let's start with hb1 because it's

00:10:19,040 --> 00:10:23,360
much easier

00:10:20,240 --> 00:10:24,560
so http1 request looks like this and we

00:10:23,360 --> 00:10:27,440
have a request line

00:10:24,560 --> 00:10:28,240
first which has a method a path and a

00:10:27,440 --> 00:10:30,079
version

00:10:28,240 --> 00:10:32,160
then we have the headers which consist

00:10:30,079 --> 00:10:34,959
of a name colon then a value

00:10:32,160 --> 00:10:35,600
and possibly more of them and then we

00:10:34,959 --> 00:10:37,200
have some

00:10:35,600 --> 00:10:38,640
well we have a blank line and then some

00:10:37,200 --> 00:10:41,680
body so

00:10:38,640 --> 00:10:43,200
this is what it is so our parser needs

00:10:41,680 --> 00:10:44,959
to be able to understand this so

00:10:43,200 --> 00:10:46,959
this is a very simple parser i've

00:10:44,959 --> 00:10:48,800
written for for this talk

00:10:46,959 --> 00:10:50,160
and you can see we feed it lines so the

00:10:48,800 --> 00:10:52,240
key thing here is you're

00:10:50,160 --> 00:10:54,000
it's kind of implicit but there's line

00:10:52,240 --> 00:10:54,640
breaks between each one of these that's

00:10:54,000 --> 00:10:56,880
how you know

00:10:54,640 --> 00:10:59,839
it's the next thing so we feed it the

00:10:56,880 --> 00:11:01,360
lines and it starts off in the request

00:10:59,839 --> 00:11:02,640
so the first line should be the method

00:11:01,360 --> 00:11:04,959
the path for the version

00:11:02,640 --> 00:11:06,959
separated by spaces and as soon as we

00:11:04,959 --> 00:11:09,200
got that we can look at the headers

00:11:06,959 --> 00:11:10,079
now the headers there could be one or

00:11:09,200 --> 00:11:11,920
many so

00:11:10,079 --> 00:11:13,120
as long as we don't see a blank line we

00:11:11,920 --> 00:11:14,000
think it's still a headers but as soon

00:11:13,120 --> 00:11:16,640
as we see that blank

00:11:14,000 --> 00:11:18,160
line we know that now we've moved on to

00:11:16,640 --> 00:11:19,279
the body everything that comes after is

00:11:18,160 --> 00:11:20,800
going to be the body so

00:11:19,279 --> 00:11:22,880
not really any more passing to do it's

00:11:20,800 --> 00:11:24,480
just all going to go in the body

00:11:22,880 --> 00:11:26,000
i'm going to ignore training headers for

00:11:24,480 --> 00:11:27,360
simplicity

00:11:26,000 --> 00:11:29,040
so if we're in the headers part this is

00:11:27,360 --> 00:11:31,040
probably the most complex bit

00:11:29,040 --> 00:11:33,680
we split on the column into the name and

00:11:31,040 --> 00:11:35,040
value and then we append it to the list

00:11:33,680 --> 00:11:37,279
of headers

00:11:35,040 --> 00:11:38,800
and we're just going to keep as well if

00:11:37,279 --> 00:11:40,160
we find the content length

00:11:38,800 --> 00:11:41,839
we're going to keep hold of that so

00:11:40,160 --> 00:11:43,360
that'll tell us how long the body is so

00:11:41,839 --> 00:11:44,240
when to stop reading the body when we're

00:11:43,360 --> 00:11:47,200
done

00:11:44,240 --> 00:11:47,600
and we're also ignoring other ways of

00:11:47,200 --> 00:11:49,200
like

00:11:47,600 --> 00:11:50,320
like chunked encoding or anything like

00:11:49,200 --> 00:11:50,800
that we're just going to do content

00:11:50,320 --> 00:11:52,560
length

00:11:50,800 --> 00:11:53,839
so this is a very simple parser which

00:11:52,560 --> 00:11:56,240
will allow us to pull out the

00:11:53,839 --> 00:11:58,480
important parts of the hp request

00:11:56,240 --> 00:12:02,800
notably the method the path and the body

00:11:58,480 --> 00:12:04,959
and the headers okay so now we have this

00:12:02,800 --> 00:12:05,839
we can combine it with the server we had

00:12:04,959 --> 00:12:07,200
previously

00:12:05,839 --> 00:12:11,839
and start to understand the requests

00:12:07,200 --> 00:12:11,839
coming in from the client

00:12:13,920 --> 00:12:18,800
so this is it so this is if you just

00:12:17,200 --> 00:12:20,720
imagine i've switched out the echo

00:12:18,800 --> 00:12:23,360
server to this hp password server

00:12:20,720 --> 00:12:24,639
still gets the reader in the writer and

00:12:23,360 --> 00:12:27,839
i create the parser

00:12:24,639 --> 00:12:29,760
and biterate to store the body in once

00:12:27,839 --> 00:12:31,440
again i'm going to

00:12:29,760 --> 00:12:34,000
keep listening until the reader the

00:12:31,440 --> 00:12:36,079
client says it's done

00:12:34,000 --> 00:12:38,000
and i'm just going to feed the lines

00:12:36,079 --> 00:12:39,760
that i get to the passer

00:12:38,000 --> 00:12:42,000
until it says everything else should be

00:12:39,760 --> 00:12:44,320
body and then when i

00:12:42,000 --> 00:12:45,760
i'm in the body state i just keep

00:12:44,320 --> 00:12:48,480
reading until i've

00:12:45,760 --> 00:12:49,040
read as much as i expect to read and at

00:12:48,480 --> 00:12:51,120
the end

00:12:49,040 --> 00:12:52,079
i could print out the methods the path

00:12:51,120 --> 00:12:54,880
the headers

00:12:52,079 --> 00:12:56,399
and the body which is what we want and

00:12:54,880 --> 00:12:58,000
then i'll just write a simple response

00:12:56,399 --> 00:12:59,279
so the client doesn't get upset

00:12:58,000 --> 00:13:00,480
i'll just tell it that everything was

00:12:59,279 --> 00:13:01,120
okay but i'm not going to send it any

00:13:00,480 --> 00:13:03,040
data

00:13:01,120 --> 00:13:05,120
i'll come to a response later again a

00:13:03,040 --> 00:13:07,519
bit of flow control and then close

00:13:05,120 --> 00:13:10,000
so if i send a hb1 request to this i

00:13:07,519 --> 00:13:12,639
should print out all the important parts

00:13:10,000 --> 00:13:13,440
send a valid response back and then

00:13:12,639 --> 00:13:17,120
close

00:13:13,440 --> 00:13:17,519
so we can test this so we run it this

00:13:17,120 --> 00:13:19,120
way

00:13:17,519 --> 00:13:20,720
and this time i'm going to use curl

00:13:19,120 --> 00:13:22,880
rather than telnet because

00:13:20,720 --> 00:13:25,120
curl will do the whole request for me

00:13:22,880 --> 00:13:25,839
and just using the v flag so we can see

00:13:25,120 --> 00:13:27,440
it all

00:13:25,839 --> 00:13:29,839
you see it's going to send this request

00:13:27,440 --> 00:13:31,920
line then these headers

00:13:29,839 --> 00:13:33,200
then the 5 bytes which is going to be

00:13:31,920 --> 00:13:35,200
hello

00:13:33,200 --> 00:13:37,040
and then it will get a response back and

00:13:35,200 --> 00:13:38,639
you can see when we test this it sends

00:13:37,040 --> 00:13:40,000
all this and gets a good response back

00:13:38,639 --> 00:13:42,880
and the connection closes so

00:13:40,000 --> 00:13:44,560
as far as kell's concerned our server

00:13:42,880 --> 00:13:46,160
did everything nicely

00:13:44,560 --> 00:13:47,440
as far as we concerned the server did as

00:13:46,160 --> 00:13:48,800
well because it's printed out the method

00:13:47,440 --> 00:13:50,560
here and the path

00:13:48,800 --> 00:13:52,800
and then all the headers that are passed

00:13:50,560 --> 00:13:55,839
in and the right body

00:13:52,800 --> 00:13:56,800
so that's pretty good so we now have a

00:13:55,839 --> 00:13:59,199
server

00:13:56,800 --> 00:14:00,000
a very basic server that can listen on a

00:13:59,199 --> 00:14:03,040
port

00:14:00,000 --> 00:14:05,120
and uh excuse me and

00:14:03,040 --> 00:14:06,880
understand the hp requests being sent to

00:14:05,120 --> 00:14:10,480
it

00:14:06,880 --> 00:14:10,480
so now we have this

00:14:10,639 --> 00:14:16,399
we need to effectively convert the hpb

00:14:13,760 --> 00:14:17,360
into ascii messages and to an extent

00:14:16,399 --> 00:14:19,680
this is what a

00:14:17,360 --> 00:14:21,760
an ascii server is it just changes from

00:14:19,680 --> 00:14:22,560
the hp protocol to the ascii protocol

00:14:21,760 --> 00:14:24,800
and back

00:14:22,560 --> 00:14:25,839
so you can imagine we get hbn we change

00:14:24,800 --> 00:14:28,160
it to an ascii message

00:14:25,839 --> 00:14:30,000
send it to the app the app is going to

00:14:28,160 --> 00:14:31,279
decide to do something

00:14:30,000 --> 00:14:33,519
so if you can imagine if you're using

00:14:31,279 --> 00:14:35,519
django it will match the path

00:14:33,519 --> 00:14:36,639
send it to the right handler the handler

00:14:35,519 --> 00:14:38,880
will

00:14:36,639 --> 00:14:40,399
do some logic and then send a response

00:14:38,880 --> 00:14:42,399
and that response is going to be

00:14:40,399 --> 00:14:43,839
a new ascii message which goes back to

00:14:42,399 --> 00:14:45,199
the server and our server is going to

00:14:43,839 --> 00:14:48,639
have to turn that ascii message

00:14:45,199 --> 00:14:50,000
into hpe and send it back to the client

00:14:48,639 --> 00:14:52,959
so that's what we're up to so let's

00:14:50,000 --> 00:14:54,320
focus a bit on the app

00:14:52,959 --> 00:14:56,079
sorry i'll come to the app in a minute

00:14:54,320 --> 00:14:59,279
let's focus first on changing

00:14:56,079 --> 00:15:02,639
hp into ascii so

00:14:59,279 --> 00:15:04,720
i mentioned earlier on that the scope

00:15:02,639 --> 00:15:06,959
pretty much fully discard defines the

00:15:04,720 --> 00:15:09,680
request other than the body

00:15:06,959 --> 00:15:10,079
and to fully define the request uh in

00:15:09,680 --> 00:15:11,600
this

00:15:10,079 --> 00:15:13,120
is a bit more than this actually but in

00:15:11,600 --> 00:15:15,199
this simple case for this

00:15:13,120 --> 00:15:16,320
presentation we need the method the path

00:15:15,199 --> 00:15:18,160
the headers

00:15:16,320 --> 00:15:20,320
and you see the ascii scope looks like

00:15:18,160 --> 00:15:23,120
this you tell it it's hpv

00:15:20,320 --> 00:15:25,199
has a method has the path information

00:15:23,120 --> 00:15:28,720
and then the headers

00:15:25,199 --> 00:15:31,279
so the code to do this looks like this

00:15:28,720 --> 00:15:32,000
so if we use our parser from earlier a

00:15:31,279 --> 00:15:33,759
scope

00:15:32,000 --> 00:15:40,320
which is the scope dictionary is simply

00:15:33,759 --> 00:15:42,079
created this way

00:15:40,320 --> 00:15:44,800
so that's great so now we can tell the

00:15:42,079 --> 00:15:46,800
app about the scope about the request

00:15:44,800 --> 00:15:49,360
but we also want to be able to tell the

00:15:46,800 --> 00:15:51,759
app about anybody

00:15:49,360 --> 00:15:54,160
and that obviously isn't going to happen

00:15:51,759 --> 00:15:56,639
for a get request but for a post request

00:15:54,160 --> 00:15:58,320
we have some content we the client is

00:15:56,639 --> 00:15:59,360
going to send us a body which is some

00:15:58,320 --> 00:16:01,199
bytes

00:15:59,360 --> 00:16:02,399
now the scope is created pretty much the

00:16:01,199 --> 00:16:05,600
same way as before well

00:16:02,399 --> 00:16:07,440
exactly the same but now we can send

00:16:05,600 --> 00:16:08,800
extra messages to the client and these

00:16:07,440 --> 00:16:12,079
extra messages

00:16:08,800 --> 00:16:14,160
are going to be type hp requests

00:16:12,079 --> 00:16:15,680
they're going to include some body and

00:16:14,160 --> 00:16:16,959
for as long as the server thinks there's

00:16:15,680 --> 00:16:18,959
more body coming

00:16:16,959 --> 00:16:20,639
we should set more body to true but as

00:16:18,959 --> 00:16:23,120
soon as we know there's no more body

00:16:20,639 --> 00:16:24,240
coming i the content length is five and

00:16:23,120 --> 00:16:26,000
we see five bytes

00:16:24,240 --> 00:16:27,839
we should say more body false which

00:16:26,000 --> 00:16:29,199
tells the app that it's got everything

00:16:27,839 --> 00:16:32,320
it's going to get about the request

00:16:29,199 --> 00:16:33,120
it can then move on to response so the

00:16:32,320 --> 00:16:35,600
code again

00:16:33,120 --> 00:16:36,720
is quite simple uh if we just has a

00:16:35,600 --> 00:16:39,920
simple function

00:16:36,720 --> 00:16:41,120
it takes a uh takes the body bytes and a

00:16:39,920 --> 00:16:42,560
little flag to say whether there's more

00:16:41,120 --> 00:16:44,880
bytes coming or not

00:16:42,560 --> 00:16:45,759
and we just create a message and we can

00:16:44,880 --> 00:16:48,839
send this message

00:16:45,759 --> 00:16:50,800
to the app and i'll show you how in a

00:16:48,839 --> 00:16:52,959
minute okay

00:16:50,800 --> 00:16:54,079
now coming back so the app has got

00:16:52,959 --> 00:16:54,959
everything it needs to know about the

00:16:54,079 --> 00:16:57,040
request

00:16:54,959 --> 00:16:58,320
now it needs to tell us how it wants to

00:16:57,040 --> 00:17:00,320
respond

00:16:58,320 --> 00:17:01,839
so the app does this by sending a

00:17:00,320 --> 00:17:04,559
message

00:17:01,839 --> 00:17:06,880
to us to us as being the server and that

00:17:04,559 --> 00:17:09,600
type is going to be the response start

00:17:06,880 --> 00:17:10,559
and the status code usually 200 but it

00:17:09,600 --> 00:17:12,000
could be anything

00:17:10,559 --> 00:17:14,319
and then whatever headers it wants to

00:17:12,000 --> 00:17:16,640
send so this is the first message

00:17:14,319 --> 00:17:19,039
the uh the app will send back to the

00:17:16,640 --> 00:17:21,280
server when it's ready to respond

00:17:19,039 --> 00:17:23,280
and the second message will be if it has

00:17:21,280 --> 00:17:24,880
any body

00:17:23,280 --> 00:17:26,640
so if it doesn't have any body this

00:17:24,880 --> 00:17:27,199
should be blank and more body would be

00:17:26,640 --> 00:17:29,200
false

00:17:27,199 --> 00:17:30,480
but if it does you can see it has hello

00:17:29,200 --> 00:17:32,559
in and

00:17:30,480 --> 00:17:34,559
us as a good server should probably

00:17:32,559 --> 00:17:37,200
check that the content length

00:17:34,559 --> 00:17:38,480
matches the the body it sent us uh the

00:17:37,200 --> 00:17:39,679
one we're going to write today doesn't

00:17:38,480 --> 00:17:40,559
but you can imagine that's a nice

00:17:39,679 --> 00:17:42,160
extension

00:17:40,559 --> 00:17:44,080
just to make sure nothing strange is

00:17:42,160 --> 00:17:47,679
going on

00:17:44,080 --> 00:17:50,000
so just to summarize um when we get a hp

00:17:47,679 --> 00:17:52,799
request we create a scope

00:17:50,000 --> 00:17:54,000
and we pass that to the app we call the

00:17:52,799 --> 00:17:57,200
app with the scope

00:17:54,000 --> 00:17:57,840
we then pass ascii messages defining

00:17:57,200 --> 00:17:59,760
anybody

00:17:57,840 --> 00:18:01,919
to the app the app's going to then

00:17:59,760 --> 00:18:03,440
decide what to do with that request

00:18:01,919 --> 00:18:04,960
and then send a response and that

00:18:03,440 --> 00:18:06,080
response is going to be a start response

00:18:04,960 --> 00:18:09,679
message

00:18:06,080 --> 00:18:12,880
and then any extra response messages

00:18:09,679 --> 00:18:14,240
and so that's the app process so now

00:18:12,880 --> 00:18:15,919
i can actually tell you about the app

00:18:14,240 --> 00:18:20,160
itself

00:18:15,919 --> 00:18:22,880
so this is a hopefully quite simple app

00:18:20,160 --> 00:18:24,320
which is uh very similar i hope to the

00:18:22,880 --> 00:18:27,120
echo server we said earlier

00:18:24,320 --> 00:18:28,720
it's basically going to echo out anybody

00:18:27,120 --> 00:18:30,160
that's been sent to us but now it's

00:18:28,720 --> 00:18:33,440
running over the hp

00:18:30,160 --> 00:18:35,679
protocol so you can see uh in this case

00:18:33,440 --> 00:18:37,520
we don't actually care about the scope

00:18:35,679 --> 00:18:39,840
all we want to do is receive the

00:18:37,520 --> 00:18:42,960
messages from the server

00:18:39,840 --> 00:18:43,520
and get the body basically so every

00:18:42,960 --> 00:18:46,000
message

00:18:43,520 --> 00:18:47,440
we get every event we get the body out

00:18:46,000 --> 00:18:49,440
and extend our

00:18:47,440 --> 00:18:50,640
body copy and as soon as we're told

00:18:49,440 --> 00:18:53,120
there's no more body

00:18:50,640 --> 00:18:54,160
we break out of this loop so the server

00:18:53,120 --> 00:18:56,080
tells us

00:18:54,160 --> 00:18:58,080
about all the all the crests all the

00:18:56,080 --> 00:19:00,160
body and then we

00:18:58,080 --> 00:19:02,720
do something do some logic this could be

00:19:00,160 --> 00:19:04,400
like i said just like matching the path

00:19:02,720 --> 00:19:06,400
uh deciding which route to call but in

00:19:04,400 --> 00:19:08,799
our echo app it's all we know

00:19:06,400 --> 00:19:11,280
it's going to do is send the body back

00:19:08,799 --> 00:19:12,799
so we start by saying

00:19:11,280 --> 00:19:14,720
everything's good and we're going to

00:19:12,799 --> 00:19:18,000
send you the link for the body

00:19:14,720 --> 00:19:20,000
bites back and then we send it basically

00:19:18,000 --> 00:19:21,600
so this is it a very simple app that

00:19:20,000 --> 00:19:23,280
will just listen to all the messages

00:19:21,600 --> 00:19:25,360
from the server build up a body

00:19:23,280 --> 00:19:27,440
and then send that back to the server

00:19:25,360 --> 00:19:31,200
expecting the server to then echo that

00:19:27,440 --> 00:19:33,280
back to the client so now we have

00:19:31,200 --> 00:19:34,480
a test app to use we can actually build

00:19:33,280 --> 00:19:36,640
our server

00:19:34,480 --> 00:19:39,120
and our server will call the app so just

00:19:36,640 --> 00:19:41,120
to qualify here what we just spoke about

00:19:39,120 --> 00:19:43,280
here was an ascii app you can use any

00:19:41,120 --> 00:19:44,240
ascii app for it but this one's kind of

00:19:43,280 --> 00:19:46,000
simple enough to

00:19:44,240 --> 00:19:47,919
show in the example but what we're

00:19:46,000 --> 00:19:49,600
trying to build is the server

00:19:47,919 --> 00:19:52,000
what i'm going to focus on first is is

00:19:49,600 --> 00:19:54,400
this flow so i i spoke through

00:19:52,000 --> 00:19:55,600
this this kind of the messages come from

00:19:54,400 --> 00:19:57,039
the client http

00:19:55,600 --> 00:19:58,640
our server turns them into ascii and

00:19:57,039 --> 00:20:00,880
sends them to the app so i'm going to

00:19:58,640 --> 00:20:04,159
focus on that first

00:20:00,880 --> 00:20:07,600
and this is the code for it so this is a

00:20:04,159 --> 00:20:08,080
a little bit more uh code so i'll take a

00:20:07,600 --> 00:20:10,159
while

00:20:08,080 --> 00:20:11,840
to talk through it again it's another

00:20:10,159 --> 00:20:13,200
server so very similar to the

00:20:11,840 --> 00:20:15,280
two we've spoken about before it just

00:20:13,200 --> 00:20:17,440
takes a reader and a writer

00:20:15,280 --> 00:20:19,600
we use our password from earlier and

00:20:17,440 --> 00:20:21,120
this time we create a cue

00:20:19,600 --> 00:20:22,640
to put the messages we're going to send

00:20:21,120 --> 00:20:24,799
to the app so this is

00:20:22,640 --> 00:20:26,000
this is what this is for so to app we're

00:20:24,799 --> 00:20:29,120
going to send to the app

00:20:26,000 --> 00:20:29,679
we're also going to keep account of how

00:20:29,120 --> 00:20:31,520
much

00:20:29,679 --> 00:20:34,159
how many bytes we've read just to know

00:20:31,520 --> 00:20:37,840
when to finish basically

00:20:34,159 --> 00:20:39,120
uh okay so again

00:20:37,840 --> 00:20:40,880
we're going to keep reading as long as

00:20:39,120 --> 00:20:42,640
the client hasn't told us it's done or

00:20:40,880 --> 00:20:45,679
there's a disconnection

00:20:42,640 --> 00:20:47,440
we feed the lines into the parser as

00:20:45,679 --> 00:20:50,480
before

00:20:47,440 --> 00:20:52,240
this time if we find after the

00:20:50,480 --> 00:20:53,600
the past is in the body stage there is

00:20:52,240 --> 00:20:55,039
no body expected i

00:20:53,600 --> 00:20:57,120
maybe it's a get request or something

00:20:55,039 --> 00:21:00,080
like that we simply put

00:20:57,120 --> 00:21:00,640
a message to the client that says i'm

00:21:00,080 --> 00:21:03,679
done

00:21:00,640 --> 00:21:05,520
and we can break out this loop

00:21:03,679 --> 00:21:07,440
if not we're going to start reading in

00:21:05,520 --> 00:21:08,080
the body and we're going to send a

00:21:07,440 --> 00:21:10,799
message

00:21:08,080 --> 00:21:10,799
to the client

00:21:11,120 --> 00:21:16,240
that has these body bytes in and

00:21:14,400 --> 00:21:17,760
it tells us it tells the client whether

00:21:16,240 --> 00:21:19,520
there's anything left so we're keeping

00:21:17,760 --> 00:21:21,360
track of how many we've read

00:21:19,520 --> 00:21:22,720
i just noticed what's making me hesitate

00:21:21,360 --> 00:21:24,799
is this should uh

00:21:22,720 --> 00:21:26,559
say red here rather than length body

00:21:24,799 --> 00:21:27,520
otherwise it won't break so sorry about

00:21:26,559 --> 00:21:28,799
that typo

00:21:27,520 --> 00:21:30,320
but hopefully you can see what's going

00:21:28,799 --> 00:21:31,039
on here we're reading the body from the

00:21:30,320 --> 00:21:33,520
client

00:21:31,039 --> 00:21:35,679
and that's coming in chunks very likely

00:21:33,520 --> 00:21:37,120
we're sending each chunk to the app

00:21:35,679 --> 00:21:39,120
and we're keeping track of how many

00:21:37,120 --> 00:21:40,960
we've read so that when we've read as

00:21:39,120 --> 00:21:44,159
many as we expect we can break out

00:21:40,960 --> 00:21:47,120
of this loop so

00:21:44,159 --> 00:21:48,320
uh we've hopefully here passed the

00:21:47,120 --> 00:21:51,280
entire

00:21:48,320 --> 00:21:53,280
uh request from the client and now we've

00:21:51,280 --> 00:21:55,679
we can create a scope as well

00:21:53,280 --> 00:21:57,360
so with the combination of the scope and

00:21:55,679 --> 00:21:58,240
this queue of messages that we're going

00:21:57,360 --> 00:22:00,320
to send to the app

00:21:58,240 --> 00:22:02,000
we have everything the app needs to

00:22:00,320 --> 00:22:04,080
understand the request

00:22:02,000 --> 00:22:05,280
and i'll just note as well here that you

00:22:04,080 --> 00:22:07,360
can kind of see

00:22:05,280 --> 00:22:09,039
how you may be thinking like we've read

00:22:07,360 --> 00:22:11,039
and done everything before we've

00:22:09,039 --> 00:22:12,720
we've called the app and you're right

00:22:11,039 --> 00:22:14,400
this is to make it simpler to show on

00:22:12,720 --> 00:22:16,320
the slide but

00:22:14,400 --> 00:22:18,400
a real ascii server could have actually

00:22:16,320 --> 00:22:19,520
created the scope before it even started

00:22:18,400 --> 00:22:21,840
to read the body

00:22:19,520 --> 00:22:23,440
and the app could have started to

00:22:21,840 --> 00:22:24,960
understand and process the request

00:22:23,440 --> 00:22:26,159
whilst the body was still being

00:22:24,960 --> 00:22:28,240
still arriving that's one of the

00:22:26,159 --> 00:22:28,559
advantages of it but it's a little hard

00:22:28,240 --> 00:22:32,000
to

00:22:28,559 --> 00:22:36,240
write that on a slide okay

00:22:32,000 --> 00:22:36,960
so we've now got the information coming

00:22:36,240 --> 00:22:38,559
in

00:22:36,960 --> 00:22:40,880
turned into asking messages to send to

00:22:38,559 --> 00:22:41,280
the app now we need to go back as well

00:22:40,880 --> 00:22:42,799
so

00:22:41,280 --> 00:22:45,200
the app is going to send us some ascii

00:22:42,799 --> 00:22:47,039
messages which we need to understand

00:22:45,200 --> 00:22:48,640
turn into hp messages and send back to

00:22:47,039 --> 00:22:51,200
the client

00:22:48,640 --> 00:22:52,320
so this is the code for that so now we

00:22:51,200 --> 00:22:55,840
have another queue

00:22:52,320 --> 00:22:55,840
coming from the app

00:22:57,200 --> 00:23:01,360
and now i just note that we actually do

00:22:59,360 --> 00:23:03,039
call the app here

00:23:01,360 --> 00:23:04,400
so this is the bit where the app's going

00:23:03,039 --> 00:23:06,000
to do everything it's going to read from

00:23:04,400 --> 00:23:08,960
the two app queue

00:23:06,000 --> 00:23:09,760
and fill up the from app queue so us is

00:23:08,960 --> 00:23:11,200
the server

00:23:09,760 --> 00:23:14,559
we just need to get the messages from

00:23:11,200 --> 00:23:17,120
the app queue

00:23:14,559 --> 00:23:18,080
the first one we expect is the response

00:23:17,120 --> 00:23:20,000
start

00:23:18,080 --> 00:23:22,000
and when that happens we just write out

00:23:20,000 --> 00:23:25,360
the status code

00:23:22,000 --> 00:23:28,880
and we write out the headers and a

00:23:25,360 --> 00:23:32,000
blank line then the next messages

00:23:28,880 --> 00:23:34,400
we expect are body so

00:23:32,000 --> 00:23:35,440
as long as the there is a body in it we

00:23:34,400 --> 00:23:38,559
write it out

00:23:35,440 --> 00:23:40,400
and then as soon as the clients the app

00:23:38,559 --> 00:23:43,679
sorry has told us there's no more body

00:23:40,400 --> 00:23:47,039
we can break this loop as well

00:23:43,679 --> 00:23:48,240
so that is it pretty much the

00:23:47,039 --> 00:23:50,240
combination

00:23:48,240 --> 00:23:51,840
of this code to send messages back to

00:23:50,240 --> 00:23:54,400
the client

00:23:51,840 --> 00:23:55,520
and this code to read messages from the

00:23:54,400 --> 00:23:59,760
client

00:23:55,520 --> 00:23:59,760
gives us an ascii server for http

00:24:00,080 --> 00:24:04,000
so let's test it out again this code is

00:24:03,279 --> 00:24:08,000
uh

00:24:04,000 --> 00:24:09,279
in the repo so we'll use curl again

00:24:08,000 --> 00:24:10,320
so this time i'm going to do the same

00:24:09,279 --> 00:24:11,679
things earlier i'm just going to send

00:24:10,320 --> 00:24:13,520
hello to it

00:24:11,679 --> 00:24:15,279
it's going to send all these headers but

00:24:13,520 --> 00:24:15,840
what we're expecting our app to do is

00:24:15,279 --> 00:24:19,279
just

00:24:15,840 --> 00:24:21,440
echo back hello to us i tested it

00:24:19,279 --> 00:24:23,360
with a lowercase h so sorry about that

00:24:21,440 --> 00:24:25,440
typo as well

00:24:23,360 --> 00:24:26,880
but that's what it does and it's working

00:24:25,440 --> 00:24:30,960
as we expect so as long as

00:24:26,880 --> 00:24:33,520
clients do the very limited hp

00:24:30,960 --> 00:24:35,200
one that we support this will work fine

00:24:33,520 --> 00:24:37,200
and uh

00:24:35,200 --> 00:24:39,200
yeah it works nicely as a as an ascii

00:24:37,200 --> 00:24:41,600
server so if you follow along you now

00:24:39,200 --> 00:24:44,640
have your own ascii server

00:24:41,600 --> 00:24:46,960
so what's next uh well uh

00:24:44,640 --> 00:24:48,000
whilst the uh the simple hp pass i

00:24:46,960 --> 00:24:50,240
showed you there

00:24:48,000 --> 00:24:51,200
uh does work and it gives really nice

00:24:50,240 --> 00:24:53,840
benchmarking

00:24:51,200 --> 00:24:55,360
scores in fact it is not stable enough

00:24:53,840 --> 00:24:56,000
for production and it doesn't cover any

00:24:55,360 --> 00:24:58,960
with near

00:24:56,000 --> 00:25:01,039
enough edge cases so i'd recommend you

00:24:58,960 --> 00:25:02,240
use something like h11 for this which is

00:25:01,039 --> 00:25:06,559
your sans io

00:25:02,240 --> 00:25:08,159
uh hb parser and

00:25:06,559 --> 00:25:10,000
you can then build on from there and

00:25:08,159 --> 00:25:11,600
there's an example in the repo for this

00:25:10,000 --> 00:25:13,440
talk if you want to look at that

00:25:11,600 --> 00:25:15,279
going any further i think you should

00:25:13,440 --> 00:25:16,559
take a look at hyper corn which is a

00:25:15,279 --> 00:25:18,880
project i maintain

00:25:16,559 --> 00:25:20,080
so hyper corn is an ascii server that

00:25:18,880 --> 00:25:23,520
supports asynco

00:25:20,080 --> 00:25:27,520
and trio workers sports hb1 using h11

00:25:23,520 --> 00:25:29,919
http 2 using h2 and hp3 using ao quick

00:25:27,520 --> 00:25:30,720
it all supports web sockets using ws

00:25:29,919 --> 00:25:32,799
proto

00:25:30,720 --> 00:25:34,000
and i of course didn't talk about web

00:25:32,799 --> 00:25:35,600
sockets at all now but

00:25:34,000 --> 00:25:37,840
the real advantage of an ascii a

00:25:35,600 --> 00:25:38,799
synchronous server is websockets fit

00:25:37,840 --> 00:25:40,799
very naturally and

00:25:38,799 --> 00:25:42,000
they you don't have to kind of like albo

00:25:40,799 --> 00:25:45,120
them in like you do with whiskey

00:25:42,000 --> 00:25:46,559
servers so uh

00:25:45,120 --> 00:25:48,640
that's it hopefully you've got a good

00:25:46,559 --> 00:25:51,679
idea of what makes up a very basic

00:25:48,640 --> 00:25:54,000
ascii server and uh yeah i look forward

00:25:51,679 --> 00:25:55,919
to your questions

00:25:54,000 --> 00:25:57,919
oh yeah thank thank you very much for

00:25:55,919 --> 00:26:00,480
the talk um

00:25:57,919 --> 00:26:02,640
i think you overwhelmed almost everybody

00:26:00,480 --> 00:26:05,600
because we just have one question

00:26:02,640 --> 00:26:07,600
and what's the benefit of writing this

00:26:05,600 --> 00:26:08,960
by hand compared to using a library like

00:26:07,600 --> 00:26:12,240
flask

00:26:08,960 --> 00:26:15,360
uh so flask is is just the

00:26:12,240 --> 00:26:17,520
uh the app side so you need a

00:26:15,360 --> 00:26:18,799
a server for that as well now for flash

00:26:17,520 --> 00:26:21,840
you probably use something like

00:26:18,799 --> 00:26:25,840
unicorn or you whiskey which are your

00:26:21,840 --> 00:26:29,200
wsdi servers so

00:26:25,840 --> 00:26:29,520
flask itself isn't yet ascii compatible

00:26:29,200 --> 00:26:32,000
so

00:26:29,520 --> 00:26:33,279
you wouldn't use flask but you if you

00:26:32,000 --> 00:26:36,480
are

00:26:33,279 --> 00:26:39,760
using say a ascii one like uh

00:26:36,480 --> 00:26:41,360
starlet or sonic or any of the others

00:26:39,760 --> 00:26:43,760
then you could use a server like this

00:26:41,360 --> 00:26:44,960
you've written yourself uh there is no

00:26:43,760 --> 00:26:46,559
advantage i would actually say you

00:26:44,960 --> 00:26:47,039
probably don't want to write it yourself

00:26:46,559 --> 00:26:49,440
because

00:26:47,039 --> 00:26:50,720
there's a lot you can get wrong however

00:26:49,440 --> 00:26:51,520
i think it's quite interesting to know

00:26:50,720 --> 00:26:52,799
how this works

00:26:51,520 --> 00:26:54,640
and to have a good understanding of the

00:26:52,799 --> 00:26:57,360
code you're using so hopefully

00:26:54,640 --> 00:26:58,799
you've gained that from my talk yeah

00:26:57,360 --> 00:27:00,799
thank you very much that was

00:26:58,799 --> 00:27:02,880
really interesting so let's have some

00:27:00,799 --> 00:27:07,840
virtual applause and everybody at home

00:27:02,880 --> 00:27:07,840
please clap along thanks

00:27:12,400 --> 00:27:16,320
and just a reminder to everybody who

00:27:14,400 --> 00:27:18,399
wants to learn more about this

00:27:16,320 --> 00:27:19,520
uh there is a separate chat room for

00:27:18,399 --> 00:27:22,559
this talk called

00:27:19,520 --> 00:27:23,360
talk asgi server so if you press

00:27:22,559 --> 00:27:27,039
controls

00:27:23,360 --> 00:27:27,520
uh k and asdi you will find it on this

00:27:27,039 --> 00:27:29,440
call

00:27:27,520 --> 00:27:30,559
so if you have any further questions you

00:27:29,440 --> 00:27:32,399
will probably

00:27:30,559 --> 00:27:34,080
be able to go there but i see there's a

00:27:32,399 --> 00:27:35,919
last minute question

00:27:34,080 --> 00:27:38,640
uh coming in and we should ask that it's

00:27:35,919 --> 00:27:41,760
why django and would django and tornado

00:27:38,640 --> 00:27:45,039
be considered wsgi

00:27:41,760 --> 00:27:47,760
uh yes they they are both uh wsgi

00:27:45,039 --> 00:27:49,120
however i think they're both i'm not too

00:27:47,760 --> 00:27:51,919
sure about tornado but

00:27:49,120 --> 00:27:53,520
django certainly is gaining asgi

00:27:51,919 --> 00:27:57,360
capabilities as well so

00:27:53,520 --> 00:28:00,320
django 3 i think or 3.1 which is

00:27:57,360 --> 00:28:00,880
going to be released this this summer is

00:28:00,320 --> 00:28:02,799
uh

00:28:00,880 --> 00:28:04,399
it's going to be an asti framework as

00:28:02,799 --> 00:28:07,840
well so you could use

00:28:04,399 --> 00:28:08,320
sgi servers like hyper corn or daphne or

00:28:07,840 --> 00:28:11,360
others

00:28:08,320 --> 00:28:13,039
to serve your django apps and so

00:28:11,360 --> 00:28:15,120
for example from the previous dock if

00:28:13,039 --> 00:28:17,840
you wanted to play around with http 3

00:28:15,120 --> 00:28:18,720
you could start hypercall with hp3 serve

00:28:17,840 --> 00:28:21,760
your django app

00:28:18,720 --> 00:28:22,240
and play around have fun and we have one

00:28:21,760 --> 00:28:24,640
final

00:28:22,240 --> 00:28:28,559
fast question from javier do you

00:28:24,640 --> 00:28:30,640
recommend to use hypercon with fast api

00:28:28,559 --> 00:28:31,840
yeah it worked fine it it depends really

00:28:30,640 --> 00:28:33,600
on uh

00:28:31,840 --> 00:28:35,919
your use case and what you'd what you'd

00:28:33,600 --> 00:28:37,279
like to do but yeah i'd certainly i mean

00:28:35,919 --> 00:28:38,240
i would personally because i work on

00:28:37,279 --> 00:28:40,320
hyper corn

00:28:38,240 --> 00:28:41,440
but uh yeah you certainly can it's up to

00:28:40,320 --> 00:28:43,679
you

00:28:41,440 --> 00:28:45,440
okay thank you very much again that's

00:28:43,679 --> 00:28:49,279
all that we have time for now

00:28:45,440 --> 00:28:50,640
um so um we shall have to get ready for

00:28:49,279 --> 00:28:52,480
next talk so

00:28:50,640 --> 00:28:57,919
see you at the conference and in the

00:28:52,480 --> 00:28:57,919

YouTube URL: https://www.youtube.com/watch?v=FNBxYyeti-s


