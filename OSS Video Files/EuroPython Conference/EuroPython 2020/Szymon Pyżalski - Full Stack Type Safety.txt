Title: Szymon Pyżalski - Full Stack Type Safety
Publication date: 2020-09-15
Playlist: EuroPython 2020
Description: 
	"Full Stack Type Safety
EuroPython 2020 - Talk - 2020-07-23 - Brian
Online

By Szymon Pyżalski

The introduction of PEP-484 gave us an option to enforce the internal type consistency of our Python applications. Our web projects, however, consist of multiple layers, with the Python app taking the role of an HTTP backend. What options do we have to ensure consistency across our stack?
In this talk, we will see some technologies that we can employ to enforce the contract between the layers of our stack. Especially between the frontend and backend. We will demo, how this can be achieved with REST/Swagger and with GraphQL. As both the Graphene library and the open API support for django-rest-framework are both a work-in-progress, we would check, what is possible, and what is still lacking. We will also discuss various approaches to the design: backend first, auto-generating backend from the spec, and TDD, with their advantages and disadvantages.
The topic would be discussed on a simple web application. We would try to play some realistic scenarios, where a careless developer breaks the contract to see how such a mistake can be spotted in the CI phase of the development cycle.
Basic knowledge of Django and JavaScript is required to understand the talk. Some familiarity with TypeScript and ReactJS would also be helpful. However, I plan to explain the code to the listeners that didn’t have prior exposure to these technologies.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2020.europython.eu/events/speaker-release-agreement/

    "
Captions: 
	00:00:06,480 --> 00:00:10,800
uh are you ready to

00:00:07,839 --> 00:00:11,679
do your screen share in in a few seconds

00:00:10,800 --> 00:00:14,080
yes of course

00:00:11,679 --> 00:00:14,960
right on your side you're you're calling

00:00:14,080 --> 00:00:19,439
in from poland

00:00:14,960 --> 00:00:22,720
right yes i do and

00:00:19,439 --> 00:00:25,439
so your talk is about type safety

00:00:22,720 --> 00:00:26,240
and in the descriptions you said it goes

00:00:25,439 --> 00:00:30,560
beyond

00:00:26,240 --> 00:00:33,520
pep 48 for uh the thai pins

00:00:30,560 --> 00:00:34,800
so um it will be really interesting to

00:00:33,520 --> 00:00:38,320
see

00:00:34,800 --> 00:00:41,360
what you want to do beyond that path

00:00:38,320 --> 00:00:45,600
so if you're ready please please start

00:00:41,360 --> 00:00:48,239
okay thank you so

00:00:45,600 --> 00:00:50,640
what i would like to talk about let's

00:00:48,239 --> 00:00:50,640
first

00:00:51,120 --> 00:00:59,039
define what i mean by

00:00:54,480 --> 00:01:02,800
type safety and also what i mean by uh

00:00:59,039 --> 00:01:05,040
full stock type type safety so

00:01:02,800 --> 00:01:06,000
the type safety that we want to achieve

00:01:05,040 --> 00:01:10,000
is

00:01:06,000 --> 00:01:14,080
catching all the errors all the bugs

00:01:10,000 --> 00:01:17,119
that are caused by type mismatches

00:01:14,080 --> 00:01:18,240
as soon as possible so ideally it would

00:01:17,119 --> 00:01:21,200
be during the

00:01:18,240 --> 00:01:21,840
code development but never later than in

00:01:21,200 --> 00:01:25,360
cre

00:01:21,840 --> 00:01:28,960
they shouldn't cause any bugs that

00:01:25,360 --> 00:01:29,920
happen later on the qa phase because

00:01:28,960 --> 00:01:33,439
this is

00:01:29,920 --> 00:01:36,079
unnecessary cost unnecessary time lost

00:01:33,439 --> 00:01:37,360
in our development cycle when they have

00:01:36,079 --> 00:01:41,119
to be

00:01:37,360 --> 00:01:44,240
found in qa and return to developers

00:01:41,119 --> 00:01:46,720
we want automatization here and also we

00:01:44,240 --> 00:01:49,600
want to catch typing errors that span

00:01:46,720 --> 00:01:53,360
layers of stock because

00:01:49,600 --> 00:01:56,799
we might have errors that

00:01:53,360 --> 00:01:57,360
are local to some code base but we also

00:01:56,799 --> 00:01:59,759
have

00:01:57,360 --> 00:02:01,439
data that is passed from a layer to a

00:01:59,759 --> 00:02:04,479
layer and we have

00:02:01,439 --> 00:02:07,520
contracts between these layers and also

00:02:04,479 --> 00:02:11,280
we want some automatic way to find

00:02:07,520 --> 00:02:16,000
that we are somehow violating this

00:02:11,280 --> 00:02:17,500
contract what are our main problems here

00:02:16,000 --> 00:02:19,440
first thing the

00:02:17,500 --> 00:02:22,319
[Music]

00:02:19,440 --> 00:02:24,560
system of type annotations in python is

00:02:22,319 --> 00:02:27,680
quite new it is quite a major

00:02:24,560 --> 00:02:30,959
not everybody is using it it is still

00:02:27,680 --> 00:02:34,160
in development so

00:02:30,959 --> 00:02:36,959
it is not not yet perfect of course

00:02:34,160 --> 00:02:38,879
the second thing is uh we have various

00:02:36,959 --> 00:02:41,920
paradigms of uh

00:02:38,879 --> 00:02:43,840
typing in various layers and this is

00:02:41,920 --> 00:02:46,879
also a problem how to

00:02:43,840 --> 00:02:50,480
uh how we can propagate the

00:02:46,879 --> 00:02:54,319
information about the uh about the type

00:02:50,480 --> 00:02:57,519
from one layer to another and

00:02:54,319 --> 00:03:00,159
also the problem is that we when we test

00:02:57,519 --> 00:03:03,360
we usually test layers in a separation

00:03:00,159 --> 00:03:06,720
it is much easier to write unit tests

00:03:03,360 --> 00:03:10,400
than integration test and it is much

00:03:06,720 --> 00:03:12,159
cheaper to run uv tests than integration

00:03:10,400 --> 00:03:16,319
tests so

00:03:12,159 --> 00:03:19,360
we mostly write unit tests not

00:03:16,319 --> 00:03:22,560
focusing that much on uh

00:03:19,360 --> 00:03:26,239
on the contracts between various

00:03:22,560 --> 00:03:26,239
components of our stock

00:03:26,720 --> 00:03:30,239
the one thing i would like to do in the

00:03:29,599 --> 00:03:34,159
beginning

00:03:30,239 --> 00:03:36,720
is to somehow discuss the terminology

00:03:34,159 --> 00:03:37,280
because this terminology is used quite

00:03:36,720 --> 00:03:40,480
loosely

00:03:37,280 --> 00:03:42,560
in the various publications and

00:03:40,480 --> 00:03:43,680
sometimes people understand different

00:03:42,560 --> 00:03:47,440
things by

00:03:43,680 --> 00:03:49,760
these terms so i would like to just

00:03:47,440 --> 00:03:51,440
ensure that we are on the same page so

00:03:49,760 --> 00:03:54,400
that we re

00:03:51,440 --> 00:03:55,840
understand the idea of weak versus

00:03:54,400 --> 00:03:59,360
strong

00:03:55,840 --> 00:04:02,720
in these terms the

00:03:59,360 --> 00:04:05,200
typing is weak if we if the value can be

00:04:02,720 --> 00:04:07,920
somehow misinterpreted

00:04:05,200 --> 00:04:08,640
unless we care about it ourselves and it

00:04:07,920 --> 00:04:11,959
is strong

00:04:08,640 --> 00:04:15,360
if a type system is protecting us from

00:04:11,959 --> 00:04:15,920
misinterpretations the basic example

00:04:15,360 --> 00:04:19,280
would be

00:04:15,920 --> 00:04:23,680
in c here we are setting

00:04:19,280 --> 00:04:27,199
two signed integers two different values

00:04:23,680 --> 00:04:31,040
the first one we are putting to printf

00:04:27,199 --> 00:04:31,040
but we are using incorrect

00:04:31,120 --> 00:04:38,400
format formatting clause and we get a

00:04:34,639 --> 00:04:41,759
value that is completely different and

00:04:38,400 --> 00:04:45,520
doesn't mean anything for our user

00:04:41,759 --> 00:04:46,800
here we are making uh we are passing the

00:04:45,520 --> 00:04:50,479
value by

00:04:46,800 --> 00:04:53,360
uh by a pointer we

00:04:50,479 --> 00:04:54,240
then cast the pointer to a pointer to a

00:04:53,360 --> 00:04:57,440
different type

00:04:54,240 --> 00:05:00,560
and it all nicely

00:04:57,440 --> 00:05:01,600
compiles but we also get a value that

00:05:00,560 --> 00:05:03,950
doesn't make

00:05:01,600 --> 00:05:05,759
any sense for us because this

00:05:03,950 --> 00:05:10,880
[Music]

00:05:05,759 --> 00:05:13,840
value that is ordinary in gets

00:05:10,880 --> 00:05:14,639
interpreted as a short end actually some

00:05:13,840 --> 00:05:16,960
bytes of this

00:05:14,639 --> 00:05:18,560
value we may think that this is

00:05:16,960 --> 00:05:21,759
something that wouldn't happen

00:05:18,560 --> 00:05:24,800
in the higher level languages but i will

00:05:21,759 --> 00:05:25,280
show how this can very similar thing can

00:05:24,800 --> 00:05:28,000
happen

00:05:25,280 --> 00:05:29,919
in the sequel so this is not completely

00:05:28,000 --> 00:05:32,400
irrelevant for us

00:05:29,919 --> 00:05:33,280
then we have static versus dynamic which

00:05:32,400 --> 00:05:36,639
i believe

00:05:33,280 --> 00:05:39,919
all of the pythonistas are familiar with

00:05:36,639 --> 00:05:40,720
of course python is a dynamic language

00:05:39,919 --> 00:05:43,520
because

00:05:40,720 --> 00:05:44,000
the types are determined during runtime

00:05:43,520 --> 00:05:47,280
not

00:05:44,000 --> 00:05:50,560
during compile time so if we have a

00:05:47,280 --> 00:05:53,199
python function without any annotations

00:05:50,560 --> 00:05:55,039
we basically don't know what are the

00:05:53,199 --> 00:05:58,240
types of these arguments

00:05:55,039 --> 00:06:01,680
we can pass various

00:05:58,240 --> 00:06:04,560
very different types here and

00:06:01,680 --> 00:06:06,319
they would all work and even if we put

00:06:04,560 --> 00:06:09,600
something that doesn't work

00:06:06,319 --> 00:06:10,319
we wouldn't know about this before we

00:06:09,600 --> 00:06:13,840
actually

00:06:10,319 --> 00:06:17,039
run this so this is the

00:06:13,840 --> 00:06:20,319
thing about dynamic typing

00:06:17,039 --> 00:06:24,319
and an example of static typing

00:06:20,319 --> 00:06:28,560
is in golang where we

00:06:24,319 --> 00:06:31,759
can actually always determine what type

00:06:28,560 --> 00:06:32,400
any variable has either because like

00:06:31,759 --> 00:06:36,160
here

00:06:32,400 --> 00:06:38,000
it is marked or because it is assigned

00:06:36,160 --> 00:06:39,600
to some value of a known time to a

00:06:38,000 --> 00:06:42,160
literal or

00:06:39,600 --> 00:06:44,080
to a result of some function and we know

00:06:42,160 --> 00:06:46,800
the result of the function here

00:06:44,080 --> 00:06:47,360
so it's static typing doesn't mean that

00:06:46,800 --> 00:06:50,000
everything

00:06:47,360 --> 00:06:52,000
is marked but it means that everything

00:06:50,000 --> 00:06:52,639
we can determine just by looking at the

00:06:52,000 --> 00:06:56,479
code and

00:06:52,639 --> 00:06:59,599
then our compiler can determine it

00:06:56,479 --> 00:07:01,520
we have also another

00:06:59,599 --> 00:07:03,120
distinction that is sometimes called

00:07:01,520 --> 00:07:06,319
weak strong

00:07:03,120 --> 00:07:09,440
but i would like to say

00:07:06,319 --> 00:07:14,000
the strict versus loose

00:07:09,440 --> 00:07:17,440
in strict typing we have explicit

00:07:14,000 --> 00:07:21,199
type conversions we have to

00:07:17,440 --> 00:07:25,440
cast the values explicitly if we don't

00:07:21,199 --> 00:07:25,840
we get exceptions or compilation errors

00:07:25,440 --> 00:07:28,880
that

00:07:25,840 --> 00:07:30,080
tell us that we have a type mismatch in

00:07:28,880 --> 00:07:33,039
those typing

00:07:30,080 --> 00:07:34,400
there can be some implicit type

00:07:33,039 --> 00:07:38,160
conversion

00:07:34,400 --> 00:07:41,280
and this thing is actually not

00:07:38,160 --> 00:07:45,199
not a binary thing this is a

00:07:41,280 --> 00:07:47,759
spectrum and to show you

00:07:45,199 --> 00:07:49,039
i can show you a language that is

00:07:47,759 --> 00:07:52,160
stricter than python

00:07:49,039 --> 00:07:54,000
this is haskell and in haskell

00:07:52,160 --> 00:07:55,840
trying to do something like this trying

00:07:54,000 --> 00:08:00,879
to print an integer

00:07:55,840 --> 00:08:04,319
would cause error trying to pass a

00:08:00,879 --> 00:08:07,120
list as a sole argument to if

00:08:04,319 --> 00:08:08,800
it is also an error so these are things

00:08:07,120 --> 00:08:12,080
that we are familiar with

00:08:08,800 --> 00:08:15,919
with from python and we can't bring it

00:08:12,080 --> 00:08:19,039
there because haskell

00:08:15,919 --> 00:08:21,039
requires some more discipline for us

00:08:19,039 --> 00:08:23,440
on the other half and there are

00:08:21,039 --> 00:08:26,160
languages that are looser than python

00:08:23,440 --> 00:08:26,639
famously it's javascript in javascript

00:08:26,160 --> 00:08:30,319
almost

00:08:26,639 --> 00:08:33,440
every expression we create

00:08:30,319 --> 00:08:36,399
would be interpreted somehow by

00:08:33,440 --> 00:08:37,680
the interpreter we can see for example

00:08:36,399 --> 00:08:41,519
that here

00:08:37,680 --> 00:08:46,399
the number is cast to a string

00:08:41,519 --> 00:08:49,600
here it's the object is cast to a number

00:08:46,399 --> 00:08:52,320
and so on somehow this leads to

00:08:49,600 --> 00:08:55,120
strange things happening for example

00:08:52,320 --> 00:08:58,560
here we get not a number but

00:08:55,120 --> 00:09:01,920
we are not working with numbers and here

00:08:58,560 --> 00:09:04,959
we get the plus operator

00:09:01,920 --> 00:09:08,320
that doesn't have this commutative

00:09:04,959 --> 00:09:12,000
property because if we swap

00:09:08,320 --> 00:09:14,800
the operands we get something different

00:09:12,000 --> 00:09:16,720
so this so python is somewhere in the

00:09:14,800 --> 00:09:20,839
middle of the spectrum

00:09:16,720 --> 00:09:23,760
where we pythonistas believe is

00:09:20,839 --> 00:09:26,000
reasonable strictness of

00:09:23,760 --> 00:09:27,040
of the language but of course the idea

00:09:26,000 --> 00:09:30,959
of reasonable

00:09:27,040 --> 00:09:33,839
is subjective then we have duck typing

00:09:30,959 --> 00:09:36,320
something we are very

00:09:33,839 --> 00:09:38,240
very proud of that we have this nice

00:09:36,320 --> 00:09:41,040
concept of duct typing

00:09:38,240 --> 00:09:43,920
so in duct typing protocols are

00:09:41,040 --> 00:09:46,320
implemented implicitly

00:09:43,920 --> 00:09:47,440
we need to implement the required

00:09:46,320 --> 00:09:49,760
methods and

00:09:47,440 --> 00:09:50,560
the object becomes compatible with a

00:09:49,760 --> 00:09:53,279
protocol

00:09:50,560 --> 00:09:53,920
we have this other way of typing where

00:09:53,279 --> 00:09:57,760
classes

00:09:53,920 --> 00:10:00,720
must inherit for another class or

00:09:57,760 --> 00:10:02,959
mark being marked as implementing the

00:10:00,720 --> 00:10:05,279
protocol

00:10:02,959 --> 00:10:06,640
how do we call this we could call this

00:10:05,279 --> 00:10:09,760
this

00:10:06,640 --> 00:10:13,519
actually my idea platonic because

00:10:09,760 --> 00:10:17,120
plata was this guy who had this uh

00:10:13,519 --> 00:10:19,360
concept of metaphysical ideas and

00:10:17,120 --> 00:10:21,519
he wouldn't agree with this proverb that

00:10:19,360 --> 00:10:22,079
if it looks like a dug and quacks like a

00:10:21,519 --> 00:10:25,279
duck

00:10:22,079 --> 00:10:25,839
it's a duck plateau would say that there

00:10:25,279 --> 00:10:28,959
exists

00:10:25,839 --> 00:10:32,079
an idea of a duck and when we see a duck

00:10:28,959 --> 00:10:35,839
we recognize it because our

00:10:32,079 --> 00:10:38,880
brains our minds somehow know this

00:10:35,839 --> 00:10:41,839
already this idea of a duck

00:10:38,880 --> 00:10:43,040
so it could be compared to classes or if

00:10:41,839 --> 00:10:46,240
we don't like this

00:10:43,040 --> 00:10:48,320
whimsical ideas we could say

00:10:46,240 --> 00:10:50,399
it's structural typing and nominal

00:10:48,320 --> 00:10:53,839
typing and these are the terms

00:10:50,399 --> 00:10:57,120
that are used in my pi uh

00:10:53,839 --> 00:11:00,320
documentation so they would probably be

00:10:57,120 --> 00:11:03,920
somehow a part of this pythonic

00:11:00,320 --> 00:11:04,399
lingual just a short regression because

00:11:03,920 --> 00:11:07,600
before

00:11:04,399 --> 00:11:09,600
i it was said the interfaces but it was

00:11:07,600 --> 00:11:13,279
crossed out and

00:11:09,600 --> 00:11:17,440
they said protocol there is this

00:11:13,279 --> 00:11:19,680
idea that we pythonistas tend to use

00:11:17,440 --> 00:11:20,560
a language that is a little different

00:11:19,680 --> 00:11:22,560
from

00:11:20,560 --> 00:11:24,000
programmers in other languages for

00:11:22,560 --> 00:11:26,800
example we say

00:11:24,000 --> 00:11:27,680
race where all the other languages say

00:11:26,800 --> 00:11:32,480
throw

00:11:27,680 --> 00:11:35,680
we call erase lists when others say list

00:11:32,480 --> 00:11:37,519
we say deck if others say it's a blatant

00:11:35,680 --> 00:11:38,399
abuse of exceptions we say stop by

00:11:37,519 --> 00:11:40,800
iteration

00:11:38,399 --> 00:11:42,160
and also the thing that in most

00:11:40,800 --> 00:11:45,440
languages is called

00:11:42,160 --> 00:11:47,600
interfaces we call it protocols this is

00:11:45,440 --> 00:11:49,519
a little problem when we want to

00:11:47,600 --> 00:11:50,160
communicate with others but we have to

00:11:49,519 --> 00:11:53,600
remember

00:11:50,160 --> 00:11:54,320
that this name protocol means the same

00:11:53,600 --> 00:11:58,160
that

00:11:54,320 --> 00:12:02,240
interface in java or in golang

00:11:58,160 --> 00:12:05,839
there is this misconception also about

00:12:02,240 --> 00:12:09,760
duct typing being some special

00:12:05,839 --> 00:12:11,360
type of dynamic typing it is not true

00:12:09,760 --> 00:12:14,399
static languages can be

00:12:11,360 --> 00:12:17,600
also that type and we can see

00:12:14,399 --> 00:12:20,880
an example here from golang we have

00:12:17,600 --> 00:12:24,639
this interface dac we have a struct

00:12:20,880 --> 00:12:28,000
called malar it implements

00:12:24,639 --> 00:12:29,120
these methods and we can use an instance

00:12:28,000 --> 00:12:32,160
of mallard

00:12:29,120 --> 00:12:33,519
as an argument for a function that

00:12:32,160 --> 00:12:36,880
requires a duck

00:12:33,519 --> 00:12:40,160
nowhere here we say explicitly a malar

00:12:36,880 --> 00:12:41,600
is a duck but our compiler understands

00:12:40,160 --> 00:12:44,959
it

00:12:41,600 --> 00:12:48,079
and there is also fifth criterion

00:12:44,959 --> 00:12:50,320
that we need to take into account it's

00:12:48,079 --> 00:12:53,040
free versus fixed attributes because we

00:12:50,320 --> 00:12:55,440
are working with the data structures

00:12:53,040 --> 00:12:57,360
and we also need to take this into

00:12:55,440 --> 00:13:01,360
account although it is not

00:12:57,360 --> 00:13:04,399
actually a paradigm of typing it's how

00:13:01,360 --> 00:13:05,600
objects work internally so if we look at

00:13:04,399 --> 00:13:08,639
our typical stack

00:13:05,600 --> 00:13:11,920
we see that the

00:13:08,639 --> 00:13:16,240
layers of the stack exhibit a different

00:13:11,920 --> 00:13:17,279
way of typing python and javascript are

00:13:16,240 --> 00:13:20,800
not that

00:13:17,279 --> 00:13:22,160
different here of course javascript is

00:13:20,800 --> 00:13:25,680
much looser than

00:13:22,160 --> 00:13:29,279
python which i showed before but for

00:13:25,680 --> 00:13:34,399
sql it is completely different

00:13:29,279 --> 00:13:34,720
we have loose typing we have static we

00:13:34,399 --> 00:13:36,399
have

00:13:34,720 --> 00:13:38,720
fixed attributes because we have of

00:13:36,399 --> 00:13:42,240
course the tables that have

00:13:38,720 --> 00:13:45,600
fixed the columns we don't have any idea

00:13:42,240 --> 00:13:48,959
of interfaces so if we

00:13:45,600 --> 00:13:51,120
communicate from python to sql we get

00:13:48,959 --> 00:13:54,000
this inherent incompatibility

00:13:51,120 --> 00:13:55,279
but this incompatibility was breached

00:13:54,000 --> 00:13:58,800
long time ago

00:13:55,279 --> 00:14:02,160
with various rns rrms are actually

00:13:58,800 --> 00:14:05,839
a little antitonic because they use

00:14:02,160 --> 00:14:08,959
fixed attributes something which was not

00:14:05,839 --> 00:14:13,040
another part of classic pythonic

00:14:08,959 --> 00:14:16,240
way of writing code they don't use

00:14:13,040 --> 00:14:19,199
any interfaces if you want to

00:14:16,240 --> 00:14:21,360
put something as a related object you

00:14:19,199 --> 00:14:24,240
have of course to put

00:14:21,360 --> 00:14:25,920
the right class you can't just implem

00:14:24,240 --> 00:14:30,720
pre-implement

00:14:25,920 --> 00:14:34,000
a model by implementing the same methods

00:14:30,720 --> 00:14:36,880
but this bridges the

00:14:34,000 --> 00:14:37,680
gap between python and between s between

00:14:36,880 --> 00:14:40,160
sql

00:14:37,680 --> 00:14:41,760
and it also fixes some problems we have

00:14:40,160 --> 00:14:45,040
with in sql

00:14:41,760 --> 00:14:46,480
if we look at this operation we can see

00:14:45,040 --> 00:14:49,760
why i

00:14:46,480 --> 00:14:51,600
declare sql a weekly type language here

00:14:49,760 --> 00:14:54,720
we are taking an

00:14:51,600 --> 00:14:55,199
id of a publisher and set it as an outer

00:14:54,720 --> 00:14:58,240
id

00:14:55,199 --> 00:15:01,920
of some book this

00:14:58,240 --> 00:15:03,040
operation is correct but it doesn't make

00:15:01,920 --> 00:15:06,240
any sense

00:15:03,040 --> 00:15:09,519
and the result of this operation is

00:15:06,240 --> 00:15:10,480
actually undefined because we don't know

00:15:09,519 --> 00:15:14,320
what would happen

00:15:10,480 --> 00:15:17,760
it depends if there happens to be

00:15:14,320 --> 00:15:18,800
an author in our database that has the

00:15:17,760 --> 00:15:22,079
same id

00:15:18,800 --> 00:15:22,880
as our publisher then it would we would

00:15:22,079 --> 00:15:24,959
get

00:15:22,880 --> 00:15:26,720
a value that doesn't make any sense if

00:15:24,959 --> 00:15:28,639
not we would get an error

00:15:26,720 --> 00:15:30,800
so this is something similar to what we

00:15:28,639 --> 00:15:32,800
get in c sometimes we get

00:15:30,800 --> 00:15:34,959
gibberish and sometimes we get a

00:15:32,800 --> 00:15:37,680
segmentation fault

00:15:34,959 --> 00:15:40,160
but we don't we can't really say in some

00:15:37,680 --> 00:15:41,920
situations what we would get this is

00:15:40,160 --> 00:15:45,920
actually bridged by

00:15:41,920 --> 00:15:49,440
rm because this operation would always

00:15:45,920 --> 00:15:52,160
uh raise a value error so rm

00:15:49,440 --> 00:15:53,360
would make sure we aren't doing

00:15:52,160 --> 00:15:55,759
something

00:15:53,360 --> 00:15:57,680
very stupid and this is one of the

00:15:55,759 --> 00:16:00,720
benefits of rm

00:15:57,680 --> 00:16:02,320
but this is something that we have for

00:16:00,720 --> 00:16:06,079
years now

00:16:02,320 --> 00:16:09,519
and how about annotations

00:16:06,079 --> 00:16:12,560
so let's enter my pi

00:16:09,519 --> 00:16:16,560
into our stack so my pi

00:16:12,560 --> 00:16:19,680
is a strange thing because it uses

00:16:16,560 --> 00:16:22,880
static analysis of a dynamic code

00:16:19,680 --> 00:16:26,079
and it is

00:16:22,880 --> 00:16:29,440
somehow disturbing for many people

00:16:26,079 --> 00:16:33,839
and some people say that it's antitonic

00:16:29,440 --> 00:16:37,759
although actually my bike can give us

00:16:33,839 --> 00:16:40,800
some uh some benefits

00:16:37,759 --> 00:16:41,680
so now let's let's look how django and

00:16:40,800 --> 00:16:45,040
maipai

00:16:41,680 --> 00:16:45,040
can work together

00:16:45,120 --> 00:16:48,480
how do they have

00:16:49,759 --> 00:16:56,959
do they work together correctly

00:16:53,279 --> 00:16:58,160
or are they lacking something so now let

00:16:56,959 --> 00:17:00,959
us

00:16:58,160 --> 00:17:00,959
look at

00:17:02,320 --> 00:17:06,640
some example models

00:17:06,650 --> 00:17:09,719
[Music]

00:17:11,280 --> 00:17:15,199
and here we have a book this book is

00:17:14,160 --> 00:17:18,799
linked to

00:17:15,199 --> 00:17:22,319
a publisher and to the author we allow

00:17:18,799 --> 00:17:23,520
uh outer to be null we don't allow

00:17:22,319 --> 00:17:26,559
publisher to be known

00:17:23,520 --> 00:17:30,840
because sometimes we cannot label a book

00:17:26,559 --> 00:17:35,520
with the author and if we now

00:17:30,840 --> 00:17:35,520
uh look at

00:17:38,160 --> 00:17:44,240
some functions these functions

00:17:41,200 --> 00:17:47,679
all almost all have some problems

00:17:44,240 --> 00:17:50,720
and if we run my pi

00:17:47,679 --> 00:17:53,120
on this code it would actually

00:17:50,720 --> 00:17:55,520
catch some of these problems it would

00:17:53,120 --> 00:17:59,120
catch that we are using

00:17:55,520 --> 00:18:03,919
incorrect type for our decimal field

00:17:59,120 --> 00:18:07,360
okay it would catch that we are using um

00:18:03,919 --> 00:18:09,679
publisher none but not that

00:18:07,360 --> 00:18:11,120
out of them okay it would also catch the

00:18:09,679 --> 00:18:14,320
thing that i was mentioning

00:18:11,120 --> 00:18:17,840
before when we are trying to put

00:18:14,320 --> 00:18:18,960
the value that is not pointed by this

00:18:17,840 --> 00:18:22,080
foreign key

00:18:18,960 --> 00:18:24,640
it's also okay however these two things

00:18:22,080 --> 00:18:25,840
are also not okay but they are not

00:18:24,640 --> 00:18:28,240
caught here

00:18:25,840 --> 00:18:29,520
we are creating a book that has only a

00:18:28,240 --> 00:18:32,480
price

00:18:29,520 --> 00:18:32,880
this would cause an error because we are

00:18:32,480 --> 00:18:36,000
setting

00:18:32,880 --> 00:18:38,640
null values where to normal

00:18:36,000 --> 00:18:40,080
columns and this actually could be fixed

00:18:38,640 --> 00:18:41,679
and maybe it would be fixed in the

00:18:40,080 --> 00:18:43,919
django stops in the future

00:18:41,679 --> 00:18:45,520
but here we have the same problem and

00:18:43,919 --> 00:18:48,960
this can be fixed

00:18:45,520 --> 00:18:49,280
because uh that's not how my pi works my

00:18:48,960 --> 00:18:52,640
pi

00:18:49,280 --> 00:18:54,320
is going line by line and in order to

00:18:52,640 --> 00:18:57,919
know that this is wrong

00:18:54,320 --> 00:19:01,600
we have to analyze the whole

00:18:57,919 --> 00:19:04,799
uh the whole code uh

00:19:01,600 --> 00:19:07,840
as a whole so it it wouldn't work

00:19:04,799 --> 00:19:10,400
anyway so what

00:19:07,840 --> 00:19:12,240
about my it already recognizes the

00:19:10,400 --> 00:19:15,200
relationship between

00:19:12,240 --> 00:19:16,080
column types and python types it

00:19:15,200 --> 00:19:19,039
recognizes the

00:19:16,080 --> 00:19:20,080
nullability of fields however it can't

00:19:19,039 --> 00:19:22,799
handle

00:19:20,080 --> 00:19:23,760
some problems when we make incomplete

00:19:22,799 --> 00:19:26,400
objects

00:19:23,760 --> 00:19:29,200
and it also requires a my pi plugin

00:19:26,400 --> 00:19:33,039
that's why it's not

00:19:29,200 --> 00:19:33,600
universal this would only work with my

00:19:33,039 --> 00:19:36,000
pi

00:19:33,600 --> 00:19:37,360
not with any tool that uses type

00:19:36,000 --> 00:19:40,320
annotations so

00:19:37,360 --> 00:19:43,280
this is also problematic okay now let's

00:19:40,320 --> 00:19:47,039
look at the other side of our stack

00:19:43,280 --> 00:19:49,760
at the communication between

00:19:47,039 --> 00:19:51,120
backend and frontend i said that

00:19:49,760 --> 00:19:54,799
javascript is not

00:19:51,120 --> 00:19:56,000
very different from python with regards

00:19:54,799 --> 00:19:58,640
to

00:19:56,000 --> 00:19:59,919
the typing paradigm however we also need

00:19:58,640 --> 00:20:03,360
to consider json

00:19:59,919 --> 00:20:06,559
and json has almost no typing it has

00:20:03,360 --> 00:20:07,360
only primitive types and no information

00:20:06,559 --> 00:20:10,480
about

00:20:07,360 --> 00:20:11,520
classes or something like this so in

00:20:10,480 --> 00:20:14,640
order to

00:20:11,520 --> 00:20:18,240
introduce some more type safety

00:20:14,640 --> 00:20:22,320
we need to add additional

00:20:18,240 --> 00:20:26,080
tools so we would use open api three

00:20:22,320 --> 00:20:27,679
and we would substitute javascript with

00:20:26,080 --> 00:20:29,280
typescript

00:20:27,679 --> 00:20:31,520
typescript is something that a

00:20:29,280 --> 00:20:34,000
javascript developer can

00:20:31,520 --> 00:20:35,200
learn in several hours because it's just

00:20:34,000 --> 00:20:38,240
javascript with

00:20:35,200 --> 00:20:40,000
type annotations just like type

00:20:38,240 --> 00:20:42,960
annotations in python can be also

00:20:40,000 --> 00:20:46,000
learned by a python dev

00:20:42,960 --> 00:20:49,520
so and open api 3

00:20:46,000 --> 00:20:51,760
is a system of schemas that can

00:20:49,520 --> 00:20:52,559
be used for tests and they can be also

00:20:51,760 --> 00:20:55,600
used for

00:20:52,559 --> 00:20:58,960
code generation so now let's look

00:20:55,600 --> 00:21:03,679
at the other part of of this

00:20:58,960 --> 00:21:07,440
so we created here a simple

00:21:03,679 --> 00:21:08,480
simple react component and this react

00:21:07,440 --> 00:21:11,760
component simply

00:21:08,480 --> 00:21:13,840
displays the data of a book however the

00:21:11,760 --> 00:21:15,679
fetching of the data is

00:21:13,840 --> 00:21:17,919
a little more complicated because it

00:21:15,679 --> 00:21:21,039
uses several

00:21:17,919 --> 00:21:24,400
api endpoints and combines this data

00:21:21,039 --> 00:21:27,200
and it has to handle the situation where

00:21:24,400 --> 00:21:28,799
the author of the book is null and not

00:21:27,200 --> 00:21:32,480
call it

00:21:28,799 --> 00:21:35,520
not call this endpoint without

00:21:32,480 --> 00:21:39,520
without the reason and if we

00:21:35,520 --> 00:21:42,559
now now run this

00:21:39,520 --> 00:21:44,960
we would see that it is working just

00:21:42,559 --> 00:21:48,400
like we just like we wanted

00:21:44,960 --> 00:21:50,960
it would uh call the

00:21:48,400 --> 00:21:52,159
back end and it would display all this

00:21:50,960 --> 00:21:55,840
data

00:21:52,159 --> 00:21:56,960
however what if we have an a developer

00:21:55,840 --> 00:21:59,360
that is

00:21:56,960 --> 00:22:01,360
careless what if we have a developer

00:21:59,360 --> 00:22:06,000
that gets this information

00:22:01,360 --> 00:22:10,159
you need to uh you need to

00:22:06,000 --> 00:22:13,280
allow for new publishers so this guy

00:22:10,159 --> 00:22:17,360
goes to the models

00:22:13,280 --> 00:22:20,640
and he does the simplest things

00:22:17,360 --> 00:22:24,840
on earth so he just allows it

00:22:20,640 --> 00:22:28,240
to be low

00:22:24,840 --> 00:22:31,280
and if we don't uh

00:22:28,240 --> 00:22:32,240
introduce any type safety mechanism then

00:22:31,280 --> 00:22:35,360
it would

00:22:32,240 --> 00:22:39,600
probably call because some bags

00:22:35,360 --> 00:22:43,200
that would happen in various places

00:22:39,600 --> 00:22:46,880
because not all our code can handle

00:22:43,200 --> 00:22:49,520
the null value however here we would

00:22:46,880 --> 00:22:50,559
have to do one more thing this would be

00:22:49,520 --> 00:22:54,720
done by this

00:22:50,559 --> 00:22:58,480
guy who does it or by ci and

00:22:54,720 --> 00:23:01,200
this would be two things uh

00:22:58,480 --> 00:23:01,200
first of all

00:23:01,919 --> 00:23:08,880
first of all it would be

00:23:05,840 --> 00:23:10,799
using this tool to generate a schema it

00:23:08,880 --> 00:23:13,200
is called spectacular there is a

00:23:10,799 --> 00:23:15,520
giant uh also schema generator in

00:23:13,200 --> 00:23:18,000
junglerist framework but it is not

00:23:15,520 --> 00:23:19,039
as good as spectacular and we would

00:23:18,000 --> 00:23:22,480
generate

00:23:19,039 --> 00:23:25,120
eskima game file

00:23:22,480 --> 00:23:25,600
then we would go to the front end this

00:23:25,120 --> 00:23:28,640
is

00:23:25,600 --> 00:23:32,720
all things that can be automated

00:23:28,640 --> 00:23:36,960
and we would generate some more files

00:23:32,720 --> 00:23:39,840
that would be typescript files and

00:23:36,960 --> 00:23:41,520
we can see that all the types are

00:23:39,840 --> 00:23:46,880
generated here

00:23:41,520 --> 00:23:46,880
and now if we if we try to

00:23:47,600 --> 00:23:54,559
to run our code we would see

00:23:51,360 --> 00:23:56,400
that during the compilation time doing

00:23:54,559 --> 00:23:57,679
compilation from typescript to

00:23:56,400 --> 00:24:00,960
javascript

00:23:57,679 --> 00:24:04,000
we already get an error

00:24:00,960 --> 00:24:08,000
because here

00:24:04,000 --> 00:24:10,880
typescript detects that the

00:24:08,000 --> 00:24:11,440
id of a book publisher needs to be a

00:24:10,880 --> 00:24:14,799
number

00:24:11,440 --> 00:24:15,840
but but book publisher can be undefined

00:24:14,799 --> 00:24:18,559
or known

00:24:15,840 --> 00:24:20,320
so we get what we wanted we get a

00:24:18,559 --> 00:24:23,919
situation where

00:24:20,320 --> 00:24:26,960
the ci detects our

00:24:23,919 --> 00:24:29,360
error and the developer can now see that

00:24:26,960 --> 00:24:32,400
he broke the contract and he needs to

00:24:29,360 --> 00:24:34,320
handle this new value so what are our

00:24:32,400 --> 00:24:37,039
takeaways from

00:24:34,320 --> 00:24:38,320
this demo there are tools for code

00:24:37,039 --> 00:24:40,880
safety enforcement

00:24:38,320 --> 00:24:42,640
that we can use in a whole python stack

00:24:40,880 --> 00:24:46,400
and they are worth consideration

00:24:42,640 --> 00:24:47,200
and they are and the benefits i believe

00:24:46,400 --> 00:24:50,880
from them

00:24:47,200 --> 00:24:51,520
for any big project outweighs the costs

00:24:50,880 --> 00:24:54,320
of

00:24:51,520 --> 00:24:55,760
introducing them however they are of

00:24:54,320 --> 00:24:59,600
course not perfect

00:24:55,760 --> 00:25:02,960
we can't expect them to catch all the

00:24:59,600 --> 00:25:03,840
typing errors and we probably do due to

00:25:02,960 --> 00:25:07,120
this

00:25:03,840 --> 00:25:07,840
inherently dynamic uh character of

00:25:07,120 --> 00:25:11,520
python

00:25:07,840 --> 00:25:14,880
we would probably never be able to

00:25:11,520 --> 00:25:17,760
to do this however we can do

00:25:14,880 --> 00:25:18,720
a lot with them what can we see in the

00:25:17,760 --> 00:25:22,240
future

00:25:18,720 --> 00:25:25,679
i believe that one thing we need to

00:25:22,240 --> 00:25:28,480
expect or maybe work on is

00:25:25,679 --> 00:25:28,880
more patterns in type annotations that

00:25:28,480 --> 00:25:32,880
are

00:25:28,880 --> 00:25:34,960
available without plugins so we can

00:25:32,880 --> 00:25:36,480
actually make type annotations that

00:25:34,960 --> 00:25:39,919
would work in every

00:25:36,480 --> 00:25:43,120
system not only in my pi and the other

00:25:39,919 --> 00:25:46,000
thing is tools that are based on code

00:25:43,120 --> 00:25:49,279
annotations not on the scriptures

00:25:46,000 --> 00:25:51,200
this is so they work like data classes

00:25:49,279 --> 00:25:52,480
there are two projects like this it's

00:25:51,200 --> 00:25:54,000
strawberry graphql

00:25:52,480 --> 00:25:56,559
we will have a spread of strawberry

00:25:54,000 --> 00:25:57,520
graphql on this conference and data

00:25:56,559 --> 00:26:00,159
class db

00:25:57,520 --> 00:26:01,120
and they also try all try to do the same

00:26:00,159 --> 00:26:05,600
thing that

00:26:01,120 --> 00:26:08,640
junglers frame or graphene or rm

00:26:05,600 --> 00:26:11,679
but in a different way so thank you

00:26:08,640 --> 00:26:14,960
i see that we don't have

00:26:11,679 --> 00:26:18,240
that much time left so i believe i would

00:26:14,960 --> 00:26:21,679
have to answer to any questions

00:26:18,240 --> 00:26:23,360
in the breakout room is it correct

00:26:21,679 --> 00:26:25,679
yeah that's correct thank you very much

00:26:23,360 --> 00:26:28,960
for your talk

00:26:25,679 --> 00:26:29,840
at the moment you're still in the brian

00:26:28,960 --> 00:26:31,919
track chat

00:26:29,840 --> 00:26:33,279
but anyone who has a question for you

00:26:31,919 --> 00:26:36,559
can then move to talk

00:26:33,279 --> 00:26:39,120
full stack type safety

00:26:36,559 --> 00:26:40,480
where you then can answer more

00:26:39,120 --> 00:26:43,360
complicated questions

00:26:40,480 --> 00:26:45,120
uh if everybo if anybody is not totally

00:26:43,360 --> 00:26:46,880
stumped by this by now

00:26:45,120 --> 00:26:49,360
uh thank you very much for taking the

00:26:46,880 --> 00:26:51,840
time to show us all this

00:26:49,360 --> 00:26:56,799
oops and that was not a proper loss so

00:26:51,840 --> 00:26:56,799

YouTube URL: https://www.youtube.com/watch?v=hAzg2iBe6cg


