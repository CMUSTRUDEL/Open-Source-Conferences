Title: Combining Embedded and Interactive Python in a Debugger:  A Case Study
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Caroline Tice - 23 June 2011 in "Track Ravioli"
Captions: 
	00:00:09,330 --> 00:00:14,849
hello so it is it am I talking to the

00:00:13,030 --> 00:00:19,420
microphone can you hear me in the back

00:00:14,849 --> 00:00:21,660
don't it is that better okay good so I'm

00:00:19,420 --> 00:00:23,740
a compiler in a debugger engineer and

00:00:21,660 --> 00:00:25,900
for the past couple of years I've been

00:00:23,740 --> 00:00:26,949
working on the ll DB debugger and I'm

00:00:25,900 --> 00:00:29,679
going to be talking about the

00:00:26,949 --> 00:00:32,169
experiences that we've had embedding

00:00:29,679 --> 00:00:34,090
Python in the interactive debugger so

00:00:32,169 --> 00:00:37,270
I'm going to start by talking a little

00:00:34,090 --> 00:00:39,010
bit about ll DB and about debuggers then

00:00:37,270 --> 00:00:40,719
I'm going to describe how we put Python

00:00:39,010 --> 00:00:42,430
in ll DB and I'm going to describe it

00:00:40,719 --> 00:00:44,949
both from the user experience and then

00:00:42,430 --> 00:00:46,390
some of the implementation details I'm

00:00:44,949 --> 00:00:47,890
going to go over some of the problems

00:00:46,390 --> 00:00:49,870
that we had trying to make this work and

00:00:47,890 --> 00:00:50,920
how we solve these problems then

00:00:49,870 --> 00:00:52,660
hopefully I'm going to have time to go

00:00:50,920 --> 00:00:54,010
over an example of actually using the

00:00:52,660 --> 00:00:56,320
Python scripting in the debugger to

00:00:54,010 --> 00:00:57,730
solve a real debugging problem and then

00:00:56,320 --> 00:01:00,699
finally hopefully we'll have time for a

00:00:57,730 --> 00:01:03,010
few questions I should probably mention

00:01:00,699 --> 00:01:05,140
a couple of things I tend to talk very

00:01:03,010 --> 00:01:07,150
quickly especially when I'm nervous so

00:01:05,140 --> 00:01:08,590
if I start talking way too fast you know

00:01:07,150 --> 00:01:11,799
raise your hands and I'll try to slow

00:01:08,590 --> 00:01:13,509
down and the other thing is it I'm as a

00:01:11,799 --> 00:01:15,520
complete Python newbie when I started I

00:01:13,509 --> 00:01:16,900
still feel like a Python newbie so there

00:01:15,520 --> 00:01:18,790
are probably better ways of doing what

00:01:16,900 --> 00:01:20,200
we've done and i'll be very happy to

00:01:18,790 --> 00:01:21,610
hear about that later on but if you're

00:01:20,200 --> 00:01:22,509
wondering why did we do it that way it's

00:01:21,610 --> 00:01:26,950
because i didn't know what i was doing

00:01:22,509 --> 00:01:31,450
when i started all right so um what is

00:01:26,950 --> 00:01:33,909
ll DD ll DB is part of the llvm project

00:01:31,450 --> 00:01:35,979
llvm is an open-source compiler and

00:01:33,909 --> 00:01:38,560
tools technology project it was started

00:01:35,979 --> 00:01:41,500
at the University of Illinois it's

00:01:38,560 --> 00:01:44,140
actually a a library of compiler tools

00:01:41,500 --> 00:01:46,180
and technologies so you can people link

00:01:44,140 --> 00:01:48,219
to it and they do a lot of research

00:01:46,180 --> 00:01:50,829
projects are using the LLVM compiler for

00:01:48,219 --> 00:01:52,240
doing a compiler research there's also a

00:01:50,829 --> 00:01:54,070
lot of corporate companies that are

00:01:52,240 --> 00:01:56,500
contributing source to the LLVM compiler

00:01:54,070 --> 00:01:59,590
project including Apple and Google and

00:01:56,500 --> 00:02:03,850
arm and a bunch of other companies ll DB

00:01:59,590 --> 00:02:05,500
is llvm s debugger so ll DB is actually

00:02:03,850 --> 00:02:07,630
more than just a debugger it's actually

00:02:05,500 --> 00:02:09,729
a debugger library so again it's

00:02:07,630 --> 00:02:11,410
something that you can link to and get

00:02:09,729 --> 00:02:13,030
various debuggers services out of

00:02:11,410 --> 00:02:15,420
including you know back-tracing in San

00:02:13,030 --> 00:02:19,170
Paulo keishon disassembly and stuff

00:02:15,420 --> 00:02:21,000
so some of the things that might try to

00:02:19,170 --> 00:02:22,830
use ll DB would include you know

00:02:21,000 --> 00:02:24,840
front-end debuggers so you know you can

00:02:22,830 --> 00:02:25,920
write a front-end and link to the ll DB

00:02:24,840 --> 00:02:28,440
library and get all of your debugger

00:02:25,920 --> 00:02:31,520
technology that you want you can also

00:02:28,440 --> 00:02:35,720
have automated testing tools or

00:02:31,520 --> 00:02:37,920
disassemblers execution analysis tools

00:02:35,720 --> 00:02:40,830
crash reporting for the back tracing and

00:02:37,920 --> 00:02:42,090
symbolic ation or on performance

00:02:40,830 --> 00:02:43,500
analysis tools so all of these different

00:02:42,090 --> 00:02:46,230
types of tools might be interested in

00:02:43,500 --> 00:02:48,180
linking to the llvm ll DB library and

00:02:46,230 --> 00:02:50,700
using the various services that we can

00:02:48,180 --> 00:02:52,560
provide in this talk I'm going to be

00:02:50,700 --> 00:02:53,910
describing the debugger front ends and

00:02:52,560 --> 00:02:56,640
in particular I'm going to be describing

00:02:53,910 --> 00:02:58,350
the ll DB command-line debugger and the

00:02:56,640 --> 00:03:02,280
ll d be gooey debugger which is part of

00:02:58,350 --> 00:03:04,080
an IDE so I'm going to start by going

00:03:02,280 --> 00:03:05,580
over a few bits of basic debugger

00:03:04,080 --> 00:03:07,410
terminology you may already know all of

00:03:05,580 --> 00:03:09,750
this but in case you don't just to go

00:03:07,410 --> 00:03:12,000
over it so when you have executable

00:03:09,750 --> 00:03:14,790
files on your disk on like hello world

00:03:12,000 --> 00:03:18,239
or Python exe these are what we refer to

00:03:14,790 --> 00:03:20,070
as targets when you go to execute your

00:03:18,239 --> 00:03:21,600
target you load it into memory and then

00:03:20,070 --> 00:03:24,239
the thing running in memory is called a

00:03:21,600 --> 00:03:26,310
process you execute your process in

00:03:24,239 --> 00:03:27,810
memory your process finishes executing

00:03:26,310 --> 00:03:29,640
its pulled out a memory you still have

00:03:27,810 --> 00:03:33,180
your targets on disk so targets and

00:03:29,640 --> 00:03:35,250
processes breakpoints are places where

00:03:33,180 --> 00:03:36,480
you can pause execution to examine the

00:03:35,250 --> 00:03:38,790
state of your program and try to figure

00:03:36,480 --> 00:03:40,590
out what's going on break points can be

00:03:38,790 --> 00:03:42,390
conditional so you can say I only want

00:03:40,590 --> 00:03:43,709
to stop at a particular breakpoint if a

00:03:42,390 --> 00:03:46,130
particular variable has a particular

00:03:43,709 --> 00:03:48,930
value or some other condition is true

00:03:46,130 --> 00:03:50,340
you can also attach code to break points

00:03:48,930 --> 00:03:55,079
and then have this code get executed

00:03:50,340 --> 00:03:56,730
each time the breakpoint is hit every

00:03:55,079 --> 00:03:58,440
time you call a function you have a

00:03:56,730 --> 00:04:00,720
frame that's associated with a function

00:03:58,440 --> 00:04:02,850
the frame contains parameters for the

00:04:00,720 --> 00:04:05,090
function its local variables and often

00:04:02,850 --> 00:04:07,230
the return address for the function

00:04:05,090 --> 00:04:09,060
processes and threads maintain call

00:04:07,230 --> 00:04:11,130
stacks of the currently i'm called

00:04:09,060 --> 00:04:12,750
functions when you call a function its

00:04:11,130 --> 00:04:14,549
frame gets pushed onto the stack when it

00:04:12,750 --> 00:04:16,200
finishes executing the frame gets popped

00:04:14,549 --> 00:04:18,450
off the stack so there's the end of

00:04:16,200 --> 00:04:22,049
debugger 101 your introduction to

00:04:18,450 --> 00:04:24,570
debuggers now about ll DB ll DB itself

00:04:22,049 --> 00:04:27,090
is written in C++ it's a multi-threaded

00:04:24,570 --> 00:04:28,600
program it's got an object-oriented

00:04:27,090 --> 00:04:30,820
design so the main

00:04:28,600 --> 00:04:33,400
the debugger are all objects and the

00:04:30,820 --> 00:04:35,650
objects are nested within each other ll

00:04:33,400 --> 00:04:36,730
DB is currently in its beta release so

00:04:35,650 --> 00:04:38,080
there are still a few bumps in the

00:04:36,730 --> 00:04:40,090
program but if you want to try it out

00:04:38,080 --> 00:04:41,440
you can as I think I said earlier it's

00:04:40,090 --> 00:04:44,430
an open source project you can download

00:04:41,440 --> 00:04:47,650
it build it contribute to it whatever

00:04:44,430 --> 00:04:49,620
the objects in lld be so the main top

00:04:47,650 --> 00:04:51,520
level object is the debugger object

00:04:49,620 --> 00:04:53,800
inside the debugger you can have a

00:04:51,520 --> 00:04:55,210
target you can even have multiple

00:04:53,800 --> 00:04:56,410
targets it's been designed to handle

00:04:55,210 --> 00:04:58,990
multiple targets within a single

00:04:56,410 --> 00:05:00,880
debugger within your target you can have

00:04:58,990 --> 00:05:04,030
a running process and your process can

00:05:00,880 --> 00:05:06,040
have one or more threads in it now

00:05:04,030 --> 00:05:07,810
within your debugger you also have your

00:05:06,040 --> 00:05:08,950
interpreters because you users have to

00:05:07,810 --> 00:05:10,510
be able to enter commands and you have

00:05:08,950 --> 00:05:12,700
to interpret the commands so you have

00:05:10,510 --> 00:05:13,990
your command interpreter that's the

00:05:12,700 --> 00:05:16,000
thing that handles your basic debugger

00:05:13,990 --> 00:05:17,020
commands like setting your file setting

00:05:16,000 --> 00:05:20,320
your breakpoints running your program

00:05:17,020 --> 00:05:22,110
you know whatever and in ll DD we also

00:05:20,320 --> 00:05:24,430
have embedded a script interpreter and

00:05:22,110 --> 00:05:25,630
this is where the Python comes in so the

00:05:24,430 --> 00:05:27,490
script interpreter then handles all the

00:05:25,630 --> 00:05:32,890
Python command Z the user might want to

00:05:27,490 --> 00:05:34,180
give the debugger so we also lld be in

00:05:32,890 --> 00:05:36,070
addition to having just a command line

00:05:34,180 --> 00:05:37,630
debugger there's a GUI debugger and this

00:05:36,070 --> 00:05:39,760
makes things a little bit more

00:05:37,630 --> 00:05:42,190
interesting because you have a single

00:05:39,760 --> 00:05:44,620
running GUI debugger process that may

00:05:42,190 --> 00:05:46,030
want to launch multiple targets it wants

00:05:44,620 --> 00:05:48,040
to launch each target in a separate

00:05:46,030 --> 00:05:49,480
window and it wants each target

00:05:48,040 --> 00:05:51,100
executing its separate window to have a

00:05:49,480 --> 00:05:53,410
separate debugger session but this is

00:05:51,100 --> 00:05:57,010
all running under one over overarching

00:05:53,410 --> 00:05:58,810
process therefore you have multiple

00:05:57,010 --> 00:06:00,340
simultaneous debuggers which want each

00:05:58,810 --> 00:06:01,240
one wants its own script interpreter so

00:06:00,340 --> 00:06:02,920
you really need to have multiple

00:06:01,240 --> 00:06:05,560
simultaneous script interpreters or

00:06:02,920 --> 00:06:07,000
something like that you need to have the

00:06:05,560 --> 00:06:08,500
ability to switch smoothly between the

00:06:07,000 --> 00:06:10,450
windows is the user clicks from one into

00:06:08,500 --> 00:06:11,980
to another and at the same time you need

00:06:10,450 --> 00:06:13,780
to maintain complete isolation between

00:06:11,980 --> 00:06:15,760
your various sessions so you have thread

00:06:13,780 --> 00:06:20,740
safety and no dead blocking and things

00:06:15,760 --> 00:06:22,780
work the way users expect them to so the

00:06:20,740 --> 00:06:24,720
debugger an LD be that it works roughly

00:06:22,780 --> 00:06:27,340
like this you have the lltv process in

00:06:24,720 --> 00:06:29,200
the big lldp process you have one

00:06:27,340 --> 00:06:31,420
running single embedded python

00:06:29,200 --> 00:06:33,850
interpreter and then you're going to

00:06:31,420 --> 00:06:34,900
have a debugger object with the command

00:06:33,850 --> 00:06:37,120
interpret and the script interpreter

00:06:34,900 --> 00:06:38,979
inside it but you can actually have

00:06:37,120 --> 00:06:39,910
multiple debuggers each with their own

00:06:38,979 --> 00:06:41,950
command interpreter and script

00:06:39,910 --> 00:06:42,310
interpreter but python is you're

00:06:41,950 --> 00:06:43,720
probably

00:06:42,310 --> 00:06:45,340
no doesn't really allow you to have

00:06:43,720 --> 00:06:48,040
multiple script interpreters in one

00:06:45,340 --> 00:06:49,480
process so we have to simulate that and

00:06:48,040 --> 00:06:51,070
we actually have on what I call

00:06:49,480 --> 00:06:52,690
interpreter sessions inside each

00:06:51,070 --> 00:06:54,490
debugger each session simulating being

00:06:52,690 --> 00:06:55,600
its own separate script interpreter and

00:06:54,490 --> 00:06:59,070
that's one of the things I'm going to

00:06:55,600 --> 00:06:59,070
explain a little bit later in this talk

00:06:59,280 --> 00:07:03,730
now the debugger so you've got your

00:07:01,510 --> 00:07:06,730
multiple debuggers and each one has its

00:07:03,730 --> 00:07:08,110
own interpreter session so the users can

00:07:06,730 --> 00:07:09,640
enter Python commands in their different

00:07:08,110 --> 00:07:11,050
interpreter sessions and they might you

00:07:09,640 --> 00:07:12,880
know define a variable and then say I

00:07:11,050 --> 00:07:14,590
want to look at the variable they could

00:07:12,880 --> 00:07:16,720
do that in multiple sessions at the same

00:07:14,590 --> 00:07:18,190
time and you really want to be careful

00:07:16,720 --> 00:07:19,900
that the values don't stomp on each

00:07:18,190 --> 00:07:22,060
other you know you want to make sure if

00:07:19,900 --> 00:07:23,080
you've set count to 24 in the left-hand

00:07:22,060 --> 00:07:24,550
window when you go to print it in the

00:07:23,080 --> 00:07:25,480
left-hand window you get 24 you don't

00:07:24,550 --> 00:07:27,550
want to get the value from the other

00:07:25,480 --> 00:07:29,890
window so we really have to maintain

00:07:27,550 --> 00:07:31,600
very strict separation between the

00:07:29,890 --> 00:07:33,430
Python definitions that are used in

00:07:31,600 --> 00:07:36,340
different interpreter sessions in this

00:07:33,430 --> 00:07:41,200
single process so that you the users get

00:07:36,340 --> 00:07:42,430
the behavior that they expect so at this

00:07:41,200 --> 00:07:44,800
point I'm going to show you a little bit

00:07:42,430 --> 00:07:46,030
of ll to be running to give you an idea

00:07:44,800 --> 00:07:49,930
of some of the stuff you can do with

00:07:46,030 --> 00:07:53,770
script and scripts in lld be if I can

00:07:49,930 --> 00:07:57,280
type so we have startup ll DB and all

00:07:53,770 --> 00:07:59,710
load hello world um this is a sea

00:07:57,280 --> 00:08:02,170
program show you running not very

00:07:59,710 --> 00:08:06,760
interesting I have another program it

00:08:02,170 --> 00:08:08,980
counts to ten again I can show it to you

00:08:06,760 --> 00:08:13,360
running not very interesting I can set a

00:08:08,980 --> 00:08:14,800
breakpoint um on the function that

00:08:13,360 --> 00:08:17,220
prints the numbers if I could actually

00:08:14,800 --> 00:08:17,220
type

00:08:19,800 --> 00:08:25,139
okay and then we run and it stops each

00:08:23,009 --> 00:08:26,550
time it goes to print a number now at

00:08:25,139 --> 00:08:28,560
this point I'm actually going to attach

00:08:26,550 --> 00:08:30,060
a Python breakpoint script command to

00:08:28,560 --> 00:08:34,860
this breakpoint so I'm going to say

00:08:30,060 --> 00:08:36,630
breakpoint command add script it's going

00:08:34,860 --> 00:08:38,820
to be a Python script and i'm going to

00:08:36,630 --> 00:08:40,560
add it the first break point and i'm

00:08:38,820 --> 00:08:42,959
going to actually start counting how

00:08:40,560 --> 00:08:44,790
many times we hit the break point so i'm

00:08:42,959 --> 00:08:47,070
going to use a variable break point

00:08:44,790 --> 00:08:51,779
count i'm going to increment it every

00:08:47,070 --> 00:08:53,790
time we hit the break point and then i'm

00:08:51,779 --> 00:08:57,959
going to print out what it is so hit

00:08:53,790 --> 00:09:09,240
this breakpoint again i can't type when

00:08:57,959 --> 00:09:12,779
I'm look nervous sorry whatever okay so

00:09:09,240 --> 00:09:20,310
and now we're done with our script great

00:09:12,779 --> 00:09:22,700
i mistyped it I appreciate your patience

00:09:20,310 --> 00:09:22,700
I'm sorry

00:09:27,800 --> 00:09:32,149
we'll just print the break point itself

00:09:35,449 --> 00:09:42,269
okay done okay now we're done now i can

00:09:39,600 --> 00:09:43,410
continue executing and all we didn't

00:09:42,269 --> 00:09:45,240
seem to print out the break point number

00:09:43,410 --> 00:09:47,759
well let's ask Python what break point

00:09:45,240 --> 00:09:49,769
count is and it tells us it doesn't know

00:09:47,759 --> 00:09:51,509
what it is oh let's initialize it and

00:09:49,769 --> 00:09:53,519
then maybe it'll know what it is so we

00:09:51,509 --> 00:09:56,970
can initialize it here directly from our

00:09:53,519 --> 00:10:00,990
command line prompt now we say what is

00:09:56,970 --> 00:10:02,579
break point count the script command is

00:10:00,990 --> 00:10:06,500
telling it we wanted to execute some

00:10:02,579 --> 00:10:08,759
Python then we continue executing and

00:10:06,500 --> 00:10:11,300
now if you look up at the lld be

00:10:08,759 --> 00:10:13,949
prompted actually printed out a 1 and

00:10:11,300 --> 00:10:17,459
the next time it printed out a 2 can you

00:10:13,949 --> 00:10:18,839
see that yeah okay and now I can say I

00:10:17,459 --> 00:10:20,970
want to drop into the script interpreter

00:10:18,839 --> 00:10:22,829
and I this is like having a Python at

00:10:20,970 --> 00:10:25,620
your unix punk'd but you're inside ll DB

00:10:22,829 --> 00:10:27,209
I can say print break point count it

00:10:25,620 --> 00:10:28,920
says it's three I can say that's not

00:10:27,209 --> 00:10:32,310
interesting let's change it so i'm going

00:10:28,920 --> 00:10:36,410
to say break point count equals you know

00:10:32,310 --> 00:10:39,420
28 get out of the script interpreter and

00:10:36,410 --> 00:10:43,139
continue executing and it's now about 29

00:10:39,420 --> 00:10:44,819
30 31 so we actually have Python

00:10:43,139 --> 00:10:49,589
accessible from all these different

00:10:44,819 --> 00:10:52,620
places inside lld be so that's a real

00:10:49,589 --> 00:10:58,980
fast demo of using it now I'm going to

00:10:52,620 --> 00:11:00,480
get back to the main talk so now i'm

00:10:58,980 --> 00:11:01,769
going to show you talk a little bit more

00:11:00,480 --> 00:11:04,380
about the implementation and the users

00:11:01,769 --> 00:11:06,209
of Python in lld be so the first

00:11:04,380 --> 00:11:07,620
question obviously is why did we want to

00:11:06,209 --> 00:11:10,350
have Python scripting in a debugger at

00:11:07,620 --> 00:11:11,819
all and one of the answers is that it

00:11:10,350 --> 00:11:13,529
can get you can start using it to set

00:11:11,819 --> 00:11:15,149
really useful conditional break points

00:11:13,529 --> 00:11:16,529
because the Python will allow you to get

00:11:15,149 --> 00:11:18,269
a hold of your debugger objects and then

00:11:16,529 --> 00:11:20,670
you can query information out of them so

00:11:18,269 --> 00:11:21,870
you can do things like say I want to set

00:11:20,670 --> 00:11:23,550
a breakpoint and then I only want to

00:11:21,870 --> 00:11:25,529
stop at that break point when it's

00:11:23,550 --> 00:11:27,120
called by a particular function so if

00:11:25,529 --> 00:11:28,199
you have a library routine that you want

00:11:27,120 --> 00:11:30,209
to set your break point in and it's

00:11:28,199 --> 00:11:31,319
called all over the place but you really

00:11:30,209 --> 00:11:32,879
only want to stop in that library

00:11:31,319 --> 00:11:34,439
function when it's called from you know

00:11:32,879 --> 00:11:36,329
a couple places in your code you can now

00:11:34,439 --> 00:11:38,790
say only stop here when the calling

00:11:36,329 --> 00:11:40,019
function has a particular name or when

00:11:38,790 --> 00:11:42,300
the calling functions argument

00:11:40,019 --> 00:11:44,189
have particular values if you're doing

00:11:42,300 --> 00:11:45,569
multi-threaded debugging you can also

00:11:44,189 --> 00:11:46,739
say I only want to stop with this

00:11:45,569 --> 00:11:48,749
breakpoint if it's being hit by a

00:11:46,739 --> 00:11:50,610
particular thread you can even record

00:11:48,749 --> 00:11:52,230
the thread ID in a Python variable and

00:11:50,610 --> 00:11:53,339
then say I only want to hit it stop at

00:11:52,230 --> 00:11:56,699
this breakpoint when it's being hit by

00:11:53,339 --> 00:11:57,749
the same thread that hit it last time in

00:11:56,699 --> 00:11:59,790
addition to setting conditional

00:11:57,749 --> 00:12:02,069
breakpoints using Python you can also

00:11:59,790 --> 00:12:04,319
use oops gotta head myself you can use

00:12:02,069 --> 00:12:06,299
Python to a help to verse your dynamic

00:12:04,319 --> 00:12:08,249
data structures so if you have I know a

00:12:06,299 --> 00:12:09,660
huge binary tree or a linked list or

00:12:08,249 --> 00:12:11,579
heap or something like that and there's

00:12:09,660 --> 00:12:12,869
you know thousands of nodes but there

00:12:11,579 --> 00:12:13,949
seems to be a problem in one of your

00:12:12,869 --> 00:12:15,809
data nodes and you're trying to find

00:12:13,949 --> 00:12:17,040
that node now you can write yourself a

00:12:15,809 --> 00:12:18,899
Python script that's going to traverse

00:12:17,040 --> 00:12:20,519
your data structure find the node it can

00:12:18,899 --> 00:12:21,959
report the path to the node it can

00:12:20,519 --> 00:12:23,639
record all kinds of information about

00:12:21,959 --> 00:12:26,189
your data structure and take you right

00:12:23,639 --> 00:12:28,769
to where the problem is you can also use

00:12:26,189 --> 00:12:30,149
Python to record and register record

00:12:28,769 --> 00:12:31,259
things like register values when you hit

00:12:30,149 --> 00:12:33,059
your breakpoints you can record your

00:12:31,259 --> 00:12:35,459
registry values and your local variables

00:12:33,059 --> 00:12:41,970
you can use the python file stuff to

00:12:35,459 --> 00:12:44,509
write it out to a file yes Oh does it oh

00:12:41,970 --> 00:12:47,220
yeah I'm curious about the support for

00:12:44,509 --> 00:12:50,069
programmatic things in the other Python

00:12:47,220 --> 00:12:52,499
debuggers mainly the Python PDB the

00:12:50,069 --> 00:12:55,019
original Python debugger and maybe any

00:12:52,499 --> 00:12:56,869
extended ones i haven't seen scripting

00:12:55,019 --> 00:12:59,699
before so I'm really interested in this

00:12:56,869 --> 00:13:00,929
honestly I don't know anything about the

00:12:59,699 --> 00:13:02,429
I Thunder buggers I said at the

00:13:00,929 --> 00:13:05,549
beginning of the talk i'm a real pipe on

00:13:02,429 --> 00:13:07,019
newbie I'm sorry but but so anyway you

00:13:05,549 --> 00:13:08,819
can you can record this information to a

00:13:07,019 --> 00:13:10,439
file you can do it each time the program

00:13:08,819 --> 00:13:12,240
point is run tip so you can start

00:13:10,439 --> 00:13:14,069
building up traces of information to

00:13:12,240 --> 00:13:15,089
help you with your debugger your

00:13:14,069 --> 00:13:16,350
debugging you can do this across

00:13:15,089 --> 00:13:17,790
multiple runs of the program you can

00:13:16,350 --> 00:13:20,459
stop execution go back and record it

00:13:17,790 --> 00:13:22,049
again and this brings up the fact that

00:13:20,459 --> 00:13:23,669
you can also use your Python scripts to

00:13:22,049 --> 00:13:25,410
help you do automated testing and QA

00:13:23,669 --> 00:13:27,240
with your programs if you have one of

00:13:25,410 --> 00:13:29,579
these nasty bugs that only shows up once

00:13:27,240 --> 00:13:30,869
in a while and it's not predictable you

00:13:29,579 --> 00:13:31,949
can write a Python script that will run

00:13:30,869 --> 00:13:33,569
your program over and over and over

00:13:31,949 --> 00:13:35,730
again until it actually hits the problem

00:13:33,569 --> 00:13:37,230
and it can collect data about your

00:13:35,730 --> 00:13:38,850
program every time it runs your programs

00:13:37,230 --> 00:13:40,169
you have all these logs and records you

00:13:38,850 --> 00:13:42,350
can compare when you actually find the

00:13:40,169 --> 00:13:44,339
problem to see what was going wrong and

00:13:42,350 --> 00:13:45,720
so these are just some of the reasons

00:13:44,339 --> 00:13:47,249
why we thought it would be really nice

00:13:45,720 --> 00:13:49,019
to be able to have scripting inside a

00:13:47,249 --> 00:13:50,490
regular debugger I mean there are lots

00:13:49,019 --> 00:13:53,290
more ways that could be used this is

00:13:50,490 --> 00:13:56,050
just the tip of the iceberg

00:13:53,290 --> 00:13:57,790
so talking a little bit about what we've

00:13:56,050 --> 00:13:59,380
actually got whereas you've all figured

00:13:57,790 --> 00:14:02,740
out already python is accessible from

00:13:59,380 --> 00:14:04,329
with inside the ll DB debugger and we've

00:14:02,740 --> 00:14:05,949
also made it so that you can access all

00:14:04,329 --> 00:14:07,750
of the LGBT bugger functionality

00:14:05,949 --> 00:14:13,600
directly from Python at the UNIX prompt

00:14:07,750 --> 00:14:15,519
if you want and so basically Python lld

00:14:13,600 --> 00:14:18,069
be when it's when it's compiled and

00:14:15,519 --> 00:14:20,230
built generates a python module so you

00:14:18,069 --> 00:14:21,790
can run Python at the UNIX prompt import

00:14:20,230 --> 00:14:23,139
your ll DB module and then you can start

00:14:21,790 --> 00:14:24,730
doing regular debugging stuff you can

00:14:23,139 --> 00:14:26,920
create a debugger you could create a

00:14:24,730 --> 00:14:28,389
target you can set breakpoints you can

00:14:26,920 --> 00:14:29,889
run your program you know you you're

00:14:28,389 --> 00:14:33,040
often running doing debugging stuff

00:14:29,889 --> 00:14:34,660
straight from the Python prompt so these

00:14:33,040 --> 00:14:37,360
functions that I've highlighted in red

00:14:34,660 --> 00:14:38,680
are all ll DB API functions they come

00:14:37,360 --> 00:14:39,699
with the API which I'm going to be

00:14:38,680 --> 00:14:42,279
talking a little bit more about

00:14:39,699 --> 00:14:43,600
throughout the talk if you want to see

00:14:42,279 --> 00:14:46,300
some good examples of how to do this

00:14:43,600 --> 00:14:47,769
kind of thing the ll DB regression test

00:14:46,300 --> 00:14:49,120
suite is actually written in this style

00:14:47,769 --> 00:14:50,380
with you know running Python straight

00:14:49,120 --> 00:14:52,389
from unix prompt and then importing the

00:14:50,380 --> 00:14:53,889
module and doing the tests so that's a

00:14:52,389 --> 00:14:57,850
great place to see examples of how to do

00:14:53,889 --> 00:14:59,290
this kind of thing now back to the main

00:14:57,850 --> 00:15:03,449
part of the talk which is actually going

00:14:59,290 --> 00:15:03,449
to be the Python inside the ll debugger

00:15:03,600 --> 00:15:08,079
ll DB contains a full and complete

00:15:05,769 --> 00:15:10,269
Python interpreter and it can be

00:15:08,079 --> 00:15:13,019
accessed from several different ways so

00:15:10,269 --> 00:15:15,010
there's the one line script command oh

00:15:13,019 --> 00:15:16,690
sorry there's the one line script

00:15:15,010 --> 00:15:18,069
command so if you have just a little bit

00:15:16,690 --> 00:15:20,560
of Python that you want to have executed

00:15:18,069 --> 00:15:21,910
but you want to stay in your main ll DB

00:15:20,560 --> 00:15:23,829
debugger context you don't want to leave

00:15:21,910 --> 00:15:25,149
the prompt you can just say Python go

00:15:23,829 --> 00:15:26,380
execute this little bit of code for me

00:15:25,149 --> 00:15:28,149
and it'll do it and bring you back the

00:15:26,380 --> 00:15:32,350
answer so you know here I've asked to

00:15:28,149 --> 00:15:33,699
convert decimal to hex you can also drop

00:15:32,350 --> 00:15:35,470
into the full interactive interpreter

00:15:33,699 --> 00:15:37,029
this is I'm just like typing Python at

00:15:35,470 --> 00:15:38,889
the UNIX prompt but it's already loaded

00:15:37,029 --> 00:15:40,839
the ll DB module for you so you've got

00:15:38,889 --> 00:15:42,220
all the API functions and we've done a

00:15:40,839 --> 00:15:44,139
little bit of extra set up to make your

00:15:42,220 --> 00:15:46,420
debugging tasks easier to accomplish and

00:15:44,139 --> 00:15:48,160
then you can also run Python from your

00:15:46,420 --> 00:15:49,569
break point commands as I showed you you

00:15:48,160 --> 00:15:53,500
can run Python in your break point

00:15:49,569 --> 00:15:55,600
commands as I showed you earlier so

00:15:53,500 --> 00:15:57,670
we've added some stuff to elevate it to

00:15:55,600 --> 00:15:59,230
make the Python really useful one of

00:15:57,670 --> 00:16:01,209
them is as I said at the beginning of

00:15:59,230 --> 00:16:03,670
the talk ll DB is really a debugger

00:16:01,209 --> 00:16:05,529
library so as a library it has a full

00:16:03,670 --> 00:16:07,000
and complete API that allows all the

00:16:05,529 --> 00:16:09,340
different tools that want to use it to

00:16:07,000 --> 00:16:11,020
call its functions create access

00:16:09,340 --> 00:16:13,840
manipulate debugger objects and state

00:16:11,020 --> 00:16:15,460
and the entire API is fully accessible

00:16:13,840 --> 00:16:18,760
and callable from Python that's in the

00:16:15,460 --> 00:16:21,460
Python ll DB module we've also

00:16:18,760 --> 00:16:23,590
pre-loaded several ll DB objects into

00:16:21,460 --> 00:16:25,720
Python variables for you so anytime you

00:16:23,590 --> 00:16:28,120
stop your execution and you want to get

00:16:25,720 --> 00:16:29,830
into Python your target your process

00:16:28,120 --> 00:16:31,360
your current target current process

00:16:29,830 --> 00:16:33,610
current thread and current frame are all

00:16:31,360 --> 00:16:35,350
in these blue Python variables for you

00:16:33,610 --> 00:16:36,910
so you've got these variables there

00:16:35,350 --> 00:16:38,320
there you can use them to start calling

00:16:36,910 --> 00:16:41,350
the API functions and doing your

00:16:38,320 --> 00:16:43,360
debugging tasks and finally as I

00:16:41,350 --> 00:16:45,490
actually demonstrated in the little demo

00:16:43,360 --> 00:16:47,080
that we gave we've set it up so you have

00:16:45,490 --> 00:16:48,760
a symbol persistent Python dictionary

00:16:47,080 --> 00:16:50,050
for your dictionary for your entire

00:16:48,760 --> 00:16:52,210
debugger session that's within the

00:16:50,050 --> 00:16:53,320
single debugger object so that you can

00:16:52,210 --> 00:16:55,060
get in and out of your interactive

00:16:53,320 --> 00:16:56,410
interpreter multiple times and things

00:16:55,060 --> 00:16:57,640
you define the first time you get into

00:16:56,410 --> 00:16:59,980
it are available the last time you get

00:16:57,640 --> 00:17:01,720
into it you can define a function in the

00:16:59,980 --> 00:17:03,880
interactive interpreter initialize it

00:17:01,720 --> 00:17:05,199
with a script command you know call it

00:17:03,880 --> 00:17:06,189
in your breakpoint command functions and

00:17:05,199 --> 00:17:07,990
they're all accessing the same

00:17:06,189 --> 00:17:12,910
persistent dictionary for your entire

00:17:07,990 --> 00:17:14,890
debugger session so there are two main

00:17:12,910 --> 00:17:16,780
parts of the implementation of Python

00:17:14,890 --> 00:17:18,550
and lld be one of them was just getting

00:17:16,780 --> 00:17:19,660
Python into it so we had the interactive

00:17:18,550 --> 00:17:21,130
interpreter and you could do the

00:17:19,660 --> 00:17:22,780
interpreter and the script commands and

00:17:21,130 --> 00:17:25,829
the breakpoint commands and then the

00:17:22,780 --> 00:17:27,970
other part was getting the API into the

00:17:25,829 --> 00:17:29,170
into a Python module so you could

00:17:27,970 --> 00:17:31,810
actually call it and do some useful

00:17:29,170 --> 00:17:33,310
debugging tasks so I'm going to talk a

00:17:31,810 --> 00:17:35,290
little bit about how we implemented the

00:17:33,310 --> 00:17:39,310
python interactive interpreter stuff in

00:17:35,290 --> 00:17:40,630
ll DD first so implementing the actual

00:17:39,310 --> 00:17:42,970
interactive interpreter with the prompts

00:17:40,630 --> 00:17:45,310
and everything we wrote our own

00:17:42,970 --> 00:17:47,710
interactive interpreter module in Python

00:17:45,310 --> 00:17:49,000
we inherited from the interactive

00:17:47,710 --> 00:17:53,170
console class which is in the code

00:17:49,000 --> 00:17:55,150
module this our interactive Python

00:17:53,170 --> 00:17:57,250
interpreter takes a dictionary as a

00:17:55,150 --> 00:17:59,020
parameter and then all the Python code

00:17:57,250 --> 00:18:00,460
that gets executed in the interactive

00:17:59,020 --> 00:18:02,650
interpreter and in the one-line script

00:18:00,460 --> 00:18:04,570
commands uses that dictionary as its

00:18:02,650 --> 00:18:08,140
main context so all the definitions go

00:18:04,570 --> 00:18:11,230
into it or looked up into it and then we

00:18:08,140 --> 00:18:13,120
use the python c api functions to in ll

00:18:11,230 --> 00:18:15,100
DB itself to initialize the Python

00:18:13,120 --> 00:18:16,900
interpreter to initialize threat some

00:18:15,100 --> 00:18:18,580
thread capabilities and we actually had

00:18:16,900 --> 00:18:20,620
to turn off Python signal handlers

00:18:18,580 --> 00:18:20,780
because by default Python installs it's

00:18:20,620 --> 00:18:22,550
a

00:18:20,780 --> 00:18:23,840
signal handlers which is good in many

00:18:22,550 --> 00:18:25,040
cases but if you're a debugger you

00:18:23,840 --> 00:18:26,150
actually need to handle the signals

00:18:25,040 --> 00:18:27,410
yourself you know you need to be you

00:18:26,150 --> 00:18:28,790
need to get the signal that says you've

00:18:27,410 --> 00:18:30,470
hit a breakpoint you need to get the

00:18:28,790 --> 00:18:32,930
signal that says the user wants to

00:18:30,470 --> 00:18:34,730
interrupt the the running process so we

00:18:32,930 --> 00:18:36,590
had to turn off Python signal handlers

00:18:34,730 --> 00:18:38,360
and then we import our own interactive

00:18:36,590 --> 00:18:40,250
interpreter module and then call the

00:18:38,360 --> 00:18:43,580
appropriate interactive interpreter

00:18:40,250 --> 00:18:44,990
function for handling the one line

00:18:43,580 --> 00:18:47,960
script command it's pretty much the same

00:18:44,990 --> 00:18:49,100
mechanism we use the same module we just

00:18:47,960 --> 00:18:50,810
have a different method in the module

00:18:49,100 --> 00:18:52,070
that we have to call and it's a simpler

00:18:50,810 --> 00:18:53,930
we don't have to do the looping we don't

00:18:52,070 --> 00:18:55,730
have to collect the input and if they

00:18:53,930 --> 00:18:59,050
give us an incomplete line we just tell

00:18:55,730 --> 00:18:59,050
them they've given us an incomplete line

00:18:59,200 --> 00:19:04,550
so a real quick overview of how the

00:19:02,630 --> 00:19:06,410
dictionary stuff works is when we create

00:19:04,550 --> 00:19:08,720
a new debugger we get a new debugger

00:19:06,410 --> 00:19:10,250
object the GNU debugger object creates

00:19:08,720 --> 00:19:12,260
new command interpreter which creates a

00:19:10,250 --> 00:19:14,420
new script interpreter session the

00:19:12,260 --> 00:19:15,770
script interpreter session automatically

00:19:14,420 --> 00:19:17,360
generates the name of the dictionary

00:19:15,770 --> 00:19:20,090
that's going to be used for that session

00:19:17,360 --> 00:19:21,590
in Python and then we tell the inter the

00:19:20,090 --> 00:19:22,820
Python interpreter to generate a new

00:19:21,590 --> 00:19:26,000
dictionary for us an empty dictionary

00:19:22,820 --> 00:19:28,160
and we put a you know in the the Python

00:19:26,000 --> 00:19:29,750
global dictionary we insert you know the

00:19:28,160 --> 00:19:31,160
dictionary name for our session and

00:19:29,750 --> 00:19:33,680
point it to the new dictionary that

00:19:31,160 --> 00:19:35,570
Python was created so that's how we get

00:19:33,680 --> 00:19:36,770
our dictionaries and then if we have

00:19:35,570 --> 00:19:38,300
multiple debuggers of course we're going

00:19:36,770 --> 00:19:43,340
to have multiple dictionaries one for

00:19:38,300 --> 00:19:44,720
each session so if we go to invoke a

00:19:43,340 --> 00:19:47,150
one-line script command then what

00:19:44,720 --> 00:19:48,770
happens is the first thing we do is we

00:19:47,150 --> 00:19:51,550
look up the right dictionary name in our

00:19:48,770 --> 00:19:53,870
session we find the dictionary in Python

00:19:51,550 --> 00:19:55,730
then we find the code for running our

00:19:53,870 --> 00:19:58,190
one line script interpreter that we've

00:19:55,730 --> 00:19:59,390
imported from our module and we get the

00:19:58,190 --> 00:20:04,310
input that the user said they wanted to

00:19:59,390 --> 00:20:06,500
use now we take this and we have to wrap

00:20:04,310 --> 00:20:08,060
the the input that the user gave us in

00:20:06,500 --> 00:20:10,520
our dictionary up into this argument

00:20:08,060 --> 00:20:13,640
tuple we use the embedded capi function

00:20:10,520 --> 00:20:15,560
calls to do this and then we on call yep

00:20:13,640 --> 00:20:17,330
I object call object another capi

00:20:15,560 --> 00:20:21,800
function to actually execute the code on

00:20:17,330 --> 00:20:23,150
the argument to poll if we're calling

00:20:21,800 --> 00:20:24,880
the interactive interpreter it's a

00:20:23,150 --> 00:20:27,410
similar idea but a little bit different

00:20:24,880 --> 00:20:29,810
again we look up the dictionary name

00:20:27,410 --> 00:20:32,570
first off and then we create a string

00:20:29,810 --> 00:20:34,700
that's going to call our our interactive

00:20:32,570 --> 00:20:36,920
interpreter type Python run into

00:20:34,700 --> 00:20:38,630
is the name of our method in our module

00:20:36,920 --> 00:20:40,040
that runs the interactive interpreter

00:20:38,630 --> 00:20:41,180
for us and we fill in the name of the

00:20:40,040 --> 00:20:44,900
dictionary that it's supposed to run

00:20:41,180 --> 00:20:47,630
with and then we call the capi function

00:20:44,900 --> 00:20:50,000
pi run simple string on this this string

00:20:47,630 --> 00:20:52,070
we've created and it executes our method

00:20:50,000 --> 00:20:53,420
call it using the right dictionary now

00:20:52,070 --> 00:20:55,490
he actually had to do a little bit more

00:20:53,420 --> 00:20:57,680
we had to do some io setup and some I'll

00:20:55,490 --> 00:20:59,750
clean up and the reason for this is that

00:20:57,680 --> 00:21:01,160
Python really really really really wants

00:20:59,750 --> 00:21:04,370
to use stood in and stood out for all of

00:21:01,160 --> 00:21:06,020
its I oh and when we're like using the

00:21:04,370 --> 00:21:07,100
graphical user interface we've got like

00:21:06,020 --> 00:21:08,510
three different windows with three

00:21:07,100 --> 00:21:10,610
different script interpreter sessions we

00:21:08,510 --> 00:21:12,200
want to be able to say this io goes to

00:21:10,610 --> 00:21:14,330
this window in this I August this window

00:21:12,200 --> 00:21:17,510
in this IO goes to this window so we

00:21:14,330 --> 00:21:19,340
actually had to redirect stood assisted

00:21:17,510 --> 00:21:21,410
and insisted out before we could call

00:21:19,340 --> 00:21:23,210
the interactive interpreter and we also

00:21:21,410 --> 00:21:25,310
then had to reset them after we called

00:21:23,210 --> 00:21:27,200
the interactive interpreter and we also

00:21:25,310 --> 00:21:28,820
do some funny stuff with the term iOS to

00:21:27,200 --> 00:21:33,890
deal with control D but that's another

00:21:28,820 --> 00:21:35,710
matter so then now breakpoint script

00:21:33,890 --> 00:21:38,000
commands work a little bit differently

00:21:35,710 --> 00:21:39,050
so i'll be talking about them for a

00:21:38,000 --> 00:21:41,390
little bit so when you go to add a

00:21:39,050 --> 00:21:43,550
breakpoint script command in lld be you

00:21:41,390 --> 00:21:46,430
know you prompt you for your Python you

00:21:43,550 --> 00:21:47,690
enter your Python script and you know

00:21:46,430 --> 00:21:50,360
looks like you've just entered normal

00:21:47,690 --> 00:21:51,980
Python behind the scenes ll DB is going

00:21:50,360 --> 00:21:53,840
to take what you wrote and wrap it up in

00:21:51,980 --> 00:21:55,160
a Python function and give it some

00:21:53,840 --> 00:21:57,400
obscure name so that hopefully the user

00:21:55,160 --> 00:22:00,350
won't accidentally recreate this name

00:21:57,400 --> 00:22:02,570
and we also pass in two more of these

00:22:00,350 --> 00:22:04,160
Python variables that we load with ll DB

00:22:02,570 --> 00:22:05,720
objects so in particular you're going to

00:22:04,160 --> 00:22:06,980
get the frame and the breakpoint

00:22:05,720 --> 00:22:10,180
location object for wherever the

00:22:06,980 --> 00:22:13,430
breakpoint was hit and then you you can

00:22:10,180 --> 00:22:15,920
when the breakpoint is hit Python sorry

00:22:13,430 --> 00:22:17,810
lld be loads those objects into Python

00:22:15,920 --> 00:22:19,910
variables and calls the Python function

00:22:17,810 --> 00:22:21,290
with them now this means there are two

00:22:19,910 --> 00:22:22,790
things you need to remember when you

00:22:21,290 --> 00:22:24,680
write a breakpoint script commanded in

00:22:22,790 --> 00:22:25,820
lld be one of them is that you actually

00:22:24,680 --> 00:22:27,200
are going to have the frame in the

00:22:25,820 --> 00:22:28,910
breakpoint location variables that you

00:22:27,200 --> 00:22:30,350
can use for calling api functions and

00:22:28,910 --> 00:22:32,840
doing stuff in your script if you want

00:22:30,350 --> 00:22:34,370
and the other one is it in your script

00:22:32,840 --> 00:22:36,230
command if you actually want to use any

00:22:34,370 --> 00:22:38,180
variable that was defined outside of the

00:22:36,230 --> 00:22:39,980
script you have to remember to tell

00:22:38,180 --> 00:22:41,270
python that its global otherwise pythons

00:22:39,980 --> 00:22:45,770
going to treat it as a local and you're

00:22:41,270 --> 00:22:47,270
going to get unexpected behavior now

00:22:45,770 --> 00:22:48,410
there are two stages to the breakpoint

00:22:47,270 --> 00:22:49,670
script commands there's a stage where

00:22:48,410 --> 00:22:51,320
create the command and then there's a

00:22:49,670 --> 00:22:52,460
stage where you execute the command so

00:22:51,320 --> 00:22:54,290
when you go to create the breakpoint

00:22:52,460 --> 00:22:56,720
script command first we collect the

00:22:54,290 --> 00:22:58,340
script text from the user then we have

00:22:56,720 --> 00:22:59,960
to prepend the function definition line

00:22:58,340 --> 00:23:03,500
and indent all the code an extra four

00:22:59,960 --> 00:23:05,060
spaces and then we put all this into a

00:23:03,500 --> 00:23:08,180
big long text string with new lines in

00:23:05,060 --> 00:23:09,980
the appropriate places and call the capi

00:23:08,180 --> 00:23:12,070
function to tell it to compile this

00:23:09,980 --> 00:23:14,390
string into a Python function for us

00:23:12,070 --> 00:23:15,980
once we've got the compile function we

00:23:14,390 --> 00:23:18,650
actually tell Python to evaluate it

00:23:15,980 --> 00:23:19,760
immediately and what this does is if the

00:23:18,650 --> 00:23:21,380
users given us a valid function

00:23:19,760 --> 00:23:22,700
definition then it stops the function

00:23:21,380 --> 00:23:24,980
definition straight into the global

00:23:22,700 --> 00:23:26,720
dictionary immediately for us and if

00:23:24,980 --> 00:23:28,220
it's not a valid function definition

00:23:26,720 --> 00:23:29,450
then we know immediately that the users

00:23:28,220 --> 00:23:31,280
done something wrong and we can go right

00:23:29,450 --> 00:23:32,960
back to you the user immediately and say

00:23:31,280 --> 00:23:35,720
you've given us a bad script we can't

00:23:32,960 --> 00:23:37,010
use this but if they've given us a good

00:23:35,720 --> 00:23:38,690
script then addition in addition to

00:23:37,010 --> 00:23:40,790
putting it in the dictionary we also

00:23:38,690 --> 00:23:44,660
create the call for the function and

00:23:40,790 --> 00:23:46,190
attach that to the breakpoint now when

00:23:44,660 --> 00:23:48,500
the breakpoint gets hit and you actually

00:23:46,190 --> 00:23:50,270
want to call the function again we have

00:23:48,500 --> 00:23:53,480
to look up the dictionary in the script

00:23:50,270 --> 00:23:55,580
session we find the dictionary in Python

00:23:53,480 --> 00:23:58,000
then we have to find the breakpoint

00:23:55,580 --> 00:24:03,290
function to call for the breakpoint and

00:23:58,000 --> 00:24:04,880
then see right then the next thing we

00:24:03,290 --> 00:24:06,440
have to do actually is we have to get

00:24:04,880 --> 00:24:07,910
our frame object an hour break point

00:24:06,440 --> 00:24:09,500
location object and stuff them into

00:24:07,910 --> 00:24:12,380
Python variables so that we can pass

00:24:09,500 --> 00:24:13,580
them to the function we create an

00:24:12,380 --> 00:24:15,170
argument tuple with the frame the

00:24:13,580 --> 00:24:18,560
breakpoint location and the dictionary

00:24:15,170 --> 00:24:19,760
and then again we call we use the capi

00:24:18,560 --> 00:24:25,190
function to call the code on the

00:24:19,760 --> 00:24:26,690
argument tuple so that's kind of how we

00:24:25,190 --> 00:24:28,100
implemented the interactive interpreter

00:24:26,690 --> 00:24:29,480
and the breakpoint command scripts in ll

00:24:28,100 --> 00:24:32,260
DB now I'm going to talk very quickly

00:24:29,480 --> 00:24:35,360
about how we made the lltv python module

00:24:32,260 --> 00:24:38,900
and it was really very very easy the

00:24:35,360 --> 00:24:40,220
one-word answer is we used swig so for

00:24:38,900 --> 00:24:41,600
those of you who don't know swig is a

00:24:40,220 --> 00:24:43,760
simplified wrapper in interphase

00:24:41,600 --> 00:24:46,370
generator it's an open source tool that

00:24:43,760 --> 00:24:48,050
parses C and C++ interfaces and it

00:24:46,370 --> 00:24:49,400
generates a glue code that allows Python

00:24:48,050 --> 00:24:53,090
and other scripting languages to call

00:24:49,400 --> 00:24:54,710
into the C and C++ code so we take our

00:24:53,090 --> 00:24:56,240
header files and our swig input file

00:24:54,710 --> 00:24:57,980
which tell us what header files to use

00:24:56,240 --> 00:25:00,470
in some type definitions and stuff we

00:24:57,980 --> 00:25:01,820
pass it to swig so it generates our C++

00:25:00,470 --> 00:25:05,630
file with all the wrapper

00:25:01,820 --> 00:25:07,850
glue code and it also generates a py

00:25:05,630 --> 00:25:10,670
file to actually call the the C++ stuff

00:25:07,850 --> 00:25:12,740
after we've compiled it we also take our

00:25:10,670 --> 00:25:14,420
ll DB sources and the C++ file that

00:25:12,740 --> 00:25:16,520
seats wig generated run it through the

00:25:14,420 --> 00:25:18,710
compiler and s gives us our lld be

00:25:16,520 --> 00:25:21,380
shared object and the shared object

00:25:18,710 --> 00:25:23,630
together with a py file is our module

00:25:21,380 --> 00:25:29,510
that we then can important to python to

00:25:23,630 --> 00:25:31,880
access lld be so that's pretty much how

00:25:29,510 --> 00:25:32,960
we implemented on Python in ll DB now

00:25:31,880 --> 00:25:34,430
I'm going to talk about some of the

00:25:32,960 --> 00:25:37,880
problems that we ran into and how we

00:25:34,430 --> 00:25:39,080
solved them so there were three main

00:25:37,880 --> 00:25:40,940
problems i'm going to talk about one of

00:25:39,080 --> 00:25:42,740
them was trying to pass pointers in c++

00:25:40,940 --> 00:25:46,040
objects back and forth between Python

00:25:42,740 --> 00:25:47,270
and end ll DB then how we maintained a

00:25:46,040 --> 00:25:49,250
single dictionary across the entire

00:25:47,270 --> 00:25:50,210
debugger session and finally how we

00:25:49,250 --> 00:25:51,920
dealt with the fact that we have

00:25:50,210 --> 00:25:53,390
multiple sessions with seemingly

00:25:51,920 --> 00:25:57,290
multiple script interpreters under a

00:25:53,390 --> 00:25:59,270
single embedded Python interpreter so

00:25:57,290 --> 00:26:03,560
passing pointers in C++ objects to

00:25:59,270 --> 00:26:05,450
python the api operates on debugger

00:26:03,560 --> 00:26:07,100
object so it operates on targets and

00:26:05,450 --> 00:26:09,650
processes and threads and frames and

00:26:07,100 --> 00:26:13,160
stuff and ll DB stores these things as

00:26:09,650 --> 00:26:15,470
objects C++ objects or pointers now

00:26:13,160 --> 00:26:17,000
embedded Python only really passes

00:26:15,470 --> 00:26:20,420
scalar data types back and forth between

00:26:17,000 --> 00:26:21,560
C++ programs and Python so we had a real

00:26:20,420 --> 00:26:23,630
problem trying to figure out how to get

00:26:21,560 --> 00:26:26,330
the ldb objects over into Python so that

00:26:23,630 --> 00:26:27,950
the API could call them so you know to

00:26:26,330 --> 00:26:30,380
illustrate the problem here we have a

00:26:27,950 --> 00:26:32,450
process object on the process class

00:26:30,380 --> 00:26:34,220
contains several methods including get

00:26:32,450 --> 00:26:35,570
num threads and we have our current

00:26:34,220 --> 00:26:37,850
processes running so there's a pointer

00:26:35,570 --> 00:26:39,170
to this process object and we're over in

00:26:37,850 --> 00:26:40,940
the script interpreter and we want to be

00:26:39,170 --> 00:26:43,820
able to call get num threads so what do

00:26:40,940 --> 00:26:45,740
we do well if you try calling get numb

00:26:43,820 --> 00:26:47,150
threads directly python says correctly

00:26:45,740 --> 00:26:48,590
that the name get num threads is not

00:26:47,150 --> 00:26:52,130
defined because it's not at the global

00:26:48,590 --> 00:26:53,600
level it's a class method so the next

00:26:52,130 --> 00:26:56,000
thing we might try doing is we say it

00:26:53,600 --> 00:26:57,950
well let's tell Python it's in the ll DB

00:26:56,000 --> 00:27:00,290
module it's in the SP process class and

00:26:57,950 --> 00:27:02,420
it's a gettin um threads method again

00:27:00,290 --> 00:27:04,010
Python complains and particular it says

00:27:02,420 --> 00:27:06,410
get num threads has to be called with

00:27:04,010 --> 00:27:09,740
the process instance you can't it's cute

00:27:06,410 --> 00:27:12,470
can't call it as an unbound method so

00:27:09,740 --> 00:27:15,920
that means we really have to figure out

00:27:12,470 --> 00:27:17,360
how to get a process object

00:27:15,920 --> 00:27:21,770
into a Python variable so that we can

00:27:17,360 --> 00:27:23,600
call this method that we want now Python

00:27:21,770 --> 00:27:26,060
the C API provides a couple of methods

00:27:23,600 --> 00:27:29,270
for converting stuff from types from C

00:27:26,060 --> 00:27:32,330
to python but basically it converts

00:27:29,270 --> 00:27:34,700
strings it converts integers it converts

00:27:32,330 --> 00:27:37,910
other numbers it converts these things

00:27:34,700 --> 00:27:39,290
called PI size and PI object but if you

00:27:37,910 --> 00:27:41,330
want to convert anything else the

00:27:39,290 --> 00:27:44,180
programmer has to write the conversion

00:27:41,330 --> 00:27:45,800
and this is very complicated you I've

00:27:44,180 --> 00:27:47,480
read the books on the types in the the

00:27:45,800 --> 00:27:50,210
the way you set it all up and it's got

00:27:47,480 --> 00:27:51,980
its very ugly and not something that as

00:27:50,210 --> 00:27:54,770
a newbie we really wanted to try it's

00:27:51,980 --> 00:27:56,000
very difficult very easy to make

00:27:54,770 --> 00:27:57,380
mistakes and we didn't want have to do

00:27:56,000 --> 00:27:59,150
this for all of the types that we have

00:27:57,380 --> 00:28:02,300
in lld because that's a vast number of

00:27:59,150 --> 00:28:04,130
types so we thought about this for a

00:28:02,300 --> 00:28:06,710
while and we thought we came up with a

00:28:04,130 --> 00:28:08,750
few key insights the first one is that

00:28:06,710 --> 00:28:10,790
integers are very easy to pass back and

00:28:08,750 --> 00:28:11,930
forth between C and Python there are

00:28:10,790 --> 00:28:14,360
lots of different ways you can pass the

00:28:11,930 --> 00:28:16,250
integers back and forth the second

00:28:14,360 --> 00:28:17,840
insight was that we have control over

00:28:16,250 --> 00:28:19,310
the API we can write whatever API

00:28:17,840 --> 00:28:21,290
functions we want and it's very easy

00:28:19,310 --> 00:28:23,030
once you have an object to get to

00:28:21,290 --> 00:28:24,230
another object so if we have a target we

00:28:23,030 --> 00:28:26,840
can get to a process if we have a

00:28:24,230 --> 00:28:28,490
process we can get to a frame so the

00:28:26,840 --> 00:28:30,620
real problem is we just have to manage

00:28:28,490 --> 00:28:32,210
somehow to get a single object across

00:28:30,620 --> 00:28:34,340
into Python and then we'll be off and

00:28:32,210 --> 00:28:36,770
running so we decided to use a

00:28:34,340 --> 00:28:39,950
combination of api api functions and

00:28:36,770 --> 00:28:41,840
integers to do just that so we decided

00:28:39,950 --> 00:28:43,190
the single object we were going to focus

00:28:41,840 --> 00:28:44,540
on getting over there was the debugger

00:28:43,190 --> 00:28:45,710
object because again that's kind of the

00:28:44,540 --> 00:28:48,560
top-level object and from there you

00:28:45,710 --> 00:28:50,330
really can get to everything and we're

00:28:48,560 --> 00:28:53,300
going to start out we decided to attach

00:28:50,330 --> 00:28:56,390
a unique ID unique integer to every

00:28:53,300 --> 00:28:57,680
debugger basically give it an ID then

00:28:56,390 --> 00:28:59,300
we're going to pass the appropriate

00:28:57,680 --> 00:29:01,130
debugger ID to python so whenever you

00:28:59,300 --> 00:29:03,110
want to get into python we're going to

00:29:01,130 --> 00:29:04,490
set up this ll DB debugger unique ID

00:29:03,110 --> 00:29:07,790
object with the idea of whatever

00:29:04,490 --> 00:29:10,310
debugger is trying to access python and

00:29:07,790 --> 00:29:12,290
then we're going to create a static api

00:29:10,310 --> 00:29:14,960
function and so we added a new method to

00:29:12,290 --> 00:29:17,720
our debugger class find debugger with ID

00:29:14,960 --> 00:29:20,000
and the important part is that this is

00:29:17,720 --> 00:29:21,680
static and because it's static you don't

00:29:20,000 --> 00:29:24,080
have to have an object to call it when

00:29:21,680 --> 00:29:26,750
you can just call it directly and so

00:29:24,080 --> 00:29:28,580
that's what we do so when you type

00:29:26,750 --> 00:29:29,639
script in LDV to get into the script

00:29:28,580 --> 00:29:31,709
interpreter the first

00:29:29,639 --> 00:29:33,959
that it does is it actually goes and

00:29:31,709 --> 00:29:36,889
finds the debugger ID and sets the

00:29:33,959 --> 00:29:38,639
debugger ID variable correctly for you

00:29:36,889 --> 00:29:41,309
then you drop into the script

00:29:38,639 --> 00:29:42,629
interpreter and then I put it into the

00:29:41,309 --> 00:29:45,779
shorter variable because I don't have

00:29:42,629 --> 00:29:48,589
enough room on my screen and then you

00:29:45,779 --> 00:29:50,669
can use the new find a bugger with ID

00:29:48,589 --> 00:29:52,499
function to actually get your debugger

00:29:50,669 --> 00:29:54,450
object and put it into a Python variable

00:29:52,499 --> 00:29:56,159
and now we're often running we have a

00:29:54,450 --> 00:29:57,599
debugger object from there we can get a

00:29:56,159 --> 00:29:59,940
target from the target we can get the

00:29:57,599 --> 00:30:02,489
process from the process we can call get

00:29:59,940 --> 00:30:08,039
num threads and it actually works so we

00:30:02,489 --> 00:30:10,499
have succeeded more or less so the next

00:30:08,039 --> 00:30:11,789
problem that we had to face was using a

00:30:10,499 --> 00:30:13,859
single dictionary across the entire

00:30:11,789 --> 00:30:15,419
debugger session and so there were two

00:30:13,859 --> 00:30:17,729
reasons why we really wanted to have

00:30:15,419 --> 00:30:19,289
this this dictionary for the entire

00:30:17,729 --> 00:30:20,879
debugger session one of them was the

00:30:19,289 --> 00:30:23,339
idea of having persistent and reusable

00:30:20,879 --> 00:30:25,859
definitions so that you could define

00:30:23,339 --> 00:30:27,059
something in one dropping into the

00:30:25,859 --> 00:30:28,320
interpreter session and then call it

00:30:27,059 --> 00:30:29,759
from the one-line script commands and

00:30:28,320 --> 00:30:30,690
have it you know callable from the break

00:30:29,759 --> 00:30:32,309
point commands and not have the

00:30:30,690 --> 00:30:34,469
definitions disappear between each of

00:30:32,309 --> 00:30:35,969
the pieces and the other idea again is

00:30:34,469 --> 00:30:37,769
as I said with the GUI we had to have

00:30:35,969 --> 00:30:38,849
multiple script interpreter sessions and

00:30:37,769 --> 00:30:40,589
so we really had to have a way of

00:30:38,849 --> 00:30:44,609
keeping independent and non-interfering

00:30:40,589 --> 00:30:46,049
definitions so again this is a reminder

00:30:44,609 --> 00:30:48,320
of the general setup and what it looks

00:30:46,049 --> 00:30:51,149
like you probably already remember this

00:30:48,320 --> 00:30:52,259
so with the interactive interpreter and

00:30:51,149 --> 00:30:54,709
the one line script commands it was

00:30:52,259 --> 00:30:56,579
pretty easy as i said we wrote our own

00:30:54,709 --> 00:30:58,469
interactive interpreter module that

00:30:56,579 --> 00:31:00,989
takes a dictionary as a parameter and so

00:30:58,469 --> 00:31:02,789
then all of the interactive stuff is

00:31:00,989 --> 00:31:04,649
executed in terms of this dictionary all

00:31:02,789 --> 00:31:06,570
the definitions and go into this session

00:31:04,649 --> 00:31:08,639
dictionary all the code is executed in

00:31:06,570 --> 00:31:10,469
context of the session dictionary and

00:31:08,639 --> 00:31:12,570
the dictionary because it lives in the

00:31:10,469 --> 00:31:14,369
Python global dictionary which persists

00:31:12,570 --> 00:31:15,929
across the entire debugger session all

00:31:14,369 --> 00:31:17,609
the definitions automatically also live

00:31:15,929 --> 00:31:18,779
across the entire debugger session no

00:31:17,609 --> 00:31:19,889
matter how many times you drop in and

00:31:18,779 --> 00:31:22,829
out of the interactive interpreter or

00:31:19,889 --> 00:31:24,299
the script interpreter or whatever now

00:31:22,829 --> 00:31:27,299
the breakpoint commands were a real

00:31:24,299 --> 00:31:28,889
problem and the reason for that is there

00:31:27,299 --> 00:31:30,839
was no encapsulating run environment we

00:31:28,889 --> 00:31:32,219
had no way of using the session

00:31:30,839 --> 00:31:34,409
dictionary as a global dictionary for

00:31:32,219 --> 00:31:36,539
the break point commands because we had

00:31:34,409 --> 00:31:37,919
to wrap up the the frame object in the

00:31:36,539 --> 00:31:41,969
breakpoint location object as parameters

00:31:37,919 --> 00:31:43,470
and pass them into the the break point

00:31:41,969 --> 00:31:44,490
command script function we

00:31:43,470 --> 00:31:46,860
really didn't have the option of using

00:31:44,490 --> 00:31:49,919
the interactive interpreter code to

00:31:46,860 --> 00:31:51,600
execute it so the breakpoint script

00:31:49,919 --> 00:31:53,850
functions actually are called from the

00:31:51,600 --> 00:31:55,289
global Python environment therefore what

00:31:53,850 --> 00:31:57,000
we actually did was we decided to modify

00:31:55,289 --> 00:31:59,370
the global environment carefully and

00:31:57,000 --> 00:32:00,630
this really works because of the way we

00:31:59,370 --> 00:32:02,429
set up the interactive interpreter and

00:32:00,630 --> 00:32:03,840
the script interpreter the user has no

00:32:02,429 --> 00:32:06,080
way of really directly putting

00:32:03,840 --> 00:32:09,419
definitions into the global environment

00:32:06,080 --> 00:32:12,030
so remember this if you enter this kind

00:32:09,419 --> 00:32:13,890
of script as your script command lldp

00:32:12,030 --> 00:32:15,299
will automatically create a Python

00:32:13,890 --> 00:32:17,340
definition for you with these parameters

00:32:15,299 --> 00:32:18,539
it actually throws in the third

00:32:17,340 --> 00:32:20,159
parameter which is the session

00:32:18,539 --> 00:32:21,630
dictionary for whichever debugger

00:32:20,159 --> 00:32:24,360
session is calling the breakpoint script

00:32:21,630 --> 00:32:26,010
command it also adds some code before

00:32:24,360 --> 00:32:27,270
the users code that does some dictionary

00:32:26,010 --> 00:32:29,549
set up magic that I'm going to talk

00:32:27,270 --> 00:32:31,350
about and it adds some code after the

00:32:29,549 --> 00:32:35,309
users code does some dictionary clean up

00:32:31,350 --> 00:32:37,350
magic so the dictionary set up magic

00:32:35,309 --> 00:32:39,659
works like this going into the users

00:32:37,350 --> 00:32:40,950
script we have our global dictionary

00:32:39,659 --> 00:32:43,200
with its values and we have our session

00:32:40,950 --> 00:32:44,940
dictionary with its values so we make

00:32:43,200 --> 00:32:46,200
two lists recording what the keys are in

00:32:44,940 --> 00:32:47,880
both of the dictionaries this means that

00:32:46,200 --> 00:32:49,080
before the users code executes we know

00:32:47,880 --> 00:32:53,280
what was supposed to be in each

00:32:49,080 --> 00:32:55,380
dictionary then we extend the global

00:32:53,280 --> 00:32:56,669
dictionary and we actually copy all the

00:32:55,380 --> 00:32:58,200
definitions from the de bug recession

00:32:56,669 --> 00:33:00,390
dictionary into the global dictionary

00:32:58,200 --> 00:33:01,799
and then at this point we're ready to

00:33:00,390 --> 00:33:03,210
execute the users break point script

00:33:01,799 --> 00:33:06,659
command in the context of the global

00:33:03,210 --> 00:33:08,880
dictionary after the users code executes

00:33:06,659 --> 00:33:11,520
we have to do our cleanup and the clean

00:33:08,880 --> 00:33:13,559
up goes roughly like this not

00:33:11,520 --> 00:33:16,230
surprisingly the first thing we do is we

00:33:13,559 --> 00:33:18,240
take all the the values for the users

00:33:16,230 --> 00:33:19,740
value users definitions and copy them

00:33:18,240 --> 00:33:21,090
back into the session dictionary so in

00:33:19,740 --> 00:33:23,370
this case a couple of things have

00:33:21,090 --> 00:33:24,870
changed and we move all the appropriate

00:33:23,370 --> 00:33:27,150
user definitions back into the debugger

00:33:24,870 --> 00:33:29,820
session dictionary we pull them out of

00:33:27,150 --> 00:33:31,140
the global dictionary then the keys

00:33:29,820 --> 00:33:32,669
themselves go away because those are

00:33:31,140 --> 00:33:35,130
actually local variables that we set up

00:33:32,669 --> 00:33:36,780
in the sprit point script command and so

00:33:35,130 --> 00:33:38,190
now we're happy we're done we've got all

00:33:36,780 --> 00:33:42,870
our dictionaries back the way out they

00:33:38,190 --> 00:33:44,880
ought to be the third problem that we

00:33:42,870 --> 00:33:46,230
had to solve was the fact that we had to

00:33:44,880 --> 00:33:47,549
simulate having multiple script

00:33:46,230 --> 00:33:49,020
interpreters well we really had one

00:33:47,549 --> 00:33:53,250
underlying script interpreter running in

00:33:49,020 --> 00:33:54,809
Python so again just as a reminder I

00:33:53,250 --> 00:33:56,340
went over this before the GUI needs to

00:33:54,809 --> 00:33:57,120
be able to launch multiple executables

00:33:56,340 --> 00:33:58,500
in separate window

00:33:57,120 --> 00:34:00,000
is each with its own de bugger session

00:33:58,500 --> 00:34:01,470
so you need to be able to simulate

00:34:00,000 --> 00:34:03,240
having multiple script interpreters with

00:34:01,470 --> 00:34:04,980
dictionaries switch between them and

00:34:03,240 --> 00:34:07,700
keep the isolation between them complete

00:34:04,980 --> 00:34:10,080
have thread safety and no dead blocking

00:34:07,700 --> 00:34:13,679
so one thing we looked at was using the

00:34:10,080 --> 00:34:15,659
capi function pi new interpreter but

00:34:13,679 --> 00:34:17,639
there were some problems with that the

00:34:15,659 --> 00:34:19,260
first one is that it doesn't fully load

00:34:17,639 --> 00:34:20,970
and initialize modules into all the new

00:34:19,260 --> 00:34:22,379
interpreters so this means we could load

00:34:20,970 --> 00:34:23,730
the ll DB module into the first

00:34:22,379 --> 00:34:25,260
interpreter and it would be fine but we

00:34:23,730 --> 00:34:26,669
load the LED module into the second

00:34:25,260 --> 00:34:28,470
interpreter it's not fully loaded it's

00:34:26,669 --> 00:34:31,220
not fully initialized it's not fully

00:34:28,470 --> 00:34:33,270
there and same for the rest of them

00:34:31,220 --> 00:34:35,280
according to the documentation some

00:34:33,270 --> 00:34:37,110
extensions may not work properly it does

00:34:35,280 --> 00:34:38,370
not fully isolate files and I oh so you

00:34:37,110 --> 00:34:39,990
might end up you know doing something in

00:34:38,370 --> 00:34:42,000
one window and having the solution show

00:34:39,990 --> 00:34:43,169
up in another window and finally they

00:34:42,000 --> 00:34:44,669
can insert objects into each other's

00:34:43,169 --> 00:34:46,350
name spaces so your dictionaries are not

00:34:44,669 --> 00:34:50,010
guaranteed to be isolated so this

00:34:46,350 --> 00:34:51,510
approach was rejected the next thing

00:34:50,010 --> 00:34:53,450
that we looked at was possibly relying

00:34:51,510 --> 00:34:56,669
on the Gil the global interpreter lock

00:34:53,450 --> 00:34:58,620
so the global interpreter lock you get

00:34:56,669 --> 00:35:00,570
some functions that ensure your state

00:34:58,620 --> 00:35:03,270
and allow you to set it and release it

00:35:00,570 --> 00:35:04,980
and deal with threads and it does

00:35:03,270 --> 00:35:07,320
serialize calls into the interpreter and

00:35:04,980 --> 00:35:09,390
prevent deadlock so that's good however

00:35:07,320 --> 00:35:11,100
it could release the lock too soon the

00:35:09,390 --> 00:35:12,000
Gil decides okay this thing's had the

00:35:11,100 --> 00:35:13,260
lock for a little bit of time I'm going

00:35:12,000 --> 00:35:15,690
to let it go and have something else

00:35:13,260 --> 00:35:17,580
have the lock so if the user was in the

00:35:15,690 --> 00:35:19,980
script interpreters in the interactive

00:35:17,580 --> 00:35:21,510
interpreter over in this window and this

00:35:19,980 --> 00:35:23,190
window hits a breakpoint script command

00:35:21,510 --> 00:35:24,420
the Gil might suddenly decide okay

00:35:23,190 --> 00:35:25,560
you've had the lock long enough I'm

00:35:24,420 --> 00:35:27,090
going to let you have the lock and the

00:35:25,560 --> 00:35:28,350
breakpoint script command can start

00:35:27,090 --> 00:35:30,780
executing all the users still doing

00:35:28,350 --> 00:35:32,610
stuff in there while the users trying to

00:35:30,780 --> 00:35:33,990
do stuff in there interactive

00:35:32,610 --> 00:35:36,840
interpreter session and it could lead to

00:35:33,990 --> 00:35:38,340
problems and again it does not guarantee

00:35:36,840 --> 00:35:40,260
non interference between the separate

00:35:38,340 --> 00:35:43,710
session dictionaries so the Gil seems to

00:35:40,260 --> 00:35:44,790
be insufficient for our purposes so we

00:35:43,710 --> 00:35:46,860
decided we were going to have to write

00:35:44,790 --> 00:35:48,780
our own a locking mechanism so we used

00:35:46,860 --> 00:35:51,600
basically a combination of mutexes and

00:35:48,780 --> 00:35:53,310
predicates every session has its own

00:35:51,600 --> 00:35:54,030
input and help pseudo terminals again

00:35:53,310 --> 00:35:55,230
because they have to write to the

00:35:54,030 --> 00:35:56,430
different windows they have their own

00:35:55,230 --> 00:35:57,600
session dictionary and they have a

00:35:56,430 --> 00:36:01,020
boolean indicating whether or not

00:35:57,600 --> 00:36:02,220
they're active when particular debugger

00:36:01,020 --> 00:36:05,130
thread indicates it wants to access

00:36:02,220 --> 00:36:07,620
Python then we first say does it have

00:36:05,130 --> 00:36:08,910
the Python lock if it does not have the

00:36:07,620 --> 00:36:10,640
Python lock we say well can you get the

00:36:08,910 --> 00:36:12,019
Python lock if you can

00:36:10,640 --> 00:36:14,359
the Python lock or you have the lock

00:36:12,019 --> 00:36:15,740
then we do our setup are on contact

00:36:14,359 --> 00:36:17,119
setups we set up the dictionary we set

00:36:15,740 --> 00:36:19,430
up the i/o we set up the convenience

00:36:17,119 --> 00:36:21,769
variables then we execute our Python and

00:36:19,430 --> 00:36:23,960
release the lock if we could not get the

00:36:21,769 --> 00:36:25,400
lock then we print the error message

00:36:23,960 --> 00:36:27,049
saying you can't do that right now

00:36:25,400 --> 00:36:28,549
because the interpreters locked in this

00:36:27,049 --> 00:36:31,099
window it's you're using in another

00:36:28,549 --> 00:36:32,660
window and then depending on what the

00:36:31,099 --> 00:36:33,950
he's just trying to do we either go back

00:36:32,660 --> 00:36:36,349
and try to get the lock again or we just

00:36:33,950 --> 00:36:39,010
return and leave it at that and again

00:36:36,349 --> 00:36:41,539
once you release the lock you return so

00:36:39,010 --> 00:36:43,250
this bit up here guarantees that we have

00:36:41,539 --> 00:36:45,019
thread safety and no deadlocking because

00:36:43,250 --> 00:36:47,750
we've got your one lock that you know

00:36:45,019 --> 00:36:49,849
only one thread at a time can get and

00:36:47,750 --> 00:36:51,019
this bit down here guarantees that we

00:36:49,849 --> 00:36:52,339
have the correct dictionary you know

00:36:51,019 --> 00:36:53,390
early release because once you get the

00:36:52,339 --> 00:36:54,710
lock you actually go through and finish

00:36:53,390 --> 00:36:57,769
executing whatever you were going to

00:36:54,710 --> 00:37:00,200
execute before you let go of the lock so

00:36:57,769 --> 00:37:01,430
how do we do well we have seemingly

00:37:00,200 --> 00:37:02,779
multiple script interpreters and

00:37:01,430 --> 00:37:04,400
dictionaries we have the ability to

00:37:02,779 --> 00:37:05,930
switch smoothly between them we have

00:37:04,400 --> 00:37:07,819
complete isolation between our sessions

00:37:05,930 --> 00:37:10,309
and our session dictionaries we have

00:37:07,819 --> 00:37:12,019
thread safety and no deadlocking we do

00:37:10,309 --> 00:37:13,309
not have true concurrency Python just

00:37:12,019 --> 00:37:15,019
does not allow that so we are still

00:37:13,309 --> 00:37:16,730
serializing accesses to the single

00:37:15,019 --> 00:37:18,170
underlying script interpreter and until

00:37:16,730 --> 00:37:19,660
somebody can convince Guido to change

00:37:18,170 --> 00:37:24,619
things that's why it's going to be

00:37:19,660 --> 00:37:26,599
unfortunately so that's basically the

00:37:24,619 --> 00:37:28,579
implementation of ll DB and the problems

00:37:26,599 --> 00:37:29,720
that we ran into now for the next part

00:37:28,579 --> 00:37:32,000
of the talk I'm actually going to show

00:37:29,720 --> 00:37:34,160
an example of using scripting in lgb to

00:37:32,000 --> 00:37:36,710
solve a real debugging problem or a kind

00:37:34,160 --> 00:37:39,019
of debugging problem so for this example

00:37:36,710 --> 00:37:40,670
we're going to have a sea program that

00:37:39,019 --> 00:37:42,259
reads in an input text file and stores

00:37:40,670 --> 00:37:44,299
all the words in a binary search tree

00:37:42,259 --> 00:37:46,720
and then the program can be asked is the

00:37:44,299 --> 00:37:49,190
word in the tree and it'll say yes or no

00:37:46,720 --> 00:37:50,329
now since this is about debugging talk

00:37:49,190 --> 00:37:51,500
obviously there's a bug in the program

00:37:50,329 --> 00:37:53,900
otherwise it wouldn't be very

00:37:51,500 --> 00:37:55,579
interesting so um we're reading in the

00:37:53,900 --> 00:37:56,930
play Romeo and Juliet and we're looking

00:37:55,579 --> 00:37:58,700
for various words that should be in the

00:37:56,930 --> 00:38:00,559
play and it's finding some of them but

00:37:58,700 --> 00:38:01,880
the word Romeo which I am dead sure is

00:38:00,559 --> 00:38:05,150
somewhere in that play is not being

00:38:01,880 --> 00:38:07,279
found so um there are several reasons

00:38:05,150 --> 00:38:08,599
why it might not be found one of them is

00:38:07,279 --> 00:38:10,099
that the word never got inserted into

00:38:08,599 --> 00:38:11,809
the dictionary another possible reason

00:38:10,099 --> 00:38:13,670
is that it got inserted but it's in the

00:38:11,809 --> 00:38:15,230
tree in some unexpected location so that

00:38:13,670 --> 00:38:17,299
the binary search algorithm just isn't

00:38:15,230 --> 00:38:19,009
finding it so the first thing we need to

00:38:17,299 --> 00:38:22,039
figure out is is the word in our tree or

00:38:19,009 --> 00:38:23,450
not well if it were a tiny tree we could

00:38:22,039 --> 00:38:24,950
look at all the nodes by hand and say

00:38:23,450 --> 00:38:26,570
and try to find the word but of course

00:38:24,950 --> 00:38:27,800
Romeo and Juliet has thousands and

00:38:26,570 --> 00:38:29,420
thousands of words the tree is going to

00:38:27,800 --> 00:38:31,580
be enormous trying to look for it by

00:38:29,420 --> 00:38:33,140
hand is just not practical luckily we

00:38:31,580 --> 00:38:34,310
can write a Python script to do this for

00:38:33,140 --> 00:38:36,950
us and that's exactly what we're going

00:38:34,310 --> 00:38:38,240
to do so the plan is we're going to

00:38:36,950 --> 00:38:39,950
write a recursive depth-first search

00:38:38,240 --> 00:38:41,360
function in Python we're going to stick

00:38:39,950 --> 00:38:42,680
it in this tree you Dalls file because

00:38:41,360 --> 00:38:44,330
you don't want to write long things at

00:38:42,680 --> 00:38:47,390
the interactive prompt or you make

00:38:44,330 --> 00:38:48,920
typing mistakes we're going to attach to

00:38:47,390 --> 00:38:50,840
our running program using the ll DB

00:38:48,920 --> 00:38:52,580
debugger then drop into our interactive

00:38:50,840 --> 00:38:54,680
interpreter and call the depth-first

00:38:52,580 --> 00:38:56,960
search function on our binary search

00:38:54,680 --> 00:38:58,310
tree the depth-first search function if

00:38:56,960 --> 00:39:00,230
it finds the word it's actually going to

00:38:58,310 --> 00:39:01,490
return a string representing the path

00:39:00,230 --> 00:39:05,390
from the root of the tree to the node

00:39:01,490 --> 00:39:06,770
where it found it so this is roughly

00:39:05,390 --> 00:39:09,590
what the depth-first search function

00:39:06,770 --> 00:39:11,330
looks like um it takes three parameters

00:39:09,590 --> 00:39:13,340
the first one is actually going to be

00:39:11,330 --> 00:39:15,050
our binary search tree or note in our

00:39:13,340 --> 00:39:17,030
tree because it's a recursive function

00:39:15,050 --> 00:39:18,590
on the second one is the word that we're

00:39:17,030 --> 00:39:19,880
searching for and the third one is a

00:39:18,590 --> 00:39:22,430
string representing the path from the

00:39:19,880 --> 00:39:24,290
root of the tree to our current node now

00:39:22,430 --> 00:39:26,660
these functions in red are all part of

00:39:24,290 --> 00:39:27,950
the lld bapi those are all functions so

00:39:26,660 --> 00:39:29,690
the first bit of code up there at the

00:39:27,950 --> 00:39:31,610
top is actually just getting the the

00:39:29,690 --> 00:39:34,760
fields out of the node and putting them

00:39:31,610 --> 00:39:35,810
into Python variables and then starting

00:39:34,760 --> 00:39:37,550
with you if statement that's the main

00:39:35,810 --> 00:39:38,990
body of the depth-first search function

00:39:37,550 --> 00:39:40,580
I assume you probably know depth-first

00:39:38,990 --> 00:39:42,110
search so you just say you know have we

00:39:40,580 --> 00:39:43,780
found the word no should we go left go

00:39:42,110 --> 00:39:49,700
left should we go right go right

00:39:43,780 --> 00:39:50,930
standard depth first search so seeing

00:39:49,700 --> 00:39:53,110
what it looks like actually when we use

00:39:50,930 --> 00:39:55,280
it we've attached to our running program

00:39:53,110 --> 00:39:57,440
we drop into our interactive script

00:39:55,280 --> 00:39:59,210
interpreter and we import the file that

00:39:57,440 --> 00:40:01,550
contains our depth first search function

00:39:59,210 --> 00:40:03,380
and now we have to take our binary

00:40:01,550 --> 00:40:04,760
search tree and put it into a Python

00:40:03,380 --> 00:40:07,040
variable so that we can pass it to the

00:40:04,760 --> 00:40:08,630
depth-first search function so here

00:40:07,040 --> 00:40:10,400
we're actually using one of those ll

00:40:08,630 --> 00:40:11,420
that one of those convenience variables

00:40:10,400 --> 00:40:13,280
that I talked about at the beginning of

00:40:11,420 --> 00:40:15,230
the talk remember I said that Python ll

00:40:13,280 --> 00:40:16,640
DB preloads certain Python variables

00:40:15,230 --> 00:40:17,930
with bits of your state that you're

00:40:16,640 --> 00:40:20,030
going to need the target in the process

00:40:17,930 --> 00:40:21,830
and the frame and the thread so we're

00:40:20,030 --> 00:40:23,480
going to use our frame we're going to

00:40:21,830 --> 00:40:25,010
ask the frame to find a variable using

00:40:23,480 --> 00:40:26,030
the API function and the variable we're

00:40:25,010 --> 00:40:27,170
going to look for is the one called

00:40:26,030 --> 00:40:29,180
dictionary because that's the name of

00:40:27,170 --> 00:40:30,800
our binary search tree so it's going to

00:40:29,180 --> 00:40:32,090
find the variable name dictionary in our

00:40:30,800 --> 00:40:35,240
current frame and it's going to put it

00:40:32,090 --> 00:40:36,820
into the Python variable named root then

00:40:35,240 --> 00:40:37,870
we initialize our current path to the mt

00:40:36,820 --> 00:40:39,850
string because we're starting at the

00:40:37,870 --> 00:40:41,530
root itself and we call a depth-first

00:40:39,850 --> 00:40:43,480
search function we're going to pass in

00:40:41,530 --> 00:40:45,700
the binary search tree the string Romeo

00:40:43,480 --> 00:40:47,980
and our current path string and if it

00:40:45,700 --> 00:40:50,530
finds the node it's going to return the

00:40:47,980 --> 00:40:53,680
string to the of the path to the node in

00:40:50,530 --> 00:40:55,210
the Python variable named pass so then

00:40:53,680 --> 00:40:57,250
we print path to see what it is and sure

00:40:55,210 --> 00:40:59,880
enough it found our node and the path to

00:40:57,250 --> 00:41:02,530
the node is left left right right left

00:40:59,880 --> 00:41:04,390
so we're halfway there we know that the

00:41:02,530 --> 00:41:05,890
note is in the tree we found it the next

00:41:04,390 --> 00:41:08,050
question is why didn't our search

00:41:05,890 --> 00:41:09,850
algorithm find it and how are we going

00:41:08,050 --> 00:41:11,020
to figure out where the problem is well

00:41:09,850 --> 00:41:13,840
the answer is we're going to use break

00:41:11,020 --> 00:41:16,060
point script commands so the idea goes

00:41:13,840 --> 00:41:17,680
like this we know this is where our word

00:41:16,060 --> 00:41:19,390
is and we know that a binary search

00:41:17,680 --> 00:41:20,650
algorithm has two decision points the

00:41:19,390 --> 00:41:22,540
point where it decides to go right and

00:41:20,650 --> 00:41:23,650
the point where it decides to go left so

00:41:22,540 --> 00:41:25,060
we're going to set breakpoints at each

00:41:23,650 --> 00:41:26,320
of these decision points and attach a

00:41:25,060 --> 00:41:28,390
break point script command to each

00:41:26,320 --> 00:41:29,920
decision point the breakpoint script

00:41:28,390 --> 00:41:31,360
command is going to compare the decision

00:41:29,920 --> 00:41:33,460
with what the past says it should do at

00:41:31,360 --> 00:41:34,990
that point as long as the decision

00:41:33,460 --> 00:41:36,850
agrees with a path we're just going to

00:41:34,990 --> 00:41:38,260
keep executing but as soon as the

00:41:36,850 --> 00:41:39,340
decision differs from what the path says

00:41:38,260 --> 00:41:40,870
we're going to should do we're going to

00:41:39,340 --> 00:41:44,620
stop executing and say we found our

00:41:40,870 --> 00:41:46,000
problem so this is what the breakpoint

00:41:44,620 --> 00:41:47,980
script command looks like at the

00:41:46,000 --> 00:41:50,170
decision to go right and again remember

00:41:47,980 --> 00:41:51,550
ll to be wraps it up in the function

00:41:50,170 --> 00:41:54,220
passes in the frame in the breakpoint

00:41:51,550 --> 00:41:55,690
location for you so we're going to use

00:41:54,220 --> 00:41:56,890
our global path variable that was

00:41:55,690 --> 00:41:58,570
returned by the depth-first search

00:41:56,890 --> 00:42:01,030
function so this tells us the path that

00:41:58,570 --> 00:42:02,890
we should be looking at we're going to

00:42:01,030 --> 00:42:04,960
compare the decision to go right with

00:42:02,890 --> 00:42:06,250
what the front of the path says if the

00:42:04,960 --> 00:42:07,360
path agrees with the decision then we're

00:42:06,250 --> 00:42:09,850
going to strip the first character off

00:42:07,360 --> 00:42:11,650
the path and resume execution we resume

00:42:09,850 --> 00:42:13,450
execution by first i'm using the frame

00:42:11,650 --> 00:42:14,650
variable that we know is there lldp

00:42:13,450 --> 00:42:16,540
gives us to us in our breakpoint

00:42:14,650 --> 00:42:18,010
commands we're going to use our API

00:42:16,540 --> 00:42:19,480
functions to get the thread and then get

00:42:18,010 --> 00:42:21,790
the process and then tell the process to

00:42:19,480 --> 00:42:23,710
continue execution so from the users

00:42:21,790 --> 00:42:25,390
point of view if the path agrees with

00:42:23,710 --> 00:42:27,850
the decision then we don't even see this

00:42:25,390 --> 00:42:30,280
breakpoint it just keeps executing but

00:42:27,850 --> 00:42:32,140
if the decision disagrees with the path

00:42:30,280 --> 00:42:33,370
then we're going to stay stopped at this

00:42:32,140 --> 00:42:34,690
breakpoint and we're going to print out

00:42:33,370 --> 00:42:37,810
an error message for the user saying we

00:42:34,690 --> 00:42:40,000
found the problem so looking at this in

00:42:37,810 --> 00:42:41,410
an execution we attach a breakpoint

00:42:40,000 --> 00:42:42,600
command at the decision to go right

00:42:41,410 --> 00:42:44,620
we've already seen what that looks like

00:42:42,600 --> 00:42:46,360
we attach to the breakpoint commanded

00:42:44,620 --> 00:42:47,440
the decision to left to go left it looks

00:42:46,360 --> 00:42:50,710
just like the one to go right except it

00:42:47,440 --> 00:42:52,330
says left and then we continue executing

00:42:50,710 --> 00:42:53,560
it executes for a little while and then

00:42:52,330 --> 00:42:54,820
it stops and prints out this error

00:42:53,560 --> 00:42:56,890
message so we actually seem to have

00:42:54,820 --> 00:42:59,109
found the problem so now let's look at

00:42:56,890 --> 00:43:01,050
the tree and see what we've got so at

00:42:59,109 --> 00:43:03,160
the current node the word is dramatis

00:43:01,050 --> 00:43:06,609
the word we're searching for is still

00:43:03,160 --> 00:43:09,250
Romeo that's good now the tree is sorted

00:43:06,609 --> 00:43:11,200
alphabetically and Romeo is greater than

00:43:09,250 --> 00:43:13,720
dramatis alphabetically so Romeo should

00:43:11,200 --> 00:43:15,099
be to the right of dramatis and it says

00:43:13,720 --> 00:43:17,290
we were trying to go right but the path

00:43:15,099 --> 00:43:18,369
says we should go left that seems a

00:43:17,290 --> 00:43:20,619
little bit odd so we're going to ask

00:43:18,369 --> 00:43:22,900
Python again prin us the pass from the

00:43:20,619 --> 00:43:25,660
current node to the word Romeo that you

00:43:22,900 --> 00:43:27,070
found it says the path is left left

00:43:25,660 --> 00:43:28,060
right right left and for those of you

00:43:27,070 --> 00:43:29,410
who are observant you will notice that

00:43:28,060 --> 00:43:31,300
this means we actually have a problem in

00:43:29,410 --> 00:43:34,990
the very first note of our tree because

00:43:31,300 --> 00:43:36,190
the path hasn't changed yet so we say ok

00:43:34,990 --> 00:43:38,080
let's find out what we actually have

00:43:36,190 --> 00:43:40,030
left left right right left from here and

00:43:38,080 --> 00:43:42,339
we look at that and it's the word Romeo

00:43:40,030 --> 00:43:44,170
but look at this we have an uppercase R

00:43:42,339 --> 00:43:45,760
versus a lowercase R our program

00:43:44,170 --> 00:43:49,660
contains a case conversion problem and

00:43:45,760 --> 00:43:51,099
that is the bug so basically that that's

00:43:49,660 --> 00:43:52,900
the end of my example of how you might

00:43:51,099 --> 00:43:54,430
use Python scripting to solve a real

00:43:52,900 --> 00:43:58,420
debugging problem if you're trying to

00:43:54,430 --> 00:43:59,980
find a problem in your program so in

00:43:58,420 --> 00:44:01,420
summary I've shown you hopefully that

00:43:59,980 --> 00:44:03,460
embedding Python into debugger gives

00:44:01,420 --> 00:44:04,599
users a great deal of power and I'm the

00:44:03,460 --> 00:44:06,010
ability to do a lot of really cool

00:44:04,599 --> 00:44:08,290
useful stuff that they couldn't do

00:44:06,010 --> 00:44:10,359
without a scripting on Python ability in

00:44:08,290 --> 00:44:12,190
their debugger I've showing you how we

00:44:10,359 --> 00:44:15,760
sold a couple problems including passing

00:44:12,190 --> 00:44:17,980
pointers and objects on 22 between C and

00:44:15,760 --> 00:44:19,359
C++ and Python and also how we managed

00:44:17,980 --> 00:44:20,710
to maintain the fiction of having

00:44:19,359 --> 00:44:21,760
multiple separate Python interpreters

00:44:20,710 --> 00:44:24,820
with really a single underlying

00:44:21,760 --> 00:44:27,010
interpreter running if you want more

00:44:24,820 --> 00:44:29,619
information that you can always go to

00:44:27,010 --> 00:44:31,150
the ll DB website there there's a full

00:44:29,619 --> 00:44:33,220
project description you can download the

00:44:31,150 --> 00:44:34,510
code and look at it if you want to look

00:44:33,220 --> 00:44:36,130
at the API you could look at the header

00:44:34,510 --> 00:44:38,980
files that's the best place to examine

00:44:36,130 --> 00:44:40,119
it there's also the scripting example

00:44:38,980 --> 00:44:42,070
that I went over at the end there's a

00:44:40,119 --> 00:44:43,690
link to the example on the web page with

00:44:42,070 --> 00:44:45,190
more explanations and descriptions if

00:44:43,690 --> 00:44:48,130
you want and there's a link to the

00:44:45,190 --> 00:44:49,960
developers mailing list so at this point

00:44:48,130 --> 00:44:54,030
I think I'm ready for questions and

00:44:49,960 --> 00:44:54,030
comments yes

00:45:02,820 --> 00:45:11,290
you did a lot of work to get pies in to

00:45:06,930 --> 00:45:13,480
fulfill your requirements so besides

00:45:11,290 --> 00:45:15,640
getting the nice food here and this nice

00:45:13,480 --> 00:45:17,590
conference why did you pick pies why did

00:45:15,640 --> 00:45:22,570
you not pick for example Java Script

00:45:17,590 --> 00:45:25,120
lure or tickle something that can do

00:45:22,570 --> 00:45:28,870
multiple interpreters a thread-safe

00:45:25,120 --> 00:45:30,460
nurse and was it sings well when we woke

00:45:28,870 --> 00:45:32,320
up a couple of reasons one of them is

00:45:30,460 --> 00:45:33,550
I'm when we first started we didn't

00:45:32,320 --> 00:45:34,660
realize that the multiple script

00:45:33,550 --> 00:45:36,730
interpreters was one of the requirements

00:45:34,660 --> 00:45:38,410
and so we were doing this thing in

00:45:36,730 --> 00:45:40,180
Python pythons an easy to use language

00:45:38,410 --> 00:45:41,620
easy to learn a lot of a lot of people

00:45:40,180 --> 00:45:42,790
use Python so we thought Python would be

00:45:41,620 --> 00:45:43,990
a good thing for a lot of programmers to

00:45:42,790 --> 00:45:45,850
be able to do their scripting in and

00:45:43,990 --> 00:45:47,110
then when we're told oh and by the way

00:45:45,850 --> 00:45:49,300
you've got to make it work with these

00:45:47,110 --> 00:45:51,160
multiple sessions we said lovely now

00:45:49,300 --> 00:45:52,960
what do we do so so that that that's

00:45:51,160 --> 00:46:03,040
kind of the show requirements gathering

00:45:52,960 --> 00:46:04,810
was not perfect yes and basically just a

00:46:03,040 --> 00:46:06,820
quick question about lld be can it be

00:46:04,810 --> 00:46:10,000
used easily to debug programs that

00:46:06,820 --> 00:46:12,970
haven't been compiled with llvm it

00:46:10,000 --> 00:46:15,430
should work on any any compiled program

00:46:12,970 --> 00:46:22,720
yeah well it needs to Worf debug

00:46:15,430 --> 00:46:25,230
information to work well but um any

00:46:22,720 --> 00:46:25,230
other questions

00:46:30,390 --> 00:46:36,329
um okay currently it runs best on Mac OS

00:46:33,960 --> 00:46:38,849
X I didn't say but most this development

00:46:36,329 --> 00:46:40,470
actually happened at Apple but it's also

00:46:38,849 --> 00:46:41,700
there there are some developers have

00:46:40,470 --> 00:46:43,289
been working on a port to linux and i

00:46:41,700 --> 00:46:45,809
believe the linux port is either fully

00:46:43,289 --> 00:46:47,700
functional or almost fully functional so

00:46:45,809 --> 00:46:48,960
it Linux and Mac OS X now and we'd like

00:46:47,700 --> 00:46:52,849
to get it onto windows and some others

00:46:48,960 --> 00:46:52,849
but that's what we've got at the moment

00:46:57,170 --> 00:47:04,950
okay so which languages can I compile

00:47:01,079 --> 00:47:07,289
with this compiler llvm mostly does see

00:47:04,950 --> 00:47:09,210
languages so it's see I'm a C C++

00:47:07,289 --> 00:47:12,740
objective-c an objective c plus plus at

00:47:09,210 --> 00:47:16,349
the moment okay and why should i use

00:47:12,740 --> 00:47:19,410
this compiler instead of GCC and be

00:47:16,349 --> 00:47:23,039
nettles toolchain ye ok a couple reasons

00:47:19,410 --> 00:47:25,079
llvm the LLVM compiler it actually it

00:47:23,039 --> 00:47:26,970
does a better job of optimizing than GCC

00:47:25,079 --> 00:47:28,799
it's a much more modern compiler so it's

00:47:26,970 --> 00:47:30,630
got a much better more coherent design

00:47:28,799 --> 00:47:32,309
it's got more advanced optimizations it

00:47:30,630 --> 00:47:34,260
runs more efficiently you know there are

00:47:32,309 --> 00:47:36,569
a lot of good reasons for using llvm and

00:47:34,260 --> 00:47:40,589
ll DB actually takes a lot of advantage

00:47:36,569 --> 00:47:42,690
of llvm so when you have both ll DB and

00:47:40,589 --> 00:47:44,970
llvm on your system for example ll DB

00:47:42,690 --> 00:47:47,279
uses the llvm parser to parse all the

00:47:44,970 --> 00:47:48,690
sea expressions in in the debugger so we

00:47:47,279 --> 00:47:51,119
didn't have we didn't try to write our

00:47:48,690 --> 00:47:54,059
own c and c++ parser and we didn't try

00:47:51,119 --> 00:47:58,410
to write our own um we actually use some

00:47:54,059 --> 00:48:00,480
of the abilities in llv LLVM compiler to

00:47:58,410 --> 00:48:02,039
do some stuff in lld be so you can we

00:48:00,480 --> 00:48:03,690
have some code there's there's i

00:48:02,039 --> 00:48:05,160
didn't show it to you but there's an

00:48:03,690 --> 00:48:07,829
expression command in here the way you

00:48:05,160 --> 00:48:09,509
can actually write a C or C++ expression

00:48:07,829 --> 00:48:11,309
have it um jittered and executed in your

00:48:09,509 --> 00:48:16,170
code so you can do all kinds of very

00:48:11,309 --> 00:48:18,180
useful stuff with that um so ok and for

00:48:16,170 --> 00:48:21,390
reach architectures can I use this

00:48:18,180 --> 00:48:23,670
compiler it's only for Intel CPU or can

00:48:21,390 --> 00:48:25,890
i use forearm or some other arm oh

00:48:23,670 --> 00:48:30,809
definitely works for forearm and intel

00:48:25,890 --> 00:48:32,819
and i'm not sure of all I'm less sure of

00:48:30,809 --> 00:48:34,289
the backends that the compiler works for

00:48:32,819 --> 00:48:35,970
I've been working largely on the

00:48:34,289 --> 00:48:37,550
debugger side but I believe it works on

00:48:35,970 --> 00:48:40,100
across a wide variety of

00:48:37,550 --> 00:48:43,160
ends um I go to the website and check

00:48:40,100 --> 00:48:45,530
I'm sorry but it works on an awful lot

00:48:43,160 --> 00:48:47,570
of back ends so LLL vm is been around a

00:48:45,530 --> 00:48:49,820
lot longer than ll DB and so it's a much

00:48:47,570 --> 00:48:51,740
more mature product as I said ll DB is

00:48:49,820 --> 00:49:02,120
still in the beta release version so

00:48:51,740 --> 00:49:04,580
okay thanks actually how much speed do I

00:49:02,120 --> 00:49:07,220
lose using the debugger and does the

00:49:04,580 --> 00:49:11,450
rely on the cpu extensions for debugging

00:49:07,220 --> 00:49:12,620
on each supported platform um I'm not

00:49:11,450 --> 00:49:16,610
sure I understand what you mean by

00:49:12,620 --> 00:49:18,380
losing speed compared to if I do it did

00:49:16,610 --> 00:49:20,500
not attach to the process how much

00:49:18,380 --> 00:49:24,290
slower that doesn't actually get when

00:49:20,500 --> 00:49:26,150
well checking for break you you can't

00:49:24,290 --> 00:49:27,140
really compare running the program in a

00:49:26,150 --> 00:49:28,580
debugger versus running the program

00:49:27,140 --> 00:49:30,620
without using the debugger because the

00:49:28,580 --> 00:49:34,210
debugger stops the program and so you've

00:49:30,620 --> 00:49:36,740
got it stopped so yes but but on a

00:49:34,210 --> 00:49:38,570
function where I actually have no break

00:49:36,740 --> 00:49:45,380
points um you shouldn't have any

00:49:38,570 --> 00:49:47,360
slowdown at all then okay does ll DB

00:49:45,380 --> 00:49:50,750
contain any support for debugging

00:49:47,360 --> 00:49:54,140
interpreted programs not at the moment

00:49:50,750 --> 00:49:56,450
unfortunately because it would be

00:49:54,140 --> 00:49:58,610
interesting if I could debug attached to

00:49:56,450 --> 00:50:00,650
running Python program and debug it

00:49:58,610 --> 00:50:02,420
using the sort of peevish things I

00:50:00,650 --> 00:50:03,920
completely agree but it's not there yet

00:50:02,420 --> 00:50:05,690
yeah if you want to write it you know

00:50:03,920 --> 00:50:08,290
it's open source please feel free I'd

00:50:05,690 --> 00:50:08,290
love to see it

00:50:20,470 --> 00:50:34,760
yeah anything else um no we weren't

00:50:33,020 --> 00:50:36,920
really aware of anything besides swig at

00:50:34,760 --> 00:50:38,240
the time and I repeat we were newbies

00:50:36,920 --> 00:50:40,300
and you know did what we could figure

00:50:38,240 --> 00:50:40,300
out

00:50:50,950 --> 00:50:58,490
you talked about having difficulties

00:50:53,750 --> 00:51:01,490
getting a Python usable object into the

00:50:58,490 --> 00:51:03,530
script yeah I was wondering why you

00:51:01,490 --> 00:51:04,910
didn't have the same trouble with values

00:51:03,530 --> 00:51:07,100
that were returned from api functions

00:51:04,910 --> 00:51:08,840
that you could then call um largely

00:51:07,100 --> 00:51:10,430
because the api functions went through

00:51:08,840 --> 00:51:11,720
swig so sweet took care of all the heavy

00:51:10,430 --> 00:51:13,970
lifting in terms of figuring out how to

00:51:11,720 --> 00:51:15,500
do the type conversions for us we just

00:51:13,970 --> 00:51:16,970
busted that split would convert it

00:51:15,500 --> 00:51:25,550
properly and it would end up in a Python

00:51:16,970 --> 00:51:27,260
variable for us okay or in just one more

00:51:25,550 --> 00:51:30,650
question did you compare this compiler

00:51:27,260 --> 00:51:32,780
to the interest compiler you know c

00:51:30,650 --> 00:51:36,530
compiler compiler and what is the

00:51:32,780 --> 00:51:38,240
difference of the speed um I'm sure the

00:51:36,530 --> 00:51:40,610
comparisons have been done and I don't

00:51:38,240 --> 00:51:42,020
know the answers I'm sorry okay again

00:51:40,610 --> 00:51:43,040
and if you really interested you can

00:51:42,020 --> 00:51:46,630
look it up on the web I'm sure it's

00:51:43,040 --> 00:51:46,630
there hey Owen okay

00:51:53,650 --> 00:52:02,309

YouTube URL: https://www.youtube.com/watch?v=a6oHHGIV3r4


