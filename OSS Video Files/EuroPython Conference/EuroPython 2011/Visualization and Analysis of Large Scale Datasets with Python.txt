Title: Visualization and Analysis of Large Scale Datasets with Python
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Christine Moran - 23 June 2011 in "Training Pizza Margherita
"
Captions: 
	00:00:06,109 --> 00:00:13,589
okay hi can everyone hear me in here

00:00:10,460 --> 00:00:16,170
Thanks and if I speak too fast or too

00:00:13,589 --> 00:00:18,000
slow you can tell me either way I just

00:00:16,170 --> 00:00:20,730
raise your hands or please interrupt

00:00:18,000 --> 00:00:24,870
with questions so what I'm going to

00:00:20,730 --> 00:00:28,020
introduce you guys today is parallel

00:00:24,870 --> 00:00:30,120
visualization with Python and mainly

00:00:28,020 --> 00:00:34,589
concentrating about what we're going to

00:00:30,120 --> 00:00:36,000
go over tomorrow in the workshop so I'm

00:00:34,589 --> 00:00:38,570
going to go through what is

00:00:36,000 --> 00:00:41,640
visualization that's an easy one sort of

00:00:38,570 --> 00:00:44,190
why should we bother with doing parallel

00:00:41,640 --> 00:00:47,219
visualization and why Python in

00:00:44,190 --> 00:00:49,260
particular the last one should also be

00:00:47,219 --> 00:00:53,429
easy we're all at euro Python of course

00:00:49,260 --> 00:00:56,460
Python yes and then I'll go over kind of

00:00:53,429 --> 00:01:00,149
with pretty pictures what we're going to

00:00:56,460 --> 00:01:04,800
be doing tomorrow afternoon so first of

00:01:00,149 --> 00:01:07,530
all why visualize information at all so

00:01:04,800 --> 00:01:10,860
if you have a set of numbers maybe in a

00:01:07,530 --> 00:01:13,290
spreadsheet in a binary file by

00:01:10,860 --> 00:01:16,860
visualizing it you can gain some insight

00:01:13,290 --> 00:01:20,820
into patterns in your data you can more

00:01:16,860 --> 00:01:24,720
easily communicate to a scientific

00:01:20,820 --> 00:01:27,060
colleague a co-worker or customer what

00:01:24,720 --> 00:01:28,890
does this data actually mean you can

00:01:27,060 --> 00:01:31,740
easily compare your results either to

00:01:28,890 --> 00:01:34,530
your expectations and debugging or to

00:01:31,740 --> 00:01:37,130
what someone else a co-worker or

00:01:34,530 --> 00:01:39,600
colleague got out of a particular

00:01:37,130 --> 00:01:42,150
computation and you can gain some

00:01:39,600 --> 00:01:45,200
appreciation so here are two beautiful

00:01:42,150 --> 00:01:47,550
visualisations ones of shipping patterns

00:01:45,200 --> 00:01:49,950
around the world and the other is a

00:01:47,550 --> 00:01:53,450
magnetic field and you can see that not

00:01:49,950 --> 00:01:55,980
only do these help us gain insight and

00:01:53,450 --> 00:01:57,480
communicate kind of what the the base

00:01:55,980 --> 00:02:01,860
numbers of the data are up to they're

00:01:57,480 --> 00:02:04,470
also very beautiful so now why parallel

00:02:01,860 --> 00:02:08,869
so desktop machines these days have many

00:02:04,470 --> 00:02:13,900
cores 2 4 6 12 hopefully more and more

00:02:08,869 --> 00:02:17,019
and by fully using these cores

00:02:13,900 --> 00:02:19,090
you can gain speed up if you're doing

00:02:17,019 --> 00:02:21,010
visualization moreover data sets

00:02:19,090 --> 00:02:23,879
nowadays or getting bigger and bigger

00:02:21,010 --> 00:02:26,349
and people are tackling the problem of

00:02:23,879 --> 00:02:28,209
visualizing and analyzing data sets that

00:02:26,349 --> 00:02:31,079
are too big to fit in memory on your

00:02:28,209 --> 00:02:35,590
local machine so two examples here are

00:02:31,079 --> 00:02:37,420
engrams which are strings of words where

00:02:35,590 --> 00:02:39,549
n is the number of words and the string

00:02:37,420 --> 00:02:41,799
and Google releases a freely available

00:02:39,549 --> 00:02:45,519
data set that's used by a lot of people

00:02:41,799 --> 00:02:48,459
natural language processing denoting the

00:02:45,519 --> 00:02:50,950
frequency of a given Engram and say the

00:02:48,459 --> 00:02:55,450
English language so how often does the

00:02:50,950 --> 00:03:01,030
word dog or dogs suck that string occur

00:02:55,450 --> 00:03:03,760
in English I'm a cat lover or that that

00:03:01,030 --> 00:03:06,579
dataset is 2.2 terabytes of data so

00:03:03,760 --> 00:03:11,019
that's not going to fit in my macbook's

00:03:06,579 --> 00:03:14,260
RAM maybe next year oh and Wikipedia

00:03:11,019 --> 00:03:16,420
traffic stats or 150 gigabytes so if we

00:03:14,260 --> 00:03:19,810
really want to be able to interact with

00:03:16,420 --> 00:03:21,879
our data and like I said that that helps

00:03:19,810 --> 00:03:24,280
us to discover new patterns in our data

00:03:21,879 --> 00:03:27,819
and then we can act on those patterns to

00:03:24,280 --> 00:03:31,120
either debug our code make our code run

00:03:27,819 --> 00:03:34,329
faster investigate a certain phenomenon

00:03:31,120 --> 00:03:36,370
in more detail then we have to fully

00:03:34,329 --> 00:03:40,510
utilize our computational resources so

00:03:36,370 --> 00:03:43,229
use those many cores and fully analyze

00:03:40,510 --> 00:03:46,629
the full data set by using many machines

00:03:43,229 --> 00:03:51,069
so now why pair of you pair of you is

00:03:46,629 --> 00:03:54,609
first of all open source it's written in

00:03:51,069 --> 00:03:56,139
C C++ under a BSD license it's very well

00:03:54,609 --> 00:03:58,780
maintained it has a large development

00:03:56,139 --> 00:04:01,060
community behind it and basically it's a

00:03:58,780 --> 00:04:03,040
set of rappers over the visualization

00:04:01,060 --> 00:04:05,919
tool kit which handles a lot of the

00:04:03,040 --> 00:04:10,060
nitty-gritty elements of visualization

00:04:05,919 --> 00:04:11,949
for you with a QT GUI we just learned a

00:04:10,060 --> 00:04:14,139
little bit about pie cutie in the last

00:04:11,949 --> 00:04:16,539
talked so key to graphical user

00:04:14,139 --> 00:04:18,609
interface and some parallel rendering

00:04:16,539 --> 00:04:21,010
libraries on top of that and everything

00:04:18,609 --> 00:04:23,840
is neatly wrapped in several different

00:04:21,010 --> 00:04:27,770
languages my favorite of course being

00:04:23,840 --> 00:04:30,980
and here's kind of pair of use model of

00:04:27,770 --> 00:04:34,520
computation so you cannot have a serial

00:04:30,980 --> 00:04:37,100
reader in which case the first part of

00:04:34,520 --> 00:04:38,780
this diagram would just be one big block

00:04:37,100 --> 00:04:42,380
but if you have a parallel reader than

00:04:38,780 --> 00:04:45,080
each process reads just a portion of the

00:04:42,380 --> 00:04:47,389
data that it's responsible for and then

00:04:45,080 --> 00:04:51,979
you can optionally redistribute the data

00:04:47,389 --> 00:04:54,680
with a data distribution filter to have

00:04:51,979 --> 00:04:57,290
for example more spatial locality or if

00:04:54,680 --> 00:04:59,810
you have a serial reader you might read

00:04:57,290 --> 00:05:01,669
in all the data on process 0 and then

00:04:59,810 --> 00:05:03,710
want to distribute the data among all

00:05:01,669 --> 00:05:04,940
your different processes so in pair of

00:05:03,710 --> 00:05:08,720
you there's just one function that you

00:05:04,940 --> 00:05:11,960
call and it takes care of that for you

00:05:08,720 --> 00:05:14,020
as best it can and then if you want to

00:05:11,960 --> 00:05:16,850
do some analysis or visualization

00:05:14,020 --> 00:05:18,979
there's the full VT k pipeline where you

00:05:16,850 --> 00:05:22,330
can have impaired of these language

00:05:18,979 --> 00:05:25,310
filters these are basically analysis or

00:05:22,330 --> 00:05:27,800
visualization functions and then finally

00:05:25,310 --> 00:05:30,350
you have the ice tea parallel rendering

00:05:27,800 --> 00:05:32,660
library and basically each process

00:05:30,350 --> 00:05:35,180
renders whatever data it happens to have

00:05:32,660 --> 00:05:37,700
locally and then iced tea takes care of

00:05:35,180 --> 00:05:40,580
compositing all those different images

00:05:37,700 --> 00:05:43,370
here we have three images into a final

00:05:40,580 --> 00:05:46,849
image that you actually see on screen or

00:05:43,370 --> 00:05:48,590
output from your script so now why

00:05:46,849 --> 00:05:51,770
Python I mentioned that there's a great

00:05:48,590 --> 00:05:54,020
QT GUI for pair of you that you can

00:05:51,770 --> 00:05:56,630
interact with by making some mouse

00:05:54,020 --> 00:06:00,200
clicks and quickly get up and running

00:05:56,630 --> 00:06:05,060
with visualization and you can moreover

00:06:00,200 --> 00:06:09,919
extend a pair of you in C++ by extending

00:06:05,060 --> 00:06:11,630
some of their filters or readers by

00:06:09,919 --> 00:06:14,990
implementing a single method it's not

00:06:11,630 --> 00:06:17,330
too difficult and you implement some XML

00:06:14,990 --> 00:06:21,440
to let the graphical user interface know

00:06:17,330 --> 00:06:24,710
about your extensions but with Python we

00:06:21,440 --> 00:06:27,289
can easily automate a lot of our mouse

00:06:24,710 --> 00:06:28,639
clicks so you get tired of that as a

00:06:27,289 --> 00:06:31,010
researcher clicking around with the

00:06:28,639 --> 00:06:34,590
mouse very quickly and moreover you can

00:06:31,010 --> 00:06:36,320
embed all of your visualization and

00:06:34,590 --> 00:06:38,760
part of your analysis into your existing

00:06:36,320 --> 00:06:40,550
Python code so if you have a Python code

00:06:38,760 --> 00:06:44,280
to generate data you can immediately

00:06:40,550 --> 00:06:46,980
visualized it kind of in line so here's

00:06:44,280 --> 00:06:49,560
an example and I will go through this in

00:06:46,980 --> 00:06:51,960
more detail at the tutorial so what

00:06:49,560 --> 00:06:54,810
progress are we going to make in this

00:06:51,960 --> 00:06:58,380
tutorial so we're going to go over

00:06:54,810 --> 00:07:00,750
creating simple visualizations in cereal

00:06:58,380 --> 00:07:02,670
and in parallel here's an example where

00:07:00,750 --> 00:07:05,610
I'm actually connected to a parallel

00:07:02,670 --> 00:07:09,480
server that I started with this command

00:07:05,610 --> 00:07:11,510
MPI run number of processors to this was

00:07:09,480 --> 00:07:15,470
on my local machine and I have two cores

00:07:11,510 --> 00:07:19,140
and then the PV server command and

00:07:15,470 --> 00:07:22,680
connected to that server then I created

00:07:19,140 --> 00:07:25,560
a sphere I showed the sphere which

00:07:22,680 --> 00:07:27,260
basically tells a pair of you I've made

00:07:25,560 --> 00:07:29,790
some changes to the data pipeline

00:07:27,260 --> 00:07:32,970
recognize those changes and then I

00:07:29,790 --> 00:07:34,320
render the sphere on screen and if I

00:07:32,970 --> 00:07:37,320
save the image then it would just be a

00:07:34,320 --> 00:07:39,810
gray image but then I color by the

00:07:37,320 --> 00:07:43,380
process ID and here I'm connected to a

00:07:39,810 --> 00:07:45,750
server with running on two processes so

00:07:43,380 --> 00:07:48,720
when I show that and color by the

00:07:45,750 --> 00:07:51,090
process ID you can see here I have these

00:07:48,720 --> 00:07:53,790
two colors of the sphere red and blue

00:07:51,090 --> 00:07:55,560
and this is way more fun to double check

00:07:53,790 --> 00:07:58,310
when you're running on like a thousand

00:07:55,560 --> 00:08:00,660
core machine that you're actually

00:07:58,310 --> 00:08:02,010
connected to the server and you really

00:08:00,660 --> 00:08:04,800
can't believe it the first time you do

00:08:02,010 --> 00:08:07,710
it so seeing it visually is this is one

00:08:04,800 --> 00:08:09,150
of those things where it's it's good to

00:08:07,710 --> 00:08:11,880
debug your server just to be able to

00:08:09,150 --> 00:08:15,750
visualize okay here is the data where

00:08:11,880 --> 00:08:21,000
exactly is it living and if you're

00:08:15,750 --> 00:08:22,560
expecting processors to handle data

00:08:21,000 --> 00:08:23,970
that's very close to each other being on

00:08:22,560 --> 00:08:25,530
the same process you can visually

00:08:23,970 --> 00:08:27,690
immediately see if your data

00:08:25,530 --> 00:08:29,310
distribution works or not so we'll be

00:08:27,690 --> 00:08:34,020
able to do this kind of right out of the

00:08:29,310 --> 00:08:36,920
box there and then we'll go over reading

00:08:34,020 --> 00:08:40,110
in data from a comma separated value

00:08:36,920 --> 00:08:43,050
ASCII file that's going to be a serial

00:08:40,110 --> 00:08:46,680
reader but we can then use the data

00:08:43,050 --> 00:08:48,870
distribution filter to

00:08:46,680 --> 00:08:51,930
if we're running on multiple processors

00:08:48,870 --> 00:08:56,100
if you have multiple cores or I have a

00:08:51,930 --> 00:08:58,680
server setup will be able to see which

00:08:56,100 --> 00:09:02,100
process your data lives on as well as

00:08:58,680 --> 00:09:04,500
binary files this is an example of a

00:09:02,100 --> 00:09:08,459
little bit of a random number generator

00:09:04,500 --> 00:09:11,070
and I colored by the size of the random

00:09:08,459 --> 00:09:15,120
number and also scaled the sphere by the

00:09:11,070 --> 00:09:18,360
size of the random number and here's

00:09:15,120 --> 00:09:21,060
some of the Python code I won't go into

00:09:18,360 --> 00:09:23,220
this in detail right now but we'll cover

00:09:21,060 --> 00:09:25,140
this all in a few hours tomorrow and

00:09:23,220 --> 00:09:28,800
also maybe making modifications of this

00:09:25,140 --> 00:09:32,370
to suit your needs will play with some

00:09:28,800 --> 00:09:34,130
data from the web this is some stellar

00:09:32,370 --> 00:09:38,029
cluster data that's freely available

00:09:34,130 --> 00:09:41,399
that we can visualize and manipulate

00:09:38,029 --> 00:09:42,959
will use filters to do analysis so

00:09:41,399 --> 00:09:45,300
here's that previous random number

00:09:42,959 --> 00:09:49,920
generator where I've just brush holded

00:09:45,300 --> 00:09:51,959
by random numbers that lie between 0.75

00:09:49,920 --> 00:09:54,320
and one so you see that now I only have

00:09:51,959 --> 00:09:59,700
big blue spheres instead of small

00:09:54,320 --> 00:10:02,430
reddish spheres and writing your own

00:09:59,700 --> 00:10:07,529
custom readers writers and data filters

00:10:02,430 --> 00:10:10,020
all in native Python so finally we'll go

00:10:07,529 --> 00:10:13,400
over what's possible and I'm welcome to

00:10:10,020 --> 00:10:16,050
brainstorm with you guys if you have a

00:10:13,400 --> 00:10:18,480
big or small data set that you're

00:10:16,050 --> 00:10:22,770
interested in visualizing how exactly

00:10:18,480 --> 00:10:25,140
pair of you might suit your needs and it

00:10:22,770 --> 00:10:27,270
definitely is possible to visualize and

00:10:25,140 --> 00:10:29,550
manipulate terabytes of data in one go

00:10:27,270 --> 00:10:31,470
in real time given the computational

00:10:29,550 --> 00:10:34,440
resources I've looked at billions of

00:10:31,470 --> 00:10:38,700
particles and done analysis tasks in

00:10:34,440 --> 00:10:40,290
real time via pair of you and so I hope

00:10:38,700 --> 00:10:43,709
that you guys manage to make it tomorrow

00:10:40,290 --> 00:10:46,140
and everything should be very accessible

00:10:43,709 --> 00:10:48,560
for anyone from beginning Python

00:10:46,140 --> 00:10:51,029
beginning visualizing beginning

00:10:48,560 --> 00:10:53,459
scientific analysis to if you have a

00:10:51,029 --> 00:10:54,160
huge data set being able to write your

00:10:53,459 --> 00:10:55,839
own custom

00:10:54,160 --> 00:10:59,259
attention and get visualizing it right

00:10:55,839 --> 00:11:01,329
away so if you manage please download

00:10:59,259 --> 00:11:05,170
and run a pair of you binary there are

00:11:01,329 --> 00:11:08,949
binary builds for Windows Mac OS X and

00:11:05,170 --> 00:11:10,779
Linux of course I will also have these

00:11:08,949 --> 00:11:12,459
on USB keys and running on a local

00:11:10,779 --> 00:11:14,470
server at the tutorial if you don't

00:11:12,459 --> 00:11:17,110
manage to do this and if you have

00:11:14,470 --> 00:11:31,439
problems with this please ping me so

00:11:17,110 --> 00:11:31,439
thank you very much yes

00:11:35,750 --> 00:11:38,740
don't be shy

00:11:45,080 --> 00:11:50,420
you have any pointers to like freely

00:11:48,170 --> 00:11:55,010
available datasets they're actually

00:11:50,420 --> 00:11:58,730
interesting to visualize yeah I have

00:11:55,010 --> 00:12:02,900
well it depends on what field you find

00:11:58,730 --> 00:12:05,090
interesting of course but there is a lot

00:12:02,900 --> 00:12:07,850
of data freely available on Amazon s3

00:12:05,090 --> 00:12:12,200
for example their server cluster and

00:12:07,850 --> 00:12:14,270
they even index it amazon has freely

00:12:12,200 --> 00:12:18,590
searchable list of freely available data

00:12:14,270 --> 00:12:20,180
on s3 and there are I think a thousand

00:12:18,590 --> 00:12:23,590
different huge data sets so both the

00:12:20,180 --> 00:12:27,020
engrams and the Wikipedia traffic

00:12:23,590 --> 00:12:28,100
examples in my talk were taken from just

00:12:27,020 --> 00:12:30,860
searching that list of what's

00:12:28,100 --> 00:12:32,480
interesting out there so if you have a

00:12:30,860 --> 00:12:34,370
huge data set you want to visualize you

00:12:32,480 --> 00:12:36,980
probably need a huge cluster and unless

00:12:34,370 --> 00:12:39,590
you're on at a university you might want

00:12:36,980 --> 00:12:41,360
to run on amazon for example so having

00:12:39,590 --> 00:12:44,030
the data already at amazon saves you the

00:12:41,360 --> 00:12:45,680
trouble of transferring two terabytes of

00:12:44,030 --> 00:12:54,070
data to your server which is always

00:12:45,680 --> 00:12:54,070
annoying any other questions

00:13:03,160 --> 00:13:10,889
is the the library fit for visualizing

00:13:08,410 --> 00:13:16,360
faint element analysis data or

00:13:10,889 --> 00:13:20,889
computational fluid dynamics results yes

00:13:16,360 --> 00:13:23,319
absolutely it actually natively handles

00:13:20,889 --> 00:13:25,360
a lot of commonly used formats in both

00:13:23,319 --> 00:13:28,000
those fields and you can definitely

00:13:25,360 --> 00:13:30,009
write your own custom extensions there

00:13:28,000 --> 00:13:32,560
are lots of the primitive data sets in

00:13:30,009 --> 00:13:36,069
VT k or pair of you that handles say

00:13:32,560 --> 00:13:38,620
moving meshes etc so if you're very

00:13:36,069 --> 00:13:40,360
lucky you can even pick your favorite

00:13:38,620 --> 00:13:42,519
data set and use it out of the box if

00:13:40,360 --> 00:13:45,009
you're slightly less lucky you might

00:13:42,519 --> 00:13:47,379
have to write some lines of Python or C

00:13:45,009 --> 00:13:56,019
C++ to handle that but it's very

00:13:47,379 --> 00:13:59,009
suitable for for both those fields and

00:13:56,019 --> 00:14:02,319
how's it work with large graph layouts I

00:13:59,009 --> 00:14:06,519
haven't personally done that there are a

00:14:02,319 --> 00:14:08,709
lot of customized extensions plugins so

00:14:06,519 --> 00:14:12,279
I maintain one plug-in that deals with a

00:14:08,709 --> 00:14:14,259
few data sets and analysis tasks that

00:14:12,279 --> 00:14:17,069
are very common in astrophysics and I do

00:14:14,259 --> 00:14:19,899
know that there is a computer science

00:14:17,069 --> 00:14:23,769
plugin called infovis that handles a lot

00:14:19,899 --> 00:14:25,240
of the graph visualization topics of

00:14:23,769 --> 00:14:29,470
interest but I haven't played around

00:14:25,240 --> 00:14:31,860
with it myself so I can look into that a

00:14:29,470 --> 00:14:35,709
bit if you're planning to come tomorrow

00:14:31,860 --> 00:14:37,389
but my intuition is that it is suitable

00:14:35,709 --> 00:14:42,459
for that but I just haven't played

00:14:37,389 --> 00:14:47,559
around with that as much I knew that

00:14:42,459 --> 00:14:49,269
there were many questions is this a

00:14:47,559 --> 00:14:51,730
platform dependent or platform

00:14:49,269 --> 00:14:54,220
independent running the Macintosh oh its

00:14:51,730 --> 00:14:56,920
platform independent it uses scenic as a

00:14:54,220 --> 00:14:59,199
build system so even the build process

00:14:56,920 --> 00:15:00,910
is I've built it personally I've never

00:14:59,199 --> 00:15:03,309
built it on a Windows machine but I

00:15:00,910 --> 00:15:06,459
supervise a student who uses windows and

00:15:03,309 --> 00:15:11,259
he had no problem developing and running

00:15:06,459 --> 00:15:12,790
on Windows and I built on anything from

00:15:11,259 --> 00:15:15,220
my local mac to

00:15:12,790 --> 00:15:17,620
a linux-based supercomputer and really

00:15:15,220 --> 00:15:19,060
um sometimes especially when you're

00:15:17,620 --> 00:15:21,280
setting things up on a supercomputer

00:15:19,060 --> 00:15:25,930
things can get a little harried in

00:15:21,280 --> 00:15:33,310
copulation but definitely for your local

00:15:25,930 --> 00:15:37,270
machine it's very easy to compile I have

00:15:33,310 --> 00:15:40,360
a question so if there's any company

00:15:37,270 --> 00:15:43,030
here that is interested in using it for

00:15:40,360 --> 00:15:46,360
the Commissioner commercial applications

00:15:43,030 --> 00:15:49,750
what are the licenses so it's under a

00:15:46,360 --> 00:15:51,970
bsd license and I believe that means

00:15:49,750 --> 00:15:53,770
that you can incorporate it into your

00:15:51,970 --> 00:15:56,920
commercial products and you don't have

00:15:53,770 --> 00:16:00,160
to release the entire source as is the

00:15:56,920 --> 00:16:06,670
GPL so I am aware of several commercial

00:16:00,160 --> 00:16:15,870
products that that use pair of you think

00:16:06,670 --> 00:16:15,870

YouTube URL: https://www.youtube.com/watch?v=y2eKgo3gw-0


