Title: What makes Python so AWESOME
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Raymond Hettinger - 20 June 2011 in "Track Spaghetti"
Captions: 
	00:00:00,770 --> 00:00:12,379
so thank you very much so the talk is

00:00:10,070 --> 00:00:14,030
what makes Python so awesome

00:00:12,379 --> 00:00:17,570
I could have put a period here an

00:00:14,030 --> 00:00:18,890
exclamation point are a question I'm

00:00:17,570 --> 00:00:21,740
going to try it all three different ways

00:00:18,890 --> 00:00:23,539
so quick introduction I'm a PSF board

00:00:21,740 --> 00:00:24,859
member I decided to become a board

00:00:23,539 --> 00:00:29,300
member after getting a really good

00:00:24,859 --> 00:00:32,090
massage long term Python core developer

00:00:29,300 --> 00:00:34,190
have written some of the tools that you

00:00:32,090 --> 00:00:35,840
probably use everyday set object sorting

00:00:34,190 --> 00:00:37,670
key functions that are tools that sort

00:00:35,840 --> 00:00:42,530
of thing the most important part of this

00:00:37,670 --> 00:00:44,660
is the Raymond H on Twitter if you were

00:00:42,530 --> 00:00:46,850
connected in now what I'd like to do is

00:00:44,660 --> 00:00:49,250
make this up very dynamic and a fun talk

00:00:46,850 --> 00:00:51,620
where you guys are as we're going along

00:00:49,250 --> 00:00:54,560
tweeting about what you think makes

00:00:51,620 --> 00:00:56,810
Python awesome I'd like to be a two-way

00:00:54,560 --> 00:00:58,880
conversation and so let's all share as

00:00:56,810 --> 00:00:59,390
we go along I think that makes Python

00:00:58,880 --> 00:01:00,920
awesome

00:00:59,390 --> 00:01:03,260
I have something that's not on the list

00:01:00,920 --> 00:01:05,449
that I think is Python as awesome and so

00:01:03,260 --> 00:01:09,560
either tweeted to Europe Python or

00:01:05,449 --> 00:01:11,479
Raymond H also Raymond H i-i've for past

00:01:09,560 --> 00:01:15,710
couple months try to put out some Python

00:01:11,479 --> 00:01:18,020
tips and tricks one or two every day to

00:01:15,710 --> 00:01:21,499
try and create an interesting two-way

00:01:18,020 --> 00:01:24,679
fun Twitter feed okay so I have a

00:01:21,499 --> 00:01:29,689
question for you name an awesome

00:01:24,679 --> 00:01:35,719
language I have heard a couple things

00:01:29,689 --> 00:01:39,189
any any others okay I've heard Python

00:01:35,719 --> 00:01:44,979
mentioned in a number of times

00:01:39,189 --> 00:01:44,979
who said Python why is it awesome

00:01:46,810 --> 00:01:53,299
read it so that makes it great what else

00:01:50,360 --> 00:01:57,290
makes it great is it right your agree

00:01:53,299 --> 00:02:01,460
that Python is awesome okay we'd say it

00:01:57,290 --> 00:02:04,729
seemed to have general agreement are

00:02:01,460 --> 00:02:06,770
there any other awesome languages is my

00:02:04,729 --> 00:02:08,179
opinion that all of these are awesome I

00:02:06,770 --> 00:02:09,500
have programmed in all of them at one

00:02:08,179 --> 00:02:12,020
time or another and they each have their

00:02:09,500 --> 00:02:13,550
own degree of also awesomeness assembler

00:02:12,020 --> 00:02:15,319
was great because it's close to the

00:02:13,550 --> 00:02:17,390
middle and I could back when memory was

00:02:15,319 --> 00:02:20,840
constrained fit lots of stuff in a small

00:02:17,390 --> 00:02:25,430
space where COBOL was a little less

00:02:20,840 --> 00:02:27,739
awesome but okay there is a reason that

00:02:25,430 --> 00:02:30,380
there have been billions of lines of

00:02:27,739 --> 00:02:33,050
code of a COBOL ready and there is a

00:02:30,380 --> 00:02:35,000
reason that Fortran is still around all

00:02:33,050 --> 00:02:36,470
of these languages are awesome somewhat

00:02:35,000 --> 00:02:38,900
so I'm not here to commit you today that

00:02:36,470 --> 00:02:41,120
Python is more awesome instead we're

00:02:38,900 --> 00:02:44,600
going to talk about the things that does

00:02:41,120 --> 00:02:46,700
make Python awesome itself what each

00:02:44,600 --> 00:02:48,260
language is awesome in its own ways what

00:02:46,700 --> 00:02:50,510
are our ways we've come up with one

00:02:48,260 --> 00:02:56,239
which is a readability is there anything

00:02:50,510 --> 00:03:03,620
else that makes Python awesome that's a

00:02:56,239 --> 00:03:05,000
really good one that one wasn't on the

00:03:03,620 --> 00:03:09,549
list remind me of that we will come back

00:03:05,000 --> 00:03:14,299
to that it's fantastic anything else ah

00:03:09,549 --> 00:03:16,370
already covered you guys have not

00:03:14,299 --> 00:03:18,230
guessed the next slide yet the thing

00:03:16,370 --> 00:03:22,519
that makes some Python the most awesome

00:03:18,230 --> 00:03:25,130
is its license okay I actually what I've

00:03:22,519 --> 00:03:27,260
done is compiled a list of what reasons

00:03:25,130 --> 00:03:29,570
I think that Python is awesome starting

00:03:27,260 --> 00:03:31,820
from very high-level contextual factors

00:03:29,570 --> 00:03:33,500
then going to some high level use of the

00:03:31,820 --> 00:03:35,900
language and then some actual language

00:03:33,500 --> 00:03:38,989
features itself so those the three parts

00:03:35,900 --> 00:03:40,670
of the top so what it took to get Python

00:03:38,989 --> 00:03:42,799
on the map I think one of the most

00:03:40,670 --> 00:03:44,840
important things was its license head

00:03:42,799 --> 00:03:49,280
cuido not open-source it you would not

00:03:44,840 --> 00:03:53,470
be using a Python today being open is at

00:03:49,280 --> 00:03:57,049
the heart of what makes Python awesome

00:03:53,470 --> 00:03:58,970
interesting parts of the license are

00:03:57,049 --> 00:04:01,190
it's available to you on an AZ

00:03:58,970 --> 00:04:03,110
spaces to set sound awesome like if it

00:04:01,190 --> 00:04:04,820
breaks it's not our fault that part

00:04:03,110 --> 00:04:07,130
doesn't sound is awesome but we give you

00:04:04,820 --> 00:04:09,830
access to the source code most important

00:04:07,130 --> 00:04:11,690
part is the last part the owners of the

00:04:09,830 --> 00:04:14,000
intellectual property rights the PSF

00:04:11,690 --> 00:04:16,340
they grant you a non-exclusive

00:04:14,000 --> 00:04:18,350
royalty-free worldwide license to

00:04:16,340 --> 00:04:19,940
reproduce analyze test perform and are

00:04:18,350 --> 00:04:22,010
publicly display prepared derivative

00:04:19,940 --> 00:04:24,230
works distribute or otherwise use Python

00:04:22,010 --> 00:04:25,450
alone or in any derivative version who

00:04:24,230 --> 00:04:27,980
thinks that's awesome

00:04:25,450 --> 00:04:37,030
it is awesome that's why we use Python

00:04:27,980 --> 00:04:37,030
today I concur

00:04:37,120 --> 00:04:41,120
Python is awesome because it has

00:04:39,020 --> 00:04:43,610
commercial distributions this is a very

00:04:41,120 --> 00:04:45,380
short list but uh the list of people

00:04:43,610 --> 00:04:47,480
working commercial firms working the

00:04:45,380 --> 00:04:49,220
Python community is enormous but these

00:04:47,480 --> 00:04:51,590
are two separate commercial

00:04:49,220 --> 00:04:53,180
distributions why is that awesome I

00:04:51,590 --> 00:04:55,900
contend that a language can't be

00:04:53,180 --> 00:04:57,980
successful until it has some commercial

00:04:55,900 --> 00:04:59,330
distributions because there are

00:04:57,980 --> 00:05:01,190
companies that unless there is a

00:04:59,330 --> 00:05:03,950
commercial distribution they can't use

00:05:01,190 --> 00:05:07,700
it and so these groups sell people who

00:05:03,950 --> 00:05:10,100
need a commercial distribution and we

00:05:07,700 --> 00:05:12,500
have a language that encourages the

00:05:10,100 --> 00:05:14,390
commercial side as well as the the free

00:05:12,500 --> 00:05:16,040
and open side the two fit together

00:05:14,390 --> 00:05:18,200
really nicely I think it was a key

00:05:16,040 --> 00:05:19,940
factor of success so if you are

00:05:18,200 --> 00:05:21,620
everything should be free and open

00:05:19,940 --> 00:05:23,270
person realized that the commercial side

00:05:21,620 --> 00:05:25,360
of it has contributed to some of this

00:05:23,270 --> 00:05:27,830
success to get us where we are today

00:05:25,360 --> 00:05:28,250
what else do we have what makes us

00:05:27,830 --> 00:05:35,780
special

00:05:28,250 --> 00:05:41,090
we've got Zen it speaks for itself

00:05:35,780 --> 00:05:42,680
got more Zen and as was mentioned we've

00:05:41,090 --> 00:05:44,030
got the community I think community is

00:05:42,680 --> 00:05:45,950
one of the killer features I'm going to

00:05:44,030 --> 00:05:48,500
ask you why the Python is awesome in

00:05:45,950 --> 00:05:50,240
part it has a fantastic community we

00:05:48,500 --> 00:05:53,360
have them the news groups the mail list

00:05:50,240 --> 00:05:56,510
there are pie cons everywhere now I just

00:05:53,360 --> 00:05:58,550
got invited to go speak in India of all

00:05:56,510 --> 00:06:00,530
places so that will be my first trip

00:05:58,550 --> 00:06:02,770
there they're popping up all over the

00:06:00,530 --> 00:06:05,120
place other pie interest groups

00:06:02,770 --> 00:06:07,610
everywhere the language is having a

00:06:05,120 --> 00:06:09,770
phenomenal success and part of it is the

00:06:07,610 --> 00:06:13,669
community of people you were the folks

00:06:09,770 --> 00:06:17,300
that make this part of me flick Python

00:06:13,669 --> 00:06:20,090
wonderful to work with who thinks the

00:06:17,300 --> 00:06:21,860
community is a killer feature so if

00:06:20,090 --> 00:06:23,360
you're making your own language and you

00:06:21,860 --> 00:06:25,580
want it to be awesome when the first

00:06:23,360 --> 00:06:27,530
things you need to do before you write

00:06:25,580 --> 00:06:29,240
your first line of code is start to

00:06:27,530 --> 00:06:32,570
develop a wonderful community like we've

00:06:29,240 --> 00:06:34,160
got today one that scales and retains

00:06:32,570 --> 00:06:38,750
its nice qualities and its pleasant to

00:06:34,160 --> 00:06:41,390
work with we've got Pippi why is that

00:06:38,750 --> 00:06:42,800
important it's our way of exchanging

00:06:41,390 --> 00:06:44,840
modules with one another and work with

00:06:42,800 --> 00:06:47,390
one another no way the CCD is currently

00:06:44,840 --> 00:06:49,190
up to a 15,000 package strictly

00:06:47,390 --> 00:06:51,290
accessible by installers which you can

00:06:49,190 --> 00:06:54,200
go in and say hip install ordered it and

00:06:51,290 --> 00:06:56,419
even if you're working in Python to five

00:06:54,200 --> 00:06:59,020
the Oder dick will come right down and

00:06:56,419 --> 00:07:02,030
you can start working with the features

00:06:59,020 --> 00:07:02,750
that were introduced in later versions

00:07:02,030 --> 00:07:04,910
of Python

00:07:02,750 --> 00:07:08,900
I think Pippi is a killer feature what

00:07:04,910 --> 00:07:10,430
do you think okay I see some nods of

00:07:08,900 --> 00:07:12,860
affirmation but I don't see fingers

00:07:10,430 --> 00:07:15,590
typing tweeting up a storm saying yes

00:07:12,860 --> 00:07:18,010
the community with no no it's Pippi I

00:07:15,590 --> 00:07:19,850
insist that Pippi is our killer feature

00:07:18,010 --> 00:07:21,350
okay if you're going to have a

00:07:19,850 --> 00:07:23,479
successful language what else do you

00:07:21,350 --> 00:07:25,760
need you need killer apps and success

00:07:23,479 --> 00:07:28,940
stories once again this is not an

00:07:25,760 --> 00:07:32,180
include all-inclusive list so why is it

00:07:28,940 --> 00:07:36,590
on the list because it was early and big

00:07:32,180 --> 00:07:38,600
it put Python on a map in some ways it

00:07:36,590 --> 00:07:41,600
was every bit as important to Python is

00:07:38,600 --> 00:07:44,900
a Django and pylons are today

00:07:41,600 --> 00:07:46,669
how about numpy and Syfy then there is a

00:07:44,900 --> 00:07:48,660
whole section of the community that

00:07:46,669 --> 00:07:51,210
works with these tools

00:07:48,660 --> 00:07:53,970
every day work was written in our

00:07:51,210 --> 00:07:55,980
Python twisted is a fantastic tool

00:07:53,970 --> 00:07:59,640
YouTube I understand was at one point

00:07:55,980 --> 00:08:03,270
entirely based in a Python we have

00:07:59,640 --> 00:08:04,920
Google's acceptance of use of Python I

00:08:03,270 --> 00:08:06,480
understand was one of the big reasons

00:08:04,920 --> 00:08:11,430
that Python became more accepted in

00:08:06,480 --> 00:08:14,970
Japan when cuido joined Google that in

00:08:11,430 --> 00:08:17,160
and of itself boosted the success rate

00:08:14,970 --> 00:08:19,350
in Japan and changed the perception of

00:08:17,160 --> 00:08:21,600
the language as a whole so we're talking

00:08:19,350 --> 00:08:23,700
about high level context factors things

00:08:21,600 --> 00:08:25,620
that contribute to making Python awesome

00:08:23,700 --> 00:08:27,960
you cannot have an awesome language

00:08:25,620 --> 00:08:33,599
without some killer apps and some big

00:08:27,960 --> 00:08:36,270
success stories 32 I'll bet most of you

00:08:33,599 --> 00:08:38,789
in here don't use Windows but there's a

00:08:36,270 --> 00:08:41,580
huge huge huge segment of the world that

00:08:38,789 --> 00:08:43,650
does we opened our door to that that was

00:08:41,580 --> 00:08:46,800
Mark Hammond he opened up a massive

00:08:43,650 --> 00:08:49,260
massive user base without it Python

00:08:46,800 --> 00:08:50,820
would not be where it is today so we're

00:08:49,260 --> 00:08:52,920
all benefitting for tools that we might

00:08:50,820 --> 00:08:54,840
not even use you may have never heard of

00:08:52,920 --> 00:08:58,050
soap maybe never used soap but you're

00:08:54,840 --> 00:08:59,910
benefiting from the community it was

00:08:58,050 --> 00:09:01,530
formed by soap the massive number of

00:08:59,910 --> 00:09:04,710
users who came to Python from soap

00:09:01,530 --> 00:09:07,350
likewise you are benefiting now from the

00:09:04,710 --> 00:09:09,390
enormous number of people who got

00:09:07,350 --> 00:09:11,790
benefit from being able to run on

00:09:09,390 --> 00:09:14,190
Windows and interface with the Microsoft

00:09:11,790 --> 00:09:15,330
apps and we've got books we've got a

00:09:14,190 --> 00:09:17,190
number of book authors uh

00:09:15,330 --> 00:09:19,920
here there's learning Python dive into

00:09:17,190 --> 00:09:21,300
Python Python a nutshell Python cookbook

00:09:19,920 --> 00:09:23,610
pay you've got two of them on here

00:09:21,300 --> 00:09:25,950
that's nope here okay in an upcoming

00:09:23,610 --> 00:09:29,000
book what makes the last book special

00:09:25,950 --> 00:09:32,970
besides being vapor we're at this point

00:09:29,000 --> 00:09:35,880
ok the last book is special because it

00:09:32,970 --> 00:09:38,970
is written by we have gone out to

00:09:35,880 --> 00:09:40,770
various members of the community asking

00:09:38,970 --> 00:09:43,110
them to write about what they were

00:09:40,770 --> 00:09:46,980
expert in so most books are a bit of a

00:09:43,110 --> 00:09:48,930
challenge even for Alex Martelli to have

00:09:46,980 --> 00:09:50,640
to write a whole book about all of

00:09:48,930 --> 00:09:52,650
Python because it puts him in the

00:09:50,640 --> 00:09:56,340
position of having to be an expert about

00:09:52,650 --> 00:09:57,630
every single corner of Python the

00:09:56,340 --> 00:09:59,570
different approach for python swallowed

00:09:57,630 --> 00:10:01,590
whole is we actually went to the expert

00:09:59,570 --> 00:10:06,420
person wrote the decimal

00:10:01,590 --> 00:10:08,880
person who created module X Y or Z the

00:10:06,420 --> 00:10:11,400
person whose are the group of people who

00:10:08,880 --> 00:10:14,070
worked on a jet on for example and say

00:10:11,400 --> 00:10:18,029
write us a chapter tell us what we need

00:10:14,070 --> 00:10:20,730
to know educator so it is a book by the

00:10:18,029 --> 00:10:23,670
community every chapter was written by

00:10:20,730 --> 00:10:24,960
the expert in that particular area and I

00:10:23,670 --> 00:10:28,220
think it's going to be a fantastic thing

00:10:24,960 --> 00:10:30,779
where do 100 percent of the proceeds go

00:10:28,220 --> 00:10:34,170
to the Python massage foundation of

00:10:30,779 --> 00:10:35,790
Python software vendors all right so

00:10:34,170 --> 00:10:37,589
summary this is what you need is a

00:10:35,790 --> 00:10:39,480
context for success you need a good

00:10:37,589 --> 00:10:41,580
license you need some commercial

00:10:39,480 --> 00:10:44,250
distributions you need the Zen without

00:10:41,580 --> 00:10:47,100
your philosophy you're not centered you

00:10:44,250 --> 00:10:48,360
need a community all of these things are

00:10:47,100 --> 00:10:49,620
necessary if you're going to get your

00:10:48,360 --> 00:10:52,260
language up and running and make it

00:10:49,620 --> 00:10:53,520
awesome you need to run on Windows you

00:10:52,260 --> 00:10:55,050
need to have some success stories you

00:10:53,520 --> 00:10:56,820
need to have a few good books out there

00:10:55,050 --> 00:10:58,589
there are some languages that I think

00:10:56,820 --> 00:11:00,180
are pretty neat some tools I think are

00:10:58,589 --> 00:11:02,310
pretty neat in there no books on them it

00:11:00,180 --> 00:11:03,990
makes them relatively and accessible to

00:11:02,310 --> 00:11:07,140
me I think all of these are expensive

00:11:03,990 --> 00:11:09,860
essential success factors who thinks all

00:11:07,140 --> 00:11:12,720
of these things make Python awesome

00:11:09,860 --> 00:11:15,930
alright let's go down a level that's

00:11:12,720 --> 00:11:18,720
just too high level for me Raymond what

00:11:15,930 --> 00:11:20,640
besides context are we doing right name

00:11:18,720 --> 00:11:22,170
something specific to Python itself

00:11:20,640 --> 00:11:24,120
because all the things I just mentioned

00:11:22,170 --> 00:11:27,480
really could have applied to any other

00:11:24,120 --> 00:11:29,160
language and yet you guys said it was

00:11:27,480 --> 00:11:30,660
Python that was awesome so what else

00:11:29,160 --> 00:11:34,380
were you doing right what are some of

00:11:30,660 --> 00:11:39,690
the kind of qualities of Python itself

00:11:34,380 --> 00:11:41,700
that make it distinct so I think that's

00:11:39,690 --> 00:11:43,860
last on the list today and that is a

00:11:41,700 --> 00:11:45,959
detailed language feature as opposed to

00:11:43,860 --> 00:11:49,890
right now we're at the middle level the

00:11:45,959 --> 00:11:51,810
qualities of the language I tried to

00:11:49,890 --> 00:11:53,310
rank order a couple of these so and I

00:11:51,810 --> 00:11:54,900
thought put ease of learning on the top

00:11:53,310 --> 00:11:56,820
of the list in order to get ready for

00:11:54,900 --> 00:11:59,040
this talk I went to a number of clients

00:11:56,820 --> 00:12:00,870
I taught a number of class and if I

00:11:59,040 --> 00:12:04,529
surveyed them all and asked them what

00:12:00,870 --> 00:12:06,570
makes Python awesome and one of the

00:12:04,529 --> 00:12:08,760
amazing features is how quickly you can

00:12:06,570 --> 00:12:10,320
get up to speed with Python it used to

00:12:08,760 --> 00:12:12,959
be you could learn all of Python in a

00:12:10,320 --> 00:12:14,660
weekend now it's a much bigger language

00:12:12,959 --> 00:12:16,670
but the core of Python can be

00:12:14,660 --> 00:12:18,910
very quickly what can be learned in one

00:12:16,670 --> 00:12:22,459
hour you can learn your types int float

00:12:18,910 --> 00:12:25,000
string list tuples sets dick those are

00:12:22,459 --> 00:12:27,170
enough to get you very very very far and

00:12:25,000 --> 00:12:29,600
algorithm design and solving your

00:12:27,170 --> 00:12:30,980
problems on the control structures for

00:12:29,600 --> 00:12:33,949
loops while loops strikes up

00:12:30,980 --> 00:12:36,529
if-then-else then you've learned some

00:12:33,949 --> 00:12:38,569
tools for to organize your programs into

00:12:36,529 --> 00:12:40,399
functions classes and modules I can

00:12:38,569 --> 00:12:43,550
cover that in one hour and a high speed

00:12:40,399 --> 00:12:45,199
class yeah in that one hour there won't

00:12:43,550 --> 00:12:47,360
be a whole lot of time for practice and

00:12:45,199 --> 00:12:49,129
whatnot but I have seen tutorials they

00:12:47,360 --> 00:12:50,930
can walk you through in one hour and

00:12:49,129 --> 00:12:52,879
cover all of those subjects I think

00:12:50,930 --> 00:12:58,459
that's amazing who thinks they can get

00:12:52,879 --> 00:13:02,629
that far in C++ in an hour I actually

00:12:58,459 --> 00:13:05,569
participated on the C++ standardization

00:13:02,629 --> 00:13:07,879
committee many many many moons ago and

00:13:05,569 --> 00:13:10,449
yet I've still yet to master that

00:13:07,879 --> 00:13:13,790
language and I think that says something

00:13:10,449 --> 00:13:15,199
what can be learned in a day well if

00:13:13,790 --> 00:13:17,870
you've got a day of training to learn

00:13:15,199 --> 00:13:22,160
Python idioms learn you met all the meta

00:13:17,870 --> 00:13:23,870
commentary library so you know what's

00:13:22,160 --> 00:13:25,939
available and you learn the special

00:13:23,870 --> 00:13:27,639
methods in other words you're decently

00:13:25,939 --> 00:13:30,470
well-equipped after one day of training

00:13:27,639 --> 00:13:32,420
to start writing Python programs that

00:13:30,470 --> 00:13:34,519
are useful who thinks that's fantastic

00:13:32,420 --> 00:13:36,649
it is one of the killer features the

00:13:34,519 --> 00:13:38,029
language and what I think I think it's

00:13:36,649 --> 00:13:41,000
one of the number one things that makes

00:13:38,029 --> 00:13:42,949
a Python awesome I don't get asked this

00:13:41,000 --> 00:13:45,709
as much anymore but a few years ago a

00:13:42,949 --> 00:13:48,230
common question of by businesses was

00:13:45,709 --> 00:13:49,790
where do I go to get Python programmers

00:13:48,230 --> 00:13:52,370
so just starting a Python program I'm

00:13:49,790 --> 00:13:54,139
not going to set my have my business use

00:13:52,370 --> 00:13:55,759
Python because I can't get Python

00:13:54,139 --> 00:13:57,800
programmers I look in the listings and I

00:13:55,759 --> 00:13:59,930
don't see them where'd a Python

00:13:57,800 --> 00:14:03,550
programmers come from and I'd always

00:13:59,930 --> 00:14:05,720
answers like take any good programmer

00:14:03,550 --> 00:14:07,839
give them a week long training course

00:14:05,720 --> 00:14:11,059
and they're proud of they are a Python

00:14:07,839 --> 00:14:13,819
programmer it takes that long to get

00:14:11,059 --> 00:14:17,300
productive to a commercial level in

00:14:13,819 --> 00:14:19,819
Python how long does it take to get that

00:14:17,300 --> 00:14:21,769
productive in Java I'd say after 6

00:14:19,819 --> 00:14:24,589
months a person can be a pretty solid

00:14:21,769 --> 00:14:28,470
contributor as a Java programmer and

00:14:24,589 --> 00:14:30,870
after two years of C++ they can be

00:14:28,470 --> 00:14:32,880
pretty solid contributor if you are

00:14:30,870 --> 00:14:34,650
already a good programmer I can get you

00:14:32,880 --> 00:14:35,280
there in a week who thinks that's

00:14:34,650 --> 00:14:38,220
fantast

00:14:35,280 --> 00:14:39,570
it's a reason to base your business on

00:14:38,220 --> 00:14:42,390
Python so I don't have any Python

00:14:39,570 --> 00:14:44,420
programmers went into a business that

00:14:42,390 --> 00:14:46,350
didn't have any Python programmers

00:14:44,420 --> 00:14:48,060
protect your training for a week and

00:14:46,350 --> 00:14:50,040
guess what they have an army of Python

00:14:48,060 --> 00:14:52,730
programmers you can make them out of

00:14:50,040 --> 00:14:57,630
nothing who thinks that's fantastic

00:14:52,730 --> 00:14:58,560
who thinks that's awesome all right so I

00:14:57,630 --> 00:15:00,840
think it's one of the number one

00:14:58,560 --> 00:15:03,360
attraction to the language then there's

00:15:00,840 --> 00:15:05,340
the rapid development cycle and there

00:15:03,360 --> 00:15:09,030
are rapid development methodologies that

00:15:05,340 --> 00:15:10,760
can be used in any language oh and one

00:15:09,030 --> 00:15:12,990
of my first exposures to rapid

00:15:10,760 --> 00:15:15,720
development was I was a big fan of the

00:15:12,990 --> 00:15:18,840
programming language off I wrote a

00:15:15,720 --> 00:15:20,130
flight simulator and uh those are the

00:15:18,840 --> 00:15:22,080
category of scripting languages

00:15:20,130 --> 00:15:24,360
scripting languages are just hard to

00:15:22,080 --> 00:15:26,460
beat for speed programs grow up are

00:15:24,360 --> 00:15:27,390
organically they're always working and

00:15:26,460 --> 00:15:30,270
you're just crafting on new

00:15:27,390 --> 00:15:31,950
functionality it begets a style of

00:15:30,270 --> 00:15:35,040
development that's fantastically

00:15:31,950 --> 00:15:37,110
productive it also has this really nice

00:15:35,040 --> 00:15:39,720
environment for us where with the

00:15:37,110 --> 00:15:41,040
interactive prop and let's let you write

00:15:39,720 --> 00:15:43,110
a function and then immediately go out

00:15:41,040 --> 00:15:45,240
and start working with your own tools

00:15:43,110 --> 00:15:46,830
and that doesn't seem like a big deal

00:15:45,240 --> 00:15:48,180
unless you compare two languages where

00:15:46,830 --> 00:15:49,920
you can't do that where you have to

00:15:48,180 --> 00:15:53,520
build up an enormous library and it's

00:15:49,920 --> 00:15:55,250
not it didn't used to be uncommon to go

00:15:53,520 --> 00:15:57,450
into an organization and see them two

00:15:55,250 --> 00:15:58,710
mendes amount of development but I've

00:15:57,450 --> 00:16:00,240
never actually worked with their own

00:15:58,710 --> 00:16:02,310
tool they didn't see how the parts fit

00:16:00,240 --> 00:16:03,990
together you know they saw descriptions

00:16:02,310 --> 00:16:06,030
of how the tar Wow parts put together

00:16:03,990 --> 00:16:07,830
they white boarded it but they couldn't

00:16:06,030 --> 00:16:10,680
go out and actually play with their

00:16:07,830 --> 00:16:14,220
tools you take your average of C++

00:16:10,680 --> 00:16:16,560
library or C library you have to graft

00:16:14,220 --> 00:16:17,940
on a lot of tools in order to be able to

00:16:16,560 --> 00:16:19,920
go and play with each of the pieces

00:16:17,940 --> 00:16:21,960
you've just made but in Python it's

00:16:19,920 --> 00:16:23,760
remarkably easy to do so this is not the

00:16:21,960 --> 00:16:26,550
only language that has that small talk

00:16:23,760 --> 00:16:27,830
was fantastic in that you could graft on

00:16:26,550 --> 00:16:29,550
a little piece of functionality and

00:16:27,830 --> 00:16:31,590
exercise it right away

00:16:29,550 --> 00:16:33,750
at least a very rapid development and

00:16:31,590 --> 00:16:36,240
then of course interpreted languages

00:16:33,750 --> 00:16:38,220
save dry your your cycle of edit compile

00:16:36,240 --> 00:16:40,350
and run I don't think that's a

00:16:38,220 --> 00:16:40,980
particularly killer feature because with

00:16:40,350 --> 00:16:42,930
making

00:16:40,980 --> 00:16:45,000
some other tools that are available and

00:16:42,930 --> 00:16:46,440
compiled languages that is not that big

00:16:45,000 --> 00:16:48,149
of a step the more important thing is

00:16:46,440 --> 00:16:51,300
being able to work interactively and

00:16:48,149 --> 00:16:52,680
growing organically who thinks rapid

00:16:51,300 --> 00:16:56,850
development is pythons most killer

00:16:52,680 --> 00:16:58,649
feature interesting it is such a killer

00:16:56,850 --> 00:17:02,910
feature that it can overcome some of

00:16:58,649 --> 00:17:04,650
pythons limitations paired to some

00:17:02,910 --> 00:17:08,699
compiled languages with well designed

00:17:04,650 --> 00:17:10,470
code Python is ungodly slow where would

00:17:08,699 --> 00:17:11,819
that matter that might matter in a

00:17:10,470 --> 00:17:14,130
genomics field where you have enormous

00:17:11,819 --> 00:17:16,380
datasets I worked in a high frequency

00:17:14,130 --> 00:17:18,949
trading company where we wrote

00:17:16,380 --> 00:17:21,809
strategies to go out and find momentary

00:17:18,949 --> 00:17:25,110
aberrations in the stock market and abra

00:17:21,809 --> 00:17:27,179
arbitrage them away those aberrations

00:17:25,110 --> 00:17:29,820
could last for under a millisecond and

00:17:27,179 --> 00:17:32,309
the early bird gets the worm whoever had

00:17:29,820 --> 00:17:34,679
the fastest program would win so why did

00:17:32,309 --> 00:17:36,330
we program in Python I went to a

00:17:34,679 --> 00:17:40,350
genomics company we programmed in Python

00:17:36,330 --> 00:17:42,330
why if python is so slow the answer is

00:17:40,350 --> 00:17:45,000
the rapid development cycle more than

00:17:42,330 --> 00:17:47,190
makes up for that the ability to in a

00:17:45,000 --> 00:17:48,860
trading firm to adapt to strategy as

00:17:47,190 --> 00:17:53,160
fast as the market is changing something

00:17:48,860 --> 00:17:55,530
you are programming in a C++ or Java you

00:17:53,160 --> 00:17:57,720
don't typically have conversations along

00:17:55,530 --> 00:17:59,580
the lines of hey the market dynamics

00:17:57,720 --> 00:18:02,610
just changed can you make me a new

00:17:59,580 --> 00:18:04,710
program right now in half an hour from

00:18:02,610 --> 00:18:07,080
now we'll run it live on the market and

00:18:04,710 --> 00:18:08,700
start trading with it very few other

00:18:07,080 --> 00:18:10,710
languages have the capability for that

00:18:08,700 --> 00:18:12,630
sort of response time and I think it's

00:18:10,710 --> 00:18:15,030
one of pythons Kilifi who thinks that's

00:18:12,630 --> 00:18:17,540
awesome all right tweet it from the

00:18:15,030 --> 00:18:20,190
mountaintops

00:18:17,540 --> 00:18:22,919
this is one of my favorites economy of

00:18:20,190 --> 00:18:24,990
expression the code that you see here is

00:18:22,919 --> 00:18:27,059
the refined version of the answer to an

00:18:24,990 --> 00:18:31,559
early exercise and given a training

00:18:27,059 --> 00:18:34,410
class so we have people write some very

00:18:31,559 --> 00:18:36,210
dirt simple Python that does exactly

00:18:34,410 --> 00:18:39,260
this it's designed to show off some of

00:18:36,210 --> 00:18:41,340
the the libraries and to show off

00:18:39,260 --> 00:18:45,150
iteration protocol and that sort of

00:18:41,340 --> 00:18:46,530
thing oh and it has a subtext to it it's

00:18:45,150 --> 00:18:50,130
designed to people convince people that

00:18:46,530 --> 00:18:52,950
python is powerful they have written one

00:18:50,130 --> 00:18:54,690
of their first programs that is more

00:18:52,950 --> 00:18:56,669
than a one or two liner

00:18:54,690 --> 00:18:59,429
and then find themselves what's the

00:18:56,669 --> 00:19:01,529
European term gobsmacked gobsmacked that

00:18:59,429 --> 00:19:04,379
you could do so much with so little cut

00:19:01,529 --> 00:19:05,729
but the thing I like to do is after

00:19:04,379 --> 00:19:07,440
they've written that we come back and we

00:19:05,729 --> 00:19:09,239
refined it a little bit more a little

00:19:07,440 --> 00:19:12,299
bit more throw in a couple more advanced

00:19:09,239 --> 00:19:14,340
tools and then the punchline of the

00:19:12,299 --> 00:19:17,549
exercise is where we go back and compare

00:19:14,340 --> 00:19:19,710
it to the English description of the

00:19:17,549 --> 00:19:21,899
problem and we find that the Python code

00:19:19,710 --> 00:19:23,369
is clearer than the description of the

00:19:21,899 --> 00:19:26,340
problem it's more Cheers and more

00:19:23,369 --> 00:19:28,859
succinct and more importantly there is a

00:19:26,340 --> 00:19:30,690
direct correspondence between the words

00:19:28,859 --> 00:19:33,479
you use in the problem specification any

00:19:30,690 --> 00:19:36,179
more Jesus and by thon so starting from

00:19:33,479 --> 00:19:38,249
the top I am giving someone instructions

00:19:36,179 --> 00:19:39,690
on what I want them to do our overall

00:19:38,249 --> 00:19:44,070
test by the way is we're going to

00:19:39,690 --> 00:19:45,779
analyze some log files to see what which

00:19:44,070 --> 00:19:48,929
resources are most commonly hit on our

00:19:45,779 --> 00:19:51,179
web server so here are my instructions

00:19:48,929 --> 00:19:53,009
to the person I want you to set up a

00:19:51,179 --> 00:19:55,559
tally sheet so you can start counting

00:19:53,009 --> 00:19:57,179
that's what that first line says set up

00:19:55,559 --> 00:19:59,669
a tally sheet so you can start counting

00:19:57,179 --> 00:20:01,559
now I'd like you to go to the data logs

00:19:59,669 --> 00:20:04,889
directory and find all the Jeezy files

00:20:01,559 --> 00:20:07,529
and loop over them line by line that's

00:20:04,889 --> 00:20:09,479
what the second line says keep in mind I

00:20:07,529 --> 00:20:12,509
use more words to describe it in English

00:20:09,479 --> 00:20:13,950
vaguely than I did in Python for as

00:20:12,509 --> 00:20:15,450
described it precisely

00:20:13,950 --> 00:20:17,879
the words in English again work go to

00:20:15,450 --> 00:20:21,119
the data logs directory find all the

00:20:17,879 --> 00:20:24,179
files that end with GC and loop over the

00:20:21,119 --> 00:20:25,950
loop over each of those file names now

00:20:24,179 --> 00:20:30,119
this happen to be gzip files so I do a

00:20:25,950 --> 00:20:31,950
gzip open so open each file i'll gzipped

00:20:30,119 --> 00:20:34,320
and loop over it line by line that's

00:20:31,950 --> 00:20:38,849
what the third line says loop over line

00:20:34,320 --> 00:20:41,840
by line of a gzip file that's a lot of

00:20:38,849 --> 00:20:45,960
economy of expression it's what is it uh

00:20:41,840 --> 00:20:48,509
six words on that line precisely

00:20:45,960 --> 00:20:50,309
describe what is taking place now once

00:20:48,509 --> 00:20:51,840
you've looped over all the lines in the

00:20:50,309 --> 00:20:53,639
log files I'd like you to search each

00:20:51,840 --> 00:20:55,679
line is for something that starts with a

00:20:53,639 --> 00:21:00,179
get ends with an HTTP and have something

00:20:55,679 --> 00:21:03,629
in between if you find it if that's not

00:21:00,179 --> 00:21:06,210
none then consider that group to be a

00:21:03,629 --> 00:21:07,780
URL so the URLs located between the get

00:21:06,210 --> 00:21:10,610
and the HTTP line

00:21:07,780 --> 00:21:15,100
and once you've got the URL count it

00:21:10,610 --> 00:21:18,440
county count counter URL plus equal one

00:21:15,100 --> 00:21:22,580
now take that result and give me the top

00:21:18,440 --> 00:21:25,670
20 hits treating the count as the sort

00:21:22,580 --> 00:21:27,980
key that's all the code it takes to go

00:21:25,670 --> 00:21:30,470
out hop into a directory loop over all

00:21:27,980 --> 00:21:32,360
the log files read the gzip log files

00:21:30,470 --> 00:21:36,110
you don't have to unzip them just read

00:21:32,360 --> 00:21:38,510
them all directly effectively grip over

00:21:36,110 --> 00:21:40,610
them extract a piece of data count them

00:21:38,510 --> 00:21:41,900
up tally em sort them and take them top

00:21:40,610 --> 00:21:44,300
20 and it's actually remarkably

00:21:41,900 --> 00:21:47,060
efficient who thinks that's fantastic

00:21:44,300 --> 00:21:49,520
that is economy of expression and more

00:21:47,060 --> 00:21:51,140
importantly the words here correspond

00:21:49,520 --> 00:21:53,180
very closely to the words in the

00:21:51,140 --> 00:21:54,440
business logic I can take someone

00:21:53,180 --> 00:21:56,360
through this program who has never

00:21:54,440 --> 00:21:57,950
programmed in Python before and they

00:21:56,360 --> 00:22:00,770
walk away reasonably convinced the

00:21:57,950 --> 00:22:02,750
program did exactly what I said I cannot

00:22:00,770 --> 00:22:05,450
do that with a COBOL program I cannot do

00:22:02,750 --> 00:22:06,980
that with APL which I loved APL but I

00:22:05,450 --> 00:22:09,320
couldn't do it with it I couldn't even

00:22:06,980 --> 00:22:10,940
do it with Excel and Excel was designed

00:22:09,320 --> 00:22:12,440
to lay out thoughts in a fairly clear

00:22:10,940 --> 00:22:14,120
pattern but it didn't describe looping

00:22:12,440 --> 00:22:15,050
idioms very well who thinks this is

00:22:14,120 --> 00:22:18,110
fantastic

00:22:15,050 --> 00:22:19,580
economy of expression is one of the

00:22:18,110 --> 00:22:21,560
things going for the language I think

00:22:19,580 --> 00:22:23,510
we've made it as economical as possible

00:22:21,560 --> 00:22:27,530
without venturing into the land of

00:22:23,510 --> 00:22:29,450
unreadable 'ti as was done with APL ok

00:22:27,530 --> 00:22:31,490
beauty counts so one of the things that

00:22:29,450 --> 00:22:34,760
was mentioned when I said why does his

00:22:31,490 --> 00:22:37,010
Python awesome and the answer is

00:22:34,760 --> 00:22:38,390
readability you'll hear people mention

00:22:37,010 --> 00:22:44,150
assault at Mia Python is very readable

00:22:38,390 --> 00:22:45,680
why is that important you think it's

00:22:44,150 --> 00:22:48,610
important for the programmer because it

00:22:45,680 --> 00:22:50,840
makes the language choice to use

00:22:48,610 --> 00:22:53,810
languages that aren't pretty even if

00:22:50,840 --> 00:22:57,560
they're expressive even if they closely

00:22:53,810 --> 00:22:59,750
correspond to the problem domain are not

00:22:57,560 --> 00:23:01,730
as fun to put even if you're good at

00:22:59,750 --> 00:23:05,300
that sale of expression like I really

00:23:01,730 --> 00:23:07,640
enjoyed working with a MATLAB reasonably

00:23:05,300 --> 00:23:11,060
unreasonably proficient expressing

00:23:07,640 --> 00:23:12,710
problems in terms of matrices what I

00:23:11,060 --> 00:23:16,010
have to say MATLAB programs aren't

00:23:12,710 --> 00:23:17,330
beautiful they are succinct in they

00:23:16,010 --> 00:23:19,490
correspond very nicely to the

00:23:17,330 --> 00:23:21,029
mathematical notation but you don't feel

00:23:19,490 --> 00:23:22,289
the same joy as you get

00:23:21,029 --> 00:23:24,779
when you look at a program like that

00:23:22,289 --> 00:23:27,029
which is just so clean and just rolls

00:23:24,779 --> 00:23:29,189
off the fingertips as you write it so

00:23:27,029 --> 00:23:31,439
joy I think is one of the reasons that

00:23:29,189 --> 00:23:33,269
attracts to the language but from a

00:23:31,439 --> 00:23:35,219
manager's point of view or company

00:23:33,269 --> 00:23:37,769
adopting Python the readability counts

00:23:35,219 --> 00:23:39,419
is absolutely essential it's why they've

00:23:37,769 --> 00:23:42,839
come to Python and given up all of their

00:23:39,419 --> 00:23:44,069
bash scripts why would I devote hundreds

00:23:42,839 --> 00:23:45,539
and hundreds of man-hours to having

00:23:44,069 --> 00:23:48,119
someone rewrite all of my bash scripts

00:23:45,539 --> 00:23:49,619
in Python thought is I'm trying to get

00:23:48,119 --> 00:23:51,419
something for that and what I'm getting

00:23:49,619 --> 00:23:53,969
is the readability so that will actually

00:23:51,419 --> 00:23:56,609
be able to maintain those scripts

00:23:53,969 --> 00:23:58,409
readability is fine for yourself as a

00:23:56,609 --> 00:23:59,969
reminder it improves the enjoy the

00:23:58,409 --> 00:24:01,649
programming but it's particularly nice

00:23:59,969 --> 00:24:03,539
when you get to maintaining someone else

00:24:01,649 --> 00:24:06,359
in your code that you have some fighting

00:24:03,539 --> 00:24:09,169
chance of being able to read it so one

00:24:06,359 --> 00:24:11,939
good argument in the favor of that is

00:24:09,169 --> 00:24:15,299
Python ships with its own on source code

00:24:11,939 --> 00:24:17,219
so you can open up the collections

00:24:15,299 --> 00:24:19,079
module and go down and criticize my

00:24:17,219 --> 00:24:20,369
coding style and say Raymond I would

00:24:19,079 --> 00:24:22,409
have never done it this way

00:24:20,369 --> 00:24:24,449
oh my god that was on a nice piece of

00:24:22,409 --> 00:24:26,399
code it's all out there in the open it's

00:24:24,449 --> 00:24:28,169
pretty easy to read and it's an

00:24:26,399 --> 00:24:30,059
educational effort so I recommend highly

00:24:28,169 --> 00:24:32,519
reading a little bit of a source code

00:24:30,059 --> 00:24:34,379
from the standard library it'll make you

00:24:32,519 --> 00:24:36,359
a better programmer and it will

00:24:34,379 --> 00:24:38,249
certainly drive home the one of the

00:24:36,359 --> 00:24:40,139
benefits of readability

00:24:38,249 --> 00:24:42,089
you know the assembly language didn't

00:24:40,139 --> 00:24:44,239
have that so I could go back and look at

00:24:42,089 --> 00:24:46,709
someone else's assembly language code

00:24:44,239 --> 00:24:49,199
the process of reading that code is

00:24:46,709 --> 00:24:51,559
really inactive decryption now to be

00:24:49,199 --> 00:24:54,899
fair a good assembly language programmer

00:24:51,559 --> 00:24:57,569
designs procedure names and comments and

00:24:54,899 --> 00:25:00,299
whatnot to try and decrease the effort

00:24:57,569 --> 00:25:02,639
and so assembly language programs can be

00:25:00,299 --> 00:25:05,639
written in a readable fashion it's just

00:25:02,639 --> 00:25:07,649
they often work so in the hands of a

00:25:05,639 --> 00:25:09,989
good programmer lots of languages can be

00:25:07,649 --> 00:25:11,909
made readable Python just seems to come

00:25:09,989 --> 00:25:14,939
out that way even from bad programmers

00:25:11,909 --> 00:25:16,589
who thinks that's a fantastic feature of

00:25:14,939 --> 00:25:18,389
the language it is one of the number one

00:25:16,589 --> 00:25:21,149
draws when you go around ask people what

00:25:18,389 --> 00:25:23,999
makes Python awesome and one that's not

00:25:21,149 --> 00:25:27,269
mentioned much what comes up when I

00:25:23,999 --> 00:25:29,009
really drill down and ask people what

00:25:27,269 --> 00:25:31,560
meant why did you come to Python from

00:25:29,009 --> 00:25:33,510
Perl what made it

00:25:31,560 --> 00:25:35,250
and it's the one way to do it if you've

00:25:33,510 --> 00:25:37,500
started programming in Python and head

00:25:35,250 --> 00:25:40,920
and worked with a language like Perl

00:25:37,500 --> 00:25:43,620
it's hard to appreciate how could things

00:25:40,920 --> 00:25:45,930
be any different you know isn't this

00:25:43,620 --> 00:25:48,750
just the way you would cook and the

00:25:45,930 --> 00:25:51,240
answer is no Perl and Ruby both share a

00:25:48,750 --> 00:25:52,500
philosophy of many ways to do it they

00:25:51,240 --> 00:25:54,480
actually considered it to be a strengths

00:25:52,500 --> 00:25:57,450
of their community and in their own ways

00:25:54,480 --> 00:25:59,430
those languages are awesome our

00:25:57,450 --> 00:26:02,820
awesomeness is so bleep chose to go on a

00:25:59,430 --> 00:26:04,740
different path and so in Perl there's

00:26:02,820 --> 00:26:07,230
often many different idioms that can be

00:26:04,740 --> 00:26:09,480
used and people fall into a style I do

00:26:07,230 --> 00:26:11,340
some sub scripting into array that

00:26:09,480 --> 00:26:13,230
indexes into something else and I've

00:26:11,340 --> 00:26:15,870
created my own little mini language with

00:26:13,230 --> 00:26:18,630
my mini idioms and other people who

00:26:15,870 --> 00:26:20,700
program like me can read my code but

00:26:18,630 --> 00:26:23,100
there were other paths to go down and if

00:26:20,700 --> 00:26:26,070
you compare two sets of Perl programs

00:26:23,100 --> 00:26:28,350
written by different teams they are so

00:26:26,070 --> 00:26:32,340
different that it becomes a write-only

00:26:28,350 --> 00:26:33,900
language that the team that wrote it can

00:26:32,340 --> 00:26:36,150
read it but if they go over and look at

00:26:33,900 --> 00:26:38,820
something someone else's style this is a

00:26:36,150 --> 00:26:41,430
particularly a tough problem for Lua

00:26:38,820 --> 00:26:44,490
Lewis ships with almost no batteries

00:26:41,430 --> 00:26:46,830
included Lua is an awesome language it

00:26:44,490 --> 00:26:49,110
is lightweight it graphs on to C it is

00:26:46,830 --> 00:26:51,450
the easiest way to graft a scripting

00:26:49,110 --> 00:26:53,640
language on to C so don't get me wrong

00:26:51,450 --> 00:26:55,380
it's awesome but it ships with so few

00:26:53,640 --> 00:26:56,790
batteries included that one of the first

00:26:55,380 --> 00:26:58,770
things you have to do is we implement

00:26:56,790 --> 00:27:00,000
object-oriented programming they give

00:26:58,770 --> 00:27:01,620
you dictionaries that train to one

00:27:00,000 --> 00:27:04,260
another and they give you a dot operator

00:27:01,620 --> 00:27:06,360
after that you build your own and not

00:27:04,260 --> 00:27:08,460
everybody builds it in the same way so

00:27:06,360 --> 00:27:10,530
you quickly build your own language on

00:27:08,460 --> 00:27:13,140
top of Lua because nobody goes in just

00:27:10,530 --> 00:27:14,820
Lua that's naked it's always a building

00:27:13,140 --> 00:27:16,770
up of the libraries and everyone does it

00:27:14,820 --> 00:27:19,140
in a different way meaning that if you

00:27:16,770 --> 00:27:21,660
come to someone else's Lua code and have

00:27:19,140 --> 00:27:23,310
to maintain it you have to recreate

00:27:21,660 --> 00:27:25,440
their whole thought process from the

00:27:23,310 --> 00:27:28,140
ground up to rediscover the language

00:27:25,440 --> 00:27:30,360
that they invented one way to do it is a

00:27:28,140 --> 00:27:32,430
killer feature of the language and yet

00:27:30,360 --> 00:27:34,260
if I survey groups of people for the

00:27:32,430 --> 00:27:36,450
most part it never comes up until we get

00:27:34,260 --> 00:27:38,370
down to brass tacks and really start

00:27:36,450 --> 00:27:40,640
interviewing and say why is this better

00:27:38,370 --> 00:27:43,490
than what you were coding ten years ago

00:27:40,640 --> 00:27:44,750
and let's let's compare the same

00:27:43,490 --> 00:27:46,160
programs written in different language

00:27:44,750 --> 00:27:50,150
its killer feature who thinks it's

00:27:46,160 --> 00:27:51,710
awesome we've got an interactive prompt

00:27:50,150 --> 00:27:53,750
the neat things about this I'd like to

00:27:51,710 --> 00:27:56,809
tell classes and we're starting Python

00:27:53,750 --> 00:27:59,480
experts don't memorize Python I will sit

00:27:56,809 --> 00:28:02,300
down and talk with Alex our cuido

00:27:59,480 --> 00:28:05,000
our Brett and as we discuss the language

00:28:02,300 --> 00:28:06,950
we rediscover for ourselves what it what

00:28:05,000 --> 00:28:10,550
it does and we fire up the interpreter

00:28:06,950 --> 00:28:15,670
it's possible even Arman goes to the

00:28:10,550 --> 00:28:15,670
interpreter RIA discovers what it does I

00:28:15,700 --> 00:28:19,880
think it's a fantastic tool and you

00:28:19,220 --> 00:28:21,620
don't miss it

00:28:19,880 --> 00:28:23,120
you don't realize how significant is

00:28:21,620 --> 00:28:25,309
until you go to another language that

00:28:23,120 --> 00:28:28,580
doesn't have it and then the ability to

00:28:25,309 --> 00:28:30,500
experiment disappears it's a killer

00:28:28,580 --> 00:28:33,230
feature that causes us to run circles

00:28:30,500 --> 00:28:35,000
around compiled languages one because

00:28:33,230 --> 00:28:38,870
it's learnability and we discoverability

00:28:35,000 --> 00:28:41,390
it lets us exercise our own programs our

00:28:38,870 --> 00:28:43,490
early and often the interactive prompt

00:28:41,390 --> 00:28:45,170
can be pushed to extreme limits so you

00:28:43,490 --> 00:28:47,540
can't just use it for helping or to

00:28:45,170 --> 00:28:49,940
quickly run your function R you can wrap

00:28:47,540 --> 00:28:51,500
something out use ipython or V Python

00:28:49,940 --> 00:28:53,780
and it becomes an operating environment

00:28:51,500 --> 00:28:55,940
unto itself and it is not uncommon to

00:28:53,780 --> 00:28:58,940
see a scientific programmer fry up an

00:28:55,940 --> 00:29:01,700
interactive prompt in ipython loaded in

00:28:58,940 --> 00:29:05,600
data sets visualize the data set in

00:29:01,700 --> 00:29:06,890
using matplotlib and to do actively do

00:29:05,600 --> 00:29:08,720
all their manipulations they're not

00:29:06,890 --> 00:29:11,210
really programming so much as they are

00:29:08,720 --> 00:29:13,070
they're using it as a control panel to

00:29:11,210 --> 00:29:14,570
drive the ship from the command line I

00:29:13,070 --> 00:29:15,740
think that's fantastic

00:29:14,570 --> 00:29:17,510
and if you don't have an interactive

00:29:15,740 --> 00:29:19,100
prompt you can't do that the other thing

00:29:17,510 --> 00:29:21,470
you can do with it is you can embed it

00:29:19,100 --> 00:29:24,380
in a larger system so it's a killer

00:29:21,470 --> 00:29:26,000
feature for a tool like a blender where

00:29:24,380 --> 00:29:27,710
they list Python is one of their key

00:29:26,000 --> 00:29:31,280
success characteristics where they've

00:29:27,710 --> 00:29:32,600
exposed all the tools with Python as a

00:29:31,280 --> 00:29:34,550
scripting language and you can either

00:29:32,600 --> 00:29:36,580
drive it directly or you can experiment

00:29:34,550 --> 00:29:39,200
with the tools or you can extend blender

00:29:36,580 --> 00:29:41,300
using the interactive prompt it takes

00:29:39,200 --> 00:29:42,380
those fantastic do you appreciate it

00:29:41,300 --> 00:29:44,720
more now than you used to

00:29:42,380 --> 00:29:47,480
I hope so and then we've often mentioned

00:29:44,720 --> 00:29:50,900
batteries included as a killer feature

00:29:47,480 --> 00:29:52,640
of the language start working with Lua

00:29:50,900 --> 00:29:54,770
you'll miss your batteries right away

00:29:52,640 --> 00:29:55,910
one of the things I've learned to do in

00:29:54,770 --> 00:29:58,280
my Python training

00:29:55,910 --> 00:30:00,080
as I show only a little bit of the core

00:29:58,280 --> 00:30:02,930
language then immediately go to the

00:30:00,080 --> 00:30:04,610
batteries so that people are their first

00:30:02,930 --> 00:30:07,190
experience doesn't feel like when they

00:30:04,610 --> 00:30:09,410
learn to programming at in schools like

00:30:07,190 --> 00:30:11,270
oh I have to take this data type shove

00:30:09,410 --> 00:30:13,010
it around and declare this and arrange

00:30:11,270 --> 00:30:15,470
this look to some people that seems

00:30:13,010 --> 00:30:17,750
meaningless and arcane and an utter

00:30:15,470 --> 00:30:19,310
waste of time and reminds them of the

00:30:17,750 --> 00:30:21,260
worst programming experiences they ever

00:30:19,310 --> 00:30:23,000
had so I like to quickly take them out

00:30:21,260 --> 00:30:25,550
to hey let's load up some of the

00:30:23,000 --> 00:30:28,520
batteries and let's open up this file

00:30:25,550 --> 00:30:30,020
it's got XML in it and I said I promise

00:30:28,520 --> 00:30:31,940
them you won't have to touch a single

00:30:30,020 --> 00:30:35,120
angle bracket or even look at it we'll

00:30:31,940 --> 00:30:38,450
just say traverse the elementary until

00:30:35,120 --> 00:30:40,370
we find recipe slash ingredients and

00:30:38,450 --> 00:30:41,990
then list all of the items in the end up

00:30:40,370 --> 00:30:45,410
with a four line long Python program

00:30:41,990 --> 00:30:47,510
that has parsed an XML file and

00:30:45,410 --> 00:30:49,310
extracted relevant information from it

00:30:47,510 --> 00:30:52,010
then we do something similar pulling

00:30:49,310 --> 00:30:54,020
something down from the web and taking

00:30:52,010 --> 00:30:55,850
beautifulsoup and parsing it up and

00:30:54,020 --> 00:30:58,010
generating some JSON and shoving it over

00:30:55,850 --> 00:30:59,870
to the program and firing up sequel i3

00:30:58,010 --> 00:31:01,430
the batteries included is a killer

00:30:59,870 --> 00:31:03,260
feature of the language and I've learned

00:31:01,430 --> 00:31:05,390
now to lead with that instead of follow

00:31:03,260 --> 00:31:07,220
with it I believe now the wrong way to

00:31:05,390 --> 00:31:07,940
teach Python is to save the batteries

00:31:07,220 --> 00:31:09,980
for last

00:31:07,940 --> 00:31:11,480
it's where the the power plays come from

00:31:09,980 --> 00:31:13,250
and people are very impressed with it at

00:31:11,480 --> 00:31:15,830
the outset and they walk away with a

00:31:13,250 --> 00:31:18,320
newfound respect for the language so who

00:31:15,830 --> 00:31:20,770
wants a language without batteries okay

00:31:18,320 --> 00:31:23,510
so if you're inventing a new language

00:31:20,770 --> 00:31:25,220
let's say you make something you know

00:31:23,510 --> 00:31:28,220
take the first two letters of your

00:31:25,220 --> 00:31:30,230
company's name or this or go that and

00:31:28,220 --> 00:31:32,240
you make this new language what do you

00:31:30,230 --> 00:31:34,960
need to win you need to build some

00:31:32,240 --> 00:31:37,460
batteries you need to build them quick

00:31:34,960 --> 00:31:42,050
okay and then behind the scenes what are

00:31:37,460 --> 00:31:43,700
we doing for you we have a B D F L he

00:31:42,050 --> 00:31:45,740
has made the language the way it is

00:31:43,700 --> 00:31:47,750
today one of the things I like to teach

00:31:45,740 --> 00:31:50,480
early on is in Python just to not argue

00:31:47,750 --> 00:31:52,280
with the language Python is Quito's

00:31:50,480 --> 00:31:56,900
language he happens to be letting you

00:31:52,280 --> 00:31:58,820
use it but it's his so sometimes the

00:31:56,900 --> 00:32:02,060
correct answer to a question is why is

00:31:58,820 --> 00:32:04,670
this thing that way what is a couple

00:32:02,060 --> 00:32:05,930
just a crippled form of a list of that

00:32:04,670 --> 00:32:07,850
happens to have some additional

00:32:05,930 --> 00:32:10,360
capability of being hashable

00:32:07,850 --> 00:32:13,610
is it an immutable list

00:32:10,360 --> 00:32:23,029
nicholae yes but the real answer is No

00:32:13,610 --> 00:32:25,909
why because cuido says so why is this

00:32:23,029 --> 00:32:28,369
important because cuido thinks of tuples

00:32:25,909 --> 00:32:31,039
as a holder for records as a struct type

00:32:28,369 --> 00:32:32,899
in Python so if you accept that and

00:32:31,039 --> 00:32:34,909
don't fight the language if you program

00:32:32,899 --> 00:32:36,739
the Cueto way you program with the grain

00:32:34,909 --> 00:32:38,299
of the language if you program with the

00:32:36,739 --> 00:32:39,710
grain of the language you'll find that

00:32:38,299 --> 00:32:42,739
all the pieces fit together really

00:32:39,710 --> 00:32:44,779
nicely oh every piece I grab grab just

00:32:42,739 --> 00:32:46,489
seems to already fit into the API what

00:32:44,779 --> 00:32:48,820
I'm already working with it's fantastic

00:32:46,489 --> 00:32:51,259
how Python just comes together like that

00:32:48,820 --> 00:32:53,059
but someone else might be fitting pieces

00:32:51,259 --> 00:32:55,909
together they never fit together they're

00:32:53,059 --> 00:32:58,279
not programming with the grandeur of the

00:32:55,909 --> 00:33:01,100
language just a quick little anecdote

00:32:58,279 --> 00:33:02,899
who's ever played Sim City all right so

00:33:01,100 --> 00:33:04,450
there was some hidden logic inside that

00:33:02,899 --> 00:33:07,369
I thought was kind of interesting

00:33:04,450 --> 00:33:09,799
thank you play Sim City for a long time

00:33:07,369 --> 00:33:11,749
and just rarely get a tornado or a

00:33:09,799 --> 00:33:14,029
dragon or whatnot coming through my city

00:33:11,749 --> 00:33:17,090
there are other people who they could

00:33:14,029 --> 00:33:19,100
come play on my computer and right away

00:33:17,090 --> 00:33:21,590
they would be hit with the tornado every

00:33:19,100 --> 00:33:25,039
year what were they doing wrong there

00:33:21,590 --> 00:33:27,049
was a hidden rule in the game if you

00:33:25,039 --> 00:33:28,669
were the cut one of the types of

00:33:27,049 --> 00:33:30,590
buildings that would show up as a church

00:33:28,669 --> 00:33:31,970
and in order to redistricting area

00:33:30,590 --> 00:33:34,730
you needed to bulldoze down what was

00:33:31,970 --> 00:33:39,409
there he who bulldoze churches incurred

00:33:34,730 --> 00:33:42,200
the wrath of God and not immediately but

00:33:39,409 --> 00:33:44,840
later you would get one tornado one fire

00:33:42,200 --> 00:33:48,080
one hurricane after another why is this

00:33:44,840 --> 00:33:50,899
important if you program the cuido way

00:33:48,080 --> 00:33:53,109
everything will just work for you if you

00:33:50,899 --> 00:33:53,109
don't

00:33:54,060 --> 00:34:00,700
okay what four other successful no

00:33:58,570 --> 00:34:02,860
weekend we're going to get progressively

00:34:00,700 --> 00:34:05,200
more technical as we go along protocols

00:34:02,860 --> 00:34:06,550
it sounds very technical it's one of the

00:34:05,200 --> 00:34:07,720
things I think the language is done

00:34:06,550 --> 00:34:10,180
right and one of the things that is

00:34:07,720 --> 00:34:11,440
underappreciated and there are some

00:34:10,180 --> 00:34:13,300
people in the audience have contributed

00:34:11,440 --> 00:34:16,690
heavily to the things that python has

00:34:13,300 --> 00:34:19,270
done right on this page one is we make

00:34:16,690 --> 00:34:21,610
protocols protocol is in my mind is

00:34:19,270 --> 00:34:24,400
essentially an API that applies to

00:34:21,610 --> 00:34:26,320
multiple tools in exactly the same way

00:34:24,400 --> 00:34:28,330
it's fantastic it's one of the things

00:34:26,320 --> 00:34:31,450
that makes Python easier to learn and

00:34:28,330 --> 00:34:33,670
fun to use so there was a database API

00:34:31,450 --> 00:34:36,400
specification two of them as a matter of

00:34:33,670 --> 00:34:38,230
fact ppapi two is the current one it

00:34:36,400 --> 00:34:42,010
provides a common interface to many

00:34:38,230 --> 00:34:43,660
varieties of SQL it's fantastic it is

00:34:42,010 --> 00:34:45,160
really nice to be able to switch

00:34:43,660 --> 00:34:46,960
versions of sequel and I have to change

00:34:45,160 --> 00:34:48,400
your underlying Python sometimes you

00:34:46,960 --> 00:34:50,620
have to update your select statements

00:34:48,400 --> 00:34:53,380
and whatnot to accommodate the dialect

00:34:50,620 --> 00:34:57,360
but the the Python interface is the same

00:34:53,380 --> 00:35:01,240
it's fantastic learn once right many

00:34:57,360 --> 00:35:03,130
Ashley use md5 later you can change the

00:35:01,240 --> 00:35:05,470
md5 to a sha-1 and you don't have to

00:35:03,130 --> 00:35:08,830
change anything else in your cook all

00:35:05,470 --> 00:35:10,690
the hash buffers all have the same API

00:35:08,830 --> 00:35:12,190
which is kind of neat given that they

00:35:10,690 --> 00:35:15,130
were written by different people at

00:35:12,190 --> 00:35:16,990
different times in pythons a history the

00:35:15,130 --> 00:35:18,970
protocols are working for us compression

00:35:16,990 --> 00:35:22,630
interfaces we started out with an

00:35:18,970 --> 00:35:25,120
interface for gzip and seal it but when

00:35:22,630 --> 00:35:27,640
XZ goes in guess what it's going to be

00:35:25,120 --> 00:35:29,440
identical in its interface it's

00:35:27,640 --> 00:35:31,720
fantastic a lot of these things can be

00:35:29,440 --> 00:35:34,120
taught in minutes now instead of days

00:35:31,720 --> 00:35:36,220
because there's one protocol to bind

00:35:34,120 --> 00:35:39,630
them all the conversion protocols

00:35:36,220 --> 00:35:42,070
I teach pickle here's a loads and dumps

00:35:39,630 --> 00:35:43,360
people got that locked in their mind how

00:35:42,070 --> 00:35:47,370
long do you think it takes me to cheat

00:35:43,360 --> 00:35:50,620
the interface to Jason our Marshall I

00:35:47,370 --> 00:35:51,760
long it off take seconds basically it's

00:35:50,620 --> 00:35:53,770
the same thing as pickle but that pickle

00:35:51,760 --> 00:35:57,970
anymore just a different underlying data

00:35:53,770 --> 00:36:00,010
format okay a huge huge huge huge step

00:35:57,970 --> 00:36:04,030
forward for Python what's the

00:36:00,010 --> 00:36:05,029
introduction of the whiskey protocol who

00:36:04,030 --> 00:36:07,699
knows

00:36:05,029 --> 00:36:08,779
how significant that raised your hand if

00:36:07,699 --> 00:36:11,630
you think that was just majorly

00:36:08,779 --> 00:36:13,609
significant if I thought okay those of

00:36:11,630 --> 00:36:15,409
you who raised your hand are those who

00:36:13,609 --> 00:36:17,689
remember how it was before there were

00:36:15,409 --> 00:36:19,909
many many many web servers there were

00:36:17,689 --> 00:36:22,039
many many many many web frameworks and

00:36:19,909 --> 00:36:24,259
there still are what's different is they

00:36:22,039 --> 00:36:27,439
didn't talk to one another if you chose

00:36:24,259 --> 00:36:29,719
a web right mark it dictated and

00:36:27,439 --> 00:36:30,289
somewhat restricted your choices of web

00:36:29,719 --> 00:36:32,539
server

00:36:30,289 --> 00:36:34,489
are the other way around if you had a

00:36:32,539 --> 00:36:35,900
web server you had a limited choice of

00:36:34,489 --> 00:36:38,599
all web frameworks you didn't switch

00:36:35,900 --> 00:36:40,579
this was the one ring to bind them all

00:36:38,599 --> 00:36:43,219
but from all together a common interface

00:36:40,579 --> 00:36:45,289
it was fantastic for Python if you do

00:36:43,219 --> 00:36:47,329
any sort of web development whether you

00:36:45,289 --> 00:36:49,309
know about whiskey or not you benefit

00:36:47,329 --> 00:36:51,769
from it every day it makes Python

00:36:49,309 --> 00:36:55,459
awesome and then last is things like the

00:36:51,769 --> 00:36:58,309
file API the open readwrite reline that

00:36:55,459 --> 00:36:59,989
works for real files during i/o there's

00:36:58,309 --> 00:37:02,989
an amazing number of objects that follow

00:36:59,989 --> 00:37:04,579
exactly that API and so Python is a

00:37:02,989 --> 00:37:07,429
language where I can teach a handful of

00:37:04,579 --> 00:37:08,749
api's and cause people to learn most of

00:37:07,429 --> 00:37:11,199
the language as a whole who thinks

00:37:08,749 --> 00:37:13,759
that's fantastic who thinks it's awesome

00:37:11,199 --> 00:37:15,319
thinks it's not like see where all the

00:37:13,759 --> 00:37:16,729
libraries were developed by different

00:37:15,319 --> 00:37:18,859
groups of people had different notions

00:37:16,729 --> 00:37:20,269
of the interface every see library you

00:37:18,859 --> 00:37:22,369
picked up unless it's developed by the

00:37:20,269 --> 00:37:23,959
same company sometimes even if it was

00:37:22,369 --> 00:37:26,079
developed by the same company had

00:37:23,959 --> 00:37:29,059
radically different api's or underlying

00:37:26,079 --> 00:37:31,729
context Maps we had we learn how those

00:37:29,059 --> 00:37:33,499
people fought about the world and heaven

00:37:31,729 --> 00:37:37,069
help you if you had to interface to

00:37:33,499 --> 00:37:39,349
different api's what did you do the

00:37:37,069 --> 00:37:40,429
adapter pattern was born the pieces

00:37:39,349 --> 00:37:41,900
didn't fit together then you had to

00:37:40,429 --> 00:37:44,359
write an adapter for every two pieces

00:37:41,900 --> 00:37:46,369
you put together these are it's kind of

00:37:44,359 --> 00:37:47,869
like one of fish swims in water you ask

00:37:46,369 --> 00:37:50,089
them the characteristics of water they

00:37:47,869 --> 00:37:52,130
forgot you swim in water every day and

00:37:50,089 --> 00:37:53,509
benefit from the existence of these

00:37:52,130 --> 00:37:56,029
protocols whether you know it or not

00:37:53,509 --> 00:37:58,729
made Python much easier to learn much

00:37:56,029 --> 00:38:01,579
easier to scale up so somebody these are

00:37:58,729 --> 00:38:03,409
high-level qualities of Python that I go

00:38:01,579 --> 00:38:05,359
into a management company and say these

00:38:03,409 --> 00:38:06,919
are the reasons use of value Python it's

00:38:05,359 --> 00:38:08,509
easy to learn I can get your programmers

00:38:06,919 --> 00:38:10,249
up to speed fast they'll have a rapid

00:38:08,509 --> 00:38:12,249
development cycle there's an economy of

00:38:10,249 --> 00:38:14,659
expression more importantly not just

00:38:12,249 --> 00:38:16,789
economical but it corresponds to the

00:38:14,659 --> 00:38:17,850
business logic it's readable and it's

00:38:16,789 --> 00:38:19,650
beautiful so your

00:38:17,850 --> 00:38:21,090
we'll enjoy programming in it and they

00:38:19,650 --> 00:38:23,940
won't hate you as much if they have to

00:38:21,090 --> 00:38:26,970
maintain someone else's code having one

00:38:23,940 --> 00:38:28,440
way to do it is a fantastic thing for

00:38:26,970 --> 00:38:31,200
Python it means we can look at each

00:38:28,440 --> 00:38:33,600
other's code and not immediately have

00:38:31,200 --> 00:38:35,670
our jaw drop in our face twist in pain

00:38:33,600 --> 00:38:37,380
the batteries included means you're

00:38:35,670 --> 00:38:39,090
productive right out of the box every

00:38:37,380 --> 00:38:41,310
distribution includes enough batteries

00:38:39,090 --> 00:38:43,770
together to do powerful effective things

00:38:41,310 --> 00:38:46,530
right away but behind the scenes were

00:38:43,770 --> 00:38:48,690
doing how to takes care of you having it

00:38:46,530 --> 00:38:50,250
beat Quito's language having him make

00:38:48,690 --> 00:38:50,700
pronouncements having it done in his

00:38:50,250 --> 00:38:52,860
image

00:38:50,700 --> 00:38:55,500
unifies the language in the way that

00:38:52,860 --> 00:38:58,950
some other languages are not Linux has

00:38:55,500 --> 00:39:01,260
benefited from Linus making decisions at

00:38:58,950 --> 00:39:03,210
the top a number of tools have benefited

00:39:01,260 --> 00:39:04,830
from having a single person's vision

00:39:03,210 --> 00:39:06,840
implemented by multiple people and

00:39:04,830 --> 00:39:08,190
lastly the common protocols who thinks

00:39:06,840 --> 00:39:13,920
all these things make Python an

00:39:08,190 --> 00:39:16,890
incredibly awesome language ok so a

00:39:13,920 --> 00:39:18,810
question arises could I possibly have

00:39:16,890 --> 00:39:20,760
been describing any other language here

00:39:18,810 --> 00:39:22,350
could I have substituted the word Python

00:39:20,760 --> 00:39:25,530
for small talk gone to a small talk

00:39:22,350 --> 00:39:28,680
conference and given most of these these

00:39:25,530 --> 00:39:29,880
points some of them would apply as I

00:39:28,680 --> 00:39:31,650
mentioned earlier I think a lot of these

00:39:29,880 --> 00:39:33,450
other languages I mentioned are awesome

00:39:31,650 --> 00:39:34,800
and awesome in their own ways and some

00:39:33,450 --> 00:39:36,420
of them are awesome in some of the same

00:39:34,800 --> 00:39:39,420
way so a lot of these apply to multiple

00:39:36,420 --> 00:39:41,010
tools so let's get to things that are

00:39:39,420 --> 00:39:42,480
unique to Python that is actually the

00:39:41,010 --> 00:39:44,840
core language itself ready for the

00:39:42,480 --> 00:39:47,040
technical part of the top all right

00:39:44,840 --> 00:39:48,540
we're going to build our own language we

00:39:47,040 --> 00:39:51,410
need to start with a foundation

00:39:48,540 --> 00:39:53,610
what would quita say be a foundation is

00:39:51,410 --> 00:39:55,230
one of the most important things to him

00:39:53,610 --> 00:39:57,630
based on my conversations with them is

00:39:55,230 --> 00:39:59,940
that the core objects are dictionaries

00:39:57,630 --> 00:40:01,920
and lists now keep in mind I wrote sets

00:39:59,940 --> 00:40:04,320
and I didn't include sets on the list

00:40:01,920 --> 00:40:06,090
because dictionaries and lists are even

00:40:04,320 --> 00:40:08,760
more fundamental armed with just those

00:40:06,090 --> 00:40:12,120
you can solve an enormous number of

00:40:08,760 --> 00:40:14,040
problems as well as these where you can

00:40:12,120 --> 00:40:16,020
put dictionaries and lists in the hands

00:40:14,040 --> 00:40:18,120
of beginners teach them how to navigate

00:40:16,020 --> 00:40:20,160
trees of dictionaries and trees of lists

00:40:18,120 --> 00:40:22,050
and at that point they are as empowered

00:40:20,160 --> 00:40:24,030
as some computer science majors who've

00:40:22,050 --> 00:40:27,720
studied

00:40:24,030 --> 00:40:28,740
computing for several years it is if

00:40:27,720 --> 00:40:30,390
you're going to build your own language

00:40:28,740 --> 00:40:32,190
at a foundation he needs

00:40:30,390 --> 00:40:34,319
in lists one of the reasons I loved awk

00:40:32,190 --> 00:40:36,660
it had associative arrays back when

00:40:34,319 --> 00:40:39,210
nothing else did I could get some of the

00:40:36,660 --> 00:40:41,250
power of dictionaries and lists

00:40:39,210 --> 00:40:44,160
available to me just like that it's why

00:40:41,250 --> 00:40:45,900
awk was so expressive we don't learn

00:40:44,160 --> 00:40:47,910
that from ABC he brought it into Python

00:40:45,900 --> 00:40:49,829
next thing you need is automatic memory

00:40:47,910 --> 00:40:52,430
management breath counting is an

00:40:49,829 --> 00:40:54,990
essential it can be done with the GC oh

00:40:52,430 --> 00:40:57,960
the important thing is you're not doing

00:40:54,990 --> 00:40:59,339
a specific Malick's and freeze who's

00:40:57,960 --> 00:41:01,740
ever lived in that world for a while

00:40:59,339 --> 00:41:04,079
knows it's a very powerful tool it's

00:41:01,740 --> 00:41:08,039
very fast it's also very painful when

00:41:04,079 --> 00:41:09,390
something goes wrong so if you've never

00:41:08,039 --> 00:41:11,250
dealt with one of those languages you

00:41:09,390 --> 00:41:12,690
really don't know how good you have it

00:41:11,250 --> 00:41:17,299
but it's fantastic

00:41:12,690 --> 00:41:19,920
and then exceptions I was reading a

00:41:17,299 --> 00:41:22,769
follow-on to the little schemer little

00:41:19,920 --> 00:41:23,910
lisper and it was the second book I

00:41:22,769 --> 00:41:26,130
think it may have even been written in

00:41:23,910 --> 00:41:28,140
the context of ml and it argued that

00:41:26,130 --> 00:41:30,089
beyond all the recursive capabilities

00:41:28,140 --> 00:41:32,460
one of the greatest things that was ever

00:41:30,089 --> 00:41:34,680
added to that language was exceptions

00:41:32,460 --> 00:41:37,440
exceptions are the ability to do

00:41:34,680 --> 00:41:41,400
non-local jumps like a go-to or like a

00:41:37,440 --> 00:41:43,259
long jump but in a structured way it has

00:41:41,400 --> 00:41:46,200
fantastic capability to the language

00:41:43,259 --> 00:41:48,230
where you can hop up to whatever you can

00:41:46,200 --> 00:41:50,700
raise an exception and throw it up

00:41:48,230 --> 00:41:52,589
knowing that many layers up it'll be

00:41:50,700 --> 00:41:54,809
handled by the thing that knows how to

00:41:52,589 --> 00:41:57,539
handle it without having to write

00:41:54,809 --> 00:41:59,519
convoluted unstructured logic it is a

00:41:57,539 --> 00:42:01,380
beautiful thing for a language there are

00:41:59,519 --> 00:42:03,109
other ways to do it my wife is a VB

00:42:01,380 --> 00:42:06,869
programmer they have their own

00:42:03,109 --> 00:42:08,490
techniques some of which allow resuming

00:42:06,869 --> 00:42:11,099
the code that raises the exception so

00:42:08,490 --> 00:42:12,750
it's not a straight win but it's a fine

00:42:11,099 --> 00:42:15,059
thing to add to the language and then

00:42:12,750 --> 00:42:17,130
making things of a first-class like

00:42:15,059 --> 00:42:18,259
function so that you can pass functions

00:42:17,130 --> 00:42:20,720
as arguments

00:42:18,259 --> 00:42:24,269
whoever's have a read Joel on software

00:42:20,720 --> 00:42:27,210
so one of his fantastic articles is can

00:42:24,269 --> 00:42:28,799
your language do this and he is talking

00:42:27,210 --> 00:42:32,039
about the notion of functions being

00:42:28,799 --> 00:42:34,170
first-class and describes the compelling

00:42:32,039 --> 00:42:38,700
advantages of it I recommend the article

00:42:34,170 --> 00:42:41,069
highly it is amazing to me when my wife

00:42:38,700 --> 00:42:43,170
and I whiteboard some of her code okay

00:42:41,069 --> 00:42:43,920
well you just oh wait you can't do that

00:42:43,170 --> 00:42:45,960
in VB

00:42:43,920 --> 00:42:47,670
you can't pass a function around you

00:42:45,960 --> 00:42:49,079
can't create a new function on the

00:42:47,670 --> 00:42:52,200
things you can't do with the collection

00:42:49,079 --> 00:42:54,180
objects it's just incredibly painful

00:42:52,200 --> 00:42:56,329
it does have some other incredibly

00:42:54,180 --> 00:43:00,059
powerful features that are useful for

00:42:56,329 --> 00:43:03,180
her but you really notice this stuff

00:43:00,059 --> 00:43:04,200
when it's gone and then lastly I don't

00:43:03,180 --> 00:43:06,150
know that everybody else would consider

00:43:04,200 --> 00:43:07,829
this to be part of the foundation but

00:43:06,150 --> 00:43:10,109
I've done enough work with the core to

00:43:07,829 --> 00:43:13,829
know that really part of our success was

00:43:10,109 --> 00:43:16,160
over writable syntax that brackets

00:43:13,829 --> 00:43:18,559
correspond to under get item dot

00:43:16,160 --> 00:43:21,540
corresponds under to get attribute add

00:43:18,559 --> 00:43:24,950
correspond the plus corresponds to an

00:43:21,540 --> 00:43:27,359
under under add because of this design

00:43:24,950 --> 00:43:30,380
we're able to generate code that

00:43:27,359 --> 00:43:32,730
whenever it sees one of these pieces

00:43:30,380 --> 00:43:34,829
executes one of the methods on the right

00:43:32,730 --> 00:43:36,750
meaning that we put almost no

00:43:34,829 --> 00:43:38,160
intelligence inside the brackets no

00:43:36,750 --> 00:43:40,470
intelligence inside the dot no

00:43:38,160 --> 00:43:41,490
intelligence inside the plus this is

00:43:40,470 --> 00:43:43,410
fantastic

00:43:41,490 --> 00:43:45,299
means that all the good stuff in the

00:43:43,410 --> 00:43:48,059
language is all done down at the level

00:43:45,299 --> 00:43:49,920
of individual objects in fact when new

00:43:48,059 --> 00:43:51,990
style classes came along we took lots of

00:43:49,920 --> 00:43:59,599
things that were hardwired like the old

00:43:51,990 --> 00:43:59,599
that says -15 I have negative 15 minutes

00:44:00,410 --> 00:44:06,569
okay so over writable syntax the

00:44:04,799 --> 00:44:08,670
significance of it is it dramatically

00:44:06,569 --> 00:44:10,710
simplified the implementations language

00:44:08,670 --> 00:44:12,690
as people in here who've worked on other

00:44:10,710 --> 00:44:15,720
information implementations can attest

00:44:12,690 --> 00:44:17,880
it probably simplified their lives quite

00:44:15,720 --> 00:44:19,559
a bit too all the details are down in

00:44:17,880 --> 00:44:23,549
the objects what lets you extend the

00:44:19,559 --> 00:44:25,109
language and customize it I would say if

00:44:23,549 --> 00:44:26,970
you're building your own language you

00:44:25,109 --> 00:44:29,880
need to have these five things in order

00:44:26,970 --> 00:44:31,559
to have a solid foundation so those are

00:44:29,880 --> 00:44:35,670
our basic wins quitter went out and

00:44:31,559 --> 00:44:39,869
grabbed some basic essentials that made

00:44:35,670 --> 00:44:43,049
Python usable back in 1990 okay it's

00:44:39,869 --> 00:44:45,349
true classes came slightly later classes

00:44:43,049 --> 00:44:47,790
were grafted on to the language but are

00:44:45,349 --> 00:44:50,460
long before probably most of you saw

00:44:47,790 --> 00:44:53,700
Python so this is a solid foundation

00:44:50,460 --> 00:44:54,540
these are things that make get Python a

00:44:53,700 --> 00:44:59,190
tremendous amount of

00:44:54,540 --> 00:45:01,830
power so could we do any better with

00:44:59,190 --> 00:45:05,850
that context I've given you with the

00:45:01,830 --> 00:45:07,470
readability with the community with this

00:45:05,850 --> 00:45:09,390
solid foundation of dictionaries and

00:45:07,470 --> 00:45:12,450
lists we should have a winning language

00:45:09,390 --> 00:45:16,590
can we go further and the answer is yes

00:45:12,450 --> 00:45:18,410
this is a about where Python was a

00:45:16,590 --> 00:45:21,020
decade ago

00:45:18,410 --> 00:45:23,580
twelve years ago right in that range

00:45:21,020 --> 00:45:25,350
we've had some significant wins since

00:45:23,580 --> 00:45:27,120
then we've done some cool stuff we've

00:45:25,350 --> 00:45:28,770
steps stepped into some pace and watch

00:45:27,120 --> 00:45:31,020
you some great tools would you like to

00:45:28,770 --> 00:45:32,910
see what they are I think one of the

00:45:31,020 --> 00:45:35,490
number one killer features the language

00:45:32,910 --> 00:45:37,110
is the iterator protocol it is the high

00:45:35,490 --> 00:45:38,670
level glue that connects the language

00:45:37,110 --> 00:45:40,500
together we have a long list of things

00:45:38,670 --> 00:45:42,330
that are interval strings list set

00:45:40,500 --> 00:45:44,700
sticks collection Ares files open URL

00:45:42,330 --> 00:45:46,740
CSV readers inter tools yada yada yada

00:45:44,700 --> 00:45:49,680
yada yada we also have things that

00:45:46,740 --> 00:45:53,400
consume iterators for loops primarily

00:45:49,680 --> 00:45:55,800
min Max sorted some set list uh

00:45:53,400 --> 00:45:57,420
political hey wait some of those things

00:45:55,800 --> 00:45:59,730
on the second list are on the first list

00:45:57,420 --> 00:46:01,020
are you saying I can take the output of

00:45:59,730 --> 00:46:02,730
one of these and feed it into another

00:46:01,020 --> 00:46:04,950
yes in fact we can string them together

00:46:02,730 --> 00:46:07,500
some of the more impressive one-liners

00:46:04,950 --> 00:46:08,520
in Python really have to do with I open

00:46:07,500 --> 00:46:10,950
something that would up that was

00:46:08,520 --> 00:46:15,750
iterable let's say that gzip file I

00:46:10,950 --> 00:46:18,030
passed it to something else that handled

00:46:15,750 --> 00:46:20,040
an interval I can pass something in to

00:46:18,030 --> 00:46:22,290
set which I can pass to sorted which I

00:46:20,040 --> 00:46:25,230
can Pat turn to lists which I can hand a

00:46:22,290 --> 00:46:26,700
P print and do all that in one line and

00:46:25,230 --> 00:46:29,610
our goal in Python is not fit things

00:46:26,700 --> 00:46:31,830
onto one line our goal is to make pieces

00:46:29,610 --> 00:46:33,510
that connect together easily and we find

00:46:31,830 --> 00:46:35,910
that the glue that connects all these

00:46:33,510 --> 00:46:38,490
parts together is the iterator protocol

00:46:35,910 --> 00:46:40,230
sorted was not intentionally designed to

00:46:38,490 --> 00:46:43,020
make something that could flow into set

00:46:40,230 --> 00:46:45,420
or vice-versa but you can do set on an

00:46:43,020 --> 00:46:46,980
input and unique if I eliminate all the

00:46:45,420 --> 00:46:48,720
duplicates and take the output of that

00:46:46,980 --> 00:46:50,400
and feed it to sorted I think it's

00:46:48,720 --> 00:46:51,840
fantastic two tools that weren't

00:46:50,400 --> 00:46:52,920
originally designed to work with each

00:46:51,840 --> 00:46:55,440
other fit together neatly

00:46:52,920 --> 00:46:56,520
it's iterators that do do that and if

00:46:55,440 --> 00:46:58,740
you start chaining them together you

00:46:56,520 --> 00:47:00,810
realize hey these fit together a lot

00:46:58,740 --> 00:47:02,160
like UNIX pipes and filters you can be

00:47:00,810 --> 00:47:03,630
one of the many many people if they

00:47:02,160 --> 00:47:06,270
you're the first person who said this

00:47:03,630 --> 00:47:07,840
idea I'm going to reprogram Python to

00:47:06,270 --> 00:47:09,610
have pipes and filters

00:47:07,840 --> 00:47:11,860
type syntax and it's actually not that

00:47:09,610 --> 00:47:13,720
hard of an exercise to do the important

00:47:11,860 --> 00:47:15,460
thing is the same power that you get of

00:47:13,720 --> 00:47:17,260
UNIX file types and filters

00:47:15,460 --> 00:47:19,450
you also get out of the iterator

00:47:17,260 --> 00:47:21,250
protocol I think it's one of its number

00:47:19,450 --> 00:47:23,290
one killer detail language features you

00:47:21,250 --> 00:47:27,430
with me are you tweeting from the

00:47:23,290 --> 00:47:30,820
mountaintops no what is the most popular

00:47:27,430 --> 00:47:33,010
language feature arguably its list

00:47:30,820 --> 00:47:35,170
comprehensions especially when teaching

00:47:33,010 --> 00:47:38,650
like the people love was comprehensions

00:47:35,170 --> 00:47:41,350
i think they're uh they're great they

00:47:38,650 --> 00:47:42,910
were derived from a notation using

00:47:41,350 --> 00:47:45,370
mathematics they're very clean and

00:47:42,910 --> 00:47:46,960
beautiful looking you know one of the

00:47:45,370 --> 00:47:48,670
challenges with them is this easy to get

00:47:46,960 --> 00:47:51,100
carried away and have it hard time

00:47:48,670 --> 00:47:53,260
fitting it all on one line but aside

00:47:51,100 --> 00:47:55,240
from the length issue it's a very

00:47:53,260 --> 00:47:57,310
beautiful syntax and it's much more

00:47:55,240 --> 00:47:59,440
flexible than the alternatives using map

00:47:57,310 --> 00:48:01,330
filter and reduce where you find

00:47:59,440 --> 00:48:02,500
yourself importing the operator module

00:48:01,330 --> 00:48:05,080
and you do some rather awkward

00:48:02,500 --> 00:48:07,150
constructions to do expressions that are

00:48:05,080 --> 00:48:10,000
non simple if you're just mapping add

00:48:07,150 --> 00:48:11,320
across two vectors senso so that if you

00:48:10,000 --> 00:48:13,300
actually have to take a whole formula

00:48:11,320 --> 00:48:15,460
and map it across it's really nice to be

00:48:13,300 --> 00:48:17,560
able to do that with list comprehensions

00:48:15,460 --> 00:48:23,140
people love list comprehensions

00:48:17,560 --> 00:48:25,000
I love generators I think generators are

00:48:23,140 --> 00:48:26,920
the easiest way to write a interpreter

00:48:25,000 --> 00:48:28,350
now we decide that iterators with the

00:48:26,920 --> 00:48:31,330
glue that held the language together

00:48:28,350 --> 00:48:33,700
problem is they're no fun to write make

00:48:31,330 --> 00:48:35,800
a class that is an iterator class I have

00:48:33,700 --> 00:48:38,200
to define editor hitter app to define

00:48:35,800 --> 00:48:40,150
next have to do tune it every time I do

00:48:38,200 --> 00:48:41,710
any interesting operation I have to pull

00:48:40,150 --> 00:48:43,990
back my state variables and remember

00:48:41,710 --> 00:48:45,490
where I left off that's no fun these

00:48:43,990 --> 00:48:48,490
things that are no fun become trivial

00:48:45,490 --> 00:48:50,050
easy to read easy to write and something

00:48:48,490 --> 00:48:52,060
I could teach to Python programmers on

00:48:50,050 --> 00:48:53,860
their second day of learning Python and

00:48:52,060 --> 00:48:56,110
they can be writing generators I think

00:48:53,860 --> 00:48:58,150
that's fantastic what art it take to add

00:48:56,110 --> 00:49:01,000
it only one keyword the word in this

00:48:58,150 --> 00:49:03,190
field it was a fantastic addition to the

00:49:01,000 --> 00:49:05,350
language and it has superpowers when

00:49:03,190 --> 00:49:07,060
you've learned generators you're like

00:49:05,350 --> 00:49:10,600
okay I can write iterator very quick you

00:49:07,060 --> 00:49:14,610
can file it away but if you like Armen

00:49:10,600 --> 00:49:16,930
or Chris or number of Alex the number of

00:49:14,610 --> 00:49:19,090
wisenheimers like no it does something

00:49:16,930 --> 00:49:20,980
even more magical than that these things

00:49:19,090 --> 00:49:23,770
freeze program execution

00:49:20,980 --> 00:49:25,690
whenever you yield they remember all of

00:49:23,770 --> 00:49:27,339
their local variables they remember the

00:49:25,690 --> 00:49:29,650
execution pointer and they remember all

00:49:27,339 --> 00:49:31,660
of their open I'm in the middle of a for

00:49:29,650 --> 00:49:34,450
loop and I'm in the middle of multiple

00:49:31,660 --> 00:49:36,670
tries and accepts it remembers all that

00:49:34,450 --> 00:49:38,560
and is resumable which leads you to say

00:49:36,670 --> 00:49:41,650
hey I could do all my cool computer

00:49:38,560 --> 00:49:44,440
science stuff I can write co-routines I

00:49:41,650 --> 00:49:47,710
can implement twisted in line generators

00:49:44,440 --> 00:49:49,599
all kinds of fantastic capabilities as

00:49:47,710 --> 00:49:51,820
sue from its ability to remember its

00:49:49,599 --> 00:49:54,700
state and then resume later who thinks

00:49:51,820 --> 00:49:57,609
that's fantastic it is not just a

00:49:54,700 --> 00:49:59,440
language feature that is pretty it is a

00:49:57,609 --> 00:50:04,359
technological marvel and we can think of

00:49:59,440 --> 00:50:07,089
being for it okay so winning language

00:50:04,359 --> 00:50:10,510
feature what is the logical for a

00:50:07,089 --> 00:50:13,930
lovechild of list comprehensions and

00:50:10,510 --> 00:50:15,910
generators well it would be a generator

00:50:13,930 --> 00:50:19,240
expressions that comprehensions dis

00:50:15,910 --> 00:50:22,359
comprehension see this is what Fineman

00:50:19,240 --> 00:50:23,980
would call ordinary genius any ordinary

00:50:22,359 --> 00:50:25,260
genius could have said hey I could take

00:50:23,980 --> 00:50:28,329
these two things and stick them together

00:50:25,260 --> 00:50:30,790
one way or another whoa we were going to

00:50:28,329 --> 00:50:31,900
get there it was obvious both things

00:50:30,790 --> 00:50:33,819
were very useful and needed to be

00:50:31,900 --> 00:50:36,220
married up and so now we have this

00:50:33,819 --> 00:50:40,210
beautiful syntax for generators and sets

00:50:36,220 --> 00:50:42,550
and and dicks okay that was ordinary

00:50:40,210 --> 00:50:44,140
genius what is extraordinary genius

00:50:42,550 --> 00:50:45,339
extraordinary genius is where you're not

00:50:44,140 --> 00:50:47,050
just combining together existing

00:50:45,339 --> 00:50:49,960
features you're doing something new and

00:50:47,050 --> 00:50:54,400
wonderful I think one of those is

00:50:49,960 --> 00:50:56,140
decorators decorators took a certain

00:50:54,400 --> 00:50:58,089
amount of genius because it was not

00:50:56,140 --> 00:50:59,050
obvious that it was the right thing to

00:50:58,089 --> 00:51:01,000
do for the language there was

00:50:59,050 --> 00:51:02,619
considerable debate about it there were

00:51:01,000 --> 00:51:05,859
a couple pieces of syntax floating

00:51:02,619 --> 00:51:09,339
around we did was convinced to put them

00:51:05,859 --> 00:51:13,119
in because a couple of tools needed them

00:51:09,339 --> 00:51:15,040
and how they did a lot of function in a

00:51:13,119 --> 00:51:16,630
function function wrapping a function

00:51:15,040 --> 00:51:18,880
wrapping a function type thing and they

00:51:16,630 --> 00:51:20,440
really needed it for usability and

00:51:18,880 --> 00:51:23,500
essentially this was going to be a

00:51:20,440 --> 00:51:25,599
concession to them to simplify their

00:51:23,500 --> 00:51:26,890
particular problem domain some thought

00:51:25,599 --> 00:51:28,960
was put into making them a little bit

00:51:26,890 --> 00:51:30,940
more general-purpose and hopefully

00:51:28,960 --> 00:51:33,040
useful outside it has been a wonderful

00:51:30,940 --> 00:51:34,060
wonderful addition to the language to

00:51:33,040 --> 00:51:36,160
express it

00:51:34,060 --> 00:51:39,040
they're easy on the eyes works for

00:51:36,160 --> 00:51:41,620
functions methods classes and it adds a

00:51:39,040 --> 00:51:44,500
powerful layer of composable tools so

00:51:41,620 --> 00:51:45,820
that an amazing number of decorator

00:51:44,500 --> 00:51:48,150
tools have been written to where a

00:51:45,820 --> 00:51:50,560
person can add extra functionality

00:51:48,150 --> 00:51:53,650
easily to the program just by putting a

00:51:50,560 --> 00:51:56,080
net sign in a decorator name before a

00:51:53,650 --> 00:51:59,410
class or a function I introduced one in

00:51:56,080 --> 00:52:02,320
Python 3 too so you write your Fibonacci

00:51:59,410 --> 00:52:05,260
function it's a terrible example by the

00:52:02,320 --> 00:52:06,610
way but I like it because it's easy to

00:52:05,260 --> 00:52:08,620
demonstrate one of the worst ways to

00:52:06,610 --> 00:52:12,280
write the Fibonacci function is you

00:52:08,620 --> 00:52:14,830
return fib n minus 1 plus fib n minus 2

00:52:12,280 --> 00:52:16,780
which is catastrophic in terms of

00:52:14,830 --> 00:52:19,860
performance if you run that for fib 100

00:52:16,780 --> 00:52:22,180
it will not finish in your lifetime you

00:52:19,860 --> 00:52:23,710
have the power of Google backing you up

00:52:22,180 --> 00:52:27,970
and you're splitting across all other

00:52:23,710 --> 00:52:30,100
machines so how do you fix this well you

00:52:27,970 --> 00:52:31,360
can rewrite the algorithm but hey that

00:52:30,100 --> 00:52:34,570
takes you away from the way it was

00:52:31,360 --> 00:52:37,450
described in the books you've lost your

00:52:34,570 --> 00:52:39,100
little recursive relation what if we

00:52:37,450 --> 00:52:42,010
just put one line before the function

00:52:39,100 --> 00:52:44,320
set at LRU cache presto

00:52:42,010 --> 00:52:46,480
it has instantly moved into the world of

00:52:44,320 --> 00:52:48,640
dynamic programming caches previous

00:52:46,480 --> 00:52:51,460
results and now when you say fib 100 it

00:52:48,640 --> 00:52:54,880
takes 101 iterations to complete it

00:52:51,460 --> 00:52:56,920
becomes astonishingly fast now I have a

00:52:54,880 --> 00:52:59,410
function that whose job it is to take

00:52:56,920 --> 00:53:01,860
someone's name open the database

00:52:59,410 --> 00:53:04,630
connection go out to the database do a

00:53:01,860 --> 00:53:06,190
sequel search with the where clause

00:53:04,630 --> 00:53:08,650
where it equals that name and were to

00:53:06,190 --> 00:53:11,080
return the phone number then parse up

00:53:08,650 --> 00:53:13,810
the result coerce it to an integer and

00:53:11,080 --> 00:53:16,540
hand it back it happens every time I

00:53:13,810 --> 00:53:18,220
look up the person's name just to find

00:53:16,540 --> 00:53:21,610
their phone number what does it take to

00:53:18,220 --> 00:53:23,950
optimize that at LRU cache least

00:53:21,610 --> 00:53:26,170
recently used cache decorators are a

00:53:23,950 --> 00:53:28,000
powerful feature to extend the language

00:53:26,170 --> 00:53:31,720
and a beautiful readable sort of way who

00:53:28,000 --> 00:53:33,340
thinks that's fantastic you guys even

00:53:31,720 --> 00:53:35,560
heard of Python 3 too yet and just

00:53:33,340 --> 00:53:36,700
wonders we've had what this cache thing

00:53:35,560 --> 00:53:39,520
is I'm talking about

00:53:36,700 --> 00:53:40,990
if you feel left out you could go look

00:53:39,520 --> 00:53:43,180
at the docs for it and you will find a

00:53:40,990 --> 00:53:45,900
link to a version of it that works back

00:53:43,180 --> 00:53:47,940
on Python to 5 + 2 6 + 2

00:53:45,900 --> 00:53:51,390
all those primitive pythons that you're

00:53:47,940 --> 00:53:53,850
still stuck with okay something we got

00:53:51,390 --> 00:53:59,040
that you don't got my language has

00:53:53,850 --> 00:54:01,980
introspection in yours doesn't the

00:53:59,040 --> 00:54:04,080
fantastic feature if Alan Kay were here

00:54:01,980 --> 00:54:05,820
he's read curmudgeonly I had the

00:54:04,080 --> 00:54:06,930
pleasure of being able to work with him

00:54:05,820 --> 00:54:08,850
for a year

00:54:06,930 --> 00:54:10,410
any time you would bring up something

00:54:08,850 --> 00:54:13,520
like this we solve this problem I cannot

00:54:10,410 --> 00:54:16,230
1860s list did this this wasn't

00:54:13,520 --> 00:54:18,210
respectable but then people forgot and

00:54:16,230 --> 00:54:20,970
made lots of languages that couldn't

00:54:18,210 --> 00:54:22,920
introspect so it adds a capability it's

00:54:20,970 --> 00:54:24,720
off limits to aesthetically compiled

00:54:22,920 --> 00:54:27,030
languages it lets us build tools like

00:54:24,720 --> 00:54:29,280
inspect hideout help metaclasses dock

00:54:27,030 --> 00:54:31,050
test unit tests to do self-discovery

00:54:29,280 --> 00:54:32,910
debuggers all kinds of wonderful things

00:54:31,050 --> 00:54:34,230
if you are not introspecting in Python

00:54:32,910 --> 00:54:35,670
you are not using full features of

00:54:34,230 --> 00:54:37,830
language who thinks this is a powerful

00:54:35,670 --> 00:54:41,390
awesome capability that we got and you

00:54:37,830 --> 00:54:43,920
don't get okay all right

00:54:41,390 --> 00:54:47,060
there are those who consider exec them

00:54:43,920 --> 00:54:49,650
and eval to be a sin I am NOT wonderful

00:54:47,060 --> 00:54:51,210
Allen okay would say it was a list

00:54:49,650 --> 00:54:56,640
killer feature it was the ability to run

00:54:51,210 --> 00:54:57,870
itself I think can run itself oh I will

00:54:56,640 --> 00:55:01,410
not try and commit you for this awesome

00:54:57,870 --> 00:55:04,320
I will say that we've used it in time it

00:55:01,410 --> 00:55:08,010
preached code on the fly name tuples up

00:55:04,320 --> 00:55:09,630
or run themselves through a vowel it's

00:55:08,010 --> 00:55:11,010
really a fantastic capability I will

00:55:09,630 --> 00:55:12,570
point you to a recipe if you go to

00:55:11,010 --> 00:55:14,610
search in a Python cookbook for

00:55:12,570 --> 00:55:16,560
spreadsheet or look at one of the top

00:55:14,610 --> 00:55:19,980
recipes there it shows a simple way to

00:55:16,560 --> 00:55:21,870
use eval to implement spreadsheet like

00:55:19,980 --> 00:55:24,660
capabilities in just a couple lines it

00:55:21,870 --> 00:55:27,000
is fantastic because eval will accept as

00:55:24,660 --> 00:55:28,470
an argument not just a dictionary but

00:55:27,000 --> 00:55:29,820
something looks like a dictionary that's

00:55:28,470 --> 00:55:31,830
something it looks like a dictionary can

00:55:29,820 --> 00:55:33,660
recursively go back in and do a chain of

00:55:31,830 --> 00:55:35,790
calculations if you've ever worked with

00:55:33,660 --> 00:55:37,320
a spreadsheet you'll know that it seems

00:55:35,790 --> 00:55:39,150
to be able to figure out a dependency

00:55:37,320 --> 00:55:40,830
graph whenever you enter a formula it

00:55:39,150 --> 00:55:42,750
knows what it depends on so if you

00:55:40,830 --> 00:55:44,550
change an input only the things that

00:55:42,750 --> 00:55:46,890
depend on that input change it's

00:55:44,550 --> 00:55:48,630
fantastic we have the capability to and

00:55:46,890 --> 00:55:51,210
if you haven't played with Val and

00:55:48,630 --> 00:55:54,030
haven't given it a custom mapping you've

00:55:51,210 --> 00:55:55,080
missed out wait it from the mountaintops

00:55:54,030 --> 00:55:57,960
if you think you just learned something

00:55:55,080 --> 00:55:58,550
to learn something new everybody in here

00:55:57,960 --> 00:56:01,910
knew you could

00:55:58,550 --> 00:56:03,830
that I don't buy it all right one of our

00:56:01,910 --> 00:56:05,930
killer features is of the with statement

00:56:03,830 --> 00:56:09,320
I think this is a marvelous piece of

00:56:05,930 --> 00:56:11,930
technology I have seen things like it

00:56:09,320 --> 00:56:14,900
before but not many most languages are

00:56:11,930 --> 00:56:16,190
deprived of the WIPP statement so from

00:56:14,900 --> 00:56:17,840
the point of view of a person just using

00:56:16,190 --> 00:56:19,970
with everyday it's just a clean and

00:56:17,840 --> 00:56:21,740
elegant way to do resource management to

00:56:19,970 --> 00:56:24,580
make sure your locks are freed up and

00:56:21,740 --> 00:56:27,740
that your your files are closed and that

00:56:24,580 --> 00:56:30,770
I put threads and locks and saying I

00:56:27,740 --> 00:56:33,290
should've put files there so isn't a

00:56:30,770 --> 00:56:36,610
very elegant tool but more importantly

00:56:33,290 --> 00:56:42,740
it's a tool for factoring so you have

00:56:36,610 --> 00:56:46,300
piece of code a B and C a sandwich now

00:56:42,740 --> 00:56:48,530
in that sandwich it used to be that

00:56:46,300 --> 00:56:50,620
common problem was the thing that

00:56:48,530 --> 00:56:53,660
changed was the bread on the sandwich

00:56:50,620 --> 00:56:56,180
different breads same me every time what

00:56:53,660 --> 00:56:58,100
was our solution to that in the

00:56:56,180 --> 00:57:02,240
beginning there was no sub and returned

00:56:58,100 --> 00:57:05,030
God gave us the subroutine subroutine

00:57:02,240 --> 00:57:07,640
was a way of some handling the problem

00:57:05,030 --> 00:57:11,270
of gyfer bread saying meet the width

00:57:07,640 --> 00:57:13,550
statement is the other way around same

00:57:11,270 --> 00:57:15,650
bread different meat I have this same

00:57:13,550 --> 00:57:18,560
setup and the same teardown over and

00:57:15,650 --> 00:57:20,990
over again it's just the body that goes

00:57:18,560 --> 00:57:22,640
inside that change so it is the inverse

00:57:20,990 --> 00:57:24,290
of the subroutine so given that it's the

00:57:22,640 --> 00:57:26,210
inverse of a subroutine or the

00:57:24,290 --> 00:57:27,680
complement to a subroutine you would

00:57:26,210 --> 00:57:29,210
have think thought that somebody would

00:57:27,680 --> 00:57:31,460
have thought this up a long time ago and

00:57:29,210 --> 00:57:33,230
I'm sure they did but they expressed it

00:57:31,460 --> 00:57:35,600
in some arcane form that no one wanted

00:57:33,230 --> 00:57:38,090
to use so it died a horrible death and

00:57:35,600 --> 00:57:39,560
now came back in a beautiful form and it

00:57:38,090 --> 00:57:41,180
provides you an amazing tool for

00:57:39,560 --> 00:57:43,970
factoring for implementing the dry

00:57:41,180 --> 00:57:45,680
principle of - not repeating yourself so

00:57:43,970 --> 00:57:47,240
who just learned the magical purpose

00:57:45,680 --> 00:57:48,980
behind with and why it was special we

00:57:47,240 --> 00:57:51,380
learned something new all right

00:57:48,980 --> 00:57:53,750
it makes it really everybody knew that

00:57:51,380 --> 00:57:58,040
it was the whole bread sandwich an hour

00:57:53,750 --> 00:58:00,920
I don't buy it now a tool that you never

00:57:58,040 --> 00:58:06,200
use but benefit from everyday abstract

00:58:00,920 --> 00:58:08,750
pain cloud base classes identified I go

00:58:06,200 --> 00:58:10,700
in slightly negative I'm actually making

00:58:08,750 --> 00:58:13,010
okay so I will wrap up here pretty

00:58:10,700 --> 00:58:16,750
quickly abstract base classes is the

00:58:13,010 --> 00:58:19,220
next to last one and the thought here is

00:58:16,750 --> 00:58:21,740
most important thing it did for us is

00:58:19,220 --> 00:58:24,890
prior to ABCs the notion of what was a

00:58:21,740 --> 00:58:27,109
set our mapping was a very vague concept

00:58:24,890 --> 00:58:28,609
we had some general agreement amongst

00:58:27,109 --> 00:58:30,650
ourselves that it needed to have get

00:58:28,609 --> 00:58:33,230
item and link and possibly if it had

00:58:30,650 --> 00:58:34,880
keys it was a dictionary but maybe not

00:58:33,230 --> 00:58:37,430
possibly to had items they had a

00:58:34,880 --> 00:58:39,800
dictionary maybe not you benefit now

00:58:37,430 --> 00:58:42,050
from it is now defined exactly what it

00:58:39,800 --> 00:58:43,940
means to be a sequence and a mapping and

00:58:42,050 --> 00:58:45,470
because it's exactly defined you benefit

00:58:43,940 --> 00:58:47,960
from it every day without realizing

00:58:45,470 --> 00:58:51,200
because the parts fit together much

00:58:47,960 --> 00:58:53,240
better so just having a definition was

00:58:51,200 --> 00:58:55,030
progress also it gives you mixing

00:58:53,240 --> 00:58:58,609
capabilities if you've ever used user

00:58:55,030 --> 00:59:00,380
dik-diks mixin you would know that it's

00:58:58,609 --> 00:59:04,220
the simplest way to give a full mapping

00:59:00,380 --> 00:59:07,190
API to your object so you define get

00:59:04,220 --> 00:59:09,980
item you define a length and you define

00:59:07,190 --> 00:59:11,450
keys you pass it to user dik-diks mix in

00:59:09,980 --> 00:59:14,780
and you get the entire dictionary

00:59:11,450 --> 00:59:16,460
interface for free it's fantastic we've

00:59:14,780 --> 00:59:17,780
given you a lot of these capabilities

00:59:16,460 --> 00:59:19,520
through the abstract base classes so you

00:59:17,780 --> 00:59:21,589
can just subclass them and very quickly

00:59:19,520 --> 00:59:24,560
roll your own fully compliant set class

00:59:21,589 --> 00:59:26,480
are mutable mapping and then its last

00:59:24,560 --> 00:59:28,640
magical capability change something

00:59:26,480 --> 00:59:30,740
fundamental to Python Python was special

00:59:28,640 --> 00:59:32,330
because we had duck typing duck typing

00:59:30,740 --> 00:59:33,530
it looks like a duck walks like a duck

00:59:32,330 --> 00:59:37,180
and quacks like a duck it's a duck

00:59:33,530 --> 00:59:39,740
anything else a duck well yes real ducks

00:59:37,180 --> 00:59:43,160
real ducks which what else is brown and

00:59:39,740 --> 00:59:47,839
flows okay after throwing a Monty Python

00:59:43,160 --> 00:59:49,520
reference the new duck typing says if it

00:59:47,839 --> 00:59:51,080
says it's a duck I have something here

00:59:49,520 --> 00:59:52,369
doesn't look like a duck walk like our

00:59:51,080 --> 00:59:54,650
duck would quack like a duck but it

00:59:52,369 --> 00:59:56,510
claims to be a duck and I actually look

00:59:54,650 --> 00:59:58,010
on the duck list and it is registered as

00:59:56,510 --> 00:59:59,839
a duck who put it on the ductless it

00:59:58,010 --> 01:00:02,750
registered itself and I said I am a duck

00:59:59,839 --> 01:00:04,280
that is the new duck typing in Python

01:00:02,750 --> 01:00:06,440
and it gives you the ability to over

01:00:04,280 --> 01:00:08,030
ideas instance and is subclass so it

01:00:06,440 --> 01:00:10,310
used to be a cardinal rule in Python you

01:00:08,030 --> 01:00:14,000
never type check because as soon as you

01:00:10,310 --> 01:00:16,820
say is instance X of list you are

01:00:14,000 --> 01:00:18,560
precluding X from ever being a list like

01:00:16,820 --> 01:00:20,930
object that's not a subclass of list

01:00:18,560 --> 01:00:22,580
you've tied the hands of people but

01:00:20,930 --> 01:00:24,260
that's the segue into my art of

01:00:22,580 --> 01:00:27,380
subclassing talk which is at the end of

01:00:24,260 --> 01:00:29,360
the week hit okay so you have the

01:00:27,380 --> 01:00:33,350
ability latias instance in this subclass

01:00:29,360 --> 01:00:34,700
and brand new capability lasts a winning

01:00:33,350 --> 01:00:36,770
language feature was the indentation

01:00:34,700 --> 01:00:38,810
this is how we write our pseudocode it

01:00:36,770 --> 01:00:40,970
complete contributes to the clean

01:00:38,810 --> 01:00:43,130
uncluttered appearance and for its time

01:00:40,970 --> 01:00:44,690
it was an audacious move even now there

01:00:43,130 --> 01:00:47,750
are people who come to Python and are

01:00:44,690 --> 01:00:50,210
shocked shocked that our whitespace has

01:00:47,750 --> 01:00:51,080
significance I imagine all of you have

01:00:50,210 --> 01:00:54,380
grown used to it

01:00:51,080 --> 01:00:56,510
I will quick a thought is I used to

01:00:54,380 --> 01:00:58,510
follow sig errors for the ACM and one of

01:00:56,510 --> 01:01:01,520
the errors that interested me was when

01:00:58,510 --> 01:01:03,380
AT&T in the United States went offline

01:01:01,520 --> 01:01:06,980
for eight days they trace the air to a

01:01:03,380 --> 01:01:08,780
single line of C code the C code lied

01:01:06,980 --> 01:01:11,060
about what it did in part because of its

01:01:08,780 --> 01:01:13,370
indentation in baqar in part because a

01:01:11,060 --> 01:01:16,430
break was used to break out of an a

01:01:13,370 --> 01:01:19,490
multiple level of if instead of multiple

01:01:16,430 --> 01:01:22,130
level of four and while this is heavily

01:01:19,490 --> 01:01:24,440
nested code the indentation lied about

01:01:22,130 --> 01:01:26,360
what it did the comment lied about what

01:01:24,440 --> 01:01:29,030
it did and yet they knew this was

01:01:26,360 --> 01:01:31,340
critical code and when they knew it was

01:01:29,030 --> 01:01:31,700
critical code they had many layers of

01:01:31,340 --> 01:01:34,040
review

01:01:31,700 --> 01:01:35,870
lots of extremely smart programmers

01:01:34,040 --> 01:01:39,140
looked at this code and blessed it and a

01:01:35,870 --> 01:01:40,550
code wide to them so one of the lessons

01:01:39,140 --> 01:01:42,110
that was derived from that was the

01:01:40,550 --> 01:01:43,760
proper way to do these type of reviews

01:01:42,110 --> 01:01:45,440
now as one you strip the comments until

01:01:43,760 --> 01:01:47,600
you run the city of the C code through a

01:01:45,440 --> 01:01:49,280
beautifier so the indentation doesn't

01:01:47,600 --> 01:01:51,140
lie to you it actually reflects the real

01:01:49,280 --> 01:01:54,130
logic of what the program does do we

01:01:51,140 --> 01:01:58,010
know any language that does that for you

01:01:54,130 --> 01:01:59,630
that's Python the indentation never lies

01:01:58,010 --> 01:02:01,130
to you it tells you what the program

01:01:59,630 --> 01:02:05,080
does who thinks that's fantastic

01:02:01,130 --> 01:02:09,140
so summary of winning language features

01:02:05,080 --> 01:02:11,030
you got them all is that all that makes

01:02:09,140 --> 01:02:11,630
Python awesome if you can think of

01:02:11,030 --> 01:02:12,950
anything else

01:02:11,630 --> 01:02:19,540
I urge you to tweet it from the

01:02:12,950 --> 01:02:19,540
mountaintops yes sir we were in there

01:02:20,680 --> 01:02:28,569
it's a major feature cuido mentions

01:02:23,550 --> 01:02:30,970
inspiration from Mozilla and yes so I

01:02:28,569 --> 01:02:32,650
had not mentioned modules as a major

01:02:30,970 --> 01:02:33,970
language feature some of those things

01:02:32,650 --> 01:02:35,440
you like blue of course you have modules

01:02:33,970 --> 01:02:40,660
except for languages that don't have

01:02:35,440 --> 01:02:43,150
them so we doe mentioned in his history

01:02:40,660 --> 01:02:44,770
of Python inspiration from languages

01:02:43,150 --> 01:02:46,960
they had a modular structure it so that

01:02:44,770 --> 01:02:50,410
was an early feature of the language

01:02:46,960 --> 01:02:52,089
packages got later on added later on in

01:02:50,410 --> 01:02:55,540
my opinion they've been heavily abused

01:02:52,089 --> 01:02:59,680
but modules are a fine thing any other

01:02:55,540 --> 01:03:01,900
awesome features I missed I have two

01:02:59,680 --> 01:03:04,450
quick questions the first one is about

01:03:01,900 --> 01:03:07,270
the ease of learning how do you think we

01:03:04,450 --> 01:03:09,240
can balance that with the necessity for

01:03:07,270 --> 01:03:12,790
language growth in the future

01:03:09,240 --> 01:03:14,859
second one is about protocols the only

01:03:12,790 --> 01:03:18,250
thing is that we don't have a formal

01:03:14,859 --> 01:03:21,220
protocol definition in Python but they

01:03:18,250 --> 01:03:23,740
work in a way a lot of people even not

01:03:21,220 --> 01:03:26,349
in the batteries where they have a file

01:03:23,740 --> 01:03:29,349
like object it will follow that protocol

01:03:26,349 --> 01:03:31,660
so how much do you think these have to

01:03:29,349 --> 01:03:33,670
do with the nature of the community okay

01:03:31,660 --> 01:03:35,170
so those work because the second

01:03:33,670 --> 01:03:40,270
questions are protocols in the first was

01:03:35,170 --> 01:03:42,880
on okay so let me handle the protocol

01:03:40,270 --> 01:03:44,740
question persons python doesn't have a

01:03:42,880 --> 01:03:46,180
protocol I interpreted that in several

01:03:44,740 --> 01:03:47,740
different ways and we mentioned file

01:03:46,180 --> 01:03:49,809
like objects those actually have a

01:03:47,740 --> 01:03:52,750
definition to now abstract base classes

01:03:49,809 --> 01:03:54,640
were an attempt to define a protocol for

01:03:52,750 --> 01:03:56,650
that so there is a protocol now for what

01:03:54,640 --> 01:03:58,480
it means to be a file like objects so

01:03:56,650 --> 01:04:00,940
eventually we're getting this how about

01:03:58,480 --> 01:04:02,650
a language definition itself it used to

01:04:00,940 --> 01:04:07,119
be 10 Peter said the definition of

01:04:02,650 --> 01:04:08,650
Python is whatever C Python does and

01:04:07,119 --> 01:04:10,869
unfortunately to some degree that is

01:04:08,650 --> 01:04:12,640
still true but is becoming less true and

01:04:10,869 --> 01:04:15,940
hopefully will stop being true

01:04:12,640 --> 01:04:19,960
altogether in the fairly near future so

01:04:15,940 --> 01:04:23,710
I have an official spec but we will have

01:04:19,960 --> 01:04:25,599
some agreed-upon commonality between all

01:04:23,710 --> 01:04:28,390
the implementations that it is no longer

01:04:25,599 --> 01:04:30,690
C Python is no longer Python just

01:04:28,390 --> 01:04:32,869
because C Python happened to do thing X

01:04:30,690 --> 01:04:35,660
possibly unintentionally enough

01:04:32,869 --> 01:04:38,210
I design these of learning question

01:04:35,660 --> 01:04:40,279
really had to do with one time the

01:04:38,210 --> 01:04:42,170
language is very simple it really you

01:04:40,279 --> 01:04:44,259
could learn the whole language in a day

01:04:42,170 --> 01:04:48,499
the whole language Python one point

01:04:44,259 --> 01:04:50,390
1.5.2 is still cherished by many because

01:04:48,499 --> 01:04:51,859
you could learn it very quickly and know

01:04:50,390 --> 01:04:54,259
the whole language people used to say it

01:04:51,859 --> 01:04:55,039
fits in my head no longer does it fit in

01:04:54,259 --> 01:04:58,880
your head

01:04:55,039 --> 01:05:02,869
I am shocked shocked to talk to Python

01:04:58,880 --> 01:05:05,119
core developers routinely they forget

01:05:02,869 --> 01:05:07,880
what's in the language I talk to people

01:05:05,119 --> 01:05:09,829
teach Python every day they forget I was

01:05:07,880 --> 01:05:10,579
in the language I fall on the little

01:05:09,829 --> 01:05:12,349
Twitter street

01:05:10,579 --> 01:05:15,049
I'll have Steve Holden the head of the

01:05:12,349 --> 01:05:18,769
PSF teacher of Python proposed features

01:05:15,049 --> 01:05:21,259
that are already there it happens a lot

01:05:18,769 --> 01:05:23,269
and so we have a challenge there of how

01:05:21,259 --> 01:05:25,759
to organize that information about what

01:05:23,269 --> 01:05:28,039
exists and to try to not expand the

01:05:25,759 --> 01:05:30,410
language without bounty add features

01:05:28,039 --> 01:05:33,289
that unify rather than then take away I

01:05:30,410 --> 01:05:38,839
think it's an ongoing challenge yes that

01:05:33,289 --> 01:05:40,430
oh yes we don't talk about the time

01:05:38,839 --> 01:05:48,589
machine and we way don't talk about the

01:05:40,430 --> 01:05:50,089
PSU I mean if and we get to have some

01:05:48,589 --> 01:05:53,239
question that comes over the radio from

01:05:50,089 --> 01:05:57,829
the people upstairs number four oh hello

01:05:53,239 --> 01:05:59,809
hello I I'm not gonna mention in an

01:05:57,829 --> 01:06:01,999
awesome feature it's more of a kind of

01:05:59,809 --> 01:06:05,599
progression with readability and

01:06:01,999 --> 01:06:07,940
indentation and ease of use and he

01:06:05,599 --> 01:06:12,499
mentioned it's more based on a personal

01:06:07,940 --> 01:06:14,599
story that today you can consider kind

01:06:12,499 --> 01:06:18,739
of anybody can program Python it's

01:06:14,599 --> 01:06:21,499
because the much effort in making it

01:06:18,739 --> 01:06:24,739
easy but that has a major drawback that

01:06:21,499 --> 01:06:26,930
anybody can program Python so you go to

01:06:24,739 --> 01:06:28,549
an interview you're reading the

01:06:26,930 --> 01:06:31,279
curriculum vitae and the next question

01:06:28,549 --> 01:06:33,799
after reading that he programs Python it

01:06:31,279 --> 01:06:38,900
is you know if he knows how to program

01:06:33,799 --> 01:06:42,259
because really I once had to read some

01:06:38,900 --> 01:06:44,869
source code that this guy used one space

01:06:42,259 --> 01:06:46,720
for an F and for the other if he use

01:06:44,869 --> 01:06:50,780
three spaces and

01:06:46,720 --> 01:06:53,870
obviously his functions span through ten

01:06:50,780 --> 01:06:55,670
screen would it be a fair recap of what

01:06:53,870 --> 01:06:57,740
you said that atrocities can be

01:06:55,670 --> 01:07:01,670
committed in any language and that

01:06:57,740 --> 01:07:04,580
Python in a way is worse because it's so

01:07:01,670 --> 01:07:07,370
easily acquired that people who have

01:07:04,580 --> 01:07:10,250
almost no programming skill and all no

01:07:07,370 --> 01:07:13,040
I'm not saying that it's worse but maybe

01:07:10,250 --> 01:07:15,830
the problem is this guy was working as a

01:07:13,040 --> 01:07:18,740
programmer and I think please don't kill

01:07:15,830 --> 01:07:20,510
me for this but if this guy had to deal

01:07:18,740 --> 01:07:22,460
with a compiler he would have quit

01:07:20,510 --> 01:07:24,500
programming I mean for further further

01:07:22,460 --> 01:07:26,870
good of all of us I want something

01:07:24,500 --> 01:07:28,670
different and that's what I mean that it

01:07:26,870 --> 01:07:32,900
sometimes talked it up not as a question

01:07:28,670 --> 01:07:34,880
but as an observation if I were to hint

01:07:32,900 --> 01:07:36,380
to a positive direction I'd say in the

01:07:34,880 --> 01:07:38,030
interest of the awesomeness of Python

01:07:36,380 --> 01:07:39,950
this person could possibly actually be

01:07:38,030 --> 01:07:41,660
trained to do amazing things and there

01:07:39,950 --> 01:07:44,480
are people who come to Python without a

01:07:41,660 --> 01:07:46,760
modicum of skill but eventually with

01:07:44,480 --> 01:07:48,590
some time apply the find that it opens

01:07:46,760 --> 01:07:50,930
doors to them to teach them some amazing

01:07:48,590 --> 01:07:53,840
things so your buddy Bremen came to

01:07:50,930 --> 01:07:55,640
Python with a huge huge huge amount of

01:07:53,840 --> 01:07:58,610
programming except in this area called

01:07:55,640 --> 01:08:00,920
the Internet and so I opened up the

01:07:58,610 --> 01:08:03,560
essential reference over a decade ago

01:08:00,920 --> 01:08:05,480
and I typed in the socket examples of

01:08:03,560 --> 01:08:07,420
what not and I learned everything about

01:08:05,480 --> 01:08:10,340
the Internet through David Beasley's uh

01:08:07,420 --> 01:08:16,360
examples and then only later reading

01:08:10,340 --> 01:08:23,120
RFC's and whatnot so training can happen

01:08:16,360 --> 01:08:25,520
yes just to question first you didn't

01:08:23,120 --> 01:08:29,000
talk about the buffer and memory review

01:08:25,520 --> 01:08:32,270
that's coming in treated in Peter in

01:08:29,000 --> 01:08:34,280
Python treat like it's really important

01:08:32,270 --> 01:08:37,370
from the NP and everything that's gone

01:08:34,280 --> 01:08:40,700
at the sea level and another thing was

01:08:37,370 --> 01:08:43,880
more of a question about what's gonna be

01:08:40,700 --> 01:08:45,350
the next awesome thing about Titan I

01:08:43,880 --> 01:08:48,560
mean what what do you have in you

01:08:45,350 --> 01:08:51,020
basically so to dramatically different

01:08:48,560 --> 01:08:54,680
questions one was I did not mention a

01:08:51,020 --> 01:08:55,789
list of awesome things a buffer protocol

01:08:54,680 --> 01:08:58,779
and

01:08:55,789 --> 01:09:04,549
revue object possibly because in my view

01:08:58,779 --> 01:09:07,250
they aren't awesome can be awesome we're

01:09:04,549 --> 01:09:10,309
in completely implemented may someday be

01:09:07,250 --> 01:09:12,049
awesome but among some of the core

01:09:10,309 --> 01:09:13,549
developers we kind of vote amongst

01:09:12,049 --> 01:09:17,480
ourselves on it what was the least

01:09:13,549 --> 01:09:19,699
useful feature in Python 3 new feature

01:09:17,480 --> 01:09:21,349
possibly the memory view object was it

01:09:19,699 --> 01:09:24,769
yeah it has the potential to be very

01:09:21,349 --> 01:09:27,199
important because in the numpy world one

01:09:24,769 --> 01:09:30,199
of the discoveries was the ability to

01:09:27,199 --> 01:09:32,750
dance across arrays in memory in ways

01:09:30,199 --> 01:09:34,730
where you could specify as a striding of

01:09:32,750 --> 01:09:38,359
the size of that the pieces was actually

01:09:34,730 --> 01:09:40,849
an incredibly powerful metaphor but a

01:09:38,359 --> 01:09:43,190
style of interacting with data one that

01:09:40,849 --> 01:09:45,349
transcended the scientific law world and

01:09:43,190 --> 01:09:47,000
was really a fantastic tool the idea the

01:09:45,349 --> 01:09:49,099
memory view object was it was going to

01:09:47,000 --> 01:09:51,289
give everyone access to that I believe

01:09:49,099 --> 01:09:55,489
it is not fulfilled it's a promise in

01:09:51,289 --> 01:09:58,940
that regard another question was what is

01:09:55,489 --> 01:10:03,079
the next most awesome feature coming up

01:09:58,940 --> 01:10:06,099
in Python L&K said the best way to

01:10:03,079 --> 01:10:09,199
predict the future is to invent it and

01:10:06,099 --> 01:10:14,150
so it's up to you to make it one that I

01:10:09,199 --> 01:10:16,280
put in was in Python 3 3 you do go to we

01:10:14,150 --> 01:10:17,809
you know we have daily builds so you can

01:10:16,280 --> 01:10:20,000
actually be running Python 3 3 right now

01:10:17,809 --> 01:10:22,730
so chain map is in there which is the

01:10:20,000 --> 01:10:24,469
ability to like take multiple app

01:10:22,730 --> 01:10:26,539
mapping objects and link them together

01:10:24,469 --> 01:10:28,550
the traditional style was you take a

01:10:26,539 --> 01:10:29,989
dictionary you copy it make a new one

01:10:28,550 --> 01:10:31,730
and then do a whole bunch of updates

01:10:29,989 --> 01:10:33,019
copying different dictionaries over when

01:10:31,730 --> 01:10:35,389
in fact you can link several of them

01:10:33,019 --> 01:10:39,289
together and it's an amazingly powerful

01:10:35,389 --> 01:10:42,170
technique so that is one that I know up

01:10:39,289 --> 01:10:44,179
because I invented it another one it's a

01:10:42,170 --> 01:10:46,550
other say I haven't been invented yet I

01:10:44,179 --> 01:10:46,880
invite you to come invent the next best

01:10:46,550 --> 01:10:53,300
thing

01:10:46,880 --> 01:10:55,190
in Python Unicode strings fair enough

01:10:53,300 --> 01:10:57,409
did you guys have a great time it's

01:10:55,190 --> 01:10:59,280
Python awesome thuy different

01:10:57,409 --> 01:11:01,900
mountaintops

01:10:59,280 --> 01:11:06,640
yeah yeah two questions

01:11:01,900 --> 01:11:10,600
yeah yes no no what about them what do

01:11:06,640 --> 01:11:12,130
you think about a strong typing I think

01:11:10,600 --> 01:11:15,160
that Python is beautiful because I am

01:11:12,130 --> 01:11:20,410
are you like if it I make bad things

01:11:15,160 --> 01:11:23,590
with the types it kicks my ass and the

01:11:20,410 --> 01:11:24,910
other question is why a python is

01:11:23,590 --> 01:11:29,440
case-sensitive

01:11:24,910 --> 01:11:30,010
I I think that case sensitivity is a big

01:11:29,440 --> 01:11:35,080
deal

01:11:30,010 --> 01:11:38,020
I understand the second question was why

01:11:35,080 --> 01:11:40,350
is a Python case sensitive it is a case

01:11:38,020 --> 01:11:43,240
sensitive is a big deal Oh

01:11:40,350 --> 01:11:46,420
what's the standard answer because cuido

01:11:43,240 --> 01:11:48,250
said so and how do we know Peter was

01:11:46,420 --> 01:11:49,750
right it seemed to have worked out well

01:11:48,250 --> 01:11:52,300
for all of us who've been programming in

01:11:49,750 --> 01:11:53,950
Python for years that being said we've

01:11:52,300 --> 01:11:55,300
had to adopt some conventions because

01:11:53,950 --> 01:11:58,780
people have gone a little bit nuts is

01:11:55,300 --> 01:12:00,400
Alex I pointed out being inconsistent in

01:11:58,780 --> 01:12:03,430
the upper casing and lower casing in

01:12:00,400 --> 01:12:05,950
camel casing and in what not so that

01:12:03,430 --> 01:12:14,530
atrocity scam people perform fire can be

01:12:05,950 --> 01:12:16,690
your friend or your enemy right wrong

01:12:14,530 --> 01:12:18,850
consistent and wrong which is which is

01:12:16,690 --> 01:12:22,770
the other boat worst of both worlds and

01:12:18,850 --> 01:12:25,300
I'm sorry your first first question

01:12:22,770 --> 01:12:28,720
wrong typing how do I feel about strong

01:12:25,300 --> 01:12:31,600
typing every languages are that I had

01:12:28,720 --> 01:12:34,900
mentioned is awesome some languages are

01:12:31,600 --> 01:12:37,060
more strongly typed in than others each

01:12:34,900 --> 01:12:39,880
of them is awesome in the different ways

01:12:37,060 --> 01:12:41,860
I love that in Python I can create a

01:12:39,880 --> 01:12:43,720
tracer class that looks like some other

01:12:41,860 --> 01:12:46,240
class drop it into a function and have

01:12:43,720 --> 01:12:48,490
it run through and informed me and law

01:12:46,240 --> 01:12:51,130
every activity that occurs along the way

01:12:48,490 --> 01:12:51,670
that's a fantastic capability at the

01:12:51,130 --> 01:12:53,710
same time

01:12:51,670 --> 01:12:56,140
I also love oh camel o camel is

01:12:53,710 --> 01:12:58,240
fantastic because I get all the benefits

01:12:56,140 --> 01:13:00,400
of strong typing with almost none of the

01:12:58,240 --> 01:13:04,030
overhead it's a different language and

01:13:00,400 --> 01:13:06,430
awesome in its own way so I think our

01:13:04,030 --> 01:13:09,060
weaknesses really you just use each tool

01:13:06,430 --> 01:13:09,060
for what it's good at

01:13:09,830 --> 01:13:14,600

YouTube URL: https://www.youtube.com/watch?v=u1sVfGEBKWQ


