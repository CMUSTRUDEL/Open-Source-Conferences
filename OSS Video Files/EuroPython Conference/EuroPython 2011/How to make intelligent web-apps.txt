Title: How to make intelligent web-apps
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Deepak Thukral - 22 June 2011 in "Track Ravioli
"
Captions: 
	00:00:09,480 --> 00:00:28,000
hi everyone is is Deepak yeah it's my

00:00:13,540 --> 00:00:32,169
son is okay yeah okay no hi and now okay

00:00:28,000 --> 00:00:37,600
now okay I ok is the first time I'm

00:00:32,169 --> 00:00:40,390
using hanhan Mike sex okay and so I

00:00:37,600 --> 00:00:44,530
changed my title a bit it's not

00:00:40,390 --> 00:00:48,910
intelligent anymore now I now now now

00:00:44,530 --> 00:00:51,370
now it's super awesome and and after

00:00:48,910 --> 00:00:52,930
attending Raymond talk and Python got so

00:00:51,370 --> 00:00:58,750
many awesome features then I thought

00:00:52,930 --> 00:01:04,890
that let's call this talk super awesome

00:00:58,750 --> 00:01:09,790
you know so i'm deepak and i studied CS

00:01:04,890 --> 00:01:12,460
just like some of you guys and how many

00:01:09,790 --> 00:01:17,110
of you have studied artificial

00:01:12,460 --> 00:01:20,470
intelligence in at universities so quite

00:01:17,110 --> 00:01:24,850
a lot so so this talk is more about

00:01:20,470 --> 00:01:27,190
artificial intelligence then using some

00:01:24,850 --> 00:01:31,659
kind of framework or are you using some

00:01:27,190 --> 00:01:36,340
kind of design patterns so basically i

00:01:31,659 --> 00:01:40,510
loved data and i love to hack it and i

00:01:36,340 --> 00:01:45,580
also love python but before I starting

00:01:40,510 --> 00:01:49,659
hacking data I was writing so many code

00:01:45,580 --> 00:01:53,680
at the University you know how to how to

00:01:49,659 --> 00:01:58,390
fix date on how to represent in in a way

00:01:53,680 --> 00:02:05,440
so that so that other machine can read

00:01:58,390 --> 00:02:09,159
it so why Python because it's awesome so

00:02:05,440 --> 00:02:13,959
so we have no excuse to not use Python

00:02:09,159 --> 00:02:17,439
and it has got awesome fat framework as

00:02:13,959 --> 00:02:20,160
well and such that some of them are here

00:02:17,439 --> 00:02:23,760
for for example Django is

00:02:20,160 --> 00:02:27,480
quite awesome cherry pie it's also

00:02:23,760 --> 00:02:30,420
awesome and take care about the turbo

00:02:27,480 --> 00:02:32,610
gear it's also cool I wouldn't say it's

00:02:30,420 --> 00:02:40,650
awesome but it but but but it's cool

00:02:32,610 --> 00:02:43,560
yeah anyway so and and then and then we

00:02:40,650 --> 00:02:46,410
have more pie alone and soap I mean some

00:02:43,560 --> 00:02:49,920
people still use it I mean for those for

00:02:46,410 --> 00:02:52,970
support for those I I think I think

00:02:49,920 --> 00:02:55,800
Mama's to them who use blown I guess so

00:02:52,970 --> 00:02:58,080
and there are so many framework that

00:02:55,800 --> 00:02:59,370
even some people say that they have

00:02:58,080 --> 00:03:03,660
their own framework and it's their

00:02:59,370 --> 00:03:06,900
favorite super awesome framework so so

00:03:03,660 --> 00:03:10,230
what's the futz the formula of of making

00:03:06,900 --> 00:03:12,440
us an awesome app and and awesome is

00:03:10,230 --> 00:03:16,230
different than super awesome because

00:03:12,440 --> 00:03:18,150
because awesome is something when when

00:03:16,230 --> 00:03:19,710
you use awesome tools you have awesome

00:03:18,150 --> 00:03:21,750
idea and you have also you're awesome

00:03:19,710 --> 00:03:25,709
you user interface and then you build an

00:03:21,750 --> 00:03:28,650
awesome app so so the main main idea is

00:03:25,709 --> 00:03:31,080
that you have an awesome idea which is

00:03:28,650 --> 00:03:32,670
which is the core which we which no one

00:03:31,080 --> 00:03:34,820
can help you with it with that and then

00:03:32,670 --> 00:03:37,350
you have awesome awesome tools and

00:03:34,820 --> 00:03:41,100
awesome web framework which which you

00:03:37,350 --> 00:03:43,230
can use for example Django or or or some

00:03:41,100 --> 00:03:47,250
other and then you have to build an

00:03:43,230 --> 00:03:50,070
awesome user interface yeah I mean based

00:03:47,250 --> 00:03:52,230
on my experience I'm a data engineer and

00:03:50,070 --> 00:03:55,770
I don't care about user interface much

00:03:52,230 --> 00:04:00,870
but believe me it matters it really

00:03:55,770 --> 00:04:03,600
matters and a good UI designer can can

00:04:00,870 --> 00:04:06,090
give you 100 100 argument that user

00:04:03,600 --> 00:04:08,430
interface should be much better but you

00:04:06,090 --> 00:04:10,770
wouldn't trust as a data engineer but

00:04:08,430 --> 00:04:12,390
when the code goes live or the web app

00:04:10,770 --> 00:04:16,260
goes live then you see so many people

00:04:12,390 --> 00:04:19,380
they use your app and then you feel that

00:04:16,260 --> 00:04:23,419
oh you were wrong and he was right so

00:04:19,380 --> 00:04:27,990
it's the idea how to make an awesome app

00:04:23,419 --> 00:04:30,810
so back in 15 years when I was a student

00:04:27,990 --> 00:04:33,689
in secondary school it was it was it was

00:04:30,810 --> 00:04:37,799
really hard to think think like this

00:04:33,689 --> 00:04:39,439
and I saw a hot meal and it was it was

00:04:37,799 --> 00:04:43,409
quite cool and I wanted to make

00:04:39,439 --> 00:04:47,759
something like an HTML page but I didn't

00:04:43,409 --> 00:04:50,549
know it's called HTML so I I I found an

00:04:47,759 --> 00:04:53,399
awesome website which was this which

00:04:50,549 --> 00:04:55,469
which helped me a lot as you can see

00:04:53,399 --> 00:04:57,599
that you user interface I mean if you

00:04:55,469 --> 00:04:59,639
compare now then it sucks but at that

00:04:57,599 --> 00:05:06,529
time it was quite cool and very infirm

00:04:59,639 --> 00:05:10,860
it infirmity and and the link here I

00:05:06,529 --> 00:05:14,399
click there almost 100 times and and I

00:05:10,860 --> 00:05:17,159
never got any useful information there

00:05:14,399 --> 00:05:22,050
so the thing the first thing which I

00:05:17,159 --> 00:05:26,129
searched there is how to make hotmail so

00:05:22,050 --> 00:05:31,469
it was quite weird because I didn't get

00:05:26,129 --> 00:05:34,049
any it is reserves and and I mean I I

00:05:31,469 --> 00:05:37,769
got reserved for hotmail and then I

00:05:34,049 --> 00:05:39,360
could check my emails weird so I and

00:05:37,769 --> 00:05:42,779
then I search more and then I go I got

00:05:39,360 --> 00:05:45,389
to know a word which is called HTML so

00:05:42,779 --> 00:05:49,860
the key but I was looking for was HTML

00:05:45,389 --> 00:05:53,129
but it took me around three days around

00:05:49,860 --> 00:05:56,610
eight hours and it was very expensive to

00:05:53,129 --> 00:05:59,669
use internet at that time so so but two

00:05:56,610 --> 00:06:04,739
years later in 1998 something super

00:05:59,669 --> 00:06:06,809
awesome came and it was this and and and

00:06:04,739 --> 00:06:09,989
the thing why it was super super awesome

00:06:06,809 --> 00:06:12,419
and the reason was that I could write

00:06:09,989 --> 00:06:14,789
anything and I was always getting their

00:06:12,419 --> 00:06:16,379
reserve which I was looking for because

00:06:14,789 --> 00:06:19,199
at that time information was very less

00:06:16,379 --> 00:06:26,759
and it was very easy to find and useful

00:06:19,199 --> 00:06:33,449
information the deaf schools so that

00:06:26,759 --> 00:06:35,999
that is why it's super awesome so the

00:06:33,449 --> 00:06:39,599
thing is why we need intelligence in our

00:06:35,999 --> 00:06:42,659
application if at this point it's very

00:06:39,599 --> 00:06:44,819
important because information is looks

00:06:42,659 --> 00:06:46,589
like this it's overloaded it's

00:06:44,819 --> 00:06:47,610
everywhere there's so much information

00:06:46,589 --> 00:06:50,610
then it

00:06:47,610 --> 00:06:53,629
is it's extremely hard I would say it's

00:06:50,610 --> 00:06:59,330
Vic Utley hard to to find useful

00:06:53,629 --> 00:07:03,150
information from from from from the bulk

00:06:59,330 --> 00:07:06,629
so if you if you see the stats that it's

00:07:03,150 --> 00:07:10,169
it's also very I mean for me it's it's

00:07:06,629 --> 00:07:12,240
nice because i love data there's a lot

00:07:10,169 --> 00:07:15,270
of data there around a 130 million

00:07:12,240 --> 00:07:18,180
website at at a time i guess there are

00:07:15,270 --> 00:07:22,590
more and there are around 150 million

00:07:18,180 --> 00:07:26,729
tweets every day and and out of them

00:07:22,590 --> 00:07:29,520
there two million two million tweets are

00:07:26,729 --> 00:07:33,300
just pictures and there around four

00:07:29,520 --> 00:07:37,169
million blog post every day at WordPress

00:07:33,300 --> 00:07:39,719
so if you if you if you studied computer

00:07:37,169 --> 00:07:41,759
science and if you if you know a bit

00:07:39,719 --> 00:07:45,389
about artificial intelligence then this

00:07:41,759 --> 00:07:47,009
thing it gives you a picture of future

00:07:45,389 --> 00:07:52,500
that how our future is going to look

00:07:47,009 --> 00:07:54,960
like and it's not it's not very nice if

00:07:52,500 --> 00:07:58,560
you have so much information and then

00:07:54,960 --> 00:08:02,759
you need a lot of research to to fix

00:07:58,560 --> 00:08:04,669
these things for you so the more reason

00:08:02,759 --> 00:08:07,379
that why you need intelligence is that

00:08:04,669 --> 00:08:10,199
you want to do something new in in your

00:08:07,379 --> 00:08:12,870
application III have seen so many guys

00:08:10,199 --> 00:08:14,639
they are talking to me for example one

00:08:12,870 --> 00:08:18,539
guy he wanted to make an iphone app and

00:08:14,639 --> 00:08:21,389
he wanted to take a picture but he he on

00:08:18,539 --> 00:08:24,509
this picture he wanted that this image

00:08:21,389 --> 00:08:27,569
should be segmented so that you can see

00:08:24,509 --> 00:08:29,789
different areas and you can pinpoint and

00:08:27,569 --> 00:08:31,940
change the color and the idea was very

00:08:29,789 --> 00:08:34,649
awesome but he didn't know that it's

00:08:31,940 --> 00:08:37,310
very easy to solve if you know

00:08:34,649 --> 00:08:42,390
artificial intelligence or if you know

00:08:37,310 --> 00:08:45,810
clustering in general so so there are

00:08:42,390 --> 00:08:48,209
some cases like this essa and if you

00:08:45,810 --> 00:08:49,260
want to stay in competition you you you

00:08:48,209 --> 00:08:51,510
have a cool idea you have an awesome

00:08:49,260 --> 00:08:53,820
website you have awesome super you super

00:08:51,510 --> 00:08:57,600
awesome users and you have a scalable

00:08:53,820 --> 00:09:00,480
architecture but you need to ask that

00:08:57,600 --> 00:09:01,379
are you prepared for future there are so

00:09:00,480 --> 00:09:03,989
much information

00:09:01,379 --> 00:09:08,579
that you can extract or you need to

00:09:03,989 --> 00:09:10,559
solve solve something so you you need to

00:09:08,579 --> 00:09:13,410
ask that the information that you have

00:09:10,559 --> 00:09:16,919
is really useful in it will be really

00:09:13,410 --> 00:09:20,129
useful in future and the last reason

00:09:16,919 --> 00:09:25,319
that there are so many things to do and

00:09:20,129 --> 00:09:28,229
since I'm a scientist so I'll I like the

00:09:25,319 --> 00:09:32,959
last one but there are so many things to

00:09:28,229 --> 00:09:35,809
with data so what exactly is a machine

00:09:32,959 --> 00:09:38,339
learning actually it is very simple

00:09:35,809 --> 00:09:42,179
algorithm that can allow your machine to

00:09:38,339 --> 00:09:44,339
learn and there are a few examples in

00:09:42,179 --> 00:09:47,249
real world which you which you use every

00:09:44,339 --> 00:09:50,039
day I guess the cell is the spam tick

00:09:47,249 --> 00:09:54,869
tick tick tick oh sorry the spam

00:09:50,039 --> 00:09:57,149
detection actually spam detection was

00:09:54,869 --> 00:09:59,999
the first thing I mean which I which I

00:09:57,149 --> 00:10:02,549
ever did at University it's very easy

00:09:59,999 --> 00:10:05,249
that you can you you have some emails

00:10:02,549 --> 00:10:07,289
you can you can detect that whether

00:10:05,249 --> 00:10:09,600
they're spam or not and the second

00:10:07,289 --> 00:10:13,889
example what you but you might use I

00:10:09,600 --> 00:10:18,449
think most of them uses google news it's

00:10:13,889 --> 00:10:21,049
very neat example how to how to cluster

00:10:18,449 --> 00:10:24,089
your data and then how to personalize

00:10:21,049 --> 00:10:27,419
ranking I mean which news should be on

00:10:24,089 --> 00:10:29,999
top which new should be at bottom and

00:10:27,419 --> 00:10:31,889
then there few example like facebook

00:10:29,999 --> 00:10:34,259
when you log into Facebook then you see

00:10:31,889 --> 00:10:39,409
that you you may know these people as

00:10:34,259 --> 00:10:43,220
well so it's also something to do with

00:10:39,409 --> 00:10:46,319
not machine learning in general but yeah

00:10:43,220 --> 00:10:50,569
artificial intelligence so I think there

00:10:46,319 --> 00:10:55,079
is a talk by Robin Rob and it's about

00:10:50,569 --> 00:10:59,089
how to decide prices of your products

00:10:55,079 --> 00:11:02,249
and it's it's also a part of machine

00:10:59,089 --> 00:11:04,649
artificial intelligence and there are so

00:11:02,249 --> 00:11:06,599
many other things which you can do so

00:11:04,649 --> 00:11:08,789
basically when we talk about machine

00:11:06,599 --> 00:11:10,559
learning there are two things which I

00:11:08,789 --> 00:11:13,169
mean they're to type of algorithm

00:11:10,559 --> 00:11:15,180
they're supervised and unsupervised so

00:11:13,169 --> 00:11:18,000
what you do in supervised that you take

00:11:15,180 --> 00:11:20,330
your thick data and then you then you

00:11:18,000 --> 00:11:24,000
use some part of data to train it and

00:11:20,330 --> 00:11:27,710
then you use some other part of data are

00:11:24,000 --> 00:11:33,300
you some new observation to to say that

00:11:27,710 --> 00:11:38,940
okay the base this data is good or not I

00:11:33,300 --> 00:11:44,340
mean not good or not but it's it belongs

00:11:38,940 --> 00:11:48,030
to this class or not actually so the inn

00:11:44,340 --> 00:11:51,710
in supervised there are a few kind of

00:11:48,030 --> 00:11:54,600
algorithm and then they're more the

00:11:51,710 --> 00:11:56,640
classification is one of the most common

00:11:54,600 --> 00:11:59,520
which people uses and then you have

00:11:56,640 --> 00:12:02,550
artificial neural network and then you

00:11:59,520 --> 00:12:06,690
have some regression etc and your

00:12:02,550 --> 00:12:08,760
unsupervised is is something that you

00:12:06,690 --> 00:12:12,780
have your data but you don't know that

00:12:08,760 --> 00:12:16,860
to proper in which in which part you

00:12:12,780 --> 00:12:19,530
should divide the data you you you don't

00:12:16,860 --> 00:12:23,550
have answers actually so you don't train

00:12:19,530 --> 00:12:26,370
it you just add weight I create or apply

00:12:23,550 --> 00:12:29,430
some algorithm to do it and the good

00:12:26,370 --> 00:12:32,280
good example is clustering and self or

00:12:29,430 --> 00:12:34,830
nice map I'm not going to talk about

00:12:32,280 --> 00:12:43,560
self-organized map because it's quite

00:12:34,830 --> 00:12:47,580
hard to talk in icon in in Python there

00:12:43,560 --> 00:12:49,500
are over 20 python modules which you can

00:12:47,580 --> 00:12:53,910
use it you don't have to write your own

00:12:49,500 --> 00:12:56,940
algorithms and some of them I mean which

00:12:53,910 --> 00:13:01,530
I would recommend is scikit-learn

00:12:56,940 --> 00:13:06,990
because it's it's made for unstructured

00:13:01,530 --> 00:13:10,110
data so if it's quite cool and mmm DP is

00:13:06,990 --> 00:13:13,350
also cool because it's pure python and

00:13:10,110 --> 00:13:14,910
if you if if you heard of the support

00:13:13,350 --> 00:13:20,100
vector machine then i would recommend

00:13:14,910 --> 00:13:23,520
lib svn but the thing is that none of

00:13:20,100 --> 00:13:26,160
them have everything so you you might

00:13:23,520 --> 00:13:27,930
have to use different different modules

00:13:26,160 --> 00:13:31,589
for different different things

00:13:27,930 --> 00:13:34,589
in your eye I said that md md b is pure

00:13:31,589 --> 00:13:37,770
python so if you guys just want to have

00:13:34,589 --> 00:13:41,100
pure python good then mdp might appear

00:13:37,770 --> 00:13:44,510
to you but as I scikit-learn is also

00:13:41,100 --> 00:13:48,620
also quite awesome because it it has a

00:13:44,510 --> 00:13:52,220
very cool way to extract features and

00:13:48,620 --> 00:13:55,470
the actually the actually but the main

00:13:52,220 --> 00:13:58,200
problem why you can't use these all

00:13:55,470 --> 00:14:02,540
things I mean why these all things are

00:13:58,200 --> 00:14:06,089
not fully and the main reason is that

00:14:02,540 --> 00:14:08,370
they can't read your feature so you you

00:14:06,089 --> 00:14:11,640
you you have to expect your feature and

00:14:08,370 --> 00:14:15,240
then you have to put put it into some

00:14:11,640 --> 00:14:18,060
kind of algorithms I mean machine

00:14:15,240 --> 00:14:19,830
learning algorithm so if you know how to

00:14:18,060 --> 00:14:24,330
extract feature then you are almost

00:14:19,830 --> 00:14:26,130
halfway there so the first thing which

00:14:24,330 --> 00:14:29,520
I'm going to talk about click click

00:14:26,130 --> 00:14:32,430
clustering in general so the main main

00:14:29,520 --> 00:14:36,170
idea here here is that you have n items

00:14:32,430 --> 00:14:39,959
you want to form a gay group and

00:14:36,170 --> 00:14:43,800
actually it's not very hard and if you

00:14:39,959 --> 00:14:47,150
know if you know what you need if then

00:14:43,800 --> 00:14:50,070
it's it's not it's not really hard and

00:14:47,150 --> 00:14:52,680
there there's so many type of algorithm

00:14:50,070 --> 00:14:56,360
which you can apply a hierarchical came

00:14:52,680 --> 00:15:00,709
in quality threshold fuzzy seeming or

00:14:56,360 --> 00:15:06,810
LSH locality sensitive hashing which was

00:15:00,709 --> 00:15:11,329
developed at Stanford so but i will take

00:15:06,810 --> 00:15:13,950
the easiest one and it's gay means so

00:15:11,329 --> 00:15:17,250
the idea is very simple you have n items

00:15:13,950 --> 00:15:22,890
this n items can be for example news

00:15:17,250 --> 00:15:25,020
articles and you your app is aggregating

00:15:22,890 --> 00:15:27,990
news articles and and and you want to

00:15:25,020 --> 00:15:30,390
divide into like these all news belongs

00:15:27,990 --> 00:15:34,350
to the same same group these all news

00:15:30,390 --> 00:15:37,110
are similar to each other so if you want

00:15:34,350 --> 00:15:43,250
to do something like this then you you

00:15:37,110 --> 00:15:43,250
should probably use clustering and

00:15:43,700 --> 00:15:52,470
the main idea is that you have your end

00:15:47,640 --> 00:15:59,400
news article here and you choose around

00:15:52,470 --> 00:16:02,520
you choose k k is centroid and I mean

00:15:59,400 --> 00:16:06,270
it's a track at random you you you just

00:16:02,520 --> 00:16:10,200
apply a randomizer and then you pick you

00:16:06,270 --> 00:16:13,860
pick kick kick kick akkk centroid from

00:16:10,200 --> 00:16:16,950
your and news article and then you

00:16:13,860 --> 00:16:20,280
compute distance between the set in the

00:16:16,950 --> 00:16:22,980
center and the new news article and I

00:16:20,280 --> 00:16:27,890
mean III mean the centroid itself is a

00:16:22,980 --> 00:16:32,790
news article so you just find a taster

00:16:27,890 --> 00:16:36,090
between them and you you you you append

00:16:32,790 --> 00:16:39,120
it to a centroid which is more near to

00:16:36,090 --> 00:16:46,610
the news article and and as you can see

00:16:39,120 --> 00:16:50,880
here that here which you don't really

00:16:46,610 --> 00:16:53,340
want because you can see it that it's

00:16:50,880 --> 00:16:56,730
it's it's wrong so you have to adjust

00:16:53,340 --> 00:17:03,020
your centroid and how to do is that you

00:16:56,730 --> 00:17:07,380
recompute this centroid based on your

00:17:03,020 --> 00:17:11,940
dresser and and you adjust it and you

00:17:07,380 --> 00:17:17,940
repeat this until your until your I

00:17:11,940 --> 00:17:21,120
creation converge so so you so now you

00:17:17,940 --> 00:17:28,470
know something about this is how to

00:17:21,120 --> 00:17:30,570
group yeah yeah I mean I mean you you

00:17:28,470 --> 00:17:34,200
you have used some kind of distance

00:17:30,570 --> 00:17:36,960
function for that you you you have to

00:17:34,200 --> 00:17:39,540
find distance between your your your

00:17:36,960 --> 00:17:42,540
story a little extra can example like a

00:17:39,540 --> 00:17:44,430
new story yeah so you have tuned to new

00:17:42,540 --> 00:17:47,480
to new story and you want to owe you you

00:17:44,430 --> 00:17:50,910
want to know that how how how they are

00:17:47,480 --> 00:17:54,090
it is related so you find a distance

00:17:50,910 --> 00:17:54,930
between yours your stories if if if

00:17:54,090 --> 00:17:58,430
there

00:17:54,930 --> 00:18:03,050
fournier so you you put it into the same

00:17:58,430 --> 00:18:05,280
total cluster so so when you have your

00:18:03,050 --> 00:18:07,770
centroid I mean when you have your first

00:18:05,280 --> 00:18:11,340
iteration then you get a group and then

00:18:07,770 --> 00:18:12,870
you and then you readjust the centroid

00:18:11,340 --> 00:18:14,910
because you have a group and you have a

00:18:12,870 --> 00:18:17,790
centroid somewhere and then you see that

00:18:14,910 --> 00:18:21,390
that it's not exactly my centroid so you

00:18:17,790 --> 00:18:23,250
readjust somewhere somewhere else so the

00:18:21,390 --> 00:18:27,900
social the main idea is that you have to

00:18:23,250 --> 00:18:30,930
compute a strength so let's take an

00:18:27,900 --> 00:18:34,530
example and in this example we will

00:18:30,930 --> 00:18:38,100
we'll make a django app and which which

00:18:34,530 --> 00:18:43,290
aggregates news article from different

00:18:38,100 --> 00:18:46,410
sources so if you I guess you almost

00:18:43,290 --> 00:18:50,270
Django so I don't have to talk what is

00:18:46,410 --> 00:18:53,340
it so so the main idea here is that you

00:18:50,270 --> 00:18:56,100
you specify your new source and then you

00:18:53,340 --> 00:19:01,560
specify your news items then you make a

00:18:56,100 --> 00:19:04,860
label called cluster and and then you

00:19:01,560 --> 00:19:09,180
just put a signal on your post save that

00:19:04,860 --> 00:19:12,300
whenever you add a new new source and so

00:19:09,180 --> 00:19:15,470
that you you pass our answer feed and

00:19:12,300 --> 00:19:19,230
you feed if you repeat it into news

00:19:15,470 --> 00:19:20,930
articles and after that you build an

00:19:19,230 --> 00:19:26,970
awesome UI which is very important

00:19:20,930 --> 00:19:30,870
believe me and now we can enhance it and

00:19:26,970 --> 00:19:33,600
make it more more awesome bye bye by

00:19:30,870 --> 00:19:36,240
using some kind of grouping algorithms

00:19:33,600 --> 00:19:39,660
which which I when talking in there in

00:19:36,240 --> 00:19:41,010
this kit in this case k means so the

00:19:39,660 --> 00:19:45,810
first thing is that you have to find

00:19:41,010 --> 00:19:48,960
distance between your new story and if

00:19:45,810 --> 00:19:51,120
you if you need to find distance

00:19:48,960 --> 00:19:53,820
actually it's not it's not very hard so

00:19:51,120 --> 00:19:55,920
let's take an example you have a two

00:19:53,820 --> 00:19:58,740
stories which I took like two two days

00:19:55,920 --> 00:20:00,330
back and if you can see that these

00:19:58,740 --> 00:20:02,220
stories they looks very similar for

00:20:00,330 --> 00:20:07,170
human it's very obvious but from machine

00:20:02,220 --> 00:20:08,820
how we can do do this in machine so if

00:20:07,170 --> 00:20:11,100
you see these two story

00:20:08,820 --> 00:20:15,960
you see you say that yes it looks very

00:20:11,100 --> 00:20:19,500
similar so the distance is complementary

00:20:15,960 --> 00:20:21,690
to swimming similarity so if you if if

00:20:19,500 --> 00:20:28,139
two items are similar then distance is

00:20:21,690 --> 00:20:30,779
more smaller so so what what is what we

00:20:28,139 --> 00:20:34,289
can say is that the distance between a

00:20:30,779 --> 00:20:37,590
and b is 1 minus similarity between a

00:20:34,289 --> 00:20:39,509
and B and in such it's very easy to find

00:20:37,590 --> 00:20:41,580
you just fine intersection and then you

00:20:39,509 --> 00:20:48,679
divide it by a union and it's also

00:20:41,580 --> 00:20:54,600
called occurred similarity this one and

00:20:48,679 --> 00:20:58,139
and if you if your if your data is huge

00:20:54,600 --> 00:20:59,519
and to you don't you don't want to you

00:20:58,139 --> 00:21:03,779
don't want to apply such expensive of

00:20:59,519 --> 00:21:08,090
operation then you can also use min hash

00:21:03,779 --> 00:21:16,100
and this is also quite advanced but you

00:21:08,090 --> 00:21:20,220
yeah is the number of element in sets

00:21:16,100 --> 00:21:24,960
insect in set theory it's a in Python

00:21:20,220 --> 00:21:28,500
you can say length length and then you

00:21:24,960 --> 00:21:31,440
can say set set 1 intersections is it a

00:21:28,500 --> 00:21:37,500
dot intersection B and then you can do

00:21:31,440 --> 00:21:39,840
it by Len a union B so if you if you see

00:21:37,500 --> 00:21:41,509
if you see the story and you compute

00:21:39,840 --> 00:21:44,700
then you can you can say that the

00:21:41,509 --> 00:21:48,320
distance between these two story is zero

00:21:44,700 --> 00:21:51,299
point 75 actually it's quite a bit but

00:21:48,320 --> 00:21:57,029
that's that's something which is very

00:21:51,299 --> 00:22:03,210
very hard to find in your data that what

00:21:57,029 --> 00:22:06,299
should be the range of your threshold so

00:22:03,210 --> 00:22:08,060
in Python it's actually not very hard to

00:22:06,299 --> 00:22:10,430
implement

00:22:08,060 --> 00:22:12,230
as as you can see that you you first

00:22:10,430 --> 00:22:16,880
need to extract feature you you take a

00:22:12,230 --> 00:22:20,300
spring with the news items title and

00:22:16,880 --> 00:22:23,000
content you you strip all stop words and

00:22:20,300 --> 00:22:25,520
then you split them or split them up to

00:22:23,000 --> 00:22:28,340
form a new form some kind of set which

00:22:25,520 --> 00:22:32,480
is which is also called back bag of word

00:22:28,340 --> 00:22:35,060
and then you find similarity which is

00:22:32,480 --> 00:22:40,100
just a set in intersection and sets at

00:22:35,060 --> 00:22:43,880
Union yeah and then you just subtract by

00:22:40,100 --> 00:22:45,830
one and you get it dipped a strength now

00:22:43,880 --> 00:22:47,600
after that you need to think you know

00:22:45,830 --> 00:22:50,450
you have your feature you have your

00:22:47,600 --> 00:22:55,040
distance function but but you what you

00:22:50,450 --> 00:22:57,250
really need is that what kind of eyeball

00:22:55,040 --> 00:23:01,150
Sam you you you need to apply off on it

00:22:57,250 --> 00:23:05,210
so the easiest way is you apply gaming

00:23:01,150 --> 00:23:08,510
algorithm but the Cayman haltom itself

00:23:05,210 --> 00:23:13,310
is not suitable in this case because you

00:23:08,510 --> 00:23:17,180
you you you know your size of cluster

00:23:13,310 --> 00:23:20,230
and that's not desired in this case

00:23:17,180 --> 00:23:25,640
because you can have very very sparse

00:23:20,230 --> 00:23:29,000
very very sparse would take data and

00:23:25,640 --> 00:23:34,280
then you can you can you may you mean

00:23:29,000 --> 00:23:37,580
you may not need to structure items into

00:23:34,280 --> 00:23:43,480
a limited group so you you you you need

00:23:37,580 --> 00:23:47,390
have flexibility so let's change a bit

00:23:43,480 --> 00:23:49,510
so so what we can do is that we can say

00:23:47,390 --> 00:23:55,930
that if you have two story and if if the

00:23:49,510 --> 00:24:00,230
distance between them is is smaller than

00:23:55,930 --> 00:24:03,160
delta which is our threshold then then

00:24:00,230 --> 00:24:07,910
we will do then we will append it to

00:24:03,160 --> 00:24:11,510
pressure so what it allows us that we

00:24:07,910 --> 00:24:14,030
can we are no longer dependent on K so

00:24:11,510 --> 00:24:16,430
if you have empty empty empty groups

00:24:14,030 --> 00:24:19,020
then you can just drop them and you can

00:24:16,430 --> 00:24:22,230
apply you can rerun that thing and then

00:24:19,020 --> 00:24:24,450
and then you will get you you you you

00:24:22,230 --> 00:24:25,920
will get some groups and then you again

00:24:24,450 --> 00:24:29,400
drop empty groups and then you will

00:24:25,920 --> 00:24:35,450
rerun it and and so on until you are

00:24:29,400 --> 00:24:40,260
satisfied so it it looks very similar to

00:24:35,450 --> 00:24:44,580
click canopy clustering which is very

00:24:40,260 --> 00:24:50,280
new and i am not going to talk much

00:24:44,580 --> 00:24:52,410
about it so so in in python if it's also

00:24:50,280 --> 00:24:55,950
not very hard to implement you you just

00:24:52,410 --> 00:24:59,010
have a class professor and then you pass

00:24:55,950 --> 00:25:01,920
your items and you pass your distance

00:24:59,010 --> 00:25:08,430
function and then you apply your gaming

00:25:01,920 --> 00:25:10,790
algorithm and and this algorithm is is

00:25:08,430 --> 00:25:15,510
quite simple so first you take your

00:25:10,790 --> 00:25:19,020
items and then you a ten at random use

00:25:15,510 --> 00:25:21,780
select kay-kay centers and then you

00:25:19,020 --> 00:25:28,020
remove this case enters from from the

00:25:21,780 --> 00:25:30,360
items which you want cluster so and and

00:25:28,020 --> 00:25:33,540
and and after that and after that you

00:25:30,360 --> 00:25:36,120
you you just assume that this series

00:25:33,540 --> 00:25:38,520
will converge in fifty I patient's or

00:25:36,120 --> 00:25:40,860
hundred I creations or or three hundred

00:25:38,520 --> 00:25:44,460
hydration but I think for this algorithm

00:25:40,860 --> 00:25:47,040
50 is enough I found that here it

00:25:44,460 --> 00:25:51,600
converges into eight or eight to ten

00:25:47,040 --> 00:25:57,120
iterations so so you you form empty

00:25:51,600 --> 00:26:01,890
empty groups in here and you you from k

00:25:57,120 --> 00:26:03,540
kk md groups here and then you and then

00:26:01,890 --> 00:26:06,180
you iterate through your items and then

00:26:03,540 --> 00:26:09,660
you find distance between centroid and

00:26:06,180 --> 00:26:12,870
items and n n n is this items and the

00:26:09,660 --> 00:26:16,470
end if the distance is minimum and it's

00:26:12,870 --> 00:26:21,210
below the threshold then you up then you

00:26:16,470 --> 00:26:23,490
append it to your group and you do it

00:26:21,210 --> 00:26:26,490
again you do it again and again until

00:26:23,490 --> 00:26:29,730
the last and the best is the same and

00:26:26,490 --> 00:26:32,430
after that you readjust your Center

00:26:29,730 --> 00:26:33,120
since you know that what is your cluster

00:26:32,430 --> 00:26:36,480
and then

00:26:33,120 --> 00:26:39,290
you can you can move your centroid and

00:26:36,480 --> 00:26:44,190
then you rerun it until you get the same

00:26:39,290 --> 00:26:47,820
results so if we if we run it here and

00:26:44,190 --> 00:26:52,080
then I mean I use the sample data and

00:26:47,820 --> 00:26:55,950
then I Iran and the results were not no

00:26:52,080 --> 00:26:59,120
not so bad actually so I I have around

00:26:55,950 --> 00:27:03,450
with 500 news articles i was able to

00:26:59,120 --> 00:27:06,630
cluster around 120 of them and i had

00:27:03,450 --> 00:27:12,030
eight new sources so as you can see that

00:27:06,630 --> 00:27:23,970
you you can see almost the algorithm

00:27:12,030 --> 00:27:26,280
works what okay okay okay I'm sorry no

00:27:23,970 --> 00:27:32,940
it looks like that I've been over

00:27:26,280 --> 00:27:34,590
speaking okay so so so if you run the

00:27:32,940 --> 00:27:37,410
algorithm then you see something like

00:27:34,590 --> 00:27:41,309
this so i will i will go extremely fast

00:27:37,410 --> 00:27:43,710
now so the damn there there there more

00:27:41,309 --> 00:27:46,890
examples you can recognize hand

00:27:43,710 --> 00:27:49,380
handwriting it's also fairly simple and

00:27:46,890 --> 00:27:53,429
then you can subdivide images into some

00:27:49,380 --> 00:27:55,770
kind of areas and then and then if you

00:27:53,429 --> 00:28:00,000
use google maps and there are so many

00:27:55,770 --> 00:28:04,290
places then you can cluster this label

00:28:00,000 --> 00:28:09,420
on on on map and then also you can do

00:28:04,290 --> 00:28:14,429
some kind of sale be i think so the

00:28:09,420 --> 00:28:17,220
second technique is classification so

00:28:14,429 --> 00:28:19,950
for for kid is is very obvious to do

00:28:17,220 --> 00:28:21,900
this thing I mean for us also so you you

00:28:19,950 --> 00:28:24,809
you you you you have some items and you

00:28:21,900 --> 00:28:26,460
you want to you want to tell that it

00:28:24,809 --> 00:28:29,250
belongs to this class or it belongs to

00:28:26,460 --> 00:28:32,190
that class or it belongs to something

00:28:29,250 --> 00:28:33,450
else so Kate seat and and then he and he

00:28:32,190 --> 00:28:37,320
see the picture and then he can

00:28:33,450 --> 00:28:41,490
recognize that it's it is so the idea is

00:28:37,320 --> 00:28:44,950
the same here so

00:28:41,490 --> 00:28:48,880
so the thing is that we present an

00:28:44,950 --> 00:28:51,910
observation and then we train the system

00:28:48,880 --> 00:28:54,190
and then we give some something unseen

00:28:51,910 --> 00:28:56,200
which is not in the system and then and

00:28:54,190 --> 00:28:58,510
then we expect the system system will

00:28:56,200 --> 00:29:00,940
tell that it belongs to X class or its

00:28:58,510 --> 00:29:03,430
belongs to Y like in like in case of

00:29:00,940 --> 00:29:11,220
spam it tells you the new new email is a

00:29:03,430 --> 00:29:15,610
spam or ham so here's a simple pais

00:29:11,220 --> 00:29:19,230
classifier and and its a math the math

00:29:15,610 --> 00:29:22,840
here that they are two to two groups the

00:29:19,230 --> 00:29:27,460
red and green and therefore to be 40

00:29:22,840 --> 00:29:30,070
green and put 20 read and do you need to

00:29:27,460 --> 00:29:33,040
you and then you give a white dot and

00:29:30,070 --> 00:29:37,810
then you ask the system that is this is

00:29:33,040 --> 00:29:41,520
this y dot is green or or read so if if

00:29:37,810 --> 00:29:43,950
you do it then you if you use a pious

00:29:41,520 --> 00:29:47,970
classifier then you can easily do this

00:29:43,950 --> 00:29:53,080
so I will skip it to sams an example

00:29:47,970 --> 00:29:57,040
sample app so we let's make it let's

00:29:53,080 --> 00:29:59,470
make an appt and in this app what we do

00:29:57,040 --> 00:30:03,070
is that we take a tweets and then we we

00:29:59,470 --> 00:30:06,430
tell that these tweets are happy happy

00:30:03,070 --> 00:30:10,560
to its or sad tweets and actually it's

00:30:06,430 --> 00:30:14,350
not very hard also so you just make a

00:30:10,560 --> 00:30:16,360
django model which is which is very

00:30:14,350 --> 00:30:18,910
simple you you do take an author you put

00:30:16,360 --> 00:30:21,630
a tweet and then you put a sentiment say

00:30:18,910 --> 00:30:27,090
and the sentiment can be happy or sad or

00:30:21,630 --> 00:30:31,180
neutral and then you you use papaya seen

00:30:27,090 --> 00:30:35,140
classifier and then you train your your

00:30:31,180 --> 00:30:37,840
your your data that work but is happy so

00:30:35,140 --> 00:30:40,180
if their words like happy awesome

00:30:37,840 --> 00:30:42,010
amazing impressed or smiley then it's

00:30:40,180 --> 00:30:45,580
happy of course and if something like

00:30:42,010 --> 00:30:49,150
side such problem headache or or or that

00:30:45,580 --> 00:30:51,820
smiley the next add so and then we crane

00:30:49,150 --> 00:30:53,970
the system and and then we ask your

00:30:51,820 --> 00:30:56,280
python is awesome the place here and it

00:30:53,970 --> 00:31:00,870
its face yes it's happy grid so the guy

00:30:56,280 --> 00:31:03,300
who wrote this suite is happy the has

00:31:00,870 --> 00:31:06,960
taken some example which I use from

00:31:03,300 --> 00:31:09,150
European feet and some someone I don't

00:31:06,960 --> 00:31:12,600
know who who wrote this then he wrote

00:31:09,150 --> 00:31:15,480
that he wrote something packing done to

00:31:12,600 --> 00:31:19,350
tomorrow flying to prank frankfurt on to

00:31:15,480 --> 00:31:22,380
pisa we're ready for a great week to the

00:31:19,350 --> 00:31:26,040
european and it's it's happy and someone

00:31:22,380 --> 00:31:30,870
wrote back to small no or back too small

00:31:26,040 --> 00:31:35,120
for running shoes and of course if it's

00:31:30,870 --> 00:31:38,640
a said so and but but but you can also

00:31:35,120 --> 00:31:42,930
improve improve the system if you if you

00:31:38,640 --> 00:31:47,640
if you crane crane it by your results or

00:31:42,930 --> 00:31:49,560
use human human computing and suppose

00:31:47,640 --> 00:31:51,570
you you you say that it's spam or not

00:31:49,560 --> 00:31:55,320
yours happy or sad that you add a link

00:31:51,570 --> 00:31:56,790
that is is it really really happy and if

00:31:55,320 --> 00:32:02,240
someone said no it's not happy then you

00:31:56,790 --> 00:32:04,410
trained by that by that example and that

00:32:02,240 --> 00:32:08,300
the last thing which I'm going to talk

00:32:04,410 --> 00:32:13,050
about is recommendation system it works

00:32:08,300 --> 00:32:15,630
it was the same way like if if if I were

00:32:13,050 --> 00:32:17,850
if I if I buy something and I tell to my

00:32:15,630 --> 00:32:20,850
friend that hey this this thing is

00:32:17,850 --> 00:32:24,870
awesome and then he said is it and then

00:32:20,850 --> 00:32:27,720
and then he and then he also by so the

00:32:24,870 --> 00:32:31,050
idea is to emulate the same behavior in

00:32:27,720 --> 00:32:38,190
in machine so that that our social

00:32:31,050 --> 00:32:42,060
social environment is more our social

00:32:38,190 --> 00:32:45,540
shopping become more social so you can

00:32:42,060 --> 00:32:48,840
either recommend recommend things by you

00:32:45,540 --> 00:32:53,790
use a base or buy items like Amazon heat

00:32:48,840 --> 00:32:57,410
amazon values item based and some other

00:32:53,790 --> 00:32:59,720
use user base like Twitter like they use

00:32:57,410 --> 00:33:03,780
they see your friends and then

00:32:59,720 --> 00:33:05,220
friendship friend and then then and then

00:33:03,780 --> 00:33:09,990
they

00:33:05,220 --> 00:33:13,520
when you more friends so you use a

00:33:09,990 --> 00:33:17,039
weight user base user base

00:33:13,520 --> 00:33:19,770
recommendation if it's more about to

00:33:17,039 --> 00:33:22,890
finding similar you you users first and

00:33:19,770 --> 00:33:26,429
then and then you find the intersection

00:33:22,890 --> 00:33:29,130
between their interest and it's very

00:33:26,429 --> 00:33:31,559
easy to implement but it's very slow

00:33:29,130 --> 00:33:34,230
because the youth the amount of users

00:33:31,559 --> 00:33:37,140
are huge and the users change change is

00:33:34,230 --> 00:33:39,809
very often that they like this now and

00:33:37,140 --> 00:33:43,140
they don't like place more but for

00:33:39,809 --> 00:33:48,140
social sites it makes more sense and in

00:33:43,140 --> 00:33:51,419
the item based system that you you

00:33:48,140 --> 00:33:54,990
recommend items and since item they

00:33:51,419 --> 00:33:57,539
don't change very often and if it's very

00:33:54,990 --> 00:34:00,450
easy to easy to run and it's extremely

00:33:57,539 --> 00:34:02,429
faster and it's more it makes more sense

00:34:00,450 --> 00:34:05,429
when you when you say when you sell

00:34:02,429 --> 00:34:07,830
something and you want to you want to

00:34:05,429 --> 00:34:12,619
find that if someone it's excuse about

00:34:07,830 --> 00:34:17,010
this then my user should also buy this

00:34:12,619 --> 00:34:19,109
so as I told you that you use a change

00:34:17,010 --> 00:34:20,639
very fast so you user base

00:34:19,109 --> 00:34:23,730
recommendation assist recommendation

00:34:20,639 --> 00:34:27,780
systems are very slow but item based are

00:34:23,730 --> 00:34:30,119
are quite fast and in the few examples

00:34:27,780 --> 00:34:33,780
like you have seen this recommendation

00:34:30,119 --> 00:34:39,720
recommendation system at last or FM and

00:34:33,780 --> 00:34:42,480
Facebook Twitter and even ads and that's

00:34:39,720 --> 00:34:44,129
it so if you are if you're scared of

00:34:42,480 --> 00:34:46,349
this algorithm then I would recommend

00:34:44,129 --> 00:34:49,230
you to use some some of the tool which

00:34:46,349 --> 00:34:51,589
are already exist in my opinion psychic

00:34:49,230 --> 00:34:54,839
scikit-learn is is an awesome tool

00:34:51,589 --> 00:34:57,960
unfortunately it's not in pure python

00:34:54,839 --> 00:35:03,240
and then you can also use prediction API

00:34:57,960 --> 00:35:06,270
and you can you can clean your data and

00:35:03,240 --> 00:35:09,180
then you you can tell that if it's spam

00:35:06,270 --> 00:35:12,720
or snores happy or sad it's quite easy

00:35:09,180 --> 00:35:17,200
with prediction API and the one

00:35:12,720 --> 00:35:20,640
interesting thing is Apache mouth and

00:35:17,200 --> 00:35:24,240
it's also cool tool but it's written in

00:35:20,640 --> 00:35:30,130
Java and for those who love the code in

00:35:24,240 --> 00:35:32,859
Python they can use type IP and some of

00:35:30,130 --> 00:35:34,990
the cases are that when none of this

00:35:32,859 --> 00:35:39,099
thing fit then and you want to use human

00:35:34,990 --> 00:35:42,550
sin and then you can use a service

00:35:39,099 --> 00:35:44,140
service from amazon which you can upload

00:35:42,550 --> 00:35:48,040
it up upload your upload your assignment

00:35:44,140 --> 00:35:53,560
and people are real people are doing for

00:35:48,040 --> 00:35:56,470
you so this machine machine learning

00:35:53,560 --> 00:35:59,589
anything are not one hundred percent

00:35:56,470 --> 00:36:02,050
accurate for sure so if you if you

00:35:59,589 --> 00:36:06,660
really care care about accuracy then you

00:36:02,050 --> 00:36:10,690
should think using human computing and

00:36:06,660 --> 00:36:14,770
as the data grow then it become

00:36:10,690 --> 00:36:16,720
extremely hard for for people to current

00:36:14,770 --> 00:36:21,040
to run algorithm because it's so

00:36:16,720 --> 00:36:24,670
expensive and in some cases you just you

00:36:21,040 --> 00:36:28,030
just don't know what to do and and there

00:36:24,670 --> 00:36:30,609
are more reason that if why why we

00:36:28,030 --> 00:36:34,300
shouldn't use machine learning but one

00:36:30,609 --> 00:36:37,270
of the thing is cowan said that it's not

00:36:34,300 --> 00:36:40,690
going it's not the most intelligent and

00:36:37,270 --> 00:36:42,849
most strong who's going to survive it's

00:36:40,690 --> 00:36:47,970
more most adoptable who is going to

00:36:42,849 --> 00:36:52,480
serve survive so you have to adopt your

00:36:47,970 --> 00:36:54,970
algorithms so so you make your awesome

00:36:52,480 --> 00:36:57,400
app you use your awesome idea i use

00:36:54,970 --> 00:36:59,230
awesome art architecture then you use

00:36:57,400 --> 00:37:03,720
awesome framework then use awesome you I

00:36:59,230 --> 00:37:06,069
then use some awesome cloud solution and

00:37:03,720 --> 00:37:07,900
then you have your awesome app but if

00:37:06,069 --> 00:37:09,369
you want to make it super awesome then i

00:37:07,900 --> 00:37:12,069
would highly recommend you that do

00:37:09,369 --> 00:37:17,310
something interesting with your kid data

00:37:12,069 --> 00:37:21,790
and it worth it i would highly recommend

00:37:17,310 --> 00:37:23,920
this book from toby cigar and it is

00:37:21,790 --> 00:37:30,010
quite it's quite nice and it's used

00:37:23,920 --> 00:37:31,110
python examples and is its if if the

00:37:30,010 --> 00:37:35,170
core i would

00:37:31,110 --> 00:37:39,310
and and there are other useful things

00:37:35,170 --> 00:37:41,140
which you can do in machine learning if

00:37:39,310 --> 00:37:42,550
you are interested in two interesting in

00:37:41,140 --> 00:37:46,860
it that you can use support vector

00:37:42,550 --> 00:37:50,950
machine for classifying and it's

00:37:46,860 --> 00:37:54,900
amazingly amazingly it gives you it

00:37:50,950 --> 00:37:58,150
gives you an amazing improvement over

00:37:54,900 --> 00:38:00,040
over some other algorithm you can also

00:37:58,150 --> 00:38:03,340
use some kind of other algorithm which I

00:38:00,040 --> 00:38:07,360
mentioned here to improve to improve

00:38:03,340 --> 00:38:10,150
your system and you guys are awesome you

00:38:07,360 --> 00:38:12,490
you make your awesome app and in the end

00:38:10,150 --> 00:38:15,600
it all examples are available only to

00:38:12,490 --> 00:38:20,130
keep github so you can just go and see

00:38:15,600 --> 00:38:24,930
or or or something like this I think

00:38:20,130 --> 00:38:24,930
that's it I don't have much time left

00:38:33,559 --> 00:38:39,859
so if you have any questions please yes

00:38:44,210 --> 00:38:49,829
we have another look just like that are

00:38:46,859 --> 00:38:53,940
you yeah I mean I mean you you can you

00:38:49,829 --> 00:38:55,230
can i okay Cooper climbing you can Korea

00:38:53,940 --> 00:38:57,559
can we have another look at the source

00:38:55,230 --> 00:39:02,609
code for the k-means for the k-means

00:38:57,559 --> 00:39:16,770
algorithm yeah you you can we look at it

00:39:02,609 --> 00:39:18,089
now the next one cool I mean if no one

00:39:16,770 --> 00:39:20,010
else has any questions would you would

00:39:18,089 --> 00:39:26,819
you go through it and explain it in more

00:39:20,010 --> 00:39:29,430
detail I mean I mean I've already

00:39:26,819 --> 00:39:32,220
explained what i will do again the first

00:39:29,430 --> 00:39:35,640
thing is that you you what you do is

00:39:32,220 --> 00:39:38,760
that you you select your k items from

00:39:35,640 --> 00:39:42,510
from an item and then you call them that

00:39:38,760 --> 00:39:45,059
it's it's your centroid yeah and then

00:39:42,510 --> 00:39:52,980
and then you and then you and then you

00:39:45,059 --> 00:39:56,490
form this mt mt k clusters here yeah and

00:39:52,980 --> 00:39:59,190
then you and then you and then you take

00:39:56,490 --> 00:40:02,460
your old items which you want to group

00:39:59,190 --> 00:40:05,700
and then you and then you pass it

00:40:02,460 --> 00:40:08,970
through the centroid one by one ready

00:40:05,700 --> 00:40:12,000
and and and then you compare distance

00:40:08,970 --> 00:40:15,770
between the item and the centroid of one

00:40:12,000 --> 00:40:20,430
by one okay and and it's here and if its

00:40:15,770 --> 00:40:22,920
end if it's smaller than your and if

00:40:20,430 --> 00:40:28,109
it's smaller than your threshold then

00:40:22,920 --> 00:40:30,690
you just attach it to the thresholds

00:40:28,109 --> 00:40:33,180
Commission it's not it's not exactly

00:40:30,690 --> 00:40:36,569
k-means because in k mean there is no no

00:40:33,180 --> 00:40:39,599
concept of threshold so it's the key

00:40:36,569 --> 00:40:41,220
because your your data is I mean you

00:40:39,599 --> 00:40:43,089
your data is new vertical and you don't

00:40:41,220 --> 00:40:46,779
want to say that I have hundred news and

00:40:43,089 --> 00:40:49,029
and I want to form five cluster out of

00:40:46,779 --> 00:40:51,910
it it makes no sense so you you so you

00:40:49,029 --> 00:40:54,519
so you need to make I I want something

00:40:51,910 --> 00:41:01,660
which looks similar and the similarity

00:40:54,519 --> 00:41:05,619
between them should be a put twenty

00:41:01,660 --> 00:41:11,999
percent okay so if you do if you do that

00:41:05,619 --> 00:41:11,999
way then you can you avoid hoping the

00:41:21,329 --> 00:41:26,619
still on the code is there an upper

00:41:23,890 --> 00:41:30,549
bound for the conveyor is there an upper

00:41:26,619 --> 00:41:34,960
bound on the convergence how how do you

00:41:30,549 --> 00:41:38,950
compute it well yes there is and I mean

00:41:34,960 --> 00:41:41,920
okay it's a if you know k-means

00:41:38,950 --> 00:41:46,390
algorithm them it's actually look the

00:41:41,920 --> 00:41:53,589
lower bound is big oh NM + b and these

00:41:46,390 --> 00:41:59,289
were dimension of your if it's quite

00:41:53,589 --> 00:42:01,630
hard when you have very funny I mean why

00:41:59,289 --> 00:42:05,049
not using the upper bound instead of an

00:42:01,630 --> 00:42:08,470
arbitrary number in the algorithm the 50

00:42:05,049 --> 00:42:15,760
c I mean you can success suddenly you do

00:42:08,470 --> 00:42:20,099
that as well it's up to you I already

00:42:15,760 --> 00:42:20,099
did did this app and I did in this way

00:42:22,859 --> 00:42:32,260
it's not it's not really a case if you

00:42:26,200 --> 00:42:34,680
if you know what you are doing ok this

00:42:32,260 --> 00:42:34,680
one do

00:42:37,870 --> 00:42:43,760
hello there so last year at Europe ison

00:42:41,030 --> 00:42:46,250
i did a lightning talk on a face

00:42:43,760 --> 00:42:48,950
tracking robot and then ran a birds of a

00:42:46,250 --> 00:42:50,750
feather session on AI I'm guessing since

00:42:48,950 --> 00:42:51,800
a bunch of hands went up for a I earlier

00:42:50,750 --> 00:42:53,090
that maybe they'll be interested in

00:42:51,800 --> 00:42:56,390
running a birds of a feather session

00:42:53,090 --> 00:42:58,340
again this year if i were to sticker an

00:42:56,390 --> 00:43:00,380
event name up on the free space outside

00:42:58,340 --> 00:43:01,910
and the next day or two would anyone be

00:43:00,380 --> 00:43:04,640
interested in getting together and

00:43:01,910 --> 00:43:08,180
talking about whatever AI pod michelle

00:43:04,640 --> 00:43:10,730
sylvan sorry no i haven't got the robot

00:43:08,180 --> 00:43:12,200
was at herald no uh-uh Harold yet no

00:43:10,730 --> 00:43:14,360
don't know Rover this year sorry um

00:43:12,200 --> 00:43:17,270
hands up and he'll be interested in an

00:43:14,360 --> 00:43:19,820
AI birds of a feather session yeah one

00:43:17,270 --> 00:43:22,070
two three okay I'll stick up a talk in

00:43:19,820 --> 00:43:24,340
the next couple of days cool just a

00:43:22,070 --> 00:43:24,340
session

00:43:37,550 --> 00:43:43,410
at the beginning you showed us some

00:43:40,619 --> 00:43:48,060
packages or modern some Python to do

00:43:43,410 --> 00:43:50,760
these kind of things I have a problem in

00:43:48,060 --> 00:43:53,340
one of my application I have to use

00:43:50,760 --> 00:43:56,310
something like business logic let's say

00:43:53,340 --> 00:43:58,410
so which is kindly different from this

00:43:56,310 --> 00:44:01,500
one but this seems to be a different

00:43:58,410 --> 00:44:04,350
approach moving the computation from the

00:44:01,500 --> 00:44:06,210
database to the application it it's good

00:44:04,350 --> 00:44:11,430
for me it's not a machine that can do

00:44:06,210 --> 00:44:13,980
the calculation ok do you know if any of

00:44:11,430 --> 00:44:18,140
those libraries you showed us the list

00:44:13,980 --> 00:44:22,050
or if it's something else which can give

00:44:18,140 --> 00:44:24,869
these machine intelligence to a higher

00:44:22,050 --> 00:44:26,270
level higher level libraries which can

00:44:24,869 --> 00:44:29,100
be used for business intelligence

00:44:26,270 --> 00:44:30,930
because usually when you search for open

00:44:29,100 --> 00:44:33,859
source and business intelligence in my

00:44:30,930 --> 00:44:36,390
experience I was frustrated because

00:44:33,859 --> 00:44:39,960
everyone told me if you want something

00:44:36,390 --> 00:44:44,130
big use pentaho but pentaho is for java

00:44:39,960 --> 00:44:46,920
and i don't want to use java so dizzy

00:44:44,130 --> 00:44:51,359
this seems to be like a lower layer for

00:44:46,920 --> 00:44:56,160
building something up like fufu for IRP

00:44:51,359 --> 00:44:57,930
or i would highly recommend you if you

00:44:56,160 --> 00:44:59,520
have if you have if you haven't used it

00:44:57,930 --> 00:45:03,210
then i would highly recommend you to use

00:44:59,520 --> 00:45:04,859
scikit-learn actually it it covers

00:45:03,210 --> 00:45:08,190
almost eighty percent of the things

00:45:04,859 --> 00:45:15,270
which you which would need for bi so

00:45:08,190 --> 00:45:18,200
it's it's nice it's nice it's more nicer

00:45:15,270 --> 00:45:21,750
than other other like mdp which is very

00:45:18,200 --> 00:45:25,130
strict to some things and the other like

00:45:21,750 --> 00:45:25,130
py brain or

00:45:38,400 --> 00:45:56,740
which one day the kill you kick you in

00:45:49,330 --> 00:45:58,680
the scam it hi i was still wondering you

00:45:56,740 --> 00:46:02,890
showed us how to do k-means clustering

00:45:58,680 --> 00:46:05,619
and then the news site oh and then you

00:46:02,890 --> 00:46:07,210
showed the new site with your only

00:46:05,619 --> 00:46:09,010
calculating distances between the

00:46:07,210 --> 00:46:12,369
storage i guess so how do you do the

00:46:09,010 --> 00:46:15,760
clustering down actually it's it's mum

00:46:12,369 --> 00:46:19,900
it is the same algorithm which i have

00:46:15,760 --> 00:46:22,450
shown it so what but we do what we do is

00:46:19,900 --> 00:46:24,180
that we take i need a news article and

00:46:22,450 --> 00:46:27,220
then we say that until this range

00:46:24,180 --> 00:46:30,730
whatever it comes that it they should

00:46:27,220 --> 00:46:32,410
fall in the same but less true so you

00:46:30,730 --> 00:46:34,000
you find your notes your notes

00:46:32,410 --> 00:46:38,170
calculating centroids anymore pictured

00:46:34,000 --> 00:46:40,060
no no we are doing that so so what we

00:46:38,170 --> 00:46:43,770
are doing is that we find it is between

00:46:40,060 --> 00:46:47,920
centroid and the news article in form a

00:46:43,770 --> 00:46:49,780
group and then but you what you really

00:46:47,920 --> 00:46:51,640
need to do is that you need to see that

00:46:49,780 --> 00:46:55,510
the centroid that you have chosen is

00:46:51,640 --> 00:46:59,260
actually as centroid for that server if

00:46:55,510 --> 00:47:02,920
not then you can you find out reg values

00:46:59,260 --> 00:47:04,570
and then you move it somewhere and and

00:47:02,920 --> 00:47:07,750
then you rerun and then if you see that

00:47:04,570 --> 00:47:11,200
the your group is the same as it was

00:47:07,750 --> 00:47:16,140
before so you say that okay this topic

00:47:11,200 --> 00:47:16,140
so it's it's it's the end okay

00:47:21,650 --> 00:47:24,760
some more questions

00:47:32,230 --> 00:47:38,520

YouTube URL: https://www.youtube.com/watch?v=u3oVf_Z4kmI


