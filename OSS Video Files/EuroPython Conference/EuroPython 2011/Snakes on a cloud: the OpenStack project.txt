Title: Snakes on a cloud: the OpenStack project
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Thierry Carrez - 23 June 2011 in "Track Lasagne"
Captions: 
	00:00:09,360 --> 00:00:13,960
hey so my name is Jerrica hands and the

00:00:12,610 --> 00:00:17,950
release manager for the OpenStack

00:00:13,960 --> 00:00:20,920
project and today i'll talk about snakes

00:00:17,950 --> 00:00:23,050
on a cloud or how we use python to build

00:00:20,920 --> 00:00:29,670
open source cloud infrastructure

00:00:23,050 --> 00:00:31,630
software Wow so there we had a number of

00:00:29,670 --> 00:00:34,690
presentations on cloud stuff already

00:00:31,630 --> 00:00:36,820
this week so you raise your hand if you

00:00:34,690 --> 00:00:45,609
have now a very precise idea of what

00:00:36,820 --> 00:00:48,940
cloud computing is okay so for all the

00:00:45,609 --> 00:00:51,219
others you probably think that a lot of

00:00:48,940 --> 00:00:56,019
different things are actually described

00:00:51,219 --> 00:01:00,159
as cloud and the reason for this is that

00:00:56,019 --> 00:01:01,659
Klaus is a virtual it's it's a very

00:01:00,159 --> 00:01:04,059
trendy Bruce world so if you have

00:01:01,659 --> 00:01:05,950
anything to sell you should probably add

00:01:04,059 --> 00:01:11,760
the world cloud to it like a

00:01:05,950 --> 00:01:11,760
presentation title what pretty well and

00:01:12,600 --> 00:01:19,060
the thing is cloud computing actually

00:01:16,660 --> 00:01:20,800
describes the transition on for the

00:01:19,060 --> 00:01:22,870
computing industry from an industry of

00:01:20,800 --> 00:01:26,080
products to in the industry of services

00:01:22,870 --> 00:01:29,530
and those the services that are blown

00:01:26,080 --> 00:01:32,350
out of the bath transition share two

00:01:29,530 --> 00:01:34,300
main characteristics one is ubiquitous

00:01:32,350 --> 00:01:37,360
so you can access the service from from

00:01:34,300 --> 00:01:40,600
anywhere and from any device and the

00:01:37,360 --> 00:01:42,700
other is elasticity where you the

00:01:40,600 --> 00:01:44,530
services are generally multi-tenant and

00:01:42,700 --> 00:01:46,570
you you don't really have to care about

00:01:44,530 --> 00:01:49,600
the service scaling for to meet your

00:01:46,570 --> 00:01:54,820
needs and you'd usually pay for what you

00:01:49,600 --> 00:01:56,650
use exactly but it's telling muslim with

00:01:54,820 --> 00:01:58,750
services that are geared towards end

00:01:56,650 --> 00:02:02,860
users so with the software as a Service

00:01:58,750 --> 00:02:04,870
says false started by by Austin it's CRM

00:02:02,860 --> 00:02:08,739
solution or pregnant asti platform with

00:02:04,870 --> 00:02:09,160
sirens mission then it was bull dogs and

00:02:08,739 --> 00:02:12,670
then

00:02:09,160 --> 00:02:14,530
almost every website that provides some

00:02:12,670 --> 00:02:16,540
kind of service with Lloyds have cloud

00:02:14,530 --> 00:02:18,820
as well so what gmail is cloud flicker

00:02:16,540 --> 00:02:21,880
is cloud remember the milk is cloud

00:02:18,820 --> 00:02:25,900
twitter is cloud and facebook is cloud

00:02:21,880 --> 00:02:27,550
and everything else is cloud two and the

00:02:25,900 --> 00:02:31,570
other type of end user services is

00:02:27,550 --> 00:02:35,050
online storage and swimming so that's

00:02:31,570 --> 00:02:37,780
what a Dropbox does Amazon Cloud Drive

00:02:35,050 --> 00:02:50,740
which one or the recently announced

00:02:37,780 --> 00:02:59,110
iCloud if this thing is is cloud icon so

00:02:50,740 --> 00:03:01,150
that tells I like this yeah the other

00:02:59,110 --> 00:03:03,700
type of services that are born out of

00:03:01,150 --> 00:03:05,380
cloud computing is our services that are

00:03:03,700 --> 00:03:07,600
geared towards the system integrators

00:03:05,380 --> 00:03:09,940
platform builders or programmers and

00:03:07,600 --> 00:03:12,580
there is a infrastructure as a service

00:03:09,940 --> 00:03:14,709
which is about providing roll compute

00:03:12,580 --> 00:03:17,200
and storage resources that's what Amazon

00:03:14,709 --> 00:03:21,250
Web Services does also a rackspace cloud

00:03:17,200 --> 00:03:24,610
and the other type of back-end services

00:03:21,250 --> 00:03:27,330
is deployment platforms where you can

00:03:24,610 --> 00:03:29,800
basically upload your code and they will

00:03:27,330 --> 00:03:32,350
deploy it for you and scan it for you

00:03:29,800 --> 00:03:35,620
that's what Google App Engine about who

00:03:32,350 --> 00:03:40,930
EP dot IO who are here this week and

00:03:35,620 --> 00:03:43,540
Windows 20 which should be do open

00:03:40,930 --> 00:03:45,520
source that's an interesting point where

00:03:43,540 --> 00:03:47,350
is open source in all this so most of

00:03:45,520 --> 00:03:49,989
the services actually using open source

00:03:47,350 --> 00:03:52,330
building blocks but the software that

00:03:49,989 --> 00:03:54,750
actually are used to run this their

00:03:52,330 --> 00:03:58,120
service is actually closed source and

00:03:54,750 --> 00:04:00,340
the main reason for that is that they

00:03:58,120 --> 00:04:03,130
consider their code the secret sauce

00:04:00,340 --> 00:04:04,630
that enables them to prevent the

00:04:03,130 --> 00:04:09,370
competition from spinning and equivalent

00:04:04,630 --> 00:04:11,620
service with low cost that said some

00:04:09,370 --> 00:04:13,120
companies are starting to see the value

00:04:11,620 --> 00:04:16,560
of developing something in common

00:04:13,120 --> 00:04:20,979
whether than privately separately and

00:04:16,560 --> 00:04:22,049
the main driver of that is sharing

00:04:20,979 --> 00:04:26,060
development costs

00:04:22,049 --> 00:04:29,250
obviously but also the promise of

00:04:26,060 --> 00:04:32,729
creating a new standard and being proud

00:04:29,250 --> 00:04:34,650
of that standard or any on so we're

00:04:32,729 --> 00:04:36,930
we're seeing more month at of that and

00:04:34,650 --> 00:04:39,270
we should probably facilitate this we

00:04:36,930 --> 00:04:42,180
should encourage that thinking because

00:04:39,270 --> 00:04:46,020
for for consumers of the services it's

00:04:42,180 --> 00:04:47,879
it's really good to to create

00:04:46,020 --> 00:04:49,740
competition to eliminate van tulleken

00:04:47,879 --> 00:04:53,280
which is one of the problems of cloud

00:04:49,740 --> 00:04:55,740
services reducing therefore the value of

00:04:53,280 --> 00:04:58,800
adoption and potentially enabling

00:04:55,740 --> 00:05:00,719
Federation of equivalent services that's

00:04:58,800 --> 00:05:04,080
where open source is pretty important in

00:05:00,719 --> 00:05:06,199
that space so over the last year we saw

00:05:04,080 --> 00:05:10,469
the emergence of three projects and

00:05:06,199 --> 00:05:14,909
there is open compute that is pushed by

00:05:10,469 --> 00:05:17,699
my Facebook to open source the hardware

00:05:14,909 --> 00:05:19,710
of the data center design the data

00:05:17,699 --> 00:05:21,930
center hardware design there is

00:05:19,710 --> 00:05:26,690
OpenStack that promises to offer a

00:05:21,930 --> 00:05:29,099
software for it to run cloud

00:05:26,690 --> 00:05:32,310
infrastructure as a service providers

00:05:29,099 --> 00:05:33,840
and cloud foundry promises to address

00:05:32,310 --> 00:05:37,069
the platform as a service space which

00:05:33,840 --> 00:05:39,360
launched by by p.m. where every century

00:05:37,069 --> 00:05:41,759
so we're starting to see open source

00:05:39,360 --> 00:05:44,490
software that can actually be used to

00:05:41,759 --> 00:05:49,259
run the cloud or open source design that

00:05:44,490 --> 00:05:51,389
can be actually used for what this so a

00:05:49,259 --> 00:05:53,750
few words on how the OpenStack project

00:05:51,389 --> 00:05:56,520
started so on one hand you have

00:05:53,750 --> 00:05:58,590
rackspace hosting rackspace hosting runs

00:05:56,520 --> 00:06:00,150
the Rackspace cloud it's an

00:05:58,590 --> 00:06:02,430
infrastructure-as-a-service offer that

00:06:00,150 --> 00:06:06,300
has cloud servers for the compute part

00:06:02,430 --> 00:06:09,569
and cloud files for the storage cloud so

00:06:06,300 --> 00:06:12,449
it was a very successful cloud files was

00:06:09,569 --> 00:06:14,279
written in Python so it it scaled

00:06:12,449 --> 00:06:16,889
horizontally so the success wasn't

00:06:14,279 --> 00:06:18,599
really so much of an issue Cloud Servers

00:06:16,889 --> 00:06:21,180
is starting to see its limits in the

00:06:18,599 --> 00:06:24,840
design so they wanted to rewrite it in

00:06:21,180 --> 00:06:27,210
pattern and so that it would be always

00:06:24,840 --> 00:06:29,370
on to be scalable and so that it can

00:06:27,210 --> 00:06:32,909
meet the needs of tomorrow they also

00:06:29,370 --> 00:06:34,589
impelled decided in May 2010 to open

00:06:32,909 --> 00:06:35,190
source the software and behind their

00:06:34,589 --> 00:06:40,560
infrastructure

00:06:35,190 --> 00:06:43,230
for the reasons I outlined above on the

00:06:40,560 --> 00:06:45,540
other hand you had NASA NASA was

00:06:43,230 --> 00:06:47,910
building a US government private cloud

00:06:45,540 --> 00:06:50,280
for hosting government sites and do

00:06:47,910 --> 00:06:53,970
heavy calculation on hon like pictures

00:06:50,280 --> 00:06:55,680
of stars and to overcome the limits of

00:06:53,970 --> 00:06:57,570
the software they were using this study

00:06:55,680 --> 00:07:02,040
to provide their own cloud compute

00:06:57,570 --> 00:07:06,300
software in invitin and their release

00:07:02,040 --> 00:07:08,880
did in May 2010 2 released an early

00:07:06,300 --> 00:07:14,220
version of it called Nova CC written in

00:07:08,880 --> 00:07:16,470
Python and apache licensed some people

00:07:14,220 --> 00:07:18,720
notice the potential for for convergence

00:07:16,470 --> 00:07:20,730
between the two projects in particular

00:07:18,720 --> 00:07:22,380
the architecture for the compute boat

00:07:20,730 --> 00:07:25,410
was remarkably similar between the right

00:07:22,380 --> 00:07:28,650
space project and what nasa put out in

00:07:25,410 --> 00:07:31,560
the open and both were waiting tightened

00:07:28,650 --> 00:07:33,330
so they talk to each other and they

00:07:31,560 --> 00:07:36,240
decide decided to form a common project

00:07:33,330 --> 00:07:38,520
will OpenStack where you would get take

00:07:36,240 --> 00:07:40,290
the code from the / CC for the compute

00:07:38,520 --> 00:07:42,930
power and the code fall from Cloud Files

00:07:40,290 --> 00:07:46,820
running in production at Rackspace for

00:07:42,930 --> 00:07:46,820
for the storage go under the name Swift

00:07:46,880 --> 00:07:52,980
the mission statement for the OpenStack

00:07:49,590 --> 00:07:54,480
project is to produce the liquidus open

00:07:52,980 --> 00:07:56,070
source cloud computing platform that

00:07:54,480 --> 00:07:58,169
will meet the needs of public and

00:07:56,070 --> 00:08:00,140
private cloud providers regardless of

00:07:58,169 --> 00:08:04,140
size by being simple to implement and

00:08:00,140 --> 00:08:06,720
massively scalable so we did that the

00:08:04,140 --> 00:08:11,880
the project was founded on four basic

00:08:06,720 --> 00:08:14,040
principle suppose open source so it's

00:08:11,880 --> 00:08:16,260
apache license and we promise not to do

00:08:14,040 --> 00:08:18,480
open court you have an enterprise

00:08:16,260 --> 00:08:23,220
edition that has all the interesting

00:08:18,480 --> 00:08:25,950
stuff everything is is in the call in

00:08:23,220 --> 00:08:27,930
the in the apache license code open

00:08:25,950 --> 00:08:29,490
design we design summits every six

00:08:27,930 --> 00:08:31,950
months and there are the model of room

00:08:29,490 --> 00:08:34,349
to design some it so everyone can can

00:08:31,950 --> 00:08:37,530
can come and one can submit blueprints

00:08:34,349 --> 00:08:38,729
for new ideas of features which you open

00:08:37,530 --> 00:08:40,469
development with your heavy use of

00:08:38,729 --> 00:08:42,659
distributed version control system

00:08:40,469 --> 00:08:43,070
anyone can propose a branch for merging

00:08:42,659 --> 00:08:44,960
in

00:08:43,070 --> 00:08:47,030
and we do the code reviews in the open

00:08:44,960 --> 00:08:50,990
as well so you know why your code is not

00:08:47,030 --> 00:08:53,120
accepted or accepted and we do up and

00:08:50,990 --> 00:08:54,650
community we have all the discussions in

00:08:53,120 --> 00:08:56,930
public channels we have community

00:08:54,650 --> 00:08:59,450
elected technical leads for the project

00:08:56,930 --> 00:09:03,140
we have community elected seats on the

00:08:59,450 --> 00:09:04,850
project goal it's it's very much under

00:09:03,140 --> 00:09:09,610
the model of the Apache foundation for

00:09:04,850 --> 00:09:13,700
those who know about it I penis open but

00:09:09,610 --> 00:09:15,650
almost one thing to keep in mind that

00:09:13,700 --> 00:09:18,650
it's a very young project it's been one

00:09:15,650 --> 00:09:21,820
year since since it started we had three

00:09:18,650 --> 00:09:28,910
design summits we had three releases

00:09:21,820 --> 00:09:30,590
it's about yeah one year now I guess it

00:09:28,910 --> 00:09:32,630
it's a young project but it attracted

00:09:30,590 --> 00:09:35,660
all have in debt of attention there are

00:09:32,630 --> 00:09:37,880
about 100 developers now that have

00:09:35,660 --> 00:09:40,780
committed code one of the core projects

00:09:37,880 --> 00:09:43,850
of OpenStack with well-known names

00:09:40,780 --> 00:09:46,370
though is it or not the usual picture of

00:09:43,850 --> 00:09:48,890
OpenStack partners which are not people

00:09:46,370 --> 00:09:51,320
committing code just people giving us a

00:09:48,890 --> 00:09:53,240
logo these are people that have actually

00:09:51,320 --> 00:09:58,310
developers on payroll committing code so

00:09:53,240 --> 00:10:01,790
that's so that we all want a few words

00:09:58,310 --> 00:10:04,130
on on our design and coding standards so

00:10:01,790 --> 00:10:07,190
scalability and elasticity are all main

00:10:04,130 --> 00:10:09,680
goals features that clean it's all goals

00:10:07,190 --> 00:10:12,860
must be optional everything should be a

00:10:09,680 --> 00:10:15,020
synchronous main component should be a

00:10:12,860 --> 00:10:18,230
reason to be scalable we should always

00:10:15,020 --> 00:10:21,140
use share nothing or shouting we should

00:10:18,230 --> 00:10:23,870
distribute everything especially logic

00:10:21,140 --> 00:10:26,660
and move logic where state that you

00:10:23,870 --> 00:10:28,520
really exist if you'll accept eventual

00:10:26,660 --> 00:10:32,030
consistency and embrace it where

00:10:28,520 --> 00:10:35,900
appropriate we should test everything

00:10:32,030 --> 00:10:38,630
it's unit test but also smoke tests that

00:10:35,900 --> 00:10:41,600
actually deploy the code in some that

00:10:38,630 --> 00:10:46,010
that test data center and run a real

00:10:41,600 --> 00:10:47,930
workload on it and we enforce pet 84

00:10:46,010 --> 00:10:50,620
code consistency which is extremely

00:10:47,930 --> 00:10:50,620
important

00:10:52,320 --> 00:10:56,260
so if you're interested in our

00:10:54,250 --> 00:10:58,149
continuous integration solution i invite

00:10:56,260 --> 00:11:01,779
you to come to so on Hanson talk

00:10:58,149 --> 00:11:04,000
tomorrow at noon you will go into more

00:11:01,779 --> 00:11:06,760
detail on how we ensure that that those

00:11:04,000 --> 00:11:08,920
rules are followed before the code

00:11:06,760 --> 00:11:14,440
actually it's the trunk and get built

00:11:08,920 --> 00:11:16,360
into multiple packages but there are

00:11:14,440 --> 00:11:18,279
multiple types of OpenStack projects

00:11:16,360 --> 00:11:20,800
there are the core project without the

00:11:18,279 --> 00:11:22,839
one we actually care about and there are

00:11:20,800 --> 00:11:26,860
three of them now Nova for compute

00:11:22,839 --> 00:11:28,480
glands for handling disk images Swift

00:11:26,860 --> 00:11:31,060
for storage and I will go into more

00:11:28,480 --> 00:11:33,250
details on each of those in the next

00:11:31,060 --> 00:11:36,220
slide we also have an incubation process

00:11:33,250 --> 00:11:39,610
it was very similar to the apache

00:11:36,220 --> 00:11:42,100
foundation incubation process it's

00:11:39,610 --> 00:11:44,800
usually project that we would like to

00:11:42,100 --> 00:11:47,500
have in esco projects Sunday but are not

00:11:44,800 --> 00:11:49,389
ready yet so there is a common intent

00:11:47,500 --> 00:11:51,040
occasion from work for that will be

00:11:49,389 --> 00:11:54,160
shared among all the all the core

00:11:51,040 --> 00:11:57,850
projects there is a jungle based web UI

00:11:54,160 --> 00:12:03,220
called dashboard and we are also

00:11:57,850 --> 00:12:04,720
building a few service for starting to

00:12:03,220 --> 00:12:07,000
address the platform as a service space

00:12:04,720 --> 00:12:13,540
under the name borough those are all the

00:12:07,000 --> 00:12:15,970
Python project already cycled is time

00:12:13,540 --> 00:12:17,980
based we recently moved to a six-month

00:12:15,970 --> 00:12:19,389
sweaty cycle we usually we used to have

00:12:17,980 --> 00:12:21,130
three months for this cycle but it was a

00:12:19,389 --> 00:12:23,829
bit stressful for the release manager so

00:12:21,130 --> 00:12:26,050
we moved to six and it's a six months

00:12:23,829 --> 00:12:27,790
for a scheduled with the consolidated

00:12:26,050 --> 00:12:30,970
already is of all the projects at the

00:12:27,790 --> 00:12:33,069
same time most of the core project

00:12:30,970 --> 00:12:35,500
actually following a common might come

00:12:33,069 --> 00:12:36,910
on what is schedule because we do six

00:12:35,500 --> 00:12:41,430
months for a schedule with frequent

00:12:36,910 --> 00:12:44,589
milestone in between so then we have a

00:12:41,430 --> 00:12:46,870
towel all the Holy is built every four

00:12:44,589 --> 00:12:50,050
weeks that are that are development

00:12:46,870 --> 00:12:52,630
milestones and the last development my

00:12:50,050 --> 00:12:56,019
son called Diablo for is X to actuate

00:12:52,630 --> 00:12:58,540
for an becomes the final release we also

00:12:56,019 --> 00:13:00,699
have a more stable or independent

00:12:58,540 --> 00:13:03,640
project like Swift who have their own

00:13:00,699 --> 00:13:04,200
independent when a schedule and they ask

00:13:03,640 --> 00:13:05,870
us

00:13:04,200 --> 00:13:09,720
to include the latest version they had

00:13:05,870 --> 00:13:17,040
into into the into the OpenStack comment

00:13:09,720 --> 00:13:19,500
or need but let let's go into more

00:13:17,040 --> 00:13:22,050
detail into what where is those what are

00:13:19,500 --> 00:13:25,380
those projects Swift is the cloud

00:13:22,050 --> 00:13:27,270
storage part its object storage it's not

00:13:25,380 --> 00:13:31,290
block storage so you won't like create a

00:13:27,270 --> 00:13:34,740
file system on it it so you just store

00:13:31,290 --> 00:13:37,920
and retrieve binary blobs it best saw

00:13:34,740 --> 00:13:39,990
through a restful interface there is no

00:13:37,920 --> 00:13:44,250
object size limit except the size of

00:13:39,990 --> 00:13:45,900
your cloud it's because we use segments

00:13:44,250 --> 00:13:47,580
and manifest so you can upload multiple

00:13:45,900 --> 00:13:50,430
parts and then the manifest that ties

00:13:47,580 --> 00:13:52,560
them all together it's dead all and

00:13:50,430 --> 00:13:54,300
deployed in production as Rackspace

00:13:52,560 --> 00:13:57,120
cloud files so you can test that works

00:13:54,300 --> 00:14:04,140
correctly and it scales massively and I

00:13:57,120 --> 00:14:09,150
will explain why Swift as three levels

00:14:04,140 --> 00:14:11,310
of containers there is the account where

00:14:09,150 --> 00:14:13,950
which is usually tied to your credit

00:14:11,310 --> 00:14:16,770
card the container which is like a

00:14:13,950 --> 00:14:19,260
folder and you can store as many objects

00:14:16,770 --> 00:14:21,030
and as many containers that you want and

00:14:19,260 --> 00:14:24,950
you and you have been a flat structure

00:14:21,030 --> 00:14:24,950
of objects that are accessed by name

00:14:26,450 --> 00:14:33,870
which uses rings rings are distributed

00:14:30,330 --> 00:14:36,990
hash tables so you basically partition

00:14:33,870 --> 00:14:39,930
the the the hashing space into into

00:14:36,990 --> 00:14:42,690
smaller bits and and that allows you to

00:14:39,930 --> 00:14:44,310
map well we'll see how we use them this

00:14:42,690 --> 00:14:48,120
is an example of a ring with eight

00:14:44,310 --> 00:14:51,800
partitions so anything that past 10 to 1

00:14:48,120 --> 00:14:57,380
ffffff falls into the first partition as

00:14:51,800 --> 00:14:57,380
everyone know about tht is already yes

00:14:58,480 --> 00:15:04,480
so how does it work when you stole an

00:15:01,120 --> 00:15:06,880
object in Swift you use a cool like this

00:15:04,480 --> 00:15:10,360
put / API version / the name of the

00:15:06,880 --> 00:15:13,029
account / container / object and what

00:15:10,360 --> 00:15:16,480
Swift does is it takes the account /

00:15:13,029 --> 00:15:20,050
containers a / object pot builds an md5

00:15:16,480 --> 00:15:23,980
sum out of it looks at this md5 sum on

00:15:20,050 --> 00:15:26,260
to the object ring and then it folds

00:15:23,980 --> 00:15:29,589
into one of the partition and this

00:15:26,260 --> 00:15:32,079
partition is linked to three a unique

00:15:29,589 --> 00:15:35,350
set of three servers and that gives you

00:15:32,079 --> 00:15:38,560
the servers where the data will actually

00:15:35,350 --> 00:15:40,690
be stored so the files received by a

00:15:38,560 --> 00:15:43,240
proxy server the processor looks up

00:15:40,690 --> 00:15:45,670
where the files should be stored on a

00:15:43,240 --> 00:15:49,720
local copy of the ring and then stores

00:15:45,670 --> 00:15:51,279
the object into the three servers the

00:15:49,720 --> 00:15:53,500
idea is to have those three servers in

00:15:51,279 --> 00:15:57,399
three separate zones zones can be like a

00:15:53,500 --> 00:16:02,980
switch or a rack or a data center based

00:15:57,399 --> 00:16:04,930
on on on how lucky you are and and that

00:16:02,980 --> 00:16:08,350
handles running what an NC for you so

00:16:04,930 --> 00:16:11,139
you don't have to have pricey object

00:16:08,350 --> 00:16:15,190
servers with crazy red cards on anything

00:16:11,139 --> 00:16:16,720
this is what ensures redundancy so

00:16:15,190 --> 00:16:20,199
that's pretty cool because it's scales

00:16:16,720 --> 00:16:23,310
recently but there is a problem if you

00:16:20,199 --> 00:16:25,990
want to choose to actually list the

00:16:23,310 --> 00:16:29,260
objects that are in a container you

00:16:25,990 --> 00:16:31,120
don't have a sense for index that stores

00:16:29,260 --> 00:16:33,459
everything wherever fans because then it

00:16:31,120 --> 00:16:37,079
defeats the whole purpose of using rings

00:16:33,459 --> 00:16:41,680
so that's where Swift juice is a trick

00:16:37,079 --> 00:16:44,319
it uses another ring so to list objects

00:16:41,680 --> 00:16:48,040
in a container you do get / API version

00:16:44,319 --> 00:16:49,990
/ account / container and what sweet

00:16:48,040 --> 00:16:52,899
does that takes account / container

00:16:49,990 --> 00:16:54,819
turns it into an md5 son looks it up on

00:16:52,899 --> 00:16:57,610
a separate train called the containers

00:16:54,819 --> 00:16:59,050
ring and find the three servers that

00:16:57,610 --> 00:17:03,880
will actually contain the listing of

00:16:59,050 --> 00:17:06,069
your object and you do the same to list

00:17:03,880 --> 00:17:09,030
containers in an account to get the list

00:17:06,069 --> 00:17:09,030
of containers in an account

00:17:09,179 --> 00:17:15,009
for your deployment looks like this you

00:17:12,130 --> 00:17:18,850
have proxy servers each of those have

00:17:15,009 --> 00:17:21,039
copies of the three rings and you cannot

00:17:18,850 --> 00:17:22,750
have many of them a few months since you

00:17:21,039 --> 00:17:24,939
want to handle with the client load and

00:17:22,750 --> 00:17:27,069
then you deploy object servers container

00:17:24,939 --> 00:17:29,970
servers and the count servers in three

00:17:27,069 --> 00:17:32,710
at least read three separate zones and

00:17:29,970 --> 00:17:34,600
it's scales horizontally and you can use

00:17:32,710 --> 00:17:38,980
commodity hardware actually cheap you

00:17:34,600 --> 00:17:41,289
can use crappy disks it works there are

00:17:38,980 --> 00:17:44,379
a few other companies the account Reaper

00:17:41,289 --> 00:17:47,230
actually looks up for dead accounts of

00:17:44,379 --> 00:17:49,500
people that don't pay and we move all

00:17:47,230 --> 00:17:53,169
their all their objects you're better

00:17:49,500 --> 00:17:55,149
actually takes care of when one server

00:17:53,169 --> 00:17:57,429
doesn't answer there is a fallback

00:17:55,149 --> 00:17:59,350
server that fullback server will will

00:17:57,429 --> 00:18:02,559
use the updater will use those small

00:17:59,350 --> 00:18:04,740
fullback servers to copy the data back

00:18:02,559 --> 00:18:08,769
onto the server der deutschen observer

00:18:04,740 --> 00:18:10,330
and your dealers are quoting the object

00:18:08,769 --> 00:18:15,909
space just making sure that random

00:18:10,330 --> 00:18:19,570
objects and still be accessed that was

00:18:15,909 --> 00:18:22,690
Swift next project is glance so glance

00:18:19,570 --> 00:18:24,970
is the image service it's about

00:18:22,690 --> 00:18:27,940
discovering registering and retrieving

00:18:24,970 --> 00:18:29,620
disk images and associated metadata so

00:18:27,940 --> 00:18:32,679
it's a very special service it's very

00:18:29,620 --> 00:18:34,389
it's much smaller than the others it

00:18:32,679 --> 00:18:37,090
supports multiple disc formats it

00:18:34,389 --> 00:18:41,379
supports multiple container formats go

00:18:37,090 --> 00:18:43,990
into details here is the architecture

00:18:41,379 --> 00:18:45,940
slide so you have glenn's API which

00:18:43,990 --> 00:18:48,399
received the request from the clients

00:18:45,940 --> 00:18:52,210
the clients are talking a restful api

00:18:48,399 --> 00:18:57,070
called the glens api we are providing a

00:18:52,210 --> 00:18:59,259
CLI 20 glands and also a glance client

00:18:57,070 --> 00:19:02,259
python library if you want to roll you

00:18:59,259 --> 00:19:06,700
on but anything that actually speaks to

00:19:02,259 --> 00:19:09,730
rest glance api is quite easy to write

00:19:06,700 --> 00:19:12,549
your own client for it so Glenn's API

00:19:09,730 --> 00:19:15,909
received a request it uses an internal

00:19:12,549 --> 00:19:17,510
restful api called the registry api to

00:19:15,909 --> 00:19:19,160
inquiry

00:19:17,510 --> 00:19:22,730
metadata information or location

00:19:19,160 --> 00:19:24,260
information about the disk images so we

00:19:22,730 --> 00:19:25,910
provide one reference implementation of

00:19:24,260 --> 00:19:27,710
it called the grants registry which has

00:19:25,910 --> 00:19:29,920
an SQL backend but you're free to

00:19:27,710 --> 00:19:33,590
implement you over the crazy no SQL

00:19:29,920 --> 00:19:35,930
version of it as long as it speaks the

00:19:33,590 --> 00:19:38,660
registry API which is rest of year with

00:19:35,930 --> 00:19:40,340
let's say Pia and Glen's API uses

00:19:38,660 --> 00:19:42,170
multiple storage back ends where it

00:19:40,340 --> 00:19:45,230
actually stores the disk image which is

00:19:42,170 --> 00:19:47,630
the large pot so it can use Swift it can

00:19:45,230 --> 00:19:51,170
use Amazon s3 you can use a local file

00:19:47,630 --> 00:19:56,060
system that's useful for tests and it

00:19:51,170 --> 00:19:58,730
can also use HTTP legs but that's only

00:19:56,060 --> 00:20:00,830
your radar then then you basically tell

00:19:58,730 --> 00:20:02,660
glance where to fetch an image that is

00:20:00,830 --> 00:20:04,730
available over the internet and you can

00:20:02,660 --> 00:20:13,280
combine them all I mean they are not

00:20:04,730 --> 00:20:17,630
exclusive last but not least cloud

00:20:13,280 --> 00:20:20,660
compute this is by far the largest it's

00:20:17,630 --> 00:20:23,900
you can think of it as VMs being just

00:20:20,660 --> 00:20:25,880
one API call away it's highly modular

00:20:23,900 --> 00:20:27,770
framework so you have to pick exactly

00:20:25,880 --> 00:20:29,390
the deployment options that you actually

00:20:27,770 --> 00:20:31,760
want to run there are tons of

00:20:29,390 --> 00:20:32,990
hypervisors that we support you actually

00:20:31,760 --> 00:20:35,750
don't want to support all of them at the

00:20:32,990 --> 00:20:37,910
same time it's 200 heavy development

00:20:35,750 --> 00:20:42,260
we're still with factoring things trying

00:20:37,910 --> 00:20:44,570
two separate things out so it's the

00:20:42,260 --> 00:20:46,580
risky to use right now but it's a it's

00:20:44,570 --> 00:20:48,410
it's interesting to test but for

00:20:46,580 --> 00:20:51,140
deployment you better have a good IT

00:20:48,410 --> 00:20:53,420
management team it's used in production

00:20:51,140 --> 00:20:57,230
in NASA nebular cloud currently so it's

00:20:53,420 --> 00:21:00,830
working and white space cloud service is

00:20:57,230 --> 00:21:05,590
expected to go using Nova by before the

00:21:00,830 --> 00:21:08,660
end of the year so needs to be ready

00:21:05,590 --> 00:21:11,980
those are the different components so

00:21:08,660 --> 00:21:16,580
it's also a resin to the e scalable

00:21:11,980 --> 00:21:19,220
componentized system we have API knows

00:21:16,580 --> 00:21:22,070
who are responsible for receiving client

00:21:19,220 --> 00:21:23,470
requests and acting on them scheduler

00:21:22,070 --> 00:21:25,870
nodes that actually

00:21:23,470 --> 00:21:30,789
decide where a given request will

00:21:25,870 --> 00:21:33,580
actually be done a compute node that are

00:21:30,789 --> 00:21:35,230
responsible for the VMS themselves so

00:21:33,580 --> 00:21:37,900
they skinned up the VMS network nodes

00:21:35,230 --> 00:21:40,690
which provide network resources for for

00:21:37,900 --> 00:21:44,289
compute nodes and volume nodes which

00:21:40,690 --> 00:21:46,929
have the can contain block storage or

00:21:44,289 --> 00:21:50,409
interface with logarithms block storage

00:21:46,929 --> 00:21:52,990
and all this is linked to a message

00:21:50,409 --> 00:21:55,600
queue we use rabbitmq and you can add

00:21:52,990 --> 00:21:59,020
any number of of those components that

00:21:55,600 --> 00:22:01,360
is actually needed to care too I have

00:21:59,020 --> 00:22:04,450
your own if you have a relatively low

00:22:01,360 --> 00:22:06,700
number of compute of VMS but a large

00:22:04,450 --> 00:22:09,010
number of api calls then you should

00:22:06,700 --> 00:22:17,530
spill that more api know if it the other

00:22:09,010 --> 00:22:19,480
way around better add compute nodes so

00:22:17,530 --> 00:22:22,179
for example if you ask for a new server

00:22:19,480 --> 00:22:24,130
to be created the client with request

00:22:22,179 --> 00:22:25,960
will be received by the API know the API

00:22:24,130 --> 00:22:28,090
node would put message on the queue

00:22:25,960 --> 00:22:31,150
saying well this sure that should be

00:22:28,090 --> 00:22:33,900
created a scalar node one schedule note

00:22:31,150 --> 00:22:36,490
somewhere would pick up the request and

00:22:33,900 --> 00:22:38,350
apply some internal i'll go ahead and to

00:22:36,490 --> 00:22:42,760
decide where it should be handled and

00:22:38,350 --> 00:22:44,470
put back a message on the q 2 22 that

00:22:42,760 --> 00:22:47,740
compute node that compute node would

00:22:44,470 --> 00:22:51,340
pick up the message on the cube require

00:22:47,740 --> 00:22:53,409
disk images from glands and then ask the

00:22:51,340 --> 00:22:58,059
network node for network resources like

00:22:53,409 --> 00:23:01,510
IP addresses or networks or firewalls

00:22:58,059 --> 00:23:06,580
and and then with finally spin up the vm

00:23:01,510 --> 00:23:09,880
and the api know if the client queries

00:23:06,580 --> 00:23:12,610
for the location of his of his server

00:23:09,880 --> 00:23:16,450
that the system would point in tune to

00:23:12,610 --> 00:23:20,260
the compute node so i said we should

00:23:16,450 --> 00:23:23,010
always share nothing but unfortunately

00:23:20,260 --> 00:23:25,480
no one shares a bit we have a data so

00:23:23,010 --> 00:23:30,909
we're we're trying to get rid of it and

00:23:25,480 --> 00:23:32,850
it's a but its its how to kill so we're

00:23:30,909 --> 00:23:35,250
trying to move as

00:23:32,850 --> 00:23:37,770
to shout as much information as we can

00:23:35,250 --> 00:23:39,450
amount to different nodes and push as

00:23:37,770 --> 00:23:41,520
much information as we can into the

00:23:39,450 --> 00:23:47,010
queue rather than have a central that a

00:23:41,520 --> 00:23:51,180
better store okay it's an interesting

00:23:47,010 --> 00:23:53,340
project what those interested a few

00:23:51,180 --> 00:23:56,430
words on modularity I said it's a highly

00:23:53,340 --> 00:23:58,020
modular framework so the API no hood is

00:23:56,430 --> 00:24:00,320
actually whiskey in there were so you

00:23:58,020 --> 00:24:03,500
can stack up any any authentication

00:24:00,320 --> 00:24:07,740
whatever impressive stuff that you have

00:24:03,500 --> 00:24:10,170
we support to aap is the ec2 and the

00:24:07,740 --> 00:24:13,920
OpenStack API so the ec2 API is what you

00:24:10,170 --> 00:24:16,140
used due to the success of amazon web

00:24:13,920 --> 00:24:18,570
services but we also provide our own

00:24:16,140 --> 00:24:20,130
OpenStack API the reason for this is

00:24:18,570 --> 00:24:23,160
that they don't want to be stuck with

00:24:20,130 --> 00:24:24,900
what Amazon dictates the cloud is we

00:24:23,160 --> 00:24:27,300
actually want to be part of it so if we

00:24:24,900 --> 00:24:29,010
have a shiny new feature with we want to

00:24:27,300 --> 00:24:31,500
expose it to our users and that's why we

00:24:29,010 --> 00:24:33,480
we have the OpenStack idea and we

00:24:31,500 --> 00:24:36,510
support multiple authentication plug ins

00:24:33,480 --> 00:24:38,550
database held up but that should be

00:24:36,510 --> 00:24:40,890
replaced by by the Keystone project

00:24:38,550 --> 00:24:44,100
which will have a database and out the

00:24:40,890 --> 00:24:45,840
back end that's the idea that you will

00:24:44,100 --> 00:24:49,050
be able to share tokens between the

00:24:45,840 --> 00:24:51,150
different organs are called Project the

00:24:49,050 --> 00:24:54,270
scheduler node is uses a pluggable

00:24:51,150 --> 00:24:56,010
algorithm we provide two of them chance

00:24:54,270 --> 00:24:57,720
which is basically run Robin and the

00:24:56,010 --> 00:25:00,870
zone aware scheduler I think there are

00:24:57,720 --> 00:25:02,820
thirty third one now but it's just a

00:25:00,870 --> 00:25:06,360
matter of extending a class two to

00:25:02,820 --> 00:25:09,360
provide your own logic the trim is

00:25:06,360 --> 00:25:12,720
actually aimed should be nem 2pq it's

00:25:09,360 --> 00:25:14,250
not like type 2 rabbitmq the data store

00:25:12,720 --> 00:25:17,450
or you can use SQLite for like

00:25:14,250 --> 00:25:19,770
development set up mysql postgres

00:25:17,450 --> 00:25:24,720
network node we support three network

00:25:19,770 --> 00:25:26,550
modes ipv4 and ipv6 for the compute node

00:25:24,720 --> 00:25:32,100
we support the large number of

00:25:26,550 --> 00:25:35,490
hypervisors so qemu kvm UML at XC zhen

00:25:32,100 --> 00:25:39,240
zhen server microsoft hyper-v freeway we

00:25:35,490 --> 00:25:43,650
want to vmware is vmware vsphere which

00:25:39,240 --> 00:25:45,900
is same thing and for volume nodes with

00:25:43,650 --> 00:25:48,090
support local lvm vol volume groups

00:25:45,900 --> 00:25:52,350
promote I scuzzy storage Doug

00:25:48,090 --> 00:25:53,910
volumes and H peace and that's what I

00:25:52,350 --> 00:25:56,340
meant by lots of different options you

00:25:53,910 --> 00:25:59,150
don't want to run everything on the

00:25:56,340 --> 00:26:03,120
center at the same time you have to take

00:25:59,150 --> 00:26:07,070
based on your name coming up in the next

00:26:03,120 --> 00:26:10,800
release of Nova we're actually please

00:26:07,070 --> 00:26:13,950
simplifying in over to separate some

00:26:10,800 --> 00:26:15,570
functionality out of it so we're we plan

00:26:13,950 --> 00:26:18,060
to separate the block storage service

00:26:15,570 --> 00:26:20,130
the volume the volume notes that you've

00:26:18,060 --> 00:26:22,560
seen so that they answer that one

00:26:20,130 --> 00:26:24,890
restful api and that Nova would use it

00:26:22,560 --> 00:26:27,950
to call it that's a project called lunar

00:26:24,890 --> 00:26:30,270
and we hope that it would be

00:26:27,950 --> 00:26:33,270
sufficiently complete so that it can be

00:26:30,270 --> 00:26:35,340
an option for for for Nova bye-bye sep

00:26:33,270 --> 00:26:38,670
tember 22 which is the date of w's of

00:26:35,340 --> 00:26:41,900
this version we also plan to separate

00:26:38,670 --> 00:26:45,540
network services we have a number of

00:26:41,900 --> 00:26:47,940
projects that will spawn a function that

00:26:45,540 --> 00:26:52,110
provides the network api that would be

00:26:47,940 --> 00:26:53,700
used by the cloud compute did so you

00:26:52,110 --> 00:26:55,560
could request an IP address you could

00:26:53,700 --> 00:26:57,720
request an elastic IP address you could

00:26:55,560 --> 00:27:01,140
request the network and connect them and

00:26:57,720 --> 00:27:04,260
etc minerals which is a network resource

00:27:01,140 --> 00:27:08,940
registry so like an IP address directory

00:27:04,260 --> 00:27:10,550
and Donna Bay which addresses a complex

00:27:08,940 --> 00:27:13,830
network container so you can just

00:27:10,550 --> 00:27:17,490
describe your your network configuration

00:27:13,830 --> 00:27:18,660
and they will donate to actually make it

00:27:17,490 --> 00:27:22,950
happen with the very intelligent

00:27:18,660 --> 00:27:26,690
switches and finally Keystone already

00:27:22,950 --> 00:27:28,740
mentioned so trying to have all those

00:27:26,690 --> 00:27:32,310
projects use the same authentication

00:27:28,740 --> 00:27:34,260
mechanism also will have snapshot clone

00:27:32,310 --> 00:27:35,490
and boot form volumes distributed

00:27:34,260 --> 00:27:38,430
scheduling because we have the notion

00:27:35,490 --> 00:27:40,740
that the idea of zones now we should

00:27:38,430 --> 00:27:44,600
hopefully complete the OpenStack API 1

00:27:40,740 --> 00:27:50,210
dot 1 and we should hopefully have

00:27:44,600 --> 00:27:53,130
configuration drives which are like data

00:27:50,210 --> 00:27:55,620
disks that are mounted on the vmsu spoon

00:27:53,130 --> 00:27:56,429
that content data that the user provides

00:27:55,620 --> 00:27:59,179
so that

00:27:56,429 --> 00:28:04,429
to communicate with your instance and

00:27:59,179 --> 00:28:08,100
customize it before its funds okay I

00:28:04,429 --> 00:28:11,610
think why do we use pattern there was a

00:28:08,100 --> 00:28:16,740
good plenary talk on what makes Python

00:28:11,610 --> 00:28:19,679
awesome on Monday what makes Titan

00:28:16,740 --> 00:28:22,499
awesome for us at least for me is that

00:28:19,679 --> 00:28:25,440
our users are not end users but now not

00:28:22,499 --> 00:28:27,360
really programmers either so having a

00:28:25,440 --> 00:28:31,499
language that is easy to learn that is

00:28:27,360 --> 00:28:36,690
easy to read and easy to patch for

00:28:31,499 --> 00:28:39,269
season means that that brings the the

00:28:36,690 --> 00:28:41,759
users of our software are actually able

00:28:39,269 --> 00:28:44,220
to contribute patches back and that

00:28:41,759 --> 00:28:46,259
that's the main I mean for me that's the

00:28:44,220 --> 00:28:48,539
main feature of Python that that that is

00:28:46,259 --> 00:28:50,480
relevant here it's that it's a community

00:28:48,539 --> 00:28:52,980
enabler it's really useful to have a

00:28:50,480 --> 00:28:54,720
simple language that that people can

00:28:52,980 --> 00:28:59,909
actually run in in one day or one week

00:28:54,720 --> 00:29:01,860
and start contributing bug fixes but

00:28:59,909 --> 00:29:04,889
it's also because there are lots of very

00:29:01,860 --> 00:29:09,179
interesting libraries so we're using

00:29:04,889 --> 00:29:11,639
libvirt especially for having this weird

00:29:09,179 --> 00:29:13,889
collection of hypervisors so liberal

00:29:11,639 --> 00:29:17,149
provides for us the direction layer that

00:29:13,889 --> 00:29:22,440
allows us to have those many many

00:29:17,149 --> 00:29:26,009
hypervisors win for concurrency we're

00:29:22,440 --> 00:29:28,679
using even flat so that was a big debate

00:29:26,009 --> 00:29:32,249
twisted versus even led at one of our

00:29:28,679 --> 00:29:34,649
design summits and we settled on event

00:29:32,249 --> 00:29:38,519
led which was used by like half of the

00:29:34,649 --> 00:29:40,710
project mostly because it's easier for

00:29:38,519 --> 00:29:44,100
someone that doesn't know anything about

00:29:40,710 --> 00:29:50,580
about concurrency to use while twisted

00:29:44,100 --> 00:29:52,049
you have to think the twisted way we use

00:29:50,580 --> 00:29:54,629
pest deploy for the whiskey

00:29:52,049 --> 00:29:57,149
configuration handling we use a web up

00:29:54,629 --> 00:30:00,690
to encapsulate West funds and request

00:29:57,149 --> 00:30:03,619
object we use routes for setting up

00:30:00,690 --> 00:30:08,780
because we're lazy to set up the rest

00:30:03,619 --> 00:30:11,210
endpoint we're using coward

00:30:08,780 --> 00:30:13,550
to interact with the queue it together

00:30:11,210 --> 00:30:15,680
with MSHA period workout has been

00:30:13,550 --> 00:30:19,430
discontinued so we probably need to move

00:30:15,680 --> 00:30:22,250
to kombu now we use SQL alchemy for

00:30:19,430 --> 00:30:27,500
interaction of at the at the data store

00:30:22,250 --> 00:30:29,510
layer in in the Three project and we use

00:30:27,500 --> 00:30:31,520
SQL alchemy migrate to migrate the

00:30:29,510 --> 00:30:33,560
scheme of the database schema from one

00:30:31,520 --> 00:30:39,340
version to another every time we change

00:30:33,560 --> 00:30:43,550
the schema and as far as plumbing goes

00:30:39,340 --> 00:30:48,080
we're using standard logging standard

00:30:43,550 --> 00:30:52,250
HTTP leed standard J'son we're using

00:30:48,080 --> 00:30:55,120
bodo to talk s3 with amazon we're using

00:30:52,250 --> 00:30:58,100
em to crypto for anything cryptographic

00:30:55,120 --> 00:31:01,520
Nova is using g flags for for

00:30:58,100 --> 00:31:07,820
configuration files but I think we are

00:31:01,520 --> 00:31:09,710
going to move away from that so well

00:31:07,820 --> 00:31:12,620
we're going to come and join the fence

00:31:09,710 --> 00:31:15,710
the very open project a few min URLs for

00:31:12,620 --> 00:31:17,150
you we are very active on IRC so there

00:31:15,710 --> 00:31:20,390
is the OpenStack channel which is more

00:31:17,150 --> 00:31:23,390
like a user user of the software and the

00:31:20,390 --> 00:31:26,090
OpenStack death where were the

00:31:23,390 --> 00:31:29,330
development discussions happen we have

00:31:26,090 --> 00:31:31,130
weekly team meetings on IRC to its tip

00:31:29,330 --> 00:31:35,930
it inconvenient for Europeans it's like

00:31:31,130 --> 00:31:37,550
it 11 p.m. on Tuesdays and we have a

00:31:35,930 --> 00:31:44,620
mailing list to Santa mailing list for

00:31:37,550 --> 00:31:44,620
all our discussions that's it

00:31:53,990 --> 00:32:05,550
are there okay thank you I saw up and

00:32:03,510 --> 00:32:09,330
stop implements many amazon and

00:32:05,550 --> 00:32:11,520
rackspace feature of the API is level

00:32:09,330 --> 00:32:15,420
what are the future plans of these

00:32:11,520 --> 00:32:19,560
different approaches did you repeat your

00:32:15,420 --> 00:32:23,040
question yes I saw OpenStack implements

00:32:19,560 --> 00:32:27,720
many amazon and rackspace features at

00:32:23,040 --> 00:32:31,110
the api's level the future plans for

00:32:27,720 --> 00:32:42,030
these different approaches if you plan

00:32:31,110 --> 00:32:44,870
to bring on both or so we so that the

00:32:42,030 --> 00:32:47,820
OpenStack one dot one API will is

00:32:44,870 --> 00:32:50,940
modeled after the Rackspace cloud when

00:32:47,820 --> 00:32:53,130
the 0 API and plus 65 features that we

00:32:50,940 --> 00:32:56,940
have in in OpenStack so it's a it's a

00:32:53,130 --> 00:32:58,980
superset if you want so we we already

00:32:56,940 --> 00:33:03,590
support the Rackspace cloud when the 0 a

00:32:58,980 --> 00:33:03,590
I think pretty completely

00:33:09,009 --> 00:33:14,299
and we're having a bit of trouble with

00:33:11,600 --> 00:33:16,519
with the API because they are usually

00:33:14,299 --> 00:33:17,570
defined by other groups than the one

00:33:16,519 --> 00:33:21,499
that I've joined you walking on the

00:33:17,570 --> 00:33:23,840
software we need to fix that that as far

00:33:21,499 --> 00:33:27,129
as easy to goes it's a it's a best

00:33:23,840 --> 00:33:31,539
effort to try to match the features in

00:33:27,129 --> 00:33:34,399
in that easy to provides but obviously

00:33:31,539 --> 00:33:36,739
amazon is changing the IP I whenever

00:33:34,399 --> 00:33:39,350
they want and they don't give advance

00:33:36,739 --> 00:33:42,350
notice to anyone but what that will be

00:33:39,350 --> 00:33:43,879
so it's always late in some ways

00:33:42,350 --> 00:33:45,350
sometimes it's not very late sometimes

00:33:43,879 --> 00:33:47,330
it's completely late sometimes its

00:33:45,350 --> 00:33:50,840
features that we don't we won't support

00:33:47,330 --> 00:33:54,139
on TV so but the idea is to support both

00:33:50,840 --> 00:33:56,749
ap is we have especially since we have

00:33:54,139 --> 00:33:59,950
now a winter server that has picked

00:33:56,749 --> 00:34:02,149
OpenStack as their default cloudstack

00:33:59,950 --> 00:34:05,600
and they care about the ec2

00:34:02,149 --> 00:34:08,329
compatibility more than the most of us

00:34:05,600 --> 00:34:10,730
do so they're there they're supposed to

00:34:08,329 --> 00:34:14,179
make sure that we are up to par with

00:34:10,730 --> 00:34:16,609
with general Institute compatibility as

00:34:14,179 --> 00:34:18,859
an example eucalyptus that claims use pc

00:34:16,609 --> 00:34:20,089
to perfect compatibility is not perfect

00:34:18,859 --> 00:34:24,319
either because they suffer from the same

00:34:20,089 --> 00:34:31,490
issue they also have problems keeping up

00:34:24,319 --> 00:34:34,940
with with Amazon Apple question yes is

00:34:31,490 --> 00:34:39,980
there a milestone to improve the

00:34:34,940 --> 00:34:42,049
documentation part so the condition is

00:34:39,980 --> 00:34:44,899
actually quite good when when the

00:34:42,049 --> 00:34:47,569
project are stable and but it's it's

00:34:44,899 --> 00:34:49,909
difficult for that we have technical

00:34:47,569 --> 00:34:54,889
writers and and the community group that

00:34:49,909 --> 00:34:57,380
works with with her the problem is

00:34:54,889 --> 00:35:00,859
keeping up with the pace of changes it's

00:34:57,380 --> 00:35:03,170
squealing going very fast it's like

00:35:00,859 --> 00:35:07,430
thousands of commits sin in one month

00:35:03,170 --> 00:35:09,109
and sometimes well the time it takes for

00:35:07,430 --> 00:35:12,290
them to write the chapter it so it's

00:35:09,109 --> 00:35:16,790
already obsolete so it's a it's

00:35:12,290 --> 00:35:19,890
definitely a concern and there are teams

00:35:16,790 --> 00:35:22,960
now at work space that

00:35:19,890 --> 00:35:25,450
training and provide good good

00:35:22,960 --> 00:35:27,250
documentation so I hope that it would be

00:35:25,450 --> 00:35:30,490
it would be improved but the software

00:35:27,250 --> 00:35:32,560
needs to count down and slow down a bit

00:35:30,490 --> 00:35:36,070
if you want any documentation to be

00:35:32,560 --> 00:35:39,670
accurate so Swift documentation is is is

00:35:36,070 --> 00:35:42,700
okay the inline documentation and

00:35:39,670 --> 00:35:46,240
everything we generated by Sphinx is

00:35:42,700 --> 00:35:50,920
actually quite accurate that the PDF

00:35:46,240 --> 00:36:02,950
books are not that accurate info Nova

00:35:50,920 --> 00:36:05,160
especially up wait with you eka is in

00:36:02,950 --> 00:36:08,800
the development apart in the API is

00:36:05,160 --> 00:36:15,070
often are only the documentation defined

00:36:08,800 --> 00:36:16,780
in the sealer and function oh the API is

00:36:15,070 --> 00:36:19,660
one of the things that are actually well

00:36:16,780 --> 00:36:23,310
documented they OpenStack tenova in the

00:36:19,660 --> 00:36:26,380
Nova part in what so Nova the

00:36:23,310 --> 00:36:30,609
development development part of Nova I

00:36:26,380 --> 00:36:32,230
mean the OpenStack API or yes it depends

00:36:30,609 --> 00:36:33,820
a kiss bi is very well defined the

00:36:32,230 --> 00:36:36,970
problem is do we do we actually

00:36:33,820 --> 00:36:45,070
implement it correctly so correctly but

00:36:36,970 --> 00:36:46,630
the deeper very very very short it can

00:36:45,070 --> 00:36:49,270
always be improved and it's a it's a

00:36:46,630 --> 00:36:52,359
community project so if you're really

00:36:49,270 --> 00:36:54,280
interesting it it's actually the best

00:36:52,359 --> 00:36:58,200
documentation came from from from

00:36:54,280 --> 00:37:02,980
outside of of the developer group and

00:36:58,200 --> 00:37:07,109
paint companies can I build a couplet

00:37:02,980 --> 00:37:10,270
cloud using open stock so get close and

00:37:07,109 --> 00:37:13,080
I build to know open stock the

00:37:10,270 --> 00:37:18,130
relationship between lip cloud now

00:37:13,080 --> 00:37:21,790
favorite hybrid clouds hybrid clouds so

00:37:18,130 --> 00:37:23,470
yeah hybrid clouds you can use public

00:37:21,790 --> 00:37:25,180
clouds you can use private clouds if you

00:37:23,470 --> 00:37:27,070
deploy them inside your firewall and the

00:37:25,180 --> 00:37:29,410
idea behind the hybrid clouds is that

00:37:27,070 --> 00:37:31,330
you you can you can deploy half of it

00:37:29,410 --> 00:37:32,859
well you can move your application from

00:37:31,330 --> 00:37:36,130
the private side

00:37:32,859 --> 00:37:37,630
cybers to the public cloud etc so up and

00:37:36,130 --> 00:37:40,329
stacked is in the neighbor of hybrid

00:37:37,630 --> 00:37:43,019
clouds because it's it's good to just

00:37:40,329 --> 00:37:45,999
say well you're AC to AC I'll compatible

00:37:43,019 --> 00:37:51,910
but it's it's not enough because

00:37:45,999 --> 00:37:54,819
everyone has its own version of the ec2

00:37:51,910 --> 00:37:57,519
API although they are not similar if

00:37:54,819 --> 00:37:59,319
OpenStack wins and becomes the apache of

00:37:57,519 --> 00:38:01,180
the cloud then you will have OpenStack

00:37:59,319 --> 00:38:03,670
clouds everywhere and you can run your

00:38:01,180 --> 00:38:06,130
private cloud with exactly the same code

00:38:03,670 --> 00:38:08,440
as the Rackspace and others and then

00:38:06,130 --> 00:38:10,390
it's like two compatibilities not just

00:38:08,440 --> 00:38:12,069
like well this API it looks like it's

00:38:10,390 --> 00:38:14,980
the same and it's look looks like it's

00:38:12,069 --> 00:38:17,140
from 99 dot nine percent correct it's

00:38:14,980 --> 00:38:21,190
it's about running exactly the same code

00:38:17,140 --> 00:38:24,609
so i hope that OpenStack will facilitate

00:38:21,190 --> 00:38:27,279
the diversions of hybrid clouds and make

00:38:24,609 --> 00:38:29,710
them and the emotions of Federation of

00:38:27,279 --> 00:38:31,390
clouds of cloud markets so that you can

00:38:29,710 --> 00:38:35,410
compare the prices and the services of

00:38:31,390 --> 00:38:38,099
each of each provider and drive the cost

00:38:35,410 --> 00:38:41,849
down and break amazon so nobody that's

00:38:38,099 --> 00:38:41,849
my personal goal

00:38:46,150 --> 00:38:56,930
hi before you said that you were using a

00:38:52,309 --> 00:39:00,160
mix off event let and twist it and you

00:38:56,930 --> 00:39:06,680
are now off focusing on on the event let

00:39:00,160 --> 00:39:10,430
but I had a look at the source code for

00:39:06,680 --> 00:39:12,619
Nova and then there are the both two

00:39:10,430 --> 00:39:17,150
things living together is there any

00:39:12,619 --> 00:39:19,250
plans to face out there is a bad or

00:39:17,150 --> 00:39:21,200
twisted or there is one component that I

00:39:19,250 --> 00:39:24,740
didn't mention in the architecture slide

00:39:21,200 --> 00:39:29,359
that is the Nova object store that still

00:39:24,740 --> 00:39:31,510
uses twisted for historical reason it

00:39:29,359 --> 00:39:31,510
doesn't

00:39:45,720 --> 00:39:53,020
yeah what did I start well the object

00:39:51,400 --> 00:39:55,060
store does not use twisted anymore the

00:39:53,020 --> 00:39:57,609
only twisted stuff that's left in the

00:39:55,060 --> 00:39:59,650
code bag is really think it's a couple

00:39:57,609 --> 00:40:01,000
of base classes that we just happened to

00:39:59,650 --> 00:40:03,040
use from twisted than no one has really

00:40:01,000 --> 00:40:04,450
bothered to replace with you know

00:40:03,040 --> 00:40:06,820
something not twisted so we can remove

00:40:04,450 --> 00:40:09,220
the dependency because it's not you know

00:40:06,820 --> 00:40:12,700
doing cool twisted e sort of things it's

00:40:09,220 --> 00:40:15,609
just using I forget what it is it might

00:40:12,700 --> 00:40:19,420
be like a log rotating thing or you know

00:40:15,609 --> 00:40:21,369
just really bad asynchronous related

00:40:19,420 --> 00:40:24,970
stuff so no we don't use twist it

00:40:21,369 --> 00:40:29,920
anymore maybe you look at an old release

00:40:24,970 --> 00:40:33,270
or that's all oh yeah ancient I mean

00:40:29,920 --> 00:40:37,630
it's what we guess weeks old isn't it

00:40:33,270 --> 00:40:40,090
mud semen maybe I mean time flies in to

00:40:37,630 --> 00:40:42,460
keep up

00:40:40,090 --> 00:40:51,000
that's what I meant by under heavy

00:40:42,460 --> 00:40:54,310
development okay I've been seen the

00:40:51,000 --> 00:40:56,680
using the rain so you can point to a

00:40:54,310 --> 00:41:01,420
disk a resource I mean I mean a part of

00:40:56,680 --> 00:41:04,480
your storage I'm coming from the account

00:41:01,420 --> 00:41:07,410
and the container so you can buy into

00:41:04,480 --> 00:41:10,120
the correct data you you mean for your

00:41:07,410 --> 00:41:12,700
current upon machine you are running at

00:41:10,120 --> 00:41:16,000
the moment everything that you have for

00:41:12,700 --> 00:41:19,330
insta three times the same data in the

00:41:16,000 --> 00:41:22,780
inside replicated three or a number of

00:41:19,330 --> 00:41:27,940
times of replicas of the same as the

00:41:22,780 --> 00:41:30,520
same data they they are kept in any case

00:41:27,940 --> 00:41:34,090
at current you re work with one single

00:41:30,520 --> 00:41:37,480
single instance and the other two are

00:41:34,090 --> 00:41:39,130
kept aligned with it also hear

00:41:37,480 --> 00:41:42,760
everything that you have you declared

00:41:39,130 --> 00:41:49,960
you have no ray the or no redundancy on

00:41:42,760 --> 00:41:57,340
this data so the MDR the last and how

00:41:49,960 --> 00:42:02,200
can the end you used to move data yes I

00:41:57,340 --> 00:42:07,200
back to the previous one maybe yes I

00:42:02,200 --> 00:42:12,310
mean this in this part of the next one

00:42:07,200 --> 00:42:14,770
next it is ok that's why is this so you

00:42:12,310 --> 00:42:18,790
can point the two zone a zombie or zone

00:42:14,770 --> 00:42:21,670
see according to the no it's not or its

00:42:18,790 --> 00:42:28,560
end is and so in any case you mount data

00:42:21,670 --> 00:42:28,560
from all of the three areas so that

00:42:29,340 --> 00:42:35,260
although I pointed to the image

00:42:32,980 --> 00:42:37,150
partition the partition contains the

00:42:35,260 --> 00:42:38,740
names of the three servers that should

00:42:37,150 --> 00:42:41,290
contain your up directly actually also

00:42:38,740 --> 00:42:43,990
contains two additional servers which

00:42:41,290 --> 00:42:48,490
are the four back servers okay and

00:42:43,990 --> 00:42:51,400
that's the one used when when one or two

00:42:48,490 --> 00:42:54,850
of those servers don't answer right so

00:42:51,400 --> 00:42:58,030
you have five servers with three primary

00:42:54,850 --> 00:43:00,670
servers in and the system make sure that

00:42:58,030 --> 00:43:02,500
you have those three servers notes at

00:43:00,670 --> 00:43:04,840
least three separate zones this is not a

00:43:02,500 --> 00:43:07,240
configurable you can add six or in

00:43:04,840 --> 00:43:10,600
another a number of Libya repeat of the

00:43:07,240 --> 00:43:13,090
data and they are kept alive in any case

00:43:10,600 --> 00:43:15,760
yeah when when the proxy server received

00:43:13,090 --> 00:43:17,500
the put request it actually puts the

00:43:15,760 --> 00:43:20,200
requested synchronous lean onto the

00:43:17,500 --> 00:43:22,450
screen location it's not just one okay

00:43:20,200 --> 00:43:24,400
and that's where the redundancy happens

00:43:22,450 --> 00:43:26,650
it's why we don't really want to care

00:43:24,400 --> 00:43:29,320
about red because that's just one aspect

00:43:26,650 --> 00:43:31,330
of redundancy like they then there is

00:43:29,320 --> 00:43:34,600
power then there is the OS that can just

00:43:31,330 --> 00:43:36,700
do the boom or whatever and so we we

00:43:34,600 --> 00:43:38,590
don't really care we what we want its

00:43:36,700 --> 00:43:43,060
store it in screen separate places and

00:43:38,590 --> 00:43:45,070
and the personal relevancy like this the

00:43:43,060 --> 00:43:46,720
fastest to the replies you can even

00:43:45,070 --> 00:43:48,880
increase the global redundancy by

00:43:46,720 --> 00:43:50,860
setting all those on the white servers

00:43:48,880 --> 00:43:53,850
but the idea is to use shrimp out where

00:43:50,860 --> 00:43:56,980
rather than an expensive one so better

00:43:53,850 --> 00:43:58,480
better not too keen on the web and not

00:43:56,980 --> 00:44:00,580
you create the performance of your

00:43:58,480 --> 00:44:02,410
system and store it in three different

00:44:00,580 --> 00:44:07,060
place this is eventually consistent it's

00:44:02,410 --> 00:44:09,550
not it's not like atomic commit so or

00:44:07,060 --> 00:44:11,170
whatever it stores when when it can and

00:44:09,550 --> 00:44:13,330
then when your trade the data you might

00:44:11,170 --> 00:44:17,940
get if you do it very very fast a

00:44:13,330 --> 00:44:20,830
previous version or okay and it is easy

00:44:17,940 --> 00:44:24,010
the supervisor of these all the old

00:44:20,830 --> 00:44:26,980
stories you can define where the data

00:44:24,010 --> 00:44:31,450
stars are kept in which counter I mean

00:44:26,980 --> 00:44:34,000
anytime we have some knows about keeping

00:44:31,450 --> 00:44:37,500
data in the United unifor instance so

00:44:34,000 --> 00:44:41,350
you can defy that your objects ever be

00:44:37,500 --> 00:44:44,170
the ship or holder of the object server

00:44:41,350 --> 00:44:47,800
for a specific customer must be located

00:44:44,170 --> 00:44:50,890
in a country that that that's why

00:44:47,800 --> 00:44:51,380
Italian telecom is suggesting their own

00:44:50,890 --> 00:44:54,559
class

00:44:51,380 --> 00:44:56,809
that's a new features for swift I know

00:44:54,559 --> 00:45:00,319
the plan to add that to head like Joe

00:44:56,809 --> 00:45:02,990
perfect aware type of queries currently

00:45:00,319 --> 00:45:05,779
it's it's it's tailored to the needs of

00:45:02,990 --> 00:45:08,630
wax paste cloud so it's like a sample a

00:45:05,779 --> 00:45:10,339
unique thing that is running in the US

00:45:08,630 --> 00:45:12,349
or a unique thing that is wandering the

00:45:10,339 --> 00:45:14,119
UK door completely separate so they

00:45:12,349 --> 00:45:17,450
don't really care about about geography

00:45:14,119 --> 00:45:19,970
zones like like like Amazon does but

00:45:17,450 --> 00:45:24,950
they want to they want to have a

00:45:19,970 --> 00:45:26,690
pluggable a way of storing things so so

00:45:24,950 --> 00:45:29,480
that you could use a cluster back in if

00:45:26,690 --> 00:45:30,950
you want to others so I know that the

00:45:29,480 --> 00:45:34,250
end they want to support Geographic

00:45:30,950 --> 00:45:37,849
queries the ring is is a bit more

00:45:34,250 --> 00:45:40,369
complex than I showed obviously because

00:45:37,849 --> 00:45:42,710
it's weighted so the size of your

00:45:40,369 --> 00:45:45,799
partition depends on on if you have

00:45:42,710 --> 00:45:47,839
larger servers obviously you want you

00:45:45,799 --> 00:45:51,950
want them to store more data so it's

00:45:47,839 --> 00:45:53,809
it's a bit waited and it sits there is a

00:45:51,950 --> 00:45:55,730
not flying tool to generate those and

00:45:53,809 --> 00:45:58,400
it's it's it important you can you

00:45:55,730 --> 00:46:00,230
connect the tomb can be generated on all

00:45:58,400 --> 00:46:02,990
those API servers and will return the

00:46:00,230 --> 00:46:04,579
same rings India so whenever going to

00:46:02,990 --> 00:46:06,710
add servers obviously the some

00:46:04,579 --> 00:46:10,970
partitions get split into based on their

00:46:06,710 --> 00:46:13,880
current be able of use it there is lots

00:46:10,970 --> 00:46:16,069
of smart things done by by the script

00:46:13,880 --> 00:46:20,119
frame builder tool to ensure that you

00:46:16,069 --> 00:46:21,980
get the optimal the optimal proud of

00:46:20,119 --> 00:46:23,990
your data but it's it's a bit more

00:46:21,980 --> 00:46:27,970
complex than gently just splitting the

00:46:23,990 --> 00:46:27,970
hash spacing it in a competition

00:46:37,760 --> 00:46:45,990
other question I have a question for the

00:46:44,069 --> 00:46:50,010
four drink maybe I message something but

00:46:45,990 --> 00:46:53,970
if you split the rink partition into two

00:46:50,010 --> 00:46:57,480
and there is new server that you had one

00:46:53,970 --> 00:46:59,970
sorry now you have to you have but you

00:46:57,480 --> 00:47:02,099
gotta move the files from this old

00:46:59,970 --> 00:47:05,250
server couple of the pilot student in

00:47:02,099 --> 00:47:10,040
your server right yes okay that's why I

00:47:05,250 --> 00:47:13,650
wanted to make sure that I how we do it

00:47:10,040 --> 00:47:24,450
so I don't know if it's the updater that

00:47:13,650 --> 00:47:27,230
does it one day I don't know if it's the

00:47:24,450 --> 00:47:29,549
updater that does it or or the new

00:47:27,230 --> 00:47:31,740
servers in a new partition that users

00:47:29,549 --> 00:47:36,780
are saying to get them from from the

00:47:31,740 --> 00:47:39,720
previous servers I I can find out for

00:47:36,780 --> 00:47:43,410
you I'm not a sweet never 400 a

00:47:39,720 --> 00:47:46,230
developer for the matter so and I just

00:47:43,410 --> 00:47:49,890
really have to make those slides and a

00:47:46,230 --> 00:47:51,390
peer smart it's a lot of project it's a

00:47:49,890 --> 00:47:54,650
bit difficult to keep up with all those

00:47:51,390 --> 00:47:58,049
i'm mostly following over to be honest

00:47:54,650 --> 00:48:00,690
right so it's really madeira i see when

00:47:58,049 --> 00:48:03,980
stack three modular there is a lot of

00:48:00,690 --> 00:48:06,150
different projects and it made to be

00:48:03,980 --> 00:48:09,240
introduced progressively into an

00:48:06,150 --> 00:48:12,000
existing infrastructure so you don't

00:48:09,240 --> 00:48:15,480
have to install all of them I mean Swift

00:48:12,000 --> 00:48:17,880
is is completely separate from from the

00:48:15,480 --> 00:48:20,880
rest of the co projects a glance and

00:48:17,880 --> 00:48:24,020
Nova work together boro will probably

00:48:20,880 --> 00:48:27,000
work with Nova as well as the

00:48:24,020 --> 00:48:29,190
infrastructure layer below it and then

00:48:27,000 --> 00:48:31,650
the Keystone thing is is

00:48:29,190 --> 00:48:33,690
is dis linking all of those but you

00:48:31,650 --> 00:48:36,930
don't have to deploy everything I mean

00:48:33,690 --> 00:48:41,640
nobody's standalone you can even spare

00:48:36,930 --> 00:48:44,150
glance the swiftest stand alone we will

00:48:41,640 --> 00:48:46,410
have more and more projects so it's it's

00:48:44,150 --> 00:48:48,089
we ensure that they work well together

00:48:46,410 --> 00:48:49,740
but that doesn't mean you need to

00:48:48,089 --> 00:48:52,140
install everything to make like an

00:48:49,740 --> 00:49:01,440
openstack cloud you just provide the

00:48:52,140 --> 00:49:03,540
cloud compute part you polite others you

00:49:01,440 --> 00:49:05,579
can you talk a bit what kind of projects

00:49:03,540 --> 00:49:07,230
are currently having the incubator and

00:49:05,579 --> 00:49:15,750
what kind of projects would you like to

00:49:07,230 --> 00:49:18,260
see so incubation we have a bit of fake

00:49:15,750 --> 00:49:21,540
slide because we don't have so many

00:49:18,260 --> 00:49:23,960
baited the incubation process has been

00:49:21,540 --> 00:49:28,829
like decided one week ago two weeks ago

00:49:23,960 --> 00:49:33,240
so it's it's it's it's what I would like

00:49:28,829 --> 00:49:35,430
to see personally so a dashboard was was

00:49:33,240 --> 00:49:39,030
officially voted and an OpenStack

00:49:35,430 --> 00:49:41,609
incubated project choose Keystone is

00:49:39,030 --> 00:49:43,950
expect it as applied but we didn't know

00:49:41,609 --> 00:49:49,220
it's accepted to Keystone is accepted to

00:49:43,950 --> 00:49:51,660
burrow is expected to to apply for soon

00:49:49,220 --> 00:49:56,609
we had other project that applied that

00:49:51,660 --> 00:49:59,599
got rejected at least omari we what will

00:49:56,609 --> 00:49:59,599
we have here

00:50:02,470 --> 00:50:07,090
at that point I think it's the only

00:50:04,810 --> 00:50:09,040
three project that I think should be

00:50:07,090 --> 00:50:10,500
called project for the next phase the

00:50:09,040 --> 00:50:13,510
idea is that you are incubated

00:50:10,500 --> 00:50:14,980
incubating for one recycle and then the

00:50:13,510 --> 00:50:17,640
next one cycle you're part of the core

00:50:14,980 --> 00:50:20,530
project do we need to make sure that

00:50:17,640 --> 00:50:22,060
they're up to power 4 what about where

00:50:20,530 --> 00:50:25,660
this management process that they're

00:50:22,060 --> 00:50:27,570
they're like sufficiently present on IRC

00:50:25,660 --> 00:50:29,830
so that we can communicate with them

00:50:27,570 --> 00:50:32,470
that they are sufficiently integrated

00:50:29,830 --> 00:50:34,450
with the way things work so that we can

00:50:32,470 --> 00:50:37,390
actually work with them as a cool

00:50:34,450 --> 00:50:39,250
project and there are lots of related

00:50:37,390 --> 00:50:41,500
projects I didn't talk about them it's

00:50:39,250 --> 00:50:45,040
it's things that will never be in call

00:50:41,500 --> 00:50:48,280
like mobile phone clients or deployment

00:50:45,040 --> 00:50:51,220
tools that that well there are like 10

00:50:48,280 --> 00:50:52,810
of them we don't really want to choose

00:50:51,220 --> 00:50:54,849
between though between those they are

00:50:52,810 --> 00:50:56,619
all working with OpenStack or OpenStack

00:50:54,849 --> 00:50:58,990
compatible they could have a sticker but

00:50:56,619 --> 00:51:10,359
I don't think they should be made core

00:50:58,990 --> 00:51:15,190
project of OpenStack your question his

00:51:10,359 --> 00:51:19,210
glance meant just to store read-only

00:51:15,190 --> 00:51:22,420
disk images or also modifiable 1 i'm

00:51:19,210 --> 00:51:27,300
thinking the difference between a zebra

00:51:22,420 --> 00:51:34,330
mid-major and a beautiful machine disk

00:51:27,300 --> 00:51:36,490
snapshot it's it's meant to store think

00:51:34,330 --> 00:51:39,430
it's meant to store that the base images

00:51:36,490 --> 00:51:42,160
that the compute service will offer as

00:51:39,430 --> 00:51:47,230
an option so like you want moving to

00:51:42,160 --> 00:51:50,619
server well 1004 LTS then then the gland

00:51:47,230 --> 00:51:52,510
service can allow you to search the base

00:51:50,619 --> 00:51:57,190
for all those that are compatible with

00:51:52,510 --> 00:51:59,020
that and and with the run that the RAM

00:51:57,190 --> 00:52:02,470
and CPU option that you want and we'll

00:51:59,020 --> 00:52:04,990
trade that disk image and we also push

00:52:02,470 --> 00:52:08,859
the idea of what all am preparing to do

00:52:04,990 --> 00:52:10,660
a good time configuration that's what we

00:52:08,859 --> 00:52:13,960
do does with their boot to cloud images

00:52:10,660 --> 00:52:15,880
so you have a common image and you put

00:52:13,960 --> 00:52:17,890
it with with specific parameters that

00:52:15,880 --> 00:52:20,200
that actually configures it into

00:52:17,890 --> 00:52:23,710
something that does something rid of it

00:52:20,200 --> 00:52:25,540
and I think it's better than than the

00:52:23,710 --> 00:52:28,359
hip burning stuff where you need to

00:52:25,540 --> 00:52:31,570
upload the work that's our Amazon Amazon

00:52:28,359 --> 00:52:33,700
does it you need to remember your image

00:52:31,570 --> 00:52:36,640
and upload it again to s3 store it there

00:52:33,700 --> 00:52:40,359
and that's that's a slightly different

00:52:36,640 --> 00:52:45,390
approach I don't see why plants could

00:52:40,359 --> 00:52:45,390
not be used to store like snapshots or

00:52:51,610 --> 00:52:59,180
and London lock storage when the the

00:52:55,870 --> 00:53:04,160
wood for volumes is separate snapshots

00:52:59,180 --> 00:53:07,880
oh yeah I well I think it must be the

00:53:04,160 --> 00:53:10,190
OpenStack API that has a an API call to

00:53:07,880 --> 00:53:13,730
create a snapshot of of a running

00:53:10,190 --> 00:53:15,650
virtual machine and that ends up in

00:53:13,730 --> 00:53:18,560
plants that's where it extracts it and

00:53:15,650 --> 00:53:21,160
put it into flames well yeah we were we

00:53:18,560 --> 00:53:23,900
are adding the the in the new version

00:53:21,160 --> 00:53:26,210
the possibility to snapshot clone and

00:53:23,900 --> 00:53:28,130
boot from volumes so that's a blog

00:53:26,210 --> 00:53:32,060
storage that is handled by by the volume

00:53:28,130 --> 00:53:34,580
API so that's one option but you can

00:53:32,060 --> 00:53:36,320
also snapshot disk images and then push

00:53:34,580 --> 00:53:38,840
them to plants and boot from that

00:53:36,320 --> 00:53:41,030
instead so it's like I said lots of

00:53:38,840 --> 00:53:44,450
options sometimes difficult to tell

00:53:41,030 --> 00:53:47,870
which option is the best combination for

00:53:44,450 --> 00:53:50,090
your use case we expect that the window

00:53:47,870 --> 00:53:56,620
guys will come up with with like a

00:53:50,090 --> 00:53:58,820
standard we went to the centroid way of

00:53:56,620 --> 00:54:00,950
selection of component that makes sense

00:53:58,820 --> 00:54:02,690
altogether to deploy a private cloud

00:54:00,950 --> 00:54:05,540
because that's their your target and

00:54:02,690 --> 00:54:07,430
that will be easier for for people to

00:54:05,540 --> 00:54:09,920
test you can actually deploy all the

00:54:07,430 --> 00:54:14,330
components in a single machine and run

00:54:09,920 --> 00:54:17,360
with the local habit mq and and and

00:54:14,330 --> 00:54:18,800
sqlite databases and test everything on

00:54:17,360 --> 00:54:20,590
this on a single machine which is very

00:54:18,800 --> 00:54:23,510
useful it's kels up but they're so down

00:54:20,590 --> 00:54:32,440
so it's a it's not that difficult to

00:54:23,510 --> 00:54:38,320
evaluate i just lost a quick question

00:54:32,440 --> 00:54:42,800
actually have two questions too bad

00:54:38,320 --> 00:54:46,960
first question is how long is it gonna

00:54:42,800 --> 00:54:49,720
take before use OpenStack and production

00:54:46,960 --> 00:54:53,570
well it depends on your on your

00:54:49,720 --> 00:54:55,010
definition of all it's already all the

00:54:53,570 --> 00:54:55,820
components are already already used

00:54:55,010 --> 00:55:01,540
input

00:54:55,820 --> 00:55:04,820
so except glands maybe uh nope who knows

00:55:01,540 --> 00:55:09,380
so Swift is used in production for cloud

00:55:04,820 --> 00:55:11,960
Rackspace cloud files and so it's it's

00:55:09,380 --> 00:55:14,120
like it's the code like we released a

00:55:11,960 --> 00:55:16,250
version on Monday and it's already

00:55:14,120 --> 00:55:18,500
deployed on rackspace cloud in

00:55:16,250 --> 00:55:22,280
production so this is very much

00:55:18,500 --> 00:55:24,560
collection ready Nova is run it's

00:55:22,280 --> 00:55:27,250
running in production at NASA water

00:55:24,560 --> 00:55:30,080
power the nebular cloud they use for a

00:55:27,250 --> 00:55:33,470
calculation but also to host various

00:55:30,080 --> 00:55:36,250
websites like white house at all and and

00:55:33,470 --> 00:55:39,200
so it worked it's the question is that

00:55:36,250 --> 00:55:43,010
you have to pick the most student

00:55:39,200 --> 00:55:45,110
components you have to have a good crew

00:55:43,010 --> 00:55:47,000
of decent means to keep up with what you

00:55:45,110 --> 00:55:48,920
should upgrade to what you shouldn't to

00:55:47,000 --> 00:55:51,470
provide the glue when the when the

00:55:48,920 --> 00:55:53,870
migration is not it's not that easy from

00:55:51,470 --> 00:55:56,060
one person to another so it's it's it's

00:55:53,870 --> 00:55:57,710
tricky to deploy currently to have no

00:55:56,060 --> 00:56:00,410
vine production like with a small group

00:55:57,710 --> 00:56:01,910
of IT guys you can definitely test it

00:56:00,410 --> 00:56:03,890
you should test it to make sure that it

00:56:01,910 --> 00:56:05,210
works for your walk alone it's the best

00:56:03,890 --> 00:56:07,820
way to ensure that it will meet your

00:56:05,210 --> 00:56:13,490
needs of tomorrow deploying today in

00:56:07,820 --> 00:56:17,450
production with a small ite ite service

00:56:13,490 --> 00:56:21,320
and in a private enterprise to serve

00:56:17,450 --> 00:56:23,720
users it's a bit risky I expect it to

00:56:21,320 --> 00:56:25,610
stabilize in six months once we separate

00:56:23,720 --> 00:56:27,470
all those api's I think that the the

00:56:25,610 --> 00:56:29,950
equation from the current version to the

00:56:27,470 --> 00:56:34,150
next version where we have those API

00:56:29,950 --> 00:56:36,590
separated and the new services are fully

00:56:34,150 --> 00:56:39,190
replacing the old ones think the

00:56:36,590 --> 00:56:43,990
migration path would be a bit bumpy and

00:56:39,190 --> 00:56:43,990
maybe that is okay thank you very much

00:56:46,720 --> 00:56:48,780

YouTube URL: https://www.youtube.com/watch?v=k9NGWSqcmDI


