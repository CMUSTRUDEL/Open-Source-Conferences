Title: Exploring CPython's bytecode
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Floris Bruynooghe - 22 June 2011 in "Track Lasagne"
Captions: 
	00:00:01,949 --> 00:00:05,969
Flores thank

00:00:11,250 --> 00:00:19,660
thank you and tell ya exploring see

00:00:15,549 --> 00:00:22,450
Piper's bike Cove um first a little bit

00:00:19,660 --> 00:00:24,699
about me I'm not accorded fightin

00:00:22,450 --> 00:00:28,779
developer and so I'm not really

00:00:24,699 --> 00:00:30,490
qualified to give this and so my

00:00:28,779 --> 00:00:33,670
approach is really not going to be like

00:00:30,490 --> 00:00:35,470
explaining from the ground up high court

00:00:33,670 --> 00:00:38,410
I'm approaching this from the outside in

00:00:35,470 --> 00:00:40,780
as in we all know there's this x y z

00:00:38,410 --> 00:00:43,360
files and you know what what's actually

00:00:40,780 --> 00:00:45,760
inside them and i'll go in and start at

00:00:43,360 --> 00:00:48,280
the part i see fire strike trying to

00:00:45,760 --> 00:00:51,850
retort inside them and from there kind

00:00:48,280 --> 00:00:54,670
of like backwards do how the item

00:00:51,850 --> 00:01:00,190
virtual machine actually ends up

00:00:54,670 --> 00:01:02,530
executing that byte code yeah on that

00:01:00,190 --> 00:01:06,759
you know occasionally try to contribute

00:01:02,530 --> 00:01:09,580
some patches and I'm maintain or spear

00:01:06,759 --> 00:01:13,930
type ipython system information which is

00:01:09,580 --> 00:01:15,520
a small extension module I have got

00:01:13,930 --> 00:01:18,220
quite a few years of experience in

00:01:15,520 --> 00:01:20,650
writing development I've been and write

00:01:18,220 --> 00:01:23,470
full-time it working coding with piping

00:01:20,650 --> 00:01:32,350
for the past five or six years or

00:01:23,470 --> 00:01:35,020
something Oh unraveling by code so it's

00:01:32,350 --> 00:01:38,470
going to start with as I kind of said

00:01:35,020 --> 00:01:42,070
already starting with bio I see files it

00:01:38,470 --> 00:01:44,439
reads what's inside them and really the

00:01:42,070 --> 00:01:46,000
main thing is that this is not going to

00:01:44,439 --> 00:01:49,600
make you better developer knowing any of

00:01:46,000 --> 00:01:51,280
this it's it's just the base of time

00:01:49,600 --> 00:01:53,170
it's an interesting thought experiment

00:01:51,280 --> 00:01:55,000
but unless you really want to go and

00:01:53,170 --> 00:01:59,680
write your own interpret all right all

00:01:55,000 --> 00:02:01,990
right on Python itself not none of this

00:01:59,680 --> 00:02:04,990
information is going to be very critical

00:02:01,990 --> 00:02:07,659
that that make you much better but it's

00:02:04,990 --> 00:02:10,420
a fun exercise anyway I enjoyed it and

00:02:07,659 --> 00:02:14,650
the examples are going to be inviting

00:02:10,420 --> 00:02:16,810
three the difference between pythons 2

00:02:14,650 --> 00:02:19,239
and x 3 and x code is really quite small

00:02:16,810 --> 00:02:22,540
that there's a couple of small

00:02:19,239 --> 00:02:25,000
difference to some but it's very easy to

00:02:22,540 --> 00:02:26,889
see it she's to lab belong to each other

00:02:25,000 --> 00:02:28,269
so much abuse in some objects might be

00:02:26,889 --> 00:02:30,940
slightly different names and things that

00:02:28,269 --> 00:02:36,459
out but it's not very not very difficult

00:02:30,940 --> 00:02:38,730
than enough ivan is really it's always

00:02:36,459 --> 00:02:41,470
called an interpreter it's really a

00:02:38,730 --> 00:02:46,750
compiler and a virtual machine at the

00:02:41,470 --> 00:02:50,139
same in one going package but whenever

00:02:46,750 --> 00:02:53,049
whenever you excuse any by file it will

00:02:50,139 --> 00:02:56,230
first compile the source code into the

00:02:53,049 --> 00:02:59,530
bike Cove which will then try and store

00:02:56,230 --> 00:03:02,680
in piracy file if it can compiler

00:02:59,530 --> 00:03:05,799
actually uses intermedius facs which is

00:03:02,680 --> 00:03:08,109
a whole other subject which though and

00:03:05,799 --> 00:03:10,600
you can modify things on the ASD and

00:03:08,109 --> 00:03:13,900
think cetera which is also quite

00:03:10,600 --> 00:03:17,709
interesting and then once it's got the

00:03:13,900 --> 00:03:20,380
this despite code it will execute that

00:03:17,709 --> 00:03:22,540
in the virtual machine so a virtual

00:03:20,380 --> 00:03:26,350
machine always loads Bri compiled by

00:03:22,540 --> 00:03:30,940
code and then we'll execute it in stack

00:03:26,350 --> 00:03:35,639
frames is going on text that it gives

00:03:30,940 --> 00:03:38,590
what a lot of sexy with new things the

00:03:35,639 --> 00:03:40,660
this talk is going to concentrate on the

00:03:38,590 --> 00:03:42,010
virtual machine part not really much on

00:03:40,660 --> 00:03:43,840
the compiled part and there's the

00:03:42,010 --> 00:03:48,820
transformations to try it you can do on

00:03:43,840 --> 00:03:50,470
those this is a the only in which I'm

00:03:48,820 --> 00:03:52,620
afraid to say that you're going to get

00:03:50,470 --> 00:03:56,139
because I'm rubbish at making images and

00:03:52,620 --> 00:03:59,019
I even stole this from someone else with

00:03:56,139 --> 00:04:02,290
permission but so that's a graphical

00:03:59,019 --> 00:04:05,769
overview of what's happened what happens

00:04:02,290 --> 00:04:08,590
so the source file gets reform to HD

00:04:05,769 --> 00:04:11,229
you'd create code objects which is

00:04:08,590 --> 00:04:14,799
thought in bio files and then the

00:04:11,229 --> 00:04:18,519
interpreter with loaders and with

00:04:14,799 --> 00:04:20,560
executors using stack frames at the end

00:04:18,519 --> 00:04:22,660
of it you get running program which is

00:04:20,560 --> 00:04:27,970
what you want I'm going to be working

00:04:22,660 --> 00:04:28,620
with this small module it's very trivial

00:04:27,970 --> 00:04:31,830
it's

00:04:28,620 --> 00:04:35,340
it skips a lot of trickier and bits that

00:04:31,830 --> 00:04:37,590
things that he can do in empire but it's

00:04:35,340 --> 00:04:40,979
sufficient to demonstrate how invite

00:04:37,590 --> 00:04:44,220
code works again then I'm sorry just

00:04:40,979 --> 00:04:46,110
what one yeah one function log string

00:04:44,220 --> 00:04:49,949
there's some very simple combination

00:04:46,110 --> 00:04:54,240
returns a number well doesn't the reason

00:04:49,949 --> 00:04:55,919
number and and then on the module level

00:04:54,240 --> 00:04:59,010
it's actually execute that function

00:04:55,919 --> 00:05:02,190
rinse it off on the screen and doctoring

00:04:59,010 --> 00:05:05,039
at one your level as well but it's a

00:05:02,190 --> 00:05:09,000
very small yes it skips a lot of

00:05:05,039 --> 00:05:10,110
features quite endure all right I'm

00:05:09,000 --> 00:05:12,720
going to be ambitious and I'm actually

00:05:10,110 --> 00:05:15,840
going to write an interpreter during

00:05:12,720 --> 00:05:18,090
this talk well I wrote one for the talk

00:05:15,840 --> 00:05:21,479
that will be able to execute that little

00:05:18,090 --> 00:05:24,510
module and it's going to be important so

00:05:21,479 --> 00:05:29,820
it will be slow and entirely pointless

00:05:24,510 --> 00:05:32,520
again yeah it's it's you know it's not

00:05:29,820 --> 00:05:34,800
like pie pie pie where they spend five

00:05:32,520 --> 00:05:36,870
years or more developing from the

00:05:34,800 --> 00:05:38,970
mountain themes etc so it's really

00:05:36,870 --> 00:05:44,760
pointless exercise but it's really nice

00:05:38,970 --> 00:05:49,160
to demonstrate how it all works yeah it

00:05:44,760 --> 00:05:53,490
will still need pythons to run mostly a

00:05:49,160 --> 00:05:55,650
compiler part usually happens in bishop

00:05:53,490 --> 00:05:58,949
and so you don't notice you just run

00:05:55,650 --> 00:06:01,949
your program and C Python will buy it

00:05:58,949 --> 00:06:04,289
compile your files if it needs to if you

00:06:01,949 --> 00:06:07,289
do want to do that explicitly you can

00:06:04,289 --> 00:06:09,360
use the fire compile module which you

00:06:07,289 --> 00:06:13,740
can get to which can also invoke on the

00:06:09,360 --> 00:06:16,260
command line there is another module I

00:06:13,740 --> 00:06:18,690
think compile all which you can point to

00:06:16,260 --> 00:06:21,690
a directory and compile whole packages

00:06:18,690 --> 00:06:25,470
etc in general you don't want to really

00:06:21,690 --> 00:06:27,500
do this but unless you're distributing

00:06:25,470 --> 00:06:30,350
packages or something right out

00:06:27,500 --> 00:06:35,030
on them I'm doing the examples on

00:06:30,350 --> 00:06:37,970
fightin 3.2 and your bytecode will end

00:06:35,030 --> 00:06:42,170
up in this bio cache directory the

00:06:37,970 --> 00:06:44,180
reason and I think earlier version of x

00:06:42,170 --> 00:06:47,150
+ 3 as well as buying food you just get

00:06:44,180 --> 00:06:50,660
the piracy fine next to it this is quite

00:06:47,150 --> 00:06:53,750
recent edition and it makes it easier to

00:06:50,660 --> 00:06:55,250
share the same by code directory between

00:06:53,750 --> 00:06:58,370
multiple interpreters which is something

00:06:55,250 --> 00:07:02,240
that's useful for distributors like

00:06:58,370 --> 00:07:06,380
they're being etc I think Barry won't

00:07:02,240 --> 00:07:07,640
wash or put in recently but the good

00:07:06,380 --> 00:07:10,790
thing is you don't really have to worry

00:07:07,640 --> 00:07:13,310
where to buy it goes because the inp

00:07:10,790 --> 00:07:18,350
module in the Sun library will tell you

00:07:13,310 --> 00:07:19,640
I so they stash from source function you

00:07:18,350 --> 00:07:21,580
just give it the source file name

00:07:19,640 --> 00:07:24,770
example at PI and it will come up with

00:07:21,580 --> 00:07:27,470
the long filename there's a couple of

00:07:24,770 --> 00:07:30,350
others like you can do to reverse and a

00:07:27,470 --> 00:07:33,729
few more functions in there so you don't

00:07:30,350 --> 00:07:33,729
have to worry where to buy code ends up

00:07:34,000 --> 00:07:42,229
or actually going into it my obviously

00:07:38,540 --> 00:07:44,180
good you just explain some more because

00:07:42,229 --> 00:07:46,729
these two optimizations which is that

00:07:44,180 --> 00:07:49,630
exist optimization between codes because

00:07:46,729 --> 00:07:53,180
they don't really optimize anything and

00:07:49,630 --> 00:07:55,580
they modified a bytecode firstly when

00:07:53,180 --> 00:07:58,940
you start using them you will end up

00:07:55,580 --> 00:08:00,650
with pyro files this is a bit odd spy

00:07:58,940 --> 00:08:02,419
things one of the only languages i know

00:08:00,650 --> 00:08:08,750
that actually uses different extension

00:08:02,419 --> 00:08:12,350
but anyway the dunder debug thing is

00:08:08,750 --> 00:08:15,620
actually useful it means you can ride

00:08:12,350 --> 00:08:17,630
some tests or write to Mexico din if it

00:08:15,620 --> 00:08:19,669
blocks if done the debug or something

00:08:17,630 --> 00:08:22,610
like that so that will evaluate to false

00:08:19,669 --> 00:08:25,669
when you have optimization on and you'll

00:08:22,610 --> 00:08:31,700
also skip a search statement can also be

00:08:25,669 --> 00:08:34,339
useful minus 0 2 is it's it's a very its

00:08:31,700 --> 00:08:36,830
way of making the fires a bit smaller by

00:08:34,339 --> 00:08:38,310
skipping drop strings however you have

00:08:36,830 --> 00:08:40,840
to watch out because

00:08:38,310 --> 00:08:43,840
sleep if you're using the doc string

00:08:40,840 --> 00:08:49,420
you'll still use it and you only I'm

00:08:43,840 --> 00:08:53,230
crash products yeah um thats

00:08:49,420 --> 00:08:56,860
optimization kind of thing well so how

00:08:53,230 --> 00:08:59,920
do you read a piracy file well you know

00:08:56,860 --> 00:09:02,080
in in the old days you eat a resource

00:08:59,920 --> 00:09:03,760
and figure it out nowadays you just look

00:09:02,080 --> 00:09:04,750
on the internet and for any question

00:09:03,760 --> 00:09:09,430
that someone else's figured it out

00:09:04,750 --> 00:09:11,220
already that's a very good article about

00:09:09,430 --> 00:09:14,830
the structure of priority files and

00:09:11,220 --> 00:09:17,500
essentially it's really simple it's a

00:09:14,830 --> 00:09:19,270
magic number a timestamp and a code

00:09:17,500 --> 00:09:21,990
object which is the rest of the file

00:09:19,270 --> 00:09:25,660
kind of thing the magic number is there

00:09:21,990 --> 00:09:27,190
24 by thing to do know that it's got the

00:09:25,660 --> 00:09:31,480
right and then it's got the right

00:09:27,190 --> 00:09:33,730
version of piracy fun so byte code files

00:09:31,480 --> 00:09:36,430
the four months it changes between major

00:09:33,730 --> 00:09:38,080
versions of biking and it just needs to

00:09:36,430 --> 00:09:40,720
ensure that yes i'm running the right

00:09:38,080 --> 00:09:43,270
bike go far and if that magic number

00:09:40,720 --> 00:09:48,840
doesn't match it's going to recompile

00:09:43,270 --> 00:09:48,840
the source start again the time stamp is

00:09:49,140 --> 00:09:54,850
it's also used python always looks at

00:09:52,720 --> 00:09:57,670
the source code first and the timestamp

00:09:54,850 --> 00:09:59,950
is it simply used to check you do i need

00:09:57,670 --> 00:10:01,780
to recompile the by code has a source go

00:09:59,950 --> 00:10:04,060
and change the art or not and then the

00:10:01,780 --> 00:10:09,240
code object is actually what will be

00:10:04,060 --> 00:10:14,830
interested in it turns out magic number

00:10:09,240 --> 00:10:17,080
four bytes that's for my example by

00:10:14,830 --> 00:10:18,670
profile that that's the magic number

00:10:17,080 --> 00:10:21,150
that comes out and you can see it ants

00:10:18,670 --> 00:10:24,640
in a carriage return on a line feed

00:10:21,150 --> 00:10:26,320
that's that's not really part of magic

00:10:24,640 --> 00:10:28,120
number doubt there to detect corruption

00:10:26,320 --> 00:10:29,980
when people have to be in ascii mode

00:10:28,120 --> 00:10:33,700
across windows units and Max machines

00:10:29,980 --> 00:10:35,770
and stuff gets mangled up and so that's

00:10:33,700 --> 00:10:41,530
just a protection against that and then

00:10:35,770 --> 00:10:43,810
the first part is it is yet due to two

00:10:41,530 --> 00:10:46,480
bytes then go do a little engine

00:10:43,810 --> 00:10:50,110
struggle and packed that lasted own

00:10:46,480 --> 00:10:51,730
symbol this little engine short and

00:10:50,110 --> 00:10:55,300
science short

00:10:51,730 --> 00:11:00,190
and the number of my example one comes

00:10:55,300 --> 00:11:01,449
out with 3083 180 it's just a random

00:11:00,190 --> 00:11:02,889
number it doesn't matter the only thing

00:11:01,449 --> 00:11:05,079
that matters is that it matches if you

00:11:02,889 --> 00:11:07,510
really care you can actually go and look

00:11:05,079 --> 00:11:10,449
at import the scene in the Python source

00:11:07,510 --> 00:11:13,990
code it's a big dog straighten a big

00:11:10,449 --> 00:11:16,540
comment where it lists all the magic

00:11:13,990 --> 00:11:18,399
numbers they've had and what they've

00:11:16,540 --> 00:11:21,070
kind of what what Python version that

00:11:18,399 --> 00:11:24,180
much onto and sort of what they've

00:11:21,070 --> 00:11:27,490
changed in the right code so actually

00:11:24,180 --> 00:11:30,940
this one that they last change a pre

00:11:27,490 --> 00:11:35,490
2002 and they added the new bike goes

00:11:30,940 --> 00:11:39,279
into it this is accessible from inside

00:11:35,490 --> 00:11:40,990
biking again by the IP module get magic

00:11:39,279 --> 00:11:42,220
only gives you the current magic but

00:11:40,990 --> 00:11:44,260
that's really everything you only care

00:11:42,220 --> 00:11:48,370
about you just want to ensure that you

00:11:44,260 --> 00:11:49,630
got the right man the right by code any

00:11:48,370 --> 00:11:52,570
other bytecode you wouldn't be able to

00:11:49,630 --> 00:11:55,209
understand anyway so you don't mind

00:11:52,570 --> 00:11:57,600
Meadows timestamp is a simple unix

00:11:55,209 --> 00:12:00,190
timestamp again little endian encoded

00:11:57,600 --> 00:12:01,899
you'll find out everything in byte code

00:12:00,190 --> 00:12:05,889
files in Python my cat far as little and

00:12:01,899 --> 00:12:08,350
little engine encoded so yeah you can

00:12:05,889 --> 00:12:12,930
unpack those and the example module I

00:12:08,350 --> 00:12:15,190
and only I may dislike on something so

00:12:12,930 --> 00:12:17,769
yeah it just gives you the time when

00:12:15,190 --> 00:12:21,240
it's changed the code object them is

00:12:17,769 --> 00:12:25,389
actually what you can you care about

00:12:21,240 --> 00:12:26,920
then again the Python Python standard

00:12:25,389 --> 00:12:29,889
library is very good at eating sound

00:12:26,920 --> 00:12:32,529
offered and it concludes this marshal

00:12:29,889 --> 00:12:33,910
module if you read your confession of it

00:12:32,529 --> 00:12:37,149
it will say I don't use this because

00:12:33,910 --> 00:12:38,740
it's not general persistence etc it's

00:12:37,149 --> 00:12:40,449
only real reason is there to be able to

00:12:38,740 --> 00:12:42,880
write for barton to read and write byte

00:12:40,449 --> 00:12:45,399
code it's insecure it doesn't check its

00:12:42,880 --> 00:12:46,899
input etc all those things and that's

00:12:45,399 --> 00:12:48,910
why you've got the magic number on the

00:12:46,899 --> 00:12:52,779
front so that person can be sort of sure

00:12:48,910 --> 00:12:56,620
that it's going to be all right and the

00:12:52,779 --> 00:12:58,529
API is very simple just call it with it

00:12:56,620 --> 00:13:01,810
with the fire pointer that you got open

00:12:58,529 --> 00:13:03,050
and it will read the rest of the file

00:13:01,810 --> 00:13:06,410
until it gets to the end

00:13:03,050 --> 00:13:11,060
of the code object it will return

00:13:06,410 --> 00:13:16,880
unicode object and leave the fire

00:13:11,060 --> 00:13:21,380
pointer after the code object though the

00:13:16,880 --> 00:13:24,500
entire process of reading high prices of

00:13:21,380 --> 00:13:26,440
reading and micro file it's something

00:13:24,500 --> 00:13:29,810
along these lines who you open the file

00:13:26,440 --> 00:13:32,329
that you want to make sure inviting free

00:13:29,810 --> 00:13:36,230
to open it as binary file not as a text

00:13:32,329 --> 00:13:38,930
file you get the magic you check the

00:13:36,230 --> 00:13:40,690
magic number is fine but this is bad

00:13:38,930 --> 00:13:43,100
style if you don't use a server because

00:13:40,690 --> 00:13:44,600
when you use a search for this you will

00:13:43,100 --> 00:13:47,720
lose the information you'll lose it when

00:13:44,600 --> 00:13:51,920
you start using minus hope so but it's

00:13:47,720 --> 00:13:54,910
shorter in and finish lights and you can

00:13:51,920 --> 00:13:58,820
get the time stamp out quite easily

00:13:54,910 --> 00:14:03,740
struck modulus returns double and then

00:13:58,820 --> 00:14:05,600
you you load the code object and a

00:14:03,740 --> 00:14:09,680
normal by code file you'll then be at

00:14:05,600 --> 00:14:12,020
the end of the file though then you want

00:14:09,680 --> 00:14:13,130
to yeah used to go to object but i'm

00:14:12,020 --> 00:14:15,410
going to quickly jump back to the

00:14:13,130 --> 00:14:19,640
compiler now originally it said you know

00:14:15,410 --> 00:14:22,160
use this by compile module to create

00:14:19,640 --> 00:14:25,100
your bike code there's also a direct way

00:14:22,160 --> 00:14:26,630
in encode if you don't want to use if

00:14:25,100 --> 00:14:28,700
you don't want to have an external by

00:14:26,630 --> 00:14:32,510
code file you can just call it compile

00:14:28,700 --> 00:14:36,380
module a compiler built in function

00:14:32,510 --> 00:14:39,140
sorry it takes just the texture source

00:14:36,380 --> 00:14:42,200
code it wants to notify them because

00:14:39,140 --> 00:14:45,079
it's used introspection things photo/the

00:14:42,200 --> 00:14:48,949
mode which is one of them those exact a

00:14:45,079 --> 00:14:51,110
violent single the difference between

00:14:48,949 --> 00:14:54,050
those three modes exer case if you want

00:14:51,110 --> 00:14:57,350
to lower the whole module it will

00:14:54,050 --> 00:15:00,260
execute their whole module in namespace

00:14:57,350 --> 00:15:03,260
normally evil is for single expressions

00:15:00,260 --> 00:15:05,630
and single is something you really want

00:15:03,260 --> 00:15:09,019
to use against i think it's a special

00:15:05,630 --> 00:15:11,480
case of evil which is used when the

00:15:09,019 --> 00:15:13,059
interpreter when you use in tertiary

00:15:11,480 --> 00:15:15,969
interactively so

00:15:13,059 --> 00:15:18,479
it will after executing the expression

00:15:15,969 --> 00:15:23,559
it will actually print it on to the

00:15:18,479 --> 00:15:28,079
current terminal you're on a the other

00:15:23,559 --> 00:15:30,669
things like it's something like which

00:15:28,079 --> 00:15:33,009
than the future statements you aren't

00:15:30,669 --> 00:15:36,639
used you know you can do like in the

00:15:33,009 --> 00:15:40,479
future division than important to point

00:15:36,639 --> 00:15:42,629
something dynasty future with statements

00:15:40,479 --> 00:15:47,409
and things like that absolute import

00:15:42,629 --> 00:15:49,839
those the flags is it flat for that bond

00:15:47,409 --> 00:15:51,699
inherit it is again normally if you

00:15:49,839 --> 00:15:55,809
leave the defaults for those keyword

00:15:51,699 --> 00:15:57,489
arguments you'll end up with inheriting

00:15:55,809 --> 00:15:59,319
everything in flags what future

00:15:57,489 --> 00:16:02,949
statements are active and what

00:15:59,319 --> 00:16:05,319
optimization level you have from the

00:16:02,949 --> 00:16:07,209
code executing it from so that those

00:16:05,319 --> 00:16:08,919
three bio methods allow you to customize

00:16:07,209 --> 00:16:12,219
that if you want to force a certain

00:16:08,919 --> 00:16:14,289
thing opening the source file it this is

00:16:12,219 --> 00:16:17,499
actually slightly cheating too bad start

00:16:14,289 --> 00:16:20,799
as well because you don't know d you

00:16:17,499 --> 00:16:22,829
don't really know DM encoding you should

00:16:20,799 --> 00:16:25,299
really know the encoding I think in the

00:16:22,829 --> 00:16:27,429
token item module there's an open

00:16:25,299 --> 00:16:33,249
function that fetches encoding out as

00:16:27,429 --> 00:16:35,349
well but on to code object the great

00:16:33,249 --> 00:16:37,749
thing about it it's documented in the

00:16:35,349 --> 00:16:39,999
language references there's a data model

00:16:37,749 --> 00:16:42,339
detection and that's very interesting

00:16:39,999 --> 00:16:45,399
section when you're looking at internals

00:16:42,339 --> 00:16:47,369
in Python it explains a lot of those as

00:16:45,399 --> 00:16:52,029
already mentioned I think everything

00:16:47,369 --> 00:16:53,979
that will get executed first gets

00:16:52,029 --> 00:16:55,659
compiled into code eject they are

00:16:53,979 --> 00:16:59,229
read-only so you can actually modify

00:16:55,659 --> 00:17:00,669
those at all you can create new ones if

00:16:59,229 --> 00:17:05,980
you really want to order it slightly

00:17:00,669 --> 00:17:09,220
complicated and there yeah they're a

00:17:05,980 --> 00:17:10,899
bunch of cereal attributes basically so

00:17:09,220 --> 00:17:14,379
the code object we got back from from

00:17:10,899 --> 00:17:16,409
reading out party file looks slightly

00:17:14,379 --> 00:17:19,029
like this with it with the attribute and

00:17:16,409 --> 00:17:20,789
so it encodes you really finally I mean

00:17:19,029 --> 00:17:24,970
there it encodes line number information

00:17:20,789 --> 00:17:27,050
not only the tab is a and the top is a

00:17:24,970 --> 00:17:30,240
very tight

00:17:27,050 --> 00:17:32,400
way of encoding which bytecodes might

00:17:30,240 --> 00:17:34,950
just start up with rich line number

00:17:32,400 --> 00:17:38,190
details of their are in an attempt nodes

00:17:34,950 --> 00:17:40,410
in the source code of Python again it's

00:17:38,190 --> 00:17:43,050
fairly complicated but it's a tight

00:17:40,410 --> 00:17:44,910
packing flags are mostly going to ignore

00:17:43,050 --> 00:17:49,200
it again things like what future

00:17:44,910 --> 00:17:51,690
statements are in use what reddit reddit

00:17:49,200 --> 00:17:53,490
function use estar arms etc I know we're

00:17:51,690 --> 00:17:55,530
still talking about a module but Dakota

00:17:53,490 --> 00:17:57,060
Dakota object you see the same like the

00:17:55,530 --> 00:17:59,910
same code object just is used for

00:17:57,060 --> 00:18:02,180
modules for functions for classes that

00:17:59,910 --> 00:18:06,960
right it's all it just some attributes

00:18:02,180 --> 00:18:08,880
aren't just not used the name then the

00:18:06,960 --> 00:18:10,620
name is normally if it's a function it

00:18:08,880 --> 00:18:13,830
will be named function this case there

00:18:10,620 --> 00:18:17,040
is no name Theo names is more

00:18:13,830 --> 00:18:19,320
interesting this is an array or topple

00:18:17,040 --> 00:18:21,270
it represent as a couple here of the

00:18:19,320 --> 00:18:26,370
names that are that are used but by this

00:18:21,270 --> 00:18:28,530
this code object the constant again as

00:18:26,370 --> 00:18:31,740
well so in the constants you can see doc

00:18:28,530 --> 00:18:37,350
string which which yeah it stored as a

00:18:31,740 --> 00:18:38,940
string you can see the two integers also

00:18:37,350 --> 00:18:40,620
known as an illness used constant

00:18:38,940 --> 00:18:43,890
because it's it's returned thing bacilli

00:18:40,620 --> 00:18:45,570
at the end of the module and then you

00:18:43,890 --> 00:18:47,940
can see in all the code gold object in

00:18:45,570 --> 00:18:49,320
there so a code object will you know

00:18:47,940 --> 00:18:50,580
contain all the code Jackson code

00:18:49,320 --> 00:18:54,000
objects and that's how you get your

00:18:50,580 --> 00:18:56,640
function cetera stack size is something

00:18:54,000 --> 00:19:00,120
that and because I'm writing my mark my

00:18:56,640 --> 00:19:01,560
little interpreter here in Python item I

00:19:00,120 --> 00:19:03,480
don't really care about knowing what the

00:19:01,560 --> 00:19:05,910
stack size would be C Python life's to

00:19:03,480 --> 00:19:09,150
know with a bit upfront what the stack

00:19:05,910 --> 00:19:11,220
size but will grow up to because it i

00:19:09,150 --> 00:19:12,930
presume it can be more efficient and

00:19:11,220 --> 00:19:16,350
then the extra byte code is in the CEO

00:19:12,930 --> 00:19:23,370
and the score curve attribute and it's a

00:19:16,350 --> 00:19:25,590
long byte string really the this one

00:19:23,370 --> 00:19:28,440
it's got the same i omitted some up some

00:19:25,590 --> 00:19:31,110
am so much meat on the previous one like

00:19:28,440 --> 00:19:33,660
like the bottom ones here and similarly

00:19:31,110 --> 00:19:34,710
I'm emitting some like the file name

00:19:33,660 --> 00:19:36,690
will be on this

00:19:34,710 --> 00:19:39,330
of course etc so everything is always

00:19:36,690 --> 00:19:40,980
there but this one isn't some function

00:19:39,330 --> 00:19:43,890
that we had this one doesn't have any

00:19:40,980 --> 00:19:46,860
names which is interesting it is half

00:19:43,890 --> 00:19:49,770
constant so again a doc string and two

00:19:46,860 --> 00:19:52,830
integers that it uses it tells you the

00:19:49,770 --> 00:19:56,220
argument count and it says that I'm no

00:19:52,830 --> 00:19:58,320
keywords on the argument because I'm

00:19:56,220 --> 00:20:02,220
skipping cubed over all the organs for

00:19:58,320 --> 00:20:05,850
now there are and in selves hours of

00:20:02,220 --> 00:20:08,100
free vas is again I'm going to skip this

00:20:05,850 --> 00:20:09,270
but if you've got nested functions than

00:20:08,100 --> 00:20:11,929
so you've got a function and in the

00:20:09,270 --> 00:20:14,399
function you define order function you

00:20:11,929 --> 00:20:17,909
you can have you can use variables from

00:20:14,399 --> 00:20:19,470
outside from the parent function so

00:20:17,909 --> 00:20:21,059
selves are so basically in the parent

00:20:19,470 --> 00:20:22,740
function saying these variables are

00:20:21,059 --> 00:20:25,590
going to be used by some of some

00:20:22,740 --> 00:20:27,179
functions lower down free versus the

00:20:25,590 --> 00:20:29,279
opposite in function Lloyd I'm saying

00:20:27,179 --> 00:20:33,539
these fibers need to come from somewhere

00:20:29,279 --> 00:20:35,460
higher up on that yeah I'm skipping

00:20:33,539 --> 00:20:38,909
implication of those number of locals

00:20:35,460 --> 00:20:41,429
again I I don't really care about I

00:20:38,909 --> 00:20:44,279
think C Python lights to do they can

00:20:41,429 --> 00:20:47,309
pre-allocate stuff all down knowing that

00:20:44,279 --> 00:20:49,049
any extra variable names used that is

00:20:47,309 --> 00:20:53,130
useful that will end up in your local

00:20:49,049 --> 00:20:54,870
dictionary again a snack size and the

00:20:53,130 --> 00:20:59,850
actual bytecode just a little bit short

00:20:54,870 --> 00:21:02,700
in this case so what what what's in the

00:20:59,850 --> 00:21:06,740
by code again the standard library is is

00:21:02,700 --> 00:21:09,210
greater this disassembler module dis

00:21:06,740 --> 00:21:11,880
it's very good it actually documents

00:21:09,210 --> 00:21:13,289
even all the byte codes that are used so

00:21:11,880 --> 00:21:15,779
you don't even have to go and read a

00:21:13,289 --> 00:21:19,169
source code it's all right there and

00:21:15,779 --> 00:21:21,149
it's do really useful functions is this

00:21:19,169 --> 00:21:25,080
not show code which will very quickly

00:21:21,149 --> 00:21:26,490
dump your code object and an easy and

00:21:25,080 --> 00:21:28,440
not a nice summary of all those

00:21:26,490 --> 00:21:30,870
attributes that it has and this not this

00:21:28,440 --> 00:21:35,340
which will tell you what the bikers are

00:21:30,870 --> 00:21:38,580
and what they look like so yeah that's

00:21:35,340 --> 00:21:40,359
have a look Lee if I take a function

00:21:38,580 --> 00:21:43,009
object I have

00:21:40,359 --> 00:21:46,419
that's that's how it shows it and that's

00:21:43,009 --> 00:21:46,419
the SN things you want to care about

00:21:46,749 --> 00:21:53,509
yeah we've gone over this already and

00:21:50,539 --> 00:21:56,239
then actually looking at a bike code if

00:21:53,509 --> 00:22:00,379
you use this to this just as a reference

00:21:56,239 --> 00:22:01,850
what the function look like here you can

00:22:00,379 --> 00:22:09,320
start to see what what what's kind of

00:22:01,850 --> 00:22:12,619
happening that's the function arguments

00:22:09,320 --> 00:22:16,909
end up being in the local stitchery of

00:22:12,619 --> 00:22:19,809
the function by the corner kind of so

00:22:16,909 --> 00:22:23,929
you're loading your loading the variable

00:22:19,809 --> 00:22:25,340
onto the stack so python is this kind of

00:22:23,929 --> 00:22:26,629
a stack-based virtual machine so it's

00:22:25,340 --> 00:22:28,129
got this pack and then it's got this

00:22:26,629 --> 00:22:32,090
couple of arrays the variable names in

00:22:28,129 --> 00:22:34,669
the constants and can look up to all the

00:22:32,090 --> 00:22:37,039
arguments so maybe I should suffer stand

00:22:34,669 --> 00:22:38,330
what what the difference things are the

00:22:37,039 --> 00:22:41,539
numbers on the first line is actually

00:22:38,330 --> 00:22:43,909
not line numbers in the source code this

00:22:41,539 --> 00:22:46,309
one is done the address of the bytecode

00:22:43,909 --> 00:22:50,769
which is just an index into that string

00:22:46,309 --> 00:22:54,799
of that byte array in the co code object

00:22:50,769 --> 00:22:57,440
or attribute then you've got the name of

00:22:54,799 --> 00:22:59,830
the bytecode and then the last columnist

00:22:57,440 --> 00:23:03,139
is the attribute which is always a

00:22:59,830 --> 00:23:04,759
number as well but depending on the

00:23:03,139 --> 00:23:06,919
bytecode that attribute that number

00:23:04,759 --> 00:23:10,009
means look up something from this

00:23:06,919 --> 00:23:13,609
Constance array or look something up

00:23:10,009 --> 00:23:15,769
from this names array and between

00:23:13,609 --> 00:23:17,570
brackets is hit the disassembler does

00:23:15,769 --> 00:23:20,659
this already for you so you can nicely

00:23:17,570 --> 00:23:23,450
see what's happening so it's low this

00:23:20,659 --> 00:23:25,759
one is loading the variable a it's

00:23:23,450 --> 00:23:28,519
loading or two it's multiplying those

00:23:25,759 --> 00:23:30,619
and then it's storing it again so it's

00:23:28,519 --> 00:23:32,179
loading a onto the stack it's loading

00:23:30,619 --> 00:23:34,159
one onto the stack then it's multiplying

00:23:32,179 --> 00:23:36,909
those multiply and we'll pop those

00:23:34,159 --> 00:23:40,999
through all the stack and then we'll

00:23:36,909 --> 00:23:43,059
push the result back onto this type and

00:23:40,999 --> 00:23:48,220
the result of that it will store again

00:23:43,059 --> 00:23:51,130
into into a variable same same for be

00:23:48,220 --> 00:23:55,510
from the next block the next line does

00:23:51,130 --> 00:23:58,210
the same kind of thing and then yeah and

00:23:55,510 --> 00:24:03,340
again it just works through it line up

00:23:58,210 --> 00:24:13,150
at the end returns a value by pushing it

00:24:03,340 --> 00:24:16,240
on the stack I think we'll okay so as I

00:24:13,150 --> 00:24:19,870
said actual these are these are the byte

00:24:16,240 --> 00:24:22,450
code names the they are documented in

00:24:19,870 --> 00:24:25,030
the dis module and tells you what they

00:24:22,450 --> 00:24:27,010
do which I thought of set already it

00:24:25,030 --> 00:24:28,480
also says what what happens from the

00:24:27,010 --> 00:24:30,909
stack due to static etcetera which is

00:24:28,480 --> 00:24:35,070
all very it's very helpful when you're

00:24:30,909 --> 00:24:35,070
trying to understand what the bios do II

00:24:37,679 --> 00:24:41,470
know this is where I should really have

00:24:39,730 --> 00:24:43,440
a nice solid picture of how r DVM kind

00:24:41,470 --> 00:24:46,809
of works with the star can the various

00:24:43,440 --> 00:24:50,980
erase that I'm not great at picture so i

00:24:46,809 --> 00:24:52,900
wrote a class instead and visit this is

00:24:50,980 --> 00:24:55,900
my own class implementation of frame

00:24:52,900 --> 00:24:59,860
kind of thing but pikemen had frame

00:24:55,900 --> 00:25:02,799
object but and which is kind of looks

00:24:59,860 --> 00:25:05,830
the same like well similar a shin ffff

00:25:02,799 --> 00:25:08,140
code etc that I told the same names as

00:25:05,830 --> 00:25:10,539
fighting us in there just to make it

00:25:08,140 --> 00:25:13,059
simple back is just the previous frame

00:25:10,539 --> 00:25:15,909
so the frame of column code will

00:25:13,059 --> 00:25:19,120
actually contain the code object that

00:25:15,909 --> 00:25:20,650
this frame is going to execute last eyes

00:25:19,120 --> 00:25:23,080
the instruction pointer to the bytecode

00:25:20,650 --> 00:25:26,260
so you know varying the bytecode and

00:25:23,080 --> 00:25:27,820
byte array you're working and then three

00:25:26,260 --> 00:25:31,299
dictionaries for the globe as locals in

00:25:27,820 --> 00:25:33,220
the built-ins to look up and the last

00:25:31,299 --> 00:25:34,510
one I'm doing is the stack which can

00:25:33,220 --> 00:25:36,640
don't fight the unconventional I think

00:25:34,510 --> 00:25:38,559
by putting this into the frame so I'm

00:25:36,640 --> 00:25:40,659
create new stack per frame kind of thing

00:25:38,559 --> 00:25:44,320
usually usually you have just one big

00:25:40,659 --> 00:25:45,940
hug and when frames frames come and go

00:25:44,320 --> 00:25:49,870
they just got a stack pointer saying I'm

00:25:45,940 --> 00:25:53,070
hearing a star for anything it's much

00:25:49,870 --> 00:25:58,029
quicker and easier to do it on here and

00:25:53,070 --> 00:26:00,159
the execute method here is

00:25:58,029 --> 00:26:02,769
what we're going to build up now and

00:26:00,159 --> 00:26:07,090
that would be able to run through Lee by

00:26:02,769 --> 00:26:08,859
codes and actually executed so it's a

00:26:07,090 --> 00:26:15,070
long by tipping extra by code so i was a

00:26:08,859 --> 00:26:18,190
long bike a long byte array the if you

00:26:15,070 --> 00:26:21,399
if you want to read it like more in a

00:26:18,190 --> 00:26:23,440
better ways like its kind of transfer it

00:26:21,399 --> 00:26:25,869
into integers and these are these are

00:26:23,440 --> 00:26:29,909
these are the bites they're integer

00:26:25,869 --> 00:26:33,789
values so you can sort of see from here

00:26:29,909 --> 00:26:35,589
the first the first byte code what was

00:26:33,789 --> 00:26:39,549
slow fast i think which is hundred

00:26:35,589 --> 00:26:41,499
twenty four 900 is its argument so

00:26:39,549 --> 00:26:43,779
arguments consists of two two numbers

00:26:41,499 --> 00:26:47,799
again are combined again little endian

00:26:43,779 --> 00:26:50,109
encoded and tight so an expired code

00:26:47,799 --> 00:26:52,599
will be 100 which I can't remember Wars

00:26:50,109 --> 00:26:56,649
and again the best module is really

00:26:52,599 --> 00:26:58,809
really useful it has a it has a list of

00:26:56,649 --> 00:27:00,369
all the byte codes so you just get the

00:26:58,809 --> 00:27:02,529
indexing you know what you know it came

00:27:00,369 --> 00:27:06,639
and again it's got a map mapping the

00:27:02,529 --> 00:27:10,200
names back to numbers it's really it's

00:27:06,639 --> 00:27:12,879
really nice to have them to look into

00:27:10,200 --> 00:27:15,249
this module there's another thing this

00:27:12,879 --> 00:27:18,549
not have arguments is 90 currently in

00:27:15,249 --> 00:27:21,190
this version anyway don't rely on it and

00:27:18,549 --> 00:27:22,869
that that's what you can use to know

00:27:21,190 --> 00:27:25,749
whether you buy code section augmentin

00:27:22,869 --> 00:27:29,529
or so all byte codes are larger or

00:27:25,749 --> 00:27:33,519
equals to 90 will have an argument I'll

00:27:29,529 --> 00:27:36,879
buy codes that are lower than 91 won't

00:27:33,519 --> 00:27:43,119
have an argument arguments yeah dubai's

00:27:36,879 --> 00:27:46,419
little engine encoding so the first

00:27:43,119 --> 00:27:51,009
first go at writing an EVO loop to

00:27:46,419 --> 00:27:53,879
evaluate their by code them so get get

00:27:51,009 --> 00:27:56,820
get the actual khodam in the battery and

00:27:53,879 --> 00:27:58,749
just making it short variable

00:27:56,820 --> 00:28:03,009
initializing the instruction pointer and

00:27:58,749 --> 00:28:06,159
then the actual loop in C Python service

00:28:03,009 --> 00:28:08,559
is it's an infinite loop until someone

00:28:06,159 --> 00:28:10,750
breaks out of it so it's really easily

00:28:08,559 --> 00:28:12,870
it's really easy to break pythons

00:28:10,750 --> 00:28:16,900
or make it safe all that set by buyer

00:28:12,870 --> 00:28:19,240
but fudging the bytecode if you hand or

00:28:16,900 --> 00:28:21,090
if you just write with Chuck randoms

00:28:19,240 --> 00:28:24,490
things into the bytecode over your hand

00:28:21,090 --> 00:28:26,650
model the bytecode you can actually it's

00:28:24,490 --> 00:28:29,860
not that hard to make sheep I can crash

00:28:26,650 --> 00:28:31,750
and desert air that's why I buy codest

00:28:29,860 --> 00:28:37,630
really trusted thing it needed work

00:28:31,750 --> 00:28:40,030
needs to be correct I decided to the

00:28:37,630 --> 00:28:43,380
action bar codes I again slightly up may

00:28:40,030 --> 00:28:47,620
be beside but it's quicker to just quick

00:28:43,380 --> 00:28:52,620
greatest methods on to the same frame

00:28:47,620 --> 00:28:55,540
object and you basically loop through

00:28:52,620 --> 00:29:00,250
loop through so that's why I do with the

00:28:55,540 --> 00:29:03,310
guitar turn loop to loop through all the

00:29:00,250 --> 00:29:05,020
byte codes after after you've executed a

00:29:03,310 --> 00:29:07,270
method you want to increase the

00:29:05,020 --> 00:29:09,550
instruction pointer that depends on

00:29:07,270 --> 00:29:11,920
whether it's got an armed or not there's

00:29:09,550 --> 00:29:14,590
one opcode I'm treating specially here

00:29:11,920 --> 00:29:19,720
to break out of the loop is there we

00:29:14,590 --> 00:29:26,650
turned value one it just pops stack and

00:29:19,720 --> 00:29:33,940
then returns that value and passing

00:29:26,650 --> 00:29:37,020
arguments is kind of yeah but passing

00:29:33,940 --> 00:29:42,690
argument is kind of trick as well the

00:29:37,020 --> 00:29:44,920
the arguments are are they need to a new

00:29:42,690 --> 00:29:47,440
call another function they need to be

00:29:44,920 --> 00:29:49,090
passed into they need to be put into the

00:29:47,440 --> 00:29:54,190
local dictionary off off your new frame

00:29:49,090 --> 00:29:55,810
that you just created and the code

00:29:54,190 --> 00:30:02,050
object tells you what your ardent

00:29:55,810 --> 00:30:04,450
countess but the so I'm checking the in

00:30:02,050 --> 00:30:06,430
this in this case I just decided to do

00:30:04,450 --> 00:30:10,390
want the argument asked into the actor

00:30:06,430 --> 00:30:11,890
in my ex a method here and so I'm

00:30:10,390 --> 00:30:13,990
checking that they're fine I'm also

00:30:11,890 --> 00:30:16,270
again lead us earth which you shouldn't

00:30:13,990 --> 00:30:17,110
do I'm also checking that because I'm

00:30:16,270 --> 00:30:19,150
not dealing

00:30:17,110 --> 00:30:24,010
once for now also checking that those

00:30:19,150 --> 00:30:25,690
are not used and then you just the

00:30:24,010 --> 00:30:28,380
position of the argument is actually

00:30:25,690 --> 00:30:31,840
important that they get passed into

00:30:28,380 --> 00:30:35,080
because that position that the first

00:30:31,840 --> 00:30:37,270
argument will be you will have to look

00:30:35,080 --> 00:30:40,150
up in this some in the code object again

00:30:37,270 --> 00:30:41,799
the variable names and the position that

00:30:40,150 --> 00:30:44,020
the index of ablation will be reused

00:30:41,799 --> 00:30:46,390
there so that's one the enumerate lived

00:30:44,020 --> 00:30:48,760
us it gets the end explanation of your

00:30:46,390 --> 00:30:50,620
argument and that's that's where it

00:30:48,760 --> 00:30:54,040
looks up the name and that and then it

00:30:50,620 --> 00:30:56,350
knows that evaluate got or the object it

00:30:54,040 --> 00:31:01,270
got needs to go in that name in the

00:30:56,350 --> 00:31:04,419
local in the locus dictionary that's

00:31:01,270 --> 00:31:09,580
yeah that's the receiving part of off of

00:31:04,419 --> 00:31:11,950
passing arguments on that yeah well

00:31:09,580 --> 00:31:19,980
that's the honesty extracted it d DX a

00:31:11,950 --> 00:31:19,980
group for now um so handling by codes

00:31:20,340 --> 00:31:27,190
I'm doing them as Mathis one frame

00:31:22,510 --> 00:31:29,530
object here just a great review of to

00:31:27,190 --> 00:31:34,299
this earth again so that's that's what

00:31:29,530 --> 00:31:36,610
you've gone be executing there's yeah

00:31:34,299 --> 00:31:40,150
the simple ones load fast store fast

00:31:36,610 --> 00:31:41,770
they just need to look up the there are

00:31:40,150 --> 00:31:43,450
going to all integers so they need to

00:31:41,770 --> 00:31:47,890
move up in the right away which in this

00:31:43,450 --> 00:31:50,350
case CEO of our names and put them from

00:31:47,890 --> 00:31:52,380
the stack onto onto the locust into the

00:31:50,350 --> 00:31:54,790
Lotus victory or the other way around

00:31:52,380 --> 00:31:57,070
load const needs to look up in the

00:31:54,790 --> 00:32:03,210
constant array that's all pretty

00:31:57,070 --> 00:32:06,070
straightforward binary multiply that's

00:32:03,210 --> 00:32:09,700
it's basically utmost most binary

00:32:06,070 --> 00:32:12,280
operates look very similar if you

00:32:09,700 --> 00:32:14,950
remember the object protocol in not in

00:32:12,280 --> 00:32:16,960
Python basically multiplier is actually

00:32:14,950 --> 00:32:19,000
implemented or can be important in

00:32:16,960 --> 00:32:22,900
Python again itself so you need to look

00:32:19,000 --> 00:32:24,160
up the London Mill operator which is

00:32:22,900 --> 00:32:26,950
generally gold

00:32:24,160 --> 00:32:29,590
on the left-hand object and with their I

00:32:26,950 --> 00:32:31,030
tenth one so that that can have a go and

00:32:29,590 --> 00:32:32,950
return a value if it doesn't return

00:32:31,030 --> 00:32:34,450
about it doesn't know the other object

00:32:32,950 --> 00:32:37,890
or doesn't know how to multiply with

00:32:34,450 --> 00:32:40,600
object it just not implemented and then

00:32:37,890 --> 00:32:44,800
Python but we'll go we'll try the other

00:32:40,600 --> 00:32:47,290
object and say you have a mole method if

00:32:44,800 --> 00:32:49,210
so do you know how to multiply you

00:32:47,290 --> 00:32:53,380
salford with the order of the first

00:32:49,210 --> 00:32:55,300
object that's what this lubed us it

00:32:53,380 --> 00:32:58,930
needs to pop those values of the stack

00:32:55,300 --> 00:33:00,700
needs to come and then adjust Jack's

00:32:58,930 --> 00:33:03,790
read it whether that done the mole

00:33:00,700 --> 00:33:06,820
method is available calls it and and

00:33:03,790 --> 00:33:08,800
then at the end the if none of them know

00:33:06,820 --> 00:33:12,070
how to multiply you get a type error

00:33:08,800 --> 00:33:14,680
otherwise result always goes back to the

00:33:12,070 --> 00:33:18,960
stack you said so byte codes just

00:33:14,680 --> 00:33:18,960
operate must not well

00:33:26,630 --> 00:33:36,430
and I'm okay possibly i'm not sure i

00:33:32,540 --> 00:33:36,430
would have to check it might be yes

00:33:38,260 --> 00:33:46,640
binary ad yeah very similar basically

00:33:44,210 --> 00:33:49,130
well almost the same just another method

00:33:46,640 --> 00:33:54,920
but again possibly our art as well I

00:33:49,130 --> 00:33:57,050
imagine and if it's our milk or than

00:33:54,920 --> 00:33:59,210
that it's exactly the same it just goes

00:33:57,050 --> 00:34:04,370
it to object tries to cheat you know how

00:33:59,210 --> 00:34:07,070
to add yourself to the other one return

00:34:04,370 --> 00:34:08,659
value is actually nothing in this case

00:34:07,070 --> 00:34:11,710
because we are early special case that

00:34:08,659 --> 00:34:14,740
in the eval loop so the return value is

00:34:11,710 --> 00:34:16,909
not going to be it doesn't know anything

00:34:14,740 --> 00:34:20,600
in return value need to support the

00:34:16,909 --> 00:34:27,379
stack and then return it that value to

00:34:20,600 --> 00:34:30,500
the caller basically though the tiny of

00:34:27,379 --> 00:34:33,040
vm that we have been building so far it

00:34:30,500 --> 00:34:36,889
can actually execute this method now

00:34:33,040 --> 00:34:38,990
yeah if with this code if you're great

00:34:36,889 --> 00:34:41,770
frame with really code object but for

00:34:38,990 --> 00:34:43,760
some you execute it with some parameters

00:34:41,770 --> 00:34:48,530
comes out with the back of the right

00:34:43,760 --> 00:34:50,720
result executors entirely Oh time to

00:34:48,530 --> 00:34:52,570
look at module the module is a lot

00:34:50,720 --> 00:34:56,270
bigger it doesn't fit on the screen

00:34:52,570 --> 00:34:57,470
again you can see sort of do things

00:34:56,270 --> 00:35:01,280
you've not the you can brief scene

00:34:57,470 --> 00:35:03,230
already loads of doc string and module

00:35:01,280 --> 00:35:05,870
to actually get this a Saturday assigned

00:35:03,230 --> 00:35:07,460
on to dork explicitly and functions

00:35:05,870 --> 00:35:12,800
going to happen simplicity runs great

00:35:07,460 --> 00:35:16,120
function object and then it online for

00:35:12,800 --> 00:35:18,440
it gets more interesting it loads this

00:35:16,120 --> 00:35:20,270
again loads of constant which is code

00:35:18,440 --> 00:35:22,940
object in this case then it calls this

00:35:20,270 --> 00:35:25,580
make function thing a make function is

00:35:22,940 --> 00:35:28,370
actually very is going to take that code

00:35:25,580 --> 00:35:31,160
object and create a functional check out

00:35:28,370 --> 00:35:34,760
of it it will then pay that function

00:35:31,160 --> 00:35:37,460
object and store it into an order

00:35:34,760 --> 00:35:37,970
variable it's using store name now

00:35:37,460 --> 00:35:42,160
instead of

00:35:37,970 --> 00:35:46,160
fast and there's subtle difference here

00:35:42,160 --> 00:35:48,590
similarly the next line is like line 11

00:35:46,160 --> 00:35:55,970
that was the if statement if name equals

00:35:48,590 --> 00:35:57,530
main thodi if statement loads load name

00:35:55,970 --> 00:35:58,970
load bombs the boatloads of those who

00:35:57,530 --> 00:36:00,380
will end up putting something on the

00:35:58,970 --> 00:36:03,140
stack so now you've got two new writers

00:36:00,380 --> 00:36:04,970
on the stack compare up will will take

00:36:03,140 --> 00:36:07,760
us to write another stack do the

00:36:04,970 --> 00:36:11,359
comparison and put the result back onto

00:36:07,760 --> 00:36:13,670
the stack the next is the actual if kind

00:36:11,359 --> 00:36:17,840
of statement page the top of the stack

00:36:13,670 --> 00:36:19,849
again and if if it's deaths whether it's

00:36:17,840 --> 00:36:22,400
fault or not if it falls it will do an

00:36:19,849 --> 00:36:27,170
absolute jump the argument here 49 is

00:36:22,400 --> 00:36:29,300
actually the address off in the bath

00:36:27,170 --> 00:36:30,859
career egg and so this is the address of

00:36:29,300 --> 00:36:35,090
the bytecode the next byte code that you

00:36:30,859 --> 00:36:37,820
want to execute and I think a split of

00:36:35,090 --> 00:36:41,920
juice like this and so the last is

00:36:37,820 --> 00:36:45,619
duplicating slight little bit said so

00:36:41,920 --> 00:36:47,750
and then what once what if it's not

00:36:45,619 --> 00:36:50,030
jumping past this certainly these double

00:36:47,750 --> 00:36:52,790
arrows bits and sorry the double arrow

00:36:50,030 --> 00:36:54,589
bit is the jump label x goes to which is

00:36:52,790 --> 00:37:00,440
something else that this gives you which

00:36:54,589 --> 00:37:02,030
were not not now but what was he doing

00:37:00,440 --> 00:37:03,589
now is it's basically load to do names

00:37:02,030 --> 00:37:05,900
again which is print and sun which the

00:37:03,589 --> 00:37:09,020
two functions so they'll be popped onto

00:37:05,900 --> 00:37:13,099
the stack and to function objects then

00:37:09,020 --> 00:37:15,410
it will put two constants in and the two

00:37:13,099 --> 00:37:17,800
integers there 15 and 4 will again pop

00:37:15,410 --> 00:37:20,150
those on the stack on top of the

00:37:17,800 --> 00:37:22,630
functional object and then it will call

00:37:20,150 --> 00:37:24,349
the function so that's how and

00:37:22,630 --> 00:37:26,599
parameters are passed to the function

00:37:24,349 --> 00:37:28,670
they are pop and pushed onto the stack

00:37:26,599 --> 00:37:30,650
and then thank the call function will

00:37:28,670 --> 00:37:33,170
pop those on off to the stack and give

00:37:30,650 --> 00:37:38,570
them to do to the new frame in the

00:37:33,170 --> 00:37:40,400
correct way and you can see now nest of

00:37:38,570 --> 00:37:42,530
course as well so call function will

00:37:40,400 --> 00:37:47,690
then push back on the stack the result

00:37:42,530 --> 00:37:49,900
of the of the function call and the next

00:37:47,690 --> 00:37:53,190
function will have that as its argument

00:37:49,900 --> 00:37:56,020
and pop that of a stack again to execute

00:37:53,190 --> 00:37:57,190
call function will end up removing the

00:37:56,020 --> 00:37:58,720
because the function is still on the

00:37:57,190 --> 00:38:00,540
stack as well I said we're end up

00:37:58,720 --> 00:38:05,260
removing the function of the stack do

00:38:00,540 --> 00:38:07,720
and there's a jump forward there that's

00:38:05,260 --> 00:38:09,370
a relative jump I'm not entirely a wider

00:38:07,720 --> 00:38:11,410
compiler put that in there because it's

00:38:09,370 --> 00:38:15,370
just moving to next by code is actually

00:38:11,410 --> 00:38:19,090
not doing anything um jump forward 0 and

00:38:15,370 --> 00:38:20,560
at the end yeah load constant alert

00:38:19,090 --> 00:38:23,440
normal Eric returns it so that's what

00:38:20,560 --> 00:38:28,780
the module kind of returns so the new

00:38:23,440 --> 00:38:30,850
byte codes store name that's big step

00:38:28,780 --> 00:38:33,460
forward you just get stored into the

00:38:30,850 --> 00:38:35,860
locals dictionary again you need to look

00:38:33,460 --> 00:38:38,530
up the name in the right in the right

00:38:35,860 --> 00:38:41,260
array again co names in this case load

00:38:38,530 --> 00:38:43,570
name is and this is where you can see

00:38:41,260 --> 00:38:46,540
why we had a load fast earlier load

00:38:43,570 --> 00:38:48,340
names is a neat need to actually check

00:38:46,540 --> 00:38:50,470
where the names come from where the name

00:38:48,340 --> 00:38:52,480
comes from so it starts with the locals

00:38:50,470 --> 00:38:54,820
dictionary it's not in the locus it will

00:38:52,480 --> 00:38:56,470
start with pride Global's and it's not

00:38:54,820 --> 00:39:00,610
in the Global's it will look at the

00:38:56,470 --> 00:39:02,740
built-ins and that's that's why I load

00:39:00,610 --> 00:39:04,660
fast was kind of if the course of

00:39:02,740 --> 00:39:07,330
compiler sometimes can know as it will

00:39:04,660 --> 00:39:09,400
be in the locals and it in that case you

00:39:07,330 --> 00:39:10,750
will put load fasting there so it

00:39:09,400 --> 00:39:16,740
doesn't have to do all those lookups

00:39:10,750 --> 00:39:21,160
it's a lot quicker when doesn't it know

00:39:16,740 --> 00:39:23,110
and there's there's a there's a look

00:39:21,160 --> 00:39:24,970
fast there's a load global I think as

00:39:23,110 --> 00:39:27,780
well so sometimes combined no sense and

00:39:24,970 --> 00:39:27,780
then there's load name

00:39:36,339 --> 00:39:40,960
if you if you if you use a global you

00:39:39,519 --> 00:39:43,269
know the global statement in a function

00:39:40,960 --> 00:39:45,579
so if you use that it knows it needs to

00:39:43,269 --> 00:39:47,739
go to global but if not if you haven't

00:39:45,579 --> 00:39:53,950
used to father yet so it needs to do

00:39:47,739 --> 00:39:56,650
yeah go back look outside um name error

00:39:53,950 --> 00:39:58,269
if he doesn't find it and put your

00:39:56,650 --> 00:40:04,059
results back on the stack may function

00:39:58,269 --> 00:40:06,609
then quite the right size but yeah this

00:40:04,059 --> 00:40:08,380
this one doesn't handle default values

00:40:06,609 --> 00:40:11,969
doesn't then keyboard argument cedar

00:40:08,380 --> 00:40:20,229
keyboard only organs but basically it

00:40:11,969 --> 00:40:22,719
what pops the pop c function pops it

00:40:20,229 --> 00:40:27,880
pops the function object of the stack

00:40:22,719 --> 00:40:30,400
and then it will prom date with the

00:40:27,880 --> 00:40:32,799
create create a function object sorry

00:40:30,400 --> 00:40:35,680
yeah the pub's code objects or the stack

00:40:32,799 --> 00:40:38,380
sorry and create a function object from

00:40:35,680 --> 00:40:40,960
it I could have defined my own function

00:40:38,380 --> 00:40:42,999
object but the types module in Python

00:40:40,960 --> 00:40:46,900
lets you create new function objects

00:40:42,999 --> 00:40:52,089
from from scratch by function type all

00:40:46,900 --> 00:40:53,739
it needs is the code object which I just

00:40:52,089 --> 00:40:58,269
popped on the stack and the Global's

00:40:53,739 --> 00:41:01,450
victory puts that back onto stack and

00:40:58,269 --> 00:41:02,799
now you've got a function object around

00:41:01,450 --> 00:41:06,339
which will probably be stored in a

00:41:02,799 --> 00:41:08,859
variable next bunch of objects have a

00:41:06,339 --> 00:41:10,359
couple of and attributes that you might

00:41:08,859 --> 00:41:12,519
have encountered the code objective

00:41:10,359 --> 00:41:14,619
referenced in there you've got a quick

00:41:12,519 --> 00:41:17,380
access to the model letter module etc so

00:41:14,619 --> 00:41:20,890
you don't have to go via the code object

00:41:17,380 --> 00:41:25,319
to find those things its counterpart

00:41:20,890 --> 00:41:28,210
Kyle function is a more interesting so

00:41:25,319 --> 00:41:32,979
again not handling the fault values and

00:41:28,210 --> 00:41:36,579
keyboard only argument it it's it

00:41:32,979 --> 00:41:38,589
argument its argument of that that biker

00:41:36,579 --> 00:41:42,009
gets actually committing to a treat as

00:41:38,589 --> 00:41:43,680
two separate numbers that each bite and

00:41:42,009 --> 00:41:47,280
one of them is the

00:41:43,680 --> 00:41:49,109
a number of arguments which includes at

00:41:47,280 --> 00:41:52,230
once with default values the other is

00:41:49,109 --> 00:41:53,849
the gate key words our arguments passed

00:41:52,230 --> 00:41:58,200
and i think that's keyboards on the

00:41:53,849 --> 00:42:01,530
argument so yeah you have to have to

00:41:58,200 --> 00:42:07,770
split it decomposes that again by some

00:42:01,530 --> 00:42:10,770
shifting and ending together again I'm

00:42:07,770 --> 00:42:12,869
skipping keyword arguments and then the

00:42:10,770 --> 00:42:16,200
next thing it needs to do is for each

00:42:12,869 --> 00:42:18,420
argument it needs to look through needs

00:42:16,200 --> 00:42:20,040
to pop the arguments from the stack in

00:42:18,420 --> 00:42:21,690
this case that they're just the

00:42:20,040 --> 00:42:26,430
positional arguments and they'll be on

00:42:21,690 --> 00:42:28,500
the stack in the right position get

00:42:26,430 --> 00:42:29,970
keyword arguments would be as the key

00:42:28,500 --> 00:42:31,619
name and then the value name would all

00:42:29,970 --> 00:42:35,339
be on the stack they need to be popped

00:42:31,619 --> 00:42:38,339
in the right order so I'm popping them

00:42:35,339 --> 00:42:41,130
all off the stack I need to reverse them

00:42:38,339 --> 00:42:43,440
to pass them on to my function and then

00:42:41,130 --> 00:42:46,470
the next thing is you need to you need

00:42:43,440 --> 00:42:48,290
to differentiate use of functions and

00:42:46,470 --> 00:42:50,369
built-in functions so I'm checking

00:42:48,290 --> 00:42:52,910
basically built in function swamp ever

00:42:50,369 --> 00:42:56,160
done the code attributes so I'm checking

00:42:52,910 --> 00:42:59,010
whether it's User function using their

00:42:56,160 --> 00:43:01,859
attribute if it is I know I can create a

00:42:59,010 --> 00:43:04,799
frame again which I'm using to execute

00:43:01,859 --> 00:43:09,180
it a parsing the right yeah there are

00:43:04,799 --> 00:43:11,030
passing the globe and the code of yeah

00:43:09,180 --> 00:43:14,609
and the code of Jackie needs to do a

00:43:11,030 --> 00:43:17,190
great frame for and then execute it with

00:43:14,609 --> 00:43:19,440
you with the arguments if it's a

00:43:17,190 --> 00:43:21,960
built-in function I just got it directly

00:43:19,440 --> 00:43:25,920
and printed a built-in function so I had

00:43:21,960 --> 00:43:28,740
to with our special gated and well both

00:43:25,920 --> 00:43:31,700
in code will do what if this do the

00:43:28,740 --> 00:43:33,630
right thing the return value of a

00:43:31,700 --> 00:43:38,339
calling that function nice if we push

00:43:33,630 --> 00:43:44,880
back on to stack again and I think I've

00:43:38,339 --> 00:43:46,920
said this already so yeah the thing that

00:43:44,880 --> 00:43:48,240
you can that the number of arguments

00:43:46,920 --> 00:43:49,200
that the thing that you can learn from

00:43:48,240 --> 00:43:51,869
there actually is the number of

00:43:49,200 --> 00:43:53,490
arguments is eating a half maximum 1055

00:43:51,869 --> 00:43:54,760
arguments passed them to a function

00:43:53,490 --> 00:43:59,220
because of that bike

00:43:54,760 --> 00:44:05,040
how their bike would argue misused just

00:43:59,220 --> 00:44:08,080
hidden limitation somewhere in Titan yep

00:44:05,040 --> 00:44:12,330
pop jump is false it's pretty

00:44:08,080 --> 00:44:15,550
straightforward you need to change the

00:44:12,330 --> 00:44:19,180
target the instruction pointer at the

00:44:15,550 --> 00:44:20,530
target doing minus 3 because I know that

00:44:19,180 --> 00:44:24,120
the if I loop will actually add three

00:44:20,530 --> 00:44:24,120
straight after this function returns

00:44:24,720 --> 00:44:30,630
which yeah if I look just that's three

00:44:30,660 --> 00:44:38,200
jump forward it's very very

00:44:34,720 --> 00:44:40,120
straightforward just update the update

00:44:38,200 --> 00:44:41,740
instruction pointer pop stack is just

00:44:40,120 --> 00:44:42,880
discarding garland release if you don't

00:44:41,740 --> 00:44:44,710
care about return value of a function

00:44:42,880 --> 00:44:50,200
like we don't care about return value of

00:44:44,710 --> 00:44:56,100
print that's why we go up top in there

00:44:50,200 --> 00:44:58,150
Oh executing the entire module down

00:44:56,100 --> 00:45:01,090
we've seen the first part you get the

00:44:58,150 --> 00:45:02,740
code object next you just you can create

00:45:01,090 --> 00:45:04,660
the coda pretend that that whole frame

00:45:02,740 --> 00:45:07,920
function that I made it's actually able

00:45:04,660 --> 00:45:10,930
of off compiling creating that whole

00:45:07,920 --> 00:45:13,330
executing that whole got a little bit i

00:45:10,930 --> 00:45:16,510
checked and it brings out the result

00:45:13,330 --> 00:45:20,200
which is all very good and this is very

00:45:16,510 --> 00:45:23,080
incomplete obviously I've mentioned most

00:45:20,200 --> 00:45:24,910
of the limitations and but it gives you

00:45:23,080 --> 00:45:26,890
an idea of how how the bytecode

00:45:24,910 --> 00:45:29,380
interpreter kind of works how it uses

00:45:26,890 --> 00:45:31,000
those by codes what you can sort of do

00:45:29,380 --> 00:45:34,690
and one of the things i skipped was

00:45:31,000 --> 00:45:36,640
extended art and just byte codes if you

00:45:34,690 --> 00:45:40,510
don't have a it's a bad code that adds

00:45:36,640 --> 00:45:42,970
extra information on to if the argument

00:45:40,510 --> 00:45:48,970
because you're limited to 2 to the power

00:45:42,970 --> 00:45:50,740
4 16 argument all right yeah it's

00:45:48,970 --> 00:45:52,390
unlikely because the sort of things

00:45:50,740 --> 00:45:54,940
you're looking business arguments that

00:45:52,390 --> 00:45:56,530
they're going to the array of Pharma our

00:45:54,940 --> 00:45:58,210
names array of names constant sister

00:45:56,530 --> 00:46:03,990
giants unlikely to have more than and

00:45:58,210 --> 00:46:06,730
that money yeah I'm supposed to stop now

00:46:03,990 --> 00:46:07,520
there's like a very good thing of four

00:46:06,730 --> 00:46:09,500
people

00:46:07,520 --> 00:46:11,870
on the wrong with my code really you

00:46:09,500 --> 00:46:14,530
don't want to do those there's a couple

00:46:11,870 --> 00:46:18,050
of modules that help you making

00:46:14,530 --> 00:46:19,910
handcraft by code if you want people

00:46:18,050 --> 00:46:23,990
have managed to do go to people have

00:46:19,910 --> 00:46:26,300
some people actually is actually

00:46:23,990 --> 00:46:30,500
slightly useful is this for the coverage

00:46:26,300 --> 00:46:32,000
that package that by changing lineman

00:46:30,500 --> 00:46:37,330
was a managed to get more cough or a

00:46:32,000 --> 00:46:39,260
child of it decompiling obfuscation

00:46:37,330 --> 00:46:41,090
application is quite bad because you

00:46:39,260 --> 00:46:47,960
can't retrace backs anymore so it's not

00:46:41,090 --> 00:46:50,720
get very hoodie yeah and then I think

00:46:47,960 --> 00:46:53,780
I'm in honor that mentioned some quite

00:46:50,720 --> 00:46:56,480
horrible things since fog earlier this

00:46:53,780 --> 00:47:00,410
week a switch statement has been

00:46:56,480 --> 00:47:02,800
implemented as well and yeah that was it

00:47:00,410 --> 00:47:02,800
I think

00:47:10,059 --> 00:47:21,680
so there is room for some questions oh

00:47:14,410 --> 00:47:27,920
let's have a direction you can you can

00:47:21,680 --> 00:47:34,160
pass the microphone beyond you I said

00:47:27,920 --> 00:47:36,260
okay good maybe a silly question but why

00:47:34,160 --> 00:47:38,359
do you need always to use the underscore

00:47:36,260 --> 00:47:41,569
methods for example when you multiply

00:47:38,359 --> 00:47:44,180
you do underscore underscore mall and

00:47:41,569 --> 00:47:46,430
then instead of just using the multiply

00:47:44,180 --> 00:47:49,520
operator what's the difference that's

00:47:46,430 --> 00:47:51,319
the way apart by multiplying is

00:47:49,520 --> 00:47:52,940
implemented as protocol so if you create

00:47:51,319 --> 00:47:55,910
your own class you can define that

00:47:52,940 --> 00:47:59,030
method on the square mu and that's the

00:47:55,910 --> 00:48:00,849
protocol that parking is due to multiply

00:47:59,030 --> 00:48:03,319
so it means you can overwrite

00:48:00,849 --> 00:48:06,170
multiplication and things like that and

00:48:03,319 --> 00:48:07,819
that the way of looking up that mill

00:48:06,170 --> 00:48:10,130
method passing in the other argument

00:48:07,819 --> 00:48:11,510
instead of just using multiple I mean I

00:48:10,130 --> 00:48:13,040
could have done that directly indeed

00:48:11,510 --> 00:48:15,440
because I'm skipping many things already

00:48:13,040 --> 00:48:17,690
anyway but that that's how the Python

00:48:15,440 --> 00:48:20,000
protocol kind of hurts because I mean

00:48:17,690 --> 00:48:22,569
when you check the mall and do all the

00:48:20,000 --> 00:48:25,190
things in the binary x near multiply

00:48:22,569 --> 00:48:27,319
function you could just do a

00:48:25,190 --> 00:48:30,079
multiplication and then the exception is

00:48:27,319 --> 00:48:32,359
raised automatically by Python if the

00:48:30,079 --> 00:48:35,030
mold is not found so there was just one

00:48:32,359 --> 00:48:37,760
line instead of all the things I just I

00:48:35,030 --> 00:48:39,020
just wanted to destroy what if I would

00:48:37,760 --> 00:48:40,369
have put in a multiplication with you

00:48:39,020 --> 00:48:43,010
objects that would have had the same

00:48:40,369 --> 00:48:48,250
result I just wanted to show that how it

00:48:43,010 --> 00:48:48,250
would actually have to do it thanks

00:48:56,219 --> 00:49:02,049
okay so first of all you do need the our

00:48:59,679 --> 00:49:04,179
mole and our ad and all those that's

00:49:02,049 --> 00:49:07,779
used if you for the right hand side so

00:49:04,179 --> 00:49:09,969
consider division where 3/5 is very

00:49:07,779 --> 00:49:13,239
different from 5/3 or multiplication

00:49:09,969 --> 00:49:14,890
with the string and an integer the other

00:49:13,239 --> 00:49:17,079
thing was there was a question about

00:49:14,890 --> 00:49:20,349
global and so I wanted to say very

00:49:17,079 --> 00:49:23,229
quickly exactly how global works when

00:49:20,349 --> 00:49:25,809
Python when C Python generates the byte

00:49:23,229 --> 00:49:27,640
code for something all locals are stored

00:49:25,809 --> 00:49:29,439
in the locals dictionary and then

00:49:27,640 --> 00:49:30,969
there's a post processing step after the

00:49:29,439 --> 00:49:33,339
compilation of a function that scans

00:49:30,969 --> 00:49:34,869
over and looks for assignments whenever

00:49:33,339 --> 00:49:37,089
it finds an assignment it says a hot

00:49:34,869 --> 00:49:39,249
this can be a load fast and it converts

00:49:37,089 --> 00:49:42,549
all the references to that variable into

00:49:39,249 --> 00:49:43,900
load fast or fast so that's why whenever

00:49:42,549 --> 00:49:47,410
you assign something inside of a

00:49:43,900 --> 00:49:50,079
function it occludes the global that

00:49:47,410 --> 00:49:52,239
matches that so you have to in order to

00:49:50,079 --> 00:49:53,979
access the in order to will be able to

00:49:52,239 --> 00:49:56,469
assign to a global you have to say

00:49:53,979 --> 00:49:58,859
global and then in Python 3 2 non-local

00:49:56,469 --> 00:49:58,859
as well

00:50:06,650 --> 00:50:16,760
so any more question about it okay thank

00:50:14,340 --> 00:50:16,760

YouTube URL: https://www.youtube.com/watch?v=c08Ee2gQ3pY


