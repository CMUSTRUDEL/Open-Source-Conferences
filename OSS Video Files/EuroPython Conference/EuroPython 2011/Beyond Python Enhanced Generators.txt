Title: Beyond Python Enhanced Generators
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Erik Groeneveld - 23 June 2011 in "Track Spaghetti"
Captions: 
	00:00:09,559 --> 00:00:14,520
before I begin I'd like to thank you for

00:00:12,209 --> 00:00:17,369
all coming here I expected about 10 or

00:00:14,520 --> 00:00:20,310
20 people to have a very deep technical

00:00:17,369 --> 00:00:22,560
discussion then when I saw the number of

00:00:20,310 --> 00:00:24,539
attendees you expected that in these I

00:00:22,560 --> 00:00:27,119
changed my presentation in a little bit

00:00:24,539 --> 00:00:30,989
I've some more slides to give you more

00:00:27,119 --> 00:00:33,239
perspective and background and maybe a

00:00:30,989 --> 00:00:39,000
little bit of less code but it's I still

00:00:33,239 --> 00:00:41,940
think it's 5050 my name is Eric I'm from

00:00:39,000 --> 00:00:45,330
the company called seeker I started my

00:00:41,940 --> 00:00:48,210
own company about 10 years ago to do fun

00:00:45,330 --> 00:00:50,490
stuff what I'm going to present today is

00:00:48,210 --> 00:00:59,660
one of these things that we think is fun

00:00:50,490 --> 00:01:02,010
stuff there is a has been a lot of

00:00:59,660 --> 00:01:04,049
talking going on about bite and three

00:01:02,010 --> 00:01:06,600
and are a lot of changes in part and

00:01:04,049 --> 00:01:11,220
three but I think that there was really

00:01:06,600 --> 00:01:13,950
one big deep profound change in Python

00:01:11,220 --> 00:01:18,360
and that happened when generalized

00:01:13,950 --> 00:01:21,630
generators came into Python 205 and that

00:01:18,360 --> 00:01:24,870
was really i think the most profound

00:01:21,630 --> 00:01:28,950
change that probably has ever been in

00:01:24,870 --> 00:01:32,210
python because they were simply no other

00:01:28,950 --> 00:01:35,010
way there was no workaround to

00:01:32,210 --> 00:01:41,700
completely structure your programs in a

00:01:35,010 --> 00:01:45,180
completely different way i hope i will

00:01:41,700 --> 00:01:49,710
make that clear during this during this

00:01:45,180 --> 00:01:51,750
talk i also still working on python to

00:01:49,710 --> 00:01:53,549
load five and two dot six I'm not moving

00:01:51,750 --> 00:01:55,110
forward because my main debian

00:01:53,549 --> 00:01:57,930
distribution doesn't move forward so

00:01:55,110 --> 00:02:00,540
quickly and I'm perfectly happy with

00:01:57,930 --> 00:02:02,790
that but if I find a distribution with

00:02:00,540 --> 00:02:04,860
Biden to the four then I immediately

00:02:02,790 --> 00:02:06,330
start compiling my own part into the

00:02:04,860 --> 00:02:13,230
five because this is really essential

00:02:06,330 --> 00:02:15,870
this generator stuff so at a time when I

00:02:13,230 --> 00:02:18,970
turn to the five came out and I heard of

00:02:15,870 --> 00:02:21,640
this generalized generators which

00:02:18,970 --> 00:02:22,900
also called currencies which there

00:02:21,640 --> 00:02:26,080
aren't actually colored things would i

00:02:22,900 --> 00:02:29,890
look like it i started thinking about

00:02:26,080 --> 00:02:33,750
what you could do with that and then i

00:02:29,890 --> 00:02:36,070
created a thing called weightless

00:02:33,750 --> 00:02:40,410
basically there's there's lots of

00:02:36,070 --> 00:02:40,410
activities going on in in this area

00:02:41,490 --> 00:02:47,680
there are many many initiatives that

00:02:44,320 --> 00:02:49,840
just like me people were thrilled by the

00:02:47,680 --> 00:02:52,420
idea of having generalized generators

00:02:49,840 --> 00:02:55,900
and they started coding with it and i

00:02:52,420 --> 00:02:58,360
named a couple of them here like cogan

00:02:55,900 --> 00:03:00,220
GN effing GD fiendish very very popular

00:02:58,360 --> 00:03:04,060
at the moment it was here at dura python

00:03:00,220 --> 00:03:06,280
and it was at european last year picking

00:03:04,060 --> 00:03:08,980
up quite well there's multitaskers event

00:03:06,280 --> 00:03:11,890
lets his monocle there's many many

00:03:08,980 --> 00:03:14,200
others i even listed many others on my

00:03:11,890 --> 00:03:16,270
website and every now and then I check

00:03:14,200 --> 00:03:18,730
these and I see lots of them are gone

00:03:16,270 --> 00:03:21,730
and every now and then new initiatives

00:03:18,730 --> 00:03:23,290
arrive so i was doing weightless and

00:03:21,730 --> 00:03:24,850
what is what's the reason for doing

00:03:23,290 --> 00:03:29,230
weightless if there are so many other

00:03:24,850 --> 00:03:32,110
alternatives but what I'm trying to do

00:03:29,230 --> 00:03:34,269
today is also show you what different

00:03:32,110 --> 00:03:37,030
what with weightless makes what makes

00:03:34,269 --> 00:03:39,250
wait is different and it is basically

00:03:37,030 --> 00:03:42,540
that I think most of these other

00:03:39,250 --> 00:03:46,930
initiatives are working with co routines

00:03:42,540 --> 00:03:50,040
to do lightweight scheduling maybe I'm

00:03:46,930 --> 00:03:53,070
grossly simplifying matters here so

00:03:50,040 --> 00:03:55,600
speak up later a she or he don't agree

00:03:53,070 --> 00:03:57,790
but it's just a pinpoint the difference

00:03:55,600 --> 00:04:02,320
and what weightless does it focuses on

00:03:57,790 --> 00:04:04,680
data streaming and yes it also does

00:04:02,320 --> 00:04:07,090
lightweight scheduling but it's the

00:04:04,680 --> 00:04:09,730
initiative it's the intention that's

00:04:07,090 --> 00:04:12,910
that's been different and that leads to

00:04:09,730 --> 00:04:16,030
different results of course a weightless

00:04:12,910 --> 00:04:18,220
consists of three parts first of all

00:04:16,030 --> 00:04:22,440
there is observable which is a

00:04:18,220 --> 00:04:24,900
lightweight framework configuration

00:04:22,440 --> 00:04:27,360
dinghy

00:04:24,900 --> 00:04:29,250
I told I spoke about death on the last

00:04:27,360 --> 00:04:30,600
year's part in conference is basically

00:04:29,250 --> 00:04:32,370
an implementation of the observable

00:04:30,600 --> 00:04:35,639
pattern but then in a more flexible way

00:04:32,370 --> 00:04:38,430
that allows you to pick your programs of

00:04:35,639 --> 00:04:42,419
different components the second thing is

00:04:38,430 --> 00:04:47,340
composed this is the subject of of today

00:04:42,419 --> 00:04:49,800
and the last thing is geo which stands

00:04:47,340 --> 00:04:52,440
for generator I oh and that's basically

00:04:49,800 --> 00:04:54,780
ties together a soccer to generator I

00:04:52,440 --> 00:04:59,720
will explain that a little bit but most

00:04:54,780 --> 00:04:59,720
of the talk today will be about post I

00:05:03,139 --> 00:05:08,220
already spoke about the differences

00:05:05,490 --> 00:05:10,100
between different frameworks and to

00:05:08,220 --> 00:05:15,539
illustrate that a little bit more I

00:05:10,100 --> 00:05:17,880
think this is what most most frameworks

00:05:15,539 --> 00:05:20,760
more or less do there is this this

00:05:17,880 --> 00:05:23,310
notion of different coatings and these

00:05:20,760 --> 00:05:25,500
co routines the are basically sending

00:05:23,310 --> 00:05:28,370
each other messages or invoking each

00:05:25,500 --> 00:05:31,860
other or whatever you call it and I'm

00:05:28,370 --> 00:05:34,080
because that doesn't work because we for

00:05:31,860 --> 00:05:36,449
example the C Python doesn't stack based

00:05:34,080 --> 00:05:38,190
it doesn't have a continuation or

00:05:36,449 --> 00:05:41,760
something like that you need something

00:05:38,190 --> 00:05:44,849
like a trampoline and every generated

00:05:41,760 --> 00:05:48,090
and returns to the trampoline by

00:05:44,849 --> 00:05:50,039
returning next generator to be involved

00:05:48,090 --> 00:05:51,780
and then the trampoline invoke that

00:05:50,039 --> 00:05:55,500
generator and that generator again

00:05:51,780 --> 00:05:57,449
returns next generator to be invoked and

00:05:55,500 --> 00:06:02,370
that's that's the way you can do co

00:05:57,449 --> 00:06:04,680
routines in in Python I also added here

00:06:02,370 --> 00:06:07,440
a little round thing that's called a

00:06:04,680 --> 00:06:12,000
socket that this is round Google over

00:06:07,440 --> 00:06:15,900
there and this is actually to to make

00:06:12,000 --> 00:06:18,300
clear that there is no io being done by

00:06:15,900 --> 00:06:21,030
the trampoline itself I always basically

00:06:18,300 --> 00:06:22,830
done at the co routine level there are

00:06:21,030 --> 00:06:25,650
girl routines you can call functions

00:06:22,830 --> 00:06:28,550
like read and write and then these

00:06:25,650 --> 00:06:33,930
functions are usually then yielded or

00:06:28,550 --> 00:06:35,460
some other way made a synchronous this

00:06:33,930 --> 00:06:38,070
is quite different I think from the

00:06:35,460 --> 00:06:39,090
model that i was looking at last five

00:06:38,070 --> 00:06:40,860
years or so

00:06:39,090 --> 00:06:42,900
and this is basically how that mobile

00:06:40,860 --> 00:06:47,580
works it's tightly integrated at doing I

00:06:42,900 --> 00:06:51,000
oh if this this socket here at the at

00:06:47,580 --> 00:06:55,050
one end and they said the socket is

00:06:51,000 --> 00:06:59,550
connected by a driver to a bunch of

00:06:55,050 --> 00:07:03,840
generators over there and this driver is

00:06:59,550 --> 00:07:08,880
is actually what is geo in the in one of

00:07:03,840 --> 00:07:11,580
the previous slide although this is

00:07:08,880 --> 00:07:14,070
tightly integrated the interesting thing

00:07:11,580 --> 00:07:16,979
is that at this point here it's not

00:07:14,070 --> 00:07:18,600
integrated at all because the vision I

00:07:16,979 --> 00:07:23,510
had was that you could write these

00:07:18,600 --> 00:07:26,280
generators without regard to doing I oh

00:07:23,510 --> 00:07:30,360
so basically you could be able to write

00:07:26,280 --> 00:07:33,120
an HTTP protocol with a generator

00:07:30,360 --> 00:07:37,169
without bothering where the data comes

00:07:33,120 --> 00:07:39,900
from HTTP that's may usually not such a

00:07:37,169 --> 00:07:43,770
big point because HTTP runs over tcp/ip

00:07:39,900 --> 00:07:47,039
and if not you have not much charged

00:07:43,770 --> 00:07:48,720
there but if you think about soap soap

00:07:47,039 --> 00:07:50,550
is a protocol specification is

00:07:48,720 --> 00:07:55,110
completely detached of any transport

00:07:50,550 --> 00:07:57,419
layer so you can do soap over HTTP you

00:07:55,110 --> 00:08:00,419
can also do it using s the Simple Mail

00:07:57,419 --> 00:08:04,289
Transfer Protocol you can do it by using

00:08:00,419 --> 00:08:06,030
files you can do it any way you like so

00:08:04,289 --> 00:08:07,710
it's very interesting to have an

00:08:06,030 --> 00:08:09,630
implementation of the show protocol

00:08:07,710 --> 00:08:12,180
completely detached from how it's doing

00:08:09,630 --> 00:08:14,580
I oh and I thought well generators might

00:08:12,180 --> 00:08:19,229
give you a very interesting way of doing

00:08:14,580 --> 00:08:23,130
that the the most important thing here

00:08:19,229 --> 00:08:26,520
is we will focus on these on these three

00:08:23,130 --> 00:08:28,830
things how do you how do you create

00:08:26,520 --> 00:08:31,020
these how do you support creating them

00:08:28,830 --> 00:08:35,669
that's basically the most important

00:08:31,020 --> 00:08:37,409
question and I have to tell a little bit

00:08:35,669 --> 00:08:41,339
about one of these other three topics

00:08:37,409 --> 00:08:43,800
that was the topic of lost here it dealt

00:08:41,339 --> 00:08:45,839
with how you configure all those

00:08:43,800 --> 00:08:47,790
generators there are three generators

00:08:45,839 --> 00:08:50,459
here on the screen and they somehow

00:08:47,790 --> 00:08:51,840
delegate to each other and you have to

00:08:50,459 --> 00:08:53,220
configure that

00:08:51,840 --> 00:08:55,320
you can not hard code all those

00:08:53,220 --> 00:08:57,630
relations you don't want that in

00:08:55,320 --> 00:09:01,260
waitlist it is done by using the

00:08:57,630 --> 00:09:04,560
observable pattern you can see it on the

00:09:01,260 --> 00:09:11,250
screen there is in the text it says self

00:09:04,560 --> 00:09:13,770
dot any a loop all and self do this

00:09:11,250 --> 00:09:16,710
actually is a generator call self-taught

00:09:13,770 --> 00:09:18,560
any handle and then say you request then

00:09:16,710 --> 00:09:24,140
basically it delegates to one of his

00:09:18,560 --> 00:09:28,380
observers by doing so you detach

00:09:24,140 --> 00:09:31,500
different components from each other if

00:09:28,380 --> 00:09:32,910
you like that if you like that topic and

00:09:31,500 --> 00:09:35,130
you want to know more about it and just

00:09:32,910 --> 00:09:37,400
look at the website or talk to me later

00:09:35,130 --> 00:09:40,410
I'm going to skip it now because it's

00:09:37,400 --> 00:09:42,510
it's not really essential you can if you

00:09:40,410 --> 00:09:46,410
use compose you can explain compose

00:09:42,510 --> 00:09:50,900
about this and you can use about this by

00:09:46,410 --> 00:09:50,900
just hard coding or doing something else

00:09:51,770 --> 00:10:00,060
now if you start working with generators

00:09:55,500 --> 00:10:04,650
the way we did then you you learn of all

00:10:00,060 --> 00:10:06,990
sorts of difficult things that are are

00:10:04,650 --> 00:10:08,700
in the way and are basically four topics

00:10:06,990 --> 00:10:10,800
that I want to cover today those four

00:10:08,700 --> 00:10:13,830
topics are things that I found when

00:10:10,800 --> 00:10:16,200
working with these generators and not

00:10:13,830 --> 00:10:20,450
only working with generators but writing

00:10:16,200 --> 00:10:23,340
complete programs with only generators

00:10:20,450 --> 00:10:25,710
but what we actually did is we are

00:10:23,340 --> 00:10:29,250
writing very large programs for our

00:10:25,710 --> 00:10:35,690
company is doing search engines we are

00:10:29,250 --> 00:10:38,490
writing big applications with only these

00:10:35,690 --> 00:10:41,370
coatings only these generators our

00:10:38,490 --> 00:10:44,820
complete application is structured as co

00:10:41,370 --> 00:10:46,980
routines that call each other and if you

00:10:44,820 --> 00:10:48,690
do that there are some points that there

00:10:46,980 --> 00:10:50,970
are you crazy and you really have to so

00:10:48,690 --> 00:10:54,180
often as those few poor those four

00:10:50,970 --> 00:10:57,390
points first of all is you need

00:10:54,180 --> 00:11:00,030
something like back traces um you need

00:10:57,390 --> 00:11:03,279
something like flow control you need

00:11:00,030 --> 00:11:04,959
something like to push back data and

00:11:03,279 --> 00:11:08,800
in the end you need something called

00:11:04,959 --> 00:11:13,089
local which is something like that logo

00:11:08,800 --> 00:11:14,680
learn more things like that but this

00:11:13,089 --> 00:11:18,879
these are the four topics I want to

00:11:14,680 --> 00:11:19,870
cover today and this is the agenda I'll

00:11:18,879 --> 00:11:24,579
give you some more background

00:11:19,870 --> 00:11:26,970
information out about GSP but this time

00:11:24,579 --> 00:11:31,269
it means Jackson structured programming

00:11:26,970 --> 00:11:35,819
I wonder how many of you have ever heard

00:11:31,269 --> 00:11:38,980
of GSP in this in this sense you have

00:11:35,819 --> 00:11:45,639
very interesting I see a couple of

00:11:38,980 --> 00:11:47,529
people with gray hairs not not so not so

00:11:45,639 --> 00:11:48,999
strange because it's I think his work

00:11:47,529 --> 00:11:51,519
has been done in the 60s or something

00:11:48,999 --> 00:11:54,959
like that and I also see a younger guy

00:11:51,519 --> 00:11:59,199
raising his hand and I admit the only

00:11:54,959 --> 00:12:02,199
thing I knew GSP from Rush was from the

00:11:59,199 --> 00:12:04,149
chapter of the the title of the chapter

00:12:02,199 --> 00:12:09,819
of the book we were allowed to skip for

00:12:04,149 --> 00:12:13,809
exams but it's very very fundamental if

00:12:09,819 --> 00:12:16,300
you look at what he did it's it to my

00:12:13,809 --> 00:12:19,839
knowledge it's the only some sort of

00:12:16,300 --> 00:12:22,990
methodology that tells you where to put

00:12:19,839 --> 00:12:25,360
if and else and wireless loops etc I

00:12:22,990 --> 00:12:27,639
mean there is 0 0 but 00 doesn't say

00:12:25,360 --> 00:12:30,430
tell you anything about how to actually

00:12:27,639 --> 00:12:32,500
structure your program where to make

00:12:30,430 --> 00:12:35,740
objects were to make decisions etc etc

00:12:32,500 --> 00:12:38,680
and this this method does and it makes

00:12:35,740 --> 00:12:41,290
it very cool i'll give you some more

00:12:38,680 --> 00:12:44,709
background about that because when i was

00:12:41,290 --> 00:12:47,889
looking at when I found Python to dal 5

00:12:44,709 --> 00:12:50,379
does this generalized generators a disk

00:12:47,889 --> 00:12:54,600
lost my mind and I thought wow maybe

00:12:50,379 --> 00:12:57,579
this will be possible in Python this

00:12:54,600 --> 00:13:01,240
I'll give you a short recap of the of

00:12:57,579 --> 00:13:06,490
the the peps that are related to this

00:13:01,240 --> 00:13:09,429
topic the 342 very very shortly because

00:13:06,490 --> 00:13:13,509
I assume most of you know that and 380 a

00:13:09,429 --> 00:13:16,080
little bit more in detail and then I'll

00:13:13,509 --> 00:13:18,990
switch to a lots of code to

00:13:16,080 --> 00:13:20,640
to get you through the main topics and

00:13:18,990 --> 00:13:26,220
then I hope there's some time left for

00:13:20,640 --> 00:13:28,860
discussion what is Jackson Jackson

00:13:26,220 --> 00:13:31,700
structured programming well it is made

00:13:28,860 --> 00:13:34,950
up in the 60s or something like that and

00:13:31,700 --> 00:13:37,380
the main problem was this this you had

00:13:34,950 --> 00:13:40,560
these mainframes with these big tapes

00:13:37,380 --> 00:13:42,180
and if you wanted to process that she

00:13:40,560 --> 00:13:43,710
taped and what you did you took the tape

00:13:42,180 --> 00:13:46,740
and you read it in and then you produce

00:13:43,710 --> 00:13:49,290
a new tape but that's very difficult to

00:13:46,740 --> 00:13:50,700
do because you have to boot to get older

00:13:49,290 --> 00:13:52,170
did this complete type you have to get

00:13:50,700 --> 00:13:54,560
it in memory the memory was very

00:13:52,170 --> 00:14:00,360
expensive and there was not much of it

00:13:54,560 --> 00:14:02,340
so how would you efficiently process

00:14:00,360 --> 00:14:07,800
this tape and turn it into another tape

00:14:02,340 --> 00:14:11,190
with result data Oh Dixon said we'll

00:14:07,800 --> 00:14:13,500
think of it as a data stream dreaming in

00:14:11,190 --> 00:14:17,550
and you try to stream out at the same

00:14:13,500 --> 00:14:19,560
time and then he explained what you had

00:14:17,550 --> 00:14:22,410
to do to make that work in your program

00:14:19,560 --> 00:14:25,050
and he actually says your your program

00:14:22,410 --> 00:14:27,810
structures who shoot more or less full

00:14:25,050 --> 00:14:30,960
out the structure of your data so what

00:14:27,810 --> 00:14:32,820
I've shown here is the resume for

00:14:30,960 --> 00:14:35,040
example an HTTP request coming in

00:14:32,820 --> 00:14:37,380
because i'm i'm now making a big big

00:14:35,040 --> 00:14:40,080
leap from mainframes back to web servers

00:14:37,380 --> 00:14:44,120
with it actually quite similar this is

00:14:40,080 --> 00:14:46,200
HTTP request it has a request line

00:14:44,120 --> 00:14:49,170
starts with request mind then follow

00:14:46,200 --> 00:14:53,930
some headers and after that there is the

00:14:49,170 --> 00:14:57,240
body and the body probably this in some

00:14:53,930 --> 00:15:01,680
it contains a form and a form might

00:14:57,240 --> 00:15:03,450
contain data xml data or whatever then

00:15:01,680 --> 00:15:07,410
you can go on like this forever of

00:15:03,450 --> 00:15:09,120
course so if you have this this this is

00:15:07,410 --> 00:15:11,250
the infant for the input data the

00:15:09,120 --> 00:15:12,630
structure of the input data or there

00:15:11,250 --> 00:15:16,250
might be a good idea to structure your

00:15:12,630 --> 00:15:16,250
program in exactly the same way

00:15:18,860 --> 00:15:27,200
interesting thing is that if you do so

00:15:22,040 --> 00:15:29,750
and solve for difficult problems

00:15:27,200 --> 00:15:33,020
and you do that actually with co

00:15:29,750 --> 00:15:35,480
routines and i'm now it's trying to

00:15:33,020 --> 00:15:36,650
explain these four problems and i think

00:15:35,480 --> 00:15:38,390
they're all quite familiar to you

00:15:36,650 --> 00:15:41,150
because if you have been programming and

00:15:38,390 --> 00:15:43,970
you have then you will you will have

00:15:41,150 --> 00:15:45,920
seen these problems before and the idea

00:15:43,970 --> 00:15:48,200
of objection was well if you use code

00:15:45,920 --> 00:15:55,390
routines you can very neatly solve these

00:15:48,200 --> 00:15:57,950
four problems first of all there is a

00:15:55,390 --> 00:16:01,750
boundary clashes in your in your data

00:15:57,950 --> 00:16:04,760
for example your input data consists of

00:16:01,750 --> 00:16:07,910
month and each month and each month have

00:16:04,760 --> 00:16:09,950
has a certain amount of days and what

00:16:07,910 --> 00:16:13,130
you actually want to produce is weekly

00:16:09,950 --> 00:16:17,540
report quite well known problem that

00:16:13,130 --> 00:16:19,820
month do not neatly collide with weeks

00:16:17,540 --> 00:16:23,030
because every month is different it's

00:16:19,820 --> 00:16:27,200
not for weeks but a little bit more but

00:16:23,030 --> 00:16:29,920
inside is still days so you can match

00:16:27,200 --> 00:16:32,660
these days which you cannot match these

00:16:29,920 --> 00:16:35,270
you can not match the concepts on a

00:16:32,660 --> 00:16:37,400
higher level a week is not a month this

00:16:35,270 --> 00:16:40,400
is called a boundary clash and it

00:16:37,400 --> 00:16:42,950
happens a lot happens a lot later I will

00:16:40,400 --> 00:16:44,750
explain about boundary clashes that you

00:16:42,950 --> 00:16:49,160
hit when you are implementing web

00:16:44,750 --> 00:16:52,760
servers I think you can think of some of

00:16:49,160 --> 00:16:57,050
the boundary clashes there can also be

00:16:52,760 --> 00:16:59,180
interleaving klassische there's actually

00:16:57,050 --> 00:17:01,120
red yellow and green boxes here but i

00:16:59,180 --> 00:17:03,470
think the yellow and green are not so

00:17:01,120 --> 00:17:05,690
well distinguishable it's better

00:17:03,470 --> 00:17:08,030
distinguishable over there if you look

00:17:05,690 --> 00:17:11,180
to your right then you can see there are

00:17:08,030 --> 00:17:13,160
actually three colors interleaving

00:17:11,180 --> 00:17:17,060
clashes basically means that the data is

00:17:13,160 --> 00:17:20,530
coming in in a some sort of maybe random

00:17:17,060 --> 00:17:23,209
order and you have like the upper line

00:17:20,530 --> 00:17:24,829
it's just a stream of records for

00:17:23,209 --> 00:17:28,010
example there's a if you have a telecom

00:17:24,829 --> 00:17:30,620
operator is collecting records that

00:17:28,010 --> 00:17:32,480
represent phone calls and what Union

00:17:30,620 --> 00:17:36,260
want to do you want to have a billing

00:17:32,480 --> 00:17:38,540
and you have to to process the stream

00:17:36,260 --> 00:17:42,320
and produce bills for the

00:17:38,540 --> 00:17:44,030
red yellow and green customers this is

00:17:42,320 --> 00:17:46,460
typically an interleaving class show you

00:17:44,030 --> 00:17:51,160
want to process this 3 Madhu that the

00:17:46,460 --> 00:17:51,160
end result has a different ordering

00:17:53,050 --> 00:17:59,660
there can also be there was a bit weird

00:17:55,580 --> 00:18:03,590
this is an ordering clash for example

00:17:59,660 --> 00:18:05,720
this if you have a data coming in that

00:18:03,590 --> 00:18:07,190
is for example a table which is Rho

00:18:05,720 --> 00:18:10,130
oriented and you want to have it

00:18:07,190 --> 00:18:14,420
column-oriented this basically what this

00:18:10,130 --> 00:18:16,850
image tries to to depict this dream is

00:18:14,420 --> 00:18:21,770
coming in the stream is is formatted

00:18:16,850 --> 00:18:23,420
like the upper upper bar and what you

00:18:21,770 --> 00:18:27,250
want actually is the lower bar so you

00:18:23,420 --> 00:18:27,250
want to have it diff order differently

00:18:27,880 --> 00:18:34,430
then there is recognition difficulties

00:18:31,570 --> 00:18:35,810
the data that's coming in in in a data

00:18:34,430 --> 00:18:39,980
stream often these structures in

00:18:35,810 --> 00:18:42,260
structured in a certain way and it might

00:18:39,980 --> 00:18:45,320
be very difficult to tell one structure

00:18:42,260 --> 00:18:49,160
from another so for example you have

00:18:45,320 --> 00:18:50,930
this structure here yes a and the

00:18:49,160 --> 00:18:54,230
structure for be here is almost exactly

00:18:50,930 --> 00:18:57,670
the same if you look at this a distorted

00:18:54,230 --> 00:19:02,480
and you can only tell from F here at the

00:18:57,670 --> 00:19:05,660
rightmost lower part that it's well that

00:19:02,480 --> 00:19:09,380
is actually be for all elves it's it's

00:19:05,660 --> 00:19:12,620
completely equivalent to a so if you if

00:19:09,380 --> 00:19:15,440
you imagine you would have a recursive

00:19:12,620 --> 00:19:18,590
descent parser and you would send into

00:19:15,440 --> 00:19:20,450
this this tree and you would do say a

00:19:18,590 --> 00:19:24,260
left hand search or something like that

00:19:20,450 --> 00:19:27,680
left recursive descent then you would

00:19:24,260 --> 00:19:29,750
recursion to see and then into E and

00:19:27,680 --> 00:19:32,450
then in 2d and then oh man you're almost

00:19:29,750 --> 00:19:34,760
done you recursion to F and then you see

00:19:32,450 --> 00:19:38,920
how well this is actually is actually be

00:19:34,760 --> 00:19:41,450
a structure of try bein out of type a

00:19:38,920 --> 00:19:43,310
what you have to do if that is what you

00:19:41,450 --> 00:19:48,040
need to solve that is some sort of look

00:19:43,310 --> 00:19:48,040
ahead or back tracking or maybe both

00:19:48,970 --> 00:19:54,930
this is this is the solution that

00:19:52,050 --> 00:19:58,580
action Jackson came up with he actually

00:19:54,930 --> 00:20:01,860
says well think of your programs p and q

00:19:58,580 --> 00:20:05,400
or two programs and they are somehow

00:20:01,860 --> 00:20:07,950
processing data and one is feeding data

00:20:05,400 --> 00:20:10,860
into the other and this feat is

00:20:07,950 --> 00:20:13,950
represented by the blue the blue blue

00:20:10,860 --> 00:20:17,100
square I I put their the word buffer

00:20:13,950 --> 00:20:18,900
because that's how it unusually works it

00:20:17,100 --> 00:20:21,600
did work so with these tapes you would

00:20:18,900 --> 00:20:23,010
run one program it would read one type

00:20:21,600 --> 00:20:24,360
and would write another type now you

00:20:23,010 --> 00:20:26,940
read the next program reach the whole

00:20:24,360 --> 00:20:29,520
type and write the next type you need

00:20:26,940 --> 00:20:31,320
this buffer now this is a problem

00:20:29,520 --> 00:20:35,100
because this buffering is expensive it

00:20:31,320 --> 00:20:37,140
adds lots to your completely to complete

00:20:35,100 --> 00:20:42,210
the runtime of your of your application

00:20:37,140 --> 00:20:44,790
and by the way it's still today very

00:20:42,210 --> 00:20:47,400
very actual it's very very realistic

00:20:44,790 --> 00:20:50,430
this buffering because web servers if

00:20:47,400 --> 00:20:52,230
you have a web server and I don't know

00:20:50,430 --> 00:20:54,710
how many of you do performance analysis

00:20:52,230 --> 00:20:57,740
of difficult systems but if you ever did

00:20:54,710 --> 00:21:01,410
then you probably already know that

00:20:57,740 --> 00:21:03,450
buffering or copying data into one from

00:21:01,410 --> 00:21:06,570
one boyfriend to another it's usually

00:21:03,450 --> 00:21:08,130
one of the big bottlenecks in a

00:21:06,570 --> 00:21:12,300
high-performance system so you don't

00:21:08,130 --> 00:21:15,330
want this buffering so here again it's

00:21:12,300 --> 00:21:16,860
from 40 years ago it's still relevant

00:21:15,330 --> 00:21:20,670
today but in a completely different

00:21:16,860 --> 00:21:22,860
context now what Jackson suggested was

00:21:20,670 --> 00:21:25,620
well why don't you create an inverse

00:21:22,860 --> 00:21:28,680
program so we are still have P but from

00:21:25,620 --> 00:21:31,470
the program Q we create the inverse so

00:21:28,680 --> 00:21:34,350
we have this Q Prime and this cube prime

00:21:31,470 --> 00:21:36,480
is really absurd down it doesn't contain

00:21:34,350 --> 00:21:38,430
an event loop anymore so you don't say

00:21:36,480 --> 00:21:39,840
well here you go and process these

00:21:38,430 --> 00:21:43,550
records no you just say here's one

00:21:39,840 --> 00:21:46,560
record process it and that's exactly

00:21:43,550 --> 00:21:53,390
what coatings are about so it's a really

00:21:46,560 --> 00:21:55,890
really neat match there are some

00:21:53,390 --> 00:21:58,140
examples are generators work this way

00:21:55,890 --> 00:22:01,320
but there is a very other very important

00:21:58,140 --> 00:22:03,720
or important very pleasant surprise to

00:22:01,320 --> 00:22:05,600
me was another example of this

00:22:03,720 --> 00:22:10,940
programming version

00:22:05,600 --> 00:22:13,080
i'm using i'm a really a fan of alex ml

00:22:10,940 --> 00:22:15,240
doctor is not here is usually at

00:22:13,080 --> 00:22:20,040
conferences like europe item but he's

00:22:15,240 --> 00:22:23,870
not this year but Alex ml got this this

00:22:20,040 --> 00:22:26,370
needs the method called alex ml feet

00:22:23,870 --> 00:22:28,890
this is really programming version and

00:22:26,370 --> 00:22:30,900
it comes in very very handy if you are

00:22:28,890 --> 00:22:34,380
structuring your programs as skull teams

00:22:30,900 --> 00:22:37,260
and you want to have an inverse xml

00:22:34,380 --> 00:22:39,330
portion the big thing here is that this

00:22:37,260 --> 00:22:41,220
parched normally you give parses you

00:22:39,330 --> 00:22:43,440
gave a very control to porsche and then

00:22:41,220 --> 00:22:45,300
the parser is executing a loop and you

00:22:43,440 --> 00:22:47,610
cannot get Duke and you cannot do

00:22:45,300 --> 00:22:49,800
anything at all until that this loop

00:22:47,610 --> 00:22:51,120
terminates so you say parson and it

00:22:49,800 --> 00:22:54,660
starts parsing but it needs the whole

00:22:51,120 --> 00:22:57,540
message this feed method basically says

00:22:54,660 --> 00:22:59,190
well you are the caller you're in

00:22:57,540 --> 00:23:02,100
control whenever you have some data feed

00:22:59,190 --> 00:23:04,260
it into me and I'll do a little bit of

00:23:02,100 --> 00:23:06,360
work and then I'll return immediately so

00:23:04,260 --> 00:23:09,660
you can you can come with more data and

00:23:06,360 --> 00:23:12,060
this is exactly the type of inversed

00:23:09,660 --> 00:23:14,130
programs you need like this whole

00:23:12,060 --> 00:23:16,580
objection searcher injection structured

00:23:14,130 --> 00:23:22,370
programming work so it was very glad

00:23:16,580 --> 00:23:22,370
that they introduced it this method I

00:23:22,940 --> 00:23:28,500
think already sell lots about this slide

00:23:25,830 --> 00:23:31,770
it's about the applicability the

00:23:28,500 --> 00:23:34,890
objection is stems from the 1960s I

00:23:31,770 --> 00:23:37,800
think in the seventies probably applied

00:23:34,890 --> 00:23:41,090
to mainframes and tapes today it really

00:23:37,800 --> 00:23:45,540
is really applies well to web servers

00:23:41,090 --> 00:23:48,060
don't know if you happens happens quite

00:23:45,540 --> 00:23:49,650
a lot for example your web server this

00:23:48,060 --> 00:23:51,750
web server is never alone this web

00:23:49,650 --> 00:23:54,150
server is actually communicating with a

00:23:51,750 --> 00:23:57,300
web browser and you'll probably notice

00:23:54,150 --> 00:23:59,220
that every browser is works already very

00:23:57,300 --> 00:24:03,690
incremental so it builds up the screen

00:23:59,220 --> 00:24:05,880
while the data is coming in and this web

00:24:03,690 --> 00:24:08,490
server also if you implement that as

00:24:05,880 --> 00:24:14,280
much as streaming as possible it has a

00:24:08,490 --> 00:24:16,080
very very quick response makes things

00:24:14,280 --> 00:24:17,500
even worse if you are going to talk

00:24:16,080 --> 00:24:19,750
about web services

00:24:17,500 --> 00:24:22,780
because then you have a web service and

00:24:19,750 --> 00:24:25,300
these web service is actually serving

00:24:22,780 --> 00:24:28,230
requests to some other program and that

00:24:25,300 --> 00:24:30,940
program is then producing HTML to view

00:24:28,230 --> 00:24:33,400
now what happens a lot is how i create

00:24:30,940 --> 00:24:36,370
the search engines the search engines

00:24:33,400 --> 00:24:38,410
oft often communicate by I standard

00:24:36,370 --> 00:24:40,840
search protocol with another another

00:24:38,410 --> 00:24:43,090
machine and that machine uses HTML for a

00:24:40,840 --> 00:24:46,000
search portal now what happens is this

00:24:43,090 --> 00:24:48,280
search engine creates your response this

00:24:46,000 --> 00:24:50,620
response is an XML of course I would you

00:24:48,280 --> 00:24:52,600
do it otherwise today and it sends it to

00:24:50,620 --> 00:24:55,090
the client and then this client is first

00:24:52,600 --> 00:24:57,570
buffering the complete response and then

00:24:55,090 --> 00:25:01,360
he folks the XML parser and then

00:24:57,570 --> 00:25:03,970
produces the HTML now by only changing

00:25:01,360 --> 00:25:06,370
this client in not buffering the

00:25:03,970 --> 00:25:09,630
complete message but making it streaming

00:25:06,370 --> 00:25:12,070
so when the first record comes in guilty

00:25:09,630 --> 00:25:13,720
generate a little piece of HTML that

00:25:12,070 --> 00:25:17,580
shows you the first table or the first

00:25:13,720 --> 00:25:17,580
line of a record or something like that

00:25:18,330 --> 00:25:25,210
response times improve enormously and

00:25:21,880 --> 00:25:27,460
especially how people experience these

00:25:25,210 --> 00:25:28,990
response times because it isn't there is

00:25:27,460 --> 00:25:30,610
no blank screen and you wait a couple of

00:25:28,990 --> 00:25:31,960
seconds now there is something coming in

00:25:30,610 --> 00:25:36,570
and maybe it also takes a couple of

00:25:31,960 --> 00:25:36,570
seconds but it's a different experience

00:25:39,180 --> 00:25:45,040
though I had this idea for there is a

00:25:42,250 --> 00:25:48,210
great idea to apply section structured

00:25:45,040 --> 00:25:51,760
programming to my programs using Python

00:25:48,210 --> 00:25:53,860
generators generalized generators but

00:25:51,760 --> 00:25:57,760
was a bit of a hard time and actually

00:25:53,860 --> 00:26:01,240
switched these two modes quite often for

00:25:57,760 --> 00:26:03,250
for more than a year at the one end I

00:26:01,240 --> 00:26:06,010
was the happy programmer to see what I

00:26:03,250 --> 00:26:07,450
can build my programs using this jackson

00:26:06,010 --> 00:26:09,370
structured programming that's very cool

00:26:07,450 --> 00:26:13,150
and i can solve problems easier that

00:26:09,370 --> 00:26:15,670
they couldn't solve before but then it

00:26:13,150 --> 00:26:18,430
this program I got frustrated frustrated

00:26:15,670 --> 00:26:20,950
because things didn't work as expected

00:26:18,430 --> 00:26:23,440
nor as the data was losing and

00:26:20,950 --> 00:26:25,420
unexpected things were happening and

00:26:23,440 --> 00:26:26,890
then the same program are jumped into

00:26:25,420 --> 00:26:29,380
the box into the virtual machine i

00:26:26,890 --> 00:26:30,119
started working from the inside to fix

00:26:29,380 --> 00:26:32,519
things and then

00:26:30,119 --> 00:26:34,229
then he folded well might work now and

00:26:32,519 --> 00:26:35,759
Annie jump back out of it and was the

00:26:34,229 --> 00:26:37,919
happy programming again and it tried it

00:26:35,759 --> 00:26:40,379
and then it didn't work again there was

00:26:37,919 --> 00:26:43,079
some new problem and actually this this

00:26:40,379 --> 00:26:46,139
happened for over a year until I finally

00:26:43,079 --> 00:26:47,999
found what was the problem and I made

00:26:46,139 --> 00:26:51,539
some design choices and that's what I

00:26:47,999 --> 00:26:53,689
want to present today and actually this

00:26:51,539 --> 00:26:56,639
this was happened a couple of years ago

00:26:53,689 --> 00:26:58,259
but it still happened at it's still

00:26:56,639 --> 00:27:00,629
happening it happened last week when I

00:26:58,259 --> 00:27:04,079
was preparing this presentation I was

00:27:00,629 --> 00:27:06,029
preparing the code and then I took very

00:27:04,079 --> 00:27:08,519
very little little steps to explain

00:27:06,029 --> 00:27:10,049
what's actually happening and then I run

00:27:08,519 --> 00:27:11,819
into a situation that I was the

00:27:10,049 --> 00:27:15,539
frustrated programmer again because

00:27:11,819 --> 00:27:17,909
things didn't work as expected I had to

00:27:15,539 --> 00:27:20,069
go down into into this VM and have to

00:27:17,909 --> 00:27:21,869
fix something so that and the great

00:27:20,069 --> 00:27:24,179
thing was that there I only had to

00:27:21,869 --> 00:27:26,459
remove three lines of code and replaced

00:27:24,179 --> 00:27:29,039
by one simple instruction and then it

00:27:26,459 --> 00:27:32,489
worked but this is this is really what

00:27:29,039 --> 00:27:35,909
it's all about it's inside the vm your

00:27:32,489 --> 00:27:38,969
work is a thing to make to make for a

00:27:35,909 --> 00:27:41,129
very neat experience for the other

00:27:38,969 --> 00:27:43,049
programmer that you also are and you

00:27:41,129 --> 00:27:46,019
want don't want if you are to the right

00:27:43,049 --> 00:27:48,329
or to the left has to say yeah you don't

00:27:46,019 --> 00:27:49,859
want to care about how things work you

00:27:48,329 --> 00:27:52,049
don't want to care about the Civil tease

00:27:49,859 --> 00:27:53,609
of different the difficult API is you

00:27:52,049 --> 00:27:56,129
just want to care about the problem

00:27:53,609 --> 00:27:58,589
you're working on I mean there's just so

00:27:56,129 --> 00:28:00,059
many things that fit in one's head so

00:27:58,589 --> 00:28:01,859
while you're a programming you just want

00:28:00,059 --> 00:28:04,199
to solve the problem and not think about

00:28:01,859 --> 00:28:07,789
very difficult api's that's that's the

00:28:04,199 --> 00:28:10,679
real problem with with difficult api's

00:28:07,789 --> 00:28:12,989
make mistakes using difficult api's and

00:28:10,679 --> 00:28:17,579
this is the reason something else to

00:28:12,989 --> 00:28:22,709
care about but basically this is this is

00:28:17,579 --> 00:28:25,979
how I've been event back and forth I now

00:28:22,709 --> 00:28:29,759
will show you some some Python code

00:28:25,979 --> 00:28:32,369
because I was just here in this showing

00:28:29,759 --> 00:28:34,919
code on the screen on the page makes you

00:28:32,369 --> 00:28:37,739
very happy that's one of the most

00:28:34,919 --> 00:28:41,849
awesome things that Raymond Ithaca I

00:28:37,739 --> 00:28:44,389
shoulders so oh I hope I'm going to make

00:28:41,849 --> 00:28:44,389
you happy now

00:28:57,380 --> 00:29:05,480
I check this it should be readable by

00:28:59,870 --> 00:29:07,970
all of you as I said I expected a small

00:29:05,480 --> 00:29:10,490
crowd not such a big crowd and I

00:29:07,970 --> 00:29:11,630
expected lots of interactions I'm still

00:29:10,490 --> 00:29:13,520
open to that so if you have any

00:29:11,630 --> 00:29:16,310
questions or any remarks and please let

00:29:13,520 --> 00:29:22,850
me know I'm happy to interrupt and give

00:29:16,310 --> 00:29:26,120
answers this presentation is structured

00:29:22,850 --> 00:29:27,560
like a piece of parting code I can just

00:29:26,120 --> 00:29:29,980
page up and page down through it and

00:29:27,560 --> 00:29:33,050
it's all runnable code so i have this

00:29:29,980 --> 00:29:34,760
window to the right where i can actually

00:29:33,050 --> 00:29:36,890
actually killed all the examples and i

00:29:34,760 --> 00:29:39,740
can if you want to I can also adjust

00:29:36,890 --> 00:29:46,490
them let's see and then see what

00:29:39,740 --> 00:29:51,230
happened what's happening so first is

00:29:46,490 --> 00:29:54,740
this pep 342 which was the pep that all

00:29:51,230 --> 00:30:01,430
started it I think it's about announced

00:29:54,740 --> 00:30:02,900
generators we're all familiar with the

00:30:01,430 --> 00:30:06,260
yield statement I think there's a yield

00:30:02,900 --> 00:30:08,660
statement you can yield messages cumple

00:30:06,260 --> 00:30:13,070
here there is there's yield yield

00:30:08,660 --> 00:30:16,750
response and this response is done

00:30:13,070 --> 00:30:16,750
actually sorry you have a question

00:30:21,990 --> 00:30:26,720
yes I tried this morning I did yesterday

00:30:24,929 --> 00:30:29,070
and this is this is the best I could get

00:30:26,720 --> 00:30:42,630
so all these color schemes have their

00:30:29,070 --> 00:30:45,630
own problems helps a bit yeah I will try

00:30:42,630 --> 00:30:47,750
to do in to clearly indicate where I'm

00:30:45,630 --> 00:30:49,770
looking at and where I'm talking about

00:30:47,750 --> 00:30:57,090
but still if you have trouble then

00:30:49,770 --> 00:30:58,770
interrupt me again thank you yeah but

00:30:57,090 --> 00:31:00,920
I've really no clue how to how to do

00:30:58,770 --> 00:31:00,920
that

00:31:08,509 --> 00:31:16,119
I'll give it a try let it again polar

00:31:13,789 --> 00:31:16,119
scheme

00:31:26,790 --> 00:31:29,300
dilek

00:31:32,520 --> 00:31:42,730
and it's actually better yeah okay great

00:31:39,730 --> 00:31:45,970
I was I was trying to do I put all kinds

00:31:42,730 --> 00:31:47,650
of schemes in my dog thames RC directory

00:31:45,970 --> 00:31:51,370
or things like that but I couldn't find

00:31:47,650 --> 00:31:59,049
a good one but this is very easy thank

00:31:51,370 --> 00:32:01,510
you no thanks a lot but this is this is

00:31:59,049 --> 00:32:05,260
how generators work until this pepper

00:32:01,510 --> 00:32:07,570
came out you can just yield some data

00:32:05,260 --> 00:32:10,750
which will be picked up by a for loop

00:32:07,570 --> 00:32:15,280
usually because that was the only way

00:32:10,750 --> 00:32:17,290
you would iterators probably and i refer

00:32:15,280 --> 00:32:19,750
to these things that are communicated i

00:32:17,290 --> 00:32:24,130
refer to them as a responses and that's

00:32:19,750 --> 00:32:26,080
throughout the whole session but this

00:32:24,130 --> 00:32:28,419
pep made it possible that you could also

00:32:26,080 --> 00:32:30,880
send data into a generator shall be

00:32:28,419 --> 00:32:34,390
completely the other way around and i

00:32:30,880 --> 00:32:36,730
refer to those as messages now the idea

00:32:34,390 --> 00:32:38,620
is you have a generator you send the

00:32:36,730 --> 00:32:45,850
message and then I generate a response

00:32:38,620 --> 00:32:47,440
with a response what I did here is I

00:32:45,850 --> 00:32:50,020
created the simplest generator that

00:32:47,440 --> 00:32:52,330
could possibly work I'll just bring this

00:32:50,020 --> 00:32:55,240
message and this is how you do it in

00:32:52,330 --> 00:32:58,090
this demo driver you create this

00:32:55,240 --> 00:33:02,890
generator by calling this function and

00:32:58,090 --> 00:33:04,630
then you sent next to it this is this is

00:33:02,890 --> 00:33:06,520
important i would like to stress this a

00:33:04,630 --> 00:33:09,549
little bit and maybe artist i'm

00:33:06,520 --> 00:33:12,669
stressing it again later on i'm sending

00:33:09,549 --> 00:33:17,740
next here and what x actually does it'll

00:33:12,669 --> 00:33:21,429
run is this generator from here Oh from

00:33:17,740 --> 00:33:24,700
this parenthesis cell to say until here

00:33:21,429 --> 00:33:28,179
and this part is actually executed but

00:33:24,700 --> 00:33:30,669
not this part Oh deterrence it runs to

00:33:28,179 --> 00:33:33,460
half of this line but actually it runs

00:33:30,669 --> 00:33:35,860
to half of the right part of this line

00:33:33,460 --> 00:33:38,190
so you have to think of I cannot select

00:33:35,860 --> 00:33:42,450
that if my mouse cursor of this piece

00:33:38,190 --> 00:33:45,929
this piece together is being executed

00:33:42,450 --> 00:33:45,929
all next

00:33:46,950 --> 00:33:57,630
now what's happening here do that then

00:33:52,960 --> 00:34:01,150
this generator will yield response and

00:33:57,630 --> 00:34:04,240
then the next thing you can do is you

00:34:01,150 --> 00:34:05,950
send basically i'm sending it a message

00:34:04,240 --> 00:34:09,010
here and then when you send it the

00:34:05,950 --> 00:34:13,060
message generator resumes where it left

00:34:09,010 --> 00:34:18,129
off so do zooms here and it executed

00:34:13,060 --> 00:34:21,179
this part part here until the next yield

00:34:18,129 --> 00:34:24,760
so it ends here so actually execute this

00:34:21,179 --> 00:34:28,530
that's and at peace show this bit every

00:34:24,760 --> 00:34:36,000
execution is between yield statements

00:34:28,530 --> 00:34:36,000
that clear ok i can actually run it

00:34:41,659 --> 00:34:51,559
and it's Prince message because here's

00:34:47,379 --> 00:34:53,299
printed the message here oh that's all

00:34:51,559 --> 00:34:58,359
there is to it it's really it's really

00:34:53,299 --> 00:35:02,140
simple this dispatch was really simple

00:34:58,359 --> 00:35:05,200
but what was not simple is calling sent

00:35:02,140 --> 00:35:08,059
bowling sent is horribly complicated

00:35:05,200 --> 00:35:10,819
because there are many many difficulties

00:35:08,059 --> 00:35:13,940
you there are many so things you have to

00:35:10,819 --> 00:35:17,119
take care of when you call sent and stop

00:35:13,940 --> 00:35:19,460
iterations can happen exceptions can

00:35:17,119 --> 00:35:22,010
tell players it's quite civil to see

00:35:19,460 --> 00:35:24,910
what you have to do and it became even

00:35:22,010 --> 00:35:30,410
more shuttle when this the next pep-pep

00:35:24,910 --> 00:35:33,920
380 came out this is this is Pat 380

00:35:30,410 --> 00:35:36,020
it's still not implemented as far as I

00:35:33,920 --> 00:35:38,359
know there are some Python

00:35:36,020 --> 00:35:41,180
implementations of it and there is I

00:35:38,359 --> 00:35:43,640
think there is somewhere C Python code

00:35:41,180 --> 00:35:47,000
branch that implements it but it hasn't

00:35:43,640 --> 00:35:48,559
has not been released yet it is really a

00:35:47,000 --> 00:35:52,940
pity because I'm really waiting for this

00:35:48,559 --> 00:35:58,520
this is this is boo what does this pep

00:35:52,940 --> 00:36:05,510
380 actually say it says that if you

00:35:58,520 --> 00:36:08,599
have a generator and you want to gets

00:36:05,510 --> 00:36:10,760
bigger it gets longer it gets a real

00:36:08,599 --> 00:36:13,400
program so to say then what you want

00:36:10,760 --> 00:36:16,369
want to do is you want to refactor this

00:36:13,400 --> 00:36:17,990
generator into little components little

00:36:16,369 --> 00:36:20,839
functions that do little bit of the work

00:36:17,990 --> 00:36:22,490
and then call them and that's what you

00:36:20,839 --> 00:36:25,339
normally do in any program rights it's

00:36:22,490 --> 00:36:27,109
about program decomposition you want to

00:36:25,339 --> 00:36:29,089
decompose your program until different

00:36:27,109 --> 00:36:30,559
functions and then also in different

00:36:29,089 --> 00:36:32,750
objects but that's less important here

00:36:30,559 --> 00:36:36,020
we want to decompose your old program in

00:36:32,750 --> 00:36:38,410
two different functions and that's

00:36:36,020 --> 00:36:41,869
essential if you don't have that ability

00:36:38,410 --> 00:36:46,670
it is absolutely no way you can ever

00:36:41,869 --> 00:36:48,079
ever create real programs though if you

00:36:46,670 --> 00:36:51,140
want to structure your complete

00:36:48,079 --> 00:36:53,089
application with using co routines or

00:36:51,140 --> 00:36:54,380
generators like this there must be a way

00:36:53,089 --> 00:36:57,830
to decompose

00:36:54,380 --> 00:37:04,050
your generator into smaller generators

00:36:57,830 --> 00:37:05,880
have not the possibility forget it but

00:37:04,050 --> 00:37:08,610
our that's why this pep is is really

00:37:05,880 --> 00:37:15,480
important because this pep proposes a

00:37:08,610 --> 00:37:19,380
way of doing that it actually if you

00:37:15,480 --> 00:37:24,030
have to generator here's generator F and

00:37:19,380 --> 00:37:27,150
yes generator G what I do is I create a

00:37:24,030 --> 00:37:31,830
for loop around this generator G this

00:37:27,150 --> 00:37:36,510
generator G wants to delegate some work

00:37:31,830 --> 00:37:38,220
to F now because this code has to

00:37:36,510 --> 00:37:41,820
compile on the on the machine I'm

00:37:38,220 --> 00:37:45,210
working on and I had this underscore but

00:37:41,820 --> 00:37:48,690
actually it must be like this but this

00:37:45,210 --> 00:37:52,290
this is the way the G delegates work to

00:37:48,690 --> 00:37:54,840
F it just says yield from F and this is

00:37:52,290 --> 00:38:02,210
essentially the pep this is what the pep

00:37:54,840 --> 00:38:04,860
is all about I can I can show you that

00:38:02,210 --> 00:38:08,070
but not because there's no

00:38:04,860 --> 00:38:09,480
implementation and I I've had at least I

00:38:08,070 --> 00:38:12,480
have no implementation of sheep aight

00:38:09,480 --> 00:38:13,620
and that really supports this youth from

00:38:12,480 --> 00:38:15,360
construction because it's a language

00:38:13,620 --> 00:38:17,250
feature and it's not that the compiler

00:38:15,360 --> 00:38:19,530
has to recognize it but it's also a

00:38:17,250 --> 00:38:24,110
virtual machine features are the virtual

00:38:19,530 --> 00:38:24,110
machine also must do little things i

00:38:24,170 --> 00:38:30,710
created the other way of doing it and

00:38:28,440 --> 00:38:33,300
this is this is what i call compose

00:38:30,710 --> 00:38:38,490
compose is actually an implementation of

00:38:33,300 --> 00:38:40,880
pep 380 i found a letter because we were

00:38:38,490 --> 00:38:44,850
doing this already before this pep was

00:38:40,880 --> 00:38:47,820
existing and that's quite reasonable

00:38:44,850 --> 00:38:49,800
because writing 2 of 5 is already quite

00:38:47,820 --> 00:38:51,540
old and it has these generalized

00:38:49,800 --> 00:38:53,280
generators and if you start working with

00:38:51,540 --> 00:38:54,810
them you will fairly very soon

00:38:53,280 --> 00:38:56,970
discovered that it is completely

00:38:54,810 --> 00:38:59,490
unusable if you don't have this way of

00:38:56,970 --> 00:39:01,380
delegating to other generators so you

00:38:59,490 --> 00:39:03,690
start thinking about it and doing stuff

00:39:01,380 --> 00:39:07,140
and we did it a couple of years ago and

00:39:03,690 --> 00:39:12,970
we created the thing we call compose

00:39:07,140 --> 00:39:15,640
yeah and instead of using you from we

00:39:12,970 --> 00:39:17,500
use both and it's called composed

00:39:15,640 --> 00:39:19,410
because what you actually are doing is

00:39:17,500 --> 00:39:21,610
you are decomposing your program and

00:39:19,410 --> 00:39:23,080
compose helps you in composing them

00:39:21,610 --> 00:39:27,520
again so that's the reason why it's

00:39:23,080 --> 00:39:30,790
called compose so instead of having this

00:39:27,520 --> 00:39:33,610
in your generator use compose and you

00:39:30,790 --> 00:39:36,480
wrap the generator and then what compose

00:39:33,610 --> 00:39:39,790
actually does it detects whenever a

00:39:36,480 --> 00:39:43,720
generator here is G again but without

00:39:39,790 --> 00:39:46,990
from when G yields the generator compose

00:39:43,720 --> 00:39:51,010
detects that and said well I assume you

00:39:46,990 --> 00:39:53,020
want to do you from and I descend or our

00:39:51,010 --> 00:39:55,900
delegate to their generator you just

00:39:53,020 --> 00:40:01,030
sealed it this is quite different from

00:39:55,900 --> 00:40:04,180
from the PAP and why is that and i found

00:40:01,030 --> 00:40:06,940
this easier to work with because I

00:40:04,180 --> 00:40:09,070
didn't have to to make a distinction an

00:40:06,940 --> 00:40:12,670
extension to the language because I

00:40:09,070 --> 00:40:16,510
don't have an extra key word I know that

00:40:12,670 --> 00:40:18,430
was not a really big problem that every

00:40:16,510 --> 00:40:23,550
generator that is yielded here is also

00:40:18,430 --> 00:40:26,260
it's always treated like a delicate II

00:40:23,550 --> 00:40:30,220
really it's really not a big problem so

00:40:26,260 --> 00:40:33,940
it's working quite well um but there is

00:40:30,220 --> 00:40:36,880
a difference because now the generator G

00:40:33,940 --> 00:40:39,580
does not decide for itself if it wants

00:40:36,880 --> 00:40:41,440
to yield from this generator f but it

00:40:39,580 --> 00:40:44,950
has been decided earlier in the stage

00:40:41,440 --> 00:40:47,830
when G was wrapped with G if a

00:40:44,950 --> 00:40:49,750
compulsory but there's this little

00:40:47,830 --> 00:40:53,710
there's little distinction in what you

00:40:49,750 --> 00:40:56,700
can do this works actually it's not

00:40:53,710 --> 00:40:56,700
really exciting but

00:41:01,710 --> 00:41:11,130
there's hello earth says hello and then

00:41:08,280 --> 00:41:23,010
it says norm does anyone know why it

00:41:11,130 --> 00:41:25,200
says hello and then known for you here

00:41:23,010 --> 00:41:33,900
yeah this this is really great it

00:41:25,200 --> 00:41:36,690
actually says saying here this this will

00:41:33,900 --> 00:41:44,099
be recurring topic you in this talk so

00:41:36,690 --> 00:41:47,640
remember this but I thought that

00:41:44,099 --> 00:41:49,980
wrapping compose is quite quite useful

00:41:47,640 --> 00:41:52,560
but sometimes it's also nice to just use

00:41:49,980 --> 00:41:54,660
it as a gen as your decorator so you can

00:41:52,560 --> 00:41:57,089
just put compose here it's a bit smart

00:41:54,660 --> 00:42:01,589
it looks like that if am I used as a

00:41:57,089 --> 00:42:04,710
decorator then I do something else but

00:42:01,589 --> 00:42:06,599
this actually may makes of G composed or

00:42:04,710 --> 00:42:14,130
a decomposed whatever you call it

00:42:06,599 --> 00:42:16,650
generator and there's another quite

00:42:14,130 --> 00:42:20,150
essential thing if you apply compose

00:42:16,650 --> 00:42:22,440
once all these generators keep on

00:42:20,150 --> 00:42:26,550
delegating to each other then you don't

00:42:22,440 --> 00:42:29,250
have to reapply compose what I did here

00:42:26,550 --> 00:42:35,790
as you created three generators there's

00:42:29,250 --> 00:42:40,589
F G and there's h h yields to g ng F and

00:42:35,790 --> 00:42:42,950
F says I'm f and i apply composer only

00:42:40,589 --> 00:42:52,080
once to the top level the last 18 and

00:42:42,950 --> 00:42:57,510
then print what comes out this says I'm

00:42:52,080 --> 00:42:59,359
f this is this quite subtle you really

00:42:57,510 --> 00:43:01,950
have to understand it because I'm

00:42:59,359 --> 00:43:05,940
suggesting suggesting that there is a

00:43:01,950 --> 00:43:07,260
higher key generators there is a chin

00:43:05,940 --> 00:43:10,470
there's G in there's f there's basically

00:43:07,260 --> 00:43:14,190
some sort of a whole stack or something

00:43:10,470 --> 00:43:15,330
like that there actually isn't remember

00:43:14,190 --> 00:43:18,720
that if you

00:43:15,330 --> 00:43:21,420
that when you yield the generator what

00:43:18,720 --> 00:43:24,960
actually happens is the generator that

00:43:21,420 --> 00:43:27,570
is yielding is stepping aside and that

00:43:24,960 --> 00:43:30,690
this other generator replace itself and

00:43:27,570 --> 00:43:32,940
do the work with avarom and working

00:43:30,690 --> 00:43:34,800
directly with whoever was calling the

00:43:32,940 --> 00:43:37,050
original generator and then when it's

00:43:34,800 --> 00:43:40,860
done I'm stepping inside again and I'll

00:43:37,050 --> 00:43:45,000
take over the work again so this for

00:43:40,860 --> 00:43:49,770
loop here communicates directly with H

00:43:45,000 --> 00:43:51,840
then it steps aside then it then H steps

00:43:49,770 --> 00:43:54,750
aside and then this for loop directly

00:43:51,840 --> 00:43:56,640
communicate is d he also steps a size

00:43:54,750 --> 00:43:59,310
again and then this for loop is directly

00:43:56,640 --> 00:44:08,370
communicating with F and an F cells I'm

00:43:59,310 --> 00:44:10,580
f and then you're done oh yes actually

00:44:08,370 --> 00:44:10,580
yesterday

00:44:15,289 --> 00:44:20,970
yeah sorry out repeat what you're saying

00:44:18,809 --> 00:44:23,130
because there's no it's not recording

00:44:20,970 --> 00:44:25,529
and maybe you didn't hear it you said

00:44:23,130 --> 00:44:27,240
there's a stack inside composed of

00:44:25,529 --> 00:44:31,920
generators that were braiding and that's

00:44:27,240 --> 00:44:37,200
that's exactly right well this all this

00:44:31,920 --> 00:44:39,390
also works to way because the previous

00:44:37,200 --> 00:44:42,210
example here was just a normal good old

00:44:39,390 --> 00:44:45,720
generator but this one is actually

00:44:42,210 --> 00:44:49,549
working both ways so it's it's sending

00:44:45,720 --> 00:44:52,650
messages and it's receiving responses

00:44:49,549 --> 00:44:55,130
it's quite the it's quite interesting

00:44:52,650 --> 00:44:59,089
here to see what's happening because

00:44:55,130 --> 00:45:05,910
here again is this first line its best

00:44:59,089 --> 00:45:08,059
next p dot next so that's being tend to

00:45:05,910 --> 00:45:12,269
this generator here which is composed

00:45:08,059 --> 00:45:15,630
generator just yields F so it it ends up

00:45:12,269 --> 00:45:17,880
here and you still have to do this next

00:45:15,630 --> 00:45:19,920
as the first thing because this f must

00:45:17,880 --> 00:45:22,680
run until the first yield statement

00:45:19,920 --> 00:45:25,079
that's a strange thing about generators

00:45:22,680 --> 00:45:31,349
you always have to say start them first

00:45:25,079 --> 00:45:36,599
by sending them bowling next I run this

00:45:31,349 --> 00:45:41,489
code first says none and then it says

00:45:36,599 --> 00:45:45,059
hello that's because this first print

00:45:41,489 --> 00:45:49,640
statement is here it says next thing

00:45:45,059 --> 00:45:53,309
doesn't heal anything or again none

00:45:49,640 --> 00:45:59,279
because if you leave out the value it

00:45:53,309 --> 00:46:03,089
assumes none then it used the message it

00:45:59,279 --> 00:46:08,089
just got so the next thing Bryn's hello

00:46:03,089 --> 00:46:08,089
it sends hello and it prints hello sorry

00:46:15,520 --> 00:46:25,880
yeah okay oh yeah that second it's an

00:46:18,020 --> 00:46:27,910
interesting one like this well let's run

00:46:25,880 --> 00:46:27,910
it

00:46:32,030 --> 00:46:41,770
oh sorry yeah thnkx dead back again all

00:46:39,050 --> 00:46:41,770
right there

00:46:55,089 --> 00:47:02,640
better eat Prince gnome twice and then

00:46:59,859 --> 00:47:09,579
it gives you a stop iteration exception

00:47:02,640 --> 00:47:13,599
clear why this happening really

00:47:09,579 --> 00:47:15,960
convinced first of all Prince known

00:47:13,599 --> 00:47:19,660
because you send it on its just echoing

00:47:15,960 --> 00:47:22,059
and but there's there's a little bit

00:47:19,660 --> 00:47:28,900
more to say about that because what this

00:47:22,059 --> 00:47:33,489
actually could have been was this acting

00:47:28,900 --> 00:47:36,969
the same a gun on online a stop

00:47:33,489 --> 00:47:39,069
iteration exception so next is exactly

00:47:36,969 --> 00:47:42,940
is completely one hundred percent

00:47:39,069 --> 00:47:44,319
equivalent to send norm thank you are

00:47:42,940 --> 00:47:49,690
your question because this is also one

00:47:44,319 --> 00:47:52,239
of them important things what's

00:47:49,690 --> 00:47:53,589
interesting move this here what's

00:47:52,239 --> 00:47:58,779
interesting to see here is that you

00:47:53,589 --> 00:48:03,239
online on this line here then something

00:47:58,779 --> 00:48:05,440
and you get back a response immediately

00:48:03,239 --> 00:48:07,599
this isn't interesting to note that

00:48:05,440 --> 00:48:10,869
there's actually some sort of function

00:48:07,599 --> 00:48:15,009
call that sense and response that's

00:48:10,869 --> 00:48:16,960
happening in one in one step actually

00:48:15,009 --> 00:48:20,079
because the code start executing here

00:48:16,960 --> 00:48:21,999
there's the assignment due message runs

00:48:20,079 --> 00:48:24,609
and then use the same message so there's

00:48:21,999 --> 00:48:26,680
actually there's some sort of a little

00:48:24,609 --> 00:48:28,089
bit of code that is called by send and

00:48:26,680 --> 00:48:30,809
that's between the yield statement that

00:48:28,089 --> 00:48:33,339
receive something in a deal something

00:48:30,809 --> 00:48:35,489
that's in the only one step of a

00:48:33,339 --> 00:48:35,489
question

00:48:49,119 --> 00:48:54,039
no that happens it happens to the next

00:48:51,579 --> 00:49:00,480
time so I have to call send again and

00:48:54,039 --> 00:49:04,210
then you get the stop iteration here and

00:49:00,480 --> 00:49:06,460
whatever doesn't matter then it falls

00:49:04,210 --> 00:49:12,160
off the edge so to say it's it's done

00:49:06,460 --> 00:49:15,460
here dish yeah happening here actually f

00:49:12,160 --> 00:49:18,009
F F is stopping running off the edge is

00:49:15,460 --> 00:49:21,369
coming to the end then it terminates

00:49:18,009 --> 00:49:25,680
with raising a stop iteration don't see

00:49:21,369 --> 00:49:28,749
that actually raising a stop iteration

00:49:25,680 --> 00:49:30,700
that's one of the reasons that calling

00:49:28,749 --> 00:49:32,619
sent is not so convenient because you

00:49:30,700 --> 00:49:34,269
have to catch the stop iteration and

00:49:32,619 --> 00:49:36,759
normally it happens inside the for loop

00:49:34,269 --> 00:49:39,789
before loop actually terminates because

00:49:36,759 --> 00:49:41,799
of the data source raising a stop

00:49:39,789 --> 00:49:43,210
iteration exception so it is quite

00:49:41,799 --> 00:49:46,329
neatly but if you call center yourself

00:49:43,210 --> 00:49:50,589
and it's not so it's not so nice to to

00:49:46,329 --> 00:49:55,359
do this to catch these exceptions Sorry

00:49:50,589 --> 00:49:57,930
Sorry an f second um so here's this this

00:49:55,359 --> 00:49:57,930
exception

00:50:05,780 --> 00:50:10,430
yes yeah it's completely transparent

00:50:08,240 --> 00:50:13,490
yeah you can have it as many times as

00:50:10,430 --> 00:50:20,470
you want don't even I'll come back to

00:50:13,490 --> 00:50:20,470
that later I shall I remove this again

00:50:24,220 --> 00:50:28,490
but actually did much of this piece of

00:50:26,750 --> 00:50:30,200
cult has already been taken care of

00:50:28,490 --> 00:50:34,640
because this is this is an alternative

00:50:30,200 --> 00:50:39,020
it is exactly the same but if you see in

00:50:34,640 --> 00:50:41,390
this line here it's actually a loop so

00:50:39,020 --> 00:50:44,720
doesn't terminate and it yields the

00:50:41,390 --> 00:50:46,340
message just got but what do how do you

00:50:44,720 --> 00:50:49,160
start I mean message must have a value

00:50:46,340 --> 00:50:51,500
the first time so what I did as I made

00:50:49,160 --> 00:50:55,400
it nom so the first time you enter that

00:50:51,500 --> 00:50:57,470
loop there's yield none that's the first

00:50:55,400 --> 00:50:59,600
thing that is being yielded and then

00:50:57,470 --> 00:51:03,500
loop just continues by echoing this

00:50:59,600 --> 00:51:07,730
message I also apply this instead of

00:51:03,500 --> 00:51:10,100
next time i wrote sent nom and we have

00:51:07,730 --> 00:51:12,590
already covered it because it's instant

00:51:10,100 --> 00:51:15,290
essential to understand that next is

00:51:12,590 --> 00:51:18,410
just sent nom and yield without any

00:51:15,290 --> 00:51:22,210
arguments is just yield none quite

00:51:18,410 --> 00:51:26,210
important I'll come back to that later a

00:51:22,210 --> 00:51:30,980
couple of times here's something that is

00:51:26,210 --> 00:51:32,930
actually in bed 38 you would expect if

00:51:30,980 --> 00:51:35,270
you for example here you have a

00:51:32,930 --> 00:51:36,950
generator and you use another generator

00:51:35,270 --> 00:51:39,950
so you delegate to the generator and

00:51:36,950 --> 00:51:42,970
suppose this generator f is raising an

00:51:39,950 --> 00:51:47,230
exception something goes wrong now you'd

00:51:42,970 --> 00:51:51,470
expect that you would call it this way

00:51:47,230 --> 00:51:54,980
able to try and accept gets this

00:51:51,470 --> 00:51:57,530
exception but actually it isn't reason

00:51:54,980 --> 00:52:02,990
why is our only tell told you that when

00:51:57,530 --> 00:52:05,510
G here this generator G delegates to F

00:52:02,990 --> 00:52:08,660
it basically is stepping aside and that

00:52:05,510 --> 00:52:11,780
f the woodwork do which work so f raises

00:52:08,660 --> 00:52:14,450
an exception where does it end up then

00:52:11,780 --> 00:52:17,510
the ends up in the somewhere in the

00:52:14,450 --> 00:52:18,750
caller of F which was previously the

00:52:17,510 --> 00:52:20,220
color of

00:52:18,750 --> 00:52:22,560
of tea but now it's the corner of

00:52:20,220 --> 00:52:25,890
episode the G is just stepping aside it

00:52:22,560 --> 00:52:27,360
never sees this exception and this is

00:52:25,890 --> 00:52:29,340
one of the things you really have to fix

00:52:27,360 --> 00:52:33,110
and this is what that 38 is fixing and

00:52:29,340 --> 00:52:33,110
this is also what composers fixing

00:52:33,410 --> 00:52:39,140
because you really want to be able to oh

00:52:41,030 --> 00:52:46,580
it just catches this exception here

00:52:46,730 --> 00:52:56,490
glosses been sit here now this is one of

00:52:51,420 --> 00:53:00,150
the I think one of the most one of the

00:52:56,490 --> 00:53:01,770
best examples of the difference between

00:53:00,150 --> 00:53:03,360
these two programmers one inside the

00:53:01,770 --> 00:53:04,680
virtual machine and one outside the

00:53:03,360 --> 00:53:07,080
virtual machine that one outside the

00:53:04,680 --> 00:53:10,560
virtual machine just once once to type

00:53:07,080 --> 00:53:14,580
try yield f except blah blah blah that

00:53:10,560 --> 00:53:18,810
you just accept are you have to be able

00:53:14,580 --> 00:53:20,640
to catch exceptions and then it doesn't

00:53:18,810 --> 00:53:22,350
and you get frustrated so you have to go

00:53:20,640 --> 00:53:26,160
back into this virtual machines you or

00:53:22,350 --> 00:53:28,830
why is not happening well how i fix this

00:53:26,160 --> 00:53:34,410
in compulsion is by just having this

00:53:28,830 --> 00:53:37,290
stack of generator so if f if G steps

00:53:34,410 --> 00:53:40,890
aside and gives us the room and g is

00:53:37,290 --> 00:53:44,000
kept on the stack and whenever f raises

00:53:40,890 --> 00:53:48,680
an exception it is first sent to g

00:53:44,000 --> 00:53:48,680
that's how you fix this problem here

00:53:50,510 --> 00:53:56,520
then there's another problem i'm not

00:53:52,740 --> 00:54:00,210
sure if this is part of Pep 38 or not it

00:53:56,520 --> 00:54:05,540
doesn't say so explicitly but this is

00:54:00,210 --> 00:54:05,540
quite important here yeah

00:54:16,600 --> 00:54:21,030
yeah okay

00:54:26,910 --> 00:54:33,700
your question is actually if compose

00:54:30,940 --> 00:54:36,490
catches an exception from F and it sends

00:54:33,700 --> 00:54:39,839
it sends it to G where and when does it

00:54:36,490 --> 00:54:39,839
happen is that your question actually

00:54:43,170 --> 00:54:49,960
yeah well just only one it's it's

00:54:47,230 --> 00:54:52,690
completely transparent so if here's a

00:54:49,960 --> 00:54:55,420
youth statement here or actually all it

00:54:52,690 --> 00:54:56,740
raises this exception here but this

00:54:55,420 --> 00:55:00,670
yield statement is not seen by the

00:54:56,740 --> 00:55:04,119
caller so composed takes care of

00:55:00,670 --> 00:55:07,599
invoking f directly so you don't you

00:55:04,119 --> 00:55:12,670
just see it as your s going to this

00:55:07,599 --> 00:55:16,000
point right away and if a generator is

00:55:12,670 --> 00:55:19,240
has yielded a value I suppose you have

00:55:16,000 --> 00:55:22,079
this generator object and you send it

00:55:19,240 --> 00:55:25,150
something and then it returns actually

00:55:22,079 --> 00:55:26,530
generator returns by having a yield

00:55:25,150 --> 00:55:29,069
statement so this yield me they

00:55:26,530 --> 00:55:31,270
basically means something like return

00:55:29,069 --> 00:55:34,510
when they when you have to generate

00:55:31,270 --> 00:55:36,760
object and it has yielded then you can

00:55:34,510 --> 00:55:40,180
basically do three things not only to

00:55:36,760 --> 00:55:43,300
you can send it next different to

00:55:40,180 --> 00:55:44,710
calling sent with a with nom but you can

00:55:43,300 --> 00:55:49,510
also do a third thing and that's called

00:55:44,710 --> 00:55:51,970
fro outline it that but that's a because

00:55:49,510 --> 00:55:54,760
you usually don't need it but under the

00:55:51,970 --> 00:55:57,670
hood you will need it and fro actually

00:55:54,760 --> 00:56:00,940
also resumes the generator exactly at

00:55:57,670 --> 00:56:03,520
this point here but is exactly the same

00:56:00,940 --> 00:56:07,210
as sent and next but it resumed to

00:56:03,520 --> 00:56:10,630
generator with an exception so yeah at

00:56:07,210 --> 00:56:14,200
this point very you this an exception is

00:56:10,630 --> 00:56:17,829
raised and it's posed by someone calling

00:56:14,200 --> 00:56:19,150
throw on the generator object it's

00:56:17,829 --> 00:56:23,890
really an implementation detail you

00:56:19,150 --> 00:56:28,540
really don't have to care about that as

00:56:23,890 --> 00:56:30,579
you want to of course now there's so

00:56:28,540 --> 00:56:32,859
there's something else associated with

00:56:30,579 --> 00:56:34,810
with exceptions suppose you have you you

00:56:32,859 --> 00:56:37,359
big program and it's hundreds of

00:56:34,810 --> 00:56:38,320
generators and then there's something

00:56:37,359 --> 00:56:42,760
going wrong what do

00:56:38,320 --> 00:56:46,090
you do there's treasure somewhere on

00:56:42,760 --> 00:56:47,860
your screen but because of you every

00:56:46,090 --> 00:56:50,320
generator stepping aside and giving the

00:56:47,860 --> 00:56:52,510
other generator a turn to do something

00:56:50,320 --> 00:56:55,180
this generator stepping aside is not on

00:56:52,510 --> 00:56:57,570
the call stack so it's not printed on

00:56:55,180 --> 00:57:00,250
any exception on any trace back either

00:56:57,570 --> 00:57:02,920
and this makes it virtually impossible

00:57:00,250 --> 00:57:05,800
to deal with your coat and to deal with

00:57:02,920 --> 00:57:07,990
exceptions it's pegs in programming next

00:57:05,800 --> 00:57:11,350
to impossible because you it's each time

00:57:07,990 --> 00:57:13,390
it's like saying like programming in C

00:57:11,350 --> 00:57:14,650
and you just have a segmentation fault

00:57:13,390 --> 00:57:16,120
and there's something wrong and you

00:57:14,650 --> 00:57:18,400
don't have a debugger to get a stack

00:57:16,120 --> 00:57:21,730
trace so you just have to guess where it

00:57:18,400 --> 00:57:25,420
went wrong this is nothing so what I did

00:57:21,730 --> 00:57:28,290
is I also in a generator is raising an

00:57:25,420 --> 00:57:28,290
exception like here

00:57:37,870 --> 00:57:44,200
like this and then you will see on the

00:57:40,600 --> 00:57:45,610
stack trace that there is a sheer f on

00:57:44,200 --> 00:57:49,180
the stack there's GE on the stack and

00:57:45,610 --> 00:57:51,430
there's H on the stack the discompose is

00:57:49,180 --> 00:57:53,680
holding a stack of all these generators

00:57:51,430 --> 00:57:55,510
and as soon as an exception takes place

00:57:53,680 --> 00:57:57,120
it make sure that these things are

00:57:55,510 --> 00:58:00,580
actually printed in on the stack trace

00:57:57,120 --> 00:58:03,250
so you will find it very easy to find

00:58:00,580 --> 00:58:09,520
your the way the point where the error

00:58:03,250 --> 00:58:12,700
occurred I'm not sure if this is in pep

00:58:09,520 --> 00:58:16,300
three ID it could be probably yes I

00:58:12,700 --> 00:58:18,070
think how do you return a value I'll

00:58:16,300 --> 00:58:20,200
just ignore all the red stuff below

00:58:18,070 --> 00:58:23,830
because we already covered that it's

00:58:20,200 --> 00:58:25,450
still here I'll do your return of value

00:58:23,830 --> 00:58:32,710
will actually do that by raising stop

00:58:25,450 --> 00:58:36,070
iteration I remember I told already that

00:58:32,710 --> 00:58:39,340
return of generator is actually raising

00:58:36,070 --> 00:58:41,080
a stop iteration if you return if you

00:58:39,340 --> 00:58:44,290
ever actually return statement in a

00:58:41,080 --> 00:58:48,270
generator and it basically means the

00:58:44,290 --> 00:58:50,710
same as stop iteration with no arguments

00:58:48,270 --> 00:58:53,440
turn and stop iteration are really

00:58:50,710 --> 00:58:55,450
interchangeable so this line here it

00:58:53,440 --> 00:58:58,390
says explicitly stop iteration with a

00:58:55,450 --> 00:59:03,610
value or FL you then is to return tell

00:58:58,390 --> 00:59:05,530
you but it would be in maybe Python for

00:59:03,610 --> 00:59:07,000
or something like that it could become

00:59:05,530 --> 00:59:09,940
possible to just write this in your

00:59:07,000 --> 00:59:12,280
generator return returnvalue and that

00:59:09,940 --> 00:59:16,120
would this actually also proposed by pep

00:59:12,280 --> 00:59:19,630
380 to do it like this and now what you

00:59:16,120 --> 00:59:23,620
can do is write this you have a value

00:59:19,630 --> 00:59:27,430
fee which is the result of calling short

00:59:23,620 --> 00:59:30,370
of calling yield f and this fee actually

00:59:27,430 --> 00:59:36,240
gets gets the value that is booting stop

00:59:30,370 --> 00:59:36,240
iteration over here person

00:59:57,490 --> 01:00:08,280
or I can hardly understand it yeah yeah

01:00:05,860 --> 01:00:08,280
yes

01:00:17,140 --> 01:00:31,520
yeah yeah okay I said I ya understand

01:00:27,350 --> 01:00:33,680
your question yeah okay so your question

01:00:31,520 --> 01:00:35,870
is actually isn't this raising a stop

01:00:33,680 --> 01:00:39,260
iteration isn't that a problem if you

01:00:35,870 --> 01:00:42,380
have this slide here if this you try

01:00:39,260 --> 01:00:43,990
except without any any exception

01:00:42,380 --> 01:00:46,880
specification there's no class here

01:00:43,990 --> 01:00:48,770
isn't as a possibility that you then are

01:00:46,880 --> 01:00:50,150
hiding stop iteration exceptions that

01:00:48,770 --> 01:00:54,440
through two are you turning values

01:00:50,150 --> 01:00:56,540
actually answer is no because compose is

01:00:54,440 --> 01:00:59,300
catching these top iteration exceptions

01:00:56,540 --> 01:01:01,820
and turning them into something else but

01:00:59,300 --> 01:01:04,790
the only thing your your get it will get

01:01:01,820 --> 01:01:14,960
here is is all exceptions except stop

01:01:04,790 --> 01:01:16,520
iteration does that clear answer but

01:01:14,960 --> 01:01:20,660
this is how you return FL you now what

01:01:16,520 --> 01:01:23,600
what's interesting here is to to see how

01:01:20,660 --> 01:01:29,210
this return actually works because if

01:01:23,600 --> 01:01:34,070
you have this burning a value that must

01:01:29,210 --> 01:01:36,710
return from yield then someone must all

01:01:34,070 --> 01:01:38,200
sent on this generator if this return

01:01:36,710 --> 01:01:42,410
value I mean that's the only way

01:01:38,200 --> 01:01:44,660
something can get assigned here now what

01:01:42,410 --> 01:01:48,620
actually got composed us it catches this

01:01:44,660 --> 01:01:53,360
top iteration extracts this value here

01:01:48,620 --> 01:01:59,200
and then call sent on 2g let it continue

01:01:53,360 --> 01:02:02,270
here and have this value in fee this is

01:01:59,200 --> 01:02:04,810
quite interesting to to remember you

01:02:02,270 --> 01:02:08,720
come back to that in a couple of minutes

01:02:04,810 --> 01:02:11,030
this is this is actually the way that co

01:02:08,720 --> 01:02:16,070
routines are done and this is what what

01:02:11,030 --> 01:02:17,690
I don't like because you need this

01:02:16,070 --> 01:02:19,670
trampling here i don't think i'm going

01:02:17,690 --> 01:02:21,770
to cover this completely this is this is

01:02:19,670 --> 01:02:25,850
to curl routines so if you would have

01:02:21,770 --> 01:02:27,770
the ejection notion of cal routines and

01:02:25,850 --> 01:02:30,010
you would literally implement it and you

01:02:27,770 --> 01:02:32,410
would have to go things like these

01:02:30,010 --> 01:02:35,710
calling calling each other but you can't

01:02:32,410 --> 01:02:37,990
call them so if this coding he wants to

01:02:35,710 --> 01:02:41,970
call coding bead and it actually yields

01:02:37,990 --> 01:02:44,350
the name of B comma and then a value and

01:02:41,970 --> 01:02:46,750
then it that goes back to this

01:02:44,350 --> 01:02:49,840
trampoline it actually takes this be

01:02:46,750 --> 01:02:51,310
here and calls it if this parameter here

01:02:49,840 --> 01:02:52,690
so it doesn't look like a function call

01:02:51,310 --> 01:02:54,340
with this trampoline is making it a

01:02:52,690 --> 01:02:57,700
function call and this is really an

01:02:54,340 --> 01:03:00,090
awkward way of doing it if you if you

01:02:57,700 --> 01:03:03,070
want to use playing real co routines in

01:03:00,090 --> 01:03:05,260
this way just get the green light source

01:03:03,070 --> 01:03:07,450
necklace or or any of the other

01:03:05,260 --> 01:03:08,770
alternatives that do it better than only

01:03:07,450 --> 01:03:12,750
they've covered all you've generated

01:03:08,770 --> 01:03:16,630
because this dark aggression it's nuffin

01:03:12,750 --> 01:03:20,500
did something else I made a very bold

01:03:16,630 --> 01:03:23,140
decision actually I sure I didn't decide

01:03:20,500 --> 01:03:25,840
it it just happened but then still

01:03:23,140 --> 01:03:29,050
you're deciding if I said well there is

01:03:25,840 --> 01:03:31,090
this coating here gauteng a and there's

01:03:29,050 --> 01:03:33,190
call routing be you know what I do this

01:03:31,090 --> 01:03:35,620
cowl routine be is just sending to

01:03:33,190 --> 01:03:38,140
coyote coyote a just like in the

01:03:35,620 --> 01:03:42,970
previous example but Kyle routine a is

01:03:38,140 --> 01:03:44,980
not thing that is has its own loop it's

01:03:42,970 --> 01:03:47,920
not selling to be explicitly call

01:03:44,980 --> 01:03:53,200
routing a has a very limited scope co

01:03:47,920 --> 01:03:56,380
routine a is created here being used

01:03:53,200 --> 01:03:58,960
being you but and as soon as cutting a

01:03:56,380 --> 01:04:01,300
is done which is rather quickly because

01:03:58,960 --> 01:04:04,840
it has only one yield statement it is

01:04:01,300 --> 01:04:06,820
done so it is not an actor that is

01:04:04,840 --> 01:04:08,980
accepting messages and giving responses

01:04:06,820 --> 01:04:11,740
this is this system the model I showed

01:04:08,980 --> 01:04:13,930
you on one of the earlier slides that is

01:04:11,740 --> 01:04:15,940
not the actor model of two processes

01:04:13,930 --> 01:04:17,680
communicating to coyotes but it's just

01:04:15,940 --> 01:04:20,860
one coating is actually doing something

01:04:17,680 --> 01:04:23,500
a loop that's cutting be here the other

01:04:20,860 --> 01:04:26,440
car routine is very very limited it's

01:04:23,500 --> 01:04:28,780
very short lift coating and it turns out

01:04:26,440 --> 01:04:30,850
that this is just as powerful as the

01:04:28,780 --> 01:04:32,470
previous model so one of your agenda one

01:04:30,850 --> 01:04:35,560
of your generators or crow routines is

01:04:32,470 --> 01:04:37,030
just way more limited but it still is as

01:04:35,560 --> 01:04:40,150
powerful and you can get the whole

01:04:37,030 --> 01:04:43,510
jection stuff or working with only this

01:04:40,150 --> 01:04:46,510
now doing this makes it

01:04:43,510 --> 01:04:50,230
very very neat you can write it down in

01:04:46,510 --> 01:04:53,710
a neat syntax in a very comprehensible

01:04:50,230 --> 01:04:55,120
way that's quite important because if

01:04:53,710 --> 01:04:56,620
you are this programmer outside the

01:04:55,120 --> 01:04:59,320
virtual machine you don't want to be

01:04:56,620 --> 01:05:00,670
both are difficult stuff and here you

01:04:59,320 --> 01:05:01,990
are bothered by it because you have to

01:05:00,670 --> 01:05:04,230
write these stupid things to call a

01:05:01,990 --> 01:05:04,230
function

01:05:15,829 --> 01:05:20,609
now here's the so that's that's the

01:05:19,079 --> 01:05:23,160
first choice in May the second thing is

01:05:20,609 --> 01:05:26,219
it's about this other slide with this

01:05:23,160 --> 01:05:28,979
change in model the change of you here's

01:05:26,219 --> 01:05:30,869
what I show here is a socket driver and

01:05:28,979 --> 01:05:34,499
it actually reads a socket it's of

01:05:30,869 --> 01:05:37,829
course naive grossly naive code it reads

01:05:34,499 --> 01:05:42,299
a socket and here anytime it reads

01:05:37,829 --> 01:05:45,809
something it sends it to the generator

01:05:42,299 --> 01:05:48,079
and if the safe generator would would

01:05:45,809 --> 01:05:53,279
reply something response then it would

01:05:48,079 --> 01:05:55,049
send that to the oh no I'm sorry I'm

01:05:53,279 --> 01:05:57,150
wrong it sends it to the generator on

01:05:55,049 --> 01:05:59,519
this line if you generate the response

01:05:57,150 --> 01:06:02,579
with something it sends it to the socket

01:05:59,519 --> 01:06:03,930
and then it reads the socket to see if

01:06:02,579 --> 01:06:05,819
there's a message from the socket and

01:06:03,930 --> 01:06:07,739
yes there is a message and it's

01:06:05,819 --> 01:06:10,079
sensitive to the generator again so

01:06:07,739 --> 01:06:12,569
basically the idea is this is this is

01:06:10,079 --> 01:06:14,729
very too simple but the idea is have a

01:06:12,569 --> 01:06:17,009
generator connected to a socket because

01:06:14,729 --> 01:06:19,410
socket has two streams both ways a

01:06:17,009 --> 01:06:21,089
generator also has two streams nowadays

01:06:19,410 --> 01:06:30,779
so you can communicate both ways that's

01:06:21,089 --> 01:06:34,799
the basic idea 30 oh yeah I've made a

01:06:30,779 --> 01:06:36,690
mistake here yeah this response and

01:06:34,799 --> 01:06:41,099
waited a bit sure because to fit in this

01:06:36,690 --> 01:06:44,369
window so this is a slightly more

01:06:41,099 --> 01:06:47,309
elaborate socket driver it's still very

01:06:44,369 --> 01:06:50,039
simple but what I want to what want to

01:06:47,309 --> 01:06:51,509
stress here is that there is this

01:06:50,039 --> 01:06:54,029
generator and there is this socket and

01:06:51,509 --> 01:06:55,469
the socket is basically very stupid the

01:06:54,029 --> 01:06:57,959
shocker doesn't say anything about a

01:06:55,469 --> 01:06:59,940
protocol and my idea is that the

01:06:57,959 --> 01:07:02,549
protocol is defined by the generator or

01:06:59,940 --> 01:07:04,410
the kalu team so what you do is the

01:07:02,549 --> 01:07:07,589
first thing you do in the socket driver

01:07:04,410 --> 01:07:09,420
does it asks the protocol which is

01:07:07,589 --> 01:07:11,430
actually here it's just a parameter and

01:07:09,420 --> 01:07:14,910
it's meant to be a coating or a

01:07:11,430 --> 01:07:16,890
generator it stands it next and it

01:07:14,910 --> 01:07:19,529
basically here at line at this line it

01:07:16,890 --> 01:07:22,559
asks the protocol what do you wanted me

01:07:19,529 --> 01:07:25,559
to send what we all do you want me to do

01:07:22,559 --> 01:07:26,970
and then here you see the if it says if

01:07:25,559 --> 01:07:29,850
there is a response

01:07:26,970 --> 01:07:31,530
then I send it on the socket and if

01:07:29,850 --> 01:07:33,870
there's no response then I receive from

01:07:31,530 --> 01:07:35,490
the socket now this is quite important

01:07:33,870 --> 01:07:38,910
this is something that's missing in pep

01:07:35,490 --> 01:07:41,850
380 does what you're actually doing here

01:07:38,910 --> 01:07:44,490
is you send next to you send numb and

01:07:41,850 --> 01:07:46,110
then when it responses with something

01:07:44,490 --> 01:07:48,230
that's not none then you think oh that's

01:07:46,110 --> 01:07:51,240
data let's send that to the socket here

01:07:48,230 --> 01:07:54,060
but when it responses with numb it

01:07:51,240 --> 01:07:57,210
actually means oh it has no data

01:07:54,060 --> 01:07:59,870
probably it wants to receive data so i

01:07:57,210 --> 01:08:03,090
receive data on a socket and send it

01:07:59,870 --> 01:08:06,870
this is what I hesitated for to do about

01:08:03,090 --> 01:08:10,280
a year i think because somehow the

01:08:06,870 --> 01:08:12,810
special meaning of numb I didn't like it

01:08:10,280 --> 01:08:14,910
but I couldn't get it working i couldn't

01:08:12,810 --> 01:08:16,850
get this nice feeling for this

01:08:14,910 --> 01:08:20,910
programmer outside of the sexual machine

01:08:16,850 --> 01:08:24,890
to be just being working with it and not

01:08:20,910 --> 01:08:29,700
caring about it until i had this this

01:08:24,890 --> 01:08:31,860
special meaning for none and i basically

01:08:29,700 --> 01:08:34,380
here it says next there's an implicit

01:08:31,860 --> 01:08:37,050
norm if your youth statement without any

01:08:34,380 --> 01:08:39,990
parameters in inside the generator also

01:08:37,050 --> 01:08:42,330
implicitly yields none sorry for what

01:08:39,990 --> 01:08:43,710
why not do that on the other end end as

01:08:42,330 --> 01:08:46,260
well i mean there isn't one entity

01:08:43,710 --> 01:08:48,930
generator doing this is numb why not me

01:08:46,260 --> 01:08:51,510
as a driver of this generator do the

01:08:48,930 --> 01:08:53,490
same so well i sent normal it means that

01:08:51,510 --> 01:08:56,220
one day time and i get known that means

01:08:53,490 --> 01:09:00,800
human on data it's very very clear so

01:08:56,220 --> 01:09:06,080
you have some sort of flow control okay

01:09:00,800 --> 01:09:06,080
this this flow control is actually their

01:09:08,090 --> 01:09:12,450
blow control is one of the one of the

01:09:10,350 --> 01:09:13,920
main topics i think i think that 38

01:09:12,450 --> 01:09:16,140
shoot includes something like fro

01:09:13,920 --> 01:09:19,020
control because otherwise it drives you

01:09:16,140 --> 01:09:21,240
it really drives you crazy will be

01:09:19,020 --> 01:09:24,030
missing failures or other failures will

01:09:21,240 --> 01:09:26,780
get somewhere you don't expect them to

01:09:24,030 --> 01:09:30,300
show up just because you don't have

01:09:26,780 --> 01:09:36,410
something to do some way you flow the

01:09:30,300 --> 01:09:39,410
flow control now there's something else

01:09:36,410 --> 01:09:39,410
over

01:09:39,870 --> 01:09:45,640
support here so here's a nice example of

01:09:42,160 --> 01:09:48,640
this boundary clashes I have a generator

01:09:45,640 --> 01:09:55,300
at the top which is its reading a

01:09:48,640 --> 01:09:59,110
request line from from an HTTP best I've

01:09:55,300 --> 01:10:01,570
created this generator here I have

01:09:59,110 --> 01:10:03,970
composed around it and then I'm I'm

01:10:01,570 --> 01:10:05,680
pretending to be a real socket and I'm

01:10:03,970 --> 01:10:07,630
sending data and all kinds of weird

01:10:05,680 --> 01:10:11,590
chunks this is typical the boundary

01:10:07,630 --> 01:10:13,960
clash I mean I don't you will get here

01:10:11,590 --> 01:10:16,000
half of a status line then you get the

01:10:13,960 --> 01:10:17,380
next if piece of the next header and

01:10:16,000 --> 01:10:19,150
then you will get the header and

01:10:17,380 --> 01:10:22,960
possibly after the header you will get

01:10:19,150 --> 01:10:26,140
peace of the body we different sense so

01:10:22,960 --> 01:10:29,350
how do you deal with that for the first

01:10:26,140 --> 01:10:31,480
sent here actually will send something

01:10:29,350 --> 01:10:34,630
to hear so what I did in this loop I

01:10:31,480 --> 01:10:37,420
created loop here first I make my

01:10:34,630 --> 01:10:43,840
message empty and well as long as there

01:10:37,420 --> 01:10:46,240
is no this is a large physical in HTTP

01:10:43,840 --> 01:10:48,420
HTTP as long as there are no noble I fit

01:10:46,240 --> 01:10:53,340
in in the message I'll continue reading

01:10:48,420 --> 01:10:56,830
so this is no has no line fit in it

01:10:53,340 --> 01:11:00,280
second one has a line feet so this loop

01:10:56,830 --> 01:11:03,250
is terminated and then then I have my my

01:11:00,280 --> 01:11:07,450
status line but i also have pieces of

01:11:03,250 --> 01:11:08,980
the next part and I don't want that but

01:11:07,450 --> 01:11:14,290
this this is very typical in doing

01:11:08,980 --> 01:11:18,150
parsing and doing look ahead in don't

01:11:14,290 --> 01:11:21,280
look ahead but you do trace back tracing

01:11:18,150 --> 01:11:23,130
you will get this situation and how do

01:11:21,280 --> 01:11:27,280
you deal with death with generators

01:11:23,130 --> 01:11:31,320
actually what I did is I said well let's

01:11:27,280 --> 01:11:34,330
have stop iteration an extra parameter

01:11:31,320 --> 01:11:37,120
besides request here this is the return

01:11:34,330 --> 01:11:40,210
value I can put some more things to it

01:11:37,120 --> 01:11:42,250
and for example here till and what is

01:11:40,210 --> 01:11:44,470
still well it actually till is

01:11:42,250 --> 01:11:48,280
everything that remains that i didn't

01:11:44,470 --> 01:11:51,090
need so i processed this stuff here

01:11:48,280 --> 01:11:53,040
until there but this

01:11:51,090 --> 01:11:55,890
this piece actually this piece here is

01:11:53,040 --> 01:11:59,670
not needed actually it's meant for the

01:11:55,890 --> 01:12:02,040
next Galu team so I want to push it back

01:11:59,670 --> 01:12:03,720
to give it back to the input stream

01:12:02,040 --> 01:12:06,150
because it's not for me it's for the

01:12:03,720 --> 01:12:10,770
next generator that's how that's what I

01:12:06,150 --> 01:12:12,810
did by allowing her to have allowing

01:12:10,770 --> 01:12:15,660
stop iteration to have additional

01:12:12,810 --> 01:12:17,400
parameters and technically speaking it's

01:12:15,660 --> 01:12:19,950
very interesting because this request

01:12:17,400 --> 01:12:22,230
and the till and there might be three

01:12:19,950 --> 01:12:25,110
four or five things to push back it's

01:12:22,230 --> 01:12:28,620
all pushed back into a message queue so

01:12:25,110 --> 01:12:30,390
composed contains a message queue and if

01:12:28,620 --> 01:12:32,460
you return something then request this

01:12:30,390 --> 01:12:34,430
boost onto the message queue until this

01:12:32,460 --> 01:12:37,380
is pushed onto the message queue and

01:12:34,430 --> 01:12:38,910
then compose continues by eating this

01:12:37,380 --> 01:12:40,560
message queue and sending it to the

01:12:38,910 --> 01:12:47,640
generator that's on top of the generator

01:12:40,560 --> 01:12:49,590
stack so this will be sent to the one

01:12:47,640 --> 01:12:51,000
who gets the return value so that will

01:12:49,590 --> 01:12:54,330
be yielded that's the first thing in the

01:12:51,000 --> 01:13:00,770
caller the neck this will be yielded

01:12:54,330 --> 01:13:03,240
next what you can do with that over this

01:13:00,770 --> 01:13:05,420
if you do a complete example I think

01:13:03,240 --> 01:13:05,420
that's

01:13:15,340 --> 01:13:19,860
oh sorry i had a complete example

01:13:17,199 --> 01:13:19,860
somewhere here

01:13:26,940 --> 01:13:34,949
just here's the SD complete protocol I

01:13:31,880 --> 01:13:38,310
have to plot polka dots way protocol to

01:13:34,949 --> 01:13:40,380
hear the parameter handle requests and

01:13:38,310 --> 01:13:42,870
this protocol will be actually dealing

01:13:40,380 --> 01:13:45,780
with the HTTP protocol and whenever it

01:13:42,870 --> 01:13:47,670
has a request ready it will delegate to

01:13:45,780 --> 01:13:51,000
handle requests and the request is

01:13:47,670 --> 01:13:55,020
appear an angle requests just expects

01:13:51,000 --> 01:13:56,760
the body and nothing else so the request

01:13:55,020 --> 01:13:59,219
line and the headers already have been

01:13:56,760 --> 01:14:01,530
eaten now what I'm doing here

01:13:59,219 --> 01:14:04,320
deliberately is sending these weird

01:14:01,530 --> 01:14:06,840
messages again like first this half step

01:14:04,320 --> 01:14:09,120
status line is the rest of the status

01:14:06,840 --> 01:14:11,340
line then there is part of the HTTP

01:14:09,120 --> 01:14:12,900
headers here and then in the same

01:14:11,340 --> 01:14:15,449
message there's part of the form data

01:14:12,900 --> 01:14:17,580
and this form data is the only thing you

01:14:15,449 --> 01:14:21,239
want to show up here and handle requests

01:14:17,580 --> 01:14:23,670
and all the other stuff that will be

01:14:21,239 --> 01:14:30,060
dealt with with other generators and I

01:14:23,670 --> 01:14:35,280
have these ribbon here's the HTTP

01:14:30,060 --> 01:14:38,219
protocol this handler of this HTTP

01:14:35,280 --> 01:14:39,870
protocol and just as well first read

01:14:38,219 --> 01:14:41,250
request you pre the request that gives

01:14:39,870 --> 01:14:44,070
me two answers the request and the

01:14:41,250 --> 01:14:47,760
headers and then a call handler with

01:14:44,070 --> 01:14:49,800
requests and headers now if you look at

01:14:47,760 --> 01:14:52,949
read request is below where it says well

01:14:49,800 --> 01:14:55,800
first read request line and then retweet

01:14:52,949 --> 01:14:59,370
and then read the headers and return

01:14:55,800 --> 01:15:00,930
them both going back here you have these

01:14:59,370 --> 01:15:02,630
two answers then you call the end the

01:15:00,930 --> 01:15:06,330
handler if the request and the headers

01:15:02,630 --> 01:15:09,390
the only thing is that this one will

01:15:06,330 --> 01:15:12,060
only be reading the status line will be

01:15:09,390 --> 01:15:13,440
having too much data because parts of

01:15:12,060 --> 01:15:16,830
the headers were already in this message

01:15:13,440 --> 01:15:19,830
so it pushes these back onto onto the

01:15:16,830 --> 01:15:22,410
the message stack then this message deck

01:15:19,830 --> 01:15:25,650
is there and then this next line is

01:15:22,410 --> 01:15:28,590
executed and red hatters retailers is

01:15:25,650 --> 01:15:30,630
then executing and retailers will first

01:15:28,590 --> 01:15:32,489
get this little piece that's still on

01:15:30,630 --> 01:15:34,830
the message stack because that belongs

01:15:32,489 --> 01:15:36,960
to the headers and then it reads on and

01:15:34,830 --> 01:15:38,550
then it guess then read headers get next

01:15:36,960 --> 01:15:40,710
of the headers but in the last message

01:15:38,550 --> 01:15:42,719
it will get parson parts of

01:15:40,710 --> 01:15:48,390
the body where the body is not meant for

01:15:42,719 --> 01:15:50,310
it so that's the same problem it so it

01:15:48,390 --> 01:15:55,050
pushes back onto the message take again

01:15:50,310 --> 01:15:56,760
and then this thing is terminating this

01:15:55,050 --> 01:15:59,340
ring is terminating and then it yields

01:15:56,760 --> 01:16:01,140
handler and handler will get first is

01:15:59,340 --> 01:16:09,780
last piece of the mark of the message

01:16:01,140 --> 01:16:15,120
body then reach the rest of the form

01:16:09,780 --> 01:16:19,620
data and I think I have one minute left

01:16:15,120 --> 01:16:25,920
or so I have to stop okay and then I'll

01:16:19,620 --> 01:16:27,660
find the last slide I'm missing one

01:16:25,920 --> 01:16:29,580
topic here that's about something

01:16:27,660 --> 01:16:31,200
threadlocal even after there's something

01:16:29,580 --> 01:16:32,460
like generator local or something like

01:16:31,200 --> 01:16:37,590
that because you're doing lightweight

01:16:32,460 --> 01:16:41,360
reading keeping that and then this is

01:16:37,590 --> 01:16:44,390
this is the topic saya for discussion

01:16:41,360 --> 01:16:46,440
first of these back traces are these

01:16:44,390 --> 01:16:51,570
artists really necessary and should we

01:16:46,440 --> 01:16:54,210
be should they be in in pep 380 or maybe

01:16:51,570 --> 01:16:56,489
they are already there I don't know then

01:16:54,210 --> 01:16:58,200
there is something like flow control it

01:16:56,489 --> 01:17:01,350
really really drives you crazy if you

01:16:58,200 --> 01:17:03,450
don't have that I think it should be in

01:17:01,350 --> 01:17:06,570
depth 380 somehow I don't know how but I

01:17:03,450 --> 01:17:09,120
think it would be very useful to have

01:17:06,570 --> 01:17:14,790
something like that then there's look

01:17:09,120 --> 01:17:16,920
ahead and push back you don't have this

01:17:14,790 --> 01:17:18,780
mechanism then it comes very hard to

01:17:16,920 --> 01:17:22,739
make these programs 50 generators

01:17:18,780 --> 01:17:26,900
dealing if if Tom do Luke ahead if you

01:17:22,739 --> 01:17:30,150
can't do don't push back any data then

01:17:26,900 --> 01:17:33,239
you cannot process any stream of data

01:17:30,150 --> 01:17:34,860
because you always have to do that and

01:17:33,239 --> 01:17:38,460
the last thing is why I've already said

01:17:34,860 --> 01:17:41,390
that it was missing out of time about

01:17:38,460 --> 01:17:41,390
this generator logos

01:17:45,070 --> 01:17:54,040
no I've question what do you think of it

01:17:56,260 --> 01:18:02,630
by then you think the middle of your

01:18:00,620 --> 01:18:04,640
talk seemed to be about how to sort of

01:18:02,630 --> 01:18:06,890
massage these generators into

01:18:04,640 --> 01:18:09,350
essentially kuru teens why not just use

01:18:06,890 --> 01:18:13,130
a coyote joe's tactless or green 'let's

01:18:09,350 --> 01:18:15,260
it because the only way to do decent co

01:18:13,130 --> 01:18:16,760
routines requires you to switch to

01:18:15,260 --> 01:18:18,620
different for um a different language

01:18:16,760 --> 01:18:21,320
you have to have different language

01:18:18,620 --> 01:18:23,030
features for that you can do it with it

01:18:21,320 --> 01:18:24,800
of course but this is this is something

01:18:23,030 --> 01:18:35,510
you can do with the normal see part of

01:18:24,800 --> 01:18:40,370
vm ok for example well what is i know

01:18:35,510 --> 01:18:43,700
that it is somehow the future but there

01:18:40,370 --> 01:18:48,260
are solutions liking that flow where you

01:18:43,700 --> 01:18:51,260
can have output on input ports on

01:18:48,260 --> 01:18:53,870
generators why not use that for co

01:18:51,260 --> 01:18:56,900
routines for example because i'm not

01:18:53,870 --> 01:19:06,170
aware of it you are mentioning it ok ok

01:18:56,900 --> 01:19:16,130
yeah could you show you code example

01:19:06,170 --> 01:19:17,420
number 11 and remind me was as i recall

01:19:16,130 --> 01:19:20,590
you there's something you don't like

01:19:17,420 --> 01:19:30,970
about it yeah and you can you remind us

01:19:20,590 --> 01:19:33,230
sure well if you look back ow jection

01:19:30,970 --> 01:19:37,610
assumed generators or assumed go

01:19:33,230 --> 01:19:39,650
routines to to work and behave then he's

01:19:37,610 --> 01:19:41,600
really having this this actor model in

01:19:39,650 --> 01:19:43,730
mind so there's there's two coatings and

01:19:41,600 --> 01:19:45,590
they're basically both of them are

01:19:43,730 --> 01:19:47,390
running like processes or something like

01:19:45,590 --> 01:19:50,060
that and then there are exchanging

01:19:47,390 --> 01:19:51,320
messages by calling each other and there

01:19:50,060 --> 01:19:53,210
are not processes in the sense that

01:19:51,320 --> 01:19:56,510
there are threats but they are they are

01:19:53,210 --> 01:19:58,400
giving each other turns to run and if

01:19:56,510 --> 01:20:00,380
you would have that model and you would

01:19:58,400 --> 01:20:02,570
and you would like to implement that in

01:20:00,380 --> 01:20:04,880
in Python in playing Python like like C

01:20:02,570 --> 01:20:06,560
Python ish then you would have to do

01:20:04,880 --> 01:20:09,909
something like this because you have

01:20:06,560 --> 01:20:12,830
these two co routines and one coating

01:20:09,909 --> 01:20:19,670
coating be here is call encoding a

01:20:12,830 --> 01:20:21,050
protein a here is Colin coyote be so

01:20:19,670 --> 01:20:23,050
they're basically exchanging messages

01:20:21,050 --> 01:20:29,810
and what they do where they count to 10

01:20:23,050 --> 01:20:33,500
together but I don't like is the dis dis

01:20:29,810 --> 01:20:35,600
syntax here what it actually says and

01:20:33,500 --> 01:20:38,179
this is also what what normally encode

01:20:35,600 --> 01:20:46,699
things would would happen is i want to

01:20:38,179 --> 01:20:48,830
call oracle team this parameter that's

01:20:46,699 --> 01:20:52,219
actually what you want but that's not

01:20:48,830 --> 01:20:55,520
possible so the only way to make it

01:20:52,219 --> 01:20:58,850
possible is to to yield something to a

01:20:55,520 --> 01:21:00,590
super super thing i call that a

01:20:58,850 --> 01:21:03,020
trampoline shall you yield back to a

01:21:00,590 --> 01:21:05,300
trampoline and is trampling reach these

01:21:03,020 --> 01:21:08,210
parameters and makes it into this

01:21:05,300 --> 01:21:13,989
function call actually not this function

01:21:08,210 --> 01:21:18,890
call with it it sends this 2x generator

01:21:13,989 --> 01:21:22,969
and this is a thing doing these kinds of

01:21:18,890 --> 01:21:25,400
things exactly what is this program are

01:21:22,969 --> 01:21:27,699
outside of the box outside of the

01:21:25,400 --> 01:21:29,840
virtual machine what drives him crazy

01:21:27,699 --> 01:21:34,550
you don't want to do this you want to

01:21:29,840 --> 01:21:36,199
have a neat syntax and just say well if

01:21:34,550 --> 01:21:38,929
I want to do something like this then I

01:21:36,199 --> 01:21:44,449
would be able to oh and this is actually

01:21:38,929 --> 01:21:45,980
what composes about this and even some

01:21:44,449 --> 01:21:48,890
people argue that it would be nice to

01:21:45,980 --> 01:21:50,989
leave how do you yield keyword that's

01:21:48,890 --> 01:21:54,650
that's certainly true but I come deficit

01:21:50,989 --> 01:21:57,620
leave if the u.p word that's your

01:21:54,650 --> 01:22:00,650
problem if you have languages like

01:21:57,620 --> 01:22:04,239
sticklers and other alternatives and you

01:22:00,650 --> 01:22:04,239
can even leave out the u.p word

01:22:06,139 --> 01:22:10,939
looking at the code it seems to me that

01:22:08,419 --> 01:22:13,099
a and B should be parameters to co

01:22:10,939 --> 01:22:16,249
routine a & Co routine be because at the

01:22:13,099 --> 01:22:18,889
moment it's a very hard coded yeah okay

01:22:16,249 --> 01:22:22,340
sure but that's just for the example

01:22:18,889 --> 01:22:24,260
yeah yeah but your objection is that

01:22:22,340 --> 01:22:26,989
you've got an awkward function call is

01:22:24,260 --> 01:22:28,699
that you really like the syntax to be

01:22:26,989 --> 01:22:30,979
able to use the syntax of a function

01:22:28,699 --> 01:22:34,099
call there is not the point yeah I'd

01:22:30,979 --> 01:22:36,169
like to make it the life of a programmer

01:22:34,099 --> 01:22:39,499
that is not inside this virtual machine

01:22:36,169 --> 01:22:41,659
box a little bit easier I I think I'm

01:22:39,499 --> 01:22:43,849
not doing that if I just proposed to

01:22:41,659 --> 01:22:47,599
this programmer well I'll use this

01:22:43,849 --> 01:22:49,329
syntax here okay I understand what

01:22:47,599 --> 01:22:52,719
you're saying I may not agree with it

01:22:49,329 --> 01:22:52,719
thanks for explaining

01:23:00,030 --> 01:23:05,420
next what one

01:23:12,430 --> 01:23:19,840
actually encouraging beam when you

01:23:15,490 --> 01:23:22,150
yelled occur it in a are this statement

01:23:19,840 --> 01:23:25,570
is actually not instant fitting the

01:23:22,150 --> 01:23:28,450
iterator but only calling next so

01:23:25,570 --> 01:23:30,580
actually now that's that's the that's

01:23:28,450 --> 01:23:33,550
that's actually the point it is

01:23:30,580 --> 01:23:38,230
instantiating the Detroit origin this

01:23:33,550 --> 01:23:41,140
call here actually instantiate the

01:23:38,230 --> 01:23:44,710
routine here so whenever this loop is is

01:23:41,140 --> 01:23:48,090
is executing it creates a new completely

01:23:44,710 --> 01:23:51,490
new version of quality colluding a

01:23:48,090 --> 01:23:54,480
that's exactly the difference with the

01:23:51,490 --> 01:23:58,090
previous one there are the kalu teen a

01:23:54,480 --> 01:23:59,620
dist and keeps on existing between calls

01:23:58,090 --> 01:24:03,790
and here you create a new one all the

01:23:59,620 --> 01:24:08,020
time though and if code in a is have

01:24:03,790 --> 01:24:11,290
multiple yelda statement inside what's

01:24:08,020 --> 01:24:14,920
going to happen is that we only go run

01:24:11,290 --> 01:24:17,320
out at two up to the first one and we

01:24:14,920 --> 01:24:21,070
delay aboard to the rest of the

01:24:17,320 --> 01:24:23,950
computation no it just runs to

01:24:21,070 --> 01:24:26,730
completion that's the other choice when

01:24:23,950 --> 01:24:30,760
you do this these other co routine

01:24:26,730 --> 01:24:32,830
protein ie runs to completion always so

01:24:30,760 --> 01:24:35,320
it's basically a very limited way of a

01:24:32,830 --> 01:24:39,150
couple teen it's it's it's heart maybe

01:24:35,320 --> 01:24:42,400
it's hardly no cuddling anymore does it

01:24:39,150 --> 01:24:44,230
and you do this Kyle routine a will be

01:24:42,400 --> 01:24:46,390
instantiated it will it will run until

01:24:44,230 --> 01:24:51,930
completion so the oldest complete stuff

01:24:46,390 --> 01:24:54,940
here and then program continue their a

01:24:51,930 --> 01:25:02,740
very limited way of dealing with the

01:24:54,940 --> 01:25:05,800
other co routine that the ID the point

01:25:02,740 --> 01:25:08,200
is here that I had try to make clear

01:25:05,800 --> 01:25:10,000
that this is just as powerful as as to

01:25:08,200 --> 01:25:12,760
having the 22 cal routines depart

01:25:10,000 --> 01:25:18,280
because you really can be you create

01:25:12,760 --> 01:25:21,520
huge applications with this it feels

01:25:18,280 --> 01:25:23,080
natural it's just like programming the

01:25:21,520 --> 01:25:25,710
function here like equal you extract

01:25:23,080 --> 01:25:27,660
something you put it in a new cutting

01:25:25,710 --> 01:25:30,780
and it just behaves like you would

01:25:27,660 --> 01:25:33,060
expect it's just the actor in principle

01:25:30,780 --> 01:25:37,020
that is at work here and that's what I

01:25:33,060 --> 01:25:39,300
wanted to have I've realized to have a

01:25:37,020 --> 01:25:41,280
situation in which you can just say well

01:25:39,300 --> 01:25:42,750
have this big coating refactor it into

01:25:41,280 --> 01:25:44,370
three small ones and these three four

01:25:42,750 --> 01:25:47,489
months I deganwy factor than the writer

01:25:44,370 --> 01:25:50,040
or with ten layers of co routines

01:25:47,489 --> 01:25:54,560
calling each other and it must be work

01:25:50,040 --> 01:25:54,560
it must work very natural to work to him

01:25:57,620 --> 01:26:02,060
though let's find Carrie

01:26:08,980 --> 01:26:11,040

YouTube URL: https://www.youtube.com/watch?v=yWR00Y6tkC8


