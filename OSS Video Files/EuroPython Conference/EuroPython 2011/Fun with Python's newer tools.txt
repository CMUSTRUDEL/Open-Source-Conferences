Title: Fun with Python's newer tools
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Raymond Hettinger - 23 June 2011 in "Track Spaghetti"
Captions: 
	00:00:10,549 --> 00:00:16,830
thank you very much leave a dirty

00:00:12,860 --> 00:00:26,310
alright who's currently running at work

00:00:16,830 --> 00:00:29,070
on Python 2 5 6 7 oh there's some

00:00:26,310 --> 00:00:30,930
overlap okay so 2 7 is a fine thing I

00:00:29,070 --> 00:00:33,210
would I am encouraging everyone to

00:00:30,930 --> 00:00:34,890
migrate 2 to 7 as fast as possible you

00:00:33,210 --> 00:00:37,410
know how Ubuntu has this notion of a

00:00:34,890 --> 00:00:39,600
long-term maintenance release one that

00:00:37,410 --> 00:00:42,270
they're going to maintain for years 2.7

00:00:39,600 --> 00:00:44,489
is going to be ours 2.6 it's not getting

00:00:42,270 --> 00:00:45,540
any bug fixes it's not getting any

00:00:44,489 --> 00:00:47,850
attention at all

00:00:45,540 --> 00:00:50,670
very quickly the compiler community is

00:00:47,850 --> 00:00:52,590
converging on to 7 Wesley told us this

00:00:50,670 --> 00:00:56,100
morning that Google App Engine will soon

00:00:52,590 --> 00:00:58,140
support Python to 7 and so it's where I

00:00:56,100 --> 00:00:59,820
recommend you ought to be and where you

00:00:58,140 --> 00:01:01,590
can get so that you can play with

00:00:59,820 --> 00:01:03,930
pythons newer tools I'll leave you to

00:01:01,590 --> 00:01:04,860
show you some that are in 3 2 and if we

00:01:03,930 --> 00:01:06,420
have a little time I'll show you

00:01:04,860 --> 00:01:09,630
something that's in 3 3 3

00:01:06,420 --> 00:01:11,490
who's running Python 3 3 all right just

00:01:09,630 --> 00:01:13,890
a couple of you we actually have a link

00:01:11,490 --> 00:01:16,110
for a daily build and so you can pull

00:01:13,890 --> 00:01:17,369
down and be running with 3 3 every day

00:01:16,110 --> 00:01:20,580
if you like if you'd like to live on the

00:01:17,369 --> 00:01:22,890
the bleeding edge so what if you're not

00:01:20,580 --> 00:01:26,220
using Python 33 at work can you get the

00:01:22,890 --> 00:01:27,570
newer tools and the answer is yes most

00:01:26,220 --> 00:01:29,670
of the things that I'm putting into

00:01:27,570 --> 00:01:31,560
Python in the last few years I go and I

00:01:29,670 --> 00:01:33,450
put an equivalent recipe that runs on

00:01:31,560 --> 00:01:35,010
older versions of Python so if you'd

00:01:33,450 --> 00:01:37,409
like to have an order dictionary and

00:01:35,010 --> 00:01:39,540
you're running Python 2 5 you can go out

00:01:37,409 --> 00:01:41,970
to the Python cookbook pull down that

00:01:39,540 --> 00:01:43,830
recipe and it will I've designed them to

00:01:41,970 --> 00:01:46,560
where they are compliant with they pass

00:01:43,830 --> 00:01:48,810
all of the tests in the later pythons so

00:01:46,560 --> 00:01:50,520
if you'd like to have an LRU cache and

00:01:48,810 --> 00:01:52,830
you don't have one if you'd like to have

00:01:50,520 --> 00:01:55,049
a counter and you don't have one go into

00:01:52,830 --> 00:01:58,170
the docs for the newer version of Python

00:01:55,049 --> 00:02:00,240
there will be a link to the code that

00:01:58,170 --> 00:02:01,740
runs on old pythons so you can be

00:02:00,240 --> 00:02:04,530
running on our new Python even though

00:02:01,740 --> 00:02:04,890
you have an old one got the gist all

00:02:04,530 --> 00:02:09,329
right

00:02:04,890 --> 00:02:10,830
all of these tools can be yours ok it is

00:02:09,329 --> 00:02:12,780
my aspiration to use Twitter for

00:02:10,830 --> 00:02:14,580
something good other than telling people

00:02:12,780 --> 00:02:15,040
where I'm currently standing at the

00:02:14,580 --> 00:02:17,739
moment

00:02:15,040 --> 00:02:19,810
I'm talking to so if you subscribe to my

00:02:17,739 --> 00:02:22,719
Twitter feed I promise not to spam you

00:02:19,810 --> 00:02:24,640
and instead I am trying to at least once

00:02:22,719 --> 00:02:27,640
a day sometimes two or three times a day

00:02:24,640 --> 00:02:30,250
tweet out Python tips as much as can be

00:02:27,640 --> 00:02:33,549
fit into 140 characters it seems to be

00:02:30,250 --> 00:02:36,430
reasonably popular so anyway

00:02:33,549 --> 00:02:41,950
new Python tips ready to get the show

00:02:36,430 --> 00:02:44,829
rolling alright collections counter so

00:02:41,950 --> 00:02:47,230
collections counter was modeled at the

00:02:44,829 --> 00:02:48,879
way some of this design process works is

00:02:47,230 --> 00:02:50,970
the idea of something that's going to be

00:02:48,879 --> 00:02:54,340
generically useful enough to be

00:02:50,970 --> 00:02:55,989
collections in collections is probably

00:02:54,340 --> 00:02:59,829
some technology has been invented before

00:02:55,989 --> 00:03:01,989
and so the API design starts with taking

00:02:59,829 --> 00:03:04,090
a look at what has been done for the

00:03:01,989 --> 00:03:06,760
previous technology so look at multi

00:03:04,090 --> 00:03:10,090
sets in C++ bags in small talk and

00:03:06,760 --> 00:03:11,950
Objective C and a decision was made

00:03:10,090 --> 00:03:13,720
early on to not completely encapsulate

00:03:11,950 --> 00:03:15,189
this and lock it up and guarantee that

00:03:13,720 --> 00:03:17,109
you can only do increments and

00:03:15,189 --> 00:03:19,359
decrements we left it wide open what

00:03:17,109 --> 00:03:21,459
does that mean we subclass dick so what

00:03:19,359 --> 00:03:23,530
is a counter a counter is simply a

00:03:21,459 --> 00:03:27,069
dictionary that has this extra

00:03:23,530 --> 00:03:30,849
capability that you can that it note has

00:03:27,069 --> 00:03:32,500
a default value of zero so if you look

00:03:30,849 --> 00:03:34,060
up something in this dictionary and it's

00:03:32,500 --> 00:03:36,370
missing from the dictionary it will

00:03:34,060 --> 00:03:38,379
return a count of zero so what can you

00:03:36,370 --> 00:03:41,470
store in the counter you can store

00:03:38,379 --> 00:03:43,090
anything because it's a dictionary so

00:03:41,470 --> 00:03:44,470
you can put junk in your counter and use

00:03:43,090 --> 00:03:48,250
it for things other than counting you

00:03:44,470 --> 00:03:50,139
can also count with integers including

00:03:48,250 --> 00:03:52,239
negative numbers if negative numbers

00:03:50,139 --> 00:03:53,979
make sense in your application you can

00:03:52,239 --> 00:03:56,970
count with decimals you can count with

00:03:53,979 --> 00:04:00,879
fractions it's just a dictionary quick

00:03:56,970 --> 00:04:04,419
what can you put in it anything because

00:04:00,879 --> 00:04:06,129
it's just as an action area okay good

00:04:04,419 --> 00:04:08,290
enough it's amazing how many discussions

00:04:06,129 --> 00:04:10,680
I have around counters look can I put it

00:04:08,290 --> 00:04:10,680
yes

00:04:11,920 --> 00:04:17,359
so it's a simple design

00:04:14,300 --> 00:04:20,660
it started out close to being a two

00:04:17,359 --> 00:04:24,320
liner in python class counter inherits

00:04:20,660 --> 00:04:27,530
from dick fine under under missing

00:04:24,320 --> 00:04:29,960
return zero that was the beginning and

00:04:27,530 --> 00:04:33,200
at that point you already have a usable

00:04:29,960 --> 00:04:35,090
counter it's easy to use it has an under

00:04:33,200 --> 00:04:36,800
under missing method that returns zero

00:04:35,090 --> 00:04:40,520
who knew about the end Reuter missing

00:04:36,800 --> 00:04:42,290
method I'm impressed because a shocking

00:04:40,520 --> 00:04:44,270
number of people who have been using

00:04:42,290 --> 00:04:45,740
Python for years read the docs and well

00:04:44,270 --> 00:04:48,050
now have no idea that there's an under

00:04:45,740 --> 00:04:50,240
under missing that's a method for

00:04:48,050 --> 00:04:52,490
dictionaries and it's a fantastically

00:04:50,240 --> 00:04:54,650
capable tool there's a lot of things you

00:04:52,490 --> 00:04:55,790
can do with it and if you haven't used

00:04:54,650 --> 00:04:58,190
it before I recommend that you play

00:04:55,790 --> 00:05:00,680
around with it a little bit it is part

00:04:58,190 --> 00:05:02,330
of our core dictionary API now and so

00:05:00,680 --> 00:05:05,210
lots of objects will support under under

00:05:02,330 --> 00:05:07,460
missing like if you subclass and ordered

00:05:05,210 --> 00:05:11,300
dictionary it'll support under under

00:05:07,460 --> 00:05:13,280
missing alright and then I went one step

00:05:11,300 --> 00:05:15,050
further and said well if we look up an

00:05:13,280 --> 00:05:17,240
item in a dictionary and it says that

00:05:15,050 --> 00:05:18,890
it's a default value is zero you know

00:05:17,240 --> 00:05:21,290
what is the count of the number of

00:05:18,890 --> 00:05:23,900
Ramon's in the counter and the count is

00:05:21,290 --> 00:05:26,060
zero well I'd like to be able to if the

00:05:23,900 --> 00:05:27,710
get succeeds I'd like to have a Adel

00:05:26,060 --> 00:05:30,950
succeed so we built it out a little bit

00:05:27,710 --> 00:05:32,539
so that it's easy to delete so you can

00:05:30,950 --> 00:05:34,430
write lines like this to do a tally to

00:05:32,539 --> 00:05:35,570
increment the counter and lines like

00:05:34,430 --> 00:05:37,400
this to delete something out of the

00:05:35,570 --> 00:05:39,080
counter whether something is already in

00:05:37,400 --> 00:05:41,300
there or not you don't have to take care

00:05:39,080 --> 00:05:43,760
of putting a value of zero so this will

00:05:41,300 --> 00:05:44,690
never raise Kiera and that will never

00:05:43,760 --> 00:05:48,229
raise Kiera

00:05:44,690 --> 00:05:51,530
that gives it a clean API seems simple

00:05:48,229 --> 00:05:53,750
enough let's push the design a little

00:05:51,530 --> 00:05:55,310
bit further and let's show you how it's

00:05:53,750 --> 00:05:58,220
made so if you're going to make your own

00:05:55,310 --> 00:05:59,840
you would make a class counter so

00:05:58,220 --> 00:06:02,180
plastic add a missing method that

00:05:59,840 --> 00:06:04,220
returns zero so anytime someone does a

00:06:02,180 --> 00:06:08,110
lookup into this dictionary if an item

00:06:04,220 --> 00:06:12,140
is missing it is called and returns zero

00:06:08,110 --> 00:06:13,640
and then del items uh matches it just

00:06:12,140 --> 00:06:16,400
checks to see if the elements in the

00:06:13,640 --> 00:06:18,950
dictionary it'll delete it if it's not

00:06:16,400 --> 00:06:20,840
in the dictionary it's already gone hey

00:06:18,950 --> 00:06:23,270
this is kind of cool we use super here

00:06:20,840 --> 00:06:25,450
it's like good for anything we'll see

00:06:23,270 --> 00:06:27,940
shortly

00:06:25,450 --> 00:06:30,890
things like this had fantastic

00:06:27,940 --> 00:06:33,820
superpowers to counter this read the

00:06:30,890 --> 00:06:37,400
super are considered super blog post Oh

00:06:33,820 --> 00:06:38,960
some of you have missed out this I heard

00:06:37,400 --> 00:06:42,020
of the super considered harmful blog

00:06:38,960 --> 00:06:44,030
post everybody those of you who've been

00:06:42,020 --> 00:06:45,950
lied to you think you've been told this

00:06:44,030 --> 00:06:47,690
tools off-limits that it's no good that

00:06:45,950 --> 00:06:49,640
it's not good for anything you don't

00:06:47,690 --> 00:06:51,710
know that it has superpowers I recommend

00:06:49,640 --> 00:06:54,530
the super considered super blog post

00:06:51,710 --> 00:06:58,010
it is a clear set of instructions on how

00:06:54,530 --> 00:06:58,460
to use super in a way that works every

00:06:58,010 --> 00:07:01,730
time

00:06:58,460 --> 00:07:05,990
and is really hard to emulate using any

00:07:01,730 --> 00:07:07,550
other programming technique so I'll stop

00:07:05,990 --> 00:07:09,260
promising the future and back to the

00:07:07,550 --> 00:07:12,170
present so here's how you instantiate a

00:07:09,260 --> 00:07:14,420
counter I can add I can count my exes

00:07:12,170 --> 00:07:17,000
and add one to it that's the normal

00:07:14,420 --> 00:07:18,230
usage I can count why and add to it to

00:07:17,000 --> 00:07:21,590
it so you don't have to count one at a

00:07:18,230 --> 00:07:23,090
time or I can set a value which is kind

00:07:21,590 --> 00:07:24,890
of nice if I had attempted to build some

00:07:23,090 --> 00:07:26,990
bag class where I over wrote every

00:07:24,890 --> 00:07:28,400
access err it's easy to leave one of

00:07:26,990 --> 00:07:30,920
these outside you know people can only

00:07:28,400 --> 00:07:33,080
count one at a time so you can set

00:07:30,920 --> 00:07:34,580
values here so the output of that looks

00:07:33,080 --> 00:07:35,750
very much like addiction regular

00:07:34,580 --> 00:07:38,900
dictionary why does it look like a

00:07:35,750 --> 00:07:43,330
regular dictionary because it is alright

00:07:38,900 --> 00:07:45,920
what happens if I do Adele W here no

00:07:43,330 --> 00:07:49,610
because we have the addictive simple

00:07:45,920 --> 00:07:51,170
design you happy encounter so far but we

00:07:49,610 --> 00:07:53,810
have called ourself our design done

00:07:51,170 --> 00:07:55,190
absolutely but maybe it needs some

00:07:53,810 --> 00:07:58,300
convenience methods because we think

00:07:55,190 --> 00:08:00,890
about what do people do with counters

00:07:58,300 --> 00:08:06,860
that was not an excellent segue was it

00:08:00,890 --> 00:08:08,510
Oh an example abusing a counter let's

00:08:06,860 --> 00:08:11,210
say you have a results counter you loop

00:08:08,510 --> 00:08:15,860
over your test if it if the test passes

00:08:11,210 --> 00:08:17,750
add one two succeeded in either case add

00:08:15,860 --> 00:08:19,820
one to attempt it so it's a very simple

00:08:17,750 --> 00:08:22,820
use of counter it's a much cleaner

00:08:19,820 --> 00:08:24,350
looking code than the old cell using yet

00:08:22,820 --> 00:08:26,330
or having to build yourself a custom

00:08:24,350 --> 00:08:28,850
dick with under missing are using a

00:08:26,330 --> 00:08:31,700
default dictionary default dictionaries

00:08:28,850 --> 00:08:33,229
are very easy to use but somehow it

00:08:31,700 --> 00:08:34,870
gives people mental conniptions as if

00:08:33,229 --> 00:08:37,070
they're using something really advanced

00:08:34,870 --> 00:08:38,530
default dick that's that's way more

00:08:37,070 --> 00:08:41,180
advanced than lamb

00:08:38,530 --> 00:08:43,070
and I think the problem is the factory

00:08:41,180 --> 00:08:44,750
functions for some reason find people

00:08:43,070 --> 00:08:46,640
free and find it to be mind-blowing but

00:08:44,750 --> 00:08:48,500
what I like about this code is I can

00:08:46,640 --> 00:08:50,330
show it to a non programmer manager

00:08:48,500 --> 00:08:51,890
client what not and it's very clear to

00:08:50,330 --> 00:08:54,410
them that it does exactly what it says

00:08:51,890 --> 00:08:56,690
and that's the kind of Python we strive

00:08:54,410 --> 00:08:58,670
for is the kind that matches the

00:08:56,690 --> 00:08:59,840
business description of the problem all

00:08:58,670 --> 00:09:02,360
right

00:08:59,840 --> 00:09:04,910
oh another example of using counter

00:09:02,360 --> 00:09:07,730
before I get to the extra features so

00:09:04,910 --> 00:09:10,070
open some text the example I put in the

00:09:07,730 --> 00:09:14,980
docs was actually open Hamlet text so I

00:09:10,070 --> 00:09:14,980
had full text of Hamlet opened it

00:09:15,280 --> 00:09:21,830
lowercase it split it use words to split

00:09:19,610 --> 00:09:24,560
up all of the words in Hamlet get rid of

00:09:21,830 --> 00:09:27,890
the punctuation and feed that directly

00:09:24,560 --> 00:09:29,090
into counter Oh cut this extra method

00:09:27,890 --> 00:09:31,130
over here because a very common use of

00:09:29,090 --> 00:09:32,540
counter is well you've counted things

00:09:31,130 --> 00:09:33,980
what do you do with the count well I'd

00:09:32,540 --> 00:09:36,470
like to know what the biggest counts are

00:09:33,980 --> 00:09:39,860
so what this says right here is take all

00:09:36,470 --> 00:09:43,160
of these words count them up give me the

00:09:39,860 --> 00:09:46,280
50 most common sorted most common two

00:09:43,160 --> 00:09:48,620
least common so it's fantastic for word

00:09:46,280 --> 00:09:51,590
counts I could have fed in all of the

00:09:48,620 --> 00:09:54,320
URLs out of my log so I do a quick scan

00:09:51,590 --> 00:09:55,130
of the resources being requested out of

00:09:54,320 --> 00:09:57,380
all of my logs

00:09:55,130 --> 00:09:59,120
take that iterator drop it right here

00:09:57,380 --> 00:10:00,620
where it said words and what is this

00:09:59,120 --> 00:10:03,590
line of code Nell do it doesn't do a

00:10:00,620 --> 00:10:06,050
word count tells me the top 50 hits on

00:10:03,590 --> 00:10:07,490
my website the most popular resources it

00:10:06,050 --> 00:10:11,450
thinks that's fantastic something they

00:10:07,490 --> 00:10:13,130
can use every day a couple of use not

00:10:11,450 --> 00:10:15,860
that comma you want extra features don't

00:10:13,130 --> 00:10:18,050
you convenience method so I added our

00:10:15,860 --> 00:10:20,150
most common it returns a sorted list of

00:10:18,050 --> 00:10:22,880
the in highest counts and they say give

00:10:20,150 --> 00:10:25,130
me the top 50 top 10 are fused to final

00:10:22,880 --> 00:10:28,720
argument it will just sort them all so

00:10:25,130 --> 00:10:31,070
it reduces to a simple one-liner

00:10:28,720 --> 00:10:33,890
something that matches the English

00:10:31,070 --> 00:10:37,070
description give me the 50 most common

00:10:33,890 --> 00:10:38,540
words 15 most common URLs that sort of

00:10:37,070 --> 00:10:41,150
thing that way we have a very clear

00:10:38,540 --> 00:10:42,980
correspondence between a single simple

00:10:41,150 --> 00:10:48,740
English declaration of a problem task

00:10:42,980 --> 00:10:50,750
and the actual nice correspondence now

00:10:48,740 --> 00:10:51,870
elements those of you who've used bags

00:10:50,750 --> 00:10:53,790
before another line

00:10:51,870 --> 00:10:56,100
which knows the way that they works is

00:10:53,790 --> 00:10:57,450
by put something in the bag put another

00:10:56,100 --> 00:10:58,830
thing in the bag put another thing in

00:10:57,450 --> 00:11:01,380
the bag I should be able to pull those

00:10:58,830 --> 00:11:03,390
things back out of the bag so if I put

00:11:01,380 --> 00:11:04,860
in three red marbles and two blue

00:11:03,390 --> 00:11:07,710
marbles and I say iterate over this

00:11:04,860 --> 00:11:10,020
you're taking one red out another red

00:11:07,710 --> 00:11:12,420
out another red out a blue and a blue

00:11:10,020 --> 00:11:13,980
and so that's what elements does is it

00:11:12,420 --> 00:11:17,279
lists out the contents individually

00:11:13,980 --> 00:11:18,990
after handling their multiplicity so it

00:11:17,279 --> 00:11:21,720
doesn't hand you one red marble and hand

00:11:18,990 --> 00:11:24,180
you all three so it works just like the

00:11:21,720 --> 00:11:26,880
bag design iterator over our bags in

00:11:24,180 --> 00:11:28,710
small talk differs from the built in

00:11:26,880 --> 00:11:30,270
inner method for dicks because remember

00:11:28,710 --> 00:11:31,770
this is just a dick so what's the dick

00:11:30,270 --> 00:11:33,870
going to return if you iterate over it

00:11:31,770 --> 00:11:35,940
it'll return just the objects its keys

00:11:33,870 --> 00:11:37,380
unless you say give me items in which

00:11:35,940 --> 00:11:38,970
case it will give you the key value

00:11:37,380 --> 00:11:41,370
pairs what are the key value pairs the

00:11:38,970 --> 00:11:44,339
object and their most multiplicity you

00:11:41,370 --> 00:11:46,680
have so if you it over items of the

00:11:44,339 --> 00:11:48,870
counter I just mentioned the first

00:11:46,680 --> 00:11:50,730
return will be red three there are three

00:11:48,870 --> 00:11:55,230
red marbles the second return will be

00:11:50,730 --> 00:11:57,060
there as green two elements on the other

00:11:55,230 --> 00:11:59,400
hand red red red green green got the

00:11:57,060 --> 00:12:02,370
difference convene use method so the

00:11:59,400 --> 00:12:04,860
idea in the AP add I design is to

00:12:02,370 --> 00:12:06,480
anticipate after we've made a counter

00:12:04,860 --> 00:12:08,400
anticipate how people are going to use

00:12:06,480 --> 00:12:13,020
it and then make sure that their use

00:12:08,400 --> 00:12:16,290
cases are supported yes sir ape returns

00:12:13,020 --> 00:12:18,390
an iterator I always try and return

00:12:16,290 --> 00:12:20,190
iterators when I can the only time of

00:12:18,390 --> 00:12:22,339
return list is if I already have to fill

00:12:20,190 --> 00:12:24,510
up memory so in the case of a sort

00:12:22,339 --> 00:12:27,150
sorted well we're turn to list because

00:12:24,510 --> 00:12:28,470
it's already filled up memory but two

00:12:27,150 --> 00:12:29,580
other tools like enumerate well we're

00:12:28,470 --> 00:12:31,529
turning an iterator because it can

00:12:29,580 --> 00:12:33,209
handle them in one at a time it's kind

00:12:31,529 --> 00:12:36,360
of a design principle and good question

00:12:33,209 --> 00:12:39,029
um anything else exciting on this page

00:12:36,360 --> 00:12:44,990
you guys are really bored by this much

00:12:39,029 --> 00:12:47,610
if you want to know it's at least common

00:12:44,990 --> 00:12:50,520
so I thought about putting in a least

00:12:47,610 --> 00:12:53,040
common and there's a way to already get

00:12:50,520 --> 00:12:55,560
to it like you say most common without

00:12:53,040 --> 00:12:57,630
any arguments and then strip off using

00:12:55,560 --> 00:12:59,790
slicing to pull off of the end same way

00:12:57,630 --> 00:13:01,170
you would do with a regular list so you

00:12:59,790 --> 00:13:03,990
already have a way to get to least

00:13:01,170 --> 00:13:05,200
common but then I thought about the the

00:13:03,990 --> 00:13:07,300
use cases

00:13:05,200 --> 00:13:11,110
and least common is not something that

00:13:07,300 --> 00:13:13,630
people usually seek out they are trying

00:13:11,110 --> 00:13:16,060
to find it doesn't match what people are

00:13:13,630 --> 00:13:18,340
after so I didn't build in that extra

00:13:16,060 --> 00:13:21,520
method could have it doesn't occupy a

00:13:18,340 --> 00:13:23,530
whole lot of extra mental space but so

00:13:21,520 --> 00:13:25,240
the opposing forces are someone

00:13:23,530 --> 00:13:28,420
somewhere might want it for a reason I

00:13:25,240 --> 00:13:31,390
can't anticipate now balance with I like

00:13:28,420 --> 00:13:33,430
to keep the AAPI compact and I'd still

00:13:31,390 --> 00:13:35,470
like to be able to sell counters as it's

00:13:33,430 --> 00:13:37,020
basically a dictionary and when you

00:13:35,470 --> 00:13:39,160
figure out you want the most common

00:13:37,020 --> 00:13:41,470
elements I happen to have a convenience

00:13:39,160 --> 00:13:44,260
method in it in there for you but if I

00:13:41,470 --> 00:13:45,610
hadn't you could have made your own in a

00:13:44,260 --> 00:13:47,320
number of ways like just taking the

00:13:45,610 --> 00:13:49,000
items and doing a sort on the items

00:13:47,320 --> 00:13:51,340
holding it out the old-fashioned way

00:13:49,000 --> 00:13:52,930
all right so we've put in some counter

00:13:51,340 --> 00:13:54,730
mathematics you got one counter you got

00:13:52,930 --> 00:13:58,120
another counter you might want to do

00:13:54,730 --> 00:14:00,820
counter to counter operations so if I

00:13:58,120 --> 00:14:03,550
add two counters together so I have one

00:14:00,820 --> 00:14:04,960
one bucket with my three red marbles and

00:14:03,550 --> 00:14:07,480
two green marbles and another bucket

00:14:04,960 --> 00:14:09,220
with ten red marbles and four green

00:14:07,480 --> 00:14:10,780
marbles I can add them combine them

00:14:09,220 --> 00:14:13,540
together and it will add their

00:14:10,780 --> 00:14:14,680
multiplicities together subtract is the

00:14:13,540 --> 00:14:17,350
more interesting one we have two

00:14:14,680 --> 00:14:19,210
different kinds of counter mat we have

00:14:17,350 --> 00:14:22,480
the regular math so I have two counters

00:14:19,210 --> 00:14:24,130
here one that has one A and one B 1 a

00:14:22,480 --> 00:14:29,110
and Lindsay I take the difference

00:14:24,130 --> 00:14:31,750
between those the aides go to 0 these

00:14:29,110 --> 00:14:34,600
the default count for C is 0 so the C

00:14:31,750 --> 00:14:38,800
goes to negative 1 and the default count

00:14:34,600 --> 00:14:44,980
for B is 0 so 1 minus 0 is 1 anybody

00:14:38,800 --> 00:14:46,660
surprised by that result really the Mobe

00:14:44,980 --> 00:14:48,850
would be surprised by the result if you

00:14:46,660 --> 00:14:51,010
have used bag objects and another

00:14:48,850 --> 00:14:52,360
language like what is the meaning of a

00:14:51,010 --> 00:14:55,380
negative count you can't have negative

00:14:52,360 --> 00:14:57,610
marbles if I were to use multi set math

00:14:55,380 --> 00:14:59,230
my counters have no meaning for negative

00:14:57,610 --> 00:15:03,700
counts but I was in first grade and they

00:14:59,230 --> 00:15:07,360
taught me to count 1 2 3 negative 1 it's

00:15:03,700 --> 00:15:08,440
not on the list though for some use

00:15:07,360 --> 00:15:11,440
cases this is not the appropriate

00:15:08,440 --> 00:15:13,060
structure kind of subtraction the kind

00:15:11,440 --> 00:15:14,800
that you might want the kind is

00:15:13,060 --> 00:15:16,510
typically defined for multi sets has a

00:15:14,800 --> 00:15:19,170
name who knows what the name is there's

00:15:16,510 --> 00:15:19,170
a technical term

00:15:20,340 --> 00:15:28,440
Uncle Don donald knuth calls it

00:15:24,150 --> 00:15:31,180
saturating subtraction and the idea is

00:15:28,440 --> 00:15:33,510
you're subtracting off marbles until you

00:15:31,180 --> 00:15:35,920
get to zero which once you fully saw

00:15:33,510 --> 00:15:38,230
subtracted out all possible marbles and

00:15:35,920 --> 00:15:40,510
you stop there so you go now lower than

00:15:38,230 --> 00:15:43,180
zero so that same subtraction here would

00:15:40,510 --> 00:15:46,870
have actually gotten rid of the negative

00:15:43,180 --> 00:15:49,180
case so when I do the and I'm doing a

00:15:46,870 --> 00:15:51,160
comparison here on this line I'm showing

00:15:49,180 --> 00:15:54,340
how does this behave with regular sets a

00:15:51,160 --> 00:15:57,220
regular set a and B minus the set a and

00:15:54,340 --> 00:16:00,970
C just leaves B nothing happens with C

00:15:57,220 --> 00:16:02,590
so this is normal set Matt this is how

00:16:00,970 --> 00:16:05,140
we do it with counters it gets the same

00:16:02,590 --> 00:16:07,410
result the idea is that sets that have a

00:16:05,140 --> 00:16:09,850
multiplicity of one regular sets and

00:16:07,410 --> 00:16:11,380
counters their subtraction behaves

00:16:09,850 --> 00:16:14,350
exactly the same do you see the course

00:16:11,380 --> 00:16:17,470
who learned a new link between counters

00:16:14,350 --> 00:16:19,000
and sets there's a deep relationship and

00:16:17,470 --> 00:16:21,370
not a shallow relationship that's why

00:16:19,000 --> 00:16:26,770
they're sometimes called multi sets sets

00:16:21,370 --> 00:16:28,510
they have unique elements that are every

00:16:26,770 --> 00:16:30,550
element that's in the set has a count of

00:16:28,510 --> 00:16:34,030
at least one and that there are no

00:16:30,550 --> 00:16:36,520
negatives okay so two kinds of math and

00:16:34,030 --> 00:16:38,710
your new term for the day is saturating

00:16:36,520 --> 00:16:41,560
subtraction it is used in many contexts

00:16:38,710 --> 00:16:43,900
not just this one so if you were doing

00:16:41,560 --> 00:16:46,480
some image processing and you were

00:16:43,900 --> 00:16:50,590
darkening a pixel and you want to darken

00:16:46,480 --> 00:16:52,870
it by 10 pixels you're never going to go

00:16:50,590 --> 00:16:56,110
higher than 255 and never lower than 0

00:16:52,870 --> 00:17:01,030
so you will said to have saturated the

00:16:56,110 --> 00:17:02,530
pixel who learned a new term it'd have

00:17:01,030 --> 00:17:05,080
been every hand because the one knew the

00:17:02,530 --> 00:17:08,470
term when I asked for it let's move on

00:17:05,080 --> 00:17:12,220
named tuples raymond named tuples aren't

00:17:08,470 --> 00:17:14,440
who sure they are how do I know they're

00:17:12,220 --> 00:17:16,120
new because when I go out to consult for

00:17:14,440 --> 00:17:18,450
companies now look at their code bases I

00:17:16,120 --> 00:17:20,710
see an under utilization of named tuples

00:17:18,450 --> 00:17:22,290
they have not yet won the world they

00:17:20,710 --> 00:17:25,000
should win the world

00:17:22,290 --> 00:17:28,140
no named tuples weren't just like a

00:17:25,000 --> 00:17:30,790
regular couple how do we know that

00:17:28,140 --> 00:17:34,430
counters are just a

00:17:30,790 --> 00:17:38,240
aim tuples are just up so they are just

00:17:34,430 --> 00:17:40,310
a couple or some of us say tuple and so

00:17:38,240 --> 00:17:42,470
it is a tuple subclass light it hates

00:17:40,310 --> 00:17:44,270
exactly like a couple who knows how much

00:17:42,470 --> 00:17:49,340
overhead is associated with a name

00:17:44,270 --> 00:17:52,010
couple let's say I go to my database I

00:17:49,340 --> 00:17:53,510
do a fetch all and it returns a list of

00:17:52,010 --> 00:17:56,750
a million records and each one of those

00:17:53,510 --> 00:17:58,280
records is a tupple now I go cast that I

00:17:56,750 --> 00:18:00,290
take every one of those tuples and turn

00:17:58,280 --> 00:18:05,660
it into a name couple how much extra

00:18:00,290 --> 00:18:07,610
memory of I consumed Dee bro inside the

00:18:05,660 --> 00:18:08,930
tupple there's a pointer to each element

00:18:07,610 --> 00:18:11,900
in the tuple and then there's a pointer

00:18:08,930 --> 00:18:14,570
to what kind of thing it is and then

00:18:11,900 --> 00:18:17,540
formally that pointer normally its type

00:18:14,570 --> 00:18:19,040
pointer it usually points to tupple but

00:18:17,540 --> 00:18:20,270
when you cast it it'll just change that

00:18:19,040 --> 00:18:21,590
pointer and it will point at the name

00:18:20,270 --> 00:18:23,360
tuple the thing that knows the field

00:18:21,590 --> 00:18:29,900
your space overhead is zero

00:18:23,360 --> 00:18:31,730
who likes free Ria's good alright it is

00:18:29,900 --> 00:18:33,740
my belief that the use of name tuples

00:18:31,730 --> 00:18:35,620
can profoundly improve your code base it

00:18:33,740 --> 00:18:37,640
makes your code more self documenting

00:18:35,620 --> 00:18:39,080
whenever you have an error message and

00:18:37,640 --> 00:18:43,640
the repper of the object shows up on the

00:18:39,080 --> 00:18:45,290
screen it is self explanatory and more

00:18:43,640 --> 00:18:46,700
importantly it lets you change the order

00:18:45,290 --> 00:18:48,380
of elements in the couple without all

00:18:46,700 --> 00:18:50,240
affecting all of your client code most

00:18:48,380 --> 00:18:52,220
people who manipulate tuples where the

00:18:50,240 --> 00:18:54,170
first field is the last name second

00:18:52,220 --> 00:18:56,930
one's the first name next one's the age

00:18:54,170 --> 00:18:59,120
next one is employee identifier number

00:18:56,930 --> 00:19:02,030
okay we'll end up with a lot of code

00:18:59,120 --> 00:19:05,660
that says take Tia three store it in

00:19:02,030 --> 00:19:08,090
this field update Tia 2 and that will

00:19:05,660 --> 00:19:10,130
permeate the entire code base which is a

00:19:08,090 --> 00:19:12,980
real problem if later you go and insert

00:19:10,130 --> 00:19:14,930
a new field in position 0 you have to

00:19:12,980 --> 00:19:16,250
change all of your code what are the

00:19:14,930 --> 00:19:19,340
odds such are that you're going to be

00:19:16,250 --> 00:19:21,410
able to do that reliably apps if you

00:19:19,340 --> 00:19:24,500
have a really smart editor if it's all

00:19:21,410 --> 00:19:26,660
concentrated in one place if you have

00:19:24,500 --> 00:19:29,690
extensive unit tests and if you're very

00:19:26,660 --> 00:19:30,800
very lucky all of those things will

00:19:29,690 --> 00:19:32,420
allow you to change it but if you're

00:19:30,800 --> 00:19:33,950
using a name tupple you change the order

00:19:32,420 --> 00:19:37,810
and you won't have to change any of the

00:19:33,950 --> 00:19:37,810
client code have I sold you

00:19:39,790 --> 00:19:45,500
there was a time when you ran doc test

00:19:42,980 --> 00:19:47,660
and you went oh oh I shouldn't give it

00:19:45,500 --> 00:19:51,400
away the answer you guys read that slide

00:19:47,660 --> 00:19:53,540
already all right so you're in doc test

00:19:51,400 --> 00:19:55,790
print out the result and it returns the

00:19:53,540 --> 00:20:00,850
tupple and it returns the tupple zero

00:19:55,790 --> 00:20:00,850
comma seven are you happier are you set

00:20:04,090 --> 00:20:08,270
fact that you can't understand the

00:20:06,110 --> 00:20:10,310
answer but you should be happy because

00:20:08,270 --> 00:20:12,620
what it actually means and it now says

00:20:10,310 --> 00:20:16,250
it returns a name couple and the name

00:20:12,620 --> 00:20:18,560
couple says this is a test result zero

00:20:16,250 --> 00:20:21,950
failed and attempted seven it was a good

00:20:18,560 --> 00:20:25,730
result you're happier now so the old doc

00:20:21,950 --> 00:20:27,230
test returned just a couple lots of doc

00:20:25,730 --> 00:20:30,650
test was out for a long time

00:20:27,230 --> 00:20:32,180
lots of client code uses that tupple so

00:20:30,650 --> 00:20:34,010
what happened when I introduced a name

00:20:32,180 --> 00:20:37,580
couple did I break any of the client

00:20:34,010 --> 00:20:39,680
code no it's just a topple subclass this

00:20:37,580 --> 00:20:42,790
thing you can still say take the result

00:20:39,680 --> 00:20:47,360
sign it to Tee tee at 0 will be 0 t it

00:20:42,790 --> 00:20:48,800
said to RT at 1 will be 7 I could run

00:20:47,360 --> 00:20:51,230
list of the tupple and it would give me

00:20:48,800 --> 00:20:53,810
the list 0 7 I could feed it into

00:20:51,230 --> 00:20:56,090
something accepts an interval I could

00:20:53,810 --> 00:20:59,380
feed it into set just to make you see if

00:20:56,090 --> 00:21:02,060
these two are the same in other words

00:20:59,380 --> 00:21:04,480
what you could do after this conference

00:21:02,060 --> 00:21:08,560
is go back to your code base go through

00:21:04,480 --> 00:21:10,220
every piece of code that returns a tuple

00:21:08,560 --> 00:21:11,780
where the different fields have

00:21:10,220 --> 00:21:15,020
different mean turn it into name trouble

00:21:11,780 --> 00:21:16,820
and your space overhead will be 0 your

00:21:15,020 --> 00:21:19,040
readability will go up you'll get

00:21:16,820 --> 00:21:21,770
beautiful wrappers like this it will

00:21:19,040 --> 00:21:25,190
cost you nothing who likes free all

00:21:21,770 --> 00:21:29,420
right have I sold you now ok but what

00:21:25,190 --> 00:21:31,370
was the promise of this talk are they

00:21:29,420 --> 00:21:32,930
just going to sell you on a new tool no

00:21:31,370 --> 00:21:35,750
I'm going to show you how to make it and

00:21:32,930 --> 00:21:37,220
then once we know how to make it we're

00:21:35,750 --> 00:21:38,890
gonna push it to the outer limits and

00:21:37,220 --> 00:21:40,880
say what can be done with one of these

00:21:38,890 --> 00:21:43,100
let's go have some fun with it

00:21:40,880 --> 00:21:44,900
all right so simple implementation let's

00:21:43,100 --> 00:21:47,090
say you're making your own test results

00:21:44,900 --> 00:21:49,100
you say class test results and here

00:21:47,090 --> 00:21:52,190
since tupple at that point you could say

00:21:49,100 --> 00:21:53,210
I'm already done and you will not have

00:21:52,190 --> 00:21:55,010
damaged your code and

00:21:53,210 --> 00:21:56,450
anyway because it still behaves just

00:21:55,010 --> 00:21:58,880
like a couple we know that because it

00:21:56,450 --> 00:22:00,649
inherited from trouble you guys seeing a

00:21:58,880 --> 00:22:04,010
theme of how I design some of the

00:22:00,649 --> 00:22:05,990
collections all right so now we give it

00:22:04,010 --> 00:22:07,700
a nice doc string which is great because

00:22:05,990 --> 00:22:10,730
the first time someone types in test

00:22:07,700 --> 00:22:13,100
results a tooltip will pop up on their

00:22:10,730 --> 00:22:16,220
screen so using one of the more advanced

00:22:13,100 --> 00:22:18,649
editors like most of you are empty slots

00:22:16,220 --> 00:22:20,299
what does that do for us that prevents

00:22:18,649 --> 00:22:23,210
the formation of an instance dictionary

00:22:20,299 --> 00:22:26,860
and it's why named tuples have zero

00:22:23,210 --> 00:22:31,070
overhead you learn something new

00:22:26,860 --> 00:22:33,669
fantastic now named tuples no their own

00:22:31,070 --> 00:22:36,799
field names why would I put this in here

00:22:33,669 --> 00:22:38,630
make the object introspective all so you

00:22:36,799 --> 00:22:41,690
can take a name couple ask it what does

00:22:38,630 --> 00:22:43,130
field names are all right it has a new

00:22:41,690 --> 00:22:45,529
method so you can pass him failed and

00:22:43,130 --> 00:22:48,770
attempted it has a nice repre he knows

00:22:45,529 --> 00:22:51,350
it's classy who knows why I didn't write

00:22:48,770 --> 00:22:54,700
here why I didn't put test result why

00:22:51,350 --> 00:22:54,700
did I use self that class that name

00:22:55,870 --> 00:23:03,980
Anjali do you also have a time machine

00:23:00,429 --> 00:23:05,809
cuz that's tomorrow's lesson tomorrow I

00:23:03,980 --> 00:23:07,549
talk on the art of subclassing and the

00:23:05,809 --> 00:23:09,080
article subclassing says we will design

00:23:07,549 --> 00:23:11,059
our classes to make it nice for

00:23:09,080 --> 00:23:13,760
subclasses in the future so a subclass

00:23:11,059 --> 00:23:16,220
of test results comes along they says my

00:23:13,760 --> 00:23:18,980
combined test results my validated test

00:23:16,220 --> 00:23:20,990
results my successful test results if

00:23:18,980 --> 00:23:22,669
that's a subclass of test results its

00:23:20,990 --> 00:23:24,020
name will drop in here and the your

00:23:22,669 --> 00:23:26,770
subclass or won't have to rewrite your

00:23:24,020 --> 00:23:29,360
wrapper who learned a new technique

00:23:26,770 --> 00:23:30,890
fantastic and then we use properties an

00:23:29,360 --> 00:23:33,500
item getter to actually get the failed

00:23:30,890 --> 00:23:36,289
an attempt it so whenever you take your

00:23:33,500 --> 00:23:38,120
test result dot failed it will trigger

00:23:36,289 --> 00:23:39,649
the property which calls an item getter

00:23:38,120 --> 00:23:41,539
which grab something from opposition

00:23:39,649 --> 00:23:43,640
zero and it'll give you a nice dock

00:23:41,539 --> 00:23:46,580
string on your tooltip saying a failed

00:23:43,640 --> 00:23:48,409
is an alias for field number zero so if

00:23:46,580 --> 00:23:50,929
you were going to write test results on

00:23:48,409 --> 00:23:52,610
your own to create a named tuple that's

00:23:50,929 --> 00:23:54,470
what you would write you might int add

00:23:52,610 --> 00:23:57,399
add in some extra convenience methods

00:23:54,470 --> 00:24:00,590
but this would be the start easy enough

00:23:57,399 --> 00:24:02,840
how do I make this there will be a

00:24:00,590 --> 00:24:05,179
handful of you who cringe at this and a

00:24:02,840 --> 00:24:06,650
handful who say oh I've learned a new

00:24:05,179 --> 00:24:08,930
fantastic technique I

00:24:06,650 --> 00:24:11,570
continuous perfectly legitimate veto

00:24:08,930 --> 00:24:15,980
doesn't I do it there's some of you who

00:24:11,570 --> 00:24:17,930
think it's morally wrong you know what

00:24:15,980 --> 00:24:20,860
I'm gonna make another name couple and

00:24:17,930 --> 00:24:23,990
it's gonna have exactly this layout

00:24:20,860 --> 00:24:26,900
those of you come from the web world do

00:24:23,990 --> 00:24:28,100
a lot of django jing jinga that sort of

00:24:26,900 --> 00:24:29,240
thing i would say you know what i can

00:24:28,100 --> 00:24:30,890
take this thing and make a template out

00:24:29,240 --> 00:24:33,620
of it and we can just drop in words like

00:24:30,890 --> 00:24:35,570
failed and attempt it that in fact is

00:24:33,620 --> 00:24:37,190
the way our name couple works it's the

00:24:35,570 --> 00:24:39,470
factory function that takes a template

00:24:37,190 --> 00:24:41,390
that looks like this and drops in the

00:24:39,470 --> 00:24:44,540
words test results failed and attempted

00:24:41,390 --> 00:24:45,680
and creates a new class one of the

00:24:44,540 --> 00:24:47,540
things it's fantastic about this

00:24:45,680 --> 00:24:50,240
technique is its self documenting you

00:24:47,540 --> 00:24:53,000
can take any I never get questions about

00:24:50,240 --> 00:24:54,740
how I named couple works the reason is

00:24:53,000 --> 00:24:56,570
there's an option on the factory

00:24:54,740 --> 00:24:58,640
function called bra Bruce and it prints

00:24:56,570 --> 00:25:01,040
this out to the screen and so everyone

00:24:58,640 --> 00:25:03,230
who knows the basic Python can see this

00:25:01,040 --> 00:25:05,300
code and it answers questions right away

00:25:03,230 --> 00:25:07,220
like how does the repper work works just

00:25:05,300 --> 00:25:09,050
like this as a wrapper subclass of all

00:25:07,220 --> 00:25:11,000
yes what would happen if I want to

00:25:09,050 --> 00:25:13,070
override failed well if someone had

00:25:11,000 --> 00:25:15,950
typed this class you override it put in

00:25:13,070 --> 00:25:18,110
a new one no problem it answers all

00:25:15,950 --> 00:25:19,850
questions it is not opaque like C code

00:25:18,110 --> 00:25:22,310
it's a fantastic thing so I fill in the

00:25:19,850 --> 00:25:24,590
template and run it through eval what's

00:25:22,310 --> 00:25:29,120
the problem with running untrusted code

00:25:24,590 --> 00:25:30,890
through a Val here D risk you've given

00:25:29,120 --> 00:25:33,020
access to your whole system somebody is

00:25:30,890 --> 00:25:34,130
possibly defined a field name externally

00:25:33,020 --> 00:25:36,620
they load it in

00:25:34,130 --> 00:25:39,290
so we sanitize the results first just to

00:25:36,620 --> 00:25:40,970
make sure that they are all valid Python

00:25:39,290 --> 00:25:44,030
identifiers and there's nothing else

00:25:40,970 --> 00:25:46,130
magical inside ok convenience methods

00:25:44,030 --> 00:25:48,860
building it up I have this theory and

00:25:46,130 --> 00:25:51,710
API design anything that you make that

00:25:48,860 --> 00:25:53,720
has some notion of two things associated

00:25:51,710 --> 00:25:56,600
together well one looks up the other is

00:25:53,720 --> 00:25:57,980
at its heart a key value pair and

00:25:56,600 --> 00:26:00,170
anything that is at its heart a key

00:25:57,980 --> 00:26:05,060
value pair should be readily convertible

00:26:00,170 --> 00:26:07,310
into and out of dictionaries so baled is

00:26:05,060 --> 00:26:09,260
associated with zero so attempted

00:26:07,310 --> 00:26:10,670
associated with seven conceptually

00:26:09,260 --> 00:26:13,160
that's a dictionary and someone might

00:26:10,670 --> 00:26:16,190
want a dictionary so I provide a under

00:26:13,160 --> 00:26:20,390
as dick method and then there's a

00:26:16,190 --> 00:26:23,780
replace replace is a fantastic method

00:26:20,390 --> 00:26:25,160
Wow it took a lot of design iterations

00:26:23,780 --> 00:26:27,140
to get to our current version of replace

00:26:25,160 --> 00:26:31,450
but it's truly wonderful what replace

00:26:27,140 --> 00:26:33,740
does this takes the old result copies it

00:26:31,450 --> 00:26:36,380
replacing one of the fields so I can say

00:26:33,740 --> 00:26:38,750
take the failed zero and attempted seven

00:26:36,380 --> 00:26:41,929
and replace failed with two and it makes

00:26:38,750 --> 00:26:44,720
a new test result now that's the word

00:26:41,929 --> 00:26:46,910
replaced suggests that it in place goes

00:26:44,720 --> 00:26:48,230
in and mutates a couple what's one of

00:26:46,910 --> 00:26:50,990
the properties of tuples they're

00:26:48,230 --> 00:26:52,790
immutable so it would seem like replaces

00:26:50,990 --> 00:26:58,040
a bad name who knows why I chose replace

00:26:52,790 --> 00:26:59,390
is the name for this that's exactly it

00:26:58,040 --> 00:27:03,620
we've already got one and it's a very

00:26:59,390 --> 00:27:05,809
nice so string replace strings are

00:27:03,620 --> 00:27:07,309
immutable but we do replace as people

00:27:05,809 --> 00:27:08,960
seem to get it and because they seem to

00:27:07,309 --> 00:27:11,030
get it and I've already acquired that

00:27:08,960 --> 00:27:13,940
knowledge when the API design principles

00:27:11,030 --> 00:27:15,440
here was we've modeled off of something

00:27:13,940 --> 00:27:18,020
to already know so this learning curve

00:27:15,440 --> 00:27:19,700
drops to zero so if you don't have

00:27:18,020 --> 00:27:21,470
replaced the old-fashioned way with

00:27:19,700 --> 00:27:23,480
tuples is the way to make a new one is I

00:27:21,470 --> 00:27:25,760
create a couple of length one and then

00:27:23,480 --> 00:27:27,679
add in resultant one which is clear

00:27:25,760 --> 00:27:29,750
about what it does this line or this

00:27:27,679 --> 00:27:31,340
line it's the second one this is

00:27:29,750 --> 00:27:33,890
particularly important when we get into

00:27:31,340 --> 00:27:35,120
a long couple and remember this is

00:27:33,890 --> 00:27:37,429
special because it can also replace

00:27:35,120 --> 00:27:39,500
multiple fields at once so if I had a

00:27:37,429 --> 00:27:41,270
very long tupple 50 fields I could say

00:27:39,500 --> 00:27:43,610
I'm going to replace the last name the

00:27:41,270 --> 00:27:45,260
first name update the timestamp update

00:27:43,610 --> 00:27:49,940
the quantity available leaving all other

00:27:45,260 --> 00:27:51,200
fields the same yes sir raises a

00:27:49,940 --> 00:27:56,419
question why the underscore and the

00:27:51,200 --> 00:27:57,919
method names who knows right so I have

00:27:56,419 --> 00:28:00,530
made it to where you can define your own

00:27:57,919 --> 00:28:03,890
fields words like failed and attempted

00:28:00,530 --> 00:28:06,260
my problem is if I make a method replace

00:28:03,890 --> 00:28:08,179
or azdak potentially aim conflicting

00:28:06,260 --> 00:28:10,040
with one of your names so we're having a

00:28:08,179 --> 00:28:10,340
name say squash so I've made a deal with

00:28:10,040 --> 00:28:12,860
you

00:28:10,340 --> 00:28:14,750
I said you can use any name you want as

00:28:12,860 --> 00:28:17,210
long as it's a palette valid Python

00:28:14,750 --> 00:28:19,340
identifier it has to be a valid path on

00:28:17,210 --> 00:28:22,130
identifier so that you can say TDOT

00:28:19,340 --> 00:28:24,740
failed or TDOT attempted so it's a basic

00:28:22,130 --> 00:28:25,940
restriction but in addition I preclude

00:28:24,740 --> 00:28:29,179
you from using something that starts

00:28:25,940 --> 00:28:34,789
from an underscore because in mine

00:28:29,179 --> 00:28:39,499
fair enough would I do this again no I

00:28:34,789 --> 00:28:41,450
made a mistake I'll take all the blame

00:28:39,499 --> 00:28:43,429
but I have to share it with I've

00:28:41,450 --> 00:28:45,859
reviewed it with everybody on Python

00:28:43,429 --> 00:28:47,629
death part of the design of name tuples

00:28:45,859 --> 00:28:50,239
we put them out on the ASP in cookbook

00:28:47,629 --> 00:28:52,940
and we had comments from dozens of

00:28:50,239 --> 00:28:54,940
people so I went I've deployed this code

00:28:52,940 --> 00:28:59,719
got lots of people to exercise it and

00:28:54,940 --> 00:29:01,279
nobody suggested until weeks ago you

00:28:59,719 --> 00:29:03,499
know what is our usual way to deal with

00:29:01,279 --> 00:29:06,109
namespace conflicts in Python how do you

00:29:03,499 --> 00:29:09,710
how does the operator module add the

00:29:06,109 --> 00:29:12,379
word is because is is a keyword if this

00:29:09,710 --> 00:29:13,849
is followed by an underscore trailing

00:29:12,379 --> 00:29:15,440
underscore would have been the correct

00:29:13,849 --> 00:29:18,169
convention because our convention for

00:29:15,440 --> 00:29:19,519
leading underscores is uh it

00:29:18,169 --> 00:29:23,210
communicates that this is a private

00:29:19,519 --> 00:29:24,589
method so it was mistake if I had it to

00:29:23,210 --> 00:29:27,679
do over again that would be a trailing

00:29:24,589 --> 00:29:29,059
underscore fair enough that being said

00:29:27,679 --> 00:29:30,859
it doesn't seem to have created a

00:29:29,059 --> 00:29:33,739
usability problem at all people seem

00:29:30,859 --> 00:29:35,629
happy with it and we've got good good

00:29:33,739 --> 00:29:37,039
results so I could say we're done with

00:29:35,629 --> 00:29:39,139
named tuples you know how to build them

00:29:37,039 --> 00:29:41,509
the design principles that went behind

00:29:39,139 --> 00:29:43,759
making it what the convenience methods

00:29:41,509 --> 00:29:45,379
are a month are useful for what you guys

00:29:43,759 --> 00:29:47,149
like to put the pedal to the metal and

00:29:45,379 --> 00:29:48,799
take it for a ride around the block just

00:29:47,149 --> 00:29:54,499
open it up on a track and see what it

00:29:48,799 --> 00:29:56,149
can do hi pro tip number one using the

00:29:54,499 --> 00:30:00,019
field structure so remember it's

00:29:56,149 --> 00:30:03,349
introspective all so we had a test

00:30:00,019 --> 00:30:05,149
result and test results fields in under

00:30:03,349 --> 00:30:08,239
header fields what if I want to make a

00:30:05,149 --> 00:30:10,999
new result called the labeled result I

00:30:08,239 --> 00:30:13,580
take test result fields and then add a

00:30:10,999 --> 00:30:15,799
new field name onto it and build a new

00:30:13,580 --> 00:30:18,799
one labeled results that way I can chain

00:30:15,799 --> 00:30:20,749
these together that I have a name couple

00:30:18,799 --> 00:30:23,389
for color which concludes a red green

00:30:20,749 --> 00:30:25,759
blue component or hue saturation value

00:30:23,389 --> 00:30:27,979
however you store your colors and then I

00:30:25,759 --> 00:30:33,109
can have another name couple for a 2d

00:30:27,979 --> 00:30:37,519
position that has X&Y I can from the 2d

00:30:33,109 --> 00:30:39,789
position add on to its field a Z

00:30:37,519 --> 00:30:42,650
coordinate so that I have a 3d position

00:30:39,789 --> 00:30:45,020
it includes the

00:30:42,650 --> 00:30:47,809
and then I can compose those two and

00:30:45,020 --> 00:30:49,670
make a colored point something that has

00:30:47,809 --> 00:30:51,020
for every point in space so we can

00:30:49,670 --> 00:30:55,730
compose these who learned a new

00:30:51,020 --> 00:30:56,150
technique very few of you amazing all

00:30:55,730 --> 00:30:59,809
right

00:30:56,150 --> 00:31:01,670
pro tip number two this is cool I get

00:30:59,809 --> 00:31:03,410
requests all the time you know what

00:31:01,670 --> 00:31:05,120
these mean tuples are great but I'd like

00:31:03,410 --> 00:31:08,540
to have default values for the fields

00:31:05,120 --> 00:31:11,120
can I do that well in fact you can if

00:31:08,540 --> 00:31:14,929
you know this technique it's borrowed

00:31:11,120 --> 00:31:16,670
from prototype oo the idea that you

00:31:14,929 --> 00:31:19,340
don't create new objects you just clone

00:31:16,670 --> 00:31:21,890
Oh old ones and then modify them so let

00:31:19,340 --> 00:31:24,350
us make a prototype instance of a cell

00:31:21,890 --> 00:31:26,300
and the prototype instance of cell has

00:31:24,350 --> 00:31:27,470
color equal to red size equal to 10 in

00:31:26,300 --> 00:31:29,450
boarder equal to false

00:31:27,470 --> 00:31:31,220
look how more self-explanatory this is

00:31:29,450 --> 00:31:34,910
then a regular couple where we just said

00:31:31,220 --> 00:31:36,830
red comma 10 comma false a lot more

00:31:34,910 --> 00:31:39,260
meaning in this so now I've got my

00:31:36,830 --> 00:31:41,420
prototype how do I make new ones with

00:31:39,260 --> 00:31:43,670
those default values I just use replace

00:31:41,420 --> 00:31:45,950
so let's take the prototype and replace

00:31:43,670 --> 00:31:48,920
the size with 20 now I've created an

00:31:45,950 --> 00:31:51,890
intro that has size 20 color red and

00:31:48,920 --> 00:31:54,650
board or false or I create my lead

00:31:51,890 --> 00:31:57,429
well my lead it's just like the

00:31:54,650 --> 00:31:59,990
prototype but it's color now is blue and

00:31:57,429 --> 00:32:01,940
word is false now I don't have to use

00:31:59,990 --> 00:32:04,100
just a single prototype I can nest these

00:32:01,940 --> 00:32:06,860
and so lead could be a modified version

00:32:04,100 --> 00:32:08,750
the intro I can have different defaults

00:32:06,860 --> 00:32:10,760
for different sections and work away and

00:32:08,750 --> 00:32:13,190
who thinks this is useful it's

00:32:10,760 --> 00:32:17,780
fantastically useful and it's extremely

00:32:13,190 --> 00:32:19,790
readable it beats the snot out of doing

00:32:17,780 --> 00:32:23,830
this with regular tuples if you start

00:32:19,790 --> 00:32:30,470
doing something like this and say T at 0

00:32:23,830 --> 00:32:34,820
plus the couple of length of 120 plus T

00:32:30,470 --> 00:32:39,050
at 2 you've communicated nothing to your

00:32:34,820 --> 00:32:42,640
reader bill that's got to be expensive

00:32:39,050 --> 00:32:46,340
oh wait how much overhead does it have

00:32:42,640 --> 00:32:49,520
what's the new protip and subclass named

00:32:46,340 --> 00:32:51,830
tuples well you saw that it was just a

00:32:49,520 --> 00:32:53,540
simple class definition so since it's a

00:32:51,830 --> 00:32:55,730
simple class definition there's no

00:32:53,540 --> 00:32:57,350
reason we can't subclass it

00:32:55,730 --> 00:32:59,120
when you subclass it if you would like

00:32:57,350 --> 00:33:02,830
to retain the space efficiency you ought

00:32:59,120 --> 00:33:04,760
to also sent slots up to an empty tuple

00:33:02,830 --> 00:33:06,320
because that's the way we prevent the

00:33:04,760 --> 00:33:08,120
formation of instance dictionaries

00:33:06,320 --> 00:33:12,019
because slots is not something that

00:33:08,120 --> 00:33:14,330
inherits I can add a property and I can

00:33:12,019 --> 00:33:19,669
add Astor Astor is a custom way to print

00:33:14,330 --> 00:33:21,529
this out the XY point and high pot is a

00:33:19,669 --> 00:33:23,480
computed field all this is fantastic

00:33:21,529 --> 00:33:26,029
reminds us of the database world I have

00:33:23,480 --> 00:33:27,919
a database that stores x and y but I can

00:33:26,029 --> 00:33:32,269
create a view that includes a third

00:33:27,919 --> 00:33:34,970
field the hypotenuse as if that value

00:33:32,269 --> 00:33:38,899
had been stored so now whenever someone

00:33:34,970 --> 00:33:41,990
says their py pot it will compute on the

00:33:38,899 --> 00:33:43,460
fly from x and y the hypotenuse is if it

00:33:41,990 --> 00:33:45,470
had been stored so your name temple only

00:33:43,460 --> 00:33:47,779
takes up space of a to topple not space

00:33:45,470 --> 00:33:49,639
the three tuple computed fields is one

00:33:47,779 --> 00:33:51,350
good use another good use is to

00:33:49,639 --> 00:33:53,059
customize a printout in this case I want

00:33:51,350 --> 00:33:55,789
it to be nicely formatted so that I

00:33:53,059 --> 00:33:57,559
could produce a table where everything

00:33:55,789 --> 00:34:00,740
can be read vertically in a nice column

00:33:57,559 --> 00:34:03,559
or format so if I loop over these two

00:34:00,740 --> 00:34:05,659
points it prints out X Y and hi pot as

00:34:03,559 --> 00:34:07,490
if all three had been stored and they're

00:34:05,659 --> 00:34:10,399
all neatly formatted we've learned a new

00:34:07,490 --> 00:34:12,470
technique sub classing they named tuples

00:34:10,399 --> 00:34:15,079
it's not exotic it is very normal

00:34:12,470 --> 00:34:16,819
it is a preferred way to use them start

00:34:15,079 --> 00:34:20,290
with what I gave you the ability to

00:34:16,819 --> 00:34:22,970
convert it to a dictionary nice wrapper

00:34:20,290 --> 00:34:24,349
all the little nice nice t-shirt and

00:34:22,970 --> 00:34:28,310
then customize it change the way it

00:34:24,349 --> 00:34:31,450
prints add on new methods it's the

00:34:28,310 --> 00:34:36,919
normal way to use named tuples all right

00:34:31,450 --> 00:34:38,419
did I show you something bad okay

00:34:36,919 --> 00:34:40,579
all right I'm actually just going to

00:34:38,419 --> 00:34:42,470
opine and pontificate for a moment so

00:34:40,579 --> 00:34:43,940
all the rest of this I'm giving you the

00:34:42,470 --> 00:34:45,919
straight facts but now I'm gonna stand

00:34:43,940 --> 00:34:47,810
on my soapbox and have an opinion so you

00:34:45,919 --> 00:34:50,500
come to Python from some language

00:34:47,810 --> 00:34:53,089
statically compiled language where a new

00:34:50,500 --> 00:34:54,889
new types are important in that language

00:34:53,089 --> 00:34:57,410
and they're also cost free because the

00:34:54,889 --> 00:34:59,569
compiler compiles them away so your

00:34:57,410 --> 00:35:03,829
immediate aspiration because you aspire

00:34:59,569 --> 00:35:06,140
to program Java and Python or JavaScript

00:35:03,829 --> 00:35:08,270
in Python yada yada yada

00:35:06,140 --> 00:35:09,500
your immediate aspiration is I'm going

00:35:08,270 --> 00:35:11,120
to make myself an inn

00:35:09,500 --> 00:35:13,520
and it turns out they're more fun to

00:35:11,120 --> 00:35:14,990
make a new recipes than it is to

00:35:13,520 --> 00:35:17,120
actually use them because they're slow

00:35:14,990 --> 00:35:19,790
in Python we already have ways to do it

00:35:17,120 --> 00:35:22,130
attach things inside a class or in a

00:35:19,790 --> 00:35:23,570
module in the in space well if you were

00:35:22,130 --> 00:35:25,580
going to do it which I don't think you

00:35:23,570 --> 00:35:27,500
should you could do it with the name

00:35:25,580 --> 00:35:30,320
tupple so we can make a name topical

00:35:27,500 --> 00:35:33,910
color it has fields red orange green

00:35:30,320 --> 00:35:37,190
blue and indigo and I can go ahead and

00:35:33,910 --> 00:35:38,810
instantiate that and assign a value to

00:35:37,190 --> 00:35:42,140
each one of these so now we have color

00:35:38,810 --> 00:35:43,880
red is zero color green is three presto

00:35:42,140 --> 00:35:45,860
enumerated type we've learned something

00:35:43,880 --> 00:35:48,980
new who also learned that they shouldn't

00:35:45,860 --> 00:35:51,980
do it alright Python does not need

00:35:48,980 --> 00:35:53,870
enumerated types that is a feature that

00:35:51,980 --> 00:35:55,430
is vital to statically compiled

00:35:53,870 --> 00:35:58,310
languages and almost entirely

00:35:55,430 --> 00:36:00,770
unnecessary in Python I think almost

00:35:58,310 --> 00:36:03,050
because there are some use cases where

00:36:00,770 --> 00:36:06,260
people have a lot of sets of constants

00:36:03,050 --> 00:36:07,700
of floating around and occasionally you

00:36:06,260 --> 00:36:09,470
might want to create yourself something

00:36:07,700 --> 00:36:10,820
that resembles some type of enumerator

00:36:09,470 --> 00:36:13,760
lookup but remember every time you do a

00:36:10,820 --> 00:36:15,830
dot in Python you're paying a price a

00:36:13,760 --> 00:36:17,780
lot of stuff goes on this is an operator

00:36:15,830 --> 00:36:19,490
just like brackets it's more expensive

00:36:17,780 --> 00:36:23,480
to other than just just a dictionary

00:36:19,490 --> 00:36:24,920
lookup well you're going to be pay the

00:36:23,480 --> 00:36:27,110
price if you want to say color dot red

00:36:24,920 --> 00:36:28,970
why not just use color underscore red

00:36:27,110 --> 00:36:34,040
make it a module variable don't pay the

00:36:28,970 --> 00:36:36,830
price okay cash

00:36:34,040 --> 00:36:40,610
this is a very simple cash recipe this

00:36:36,830 --> 00:36:44,090
is not Python 101 it is Python 102 day

00:36:40,610 --> 00:36:45,500
one so after people learns sets and

00:36:44,090 --> 00:36:47,180
dictionaries and strings and all of our

00:36:45,500 --> 00:36:49,610
native objects this we teach them sell

00:36:47,180 --> 00:36:52,490
way to make a cash so we supply a

00:36:49,610 --> 00:36:53,780
default argument cash I could have

00:36:52,490 --> 00:36:55,490
called this underscore cash to hint that

00:36:53,780 --> 00:36:56,990
is private because this function is not

00:36:55,490 --> 00:37:00,140
meant to be called with cash is an

00:36:56,990 --> 00:37:03,500
argument fit to be called with some

00:37:00,140 --> 00:37:05,180
arguments and its first step is to take

00:37:03,500 --> 00:37:07,490
these arguments and check to see if that

00:37:05,180 --> 00:37:09,910
Arg couple is in the cash dictionary if

00:37:07,490 --> 00:37:12,470
it is it just returns that value

00:37:09,910 --> 00:37:14,720
otherwise it'll go ahead and do the

00:37:12,470 --> 00:37:16,700
results of some large computation one

00:37:14,720 --> 00:37:19,250
that is time consuming or otherwise

00:37:16,700 --> 00:37:20,660
resource intensive take the result and

00:37:19,250 --> 00:37:24,590
instead of just returning it it'll store

00:37:20,660 --> 00:37:27,680
it in the cache this is a fantastic

00:37:24,590 --> 00:37:29,210
recipe it is Python 102 it is my hope

00:37:27,680 --> 00:37:31,460
that everyone in this room already knew

00:37:29,210 --> 00:37:36,650
how to do that so we learned something

00:37:31,460 --> 00:37:38,090
new Hey alright what's the problem with

00:37:36,650 --> 00:37:40,700
this technique this is a widely used

00:37:38,090 --> 00:37:43,430
taking you will see it in many many code

00:37:40,700 --> 00:37:47,510
bases you might have even seen it in the

00:37:43,430 --> 00:37:49,640
Python core till I got to it places with

00:37:47,510 --> 00:37:51,560
something better the problem is for

00:37:49,640 --> 00:37:53,210
long-running processes this could grow

00:37:51,560 --> 00:37:56,290
without bound the dictionary gets bigger

00:37:53,210 --> 00:38:01,460
and bigger and bigger and it never fries

00:37:56,290 --> 00:38:03,910
at oh you're running Gengo you put in

00:38:01,460 --> 00:38:06,440
one little function cache like this

00:38:03,910 --> 00:38:08,510
every day it gets hit one time add

00:38:06,440 --> 00:38:10,430
something to the dictionary and your

00:38:08,510 --> 00:38:11,870
long-running process one day falls over

00:38:10,430 --> 00:38:13,730
dead because it's eating up all memory

00:38:11,870 --> 00:38:16,310
for cache that you don't care about

00:38:13,730 --> 00:38:17,990
anymore what do we do about it we have

00:38:16,310 --> 00:38:21,230
to have some strategy for pulling things

00:38:17,990 --> 00:38:24,050
out and the popular strategy is called

00:38:21,230 --> 00:38:26,240
the LRU cache least recently used yeah I

00:38:24,050 --> 00:38:28,780
will set a bound that says I'll put no

00:38:26,240 --> 00:38:30,710
more than 100 items in the cache

00:38:28,780 --> 00:38:32,690
whenever there's a hundred there I will

00:38:30,710 --> 00:38:34,820
take the least recently used but one

00:38:32,690 --> 00:38:37,480
that matters to me the least toss it out

00:38:34,820 --> 00:38:37,480
and put the new one in

00:38:37,870 --> 00:38:44,150
well we provided in the standard library

00:38:40,910 --> 00:38:47,720
as a decorator so you take your big

00:38:44,150 --> 00:38:50,900
computation code and add

00:38:47,720 --> 00:38:55,609
you cash just forehead presto you have a

00:38:50,900 --> 00:38:57,950
cash function that doesn't grow without

00:38:55,609 --> 00:38:59,840
bound and you had to add one line to

00:38:57,950 --> 00:39:02,599
your program an explicit line that says

00:38:59,840 --> 00:39:05,540
this particular function or method is

00:39:02,599 --> 00:39:07,270
cashed to a maximum size of 100 who

00:39:05,540 --> 00:39:10,220
thinks that's a fantastic tool to have

00:39:07,270 --> 00:39:11,810
in your toolbox unfortunately comes in

00:39:10,220 --> 00:39:13,010
later versions of Python and I

00:39:11,810 --> 00:39:14,330
understand some of you are running

00:39:13,010 --> 00:39:16,040
earlier versions of Python so what are

00:39:14,330 --> 00:39:18,230
you going to do you're going to go to

00:39:16,040 --> 00:39:21,320
the newer Docs let's say the Python 3 2

00:39:18,230 --> 00:39:21,800
dots you look and func tools see how it

00:39:21,320 --> 00:39:23,270
works

00:39:21,800 --> 00:39:24,680
after having read the docs you will

00:39:23,270 --> 00:39:26,660
click on the link and it will take you

00:39:24,680 --> 00:39:31,099
to a recipe for a version of this that

00:39:26,660 --> 00:39:33,470
one is just fine on Python 2 5 I found 2

00:39:31,099 --> 00:39:35,090
6 you will copy that into your utils

00:39:33,470 --> 00:39:38,900
directory and then you two can write

00:39:35,090 --> 00:39:42,560
that 1 line fair enough you learn

00:39:38,900 --> 00:39:44,420
something new all right I couldn't tell

00:39:42,560 --> 00:39:45,050
you how it was implemented but it's so

00:39:44,420 --> 00:39:50,720
darn easy

00:39:45,050 --> 00:39:52,130
I used order dictionary once you've got

00:39:50,720 --> 00:39:57,700
an order dictionary it takes very few

00:39:52,130 --> 00:39:58,910
lines to change this recipe into that

00:39:57,700 --> 00:40:01,520
enough

00:39:58,910 --> 00:40:03,200
oh wait some of you are on versions of

00:40:01,520 --> 00:40:06,140
Python that don't even have an order

00:40:03,200 --> 00:40:07,490
dictionary what are you gonna do I'm

00:40:06,140 --> 00:40:09,320
gonna go to the docs for collections

00:40:07,490 --> 00:40:11,089
look at order dictionary see how it

00:40:09,320 --> 00:40:13,280
works it's only like 2 paragraphs long

00:40:11,089 --> 00:40:14,900
it's very easy to learn then you want to

00:40:13,280 --> 00:40:16,910
click on the link and it will take you

00:40:14,900 --> 00:40:18,890
to the code for an order dictionary that

00:40:16,910 --> 00:40:20,119
runs on the old version of Python so now

00:40:18,890 --> 00:40:24,680
you've got an ordered dictionary and an

00:40:20,119 --> 00:40:28,580
LRU cache ok so that's how you implement

00:40:24,680 --> 00:40:29,720
it what do we do next let's push it to

00:40:28,580 --> 00:40:31,010
the outer limits let's see if we can

00:40:29,720 --> 00:40:32,030
shoot the say in the stratosphere let's

00:40:31,010 --> 00:40:34,310
see if we can do something cool with it

00:40:32,030 --> 00:40:36,710
because you can already imagine that big

00:40:34,310 --> 00:40:38,330
computation is you're going out hitting

00:40:36,710 --> 00:40:40,730
your database over and over again for

00:40:38,330 --> 00:40:42,200
the same lookups so the big computation

00:40:40,730 --> 00:40:45,320
here is actually saving load on your

00:40:42,200 --> 00:40:46,820
database by caching 100 most hit

00:40:45,320 --> 00:40:49,040
it could be something that's going up

00:40:46,820 --> 00:40:50,930
looking at URLs on the net so simply by

00:40:49,040 --> 00:40:52,460
adding that one line you produce your

00:40:50,930 --> 00:40:53,960
amount of net traffic you know how

00:40:52,460 --> 00:40:56,119
longer have to worry about latency and

00:40:53,960 --> 00:40:59,030
get a nice performance speed-up those

00:40:56,119 --> 00:41:02,710
are the obvious uses who knows the

00:40:59,030 --> 00:41:02,710
origin of the term dynamic programming

00:41:02,910 --> 00:41:11,230
back in the big one ww2 there was a

00:41:07,960 --> 00:41:13,210
group of people who were devoting

00:41:11,230 --> 00:41:17,859
themselves to trying to find more

00:41:13,210 --> 00:41:19,660
efficient ways to allocate resources and

00:41:17,859 --> 00:41:22,359
whenever they use the word optimization

00:41:19,660 --> 00:41:24,010
are talked about mathematics the

00:41:22,359 --> 00:41:27,430
generals that they reported to their

00:41:24,010 --> 00:41:27,970
eyes glazed over and refused to fund the

00:41:27,430 --> 00:41:29,859
project

00:41:27,970 --> 00:41:31,420
it's simple seem like somebody was just

00:41:29,859 --> 00:41:34,230
drawing symbols on the board and not

00:41:31,420 --> 00:41:37,210
actually contributing to the war effort

00:41:34,230 --> 00:41:39,160
though the head of that project embedded

00:41:37,210 --> 00:41:40,480
the term dynamic programming it's

00:41:39,160 --> 00:41:44,770
something that actually sounded like

00:41:40,480 --> 00:41:47,109
they were it was closer to we're moving

00:41:44,770 --> 00:41:49,150
boxes around or reloading a truck or

00:41:47,109 --> 00:41:50,740
something that sounded much more warlike

00:41:49,150 --> 00:41:53,109
and that is the origin of the term

00:41:50,740 --> 00:41:56,380
dynamic programming it is no more

00:41:53,109 --> 00:41:57,940
significant than that so this is an

00:41:56,380 --> 00:42:01,660
example of a catastrophic liebe add

00:41:57,940 --> 00:42:06,369
function that has some virtues so the

00:42:01,660 --> 00:42:08,440
Fibonacci function recursive twice for

00:42:06,369 --> 00:42:10,569
era for each call to it and then it goes

00:42:08,440 --> 00:42:13,359
back in the curse is again so if you

00:42:10,569 --> 00:42:16,049
were to enter this with notching 100 it

00:42:13,359 --> 00:42:20,109
would not finish in your lifetime are

00:42:16,049 --> 00:42:22,720
the lifetime of the universe makes a

00:42:20,109 --> 00:42:24,520
long time to run that's doing a lot of

00:42:22,720 --> 00:42:26,020
recursive calls doing the same lookups

00:42:24,520 --> 00:42:27,970
over and over again what is the

00:42:26,020 --> 00:42:29,049
advantage of writing Fibonacci like this

00:42:27,970 --> 00:42:31,510
because there's a lot of ways to write

00:42:29,049 --> 00:42:34,059
it one of the advantages Vantage's is it

00:42:31,510 --> 00:42:36,250
corresponds exactly to the way we first

00:42:34,059 --> 00:42:39,040
speech people what a Fibonacci function

00:42:36,250 --> 00:42:41,740
is once again you're taking a theme here

00:42:39,040 --> 00:42:44,020
the English problem statement and the

00:42:41,740 --> 00:42:46,089
code start looked the same so I don't

00:42:44,020 --> 00:42:47,950
want to rewrite this with an alternative

00:42:46,089 --> 00:42:49,660
Fibonacci not that it's a particularly

00:42:47,950 --> 00:42:51,880
important function but you get the gist

00:42:49,660 --> 00:42:53,440
I want to write my function the way I

00:42:51,880 --> 00:42:56,619
want to write it for a reason but I'd

00:42:53,440 --> 00:43:00,790
like it to be fast so I add a Tele you

00:42:56,619 --> 00:43:04,150
cash as a decorator before and now it

00:43:00,790 --> 00:43:06,099
memorizes the previous calls if you're

00:43:04,150 --> 00:43:08,680
out on an interview it's very common to

00:43:06,099 --> 00:43:10,599
give people programming tests now and to

00:43:08,680 --> 00:43:12,790
check to see if you're a whippersnapper

00:43:10,599 --> 00:43:14,560
programming genius they'll check to see

00:43:12,790 --> 00:43:16,150
if you know dynamic programming

00:43:14,560 --> 00:43:18,580
how are you going to answer the question

00:43:16,150 --> 00:43:21,250
you could go in and build up these

00:43:18,580 --> 00:43:23,740
little internal lists and do things to

00:43:21,250 --> 00:43:25,060
build stacks that shrink and grow which

00:43:23,740 --> 00:43:26,740
is the answer they're expecting because

00:43:25,060 --> 00:43:29,800
it shows off your amazing programming

00:43:26,740 --> 00:43:31,630
skill I like to do when I get those

00:43:29,800 --> 00:43:33,430
tests and amazingly I get them even for

00:43:31,630 --> 00:43:35,200
consulting assignments we know who you

00:43:33,430 --> 00:43:36,130
are we're hiring you as a consultant but

00:43:35,200 --> 00:43:37,690
we're going to see if you can write a

00:43:36,130 --> 00:43:40,150
Fibonacci function and do it in a

00:43:37,690 --> 00:43:41,530
dynamic programming style it comes up so

00:43:40,150 --> 00:43:43,840
I like to give them code that looks like

00:43:41,530 --> 00:43:45,220
this snippet at LRU cache in front of it

00:43:43,840 --> 00:43:53,350
and they have a hard time convincing

00:43:45,220 --> 00:43:55,510
themselves that it works so we have a

00:43:53,350 --> 00:44:08,470
tool for that what is it

00:43:55,510 --> 00:44:12,430
ctrl shift + emo big all right

00:44:08,470 --> 00:44:16,900
is our Fibonacci function let's check it

00:44:12,430 --> 00:44:18,670
Python 3.2 - him who knows about the - M

00:44:16,900 --> 00:44:22,240
option that goes up and looks up modules

00:44:18,670 --> 00:44:30,820
like binds the trace module which we you

00:44:22,240 --> 00:44:39,880
asked it for coverage of py and cover is

00:44:30,820 --> 00:44:43,000
not the magic word is its count don't

00:44:39,880 --> 00:44:44,440
off the screen yep yeah I see the two

00:44:43,000 --> 00:44:47,880
dots I just can't see what the two dots

00:44:44,440 --> 00:44:47,880
are so I'm going to shrink the screen

00:44:49,109 --> 00:44:57,099
okay all right that happens to be the

00:44:55,150 --> 00:44:59,680
answer to the Fibonacci call from Fabio

00:44:57,099 --> 00:45:01,240
100 so you can get some idea why there

00:44:59,680 --> 00:45:05,940
was a lot of computation there but it

00:45:01,240 --> 00:45:09,369
created a new file for me call 500 cover

00:45:05,940 --> 00:45:10,900
never uses before it's pretty easy to

00:45:09,369 --> 00:45:14,109
use which is why I want to show it off

00:45:10,900 --> 00:45:16,060
here it gives my program back to me but

00:45:14,109 --> 00:45:17,440
it prefixes it with the count of the

00:45:16,060 --> 00:45:19,990
number of times each function was called

00:45:17,440 --> 00:45:25,510
so it tells me that because of the LRU

00:45:19,990 --> 00:45:28,060
cache I only had 101 calls here it

00:45:25,510 --> 00:45:32,339
thinks it's fantastic as a number

00:45:28,060 --> 00:45:36,609
without the LRU cache is a little bigger

00:45:32,339 --> 00:45:38,099
alright good learned a new technique yes

00:45:36,609 --> 00:45:41,770
sir

00:45:38,099 --> 00:45:44,550
where does count come from or how does

00:45:41,770 --> 00:45:44,550
it get the counts

00:45:49,280 --> 00:45:56,570
oh no it's been in for a long time tres

00:45:53,360 --> 00:46:02,620
has been around for a good while tres

00:45:56,570 --> 00:46:02,620
support goes back bris what Python - a

00:46:02,770 --> 00:46:08,960
long time maybe before even tre supports

00:46:07,910 --> 00:46:18,290
been there forever

00:46:08,960 --> 00:46:19,850
Armen might come alright so who's very

00:46:18,290 --> 00:46:21,590
impressed with LRU cache is think they

00:46:19,850 --> 00:46:24,500
can do something new and Jedi like with

00:46:21,590 --> 00:46:26,540
it alright so it has good everyday uses

00:46:24,500 --> 00:46:28,820
solves dynamic programming problems and

00:46:26,540 --> 00:46:32,150
you've learned to use trace to produce

00:46:28,820 --> 00:46:33,680
coverage reports for your programming so

00:46:32,150 --> 00:46:34,760
what about here it gives Moses not in

00:46:33,680 --> 00:46:37,010
collections it's the new string

00:46:34,760 --> 00:46:43,070
formatting syntax and if you have been

00:46:37,010 --> 00:46:44,960
to my API design class you know why it's

00:46:43,070 --> 00:46:46,880
important that we had it you know all of

00:46:44,960 --> 00:46:48,920
the things that were wrong with the

00:46:46,880 --> 00:46:50,060
percent formatting style so I'm going to

00:46:48,920 --> 00:46:51,740
show you the new formatting because how

00:46:50,060 --> 00:46:54,590
many of you have adopted this is your

00:46:51,740 --> 00:46:57,560
new preferred style surprising the

00:46:54,590 --> 00:46:59,360
number of you still that leaves about

00:46:57,560 --> 00:47:01,430
80% of the audience hasn't touched it

00:46:59,360 --> 00:47:03,170
yet so I have a feeling that if I show

00:47:01,430 --> 00:47:05,030
it to you walk you through those first

00:47:03,170 --> 00:47:08,930
steps you will now adopt it as your

00:47:05,030 --> 00:47:11,330
primary tour so I can now pass in

00:47:08,930 --> 00:47:13,880
positional arguments ten and twenty and

00:47:11,330 --> 00:47:17,030
by using curly brackets reference them

00:47:13,880 --> 00:47:18,620
so zero and one we'll pull out the

00:47:17,030 --> 00:47:21,950
trouble position zero argument at

00:47:18,620 --> 00:47:23,600
position one easy enough just like the

00:47:21,950 --> 00:47:25,580
positional arguments with the percent

00:47:23,600 --> 00:47:27,890
formatting you're used to but without

00:47:25,580 --> 00:47:29,540
percent s's instead it's just curly

00:47:27,890 --> 00:47:33,590
brackets already it looks slightly

00:47:29,540 --> 00:47:36,620
cleaner now we look down and pass in

00:47:33,590 --> 00:47:39,050
keyword arguments which is nice because

00:47:36,620 --> 00:47:41,750
I can look them up by name page curly

00:47:39,050 --> 00:47:43,640
brackets page curly brackets line is

00:47:41,750 --> 00:47:45,950
that beautiful that is way better

00:47:43,640 --> 00:47:47,300
looking than percent formatting and one

00:47:45,950 --> 00:47:50,240
of the nice things about it is percent

00:47:47,300 --> 00:47:52,190
formatting is just complicated enough to

00:47:50,240 --> 00:47:53,990
where you only show it to programmers no

00:47:52,190 --> 00:47:56,660
one ever exposes that to the end user

00:47:53,990 --> 00:47:58,160
for templates this is simple enough to

00:47:56,660 --> 00:48:00,080
where you can show end-users templates

00:47:58,160 --> 00:48:02,809
like that so they can format their own

00:48:00,080 --> 00:48:04,699
pages so if you have a Jane

00:48:02,809 --> 00:48:07,549
you might want this the users can

00:48:04,699 --> 00:48:10,969
customize the look of the page I think

00:48:07,549 --> 00:48:12,729
it's beautiful but those are powers we

00:48:10,969 --> 00:48:16,159
already have do we get anything new

00:48:12,729 --> 00:48:17,869
matter fact yes we get indexing an

00:48:16,159 --> 00:48:21,079
attribute lookup I'm gonna complete an

00:48:17,869 --> 00:48:22,880
empty person class assign an attribute

00:48:21,079 --> 00:48:24,349
their last name there's lots of ways to

00:48:22,880 --> 00:48:25,849
do this we could have made name tuples

00:48:24,349 --> 00:48:26,839
we could have very rich objects the

00:48:25,849 --> 00:48:29,539
important thing is there's some

00:48:26,839 --> 00:48:32,150
attribute we can look up I can now

00:48:29,539 --> 00:48:35,559
reference that in my curly brackets I

00:48:32,150 --> 00:48:38,659
put P dot last name that's kind of neat

00:48:35,559 --> 00:48:42,109
especially if you have a longer string

00:48:38,659 --> 00:48:44,239
where you pass in one P single argument

00:48:42,109 --> 00:48:50,469
I have multiple references to it inside

00:48:44,239 --> 00:48:53,150
o P dot first name last name P dot title

00:48:50,469 --> 00:48:56,150
PHP dot Department all those things you

00:48:53,150 --> 00:48:58,009
pass in one argument but use it many

00:48:56,150 --> 00:49:01,369
times who thinks that's fantastic

00:48:58,009 --> 00:49:04,669
alright now you can also use tuple of

00:49:01,369 --> 00:49:07,669
cell access so you can give me position

00:49:04,669 --> 00:49:08,929
zero and position one and but we don't

00:49:07,669 --> 00:49:13,809
do that anymore because we use name

00:49:08,929 --> 00:49:15,650
tuples all right it probably does not

00:49:13,809 --> 00:49:17,989
surprise you that we can do a little

00:49:15,650 --> 00:49:20,380
formatting control in this so i put a

00:49:17,989 --> 00:49:21,859
colon after and provide some

00:49:20,380 --> 00:49:24,079
specifications of how this should

00:49:21,859 --> 00:49:28,909
pronounce if I put colon eight it will

00:49:24,079 --> 00:49:30,890
have this two eight characters there are

00:49:28,909 --> 00:49:32,569
if you look at the the shape of these

00:49:30,890 --> 00:49:34,219
three symbols up here one is left angle

00:49:32,569 --> 00:49:35,809
bracket one's the carrot ones the right

00:49:34,219 --> 00:49:36,919
angle bracket essentially they're like

00:49:35,809 --> 00:49:38,119
arrow is pointing in a different

00:49:36,919 --> 00:49:40,009
direction that's the way to remember

00:49:38,119 --> 00:49:42,169
that the left angle brackets is pushed

00:49:40,009 --> 00:49:44,509
to the left side the Hat says go to the

00:49:42,169 --> 00:49:46,669
middle and the right angle bracket are

00:49:44,509 --> 00:49:48,319
the default pushes to the right easy

00:49:46,669 --> 00:49:51,469
enough so you can control the alignment

00:49:48,319 --> 00:49:53,150
no more ljust are just in center you

00:49:51,469 --> 00:49:55,939
actually specify the format in the

00:49:53,150 --> 00:49:58,249
correct place not in the code but in the

00:49:55,939 --> 00:49:59,959
template that and the template is really

00:49:58,249 --> 00:50:02,029
concerned about layout so you move

00:49:59,959 --> 00:50:02,659
layout information in the template where

00:50:02,029 --> 00:50:04,640
it belongs

00:50:02,659 --> 00:50:06,589
I believe that's an improvement and then

00:50:04,640 --> 00:50:08,150
you can also prefix this with some

00:50:06,589 --> 00:50:09,769
character to say what the fill character

00:50:08,150 --> 00:50:11,900
is so instead of padding with spaces you

00:50:09,769 --> 00:50:15,410
can pad with number signs or whatnot I

00:50:11,900 --> 00:50:17,550
think that's kind of cool all right

00:50:15,410 --> 00:50:19,140
now some of this is not terribly

00:50:17,550 --> 00:50:21,089
surprising to those of you familiar with

00:50:19,140 --> 00:50:22,230
the details of present formatting you

00:50:21,089 --> 00:50:24,900
know this has this to still be on a

00:50:22,230 --> 00:50:27,300
format pie we tell it with leading zeros

00:50:24,900 --> 00:50:29,339
taking a total of eight spaces out to

00:50:27,300 --> 00:50:30,930
two decimal points and print the sign

00:50:29,339 --> 00:50:32,520
regardless whether it's positive or

00:50:30,930 --> 00:50:33,710
negative but a minus there it'll only to

00:50:32,520 --> 00:50:36,450
the minus if it's negative

00:50:33,710 --> 00:50:38,220
straightforward stuff next one's kind of

00:50:36,450 --> 00:50:40,020
new and special though something just

00:50:38,220 --> 00:50:40,530
happened something new you haven't seen

00:50:40,020 --> 00:50:43,730
before

00:50:40,530 --> 00:50:48,180
I wrote a pep on this there's a comma

00:50:43,730 --> 00:50:53,369
now I have a thousand separator what

00:50:48,180 --> 00:50:57,750
about people in Europe I tried to sell

00:50:53,369 --> 00:51:00,270
cuido on all types of ways to indicate

00:50:57,750 --> 00:51:02,400
what the thousand separator should be

00:51:00,270 --> 00:51:06,930
problem is thousand separator changes

00:51:02,400 --> 00:51:08,369
and then the the decimal point changes

00:51:06,930 --> 00:51:09,420
and then there are different grouping

00:51:08,369 --> 00:51:11,010
conventions I learned there's some

00:51:09,420 --> 00:51:12,690
countries where the thousands separators

00:51:11,010 --> 00:51:14,670
really ten thousand separators or a

00:51:12,690 --> 00:51:17,940
hundred thousand separators there are

00:51:14,670 --> 00:51:19,559
ISO standard for grouping up act to the

00:51:17,940 --> 00:51:24,390
right of the decimal point in groups of

00:51:19,559 --> 00:51:26,700
five cuido decided let's do the simplest

00:51:24,390 --> 00:51:28,200
thing that can possibly work make this

00:51:26,700 --> 00:51:29,670
so that people can remember how to

00:51:28,200 --> 00:51:32,250
insert it in so if there's just one

00:51:29,670 --> 00:51:33,750
control character so that all the things

00:51:32,250 --> 00:51:35,490
that implement their own for matters

00:51:33,750 --> 00:51:37,020
only have to understand one control

00:51:35,490 --> 00:51:41,130
character and then we will leave it up

00:51:37,020 --> 00:51:44,430
to users to use dot replace now how do

00:51:41,130 --> 00:51:47,730
you replace the commas with the the

00:51:44,430 --> 00:51:50,160
periods here well it's the three-way

00:51:47,730 --> 00:51:52,049
dance and the three-way dance says in

00:51:50,160 --> 00:51:56,309
order to exchange the two things that

00:51:52,049 --> 00:51:58,829
I'm in my hands I need the exchange here

00:51:56,309 --> 00:52:00,630
is I put in the temporary location I

00:51:58,829 --> 00:52:03,530
move this one to this one I pull this

00:52:00,630 --> 00:52:06,720
back up fair enough

00:52:03,530 --> 00:52:09,890
though I would replace the period with

00:52:06,720 --> 00:52:09,890
something like an exclamation point

00:52:09,950 --> 00:52:17,700
place the commas with a period replace

00:52:13,230 --> 00:52:19,230
the exclamation point comma kind of a

00:52:17,700 --> 00:52:19,650
nuisance what you want to do that over

00:52:19,230 --> 00:52:23,910
and over again

00:52:19,650 --> 00:52:27,390
no you make a function called friendship

00:52:23,910 --> 00:52:32,070
I it there manif I it

00:52:27,390 --> 00:52:33,210
African eyes it Asian if I it with me

00:52:32,070 --> 00:52:34,920
okay

00:52:33,210 --> 00:52:36,360
that was we does recommend a solution to

00:52:34,920 --> 00:52:40,890
the problem and it has the virtue of at

00:52:36,360 --> 00:52:42,300
least being simple questions suggestions

00:52:40,890 --> 00:52:51,050
come a certain place yes sir

00:52:42,300 --> 00:52:51,050
I had many proposals cuido approved one

00:52:51,830 --> 00:52:58,680
there were lots of ways to skin this cat

00:52:55,250 --> 00:53:00,060
the problem is if you look at the

00:52:58,680 --> 00:53:01,680
description of how we write these

00:53:00,060 --> 00:53:03,810
strings of all the possibilities is

00:53:01,680 --> 00:53:05,820
already reached a complexity limit that

00:53:03,810 --> 00:53:07,050
says any addition to it actually makes

00:53:05,820 --> 00:53:09,990
it worse rather than better

00:53:07,050 --> 00:53:12,270
even though we add a new capability the

00:53:09,990 --> 00:53:15,660
ease-of-use matters more than the extra

00:53:12,270 --> 00:53:19,100
capability its Python day one to be able

00:53:15,660 --> 00:53:19,100
to to fix this thing

00:53:19,610 --> 00:53:23,820
what there's another way you could use

00:53:22,440 --> 00:53:26,880
the locale module where there's already

00:53:23,820 --> 00:53:28,970
support for this and if you're in one of

00:53:26,880 --> 00:53:32,780
my classes other classes you know how to

00:53:28,970 --> 00:53:35,910
handle the fact that locale is global

00:53:32,780 --> 00:53:37,440
setting and so there's some issues there

00:53:35,910 --> 00:53:39,180
that need to be resolved but locale will

00:53:37,440 --> 00:53:41,120
take care of this stuff for you so I

00:53:39,180 --> 00:53:45,420
think we are at the question period

00:53:41,120 --> 00:53:55,280
alright so can you go to the end of a

00:53:45,420 --> 00:54:02,880
counter okay when there is the subtract

00:53:55,280 --> 00:54:06,200
previous light previous light oh these

00:54:02,880 --> 00:54:06,200
are pretty slice I'm going backwards

00:54:06,290 --> 00:54:11,430
alright so where did there is a sub

00:54:08,910 --> 00:54:15,240
structure where there is a sub struct of

00:54:11,430 --> 00:54:17,250
counter yes a subtraction okay so this

00:54:15,240 --> 00:54:18,330
is here are two subtracting slides yeah

00:54:17,250 --> 00:54:20,520
exactly

00:54:18,330 --> 00:54:26,760
this one yeah so I was a little confused

00:54:20,520 --> 00:54:29,880
since in the upper part you say subtract

00:54:26,760 --> 00:54:32,700
T that's a difference to counter and

00:54:29,880 --> 00:54:37,530
then in the example you show that you

00:54:32,700 --> 00:54:39,130
take to name it arguments with the

00:54:37,530 --> 00:54:43,119
subtract method

00:54:39,130 --> 00:54:45,160
okay so subtract method uh will accept

00:54:43,119 --> 00:54:47,289
named arguments it will also accept

00:54:45,160 --> 00:54:48,700
another counter so I have spared you

00:54:47,289 --> 00:54:51,729
from going and creating another counter

00:54:48,700 --> 00:54:53,229
because the way on named arguments work

00:54:51,729 --> 00:54:54,910
are they create a dictionary

00:54:53,229 --> 00:54:57,220
what is the counter it's just a

00:54:54,910 --> 00:54:59,289
dictionary so there was no sense in once

00:54:57,220 --> 00:55:01,119
somebody provided ake one and C equal

00:54:59,289 --> 00:55:04,720
one there was no sense and then wrapping

00:55:01,119 --> 00:55:06,999
a counter around it before I before I go

00:55:04,720 --> 00:55:11,259
on so I could have put the word counter

00:55:06,999 --> 00:55:13,119
here right there to create an internal

00:55:11,259 --> 00:55:15,339
counter to subtracted to but I can also

00:55:13,119 --> 00:55:17,979
do it directly by keyword arguments it

00:55:15,339 --> 00:55:20,259
was just a simpler API either would work

00:55:17,979 --> 00:55:23,049
does that answer the question or no yeah

00:55:20,259 --> 00:55:25,019
actually no I see the difference between

00:55:23,049 --> 00:55:27,489
this problem and the problem of

00:55:25,019 --> 00:55:29,710
positional arguments of that yes okay

00:55:27,489 --> 00:55:32,440
there to develop suffusing me because it

00:55:29,710 --> 00:55:37,319
was looking similar at the first sight

00:55:32,440 --> 00:55:37,319
fair enough anything else yes sir

00:55:50,230 --> 00:55:54,220
okay so we discussed before the reason

00:55:52,210 --> 00:55:56,980
for the under oh in stead of regular

00:55:54,220 --> 00:55:59,680
instantiation I could have could have

00:55:56,980 --> 00:56:02,410
done that what make is for is and you

00:55:59,680 --> 00:56:04,480
learned in my API class earlier this

00:56:02,410 --> 00:56:06,160
week whenever there's a need for two

00:56:04,480 --> 00:56:07,690
different types of constructors one

00:56:06,160 --> 00:56:09,520
worth positional arguments and other

00:56:07,690 --> 00:56:11,770
with interval the correct answer is

00:56:09,520 --> 00:56:14,020
always to provide both so the default

00:56:11,770 --> 00:56:16,960
for a name tuple is you'd be able to

00:56:14,020 --> 00:56:19,000
take color and say color open paren one

00:56:16,960 --> 00:56:23,920
two three whatever separate fields but

00:56:19,000 --> 00:56:25,900
if you already have a tuple made in this

00:56:23,920 --> 00:56:28,150
case range you know has an input that is

00:56:25,900 --> 00:56:30,609
already an iterable the way I passed

00:56:28,150 --> 00:56:32,440
that in it is with make so it's just an

00:56:30,609 --> 00:56:35,530
alternate form so I could have here

00:56:32,440 --> 00:56:37,690
eliminated the make with open brackets

00:56:35,530 --> 00:56:42,130
and used to star so it saves you from

00:56:37,690 --> 00:56:44,260
start unpacking make is less useful in

00:56:42,130 --> 00:56:46,960
this context star probably would have

00:56:44,260 --> 00:56:48,609
been better for this example place where

00:56:46,960 --> 00:56:51,670
make is really useful is if you have a

00:56:48,609 --> 00:56:54,099
giant list of tuples and you're casting

00:56:51,670 --> 00:56:55,960
them all to your name tuple like you've

00:56:54,099 --> 00:56:57,700
got a query back from a sequel database

00:56:55,960 --> 00:57:00,970
and you would have named couple eyes all

00:56:57,700 --> 00:57:04,329
of them you run it through map with make

00:57:00,970 --> 00:57:05,920
and it converts all of them over because

00:57:04,329 --> 00:57:07,720
otherwise you'd have to build a list

00:57:05,920 --> 00:57:09,099
comprehension you'd do a star on every

00:57:07,720 --> 00:57:11,140
one of them which would unpack it on the

00:57:09,099 --> 00:57:14,230
stack just to rebuild it back again

00:57:11,140 --> 00:57:19,630
they'd be terribly inefficient and that

00:57:14,230 --> 00:57:22,569
wouldn't be any fun and joggle is the

00:57:19,630 --> 00:57:26,140
new formatting back button to 2.7 I

00:57:22,569 --> 00:57:28,750
believe it is oh one other thought on

00:57:26,140 --> 00:57:33,869
the new formatting should you use the

00:57:28,750 --> 00:57:37,119
new formatting of the old formatting yes

00:57:33,869 --> 00:57:39,160
alright so whenever you see a format

00:57:37,119 --> 00:57:41,470
somebody present you with some type of

00:57:39,160 --> 00:57:43,630
formatting like how did it bash we use a

00:57:41,470 --> 00:57:46,180
dollar sign which raises the question

00:57:43,630 --> 00:57:47,349
how do I omit a dollar sign there needs

00:57:46,180 --> 00:57:50,829
to be some way to escape it and the

00:57:47,349 --> 00:57:52,960
answer is to dollar signs is one all

00:57:50,829 --> 00:57:54,940
right how do i omit a percent with

00:57:52,960 --> 00:57:57,280
regular percent formatting i escape it

00:57:54,940 --> 00:57:59,079
by doing % percent which is a real

00:57:57,280 --> 00:58:01,119
problem if i'm going to apply the format

00:57:59,079 --> 00:58:02,310
in multiple successive stages it because

00:58:01,119 --> 00:58:05,460
i've been i need

00:58:02,310 --> 00:58:08,280
% % % run it through one level takes it

00:58:05,460 --> 00:58:10,860
down to two and then leaves one what do

00:58:08,280 --> 00:58:13,590
we do for the new cell formatting how do

00:58:10,860 --> 00:58:15,450
we escape curly brackets we double them

00:58:13,590 --> 00:58:20,370
up curly bracket curly bracket who hates

00:58:15,450 --> 00:58:22,080
that I do how do you deal with it way I

00:58:20,370 --> 00:58:25,710
deal with this I used new and the old

00:58:22,080 --> 00:58:28,350
formatting all right so if I have a %

00:58:25,710 --> 00:58:29,580
and so sometimes I want to format a

00:58:28,350 --> 00:58:33,180
string that actually has formatting

00:58:29,580 --> 00:58:36,210
inside it and whenever I need to do that

00:58:33,180 --> 00:58:37,710
I do the innermost one with the old

00:58:36,210 --> 00:58:38,970
style formatting and the other one with

00:58:37,710 --> 00:58:41,250
the old side and that way I don't have

00:58:38,970 --> 00:58:44,790
any escaping who thinks that's no

00:58:41,250 --> 00:58:46,770
wonderful little technique and if you

00:58:44,790 --> 00:58:49,890
work on it for awhile you take that

00:58:46,770 --> 00:58:51,300
technique and try any capsulate and

00:58:49,890 --> 00:58:53,070
describe it in a sentence and it's

00:58:51,300 --> 00:58:55,170
crunch to send it to make the word small

00:58:53,070 --> 00:58:56,520
and scrunch in scrunch it after a great

00:58:55,170 --> 00:58:58,560
deal of effort you can compress it into

00:58:56,520 --> 00:58:59,700
less than 140 characters in which case

00:58:58,560 --> 00:59:01,830
you could share it with the world in the

00:58:59,700 --> 00:59:04,800
tweet how could you have found out about

00:59:01,830 --> 00:59:07,080
this before this class if you follow my

00:59:04,800 --> 00:59:10,770
Twitter stream you'll get tips like this

00:59:07,080 --> 00:59:12,630
every day at Raymond H and I'm sorry we

00:59:10,770 --> 00:59:18,020
should stop here for this detour now

00:59:12,630 --> 00:59:18,020

YouTube URL: https://www.youtube.com/watch?v=twrNGyl1sbc


