Title: Python 103: Mmmm... Understanding Python's Memory Model, Mutability, and Methods
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] wesley chun - 22 June 2011 in "Track Lasagne"
Captions: 
	00:00:02,070 --> 00:00:13,289
was it to him alright so today I'm gonna

00:00:09,780 --> 00:00:16,230
talk about a little bit more sort of

00:00:13,289 --> 00:00:18,359
under the covers how Python works and

00:00:16,230 --> 00:00:22,080
you probably you probably read the

00:00:18,359 --> 00:00:27,560
description in the in the on the website

00:00:22,080 --> 00:00:29,759
or or in the conference guidebook that

00:00:27,560 --> 00:00:31,230
now you get you get to a certain point

00:00:29,759 --> 00:00:33,810
in your Python programming where you

00:00:31,230 --> 00:00:36,690
know you're pretty smart you figured out

00:00:33,810 --> 00:00:38,730
how to use Python you used it for

00:00:36,690 --> 00:00:41,699
several months or maybe like one or two

00:00:38,730 --> 00:00:43,110
years now and you think you understand

00:00:41,699 --> 00:00:44,520
it pretty well you know the syntax

00:00:43,110 --> 00:00:47,309
pretty well you've done all these kind

00:00:44,520 --> 00:00:48,690
of things with it but sometimes you run

00:00:47,309 --> 00:00:50,760
into these issues that you don't have

00:00:48,690 --> 00:00:52,680
time to debug where Python doesn't act

00:00:50,760 --> 00:00:55,590
the way you think it should and you're

00:00:52,680 --> 00:00:58,260
you know perfectly convinced that your

00:00:55,590 --> 00:01:00,390
program is you know your Europe code is

00:00:58,260 --> 00:01:01,859
absolutely correct the Python still

00:01:00,390 --> 00:01:05,570
doesn't behave in the way that you think

00:01:01,859 --> 00:01:08,189
it should so hopefully some of the

00:01:05,570 --> 00:01:10,590
information I have today for you will

00:01:08,189 --> 00:01:12,600
help to sort of explain those things to

00:01:10,590 --> 00:01:14,400
give you more of an idea of how things

00:01:12,600 --> 00:01:16,560
work under the covers all right so

00:01:14,400 --> 00:01:19,979
that's the main goal so if you haven't

00:01:16,560 --> 00:01:21,960
been to editing my talks yet at your

00:01:19,979 --> 00:01:24,090
Python it's a little bit of background

00:01:21,960 --> 00:01:25,380
about me I've been programming Python

00:01:24,090 --> 00:01:28,500
for a while but you know there's a lot

00:01:25,380 --> 00:01:30,509
of information to read here so in all my

00:01:28,500 --> 00:01:32,700
talks I just say don't read this because

00:01:30,509 --> 00:01:34,860
it's too confusing the most important

00:01:32,700 --> 00:01:37,470
things to know about me or that I like

00:01:34,860 --> 00:01:41,970
to teach especially Python so I teach at

00:01:37,470 --> 00:01:44,100
companies I teach at conferences I write

00:01:41,970 --> 00:01:45,899
so I'm one of those weird programmers

00:01:44,100 --> 00:01:48,030
that actually likes to write so I have

00:01:45,899 --> 00:01:50,880
like one or two books out there you may

00:01:48,030 --> 00:01:53,040
have seen them already but the most

00:01:50,880 --> 00:01:55,110
important thing about me is that I'm a

00:01:53,040 --> 00:01:56,729
software engineer so I code and I've

00:01:55,110 --> 00:01:59,189
done all kinds of crazy things with

00:01:56,729 --> 00:02:03,090
Python and if you're curious about how I

00:01:59,189 --> 00:02:04,710
got started I was on the original Yahoo

00:02:03,090 --> 00:02:07,590
Mail engineering team where we built

00:02:04,710 --> 00:02:09,180
most of it with Python 14 years ago when

00:02:07,590 --> 00:02:12,330
no one ever heard of Python before so

00:02:09,180 --> 00:02:14,670
it's quite interesting the back end mail

00:02:12,330 --> 00:02:16,650
store was C++ but all of the middleware

00:02:14,670 --> 00:02:19,950
the main application that was all Python

00:02:16,650 --> 00:02:23,220
so that was my first experience with

00:02:19,950 --> 00:02:27,360
Python many years ago so anyway so about

00:02:23,220 --> 00:02:29,580
this talk and about you guys so there's

00:02:27,360 --> 00:02:32,760
gonna be like sort of four main parts

00:02:29,580 --> 00:02:35,700
the first part is sort of like not as

00:02:32,760 --> 00:02:37,620
related to the rest of the talk so it's

00:02:35,700 --> 00:02:39,510
sort of introduction for people you know

00:02:37,620 --> 00:02:41,130
for people who are getting here after

00:02:39,510 --> 00:02:45,060
the beginning so it's sort of like a

00:02:41,130 --> 00:02:46,830
bonus material all right so that's the

00:02:45,060 --> 00:02:48,480
thing about the first part so I'm going

00:02:46,830 --> 00:02:50,850
to talk about special methods to make

00:02:48,480 --> 00:02:52,980
your classes act like Python data types

00:02:50,850 --> 00:02:55,260
that you're used to using so after that

00:02:52,980 --> 00:02:58,140
sort of bonus section then we get to the

00:02:55,260 --> 00:03:00,239
real reason why you're here okay so

00:02:58,140 --> 00:03:01,739
again about you guys you have some

00:03:00,239 --> 00:03:04,769
Python experience you still don't

00:03:01,739 --> 00:03:07,290
understand weird behavior you know

00:03:04,769 --> 00:03:08,610
things that you can't explain well and

00:03:07,290 --> 00:03:10,110
you want to learn more of the internal

00:03:08,610 --> 00:03:12,930
stuff okay so that's sort of like the

00:03:10,110 --> 00:03:15,120
main reason why why I made this talk of

00:03:12,930 --> 00:03:18,060
course when I made this talk originally

00:03:15,120 --> 00:03:19,650
you know when I did the the proposal for

00:03:18,060 --> 00:03:21,209
this talk I said oh you know what I

00:03:19,650 --> 00:03:23,549
think I only have half an hour of

00:03:21,209 --> 00:03:25,500
material maybe I can stretch it to 45

00:03:23,549 --> 00:03:28,890
minutes and then the program committee

00:03:25,500 --> 00:03:32,100
assigned me to a 90 minute talk so I had

00:03:28,890 --> 00:03:35,610
to graft an entire half of this talk

00:03:32,100 --> 00:03:38,100
together so halfway through this talk I

00:03:35,610 --> 00:03:42,180
have to go and make some new slides okay

00:03:38,100 --> 00:03:43,470
so you'll you'll see that okay so let's

00:03:42,180 --> 00:03:45,030
talk about special methods first so this

00:03:43,470 --> 00:03:46,709
is the bonus part so if you come in late

00:03:45,030 --> 00:03:48,360
and you kind of skip this part it's kind

00:03:46,709 --> 00:03:51,060
of okay alright but it's kind of fun

00:03:48,360 --> 00:03:53,489
because I like I like showing people how

00:03:51,060 --> 00:03:55,410
to make their objects act like Python

00:03:53,489 --> 00:03:57,510
types because it's a very fun thing to

00:03:55,410 --> 00:03:59,010
do alright so since you guys already

00:03:57,510 --> 00:04:01,290
know some Python than you already know

00:03:59,010 --> 00:04:03,030
how to create a class right so here's an

00:04:01,290 --> 00:04:06,260
example of a very simple class where I'm

00:04:03,030 --> 00:04:10,019
creating an address book entry okay

00:04:06,260 --> 00:04:11,880
right here is there a way to dim the

00:04:10,019 --> 00:04:13,769
lights for the front part to see it

00:04:11,880 --> 00:04:17,400
better or okay that would be great

00:04:13,769 --> 00:04:21,060
that's okay so this is a very basic

00:04:17,400 --> 00:04:27,790
basic class so that

00:04:21,060 --> 00:04:30,040
it's easy to read right every go okay so

00:04:27,790 --> 00:04:31,990
there's a constructor or initializer we

00:04:30,040 --> 00:04:34,180
don't say constructor in Python because

00:04:31,990 --> 00:04:37,150
we know Python manages memory for F so

00:04:34,180 --> 00:04:39,580
it's an initializer Python constructs

00:04:37,150 --> 00:04:42,130
our object for us and after it makes the

00:04:39,580 --> 00:04:44,200
object it calls under under in it as the

00:04:42,130 --> 00:04:46,419
very first method to pre-process it and

00:04:44,200 --> 00:04:47,980
then python gives it the object back to

00:04:46,419 --> 00:04:50,290
you so that's why we call it an

00:04:47,980 --> 00:04:52,810
initializer instead of constructor okay

00:04:50,290 --> 00:04:54,700
so you can see it takes two parameters a

00:04:52,810 --> 00:04:56,410
name and phone number there is a third

00:04:54,700 --> 00:04:58,180
of course which is even card self

00:04:56,410 --> 00:04:59,620
argument you know a lot of people

00:04:58,180 --> 00:05:01,060
complained that you know why do I have

00:04:59,620 --> 00:05:04,750
to type itself all the time well it's

00:05:01,060 --> 00:05:06,550
because we do' wants it that way okay to

00:05:04,750 --> 00:05:08,200
be more explicit okay that's very

00:05:06,550 --> 00:05:09,820
important you know where things come

00:05:08,200 --> 00:05:12,130
from where things are going because you

00:05:09,820 --> 00:05:13,600
can see self dot name if this was not

00:05:12,130 --> 00:05:15,639
required and you all of a sudden saw

00:05:13,600 --> 00:05:20,080
self dot name ago where did it come from

00:05:15,639 --> 00:05:21,669
right so anyway so when you good okay so

00:05:20,080 --> 00:05:23,290
it's a you scratch my back I scratch

00:05:21,669 --> 00:05:24,700
your back kind of a thing I know there's

00:05:23,290 --> 00:05:27,729
probably some way to say that in Italian

00:05:24,700 --> 00:05:29,770
I just don't know what it is alright but

00:05:27,729 --> 00:05:31,810
since you went out of your way to put

00:05:29,770 --> 00:05:33,610
itself as the first argument when you

00:05:31,810 --> 00:05:36,610
call methods you don't have to

00:05:33,610 --> 00:05:38,080
explicitly pass it in okay so you did

00:05:36,610 --> 00:05:38,860
something nice for Python Python will do

00:05:38,080 --> 00:05:41,560
something nice for you

00:05:38,860 --> 00:05:43,960
alright so when we create instances of

00:05:41,560 --> 00:05:45,190
this address book entry type we only

00:05:43,960 --> 00:05:47,200
have to pass in the name of the phone

00:05:45,190 --> 00:05:48,940
number and then we have a method here to

00:05:47,200 --> 00:05:50,350
update a phone number so you just pass

00:05:48,940 --> 00:05:51,700
in a new phone number and that gets of

00:05:50,350 --> 00:05:53,560
science but there's a very basic class

00:05:51,700 --> 00:05:55,479
that you can pretty much understand and

00:05:53,560 --> 00:05:57,490
you can also see I also have a static

00:05:55,479 --> 00:06:00,010
class a member too alright everybody

00:05:57,490 --> 00:06:01,840
know what a static class member is it's

00:06:00,010 --> 00:06:05,050
a it's an attribute that is shared

00:06:01,840 --> 00:06:07,510
amongst all instances all right so once

00:06:05,050 --> 00:06:09,639
you make a change to this class this

00:06:07,510 --> 00:06:12,160
class attribute all the instances are

00:06:09,639 --> 00:06:14,830
going to see that new version number if

00:06:12,160 --> 00:06:17,910
you were to upgrade that okay all right

00:06:14,830 --> 00:06:17,910
so that's the important stuff

00:06:24,870 --> 00:06:33,490
okay all right so let's take a temporary

00:06:29,880 --> 00:06:36,790
sidetrack here so how many of you have a

00:06:33,490 --> 00:06:39,130
computer science background yeah okay

00:06:36,790 --> 00:06:41,440
that's most people right so when I say

00:06:39,130 --> 00:06:43,120
something like called by reference or

00:06:41,440 --> 00:06:45,580
called by value that makes sense to you

00:06:43,120 --> 00:06:47,290
right so that's a very easy question for

00:06:45,580 --> 00:06:48,940
people to ask when they're learning the

00:06:47,290 --> 00:06:51,580
language so is Python called by

00:06:48,940 --> 00:06:55,360
reference or call by value the problem

00:06:51,580 --> 00:06:57,550
is this type of thinking doesn't really

00:06:55,360 --> 00:06:58,870
apply to Python okay it's you can think

00:06:57,550 --> 00:07:01,600
that you could say that it's it's

00:06:58,870 --> 00:07:04,060
neither because it doesn't obey these

00:07:01,600 --> 00:07:06,250
two rules but you can also say that it's

00:07:04,060 --> 00:07:09,220
both because depending on the type of

00:07:06,250 --> 00:07:10,780
object it may do one thing for what

00:07:09,220 --> 00:07:12,580
certain types of objects but it'll do

00:07:10,780 --> 00:07:15,160
something else for other types of

00:07:12,580 --> 00:07:17,590
objects okay so we already know that

00:07:15,160 --> 00:07:19,480
Python objects are always passed by

00:07:17,590 --> 00:07:22,120
reference always right that's just the

00:07:19,480 --> 00:07:24,400
way the rules are okay the thing is

00:07:22,120 --> 00:07:26,950
though that if you have a mutable object

00:07:24,400 --> 00:07:28,750
okay aliases act like pointers it really

00:07:26,950 --> 00:07:32,650
you know when you make a change in that

00:07:28,750 --> 00:07:33,850
function the caller you know with that

00:07:32,650 --> 00:07:36,880
data structure will see that change

00:07:33,850 --> 00:07:38,830
right so in that sense it's like call by

00:07:36,880 --> 00:07:41,050
reference but if you pass in an

00:07:38,830 --> 00:07:45,220
immutable object like a string or a

00:07:41,050 --> 00:07:46,990
number and the function changes that

00:07:45,220 --> 00:07:49,210
variable well you know because it's

00:07:46,990 --> 00:07:51,820
immutable it really just gets redirected

00:07:49,210 --> 00:07:53,800
and point to another object right so

00:07:51,820 --> 00:07:55,630
it's like call-by-value because that

00:07:53,800 --> 00:07:58,360
change is not reflected in the caller

00:07:55,630 --> 00:07:59,710
okay so that's why python is both in

00:07:58,360 --> 00:08:01,419
this case but it's really neither

00:07:59,710 --> 00:08:04,390
because it doesn't kind of adhere to

00:08:01,419 --> 00:08:07,930
that but you know the in reality that

00:08:04,390 --> 00:08:11,169
everything is is is a call by value of

00:08:07,930 --> 00:08:12,669
the reference all right really right

00:08:11,169 --> 00:08:14,050
because it's a pointer it's a number

00:08:12,669 --> 00:08:17,400
that number doesn't change because it's

00:08:14,050 --> 00:08:19,900
immutable but it is a reference right so

00:08:17,400 --> 00:08:21,100
so anyway so whenever your friends are

00:08:19,900 --> 00:08:22,870
learning Python and they ask you the

00:08:21,100 --> 00:08:25,450
same question now you can give them this

00:08:22,870 --> 00:08:27,520
direct answer in Python it's more

00:08:25,450 --> 00:08:29,590
important to talk about the mutability

00:08:27,520 --> 00:08:32,890
of an object than it is talking about

00:08:29,590 --> 00:08:34,330
calling convention okay all right so

00:08:32,890 --> 00:08:35,830
that's enough of the side but just you

00:08:34,330 --> 00:08:36,729
know keep that in mind I had to add this

00:08:35,830 --> 00:08:38,740
extra stuff

00:08:36,729 --> 00:08:40,000
in there because you know people ask all

00:08:38,740 --> 00:08:41,199
the time right you have to have it clear

00:08:40,000 --> 00:08:42,550
in your head okay

00:08:41,199 --> 00:08:43,719
nobody explained this to me when I was

00:08:42,550 --> 00:08:44,850
learning Python it would have been nice

00:08:43,719 --> 00:08:47,560
all right

00:08:44,850 --> 00:08:50,019
okay let's go back to our class so let's

00:08:47,560 --> 00:08:51,160
create some instances so we know that

00:08:50,019 --> 00:08:53,139
you know when you create an instance you

00:08:51,160 --> 00:08:55,180
call the class as if it was a function

00:08:53,139 --> 00:08:57,880
there's no new keyword lecture isn't

00:08:55,180 --> 00:08:58,690
like Java or C++ and you pass in the

00:08:57,880 --> 00:09:01,839
name and phone number

00:08:58,690 --> 00:09:03,670
okay that's fine now we can call those

00:09:01,839 --> 00:09:06,430
attributes those instance attributes

00:09:03,670 --> 00:09:08,920
that we defined earlier okay because now

00:09:06,430 --> 00:09:11,380
we have self which is our instance now

00:09:08,920 --> 00:09:14,260
we can call them directly by name okay

00:09:11,380 --> 00:09:15,610
so that's great now one thing that makes

00:09:14,260 --> 00:09:17,470
Python different from other

00:09:15,610 --> 00:09:18,699
object-oriented programming languages

00:09:17,470 --> 00:09:21,310
that is that you can have dynamic

00:09:18,699 --> 00:09:22,720
instance attributes so immediately I can

00:09:21,310 --> 00:09:24,940
just create something from scratch

00:09:22,720 --> 00:09:27,940
that's completely different that was not

00:09:24,940 --> 00:09:30,370
in any of the code back here okay so

00:09:27,940 --> 00:09:32,050
this tattoo did not show up anywhere but

00:09:30,370 --> 00:09:34,779
now instantly I can give John a tattoo

00:09:32,050 --> 00:09:38,920
but Jane doesn't have one right so it's

00:09:34,779 --> 00:09:40,870
completely different alright so so we

00:09:38,920 --> 00:09:42,100
know that address book entry version is

00:09:40,870 --> 00:09:43,750
a class attribute it's one of those

00:09:42,100 --> 00:09:46,149
static class members right you just

00:09:43,750 --> 00:09:47,800
talked about that I mean yeah sure look

00:09:46,149 --> 00:09:49,870
we can use our instance to get access to

00:09:47,800 --> 00:09:52,870
it okay that's great

00:09:49,870 --> 00:09:55,899
the thing is though I still would prefer

00:09:52,870 --> 00:09:57,430
you to use address book entries version

00:09:55,899 --> 00:09:59,319
instead of calling it through the

00:09:57,430 --> 00:10:02,319
instance because I want you to always

00:09:59,319 --> 00:10:04,060
think that that is a class member not an

00:10:02,319 --> 00:10:06,190
instance member the only reason why you

00:10:04,060 --> 00:10:08,440
have this is that there's a sort of a

00:10:06,190 --> 00:10:10,959
courtesy lookup because if I don't have

00:10:08,440 --> 00:10:13,720
it I want to check if the the class that

00:10:10,959 --> 00:10:15,160
I was instantiated from has it so it's

00:10:13,720 --> 00:10:19,750
one of those things that Python gives

00:10:15,160 --> 00:10:21,550
you is a polite bonus all right but what

00:10:19,750 --> 00:10:25,480
happens when I do this which you cannot

00:10:21,550 --> 00:10:27,670
see okay all right because you can't see

00:10:25,480 --> 00:10:31,079
it it actually says John version equals

00:10:27,670 --> 00:10:36,430
one point zero what happens in that case

00:10:31,079 --> 00:10:40,600
did I change my class one you didn't you

00:10:36,430 --> 00:10:42,310
created a new tattoo okay so if I do to

00:10:40,600 --> 00:10:45,310
print John that version yes I will get

00:10:42,310 --> 00:10:48,160
one point oh no but if I print Jane

00:10:45,310 --> 00:10:49,410
version she is still looking at the

00:10:48,160 --> 00:10:52,229
class one

00:10:49,410 --> 00:10:55,019
not the instance dynamic attribute that

00:10:52,229 --> 00:10:58,309
I've just made okay this is a source of

00:10:55,019 --> 00:11:01,019
a lot of bugs when you're using the

00:10:58,309 --> 00:11:02,759
instance to refer to a static class

00:11:01,019 --> 00:11:04,709
member and you assign to it you're

00:11:02,759 --> 00:11:07,049
really not assigning to it what you're

00:11:04,709 --> 00:11:11,189
really doing is creating a local

00:11:07,049 --> 00:11:14,999
variable and you are hiding access to

00:11:11,189 --> 00:11:17,909
the globe to the global one this global

00:11:14,999 --> 00:11:19,199
one okay so it's it's like it's it

00:11:17,909 --> 00:11:22,349
you've removed this thing from your

00:11:19,199 --> 00:11:25,769
scope can't get access to this one

00:11:22,349 --> 00:11:27,869
unless of course you go back and use

00:11:25,769 --> 00:11:29,399
address book entry dot version like I

00:11:27,869 --> 00:11:31,109
originally suggested then you won't have

00:11:29,399 --> 00:11:32,809
this problem then you wouldn't have an

00:11:31,109 --> 00:11:36,599
unexplained bug in your code

00:11:32,809 --> 00:11:38,369
hey everybody understand that okay

00:11:36,599 --> 00:11:39,479
pretty important this catches a lot of

00:11:38,369 --> 00:11:43,349
beginners as well

00:11:39,479 --> 00:11:46,439
so I did so so my job is to create more

00:11:43,349 --> 00:11:49,829
bug free Python programmers okay that's

00:11:46,439 --> 00:11:51,539
you guys all right okay good so you know

00:11:49,829 --> 00:11:53,249
what's really funny and I would do if I

00:11:51,539 --> 00:11:56,009
had the whiteboard here so if I had the

00:11:53,249 --> 00:11:57,720
whiteboard here I would say if you did

00:11:56,009 --> 00:11:59,399
this it would actually work if you did

00:11:57,720 --> 00:12:01,379
like print john dot version print john

00:11:59,399 --> 00:12:03,389
dot version and then i did john dot

00:12:01,379 --> 00:12:05,159
version equals 1.0 and then i did print

00:12:03,389 --> 00:12:07,649
john dot version again and so i would

00:12:05,159 --> 00:12:10,679
output the 1.0 but if right after that

00:12:07,649 --> 00:12:13,619
output i did del of john dot version and

00:12:10,679 --> 00:12:15,209
then print john dot version i actually

00:12:13,619 --> 00:12:18,149
won't get an error i'll actually get

00:12:15,209 --> 00:12:21,029
this again because now I've removed the

00:12:18,149 --> 00:12:22,409
local variable I did add L on it del

00:12:21,029 --> 00:12:24,600
john dot version I got rid of the

00:12:22,409 --> 00:12:26,489
dynamic instance attribute so now when I

00:12:24,600 --> 00:12:28,169
do print John divergent now it's gonna

00:12:26,489 --> 00:12:29,369
go I don't have one so I'm gonna go look

00:12:28,169 --> 00:12:31,409
at the class one so now you're getting

00:12:29,369 --> 00:12:34,289
back to the zero point one so it looks

00:12:31,409 --> 00:12:36,539
really weird to see code that says print

00:12:34,289 --> 00:12:38,159
john dot version i mean del john dot

00:12:36,539 --> 00:12:39,509
version and then print john dot version

00:12:38,159 --> 00:12:42,629
right after that and have it still work

00:12:39,509 --> 00:12:44,309
right it just looks very odd but that's

00:12:42,629 --> 00:12:47,489
what you're doing you're removing that

00:12:44,309 --> 00:12:51,059
local reference that dynamic instance

00:12:47,489 --> 00:12:55,159
attribute okay everybody got it okay

00:12:51,059 --> 00:12:55,159
good question

00:12:58,740 --> 00:13:02,440
okay so what if thought the question is

00:13:00,940 --> 00:13:04,000
what if I perform a delete on the

00:13:02,440 --> 00:13:08,320
instance well if I delete the entire

00:13:04,000 --> 00:13:11,830
instance then oh if you delete the

00:13:08,320 --> 00:13:13,839
attribute again you should okay so the

00:13:11,830 --> 00:13:15,640
question is what if I do another del

00:13:13,839 --> 00:13:18,160
john dot version what do I get out of

00:13:15,640 --> 00:13:20,290
that that's a very good question and I

00:13:18,160 --> 00:13:23,410
actually haven't tried that yet but my

00:13:20,290 --> 00:13:27,700
guess is that you would actually get

00:13:23,410 --> 00:13:29,050
sort of a local error you get inception

00:13:27,700 --> 00:13:31,390
okay so this gentleman here says you

00:13:29,050 --> 00:13:33,339
would get an exception so I agree with

00:13:31,390 --> 00:13:39,310
that because you're trying to remove

00:13:33,339 --> 00:13:39,700
something that it's not there okay all

00:13:39,310 --> 00:13:41,950
right

00:13:39,700 --> 00:13:44,470
good actually try it you know if you

00:13:41,950 --> 00:13:46,870
have your laptop try it there's nothing

00:13:44,470 --> 00:13:51,130
like seeing the source code beat the

00:13:46,870 --> 00:13:53,320
sword though all right so let's talk

00:13:51,130 --> 00:13:54,880
about a subclass now so we all know how

00:13:53,320 --> 00:13:57,700
to create sub classes you know

00:13:54,880 --> 00:13:59,350
subclasses inherits everything from the

00:13:57,700 --> 00:14:01,450
base or parent class and you can

00:13:59,350 --> 00:14:03,820
customize it by tweaking it a little bit

00:14:01,450 --> 00:14:06,190
to make it different from the class that

00:14:03,820 --> 00:14:08,440
you inherited from right so one thing

00:14:06,190 --> 00:14:11,170
you have to keep in mind is that if you

00:14:08,440 --> 00:14:14,260
do want to if you override any of the

00:14:11,170 --> 00:14:16,209
methods like like the initializer it

00:14:14,260 --> 00:14:18,089
doesn't call the base class one so if

00:14:16,209 --> 00:14:19,930
you really want to call the parent class

00:14:18,089 --> 00:14:22,540
under-under in it you have to do it

00:14:19,930 --> 00:14:24,550
explicitly like I did here okay so this

00:14:22,540 --> 00:14:26,380
is employer address book entry which is

00:14:24,550 --> 00:14:27,930
a subclass of address book entry so I'm

00:14:26,380 --> 00:14:31,000
going to have two more informations like

00:14:27,930 --> 00:14:32,170
employee ID and you know in America we

00:14:31,000 --> 00:14:37,540
use social security number to identify

00:14:32,170 --> 00:14:39,790
ourselves to the government okay so so

00:14:37,540 --> 00:14:41,020
so this one is slightly different from

00:14:39,790 --> 00:14:43,150
the address book entry because I have

00:14:41,020 --> 00:14:46,330
two new pieces of data now what you

00:14:43,150 --> 00:14:47,980
could do instead of doing this I could

00:14:46,330 --> 00:14:49,510
have just copied the code I could have

00:14:47,980 --> 00:14:51,910
just copied the self dot name equals

00:14:49,510 --> 00:14:53,890
name self that phone equals phone okay

00:14:51,910 --> 00:14:55,779
but what if your original initializer

00:14:53,890 --> 00:14:58,180
was more complicated right what if it

00:14:55,779 --> 00:15:00,790
was a big block of code now I'm going to

00:14:58,180 --> 00:15:02,620
cut and paste that into my subclass well

00:15:00,790 --> 00:15:03,880
that's not good practice right because

00:15:02,620 --> 00:15:05,860
what if you had a bug in that original

00:15:03,880 --> 00:15:08,020
one now you've got that bug in two

00:15:05,860 --> 00:15:08,730
places okay so you really don't want to

00:15:08,020 --> 00:15:10,680
cut and

00:15:08,730 --> 00:15:13,260
it's code from your base classes okay

00:15:10,680 --> 00:15:16,470
you really want to just call the parent

00:15:13,260 --> 00:15:18,300
class version of that to set it up and

00:15:16,470 --> 00:15:20,699
then you can do your own class

00:15:18,300 --> 00:15:22,260
customization afterwards is to do the

00:15:20,699 --> 00:15:24,720
you know the special stuff for this

00:15:22,260 --> 00:15:26,070
particular class right right you

00:15:24,720 --> 00:15:29,399
everybody understand that don't cut in

00:15:26,070 --> 00:15:31,529
pace code it's really bad okay so the

00:15:29,399 --> 00:15:33,360
way you do that is you actually call the

00:15:31,529 --> 00:15:36,060
initializer for the base class

00:15:33,360 --> 00:15:39,329
explicitly like this now the only catch

00:15:36,060 --> 00:15:40,829
is that if if you have studied Python

00:15:39,329 --> 00:15:42,899
and you know you learned it pretty well

00:15:40,829 --> 00:15:45,410
you understand that Python has the

00:15:42,899 --> 00:15:48,060
concept of bounds versus unbound methods

00:15:45,410 --> 00:15:49,290
okay and the difference is when it's

00:15:48,060 --> 00:15:50,459
unbound that means you just have the

00:15:49,290 --> 00:15:52,949
class and you have the method you don't

00:15:50,459 --> 00:15:54,269
have any instances okay as soon as you

00:15:52,949 --> 00:15:57,480
make an instance of a class

00:15:54,269 --> 00:15:59,279
now that object is bound to that

00:15:57,480 --> 00:16:01,709
instance and now I can call that method

00:15:59,279 --> 00:16:04,380
so technically you can't call a method

00:16:01,709 --> 00:16:07,110
unless it's bound really okay so I need

00:16:04,380 --> 00:16:09,420
to create John or Jane and now I have an

00:16:07,110 --> 00:16:11,550
instance I can call John update phone or

00:16:09,420 --> 00:16:13,410
Jane update phone if I just have address

00:16:11,550 --> 00:16:15,149
book entry by itself it doesn't make

00:16:13,410 --> 00:16:16,470
sense for me to go address book entry

00:16:15,149 --> 00:16:20,250
dot update phone because I don't have

00:16:16,470 --> 00:16:22,529
anybody's information to update right so

00:16:20,250 --> 00:16:24,269
the same thing applies for here I don't

00:16:22,529 --> 00:16:27,240
really have an instance of address book

00:16:24,269 --> 00:16:30,930
entry right I have an instance of

00:16:27,240 --> 00:16:33,300
employer address book entry okay but the

00:16:30,930 --> 00:16:35,339
thing is even though I don't have an

00:16:33,300 --> 00:16:37,769
instance of address book entry my

00:16:35,339 --> 00:16:40,110
instance of employer address book entry

00:16:37,769 --> 00:16:41,819
is the closest thing I have to an

00:16:40,110 --> 00:16:44,550
instance of address book entry it's just

00:16:41,819 --> 00:16:46,980
an instance of the subclass right so

00:16:44,550 --> 00:16:49,079
that's the only object I have that is

00:16:46,980 --> 00:16:51,569
the closest that I have to the original

00:16:49,079 --> 00:16:53,399
instance of the original base class so

00:16:51,569 --> 00:16:54,930
that's why I have to pass itself this

00:16:53,399 --> 00:16:56,339
time remember I told you that you don't

00:16:54,930 --> 00:16:58,769
have to pass itself when you're calling

00:16:56,339 --> 00:17:00,589
a method well you don't have to pass it

00:16:58,769 --> 00:17:02,670
in when you're calling a bound method

00:17:00,589 --> 00:17:04,679
okay that means that you know John

00:17:02,670 --> 00:17:06,600
update phone because I have the instance

00:17:04,679 --> 00:17:08,970
John here I don't have an instance John

00:17:06,600 --> 00:17:10,949
yet I'm actually trying to make an

00:17:08,970 --> 00:17:12,329
instance of employer address book entry

00:17:10,949 --> 00:17:14,160
but I don't have an instance of address

00:17:12,329 --> 00:17:17,159
book entry and because I'm trying to

00:17:14,160 --> 00:17:19,679
call an unbound function I need to

00:17:17,159 --> 00:17:21,850
explicitly pass in that instance that

00:17:19,679 --> 00:17:25,270
proxies that is a subject

00:17:21,850 --> 00:17:27,250
- for my lack of having an instance of

00:17:25,270 --> 00:17:29,050
address book injury so that's why self

00:17:27,250 --> 00:17:31,810
is the closest thing because self is an

00:17:29,050 --> 00:17:33,820
instance of employer just book entry so

00:17:31,810 --> 00:17:35,440
I'm passing that in as my argument so

00:17:33,820 --> 00:17:38,230
see I have to pass in three parameters

00:17:35,440 --> 00:17:40,240
now instead of two because I don't have

00:17:38,230 --> 00:17:45,010
an instance of address book entry so

00:17:40,240 --> 00:17:47,050
that's why I'm doing that okay so yeah

00:17:45,010 --> 00:17:49,000
so now that I've done that this will

00:17:47,050 --> 00:17:50,710
automatically do the self name and self

00:17:49,000 --> 00:17:52,600
doubt phone assignments as well as

00:17:50,710 --> 00:17:54,460
anything else you know if that if that

00:17:52,600 --> 00:17:56,260
method was more complicated then it will

00:17:54,460 --> 00:17:58,660
do all the other things and then I'm

00:17:56,260 --> 00:18:01,090
ready to add my employer employee idea

00:17:58,660 --> 00:18:03,370
in my you know social security number

00:18:01,090 --> 00:18:05,980
okay that make sense to everybody

00:18:03,370 --> 00:18:07,150
okay yes just say yes even if you don't

00:18:05,980 --> 00:18:09,670
get anything I just said

00:18:07,150 --> 00:18:18,940
okay good good good a question in the

00:18:09,670 --> 00:18:20,530
back ok so that's a good question so the

00:18:18,940 --> 00:18:22,930
question was sometimes I see the base

00:18:20,530 --> 00:18:24,670
class initializer or any base class

00:18:22,930 --> 00:18:28,690
method get call at the end of this one

00:18:24,670 --> 00:18:31,240
yeah so that so that that all depends on

00:18:28,690 --> 00:18:33,160
how this thing works okay so this thing

00:18:31,240 --> 00:18:35,650
for example you know create the database

00:18:33,160 --> 00:18:37,690
object maybe you don't want the the

00:18:35,650 --> 00:18:40,060
database saved to be called first

00:18:37,690 --> 00:18:41,890
because then I would lose this info so

00:18:40,060 --> 00:18:44,350
in that particular case I want to assign

00:18:41,890 --> 00:18:46,240
this additional data first and then call

00:18:44,350 --> 00:18:47,500
my base class initializer so that it

00:18:46,240 --> 00:18:48,850
assigns the name of the phone number and

00:18:47,500 --> 00:18:50,830
then perhaps stores it in the database

00:18:48,850 --> 00:18:52,840
so I have everything so it all depends

00:18:50,830 --> 00:18:54,190
on the context most of the time you call

00:18:52,840 --> 00:18:56,020
it first because you want to kind of get

00:18:54,190 --> 00:18:57,370
it ready and then you customize it but

00:18:56,020 --> 00:18:59,860
there may be cases like what I just

00:18:57,370 --> 00:19:01,450
described where no no you really do want

00:18:59,860 --> 00:19:02,830
to do your customization first and then

00:19:01,450 --> 00:19:05,140
do the other thing because the other

00:19:02,830 --> 00:19:07,090
thing has to execute with the new data

00:19:05,140 --> 00:19:10,950
as well okay does that answer your

00:19:07,090 --> 00:19:10,950
question okay so a question behind you

00:19:11,190 --> 00:19:16,270
didn't you use a super function yes you

00:19:14,560 --> 00:19:18,730
should use a super function if this is

00:19:16,270 --> 00:19:20,020
further down the line if it's just you

00:19:18,730 --> 00:19:21,820
know the immediate parent class you

00:19:20,020 --> 00:19:23,830
don't have to use super but you can and

00:19:21,820 --> 00:19:26,020
then a lot of beginners also don't

00:19:23,830 --> 00:19:30,160
understand super as well super is its

00:19:26,020 --> 00:19:33,640
own I won't say monster but its own

00:19:30,160 --> 00:19:34,990
beast okay so yeah so yeah if you're

00:19:33,640 --> 00:19:35,350
further down the tree you should use

00:19:34,990 --> 00:19:38,020
soup

00:19:35,350 --> 00:19:39,940
because it executes the MRO which helps

00:19:38,020 --> 00:19:43,810
you look up the actual object that you

00:19:39,940 --> 00:19:45,640
really should be the class the base

00:19:43,810 --> 00:19:47,410
class that you should be calling and

00:19:45,640 --> 00:19:51,960
another question in the front or closer

00:19:47,410 --> 00:19:51,960
Oh same question okay great

00:19:52,150 --> 00:20:00,940
no that's that's something I'd like

00:19:54,370 --> 00:20:03,010
Raymond to do because yeah yeah well and

00:20:00,940 --> 00:20:04,480
he just wrote a like a recent blog post

00:20:03,010 --> 00:20:07,300
on it like maybe a couple of weeks ago

00:20:04,480 --> 00:20:08,800
anyway but there isn't another blog post

00:20:07,300 --> 00:20:11,140
that you should read in addition to

00:20:08,800 --> 00:20:12,970
Raymond's too and that was the superest

00:20:11,140 --> 00:20:15,220
considered harmful one so you can see

00:20:12,970 --> 00:20:17,470
the opposing viewpoint and why you may

00:20:15,220 --> 00:20:19,180
not want to use super okay it's good to

00:20:17,470 --> 00:20:21,280
be balanced right because Lea for

00:20:19,180 --> 00:20:23,290
example I was born in America so when I

00:20:21,280 --> 00:20:24,610
learned about the Vietnam War I learned

00:20:23,290 --> 00:20:26,470
one side of the story

00:20:24,610 --> 00:20:28,270
it wasn't until ten years ago that I

00:20:26,470 --> 00:20:30,340
actually went to Vietnam got the other

00:20:28,270 --> 00:20:32,440
side of the story that now can make an

00:20:30,340 --> 00:20:34,240
educated opinion to form an educated

00:20:32,440 --> 00:20:36,070
opinion on what really happened kind of

00:20:34,240 --> 00:20:37,450
a thing right so it's really that you

00:20:36,070 --> 00:20:41,650
want to have both sides of the story

00:20:37,450 --> 00:20:48,910
before making conclusions okay there was

00:20:41,650 --> 00:20:51,040
a question up here uh-huh okay yes

00:20:48,910 --> 00:20:52,510
attribute error because so he tried to

00:20:51,040 --> 00:20:54,760
this gentleman tried to actually do the

00:20:52,510 --> 00:20:57,160
delete of John version again and he got

00:20:54,760 --> 00:20:58,780
an attribute error because the John

00:20:57,160 --> 00:21:01,540
instance did not have an attribute

00:20:58,780 --> 00:21:03,820
version and that's because the class has

00:21:01,540 --> 00:21:06,880
it the instance did not have it okay

00:21:03,820 --> 00:21:08,980
again it's yeah it's just it's just like

00:21:06,880 --> 00:21:11,980
like I said a courtesy lookup it really

00:21:08,980 --> 00:21:13,930
doesn't belong to that instance so okay

00:21:11,980 --> 00:21:17,230
great you guys are doing good learning

00:21:13,930 --> 00:21:20,410
something yes yes okay if you say no

00:21:17,230 --> 00:21:23,370
then I have some more okay one more

00:21:20,410 --> 00:21:23,370
question in the back or not

00:21:40,450 --> 00:21:43,650
Oh would you use super

00:21:56,450 --> 00:22:00,200
it should just it should just make when

00:21:58,730 --> 00:22:01,610
when you get super you're only gonna get

00:22:00,200 --> 00:22:06,200
one class back you're not gonna get

00:22:01,610 --> 00:22:07,670
multiple classes back refactoring a

00:22:06,200 --> 00:22:08,750
refactoring your existing code you

00:22:07,670 --> 00:22:10,610
because you don't have to think about

00:22:08,750 --> 00:22:11,060
which one it is yes that's right that's

00:22:10,610 --> 00:22:13,730
right

00:22:11,060 --> 00:22:14,930
yeah explicitly naming it's only in a

00:22:13,730 --> 00:22:16,970
very close situation where you know

00:22:14,930 --> 00:22:20,000
exactly what's going on but yes it sort

00:22:16,970 --> 00:22:21,470
of hides from you you know having to do

00:22:20,000 --> 00:22:24,620
the lookup yourself if you didn't

00:22:21,470 --> 00:22:28,690
already know what it was yeah all right

00:22:24,620 --> 00:22:31,460
okay so now let's do something more fun

00:22:28,690 --> 00:22:33,230
okay and that is making your instances

00:22:31,460 --> 00:22:35,750
act like Python types like a Python

00:22:33,230 --> 00:22:36,920
number a Python list a dictionary okay

00:22:35,750 --> 00:22:39,080
these things are very fun all right

00:22:36,920 --> 00:22:41,270
they're special class meth is made for

00:22:39,080 --> 00:22:42,830
this purpose by default they're not

00:22:41,270 --> 00:22:44,420
defined or you can think of them as

00:22:42,830 --> 00:22:45,950
defined but with a path so they don't

00:22:44,420 --> 00:22:48,050
really do anything okay

00:22:45,950 --> 00:22:51,800
and you really customize your class when

00:22:48,050 --> 00:22:53,990
you override these and and and process

00:22:51,800 --> 00:22:56,300
possibly overloading existing Python

00:22:53,990 --> 00:22:58,910
operators as well as built-in functions

00:22:56,300 --> 00:23:01,610
to be used for to manipulate your

00:22:58,910 --> 00:23:05,390
instances with okay for example you know

00:23:01,610 --> 00:23:08,330
one plus two that's great Foo quote plus

00:23:05,390 --> 00:23:09,860
bar quote okay so I'm adding numbers and

00:23:08,330 --> 00:23:11,660
then I'm concatenated strings to the

00:23:09,860 --> 00:23:14,000
plus sign is overloaded so it does

00:23:11,660 --> 00:23:16,400
something for numbers and it does

00:23:14,000 --> 00:23:17,750
something different for Strings so you

00:23:16,400 --> 00:23:19,970
can do the same thing with your classes

00:23:17,750 --> 00:23:22,040
you can make your in your instances use

00:23:19,970 --> 00:23:24,290
the plus sign and have it be a valid a

00:23:22,040 --> 00:23:26,000
valid thing all right so these are those

00:23:24,290 --> 00:23:27,800
special methods okay so we already know

00:23:26,000 --> 00:23:30,230
about under under init which is the

00:23:27,800 --> 00:23:32,390
initializer there's a special one

00:23:30,230 --> 00:23:34,580
special version of under internet called

00:23:32,390 --> 00:23:37,430
under under new and that's used when

00:23:34,580 --> 00:23:38,930
you're sub classing immutable objects so

00:23:37,430 --> 00:23:41,300
you know that immutable objects you

00:23:38,930 --> 00:23:44,270
cannot modify right but with under under

00:23:41,300 --> 00:23:46,190
in it it's it's fine because python

00:23:44,270 --> 00:23:47,930
makes the object for you it calls your

00:23:46,190 --> 00:23:49,760
under and earn it you can do your self

00:23:47,930 --> 00:23:51,890
name self that phone assignments you're

00:23:49,760 --> 00:23:53,900
actually changing that instance but if

00:23:51,890 --> 00:23:56,180
your object is immutable you can't do

00:23:53,900 --> 00:23:58,340
that right if you can't change this

00:23:56,180 --> 00:23:59,750
object because it's frozen I think I'm

00:23:58,340 --> 00:24:01,730
not gonna go and do a self dot name

00:23:59,750 --> 00:24:03,290
equals in a cell phone equals after that

00:24:01,730 --> 00:24:04,580
because it'll you know you're gonna get

00:24:03,290 --> 00:24:05,930
an argument you're gonna get an error

00:24:04,580 --> 00:24:07,790
you're gonna get an exception and I'll

00:24:05,930 --> 00:24:10,130
say something like you know cannot this

00:24:07,790 --> 00:24:12,950
an object is not support assignment

00:24:10,130 --> 00:24:14,630
okay and so to make up for that you use

00:24:12,950 --> 00:24:16,280
under under new because this is

00:24:14,630 --> 00:24:18,230
basically where you set up the creation

00:24:16,280 --> 00:24:20,450
of the object then you tell python to

00:24:18,230 --> 00:24:22,390
make it okay so it's kind of like you

00:24:20,450 --> 00:24:24,950
know when you're making a you know a

00:24:22,390 --> 00:24:27,350
popsicle you know you put your juice in

00:24:24,950 --> 00:24:28,580
the the ice tray you put the stick in it

00:24:27,350 --> 00:24:31,669
you put whatever you want in it then you

00:24:28,580 --> 00:24:33,200
put it in the freezer okay and then it

00:24:31,669 --> 00:24:35,840
comes out so this is kind of like that

00:24:33,200 --> 00:24:38,120
so before you freeze your object you set

00:24:35,840 --> 00:24:40,460
it up using under-under new so new is

00:24:38,120 --> 00:24:42,409
like an it but it's for when you're

00:24:40,460 --> 00:24:43,940
creating sub classic immutable objects

00:24:42,409 --> 00:24:46,520
and then there's a terminator which

00:24:43,940 --> 00:24:48,169
nobody uses because that has its own

00:24:46,520 --> 00:24:49,400
problems right everybody knows that

00:24:48,169 --> 00:24:52,370
you're not supposed to write terminators

00:24:49,400 --> 00:24:53,929
okay because you cannot predict when

00:24:52,370 --> 00:24:55,429
it's going to be called because it's

00:24:53,929 --> 00:24:57,590
only called when the reference count of

00:24:55,429 --> 00:24:58,970
your object goes to zero which is when

00:24:57,590 --> 00:25:00,200
no variables are interested in your

00:24:58,970 --> 00:25:02,570
object anymore it could be de-allocated

00:25:00,200 --> 00:25:04,250
so you can't predict that okay so that's

00:25:02,570 --> 00:25:05,900
one reason why you don't call the

00:25:04,250 --> 00:25:08,720
under-under del you don't know when it's

00:25:05,900 --> 00:25:10,370
going to execute furthermore let's say

00:25:08,720 --> 00:25:12,289
that your entire script is ending and

00:25:10,370 --> 00:25:14,440
python is going the interpreter is going

00:25:12,289 --> 00:25:17,419
through and hitting free on everything

00:25:14,440 --> 00:25:19,220
it's possible that by the time your

00:25:17,419 --> 00:25:21,470
reference count goes to zero and your

00:25:19,220 --> 00:25:23,480
undergird l is called that python has

00:25:21,470 --> 00:25:25,100
already freed objects that you're going

00:25:23,480 --> 00:25:27,380
to be that you're using inside your

00:25:25,100 --> 00:25:28,640
Terminator which results in an exception

00:25:27,380 --> 00:25:32,179
because those objects are no longer

00:25:28,640 --> 00:25:33,950
there so in under under Dells exceptions

00:25:32,179 --> 00:25:35,929
are ignored which is gonna be very bad

00:25:33,950 --> 00:25:37,549
right because you could be ignoring a

00:25:35,929 --> 00:25:39,169
real error situation or ubeat we're

00:25:37,549 --> 00:25:40,549
ignoring one of those oh my object was

00:25:39,169 --> 00:25:42,590
freed already but you don't know which

00:25:40,549 --> 00:25:44,450
one it is so that's why it's not

00:25:42,590 --> 00:25:46,039
recommended to use those all right if

00:25:44,450 --> 00:25:48,320
you do have to do some sort of exit

00:25:46,039 --> 00:25:51,049
thing there is an exit hook that you can

00:25:48,320 --> 00:25:52,640
use to kind of specify that all right so

00:25:51,049 --> 00:25:54,350
that's why you don't write under under

00:25:52,640 --> 00:25:56,000
Dells in fact when you look at the

00:25:54,350 --> 00:25:57,260
documentation if you have to go through

00:25:56,000 --> 00:25:59,570
the Python documentation and get this

00:25:57,260 --> 00:26:01,940
big warning box do not implement under

00:25:59,570 --> 00:26:04,280
under del okay unless you really really

00:26:01,940 --> 00:26:06,080
know what you're doing okay all right so

00:26:04,280 --> 00:26:07,760
enough of the you know the setup and the

00:26:06,080 --> 00:26:09,169
takedown stuff let's talk about some of

00:26:07,760 --> 00:26:12,200
the more interesting methods like under

00:26:09,169 --> 00:26:14,539
under STR so under under STR if you

00:26:12,200 --> 00:26:17,650
create this this method in your class

00:26:14,539 --> 00:26:20,840
definition you have just overloaded FCR

00:26:17,650 --> 00:26:22,040
to do a printable string representation

00:26:20,840 --> 00:26:23,660
of your object

00:26:22,040 --> 00:26:26,000
okay so I'll show an example about

00:26:23,660 --> 00:26:28,010
coming up but what that means is so

00:26:26,000 --> 00:26:29,030
everybody knows what what your objects

00:26:28,010 --> 00:26:31,630
look like let me see if I can just

00:26:29,030 --> 00:26:35,440
demonstrate that here really quickly

00:26:31,630 --> 00:26:39,860
because this is part of my delay tactic

00:26:35,440 --> 00:26:42,830
because I have 90 minutes I'm going very

00:26:39,860 --> 00:26:46,100
slowly by just starting the interpreter

00:26:42,830 --> 00:26:49,070
up it's gonna take a while which is

00:26:46,100 --> 00:26:54,620
great let's see how I'm doing on time oh

00:26:49,070 --> 00:26:57,110
my gosh I have a lot of time still okay

00:26:54,620 --> 00:27:01,310
so this takes a long time because I have

00:26:57,110 --> 00:27:04,190
a slow machine it's a PCE okay that came

00:27:01,310 --> 00:27:07,100
up faster than I thought I only have two

00:27:04,190 --> 00:27:13,100
gigs in this machine all right so let's

00:27:07,100 --> 00:27:17,540
create a class-c object and then I make

00:27:13,100 --> 00:27:21,980
one okay when I do prints see how is

00:27:17,540 --> 00:27:23,480
that useful to me all right

00:27:21,980 --> 00:27:26,780
it tells me what kind of object it is

00:27:23,480 --> 00:27:28,850
cool it tells me what the ID is that's

00:27:26,780 --> 00:27:30,800
pretty nice it doesn't tell me anything

00:27:28,850 --> 00:27:32,450
what if I do important stuff like I'm

00:27:30,800 --> 00:27:39,410
gonna put in my very important variables

00:27:32,450 --> 00:27:44,720
in here okay now let's print it and see

00:27:39,410 --> 00:27:49,370
all my new data what what happened to my

00:27:44,720 --> 00:27:55,450
data it doesn't do it I'm not getting

00:27:49,370 --> 00:27:55,450
any information out of this useless okay

00:28:02,920 --> 00:28:13,480
okay Harold that's great what are gonna

00:28:06,190 --> 00:28:14,860
do with that tell your friends yeah and

00:28:13,480 --> 00:28:18,370
you gonna put frame it and put it on the

00:28:14,860 --> 00:28:19,600
wall like art okay not pretty not very

00:28:18,370 --> 00:28:22,300
useful right why not

00:28:19,600 --> 00:28:25,210
so Oh see here's another inside tip did

00:28:22,300 --> 00:28:27,840
you know that when you call print on any

00:28:25,210 --> 00:28:33,280
object it's the same thing as doing

00:28:27,840 --> 00:28:36,550
doing sis standard out right of Str of

00:28:33,280 --> 00:28:40,000
that object do you guys know that STR is

00:28:36,550 --> 00:28:43,980
always called on a print okay always

00:28:40,000 --> 00:28:47,230
even if you didn't do it yourself

00:28:43,980 --> 00:28:51,430
okay so STR so the reason why I use

00:28:47,230 --> 00:28:55,630
print was because when I override

00:28:51,430 --> 00:28:58,210
under-under STR that makes it work with

00:28:55,630 --> 00:29:00,220
printing basically okay and the same

00:28:58,210 --> 00:29:03,220
thing goes for re PR all right you can

00:29:00,220 --> 00:29:05,800
hope you can create the under-under re

00:29:03,220 --> 00:29:08,020
PR method and that will overload re PR

00:29:05,800 --> 00:29:09,490
so you can use that for your right now

00:29:08,020 --> 00:29:12,880
it's kind of neat because I'm used to

00:29:09,490 --> 00:29:14,890
calling STR of quote 1 2 3 or STR of any

00:29:12,880 --> 00:29:17,290
other object now I can call STR on my

00:29:14,890 --> 00:29:20,320
instance which is kind of neat I think

00:29:17,290 --> 00:29:22,420
all right and then similarly let's talk

00:29:20,320 --> 00:29:24,160
about equals equals and not equals okay

00:29:22,420 --> 00:29:26,440
so what if I want to overload the equal

00:29:24,160 --> 00:29:28,450
sign what if I want to have the concept

00:29:26,440 --> 00:29:31,630
of my instance equals equals something

00:29:28,450 --> 00:29:33,760
else another object x equals equals y

00:29:31,630 --> 00:29:36,070
where x and y are both instances of my

00:29:33,760 --> 00:29:39,190
address book entry class or something ok

00:29:36,070 --> 00:29:41,170
so you can over override under under equ

00:29:39,190 --> 00:29:42,430
under under any and the same thing goes

00:29:41,170 --> 00:29:44,080
for greater than greater than equal to

00:29:42,430 --> 00:29:49,420
less than less than equal to so it's GE

00:29:44,080 --> 00:29:50,920
GTL elt under under ok so now my

00:29:49,420 --> 00:29:52,210
instances can work with those objects

00:29:50,920 --> 00:29:55,900
now it's starting to act like a Python

00:29:52,210 --> 00:29:57,760
type right okay and then for if I want

00:29:55,900 --> 00:30:00,370
to use the plus symbol all I have to do

00:29:57,760 --> 00:30:02,590
is over I yeah create the under under

00:30:00,370 --> 00:30:05,140
add method now I can have my instance

00:30:02,590 --> 00:30:07,300
plus something ok now if I want

00:30:05,140 --> 00:30:09,820
something plus my instance I have to

00:30:07,300 --> 00:30:12,700
also create under under our add for

00:30:09,820 --> 00:30:14,920
right hand side operations ok now if you

00:30:12,700 --> 00:30:16,650
have commutative objects which means 1

00:30:14,920 --> 00:30:18,750
plus 2 equals 2 plus 1 like

00:30:16,650 --> 00:30:20,790
numbers you would generally just make

00:30:18,750 --> 00:30:23,190
one of them and then make the the other

00:30:20,790 --> 00:30:24,930
one like you would create undergrad and

00:30:23,190 --> 00:30:28,530
then you would just make our ad point -

00:30:24,930 --> 00:30:31,050
under under ad okay but if it's

00:30:28,530 --> 00:30:33,450
different or not community elect strings

00:30:31,050 --> 00:30:35,550
you know quote foo plus quote bar that's

00:30:33,450 --> 00:30:37,770
different from quote bar plus quote food

00:30:35,550 --> 00:30:40,680
right then these two will have to be

00:30:37,770 --> 00:30:43,080
different okay or furthermore if you

00:30:40,680 --> 00:30:44,880
want instance plus equals something then

00:30:43,080 --> 00:30:48,180
you would overload the undereye method

00:30:44,880 --> 00:30:50,550
okay I add so the same thing happens for

00:30:48,180 --> 00:30:52,560
sub there's also a sub R sub I sub and

00:30:50,550 --> 00:30:54,780
then from multiply it small R mole I'm

00:30:52,560 --> 00:30:56,690
all and then divide it's you know div

00:30:54,780 --> 00:31:00,120
are div id band then there's also

00:30:56,690 --> 00:31:02,580
Florida are Florida v Florida for the

00:31:00,120 --> 00:31:04,440
double slash operator so it same goes

00:31:02,580 --> 00:31:07,500
for modulus okay so you can overload

00:31:04,440 --> 00:31:10,590
these operators by just defining these

00:31:07,500 --> 00:31:13,350
special methods okay and then the last

00:31:10,590 --> 00:31:15,210
bits are if the if my object has a

00:31:13,350 --> 00:31:18,390
concept of a length some sort of

00:31:15,210 --> 00:31:20,760
cardinality then I should overload the

00:31:18,390 --> 00:31:23,100
under-under LAN so that I could use the

00:31:20,760 --> 00:31:24,990
lend built-in function with my objects

00:31:23,100 --> 00:31:27,090
okay and then get some number out of it

00:31:24,990 --> 00:31:29,160
to tell me something whatever length

00:31:27,090 --> 00:31:32,340
means from my type of ends about my type

00:31:29,160 --> 00:31:33,960
of class okay similarly if I want to be

00:31:32,340 --> 00:31:36,450
able to use the bracket operator to

00:31:33,960 --> 00:31:39,210
pretend my object is like a list or an

00:31:36,450 --> 00:31:41,190
array or a dictionary okay then I

00:31:39,210 --> 00:31:42,990
overload under under get item and then I

00:31:41,190 --> 00:31:44,640
overload under under set item if I want

00:31:42,990 --> 00:31:47,340
to have assignment to my instance

00:31:44,640 --> 00:31:49,590
whatever that means for that object type

00:31:47,340 --> 00:31:52,620
and then similarly if I want to be able

00:31:49,590 --> 00:31:54,200
to do slicing I can do get slice okay

00:31:52,620 --> 00:31:56,430
and I think there's a set slice as well

00:31:54,200 --> 00:31:58,500
all right if I want to have the concept

00:31:56,430 --> 00:32:01,830
of indexing and setting multiple

00:31:58,500 --> 00:32:03,780
elements in my instance object okay then

00:32:01,830 --> 00:32:05,610
finally if I want to be able to check

00:32:03,780 --> 00:32:09,060
for membership and use the in operator

00:32:05,610 --> 00:32:12,120
with my instances then I can create the

00:32:09,060 --> 00:32:13,920
under contains method okay is everybody

00:32:12,120 --> 00:32:15,900
understand what I'm kind of saying okay

00:32:13,920 --> 00:32:17,880
let's look at a real example okay so I

00:32:15,900 --> 00:32:20,940
want to measure like hours and minutes

00:32:17,880 --> 00:32:23,160
like I have contractors coming to my

00:32:20,940 --> 00:32:24,810
house to make a repair and they're going

00:32:23,160 --> 00:32:26,520
to bill me based on the time that they

00:32:24,810 --> 00:32:28,980
have worked all together so I need to

00:32:26,520 --> 00:32:30,460
track hours and minutes okay so I'm

00:32:28,980 --> 00:32:33,280
creating a simple class

00:32:30,460 --> 00:32:35,140
times 60 that measures hours and minutes

00:32:33,280 --> 00:32:36,520
okay self-doubt articles hours sometimes

00:32:35,140 --> 00:32:38,799
minute equals minute so I'm expecting

00:32:36,520 --> 00:32:41,169
the past that's in now something to

00:32:38,799 --> 00:32:44,440
think about on the side how can I make

00:32:41,169 --> 00:32:46,140
my initializer more robust so that if I

00:32:44,440 --> 00:32:48,549
have input from a different source

00:32:46,140 --> 00:32:50,350
using different ways of input like it's

00:32:48,549 --> 00:32:52,270
one single string instead of two

00:32:50,350 --> 00:32:55,840
integers you know how would I do that

00:32:52,270 --> 00:32:58,419
how would I make my constructor support

00:32:55,840 --> 00:33:00,940
additional forms of input right because

00:32:58,419 --> 00:33:02,350
Python doesn't have it doesn't have

00:33:00,940 --> 00:33:04,360
overloading so you're not gonna have

00:33:02,350 --> 00:33:06,250
multiple signatures so you're gonna have

00:33:04,360 --> 00:33:07,870
to be able to kind of build all that in

00:33:06,250 --> 00:33:10,059
one single body of code so it's

00:33:07,870 --> 00:33:11,950
something to think about okay but in the

00:33:10,059 --> 00:33:13,480
meantime what I really want to do with

00:33:11,950 --> 00:33:15,100
this whole thing is do something like

00:33:13,480 --> 00:33:16,840
this I'm going to import my class and

00:33:15,100 --> 00:33:18,309
then I want to create an object that

00:33:16,840 --> 00:33:21,669
represents ten hours and thirty minutes

00:33:18,309 --> 00:33:23,860
and when I do a print on this ten hour

00:33:21,669 --> 00:33:25,900
and 30 minutes object I don't want to

00:33:23,860 --> 00:33:27,460
see something like this because this

00:33:25,900 --> 00:33:28,929
doesn't tell me this is not gonna tell

00:33:27,460 --> 00:33:31,330
me anything about my hours and nine

00:33:28,929 --> 00:33:35,799
minutes right okay I actually want to

00:33:31,330 --> 00:33:38,559
see you know n : 30 because that to me

00:33:35,799 --> 00:33:41,169
means 10 hours and 30 minutes or I guess

00:33:38,559 --> 00:33:43,450
in some countries it's 10 hour ten comma

00:33:41,169 --> 00:33:46,120
30 okay but it doesn't really matter

00:33:43,450 --> 00:33:48,340
whichever one you want you need to

00:33:46,120 --> 00:33:50,049
customize your under-under str to do

00:33:48,340 --> 00:33:52,720
that so that's what we've done here

00:33:50,049 --> 00:33:56,230
okay so I've customized my under under

00:33:52,720 --> 00:33:58,929
STR so that does our : minutes so that

00:33:56,230 --> 00:34:01,360
when I print it out and print calls STR

00:33:58,929 --> 00:34:02,980
which calls my under under STR that

00:34:01,360 --> 00:34:05,919
actually gets something that act that

00:34:02,980 --> 00:34:07,360
makes sense to me right because if I get

00:34:05,919 --> 00:34:09,879
what I got before you know less than

00:34:07,360 --> 00:34:11,800
sign times sixty object at some hex

00:34:09,879 --> 00:34:14,020
number that's not useful for debugging

00:34:11,800 --> 00:34:15,609
this is much more useful for me because

00:34:14,020 --> 00:34:18,149
it tells me the most critical

00:34:15,609 --> 00:34:20,560
information about my object all right

00:34:18,149 --> 00:34:22,060
okay and then furthermore I want to

00:34:20,560 --> 00:34:26,260
create another one let's say eight hours

00:34:22,060 --> 00:34:28,839
of 15 minutes okay so that's my second

00:34:26,260 --> 00:34:31,359
instance I want to be able to add them

00:34:28,839 --> 00:34:33,580
together and make a third instance of

00:34:31,359 --> 00:34:35,409
time 60 so you can't see it here but it

00:34:33,580 --> 00:34:37,389
actually is a third instance all right

00:34:35,409 --> 00:34:40,889
and I want them to be added together so

00:34:37,389 --> 00:34:42,960
that it tells me 18 hours and 45 minutes

00:34:40,889 --> 00:34:45,059
like that

00:34:42,960 --> 00:34:46,980
so in order to support the adding of

00:34:45,059 --> 00:34:49,319
these instances I need to have it under

00:34:46,980 --> 00:34:52,260
under ad okay

00:34:49,319 --> 00:34:55,169
and here's where I instantiate make the

00:34:52,260 --> 00:34:56,760
third instance I'm calling my class you

00:34:55,169 --> 00:34:58,349
know you could put time 60 here as well

00:34:56,760 --> 00:34:59,700
but it's better to do self down under

00:34:58,349 --> 00:35:02,280
class because you may not necessarily

00:34:59,700 --> 00:35:04,349
know the name of your class right and

00:35:02,280 --> 00:35:05,520
then or or maybe like what if you want

00:35:04,349 --> 00:35:07,020
to change the name of your class cuz you

00:35:05,520 --> 00:35:09,030
don't like it now you have to do search

00:35:07,020 --> 00:35:11,190
and replace okay so is easier just to

00:35:09,030 --> 00:35:13,020
get the reference to the class object

00:35:11,190 --> 00:35:15,990
from the instance itself so now you can

00:35:13,020 --> 00:35:17,849
fill in the blanks right can everybody

00:35:15,990 --> 00:35:22,800
guess what the blanks are self and other

00:35:17,849 --> 00:35:25,530
self and other self dot our plus other

00:35:22,800 --> 00:35:28,050
dot our and then self dot minute plus

00:35:25,530 --> 00:35:30,270
other dot minute okay but of course

00:35:28,050 --> 00:35:32,040
that's not doesn't support base sixty so

00:35:30,270 --> 00:35:34,740
you need to add so one of the exercises

00:35:32,040 --> 00:35:37,140
in chapter thirteen oh my book is I

00:35:34,740 --> 00:35:39,180
think part F of chapter thirteen

00:35:37,140 --> 00:35:42,359
exercise twenty part F is to support

00:35:39,180 --> 00:35:44,250
base sixty okay so that if I have like

00:35:42,359 --> 00:35:45,780
eight and you know ten hours and thirty

00:35:44,250 --> 00:35:47,369
minutes plus eight hours and forty-five

00:35:45,780 --> 00:35:49,140
minutes I'm not gonna get 18 hours

00:35:47,369 --> 00:35:51,210
seventy five minutes I want to get

00:35:49,140 --> 00:35:52,380
nineteen hours and 15 minutes so then

00:35:51,210 --> 00:35:53,940
you're gonna have to do your mod by

00:35:52,380 --> 00:35:55,559
sixty divided by 60 and all that

00:35:53,940 --> 00:35:57,480
additional stuff and you put it here

00:35:55,559 --> 00:35:59,940
okay so I'll let you guys fill in the

00:35:57,480 --> 00:36:01,619
blank mentally alright there's an

00:35:59,940 --> 00:36:03,299
exercise that's what I do

00:36:01,619 --> 00:36:06,180
right I make you guys do work because

00:36:03,299 --> 00:36:07,980
I'm too lazy to do it okay all right so

00:36:06,180 --> 00:36:10,619
anyway now you see the power of these

00:36:07,980 --> 00:36:12,089
magical methods to make your objects act

00:36:10,619 --> 00:36:13,589
just like Python types are down here I

00:36:12,089 --> 00:36:15,510
can't tell this is not a Python type

00:36:13,589 --> 00:36:17,160
because I'm printing it I see something

00:36:15,510 --> 00:36:17,670
useful I'm adding them I see something

00:36:17,160 --> 00:36:21,420
useful

00:36:17,670 --> 00:36:23,359
okay that's pretty cool alright so

00:36:21,420 --> 00:36:25,980
that's the end of the bonus material

00:36:23,359 --> 00:36:28,470
okay now let's get to the real reason

00:36:25,980 --> 00:36:32,490
why you're here okay so good good we

00:36:28,470 --> 00:36:34,710
have in 15 minutes or 40 minutes of

00:36:32,490 --> 00:36:36,630
maybe 50 minutes if I go long so let's

00:36:34,710 --> 00:36:38,640
see how well I do all right so let's

00:36:36,630 --> 00:36:40,710
talk about performance and how to use

00:36:38,640 --> 00:36:42,690
the stack or really how not to use a

00:36:40,710 --> 00:36:44,369
stack because if you can minimize your

00:36:42,690 --> 00:36:45,780
use of the stack then your program runs

00:36:44,369 --> 00:36:47,910
faster right because everybody knows

00:36:45,780 --> 00:36:49,920
that there's some context switching time

00:36:47,910 --> 00:36:51,390
you have to push objects onto the stack

00:36:49,920 --> 00:36:53,760
you got to push the function you're

00:36:51,390 --> 00:36:55,559
going to call on the stack you know your

00:36:53,760 --> 00:36:57,299
program counter has to change and

00:36:55,559 --> 00:36:58,259
you have to like save registers and all

00:36:57,299 --> 00:37:00,329
that kind of stuff and then when it

00:36:58,259 --> 00:37:01,769
comes off when the function is done you

00:37:00,329 --> 00:37:03,180
have to pop that off you have to get the

00:37:01,769 --> 00:37:04,829
return value and all those kinds of

00:37:03,180 --> 00:37:07,199
things right so really you want to try

00:37:04,829 --> 00:37:09,180
and minimize it if possible all right so

00:37:07,199 --> 00:37:14,160
here so let's talk about that for a

00:37:09,180 --> 00:37:16,949
little bit so as you know since you're

00:37:14,160 --> 00:37:19,499
all computer scientists the stack starts

00:37:16,949 --> 00:37:21,479
at the bottom and it grows upwards okay

00:37:19,499 --> 00:37:23,729
every time you call a function push the

00:37:21,479 --> 00:37:26,039
arguments on push function on and then

00:37:23,729 --> 00:37:27,150
you go and then if that function calls

00:37:26,039 --> 00:37:28,859
another function then you have another

00:37:27,150 --> 00:37:31,079
stack frame okay so those calls stack

00:37:28,859 --> 00:37:34,049
frames want to add not too many side

00:37:31,079 --> 00:37:36,089
frames so when you're done these things

00:37:34,049 --> 00:37:39,599
get popped off these being popped off

00:37:36,089 --> 00:37:42,239
and the stack goes back down okay now in

00:37:39,599 --> 00:37:45,119
regular C Python there is one Python

00:37:42,239 --> 00:37:47,209
stack frame every single Python stack

00:37:45,119 --> 00:37:49,799
frame means that there is going to be a

00:37:47,209 --> 00:37:52,019
seascape frame call as well under the

00:37:49,799 --> 00:37:53,549
covers okay the reason why I put the

00:37:52,019 --> 00:37:55,439
star there is if you're using a

00:37:53,549 --> 00:37:56,819
different version of Python that may not

00:37:55,439 --> 00:37:58,499
be the case like if you're using stack

00:37:56,819 --> 00:38:00,329
lists you can have like any number of

00:37:58,499 --> 00:38:02,759
Python stack frames for one C stack

00:38:00,329 --> 00:38:04,799
frame okay so that's why there's a star

00:38:02,759 --> 00:38:06,539
there now of course if you're making a

00:38:04,799 --> 00:38:08,459
lot of function calls and your stack

00:38:06,539 --> 00:38:10,140
grows really high and of course way up

00:38:08,459 --> 00:38:11,759
at the top you're allocating dynamic

00:38:10,140 --> 00:38:15,630
memory with your heap going downwards

00:38:11,759 --> 00:38:16,920
okay if you go too far when the two get

00:38:15,630 --> 00:38:18,929
together then that's what I'm gonna have

00:38:16,920 --> 00:38:22,289
memory error okay so it had to be

00:38:18,929 --> 00:38:24,329
careful about about that so and some

00:38:22,289 --> 00:38:25,920
other general good tips are try not to

00:38:24,329 --> 00:38:29,099
have global variables okay so that's

00:38:25,920 --> 00:38:30,630
applies in C as well in Python 2 but you

00:38:29,099 --> 00:38:32,279
know slightly different reasons but you

00:38:30,630 --> 00:38:34,439
know I thought and you know see Python

00:38:32,279 --> 00:38:36,209
is written in C right so follow some of

00:38:34,439 --> 00:38:38,099
those rules and of course version is so

00:38:36,209 --> 00:38:40,019
you can have recursion as well but it

00:38:38,099 --> 00:38:41,670
doesn't matter to Python or C because

00:38:40,019 --> 00:38:43,229
even if you're calling function with the

00:38:41,670 --> 00:38:44,939
same name even though that's mentally

00:38:43,229 --> 00:38:47,459
hard for a human you know it's just yet

00:38:44,939 --> 00:38:49,890
another stack frame for for the

00:38:47,459 --> 00:38:52,319
interpreter ok so let's just take a look

00:38:49,890 --> 00:38:54,089
at some examples here so pretend X is a

00:38:52,319 --> 00:38:55,709
really really long string for you know

00:38:54,089 --> 00:38:57,599
pretend you just like did an F dot read

00:38:55,709 --> 00:38:58,890
on a lot you know like a 1 gigabyte file

00:38:57,599 --> 00:39:00,569
all right so it's probably not

00:38:58,890 --> 00:39:02,880
recommended to do but let's just say

00:39:00,569 --> 00:39:04,859
it's very long let's take a really quick

00:39:02,880 --> 00:39:07,230
look at you know these two snippets of

00:39:04,859 --> 00:39:09,180
code and kind of like think in your head

00:39:07,230 --> 00:39:10,650
visually like which one you think maybe

00:39:09,180 --> 00:39:12,540
faster so I'll give you guys you know

00:39:10,650 --> 00:39:28,050
like 10 seconds think about it and then

00:39:12,540 --> 00:39:29,790
we'll talk about it okay how many people

00:39:28,050 --> 00:39:33,630
think they will take the same amount of

00:39:29,790 --> 00:39:35,369
time to run a - okay

00:39:33,630 --> 00:39:38,130
probably need to phone a friend or ask

00:39:35,369 --> 00:39:42,960
the audience okay how many people think

00:39:38,130 --> 00:39:44,609
the first one is faster and how many

00:39:42,960 --> 00:39:45,780
people think the second one is faster

00:39:44,609 --> 00:39:47,640
whoa

00:39:45,780 --> 00:39:50,070
okay so we should have done ask the

00:39:47,640 --> 00:39:52,950
audience not phone a friend then okay

00:39:50,070 --> 00:39:54,510
all right so let's talk about this they

00:39:52,950 --> 00:39:55,980
definitely do not take the same amount

00:39:54,510 --> 00:39:57,810
of time to run and you're gonna actually

00:39:55,980 --> 00:39:59,040
run these yourself use the time-it

00:39:57,810 --> 00:40:01,050
module how many people have used the

00:39:59,040 --> 00:40:02,490
time-it module all right

00:40:01,050 --> 00:40:07,320
that's funny most of you are on this

00:40:02,490 --> 00:40:08,910
side there was no sign on the door that

00:40:07,320 --> 00:40:10,260
said people have used time it sit on the

00:40:08,910 --> 00:40:11,550
right side of the room people who have

00:40:10,260 --> 00:40:14,040
not used sit on the left side it's

00:40:11,550 --> 00:40:15,780
really weird so time it is a module that

00:40:14,040 --> 00:40:17,280
you take a Python snippet of code you

00:40:15,780 --> 00:40:19,440
pass it in it will run it a million

00:40:17,280 --> 00:40:21,780
times it'll tell you the average runtime

00:40:19,440 --> 00:40:23,130
very useful for when you have like two

00:40:21,780 --> 00:40:24,570
different solutions or three different

00:40:23,130 --> 00:40:26,010
solutions of solving the same problem

00:40:24,570 --> 00:40:29,520
you want to see which one runs faster

00:40:26,010 --> 00:40:33,420
okay so time at TI MIT okay very useful

00:40:29,520 --> 00:40:35,640
all right so why four so for all of you

00:40:33,420 --> 00:40:43,320
guys why do you guys say that the first

00:40:35,640 --> 00:40:46,530
one is slower okay all right but isn't

00:40:43,320 --> 00:40:49,140
Python smart enough to cache this it's

00:40:46,530 --> 00:40:50,609
another quick though okay it's another

00:40:49,140 --> 00:40:52,380
question I get asked from beginners in

00:40:50,609 --> 00:40:55,619
my classes like what does it do that

00:40:52,380 --> 00:40:59,420
all right well the reason is because

00:40:55,619 --> 00:41:03,750
it's possible however not very likely

00:40:59,420 --> 00:41:06,119
that you can change le n right you might

00:41:03,750 --> 00:41:07,530
change the function because you know

00:41:06,119 --> 00:41:09,900
it's not a reserved word so you get to

00:41:07,530 --> 00:41:11,970
make it point to something else right so

00:41:09,900 --> 00:41:14,130
something like unladen swallow says oh

00:41:11,970 --> 00:41:15,480
no no that's probably not likely that

00:41:14,130 --> 00:41:17,340
they're gonna change that function so

00:41:15,480 --> 00:41:18,930
let let us do cache that to make things

00:41:17,340 --> 00:41:20,250
run faster so that's one of the

00:41:18,930 --> 00:41:20,940
performance improvements that the

00:41:20,250 --> 00:41:22,079
unladen swallow

00:41:20,940 --> 00:41:25,050
project was trying to make to make

00:41:22,079 --> 00:41:26,520
Python run faster okay so yes so the

00:41:25,050 --> 00:41:29,430
reason why the first one takes longer is

00:41:26,520 --> 00:41:32,069
because I'm making you know push on push

00:41:29,430 --> 00:41:34,200
on the stack frame pop off push on pop

00:41:32,069 --> 00:41:36,270
off push on pop up and this length

00:41:34,200 --> 00:41:37,530
function is gonna be expensive if Python

00:41:36,270 --> 00:41:39,240
doesn't keep track of how long the

00:41:37,530 --> 00:41:40,650
string is alright if it doesn't keep

00:41:39,240 --> 00:41:42,119
track how long the string cuz it's

00:41:40,650 --> 00:41:44,670
really gonna take a long time but if

00:41:42,119 --> 00:41:46,950
Python is smart it does say the size in

00:41:44,670 --> 00:41:48,810
you know part of the struct then you you

00:41:46,950 --> 00:41:50,460
know you're only paying the penalty of

00:41:48,810 --> 00:41:52,170
the stack frames but if you call it a

00:41:50,460 --> 00:41:54,000
million times that that adds up right

00:41:52,170 --> 00:41:55,770
you'll notice that if you guys pass both

00:41:54,000 --> 00:41:58,950
of these into time it you'll see the

00:41:55,770 --> 00:42:00,540
penalty that you pay for that so yes so

00:41:58,950 --> 00:42:02,609
in the second case I'm sort of I'm

00:42:00,540 --> 00:42:04,680
cashing that value into an integer a

00:42:02,609 --> 00:42:06,119
variable and then I'm just referring to

00:42:04,680 --> 00:42:08,310
that variable instead of having to call

00:42:06,119 --> 00:42:09,810
function so by reducing the total number

00:42:08,310 --> 00:42:11,609
of function calls you have made your

00:42:09,810 --> 00:42:14,579
program run faster so this is what I

00:42:11,609 --> 00:42:18,000
mean by trying to not use the stack okay

00:42:14,579 --> 00:42:19,829
it's easier to just a cassius okay now

00:42:18,000 --> 00:42:22,140
I'm not gonna ask the for those of you

00:42:19,829 --> 00:42:25,740
guys who think the first one ran faster

00:42:22,140 --> 00:42:27,480
I'm not gonna ask you why but I did have

00:42:25,740 --> 00:42:29,339
a student in one of my classes say well

00:42:27,480 --> 00:42:35,010
it's obvious the first one runs faster

00:42:29,339 --> 00:42:36,900
there's fewer lines of code right I mean

00:42:35,010 --> 00:42:38,130
you can kind of see their argument but

00:42:36,900 --> 00:42:40,230
they weren't thinking in terms of the

00:42:38,130 --> 00:42:42,660
static right so when you're writing your

00:42:40,230 --> 00:42:44,520
code it just means you know yes you may

00:42:42,660 --> 00:42:47,609
be able to come up with how to do it in

00:42:44,520 --> 00:42:50,280
Python pretty quickly but is it the most

00:42:47,609 --> 00:42:51,810
optimal way so sometimes I find myself

00:42:50,280 --> 00:42:53,460
refactoring my code as I'm writing I'm

00:42:51,810 --> 00:42:55,109
not I'm waiting till afterwards I'm

00:42:53,460 --> 00:42:57,000
rewrite I'm refactoring it as I'm doing

00:42:55,109 --> 00:42:58,079
it thinking you know what I think

00:42:57,000 --> 00:42:59,910
there's a slightly better way of doing

00:42:58,079 --> 00:43:02,250
things and this is not a big change

00:42:59,910 --> 00:43:04,020
right with just one extra line you know

00:43:02,250 --> 00:43:05,849
one extra little or two different lines

00:43:04,020 --> 00:43:07,920
of code I've really changed the

00:43:05,849 --> 00:43:09,480
performance of my Python code that

00:43:07,920 --> 00:43:11,430
happens a lot every day this is just one

00:43:09,480 --> 00:43:13,500
example so for you guys the same thing

00:43:11,430 --> 00:43:15,660
applies to when you do something and you

00:43:13,500 --> 00:43:17,670
have a solution is this the most optimal

00:43:15,660 --> 00:43:21,780
way of doing it am I making it run

00:43:17,670 --> 00:43:24,450
faster am i reducing how many function

00:43:21,780 --> 00:43:25,500
calls I make am i making a list versus

00:43:24,450 --> 00:43:27,359
making an iterator

00:43:25,500 --> 00:43:30,060
okay these are design decisions that you

00:43:27,359 --> 00:43:31,950
you know you can figure out later on

00:43:30,060 --> 00:43:33,180
when you're doing real refactoring but

00:43:31,950 --> 00:43:34,530
you know sometimes you can think about

00:43:33,180 --> 00:43:36,240
you know if you have once you

00:43:34,530 --> 00:43:38,400
- enough Python experience you will

00:43:36,240 --> 00:43:39,750
already be able to tell in fact you'll

00:43:38,400 --> 00:43:42,750
be able to debug your own code while

00:43:39,750 --> 00:43:44,940
you're writing it ok so that takes a

00:43:42,750 --> 00:43:46,970
while - to do we had a question in the

00:43:44,940 --> 00:43:46,970
back

00:43:53,700 --> 00:43:58,290
yeah right right right exactly so so the

00:43:56,760 --> 00:43:59,940
question was will I see a difference if

00:43:58,290 --> 00:44:00,630
I only you know if the loop is very

00:43:59,940 --> 00:44:03,450
short

00:44:00,630 --> 00:44:04,920
probably not noticeable okay it only

00:44:03,450 --> 00:44:06,270
happens if this head ends up being like

00:44:04,920 --> 00:44:07,380
a bottleneck or something that happens

00:44:06,270 --> 00:44:09,510
to be called all the time

00:44:07,380 --> 00:44:10,880
so it's more so I'm not telling you that

00:44:09,510 --> 00:44:12,930
this is going to solve all your problems

00:44:10,880 --> 00:44:14,490
all your performance problems you're not

00:44:12,930 --> 00:44:16,530
gonna see the entire application run a

00:44:14,490 --> 00:44:19,290
lot faster but this is one place that

00:44:16,530 --> 00:44:21,150
you remove the bottleneck and that's one

00:44:19,290 --> 00:44:22,950
of the secrets to making Python scalable

00:44:21,150 --> 00:44:24,569
because a lot of people complain oh you

00:44:22,950 --> 00:44:26,280
know back in the old days it was Python

00:44:24,569 --> 00:44:29,700
versus Perl and why was Python always

00:44:26,280 --> 00:44:31,290
slower than Perl okay so this is one of

00:44:29,700 --> 00:44:33,390
those optimizations that he make to help

00:44:31,290 --> 00:44:35,309
start making your program run faster and

00:44:33,390 --> 00:44:36,750
of course every release the core Python

00:44:35,309 --> 00:44:38,280
developers you know make performance

00:44:36,750 --> 00:44:40,950
improvement in the interpreter itself

00:44:38,280 --> 00:44:44,849
but that doesn't preclude you from being

00:44:40,950 --> 00:44:46,680
lazy and not you know making your code

00:44:44,849 --> 00:44:51,930
run as fast as it possibly could from

00:44:46,680 --> 00:44:54,180
your from what you can control okay yeah

00:44:51,930 --> 00:44:55,770
so you just have to you have to think

00:44:54,180 --> 00:44:57,180
about it carefully so the example here

00:44:55,770 --> 00:44:59,339
is just to show you that with a small

00:44:57,180 --> 00:45:00,990
change you can change slightly improve

00:44:59,339 --> 00:45:03,410
the performance of your code okay

00:45:00,990 --> 00:45:03,410
another question

00:45:14,160 --> 00:45:18,390
right so the confident comment is if

00:45:16,650 --> 00:45:20,220
it's a different implementation it will

00:45:18,390 --> 00:45:22,500
not necessarily behave this way because

00:45:20,220 --> 00:45:24,809
Java has certain optimizations and I'm

00:45:22,500 --> 00:45:26,609
sure you know the CLR does optimizations

00:45:24,809 --> 00:45:28,200
as well if you're using ironpython etc

00:45:26,609 --> 00:45:29,279
okay so that's correct so this really

00:45:28,200 --> 00:45:30,660
applies to cpython

00:45:29,279 --> 00:45:32,940
all right but I'm going to assume most

00:45:30,660 --> 00:45:34,319
of you are C Python users anyway all

00:45:32,940 --> 00:45:36,029
right so I just want to show you this

00:45:34,319 --> 00:45:39,150
example and of course I have another

00:45:36,029 --> 00:45:41,460
student that said well it's obvious that

00:45:39,150 --> 00:45:42,930
the second one runs faster because it

00:45:41,460 --> 00:45:47,970
has a green light the first has a red

00:45:42,930 --> 00:45:51,779
light and I have really interesting

00:45:47,970 --> 00:45:53,849
students I did not see that at all okay

00:45:51,779 --> 00:45:55,759
and it would be really bad if I change

00:45:53,849 --> 00:45:58,079
the color so I'd leave it the way it is

00:45:55,759 --> 00:46:01,079
okay maybe that'll help them in some

00:45:58,079 --> 00:46:04,170
other way that I can't understand okay

00:46:01,079 --> 00:46:09,539
all right so that's great now let's

00:46:04,170 --> 00:46:11,190
let's talk about Python so one of the

00:46:09,539 --> 00:46:12,960
things I don't know if whoever you learn

00:46:11,190 --> 00:46:14,640
Python from maybe it was yourself but

00:46:12,960 --> 00:46:16,950
did you know that every Python object

00:46:14,640 --> 00:46:18,539
has these three attributes all of them

00:46:16,950 --> 00:46:19,740
there's no exceptions there's no object

00:46:18,539 --> 00:46:21,119
that does not have these three

00:46:19,740 --> 00:46:24,089
attributes they all have an identity

00:46:21,119 --> 00:46:25,470
which is the hex number that we saw it's

00:46:24,089 --> 00:46:27,450
just a number that uniquely identifies

00:46:25,470 --> 00:46:31,650
this object from any other object in the

00:46:27,450 --> 00:46:33,779
system there's a type and there's a

00:46:31,650 --> 00:46:36,170
value and the thing that's most

00:46:33,779 --> 00:46:38,880
important is of all three of these

00:46:36,170 --> 00:46:40,819
values the attributes that all objects

00:46:38,880 --> 00:46:43,980
have they're pretty much all read-only

00:46:40,819 --> 00:46:47,039
it can't be changed the only one that

00:46:43,980 --> 00:46:48,720
may be changed is the value okay and

00:46:47,039 --> 00:46:50,700
that's the difference between a mutable

00:46:48,720 --> 00:46:52,559
object and an immutable object right can

00:46:50,700 --> 00:46:54,960
I change this object or can I not change

00:46:52,559 --> 00:46:56,970
this object most of them you can't right

00:46:54,960 --> 00:46:58,890
there's only a few Python objects that

00:46:56,970 --> 00:47:01,920
are really mutable like lists and

00:46:58,890 --> 00:47:02,700
dictionaries and instances and classes

00:47:01,920 --> 00:47:03,990
and things like that

00:47:02,700 --> 00:47:06,930
okay those are usually the only

00:47:03,990 --> 00:47:08,250
exceptions okay and all Python has about

00:47:06,930 --> 00:47:09,450
30 object types if you didn't know that

00:47:08,250 --> 00:47:11,730
so you can take a look at that at the

00:47:09,450 --> 00:47:13,740
link there I'll have the slides uploaded

00:47:11,730 --> 00:47:14,700
you know maybe you know at the end of

00:47:13,740 --> 00:47:17,059
the day or something so you don't have

00:47:14,700 --> 00:47:19,799
to worry about writing anything down

00:47:17,059 --> 00:47:21,420
but anyway so if you were to at you know

00:47:19,799 --> 00:47:22,680
if somebody asked you you know oh you

00:47:21,420 --> 00:47:24,150
know I'm trying to learn Python how many

00:47:22,680 --> 00:47:26,569
numeric types does it have and you have

00:47:24,150 --> 00:47:30,239
to tell them oh between three and eight

00:47:26,569 --> 00:47:31,920
because there are all right

00:47:30,239 --> 00:47:36,949
and how many string types you guys have

00:47:31,920 --> 00:47:39,180
Oh two or three okay because there are

00:47:36,949 --> 00:47:41,369
and then there's lists and tuples or

00:47:39,180 --> 00:47:42,809
tuples dictionaries and then there's to

00:47:41,369 --> 00:47:44,400
set types and then these other things

00:47:42,809 --> 00:47:46,079
which are also objects like none and

00:47:44,400 --> 00:47:47,549
files functions modules classes types

00:47:46,079 --> 00:47:51,289
everything is an object in Python anyway

00:47:47,549 --> 00:47:53,880
right so anyway so those are the objects

00:47:51,289 --> 00:47:55,650
and all objects are allocated on

00:47:53,880 --> 00:47:58,589
assignment so you don't the pre declare

00:47:55,650 --> 00:47:59,789
variables dynamic typing duck typing all

00:47:58,589 --> 00:48:02,099
objects are passed by reference we

00:47:59,789 --> 00:48:04,859
already talked about that references are

00:48:02,099 --> 00:48:06,180
also called aliases okay and reference

00:48:04,859 --> 00:48:08,819
counting is used to track the total

00:48:06,180 --> 00:48:10,259
number of you know you know variables

00:48:08,819 --> 00:48:11,910
that are interested in your object you

00:48:10,259 --> 00:48:15,359
know how many references do I have to my

00:48:11,910 --> 00:48:16,890
object okay and you know this reference

00:48:15,359 --> 00:48:19,529
count will either you know increase or

00:48:16,890 --> 00:48:21,359
decrease based on you know how you use

00:48:19,529 --> 00:48:24,539
it and where you use it and where you

00:48:21,359 --> 00:48:26,160
pass it into and then of course you know

00:48:24,539 --> 00:48:27,479
your your your your objects are garbage

00:48:26,160 --> 00:48:28,920
collected when the reference count goes

00:48:27,479 --> 00:48:31,019
to zero they're flagged for garbage

00:48:28,920 --> 00:48:32,609
collection when objects go to zero

00:48:31,019 --> 00:48:36,839
doesn't necessarily mean they're garbage

00:48:32,609 --> 00:48:40,199
collected okay so so yeah so here's an

00:48:36,839 --> 00:48:41,999
example x equals one okay so so one of

00:48:40,199 --> 00:48:43,650
the things I tell my students is you

00:48:41,999 --> 00:48:46,109
know when I learned programming many

00:48:43,650 --> 00:48:47,999
many many years ago I was told that a

00:48:46,109 --> 00:48:51,390
variable is a box and you drop a very

00:48:47,999 --> 00:48:52,949
valuable and you know that's it so I

00:48:51,390 --> 00:48:54,719
have a box named X and a dropping value

00:48:52,949 --> 00:48:56,099
and you know drop the value of one into

00:48:54,719 --> 00:48:57,569
my box all right

00:48:56,099 --> 00:48:59,009
unfortunately with Python it doesn't

00:48:57,569 --> 00:49:01,019
work that way you have to unlearn all

00:48:59,009 --> 00:49:02,880
that thinking okay you have to kind of

00:49:01,019 --> 00:49:04,380
like it's because it's backwards right

00:49:02,880 --> 00:49:05,670
you don't you can't teach programming

00:49:04,380 --> 00:49:07,559
that way now when you're using Python

00:49:05,670 --> 00:49:09,809
because it's it's more object centric

00:49:07,559 --> 00:49:11,429
right when you do x equals one - let's

00:49:09,809 --> 00:49:13,589
say oh I'm gonna make any integer object

00:49:11,429 --> 00:49:16,049
one it has an attribute I type in a

00:49:13,589 --> 00:49:17,489
value that I just described and X is

00:49:16,049 --> 00:49:18,929
just a sticker I put on it like a

00:49:17,489 --> 00:49:20,880
post-it note you know those yellow

00:49:18,929 --> 00:49:22,380
post-it note they put on it that's what

00:49:20,880 --> 00:49:24,989
they are and you can put another one on

00:49:22,380 --> 00:49:26,339
by doing y equals x okay so now I have

00:49:24,989 --> 00:49:27,809
two post-it notes on an object I don't

00:49:26,339 --> 00:49:28,650
have two boxes x and y and they both

00:49:27,809 --> 00:49:31,499
have ones in them

00:49:28,650 --> 00:49:35,699
I have integer object one that has X and

00:49:31,499 --> 00:49:38,069
y as labels on that integer object okay

00:49:35,699 --> 00:49:39,990
so again variables don't hold data

00:49:38,069 --> 00:49:42,450
anymore they're really just pointer

00:49:39,990 --> 00:49:43,560
or aliases or references to an object of

00:49:42,450 --> 00:49:45,869
course you can have additional alias

00:49:43,560 --> 00:49:47,850
it's like the why and again you know

00:49:45,869 --> 00:49:48,990
when the when x and y are gone let's say

00:49:47,850 --> 00:49:50,400
they were part of a function the

00:49:48,990 --> 00:49:52,080
variables their local variable that go

00:49:50,400 --> 00:49:53,730
away and nothing else is interested in

00:49:52,080 --> 00:49:55,950
my object getting more than its flag for

00:49:53,730 --> 00:49:58,050
garbage collection okay so you know

00:49:55,950 --> 00:49:59,550
reference counting is an easy way to do

00:49:58,050 --> 00:50:01,590
memory management the only the only

00:49:59,550 --> 00:50:03,210
drawback one of the drawbacks is that

00:50:01,590 --> 00:50:05,010
you can have cycles to be an object

00:50:03,210 --> 00:50:06,750
pointing to an object going to an object

00:50:05,010 --> 00:50:07,830
and then that object eventually points

00:50:06,750 --> 00:50:09,390
back to the first one and then all

00:50:07,830 --> 00:50:11,310
variables pointing to these two go away

00:50:09,390 --> 00:50:13,140
and all the other ones go away the

00:50:11,310 --> 00:50:14,730
problem is they all still have a

00:50:13,140 --> 00:50:15,960
reference to each other even if you

00:50:14,730 --> 00:50:19,080
can't get to it anymore from your

00:50:15,960 --> 00:50:21,240
application the reference cut will never

00:50:19,080 --> 00:50:22,890
go to zero so those are you're leaking

00:50:21,240 --> 00:50:24,690
that memory okay so that's a one

00:50:22,890 --> 00:50:26,430
drawback to having to music reference

00:50:24,690 --> 00:50:28,440
counting but ipython has a cycle

00:50:26,430 --> 00:50:30,570
detector that will go through and check

00:50:28,440 --> 00:50:33,360
for this type of stuff back in the old

00:50:30,570 --> 00:50:34,860
days before Python had a cycle detector

00:50:33,360 --> 00:50:37,230
this was not the case so you know you

00:50:34,860 --> 00:50:39,090
could run into problems all right

00:50:37,230 --> 00:50:40,380
but you know if you think you're a

00:50:39,090 --> 00:50:43,140
perfect programmer and you write

00:50:40,380 --> 00:50:44,820
bug-free code then you can actually tell

00:50:43,140 --> 00:50:47,609
Python to turn off the cycle detector

00:50:44,820 --> 00:50:50,310
you can you know you know do the trapeze

00:50:47,609 --> 00:50:52,290
work with no net on the bottom okay but

00:50:50,310 --> 00:50:55,050
it's probably very dangerous to do okay

00:50:52,290 --> 00:50:57,119
so anyway so let's talk about being and

00:50:55,050 --> 00:50:58,380
what makes reference counts go up okay

00:50:57,119 --> 00:51:00,119
so when you make an object like this

00:50:58,380 --> 00:51:01,590
string here and you assign it to a first

00:51:00,119 --> 00:51:03,300
variable well now my reference count is

00:51:01,590 --> 00:51:05,670
1 because I made this object and now I

00:51:03,300 --> 00:51:08,160
have one alias to it one reference to it

00:51:05,670 --> 00:51:09,900
so reference count is one I can now make

00:51:08,160 --> 00:51:11,640
another alias point to the same string

00:51:09,900 --> 00:51:14,430
and now that makes my reference count go

00:51:11,640 --> 00:51:16,380
up to two or I could pass that object

00:51:14,430 --> 00:51:18,390
into a function now it becomes a new

00:51:16,380 --> 00:51:20,609
local variable in that function so again

00:51:18,390 --> 00:51:23,820
the reference count goes up I want or I

00:51:20,609 --> 00:51:24,900
could put it inside a container okay so

00:51:23,820 --> 00:51:26,460
now I need to be able to refer to that

00:51:24,900 --> 00:51:28,140
object from somewhere else so that makes

00:51:26,460 --> 00:51:30,000
a reference count go up by one as well

00:51:28,140 --> 00:51:31,530
okay so in your head you need to kind of

00:51:30,000 --> 00:51:33,750
like mentally keep track of this type of

00:51:31,530 --> 00:51:35,940
stuff because if you end up writing a C

00:51:33,750 --> 00:51:37,920
extension you have to manually manage

00:51:35,940 --> 00:51:39,060
the reference counting yourself you know

00:51:37,920 --> 00:51:40,619
so for those of you have done it you

00:51:39,060 --> 00:51:42,930
know it's incorrect and Dec ref you know

00:51:40,619 --> 00:51:45,440
this very common thing to do but

00:51:42,930 --> 00:51:45,440
question back there

00:51:48,999 --> 00:51:53,979
the question is can I get the reference

00:51:51,369 --> 00:51:56,859
kind of an object and I believe it is

00:51:53,979 --> 00:51:58,809
sis dot get ref count can anybody

00:51:56,859 --> 00:52:02,670
confirm that or do I have to do imports

00:51:58,809 --> 00:52:02,670
this Durov sis

00:52:18,590 --> 00:52:28,810
just out getting rough count you know

00:52:21,050 --> 00:52:28,810
what's fun do the rough kind of zero

00:52:37,019 --> 00:52:40,019
always fun to see these reference cuz

00:52:39,059 --> 00:52:42,329
you're thinking wait a minute I just

00:52:40,019 --> 00:52:43,969
started the Python interpreter yeah

00:52:42,329 --> 00:52:46,199
right

00:52:43,969 --> 00:52:58,259
you ran a lot of stuff that you didn't

00:52:46,199 --> 00:53:04,039
think you were running pardon it's more

00:52:58,259 --> 00:53:08,009
false than true yes yes it's that's true

00:53:04,039 --> 00:53:14,969
that was a clever observation it's more

00:53:08,009 --> 00:53:18,809
nun than anything else exactly how about

00:53:14,969 --> 00:53:20,069
my instance see not too many things not

00:53:18,809 --> 00:53:21,899
too many things interested in my

00:53:20,069 --> 00:53:26,039
instance see that I try to print out

00:53:21,899 --> 00:53:27,479
apparently okay those just kind of fun

00:53:26,039 --> 00:53:29,849
so yes you can get the reference kind of

00:53:27,479 --> 00:53:31,559
of an object that's a good question

00:53:29,849 --> 00:53:34,979
actually I should have put that in my

00:53:31,559 --> 00:53:35,849
slides how to get the rift alright now

00:53:34,979 --> 00:53:38,789
let's talk about when the reference

00:53:35,849 --> 00:53:41,759
count goes down so in the previous slide

00:53:38,789 --> 00:53:43,979
I passed in this string to a function

00:53:41,759 --> 00:53:45,959
and then the function ends so that local

00:53:43,979 --> 00:53:48,239
variable is gone so that decrement sit I

00:53:45,959 --> 00:53:49,739
could just remove that alias that I made

00:53:48,239 --> 00:53:51,509
an already did bar equals foo and I can

00:53:49,739 --> 00:53:53,339
do del bar or I can do del foo and just

00:53:51,509 --> 00:53:55,499
remove one of those references and now

00:53:53,339 --> 00:53:57,179
my ref count goes down by one I can

00:53:55,499 --> 00:53:59,369
immediately assign bar to something else

00:53:57,179 --> 00:54:01,529
completely different okay so now it's

00:53:59,369 --> 00:54:03,630
not looking at my string anymore or I

00:54:01,529 --> 00:54:05,549
can remember how I also put it in this

00:54:03,630 --> 00:54:08,219
container the list well I can also

00:54:05,549 --> 00:54:10,739
remove it just as easily or maybe the

00:54:08,219 --> 00:54:12,029
entire container goes away okay so all

00:54:10,739 --> 00:54:14,399
saying all those things make the

00:54:12,029 --> 00:54:17,719
reference count go down by one okay just

00:54:14,399 --> 00:54:20,339
something to think about right okay and

00:54:17,719 --> 00:54:22,079
so anyway so just forget all that it

00:54:20,339 --> 00:54:23,159
doesn't matter okay we're adding that

00:54:22,079 --> 00:54:26,729
section now let's talk about the next

00:54:23,159 --> 00:54:30,689
section okay so good we're good on time

00:54:26,729 --> 00:54:32,339
it's good so now I'm going to categorize

00:54:30,689 --> 00:54:34,199
all the standard types for you but I'm

00:54:32,339 --> 00:54:35,969
gonna do it in three different ways why

00:54:34,199 --> 00:54:37,409
am i doing that to make you learn them

00:54:35,969 --> 00:54:39,089
faster if you're still new to the

00:54:37,409 --> 00:54:41,099
language if you're not new to the

00:54:39,089 --> 00:54:42,749
language hopefully I would show you a

00:54:41,099 --> 00:54:44,009
different way to think about the

00:54:42,749 --> 00:54:46,229
relationships that each of these

00:54:44,009 --> 00:54:49,199
standard types have with each other okay

00:54:46,229 --> 00:54:49,859
you know so the another goal is to make

00:54:49,199 --> 00:54:52,440
you understand

00:54:49,859 --> 00:54:53,819
better and if you understand them better

00:54:52,440 --> 00:54:55,410
and you know how they work under the

00:54:53,819 --> 00:54:57,660
covers you're going to write more

00:54:55,410 --> 00:55:00,930
correct Python code again I'm trying to

00:54:57,660 --> 00:55:02,190
create a bug I shouldn't say bug free

00:55:00,930 --> 00:55:03,930
Python programmers I'm trying to make

00:55:02,190 --> 00:55:06,269
you guys write with fewer bugs that you

00:55:03,930 --> 00:55:08,969
haven't written yet okay that's my goal

00:55:06,269 --> 00:55:10,799
okay so if you because if you understand

00:55:08,969 --> 00:55:12,239
them better internally your code is

00:55:10,799 --> 00:55:13,589
gonna be more not only efficient it's

00:55:12,239 --> 00:55:15,749
gonna run faster it's gonna be more

00:55:13,589 --> 00:55:19,680
correct okay I want you guys to be the

00:55:15,749 --> 00:55:22,469
perfect programmer okay in fact that's

00:55:19,680 --> 00:55:24,539
what I tell my QA testing people I tell

00:55:22,469 --> 00:55:27,930
them you know what I don't need your

00:55:24,539 --> 00:55:32,279
services I write bug-free code and they

00:55:27,930 --> 00:55:35,459
all go and then I just wait for them to

00:55:32,279 --> 00:55:38,130
file tickets on my stuff maybe once in

00:55:35,459 --> 00:55:39,539
every six months or so okay it doesn't

00:55:38,130 --> 00:55:41,160
really happen and some of them can't

00:55:39,539 --> 00:55:43,529
understand it and every time they find

00:55:41,160 --> 00:55:45,059
one they think it's victory and they go

00:55:43,529 --> 00:55:47,390
and yell you run around the office

00:55:45,059 --> 00:55:50,190
screaming I found a bug in Wesley's code

00:55:47,390 --> 00:55:53,579
this doesn't happen very often all right

00:55:50,190 --> 00:55:55,249
so that makes me happy because I know

00:55:53,579 --> 00:55:59,219
it's not realistic for me to say that

00:55:55,249 --> 00:56:00,449
but it is a goal that I have because you

00:55:59,219 --> 00:56:01,529
got to shoot for something right

00:56:00,449 --> 00:56:03,779
otherwise you shouldn't be in this

00:56:01,529 --> 00:56:06,119
business okay you should just go back

00:56:03,779 --> 00:56:07,019
and you know do underwater

00:56:06,119 --> 00:56:11,910
basket-weaving

00:56:07,019 --> 00:56:12,989
or something okay so okay now let's talk

00:56:11,910 --> 00:56:15,299
about the three different ways to

00:56:12,989 --> 00:56:17,130
categorize the standard types storage

00:56:15,299 --> 00:56:18,239
model update model access model you

00:56:17,130 --> 00:56:20,579
won't find this in any other book

00:56:18,239 --> 00:56:23,039
because I'm a mad scientist and it's

00:56:20,579 --> 00:56:25,199
only my wild and crazy imagination and

00:56:23,039 --> 00:56:27,749
so I put it in my book so it's not in

00:56:25,199 --> 00:56:30,569
any other book right okay storage model

00:56:27,749 --> 00:56:32,729
how is data stored in an object in other

00:56:30,569 --> 00:56:34,559
words can it hold a single object or can

00:56:32,729 --> 00:56:35,940
it hold multiple objects in other words

00:56:34,559 --> 00:56:37,559
what I'm really trying to ask is is this

00:56:35,940 --> 00:56:40,170
a container or not

00:56:37,559 --> 00:56:42,089
okay so literals and scalars are not

00:56:40,170 --> 00:56:44,670
container so that's all number types and

00:56:42,089 --> 00:56:46,559
strings container types or everything

00:56:44,670 --> 00:56:47,999
else lists tuples tuples dictionaries

00:56:46,559 --> 00:56:49,349
sets those are all container types

00:56:47,999 --> 00:56:51,180
because they can contain more than one

00:56:49,349 --> 00:56:52,680
Python object all right everybody

00:56:51,180 --> 00:56:54,660
understand this model fairly

00:56:52,680 --> 00:56:57,119
straightforward here's another model the

00:56:54,660 --> 00:57:01,079
update model can I update this objects

00:56:57,119 --> 00:57:03,209
value again every object has a type @ ID

00:57:01,079 --> 00:57:03,810
and a value right and all of them are

00:57:03,209 --> 00:57:05,100
read-only

00:57:03,810 --> 00:57:06,810
that may be the value so here's where

00:57:05,100 --> 00:57:08,850
this comes in and that is whether that

00:57:06,810 --> 00:57:10,620
object is mutable or not if it's mutable

00:57:08,850 --> 00:57:13,140
yes you can change it if it's immutable

00:57:10,620 --> 00:57:14,340
no you can't change it okay and of

00:57:13,140 --> 00:57:16,710
course there's one of each set type

00:57:14,340 --> 00:57:19,670
there is a Mita Balad set there's an

00:57:16,710 --> 00:57:23,340
immutable set table called a frozen set

00:57:19,670 --> 00:57:25,340
and starting in Python 3.0 there is a

00:57:23,340 --> 00:57:27,990
byte array type which is a mutable

00:57:25,340 --> 00:57:30,740
string type or it's really not a string

00:57:27,990 --> 00:57:33,720
it's a byte it's an array of bytes okay

00:57:30,740 --> 00:57:35,100
so that's the update model can they be

00:57:33,720 --> 00:57:36,900
change remember how I said there's very

00:57:35,100 --> 00:57:40,290
few mutable types lists dictionaries

00:57:36,900 --> 00:57:42,060
sets instances and classes okay

00:57:40,290 --> 00:57:43,380
everything else is pretty much immutable

00:57:42,060 --> 00:57:45,120
okay there may be a couple others as

00:57:43,380 --> 00:57:46,800
well right so just keep that in mind

00:57:45,120 --> 00:57:49,260
because believe it or not

00:57:46,800 --> 00:57:53,030
mutability of an object is a source of

00:57:49,260 --> 00:57:55,800
many many python bugs many python bugs

00:57:53,030 --> 00:57:57,930
last one is probably the most normal way

00:57:55,800 --> 00:57:59,160
and you know this is how you learn

00:57:57,930 --> 00:58:00,720
Python in most books and most

00:57:59,160 --> 00:58:02,820
documentation and that that's how you

00:58:00,720 --> 00:58:04,140
access an object do you access them

00:58:02,820 --> 00:58:05,310
directly if so there's probably a number

00:58:04,140 --> 00:58:08,490
or a set whoops

00:58:05,310 --> 00:58:10,890
it's a number or set if you access it by

00:58:08,490 --> 00:58:13,710
index value you know bracket 0 bracket 1

00:58:10,890 --> 00:58:17,490
that's a sequence type ok strings listen

00:58:13,710 --> 00:58:18,750
to pools or use a key to access your

00:58:17,490 --> 00:58:21,360
value so that's a mapping type

00:58:18,750 --> 00:58:22,710
dictionaries ok all right everybody

00:58:21,360 --> 00:58:23,910
understand this one right how do you

00:58:22,710 --> 00:58:26,670
access the object either I get it

00:58:23,910 --> 00:58:27,900
directly or go by index or go by key now

00:58:26,670 --> 00:58:29,550
so we looked at all three of these

00:58:27,900 --> 00:58:30,930
models and they kind of were a little

00:58:29,550 --> 00:58:33,060
similar it's always different in other

00:58:30,930 --> 00:58:34,350
ways but the interesting thing to do is

00:58:33,060 --> 00:58:37,980
to actually look at them all combined

00:58:34,350 --> 00:58:39,420
together ok so by doing that you can

00:58:37,980 --> 00:58:41,340
kind of see the interrelationship that

00:58:39,420 --> 00:58:43,050
each of the Python stereotypes have with

00:58:41,340 --> 00:58:44,730
each other so you see that lists and

00:58:43,050 --> 00:58:46,230
tuples are very similar to each other

00:58:44,730 --> 00:58:48,120
okay they're both containers of both

00:58:46,230 --> 00:58:51,480
sequences but ones mutable the others

00:58:48,120 --> 00:58:53,340
none you know another one is like

00:58:51,480 --> 00:58:54,840
dictionaries and lists they're similar

00:58:53,340 --> 00:58:57,420
too because they're both containers

00:58:54,840 --> 00:59:00,210
they're both mutable but one's a mapping

00:58:57,420 --> 00:59:02,610
type the other is a sequence time ok so

00:59:00,210 --> 00:59:05,340
this chart here helps you understand how

00:59:02,610 --> 00:59:06,540
they are alike and how they're different

00:59:05,340 --> 00:59:09,510
in different ways

00:59:06,540 --> 00:59:10,890
ok so understanding this chart will give

00:59:09,510 --> 00:59:14,700
you a better understanding of the Python

00:59:10,890 --> 00:59:16,650
types ok so that's all I wanted to say

00:59:14,700 --> 00:59:18,180
about that let's take a quiz now

00:59:16,650 --> 00:59:20,460
so let's take a look at example one

00:59:18,180 --> 00:59:21,840
example two so I want you to look at it

00:59:20,460 --> 00:59:24,480
for each of them each one for ten

00:59:21,840 --> 00:59:26,040
seconds and mentally in your head figure

00:59:24,480 --> 00:59:27,750
out what the output is and then tell me

00:59:26,040 --> 00:59:29,400
what you think the output is you know in

00:59:27,750 --> 00:59:32,360
about 10 seconds I'll let you look at

00:59:29,400 --> 00:59:32,360
and we'll talk about it

00:59:45,200 --> 00:59:51,680
all right so what's the answer to the

00:59:47,569 --> 00:59:54,920
first one okay

00:59:51,680 --> 00:59:56,720
43 and 42 okay that makes sense right so

00:59:54,920 --> 00:59:58,670
if I had a white board here I would do

00:59:56,720 --> 01:00:00,140
this I would pretend I was the Python

00:59:58,670 --> 01:00:02,950
interpreter that's how you figure out

01:00:00,140 --> 01:00:04,160
what the code does you have to be Guido

01:00:02,950 --> 01:00:06,290
okay

01:00:04,160 --> 01:00:08,630
so x equals 42 so the first thing that

01:00:06,290 --> 01:00:11,809
happens is no I don't assign 42 to X I

01:00:08,630 --> 01:00:14,690
see do I have an integer 42 in my system

01:00:11,809 --> 01:00:16,790
so I'll make it up and then make X point

01:00:14,690 --> 01:00:18,680
to it right it's a label okay

01:00:16,790 --> 01:00:20,660
then I do y equals x I make another

01:00:18,680 --> 01:00:23,030
label pointing to the X when I do x

01:00:20,660 --> 01:00:25,849
equals x plus 1 I go okay I'm gonna take

01:00:23,030 --> 01:00:28,010
the value 42 add 1 to it then I have

01:00:25,849 --> 01:00:29,720
object 43 and then I make X point to

01:00:28,010 --> 01:00:32,240
that and then Y is still pointing to 42

01:00:29,720 --> 01:00:33,109
so the sticker has been moved okay so

01:00:32,240 --> 01:00:37,400
let's take a look at the second example

01:00:33,109 --> 01:00:40,460
how does that work what's the output aim

01:00:37,400 --> 01:00:42,650
which is 4 to 3

01:00:40,460 --> 01:00:46,609
okay right so the way I execute that is

01:00:42,650 --> 01:00:49,099
I make a object-- list 1 2 3 I make X

01:00:46,609 --> 01:00:51,950
refer to it then I make why stick on

01:00:49,099 --> 01:00:53,420
that as well when I refer to X bracket 0

01:00:51,950 --> 01:00:54,980
I'm looking at the first element I'm

01:00:53,420 --> 01:00:59,390
swapping the one out and replacing it

01:00:54,980 --> 01:01:01,400
with a 4 but because I've changed x and

01:00:59,390 --> 01:01:03,020
y is looking at exactly the same object

01:01:01,400 --> 01:01:06,290
that's why my output is the same here

01:01:03,020 --> 01:01:13,059
but it's different here why are they not

01:01:06,290 --> 01:01:15,920
the same because of what M starts with M

01:01:13,059 --> 01:01:18,260
mutability right again this is the cause

01:01:15,920 --> 01:01:20,690
of most pipe or many python bugs as

01:01:18,260 --> 01:01:24,670
mutability you forgot that numbers were

01:01:20,690 --> 01:01:27,200
immutable and lists are mutable okay

01:01:24,670 --> 01:01:28,730
okay good so now let's look at another

01:01:27,200 --> 01:01:32,599
example before we go to the next slide

01:01:28,730 --> 01:01:35,089
let's do the same example but let's do

01:01:32,599 --> 01:01:38,210
it slightly differently so instead of x

01:01:35,089 --> 01:01:43,250
equals 42 and y equals x let's do x

01:01:38,210 --> 01:01:47,839
equals 42 and then y equals 42 now what

01:01:43,250 --> 01:01:50,540
happens do I have 42 and at X pointing

01:01:47,839 --> 01:01:53,150
to it and another 42 and a Y pointing at

01:01:50,540 --> 01:01:55,520
it or do I only have one 42 and then

01:01:53,150 --> 01:01:58,430
both x and y are looking at it if I have

01:01:55,520 --> 01:01:58,940
x equals 42 and y equals 42 not y equals

01:01:58,430 --> 01:02:04,430
x

01:01:58,940 --> 01:02:06,800
but why equals 42 Oh how many people say

01:02:04,430 --> 01:02:09,470
there's only 142 in the system

01:02:06,800 --> 01:02:12,560
I'm people say there are two 42 is in

01:02:09,470 --> 01:02:19,400
the system not a lot of people in the

01:02:12,560 --> 01:02:23,150
second one okay so I'll say that most of

01:02:19,400 --> 01:02:25,849
you are right in most cases but the rest

01:02:23,150 --> 01:02:26,839
of you are right in other cases so

01:02:25,849 --> 01:02:32,869
you're all right

01:02:26,839 --> 01:02:35,390
everybody's a winner okay so if I do X

01:02:32,869 --> 01:02:37,550
equals 4 and y equals 4 is it going to

01:02:35,390 --> 01:02:39,470
be this one or this one pretend that

01:02:37,550 --> 01:02:42,980
four point three is really a four okay

01:02:39,470 --> 01:02:45,470
so this is an exception to the rule so

01:02:42,980 --> 01:02:46,849
based on what I've told you so far you

01:02:45,470 --> 01:02:49,310
should be saying there should be two of

01:02:46,849 --> 01:02:51,530
them like some of you have and you would

01:02:49,310 --> 01:02:55,849
be correct except this is an exception

01:02:51,530 --> 01:02:57,560
to the rule and the exception is special

01:02:55,849 --> 01:03:01,819
numbers which are all numbers between

01:02:57,560 --> 01:03:03,800
negative 5 and 256 okay there's only one

01:03:01,819 --> 01:03:05,780
instance of those objects they're all

01:03:03,800 --> 01:03:07,490
Singleton's and they're all permanently

01:03:05,780 --> 01:03:09,560
installed in the system which means

01:03:07,490 --> 01:03:10,910
they're never deleted which means even

01:03:09,560 --> 01:03:12,260
if the reference count goes to 0 they

01:03:10,910 --> 01:03:16,250
will not be de-allocated these are

01:03:12,260 --> 01:03:17,839
special they're called in turn ok so the

01:03:16,250 --> 01:03:19,160
reason why this is I put currently is

01:03:17,839 --> 01:03:22,970
because well first of all this is

01:03:19,160 --> 01:03:27,290
undocumented ok so you won't find this

01:03:22,970 --> 01:03:28,970
anywhere except in my book and the other

01:03:27,290 --> 01:03:30,589
thing that's bad is that because it's

01:03:28,970 --> 01:03:33,109
undocumented or maybe this is the reason

01:03:30,589 --> 01:03:36,230
why it's undocumented is the core Python

01:03:33,109 --> 01:03:40,790
team changed this on me okay so before

01:03:36,230 --> 01:03:41,540
python 2.5 this range needs to be - 1 -

01:03:40,790 --> 01:03:44,599
01:03:41,540 --> 01:03:47,839
we're in turn anything bigger than 100

01:03:44,599 --> 01:03:49,490
100 and smaller than minus 1 were not in

01:03:47,839 --> 01:03:51,980
turned so you would actually have 2 of

01:03:49,490 --> 01:03:54,349
them ok so this is only integers and

01:03:51,980 --> 01:03:56,060
also often used single character or

01:03:54,349 --> 01:03:59,240
empty strings those are the only obvious

01:03:56,060 --> 01:04:01,099
that are in turn so if I use floats then

01:03:59,240 --> 01:04:02,540
you actually will get 2 so those of you

01:04:01,099 --> 01:04:04,460
guys that think you were originally

01:04:02,540 --> 01:04:07,160
wrong right now okay it's all set to

01:04:04,460 --> 01:04:10,460
float there was something else the

01:04:07,160 --> 01:04:11,869
dictionary list or whatever okay so it's

01:04:10,460 --> 01:04:12,620
undocumented and of course when I was

01:04:11,869 --> 01:04:14,390
working on the second

01:04:12,620 --> 01:04:16,550
my book nobody told me that they changed

01:04:14,390 --> 01:04:18,230
it so I was looking for the 101 in the

01:04:16,550 --> 01:04:21,200
source code I couldn't find it with my

01:04:18,230 --> 01:04:23,180
grep magic tool and then I found out

01:04:21,200 --> 01:04:27,050
that it was changed at 256 so that was

01:04:23,180 --> 01:04:28,820
kind of disturbing so yeah so there's

01:04:27,050 --> 01:04:30,470
undocumented but it's one of the things

01:04:28,820 --> 01:04:31,550
that may be a cause of one of your bugs

01:04:30,470 --> 01:04:33,710
but you don't know that

01:04:31,550 --> 01:04:35,720
right so it's not documented because you

01:04:33,710 --> 01:04:37,190
shouldn't need to know this stuff but

01:04:35,720 --> 01:04:39,020
there may be cases where you need to

01:04:37,190 --> 01:04:40,610
know whether or not both x and y are

01:04:39,020 --> 01:04:43,580
looking at the same object or not and so

01:04:40,610 --> 01:04:45,410
that's why there is keywords exists okay

01:04:43,580 --> 01:04:46,940
so is will tell you whether or not

01:04:45,410 --> 01:04:48,920
they're both looking at exactly the same

01:04:46,940 --> 01:04:51,260
object when you do x equals four y

01:04:48,920 --> 01:04:54,170
equals four and you do x equals x is y

01:04:51,260 --> 01:04:55,220
you actually get a true but if you did

01:04:54,170 --> 01:04:57,470
the same thing for four point three

01:04:55,220 --> 01:04:59,900
you'll get a false now four equals

01:04:57,470 --> 01:05:02,060
equals would get true in both cases but

01:04:59,900 --> 01:05:03,200
four is you're only gonna get a true for

01:05:02,060 --> 01:05:04,700
this one you're gonna get a false for

01:05:03,200 --> 01:05:06,620
this one because there are two objects

01:05:04,700 --> 01:05:11,060
so they're not looking exactly at the

01:05:06,620 --> 01:05:18,530
same same one okay and then let's take a

01:05:11,060 --> 01:05:20,810
look at the second quiz here now I'm

01:05:18,530 --> 01:05:22,310
gonna make a copy okay so people you

01:05:20,810 --> 01:05:24,110
know beginners to Python will ask me how

01:05:22,310 --> 01:05:27,170
do we make a copy of a list well you can

01:05:24,110 --> 01:05:28,790
just do loops you can just do a list of

01:05:27,170 --> 01:05:30,440
your existing list or you can just take

01:05:28,790 --> 01:05:34,340
an improper slice which is a slice of

01:05:30,440 --> 01:05:37,250
everything okay and so now I'm gonna go

01:05:34,340 --> 01:05:39,830
and change this one to a four Y bracket

01:05:37,250 --> 01:05:41,030
one after I've copied it change that to

01:05:39,830 --> 01:05:43,520
a four I'm not changing the one and X

01:05:41,030 --> 01:05:50,870
I'm changing the one in four so now what

01:05:43,520 --> 01:05:58,580
is the output same are you sure I made a

01:05:50,870 --> 01:06:02,060
copy how many people think the output is

01:05:58,580 --> 01:06:04,280
going to be different how many people

01:06:02,060 --> 01:06:07,280
think it's gonna be the same oh that's

01:06:04,280 --> 01:06:16,040
not good that is not good because half

01:06:07,280 --> 01:06:22,560
of you are wrong now you know which half

01:06:16,040 --> 01:06:26,530
is wrong why is this the case

01:06:22,560 --> 01:06:28,270
okay okay so this gentleman here said

01:06:26,530 --> 01:06:30,790
the list is a list of references but

01:06:28,270 --> 01:06:32,350
that doesn't let me explain it in

01:06:30,790 --> 01:06:35,940
different words saying exactly the same

01:06:32,350 --> 01:06:39,600
thing as him when I copied the list I

01:06:35,940 --> 01:06:42,850
copied the references I did not copy the

01:06:39,600 --> 01:06:45,580
objects hey

01:06:42,850 --> 01:06:47,410
both X&Y even though they are different

01:06:45,580 --> 01:06:48,670
data structures when you do at you know

01:06:47,410 --> 01:06:50,200
X is not Y

01:06:48,670 --> 01:06:52,630
you'll get that X is not why they're

01:06:50,200 --> 01:06:54,930
different lists the promise inside them

01:06:52,630 --> 01:06:57,850
are the same pointers

01:06:54,930 --> 01:07:01,690
they are both pointing to the same list

01:06:57,850 --> 01:07:04,270
here so even though I changed Y because

01:07:01,690 --> 01:07:06,010
Y refers me to this list but X also

01:07:04,270 --> 01:07:08,800
refers to that list even though x and y

01:07:06,010 --> 01:07:12,040
are different lists okay

01:07:08,800 --> 01:07:13,240
this causes both of them to be changed

01:07:12,040 --> 01:07:14,860
but it's not really both of them that

01:07:13,240 --> 01:07:19,660
are changing is I'm only changed the one

01:07:14,860 --> 01:07:21,970
thing that they are both looking at okay

01:07:19,660 --> 01:07:24,300
again so because half of you raised this

01:07:21,970 --> 01:07:26,440
because half of you raised your hand

01:07:24,300 --> 01:07:27,280
this would have been a bug oops this

01:07:26,440 --> 01:07:29,200
would have been a bug in your

01:07:27,280 --> 01:07:32,940
application because you weren't aware of

01:07:29,200 --> 01:07:38,320
this again what is the cause of this bug

01:07:32,940 --> 01:07:39,960
that's with M exactly okay

01:07:38,320 --> 01:07:45,550
everybody learned something today

01:07:39,960 --> 01:07:48,460
shocking isn't it okay yes question how

01:07:45,550 --> 01:07:52,900
can you do a deep copy that's on the

01:07:48,460 --> 01:07:55,630
very next slide yeah a lot of a lot of

01:07:52,900 --> 01:07:57,040
my in my classes actually when I want to

01:07:55,630 --> 01:07:58,720
teach my class I tell them all right I

01:07:57,040 --> 01:08:00,220
know we're just starting the class but

01:07:58,720 --> 01:08:02,050
let me tell you whatever questions you

01:08:00,220 --> 01:08:03,130
guys have I'm probably going to answer

01:08:02,050 --> 01:08:05,290
it in the next three or four slides

01:08:03,130 --> 01:08:13,540
really and people don't believe me they

01:08:05,290 --> 01:08:15,340
ask anyway okay so Harold is there any

01:08:13,540 --> 01:08:17,260
way to find who's holding a reference to

01:08:15,340 --> 01:08:18,609
an object there I don't think there's an

01:08:17,260 --> 01:08:22,420
easy way of doing it you're just gonna

01:08:18,609 --> 01:08:23,980
have to check IDs there might be a way

01:08:22,420 --> 01:08:28,150
but I am not familiar with what it is

01:08:23,980 --> 01:08:29,650
okay all right so first step is be aware

01:08:28,150 --> 01:08:31,030
that when you make an eight loops when

01:08:29,650 --> 01:08:33,210
you make an alias we've certainly not

01:08:31,030 --> 01:08:35,580
making a copy right when I'm doing bee

01:08:33,210 --> 01:08:38,219
they all write equals equals B that's

01:08:35,580 --> 01:08:39,839
true and a is B okay because the idea of

01:08:38,219 --> 01:08:41,100
a who's idea be as if some of you guys

01:08:39,839 --> 01:08:42,690
want to find out how do I get an idea of

01:08:41,100 --> 01:08:44,580
a value somebody asked how to get a ref

01:08:42,690 --> 01:08:47,370
count are you really know how to get the

01:08:44,580 --> 01:08:48,839
value of a variable you know how to you

01:08:47,370 --> 01:08:50,310
know how to get the reference count now

01:08:48,839 --> 01:08:53,190
you know I'm teaching you how to get the

01:08:50,310 --> 01:08:55,080
ID okay so I da equals equals idea be

01:08:53,190 --> 01:08:56,339
the same thing that's a is B so these

01:08:55,080 --> 01:08:57,600
both exactly looking at the same off

01:08:56,339 --> 01:08:59,700
you're not making a copy you're just

01:08:57,600 --> 01:09:03,359
making an alias if you make a shallow

01:08:59,700 --> 01:09:05,489
copy okay a is still equal equal to B

01:09:03,359 --> 01:09:07,410
but a it's not B because you know like

01:09:05,489 --> 01:09:08,969
we did on the previous slide x and y are

01:09:07,410 --> 01:09:11,219
different lists but what they're

01:09:08,969 --> 01:09:13,259
pointing to are all the same right okay

01:09:11,219 --> 01:09:15,450
so now if you really want to copy

01:09:13,259 --> 01:09:17,850
there's a copy module and isn't a copy

01:09:15,450 --> 01:09:19,529
module is a deep copy function okay so

01:09:17,850 --> 01:09:22,259
you just call copy deep copy to get to

01:09:19,529 --> 01:09:24,810
that so yes you did ask me a good

01:09:22,259 --> 01:09:28,170
question and no I didn't pay you to do

01:09:24,810 --> 01:09:29,549
that but to be honest I don't know if

01:09:28,170 --> 01:09:31,469
this is a case with other languages or

01:09:29,549 --> 01:09:33,509
not but in 14 straight years as a

01:09:31,469 --> 01:09:35,339
software engineering Python I actually

01:09:33,509 --> 01:09:37,350
not needed to use deep copy at all

01:09:35,339 --> 01:09:38,670
because most of the time when I'm going

01:09:37,350 --> 01:09:40,770
through a list I'm really wanting to

01:09:38,670 --> 01:09:42,600
just extract values from it like using

01:09:40,770 --> 01:09:44,279
filter or using a list comprehension or

01:09:42,600 --> 01:09:47,040
a generator expression I'm not really

01:09:44,279 --> 01:09:48,870
needing to actually make a real copy of

01:09:47,040 --> 01:09:50,759
the things and things this is restricted

01:09:48,870 --> 01:09:53,100
anyway there are certain objects that

01:09:50,759 --> 01:09:54,390
deep copy cannot copy it like if you had

01:09:53,100 --> 01:09:56,219
a file object in there you can't really

01:09:54,390 --> 01:09:58,230
copy a file object you know what I'm

01:09:56,219 --> 01:10:00,570
saying so you have to be kind of like

01:09:58,230 --> 01:10:02,160
cautious with using deep copy anyway or

01:10:00,570 --> 01:10:03,690
you can copy simple objects but anything

01:10:02,160 --> 01:10:06,960
more complicated it's more difficult to

01:10:03,690 --> 01:10:12,000
do okay all right so that's really the

01:10:06,960 --> 01:10:16,920
end of the talk so I do have a part two

01:10:12,000 --> 01:10:19,680
that I didn't get to so I will start

01:10:16,920 --> 01:10:22,830
doing that while I take more questions

01:10:19,680 --> 01:10:24,210
and I know we're wrapping up I know we

01:10:22,830 --> 01:10:26,489
have a few more minutes but I'm gonna

01:10:24,210 --> 01:10:29,190
see how close I can get to running over

01:10:26,489 --> 01:10:36,420
time so let me just make the second

01:10:29,190 --> 01:10:37,920
presentation here yeah yeah yeah so my

01:10:36,420 --> 01:10:39,360
second presentation I did this all last

01:10:37,920 --> 01:10:43,470
night after coming back from dinner so I

01:10:39,360 --> 01:10:45,030
did it all in plain text okay

01:10:43,470 --> 01:10:46,560
but nobody wants to see a presentation

01:10:45,030 --> 01:10:49,920
in plain text right so let's make a

01:10:46,560 --> 01:10:51,480
PowerPoint out of it oh wow I have a

01:10:49,920 --> 01:10:52,860
funny Python script that actually just

01:10:51,480 --> 01:10:54,870
takes plain text and makes me a

01:10:52,860 --> 01:10:56,490
PowerPoint presentation so I don't have

01:10:54,870 --> 01:10:58,820
to really do any kind of editing in

01:10:56,490 --> 01:11:01,380
PowerPoint

01:10:58,820 --> 01:11:04,460
this is take a few seconds cuz there's

01:11:01,380 --> 01:11:06,870
only a few slides here but I'm lazy

01:11:04,460 --> 01:11:08,880
because you know I had a little bit of

01:11:06,870 --> 01:11:09,830
red wine last night and I really

01:11:08,880 --> 01:11:12,480
wouldn't be able to manipulate

01:11:09,830 --> 01:11:14,910
PowerPoint in the mouth so I plain text

01:11:12,480 --> 01:11:18,180
I can handle when I'm drunk okay

01:11:14,910 --> 01:11:22,380
PowerPoint is not as easy to do okay so

01:11:18,180 --> 01:11:24,390
good mmm oh the reverse problem I can't

01:11:22,380 --> 01:11:33,300
go the other way yeah okay

01:11:24,390 --> 01:11:35,130
so so let's spend the last five minutes

01:11:33,300 --> 01:11:36,990
talking about Raymond stock from 2008

01:11:35,130 --> 01:11:39,150
which I wish he would repeat but since

01:11:36,990 --> 01:11:41,520
he's not doing I'll do it for him but

01:11:39,150 --> 01:11:43,040
using my way of doing things okay

01:11:41,520 --> 01:11:45,810
everybody gets to do it in their own way

01:11:43,040 --> 01:11:46,800
so just thinking about mutable container

01:11:45,810 --> 01:11:48,410
so I'm gonna blow through these pretty

01:11:46,800 --> 01:11:50,700
fast because we only have a few minutes

01:11:48,410 --> 01:11:52,350
but again it's very important to know

01:11:50,700 --> 01:11:53,790
some of this background data so let's

01:11:52,350 --> 01:11:55,740
talk about list a little bit in how they

01:11:53,790 --> 01:11:57,600
grow and shrink because if you know how

01:11:55,740 --> 01:12:01,230
this worked then you'll try to try to

01:11:57,600 --> 01:12:03,150
avoid them right okay so memory

01:12:01,230 --> 01:12:04,770
allocation there are good memory

01:12:03,150 --> 01:12:06,360
alligators and they're bad ones okay so

01:12:04,770 --> 01:12:07,530
it all depends on your operating system

01:12:06,360 --> 01:12:10,020
and things like that some things are out

01:12:07,530 --> 01:12:12,270
of pythons control okay so the good ones

01:12:10,020 --> 01:12:15,480
will you know really grow things in a

01:12:12,270 --> 01:12:17,730
smart way okay so Python just pretends

01:12:15,480 --> 01:12:19,860
every all day a memory allocation is bad

01:12:17,730 --> 01:12:22,080
okay so it tries to be as good as it

01:12:19,860 --> 01:12:24,030
possibly can okay regardless of the

01:12:22,080 --> 01:12:25,890
operating system that you're using okay

01:12:24,030 --> 01:12:28,830
so the trick is to leave room to grow

01:12:25,890 --> 01:12:30,590
okay so when you make a list it's gonna

01:12:28,830 --> 01:12:32,400
allocate just a little bit more in

01:12:30,590 --> 01:12:36,960
anticipating gonna do dot append a

01:12:32,400 --> 01:12:38,730
couple of times okay so so for example

01:12:36,960 --> 01:12:40,620
if you create an empty list there's no

01:12:38,730 --> 01:12:42,930
memory allocation except for the struck

01:12:40,620 --> 01:12:45,320
that you use to hold the list with if

01:12:42,930 --> 01:12:47,640
you you know do a dot append on an item

01:12:45,320 --> 01:12:50,160
instead of making just one slot it

01:12:47,640 --> 01:12:52,740
actually makes four slots okay for you

01:12:50,160 --> 01:12:54,360
so that if you do dot append data panda

01:12:52,740 --> 01:12:56,460
dot append again you don't have to go

01:12:54,360 --> 01:12:57,370
and reallocate more memory okay so

01:12:56,460 --> 01:13:00,010
that's an optimist

01:12:57,370 --> 01:13:01,870
datian and then only when you get to

01:13:00,010 --> 01:13:03,880
making the fifth one does it get another

01:13:01,870 --> 01:13:05,770
four okay

01:13:03,880 --> 01:13:07,420
and then so you can do another dot

01:13:05,770 --> 01:13:09,190
append up and I depend on a pen without

01:13:07,420 --> 01:13:11,530
paying any kind of penalty so it looks

01:13:09,190 --> 01:13:13,540
like it doubles every time you know it

01:13:11,530 --> 01:13:14,650
calls another serie a log right it looks

01:13:13,540 --> 01:13:16,180
like every time you go to the next when

01:13:14,650 --> 01:13:17,590
it doubles but it really doesn't because

01:13:16,180 --> 01:13:18,790
you know as you get really big you

01:13:17,590 --> 01:13:20,290
really don't want to double right

01:13:18,790 --> 01:13:22,810
because if I do you know a hundred

01:13:20,290 --> 01:13:24,460
thousand you know a pant am I gonna do a

01:13:22,810 --> 01:13:25,510
hundred thousand of pens so that when I

01:13:24,460 --> 01:13:26,830
get to a hundred thousand I'm gonna put

01:13:25,510 --> 01:13:28,870
a 200 thousand am I really gonna do

01:13:26,830 --> 01:13:30,310
another a hundred thousand pens probably

01:13:28,870 --> 01:13:33,220
not likely right so we want to kind of

01:13:30,310 --> 01:13:35,440
tail that off as we get bigger okay so

01:13:33,220 --> 01:13:37,270
that's so this is what the pattern is so

01:13:35,440 --> 01:13:39,190
it doubles to begin with and then it

01:13:37,270 --> 01:13:41,320
slowly starts to reduce the doubling

01:13:39,190 --> 01:13:43,060
okay and for as you get larger and

01:13:41,320 --> 01:13:45,010
larger it really does not go over more

01:13:43,060 --> 01:13:47,350
than two and a half percent okay to be

01:13:45,010 --> 01:13:48,550
more efficient that way okay and this is

01:13:47,350 --> 01:13:50,650
really good performance for a pen

01:13:48,550 --> 01:13:54,040
because it's just oh one right so that's

01:13:50,650 --> 01:13:56,140
very nice okay so let's take a look at

01:13:54,040 --> 01:13:57,640
what that is okay so when you you know

01:13:56,140 --> 01:13:59,380
it goes from zero to four eight sixteen

01:13:57,640 --> 01:14:00,640
you can keep on going so there's this

01:13:59,380 --> 01:14:03,070
function or so I'm just the new

01:14:00,640 --> 01:14:05,560
allocated size is zero I have a while

01:14:03,070 --> 01:14:07,420
true loop you know print the size of

01:14:05,560 --> 01:14:09,010
what the allocator is then but I want to

01:14:07,420 --> 01:14:10,810
figure out you know what is it when I

01:14:09,010 --> 01:14:12,940
want to at your pen something when I do

01:14:10,810 --> 01:14:13,840
give me an extra value on a list give me

01:14:12,940 --> 01:14:16,390
a value on the list

01:14:13,840 --> 01:14:18,670
what does it make my new size okay so

01:14:16,390 --> 01:14:20,260
what is G what is my growth my growing

01:14:18,670 --> 01:14:22,810
function the growing function can be

01:14:20,260 --> 01:14:24,370
defined here if you go to list objects

01:14:22,810 --> 01:14:25,870
see you can actually see the actual

01:14:24,370 --> 01:14:28,600
algorithm and that's this magic thing

01:14:25,870 --> 01:14:31,780
here so G is just this function that

01:14:28,600 --> 01:14:33,790
takes your size it multiplies it by or

01:14:31,780 --> 01:14:35,290
it shifts it by three and it checks you

01:14:33,790 --> 01:14:37,000
know it checks at the size is less than

01:14:35,290 --> 01:14:38,440
nine otherwise six so you don't have to

01:14:37,000 --> 01:14:40,090
really understand what that does all you

01:14:38,440 --> 01:14:42,390
need to know is that it does this which

01:14:40,090 --> 01:14:45,280
is the list allocation mechanism okay

01:14:42,390 --> 01:14:47,380
note that if you do have a lot of one to

01:14:45,280 --> 01:14:49,390
two item lists you really waste a lot of

01:14:47,380 --> 01:14:50,980
space because you're gonna have a bunch

01:14:49,390 --> 01:14:53,710
of like these dots everywhere that's

01:14:50,980 --> 01:14:56,590
like not used okay so try not to have a

01:14:53,710 --> 01:14:59,350
lot of short lists okay right understand

01:14:56,590 --> 01:15:01,630
that okay that's good so shrinking is

01:14:59,350 --> 01:15:03,610
kind of similar but it's easier it only

01:15:01,630 --> 01:15:05,620
calls realloc to reallocate read to

01:15:03,610 --> 01:15:07,210
recom packed the space only if you have

01:15:05,620 --> 01:15:08,920
less than what's half of Ballack was

01:15:07,210 --> 01:15:10,690
allocated so you go to the source again

01:15:08,920 --> 01:15:11,170
you see that you know whatever I have a

01:15:10,690 --> 01:15:13,449
left is

01:15:11,170 --> 01:15:17,140
is that greater than how what my new

01:15:13,449 --> 01:15:19,300
size is going to be and if not if it's

01:15:17,140 --> 01:15:20,860
not more less than a half which means is

01:15:19,300 --> 01:15:22,719
greater than equal to you know shifted

01:15:20,860 --> 01:15:26,500
by one then just don't even call realloc

01:15:22,719 --> 01:15:28,690
just return keep the size the same okay

01:15:26,500 --> 01:15:30,550
so removing is pretty easy it's also o

01:15:28,690 --> 01:15:32,590
of one when you pop at the end so when

01:15:30,550 --> 01:15:35,050
you do a pen and pop it's pretty good

01:15:32,590 --> 01:15:36,760
for lists if it's in the middle you pay

01:15:35,050 --> 01:15:37,810
a penalty because when you do things in

01:15:36,760 --> 01:15:39,760
the middle or the beginning you have to

01:15:37,810 --> 01:15:40,840
shift everything right so if you insert

01:15:39,760 --> 01:15:42,010
at the beginning if the shift everything

01:15:40,840 --> 01:15:43,120
to the right when you delete at the

01:15:42,010 --> 01:15:44,890
beginning of the shift everything to the

01:15:43,120 --> 01:15:46,810
left so unfortunately the performance

01:15:44,890 --> 01:15:50,290
gets much worse at the end okay so

01:15:46,810 --> 01:15:51,940
that's a problem there so so Raymond

01:15:50,290 --> 01:15:53,890
actually created this double ended queue

01:15:51,940 --> 01:15:56,590
object which you should use if you do a

01:15:53,890 --> 01:15:58,780
lot of this inserting in the in the at

01:15:56,590 --> 01:16:02,469
the beginnings or at the ends so this

01:15:58,780 --> 01:16:05,140
double ended queue is is really made for

01:16:02,469 --> 01:16:06,310
open access for pushing and popping at

01:16:05,140 --> 01:16:07,449
the beginning or at the end so you

01:16:06,310 --> 01:16:09,310
should look at that

01:16:07,449 --> 01:16:12,489
but it's slower for accessing stuff in

01:16:09,310 --> 01:16:14,350
the middle though but and then there's

01:16:12,489 --> 01:16:16,179
stuff about sets here I guess I'll just

01:16:14,350 --> 01:16:16,929
give you guys two slides slides are

01:16:16,179 --> 01:16:18,550
pretty fast

01:16:16,929 --> 01:16:20,469
I mean stats are pretty fast it's oh one

01:16:18,550 --> 01:16:24,400
from membership checking when it grows

01:16:20,469 --> 01:16:25,210
at two-thirds full it jumps by four but

01:16:24,400 --> 01:16:27,460
you have to keep in mind the

01:16:25,210 --> 01:16:28,840
dictionary's assets or and lists

01:16:27,460 --> 01:16:30,219
actually that sets it should be lit so

01:16:28,840 --> 01:16:31,900
I'll change this in the slides before I

01:16:30,219 --> 01:16:33,160
upload it they're very expensive so you

01:16:31,900 --> 01:16:35,260
can think of them like Italian sports

01:16:33,160 --> 01:16:36,429
cars okay they're very expensive but

01:16:35,260 --> 01:16:37,630
they're very fast because they've been

01:16:36,429 --> 01:16:40,420
in Python for so long they've been

01:16:37,630 --> 01:16:42,280
finely tuned okay in fact Tim Peters

01:16:40,420 --> 01:16:44,650
says that a patient Python dictionary is

01:16:42,280 --> 01:16:46,719
way faster than AC object that you

01:16:44,650 --> 01:16:48,520
haven't really optimized okay if they're

01:16:46,719 --> 01:16:51,219
really really fine-tune objects all

01:16:48,520 --> 01:16:53,170
right so review all your code and then I

01:16:51,219 --> 01:16:55,690
have some examples of how more examples

01:16:53,170 --> 01:16:57,250
of how to optimize so I guess eyestalks

01:16:55,690 --> 01:16:59,890
slowly enough so that I didn't have to

01:16:57,250 --> 01:17:02,260
use the slide material but if you had

01:16:59,890 --> 01:17:04,330
code to find like the longest line in a

01:17:02,260 --> 01:17:06,610
file takes a lot of effort right this is

01:17:04,330 --> 01:17:09,160
kind of complicated code but then you

01:17:06,610 --> 01:17:10,300
can like slowly refactor and you know

01:17:09,160 --> 01:17:13,000
maybe I'll talk about this some other

01:17:10,300 --> 01:17:15,070
time but you can't actually refactor all

01:17:13,000 --> 01:17:17,800
the way down to something this small or

01:17:15,070 --> 01:17:19,570
even smaller and then if you're really

01:17:17,800 --> 01:17:20,980
crazy you can write a one-liner but I

01:17:19,570 --> 01:17:22,610
don't recommend one-liners because you

01:17:20,980 --> 01:17:27,020
shouldn't be playing COBOL

01:17:22,610 --> 01:17:29,000
so so anyway that's all I have thank you

01:17:27,020 --> 01:17:31,570
very much for coming and I hope you guys

01:17:29,000 --> 01:17:31,570

YouTube URL: https://www.youtube.com/watch?v=HHFCFJSPWrI


