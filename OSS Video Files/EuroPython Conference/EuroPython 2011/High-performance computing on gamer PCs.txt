Title: High-performance computing on gamer PCs
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Yann Le Du - 20 June 2011 in "Track Lasagne"
Captions: 
	00:00:02,920 --> 00:00:13,490
convolution of two two functions plus so

00:00:10,670 --> 00:00:16,760
what we want to see is because we have

00:00:13,490 --> 00:00:18,440
constants like constant intensity which

00:00:16,760 --> 00:00:21,470
means smoke which means you cannot have

00:00:18,440 --> 00:00:24,050
negative density of matter it's one

00:00:21,470 --> 00:00:27,380
physical and I'll have this so when you

00:00:24,050 --> 00:00:29,600
use 4848 gives you negative values for

00:00:27,380 --> 00:00:33,910
the Texas so it's not little will's

00:00:29,600 --> 00:00:33,910
oisin going to help us attain physical

00:00:34,150 --> 00:00:40,790
yes first five we then all of this goes

00:00:38,330 --> 00:00:48,890
as i will show later this done using

00:00:40,790 --> 00:00:53,120
iphone this is a box and so here in red

00:00:48,890 --> 00:00:56,180
at university in gloom you have the

00:00:53,120 --> 00:01:00,950
neural network reconstruction aann and

00:00:56,180 --> 00:01:03,649
spas official google network and laptops

00:01:00,950 --> 00:01:06,590
you have to forget this for ya

00:01:03,649 --> 00:01:09,380
construction was gone bad mood because i

00:01:06,590 --> 00:01:12,200
know the density so i tried to fill

00:01:09,380 --> 00:01:15,109
before yet relatives until my obtain

00:01:12,200 --> 00:01:18,289
something that was the closest to me out

00:01:15,109 --> 00:01:22,759
but that's any stocks relations is the

00:01:18,289 --> 00:01:26,770
best for making you so the advantages of

00:01:22,759 --> 00:01:30,100
afm is easy to draw eyes

00:01:26,770 --> 00:01:33,130
we advise the code and medical is

00:01:30,100 --> 00:01:39,130
entitled and some specialized libraries

00:01:33,130 --> 00:01:42,490
work with and Athena and the good thing

00:01:39,130 --> 00:01:45,250
with enhanced once a artificial neural

00:01:42,490 --> 00:01:47,469
network is friends it's very fast to

00:01:45,250 --> 00:01:50,049
compute the surgeon we just do some

00:01:47,469 --> 00:01:56,500
matrix comfortable makes it typically

00:01:50,049 --> 00:02:00,310
matrix by inspectors very slow now this

00:01:56,500 --> 00:02:02,829
is again the equation these are these

00:02:00,310 --> 00:02:05,439
are examples that we get is of

00:02:02,829 --> 00:02:09,899
artificial examples in imaging coatings

00:02:05,439 --> 00:02:13,810
ten homes so build 10 pounds using

00:02:09,899 --> 00:02:17,970
shapes that we know correspond to the

00:02:13,810 --> 00:02:20,049
real shape based shapes were built of

00:02:17,970 --> 00:02:21,610
composites times there are not many

00:02:20,049 --> 00:02:25,750
times because you do not have the

00:02:21,610 --> 00:02:29,769
continuity condition different parts of

00:02:25,750 --> 00:02:33,609
the presence times and to build these

00:02:29,769 --> 00:02:36,430
vines we use Python library and this is

00:02:33,609 --> 00:02:37,069
discounted site on a mainly will be to

00:02:36,430 --> 00:02:40,609
develop

00:02:37,069 --> 00:02:42,709
we use my phone we just have to explore

00:02:40,609 --> 00:02:45,560
everything we can and when we really

00:02:42,709 --> 00:02:51,139
understand what's happening we then move

00:02:45,560 --> 00:02:53,870
too little for them I'll show you so

00:02:51,139 --> 00:02:56,569
what's the neural network-based so

00:02:53,870 --> 00:02:59,840
normal network here is the propagation

00:02:56,569 --> 00:03:04,099
of the same old so the input would be a

00:02:59,840 --> 00:03:06,590
tpr etc what nature gives good and here

00:03:04,099 --> 00:03:09,169
are the computational new ones and here

00:03:06,590 --> 00:03:12,650
is an output so we use in particular

00:03:09,169 --> 00:03:16,189
network was proposed are debated ok will

00:03:12,650 --> 00:03:18,919
converge which means we have infants is

00:03:16,189 --> 00:03:21,500
the suction and you will expect here the

00:03:18,919 --> 00:03:24,560
density so why do they have only one you

00:03:21,500 --> 00:03:28,819
know because the network actually builds

00:03:24,560 --> 00:03:31,040
the density ponds by this is more than a

00:03:28,819 --> 00:03:34,400
single people so these are called hidden

00:03:31,040 --> 00:03:37,340
neurons these are the computation so

00:03:34,400 --> 00:03:39,980
this is the first you know network we

00:03:37,340 --> 00:03:43,400
use but gave the results I showed you

00:03:39,980 --> 00:03:45,590
earlier was very nice very good but we

00:03:43,400 --> 00:03:47,870
wanted to improve on that because the

00:03:45,590 --> 00:03:51,379
thumbs the Phantom's we use of the time

00:03:47,870 --> 00:03:54,709
with very simple atoms and we like the

00:03:51,379 --> 00:03:59,720
new network to build to work on context

00:03:54,709 --> 00:04:01,849
and cons but because it's not so if you

00:03:59,720 --> 00:04:04,579
if you now about them equations for

00:04:01,849 --> 00:04:07,310
neural network is not written in many

00:04:04,579 --> 00:04:10,579
places but basically a neural network is

00:04:07,310 --> 00:04:13,639
a machine compute Memphis's ty

00:04:10,579 --> 00:04:15,949
inspectors so this is very important

00:04:13,639 --> 00:04:18,769
because he used a neural network with a

00:04:15,949 --> 00:04:21,500
few new ones that we don't care if it's

00:04:18,769 --> 00:04:24,229
a matrix-vector computation you can turn

00:04:21,500 --> 00:04:26,120
any kind loops anything anything will

00:04:24,229 --> 00:04:27,380
work because you have so few neurons

00:04:26,120 --> 00:04:29,930
that to come

00:04:27,380 --> 00:04:32,450
very fast but it's not possible to do

00:04:29,930 --> 00:04:35,060
this anymore when we have millions we

00:04:32,450 --> 00:04:37,130
have large deficits we want to go so you

00:04:35,060 --> 00:04:39,290
want to optimize and the first thing

00:04:37,130 --> 00:04:41,600
figured out optimizing it is

00:04:39,290 --> 00:04:44,750
privatization the first thing we have to

00:04:41,600 --> 00:04:47,120
do we want to mobilize code is to first

00:04:44,750 --> 00:04:50,450
look is it possible to park this as a

00:04:47,120 --> 00:04:52,360
matrix effective concentration where are

00:04:50,450 --> 00:04:55,070
the men tracers work are the vectors

00:04:52,360 --> 00:04:57,440
mainly when are the tenses attend

00:04:55,070 --> 00:05:02,000
servitor more than two dimensional

00:04:57,440 --> 00:05:06,200
makers so this is the basic function of

00:05:02,000 --> 00:05:10,100
the neural network so this is a need to

00:05:06,200 --> 00:05:12,170
do decolonization matrix computation and

00:05:10,100 --> 00:05:14,630
the mapping mapping workforce is they're

00:05:12,170 --> 00:05:20,030
easy to fertilize because nothing is in

00:05:14,630 --> 00:05:22,220
the event of all the epidemic so what we

00:05:20,030 --> 00:05:24,620
use now for the convolution is called is

00:05:22,220 --> 00:05:27,500
a particular kinds of neural network or

00:05:24,620 --> 00:05:31,400
reservoir network it's belongs to the

00:05:27,500 --> 00:05:33,770
paradigm reservoir computing so you have

00:05:31,400 --> 00:05:36,380
an input layer which is what nature

00:05:33,770 --> 00:05:39,740
gives you and the output which is a

00:05:36,380 --> 00:05:43,040
single point in the density and here we

00:05:39,740 --> 00:05:46,160
have the show with all the time if what

00:05:43,040 --> 00:05:49,940
we use in fact is the reservoir with an

00:05:46,160 --> 00:05:53,180
architecture caused by my option so if

00:05:49,940 --> 00:06:00,110
you look I will show your picture

00:05:53,180 --> 00:06:02,600
I so if you now move on the autistic

00:06:00,110 --> 00:06:05,570
view of the brain and the reservoir to

00:06:02,600 --> 00:06:08,389
Leeds inactive used to make the code

00:06:05,570 --> 00:06:12,710
then you see here that you had a sports

00:06:08,389 --> 00:06:15,470
random directed graph which has to have

00:06:12,710 --> 00:06:19,009
special qualities and these properties

00:06:15,470 --> 00:06:22,370
are studying using logical network X and

00:06:19,009 --> 00:06:26,750
that using this library we characterize

00:06:22,370 --> 00:06:30,190
the graph to rapidly build and we'll

00:06:26,750 --> 00:06:33,889
make sure that it has the boxes so any

00:06:30,190 --> 00:06:38,840
input you want and have the matrix that

00:06:33,889 --> 00:06:43,250
in fact cones the input to the brain so

00:06:38,840 --> 00:06:46,160
reservoir is they went idea it with me

00:06:43,250 --> 00:06:49,490
since Howard I've developed in 2006 and

00:06:46,160 --> 00:06:51,800
what what we do in this paradigm is that

00:06:49,490 --> 00:06:54,229
you have this manual network that

00:06:51,800 --> 00:06:58,699
imitates the rain random connection

00:06:54,229 --> 00:07:02,030
sponsor and here you have the output

00:06:58,699 --> 00:07:05,090
neurons contrary to the previous reports

00:07:02,030 --> 00:07:07,909
to show you you only change those words

00:07:05,090 --> 00:07:10,630
during learning you never touch those

00:07:07,909 --> 00:07:17,570
weights get the ones here are given

00:07:10,630 --> 00:07:20,659
another check what you change is this so

00:07:17,570 --> 00:07:23,840
when once you have this network what you

00:07:20,659 --> 00:07:26,389
need is to write down what you do with

00:07:23,840 --> 00:07:28,669
reservoir using matrix vector

00:07:26,389 --> 00:07:31,130
computation as I told you earlier if

00:07:28,669 --> 00:07:33,889
you're able to write what you do using

00:07:31,130 --> 00:07:37,070
matrices and vectors then you can do

00:07:33,889 --> 00:07:40,070
anything so let's try to write down what

00:07:37,070 --> 00:07:43,430
the problem is how you can be written in

00:07:40,070 --> 00:07:47,659
matrix vector and then we map this

00:07:43,430 --> 00:07:49,610
inside the reservoir back again into the

00:07:47,659 --> 00:07:53,720
equation what you do is you do a

00:07:49,610 --> 00:07:55,880
dissertation of the integral so as I

00:07:53,720 --> 00:07:58,220
said in the throat I expect you know

00:07:55,880 --> 00:08:00,080
what it means to discretize an integral

00:07:58,220 --> 00:08:02,229
basically this precise this

00:08:00,080 --> 00:08:03,900
discretization i right here is a simple

00:08:02,229 --> 00:08:06,509
collocation despot eyes

00:08:03,900 --> 00:08:09,389
and you don't arrive to a matrix

00:08:06,509 --> 00:08:12,539
equation and here what we want to do is

00:08:09,389 --> 00:08:15,180
to inverse this equation here and what

00:08:12,539 --> 00:08:17,220
you want to do is inverse C but the

00:08:15,180 --> 00:08:19,410
problem with c is that it's ill

00:08:17,220 --> 00:08:24,449
conditioned which means that if you have

00:08:19,410 --> 00:08:27,680
slight variations on earth and there

00:08:24,449 --> 00:08:31,139
will be massive differences in this

00:08:27,680 --> 00:08:34,529
condition but what does the network

00:08:31,139 --> 00:08:39,440
actually do well the network is actually

00:08:34,529 --> 00:08:41,969
in versing this equation but using an

00:08:39,440 --> 00:08:44,459
activation function which is normally

00:08:41,969 --> 00:08:47,250
here so what is this activation function

00:08:44,459 --> 00:08:50,820
once you have computed the neurons you

00:08:47,250 --> 00:08:53,040
apply f to each new long as I told you

00:08:50,820 --> 00:08:55,350
earlier there is a mapping this is where

00:08:53,040 --> 00:08:58,170
the map incomes thing and what the magic

00:08:55,350 --> 00:09:00,900
comes in this function here is nonlinear

00:08:58,170 --> 00:09:04,440
and what you do is you hope the network

00:09:00,900 --> 00:09:07,650
is able to build the inverse of the

00:09:04,440 --> 00:09:10,080
matrix by reservoir matchup because

00:09:07,650 --> 00:09:12,990
basically there are many conjectures on

00:09:10,080 --> 00:09:15,870
the workings of the reservoir but no

00:09:12,990 --> 00:09:18,270
theorems two theorems for many

00:09:15,870 --> 00:09:20,760
conjectures so it's actually a field in

00:09:18,270 --> 00:09:24,360
which some mathematicians work because

00:09:20,760 --> 00:09:26,790
we don't really understand the whole old

00:09:24,360 --> 00:09:29,040
workings of a relevant we only know that

00:09:26,790 --> 00:09:36,660
it works as at least as well as

00:09:29,040 --> 00:09:39,050
regularly but short of time so once you

00:09:36,660 --> 00:09:43,500
have understood this you need to

00:09:39,050 --> 00:09:47,250
optimize the network as I told you the

00:09:43,500 --> 00:09:49,950
network here is random but it never

00:09:47,250 --> 00:09:52,170
changes so how do you know that you have

00:09:49,950 --> 00:09:55,320
found the right Network well you need to

00:09:52,170 --> 00:09:59,310
explore many kinds of networks so you

00:09:55,320 --> 00:10:00,930
need to do some kind of optimization but

00:09:59,310 --> 00:10:03,810
you need to optimize the reservoir ways

00:10:00,930 --> 00:10:05,400
but there can be many local Mainer how

00:10:03,810 --> 00:10:11,180
do you know that you find a global

00:10:05,400 --> 00:10:11,180
minimum i can show you an animation

00:10:28,949 --> 00:10:35,100
so here is a small animation

00:11:05,320 --> 00:11:07,380
Oh

00:11:18,780 --> 00:11:26,640
okay so what's happening here you have

00:11:22,380 --> 00:11:30,120
you have a function here you have a low

00:11:26,640 --> 00:11:33,630
many local minima and you have only a

00:11:30,120 --> 00:11:37,380
single global minimum it's at the sensor

00:11:33,630 --> 00:11:40,620
here so how do you manage to find the

00:11:37,380 --> 00:11:48,780
global minima well we use for that we

00:11:40,620 --> 00:11:51,540
use that we use a technique called swarm

00:11:48,780 --> 00:11:56,070
optimization coupled to a genetic

00:11:51,540 --> 00:12:00,090
algorithm so here you have a swore here

00:11:56,070 --> 00:12:03,750
that evolves in time and each of these

00:12:00,090 --> 00:12:07,500
particles go to a new place by genetic

00:12:03,750 --> 00:12:10,800
variation and we minimize locally and we

00:12:07,500 --> 00:12:13,320
find the local minimum then we compare

00:12:10,800 --> 00:12:16,770
the different what the different

00:12:13,320 --> 00:12:19,110
particles have obtained as mini if the

00:12:16,770 --> 00:12:23,190
pot is better than another one it calls

00:12:19,110 --> 00:12:25,020
the other way like in this war and using

00:12:23,190 --> 00:12:27,660
this you see that in the end you have a

00:12:25,020 --> 00:12:30,870
very fast convergence to the global

00:12:27,660 --> 00:12:33,180
minimum even though you stop from very

00:12:30,870 --> 00:12:35,010
far away so this is another function

00:12:33,180 --> 00:12:37,170
that is used for testing global

00:12:35,010 --> 00:12:39,510
minimizes it's called the fox hole

00:12:37,170 --> 00:12:42,390
function because you have it's very flat

00:12:39,510 --> 00:12:46,560
and you only have a few holes and the

00:12:42,390 --> 00:12:51,150
real minimum is a here p that i start

00:12:46,560 --> 00:12:54,360
with a i start with a very few particles

00:12:51,150 --> 00:12:57,150
and none of the particles is in the

00:12:54,360 --> 00:12:59,370
global minimum but then thanks to this

00:12:57,150 --> 00:13:03,600
swarm optimization i find the global

00:12:59,370 --> 00:13:05,370
minimum but here is another example but

00:13:03,600 --> 00:13:07,500
in this example you will see that the

00:13:05,370 --> 00:13:12,210
particles do not converge to the global

00:13:07,500 --> 00:13:16,110
minimum be of course the algorithm can

00:13:12,210 --> 00:13:18,630
can fail it has its not fail safe so

00:13:16,110 --> 00:13:22,530
what you want to do is to make sure that

00:13:18,630 --> 00:13:24,780
you generate many many minimizes many

00:13:22,530 --> 00:13:27,300
global minimizes and you hope that among

00:13:24,780 --> 00:13:30,680
all the many minimizes one of them will

00:13:27,300 --> 00:13:30,680
find the true global minima

00:13:31,189 --> 00:13:38,369
hey why I like to watch these movies

00:13:36,240 --> 00:13:39,930
because you know either swarm converging

00:13:38,369 --> 00:13:42,569
is like it works like magic and the

00:13:39,930 --> 00:13:45,930
algorithm behind is very simple this

00:13:42,569 --> 00:13:48,720
code was written using a ipython using

00:13:45,930 --> 00:13:50,999
the PI lab library and it runs very fast

00:13:48,720 --> 00:13:52,949
one day I learned about the algorithm at

00:13:50,999 --> 00:13:55,110
the end of the day I had these pictures

00:13:52,949 --> 00:13:58,519
and I was a happy and I knew that I was

00:13:55,110 --> 00:13:58,519
on my way to finding the global minimum

00:13:58,879 --> 00:14:05,009
so here is another big function you have

00:14:01,920 --> 00:14:06,809
many local minimum many maxima and you

00:14:05,009 --> 00:14:10,379
try to find the real minimum which is

00:14:06,809 --> 00:14:13,319
here but sometimes the convergence can

00:14:10,379 --> 00:14:16,350
be very slow so you need locked a long

00:14:13,319 --> 00:14:17,879
time you need many iterations so this is

00:14:16,350 --> 00:14:21,179
why you have to paralyze the code

00:14:17,879 --> 00:14:22,649
otherwise it's no hope so you have to

00:14:21,179 --> 00:14:24,629
understand one thing is that many

00:14:22,649 --> 00:14:27,089
techniques that were developed a long

00:14:24,629 --> 00:14:28,350
time ago one could not be applied a long

00:14:27,089 --> 00:14:30,629
time ago because there was no

00:14:28,350 --> 00:14:32,850
computational resource to make the

00:14:30,629 --> 00:14:34,980
algorithm work but now we do have the

00:14:32,850 --> 00:14:37,350
company of computational resources to

00:14:34,980 --> 00:14:40,279
make special algorithms heuristic

00:14:37,350 --> 00:14:40,279
algorithms work

00:14:47,070 --> 00:14:49,730
hey

00:14:52,089 --> 00:14:54,569
though

00:14:58,160 --> 00:15:02,629
so you need to find a global minimum

00:15:00,639 --> 00:15:04,579
this is the picture of the global

00:15:02,629 --> 00:15:07,069
minimum you have many particles that are

00:15:04,579 --> 00:15:09,709
launched in different parts in parameter

00:15:07,069 --> 00:15:12,319
space then when they arrive on the top

00:15:09,709 --> 00:15:14,060
of the hill they climbed down and define

00:15:12,319 --> 00:15:16,399
their local minimum and they say that's

00:15:14,060 --> 00:15:18,470
my quality my quality is my local

00:15:16,399 --> 00:15:20,449
minimum and then I use it and I

00:15:18,470 --> 00:15:24,290
genetically cross over with others and

00:15:20,449 --> 00:15:26,060
the genetic crossover actually the

00:15:24,290 --> 00:15:29,480
genetic crossover that happens actually

00:15:26,060 --> 00:15:33,579
happens on the sports random Network

00:15:29,480 --> 00:15:36,199
wait so the genes are the network wait

00:15:33,579 --> 00:15:40,100
so the three main are going ons we use

00:15:36,199 --> 00:15:42,139
are the the reservoir computing with a

00:15:40,100 --> 00:15:44,870
fly I architecture then we use the

00:15:42,139 --> 00:15:48,439
particle swarm optimization and then a

00:15:44,870 --> 00:15:51,230
genetic cross over take the swarm move

00:15:48,439 --> 00:15:55,339
how does the swarm move and how does it

00:15:51,230 --> 00:15:57,230
mix up how does it genetically mix up of

00:15:55,339 --> 00:15:59,180
course these algorithms can only work

00:15:57,230 --> 00:16:01,279
with you proly lies them and the

00:15:59,180 --> 00:16:07,160
workhorse today for parameterization or

00:16:01,279 --> 00:16:08,689
GPUs then in the end after enough to

00:16:07,160 --> 00:16:11,089
this I will show you the software and

00:16:08,689 --> 00:16:13,459
the hardware architecture we use in the

00:16:11,089 --> 00:16:15,290
end when once you have many candidates

00:16:13,459 --> 00:16:19,040
how do you choose among all the

00:16:15,290 --> 00:16:21,889
candidate but we use a particular

00:16:19,040 --> 00:16:28,850
technique that imitates what what's and

00:16:21,889 --> 00:16:30,740
does to of what sin does to beat human

00:16:28,850 --> 00:16:33,079
participants in a game called jeopardy

00:16:30,740 --> 00:16:36,110
jeopardy is a game that is based on

00:16:33,079 --> 00:16:38,089
things like what's the size of Italy ok

00:16:36,110 --> 00:16:40,899
that's easy for computer and other

00:16:38,089 --> 00:16:44,949
questions which are based on on wordplay

00:16:40,899 --> 00:16:47,959
ambiguous meanings so and at that game

00:16:44,949 --> 00:16:50,740
what sin does beat the crap out of the

00:16:47,959 --> 00:16:53,870
best humans that ever play that jeopardy

00:16:50,740 --> 00:16:56,329
so what Watson does is that it selects

00:16:53,870 --> 00:16:59,180
it has many algorithms it's all the

00:16:56,329 --> 00:17:02,120
algorithms select a candidate answer and

00:16:59,180 --> 00:17:04,610
then if one answer has a probability

00:17:02,120 --> 00:17:08,750
higher than fifty percent of being true

00:17:04,610 --> 00:17:10,760
then Watson both if it's lower than

00:17:08,750 --> 00:17:11,959
fifty percent it doesn't vote so we

00:17:10,760 --> 00:17:14,390
actually develop something

00:17:11,959 --> 00:17:19,130
similar in the end we have many

00:17:14,390 --> 00:17:21,169
candidates or all the ifly architectures

00:17:19,130 --> 00:17:24,439
we have candidates that claim they have

00:17:21,169 --> 00:17:26,419
the right answer then we have a what we

00:17:24,439 --> 00:17:28,339
call a possibility estimate it's not the

00:17:26,419 --> 00:17:29,960
probability has nothing I mean it has to

00:17:28,339 --> 00:17:31,669
do with probability but it's called the

00:17:29,960 --> 00:17:33,770
theory of possibilities it's not the

00:17:31,669 --> 00:17:36,080
theory of probability and so we use the

00:17:33,770 --> 00:17:39,260
theory of possibilities to build the

00:17:36,080 --> 00:17:41,299
matrix and in this matrix we select the

00:17:39,260 --> 00:17:44,510
the one that has a possibility higher

00:17:41,299 --> 00:17:47,690
than point five and to do that we have a

00:17:44,510 --> 00:17:51,380
very large matrix it's very large and we

00:17:47,690 --> 00:17:53,960
want to find the lowest in all the lines

00:17:51,380 --> 00:17:56,630
and four and for that we use the

00:17:53,960 --> 00:17:59,600
argument function which is called the

00:17:56,630 --> 00:18:01,669
parallel row reduction because you have

00:17:59,600 --> 00:18:03,830
this big matrix and you want to find the

00:18:01,669 --> 00:18:07,450
minimum on all the lines so you want to

00:18:03,830 --> 00:18:10,130
reduce the matrix to a single column

00:18:07,450 --> 00:18:13,640
this is called augment and you have a

00:18:10,130 --> 00:18:16,669
very good row reduction functions that

00:18:13,640 --> 00:18:21,440
work on the CUDA library are linked to

00:18:16,669 --> 00:18:23,690
python so it's very easy to test okay so

00:18:21,440 --> 00:18:25,940
this is the fly I here so you see an eye

00:18:23,690 --> 00:18:29,059
here which is made up of many cells

00:18:25,940 --> 00:18:33,740
called each cell is called an epi diem

00:18:29,059 --> 00:18:35,289
and all of these cells are here each of

00:18:33,740 --> 00:18:37,640
these ones each of these cells

00:18:35,289 --> 00:18:43,130
specializes in the reconstruction of the

00:18:37,640 --> 00:18:44,899
single point in the density of course

00:18:43,130 --> 00:18:46,760
all of these are computed in parallel

00:18:44,899 --> 00:18:48,740
when you want to penalize you have to be

00:18:46,760 --> 00:18:50,630
obsessed with matrices and vectors you

00:18:48,740 --> 00:18:52,669
just only think about this where are the

00:18:50,630 --> 00:18:55,039
matrices where are the vectors where are

00:18:52,669 --> 00:18:58,120
the mappings where are the red be

00:18:55,039 --> 00:19:02,720
reductions if you find these it's good

00:18:58,120 --> 00:19:05,120
and for that we use the library called

00:19:02,720 --> 00:19:07,610
pi q de python cuda it's so wrapping

00:19:05,120 --> 00:19:08,750
around the cuda library very easy you

00:19:07,610 --> 00:19:10,429
have to think that i'm not a

00:19:08,750 --> 00:19:13,220
professional programmer so i want

00:19:10,429 --> 00:19:15,710
something that works easily and pi pi q

00:19:13,220 --> 00:19:18,039
that is just a stick because you can

00:19:15,710 --> 00:19:20,779
test all of these IDs in a few days

00:19:18,039 --> 00:19:23,000
otherwise I remember when I first looked

00:19:20,779 --> 00:19:24,980
at GPUs a long time ago you had to look

00:19:23,000 --> 00:19:26,450
at the assembly code for G

00:19:24,980 --> 00:19:28,610
use and stuff like that was just

00:19:26,450 --> 00:19:30,020
horrible and for me I couldn't you know

00:19:28,610 --> 00:19:32,929
I couldn't work on that it's not

00:19:30,020 --> 00:19:35,419
possible for me so then when this came

00:19:32,929 --> 00:19:41,660
out with the corresponding cards cards

00:19:35,419 --> 00:19:44,030
GPU cause it was just fantastic but here

00:19:41,660 --> 00:19:48,049
is this the faster summary of what we do

00:19:44,030 --> 00:19:50,960
and pull the all the algorithms and in

00:19:48,049 --> 00:19:53,809
each step here that you see everything

00:19:50,960 --> 00:19:56,840
we do a Python into these Python Python

00:19:53,809 --> 00:19:59,299
libraries and sometimes and very small

00:19:56,840 --> 00:20:02,270
places you have little codes written in

00:19:59,299 --> 00:20:05,059
C but the code written in C is in fact

00:20:02,270 --> 00:20:07,970
wrapped inside pi q de it's called a

00:20:05,059 --> 00:20:10,669
colonel a see colonel and it's it's it's

00:20:07,970 --> 00:20:12,500
it's useful to have a little see journal

00:20:10,669 --> 00:20:15,080
when you do not have an existing

00:20:12,500 --> 00:20:17,360
function that does what you want to do

00:20:15,080 --> 00:20:19,850
so sometimes I'm obliged to write a few

00:20:17,360 --> 00:20:22,490
lines of C but when I write those few

00:20:19,850 --> 00:20:24,590
lines it's nice see because it's see

00:20:22,490 --> 00:20:26,030
when it's useful it's not see when you

00:20:24,590 --> 00:20:28,760
have to do things which are you know

00:20:26,030 --> 00:20:30,679
everywhere which frightens me so it's

00:20:28,760 --> 00:20:32,210
just see when you have loops simple

00:20:30,679 --> 00:20:36,410
things good things for people like me

00:20:32,210 --> 00:20:39,770
who are not expert programmers though

00:20:36,410 --> 00:20:41,570
this is an algorithm so now literate

00:20:39,770 --> 00:20:43,730
programming all of this if you look at

00:20:41,570 --> 00:20:45,890
this big algorithm it's very big for a

00:20:43,730 --> 00:20:48,860
single brain so in HP you for science

00:20:45,890 --> 00:20:51,140
there are little core team were about

00:20:48,860 --> 00:20:53,030
five people working on it with a few

00:20:51,140 --> 00:20:55,700
people working on the general framework

00:20:53,030 --> 00:20:58,520
for hardware and stuff like that but we

00:20:55,700 --> 00:21:00,110
only have three people programming so

00:20:58,520 --> 00:21:02,390
these these people have to have

00:21:00,110 --> 00:21:04,750
everything in the blade and to hold

00:21:02,390 --> 00:21:07,400
everything like this in one single brain

00:21:04,750 --> 00:21:09,470
it's not easy so we have to help

00:21:07,400 --> 00:21:11,660
ourselves with programming paradigm

00:21:09,470 --> 00:21:14,690
called literate programming this I

00:21:11,660 --> 00:21:18,520
discovered with Donald Knuth who is a

00:21:14,690 --> 00:21:21,710
very famous programmer with you know

00:21:18,520 --> 00:21:24,110
though Donald Knuth is wrote about

00:21:21,710 --> 00:21:27,110
literate programming the main thing is

00:21:24,110 --> 00:21:29,210
the problem L strives for a program that

00:21:27,110 --> 00:21:31,549
is comprehensible because its concepts

00:21:29,210 --> 00:21:34,159
have been introduced in an order that is

00:21:31,549 --> 00:21:35,960
best for human understanding so what

00:21:34,159 --> 00:21:38,000
does it mean what does it mean it's good

00:21:35,960 --> 00:21:38,690
it's good for excellence it's very good

00:21:38,000 --> 00:21:40,340
for science

00:21:38,690 --> 00:21:41,750
the complications because when you do

00:21:40,340 --> 00:21:44,930
something when you do scientific

00:21:41,750 --> 00:21:46,820
investigations you start where you can

00:21:44,930 --> 00:21:48,800
it's a very stupid sentence but that's

00:21:46,820 --> 00:21:50,300
what you actually do so you start with

00:21:48,800 --> 00:21:52,520
the first ID that comes to you and

00:21:50,300 --> 00:21:54,650
that's how literate programming work you

00:21:52,520 --> 00:21:57,710
start to write the code as it comes to

00:21:54,650 --> 00:21:59,510
you oh I have to do this and then maybe

00:21:57,710 --> 00:22:01,970
I have to import some library let's

00:21:59,510 --> 00:22:04,670
import it now and then you know you just

00:22:01,970 --> 00:22:06,890
do it as as you like so what does it

00:22:04,670 --> 00:22:10,090
look like this is a cold without

00:22:06,890 --> 00:22:14,600
literate programming it's three lines

00:22:10,090 --> 00:22:17,660
it's a colonel it's a ste colonel just

00:22:14,600 --> 00:22:20,510
to do some simple vector addition very

00:22:17,660 --> 00:22:21,950
simple very straightforward but what you

00:22:20,510 --> 00:22:25,250
have to remember is that when you use

00:22:21,950 --> 00:22:27,830
when you use GPU the very nice thing is

00:22:25,250 --> 00:22:31,960
that all the cores in the GPU do the

00:22:27,830 --> 00:22:35,110
same thing except their index changes

00:22:31,960 --> 00:22:38,960
they have an address which is here

00:22:35,110 --> 00:22:41,270
threads idx from X that changes so it's

00:22:38,960 --> 00:22:45,940
very simple when you do vector addition

00:22:41,270 --> 00:22:48,980
i will be the the online in position

00:22:45,940 --> 00:22:50,990
that will be mapped to the core number

00:22:48,980 --> 00:22:53,030
so it's very easy once you understand

00:22:50,990 --> 00:22:55,490
that so how do you write this in

00:22:53,030 --> 00:22:58,130
literate programming okay this is simple

00:22:55,490 --> 00:23:00,530
for people who do who know basic maths

00:22:58,130 --> 00:23:02,240
okay this is simple but just for the

00:23:00,530 --> 00:23:03,980
sake of the argument how do you program

00:23:02,240 --> 00:23:06,650
this in literate programming because

00:23:03,980 --> 00:23:08,180
this is easy but you know when it's once

00:23:06,650 --> 00:23:10,220
it's written you just forget about it

00:23:08,180 --> 00:23:12,470
you're not very proud of this very easy

00:23:10,220 --> 00:23:13,970
let's get proud of what we do and let's

00:23:12,470 --> 00:23:16,450
do something that we can show to the

00:23:13,970 --> 00:23:20,360
other people and say oh it looks good

00:23:16,450 --> 00:23:22,490
but this is these two pages corresponds

00:23:20,360 --> 00:23:25,670
to the liquid program that is equivalent

00:23:22,490 --> 00:23:27,910
to those three lines okay i have added

00:23:25,670 --> 00:23:31,160
lots of stuff in it and it's a very nice

00:23:27,910 --> 00:23:33,020
so what it does here is that I I'm

00:23:31,160 --> 00:23:35,210
explaining the code so somewhere in

00:23:33,020 --> 00:23:37,130
there is not even an undergrad who comes

00:23:35,210 --> 00:23:39,170
from high school it doesn't have you

00:23:37,130 --> 00:23:41,570
know good memories of how vectors work

00:23:39,170 --> 00:23:44,540
so I just explained to him what a vector

00:23:41,570 --> 00:23:48,530
is basically and then I explain a vector

00:23:44,540 --> 00:23:50,559
addition here very simply and then I say

00:23:48,530 --> 00:23:54,639
so if you want to add though

00:23:50,559 --> 00:23:57,759
vectors let's write the vectors as UI +

00:23:54,639 --> 00:24:01,960
VI this is where the code comes in there

00:23:57,759 --> 00:24:04,330
is no import no function argument

00:24:01,960 --> 00:24:06,340
declaration nothing you just write the

00:24:04,330 --> 00:24:10,779
code when it's useful for the

00:24:06,340 --> 00:24:14,529
presentation then you continue and you

00:24:10,779 --> 00:24:17,169
say oh but then i define I what's I oh I

00:24:14,529 --> 00:24:20,470
is the position on in the vector it

00:24:17,169 --> 00:24:22,749
corresponds to the thread idx let's go

00:24:20,470 --> 00:24:24,519
in the documentation or your thread idx

00:24:22,749 --> 00:24:28,570
so this is the definition for the thread

00:24:24,519 --> 00:24:30,639
and then oh you know it's see so I have

00:24:28,570 --> 00:24:33,009
to declare the function declare the

00:24:30,639 --> 00:24:35,799
arguments the Claret type let's do it

00:24:33,009 --> 00:24:38,470
now because this is not as funny as what

00:24:35,799 --> 00:24:43,330
we did before but we can do it now so we

00:24:38,470 --> 00:24:46,200
just split the code you know went in a

00:24:43,330 --> 00:24:48,580
in an order that fit the presentation

00:24:46,200 --> 00:24:51,249
once you do this you obtain the final

00:24:48,580 --> 00:24:53,649
code that i showed you earlier and for

00:24:51,249 --> 00:24:55,929
that to obtain this code you use the

00:24:53,649 --> 00:24:57,850
program called no web which is an

00:24:55,929 --> 00:25:02,919
adaptation of the program written by new

00:24:57,850 --> 00:25:06,039
circle the web and that that program is

00:25:02,919 --> 00:25:08,590
filled no web and inside you have to sub

00:25:06,039 --> 00:25:12,700
functions called no tengo and no we've

00:25:08,590 --> 00:25:16,059
no tengo builds the code no we've build

00:25:12,700 --> 00:25:18,730
the documentation that's the code built

00:25:16,059 --> 00:25:23,619
by no tengo and that's the documentation

00:25:18,730 --> 00:25:25,570
built by know we've the literate

00:25:23,619 --> 00:25:28,299
programming just you know go a little

00:25:25,570 --> 00:25:30,070
further in the argument is is here to

00:25:28,299 --> 00:25:32,860
help you to help you reduce the

00:25:30,070 --> 00:25:34,840
complexity when I read the archives

00:25:32,860 --> 00:25:37,600
there's a very nice archives with the

00:25:34,840 --> 00:25:39,129
handwritten notes of Dykstra on the web

00:25:37,600 --> 00:25:40,840
it's very nice to read all this

00:25:39,129 --> 00:25:43,600
sometimes it's funny is a very very

00:25:40,840 --> 00:25:45,009
tough guy he's not very nice always but

00:25:43,600 --> 00:25:47,980
it's very interesting to read and it has

00:25:45,009 --> 00:25:50,259
a very nice handwriting so the Dykstra

00:25:47,980 --> 00:25:53,049
says I hope that they in the future

00:25:50,259 --> 00:25:55,809
languages should deepen our

00:25:53,049 --> 00:25:57,999
understanding of the of the processes

00:25:55,809 --> 00:26:00,190
and design and creation it should give

00:25:57,999 --> 00:26:02,509
us better control over the task of

00:26:00,190 --> 00:26:04,369
organizing our thought

00:26:02,509 --> 00:26:06,169
we should help us because you know

00:26:04,369 --> 00:26:10,369
programs are big should reduce

00:26:06,169 --> 00:26:13,070
complexity and apart from literate

00:26:10,369 --> 00:26:14,839
programming we also use a programming

00:26:13,070 --> 00:26:16,940
paradigm called reproducible

00:26:14,839 --> 00:26:19,369
computational research it was proposed

00:26:16,940 --> 00:26:22,249
by many people including David Donahoe

00:26:19,369 --> 00:26:25,459
which is a big big guy in in signal

00:26:22,249 --> 00:26:27,769
analysis and David Donahoe said that you

00:26:25,459 --> 00:26:29,539
know traditional scientific publication

00:26:27,769 --> 00:26:31,269
is incapable of finding and rooting out

00:26:29,539 --> 00:26:33,409
errors in scientific computation

00:26:31,269 --> 00:26:34,819
reproducible computational research in

00:26:33,409 --> 00:26:36,589
which the full computational environment

00:26:34,819 --> 00:26:39,679
that produces a result is published

00:26:36,589 --> 00:26:41,559
along with the article we publish an

00:26:39,679 --> 00:26:43,999
article you published the figures

00:26:41,559 --> 00:26:45,799
published the figures and you have the

00:26:43,999 --> 00:26:47,629
code for the figures you have the data

00:26:45,799 --> 00:26:49,669
and you have the code that did the

00:26:47,629 --> 00:26:53,499
analysis of the data all of this comes

00:26:49,669 --> 00:26:57,769
online so anyone can check what happened

00:26:53,499 --> 00:27:00,289
so now let's go to the software so all

00:26:57,769 --> 00:27:05,659
the software we use Linux operating

00:27:00,289 --> 00:27:08,119
system and ext4 for the root the root

00:27:05,659 --> 00:27:10,459
system and for you know the operating

00:27:08,119 --> 00:27:13,190
system in general and for storage we use

00:27:10,459 --> 00:27:15,259
btrfs that's a very personal choice

00:27:13,190 --> 00:27:16,999
because you know first I found btrfs

00:27:15,259 --> 00:27:18,409
very cool when you're not the

00:27:16,999 --> 00:27:20,869
professional programmer you know a

00:27:18,409 --> 00:27:22,219
little little okay so you're trying to

00:27:20,869 --> 00:27:24,229
find things that you find cool and I

00:27:22,219 --> 00:27:26,959
found btrfs very cool and it turns out

00:27:24,229 --> 00:27:31,519
it was also usable so I made the choice

00:27:26,959 --> 00:27:33,949
for btrfs but btrfs has defects when you

00:27:31,519 --> 00:27:36,199
try to move data if you move lots of

00:27:33,949 --> 00:27:38,569
data around you can have data corruption

00:27:36,199 --> 00:27:41,899
things get you know weird but we don't

00:27:38,569 --> 00:27:44,479
move data we store it we read it we move

00:27:41,899 --> 00:27:48,679
it so btrfs in this kind of usage we

00:27:44,479 --> 00:27:51,889
have is very nice you just do raid raid

00:27:48,679 --> 00:27:55,099
0 very fast and single line and it has a

00:27:51,889 --> 00:27:58,579
very good feeling I know because that we

00:27:55,099 --> 00:28:00,769
use get for for versioning it has it

00:27:58,579 --> 00:28:03,769
looks a bit like this and I really like

00:28:00,769 --> 00:28:06,619
the feeling of using btrfs for

00:28:03,769 --> 00:28:08,809
development we use a editor it happens

00:28:06,619 --> 00:28:10,309
we use them but you know you could acts

00:28:08,809 --> 00:28:13,919
also

00:28:10,309 --> 00:28:16,980
python for the language pi q de for the

00:28:13,919 --> 00:28:19,919
main python library to work on GPUs we

00:28:16,980 --> 00:28:22,470
use psychics and we use the library we

00:28:19,919 --> 00:28:25,200
discovered recently called CUV a very

00:28:22,470 --> 00:28:29,190
powerful library it's based on C++ and

00:28:25,200 --> 00:28:31,320
plates very nice we also use c4 the

00:28:29,190 --> 00:28:32,789
little kernels and we use siphon

00:28:31,320 --> 00:28:35,820
fighting is magic I will show you a

00:28:32,789 --> 00:28:38,070
little example of siphon which we siphon

00:28:35,820 --> 00:28:40,470
is coupled with stage very nice

00:28:38,070 --> 00:28:43,080
beautiful and for the literate

00:28:40,470 --> 00:28:44,880
programming we use no web which has to

00:28:43,080 --> 00:28:48,179
stop functions called no tangle and no

00:28:44,880 --> 00:28:52,139
and no we've both the data analysis we

00:28:48,179 --> 00:28:54,480
use scientific Python ipython sage which

00:28:52,139 --> 00:28:57,029
is this marvelous we are replacing

00:28:54,480 --> 00:29:00,019
Mathematica with stage it's very nice

00:28:57,029 --> 00:29:05,429
and it has latex built-in very much and

00:29:00,019 --> 00:29:09,330
we use my avi for 3d imaging display we

00:29:05,429 --> 00:29:11,220
use asymptote for many schematics and we

00:29:09,330 --> 00:29:14,010
use google docs for collaboration it's a

00:29:11,220 --> 00:29:16,049
fantastic tool google docs just amazing

00:29:14,010 --> 00:29:17,850
you can work simultaneously on the

00:29:16,049 --> 00:29:19,950
documents just mothers the only defect

00:29:17,850 --> 00:29:22,320
it has if that doesn't work so well with

00:29:19,950 --> 00:29:25,230
latex so you know you have to have those

00:29:22,320 --> 00:29:29,130
PNG you know images that you plug in or

00:29:25,230 --> 00:29:31,110
sometimes you just write have time to do

00:29:29,130 --> 00:29:32,940
anything better but it's really really

00:29:31,110 --> 00:29:35,309
nice so if Google could work on the

00:29:32,940 --> 00:29:37,200
latex on a very nice latex a little

00:29:35,309 --> 00:29:41,580
later if you write them but it looks

00:29:37,200 --> 00:29:43,919
doesn't look right so how does the

00:29:41,580 --> 00:29:45,510
siphon work here is a very simple

00:29:43,919 --> 00:29:47,970
example based on the Monte Carlo

00:29:45,510 --> 00:29:49,350
integrate in a Monte Carlo integration

00:29:47,970 --> 00:29:50,760
Monte Carlo integration if you don't

00:29:49,350 --> 00:29:53,580
know about it just read it on Wikipedia

00:29:50,760 --> 00:29:56,460
it's just beautiful breathtaking very

00:29:53,580 --> 00:29:59,159
simple developed by knowing man and oh

00:29:56,460 --> 00:30:01,169
men in among his friends it's just

00:29:59,159 --> 00:30:03,330
beautiful so here here is a one liner

00:30:01,169 --> 00:30:06,600
for a little monster caught up in

00:30:03,330 --> 00:30:09,690
integrator very simple and here is the

00:30:06,600 --> 00:30:11,909
Python equivalent using loops so what

00:30:09,690 --> 00:30:13,860
you do when you use siphon is that first

00:30:11,909 --> 00:30:15,330
of all you hack a little line because

00:30:13,860 --> 00:30:17,610
it's always nice to have a single liner

00:30:15,330 --> 00:30:20,220
okay then you write a loop because

00:30:17,610 --> 00:30:22,240
that's how the world is it uses loops

00:30:20,220 --> 00:30:24,760
and then once you have

00:30:22,240 --> 00:30:27,550
loop you just cite the night the code

00:30:24,760 --> 00:30:31,030
cipher knives I call siphon eyes is just

00:30:27,550 --> 00:30:33,730
typing you type the variables here if

00:30:31,030 --> 00:30:37,990
you look at the differences you have a/c

00:30:33,730 --> 00:30:40,000
dep to define f well see that means that

00:30:37,990 --> 00:30:42,700
the function is only available to the

00:30:40,000 --> 00:30:45,100
scene it's not exposed to python you

00:30:42,700 --> 00:30:48,580
will not be able to use F in the Python

00:30:45,100 --> 00:30:51,040
environment but it's faster and then you

00:30:48,580 --> 00:30:53,080
define the siphon function which is just

00:30:51,040 --> 00:30:56,050
a typed version of the Python function

00:30:53,080 --> 00:30:59,710
so how we work if we run the Python code

00:30:56,050 --> 00:31:04,150
and when it works but works slowly then

00:30:59,710 --> 00:31:08,410
we siphon eyes it very simple but the

00:31:04,150 --> 00:31:10,120
system linux as i told you if is you

00:31:08,410 --> 00:31:11,830
know you don't have in high performance

00:31:10,120 --> 00:31:15,820
computing high performance computing

00:31:11,830 --> 00:31:17,679
linux rules if you just something which

00:31:15,820 --> 00:31:20,470
is quite amazing the cern produces one

00:31:17,679 --> 00:31:22,270
gigabyte of data each second and all

00:31:20,470 --> 00:31:23,920
this is dealt with with a network of a

00:31:22,270 --> 00:31:28,300
hundred thousand computers using limits

00:31:23,920 --> 00:31:30,610
so good for them it's good for us btrfs

00:31:28,300 --> 00:31:32,110
i told you about it that DX before

00:31:30,610 --> 00:31:35,760
because you know you need something very

00:31:32,110 --> 00:31:38,500
stable for the OS and to move that up

00:31:35,760 --> 00:31:40,330
this is an example of siphon these are

00:31:38,500 --> 00:31:43,300
the three functions i told you about and

00:31:40,330 --> 00:31:46,240
how much time do you gain you start with

00:31:43,300 --> 00:31:49,710
11 seconds or classical python and you

00:31:46,240 --> 00:31:53,530
go to 0 point 12 seconds just a fact 100

00:31:49,710 --> 00:31:59,679
just in one go no thinking just type the

00:31:53,530 --> 00:32:02,260
vault for the get we use a flow chart

00:31:59,679 --> 00:32:05,260
that was proposed on the web by Vincent

00:32:02,260 --> 00:32:07,290
reason it's a beautiful flow chart we

00:32:05,260 --> 00:32:10,000
have different branches it works nicely

00:32:07,290 --> 00:32:13,300
very nice I really advise you to look at

00:32:10,000 --> 00:32:16,150
his page it's all described very nice

00:32:13,300 --> 00:32:18,490
beautiful so we have a repo it's not

00:32:16,150 --> 00:32:21,630
centralized but it is centralized you

00:32:18,490 --> 00:32:25,360
read on his page but he means by this

00:32:21,630 --> 00:32:27,850
and now to the hardware so you know we

00:32:25,360 --> 00:32:30,040
do everything from the algorithms to

00:32:27,850 --> 00:32:32,559
choosing the software to coding to

00:32:30,040 --> 00:32:33,830
building the cluster and everything so

00:32:32,559 --> 00:32:36,049
how do we what do we

00:32:33,830 --> 00:32:39,559
for the cluster so here's the little

00:32:36,049 --> 00:32:41,210
class that we have so we have one

00:32:39,559 --> 00:32:44,840
computer called the master that

00:32:41,210 --> 00:32:48,380
centralizes data it frames the

00:32:44,840 --> 00:32:50,990
calculations it gives the orders to the

00:32:48,380 --> 00:32:55,789
workers but the workers do not receive

00:32:50,990 --> 00:32:58,429
orders they ask for orders we have six

00:32:55,789 --> 00:33:02,809
workers from three to seven GPUs and we

00:32:58,429 --> 00:33:05,600
call an HP you hardware CPU thread and a

00:33:02,809 --> 00:33:08,450
GPU processor that's called that's what

00:33:05,600 --> 00:33:12,590
we call an HP you once one thread one

00:33:08,450 --> 00:33:14,990
GPU and all the jeep all the HP use run

00:33:12,590 --> 00:33:18,490
the same algorithm except that we change

00:33:14,990 --> 00:33:21,529
the part of parameter space to explore

00:33:18,490 --> 00:33:23,179
so that was the beginning when I send

00:33:21,529 --> 00:33:25,370
that picture to a friend was less

00:33:23,179 --> 00:33:28,789
Christmas he said well that's good but

00:33:25,370 --> 00:33:31,990
it looks like Frankenstein ok so now it

00:33:28,789 --> 00:33:34,970
looks a little nicer and we have a

00:33:31,990 --> 00:33:36,559
hardware engineer who is not specialized

00:33:34,970 --> 00:33:38,299
in computer and because he works in the

00:33:36,559 --> 00:33:40,360
chemistry lab of course who helped us

00:33:38,299 --> 00:33:44,510
set up the cluster in a nice way of

00:33:40,360 --> 00:33:47,380
course we use a GPU cards for different

00:33:44,510 --> 00:33:51,409
cards which correspond to two different

00:33:47,380 --> 00:33:55,549
GPU veces we started some time ago with

00:33:51,409 --> 00:33:59,149
the GTX 285 and then we end now with the

00:33:55,549 --> 00:34:03,440
gtx 590 which is a dual GPU card

00:33:59,149 --> 00:34:05,360
beautiful so this is the master it's a

00:34:03,440 --> 00:34:11,179
dual xeon twenty four gigabytes of

00:34:05,360 --> 00:34:13,520
memory it has a 5 raid 0 SSDs for you

00:34:11,179 --> 00:34:16,520
know that I management fast storage when

00:34:13,520 --> 00:34:20,080
it receives data from the workers we

00:34:16,520 --> 00:34:23,179
have a 20 20 terabytes of storage

00:34:20,080 --> 00:34:27,349
long-term storage no SSD just normal

00:34:23,179 --> 00:34:30,169
hard disks and this is the worker 3 and

00:34:27,349 --> 00:34:33,230
here you can see the four cards as well

00:34:30,169 --> 00:34:35,300
come together before five 80s but in

00:34:33,230 --> 00:34:38,540
order for the 45 80s to work together

00:34:35,300 --> 00:34:39,830
and like this we had to make very who

00:34:38,540 --> 00:34:42,470
have to really think about the choices

00:34:39,830 --> 00:34:43,700
we made in particular we had to think

00:34:42,470 --> 00:34:45,619
about the the

00:34:43,700 --> 00:34:49,339
motherboard because the motherboard has

00:34:45,619 --> 00:34:51,470
to have enough pci lanes in order to

00:34:49,339 --> 00:34:53,869
have maximum bandwidth when

00:34:51,470 --> 00:34:57,349
communicating with the processor so in

00:34:53,869 --> 00:35:02,420
this cards we have 64 pci lanes so this

00:34:57,349 --> 00:35:06,920
means we have full 16 times video cards

00:35:02,420 --> 00:35:09,260
because all time 16 ok so it works very

00:35:06,920 --> 00:35:11,119
nice motherboard but we just I think we

00:35:09,260 --> 00:35:12,680
bought we bought a few months ago we

00:35:11,119 --> 00:35:14,660
bought the last three that were

00:35:12,680 --> 00:35:16,550
available in French so maybe they have

00:35:14,660 --> 00:35:18,470
or now but you know it's very hard to

00:35:16,550 --> 00:35:22,089
have those this kind of hardware very

00:35:18,470 --> 00:35:23,839
difficult many people use a video card

00:35:22,089 --> 00:35:25,970
motherboards in which they don't have

00:35:23,839 --> 00:35:28,040
enough pci lanes so this means that one

00:35:25,970 --> 00:35:29,990
of the GPUs will not communicate at

00:35:28,040 --> 00:35:32,510
maximum bandwidth with the processor so

00:35:29,990 --> 00:35:36,500
you lose time you lose very important

00:35:32,510 --> 00:35:38,720
time but the worker 5 is the latest that

00:35:36,500 --> 00:35:40,940
actually works because we have a worker

00:35:38,720 --> 00:35:44,900
six but it doesn't it's not working at

00:35:40,940 --> 00:35:49,099
this moment so the work of 5 uses 35 90s

00:35:44,900 --> 00:35:51,260
this means six GPUs and 15 81 GPU so

00:35:49,099 --> 00:35:54,020
that makes a total of seven GPUs in a

00:35:51,260 --> 00:35:57,170
single box so let me that's the maximum

00:35:54,020 --> 00:35:59,630
because we really designed the box so

00:35:57,170 --> 00:36:02,329
that it worked and that the power

00:35:59,630 --> 00:36:04,670
consumption corresponded to the cause it

00:36:02,329 --> 00:36:06,700
was a very long work it didn't work at

00:36:04,670 --> 00:36:10,760
the store it's not you know plug it oh

00:36:06,700 --> 00:36:13,849
ho doesn't work like this the problems

00:36:10,760 --> 00:36:15,410
we had with temperatures temperature was

00:36:13,849 --> 00:36:18,440
very high sometimes so we had to use

00:36:15,410 --> 00:36:20,359
special risers that we ordered very high

00:36:18,440 --> 00:36:23,300
bandwidth rises to have the cards

00:36:20,359 --> 00:36:26,089
outside the box we sometimes had

00:36:23,300 --> 00:36:27,980
electric over consumption so we needed

00:36:26,089 --> 00:36:31,040
to really measure the construction and

00:36:27,980 --> 00:36:34,579
many defective components it actually

00:36:31,040 --> 00:36:36,950
happens that in you know gamer hardware

00:36:34,579 --> 00:36:39,260
if you buy one card ok but if you fight

00:36:36,950 --> 00:36:41,839
if you buy ten cards then you know the

00:36:39,260 --> 00:36:43,849
probability adds up and you find a

00:36:41,839 --> 00:36:45,710
defective component so that was a big

00:36:43,849 --> 00:36:49,490
problem but the hardware manufacturers

00:36:45,710 --> 00:36:52,250
actually send them back knee hardware

00:36:49,490 --> 00:36:54,200
and they send it back but but it's

00:36:52,250 --> 00:36:55,970
always painful to lose time and to make

00:36:54,200 --> 00:37:00,170
the test it doesn't work you're not

00:36:55,970 --> 00:37:03,980
happy the temperature typically rises to

00:37:00,170 --> 00:37:06,609
about 90 degrees on a single card we

00:37:03,980 --> 00:37:08,750
have a distributed architecture

00:37:06,609 --> 00:37:10,700
completely distributed all the workers

00:37:08,750 --> 00:37:13,040
are independence which means that we can

00:37:10,700 --> 00:37:14,660
have a worker which is far away and it

00:37:13,040 --> 00:37:18,200
will contribute in the same way as the

00:37:14,660 --> 00:37:20,720
local workers though the software

00:37:18,200 --> 00:37:24,369
components for non computational cluster

00:37:20,720 --> 00:37:27,830
activity the data storage is a homemade

00:37:24,369 --> 00:37:30,050
Python dictionaries using C pickle very

00:37:27,830 --> 00:37:32,930
nice we don't have you know we have data

00:37:30,050 --> 00:37:34,550
but it's stored we know how we want to

00:37:32,930 --> 00:37:37,400
interrogate the database so it's

00:37:34,550 --> 00:37:39,740
handmade and it's homemade we use carry

00:37:37,400 --> 00:37:42,380
gal it's a very nice web server built in

00:37:39,740 --> 00:37:44,960
Python very nice so we use it to make

00:37:42,380 --> 00:37:47,300
data requests and visualization from

00:37:44,960 --> 00:37:50,630
outside you know as the cluster working

00:37:47,300 --> 00:37:52,570
and everything a communication is you is

00:37:50,630 --> 00:37:58,599
made using the multi processing mode

00:37:52,570 --> 00:38:01,910
library module we use client-server and

00:37:58,599 --> 00:38:05,210
we have a tool to give us instant

00:38:01,910 --> 00:38:08,660
snapshots of the cluster activity if you

00:38:05,210 --> 00:38:10,790
compare hbu for signs with Watson 30

00:38:08,660 --> 00:38:13,790
thousand euros for each beautiful

00:38:10,790 --> 00:38:17,119
science what CERN costs about 22 million

00:38:13,790 --> 00:38:19,640
dollars the power 2045 teraflops peek

00:38:17,119 --> 00:38:24,500
which means that in reality we reach 16

00:38:19,640 --> 00:38:29,359
teraflops ET teraflops 1170 mega flops

00:38:24,500 --> 00:38:31,700
per euro 34 mega for Europe for its 20

00:38:29,359 --> 00:38:34,369
terabytes 20 terabytes but I cheated a

00:38:31,700 --> 00:38:39,380
bit because these 20 terabytes you

00:38:34,369 --> 00:38:44,500
actually had 15 terabytes of RAM i only

00:38:39,380 --> 00:38:44,500
had 48 you go back a 60 gigabytes of ram

00:38:45,640 --> 00:38:52,040
so the short term evolution is to test

00:38:48,470 --> 00:38:54,020
opencl with a pie opencl apparently i

00:38:52,040 --> 00:38:55,700
went to a specialized seminar it's a

00:38:54,020 --> 00:38:57,530
little more painful to program in in

00:38:55,700 --> 00:39:00,200
opencl so because i'm not a professional

00:38:57,530 --> 00:39:03,320
programmer maybe else will stick to phi

00:39:00,200 --> 00:39:04,790
q de open-source the code of course it's

00:39:03,320 --> 00:39:07,760
the whole thing of reproducible

00:39:04,790 --> 00:39:09,050
computational research and move to the

00:39:07,760 --> 00:39:11,000
new cards which

00:39:09,050 --> 00:39:14,300
speed will be twice as fast as the

00:39:11,000 --> 00:39:16,370
previous five 90s very nice and of

00:39:14,300 --> 00:39:17,930
course this machine learning application

00:39:16,370 --> 00:39:19,700
for deconvolution will not be the only

00:39:17,930 --> 00:39:22,610
application of the machine learning

00:39:19,700 --> 00:39:25,240
machine we have and we also program lots

00:39:22,610 --> 00:39:28,010
of the others application in chemistry

00:39:25,240 --> 00:39:29,810
the thing is we like to stay in the lab

00:39:28,010 --> 00:39:32,330
where the crest work where the questions

00:39:29,810 --> 00:39:34,670
arise if you separate from the chemistry

00:39:32,330 --> 00:39:36,440
lab then you develop your own questions

00:39:34,670 --> 00:39:38,240
and then you get disconnected from

00:39:36,440 --> 00:39:41,420
reality so we like to stay in a

00:39:38,240 --> 00:39:45,020
chemistry lab but this is final drawing

00:39:41,420 --> 00:39:46,820
is here is the Oracle the perfect neural

00:39:45,020 --> 00:39:50,030
network and you have the little brains

00:39:46,820 --> 00:39:54,950
trying to find the Oracle so may Python

00:39:50,030 --> 00:39:57,340
help us to find the oracle team and the

00:39:54,950 --> 00:39:57,340
website

00:40:06,529 --> 00:40:17,309
um a lobotomy question hi i saw using

00:40:15,660 --> 00:40:19,019
siphon for some of the high performance

00:40:17,309 --> 00:40:21,390
stuff how did it using pi PI tool

00:40:19,019 --> 00:40:23,669
because their gangs are very impressive

00:40:21,390 --> 00:40:26,099
performance gains and we make will make

00:40:23,669 --> 00:40:32,269
the choice of cyclin we never fight my

00:40:26,099 --> 00:40:36,349
by them I mean we could try anybody else

00:40:32,269 --> 00:40:36,349
okay thank you young

00:40:51,510 --> 00:40:53,570

YouTube URL: https://www.youtube.com/watch?v=5epAiVgitL0


