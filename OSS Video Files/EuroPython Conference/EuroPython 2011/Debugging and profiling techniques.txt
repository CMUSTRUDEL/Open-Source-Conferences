Title: Debugging and profiling techniques
Publication date: 2015-04-19
Playlist: EuroPython 2011
Description: 
	[EuroPython 2011] Giovanni Bajo - 22 June 2011 in "Track Spaghetti"
Captions: 
	00:00:03,690 --> 00:00:12,880
thank you thank you can you hear me ok

00:00:08,850 --> 00:00:15,280
so this guy is the problem and this

00:00:12,880 --> 00:00:17,500
problem is has to do with Python because

00:00:15,280 --> 00:00:20,769
basically this guy is just learn Python

00:00:17,500 --> 00:00:22,749
maybe one or two years ago and he tried

00:00:20,769 --> 00:00:25,179
it with small snippets of code and

00:00:22,749 --> 00:00:28,149
everything was oh yeah works very well

00:00:25,179 --> 00:00:31,569
very fast much faster than C++ I can be

00:00:28,149 --> 00:00:33,550
more productive and so and then he tried

00:00:31,569 --> 00:00:36,580
to start doing production with it and

00:00:33,550 --> 00:00:39,340
try to make instead of small snippets

00:00:36,580 --> 00:00:41,830
some medium-sized program and then he

00:00:39,340 --> 00:00:43,810
found out that yeah works very well but

00:00:41,830 --> 00:00:45,760
this you know this abstraction sometimes

00:00:43,810 --> 00:00:47,920
liquor and then you have some memory

00:00:45,760 --> 00:00:50,050
leak somewhere and your program is two

00:00:47,920 --> 00:00:52,570
gigabytes of RAM occupation or is a

00:00:50,050 --> 00:00:54,280
little slower than expected and it

00:00:52,570 --> 00:00:58,390
doesn't know how to solve these problems

00:00:54,280 --> 00:01:00,100
so if you if you want kind of in this

00:00:58,390 --> 00:01:02,530
situation this is the talk for you if

00:01:00,100 --> 00:01:05,170
you are like a ten years the Python core

00:01:02,530 --> 00:01:06,880
committer and you develop a half of C

00:01:05,170 --> 00:01:10,539
Python then probably it's not the good

00:01:06,880 --> 00:01:12,219
talk for you ok just a short

00:01:10,539 --> 00:01:15,130
introduction but actually Valentin

00:01:12,219 --> 00:01:17,289
already introduced myself I organized

00:01:15,130 --> 00:01:20,920
pack on Italy and Europe item this is

00:01:17,289 --> 00:01:26,039
what I'm mostly proud of and I'm city of

00:01:20,920 --> 00:01:29,229
develop one of our sponsors and hmm

00:01:26,039 --> 00:01:30,670
these are my twitter and blog reference

00:01:29,229 --> 00:01:35,049
in case you want to follow me in the

00:01:30,670 --> 00:01:37,630
next few years maybe ok so this is the

00:01:35,049 --> 00:01:40,270
roadmap of my talk we will look into

00:01:37,630 --> 00:01:42,700
memory leaks first and resource leaks in

00:01:40,270 --> 00:01:46,869
pattern in general which is actually am

00:01:42,700 --> 00:01:49,329
a big topic so we will detail how or

00:01:46,869 --> 00:01:51,609
what is a memory leak in Python since it

00:01:49,329 --> 00:01:54,130
shouldn't be a memory leak right so what

00:01:51,609 --> 00:01:56,649
is the memory leak and how we can debug

00:01:54,130 --> 00:01:59,289
it and fix the problems then we will

00:01:56,649 --> 00:02:01,899
look into Python code profiling so what

00:01:59,289 --> 00:02:04,420
python has two offers to help developers

00:02:01,899 --> 00:02:07,060
profile their code and then when we look

00:02:04,420 --> 00:02:09,069
into C C++ extensions because all those

00:02:07,060 --> 00:02:11,290
nice extension is like importantly

00:02:09,069 --> 00:02:13,990
gravity you know and then you fly but

00:02:11,290 --> 00:02:15,100
sometimes the tanta gravity stuff

00:02:13,990 --> 00:02:17,560
written in c plus

00:02:15,100 --> 00:02:20,110
plus came you know crashing you with a

00:02:17,560 --> 00:02:22,810
big segfault which is something a Python

00:02:20,110 --> 00:02:25,840
programmer is not used to and so we will

00:02:22,810 --> 00:02:27,610
look into how to debug those z+ parsec

00:02:25,840 --> 00:02:29,800
station especially under windows which

00:02:27,610 --> 00:02:31,540
is not exactly the most friendly

00:02:29,800 --> 00:02:36,220
debugging environment for this kind of

00:02:31,540 --> 00:02:39,730
task just a notice we will focus on C

00:02:36,220 --> 00:02:42,700
Python mostly almost exclusively so if

00:02:39,730 --> 00:02:44,680
you are like the if you only use light

00:02:42,700 --> 00:02:52,840
on this talk will not help you much

00:02:44,680 --> 00:02:54,430
probably okay let's start so what's the

00:02:52,840 --> 00:02:58,450
difference between a memory leak and the

00:02:54,430 --> 00:02:59,950
resource leak well technically there

00:02:58,450 --> 00:03:02,800
should be different because the memory

00:02:59,950 --> 00:03:04,990
leak basically means in see terms it's a

00:03:02,800 --> 00:03:08,590
malach without the free so you just

00:03:04,990 --> 00:03:10,390
allocate a piece of memory and you don't

00:03:08,590 --> 00:03:12,400
release it okay this should be a memory

00:03:10,390 --> 00:03:16,420
leak and the source Nick is when you

00:03:12,400 --> 00:03:18,280
lose a resource that you get so for

00:03:16,420 --> 00:03:20,320
insulin a file and you don't close it

00:03:18,280 --> 00:03:23,440
that's a resource leak okay you open a

00:03:20,320 --> 00:03:25,420
socket you don't close it but in Python

00:03:23,440 --> 00:03:27,880
these kind of leaks are actually

00:03:25,420 --> 00:03:30,730
coincident because the way you allocate

00:03:27,880 --> 00:03:32,590
memory in Python is through objects so

00:03:30,730 --> 00:03:34,120
when you need a buffer memory to do

00:03:32,590 --> 00:03:36,340
something you probably go through an

00:03:34,120 --> 00:03:38,890
object so what can happen is that you

00:03:36,340 --> 00:03:41,050
lick that object at the same appens for

00:03:38,890 --> 00:03:43,090
resources so you open a fight through an

00:03:41,050 --> 00:03:45,700
object and then somehow you forget to

00:03:43,090 --> 00:03:48,760
call the close method on that object and

00:03:45,700 --> 00:03:51,160
that's leak as well so basically since

00:03:48,760 --> 00:03:53,860
the cleanup usually happens through

00:03:51,160 --> 00:03:56,200
either object structure so for instance

00:03:53,860 --> 00:04:00,430
you have this under under del method we

00:03:56,200 --> 00:04:02,020
will and we will analyze later and you

00:04:00,430 --> 00:04:04,480
have this metal there should be

00:04:02,020 --> 00:04:07,090
automatically call for you when the

00:04:04,480 --> 00:04:09,850
object is you are done with and it

00:04:07,090 --> 00:04:11,800
evokes the claws of close method of file

00:04:09,850 --> 00:04:14,320
since you have this mechanism you

00:04:11,800 --> 00:04:17,410
shouldn't have any leak right but still

00:04:14,320 --> 00:04:19,480
there can be problems in that and so

00:04:17,410 --> 00:04:21,090
still basically in Python it's mostly

00:04:19,480 --> 00:04:24,040
the same thing so we will focus on how

00:04:21,090 --> 00:04:27,130
basically you you lose trucks of object

00:04:24,040 --> 00:04:29,500
and this amount managed to still be in

00:04:27,130 --> 00:04:32,930
your process memory

00:04:29,500 --> 00:04:34,970
but in Python as you know object

00:04:32,930 --> 00:04:37,300
collection is supposed to be automatic

00:04:34,970 --> 00:04:41,510
right so basically the idea is that

00:04:37,300 --> 00:04:44,140
Python knows the references among

00:04:41,510 --> 00:04:46,370
objects and should automatically collect

00:04:44,140 --> 00:04:49,970
objects when they are not used anymore

00:04:46,370 --> 00:04:52,160
by your program lets the dr and so what

00:04:49,970 --> 00:04:55,910
is an object click an object click a

00:04:52,160 --> 00:04:58,490
resource leak is when basically an

00:04:55,910 --> 00:05:02,030
object is logically dead for you which

00:04:58,490 --> 00:05:03,350
means you don't need it anymore but it's

00:05:02,030 --> 00:05:06,860
still not being collected by the

00:05:03,350 --> 00:05:09,380
interpreter so we call it object lik

00:05:06,860 --> 00:05:11,960
whenever you think that you are done

00:05:09,380 --> 00:05:15,320
with an object but C Python doesn't

00:05:11,960 --> 00:05:17,480
angry with you okay so basically this

00:05:15,320 --> 00:05:18,950
can happen for several reasons for

00:05:17,480 --> 00:05:21,620
instance there could be some lost or

00:05:18,950 --> 00:05:24,580
hidden reference so in a way you think

00:05:21,620 --> 00:05:26,720
that you have removed all the references

00:05:24,580 --> 00:05:29,030
from these objects you don't need

00:05:26,720 --> 00:05:31,010
anymore but instead there are some

00:05:29,030 --> 00:05:33,110
hidden reference references some

00:05:31,010 --> 00:05:35,630
somewhere in your program and so those

00:05:33,110 --> 00:05:37,880
object are still alive or obviously

00:05:35,630 --> 00:05:40,550
there could be some bugs because the

00:05:37,880 --> 00:05:42,980
Python is just you know C Python is just

00:05:40,550 --> 00:05:46,190
a sea program can have packs and the

00:05:42,980 --> 00:05:48,380
extension C++ extension that many Python

00:05:46,190 --> 00:05:51,800
programs use can have bugs as well and

00:05:48,380 --> 00:05:56,150
with the bug you just may be looser l am

00:05:51,800 --> 00:05:59,270
a reference to an object and also there

00:05:56,150 --> 00:06:01,430
are some bug being the in the Python

00:05:59,270 --> 00:06:03,350
color or even if they're not back there

00:06:01,430 --> 00:06:05,000
could be quality of implementation

00:06:03,350 --> 00:06:07,550
something like choice is made by the

00:06:05,000 --> 00:06:10,660
Python core but in a way affect the way

00:06:07,550 --> 00:06:14,450
your program works I will explain this

00:06:10,660 --> 00:06:17,990
so let's start how do you see how do we

00:06:14,450 --> 00:06:21,740
see how many objects we are located in

00:06:17,990 --> 00:06:23,690
Python we use this function this

00:06:21,740 --> 00:06:26,890
function is the module GC which is a

00:06:23,690 --> 00:06:29,330
standard model of the Python library

00:06:26,890 --> 00:06:32,150
this dysfunction is very nice because

00:06:29,330 --> 00:06:35,150
give you a standard Python list with all

00:06:32,150 --> 00:06:38,240
your objects in it so just a way to get

00:06:35,150 --> 00:06:42,460
a list of all the objects the pie to the

00:06:38,240 --> 00:06:45,680
C Python interpreter knows about

00:06:42,460 --> 00:06:48,379
but of course having a such a big list

00:06:45,680 --> 00:06:50,300
it's probably not very useful but there

00:06:48,379 --> 00:06:52,669
are still some nice things we can do

00:06:50,300 --> 00:06:54,770
with this list so for instance the first

00:06:52,669 --> 00:06:57,559
thing that comes to mind is that you can

00:06:54,770 --> 00:06:59,899
do some kind of before-and-after check

00:06:57,559 --> 00:07:03,770
so what I mean we'd before and after

00:06:59,899 --> 00:07:06,139
check I mean just you get a list compute

00:07:03,770 --> 00:07:08,539
some statistic on it then you do an

00:07:06,139 --> 00:07:11,719
operation and then you recompute the

00:07:08,539 --> 00:07:14,059
same statistics on that list and if you

00:07:11,719 --> 00:07:16,009
if you think that nothing more is being

00:07:14,059 --> 00:07:17,930
created for instance the your statistics

00:07:16,009 --> 00:07:19,309
should match and if they don't match

00:07:17,930 --> 00:07:21,379
probably there is something that has

00:07:19,309 --> 00:07:24,020
leaked through so if they for instance

00:07:21,379 --> 00:07:27,289
if the list grows there are more objects

00:07:24,020 --> 00:07:29,689
in your environment if you think that

00:07:27,289 --> 00:07:32,539
before and after the list should have

00:07:29,689 --> 00:07:34,490
the same sides but it doesn't it means

00:07:32,539 --> 00:07:39,740
that what we have done between has

00:07:34,490 --> 00:07:43,180
licked some objects okay yeah there is

00:07:39,740 --> 00:07:45,800
enough contrast can you read this yeah

00:07:43,180 --> 00:07:48,889
so this is an example i define a

00:07:45,800 --> 00:07:51,949
function i call how many and they pass

00:07:48,889 --> 00:07:55,430
with the class type okay this function

00:07:51,949 --> 00:08:00,409
just go through the GC lisam get objects

00:07:55,430 --> 00:08:03,860
and simply counts how many objects of a

00:08:00,409 --> 00:08:07,249
certain type there are okay so you see I

00:08:03,860 --> 00:08:09,289
just filter the list basic on on the

00:08:07,249 --> 00:08:11,360
easy instance check and then I just

00:08:09,289 --> 00:08:15,080
compute its length okay so for instance

00:08:11,360 --> 00:08:18,259
there is a dummy class a and if I just

00:08:15,080 --> 00:08:20,599
count how many a it tells me 0 then I

00:08:18,259 --> 00:08:22,580
locate one how many a one and then I

00:08:20,599 --> 00:08:25,969
remove a reference through them the dell

00:08:22,580 --> 00:08:28,159
statement they'll male and then there

00:08:25,969 --> 00:08:34,610
are no more a's in miami environment so

00:08:28,159 --> 00:08:37,459
how many a's it's zero okay so another

00:08:34,610 --> 00:08:41,479
way to explicitly check for references

00:08:37,459 --> 00:08:45,500
is this function which is in the sea

00:08:41,479 --> 00:08:50,540
smaj ow it's called get ref count get

00:08:45,500 --> 00:08:54,350
ref count basically gives you the number

00:08:50,540 --> 00:08:56,000
of reference to an object number of

00:08:54,350 --> 00:08:59,720
references to an object

00:08:56,000 --> 00:09:03,740
so if I say get ref count a it will tell

00:08:59,720 --> 00:09:07,160
me how many references there are two

00:09:03,740 --> 00:09:10,100
debt object okay you see the minus one I

00:09:07,160 --> 00:09:12,200
put it's because when you enter the debt

00:09:10,100 --> 00:09:14,090
function with your code you call the

00:09:12,200 --> 00:09:16,520
function the function executes the

00:09:14,090 --> 00:09:19,490
function itself needs to get a reference

00:09:16,520 --> 00:09:22,030
to the object that you pass it okay so

00:09:19,490 --> 00:09:23,870
there will be always one more reference

00:09:22,030 --> 00:09:25,670
 by the function because the

00:09:23,870 --> 00:09:28,280
function itself is all doing a reference

00:09:25,670 --> 00:09:32,420
in the moment it counts them okay so you

00:09:28,280 --> 00:09:38,360
need to decrease by 1 the count to make

00:09:32,420 --> 00:09:40,190
to get the number you need so for

00:09:38,360 --> 00:09:41,810
instance one thing you can try is to

00:09:40,190 --> 00:09:44,840
check the reference count just before

00:09:41,810 --> 00:09:46,340
your logical destruction destruction so

00:09:44,840 --> 00:09:49,370
what I mean is that you have an object

00:09:46,340 --> 00:09:51,740
in your hand and your you are going to

00:09:49,370 --> 00:09:53,540
remove the last reference to the object

00:09:51,740 --> 00:09:56,300
if you want to make sure that it's

00:09:53,540 --> 00:10:00,050
really the last reference just call get

00:09:56,300 --> 00:10:03,080
ref count because if it returns to use

00:10:00,050 --> 00:10:05,540
one it's one that debt reference is your

00:10:03,080 --> 00:10:07,940
last one but it will eat the returns

00:10:05,540 --> 00:10:11,080
free there are many other rep there are

00:10:07,940 --> 00:10:13,550
another reference in your program okay

00:10:11,080 --> 00:10:15,800
this function can also be used in test

00:10:13,550 --> 00:10:18,350
suite because the for instance you can

00:10:15,800 --> 00:10:20,930
do an automatic tester that check some

00:10:18,350 --> 00:10:22,910
how you use an object and you can use

00:10:20,930 --> 00:10:25,280
get ref count to check if all the

00:10:22,910 --> 00:10:27,200
references are being collected and then

00:10:25,280 --> 00:10:32,839
your trash your test will fail if

00:10:27,200 --> 00:10:35,270
something goes wrong and if there is a

00:10:32,839 --> 00:10:36,860
reference missing how can we find it if

00:10:35,270 --> 00:10:40,460
there is one more reference and we don't

00:10:36,860 --> 00:10:42,950
know where it is how can we find it we

00:10:40,460 --> 00:10:47,540
can use this other function back to the

00:10:42,950 --> 00:10:49,910
GC module it's get referers get

00:10:47,540 --> 00:10:53,540
referrers gives you a list of all

00:10:49,910 --> 00:10:57,050
objects that hold the reference to the

00:10:53,540 --> 00:10:59,420
object you pass to the function okay you

00:10:57,050 --> 00:11:02,360
can actually put a pass a list of

00:10:59,420 --> 00:11:05,270
objects and we get will give you a list

00:11:02,360 --> 00:11:08,260
of all objects holding a reference to

00:11:05,270 --> 00:11:11,000
all those objects okay

00:11:08,260 --> 00:11:13,250
we are thinking of direct references

00:11:11,000 --> 00:11:14,720
here because here these are the

00:11:13,250 --> 00:11:17,510
references that the C Python interpreter

00:11:14,720 --> 00:11:19,820
seized with direct reference that means

00:11:17,510 --> 00:11:21,880
I mean that for instance in classes in

00:11:19,820 --> 00:11:24,790
instances you know that there is a

00:11:21,880 --> 00:11:27,980
adicta a dictionary that holds all your

00:11:24,790 --> 00:11:30,800
attributes okay which is the under under

00:11:27,980 --> 00:11:34,730
dick of the instance so for instance if

00:11:30,800 --> 00:11:37,760
I ask for them referers of an object

00:11:34,730 --> 00:11:41,480
which is held as an attribute in in in

00:11:37,760 --> 00:11:44,150
another object the dysfunction we return

00:11:41,480 --> 00:11:47,240
the dictionary instance of the object

00:11:44,150 --> 00:11:50,210
okay because that's the direct reference

00:11:47,240 --> 00:11:53,270
to the to the first object so we

00:11:50,210 --> 00:11:55,970
probably needs to recursively analyze

00:11:53,270 --> 00:12:00,260
the references I have some example I can

00:11:55,970 --> 00:12:05,510
show you so get back to the a dummy plus

00:12:00,260 --> 00:12:10,910
i allocate to difference beautiful it's

00:12:05,510 --> 00:12:15,050
instances a1 and a2 okay I check them I

00:12:10,910 --> 00:12:18,530
call get rest count on a 1-1 and I get

00:12:15,050 --> 00:12:22,430
one reference okay because we are there

00:12:18,530 --> 00:12:25,160
is one reference to a one so I say what

00:12:22,430 --> 00:12:28,490
is this reference to a one I check it

00:12:25,160 --> 00:12:32,420
with get referrers here and then you

00:12:28,490 --> 00:12:35,030
spit pretty print to see who's holding a

00:12:32,420 --> 00:12:37,100
reference to a one this one reference we

00:12:35,030 --> 00:12:39,980
see here who's holding this one

00:12:37,100 --> 00:12:44,120
reference and I get these you see it's a

00:12:39,980 --> 00:12:46,550
list here here of just one item which is

00:12:44,120 --> 00:12:50,570
a dictionary so there is a dictionary

00:12:46,550 --> 00:12:54,290
holding a reference to a one and you can

00:12:50,570 --> 00:12:56,840
see the reference here a one main a

00:12:54,290 --> 00:12:58,820
instance ok this is the reference to a

00:12:56,840 --> 00:13:01,480
one the only reference and this

00:12:58,820 --> 00:13:04,040
dictionary is basically just the

00:13:01,480 --> 00:13:06,950
interpreter dictionary ok it's the

00:13:04,040 --> 00:13:08,780
dictionary that holds all the objects

00:13:06,950 --> 00:13:15,440
available at interpreter level it's the

00:13:08,780 --> 00:13:18,540
Global's ok you can check it so what i'm

00:13:15,440 --> 00:13:21,600
doing here is asking who

00:13:18,540 --> 00:13:25,440
who's holding the references to a one

00:13:21,600 --> 00:13:27,900
the first one the diction is global and

00:13:25,440 --> 00:13:29,340
that's true okay so this is the global

00:13:27,900 --> 00:13:30,960
dictionary which is the dictionary you

00:13:29,340 --> 00:13:33,960
modify when you create something your

00:13:30,960 --> 00:13:35,910
interpreter you say a equal to 0 you are

00:13:33,960 --> 00:13:39,090
adding a to the global dictionary of

00:13:35,910 --> 00:13:41,580
your interpreter and this is this

00:13:39,090 --> 00:13:46,220
picture is always available because it's

00:13:41,580 --> 00:13:48,900
also available through the Seas module

00:13:46,220 --> 00:13:53,720
basically if you call this weird stuff

00:13:48,900 --> 00:13:57,210
here sis dot under get frame function

00:13:53,720 --> 00:13:59,930
dot F locals this is like a magic

00:13:57,210 --> 00:14:03,570
formula you can use and we give you a

00:13:59,930 --> 00:14:07,050
reference to the dictionary holding all

00:14:03,570 --> 00:14:09,810
objects in your local context okay so if

00:14:07,050 --> 00:14:12,990
you call this magic formula within a

00:14:09,810 --> 00:14:15,720
function it will give you a reference to

00:14:12,990 --> 00:14:17,790
the locals dictionary okay if you call

00:14:15,720 --> 00:14:19,650
this magical formula in the global

00:14:17,790 --> 00:14:23,250
context we give you a reference to the

00:14:19,650 --> 00:14:26,370
global global function okay just to show

00:14:23,250 --> 00:14:28,470
you some stuff within the pattern

00:14:26,370 --> 00:14:37,020
interpreter which is usually not very

00:14:28,470 --> 00:14:39,300
famous so now let's just change

00:14:37,020 --> 00:14:41,250
something here and just you see on the

00:14:39,300 --> 00:14:47,040
third driving just adding a reference

00:14:41,250 --> 00:14:50,250
from a 2 2 a 1 okay so now a 2 holds the

00:14:47,040 --> 00:14:56,190
reference to a 1 through that the XXX

00:14:50,250 --> 00:14:59,300
attribute okay so when I ask again who's

00:14:56,190 --> 00:15:02,160
holding a reference to a 1 I get to

00:14:59,300 --> 00:15:06,110
because one is the global dictionary and

00:15:02,160 --> 00:15:09,060
two is this reference I added here okay

00:15:06,110 --> 00:15:14,460
is everything clear so we have to

00:15:09,060 --> 00:15:17,670
reference to two references to a one if

00:15:14,460 --> 00:15:19,710
I again ask them garbage collector to

00:15:17,670 --> 00:15:23,070
give me all referrers I get the list of

00:15:19,710 --> 00:15:24,860
two items the second one against the

00:15:23,070 --> 00:15:30,960
global dictionary we saw before the

00:15:24,860 --> 00:15:36,210
first one is this is another dictionary

00:15:30,960 --> 00:15:38,880
okay but what we did is just put a one

00:15:36,210 --> 00:15:41,640
within a two and what i get is not a

00:15:38,880 --> 00:15:45,030
tool but I get a dictionary and this

00:15:41,640 --> 00:15:48,990
dictionary is the instant dictionary of

00:15:45,030 --> 00:15:52,020
a to see here it's true so what it means

00:15:48,990 --> 00:15:53,970
is that when you add an object you you

00:15:52,020 --> 00:15:55,860
are the reference to an object within

00:15:53,970 --> 00:15:57,930
another object what you're doing is

00:15:55,860 --> 00:16:00,930
putting that object within the instance

00:15:57,930 --> 00:16:03,150
dictionary so if you ask C Python to

00:16:00,930 --> 00:16:05,730
give your list of all the objects

00:16:03,150 --> 00:16:07,230
holding a reference you don't get you

00:16:05,730 --> 00:16:10,470
don't get directly you don't jump

00:16:07,230 --> 00:16:12,840
directly from a1 to a2 but from a 0 a 1

00:16:10,470 --> 00:16:17,850
a sip icons is the instant dictionaries

00:16:12,840 --> 00:16:20,160
of heo and this dick here if you get the

00:16:17,850 --> 00:16:24,720
reference of this dictionary you get a 2

00:16:20,160 --> 00:16:26,880
you see so basically probably the

00:16:24,720 --> 00:16:29,070
programmers doesn't want to care about

00:16:26,880 --> 00:16:32,430
this dictionary he would like to a very

00:16:29,070 --> 00:16:33,990
easy way to see to tell C Python okay i

00:16:32,430 --> 00:16:36,600
have this a 2 who's holding the

00:16:33,990 --> 00:16:39,390
reference sorry I have this a one who's

00:16:36,600 --> 00:16:41,190
holding the reference a to but you don't

00:16:39,390 --> 00:16:42,900
get this answer straight you get first

00:16:41,190 --> 00:16:47,370
an instant dictionary and you need to do

00:16:42,900 --> 00:16:51,450
another question to get to 80 okay so

00:16:47,370 --> 00:16:53,160
it's true to John's ok so this is just I

00:16:51,450 --> 00:16:56,550
was an introduction to see how

00:16:53,160 --> 00:16:59,940
references work in C Python and then we

00:16:56,550 --> 00:17:05,040
see how we should go to collect all this

00:16:59,940 --> 00:17:07,440
stuff so C Python uses reference count

00:17:05,040 --> 00:17:09,450
this is probably it's all Python

00:17:07,440 --> 00:17:13,110
programmers are aware of something like

00:17:09,450 --> 00:17:15,690
that with the reference count means that

00:17:13,110 --> 00:17:17,850
you have C Python keep track of how many

00:17:15,690 --> 00:17:21,089
reference there are so when this counter

00:17:17,850 --> 00:17:25,410
goes zero you will delete the objects

00:17:21,089 --> 00:17:27,480
okay in C Python when the reference

00:17:25,410 --> 00:17:29,910
count goes to zero the destruction is in

00:17:27,480 --> 00:17:32,450
mediate so it's not like you know Java

00:17:29,910 --> 00:17:36,210
when there is where there is a

00:17:32,450 --> 00:17:37,980
background collector going on but in

00:17:36,210 --> 00:17:39,870
this case we are thinking of reference

00:17:37,980 --> 00:17:42,120
counting so when an object goes to zero

00:17:39,870 --> 00:17:43,059
it's immediately distracted and you can

00:17:42,120 --> 00:17:45,850
trust this

00:17:43,059 --> 00:17:48,850
this feature of C Python it's not going

00:17:45,850 --> 00:17:51,059
to change anytime soon I actually had an

00:17:48,850 --> 00:17:54,249
argument with Widow few years ago

00:17:51,059 --> 00:17:56,559
because I actually in my own protein

00:17:54,249 --> 00:17:59,200
style is that I like to rely on this

00:17:56,559 --> 00:18:02,049
feature of C Python a lot which is I

00:17:59,200 --> 00:18:04,600
mean it's not portable among Python

00:18:02,049 --> 00:18:07,749
implementations but I still since I I

00:18:04,600 --> 00:18:12,700
mostly you see Python I still like to

00:18:07,749 --> 00:18:15,100
rely on this and so for instance if you

00:18:12,700 --> 00:18:16,869
delete explicitly a reference to an

00:18:15,100 --> 00:18:18,789
object through the del statement which

00:18:16,869 --> 00:18:21,249
is the way you explicitly remove a

00:18:18,789 --> 00:18:22,749
reference if that was the last reference

00:18:21,249 --> 00:18:24,759
to the object there is an immediate

00:18:22,749 --> 00:18:26,470
destruction of the dog checked okay you

00:18:24,759 --> 00:18:28,179
can trust that as soon as the dead

00:18:26,470 --> 00:18:30,399
statement is finished the object is

00:18:28,179 --> 00:18:32,710
already gone okay you don't need to wait

00:18:30,399 --> 00:18:35,590
for the function to exit or whatever

00:18:32,710 --> 00:18:37,960
it's an immediate destruction also on

00:18:35,590 --> 00:18:39,850
function exit when you exit from a

00:18:37,960 --> 00:18:41,889
function or local variables are

00:18:39,850 --> 00:18:43,899
immediately distracted because the

00:18:41,889 --> 00:18:46,450
locals dictionary is collected and then

00:18:43,899 --> 00:18:47,740
all the local variable if there are no

00:18:46,450 --> 00:18:49,779
more references to them they are

00:18:47,740 --> 00:18:51,850
immediately distracted okay not after

00:18:49,779 --> 00:18:55,600
while immediately when the function

00:18:51,850 --> 00:19:01,149
exits so either at the time or there is

00:18:55,600 --> 00:19:03,970
a problem okay if you target C Python

00:19:01,149 --> 00:19:05,830
like I do mostly you can probably try to

00:19:03,970 --> 00:19:08,799
rely on this because it's not going to

00:19:05,830 --> 00:19:14,139
change even someone doesn't agree with

00:19:08,799 --> 00:19:19,419
this so for instance if you see that you

00:19:14,139 --> 00:19:22,990
called snippets above they are not that

00:19:19,419 --> 00:19:25,240
kind of coding style is not Python how

00:19:22,990 --> 00:19:27,610
can I say compact cross Python

00:19:25,240 --> 00:19:29,830
compatible it doesn't work on all Python

00:19:27,610 --> 00:19:32,769
implementations but it works on sit idle

00:19:29,830 --> 00:19:35,769
so in the first one I read file you see

00:19:32,769 --> 00:19:39,129
that I open a file and then directly

00:19:35,769 --> 00:19:41,529
return the contents of the file okay

00:19:39,129 --> 00:19:43,659
there is no clothes statement but the

00:19:41,529 --> 00:19:46,720
file is closed immediately when the

00:19:43,659 --> 00:19:48,100
function exit okay so if this is

00:19:46,720 --> 00:19:49,690
probably what you do because you are

00:19:48,100 --> 00:19:52,119
just trying to read the contents so it's

00:19:49,690 --> 00:19:54,759
open read close okay this is what you do

00:19:52,119 --> 00:19:56,919
do what you want but if you write code

00:19:54,759 --> 00:19:58,450
like this you can be sure that the file

00:19:56,919 --> 00:20:01,269
is immediately closed so you are not

00:19:58,450 --> 00:20:03,759
like licking a reference or maybe

00:20:01,269 --> 00:20:07,450
delaying destruction to an unspecified

00:20:03,759 --> 00:20:09,220
the time in the future the file will be

00:20:07,450 --> 00:20:13,000
closed immediately when the function

00:20:09,220 --> 00:20:17,830
exit okay and so you can shorten it even

00:20:13,000 --> 00:20:19,899
more second example above okay also that

00:20:17,830 --> 00:20:21,190
kind of code is correct and sip item and

00:20:19,899 --> 00:20:25,240
with correct I mean that the file is

00:20:21,190 --> 00:20:26,860
opened read close okay guaranteed there

00:20:25,240 --> 00:20:29,889
are absolutely no leak and they're

00:20:26,860 --> 00:20:36,639
absolutely not delay in the suction okay

00:20:29,889 --> 00:20:39,759
the formal GF sorry if it's okay if it

00:20:36,639 --> 00:20:43,600
throws an exception oh are you asking

00:20:39,759 --> 00:20:48,460
for pattern to or patio free I'm not

00:20:43,600 --> 00:20:50,110
sure so basically i will reply in python

00:20:48,460 --> 00:20:54,460
free because the answer you will act

00:20:50,110 --> 00:20:57,460
most so basically what happens is that

00:20:54,460 --> 00:20:59,649
if it runs an exception you you will

00:20:57,460 --> 00:21:01,509
catch the exceptional at a certain point

00:20:59,649 --> 00:21:04,240
because otherwise if the program exit

00:21:01,509 --> 00:21:06,700
you don't have any way so you will catch

00:21:04,240 --> 00:21:11,109
an exception the file is still open

00:21:06,700 --> 00:21:13,509
there until the except Clause finishes

00:21:11,109 --> 00:21:18,850
when the except Clause finishes so you

00:21:13,509 --> 00:21:21,820
just you know except what except ioerror

00:21:18,850 --> 00:21:24,700
something you just print error log

00:21:21,820 --> 00:21:26,470
whatever and then you blame them in the

00:21:24,700 --> 00:21:30,159
moment you de indent the file is closed

00:21:26,470 --> 00:21:33,100
okay this is part of free in Python to

00:21:30,159 --> 00:21:35,909
its little bit worse than that you need

00:21:33,100 --> 00:21:39,549
also to exit from the function where you

00:21:35,909 --> 00:21:41,950
grab that section okay in pattern to you

00:21:39,549 --> 00:21:44,499
need also to again to exit from the

00:21:41,950 --> 00:21:46,809
function there is a reason for this but

00:21:44,499 --> 00:21:50,889
i would need like 10 slides to show why

00:21:46,809 --> 00:21:54,039
so i don't have those here the code

00:21:50,889 --> 00:21:56,769
snippet here are them formally correct

00:21:54,039 --> 00:21:59,679
way to do it in all pattern interpreters

00:21:56,769 --> 00:22:03,250
so you just saw you either try finally

00:21:59,679 --> 00:22:03,580
used i try finally okay or you use the

00:22:03,250 --> 00:22:05,800
width

00:22:03,580 --> 00:22:08,560
statement okay the with statement also

00:22:05,800 --> 00:22:10,240
guarantees destruction and this works

00:22:08,560 --> 00:22:11,680
across all Python interpreter see

00:22:10,240 --> 00:22:13,350
windows with garbage collection and

00:22:11,680 --> 00:22:17,380
stuff because the wit statement says

00:22:13,350 --> 00:22:19,630
explicitly what to do when they block

00:22:17,380 --> 00:22:29,110
finish which is to cause the call they

00:22:19,630 --> 00:22:31,240
close function okay if you run the upper

00:22:29,110 --> 00:22:36,510
version on Python you will run out of

00:22:31,240 --> 00:22:39,400
files yeah so use the right one yeah

00:22:36,510 --> 00:22:41,620
yeah this is what I was saying before if

00:22:39,400 --> 00:22:45,010
you target other python implementation

00:22:41,620 --> 00:22:47,860
for instance by PI you cannot use the

00:22:45,010 --> 00:22:49,060
above examples because in pi PI the

00:22:47,860 --> 00:22:51,340
garbage collection might work

00:22:49,060 --> 00:22:53,860
differently might ought to use reference

00:22:51,340 --> 00:22:56,950
counting so this one is the correct

00:22:53,860 --> 00:22:59,950
version for all python versions okay so

00:22:56,950 --> 00:23:01,600
if you if you plan to use pi PI and

00:22:59,950 --> 00:23:03,040
sometimes all you want to be future

00:23:01,600 --> 00:23:05,500
proof you don't know what to do but

00:23:03,040 --> 00:23:08,140
maybe by PI so you can write code like

00:23:05,500 --> 00:23:10,120
this and we will work on pi PI but if

00:23:08,140 --> 00:23:11,710
you write code like this it works all

00:23:10,120 --> 00:23:14,260
written in C Python why I stress this

00:23:11,710 --> 00:23:16,990
because I need to explain you when there

00:23:14,260 --> 00:23:19,420
is a leak so first I need to make sure

00:23:16,990 --> 00:23:21,790
that everybody is aware when there is

00:23:19,420 --> 00:23:23,890
not a leak okay because otherwise it's

00:23:21,790 --> 00:23:25,870
all kind of magical those reference go

00:23:23,890 --> 00:23:27,960
away some sometime in the future and we

00:23:25,870 --> 00:23:32,080
don't understand okay so in C Python

00:23:27,960 --> 00:23:35,440
this is correct because the file is

00:23:32,080 --> 00:23:38,680
immediately destroyed okay so this is

00:23:35,440 --> 00:23:41,020
just a diagram showing the timeline from

00:23:38,680 --> 00:23:43,780
this is a timeline from top to bottom of

00:23:41,020 --> 00:23:46,480
the screen so for instance a object is

00:23:43,780 --> 00:23:49,060
holding a reference to be object the one

00:23:46,480 --> 00:23:51,460
between parentheses means that there is

00:23:49,060 --> 00:23:55,210
one reference to be okay which is the

00:23:51,460 --> 00:23:57,400
reference held by a and B is holding the

00:23:55,210 --> 00:24:03,130
reference to see so if we drop a

00:23:57,400 --> 00:24:06,610
reference from A to B that hand about do

00:24:03,130 --> 00:24:09,400
you say this sign here means that you're

00:24:06,610 --> 00:24:11,950
dropping a reference so what happens

00:24:09,400 --> 00:24:14,140
that they be reference count drops to

00:24:11,950 --> 00:24:16,320
zero and then the object is immediately

00:24:14,140 --> 00:24:20,639
distracted when its destructive

00:24:16,320 --> 00:24:22,830
by consequence the reference to cyst is

00:24:20,639 --> 00:24:25,919
dropped and since it was the last

00:24:22,830 --> 00:24:28,019
reference to see see also see is

00:24:25,919 --> 00:24:30,299
destroyed it's also it also gets

00:24:28,019 --> 00:24:32,639
destroyed by the interpreter so at the

00:24:30,299 --> 00:24:34,950
end of the day see is collected then be

00:24:32,639 --> 00:24:39,389
finishes this collection and then you

00:24:34,950 --> 00:24:42,809
left within ok so reference cycle can

00:24:39,389 --> 00:24:47,759
you see those thin lines here very thin

00:24:42,809 --> 00:24:50,309
sorry this is the problem with the

00:24:47,759 --> 00:24:52,169
reference cycles here there are some

00:24:50,309 --> 00:24:54,120
object there are these lines so you can

00:24:52,169 --> 00:24:56,490
trust these numbers between parentheses

00:24:54,120 --> 00:24:59,340
if you don't see the lines so but that

00:24:56,490 --> 00:25:01,110
is that you you get this day object ok

00:24:59,340 --> 00:25:04,049
and this day object as a reference to be

00:25:01,110 --> 00:25:06,779
and then there is a complex web of

00:25:04,049 --> 00:25:10,830
references you drop reference from A to

00:25:06,779 --> 00:25:13,169
B and this is supposed to work right but

00:25:10,830 --> 00:25:15,860
what happens is just that be just one

00:25:13,169 --> 00:25:20,120
and then all those web of references

00:25:15,860 --> 00:25:22,860
make makes make it so no objects are

00:25:20,120 --> 00:25:25,399
avid zero reference because they all

00:25:22,860 --> 00:25:29,009
reference together in a circle you see

00:25:25,399 --> 00:25:31,980
so even if you drop your last reference

00:25:29,009 --> 00:25:36,090
to these and to hold this world and you

00:25:31,980 --> 00:25:39,059
say ok I'm done with go away they still

00:25:36,090 --> 00:25:43,019
stay alive because they have there is a

00:25:39,059 --> 00:25:45,899
reference is a reference cycle ok so the

00:25:43,019 --> 00:25:49,139
reference count mechanism fail in this

00:25:45,899 --> 00:25:52,190
example so what Python does to fix this

00:25:49,139 --> 00:25:55,620
problem was introduced in C Python 2.0

00:25:52,190 --> 00:25:57,389
is the cyclic garbage collector so there

00:25:55,620 --> 00:25:59,309
is a cabbage collector going on in the

00:25:57,389 --> 00:26:01,649
background you bro you're probably heard

00:25:59,309 --> 00:26:03,059
of it but it's important to see that

00:26:01,649 --> 00:26:05,519
this garbage collector is only

00:26:03,059 --> 00:26:09,269
responsible for collecting cycles of

00:26:05,519 --> 00:26:11,399
objects so back to this example the

00:26:09,269 --> 00:26:14,039
garbage the garbage collector will help

00:26:11,399 --> 00:26:15,840
you collect only disciple of objects ok

00:26:14,039 --> 00:26:17,730
because this is where reference counting

00:26:15,840 --> 00:26:19,710
doesn't work for everything else there

00:26:17,730 --> 00:26:22,860
is reference counting when there is a

00:26:19,710 --> 00:26:25,799
cycle the garbage collector it kicks it

00:26:22,860 --> 00:26:30,080
kicks in always but when it is a cycle

00:26:25,799 --> 00:26:34,230
like this it will collect it ok

00:26:30,080 --> 00:26:37,309
to collect this kind of cycle it

00:26:34,230 --> 00:26:40,440
basically breaks references at random

00:26:37,309 --> 00:26:43,080
try to get the counters go to zero so

00:26:40,440 --> 00:26:44,880
that the object can be destroyed okay

00:26:43,080 --> 00:26:46,470
this is the way they garbage collector

00:26:44,880 --> 00:26:49,200
wars there are two phases the first

00:26:46,470 --> 00:26:51,600
phase is finding the circles okay let's

00:26:49,200 --> 00:26:53,880
say it found a cycle it will just get a

00:26:51,600 --> 00:26:56,220
random object get the random reference

00:26:53,880 --> 00:26:58,650
and just break it so if you have some

00:26:56,220 --> 00:27:02,669
odd is it something like you say random

00:26:58,650 --> 00:27:05,309
random statement like Dell any point X

00:27:02,669 --> 00:27:08,220
ok we'll do something like that and then

00:27:05,309 --> 00:27:10,289
hope that the references go down one at

00:27:08,220 --> 00:27:13,470
the time and then object all up just go

00:27:10,289 --> 00:27:15,900
away okay you can force an invitation of

00:27:13,470 --> 00:27:18,780
garbage collector to the GC collect call

00:27:15,900 --> 00:27:21,150
okay this is a way to force garbage

00:27:18,780 --> 00:27:23,549
collection to happen now which is very

00:27:21,150 --> 00:27:25,110
cool for debugging you can disable and

00:27:23,549 --> 00:27:27,120
enable the grand corbett garbage

00:27:25,110 --> 00:27:28,650
collector which is very useful when you

00:27:27,120 --> 00:27:31,470
are doing a lot of a location or the

00:27:28,650 --> 00:27:34,169
allocation so when you have this big

00:27:31,470 --> 00:27:36,720
application which is file open load file

00:27:34,169 --> 00:27:38,280
you can disable garbage collection while

00:27:36,720 --> 00:27:40,980
the file is loading because you are

00:27:38,280 --> 00:27:43,049
locating tons of stuff and then you rain

00:27:40,980 --> 00:27:44,970
able it at the end because otherwise the

00:27:43,049 --> 00:27:46,500
cabbage collects or kicks in many times

00:27:44,970 --> 00:27:49,590
during loading and you don't probably

00:27:46,500 --> 00:27:51,480
want it okay and this is probably a

00:27:49,590 --> 00:27:56,070
really nice speed up which is free for

00:27:51,480 --> 00:27:59,150
you so how the garbage collector wars I

00:27:56,070 --> 00:28:02,820
have this small animation stuff later so

00:27:59,150 --> 00:28:05,250
this is the example before a is our word

00:28:02,820 --> 00:28:07,830
we lost the last reference like there is

00:28:05,250 --> 00:28:10,110
a cycle the garbage collector starts and

00:28:07,830 --> 00:28:15,270
just drops the reference okay so just

00:28:10,110 --> 00:28:18,690
say del b dot x which is c so remove

00:28:15,270 --> 00:28:21,690
this reference then C goes to 0 and then

00:28:18,690 --> 00:28:25,260
bring the way to other references okay

00:28:21,690 --> 00:28:27,690
but still another object row 20 there is

00:28:25,260 --> 00:28:30,059
another smaller cycle subset cycle of

00:28:27,690 --> 00:28:34,130
the cycle before so again garbage

00:28:30,059 --> 00:28:38,610
collector kicks in and say is like del e

00:28:34,130 --> 00:28:42,029
dot X which is d the reference go away

00:28:38,610 --> 00:28:45,200
some objects go away another small side

00:28:42,029 --> 00:28:49,489
Oh third round of garbage collectors

00:28:45,200 --> 00:28:53,249
removal of this object again again and

00:28:49,489 --> 00:28:54,749
everything is done okay actually I said

00:28:53,249 --> 00:28:57,179
the third run but it's not correct

00:28:54,749 --> 00:28:59,159
because it manages to understand that

00:28:57,179 --> 00:29:01,919
this still needs to you know like loop

00:28:59,159 --> 00:29:04,590
on itself until it's done okay now

00:29:01,919 --> 00:29:08,899
justin is basically just three steps of

00:29:04,590 --> 00:29:08,899
the one invocation of garbage collector

00:29:09,320 --> 00:29:16,950
so let's try this in the R word again a1

00:29:14,190 --> 00:29:20,879
a2 I create a cyclic reference here

00:29:16,950 --> 00:29:24,179
saket reference you see a one reference

00:29:20,879 --> 00:29:28,879
to a two and A two reference to a one so

00:29:24,179 --> 00:29:31,460
we have a loop here if I ask how many

00:29:28,879 --> 00:29:34,229
instances there are there are two

00:29:31,460 --> 00:29:36,710
instances you remember the how many was

00:29:34,229 --> 00:29:40,409
filtering the list of all Python objects

00:29:36,710 --> 00:29:43,919
okay so there are two a instances i

00:29:40,409 --> 00:29:47,460
delete a one and delete a tool and when

00:29:43,919 --> 00:29:51,179
I do this I think okay i get rid of all

00:29:47,460 --> 00:29:54,869
my references to a-1 a-2 they should be

00:29:51,179 --> 00:29:56,609
collected yes but not immediately how

00:29:54,869 --> 00:29:58,440
many a is still too because the

00:29:56,609 --> 00:30:01,169
reference count mechanism here fails

00:29:58,440 --> 00:30:02,820
because of the cycle okay so immediately

00:30:01,169 --> 00:30:05,129
after the statement there are still two

00:30:02,820 --> 00:30:07,889
references then you run the garbage

00:30:05,129 --> 00:30:11,639
collector once and it tells you that

00:30:07,889 --> 00:30:15,899
it's collected four objects okay and

00:30:11,639 --> 00:30:19,289
there are no more is after the garbage

00:30:15,899 --> 00:30:21,089
collector those four objects anybody's

00:30:19,289 --> 00:30:24,359
an idea why there are four of just being

00:30:21,089 --> 00:30:27,359
collected it's the question okay yeah

00:30:24,359 --> 00:30:29,729
it's basically a one and two a one

00:30:27,359 --> 00:30:32,729
instance dictionary a to z instant

00:30:29,729 --> 00:30:38,719
dictionary okay so it's four of just

00:30:32,729 --> 00:30:38,719
being collected I sweet on this line

00:30:41,240 --> 00:30:52,440
yeah it is smart guy yeah yeah you were

00:30:44,610 --> 00:30:55,080
smart you with realism but also GC

00:30:52,440 --> 00:30:57,060
doesn't work in some car in some cases

00:30:55,080 --> 00:31:01,140
for instance it doesn't work on object

00:30:57,060 --> 00:31:03,000
with finalized errs so if you have an

00:31:01,140 --> 00:31:06,090
objects with the Nanda under del

00:31:03,000 --> 00:31:08,750
function defined the GC doesn't work and

00:31:06,090 --> 00:31:11,640
why doesn't work because it cannot

00:31:08,750 --> 00:31:13,980
cannot break references in random more

00:31:11,640 --> 00:31:16,800
than anymore because when you write your

00:31:13,980 --> 00:31:19,680
nice under under del code you expect

00:31:16,800 --> 00:31:22,290
that the object is seen is in the state

00:31:19,680 --> 00:31:24,270
it was just before its destruction right

00:31:22,290 --> 00:31:27,840
but if the garbage collector is

00:31:24,270 --> 00:31:30,090
distracted the random is removed objects

00:31:27,840 --> 00:31:34,230
from sorry references attributes from

00:31:30,090 --> 00:31:36,960
your objects in random points if it

00:31:34,230 --> 00:31:39,060
involves the den code your dell code

00:31:36,960 --> 00:31:41,670
maybe some attributes are not available

00:31:39,060 --> 00:31:43,650
anymore because the GC is to remove it

00:31:41,670 --> 00:31:45,450
at random as we show before and then

00:31:43,650 --> 00:31:48,090
your dell object would raise an

00:31:45,450 --> 00:31:50,520
exception attribute error okay so this

00:31:48,090 --> 00:31:53,220
is something that GC try to avoid and so

00:31:50,520 --> 00:31:57,810
it just cannot work with objects with

00:31:53,220 --> 00:32:01,920
the under under del function okay in

00:31:57,810 --> 00:32:04,260
this case you really have a leak okay in

00:32:01,920 --> 00:32:06,510
this case those objects will never be

00:32:04,260 --> 00:32:13,020
collected and will stain your process

00:32:06,510 --> 00:32:16,740
memory forever okay Lex is only one of

00:32:13,020 --> 00:32:20,730
the elements as a bell menu good-by to

00:32:16,740 --> 00:32:23,910
Prague another yep the garbage collector

00:32:20,730 --> 00:32:26,430
you mean yeah I will repeat this

00:32:23,910 --> 00:32:30,000
question by going to the next slide with

00:32:26,430 --> 00:32:32,240
a display so basically as I'm writing

00:32:30,000 --> 00:32:37,190
here you can still use their own lives

00:32:32,240 --> 00:32:40,890
to explain this i have this diagram here

00:32:37,190 --> 00:32:43,650
so basically if you have a cycle are ok

00:32:40,890 --> 00:32:46,020
this green stuff are the objects with

00:32:43,650 --> 00:32:49,590
the finalizer ok the blue one doesn't

00:32:46,020 --> 00:32:51,160
don't have any finalizer so if you have

00:32:49,590 --> 00:32:55,390
a cycle like this

00:32:51,160 --> 00:32:58,630
you have a leak okay but if you have a

00:32:55,390 --> 00:33:01,180
cycle like these you don't have a leak

00:32:58,630 --> 00:33:04,180
because in this case garbage collector

00:33:01,180 --> 00:33:07,330
know that he can break disciple at any

00:33:04,180 --> 00:33:09,640
point the end nothing wheel balance

00:33:07,330 --> 00:33:12,130
because these objects it doesn't touch

00:33:09,640 --> 00:33:13,900
it okay so because it's not part of

00:33:12,130 --> 00:33:17,260
disciple it's not technically part of

00:33:13,900 --> 00:33:20,230
disciple disciple is holding this object

00:33:17,260 --> 00:33:22,600
alive but is not part of the cycle okay

00:33:20,230 --> 00:33:25,150
so since the garbage collector only

00:33:22,600 --> 00:33:27,610
works on cycles it doesn't see these

00:33:25,150 --> 00:33:29,260
objects basically so it doesn't see this

00:33:27,610 --> 00:33:31,240
object just see these objects they say

00:33:29,260 --> 00:33:33,340
okay there are no finalizar let me just

00:33:31,240 --> 00:33:35,590
break stuff here and then everything

00:33:33,340 --> 00:33:41,530
goes away okay if you are something like

00:33:35,590 --> 00:33:43,960
this you have the leak so what you can

00:33:41,530 --> 00:33:47,080
do is you can try if you want to use

00:33:43,960 --> 00:33:49,060
them on Leafs on classes that you know

00:33:47,080 --> 00:33:52,450
that will never be part of cycles

00:33:49,060 --> 00:33:54,760
because basically I just leaves so for

00:33:52,450 --> 00:33:57,790
instance just to have an example let me

00:33:54,760 --> 00:34:00,790
say you're wrapping some open closed

00:33:57,790 --> 00:34:02,680
lock release kind of api's there are

00:34:00,790 --> 00:34:05,380
better ways to do it with statement

00:34:02,680 --> 00:34:08,470
whatever but just to make an example you

00:34:05,380 --> 00:34:11,020
have wrapping some lock release api's

00:34:08,470 --> 00:34:12,910
into an object okay so you're just

00:34:11,020 --> 00:34:15,910
wrapping it just creating a small object

00:34:12,910 --> 00:34:18,460
okay this is more object you will you

00:34:15,910 --> 00:34:22,210
will hold some references to it but this

00:34:18,460 --> 00:34:25,900
object will not blue some kind of cycles

00:34:22,210 --> 00:34:27,760
or web of references on that object you

00:34:25,900 --> 00:34:31,870
can probably use them this is an example

00:34:27,760 --> 00:34:34,210
with opengl opengl is the capi okay and

00:34:31,870 --> 00:34:36,490
for instance the reason i look allocate

00:34:34,210 --> 00:34:38,440
or d a locator of something called the

00:34:36,490 --> 00:34:41,230
display list so we you don't need to

00:34:38,440 --> 00:34:44,679
know what it is you can do there is this

00:34:41,230 --> 00:34:49,120
RPG l a lock list and then jail free

00:34:44,679 --> 00:34:52,120
list okay just call to opengl so you can

00:34:49,120 --> 00:34:56,290
this is a small wrapper for making

00:34:52,120 --> 00:34:59,290
python code fun f more fun so basically

00:34:56,290 --> 00:35:01,900
you just allocate a list in the

00:34:59,290 --> 00:35:02,520
constructor and free the list in the

00:35:01,900 --> 00:35:06,000
destructor

00:35:02,520 --> 00:35:08,010
this case this is probably the will

00:35:06,000 --> 00:35:09,900
never be part of the cycle because this

00:35:08,010 --> 00:35:12,330
is the whole class will never hold a

00:35:09,900 --> 00:35:13,950
reference to another class and be part

00:35:12,330 --> 00:35:19,080
of the cycle so here you can use a

00:35:13,950 --> 00:35:21,570
finalized ok GC dot car is a list

00:35:19,080 --> 00:35:23,670
of all the objects that cannot be

00:35:21,570 --> 00:35:26,010
collected by the garbage collector so

00:35:23,670 --> 00:35:29,100
this is our your memory leaks you have a

00:35:26,010 --> 00:35:32,670
list of your leaks which is fun funny

00:35:29,100 --> 00:35:35,340
for AC programmer our list of the leaks

00:35:32,670 --> 00:35:36,960
wisely yeah is it Alec because they will

00:35:35,340 --> 00:35:39,180
stay that is they will stay in this list

00:35:36,960 --> 00:35:42,510
okay so they are resting in your process

00:35:39,180 --> 00:35:44,880
memory you can look here if your

00:35:42,510 --> 00:35:46,800
troubles so if you think your process

00:35:44,880 --> 00:35:48,810
memory is growing what you don't you

00:35:46,800 --> 00:35:54,540
just print this list because if it's not

00:35:48,810 --> 00:35:57,800
empty you have a problem and how can you

00:35:54,540 --> 00:36:01,320
finalize objects without using dell

00:35:57,800 --> 00:36:04,860
there is actually trick the trick goes

00:36:01,320 --> 00:36:07,350
to use the weak references the weak

00:36:04,860 --> 00:36:11,220
references how many people know what a

00:36:07,350 --> 00:36:16,200
with reference ism okay so basically

00:36:11,220 --> 00:36:20,250
it's a reference to an object in a way

00:36:16,200 --> 00:36:22,470
that it doesn't increase the reference

00:36:20,250 --> 00:36:26,070
count of that object okay is a weak

00:36:22,470 --> 00:36:28,560
reference so it doesn't really have a

00:36:26,070 --> 00:36:30,660
reference and if the object dies the

00:36:28,560 --> 00:36:35,280
with reference automatically turns to

00:36:30,660 --> 00:36:37,230
none okay and the wit references as a

00:36:35,280 --> 00:36:39,060
nice visual they have a callback

00:36:37,230 --> 00:36:41,730
function that you can register when the

00:36:39,060 --> 00:36:44,190
object dies okay and this is the way in

00:36:41,730 --> 00:36:49,110
through this you can probably emulate

00:36:44,190 --> 00:36:53,850
del Sol back to the back to the example

00:36:49,110 --> 00:36:55,980
journal oakleys jelly free list this is

00:36:53,850 --> 00:36:58,770
with them you can see how many jelly

00:36:55,980 --> 00:37:03,240
this playlist 0 i allocate one how many

00:36:58,770 --> 00:37:05,010
one Idol italy that object how many 0 ok

00:37:03,240 --> 00:37:07,410
so everything is working correctly the

00:37:05,010 --> 00:37:13,140
dell is being invoked how can i write

00:37:07,410 --> 00:37:15,310
this without del like this ok so what I

00:37:13,140 --> 00:37:19,180
do is that I create

00:37:15,310 --> 00:37:23,230
and weak reference to self which is the

00:37:19,180 --> 00:37:25,750
gel this playlist object and this is the

00:37:23,230 --> 00:37:28,060
call the function that will be involved

00:37:25,750 --> 00:37:31,030
when gel display lists' the object is

00:37:28,060 --> 00:37:33,370
being destroyed okay so when it's been

00:37:31,030 --> 00:37:35,110
destroyed the weak reference will invoke

00:37:33,370 --> 00:37:36,910
the callback function and in the

00:37:35,110 --> 00:37:41,200
callback function I will just pull the

00:37:36,910 --> 00:37:43,630
gel free dysfunction okay so I'm

00:37:41,200 --> 00:37:48,180
basically getting the dell code and

00:37:43,630 --> 00:37:53,290
moving it into the cold bed okay but

00:37:48,180 --> 00:37:57,100
Alice it's not that easy because if I

00:37:53,290 --> 00:37:59,320
try again it kinds of work because i

00:37:57,100 --> 00:38:03,220
allocate the gel displeased then I

00:37:59,320 --> 00:38:05,530
delete it but there is still one

00:38:03,220 --> 00:38:08,800
instance of jelly displaced after the

00:38:05,530 --> 00:38:11,170
collision DC collector then i get rid of

00:38:08,800 --> 00:38:14,950
that instance so basically it kind of

00:38:11,170 --> 00:38:18,190
works but it daily delays destruction to

00:38:14,950 --> 00:38:20,530
the garbage collection and this happens

00:38:18,190 --> 00:38:23,350
because there is a reference there is a

00:38:20,530 --> 00:38:25,090
reference Eiffel the referent cycle in

00:38:23,350 --> 00:38:27,160
this code is probably hard to see

00:38:25,090 --> 00:38:29,410
because you say oh where is the cycle

00:38:27,160 --> 00:38:31,210
again I cannot see a cycle here and the

00:38:29,410 --> 00:38:34,000
cycle is basically this one you have the

00:38:31,210 --> 00:38:36,790
yourself object ok so the instance I

00:38:34,000 --> 00:38:39,790
call itself as a reference tweet prev

00:38:36,790 --> 00:38:41,380
right self dot underworld this is a

00:38:39,790 --> 00:38:43,900
reference or self as a reference to wit

00:38:41,380 --> 00:38:45,760
ref we trev all the reference they call

00:38:43,900 --> 00:38:48,730
the function because it needs to call it

00:38:45,760 --> 00:38:51,280
obviously and the callback function as a

00:38:48,730 --> 00:38:53,650
reference to the national scope the

00:38:51,280 --> 00:38:55,660
nested copper is the scope that

00:38:53,650 --> 00:39:00,430
basically is hidden by the interpreter

00:38:55,660 --> 00:39:03,820
and it lets you access in it local

00:39:00,430 --> 00:39:06,490
variables from within this lambda

00:39:03,820 --> 00:39:09,520
function you see that within from this

00:39:06,490 --> 00:39:13,540
lambda function are you self and how can

00:39:09,520 --> 00:39:16,120
this function have as the referee have a

00:39:13,540 --> 00:39:18,640
reference to self it's because this

00:39:16,120 --> 00:39:21,820
function is holding the reference to a

00:39:18,640 --> 00:39:23,770
secret list of objects which has the

00:39:21,820 --> 00:39:26,830
objects of this init function and this

00:39:23,770 --> 00:39:29,050
is the nest scope ok Aidan Estes copper

00:39:26,830 --> 00:39:31,690
is the one with the reference to self

00:39:29,050 --> 00:39:35,740
and this is why this lambda function can

00:39:31,690 --> 00:39:39,070
work because it's there is a reference

00:39:35,740 --> 00:39:40,900
to this nest s cops so it works but

00:39:39,070 --> 00:39:42,610
there is a quality of implementation

00:39:40,900 --> 00:39:44,470
regression because before it was being

00:39:42,610 --> 00:39:47,350
collected immediately now we need to

00:39:44,470 --> 00:39:49,660
wait for the garbage collection to fix

00:39:47,350 --> 00:39:55,570
this there is a little trick which is to

00:39:49,660 --> 00:39:57,310
use the default arguments use you

00:39:55,570 --> 00:39:59,470
probably you probably are aware that in

00:39:57,310 --> 00:40:01,570
Python default arguments to function our

00:39:59,470 --> 00:40:03,700
little wheeled compared to other

00:40:01,570 --> 00:40:07,180
languages because they are evaluated the

00:40:03,700 --> 00:40:09,280
moment the function is compiled or is

00:40:07,180 --> 00:40:11,590
not compiled but anyway the moment the

00:40:09,280 --> 00:40:14,080
function is compiled and not at any

00:40:11,590 --> 00:40:17,260
invocation of the function so if you

00:40:14,080 --> 00:40:19,710
just get the reference to self dot ID

00:40:17,260 --> 00:40:23,560
here when you create the lumber function

00:40:19,710 --> 00:40:25,360
and you assigned to ID so basically this

00:40:23,560 --> 00:40:27,910
lambda function doesn't need a net set

00:40:25,360 --> 00:40:30,010
up anymore because they it doesn't

00:40:27,910 --> 00:40:33,130
access anymore anything outside itself

00:40:30,010 --> 00:40:35,920
it just pulls a global function okay and

00:40:33,130 --> 00:40:38,200
then just use this ID default argument

00:40:35,920 --> 00:40:41,650
so it doesn't have an SS cop anymore

00:40:38,200 --> 00:40:44,650
there is no more access to outside the

00:40:41,650 --> 00:40:46,390
outside references it just self

00:40:44,650 --> 00:40:48,550
contained a normal functional

00:40:46,390 --> 00:40:50,500
self-contained function so there is no

00:40:48,550 --> 00:40:52,840
more no more Nesta scope in this case

00:40:50,500 --> 00:40:56,860
you don't have a circle anymore ok and

00:40:52,840 --> 00:41:00,100
so this code behaves exactly like with

00:40:56,860 --> 00:41:02,850
the original finalizer ok this is a

00:41:00,100 --> 00:41:10,060
virtually perfect substitution for Dell

00:41:02,850 --> 00:41:12,550
I was discussing this with the remand

00:41:10,060 --> 00:41:15,580
hettinger sometimes in some few years

00:41:12,550 --> 00:41:19,390
ago and he proposed to I will you know

00:41:15,580 --> 00:41:22,440
starting to propose this function i

00:41:19,390 --> 00:41:25,540
finalized function well you basically

00:41:22,440 --> 00:41:27,970
you register if analyzer so you

00:41:25,540 --> 00:41:31,150
basically say ok when these object dies

00:41:27,970 --> 00:41:33,940
I want this callback to be called ok and

00:41:31,150 --> 00:41:36,520
this function will basically create the

00:41:33,940 --> 00:41:38,390
weak reference for you whole beating

00:41:36,520 --> 00:41:41,990
them into am ready

00:41:38,390 --> 00:41:44,900
three of weak references so it's based

00:41:41,990 --> 00:41:49,279
so that it's easier for you again the

00:41:44,900 --> 00:41:51,349
display list example there is no more we

00:41:49,279 --> 00:41:55,369
crave for stuff for you just need to

00:41:51,349 --> 00:41:58,099
finalize itself and pass the finalizer

00:41:55,369 --> 00:42:01,220
function but you still have the nexus 4

00:41:58,099 --> 00:42:03,500
problem okay but you don't have to hold

00:42:01,220 --> 00:42:07,640
the references in your object and it's

00:42:03,500 --> 00:42:10,460
probably cleaner for you and another

00:42:07,640 --> 00:42:14,029
small tool you can do i always use this

00:42:10,460 --> 00:42:17,180
one it is the bug death I pass it an

00:42:14,029 --> 00:42:19,880
object a basically I want to know when

00:42:17,180 --> 00:42:23,000
the object is destroyed so I write debug

00:42:19,880 --> 00:42:24,799
that all which means please print a

00:42:23,000 --> 00:42:28,130
statement to the standard output when

00:42:24,799 --> 00:42:30,500
all dies okay and we will finish

00:42:28,130 --> 00:42:34,130
finalized we basically see you register

00:42:30,500 --> 00:42:37,849
if analyzer for all who a function we

00:42:34,130 --> 00:42:39,380
just does a print okay which is nice

00:42:37,849 --> 00:42:40,700
because when you are debugging you

00:42:39,380 --> 00:42:43,490
probably want to know when an object

00:42:40,700 --> 00:42:47,799
dice so you just say okay please let me

00:42:43,490 --> 00:42:50,390
the back when this object dies okay and

00:42:47,799 --> 00:42:52,460
the nice thing about this function is

00:42:50,390 --> 00:42:54,319
that it works for any object you don't

00:42:52,460 --> 00:42:56,390
need to add the finalizer to the object

00:42:54,319 --> 00:43:03,890
modify its code you can do it Excel

00:42:56,390 --> 00:43:06,740
externally ok ok these are those are the

00:43:03,890 --> 00:43:09,650
leaks where the leaks in the you mean

00:43:06,740 --> 00:43:14,829
Python side we can have also leaks in

00:43:09,650 --> 00:43:16,849
the C C++ sides so for instance some

00:43:14,829 --> 00:43:19,369
enthusiasts first called the programmers

00:43:16,849 --> 00:43:22,509
need to call improv and deck ref

00:43:19,369 --> 00:43:24,680
explicitly so they need to explicitly

00:43:22,509 --> 00:43:27,019
increment the counter when the keeper

00:43:24,680 --> 00:43:30,079
when they start to keep reference and

00:43:27,019 --> 00:43:33,109
decrease the counter when they they're

00:43:30,079 --> 00:43:36,170
not holding a reference anymore if they

00:43:33,109 --> 00:43:38,630
forget to call that graph it's a memory

00:43:36,170 --> 00:43:42,200
leak you probably are just using the

00:43:38,630 --> 00:43:44,869
library but you have a memory leak the

00:43:42,200 --> 00:43:46,849
API is back drama because it's back from

00:43:44,869 --> 00:43:50,539
I mean it's just a little hard to write

00:43:46,849 --> 00:43:51,660
and you need to pay attention I usually

00:43:50,539 --> 00:43:54,780
suggest to

00:43:51,660 --> 00:43:59,039
binding generators more so if you have

00:43:54,780 --> 00:44:00,809
this random github library you found

00:43:59,039 --> 00:44:04,680
that you're not very sure it's mature

00:44:00,809 --> 00:44:07,619
and that it's got a lot of manual C

00:44:04,680 --> 00:44:10,470
Python API code I wouldn't trust it

00:44:07,619 --> 00:44:12,539
fully not to leak any object while if

00:44:10,470 --> 00:44:16,559
it's using some kind of binding

00:44:12,539 --> 00:44:19,109
generator like seitan or sweet Gore sip

00:44:16,559 --> 00:44:21,900
or whatever then probably there are no

00:44:19,109 --> 00:44:24,839
bugs because the binding generator takes

00:44:21,900 --> 00:44:31,589
care of these reference counters and

00:44:24,839 --> 00:44:35,119
it's the code is more mature ok I will

00:44:31,589 --> 00:44:35,119
just have some water

00:45:06,140 --> 00:45:14,960
and sorry I just need the microphone

00:45:07,849 --> 00:45:18,680
because I cannot be are correct I'm not

00:45:14,960 --> 00:45:21,740
sure if I understood the best if you use

00:45:18,680 --> 00:45:23,720
something like this week and the

00:45:21,740 --> 00:45:26,650
interpreter goes down basically you exit

00:45:23,720 --> 00:45:29,599
the program you have two problems that

00:45:26,650 --> 00:45:32,470
modules get destroyed and the Global's

00:45:29,599 --> 00:45:38,779
get set to none and speak usually

00:45:32,470 --> 00:45:42,170
carries around a reference to a global

00:45:38,779 --> 00:45:45,349
to destroy its local objects so if you

00:45:42,170 --> 00:45:49,549
use binding generator you usually get a

00:45:45,349 --> 00:45:51,859
ton of those arrows on program exit if

00:45:49,549 --> 00:45:54,140
you do a bit more complex sayings to be

00:45:51,859 --> 00:45:57,549
to be more precise if you swing you get

00:45:54,140 --> 00:46:00,380
on those errors yeah I I hate week okay

00:45:57,549 --> 00:46:02,690
so it's not matter yeah no it's not I

00:46:00,380 --> 00:46:05,180
mean it's not improve that's correct but

00:46:02,690 --> 00:46:07,940
I see those extensions which are like

00:46:05,180 --> 00:46:10,849
1,000,000,000 of code of Python caap I

00:46:07,940 --> 00:46:13,730
with the 10 users in the world and those

00:46:10,849 --> 00:46:16,460
are f memory leaks for sure if you swing

00:46:13,730 --> 00:46:20,779
probably most of the code words but we

00:46:16,460 --> 00:46:34,759
have is some issues large issue okay so

00:46:20,779 --> 00:46:38,720
I ok timecode profiling this is just

00:46:34,759 --> 00:46:44,000
basic stuff but still gives you an idea

00:46:38,720 --> 00:46:47,420
of how to profile your Python code the

00:46:44,000 --> 00:46:50,809
first most simplest way to profile your

00:46:47,420 --> 00:46:53,089
code is to use the time it module which

00:46:50,809 --> 00:46:56,809
is a way to do just measurement of code

00:46:53,089 --> 00:46:59,809
the speed it's useful from small to

00:46:56,809 --> 00:47:04,130
medium code snippets and basically

00:46:59,809 --> 00:47:07,519
measure the average execution time you

00:47:04,130 --> 00:47:11,599
can use from common line you just need

00:47:07,519 --> 00:47:14,750
to say Python dash mne time it and then

00:47:11,599 --> 00:47:16,430
you can pass one or more setup statement

00:47:14,750 --> 00:47:19,820
which means you are set up in the

00:47:16,430 --> 00:47:23,030
environment before doing the profiling

00:47:19,820 --> 00:47:25,370
and then the set of statements are they

00:47:23,030 --> 00:47:28,820
have a dash stress in front of them okay

00:47:25,370 --> 00:47:33,170
and then you pass it one statement that

00:47:28,820 --> 00:47:36,410
you are actually sorry 111 expression

00:47:33,170 --> 00:47:38,750
that you want to evaluate or is it a

00:47:36,410 --> 00:47:42,500
statement no it's a statement ya know

00:47:38,750 --> 00:47:45,110
oops I'll confused etcetera statement or

00:47:42,500 --> 00:47:47,720
expression I just can remember and now

00:47:45,110 --> 00:47:50,750
but anyway you pass it the code that you

00:47:47,720 --> 00:47:53,240
want to profile it like this or like

00:47:50,750 --> 00:47:55,610
this so for instance here i am saying

00:47:53,240 --> 00:47:57,800
okay python the same time it so i want

00:47:55,610 --> 00:48:01,340
to do a time measurement the setup is

00:47:57,800 --> 00:48:03,800
creating a list with just one item which

00:48:01,340 --> 00:48:06,410
is 0 and then I want to know how long it

00:48:03,800 --> 00:48:09,350
takes to the interpreter to multiply

00:48:06,410 --> 00:48:12,980
this hundreds of times so create 100

00:48:09,350 --> 00:48:15,350
items with value 0 okay this is more

00:48:12,980 --> 00:48:17,870
complex but it can be in your

00:48:15,350 --> 00:48:20,180
application you just import the core of

00:48:17,870 --> 00:48:23,930
your application then you load some

00:48:20,180 --> 00:48:26,300
large data set load food that so you see

00:48:23,930 --> 00:48:29,210
this statement set up statement are

00:48:26,300 --> 00:48:33,260
executed in order you load your large

00:48:29,210 --> 00:48:35,540
data set then you you know find sign my

00:48:33,260 --> 00:48:37,820
items within this large data sets and

00:48:35,540 --> 00:48:40,220
then you do some complex computation on

00:48:37,820 --> 00:48:42,410
them and you want to know how long it

00:48:40,220 --> 00:48:45,200
takes to do this oh this is supposed to

00:48:42,410 --> 00:48:48,110
be used for stuff like I don't know

00:48:45,200 --> 00:48:50,240
maybe less than a second or not 23

00:48:48,110 --> 00:48:54,250
seconds if it takes like two hours it's

00:48:50,240 --> 00:48:57,290
not right tool the nice thing is that

00:48:54,250 --> 00:48:59,620
time it is the dynamic precision so it

00:48:57,290 --> 00:49:02,840
works from microseconds two milliseconds

00:48:59,620 --> 00:49:05,960
because it adjusts dynamically and knows

00:49:02,840 --> 00:49:08,780
how many times to retry executing your

00:49:05,960 --> 00:49:11,330
code to be sure that the error that

00:49:08,780 --> 00:49:13,490
gives you from the average is correct so

00:49:11,330 --> 00:49:18,650
for instance this is an example from by

00:49:13,490 --> 00:49:20,360
cute for you can just measuring how long

00:49:18,650 --> 00:49:24,850
it takes to a cue mattrick's to be

00:49:20,360 --> 00:49:27,760
inverted okay so this time we decided

00:49:24,850 --> 00:49:31,880
automatically decide to try to do this

00:49:27,760 --> 00:49:33,650
100 thousands of times

00:49:31,880 --> 00:49:39,980
it can give you an idea that it takes

00:49:33,650 --> 00:49:44,500
five dot 93 microseconds per loop

00:49:39,980 --> 00:49:47,059
repeats as executing three times okay

00:49:44,500 --> 00:49:50,059
this is nice because you can use it to

00:49:47,059 --> 00:49:51,769
compare different implementations if you

00:49:50,059 --> 00:49:54,400
just tweak something you want to see if

00:49:51,769 --> 00:49:57,440
it's really faster or not you maybe you

00:49:54,400 --> 00:50:00,319
go you went to some remand hettinger

00:49:57,440 --> 00:50:02,240
talk where he was saying like oh you can

00:50:00,319 --> 00:50:04,400
like do this nice thing with the

00:50:02,240 --> 00:50:07,579
dictionary fuse pop items is faster than

00:50:04,400 --> 00:50:09,559
doing nested the list comprehensions

00:50:07,579 --> 00:50:11,660
after that you want to know if it's

00:50:09,559 --> 00:50:13,490
really sure for your code with your data

00:50:11,660 --> 00:50:16,730
set then you can try to compare

00:50:13,490 --> 00:50:20,480
implementation with time it ok micro

00:50:16,730 --> 00:50:23,269
profiling for large profiling there are

00:50:20,480 --> 00:50:25,369
too many types of profiling you can have

00:50:23,269 --> 00:50:27,740
deterministic profiling of statistic

00:50:25,369 --> 00:50:29,779
profiling the term easy profiling means

00:50:27,740 --> 00:50:32,569
that your code is instrumented

00:50:29,779 --> 00:50:33,950
automatically so basically the cpat

00:50:32,569 --> 00:50:36,200
interpreter is a way to know exactly

00:50:33,950 --> 00:50:39,529
when a function begins or ends and

00:50:36,200 --> 00:50:42,289
measure the time statistic profiling

00:50:39,529 --> 00:50:45,740
means that basically there is like a

00:50:42,289 --> 00:50:48,829
check very often so basically a schedule

00:50:45,740 --> 00:50:50,720
a timer and said every the no 10

00:50:48,829 --> 00:50:53,509
milliseconds and checks in which

00:50:50,720 --> 00:50:55,940
function it is at that point and then by

00:50:53,509 --> 00:50:57,920
statistics it says okay this function

00:50:55,940 --> 00:50:59,750
takes a lot of time because many times

00:50:57,920 --> 00:51:02,150
when I woke up I was within this

00:50:59,750 --> 00:51:03,589
function okay so you can either have the

00:51:02,150 --> 00:51:08,839
statistic approach that a mistake

00:51:03,589 --> 00:51:13,309
approach see profile it's not really hot

00:51:08,839 --> 00:51:16,190
new on right now but hot nuke is the hot

00:51:13,309 --> 00:51:19,039
new guy so you can basically this is the

00:51:16,190 --> 00:51:22,390
module you want to use for I mean your

00:51:19,039 --> 00:51:26,089
day one profiling just use see profile

00:51:22,390 --> 00:51:28,700
see profile this is an example how to

00:51:26,089 --> 00:51:31,160
use it you can use it from within your

00:51:28,700 --> 00:51:33,559
program or from the command line again

00:51:31,160 --> 00:51:36,349
like time it so i have this test full

00:51:33,559 --> 00:51:39,289
function that i want to profile i call

00:51:36,349 --> 00:51:41,210
import see profile see profile run to

00:51:39,289 --> 00:51:44,710
see profile i need to pass a string

00:51:41,210 --> 00:51:47,260
which is the statement to profile

00:51:44,710 --> 00:51:49,270
okay just the way to it's just a trick

00:51:47,260 --> 00:51:51,400
to delay evaluation of the function I

00:51:49,270 --> 00:51:53,920
need to tell the tale to see profile

00:51:51,400 --> 00:51:57,990
what to do so I pass a string it will

00:51:53,920 --> 00:52:00,820
exact it ok so the M will measure it or

00:51:57,990 --> 00:52:03,730
you can do it outside so if you have a a

00:52:00,820 --> 00:52:08,050
program that does the test foo you just

00:52:03,730 --> 00:52:11,589
can do Python dot M see profile photo by

00:52:08,050 --> 00:52:17,109
ok and it will measure how long it takes

00:52:11,589 --> 00:52:20,290
to food pie to complete and where the

00:52:17,109 --> 00:52:22,570
time is being spent and this is what you

00:52:20,290 --> 00:52:26,290
get from see profile which is a big

00:52:22,570 --> 00:52:28,330
nightmare of numbers at the first line

00:52:26,290 --> 00:52:31,030
show you shows you how many function

00:52:28,330 --> 00:52:34,020
calls there are because see profile is

00:52:31,030 --> 00:52:37,270
only and also providers mainly are

00:52:34,020 --> 00:52:39,910
focused on function calls so they don't

00:52:37,270 --> 00:52:42,099
get they don't give you an idea of what

00:52:39,910 --> 00:52:44,710
happens within a function so if you have

00:52:42,099 --> 00:52:47,320
a la a big function and you don't know

00:52:44,710 --> 00:52:49,540
if loop one loop to a loop-free is the

00:52:47,320 --> 00:52:51,339
one taking longer you need to split it

00:52:49,540 --> 00:52:53,200
in two different function before running

00:52:51,339 --> 00:52:54,609
see profile because see profile will

00:52:53,200 --> 00:52:59,349
give you information only at the

00:52:54,609 --> 00:53:08,980
function level ok so you say there are

00:52:59,349 --> 00:53:11,380
300 23 389 thousands in 2.6 seconds keep

00:53:08,980 --> 00:53:13,270
in mind that that time this is not the

00:53:11,380 --> 00:53:15,430
real running time is the running time

00:53:13,270 --> 00:53:18,339
within the profiler which is much slower

00:53:15,430 --> 00:53:19,960
than the real running time ok but it's

00:53:18,339 --> 00:53:22,990
still printing it because if you change

00:53:19,960 --> 00:53:24,550
your code you can still compare it ok

00:53:22,990 --> 00:53:26,410
because relic will be splitting it's

00:53:24,550 --> 00:53:28,510
correct then if you want to know exactly

00:53:26,410 --> 00:53:31,450
how long it takes you need to run it

00:53:28,510 --> 00:53:34,599
outside the profile ok then you get this

00:53:31,450 --> 00:53:38,920
table here for each function so I get

00:53:34,599 --> 00:53:44,040
this voronoi connected function here

00:53:38,920 --> 00:53:48,250
line 78 is in line of your code you know

00:53:44,040 --> 00:53:51,670
how many calls to the function how long

00:53:48,250 --> 00:53:55,390
does it take in total to run the call

00:53:51,670 --> 00:53:57,609
how long a single call took then there

00:53:55,390 --> 00:54:02,890
is the cumulative time and the Perkins

00:53:57,609 --> 00:54:05,319
we'll explain this but this table

00:54:02,890 --> 00:54:07,720
probably needs some sorting because

00:54:05,319 --> 00:54:09,849
obviously you get a big dump of all

00:54:07,720 --> 00:54:14,609
dysfunction but you want to sort them to

00:54:09,849 --> 00:54:18,489
focus on the main bottlenecks so Adam

00:54:14,609 --> 00:54:21,700
the the main two columns that you want

00:54:18,489 --> 00:54:26,410
to sort against our come come time which

00:54:21,700 --> 00:54:29,739
is cumulative time which is the time

00:54:26,410 --> 00:54:32,170
spent within a function without each

00:54:29,739 --> 00:54:34,630
Hildur okay with children I mean

00:54:32,170 --> 00:54:37,390
function being called within that

00:54:34,630 --> 00:54:39,789
function okay so you want to know how

00:54:37,390 --> 00:54:43,150
long it takes for the statement of that

00:54:39,789 --> 00:54:45,509
function to execute excluding function

00:54:43,150 --> 00:54:48,190
call method function codes okay and

00:54:45,509 --> 00:54:49,989
total timing instead is the time spent

00:54:48,190 --> 00:54:52,569
within a function including all the

00:54:49,989 --> 00:54:57,400
children's so until the function exits

00:54:52,569 --> 00:54:59,259
okay so to sort by internal tank by come

00:54:57,400 --> 00:55:03,190
time or thought time you have to use

00:54:59,259 --> 00:55:05,470
these dashes command line which is also

00:55:03,190 --> 00:55:07,630
sort keyword are commented to the sea

00:55:05,470 --> 00:55:12,089
profile run function if you are

00:55:07,630 --> 00:55:14,319
debugging within your code there is a I

00:55:12,089 --> 00:55:17,470
think there is a mistake in the slide

00:55:14,319 --> 00:55:19,839
actually because actually this is

00:55:17,470 --> 00:55:23,170
cumulative and perilous talk time I just

00:55:19,839 --> 00:55:24,940
sorry this is inverted so the column

00:55:23,170 --> 00:55:27,489
called come time is actually the

00:55:24,940 --> 00:55:29,769
cumulative time and the column called

00:55:27,489 --> 00:55:33,489
thought time is internal okay sorry for

00:55:29,769 --> 00:55:36,579
the mistake this is the problem here I

00:55:33,489 --> 00:55:39,549
got confused because there is a clash

00:55:36,579 --> 00:55:41,440
they should use the same word command

00:55:39,549 --> 00:55:45,849
line and column but they don't use the

00:55:41,440 --> 00:55:49,180
same one so for instance here and

00:55:45,849 --> 00:55:54,700
sorting by cumulative time which is

00:55:49,180 --> 00:55:57,420
function with all the children so the

00:55:54,700 --> 00:56:01,809
function that takes more time to execute

00:55:57,420 --> 00:56:03,940
cumulative it's the main okay because

00:56:01,809 --> 00:56:05,829
the main entry point of your program is

00:56:03,940 --> 00:56:07,029
the one that including all the children

00:56:05,829 --> 00:56:10,029
text most of the time because obviously

00:56:07,029 --> 00:56:10,599
it stays alive until your program exits

00:56:10,029 --> 00:56:13,930
okay

00:56:10,599 --> 00:56:17,440
and then you then there is probably the

00:56:13,930 --> 00:56:19,630
main is doing exit file and mmm but

00:56:17,440 --> 00:56:23,440
still if you find a function like this

00:56:19,630 --> 00:56:26,380
RP which was not expected to be the one

00:56:23,440 --> 00:56:28,089
to take most you can find him very high

00:56:26,380 --> 00:56:30,339
in Dakota you can have a look at this

00:56:28,089 --> 00:56:32,529
function because it's probably slower so

00:56:30,339 --> 00:56:34,450
when you sort by cumulative probably the

00:56:32,529 --> 00:56:37,690
first few entries are not very

00:56:34,450 --> 00:56:40,150
significant significant to you because

00:56:37,690 --> 00:56:42,279
are they like the main points main entry

00:56:40,150 --> 00:56:44,829
points of your code but then you just

00:56:42,279 --> 00:56:46,180
need to go down in the list you can

00:56:44,829 --> 00:56:51,239
probably find something interesting

00:56:46,180 --> 00:56:54,519
these fantasies invoked 100,000 times so

00:56:51,239 --> 00:56:56,920
okay cumulative time is almost I don't

00:56:54,519 --> 00:56:59,849
know ninety percent of execution time

00:56:56,920 --> 00:57:06,930
you see this is the total execution time

00:56:59,849 --> 00:57:06,930
1.8 1.5 58 only in this function okay

00:57:07,410 --> 00:57:14,410
internal sorting so here I'm checking

00:57:12,210 --> 00:57:18,039
how long it takes for function without

00:57:14,410 --> 00:57:20,079
children's and i found out for instance

00:57:18,039 --> 00:57:21,759
that in this example since it was an

00:57:20,079 --> 00:57:25,089
example of was generating lot of random

00:57:21,759 --> 00:57:28,029
data and the run range function is was

00:57:25,089 --> 00:57:29,769
the one using more time internally with

00:57:28,029 --> 00:57:31,599
them because it was using he was doing

00:57:29,769 --> 00:57:37,539
the algorithm for random numbers it was

00:57:31,599 --> 00:57:39,999
the longest okay so the idea is that

00:57:37,539 --> 00:57:42,219
when you profile the code you get a lots

00:57:39,999 --> 00:57:44,799
of numbers back and you want to analyze

00:57:42,219 --> 00:57:46,809
these numbers it's not enough just to

00:57:44,799 --> 00:57:49,420
have a quick glance because the numbers

00:57:46,809 --> 00:57:55,269
can confuse you they confuse anybody of

00:57:49,420 --> 00:57:59,079
course and so then yes that you probably

00:57:55,269 --> 00:58:01,839
want to do more profile sessions you can

00:57:59,079 --> 00:58:03,640
you suggest you to always try different

00:58:01,839 --> 00:58:06,339
profiles as well try see profile and not

00:58:03,640 --> 00:58:09,579
shots because see profile can instrument

00:58:06,339 --> 00:58:12,489
your code in a way that somehow create

00:58:09,579 --> 00:58:15,099
overheads in points that let that hides

00:58:12,489 --> 00:58:18,969
the real bottlenecks in your code so it

00:58:15,099 --> 00:58:21,219
can happen so try both see profiling the

00:58:18,969 --> 00:58:23,450
hotshots for statistic profiling try

00:58:21,219 --> 00:58:26,210
different data inputs of course this is

00:58:23,450 --> 00:58:28,340
profiling stuff if you do but only

00:58:26,210 --> 00:58:31,010
against one data set you probably fix

00:58:28,340 --> 00:58:32,810
everything in that data set but this is

00:58:31,010 --> 00:58:37,640
not what you want you want your program

00:58:32,810 --> 00:58:39,560
to work well on average okay also pay

00:58:37,640 --> 00:58:43,220
attention to hover in absolute numbers

00:58:39,560 --> 00:58:45,560
so numbers within see profile are always

00:58:43,220 --> 00:58:49,130
increased by overhead as i was saying

00:58:45,560 --> 00:58:51,650
before so if you just lose focus you are

00:58:49,130 --> 00:58:53,600
really profiling you're shoving off lot

00:58:51,650 --> 00:58:57,080
of time from your function and you go

00:58:53,600 --> 00:59:00,830
down to optimizing that code taking zero

00:58:57,080 --> 00:59:04,370
point zero point zero five seconds but

00:59:00,830 --> 00:59:07,130
it's 0.05 under profiling so may begin

00:59:04,370 --> 00:59:10,160
at real time it's really nothing to wash

00:59:07,130 --> 00:59:12,230
okay so make attention not to trust too

00:59:10,160 --> 00:59:15,200
much absolute numbers use profile to

00:59:12,230 --> 00:59:17,600
compare relative numbers okay the

00:59:15,200 --> 00:59:19,730
numbers relatively and time the timer

00:59:17,600 --> 00:59:22,580
it's a way to get back to reality

00:59:19,730 --> 00:59:25,010
because you just use them time to time

00:59:22,580 --> 00:59:27,590
print to standard output along it really

00:59:25,010 --> 00:59:29,750
takes for that code to execute and then

00:59:27,590 --> 00:59:32,900
you just you can scale back from your

00:59:29,750 --> 00:59:34,220
profile numbers that maybe you saved and

00:59:32,900 --> 00:59:39,410
get back to the artist the real

00:59:34,220 --> 00:59:41,150
execution time sometimes profiling is

00:59:39,410 --> 00:59:43,520
not enough you don't see anything Glalie

00:59:41,150 --> 00:59:48,440
you think that it cannot be optimistic

00:59:43,520 --> 00:59:50,540
further okay so what you can do is split

00:59:48,440 --> 00:59:52,450
into multiple functions which gives you

00:59:50,540 --> 00:59:55,670
more visibility as I was saying before

00:59:52,450 --> 00:59:58,280
or you can try a sea level profiling

00:59:55,670 --> 01:00:02,870
because maybe the hover it is not really

00:59:58,280 --> 01:00:05,330
your code but within your where your

01:00:02,870 --> 01:00:07,670
extensions I suggest to use Oh profile

01:00:05,330 --> 01:00:11,720
so just to use low profile on lyrics

01:00:07,670 --> 01:00:16,060
which is a really nice tool for instance

01:00:11,720 --> 01:00:19,160
a few years ago we found out about to

01:00:16,060 --> 01:00:22,910
upgrading from PI cute free to packet

01:00:19,160 --> 01:00:25,430
for using the very first early versions

01:00:22,910 --> 01:00:27,170
of packet for the application was slower

01:00:25,430 --> 01:00:31,210
we were debugging and looking with see

01:00:27,170 --> 01:00:33,890
profile everywhere and there was nothing

01:00:31,210 --> 01:00:36,690
showing up in the provides so we were

01:00:33,890 --> 01:00:39,089
wondering why it was getting slower and

01:00:36,690 --> 01:00:41,460
actually a regression in the binding

01:00:39,089 --> 01:00:44,579
generator hood the binding generation

01:00:41,460 --> 01:00:46,940
code was slower but since it was spread

01:00:44,579 --> 01:00:48,780
among all objects creations and

01:00:46,940 --> 01:00:50,670
destruction you just didn't see it

01:00:48,780 --> 01:00:53,849
because the numbers were higher than

01:00:50,670 --> 01:00:55,530
before but everywhere so you don't see

01:00:53,849 --> 01:00:57,839
them at the Python level okay every

01:00:55,530 --> 01:00:59,609
single object creation of the

01:00:57,839 --> 01:01:01,890
destruction was taking a little longer

01:00:59,609 --> 01:01:04,440
but totally the application was like

01:01:01,890 --> 01:01:05,790
three times lovers okay so that's the

01:01:04,440 --> 01:01:08,609
bomb a you didn't see anything in the

01:01:05,790 --> 01:01:11,430
profiling and you just run a profile one

01:01:08,609 --> 01:01:13,770
and you see that single function at the

01:01:11,430 --> 01:01:16,470
sea level using eighty percent of time

01:01:13,770 --> 01:01:18,180
okay and it's within the binding

01:01:16,470 --> 01:01:22,500
generator then you realize that there's

01:01:18,180 --> 01:01:24,329
something going on there okay i would

01:01:22,500 --> 01:01:26,460
say before don't lose focus okay so

01:01:24,329 --> 01:01:29,550
micro macro optimization don't pay back

01:01:26,460 --> 01:01:31,410
make attention not to lose focus and on

01:01:29,550 --> 01:01:33,630
to focus on details when providing it's

01:01:31,410 --> 01:01:36,930
really easy to lose focus because you

01:01:33,630 --> 01:01:39,960
see all these numbers you kind of your

01:01:36,930 --> 01:01:41,480
not know you're really you're following

01:01:39,960 --> 01:01:44,010
this number you think that this function

01:01:41,480 --> 01:01:45,839
because it's a bigger number that is one

01:01:44,010 --> 01:01:50,250
its most important but probably it's a

01:01:45,839 --> 01:01:56,000
wash your code okay you can use the

01:01:50,250 --> 01:01:58,680
piece that's module to analyze the data

01:01:56,000 --> 01:02:00,990
post-mortem let me say so basically you

01:01:58,680 --> 01:02:03,960
can just run something across your night

01:02:00,990 --> 01:02:07,020
save the data to disk see profile can

01:02:03,960 --> 01:02:09,270
save that of disk with the show or you

01:02:07,020 --> 01:02:11,460
can pass the output file and then once

01:02:09,270 --> 01:02:14,010
you have your data on disk you can load

01:02:11,460 --> 01:02:16,380
it back you can load with the p stats

01:02:14,010 --> 01:02:18,480
and do all the sort things okay so that

01:02:16,380 --> 01:02:21,000
you save your profiling data and analyze

01:02:18,480 --> 01:02:23,339
it so that you don't need to you know

01:02:21,000 --> 01:02:30,020
rerun it just to change the sorting or

01:02:23,339 --> 01:02:33,839
stuff like that if you want to have some

01:02:30,020 --> 01:02:36,690
just a quick act try to try speeding up

01:02:33,839 --> 01:02:39,569
something i suggest to use I offers or

01:02:36,690 --> 01:02:41,460
pi PI you can try nowadays you can try

01:02:39,569 --> 01:02:42,960
pi PI on your code if your code is like

01:02:41,460 --> 01:02:44,900
mathematical code or satellite data

01:02:42,960 --> 01:02:47,210
doesn't have many CA

01:02:44,900 --> 01:02:50,000
source affilliate that probably wife i

01:02:47,210 --> 01:02:54,320
could give you an exemption am sorry an

01:02:50,000 --> 01:02:56,710
improvement because of the just-in-time

01:02:54,320 --> 01:03:00,350
called psycho as well you can try and

01:02:56,710 --> 01:03:02,000
these are you know I wrote ten minutes

01:03:00,350 --> 01:03:04,100
but probably couple of hours you can try

01:03:02,000 --> 01:03:07,100
Popeye on get an idea if it works on

01:03:04,100 --> 01:03:09,230
your code you can also i also suggest to

01:03:07,100 --> 01:03:11,360
use site on which is very nice tool so

01:03:09,230 --> 01:03:13,310
if you have this module which is too

01:03:11,360 --> 01:03:15,590
slow in python because there's a lot of

01:03:13,310 --> 01:03:17,660
computational something you can try to

01:03:15,590 --> 01:03:20,270
convert it to site on it's really easy

01:03:17,660 --> 01:03:22,730
even if you never did it before just

01:03:20,270 --> 01:03:26,210
follow satin tutorial and its really

01:03:22,730 --> 01:03:28,250
really easy to use and can increase the

01:03:26,210 --> 01:03:29,960
speed of your code a lot it's basically

01:03:28,250 --> 01:03:31,700
if you don't know certain it's just like

01:03:29,960 --> 01:03:35,210
Python code you can think of it like

01:03:31,700 --> 01:03:38,570
Python code with the static type

01:03:35,210 --> 01:03:41,530
declarations so that it can kind of use

01:03:38,570 --> 01:03:44,150
this information to improve your code

01:03:41,530 --> 01:03:46,550
Saturn requires compilation so second

01:03:44,150 --> 01:03:50,120
code even if it looks like Python it's

01:03:46,550 --> 01:03:52,100
being compiled into native code so and

01:03:50,120 --> 01:03:54,530
it's really easy because every Python

01:03:52,100 --> 01:03:57,230
code is already good site encoders you

01:03:54,530 --> 01:03:59,300
can already compile it and it's it is

01:03:57,230 --> 01:04:01,300
already two percent faster than the cpat

01:03:59,300 --> 01:04:06,020
interpreter because it's basically

01:04:01,300 --> 01:04:08,510
expanding all the internal interpreted

01:04:06,020 --> 01:04:10,340
call without the interpreter loop so

01:04:08,510 --> 01:04:12,110
it's already faster immediately and then

01:04:10,340 --> 01:04:14,360
you just add one by one type

01:04:12,110 --> 01:04:17,690
declarations in your code see the

01:04:14,360 --> 01:04:21,740
generated C code a one by one you get

01:04:17,690 --> 01:04:24,020
speed this is easy to use sorry I'm

01:04:21,740 --> 01:04:26,650
missing a slide here I suggest also to

01:04:24,020 --> 01:04:31,310
have a look into a graphical tool called

01:04:26,650 --> 01:04:33,410
runs neck run runs necron is AC profile

01:04:31,310 --> 01:04:35,510
data analyzer it's basically the

01:04:33,410 --> 01:04:37,940
graphical version of this be starts

01:04:35,510 --> 01:04:40,910
module okay with all the bells and

01:04:37,940 --> 01:04:43,840
whistles of graphical profiling tools

01:04:40,910 --> 01:04:45,760
okay if you are into

01:04:43,840 --> 01:05:03,790
user interface tools you can try it on

01:04:45,760 --> 01:05:14,490
synchrony it's really nice okay yes okay

01:05:03,790 --> 01:05:17,890
perfect shed skin okay so basically

01:05:14,490 --> 01:05:20,200
what's your name sorry i er knows well

01:05:17,890 --> 01:05:22,390
okay so basically n is saying that this

01:05:20,200 --> 01:05:25,750
afternoon this afternoon in it's a

01:05:22,390 --> 01:05:28,180
margarita training yeah because early he

01:05:25,750 --> 01:05:30,820
has a very interesting training I think

01:05:28,180 --> 01:05:34,800
I gave you 10 10 in my community voting

01:05:30,820 --> 01:05:37,180
it's very interesting training about

01:05:34,800 --> 01:05:39,070
high-performance Piton optimization

01:05:37,180 --> 01:05:41,710
coding and it will show everything about

01:05:39,070 --> 01:05:45,760
this in detail so this can be a phizzer

01:05:41,710 --> 01:05:47,230
talk for you my teaser talk to ian is if

01:05:45,760 --> 01:05:49,630
you like this kind of stuff you want to

01:05:47,230 --> 01:05:52,060
see how to optimize your code use site

01:05:49,630 --> 01:05:55,000
on users shed skin which is another nice

01:05:52,060 --> 01:05:56,470
tool to compile your code just go to the

01:05:55,000 --> 01:06:03,190
great tea and training this afternoon

01:05:56,470 --> 01:06:06,040
okay thank you okay last last subject

01:06:03,190 --> 01:06:11,170
last topic for today how to debug c c++

01:06:06,040 --> 01:06:13,090
extensions there is a a nice answer to

01:06:11,170 --> 01:06:18,190
this question which is by using a

01:06:13,090 --> 01:06:20,500
debugger which is which is true but it's

01:06:18,190 --> 01:06:25,410
not that easy but it's not easy to do

01:06:20,500 --> 01:06:28,630
because it's not easy to do because

01:06:25,410 --> 01:06:30,280
especially on windows so right now i'm

01:06:28,630 --> 01:06:33,910
going to focus mainly on windows

01:06:30,280 --> 01:06:36,580
especially in windows there are lots of

01:06:33,910 --> 01:06:38,440
problems on getting things right to get

01:06:36,580 --> 01:06:41,650
to the point where you have your

01:06:38,440 --> 01:06:46,000
debugger set up with all the bad symbols

01:06:41,650 --> 01:06:49,240
in places with not weird external seg

01:06:46,000 --> 01:06:51,520
faults and stuff so we are trying to

01:06:49,240 --> 01:06:53,830
show you how to use al to do post-mortem

01:06:51,520 --> 01:06:56,380
the backing so after a sackful for

01:06:53,830 --> 01:06:57,490
instance or step a step debugging into

01:06:56,380 --> 01:07:00,000
your code which means

01:06:57,490 --> 01:07:02,470
so you cannot step by step the bug

01:07:00,000 --> 01:07:04,510
Python code I mean you can do that with

01:07:02,470 --> 01:07:06,280
the pass on the bugger but you can step

01:07:04,510 --> 01:07:09,490
by step I what I mean here is step by

01:07:06,280 --> 01:07:12,550
step in C C++ code in code extensions

01:07:09,490 --> 01:07:16,000
okay so the problem the main problems

01:07:12,550 --> 01:07:19,690
with Windows rely on is the basically

01:07:16,000 --> 01:07:22,390
tied to an old Microsoft choice to have

01:07:19,690 --> 01:07:25,930
different ad eyes four different

01:07:22,390 --> 01:07:28,690
runtimes libraries c runtime libraries

01:07:25,930 --> 01:07:30,820
so basically when you switch between for

01:07:28,690 --> 01:07:34,720
instance debug and release build in

01:07:30,820 --> 01:07:37,240
visual studio debugger release builds a

01:07:34,720 --> 01:07:39,610
different ABI if you don't know what

01:07:37,240 --> 01:07:42,970
basically bi means that you cannot mix

01:07:39,610 --> 01:07:44,980
match dynamic libraries with different

01:07:42,970 --> 01:07:47,230
ad is otherwise you get different

01:07:44,980 --> 01:07:51,100
crashes from the one that you were

01:07:47,230 --> 01:07:55,450
debugging which is not fun and so there

01:07:51,100 --> 01:07:57,940
is that if you basically you know you

01:07:55,450 --> 01:08:00,190
want to be back this module if you just

01:07:57,940 --> 01:08:03,070
switch to the bad mode for this for

01:08:00,190 --> 01:08:05,859
death only module that model will change

01:08:03,070 --> 01:08:08,380
its ABI so you cannot debug it together

01:08:05,859 --> 01:08:09,850
with the rest of your application which

01:08:08,380 --> 01:08:12,280
is a problem because you don't want to

01:08:09,850 --> 01:08:15,910
recompile all your word which means

01:08:12,280 --> 01:08:19,359
python itself all your third party

01:08:15,910 --> 01:08:24,430
extension we are using to debug just to

01:08:19,359 --> 01:08:26,740
debug your extension okay if you have a

01:08:24,430 --> 01:08:29,529
look to the syren time that I'm

01:08:26,740 --> 01:08:35,230
flybridge and the windows for instance

01:08:29,529 --> 01:08:37,630
this is the msvcr71.dll which is the

01:08:35,230 --> 01:08:43,630
debug sear on time for visual Studios

01:08:37,630 --> 01:08:49,089
7.1 which is dotnet 2003 which is 130

01:08:43,630 --> 01:08:51,850
okay if you for instance switch to a

01:08:49,089 --> 01:08:55,830
risk build you are linking against the

01:08:51,850 --> 01:08:59,770
71 without the dll which is incompatible

01:08:55,830 --> 01:09:02,470
okay so this can work only for all your

01:08:59,770 --> 01:09:07,299
libraries are using the same ms you see

01:09:02,470 --> 01:09:09,160
our library to check if this is true or

01:09:07,299 --> 01:09:10,750
not your application i suggest to use on

01:09:09,160 --> 01:09:13,720
windows this too

01:09:10,750 --> 01:09:16,810
which is dependency Walker it's a free

01:09:13,720 --> 01:09:19,900
as in beer to split you can download or

01:09:16,810 --> 01:09:22,180
you can use a free as in freedom tools

01:09:19,900 --> 01:09:25,330
in PI installers which is called being

01:09:22,180 --> 01:09:29,259
depend and a small tool on just command

01:09:25,330 --> 01:09:31,720
line the dependency Walker is graphical

01:09:29,259 --> 01:09:34,839
tool for instance i'm running this

01:09:31,720 --> 01:09:37,089
against an old version of by cute and it

01:09:34,839 --> 01:09:41,140
will list all the dll dependency you can

01:09:37,089 --> 01:09:45,520
see here that under cute dot PYD is

01:09:41,140 --> 01:09:49,509
depending on ma msvcr71.dll so it's a

01:09:45,520 --> 01:09:52,569
release mode compiled across visual

01:09:49,509 --> 01:09:55,180
studio.net to 2003 when you run python

01:09:52,569 --> 01:09:58,630
and in a single process you want just

01:09:55,180 --> 01:10:01,420
one instance of this family of dll okay

01:09:58,630 --> 01:10:03,280
so if you have my cute using this one

01:10:01,420 --> 01:10:08,080
and then you recompile your third party

01:10:03,280 --> 01:10:09,430
tool with the msvcr80.dll because you

01:10:08,080 --> 01:10:12,610
are using a newer videos to the version

01:10:09,430 --> 01:10:14,740
you are in trouble okay so you need to

01:10:12,610 --> 01:10:17,410
use the same module against all the

01:10:14,740 --> 01:10:19,090
extensions which means that it is not

01:10:17,410 --> 01:10:21,100
easy to just compile one a station the

01:10:19,090 --> 01:10:24,310
back you need to pay attention of how

01:10:21,100 --> 01:10:28,270
your comp I'll meet this table will show

01:10:24,310 --> 01:10:30,940
you the correct msvc our version for

01:10:28,270 --> 01:10:34,180
Python version since Python depends on

01:10:30,940 --> 01:10:37,930
mm msvc are you basically needs to

01:10:34,180 --> 01:10:42,670
always use the same CRT library that the

01:10:37,930 --> 01:10:45,010
Python interpreter is using okay so if

01:10:42,670 --> 01:10:46,900
you are using two point six plus newer

01:10:45,010 --> 01:10:49,960
versions which is probably most of you

01:10:46,900 --> 01:10:52,210
are using you need to use this video

01:10:49,960 --> 01:10:53,680
studio version which means all your

01:10:52,210 --> 01:10:57,700
third party extension need to be

01:10:53,680 --> 01:11:00,580
compiled with this one okay this problem

01:10:57,700 --> 01:11:04,150
is being solved in Python free but on

01:11:00,580 --> 01:11:07,060
3.2 because they are they are trying to

01:11:04,150 --> 01:11:11,170
introduce a fixed set the API for

01:11:07,060 --> 01:11:13,390
extensions but since it I mean something

01:11:11,170 --> 01:11:16,510
that will happen in the future in real

01:11:13,390 --> 01:11:19,210
world I don't I will not explain this

01:11:16,510 --> 01:11:21,190
right now but right now the problem is

01:11:19,210 --> 01:11:23,820
this you always need to use the same 30

01:11:21,190 --> 01:11:27,010
library this is

01:11:23,820 --> 01:11:30,850
advertise advertise man there is a free

01:11:27,010 --> 01:11:33,580
min ji min GW build for Python

01:11:30,850 --> 01:11:36,690
developers endeavors open source web

01:11:33,580 --> 01:11:40,630
site basically it's a way to quickly

01:11:36,690 --> 01:11:42,580
recompile Python extensions okay without

01:11:40,630 --> 01:11:46,180
using visual studio but using the

01:11:42,580 --> 01:11:48,730
correct ms VCR it's basically just a

01:11:46,180 --> 01:11:50,380
standard GCC builder with some with

01:11:48,730 --> 01:11:53,080
advanced installer that will set up

01:11:50,380 --> 01:11:54,700
everything correctly you just tell you

01:11:53,080 --> 01:11:56,650
just an which patent version you are

01:11:54,700 --> 01:12:00,910
using and then you can use GCC to

01:11:56,650 --> 01:12:04,350
compile your extensions ok because

01:12:00,910 --> 01:12:07,000
standard me means uwb to use this one

01:12:04,350 --> 01:12:09,460
msvcrt.dll so they are really compatible

01:12:07,000 --> 01:12:12,250
with python 2.3 if you just download

01:12:09,460 --> 01:12:14,710
today min GW and try to compile an

01:12:12,250 --> 01:12:18,330
extension for 2.6 it will not work there

01:12:14,710 --> 01:12:18,330
are lots of tutorial on the webs on this

01:12:18,840 --> 01:12:26,550
ok took to get the bad symbols which is

01:12:22,480 --> 01:12:31,180
what you need to do debugging usually

01:12:26,550 --> 01:12:34,000
you need to compile in debug mode with

01:12:31,180 --> 01:12:37,990
visual studio but with the same theory

01:12:34,000 --> 01:12:39,610
of release version because either you

01:12:37,990 --> 01:12:41,260
recompile everything a we don't want

01:12:39,610 --> 01:12:43,150
this we want to use the standard pattern

01:12:41,260 --> 01:12:46,110
interpreter so the standard pattern

01:12:43,150 --> 01:12:51,610
interpreter is using the release CRT

01:12:46,110 --> 01:12:53,320
version so you want your your extension

01:12:51,610 --> 01:12:56,170
to use their release the CRT to be

01:12:53,320 --> 01:12:58,420
compatible but with the bug symbols this

01:12:56,170 --> 01:12:59,740
is actually easy once you know it once

01:12:58,420 --> 01:13:01,870
you know this is your problem it's very

01:12:59,740 --> 01:13:05,020
easy because Visual Studio you just need

01:13:01,870 --> 01:13:08,290
to go through the menus and find where

01:13:05,020 --> 01:13:10,870
the CRT is being defined and ended in

01:13:08,290 --> 01:13:14,560
the debug build you just need to switch

01:13:10,870 --> 01:13:16,180
to runtime a multi-threaded release ok

01:13:14,560 --> 01:13:18,490
so you basically you probably have this

01:13:16,180 --> 01:13:20,860
fancy project made with visual studio

01:13:18,490 --> 01:13:23,770
you just make sure that the debug build

01:13:20,860 --> 01:13:27,220
the back target uses is using

01:13:23,770 --> 01:13:29,470
multilateralism for runtime this is the

01:13:27,220 --> 01:13:31,960
command line you want to use which is /

01:13:29,470 --> 01:13:35,830
md which is multi-threaded release with

01:13:31,960 --> 01:13:36,010
this with this command lines which you

01:13:35,830 --> 01:13:37,920
are

01:13:36,010 --> 01:13:40,120
tell me these are suited to use this one

01:13:37,920 --> 01:13:43,420
the right version of visual studio of

01:13:40,120 --> 01:13:46,750
course and then you want zi which is the

01:13:43,420 --> 01:13:49,630
buggy symbols okay the back builds

01:13:46,750 --> 01:13:51,610
usually have this different switch which

01:13:49,630 --> 01:13:56,530
means use the debug version which we

01:13:51,610 --> 01:13:59,050
don't want to use if you don't have the

01:13:56,530 --> 01:14:02,800
fancy with the studio project you just

01:13:59,050 --> 01:14:06,280
using these two T's in the students you

01:14:02,800 --> 01:14:08,860
cannot use dash dash debugger for two

01:14:06,280 --> 01:14:10,750
reasons that says debug was supposed to

01:14:08,860 --> 01:14:13,230
help you debugging your extension but

01:14:10,750 --> 01:14:16,030
it's not because this delta baggage

01:14:13,230 --> 01:14:18,880
changes Adi 2 times in 2 different

01:14:16,030 --> 01:14:20,980
incompatible ways for the rest of the

01:14:18,880 --> 01:14:23,050
pattern interpreter one it's because

01:14:20,980 --> 01:14:24,550
using the debug fear team for compiling

01:14:23,050 --> 01:14:26,770
the extension which is totally useless

01:14:24,550 --> 01:14:29,110
unless you have a Python being debug

01:14:26,770 --> 01:14:32,080
build and everything in the world and

01:14:29,110 --> 01:14:34,900
the second is a dash Leslie back is

01:14:32,080 --> 01:14:38,770
activating this pi debug mode which is

01:14:34,900 --> 01:14:41,620
an internal debug mode made by Python C

01:14:38,770 --> 01:14:45,100
Python core developers for helping them

01:14:41,620 --> 01:14:46,690
develop Python and dash dash the back in

01:14:45,100 --> 01:14:48,460
the students is activating this mode

01:14:46,690 --> 01:14:50,680
which again is incompatible with

01:14:48,460 --> 01:14:53,830
everything else so unless you compile

01:14:50,680 --> 01:14:56,650
everything in PI debug mode you cannot

01:14:53,830 --> 01:14:58,890
mix match extensions okay so dash dash

01:14:56,650 --> 01:15:02,050
the bug in the students is probably

01:14:58,890 --> 01:15:05,470
useless to most Python developers in the

01:15:02,050 --> 01:15:08,560
world what you want to debug these

01:15:05,470 --> 01:15:10,660
students in the bag in essence re-air to

01:15:08,560 --> 01:15:13,420
compile a an extension in debug mode

01:15:10,660 --> 01:15:16,060
just for having the symbols when you get

01:15:13,420 --> 01:15:19,500
a crash you want to add these lines to

01:15:16,060 --> 01:15:22,240
these to tease you basically need to

01:15:19,500 --> 01:15:25,360
manually flip the correct switch on the

01:15:22,240 --> 01:15:29,290
common line the same for GCC okay UCC

01:15:25,360 --> 01:15:31,780
doesn't have this problem but the same

01:15:29,290 --> 01:15:34,690
you need to do a solid UCC I mean under

01:15:31,780 --> 01:15:39,010
Linux you can just specify the correct

01:15:34,690 --> 01:15:41,380
form online in this way you get the your

01:15:39,010 --> 01:15:43,660
third party extension compiled with the

01:15:41,380 --> 01:15:45,550
bug symbols okay but in a way that is

01:15:43,660 --> 01:15:47,500
fully compatible with the rest of your

01:15:45,550 --> 01:15:49,720
pattern environment you just have the

01:15:47,500 --> 01:15:51,400
body symbols which is what

01:15:49,720 --> 01:15:53,640
probably want the a you can disable

01:15:51,400 --> 01:15:59,440
optimization so your code is easier to

01:15:53,640 --> 01:16:01,600
inspect within at the back there ok we

01:15:59,440 --> 01:16:06,940
should probably eventually contribute

01:16:01,600 --> 01:16:09,370
something to these students for this if

01:16:06,940 --> 01:16:11,710
the bug symbols in your dll are not

01:16:09,370 --> 01:16:16,480
enough a you probably want debug symbols

01:16:11,710 --> 01:16:20,080
in Python itself sometimes in Python 3.2

01:16:16,480 --> 01:16:21,970
they are now shipping the bug symbols on

01:16:20,080 --> 01:16:24,400
Windows a separate download which is

01:16:21,970 --> 01:16:26,170
very nice but if you're using older

01:16:24,400 --> 01:16:29,290
Python version you brought you need to

01:16:26,170 --> 01:16:31,870
recompile pattern yourself which is not

01:16:29,290 --> 01:16:34,660
hard because it's complicated to come to

01:16:31,870 --> 01:16:36,970
compile the whole Python distribution

01:16:34,660 --> 01:16:39,520
but just the Python library it's

01:16:36,970 --> 01:16:44,980
actually very easy to recompile you just

01:16:39,520 --> 01:16:46,690
need to modify the standard debug target

01:16:44,980 --> 01:16:50,350
as I was saying before to switch the

01:16:46,690 --> 01:16:52,270
seer runtime 30 but it's very easy to

01:16:50,350 --> 01:16:57,820
recompile that you have debug symbols

01:16:52,270 --> 01:16:59,710
for Python and C Python as well when you

01:16:57,820 --> 01:17:03,540
are at this point so you have the debug

01:16:59,710 --> 01:17:03,540
symbols and you probably switched off

01:17:03,570 --> 01:17:08,320
optimization for the parts of code that

01:17:05,710 --> 01:17:10,630
you want to inspect then if you get a

01:17:08,320 --> 01:17:12,640
cig fold you just press debug and you

01:17:10,630 --> 01:17:14,830
get the nice stack trace with all the

01:17:12,640 --> 01:17:21,100
symbols which is what you were trying to

01:17:14,830 --> 01:17:23,110
achieve two hours ago and am another

01:17:21,100 --> 01:17:25,240
nice feature of visual studio in here is

01:17:23,110 --> 01:17:29,230
that once if you just get a sec phone

01:17:25,240 --> 01:17:31,990
you press debug jump into the bugger if

01:17:29,230 --> 01:17:33,730
you save the generated workspace you

01:17:31,990 --> 01:17:35,260
just save it you can then modify the

01:17:33,730 --> 01:17:37,360
command line and rerun the whole

01:17:35,260 --> 01:17:41,530
application within a debugger this is

01:17:37,360 --> 01:17:44,290
the easier way to do it so you restart

01:17:41,530 --> 01:17:48,630
with the five you put breakpoints okay

01:17:44,290 --> 01:17:51,280
in your C C++ code and you can debug

01:17:48,630 --> 01:17:55,020
only notes the situation is much better

01:17:51,280 --> 01:17:58,150
because there is no this ad is ertms and

01:17:55,020 --> 01:18:00,070
also because the most distribution ship

01:17:58,150 --> 01:18:01,660
debug symbols for third-party libraries

01:18:00,070 --> 01:18:03,100
so basically if you are using I don't

01:18:01,660 --> 01:18:06,100
know Python

01:18:03,100 --> 01:18:10,510
image library item pill you just install

01:18:06,100 --> 01:18:12,760
the peel peel the bugger deb package and

01:18:10,510 --> 01:18:16,720
you get to debug symbols so when you get

01:18:12,760 --> 01:18:19,030
it crush a dump you just run it to gdb

01:18:16,720 --> 01:18:21,520
and you get to all the debug symbols ok

01:18:19,030 --> 01:18:24,460
you don't need to recompile anything you

01:18:21,520 --> 01:18:26,350
just need to avoid the pie debug mode ok

01:18:24,460 --> 01:18:29,230
so dash dash debug is still don't work

01:18:26,350 --> 01:18:33,630
on linux because despite the bag mode is

01:18:29,230 --> 01:18:36,520
incompatible you still need to specify

01:18:33,630 --> 01:18:38,530
debugging command-line documents to GCC

01:18:36,520 --> 01:18:46,560
within these to this reading set up dot

01:18:38,530 --> 01:18:50,350
pie ok and then a nice candy in python

01:18:46,560 --> 01:18:54,570
3.3 or two or three point three there is

01:18:50,350 --> 01:18:54,570
this new model made by Victor's thinner

01:18:55,050 --> 01:19:02,080
available it's called fault handler

01:18:57,540 --> 01:19:04,150
fault handler is a nice model that you

01:19:02,080 --> 01:19:09,160
can just import and enable the way

01:19:04,150 --> 01:19:11,800
importantly gravity works and then when

01:19:09,160 --> 01:19:14,380
a segmentation fault is generated which

01:19:11,800 --> 01:19:16,690
you can easily generate with this very

01:19:14,380 --> 01:19:18,100
handy function in full tandler in case

01:19:16,690 --> 01:19:22,510
you want your application crash at

01:19:18,100 --> 01:19:24,760
random points usual you just don't get a

01:19:22,510 --> 01:19:27,160
segmentation fault but you get a python

01:19:24,760 --> 01:19:29,470
trace back as well on standard which is

01:19:27,160 --> 01:19:33,130
really nice because you get a trace back

01:19:29,470 --> 01:19:34,810
at the point of the seg fault which is

01:19:33,130 --> 01:19:36,430
interesting because at least give you an

01:19:34,810 --> 01:19:38,260
idea even without setting up the

01:19:36,430 --> 01:19:39,940
environment the bugger never you you get

01:19:38,260 --> 01:19:42,130
an idea of where your application is

01:19:39,940 --> 01:19:44,200
crashing probably you already have an

01:19:42,130 --> 01:19:46,000
idea maybe not maybe yes I don't know

01:19:44,200 --> 01:19:48,520
but still the traceback will confirm

01:19:46,000 --> 01:19:51,400
exactly at which point to your invoking

01:19:48,520 --> 01:19:59,710
see called it crashes ok for hundreds

01:19:51,400 --> 01:20:01,450
very nice sorry add the default actually

01:19:59,710 --> 01:20:03,310
I don't know we should speak with Victor

01:20:01,450 --> 01:20:05,410
about this because I don't know if there

01:20:03,310 --> 01:20:09,550
are some side effects on enabling I

01:20:05,410 --> 01:20:12,490
actually I I don't recall the discussion

01:20:09,550 --> 01:20:14,350
on the Piton their mailing list but

01:20:12,490 --> 01:20:16,090
actually i will ask this because it's

01:20:14,350 --> 01:20:19,990
interesting

01:20:16,090 --> 01:20:23,680
another thing you can do is that on UNIX

01:20:19,990 --> 01:20:26,020
or Linux you can register fault handler

01:20:23,680 --> 01:20:28,900
on a signal so for instance iam I am

01:20:26,020 --> 01:20:31,960
registering fault handler on the sig

01:20:28,900 --> 01:20:34,180
user senior sig user one signal and I'm

01:20:31,960 --> 01:20:39,670
saying that I want the trace back for

01:20:34,180 --> 01:20:41,890
all threads for all threads and if i

01:20:39,670 --> 01:20:44,080
send i just need to send the sick users

01:20:41,890 --> 01:20:46,030
inner to my process and when i send it

01:20:44,080 --> 01:20:49,150
it will display this day trace back on

01:20:46,030 --> 01:20:51,730
the standard output ok so at any time

01:20:49,150 --> 01:20:54,250
the process is running I send him and I

01:20:51,730 --> 01:20:57,990
send it a cig user signal and we'll dump

01:20:54,250 --> 01:21:00,340
the trash bag for all threads ok and

01:20:57,990 --> 01:21:02,470
another thing you can do is dump trance

01:21:00,340 --> 01:21:05,260
mix later and you say i want all the

01:21:02,470 --> 01:21:07,930
trash bags for all threads means in 10

01:21:05,260 --> 01:21:10,180
seconds from now this is also

01:21:07,930 --> 01:21:14,440
interesting function patent free free

01:21:10,180 --> 01:21:16,240
but it's available on pi PI today for

01:21:14,440 --> 01:21:22,530
two point X as well so you can download

01:21:16,240 --> 01:21:22,530
it today and start using it ok ok

01:21:33,489 --> 01:21:42,080
we have very little time for questions

01:21:36,610 --> 01:21:44,120
unfortunately hello you showed the trick

01:21:42,080 --> 01:21:47,450
with wheatgrass and with the car back

01:21:44,120 --> 01:21:50,500
yeah do you know why didn't they do it

01:21:47,450 --> 01:21:56,239
this way from the beginning with wee pal

01:21:50,500 --> 01:21:58,610
why do they do what because that has its

01:21:56,239 --> 01:22:02,060
problems right there at the underhanded

01:21:58,610 --> 01:22:04,160
sorry under under del yes okay but you

01:22:02,060 --> 01:22:06,260
can emulate it with we graph without

01:22:04,160 --> 01:22:08,600
those promenade it's not fully correct

01:22:06,260 --> 01:22:11,030
you can emulate it but your code will

01:22:08,600 --> 01:22:13,520
not work in exactly the same way because

01:22:11,030 --> 01:22:16,430
you don't have a live reference to self

01:22:13,520 --> 01:22:19,460
available you see the light reference to

01:22:16,430 --> 01:22:23,000
self is the tricky part in them because

01:22:19,460 --> 01:22:26,000
dell is the finalizer which is really

01:22:23,000 --> 01:22:28,250
funny because you are the object is

01:22:26,000 --> 01:22:31,760
going to die but it will give you a life

01:22:28,250 --> 01:22:34,430
reference to self so for instance with

01:22:31,760 --> 01:22:37,310
these live reference you can keep the

01:22:34,430 --> 01:22:40,280
object alive from then you just append

01:22:37,310 --> 01:22:42,950
it to a global list and the object stays

01:22:40,280 --> 01:22:46,310
live even if it's being finalized so

01:22:42,950 --> 01:22:49,280
that's the way the witnessing in in

01:22:46,310 --> 01:22:52,070
there so you cannot do exactly the same

01:22:49,280 --> 01:22:55,340
with week ref because we crack we never

01:22:52,070 --> 01:22:57,050
have a live reference a live reference

01:22:55,340 --> 01:22:59,930
to sell otherwise you have the nested

01:22:57,050 --> 01:23:03,020
loop so the trick to use default

01:22:59,930 --> 01:23:04,520
argument is to pass what you need to

01:23:03,020 --> 01:23:08,290
they call back function but not the

01:23:04,520 --> 01:23:08,290
fully live reference to self

01:23:14,510 --> 01:23:21,660
you showed quite some ways about how to

01:23:17,520 --> 01:23:24,480
see all objects and etc but my major

01:23:21,660 --> 01:23:27,780
problem with debugging this stuff is you

01:23:24,480 --> 01:23:30,510
see a lot a lot of trees but not a one

01:23:27,780 --> 01:23:34,020
you search for so is there some special

01:23:30,510 --> 01:23:37,350
procedure or trick how to get faster to

01:23:34,020 --> 01:23:40,830
the point to find the real leak in this

01:23:37,350 --> 01:23:43,530
big forest of lots of trees I actually

01:23:40,830 --> 01:23:46,880
don't know any I actually don't know any

01:23:43,530 --> 01:23:54,600
solution for this problem there is a

01:23:46,880 --> 01:23:58,470
tool called my Elia I guess does anybody

01:23:54,600 --> 01:24:05,250
knows my earlier by my earlier I think

01:23:58,470 --> 01:24:07,730
it's mal I a a something like that it's

01:24:05,250 --> 01:24:12,030
on launch pad it's being developed by

01:24:07,730 --> 01:24:18,380
Barry war so for the bug linger was the

01:24:12,030 --> 01:24:21,270
SCM name for Ubuntu bizarre right it's a

01:24:18,380 --> 01:24:24,270
debugging tool which is being developed

01:24:21,270 --> 01:24:26,520
to help them debug bizarre which has

01:24:24,270 --> 01:24:29,070
lots of memory leaks problems so they

01:24:26,520 --> 01:24:31,970
have this big forest that's true there

01:24:29,070 --> 01:24:34,290
are lots of memory leaks in pasta and

01:24:31,970 --> 01:24:36,410
basically and there's nothing wrong with

01:24:34,290 --> 01:24:38,850
that because they are I mean short

01:24:36,410 --> 01:24:40,650
comments you run even if it leaks one

01:24:38,850 --> 01:24:43,470
gigabytes of memory when it's done

01:24:40,650 --> 01:24:45,840
everything is collected the problem is

01:24:43,470 --> 01:24:48,780
if it takes five hours and then the

01:24:45,840 --> 01:24:52,160
memory go into trash mode there that's

01:24:48,780 --> 01:24:55,640
the point when they need to debug it and

01:24:52,160 --> 01:24:58,620
and the bizarre developers are debugging

01:24:55,640 --> 01:25:00,960
dismally I think it is if you search it

01:24:58,620 --> 01:25:03,570
on launch pad there are also a few blog

01:25:00,960 --> 01:25:05,850
blog posts that show you how to use it

01:25:03,570 --> 01:25:09,000
so it's not really much more to this is

01:25:05,850 --> 01:25:14,230
why not riding on a computer can you

01:25:09,000 --> 01:25:19,020
ready yes you found it a lot fun

01:25:14,230 --> 01:25:19,020
echo ya Leah

01:25:33,740 --> 01:25:50,660
by a quarry cloud India alpha echo this

01:25:37,550 --> 01:25:56,330
one let me not Emily 5ma alpha echo okay

01:25:50,660 --> 01:26:00,290
this one and if luck is Magic google

01:25:56,330 --> 01:26:03,710
search blog post you will find if you to

01:26:00,290 --> 01:26:07,370
target so happy I am never used it so I

01:26:03,710 --> 01:26:09,980
just mentioning it I remember they are

01:26:07,370 --> 01:26:13,430
quite some such tools you should help

01:26:09,980 --> 01:26:17,570
you but I tried some of them some don't

01:26:13,430 --> 01:26:20,180
even compile some trying to help you but

01:26:17,570 --> 01:26:23,810
you must build finding or not exactly

01:26:20,180 --> 01:26:25,730
you know you see I often want to figure

01:26:23,810 --> 01:26:27,350
out what is going on in my process for

01:26:25,730 --> 01:26:33,200
my process is consuming huge amounts of

01:26:27,350 --> 01:26:36,620
memory or gigabytes which is better the

01:26:33,200 --> 01:26:38,210
scanner is a notification icon object

01:26:36,620 --> 01:26:40,520
will turn to the right spot on to spend

01:26:38,210 --> 01:26:44,420
on education so it's probably trying to

01:26:40,520 --> 01:26:49,360
target in progress are you trying ok

01:26:44,420 --> 01:26:52,930
I've never been touched but you can try

01:26:49,360 --> 01:26:52,930
new more questions

01:26:56,560 --> 01:27:06,889
um today idea may yet make okay some

01:27:04,639 --> 01:27:12,949
questions about the surface about

01:27:06,889 --> 01:27:15,050
windows by why don't we use these PB

01:27:12,949 --> 01:27:17,210
files for attendance you can just

01:27:15,050 --> 01:27:19,760
compile people release boat with

01:27:17,210 --> 01:27:23,000
attached debug information so you can

01:27:19,760 --> 01:27:27,650
borrow release the open you can also

01:27:23,000 --> 01:27:30,260
make some maps of vit d and see if he

01:27:27,650 --> 01:27:34,280
files if you make sure that your

01:27:30,260 --> 01:27:37,940
extension does not pass ma-fuckers you

01:27:34,280 --> 01:27:40,900
have a paper spawn and fries previous

01:27:37,940 --> 01:27:43,429
another so yeah good work your shade day

01:27:40,900 --> 01:27:47,989
if you make sure that you don't bust

01:27:43,429 --> 01:27:51,560
buffers or references to see objects for

01:27:47,989 --> 01:27:53,150
c15 objects to other extensions yes you

01:27:51,560 --> 01:27:58,159
can probably you can broadly nice match

01:27:53,150 --> 01:28:00,080
but the point is that in my opinion it's

01:27:58,159 --> 01:28:02,179
not easy to make sure that if you wrote

01:28:00,080 --> 01:28:03,770
the third part extension yes it's easy

01:28:02,179 --> 01:28:05,870
because you got it but if you're

01:28:03,770 --> 01:28:08,840
debugging some other extension is not

01:28:05,870 --> 01:28:11,170
it's hard to scan for this case it's not

01:28:08,840 --> 01:28:14,330
much food and tells you yes you can

01:28:11,170 --> 01:28:16,520
mixmash safe txt enter so the one good

01:28:14,330 --> 01:28:19,639
rule is never mix match because that

01:28:16,520 --> 01:28:21,830
always works yes pdb Simon symbols is

01:28:19,639 --> 01:28:24,889
correct you can use them but if you need

01:28:21,830 --> 01:28:26,719
to step back to step by step the buggy

01:28:24,889 --> 01:28:29,480
in a release code it's not always very

01:28:26,719 --> 01:28:32,360
good so what I was shown is how to also

01:28:29,480 --> 01:28:34,219
disable go to the bottom of do so

01:28:32,360 --> 01:28:38,810
without the possession but without

01:28:34,219 --> 01:28:41,420
changes okay but you are correct you can

01:28:38,810 --> 01:28:43,429
actually hit smack sure GRT need to make

01:28:41,420 --> 01:28:48,840
sure that the future point use our

01:28:43,429 --> 01:28:52,980
nation this awesome d2 edition or

01:28:48,840 --> 01:28:55,530
33 our senses on snake phrase for

01:28:52,980 --> 01:28:58,020
Calgary qualifiers on signal or

01:28:55,530 --> 01:29:00,570
something present working windows who so

01:28:58,020 --> 01:29:03,720
you get profiled and basically sometimes

01:29:00,570 --> 01:29:05,790
I go to their knowing the videos were

01:29:03,720 --> 01:29:08,610
concerning date it signal doesn't work

01:29:05,790 --> 01:29:10,680
no sleeping of course off for number of

01:29:08,610 --> 01:29:13,380
support working windows full-time there

01:29:10,680 --> 01:29:18,960
yeah Jenna it works on Windows this one

01:29:13,380 --> 01:29:23,660
there is no more so mean discipline see

01:29:18,960 --> 01:29:28,170
that is any song yes did you have a use

01:29:23,660 --> 01:29:30,770
things like all crying for to see are so

01:29:28,170 --> 01:29:35,220
to depart on save settings and stop by

01:29:30,770 --> 01:29:39,690
reference leads they're actually all

01:29:35,220 --> 01:29:44,250
right using or brine to impress stuff

01:29:39,690 --> 01:29:46,260
like that now I yeah actually the

01:29:44,250 --> 01:29:48,240
suggestion if you drive on drive to the

01:29:46,260 --> 01:29:51,930
banker this kind of memory leaks and

01:29:48,240 --> 01:29:53,700
forward right there is if you want to

01:29:51,930 --> 01:29:56,250
walk right on patent extension you can

01:29:53,700 --> 01:29:58,710
do that it's very nice cool there is

01:29:56,250 --> 01:30:02,220
just one problem you just you need to

01:29:58,710 --> 01:30:06,330
find in a specific type of suppression

01:30:02,220 --> 01:30:10,010
fire suppression vice our definition for

01:30:06,330 --> 01:30:12,780
by Greg that they seem to skip a few

01:30:10,010 --> 01:30:15,090
false positives in the sea pipe

01:30:12,780 --> 01:30:17,640
interpreter because if you just run my

01:30:15,090 --> 01:30:21,180
grandpa he looks like it's leaking like

01:30:17,640 --> 01:30:25,080
hell everything but it's just it's just

01:30:21,180 --> 01:30:27,690
the false positives in poor the way they

01:30:25,080 --> 01:30:32,360
Michael object collectibles so you need

01:30:27,690 --> 01:30:35,280
to get this bad rap icon suppress

01:30:32,360 --> 01:30:38,160
suppression fire circle ended which is

01:30:35,280 --> 01:30:39,309
actually part of the package source okay

01:30:38,160 --> 01:30:41,619
but if you

01:30:39,309 --> 01:30:44,139
google it you will find a lot that you

01:30:41,619 --> 01:30:46,959
when you run background you specify this

01:30:44,139 --> 01:30:49,300
file and then you remove all those four

01:30:46,959 --> 01:30:52,839
whole squad is and you see the real no

01:30:49,300 --> 01:30:57,869
means there's no more time for questions

01:30:52,839 --> 01:30:57,869
it's copy great client remember together

01:31:02,559 --> 01:31:04,619

YouTube URL: https://www.youtube.com/watch?v=6jD34p8PokU


