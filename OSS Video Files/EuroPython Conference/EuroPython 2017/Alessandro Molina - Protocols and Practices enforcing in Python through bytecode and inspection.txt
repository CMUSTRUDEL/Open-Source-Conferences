Title: Alessandro Molina - Protocols and Practices enforcing in Python through bytecode and inspection
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Protocols and Practices enforcing in Python through bytecode and inspection
[EuroPython 2017 - Talk - 2017-07-10 - PyCharm Room]
[Rimini, Italy]

Python is an interpreted development language with powerful introspection features, up to allow accesso to the byte code itself to see what the virtual machine is going to do. Reaching down to byte code or low level inspection is usually a very uncommon need and it's usually only involved in debugging or understanding the interpreter internals, but it can be a powerful tool to check that third parties code that (or the code we will write ourselves in the future) sticks to some protocols or best practices that are supposed to be in place.

Most of the needs for this checks are usually performed at execution time or through techniques like metaclasses and monkeypatching of third parties code, but in some cases it would be possible to inadvertently skip those checks or work them around, while verifying the resulting byte code allows us to check what's really going to be executed and enforce the required constraints.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:08,950 --> 00:00:16,040
okay first of all I probably a little

00:00:13,790 --> 00:00:17,990
longer so if we have no time left on

00:00:16,040 --> 00:00:20,539
question and we'd be outside feel free

00:00:17,990 --> 00:00:23,240
to ask anything does the Hulk is quite

00:00:20,539 --> 00:00:24,859
long I try to make it as short as

00:00:23,240 --> 00:00:26,990
possible but there are many things that

00:00:24,859 --> 00:00:29,359
I would like to say and some of them are

00:00:26,990 --> 00:00:32,449
long and complex so I didn't have enough

00:00:29,359 --> 00:00:34,879
time to explain them in full so I

00:00:32,449 --> 00:00:37,750
recognize that something might not be

00:00:34,879 --> 00:00:43,340
clear so feel free to ask me anything

00:00:37,750 --> 00:00:45,829
the reason first of all why I'm here and

00:00:43,340 --> 00:00:48,440
what's the reason for this told I'm

00:00:45,829 --> 00:00:50,590
currently maintaining a few Python

00:00:48,440 --> 00:00:54,440
libraries and framers in web development

00:00:50,590 --> 00:00:56,270
world for Python the biggest project is

00:00:54,440 --> 00:00:58,340
for sure the trouble year's project

00:00:56,270 --> 00:01:01,070
which for any of you that doesn't know

00:00:58,340 --> 00:01:05,860
it is a framework that is comparable to

00:01:01,070 --> 00:01:09,290
Django insights and admin as multiple

00:01:05,860 --> 00:01:12,670
optically database versus layer support

00:01:09,290 --> 00:01:15,200
for both MongoDB and sequel alchemy is

00:01:12,670 --> 00:01:17,570
everything you might expect for fools by

00:01:15,200 --> 00:01:20,950
framework and there's been around for

00:01:17,570 --> 00:01:25,939
like seven or eight years so it's a very

00:01:20,950 --> 00:01:27,920
big project with a lot of other big

00:01:25,939 --> 00:01:30,380
projects they rely on it so that it

00:01:27,920 --> 00:01:32,990
takes a lot of my time and then a few

00:01:30,380 --> 00:01:35,659
other minor projects like vigor which is

00:01:32,990 --> 00:01:38,810
a framework for caching and sessions on

00:01:35,659 --> 00:01:40,729
web and there are other side projects

00:01:38,810 --> 00:01:42,799
like duck Pi which is a JavaScript

00:01:40,729 --> 00:01:44,810
interpreter for Python you can use it

00:01:42,799 --> 00:01:47,090
for example to run reacts the

00:01:44,810 --> 00:01:50,240
server-side on Python or to around

00:01:47,090 --> 00:01:51,950
bubble jes transpile evam Python without

00:01:50,240 --> 00:01:54,710
the need for node or things like that

00:01:51,950 --> 00:01:56,420
and B port which is a file storage

00:01:54,710 --> 00:01:59,299
framework so you can see that there are

00:01:56,420 --> 00:02:01,430
a lot of projects on maintaining and the

00:01:59,299 --> 00:02:03,590
reason for digital came from the

00:02:01,430 --> 00:02:07,399
experience I had as a development of

00:02:03,590 --> 00:02:10,040
libraries and frameworks so whenever you

00:02:07,399 --> 00:02:12,140
create something like a library if you

00:02:10,040 --> 00:02:14,319
are lucky enough it will be used and

00:02:12,140 --> 00:02:16,980
then the project the real problem star

00:02:14,319 --> 00:02:20,340
the fact is that most of

00:02:16,980 --> 00:02:22,950
these pieces in which my being dependent

00:02:20,340 --> 00:02:26,190
start to get integrated into bigger

00:02:22,950 --> 00:02:29,580
software or other other solutions that

00:02:26,190 --> 00:02:33,030
involvement and it's not always easy to

00:02:29,580 --> 00:02:36,450
find a way to make them interact with

00:02:33,030 --> 00:02:39,540
other piece of software and communicate

00:02:36,450 --> 00:02:41,879
the design and intent of what you world

00:02:39,540 --> 00:02:44,700
I mean you might expect that your

00:02:41,879 --> 00:02:47,599
library does something in a very

00:02:44,700 --> 00:02:51,319
specific way as you do not expect people

00:02:47,599 --> 00:02:54,599
using eating so some ways you didn't

00:02:51,319 --> 00:02:57,450
foresee or things like that and you try

00:02:54,599 --> 00:02:59,670
to do your best to enforce those ways

00:02:57,450 --> 00:03:01,620
and communicate them and things like

00:02:59,670 --> 00:03:05,459
that but it's not always easy

00:03:01,620 --> 00:03:11,060
so sometimes we need to revert to more

00:03:05,459 --> 00:03:13,799
stricter enforcing two to apply them so

00:03:11,060 --> 00:03:15,750
this is the most common situation I

00:03:13,799 --> 00:03:18,180
usually end up at the library whenever

00:03:15,750 --> 00:03:21,870
people at the library developer whenever

00:03:18,180 --> 00:03:25,200
people open an issue nearly half of the

00:03:21,870 --> 00:03:27,120
times is because they use the library in

00:03:25,200 --> 00:03:29,430
a way that I didn't predict or first

00:03:27,120 --> 00:03:31,590
year they didn't mean at all to be used

00:03:29,430 --> 00:03:33,930
like that for example the most

00:03:31,590 --> 00:03:36,299
interesting thing was recently an issue

00:03:33,930 --> 00:03:39,060
was opened to me for d-pod which is a

00:03:36,299 --> 00:03:41,099
file storage framework and as a deep

00:03:39,060 --> 00:03:42,930
integration with sequel alchemy so

00:03:41,099 --> 00:03:45,239
whenever you for example commit your

00:03:42,930 --> 00:03:47,340
transaction or rollback your transaction

00:03:45,239 --> 00:03:50,340
or things like that your files get

00:03:47,340 --> 00:03:52,590
deleted or fails for we all according to

00:03:50,340 --> 00:03:55,019
this state of the transaction so for

00:03:52,590 --> 00:03:58,260
example if a user uploaded his avatar

00:03:55,019 --> 00:04:00,989
and you are transactional fails because

00:03:58,260 --> 00:04:02,970
I don't know any kind of error the other

00:04:00,989 --> 00:04:05,190
thought the user is not left there on

00:04:02,970 --> 00:04:07,620
these corners for your wherever you

00:04:05,190 --> 00:04:10,069
uploaded it it's also rolled back with

00:04:07,620 --> 00:04:12,829
the transaction so you don't live around

00:04:10,069 --> 00:04:15,750
broken files or things like that and

00:04:12,829 --> 00:04:17,789
there it was a guy that opened an issue

00:04:15,750 --> 00:04:20,250
about the fact that it didn't work well

00:04:17,789 --> 00:04:22,109
with django RM i said yeah of course

00:04:20,250 --> 00:04:25,050
it's supposed to work with sequel alkie

00:04:22,109 --> 00:04:27,570
it's the first word in the documentation

00:04:25,050 --> 00:04:29,669
and things like that and then I started

00:04:27,570 --> 00:04:30,510
actually implementing support for

00:04:29,669 --> 00:04:33,450
January

00:04:30,510 --> 00:04:40,100
because people actually wanted to use it

00:04:33,450 --> 00:04:43,410
on that storage system I believe so

00:04:40,100 --> 00:04:45,900
you try to cover whatever it might be

00:04:43,410 --> 00:04:48,780
possible miss users of the library or

00:04:45,900 --> 00:04:51,180
the framework or decoder world and you

00:04:48,780 --> 00:04:53,550
try to do that in documentation you show

00:04:51,180 --> 00:04:55,760
people the way they are supposed to use

00:04:53,550 --> 00:04:59,190
the library but it's nearly impossible

00:04:55,760 --> 00:05:02,670
to show them all the way they should not

00:04:59,190 --> 00:05:05,220
use the library you if you try like I

00:05:02,670 --> 00:05:07,290
could write these words we have sequel

00:05:05,220 --> 00:05:09,330
alchemy and MongoDB which is what I did

00:05:07,290 --> 00:05:11,250
and then I could learn more one more

00:05:09,330 --> 00:05:14,760
paragraph to the documentation so it

00:05:11,250 --> 00:05:16,860
doesn't work we've joined RM and then

00:05:14,760 --> 00:05:18,810
probably someone will try to use it with

00:05:16,860 --> 00:05:21,150
 engine and I would have to say

00:05:18,810 --> 00:05:23,160
doesn't work with ng only mean for

00:05:21,150 --> 00:05:25,350
a longer to be and things like that

00:05:23,160 --> 00:05:26,970
you'll end up trying to list all the

00:05:25,350 --> 00:05:29,490
cases that hold the things that people

00:05:26,970 --> 00:05:34,710
shouldn't do which is impossible because

00:05:29,490 --> 00:05:36,630
our your life will say unlimited so you

00:05:34,710 --> 00:05:39,720
quickly discover that your definition of

00:05:36,630 --> 00:05:42,120
what reasonable is a way that your

00:05:39,720 --> 00:05:44,700
library or framework should be used it's

00:05:42,120 --> 00:05:49,530
not easy to guess a common definition

00:05:44,700 --> 00:05:52,110
that anyone can share so you don't know

00:05:49,530 --> 00:05:54,330
what to do anymore I mean I already did

00:05:52,110 --> 00:05:57,480
my best I told you how to use the

00:05:54,330 --> 00:06:00,270
library I told you how you should apply

00:05:57,480 --> 00:06:02,610
it in your project I brought examples I

00:06:00,270 --> 00:06:04,920
brought documentation I even provided

00:06:02,610 --> 00:06:07,050
some sample projects and things like

00:06:04,920 --> 00:06:10,200
that but there is always something you

00:06:07,050 --> 00:06:12,870
didn't foresee or didn't predict so

00:06:10,200 --> 00:06:15,860
there is actually a branch of software

00:06:12,870 --> 00:06:18,630
development that comes into our wealth

00:06:15,860 --> 00:06:23,490
regarding those kind of things and it is

00:06:18,630 --> 00:06:26,160
a I will say a kind of science but it's

00:06:23,490 --> 00:06:28,410
called the fancy programming it's really

00:06:26,160 --> 00:06:31,200
commonly a really big project like if

00:06:28,410 --> 00:06:33,750
you need to write the software to drive

00:06:31,200 --> 00:06:36,000
the space shuttle you will apply a lot

00:06:33,750 --> 00:06:39,660
of things that come from the fancy

00:06:36,000 --> 00:06:41,430
programmer like must roof of their

00:06:39,660 --> 00:06:44,729
requirements or

00:06:41,430 --> 00:06:47,250
like double fallback systems for every

00:06:44,729 --> 00:06:51,150
single software piece you wrote or

00:06:47,250 --> 00:06:53,729
things like that so the purpose of

00:06:51,150 --> 00:06:56,009
defensive programming is to defend you

00:06:53,729 --> 00:06:59,060
from the impossible because it we let

00:06:56,009 --> 00:07:02,070
them and the more formal definition

00:06:59,060 --> 00:07:04,590
which I took from Wikipedia so it's

00:07:02,070 --> 00:07:06,030
probably nowadays is probably the

00:07:04,590 --> 00:07:08,850
standard definition is what your

00:07:06,030 --> 00:07:11,880
readable Wikipedia is that it's a form

00:07:08,850 --> 00:07:14,180
of defensive design so a way you design

00:07:11,880 --> 00:07:18,600
your systems not actually the way you

00:07:14,180 --> 00:07:22,139
write it on Co level to ensure that it

00:07:18,600 --> 00:07:25,229
continues to function under any possible

00:07:22,139 --> 00:07:28,770
sink response or if it doesn't work

00:07:25,229 --> 00:07:31,380
anymore at least it should notify in a

00:07:28,770 --> 00:07:33,690
clearer way what's going on instead of

00:07:31,380 --> 00:07:36,840
just providing random error which is

00:07:33,690 --> 00:07:38,789
usually what happens in the very few

00:07:36,840 --> 00:07:40,889
things on the fancy programming which we

00:07:38,789 --> 00:07:43,050
actually take for granted we have used

00:07:40,889 --> 00:07:46,349
to them from object-oriented programming

00:07:43,050 --> 00:07:50,130
from aspect-oriented programming from

00:07:46,349 --> 00:07:51,840
many other paradigms like you have

00:07:50,130 --> 00:07:54,360
interfaces in object-oriented

00:07:51,840 --> 00:07:56,789
programming you have like environment C

00:07:54,360 --> 00:07:59,340
of piping functional programming so

00:07:56,789 --> 00:08:01,260
those things actually go under the

00:07:59,340 --> 00:08:03,240
umbrella of defensive programming says

00:08:01,260 --> 00:08:07,889
they are a way to prevent you from doing

00:08:03,240 --> 00:08:09,780
the wrong thing so like if you are sub

00:08:07,889 --> 00:08:11,909
classing an object it does those things

00:08:09,780 --> 00:08:15,539
you are expected to do those things or

00:08:11,909 --> 00:08:17,789
if you are working with a specific type

00:08:15,539 --> 00:08:19,560
you are not expected to read it the

00:08:17,789 --> 00:08:21,479
object itself which might have sound

00:08:19,560 --> 00:08:24,300
effects but you are expected to create a

00:08:21,479 --> 00:08:27,539
new one and all those things are usually

00:08:24,300 --> 00:08:30,870
and go usually under the umbrella of

00:08:27,539 --> 00:08:32,849
defensive programming and you will

00:08:30,870 --> 00:08:34,469
notice that all the things that are

00:08:32,849 --> 00:08:37,830
involved in defensive programming

00:08:34,469 --> 00:08:40,860
usually resemble protocols and

00:08:37,830 --> 00:08:43,050
expectations so declare how you want to

00:08:40,860 --> 00:08:45,480
communicate with other piece of the

00:08:43,050 --> 00:08:47,520
system and what's your expectation in

00:08:45,480 --> 00:08:49,680
the way the other piece of this system

00:08:47,520 --> 00:08:52,620
will work what they are going to when

00:08:49,680 --> 00:08:55,160
things like that for example if you are

00:08:52,620 --> 00:08:57,110
a file storage framework you'll support

00:08:55,160 --> 00:09:01,029
store your files aware you're not

00:08:57,110 --> 00:09:05,000
actually supposed to provide to weather

00:09:01,029 --> 00:09:07,310
storage in nowhere which is actually one

00:09:05,000 --> 00:09:09,560
of the feature that first got requested

00:09:07,310 --> 00:09:12,620
on people for example people started

00:09:09,560 --> 00:09:15,290
asking for a way to write really fast

00:09:12,620 --> 00:09:17,449
test unit that involve the integration

00:09:15,290 --> 00:09:19,490
with the port and say hey why we can

00:09:17,449 --> 00:09:21,230
just make people do nothing when you

00:09:19,490 --> 00:09:22,639
store something so then my test is

00:09:21,230 --> 00:09:25,040
passed instead of having to actually

00:09:22,639 --> 00:09:27,680
write the disk on the right define on

00:09:25,040 --> 00:09:33,709
disk or upload the file to s3 or things

00:09:27,680 --> 00:09:36,139
like that so whenever you whenever you

00:09:33,709 --> 00:09:40,490
face the condition in which the software

00:09:36,139 --> 00:09:43,220
refuses to respect your expectations you

00:09:40,490 --> 00:09:45,259
should provide a clear alert to the user

00:09:43,220 --> 00:09:47,750
that he is doing something wrong because

00:09:45,259 --> 00:09:49,610
you cannot rely on the fact that they

00:09:47,750 --> 00:09:55,129
read the documentation or things like

00:09:49,610 --> 00:09:57,050
that and I would say that has the

00:09:55,129 --> 00:09:59,060
software they uses your library has

00:09:57,050 --> 00:10:01,490
expectation out of your library

00:09:59,060 --> 00:10:04,220
I expect that your web framework renders

00:10:01,490 --> 00:10:05,959
my page I expect that your file storage

00:10:04,220 --> 00:10:08,360
framework saves my files

00:10:05,959 --> 00:10:11,779
I expect that whatever you are doing

00:10:08,360 --> 00:10:14,120
does what is expected to do so your

00:10:11,779 --> 00:10:16,610
library should have expectation too so

00:10:14,120 --> 00:10:19,970
you should have expectation in regard of

00:10:16,610 --> 00:10:21,740
how the user is going to use it so try

00:10:19,970 --> 00:10:24,889
to enforce them because it's one of the

00:10:21,740 --> 00:10:26,959
major pain points when you start getting

00:10:24,889 --> 00:10:32,540
involved in many different projects that

00:10:26,959 --> 00:10:35,509
do many different things there are

00:10:32,540 --> 00:10:38,000
actually part of the protocol enforcing

00:10:35,509 --> 00:10:40,339
which we are used to in our daily work

00:10:38,000 --> 00:10:42,290
so whenever you write a piece of

00:10:40,339 --> 00:10:43,550
software it doesn't need to be in the

00:10:42,290 --> 00:10:46,550
library or a framework

00:10:43,550 --> 00:10:48,829
it can even be just something you use in

00:10:46,550 --> 00:10:51,589
a single project by baby in four

00:10:48,829 --> 00:10:54,139
different places of this project at that

00:10:51,589 --> 00:10:56,209
point you will have to provide the clear

00:10:54,139 --> 00:10:59,420
expectation and you usually do that

00:10:56,209 --> 00:11:02,300
through interfaces to signatures of your

00:10:59,420 --> 00:11:04,250
method types assertions and all those

00:11:02,300 --> 00:11:06,889
kind of things actually way to expect a

00:11:04,250 --> 00:11:08,460
protocol a protocol in the sense of how

00:11:06,889 --> 00:11:10,410
your object or you

00:11:08,460 --> 00:11:14,970
were library interact with other

00:11:10,410 --> 00:11:17,960
libraries and object and you actually

00:11:14,970 --> 00:11:22,080
need to provide expectations for each

00:11:17,960 --> 00:11:24,840
single joint that your library will have

00:11:22,080 --> 00:11:27,330
with other people code so any single

00:11:24,840 --> 00:11:30,030
piece where your library can interact

00:11:27,330 --> 00:11:32,520
with something else should enforce those

00:11:30,030 --> 00:11:35,790
expectations and I'm not talking about

00:11:32,520 --> 00:11:37,530
the most obvious one like my methods if

00:11:35,790 --> 00:11:40,110
you call it you're supposed to pass a

00:11:37,530 --> 00:11:42,180
number that that's something we take for

00:11:40,110 --> 00:11:44,460
granted it's obvious that if you expect

00:11:42,180 --> 00:11:45,930
a number you should check that the thing

00:11:44,460 --> 00:11:48,360
that you are receiving at least

00:11:45,930 --> 00:11:50,220
resembles a number or can be converted

00:11:48,360 --> 00:11:53,100
to a number if you want to apply duck

00:11:50,220 --> 00:11:55,950
typing or whatever you want to work with

00:11:53,100 --> 00:11:59,460
but I'm also talking with side effect

00:11:55,950 --> 00:12:01,950
like if you saw the previous doctrine I

00:11:59,460 --> 00:12:05,190
mean there was a clear problem outside

00:12:01,950 --> 00:12:07,710
affecting import I do import and I

00:12:05,190 --> 00:12:09,660
expected what I find is this module C is

00:12:07,710 --> 00:12:11,310
actually the model that are imported but

00:12:09,660 --> 00:12:14,940
there is nothing that it's enforcing

00:12:11,310 --> 00:12:17,430
that for me it's just a side effect of

00:12:14,940 --> 00:12:20,040
how the import system works and it's not

00:12:17,430 --> 00:12:22,260
actually supposed to work the way for

00:12:20,040 --> 00:12:24,780
real something else might have changed

00:12:22,260 --> 00:12:29,310
the content of SIS import as a side

00:12:24,780 --> 00:12:32,070
effect of import so those are all kinds

00:12:29,310 --> 00:12:35,780
of expectation that your library should

00:12:32,070 --> 00:12:40,230
enforce in the context where it runs in

00:12:35,780 --> 00:12:42,750
and the fact is the context is pretty

00:12:40,230 --> 00:12:47,940
hard to define in something like a

00:12:42,750 --> 00:12:50,550
dynamic language and in this case we

00:12:47,940 --> 00:12:52,590
actually have a few tools that can help

00:12:50,550 --> 00:12:55,650
us in many ways because the fact that

00:12:52,590 --> 00:12:57,960
it's a dynamic language is the side

00:12:55,650 --> 00:13:01,530
effects like it's not always easy to

00:12:57,960 --> 00:13:04,050
specify the protocols your classes or

00:13:01,530 --> 00:13:05,970
objects need to enforce now we are

00:13:04,050 --> 00:13:09,770
starting to see improvements they try to

00:13:05,970 --> 00:13:13,020
do abstract base classes they try to do

00:13:09,770 --> 00:13:15,180
tightening in more recent versions and

00:13:13,020 --> 00:13:18,240
things like that but usually Python has

00:13:15,180 --> 00:13:22,000
a legacy of being a PI slash language

00:13:18,240 --> 00:13:25,270
mostly and that the fact that is so

00:13:22,000 --> 00:13:28,090
powerful and flexible in managing cordon

00:13:25,270 --> 00:13:30,880
ties also means that it is powerful and

00:13:28,090 --> 00:13:34,060
flexible tools to inspect what's going

00:13:30,880 --> 00:13:36,700
on because python itself has to do that

00:13:34,060 --> 00:13:40,450
to be able to treat your objects as they

00:13:36,700 --> 00:13:43,050
are something it has to have powerful

00:13:40,450 --> 00:13:45,760
tools to check what that something is so

00:13:43,050 --> 00:13:47,680
Python provides a powerful fashion

00:13:45,760 --> 00:13:51,250
because the language itself needs them

00:13:47,680 --> 00:13:53,260
for real on a daily basis if you provide

00:13:51,250 --> 00:13:55,660
something that is respected to work on a

00:13:53,260 --> 00:13:58,570
sequence you're in that's probably a

00:13:55,660 --> 00:14:01,810
case every one of you ever faced you

00:13:58,570 --> 00:14:03,970
know that it's really hard to check what

00:14:01,810 --> 00:14:06,130
the sequence is for pike we have a

00:14:03,970 --> 00:14:09,520
definition in collections we have enough

00:14:06,130 --> 00:14:12,910
base class that says I'm a sequence but

00:14:09,520 --> 00:14:15,520
actually for the general idea for what a

00:14:12,910 --> 00:14:19,840
sequence a is many types that do not

00:14:15,520 --> 00:14:22,600
expect do not respect that that here are

00:14:19,840 --> 00:14:25,630
key that interface are actually

00:14:22,600 --> 00:14:28,420
collections so it's not uncommon in

00:14:25,630 --> 00:14:32,130
Python to see complex checking of what

00:14:28,420 --> 00:14:37,690
kind of methods or behaviors the file X

00:14:32,130 --> 00:14:40,990
exposes or things like that and we are

00:14:37,690 --> 00:14:42,880
really used to in inspection in the

00:14:40,990 --> 00:14:45,070
context of debugging whenever your

00:14:42,880 --> 00:14:48,580
software crashes you expect to be able

00:14:45,070 --> 00:14:50,440
to go into the code NC was where the

00:14:48,580 --> 00:14:52,720
local variable what was the previous

00:14:50,440 --> 00:14:54,760
frame and go back and forth across this

00:14:52,720 --> 00:14:57,520
call stack and things like that all

00:14:54,760 --> 00:15:00,160
things that Python does because it's a

00:14:57,520 --> 00:15:03,130
dynamic language if you ever work with a

00:15:00,160 --> 00:15:06,520
compiled language like C or things like

00:15:03,130 --> 00:15:08,980
that it's not as easy I would say it's

00:15:06,520 --> 00:15:11,250
still possible somehow if you have an

00:15:08,980 --> 00:15:14,350
understanding about the internals of the

00:15:11,250 --> 00:15:16,480
operative system and computer work but

00:15:14,350 --> 00:15:20,560
it's not as easy to move across those

00:15:16,480 --> 00:15:23,050
types of calls and things like that at

00:15:20,560 --> 00:15:25,030
least you must know for example when

00:15:23,050 --> 00:15:27,190
which place of the memory you're

00:15:25,030 --> 00:15:30,130
vulnerables will be or things like that

00:15:27,190 --> 00:15:32,410
well in Python I can just get the frames

00:15:30,130 --> 00:15:35,050
and from the frames the local variables

00:15:32,410 --> 00:15:39,160
and DVDs what made my function

00:15:35,050 --> 00:15:43,000
trash and one thing that your library

00:15:39,160 --> 00:15:46,120
can do is leverage all these tools to

00:15:43,000 --> 00:15:48,640
inspect the surroundings in which it is

00:15:46,120 --> 00:15:53,110
running to check that the expectations

00:15:48,640 --> 00:15:55,269
are met so I will try to show you some

00:15:53,110 --> 00:15:58,209
example to clarify the concept because

00:15:55,269 --> 00:16:03,640
so far it was a really critical

00:15:58,209 --> 00:16:05,709
talk so I told you about protocols and

00:16:03,640 --> 00:16:07,209
forcing of expectation defensive

00:16:05,709 --> 00:16:10,060
programming and things like that but in

00:16:07,209 --> 00:16:13,329
practice what does it mean how can we

00:16:10,060 --> 00:16:15,640
apply some of these things to Python and

00:16:13,329 --> 00:16:18,130
I try to resemble some of the most

00:16:15,640 --> 00:16:20,470
common NT patterns that we see often in

00:16:18,130 --> 00:16:22,870
Python they are some of them are really

00:16:20,470 --> 00:16:24,959
widespread even though there are many

00:16:22,870 --> 00:16:28,480
side effects and things like that and

00:16:24,959 --> 00:16:31,680
one of the most common side s in Python

00:16:28,480 --> 00:16:35,019
which is related to the previous import

00:16:31,680 --> 00:16:37,630
example is side effects that import time

00:16:35,019 --> 00:16:40,660
we also rely on the fact that whenever

00:16:37,630 --> 00:16:43,959
Python imports the model it runs the

00:16:40,660 --> 00:16:46,600
code of that model so we tend to see

00:16:43,959 --> 00:16:50,310
like classes declaration and things like

00:16:46,600 --> 00:16:52,750
that not actually a declaration actually

00:16:50,310 --> 00:16:55,870
implementations of those that actually

00:16:52,750 --> 00:17:00,370
when they get executed create the class

00:16:55,870 --> 00:17:03,640
and this is common for example in the

00:17:00,370 --> 00:17:10,839
context of registering something like I

00:17:03,640 --> 00:17:14,199
saw people commonly used like decorators

00:17:10,839 --> 00:17:16,390
to register a global object just to

00:17:14,199 --> 00:17:19,569
register an object in a global registry

00:17:16,390 --> 00:17:21,459
okay like this this might be a really

00:17:19,569 --> 00:17:23,760
simple example of something like that

00:17:21,459 --> 00:17:26,800
it's really common in the context of

00:17:23,760 --> 00:17:27,040
event handlers and hooks and things like

00:17:26,800 --> 00:17:29,350
that

00:17:27,040 --> 00:17:32,410
it's really common to see this pattern

00:17:29,350 --> 00:17:34,330
which involves on having a some kind of

00:17:32,410 --> 00:17:37,360
registry which in this case is just

00:17:34,330 --> 00:17:40,150
addiction and some kind of decorator

00:17:37,360 --> 00:17:43,720
that the class or which even your

00:17:40,150 --> 00:17:46,660
function should be called so for example

00:17:43,720 --> 00:17:48,400
my decorator will register the function

00:17:46,660 --> 00:17:51,370
that you are providing

00:17:48,400 --> 00:17:54,400
as a handler for the event that was

00:17:51,370 --> 00:17:57,490
specified by the decorator and then

00:17:54,400 --> 00:17:59,530
whenever I want to fire an event I just

00:17:57,490 --> 00:18:02,950
look into the all the register

00:17:59,530 --> 00:18:05,380
attendants and call them like in this

00:18:02,950 --> 00:18:09,000
case it just goes through all the event

00:18:05,380 --> 00:18:11,470
angles for that event and constant and

00:18:09,000 --> 00:18:15,760
this usually ends up being something

00:18:11,470 --> 00:18:19,530
like this so on event some event than my

00:18:15,760 --> 00:18:25,330
Easterner and then I fire the event okay

00:18:19,530 --> 00:18:28,120
and there is one complex problem in this

00:18:25,330 --> 00:18:30,520
example which is involved in the most

00:18:28,120 --> 00:18:32,470
common cases it was in the case where

00:18:30,520 --> 00:18:34,390
your model gets imported and you

00:18:32,470 --> 00:18:37,450
registered the event at the global

00:18:34,390 --> 00:18:39,730
namespace but what does happen if I do

00:18:37,450 --> 00:18:43,030
something like this I do have a factor

00:18:39,730 --> 00:18:45,760
in it which is it I will say yup pretty

00:18:43,030 --> 00:18:48,250
widespread pattern in many cases and

00:18:45,760 --> 00:18:51,310
that factoring method creates something

00:18:48,250 --> 00:18:54,430
that has an event tender and here's part

00:18:51,310 --> 00:18:59,290
of our problem if I fire the event I

00:18:54,430 --> 00:19:02,920
will see getting fired if my factory was

00:18:59,290 --> 00:19:06,460
havin cold before the event was filed or

00:19:02,920 --> 00:19:09,100
it will never be fired if my factory was

00:19:06,460 --> 00:19:11,320
called after the event was fired because

00:19:09,100 --> 00:19:14,260
we will never register the event tender

00:19:11,320 --> 00:19:17,440
because my factory never was called so

00:19:14,260 --> 00:19:19,810
the decorator never was applied and so

00:19:17,440 --> 00:19:22,660
my function never was called when I

00:19:19,810 --> 00:19:26,110
fired the event and this is okay if you

00:19:22,660 --> 00:19:28,840
think about it it's fine it's the way

00:19:26,110 --> 00:19:31,780
you you know the language works you say

00:19:28,840 --> 00:19:34,600
hey you never created s so how could you

00:19:31,780 --> 00:19:38,530
register it as an event and though it's

00:19:34,600 --> 00:19:41,350
pretty obvious at that point but from

00:19:38,530 --> 00:19:44,440
the expectation of a new user of Python

00:19:41,350 --> 00:19:46,240
it might be more obvious that I can

00:19:44,440 --> 00:19:47,920
register at that function as an event

00:19:46,240 --> 00:19:50,800
handler and I expect it to be called

00:19:47,920 --> 00:19:54,310
because it's in my coat so this is an

00:19:50,800 --> 00:19:57,280
arrow that you might face if users use

00:19:54,310 --> 00:20:00,550
your globally register narender am I

00:19:57,280 --> 00:20:02,030
like opening issue on github and say hey

00:20:00,550 --> 00:20:03,920
I did this and year

00:20:02,030 --> 00:20:05,780
and I never wore a you will try yeah of

00:20:03,920 --> 00:20:08,720
course because you never actually

00:20:05,780 --> 00:20:12,620
created it but it would be better if we

00:20:08,720 --> 00:20:14,930
could find that this is an error and we

00:20:12,620 --> 00:20:17,900
could tell the user you should not be

00:20:14,930 --> 00:20:21,170
doing something like that and it is

00:20:17,900 --> 00:20:22,790
actually a condition we can accept so we

00:20:21,170 --> 00:20:26,020
can actually implement something the

00:20:22,790 --> 00:20:29,600
check for that so we can implement a

00:20:26,020 --> 00:20:33,890
register decorator that the least traps

00:20:29,600 --> 00:20:36,170
the context where it was used so in this

00:20:33,890 --> 00:20:38,900
example that we have the same exact

00:20:36,170 --> 00:20:41,240
register decorator but we are using the

00:20:38,900 --> 00:20:43,940
inspection features of Python to check

00:20:41,240 --> 00:20:46,600
that the current frame was actually the

00:20:43,940 --> 00:20:49,220
parent of the current frame were the

00:20:46,600 --> 00:20:53,060
decorator where the hidden Canada was

00:20:49,220 --> 00:20:55,640
registered is that model level so okay

00:20:53,060 --> 00:20:58,250
this might not be the clearest way to do

00:20:55,640 --> 00:21:01,070
it it might not be the most elegant way

00:20:58,250 --> 00:21:03,710
but it wasn't it was short enough to

00:21:01,070 --> 00:21:06,320
stay in a single life and that what I

00:21:03,710 --> 00:21:09,020
wanted to show you is mostly the idea

00:21:06,320 --> 00:21:11,570
that my event handler should be in

00:21:09,020 --> 00:21:14,330
charge of checking that it was used in

00:21:11,570 --> 00:21:16,850
the correct way so in this case is in

00:21:14,330 --> 00:21:19,760
charge of checking that the place where

00:21:16,850 --> 00:21:21,920
the event handler was registered is not

00:21:19,760 --> 00:21:24,500
a transient scope so it's not something

00:21:21,920 --> 00:21:28,310
that might or might not exist it's

00:21:24,500 --> 00:21:30,920
something that will exist okay at least

00:21:28,310 --> 00:21:33,920
in the sense that you usually import all

00:21:30,920 --> 00:21:36,170
the modules as the first thing of course

00:21:33,920 --> 00:21:39,380
if we break again if you use lazy

00:21:36,170 --> 00:21:41,690
imports but they have all set of side

00:21:39,380 --> 00:21:44,240
effects so you usually don't want to use

00:21:41,690 --> 00:21:48,230
them so in the most common case that it

00:21:44,240 --> 00:21:50,600
will work and in this case I trap the

00:21:48,230 --> 00:21:52,760
fact that the user registered the event

00:21:50,600 --> 00:21:54,910
handler in the scope that is not global

00:21:52,760 --> 00:21:57,410
so it might be there or might not

00:21:54,910 --> 00:22:00,500
because the only scope that we know it's

00:21:57,410 --> 00:22:04,160
always there it the global one action so

00:22:00,500 --> 00:22:07,520
and I provide an error so that whenever

00:22:04,160 --> 00:22:10,370
the user tries to use my decorator at

00:22:07,520 --> 00:22:12,080
least it gets an error details here you

00:22:10,370 --> 00:22:14,630
are registering the event enter into a

00:22:12,080 --> 00:22:15,559
transient scope maybe I can add one more

00:22:14,630 --> 00:22:18,200
option and say

00:22:15,559 --> 00:22:18,860
a yes really do that because I know what

00:22:18,200 --> 00:22:21,110
I'm doing

00:22:18,860 --> 00:22:25,220
I know that I will always call the

00:22:21,110 --> 00:22:26,870
factory before finding that event but in

00:22:25,220 --> 00:22:29,809
the most common case I should probably

00:22:26,870 --> 00:22:32,210
trap that and tell the user you are

00:22:29,809 --> 00:22:39,200
doing something that will cause issues

00:22:32,210 --> 00:22:42,740
to you and this is the case this is the

00:22:39,200 --> 00:22:45,139
scope of tools like static code analysis

00:22:42,740 --> 00:22:47,600
tools that usually do things like that

00:22:45,139 --> 00:22:49,580
they check empty patterns so everything

00:22:47,600 --> 00:22:51,740
usual you are not supposed to do and

00:22:49,580 --> 00:22:54,499
they usually do that really well at

00:22:51,740 --> 00:22:57,710
language level because they know how the

00:22:54,499 --> 00:22:59,869
Whang languages was supposed to do but

00:22:57,710 --> 00:23:03,470
they are not really useful in the

00:22:59,869 --> 00:23:05,679
context of checking your phone so I mean

00:23:03,470 --> 00:23:08,330
your clone sorry that might be a

00:23:05,679 --> 00:23:10,879
misleading definition the code that you

00:23:08,330 --> 00:23:13,610
write and there's expectation it will

00:23:10,879 --> 00:23:15,440
check that your code solves the

00:23:13,610 --> 00:23:17,570
expectation of the language or they

00:23:15,440 --> 00:23:21,350
won't be able to check that the other

00:23:17,570 --> 00:23:23,570
libraries that use your code solve the

00:23:21,350 --> 00:23:26,480
expectations of your code because you

00:23:23,570 --> 00:23:30,289
will have to write custom checks for

00:23:26,480 --> 00:23:32,539
that weapon in many cases those tools

00:23:30,289 --> 00:23:34,249
are not really easy to expand then you

00:23:32,539 --> 00:23:36,649
will need to learn a whole new framework

00:23:34,249 --> 00:23:38,419
you need to write parcels and things

00:23:36,649 --> 00:23:40,970
like that because they rely on checking

00:23:38,419 --> 00:23:42,980
the the syntax of the language they rely

00:23:40,970 --> 00:23:46,190
on checking the the source code itself

00:23:42,980 --> 00:23:48,350
not the runtime usually and there are

00:23:46,190 --> 00:23:50,830
many things in a dynamic language like

00:23:48,350 --> 00:23:53,749
Python they are not easy at all to

00:23:50,830 --> 00:23:58,100
foresty without actually running the

00:23:53,749 --> 00:24:00,529
code and if you ever use a development

00:23:58,100 --> 00:24:03,499
environment like a charm as we have in

00:24:00,529 --> 00:24:08,539
their room you will probably notice that

00:24:03,499 --> 00:24:10,789
it's not always easy for your editor to

00:24:08,539 --> 00:24:13,549
get the correct types or what's

00:24:10,789 --> 00:24:15,769
happening at the code because it doesn't

00:24:13,549 --> 00:24:18,019
really know what's going on when you run

00:24:15,769 --> 00:24:19,700
that code you can try to guess but it

00:24:18,019 --> 00:24:23,480
has no guarantee that the gas will be

00:24:19,700 --> 00:24:26,570
correct and they are trying one more

00:24:23,480 --> 00:24:30,019
dependency that you must have to your

00:24:26,570 --> 00:24:32,149
tool chain so if you will need to work

00:24:30,019 --> 00:24:34,429
on a new project it's one more piece

00:24:32,149 --> 00:24:37,279
that you need to setup before working on

00:24:34,429 --> 00:24:39,320
this project and the future as as you

00:24:37,279 --> 00:24:42,320
add more and more of those dependencies

00:24:39,320 --> 00:24:44,630
retries tends to be a pain in the ass to

00:24:42,320 --> 00:24:46,669
stop working on new projects and people

00:24:44,630 --> 00:24:48,889
start to complain and they don't want to

00:24:46,669 --> 00:24:51,080
contribute to the project anymore things

00:24:48,889 --> 00:24:55,820
like that so for an open source project

00:24:51,080 --> 00:24:58,399
is not always a really good idea okay

00:24:55,820 --> 00:25:02,720
here comes another powerful feature of

00:24:58,399 --> 00:25:05,149
python which is the inspection and we

00:25:02,720 --> 00:25:08,269
have a full set of things that we can

00:25:05,149 --> 00:25:10,279
inspect a runtime and the great thing is

00:25:08,269 --> 00:25:13,220
that you can actually inspect not only

00:25:10,279 --> 00:25:14,330
your code but even other people code but

00:25:13,220 --> 00:25:15,889
I mean three of them were your

00:25:14,330 --> 00:25:18,620
inspection is that it is really

00:25:15,889 --> 00:25:21,200
expensive so don't try to do that at one

00:25:18,620 --> 00:25:24,919
time usually you want to do that testing

00:25:21,200 --> 00:25:26,870
so while your test which one and you can

00:25:24,919 --> 00:25:29,269
inspect actually anything in the

00:25:26,870 --> 00:25:31,460
language not just objects models and

00:25:29,269 --> 00:25:32,929
classes you can inspect even code itself

00:25:31,460 --> 00:25:35,360
which is the really interesting part

00:25:32,929 --> 00:25:38,029
because we can check what other people

00:25:35,360 --> 00:25:41,419
are doing with our objects and our codes

00:25:38,029 --> 00:25:44,990
and our function and here is one simple

00:25:41,419 --> 00:25:48,289
example and they tries to explain you

00:25:44,990 --> 00:25:50,870
why inspection of the code can help you

00:25:48,289 --> 00:25:53,210
understand what's going on okay so for

00:25:50,870 --> 00:25:55,639
example we might have read the Python

00:25:53,210 --> 00:26:00,080
documentation and it states that all the

00:25:55,639 --> 00:26:03,620
quality operators evaluate from left to

00:26:00,080 --> 00:26:06,169
right at the same order so we probably

00:26:03,620 --> 00:26:11,240
think that writing something like that 2

00:26:06,169 --> 00:26:17,090
equals 14 4 comma 5 will probably

00:26:11,240 --> 00:26:18,350
respond with a true value because we

00:26:17,090 --> 00:26:20,690
compared to the false

00:26:18,350 --> 00:26:23,330
and that's false of course and false is

00:26:20,690 --> 00:26:25,220
in the list that contains false so there

00:26:23,330 --> 00:26:27,440
might be an expectation that we are if

00:26:25,220 --> 00:26:31,039
we evaluate that expression from left to

00:26:27,440 --> 00:26:33,710
right as the documentation space but

00:26:31,039 --> 00:26:36,649
that's not actually true because if we

00:26:33,710 --> 00:26:39,049
try to put squares around the expression

00:26:36,649 --> 00:26:40,600
which should change nothing because it

00:26:39,049 --> 00:26:42,669
should still get away

00:26:40,600 --> 00:26:44,350
for left light as we just place this

00:26:42,669 --> 00:26:48,159
wealth on the last part of the

00:26:44,350 --> 00:26:52,299
expression there is our changes and why

00:26:48,159 --> 00:26:52,990
is that well it's not so easy to get

00:26:52,299 --> 00:26:55,450
response

00:26:52,990 --> 00:26:58,899
so my first expression when I saw this

00:26:55,450 --> 00:27:00,850
one why and we have a few tools that

00:26:58,899 --> 00:27:03,429
might help us understand what's going on

00:27:00,850 --> 00:27:05,529
one is the syntax tree expert area

00:27:03,429 --> 00:27:08,080
inspection and the other is big micro

00:27:05,529 --> 00:27:10,269
dessert inspection the first thing that

00:27:08,080 --> 00:27:12,130
I'm going to show you is how to inspect

00:27:10,269 --> 00:27:14,559
the byte code itself so we can

00:27:12,130 --> 00:27:17,740
disassemble our function and that's

00:27:14,559 --> 00:27:19,779
Python what's going on here and we now

00:27:17,740 --> 00:27:22,389
clearly see what the language is doing

00:27:19,779 --> 00:27:25,090
what's going on is that python is going

00:27:22,389 --> 00:27:26,559
to compare true to false and if that

00:27:25,090 --> 00:27:30,070
comparison is false

00:27:26,559 --> 00:27:32,830
it will move away jumpy false means

00:27:30,070 --> 00:27:36,820
going away from what you're doing next

00:27:32,830 --> 00:27:39,580
and jump to 1127 which is the end of the

00:27:36,820 --> 00:27:42,190
function so it will totally skip the

00:27:39,580 --> 00:27:46,899
right side of my expression if they're

00:27:42,190 --> 00:27:50,049
left side is false and why is that well

00:27:46,899 --> 00:27:53,169
if we go into the extra syntax trees now

00:27:50,049 --> 00:27:55,659
get clear why python is doing that

00:27:53,169 --> 00:27:58,720
because the expectation of python is

00:27:55,659 --> 00:28:01,080
different than mine Python expect you to

00:27:58,720 --> 00:28:04,570
write something like that to express

00:28:01,080 --> 00:28:07,809
inequality here in the context of three

00:28:04,570 --> 00:28:10,000
different elements so the operation

00:28:07,809 --> 00:28:13,120
those are not two different operations

00:28:10,000 --> 00:28:17,080
it's a single operation that is compared

00:28:13,120 --> 00:28:19,659
and compared the last value to two other

00:28:17,080 --> 00:28:22,330
things using two different comparison

00:28:19,659 --> 00:28:24,370
operators so you're not actually saying

00:28:22,330 --> 00:28:25,929
competitors to and the result of the

00:28:24,370 --> 00:28:27,700
first we'll compare it to the third

00:28:25,929 --> 00:28:29,620
element you are saying comparing the

00:28:27,700 --> 00:28:32,289
first element to these and then to that

00:28:29,620 --> 00:28:35,590
and if any of the comparison is false

00:28:32,289 --> 00:28:37,659
the world expression is false but what

00:28:35,590 --> 00:28:40,509
was missing was the way that I wrote it

00:28:37,659 --> 00:28:44,230
because I use the in operator if I wrote

00:28:40,509 --> 00:28:47,919
it this way in the second example here

00:28:44,230 --> 00:28:50,700
it would be clear to any of you probably

00:28:47,919 --> 00:28:53,950
why Python believe behave that way

00:28:50,700 --> 00:28:56,830
because in this expression is clear the

00:28:53,950 --> 00:29:00,520
one day three things to be equal while

00:28:56,830 --> 00:29:03,250
in this expression is not as clear to to

00:29:00,520 --> 00:29:05,650
explain that we want true to be false

00:29:03,250 --> 00:29:09,670
and also in the list that contains false

00:29:05,650 --> 00:29:11,350
and five okay and now in the simple

00:29:09,670 --> 00:29:15,550
expression is easier but is not always

00:29:11,350 --> 00:29:18,190
easy to get what's going on until you go

00:29:15,550 --> 00:29:21,640
down to checking those kind of things

00:29:18,190 --> 00:29:23,530
and now I need actually to rush a bit

00:29:21,640 --> 00:29:26,590
because I have only like finding its

00:29:23,530 --> 00:29:29,140
life so the next example will be pretty

00:29:26,590 --> 00:29:31,930
fast if you ever work with chickaletta

00:29:29,140 --> 00:29:34,690
complexity is how much complex your code

00:29:31,930 --> 00:29:37,390
is so many branches your code is taking

00:29:34,690 --> 00:29:40,030
and usually as good limit is beta to be

00:29:37,390 --> 00:29:42,160
around seven so if you complexity goes

00:29:40,030 --> 00:29:44,050
over seventy means that you can start to

00:29:42,160 --> 00:29:47,830
get too complex for humans to follow

00:29:44,050 --> 00:29:50,770
Erin and with we have something like

00:29:47,830 --> 00:29:52,600
this we can which is just a function

00:29:50,770 --> 00:29:55,660
with two different branches two

00:29:52,600 --> 00:29:58,810
different leaf branches we can compute

00:29:55,660 --> 00:30:02,200
each economic complexity by decoding the

00:29:58,810 --> 00:30:04,150
code of that function so ended up with

00:30:02,200 --> 00:30:06,970
something like this which is the byte

00:30:04,150 --> 00:30:10,570
code and then checking the number of if

00:30:06,970 --> 00:30:15,010
and four loops that might call this

00:30:10,570 --> 00:30:19,780
running so if the complexity that gets

00:30:15,010 --> 00:30:21,790
from that formula so counting the number

00:30:19,780 --> 00:30:23,620
of BS and Counting the number four and

00:30:21,790 --> 00:30:26,980
adding one which is always the main

00:30:23,620 --> 00:30:28,900
branch itself is over seven we can

00:30:26,980 --> 00:30:34,300
provide another to the user the visual

00:30:28,900 --> 00:30:37,840
record so we can use something like code

00:30:34,300 --> 00:30:40,210
inspection to enforce best practices to

00:30:37,840 --> 00:30:43,630
our code like check that your complexity

00:30:40,210 --> 00:30:45,790
is low refactor your code when it gets

00:30:43,630 --> 00:30:49,120
long we can check that for example the

00:30:45,790 --> 00:30:51,700
function is no longer than X it's

00:30:49,120 --> 00:30:53,590
different for loops and we can say hey

00:30:51,700 --> 00:30:56,560
you did too many things into this

00:30:53,590 --> 00:30:58,420
function you should be faculty and then

00:30:56,560 --> 00:31:00,670
once you understand it you are able to

00:30:58,420 --> 00:31:05,470
inspect what's going on around you what

00:31:00,670 --> 00:31:07,539
should you do the first thing that I

00:31:05,470 --> 00:31:10,119
suggest you to apply inspection

00:31:07,539 --> 00:31:13,359
is when you worked on a big project with

00:31:10,119 --> 00:31:15,519
other members of the team it's really

00:31:13,359 --> 00:31:17,350
common that in that context about some

00:31:15,519 --> 00:31:19,830
parts of the system that you understand

00:31:17,350 --> 00:31:22,330
very well and other people understand

00:31:19,830 --> 00:31:23,919
less than you because you aren't

00:31:22,330 --> 00:31:26,529
probably the main development of that

00:31:23,919 --> 00:31:28,269
part of the system and it's really

00:31:26,529 --> 00:31:30,940
important for you to be able to set

00:31:28,269 --> 00:31:33,249
expectations during the test of that

00:31:30,940 --> 00:31:35,889
part of the system because someone else

00:31:33,249 --> 00:31:37,989
might introduce box that it doesn't even

00:31:35,889 --> 00:31:40,720
know that it's closing because it

00:31:37,989 --> 00:31:42,279
doesn't know how your code works for

00:31:40,720 --> 00:31:45,249
example one of the most recent cases

00:31:42,279 --> 00:31:48,039
where I use inspection is this example I

00:31:45,249 --> 00:31:50,259
try to explain the best I can even do I

00:31:48,039 --> 00:31:52,389
recognize that without the context of

00:31:50,259 --> 00:31:54,759
what was going on it's not really easy

00:31:52,389 --> 00:31:57,940
to get to a second suppose that you have

00:31:54,759 --> 00:32:01,389
some code that destroys an entity okay

00:31:57,940 --> 00:32:03,609
so it might be whatever a blog post okay

00:32:01,389 --> 00:32:07,090
this is a blog post and the blog post

00:32:03,609 --> 00:32:09,759
has many attachments every major video

00:32:07,090 --> 00:32:12,340
every whatever your closer to that blog

00:32:09,759 --> 00:32:15,159
post maybe does translation in other

00:32:12,340 --> 00:32:19,029
languages and things like that okay if

00:32:15,159 --> 00:32:21,099
we want to make sure that in any way the

00:32:19,029 --> 00:32:23,859
code that deletes the blog post the

00:32:21,099 --> 00:32:26,289
change you continues to maintain the

00:32:23,859 --> 00:32:28,869
assertion that all the resources that

00:32:26,289 --> 00:32:32,409
were uploaded with that blog post are

00:32:28,869 --> 00:32:35,289
deleted so even if our code face somehow

00:32:32,409 --> 00:32:38,289
it doesn't left around pieces that

00:32:35,289 --> 00:32:40,570
weren't supposed to be deleted in this

00:32:38,289 --> 00:32:42,789
case what I did was writing a function

00:32:40,570 --> 00:32:45,729
and alter function which is called get

00:32:42,789 --> 00:32:48,399
method called by which looks at the by

00:32:45,729 --> 00:32:50,919
code of a function of emitted and looks

00:32:48,399 --> 00:32:54,340
for all the other methods that were

00:32:50,919 --> 00:32:56,470
called by that function so I did

00:32:54,340 --> 00:32:59,200
something like okay I know that this

00:32:56,470 --> 00:33:01,210
function does like 20 other things check

00:32:59,200 --> 00:33:04,450
that any of the other 20 other things

00:33:01,210 --> 00:33:07,769
that the function does doesn't leave

00:33:04,450 --> 00:33:10,359
around any stray five if testing fails

00:33:07,769 --> 00:33:12,669
and that was a really important

00:33:10,359 --> 00:33:15,279
enforcement because you know that when

00:33:12,669 --> 00:33:19,149
you tear down a resource you expect it

00:33:15,279 --> 00:33:20,780
to be gone forever and you don't want to

00:33:19,149 --> 00:33:23,180
go and clean up things

00:33:20,780 --> 00:33:25,040
by n because when you find them it's

00:33:23,180 --> 00:33:27,650
usually really complex to understand

00:33:25,040 --> 00:33:29,780
anymore if they are CEUs or not you have

00:33:27,650 --> 00:33:33,650
to go through all the dependencies and

00:33:29,780 --> 00:33:36,830
incident so in my test suite I brought a

00:33:33,650 --> 00:33:39,110
test that monkey patches every single

00:33:36,830 --> 00:33:42,470
meetin that was called by that method

00:33:39,110 --> 00:33:44,510
and consulates were raised in error so

00:33:42,470 --> 00:33:46,910
every single meter that was called by

00:33:44,510 --> 00:33:50,150
the destroyed function by the teardown

00:33:46,910 --> 00:33:53,270
function now raises an error one by one

00:33:50,150 --> 00:33:56,510
and I checked that closing in error in

00:33:53,270 --> 00:34:00,260
each single method doesn't leave around

00:33:56,510 --> 00:34:04,130
any results so this is a clear example

00:34:00,260 --> 00:34:06,710
or some expectations and falling through

00:34:04,130 --> 00:34:08,840
the inspection of my code because I did

00:34:06,710 --> 00:34:11,630
inspect by code to find all the methods

00:34:08,840 --> 00:34:14,540
that the function was using and then I

00:34:11,630 --> 00:34:16,490
just enforced the fact that each one of

00:34:14,540 --> 00:34:19,280
them shouldn't leave behind any

00:34:16,490 --> 00:34:21,230
resources if it fails it can fail of

00:34:19,280 --> 00:34:21,919
course because we know that something

00:34:21,230 --> 00:34:24,320
might go wrong

00:34:21,919 --> 00:34:26,270
we know that the connection to the

00:34:24,320 --> 00:34:28,429
database system might be down for

00:34:26,270 --> 00:34:30,950
whatever reason and the user deleted the

00:34:28,429 --> 00:34:34,700
object in the exact same exact moment

00:34:30,950 --> 00:34:38,600
but we still need to make sure that the

00:34:34,700 --> 00:34:42,800
data that was stored there will be gone

00:34:38,600 --> 00:34:45,830
whenever the connection is back again so

00:34:42,800 --> 00:34:47,860
you didn't really expect me to do a talk

00:34:45,830 --> 00:34:50,600
about code inspection without

00:34:47,860 --> 00:34:53,060
psychometrics of course and at this

00:34:50,600 --> 00:34:56,330
point I try to do the best I could to

00:34:53,060 --> 00:34:58,640
explain you what definitely programming

00:34:56,330 --> 00:35:00,650
was something you can do with code

00:34:58,640 --> 00:35:03,170
inspection in Python and why you should

00:35:00,650 --> 00:35:05,750
enforce the protocol and the expectation

00:35:03,170 --> 00:35:08,630
of your libraries what you need to do is

00:35:05,750 --> 00:35:10,970
actually not easy for me to tell you

00:35:08,630 --> 00:35:12,770
because there is depends on your project

00:35:10,970 --> 00:35:15,260
and the context work your project I

00:35:12,770 --> 00:35:17,660
would say it's already enough if you get

00:35:15,260 --> 00:35:19,310
out of here and start thinking and a

00:35:17,660 --> 00:35:22,100
very frightening next piece of code

00:35:19,310 --> 00:35:24,650
about how every other single the

00:35:22,100 --> 00:35:27,350
parallel in the world might misuse my

00:35:24,650 --> 00:35:29,300
function that's usually the question you

00:35:27,350 --> 00:35:32,620
want to ask yourself whenever you write

00:35:29,300 --> 00:35:38,849
a new piece of code thank you

00:35:32,620 --> 00:35:41,770
[Applause]

00:35:38,849 --> 00:35:44,170
we've got five minutes for questions if

00:35:41,770 --> 00:35:45,849
you have any question raise your hand we

00:35:44,170 --> 00:35:52,900
have a microphone for it so it get

00:35:45,849 --> 00:35:55,210
recorded is there a library or something

00:35:52,900 --> 00:35:55,930
else that I can use sorry I can't hear

00:35:55,210 --> 00:35:57,700
you very well

00:35:55,930 --> 00:35:59,230
yeah it's their library of something

00:35:57,700 --> 00:36:00,609
else that I can use to implement the

00:35:59,230 --> 00:36:02,500
functionality that you showed me your

00:36:00,609 --> 00:36:03,880
last example to get for example the

00:36:02,500 --> 00:36:08,589
functions that are called by another

00:36:03,880 --> 00:36:11,829
function okay not that I am aware of

00:36:08,589 --> 00:36:14,109
that I'm pretty sure I saw something

00:36:11,829 --> 00:36:16,660
that does things like that their

00:36:14,109 --> 00:36:19,930
libraries for me inspecting the code or

00:36:16,660 --> 00:36:21,609
trying to look at the runtime or things

00:36:19,930 --> 00:36:24,609
like that but they are not really

00:36:21,609 --> 00:36:28,210
oriented to enforcing expectations so

00:36:24,609 --> 00:36:31,630
usually you can rely on them to to get

00:36:28,210 --> 00:36:34,150
the context what's going on but none of

00:36:31,630 --> 00:36:36,420
them is really up-to-date usually

00:36:34,150 --> 00:36:39,460
because they Python back hold changes

00:36:36,420 --> 00:36:41,410
sometimes not really often but some

00:36:39,460 --> 00:36:43,720
versions version in mind adding new

00:36:41,410 --> 00:36:45,940
operator or things like that so unless

00:36:43,720 --> 00:36:49,690
their core developers really committed

00:36:45,940 --> 00:36:52,779
to that project he usually gets behind

00:36:49,690 --> 00:36:57,670
pretty quick liking one or two versions

00:36:52,779 --> 00:37:00,130
of Python and so usually in my

00:36:57,670 --> 00:37:04,630
experience it was just easier to write

00:37:00,130 --> 00:37:07,270
it myself because when a project is is

00:37:04,630 --> 00:37:09,010
implemented it usually bound to a

00:37:07,270 --> 00:37:11,440
specific Python reactions like you

00:37:09,010 --> 00:37:14,950
usually know that this project is going

00:37:11,440 --> 00:37:17,260
to run on Python 2.7 or 3.5 or things

00:37:14,950 --> 00:37:20,440
like that so it's easier just to take

00:37:17,260 --> 00:37:23,529
for granted in the context of a project

00:37:20,440 --> 00:37:25,089
you do for work of course that that's

00:37:23,529 --> 00:37:29,319
the version you are going on obviously

00:37:25,089 --> 00:37:32,710
for a open source project is very hard

00:37:29,319 --> 00:37:35,410
and it's usually easier to rely on

00:37:32,710 --> 00:37:37,329
things like inspection you know frames

00:37:35,410 --> 00:37:39,789
called stack and things like that and

00:37:37,329 --> 00:37:43,569
trying to go into byte for dispatcher

00:37:39,789 --> 00:37:45,670
myself because in my change so I don't

00:37:43,569 --> 00:37:46,210
have a clear answer to your question

00:37:45,670 --> 00:37:48,670
because I

00:37:46,210 --> 00:37:51,369
no no good framework I will suggest you

00:37:48,670 --> 00:37:54,960
for doing that that that will be my

00:37:51,369 --> 00:37:58,000
point I saw some libraries but I never

00:37:54,960 --> 00:38:00,160
ended up using well them for various

00:37:58,000 --> 00:38:02,080
reasons so I am know enough experience

00:38:00,160 --> 00:38:04,560
in any of them to tell you it will solve

00:38:02,080 --> 00:38:04,560
all your problems

00:38:11,250 --> 00:38:19,150
Thanks so going back to your first

00:38:14,650 --> 00:38:20,920
example we register register no classes

00:38:19,150 --> 00:38:24,730
called X functions

00:38:20,920 --> 00:38:27,790
I agree this is extremely common every

00:38:24,730 --> 00:38:29,920
binding is doing that is not so clean

00:38:27,790 --> 00:38:33,490
also there is not clean but what you

00:38:29,920 --> 00:38:36,339
would you suggest to do instead okay

00:38:33,490 --> 00:38:40,000
well in this specific case for example

00:38:36,339 --> 00:38:42,010
there is a really widespread library you

00:38:40,000 --> 00:38:44,740
every one of you probably heard of it

00:38:42,010 --> 00:38:50,140
which is salary they tell does something

00:38:44,740 --> 00:38:52,180
like that for registering tasks if you

00:38:50,140 --> 00:38:54,520
have a worldly salary and if you ever

00:38:52,180 --> 00:38:57,250
try to look at its code you probably

00:38:54,520 --> 00:38:59,920
notice that it is also some pretty

00:38:57,250 --> 00:39:02,740
complex logic to try to ensure that

00:38:59,920 --> 00:39:06,430
defining all the tasks in any place of

00:39:02,740 --> 00:39:08,320
the code that you try to register but

00:39:06,430 --> 00:39:11,410
still there are many ways that you are

00:39:08,320 --> 00:39:13,839
called my go wrong and some tasks you in

00:39:11,410 --> 00:39:16,930
that case I know very well for

00:39:13,839 --> 00:39:19,420
experience I saw that is the issue

00:39:16,930 --> 00:39:22,810
because ever a single that takes a

00:39:19,420 --> 00:39:24,280
function as a argument and that Ranchos

00:39:22,810 --> 00:39:27,220
is actually the real task

00:39:24,280 --> 00:39:29,950
yeah totally that problem I agree the

00:39:27,220 --> 00:39:32,740
design is not equity so for example one

00:39:29,950 --> 00:39:35,320
of the things that I usually do to solve

00:39:32,740 --> 00:39:37,869
this kind of problem is having an

00:39:35,320 --> 00:39:40,480
explicit registration phase on kick

00:39:37,869 --> 00:39:45,220
start of the software so for example for

00:39:40,480 --> 00:39:48,040
salary we ended up writing some parts of

00:39:45,220 --> 00:39:51,490
task registration that ensures that

00:39:48,040 --> 00:39:54,490
whenever they whenever you start the

00:39:51,490 --> 00:39:57,430
software all the tasks are registered at

00:39:54,490 --> 00:39:58,930
that time if any task is register than

00:39:57,430 --> 00:40:01,210
any other moment if we

00:39:58,930 --> 00:40:03,339
trash it will tell you you're registered

00:40:01,210 --> 00:40:05,470
a task at the wrong moment so you should

00:40:03,339 --> 00:40:08,800
explicitly call a register task function

00:40:05,470 --> 00:40:11,859
in the startup function of the code and

00:40:08,800 --> 00:40:15,849
that was a simple solution that didn't

00:40:11,859 --> 00:40:19,210
involve changing salary much we just had

00:40:15,849 --> 00:40:21,700
to patch the task decorator to check

00:40:19,210 --> 00:40:25,390
that it wasn't called in any other place

00:40:21,700 --> 00:40:27,700
apart the startup function and there are

00:40:25,390 --> 00:40:29,740
probably many other patterns that you

00:40:27,700 --> 00:40:32,800
can enforce like pyramid done something

00:40:29,740 --> 00:40:33,540
really complex with the library which is

00:40:32,800 --> 00:40:36,970
called

00:40:33,540 --> 00:40:39,730
the new Venusian if I'm correct that

00:40:36,970 --> 00:40:43,300
inspects all your code trying to find

00:40:39,730 --> 00:40:45,700
any hook point in every single Python

00:40:43,300 --> 00:40:48,220
file in your code there might be another

00:40:45,700 --> 00:40:51,040
solution of the project but I guess that

00:40:48,220 --> 00:40:54,220
it will not be easy to catch them all

00:40:51,040 --> 00:40:57,550
I'm sure that if I invest enough time I

00:40:54,220 --> 00:41:01,000
can find a way to pull pyramid hooking

00:40:57,550 --> 00:41:02,800
up into my code pole thank you it's

00:41:01,000 --> 00:41:07,960
similar to things that I'm doing too so

00:41:02,800 --> 00:41:10,660
this issue thing we don't we don't have

00:41:07,960 --> 00:41:13,119
more time for questions just a quick

00:41:10,660 --> 00:41:16,390
note on the Euro Python app you can rate

00:41:13,119 --> 00:41:19,569
this up send a speaker and also provide

00:41:16,390 --> 00:41:21,760
any any any feedback you you think it

00:41:19,569 --> 00:41:23,559
might be useful for for him for beta

00:41:21,760 --> 00:41:25,180
crops so please think again the

00:41:23,559 --> 00:41:32,250
despicable genre

00:41:25,180 --> 00:41:32,250

YouTube URL: https://www.youtube.com/watch?v=MguKwkrp0tw


