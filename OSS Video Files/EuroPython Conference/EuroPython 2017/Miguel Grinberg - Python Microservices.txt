Title: Miguel Grinberg - Python Microservices
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Python Microservices
[EuroPython 2017 - Talk - 2017-07-10 - Anfiteatro 2]
[Rimini, Italy]

This talk is for Python web developers interested in learning what are the core ideas behind microservices, what problems they try to solve, and what are the viable options to implement them in Python, both from technical and teamwork point of views. Some of the topics that will be discussed include the role of APIs, the improvements microservices bring to application scalability, upgrades, and maintenance, and the challenges in breaking up a monolithic application.

Attendees will leave the talk with a good idea of what microservices are, and how they help build better applications. As usual with my presentations, there will be actual code examples presented during the talk that I will also host on GitHub, for those interested in investigating further on their own.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:05,970 --> 00:00:17,680
so uh hello and welcome

00:00:10,480 --> 00:00:20,529
I don't know how many of you know me but

00:00:17,680 --> 00:00:22,590
in case you don't this is a little bit

00:00:20,529 --> 00:00:25,300
of background information about myself

00:00:22,590 --> 00:00:28,829
I'm a software developer at Rackspace

00:00:25,300 --> 00:00:31,329
this is a company in the United States

00:00:28,829 --> 00:00:33,940
probably if you know me you know me

00:00:31,329 --> 00:00:35,920
because of the last mega tutorial this

00:00:33,940 --> 00:00:39,250
is a series of articles that I wrote on

00:00:35,920 --> 00:00:43,059
my blog a few years ago that are

00:00:39,250 --> 00:00:48,489
somewhat popular I also wrote the

00:00:43,059 --> 00:00:53,409
O'Reilly book on flask mostly these days

00:00:48,489 --> 00:00:56,170
I work on a TI - and my language of

00:00:53,409 --> 00:00:59,050
choice only 90% of the time I'm coding

00:00:56,170 --> 00:01:03,729
Python but sometimes I have no way to

00:00:59,050 --> 00:01:06,220
avoid writing JavaScript so I do and I

00:01:03,729 --> 00:01:10,300
in previous life I used to work a lot

00:01:06,220 --> 00:01:12,970
with C++ as well you have my my Twitter

00:01:10,300 --> 00:01:16,060
my my blog which has a lot of articles

00:01:12,970 --> 00:01:19,690
about Python in particular flask and my

00:01:16,060 --> 00:01:24,150
github page where you can find a bunch

00:01:19,690 --> 00:01:26,550
of open source projects that I did

00:01:24,150 --> 00:01:30,840
before I start I also wanted to mention

00:01:26,550 --> 00:01:34,360
the the other two places I'm going to be

00:01:30,840 --> 00:01:37,180
available in this conference tomorrow

00:01:34,360 --> 00:01:39,700
girls a training session Italy hour-long

00:01:37,180 --> 00:01:44,260
session on this specific topic on micro

00:01:39,700 --> 00:01:46,540
services so tomorrow morning that's

00:01:44,260 --> 00:01:48,910
that's when it's when this is happening

00:01:46,540 --> 00:01:51,820
and then I'm also going to do a helpdesk

00:01:48,910 --> 00:01:53,860
on Thursday if you have any questions

00:01:51,820 --> 00:01:56,350
about class or web development or any of

00:01:53,860 --> 00:02:00,000
my open source projects I'll be more

00:01:56,350 --> 00:02:00,000
than happy to talk to you one-on-one

00:02:00,450 --> 00:02:03,450
okay

00:02:03,560 --> 00:02:10,270
so basically this is going to be an

00:02:08,060 --> 00:02:14,350
introductory talk on micro services

00:02:10,270 --> 00:02:18,459
probably intermediate level maybe a

00:02:14,350 --> 00:02:21,739
beginner that's ready to jump into the

00:02:18,459 --> 00:02:24,260
pool of intermediate you that nobody

00:02:21,739 --> 00:02:28,190
knows exactly what it is but that's

00:02:24,260 --> 00:02:32,959
basically the target audience so I'm

00:02:28,190 --> 00:02:35,090
gonna start with self analogies imagined

00:02:32,959 --> 00:02:38,570
this is something that happened to me I

00:02:35,090 --> 00:02:40,280
have a friend who's taking a software

00:02:38,570 --> 00:02:43,220
development class he's not a developer

00:02:40,280 --> 00:02:46,280
this was an elective class of HIPAA in

00:02:43,220 --> 00:02:49,459
college he had to write a game game of

00:02:46,280 --> 00:02:51,260
pong and he had a bug and he he came to

00:02:49,459 --> 00:02:55,030
ask me for help and what he showed me

00:02:51,260 --> 00:02:58,030
his code it looked pretty much like this

00:02:55,030 --> 00:02:59,770
the whole game in a function so he

00:02:58,030 --> 00:03:02,050
called pong and then that was the game

00:02:59,770 --> 00:03:05,020
and he had abuzz with the way the ball

00:03:02,050 --> 00:03:07,060
moved right so so to help him I had to

00:03:05,020 --> 00:03:09,880
go understand pretty much the whole game

00:03:07,060 --> 00:03:11,710
right it was very hard for me to to

00:03:09,880 --> 00:03:13,360
figure out what what's going on so I use

00:03:11,710 --> 00:03:16,750
the opportunity to show him a better way

00:03:13,360 --> 00:03:18,550
to structure this the game right so I

00:03:16,750 --> 00:03:21,460
told them you should be something like

00:03:18,550 --> 00:03:24,490
this where you have a bunch of functions

00:03:21,460 --> 00:03:25,990
each function does one thing and then

00:03:24,490 --> 00:03:28,570
when when you need to do something

00:03:25,990 --> 00:03:29,680
bigger than what a function does then

00:03:28,570 --> 00:03:30,940
you have a function that calls are the

00:03:29,680 --> 00:03:32,830
functions and all the functions call

00:03:30,940 --> 00:03:35,890
each other and achieve the big thing

00:03:32,830 --> 00:03:39,100
that is the whole game right and I'm

00:03:35,890 --> 00:03:40,720
sure we all going to agree that you know

00:03:39,100 --> 00:03:41,410
the ones right was much better than the

00:03:40,720 --> 00:03:44,050
one we left

00:03:41,410 --> 00:03:45,790
so here but if you look for for saying

00:03:44,050 --> 00:03:48,340
that you know short and focused

00:03:45,790 --> 00:03:51,790
functions are better than long functions

00:03:48,340 --> 00:03:58,300
to do a lot of things now what happens

00:03:51,790 --> 00:04:00,970
if if we go one level above so this is

00:03:58,300 --> 00:04:04,209
this is an example from my book the

00:04:00,970 --> 00:04:05,950
flash book if you start the book it

00:04:04,209 --> 00:04:08,500
teaches you how to build a flask

00:04:05,950 --> 00:04:11,620
application and when you reach the end

00:04:08,500 --> 00:04:14,080
of chapter six you end up with an

00:04:11,620 --> 00:04:16,030
application that does quite a lot but

00:04:14,080 --> 00:04:19,980
basically there's the whole Python logic

00:04:16,030 --> 00:04:22,419
is in this one module hello the file

00:04:19,980 --> 00:04:25,030
then you have a bunch of templates and a

00:04:22,419 --> 00:04:27,250
bunch of static files but basically the

00:04:25,030 --> 00:04:29,140
whole Python thing is in one file so

00:04:27,250 --> 00:04:30,930
then you get into chapter 7 and chapter

00:04:29,140 --> 00:04:33,580
7 is the one that teaches you how to

00:04:30,930 --> 00:04:37,330
structure your application so that it's

00:04:33,580 --> 00:04:39,330
more maintainable so so it goes into

00:04:37,330 --> 00:04:42,220
something like this where you have a

00:04:39,330 --> 00:04:44,919
starter script managed to find the

00:04:42,220 --> 00:04:46,720
configuration it's in its own module you

00:04:44,919 --> 00:04:49,510
have the application is in the package

00:04:46,720 --> 00:04:52,419
and then the tests are in a different

00:04:49,510 --> 00:04:55,960
package and if you keep looking the

00:04:52,419 --> 00:04:58,630
application has a couple of modules that

00:04:55,960 --> 00:05:02,440
are specific things so the database

00:04:58,630 --> 00:05:06,270
models are in one module email support

00:05:02,440 --> 00:05:08,330
is in another one there's this this main

00:05:06,270 --> 00:05:11,419
folder which is another

00:05:08,330 --> 00:05:13,729
package that is a in Flast we call it a

00:05:11,419 --> 00:05:15,470
blueprint which for those of you

00:05:13,729 --> 00:05:18,169
familiar with Django will be sort of the

00:05:15,470 --> 00:05:20,479
same as the Django application and if

00:05:18,169 --> 00:05:22,310
you keep looking then you have for that

00:05:20,479 --> 00:05:25,490
blueprint you have errors forms and

00:05:22,310 --> 00:05:27,409
views so basically once again same thing

00:05:25,490 --> 00:05:29,870
as it functions now with module for

00:05:27,409 --> 00:05:32,419
saying that small and focused modules

00:05:29,870 --> 00:05:36,860
are better than large modules that do a

00:05:32,419 --> 00:05:40,430
lot of things right now what happens if

00:05:36,860 --> 00:05:43,490
if we take this even higher level and we

00:05:40,430 --> 00:05:48,979
talk about services web applications

00:05:43,490 --> 00:05:53,240
that can we translate this so this is an

00:05:48,979 --> 00:05:55,009
example of a big web application that

00:05:53,240 --> 00:05:58,039
this is actually an application that

00:05:55,009 --> 00:06:00,650
exists it's on my github I use this

00:05:58,039 --> 00:06:04,000
application to teach a class to

00:06:00,650 --> 00:06:06,560
demonstrate that slask can scale and

00:06:04,000 --> 00:06:09,520
basically the idea with this application

00:06:06,560 --> 00:06:11,719
is that you have these two green boxes

00:06:09,520 --> 00:06:18,080
black with the name of the application

00:06:11,719 --> 00:06:19,550
and then celery worker it's a one or

00:06:18,080 --> 00:06:23,029
more workers that do asynchronous

00:06:19,550 --> 00:06:26,210
functions and the idea is that you can

00:06:23,029 --> 00:06:28,039
run any number of slack instances and

00:06:26,210 --> 00:06:29,949
any number of salary workers and you

00:06:28,039 --> 00:06:32,690
scale those two according to your needs

00:06:29,949 --> 00:06:35,180
then you have a database that both use

00:06:32,690 --> 00:06:38,029
and there's a message queue that's used

00:06:35,180 --> 00:06:41,779
by celery and also used to allow the

00:06:38,029 --> 00:06:45,289
salary workers to push notifications to

00:06:41,779 --> 00:06:47,539
the client through per WebSocket so

00:06:45,289 --> 00:06:50,779
anyway this is probably a sort of a

00:06:47,539 --> 00:06:54,080
advanced ish application very scalable

00:06:50,779 --> 00:06:56,150
but it's it's one code base so can we

00:06:54,080 --> 00:07:01,669
apply the same logic that we apply to

00:06:56,150 --> 00:07:06,259
functions and modules to this and in my

00:07:01,669 --> 00:07:08,930
opinion the answer is yes and okay first

00:07:06,259 --> 00:07:13,370
I should I should tell you about the

00:07:08,930 --> 00:07:17,089
problems with this so one problem that

00:07:13,370 --> 00:07:21,590
we have is that the code is it single

00:07:17,089 --> 00:07:25,490
code base so it's a very hard to test

00:07:21,590 --> 00:07:28,220
all other things are basically couple

00:07:25,490 --> 00:07:30,980
you you have code that deals with users

00:07:28,220 --> 00:07:34,640
in this particular case slack this

00:07:30,980 --> 00:07:37,160
example is a chat application so we have

00:07:34,640 --> 00:07:39,260
coded these users and messages or mixed

00:07:37,160 --> 00:07:42,800
up you don't even realize that you are

00:07:39,260 --> 00:07:45,650
having you know coupling between those

00:07:42,800 --> 00:07:48,860
two potentially separate functions of

00:07:45,650 --> 00:07:51,050
this application if you are working with

00:07:48,860 --> 00:07:54,620
the team and you need to introduce a new

00:07:51,050 --> 00:07:56,390
member to your team that person is it's

00:07:54,620 --> 00:07:59,120
going to have a hard time trying to

00:07:56,390 --> 00:08:01,670
figure out how to become productive

00:07:59,120 --> 00:08:04,970
because it you know they'll have to

00:08:01,670 --> 00:08:07,730
understand a lot of things before you

00:08:04,970 --> 00:08:09,830
know before you let them participate you

00:08:07,730 --> 00:08:14,680
to reduce the risk of them breaking

00:08:09,830 --> 00:08:18,860
things in particularly when you use

00:08:14,680 --> 00:08:22,010
celery some here I find I find I don't

00:08:18,860 --> 00:08:24,590
like that much is that if you need to

00:08:22,010 --> 00:08:27,320
upgrade even though in this case we have

00:08:24,590 --> 00:08:30,110
two separate services the main service

00:08:27,320 --> 00:08:32,120
and the celery they all come from same

00:08:30,110 --> 00:08:34,670
codebase so there's no way to operate

00:08:32,120 --> 00:08:36,620
them separately you have to stop both or

00:08:34,670 --> 00:08:38,840
if you have many instances of each all

00:08:36,620 --> 00:08:40,580
of that you need to stop then you do the

00:08:38,840 --> 00:08:42,230
afraid to break the database whatever

00:08:40,580 --> 00:08:44,240
else you need to do and then you start

00:08:42,230 --> 00:08:46,370
them again so so basically you have to

00:08:44,240 --> 00:08:51,620
take your application down for their

00:08:46,370 --> 00:08:54,770
prey also if it have a problem and the

00:08:51,620 --> 00:08:56,540
application crashes then basically the

00:08:54,770 --> 00:08:58,970
whole application crashes and the site

00:08:56,540 --> 00:09:02,110
goes down until you figure out what's

00:08:58,970 --> 00:09:06,080
what's going on and you can restart the

00:09:02,110 --> 00:09:07,640
scaling becomes difficult he mentioned

00:09:06,080 --> 00:09:10,370
in the case of a chat application like

00:09:07,640 --> 00:09:13,750
this so we have a module reduce the

00:09:10,370 --> 00:09:15,770
users a module depletes with messages

00:09:13,750 --> 00:09:17,990
very likely there's going to be more

00:09:15,770 --> 00:09:19,490
activity on the messages side than in

00:09:17,990 --> 00:09:22,160
the user side right you're going to have

00:09:19,490 --> 00:09:23,690
a bunch of regular users that are

00:09:22,160 --> 00:09:25,130
already registered and they're going to

00:09:23,690 --> 00:09:27,470
be chatting so there'll be sending a lot

00:09:25,130 --> 00:09:30,470
of messages so if you find that you need

00:09:27,470 --> 00:09:32,750
to scale your application you're going

00:09:30,470 --> 00:09:34,120
to be scaling the whole service so

00:09:32,750 --> 00:09:36,790
you're going to have

00:09:34,120 --> 00:09:39,340
you know the necessary the necessary

00:09:36,790 --> 00:09:42,010
number of instances to satisfy the load

00:09:39,340 --> 00:09:43,690
for the messages but then you can also

00:09:42,010 --> 00:09:46,080
be having a lot of instances that

00:09:43,690 --> 00:09:49,660
contribute users are not there to be

00:09:46,080 --> 00:09:51,810
over over scaling for the user site and

00:09:49,660 --> 00:09:54,430
there's no way to have more fine control

00:09:51,810 --> 00:09:58,870
the only control is basically the celery

00:09:54,430 --> 00:10:01,390
versus the rest is the main service also

00:09:58,870 --> 00:10:03,220
consider the case where let's say this

00:10:01,390 --> 00:10:05,380
is an old application you did it in

00:10:03,220 --> 00:10:07,990
Python 2 and now you are interested in

00:10:05,380 --> 00:10:09,280
going to Python 3 and that that's going

00:10:07,990 --> 00:10:10,780
to be probably going to give you

00:10:09,280 --> 00:10:11,320
headaches right because it's all or

00:10:10,780 --> 00:10:13,870
nothing

00:10:11,320 --> 00:10:16,720
you can have to upgrade the whole whole

00:10:13,870 --> 00:10:19,150
application in one go so all these are

00:10:16,720 --> 00:10:21,760
problems that article also what we call

00:10:19,150 --> 00:10:24,700
monolith so these big applications that

00:10:21,760 --> 00:10:29,590
are they're built with a single code

00:10:24,700 --> 00:10:31,030
games now this is also a real

00:10:29,590 --> 00:10:34,660
application it's the same application

00:10:31,030 --> 00:10:39,040
it's also unlikely hub it's converted to

00:10:34,660 --> 00:10:40,540
this idea of microservices and if you

00:10:39,040 --> 00:10:43,180
can probably get that really is

00:10:40,540 --> 00:10:44,890
basically to write smaller services and

00:10:43,180 --> 00:10:47,110
the services then talked among

00:10:44,890 --> 00:10:50,110
themselves to achieve you know the whole

00:10:47,110 --> 00:10:52,570
function of the application and in this

00:10:50,110 --> 00:10:55,510
case because he would went from two

00:10:52,570 --> 00:10:59,910
green boxes to five and Siri is not

00:10:55,510 --> 00:11:02,530
there anymore so we have flight services

00:10:59,910 --> 00:11:04,270
you can see in the bottom you can see

00:11:02,530 --> 00:11:07,210
the client UI so this is the service

00:11:04,270 --> 00:11:10,690
that served the application that runs on

00:11:07,210 --> 00:11:14,410
the browser so this particular case I

00:11:10,690 --> 00:11:15,700
wrote that in Python in most cases I'm

00:11:14,410 --> 00:11:18,520
going to guess that this is going to be

00:11:15,700 --> 00:11:20,290
a node application and that's totally

00:11:18,520 --> 00:11:22,180
fine because you know that they're

00:11:20,290 --> 00:11:25,410
independent services you can write each

00:11:22,180 --> 00:11:28,150
service with the best technology for

00:11:25,410 --> 00:11:31,590
that service so we have a client you I

00:11:28,150 --> 00:11:34,750
we have a service that into tokens

00:11:31,590 --> 00:11:37,120
disagrees its authentication messages

00:11:34,750 --> 00:11:38,800
and users are separate services and then

00:11:37,120 --> 00:11:42,910
we have software ILO service which is

00:11:38,800 --> 00:11:45,640
the WebSocket push notification module

00:11:42,910 --> 00:11:47,710
so those separate in this case these are

00:11:45,640 --> 00:11:50,470
all flask applications some of

00:11:47,710 --> 00:11:51,790
these are so small that you can open

00:11:50,470 --> 00:11:54,820
them in your screen and see the whole

00:11:51,790 --> 00:11:56,530
code and the ones that you go into

00:11:54,820 --> 00:12:00,090
probably two screens not no more than

00:11:56,530 --> 00:12:04,420
that they're all you know fairly small

00:12:00,090 --> 00:12:07,530
you can see that we went from through

00:12:04,420 --> 00:12:10,930
orange boxes we had a database and a

00:12:07,530 --> 00:12:12,640
message skill on the monolithic case now

00:12:10,930 --> 00:12:14,980
we have four boxes we still have the

00:12:12,640 --> 00:12:18,370
message queue that serves the same

00:12:14,980 --> 00:12:21,010
function it helps the services

00:12:18,370 --> 00:12:23,680
communicate among themselves but then we

00:12:21,010 --> 00:12:25,780
have three databases we have a debate

00:12:23,680 --> 00:12:28,330
database for the messages service

00:12:25,780 --> 00:12:30,220
database for the user service and the

00:12:28,330 --> 00:12:35,560
database for the token service which

00:12:30,220 --> 00:12:38,170
stores revoked tokens and then what else

00:12:35,560 --> 00:12:41,140
we have we have a new box a blue box

00:12:38,170 --> 00:12:43,840
called service registry I'm gonna talk

00:12:41,140 --> 00:12:47,320
about that more later but basically this

00:12:43,840 --> 00:12:48,580
is a very efficient database that keeps

00:12:47,320 --> 00:12:51,520
track of all the services that are

00:12:48,580 --> 00:12:53,020
running it knows what's running and then

00:12:51,520 --> 00:12:56,080
it communicates with the load balancers

00:12:53,020 --> 00:12:59,380
that load balancer knows what what - you

00:12:56,080 --> 00:13:01,290
know what the services are now these

00:12:59,380 --> 00:13:04,870
five green boxes they're all

00:13:01,290 --> 00:13:08,110
independently scalable now so now if I

00:13:04,870 --> 00:13:11,710
have more more load on the messages side

00:13:08,110 --> 00:13:14,980
I can run more more instances of

00:13:11,710 --> 00:13:23,620
messages and then keep users you know at

00:13:14,980 --> 00:13:25,870
one or fill for example so I talked

00:13:23,620 --> 00:13:28,480
about you know disadvantages of the

00:13:25,870 --> 00:13:31,120
monolith and all of those now translate

00:13:28,480 --> 00:13:34,210
into benefits when we're doing micro

00:13:31,120 --> 00:13:37,150
services the code complexity it's you

00:13:34,210 --> 00:13:39,420
know greatly reduced each service as I

00:13:37,150 --> 00:13:42,640
said it's a very small flask application

00:13:39,420 --> 00:13:44,560
you know reminiscing of the hello world

00:13:42,640 --> 00:13:47,260
type application you see in the

00:13:44,560 --> 00:13:50,820
documentation they're actually very

00:13:47,260 --> 00:13:53,860
simple to decode very simple to maintain

00:13:50,820 --> 00:13:56,320
because we're forced to keep things

00:13:53,860 --> 00:13:57,850
separate it's less likely that we're

00:13:56,320 --> 00:13:58,920
going to introduce the bugs do to

00:13:57,850 --> 00:14:01,800
coupling

00:13:58,920 --> 00:14:04,050
the user service has no way to access

00:14:01,800 --> 00:14:06,270
for example the messages database

00:14:04,050 --> 00:14:08,610
directly it needs to talk to the message

00:14:06,270 --> 00:14:12,030
service so messages will have a public

00:14:08,610 --> 00:14:15,060
API that will expose to to clients or to

00:14:12,030 --> 00:14:18,450
other services the users who do the same

00:14:15,060 --> 00:14:20,310
thing and basically that that a couple

00:14:18,450 --> 00:14:23,340
designed you know by for sheep you

00:14:20,310 --> 00:14:26,280
basically this design promotes the

00:14:23,340 --> 00:14:28,230
decouple design that helps helps create

00:14:26,280 --> 00:14:30,900
programs to have less bugs

00:14:28,230 --> 00:14:34,710
now the case of having a new member in

00:14:30,900 --> 00:14:37,560
the team that that you want to to make

00:14:34,710 --> 00:14:40,500
productive as soon as possible that that

00:14:37,560 --> 00:14:42,150
becomes really easy because you can put

00:14:40,500 --> 00:14:45,420
that person to work on one of your

00:14:42,150 --> 00:14:47,880
simplest services and like in the case

00:14:45,420 --> 00:14:49,920
of pong if you have you know the code

00:14:47,880 --> 00:14:51,780
structure with functions if I need to

00:14:49,920 --> 00:14:54,510
fix how the ball moves I don't need to

00:14:51,780 --> 00:14:56,310
learn how the you know how the players

00:14:54,510 --> 00:14:59,220
move or how the collisions happen all I

00:14:56,310 --> 00:15:01,290
need to do is basically go to the

00:14:59,220 --> 00:15:03,630
function that moves the ball and this is

00:15:01,290 --> 00:15:06,510
the same thing you can put a new

00:15:03,630 --> 00:15:08,460
developer to work on the on the token

00:15:06,510 --> 00:15:11,730
services for example the token services

00:15:08,460 --> 00:15:14,490
is very simple and you know right away

00:15:11,730 --> 00:15:16,830
they take a start being productive you

00:15:14,490 --> 00:15:19,920
can you can even allow a new person to

00:15:16,830 --> 00:15:23,520
create a new service because it's a very

00:15:19,920 --> 00:15:27,150
simple application one of the things

00:15:23,520 --> 00:15:30,510
that I find most exciting is that you

00:15:27,150 --> 00:15:33,150
can upgrade like the big guys do without

00:15:30,510 --> 00:15:37,230
going down we would never find out when

00:15:33,150 --> 00:15:39,360
Facebook Twitter etc you know deploy a

00:15:37,230 --> 00:15:41,240
praise because they do it you know while

00:15:39,360 --> 00:15:43,140
running and we can do the same with this

00:15:41,240 --> 00:15:45,390
I'm going to show you an example of that

00:15:43,140 --> 00:15:48,510
later probably you don't believe me but

00:15:45,390 --> 00:15:52,080
you know give me you know benefit of the

00:15:48,510 --> 00:15:54,270
doubt I'll show you in a little bit if

00:15:52,080 --> 00:15:57,360
you have a problem with a service that

00:15:54,270 --> 00:15:59,190
crashes or such bugs or whatever that's

00:15:57,360 --> 00:16:01,260
going to set a small part of your

00:15:59,190 --> 00:16:03,060
application the rest of the application

00:16:01,260 --> 00:16:05,820
will continue to work so unless you're

00:16:03,060 --> 00:16:07,590
unlucky and your token service goes down

00:16:05,820 --> 00:16:09,690
which basically means that nobody will

00:16:07,590 --> 00:16:12,339
be able to authenticate if you have a

00:16:09,690 --> 00:16:15,490
big application with lots of service

00:16:12,339 --> 00:16:16,809
and one minor service goes down that the

00:16:15,490 --> 00:16:20,740
rest of the application will continue to

00:16:16,809 --> 00:16:21,970
work so it's a partial failure not a

00:16:20,740 --> 00:16:26,499
complete failure that in case of a

00:16:21,970 --> 00:16:28,420
monument I've mentioned that you can

00:16:26,499 --> 00:16:33,100
scale individually the services and

00:16:28,420 --> 00:16:35,889
adapt to the loads and finally also very

00:16:33,100 --> 00:16:38,110
important you can choose the best

00:16:35,889 --> 00:16:41,379
technology stack for each service they

00:16:38,110 --> 00:16:44,050
don't need to be all written in Python 2

00:16:41,379 --> 00:16:47,230
or Python 3 they can all be written in

00:16:44,050 --> 00:16:50,439
the best tool and in the example of

00:16:47,230 --> 00:16:52,059
going from Python 2 to Python 3 if you

00:16:50,439 --> 00:16:54,579
started this application with Python 2

00:16:52,059 --> 00:16:56,920
then you could start migrating services

00:16:54,579 --> 00:16:59,050
one by one to Python 3 as long as the

00:16:56,920 --> 00:17:02,860
communication mechanisms between your

00:16:59,050 --> 00:17:06,699
services standard so you will do for

00:17:02,860 --> 00:17:08,049
example HTTP for example then everything

00:17:06,699 --> 00:17:11,189
will continue to work and you can do a

00:17:08,049 --> 00:17:13,480
gradual upgrade to a new technology

00:17:11,189 --> 00:17:16,270
likewise if you find that you need to

00:17:13,480 --> 00:17:19,839
write a new service and for some reason

00:17:16,270 --> 00:17:22,360
you find that goal or node or ruby is a

00:17:19,839 --> 00:17:24,309
best choice then it's absolutely no

00:17:22,360 --> 00:17:27,640
problem you can do that service in the

00:17:24,309 --> 00:17:31,990
in a different technology and that it

00:17:27,640 --> 00:17:35,020
doesn't really matter of course it's not

00:17:31,990 --> 00:17:40,029
you know all roses and you know benefits

00:17:35,020 --> 00:17:43,210
there are some some problems to what one

00:17:40,029 --> 00:17:46,450
terms that I see you know I enforce the

00:17:43,210 --> 00:17:49,620
fact that things become simpler this

00:17:46,450 --> 00:17:51,940
this is really true but now not so much

00:17:49,620 --> 00:17:54,730
the complexity doesn't go away

00:17:51,940 --> 00:17:56,890
completely the complexity goes into the

00:17:54,730 --> 00:18:00,010
if you look at the diagram it goes into

00:17:56,890 --> 00:18:01,600
the arrows so the complexity migrates

00:18:00,010 --> 00:18:03,610
from inside the green boxes into the

00:18:01,600 --> 00:18:05,529
arrows and now you have a web of

00:18:03,610 --> 00:18:08,230
connections that sometimes gets pretty

00:18:05,529 --> 00:18:11,380
crazy so you have to make sure that for

00:18:08,230 --> 00:18:13,390
example you have a cyclic links the

00:18:11,380 --> 00:18:15,429
service calls service a call service P

00:18:13,390 --> 00:18:18,159
and then B eventually ends up calling

00:18:15,429 --> 00:18:20,230
service a again you know you may need to

00:18:18,159 --> 00:18:22,260
look for in efficiencies in that sort of

00:18:20,230 --> 00:18:26,950
thing

00:18:22,260 --> 00:18:28,770
and I suggested by showing the the boxes

00:18:26,950 --> 00:18:32,020
that each service has its own database

00:18:28,770 --> 00:18:35,890
so something that people like me which

00:18:32,020 --> 00:18:39,310
like relational databases a lot I suffer

00:18:35,890 --> 00:18:42,250
with being unable to who joins because

00:18:39,310 --> 00:18:43,900
now each service has its own database so

00:18:42,250 --> 00:18:45,940
if you need to create a join in this

00:18:43,900 --> 00:18:47,530
example between users and messages you

00:18:45,940 --> 00:18:50,650
have to do it in the application there's

00:18:47,530 --> 00:18:52,480
no way to use SQL because it's two

00:18:50,650 --> 00:18:53,890
databases and you know once every

00:18:52,480 --> 00:18:56,680
scanner access the database from the

00:18:53,890 --> 00:18:58,210
other and we don't want to to keep

00:18:56,680 --> 00:19:03,430
things separate and be able to upgrade

00:18:58,210 --> 00:19:05,560
these services separately deployments

00:19:03,430 --> 00:19:08,680
are hard and you know the Box people

00:19:05,560 --> 00:19:10,980
will tell you that you know it's job

00:19:08,680 --> 00:19:13,510
security for for the about people but

00:19:10,980 --> 00:19:16,870
you know there are so many moving pieces

00:19:13,510 --> 00:19:19,630
that you know it requires a full-time

00:19:16,870 --> 00:19:21,510
job sometimes to keep things going when

00:19:19,630 --> 00:19:26,590
we have this type of architecture and

00:19:21,510 --> 00:19:29,140
then finally you you have this pinball

00:19:26,590 --> 00:19:32,230
effect right each service that small

00:19:29,140 --> 00:19:35,710
things so when the client requests a

00:19:32,230 --> 00:19:39,070
complex action then that may require

00:19:35,710 --> 00:19:41,890
usually requires a request to pinball

00:19:39,070 --> 00:19:44,350
two different services like the entry

00:19:41,890 --> 00:19:46,060
service could be messages messages may

00:19:44,350 --> 00:19:48,220
need to talk to tokens to verify the

00:19:46,060 --> 00:19:50,740
authentication it may need to talk to

00:19:48,220 --> 00:19:53,110
users to get user information they need

00:19:50,740 --> 00:19:55,060
to talk to socket IO to to push a

00:19:53,110 --> 00:19:58,390
notification to the client so basically

00:19:55,060 --> 00:20:00,520
it becomes less efficient so you have to

00:19:58,390 --> 00:20:02,710
keep that in mind too so response times

00:20:00,520 --> 00:20:08,950
for the client do not never be as great

00:20:02,710 --> 00:20:12,450
as when you have a single codebase so

00:20:08,950 --> 00:20:15,250
you you may wonder how we were about

00:20:12,450 --> 00:20:18,220
conforming or converting or refactoring

00:20:15,250 --> 00:20:19,780
a monolithic application into micro

00:20:18,220 --> 00:20:22,630
services and fortunately that that's

00:20:19,780 --> 00:20:26,950
pretty hard and but basically there are

00:20:22,630 --> 00:20:29,950
the three main strategies the one that's

00:20:26,950 --> 00:20:32,500
probably the easiest is to say okay what

00:20:29,950 --> 00:20:33,520
I have so far I'm going to keep I'm not

00:20:32,500 --> 00:20:34,790
going to worry about that

00:20:33,520 --> 00:20:36,890
but then anything

00:20:34,790 --> 00:20:39,230
that I start building from now on I'm

00:20:36,890 --> 00:20:42,080
going to build you know using small

00:20:39,230 --> 00:20:44,180
services micro services that's the

00:20:42,080 --> 00:20:46,100
easiest strategy not the greatest one

00:20:44,180 --> 00:20:49,100
because you still have a monolith that

00:20:46,100 --> 00:20:54,230
you need to granfather into your micro

00:20:49,100 --> 00:20:57,520
services platform another option would

00:20:54,230 --> 00:21:00,020
be to to start with the big service

00:20:57,520 --> 00:21:03,350
incorporate that but then over time you

00:21:00,020 --> 00:21:06,470
start breaking away parts of that big

00:21:03,350 --> 00:21:08,810
application into small services so

00:21:06,470 --> 00:21:10,460
eventually over time you are going to

00:21:08,810 --> 00:21:13,070
end up with a micro services

00:21:10,460 --> 00:21:14,510
architecture that's pure but but then

00:21:13,070 --> 00:21:17,180
there's maybe a potentially long

00:21:14,510 --> 00:21:19,520
transition time where you will be you

00:21:17,180 --> 00:21:21,950
will be working with a hybrid that's

00:21:19,520 --> 00:21:25,280
probably what most people do when they

00:21:21,950 --> 00:21:26,810
do this and then finally you can you can

00:21:25,280 --> 00:21:28,940
use the language it's an approach and

00:21:26,810 --> 00:21:31,130
say ok I'm going to perfect this

00:21:28,940 --> 00:21:34,520
application into microcircuits you know

00:21:31,130 --> 00:21:36,410
today it may take you a week or two

00:21:34,520 --> 00:21:38,030
weeks or a month but then when you're

00:21:36,410 --> 00:21:41,180
done then you have a complete

00:21:38,030 --> 00:21:46,220
application that you know that that's

00:21:41,180 --> 00:21:48,620
fully micro services enabled something

00:21:46,220 --> 00:21:50,390
that's important I feel a lot of

00:21:48,620 --> 00:21:53,450
projects that they'd say ok I'm going to

00:21:50,390 --> 00:21:56,380
do micro services and all they do they

00:21:53,450 --> 00:22:01,970
start writing services and that's

00:21:56,380 --> 00:22:04,310
probably about 60% of the equation you

00:22:01,970 --> 00:22:07,250
need to have a platform that's proper

00:22:04,310 --> 00:22:15,640
for micro services to live and it

00:22:07,250 --> 00:22:15,640
basically this is if we okay

00:22:16,499 --> 00:22:24,999
if we go to the sorry if we go to the

00:22:20,889 --> 00:22:26,619
diagram this is basically the load

00:22:24,999 --> 00:22:29,590
balancer and the service registry are

00:22:26,619 --> 00:22:31,659
very important components that that need

00:22:29,590 --> 00:22:34,359
to be in place even if you have a

00:22:31,659 --> 00:22:35,799
monolith that you are transitioning into

00:22:34,359 --> 00:22:38,470
micro-service you'll have to figure out

00:22:35,799 --> 00:22:40,840
a way to incorporate that monolith into

00:22:38,470 --> 00:22:42,729
the platform that allows microservices

00:22:40,840 --> 00:22:48,429
to exist I'm going to describe what that

00:22:42,729 --> 00:22:50,019
means but but before I get into a little

00:22:48,429 --> 00:22:52,840
bit more theory and I'm going to do a

00:22:50,019 --> 00:22:59,409
demo and then if I run out of time then

00:22:52,840 --> 00:23:02,849
at least I get the fun part down so okay

00:22:59,409 --> 00:23:08,859
so this is this micro flat application

00:23:02,849 --> 00:23:14,289
so I'm going to show you let's see so

00:23:08,859 --> 00:23:17,590
I'm gonna again it's basically a chat

00:23:14,289 --> 00:23:21,159
application pretty standard so I can go

00:23:17,590 --> 00:23:24,879
to another tab you can see that things

00:23:21,159 --> 00:23:28,179
are looking at the boss it's probably

00:23:24,879 --> 00:23:34,330
several claims of this above it so now I

00:23:28,179 --> 00:23:39,039
can you can create another user you know

00:23:34,330 --> 00:23:42,330
so pretty simple stuff but let's uh

00:23:39,039 --> 00:23:44,799
let's look under the hood a little bit

00:23:42,330 --> 00:23:51,549
this is probably going to be whoa what

00:23:44,799 --> 00:23:55,509
was this so this is a an open source

00:23:51,549 --> 00:23:57,399
load balancer so that the the yellow the

00:23:55,509 --> 00:23:58,899
yellow of box that you saw on the

00:23:57,399 --> 00:24:02,739
diagram on the left

00:23:58,899 --> 00:24:03,609
it's called H a proxy probably your if

00:24:02,739 --> 00:24:06,879
you don't know this one you probably

00:24:03,609 --> 00:24:08,919
know nginx maybe you know traffic which

00:24:06,879 --> 00:24:11,529
is another one that's a it's kind of

00:24:08,919 --> 00:24:14,470
becoming popular these days so only

00:24:11,529 --> 00:24:17,109
these tools do is basically you tell

00:24:14,470 --> 00:24:19,929
them you know where all your services

00:24:17,109 --> 00:24:22,149
and then you have clients connect to

00:24:19,929 --> 00:24:25,779
this thing and this is sort of a

00:24:22,149 --> 00:24:28,480
switchboard a control a traffic control

00:24:25,779 --> 00:24:30,780
that basically shares

00:24:28,480 --> 00:24:35,770
all the requests that come from clients

00:24:30,780 --> 00:24:37,270
among all your instances now it is a

00:24:35,770 --> 00:24:39,160
super busy I'm not going to explain

00:24:37,270 --> 00:24:42,760
everything because it's irrelevant to

00:24:39,160 --> 00:24:45,970
our purposes here but if you look at the

00:24:42,760 --> 00:24:48,750
sections there are six sections the top

00:24:45,970 --> 00:24:52,270
section basically shows you status about

00:24:48,750 --> 00:24:54,750
the is to late April in listening to

00:24:52,270 --> 00:24:58,150
requests we're going to ignore that

00:24:54,750 --> 00:25:00,460
there's five more sections and these the

00:24:58,150 --> 00:25:04,030
side sections are for the five services

00:25:00,460 --> 00:25:06,940
that we have these five green boxes you

00:25:04,030 --> 00:25:10,179
can see that messages is running three

00:25:06,940 --> 00:25:11,799
instances or running a version for of

00:25:10,179 --> 00:25:15,130
the messages service and we have three

00:25:11,799 --> 00:25:17,169
so when requests come to this load

00:25:15,130 --> 00:25:19,960
balancer they're going to be assigned to

00:25:17,169 --> 00:25:21,280
one of these three and basically H a

00:25:19,960 --> 00:25:26,080
proxy would make sure that all three

00:25:21,280 --> 00:25:28,750
stay from more or less equally busy we

00:25:26,080 --> 00:25:32,290
have one of Sicario we have two of

00:25:28,750 --> 00:25:34,590
tokens and then one of UI and one of

00:25:32,290 --> 00:25:40,690
users so you can see that I'm scaling

00:25:34,590 --> 00:25:42,640
independently so this is all running in

00:25:40,690 --> 00:25:50,020
a vagrant machine so I'm going to log in

00:25:42,640 --> 00:25:51,880
to show you some fun stuff so what was

00:25:50,020 --> 00:25:55,030
he actually say if we probably used to

00:25:51,880 --> 00:25:56,950
here micro-services associated with you

00:25:55,030 --> 00:25:57,580
know platforms like kubernetes you know

00:25:56,950 --> 00:26:00,460
that type of thing

00:25:57,580 --> 00:26:04,059
which you can use I'm not using that

00:26:00,460 --> 00:26:06,910
right now this is all you know I'm its

00:26:04,059 --> 00:26:09,790
last guy I like simple stuff so this is

00:26:06,910 --> 00:26:12,700
all built using bash and a little bit of

00:26:09,790 --> 00:26:14,730
Python so this platform does we use any

00:26:12,700 --> 00:26:18,010
you know professional you know

00:26:14,730 --> 00:26:20,440
professional-grade microservices

00:26:18,010 --> 00:26:23,470
platform I have h a proxy I have a

00:26:20,440 --> 00:26:27,880
service registry and then a little bit

00:26:23,470 --> 00:26:30,360
of batch so for example I have a batch

00:26:27,880 --> 00:26:36,850
script that runs a new service I can say

00:26:30,360 --> 00:26:39,070
for example it's h1 uses oops excuses so

00:26:36,850 --> 00:26:41,020
this is when I run a new container this

00:26:39,070 --> 00:26:43,870
is all based on docker containers

00:26:41,020 --> 00:26:47,110
so I'm running a second users you are

00:26:43,870 --> 00:26:50,080
going to see in a little bit H a proxy

00:26:47,110 --> 00:26:51,270
please upgrade and show me - there you

00:26:50,080 --> 00:26:55,780
are

00:26:51,270 --> 00:26:58,240
so the the way H a proxy upgrade is a

00:26:55,780 --> 00:26:59,650
little bit clunky glancing screen but

00:26:58,240 --> 00:27:03,880
that doesn't mean it goes down it's just

00:26:59,650 --> 00:27:05,410
live the web panel that it's a little

00:27:03,880 --> 00:27:09,520
bit clunky but anyway you can see at the

00:27:05,410 --> 00:27:13,750
bottom now I have two users so all I did

00:27:09,520 --> 00:27:16,780
was run this I can show you okay this

00:27:13,750 --> 00:27:18,550
looks awful but somewhere in here here

00:27:16,780 --> 00:27:21,970
at the top you have a new this is the

00:27:18,550 --> 00:27:25,090
new users container that I started so

00:27:21,970 --> 00:27:26,950
just like starting the container the

00:27:25,090 --> 00:27:29,110
container itself talks to the service

00:27:26,950 --> 00:27:31,990
registry which is this database that

00:27:29,110 --> 00:27:33,340
knows about everything and then the

00:27:31,990 --> 00:27:36,670
service directors who knows about it and

00:27:33,340 --> 00:27:38,320
that gets communicated to HF proxy so

00:27:36,670 --> 00:27:44,020
it's a proxy that service online

00:27:38,320 --> 00:27:49,390
immediately now I'm going to just be

00:27:44,020 --> 00:27:50,640
nasty here and I'm going to kill that

00:27:49,390 --> 00:27:53,620
guy

00:27:50,640 --> 00:27:55,600
so the moment I stop it

00:27:53,620 --> 00:27:58,480
it's a proxies we notice that

00:27:55,600 --> 00:28:02,559
something's going not right so it's

00:27:58,480 --> 00:28:04,660
going to blacklist that that service so

00:28:02,559 --> 00:28:06,250
immediately you know in any requests are

00:28:04,660 --> 00:28:09,460
coming they're going to go to the good

00:28:06,250 --> 00:28:11,800
one there's the other one right and in a

00:28:09,460 --> 00:28:13,270
few more seconds since this isn't coming

00:28:11,800 --> 00:28:18,970
back then it's going to go away

00:28:13,270 --> 00:28:20,740
completely so this is one cool thing

00:28:18,970 --> 00:28:23,770
that you can do with my services super

00:28:20,740 --> 00:28:25,960
easy start and stop things I mentioned

00:28:23,770 --> 00:28:30,820
before that upgrades are really fun and

00:28:25,960 --> 00:28:33,809
very efficient so as soon as this spread

00:28:30,820 --> 00:28:38,520
guy goes away I'm going to show you that

00:28:33,809 --> 00:28:41,020
whenever another bash script that's

00:28:38,520 --> 00:28:45,160
that's going to upgrade messages I have

00:28:41,020 --> 00:28:47,530
three ago three messages instances that

00:28:45,160 --> 00:28:51,340
are running before now in this instance

00:28:47,530 --> 00:28:53,090
I have already here a version five that

00:28:51,340 --> 00:28:56,560
I'm about to deploy

00:28:53,090 --> 00:29:00,440
so I'm going to say enough upgrade roll

00:28:56,560 --> 00:29:07,120
messages and pay attention to what

00:29:00,440 --> 00:29:17,870
happens now so you are going to see a v5

00:29:07,120 --> 00:29:25,430
messages come up please and now thank

00:29:17,870 --> 00:29:28,970
you so so 1v5 and now one v4 is going

00:29:25,430 --> 00:29:31,730
down another we Phi is going to come and

00:29:28,970 --> 00:29:33,890
another before is going to go down so

00:29:31,730 --> 00:29:37,580
basically as you see there's always at

00:29:33,890 --> 00:29:39,590
least three that are running so we never

00:29:37,580 --> 00:29:41,440
stop we never have to we never have less

00:29:39,590 --> 00:29:43,630
than three which is what we intended

00:29:41,440 --> 00:29:46,610
they're all running

00:29:43,630 --> 00:29:49,010
eventually you know all the three V

00:29:46,610 --> 00:29:53,900
force are going to be killed and they're

00:29:49,010 --> 00:29:56,470
going to be replaced but the three v5 we

00:29:53,900 --> 00:30:00,440
have one more that needs to go down

00:29:56,470 --> 00:30:02,480
there you go so that that's how you do a

00:30:00,440 --> 00:30:06,320
trade without stocking and so that I

00:30:02,480 --> 00:30:08,500
think I would stun it if I look at these

00:30:06,320 --> 00:30:10,970
two guys there's the grind

00:30:08,500 --> 00:30:13,850
somehow I got to bounce there but other

00:30:10,970 --> 00:30:17,600
than that these are still connected they

00:30:13,850 --> 00:30:19,340
never lost the connection so so people

00:30:17,600 --> 00:30:25,250
using this service would have noticed

00:30:19,340 --> 00:30:30,020
that you're doing that break okay so

00:30:25,250 --> 00:30:33,320
that was the demo so in the time I have

00:30:30,020 --> 00:30:37,490
left okay

00:30:33,320 --> 00:30:39,200
not much yeah so five minutes in five

00:30:37,490 --> 00:30:42,380
minutes I'm gonna try to rush for this I

00:30:39,200 --> 00:30:45,380
will obscure the pieces that that make

00:30:42,380 --> 00:30:47,060
this that the build is so we have a

00:30:45,380 --> 00:30:51,290
local answer I mentioned that I'm using

00:30:47,060 --> 00:30:52,700
H a proxy basically having a load

00:30:51,290 --> 00:30:56,570
balancer when you're doing micro

00:30:52,700 --> 00:30:59,240
services is a must you you can try to

00:30:56,570 --> 00:31:02,509
not use a load balancer but it's really

00:30:59,240 --> 00:31:05,359
lose a lot of benefits

00:31:02,509 --> 00:31:07,759
you basically get to do very simple

00:31:05,359 --> 00:31:10,039
rolling a break I showed you a bash

00:31:07,759 --> 00:31:13,399
script that can do a rolling upgrade

00:31:10,039 --> 00:31:14,869
without going down and at that only

00:31:13,399 --> 00:31:18,349
because we have a load balancer that

00:31:14,869 --> 00:31:20,509
that supports is this architecture you

00:31:18,349 --> 00:31:23,119
can do a/b testing dream glue diplomacy

00:31:20,509 --> 00:31:25,099
all these cool things you hear they you

00:31:23,119 --> 00:31:27,559
know the the very popular companies the

00:31:25,099 --> 00:31:30,169
disciples Facebook's and the Netflix is

00:31:27,559 --> 00:31:32,209
talking about that they do the chaos

00:31:30,169 --> 00:31:35,029
monkey you know all those things you can

00:31:32,209 --> 00:31:38,209
do and and the load balancer is the main

00:31:35,029 --> 00:31:39,739
piece that supports this so super

00:31:38,209 --> 00:31:43,009
important that you have a one in place

00:31:39,739 --> 00:31:46,779
before we roll you start doing this the

00:31:43,009 --> 00:31:49,190
service 43 it's a database that usually

00:31:46,779 --> 00:31:51,669
it's designed to be highly available

00:31:49,190 --> 00:31:56,299
you've run multiple instances of it

00:31:51,669 --> 00:31:56,719
redundant and basically superfast it

00:31:56,299 --> 00:32:00,049
caches

00:31:56,719 --> 00:32:05,299
stuff in memory so that you can do

00:32:00,049 --> 00:32:08,809
queries are very quick and basically the

00:32:05,299 --> 00:32:11,449
service registry technically corrected

00:32:08,809 --> 00:32:14,089
from all the services when they start so

00:32:11,449 --> 00:32:17,539
they register themselves and then if it

00:32:14,089 --> 00:32:19,219
service dies the connection depends on

00:32:17,539 --> 00:32:22,609
the system but usually the connection

00:32:19,219 --> 00:32:24,559
has a TTL so if the service doesn't

00:32:22,609 --> 00:32:26,719
refresh that connection and says hey I'm

00:32:24,559 --> 00:32:28,639
still here hey I'm still here when stop

00:32:26,719 --> 00:32:30,979
saying that then the service registry

00:32:28,639 --> 00:32:33,169
will remove it and then immediately will

00:32:30,979 --> 00:32:36,279
talk to the load balancer and it will

00:32:33,169 --> 00:32:38,749
remove it from the load balancer as well

00:32:36,279 --> 00:32:40,849
so basically that that's the whole magic

00:32:38,749 --> 00:32:43,459
and if you want to know I didn't put it

00:32:40,849 --> 00:32:45,139
here but the registries I'm using is

00:32:43,459 --> 00:32:45,729
another open source project it's called

00:32:45,139 --> 00:32:49,039
xcb

00:32:45,729 --> 00:32:52,809
etcd it's very simple it's actually the

00:32:49,039 --> 00:32:52,809
one that kubernetes uses as well

00:32:54,229 --> 00:33:00,679
containers are a big part initially you

00:32:57,769 --> 00:33:02,539
see micro services platforms are always

00:33:00,679 --> 00:33:06,859
done with containers it's only because

00:33:02,539 --> 00:33:08,719
it makes things much more easy the

00:33:06,859 --> 00:33:13,039
container provides a layer of isolation

00:33:08,719 --> 00:33:15,020
that with better than just processes for

00:33:13,039 --> 00:33:17,420
example it allows you to

00:33:15,020 --> 00:33:20,240
to work with virtualized network ports

00:33:17,420 --> 00:33:23,270
all these services that you've seen that

00:33:20,240 --> 00:33:24,590
the five services in the example that's

00:33:23,270 --> 00:33:26,450
all the instances of all these services

00:33:24,590 --> 00:33:29,240
they're all running on port 5000 which

00:33:26,450 --> 00:33:31,490
is the flask default and and then docker

00:33:29,240 --> 00:33:32,810
takes care of you know mapping that into

00:33:31,490 --> 00:33:35,870
some other port that I don't even care

00:33:32,810 --> 00:33:37,910
but I don't know what what it is but but

00:33:35,870 --> 00:33:40,430
you know for me writing the services I

00:33:37,910 --> 00:33:43,250
fix for five thousand every time so that

00:33:40,430 --> 00:33:46,100
that's really nice you can do that

00:33:43,250 --> 00:33:47,150
yourself if you don't use docker but you

00:33:46,100 --> 00:33:50,660
know it makes things a lot more

00:33:47,150 --> 00:33:53,240
difficult and of course if using getting

00:33:50,660 --> 00:33:54,920
different technologies then having

00:33:53,240 --> 00:33:56,450
containers make sure that you don't have

00:33:54,920 --> 00:34:01,850
collisions between conflicting

00:33:56,450 --> 00:34:05,440
dependencies as well we have the orange

00:34:01,850 --> 00:34:09,260
boxes so storage with your storage

00:34:05,440 --> 00:34:10,970
containers usually your database your

00:34:09,260 --> 00:34:13,909
service registry can also be considered

00:34:10,970 --> 00:34:16,190
storage message queue you know all of

00:34:13,909 --> 00:34:18,050
those for all those for production

00:34:16,190 --> 00:34:19,490
platforms we would look for something

00:34:18,050 --> 00:34:22,790
that's highly available something that

00:34:19,490 --> 00:34:24,890
you can make clusters off so typically

00:34:22,790 --> 00:34:27,830
if you're using for example my sequel

00:34:24,890 --> 00:34:31,370
you will look at Galera which is a

00:34:27,830 --> 00:34:33,620
faster solution or Aurora asleep on AWS

00:34:31,370 --> 00:34:36,770
you know all those things that if you

00:34:33,620 --> 00:34:38,330
could make the service very reliable not

00:34:36,770 --> 00:34:41,240
running one instance that if it dies and

00:34:38,330 --> 00:34:45,860
the whole thing goes down right

00:34:41,240 --> 00:34:47,450
same thing for queues and and so on and

00:34:45,860 --> 00:34:49,580
then you have your applications these

00:34:47,450 --> 00:34:53,000
are the green boxes and these

00:34:49,580 --> 00:34:56,750
applications are stateless so I need to

00:34:53,000 --> 00:34:58,580
rush these are stateless so that what

00:34:56,750 --> 00:35:00,830
allows me allows me to start and stop

00:34:58,580 --> 00:35:03,920
these services they have no data in them

00:35:00,830 --> 00:35:06,440
they use the storage services to store

00:35:03,920 --> 00:35:08,440
data so this allows them to start kill

00:35:06,440 --> 00:35:11,690
and it doesn't really matter they all

00:35:08,440 --> 00:35:13,130
prolifically disposable I can hold

00:35:11,690 --> 00:35:14,000
centrally scale them for free or convert

00:35:13,130 --> 00:35:15,740
as many as I want

00:35:14,000 --> 00:35:19,630
and basically the more around the more

00:35:15,740 --> 00:35:19,630
load I can handle on that service

00:35:20,320 --> 00:35:25,960
I think I'm going to skip this one in

00:35:23,500 --> 00:35:27,430
the spirit of saving time I already

00:35:25,960 --> 00:35:28,720
talked about this

00:35:27,430 --> 00:35:30,760
basically the lifestyle of the

00:35:28,720 --> 00:35:34,270
microcircuits it starts top to the third

00:35:30,760 --> 00:35:36,070
to the 723 and then when you guys stops

00:35:34,270 --> 00:35:38,170
talking to the service right III and

00:35:36,070 --> 00:35:41,080
that translates into the load balancer

00:35:38,170 --> 00:35:45,400
removing it from from its configuration

00:35:41,080 --> 00:35:48,370
and then finally we have service service

00:35:45,400 --> 00:35:50,290
communication which is the mechanism by

00:35:48,370 --> 00:35:54,160
which the services talk among themselves

00:35:50,290 --> 00:35:56,890
this example I'm using HTTP as a way for

00:35:54,160 --> 00:35:59,230
internal communication there are many

00:35:56,890 --> 00:36:02,080
projects that decide to only use HTTP

00:35:59,230 --> 00:36:04,360
for for client communication into the

00:36:02,080 --> 00:36:06,070
into the project but then internally

00:36:04,360 --> 00:36:06,850
they use different mechanisms which is

00:36:06,070 --> 00:36:08,500
totally fine

00:36:06,850 --> 00:36:10,420
as long as it is a mechanism that

00:36:08,500 --> 00:36:14,200
doesn't restrict your choices of

00:36:10,420 --> 00:36:16,840
technologies so you should find standard

00:36:14,200 --> 00:36:19,390
RPC mechanisms for example that would be

00:36:16,840 --> 00:36:21,850
a very good way to to do a more

00:36:19,390 --> 00:36:27,040
efficient less chatty communication than

00:36:21,850 --> 00:36:28,810
HTTP so I'm going to give you a link to

00:36:27,040 --> 00:36:31,450
the slides but if you want to try this

00:36:28,810 --> 00:36:34,210
example yourself you can this runs in a

00:36:31,450 --> 00:36:36,400
vagrant virtual machine these are the

00:36:34,210 --> 00:36:38,170
instructions and the requirements you

00:36:36,400 --> 00:36:41,440
put on this application and play with it

00:36:38,170 --> 00:36:43,330
like that laid here and tomorrow I'm

00:36:41,440 --> 00:36:46,290
going to talk more detail about this if

00:36:43,330 --> 00:36:49,900
you want to learn how this was built

00:36:46,290 --> 00:36:54,000
phew thank you

00:36:49,900 --> 00:36:57,840
if you can see the slides over there

00:36:54,000 --> 00:37:00,000
thank you thank you very much for this

00:36:57,840 --> 00:37:01,849
nice presentation we do have time for

00:37:00,000 --> 00:37:05,609
questions

00:37:01,849 --> 00:37:08,700
very close thanks for the presentation

00:37:05,609 --> 00:37:11,940
my question is can there be a difference

00:37:08,700 --> 00:37:14,040
between running two instances of the

00:37:11,940 --> 00:37:16,859
same micro service into docker

00:37:14,040 --> 00:37:18,720
containers on the same machine and run

00:37:16,859 --> 00:37:21,210
in just one instance in one docker

00:37:18,720 --> 00:37:25,470
container so can it help with load

00:37:21,210 --> 00:37:26,550
balancing other cases one can help well

00:37:25,470 --> 00:37:29,160
I'm not sure if I understand the

00:37:26,550 --> 00:37:32,040
question but typically you will not run

00:37:29,160 --> 00:37:34,050
your let's say you have three instances

00:37:32,040 --> 00:37:36,180
you are probably going to run them in

00:37:34,050 --> 00:37:38,760
different hosts and then the load

00:37:36,180 --> 00:37:41,040
balancer is going to be you know in

00:37:38,760 --> 00:37:42,840
front of all those and the reason is

00:37:41,040 --> 00:37:44,790
that if the host goes down you don't

00:37:42,840 --> 00:37:48,210
want you know all your instances to go

00:37:44,790 --> 00:37:51,300
down so there is no case usually when

00:37:48,210 --> 00:37:54,180
you would run to micro service in two

00:37:51,300 --> 00:37:58,380
jokers on the same machine right I'm

00:37:54,180 --> 00:37:59,910
sorry I can't hear you well I should I

00:37:58,380 --> 00:38:03,119
mean you're asking about something

00:37:59,910 --> 00:38:05,190
specific but yeah I mean can there be a

00:38:03,119 --> 00:38:07,260
case when we have two micro services

00:38:05,190 --> 00:38:09,630
into docker containers and they are on

00:38:07,260 --> 00:38:12,420
the same machine because they have

00:38:09,630 --> 00:38:14,700
different processes and in the case when

00:38:12,420 --> 00:38:19,290
it could help

00:38:14,700 --> 00:38:21,060
well load balancing because it's totally

00:38:19,290 --> 00:38:24,720
fine you immediately are collisions

00:38:21,060 --> 00:38:28,140
between the two containers no I mean

00:38:24,720 --> 00:38:29,849
would it make sense in any case what

00:38:28,140 --> 00:38:31,500
makes more sense is to use different

00:38:29,849 --> 00:38:33,810
hosts okay thank you

00:38:31,500 --> 00:38:36,720
together that was my question but I mean

00:38:33,810 --> 00:38:39,390
only for for reliance right you don't

00:38:36,720 --> 00:38:41,400
want you know host a docker host to go

00:38:39,390 --> 00:38:43,830
down and take all your instances of a

00:38:41,400 --> 00:38:45,599
service so you you will have even

00:38:43,830 --> 00:38:48,599
different data centers like if you are

00:38:45,599 --> 00:38:53,900
we are doing this for real okay thank

00:38:48,599 --> 00:38:53,900
you any more questions

00:39:01,020 --> 00:39:04,740
all right thank you very much I was

00:39:03,180 --> 00:39:06,900
wondering what's the best practice for

00:39:04,740 --> 00:39:07,890
up rolling upgrade in micro services

00:39:06,900 --> 00:39:10,770
like I just did

00:39:07,890 --> 00:39:14,100
when one service is changing the data

00:39:10,770 --> 00:39:19,530
scheme and the other one isn't Yeah

00:39:14,100 --> 00:39:21,180
right so yeah I didn't expect to have

00:39:19,530 --> 00:39:22,050
time to talk about this but glad glad

00:39:21,180 --> 00:39:25,740
you asked

00:39:22,050 --> 00:39:27,840
there are some rules so when you make

00:39:25,740 --> 00:39:29,460
upgrades to the data base that that's

00:39:27,840 --> 00:39:31,470
not the only case but if you make

00:39:29,460 --> 00:39:34,290
upgrades of the database they need to be

00:39:31,470 --> 00:39:36,600
backwards compatible always the same

00:39:34,290 --> 00:39:39,000
thing with the API so if your service

00:39:36,600 --> 00:39:42,900
you know your services exports an API

00:39:39,000 --> 00:39:44,940
that other services and clients use the

00:39:42,900 --> 00:39:47,190
if you make changes to that they cannot

00:39:44,940 --> 00:39:49,860
be breaking changes so in my example

00:39:47,190 --> 00:39:52,380
here when I went to before before to

00:39:49,860 --> 00:39:54,480
refine or over service I need to make

00:39:52,380 --> 00:39:56,130
sure that I can have before and d5

00:39:54,480 --> 00:39:59,520
running at the same time using the same

00:39:56,130 --> 00:40:01,890
database so usually if you need to make

00:39:59,520 --> 00:40:03,750
significant changes to your database you

00:40:01,890 --> 00:40:05,130
need to make them in stages you cannot

00:40:03,750 --> 00:40:07,890
make them like you know you cannot

00:40:05,130 --> 00:40:10,650
remove a column for example you can

00:40:07,890 --> 00:40:11,250
deprecated a column you know the plug

00:40:10,650 --> 00:40:13,619
upgrade

00:40:11,250 --> 00:40:15,630
once you know you're all upgraded only

00:40:13,619 --> 00:40:17,820
then would you make sure that no

00:40:15,630 --> 00:40:21,270
instances are using that column and then

00:40:17,820 --> 00:40:25,200
remove it in the second step it's more

00:40:21,270 --> 00:40:27,090
difficult yeah it's a pain actually okay

00:40:25,200 --> 00:40:29,640
one more question a very interesting

00:40:27,090 --> 00:40:32,369
talk thank you I've got one question if

00:40:29,640 --> 00:40:33,840
you split up your big application into

00:40:32,369 --> 00:40:36,750
many that keep the data in different

00:40:33,840 --> 00:40:40,350
databases how do you keep your database

00:40:36,750 --> 00:40:42,210
backups consistent how do you keep your

00:40:40,350 --> 00:40:43,950
arguing basically it services

00:40:42,210 --> 00:40:47,190
independent so you have to backup

00:40:43,950 --> 00:40:48,480
everything separately it can be in each

00:40:47,190 --> 00:40:50,359
on schedule if they don't need to be

00:40:48,480 --> 00:40:53,070
done in at the same time or anything

00:40:50,359 --> 00:40:54,960
okay so it's you have to split up your

00:40:53,070 --> 00:40:56,190
transaction so that what has to be in

00:40:54,960 --> 00:40:58,460
one transaction has to be the same

00:40:56,190 --> 00:41:02,570
database one mm-hmm okay thank you right

00:40:58,460 --> 00:41:05,820
okay we have time for one last question

00:41:02,570 --> 00:41:07,990
hello so if you're upgrading your

00:41:05,820 --> 00:41:10,450
database you were saying that the

00:41:07,990 --> 00:41:12,280
the instances of the micro-services

00:41:10,450 --> 00:41:14,650
should I have any data and they can be

00:41:12,280 --> 00:41:16,710
closed at any time but if you are

00:41:14,650 --> 00:41:19,540
upgrading the database how do you

00:41:16,710 --> 00:41:23,110
maintain the data because the services

00:41:19,540 --> 00:41:24,510
shouldn't be holding this data well so

00:41:23,110 --> 00:41:27,670
yeah basically that's the same question

00:41:24,510 --> 00:41:31,480
before it's difficult you have to design

00:41:27,670 --> 00:41:33,250
your database upgrades so that they are

00:41:31,480 --> 00:41:34,510
that they don't break existing

00:41:33,250 --> 00:41:38,230
application but there's a sitting

00:41:34,510 --> 00:41:41,470
version of the instance so the typically

00:41:38,230 --> 00:41:43,090
requires multiple stage approach to make

00:41:41,470 --> 00:41:46,360
significant changes and usually you try

00:41:43,090 --> 00:41:50,800
to avoid making big changes usually you

00:41:46,360 --> 00:41:52,780
add stuff but never remove or rename the

00:41:50,800 --> 00:41:56,770
opie because those are kind of expensive

00:41:52,780 --> 00:41:58,480
to deploy you know because of all the

00:41:56,770 --> 00:42:01,270
effort and the risk of breaking

00:41:58,480 --> 00:42:03,970
something so so yeah typically you start

00:42:01,270 --> 00:42:06,760
thinking you know probably now if you've

00:42:03,970 --> 00:42:08,140
never done it it sounds crazy and I will

00:42:06,760 --> 00:42:10,780
see that same position it's a couple

00:42:08,140 --> 00:42:13,300
years ago but but then you get used to

00:42:10,780 --> 00:42:15,430
that and then you start thinking in you

00:42:13,300 --> 00:42:17,700
know it you know designing the database

00:42:15,430 --> 00:42:20,890
you know so that you don't have to make

00:42:17,700 --> 00:42:23,350
breaking changes so often of course if

00:42:20,890 --> 00:42:25,450
you need to make a breaking change then

00:42:23,350 --> 00:42:26,770
you know you can make an exception and

00:42:25,450 --> 00:42:28,960
say ok this time I'm going to stop

00:42:26,770 --> 00:42:32,410
everything upgrade and start everything

00:42:28,960 --> 00:42:35,500
and then there's some downtime you can

00:42:32,410 --> 00:42:39,070
go that route to another option is to

00:42:35,500 --> 00:42:42,130
use not know sequel databases which I

00:42:39,070 --> 00:42:45,010
you know I'm a big fan ml guy so I am

00:42:42,130 --> 00:42:47,440
traditionally trained I liked relational

00:42:45,010 --> 00:42:49,660
but but I have to agree that you know

00:42:47,440 --> 00:42:52,210
for this type of architecture no sequel

00:42:49,660 --> 00:42:53,800
makes a lot of sense you know we'd be

00:42:52,210 --> 00:42:59,020
because it's a lot easier there's no

00:42:53,800 --> 00:43:02,310
schema true - and to deal with ok thank

00:42:59,020 --> 00:43:02,310
you very much Megan thank you

00:43:03,890 --> 00:43:05,950

YouTube URL: https://www.youtube.com/watch?v=CoDbnoaaiu0


