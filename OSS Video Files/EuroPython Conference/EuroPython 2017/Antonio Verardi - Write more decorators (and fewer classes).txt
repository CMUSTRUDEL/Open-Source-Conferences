Title: Antonio Verardi - Write more decorators (and fewer classes)
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Write more decorators (and fewer classes)
[EuroPython 2017 - Talk - 2017-07-11 - Anfiteatro 2]
[Rimini, Italy]

In the wake of famous talk “Stop Writing Classes” by Jack Diederich (https://www.youtube.com/watch?v=o9pEzgHorH0), I’d like to present a pattern that can be used to design clean and pythonic interfaces for programmers based on replacing single-method classes with decorated functions.

This pattern is already used by some famous frameworks and libraries, like Pyramid (https://trypyramid.com/), but I believe it isn’t that well-known to many (even experienced) Python developers and is not as widely used as it deserves.

I’ll show how this pattern can be employed to improve a programming interface which is used by an internal log processing framework at Yelp. This will demonstrate how a more functional approach, leveraging the power of Python decorators, can lead to simpler, more beautiful and easier to understand code.

However, this talk doesn’t suggest giving up classes altogether, but making use of them only when they are truly useful. In fact, the use-case I’m going to analyze will combine classes, functions, and decorators to make the best out of these tools.

Given that the presentation is going to be very code-oriented, the talk is intended for an audience of developers who are already familiar with most Python constructs, including decorators, even though the concept will be briefly introduced at the beginning of the talk. But, if you are one of these people, I promise you that the code will speak for itself.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,190 --> 00:00:09,650
hello thank you very much for coming

00:00:07,490 --> 00:00:10,700
my name is Antonio I'm a software

00:00:09,650 --> 00:00:13,849
engineer at Shell

00:00:10,700 --> 00:00:16,790
I work on the matrix team so what I

00:00:13,849 --> 00:00:18,439
currently do is working on observability

00:00:16,790 --> 00:00:23,180
and real-time metrics and real time

00:00:18,439 --> 00:00:25,189
processing y'all Commission I oh okay

00:00:23,180 --> 00:00:28,210
the OL mission is to connect people with

00:00:25,189 --> 00:00:31,570
great local businesses we are more than

00:00:28,210 --> 00:00:34,940
127 million reviews on our website and

00:00:31,570 --> 00:00:38,660
an average every month we do 26 million

00:00:34,940 --> 00:00:41,420
unique mobile devices accesses our via

00:00:38,660 --> 00:00:44,660
the Yelp wave up and 84 million unique

00:00:41,420 --> 00:00:46,850
visitors with a desktop with a desktop

00:00:44,660 --> 00:00:49,280
website we have offices all over the

00:00:46,850 --> 00:00:51,740
world and we are more than 400 engineers

00:00:49,280 --> 00:00:55,190
working both on the product and the

00:00:51,740 --> 00:00:57,260
infrastructure so adieu introduction

00:00:55,190 --> 00:00:59,750
before to start this talk has been

00:00:57,260 --> 00:01:02,329
inspired by the talk stop writing

00:00:59,750 --> 00:01:04,339
classes by Jackie Etheridge highly

00:01:02,329 --> 00:01:06,860
recommend you to watch the talk is great

00:01:04,339 --> 00:01:08,840
and by the blog posts the controller

00:01:06,860 --> 00:01:12,140
pattern is awful another objective

00:01:08,840 --> 00:01:16,460
oriented heresy by Evie again great blog

00:01:12,140 --> 00:01:17,509
was highly recommended all the code that

00:01:16,460 --> 00:01:19,569
you're going to see in this presentation

00:01:17,509 --> 00:01:22,670
and trust me is going to be quite a lot

00:01:19,569 --> 00:01:25,399
it's available on github at that URL so

00:01:22,670 --> 00:01:28,030
all the code runs and us test it filter

00:01:25,399 --> 00:01:31,549
clone it and play with it it's for you

00:01:28,030 --> 00:01:33,289
now I'd like to start from the very end

00:01:31,549 --> 00:01:37,579
of the talk with the main choose

00:01:33,289 --> 00:01:39,709
takeaways so they might make a little

00:01:37,579 --> 00:01:41,270
sense to you at the moment but keep them

00:01:39,709 --> 00:01:44,389
in mind maybe at the end there will be

00:01:41,270 --> 00:01:47,869
like you know cool ideas that you can

00:01:44,389 --> 00:01:51,139
use it your JJ job so the first one is

00:01:47,869 --> 00:01:54,109
let users utilize all Python features

00:01:51,139 --> 00:01:57,109
instead of just inheritance and the

00:01:54,109 --> 00:01:59,420
second one is go for decorators when

00:01:57,109 --> 00:02:02,439
your classes have only one method and

00:01:59,420 --> 00:02:06,020
that is ten ciated only once all right

00:02:02,439 --> 00:02:09,170
so what's this all about why we're here

00:02:06,020 --> 00:02:13,310
well this is the reason how many of you

00:02:09,170 --> 00:02:15,990
have ever used salary quite a few not

00:02:13,310 --> 00:02:18,630
nice nice well salary

00:02:15,990 --> 00:02:20,790
I think as job queue based on disability

00:02:18,630 --> 00:02:23,130
message-passing it is focused on

00:02:20,790 --> 00:02:26,010
real-time operation but also scheduling

00:02:23,130 --> 00:02:29,400
of this kind of stuff so the way you

00:02:26,010 --> 00:02:32,820
define a tasking salary is defining it

00:02:29,400 --> 00:02:35,670
up using the survey API and then calling

00:02:32,820 --> 00:02:37,440
the decorators tasks on the app object

00:02:35,670 --> 00:02:40,380
that you just created in order to

00:02:37,440 --> 00:02:42,870
decorate your tasks function so this is

00:02:40,380 --> 00:02:45,540
the first example on their website and

00:02:42,870 --> 00:02:48,570
this is the pattern then I'm gonna show

00:02:45,540 --> 00:02:50,670
you today this button is very very

00:02:48,570 --> 00:02:53,280
common actually and is used by a lot of

00:02:50,670 --> 00:02:55,830
cool frameworks for example you know

00:02:53,280 --> 00:02:58,590
flask right and flask is a micro

00:02:55,830 --> 00:03:01,620
framework for web development and the

00:02:58,590 --> 00:03:03,780
way you define logic for your routine

00:03:01,620 --> 00:03:06,210
flask is exactly the same as you define

00:03:03,780 --> 00:03:10,080
tasks and salaries you define a glass

00:03:06,210 --> 00:03:13,290
cup and then you call the root decorator

00:03:10,080 --> 00:03:16,920
over the objects you just created with

00:03:13,290 --> 00:03:18,660
some parameters in this case the URL you

00:03:16,920 --> 00:03:20,910
want that function to be executed for

00:03:18,660 --> 00:03:22,320
and then you just give it a function

00:03:20,910 --> 00:03:25,320
that is going to encapsulate the logic

00:03:22,320 --> 00:03:27,780
you want to execute this is a very

00:03:25,320 --> 00:03:30,480
common pattern for web frameworks in

00:03:27,780 --> 00:03:32,730
fact also the Vitamix frameworks use it

00:03:30,480 --> 00:03:34,770
in order to define views which are

00:03:32,730 --> 00:03:37,530
basically the same concept of routes in

00:03:34,770 --> 00:03:41,400
flask as you can see you just call the

00:03:37,530 --> 00:03:43,290
app view config decorator you pass key

00:03:41,400 --> 00:03:45,840
passing some arguments and then the

00:03:43,290 --> 00:03:47,040
function you decorate it it's going to

00:03:45,840 --> 00:03:50,850
be the logic that is going to be

00:03:47,040 --> 00:03:54,480
executed this is again the first example

00:03:50,850 --> 00:03:56,220
on their website now what about classes

00:03:54,480 --> 00:03:58,500
as you notice the name of the talk is

00:03:56,220 --> 00:04:03,690
Brightmore the creators and fewer

00:03:58,500 --> 00:04:06,360
classes so if you ever try to write a

00:04:03,690 --> 00:04:08,820
task in Python it's highly likely that

00:04:06,360 --> 00:04:11,160
you have read about unit test unit test

00:04:08,820 --> 00:04:12,660
is now in the from the Lib in Python 3

00:04:11,160 --> 00:04:15,420
so I guess is the recommended way of

00:04:12,660 --> 00:04:18,959
writing testing poisons and the way you

00:04:15,420 --> 00:04:22,200
do it is you define a class inheriting

00:04:18,959 --> 00:04:24,660
from unit test or test case and you

00:04:22,200 --> 00:04:26,460
define some test methods that are going

00:04:24,660 --> 00:04:27,780
to have your assertions in order to

00:04:26,460 --> 00:04:29,129
understand if your code is using the

00:04:27,780 --> 00:04:31,889
right fingers or at least

00:04:29,129 --> 00:04:34,709
aspect and in case you want to execute

00:04:31,889 --> 00:04:37,649
some setup butcher down methods what you

00:04:34,709 --> 00:04:40,110
do is that you override a metered with a

00:04:37,649 --> 00:04:44,399
specific signature in this case setup

00:04:40,110 --> 00:04:45,989
and ear you may do all your setup logic

00:04:44,399 --> 00:04:47,819
in this case for example what the

00:04:45,989 --> 00:04:51,089
example in the Python documentation does

00:04:47,819 --> 00:04:54,080
is associated a widget object and

00:04:51,089 --> 00:04:57,989
attaching it on the fly to test class

00:04:54,080 --> 00:05:00,239
now Titus

00:04:57,989 --> 00:05:04,309
which is an alternative framework to

00:05:00,239 --> 00:05:07,319
write tests avoid the usage of classes

00:05:04,309 --> 00:05:09,539
substituting them with the decorator so

00:05:07,319 --> 00:05:12,119
if you use the PI test doc pictures

00:05:09,539 --> 00:05:15,479
decorator in order to decorate your

00:05:12,119 --> 00:05:17,969
setup logic then even it across anymore

00:05:15,479 --> 00:05:21,959
and in order to access the object that

00:05:17,969 --> 00:05:24,329
is returned by your setup that setup

00:05:21,959 --> 00:05:26,989
function what you do is that you pass

00:05:24,329 --> 00:05:30,749
the name of the function to your test

00:05:26,989 --> 00:05:32,459
functions and it works magically so as

00:05:30,749 --> 00:05:35,129
you can see the interface is much more

00:05:32,459 --> 00:05:36,689
linear you can use all the function of

00:05:35,129 --> 00:05:38,969
the concept from functional programming

00:05:36,689 --> 00:05:43,499
at everything and well at the end the

00:05:38,969 --> 00:05:46,199
day is just shorter so that's cool at

00:05:43,499 --> 00:05:48,059
least that's what I think so I wanted to

00:05:46,199 --> 00:05:50,550
understand how you implement this stuff

00:05:48,059 --> 00:05:52,919
like how do you write these decorators

00:05:50,550 --> 00:05:56,129
in order to avoid using classes or to

00:05:52,919 --> 00:05:57,749
build clean interfaces well what do you

00:05:56,129 --> 00:05:59,519
do when you want to stand how some code

00:05:57,749 --> 00:06:02,849
works we go on get up the read the

00:05:59,519 --> 00:06:06,019
source right so I went to the practice

00:06:02,849 --> 00:06:09,360
project and this was the result it is

00:06:06,019 --> 00:06:12,149
kind of complicated so I say to myself

00:06:09,360 --> 00:06:16,139
well play test as a lot of magic maybe

00:06:12,149 --> 00:06:18,329
parameter is going to be easier nope it

00:06:16,139 --> 00:06:20,879
was you know with worse maybe but yeah

00:06:18,329 --> 00:06:23,069
again primate is a matured framework and

00:06:20,879 --> 00:06:25,309
there's a lot of business logic and

00:06:23,069 --> 00:06:29,789
handles a lot of you know corner cases

00:06:25,309 --> 00:06:33,269
so celery celery was simple right nope

00:06:29,789 --> 00:06:35,189
celery was the worst of all like as you

00:06:33,269 --> 00:06:37,259
can see it's a wallet code I have no

00:06:35,189 --> 00:06:38,610
idea how to put all this code probably

00:06:37,259 --> 00:06:42,059
because they want you to handle a lot of

00:06:38,610 --> 00:06:42,380
corner cases and so my reaction after

00:06:42,059 --> 00:06:46,630
see

00:06:42,380 --> 00:06:50,000
the celery implementation was this one

00:06:46,630 --> 00:06:53,330
and I say to myself decorators are hard

00:06:50,000 --> 00:06:56,990
I'm not going to use them so who believe

00:06:53,330 --> 00:07:00,230
this sentence is true no one looks cool

00:06:56,990 --> 00:07:04,130
let's go or maybe someone there well

00:07:00,230 --> 00:07:06,140
it's actually not entirely correct

00:07:04,130 --> 00:07:08,590
a few months later I looked more into

00:07:06,140 --> 00:07:11,570
how the creators works in fighting and

00:07:08,590 --> 00:07:15,260
basically the way they work is that you

00:07:11,570 --> 00:07:17,030
define a function which receives as an

00:07:15,260 --> 00:07:19,160
argument the function you want to

00:07:17,030 --> 00:07:21,680
decorate and the result of the

00:07:19,160 --> 00:07:25,880
decorative function is assigned to the

00:07:21,680 --> 00:07:29,480
function name that's pretty easy right

00:07:25,880 --> 00:07:32,390
and in case you want to pass arguments

00:07:29,480 --> 00:07:34,580
to your decorator the way it works is

00:07:32,390 --> 00:07:36,320
that the decorator function is going to

00:07:34,580 --> 00:07:38,690
be called with the arguments before and

00:07:36,320 --> 00:07:40,580
then the result is going to use is going

00:07:38,690 --> 00:07:43,400
to be used as decorators and we have

00:07:40,580 --> 00:07:45,860
just seen and in case you have more than

00:07:43,400 --> 00:07:48,350
one decorator the way to get execute is

00:07:45,860 --> 00:07:50,300
that the closest one to the function

00:07:48,350 --> 00:07:51,200
that you want to decorate gets executed

00:07:50,300 --> 00:07:53,180
first

00:07:51,200 --> 00:07:57,350
and the result gets passed to the

00:07:53,180 --> 00:07:59,720
decorator this upper level so actually I

00:07:57,350 --> 00:08:02,180
change my stance up to that and so I

00:07:59,720 --> 00:08:05,540
decided decorators are pretty easy to

00:08:02,180 --> 00:08:08,480
use but maybe I just are too right well

00:08:05,540 --> 00:08:11,990
this is not entirely true as well so

00:08:08,480 --> 00:08:16,940
this is the simplest decorator ever made

00:08:11,990 --> 00:08:19,730
I guess as you can see what it does is

00:08:16,940 --> 00:08:23,060
just when decorating the function it

00:08:19,730 --> 00:08:25,640
prints decorating function with useless

00:08:23,060 --> 00:08:28,310
but it's a decorator and it works in

00:08:25,640 --> 00:08:30,770
fact if we execute it in the Python

00:08:28,310 --> 00:08:32,330
interpreter that's what we get the first

00:08:30,770 --> 00:08:33,860
time we import the function the

00:08:32,330 --> 00:08:35,810
decorator function is going to be

00:08:33,860 --> 00:08:38,810
executed and decorating function is

00:08:35,810 --> 00:08:40,849
going to be is going to be on the output

00:08:38,810 --> 00:08:43,099
and then every time we execute the

00:08:40,849 --> 00:08:46,520
function nothing happens to just execute

00:08:43,099 --> 00:08:49,340
the regular function so after these

00:08:46,520 --> 00:08:53,540
maybe you can think the decorators are

00:08:49,340 --> 00:08:54,370
easy to write again that is not entirely

00:08:53,540 --> 00:08:57,430
true

00:08:54,370 --> 00:08:59,230
so in case you want to implement the

00:08:57,430 --> 00:09:04,270
regulator with arguments as we saw

00:08:59,230 --> 00:09:07,450
before the way you do it is defining a

00:09:04,270 --> 00:09:10,180
linear function in your decorator

00:09:07,450 --> 00:09:12,100
function and the döner function is going

00:09:10,180 --> 00:09:13,990
to be the real decorator the one that we

00:09:12,100 --> 00:09:17,140
saw before so they were receiving the

00:09:13,990 --> 00:09:19,150
function as first argument while instead

00:09:17,140 --> 00:09:22,270
you can use the arguments that you pass

00:09:19,150 --> 00:09:25,690
to your ideal decorator in any other

00:09:22,270 --> 00:09:29,320
part to the function itself so the way

00:09:25,690 --> 00:09:31,660
it works for this decorator implemented

00:09:29,320 --> 00:09:34,870
over here is that when the function gets

00:09:31,660 --> 00:09:37,630
imported it prints decorating function

00:09:34,870 --> 00:09:39,070
with far impulse which are that you

00:09:37,630 --> 00:09:41,560
arguments will be passed to the

00:09:39,070 --> 00:09:43,210
decorator and then when the function

00:09:41,560 --> 00:09:47,200
runs the function runs without any

00:09:43,210 --> 00:09:48,760
modification at all now if you want to

00:09:47,200 --> 00:09:51,340
do something more useful with our

00:09:48,760 --> 00:09:53,680
decorators like for example changing the

00:09:51,340 --> 00:09:56,200
way the function is called or saving the

00:09:53,680 --> 00:09:59,350
result into a cache and the kind of

00:09:56,200 --> 00:10:01,300
stuff we need a proper function as well

00:09:59,350 --> 00:10:03,160
there's going to be in define inside

00:10:01,300 --> 00:10:05,590
your decorator function and these

00:10:03,160 --> 00:10:07,600
brother functions receive an argument

00:10:05,590 --> 00:10:09,430
for arguments the arguments of the

00:10:07,600 --> 00:10:11,620
function you want to decorate so piece

00:10:09,430 --> 00:10:14,680
of advice if you want to write code that

00:10:11,620 --> 00:10:16,360
is reusable just use args and kwargs so

00:10:14,680 --> 00:10:17,800
you need to care about what the function

00:10:16,360 --> 00:10:21,460
you're going to decorate is taking as

00:10:17,800 --> 00:10:24,430
parameter and the way this the greater

00:10:21,460 --> 00:10:26,980
function works is that again when

00:10:24,430 --> 00:10:29,110
executed in the interpreter it decorates

00:10:26,980 --> 00:10:32,200
the function and add import time it

00:10:29,110 --> 00:10:35,050
prints decorating function and now every

00:10:32,200 --> 00:10:37,030
time we call the function the code that

00:10:35,050 --> 00:10:38,740
we've written in the ruptor function

00:10:37,030 --> 00:10:41,410
inside the decorator function is going

00:10:38,740 --> 00:10:45,510
to be executed before the function get a

00:10:41,410 --> 00:10:48,640
security for real now with that in mind

00:10:45,510 --> 00:10:51,790
my stencil decorator is that they're

00:10:48,640 --> 00:10:54,580
neither easy or are just a bit tedious

00:10:51,790 --> 00:10:56,740
to write you see quite a few corner

00:10:54,580 --> 00:10:58,210
cases to remember what once you know how

00:10:56,740 --> 00:11:00,820
to write them once you have this free

00:10:58,210 --> 00:11:02,790
example in front of you but it's kind of

00:11:00,820 --> 00:11:05,980
gay I mean it doesn't take much time and

00:11:02,790 --> 00:11:07,590
in fact if we look at a flask framework

00:11:05,980 --> 00:11:10,440
which is a great piece of soft

00:11:07,590 --> 00:11:13,500
in my opinion this is the way they

00:11:10,440 --> 00:11:15,300
implement their decorator which is not

00:11:13,500 --> 00:11:17,130
much different to what we saw before and

00:11:15,300 --> 00:11:18,950
it's much much simpler than all the

00:11:17,130 --> 00:11:22,950
others decorator we've seen and so far

00:11:18,950 --> 00:11:25,050
so basically in the classic class which

00:11:22,950 --> 00:11:27,930
is the one we use to instantiate the up

00:11:25,050 --> 00:11:30,029
object we define a root method which

00:11:27,930 --> 00:11:32,550
takes some parameters and since its

00:11:30,029 --> 00:11:35,040
decorator that takes some parameters we

00:11:32,550 --> 00:11:37,020
need an inner function and the signal

00:11:35,040 --> 00:11:38,040
function is the actual decorator and in

00:11:37,020 --> 00:11:41,540
the actual decorator

00:11:38,040 --> 00:11:44,040
what fluff does is defining an end point

00:11:41,540 --> 00:11:45,839
using the options parameter that we

00:11:44,040 --> 00:11:47,700
provided and then adding the rules

00:11:45,839 --> 00:11:49,260
further than point to the app and it

00:11:47,700 --> 00:11:55,080
returns the function and the returns the

00:11:49,260 --> 00:11:57,480
inner function so my talk was supposed

00:11:55,080 --> 00:11:59,400
to stop here to finish here but then I

00:11:57,480 --> 00:12:01,950
noticed I booked the 45-minute slot

00:11:59,400 --> 00:12:04,700
instead of a 15-minute slot so I decided

00:12:01,950 --> 00:12:07,230
to go for a real life example

00:12:04,700 --> 00:12:09,450
so basically we're not going to see

00:12:07,230 --> 00:12:11,370
decorators for a while what we're going

00:12:09,450 --> 00:12:14,580
to do is looking at the class based

00:12:11,370 --> 00:12:16,860
interface that these example implements

00:12:14,580 --> 00:12:19,470
and then we're going to look and how we

00:12:16,860 --> 00:12:21,650
can revise it with decorators so the

00:12:19,470 --> 00:12:24,180
example I want to take is start monster

00:12:21,650 --> 00:12:26,820
stop monster is a real internal

00:12:24,180 --> 00:12:29,250
framework that we use itself to extract

00:12:26,820 --> 00:12:32,610
real-time metrics out of logs where logs

00:12:29,250 --> 00:12:34,140
are just stream of events and there's no

00:12:32,610 --> 00:12:36,510
really important for the presentation

00:12:34,140 --> 00:12:39,360
we'll just give you much more context so

00:12:36,510 --> 00:12:41,760
the way that monster works is that it

00:12:39,360 --> 00:12:43,920
consumes log from Apache Kafka which is

00:12:41,760 --> 00:12:47,760
a disability streaming platform usually

00:12:43,920 --> 00:12:50,520
used to you know good flow like carry

00:12:47,760 --> 00:12:52,530
log around your infrastructure and then

00:12:50,520 --> 00:12:56,060
it does some custom logic which is

00:12:52,530 --> 00:12:58,950
implemented by the users via an API and

00:12:56,060 --> 00:13:01,740
emits some metrics to signal effects

00:12:58,950 --> 00:13:03,660
which is a third party services that we

00:13:01,740 --> 00:13:06,540
use in order to visualize and analyze

00:13:03,660 --> 00:13:08,459
our metrics and Kairos DB which is a

00:13:06,540 --> 00:13:10,740
fast distributed scalable time series

00:13:08,459 --> 00:13:14,480
data base on top of Cassandra we

00:13:10,740 --> 00:13:17,520
maintained internally so to reiterate

00:13:14,480 --> 00:13:21,320
the input force that monster our logs

00:13:17,520 --> 00:13:23,030
and the outputs of actually metrics

00:13:21,320 --> 00:13:25,610
this is an example or what the monster

00:13:23,030 --> 00:13:27,920
does so in this example we see that the

00:13:25,610 --> 00:13:30,440
input is a lot line which is JSON

00:13:27,920 --> 00:13:33,020
formatted with some information then

00:13:30,440 --> 00:13:35,660
some user code gets executed inside that

00:13:33,020 --> 00:13:38,960
monster starts motor starts monster

00:13:35,660 --> 00:13:41,000
emits a timing matrix so basically just

00:13:38,960 --> 00:13:44,570
you know I mean the result of a function

00:13:41,000 --> 00:13:47,860
or something female which has a name at

00:13:44,570 --> 00:13:50,240
times them a value and the dictionary of

00:13:47,860 --> 00:13:53,420
attributes that we call dimensions in

00:13:50,240 --> 00:13:55,640
the metrics world now let's look at the

00:13:53,420 --> 00:13:59,480
matrix interface the matrix interface

00:13:55,640 --> 00:14:02,690
it's composed by three little pieces the

00:13:59,480 --> 00:14:05,810
first one is an anoon defining the two

00:14:02,690 --> 00:14:07,700
kind of metrics that you can emit which

00:14:05,810 --> 00:14:09,860
are basically just counters in order to

00:14:07,700 --> 00:14:12,500
counter lines and timers you know just

00:14:09,860 --> 00:14:14,540
kind them then we have the metric

00:14:12,500 --> 00:14:17,810
definition we use the name trouble here

00:14:14,540 --> 00:14:21,530
and a metric as we say as always a name

00:14:17,810 --> 00:14:23,600
a timestamp a value dictionary of tags

00:14:21,530 --> 00:14:26,600
which we call dimensions and the type

00:14:23,600 --> 00:14:30,230
and at the very end we define two

00:14:26,600 --> 00:14:32,360
commodity functions in order to give the

00:14:30,230 --> 00:14:34,400
user the possibility to instantiate a

00:14:32,360 --> 00:14:38,990
counter and the timer without providing

00:14:34,400 --> 00:14:41,590
the type is impartial okay so let's look

00:14:38,990 --> 00:14:44,480
at the input interface stats so the logs

00:14:41,590 --> 00:14:48,950
so this is where this is where the class

00:14:44,480 --> 00:14:54,170
is already coming play basically the way

00:14:48,950 --> 00:14:56,630
a lot class is define is defining at a

00:14:54,170 --> 00:14:59,030
coded function which is going to use in

00:14:56,630 --> 00:15:01,520
order to decode your load line in these

00:14:59,030 --> 00:15:03,860
case we provide the JSON decoding as

00:15:01,520 --> 00:15:06,800
default where you can just authorize

00:15:03,860 --> 00:15:08,900
these defaults just setting your custom

00:15:06,800 --> 00:15:13,100
decoding function as a class attribute

00:15:08,900 --> 00:15:15,440
and then the base class which you are

00:15:13,100 --> 00:15:17,210
seeing at the moment just define the

00:15:15,440 --> 00:15:20,120
code class method which is going to be

00:15:17,210 --> 00:15:22,640
used to the code log line and the second

00:15:20,120 --> 00:15:23,060
thing is the name of the log you want to

00:15:22,640 --> 00:15:25,730
tail

00:15:23,060 --> 00:15:28,940
so structure is a dynamic system so the

00:15:25,730 --> 00:15:31,220
way it works just inspect at runtime all

00:15:28,940 --> 00:15:34,550
the classes defined in the framework and

00:15:31,220 --> 00:15:37,250
it checks for this name field

00:15:34,550 --> 00:15:41,360
and just sales from Kafka all the logs

00:15:37,250 --> 00:15:43,100
named this way so if we want to

00:15:41,360 --> 00:15:45,170
implement a log just say to start

00:15:43,100 --> 00:15:47,060
monster tail this log for me that's the

00:15:45,170 --> 00:15:50,390
way we do it it's pretty easy it's

00:15:47,060 --> 00:15:52,670
reasonable so we just subclass the log

00:15:50,390 --> 00:15:56,510
base class and we just provide the name

00:15:52,670 --> 00:15:58,760
in this case event now in case you want

00:15:56,510 --> 00:16:00,950
to provide your custom decoding function

00:15:58,760 --> 00:16:02,600
the way you do it is just that you

00:16:00,950 --> 00:16:05,660
define your function at the very

00:16:02,600 --> 00:16:08,300
beginning and then you set up the

00:16:05,660 --> 00:16:11,690
decoding function as a class attribute

00:16:08,300 --> 00:16:15,589
of the log now let's look at the stock

00:16:11,690 --> 00:16:18,110
muscle interface so the real code is the

00:16:15,589 --> 00:16:20,480
fat muscle interface is based on the

00:16:18,110 --> 00:16:23,000
concept of trigger a trigger is a class

00:16:20,480 --> 00:16:26,450
which encapsulate the logic to struct

00:16:23,000 --> 00:16:29,839
metrics from logs and this is the base

00:16:26,450 --> 00:16:33,560
rigor class it has very few things so

00:16:29,839 --> 00:16:35,240
the first one is defining donors for

00:16:33,560 --> 00:16:38,420
every trigger so we always know which

00:16:35,240 --> 00:16:42,620
team is responsible which logic and what

00:16:38,420 --> 00:16:44,240
it does is asserting the owner then this

00:16:42,620 --> 00:16:46,430
field is going to be a list of strings

00:16:44,240 --> 00:16:49,100
there is no way for us to encode this

00:16:46,430 --> 00:16:50,660
information in Python and so we decided

00:16:49,100 --> 00:16:53,750
to start fighting a little bit of a

00:16:50,660 --> 00:16:55,339
tutorial so people could read it and you

00:16:53,750 --> 00:16:57,440
know understand what they need to pass

00:16:55,339 --> 00:17:01,279
to the function to the to the class and

00:16:57,440 --> 00:17:04,160
then every trigger needs to implement a

00:17:01,279 --> 00:17:07,160
digest meter the digest method is what

00:17:04,160 --> 00:17:10,730
is used to transform the decoded log

00:17:07,160 --> 00:17:13,819
line into metrics actually in the it's

00:17:10,730 --> 00:17:16,490
supposed to be a generator and it's

00:17:13,819 --> 00:17:19,339
feeding the soil as well so this is the

00:17:16,490 --> 00:17:21,140
chorus at master this is all the logic

00:17:19,339 --> 00:17:24,140
that really matters and that's the

00:17:21,140 --> 00:17:26,059
process function that receive the log we

00:17:24,140 --> 00:17:29,270
are consuming from the line we just

00:17:26,059 --> 00:17:32,059
consumed and then it iterates over all

00:17:29,270 --> 00:17:35,660
the triggers and it tries to yield from

00:17:32,059 --> 00:17:38,330
the digest method called on the entry so

00:17:35,660 --> 00:17:40,580
the decoded load line and in case of any

00:17:38,330 --> 00:17:45,530
exception it sends an email to the

00:17:40,580 --> 00:17:48,419
owners now this is the way a user

00:17:45,530 --> 00:17:51,269
basically instruments

00:17:48,419 --> 00:17:54,059
muster to consume a log and then to omit

00:17:51,269 --> 00:17:56,340
some metrics out of it so as you can see

00:17:54,059 --> 00:17:58,980
you first define the log as we saw

00:17:56,340 --> 00:18:01,100
before then you define the owners for

00:17:58,980 --> 00:18:03,779
your trigger in this case just me and

00:18:01,100 --> 00:18:07,409
then you define your digest function

00:18:03,779 --> 00:18:09,659
your digest needed what it does at least

00:18:07,409 --> 00:18:12,239
for this trigger is just yielding a

00:18:09,659 --> 00:18:16,859
counter saying we saw an event with this

00:18:12,239 --> 00:18:19,049
timestamp and we just count one here it

00:18:16,859 --> 00:18:21,659
is another example you define the

00:18:19,049 --> 00:18:23,340
resource usage log you define your

00:18:21,659 --> 00:18:26,580
trigger with your list of owners and

00:18:23,340 --> 00:18:29,999
then in the day just needed ear we loop

00:18:26,580 --> 00:18:32,700
over just a custom double as time a new

00:18:29,999 --> 00:18:36,359
time and we meet two timing matrix based

00:18:32,700 --> 00:18:39,690
on the content of the of the log line so

00:18:36,359 --> 00:18:42,779
this all work fine we publish a tutorial

00:18:39,690 --> 00:18:44,850
and we start to have some users but then

00:18:42,779 --> 00:18:47,850
we realize that our users and not just

00:18:44,850 --> 00:18:49,169
regular users they are engineers and you

00:18:47,850 --> 00:18:51,359
know what the probability engineers is

00:18:49,169 --> 00:18:53,399
right you give them a Lego set and then

00:18:51,359 --> 00:18:57,629
they build a flying depth stars out of

00:18:53,399 --> 00:18:59,669
it so the first question we got as soon

00:18:57,629 --> 00:19:02,249
as we release the tutorial and saucer

00:18:59,669 --> 00:19:09,629
was out doing Eric's from a base load

00:19:02,249 --> 00:19:13,710
class well I didn't think about it so I

00:19:09,629 --> 00:19:17,609
answered well let's let's do so so you

00:19:13,710 --> 00:19:21,210
define a module starting it underscore

00:19:17,609 --> 00:19:23,759
and here you define your base load class

00:19:21,210 --> 00:19:25,739
in this case what the base log class is

00:19:23,759 --> 00:19:30,809
doing is basically providing the decoder

00:19:25,739 --> 00:19:34,139
for Apache log lines and now with a bit

00:19:30,809 --> 00:19:37,710
of magic we tell that monster not to

00:19:34,139 --> 00:19:40,739
look for these underscore prefixes

00:19:37,710 --> 00:19:44,399
modules so we don't start consuming logs

00:19:40,739 --> 00:19:45,989
that don't exist okay that's cool

00:19:44,399 --> 00:19:48,090
so that's the way you use this kind of

00:19:45,989 --> 00:19:50,070
base classes in your regular module you

00:19:48,090 --> 00:19:52,440
just import them and you set the name of

00:19:50,070 --> 00:19:54,690
the lock you want to consume pretty easy

00:19:52,440 --> 00:19:55,800
the updated tutorial and we thought we

00:19:54,690 --> 00:19:59,370
were okay

00:19:55,800 --> 00:20:02,430
well it was wrong because as soon as

00:19:59,370 --> 00:20:05,160
updated the tutorial we got these other

00:20:02,430 --> 00:20:07,500
question I'll drain Eric from the base

00:20:05,160 --> 00:20:09,210
triggered class because now I saw you I

00:20:07,500 --> 00:20:11,930
can inherit load class so I want trainer

00:20:09,210 --> 00:20:13,980
it triggers classes as well all right

00:20:11,930 --> 00:20:18,840
didn't find they didn't think about it

00:20:13,980 --> 00:20:21,450
either so what we decided to do was

00:20:18,840 --> 00:20:25,620
basically reusing the same pattern so in

00:20:21,450 --> 00:20:29,070
these same underscore module you define

00:20:25,620 --> 00:20:33,240
your pastry girl with some logic in this

00:20:29,070 --> 00:20:35,700
case for example you ask the user to set

00:20:33,240 --> 00:20:39,000
the metric name and the endpoints that

00:20:35,700 --> 00:20:42,900
are written in the load line as class

00:20:39,000 --> 00:20:46,320
attributes and then you also ask him to

00:20:42,900 --> 00:20:49,950
implement your get additional dimensions

00:20:46,320 --> 00:20:51,990
maitreya needed for example where you

00:20:49,950 --> 00:20:54,000
can actually customize the matrix you

00:20:51,990 --> 00:20:56,820
are going to meet and then you provide a

00:20:54,000 --> 00:20:59,490
digest function who does some logic and

00:20:56,820 --> 00:21:02,730
cause the get additional dimension

00:20:59,490 --> 00:21:04,950
needed and uses the endpoint and the

00:21:02,730 --> 00:21:09,960
metric name that you defined as class

00:21:04,950 --> 00:21:13,890
attributes and at the end yield the

00:21:09,960 --> 00:21:17,490
counter so with a bit of magic we say to

00:21:13,890 --> 00:21:20,070
start monster again just don't look for

00:21:17,490 --> 00:21:23,250
these underscore modules for triggers as

00:21:20,070 --> 00:21:26,340
well and that's the way you use them so

00:21:23,250 --> 00:21:29,640
you just import them and then you just

00:21:26,340 --> 00:21:31,950
set those owners and point symmetric

00:21:29,640 --> 00:21:34,460
named attributes for the sub cost and

00:21:31,950 --> 00:21:36,570
then you implement the get additional

00:21:34,460 --> 00:21:39,960
dimensions in order to customize your

00:21:36,570 --> 00:21:42,180
Mattox and that's it it works so again

00:21:39,960 --> 00:21:44,520
the updated tutorial is starts to be a

00:21:42,180 --> 00:21:48,330
bit long our users were happy for like

00:21:44,520 --> 00:21:50,990
24 hours because then I got this

00:21:48,330 --> 00:21:57,050
question out generates from two

00:21:50,990 --> 00:21:57,050
triggered classes at the same time well

00:21:57,159 --> 00:22:00,850
I didn't think about it either but you

00:21:59,320 --> 00:22:02,950
know Python supports multiple

00:22:00,850 --> 00:22:08,019
inheritance so we started to occur

00:22:02,950 --> 00:22:12,490
around it and our answer was you just

00:22:08,019 --> 00:22:15,309
don't so let's keep things simple you

00:22:12,490 --> 00:22:19,750
implement your base class some logic and

00:22:15,309 --> 00:22:22,299
then you inherit from me in your other

00:22:19,750 --> 00:22:26,230
base class and you define some other

00:22:22,299 --> 00:22:28,419
logic and then what you do is that

00:22:26,230 --> 00:22:30,340
define another base class while you're

00:22:28,419 --> 00:22:33,450
still in areas from it and you define

00:22:30,340 --> 00:22:37,690
some other logic and then in your real

00:22:33,450 --> 00:22:39,610
module you just subclass from both of

00:22:37,690 --> 00:22:43,240
them and provides them the same

00:22:39,610 --> 00:22:46,240
parameters as class attributes so I get

00:22:43,240 --> 00:22:48,389
it this is not ideal but as long as it's

00:22:46,240 --> 00:22:51,879
documented is going to be okay right

00:22:48,389 --> 00:22:53,860
then after more or less one week we got

00:22:51,879 --> 00:22:56,980
the first code review in for adding a

00:22:53,860 --> 00:22:59,230
new trigger and this is the first

00:22:56,980 --> 00:23:01,240
question we got but all three tests my

00:22:59,230 --> 00:23:04,720
trigger class because you want to write

00:23:01,240 --> 00:23:06,360
tests right well guess what this time I

00:23:04,720 --> 00:23:10,330
was prepared

00:23:06,360 --> 00:23:12,100
you remember fighters right so the way

00:23:10,330 --> 00:23:14,320
you can test your trigger is just

00:23:12,100 --> 00:23:16,299
defining the fixture in fighters when

00:23:14,320 --> 00:23:18,700
you return based on CA ssin of the

00:23:16,299 --> 00:23:22,870
trigger you want to test and then what

00:23:18,700 --> 00:23:26,169
you do you call the digest method on the

00:23:22,870 --> 00:23:29,019
trigger and you test a certain matrix is

00:23:26,169 --> 00:23:33,419
in it's in the result of the digest

00:23:29,019 --> 00:23:38,519
method easy one minute after he asked me

00:23:33,419 --> 00:23:42,279
but how do I test my base trigger class

00:23:38,519 --> 00:23:46,299
right what's the difference I understand

00:23:42,279 --> 00:23:49,419
oh if you look at this class it inherits

00:23:46,299 --> 00:23:52,929
from service based rigor and service

00:23:49,419 --> 00:23:55,629
based rigor in it's in it asserts that

00:23:52,929 --> 00:23:59,169
the derived class define a metric name

00:23:55,629 --> 00:24:03,220
at the same time a daenerys from trigger

00:23:59,169 --> 00:24:05,370
which in this init Affairs that it

00:24:03,220 --> 00:24:08,970
defines owners as well

00:24:05,370 --> 00:24:11,130
so you cannot really sincere it because

00:24:08,970 --> 00:24:13,800
the assertion is going to fail I was

00:24:11,130 --> 00:24:15,570
very puzzled by this like I stayed one

00:24:13,800 --> 00:24:17,970
day thinking about this even under the

00:24:15,570 --> 00:24:20,190
shower I didn't find any good solution

00:24:17,970 --> 00:24:23,790
but then a colleague of mine came up

00:24:20,190 --> 00:24:26,760
with very good idea let's use in the

00:24:23,790 --> 00:24:28,950
tightest picture the type function of

00:24:26,760 --> 00:24:32,820
pythons chloride so with a type function

00:24:28,950 --> 00:24:36,120
you can associate a subclass of a

00:24:32,820 --> 00:24:38,690
certain class at runtime and also you

00:24:36,120 --> 00:24:44,760
can provide plus attribute as a

00:24:38,690 --> 00:24:47,310
dictionary that worked and we updated

00:24:44,760 --> 00:24:48,980
tutorial it started to be long enough

00:24:47,310 --> 00:24:53,790
that people didn't want to read it and

00:24:48,980 --> 00:24:56,790
yes I guess it's okay but let's try to

00:24:53,790 --> 00:24:59,610
make things better right so I'm going to

00:24:56,790 --> 00:25:02,220
demonstrate you that my face because

00:24:59,610 --> 00:25:04,280
using the grader was this one and after

00:25:02,220 --> 00:25:09,180
switching to a decorator base interface

00:25:04,280 --> 00:25:12,210
you change it up to ds1 so looking back

00:25:09,180 --> 00:25:15,480
at the sub master module we got logs of

00:25:12,210 --> 00:25:18,720
input and metrics as output so what's

00:25:15,480 --> 00:25:22,080
missing here what is missing is the

00:25:18,720 --> 00:25:24,000
trigger what is the trigger so we say

00:25:22,080 --> 00:25:26,930
the trigger it's a class that

00:25:24,000 --> 00:25:31,770
encapsulates the logic to transform logs

00:25:26,930 --> 00:25:34,890
to metrics so just get rid of it it

00:25:31,770 --> 00:25:36,750
doesn't have any actual reference to the

00:25:34,890 --> 00:25:39,390
real model there's just an abstraction

00:25:36,750 --> 00:25:42,960
that we constructed ourselves why do we

00:25:39,390 --> 00:25:46,950
did in the first place no idea so let's

00:25:42,960 --> 00:25:50,460
remove it and let's not force people to

00:25:46,950 --> 00:25:53,730
utilize just inheritance for the

00:25:50,460 --> 00:25:55,860
interface let's give them the power to

00:25:53,730 --> 00:26:00,030
use all the features that Python

00:25:55,860 --> 00:26:02,370
provides so in the new interface the

00:26:00,030 --> 00:26:05,400
metrics interface stays exactly the same

00:26:02,370 --> 00:26:07,350
no modifications the logs interface

00:26:05,400 --> 00:26:10,830
started already to change a bit

00:26:07,350 --> 00:26:13,740
so instead of using classes only there

00:26:10,830 --> 00:26:15,780
are sub crossings we decided to give the

00:26:13,740 --> 00:26:18,290
user the ability to just use classes

00:26:15,780 --> 00:26:20,660
either work as they were meant to be you

00:26:18,290 --> 00:26:23,390
by Verizon so you can officiate your

00:26:20,660 --> 00:26:25,400
class this time and you pass the name of

00:26:23,390 --> 00:26:29,480
the log and the decoder function as

00:26:25,400 --> 00:26:32,030
parameters of the image needed and no

00:26:29,480 --> 00:26:36,170
more session over here and the code

00:26:32,030 --> 00:26:39,190
class method now became simple method

00:26:36,170 --> 00:26:43,040
the only real difference from before is

00:26:39,190 --> 00:26:46,130
that now every log class defines an

00:26:43,040 --> 00:26:49,130
empty set of functions those functions

00:26:46,130 --> 00:26:50,660
are what organ are basically the

00:26:49,130 --> 00:26:54,110
equivalents of triggers in the new

00:26:50,660 --> 00:26:56,150
interface now this is the way you define

00:26:54,110 --> 00:26:58,490
a log in the new stuff monster you just

00:26:56,150 --> 00:27:01,340
use the class that's it you don't even

00:26:58,490 --> 00:27:04,940
need a file for each log we're just usin

00:27:01,340 --> 00:27:06,290
ciated with the name and it works and in

00:27:04,940 --> 00:27:08,930
case you want to pass seeing your own

00:27:06,290 --> 00:27:11,870
decode function you just call the cloth

00:27:08,930 --> 00:27:14,690
and you pass the parameter let's see

00:27:11,870 --> 00:27:16,910
it's already much cleaner but now let's

00:27:14,690 --> 00:27:19,370
look at the sub master interface so

00:27:16,910 --> 00:27:21,950
first of all the process function stayed

00:27:19,370 --> 00:27:25,670
exactly the same but we came a method of

00:27:21,950 --> 00:27:28,340
the log class and again we the only

00:27:25,670 --> 00:27:31,190
thing we did was substituting the

00:27:28,340 --> 00:27:35,600
trigger with the functions set that is

00:27:31,190 --> 00:27:37,970
attached to the log class now this is

00:27:35,600 --> 00:27:40,430
the way we wanted the user to utilize

00:27:37,970 --> 00:27:42,680
the new interface the way you define

00:27:40,430 --> 00:27:46,030
some logic in orders just from your logs

00:27:42,680 --> 00:27:48,140
to matrix is now importing your log

00:27:46,030 --> 00:27:52,940
objects that you created somewhere else

00:27:48,140 --> 00:27:56,750
and then calling a decorator method on

00:27:52,940 --> 00:27:59,630
top of the object also using another

00:27:56,750 --> 00:28:01,790
decorator to passing the owners method

00:27:59,630 --> 00:28:04,040
out of the function and just stuff

00:28:01,790 --> 00:28:06,440
define the function the function is

00:28:04,040 --> 00:28:08,630
exactly the digest meat of the first

00:28:06,440 --> 00:28:11,690
trigger we saw without any modification

00:28:08,630 --> 00:28:16,910
you just remove all the class thinking

00:28:11,690 --> 00:28:19,850
and basically the way the decorator is

00:28:16,910 --> 00:28:24,410
implemented it's the simplest decorator

00:28:19,850 --> 00:28:27,860
ever what it does we just receive the

00:28:24,410 --> 00:28:31,630
function as an argument and just adds it

00:28:27,860 --> 00:28:36,910
to the set that is already attached

00:28:31,630 --> 00:28:42,190
to the log class that's it now this is

00:28:36,910 --> 00:28:44,940
even simpler than flask and in case we

00:28:42,190 --> 00:28:47,500
want to provide some more helpful

00:28:44,940 --> 00:28:49,900
decorators like for example this one

00:28:47,500 --> 00:28:51,580
which makes you able to register the

00:28:49,900 --> 00:28:54,640
same function for multiple logs at the

00:28:51,580 --> 00:28:56,170
same time what we can do is implement a

00:28:54,640 --> 00:28:58,600
decorator with arguments and the

00:28:56,170 --> 00:29:02,320
arguments is basically the list of logs

00:28:58,600 --> 00:29:04,420
and in this case what we need is just an

00:29:02,320 --> 00:29:06,670
inner function where we iterate over the

00:29:04,420 --> 00:29:08,560
log and we call the register method once

00:29:06,670 --> 00:29:12,100
again because remember it's decorator

00:29:08,560 --> 00:29:14,530
but at the same time is minted and in

00:29:12,100 --> 00:29:16,630
case we want to implement this owners

00:29:14,530 --> 00:29:19,840
decorator that gives some metadata to

00:29:16,630 --> 00:29:23,280
the function what we do is exactly the

00:29:19,840 --> 00:29:26,470
same as before we pass it the endless as

00:29:23,280 --> 00:29:29,650
parameters of the function and we just

00:29:26,470 --> 00:29:31,240
attach on the fly the end lers to the

00:29:29,650 --> 00:29:33,220
function because every function in

00:29:31,240 --> 00:29:35,350
python is also an object so i know that

00:29:33,220 --> 00:29:37,390
some people are religiously opposed to

00:29:35,350 --> 00:29:39,520
these so in case you don't want to

00:29:37,390 --> 00:29:41,560
monkey patch your function you can

00:29:39,520 --> 00:29:44,110
always define a dictionary as a global

00:29:41,560 --> 00:29:45,730
and then use it in the closure of the

00:29:44,110 --> 00:29:51,370
upper function it works it's not the

00:29:45,730 --> 00:29:53,410
same now this is the way these register

00:29:51,370 --> 00:29:55,600
decorator is used as you can see we

00:29:53,410 --> 00:29:58,390
import two logs and we pass two logs to

00:29:55,600 --> 00:30:01,030
the decorator and actually I also want

00:29:58,390 --> 00:30:04,900
to point out that the owners speculator

00:30:01,030 --> 00:30:06,880
removes these ambiguity about all is the

00:30:04,900 --> 00:30:08,590
owners so just a string or is the owners

00:30:06,880 --> 00:30:10,390
list of strings like if you want to

00:30:08,590 --> 00:30:11,920
passing more owners you just passing

00:30:10,390 --> 00:30:13,420
more arguments and the Python

00:30:11,920 --> 00:30:16,270
interpreter is going to check that for

00:30:13,420 --> 00:30:18,190
us as we don't need more assertion

00:30:16,270 --> 00:30:20,020
because the Python interpreter a team

00:30:18,190 --> 00:30:22,420
for time is going to check that we

00:30:20,020 --> 00:30:26,140
created the two logs we want to register

00:30:22,420 --> 00:30:28,300
the function for they go to the function

00:30:26,140 --> 00:30:31,810
once again is just the digest speed of

00:30:28,300 --> 00:30:34,300
want greater we saw before now let's go

00:30:31,810 --> 00:30:37,720
back to the questions we got so I'll do

00:30:34,300 --> 00:30:41,920
a narrate from a base load class smiley

00:30:37,720 --> 00:30:45,460
face if you want to subclass your low

00:30:41,920 --> 00:30:48,130
class you can but if your ID

00:30:45,460 --> 00:30:49,630
is just passing a decoding functions and

00:30:48,130 --> 00:30:52,000
then avoiding to pass it over and over

00:30:49,630 --> 00:30:54,880
and over what you do is just use partial

00:30:52,000 --> 00:30:58,779
and then you accentuate the new logs

00:30:54,880 --> 00:31:00,880
using the results of partial next

00:30:58,779 --> 00:31:04,179
question I would do a narrate for a base

00:31:00,880 --> 00:31:07,600
trigger class well no more base classes

00:31:04,179 --> 00:31:11,140
no more assertions what we do is just

00:31:07,600 --> 00:31:13,390
defining a simple function we define a

00:31:11,140 --> 00:31:17,260
function yielding some metrics and

00:31:13,390 --> 00:31:19,179
having some attributes as the attributes

00:31:17,260 --> 00:31:21,250
of the class before s parameters in this

00:31:19,179 --> 00:31:23,529
case the endpoints and even the

00:31:21,250 --> 00:31:26,110
additional dimensions method is now just

00:31:23,529 --> 00:31:29,380
the parameter for the function and then

00:31:26,110 --> 00:31:33,250
we call it that's it so we just yield

00:31:29,380 --> 00:31:35,649
from the function within our you know

00:31:33,250 --> 00:31:37,120
logic and that's what we do we don't

00:31:35,649 --> 00:31:39,659
even need methods we don't need

00:31:37,120 --> 00:31:42,940
subclasses we don't need to remember to

00:31:39,659 --> 00:31:47,760
assert for class attributes it's all

00:31:42,940 --> 00:31:50,380
done by the interpreter for us for free

00:31:47,760 --> 00:31:55,270
but I'll do it from through to your

00:31:50,380 --> 00:31:58,350
classes mm about this one what you do is

00:31:55,270 --> 00:32:01,059
just you define two functions this is

00:31:58,350 --> 00:32:03,850
the digest method or the first trigger

00:32:01,059 --> 00:32:06,610
that we saw when we saw the example of

00:32:03,850 --> 00:32:08,830
the multiple inheritance this is the

00:32:06,610 --> 00:32:12,460
exactly the same code of the second

00:32:08,830 --> 00:32:15,490
trigger that we saw before you just call

00:32:12,460 --> 00:32:20,260
them both you don't even need to ask me

00:32:15,490 --> 00:32:23,549
just call functions now let's go back to

00:32:20,260 --> 00:32:27,100
tests how do I test my trigger class now

00:32:23,549 --> 00:32:28,570
easy as before even easier you don't

00:32:27,100 --> 00:32:33,100
even need to write us pictures anymore

00:32:28,570 --> 00:32:37,529
just a function you call it that's it

00:32:33,100 --> 00:32:40,450
and I'll do a test my base trigger class

00:32:37,529 --> 00:32:43,809
that's the thing I'm the most happy

00:32:40,450 --> 00:32:46,899
about it's basically another function

00:32:43,809 --> 00:32:49,870
you just call it again and the way you

00:32:46,899 --> 00:32:52,090
mock yourself is just passing some

00:32:49,870 --> 00:32:54,340
random strings like for example test as

00:32:52,090 --> 00:32:57,490
parameters you don't need to use the

00:32:54,340 --> 00:32:58,720
type function the Python provides you

00:32:57,490 --> 00:32:59,350
don't need to remember about the

00:32:58,720 --> 00:33:04,870
narrator

00:32:59,350 --> 00:33:07,300
send everything just passing a string so

00:33:04,870 --> 00:33:09,940
but now that we removed all the

00:33:07,300 --> 00:33:11,520
assertions how do I make sure that all

00:33:09,940 --> 00:33:15,400
functions have owners

00:33:11,520 --> 00:33:17,890
well we write a test what the test does

00:33:15,400 --> 00:33:20,590
is calling the collect function which is

00:33:17,890 --> 00:33:23,230
the one used by stud master to collect

00:33:20,590 --> 00:33:25,750
the runtime all blogs we iterate over

00:33:23,230 --> 00:33:30,810
the logs and we just check that they

00:33:25,750 --> 00:33:33,160
have the owners attribute set so well

00:33:30,810 --> 00:33:36,790
that's even better than before because

00:33:33,160 --> 00:33:39,910
we transformed a runtime error to a test

00:33:36,790 --> 00:33:44,980
that could fail before we even push some

00:33:39,910 --> 00:33:47,080
function without owners in production so

00:33:44,980 --> 00:33:48,970
it's everything we indeed so

00:33:47,080 --> 00:33:51,790
implementing these decorators and

00:33:48,970 --> 00:33:56,140
changing a big interface only for user's

00:33:51,790 --> 00:33:58,600
sake now actually for the most part of

00:33:56,140 --> 00:33:59,950
the same fish interest because you

00:33:58,600 --> 00:34:01,840
remember they talked a lot about the

00:33:59,950 --> 00:34:03,580
input systems that monster the thing

00:34:01,840 --> 00:34:05,560
that makes that most understand which

00:34:03,580 --> 00:34:06,940
logs he needs to consume which classes

00:34:05,560 --> 00:34:09,070
you needs to execute in the kind of

00:34:06,940 --> 00:34:11,290
stuff well you don't need to understand

00:34:09,070 --> 00:34:14,500
the code but this is the input system in

00:34:11,290 --> 00:34:18,670
the new stuff monster just look at it

00:34:14,500 --> 00:34:20,470
and compare it with the old one it

00:34:18,670 --> 00:34:22,930
doesn't even fit in a slide and actually

00:34:20,470 --> 00:34:25,300
this is a version that I wrote in Python

00:34:22,930 --> 00:34:27,960
free dog 6 so it's much more complicated

00:34:25,300 --> 00:34:32,220
version 2 the 7 version that we used and

00:34:27,960 --> 00:34:38,170
that makes me very very happy

00:34:32,220 --> 00:34:41,110
now closing up the main takeaways of the

00:34:38,170 --> 00:34:42,970
talk were let user utilize all Python

00:34:41,110 --> 00:34:47,260
feature instead of just inheritance as

00:34:42,970 --> 00:34:51,190
we saw and go for decorators when your

00:34:47,260 --> 00:34:53,260
classes have only one needed for example

00:34:51,190 --> 00:34:56,560
the trigger class as only did I just

00:34:53,260 --> 00:35:00,880
needed and they are associated only once

00:34:56,560 --> 00:35:02,500
actually we never even even associate

00:35:00,880 --> 00:35:05,560
the trigger class ourselves the

00:35:02,500 --> 00:35:07,900
framework was doing that for us and now

00:35:05,560 --> 00:35:10,180
instead what you do is you instantiate

00:35:07,900 --> 00:35:12,610
your low class whenever you want even

00:35:10,180 --> 00:35:13,350
want some coffee you are free to do it

00:35:12,610 --> 00:35:16,260
you know

00:35:13,350 --> 00:35:19,490
- don't do it and all the triggers

00:35:16,260 --> 00:35:22,620
disappeared they're just functions so

00:35:19,490 --> 00:35:24,720
just to clarify I'm not saying that we

00:35:22,620 --> 00:35:27,870
should move entirely out of classes from

00:35:24,720 --> 00:35:31,080
it just use classes when they're useful

00:35:27,870 --> 00:35:33,420
in this case the log class is still a

00:35:31,080 --> 00:35:35,700
class because there's some states and it

00:35:33,420 --> 00:35:37,560
has some behavior and it's used as close

00:35:35,700 --> 00:35:41,130
as supposed to be used in Python not

00:35:37,560 --> 00:35:43,470
only for inheritance so when you make

00:35:41,130 --> 00:35:46,650
sense go for the grader when you make

00:35:43,470 --> 00:35:48,860
sense go for classes and that's the end

00:35:46,650 --> 00:35:51,720
of the call remember that we are hiring

00:35:48,860 --> 00:35:53,460
especially for our offices in London and

00:35:51,720 --> 00:35:57,120
on board so if you want to work with

00:35:53,460 --> 00:36:00,000
Python and on big real-time processing

00:35:57,120 --> 00:36:02,340
streams and kind of stuff just come to

00:36:00,000 --> 00:36:04,800
all credit to us whatever booth just in

00:36:02,340 --> 00:36:06,720
the big ole and don't forget to follow

00:36:04,800 --> 00:36:08,970
us on every social network possible

00:36:06,720 --> 00:36:12,420
Facebook Twitter and github yes nowadays

00:36:08,970 --> 00:36:14,760
ketta be the social network and please

00:36:12,420 --> 00:36:18,930
read our engineering blog where a lot of

00:36:14,760 --> 00:36:21,030
smart engineers why better than me speak

00:36:18,930 --> 00:36:25,370
about all the cool stuff that we build

00:36:21,030 --> 00:36:25,370
every day questions

00:36:31,860 --> 00:36:41,550
thanks Anton you representation we have

00:36:35,220 --> 00:36:44,180
a time for few questions no questions

00:36:41,550 --> 00:36:44,180
please

00:36:50,410 --> 00:36:56,869
hi hi did you run into any specific

00:36:54,559 --> 00:36:59,569
situations we're switching to using

00:36:56,869 --> 00:37:01,880
decorators made it art and practice to

00:36:59,569 --> 00:37:03,799
debug certain problems so what we

00:37:01,880 --> 00:37:05,599
decorate or obscure the actual problem

00:37:03,799 --> 00:37:07,690
that you were trying to get to that

00:37:05,599 --> 00:37:10,849
that's a very good question actually so

00:37:07,690 --> 00:37:12,920
you may have used the Creator they're

00:37:10,849 --> 00:37:16,220
very complicated like to do a lot of

00:37:12,920 --> 00:37:18,229
stuff and then they difficult to the

00:37:16,220 --> 00:37:19,910
body because they change the way the

00:37:18,229 --> 00:37:21,979
function is executed and then you got

00:37:19,910 --> 00:37:24,109
this weird stuck trades and you really

00:37:21,979 --> 00:37:28,400
understand what's going on well my two

00:37:24,109 --> 00:37:31,309
signs to these is that as in any while

00:37:28,400 --> 00:37:34,849
always writing code you want to give it

00:37:31,309 --> 00:37:37,249
simple so my two cents is decorators

00:37:34,849 --> 00:37:40,130
should always return the function and

00:37:37,249 --> 00:37:42,710
touch it's like the function should be

00:37:40,130 --> 00:37:44,809
able to be called without using the

00:37:42,710 --> 00:37:47,180
decorator and the decorator should stay

00:37:44,809 --> 00:37:49,460
really small so the frameworks that I

00:37:47,180 --> 00:37:51,170
showed you before at very complex

00:37:49,460 --> 00:37:53,420
decorators but they are very much your

00:37:51,170 --> 00:37:55,069
framework with a you know good

00:37:53,420 --> 00:37:57,680
open-source community and a lot of

00:37:55,069 --> 00:38:00,410
teachers just came into it so my two

00:37:57,680 --> 00:38:02,390
cents especially for your own production

00:38:00,410 --> 00:38:05,769
code is keep your decorator simple and

00:38:02,390 --> 00:38:11,390
avoid to do a lot of stuff into them

00:38:05,769 --> 00:38:13,749
copy answers the question more questions

00:38:11,390 --> 00:38:18,079
to Antonio

00:38:13,749 --> 00:38:18,829
no we thank you and Tony for

00:38:18,079 --> 00:38:22,150
representation

00:38:18,829 --> 00:38:22,150

YouTube URL: https://www.youtube.com/watch?v=VLlLIL5ZYLI


