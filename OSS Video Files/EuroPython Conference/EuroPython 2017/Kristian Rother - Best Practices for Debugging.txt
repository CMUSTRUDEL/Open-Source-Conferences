Title: Kristian Rother - Best Practices for Debugging
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Best Practices for Debugging
[EuroPython 2017 - Training session - 2017-07-10 - Sala del Tempio 2]
[Rimini, Italy]

Debugging is a daily activity of any programmer. Frequently, it is assumed that programmers can debug. However, programmers often have to deal with existing code that simply does not work. This tutorial attempts to change that by introducing concepts for debugging and corresponding programming techniques.

In this tutorial, participants will learn strategies for systematically debugging Python programs. We will work through a series of examples, each with a different kind of bug and with increasing difficulty. The training will be interactive, combining one-person and group activities, to improve your debugging skills in an entertaining way.

Contents:


Syntax Error against Runtime exceptions
Get file and directory names right
Debugging with the scientific method
Inspection of variables with print and introspection functions
Using an interactive debugger
Pros and cons of try.. except
Delta debugging

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,310 --> 00:00:14,090
welcome everybody when I was 15 years

00:00:09,059 --> 00:00:19,260
old I was writing a computer game a

00:00:14,090 --> 00:00:22,740
little bit like this one I wrote this on

00:00:19,260 --> 00:00:25,860
a c64 computer in the assembly language

00:00:22,740 --> 00:00:31,260
is anyone here in the room who has tried

00:00:25,860 --> 00:00:33,230
doing that actually uh not a few people

00:00:31,260 --> 00:00:36,390
great congratulations

00:00:33,230 --> 00:00:39,590
well I was writing this was my first

00:00:36,390 --> 00:00:43,260
bigger program I wrote an assembler and

00:00:39,590 --> 00:00:47,489
the way it works like I wrote a couple

00:00:43,260 --> 00:00:50,430
of lines try to run the program usually

00:00:47,489 --> 00:00:53,220
the computer would crash and I so I

00:00:50,430 --> 00:00:55,920
switched it off waited a few seconds

00:00:53,220 --> 00:00:58,829
switched it on again loaded the computer

00:00:55,920 --> 00:01:04,199
as the compiler loaded my source code

00:00:58,829 --> 00:01:07,740
and the entire process repeated needless

00:01:04,199 --> 00:01:12,090
to say that you won't program very fast

00:01:07,740 --> 00:01:16,710
doing this because my average debug run

00:01:12,090 --> 00:01:20,729
cycle was about 10 minutes and this led

00:01:16,710 --> 00:01:25,670
to a lot of frustration at the moment my

00:01:20,729 --> 00:01:25,670
game is 24 years behind schedule

00:01:25,940 --> 00:01:32,280
only later I learned that on the c64 we

00:01:30,360 --> 00:01:34,860
had devices like this one

00:01:32,280 --> 00:01:38,369
a small cartridge that you could plug in

00:01:34,860 --> 00:01:41,010
the back of the computer it had a button

00:01:38,369 --> 00:01:44,369
on it you push it and you are you jump

00:01:41,010 --> 00:01:46,500
right in to the compiler can edit your

00:01:44,369 --> 00:01:49,860
code and continue where you stopped a

00:01:46,500 --> 00:01:54,750
few seconds ago but I was totally

00:01:49,860 --> 00:02:00,509
unaware of that and basically the aim of

00:01:54,750 --> 00:02:06,210
my talk is to prevent us from pitfalls

00:02:00,509 --> 00:02:10,560
like this one in Python projects now I'm

00:02:06,210 --> 00:02:13,890
not going to talk about anything fancy

00:02:10,560 --> 00:02:16,110
or totally new here because what I want

00:02:13,890 --> 00:02:16,569
to address is a common problem that I

00:02:16,110 --> 00:02:19,870
have

00:02:16,569 --> 00:02:22,599
deserved happening when people are new

00:02:19,870 --> 00:02:26,889
to Python or are a little bit more

00:02:22,599 --> 00:02:29,439
advanced in Python after you mastered

00:02:26,889 --> 00:02:31,810
the Python basics you pretty soon figure

00:02:29,439 --> 00:02:34,329
out that there are plenty of libraries

00:02:31,810 --> 00:02:36,849
for instance if I want to do data

00:02:34,329 --> 00:02:40,150
analysis then I need to find a library

00:02:36,849 --> 00:02:42,879
for data analysis like pandas if I want

00:02:40,150 --> 00:02:44,950
to do I don't know signal processing or

00:02:42,879 --> 00:02:47,349
Fourier transformation then I Google a

00:02:44,950 --> 00:02:49,870
library for that and find sci-fi for

00:02:47,349 --> 00:02:52,030
instance or if I want to do best

00:02:49,870 --> 00:02:56,889
development then I will find django and

00:02:52,030 --> 00:02:59,769
so on these things on the left side they

00:02:56,889 --> 00:03:02,859
are easy to find even if I don't know

00:02:59,769 --> 00:03:06,790
them I may have a hunch that something

00:03:02,859 --> 00:03:10,000
like this must exist but the ones on the

00:03:06,790 --> 00:03:12,159
right side if I have no idea that

00:03:10,000 --> 00:03:15,629
something like interactive debuggers

00:03:12,159 --> 00:03:18,939
exists then I won't be looking for one

00:03:15,629 --> 00:03:22,169
the same goes for automated testing and

00:03:18,939 --> 00:03:25,750
the same goes for all the tools in the

00:03:22,169 --> 00:03:30,549
Python ecosystem that helps support and

00:03:25,750 --> 00:03:35,229
maintain our code and I want to shed a

00:03:30,549 --> 00:03:37,900
light on these dark spots so if you walk

00:03:35,229 --> 00:03:40,180
out of this room and and see hey I

00:03:37,900 --> 00:03:43,629
haven't learned anything new then

00:03:40,180 --> 00:03:46,780
consider this an additional safety check

00:03:43,629 --> 00:03:49,659
pretty much like if people start an

00:03:46,780 --> 00:03:52,750
aeroplane pilots they have a checklist

00:03:49,659 --> 00:03:54,489
that they go okay other do we have

00:03:52,750 --> 00:03:57,370
clearance from the tower are there any

00:03:54,489 --> 00:03:59,680
other planes on the runway do we have

00:03:57,370 --> 00:04:04,629
enough fuel for an emergency landing and

00:03:59,680 --> 00:04:05,769
so on and so on and I think it's good to

00:04:04,629 --> 00:04:08,139
have something like that in a

00:04:05,769 --> 00:04:12,669
programming project - and this is why I

00:04:08,139 --> 00:04:14,049
call it best practices and my talk is

00:04:12,669 --> 00:04:15,909
split into three parts

00:04:14,049 --> 00:04:18,430
I would first like to talk about

00:04:15,909 --> 00:04:23,009
debugging then show an example of test

00:04:18,430 --> 00:04:23,009
about testing and then about maintenance

00:04:26,400 --> 00:04:32,050
debugging it when you talk about

00:04:29,740 --> 00:04:36,430
debugging in Titan the first thing that

00:04:32,050 --> 00:04:40,510
comes into your mind might be print now

00:04:36,430 --> 00:04:43,810
print is something that I consider a bit

00:04:40,510 --> 00:04:46,240
problematic even though I do it a lot

00:04:43,810 --> 00:04:48,070
because it's like shooting holes into a

00:04:46,240 --> 00:04:50,770
building to see whether there's a fire

00:04:48,070 --> 00:04:53,980
inside every time you add a print

00:04:50,770 --> 00:04:56,620
statement to a piece of code there is a

00:04:53,980 --> 00:04:58,870
risk that when deleting the print

00:04:56,620 --> 00:05:03,670
statement you delete one line too much

00:04:58,870 --> 00:05:05,620
without noticing and this is why it's

00:05:03,670 --> 00:05:10,530
worth keeping in mind that there are

00:05:05,620 --> 00:05:15,190
other debugging techniques for instance

00:05:10,530 --> 00:05:19,210
the interactive debugger for instance

00:05:15,190 --> 00:05:21,010
logging with the standard logging module

00:05:19,210 --> 00:05:23,890
this is really an excellent way to

00:05:21,010 --> 00:05:27,160
produce diagnostic information if your

00:05:23,890 --> 00:05:29,110
program is bigger than a couple of

00:05:27,160 --> 00:05:32,440
screen pages and logging becomes

00:05:29,110 --> 00:05:34,330
superior to print after a while you need

00:05:32,440 --> 00:05:37,060
to know your introspection functions

00:05:34,330 --> 00:05:41,050
like deer and type is instant and a

00:05:37,060 --> 00:05:44,320
couple of their cousins and I put code

00:05:41,050 --> 00:05:48,220
review here as a best practice that

00:05:44,320 --> 00:05:51,340
helps with debugging a lot we had a

00:05:48,220 --> 00:05:53,710
tutorial on debugging yesterday if you

00:05:51,340 --> 00:05:56,110
were attending some other part of the

00:05:53,710 --> 00:06:00,390
conference the exercises are there on

00:05:56,110 --> 00:06:00,390
github you can try them out by yourself

00:06:02,190 --> 00:06:09,460
but what about the really tough bugs if

00:06:06,420 --> 00:06:12,580
something does not work and does not

00:06:09,460 --> 00:06:16,420
work you stare at the code and go on

00:06:12,580 --> 00:06:19,330
staring at your code without any

00:06:16,420 --> 00:06:21,760
progress I'm sure that this has happened

00:06:19,330 --> 00:06:25,390
to most of you in the room at least it

00:06:21,760 --> 00:06:28,450
happens to me still after 28 years of

00:06:25,390 --> 00:06:31,690
programming and I have figured out

00:06:28,450 --> 00:06:34,810
something very nasty over the years not

00:06:31,690 --> 00:06:37,720
that I'm lacking some additional best

00:06:34,810 --> 00:06:38,500
practice for debugging here because 9

00:06:37,720 --> 00:06:40,510
out of 10

00:06:38,500 --> 00:06:44,460
time's the problem is inside my head

00:06:40,510 --> 00:06:44,460
rather than in the computer and

00:06:45,270 --> 00:06:49,900
fortunately there are ways to fix that

00:06:47,650 --> 00:06:53,020
so I would like to add to those best

00:06:49,900 --> 00:06:57,460
practices of debugging for very

00:06:53,020 --> 00:07:02,710
elementary things sleep talk read and

00:06:57,460 --> 00:07:06,010
write but most of the time if I spend

00:07:02,710 --> 00:07:07,870
more than 15 minutes on a bag and I

00:07:06,010 --> 00:07:13,300
don't find the solution then I'm

00:07:07,870 --> 00:07:17,130
probably tired often it helps to talk to

00:07:13,300 --> 00:07:19,660
another person explaining what you do to

00:07:17,130 --> 00:07:21,910
realize what the problem really is maybe

00:07:19,660 --> 00:07:25,900
I'm looking in the wrong spot and

00:07:21,910 --> 00:07:28,090
explaining helps usually sometimes my

00:07:25,900 --> 00:07:31,930
knowledge my knowledge is limited and

00:07:28,090 --> 00:07:36,370
reading the manual of the library this

00:07:31,930 --> 00:07:39,900
time for real helps and if all of these

00:07:36,370 --> 00:07:44,680
fail writing down what the program is

00:07:39,900 --> 00:07:46,960
formulating a couple of hypotheses or at

00:07:44,680 --> 00:07:51,160
least ideas what the problem might be

00:07:46,960 --> 00:07:54,310
could lead to progress most of the time

00:07:51,160 --> 00:07:58,560
I'm lazy and take a break and this has

00:07:54,310 --> 00:08:03,550
solved lots of bugs in the past for me

00:07:58,560 --> 00:08:09,450
testing the check I can hear is actually

00:08:03,550 --> 00:08:11,890
a bit of a provocation because this

00:08:09,450 --> 00:08:15,760
suggests something that automated

00:08:11,890 --> 00:08:18,430
testing does not do testing actually

00:08:15,760 --> 00:08:20,830
does not prove correctness of your

00:08:18,430 --> 00:08:24,270
program I know that many Python

00:08:20,830 --> 00:08:27,580
developers they love automated testing I

00:08:24,270 --> 00:08:29,620
like to use autumn write automated tests

00:08:27,580 --> 00:08:34,240
and run them it gives a feeling of

00:08:29,620 --> 00:08:35,740
achievement and but there's a pitfall

00:08:34,240 --> 00:08:39,310
and the pitfall is that one in the

00:08:35,740 --> 00:08:42,310
bottom right corner if there is always a

00:08:39,310 --> 00:08:44,890
possibility if my tests passed it could

00:08:42,310 --> 00:08:48,339
be that both the code and the tests are

00:08:44,890 --> 00:08:50,949
incorrect even if I try hard to keep my

00:08:48,339 --> 00:08:55,790
tests as simple as possible

00:08:50,949 --> 00:08:59,589
so tests by themselves do not prove

00:08:55,790 --> 00:09:02,779
correctness of the code but they have a

00:08:59,589 --> 00:09:05,509
potential to prove the presence of bugs

00:09:02,779 --> 00:09:09,499
so if I see a failing test I know that

00:09:05,509 --> 00:09:13,610
somewhere something is wrong now how can

00:09:09,499 --> 00:09:17,420
we write good tests actually let's

00:09:13,610 --> 00:09:20,269
imagine we are rising the game this time

00:09:17,420 --> 00:09:23,089
entitle not an assembly this group too

00:09:20,269 --> 00:09:25,579
tiresome we have a figure that is

00:09:23,089 --> 00:09:28,160
pushing these blue boxes around it can

00:09:25,579 --> 00:09:30,379
only push one box at a time cannot push

00:09:28,160 --> 00:09:32,629
any boxes through the wall and so on

00:09:30,379 --> 00:09:36,079
until it reaches until you reach the

00:09:32,629 --> 00:09:39,379
exit here in the bottom right now how

00:09:36,079 --> 00:09:42,619
could a test for this situation look

00:09:39,379 --> 00:09:47,569
like the first thing that you can think

00:09:42,619 --> 00:09:49,999
of a fixture in PI test I learned today

00:09:47,569 --> 00:09:51,949
when talking to the PI test core

00:09:49,999 --> 00:09:54,529
developers that it's a good idea to

00:09:51,949 --> 00:09:58,309
place fixtures in a fire contest of py

00:09:54,529 --> 00:10:03,639
and because they get automatically

00:09:58,309 --> 00:10:05,720
imported into all your test files now

00:10:03,639 --> 00:10:09,019
fixtures are actually pretty

00:10:05,720 --> 00:10:12,259
straightforward you decorate a function

00:10:09,019 --> 00:10:15,379
with the PI test fixture decorator and

00:10:12,259 --> 00:10:18,799
the name of the function will be

00:10:15,379 --> 00:10:20,360
available as a variable in all your test

00:10:18,799 --> 00:10:24,879
functions if you put it there as a

00:10:20,360 --> 00:10:27,470
parameter so in that case we would get

00:10:24,879 --> 00:10:30,139
we could have a level parameter

00:10:27,470 --> 00:10:33,169
available in our test that then contains

00:10:30,139 --> 00:10:36,410
a parse version of our example game

00:10:33,169 --> 00:10:38,749
situation actually I did something

00:10:36,410 --> 00:10:41,809
additional here I parameter ammeter eyes

00:10:38,749 --> 00:10:44,749
the test so there are two versions of

00:10:41,809 --> 00:10:48,529
the playing fields supplied to the test

00:10:44,749 --> 00:10:52,999
one with empty spaces and one with dots

00:10:48,529 --> 00:10:55,239
on the playing field so I can have two

00:10:52,999 --> 00:10:58,699
fixtures or more in one by

00:10:55,239 --> 00:11:01,970
parameterization and then we can use

00:10:58,699 --> 00:11:04,250
this in a test function I like to group

00:11:01,970 --> 00:11:06,830
my test functions into classes

00:11:04,250 --> 00:11:10,430
with PI tests this is fortunately a lot

00:11:06,830 --> 00:11:10,820
easier than it used to be with unit

00:11:10,430 --> 00:11:15,470
tests

00:11:10,820 --> 00:11:18,770
I still have less Euler plate code so I

00:11:15,470 --> 00:11:21,530
can write a normal test function with

00:11:18,770 --> 00:11:25,100
with just an assertion that is self

00:11:21,530 --> 00:11:27,080
sufficient or I can use the level

00:11:25,100 --> 00:11:29,150
parameter here note that I'm not

00:11:27,080 --> 00:11:31,820
importing level anywhere this gets

00:11:29,150 --> 00:11:35,750
automatically automatically filled in by

00:11:31,820 --> 00:11:40,460
PI test and this test function will

00:11:35,750 --> 00:11:45,530
generate two tests for me one one for

00:11:40,460 --> 00:11:48,740
each of the variants in the fixture what

00:11:45,530 --> 00:11:50,420
else can we do the third most important

00:11:48,740 --> 00:11:52,480
thing that I would like to emphasize

00:11:50,420 --> 00:11:56,390
about automated testing is test

00:11:52,480 --> 00:12:00,350
parameterization so we can have one test

00:11:56,390 --> 00:12:04,580
function right multiple try multiple

00:12:00,350 --> 00:12:08,120
examples like here we say by this

00:12:04,580 --> 00:12:10,670
parameterized decorator we would like to

00:12:08,120 --> 00:12:14,900
try out all the examples in the list

00:12:10,670 --> 00:12:17,720
like having a move that goes first up

00:12:14,900 --> 00:12:20,020
and then left and afterwards that

00:12:17,720 --> 00:12:25,160
playing figure should end up on square

00:12:20,020 --> 00:12:27,740
2x and 2y it's even possible to build

00:12:25,160 --> 00:12:32,780
failing tests with this old test that we

00:12:27,740 --> 00:12:35,150
expect to be failing so we have still

00:12:32,780 --> 00:12:38,180
right only one test function but with

00:12:35,150 --> 00:12:41,660
this one we would generate eight tests

00:12:38,180 --> 00:12:44,690
in total so it saves a lot of code the

00:12:41,660 --> 00:12:47,330
code becomes actually very readable and

00:12:44,690 --> 00:12:52,300
if we end up in a situation where our

00:12:47,330 --> 00:12:55,370
test code is ridiculously easy to read

00:12:52,300 --> 00:13:00,170
much easier than the code we are testing

00:12:55,370 --> 00:13:04,090
then we are on the right track so if we

00:13:00,170 --> 00:13:06,980
execute this code by writing PI tests

00:13:04,090 --> 00:13:11,510
this is another thing I learned this

00:13:06,980 --> 00:13:13,910
morning that the dot inside PI test has

00:13:11,510 --> 00:13:16,340
been deprecated we can use PI test

00:13:13,910 --> 00:13:18,080
without the dot in the middle so we see

00:13:16,340 --> 00:13:20,630
that all the tests

00:13:18,080 --> 00:13:26,120
secured this test actually uses a window

00:13:20,630 --> 00:13:28,100
and we see 34 past tests in the entire

00:13:26,120 --> 00:13:29,660
test set not only the ones that I showed

00:13:28,100 --> 00:13:32,210
on the slide there's a couple of more

00:13:29,660 --> 00:13:34,700
few more running in the back plus two

00:13:32,210 --> 00:13:41,020
that are expected to fail because I

00:13:34,700 --> 00:13:41,020
marked them with the exhale decorator

00:13:43,270 --> 00:13:50,720
now how much testing code should you

00:13:46,370 --> 00:13:55,520
write in my opinion this depends quite a

00:13:50,720 --> 00:13:59,300
lot on the size of your project if your

00:13:55,520 --> 00:14:01,940
project is small and prints an obvious

00:13:59,300 --> 00:14:04,100
result anyway then maybe a manual test

00:14:01,940 --> 00:14:08,210
is enough unless you want this to be

00:14:04,100 --> 00:14:10,640
continuously integrated sometimes I

00:14:08,210 --> 00:14:15,020
still write test code in the main block

00:14:10,640 --> 00:14:17,720
of a small Python module I can write

00:14:15,020 --> 00:14:20,570
make automated tightest functions out of

00:14:17,720 --> 00:14:23,150
this quite easily later if the project

00:14:20,570 --> 00:14:25,820
growth add some fixtures as the thing

00:14:23,150 --> 00:14:29,180
grows further and if the program keeps

00:14:25,820 --> 00:14:32,600
growing and growing then at some point

00:14:29,180 --> 00:14:35,180
it might be helpful to switch on testing

00:14:32,600 --> 00:14:37,580
tools like Jenkins Trevis for continuous

00:14:35,180 --> 00:14:41,930
integration or tox for testing multiple

00:14:37,580 --> 00:14:44,540
Python versions when I speak about size

00:14:41,930 --> 00:14:45,350
of the project this can mean different

00:14:44,540 --> 00:14:47,750
things

00:14:45,350 --> 00:14:50,930
it could be absolute volume in lines of

00:14:47,750 --> 00:14:54,260
code but it could also be the expected

00:14:50,930 --> 00:14:57,050
lifetime of the project so if I expect

00:14:54,260 --> 00:14:59,360
code to be maintained for two weeks then

00:14:57,050 --> 00:15:02,500
I would not worry too much about testing

00:14:59,360 --> 00:15:05,960
if I'm writing a throwaway program if

00:15:02,500 --> 00:15:10,730
the program has a high dependability so

00:15:05,960 --> 00:15:13,160
if it needs to be extra safe then doing

00:15:10,730 --> 00:15:17,780
more tests and reviews and things like

00:15:13,160 --> 00:15:21,430
that is also a good idea in the final

00:15:17,780 --> 00:15:24,590
part of my talk I would like to

00:15:21,430 --> 00:15:28,790
elaborate on maintenance

00:15:24,590 --> 00:15:34,130
peyten had a fairly sophisticated

00:15:28,790 --> 00:15:37,440
ecosystem of maintenance tools and they

00:15:34,130 --> 00:15:40,860
serve the single purpose of keeping your

00:15:37,440 --> 00:15:43,950
code in a good shape like pet eight

00:15:40,860 --> 00:15:46,440
being a layer of paint on your program

00:15:43,950 --> 00:15:49,200
like many of you probably have heard in

00:15:46,440 --> 00:15:52,530
the talk of an and a while ago buted

00:15:49,200 --> 00:15:55,410
making beautiful code is a virtue and

00:15:52,530 --> 00:16:00,990
python has nice tool supports to help

00:15:55,410 --> 00:16:05,610
you with that instead of picking a few

00:16:00,990 --> 00:16:08,670
must-have tools i tried to throw in some

00:16:05,610 --> 00:16:11,370
that keep reoccurring with git being in

00:16:08,670 --> 00:16:13,620
the middle being not a coincidence so if

00:16:11,370 --> 00:16:15,630
there's anyone not using git or version

00:16:13,620 --> 00:16:19,290
control yet in the moment it's a good

00:16:15,630 --> 00:16:21,090
this conference is a good starting point

00:16:19,290 --> 00:16:23,040
to learn that because you won't be

00:16:21,090 --> 00:16:26,010
getting anywhere without version control

00:16:23,040 --> 00:16:28,350
but others are there are many other

00:16:26,010 --> 00:16:30,420
tools as well some of them are

00:16:28,350 --> 00:16:34,320
interchangeable like pi scaffold

00:16:30,420 --> 00:16:37,380
recently in my personal ranking

00:16:34,320 --> 00:16:39,930
surpassed by cookie cutter there is

00:16:37,380 --> 00:16:43,380
things for documentation virtual ends

00:16:39,930 --> 00:16:46,350
and tie-ins for managing your Python

00:16:43,380 --> 00:16:51,810
installations and libraries pilant and

00:16:46,350 --> 00:16:56,400
pi flakes for for watching your coding

00:16:51,810 --> 00:17:00,060
side and so on and so on now what can

00:16:56,400 --> 00:17:04,260
you do to keep an overview of all of

00:17:00,060 --> 00:17:07,620
these tools now I would like to just

00:17:04,260 --> 00:17:10,740
mention two possibilities here one of

00:17:07,620 --> 00:17:13,530
them is um magdalena rotor is going to

00:17:10,740 --> 00:17:15,870
give a talk this friday where she's

00:17:13,530 --> 00:17:18,720
going to present give an overview of all

00:17:15,870 --> 00:17:22,110
the different configuration files that

00:17:18,720 --> 00:17:25,770
are that you can find in a well

00:17:22,110 --> 00:17:29,490
maintained Titan project so this is on

00:17:25,770 --> 00:17:31,800
Friday afternoon it is still too far

00:17:29,490 --> 00:17:35,850
away in the future I recommend you to

00:17:31,800 --> 00:17:37,710
take a look at koala Paula some of you

00:17:35,850 --> 00:17:40,590
may have noticed that there's a

00:17:37,710 --> 00:17:43,740
higher in the conference egg I visited

00:17:40,590 --> 00:17:45,899
the Koala booth yesterday and the

00:17:43,740 --> 00:17:48,690
developers actually gave me a quick

00:17:45,899 --> 00:17:52,679
introduction and I was able to run koala

00:17:48,690 --> 00:17:58,039
within within five or five minutes or

00:17:52,679 --> 00:18:01,919
ten minutes so koala is a framework that

00:17:58,039 --> 00:18:05,640
basically hosts many linting tools that

00:18:01,919 --> 00:18:08,460
means code tools like pilant or mypie or

00:18:05,640 --> 00:18:11,760
other tools that analyze the quality of

00:18:08,460 --> 00:18:13,500
your code not just for Python and I

00:18:11,760 --> 00:18:16,919
thought how awesome is that

00:18:13,500 --> 00:18:19,529
I can put I can check not only my Python

00:18:16,919 --> 00:18:22,610
files I can also check my HTML templates

00:18:19,529 --> 00:18:26,460
and JavaScript code and whatever has

00:18:22,610 --> 00:18:29,520
been accumulating in my project and get

00:18:26,460 --> 00:18:34,610
everything from one tool that tells me

00:18:29,520 --> 00:18:38,279
how good it is so how does that work

00:18:34,610 --> 00:18:43,590
koala brings its own configuration files

00:18:38,279 --> 00:18:45,840
that are mainly contain a list of the

00:18:43,590 --> 00:18:48,809
tools that you want to switch on for a

00:18:45,840 --> 00:18:52,529
given type of file for some reason koala

00:18:48,809 --> 00:18:54,000
calls these different linters bears so

00:18:52,529 --> 00:18:56,309
you have a list of bears in this

00:18:54,000 --> 00:18:59,399
configuration file which in my opinion

00:18:56,309 --> 00:19:01,440
it's kind of kind of cute and I need to

00:18:59,399 --> 00:19:05,570
say thanks to the developers for for

00:19:01,440 --> 00:19:07,789
doing that I really appreciate it and

00:19:05,570 --> 00:19:11,279
you can put in some additional

00:19:07,789 --> 00:19:14,789
parameters what you can do when you have

00:19:11,279 --> 00:19:20,640
this qualifier set up is that you simply

00:19:14,789 --> 00:19:23,029
write koala - - see CI and koala starts

00:19:20,640 --> 00:19:26,039
scanning your entire code base

00:19:23,029 --> 00:19:30,529
recursively analyzes all the Python

00:19:26,039 --> 00:19:34,140
files and comes up with a huge list of

00:19:30,529 --> 00:19:36,600
of comments and suggestions for

00:19:34,140 --> 00:19:41,360
potential improvements this ranges from

00:19:36,600 --> 00:19:45,740
sorting imports to style checks or even

00:19:41,360 --> 00:19:48,929
using aesthetic type checker on Titan so

00:19:45,740 --> 00:19:51,270
please feel encouraged to try koala out

00:19:48,929 --> 00:19:54,390
I'm not as brave to call the

00:19:51,270 --> 00:19:59,490
a best practice yet because it's kind of

00:19:54,390 --> 00:20:04,200
a new tool but um I hope to make that

00:19:59,490 --> 00:20:06,810
statement next year now this is an

00:20:04,200 --> 00:20:09,030
overview of testing debugging and

00:20:06,810 --> 00:20:13,080
maintenance practices that I wanted to

00:20:09,030 --> 00:20:16,530
give here and there's one more thing

00:20:13,080 --> 00:20:18,780
that I would like to do I got into this

00:20:16,530 --> 00:20:21,540
topic and liked it so much that I wrote

00:20:18,780 --> 00:20:24,390
a book about it and I got three copies

00:20:21,540 --> 00:20:27,300
with me that I'm happy to give away so

00:20:24,390 --> 00:20:29,280
after the Q & A session I'm holding a

00:20:27,300 --> 00:20:32,160
bag open here so if you put a piece of

00:20:29,280 --> 00:20:34,650
paper with your name inside I will draw

00:20:32,160 --> 00:20:38,240
three lucky winners at the end of the

00:20:34,650 --> 00:20:42,090
session and are you can read more about

00:20:38,240 --> 00:20:45,180
best practices best practices there and

00:20:42,090 --> 00:20:47,280
some of the content like the debugging

00:20:45,180 --> 00:20:51,360
tutorial you will find on my github

00:20:47,280 --> 00:20:53,480
profile that's it father for my talk

00:20:51,360 --> 00:21:00,909
thank you very much for your attention

00:20:53,480 --> 00:21:03,579
[Applause]

00:21:00,909 --> 00:21:06,909
okay so we have some time for questions

00:21:03,579 --> 00:21:06,909
any questions

00:21:16,450 --> 00:21:22,490
hi one thing I noticed that he didn't

00:21:19,190 --> 00:21:25,490
really mention was talking about virtual

00:21:22,490 --> 00:21:27,770
LANs and kind of the mismatch of

00:21:25,490 --> 00:21:32,659
packages with repositories and Pippins

00:21:27,770 --> 00:21:34,520
of you know compiled of them sauce so

00:21:32,659 --> 00:21:38,059
could you repeat the question please

00:21:34,520 --> 00:21:41,149
and so it's in seems bit missing about

00:21:38,059 --> 00:21:42,799
virtual ends like sure that's a good

00:21:41,149 --> 00:21:47,510
practice to use virtual them so you have

00:21:42,799 --> 00:21:50,390
the correct version of the packages so

00:21:47,510 --> 00:21:54,919
what's the best practice for for getting

00:21:50,390 --> 00:21:56,980
the versions of packages right well so

00:21:54,919 --> 00:21:59,630
using a requirements yes that

00:21:56,980 --> 00:22:02,480
dependencies file do we have

00:21:59,630 --> 00:22:05,840
requirements we have requirements text

00:22:02,480 --> 00:22:08,419
and the takata cloud so yes this is the

00:22:05,840 --> 00:22:11,029
number one way to go for getting the

00:22:08,419 --> 00:22:12,130
getting the right versions because pip

00:22:11,029 --> 00:22:14,480
can deal with it

00:22:12,130 --> 00:22:23,570
Condor should be able to deal with it

00:22:14,480 --> 00:22:24,820
and are safe to some trouble any more

00:22:23,570 --> 00:22:28,610
questions

00:22:24,820 --> 00:22:30,110
sure so one thing while I was going to

00:22:28,610 --> 00:22:33,710
say about the requirements thing is them

00:22:30,110 --> 00:22:35,690
so I work with software that where the

00:22:33,710 --> 00:22:37,880
version number is not fine-grained

00:22:35,690 --> 00:22:41,840
enough so we actually use git commits

00:22:37,880 --> 00:22:44,149
for the exact select actual checkout but

00:22:41,840 --> 00:22:48,049
it relates to if in your requirements

00:22:44,149 --> 00:22:51,620
file if you don't pin exact versions if

00:22:48,049 --> 00:22:55,100
in the future they get update and forget

00:22:51,620 --> 00:22:58,070
deprecated it tightens your maintenance

00:22:55,100 --> 00:23:00,890
issue is that to to users won't be able

00:22:58,070 --> 00:23:03,919
to use your software so just a key point

00:23:00,890 --> 00:23:05,899
there if you've not really kind of

00:23:03,919 --> 00:23:08,529
pulled that out before in talks or in

00:23:05,899 --> 00:23:11,539
your book it's it's an interesting one

00:23:08,529 --> 00:23:14,899
this is one of the business one off the

00:23:11,539 --> 00:23:18,830
tougher problem so um I'd be I'd be a

00:23:14,899 --> 00:23:20,809
bit careful with arm arm with leaving

00:23:18,830 --> 00:23:24,169
leaving a certain version number in your

00:23:20,809 --> 00:23:25,770
dependency like forever I wouldn't do

00:23:24,169 --> 00:23:28,590
that

00:23:25,770 --> 00:23:30,600
rather rather check it for from time to

00:23:28,590 --> 00:23:34,260
time I'll check a few different ones if

00:23:30,600 --> 00:23:36,390
a if a new newer one comes out because I

00:23:34,260 --> 00:23:40,890
would not feel comfortable with leaving

00:23:36,390 --> 00:23:42,960
the version number empty all the time

00:23:40,890 --> 00:23:45,419
especially not if you are planning to

00:23:42,960 --> 00:23:48,720
automatically deploy the code if you are

00:23:45,419 --> 00:23:50,820
running the program manually then okay I

00:23:48,720 --> 00:23:53,490
feel comfortable with it but not if you

00:23:50,820 --> 00:23:58,020
have any automated pipeline running in

00:23:53,490 --> 00:24:00,870
the back of it is your book also

00:23:58,020 --> 00:24:03,299
available as an e-book

00:24:00,870 --> 00:24:10,520
yes but I'm unfortunately you have to

00:24:03,299 --> 00:24:10,520
pay for it but it is yet fair enough

00:24:12,799 --> 00:24:19,140
okay no more questions then so that's it

00:24:17,659 --> 00:24:26,719
stop

00:24:19,140 --> 00:24:26,719

YouTube URL: https://www.youtube.com/watch?v=F3yh-LgoaME


