Title: Anton Caceres - Using the right Async tool, present day
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Using the right Async tool, present day
[EuroPython 2017 - Talk - 2017-07-11 - Arengo]
[Rimini, Italy]

Recent releases like AsyncIO and Django Channels gave a new push towards building real-time web-apps fast and easy. However, as similar tools exist in Python since 2000th, how should we balance between modern and time-proven?

This talk includes but is not focused just on AsyncIO. It gives an overview of Async libraries in Python, and helps with choosing a right tool for various web tasks.

It describes caveats of using Twisted, Tornado and AsyncIO including theory and live code, and concludes with a basic overview of Django Channels.

Talk plan


Why do we need Async Web (5 min)
Existing libraries and frameworks:  Twisted, Tornado, AsyncIO (15 min)
Sample task, sample code, conclusions (10 min)
(optional) what's about Django Channels?
Q & A (5 min)

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,569 --> 00:00:09,709
hello everyone super cool to see you

00:00:07,700 --> 00:00:11,540
today yeah I have not the pole be great

00:00:09,709 --> 00:00:12,740
guys sorry I used it I loved it but

00:00:11,540 --> 00:00:17,150
today I will be talking about the

00:00:12,740 --> 00:00:20,029
different thing with yeah we will talk

00:00:17,150 --> 00:00:23,000
about a sync and async does not mean

00:00:20,029 --> 00:00:25,940
async IO Python is a rich language with

00:00:23,000 --> 00:00:29,780
a lot of nice frameworks and tools will

00:00:25,940 --> 00:00:32,119
be looking shortly in many of those with

00:00:29,780 --> 00:00:35,420
a little live code with a little demo

00:00:32,119 --> 00:00:37,489
with a little bit of theory as well just

00:00:35,420 --> 00:00:39,859
to have an overview what is there what's

00:00:37,489 --> 00:00:42,019
available for us right now what tool can

00:00:39,859 --> 00:00:45,409
we use on the would serve circumstances

00:00:42,019 --> 00:00:48,050
and so on so the way we're going to do

00:00:45,409 --> 00:00:50,030
today we all like come from different

00:00:48,050 --> 00:00:52,339
backgrounds some of us already have

00:00:50,030 --> 00:00:54,350
experience with acing tools and

00:00:52,339 --> 00:00:56,780
generally network development in Python

00:00:54,350 --> 00:00:58,519
some don't so you can interrupt me and

00:00:56,780 --> 00:01:00,559
ask questions right during the talk

00:00:58,519 --> 00:01:04,070
because I really want that everyone like

00:01:00,559 --> 00:01:06,740
keeps track of this talk well so please

00:01:04,070 --> 00:01:08,479
do not wait until the end rise your hand

00:01:06,740 --> 00:01:11,450
or just ask the question I'll repeat it

00:01:08,479 --> 00:01:13,250
I'll do my best to keep everyone like in

00:01:11,450 --> 00:01:14,500
a good mood and understanding what's

00:01:13,250 --> 00:01:18,950
happening here

00:01:14,500 --> 00:01:20,750
let's go all right so first thing I have

00:01:18,950 --> 00:01:23,659
to say is I know it was a difficult

00:01:20,750 --> 00:01:25,549
choice to come to this room having seven

00:01:23,659 --> 00:01:28,460
tracks in Europe Python and also like

00:01:25,549 --> 00:01:32,380
having this I know what we've been

00:01:28,460 --> 00:01:34,609
thinking about it's this versus this and

00:01:32,380 --> 00:01:36,799
burning your eyes to is good spatial

00:01:34,609 --> 00:01:39,189
with my code is of course a tough

00:01:36,799 --> 00:01:42,950
decision so thank you for taking that

00:01:39,189 --> 00:01:46,130
we'll do our best so as I said I have a

00:01:42,950 --> 00:01:47,780
live examples in my talk included and we

00:01:46,130 --> 00:01:50,479
can also have discussions right during

00:01:47,780 --> 00:01:53,719
the talk and we are in Italy so I hope

00:01:50,479 --> 00:01:56,479
coffee helps as well Who am I

00:01:53,719 --> 00:01:57,490
very shortly who knows this log on my

00:01:56,479 --> 00:02:01,850
t-shirt

00:01:57,490 --> 00:02:03,679
yes it's Python web so I didn't do any

00:02:01,850 --> 00:02:06,049
awesome framework in Python yes

00:02:03,679 --> 00:02:08,539
unfortunately I hope so I will do it in

00:02:06,049 --> 00:02:09,920
the future but for now the only thing I

00:02:08,539 --> 00:02:11,700
can say about myself

00:02:09,920 --> 00:02:15,569
no framework okay

00:02:11,700 --> 00:02:17,910
alright other idea Thanks yeah so for

00:02:15,569 --> 00:02:19,890
now I can say that I'm the one who is

00:02:17,910 --> 00:02:21,599
Corgan izing Vikon Webb so that's

00:02:19,890 --> 00:02:25,830
probably the best description of myself

00:02:21,599 --> 00:02:28,470
and I'm a freelancer yes and the plan

00:02:25,830 --> 00:02:30,660
about today's talk is first we'll just

00:02:28,470 --> 00:02:32,580
have a bit of the theory recap like what

00:02:30,660 --> 00:02:35,340
is this in computing in general or what

00:02:32,580 --> 00:02:40,080
we have in Python available what tools

00:02:35,340 --> 00:02:42,450
we have that we can use already now we

00:02:40,080 --> 00:02:44,580
will go then into twisted tornado and I

00:02:42,450 --> 00:02:47,400
think a are a bit more detailed we'll

00:02:44,580 --> 00:02:49,530
look including the examples how it works

00:02:47,400 --> 00:02:52,739
then we'll have Q&A and I hope we'll

00:02:49,530 --> 00:02:54,750
have some time to just briefly discuss

00:02:52,739 --> 00:02:57,930
junga channels because it's a trendy

00:02:54,750 --> 00:03:00,470
topic and it's also kind of a sink ish

00:02:57,930 --> 00:03:03,959
so I hope that we have time for that too

00:03:00,470 --> 00:03:06,390
all right so what they think a quick

00:03:03,959 --> 00:03:09,030
recap what is it in general this

00:03:06,390 --> 00:03:14,940
buzzword so what we see on this picture

00:03:09,030 --> 00:03:15,810
is a task yeah we have um you can see my

00:03:14,940 --> 00:03:19,859
laser pointer

00:03:15,810 --> 00:03:22,709
yes great alright so we have a task with

00:03:19,859 --> 00:03:25,230
this process synchronously at first we

00:03:22,709 --> 00:03:28,530
have the requests coming in here we have

00:03:25,230 --> 00:03:31,290
processing until here then the results

00:03:28,530 --> 00:03:33,930
coming out then the request number two

00:03:31,290 --> 00:03:35,790
comes in between then we processing it

00:03:33,930 --> 00:03:37,709
and response and then the request number

00:03:35,790 --> 00:03:39,780
three coming in process response that's

00:03:37,709 --> 00:03:41,970
like a classic model that they show us

00:03:39,780 --> 00:03:43,880
in school but the thing is that it

00:03:41,970 --> 00:03:46,440
actually never works this way obviously

00:03:43,880 --> 00:03:48,900
because one request will never wait for

00:03:46,440 --> 00:03:50,670
another request to be completed in the

00:03:48,900 --> 00:03:52,650
reality we will have one request and

00:03:50,670 --> 00:03:54,299
then right away another and then right

00:03:52,650 --> 00:03:54,750
away the third one and so on and so

00:03:54,299 --> 00:03:58,590
forth

00:03:54,750 --> 00:04:00,569
so we'll our requests never wait for

00:03:58,590 --> 00:04:03,690
responses they will just come and hope

00:04:00,569 --> 00:04:05,579
that women we can handle them somehow so

00:04:03,690 --> 00:04:08,430
you see that the request number one

00:04:05,579 --> 00:04:10,410
comes our main thread of the program is

00:04:08,430 --> 00:04:12,780
processing it and then requests number

00:04:10,410 --> 00:04:15,239
two comes but we do not have resources

00:04:12,780 --> 00:04:16,889
for that so we just wait the request

00:04:15,239 --> 00:04:18,389
number three comes and it also has to

00:04:16,889 --> 00:04:21,090
wait because we don't have resources for

00:04:18,389 --> 00:04:22,919
that and then when the request one is

00:04:21,090 --> 00:04:24,450
done only then we can go on the request

00:04:22,919 --> 00:04:26,640
number two and only then we can

00:04:24,450 --> 00:04:29,340
go to the request number three that's

00:04:26,640 --> 00:04:31,530
their reality now what we can also

00:04:29,340 --> 00:04:35,180
notice in this picture is that the

00:04:31,530 --> 00:04:38,040
request number one it also has some

00:04:35,180 --> 00:04:40,560
spots here which I marked as waiting

00:04:38,040 --> 00:04:42,630
this means that when we are processing

00:04:40,560 --> 00:04:44,400
some requests it does not really mean

00:04:42,630 --> 00:04:47,010
that we are like heavily computing

00:04:44,400 --> 00:04:48,810
something all of the time most of the

00:04:47,010 --> 00:04:50,460
times especially in web development we

00:04:48,810 --> 00:04:53,670
are waiting for something else like for

00:04:50,460 --> 00:04:56,370
the database or for a file i/o maybe

00:04:53,670 --> 00:04:58,530
some slow NFS share or whatever so we

00:04:56,370 --> 00:04:58,950
are not really computing something all

00:04:58,530 --> 00:05:00,990
the time

00:04:58,950 --> 00:05:02,670
we are often waiting for another

00:05:00,990 --> 00:05:04,830
resources and the problem in this

00:05:02,670 --> 00:05:05,550
approach is that even though we are just

00:05:04,830 --> 00:05:08,040
waiting

00:05:05,550 --> 00:05:10,080
since we have just one main thread and

00:05:08,040 --> 00:05:12,450
we are dealing with this one thread with

00:05:10,080 --> 00:05:15,930
one request other requests have to wait

00:05:12,450 --> 00:05:18,180
and that could be optimized and this is

00:05:15,930 --> 00:05:20,220
where asynchronous computing comes in so

00:05:18,180 --> 00:05:23,760
the idea is that instead of waiting we

00:05:20,220 --> 00:05:26,100
can just do other work so we can work on

00:05:23,760 --> 00:05:28,650
other requests too and this is what's

00:05:26,100 --> 00:05:31,440
shown on this chart it is a request one

00:05:28,650 --> 00:05:33,270
comes in its processed then let's say

00:05:31,440 --> 00:05:35,520
that at this point we request number two

00:05:33,270 --> 00:05:38,000
comes in request number one is actually

00:05:35,520 --> 00:05:42,210
waiting for the database so with smart

00:05:38,000 --> 00:05:44,220
software says ok we can wait here for

00:05:42,210 --> 00:05:46,980
some response meanwhile we will do

00:05:44,220 --> 00:05:48,840
another thing and another thing is

00:05:46,980 --> 00:05:54,390
request number two and we start

00:05:48,840 --> 00:05:57,480
processing it easy good next so if we

00:05:54,390 --> 00:05:59,760
map this very very simple chart that I

00:05:57,480 --> 00:06:02,460
showed you on the web servers and the

00:05:59,760 --> 00:06:03,030
web development in general this is how

00:06:02,460 --> 00:06:06,540
it will look

00:06:03,030 --> 00:06:09,840
so obviously one request is one client

00:06:06,540 --> 00:06:13,650
or one client request in a browser let's

00:06:09,840 --> 00:06:16,170
say or on some API so let's say we start

00:06:13,650 --> 00:06:18,570
our overview with the threaded web

00:06:16,170 --> 00:06:21,870
server and this is a very simple idea

00:06:18,570 --> 00:06:24,000
how can we handle many requests

00:06:21,870 --> 00:06:25,950
concurrently is it that we just spin a

00:06:24,000 --> 00:06:28,830
new threat to every new request you'd

00:06:25,950 --> 00:06:31,260
like this totally makes sense it is

00:06:28,830 --> 00:06:33,000
still a blocking approach but so we can

00:06:31,260 --> 00:06:34,700
scale because the more requests we have

00:06:33,000 --> 00:06:36,590
the most ready start

00:06:34,700 --> 00:06:40,130
and we handle each new request in a new

00:06:36,590 --> 00:06:41,870
thread the squad meaning user one is

00:06:40,130 --> 00:06:44,450
requesting some webpage we are handling

00:06:41,870 --> 00:06:46,720
it here then user number two joints we

00:06:44,450 --> 00:06:49,880
handle it here and so every next user

00:06:46,720 --> 00:06:52,340
starts another thread on our back end

00:06:49,880 --> 00:06:55,600
the problem is obviously doesn't scale

00:06:52,340 --> 00:06:59,680
very well who use Apache maybe

00:06:55,600 --> 00:07:02,870
old-school ok good so I used Apache 2

00:06:59,680 --> 00:07:06,860
this is a patch in my opinion under many

00:07:02,870 --> 00:07:08,930
threads when you have too much so it

00:07:06,860 --> 00:07:10,610
doesn't scale that's the problem and the

00:07:08,930 --> 00:07:13,820
biggest problem of that is that when

00:07:10,610 --> 00:07:16,190
Apache does this not only your new

00:07:13,820 --> 00:07:18,410
client will will just get nothing but

00:07:16,190 --> 00:07:19,010
also the client that are already like in

00:07:18,410 --> 00:07:22,760
progress

00:07:19,010 --> 00:07:24,710
those who are almost done if Apache

00:07:22,760 --> 00:07:26,980
crashes that's it nobody gets anything

00:07:24,710 --> 00:07:29,750
that's the problem of this reddit server

00:07:26,980 --> 00:07:33,170
so there was a smart idea why don't we

00:07:29,750 --> 00:07:35,870
have a pool like we can say our thread

00:07:33,170 --> 00:07:37,340
the server is capable of I don't know 16

00:07:35,870 --> 00:07:39,380
threads let's say and it does it

00:07:37,340 --> 00:07:41,870
efficiently so we have a fixed pool of

00:07:39,380 --> 00:07:43,640
16 threads whenever there is more you

00:07:41,870 --> 00:07:46,400
just have to wait but we at least know

00:07:43,640 --> 00:07:48,980
that this 16 are covered without any

00:07:46,400 --> 00:07:51,290
problem yeah that's a good idea so we

00:07:48,980 --> 00:07:53,060
have in this example just two threads in

00:07:51,290 --> 00:07:55,040
the pool we have thread one that is

00:07:53,060 --> 00:07:56,900
doing something through two then the

00:07:55,040 --> 00:07:58,580
request number one and the request

00:07:56,900 --> 00:07:59,000
number two which is just waiting this

00:07:58,580 --> 00:08:02,780
works

00:07:59,000 --> 00:08:06,080
yeah so thread the thread threaded pool

00:08:02,780 --> 00:08:08,120
works until obviously we just reach a

00:08:06,080 --> 00:08:09,590
point where there are not enough thread

00:08:08,120 --> 00:08:11,960
in the pool to handle all of the load

00:08:09,590 --> 00:08:14,960
the good thing is that they just have to

00:08:11,960 --> 00:08:17,450
wait the clients I mean it will not

00:08:14,960 --> 00:08:20,000
crash as hard as normal threaded server

00:08:17,450 --> 00:08:23,330
but yeah you can do more with your

00:08:20,000 --> 00:08:25,730
server and now comes the synchronous web

00:08:23,330 --> 00:08:30,050
server from the same theories that I

00:08:25,730 --> 00:08:32,479
already shown to you we have just one

00:08:30,050 --> 00:08:34,490
thread and we're using this thread to

00:08:32,479 --> 00:08:36,229
like switch between different tasks in

00:08:34,490 --> 00:08:40,040
different points of time so whenever we

00:08:36,229 --> 00:08:43,099
have a free slots free resources we are

00:08:40,040 --> 00:08:45,110
taking another task when there is when

00:08:43,099 --> 00:08:47,470
the response or when some well let's say

00:08:45,110 --> 00:08:49,120
the network socket has data of our

00:08:47,470 --> 00:08:51,700
request we're switching back to it and

00:08:49,120 --> 00:08:54,370
we finish in it don't worry I mean it's

00:08:51,700 --> 00:08:55,930
a very very brief overview I will get

00:08:54,370 --> 00:08:58,540
into details it will get more clear

00:08:55,930 --> 00:09:00,490
later on so the main thing that I have

00:08:58,540 --> 00:09:03,040
to point out right now is that in this

00:09:00,490 --> 00:09:05,110
scenario we have just one thread and we

00:09:03,040 --> 00:09:07,240
hope that this one thread will like

00:09:05,110 --> 00:09:11,220
jungle with as many tasks as it can and

00:09:07,240 --> 00:09:14,020
switch on some smart scenario that

00:09:11,220 --> 00:09:16,300
whenever there is some blocking

00:09:14,020 --> 00:09:18,400
operation the thread is doing another

00:09:16,300 --> 00:09:21,370
task that's that's the whole idea I

00:09:18,400 --> 00:09:23,470
didn't find a better gift so this is the

00:09:21,370 --> 00:09:25,690
rather this is the asynchronous server

00:09:23,470 --> 00:09:28,960
in my vision

00:09:25,690 --> 00:09:31,900
good of course it was just blah blah so

00:09:28,960 --> 00:09:35,530
let's have a real chart here you have

00:09:31,900 --> 00:09:37,180
Apache like expedient nginx Apache being

00:09:35,530 --> 00:09:39,430
threaded server and Janique being a

00:09:37,180 --> 00:09:43,660
synchronous web server and these are

00:09:39,430 --> 00:09:49,390
requests per second chart so you see

00:09:43,660 --> 00:09:50,980
here that nginx gets as high as possible

00:09:49,390 --> 00:09:55,630
on this comparison

00:09:50,980 --> 00:09:57,340
it can handle around 12,000 requests per

00:09:55,630 --> 00:10:00,250
second obviously it depends a lot on

00:09:57,340 --> 00:10:04,000
your concrete's server and hardware and

00:10:00,250 --> 00:10:07,090
so on but that's the approximate picture

00:10:04,000 --> 00:10:09,190
that you can see in practice then there

00:10:07,090 --> 00:10:12,130
is another good chart is a memory usage

00:10:09,190 --> 00:10:14,320
as I already said threads are expensive

00:10:12,130 --> 00:10:17,050
so whenever Apache starts a new thread

00:10:14,320 --> 00:10:18,790
it costs you those the most the more

00:10:17,050 --> 00:10:22,060
clients you have the most read you run

00:10:18,790 --> 00:10:25,270
the more memory is being used in

00:10:22,060 --> 00:10:28,120
contrast nginx and lighttpd are quite

00:10:25,270 --> 00:10:31,720
sparing with your operating system

00:10:28,120 --> 00:10:34,930
resources good so now that gets more

00:10:31,720 --> 00:10:36,610
into practice so async Python is not

00:10:34,930 --> 00:10:37,720
async IO there have been tools around

00:10:36,610 --> 00:10:40,570
for years

00:10:37,720 --> 00:10:42,430
let's say that tornado is eight years

00:10:40,570 --> 00:10:45,820
old and then there is twisted which is

00:10:42,430 --> 00:10:48,160
oh but it's quite a while I'd say and

00:10:45,820 --> 00:10:52,960
then there are also other languages

00:10:48,160 --> 00:10:55,570
there and you have a think it's not

00:10:52,960 --> 00:10:57,340
something new so the question is why are

00:10:55,570 --> 00:11:01,060
blocking servers still popular

00:10:57,340 --> 00:11:03,280
like you can say while Jenga popular

00:11:01,060 --> 00:11:05,920
it's not they think it's so cool I'm

00:11:03,280 --> 00:11:07,720
using Jenga because it's easy I think

00:11:05,920 --> 00:11:09,640
everyone would agree that sequential

00:11:07,720 --> 00:11:12,070
code is just much easier to write use

00:11:09,640 --> 00:11:15,010
you don't want to have a callback he'll

00:11:12,070 --> 00:11:17,020
like you haven't usually not just you

00:11:15,010 --> 00:11:19,240
write your nice fancy code in Django and

00:11:17,020 --> 00:11:21,490
if you don't have like very specific

00:11:19,240 --> 00:11:22,300
tasks the jungler cannot handle you

00:11:21,490 --> 00:11:24,460
happy with it

00:11:22,300 --> 00:11:26,260
so why I'm doing this talk is I'm going

00:11:24,460 --> 00:11:27,880
to show you the drug different tools in

00:11:26,260 --> 00:11:29,890
Python that allow you to write a

00:11:27,880 --> 00:11:36,180
synchronous code as easy as synchronous

00:11:29,890 --> 00:11:39,160
code or at least comparable easy yes and

00:11:36,180 --> 00:11:40,900
the goal is to make it as easy as Django

00:11:39,160 --> 00:11:43,330
or Ruby on Rails then I would say that

00:11:40,900 --> 00:11:45,730
we can seriously consider using

00:11:43,330 --> 00:11:49,660
asynchronous tools of Python on a daily

00:11:45,730 --> 00:11:51,700
basis so yeah as I said we prefer

00:11:49,660 --> 00:11:54,520
anything that covers our needs in the

00:11:51,700 --> 00:11:57,520
simplest way possible the good news is

00:11:54,520 --> 00:11:59,500
that we have many choices in Python

00:11:57,520 --> 00:12:01,060
already at this point and we can try

00:11:59,500 --> 00:12:04,000
different things which we are going to

00:12:01,060 --> 00:12:06,700
do today and we will see what is best

00:12:04,000 --> 00:12:08,680
suitable for us let's start with twisted

00:12:06,700 --> 00:12:10,060
twisted is like a Python dinosaur who

00:12:08,680 --> 00:12:12,880
used twisted in this room

00:12:10,060 --> 00:12:15,640
oh cool many people that's great I love

00:12:12,880 --> 00:12:18,400
twisted so twisted is a framework it's

00:12:15,640 --> 00:12:20,380
huge it includes a powerful high-level

00:12:18,400 --> 00:12:23,170
components like web server user

00:12:20,380 --> 00:12:25,600
authentication systems as well as mail

00:12:23,170 --> 00:12:28,150
server I know it's instant messaging SSH

00:12:25,600 --> 00:12:30,640
client DNS clients and servers anything

00:12:28,150 --> 00:12:32,350
so basically any network tasks you have

00:12:30,640 --> 00:12:36,780
most likely you will have it already

00:12:32,350 --> 00:12:39,430
sold with twisted also exempt EP server

00:12:36,780 --> 00:12:41,589
anything really so if you are looking

00:12:39,430 --> 00:12:44,700
for let's say some implementation of

00:12:41,589 --> 00:12:46,600
some network protocol with Python then

00:12:44,700 --> 00:12:49,020
twisted is your best bet

00:12:46,600 --> 00:12:52,480
most likely it's already done in twisted

00:12:49,020 --> 00:12:54,310
so as they say

00:12:52,480 --> 00:12:56,140
twisted doesn't call you don't call

00:12:54,310 --> 00:12:58,839
twisted twisted call zo that's like a

00:12:56,140 --> 00:13:00,700
motive twisted and that actually applies

00:12:58,839 --> 00:13:02,230
the only thing frameworks in vitam but

00:13:00,700 --> 00:13:05,230
they've been first someplace you

00:13:02,230 --> 00:13:07,510
discredit to them the base of twisted is

00:13:05,230 --> 00:13:10,150
the event loop as always thing so

00:13:07,510 --> 00:13:11,690
obviously so twisted is build around the

00:13:10,150 --> 00:13:13,610
reactor pattern

00:13:11,690 --> 00:13:15,230
even look responsible for handling

00:13:13,610 --> 00:13:17,750
network and system events

00:13:15,230 --> 00:13:20,630
it basically says when the event a

00:13:17,750 --> 00:13:23,900
happens react with function or with a

00:13:20,630 --> 00:13:25,880
callback B and one started the reactor

00:13:23,900 --> 00:13:27,440
loops over and over doing this kind of

00:13:25,880 --> 00:13:29,000
task so it both for IO

00:13:27,440 --> 00:13:31,730
and just triggers the appropriate

00:13:29,000 --> 00:13:41,210
callbacks depending on what events we

00:13:31,730 --> 00:13:44,360
have loops over and over then let's have

00:13:41,210 --> 00:13:47,020
an example finally so as I said twisted

00:13:44,360 --> 00:13:50,210
this is a really low-level framework as

00:13:47,020 --> 00:13:52,220
our first example I would just try to

00:13:50,210 --> 00:13:57,430
print something on the network socket so

00:13:52,220 --> 00:14:01,430
as low as possible and here we go so I

00:13:57,430 --> 00:14:04,040
have the solution right here I will show

00:14:01,430 --> 00:14:06,800
you I will run it later on first let me

00:14:04,040 --> 00:14:08,660
go through the code just you know to to

00:14:06,800 --> 00:14:12,230
show you what it's doing so you feel

00:14:08,660 --> 00:14:15,410
like comfortable with this so what we

00:14:12,230 --> 00:14:17,660
have here it's a really really

00:14:15,410 --> 00:14:20,450
simplistic minimal case how do you write

00:14:17,660 --> 00:14:22,390
into socket in twisted so first you have

00:14:20,450 --> 00:14:25,820
to factorize of course you have a

00:14:22,390 --> 00:14:28,120
protocol factory here first and the zero

00:14:25,820 --> 00:14:31,010
factor here you define this two classes

00:14:28,120 --> 00:14:32,300
and that's actually what this what you

00:14:31,010 --> 00:14:34,160
have always in twisted you have a

00:14:32,300 --> 00:14:35,690
factory for everything and you have a

00:14:34,160 --> 00:14:38,570
callback for everything it makes it kind

00:14:35,690 --> 00:14:41,180
of complicated but if you are really

00:14:38,570 --> 00:14:44,330
willing to implement some difficult

00:14:41,180 --> 00:14:45,620
protocol nice and clean it's a good way

00:14:44,330 --> 00:14:49,550
to do it because you cannot miss it

00:14:45,620 --> 00:14:51,640
something accidentally so of course the

00:14:49,550 --> 00:14:54,950
main part here is the greeting protocol

00:14:51,640 --> 00:14:56,780
we inherit from protocol protocol and we

00:14:54,950 --> 00:14:59,120
define our first and only callback

00:14:56,780 --> 00:15:00,950
connection made meaning then whenever

00:14:59,120 --> 00:15:03,560
there is the network connection on this

00:15:00,950 --> 00:15:06,620
socket we do self transfer twice

00:15:03,560 --> 00:15:08,450
ciao Europe item and that's it and we

00:15:06,620 --> 00:15:11,630
close the connection that's the only

00:15:08,450 --> 00:15:14,240
thing we do here and let's see if I lie

00:15:11,630 --> 00:15:20,020
to you or not by running this in

00:15:14,240 --> 00:15:20,020
terminal ok you don't see my terminal

00:15:20,780 --> 00:15:30,040
I will bring it to them No

00:15:39,580 --> 00:15:52,820
okay I will just mirror the displays it

00:15:42,140 --> 00:15:57,320
will be faster in this case okay can you

00:15:52,820 --> 00:16:00,649
see this that's really good okay let's

00:15:57,320 --> 00:16:04,120
start like this then then we see okay so

00:16:00,649 --> 00:16:04,120
I have all of the examples here

00:16:17,480 --> 00:16:23,149
I started the example twisted one despy

00:16:21,589 --> 00:16:26,029
it's the same code that you've just seen

00:16:23,149 --> 00:16:27,980
on the slides and to check it I cannot

00:16:26,029 --> 00:16:31,399
do it with the browser because it's a

00:16:27,980 --> 00:16:34,810
telnet socket it's a just around socket

00:16:31,399 --> 00:16:34,810
of this machine so use telnet

00:16:44,309 --> 00:16:47,519
bless sir

00:16:58,920 --> 00:17:07,199
okay so we have here ciao Europe item ah

00:17:03,900 --> 00:17:10,480
you don't see that oh I got it okay I

00:17:07,199 --> 00:17:15,730
need to zoom in some how can I change

00:17:10,480 --> 00:17:19,570
the resolution or will it crash okay

00:17:15,730 --> 00:17:24,760
or anyone knows the shortcut for item to

00:17:19,570 --> 00:17:28,540
zoom in commons + okay

00:17:24,760 --> 00:17:34,120
yes thank you guys thank you great ok so

00:17:28,540 --> 00:17:37,560
then again the demo you see ciao you're

00:17:34,120 --> 00:17:44,100
a Python print it here it worked good

00:17:37,560 --> 00:17:52,890
then jumping back to the presentation

00:17:44,100 --> 00:17:52,890
no yes I'll take me roll off

00:17:55,860 --> 00:18:01,090
yeah this jumping back and forth is not

00:17:58,420 --> 00:18:06,760
perfectly optimized I'm sorry it will

00:18:01,090 --> 00:18:09,730
door back good okay we're back then of

00:18:06,760 --> 00:18:10,450
course just the socket connection is

00:18:09,730 --> 00:18:13,450
kind of boring

00:18:10,450 --> 00:18:18,100
we are web developers most of us I think

00:18:13,450 --> 00:18:21,310
in this room so let's see some web or

00:18:18,100 --> 00:18:24,220
web related case let's have a twisted

00:18:21,310 --> 00:18:28,360
app that returns hello Europe item as a

00:18:24,220 --> 00:18:30,610
get request Handler so what we have to

00:18:28,360 --> 00:18:34,480
do here is a win here it from the

00:18:30,610 --> 00:18:41,080
resource this is a class in twister that

00:18:34,480 --> 00:18:43,990
implements get more like HTTP stuff then

00:18:41,080 --> 00:18:48,670
we define the render get methods you see

00:18:43,990 --> 00:18:52,030
it here render get and this is easiest

00:18:48,670 --> 00:18:55,960
return Cho Europe isin and Python 3 so

00:18:52,030 --> 00:18:58,600
and code utf-8 I think I will not do the

00:18:55,960 --> 00:19:00,250
mirroring again so you can just trust me

00:18:58,600 --> 00:19:03,250
that it works if we have time at the end

00:19:00,250 --> 00:19:06,060
I will show you this examples in the

00:19:03,250 --> 00:19:09,340
shell otherwise it gets really boring

00:19:06,060 --> 00:19:11,590
next twist to this school so I'm not

00:19:09,340 --> 00:19:13,810
going to show you much more twisted

00:19:11,590 --> 00:19:16,810
because the goal is just to show you an

00:19:13,810 --> 00:19:18,910
idea if you implemented some protocol

00:19:16,810 --> 00:19:20,770
you are inheriting from the protocol

00:19:18,910 --> 00:19:22,930
class you need to define factories of

00:19:20,770 --> 00:19:25,390
factories of factories and eventually it

00:19:22,930 --> 00:19:27,190
will work by that I want to say that

00:19:25,390 --> 00:19:29,170
twisted is an excellent choice for the

00:19:27,190 --> 00:19:31,360
vast number of cases and especially if

00:19:29,170 --> 00:19:33,540
you need to integrate some multiple

00:19:31,360 --> 00:19:35,620
aspects of functionality for some

00:19:33,540 --> 00:19:38,170
network protocol especially a

00:19:35,620 --> 00:19:40,540
complicated one so first of all twisted

00:19:38,170 --> 00:19:42,970
is a concurrency framework it allows you

00:19:40,540 --> 00:19:45,040
to jungle multiple tasks in one

00:19:42,970 --> 00:19:47,290
application without using threads that

00:19:45,040 --> 00:19:50,530
was the goal of asynchronous development

00:19:47,290 --> 00:19:52,780
and the code is tends to be a bit

00:19:50,530 --> 00:19:54,160
complicated I would say it's it's

00:19:52,780 --> 00:19:56,290
actually not complicated it's just

00:19:54,160 --> 00:19:58,570
complex so you will have a lot of codes

00:19:56,290 --> 00:20:00,310
but the good thing is that you can

00:19:58,570 --> 00:20:01,900
reduce components of twisted and they

00:20:00,310 --> 00:20:04,540
have components for pretty much anything

00:20:01,900 --> 00:20:06,220
you like so it's easy to hack in into

00:20:04,540 --> 00:20:09,280
existing protocol and customize

00:20:06,220 --> 00:20:12,340
to your needs it's also perfectly

00:20:09,280 --> 00:20:16,840
attested so like if you would write on

00:20:12,340 --> 00:20:19,659
our extent VP boat or something I'd say

00:20:16,840 --> 00:20:22,299
go with twisted but then there are other

00:20:19,659 --> 00:20:25,870
tools that make a thing development in

00:20:22,299 --> 00:20:28,799
Python even easier just the bits of

00:20:25,870 --> 00:20:32,679
words about async evolution in Python

00:20:28,799 --> 00:20:34,929
since by some 2.5 we have the yield

00:20:32,679 --> 00:20:38,710
keyword and it was used just for

00:20:34,929 --> 00:20:40,780
generators and then after some time

00:20:38,710 --> 00:20:42,789
there was a tornado web framework that

00:20:40,780 --> 00:20:44,169
used it for asynchronous development of

00:20:42,789 --> 00:20:46,900
web applications I will show you

00:20:44,169 --> 00:20:49,360
examples later then in Python 3 the

00:20:46,900 --> 00:20:51,250
three we got the generation delegate

00:20:49,360 --> 00:20:54,010
generator delegation expression yield

00:20:51,250 --> 00:20:56,200
from which is a very similar concept but

00:20:54,010 --> 00:20:58,179
it's just a bit better

00:20:56,200 --> 00:21:03,100
I'll show you later and then finally at

00:20:58,179 --> 00:21:04,840
3.5 we have a weight which like in 99

00:21:03,100 --> 00:21:06,700
cases for you will be totally the same

00:21:04,840 --> 00:21:09,039
as yield from but it just makes more

00:21:06,700 --> 00:21:10,929
sense as a word so it's easier to

00:21:09,039 --> 00:21:14,770
understand what is it actually doing and

00:21:10,929 --> 00:21:16,990
this little these little things they

00:21:14,770 --> 00:21:18,909
matter so they they help you to write

00:21:16,990 --> 00:21:21,159
asynchronous code in the similar way

00:21:18,909 --> 00:21:25,960
that you write the synchronous code now

00:21:21,159 --> 00:21:28,659
let's get to more examples you do not

00:21:25,960 --> 00:21:30,580
have any excuse not to use a synchronous

00:21:28,659 --> 00:21:33,280
code in Python

00:21:30,580 --> 00:21:36,970
since 2.5 because that's the point when

00:21:33,280 --> 00:21:38,559
we got yield and generators but I would

00:21:36,970 --> 00:21:41,080
recommend to use Python 3

00:21:38,559 --> 00:21:44,409
especially 3.5 because it makes things

00:21:41,080 --> 00:21:46,240
even better and again you do not need to

00:21:44,409 --> 00:21:48,340
write callbacks every time like you do

00:21:46,240 --> 00:21:52,980
it and twist it and to wipe callbacks

00:21:48,340 --> 00:21:55,390
Abed who is also JavaScript developer or

00:21:52,980 --> 00:21:58,120
just some JavaScript okay so I don't

00:21:55,390 --> 00:22:00,429
have to tell you it's difficult to write

00:21:58,120 --> 00:22:02,080
nice code and I have a little favorite

00:22:00,429 --> 00:22:05,409
example that travels with me on

00:22:02,080 --> 00:22:08,919
different conferences here it is so yeah

00:22:05,409 --> 00:22:12,130
this is like the real code from GS

00:22:08,919 --> 00:22:14,110
it's testing as I can see here but still

00:22:12,130 --> 00:22:15,880
like I know it's it's not something that

00:22:14,110 --> 00:22:18,010
you need to write every day but if you

00:22:15,880 --> 00:22:21,040
even had to write this for yourself

00:22:18,010 --> 00:22:23,440
there is something wrong oh and they

00:22:21,040 --> 00:22:25,810
recommend you a callback hell calm if

00:22:23,440 --> 00:22:28,330
you're not convinced they have more cool

00:22:25,810 --> 00:22:33,130
examples so let's just agree the

00:22:28,330 --> 00:22:36,060
sequential code looks nicer and we will

00:22:33,130 --> 00:22:39,370
try to avoid callbacks from this point I

00:22:36,060 --> 00:22:41,890
think I own the buzzword I think I don't

00:22:39,370 --> 00:22:43,840
have to stop really long time over this

00:22:41,890 --> 00:22:46,300
one because you have awesome talks as

00:22:43,840 --> 00:22:48,730
well in this conference about it still

00:22:46,300 --> 00:22:50,650
obviously I will show you the basis so

00:22:48,730 --> 00:22:52,600
we have some new concepts that can help

00:22:50,650 --> 00:22:55,720
us to ethical escape the callback hell

00:22:52,600 --> 00:22:57,580
in a scene KO and is well in tornado for

00:22:55,720 --> 00:22:59,740
that we need to learn a bit of a theory

00:22:57,580 --> 00:23:02,590
who knows what is the future so maybe I

00:22:59,740 --> 00:23:06,670
can skip it a future objects or okay

00:23:02,590 --> 00:23:08,950
let's have a little little conversation

00:23:06,670 --> 00:23:11,500
here then so a future is just like a

00:23:08,950 --> 00:23:14,350
placeholder object it is designed to

00:23:11,500 --> 00:23:15,970
receive and store a result of some

00:23:14,350 --> 00:23:18,670
operation that is not available right

00:23:15,970 --> 00:23:21,040
now at this point of time so we use the

00:23:18,670 --> 00:23:23,320
future as a placeholder to pass around

00:23:21,040 --> 00:23:26,110
and this will have a reference to the

00:23:23,320 --> 00:23:27,550
result of our operation in the example

00:23:26,110 --> 00:23:29,580
that I told you in the beginning like if

00:23:27,550 --> 00:23:32,530
we are waiting for the database result

00:23:29,580 --> 00:23:35,470
we don't want to just block and wait for

00:23:32,530 --> 00:23:37,360
this result to be available we can store

00:23:35,470 --> 00:23:39,610
it in the future and say ok this future

00:23:37,360 --> 00:23:41,500
it doesn't have a result yet it has a

00:23:39,610 --> 00:23:44,380
reference to the result and it will be

00:23:41,500 --> 00:23:45,970
ready at some later point so the future

00:23:44,380 --> 00:23:49,660
object can be returned to the color

00:23:45,970 --> 00:23:51,310
right away and that color can access the

00:23:49,660 --> 00:23:55,600
actual result later when it's available

00:23:51,310 --> 00:23:57,730
and this is the simplest way to use the

00:23:55,600 --> 00:23:59,410
future to run it so this is obviously

00:23:57,730 --> 00:24:01,450
pretty dumped because it still

00:23:59,410 --> 00:24:04,150
synchronous but it just show you how it

00:24:01,450 --> 00:24:06,490
works so you need the library that works

00:24:04,150 --> 00:24:09,790
with futures like return features and

00:24:06,490 --> 00:24:12,760
for example some async HTTP library you

00:24:09,790 --> 00:24:15,580
do fetch Europe items of you let's say

00:24:12,760 --> 00:24:17,710
that it's slow even though it's not but

00:24:15,580 --> 00:24:20,410
let's pretend it's low and we don't want

00:24:17,710 --> 00:24:22,600
to wait and block so instead this

00:24:20,410 --> 00:24:25,300
library will return your future save it

00:24:22,600 --> 00:24:27,400
in the future variable and then we say

00:24:25,300 --> 00:24:29,020
to the i/o loop I eloped please wait

00:24:27,400 --> 00:24:31,000
until the future is ready

00:24:29,020 --> 00:24:32,860
and then when it's ready we just call

00:24:31,000 --> 00:24:35,290
future that results to get the actual

00:24:32,860 --> 00:24:38,429
results of this operation as easy as

00:24:35,290 --> 00:24:41,410
that now next the core routine a

00:24:38,429 --> 00:24:43,300
quarantine is a function it's a spatial

00:24:41,410 --> 00:24:47,500
like a generator function that can

00:24:43,300 --> 00:24:49,960
return some value and suspend so when we

00:24:47,500 --> 00:24:51,940
call it again as generator it will

00:24:49,960 --> 00:24:55,570
continue from the place where where it

00:24:51,940 --> 00:24:58,260
left off last time so unlike a function

00:24:55,570 --> 00:25:00,730
it can be called multiple times and

00:24:58,260 --> 00:25:02,830
continuing and pausing multiple times

00:25:00,730 --> 00:25:06,070
and this is the minimal example of a

00:25:02,830 --> 00:25:08,020
core routine I didn't use the 3.5 syntax

00:25:06,070 --> 00:25:09,929
on purpose because Co routines are

00:25:08,020 --> 00:25:14,110
something is you can get in Python since

00:25:09,929 --> 00:25:16,480
to the 6 or 2.5 even so there is really

00:25:14,110 --> 00:25:19,990
enough use not to use them so you define

00:25:16,480 --> 00:25:22,330
it just as a generator you say for chunk

00:25:19,990 --> 00:25:23,830
in data the trees and let's say that

00:25:22,330 --> 00:25:26,200
data that's really some really heavy

00:25:23,830 --> 00:25:29,040
operation and then as a generator will

00:25:26,200 --> 00:25:32,710
just yielding chunks back to the color

00:25:29,040 --> 00:25:34,360
that's the minimal example then what

00:25:32,710 --> 00:25:36,700
does it have to do with the synchronous

00:25:34,360 --> 00:25:39,460
development like quarantines play really

00:25:36,700 --> 00:25:41,920
well with futures because future is

00:25:39,460 --> 00:25:43,420
something that can hold a link a

00:25:41,920 --> 00:25:46,420
reference to the result as I already

00:25:43,420 --> 00:25:49,000
said and the core routine can return it

00:25:46,420 --> 00:25:51,640
the so for routine returns futures that

00:25:49,000 --> 00:25:54,130
the way it works co-written returns the

00:25:51,640 --> 00:25:55,929
future it pauses until the futures ready

00:25:54,130 --> 00:26:02,020
and then it continues from this place

00:25:55,929 --> 00:26:05,050
where it stops this is an example a core

00:26:02,020 --> 00:26:07,120
routine and then we already familiar

00:26:05,050 --> 00:26:10,390
with this async HTTP that fetch a

00:26:07,120 --> 00:26:12,730
library that does not block but instead

00:26:10,390 --> 00:26:15,910
returns us a future so a reference to

00:26:12,730 --> 00:26:20,080
the result then we yield the future so

00:26:15,910 --> 00:26:22,420
this is a new new concept here by

00:26:20,080 --> 00:26:24,429
yielding the future we are giving it to

00:26:22,420 --> 00:26:27,400
the color color in this case is the i/o

00:26:24,429 --> 00:26:29,170
loop and we say that ok please do not

00:26:27,400 --> 00:26:31,179
wait to do other stuff in the meanwhile

00:26:29,170 --> 00:26:33,130
like handle other requests in the

00:26:31,179 --> 00:26:34,960
meanwhile and whenever the result of

00:26:33,130 --> 00:26:37,480
this future will be ready please just

00:26:34,960 --> 00:26:39,270
jump back in this place and continue as

00:26:37,480 --> 00:26:41,940
the field was never here

00:26:39,270 --> 00:26:47,040
kind of a magic how it works and then we

00:26:41,940 --> 00:26:49,050
just print it I mentioned that the event

00:26:47,040 --> 00:26:51,060
loop is color in this case so what is

00:26:49,050 --> 00:26:53,580
the event loop it's kind of a reactor

00:26:51,060 --> 00:26:55,800
pattern that we know from computer

00:26:53,580 --> 00:26:58,140
science course it just waits for

00:26:55,800 --> 00:27:00,840
something to happen and it acts upon the

00:26:58,140 --> 00:27:03,440
events it's responsible for handling

00:27:00,840 --> 00:27:06,950
such things as IO and system events and

00:27:03,440 --> 00:27:09,810
I think I think it actually has several

00:27:06,950 --> 00:27:13,050
implementations available like the model

00:27:09,810 --> 00:27:15,720
that will default to the one most likely

00:27:13,050 --> 00:27:19,740
to be most efficient and used in

00:27:15,720 --> 00:27:22,190
operating systems like for for Windows

00:27:19,740 --> 00:27:28,320
it's still using the Select loop but for

00:27:22,190 --> 00:27:31,800
linux and mac OS x KQ so I think I will

00:27:28,320 --> 00:27:33,540
guess which our loop can be used in the

00:27:31,800 --> 00:27:35,370
best case for your particular operating

00:27:33,540 --> 00:27:38,480
system it delegated to the operating

00:27:35,370 --> 00:27:41,070
system loop and just acts as a wrapper

00:27:38,480 --> 00:27:42,950
however you can always explicitly choose

00:27:41,070 --> 00:27:46,230
the underlying loop if you like and

00:27:42,950 --> 00:27:48,300
again in a few words if you don't want

00:27:46,230 --> 00:27:50,850
details the I loop is just something

00:27:48,300 --> 00:27:53,220
that says when the event a happens do

00:27:50,850 --> 00:27:57,060
the function B and save this mapping

00:27:53,220 --> 00:27:59,010
that's in a nutshell what it does let's

00:27:57,060 --> 00:28:04,380
see what they think of event loop is

00:27:59,010 --> 00:28:07,140
doing so here I already use the 3.5

00:28:04,380 --> 00:28:09,540
syntax async depth this is just a fancy

00:28:07,140 --> 00:28:11,820
way to define a core routine it shows

00:28:09,540 --> 00:28:13,650
you right away that hey this is not just

00:28:11,820 --> 00:28:16,620
a function and not just a generator it's

00:28:13,650 --> 00:28:20,190
a core routine they sing that fancy so

00:28:16,620 --> 00:28:23,220
this is Anton stock and what Curtin does

00:28:20,190 --> 00:28:25,920
is it just says do the talk and print

00:28:23,220 --> 00:28:28,560
question after this is finished we do

00:28:25,920 --> 00:28:30,960
not have any yields here yeah so this is

00:28:28,560 --> 00:28:34,050
just a minimal example how do you run

00:28:30,960 --> 00:28:37,500
the I loop no yields no futures just a

00:28:34,050 --> 00:28:39,870
minimal example now bit more complicated

00:28:37,500 --> 00:28:43,740
let's have multiple core routines so

00:28:39,870 --> 00:28:46,160
there is here is Anton stock

00:28:43,740 --> 00:28:48,630
and here is a coroutine grab the coffee

00:28:46,160 --> 00:28:50,670
what I want to show you here is that how

00:28:48,630 --> 00:28:54,150
easy you can switch between two thanks

00:28:50,670 --> 00:28:56,910
to your I loop and distinct i/o so first

00:28:54,150 --> 00:28:58,670
we run Anton's workshop for Anton stop

00:28:56,910 --> 00:29:02,520
we print welcome

00:28:58,670 --> 00:29:05,010
we await away to the same as you in this

00:29:02,520 --> 00:29:07,590
case so we do the blocking operation

00:29:05,010 --> 00:29:10,320
here do talk and at this point where you

00:29:07,590 --> 00:29:11,910
use yield or a weight that the library

00:29:10,320 --> 00:29:13,920
is smart enough to say ok we are waiting

00:29:11,910 --> 00:29:15,870
on some blocking resource let's do

00:29:13,920 --> 00:29:19,140
something else and something else in

00:29:15,870 --> 00:29:20,760
this case is karate in grab coffee so

00:29:19,140 --> 00:29:24,150
then the next line that will be printed

00:29:20,760 --> 00:29:26,610
we'll be drinking coffee and then we are

00:29:24,150 --> 00:29:28,380
awaiting for something again so I hope

00:29:26,610 --> 00:29:30,600
we'll see a hand we have to wait here as

00:29:28,380 --> 00:29:32,970
well so now we jump to some other thing

00:29:30,600 --> 00:29:34,800
and so it jumps back to the Anton stock

00:29:32,970 --> 00:29:37,830
and then this statement will be printed

00:29:34,800 --> 00:29:39,840
thanks for coming and then after this

00:29:37,830 --> 00:29:41,940
coordinates is finished it will continue

00:29:39,840 --> 00:29:43,770
number two again so this is just a

00:29:41,940 --> 00:29:47,270
minimal example how the I loop will

00:29:43,770 --> 00:29:47,270
switch between tasks for you

00:29:52,740 --> 00:30:05,200
could you please repeat yes you also

00:30:02,830 --> 00:30:08,019
have Anton's workshop and he rent on

00:30:05,200 --> 00:30:10,450
stock thank you for noticing it it was

00:30:08,019 --> 00:30:12,820
my best yeah because I planned it as a

00:30:10,450 --> 00:30:15,220
workshop first but then I packed it in

00:30:12,820 --> 00:30:17,409
the talk so yeah this will not work but

00:30:15,220 --> 00:30:20,889
this is absolutely code anyway so I will

00:30:17,409 --> 00:30:24,460
not run it but thanks for pointing it

00:30:20,889 --> 00:30:27,700
out so let's compare all the approaches

00:30:24,460 --> 00:30:29,440
like I'm still trying to to explain the

00:30:27,700 --> 00:30:31,240
judge the general thing about coroutines

00:30:29,440 --> 00:30:34,690
and futures to you so this is also a

00:30:31,240 --> 00:30:36,250
very very simplistic pseudocode this is

00:30:34,690 --> 00:30:38,529
the way that you would write usually a

00:30:36,250 --> 00:30:40,840
sequential code in any frame or any web

00:30:38,529 --> 00:30:43,330
framework that you use let's say this is

00:30:40,840 --> 00:30:45,760
a get request handler we have a huge

00:30:43,330 --> 00:30:47,409
database query a synchronous one we save

00:30:45,760 --> 00:30:51,340
it in the result and then we print the

00:30:47,409 --> 00:30:54,820
result easy everyone did that we will be

00:30:51,340 --> 00:30:56,679
blocking here so we will just wait at

00:30:54,820 --> 00:30:59,970
this point that's how it works in most

00:30:56,679 --> 00:31:02,679
cases that's how it works in Django then

00:30:59,970 --> 00:31:07,210
how would you do it in JavaScript or in

00:31:02,679 --> 00:31:08,830
twisted you would say make the huge

00:31:07,210 --> 00:31:11,230
database query and then you will use a

00:31:08,830 --> 00:31:12,580
callback you would say when the huge

00:31:11,230 --> 00:31:16,149
database query is ready

00:31:12,580 --> 00:31:18,309
call the own result function so this is

00:31:16,149 --> 00:31:20,230
a bit messy because it pushes you

00:31:18,309 --> 00:31:21,909
towards the spaghetti code but it's at

00:31:20,230 --> 00:31:24,610
least very clear because you are not

00:31:21,909 --> 00:31:26,740
using any co-routine future magic so

00:31:24,610 --> 00:31:29,679
it's very explicit you say when this is

00:31:26,740 --> 00:31:32,970
done called this function this is the

00:31:29,679 --> 00:31:36,700
callback way of doing the same thing and

00:31:32,970 --> 00:31:39,010
this is a sinker your alternator way of

00:31:36,700 --> 00:31:42,519
doing the same task you're defining a

00:31:39,010 --> 00:31:44,230
coroutine async that then assuming that

00:31:42,519 --> 00:31:46,149
your huge database query returns the

00:31:44,230 --> 00:31:48,399
future so it supports this kind of

00:31:46,149 --> 00:31:52,500
operation you put a weight in front of

00:31:48,399 --> 00:31:57,100
it and by that you're telling a

00:31:52,500 --> 00:32:00,100
psicological back so huge database query

00:31:57,100 --> 00:32:01,870
returns in the future you yield or away

00:32:00,100 --> 00:32:03,629
the future give it back to the I you

00:32:01,870 --> 00:32:05,440
loop say when this future is ready

00:32:03,629 --> 00:32:07,450
please give us there is

00:32:05,440 --> 00:32:12,040
and just save the results - the result

00:32:07,450 --> 00:32:12,820
of variable so this and this should be

00:32:12,040 --> 00:32:16,000
the same for you

00:32:12,820 --> 00:32:18,040
and they actually look the same that the

00:32:16,000 --> 00:32:23,440
whole point of this talk to show you

00:32:18,040 --> 00:32:27,130
that async does not mean callback good

00:32:23,440 --> 00:32:30,400
so now again let's have a real example I

00:32:27,130 --> 00:32:33,820
usually teepee server every HTTP is a

00:32:30,400 --> 00:32:36,640
synchronous HTTP framework or library

00:32:33,820 --> 00:32:38,650
available for a single and its outer

00:32:36,640 --> 00:32:40,450
Andre is actually at this conference so

00:32:38,650 --> 00:32:42,820
I really recommend you to go to his talk

00:32:40,450 --> 00:32:44,620
of his training to go in details on this

00:32:42,820 --> 00:32:48,520
I will be just shown you a minimal

00:32:44,620 --> 00:32:53,200
example and so a web app that returns

00:32:48,520 --> 00:32:55,030
hello Remini is as short as that you do

00:32:53,200 --> 00:32:59,020
again the async dev so define your core

00:32:55,030 --> 00:33:02,520
routine then you return web responds

00:32:59,020 --> 00:33:05,770
hello Remini no using now awaiting and

00:33:02,520 --> 00:33:07,960
then you run it you create web

00:33:05,770 --> 00:33:10,330
application you define your first end on

00:33:07,960 --> 00:33:12,760
the routes you say that whenever it goes

00:33:10,330 --> 00:33:14,620
to this route you can accuse the core

00:33:12,760 --> 00:33:16,420
routine hello and then you run it so

00:33:14,620 --> 00:33:18,100
this is the simplest example you're not

00:33:16,420 --> 00:33:20,350
waiting for the database here of course

00:33:18,100 --> 00:33:21,850
that's why it looks so easy but that the

00:33:20,350 --> 00:33:25,420
minimal thing you need to run the IE

00:33:21,850 --> 00:33:27,670
HTTP server of course we want to get

00:33:25,420 --> 00:33:30,220
more tricky we want to have a think in

00:33:27,670 --> 00:33:35,080
the way to be more realistic this is a

00:33:30,220 --> 00:33:39,160
very same example but now you are going

00:33:35,080 --> 00:33:41,470
to some URL so this URL is HTTP bin it's

00:33:39,160 --> 00:33:43,660
a nice tool that gives you a like a fake

00:33:41,470 --> 00:33:46,630
delay it's very cool to test your

00:33:43,660 --> 00:33:50,050
software so this will give us the live

00:33:46,630 --> 00:33:51,750
one seconds just if we will eventually

00:33:50,050 --> 00:33:53,830
run this code at the end you will see

00:33:51,750 --> 00:33:59,080
what we are doing here we are defining

00:33:53,830 --> 00:34:02,410
again a handler we are requesting which

00:33:59,080 --> 00:34:04,690
gets method this URL on top and then the

00:34:02,410 --> 00:34:07,390
result will be a future or curtain you

00:34:04,690 --> 00:34:09,190
are awaiting for it meaning giving it

00:34:07,390 --> 00:34:11,050
back to the I loop

00:34:09,190 --> 00:34:13,120
whenever the result is ready we are

00:34:11,050 --> 00:34:15,340
saving it to response and now the

00:34:13,120 --> 00:34:18,330
surprised why we are waiting for it the

00:34:15,340 --> 00:34:20,790
second time who knows

00:34:18,330 --> 00:34:22,860
yes okay so actually there are two

00:34:20,790 --> 00:34:25,560
blocking operations in this simple

00:34:22,860 --> 00:34:28,140
example of fetching a URL first blocking

00:34:25,560 --> 00:34:29,820
operation is when you fetch the first

00:34:28,140 --> 00:34:31,890
bytes like when you want to get the

00:34:29,820 --> 00:34:33,840
first byte of response this is the first

00:34:31,890 --> 00:34:36,150
operation when it when you need to wait

00:34:33,840 --> 00:34:39,390
for something but then there is a second

00:34:36,150 --> 00:34:41,760
one if the response is not going all at

00:34:39,390 --> 00:34:43,320
once if it's a streaming response this

00:34:41,760 --> 00:34:45,870
is why you need to wait for the second

00:34:43,320 --> 00:34:48,300
time so let's say that first byte comes

00:34:45,870 --> 00:34:50,790
in one second but the last byte comes in

00:34:48,300 --> 00:34:52,170
one minute so you would be blocking the

00:34:50,790 --> 00:34:54,900
difference right so that's why you do it

00:34:52,170 --> 00:34:58,110
twice in this example and then you print

00:34:54,900 --> 00:35:00,900
the result again so this looks not of

00:34:58,110 --> 00:35:03,120
course not exactly the same as Jango but

00:35:00,900 --> 00:35:10,920
I would say it's still decent and easy

00:35:03,120 --> 00:35:13,800
and you're not using callbacks then what

00:35:10,920 --> 00:35:16,260
if we need to request multiple URLs and

00:35:13,800 --> 00:35:18,060
parallel I will jump over this really

00:35:16,260 --> 00:35:21,180
quickly because as I said you have a

00:35:18,060 --> 00:35:23,550
dedicated talk for I think IO and I HTTP

00:35:21,180 --> 00:35:25,260
on this conference so I will just say

00:35:23,550 --> 00:35:27,720
that if you want to request multiple

00:35:25,260 --> 00:35:29,220
URLs and do this in parallel it's also

00:35:27,720 --> 00:35:33,780
very easy you just need to define

00:35:29,220 --> 00:35:37,880
multiple tasks make a chap to pull up

00:35:33,780 --> 00:35:37,880
those and deal the people that will work

00:35:39,380 --> 00:35:44,130
this is the second way that you can do

00:35:41,790 --> 00:35:49,590
the same thing if you are requesting

00:35:44,130 --> 00:35:52,080
multiple URLs you can use I think earth

00:35:49,590 --> 00:35:55,200
at weight a function that would let you

00:35:52,080 --> 00:35:57,210
pack multiple futures in one I'm not

00:35:55,200 --> 00:35:59,100
stopping over this on purpose because I

00:35:57,210 --> 00:36:02,760
want to show you tornado as well and our

00:35:59,100 --> 00:36:05,610
tornado a big difference between tornado

00:36:02,760 --> 00:36:08,280
and async a job tornado was there since

00:36:05,610 --> 00:36:11,610
2.5 so even when you didn't have the

00:36:08,280 --> 00:36:14,640
fancy syntax of async await and async

00:36:11,610 --> 00:36:16,380
death you already could use tornado and

00:36:14,640 --> 00:36:19,620
write the synchronous code with it in

00:36:16,380 --> 00:36:22,710
Python using the generators and I will

00:36:19,620 --> 00:36:25,050
show you how right now so tornado runs

00:36:22,710 --> 00:36:27,600
on the same idea of i/o loop futures and

00:36:25,050 --> 00:36:29,580
coroutines it just uses heck sesh way of

00:36:27,600 --> 00:36:32,260
achieving the same thing because again

00:36:29,580 --> 00:36:34,270
in 2.5 there was no native way

00:36:32,260 --> 00:36:36,580
having this functionality in Python so

00:36:34,270 --> 00:36:38,440
it has different mechanics but it is

00:36:36,580 --> 00:36:40,810
using the similar syntax and the main

00:36:38,440 --> 00:36:44,020
thing it is well tested it is stable

00:36:40,810 --> 00:36:46,240
it's used really a lot I can tell you so

00:36:44,020 --> 00:36:48,490
it's totally production-ready if you

00:36:46,240 --> 00:36:50,830
have some web application that needs to

00:36:48,490 --> 00:36:54,130
deal with WebSockets think about tornado

00:36:50,830 --> 00:36:55,990
it's really good option for this how

00:36:54,130 --> 00:36:59,170
does it play together with the sinker

00:36:55,990 --> 00:37:02,230
well this is the idea of the stack the

00:36:59,170 --> 00:37:04,750
tooth work on top we have application

00:37:02,230 --> 00:37:06,970
level like tornado twisted or whatever

00:37:04,750 --> 00:37:09,310
then we have the i/o framework async IO

00:37:06,970 --> 00:37:11,290
and then on the operating system level

00:37:09,310 --> 00:37:13,270
as I said we have the queues that are

00:37:11,290 --> 00:37:15,100
most efficient for the operating system

00:37:13,270 --> 00:37:17,470
like a queue or a pole or select on

00:37:15,100 --> 00:37:17,710
Windows it doesn't work like that right

00:37:17,470 --> 00:37:20,170
now

00:37:17,710 --> 00:37:22,960
so tornado and twisted they both come

00:37:20,170 --> 00:37:24,820
with their own event groups but this is

00:37:22,960 --> 00:37:27,940
the idea that maybe at some point it

00:37:24,820 --> 00:37:31,300
will work like this event loop of

00:37:27,940 --> 00:37:33,010
tornado very similar to async I own you

00:37:31,300 --> 00:37:36,340
don't have to remember the syntax I'm

00:37:33,010 --> 00:37:38,170
just showing you that it's as easy as I

00:37:36,340 --> 00:37:39,940
looked at current it's a single tone you

00:37:38,170 --> 00:37:42,580
get the aisle open you do a loop that

00:37:39,940 --> 00:37:44,920
starts to start it there is no big magic

00:37:42,580 --> 00:37:46,570
behind it and then if you want to run

00:37:44,920 --> 00:37:49,570
the I think i/o event loop it's also

00:37:46,570 --> 00:37:52,000
possible there are adapters available in

00:37:49,570 --> 00:37:53,950
tornado to use futures as well as I a

00:37:52,000 --> 00:37:56,590
loop from I think i/o and this is how

00:37:53,950 --> 00:38:00,450
you do it you just import I think i/o

00:37:56,590 --> 00:38:03,790
main loop and be started so it works too

00:38:00,450 --> 00:38:06,609
then futures again are compatible so

00:38:03,790 --> 00:38:08,770
tornado prefers own futures but you can

00:38:06,609 --> 00:38:10,570
use futures from tornado from a thinker

00:38:08,770 --> 00:38:12,880
as well and this is really handy because

00:38:10,570 --> 00:38:14,680
some libraries will give you futures of

00:38:12,880 --> 00:38:16,090
a thing karyotype let's say and you

00:38:14,680 --> 00:38:17,859
would say hey why did I do this whole

00:38:16,090 --> 00:38:20,140
application in tornado and now it's

00:38:17,859 --> 00:38:22,090
incompatible so it is compatible that's

00:38:20,140 --> 00:38:24,100
really good thing you can convert

00:38:22,090 --> 00:38:29,020
between tornado and they think at your

00:38:24,100 --> 00:38:32,770
back and forth easily finally minimal

00:38:29,020 --> 00:38:35,170
tornado web app it's very similar to the

00:38:32,770 --> 00:38:39,280
a single example we have a handle handle

00:38:35,170 --> 00:38:41,590
class you have a get function that

00:38:39,280 --> 00:38:44,400
handles it and you do sell that right to

00:38:41,590 --> 00:38:46,290
return the response to the color

00:38:44,400 --> 00:38:50,040
and in the same way you define the

00:38:46,290 --> 00:38:54,270
routing you say listen on this port you

00:38:50,040 --> 00:38:56,520
start the loop that's it now let's have

00:38:54,270 --> 00:38:59,310
an example of fetching the URL and

00:38:56,520 --> 00:39:02,460
tornado it's quite similar to a sink ion

00:38:59,310 --> 00:39:05,460
tornado has only think httpclient here

00:39:02,460 --> 00:39:08,370
it is that is doing the fetching for you

00:39:05,460 --> 00:39:12,270
so first you create an instance of the a

00:39:08,370 --> 00:39:16,080
sinking significance here then you do

00:39:12,270 --> 00:39:19,170
fetch URL this returns you a future that

00:39:16,080 --> 00:39:20,820
you use to the color tornado supports

00:39:19,170 --> 00:39:22,230
the await syntax as well I'm just

00:39:20,820 --> 00:39:24,150
showing you here that you can use it

00:39:22,230 --> 00:39:26,040
with Python too as well which is of

00:39:24,150 --> 00:39:26,870
course a bad thing that you can still do

00:39:26,040 --> 00:39:29,760
it

00:39:26,870 --> 00:39:32,220
so you yield the future to the i/o loop

00:39:29,760 --> 00:39:33,840
it does the processing and whenever the

00:39:32,220 --> 00:39:36,720
result is ready it saves it to the

00:39:33,840 --> 00:39:40,940
response variable and then you can print

00:39:36,720 --> 00:39:40,940
it to the caller print it to the client

00:39:42,680 --> 00:39:53,150
good then to to fetch multiple URLs you

00:39:49,140 --> 00:40:04,860
can do it like this I need my mouse here

00:39:53,150 --> 00:40:07,200
so I did it on purpose here yes so if

00:40:04,860 --> 00:40:09,390
you I did it on purpose here I didn't

00:40:07,200 --> 00:40:11,700
input multiple URLs to show you how easy

00:40:09,390 --> 00:40:14,700
is to fetch multiple URLs instead of one

00:40:11,700 --> 00:40:18,560
URL so if you have multiple URLs all you

00:40:14,700 --> 00:40:18,560
need to do is you wrap this as a list

00:40:19,700 --> 00:40:26,990
assuming that URLs is now a list and not

00:40:24,150 --> 00:40:26,990
a single URL

00:40:32,749 --> 00:40:37,919
so this is everything you need to change

00:40:35,399 --> 00:40:40,559
to fetch multiple URLs instead of one

00:40:37,919 --> 00:40:42,929
URL tornado is smart enough to notice

00:40:40,559 --> 00:40:44,869
that when you use not one future but the

00:40:42,929 --> 00:40:48,029
list of futures or dictionary of futures

00:40:44,869 --> 00:40:52,609
it will automatically process all of

00:40:48,029 --> 00:40:52,609
them in parallel so it's super handy yes

00:40:53,029 --> 00:41:00,380
yes yes you can

00:40:56,059 --> 00:41:00,380
good now I'm running out of time

00:41:02,209 --> 00:41:07,890
so just a little wrap-up there is

00:41:05,459 --> 00:41:10,259
twisted that is super well tested there

00:41:07,890 --> 00:41:12,989
are implementations of all of the

00:41:10,259 --> 00:41:14,819
protocols that you can imagine its

00:41:12,989 --> 00:41:16,739
production ready and it's time for one

00:41:14,819 --> 00:41:18,569
so use that if you want to do something

00:41:16,739 --> 00:41:20,939
really complicated like a difficult

00:41:18,569 --> 00:41:23,159
network protocol there is a sink area

00:41:20,939 --> 00:41:25,439
which is the future so if you want to

00:41:23,159 --> 00:41:28,019
make something in the perspective of

00:41:25,439 --> 00:41:30,089
future support take that and this is

00:41:28,019 --> 00:41:32,279
using the most fancy syntax available in

00:41:30,089 --> 00:41:34,019
Python and then there is a tornado is

00:41:32,279 --> 00:41:37,109
kind of a compromise it stays in between

00:41:34,019 --> 00:41:39,449
I personally use tornado just for

00:41:37,109 --> 00:41:42,359
historical reasons but I'm now switching

00:41:39,449 --> 00:41:43,649
slowly to a sink area I think that's it

00:41:42,359 --> 00:41:45,359
you're great

00:41:43,649 --> 00:41:48,469
thanks for not flipping on this talk and

00:41:45,359 --> 00:41:48,469
now let's go to questions

00:41:52,370 --> 00:42:03,030
first one OK click questions because we

00:41:58,650 --> 00:42:05,130
only yeah my question is I see most of

00:42:03,030 --> 00:42:07,740
the parts when you apply synchronous

00:42:05,130 --> 00:42:10,920
calls are I oh yes what are the benefits

00:42:07,740 --> 00:42:14,100
of a synchronous processing when when

00:42:10,920 --> 00:42:16,320
most of your things are CPU bound or it

00:42:14,100 --> 00:42:19,830
yeah what would be the benefit in that

00:42:16,320 --> 00:42:21,660
case a great question so yes it is in

00:42:19,830 --> 00:42:21,930
the first place designs to be used this

00:42:21,660 --> 00:42:26,730
way

00:42:21,930 --> 00:42:30,270
so first advantages you can take is if

00:42:26,730 --> 00:42:34,140
the is the i/o that's why it's async i/o

00:42:30,270 --> 00:42:36,990
I would say that 90% of cases of waiting

00:42:34,140 --> 00:42:38,880
in the web application is i/o I cannot

00:42:36,990 --> 00:42:40,470
even think of another occasion well

00:42:38,880 --> 00:42:42,870
maybe you have some difficult I know

00:42:40,470 --> 00:42:44,460
face recognition system running and it

00:42:42,870 --> 00:42:46,860
takes time you will you will not have

00:42:44,460 --> 00:42:50,550
any benefit one thing that you have

00:42:46,860 --> 00:42:52,950
though is how else would you do it you

00:42:50,550 --> 00:42:55,080
would start a thread normally that's the

00:42:52,950 --> 00:42:56,940
typical way so you can also do it with

00:42:55,080 --> 00:42:59,880
the sink here there is a thread pool

00:42:56,940 --> 00:43:03,930
executor and thread and process pool

00:42:59,880 --> 00:43:05,580
executor classes in I think a library so

00:43:03,930 --> 00:43:06,960
then the advantage for you would be that

00:43:05,580 --> 00:43:09,660
you would not need to write two

00:43:06,960 --> 00:43:11,550
different code bases you would not need

00:43:09,660 --> 00:43:15,120
to use two different approaches you

00:43:11,550 --> 00:43:17,790
could use perks of a CIO to wait for the

00:43:15,120 --> 00:43:19,770
i/o events and for your fancy image

00:43:17,790 --> 00:43:26,010
recognition software you could start

00:43:19,770 --> 00:43:28,560
thread but still use smk of syntax so it

00:43:26,010 --> 00:43:30,750
would make testing probably easier a bit

00:43:28,560 --> 00:43:32,880
and it would just make your code look

00:43:30,750 --> 00:43:35,610
the same way so the structure is better

00:43:32,880 --> 00:43:37,290
if you have only like let's say some

00:43:35,610 --> 00:43:39,240
difficult machine learning computation

00:43:37,290 --> 00:43:43,550
there is no advantage as I see it I

00:43:39,240 --> 00:43:46,500
could be wrong one more question

00:43:43,550 --> 00:43:49,230
anyone know okay

00:43:46,500 --> 00:43:52,770
is it good or is it bad it's good okay

00:43:49,230 --> 00:43:55,280
you you covered it really well one yes

00:43:52,770 --> 00:43:55,280
great

00:43:55,609 --> 00:44:09,529
yes yeah but I can't so I know that this

00:44:06,709 --> 00:44:11,779
is probably very similar to each other

00:44:09,529 --> 00:44:14,239
I mean dos Ramos I'm wondering whether

00:44:11,779 --> 00:44:16,219
you compared like a performance of them

00:44:14,239 --> 00:44:19,430
or maybe there is something that

00:44:16,219 --> 00:44:22,999
actually you know is one of them less

00:44:19,430 --> 00:44:25,190
performant great great question so yes I

00:44:22,999 --> 00:44:27,289
did compare the performance of course

00:44:25,190 --> 00:44:30,079
performance is such term that there are

00:44:27,289 --> 00:44:31,700
like very numerous ways to measure the

00:44:30,079 --> 00:44:34,249
performance and you could measure the

00:44:31,700 --> 00:44:36,109
memory you can measure the speed many

00:44:34,249 --> 00:44:36,920
things so what I did measure is requests

00:44:36,109 --> 00:44:40,219
per second

00:44:36,920 --> 00:44:43,130
I measured tornado I think a you know GS

00:44:40,219 --> 00:44:46,309
and Scala cynical like for libraries

00:44:43,130 --> 00:44:50,089
that do the same sorry guys Khalid is

00:44:46,309 --> 00:44:55,489
the best but at least we are better than

00:44:50,089 --> 00:44:59,900
not yes that's also good actually yeah I

00:44:55,489 --> 00:45:01,880
think we need to head on out yes so good

00:44:59,900 --> 00:45:04,790
thank you all for coming

00:45:01,880 --> 00:45:08,389
yes thank you very much you was great

00:45:04,790 --> 00:45:08,389

YouTube URL: https://www.youtube.com/watch?v=ZXrdqq7nc1I


