Title: Adam Dangoor - But how do you know your mock is valid? Verified fakes of web services
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"But how do you know your mock is valid? Verified fakes of web services
[EuroPython 2017 - Talk - 2017-07-10 - Arengo]
[Rimini, Italy]

If your code calls a third party service then you may want to test that your code works but you don't want to call the service in your tests.

It may be expensive, slow or impossible to call that service. For example, if you are making a Slack bot, you want to create tests which don't make calls across the network to Slack.

One approach is to create a mock of that service. Our tests can now run quickly, cheaply and reliably. But if we copy the service incorrectly, or if the service changes, our tests will pass while our code does not work.

Verified fakes solve this problem. You can write tests which confirm that your mock is an accurate representation of the service being mocked. Those tests can be a small subset of your test suite and they can be run periodically, to verify the validity of the many tests which use the mock.

This talk will follow the example of VWS-Python, a verified fake for a proprietary web service. It will discuss the practicalities of creating such a fake and it will focus on the trade-offs, tooling and approaches involved.

By the end of this talk the audience will understand how to tie together pytest, Travis CI, requests and Responses to create a verified fake.

The talk is aimed at people who have an interest in writing correct software. It is assumed that the audience is familiar with basic testing techniques.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:03,639 --> 00:00:09,309
thank you and thank you everyone for

00:00:05,470 --> 00:00:10,799
coming so my name is Adam Gangrel I work

00:00:09,309 --> 00:00:13,179
at a company called meter sphere

00:00:10,799 --> 00:00:15,879
building an operating system for data

00:00:13,179 --> 00:00:16,930
centers but last year I was working on

00:00:15,879 --> 00:00:19,660
something quite different

00:00:16,930 --> 00:00:22,900
I was working on the back end of an

00:00:19,660 --> 00:00:26,410
iPhone app now what you do is as a user

00:00:22,900 --> 00:00:28,810
you would take a photo of a wine label

00:00:26,410 --> 00:00:30,790
with your phone and yet would tell you

00:00:28,810 --> 00:00:33,100
all kinds of details about that wine or

00:00:30,790 --> 00:00:35,860
at least it was something like that I'm

00:00:33,100 --> 00:00:39,460
going to protect my NDA here today and

00:00:35,860 --> 00:00:41,440
our app was a flask app now if you don't

00:00:39,460 --> 00:00:43,840
know flask it's a really simple web

00:00:41,440 --> 00:00:47,500
framework and it looks something like

00:00:43,840 --> 00:00:52,079
this now a really cool thing about flask

00:00:47,500 --> 00:00:55,300
is that it provides give second a Velcro

00:00:52,079 --> 00:00:57,550
test client if I got that right

00:00:55,300 --> 00:00:59,440
and what that means is that you can make

00:00:57,550 --> 00:01:01,989
requests against an in-memory

00:00:59,440 --> 00:01:05,019
application and you can get response

00:01:01,989 --> 00:01:07,960
objects which you can inspect so if we

00:01:05,019 --> 00:01:11,920
look at this test here it kind of looks

00:01:07,960 --> 00:01:13,540
like we've made an HTTP request but

00:01:11,920 --> 00:01:17,130
actually everything's being done in

00:01:13,540 --> 00:01:19,840
memory in our tests now in our wine

00:01:17,130 --> 00:01:22,229
recognition app we use something as well

00:01:19,840 --> 00:01:24,760
called the forea web services and

00:01:22,229 --> 00:01:27,280
basically what before a Web Services is

00:01:24,760 --> 00:01:29,080
is it's a tool that lets you upload a

00:01:27,280 --> 00:01:32,920
whole bunch of images let's say in our

00:01:29,080 --> 00:01:36,159
case images of wine labels and then when

00:01:32,920 --> 00:01:37,960
a user uploaded a photo to us well we

00:01:36,159 --> 00:01:40,270
could send that image to the foria and

00:01:37,960 --> 00:01:43,000
then before iya would tell us which one

00:01:40,270 --> 00:01:46,659
of our previously uploaded images their

00:01:43,000 --> 00:01:48,850
photo most closely matched and then what

00:01:46,659 --> 00:01:51,009
we could do is we could fetch details

00:01:48,850 --> 00:01:53,560
about that wine from our database and

00:01:51,009 --> 00:01:56,439
tell the users details about the wine

00:01:53,560 --> 00:01:58,990
like how much it should cost how well

00:01:56,439 --> 00:02:00,479
rated it was from exactly where it's

00:01:58,990 --> 00:02:03,700
from that kind of thing

00:02:00,479 --> 00:02:05,229
but when we built our prototype well we

00:02:03,700 --> 00:02:05,619
kept finding loads of problems loads of

00:02:05,229 --> 00:02:08,829
bugs

00:02:05,619 --> 00:02:10,539
and in particular those bugs came from

00:02:08,829 --> 00:02:12,489
assumptions that we'd made about the

00:02:10,539 --> 00:02:14,050
foria which weren't quite right often

00:02:12,489 --> 00:02:15,790
that came from reading their

00:02:14,050 --> 00:02:19,180
documentation and

00:02:15,790 --> 00:02:21,549
trusting that it was truthful and full

00:02:19,180 --> 00:02:24,189
and gem where you can't always make

00:02:21,549 --> 00:02:26,500
those assumptions and so what we wanted

00:02:24,189 --> 00:02:29,049
to do we wanted to add text for our

00:02:26,500 --> 00:02:30,819
matching workflow and that matching

00:02:29,049 --> 00:02:32,500
workflow of course used before eeeh and

00:02:30,819 --> 00:02:36,760
we wanted those tests to be in our

00:02:32,500 --> 00:02:40,390
existing test suite now before in here

00:02:36,760 --> 00:02:42,489
was accessed over HTTP and that's what

00:02:40,390 --> 00:02:44,049
I'm going to focus on today but the

00:02:42,489 --> 00:02:46,480
general idea is really aren't specific

00:02:44,049 --> 00:02:50,349
to HTTP because you might want to test

00:02:46,480 --> 00:02:53,530
code let's say that uses a database for

00:02:50,349 --> 00:02:56,260
local storage or you might want to test

00:02:53,530 --> 00:02:58,569
a deployment workflow which uses docker

00:02:56,260 --> 00:03:01,540
or or maybe you even want to test code

00:02:58,569 --> 00:03:04,720
which uses an Amazon s3 or some other

00:03:01,540 --> 00:03:07,060
cloud storage as a storage back-end now

00:03:04,720 --> 00:03:09,639
we were lucky we had a very clear idea

00:03:07,060 --> 00:03:11,530
of what we wanted our first has to be I

00:03:09,639 --> 00:03:15,340
know this is quite a lot of code to have

00:03:11,530 --> 00:03:18,099
on a slide but simply what we wanted to

00:03:15,340 --> 00:03:20,379
test was that if a user uploaded a photo

00:03:18,099 --> 00:03:23,019
of a wine label which matched a photo

00:03:20,379 --> 00:03:25,690
that weird already added well then they

00:03:23,019 --> 00:03:27,099
would get details about that wine so I

00:03:25,690 --> 00:03:31,329
wrote a test that looked a little bit

00:03:27,099 --> 00:03:33,220
like this I had two wines here add wine

00:03:31,329 --> 00:03:35,669
let's say it adds it to our database but

00:03:33,220 --> 00:03:38,440
it also uploads it to the Floria and

00:03:35,669 --> 00:03:40,090
then I checked that I get the right one

00:03:38,440 --> 00:03:42,280
back when I query the match function

00:03:40,090 --> 00:03:46,349
that much function uses for foria on the

00:03:42,280 --> 00:03:48,220
back end now with some third-party tools

00:03:46,349 --> 00:03:50,260
maybe even some of the ones I mentioned

00:03:48,220 --> 00:03:53,409
like doctor you might be totally fine

00:03:50,260 --> 00:03:57,099
totally cool to call that real tool in

00:03:53,409 --> 00:03:59,139
your test suite but when we call before

00:03:57,099 --> 00:04:02,590
in our tests we actually hit some

00:03:59,139 --> 00:04:04,989
problems now first of all we were at the

00:04:02,590 --> 00:04:08,680
mercy of the network and what that meant

00:04:04,989 --> 00:04:11,079
is when our theory system had a little

00:04:08,680 --> 00:04:13,900
network glitch well then our whole test

00:04:11,079 --> 00:04:16,389
to it would fail because I text made

00:04:13,900 --> 00:04:19,269
HTTP requests against the Internet and

00:04:16,389 --> 00:04:21,159
we didn't know if those failures were

00:04:19,269 --> 00:04:22,930
because of the network failure or

00:04:21,159 --> 00:04:26,349
because there was some kind of flakiness

00:04:22,930 --> 00:04:28,889
in our code but also we were at the

00:04:26,349 --> 00:04:30,930
mercy of a forea so similarly when

00:04:28,889 --> 00:04:33,599
the foria went down or went down

00:04:30,930 --> 00:04:35,729
temporarily as testsuite would fail and

00:04:33,599 --> 00:04:38,550
it really does slow down development if

00:04:35,729 --> 00:04:42,960
you're constantly worrying have you made

00:04:38,550 --> 00:04:44,849
a mistake or is it on their end now say

00:04:42,960 --> 00:04:47,580
you're using a real service like s/3 s/3

00:04:44,849 --> 00:04:49,379
might be pretty stable probably even

00:04:47,580 --> 00:04:50,699
more stable than your software so you

00:04:49,379 --> 00:04:51,449
might not have to worry too much about

00:04:50,699 --> 00:04:55,020
flakiness

00:04:51,449 --> 00:04:57,180
but s3 charges you per megabyte use so

00:04:55,020 --> 00:04:58,379
if you want to use it in your test suite

00:04:57,180 --> 00:05:01,199
it might actually become really

00:04:58,379 --> 00:05:05,250
expensive to run your tests you might

00:05:01,199 --> 00:05:07,740
have to pay per megabyte and rip just

00:05:05,250 --> 00:05:09,210
spend quite a lot of money and another

00:05:07,740 --> 00:05:10,949
problem that you might run into is

00:05:09,210 --> 00:05:12,689
resorts limits this is definitely

00:05:10,949 --> 00:05:15,240
something that I've hid a lot of

00:05:12,689 --> 00:05:17,129
services have resource limits than a

00:05:15,240 --> 00:05:19,620
certain number of requests that your

00:05:17,129 --> 00:05:21,750
account can make and so if you call

00:05:19,620 --> 00:05:23,069
something in your test suite very

00:05:21,750 --> 00:05:25,439
heavily especially if you let's say

00:05:23,069 --> 00:05:27,719
you're doing performance benchmarking

00:05:25,439 --> 00:05:29,279
you're making a load of calls well then

00:05:27,719 --> 00:05:30,870
you might hit those resource limits and

00:05:29,279 --> 00:05:31,770
you can't run your tests anymore and

00:05:30,870 --> 00:05:34,860
you're pretty much blocked on

00:05:31,770 --> 00:05:37,529
development and even when those things

00:05:34,860 --> 00:05:40,469
weren't problems and everything was

00:05:37,529 --> 00:05:42,029
really slow so before it's quite

00:05:40,469 --> 00:05:44,550
advanced software does a lot of

00:05:42,029 --> 00:05:47,699
processing magic so that it can do the

00:05:44,550 --> 00:05:50,430
image matching and that means that after

00:05:47,699 --> 00:05:53,009
you've uploaded an image well it takes a

00:05:50,430 --> 00:05:54,479
few minutes until that image can be

00:05:53,009 --> 00:05:56,430
matched that's totally reasonable I

00:05:54,479 --> 00:05:59,039
don't think I could really expect them

00:05:56,430 --> 00:06:00,539
to do it instantly but in our test suite

00:05:59,039 --> 00:06:03,419
well I didn't really want to have to

00:06:00,539 --> 00:06:07,229
wait a few minutes to know if our get

00:06:03,419 --> 00:06:08,759
match code worked so we caught these

00:06:07,229 --> 00:06:11,310
tests like the one that I showed you

00:06:08,759 --> 00:06:13,349
before integration tests because well

00:06:11,310 --> 00:06:15,750
they tested the integration of our

00:06:13,349 --> 00:06:17,159
software with v4 is I think a lot of

00:06:15,750 --> 00:06:18,750
people get confused about the

00:06:17,159 --> 00:06:20,699
terminology some people call these

00:06:18,750 --> 00:06:22,710
things acceptance tests or end-to-end

00:06:20,699 --> 00:06:26,279
tests but I think we can agree that

00:06:22,710 --> 00:06:28,259
they're high level tests and they were

00:06:26,279 --> 00:06:31,289
definitely useful and they really did

00:06:28,259 --> 00:06:33,629
help us track down some bugs but we also

00:06:31,289 --> 00:06:35,159
wanted unit tests because unit tests

00:06:33,629 --> 00:06:38,250
give us a lot of benefits over

00:06:35,159 --> 00:06:41,399
integration tests and in particular they

00:06:38,250 --> 00:06:42,180
tell us if our code calls before you

00:06:41,399 --> 00:06:45,900
directly in the

00:06:42,180 --> 00:06:48,000
case even when the fora is down and unit

00:06:45,900 --> 00:06:51,600
tests are also really small in scope and

00:06:48,000 --> 00:06:54,120
what that means is well let's see one

00:06:51,600 --> 00:06:56,660
fail not all the time but often you know

00:06:54,120 --> 00:07:00,210
exactly which part of your code failed

00:06:56,660 --> 00:07:02,400
and if you change that bit of your code

00:07:00,210 --> 00:07:05,120
to make the unit test pass well there

00:07:02,400 --> 00:07:07,560
could be a small isolated change and

00:07:05,120 --> 00:07:09,300
when you've got unit tests that run

00:07:07,560 --> 00:07:12,360
quickly and are small well you can even

00:07:09,300 --> 00:07:16,979
use some tools may be like hypothesis to

00:07:12,360 --> 00:07:18,479
generate a whole bunch of unit tests so

00:07:16,979 --> 00:07:21,150
what we want to do we want to turn a

00:07:18,479 --> 00:07:24,210
code base which can currently be tested

00:07:21,150 --> 00:07:27,860
only by integration tests into one which

00:07:24,210 --> 00:07:31,050
can also be tested with unit tests and

00:07:27,860 --> 00:07:35,669
one way that some people achieve this is

00:07:31,050 --> 00:07:37,979
by using mocks now roughly a mock is

00:07:35,669 --> 00:07:40,440
some code which provides the same

00:07:37,979 --> 00:07:43,830
interface as something that your code

00:07:40,440 --> 00:07:47,430
calls but it reduces or it remove some

00:07:43,830 --> 00:07:48,930
cost and in this case the main costs

00:07:47,430 --> 00:07:51,270
that we care about like I mentioned were

00:07:48,930 --> 00:07:53,550
time we care about those slow tests and

00:07:51,270 --> 00:07:56,010
flakiness but again you might want to

00:07:53,550 --> 00:07:57,510
avoid financial costs resource limits or

00:07:56,010 --> 00:08:01,949
all kinds of other costs that can come

00:07:57,510 --> 00:08:04,349
into your test suite so monocle was that

00:08:01,949 --> 00:08:06,599
wherever code under test made a request

00:08:04,349 --> 00:08:09,030
of a forea at least in our unit test

00:08:06,599 --> 00:08:11,340
suite the tests would make sure that

00:08:09,030 --> 00:08:13,680
that request that HTTP request was

00:08:11,340 --> 00:08:16,919
actually handled by a mock function

00:08:13,680 --> 00:08:19,199
rather than going over the web now we're

00:08:16,919 --> 00:08:20,849
very fortunate we were using the request

00:08:19,199 --> 00:08:23,639
library that I'm sure some of you at

00:08:20,849 --> 00:08:26,490
least are familiar with and there are a

00:08:23,639 --> 00:08:28,620
few ways with Python to get requests

00:08:26,490 --> 00:08:32,099
which are made with the requests library

00:08:28,620 --> 00:08:33,659
to point us unlock code and the tool I

00:08:32,099 --> 00:08:35,669
chose is this one it's called

00:08:33,659 --> 00:08:37,890
requests mock I know there's also

00:08:35,669 --> 00:08:39,750
another one by the folks you make

00:08:37,890 --> 00:08:42,779
century called responses there's also

00:08:39,750 --> 00:08:45,270
something called HTTP GET if you're on

00:08:42,779 --> 00:08:48,930
Python 2 and maybe you're not using the

00:08:45,270 --> 00:08:52,770
requests library now the simple requests

00:08:48,930 --> 00:08:55,550
mock example is this one so what you can

00:08:52,770 --> 00:08:59,209
say is here when I make a get

00:08:55,550 --> 00:09:03,949
to test calm return the string that says

00:08:59,209 --> 00:09:07,160
data that's pretty simple and at the

00:09:03,949 --> 00:09:08,779
same time as using requests mark I'm

00:09:07,160 --> 00:09:12,050
sorry personally try to take a photo the

00:09:08,779 --> 00:09:13,670
slides will be online at home and at the

00:09:12,050 --> 00:09:17,750
same time is using requests mark we were

00:09:13,670 --> 00:09:20,629
also using PI tests now what practice is

00:09:17,750 --> 00:09:23,540
is it's a test runner which gives you a

00:09:20,629 --> 00:09:28,519
really neat way to do setup and teardown

00:09:23,540 --> 00:09:30,319
for test requirements now that feature

00:09:28,519 --> 00:09:31,040
is called fixtures and we have a fixture

00:09:30,319 --> 00:09:34,009
right here

00:09:31,040 --> 00:09:37,910
and what this one says is hey if I use

00:09:34,009 --> 00:09:40,399
this fixture then requests in this test

00:09:37,910 --> 00:09:42,740
will be handled by mock code you can see

00:09:40,399 --> 00:09:46,040
we yield when we're in the context

00:09:42,740 --> 00:09:48,829
manager and but I'm sure that if you're

00:09:46,040 --> 00:09:50,329
using a more traditional test framework

00:09:48,829 --> 00:09:54,110
you can use just the normal kind of

00:09:50,329 --> 00:09:55,579
setup and teardown methods now what I

00:09:54,110 --> 00:09:57,230
wanted I didn't want just wanted to

00:09:55,579 --> 00:09:58,579
return the string data or something like

00:09:57,230 --> 00:10:01,930
that I wanted some quite advanced

00:09:58,579 --> 00:10:05,209
features in my mock and in particular I

00:10:01,930 --> 00:10:06,860
wanted to have a stateful mock and that

00:10:05,209 --> 00:10:09,050
would allow me to give different

00:10:06,860 --> 00:10:11,329
responses based on previous requests so

00:10:09,050 --> 00:10:13,880
I could give a different match response

00:10:11,329 --> 00:10:17,990
if someone had already uploaded to the

00:10:13,880 --> 00:10:20,930
mark a picture of a matching label so I

00:10:17,990 --> 00:10:23,029
use a request snot feature which let me

00:10:20,930 --> 00:10:26,079
use a callable instead of a predefined

00:10:23,029 --> 00:10:28,699
response and that collar ball takes a

00:10:26,079 --> 00:10:31,970
request like object it gives me a word

00:10:28,699 --> 00:10:34,339
details of the request so we created a

00:10:31,970 --> 00:10:36,980
whole bunch of small mock functions for

00:10:34,339 --> 00:10:39,019
every end point we used and at this

00:10:36,980 --> 00:10:41,240
point we'd pretty much achieved our goal

00:10:39,019 --> 00:10:45,920
right we could test our code without

00:10:41,240 --> 00:10:47,779
touching the reel before it but then we

00:10:45,920 --> 00:10:50,569
hit some more problems problems when we

00:10:47,779 --> 00:10:52,459
were using that knock and I actually

00:10:50,569 --> 00:10:56,059
think that these are problems that a lot

00:10:52,459 --> 00:10:58,370
of mocks face and sometimes we found

00:10:56,059 --> 00:10:59,540
that we'd copied the interface correctly

00:10:58,370 --> 00:11:03,079
you know it can be pretty hard there are

00:10:59,540 --> 00:11:04,519
lots of edge cases what if the image is

00:11:03,079 --> 00:11:06,350
too big that we give the right error

00:11:04,519 --> 00:11:08,810
back that kind of thing

00:11:06,350 --> 00:11:10,670
and humans make mistake even with code

00:11:08,810 --> 00:11:13,100
review and so we found that we've copied

00:11:10,670 --> 00:11:15,590
a lot of things incorrectly but then

00:11:13,100 --> 00:11:17,390
even when we were extra careful we found

00:11:15,590 --> 00:11:20,750
that the mock quickly became updated

00:11:17,390 --> 00:11:22,310
whenever the forea changed if they sent

00:11:20,750 --> 00:11:24,800
out a really nice change log we could

00:11:22,310 --> 00:11:26,270
change our mock to match it but that's

00:11:24,800 --> 00:11:30,020
not always the case especially for very

00:11:26,270 --> 00:11:32,420
minor minor things and this isn't you

00:11:30,020 --> 00:11:33,920
know a Python library where you can even

00:11:32,420 --> 00:11:36,650
inspect the code changes this is a web

00:11:33,920 --> 00:11:39,380
service now when you have an outdated

00:11:36,650 --> 00:11:41,870
mock you have quite a serious problem or

00:11:39,380 --> 00:11:43,910
at least what we'll serious for us which

00:11:41,870 --> 00:11:46,100
is our tests path

00:11:43,910 --> 00:11:48,950
but our software is actually failing in

00:11:46,100 --> 00:11:52,340
production and when you've got that you

00:11:48,950 --> 00:11:54,650
can have a real difficult time tracking

00:11:52,340 --> 00:11:57,350
down exactly why your code is broken

00:11:54,650 --> 00:11:58,730
because everything looks like it should

00:11:57,350 --> 00:12:00,620
be working and you have to find Oh

00:11:58,730 --> 00:12:03,890
actually my mock is wrong where is it

00:12:00,620 --> 00:12:06,680
wrong trying to basically remake those

00:12:03,890 --> 00:12:10,670
manual requests to check to your market

00:12:06,680 --> 00:12:14,240
it's very tedious so that was a contract

00:12:10,670 --> 00:12:17,030
gig and that contract ended and I kind

00:12:14,240 --> 00:12:18,830
of felt like I'd built an okay solution

00:12:17,030 --> 00:12:22,820
it was working alright for the client

00:12:18,830 --> 00:12:24,440
but I really felt like the well like the

00:12:22,820 --> 00:12:26,510
problem could be tackled in a better way

00:12:24,440 --> 00:12:29,660
and that I could have provided a better

00:12:26,510 --> 00:12:30,950
solution if I'd had more time and in

00:12:29,660 --> 00:12:34,970
particular because we kept hitting those

00:12:30,950 --> 00:12:38,450
issues of before you change and of human

00:12:34,970 --> 00:12:39,950
error and at the same time I really

00:12:38,450 --> 00:12:44,570
believe that before eeeh and I still goo

00:12:39,950 --> 00:12:46,160
could be a genuinely useful tool for a

00:12:44,570 --> 00:12:49,160
bunch of people and it could be

00:12:46,160 --> 00:12:52,730
especially useful if it was easy to

00:12:49,160 --> 00:12:55,250
develop against so I set out to make vws

00:12:52,730 --> 00:12:57,890
Python which is basically an open-source

00:12:55,250 --> 00:13:00,590
library for using the beforeö web

00:12:57,890 --> 00:13:04,490
services with python it's in progress

00:13:00,590 --> 00:13:07,340
hopefully coming very soon to pi PI but

00:13:04,490 --> 00:13:09,620
I also had another goal I started

00:13:07,340 --> 00:13:12,380
testing it with an open source mark part

00:13:09,620 --> 00:13:14,900
part of that library but I realised that

00:13:12,380 --> 00:13:17,420
the mosque itself is very useful whether

00:13:14,900 --> 00:13:18,830
or not you're using my library and I

00:13:17,420 --> 00:13:20,750
wanted to ship that machs

00:13:18,830 --> 00:13:23,330
people so that if they were writing code

00:13:20,750 --> 00:13:26,440
which used for forea well then they

00:13:23,330 --> 00:13:29,150
could have the mark for their own tests

00:13:26,440 --> 00:13:31,070
so I wrote some integration tests for

00:13:29,150 --> 00:13:33,590
the library and I wrote some unit tests

00:13:31,070 --> 00:13:35,680
for that library which use the mock and

00:13:33,590 --> 00:13:38,290
I put the test suite on Travis CI

00:13:35,680 --> 00:13:40,760
because well because I knew it and

00:13:38,290 --> 00:13:43,310
because it was free for open source

00:13:40,760 --> 00:13:44,840
projects and one really cool feature of

00:13:43,310 --> 00:13:47,030
Travis I'm sure a lot of other CI

00:13:44,840 --> 00:13:49,550
systems share it though is that I can

00:13:47,030 --> 00:13:50,720
get it the credentials report phoria and

00:13:49,550 --> 00:13:53,300
I don't have to have those credentials

00:13:50,720 --> 00:13:55,550
show up in the codebase where someone

00:13:53,300 --> 00:13:58,490
can abuse them but I also don't get have

00:13:55,550 --> 00:14:00,890
to have them show up in the logs so I

00:13:58,490 --> 00:14:03,620
could really use the real service even

00:14:00,890 --> 00:14:06,170
from a CI system and every time I made a

00:14:03,620 --> 00:14:08,750
change to the library the test will run

00:14:06,170 --> 00:14:11,210
and those integration tests run against

00:14:08,750 --> 00:14:13,430
the real before it but if you remember

00:14:11,210 --> 00:14:15,530
the goal I set I wanted people to be

00:14:13,430 --> 00:14:17,810
able to use my mark to test their code

00:14:15,530 --> 00:14:20,600
whether or not they were using my

00:14:17,810 --> 00:14:22,340
library and there's a cool way to let

00:14:20,600 --> 00:14:25,370
even people who use different of

00:14:22,340 --> 00:14:28,070
programming languages not just Python to

00:14:25,370 --> 00:14:29,300
use your mock while you're still keeping

00:14:28,070 --> 00:14:31,550
the interface really nice and pleasant

00:14:29,300 --> 00:14:33,730
if you remember we had a PI test fixture

00:14:31,550 --> 00:14:37,640
or if you're not using PI test just a

00:14:33,730 --> 00:14:39,200
context manager or a decorator so you

00:14:37,640 --> 00:14:40,460
want to keep that for Python users but

00:14:39,200 --> 00:14:44,240
you want to let other people use your

00:14:40,460 --> 00:14:49,220
code as well and the way that I did this

00:14:44,240 --> 00:14:51,230
is well I built the mock in a way that

00:14:49,220 --> 00:14:54,170
meant it could be run as a standalone

00:14:51,230 --> 00:14:56,120
server and what that meant is ditching

00:14:54,170 --> 00:15:00,560
the requests mock syntax that we had

00:14:56,120 --> 00:15:02,870
before but at the same time well no I'll

00:15:00,560 --> 00:15:04,310
move on so I wrote this little bit of

00:15:02,870 --> 00:15:07,640
code I'm not going to get into it too

00:15:04,310 --> 00:15:08,960
too deeply because maybe I'm a little

00:15:07,640 --> 00:15:11,390
bit embarrassed it's a bit of a hairy

00:15:08,960 --> 00:15:14,660
tack but really it let me rewrite the

00:15:11,390 --> 00:15:16,490
mark as a flask app and keep using it

00:15:14,660 --> 00:15:20,630
with requests mock so that means that

00:15:16,490 --> 00:15:23,390
I've got a flask app that I can just run

00:15:20,630 --> 00:15:25,310
as a standalone server but if I get if I

00:15:23,390 --> 00:15:27,410
use this code it tied it into requests

00:15:25,310 --> 00:15:29,420
mark so let's say what it does is it

00:15:27,410 --> 00:15:32,180
translates those request objects from

00:15:29,420 --> 00:15:35,210
requests mark into something that use

00:15:32,180 --> 00:15:38,120
that can be used by the I guess the

00:15:35,210 --> 00:15:40,010
vectra's logic test client again but

00:15:38,120 --> 00:15:41,930
then you also translate responses from

00:15:40,010 --> 00:15:43,730
access client into something that

00:15:41,930 --> 00:15:48,709
requests mocks an user or all those code

00:15:43,730 --> 00:15:50,750
will be online later so if you're not

00:15:48,709 --> 00:15:52,250
using Python then what you can do is you

00:15:50,750 --> 00:15:55,040
can spin up a flask app let's say in a

00:15:52,250 --> 00:15:56,899
docker container for every test and then

00:15:55,040 --> 00:15:58,580
you can route your request to that

00:15:56,899 --> 00:16:00,410
container using whatever kind of

00:15:58,580 --> 00:16:01,820
requests mock alternative your lot of

00:16:00,410 --> 00:16:03,680
language has and that can be

00:16:01,820 --> 00:16:05,779
particularly useful even especially even

00:16:03,680 --> 00:16:08,810
if you're on an old Python version that

00:16:05,779 --> 00:16:10,850
doesn't support my marks code so I'd say

00:16:08,810 --> 00:16:13,310
this if you're in an organization and

00:16:10,850 --> 00:16:15,140
you're writing a mock and you want that

00:16:13,310 --> 00:16:17,390
mock to be used across organization even

00:16:15,140 --> 00:16:20,000
if people use different languages this

00:16:17,390 --> 00:16:23,089
is a really cool way to do it so back to

00:16:20,000 --> 00:16:24,589
writing the mark this time around the

00:16:23,089 --> 00:16:27,080
mark was definitely part of my product

00:16:24,589 --> 00:16:29,089
so I didn't want to just do it in an ad

00:16:27,080 --> 00:16:32,240
hoc manner I wanted to test it

00:16:29,089 --> 00:16:33,709
thoroughly and I wanted to write those

00:16:32,240 --> 00:16:35,870
tests that confirmed it was doing what I

00:16:33,709 --> 00:16:38,600
wanted so if you think about it at this

00:16:35,870 --> 00:16:40,670
point I'm kind of probably duplicating a

00:16:38,600 --> 00:16:42,920
lot of the work that the people at for

00:16:40,670 --> 00:16:45,410
foria did write I'm rewriting a bit of

00:16:42,920 --> 00:16:47,839
this service and I'm also thinking about

00:16:45,410 --> 00:16:51,560
edge cases for it and I'm what I'm doing

00:16:47,839 --> 00:16:53,750
is is very manual I'm making requests to

00:16:51,560 --> 00:16:55,279
their servers with those kind of edge

00:16:53,750 --> 00:16:58,400
cases that I'm thinking about

00:16:55,279 --> 00:17:00,380
then I'm noting the responses down in

00:16:58,400 --> 00:17:04,189
tests and then I'm making sure that that

00:17:00,380 --> 00:17:06,410
test passes for my mark and my testings

00:17:04,189 --> 00:17:08,390
especially that aren't mentioned in the

00:17:06,410 --> 00:17:11,270
documentation so let's say one example

00:17:08,390 --> 00:17:13,429
is they take a whip for the image in

00:17:11,270 --> 00:17:18,199
centimeters well what happens if you

00:17:13,429 --> 00:17:20,000
give it and negative width well I did it

00:17:18,199 --> 00:17:22,429
I found that they gave an error I copied

00:17:20,000 --> 00:17:24,920
that exact era into my mark and then the

00:17:22,429 --> 00:17:28,370
library which is the kind of a main

00:17:24,920 --> 00:17:29,809
product handles that error and raises an

00:17:28,370 --> 00:17:32,360
appropriate Python multiplies an

00:17:29,809 --> 00:17:36,470
exception for that error so this point I

00:17:32,360 --> 00:17:38,809
have three sets of tests so I have a few

00:17:36,470 --> 00:17:42,140
integration tests which use the test

00:17:38,809 --> 00:17:44,000
library with the real before eeeh I have

00:17:42,140 --> 00:17:45,340
a whole bunch of unit tests for the

00:17:44,000 --> 00:17:47,080
library maybe maybe hundred

00:17:45,340 --> 00:17:49,720
thousands if you count those which are

00:17:47,080 --> 00:17:52,810
generated by hypothesis and those use

00:17:49,720 --> 00:17:55,900
the mark and then I have some unit tests

00:17:52,810 --> 00:17:57,310
for the MOC itself but I'm still

00:17:55,900 --> 00:17:59,790
vulnerable to those problems that I

00:17:57,310 --> 00:18:02,170
mentioned earlier copying incorrectly

00:17:59,790 --> 00:18:04,210
and before we are changing which will

00:18:02,170 --> 00:18:07,900
render my monk inaccurate and now my

00:18:04,210 --> 00:18:10,720
library possibly even broken so they're

00:18:07,900 --> 00:18:13,330
turning a mark into a verified fake

00:18:10,720 --> 00:18:17,230
which is the title of this talk is all

00:18:13,330 --> 00:18:19,720
about avoiding those problems now what a

00:18:17,230 --> 00:18:22,570
verify fake is roughly is it's a fake

00:18:19,720 --> 00:18:25,120
implementation which is verified against

00:18:22,570 --> 00:18:29,530
the subset a subset of the same test

00:18:25,120 --> 00:18:31,660
suite as the real implementation now I

00:18:29,530 --> 00:18:33,010
don't have the beforee account and I

00:18:31,660 --> 00:18:36,130
definitely don't have their test story

00:18:33,010 --> 00:18:37,720
if they've even got one and so if I

00:18:36,130 --> 00:18:40,210
wanted to make a verified fake which I

00:18:37,720 --> 00:18:43,630
did I needed to have my own test suite

00:18:40,210 --> 00:18:46,390
so turning the mark into a verified fake

00:18:43,630 --> 00:18:48,310
really meant making a test suite which

00:18:46,390 --> 00:18:52,090
ran both against the mark and the real

00:18:48,310 --> 00:18:53,440
thing so if you recall that simple PI

00:18:52,090 --> 00:18:55,240
test fixture from before while I

00:18:53,440 --> 00:18:58,660
expanded it so PI that has this really

00:18:55,240 --> 00:19:02,170
cool feature called parameterization and

00:18:58,660 --> 00:19:04,720
you can parameterize fixtures so that

00:19:02,170 --> 00:19:06,790
tests which use those fixtures are run

00:19:04,720 --> 00:19:09,940
once with each parameter option so here

00:19:06,790 --> 00:19:13,990
I've got a simple true/false and I map

00:19:09,940 --> 00:19:16,630
that to use real the foria or not and so

00:19:13,990 --> 00:19:18,940
any test which uses this fixture is run

00:19:16,630 --> 00:19:20,890
twice so it's run once with with the

00:19:18,940 --> 00:19:25,930
real vu phoria and then once with the

00:19:20,890 --> 00:19:27,310
mock vitória so these are the test

00:19:25,930 --> 00:19:31,530
results they look something like this

00:19:27,310 --> 00:19:33,670
you can see each test runs twice and

00:19:31,530 --> 00:19:35,800
fortunately I already had at least the

00:19:33,670 --> 00:19:38,260
start of a test suite for that mark so

00:19:35,800 --> 00:19:40,000
the first thing I did was I applied this

00:19:38,260 --> 00:19:41,260
to those tests so they run against the

00:19:40,000 --> 00:19:43,120
mock and the real thing and I thought I

00:19:41,260 --> 00:19:46,450
found that I've made a whole bunch of

00:19:43,120 --> 00:19:49,360
mistakes so now we've got a verified

00:19:46,450 --> 00:19:50,710
tech fake and we have a test suite which

00:19:49,360 --> 00:19:52,540
runs against both the fake

00:19:50,710 --> 00:19:55,210
implementation and the real

00:19:52,540 --> 00:19:56,950
implementation now because the mocks

00:19:55,210 --> 00:19:58,640
been turned in to verify a verified fake

00:19:56,950 --> 00:20:00,020
we actually trust

00:19:58,640 --> 00:20:01,940
that it's representative of the real

00:20:00,020 --> 00:20:03,950
before eeeh so we have loads of

00:20:01,940 --> 00:20:07,370
confidence in those hundreds of tests

00:20:03,950 --> 00:20:08,750
that we had for the library and we know

00:20:07,370 --> 00:20:10,880
that they don't just rely on an

00:20:08,750 --> 00:20:13,400
unrealistic mark but we also had another

00:20:10,880 --> 00:20:15,380
problem if you remember we worried that

00:20:13,400 --> 00:20:17,000
the forea would change and that that

00:20:15,380 --> 00:20:19,340
would make our mock inaccurate

00:20:17,000 --> 00:20:21,470
well now whenever these tests pass I

00:20:19,340 --> 00:20:24,650
know that the mark is still a faithful

00:20:21,470 --> 00:20:26,180
representation of the foria and we only

00:20:24,650 --> 00:20:28,160
incur the cost of running a hundred

00:20:26,180 --> 00:20:29,840
tests against before eeeh but we get

00:20:28,160 --> 00:20:33,050
almost a better whole benefit of running

00:20:29,840 --> 00:20:36,080
thousands of tests against before it so

00:20:33,050 --> 00:20:39,530
we lessen that kind of cost of flakiness

00:20:36,080 --> 00:20:42,110
and slow tests but at this point our

00:20:39,530 --> 00:20:43,700
tests only run when we make a change to

00:20:42,110 --> 00:20:46,490
the code which might not be that often

00:20:43,700 --> 00:20:47,660
especially once it's quite mature so we

00:20:46,490 --> 00:20:49,640
want to know what happens if a 4ea

00:20:47,660 --> 00:20:51,200
changes at that point well a cool

00:20:49,640 --> 00:20:52,460
feature of Travis and I'm sure a lot of

00:20:51,200 --> 00:20:55,300
other build systems is that you can

00:20:52,460 --> 00:20:57,560
actually set tests to run on a schedule

00:20:55,300 --> 00:20:59,060
so there's this trade-off if you run

00:20:57,560 --> 00:21:02,450
them all the time you find out problems

00:20:59,060 --> 00:21:04,040
quickly but you hit those those costs if

00:21:02,450 --> 00:21:06,140
you run them very rarely it takes you a

00:21:04,040 --> 00:21:07,520
long time to find out the problems so

00:21:06,140 --> 00:21:09,710
the trade-off that I chose was to

00:21:07,520 --> 00:21:11,570
trigger them every night but you can do

00:21:09,710 --> 00:21:12,560
them every release every week we'll just

00:21:11,570 --> 00:21:15,950
whatever work for your particular

00:21:12,560 --> 00:21:19,220
situation now back to that whit's

00:21:15,950 --> 00:21:20,930
example in the wine application I talked

00:21:19,220 --> 00:21:22,400
about at the beginning we really didn't

00:21:20,930 --> 00:21:24,850
care about the physical width of a wine

00:21:22,400 --> 00:21:27,920
label it wasn't a differentiating factor

00:21:24,850 --> 00:21:29,360
but and autos are actually really hard

00:21:27,920 --> 00:21:31,610
to get that's why we didn't care about

00:21:29,360 --> 00:21:32,930
it that much but and we tells the for it

00:21:31,610 --> 00:21:35,540
all the time that the width was zero

00:21:32,930 --> 00:21:37,400
didn't matter to us and that always

00:21:35,540 --> 00:21:39,170
worked and our mock supported it and

00:21:37,400 --> 00:21:41,120
when we get to the verified sake now few

00:21:39,170 --> 00:21:43,940
months later the verified sake also

00:21:41,120 --> 00:21:47,720
supports it and has a test that a width

00:21:43,940 --> 00:21:50,900
of zero is is okay no errors is returned

00:21:47,720 --> 00:21:53,450
the images that addict but one morning I

00:21:50,900 --> 00:21:54,350
get a an email from Travis and it looks

00:21:53,450 --> 00:21:57,830
something like this

00:21:54,350 --> 00:22:00,710
and it tells me that the build fails so

00:21:57,830 --> 00:22:02,630
I look at the logs and I see that we

00:22:00,710 --> 00:22:05,000
actually have a very precise data point

00:22:02,630 --> 00:22:07,730
of exactly what's changed in before eeeh

00:22:05,000 --> 00:22:10,070
so the mock passes for this test but the

00:22:07,730 --> 00:22:11,879
real implementation fails and the test

00:22:10,070 --> 00:22:16,799
is well what if I add

00:22:11,879 --> 00:22:18,179
a an image with a width of zero so now

00:22:16,799 --> 00:22:20,579
what I do I just changed the Mach

00:22:18,179 --> 00:22:22,289
function and the test so that the

00:22:20,579 --> 00:22:27,059
behavior new behavior is represented by

00:22:22,289 --> 00:22:29,039
the mark and that's very easy but now if

00:22:27,059 --> 00:22:30,929
you remember the library's tests they

00:22:29,039 --> 00:22:34,949
themselves depended on the mark so now

00:22:30,929 --> 00:22:37,559
the library expects that a width of zero

00:22:34,949 --> 00:22:39,599
is valid but it's invalid so as soon as

00:22:37,559 --> 00:22:43,169
I change the mark well in the library's

00:22:39,599 --> 00:22:45,149
tests immediately started failing so I

00:22:43,169 --> 00:22:46,589
could change the library to give a nice

00:22:45,149 --> 00:22:49,079
Python exception when use a width of

00:22:46,589 --> 00:22:51,359
zero and what that really demonstrates

00:22:49,079 --> 00:22:54,329
is that really within a few hours before

00:22:51,359 --> 00:22:56,129
iam made an undocumented change and that

00:22:54,329 --> 00:22:58,229
introduced incompatibility with my

00:22:56,129 --> 00:23:00,690
library and then this incompatibility

00:22:58,229 --> 00:23:04,589
was fixed without any real complex

00:23:00,690 --> 00:23:06,719
debugging and to me that shows the value

00:23:04,589 --> 00:23:09,149
of having a verified fake to any

00:23:06,719 --> 00:23:11,609
developer really who's using his writing

00:23:09,149 --> 00:23:15,839
code which integrates with third-party

00:23:11,609 --> 00:23:17,909
software tonight that you can imagine

00:23:15,839 --> 00:23:20,309
that building a verified fake when you

00:23:17,909 --> 00:23:23,489
have the original source code is much

00:23:20,309 --> 00:23:26,669
simpler than when you don't and a lot of

00:23:23,489 --> 00:23:30,209
the fake can share work and share code

00:23:26,669 --> 00:23:32,190
with the real implementation and hardly

00:23:30,209 --> 00:23:33,959
any open web services are opens also

00:23:32,190 --> 00:23:36,239
this can be really valuable if you're

00:23:33,959 --> 00:23:38,309
shipping software to people if you're

00:23:36,239 --> 00:23:40,559
shipping software to people which they

00:23:38,309 --> 00:23:43,379
might want to call in tests well you can

00:23:40,559 --> 00:23:45,299
actually add tremendous value to that

00:23:43,379 --> 00:23:47,399
software by shipping your own verified

00:23:45,299 --> 00:23:49,440
fake and it might even cause someone

00:23:47,399 --> 00:23:52,619
like me to choose to use your software

00:23:49,440 --> 00:23:54,599
over competitors and if you make a

00:23:52,619 --> 00:23:56,749
verified fake as the author of the

00:23:54,599 --> 00:23:59,190
software well it's much easier because

00:23:56,749 --> 00:24:00,779
well because you can get told before

00:23:59,190 --> 00:24:02,940
merging any changes that it would make

00:24:00,779 --> 00:24:05,999
the fake unrealistic so you know when to

00:24:02,940 --> 00:24:09,959
make changes to your code without the

00:24:05,999 --> 00:24:11,879
need for that one spurred a test run so

00:24:09,959 --> 00:24:14,309
I'm hoping that maybe in the future

00:24:11,879 --> 00:24:17,569
having an API which is easily tested

00:24:14,309 --> 00:24:21,029
against will become kind of table stakes

00:24:17,569 --> 00:24:23,039
and one cool thing about making a verify

00:24:21,029 --> 00:24:24,839
fake well you don't really have to ship

00:24:23,039 --> 00:24:25,290
your secret sauce you can just ship

00:24:24,839 --> 00:24:27,090
something

00:24:25,290 --> 00:24:28,230
does the bare minimum of your API

00:24:27,090 --> 00:24:30,720
interface let say you're making

00:24:28,230 --> 00:24:32,850
something like before you you can just

00:24:30,720 --> 00:24:34,380
have a really rubbish she kind of image

00:24:32,850 --> 00:24:35,580
match shipping that's your the core of

00:24:34,380 --> 00:24:40,080
your business you don't need to ship

00:24:35,580 --> 00:24:43,440
that to people so I hope now that you

00:24:40,080 --> 00:24:46,440
have a rough idea at least of what a

00:24:43,440 --> 00:24:48,750
verified fake is why don't it be useful

00:24:46,440 --> 00:24:52,800
and how you can start making one for

00:24:48,750 --> 00:24:56,400
yourself and for your users maybe so

00:24:52,800 --> 00:24:57,900
thank you very much that's my talk and

00:24:56,400 --> 00:25:03,650
I'm happy to take any questions thank

00:24:57,900 --> 00:25:09,570
you okay

00:25:03,650 --> 00:25:12,780
some questions hi very great great talk

00:25:09,570 --> 00:25:15,900
and eighty percent overlapping with the

00:25:12,780 --> 00:25:18,600
one I cave mm oh but you're you've got a

00:25:15,900 --> 00:25:23,370
case study which is great i don't i had

00:25:18,600 --> 00:25:26,730
the general discussion and they i think

00:25:23,370 --> 00:25:28,890
your ending is exactly how where it

00:25:26,730 --> 00:25:31,740
should be is like there is no

00:25:28,890 --> 00:25:35,880
justification for releasing a component

00:25:31,740 --> 00:25:39,720
without a fake the terminology i am

00:25:35,880 --> 00:25:42,930
trying to use to use martin's

00:25:39,720 --> 00:25:47,010
so the distinction between fake and mock

00:25:42,930 --> 00:25:50,070
so for example they one thing one thing

00:25:47,010 --> 00:25:54,150
that says is that essentially that a

00:25:50,070 --> 00:25:56,370
fake should be a spy then that's not in

00:25:54,150 --> 00:25:58,860
the original a box shouldn't be a

00:25:56,370 --> 00:26:01,590
surprise i think should it provide an

00:25:58,860 --> 00:26:03,450
introspection api perhaps and with this

00:26:01,590 --> 00:26:06,630
case i didn't worry about it so much

00:26:03,450 --> 00:26:09,720
because the API itself provides

00:26:06,630 --> 00:26:12,420
introspection abilities right the big

00:26:09,720 --> 00:26:15,240
thing that's missing here in my view is

00:26:12,420 --> 00:26:18,420
the ability to simulator the example I

00:26:15,240 --> 00:26:20,970
give is CPU or fire you don't really

00:26:18,420 --> 00:26:23,190
want to be there with a lighter to give

00:26:20,970 --> 00:26:26,430
fire to your CPU to check that your code

00:26:23,190 --> 00:26:29,850
is handling it they mark sake whatever

00:26:26,430 --> 00:26:33,090
should be programmable to raise an error

00:26:29,850 --> 00:26:35,580
so actually I've got a respond to that

00:26:33,090 --> 00:26:38,280
so first of all it's very difficult for

00:26:35,580 --> 00:26:39,059
the on fire case to verify it right

00:26:38,280 --> 00:26:40,440
because

00:26:39,059 --> 00:26:42,629
how do you have a test that checks

00:26:40,440 --> 00:26:45,269
against and thank you for your question

00:26:42,629 --> 00:26:47,580
as well your comment how do you have a

00:26:45,269 --> 00:26:49,470
test that tests it when you say this is

00:26:47,580 --> 00:26:51,330
going to give a 500 it will give a 500

00:26:49,470 --> 00:26:52,919
just like when their servers are down

00:26:51,330 --> 00:26:54,720
because their servers are down right now

00:26:52,919 --> 00:26:58,649
but actually if you check out the source

00:26:54,720 --> 00:27:04,740
code for vws Python and it takes a state

00:26:58,649 --> 00:27:08,070
object and so I have various states like

00:27:04,740 --> 00:27:10,230
on fire but not quite and so you can say

00:27:08,070 --> 00:27:13,529
just like I have this verify mock

00:27:10,230 --> 00:27:16,769
fixture or verify before we a fixture or

00:27:13,529 --> 00:27:18,960
verify before iya context manager I can

00:27:16,769 --> 00:27:24,210
give that a parameter which says broken

00:27:18,960 --> 00:27:25,799
inactive slow and then your you can see

00:27:24,210 --> 00:27:28,259
if your tests work even when there is a

00:27:25,799 --> 00:27:30,840
five-minute delay in the matching

00:27:28,259 --> 00:27:32,249
ability I hope that gives you a little

00:27:30,840 --> 00:27:38,460
bit of insight into how I've dealt with

00:27:32,249 --> 00:27:42,720
that issue I really appreciate the talk

00:27:38,460 --> 00:27:46,100
but I was wondering in visa kind of

00:27:42,720 --> 00:27:48,840
service you were walking basically the

00:27:46,100 --> 00:27:50,879
response was depending on the data you

00:27:48,840 --> 00:27:53,159
put before how would you go about

00:27:50,879 --> 00:27:56,009
marking a service for which you don't

00:27:53,159 --> 00:27:59,100
have the ability to specify the data for

00:27:56,009 --> 00:28:01,950
example if I want to know the events in

00:27:59,100 --> 00:28:04,230
a specific location they change every

00:28:01,950 --> 00:28:06,869
day they are not in my control and how

00:28:04,230 --> 00:28:07,830
can I write tests against this data

00:28:06,869 --> 00:28:11,129
which I don't know

00:28:07,830 --> 00:28:14,519
sure so you can imagine that that API

00:28:11,129 --> 00:28:18,090
that event consuming API that you're

00:28:14,519 --> 00:28:20,580
doing let's say I think Eventbrite is

00:28:18,090 --> 00:28:24,419
one of those those companies or meetup

00:28:20,580 --> 00:28:28,200
comm that they also have an API add

00:28:24,419 --> 00:28:30,929
event right but that API might not be

00:28:28,200 --> 00:28:35,090
public to you so what you've got to do

00:28:30,929 --> 00:28:37,230
is act as if you are the meetup calm

00:28:35,090 --> 00:28:39,779
person right you're the meetup calm

00:28:37,230 --> 00:28:42,629
servers and you just make some ability

00:28:39,779 --> 00:28:45,119
to add to the add an event even if it

00:28:42,629 --> 00:28:47,429
doesn't have a mocked API that will be

00:28:45,119 --> 00:28:49,649
exactly like this and then you can know

00:28:47,429 --> 00:28:50,190
okay given that I've already added an

00:28:49,649 --> 00:28:53,789
event

00:28:50,190 --> 00:28:56,129
it works in the same structure now if

00:28:53,789 --> 00:28:58,500
you want to verify it well what you can

00:28:56,129 --> 00:29:02,659
do you can have a test account that has

00:28:58,500 --> 00:29:05,370
an event in a particular location with

00:29:02,659 --> 00:29:08,549
you know a particular image and then you

00:29:05,370 --> 00:29:11,970
can make your test run against that test

00:29:08,549 --> 00:29:14,039
account and have uploaded that kind of

00:29:11,970 --> 00:29:15,389
event into your mock already and then

00:29:14,039 --> 00:29:17,610
you can say ok I want to check this

00:29:15,389 --> 00:29:19,080
event and check that the response is

00:29:17,610 --> 00:29:20,460
exactly the same I hope that roughly

00:29:19,080 --> 00:29:23,220
answers your question but you're right

00:29:20,460 --> 00:29:26,659
it's not a solved issue it's not always

00:29:23,220 --> 00:29:38,840
that easy and it is context is specific

00:29:26,659 --> 00:29:40,799
thank you next question is great is

00:29:38,840 --> 00:29:43,710
there any way that you could integrate

00:29:40,799 --> 00:29:45,120
this with fuzzing to find out the API

00:29:43,710 --> 00:29:46,409
responses that you may not be able to

00:29:45,120 --> 00:29:49,919
think of your applications not using

00:29:46,409 --> 00:29:52,230
sure so I mentioned hypothesis before

00:29:49,919 --> 00:29:54,240
that the closest tool that I personally

00:29:52,230 --> 00:29:56,610
use to fuzzing if anyone doesn't know it

00:29:54,240 --> 00:29:58,409
it's a property-based testing tool and

00:29:56,610 --> 00:30:00,659
it like I said generates a lot of tests

00:29:58,409 --> 00:30:02,220
which is kind of what fuzzing is I

00:30:00,659 --> 00:30:05,330
haven't actually done it for this

00:30:02,220 --> 00:30:08,309
because the request limits were so slow

00:30:05,330 --> 00:30:10,679
is it so low and the request took so

00:30:08,309 --> 00:30:12,720
long actually the point of doing this to

00:30:10,679 --> 00:30:15,509
me was so that I could add fuzzing to my

00:30:12,720 --> 00:30:17,220
code but you can imagine that if those

00:30:15,509 --> 00:30:19,799
problems weren't the case well you could

00:30:17,220 --> 00:30:22,590
say hey hypothesis or my fuzzing tool

00:30:19,799 --> 00:30:24,509
please run random requests against my

00:30:22,590 --> 00:30:27,149
mark and the real implementation and

00:30:24,509 --> 00:30:28,950
check that they either are exactly the

00:30:27,149 --> 00:30:30,779
same in response or share some

00:30:28,950 --> 00:30:32,850
properties like they have the same keys

00:30:30,779 --> 00:30:37,169
that that would be ideal but it really

00:30:32,850 --> 00:30:40,759
wasn't suitable in this case ok another

00:30:37,169 --> 00:30:40,759
question No oh yes

00:30:41,350 --> 00:30:51,610
so after it just the lunchtime hi a

00:30:49,120 --> 00:30:55,000
really nice talk thank you um I wonder

00:30:51,610 --> 00:30:57,610
you have like libraries like VCR or

00:30:55,000 --> 00:31:01,750
Betamax which is ported from Ruby right

00:30:57,610 --> 00:31:04,960
and they you can like record a response

00:31:01,750 --> 00:31:08,289
like and it's recorded in JSON and I

00:31:04,960 --> 00:31:11,289
wonder why you wouldn't use just like

00:31:08,289 --> 00:31:14,019
for day-to-day testing like that and

00:31:11,289 --> 00:31:16,149
then at midnight or once a day just

00:31:14,019 --> 00:31:19,509
disable the cache and see you the tests

00:31:16,149 --> 00:31:21,039
pass then so yeah

00:31:19,509 --> 00:31:25,840
PCR tools are definitely something that

00:31:21,039 --> 00:31:30,070
I've used a bit but how do you know that

00:31:25,840 --> 00:31:33,759
the operative this way maybe you have a

00:31:30,070 --> 00:31:35,950
very similar case right that the API can

00:31:33,759 --> 00:31:38,980
change and then when you disable the

00:31:35,950 --> 00:31:41,080
cache then you have to update your VCR

00:31:38,980 --> 00:31:43,299
responses and then you've kind of got a

00:31:41,080 --> 00:31:47,049
very similar thing but you might not

00:31:43,299 --> 00:31:50,440
have the add component if I want to hear

00:31:47,049 --> 00:31:56,500
add an image what do I do in a VCR

00:31:50,440 --> 00:31:57,850
system it I kind of have it sorry I

00:31:56,500 --> 00:32:01,000
don't have a great answer for that I'm

00:31:57,850 --> 00:32:05,519
going to pass on to the next one this is

00:32:01,000 --> 00:32:05,519
an alternative I guess to a VCR system

00:32:15,779 --> 00:32:23,049
now I think that people use VCR to VCR

00:32:19,090 --> 00:32:27,340
some other service I've certainly very

00:32:23,049 --> 00:32:29,769
briefly contributed to my github github

00:32:27,340 --> 00:32:34,000
API and what they do is they record

00:32:29,769 --> 00:32:36,549
responses from VCR really I try to avoid

00:32:34,000 --> 00:32:39,519
it because it came with its own set of

00:32:36,549 --> 00:32:47,399
problems and it was more painful for me

00:32:39,519 --> 00:32:48,820
to use than this system no I think is -

00:32:47,399 --> 00:32:50,530
Thank You Adam

00:32:48,820 --> 00:32:52,590
thanks to you

00:32:50,530 --> 00:32:52,590
you

00:32:53,880 --> 00:32:58,109

YouTube URL: https://www.youtube.com/watch?v=bYtA1WK7aLM


