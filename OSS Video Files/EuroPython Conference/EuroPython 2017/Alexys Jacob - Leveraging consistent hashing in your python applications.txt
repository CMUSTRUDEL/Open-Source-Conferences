Title: Alexys Jacob - Leveraging consistent hashing in your python applications
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Leveraging consistent hashing in your python applications
[EuroPython 2017 - Talk - 2017-07-11 - Anfiteatro 2]
[Rimini, Italy]

While consistent hashing is largely known and adopted in the NoSQL database clusters to solve data distribution and data access reliability, it is less known and used by the typical developers.

This talk will introduce you to consistent hashing and the problems it solves while going through a practical use case in a python application.

We will start from its standalone design and scale it out to an optimized clustered version thanks to consistent hashing.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,150 --> 00:00:08,440
we spent the next hour I will do my best

00:00:06,610 --> 00:00:11,740
to explain to you what's consistent

00:00:08,440 --> 00:00:19,119
shashing here and what can you do with

00:00:11,740 --> 00:00:22,180
it and quickly about myself you can

00:00:19,119 --> 00:00:24,850
shine me on the handled ultra bag I'm a

00:00:22,180 --> 00:00:28,080
Gentoo Linux developer where I focus on

00:00:24,850 --> 00:00:32,110
mainly on clustering and no Siqueiros

00:00:28,080 --> 00:00:41,460
distributive stuff and I'm also CTO and

00:00:32,110 --> 00:00:44,079
member Lee the goal of this talk is to

00:00:41,460 --> 00:00:47,020
really introduce you to consistent

00:00:44,079 --> 00:00:49,510
hashing so I will have to go into the

00:00:47,020 --> 00:00:52,660
before we do with the what how we have

00:00:49,510 --> 00:00:55,450
to introduce you to this how so we start

00:00:52,660 --> 00:00:57,940
with the basics of what led to

00:00:55,450 --> 00:01:01,390
consistent hashing and what kind of

00:00:57,940 --> 00:01:05,560
problem it solves and but first let's go

00:01:01,390 --> 00:01:07,869
into a bit of history so this is the

00:01:05,560 --> 00:01:10,300
concept of consistent hashing is 20

00:01:07,869 --> 00:01:12,250
years old actually it came from the

00:01:10,300 --> 00:01:14,890
paper from the guys from a kunai when

00:01:12,250 --> 00:01:20,560
they had some problems with this

00:01:14,890 --> 00:01:24,009
distributed caching and then it got into

00:01:20,560 --> 00:01:26,619
the radar of p2p networks and like

00:01:24,009 --> 00:01:30,069
system like strawed use consistent

00:01:26,619 --> 00:01:33,940
hashing to keep track of where some part

00:01:30,069 --> 00:01:37,649
of file is and that it got into the

00:01:33,940 --> 00:01:43,149
database world and mainly after Amazon

00:01:37,649 --> 00:01:48,459
use it in its dynamodb for memory

00:01:43,149 --> 00:01:50,349
management so it's strange to me that

00:01:48,459 --> 00:01:54,729
it's still fairly unknown to the casual

00:01:50,349 --> 00:01:57,910
developer and maybe it will be a good

00:01:54,729 --> 00:02:02,259
chance for me to to make it even a bit

00:01:57,910 --> 00:02:05,170
one known as well and so let me tell you

00:02:02,259 --> 00:02:08,979
a story first on the basics so let me

00:02:05,170 --> 00:02:11,590
tell you a story on mapping a map is a

00:02:08,979 --> 00:02:14,110
way to take something that I'd point to

00:02:11,590 --> 00:02:17,650
another item and return that second item

00:02:14,110 --> 00:02:20,260
okay it's fairly basic concept

00:02:17,650 --> 00:02:24,640
and the idea behind it is that you have

00:02:20,260 --> 00:02:29,140
a referential that you will use to point

00:02:24,640 --> 00:02:35,260
and to get some information this idea of

00:02:29,140 --> 00:02:39,970
looking up that is the core of the

00:02:35,260 --> 00:02:42,760
mapping functions so it's like a phone

00:02:39,970 --> 00:02:45,640
book where you have a name and you want

00:02:42,760 --> 00:02:51,329
to find out the number of the people

00:02:45,640 --> 00:02:55,209
that you are looking at the basic of the

00:02:51,329 --> 00:02:58,329
map is that you have the referential

00:02:55,209 --> 00:03:01,090
selection that then you apply a logical

00:02:58,329 --> 00:03:03,970
operation on it and then that points to

00:03:01,090 --> 00:03:07,420
a location where the information that

00:03:03,970 --> 00:03:11,859
you're looking for is tall the whole

00:03:07,420 --> 00:03:13,840
process in the two straw steps will have

00:03:11,859 --> 00:03:20,439
a great impact on your look at

00:03:13,840 --> 00:03:24,099
efficiency so mapping is just a map and

00:03:20,439 --> 00:03:30,069
you know as developers most others know

00:03:24,099 --> 00:03:34,389
this as a key relating to a value when

00:03:30,069 --> 00:03:39,250
you think about this you usually think

00:03:34,389 --> 00:03:42,310
about a dick right and I conduct for

00:03:39,250 --> 00:03:44,859
instance is a map if you have a key and

00:03:42,310 --> 00:03:48,069
you have a value associated to this key

00:03:44,859 --> 00:03:51,729
right so let's get a deep dive or quick

00:03:48,069 --> 00:03:56,019
dive story about how is it how is the

00:03:51,729 --> 00:03:58,780
Python dict implemented the truth on the

00:03:56,019 --> 00:04:05,949
Python dicks is that it's what we call a

00:03:58,780 --> 00:04:09,699
hash table a hash table is you apply a

00:04:05,949 --> 00:04:11,979
hash function on the key and then you do

00:04:09,699 --> 00:04:14,560
another logical operation that will

00:04:11,979 --> 00:04:17,470
point to the value the role of the hash

00:04:14,560 --> 00:04:22,240
function is very important because it

00:04:17,470 --> 00:04:25,750
has a direct relationship with the

00:04:22,240 --> 00:04:29,240
spread of your key on the location that

00:04:25,750 --> 00:04:33,470
is touring and all the values

00:04:29,240 --> 00:04:35,600
and the two steps represent the actual

00:04:33,470 --> 00:04:39,289
implementation so how is the

00:04:35,600 --> 00:04:42,770
implementation of the Pythons it well it

00:04:39,289 --> 00:04:46,130
supplies this function well the hash of

00:04:42,770 --> 00:04:49,639
the key is as a binary operation on the

00:04:46,130 --> 00:04:54,620
size of the in-memory array that stores

00:04:49,639 --> 00:04:58,520
all the values so if you do a shove a

00:04:54,620 --> 00:05:01,220
you get a number that's the key point

00:04:58,520 --> 00:05:03,740
here a hash function since you will do a

00:05:01,220 --> 00:05:08,780
logical operation on it has to return a

00:05:03,740 --> 00:05:12,229
number so you apply a binary operation

00:05:08,780 --> 00:05:16,280
on the size in this case is 11 and you

00:05:12,229 --> 00:05:18,470
get index 0 so that means that you will

00:05:16,280 --> 00:05:22,310
get on your in memory array at the index

00:05:18,470 --> 00:05:25,729
0 is the value for key a that is a hash

00:05:22,310 --> 00:05:29,270
table if I do the same for key C you see

00:05:25,729 --> 00:05:32,800
that it points to I index 2 if I do the

00:05:29,270 --> 00:05:38,630
same for key B it points for to index 3

00:05:32,800 --> 00:05:41,300
ok sounds pretty easy and pretty solid

00:05:38,630 --> 00:05:47,360
this hash function is a greeting of

00:05:41,300 --> 00:05:50,300
Python so there are some key factors to

00:05:47,360 --> 00:05:53,030
consider here because you expect this to

00:05:50,300 --> 00:05:56,840
be an efficient process right looking at

00:05:53,030 --> 00:06:00,800
the key must return the value fairly

00:05:56,840 --> 00:06:02,960
easily and quickly and so the

00:06:00,800 --> 00:06:05,590
distribution and balancing is the

00:06:02,960 --> 00:06:08,960
responsibility of the hash function and

00:06:05,590 --> 00:06:12,949
the operation will lead to some accuracy

00:06:08,960 --> 00:06:16,430
and performance on the location and on

00:06:12,949 --> 00:06:20,389
the whole implementation process when

00:06:16,430 --> 00:06:24,050
you add the storing of this data then

00:06:20,389 --> 00:06:27,130
you start talking about scaling so does

00:06:24,050 --> 00:06:30,530
the Python dict actually scale good

00:06:27,130 --> 00:06:32,810
the answer is I guess for some people

00:06:30,530 --> 00:06:34,130
who have try to put a lot of information

00:06:32,810 --> 00:06:37,880
in Python dict

00:06:34,130 --> 00:06:40,339
no and the reason is that the hash

00:06:37,880 --> 00:06:42,950
function the basic hash function is

00:06:40,339 --> 00:06:44,990
meant for very and the

00:06:42,950 --> 00:06:48,680
station itself is meant for very fast

00:06:44,990 --> 00:06:53,060
and consistently fast he look at at the

00:06:48,680 --> 00:06:55,010
expense of memory why because the hash

00:06:53,060 --> 00:06:58,250
function does not distribute the keys

00:06:55,010 --> 00:07:02,030
and the values of the keys evenly in the

00:06:58,250 --> 00:07:04,610
in-memory array that means that if you

00:07:02,030 --> 00:07:07,430
if we take the example earlier you see

00:07:04,610 --> 00:07:14,750
that index 1 you consume some memory

00:07:07,430 --> 00:07:20,000
with no information in it so how do you

00:07:14,750 --> 00:07:24,280
scale out from Titanic or form Nash

00:07:20,000 --> 00:07:27,650
table that is not very easily spread

00:07:24,280 --> 00:07:31,760
this is where distributed hash tables

00:07:27,650 --> 00:07:34,550
come in so their little name is DHT I

00:07:31,760 --> 00:07:39,050
guess most of you have heard of them but

00:07:34,550 --> 00:07:43,310
the idea is still pretty simple you

00:07:39,050 --> 00:07:46,970
split your keys into buckets so the hash

00:07:43,310 --> 00:07:49,700
of your key will apply to be an to an

00:07:46,970 --> 00:07:53,180
operator but instead of pointing to a

00:07:49,700 --> 00:07:55,100
direct location in let's say in memory

00:07:53,180 --> 00:07:59,330
location it will just reference the

00:07:55,100 --> 00:08:02,300
Birkett ID this bucket itself is a hash

00:07:59,330 --> 00:08:04,700
table so when you point to the bucket

00:08:02,300 --> 00:08:07,520
you will have to get the bucket to get

00:08:04,700 --> 00:08:09,970
to the bucket and then do another lookup

00:08:07,520 --> 00:08:14,480
over there

00:08:09,970 --> 00:08:17,890
fine then you take those buckets and you

00:08:14,480 --> 00:08:21,050
spread it on machines on servers right

00:08:17,890 --> 00:08:24,050
so in this at this moment the

00:08:21,050 --> 00:08:26,540
distributed hash table allows you to

00:08:24,050 --> 00:08:30,710
spread your keys and the data that comes

00:08:26,540 --> 00:08:32,960
with it around different machines which

00:08:30,710 --> 00:08:37,490
is how you will be able to scale if you

00:08:32,960 --> 00:08:39,950
want it to have vitamix inside inserted

00:08:37,490 --> 00:08:42,229
into buckets you could have Python leaks

00:08:39,950 --> 00:08:43,880
on different machines and then scale out

00:08:42,229 --> 00:08:48,110
what we would then fit on a single

00:08:43,880 --> 00:08:51,230
machine right so the key question now is

00:08:48,110 --> 00:08:53,150
what's the best operator for the

00:08:51,230 --> 00:08:55,310
accuracy and the efficiency of this

00:08:53,150 --> 00:08:55,630
implementation what's the best operator

00:08:55,310 --> 00:08:58,509
you

00:08:55,630 --> 00:09:03,790
have to point to the right server in the

00:08:58,509 --> 00:09:06,310
most efficient way so let's take with

00:09:03,790 --> 00:09:10,329
let's approach this problem with a knife

00:09:06,310 --> 00:09:13,600
DHT implementation the knife one is uses

00:09:10,329 --> 00:09:16,300
the modulo operator on the size of the

00:09:13,600 --> 00:09:20,649
number of the number of buckets so the

00:09:16,300 --> 00:09:23,319
idea is I do a hash on my key in this

00:09:20,649 --> 00:09:26,380
case I can't I will choose the hash

00:09:23,319 --> 00:09:29,069
function of Python because it doesn't

00:09:26,380 --> 00:09:33,360
spread it doesn't mix the keys easily

00:09:29,069 --> 00:09:36,850
evenly that means that he asked of a

00:09:33,360 --> 00:09:39,670
gets me a number that is close or very

00:09:36,850 --> 00:09:43,060
close to the hash of B that doesn't mix

00:09:39,670 --> 00:09:46,329
well the idea is to have a random output

00:09:43,060 --> 00:09:49,420
a random number coming out of a hash

00:09:46,329 --> 00:09:51,850
function so the best and easily known

00:09:49,420 --> 00:09:55,329
ash function that comes to mind is md5

00:09:51,850 --> 00:09:59,620
which six mixes well the keys at least

00:09:55,329 --> 00:10:02,259
and it's pretty easily implemented when

00:09:59,620 --> 00:10:06,579
pretty standard as well so in this case

00:10:02,259 --> 00:10:09,009
I would do md5 of B I would apply an

00:10:06,579 --> 00:10:11,680
extra just to get an extra decimal love

00:10:09,009 --> 00:10:14,230
it and I will transform it in base 16 to

00:10:11,680 --> 00:10:17,439
get an actual number on which I would

00:10:14,230 --> 00:10:22,360
apply a modulo on the size on the number

00:10:17,439 --> 00:10:26,500
of server or buckets that I have so the

00:10:22,360 --> 00:10:28,449
doing so with D would give me an modulo

00:10:26,500 --> 00:10:31,360
on three and as I have three servers

00:10:28,449 --> 00:10:34,360
would give okay it is on stereo key is

00:10:31,360 --> 00:10:38,380
on server 0 and you could connect there

00:10:34,360 --> 00:10:43,329
and get the value of what you're looking

00:10:38,380 --> 00:10:48,790
for so it seems pretty simple pretty

00:10:43,329 --> 00:10:51,910
solid and that's what we add actually in

00:10:48,790 --> 00:10:54,339
the 90s which I can say that but before

00:10:51,910 --> 00:10:59,259
consistent hashing came into play and

00:10:54,339 --> 00:11:03,730
that then the problem that we'll see is

00:10:59,259 --> 00:11:07,449
what but I can I think about consistent

00:11:03,730 --> 00:11:09,200
hashing actually because it won't scale

00:11:07,449 --> 00:11:12,770
if you're if the number

00:11:09,200 --> 00:11:16,840
your buckets change because the modulo

00:11:12,770 --> 00:11:20,060
operator and the size of the bucket will

00:11:16,840 --> 00:11:23,810
you apply the module operator the index

00:11:20,060 --> 00:11:27,050
the same key was referencing to will

00:11:23,810 --> 00:11:31,340
change or have a very high probability

00:11:27,050 --> 00:11:35,110
of changing in this case the D is on

00:11:31,340 --> 00:11:37,610
modulo four points now to sever one and

00:11:35,110 --> 00:11:40,940
before it was pointing to several zero

00:11:37,610 --> 00:11:44,660
so that means that on distributed system

00:11:40,940 --> 00:11:47,630
are on systems where you can have you

00:11:44,660 --> 00:11:53,090
need to tolerate the failure of a server

00:11:47,630 --> 00:11:55,700
or you need to scale up and add new

00:11:53,090 --> 00:11:58,250
servers if you were implementing the

00:11:55,700 --> 00:12:06,620
naive DHT implementation on the modulo

00:11:58,250 --> 00:12:09,590
you get some serious problems basically

00:12:06,620 --> 00:12:12,530
the number if we were using the hash

00:12:09,590 --> 00:12:14,870
function of tight on the number of key

00:12:12,530 --> 00:12:18,500
remapping so that means the keys that

00:12:14,870 --> 00:12:22,910
would their index would change would

00:12:18,500 --> 00:12:27,920
follow this operation so let's say that

00:12:22,910 --> 00:12:31,460
for 2000 and these spread on 100 servers

00:12:27,920 --> 00:12:34,280
you would get one thousand and nine

00:12:31,460 --> 00:12:36,830
hundred keys that would point to a bad

00:12:34,280 --> 00:12:39,970
location if you'd only changed or added

00:12:36,830 --> 00:12:44,750
or removed one server from your cluster

00:12:39,970 --> 00:12:50,900
or your topology it would be a disaster

00:12:44,750 --> 00:12:53,590
even more at scale right so I guess we

00:12:50,900 --> 00:12:58,580
need help on this we need consistency

00:12:53,590 --> 00:13:01,700
well at least the best consistency or a

00:12:58,580 --> 00:13:05,930
better consistency let's tell the truth

00:13:01,700 --> 00:13:08,960
right ok hand here I introduce you to

00:13:05,930 --> 00:13:12,760
the hash ring the hash ring is the

00:13:08,960 --> 00:13:18,710
concept behind consistent hashing and

00:13:12,760 --> 00:13:21,050
the ID on this is pretty simple actually

00:13:18,710 --> 00:13:22,350
when you think about it all when you

00:13:21,050 --> 00:13:25,200
hear about it

00:13:22,350 --> 00:13:28,800
and I guess I guess I'll do a decent job

00:13:25,200 --> 00:13:31,770
at doing this and the idea is that you

00:13:28,800 --> 00:13:35,490
place your server on the Rings that's

00:13:31,770 --> 00:13:37,830
also called the continuum so you can

00:13:35,490 --> 00:13:43,530
picture it quite easily you have an

00:13:37,830 --> 00:13:48,240
array and you bend it to form a circle

00:13:43,530 --> 00:13:50,880
right and then you hash the name of your

00:13:48,240 --> 00:13:55,920
server which gives you a number and you

00:13:50,880 --> 00:13:58,560
place it on your ring simple enough for

00:13:55,920 --> 00:14:01,560
now so in this case I have three server

00:13:58,560 --> 00:14:07,470
i hash their name and I place the a

00:14:01,560 --> 00:14:09,270
number on my ring okay then how do you

00:14:07,470 --> 00:14:11,400
look it up how do you look at the key

00:14:09,270 --> 00:14:14,880
and how do you know that the key belongs

00:14:11,400 --> 00:14:17,550
to said server well you do the hash of

00:14:14,880 --> 00:14:20,340
the key as well you place it on the ring

00:14:17,550 --> 00:14:23,490
and then you go clockwise until you hit

00:14:20,340 --> 00:14:32,550
a server and that will be the server

00:14:23,490 --> 00:14:38,010
responsible for the key kind of okay if

00:14:32,550 --> 00:14:41,270
you do this only one over n of your keys

00:14:38,010 --> 00:14:44,340
will be remapped or relocated or change

00:14:41,270 --> 00:14:50,360
if you add or remove a server on the

00:14:44,340 --> 00:14:53,670
ring that's fairly and clearly better

00:14:50,360 --> 00:14:56,550
what's cool with this is the more

00:14:53,670 --> 00:15:01,340
servers you had on your topology the

00:14:56,550 --> 00:15:04,740
more robust you get okay

00:15:01,340 --> 00:15:06,630
but there are still a problem the

00:15:04,740 --> 00:15:08,610
problem is that the implementation

00:15:06,630 --> 00:15:11,730
itself can be nice if the hash function

00:15:08,610 --> 00:15:14,700
is not nice you still get the problem of

00:15:11,730 --> 00:15:16,680
distribution even with the hash ring the

00:15:14,700 --> 00:15:18,570
consistent hashing does that solve by

00:15:16,680 --> 00:15:22,860
itself the problem of distribution of

00:15:18,570 --> 00:15:26,180
your servers around the circle the hash

00:15:22,860 --> 00:15:29,250
function does so you could end up with

00:15:26,180 --> 00:15:32,580
because it's pretty random at some point

00:15:29,250 --> 00:15:34,200
if you think about it you could end up

00:15:32,580 --> 00:15:35,529
with this kind of distribution where

00:15:34,200 --> 00:15:37,749
several zero as of

00:15:35,529 --> 00:15:41,259
very larger partition of the circle

00:15:37,749 --> 00:15:43,300
belonging to him because when we place

00:15:41,259 --> 00:15:45,249
our three points on the server and the

00:15:43,300 --> 00:15:49,870
hash function didn't distribute them

00:15:45,249 --> 00:15:52,660
even right so that means that du server

00:15:49,870 --> 00:15:55,899
and several zero would become what we

00:15:52,660 --> 00:16:00,579
call the hot spot it could get a higher

00:15:55,899 --> 00:16:04,180
load than the others here sever one will

00:16:00,579 --> 00:16:06,790
do almost nothing right so the hash

00:16:04,180 --> 00:16:08,439
function is very important and the

00:16:06,790 --> 00:16:11,050
choosing of the hash function is very

00:16:08,439 --> 00:16:14,529
important on the performance level

00:16:11,050 --> 00:16:20,980
because it requires computation but most

00:16:14,529 --> 00:16:23,860
importantly on distribution and so they

00:16:20,980 --> 00:16:27,430
are not perfect so the question you ask

00:16:23,860 --> 00:16:30,399
now is okay so now it's time you tell me

00:16:27,430 --> 00:16:32,829
which hash function to use there are two

00:16:30,399 --> 00:16:35,079
kinds of hash functions and on the first

00:16:32,829 --> 00:16:37,629
example I went for the most common and

00:16:35,079 --> 00:16:40,029
maybe the first like comes to mind which

00:16:37,629 --> 00:16:42,850
is md5 which is belongs to the

00:16:40,029 --> 00:16:46,899
cryptographic hash functions and you

00:16:42,850 --> 00:16:49,480
know other like Chevron and Shea X let's

00:16:46,899 --> 00:16:53,139
say these bonds are pretty standard

00:16:49,480 --> 00:16:55,689
they have a wide adoption and but they

00:16:53,139 --> 00:16:58,829
need like you said before I like you so

00:16:55,689 --> 00:17:02,170
before they need a convention to integer

00:16:58,829 --> 00:17:05,949
so that will take some computation as

00:17:02,170 --> 00:17:09,010
well on the other hand you have non

00:17:05,949 --> 00:17:11,620
cryptographic and algorithm that exists

00:17:09,010 --> 00:17:15,699
and that are optimized for key lookups

00:17:11,620 --> 00:17:20,350
those one don't include in their metal

00:17:15,699 --> 00:17:24,250
or code and cryptographic minded and

00:17:20,350 --> 00:17:27,039
algae breaking or whatever dudes we

00:17:24,250 --> 00:17:30,970
don't need to do actual and only key

00:17:27,039 --> 00:17:33,909
look at slide so the I guess the most

00:17:30,970 --> 00:17:35,559
famous of them are Mia Mia and it's v3

00:17:33,909 --> 00:17:40,929
implementation that's the most recent

00:17:35,559 --> 00:17:42,820
one and city hashes from Google they are

00:17:40,929 --> 00:17:45,880
fast since they are optimized for this

00:17:42,820 --> 00:17:48,320
so that that means and they're their

00:17:45,880 --> 00:17:52,220
direct output is a number right

00:17:48,320 --> 00:17:55,519
and the only drawback I see about them

00:17:52,220 --> 00:17:58,429
is that they need sites EDC bindings see

00:17:55,519 --> 00:18:00,559
libraries to work so they don't work

00:17:58,429 --> 00:18:04,669
like out of the box so you have to

00:18:00,559 --> 00:18:07,580
install them and on the bottom of the

00:18:04,669 --> 00:18:11,539
slide I give you a raw estimation on the

00:18:07,580 --> 00:18:16,130
speed comparison about all these ash

00:18:11,539 --> 00:18:19,690
functions Vermeil is pretty solid on the

00:18:16,130 --> 00:18:29,450
top of the list where city has 32 is the

00:18:19,690 --> 00:18:32,509
fastest of all so this reduce and help

00:18:29,450 --> 00:18:35,090
you in the balancing and now you have to

00:18:32,509 --> 00:18:38,029
reduce the load variance on your site on

00:18:35,090 --> 00:18:40,850
your circle on your ring right for this

00:18:38,029 --> 00:18:44,389
does this concept of V knows AV node is

00:18:40,850 --> 00:18:46,610
just the fact that you will take your

00:18:44,389 --> 00:18:50,690
server and duplicate it multiple times

00:18:46,610 --> 00:18:52,759
on the ring just to augment your the

00:18:50,690 --> 00:18:55,279
number of points are we on your rings

00:18:52,759 --> 00:19:00,529
and to reduce the size of all the

00:18:55,279 --> 00:19:04,389
partitions on your ring the in the

00:19:00,529 --> 00:19:10,490
consistent hashing world the best or the

00:19:04,389 --> 00:19:15,860
most acknowledged number of V nodes for

00:19:10,490 --> 00:19:19,789
a host on the ring is 160 and so it will

00:19:15,860 --> 00:19:21,649
give you a pretty solid number 30 a

00:19:19,789 --> 00:19:23,690
solid ID on the number of times that you

00:19:21,649 --> 00:19:27,019
have to duplicate your your your host on

00:19:23,690 --> 00:19:29,809
the under the ring the second one and

00:19:27,019 --> 00:19:33,649
the second aspect I want to highlight is

00:19:29,809 --> 00:19:35,990
this concept of Hector weight you can

00:19:33,649 --> 00:19:37,909
have different servers and with

00:19:35,990 --> 00:19:40,730
different capabilities or computing

00:19:37,909 --> 00:19:44,090
power on your rings and you want your

00:19:40,730 --> 00:19:46,639
ring and two you would want to adapt

00:19:44,090 --> 00:19:50,179
your load based on this as well so you

00:19:46,639 --> 00:19:53,870
can say okay this server has a weight of

00:19:50,179 --> 00:19:56,600
2 so it will be duplicated more on the

00:19:53,870 --> 00:20:01,240
it will get more Vino's on the on the on

00:19:56,600 --> 00:20:01,240
the ring to have more load spread

00:20:01,310 --> 00:20:08,850
fine so now that you all want to do

00:20:06,600 --> 00:20:10,770
consistent hashing how do you do in

00:20:08,850 --> 00:20:13,650
Python so let's see all the

00:20:10,770 --> 00:20:16,260
implementations or the most famous

00:20:13,650 --> 00:20:20,070
implementation I don't know if it's

00:20:16,260 --> 00:20:23,010
famous but anyway those ones that are

00:20:20,070 --> 00:20:25,350
existing and done so far so when I went

00:20:23,010 --> 00:20:27,870
looking into this I needed it at work

00:20:25,350 --> 00:20:30,840
and I said okay a one consistent hashing

00:20:27,870 --> 00:20:32,880
and understand the basics and I want I

00:20:30,840 --> 00:20:37,040
want to get my hands in it on the real

00:20:32,880 --> 00:20:41,850
code and on real applications right I

00:20:37,040 --> 00:20:45,540
was kind of disappointed I must say by

00:20:41,850 --> 00:20:51,360
the current and and the libraries that

00:20:45,540 --> 00:20:54,510
were present on pi PI so I did eyes I

00:20:51,360 --> 00:20:57,030
decided to go from and do my own which

00:20:54,510 --> 00:20:59,670
is you're assuring and which is the one

00:20:57,030 --> 00:21:02,370
that we have that we propose on the rest

00:20:59,670 --> 00:21:06,180
of the slides and the first ones are

00:21:02,370 --> 00:21:09,590
mostly academic implementation so they

00:21:06,180 --> 00:21:12,810
do only the hashing but you don't have

00:21:09,590 --> 00:21:23,340
easy functions to work with them I mean

00:21:12,810 --> 00:21:25,670
actual code so ah that's bad Google

00:21:23,340 --> 00:21:25,670
slides

00:21:29,940 --> 00:21:37,409
okay well here it is

00:21:40,260 --> 00:21:50,740
okay you can see it will be a problem

00:21:48,970 --> 00:21:59,620
maybe later but we'll see

00:21:50,740 --> 00:22:02,169
let's go like this okay so the ID on on

00:21:59,620 --> 00:22:05,740
on on you a shrink

00:22:02,169 --> 00:22:08,260
is that you are able to create some

00:22:05,740 --> 00:22:10,270
nodes and apply some note to each note

00:22:08,260 --> 00:22:12,460
that you will head to your rings you can

00:22:10,270 --> 00:22:15,789
add an instance associated to it which

00:22:12,460 --> 00:22:19,600
is any kind of object actually and and

00:22:15,789 --> 00:22:22,710
then here I demonstrate that you can get

00:22:19,600 --> 00:22:26,110
the national the node for the hash key

00:22:22,710 --> 00:22:29,890
for the key coconut but then if I wanted

00:22:26,110 --> 00:22:31,929
to use it I would like to be able to use

00:22:29,890 --> 00:22:35,320
it in the straightforward manner right

00:22:31,929 --> 00:22:40,210
so I would like the actual instance

00:22:35,320 --> 00:22:43,809
associated to the MNT this four node is

00:22:40,210 --> 00:22:49,090
an open file on this on the system and I

00:22:43,809 --> 00:22:51,549
would and using the HR and coconut key

00:22:49,090 --> 00:22:53,710
dot right actually points to a file

00:22:51,549 --> 00:22:56,700
descriptor so I can use it directly like

00:22:53,710 --> 00:23:00,190
this I don't have to get the node and

00:22:56,700 --> 00:23:02,620
get some other object I can use my ring

00:23:00,190 --> 00:23:06,220
in a straightforward manner that's just

00:23:02,620 --> 00:23:08,049
what I wanted to to highlight here here

00:23:06,220 --> 00:23:11,289
you see the nodes declaration with the

00:23:08,049 --> 00:23:14,470
open so each node has an open file

00:23:11,289 --> 00:23:17,590
descriptor within this declaration and

00:23:14,470 --> 00:23:19,960
then I embed this on my ring so then I

00:23:17,590 --> 00:23:22,470
can use it directly with the key that

00:23:19,960 --> 00:23:22,470
I'm looking for

00:23:22,620 --> 00:23:40,419
okay I don't know if they will be able

00:23:32,500 --> 00:23:42,450
to switch now you know okay I don't know

00:23:40,419 --> 00:23:46,600
if you have time to to see all this

00:23:42,450 --> 00:23:49,510
though I will leave it once again so HR

00:23:46,600 --> 00:23:53,260
or coconut like here you see that it

00:23:49,510 --> 00:23:55,600
points to a file descriptor and then I

00:23:53,260 --> 00:23:58,890
can use it directly and use the file

00:23:55,600 --> 00:24:04,480
descriptor methods and functions like

00:23:58,890 --> 00:24:06,640
this and then I can open the file and

00:24:04,480 --> 00:24:07,820
check that the hey coconut has been

00:24:06,640 --> 00:24:13,869
written in it

00:24:07,820 --> 00:24:13,869
[Applause]

00:24:19,240 --> 00:24:27,039
like this okay so I will switch to some

00:24:24,220 --> 00:24:29,980
example use cases before I finish this

00:24:27,039 --> 00:24:32,679
if you have a laptop a telephone of

00:24:29,980 --> 00:24:35,559
something bring it up I will have a

00:24:32,679 --> 00:24:39,340
fully working I don't know City live

00:24:35,559 --> 00:24:41,230
demo and I simulated a raffle using

00:24:39,340 --> 00:24:43,980
consistent hashing so I will ask you a

00:24:41,230 --> 00:24:47,529
question about it you and I had some

00:24:43,980 --> 00:24:49,419
raspberry zero to win so you will get a

00:24:47,529 --> 00:24:53,169
chance to win something out of this talk

00:24:49,419 --> 00:24:55,440
so if you have it prepare yourself I

00:24:53,169 --> 00:25:02,679
will give you a URL to connect to and

00:24:55,440 --> 00:25:06,039
anyway so um would like okay this force

00:25:02,679 --> 00:25:09,730
I don't know what though anyway so on

00:25:06,039 --> 00:25:15,190
some examples you have the way a way to

00:25:09,730 --> 00:25:17,200
distribute some data and on database

00:25:15,190 --> 00:25:18,850
instances you could use consistent

00:25:17,200 --> 00:25:21,870
hashing to do it properly

00:25:18,850 --> 00:25:25,779
and to be able to add or remove

00:25:21,870 --> 00:25:28,510
databases from your topology and don't

00:25:25,779 --> 00:25:31,600
so you have the minimum of mapping of

00:25:28,510 --> 00:25:34,840
data relocation to do when when you when

00:25:31,600 --> 00:25:38,500
you do that so here I have some clients

00:25:34,840 --> 00:25:41,200
a has some data and I wanted to point to

00:25:38,500 --> 00:25:45,940
a random database but in a consistent

00:25:41,200 --> 00:25:48,340
way right so here I would import your

00:25:45,940 --> 00:25:51,580
assuring I would create my node on each

00:25:48,340 --> 00:25:55,210
node at the instance of property would

00:25:51,580 --> 00:25:59,200
point to an actual my sequel connection

00:25:55,210 --> 00:26:02,230
right and I would point to every every

00:25:59,200 --> 00:26:06,279
server that I have and reference them on

00:26:02,230 --> 00:26:08,320
for usage on my ring afterwards then I

00:26:06,279 --> 00:26:11,649
would create my ring using those nodes

00:26:08,320 --> 00:26:15,700
and then I have some data and I will use

00:26:11,649 --> 00:26:18,700
the key of this data disc to select my

00:26:15,700 --> 00:26:22,360
node and to write this data into the

00:26:18,700 --> 00:26:24,549
database and for this I would use an for

00:26:22,360 --> 00:26:26,950
partition table which would be client a

00:26:24,549 --> 00:26:31,539
client by client sikhandi and then

00:26:26,950 --> 00:26:32,470
what's interesting is this one which HR

00:26:31,539 --> 00:26:35,110
partition

00:26:32,470 --> 00:26:37,330
points directly to the right server and

00:26:35,110 --> 00:26:39,640
to the right connection of the right

00:26:37,330 --> 00:26:42,790
server for the key that we are

00:26:39,640 --> 00:26:45,900
evaluating and then I could execute

00:26:42,790 --> 00:26:51,760
inside my data and then do my commit

00:26:45,900 --> 00:26:53,680
write a sample use case number two the

00:26:51,760 --> 00:26:56,440
basic is to understand here that we

00:26:53,680 --> 00:26:58,360
would be able also to to spread some

00:26:56,440 --> 00:27:02,080
disk on network i/o let's say that you

00:26:58,360 --> 00:27:05,500
have multiple masts and you they don't

00:27:02,080 --> 00:27:07,210
do clustering stuff just add some math

00:27:05,500 --> 00:27:09,360
and you want to make the most out of

00:27:07,210 --> 00:27:11,920
them so you want to distribute your

00:27:09,360 --> 00:27:13,570
workload to those nests or network nests

00:27:11,920 --> 00:27:16,840
you would mount them on your file system

00:27:13,570 --> 00:27:19,930
let's say or anything else you could

00:27:16,840 --> 00:27:22,450
open the files like this just like the

00:27:19,930 --> 00:27:24,580
example I gave earlier and then

00:27:22,450 --> 00:27:30,130
distribute your data bands on your key

00:27:24,580 --> 00:27:31,960
on the right map and on another code you

00:27:30,130 --> 00:27:34,420
could have the reader part of the code

00:27:31,960 --> 00:27:36,400
which is implemented as well here where

00:27:34,420 --> 00:27:45,790
based on key it will find the rightness

00:27:36,400 --> 00:27:48,580
whether that is written okay number

00:27:45,790 --> 00:27:50,650
three is also kind of interesting let's

00:27:48,580 --> 00:27:55,030
say that you have some piece of events

00:27:50,650 --> 00:27:57,940
or data still coming in and you want to

00:27:55,030 --> 00:28:00,040
make sure that the user ship's session

00:27:57,940 --> 00:28:02,200
usually is a good example so a user

00:28:00,040 --> 00:28:04,690
session the user generate some data

00:28:02,200 --> 00:28:08,760
based on the user ID you would like to

00:28:04,690 --> 00:28:11,950
make sure that a given worker or server

00:28:08,760 --> 00:28:15,700
is responsible for processing all these

00:28:11,950 --> 00:28:18,280
all the data of the the current user you

00:28:15,700 --> 00:28:20,500
could do it to have a greater

00:28:18,280 --> 00:28:23,920
performance so you could cache all do

00:28:20,500 --> 00:28:27,100
some clever stuff with with just making

00:28:23,920 --> 00:28:28,870
sure that the the all the in the

00:28:27,100 --> 00:28:30,970
consistent way all the data from the

00:28:28,870 --> 00:28:34,060
same user will be processed like the

00:28:30,970 --> 00:28:37,450
same worker and it will it also works

00:28:34,060 --> 00:28:40,250
for logs so let's say that you have 10

00:28:37,450 --> 00:28:42,860
machines every machine logs

00:28:40,250 --> 00:28:47,299
the user ID on their logs if you were to

00:28:42,860 --> 00:28:48,710
want to trace all what the user did he

00:28:47,299 --> 00:28:51,440
would have to gather the logs from all

00:28:48,710 --> 00:28:53,809
the machines using consistent hashing

00:28:51,440 --> 00:28:58,370
like this you would not have to do it

00:28:53,809 --> 00:29:00,919
and it would be quite easier and at

00:28:58,370 --> 00:29:03,950
least in a consistent way so it would do

00:29:00,919 --> 00:29:05,720
is best for your logs not to be spread

00:29:03,950 --> 00:29:07,879
at least so if you don't have a failure

00:29:05,720 --> 00:29:11,059
or you don't have at the new node on

00:29:07,879 --> 00:29:16,429
your topology it can be a pretty good

00:29:11,059 --> 00:29:19,429
use case as well okay all those examples

00:29:16,429 --> 00:29:22,669
and the source code of this is is online

00:29:19,429 --> 00:29:28,879
so don't really bother reading it like

00:29:22,669 --> 00:29:30,919
this on the site and I couldn't do this

00:29:28,879 --> 00:29:35,240
presentation we don't mention in caching

00:29:30,919 --> 00:29:36,919
right so I don't know how much about you

00:29:35,240 --> 00:29:41,750
maybe you can raise your hand use the

00:29:36,919 --> 00:29:46,190
Python memcache library okay

00:29:41,750 --> 00:29:49,100
pretty I'm pretty a lot of guys well

00:29:46,190 --> 00:29:51,470
actually the Python memcache server

00:29:49,100 --> 00:29:53,600
selection when you have when you create

00:29:51,470 --> 00:29:56,120
your memcache client you can specify

00:29:53,600 --> 00:29:58,460
multiple nodes to do distributed caching

00:29:56,120 --> 00:30:03,549
right well the Python memcache

00:29:58,460 --> 00:30:06,639
implementation uses the modulo nice DHT

00:30:03,549 --> 00:30:09,259
implementation so whenever one of your

00:30:06,639 --> 00:30:12,980
cache server will fail or you will have

00:30:09,259 --> 00:30:15,649
another almost all your cash will be

00:30:12,980 --> 00:30:18,470
invalidated and it will generate some

00:30:15,649 --> 00:30:23,350
load if you load this data from database

00:30:18,470 --> 00:30:26,120
or something it will be I guess bad and

00:30:23,350 --> 00:30:28,789
so you a string I do I did a simple

00:30:26,120 --> 00:30:31,700
monkey patching on the the mint in the

00:30:28,789 --> 00:30:34,700
Python memcache the library to change

00:30:31,700 --> 00:30:37,850
only change the server selection used to

00:30:34,700 --> 00:30:39,740
use consistent hashes easily so you

00:30:37,850 --> 00:30:43,700
don't have to modify the rest of your

00:30:39,740 --> 00:30:46,720
code you just do this and you get this

00:30:43,700 --> 00:30:46,720
new security

00:30:49,750 --> 00:31:00,500
so let's try to finish with a silly

00:30:55,330 --> 00:31:02,810
raffle so the idea of the raffle usually

00:31:00,500 --> 00:31:07,460
when you do a raffle you want to win

00:31:02,810 --> 00:31:10,130
right so I did two implementations of

00:31:07,460 --> 00:31:12,710
this raffle the basic concept is okay I

00:31:10,130 --> 00:31:16,990
have a list of gifts one of the gifts is

00:31:12,710 --> 00:31:20,240
a winner gift which you can see here and

00:31:16,990 --> 00:31:23,270
whenever you every time one of you will

00:31:20,240 --> 00:31:26,030
connect to the game we will simulate the

00:31:23,270 --> 00:31:30,350
adding of a node to the topology right

00:31:26,030 --> 00:31:35,600
and I have implemented this raffle using

00:31:30,350 --> 00:31:38,120
modulo or consistent hashing so if we

00:31:35,600 --> 00:31:40,460
were using the modulo operator that

00:31:38,120 --> 00:31:43,330
would mean that every time someone would

00:31:40,460 --> 00:31:46,250
connect so a new player joins the raffle

00:31:43,330 --> 00:31:52,700
the likelihood of the winner to change

00:31:46,250 --> 00:31:57,500
will be higher right so in doing so we

00:31:52,700 --> 00:32:00,110
would favor all the people who don't who

00:31:57,500 --> 00:32:02,480
are not currently winning if we were

00:32:00,110 --> 00:32:04,220
using consistent hashing every time a

00:32:02,480 --> 00:32:08,420
passive different would join the game

00:32:04,220 --> 00:32:14,030
and would have less chance of changing

00:32:08,420 --> 00:32:15,920
the winner so we will play the game but

00:32:14,030 --> 00:32:20,810
you will get to choose if we use the

00:32:15,920 --> 00:32:24,650
modulo 1 so to favor most of you let's

00:32:20,810 --> 00:32:28,100
say our randomness or you want to use

00:32:24,650 --> 00:32:32,420
the consistent server and favor whoever

00:32:28,100 --> 00:32:40,150
is going to win so you're like so let's

00:32:32,420 --> 00:32:46,820
do a hand raised hand for the modulo ok

00:32:40,150 --> 00:32:50,710
for the consistent I would almost have

00:32:46,820 --> 00:32:55,310
to count but you choose consistency so

00:32:50,710 --> 00:32:58,070
yeah ok I'm surprised I don't know ok so

00:32:55,310 --> 00:33:05,060
the concept of the game is is clear it's

00:32:58,070 --> 00:33:13,420
ok alright so this is the URL so you can

00:33:05,060 --> 00:33:13,420
connect now k EP 17 dot and b ly dot Co

00:33:16,510 --> 00:33:20,450
you have it on top of the screen you see

00:33:19,310 --> 00:33:26,480
it over there

00:33:20,450 --> 00:33:29,150
ok right yeah I know I need to run

00:33:26,480 --> 00:33:34,460
either modulo consistent server is going

00:33:29,150 --> 00:33:43,150
to work now right but it was fair play I

00:33:34,460 --> 00:33:46,150
had you have to choose first I don't see

00:33:43,150 --> 00:33:46,150
ok

00:33:49,210 --> 00:34:00,340
I guess I lost connection that's why the

00:33:51,510 --> 00:34:03,160
stuffs failed before anyway okay

00:34:00,340 --> 00:34:06,910
consistent is here the nodes only ten

00:34:03,160 --> 00:34:10,740
toes already ten participants thirty the

00:34:06,910 --> 00:34:17,500
ID of the winner is shown over there

00:34:10,740 --> 00:34:20,140
fifty nine really guys so here for those

00:34:17,500 --> 00:34:22,000
who don't have a phone all are not

00:34:20,140 --> 00:34:24,940
playing right now you can see what the

00:34:22,000 --> 00:34:27,040
other people are seeing so basically

00:34:24,940 --> 00:34:30,490
here I'm not winning right I don't have

00:34:27,040 --> 00:34:34,180
the winner gif displayed so most of you

00:34:30,490 --> 00:34:35,890
don't have a funny gift playing so even

00:34:34,180 --> 00:34:41,430
if you're losing here at least laughing

00:34:35,890 --> 00:34:44,200
but anyway 93 I wasn't expecting 93

00:34:41,430 --> 00:34:47,620
people playing the game actually so it's

00:34:44,200 --> 00:34:49,060
a it's a nice figure 99 I don't know

00:34:47,620 --> 00:34:51,550
who's the winner who's the current

00:34:49,060 --> 00:34:56,890
winner here

00:34:51,550 --> 00:35:02,620
did it change a lot did you win the

00:34:56,890 --> 00:35:07,510
first time and it didn't change now okay

00:35:02,620 --> 00:35:10,300
so you 101 so now people are trying and

00:35:07,510 --> 00:35:14,080
I figuring out a way to abuse this I

00:35:10,300 --> 00:35:15,850
guess I thought of it already so I have

00:35:14,080 --> 00:35:20,410
in the code there are some safety

00:35:15,850 --> 00:35:22,120
measure anyway okay so I want it just to

00:35:20,410 --> 00:35:26,410
show a quickie on the two

00:35:22,120 --> 00:35:30,210
implementations on the top is the

00:35:26,410 --> 00:35:34,300
modular one so the modular one uses a

00:35:30,210 --> 00:35:38,080
simple list to do this the other one

00:35:34,300 --> 00:35:42,460
uses the ash ring obviously when you add

00:35:38,080 --> 00:35:44,980
a node on a consistent on the consistent

00:35:42,460 --> 00:35:46,780
implementation it's pretty easy you see

00:35:44,980 --> 00:35:48,580
that it comes because it becomes a bit

00:35:46,780 --> 00:35:53,280
more complex when using the modular one

00:35:48,580 --> 00:35:55,990
and but still it's not it's not insane I

00:35:53,280 --> 00:35:58,210
have a node cleaner for when people are

00:35:55,990 --> 00:36:00,970
leaving the game you see that people are

00:35:58,210 --> 00:36:02,860
leaving the games of the likelihood is

00:36:00,970 --> 00:36:08,530
still changing so the winner maybe

00:36:02,860 --> 00:36:11,260
changing still and and the node

00:36:08,530 --> 00:36:14,800
selection as well here you can see the

00:36:11,260 --> 00:36:17,410
winner selection and when it's on

00:36:14,800 --> 00:36:22,450
consistent it's pretty easy I passed the

00:36:17,410 --> 00:36:26,560
win URL to the Rings so the renew I

00:36:22,450 --> 00:36:30,490
passed the URL of the winner gifts and I

00:36:26,560 --> 00:36:32,970
get the winning node itself it's as

00:36:30,490 --> 00:36:36,340
simple as that

00:36:32,970 --> 00:36:39,790
and that's all for me

00:36:36,340 --> 00:36:41,890
thanks for playing thankful for being

00:36:39,790 --> 00:36:45,130
there if you have any question I'd be

00:36:41,890 --> 00:36:50,520
happy to to answer it so you're the

00:36:45,130 --> 00:36:50,520
winner still yes

00:36:50,760 --> 00:37:00,910
no it just changed it's okay you'll win

00:36:58,110 --> 00:37:03,940
anyway okay the source code and all the

00:37:00,910 --> 00:37:06,910
rest of the stuff is is there it's the

00:37:03,940 --> 00:37:10,630
the libraries on pi PI I welcome any

00:37:06,910 --> 00:37:13,990
contribution obviously so I hope that

00:37:10,630 --> 00:37:17,800
you understand that the hash tables even

00:37:13,990 --> 00:37:20,290
Python dicks and distributed hash tables

00:37:17,800 --> 00:37:22,150
and now why or what you could do with

00:37:20,290 --> 00:37:25,410
consistent hashing and the type of

00:37:22,150 --> 00:37:25,410
programming sauce thank

00:37:28,610 --> 00:37:42,920
oh yeah so thank you very much and any

00:37:37,370 --> 00:37:46,310
questions I think uh so anyway I just

00:37:42,920 --> 00:37:49,190
have a small comment and so this is all

00:37:46,310 --> 00:37:51,130
really cool and I'd want to discourage

00:37:49,190 --> 00:37:54,340
you from doing this but actually Python

00:37:51,130 --> 00:37:57,560
memory mapping is improved recently and

00:37:54,340 --> 00:38:00,710
they're the first class to show that how

00:37:57,560 --> 00:38:02,570
Python dictionaries internally stored in

00:38:00,710 --> 00:38:05,270
the memo is no longer true for Python

00:38:02,570 --> 00:38:06,680
three six and I really recommend for

00:38:05,270 --> 00:38:09,980
everybody in the room if you like this

00:38:06,680 --> 00:38:13,040
talk watch the talk by Raymond Hettinger

00:38:09,980 --> 00:38:16,790
from Python 2017 about dictionaries

00:38:13,040 --> 00:38:18,500
because Python physics really improves

00:38:16,790 --> 00:38:21,230
the situation and your dictionaries are

00:38:18,500 --> 00:38:23,420
going to be sliced by half from the

00:38:21,230 --> 00:38:25,160
memory so that's a really good

00:38:23,420 --> 00:38:26,920
improvement if you don't want to have a

00:38:25,160 --> 00:38:31,370
distributed system and we just want to

00:38:26,920 --> 00:38:35,200
improve your own performance memory

00:38:31,370 --> 00:38:35,200
performance of your own single process

00:38:35,320 --> 00:38:40,600
thanks for this insightful comment yeah

00:38:37,940 --> 00:38:40,600
you're right

00:38:51,360 --> 00:38:58,030
hi I mean thanks for the talk you

00:38:55,240 --> 00:39:02,380
mentioned replicating nodes on the ring

00:38:58,030 --> 00:39:04,869
to kind of reduce probability that you

00:39:02,380 --> 00:39:06,610
get an even distribution how do you

00:39:04,869 --> 00:39:09,570
distribute the nodes on the ring because

00:39:06,610 --> 00:39:12,310
it seems to me that if you do this in a

00:39:09,570 --> 00:39:14,680
predictable way or with the same

00:39:12,310 --> 00:39:16,570
distance everywhere you don't improve

00:39:14,680 --> 00:39:20,340
the change the distribution at all can

00:39:16,570 --> 00:39:23,350
you elaborate on this how this works I

00:39:20,340 --> 00:39:25,260
you go back to is like a little eco I

00:39:23,350 --> 00:39:27,760
don't go back to the slide where you

00:39:25,260 --> 00:39:34,780
distribute or repeat the nodes on the

00:39:27,760 --> 00:39:37,690
ring yeah this one yes can you explain

00:39:34,780 --> 00:39:39,150
how this improves the situation because

00:39:37,690 --> 00:39:43,420
it seems to me that you like just

00:39:39,150 --> 00:39:48,340
replicate the same thing five times yep

00:39:43,420 --> 00:39:55,840
well if you compare this to this this

00:39:48,340 --> 00:39:58,950
improve the situation doesn't it like if

00:39:55,840 --> 00:40:03,369
you take the slice of each node it's

00:39:58,950 --> 00:40:07,900
lighter now than it was like this so if

00:40:03,369 --> 00:40:10,720
here I took several zero and several one

00:40:07,900 --> 00:40:15,760
and seven two and for each of them I

00:40:10,720 --> 00:40:18,100
would add to their name - 0 - 1 - 2 - 3

00:40:15,760 --> 00:40:21,580
and then I would hatch this again and

00:40:18,100 --> 00:40:24,070
place the result that would physic that

00:40:21,580 --> 00:40:27,100
would logically point to the same server

00:40:24,070 --> 00:40:29,470
but still would be a different point on

00:40:27,100 --> 00:40:32,770
the ring I would reduce the load

00:40:29,470 --> 00:40:40,640
variance of on my ring by reducing the

00:40:32,770 --> 00:40:49,790
partitions on the wondering right thanks

00:40:40,640 --> 00:40:55,280
for letting me clarify this okay how do

00:40:49,790 --> 00:41:00,380
you manage the variability of imbalance

00:40:55,280 --> 00:41:04,100
I mean even using radicals do you have

00:41:00,380 --> 00:41:08,600
an estimate of imbalance between the

00:41:04,100 --> 00:41:15,170
most loaded node and the least knotted

00:41:08,600 --> 00:41:17,990
loaded node using this library so she

00:41:15,170 --> 00:41:20,420
the value that you expect it's not

00:41:17,990 --> 00:41:24,380
dependent on the library implementation

00:41:20,420 --> 00:41:26,150
is dependent on the hash function so if

00:41:24,380 --> 00:41:28,790
you it depends on the hash function that

00:41:26,150 --> 00:41:33,920
you will use and basically the hash

00:41:28,790 --> 00:41:35,720
function as and in a range right and the

00:41:33,920 --> 00:41:37,880
range of your hash function will be the

00:41:35,720 --> 00:41:40,100
range of your ring of the total

00:41:37,880 --> 00:41:41,540
possibilities of your ring so if you

00:41:40,100 --> 00:41:44,270
know all the data points that you have

00:41:41,540 --> 00:41:46,160
on your ring and you're assuring

00:41:44,270 --> 00:41:48,830
provides a way to have this with the

00:41:46,160 --> 00:41:52,700
print continuum that I showcase you can

00:41:48,830 --> 00:41:55,850
calculate the part the partitions of

00:41:52,700 --> 00:41:59,630
each node and then you can know for sure

00:41:55,850 --> 00:42:03,640
based on your hash function how will be

00:41:59,630 --> 00:42:03,640
the load of each point of each cell out

00:42:04,930 --> 00:42:10,280
okay I have actually two questions

00:42:07,220 --> 00:42:12,260
regarding the wing at first I mean why

00:42:10,280 --> 00:42:13,670
do I need to use the hash function to

00:42:12,260 --> 00:42:15,710
distribute the node kind of just

00:42:13,670 --> 00:42:17,780
distribute them evenly or so that I

00:42:15,710 --> 00:42:20,000
split the server which has the most load

00:42:17,780 --> 00:42:22,010
current even at a new one so what is the

00:42:20,000 --> 00:42:24,230
benefit of having the hash function set

00:42:22,010 --> 00:42:27,170
of just giving them evenly distributed

00:42:24,230 --> 00:42:33,050
points and the second one is why is it a

00:42:27,170 --> 00:42:35,420
ring and not a line or whatever so I

00:42:33,050 --> 00:42:37,280
understood the second question the first

00:42:35,420 --> 00:42:39,980
one with vehicle I'm sorry I didn't

00:42:37,280 --> 00:42:42,350
understand it at all by why the ring and

00:42:39,980 --> 00:42:47,420
instead of a line I guess it's for

00:42:42,350 --> 00:42:49,880
representation for us and let and on the

00:42:47,420 --> 00:42:51,840
mathematics behind it it makes sense on

00:42:49,880 --> 00:42:56,610
on the ring on the ring

00:42:51,840 --> 00:43:00,060
because it's it calculates angles to

00:42:56,610 --> 00:43:03,420
represent partitions so it's on the

00:43:00,060 --> 00:43:06,830
paper on the aconite paper so it would

00:43:03,420 --> 00:43:11,220
be better like it's like a trigonometric

00:43:06,830 --> 00:43:13,620
rank checker sorry so it makes more

00:43:11,220 --> 00:43:15,690
sense on this and on the first question

00:43:13,620 --> 00:43:18,450
and so maybe you can catch me late at

00:43:15,690 --> 00:43:21,840
the end because with the echo I didn't

00:43:18,450 --> 00:43:24,660
understand I'm sorry okay

00:43:21,840 --> 00:43:25,420
I know a so okay thanks again Alexis

00:43:24,660 --> 00:43:31,300
thanks

00:43:25,420 --> 00:43:31,300

YouTube URL: https://www.youtube.com/watch?v=erINlrgygEk


