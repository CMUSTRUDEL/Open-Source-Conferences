Title: Kyle Knapp - Serverless Applications with Chalice
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Serverless Applications with Chalice
[EuroPython 2017 - Talk - 2017-07-11 - PythonAnywhere Room]
[Rimini, Italy]

Serverless computing: it is the practice of building and running services and applications without having to worry about provisioning and managing servers. Serverless computing has been a popular topic the past couple years, and with respect to Python, there have been various different frameworks and tools released for developing and managing your Python serverless applications. This talk will focus on developing and managing your serverless applications with chalice (https://github.com/awslabs/chalice), a python serverless microframework for AWS. Discussion points for this talk will include, but not be limited to:

•   Overview of serverless applications

•   Best practices in writing a serverless application

•    Basic usage and core features of chalice

•   Writing complete, production-level applications using chalice

•   Managing and maintaining serverless applications using chalice tooling

By the end of the talk, audience members should have a better understanding of serverless computing and how to use chalice to develop and maintain serverless applications.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,330 --> 00:00:08,950
all right hi everyone my name is Kyle

00:00:06,850 --> 00:00:11,410
Knapp and I'm a software developer at

00:00:08,950 --> 00:00:14,080
Amazon Web Services where I primarily

00:00:11,410 --> 00:00:16,509
focus on focus on developing Python

00:00:14,080 --> 00:00:19,930
client side tooling such as Davis CLI

00:00:16,509 --> 00:00:22,570
Davis SDK for Python also known as boa

00:00:19,930 --> 00:00:25,029
three and a Python micro framework for

00:00:22,570 --> 00:00:26,740
developing service applications known as

00:00:25,029 --> 00:00:28,240
chalice and today what I'm going to talk

00:00:26,740 --> 00:00:30,010
to you about is how we can go about

00:00:28,240 --> 00:00:33,850
writing service applications using

00:00:30,010 --> 00:00:35,800
chalice to start what I want to do is go

00:00:33,850 --> 00:00:38,290
over an outline of what I'm going to

00:00:35,800 --> 00:00:40,089
talk about first I'm going to give an

00:00:38,290 --> 00:00:41,949
introduction into service applications

00:00:40,089 --> 00:00:43,870
we only talk about what they are why you

00:00:41,949 --> 00:00:45,370
care about them I'll give an

00:00:43,870 --> 00:00:46,690
introduction to chalice so getting

00:00:45,370 --> 00:00:49,000
started with chalice and some of the

00:00:46,690 --> 00:00:50,290
core concepts and then I'm going to go

00:00:49,000 --> 00:00:51,850
ahead and actually have a sample

00:00:50,290 --> 00:00:53,589
application show you how you can build

00:00:51,850 --> 00:00:57,430
it from the ground up using chalice

00:00:53,589 --> 00:00:59,830
features so before I talk about what

00:00:57,430 --> 00:01:01,809
exactly a service application is let me

00:00:59,830 --> 00:01:04,750
talk about why you care about it in the

00:01:01,809 --> 00:01:06,820
benefits of service applications to

00:01:04,750 --> 00:01:08,740
start service applications mean you're

00:01:06,820 --> 00:01:11,250
not managing or provisioning servers so

00:01:08,740 --> 00:01:13,630
that's less of a DevOps load for you

00:01:11,250 --> 00:01:15,310
next you're only paying for the

00:01:13,630 --> 00:01:16,570
execution runtime for your code so if

00:01:15,310 --> 00:01:18,370
you're managing on a server you're still

00:01:16,570 --> 00:01:20,200
paying for the server to be up and

00:01:18,370 --> 00:01:21,250
running but even if there's no code

00:01:20,200 --> 00:01:24,730
running you're still paying that cost

00:01:21,250 --> 00:01:26,890
and finally you get scalability so in

00:01:24,730 --> 00:01:28,720
terms of service applications are

00:01:26,890 --> 00:01:30,910
usually hosted by a service and it

00:01:28,720 --> 00:01:31,780
handles all of the scaling for you so

00:01:30,910 --> 00:01:34,210
you don't have to worry about load

00:01:31,780 --> 00:01:36,250
balancing to meet the requests needs of

00:01:34,210 --> 00:01:39,640
your gear sitting for your service

00:01:36,250 --> 00:01:42,100
application so now let me talk about

00:01:39,640 --> 00:01:43,690
what exactly a service application is so

00:01:42,100 --> 00:01:45,970
here we have just a client and a server

00:01:43,690 --> 00:01:48,430
and on the server we just have a simple

00:01:45,970 --> 00:01:50,560
hello world function running when the

00:01:48,430 --> 00:01:52,630
client sends a request to the server it

00:01:50,560 --> 00:01:55,810
will go ahead and run the code and reply

00:01:52,630 --> 00:01:57,670
back with hello world so with a service

00:01:55,810 --> 00:02:00,100
application this all completely goes

00:01:57,670 --> 00:02:02,590
away and it gets replaced by a service

00:02:00,100 --> 00:02:04,330
such as a Debus lambda it was planted as

00:02:02,590 --> 00:02:06,790
a service for me for hosting your

00:02:04,330 --> 00:02:09,190
service applications and what happens

00:02:06,790 --> 00:02:11,620
here is you have a bunch of code you

00:02:09,190 --> 00:02:13,569
upload it to a Debus lambda and a

00:02:11,620 --> 00:02:14,830
designer will store that code for you so

00:02:13,569 --> 00:02:17,849
that when you make a request status

00:02:14,830 --> 00:02:19,650
lambda oh go ahead and execute that code

00:02:17,849 --> 00:02:21,719
and return the response hello world back

00:02:19,650 --> 00:02:23,879
for you so the key part here is you

00:02:21,719 --> 00:02:25,530
don't own the server you're not managing

00:02:23,879 --> 00:02:27,239
it or anything it's all handled by a

00:02:25,530 --> 00:02:29,359
Jewess lambda it'll handle all the

00:02:27,239 --> 00:02:31,769
scaling for you as well

00:02:29,359 --> 00:02:33,569
so now with that brief introduction of

00:02:31,769 --> 00:02:36,959
what service applications are let me

00:02:33,569 --> 00:02:39,930
talk about chalice so chalice is an

00:02:36,959 --> 00:02:42,840
open-source Python micro framework for

00:02:39,930 --> 00:02:45,209
managing service applications on ADA by

00:02:42,840 --> 00:02:46,859
lambda and integrating those service

00:02:45,209 --> 00:02:50,040
applications with other resources in

00:02:46,859 --> 00:02:51,930
your 80s cloud so to get a better idea

00:02:50,040 --> 00:02:53,639
of what chalice can do let's go over a

00:02:51,930 --> 00:02:56,069
common use case you may use chalice for

00:02:53,639 --> 00:02:59,939
and that comes with REST API s

00:02:56,069 --> 00:03:01,949
so with a typical REST API you send a

00:02:59,939 --> 00:03:05,519
resource for web requests so you're

00:03:01,949 --> 00:03:08,370
sending a get to the root path of the

00:03:05,519 --> 00:03:11,189
API and you'll get a Rach TTP response

00:03:08,370 --> 00:03:14,549
back or maybe you send a get request to

00:03:11,189 --> 00:03:16,650
the resources component and you get all

00:03:14,549 --> 00:03:17,639
your resources back from the REST API or

00:03:16,650 --> 00:03:18,989
maybe you want to change the method

00:03:17,639 --> 00:03:22,169
maybe you want to put a specific

00:03:18,989 --> 00:03:25,069
resource into your API and apply back

00:03:22,169 --> 00:03:28,470
with the HTTP response so the way that

00:03:25,069 --> 00:03:30,329
it takes Adria's lambda it uses as the

00:03:28,470 --> 00:03:32,669
backend your core functionality for your

00:03:30,329 --> 00:03:35,040
REST API and another service called

00:03:32,669 --> 00:03:36,419
Amazon API gateway which is essentially

00:03:35,040 --> 00:03:37,799
the front door for your service

00:03:36,419 --> 00:03:39,329
application it's handling the HTTP

00:03:37,799 --> 00:03:41,579
request sending the HTTP responses

00:03:39,329 --> 00:03:43,709
handling the throttling and any

00:03:41,579 --> 00:03:45,540
authentication for you so now if you

00:03:43,709 --> 00:03:48,239
send an HTTP request here it'll get sent

00:03:45,540 --> 00:03:50,009
to Amazon API gateway Amazon API gateway

00:03:48,239 --> 00:03:52,049
will then invoke your lambda function or

00:03:50,009 --> 00:03:54,000
run your code and return it responds

00:03:52,049 --> 00:03:59,340
back to Amazon API gateway giving you an

00:03:54,000 --> 00:04:01,139
HTTP response back ok so now if you kind

00:03:59,340 --> 00:04:02,340
of take a look at the simplified version

00:04:01,139 --> 00:04:04,739
of how it's set up

00:04:02,340 --> 00:04:07,469
it looks pretty simple it's just a

00:04:04,739 --> 00:04:08,639
two-way directional relationship but in

00:04:07,469 --> 00:04:10,739
reality if you're just go ahead and

00:04:08,639 --> 00:04:12,689
start this from scratch it's a little

00:04:10,739 --> 00:04:14,699
more complicated than that and reality

00:04:12,689 --> 00:04:16,469
you need to worry about setting if and I

00:04:14,699 --> 00:04:17,880
am role for your lambda function so you

00:04:16,469 --> 00:04:19,799
know what permissions you have you need

00:04:17,880 --> 00:04:21,509
to actually kick your code dependencies

00:04:19,799 --> 00:04:23,250
if it up and set it to create a function

00:04:21,509 --> 00:04:26,130
you have to create a swagger document to

00:04:23,250 --> 00:04:29,070
create your REST API for Amazon API

00:04:26,130 --> 00:04:30,389
gateway and link it all together with by

00:04:29,070 --> 00:04:31,529
adding permissions for Amazon API

00:04:30,389 --> 00:04:33,959
gateway

00:04:31,529 --> 00:04:35,339
go ahead and invoke it and create a

00:04:33,959 --> 00:04:37,799
deployment stick and you hit it with an

00:04:35,339 --> 00:04:39,929
HTP request the nice part about chalice

00:04:37,799 --> 00:04:41,939
though is that you don't really have to

00:04:39,929 --> 00:04:43,319
worry about this if you're just by hand

00:04:41,939 --> 00:04:44,999
you have to go to the console you have

00:04:43,319 --> 00:04:46,679
use an SDK or CloudFormation template

00:04:44,999 --> 00:04:47,909
but chalice handles this off for you

00:04:46,679 --> 00:04:51,029
allowing you to focus on the actual

00:04:47,909 --> 00:04:53,429
Python aspect of your application so

00:04:51,029 --> 00:04:55,319
what I have here is a video of how you

00:04:53,429 --> 00:04:57,089
can kind of get started of chalice the

00:04:55,319 --> 00:04:58,829
Wi-Fi has been a little spotty so I was

00:04:57,089 --> 00:05:01,049
gonna do a live demo but in order to

00:04:58,829 --> 00:05:04,069
save some time if in case things don't

00:05:01,049 --> 00:05:07,109
go as planned have this video being ran

00:05:04,069 --> 00:05:08,959
so first you need a pip install chalice

00:05:07,109 --> 00:05:11,849
by using pip install d'esprit

00:05:08,959 --> 00:05:15,929
right now shell this is 1.0 beta so you

00:05:11,849 --> 00:05:17,609
need to use the pre flag and once you do

00:05:15,929 --> 00:05:19,079
that you could go ahead and run chalice

00:05:17,609 --> 00:05:20,789
new project and now would get you

00:05:19,079 --> 00:05:23,069
started with a new brand new chalice

00:05:20,789 --> 00:05:24,689
project application it will create a new

00:05:23,069 --> 00:05:27,239
directory and inside the directories

00:05:24,689 --> 00:05:29,819
you'll see a two files there's an app

00:05:27,239 --> 00:05:31,679
dot py in requirement text the

00:05:29,819 --> 00:05:33,989
requirement text initially is empty to

00:05:31,679 --> 00:05:35,549
start and that is where you specify all

00:05:33,989 --> 00:05:37,829
the dependencies for your child SAP

00:05:35,549 --> 00:05:39,869
location so what happens if chalice is

00:05:37,829 --> 00:05:41,159
that if you specify dependency in your

00:05:39,869 --> 00:05:43,259
requirements of text it will go ahead

00:05:41,159 --> 00:05:46,110
and download the dependency when setting

00:05:43,259 --> 00:05:47,939
your deployment package to lambda so the

00:05:46,110 --> 00:05:50,639
second file the app dot py file is where

00:05:47,939 --> 00:05:52,110
all your core functionality exists if I

00:05:50,639 --> 00:05:54,629
open it up right here you'll notice

00:05:52,110 --> 00:05:56,129
that's actually very similar to if

00:05:54,629 --> 00:05:58,649
you're familiar with flask where you

00:05:56,129 --> 00:06:01,019
create an app object and you go ahead

00:05:58,649 --> 00:06:02,969
and specify routes for that app so right

00:06:01,019 --> 00:06:05,609
here we're registering a route route so

00:06:02,969 --> 00:06:08,339
that if HTTP request is sent to it does

00:06:05,609 --> 00:06:11,219
it get the index function would get ran

00:06:08,339 --> 00:06:13,199
and return HelloWorld so let's go ahead

00:06:11,219 --> 00:06:17,789
and actually just quickly just deploy

00:06:13,199 --> 00:06:19,649
this app using a chalice so as it's just

00:06:17,789 --> 00:06:21,359
a chalice app is getting deployed once I

00:06:19,649 --> 00:06:22,709
go onto mentioned is well this

00:06:21,359 --> 00:06:24,269
application is just sending hello world

00:06:22,709 --> 00:06:25,949
this is a production ready application

00:06:24,269 --> 00:06:27,149
you can you can send as many requests as

00:06:25,949 --> 00:06:28,769
you want and the nativist lambda will

00:06:27,149 --> 00:06:34,049
scale it up for you and be able to

00:06:28,769 --> 00:06:36,239
handle any incoming requests so once

00:06:34,049 --> 00:06:38,189
it's going to be done deploying it will

00:06:36,239 --> 00:06:39,329
go ahead and there's one more thing

00:06:38,189 --> 00:06:43,889
we're going to need in order to start

00:06:39,329 --> 00:06:45,389
hitting the API and that is a Python

00:06:43,889 --> 00:06:46,680
library called HTTP

00:06:45,389 --> 00:06:48,479
that's pretty much a command-line tool

00:06:46,680 --> 00:06:51,770
for making HP crust from the command

00:06:48,479 --> 00:06:55,319
line so if I go ahead and actually

00:06:51,770 --> 00:06:59,849
crunch l0 I can see what my API URL is

00:06:55,319 --> 00:07:02,189
again go ahead and copy it and send a

00:06:59,849 --> 00:07:05,639
get request to my API and you can see

00:07:02,189 --> 00:07:07,409
returns back hello world cool so now

00:07:05,639 --> 00:07:08,969
what it can do is if I want to add more

00:07:07,409 --> 00:07:11,430
routes to my application I can go into

00:07:08,969 --> 00:07:13,080
my app dot py file and go ahead and add

00:07:11,430 --> 00:07:15,000
new routes so for example I'm going to

00:07:13,080 --> 00:07:17,969
go ahead and add the food route to this

00:07:15,000 --> 00:07:20,039
application so that if a get request is

00:07:17,969 --> 00:07:27,810
made to foo I will go ahead and run the

00:07:20,039 --> 00:07:30,360
foo function that will return foo bar so

00:07:27,810 --> 00:07:35,360
now once I have that updated I can go

00:07:30,360 --> 00:07:37,830
ahead and run jealous deploy again and

00:07:35,360 --> 00:07:39,870
that will update my lambda function and

00:07:37,830 --> 00:07:47,400
I should be ready to go in and actually

00:07:39,870 --> 00:07:49,259
start using this new update to my API so

00:07:47,400 --> 00:07:52,050
now I'm going to get my URL real quick

00:07:49,259 --> 00:07:54,210
because I don't have it memorized and I

00:07:52,050 --> 00:07:57,270
go ahead and paste that and add the food

00:07:54,210 --> 00:07:59,430
component to my path and from there what

00:07:57,270 --> 00:08:01,550
I'll get is the expected response I want

00:07:59,430 --> 00:08:04,740
back so it should return the foo bar

00:08:01,550 --> 00:08:06,029
which it does so the two things I really

00:08:04,740 --> 00:08:08,520
hope you guys got out of this

00:08:06,029 --> 00:08:10,050
demonstration was how quickly you can

00:08:08,520 --> 00:08:11,879
get you hit the ground running using a

00:08:10,050 --> 00:08:13,379
chaste application to start using just

00:08:11,879 --> 00:08:15,629
chalice new project and chalice deploy

00:08:13,379 --> 00:08:17,430
and also the fact that child is handing

00:08:15,629 --> 00:08:18,449
all of the ABS resource set up for you

00:08:17,430 --> 00:08:21,029
so don't actually have to worry about

00:08:18,449 --> 00:08:25,500
AWS you just have to focus on the Python

00:08:21,029 --> 00:08:27,120
specific logic of your application so

00:08:25,500 --> 00:08:29,039
now what I'm going to do is go sum of a

00:08:27,120 --> 00:08:31,139
key components of a childís application

00:08:29,039 --> 00:08:34,380
and by going over the sample app on the

00:08:31,139 --> 00:08:36,539
right so what I have here to start is a

00:08:34,380 --> 00:08:37,890
app object that I create and I register

00:08:36,539 --> 00:08:39,959
a bunch of routes to it so let's take

00:08:37,890 --> 00:08:41,940
some sample HTTP requests and see how

00:08:39,959 --> 00:08:44,490
the app reacts so here we're just

00:08:41,940 --> 00:08:46,560
sending a get request to the route path

00:08:44,490 --> 00:08:48,540
and what that will happen is I'll match

00:08:46,560 --> 00:08:50,120
up with this route and therefore when it

00:08:48,540 --> 00:08:53,610
was slammed it gets invoked it will run

00:08:50,120 --> 00:08:55,230
the index function once it runs it

00:08:53,610 --> 00:08:57,750
return back hello world to the end user

00:08:55,230 --> 00:08:59,340
and Amazon API gateway afford an HTTP

00:08:57,750 --> 00:09:01,710
response back

00:08:59,340 --> 00:09:05,010
saying hello world so now let's take a

00:09:01,710 --> 00:09:07,050
get to the resource hello this will

00:09:05,010 --> 00:09:09,750
match up with this route here and run

00:09:07,050 --> 00:09:11,160
the hello euro Python function and once

00:09:09,750 --> 00:09:15,630
it's run or return hello Europe I the

00:09:11,160 --> 00:09:16,440
Sun as a HTTP response back okay so now

00:09:15,630 --> 00:09:19,320
let's like to look at something

00:09:16,440 --> 00:09:21,690
different now so with this request right

00:09:19,320 --> 00:09:22,920
here you'll notice that the exact path

00:09:21,690 --> 00:09:27,090
doesn't actually match up with any of

00:09:22,920 --> 00:09:28,350
the literals here and app py file what

00:09:27,090 --> 00:09:29,970
will happen is that actually I matches

00:09:28,350 --> 00:09:31,890
up with this route and that's because if

00:09:29,970 --> 00:09:33,990
you provide a curly bracket in your path

00:09:31,890 --> 00:09:35,880
it means it's a variable so you can

00:09:33,990 --> 00:09:37,410
provide any value you want in our case

00:09:35,880 --> 00:09:40,140
we're just providing Kyle as the

00:09:37,410 --> 00:09:42,060
variable so as a result lambo function

00:09:40,140 --> 00:09:44,540
will lambda will run the hello name

00:09:42,060 --> 00:09:46,920
function returning back using the name

00:09:44,540 --> 00:09:49,080
provided and the same parameter is

00:09:46,920 --> 00:09:53,130
passed in using the variable in the path

00:09:49,080 --> 00:09:54,900
and as a result oh the value of name

00:09:53,130 --> 00:09:57,690
will be Kyle and go ahead and return

00:09:54,900 --> 00:10:00,030
hello Kyle back to then users HTTP

00:09:57,690 --> 00:10:02,820
response so the final one I want to talk

00:10:00,030 --> 00:10:05,790
about is the post so with the post what

00:10:02,820 --> 00:10:08,310
happens you'll notice that that uses the

00:10:05,790 --> 00:10:10,590
resource hello but it doesn't use the

00:10:08,310 --> 00:10:12,990
second from the top function that's

00:10:10,590 --> 00:10:15,480
because it's a post and the route

00:10:12,990 --> 00:10:17,640
registered only allows for a post if you

00:10:15,480 --> 00:10:19,380
use in the method keyword argh so by

00:10:17,640 --> 00:10:21,810
default if you don't specify any methods

00:10:19,380 --> 00:10:23,610
it will only allow forgets so as a

00:10:21,810 --> 00:10:25,830
result and this long API gateway will

00:10:23,610 --> 00:10:28,050
invoke this lambda function with this of

00:10:25,830 --> 00:10:29,370
the post function involved if you're

00:10:28,050 --> 00:10:31,290
looking into the post function you'll

00:10:29,370 --> 00:10:33,570
notice that it uses app current request

00:10:31,290 --> 00:10:35,790
that refers to the HTTP request that

00:10:33,570 --> 00:10:37,170
triggered the lambda function and you

00:10:35,790 --> 00:10:39,210
can get properties other quests such as

00:10:37,170 --> 00:10:41,670
the JSON body so for example you get

00:10:39,210 --> 00:10:43,410
you'll have the value JSON body when

00:10:41,670 --> 00:10:45,960
you're actually invoking your function

00:10:43,410 --> 00:10:48,240
so now that when you return you'll

00:10:45,960 --> 00:10:52,470
notice that the JSON body matches up

00:10:48,240 --> 00:10:54,030
with the actual request cool so that was

00:10:52,470 --> 00:10:55,980
just a brief introduction Challis let's

00:10:54,030 --> 00:10:57,960
talk about the main points I covered one

00:10:55,980 --> 00:10:59,010
in order to start a new chalice project

00:10:57,960 --> 00:11:01,230
you just need to run the chalice new

00:10:59,010 --> 00:11:02,880
project command to get to you lets you

00:11:01,230 --> 00:11:05,520
hit the rig on running and immediately

00:11:02,880 --> 00:11:07,500
deploy that shell the savoy if you make

00:11:05,520 --> 00:11:08,790
any changes to your application all you

00:11:07,500 --> 00:11:10,290
need to do is run chalice deploy you can

00:11:08,790 --> 00:11:13,199
immediately start using it

00:11:10,290 --> 00:11:13,919
sending HTTP requests to it app dot

00:11:13,199 --> 00:11:15,899
route

00:11:13,919 --> 00:11:17,699
that allows you to run specific

00:11:15,899 --> 00:11:20,639
functions based off the HTTP request

00:11:17,699 --> 00:11:23,249
path or method that you sent and finally

00:11:20,639 --> 00:11:24,540
there is the current request property

00:11:23,249 --> 00:11:28,289
which allows you to access a current

00:11:24,540 --> 00:11:30,389
request that triggered your function so

00:11:28,289 --> 00:11:31,709
let's talk about the sample application

00:11:30,389 --> 00:11:34,559
part this is the meaty part of the talk

00:11:31,709 --> 00:11:37,859
in my sample application what I did was

00:11:34,559 --> 00:11:39,749
I created a trivia app so here is a

00:11:37,859 --> 00:11:41,220
video of me running my trivia app if

00:11:39,749 --> 00:11:44,869
you're interested you can go to that URL

00:11:41,220 --> 00:11:47,009
it's a public s3 object or a bucket and

00:11:44,869 --> 00:11:49,919
I'm going to go ahead and kind of demo

00:11:47,009 --> 00:11:53,910
this from the video so here what happens

00:11:49,919 --> 00:11:56,970
is that the application will will ask my

00:11:53,910 --> 00:11:58,649
REST API a specific question so it will

00:11:56,970 --> 00:12:01,289
give me the question and as list of

00:11:58,649 --> 00:12:03,539
possible answers to use and what will

00:12:01,289 --> 00:12:05,669
happen now is a let's try to answer this

00:12:03,539 --> 00:12:08,160
question hopefully everyone knows where

00:12:05,669 --> 00:12:10,709
they currently are right now in case you

00:12:08,160 --> 00:12:13,609
don't know we're in remedy Italy so

00:12:10,709 --> 00:12:17,730
let's go ahead and select that answer

00:12:13,609 --> 00:12:20,309
and then there's a separate API request

00:12:17,730 --> 00:12:22,529
that will now let you post the answer to

00:12:20,309 --> 00:12:24,929
figure out if you got it right so of

00:12:22,529 --> 00:12:26,789
course by posting the answer remedy

00:12:24,929 --> 00:12:28,470
Italy we got that right and we could go

00:12:26,789 --> 00:12:31,739
ahead and query for another answer on

00:12:28,470 --> 00:12:34,289
our REST API so now here's the second

00:12:31,739 --> 00:12:35,879
question asking about spaces how many

00:12:34,289 --> 00:12:37,980
should be used for annotation let's say

00:12:35,879 --> 00:12:39,749
we're completely new with Python and we

00:12:37,980 --> 00:12:40,829
put nine use tabs which is obviously

00:12:39,749 --> 00:12:44,220
wrong

00:12:40,829 --> 00:12:46,079
so the childís applets it will send a

00:12:44,220 --> 00:12:47,759
request and it will tell you that you're

00:12:46,079 --> 00:12:49,709
wrong and you get the next question so

00:12:47,759 --> 00:12:50,789
let's just say we have a lot of we've

00:12:49,709 --> 00:12:52,350
been answering a lot of questions and we

00:12:50,789 --> 00:12:55,169
want to keep track of our score where we

00:12:52,350 --> 00:12:57,769
are so we have this additional ability

00:12:55,169 --> 00:13:00,449
to go ahead and sign up as a user and

00:12:57,769 --> 00:13:04,649
keep in be able to log in and keep track

00:13:00,449 --> 00:13:07,559
of our score over time so I'm going to

00:13:04,649 --> 00:13:08,909
go ahead and add this as my username

00:13:07,559 --> 00:13:12,720
being Kyle and then give it a password

00:13:08,909 --> 00:13:14,839
and then from there I can go ahead and

00:13:12,720 --> 00:13:14,839
login

00:13:21,630 --> 00:13:26,380
so once I log it in well that will do is

00:13:25,000 --> 00:13:28,360
take me back to the original question I

00:13:26,380 --> 00:13:30,250
can start answering so for this first

00:13:28,360 --> 00:13:32,500
connection let's say I forgot that is

00:13:30,250 --> 00:13:35,350
2017 and I thought 2016 I put Bilbao

00:13:32,500 --> 00:13:36,460
down which is obviously wrong now let's

00:13:35,350 --> 00:13:40,630
actually get this answer correct

00:13:36,460 --> 00:13:41,890
and once we submit for here well we

00:13:40,630 --> 00:13:44,050
should be able to go ahead and get the

00:13:41,890 --> 00:13:45,760
next question and see what our current

00:13:44,050 --> 00:13:48,190
score is you can see that total correct

00:13:45,760 --> 00:13:49,660
is one total answer is two I can now say

00:13:48,190 --> 00:13:51,910
let's say I want to take a break and go

00:13:49,660 --> 00:13:53,380
ahead and log out and resume later so if

00:13:51,910 --> 00:13:57,250
I go ahead the blog out it returned to

00:13:53,380 --> 00:14:04,000
me back to the original question and I

00:13:57,250 --> 00:14:05,350
can go ahead and log in again and that

00:14:04,000 --> 00:14:06,760
should take me back to where I left off

00:14:05,350 --> 00:14:10,810
with that third question about design of

00:14:06,760 --> 00:14:12,430
Python so that's the gist of my

00:14:10,810 --> 00:14:13,720
application what I want to do now is

00:14:12,430 --> 00:14:17,830
actually talk about how you go about

00:14:13,720 --> 00:14:19,330
writing this application with chalice so

00:14:17,830 --> 00:14:20,860
there's three steps in writing this

00:14:19,330 --> 00:14:22,480
application one you have to worry about

00:14:20,860 --> 00:14:23,980
the question/answer API that whole idea

00:14:22,480 --> 00:14:25,240
of getting a question and then posting

00:14:23,980 --> 00:14:26,800
that answer in order to determine if

00:14:25,240 --> 00:14:28,420
you're right or wrong there's the web

00:14:26,800 --> 00:14:30,250
application portion so specifically the

00:14:28,420 --> 00:14:32,200
browser logic to make sure that you can

00:14:30,250 --> 00:14:34,090
work in the browser and then the third

00:14:32,200 --> 00:14:35,530
step which is authentication users so

00:14:34,090 --> 00:14:39,850
being able to handle registration login

00:14:35,530 --> 00:14:41,980
and being able to track user score so in

00:14:39,850 --> 00:14:44,590
order to show the rest the gets

00:14:41,980 --> 00:14:47,620
answering the post answer API let me go

00:14:44,590 --> 00:14:49,630
over this new video in which what I'll

00:14:47,620 --> 00:14:51,460
do is I'll show you initial branch of

00:14:49,630 --> 00:14:53,410
right now I have the master branch that

00:14:51,460 --> 00:14:55,150
has all the prod stuff on it I'm using

00:14:53,410 --> 00:14:56,710
this initial API branched it just has

00:14:55,150 --> 00:14:59,530
the get and post there's additional API

00:14:56,710 --> 00:15:00,880
as I'll need later on but to kind of

00:14:59,530 --> 00:15:03,100
show you a childís deployment what I'm

00:15:00,880 --> 00:15:06,340
going to do is deploy this branch to a

00:15:03,100 --> 00:15:08,380
Davis lambda and api gateway and i want

00:15:06,340 --> 00:15:11,320
to make sure to make you understand that

00:15:08,380 --> 00:15:15,160
in this command i'm running i am running

00:15:11,320 --> 00:15:18,250
it with a - test stage argument so the

00:15:15,160 --> 00:15:20,980
purpose of des este j-- is that it'll

00:15:18,250 --> 00:15:23,110
allow you to combine your resource into

00:15:20,980 --> 00:15:25,000
specific stage groups so right now i

00:15:23,110 --> 00:15:26,950
have a bunch of resources running my

00:15:25,000 --> 00:15:29,290
prada plication so if you went to the

00:15:26,950 --> 00:15:30,320
browser page it's hitting all my

00:15:29,290 --> 00:15:32,480
progress or PSA's

00:15:30,320 --> 00:15:34,430
I'm going to go ahead and deploy deploy

00:15:32,480 --> 00:15:35,570
new resources deploy new logic I don't

00:15:34,430 --> 00:15:37,340
want to be deploying straight to prod

00:15:35,570 --> 00:15:38,900
right I want to be pointing to some

00:15:37,340 --> 00:15:41,630
other stage that has all the resources

00:15:38,900 --> 00:15:42,980
isolated so that is what I'm doing here

00:15:41,630 --> 00:15:47,360
and then once I feel comfortable I can

00:15:42,980 --> 00:15:49,640
go ahead and deploy it to prod so in

00:15:47,360 --> 00:15:52,430
order to hammer that point home I'll

00:15:49,640 --> 00:15:54,650
have to do is run Chow crl with a stage

00:15:52,430 --> 00:15:56,510
URL to show that the actual URI that I

00:15:54,650 --> 00:16:00,710
get back is completely different from

00:15:56,510 --> 00:16:02,840
what the dev stages so now let's

00:16:00,710 --> 00:16:05,330
actually get into the question answer a

00:16:02,840 --> 00:16:08,330
part of the API so if I want to actually

00:16:05,330 --> 00:16:11,870
go ahead and get a question I go ahead

00:16:08,330 --> 00:16:15,140
and copy this URL in and I have the path

00:16:11,870 --> 00:16:18,590
components questions and question ID so

00:16:15,140 --> 00:16:21,050
in terms of how we do questions thick

00:16:18,590 --> 00:16:22,640
you have to provide a question ID they

00:16:21,050 --> 00:16:26,300
start at one increment by one each time

00:16:22,640 --> 00:16:28,400
so by running a get on this URL you will

00:16:26,300 --> 00:16:31,130
get the first question for the trivia

00:16:28,400 --> 00:16:33,250
application so we run that we run a get

00:16:31,130 --> 00:16:36,410
on that you'll see that it returns back

00:16:33,250 --> 00:16:38,930
that your Python where it's being held

00:16:36,410 --> 00:16:40,820
and the possible answers they can use it

00:16:38,930 --> 00:16:41,960
didn't reply to you in to answer back so

00:16:40,820 --> 00:16:45,230
you have to go ahead and post this

00:16:41,960 --> 00:16:47,690
answer we allow for posts the same your

00:16:45,230 --> 00:16:51,710
I and then what we're going to do is

00:16:47,690 --> 00:16:54,890
include a JSON body in this post for our

00:16:51,710 --> 00:16:56,720
server to be able to figure out what the

00:16:54,890 --> 00:16:59,150
correct answer is so we provide the

00:16:56,720 --> 00:17:00,950
answer key and the actual answer and

00:16:59,150 --> 00:17:03,160
once we actually go ahead and post this

00:17:00,950 --> 00:17:07,550
it will tell us if we're correct or not

00:17:03,160 --> 00:17:11,000
in which we were work for echt in the

00:17:07,550 --> 00:17:14,180
case where we submit a wrong answer it

00:17:11,000 --> 00:17:18,670
will do a similar thing but so let's say

00:17:14,180 --> 00:17:18,670
I put down Bilbao Spain instead for this

00:17:19,540 --> 00:17:24,170
and what will happen instead it will

00:17:22,400 --> 00:17:27,560
tell you all right you the correct

00:17:24,170 --> 00:17:30,680
answer is actually Remini but the and

00:17:27,560 --> 00:17:32,180
you got your answer wrong so let's go

00:17:30,680 --> 00:17:33,800
ahead now that you have an idea of how

00:17:32,180 --> 00:17:37,720
the rest api looks let's actually go

00:17:33,800 --> 00:17:41,420
talk about how you'd go about doing this

00:17:37,720 --> 00:17:42,950
so let's imagine we have our get

00:17:41,420 --> 00:17:44,990
question API we have

00:17:42,950 --> 00:17:48,080
of a question table that has Oliver

00:17:44,990 --> 00:17:49,790
questions in order to set up a a REST

00:17:48,080 --> 00:17:52,280
API for this all we need to do is stick

00:17:49,790 --> 00:17:54,500
a chalice application in between the two

00:17:52,280 --> 00:17:56,780
so that if you send a get request it

00:17:54,500 --> 00:17:59,120
will be Ford's by Amazon API gateway to

00:17:56,780 --> 00:18:01,040
Avis lamda which will read from the

00:17:59,120 --> 00:18:03,020
question table and return the

00:18:01,040 --> 00:18:07,100
information back to the user as HTTP

00:18:03,020 --> 00:18:09,170
response so now if they provide a answer

00:18:07,100 --> 00:18:10,910
that question that doesn't exist it

00:18:09,170 --> 00:18:12,350
would be the same logic but lambda would

00:18:10,910 --> 00:18:14,780
realize it's not on the table until

00:18:12,350 --> 00:18:19,400
Amazon API gateway to give the user a

00:18:14,780 --> 00:18:20,510
four for at the very end so here is some

00:18:19,400 --> 00:18:22,670
sample code on how you actually

00:18:20,510 --> 00:18:24,080
implement it don't worry about trying to

00:18:22,670 --> 00:18:25,790
read through it all right now I'm gonna

00:18:24,080 --> 00:18:28,280
step through it one by one so make sure

00:18:25,790 --> 00:18:30,650
you pay attention so to start I just

00:18:28,280 --> 00:18:32,870
import chalice here the second thing I

00:18:30,650 --> 00:18:34,910
import is a chalice Lib question so this

00:18:32,870 --> 00:18:37,280
is not a dependency of chalice it's

00:18:34,910 --> 00:18:39,050
actually a built-in functionality so if

00:18:37,280 --> 00:18:40,670
you want your application to grow

00:18:39,050 --> 00:18:43,600
outside of an app dot paper why file

00:18:40,670 --> 00:18:46,190
like you want more than one file

00:18:43,600 --> 00:18:49,280
involved you can use something called a

00:18:46,190 --> 00:18:51,230
chalice Lib which what I do is you can

00:18:49,280 --> 00:18:53,000
create a new chalice Lib directory in

00:18:51,230 --> 00:18:55,270
your chalice app allowing you to put new

00:18:53,000 --> 00:18:58,520
modules like I added a question spy

00:18:55,270 --> 00:18:59,750
module into my chalice Lib directory and

00:18:58,520 --> 00:19:01,610
this is a lot of difference in

00:18:59,750 --> 00:19:04,310
requirement text because requirement

00:19:01,610 --> 00:19:05,810
text is mainly for third-party package

00:19:04,310 --> 00:19:07,130
dependencies so stuff that you didn't

00:19:05,810 --> 00:19:10,640
write but you just want to take a

00:19:07,130 --> 00:19:13,610
dependency on afterwards I go ahead and

00:19:10,640 --> 00:19:16,760
create my app object and then I register

00:19:13,610 --> 00:19:19,010
my route and a handler for it accepts

00:19:16,760 --> 00:19:22,970
the question ID because question ID is a

00:19:19,010 --> 00:19:24,830
variable in the URI and now all we have

00:19:22,970 --> 00:19:26,480
to do is create a questions table called

00:19:24,830 --> 00:19:28,730
get questions this return none if the

00:19:26,480 --> 00:19:31,280
question doesn't exist or a name tuple

00:19:28,730 --> 00:19:32,240
of information about the question so if

00:19:31,280 --> 00:19:33,980
the questions I think this we're going

00:19:32,240 --> 00:19:36,140
to go ahead and raise this chalice done

00:19:33,980 --> 00:19:38,030
not found error so chalice has a bunch

00:19:36,140 --> 00:19:40,460
of built-in exceptions that allows you

00:19:38,030 --> 00:19:42,290
to raise it in your code in Amazon API

00:19:40,460 --> 00:19:44,090
gateway will propagate the specific

00:19:42,290 --> 00:19:45,500
status code back to the end users so by

00:19:44,090 --> 00:19:47,920
raising a chalice done not found error

00:19:45,500 --> 00:19:51,170
you will raise a 404 to the end user

00:19:47,920 --> 00:19:52,670
so now after all that's been gone

00:19:51,170 --> 00:19:55,490
through we can go ahead and return the

00:19:52,670 --> 00:19:57,500
question ID if it was found

00:19:55,490 --> 00:19:59,990
the poster side of it is very similar to

00:19:57,500 --> 00:20:02,059
the get all you have to do is in ABS

00:19:59,990 --> 00:20:04,330
lambda once you get the question back is

00:20:02,059 --> 00:20:06,890
determine if the provided answer is

00:20:04,330 --> 00:20:10,370
correct and if it is go ahead and return

00:20:06,890 --> 00:20:12,470
true to the end-user so here again is

00:20:10,370 --> 00:20:13,730
the code required to do this don't worry

00:20:12,470 --> 00:20:16,100
about reading this all three right now

00:20:13,730 --> 00:20:17,450
I'm going to step through it again so to

00:20:16,100 --> 00:20:19,970
register the route to start we use the

00:20:17,450 --> 00:20:22,130
same path as before but instead we

00:20:19,970 --> 00:20:25,130
specify post the last route we

00:20:22,130 --> 00:20:26,780
registered was only again so now we go

00:20:25,130 --> 00:20:28,490
ahead and create our function handle in

00:20:26,780 --> 00:20:29,900
which we accept question D as a

00:20:28,490 --> 00:20:32,300
parameter because it's a variable new

00:20:29,900 --> 00:20:34,160
you're in the path and then from there

00:20:32,300 --> 00:20:36,080
we the very first thing before we do any

00:20:34,160 --> 00:20:38,300
core logic is to make sure that the

00:20:36,080 --> 00:20:39,950
answer is actually in the JSON body and

00:20:38,300 --> 00:20:42,470
if it isn't we raise another built-in

00:20:39,950 --> 00:20:44,750
Challis exception which is the bad

00:20:42,470 --> 00:20:47,570
requester this will raise a four hundred

00:20:44,750 --> 00:20:49,670
error to the end user in terms of HTTP

00:20:47,570 --> 00:20:51,410
response and then from there what we can

00:20:49,670 --> 00:20:53,480
do is do some of the more core logic and

00:20:51,410 --> 00:20:55,610
figure out the really provided and get

00:20:53,480 --> 00:20:57,350
the actual question make sure that the

00:20:55,610 --> 00:20:59,420
provided answer is a list of possible

00:20:57,350 --> 00:21:01,130
answers if it's not let's go ahead and

00:20:59,420 --> 00:21:02,990
raise another bad request error another

00:21:01,130 --> 00:21:04,820
400 and tell them you need to provide an

00:21:02,990 --> 00:21:07,700
actual answer the list of possible

00:21:04,820 --> 00:21:09,440
answers once all those checks been

00:21:07,700 --> 00:21:11,630
complete what we do ahead and do is

00:21:09,440 --> 00:21:16,160
return if they're correct was a provided

00:21:11,630 --> 00:21:17,990
answer and actual correct answer so that

00:21:16,160 --> 00:21:19,429
was the question answer part of the API

00:21:17,990 --> 00:21:21,440
let's talk about what we kind of learned

00:21:19,429 --> 00:21:23,570
in this section first we talked about

00:21:21,440 --> 00:21:25,130
shallow Status stage so the idea of

00:21:23,570 --> 00:21:27,290
being able to group your resources into

00:21:25,130 --> 00:21:29,450
different stages so you don't interfere

00:21:27,290 --> 00:21:31,940
or deploy over your existing resources

00:21:29,450 --> 00:21:34,640
so if you wanted to experiment with

00:21:31,940 --> 00:21:36,950
stage you can keep your prodigy and not

00:21:34,640 --> 00:21:39,260
have to worry about deploying over what

00:21:36,950 --> 00:21:41,360
you have previously previously deployed

00:21:39,260 --> 00:21:42,920
we talked about chalice exception

00:21:41,360 --> 00:21:44,960
handling so raising a built-in chalice

00:21:42,920 --> 00:21:46,370
exception to go ahead and propagate a

00:21:44,960 --> 00:21:48,410
specific status code you want back to

00:21:46,370 --> 00:21:49,910
the user and we also talked about

00:21:48,410 --> 00:21:51,920
chalice Lib so if you want to outgrow

00:21:49,910 --> 00:21:53,809
your app top PI file you can go ahead

00:21:51,920 --> 00:21:55,750
and create a chalice Lib directory and

00:21:53,809 --> 00:21:57,500
create your own modules inside of that

00:21:55,750 --> 00:21:59,390
so now that we talked about the

00:21:57,500 --> 00:22:02,210
question/answer api let's talk about the

00:21:59,390 --> 00:22:03,260
web application portion of it so for the

00:22:02,210 --> 00:22:04,850
web applications are two things we're

00:22:03,260 --> 00:22:07,220
gonna have to worry about there's we had

00:22:04,850 --> 00:22:08,860
that ability for course and we're going

00:22:07,220 --> 00:22:10,510
to also have to get an SDK

00:22:08,860 --> 00:22:14,140
to be able to interact with our API in

00:22:10,510 --> 00:22:15,760
the browser so with course right now

00:22:14,140 --> 00:22:18,520
what I've been doing is just making API

00:22:15,760 --> 00:22:19,630
requests with my laptop to my REST API I

00:22:18,520 --> 00:22:21,700
don't really have to worry about cores

00:22:19,630 --> 00:22:23,950
but the minute I put a browser in there

00:22:21,700 --> 00:22:26,020
we have to worry about data security in

00:22:23,950 --> 00:22:27,670
terms of making cross-domain requests

00:22:26,020 --> 00:22:31,420
and to do that we have to abide by

00:22:27,670 --> 00:22:34,000
course and here's an example for example

00:22:31,420 --> 00:22:36,309
get request what happens here is that

00:22:34,000 --> 00:22:37,960
when we send a get request it will send

00:22:36,309 --> 00:22:39,190
the same response back but we also

00:22:37,960 --> 00:22:41,559
include this header right here the

00:22:39,190 --> 00:22:43,360
access control allow origin header which

00:22:41,559 --> 00:22:45,429
specifies what origins are allowed to

00:22:43,360 --> 00:22:49,200
read this resource in our case we just

00:22:45,429 --> 00:22:52,600
provided a star meaning any resource can

00:22:49,200 --> 00:22:54,040
if the if the request gets a little more

00:22:52,600 --> 00:22:55,960
complicated maybe it's a put or has some

00:22:54,040 --> 00:22:57,760
extra headers the browser also sends

00:22:55,960 --> 00:23:01,120
them pre-flight requests in terms of an

00:22:57,760 --> 00:23:02,350
options HTTP method and in order to do

00:23:01,120 --> 00:23:04,450
that it will determine what permissions

00:23:02,350 --> 00:23:06,580
it has to send in this request so

00:23:04,450 --> 00:23:09,760
specifically the server will apply back

00:23:06,580 --> 00:23:11,140
with if what headers you can reviews in

00:23:09,760 --> 00:23:13,809
your requests what methods you can use

00:23:11,140 --> 00:23:15,340
in sending it and also what resource

00:23:13,809 --> 00:23:18,970
what origins allowed to access this

00:23:15,340 --> 00:23:20,530
resource in order to enable this and a

00:23:18,970 --> 00:23:23,500
chalice application is quite simple you

00:23:20,530 --> 00:23:24,820
just add course equals true that will

00:23:23,500 --> 00:23:26,679
give you all the default values they'll

00:23:24,820 --> 00:23:29,350
get you a star for the origin it will

00:23:26,679 --> 00:23:31,330
give you a pre set of headers and

00:23:29,350 --> 00:23:33,429
anything any methods that have been

00:23:31,330 --> 00:23:35,590
labeled as cores also add that to the

00:23:33,429 --> 00:23:38,740
naval methods carlile methods for the

00:23:35,590 --> 00:23:40,390
cores headers if you want anything more

00:23:38,740 --> 00:23:42,280
specific you can go ahead and run court

00:23:40,390 --> 00:23:44,049
run it with course config instead of a

00:23:42,280 --> 00:23:47,679
boolean and you can get specific values

00:23:44,049 --> 00:23:51,280
that way as well so now what I want to

00:23:47,679 --> 00:23:53,230
do is talk about generating SDKs so the

00:23:51,280 --> 00:23:55,480
web of the front-end application I have

00:23:53,230 --> 00:23:57,400
is all written in JavaScript don't worry

00:23:55,480 --> 00:23:59,530
I'm not going to show you very very much

00:23:57,400 --> 00:24:01,809
javascript is the Python conference and

00:23:59,530 --> 00:24:04,600
way more way more confident with my

00:24:01,809 --> 00:24:07,270
Python abilities so I'm going to spare

00:24:04,600 --> 00:24:09,280
you guys of that but with the Chou's

00:24:07,270 --> 00:24:10,900
generate sdk what allows you to do is

00:24:09,280 --> 00:24:13,480
generate a javascript based sdk to

00:24:10,900 --> 00:24:17,710
interact with your api so here is an

00:24:13,480 --> 00:24:19,720
example of how you go about doing it so

00:24:17,710 --> 00:24:24,210
all you need to do is just run Challis

00:24:19,720 --> 00:24:24,210
generate sdk and specify a directory

00:24:24,269 --> 00:24:30,460
and what's going to happen here is that

00:24:27,990 --> 00:24:33,549
chalice will make an API request to a

00:24:30,460 --> 00:24:35,080
Amazon API gateway and Amazon API

00:24:33,549 --> 00:24:36,490
gateway will go ahead and generate your

00:24:35,080 --> 00:24:38,379
JavaScript SDK for you

00:24:36,490 --> 00:24:39,879
chalice will then download it and unzip

00:24:38,379 --> 00:24:42,129
it in the directory that you specified

00:24:39,879 --> 00:24:45,009
so now if I go ahead and CD into this

00:24:42,129 --> 00:24:48,279
directory you can see the different

00:24:45,009 --> 00:24:51,490
files I have available to me and you can

00:24:48,279 --> 00:24:53,649
see that I have a API gateway client j/s

00:24:51,490 --> 00:24:55,860
file and under here you can see some

00:24:53,649 --> 00:24:58,179
client code let's look at the more

00:24:55,860 --> 00:25:00,399
specific things related to our

00:24:58,179 --> 00:25:02,470
application so for example here we have

00:25:00,399 --> 00:25:04,570
our invoke URL you can see this is

00:25:02,470 --> 00:25:05,769
exactly the same as our dev stage so

00:25:04,570 --> 00:25:10,840
this is a URL we're going to be hitting

00:25:05,769 --> 00:25:13,779
in the end then if I skip along a little

00:25:10,840 --> 00:25:15,009
bit to the later on in the file you can

00:25:13,779 --> 00:25:17,649
also see some of the methods through

00:25:15,009 --> 00:25:19,450
some of the routes so you can see here

00:25:17,649 --> 00:25:21,639
this is just the questions so this is

00:25:19,450 --> 00:25:23,230
the gate question part of the API this

00:25:21,639 --> 00:25:25,450
allows me to get my information about a

00:25:23,230 --> 00:25:26,950
question so that's it in terms of how

00:25:25,450 --> 00:25:28,360
much JavaScript I'll show you but it

00:25:26,950 --> 00:25:30,519
just gives you an idea of how you can

00:25:28,360 --> 00:25:34,470
have easy access to your API from a

00:25:30,519 --> 00:25:37,149
front-end application so continuing on

00:25:34,470 --> 00:25:39,460
let's go ahead and talk about the last

00:25:37,149 --> 00:25:41,499
piece that we need in order to complete

00:25:39,460 --> 00:25:46,330
this application which is authorization

00:25:41,499 --> 00:25:48,190
in users so in terms of authorization

00:25:46,330 --> 00:25:49,269
users the one thing if you remember from

00:25:48,190 --> 00:25:51,249
the sample application there's the

00:25:49,269 --> 00:25:53,259
ability to log in there is ability to

00:25:51,249 --> 00:25:54,399
register yourself and be able to keep

00:25:53,259 --> 00:25:56,320
track of your score and where you've

00:25:54,399 --> 00:25:58,029
been so jealous has a bunch of different

00:25:56,320 --> 00:26:00,999
authorization options available to you

00:25:58,029 --> 00:26:02,409
there's of course none which we've been

00:26:00,999 --> 00:26:04,960
using the entire time we don't have to

00:26:02,409 --> 00:26:07,299
be authorized to use our API s there is

00:26:04,960 --> 00:26:09,759
I am authorizer which is using a branch

00:26:07,299 --> 00:26:12,159
at credentials and Amazon cig before

00:26:09,759 --> 00:26:14,350
signing to give authorization there is

00:26:12,159 --> 00:26:16,720
kognito user pool authorizer which is

00:26:14,350 --> 00:26:18,460
using amazon kognito which is a managed

00:26:16,720 --> 00:26:20,980
service for managing users and user

00:26:18,460 --> 00:26:23,409
pools and handling credential send login

00:26:20,980 --> 00:26:25,389
and registration whatnot and finally

00:26:23,409 --> 00:26:27,730
there is ability to define your own

00:26:25,389 --> 00:26:29,559
authorizers using the decorator apt

00:26:27,730 --> 00:26:31,059
authorizer so in your childís code you

00:26:29,559 --> 00:26:32,590
can go ahead and actually implement all

00:26:31,059 --> 00:26:35,169
the logic that you need for your

00:26:32,590 --> 00:26:36,220
authorizer and then link that up with

00:26:35,169 --> 00:26:39,130
your rest api

00:26:36,220 --> 00:26:40,539
handlers for this application I'm going

00:26:39,130 --> 00:26:43,480
to be using the cognitive use your pool

00:26:40,539 --> 00:26:44,440
authorizer mainly because Amazon Canada

00:26:43,480 --> 00:26:46,120
user pools gives you a lot of

00:26:44,440 --> 00:26:47,919
functionality right out of the box so

00:26:46,120 --> 00:26:49,059
mainly it's be able to manage users to

00:26:47,919 --> 00:26:51,789
be able to manage all the user data

00:26:49,059 --> 00:26:55,030
there and handle login registration all

00:26:51,789 --> 00:26:56,710
for you it provides SDKs for user

00:26:55,030 --> 00:26:58,240
registration logins so my front-end

00:26:56,710 --> 00:26:59,830
application is just a simple function

00:26:58,240 --> 00:27:03,309
called to get my credentials or to

00:26:59,830 --> 00:27:05,169
register a new user and also provides a

00:27:03,309 --> 00:27:06,669
DOS lamda triggers so while it provides

00:27:05,169 --> 00:27:08,530
an out-of-box solution if I want to

00:27:06,669 --> 00:27:10,200
customize it all I can create lambda

00:27:08,530 --> 00:27:13,210
functions that will customize the

00:27:10,200 --> 00:27:17,860
process in terms of how a user signs in

00:27:13,210 --> 00:27:20,400
our registers themself so in order to

00:27:17,860 --> 00:27:23,140
talk about how an authenticated user

00:27:20,400 --> 00:27:26,230
answer would be let's talk about the

00:27:23,140 --> 00:27:27,580
anonymous one first so here's the set up

00:27:26,230 --> 00:27:29,679
for the anonymous one if we want to

00:27:27,580 --> 00:27:32,020
actually add an offset authenticated

00:27:29,679 --> 00:27:35,080
answer API we go ahead and add the user

00:27:32,020 --> 00:27:36,870
component here and in adding the user

00:27:35,080 --> 00:27:39,909
point component we need two more

00:27:36,870 --> 00:27:43,539
resources one being a user table we also

00:27:39,909 --> 00:27:45,340
need Amazon kognito so in terms of the

00:27:43,539 --> 00:27:47,169
workflow in order to actually keep track

00:27:45,340 --> 00:27:49,090
of the users answers we need you to the

00:27:47,169 --> 00:27:51,730
following first the client will have to

00:27:49,090 --> 00:27:53,049
make a request Amazon Cognito using the

00:27:51,730 --> 00:27:55,000
username and password off they can

00:27:53,049 --> 00:27:56,440
authenticate themselves once they've

00:27:55,000 --> 00:28:00,010
been authenticated this Amazon Cognito

00:27:56,440 --> 00:28:03,159
go ahead and return a JWT token back to

00:28:00,010 --> 00:28:05,110
be used in subsequent requests and from

00:28:03,159 --> 00:28:07,210
there you can go ahead and post your

00:28:05,110 --> 00:28:09,370
answer but notice that there's an

00:28:07,210 --> 00:28:12,059
authorization header included that

00:28:09,370 --> 00:28:14,500
matches the exact same JWT token and

00:28:12,059 --> 00:28:16,480
Amazon API gateway will then check to

00:28:14,500 --> 00:28:18,309
make sure that they're authorized and go

00:28:16,480 --> 00:28:20,679
ahead and book the ATIS lambda function

00:28:18,309 --> 00:28:22,570
ADIS lambda will make sure that what

00:28:20,679 --> 00:28:24,250
their answer was was correct and based

00:28:22,570 --> 00:28:26,620
off the result we'll go ahead and record

00:28:24,250 --> 00:28:28,360
that in our user table and finally

00:28:26,620 --> 00:28:32,850
return that HTTP response back to the

00:28:28,360 --> 00:28:35,460
end-user so to actually implement this

00:28:32,850 --> 00:28:37,419
here is sample code and how you do it

00:28:35,460 --> 00:28:40,809
I'm going to step through this one by

00:28:37,419 --> 00:28:43,240
one again so follow along here what I

00:28:40,809 --> 00:28:45,070
have is the pool arm so the Amazon

00:28:43,240 --> 00:28:47,799
Cognito user pool I set this up prior to

00:28:45,070 --> 00:28:49,299
any shell this deployment and the pool

00:28:47,799 --> 00:28:52,720
urn is essentially the

00:28:49,299 --> 00:28:55,960
a fire for the spool and from there what

00:28:52,720 --> 00:28:57,970
I do create a cognate oh you user pool

00:28:55,960 --> 00:29:00,340
authorizers so I provide my pool iron to

00:28:57,970 --> 00:29:03,009
that to have an authorizer that I can

00:29:00,340 --> 00:29:05,139
then take my take in my route and assign

00:29:03,009 --> 00:29:07,840
it as my authorizers so any requests

00:29:05,139 --> 00:29:09,730
going through this route has to have

00:29:07,840 --> 00:29:13,090
Cognito user pool authentication in

00:29:09,730 --> 00:29:14,739
order for it to pass through so now from

00:29:13,090 --> 00:29:17,980
there what we would go ahead and do is

00:29:14,739 --> 00:29:20,080
create a function and go ahead and run

00:29:17,980 --> 00:29:21,669
to answer date question function if we

00:29:20,080 --> 00:29:23,559
remember before answer question comes

00:29:21,669 --> 00:29:27,070
from just anonymous post questions

00:29:23,559 --> 00:29:28,299
question ID Rao once we have the answer

00:29:27,070 --> 00:29:29,559
data we need to actually figure out who

00:29:28,299 --> 00:29:31,809
the user was that just answered that

00:29:29,559 --> 00:29:34,419
question and in order to get that what

00:29:31,809 --> 00:29:36,879
we can do is go ahead and run this

00:29:34,419 --> 00:29:40,149
helper function called get authenticated

00:29:36,879 --> 00:29:42,039
user name which uses a property on the

00:29:40,149 --> 00:29:44,649
current request object which is the

00:29:42,039 --> 00:29:46,690
context the context provides information

00:29:44,649 --> 00:29:48,429
about what exactly triggered my lambda

00:29:46,690 --> 00:29:51,549
function and just information about it

00:29:48,429 --> 00:29:54,249
and if I open this up you see I get a

00:29:51,549 --> 00:29:55,690
big JSON dictionary I actually shortened

00:29:54,249 --> 00:29:57,220
this dictionary because if I didn't it

00:29:55,690 --> 00:29:57,820
will fill up the entire page and didn't

00:29:57,220 --> 00:29:59,980
have any room

00:29:57,820 --> 00:30:02,139
so I shortened it just for the specifics

00:29:59,980 --> 00:30:03,879
that we want and specifically what we

00:30:02,139 --> 00:30:06,129
want is that Cognito username out of it

00:30:03,879 --> 00:30:09,309
in this case the username was my

00:30:06,129 --> 00:30:11,889
username so another point I want to make

00:30:09,309 --> 00:30:13,539
out to you is that ideally if you're

00:30:11,889 --> 00:30:15,249
using keeping these in a database you

00:30:13,539 --> 00:30:19,059
probably want to be using the sub token

00:30:15,249 --> 00:30:20,590
this is a unique uniquely generated ID

00:30:19,059 --> 00:30:22,149
by Amazon kognito

00:30:20,590 --> 00:30:23,710
so if you're trying to add these users

00:30:22,149 --> 00:30:25,749
to a user pool you probably want to use

00:30:23,710 --> 00:30:28,440
that as a primary key but I'm just using

00:30:25,749 --> 00:30:32,799
Cognito username for simplicity and

00:30:28,440 --> 00:30:34,960
reading for this talk so now I go ahead

00:30:32,799 --> 00:30:36,700
and create my user table I add my update

00:30:34,960 --> 00:30:40,690
my user score and return the answer data

00:30:36,700 --> 00:30:42,429
which came from the answer question so

00:30:40,690 --> 00:30:44,799
now that we have login all handled and

00:30:42,429 --> 00:30:45,999
keeping track of user score the one

00:30:44,799 --> 00:30:48,220
thing we haven't covered is how do we

00:30:45,999 --> 00:30:50,529
handle registration of users so like I

00:30:48,220 --> 00:30:53,289
said before Amazon Cognito provides to

00:30:50,529 --> 00:30:54,820
you a outlet box solution but you may

00:30:53,289 --> 00:30:57,039
want to customize it in my case actually

00:30:54,820 --> 00:30:59,200
wanted to customize it specifically in

00:30:57,039 --> 00:31:00,549
terms of registering new user usually

00:30:59,200 --> 00:31:03,009
you sign up and then you have to do a

00:31:00,549 --> 00:31:03,280
confirmation of this the user has to

00:31:03,009 --> 00:31:05,500
think

00:31:03,280 --> 00:31:07,570
confirm themselves I wasn't particularly

00:31:05,500 --> 00:31:09,100
interested in doing a confirmation so I

00:31:07,570 --> 00:31:10,660
wanted to be able to stable that a

00:31:09,100 --> 00:31:12,910
second thing I wanted was that

00:31:10,660 --> 00:31:14,320
immediately after a user registered I

00:31:12,910 --> 00:31:17,050
wanted to keep track of them in my

00:31:14,320 --> 00:31:20,140
dynamodb database I don't want to I do

00:31:17,050 --> 00:31:21,940
not want to only have access to users

00:31:20,140 --> 00:31:23,200
that have just answered a question

00:31:21,940 --> 00:31:25,660
because that's the only way I'd be able

00:31:23,200 --> 00:31:28,660
to track it by adding them when I invoke

00:31:25,660 --> 00:31:30,820
the lambda function so in order to do

00:31:28,660 --> 00:31:32,320
this I add two more lambda functions one

00:31:30,820 --> 00:31:34,330
lambda function for auto confirming

00:31:32,320 --> 00:31:36,520
functions for Auto confirming the users

00:31:34,330 --> 00:31:40,420
and another lambda function for actually

00:31:36,520 --> 00:31:42,610
adding users and the way it works now is

00:31:40,420 --> 00:31:44,440
once you've register you send a username

00:31:42,610 --> 00:31:46,540
and password to Amazon kognito

00:31:44,440 --> 00:31:48,670
and Amazon keenya would start the

00:31:46,540 --> 00:31:49,990
registration process and these limited

00:31:48,670 --> 00:31:52,030
functions are hooked up to specific

00:31:49,990 --> 00:31:54,250
points in the registration process so

00:31:52,030 --> 00:31:56,860
that Amazon kognito would then invoke a

00:31:54,250 --> 00:31:58,810
de lambda function on a specific point

00:31:56,860 --> 00:32:00,250
so at the pre signup trigger we'll go

00:31:58,810 --> 00:32:02,440
ahead and invoke our auto confirm

00:32:00,250 --> 00:32:04,510
function in which case the lambda

00:32:02,440 --> 00:32:06,640
function will respond to Amazon kognito

00:32:04,510 --> 00:32:09,340
to go ahead and say you can go ahead and

00:32:06,640 --> 00:32:11,170
auto confirm this user after this being

00:32:09,340 --> 00:32:13,000
has been signed up and confirmed there

00:32:11,170 --> 00:32:14,890
is another trigger called the post

00:32:13,000 --> 00:32:16,780
confirmation trigger and with the post

00:32:14,890 --> 00:32:18,550
confirmation trigger what we'll do is

00:32:16,780 --> 00:32:21,120
have the Amazon lambda function go ahead

00:32:18,550 --> 00:32:24,430
and actually add the user to our table o

00:32:21,120 --> 00:32:25,930
turned back a response and Amazon cogito

00:32:24,430 --> 00:32:30,640
will tell the user you're all signed up

00:32:25,930 --> 00:32:32,980
you're good to go so the auto confirm

00:32:30,640 --> 00:32:35,560
function and it's not very difficult to

00:32:32,980 --> 00:32:38,080
do this all I have to do is in your app

00:32:35,560 --> 00:32:40,480
top tie file go ahead and add this

00:32:38,080 --> 00:32:41,500
function right here so this is a little

00:32:40,480 --> 00:32:42,790
bit different than you've been saying

00:32:41,500 --> 00:32:44,500
previously we've been using routes as a

00:32:42,790 --> 00:32:46,210
decorator this time we're you actually

00:32:44,500 --> 00:32:48,220
using the lambda function decorator

00:32:46,210 --> 00:32:50,140
so what that means is a standalone

00:32:48,220 --> 00:32:52,390
lambda function so it's not connected to

00:32:50,140 --> 00:32:56,080
any API gateway so you can't actually

00:32:52,390 --> 00:32:59,190
make REST API eyes to it rest a request

00:32:56,080 --> 00:33:02,680
to it and it's also isolated from your

00:32:59,190 --> 00:33:05,890
API environment all the logic that's

00:33:02,680 --> 00:33:07,750
handling your routes so this function

00:33:05,890 --> 00:33:10,030
now accepts two arguments there is the

00:33:07,750 --> 00:33:11,440
event in context the event is usually a

00:33:10,030 --> 00:33:14,320
dictionary that has all the parameters

00:33:11,440 --> 00:33:16,090
that it was that triggered this lambda

00:33:14,320 --> 00:33:17,320
function in the context has if

00:33:16,090 --> 00:33:18,909
Meishan about how the line to function

00:33:17,320 --> 00:33:21,429
got triggered if actually look at the

00:33:18,909 --> 00:33:23,020
event here you can see the different

00:33:21,429 --> 00:33:25,510
formation I have available to myself for

00:33:23,020 --> 00:33:27,700
this pre signup event and specifically

00:33:25,510 --> 00:33:29,710
what I'm interested in is telling this

00:33:27,700 --> 00:33:30,549
auto confirm user value a false and

00:33:29,710 --> 00:33:33,070
setting it to true

00:33:30,549 --> 00:33:35,350
and after that I'll go ahead and return

00:33:33,070 --> 00:33:37,570
the event this entire thing telling

00:33:35,350 --> 00:33:42,400
Amazon Cognito to skip the confirmation

00:33:37,570 --> 00:33:44,860
sign up the confirm signup step so in

00:33:42,400 --> 00:33:46,630
order to add a user now this is not too

00:33:44,860 --> 00:33:49,529
difficult either all you have to do is

00:33:46,630 --> 00:33:52,090
add another lender function here and

00:33:49,529 --> 00:33:53,799
like like it's like it did the last one

00:33:52,090 --> 00:33:55,000
the lambda function is a standard loan

00:33:53,799 --> 00:33:56,740
lambda function because it's using the

00:33:55,000 --> 00:34:00,190
lambda function decorator so it's not

00:33:56,740 --> 00:34:03,190
connected to Amazon API gateway and the

00:34:00,190 --> 00:34:06,039
event that it adds is the event that it

00:34:03,190 --> 00:34:07,480
takes in is this event here and out of

00:34:06,039 --> 00:34:10,060
this event I can get information such as

00:34:07,480 --> 00:34:12,460
the user name which will allow me to go

00:34:10,060 --> 00:34:13,960
ahead and add the user to the user table

00:34:12,460 --> 00:34:18,280
I can go ahead and return the Tower

00:34:13,960 --> 00:34:20,500
event to Amazon Cognito and then that's

00:34:18,280 --> 00:34:23,020
all it takes for the entire registration

00:34:20,500 --> 00:34:26,050
process that happened one thing I also

00:34:23,020 --> 00:34:27,550
want to mention before is that after

00:34:26,050 --> 00:34:29,889
Ibiza slammed a function deployed I have

00:34:27,550 --> 00:34:32,260
to go ahead and add these as triggers to

00:34:29,889 --> 00:34:34,810
my existing user pool it's a one-time

00:34:32,260 --> 00:34:37,060
setup thing but I'm using chalice mainly

00:34:34,810 --> 00:34:38,440
here so I can handle the deployments and

00:34:37,060 --> 00:34:41,200
updates of my lambda functions in my

00:34:38,440 --> 00:34:46,480
chalice application because it makes it

00:34:41,200 --> 00:34:47,980
very easy for me to update it so going

00:34:46,480 --> 00:34:49,720
back to the outline let's talk about we

00:34:47,980 --> 00:34:51,460
learned in section we talked about how

00:34:49,720 --> 00:34:55,060
you use Amazon kognito to give off the

00:34:51,460 --> 00:34:57,220
radiation for your child suffocation we

00:34:55,060 --> 00:34:59,320
talked about app current request context

00:34:57,220 --> 00:35:01,660
so being able to get information about

00:34:59,320 --> 00:35:05,190
your lambda function and how it got

00:35:01,660 --> 00:35:07,630
invoked and finally we talked about the

00:35:05,190 --> 00:35:09,400
app dot lambda function decorators so

00:35:07,630 --> 00:35:11,410
being able to set up a standalone lambda

00:35:09,400 --> 00:35:13,119
function that is not connected to the

00:35:11,410 --> 00:35:17,650
Amazon API gateway and just runs by

00:35:13,119 --> 00:35:19,450
itself so given the time constraints

00:35:17,650 --> 00:35:21,660
there's some other Challis features I

00:35:19,450 --> 00:35:25,119
really wish we got to talk about but

00:35:21,660 --> 00:35:27,130
unfortunately was not able to one

00:35:25,119 --> 00:35:28,750
feature being the app dot scheduled

00:35:27,130 --> 00:35:29,950
decorator so this is like the lambda

00:35:28,750 --> 00:35:31,750
function decorator but it's

00:35:29,950 --> 00:35:34,270
because you can essentially have cron

00:35:31,750 --> 00:35:36,849
jobs running for your service

00:35:34,270 --> 00:35:39,099
application so every X minutes every X

00:35:36,849 --> 00:35:41,200
hours or a specific day of the week you

00:35:39,099 --> 00:35:42,599
can have a lambda function run so that's

00:35:41,200 --> 00:35:45,400
very convenient

00:35:42,599 --> 00:35:48,670
another one is dependency management so

00:35:45,400 --> 00:35:50,559
while if you remember for in the intro

00:35:48,670 --> 00:35:52,240
demo I talked about requirement text and

00:35:50,559 --> 00:35:55,540
how it downloads all the dependencies

00:35:52,240 --> 00:35:57,480
you need for you while that's pretty

00:35:55,540 --> 00:35:59,280
straightforward but when it comes to

00:35:57,480 --> 00:36:01,750
extensions it gets kind of complicated

00:35:59,280 --> 00:36:02,950
because if they add abuse lambda it's

00:36:01,750 --> 00:36:05,619
underlining operating system that's

00:36:02,950 --> 00:36:08,710
running on this is Amazon Linux so if

00:36:05,619 --> 00:36:10,270
you send up a compiled version of the C

00:36:08,710 --> 00:36:12,130
extension that isn't compatible with

00:36:10,270 --> 00:36:14,380
Amazon Linux you're going to have a lot

00:36:12,130 --> 00:36:16,240
of problems when you're Amazon and

00:36:14,380 --> 00:36:17,980
you're a dubose lambda function the cool

00:36:16,240 --> 00:36:19,510
part what Challis will do though is it

00:36:17,980 --> 00:36:22,240
will actually download wheels for you

00:36:19,510 --> 00:36:24,099
that are compatible for Amazon Linux on

00:36:22,240 --> 00:36:25,569
zip it into deployment package and go

00:36:24,099 --> 00:36:28,359
ahead and allow you to run that in

00:36:25,569 --> 00:36:29,500
lambda so for example if you were right

00:36:28,359 --> 00:36:31,869
if you're doing your deployments from a

00:36:29,500 --> 00:36:34,510
window machine and you had a dependency

00:36:31,869 --> 00:36:36,160
on numpy for example it'll go ahead and

00:36:34,510 --> 00:36:37,630
download those wheels for you for dead

00:36:36,160 --> 00:36:39,490
orchid data for Amazon Linux and go

00:36:37,630 --> 00:36:40,780
ahead and include that deployment

00:36:39,490 --> 00:36:42,250
package you can have nem PI run your

00:36:40,780 --> 00:36:46,540
lambda function it doesn't manage the

00:36:42,250 --> 00:36:50,829
operating system so last thing I want to

00:36:46,540 --> 00:36:54,549
talk about a additional Challis I am

00:36:50,829 --> 00:36:57,579
policy generation which what allows you

00:36:54,549 --> 00:36:59,799
to do is if you remember from the very

00:36:57,579 --> 00:37:02,020
first of one of the first slides where

00:36:59,799 --> 00:37:03,880
we talking about the setting it up from

00:37:02,020 --> 00:37:06,520
scratch about the I n policy so lambda

00:37:03,880 --> 00:37:08,079
needs a bunch of permissions in terms of

00:37:06,520 --> 00:37:10,420
if you're going to access other 80s

00:37:08,079 --> 00:37:11,920
resources what jelous will do is scan

00:37:10,420 --> 00:37:13,599
through your source code determine all

00:37:11,920 --> 00:37:15,460
the operations you're using all the Atos

00:37:13,599 --> 00:37:17,049
resources using actually generate that

00:37:15,460 --> 00:37:19,690
ion policy for you so you don't actually

00:37:17,049 --> 00:37:23,680
have to worry about that part of the

00:37:19,690 --> 00:37:26,559
shell of the land of deployment part so

00:37:23,680 --> 00:37:28,030
now let's start wrapping this up the one

00:37:26,559 --> 00:37:30,010
thing I really hope you guys got out of

00:37:28,030 --> 00:37:33,490
this talk was the benefits of using

00:37:30,010 --> 00:37:35,260
chalice from the beginning we showed how

00:37:33,490 --> 00:37:36,819
it's easy and if it allows for easy and

00:37:35,260 --> 00:37:38,559
fast paced app development

00:37:36,819 --> 00:37:39,730
so from chalice new project you can get

00:37:38,559 --> 00:37:41,859
quickly started and deploy that

00:37:39,730 --> 00:37:43,750
application and quickly iterate on top

00:37:41,859 --> 00:37:44,860
of it there's not a lot of boilerplate

00:37:43,750 --> 00:37:47,110
code you need to worry about in

00:37:44,860 --> 00:37:49,420
deploying analysis application I think

00:37:47,110 --> 00:37:50,710
in the end my app dot PI file for this

00:37:49,420 --> 00:37:54,000
entire application was less than hundred

00:37:50,710 --> 00:37:56,410
lines of code so that was really nice

00:37:54,000 --> 00:37:58,060
another point is it handles all the ADA

00:37:56,410 --> 00:38:01,740
based resource management for you so it

00:37:58,060 --> 00:38:05,140
provides a nice abstraction on top of

00:38:01,740 --> 00:38:06,700
your top of all the ATS all the a DOS

00:38:05,140 --> 00:38:07,780
lambda and API gateway stuff so you

00:38:06,700 --> 00:38:09,670
don't actually have to worry about that

00:38:07,780 --> 00:38:11,950
it will handle it all for you so you can

00:38:09,670 --> 00:38:15,610
just focus on the Python specific aspect

00:38:11,950 --> 00:38:17,650
of your code and finally it produces

00:38:15,610 --> 00:38:19,630
production ready applications production

00:38:17,650 --> 00:38:21,370
ready being it's being ran on a Prius

00:38:19,630 --> 00:38:22,720
lambda and therefore is handling all the

00:38:21,370 --> 00:38:24,490
scaling for you and all the

00:38:22,720 --> 00:38:26,290
infrastructure management so you can go

00:38:24,490 --> 00:38:28,150
ahead and deploy it just leave it there

00:38:26,290 --> 00:38:29,710
and not have to worry about it or

00:38:28,150 --> 00:38:35,830
keeping or worrying about any of the

00:38:29,710 --> 00:38:37,270
DevOps related to it ok so the final

00:38:35,830 --> 00:38:39,850
thing I want to mention is that we

00:38:37,270 --> 00:38:41,500
really shall is 1.0 beta last week so

00:38:39,850 --> 00:38:42,970
what that means is that while it's still

00:38:41,500 --> 00:38:45,130
developer preview we're getting very

00:38:42,970 --> 00:38:47,710
close to actually going GA with this in

00:38:45,130 --> 00:38:51,160
having that 1.0 release so between now

00:38:47,710 --> 00:38:53,050
and when we actually do 1.0 it's only to

00:38:51,160 --> 00:38:55,090
be small enhancements based off user

00:38:53,050 --> 00:38:58,390
feedback and trying to polish up the

00:38:55,090 --> 00:39:01,960
final interface so I really hope this

00:38:58,390 --> 00:39:03,550
talk it motivated you guys to all try

00:39:01,960 --> 00:39:05,110
out chalice try writing some service

00:39:03,550 --> 00:39:07,450
applications and if you have any

00:39:05,110 --> 00:39:10,330
feedback come find me

00:39:07,450 --> 00:39:12,820
or there's another dev here James from

00:39:10,330 --> 00:39:15,160
the Chou's team or you can also post an

00:39:12,820 --> 00:39:16,720
issue on github any feedback we can get

00:39:15,160 --> 00:39:20,850
between now and we go jay is very

00:39:16,720 --> 00:39:23,830
valuable so we would be grateful for it

00:39:20,850 --> 00:39:25,720
so one thing I want to say is here's

00:39:23,830 --> 00:39:28,420
some related links here's a chalice

00:39:25,720 --> 00:39:29,950
repository chalice documentation and

00:39:28,420 --> 00:39:31,570
also all the code I used for my

00:39:29,950 --> 00:39:34,150
challenge trivia app you can find it

00:39:31,570 --> 00:39:35,380
here I need to fill out the readme a

00:39:34,150 --> 00:39:37,060
little bit so if you're trying to deploy

00:39:35,380 --> 00:39:38,440
it initially you might have a little bit

00:39:37,060 --> 00:39:40,210
issues but you can at least get a gist

00:39:38,440 --> 00:39:43,390
of how I actually went about writing

00:39:40,210 --> 00:39:45,280
this application and you can follow me

00:39:43,390 --> 00:39:48,730
at twitter at be Callen app for any

00:39:45,280 --> 00:39:51,070
updates related to this talk and also if

00:39:48,730 --> 00:39:52,570
you want to talk about AWS chalice or

00:39:51,070 --> 00:39:54,900
any of the libraries that I work on

00:39:52,570 --> 00:39:57,180
please come find me or your

00:39:54,900 --> 00:39:58,470
my team member chamber barrettes later

00:39:57,180 --> 00:40:00,570
this week I'll be here the entire

00:39:58,470 --> 00:40:03,030
conference so if we have time for

00:40:00,570 --> 00:40:09,210
questions we can do it after but thanks

00:40:03,030 --> 00:40:11,670
everyone for coming listening we do have

00:40:09,210 --> 00:40:13,970
time for a few questions so let's get

00:40:11,670 --> 00:40:13,970
started

00:40:14,990 --> 00:40:21,270
hello Estelle is providing good talk by

00:40:18,210 --> 00:40:24,180
the way yes I studies providing um any

00:40:21,270 --> 00:40:28,590
way to manage resources like s3 buckets

00:40:24,180 --> 00:40:30,300
or databases um not not currently the

00:40:28,590 --> 00:40:31,410
closest thing you could do is it

00:40:30,300 --> 00:40:32,670
provides the ability to have

00:40:31,410 --> 00:40:34,080
CloudFormation templates where you can

00:40:32,670 --> 00:40:36,270
have an s3 bucket there but one creature

00:40:34,080 --> 00:40:38,430
really want to add is some of the major

00:40:36,270 --> 00:40:39,840
resources like s3 DynamoDB something

00:40:38,430 --> 00:40:41,370
you'll be at you'd be using a lot in

00:40:39,840 --> 00:40:43,140
your application and being able to

00:40:41,370 --> 00:40:49,560
manage it but that's something on the

00:40:43,140 --> 00:40:53,130
roadmap yeah same for your talks yep in

00:40:49,560 --> 00:40:56,400
terms of data persistence see what sub

00:40:53,130 --> 00:40:59,280
databases because you show user table a

00:40:56,400 --> 00:41:02,220
question table yep the options out there

00:40:59,280 --> 00:41:02,760
uh can you repeat the question I can't

00:41:02,220 --> 00:41:06,810
hear very well

00:41:02,760 --> 00:41:10,440
sorry so in terms of data persistence II

00:41:06,810 --> 00:41:14,400
like databases what can you use can use

00:41:10,440 --> 00:41:16,410
like my sequel pause grace dynamodb yeah

00:41:14,400 --> 00:41:17,460
I mean whatever tape whatever table you

00:41:16,410 --> 00:41:18,990
have available to you whatever can

00:41:17,460 --> 00:41:21,480
connect to you I was doing DynamoDB in

00:41:18,990 --> 00:41:23,700
my user table so that's really nice

00:41:21,480 --> 00:41:26,340
because it just integrates really well

00:41:23,700 --> 00:41:27,090
database just resources and whatnot does

00:41:26,340 --> 00:41:32,250
that answer the question

00:41:27,090 --> 00:41:34,980
or yes thank okay yeah I thank you for

00:41:32,250 --> 00:41:38,460
the talk and what about testing because

00:41:34,980 --> 00:41:41,340
yeah code you showed was really tight

00:41:38,460 --> 00:41:44,250
coupled and oh sorry what about that

00:41:41,340 --> 00:41:46,650
yeah so interpret yeah server interpret

00:41:44,250 --> 00:41:47,940
testing you can go ahead and you you can

00:41:46,650 --> 00:41:50,340
go ahead and just test this general

00:41:47,940 --> 00:41:52,350
function the general handlers but in

00:41:50,340 --> 00:41:54,000
terms of actual framework if you're

00:41:52,350 --> 00:41:55,440
familiar flask and how it has its own

00:41:54,000 --> 00:41:56,880
testing framework it doesn't tell us

00:41:55,440 --> 00:41:58,440
this really have anything specific like

00:41:56,880 --> 00:42:02,780
that but it's something we want to add

00:41:58,440 --> 00:42:02,780
and in coming days

00:42:06,540 --> 00:42:09,990
thank you for the duck they're not very

00:42:08,220 --> 00:42:12,900
nice life in comparison thank you what

00:42:09,990 --> 00:42:14,670
do we see in yesterday and my question

00:42:12,900 --> 00:42:16,830
is that you told us main difference

00:42:14,670 --> 00:42:19,230
between free or art is that you don't

00:42:16,830 --> 00:42:20,490
have a server to manage but like if you

00:42:19,230 --> 00:42:22,110
take elastic Beanstalk

00:42:20,490 --> 00:42:24,000
for instance view also the Mensch

00:42:22,110 --> 00:42:26,340
anything you just upload some artifact

00:42:24,000 --> 00:42:28,250
was like which depicts whiskey yeah and

00:42:26,340 --> 00:42:31,380
that's it like what's the difference and

00:42:28,250 --> 00:42:33,390
okay surplus itself feels like a little

00:42:31,380 --> 00:42:35,760
misguided because yeah so I mean River

00:42:33,390 --> 00:42:37,140
on demand but you yeah yeah I hear you

00:42:35,760 --> 00:42:39,060
saying so the thing with so elastic

00:42:37,140 --> 00:42:40,650
Beanstalk is that you have you still

00:42:39,060 --> 00:42:42,390
have the application up and running but

00:42:40,650 --> 00:42:43,620
with if you're using a to s lambda

00:42:42,390 --> 00:42:46,410
though you're only paying for the

00:42:43,620 --> 00:42:49,470
execution runtime so you still may have

00:42:46,410 --> 00:42:50,910
your elastic Beanstalk application still

00:42:49,470 --> 00:42:53,070
going and you're still paying for that

00:42:50,910 --> 00:42:54,780
resource both a Tabas lambda you only

00:42:53,070 --> 00:43:00,170
have to worry about whenever it gets

00:42:54,780 --> 00:43:04,080
executed that make sense last question

00:43:00,170 --> 00:43:05,550
okay and another question okay if I get

00:43:04,080 --> 00:43:07,800
like denial service attack

00:43:05,550 --> 00:43:11,310
you told like you scales like yeah crazy

00:43:07,800 --> 00:43:14,400
like would Amazon boo me all that d-does

00:43:11,310 --> 00:43:16,650
um for the we're talking about detoxing

00:43:14,400 --> 00:43:19,290
how does it work is it denial of service

00:43:16,650 --> 00:43:20,370
so I I get a little traffic the Amazon

00:43:19,290 --> 00:43:24,180
can handle it

00:43:20,370 --> 00:43:25,560
but to on my expense like how oh yeah so

00:43:24,180 --> 00:43:26,910
where you'd have to probably set up is

00:43:25,560 --> 00:43:28,950
in terms you can actually set up

00:43:26,910 --> 00:43:30,270
dawdling through API gateway and that'll

00:43:28,950 --> 00:43:32,250
actually handle to make sure that your

00:43:30,270 --> 00:43:33,900
land of function gives and get voc to

00:43:32,250 --> 00:43:36,660
way too many times so you can avoid that

00:43:33,900 --> 00:43:39,750
you can just kept it right yeah okay

00:43:36,660 --> 00:43:43,340
thank you actually I think we have time

00:43:39,750 --> 00:43:43,340
for one last question if anyone has one

00:43:46,990 --> 00:43:51,190
hey thank you for the talk yep so I just

00:43:49,690 --> 00:43:52,570
look it up on the internet and it seems

00:43:51,190 --> 00:43:55,060
like there are some limitations

00:43:52,570 --> 00:43:57,510
well of course it's everywhere and it

00:43:55,060 --> 00:44:00,430
seems like you can heavenly thousand

00:43:57,510 --> 00:44:03,880
parallel threads like France and brats

00:44:00,430 --> 00:44:05,770
is executed for one function one lambda

00:44:03,880 --> 00:44:08,320
function so my question is what if you

00:44:05,770 --> 00:44:10,119
need to serve more than thousand PPS can

00:44:08,320 --> 00:44:12,520
you repeat that again I think at last

00:44:10,119 --> 00:44:14,859
yessir basically I looked at Amazon

00:44:12,520 --> 00:44:16,960
websites talking about restrictions so

00:44:14,859 --> 00:44:21,010
there are limitations you can run

00:44:16,960 --> 00:44:22,599
I think 1024 threads and processes for

00:44:21,010 --> 00:44:24,250
one lambda function in parallel at the

00:44:22,599 --> 00:44:28,330
same time what if you need to serve more

00:44:24,250 --> 00:44:30,040
than 1,000 queue pairs sorry so I

00:44:28,330 --> 00:44:31,660
believe it that's just a your cap on

00:44:30,040 --> 00:44:33,400
terms of lambda functions in terms of

00:44:31,660 --> 00:44:36,880
having it invoke I believe that's not

00:44:33,400 --> 00:44:38,830
the limit is it well that's what I what

00:44:36,880 --> 00:44:40,359
I've seen maybe I didn't I'm pretty sure

00:44:38,830 --> 00:44:42,970
you can only have a bet you can only

00:44:40,359 --> 00:44:44,589
have 1024 I think that was the I think

00:44:42,970 --> 00:44:46,570
that's what the current limit is of just

00:44:44,589 --> 00:44:49,109
simultaneous lambda functions going like

00:44:46,570 --> 00:44:51,730
there Seifer 8 there's separate ones

00:44:49,109 --> 00:44:53,440
okay so it's not like Challis will have

00:44:51,730 --> 00:44:54,940
the same lambda function for your API so

00:44:53,440 --> 00:44:56,080
you can hit that as much do you want

00:44:54,940 --> 00:44:57,790
there won't be an issue with that okay

00:44:56,080 --> 00:45:00,609
make sense so snug annotations ok cool

00:44:57,790 --> 00:45:01,890
things yeah all right thank everyone

00:45:00,609 --> 00:45:05,440
perhaps

00:45:01,890 --> 00:45:05,440

YouTube URL: https://www.youtube.com/watch?v=33-0xdxp9-I


