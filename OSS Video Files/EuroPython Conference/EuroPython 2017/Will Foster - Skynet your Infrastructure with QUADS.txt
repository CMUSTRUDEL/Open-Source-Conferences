Title: Will Foster - Skynet your Infrastructure with QUADS
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Skynet your Infrastructure with QUADS
[EuroPython 2017 - Talk - 2017-07-11 - Anfiteatro 1]
[Rimini, Italy]

The very small 2-person DevOps team within Red Hat Performance/Scale Engineering has developed a set of Open Source Python-based systems and network automation provisioning tools designed to end-to-end automate the provisioning of large-scale systems and network switches using tools like Foreman, Ansible, and other Open Source bits.

QUADS – or “quick and dirty scheduler” allows a normally overburdened DevOps warrior to fully automate large swaths of systems and network devices based on a schedule, even set systems provisioning to fire off in the future so they can focus on important things like Netflix and popcorn or not reading your emails while your datacenter burns in an inferno of rapid, automated skynet provisioning. QUADS will also auto-generate up-to-date infrastructure documentation, track scheduling, systems assignments and more.

In this talk we’ll show you how we’re using QUADS (backed by Foreman) to empower rapid, meaningful performance and scale testing of Red Hat products and technologies. While QUADS is a new project and under constant development, the design approach to handling large-scale systems provisioning as well as the current codebase is consumable for others interested in improving the efficiency and level of automation within their infrastructure.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,120 --> 00:00:10,799
buon pomeriggio or Godsey to Tula talk

00:00:08,530 --> 00:00:14,469
in italiano

00:00:10,799 --> 00:00:16,480
allora this talk will be in English

00:00:14,469 --> 00:00:18,520
thank God because my time is terrible as

00:00:16,480 --> 00:00:20,439
you can tell and I apologize if I've

00:00:18,520 --> 00:00:23,169
offended anybody in the audience just

00:00:20,439 --> 00:00:25,619
now so my name is will Foster

00:00:23,169 --> 00:00:27,700
I'm a DevOps engineer at Red Hat and

00:00:25,619 --> 00:00:30,219
today I'm going to be talking about an

00:00:27,700 --> 00:00:32,559
exciting new Python based framework

00:00:30,219 --> 00:00:34,180
called quads that we've developed

00:00:32,559 --> 00:00:36,820
in-house that solves some of the

00:00:34,180 --> 00:00:40,539
problems that we have and I'm just going

00:00:36,820 --> 00:00:43,239
to get right into it so before I kind of

00:00:40,539 --> 00:00:45,280
explain what quads is and how we've

00:00:43,239 --> 00:00:47,079
built this sort of framework to solve

00:00:45,280 --> 00:00:49,449
some of our infrastructure and

00:00:47,079 --> 00:00:52,329
automation problems I want to explain

00:00:49,449 --> 00:00:54,969
what I do at Red Hat I'm on a very small

00:00:52,329 --> 00:00:58,030
team of two people and there's not

00:00:54,969 --> 00:01:00,879
enough car analogies on the Internet in

00:00:58,030 --> 00:01:03,069
fact there's never been a car analogy

00:01:00,879 --> 00:01:07,090
used for open-source it's never happened

00:01:03,069 --> 00:01:09,520
so I'm going to use a car analogy here

00:01:07,090 --> 00:01:11,590
to kind of explain what what I do and

00:01:09,520 --> 00:01:14,830
what my other colleague does on the dev

00:01:11,590 --> 00:01:17,350
app side so I want to talk about high

00:01:14,830 --> 00:01:20,710
performance computer servers as race

00:01:17,350 --> 00:01:24,130
cars very high performance you know

00:01:20,710 --> 00:01:28,090
fully spec the latest Intel AMD chipsets

00:01:24,130 --> 00:01:33,130
as as race cars and high-performance

00:01:28,090 --> 00:01:35,860
networks would be the racetracks and the

00:01:33,130 --> 00:01:38,440
race car races that run on these tracks

00:01:35,860 --> 00:01:40,990
would be performance and scale testing

00:01:38,440 --> 00:01:43,150
of various open-source products that Red

00:01:40,990 --> 00:01:46,110
Hat delet develops and also upstream

00:01:43,150 --> 00:01:48,250
things like OpenStack and openshift and

00:01:46,110 --> 00:01:50,440
kubernetes and different types of

00:01:48,250 --> 00:01:54,040
technologies that we want to test and

00:01:50,440 --> 00:01:56,530
vet at a very large scale and the actual

00:01:54,040 --> 00:01:58,870
racecar drivers themselves that are

00:01:56,530 --> 00:02:02,860
driving these servers that are race cars

00:01:58,870 --> 00:02:06,880
on these fast tracks 40 gig hundred gig

00:02:02,860 --> 00:02:08,560
networking or race tracks are the race

00:02:06,880 --> 00:02:11,590
car drivers they're the scale engineers

00:02:08,560 --> 00:02:13,239
and that's a pretty cool analogy to have

00:02:11,590 --> 00:02:14,980
if someone says what do you do why drive

00:02:13,239 --> 00:02:16,590
race cars so that's kind of throwing a

00:02:14,980 --> 00:02:18,150
bone to more of the core

00:02:16,590 --> 00:02:20,220
performance and scale engineers by Colin

00:02:18,150 --> 00:02:21,870
and racecar drivers but I look at myself

00:02:20,220 --> 00:02:23,550
and my colleague on kind of the the

00:02:21,870 --> 00:02:25,739
DevOps side as we're the pit crew and

00:02:23,550 --> 00:02:28,800
we're the track engineers and our goal

00:02:25,739 --> 00:02:31,260
is to make as many races happen all the

00:02:28,800 --> 00:02:35,310
time as efficiently as possible without

00:02:31,260 --> 00:02:38,940
any wrecks or explosions and those do

00:02:35,310 --> 00:02:41,099
happen which I'll get to and this tool

00:02:38,940 --> 00:02:43,650
quads helps us automate the entire thing

00:02:41,099 --> 00:02:47,160
including writing our documentation for

00:02:43,650 --> 00:02:50,010
us configuring VLANs on juniper and

00:02:47,160 --> 00:02:51,959
Cisco switches and the full lifecycle of

00:02:50,010 --> 00:02:53,610
provisioning bare-metal server spinning

00:02:51,959 --> 00:02:55,530
them up passing them to an engineering

00:02:53,610 --> 00:02:57,090
group for product and scale testing and

00:02:55,530 --> 00:03:01,860
then spinning them down when they're

00:02:57,090 --> 00:03:03,299
done so if this was either a terrible

00:03:01,860 --> 00:03:05,069
analogy or an awesome one I have a very

00:03:03,299 --> 00:03:07,640
simplified one and this is the Reader's

00:03:05,069 --> 00:03:10,650
Digest version which basically we manage

00:03:07,640 --> 00:03:13,019
300 or so high performance servers and

00:03:10,650 --> 00:03:14,910
switches and a large infrastructure and

00:03:13,019 --> 00:03:18,450
this infrastructure accommodates

00:03:14,910 --> 00:03:21,329
parallel product testing and it's really

00:03:18,450 --> 00:03:23,459
comprised of isolated sets of machines

00:03:21,329 --> 00:03:26,519
we refer to them as clouds because we're

00:03:23,459 --> 00:03:28,459
not very creative for different

00:03:26,519 --> 00:03:31,260
workloads that happen simultaneously and

00:03:28,459 --> 00:03:33,420
with quads we have basically automated

00:03:31,260 --> 00:03:35,609
our entire jobs we've automated ourself

00:03:33,420 --> 00:03:38,579
out of a job and instead of spending the

00:03:35,609 --> 00:03:41,579
time going in being being network

00:03:38,579 --> 00:03:43,349
engineers being systems folks that have

00:03:41,579 --> 00:03:45,389
to deploy servers we've automated all of

00:03:43,349 --> 00:03:46,859
this with Python and we instead spend

00:03:45,389 --> 00:03:52,650
our time on actually improving the

00:03:46,859 --> 00:03:54,630
automation so what is quads and what

00:03:52,650 --> 00:03:56,310
isn't it what what sort of things does

00:03:54,630 --> 00:03:58,829
it do and not do well it's not an

00:03:56,310 --> 00:04:01,410
installer it's not a provisioning system

00:03:58,829 --> 00:04:01,950
it bridges several interchangeable tools

00:04:01,410 --> 00:04:05,400
together

00:04:01,950 --> 00:04:07,470
I mentioned Foreman because that is our

00:04:05,400 --> 00:04:09,450
back-end provisioning vehicle that we

00:04:07,470 --> 00:04:11,010
use but we we designed quads in a way

00:04:09,450 --> 00:04:13,470
that if you have an existing

00:04:11,010 --> 00:04:14,760
provisioning system or a workflow or

00:04:13,470 --> 00:04:17,070
anything that you're used to you can

00:04:14,760 --> 00:04:18,630
plug that into quads quads will simply

00:04:17,070 --> 00:04:20,820
call out to your provisioning system to

00:04:18,630 --> 00:04:23,280
do you know re kicking machines

00:04:20,820 --> 00:04:24,719
reprovision machines or pushing image

00:04:23,280 --> 00:04:27,539
based deployments across a lot of

00:04:24,719 --> 00:04:29,870
servers and it also helps us automate

00:04:27,539 --> 00:04:31,430
basically the boring things that

00:04:29,870 --> 00:04:33,169
maybe you do once or twice and it's

00:04:31,430 --> 00:04:36,830
exciting but you never want to do again

00:04:33,169 --> 00:04:39,020
you know I love network engineering I

00:04:36,830 --> 00:04:40,580
love connectivity I like switches and

00:04:39,020 --> 00:04:41,270
firewalls but I don't want to do that

00:04:40,580 --> 00:04:43,880
for a living

00:04:41,270 --> 00:04:45,860
I would rather automation do it for me

00:04:43,880 --> 00:04:49,070
because it makes a lot less mistakes and

00:04:45,860 --> 00:04:51,680
it's frankly better at it but basically

00:04:49,070 --> 00:04:53,330
our goal is to build a system that

00:04:51,680 --> 00:04:54,889
orchestrates and builds all the other

00:04:53,330 --> 00:04:57,560
systems and only spend our time

00:04:54,889 --> 00:04:59,570
maintaining that automation framework

00:04:57,560 --> 00:05:03,200
and trying to waste as little time as

00:04:59,570 --> 00:05:04,880
possible being Hardware people or being

00:05:03,200 --> 00:05:07,220
Network people or storage people because

00:05:04,880 --> 00:05:12,020
you know it gets boring when you do just

00:05:07,220 --> 00:05:14,210
one thing so what is quads from kind of

00:05:12,020 --> 00:05:14,960
a high level we drive everything with

00:05:14,210 --> 00:05:17,419
PMO

00:05:14,960 --> 00:05:20,150
so the idea the top-level idea is that

00:05:17,419 --> 00:05:23,240
for every asset in our infrastructure we

00:05:20,150 --> 00:05:25,430
have a yamo based schedule that tells it

00:05:23,240 --> 00:05:28,100
where it's what it's supposed to be

00:05:25,430 --> 00:05:30,560
doing from what start date and what end

00:05:28,100 --> 00:05:32,780
date and what isolated worker assignment

00:05:30,560 --> 00:05:35,240
and this way we can programmatically

00:05:32,780 --> 00:05:37,490
schedule things in the future you know

00:05:35,240 --> 00:05:39,560
in an ideal world you would know the

00:05:37,490 --> 00:05:41,810
development schedule of all of your

00:05:39,560 --> 00:05:44,690
engineering groups you would say you

00:05:41,810 --> 00:05:47,360
know in November team a is going to be

00:05:44,690 --> 00:05:49,220
releasing a beta of project project Y

00:05:47,360 --> 00:05:51,169
and team C is going to be doing the same

00:05:49,220 --> 00:05:52,910
thing and if you knew what people's

00:05:51,169 --> 00:05:54,830
needs were ahead of time you can

00:05:52,910 --> 00:05:58,310
schedule compute and network resources

00:05:54,830 --> 00:06:00,410
in advance the reality of it is none of

00:05:58,310 --> 00:06:05,150
that ever happens like you would like it

00:06:00,410 --> 00:06:07,310
to deadlines shift there's different

00:06:05,150 --> 00:06:09,080
holdups and blockers with bugs and

00:06:07,310 --> 00:06:10,940
different projects and how you perceive

00:06:09,080 --> 00:06:13,160
the world to ideally be is never

00:06:10,940 --> 00:06:14,750
actually how it turns out to be so we've

00:06:13,160 --> 00:06:20,090
baked in a little bit of resilience into

00:06:14,750 --> 00:06:21,919
how we schedule things in the future so

00:06:20,090 --> 00:06:23,240
a little bit more detail about how it

00:06:21,919 --> 00:06:25,880
actually manages this kind of

00:06:23,240 --> 00:06:28,700
programmatic gamal driven scheduling and

00:06:25,880 --> 00:06:32,270
provisioning we set aside the amyl

00:06:28,700 --> 00:06:34,310
schedule for server assets and then we

00:06:32,270 --> 00:06:37,010
automate basically the entire lifecycle

00:06:34,310 --> 00:06:37,550
of a set of machines from beginning to

00:06:37,010 --> 00:06:40,460
end

00:06:37,550 --> 00:06:43,700
automatically so on a Sunday at 2200 UTC

00:06:40,460 --> 00:06:47,180
if you're going to be receiving

00:06:43,700 --> 00:06:48,980
say two hundred servers and a what we

00:06:47,180 --> 00:06:50,980
would call a Q and Q zero or a specific

00:06:48,980 --> 00:06:53,030
VLAN configuration that we support

00:06:50,980 --> 00:06:55,420
automatically your machines would spin

00:06:53,030 --> 00:06:57,380
up they would reprovision

00:06:55,420 --> 00:06:59,150
tooling would go out to each of the

00:06:57,380 --> 00:07:01,190
switches and configure VLAN so you would

00:06:59,150 --> 00:07:02,680
have one isolated environment separate

00:07:01,190 --> 00:07:06,190
from the other engineering groups and

00:07:02,680 --> 00:07:08,390
things like a foreman self-service

00:07:06,190 --> 00:07:10,220
account will be created you would have

00:07:08,390 --> 00:07:11,120
your own IP my credentials to get into

00:07:10,220 --> 00:07:13,640
the machines out-of-band

00:07:11,120 --> 00:07:17,060
and then our documentation would be

00:07:13,640 --> 00:07:19,010
automatically generated to reflect the

00:07:17,060 --> 00:07:21,440
current state of what your machines are

00:07:19,010 --> 00:07:25,310
doing and who is using all of the assets

00:07:21,440 --> 00:07:27,290
inside of an environment so like how do

00:07:25,310 --> 00:07:30,200
we how do we use this internally at Red

00:07:27,290 --> 00:07:31,490
Hat so we have a large Rd environment

00:07:30,200 --> 00:07:34,190
called the scale lab and this is where

00:07:31,490 --> 00:07:37,390
we test and vet all of our products you

00:07:34,190 --> 00:07:42,590
know Red Hat Enterprise Linux OpenStack

00:07:37,390 --> 00:07:43,910
you know Rev satellite just I don't even

00:07:42,590 --> 00:07:46,820
know how many products we have but we

00:07:43,910 --> 00:07:48,800
had some s where we test it and there's

00:07:46,820 --> 00:07:52,010
it's a very special place because all

00:07:48,800 --> 00:07:54,200
the hardware is deemed high performance

00:07:52,010 --> 00:07:55,640
scale gear you know we used 100 Gig

00:07:54,200 --> 00:07:57,230
networking across the board it's all

00:07:55,640 --> 00:07:59,060
very high in servers and it's not a

00:07:57,230 --> 00:08:01,700
place for you to have a development test

00:07:59,060 --> 00:08:04,580
bet it's a place for you that if you you

00:08:01,700 --> 00:08:06,370
are doing development work and you hit

00:08:04,580 --> 00:08:09,470
what could potentially be a scale issue

00:08:06,370 --> 00:08:11,750
with any sort of bits of the application

00:08:09,470 --> 00:08:13,700
stack and you're able to reproduce this

00:08:11,750 --> 00:08:16,250
issue on a smaller scale this is where

00:08:13,700 --> 00:08:19,820
you go to run it at a very large scale

00:08:16,250 --> 00:08:22,460
so we can anticipate how customers using

00:08:19,820 --> 00:08:24,980
our software would that would do in the

00:08:22,460 --> 00:08:26,960
real world ideally we would identify

00:08:24,980 --> 00:08:29,300
issues before other customers to them

00:08:26,960 --> 00:08:31,370
but again that's not always the case

00:08:29,300 --> 00:08:33,650
so in our Red Hat scale lab we have

00:08:31,370 --> 00:08:35,990
about 300 servers we have 40 or 50 high

00:08:33,650 --> 00:08:37,820
performance juniper switches and right

00:08:35,990 --> 00:08:39,860
now where you run about 16 to 20

00:08:37,820 --> 00:08:42,050
different isolated scale and performance

00:08:39,860 --> 00:08:44,720
workload on these systems for up to four

00:08:42,050 --> 00:08:46,820
weeks at a time and these and quads

00:08:44,720 --> 00:08:48,470
helps us spin up these machines hand

00:08:46,820 --> 00:08:50,300
them over to the appropriate people for

00:08:48,470 --> 00:08:51,980
short term lease and then spin them back

00:08:50,300 --> 00:08:54,800
down again and put them in kind of an

00:08:51,980 --> 00:08:57,170
allocation pool so I'll give you an

00:08:54,800 --> 00:08:59,269
example and let's look at some picture

00:08:57,170 --> 00:09:01,790
because everyone likes pictures so this

00:08:59,269 --> 00:09:03,769
is the example of some of the scheduling

00:09:01,790 --> 00:09:06,709
that we do automatically so this is from

00:09:03,769 --> 00:09:09,560
February to May of this year and you can

00:09:06,709 --> 00:09:11,720
see how we've very efficiently done

00:09:09,560 --> 00:09:14,300
back-to-back scheduling of all of the

00:09:11,720 --> 00:09:17,720
machines in environment and you can see

00:09:14,300 --> 00:09:20,180
you know four to five parallel running

00:09:17,720 --> 00:09:21,800
workloads testing different products

00:09:20,180 --> 00:09:24,649
different scale different aspects of

00:09:21,800 --> 00:09:26,510
different products and all of this when

00:09:24,649 --> 00:09:28,670
it's scheduled in advance all happens

00:09:26,510 --> 00:09:30,320
automatically so we don't ever have to

00:09:28,670 --> 00:09:32,329
waste time there's a two person team we

00:09:30,320 --> 00:09:34,550
got a lot of infrastructure so we don't

00:09:32,329 --> 00:09:39,440
have to waste time manually setting up

00:09:34,550 --> 00:09:40,970
any of this stuff nor would you here's

00:09:39,440 --> 00:09:42,589
an example of you know some of the

00:09:40,970 --> 00:09:44,269
metrics that we've gotten from the lab I

00:09:42,589 --> 00:09:48,079
just kind of picked this at random this

00:09:44,269 --> 00:09:49,760
is a storage workload you know and these

00:09:48,079 --> 00:09:51,860
are some of the results that we get out

00:09:49,760 --> 00:09:54,250
of out of the scale lab and quads kind

00:09:51,860 --> 00:09:57,350
of empowers us to do this sort of work

00:09:54,250 --> 00:09:59,029
so we talked a little bit about the time

00:09:57,350 --> 00:10:01,070
savings and efficiency but I want to

00:09:59,029 --> 00:10:03,079
drill down more into what problems we're

00:10:01,070 --> 00:10:06,140
actually solving here besides the

00:10:03,079 --> 00:10:07,610
obvious so the first one is server

00:10:06,140 --> 00:10:11,870
hugging does anyone know what server

00:10:07,610 --> 00:10:13,459
hugging is okay so server hugging is the

00:10:11,870 --> 00:10:15,140
idea once I explain it you'll be like oh

00:10:13,459 --> 00:10:17,750
yeah I know server target so server

00:10:15,140 --> 00:10:20,000
hugging is the idea that if you give

00:10:17,750 --> 00:10:22,130
someone a resource they're going to hold

00:10:20,000 --> 00:10:25,820
onto it as long as possible until you

00:10:22,130 --> 00:10:28,399
pull it back from them developers are

00:10:25,820 --> 00:10:30,320
very bad at server hugging and usually

00:10:28,399 --> 00:10:31,579
there's always more of a demand for

00:10:30,320 --> 00:10:33,980
resources than there are actual

00:10:31,579 --> 00:10:36,350
resources to give people so if you're

00:10:33,980 --> 00:10:37,970
lucky enough that you know your manager

00:10:36,350 --> 00:10:41,300
is particularly savvy and he can fight

00:10:37,970 --> 00:10:43,250
for a budget to have this Rd dev test

00:10:41,300 --> 00:10:44,569
Hardware and he's better than the other

00:10:43,250 --> 00:10:46,339
managers at it then you're going to have

00:10:44,569 --> 00:10:48,019
more gear to play on but the sad reality

00:10:46,339 --> 00:10:50,149
is is there's never enough bare metal

00:10:48,019 --> 00:10:51,800
hardware unless your Facebook or Google

00:10:50,149 --> 00:10:55,490
or you know one of these behemoths that

00:10:51,800 --> 00:10:57,440
you're not going to have bare metal high

00:10:55,490 --> 00:10:59,240
end server hardware to run your code and

00:10:57,440 --> 00:11:01,399
test against all the time when you want

00:10:59,240 --> 00:11:03,740
it so server hugging is the idea that

00:11:01,399 --> 00:11:05,329
there's this tendency of people to hold

00:11:03,740 --> 00:11:07,310
on to things longer than they should and

00:11:05,329 --> 00:11:09,620
it's a natural human thing you know you

00:11:07,310 --> 00:11:10,520
you've given something you want to use

00:11:09,620 --> 00:11:11,870
it and

00:11:10,520 --> 00:11:13,790
kind of become protective over it it's

00:11:11,870 --> 00:11:16,100
your it's your pet it's your it's your

00:11:13,790 --> 00:11:18,550
area as yours but it's not really yours

00:11:16,100 --> 00:11:22,820
you got to share it with other people so

00:11:18,550 --> 00:11:24,320
by having automated scheduling of part

00:11:22,820 --> 00:11:27,680
of server resources and network

00:11:24,320 --> 00:11:29,300
resources you sort of force people to be

00:11:27,680 --> 00:11:32,390
more efficient with their planning you

00:11:29,300 --> 00:11:34,610
force them to maximize the time that

00:11:32,390 --> 00:11:36,350
they would have on a set of hardware and

00:11:34,610 --> 00:11:41,240
you can save a whole lot of money in

00:11:36,350 --> 00:11:42,320
time by doing it this way so what's the

00:11:41,240 --> 00:11:44,300
other things that we saw will we

00:11:42,320 --> 00:11:46,250
automate things no there's there's

00:11:44,300 --> 00:11:48,890
there's less human error that's good

00:11:46,250 --> 00:11:51,500
with more automation and to a certain

00:11:48,890 --> 00:11:54,110
extent you can kind of give control over

00:11:51,500 --> 00:11:56,200
to the machines because you know what's

00:11:54,110 --> 00:12:09,470
what's the worst that's going to happen

00:11:56,200 --> 00:12:15,430
you know at that point there's obviously

00:12:09,470 --> 00:12:15,430
bugs and clods and kill - 9 terminate

00:12:15,670 --> 00:12:23,180
there's obviously some rough edges and

00:12:18,310 --> 00:12:24,470
in our software as there are but you

00:12:23,180 --> 00:12:27,140
know the idea is that you automate as

00:12:24,470 --> 00:12:30,079
much as possible you know the biggest

00:12:27,140 --> 00:12:33,950
area of devastation is on the network

00:12:30,079 --> 00:12:36,920
side it hits one typo to configure the

00:12:33,950 --> 00:12:38,630
wrong port and totally offline a machine

00:12:36,920 --> 00:12:40,430
or just cause straight-up havoc so

00:12:38,630 --> 00:12:43,610
simply just automating the network

00:12:40,430 --> 00:12:47,990
administration is a huge boon to having

00:12:43,610 --> 00:12:50,839
errors the downside is when automation

00:12:47,990 --> 00:12:53,620
fails it normally fails in glorious ways

00:12:50,839 --> 00:12:55,880
it's normally just a giant explosion

00:12:53,620 --> 00:12:57,440
slow-motion train wreck when your

00:12:55,880 --> 00:12:59,329
automation actually fails because it's

00:12:57,440 --> 00:13:01,579
so efficient at something and if that

00:12:59,329 --> 00:13:04,459
something has errors then it's going to

00:13:01,579 --> 00:13:05,779
be catastrophic so Dave Wilson if you're

00:13:04,459 --> 00:13:08,180
watching this I'm really sorry about

00:13:05,779 --> 00:13:12,410
your 50 machines that got eaten by our

00:13:08,180 --> 00:13:13,579
network bug but it's fixed now so what

00:13:12,410 --> 00:13:15,649
are the other things that we're solving

00:13:13,579 --> 00:13:18,110
here so we want to maximize idle machine

00:13:15,649 --> 00:13:21,079
cycles electricity is expensive carbon

00:13:18,110 --> 00:13:22,820
footprint is always an issue and we want

00:13:21,079 --> 00:13:25,170
to automate and spin up machines only

00:13:22,820 --> 00:13:40,780
when there

00:13:25,170 --> 00:13:42,340
reprovision whew where were we so what

00:13:40,780 --> 00:13:43,150
we do is we power off machines when

00:13:42,340 --> 00:13:45,900
they're not in use

00:13:43,150 --> 00:13:48,100
and only when they have an active

00:13:45,900 --> 00:13:51,550
schedule in their llamo config did they

00:13:48,100 --> 00:13:53,020
actually come alive and get participate

00:13:51,550 --> 00:13:56,110
in some sort of an automated workload

00:13:53,020 --> 00:13:58,810
and sometimes they they don't work like

00:13:56,110 --> 00:14:00,970
you'd like them to but that's kind of

00:13:58,810 --> 00:14:05,470
the double-edged sort of of automating

00:14:00,970 --> 00:14:08,320
things so lastly we want to solve the

00:14:05,470 --> 00:14:11,140
scheduling issues we we go with short

00:14:08,320 --> 00:14:13,080
term reservation so if you rent say a

00:14:11,140 --> 00:14:15,700
hundred machines if you use quads and

00:14:13,080 --> 00:14:17,350
you get assigned 100 machines in a

00:14:15,700 --> 00:14:18,990
particular VLAN configuration to your

00:14:17,350 --> 00:14:21,490
development and your testing at scale

00:14:18,990 --> 00:14:23,230
the maximum you can keep it as 4 weeks

00:14:21,490 --> 00:14:25,690
there's we only have a couple hundred

00:14:23,230 --> 00:14:27,220
servers but we have queued up almost a

00:14:25,690 --> 00:14:29,200
month wait time to get to those those

00:14:27,220 --> 00:14:34,660
resources so we want to be more like

00:14:29,200 --> 00:14:37,600
Airbnb and less like a hobo house Airbnb

00:14:34,660 --> 00:14:39,370
has very defined guidelines you can't

00:14:37,600 --> 00:14:41,640
stay in an Airbnb longer than four weeks

00:14:39,370 --> 00:14:44,440
and it has uniformed for the most part

00:14:41,640 --> 00:14:46,540
kind of things you would expect from a

00:14:44,440 --> 00:14:49,090
Airbnb you know you generally know what

00:14:46,540 --> 00:14:50,260
you're going to get maybe not but it's a

00:14:49,090 --> 00:14:54,660
little more polished and professional

00:14:50,260 --> 00:14:57,310
than you know like say a hobo house and

00:14:54,660 --> 00:14:58,840
the last thing that we really save here

00:14:57,310 --> 00:15:01,420
and this is kind of the impetus for us

00:14:58,840 --> 00:15:03,550
continuing to for us to automate our

00:15:01,420 --> 00:15:06,580
jobs and then work on the automation is

00:15:03,550 --> 00:15:08,410
the time savings and the cost savings so

00:15:06,580 --> 00:15:11,470
we had done some kind of back of the

00:15:08,410 --> 00:15:13,870
envelope math of using 100 machines for

00:15:11,470 --> 00:15:16,930
an example if 100 machines change hands

00:15:13,870 --> 00:15:18,490
tomorrow and went from one development

00:15:16,930 --> 00:15:20,380
group working on something or a set of

00:15:18,490 --> 00:15:21,700
developers with a specific scale or

00:15:20,380 --> 00:15:24,520
performance problem they were trying to

00:15:21,700 --> 00:15:26,830
fix what would be the cost and the time

00:15:24,520 --> 00:15:30,880
involved if someone was to do that

00:15:26,830 --> 00:15:32,710
manually now granted in 2017 I hope no

00:15:30,880 --> 00:15:35,260
one is doing all of this by hand I hope

00:15:32,710 --> 00:15:36,529
people aren't inserting an ISO into a

00:15:35,260 --> 00:15:39,470
server somewhere and

00:15:36,529 --> 00:15:41,029
someone's on a SSH console and a switch

00:15:39,470 --> 00:15:43,910
and I hope people aren't doing it that

00:15:41,029 --> 00:15:45,740
way maybe some people are but assuming

00:15:43,910 --> 00:15:48,199
that you did do everything manually it

00:15:45,740 --> 00:15:51,170
would take roughly 90 hours of work to

00:15:48,199 --> 00:15:53,300
provision 100 servers and pass them off

00:15:51,170 --> 00:15:55,699
to someone else so for our current

00:15:53,300 --> 00:15:56,689
two-person team that would be about 45

00:15:55,699 --> 00:15:59,389
hours apiece

00:15:56,689 --> 00:16:02,689
over a week of work and if we tripled

00:15:59,389 --> 00:16:04,069
our team it would be about 15 hours or 2

00:16:02,689 --> 00:16:05,600
working days and we've we had a 12

00:16:04,069 --> 00:16:06,759
person team we could maybe get it done

00:16:05,600 --> 00:16:10,779
in a day

00:16:06,759 --> 00:16:13,240
so quads does all of this on Sundays

00:16:10,779 --> 00:16:15,649
when most people aren't working and

00:16:13,240 --> 00:16:18,110
automates the entire thing and a span of

00:16:15,649 --> 00:16:20,569
2 or 3 hours so when Monday Monday

00:16:18,110 --> 00:16:22,220
Monday morning rolls around machines are

00:16:20,569 --> 00:16:23,449
already passed off notifications are

00:16:22,220 --> 00:16:25,069
already sent to the users they already

00:16:23,449 --> 00:16:26,600
have their own special credentials to

00:16:25,069 --> 00:16:28,699
access the machines that only they have

00:16:26,600 --> 00:16:32,120
and then the clock starts ticking on the

00:16:28,699 --> 00:16:33,410
reservation so I'm not going to drill

00:16:32,120 --> 00:16:35,509
into this but this is kind of how we

00:16:33,410 --> 00:16:37,009
came up with this figure and these are

00:16:35,509 --> 00:16:41,509
pretty conservative estimates of

00:16:37,009 --> 00:16:43,819
everything that we do all right

00:16:41,509 --> 00:16:45,589
so how does quads actually do all of

00:16:43,819 --> 00:16:47,449
this we've talked about the problems

00:16:45,589 --> 00:16:49,939
that we're going to solve with it that

00:16:47,449 --> 00:16:51,410
we solve today we talked about the level

00:16:49,939 --> 00:16:52,939
of automation and efficiency that we're

00:16:51,410 --> 00:16:56,180
able to yield but how does it actually

00:16:52,939 --> 00:16:59,750
look on the back end so I have made some

00:16:56,180 --> 00:17:01,250
rather grotesque topographical images

00:16:59,750 --> 00:17:02,839
for you this is not going to win any

00:17:01,250 --> 00:17:05,329
website awards but we all remember

00:17:02,839 --> 00:17:07,850
Milton from office space we're going to

00:17:05,329 --> 00:17:10,610
say he's your typical scale engineer and

00:17:07,850 --> 00:17:12,579
he needs hardware so this is the kind of

00:17:10,610 --> 00:17:15,520
quads architecture at a very high level

00:17:12,579 --> 00:17:18,799
we have now a JSON API in front of it

00:17:15,520 --> 00:17:21,350
but generally speaking there's also a

00:17:18,799 --> 00:17:24,980
daemon and also a CLI that you interact

00:17:21,350 --> 00:17:27,709
with at it's very basic constructs there

00:17:24,980 --> 00:17:29,690
is a yam Allah is constantly modified by

00:17:27,709 --> 00:17:31,370
PI llamo and and I'll give you an

00:17:29,690 --> 00:17:34,520
example of that a couple of slides later

00:17:31,370 --> 00:17:37,309
but this is at the heart of how things

00:17:34,520 --> 00:17:39,710
are automated in the present and in the

00:17:37,309 --> 00:17:41,929
future there's also some provisioning

00:17:39,710 --> 00:17:44,720
elements if we want to do any graphing

00:17:41,929 --> 00:17:46,909
we have hooks into collecti and Ravana

00:17:44,720 --> 00:17:48,820
and we also can send results

00:17:46,909 --> 00:17:50,300
elasticsearch as well but this is more

00:17:48,820 --> 00:17:52,850
ancillary stuff

00:17:50,300 --> 00:17:54,590
we would set up after-the-fact automated

00:17:52,850 --> 00:17:57,440
of course and then lastly there's the

00:17:54,590 --> 00:18:00,890
the consumable here besides the actual

00:17:57,440 --> 00:18:02,990
machines is the documentation at any

00:18:00,890 --> 00:18:04,670
point anyone can look inside of this

00:18:02,990 --> 00:18:06,650
quads managed environment they can see

00:18:04,670 --> 00:18:09,050
what all the machines are doing what

00:18:06,650 --> 00:18:11,360
does the utilisation look like who has

00:18:09,050 --> 00:18:12,860
the machines what are they working on

00:18:11,360 --> 00:18:13,100
and for how long they'll be working on

00:18:12,860 --> 00:18:16,310
it

00:18:13,100 --> 00:18:19,220
so you when you provide transparency

00:18:16,310 --> 00:18:21,020
like this it's easier for people they

00:18:19,220 --> 00:18:23,210
don't have to ask you hey you got any

00:18:21,020 --> 00:18:24,620
spare machines guys or I have this

00:18:23,210 --> 00:18:26,060
project and want from now what's the

00:18:24,620 --> 00:18:27,350
schedule going to look like all this is

00:18:26,060 --> 00:18:30,860
already published and available to

00:18:27,350 --> 00:18:32,660
anyone who wants to look at it so

00:18:30,860 --> 00:18:35,330
there's tie-ins to the actual

00:18:32,660 --> 00:18:38,140
provisioning which is the next slide and

00:18:35,330 --> 00:18:40,520
there's a plug into quads basically a

00:18:38,140 --> 00:18:42,280
open-ended command that we call move

00:18:40,520 --> 00:18:45,320
hosts it's just a simple art barse

00:18:42,280 --> 00:18:47,390
option in quads but this is where you

00:18:45,320 --> 00:18:50,230
tie in your provisioning system so

00:18:47,390 --> 00:18:52,310
however you run the life cycle of

00:18:50,230 --> 00:18:53,900
provisioning on operating system or

00:18:52,310 --> 00:18:55,880
laying down an image over top of it

00:18:53,900 --> 00:18:58,220
whatever your method is you plug this

00:18:55,880 --> 00:18:59,570
into the move hosts command you define

00:18:58,220 --> 00:19:02,300
this in clause it can be whatever you

00:18:59,570 --> 00:19:04,010
want in our case we just use Foreman

00:19:02,300 --> 00:19:06,290
because that's one of the tools that we

00:19:04,010 --> 00:19:08,210
enjoy using and saves us some time so

00:19:06,290 --> 00:19:11,660
the quads moves host command would

00:19:08,210 --> 00:19:14,390
basically spit out if the time is

00:19:11,660 --> 00:19:16,820
running like if now is scheduled right

00:19:14,390 --> 00:19:18,740
now for a set of machines to change

00:19:16,820 --> 00:19:21,170
hands and go to another environment with

00:19:18,740 --> 00:19:22,700
another VLAN configuration we would get

00:19:21,170 --> 00:19:25,070
this printed out in our logs we would

00:19:22,700 --> 00:19:26,570
say this example server is moving from

00:19:25,070 --> 00:19:30,320
cloud zero one environment to clouds you

00:19:26,570 --> 00:19:32,840
or two as an example on the back end on

00:19:30,320 --> 00:19:35,330
the foreman end of a lease for us this

00:19:32,840 --> 00:19:38,630
is our provisioning workflow we would

00:19:35,330 --> 00:19:40,970
tie Foreman in to add and remove role

00:19:38,630 --> 00:19:44,000
based access for the host we would

00:19:40,970 --> 00:19:45,950
change the IPMI passwords so that users

00:19:44,000 --> 00:19:47,330
are isolated in their own environment we

00:19:45,950 --> 00:19:49,520
would do a full provision the offering

00:19:47,330 --> 00:19:51,110
system we would lay down any post

00:19:49,520 --> 00:19:53,210
configuration stuff and then we would

00:19:51,110 --> 00:19:55,250
actually move the VLANs on the physical

00:19:53,210 --> 00:19:57,500
switches depending on the VLAN design

00:19:55,250 --> 00:19:59,540
that we support and then lastly and I

00:19:57,500 --> 00:20:00,980
think more importantly is there's

00:19:59,540 --> 00:20:02,840
automatic network validation that

00:20:00,980 --> 00:20:03,810
happens we don't want to pass off a set

00:20:02,840 --> 00:20:04,980
of machines to people

00:20:03,810 --> 00:20:06,720
they're not ready to user if there's

00:20:04,980 --> 00:20:08,490
something wrong with them so we run

00:20:06,720 --> 00:20:11,040
automated validation two checks and

00:20:08,490 --> 00:20:12,750
checks and checks and if every one of

00:20:11,040 --> 00:20:15,270
the machines doesn't pass the network

00:20:12,750 --> 00:20:17,910
validation we get notified and then it

00:20:15,270 --> 00:20:19,950
continues to check in intervals until we

00:20:17,910 --> 00:20:22,860
fix the problem and then it finally

00:20:19,950 --> 00:20:24,720
passes validation and the consumers of

00:20:22,860 --> 00:20:26,940
the hardware of the of the isolated

00:20:24,720 --> 00:20:28,650
environment get notified through a

00:20:26,940 --> 00:20:32,700
couple different mechanisms usually IRC

00:20:28,650 --> 00:20:34,230
BOTS and email so we talked about the

00:20:32,700 --> 00:20:36,000
animal scheduled for hosts this is what

00:20:34,230 --> 00:20:39,030
it looks like this is kind of at its

00:20:36,000 --> 00:20:42,860
basic the construct of how the PMO

00:20:39,030 --> 00:20:45,630
drives current and future scheduling of

00:20:42,860 --> 00:20:48,000
machines and networks so we see this

00:20:45,630 --> 00:20:50,160
defined schedule here there very simple

00:20:48,000 --> 00:20:52,920
command of LS schedule will list you all

00:20:50,160 --> 00:20:55,290
of the all of the current the past

00:20:52,920 --> 00:20:58,050
current and future scheduling that quads

00:20:55,290 --> 00:21:00,740
knows about for a particular asset so

00:20:58,050 --> 00:21:03,900
the very bottom here number five that

00:21:00,740 --> 00:21:05,700
would be like say a current allocation

00:21:03,900 --> 00:21:08,490
that would be something that started

00:21:05,700 --> 00:21:11,910
June 28th and it's going to end the six

00:21:08,490 --> 00:21:14,570
of July or or has ended and we keep a

00:21:11,910 --> 00:21:17,880
historical record of this in the mo file

00:21:14,570 --> 00:21:20,360
because that drives the documentation

00:21:17,880 --> 00:21:27,320
and also the visualizations that we make

00:21:20,360 --> 00:21:30,990
so oh it's a documentation now I like

00:21:27,320 --> 00:21:32,130
writing documentation once in fact I

00:21:30,990 --> 00:21:34,650
don't even really like writing

00:21:32,130 --> 00:21:36,840
documentation but it's it's one of those

00:21:34,650 --> 00:21:39,180
things that is so critical to any sort

00:21:36,840 --> 00:21:41,550
of project or any sort of endeavor that

00:21:39,180 --> 00:21:43,530
it's also the most lacking aspect of

00:21:41,550 --> 00:21:47,160
documentation so we decided that one of

00:21:43,530 --> 00:21:49,170
the pillars of this quads framework

00:21:47,160 --> 00:21:51,030
would be to automate all of the things

00:21:49,170 --> 00:21:53,550
that we either don't want to do or we

00:21:51,030 --> 00:21:55,710
are going to screw up at some point if

00:21:53,550 --> 00:21:58,110
you had even outdated documentation is

00:21:55,710 --> 00:22:00,480
still better than no documentation but

00:21:58,110 --> 00:22:03,450
it's still terrible so our goal was to

00:22:00,480 --> 00:22:04,830
have absolutely up to date by the minute

00:22:03,450 --> 00:22:07,290
documentation and the way that we do

00:22:04,830 --> 00:22:09,390
that is we query our provisioning source

00:22:07,290 --> 00:22:11,130
in this case it's formant it could be

00:22:09,390 --> 00:22:14,160
anything else it could be ansible fax

00:22:11,130 --> 00:22:16,330
for example and then we we query quads

00:22:14,160 --> 00:22:17,770
because it knows about the past

00:22:16,330 --> 00:22:20,080
current and future schedule of

00:22:17,770 --> 00:22:22,540
everything in our infrastructure we

00:22:20,080 --> 00:22:25,270
parse it into markdown format and then

00:22:22,540 --> 00:22:27,910
we use an XML RP RP C Python library to

00:22:25,270 --> 00:22:29,380
push it up to a wiki page and then this

00:22:27,910 --> 00:22:30,520
is continually updated every minute

00:22:29,380 --> 00:22:31,120
anytime there's a change in the

00:22:30,520 --> 00:22:33,100
environment

00:22:31,120 --> 00:22:34,960
anytime of bare-metal servers added or

00:22:33,100 --> 00:22:36,910
removed this gets updated in the

00:22:34,960 --> 00:22:38,850
infrastructure documentation in this

00:22:36,910 --> 00:22:41,320
case we use WordPress it's got a nice

00:22:38,850 --> 00:22:42,880
API for this but it could be easily be

00:22:41,320 --> 00:22:46,210
media wiki or anything that supports

00:22:42,880 --> 00:22:47,590
some programmatic markdown format and

00:22:46,210 --> 00:22:48,850
again it doesn't even have to be

00:22:47,590 --> 00:22:52,060
markdown it's just that's what we

00:22:48,850 --> 00:22:54,400
currently use so this is an example of

00:22:52,060 --> 00:22:56,590
what it actually generates so this is

00:22:54,400 --> 00:22:58,960
the front sort of infrastructure

00:22:56,590 --> 00:23:01,180
documentation of a set of our servers

00:22:58,960 --> 00:23:03,700
and this is what is continually

00:23:01,180 --> 00:23:05,230
generated and updated over time we have

00:23:03,700 --> 00:23:07,150
your typical things you would expect

00:23:05,230 --> 00:23:10,780
from infrastructure Docs like a host

00:23:07,150 --> 00:23:13,030
name serial mac address IP address we

00:23:10,780 --> 00:23:14,440
have a link to a demand console but

00:23:13,030 --> 00:23:16,990
what's different from this then

00:23:14,440 --> 00:23:19,210
something that someone edits is that on

00:23:16,990 --> 00:23:20,290
the right hand side we have workload so

00:23:19,210 --> 00:23:22,390
if you were to click on that workload

00:23:20,290 --> 00:23:24,100
link you would drill down to exactly

00:23:22,390 --> 00:23:26,140
what those sets of machines are doing

00:23:24,100 --> 00:23:28,750
what is cloud zero 6 for example doing

00:23:26,140 --> 00:23:30,910
we know our bryant is the owner of these

00:23:28,750 --> 00:23:33,370
sets of machines and then this is an

00:23:30,910 --> 00:23:35,860
older image but the graph link would

00:23:33,370 --> 00:23:37,900
redirect you to a graph on a dashboard

00:23:35,860 --> 00:23:40,630
that has all the historical bandwidth

00:23:37,900 --> 00:23:43,450
throughput of all the interfaces per

00:23:40,630 --> 00:23:45,310
machine which is useful and again these

00:23:43,450 --> 00:23:47,380
serial numbers are actual servers but

00:23:45,310 --> 00:23:48,850
they're out of support so you're not

00:23:47,380 --> 00:23:50,410
going to gain anything by getting them

00:23:48,850 --> 00:23:54,360
for my talk but you could certainly pay

00:23:50,410 --> 00:23:56,740
the bill for us if you feel inclined so

00:23:54,360 --> 00:23:58,960
along with a general infrastructure

00:23:56,740 --> 00:24:00,970
layout of the documentation we we drill

00:23:58,960 --> 00:24:02,890
down into assignments again kind of what

00:24:00,970 --> 00:24:04,930
machines are doing right now and this is

00:24:02,890 --> 00:24:08,590
just an example snapshot taken a few

00:24:04,930 --> 00:24:10,240
months back of various you know internal

00:24:08,590 --> 00:24:11,890
testing of products and things like that

00:24:10,240 --> 00:24:14,950
we see a lot of open shift stuff in here

00:24:11,890 --> 00:24:17,160
OpenStack elements of OpenStack we see

00:24:14,950 --> 00:24:20,290
some Software Defined Networking running

00:24:17,160 --> 00:24:22,000
things of that nature and then you can

00:24:20,290 --> 00:24:23,950
drill down further into the workload and

00:24:22,000 --> 00:24:25,720
you'll see how long they've had the

00:24:23,950 --> 00:24:28,960
assignment how long that's going to run

00:24:25,720 --> 00:24:30,250
and what's the remaining time so again

00:24:28,960 --> 00:24:32,289
this just gives people

00:24:30,250 --> 00:24:34,450
an added level of transparency to see

00:24:32,289 --> 00:24:35,830
there's no more black box what's going

00:24:34,450 --> 00:24:38,590
on with this server gear that we have

00:24:35,830 --> 00:24:40,179
you know it's very clear is there

00:24:38,590 --> 00:24:41,789
servers available I can request them and

00:24:40,179 --> 00:24:44,649
I'll get them and then I get this nice

00:24:41,789 --> 00:24:46,389
generated printout and then we also tag

00:24:44,649 --> 00:24:48,820
faulty machine so if there's something

00:24:46,389 --> 00:24:50,799
wrong with the hardware we simply assign

00:24:48,820 --> 00:24:53,470
a key value pair of faulty and then it

00:24:50,799 --> 00:24:54,909
goes into the spare pool or the faulty

00:24:53,470 --> 00:24:59,590
pool that we can have the local lab

00:24:54,909 --> 00:25:00,879
people take a look at and fix on top of

00:24:59,590 --> 00:25:02,529
the documentation we have we have

00:25:00,879 --> 00:25:04,960
visualizations as well we generate a

00:25:02,529 --> 00:25:06,850
calendar so any point you can see what

00:25:04,960 --> 00:25:09,850
kind of tests are running inside of the

00:25:06,850 --> 00:25:12,009
RNA scale environment and then lastly we

00:25:09,850 --> 00:25:14,980
have a heat map visualization now if

00:25:12,009 --> 00:25:17,710
this doesn't look like it's going to win

00:25:14,980 --> 00:25:20,049
any website awards it looks like the old

00:25:17,710 --> 00:25:21,639
windows 95 defrag program you guys

00:25:20,049 --> 00:25:24,340
remember that where it's like the big

00:25:21,639 --> 00:25:26,230
blue grid and then the colors change but

00:25:24,340 --> 00:25:28,120
it's incredibly useful from a scheduling

00:25:26,230 --> 00:25:30,039
perspective because we can look at and

00:25:28,120 --> 00:25:31,840
this is generated three months in

00:25:30,039 --> 00:25:33,580
advance six months in advance whatever

00:25:31,840 --> 00:25:36,309
you want to set it at but we can very

00:25:33,580 --> 00:25:38,919
quickly see what's available from a day

00:25:36,309 --> 00:25:40,899
of the month or at a longer view and

00:25:38,919 --> 00:25:42,820
then we can use that to schedule free

00:25:40,899 --> 00:25:46,830
servers for people that have requested

00:25:42,820 --> 00:25:50,889
it so again and this is all automated

00:25:46,830 --> 00:25:54,100
automatically generated for you cool so

00:25:50,889 --> 00:25:57,580
as you see earlier we definitely need

00:25:54,100 --> 00:26:00,059
more testing and CI is very important so

00:25:57,580 --> 00:26:03,549
we do have testing it's not good enough

00:26:00,059 --> 00:26:05,559
but it's it's getting there we use

00:26:03,549 --> 00:26:08,230
Gerrit for code review and then we use

00:26:05,559 --> 00:26:11,440
Jenkins for the CI and we're working on

00:26:08,230 --> 00:26:13,330
now kind of a fully instantiated virtual

00:26:11,440 --> 00:26:16,809
sandbox using open V switch and some

00:26:13,330 --> 00:26:19,179
other stuff to emulate switch ports but

00:26:16,809 --> 00:26:20,980
right now we're using flake eight we're

00:26:19,179 --> 00:26:22,750
using shell check for some of the the

00:26:20,980 --> 00:26:26,379
shell kind of glue that we have in the

00:26:22,750 --> 00:26:28,179
project and we need to probably get

00:26:26,379 --> 00:26:30,519
proper tests then so we're getting there

00:26:28,179 --> 00:26:33,250
the quads is about 11 months old and

00:26:30,519 --> 00:26:37,419
it's been running our RNG environment

00:26:33,250 --> 00:26:39,460
for about eight of those months cool

00:26:37,419 --> 00:26:40,869
so what's working right now this long

00:26:39,460 --> 00:26:44,140
list of stuff that I'm not going to read

00:26:40,869 --> 00:26:45,610
to you this is available in all the doc

00:26:44,140 --> 00:26:47,370
imitation that we have if you're curious

00:26:45,610 --> 00:26:49,810
you can you can ask me after the talk

00:26:47,370 --> 00:26:53,200
but it's going to do a whole lot of

00:26:49,810 --> 00:26:54,760
stuff for you what are we working on

00:26:53,200 --> 00:26:56,710
this is even more important so what are

00:26:54,760 --> 00:27:00,310
some things that we have planned to

00:26:56,710 --> 00:27:01,990
introduce with quads we the major thing

00:27:00,310 --> 00:27:05,320
right now is we want to introduce the

00:27:01,990 --> 00:27:07,870
idea of like a post config and what that

00:27:05,320 --> 00:27:09,790
would do is it's one thing to provision

00:27:07,870 --> 00:27:11,440
the network's the storage the servers

00:27:09,790 --> 00:27:13,510
for people and hand them off and

00:27:11,440 --> 00:27:16,300
document them and then reclaim them when

00:27:13,510 --> 00:27:19,210
they're done but you probably want to

00:27:16,300 --> 00:27:20,800
automate other stuff on top of that we

00:27:19,210 --> 00:27:24,100
have a lot of folks testing OpenStack

00:27:20,800 --> 00:27:26,260
for example and you might get you know

00:27:24,100 --> 00:27:27,760
say 50 servers to do an open stack

00:27:26,260 --> 00:27:29,080
deployment and then you're testing a

00:27:27,760 --> 00:27:31,450
specific part of that OpenStack

00:27:29,080 --> 00:27:33,640
deployment and you could easily burn one

00:27:31,450 --> 00:27:35,800
or two days getting OpenStack deployed

00:27:33,640 --> 00:27:37,570
and getting just right so we want to

00:27:35,800 --> 00:27:40,870
offer the option of kind of an

00:27:37,570 --> 00:27:42,370
open-ended model that whether you're

00:27:40,870 --> 00:27:44,380
laying down an infrastructure as a

00:27:42,370 --> 00:27:45,970
service set of software or you want to

00:27:44,380 --> 00:27:49,150
lay down some kind of container

00:27:45,970 --> 00:27:50,800
orchestration on your hosts we we want

00:27:49,150 --> 00:27:52,780
to offer the option that that is also

00:27:50,800 --> 00:27:54,520
automatically done for you so when

00:27:52,780 --> 00:27:57,340
developers come in on Monday or Tuesday

00:27:54,520 --> 00:27:59,380
or whenever they want to work they'll

00:27:57,340 --> 00:28:00,820
they not only have their servers that

00:27:59,380 --> 00:28:02,110
are documented that they have the

00:28:00,820 --> 00:28:04,150
credentials and they're ready to go but

00:28:02,110 --> 00:28:05,860
they also have any ancillary software

00:28:04,150 --> 00:28:08,170
stacks that they need to test on top of

00:28:05,860 --> 00:28:09,460
already set up for them and it's again

00:28:08,170 --> 00:28:12,250
it's about saving time and being as

00:28:09,460 --> 00:28:15,100
efficient as possible we're also working

00:28:12,250 --> 00:28:16,660
on a flask web interface for quads to

00:28:15,100 --> 00:28:18,580
kind of enable some self-service

00:28:16,660 --> 00:28:20,920
scheduling so if you're you know

00:28:18,580 --> 00:28:22,930
developer Jane Doe and you want to

00:28:20,920 --> 00:28:24,910
schedule yourself 100 machines for a

00:28:22,930 --> 00:28:26,530
week and they're available you can go to

00:28:24,910 --> 00:28:28,690
the flask interface and request them in

00:28:26,530 --> 00:28:30,070
a week's time whenever you want to start

00:28:28,690 --> 00:28:32,140
your machines will show up for you in a

00:28:30,070 --> 00:28:35,410
few hours so that would be a really cool

00:28:32,140 --> 00:28:37,630
feature to have we just put in place a

00:28:35,410 --> 00:28:40,300
JSON API so that's been pretty useful

00:28:37,630 --> 00:28:42,700
but we haven't quite we're not using it

00:28:40,300 --> 00:28:45,190
internally but it does work pretty well

00:28:42,700 --> 00:28:47,170
that's going to kind of pave the way for

00:28:45,190 --> 00:28:50,980
the flask interface so we're kind of

00:28:47,170 --> 00:28:52,450
doing slow moving blocks that way we

00:28:50,980 --> 00:28:55,030
just got in place to automate a network

00:28:52,450 --> 00:28:56,710
validation that I've talked about and we

00:28:55,030 --> 00:28:57,549
also want to support more resource

00:28:56,710 --> 00:28:59,769
backends

00:28:57,549 --> 00:29:01,419
Dodd's Foreman I'd like to have an

00:28:59,769 --> 00:29:02,860
answer bull back-end that all you have

00:29:01,419 --> 00:29:05,409
to do is run ansible against a set of

00:29:02,860 --> 00:29:07,360
hosts you yield all of the facts from

00:29:05,409 --> 00:29:09,249
discovery and then that is what

00:29:07,360 --> 00:29:13,059
formulates the information that's in the

00:29:09,249 --> 00:29:15,879
wiki that's automatically generated so

00:29:13,059 --> 00:29:19,119
again you know the the overall theme of

00:29:15,879 --> 00:29:21,820
quads of this kind of loose framework

00:29:19,119 --> 00:29:25,029
that we put together is being as

00:29:21,820 --> 00:29:27,970
efficient as possible with the few

00:29:25,029 --> 00:29:31,509
resources that you do have and you'll

00:29:27,970 --> 00:29:33,399
kind of see this so in our case and this

00:29:31,509 --> 00:29:35,590
is really a construct of any sort of

00:29:33,399 --> 00:29:37,179
company that's larger than you know 20

00:29:35,590 --> 00:29:38,859
or 30 people if you have bare metal

00:29:37,179 --> 00:29:41,320
assets or say you have machines in a

00:29:38,859 --> 00:29:44,320
data center or rented resources is that

00:29:41,320 --> 00:29:47,100
over time development groups tend to

00:29:44,320 --> 00:29:49,179
silo their resources so you know like

00:29:47,100 --> 00:29:51,009
department a is going to have their

00:29:49,179 --> 00:29:52,629
servers and they're going to be entirely

00:29:51,009 --> 00:29:54,129
different make and model than department

00:29:52,629 --> 00:29:56,080
B and they're going to be bought at a

00:29:54,129 --> 00:29:57,309
different time and their depreciation

00:29:56,080 --> 00:29:59,529
dates going to be different and maybe

00:29:57,309 --> 00:30:01,980
their Hardware profiles different so a

00:29:59,529 --> 00:30:04,570
company ends up spending a lot of money

00:30:01,980 --> 00:30:06,999
maintaining these little siloed areas

00:30:04,570 --> 00:30:08,889
and pockets of infrastructure and the

00:30:06,999 --> 00:30:11,259
idea behind quads is that you put

00:30:08,889 --> 00:30:13,239
everything in one giant bucket and then

00:30:11,259 --> 00:30:16,210
you let quads do all the provisioning

00:30:13,239 --> 00:30:18,340
all of all of the scheduling and take

00:30:16,210 --> 00:30:20,769
care of the whole thing for you now

00:30:18,340 --> 00:30:22,710
obviously there's downsides of automated

00:30:20,769 --> 00:30:25,739
scheduling and provisioning and that

00:30:22,710 --> 00:30:28,239
sometimes people's deadlines slip or

00:30:25,739 --> 00:30:29,739
sometimes they have something come up

00:30:28,239 --> 00:30:32,019
and then you can take vacation or they

00:30:29,739 --> 00:30:34,239
can't use the hardware so we've built in

00:30:32,019 --> 00:30:36,609
things into PI ml and PI animals very

00:30:34,239 --> 00:30:38,440
good at this and that we simply just

00:30:36,609 --> 00:30:40,539
need to modify the schedule and then

00:30:38,440 --> 00:30:42,359
quads framework does the right thing

00:30:40,539 --> 00:30:45,460
from a provisioning perspective

00:30:42,359 --> 00:30:47,590
but again this is a lot of very little

00:30:45,460 --> 00:30:49,480
tools little little small things that do

00:30:47,590 --> 00:30:52,269
one thing and do one thing well sort of

00:30:49,480 --> 00:30:56,460
sticking to the UNIX kiss principle if

00:30:52,269 --> 00:30:59,320
you will that we just keep it simple and

00:30:56,460 --> 00:31:03,039
selfishly from kind of the DevOps

00:30:59,320 --> 00:31:05,590
operations side is that we don't want to

00:31:03,039 --> 00:31:07,480
do the same thing more than once if it

00:31:05,590 --> 00:31:10,269
can be automated we want to automate the

00:31:07,480 --> 00:31:11,380
crap out of it if it's boring or we mess

00:31:10,269 --> 00:31:13,120
it up a lot

00:31:11,380 --> 00:31:15,220
we want to automate it and if it's

00:31:13,120 --> 00:31:17,290
something that's just we just don't want

00:31:15,220 --> 00:31:19,090
to do obviously machines can probably do

00:31:17,290 --> 00:31:20,890
it better for us so that was kind of the

00:31:19,090 --> 00:31:24,400
drive to initially get this thing going

00:31:20,890 --> 00:31:25,960
so the parts of quads might be more

00:31:24,400 --> 00:31:27,880
useful than the sum of its parts some

00:31:25,960 --> 00:31:31,240
people like to use just automated

00:31:27,880 --> 00:31:32,680
documentation for example the the

00:31:31,240 --> 00:31:35,320
scheduling aspect might be useful

00:31:32,680 --> 00:31:37,120
there's parts of the framework that you

00:31:35,320 --> 00:31:42,000
could consume yourself because it's not

00:31:37,120 --> 00:31:44,380
all tied together it's very modular so

00:31:42,000 --> 00:31:47,290
we've also got some external interest

00:31:44,380 --> 00:31:48,910
into quads as well there's someone going

00:31:47,290 --> 00:31:52,450
collaboration we're doing with Boston

00:31:48,910 --> 00:31:55,060
University and MIT in the Massachusetts

00:31:52,450 --> 00:31:57,700
open cloud so we're kind of merging

00:31:55,060 --> 00:32:00,630
parts of quads with their scheduler that

00:31:57,700 --> 00:32:02,950
they've written called Hill H IL and

00:32:00,630 --> 00:32:04,450
we've had some kind of large public

00:32:02,950 --> 00:32:07,870
companies show interest in using it for

00:32:04,450 --> 00:32:10,210
their dev and test environments so

00:32:07,870 --> 00:32:12,580
that's basically it thanks for coming to

00:32:10,210 --> 00:32:15,130
my talk if I have any time left I could

00:32:12,580 --> 00:32:17,550
open it up for questions if anybody's

00:32:15,130 --> 00:32:17,550
got some

00:32:22,800 --> 00:32:26,910
and if you want to read more

00:32:25,410 --> 00:32:29,730
everything's open source it's all on

00:32:26,910 --> 00:32:31,650
github and we certainly welcome patches

00:32:29,730 --> 00:32:35,190
because we're just not that good at

00:32:31,650 --> 00:32:36,870
Python but we want to be so welcome for

00:32:35,190 --> 00:32:45,990
anybody to give us a shout and look at

00:32:36,870 --> 00:32:48,270
the code yes to use that can be used

00:32:45,990 --> 00:32:53,930
it's like framework for a lute I think

00:32:48,270 --> 00:32:57,180
of a cluster for protesting major facing

00:32:53,930 --> 00:33:00,060
major tastings failure

00:32:57,180 --> 00:33:05,910
I mean if you some of the notes go down

00:33:00,060 --> 00:33:11,100
can we use to test such a scenario I

00:33:05,910 --> 00:33:13,830
don't know okay it's really it's really

00:33:11,100 --> 00:33:16,470
aimed right now for bare metal servers

00:33:13,830 --> 00:33:20,250
and kind of scheduling provisioning and

00:33:16,470 --> 00:33:22,410
resources based on a future date for

00:33:20,250 --> 00:33:27,500
example what happens it's like one of

00:33:22,410 --> 00:33:31,140
the notes doesn't start and scheduler

00:33:27,500 --> 00:33:36,240
what happens I just logged on you go and

00:33:31,140 --> 00:33:39,540
pick this by hand you're talking about

00:33:36,240 --> 00:33:40,650
OpenStack specifically your for your

00:33:39,540 --> 00:33:43,290
class that I think that the u.s.

00:33:40,650 --> 00:33:45,510
scheduled like 250 notes to get your

00:33:43,290 --> 00:33:53,460
consideration uh-huh and in front of

00:33:45,510 --> 00:33:54,840
town fail what happens hmm I'm I don't

00:33:53,460 --> 00:33:57,020
know what I'd have to have to think

00:33:54,840 --> 00:34:00,000
about it and give it back to you yeah I

00:33:57,020 --> 00:34:01,700
mean you can layer on any sort of post

00:34:00,000 --> 00:34:05,190
provisioning automation that you like

00:34:01,700 --> 00:34:07,500
and you know orchestrate that yourself

00:34:05,190 --> 00:34:10,530
it's designed in a way that we don't

00:34:07,500 --> 00:34:14,100
want to dictate a use case for you

00:34:10,530 --> 00:34:15,570
we just we find great utility and

00:34:14,100 --> 00:34:17,580
efficiency and having kind of an

00:34:15,570 --> 00:34:20,429
open-ended framework and if there are

00:34:17,580 --> 00:34:22,260
certain parts that you can reuse it's

00:34:20,429 --> 00:34:24,929
designed in a way that there's inputs

00:34:22,260 --> 00:34:27,450
for that so we ship like a yeah Mille

00:34:24,929 --> 00:34:29,130
configuration file that just to keep all

00:34:27,450 --> 00:34:31,020
you pair that if you want to use a

00:34:29,130 --> 00:34:33,270
different wiki for example or if you

00:34:31,020 --> 00:34:35,020
don't care about the provisioning aspect

00:34:33,270 --> 00:34:39,120
you could only do the scheduling or you

00:34:35,020 --> 00:34:39,120
could only use the documentation part I

00:34:43,560 --> 00:34:48,610
thank you for the talk you mention about

00:34:46,120 --> 00:34:50,409
the way the schedule and provision

00:34:48,610 --> 00:34:53,110
servers what happens when they go

00:34:50,409 --> 00:34:55,810
outside they use our 50 servers and then

00:34:53,110 --> 00:34:58,780
two of them go line you have any logic

00:34:55,810 --> 00:35:00,880
in terms of pairing them our servers

00:34:58,780 --> 00:35:06,280
that's exactly the policy on a large

00:35:00,880 --> 00:35:08,440
scale set up as far as like errors like

00:35:06,280 --> 00:35:11,560
whatever's right and two of them go like

00:35:08,440 --> 00:35:13,480
have never break all the time so how is

00:35:11,560 --> 00:35:16,030
that maybe managed as another company

00:35:13,480 --> 00:35:22,750
policy they technically won't be

00:35:16,030 --> 00:35:24,400
servicing well so things are going to

00:35:22,750 --> 00:35:27,790
always break you know there's there's

00:35:24,400 --> 00:35:30,250
you can you can build in any level of

00:35:27,790 --> 00:35:31,810
validation of pre provisioning

00:35:30,250 --> 00:35:34,060
validation but we found when you're

00:35:31,810 --> 00:35:36,670
doing very large deployments like

00:35:34,060 --> 00:35:38,200
several hundred servers at once there's

00:35:36,670 --> 00:35:39,970
going to be always be one or two

00:35:38,200 --> 00:35:41,740
stragglers where you know maybe they

00:35:39,970 --> 00:35:43,990
don't pick C correctly to Kickstarter

00:35:41,740 --> 00:35:46,980
maybe there's a failed disk that isn't

00:35:43,990 --> 00:35:50,710
picked up by the monitoring system so

00:35:46,980 --> 00:35:53,950
the best that we can do is bake in as

00:35:50,710 --> 00:35:55,480
much automated validation as we can and

00:35:53,950 --> 00:35:57,730
right now that's only on the network

00:35:55,480 --> 00:35:59,620
side but we don't really do it on the

00:35:57,730 --> 00:36:02,620
system side generally we have enough

00:35:59,620 --> 00:36:04,780
servers that if there is a serious

00:36:02,620 --> 00:36:06,130
hardware failure we can easily shuffle

00:36:04,780 --> 00:36:07,780
them out of the pile and throw another

00:36:06,130 --> 00:36:10,330
one into the mix and then that one takes

00:36:07,780 --> 00:36:11,410
its place and then we can always sort it

00:36:10,330 --> 00:36:12,970
out later and then that's why we

00:36:11,410 --> 00:36:15,220
generate the faulty servers on the

00:36:12,970 --> 00:36:17,680
documentation but I don't know a good

00:36:15,220 --> 00:36:20,200
solution for that because you're you're

00:36:17,680 --> 00:36:21,640
fighting against so many factors at that

00:36:20,200 --> 00:36:24,100
point inside of a data center there's

00:36:21,640 --> 00:36:26,320
the network layer you have power issues

00:36:24,100 --> 00:36:28,060
you have anything you could even think

00:36:26,320 --> 00:36:31,750
of it's going to go wrong at a large

00:36:28,060 --> 00:36:33,700
scale so we build more our redundancy is

00:36:31,750 --> 00:36:36,040
more built into having at least one or

00:36:33,700 --> 00:36:37,780
two spare of that type that we can

00:36:36,040 --> 00:36:41,100
quickly shuffle in and then dealing with

00:36:37,780 --> 00:36:44,200
it later rather than trying to bake in

00:36:41,100 --> 00:36:45,670
extremely long tenuous validation but we

00:36:44,200 --> 00:36:47,910
could always do better on the system

00:36:45,670 --> 00:36:58,980
side validating set the answer

00:36:47,910 --> 00:37:00,569
question great yes sir I'm just

00:36:58,980 --> 00:37:01,710
wondering about the the network aside

00:37:00,569 --> 00:37:03,839
and how do you actually deal with

00:37:01,710 --> 00:37:04,920
connecting out to your devices so your

00:37:03,839 --> 00:37:06,690
juniper you Cisco

00:37:04,920 --> 00:37:08,630
do you have any issues with like vendor

00:37:06,690 --> 00:37:13,140
interoperability them how you can excuse

00:37:08,630 --> 00:37:15,599
just like let me go or something or I'm

00:37:13,140 --> 00:37:18,660
sorry can you repeat so do you have any

00:37:15,599 --> 00:37:22,470
issues with interoperability so Cisco

00:37:18,660 --> 00:37:23,609
you might connect by SSH right juniper

00:37:22,470 --> 00:37:27,210
you might have a better ways like a

00:37:23,609 --> 00:37:30,140
necklace or something we do certain

00:37:27,210 --> 00:37:32,460
vendors because we have a pretty

00:37:30,140 --> 00:37:33,900
heterogeneous environment we have a lot

00:37:32,460 --> 00:37:36,299
of Super Micro Machines a lot of Dell

00:37:33,900 --> 00:37:38,069
machines and they're not made equal when

00:37:36,299 --> 00:37:39,930
it comes to you know out-of-band

00:37:38,069 --> 00:37:43,349
interfaces and things like that so we do

00:37:39,930 --> 00:37:46,020
have to do some one-off things it's more

00:37:43,349 --> 00:37:47,970
apparent on the network side that you

00:37:46,020 --> 00:37:50,099
would interface with Juno's completely

00:37:47,970 --> 00:37:54,210
different than you interface with iOS so

00:37:50,099 --> 00:37:56,069
we have per vendor tooling that would go

00:37:54,210 --> 00:37:59,039
out and change the VLANs and everything

00:37:56,069 --> 00:38:01,680
is done would basically keep this flat

00:37:59,039 --> 00:38:03,960
file structure and it's done in some

00:38:01,680 --> 00:38:08,400
kind of a CSV format so there's one per

00:38:03,960 --> 00:38:11,400
server that has several fields and it

00:38:08,400 --> 00:38:13,470
Maps like say the Ethernet interface to

00:38:11,400 --> 00:38:16,440
a MAC address and there's int there's a

00:38:13,470 --> 00:38:18,420
field there for vendor ID so if we were

00:38:16,440 --> 00:38:20,130
dealing with a Cisco switch versus a Jew

00:38:18,420 --> 00:38:22,410
notice which we would need to make sure

00:38:20,130 --> 00:38:25,319
that that vendor ID field actually has

00:38:22,410 --> 00:38:26,910
Cisco and then if it does it knows to

00:38:25,319 --> 00:38:29,190
use the other tooling that does the

00:38:26,910 --> 00:38:31,109
equivalent iOS stuff but it's not

00:38:29,190 --> 00:38:32,000
elegant in any way it just it gets the

00:38:31,109 --> 00:38:35,369
job done

00:38:32,000 --> 00:38:38,430
ideally and this is more of a immediate

00:38:35,369 --> 00:38:41,119
future thing is that ansible is working

00:38:38,430 --> 00:38:44,279
on network orchestration but it's done

00:38:41,119 --> 00:38:46,230
at an abstraction layer so you would

00:38:44,279 --> 00:38:48,539
have ansible drive all of your switch

00:38:46,230 --> 00:38:51,000
changes but you would tell it I don't

00:38:48,539 --> 00:38:53,220
care what the vendor is I want this VLAN

00:38:51,000 --> 00:38:55,770
or this construct to go from this to

00:38:53,220 --> 00:38:58,829
this and if it's in its desired State it

00:38:55,770 --> 00:39:00,510
does nothing so it's idempotent but you

00:38:58,829 --> 00:39:03,060
don't need to care about the vendor

00:39:00,510 --> 00:39:04,320
semantics the abstraction when ansible

00:39:03,060 --> 00:39:06,359
will take care of that but I don't know

00:39:04,320 --> 00:39:09,240
how big that is I think it's very

00:39:06,359 --> 00:39:10,590
actively being worked on and that's what

00:39:09,240 --> 00:39:14,070
we're going to move to but right now we

00:39:10,590 --> 00:39:16,859
maintain per vendor Network automation

00:39:14,070 --> 00:39:18,990
scripts and luckily right now we're

00:39:16,859 --> 00:39:26,430
almost all juniper across the board so

00:39:18,990 --> 00:39:28,410
if it makes that easy any other

00:39:26,430 --> 00:39:31,140
questions we'll feel free to find me

00:39:28,410 --> 00:39:32,760
after the conference and can borrow my

00:39:31,140 --> 00:39:35,910
Terminator mask and attack me if you

00:39:32,760 --> 00:39:37,470
like I'm into that I guess so thanks for

00:39:35,910 --> 00:39:38,830
your time and I appreciate you come to

00:39:37,470 --> 00:39:45,780
the talk

00:39:38,830 --> 00:39:45,780

YouTube URL: https://www.youtube.com/watch?v=nT8k3ykGeJQ


