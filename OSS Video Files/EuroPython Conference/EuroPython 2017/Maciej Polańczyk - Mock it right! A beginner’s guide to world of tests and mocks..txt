Title: Maciej Polańczyk - Mock it right! A beginner’s guide to world of tests and mocks.
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Mock it right! A beginner’s guide to world of tests and mocks.
[EuroPython 2017 - Talk - 2017-07-10 - Arengo]
[Rimini, Italy]

The main goal of this presentation is to make beginner audience familiar with mocks and patches but there is a chance that more experienced ones will also find something new for themselves. Presentation shows the common use cases when developing unit tests. I will say what are the best practices when working with mocks and patches and what kind of mistakes, done by many developers, may be avoided so the dragons will not come. During this presentation I will prepare mock-it-o drink as a prize.

First, I will briefly introduce an audience with the topic of unit testing. Then I will show a simple code which will be tested during the presentation. It covers all common use cases of writing unit tests which are usage of mocks, patches and their side effects. In the end I will show a template of unit test which will be extended according to our needs.

Next, I will say what is a mock, and what are the benefits of using it. Why it is better than any Dummy class implemented for purpose of unit tests and, what is the most important and sometimes forgotten by experienced developers, how to create the best mock, which involves using spec_set and spec to protect us from dragons when interface of mocked class changes.

Last but not least part of my presentation will be dedicated to patches. I will explain when and how patches should be used (how to use side_effect, patch properties and environment variables). Finally, I will say how to avoid common mistakes when working with patches.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,550 --> 00:00:09,050
hello everyone my name is Masha blinchik

00:00:06,350 --> 00:00:11,780
I came here from Poland currently I work

00:00:09,050 --> 00:00:14,269
for STX next which is the biggest Python

00:00:11,780 --> 00:00:16,490
software house in Europe and today I

00:00:14,269 --> 00:00:18,560
will talk about mocking part the tools

00:00:16,490 --> 00:00:23,210
that helped us to create unit s in

00:00:18,560 --> 00:00:25,400
Python so tell me how many of you create

00:00:23,210 --> 00:00:27,950
unit s when you create your applications

00:00:25,400 --> 00:00:30,290
please raise your hand if you do Wow

00:00:27,950 --> 00:00:33,290
almost everyone or maybe even everyone

00:00:30,290 --> 00:00:35,960
and how many of you know what is ma

00:00:33,290 --> 00:00:39,170
compartment you use modern parts in your

00:00:35,960 --> 00:00:40,789
unit as piece writer great so almost

00:00:39,170 --> 00:00:43,250
everyone it will be much easier to talk

00:00:40,789 --> 00:00:45,559
about it when you know it already before

00:00:43,250 --> 00:00:48,620
I start my presentation I would like to

00:00:45,559 --> 00:00:54,500
answer a very important question why are

00:00:48,620 --> 00:00:57,260
we here right here because I prepared

00:00:54,500 --> 00:00:59,660
with mojito drinks for those who will

00:00:57,260 --> 00:01:03,499
answer my questions or I just try to

00:00:59,660 --> 00:01:05,059
answer my questions so please during the

00:01:03,499 --> 00:01:07,340
presentation I will have a few questions

00:01:05,059 --> 00:01:10,430
too please try to answer those questions

00:01:07,340 --> 00:01:12,680
because I don't want to drink 12 mockito

00:01:10,430 --> 00:01:17,270
drinks after the presentation by myself

00:01:12,680 --> 00:01:20,390
I want to give it to you ok so this is

00:01:17,270 --> 00:01:22,400
the plan for the presentation first I

00:01:20,390 --> 00:01:24,320
will show you a class which will be an

00:01:22,400 --> 00:01:26,660
excuse to create some unit tests during

00:01:24,320 --> 00:01:29,240
the whole presentation next I will show

00:01:26,660 --> 00:01:31,390
you a template of unit tests which will

00:01:29,240 --> 00:01:34,390
extend during the whole presentation

00:01:31,390 --> 00:01:38,030
then I will tell you what is a mod and

00:01:34,390 --> 00:01:40,310
how can we use it in our unit tests for

00:01:38,030 --> 00:01:42,170
this presentation and finally I will

00:01:40,310 --> 00:01:45,650
tell you about the patch what it is and

00:01:42,170 --> 00:01:49,430
how we can use it in our case so let's

00:01:45,650 --> 00:01:52,520
say a client came to us and she asked us

00:01:49,430 --> 00:01:55,220
to create an application which will

00:01:52,520 --> 00:01:57,730
receive emails and from those images

00:01:55,220 --> 00:02:01,730
we'll take some data and then send it to

00:01:57,730 --> 00:02:04,670
some endpoint using the REST API so it

00:02:01,730 --> 00:02:07,790
seems to be a very simple application to

00:02:04,670 --> 00:02:10,459
do so you say ok we will do it we take

00:02:07,790 --> 00:02:13,070
our best developers I call them ninja

00:02:10,459 --> 00:02:15,320
developers and after a few days they

00:02:13,070 --> 00:02:18,470
create a code very good code probably

00:02:15,320 --> 00:02:21,320
this code will contain a class

00:02:18,470 --> 00:02:24,110
similar to this one message sander with

00:02:21,320 --> 00:02:27,020
its center has sent method which takes

00:02:24,110 --> 00:02:34,300
message as an argument from message it

00:02:27,020 --> 00:02:39,350
takes sender receiver and subject and

00:02:34,300 --> 00:02:43,000
this data is being sent in few attempts

00:02:39,350 --> 00:02:45,920
by post method from request library

00:02:43,000 --> 00:02:48,050
actually three attempts are done so

00:02:45,920 --> 00:02:51,290
depending on the result from post method

00:02:48,050 --> 00:02:54,080
from request library sent method will

00:02:51,290 --> 00:02:57,140
return true or false depending on the

00:02:54,080 --> 00:03:00,800
result it's a question to you what kind

00:02:57,140 --> 00:03:05,230
of unit tests would you do for this send

00:03:00,800 --> 00:03:08,230
method and this is what mockito doing an

00:03:05,230 --> 00:03:08,230
idea

00:03:12,950 --> 00:03:17,680
yes sorry

00:03:19,690 --> 00:03:26,959
of course this is very important but

00:03:24,200 --> 00:03:28,730
what other cases because this is basic I

00:03:26,959 --> 00:03:29,060
think everyone would created us like

00:03:28,730 --> 00:03:39,950
this

00:03:29,060 --> 00:03:41,870
yes exactly

00:03:39,950 --> 00:03:44,810
post metals can rise the exception and

00:03:41,870 --> 00:03:47,269
exception exception in this case would

00:03:44,810 --> 00:03:49,970
be lies by send methods because we don't

00:03:47,269 --> 00:03:52,130
catch it so all of cases is to check if

00:03:49,970 --> 00:03:55,130
the exception will be right by this

00:03:52,130 --> 00:03:57,410
method a second I think the most

00:03:55,130 --> 00:03:59,510
important thing is just to check if we

00:03:57,410 --> 00:04:01,280
really send the correct data to the

00:03:59,510 --> 00:04:03,799
correct endpoint because we use

00:04:01,280 --> 00:04:07,040
postmates also and the main thing that

00:04:03,799 --> 00:04:09,290
this function does is sending data to

00:04:07,040 --> 00:04:12,590
the endpoint so first of all we should

00:04:09,290 --> 00:04:15,920
check if post method actually if hold is

00:04:12,590 --> 00:04:19,280
set method sends correct data to correct

00:04:15,920 --> 00:04:21,620
place but when we execute all unit tests

00:04:19,280 --> 00:04:23,990
we don't want to send this fake test

00:04:21,620 --> 00:04:25,760
data to the real production endpoint

00:04:23,990 --> 00:04:28,820
because our clients will not be happy of

00:04:25,760 --> 00:04:31,039
that so when we check if this post

00:04:28,820 --> 00:04:34,010
method works correctly we also should

00:04:31,039 --> 00:04:37,130
not use the original implementation of

00:04:34,010 --> 00:04:39,680
post method so first think check this

00:04:37,130 --> 00:04:42,830
but don't use the original post method

00:04:39,680 --> 00:04:45,740
second think yes check if exception rise

00:04:42,830 --> 00:04:50,720
by post method will be raised outside of

00:04:45,740 --> 00:04:53,680
the send function what else we have also

00:04:50,720 --> 00:04:53,680
yes

00:04:55,699 --> 00:05:03,560
yes of course that's something that we

00:04:59,900 --> 00:05:06,560
need to check also yes of course you

00:05:03,560 --> 00:05:10,729
have some logic in in our method the

00:05:06,560 --> 00:05:13,189
logic is that we try to send data in few

00:05:10,729 --> 00:05:16,669
attempts so I think we should also check

00:05:13,189 --> 00:05:19,669
if we really do it if into advance in

00:05:16,669 --> 00:05:22,909
case of failure we try to send this data

00:05:19,669 --> 00:05:26,090
and last thing but not least we have

00:05:22,909 --> 00:05:28,610
message which is implemented somehow so

00:05:26,090 --> 00:05:30,349
in unit test we should cut off from the

00:05:28,610 --> 00:05:33,020
original implementation of the message

00:05:30,349 --> 00:05:36,349
so a lot of things to do let's see how

00:05:33,020 --> 00:05:38,090
we can do it this is the implementation

00:05:36,349 --> 00:05:40,340
of message class it is very simple it

00:05:38,090 --> 00:05:43,460
has only 3 v receiver center and subject

00:05:40,340 --> 00:05:44,870
and this is example of our unit test

00:05:43,460 --> 00:05:48,139
which will expand during the full

00:05:44,870 --> 00:05:50,479
presentation as you can see first we

00:05:48,139 --> 00:05:52,580
create message center object then we get

00:05:50,479 --> 00:05:56,419
a fake message we will talk in a moment

00:05:52,580 --> 00:05:59,810
how we can get it next we try to send it

00:05:56,419 --> 00:06:04,430
and then we make some assertions for the

00:05:59,810 --> 00:06:07,729
result how can we get a fake message in

00:06:04,430 --> 00:06:10,460
this simple case we can just implement a

00:06:07,729 --> 00:06:12,349
new class inside our unit test with

00:06:10,460 --> 00:06:14,990
those three fields and that's all it

00:06:12,349 --> 00:06:17,149
will work for now but what if in few

00:06:14,990 --> 00:06:19,969
days from now someone will add a new

00:06:17,149 --> 00:06:22,219
field to a original message class or for

00:06:19,969 --> 00:06:24,439
example and I think this is more

00:06:22,219 --> 00:06:27,139
important someone will add a new method

00:06:24,439 --> 00:06:30,500
currently there is no methods inside but

00:06:27,139 --> 00:06:33,919
someone will add it then if we will go

00:06:30,500 --> 00:06:36,319
the path of creating our new class

00:06:33,919 --> 00:06:39,500
inside of this unit earth will need to

00:06:36,319 --> 00:06:42,229
extend it so we can fake this new method

00:06:39,500 --> 00:06:43,729
and actually also to check if this

00:06:42,229 --> 00:06:45,500
method was code correctly from the

00:06:43,729 --> 00:06:48,319
production code which is very important

00:06:45,500 --> 00:06:50,569
so ok we can do it we will spend some

00:06:48,319 --> 00:06:52,430
time on it and after a few days probably

00:06:50,569 --> 00:06:54,979
a colleague will come to us and say wow

00:06:52,430 --> 00:06:58,310
nice code let's use it in other unit

00:06:54,979 --> 00:06:59,000
tests so we will do it and after a few

00:06:58,310 --> 00:07:01,430
days

00:06:59,000 --> 00:07:04,069
our ninja developer will come and say

00:07:01,430 --> 00:07:06,139
wow what a great tool let's let's make

00:07:04,069 --> 00:07:07,139
it public so other ninja developers can

00:07:06,139 --> 00:07:08,629
use it

00:07:07,139 --> 00:07:10,710
that's when we will not is it all

00:07:08,629 --> 00:07:13,530
something like this already exist

00:07:10,710 --> 00:07:15,599
it's called Mach so first thing I want

00:07:13,530 --> 00:07:18,810
you to remember from my presentation is

00:07:15,599 --> 00:07:20,879
that if you need to pass a fake object

00:07:18,810 --> 00:07:23,729
inside your production code and you can

00:07:20,879 --> 00:07:26,759
do it easily like in here we create fake

00:07:23,729 --> 00:07:32,879
message and you can easily pass it then

00:07:26,759 --> 00:07:34,439
you smoke what the smoke I think you

00:07:32,879 --> 00:07:36,960
already know it because once everyone

00:07:34,439 --> 00:07:39,360
set that your smokes so I would just

00:07:36,960 --> 00:07:42,029
shortly show it this is how you create

00:07:39,360 --> 00:07:45,840
mock and almost you can call anything

00:07:42,029 --> 00:07:48,120
anything that doesn't exist so if you do

00:07:45,840 --> 00:07:52,289
it for example not existing field you

00:07:48,120 --> 00:07:54,120
will always get value and if you call a

00:07:52,289 --> 00:07:57,000
method which doesn't exist you'll also

00:07:54,120 --> 00:07:58,310
get some value this is very important

00:07:57,000 --> 00:08:00,810
because this is advantage and

00:07:58,310 --> 00:08:04,460
disadvantage both together in one time

00:08:00,810 --> 00:08:07,860
but I will tell more about it later

00:08:04,460 --> 00:08:10,499
so for unit test we don't want any value

00:08:07,860 --> 00:08:14,599
to be returns we want some value for

00:08:10,499 --> 00:08:18,389
example five like this you can assign

00:08:14,599 --> 00:08:23,389
value that we want a mock to return with

00:08:18,389 --> 00:08:26,399
this simple line and from this moment

00:08:23,389 --> 00:08:29,550
this value will be always returned by a

00:08:26,399 --> 00:08:35,159
mod this is simple version when you can

00:08:29,550 --> 00:08:38,399
do it in one line okay how can we use it

00:08:35,159 --> 00:08:40,890
in our unit s it is very simple in unit

00:08:38,399 --> 00:08:44,339
test we create a mock next we assign a

00:08:40,890 --> 00:08:46,260
value which we wanted to return in

00:08:44,339 --> 00:08:51,149
production code the mock should be

00:08:46,260 --> 00:08:53,670
executed and in unit tests back in unit

00:08:51,149 --> 00:08:55,910
tests you can make assertion if it was

00:08:53,670 --> 00:08:58,769
hoped correctly in this case our

00:08:55,910 --> 00:09:00,750
existing method was cotton or Ewan's and

00:08:58,769 --> 00:09:04,199
without an argument so we can use a

00:09:00,750 --> 00:09:05,370
third called once with and if our method

00:09:04,199 --> 00:09:08,100
would be called with some kind of

00:09:05,370 --> 00:09:10,589
argument we can do it with the same

00:09:08,100 --> 00:09:13,740
assertion but we need to put the value

00:09:10,589 --> 00:09:15,930
that we expect to be caught with the

00:09:13,740 --> 00:09:17,399
more complex cases for example a method

00:09:15,930 --> 00:09:19,760
was called a few times with different

00:09:17,399 --> 00:09:23,510
arguments then we can use a

00:09:19,760 --> 00:09:25,210
Nicole and of course in Python

00:09:23,510 --> 00:09:27,590
documentation can find much more

00:09:25,210 --> 00:09:30,200
examples which I'm not able to show you

00:09:27,590 --> 00:09:32,870
in this short presentation I can show

00:09:30,200 --> 00:09:36,380
you just a few which I picked for

00:09:32,870 --> 00:09:38,600
example if we call direct earmark and

00:09:36,380 --> 00:09:42,190
then we call some methods on a mock we

00:09:38,600 --> 00:09:46,450
can use for example call Alex list

00:09:42,190 --> 00:09:49,730
subject all the direct calls to the mock

00:09:46,450 --> 00:09:52,790
method calls to check calls to the

00:09:49,730 --> 00:09:56,750
methods defined on a mock or we can have

00:09:52,790 --> 00:10:00,890
all of them using more calls in unit s

00:09:56,750 --> 00:10:04,160
we can use it in our sessions but first

00:10:00,890 --> 00:10:07,450
we need to get a color object and we can

00:10:04,160 --> 00:10:10,550
compare existing calls with a list of

00:10:07,450 --> 00:10:15,590
expected call objects this is how we can

00:10:10,550 --> 00:10:18,260
use it in unit s so going back to our

00:10:15,590 --> 00:10:20,750
unit tests we had to create a fake

00:10:18,260 --> 00:10:22,880
message we can do it like this this is a

00:10:20,750 --> 00:10:25,280
method which returns a fake of our

00:10:22,880 --> 00:10:28,700
message using a mod this mod defines

00:10:25,280 --> 00:10:31,400
this is a sender and subject and this

00:10:28,700 --> 00:10:34,130
will work at least for a few days so an

00:10:31,400 --> 00:10:38,060
ideas why this mod is in the best market

00:10:34,130 --> 00:10:41,080
that we can create and this is creation

00:10:38,060 --> 00:10:41,080
method mojito team

00:10:42,040 --> 00:10:45,040
sorry

00:10:50,480 --> 00:10:56,540
exactly this is the problem so Spets is

00:10:53,670 --> 00:10:59,640
almost what I was expecting to hear and

00:10:56,540 --> 00:11:02,280
the best answer is I will show it in a

00:10:59,640 --> 00:11:04,560
moment so what you said is that for

00:11:02,280 --> 00:11:06,120
example if someone will change the

00:11:04,560 --> 00:11:08,640
message class the original message class

00:11:06,120 --> 00:11:12,600
for example removing the subject field

00:11:08,640 --> 00:11:15,660
and he will forget to remove it from the

00:11:12,600 --> 00:11:19,590
production code so it still holds in

00:11:15,660 --> 00:11:25,080
production code then our test will fail

00:11:19,590 --> 00:11:28,110
alright or not fail exactly the test

00:11:25,080 --> 00:11:30,090
will pass because you can call anything

00:11:28,110 --> 00:11:31,890
on a mock even if it doesn't exist and

00:11:30,090 --> 00:11:35,270
this is the problem this is why we

00:11:31,890 --> 00:11:38,070
should not create mocks like this and

00:11:35,270 --> 00:11:41,790
spats is not enough in this case we can

00:11:38,070 --> 00:11:42,330
do much more we can do ah this is one

00:11:41,790 --> 00:11:45,210
more thing

00:11:42,330 --> 00:11:48,060
so I wanted to say that Dragons will

00:11:45,210 --> 00:11:49,500
come in this case because we changed

00:11:48,060 --> 00:11:53,010
something in production called

00:11:49,500 --> 00:11:55,230
a and our unit tests passed so

00:11:53,010 --> 00:11:57,450
everything is green so we decided ok we

00:11:55,230 --> 00:12:00,390
can go to the production can reduce our

00:11:57,450 --> 00:12:02,700
application and suddenly it appears that

00:12:00,390 --> 00:12:04,950
after releasing our application doesn't

00:12:02,700 --> 00:12:06,480
work so it's much too late of course I

00:12:04,950 --> 00:12:08,340
want to say that we should use staging

00:12:06,480 --> 00:12:11,340
and other testing instances this is just

00:12:08,340 --> 00:12:13,230
an example that we change the code you

00:12:11,340 --> 00:12:18,630
need this passed but production code

00:12:13,230 --> 00:12:20,730
doesn't work Dragons will tell ok so the

00:12:18,630 --> 00:12:23,790
best mock which we could create in this

00:12:20,730 --> 00:12:27,000
case is with attribute called spread set

00:12:23,790 --> 00:12:30,810
and this will protect us from creating

00:12:27,000 --> 00:12:32,960
fakes of objects with fields or methods

00:12:30,810 --> 00:12:37,340
that doesn't exist in the real

00:12:32,960 --> 00:12:40,980
implementation in this case of message

00:12:37,340 --> 00:12:43,340
but what if a message is defined like

00:12:40,980 --> 00:12:46,920
this so all the fields are defined in

00:12:43,340 --> 00:12:50,780
init method and not on the class level

00:12:46,920 --> 00:12:50,780
can we use pet set in this case

00:12:53,810 --> 00:13:00,410
okay.we unfortunate unfortunate he

00:12:56,660 --> 00:13:02,510
cannot use that in this case and this is

00:13:00,410 --> 00:13:05,750
also something that happens with

00:13:02,510 --> 00:13:09,290
response which is returned by post

00:13:05,750 --> 00:13:12,680
method response is defined in request

00:13:09,290 --> 00:13:15,230
library and we cannot control it but we

00:13:12,680 --> 00:13:17,630
would like in our unit test to control

00:13:15,230 --> 00:13:21,320
the status code value so till we could

00:13:17,630 --> 00:13:23,540
do it with mock but the problem is that

00:13:21,320 --> 00:13:23,960
implementation of response looks like

00:13:23,540 --> 00:13:26,630
this

00:13:23,960 --> 00:13:29,060
so status code is defined in init method

00:13:26,630 --> 00:13:31,400
and not on the class level so we cannot

00:13:29,060 --> 00:13:32,960
use spread set when we want to control

00:13:31,400 --> 00:13:36,410
when we want to create a mock of

00:13:32,960 --> 00:13:41,020
response we need to do something else

00:13:36,410 --> 00:13:44,300
and this is pet so spec doesn't check if

00:13:41,020 --> 00:13:47,990
what we try to create with mob for

00:13:44,300 --> 00:13:50,570
example the status code exists in the

00:13:47,990 --> 00:13:54,740
implementation of the read class it all

00:13:50,570 --> 00:13:56,870
what it does is checking if what we call

00:13:54,740 --> 00:14:01,070
from the production code was defined in

00:13:56,870 --> 00:14:04,580
the mock so it's not the same but we get

00:14:01,070 --> 00:14:08,240
some protection it's not perfect but

00:14:04,580 --> 00:14:10,280
that's what we have to do okay so we

00:14:08,240 --> 00:14:13,520
already know how to mock the response we

00:14:10,280 --> 00:14:15,620
know how to mock the message now let's

00:14:13,520 --> 00:14:18,050
talk about the most important thing how

00:14:15,620 --> 00:14:20,270
to mock the post method because we don't

00:14:18,050 --> 00:14:25,610
want to send the test data to the real

00:14:20,270 --> 00:14:27,920
production endpoint as I said we should

00:14:25,610 --> 00:14:30,320
use mod when we can easily pass them to

00:14:27,920 --> 00:14:31,370
the production code in this case we

00:14:30,320 --> 00:14:35,300
cannot do it easily

00:14:31,370 --> 00:14:37,400
somehow hard-coded but message sender

00:14:35,300 --> 00:14:39,589
belongs to us so we can ask our ninja

00:14:37,400 --> 00:14:42,440
developers to change the source code and

00:14:39,589 --> 00:14:46,459
for example we can define sender in init

00:14:42,440 --> 00:14:50,660
method and in our test we can create a

00:14:46,459 --> 00:14:51,920
mock for our sender and atrophy

00:14:50,660 --> 00:14:54,260
everything will be fine

00:14:51,920 --> 00:14:56,120
but what if message sender would come

00:14:54,260 --> 00:14:58,490
from some kind of library and we cannot

00:14:56,120 --> 00:15:01,580
change it but we still need to do this

00:14:58,490 --> 00:15:02,810
mock so this is the second thing I would

00:15:01,580 --> 00:15:05,810
like you to remember from my

00:15:02,810 --> 00:15:06,640
presentation use patch when you cannot

00:15:05,810 --> 00:15:09,490
easily

00:15:06,640 --> 00:15:14,620
pass the fake object but resolve this

00:15:09,490 --> 00:15:16,560
problem how can we use a passion there

00:15:14,620 --> 00:15:20,140
are different ways of using patches I

00:15:16,560 --> 00:15:23,380
prefer using it as a notation to a test

00:15:20,140 --> 00:15:27,399
method and this is first option of the

00:15:23,380 --> 00:15:30,339
solution you can say with this drink

00:15:27,399 --> 00:15:33,760
what should be patched and out of space

00:15:30,339 --> 00:15:38,079
equal to says that we want spats that

00:15:33,760 --> 00:15:41,320
are able to be used but we'll create a

00:15:38,079 --> 00:15:45,640
mock for this object and we'll pass it

00:15:41,320 --> 00:15:50,230
as an argument to our unit test and in

00:15:45,640 --> 00:15:56,320
here you can define what should be

00:15:50,230 --> 00:15:59,079
returned from our mod okay at the end of

00:15:56,320 --> 00:16:03,339
our unit test we can make assertions to

00:15:59,079 --> 00:16:05,350
our mock there is a second option of

00:16:03,339 --> 00:16:08,110
using puzzles and annotation and

00:16:05,350 --> 00:16:11,290
actually I prefer this solution because

00:16:08,110 --> 00:16:12,760
it doesn't take string it takes an

00:16:11,290 --> 00:16:15,550
object that is for the first argument

00:16:12,760 --> 00:16:18,550
and second argument can be also replaced

00:16:15,550 --> 00:16:20,829
by not saying but I don't want to show

00:16:18,550 --> 00:16:23,620
it on the slide because it would be a

00:16:20,829 --> 00:16:26,649
little too complex so I preferred this

00:16:23,620 --> 00:16:28,329
solution because when I use IDE it

00:16:26,649 --> 00:16:30,519
supports me when I do some kind of the

00:16:28,329 --> 00:16:34,600
factoring with important other things

00:16:30,519 --> 00:16:38,199
and in this case ID would help me with

00:16:34,600 --> 00:16:42,640
fixing those symbols in case of strings

00:16:38,199 --> 00:16:45,940
it would not check anything when you

00:16:42,640 --> 00:16:49,180
create part this very important thing

00:16:45,940 --> 00:16:52,000
that patch created the part should be

00:16:49,180 --> 00:16:54,640
created based on the place where we call

00:16:52,000 --> 00:16:56,290
the post method this is something that

00:16:54,640 --> 00:17:00,100
you can forget when you create a part

00:16:56,290 --> 00:17:03,399
for the first time we have almost to the

00:17:00,100 --> 00:17:06,429
same codes the code on the Left we call

00:17:03,399 --> 00:17:09,549
post method from request and the code on

00:17:06,429 --> 00:17:12,579
the right we call post method from from

00:17:09,549 --> 00:17:14,709
something like message sender both post

00:17:12,579 --> 00:17:17,650
methods are actually the same they come

00:17:14,709 --> 00:17:20,070
from request library but the difference

00:17:17,650 --> 00:17:24,270
is in the way how they are called

00:17:20,070 --> 00:17:27,330
this makes that we need to part them

00:17:24,270 --> 00:17:30,150
differently on the Left we pass

00:17:27,330 --> 00:17:33,540
post-metal from request on the right we

00:17:30,150 --> 00:17:35,280
pass both petal from message sender this

00:17:33,540 --> 00:17:37,740
is very important you can forget about

00:17:35,280 --> 00:17:39,960
it when you create budgets for the first

00:17:37,740 --> 00:17:43,530
time okay

00:17:39,960 --> 00:17:46,830
we already know how to touch or maybe

00:17:43,530 --> 00:17:50,190
mock postman dot so now we can go to

00:17:46,830 --> 00:17:52,470
another thing how to make it to rise the

00:17:50,190 --> 00:17:55,410
exception and to check if exception was

00:17:52,470 --> 00:17:58,340
rise we can do it simply of course with

00:17:55,410 --> 00:18:03,210
a patch and we can do it by assigning

00:17:58,340 --> 00:18:06,450
exception to a side-effect RT good and

00:18:03,210 --> 00:18:08,990
in here we can check if the exception

00:18:06,450 --> 00:18:08,990
was right

00:18:09,890 --> 00:18:16,890
another thing we have a post method

00:18:13,860 --> 00:18:19,830
called a few times if it's of course

00:18:16,890 --> 00:18:21,960
necessary and we would like to check if

00:18:19,830 --> 00:18:24,120
we really do it in our code so in case

00:18:21,960 --> 00:18:25,920
of failure when we try to send the data

00:18:24,120 --> 00:18:28,470
for the first time would like to check

00:18:25,920 --> 00:18:32,580
if our code tries to do it next time and

00:18:28,470 --> 00:18:35,730
next time so we need to be able to tell

00:18:32,580 --> 00:18:39,120
post method to return different things

00:18:35,730 --> 00:18:41,700
in our unit testing for different calls

00:18:39,120 --> 00:18:43,950
for example for first time return file

00:18:41,700 --> 00:18:46,680
and for second time return fire and for

00:18:43,950 --> 00:18:49,290
first time with an success how can we do

00:18:46,680 --> 00:18:53,940
it of course you can do it with our

00:18:49,290 --> 00:18:56,880
patch and of course we can do it with

00:18:53,940 --> 00:19:01,400
side effect we just assign to side

00:18:56,880 --> 00:19:04,020
effect attribute and we filled a list of

00:19:01,400 --> 00:19:08,220
responses that we would like to be

00:19:04,020 --> 00:19:09,690
returned by this method and first value

00:19:08,220 --> 00:19:11,340
from the list will build and for the

00:19:09,690 --> 00:19:14,120
first call second value for the second

00:19:11,340 --> 00:19:14,120
call and so on

00:19:14,720 --> 00:19:18,690
sometimes we need a special

00:19:16,650 --> 00:19:21,930
implementation of our original method

00:19:18,690 --> 00:19:24,600
and nothing else can work so in this

00:19:21,930 --> 00:19:26,790
case you can do it we can set our

00:19:24,600 --> 00:19:29,550
special implementation for example

00:19:26,790 --> 00:19:31,440
defined in our test and we can assign it

00:19:29,550 --> 00:19:33,600
to excite effect

00:19:31,440 --> 00:19:50,900
instead of original implementation of

00:19:33,600 --> 00:19:50,900
our post method you mean this case odd

00:20:06,650 --> 00:20:30,230
you mean arcs and Fox or yes yes yes

00:20:32,780 --> 00:20:38,610
to check the interface and existing this

00:20:36,570 --> 00:20:40,890
may be in this example it's not the best

00:20:38,610 --> 00:20:46,520
example some other example would be

00:20:40,890 --> 00:20:46,520
better for for this case okay

00:20:50,860 --> 00:21:02,110
yes so that defense ways for this people

00:20:59,480 --> 00:21:03,980
say different things

00:21:02,110 --> 00:21:09,470
exactly exactly

00:21:03,980 --> 00:21:11,690
okay so I think this is the next slide

00:21:09,470 --> 00:21:14,840
sometimes we need to create a few

00:21:11,690 --> 00:21:17,539
patches to one unit a scheme and this is

00:21:14,840 --> 00:21:20,119
very simple as you can see but you need

00:21:17,539 --> 00:21:22,240
to remember that the order of marks

00:21:20,119 --> 00:21:25,970
which are passed the unit tests are

00:21:22,240 --> 00:21:29,679
opposite to the order of patches which

00:21:25,970 --> 00:21:32,179
analyze this method so first patch will

00:21:29,679 --> 00:21:34,249
return a mock which will be passed as

00:21:32,179 --> 00:21:36,499
the last one to the unit test and the

00:21:34,249 --> 00:21:39,259
last patch will return a mock which will

00:21:36,499 --> 00:21:43,999
be passed as that first one to death as

00:21:39,259 --> 00:21:48,320
an adult okay

00:21:43,999 --> 00:21:51,019
sometimes our unit tests have the same

00:21:48,320 --> 00:21:54,730
patches so instead of repeating them all

00:21:51,019 --> 00:22:00,740
the time above each unit s we can just

00:21:54,730 --> 00:22:02,090
set it on the class level and this is

00:22:00,740 --> 00:22:05,629
very important you need to remember

00:22:02,090 --> 00:22:08,149
about this one before each test a setup

00:22:05,629 --> 00:22:10,100
method is called and after each test

00:22:08,149 --> 00:22:13,429
tilt down method is called G down is

00:22:10,100 --> 00:22:15,559
used to do some cleanup after the unit s

00:22:13,429 --> 00:22:17,210
and setup is used to prepare some

00:22:15,559 --> 00:22:20,690
environment for unittest

00:22:17,210 --> 00:22:23,629
but people often forget that if setup

00:22:20,690 --> 00:22:25,700
would arise exception then unit tests

00:22:23,629 --> 00:22:28,279
will never be executed and till down

00:22:25,700 --> 00:22:30,769
also will never be executed so if

00:22:28,279 --> 00:22:33,980
someone will set apart in setup methods

00:22:30,769 --> 00:22:37,039
and will think that he can clean it in

00:22:33,980 --> 00:22:39,470
pitch down and just after setting up a

00:22:37,039 --> 00:22:41,960
part there will be exception rise in

00:22:39,470 --> 00:22:44,840
setup method then the tedium will never

00:22:41,960 --> 00:22:47,330
be called so if we made this my mistake

00:22:44,840 --> 00:22:51,379
for example in first unit s and we

00:22:47,330 --> 00:22:56,749
execute 1000 unit s and 200 first unit

00:22:51,379 --> 00:22:58,490
tests is using this patch but this cell

00:22:56,749 --> 00:23:00,769
doesn't know that it is using the pass

00:22:58,490 --> 00:23:03,409
it may fail and we will spend a lot of

00:23:00,769 --> 00:23:03,900
time to find out what happened so to

00:23:03,409 --> 00:23:06,810
solve the

00:23:03,900 --> 00:23:11,580
issue we should not use teardown we

00:23:06,810 --> 00:23:13,830
should use at cleanup method like this

00:23:11,580 --> 00:23:18,780
and we will be protected from this

00:23:13,830 --> 00:23:22,590
program okay and last thing I wanted to

00:23:18,780 --> 00:23:24,930
show you very simple and I think this

00:23:22,590 --> 00:23:27,030
maybe will make you to check the

00:23:24,930 --> 00:23:29,280
documentation for box and parts because

00:23:27,030 --> 00:23:32,450
you can fight a lot of interesting

00:23:29,280 --> 00:23:36,860
things that how we can simply mock

00:23:32,450 --> 00:23:42,150
environment variables with just one line

00:23:36,860 --> 00:23:43,320
like this using part dot stick okay so

00:23:42,150 --> 00:23:45,720
two things I wanted you to remember

00:23:43,320 --> 00:23:48,750
after my presentation first thing you

00:23:45,720 --> 00:23:52,230
smoke when you can simply pass the fake

00:23:48,750 --> 00:23:55,560
object to production code and ii think

00:23:52,230 --> 00:23:59,270
use patches and you cannot simply pass

00:23:55,560 --> 00:24:17,310
the Fate object to your production code

00:23:59,270 --> 00:24:18,930
any questions if you have yet is there a

00:24:17,310 --> 00:24:21,540
way here to use like do actual

00:24:18,930 --> 00:24:23,400
environment and just overwrite few keys

00:24:21,540 --> 00:24:26,670
not not only we've always thought

00:24:23,400 --> 00:24:27,230
everyone but with any dictionary yes you

00:24:26,670 --> 00:24:30,840
can do it

00:24:27,230 --> 00:24:36,300
we hope it distracted the documentation

00:24:30,840 --> 00:24:38,840
you will see our example in the yep any

00:24:36,300 --> 00:24:38,840
more questions

00:24:44,890 --> 00:24:50,750
thank you it's more question like

00:24:48,440 --> 00:24:53,870
theoretical you have some function and

00:24:50,750 --> 00:24:55,940
you want to test it and you mock stuff

00:24:53,870 --> 00:24:57,830
outside of this function and sometimes

00:24:55,940 --> 00:25:00,169
it's actually ugly you have few marks

00:24:57,830 --> 00:25:01,940
you have defined Scientifics you define

00:25:00,169 --> 00:25:04,429
maybe something else you have to check

00:25:01,940 --> 00:25:07,039
more call arcs DS and does a start wait

00:25:04,429 --> 00:25:10,010
is it any normal wave how it's possible

00:25:07,039 --> 00:25:13,250
to make it looks better so a suggestion

00:25:10,010 --> 00:25:16,640
atleast say you have a lot of mocks with

00:25:13,250 --> 00:25:18,650
a big setup with many side effects and

00:25:16,640 --> 00:25:21,289
everything in one unit us

00:25:18,650 --> 00:25:23,809
yes notice for example freeform works

00:25:21,289 --> 00:25:26,720
already looks like quite away so first

00:25:23,809 --> 00:25:28,669
of all try not to do this because it's

00:25:26,720 --> 00:25:31,960
too complexes it will be very hard to

00:25:28,669 --> 00:25:35,480
analyze it so try to make it more simple

00:25:31,960 --> 00:25:37,429
yes of course but but how it depends on

00:25:35,480 --> 00:25:39,980
the code I would have to see the code

00:25:37,429 --> 00:25:42,799
and maybe there would be a solution for

00:25:39,980 --> 00:25:53,830
this but of course not always it's

00:25:42,799 --> 00:25:53,830
possible okay okay any more questions

00:25:56,230 --> 00:26:05,049
yes when you are mentioning the common

00:26:02,110 --> 00:26:08,950
error when patching that you need to

00:26:05,049 --> 00:26:12,309
patch the where the name is look up from

00:26:08,950 --> 00:26:15,429
by Python isn't that a smell that you're

00:26:12,309 --> 00:26:17,399
coupling the implementation of the thing

00:26:15,429 --> 00:26:20,110
you're patching with your tests

00:26:17,399 --> 00:26:23,380
basically you need to go to the source

00:26:20,110 --> 00:26:25,330
of your library and check what they are

00:26:23,380 --> 00:26:27,159
doing and they might be changing into

00:26:25,330 --> 00:26:29,740
minor patches because this is not

00:26:27,159 --> 00:26:33,220
necessarily public interface so make

00:26:29,740 --> 00:26:37,269
your code brittle a very good question

00:26:33,220 --> 00:26:41,110
I like it very much so this was only an

00:26:37,269 --> 00:26:43,630
example to show how we can track if in

00:26:41,110 --> 00:26:45,490
unit as if exception was rised I'm not

00:26:43,630 --> 00:26:48,429
saying that the code which I show you

00:26:45,490 --> 00:26:50,590
the production code was the best the

00:26:48,429 --> 00:26:52,809
different ways for this and I think most

00:26:50,590 --> 00:26:55,120
of us will agree that we should catch

00:26:52,809 --> 00:26:58,380
this exception in our production code

00:26:55,120 --> 00:27:00,730
inside method and pack it with our own

00:26:58,380 --> 00:27:03,340
implementation of exception for example

00:27:00,730 --> 00:27:05,799
and to write this exception and then we

00:27:03,340 --> 00:27:07,630
would catch our own exception and check

00:27:05,799 --> 00:27:10,090
this our own exception so we are not

00:27:07,630 --> 00:27:12,429
going down to the library which we use

00:27:10,090 --> 00:27:14,669
and I think this might be answer to a

00:27:12,429 --> 00:27:23,220
question am I correct

00:27:14,669 --> 00:27:23,220
okay any more questions

00:27:24,150 --> 00:27:30,130
so I think less than 12 people were

00:27:27,700 --> 00:27:32,650
active doing my questions so please

00:27:30,130 --> 00:27:35,080
those people come to me and some other

00:27:32,650 --> 00:27:37,360
others have people please come also

00:27:35,080 --> 00:27:39,730
because I have 12 rings and I don't want

00:27:37,360 --> 00:27:47,380
to drink them it's too much fun one more

00:27:39,730 --> 00:27:49,450
person so so they are really dreams I

00:27:47,380 --> 00:27:51,850
just call them Makita because it sounds

00:27:49,450 --> 00:27:54,490
funny and it's almost close to mojito

00:27:51,850 --> 00:28:02,860
which is which actually they are so

00:27:54,490 --> 00:28:05,110
there are real drinks inside yes side

00:28:02,860 --> 00:28:06,880
effect that depends on you if you are

00:28:05,110 --> 00:28:12,240
big then maybe side effects will not be

00:28:06,880 --> 00:28:15,360
so big yes exactly you have to test it

00:28:12,240 --> 00:28:15,360
thank you

00:28:15,730 --> 00:28:19,259

YouTube URL: https://www.youtube.com/watch?v=rEIt0D_ACy8


