Title: Leonardo Giordani - Abstract Base Classes: a smart use of metaclasses
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Abstract Base Classes: a smart use of metaclasses
[EuroPython 2017 - Talk - 2017-07-11 - PythonAnywhere Room]
[Rimini, Italy]

This talk shows what Python Abstract Base Classes (ABCs) are and how they can be used to categorise objects and implement a virtual inheritance tree. The goal of the talk is to introduce programmers to the concept of ABCs, and to show that metaclasses are not a terribly complex topic, but something that can be used by normal programmers. The talk is divided in three different “levels of difficulty”, each of one going deeper in the technical aspects of the subject.

Level 1: Polymorphism - Behaviours and delegation - Collections
The first level is meant to give a quick overview of the collections package and some useful code snippets. Even beginners can benefit of the information given here. To complete this level you only need to know what a try/except block is.

Level 2: Registering - Abstract Base Classes - Categories
The second level shows what real and virtual inheritance are, explains what is the meaning of registering and defines Abstract Base Classes. To complete this level you need to know what class inheritance is (i.e. what class MyList(list) means).

Level 3: Build your ABCs - Metaclasses - ABSs as interfaces
The third level shows how to create your own ABCs, why metaclasses are involved and why they are not a difficult concept. I will then quickly review a possible use of metaclasses as interfaces. To complete this level you need to know how to instantiate a class, and the difference between class and instance.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:05,370 --> 00:00:08,590
[Applause]

00:00:07,260 --> 00:00:11,719
[Music]

00:00:08,590 --> 00:00:15,220
thank you and thank you for being here

00:00:11,719 --> 00:00:18,140
um yeah so today I will talk about

00:00:15,220 --> 00:00:20,930
asthma episode based glasses and why I

00:00:18,140 --> 00:00:24,470
think they are useful and a useful thing

00:00:20,930 --> 00:00:28,189
to know in vital and first of all that's

00:00:24,470 --> 00:00:33,440
me too much tests so you have a recap at

00:00:28,189 --> 00:00:38,660
the end I want just to point out that I

00:00:33,440 --> 00:00:42,260
also work sometimes and I am a DevOps at

00:00:38,660 --> 00:00:45,550
the moment I'm just doing a lot of AWS

00:00:42,260 --> 00:00:45,550
nginx modern Python

00:00:46,100 --> 00:00:55,190
today's talk is divided into three

00:00:49,390 --> 00:00:58,579
levels or sections so during level one I

00:00:55,190 --> 00:01:01,760
will talk about polymorphism behaviors

00:00:58,579 --> 00:01:04,879
and delegation and collections so some

00:01:01,760 --> 00:01:06,500
concept that I think we should know has

00:01:04,879 --> 00:01:10,670
Buyten programmers as programmers in

00:01:06,500 --> 00:01:14,060
general and collections is a module that

00:01:10,670 --> 00:01:15,560
is worth knowing in Python and in level

00:01:14,060 --> 00:01:17,990
2 I will talk about registering

00:01:15,560 --> 00:01:22,100
absolutist classes finally and

00:01:17,990 --> 00:01:25,520
categories in level 3 I will go a bit

00:01:22,100 --> 00:01:29,300
deeper into the topic and talk about how

00:01:25,520 --> 00:01:31,640
you build your own episode based classes

00:01:29,300 --> 00:01:38,259
meta classes and how to use them as

00:01:31,640 --> 00:01:43,600
interfaces so python is a language that

00:01:38,259 --> 00:01:43,600
pushes the object-oriented programming

00:01:44,649 --> 00:01:51,619
methodology a lot so one of the tenets

00:01:49,310 --> 00:01:56,360
of object-oriented programming is that

00:01:51,619 --> 00:01:59,210
behavior of a structure so you we as

00:01:56,360 --> 00:02:02,060
Python programmers we should consider

00:01:59,210 --> 00:02:06,500
behavior of classes more than the

00:02:02,060 --> 00:02:08,750
structure what do I mean that at the end

00:02:06,500 --> 00:02:13,100
of the day I'm not interested in if

00:02:08,750 --> 00:02:15,350
something is a list or other things but

00:02:13,100 --> 00:02:17,750
I own tests we know if it behaves like a

00:02:15,350 --> 00:02:22,040
list so I don't really know if your

00:02:17,750 --> 00:02:27,400
class or your instance can be sliced if

00:02:22,040 --> 00:02:31,100
I can append elements I don't I don't

00:02:27,400 --> 00:02:34,760
I'm not interested sorry you know if you

00:02:31,100 --> 00:02:38,660
hear it from list or if you implement it

00:02:34,760 --> 00:02:44,540
from scratch this is a reason why in

00:02:38,660 --> 00:02:47,299
Python we push the EAF p-pardon a lot so

00:02:44,540 --> 00:02:51,200
it's easier to ask for forgiveness than

00:02:47,299 --> 00:02:53,900
permission right so we try and accept we

00:02:51,200 --> 00:02:57,230
try to use something and then we accept

00:02:53,900 --> 00:03:00,050
because we are not checking if some obj

00:02:57,230 --> 00:03:02,540
in this slide is subscribed

00:03:00,050 --> 00:03:05,000
you know if it's at least it is

00:03:02,540 --> 00:03:07,280
something that can be sliced no we just

00:03:05,000 --> 00:03:11,270
try it and if it doesn't work we do

00:03:07,280 --> 00:03:14,830
something and this is and we do this

00:03:11,270 --> 00:03:19,190
because we're interesting the behavior

00:03:14,830 --> 00:03:23,000
this is an example of behavior I have

00:03:19,190 --> 00:03:26,930
two classes list view and item view sort

00:03:23,000 --> 00:03:30,050
of like jungle views they inherit from

00:03:26,930 --> 00:03:33,260
our parent which is view and the parent

00:03:30,050 --> 00:03:35,290
class doesn't define sorry I didn't have

00:03:33,260 --> 00:03:37,910
enough space in the slide that the

00:03:35,290 --> 00:03:41,570
parent class doesn't define the status

00:03:37,910 --> 00:03:43,550
function the certain status method and I

00:03:41,570 --> 00:03:46,340
implemented directly in the list view

00:03:43,550 --> 00:03:51,140
and the item view so there is no way for

00:03:46,340 --> 00:03:56,780
me to know to say that this view and

00:03:51,140 --> 00:04:00,440
item view implement the function I mean

00:03:56,780 --> 00:04:02,240
I cannot say they hear it from view this

00:04:00,440 --> 00:04:04,430
is not a problem because view doesn't

00:04:02,240 --> 00:04:06,890
define the status class the status

00:04:04,430 --> 00:04:09,830
method so this is an example of behavior

00:04:06,890 --> 00:04:14,660
for me those two classes behave in some

00:04:09,830 --> 00:04:19,209
way they provide a method so the

00:04:14,660 --> 00:04:23,510
question is how we how do we check how

00:04:19,209 --> 00:04:27,070
an object behaves and one thing that we

00:04:23,510 --> 00:04:31,550
can do is this one so we can try and

00:04:27,070 --> 00:04:35,060
call the method for example this note

00:04:31,550 --> 00:04:37,490
that I'm not calling status I don't have

00:04:35,060 --> 00:04:40,430
the parenthesis I'm just asking for the

00:04:37,490 --> 00:04:43,880
metals okay so I'm doing it because I

00:04:40,430 --> 00:04:46,850
hope bite well I hope I know that Python

00:04:43,880 --> 00:04:48,740
raises the attribute error if the some

00:04:46,850 --> 00:04:52,100
obj doesn't contain the status method

00:04:48,740 --> 00:04:56,240
right but I'm not actually using it so

00:04:52,100 --> 00:04:59,570
this is well this works I don't really

00:04:56,240 --> 00:05:02,360
like it because it's like three lines of

00:04:59,570 --> 00:05:05,050
code to just perform one check and

00:05:02,360 --> 00:05:07,940
doesn't it actually doesn't do anything

00:05:05,050 --> 00:05:10,729
more than that if I have to check a

00:05:07,940 --> 00:05:13,040
complex behavior like for example my

00:05:10,729 --> 00:05:15,080
object behaves like a list because they

00:05:13,040 --> 00:05:17,150
our complex algorithms which have to

00:05:15,080 --> 00:05:19,970
slice have to append things and whatever

00:05:17,150 --> 00:05:23,900
I have to check three methods and

00:05:19,970 --> 00:05:29,210
possibly more than that and this is well

00:05:23,900 --> 00:05:32,980
oddly a maintainable and I'm wrong

00:05:29,210 --> 00:05:36,470
because I am checking the structure and

00:05:32,980 --> 00:05:39,560
well in Python there are ways to provide

00:05:36,470 --> 00:05:42,500
methods without actually putting them in

00:05:39,560 --> 00:05:44,900
the classes so I would say this is in

00:05:42,500 --> 00:05:50,420
general not a good solution I don't like

00:05:44,900 --> 00:05:52,910
it as a programmer the temptation we

00:05:50,420 --> 00:05:57,200
have and probably already used it a lot

00:05:52,910 --> 00:05:59,510
is to use is instance I can say if some

00:05:57,200 --> 00:06:02,600
obj is an instance of list in this case

00:05:59,510 --> 00:06:07,370
I actually check that my obj behaves

00:06:02,600 --> 00:06:11,960
like a list it is a list this is wrong

00:06:07,370 --> 00:06:15,950
because it is checking the type of the

00:06:11,960 --> 00:06:18,320
object what if I implement a new class

00:06:15,950 --> 00:06:22,400
that behaves like a list but is not

00:06:18,320 --> 00:06:27,140
least this phase this doesn't pass but

00:06:22,400 --> 00:06:29,930
the code works more than that if I start

00:06:27,140 --> 00:06:32,120
saying well I want an object which is a

00:06:29,930 --> 00:06:34,850
list or a table or a string because you

00:06:32,120 --> 00:06:36,920
know I am NOT just checking for mutable

00:06:34,850 --> 00:06:39,950
sequence in this case I mean checking

00:06:36,920 --> 00:06:42,380
for something that can be sliced and the

00:06:39,950 --> 00:06:44,750
three things this string and tupple can

00:06:42,380 --> 00:06:47,420
be sliced and then he comes in says Oh

00:06:44,750 --> 00:06:49,340
invented a new top or whatever and they

00:06:47,420 --> 00:06:53,930
have to add it so it becomes a

00:06:49,340 --> 00:06:56,570
maintainable very quickly the perfect

00:06:53,930 --> 00:06:59,390
solution in my opinion would be to have

00:06:56,570 --> 00:07:02,480
something like behaves like it's a

00:06:59,390 --> 00:07:06,260
function that says yes Euro BJ behaves

00:07:02,480 --> 00:07:11,440
like this behavior well this behavior is

00:07:06,260 --> 00:07:14,960
a class in my dream that describes a

00:07:11,440 --> 00:07:18,490
behavior okay that says yeah performs

00:07:14,960 --> 00:07:22,130
this operation does this and that yep

00:07:18,490 --> 00:07:22,940
okay good news we have something like

00:07:22,130 --> 00:07:25,160
that

00:07:22,940 --> 00:07:27,530
first of all Python is based on

00:07:25,160 --> 00:07:30,800
delegation this is a very important

00:07:27,530 --> 00:07:32,600
things to know about vitam that a lot of

00:07:30,800 --> 00:07:36,080
things in Python are implemented by the

00:07:32,600 --> 00:07:39,260
gating things for example you are

00:07:36,080 --> 00:07:41,990
familiar I think with magic metals of

00:07:39,260 --> 00:07:46,250
fight on like than the ad than the

00:07:41,990 --> 00:07:47,840
either and under contains whatever this

00:07:46,250 --> 00:07:50,660
is a delegation because I'm not

00:07:47,840 --> 00:07:53,390
providing some code in Python core that

00:07:50,660 --> 00:07:56,510
says that object can be sliced or

00:07:53,390 --> 00:07:59,120
contains something or can be added it's

00:07:56,510 --> 00:08:01,850
the object itself the class in this case

00:07:59,120 --> 00:08:04,940
that provides a method the city ax can

00:08:01,850 --> 00:08:08,720
be added to whatever or I can be sliced

00:08:04,940 --> 00:08:13,240
and this is important because actually

00:08:08,720 --> 00:08:16,820
it's the mechanism that core developers

00:08:13,240 --> 00:08:18,860
leveraged to implement a solution to my

00:08:16,820 --> 00:08:21,290
problem so to my behavior

00:08:18,860 --> 00:08:23,570
checking function this is the original

00:08:21,290 --> 00:08:26,030
version of is instance some Python

00:08:23,570 --> 00:08:28,580
versions at all well a very simplified

00:08:26,030 --> 00:08:31,310
version obviously but the concept is

00:08:28,580 --> 00:08:34,520
that what I'm doing is to check I'm

00:08:31,310 --> 00:08:40,130
passing a class and then checking that

00:08:34,520 --> 00:08:43,430
the class is in the basis of my object

00:08:40,130 --> 00:08:46,190
basis is an internal attribute that

00:08:43,430 --> 00:08:47,990
lists all the parents they actually the

00:08:46,190 --> 00:08:51,970
original version is a bit more complex

00:08:47,990 --> 00:08:55,460
because we have to somehow climb to the

00:08:51,970 --> 00:08:56,000
inheritance tree okay but this is the

00:08:55,460 --> 00:08:58,190
concept

00:08:56,000 --> 00:09:01,370
I'm checking and saying yeah python does

00:08:58,190 --> 00:09:05,300
this is instance checks for the presence

00:09:01,370 --> 00:09:07,670
of the class was changed to a new

00:09:05,300 --> 00:09:10,880
version which is based on the legation

00:09:07,670 --> 00:09:14,330
again a simplified version is instance

00:09:10,880 --> 00:09:18,890
now says that object is an instance of a

00:09:14,330 --> 00:09:21,650
class if that object says yes I am an

00:09:18,890 --> 00:09:25,930
instance of that class so the object so

00:09:21,650 --> 00:09:28,690
it is totally up to the class says yes a

00:09:25,930 --> 00:09:31,610
method which is called instance check

00:09:28,690 --> 00:09:34,730
that accepts you object and checks for

00:09:31,610 --> 00:09:35,960
something and that checks for something

00:09:34,730 --> 00:09:38,690
is extendable

00:09:35,960 --> 00:09:43,120
I can create new algorithms okay so this

00:09:38,690 --> 00:09:46,370
is not provided by Python in a core code

00:09:43,120 --> 00:09:49,280
so now this is possible is this boss it

00:09:46,370 --> 00:09:53,950
is possible to say if is instance sum of

00:09:49,280 --> 00:09:58,250
VJ this behavior because is instance

00:09:53,950 --> 00:10:01,250
uses the internal instance check method

00:09:58,250 --> 00:10:04,490
of this behavior we just need to create

00:10:01,250 --> 00:10:08,020
some class like this behavior that can

00:10:04,490 --> 00:10:08,020
check for the behavior right

00:10:08,500 --> 00:10:14,960
enter collections and collections is a

00:10:12,200 --> 00:10:19,940
module that you can find in the standard

00:10:14,960 --> 00:10:22,370
library yeah it's a module of classes

00:10:19,940 --> 00:10:24,590
that as a word that represent the

00:10:22,370 --> 00:10:28,970
interesting behaviors like mutable

00:10:24,590 --> 00:10:31,610
sequence sequence mapping whatever go

00:10:28,970 --> 00:10:33,680
and check the documentation this is an

00:10:31,610 --> 00:10:36,440
example I import collection I say is

00:10:33,680 --> 00:10:38,870
instance a string of a sequence and the

00:10:36,440 --> 00:10:42,140
string is a sequence can be sliced for

00:10:38,870 --> 00:10:43,640
example so the check is 2 but that a

00:10:42,140 --> 00:10:45,740
string is not a mapping is not a

00:10:43,640 --> 00:10:49,360
dictionary right there's no key value

00:10:45,740 --> 00:10:52,460
pairs inside so the check is false and

00:10:49,360 --> 00:10:56,150
the link there is the documentation of

00:10:52,460 --> 00:10:58,520
the collections module I my advice is to

00:10:56,150 --> 00:11:01,430
go check it and start using it because

00:10:58,520 --> 00:11:05,030
it's a very powerful module it happened

00:11:01,430 --> 00:11:07,190
it doesn't happen defin that often in

00:11:05,030 --> 00:11:09,920
Python that you have to check really

00:11:07,190 --> 00:11:13,730
check of different very different

00:11:09,920 --> 00:11:15,500
behaviors but sometimes had my code the

00:11:13,730 --> 00:11:17,930
need of check for and checking for

00:11:15,500 --> 00:11:21,530
example if something was a string or a

00:11:17,930 --> 00:11:24,680
list it happens sometimes with api's I

00:11:21,530 --> 00:11:28,070
am accepting a simple object that's a

00:11:24,680 --> 00:11:30,650
string of text or a list of texts and

00:11:28,070 --> 00:11:33,830
you cannot tell them apart by just

00:11:30,650 --> 00:11:37,280
trying to slice them because if you if

00:11:33,830 --> 00:11:39,620
you will create a for loop on your in on

00:11:37,280 --> 00:11:42,530
your parameter the for loop on the

00:11:39,620 --> 00:11:46,020
string works because the the string is a

00:11:42,530 --> 00:11:50,730
sizable can be sliced

00:11:46,020 --> 00:11:54,330
okay so - level - yeah what is the

00:11:50,730 --> 00:11:56,940
meaning of being a subclass in vitam so

00:11:54,330 --> 00:12:00,390
if you know some Python you could say

00:11:56,940 --> 00:12:02,880
well being a subclass is something that

00:12:00,390 --> 00:12:08,040
you can do when you inherit from another

00:12:02,880 --> 00:12:11,190
class and actually this is - it's one of

00:12:08,040 --> 00:12:14,220
the two methods this is what we call

00:12:11,190 --> 00:12:16,200
real subclass you will inherit from our

00:12:14,220 --> 00:12:20,730
class so child class inherits from

00:12:16,200 --> 00:12:23,190
parent class and the relationship we -

00:12:20,730 --> 00:12:26,459
the two classes is very important it's

00:12:23,190 --> 00:12:29,040
on the bottom so child class knows by in

00:12:26,459 --> 00:12:32,610
class if you have an instance of child

00:12:29,040 --> 00:12:35,700
class you can go and check a runtime

00:12:32,610 --> 00:12:38,339
that parent class is the parent it's in

00:12:35,700 --> 00:12:41,550
the basis attribute but pine class

00:12:38,339 --> 00:12:44,160
doesn't know anything about a class it's

00:12:41,550 --> 00:12:46,470
a responsible parent okay just spawns

00:12:44,160 --> 00:12:49,230
children and doesn't know anything about

00:12:46,470 --> 00:12:51,240
them so you cannot go to parent class

00:12:49,230 --> 00:12:54,630
and ask can you tell me all your

00:12:51,240 --> 00:12:58,440
children in my code base though doesn't

00:12:54,630 --> 00:13:01,050
work the second method is to be a

00:12:58,440 --> 00:13:04,620
virtual subclass this could be new to

00:13:01,050 --> 00:13:08,040
you and actually is called registering

00:13:04,620 --> 00:13:11,820
in the object-oriented word in Python as

00:13:08,040 --> 00:13:13,950
well what you do is to register or

00:13:11,820 --> 00:13:17,220
register on probably the child class

00:13:13,950 --> 00:13:19,560
into the pint glass and in this case the

00:13:17,220 --> 00:13:22,529
relationship is the opposite parent

00:13:19,560 --> 00:13:26,040
class knows that child class is a is a

00:13:22,529 --> 00:13:28,250
child class sorry upon intended but chai

00:13:26,040 --> 00:13:31,320
class doesn't know anything about point

00:13:28,250 --> 00:13:35,570
you are just assigned child class to a

00:13:31,320 --> 00:13:38,760
parent and this is important because

00:13:35,570 --> 00:13:41,370
classes that can register other classes

00:13:38,760 --> 00:13:43,709
are called absolute basic classes so

00:13:41,370 --> 00:13:46,589
this is the definition for today's talk

00:13:43,709 --> 00:13:50,390
an absurd base class is something that

00:13:46,589 --> 00:13:53,970
can register another class and in the

00:13:50,390 --> 00:13:57,840
collections module code base you can go

00:13:53,970 --> 00:13:59,610
and check it on github I found that this

00:13:57,840 --> 00:14:01,710
called this lines which are very

00:13:59,610 --> 00:14:03,750
interesting because it says sequence

00:14:01,710 --> 00:14:06,750
which is a class an absolute base class

00:14:03,750 --> 00:14:09,750
defined in that module says I registered

00:14:06,750 --> 00:14:11,550
topple a tuple I register string and a

00:14:09,750 --> 00:14:14,690
register range for example

00:14:11,550 --> 00:14:18,480
so those three thing things are

00:14:14,690 --> 00:14:22,560
sequences because sequence registers

00:14:18,480 --> 00:14:24,840
them and a list is also registered as a

00:14:22,560 --> 00:14:30,870
mutable sequence which is not a thing is

00:14:24,840 --> 00:14:34,770
not a mutable sequence in pite one very

00:14:30,870 --> 00:14:37,860
important thing to remember is that

00:14:34,770 --> 00:14:42,510
register registering is a promise so

00:14:37,860 --> 00:14:45,740
python does no absolutely no check so if

00:14:42,510 --> 00:14:50,490
you register sorry i go back if you say

00:14:45,740 --> 00:14:54,900
sequence register tupple so there is no

00:14:50,490 --> 00:14:57,630
check done by python about tapo so the

00:14:54,900 --> 00:15:00,630
double provides some methods right on at

00:14:57,630 --> 00:15:05,820
Apple has some attributes no it's really

00:15:00,630 --> 00:15:08,490
just a promise an example of this here I

00:15:05,820 --> 00:15:11,430
import collections I define a class my

00:15:08,490 --> 00:15:14,130
class which is empty and doesn't inherit

00:15:11,430 --> 00:15:19,560
from anything but object so it's pretty

00:15:14,130 --> 00:15:22,080
empty if I issue is subclass my class of

00:15:19,560 --> 00:15:27,420
collection sequence obviously I get a

00:15:22,080 --> 00:15:30,570
false luckily this is not a list but

00:15:27,420 --> 00:15:33,210
here the trick I register it so it's a

00:15:30,570 --> 00:15:36,690
collection sequence register my class I

00:15:33,210 --> 00:15:40,380
say my class is it behaves like a

00:15:36,690 --> 00:15:44,850
sequence and Python beautifully says

00:15:40,380 --> 00:15:48,180
it's - ok so it's a very powerful

00:15:44,850 --> 00:15:50,790
mechanism but we great power comes great

00:15:48,180 --> 00:15:55,530
responsibility right absorb is classes

00:15:50,790 --> 00:15:59,130
are categories just labels ok tags if

00:15:55,530 --> 00:16:01,530
you want it's a way to say yes this

00:15:59,130 --> 00:16:04,920
class behaves like that but it's just

00:16:01,530 --> 00:16:09,059
you know it's a promise I am tagging my

00:16:04,920 --> 00:16:12,509
class as a sequence or mutable diction

00:16:09,059 --> 00:16:14,429
a mapping or whatever you are promising

00:16:12,509 --> 00:16:16,649
yourself for the other programmers that

00:16:14,429 --> 00:16:21,899
your class is behaving like you want

00:16:16,649 --> 00:16:27,149
you're like you promised on to level

00:16:21,899 --> 00:16:30,479
three how do you build you on absurd

00:16:27,149 --> 00:16:32,609
based classes and this is take from the

00:16:30,479 --> 00:16:35,609
docs because the example is so good that

00:16:32,609 --> 00:16:38,459
is no is not worth implementing it so

00:16:35,609 --> 00:16:40,879
from ABC which is the module that

00:16:38,459 --> 00:16:43,979
defines absolutely exhausted I import

00:16:40,879 --> 00:16:48,419
ABC meta which is a meta class more on

00:16:43,979 --> 00:16:52,619
that in why I define a class which is

00:16:48,419 --> 00:16:54,959
just a plain empty class my AB my ABC

00:16:52,619 --> 00:16:58,379
and I define the metaclass of that class

00:16:54,959 --> 00:17:02,219
is ABC meta it's just cold ok my class

00:16:58,379 --> 00:17:05,970
can be empty and then I can use

00:17:02,219 --> 00:17:09,299
magically so to use register so you can

00:17:05,970 --> 00:17:14,429
say for example my ABC register tupple

00:17:09,299 --> 00:17:17,699
and what happens is that I can say that

00:17:14,429 --> 00:17:20,399
Apple is a subclass of my ABC because I

00:17:17,699 --> 00:17:21,899
registered it and I can say that an

00:17:20,399 --> 00:17:24,659
instance of toppled like the two

00:17:21,899 --> 00:17:31,129
parentheses there an instance of my ABC

00:17:24,659 --> 00:17:37,139
so it's pretty easy to define an ABC y

00:17:31,129 --> 00:17:38,700
metaclasses first of all don't panic ok

00:17:37,139 --> 00:17:43,649
there's a reason why I wear this t-shirt

00:17:38,700 --> 00:17:46,019
today meta classes are used by Python

00:17:43,649 --> 00:17:48,450
programmer to sketch it and in the night

00:17:46,019 --> 00:17:51,059
when if they don't go to bed right so I

00:17:48,450 --> 00:17:55,080
want to show you that meta classes are

00:17:51,059 --> 00:18:01,320
not complex not more difficult than

00:17:55,080 --> 00:18:03,889
classes here I have a very simple Python

00:18:01,320 --> 00:18:06,869
code I think it's a class definition an

00:18:03,889 --> 00:18:10,590
instantiation of that class and the use

00:18:06,869 --> 00:18:12,520
of the distance so book is a class that

00:18:10,590 --> 00:18:15,670
defines just

00:18:12,520 --> 00:18:18,460
an attribute answer 42 when I

00:18:15,670 --> 00:18:21,490
instantiate the book I can use the

00:18:18,460 --> 00:18:24,520
instance and say please instance give me

00:18:21,490 --> 00:18:26,980
the answer and the answer is 42 it easy

00:18:24,520 --> 00:18:33,150
I think everyone here understand this

00:18:26,980 --> 00:18:36,090
code this is the user of a meta class I

00:18:33,150 --> 00:18:40,030
define the meta class which is a class

00:18:36,090 --> 00:18:42,520
it now it's fun type has an init with

00:18:40,030 --> 00:18:44,530
some parameters and I can define

00:18:42,520 --> 00:18:49,120
something inside so for example sever

00:18:44,530 --> 00:18:52,090
answer 42 sounds familiar I can link a

00:18:49,120 --> 00:18:56,710
class and a meta class so I can say my

00:18:52,090 --> 00:18:59,920
class book has a meta class and they can

00:18:56,710 --> 00:19:01,990
use the class and say now please class

00:18:59,920 --> 00:19:08,350
give me the answer and the answer is

00:19:01,990 --> 00:19:09,790
again 42 I want to compare the two so on

00:19:08,350 --> 00:19:12,550
the left you have the class

00:19:09,790 --> 00:19:15,970
instantiation on the right you have the

00:19:12,550 --> 00:19:18,280
meta class definition and I think they

00:19:15,970 --> 00:19:21,940
are pretty much the same thing so you

00:19:18,280 --> 00:19:26,050
have a definition of a class or a meta

00:19:21,940 --> 00:19:29,440
class you have a use of the class or the

00:19:26,050 --> 00:19:31,020
meta class and you have an instance of

00:19:29,440 --> 00:19:34,540
the thing

00:19:31,020 --> 00:19:37,600
why because metaclasses so class is

00:19:34,540 --> 00:19:40,380
impart on our ideas right so it's

00:19:37,600 --> 00:19:44,710
something that is sort of a template of

00:19:40,380 --> 00:19:46,809
a concrete instance and the metaclass

00:19:44,710 --> 00:19:50,410
is the same thing is the IP is the

00:19:46,809 --> 00:19:52,570
template of a class I want a class to

00:19:50,410 --> 00:19:54,809
behave some in some way the class not

00:19:52,570 --> 00:19:57,850
the instance I create a meta class I

00:19:54,809 --> 00:20:00,400
think it's pretty easy if you know how

00:19:57,850 --> 00:20:02,290
to create an instance from a class you

00:20:00,400 --> 00:20:05,679
know how to create a class from a metal

00:20:02,290 --> 00:20:09,880
glass and why yeah

00:20:05,679 --> 00:20:13,179
it is simple in my opinion why are we

00:20:09,880 --> 00:20:16,809
using meta classes so well for instance

00:20:13,179 --> 00:20:22,059
because we need the classes to contain

00:20:16,809 --> 00:20:24,460
this register method we started from the

00:20:22,059 --> 00:20:26,300
need of having a register method in the

00:20:24,460 --> 00:20:28,190
class we want the class to be

00:20:26,300 --> 00:20:32,410
to register other classes because we

00:20:28,190 --> 00:20:35,900
want to tag them right like a stamp and

00:20:32,410 --> 00:20:38,210
metaclasses can put things into the

00:20:35,900 --> 00:20:42,950
class so we use the methyls to say now I

00:20:38,210 --> 00:20:46,730
get my ABC my my ABC class and they put

00:20:42,950 --> 00:20:51,400
inside the register method and magically

00:20:46,730 --> 00:20:54,920
I have it because of the metaclass once

00:20:51,400 --> 00:20:59,780
alex modality which is who is here asked

00:20:54,920 --> 00:21:03,230
me why don't we don't we use decorators

00:20:59,780 --> 00:21:07,610
for example can be done i decorate my

00:21:03,230 --> 00:21:10,730
ABC class and I put the register method

00:21:07,610 --> 00:21:14,120
inside well decorators can be inherited

00:21:10,730 --> 00:21:16,310
can't be inherited so if you inherit

00:21:14,120 --> 00:21:19,460
from a class that is decorated you don't

00:21:16,310 --> 00:21:22,280
inherit the decorator but you inherit

00:21:19,460 --> 00:21:25,250
the metaclass so meta classes are more

00:21:22,280 --> 00:21:30,170
powerful in this case than the curators

00:21:25,250 --> 00:21:31,400
oh yeah sorry I have a slide on that you

00:21:30,170 --> 00:21:35,810
inherit the metaclass

00:21:31,400 --> 00:21:39,500
here you see I define my ABC which is an

00:21:35,810 --> 00:21:44,150
ABC meta and then other ABC which

00:21:39,500 --> 00:21:47,860
inherits from my ABC and I can use other

00:21:44,150 --> 00:21:51,790
ABC just like I use my ABC so

00:21:47,860 --> 00:21:56,120
inheritance works here it's important

00:21:51,790 --> 00:21:59,480
last two slides about our different

00:21:56,120 --> 00:22:01,280
views of absorb based classes I'm not

00:21:59,480 --> 00:22:02,720
very fond of it but it's worth

00:22:01,280 --> 00:22:05,810
mentioning it because it's in the

00:22:02,720 --> 00:22:08,150
documentation you can use absolute based

00:22:05,810 --> 00:22:09,890
classes to build interfaces if you are

00:22:08,150 --> 00:22:11,960
familiar with other object-oriented

00:22:09,890 --> 00:22:13,850
programming languages like Java for

00:22:11,960 --> 00:22:17,200
example you know that there's a concept

00:22:13,850 --> 00:22:20,570
called interface which is something that

00:22:17,200 --> 00:22:24,140
enforces our structure of the object so

00:22:20,570 --> 00:22:29,240
for example you say my class has to

00:22:24,140 --> 00:22:32,360
contain the status method in Java if you

00:22:29,240 --> 00:22:35,090
do this it is the compiler complains if

00:22:32,360 --> 00:22:37,460
you don't include the method so doesn't

00:22:35,090 --> 00:22:39,090
compile in Python

00:22:37,460 --> 00:22:41,580
well we for

00:22:39,090 --> 00:22:44,430
many years we didn't have that and now

00:22:41,580 --> 00:22:47,580
we can do it with the absol method

00:22:44,430 --> 00:22:51,450
method decoration decorator sorry which

00:22:47,580 --> 00:22:54,120
is defined in the ABC module so you just

00:22:51,450 --> 00:22:57,630
define your class like you did before

00:22:54,120 --> 00:23:02,100
it's an ABC meta okay and you can put an

00:22:57,630 --> 00:23:05,880
absolute method which is something that

00:23:02,100 --> 00:23:09,120
gets checked when you instantiate the

00:23:05,880 --> 00:23:09,810
class so in the red box you see what

00:23:09,120 --> 00:23:13,320
happens

00:23:09,810 --> 00:23:16,290
if you try to instantiate the stateís

00:23:13,320 --> 00:23:20,010
interface it says type error because you

00:23:16,290 --> 00:23:21,960
cannot instantiate an abstract class why

00:23:20,010 --> 00:23:23,730
is not abstract class because doesn't

00:23:21,960 --> 00:23:26,630
contain an implementation of the stateís

00:23:23,730 --> 00:23:30,720
method is flagged as an abstract method

00:23:26,630 --> 00:23:33,270
if you inherit from status interface in

00:23:30,720 --> 00:23:36,330
this case and you don't define the

00:23:33,270 --> 00:23:38,250
status method python complains with a

00:23:36,330 --> 00:23:43,140
type error saying you cannot instantiate

00:23:38,250 --> 00:23:45,930
it you have to do it I'm not

00:23:43,140 --> 00:23:48,510
particularly fond of it but it's my

00:23:45,930 --> 00:23:50,580
personal opinion because I think python

00:23:48,510 --> 00:23:55,460
is a very very dynamic language so you

00:23:50,580 --> 00:23:59,150
strongly believe in providing behaviors

00:23:55,460 --> 00:24:01,890
flagging things and not enforcing the

00:23:59,150 --> 00:24:04,020
presence of methods but it can be useful

00:24:01,890 --> 00:24:05,790
so if you want to use it go and check

00:24:04,020 --> 00:24:08,670
the documentation because there are

00:24:05,790 --> 00:24:13,080
other decorators absurd property for

00:24:08,670 --> 00:24:15,290
example attribute and so on and that's

00:24:13,080 --> 00:24:15,290
all

00:24:15,650 --> 00:24:22,430
[Applause]

00:24:20,860 --> 00:24:28,310
[Music]

00:24:22,430 --> 00:24:28,310
questions was it too fast sorry

00:24:38,280 --> 00:24:44,020
hi next to talk in the beginning you

00:24:42,520 --> 00:24:48,760
briefly mentioned that it's not possible

00:24:44,020 --> 00:24:50,890
to this router that is kyudo me okay

00:24:48,760 --> 00:24:52,600
cool in the beginning you mentioned that

00:24:50,890 --> 00:24:55,360
it's not as easy to distinguish between

00:24:52,600 --> 00:24:57,549
string like things and lists like things

00:24:55,360 --> 00:25:00,880
you mentioned an API example that takes

00:24:57,549 --> 00:25:02,830
either a string or a list of strings you

00:25:00,880 --> 00:25:07,210
said it's not possible and then you went

00:25:02,830 --> 00:25:08,590
a bit deeper can you give advice on what

00:25:07,210 --> 00:25:10,809
is the proper approach to do this

00:25:08,590 --> 00:25:14,110
without falling back to like the ugly

00:25:10,809 --> 00:25:19,540
type tracks as you said yeah well

00:25:14,110 --> 00:25:23,860
actually it's an example of well I hired

00:25:19,540 --> 00:25:26,080
to implement it and you can do it yeah

00:25:23,860 --> 00:25:28,000
for example if you use collection

00:25:26,080 --> 00:25:32,140
sequence that doesn't work right because

00:25:28,000 --> 00:25:36,220
a string and at least both sequences you

00:25:32,140 --> 00:25:40,360
can use mutable sequence because list is

00:25:36,220 --> 00:25:45,610
mutable and string is not obviously if

00:25:40,360 --> 00:25:48,220
you if you need to tell apart two things

00:25:45,610 --> 00:25:50,380
that are mutable and sequences you

00:25:48,220 --> 00:25:52,890
cannot use collections right so if you

00:25:50,380 --> 00:25:55,570
define something which is like a list

00:25:52,890 --> 00:25:59,950
but it's different and you want to tell

00:25:55,570 --> 00:26:01,929
a list and your class apart and you have

00:25:59,950 --> 00:26:04,390
to define your own absolute based class

00:26:01,929 --> 00:26:07,720
and say okay I flag my I label my

00:26:04,390 --> 00:26:10,030
classes I don't know what my category

00:26:07,720 --> 00:26:12,220
and then I check that from the

00:26:10,030 --> 00:26:15,070
collections you can do it with the

00:26:12,220 --> 00:26:19,500
mutable sequence so yeah multiple

00:26:15,070 --> 00:26:19,500
mutable sequence it is pretty easy to do

00:26:21,299 --> 00:26:31,120
also thanks for your talk and I wanted

00:26:25,179 --> 00:26:33,880
to ask when you create a child class

00:26:31,120 --> 00:26:34,540
then the parent class gets put in the

00:26:33,880 --> 00:26:39,070
Amero

00:26:34,540 --> 00:26:42,809
and arrow and i was wondering when you

00:26:39,070 --> 00:26:48,910
register where where is this information

00:26:42,809 --> 00:26:49,910
internally health in the class if you

00:26:48,910 --> 00:26:55,070
know

00:26:49,910 --> 00:26:58,700
I don't know actually my question not

00:26:55,070 --> 00:27:01,130
clear or you didn't use it so if I

00:26:58,700 --> 00:27:04,430
understood the question is your question

00:27:01,130 --> 00:27:07,370
is when I register here yeah all Apple

00:27:04,430 --> 00:27:09,410
where is the concept that the

00:27:07,370 --> 00:27:13,010
information about you're reducing is

00:27:09,410 --> 00:27:17,360
well I don't know exactly where but it's

00:27:13,010 --> 00:27:21,320
inside my my ABC class so in Python

00:27:17,360 --> 00:27:24,470
classes are objects like so you can't do

00:27:21,320 --> 00:27:26,980
for example my ABC dots done the name

00:27:24,470 --> 00:27:29,600
and you get the name of the class and

00:27:26,980 --> 00:27:31,100
inside there I don't actually I don't

00:27:29,600 --> 00:27:34,400
have an answer so I don't I don't know

00:27:31,100 --> 00:27:37,100
the name of the attribute when I was

00:27:34,400 --> 00:27:40,550
investigating Python object I found here

00:27:37,100 --> 00:27:42,980
as a very useful function so triangle in

00:27:40,550 --> 00:27:44,930
circuit I tried I didn't find it that

00:27:42,980 --> 00:27:45,830
that's what I decided so okay nice and

00:27:44,930 --> 00:27:49,280
inviting

00:27:45,830 --> 00:27:51,110
I put dear on on the sequence and I was

00:27:49,280 --> 00:27:54,290
trying to find like when you register

00:27:51,110 --> 00:27:56,090
but I didn't well we can do it later and

00:27:54,290 --> 00:28:04,250
yeah to figure out it's very interesting

00:27:56,090 --> 00:28:09,380
thank you having anyone else if not I've

00:28:04,250 --> 00:28:12,530
got one question ok so back to the

00:28:09,380 --> 00:28:14,660
question of why why a metal class and

00:28:12,530 --> 00:28:18,500
not a decorator have you thought about

00:28:14,660 --> 00:28:20,510
why just not make register a class

00:28:18,500 --> 00:28:24,770
method and then inherit instead of

00:28:20,510 --> 00:28:31,640
having a metal class maybe well I think

00:28:24,770 --> 00:28:34,280
it's because you want to okay in Python

00:28:31,640 --> 00:28:39,260
you can have multiple inheritance right

00:28:34,280 --> 00:28:41,240
it's a hell so if it's fine for very

00:28:39,260 --> 00:28:45,080
simple cases but when you try to have

00:28:41,240 --> 00:28:49,010
too many parents the problem is that you

00:28:45,080 --> 00:28:52,400
don't you know theoretically the methods

00:28:49,010 --> 00:28:54,650
of a solution order right but in

00:28:52,400 --> 00:28:57,380
practice it's sometimes very complex if

00:28:54,650 --> 00:28:59,540
you use Django sometimes we would make

00:28:57,380 --> 00:29:01,410
sense you really don't know who define

00:28:59,540 --> 00:29:05,550
that that's in that metal

00:29:01,410 --> 00:29:09,630
so the problem with inheritance is that

00:29:05,550 --> 00:29:12,140
you create very big Hina dances trees so

00:29:09,630 --> 00:29:15,210
I think that the point is to avoid

00:29:12,140 --> 00:29:18,840
pushing further in items which is

00:29:15,210 --> 00:29:22,110
already a bit too abused sometimes we

00:29:18,840 --> 00:29:25,920
forget composition you know so it could

00:29:22,110 --> 00:29:28,740
be possible yeah in theory and well in

00:29:25,920 --> 00:29:30,900
practice as well but practically leads

00:29:28,740 --> 00:29:33,720
to the use of multiple intern

00:29:30,900 --> 00:29:38,040
inheritance and I like they don't taken

00:29:33,720 --> 00:29:42,750
took this is way to go hey thank you any

00:29:38,040 --> 00:29:44,060
other questions if not that's a big hand

00:29:42,750 --> 00:29:51,500
for our speaker

00:29:44,060 --> 00:29:51,500

YouTube URL: https://www.youtube.com/watch?v=I9nXiJQnGsk


