Title: Alexander Steffen - Testing microcontroller firmware with Python
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Testing microcontroller firmware with Python
[EuroPython 2017 - Talk - 2017-07-10 - Arengo]
[Rimini, Italy]

Last year's talk (https://ep2016.europython.eu/conference/talks/writing-unit-tests-for-c-code-in-python) showed you how to use CFFI (https://cffi.readthedocs.io/) to write unit tests for C code in Python. This year we will take the concept one step further and create integration tests covering (almost) the whole firmware of a microcontroller, again leveraging the power of CFFI.

But instead of running the firmware on the controller, it will be executed on the development machine (that is, a standard x86 architecture), allowing for much faster test execution, without requiring the target hardware. For this to work, all the hardware-dependent parts of the firmware code need to be replaced by Python code simulating the hardware functionality, so that all the firmware above this hardware abstraction layer can be executed unmodified.

In addition, this allows to use advanced security testing tools like AddressSanitizer (https://github.com/google/sanitizers/wiki/AddressSanitizer) and american fuzzy lop (http://lcamtuf.coredump.cx/afl/) that would not be able to run directly on the microcontroller.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:07,250 --> 00:00:12,360
hello I'm Alexander and I work as an

00:00:10,290 --> 00:00:14,820
embedded software developer so I write

00:00:12,360 --> 00:00:16,619
FEM before microcontrollers and today

00:00:14,820 --> 00:00:19,349
I'm going to show you how you can test

00:00:16,619 --> 00:00:21,149
such member much faster when not running

00:00:19,349 --> 00:00:25,230
it on the real device but integrating it

00:00:21,149 --> 00:00:27,630
with Python and I already gave a talk in

00:00:25,230 --> 00:00:29,880
a similar direction last year and was

00:00:27,630 --> 00:00:33,390
called writing unit tests for C code in

00:00:29,880 --> 00:00:35,820
Python where I used the C F of I library

00:00:33,390 --> 00:00:37,879
to just extract single functions or

00:00:35,820 --> 00:00:40,350
single modules from your C source code

00:00:37,879 --> 00:00:41,399
build a Python module out of it so that

00:00:40,350 --> 00:00:43,440
you could load it into your Python

00:00:41,399 --> 00:00:48,210
process and then use all of pythons

00:00:43,440 --> 00:00:51,329
power to write unit tests I'm building

00:00:48,210 --> 00:00:53,190
on this idea today and you might have

00:00:51,329 --> 00:00:55,260
already seen in other contexts this

00:00:53,190 --> 00:00:56,819
hierarchy of tests with the unit tests

00:00:55,260 --> 00:00:59,460
last year we were at bottom level where

00:00:56,819 --> 00:01:01,050
we only look at individual modules

00:00:59,460 --> 00:01:03,449
individual functions and try to test

00:01:01,050 --> 00:01:06,060
them but of course it's also important

00:01:03,449 --> 00:01:09,330
to test your code in integration with

00:01:06,060 --> 00:01:10,950
all the other parts and so this year

00:01:09,330 --> 00:01:13,680
we're going to move up a layer into the

00:01:10,950 --> 00:01:16,080
integration tests and try to make sure

00:01:13,680 --> 00:01:20,130
that basically all of our firmware

00:01:16,080 --> 00:01:23,370
really works and the motivation for that

00:01:20,130 --> 00:01:25,950
is that the fender that rewrite is

00:01:23,370 --> 00:01:27,900
rather complex so in the end we might

00:01:25,950 --> 00:01:30,900
have half a megabyte of compiled code on

00:01:27,900 --> 00:01:33,510
our microcontroller for this we've

00:01:30,900 --> 00:01:36,060
written thousands of test cases and when

00:01:33,510 --> 00:01:37,830
we run those against the real device it

00:01:36,060 --> 00:01:40,290
takes several hours for all those tests

00:01:37,830 --> 00:01:41,790
to complete and as a developer and

00:01:40,290 --> 00:01:43,650
that's not really what I want because

00:01:41,790 --> 00:01:46,380
when I make a change to the software I

00:01:43,650 --> 00:01:47,010
need to know fast whether this change is

00:01:46,380 --> 00:01:49,650
good or bad

00:01:47,010 --> 00:01:51,360
maybe quarter of an hour is the upper

00:01:49,650 --> 00:01:54,750
limit for me I don't want to wait hours

00:01:51,360 --> 00:01:56,670
before I can tell that so what we did in

00:01:54,750 --> 00:01:59,490
the past was we just selected a subset

00:01:56,670 --> 00:02:01,260
of those test cases that try to cover as

00:01:59,490 --> 00:02:04,470
much as possible but of course you can't

00:02:01,260 --> 00:02:05,940
guarantee that it really gets every

00:02:04,470 --> 00:02:07,890
corner case that you have in your code

00:02:05,940 --> 00:02:10,500
base so there might still be errors that

00:02:07,890 --> 00:02:15,260
slipped through this is what I want to

00:02:10,500 --> 00:02:15,260
avoid and how this project started

00:02:15,370 --> 00:02:20,379
so I'm first going to show you the basic

00:02:17,860 --> 00:02:22,330
concept now and then afterwards give you

00:02:20,379 --> 00:02:24,819
a complete demonstration based on on

00:02:22,330 --> 00:02:28,569
some vembur example to show you really

00:02:24,819 --> 00:02:29,920
the code that does all that if you look

00:02:28,569 --> 00:02:31,569
at your typical microcontroller

00:02:29,920 --> 00:02:33,760
application it might look something like

00:02:31,569 --> 00:02:36,700
that you've got a large application code

00:02:33,760 --> 00:02:38,620
base that's ready standard C code that

00:02:36,700 --> 00:02:40,540
you could compile for any architecture

00:02:38,620 --> 00:02:42,459
but of course you've also got Hardware

00:02:40,540 --> 00:02:44,230
specific parts and if you've structured

00:02:42,459 --> 00:02:46,299
your firmware in some way you might have

00:02:44,230 --> 00:02:48,310
an opera abstraction layer that really

00:02:46,299 --> 00:02:51,400
interfaces with the hardware and

00:02:48,310 --> 00:02:54,069
provides a nice and clean C interface to

00:02:51,400 --> 00:02:56,230
your application and this is what we

00:02:54,069 --> 00:02:58,090
based this approach on because we want

00:02:56,230 --> 00:03:00,760
to make it look like this we keep the

00:02:58,090 --> 00:03:02,709
application code and just replace the

00:03:00,760 --> 00:03:05,319
abstraction layer beneath it with some

00:03:02,709 --> 00:03:06,819
Python code and the approach for this

00:03:05,319 --> 00:03:10,290
will be similar to what I showed last

00:03:06,819 --> 00:03:14,019
year with the CF of my library mm-hmm

00:03:10,290 --> 00:03:15,879
but first when we are talking in the in

00:03:14,019 --> 00:03:17,560
the context of microcontroller Femina

00:03:15,879 --> 00:03:20,950
that's already written and C you might

00:03:17,560 --> 00:03:22,959
wonder why do we use Python at all we

00:03:20,950 --> 00:03:24,190
could just replace this this Harper

00:03:22,959 --> 00:03:26,109
abstraction layer with a different

00:03:24,190 --> 00:03:29,380
hardware abstraction layer for another

00:03:26,109 --> 00:03:32,889
machine that's faster and just use C for

00:03:29,380 --> 00:03:34,630
that why why Python now we are at a

00:03:32,889 --> 00:03:35,980
patent conference here so I don't need

00:03:34,630 --> 00:03:37,660
to tell you much about the general

00:03:35,980 --> 00:03:40,480
advantages that Python has over other

00:03:37,660 --> 00:03:43,660
languages when you're compared with with

00:03:40,480 --> 00:03:45,250
a code then you can easily see that you

00:03:43,660 --> 00:03:48,760
need to write less code to achieve the

00:03:45,250 --> 00:03:51,060
same results and it's also usually

00:03:48,760 --> 00:03:53,049
easier to use for example our

00:03:51,060 --> 00:03:55,599
microcontrollers have a cryptographic

00:03:53,049 --> 00:03:58,180
functionality built in hardware so we

00:03:55,599 --> 00:03:59,620
have for example and a peripheral in

00:03:58,180 --> 00:04:02,019
there where we can just pass in some

00:03:59,620 --> 00:04:04,000
data it does the AES encryption in

00:04:02,019 --> 00:04:05,319
hardware and returns back the result so

00:04:04,000 --> 00:04:07,060
this is something that we have to

00:04:05,319 --> 00:04:09,790
re-implement in our Python code for this

00:04:07,060 --> 00:04:10,660
to work and there are libraries and see

00:04:09,790 --> 00:04:11,859
where you can do that there are

00:04:10,660 --> 00:04:13,480
libraries in Python where you can do

00:04:11,859 --> 00:04:15,479
that but the pattern ones are usually

00:04:13,480 --> 00:04:18,549
easier to use easier to get around with

00:04:15,479 --> 00:04:20,859
and in the end pattern is also very

00:04:18,549 --> 00:04:22,450
powerful for this approach the the

00:04:20,859 --> 00:04:24,909
hardware abstraction layer might contain

00:04:22,450 --> 00:04:27,490
functions that for this simulation that

00:04:24,909 --> 00:04:29,190
we're going to build here can work

00:04:27,490 --> 00:04:32,040
similar and don't need a different in

00:04:29,190 --> 00:04:34,020
so you can just use a single template in

00:04:32,040 --> 00:04:35,430
Python and let Python generate the code

00:04:34,020 --> 00:04:37,560
for all those functions that you need

00:04:35,430 --> 00:04:40,080
you don't need to specify each and every

00:04:37,560 --> 00:04:44,250
function in your and your C code just

00:04:40,080 --> 00:04:45,810
for the for the program to compile this

00:04:44,250 --> 00:04:47,610
is now what I'm going to show you the

00:04:45,810 --> 00:04:50,340
general approach is that we'll collect

00:04:47,610 --> 00:04:51,990
all the applications C source code all

00:04:50,340 --> 00:04:55,440
the implementation of the application

00:04:51,990 --> 00:04:57,150
and we'll collect all the header parts

00:04:55,440 --> 00:04:59,010
of the software abstraction layer so

00:04:57,150 --> 00:05:01,530
everything that specifies the interface

00:04:59,010 --> 00:05:03,540
of the hardware abstraction layer and

00:05:01,530 --> 00:05:06,780
when we've got both of those parts we

00:05:03,540 --> 00:05:08,610
can pass them on to C FF I see if I will

00:05:06,780 --> 00:05:11,640
use this information to generate a

00:05:08,610 --> 00:05:13,920
Python loadable module that we can then

00:05:11,640 --> 00:05:15,960
run from our Python interpreter and then

00:05:13,920 --> 00:05:18,810
we have our application running inside a

00:05:15,960 --> 00:05:20,790
Python process on a normal machine not

00:05:18,810 --> 00:05:22,200
on our microcontroller and since the

00:05:20,790 --> 00:05:24,180
normal machine is much faster than the

00:05:22,200 --> 00:05:25,470
microcontroller hopefully also our

00:05:24,180 --> 00:05:29,820
application will be much faster and our

00:05:25,470 --> 00:05:31,860
tests can execute faster so as an

00:05:29,820 --> 00:05:34,110
example I can unfortunately not show you

00:05:31,860 --> 00:05:37,800
our real code so I looked for a

00:05:34,110 --> 00:05:39,960
different project and I chose the micro

00:05:37,800 --> 00:05:42,480
Python project because it's also very

00:05:39,960 --> 00:05:45,090
complex and a very complex project and

00:05:42,480 --> 00:05:46,800
has a lot of code so it get really an

00:05:45,090 --> 00:05:48,450
impression of real life application of

00:05:46,800 --> 00:05:50,190
this approach and not some artificial

00:05:48,450 --> 00:05:55,380
example that I just constructed for this

00:05:50,190 --> 00:05:57,720
talk you might have already heard about

00:05:55,380 --> 00:05:59,040
the micro Python project if not a quick

00:05:57,720 --> 00:06:01,050
explanation is that it's a

00:05:59,040 --> 00:06:02,790
reimplementation of the Python

00:06:01,050 --> 00:06:04,890
programming language that can run

00:06:02,790 --> 00:06:07,080
directly on a microcontroller it started

00:06:04,890 --> 00:06:08,880
several years ago also with a hardware

00:06:07,080 --> 00:06:11,580
device maybe you've seen it in previous

00:06:08,880 --> 00:06:13,200
talk in this room we've got a little

00:06:11,580 --> 00:06:15,270
bored with a small controller on add a

00:06:13,200 --> 00:06:17,640
lot of hardware peripherals that you can

00:06:15,270 --> 00:06:21,360
access from your Python code more or

00:06:17,640 --> 00:06:23,460
less directly and it has basically full

00:06:21,360 --> 00:06:27,360
compatibility compatibility to the

00:06:23,460 --> 00:06:29,550
standard C Python 3.5 code so they don't

00:06:27,360 --> 00:06:33,690
provide all the features but most that

00:06:29,550 --> 00:06:35,250
you want to use and first we'll have a

00:06:33,690 --> 00:06:36,900
look at the structure of the source code

00:06:35,250 --> 00:06:38,580
all the source code is open source you

00:06:36,900 --> 00:06:40,560
can find it on github and if you look at

00:06:38,580 --> 00:06:42,370
the repository then you'll find a

00:06:40,560 --> 00:06:43,810
structure that looks like this

00:06:42,370 --> 00:06:46,120
so there are some files containing

00:06:43,810 --> 00:06:49,330
documentation and then a lot of folders

00:06:46,120 --> 00:06:51,100
and many of those folders contain the

00:06:49,330 --> 00:06:53,169
code that is specific to one micro

00:06:51,100 --> 00:06:55,060
Python port so micro pattern already

00:06:53,169 --> 00:06:57,250
supports not only a single platform but

00:06:55,060 --> 00:07:00,550
multiple platforms they are for example

00:06:57,250 --> 00:07:05,350
some parts even for Windows for UNIX

00:07:00,550 --> 00:07:07,720
systems of the the initial port was this

00:07:05,350 --> 00:07:11,860
one here the St port one esteem based

00:07:07,720 --> 00:07:13,930
microcontroller and in other folders for

00:07:11,860 --> 00:07:16,900
example the PI folder there's the the

00:07:13,930 --> 00:07:18,700
generic didn't the generic code that can

00:07:16,900 --> 00:07:20,470
run in every ports of the PI folder

00:07:18,700 --> 00:07:24,639
contains the the Python interpreter for

00:07:20,470 --> 00:07:27,669
example and for this example I will

00:07:24,639 --> 00:07:30,850
choose the minimal port with us similar

00:07:27,669 --> 00:07:32,650
to the to the St port but very stripped

00:07:30,850 --> 00:07:34,360
down and functionality it just contains

00:07:32,650 --> 00:07:36,729
the bare essentials it gives you a

00:07:34,360 --> 00:07:37,990
pattern shell that can run code but it

00:07:36,729 --> 00:07:41,650
doesn't give you any further hardware

00:07:37,990 --> 00:07:44,320
access but for this demonstration that

00:07:41,650 --> 00:07:46,600
should be sufficient if we look at this

00:07:44,320 --> 00:07:49,180
minimal port this is all the files that

00:07:46,600 --> 00:07:51,789
are contained in there so you see only

00:07:49,180 --> 00:07:53,919
to see files the main c file contains

00:07:51,789 --> 00:07:56,620
the basic application startup code that

00:07:53,919 --> 00:08:00,460
initializes everything and you see this

00:07:56,620 --> 00:08:02,110
your core file at the end this is what

00:08:00,460 --> 00:08:04,240
the the implementation of the hardware

00:08:02,110 --> 00:08:07,030
abstraction layer for this project is so

00:08:04,240 --> 00:08:08,650
it contains some functions for input and

00:08:07,030 --> 00:08:13,660
some functions for output so that we can

00:08:08,650 --> 00:08:15,160
provide the Python shell this is what

00:08:13,660 --> 00:08:16,840
the relevant functions look like from

00:08:15,160 --> 00:08:19,720
this file you've got one function that

00:08:16,840 --> 00:08:21,490
reads a single character of input and

00:08:19,720 --> 00:08:23,490
does something with that and you've got

00:08:21,490 --> 00:08:26,020
another function that can print strings

00:08:23,490 --> 00:08:27,490
just an it output so in case of this

00:08:26,020 --> 00:08:29,710
minimal port if you really run it on the

00:08:27,490 --> 00:08:32,279
pi board that it just uses you our

00:08:29,710 --> 00:08:34,750
communication for that so you see some

00:08:32,279 --> 00:08:37,060
accesses to the UART registers in this

00:08:34,750 --> 00:08:40,029
code and if we try to compile this file

00:08:37,060 --> 00:08:41,620
for our normal machine then this

00:08:40,029 --> 00:08:43,930
wouldn't work because there are no such

00:08:41,620 --> 00:08:45,520
registers where you could write to so

00:08:43,930 --> 00:08:47,830
these are the functions that we want to

00:08:45,520 --> 00:08:50,020
replace with Python code so that we can

00:08:47,830 --> 00:08:51,610
execute them all the rest of this code

00:08:50,020 --> 00:08:53,250
that is contained in the minimal port

00:08:51,610 --> 00:08:56,340
also that's

00:08:53,250 --> 00:08:57,810
imported from the PI folder that should

00:08:56,340 --> 00:09:02,100
run on our architecture without any

00:08:57,810 --> 00:09:03,840
problems so then there's another project

00:09:02,100 --> 00:09:05,790
that I need to talk about quickly and

00:09:03,840 --> 00:09:10,470
that's called PI make that's an

00:09:05,790 --> 00:09:11,790
implementation of the make utility and I

00:09:10,470 --> 00:09:14,520
want to use that in this demonstration

00:09:11,790 --> 00:09:16,380
to parse in the make files that micro

00:09:14,520 --> 00:09:18,750
Python uses for its build process

00:09:16,380 --> 00:09:20,760
because for this approach to work we

00:09:18,750 --> 00:09:22,710
need to use we need to know which source

00:09:20,760 --> 00:09:24,510
code files to integrate into our binary

00:09:22,710 --> 00:09:26,460
where do we find the header files where

00:09:24,510 --> 00:09:27,990
do you find the source code files and of

00:09:26,460 --> 00:09:30,630
course I could just hard code that in

00:09:27,990 --> 00:09:32,970
this example but if you wanted to use

00:09:30,630 --> 00:09:34,710
that productively it makes more sense to

00:09:32,970 --> 00:09:36,660
keep this information in one place and

00:09:34,710 --> 00:09:38,940
the place that already it was chosen

00:09:36,660 --> 00:09:40,830
here is the make file so I just want to

00:09:38,940 --> 00:09:42,390
pass the make file and extract the

00:09:40,830 --> 00:09:44,520
relevant information from there so that

00:09:42,390 --> 00:09:46,080
I can still keep all the information in

00:09:44,520 --> 00:09:48,240
this one place and don't have to adapt

00:09:46,080 --> 00:09:51,720
many places just for this whole process

00:09:48,240 --> 00:09:54,240
to work and if I make gives me such a

00:09:51,720 --> 00:09:57,030
make file pause learn in Python so I'll

00:09:54,240 --> 00:09:58,770
build on on that when we look at the

00:09:57,030 --> 00:10:01,110
micro Python make file one bit of

00:09:58,770 --> 00:10:03,540
interesting information in there are the

00:10:01,110 --> 00:10:06,810
compiler options for example for the

00:10:03,540 --> 00:10:09,600
include directories so it just builds a

00:10:06,810 --> 00:10:11,730
list of those here where specifies some

00:10:09,600 --> 00:10:15,930
directories where we can find the

00:10:11,730 --> 00:10:17,760
include files the header files and in

00:10:15,930 --> 00:10:20,550
order to extract that using PI Mike I

00:10:17,760 --> 00:10:23,250
can tell primate just to parse the make

00:10:20,550 --> 00:10:24,720
file that I have without executing it

00:10:23,250 --> 00:10:28,860
really it just passes all the data

00:10:24,720 --> 00:10:31,170
structures and afterwards I can ask my

00:10:28,860 --> 00:10:34,050
Mike give me the the contents of this

00:10:31,170 --> 00:10:36,300
variable Inc where the where the include

00:10:34,050 --> 00:10:40,050
directories are contained and what I get

00:10:36,300 --> 00:10:44,730
back is not a string but is an object

00:10:40,050 --> 00:10:46,550
the representation you can see here it's

00:10:44,730 --> 00:10:48,839
actually not bad to get back in an

00:10:46,550 --> 00:10:50,400
object like this and not the the raw

00:10:48,839 --> 00:10:54,000
content because if you look at the

00:10:50,400 --> 00:10:55,920
beginning then there is contained in

00:10:54,000 --> 00:10:58,470
this value here that contains a

00:10:55,920 --> 00:11:00,540
reference to another variable so I don't

00:10:58,470 --> 00:11:02,610
I'm not interested in this in the string

00:11:00,540 --> 00:11:04,380
value but I'm need to have this value

00:11:02,610 --> 00:11:06,350
resolved to its actual value in order

00:11:04,380 --> 00:11:08,270
for this process to work

00:11:06,350 --> 00:11:11,210
and this is what can be done with the

00:11:08,270 --> 00:11:14,600
expansion object that the last call here

00:11:11,210 --> 00:11:17,180
returns there's a resolve string method

00:11:14,600 --> 00:11:18,590
on there and this then returns to the

00:11:17,180 --> 00:11:22,520
final string value that I'm interested

00:11:18,590 --> 00:11:26,000
in so I can hide just all this code in a

00:11:22,520 --> 00:11:30,770
simple function so I can use that to

00:11:26,000 --> 00:11:33,500
resolve and now looking at the the

00:11:30,770 --> 00:11:35,300
cleaned-up example we can just call this

00:11:33,500 --> 00:11:37,010
function get back the string that were

00:11:35,300 --> 00:11:39,920
declared in the make file everything

00:11:37,010 --> 00:11:43,490
seems to work so we store this value in

00:11:39,920 --> 00:11:45,200
a variable for later use and start with

00:11:43,490 --> 00:11:48,680
the real process now collecting the

00:11:45,200 --> 00:11:52,010
source code so for collecting the source

00:11:48,680 --> 00:11:53,870
code we'll just change into the micro

00:11:52,010 --> 00:11:56,000
path and minimal port directory so all

00:11:53,870 --> 00:11:58,190
paths are relative to this directory and

00:11:56,000 --> 00:12:00,650
again look at the make file there's a

00:11:58,190 --> 00:12:03,560
variable called source C that lists up

00:12:00,650 --> 00:12:05,150
all the source code files and at the

00:12:03,560 --> 00:12:06,770
beginning you see two that I've already

00:12:05,150 --> 00:12:09,200
shown to you and the main file the u our

00:12:06,770 --> 00:12:11,690
qualifier and then they are there are

00:12:09,200 --> 00:12:14,420
some references to other files in the

00:12:11,690 --> 00:12:18,230
the Lib directory again a directory

00:12:14,420 --> 00:12:20,870
that's shared by multiple ports and so

00:12:18,230 --> 00:12:22,940
we can just extract this list of source

00:12:20,870 --> 00:12:27,110
code again using the function that we've

00:12:22,940 --> 00:12:29,150
already created and again you can see

00:12:27,110 --> 00:12:30,830
here the last variable again contain the

00:12:29,150 --> 00:12:36,200
reference the reference is resolved to

00:12:30,830 --> 00:12:38,150
the actual value now if we want to

00:12:36,200 --> 00:12:41,060
create a list of source files we can use

00:12:38,150 --> 00:12:44,030
again the function converted into a set

00:12:41,060 --> 00:12:45,800
then we need another variable from from

00:12:44,030 --> 00:12:47,540
the make file that I haven't shown you

00:12:45,800 --> 00:12:49,910
so far it contains the list of all the

00:12:47,540 --> 00:12:53,780
source code from the from the PI folder

00:12:49,910 --> 00:12:56,000
not as C files but as object files so we

00:12:53,780 --> 00:12:57,620
just exact the name so that it matches

00:12:56,000 --> 00:12:59,990
to the file system location that we are

00:12:57,620 --> 00:13:03,020
interested in and add that to the set

00:12:59,990 --> 00:13:05,090
and in the end there's one source file

00:13:03,020 --> 00:13:06,680
that we have to remove again that this

00:13:05,090 --> 00:13:08,720
your core file that I showed you in the

00:13:06,680 --> 00:13:10,220
beginning because this isn't really

00:13:08,720 --> 00:13:11,660
source code of the application that's

00:13:10,220 --> 00:13:13,520
the source code of this hardware

00:13:11,660 --> 00:13:17,200
abstraction layer we don't need that now

00:13:13,520 --> 00:13:17,200
so we remove it here

00:13:18,240 --> 00:13:23,910
and then there's one more thing that's

00:13:21,149 --> 00:13:25,529
special about micro Python here if you

00:13:23,910 --> 00:13:27,600
look again at the paths that are

00:13:25,529 --> 00:13:30,510
contained in here the last one refers to

00:13:27,600 --> 00:13:33,660
a directory called built and if you try

00:13:30,510 --> 00:13:34,740
to find that in the source code you

00:13:33,660 --> 00:13:37,440
won't find it

00:13:34,740 --> 00:13:38,880
github because it's not contained in any

00:13:37,440 --> 00:13:41,990
of the commits it's just a file that's

00:13:38,880 --> 00:13:45,600
generated during the build process and

00:13:41,990 --> 00:13:48,750
contains information that micro Python

00:13:45,600 --> 00:13:50,130
extracts from its own source code so we

00:13:48,750 --> 00:13:51,990
just tell the micro Python build

00:13:50,130 --> 00:13:55,410
environment hey please build this file

00:13:51,990 --> 00:14:00,930
for us so we can compile it also into

00:13:55,410 --> 00:14:02,910
our extension module so and then we have

00:14:00,930 --> 00:14:05,580
a list of all the files so we can just

00:14:02,910 --> 00:14:07,529
open all those parts collect the source

00:14:05,580 --> 00:14:08,850
code into one large string that we later

00:14:07,529 --> 00:14:11,430
pass on to CF Fi

00:14:08,850 --> 00:14:13,050
and before we do that we make one more

00:14:11,430 --> 00:14:15,779
modification the last line here just

00:14:13,050 --> 00:14:18,779
renamed the existing main function to NP

00:14:15,779 --> 00:14:20,610
main of course the micro Python port

00:14:18,779 --> 00:14:22,920
assumes that is that it is the only

00:14:20,610 --> 00:14:24,870
application that is running on on this

00:14:22,920 --> 00:14:26,190
machine so it has its own main function

00:14:24,870 --> 00:14:27,900
when we import it into the Python

00:14:26,190 --> 00:14:30,029
interpreter there is already a main

00:14:27,900 --> 00:14:35,700
function so we rename it just to avoid

00:14:30,029 --> 00:14:37,380
any name conflicts here so with this

00:14:35,700 --> 00:14:39,959
that one is complete we have collected

00:14:37,380 --> 00:14:41,790
all the application source code now step

00:14:39,959 --> 00:14:45,570
two is to collect all the hardware

00:14:41,790 --> 00:14:47,190
abstraction layer header files and for

00:14:45,570 --> 00:14:49,260
this minimal port that's rather easy

00:14:47,190 --> 00:14:51,270
there's only one header file that we

00:14:49,260 --> 00:14:52,380
need to include that were only those two

00:14:51,270 --> 00:14:53,910
functions I showed you in the beginning

00:14:52,380 --> 00:14:56,550
the header file defines some more

00:14:53,910 --> 00:14:59,070
functions that are not really used by

00:14:56,550 --> 00:15:02,250
the code so we only need this header

00:14:59,070 --> 00:15:05,640
file but unfortunately we cannot pass it

00:15:02,250 --> 00:15:08,100
directly to see FF I because CF fi

00:15:05,640 --> 00:15:10,170
sparser for this information doesn't

00:15:08,100 --> 00:15:11,850
understand everything that in the C code

00:15:10,170 --> 00:15:14,339
or the C standard allows it just

00:15:11,850 --> 00:15:17,579
understands a subset for example it has

00:15:14,339 --> 00:15:19,620
no idea of preprocessor directors it

00:15:17,579 --> 00:15:22,709
doesn't understand some some attribute

00:15:19,620 --> 00:15:24,420
annotations on the source code so we

00:15:22,709 --> 00:15:26,279
need to clean up the source code in

00:15:24,420 --> 00:15:28,650
order to make C if if I understand it

00:15:26,279 --> 00:15:30,720
and this is something that I've already

00:15:28,650 --> 00:15:31,529
shown last year in the example with the

00:15:30,720 --> 00:15:33,480
unit tests

00:15:31,529 --> 00:15:38,850
I'm going to use similar code in this

00:15:33,480 --> 00:15:42,209
year what we're going to do is this year

00:15:38,850 --> 00:15:43,920
we add some definitions for the C

00:15:42,209 --> 00:15:44,670
preprocessor to the content of the

00:15:43,920 --> 00:15:46,379
header files

00:15:44,670 --> 00:15:48,389
for example for this attribute

00:15:46,379 --> 00:15:50,040
definition that just tells the C

00:15:48,389 --> 00:15:51,749
preprocessor to discard all this

00:15:50,040 --> 00:15:53,850
information see if I doesn't need to

00:15:51,749 --> 00:15:57,240
know about it and if it's not there it

00:15:53,850 --> 00:15:59,339
can't get confused by it and afterwards

00:15:57,240 --> 00:16:01,559
we run the C preprocessor over the

00:15:59,339 --> 00:16:03,870
source code so that it takes care of

00:16:01,559 --> 00:16:07,050
everything that's included of all if

00:16:03,870 --> 00:16:09,180
deaths and other things and then see if

00:16:07,050 --> 00:16:11,430
I can I can understand the results

00:16:09,180 --> 00:16:13,379
so this pre-processed function that's

00:16:11,430 --> 00:16:16,050
used here looks like this it just calls

00:16:13,379 --> 00:16:19,860
the GCC's preprocessor and uses its

00:16:16,050 --> 00:16:22,079
output for the for the further steps and

00:16:19,860 --> 00:16:23,639
you can also see here reference to this

00:16:22,079 --> 00:16:25,319
include options variable from the

00:16:23,639 --> 00:16:27,029
beginning where we specify all the

00:16:25,319 --> 00:16:28,589
include directories of course the

00:16:27,029 --> 00:16:30,779
preprocessor needs to know about that

00:16:28,589 --> 00:16:35,939
and afterwards everything is contained

00:16:30,779 --> 00:16:37,649
in the string we get here so this is now

00:16:35,939 --> 00:16:40,709
an extract from the string that we've

00:16:37,649 --> 00:16:43,170
produced so far there are three function

00:16:40,709 --> 00:16:45,569
prototypes one of them I showed you the

00:16:43,170 --> 00:16:47,639
implementation for for this for the one

00:16:45,569 --> 00:16:51,660
in the middle that can output in string

00:16:47,639 --> 00:16:55,110
of arbitrary length and we can pass this

00:16:51,660 --> 00:16:56,910
code to CF Fi but what we want to do is

00:16:55,110 --> 00:16:59,160
we want to have Python implementations

00:16:56,910 --> 00:17:02,129
for those functions so we want to tell

00:16:59,160 --> 00:17:03,839
CF fi hey these are functions that C

00:17:02,129 --> 00:17:06,240
code can call but that we want to

00:17:03,839 --> 00:17:08,970
implement in Python and in order for

00:17:06,240 --> 00:17:12,630
that we need to prefix those prototypes

00:17:08,970 --> 00:17:14,789
with extern Python plus C then C FF I

00:17:12,630 --> 00:17:18,110
knows okay I need to generate some blue

00:17:14,789 --> 00:17:20,610
code in order to make that work and

00:17:18,110 --> 00:17:21,899
again the simple solution that you might

00:17:20,610 --> 00:17:25,260
come up with in the beginning might be

00:17:21,899 --> 00:17:27,689
to just use search and replace and at

00:17:25,260 --> 00:17:30,000
the screen there but depending on how

00:17:27,689 --> 00:17:32,399
complex your code gets it's better again

00:17:30,000 --> 00:17:34,500
to use a real partner that understands

00:17:32,399 --> 00:17:38,010
the C code and can just make this

00:17:34,500 --> 00:17:39,419
modification this is based on the

00:17:38,010 --> 00:17:42,299
implementation that I showed last year

00:17:39,419 --> 00:17:44,580
it uses the PI C parser that's also used

00:17:42,299 --> 00:17:47,309
by c FF i internally

00:17:44,580 --> 00:17:49,230
and it passes all your C code into a

00:17:47,309 --> 00:17:51,899
Python data structure then you can

00:17:49,230 --> 00:17:56,010
modify that data structure and write it

00:17:51,899 --> 00:17:58,500
out again and in this case we do that in

00:17:56,010 --> 00:18:00,000
in two functions here we have one

00:17:58,500 --> 00:18:02,370
function that's called for every

00:18:00,000 --> 00:18:06,260
declaration that we find in the C source

00:18:02,370 --> 00:18:08,250
code so that's the first one and

00:18:06,260 --> 00:18:11,309
whenever we hit a function declaration

00:18:08,250 --> 00:18:14,460
and it's for a function that we haven't

00:18:11,309 --> 00:18:16,889
seen already then we will prefix it with

00:18:14,460 --> 00:18:18,630
X 2 and 5 and plus C and return the

00:18:16,889 --> 00:18:21,750
complete result otherwise we'll just

00:18:18,630 --> 00:18:23,340
ignore it and the second function takes

00:18:21,750 --> 00:18:24,360
care of all the function definitions

00:18:23,340 --> 00:18:27,000
that we might hit

00:18:24,360 --> 00:18:28,679
so there's might be inline functions

00:18:27,000 --> 00:18:30,960
that are specified in the header files

00:18:28,679 --> 00:18:32,669
of course we don't want to create a

00:18:30,960 --> 00:18:35,429
Python implementation for something

00:18:32,669 --> 00:18:39,809
that's already there so we just remove

00:18:35,429 --> 00:18:41,730
them from from the output as well so we

00:18:39,809 --> 00:18:43,799
can simply run that on the header

00:18:41,730 --> 00:18:46,320
content that we've collected so far get

00:18:43,799 --> 00:18:48,269
back a new string and if we look at that

00:18:46,320 --> 00:18:50,760
string then we find the same functions

00:18:48,269 --> 00:18:54,360
as before but now prefixed with extra

00:18:50,760 --> 00:18:57,269
and Python plus C so see if I should be

00:18:54,360 --> 00:18:58,889
happy with that but there's one more

00:18:57,269 --> 00:19:01,380
modification that we need to make and

00:18:58,889 --> 00:19:03,330
this is this we had this MP main

00:19:01,380 --> 00:19:06,330
function already renamed in the C source

00:19:03,330 --> 00:19:08,760
code since we want to call it later from

00:19:06,330 --> 00:19:11,190
the Python code we need to tell C if fi

00:19:08,760 --> 00:19:13,799
that this function exists and that it

00:19:11,190 --> 00:19:15,779
should provide some way from for python

00:19:13,799 --> 00:19:17,789
code to call this function so in this

00:19:15,779 --> 00:19:19,860
case it's the same function prototype as

00:19:17,789 --> 00:19:22,350
before but there's no X term Python plus

00:19:19,860 --> 00:19:24,299
C prefix so see if if I will assume that

00:19:22,350 --> 00:19:26,190
it's an existing C function that we want

00:19:24,299 --> 00:19:28,490
to call from Python and not something

00:19:26,190 --> 00:19:28,490
you

00:19:34,970 --> 00:19:39,780
and with that step to is complete we

00:19:38,310 --> 00:19:45,690
have collected all the header contents

00:19:39,780 --> 00:19:48,300
and now can move on to CF fi and the CF

00:19:45,690 --> 00:19:52,260
of AI source code is this it's only four

00:19:48,300 --> 00:19:56,310
lines so we first create the CF of I

00:19:52,260 --> 00:19:58,050
object to build our module we pass in

00:19:56,310 --> 00:20:00,390
the header content that we connected

00:19:58,050 --> 00:20:01,830
before and see if I will generate the

00:20:00,390 --> 00:20:05,280
Python interface out of this header

00:20:01,830 --> 00:20:07,440
content information and we pass in all

00:20:05,280 --> 00:20:10,410
the source code that we collected and

00:20:07,440 --> 00:20:13,290
see FF I will pass that on to a compiler

00:20:10,410 --> 00:20:16,800
to build our extension module that in

00:20:13,290 --> 00:20:19,200
this case will be called MP sim again we

00:20:16,800 --> 00:20:21,150
pass in the include directories that we

00:20:19,200 --> 00:20:22,830
had collected in the beginning and

00:20:21,150 --> 00:20:24,950
afterwards we tells you have fi to

00:20:22,830 --> 00:20:29,580
compile all this into a loadable module

00:20:24,950 --> 00:20:32,370
and then next steps are completed and we

00:20:29,580 --> 00:20:34,800
have a loadable module so now we can run

00:20:32,370 --> 00:20:39,600
it and to run it we simply import that

00:20:34,800 --> 00:20:41,550
module and then we need to define the

00:20:39,600 --> 00:20:44,310
functions that we wanted to replace with

00:20:41,550 --> 00:20:46,380
Python code and see if if I provides a

00:20:44,310 --> 00:20:48,510
decorator for that it will just match on

00:20:46,380 --> 00:20:50,940
the function name so if we define a

00:20:48,510 --> 00:20:52,830
function that has the same name as one

00:20:50,940 --> 00:20:55,800
of those x2 and Pisan plus three

00:20:52,830 --> 00:20:56,820
functions see if I will know to call

00:20:55,800 --> 00:20:59,250
this implementation

00:20:56,820 --> 00:21:03,210
whenever the C code calls the function

00:20:59,250 --> 00:21:05,880
of this name this is the implementation

00:21:03,210 --> 00:21:09,210
that reads a single character from

00:21:05,880 --> 00:21:11,760
standard input and this then is the

00:21:09,210 --> 00:21:15,810
implementation in order to write out the

00:21:11,760 --> 00:21:17,640
contents of a string and with that our

00:21:15,810 --> 00:21:20,730
implementation is complete we have

00:21:17,640 --> 00:21:24,410
everything we need so I'm going to try

00:21:20,730 --> 00:21:24,410
to show you now that this really works

00:21:24,890 --> 00:21:29,520
I've prepared a small script that

00:21:27,210 --> 00:21:31,920
contains basically this code I can run

00:21:29,520 --> 00:21:36,090
it and then I'm dropped into a micro

00:21:31,920 --> 00:21:39,480
Python shell and I can execute micro

00:21:36,090 --> 00:21:41,760
Python code in here I have the usual

00:21:39,480 --> 00:21:44,220
features of tab completion that micro

00:21:41,760 --> 00:21:47,049
Python provides I can call some of those

00:21:44,220 --> 00:21:50,489
functions can look at the objects

00:21:47,049 --> 00:21:52,840
everything seems to work as a church and

00:21:50,489 --> 00:21:54,519
in order to demonstrate you that this

00:21:52,840 --> 00:21:57,249
really uses the function that we've

00:21:54,519 --> 00:22:00,399
defined before before I can just modify

00:21:57,249 --> 00:22:04,869
that code and tell it to print

00:22:00,399 --> 00:22:07,179
everything twice and then you can see

00:22:04,869 --> 00:22:10,239
okay every output that we get is there

00:22:07,179 --> 00:22:13,659
twice everything that I type is printed

00:22:10,239 --> 00:22:15,070
twice and it really execute our Python

00:22:13,659 --> 00:22:21,759
implementation of those C level

00:22:15,070 --> 00:22:23,289
functions okay then I want to talk about

00:22:21,759 --> 00:22:26,499
some of the challenges that you might

00:22:23,289 --> 00:22:30,039
face and that we faced when we invented

00:22:26,499 --> 00:22:31,840
this approach for our source code first

00:22:30,039 --> 00:22:33,399
of all your code should follow a certain

00:22:31,840 --> 00:22:36,100
structure in order for this to work

00:22:33,399 --> 00:22:38,289
easily if you've just got a single file

00:22:36,100 --> 00:22:40,570
that contains everything it's hard to

00:22:38,289 --> 00:22:44,169
separate the the hyper dependent parts

00:22:40,570 --> 00:22:45,429
from the general source code so what you

00:22:44,169 --> 00:22:46,629
really want to have is a clear

00:22:45,429 --> 00:22:48,309
distinction between the hardware

00:22:46,629 --> 00:22:52,080
abstraction layer and the application

00:22:48,309 --> 00:22:55,809
code then you can just match on the

00:22:52,080 --> 00:22:57,820
folders for example collect the one the

00:22:55,809 --> 00:22:59,919
one part from one one folder and the

00:22:57,820 --> 00:23:02,019
other part from the other folder this is

00:22:59,919 --> 00:23:04,299
what we do in our example or have some

00:23:02,019 --> 00:23:08,529
some other mechanisms like to make files

00:23:04,299 --> 00:23:12,100
that I showed you before then there's

00:23:08,529 --> 00:23:14,019
the problem of namespaces mm-hm it's

00:23:12,100 --> 00:23:17,350
perfectly well at C code to have two

00:23:14,019 --> 00:23:19,869
files that contain functions static

00:23:17,350 --> 00:23:21,999
functions with the same name but since

00:23:19,869 --> 00:23:24,519
this example collects all the source

00:23:21,999 --> 00:23:28,090
code into one large string everything

00:23:24,519 --> 00:23:30,309
ends up in the same namespace and this

00:23:28,090 --> 00:23:32,080
won't really work so you'd eat something

00:23:30,309 --> 00:23:33,669
like that where you prefix every

00:23:32,080 --> 00:23:35,649
function for example with the name of

00:23:33,669 --> 00:23:41,529
the module so that you end up with a

00:23:35,649 --> 00:23:44,379
unique name and another problem is

00:23:41,529 --> 00:23:46,929
platform dependent code I've prepared a

00:23:44,379 --> 00:23:49,210
small example that looks innocent but

00:23:46,929 --> 00:23:52,869
contains multiple problems when you try

00:23:49,210 --> 00:23:54,669
to run it on different architectures so

00:23:52,869 --> 00:23:56,889
what we do here is we have defined a

00:23:54,669 --> 00:23:59,559
structure we fill in some values into

00:23:56,889 --> 00:24:00,140
this structure afterwards calculate a

00:23:59,559 --> 00:24:01,520
checksum

00:24:00,140 --> 00:24:04,100
that structure and of course the

00:24:01,520 --> 00:24:06,050
checksum should always be the same no

00:24:04,100 --> 00:24:08,150
matter on how on what platform this code

00:24:06,050 --> 00:24:12,170
runs if the data in the structure is the

00:24:08,150 --> 00:24:14,330
same the problems that you have here

00:24:12,170 --> 00:24:17,120
I'll show you the the corrected version

00:24:14,330 --> 00:24:19,880
already as first in the data types

00:24:17,120 --> 00:24:22,100
infrastructure if you just use shorts or

00:24:19,880 --> 00:24:25,400
in there's no specification that defines

00:24:22,100 --> 00:24:27,440
what what byte size you have here so you

00:24:25,400 --> 00:24:30,770
should use types that really specify

00:24:27,440 --> 00:24:33,140
that then you might get problems with

00:24:30,770 --> 00:24:36,290
padding that the compiler inserts into

00:24:33,140 --> 00:24:38,690
your structure so we tell it to avoid

00:24:36,290 --> 00:24:41,660
this padding with the attribute packet

00:24:38,690 --> 00:24:43,640
and last but not least you need to

00:24:41,660 --> 00:24:45,530
consider the engine s of your data so

00:24:43,640 --> 00:24:49,400
the the byte order of your data if

00:24:45,530 --> 00:24:51,290
you've got multiplied values so in the

00:24:49,400 --> 00:24:53,240
second example I use some standard

00:24:51,290 --> 00:24:55,510
functions just to compare the the

00:24:53,240 --> 00:24:57,800
engines of those values always to

00:24:55,510 --> 00:24:59,870
network byte order which is big byte or

00:24:57,800 --> 00:25:01,700
big-endian byte order and so the

00:24:59,870 --> 00:25:03,950
structure always should contain the same

00:25:01,700 --> 00:25:08,090
values here and the checksum should

00:25:03,950 --> 00:25:09,560
really be identical not the problem you

00:25:08,090 --> 00:25:11,120
might get with code that relies on

00:25:09,560 --> 00:25:13,670
interrupts because that's not really

00:25:11,120 --> 00:25:15,830
supported on this platform you might get

00:25:13,670 --> 00:25:18,530
something like this if you use threads

00:25:15,830 --> 00:25:21,260
to really achieve some some parallel

00:25:18,530 --> 00:25:25,970
events but we didn't have the use for

00:25:21,260 --> 00:25:27,830
that now so I haven't tried it and last

00:25:25,970 --> 00:25:30,980
but not least let me talk about the

00:25:27,830 --> 00:25:33,410
external interface for your code if we

00:25:30,980 --> 00:25:34,940
look again at this picture what's

00:25:33,410 --> 00:25:37,700
beneath your hardware abstraction layer

00:25:34,940 --> 00:25:39,620
in your usual application is the actual

00:25:37,700 --> 00:25:41,000
hardware and when we take away the

00:25:39,620 --> 00:25:42,950
abstraction layer we also take away the

00:25:41,000 --> 00:25:46,550
hardware so you need to replace that

00:25:42,950 --> 00:25:49,070
with something else one solution would

00:25:46,550 --> 00:25:51,350
be to use just Python code running

00:25:49,070 --> 00:25:53,870
against your application or what we use

00:25:51,350 --> 00:25:55,250
in our environment is just a network

00:25:53,870 --> 00:25:57,560
interface that can be used by our

00:25:55,250 --> 00:25:59,360
existing test cases so they deliver

00:25:57,560 --> 00:26:01,910
their input their get their output back

00:25:59,360 --> 00:26:03,290
and so the test case doesn't even need

00:26:01,910 --> 00:26:08,840
to know whether it talks to the real

00:26:03,290 --> 00:26:11,030
device or our simulation device ok now

00:26:08,840 --> 00:26:12,740
you've done of all of that you'll also

00:26:11,030 --> 00:26:14,960
get some benefits out of it

00:26:12,740 --> 00:26:18,710
and the first benefit and why we did all

00:26:14,960 --> 00:26:20,929
that was the fast execution so I've

00:26:18,710 --> 00:26:23,840
collected all the test cases that I can

00:26:20,929 --> 00:26:26,630
run against the stimulation and they

00:26:23,840 --> 00:26:28,909
were executed in roughly five minutes

00:26:26,630 --> 00:26:31,340
and if I run the same set of test cases

00:26:28,909 --> 00:26:33,890
against the real device takes one and a

00:26:31,340 --> 00:26:36,110
half hours so that was already a huge

00:26:33,890 --> 00:26:37,760
speed-up in fact these are the numbers

00:26:36,110 --> 00:26:39,830
from the first prototype that could

00:26:37,760 --> 00:26:41,360
execute everything we didn't invest any

00:26:39,830 --> 00:26:42,890
more effort and optimizing that any

00:26:41,360 --> 00:26:47,270
further because it was already fast

00:26:42,890 --> 00:26:49,100
enough for everything we wanted another

00:26:47,270 --> 00:26:51,590
benefit that you get out of this is

00:26:49,100 --> 00:26:54,409
dynamic program analysis you might know

00:26:51,590 --> 00:26:56,690
about static analysis tools the warning

00:26:54,409 --> 00:26:59,360
set the compiler gives you that special

00:26:56,690 --> 00:27:01,970
linters give you but there are also

00:26:59,360 --> 00:27:04,970
dynamic program analysis tools that look

00:27:01,970 --> 00:27:06,529
at your code or that don't look at your

00:27:04,970 --> 00:27:08,990
source code but they look at your binary

00:27:06,529 --> 00:27:12,409
code while it's being run and can give

00:27:08,990 --> 00:27:14,210
you more information one tool that we've

00:27:12,409 --> 00:27:17,179
integrated easily is the address

00:27:14,210 --> 00:27:19,159
sanitizer that's just some extra compile

00:27:17,179 --> 00:27:22,820
options that you include into your

00:27:19,159 --> 00:27:25,220
courts and then the compiler will add

00:27:22,820 --> 00:27:27,230
extra code that checks for invalid

00:27:25,220 --> 00:27:29,600
memory accesses out of bounds accesses

00:27:27,230 --> 00:27:34,580
and if it detects something like that it

00:27:29,600 --> 00:27:37,250
will just abort at this point and second

00:27:34,580 --> 00:27:39,169
tool that we use is a father it's called

00:27:37,250 --> 00:27:40,960
American fuzzy lob that tries to be a

00:27:39,169 --> 00:27:43,669
bit more intelligent and other father's

00:27:40,960 --> 00:27:46,700
by trying to find a new code path

00:27:43,669 --> 00:27:50,120
automatically and you can use that with

00:27:46,700 --> 00:27:54,950
Python code as well in our case we just

00:27:50,120 --> 00:27:58,010
use a wrapper provided by AFL to compile

00:27:54,950 --> 00:28:00,500
the extension modules called AFL GCC but

00:27:58,010 --> 00:28:04,970
cause internally to GCC but in a way

00:28:00,500 --> 00:28:06,500
that AFL support is integrated so this

00:28:04,970 --> 00:28:08,860
is all that you need in your code for

00:28:06,500 --> 00:28:11,149
the for the FL support to be present and

00:28:08,860 --> 00:28:14,210
then there's another nice tool called

00:28:11,149 --> 00:28:16,549
patent AFL that's actually intended to

00:28:14,210 --> 00:28:18,799
run Python code with this father not the

00:28:16,549 --> 00:28:21,289
extension code but Python code but it

00:28:18,799 --> 00:28:23,480
also supports this use case and then

00:28:21,289 --> 00:28:25,580
there's a small script

00:28:23,480 --> 00:28:28,610
that in this case reads puzzle input

00:28:25,580 --> 00:28:31,040
from standard input and runs it against

00:28:28,610 --> 00:28:33,140
the application in a loop we did this

00:28:31,040 --> 00:28:35,240
with our code for some I don't know

00:28:33,140 --> 00:28:37,580
seven billion executions that

00:28:35,240 --> 00:28:41,690
fortunately or unfortunately didn't find

00:28:37,580 --> 00:28:45,190
any problems but it works not with with

00:28:41,690 --> 00:28:47,660
the highest speed but you can use it and

00:28:45,190 --> 00:28:49,790
the last benefit that you gain from this

00:28:47,660 --> 00:28:51,950
approach is a certain kind of hardware

00:28:49,790 --> 00:28:53,510
independence you can do your development

00:28:51,950 --> 00:28:55,640
without having access to the real

00:28:53,510 --> 00:28:57,170
hardware so maybe in the beginning of

00:28:55,640 --> 00:28:59,000
your project when the real hardware

00:28:57,170 --> 00:29:01,700
isn't really available right no right

00:28:59,000 --> 00:29:03,230
now or even later on when the real

00:29:01,700 --> 00:29:05,660
hardware is just too expensive or you

00:29:03,230 --> 00:29:08,510
just have a few of them with this

00:29:05,660 --> 00:29:10,430
approach you can easily scale and do

00:29:08,510 --> 00:29:12,710
your tests in parallel on many devices

00:29:10,430 --> 00:29:14,690
because you just need a standard PC you

00:29:12,710 --> 00:29:18,620
don't need any complex setup for your

00:29:14,690 --> 00:29:21,670
for your hardware and with that my talk

00:29:18,620 --> 00:29:28,109
ants and thank you for your attention

00:29:21,670 --> 00:29:28,109
[Applause]

00:29:28,420 --> 00:29:33,920
st there we go so I think we've got time

00:29:31,970 --> 00:29:37,300
for maybe one very quick question

00:29:33,920 --> 00:29:37,300
if somebody would like to ask something

00:29:49,720 --> 00:29:55,390
in general thanks for the talk first

00:29:52,600 --> 00:29:58,120
time and in general you have to simulate

00:29:55,390 --> 00:30:00,370
your outside world with embedded systems

00:29:58,120 --> 00:30:03,130
so there are some inputs you're waiting

00:30:00,370 --> 00:30:05,380
on in your C code and maybe you check

00:30:03,130 --> 00:30:06,970
something or you have the control loop

00:30:05,380 --> 00:30:09,520
or something like this and you have to

00:30:06,970 --> 00:30:12,280
simulate this and so you did simulate

00:30:09,520 --> 00:30:13,060
this in Python the outside world or how

00:30:12,280 --> 00:30:15,310
did you manage this

00:30:13,060 --> 00:30:17,050
yeah though in our case the outside

00:30:15,310 --> 00:30:19,690
world is really just a communication

00:30:17,050 --> 00:30:21,250
channel we get some input there we have

00:30:19,690 --> 00:30:23,980
to process that and generate the correct

00:30:21,250 --> 00:30:26,140
output of course you could do something

00:30:23,980 --> 00:30:28,090
like the I said in the interrupt example

00:30:26,140 --> 00:30:31,150
that you used some threats that every

00:30:28,090 --> 00:30:33,220
five minutes were simulated value of

00:30:31,150 --> 00:30:34,930
some sensor or do whatever you want

00:30:33,220 --> 00:30:37,290
there but this wasn't necessary for all

00:30:34,930 --> 00:30:37,290
use case

00:30:45,799 --> 00:30:54,219
thank you very much

00:30:48,690 --> 00:30:54,219

YouTube URL: https://www.youtube.com/watch?v=-SvmjCWBX10


