Title: Alan Christie - Building a real-time embedded audio sampling application with MicroPython
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Building a real-time embedded audio sampling application with MicroPython
[EuroPython 2017 - Talk - 2017-07-10 - Arengo]
[Rimini, Italy]

While demonstrating the pyboard to a group of colleagues, a challenge was set to produce a practical demonstration of the device that would provide automatic and continuous voice recording and playback of short spoken phrases similar to that found in a number of talking toys.

This talk covers the process of designing and testing the embedded real-time Python solution and includes the architecture, test methodologies and recordings as the stages progressed to the final source code. The talk concludes with a live demonstration of the final application. The solution uses MicroPython (an embedded implementation of Python 3), the pyboard and its AMP Audio skin.

MicroPython is a lean implementation of Python 3 that is optimised to run in a very small footprint on micro-controllers and in constrained environments. It was created by the Australian programmer and physicist Damien George, after a successful Kickstarter backed campaign in 2013.

The pyboard is the original reference hardware created to host MicroPython. It is a compact low-power board based on an ARM processor with a heap of approximately 100kBytes that can run at 168MHz. It has sufficient hardware services and real-time capabilities to control all kinds of electronic projects.

The AMP Audio skin is a small additional module that attaches to the pyboard that adds a small power amplifier, speaker and a microphone with a pre-amp.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,210 --> 00:00:10,450
thank you very much I assume you can all

00:00:06,250 --> 00:00:12,790
hear me okay so this session is a

00:00:10,450 --> 00:00:15,400
beginner session we're going to walk

00:00:12,790 --> 00:00:18,279
through the design of a an audio

00:00:15,400 --> 00:00:21,040
application using micro Python and the

00:00:18,279 --> 00:00:23,770
PI board so we'll be constructing a

00:00:21,040 --> 00:00:25,599
continuous listen repeat audio

00:00:23,770 --> 00:00:27,070
application something like you might

00:00:25,599 --> 00:00:29,349
find in a toy you talk to it and it

00:00:27,070 --> 00:00:32,079
talks back to you this is for beginners

00:00:29,349 --> 00:00:34,120
so I'm not going to assume anything in

00:00:32,079 --> 00:00:36,489
terms of programming and stuff like that

00:00:34,120 --> 00:00:41,410
and we're using obviously micro Python

00:00:36,489 --> 00:00:44,109
but the PI board and it's audio skin so

00:00:41,410 --> 00:00:45,489
micro Python unfortunate there is

00:00:44,109 --> 00:00:47,440
another track at the moment which is

00:00:45,489 --> 00:00:50,230
introducing you to micro Python so most

00:00:47,440 --> 00:00:52,359
of the experts are probably there but

00:00:50,230 --> 00:00:54,879
it's a lean implementation of Python 3

00:00:52,359 --> 00:00:57,719
optimized for microcontrollers but with

00:00:54,879 --> 00:01:01,749
numerous modules for Hardware control

00:00:57,719 --> 00:01:05,199
the board itself is really quite small

00:01:01,749 --> 00:01:08,110
I've got a copy here but luckily I've

00:01:05,199 --> 00:01:10,420
brought a bigger version so it's

00:01:08,110 --> 00:01:13,090
basically just a microcontroller with a

00:01:10,420 --> 00:01:16,180
few additional bits and pieces like LEDs

00:01:13,090 --> 00:01:18,190
and switches it's very small in terms of

00:01:16,180 --> 00:01:20,410
capabilities and in terms of RAM and

00:01:18,190 --> 00:01:22,780
processing power but it does come with

00:01:20,410 --> 00:01:25,240
really cool bits of hardware and in

00:01:22,780 --> 00:01:27,310
Python all you have to do is import pyb

00:01:25,240 --> 00:01:29,380
and you've got access to pretty much all

00:01:27,310 --> 00:01:31,210
the hardware quite simply Christine

00:01:29,380 --> 00:01:34,330
Spindler is running a poster session in

00:01:31,210 --> 00:01:36,550
the sponsors hall so she can tell you a

00:01:34,330 --> 00:01:41,170
lot more about the hardware and its

00:01:36,550 --> 00:01:43,270
capabilities we also need an audio skin

00:01:41,170 --> 00:01:45,370
the ability to record and playback the

00:01:43,270 --> 00:01:48,910
board itself doesn't come with a

00:01:45,370 --> 00:01:51,940
microphone or a loudspeaker but you can

00:01:48,910 --> 00:01:55,030
basically attach an audio skin I've got

00:01:51,940 --> 00:01:58,300
one here on an aluminium casing that

00:01:55,030 --> 00:02:00,790
gives you basically a microphone a

00:01:58,300 --> 00:02:04,180
loudspeaker and the ability to add your

00:02:00,790 --> 00:02:07,750
own microphone if you want to but be

00:02:04,180 --> 00:02:09,369
prepared the audio skin comes in bits so

00:02:07,750 --> 00:02:11,739
in order to use it you're going to need

00:02:09,369 --> 00:02:14,560
good soldiering skills and a very good

00:02:11,739 --> 00:02:15,909
soldiering iron what we're going to be

00:02:14,560 --> 00:02:17,080
doing is recording and playing back

00:02:15,909 --> 00:02:18,760
speech

00:02:17,080 --> 00:02:22,350
I suppose we need to understand a little

00:02:18,760 --> 00:02:24,760
bit about what speech is I have a

00:02:22,350 --> 00:02:28,630
spectrogram a frequency domain recording

00:02:24,760 --> 00:02:30,490
of the utterance six here and basically

00:02:28,630 --> 00:02:32,260
you've got an axis which is showing you

00:02:30,490 --> 00:02:36,220
frequency so there are your high

00:02:32,260 --> 00:02:39,340
frequency parts of your six and this

00:02:36,220 --> 00:02:41,290
axis is effectively time in terms of

00:02:39,340 --> 00:02:43,690
frames which are about 10 milliseconds

00:02:41,290 --> 00:02:45,310
long so that's 350 milliseconds worth of

00:02:43,690 --> 00:02:48,610
speech if you want to record

00:02:45,310 --> 00:02:51,550
high-quality speech you need to sample a

00:02:48,610 --> 00:02:55,750
very high frequency because human speech

00:02:51,550 --> 00:02:58,000
goes up to 14 kilohertz but over the

00:02:55,750 --> 00:03:00,430
phone you basically are restricted to

00:02:58,000 --> 00:03:02,970
something like 3 to 4 kilohertz because

00:03:00,430 --> 00:03:04,959
they discovered that's all you need to

00:03:02,970 --> 00:03:08,709
intelligently understand what's being

00:03:04,959 --> 00:03:11,770
spoken so how do we go from analog to

00:03:08,709 --> 00:03:13,750
digital well we're going to use an ADC

00:03:11,770 --> 00:03:16,000
of course which is on the board and we

00:03:13,750 --> 00:03:18,300
have to consider a few items and that is

00:03:16,000 --> 00:03:21,790
effectively the sampling frequency

00:03:18,300 --> 00:03:22,870
something frequency and there are basic

00:03:21,790 --> 00:03:25,600
standards here

00:03:22,870 --> 00:03:28,120
Nyquist Shannon tells us that in order

00:03:25,600 --> 00:03:30,970
to capture an analog signal accurately

00:03:28,120 --> 00:03:34,120
we have to sample at twice the speed of

00:03:30,970 --> 00:03:36,580
the maximum frequency here we've we

00:03:34,120 --> 00:03:39,700
don't what we've got here is sampling

00:03:36,580 --> 00:03:42,459
it's at 1.5 times the speed and you can

00:03:39,700 --> 00:03:44,560
see the sample points basically give you

00:03:42,459 --> 00:03:46,600
a ran indication it's actually a lower

00:03:44,560 --> 00:03:49,120
frequency and that's called aliasing so

00:03:46,600 --> 00:03:52,390
you have to sample quite quickly the

00:03:49,120 --> 00:03:54,459
second consideration of course is the

00:03:52,390 --> 00:03:57,100
resolution how many bits you're going to

00:03:54,459 --> 00:04:00,430
store each individual sample and the pie

00:03:57,100 --> 00:04:04,030
board gives you devices which can record

00:04:00,430 --> 00:04:06,489
at 8 bits or 12 bits a bear in mind that

00:04:04,030 --> 00:04:11,080
a compact disc the original formats were

00:04:06,489 --> 00:04:12,790
16 bits at 44 point one kilohertz 44

00:04:11,080 --> 00:04:14,380
point one kilohertz is an odd number but

00:04:12,790 --> 00:04:17,229
they're very good reason for it so you

00:04:14,380 --> 00:04:19,570
need to understand that the frequencies

00:04:17,229 --> 00:04:21,910
you're going to be capturing the capture

00:04:19,570 --> 00:04:25,720
resolution and how much time you need to

00:04:21,910 --> 00:04:29,020
record speech so how do we record on a

00:04:25,720 --> 00:04:30,460
PI board well we basically create an ADC

00:04:29,020 --> 00:04:32,530
object

00:04:30,460 --> 00:04:36,840
and then we can use one of two reed

00:04:32,530 --> 00:04:40,300
methods we can call retimed or just read

00:04:36,840 --> 00:04:42,820
so we just import after we've imported

00:04:40,300 --> 00:04:46,060
my pie board we create our ADC object

00:04:42,820 --> 00:04:49,000
it's on a particular pin on your board

00:04:46,060 --> 00:04:52,720
so you're just connected to pin X 22 and

00:04:49,000 --> 00:04:54,850
once you've done that you can hand

00:04:52,720 --> 00:04:57,610
you're reading your the process of

00:04:54,850 --> 00:05:01,600
capturing samples over to micro Python

00:04:57,610 --> 00:05:04,990
and it will effectively read a block of

00:05:01,600 --> 00:05:06,880
data for you at a frequency you dictate

00:05:04,990 --> 00:05:10,420
so you can set up a buffer and say

00:05:06,880 --> 00:05:12,760
capture at six thousand samples per

00:05:10,420 --> 00:05:15,370
second that's okay but you've got no

00:05:12,760 --> 00:05:16,930
control over the real-time aspect of

00:05:15,370 --> 00:05:18,880
this it captures and you have to wait

00:05:16,930 --> 00:05:22,030
till it's finished so building a device

00:05:18,880 --> 00:05:24,010
that you want to be continuous and be

00:05:22,030 --> 00:05:26,650
interactive that's not the best thing to

00:05:24,010 --> 00:05:30,550
use so you in my particular case I'm

00:05:26,650 --> 00:05:33,760
forced to read the ADC samples manually

00:05:30,550 --> 00:05:38,860
and it's my responsibility then to

00:05:33,760 --> 00:05:41,440
record them at a designated rate so we

00:05:38,860 --> 00:05:43,830
can capture how do we replay well that's

00:05:41,440 --> 00:05:45,910
using a digital to analog converter and

00:05:43,830 --> 00:05:48,490
again there's one of those on the board

00:05:45,910 --> 00:05:50,980
is quite simple to setup there are two

00:05:48,490 --> 00:05:52,990
parts to the DAC you need to set the

00:05:50,980 --> 00:05:55,390
volume and there's a potentiometer on

00:05:52,990 --> 00:05:57,460
the I squared C bus and then once you've

00:05:55,390 --> 00:05:59,650
set the volume you just provide the DAC

00:05:57,460 --> 00:06:02,110
with your data buffer and it will play

00:05:59,650 --> 00:06:07,450
it back out for you so setting the

00:06:02,110 --> 00:06:10,570
volume is quite simple as connecting to

00:06:07,450 --> 00:06:12,970
address 46 on the I squared C bus and

00:06:10,570 --> 00:06:15,520
once you've done that you can create a

00:06:12,970 --> 00:06:18,040
DAC object you define the bit resolution

00:06:15,520 --> 00:06:20,410
that you want to play back at you have a

00:06:18,040 --> 00:06:22,330
choice of eight or twelve here and then

00:06:20,410 --> 00:06:26,290
you can use its write timed method

00:06:22,330 --> 00:06:31,360
provide a buffer provide a timer a built

00:06:26,290 --> 00:06:32,800
in object in in micro Python and tell it

00:06:31,360 --> 00:06:35,230
how to play the audio in this particular

00:06:32,800 --> 00:06:36,790
case normal means just play the buffer

00:06:35,230 --> 00:06:38,920
till it's finished and then stopped I

00:06:36,790 --> 00:06:40,780
think they have a circular option so you

00:06:38,920 --> 00:06:42,220
can fill a buffer with a repeating

00:06:40,780 --> 00:06:44,910
pattern and just get it to play

00:06:42,220 --> 00:06:44,910
continuously

00:06:45,399 --> 00:06:50,699
so I have mechanisms to record and

00:06:47,949 --> 00:06:53,080
playback how do I know that it's working

00:06:50,699 --> 00:06:55,419
sufficiently quickly it has to be

00:06:53,080 --> 00:06:58,539
real-time because I have to capture the

00:06:55,419 --> 00:07:00,339
audio at a designated rate so I'm going

00:06:58,539 --> 00:07:02,529
to rely on hardware components to do

00:07:00,339 --> 00:07:04,240
this but when I I'm also going to have

00:07:02,529 --> 00:07:06,669
software to do the actual signal

00:07:04,240 --> 00:07:08,050
processing I say signal processing there

00:07:06,669 --> 00:07:12,309
there's not a lot you can do on the PI

00:07:08,050 --> 00:07:13,839
board at this stage but there are two

00:07:12,309 --> 00:07:16,990
ways to do it you can either use an

00:07:13,839 --> 00:07:20,529
oscilloscope attach it to a pin on the

00:07:16,990 --> 00:07:23,740
board and you can you clips you can use

00:07:20,529 --> 00:07:26,589
a PI board pin give it a symbolic name

00:07:23,740 --> 00:07:29,699
and you can just set that pin high or

00:07:26,589 --> 00:07:33,819
low and your oscilloscope you can see

00:07:29,699 --> 00:07:37,229
you can measure the duration of the code

00:07:33,819 --> 00:07:39,759
that that you're surrounded the pin

00:07:37,229 --> 00:07:42,339
control with alternatively you can use

00:07:39,759 --> 00:07:46,839
timer objects so you can create a timer

00:07:42,339 --> 00:07:52,089
to calculate one one microsecond rate

00:07:46,839 --> 00:07:53,409
and just read it so the advantage of the

00:07:52,089 --> 00:07:55,569
oscilloscope is it gives me the

00:07:53,409 --> 00:07:58,300
opportunity to put a little picture up

00:07:55,569 --> 00:07:59,829
so here's a screen grab of a the

00:07:58,300 --> 00:08:02,829
oscilloscope on the board that I've been

00:07:59,829 --> 00:08:04,930
using and this low period here this

00:08:02,829 --> 00:08:07,209
trough is effectively the duration of

00:08:04,930 --> 00:08:09,909
the capture function this is the method

00:08:07,209 --> 00:08:11,649
that is running at 8 kilohertz in this

00:08:09,909 --> 00:08:15,039
particular case it was recording done at

00:08:11,649 --> 00:08:18,189
6 kilohertz so this is all the time it

00:08:15,039 --> 00:08:20,349
takes to read from the ADC and put that

00:08:18,189 --> 00:08:21,490
sample into memory and do some crude

00:08:20,349 --> 00:08:23,019
calculations with it

00:08:21,490 --> 00:08:27,309
as you can see it actually takes quite a

00:08:23,019 --> 00:08:28,569
bit of time 104 microseconds but you can

00:08:27,309 --> 00:08:30,999
do clever things with it with the pin

00:08:28,569 --> 00:08:33,459
control and discover that using a timer

00:08:30,999 --> 00:08:35,469
cost you 20 microseconds and actually

00:08:33,459 --> 00:08:39,939
doing the read itself is a relatively

00:08:35,469 --> 00:08:42,039
expensive 50 microseconds so that gives

00:08:39,939 --> 00:08:43,779
you a clear indication of how fast you

00:08:42,039 --> 00:08:45,040
could actually sample this at yeah

00:08:43,779 --> 00:08:46,509
you're not going to get to 20 kilohertz

00:08:45,040 --> 00:08:48,699
because it's going to take you 50

00:08:46,509 --> 00:08:52,089
microseconds just to get the value into

00:08:48,699 --> 00:08:55,209
your board so initial setup is basically

00:08:52,089 --> 00:08:57,710
I need a buffer to write my data into I

00:08:55,209 --> 00:09:03,110
need a function to collect the data

00:08:57,710 --> 00:09:05,330
and I need a play play mechanism so a

00:09:03,110 --> 00:09:07,010
crude diagram here here's my capture

00:09:05,330 --> 00:09:09,800
function is responsibility is just to

00:09:07,010 --> 00:09:13,430
read from the ADC it's connected to a

00:09:09,800 --> 00:09:15,650
timer and I simply create a timer and

00:09:13,430 --> 00:09:17,420
attach a callback function so here I

00:09:15,650 --> 00:09:19,520
could have a sample frequency of 8

00:09:17,420 --> 00:09:23,030
kilohertz so this function will get

00:09:19,520 --> 00:09:25,280
called at 8,000 times a second it simply

00:09:23,030 --> 00:09:26,780
does a read put it in a buffer when

00:09:25,280 --> 00:09:31,310
that's finished my play function goes

00:09:26,780 --> 00:09:33,550
and provides that data to the DAC so I

00:09:31,310 --> 00:09:36,440
have some recordings that I've made

00:09:33,550 --> 00:09:39,110
earlier I wish I'd said something a

00:09:36,440 --> 00:09:43,040
little more impressive than 1 2 3 in

00:09:39,110 --> 00:09:46,310
Italian but hopefully this will work

00:09:43,040 --> 00:09:54,740
I'll just play back an initial recording

00:09:46,310 --> 00:09:56,960
at 8 kilohertz so that's you know do a 3

00:09:54,740 --> 00:10:03,740
but you'll you'll notice it's very very

00:09:56,960 --> 00:10:05,840
noisy and that's that's at 12 bits 8

00:10:03,740 --> 00:10:08,270
kilohertz and when you analyze the noise

00:10:05,840 --> 00:10:11,690
you get really quite what disturbed and

00:10:08,270 --> 00:10:12,290
disappointed that of your to 4,000

00:10:11,690 --> 00:10:15,380
samples

00:10:12,290 --> 00:10:18,170
300 or so are just noise it's a very

00:10:15,380 --> 00:10:21,860
noisy signal on this board for a number

00:10:18,170 --> 00:10:25,490
of reasons but I'm losing quite a bit of

00:10:21,860 --> 00:10:28,280
information just in the noise and it's

00:10:25,490 --> 00:10:31,100
unpleasant unpleasant to to listen to so

00:10:28,280 --> 00:10:33,440
there are quick ways in order to renew

00:10:31,100 --> 00:10:34,760
reduce the noise and the simple one I

00:10:33,440 --> 00:10:36,710
put together is something that just

00:10:34,760 --> 00:10:38,390
searches for periods of silence in the

00:10:36,710 --> 00:10:42,260
recorded speech and who sets them to

00:10:38,390 --> 00:10:44,780
zero so to do that I basically record

00:10:42,260 --> 00:10:47,450
into my speech buffer as I call it and

00:10:44,780 --> 00:10:50,930
on a second pass I go through this

00:10:47,450 --> 00:10:53,510
speech buffer knowing roughly where 0 is

00:10:50,930 --> 00:10:55,910
again this has to adapt this is not a

00:10:53,510 --> 00:10:58,310
constant depending on your hardware 0

00:10:55,910 --> 00:10:59,810
might not be in the middle and I go

00:10:58,310 --> 00:11:02,990
through the buffer looking for periods

00:10:59,810 --> 00:11:04,850
with 0 and mark their positions and then

00:11:02,990 --> 00:11:05,480
that gives me the opportunity to do two

00:11:04,850 --> 00:11:07,670
things

00:11:05,480 --> 00:11:09,860
I can then adjust my estimate for 0

00:11:07,670 --> 00:11:11,430
because it might have changed but I can

00:11:09,860 --> 00:11:14,670
also go now go through the buffer

00:11:11,430 --> 00:11:18,029
and set all of the noise to the noisy

00:11:14,670 --> 00:11:23,630
silence to the real silence and I'll

00:11:18,029 --> 00:11:30,899
play back if we hear the original and

00:11:23,630 --> 00:11:33,480
then we apply this simple algorithm yep

00:11:30,899 --> 00:11:35,339
so a lot cleaner there's still noise in

00:11:33,480 --> 00:11:37,680
the speech signal and you can't simply

00:11:35,339 --> 00:11:42,930
just take away those bits because the

00:11:37,680 --> 00:11:46,170
speech in the noise is still valuable so

00:11:42,930 --> 00:11:48,959
I had recordings at 8 kilos a 12 bit so

00:11:46,170 --> 00:11:51,690
I decided well there is so much noise so

00:11:48,959 --> 00:12:04,709
how about recording at 8 bits rather

00:11:51,690 --> 00:12:07,110
than 12 if I play that so a bit give me

00:12:04,709 --> 00:12:09,540
an added advantage and I can store more

00:12:07,110 --> 00:12:11,130
speech on the board I'm very limited in

00:12:09,540 --> 00:12:13,860
the Java heap I probably got about a

00:12:11,130 --> 00:12:15,510
hundred K bytes minus whatever the

00:12:13,860 --> 00:12:17,490
operating system and the Python modules

00:12:15,510 --> 00:12:20,160
take away from me so I can only record

00:12:17,490 --> 00:12:22,560
very short periods of speech but at 8 8

00:12:20,160 --> 00:12:24,959
bits I can get about 8 to 10 seconds and

00:12:22,560 --> 00:12:28,200
there you will probably heard this a lot

00:12:24,959 --> 00:12:31,529
of problems with 6 & 7 say and set a and

00:12:28,200 --> 00:12:33,959
that's probably because I'm recording at

00:12:31,529 --> 00:12:37,080
8 kilohertz so we are we're right on the

00:12:33,959 --> 00:12:39,959
edge of bandwidth here so a lot of the

00:12:37,080 --> 00:12:44,670
high frequency stuff just gets lost or

00:12:39,959 --> 00:12:46,860
disturbed I also think so in order to

00:12:44,670 --> 00:12:49,140
compensate for that I decided well how

00:12:46,860 --> 00:12:50,850
about increasing the capture rate from 8

00:12:49,140 --> 00:13:02,070
kilohertz to 10 kilohertz

00:12:50,850 --> 00:13:04,079
so I'll hear the 8 again and then I move

00:13:02,070 --> 00:13:06,050
up to 10 kilohertz hopefully the say in

00:13:04,079 --> 00:13:09,190
set a will be a little better

00:13:06,050 --> 00:13:09,190
[Applause]

00:13:10,520 --> 00:13:15,720
I've made some improvements why can't I

00:13:13,230 --> 00:13:17,399
sample at 44.1 kilohertz like I have

00:13:15,720 --> 00:13:19,740
with the compact discs well as we've

00:13:17,399 --> 00:13:23,059
seen it takes me too long to read from

00:13:19,740 --> 00:13:25,170
the ADC and also the power of the device

00:13:23,059 --> 00:13:27,749
sorry the memory of the device just

00:13:25,170 --> 00:13:30,269
won't let me capture much data at 44

00:13:27,749 --> 00:13:32,939
kilohertz even if I could sample at that

00:13:30,269 --> 00:13:36,149
rate I wanted some application

00:13:32,939 --> 00:13:37,829
refinements so it's okay just recording

00:13:36,149 --> 00:13:40,769
and playing back but the purpose of this

00:13:37,829 --> 00:13:42,029
was to impress my nephew look here's a

00:13:40,769 --> 00:13:43,829
little device you could put in your

00:13:42,029 --> 00:13:46,819
cuddly toy talk to it it talks back to

00:13:43,829 --> 00:13:53,369
you so it has to have some sort of

00:13:46,819 --> 00:13:55,170
automatic whoops wrong button automatic

00:13:53,369 --> 00:13:57,989
speech detection so you have to press a

00:13:55,170 --> 00:13:59,850
button for it to listen so I wanted to

00:13:57,989 --> 00:14:02,129
be continuously listening I wanted to be

00:13:59,850 --> 00:14:03,749
able to record to the SD card this

00:14:02,129 --> 00:14:06,809
device gives you the ability to plug in

00:14:03,749 --> 00:14:08,670
a fast SD card I wanted to play with the

00:14:06,809 --> 00:14:10,439
LEDs to give you some indication that

00:14:08,670 --> 00:14:13,529
it's listening it's recording it's

00:14:10,439 --> 00:14:15,809
playing back and I wanted to be able the

00:14:13,529 --> 00:14:17,489
very least to disable the device by

00:14:15,809 --> 00:14:20,549
pressing the user button so it stopped

00:14:17,489 --> 00:14:22,829
listening so how do we how do we

00:14:20,549 --> 00:14:25,079
interact with the user button well

00:14:22,829 --> 00:14:26,970
there's a there are two switches a reset

00:14:25,079 --> 00:14:29,549
button on the board which reboots it

00:14:26,970 --> 00:14:32,639
obviously and a user switch and these

00:14:29,549 --> 00:14:35,069
are brought out as little brass buttons

00:14:32,639 --> 00:14:37,799
on your element on your aluminium casing

00:14:35,069 --> 00:14:39,839
so in order to use a button all I have

00:14:37,799 --> 00:14:41,129
to do is provide a handler function the

00:14:39,839 --> 00:14:43,410
work I want to do when the buttons

00:14:41,129 --> 00:14:45,449
pressed I need a switch object which

00:14:43,410 --> 00:14:47,730
represents the switch and then I just

00:14:45,449 --> 00:14:50,129
attach the handler via a callback method

00:14:47,730 --> 00:14:51,959
so there's my work in this particular

00:14:50,129 --> 00:14:54,809
case I'm just setting a control variable

00:14:51,959 --> 00:14:58,139
which just prevents the recording from

00:14:54,809 --> 00:15:02,600
taking place I create a switch object

00:14:58,139 --> 00:15:06,139
from the pi board module and then I

00:15:02,600 --> 00:15:08,339
invoke the callback method providing my

00:15:06,139 --> 00:15:09,839
function so every time I press that

00:15:08,339 --> 00:15:12,959
button that function runs so it's quite

00:15:09,839 --> 00:15:14,579
straightforward driving the LEDs that's

00:15:12,959 --> 00:15:17,459
pretty cool we like things that light up

00:15:14,579 --> 00:15:19,949
and flash so it's got four LEDs and four

00:15:17,459 --> 00:15:21,899
colors so you can create much like a

00:15:19,949 --> 00:15:24,629
switch you can create an LED object and

00:15:21,899 --> 00:15:26,129
you can switch them on off toggle them

00:15:24,629 --> 00:15:29,309
and so on

00:15:26,129 --> 00:15:32,309
so again Pi board led to four a four the

00:15:29,309 --> 00:15:34,829
green LED and I can switch it on I can

00:15:32,309 --> 00:15:36,209
switch it off I can toggle it led four

00:15:34,829 --> 00:15:39,360
supports an intensity

00:15:36,209 --> 00:15:42,089
method which allows you to provide 256

00:15:39,360 --> 00:15:44,149
levels of brightness they all support

00:15:42,089 --> 00:15:48,179
the intensity call but only the blue LED

00:15:44,149 --> 00:15:51,929
allows you to do the cool throbbing type

00:15:48,179 --> 00:15:55,619
type of effect automatic speech

00:15:51,929 --> 00:15:57,149
detection okay so this requires a little

00:15:55,619 --> 00:15:58,170
bit of thought the pi board doesn't give

00:15:57,149 --> 00:16:02,189
you this this is all part of my

00:15:58,170 --> 00:16:05,429
application domain code so basically i

00:16:02,189 --> 00:16:09,089
want to capture some speech continuously

00:16:05,429 --> 00:16:11,189
and only start recording when i think

00:16:09,089 --> 00:16:14,069
something's being spoken so this

00:16:11,189 --> 00:16:16,079
requires obviously the ability to

00:16:14,069 --> 00:16:20,369
determine whether there's speech or not

00:16:16,079 --> 00:16:24,600
and that's relatively simple in this

00:16:20,369 --> 00:16:27,240
implementation so i have i have two

00:16:24,600 --> 00:16:28,920
buffers i have my original speech buffer

00:16:27,240 --> 00:16:31,199
that i'm recording to but i have a very

00:16:28,920 --> 00:16:34,350
small buffer that's treated like a a

00:16:31,199 --> 00:16:35,999
circular memory so as the capture

00:16:34,350 --> 00:16:38,339
function is running it's in two modes

00:16:35,999 --> 00:16:40,050
one it's listening for speech and two

00:16:38,339 --> 00:16:42,149
it's then recording so while it's

00:16:40,050 --> 00:16:43,740
listening it's writing to this circular

00:16:42,149 --> 00:16:45,869
buffer and doing some very crude

00:16:43,740 --> 00:16:48,509
analysis on the signal level to

00:16:45,869 --> 00:16:50,160
determine whether it's silence or noise

00:16:48,509 --> 00:16:52,170
and because i've done some analysis of

00:16:50,160 --> 00:16:53,999
the noise i can understand

00:16:52,170 --> 00:16:56,610
roughly at what level these samples

00:16:53,999 --> 00:16:58,559
start to look like speech so once it's

00:16:56,610 --> 00:17:01,709
discovered that their speech it then

00:16:58,559 --> 00:17:05,839
switches to a straight record into this

00:17:01,709 --> 00:17:05,839
main buffer and then and then stops

00:17:06,529 --> 00:17:11,819
writing to an SD card is useful for

00:17:09,809 --> 00:17:14,100
storing data in recordings the device

00:17:11,819 --> 00:17:17,130
does have some flash onboard but that's

00:17:14,100 --> 00:17:21,529
very very small and extremely slow so

00:17:17,130 --> 00:17:21,529
you have to insert insert an SD card and

00:17:21,620 --> 00:17:28,679
discovering an SD card is my approach is

00:17:25,559 --> 00:17:30,029
really quite crude some my micro Python

00:17:28,679 --> 00:17:34,140
guru might say oh no you don't want to

00:17:30,029 --> 00:17:36,390
do that so i basically just look for SD

00:17:34,140 --> 00:17:38,880
in the system path if there's an SD

00:17:36,390 --> 00:17:43,940
there's a nasty device and then I just

00:17:38,880 --> 00:17:48,380
do my basic Python open right close

00:17:43,940 --> 00:17:52,190
so finally putting it all together

00:17:48,380 --> 00:17:55,549
I have sketched this application diagram

00:17:52,190 --> 00:17:58,100
the green parts are basically the micro

00:17:55,549 --> 00:17:59,960
poster and hardware services the blue

00:17:58,100 --> 00:18:02,179
parts are the software modules I

00:17:59,960 --> 00:18:04,940
provided and the red is basically just

00:18:02,179 --> 00:18:07,870
data so when we when we initialize the

00:18:04,940 --> 00:18:10,340
board the capture playback main loop

00:18:07,870 --> 00:18:12,410
essentially set controls the capture

00:18:10,340 --> 00:18:14,330
function with some control variables so

00:18:12,410 --> 00:18:16,370
it will tell it right start listening if

00:18:14,330 --> 00:18:18,620
I've not pressed the please stop

00:18:16,370 --> 00:18:22,340
listening hold button the capture

00:18:18,620 --> 00:18:24,620
function then essentially listens for

00:18:22,340 --> 00:18:26,450
speech is capturing all the time once

00:18:24,620 --> 00:18:28,610
it's detected speech writes into this

00:18:26,450 --> 00:18:31,040
long buffer it conveniently lights the

00:18:28,610 --> 00:18:34,040
amber LED for me to tell me it's

00:18:31,040 --> 00:18:40,160
recording when once that is done it then

00:18:34,040 --> 00:18:42,350
dis unlikes that led the and sets of

00:18:40,160 --> 00:18:45,230
control variable so at least my outer

00:18:42,350 --> 00:18:49,360
capture loop now understands a recording

00:18:45,230 --> 00:18:52,850
has been made so it can set the blue

00:18:49,360 --> 00:18:54,440
playback but playback LED and does one

00:18:52,850 --> 00:18:56,450
of a number of up one of a number of

00:18:54,440 --> 00:18:58,760
things now remember that I have a little

00:18:56,450 --> 00:19:01,280
bit of speech the speech detection

00:18:58,760 --> 00:19:03,500
buffer so I need to attach that to my

00:19:01,280 --> 00:19:05,450
original buffer because in my crew DAC

00:19:03,500 --> 00:19:07,520
method I can only give it the address of

00:19:05,450 --> 00:19:09,140
a buffer and play it and also that is

00:19:07,520 --> 00:19:12,710
circular so we don't know where the

00:19:09,140 --> 00:19:15,200
start of it is so the copy function

00:19:12,710 --> 00:19:18,919
unrolls these untangles this buffer puts

00:19:15,200 --> 00:19:22,280
it in here into their eye then once the

00:19:18,919 --> 00:19:24,620
copy is done I then run my crude clever

00:19:22,280 --> 00:19:27,200
attenuation method which adjusts that

00:19:24,620 --> 00:19:31,040
buffer it adjusts the value of zero for

00:19:27,200 --> 00:19:33,140
the next capture etc etc and then calls

00:19:31,040 --> 00:19:35,000
the play function once that's done it

00:19:33,140 --> 00:19:36,890
optionally dumps to the SD card if it

00:19:35,000 --> 00:19:41,020
exists and then the whole thing starts

00:19:36,890 --> 00:19:45,470
all over again and that effectively is

00:19:41,020 --> 00:19:48,320
the entire application the code is is

00:19:45,470 --> 00:19:53,059
all Python and I've published it on to

00:19:48,320 --> 00:19:54,620
onto github so all I've got to say now

00:19:53,059 --> 00:19:55,520
is thank you very much for listening I

00:19:54,620 --> 00:19:57,740
hope that's been useful

00:19:55,520 --> 00:20:00,950
you've got my contact details there and

00:19:57,740 --> 00:20:01,820
the address of the source code and I

00:20:00,950 --> 00:20:03,170
assume that

00:20:01,820 --> 00:20:07,430
effect I'll probably publish these

00:20:03,170 --> 00:20:12,740
slides up to that address later on if I

00:20:07,430 --> 00:20:25,670
just play Thank You Alan for that

00:20:12,740 --> 00:20:29,750
wonderful talk so he ought she automated

00:20:25,670 --> 00:20:31,070
away my job that's not good okay yeah

00:20:29,750 --> 00:20:34,780
thank you I hope there are some

00:20:31,070 --> 00:20:43,070
questions are there okay in the back oh

00:20:34,780 --> 00:20:46,070
yeah hi so you have a very small budget

00:20:43,070 --> 00:20:47,390
in terms of time to process does it mean

00:20:46,070 --> 00:20:49,100
there are certain things that you

00:20:47,390 --> 00:20:50,960
shouldn't do like probably import

00:20:49,100 --> 00:20:54,770
modules how about calling functions and

00:20:50,960 --> 00:20:57,260
in general is there any way to make sure

00:20:54,770 --> 00:21:00,620
that no matter what pass your code takes

00:20:57,260 --> 00:21:05,270
it would still be done within the budget

00:21:00,620 --> 00:21:10,640
to allocated yeah indeed

00:21:05,270 --> 00:21:12,890
so the overriding rule is inside your

00:21:10,640 --> 00:21:15,380
capture function you have to do as the

00:21:12,890 --> 00:21:17,120
absolute minimum that's required and my

00:21:15,380 --> 00:21:19,670
capture function essentially just calls

00:21:17,120 --> 00:21:21,470
the ADC checks the sample value and puts

00:21:19,670 --> 00:21:22,850
it in the buffer all the processing that

00:21:21,470 --> 00:21:24,860
you would ever want to that do that

00:21:22,850 --> 00:21:27,710
signal I can't do in the buffer because

00:21:24,860 --> 00:21:29,510
I've measured the time the you're in a

00:21:27,710 --> 00:21:31,070
callback function apart from other

00:21:29,510 --> 00:21:33,950
interrupts that are going on the board

00:21:31,070 --> 00:21:35,510
you you probably a fairly safe in

00:21:33,950 --> 00:21:38,780
assuming you've got control of the CPU

00:21:35,510 --> 00:21:40,490
here your Python on metal so apart from

00:21:38,780 --> 00:21:43,040
other interrupts that are occurring you

00:21:40,490 --> 00:21:46,730
probably don't have a lot to do you

00:21:43,040 --> 00:21:48,560
could yes I don't know what would happen

00:21:46,730 --> 00:21:51,560
if you over if your capture function

00:21:48,560 --> 00:21:53,780
lasted too long you could probably

00:21:51,560 --> 00:21:56,450
detect that by setting some sort of like

00:21:53,780 --> 00:21:58,460
lock variable the one thing you can't do

00:21:56,450 --> 00:22:00,380
in a callback is you can't create any

00:21:58,460 --> 00:22:02,180
Python objects and you can't do

00:22:00,380 --> 00:22:03,830
floating-point processing in Python

00:22:02,180 --> 00:22:06,530
because that in itself create Python

00:22:03,830 --> 00:22:09,230
objects so you really are at the bottom

00:22:06,530 --> 00:22:11,330
level of code just moving bits and bytes

00:22:09,230 --> 00:22:14,420
around memory but that's why I had to

00:22:11,330 --> 00:22:15,260
put in the pin function and the timers

00:22:14,420 --> 00:22:17,180
too

00:22:15,260 --> 00:22:19,370
sure there is some jitter you can see

00:22:17,180 --> 00:22:21,650
that when the board is running but as

00:22:19,370 --> 00:22:24,830
long as you're within quite a percentage

00:22:21,650 --> 00:22:29,600
point of you're allowed period you're

00:22:24,830 --> 00:22:31,940
probably quite safe thank you that was

00:22:29,600 --> 00:22:34,310
fascinating and you mentioned your

00:22:31,940 --> 00:22:37,760
nephew I think of it at the beginning

00:22:34,310 --> 00:22:39,500
and have you used this with children or

00:22:37,760 --> 00:22:43,370
young people in the net educational

00:22:39,500 --> 00:22:45,830
context and they said it well not yet

00:22:43,370 --> 00:22:48,560
the the problem that the pi board has is

00:22:45,830 --> 00:22:51,080
that when i pull the cable there's no

00:22:48,560 --> 00:22:52,730
built-in battery backup so it has to be

00:22:51,080 --> 00:22:55,310
powered by something so I'm waiting for

00:22:52,730 --> 00:22:57,740
them to produce a battery module so I

00:22:55,310 --> 00:22:59,390
could put this into you know the the

00:22:57,740 --> 00:23:00,850
stuffed toy to allow them to do that

00:22:59,390 --> 00:23:03,530
sort of thing and these things are

00:23:00,850 --> 00:23:04,820
incredibly popular now they're all over

00:23:03,530 --> 00:23:06,410
the place you know you're squeezy toy

00:23:04,820 --> 00:23:08,990
you press that press the hand and talk

00:23:06,410 --> 00:23:10,310
to it but no I haven't I haven't got

00:23:08,990 --> 00:23:15,080
back to him yet I've just released

00:23:10,310 --> 00:23:17,470
version one so thank you some questions

00:23:15,080 --> 00:23:17,470
over there

00:23:22,250 --> 00:23:28,410
have you done testing with clear signals

00:23:25,800 --> 00:23:30,060
so you can tell which part of the noise

00:23:28,410 --> 00:23:31,770
that we're hearing comes from the

00:23:30,060 --> 00:23:33,870
recording and which one comes from the

00:23:31,770 --> 00:23:39,930
playback because usually those those

00:23:33,870 --> 00:23:44,220
speakers are very locally so no I

00:23:39,930 --> 00:23:47,250
haven't but the the PI board the PI

00:23:44,220 --> 00:23:51,060
module does come with schematics and

00:23:47,250 --> 00:23:54,690
diagrams so one of the things you can do

00:23:51,060 --> 00:23:57,240
is obviously not use their built-in

00:23:54,690 --> 00:23:59,730
microphone and there's an ability to

00:23:57,240 --> 00:24:02,850
provide your own signal that the path to

00:23:59,730 --> 00:24:05,280
the analog components here is very short

00:24:02,850 --> 00:24:08,100
but that is the next step is to provide

00:24:05,280 --> 00:24:09,540
a reference signal on here to see where

00:24:08,100 --> 00:24:11,490
the noise is coming from it's not

00:24:09,540 --> 00:24:13,050
unusual to find noise in devices like

00:24:11,490 --> 00:24:16,260
this they're not exactly

00:24:13,050 --> 00:24:18,180
professional quality analog components

00:24:16,260 --> 00:24:20,550
they need proper grounding and earth

00:24:18,180 --> 00:24:22,560
planes to separate them from the digital

00:24:20,550 --> 00:24:25,110
noise but no that's the next step is to

00:24:22,560 --> 00:24:29,540
provide some sort of reference signal in

00:24:25,110 --> 00:24:31,950
at this point okay feel firsts here

00:24:29,540 --> 00:24:33,510
thanks bro so it seems like a really

00:24:31,950 --> 00:24:36,030
good way of mine getting too embedded

00:24:33,510 --> 00:24:37,110
but also learning Python because I'm

00:24:36,030 --> 00:24:38,310
quite new to pythons

00:24:37,110 --> 00:24:39,650
I'm going to play around with this I

00:24:38,310 --> 00:24:41,610
thought two quick questions hopefully

00:24:39,650 --> 00:24:44,700
firstly coming from in an embedded

00:24:41,610 --> 00:24:46,380
background can you do the ADC in the

00:24:44,700 --> 00:24:48,930
background so for example in your in

00:24:46,380 --> 00:24:50,610
your code you were waiting for the APC

00:24:48,930 --> 00:24:52,800
to get back to you and then you were

00:24:50,610 --> 00:24:54,210
buffering that data can you just pull

00:24:52,800 --> 00:24:55,890
that and then have an interrupt come

00:24:54,210 --> 00:24:57,030
back to you or for example use a double

00:24:55,890 --> 00:25:02,460
buffered approach like you would do with

00:24:57,030 --> 00:25:03,300
old audio I said sorry the question was

00:25:02,460 --> 00:25:04,980
do you know if there's anywhere in

00:25:03,300 --> 00:25:11,370
remedy you can buy these whilst we're

00:25:04,980 --> 00:25:14,400
here you've got one here now that's a

00:25:11,370 --> 00:25:16,680
good point that the ADC read method

00:25:14,400 --> 00:25:18,000
obviously it micro pythons open source

00:25:16,680 --> 00:25:20,970
so we could go in there and have a look

00:25:18,000 --> 00:25:22,860
what's going on but the read timed is is

00:25:20,970 --> 00:25:23,730
not very useful because you don't know

00:25:22,860 --> 00:25:27,150
where it is

00:25:23,730 --> 00:25:29,850
and you it's real time so at the end of

00:25:27,150 --> 00:25:32,460
the day you have to do whatever you want

00:25:29,850 --> 00:25:34,080
once every eight thousand times a second

00:25:32,460 --> 00:25:34,300
if you can't guarantee that then there's

00:25:34,080 --> 00:25:35,920
a

00:25:34,300 --> 00:25:39,220
and length of time that you can record

00:25:35,920 --> 00:25:41,200
so the only way the young what I've done

00:25:39,220 --> 00:25:43,060
is the absolute minimum which is read

00:25:41,200 --> 00:25:45,610
from the ADC and essentially put it into

00:25:43,060 --> 00:25:48,490
memory but I am I am checking the signal

00:25:45,610 --> 00:25:50,710
level I could I could connect two boards

00:25:48,490 --> 00:25:52,900
together maybe connect this to something

00:25:50,710 --> 00:25:54,880
more powerful like a Raspberry Pi and do

00:25:52,900 --> 00:25:56,650
a lot more signal processing because you

00:25:54,880 --> 00:25:59,770
can some really clever things when you

00:25:56,650 --> 00:26:02,350
turn your continuous time domain signal

00:25:59,770 --> 00:26:05,020
into a frequency domain because then you

00:26:02,350 --> 00:26:06,250
can walk into speech recognition and

00:26:05,020 --> 00:26:08,830
actually understand what people are

00:26:06,250 --> 00:26:11,530
saying so but no you really have your

00:26:08,830 --> 00:26:14,080
very limit in what you can do but yeah

00:26:11,530 --> 00:26:15,940
not as cheap as the pi zero and I don't

00:26:14,080 --> 00:26:17,920
know whether micro Python runs on the PI

00:26:15,940 --> 00:26:19,600
zero I would guess that it does but the

00:26:17,920 --> 00:26:22,480
beauty of this board is that it's got so

00:26:19,600 --> 00:26:27,490
much hardware ready and you just have a

00:26:22,480 --> 00:26:30,520
microphone and a loudspeaker okay yeah

00:26:27,490 --> 00:26:33,790
so actually my question related to what

00:26:30,520 --> 00:26:37,210
you said just now and whether what's the

00:26:33,790 --> 00:26:40,300
advantage of using micro Python on pi

00:26:37,210 --> 00:26:44,140
board versus using one of the you know

00:26:40,300 --> 00:26:46,150
bigger bone Raspberry Pi one of these

00:26:44,140 --> 00:26:48,250
boards are more powerful and able to use

00:26:46,150 --> 00:26:49,900
the full-blown Python you know and all

00:26:48,250 --> 00:26:53,050
the hardware that you can really work

00:26:49,900 --> 00:26:54,790
with so the the main the main reason I

00:26:53,050 --> 00:26:57,790
looked at this device is its physical

00:26:54,790 --> 00:26:59,980
size it comes with headers but you can

00:26:57,790 --> 00:27:02,440
buy the board without any headers so if

00:26:59,980 --> 00:27:05,140
you're going to attach this to a smaller

00:27:02,440 --> 00:27:07,180
component like a toy its size is

00:27:05,140 --> 00:27:09,780
important and and also it's the power

00:27:07,180 --> 00:27:13,120
consumption I think this is only drawing

00:27:09,780 --> 00:27:15,820
a fraction you know tens of millions

00:27:13,120 --> 00:27:18,100
whereas the Raspberry Pi just consumes

00:27:15,820 --> 00:27:21,460
too much towers too bulky so it's a

00:27:18,100 --> 00:27:24,310
trade-off between power in CPU and

00:27:21,460 --> 00:27:25,990
battery consumption and and and and

00:27:24,310 --> 00:27:29,080
things like that so I mean this is about

00:27:25,990 --> 00:27:30,580
half the size of a PI zero it's got but

00:27:29,080 --> 00:27:32,440
it's it's loaded with kind of quite a

00:27:30,580 --> 00:27:33,790
bit of hardware to play with so the

00:27:32,440 --> 00:27:36,760
reason why I thought it's not cheap I

00:27:33,790 --> 00:27:38,560
think it's 35 euros or something so it's

00:27:36,760 --> 00:27:40,510
not terribly cheap compared to the PI

00:27:38,560 --> 00:27:42,940
zero but it's got some really cool

00:27:40,510 --> 00:27:45,809
hardware features and it's it's Python

00:27:42,940 --> 00:27:49,889
on metal so let's cool

00:27:45,809 --> 00:27:52,559
and it makes noises okay so maybe I have

00:27:49,889 --> 00:27:55,259
a last question so when is Alexa running

00:27:52,559 --> 00:27:57,330
on this thing and they can well okay yes

00:27:55,259 --> 00:27:59,659
indeed well as I say the problem is

00:27:57,330 --> 00:28:03,119
getting from the continuous domain

00:27:59,659 --> 00:28:06,389
signal to the frequency domain so you

00:28:03,119 --> 00:28:07,889
need to get to something like that

00:28:06,389 --> 00:28:09,059
once you once you're able to get the

00:28:07,889 --> 00:28:10,889
data into that you can do your own

00:28:09,059 --> 00:28:13,679
speech recognition and that's I've done

00:28:10,889 --> 00:28:17,489
that in my past life but Alexa they have

00:28:13,679 --> 00:28:20,460
an API so you can give it data so yeah

00:28:17,489 --> 00:28:25,129
you just need to time okay so let's

00:28:20,460 --> 00:28:25,129

YouTube URL: https://www.youtube.com/watch?v=LXRLr8pIJf0


