Title: Armin Ronacher - A Python for Future Generations
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"A Python for Future Generations
[EuroPython 2017 - Keynote - 2017-07-10 - Anfiteatro 2]
[Rimini, Italy]

A journey through the current Python interpreter, some of the effects of its
leaky abstraction on the language design and how we could evolve the language to future proof it. Covers some practical and not so practical ideas based on experience in the JavaScript and Rust ecosystem.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,210 --> 00:00:10,690
hello everybody so my name is Armand I

00:00:08,590 --> 00:00:14,350
do lots and lots of Python for many

00:00:10,690 --> 00:00:16,800
years at this point most you might know

00:00:14,350 --> 00:00:18,970
me from the flask framework which is

00:00:16,800 --> 00:00:22,689
probably the most popular project I made

00:00:18,970 --> 00:00:27,699
and as of sometime ago I'm working on

00:00:22,689 --> 00:00:29,349
sentry with like commercial level which

00:00:27,699 --> 00:00:31,300
is also a project came out of the piping

00:00:29,349 --> 00:00:35,890
community and it's not open source

00:00:31,300 --> 00:00:37,420
projects at its core if you want to find

00:00:35,890 --> 00:00:40,390
internet this is where you can do this

00:00:37,420 --> 00:00:42,370
also this light slides of the talk will

00:00:40,390 --> 00:00:44,410
be at the URL on the bottom and

00:00:42,370 --> 00:00:48,820
hopefully also on the website of the

00:00:44,410 --> 00:00:50,290
conference so this talk is sort of the

00:00:48,820 --> 00:00:53,530
idea of raising a little bit of

00:00:50,290 --> 00:00:56,560
awareness of how Python actually works

00:00:53,530 --> 00:01:01,470
for us as a community and maybe how we

00:00:56,560 --> 00:01:04,750
can evolve it to some degree so part of

00:01:01,470 --> 00:01:07,299
what made me do with this talk and then

00:01:04,750 --> 00:01:09,820
to similar once I gave before I was that

00:01:07,299 --> 00:01:12,850
as you start programming more and more

00:01:09,820 --> 00:01:14,530
you get involved with more than sort of

00:01:12,850 --> 00:01:16,840
the language where it started out so

00:01:14,530 --> 00:01:19,500
python is sort of my home but I also use

00:01:16,840 --> 00:01:23,130
rust JavaScript Ruby many other things

00:01:19,500 --> 00:01:26,620
and when you start using something very

00:01:23,130 --> 00:01:28,840
often you are amazed by some of the

00:01:26,620 --> 00:01:31,270
things it does better than sort of what

00:01:28,840 --> 00:01:32,560
your home language is but then as you

00:01:31,270 --> 00:01:36,190
start using it more and more you also

00:01:32,560 --> 00:01:39,460
realize that they also have problems so

00:01:36,190 --> 00:01:40,780
I want to bring some of the experiences

00:01:39,460 --> 00:01:44,140
from other environments a little bit

00:01:40,780 --> 00:01:45,490
into the Python community sort of maybe

00:01:44,140 --> 00:01:48,970
so that we can do a better job at

00:01:45,490 --> 00:01:50,320
evolving the language so I think the

00:01:48,970 --> 00:01:53,979
biggest question is what is Python

00:01:50,320 --> 00:01:55,180
actually because this question is like

00:01:53,979 --> 00:01:57,130
obviously it's the language that

00:01:55,180 --> 00:01:58,659
everybody uses but if you look into it a

00:01:57,130 --> 00:02:01,830
little bit more it actually turns out

00:01:58,659 --> 00:02:03,970
that - is whatever C Python is doing I

00:02:01,830 --> 00:02:05,890
think it's a very important concept

00:02:03,970 --> 00:02:09,009
because C Python sort of the standard

00:02:05,890 --> 00:02:10,599
pipe interpreter there is a language

00:02:09,009 --> 00:02:11,980
reference which tells you how the

00:02:10,599 --> 00:02:14,680
language is supposed to work and it

00:02:11,980 --> 00:02:17,920
becomes part of the documentation of the

00:02:14,680 --> 00:02:21,670
Python language but actually

00:02:17,920 --> 00:02:24,489
a lot of how we all program - depends on

00:02:21,670 --> 00:02:26,980
very specifics of the CPI of interpreter

00:02:24,489 --> 00:02:29,590
and I will give some examples of this

00:02:26,980 --> 00:02:30,819
and why this is relevant but I think

00:02:29,590 --> 00:02:32,620
it's important to know that unlike

00:02:30,819 --> 00:02:36,700
JavaScript for instance we do not have a

00:02:32,620 --> 00:02:39,730
language standard so a lot of that the

00:02:36,700 --> 00:02:42,610
code that we use happens to work more or

00:02:39,730 --> 00:02:44,620
less because it works on C Python so

00:02:42,610 --> 00:02:46,450
many of us will have experienced that

00:02:44,620 --> 00:02:48,880
when we take our C Python code and run

00:02:46,450 --> 00:02:50,410
it on other runtimes like pi pi we

00:02:48,880 --> 00:02:54,310
encountered that not everything works

00:02:50,410 --> 00:02:56,049
exactly and then the sort of half taking

00:02:54,310 --> 00:02:57,940
for a long time have been to just make

00:02:56,049 --> 00:03:01,299
pi PI and other language is more like C

00:02:57,940 --> 00:03:02,950
Python but we never had a standard so

00:03:01,299 --> 00:03:04,480
there are two parts where this comes up

00:03:02,950 --> 00:03:06,489
one of them is a general language

00:03:04,480 --> 00:03:08,230
language behavior which is what happens

00:03:06,489 --> 00:03:09,940
when you add two numbers together and

00:03:08,230 --> 00:03:13,060
the second part is the standard library

00:03:09,940 --> 00:03:16,720
and this what exactly is the standard IO

00:03:13,060 --> 00:03:18,040
is also a little bit unclear but for

00:03:16,720 --> 00:03:19,840
more or less everything that we imported

00:03:18,040 --> 00:03:21,220
it doesn't come from pip is sort of the

00:03:19,840 --> 00:03:25,650
standard library and it also comes from

00:03:21,220 --> 00:03:28,180
C Python and usually also means that

00:03:25,650 --> 00:03:30,459
they'll send that library becomes part

00:03:28,180 --> 00:03:33,459
of quote unquote the language

00:03:30,459 --> 00:03:36,010
specification so this is my favorite

00:03:33,459 --> 00:03:40,870
example of C Python code what does this

00:03:36,010 --> 00:03:43,420
do it looks simple like you have two

00:03:40,870 --> 00:03:47,049
values a and B you multiply add them

00:03:43,420 --> 00:03:49,320
together but what happens to give you an

00:03:47,049 --> 00:03:52,510
example what happens in JavaScript is a

00:03:49,320 --> 00:03:54,940
and B are converted into value

00:03:52,510 --> 00:03:57,850
representations which are effectively

00:03:54,940 --> 00:04:00,430
numbers and then edit together and as a

00:03:57,850 --> 00:04:03,069
if you go to the standard of JavaScript

00:04:00,430 --> 00:04:04,989
or a comma script there there will be an

00:04:03,069 --> 00:04:08,470
explanation of of how this construct

00:04:04,989 --> 00:04:10,780
works but this is not JavaScript this is

00:04:08,470 --> 00:04:12,370
Python and what we all learned I think

00:04:10,780 --> 00:04:15,840
is that this is more or less equivalent

00:04:12,370 --> 00:04:20,229
to this like it's special under methods

00:04:15,840 --> 00:04:22,030
but this is really correct this is sort

00:04:20,229 --> 00:04:23,650
of what you might read in the tutorial

00:04:22,030 --> 00:04:25,419
but then some tutorials a little bit

00:04:23,650 --> 00:04:28,780
corrects and will tell you that it's

00:04:25,419 --> 00:04:31,110
actually like this so it gets the class

00:04:28,780 --> 00:04:33,389
of a and then you use this

00:04:31,110 --> 00:04:35,460
under under method in the past self

00:04:33,389 --> 00:04:38,879
explicitly as the first argument which

00:04:35,460 --> 00:04:40,979
is sort of why you can't do but you

00:04:38,879 --> 00:04:43,289
can't override the add operator on an

00:04:40,979 --> 00:04:45,270
instance so that's the explanation of

00:04:43,289 --> 00:04:47,400
them given but is this really correct it

00:04:45,270 --> 00:04:48,750
actually turns out that there's also

00:04:47,400 --> 00:04:50,580
this under under class is this

00:04:48,750 --> 00:04:53,520
equivalent to type or not and it turns

00:04:50,580 --> 00:04:54,569
out it's not at all equivalent and I

00:04:53,520 --> 00:04:57,719
think it's like they are not all

00:04:54,569 --> 00:05:00,719
necessarily correct or incorrect because

00:04:57,719 --> 00:05:02,250
they are all wrong in explaining the

00:05:00,719 --> 00:05:04,590
language because none of this actually

00:05:02,250 --> 00:05:06,750
happens if you have a plus B the

00:05:04,590 --> 00:05:08,940
interpreter will give you bytecode for

00:05:06,750 --> 00:05:11,340
this where it loads two values and it

00:05:08,940 --> 00:05:15,270
uses the internal binary at operation

00:05:11,340 --> 00:05:18,810
and then if you go all down the arms of

00:05:15,270 --> 00:05:21,780
them the rabbit-hole you will eventually

00:05:18,810 --> 00:05:24,990
realize that there is one interpretation

00:05:21,780 --> 00:05:27,930
in these interpreter of what binary it

00:05:24,990 --> 00:05:29,969
means and it tries one of those two

00:05:27,930 --> 00:05:32,039
things if it's an object that's a number

00:05:29,969 --> 00:05:33,979
then it will try to add them if it's a

00:05:32,039 --> 00:05:37,529
sequence it will try to concatenate them

00:05:33,979 --> 00:05:40,680
and this is this is something that

00:05:37,529 --> 00:05:42,690
nobody really ever looks at because it's

00:05:40,680 --> 00:05:44,669
for the most most of the time is

00:05:42,690 --> 00:05:46,589
irrelevant so it turns out that in

00:05:44,669 --> 00:05:47,819
python objects are actually they have

00:05:46,589 --> 00:05:50,550
nothing to do with these under-under

00:05:47,819 --> 00:05:53,190
methods internally for the vast majority

00:05:50,550 --> 00:05:55,379
of operations as we do there in the

00:05:53,190 --> 00:05:57,449
interpreter is a struct for all of the

00:05:55,379 --> 00:06:00,589
types and on the types there are methods

00:05:57,449 --> 00:06:03,539
and these methods are in slots and

00:06:00,589 --> 00:06:06,169
depending on how these slots are set up

00:06:03,539 --> 00:06:08,750
these operations to different things and

00:06:06,169 --> 00:06:11,190
the reason why it matters is because

00:06:08,750 --> 00:06:12,960
this was a design decision made a long

00:06:11,190 --> 00:06:15,659
time ago and everybody else has been

00:06:12,960 --> 00:06:18,870
forced to copy this like Popeye for

00:06:15,659 --> 00:06:20,610
instance so for instance this the fact

00:06:18,870 --> 00:06:23,520
that an ADD operation can do two

00:06:20,610 --> 00:06:27,210
different things on a type level has

00:06:23,520 --> 00:06:29,219
very profound consequences in particular

00:06:27,210 --> 00:06:33,180
what happens if you subclass something

00:06:29,219 --> 00:06:35,099
that already has a certain set up in the

00:06:33,180 --> 00:06:38,669
interpreter and you create a subclass of

00:06:35,099 --> 00:06:40,949
it in Python so in particular if you add

00:06:38,669 --> 00:06:43,100
an under under add method on an object

00:06:40,949 --> 00:06:45,290
it will register

00:06:43,100 --> 00:06:49,250
if you go back to this there are two

00:06:45,290 --> 00:06:51,860
slots internally on the object to do to

00:06:49,250 --> 00:06:53,480
do addition one of them is the if it's a

00:06:51,860 --> 00:06:55,340
number added together and the other one

00:06:53,480 --> 00:06:57,170
if is the sequence concatenated and if

00:06:55,340 --> 00:06:59,920
you add your own under under add method

00:06:57,170 --> 00:07:02,240
it always becomes a number addition

00:06:59,920 --> 00:07:04,280
that's kind of relevant for the most

00:07:02,240 --> 00:07:05,750
part because that you cannot still do

00:07:04,280 --> 00:07:09,320
concatenation obviously in this method

00:07:05,750 --> 00:07:12,410
but it's it's - the way into the number

00:07:09,320 --> 00:07:14,210
addition part but what if he subclass

00:07:12,410 --> 00:07:16,550
for instance a list where addition is

00:07:14,210 --> 00:07:18,440
defined the sequence computation and for

00:07:16,550 --> 00:07:19,910
quite some time there was a bug I don't

00:07:18,440 --> 00:07:22,460
know if it was just in pi PI or if it

00:07:19,910 --> 00:07:24,440
just in C prime also replicated in pi PI

00:07:22,460 --> 00:07:26,840
but it happened that if it's up Class A

00:07:24,440 --> 00:07:29,870
List and you edit your own under under

00:07:26,840 --> 00:07:32,390
ed method then sometimes concatenating

00:07:29,870 --> 00:07:33,890
lists would do your own method and

00:07:32,390 --> 00:07:36,530
sometimes it would do whatever was there

00:07:33,890 --> 00:07:38,300
originally and nowadays the interpreter

00:07:36,530 --> 00:07:39,920
if it finds an under are added will also

00:07:38,300 --> 00:07:42,530
put a proxy into the secret

00:07:39,920 --> 00:07:44,210
concatenation of ones a lot of things so

00:07:42,530 --> 00:07:47,330
there's a lot of complexity in the

00:07:44,210 --> 00:07:49,540
language as a result of this the

00:07:47,330 --> 00:07:51,860
simplest is there is no plus operator

00:07:49,540 --> 00:07:53,090
and the reason why there's no plus

00:07:51,860 --> 00:07:54,740
operator is because when the language

00:07:53,090 --> 00:07:57,260
was created originally there was no

00:07:54,740 --> 00:07:58,910
standardized model and so there are two

00:07:57,260 --> 00:08:00,440
internal markets one is called Pine

00:07:58,910 --> 00:08:02,900
number X and the other one is called PI

00:08:00,440 --> 00:08:05,360
secant concat and they correspond to

00:08:02,900 --> 00:08:07,640
those methods like pine number at will

00:08:05,360 --> 00:08:09,410
add numbers with the number protocol and

00:08:07,640 --> 00:08:11,750
two pi a sequence Concord Welcome Packet

00:08:09,410 --> 00:08:15,200
sequences so the sequence protocol but

00:08:11,750 --> 00:08:16,940
if you actually look at them so they are

00:08:15,200 --> 00:08:18,980
different but it will also do what the

00:08:16,940 --> 00:08:20,960
other one is doing so PI number ad will

00:08:18,980 --> 00:08:23,150
attempt to add numbers first and then

00:08:20,960 --> 00:08:24,740
concatenate sequences and pi sequence

00:08:23,150 --> 00:08:26,240
content will first attempt to complement

00:08:24,740 --> 00:08:28,940
sequences and then fall back to adding

00:08:26,240 --> 00:08:30,290
numbers so this is this doesn't make a

00:08:28,940 --> 00:08:32,930
lot of sense anymore but it still

00:08:30,290 --> 00:08:36,380
defines some of the the effects that we

00:08:32,930 --> 00:08:40,849
get in a language so why does this

00:08:36,380 --> 00:08:41,900
matter or it doesn't even matter and the

00:08:40,849 --> 00:08:45,580
different ways in which you can look at

00:08:41,900 --> 00:08:49,130
this but I think it kind of does matter

00:08:45,580 --> 00:08:50,690
because it limits us in what we can

00:08:49,130 --> 00:08:55,550
actually do with the language in the

00:08:50,690 --> 00:08:56,310
future so there is C Python but there's

00:08:55,550 --> 00:08:59,310
also PI pi

00:08:56,310 --> 00:09:01,020
- and right now I think both of those I

00:08:59,310 --> 00:09:03,390
don't know how active choices at this

00:09:01,020 --> 00:09:07,110
point but at least pie-pie attempts to

00:09:03,390 --> 00:09:09,360
replicate every single quirk in the in

00:09:07,110 --> 00:09:10,920
the language an attempt to be as

00:09:09,360 --> 00:09:17,100
compatible as possible to already

00:09:10,920 --> 00:09:18,630
existing code and I I think it's cool

00:09:17,100 --> 00:09:21,450
that the piper people are doing this but

00:09:18,630 --> 00:09:23,040
also at the same time it makes Piper a

00:09:21,450 --> 00:09:25,650
lot more like cpython for not

00:09:23,040 --> 00:09:29,160
necessarily the we're not necessarily

00:09:25,650 --> 00:09:30,600
gaining anything from this so so why are

00:09:29,160 --> 00:09:31,830
they replicating all the clerks instead

00:09:30,600 --> 00:09:33,510
of cleaning it up and making it nicer

00:09:31,830 --> 00:09:36,900
it's because everybody wants to have

00:09:33,510 --> 00:09:38,760
high compatibility and and I think this

00:09:36,900 --> 00:09:41,760
is the part where we as a community also

00:09:38,760 --> 00:09:43,830
sort of demand compatibility because if

00:09:41,760 --> 00:09:46,890
our code doesn't run on pi PI we're not

00:09:43,830 --> 00:09:48,330
willing to give pi PI transparency but

00:09:46,890 --> 00:09:49,890
then if you actually look into what this

00:09:48,330 --> 00:09:51,390
means for the future it means that it

00:09:49,890 --> 00:09:55,920
actually prevents more innovative

00:09:51,390 --> 00:09:57,450
language changes features and if you

00:09:55,920 --> 00:09:59,339
look very far in the future what will

00:09:57,450 --> 00:10:02,040
present Ivan look like in 30 years I

00:09:59,339 --> 00:10:03,510
mean will it just be the same or well

00:10:02,040 --> 00:10:08,420
the computers look so vastly different

00:10:03,510 --> 00:10:11,850
that we have to change the language so

00:10:08,420 --> 00:10:14,100
here is small proposals like maybe in

00:10:11,850 --> 00:10:15,600
view as a community can make the Python

00:10:14,100 --> 00:10:17,940
we use more like device may actually

00:10:15,600 --> 00:10:20,370
teach people maybe we can eventually

00:10:17,940 --> 00:10:21,870
achieve a Python barrier if you add two

00:10:20,370 --> 00:10:23,490
numbers together it does nothing else

00:10:21,870 --> 00:10:28,400
but calling is special under under ed

00:10:23,490 --> 00:10:31,250
method and this is trying to achieve

00:10:28,400 --> 00:10:34,050
consistency so a compatibility with

00:10:31,250 --> 00:10:36,570
weave stuff we had before is I think

00:10:34,050 --> 00:10:40,050
this is one of the strongest mantras in

00:10:36,570 --> 00:10:44,310
the Python community and it's a very

00:10:40,050 --> 00:10:47,490
common story so the same way as pi pi

00:10:44,310 --> 00:10:51,350
attempts to be as compatible with c

00:10:47,490 --> 00:10:53,730
python as possible we as a community are

00:10:51,350 --> 00:10:56,580
building our ecosystem in very similar

00:10:53,730 --> 00:10:58,800
ways be very strongly value

00:10:56,580 --> 00:11:04,860
compatibility ignoring this Python

00:10:58,800 --> 00:11:08,040
phrasing and this is very well shown

00:11:04,860 --> 00:11:09,300
with packaging so I don't know how many

00:11:08,040 --> 00:11:12,810
of you ever wrote a set up

00:11:09,300 --> 00:11:14,550
I fell but this whole idea of wreckage

00:11:12,810 --> 00:11:17,070
being built through a pipe my script

00:11:14,550 --> 00:11:20,490
comes from these details and these two

00:11:17,070 --> 00:11:23,790
tales was a edit eventually to Python

00:11:20,490 --> 00:11:25,380
and it set up this idea that you import

00:11:23,790 --> 00:11:27,630
a function from these two tails you call

00:11:25,380 --> 00:11:29,940
it it's called set up function and then

00:11:27,630 --> 00:11:31,230
if you run your set up the PI file it

00:11:29,940 --> 00:11:33,450
will execute this function I will do

00:11:31,230 --> 00:11:39,269
some magic and eventually end up with a

00:11:33,450 --> 00:11:40,890
table all this we still do just that now

00:11:39,269 --> 00:11:44,250
we do set up to us and if anyone has

00:11:40,890 --> 00:11:46,160
ever seen set up tools it's it's it's an

00:11:44,250 --> 00:11:48,720
elaborate monkey patch to these details

00:11:46,160 --> 00:11:52,440
and the original goal was to implement

00:11:48,720 --> 00:11:53,700
something called Python max and most

00:11:52,440 --> 00:11:55,649
communities in Python with some

00:11:53,700 --> 00:11:58,980
exceptions like I think so people might

00:11:55,649 --> 00:12:01,950
still do X Y 10 users have stopped using

00:11:58,980 --> 00:12:05,269
eggs but we didn't completely stop using

00:12:01,950 --> 00:12:07,589
X we still use the some part of the egg

00:12:05,269 --> 00:12:10,230
infrastructure with some of the things

00:12:07,589 --> 00:12:11,700
we're doing nowadays but the monkey

00:12:10,230 --> 00:12:15,180
patching doesn't stop with setup tools

00:12:11,700 --> 00:12:16,680
if you use if you used set of tools at

00:12:15,180 --> 00:12:18,060
the time one of the things that it added

00:12:16,680 --> 00:12:20,160
on top of these details was the idea

00:12:18,060 --> 00:12:22,050
that you could run Titan set up to fight

00:12:20,160 --> 00:12:23,610
develop in which case it would build

00:12:22,050 --> 00:12:24,779
binary extensions and put it into

00:12:23,610 --> 00:12:26,910
different halves than where they would

00:12:24,779 --> 00:12:29,190
be normally so that you can develop

00:12:26,910 --> 00:12:31,950
locally with a piping package without

00:12:29,190 --> 00:12:33,990
having to install it all the time this

00:12:31,950 --> 00:12:35,820
idea was later picked up a pip pip

00:12:33,990 --> 00:12:39,029
editor thing called pip installed esters

00:12:35,820 --> 00:12:41,880
editable and the way this is implemented

00:12:39,029 --> 00:12:44,820
scarily enough is it at runtime monkey

00:12:41,880 --> 00:12:49,589
patches set of tools temporarily to get

00:12:44,820 --> 00:12:51,779
its logic in place and then we'll also

00:12:49,589 --> 00:12:53,970
monkey patches setup tools to build

00:12:51,779 --> 00:12:56,399
wheels instead of eggs and actually I

00:12:53,970 --> 00:12:58,829
think even the guy who wrote the biggest

00:12:56,399 --> 00:13:00,480
wheel commands that is effectively

00:12:58,829 --> 00:13:04,020
unmaintained at this point is just doing

00:13:00,480 --> 00:13:06,350
like small little things and I saw at

00:13:04,020 --> 00:13:10,320
least one fork where someone actually

00:13:06,350 --> 00:13:12,300
monkey patches wheel to get their own

00:13:10,320 --> 00:13:13,920
stuff in place and we're doing it too

00:13:12,300 --> 00:13:16,140
because for instance we are distributing

00:13:13,920 --> 00:13:18,959
binary extension modules with a module

00:13:16,140 --> 00:13:20,430
called snake which lets us do rust

00:13:18,959 --> 00:13:23,090
modules for Python and it's a monkey

00:13:20,430 --> 00:13:24,740
patch for Buddhist Buddhist Wheel

00:13:23,090 --> 00:13:26,930
so this is this is like everybody is

00:13:24,740 --> 00:13:28,790
doing this am cff i very common module

00:13:26,930 --> 00:13:32,330
also implemented as a monkey patch to

00:13:28,790 --> 00:13:33,830
set up tools and and our in our keys

00:13:32,330 --> 00:13:35,990
snake is not just a monkey patch to

00:13:33,830 --> 00:13:39,080
setup tools it's a monkey patch to see

00:13:35,990 --> 00:13:41,360
fi which monkey patches wheels and if

00:13:39,080 --> 00:13:42,830
you ever look at like if it tried to do

00:13:41,360 --> 00:13:45,680
runtime introspection on the classes

00:13:42,830 --> 00:13:48,320
they are like if you add friends see if

00:13:45,680 --> 00:13:50,300
I if you had to see FF I modules you run

00:13:48,320 --> 00:13:53,390
the monkey patch twice so you have two

00:13:50,300 --> 00:13:56,060
subclasses internally to the default

00:13:53,390 --> 00:13:57,710
build extension command from set of

00:13:56,060 --> 00:13:59,660
tools which extends the one from these

00:13:57,710 --> 00:14:00,620
two tails but instead of it extending

00:13:59,660 --> 00:14:02,720
the one from this it is actually

00:14:00,620 --> 00:14:07,270
replacing it with its own it's really

00:14:02,720 --> 00:14:09,620
quite maddening that it's this way and

00:14:07,270 --> 00:14:11,120
we could have at one point realized that

00:14:09,620 --> 00:14:15,860
this is what we're doing and maybe like

00:14:11,120 --> 00:14:17,270
reconsider this is also I think similar

00:14:15,860 --> 00:14:19,310
to some degree the community is

00:14:17,270 --> 00:14:21,410
attempting to replace or get rid of the

00:14:19,310 --> 00:14:23,660
jail for a really long time but part of

00:14:21,410 --> 00:14:25,670
the reason we can't do it is it's just

00:14:23,660 --> 00:14:27,680
backwards compatibility it's not so much

00:14:25,670 --> 00:14:29,660
that it's hard I mean it's hard but it's

00:14:27,680 --> 00:14:30,920
only hard if the constraint is to be

00:14:29,660 --> 00:14:35,360
compatible with everything you've done

00:14:30,920 --> 00:14:36,890
so far so properly getting rid of the

00:14:35,360 --> 00:14:38,360
global interpreter lock would probably

00:14:36,890 --> 00:14:42,800
mean getting rid of ref counts and the

00:14:38,360 --> 00:14:44,210
very break everything so the thing is

00:14:42,800 --> 00:14:48,350
we're not really good at breaking from

00:14:44,210 --> 00:14:50,960
this this compatibility our our only

00:14:48,350 --> 00:14:54,620
attempt of doing this I think was Python

00:14:50,960 --> 00:14:56,720
3 and it went interesting it was very

00:14:54,620 --> 00:14:58,760
radical in some ways but it was totally

00:14:56,720 --> 00:15:00,410
not radical enough in others so it

00:14:58,760 --> 00:15:03,710
changed the language that everybody had

00:15:00,410 --> 00:15:05,090
to go through this pain of upgrading but

00:15:03,710 --> 00:15:07,370
then we ended up with more or less the

00:15:05,090 --> 00:15:11,870
same as we had before it's just slightly

00:15:07,370 --> 00:15:13,640
different unicode and especially unicode

00:15:11,870 --> 00:15:16,850
that all talk about this a little bit

00:15:13,640 --> 00:15:19,820
late again but i think it would be

00:15:16,850 --> 00:15:21,320
interesting to see if we can then do if

00:15:19,820 --> 00:15:24,350
we can learn from this a little bit and

00:15:21,320 --> 00:15:27,680
and maybe attempt another incompatible

00:15:24,350 --> 00:15:29,390
python version but different because one

00:15:27,680 --> 00:15:30,830
thing is that if you actually look at

00:15:29,390 --> 00:15:32,720
what the future of scripting languages

00:15:30,830 --> 00:15:33,949
are they

00:15:32,720 --> 00:15:35,779
like scripting language in the sense

00:15:33,949 --> 00:15:38,529
what Python JavaScript and some others

00:15:35,779 --> 00:15:40,759
are I think they're not going to go away

00:15:38,529 --> 00:15:43,160
but they will definitely look different

00:15:40,759 --> 00:15:46,339
we can already see this that async

00:15:43,160 --> 00:15:48,500
programming has become a thing that's a

00:15:46,339 --> 00:15:51,589
first-class citizen in in JavaScript in

00:15:48,500 --> 00:15:55,720
Python and many others but what people

00:15:51,589 --> 00:15:58,009
really care about is the ecosystem and

00:15:55,720 --> 00:16:02,930
in addition to the ecosystem actually

00:15:58,009 --> 00:16:05,839
care but some standards modern modern

00:16:02,930 --> 00:16:08,029
with in the past so it was perfectly

00:16:05,839 --> 00:16:09,680
okay for - not to be standardized but it

00:16:08,029 --> 00:16:11,329
would not have been ok for JavaScript

00:16:09,680 --> 00:16:12,769
not to be standardized so the fact that

00:16:11,329 --> 00:16:16,040
there is a very strong JavaScript

00:16:12,769 --> 00:16:18,680
standard now is what enabled a lot of

00:16:16,040 --> 00:16:22,759
the stuff in the community people really

00:16:18,680 --> 00:16:24,470
like JavaScript before note and before

00:16:22,759 --> 00:16:26,800
modern browsers came along wasn't very

00:16:24,470 --> 00:16:28,970
very different and that was sort of an

00:16:26,800 --> 00:16:31,490
unnecessary step the community had to do

00:16:28,970 --> 00:16:33,379
to actually come up with a way to

00:16:31,490 --> 00:16:35,750
standardize it which Titan was never

00:16:33,379 --> 00:16:37,100
forced to do so I think if you still

00:16:35,750 --> 00:16:39,379
want to be relevant in 30 years we

00:16:37,100 --> 00:16:40,730
probably have to evolve a little bit so

00:16:39,379 --> 00:16:42,110
here's some of the things we did really

00:16:40,730 --> 00:16:44,019
well and this is why I don't think

00:16:42,110 --> 00:16:46,790
Python is going anywhere

00:16:44,019 --> 00:16:48,620
the c python interpreter code is really

00:16:46,790 --> 00:16:50,000
readable and i think this is something

00:16:48,620 --> 00:16:51,379
that gets a lot of people interested in

00:16:50,000 --> 00:16:52,610
a language because you can actually

00:16:51,379 --> 00:16:55,490
figure out what's happening under the

00:16:52,610 --> 00:16:57,620
hood i know this is from a lot of people

00:16:55,490 --> 00:16:59,240
that I talked with is one of the reasons

00:16:57,620 --> 00:17:01,370
why they got interested because they

00:16:59,240 --> 00:17:02,779
could see you could very easily go to a

00:17:01,370 --> 00:17:04,100
lower level and figure out what the hell

00:17:02,779 --> 00:17:06,650
is actually happening

00:17:04,100 --> 00:17:08,600
I also means that you never really

00:17:06,650 --> 00:17:10,339
surprised if you've run Python code in

00:17:08,600 --> 00:17:13,120
production to not know what's happening

00:17:10,339 --> 00:17:15,559
if there's some really bizarre behavior

00:17:13,120 --> 00:17:19,699
it's it's straightforward to figure out

00:17:15,559 --> 00:17:21,020
what's what's going on also because we

00:17:19,699 --> 00:17:24,049
don't really have chit compilation it

00:17:21,020 --> 00:17:26,860
makes it even easier um it's super easy

00:17:24,049 --> 00:17:29,840
to compile a new Python interpreter so

00:17:26,860 --> 00:17:32,659
to actually modify the language itself

00:17:29,840 --> 00:17:34,789
is I think it's easier than any other

00:17:32,659 --> 00:17:36,230
language or if you ever use and this is

00:17:34,789 --> 00:17:37,730
this is what makes the community

00:17:36,230 --> 00:17:39,409
stronger because a lot of people are

00:17:37,730 --> 00:17:40,960
actually interested in in getting their

00:17:39,409 --> 00:17:43,090
own stuff into the language

00:17:40,960 --> 00:17:45,669
and this is it's vastly different than

00:17:43,090 --> 00:17:48,159
for instance getting changed into noches

00:17:45,669 --> 00:17:51,249
where there even internal politics in

00:17:48,159 --> 00:17:52,629
the language that make it hard where the

00:17:51,249 --> 00:17:54,159
interpreter is actually a part of a

00:17:52,629 --> 00:17:57,070
Google project and sometimes it's not

00:17:54,159 --> 00:17:59,019
sometimes it is the fact that everything

00:17:57,070 --> 00:18:01,690
a pipe is a compact package where you

00:17:59,019 --> 00:18:03,669
can modify it as you will gets a lot of

00:18:01,690 --> 00:18:05,049
people interested in and also makes them

00:18:03,669 --> 00:18:07,419
feel like this is a stable platform

00:18:05,049 --> 00:18:09,460
because even if commercial support would

00:18:07,419 --> 00:18:12,100
go away they can still take ownership of

00:18:09,460 --> 00:18:13,990
the whole thing the fact that we had

00:18:12,100 --> 00:18:15,610
this or still have to see extension

00:18:13,990 --> 00:18:17,350
modules meant that we could go into

00:18:15,610 --> 00:18:19,090
communities that our languages had a

00:18:17,350 --> 00:18:23,169
hard time going into especially

00:18:19,090 --> 00:18:24,519
scientific computing because the peyten

00:18:23,169 --> 00:18:27,309
developers themselves could never figure

00:18:24,519 --> 00:18:28,809
out all the things that the language

00:18:27,309 --> 00:18:30,519
would be used for but because other

00:18:28,809 --> 00:18:33,279
communities could come in and adapt it

00:18:30,519 --> 00:18:36,419
for the use that was really strong and

00:18:33,279 --> 00:18:39,490
powerful and this is also what made Depp

00:18:36,419 --> 00:18:41,919
very happy who is Python because you

00:18:39,490 --> 00:18:44,919
could embed it into our environments

00:18:41,919 --> 00:18:46,119
like web service and stuff and and

00:18:44,919 --> 00:18:48,820
because we are doing such a terrible

00:18:46,119 --> 00:18:50,799
chocolate package management and we come

00:18:48,820 --> 00:18:54,369
to multi version dependencies actually

00:18:50,799 --> 00:18:56,499
means that we have a lot stabler and

00:18:54,369 --> 00:18:58,960
flatter dependency hierarchies than a

00:18:56,499 --> 00:19:00,159
lot of other communities do and I don't

00:18:58,960 --> 00:19:03,490
know if you're familiar with JavaScript

00:19:00,159 --> 00:19:05,350
much but there was one of these one of

00:19:03,490 --> 00:19:07,690
these incidents was that someone

00:19:05,350 --> 00:19:11,529
unpublished a package called pet left

00:19:07,690 --> 00:19:14,619
which added some spaces I think on the

00:19:11,529 --> 00:19:16,119
right side of a string and you would

00:19:14,619 --> 00:19:17,470
think that such a simple operation if

00:19:16,119 --> 00:19:20,019
someone deletes it from the package

00:19:17,470 --> 00:19:21,879
index could never have an impact but

00:19:20,019 --> 00:19:24,809
because everybody was depending on on

00:19:21,879 --> 00:19:28,869
left petting a string by some spaces

00:19:24,809 --> 00:19:30,490
somehow deployments failed people

00:19:28,869 --> 00:19:31,990
couldn't get the new code up because the

00:19:30,490 --> 00:19:34,330
build service tried to install this

00:19:31,990 --> 00:19:36,429
various boring package from the Internet

00:19:34,330 --> 00:19:37,629
and as a result I was looking a little

00:19:36,429 --> 00:19:40,179
bit into what else the travel script

00:19:37,629 --> 00:19:42,429
community is doing and it's really

00:19:40,179 --> 00:19:45,309
absurd in some ways there's a is a

00:19:42,429 --> 00:19:47,860
package called its array which checks if

00:19:45,309 --> 00:19:51,399
an object is an array it's a one liner

00:19:47,860 --> 00:19:53,109
in it but because everybody because you

00:19:51,399 --> 00:19:53,900
have one dependency to do this or two

00:19:53,109 --> 00:19:55,910
dependencies that you

00:19:53,900 --> 00:19:57,500
it it's almost impossible for you to

00:19:55,910 --> 00:20:00,430
have a large JavaScript project and not

00:19:57,500 --> 00:20:03,380
also depend on this is array package and

00:20:00,430 --> 00:20:05,390
while the code in itself is a one-liner

00:20:03,380 --> 00:20:07,280
that is I don't know it is like a more

00:20:05,390 --> 00:20:09,590
how the kilobyte of license file that

00:20:07,280 --> 00:20:11,210
comes with it there is a tracing

00:20:09,590 --> 00:20:12,860
document which describes what it's doing

00:20:11,210 --> 00:20:15,050
there's documentation in it so you

00:20:12,860 --> 00:20:16,700
actually download like 10 kilobytes of

00:20:15,050 --> 00:20:17,870
data and if you actually look at the

00:20:16,700 --> 00:20:19,820
JavaScript community as a whole is

00:20:17,870 --> 00:20:21,970
downloading is is array it's downloaded

00:20:19,820 --> 00:20:25,460
in the excess of a terabyte a month and

00:20:21,970 --> 00:20:26,810
we're not doing that and I think that's

00:20:25,460 --> 00:20:29,600
good because it makes everything a lot

00:20:26,810 --> 00:20:31,940
more predictable when we push out the

00:20:29,600 --> 00:20:34,370
security update in a library it's very

00:20:31,940 --> 00:20:36,050
likely that the entire application will

00:20:34,370 --> 00:20:38,390
see the security update whereas with

00:20:36,050 --> 00:20:40,400
JavaScript you might have to push in the

00:20:38,390 --> 00:20:42,830
media dependencies as well it's a very

00:20:40,400 --> 00:20:46,900
common problem that we see using

00:20:42,830 --> 00:20:48,830
javascript is that there is so hard

00:20:46,900 --> 00:20:50,210
dependency pins that if you have a

00:20:48,830 --> 00:20:52,250
dependency which in itself is a

00:20:50,210 --> 00:20:53,840
dependency it might be that that

00:20:52,250 --> 00:20:58,670
dependency doesn't get a security update

00:20:53,840 --> 00:21:00,320
just because it was pinned to hard run

00:20:58,670 --> 00:21:02,300
time introspection I think is probably

00:21:00,320 --> 00:21:04,910
poisonous best feature the fact that I

00:21:02,300 --> 00:21:06,950
can look at what it's doing there

00:21:04,910 --> 00:21:09,380
there's so many nice extensions to pipe

00:21:06,950 --> 00:21:13,070
we can connect to a process see what

00:21:09,380 --> 00:21:15,250
it's doing look at the threads century

00:21:13,070 --> 00:21:17,540
the company that I work for the entire

00:21:15,250 --> 00:21:20,870
origin of that project was that you

00:21:17,540 --> 00:21:23,150
could crash in Python and look at all

00:21:20,870 --> 00:21:25,400
the local variables that you had in a

00:21:23,150 --> 00:21:26,780
stack trace and that's really powerful

00:21:25,400 --> 00:21:29,150
and I would never want to see this go

00:21:26,780 --> 00:21:31,310
away it's very painful to look at

00:21:29,150 --> 00:21:33,290
javascript in comparison where there's

00:21:31,310 --> 00:21:34,850
nothing you can do it's like you can

00:21:33,290 --> 00:21:35,990
parse work this is a real expression you

00:21:34,850 --> 00:21:39,440
can parse the stack trace this the

00:21:35,990 --> 00:21:40,490
extent of runtime introspection but here

00:21:39,440 --> 00:21:44,630
is some of the things we could probably

00:21:40,490 --> 00:21:47,090
do to make it to make our language more

00:21:44,630 --> 00:21:48,650
future-proof in the future and I feel

00:21:47,090 --> 00:21:50,480
like there's really only one thing that

00:21:48,650 --> 00:21:53,330
we should care about which is making it

00:21:50,480 --> 00:21:54,710
easier and simpler as the language core

00:21:53,330 --> 00:21:58,190
instead of just making it easier and

00:21:54,710 --> 00:21:59,960
easier libraries people in the patent

00:21:58,190 --> 00:22:02,270
community love simplicity they love

00:21:59,960 --> 00:22:04,700
using libraries that are they look

00:22:02,270 --> 00:22:07,050
simple to use but a lot of those

00:22:04,700 --> 00:22:11,130
libraries that look simple to use in

00:22:07,050 --> 00:22:13,910
do really crazy things the princess the

00:22:11,130 --> 00:22:18,150
very popular requests library in Python

00:22:13,910 --> 00:22:19,440
the is used to vendor and I think it

00:22:18,150 --> 00:22:21,210
still does to some degree vendor

00:22:19,440 --> 00:22:23,220
packages but the way in which it did it

00:22:21,210 --> 00:22:25,020
involve monkey-patching Cecile's and a

00:22:23,220 --> 00:22:28,230
bunch of other things and that sort of

00:22:25,020 --> 00:22:29,700
stuff breaks and the reason it's doing

00:22:28,230 --> 00:22:32,580
that and many other libraries also doing

00:22:29,700 --> 00:22:35,280
that is because it looks like that's one

00:22:32,580 --> 00:22:37,340
way to tame the beast but then don't

00:22:35,280 --> 00:22:39,480
really see it until it breaks and then

00:22:37,340 --> 00:22:41,460
we could have invested this time and

00:22:39,480 --> 00:22:42,810
actually figuring out like wire why is

00:22:41,460 --> 00:22:45,420
everybody doing this can we just make a

00:22:42,810 --> 00:22:47,370
simple solution for this problem so I

00:22:45,420 --> 00:22:49,140
want to bring some ideas from other

00:22:47,370 --> 00:22:51,180
communities into Python and maybe as a

00:22:49,140 --> 00:22:53,610
community as a whole we can figure out

00:22:51,180 --> 00:22:55,650
if we can adopt this so they're two

00:22:53,610 --> 00:22:58,950
languages I want to use as a reference

00:22:55,650 --> 00:23:01,470
here is JavaScript which is it's the

00:22:58,950 --> 00:23:03,000
world and rust out of personal interest

00:23:01,470 --> 00:23:05,100
and also because it's one of the last

00:23:03,000 --> 00:23:06,960
languages that appeared and as such they

00:23:05,100 --> 00:23:10,110
had highest chance of learning from

00:23:06,960 --> 00:23:11,520
everybody else's mistakes and they did

00:23:10,110 --> 00:23:13,140
learn from everybody else's mistakes

00:23:11,520 --> 00:23:17,760
javascript mostly learned from its own

00:23:13,140 --> 00:23:19,320
mistakes which is great but it it

00:23:17,760 --> 00:23:22,500
definitely also picks up from other

00:23:19,320 --> 00:23:26,610
languages so this is my favorite topic

00:23:22,500 --> 00:23:29,010
packaging and modules javascript has one

00:23:26,610 --> 00:23:30,510
so actually I used a lot of JavaScript

00:23:29,010 --> 00:23:32,580
packaging now and I would never use it

00:23:30,510 --> 00:23:33,810
as a reference point to learn from but

00:23:32,580 --> 00:23:36,600
there are some things that it has done

00:23:33,810 --> 00:23:38,760
really well one of them is all the

00:23:36,600 --> 00:23:40,800
description of a package is in a file

00:23:38,760 --> 00:23:43,560
called package of JSON which means that

00:23:40,800 --> 00:23:45,420
this is static file you can use a

00:23:43,560 --> 00:23:46,920
generator to generate it if you want but

00:23:45,420 --> 00:23:48,870
you can also load it at runtime and you

00:23:46,920 --> 00:23:51,930
can figure out what it's doing and the

00:23:48,870 --> 00:23:53,370
part that the rest community has a

00:23:51,930 --> 00:23:53,850
similar thing with a file called car

00:23:53,370 --> 00:23:56,730
botamo

00:23:53,850 --> 00:23:59,220
which is like an inny file but not

00:23:56,730 --> 00:24:01,620
really but it also defines everything

00:23:59,220 --> 00:24:03,180
that is relevant in terms of metadata

00:24:01,620 --> 00:24:07,200
and in terms of installation behavior of

00:24:03,180 --> 00:24:09,600
the library and we don't have that

00:24:07,200 --> 00:24:12,090
because we execute code to install a

00:24:09,600 --> 00:24:13,590
package and we do generate some metadata

00:24:12,090 --> 00:24:15,480
but it's generally not available it's

00:24:13,590 --> 00:24:17,370
very slow to load and the Parton

00:24:15,480 --> 00:24:18,000
community never really was interested in

00:24:17,370 --> 00:24:20,220
package

00:24:18,000 --> 00:24:22,710
but actually peckish metadata I think is

00:24:20,220 --> 00:24:24,620
the most important thing the fact that

00:24:22,710 --> 00:24:27,450
you can access your metadata at runtime

00:24:24,620 --> 00:24:29,220
gives Russ and JavaScript a lot of

00:24:27,450 --> 00:24:31,740
possibilities to make much nicer

00:24:29,220 --> 00:24:33,060
decisions than we can do and so for

00:24:31,740 --> 00:24:35,340
instance a package can figure it out

00:24:33,060 --> 00:24:38,100
figure out its own version that's a

00:24:35,340 --> 00:24:40,770
simple thing but it can also figure out

00:24:38,100 --> 00:24:45,300
its own dependencies which means that in

00:24:40,770 --> 00:24:48,960
rust and in JavaScript if you require a

00:24:45,300 --> 00:24:51,720
dependency from a package that import

00:24:48,960 --> 00:24:53,670
code or in case of Rusted the linking

00:24:51,720 --> 00:24:55,560
code can figure out what your own

00:24:53,670 --> 00:24:58,170
dependencies are to give you the more

00:24:55,560 --> 00:25:00,300
appropriate version of a library so this

00:24:58,170 --> 00:25:02,580
for instance makes it possible for a

00:25:00,300 --> 00:25:05,730
package in JavaScript to have its own

00:25:02,580 --> 00:25:08,400
left pet function whereas the other

00:25:05,730 --> 00:25:10,200
package has its own incompatible left

00:25:08,400 --> 00:25:12,060
word function but it can still work

00:25:10,200 --> 00:25:14,820
because they see their own local

00:25:12,060 --> 00:25:18,840
references and the fact that you have

00:25:14,820 --> 00:25:20,180
multiple versions per library has its

00:25:18,840 --> 00:25:22,590
ups and downs

00:25:20,180 --> 00:25:25,080
now we're leaning towards probably it

00:25:22,590 --> 00:25:27,960
has more downs than it has ups with some

00:25:25,080 --> 00:25:29,130
negative experiences made but it's not

00:25:27,960 --> 00:25:31,050
like those communities are not learning

00:25:29,130 --> 00:25:34,680
from this any particular in rust for

00:25:31,050 --> 00:25:36,750
instance and I think in JavaScript

00:25:34,680 --> 00:25:40,950
community as well there's now the talk

00:25:36,750 --> 00:25:43,140
about maybe we can find out a way to

00:25:40,950 --> 00:25:44,520
split the penalties into half we're like

00:25:43,140 --> 00:25:46,800
half the dependencies are like private

00:25:44,520 --> 00:25:49,440
dependencies which only are internal to

00:25:46,800 --> 00:25:51,420
library and some of them are public so

00:25:49,440 --> 00:25:53,100
that for instance if you have a

00:25:51,420 --> 00:25:54,990
framework like flask and you have an

00:25:53,100 --> 00:25:56,820
extension to flask that it's guaranteed

00:25:54,990 --> 00:26:00,720
that the extension of Lascaux we see the

00:25:56,820 --> 00:26:02,010
same class as your user kotas so these

00:26:00,720 --> 00:26:03,720
communities are learning and we can also

00:26:02,010 --> 00:26:06,960
start incorporating some of what they're

00:26:03,720 --> 00:26:08,910
doing while we are now is we are

00:26:06,960 --> 00:26:11,850
actually moving towards that I think

00:26:08,910 --> 00:26:13,470
very few people still run set up the PI

00:26:11,850 --> 00:26:15,330
install I think that the point where we

00:26:13,470 --> 00:26:17,130
could get rid of set out of Pi at least

00:26:15,330 --> 00:26:19,890
we have the infrastructure in place to

00:26:17,130 --> 00:26:22,890
build piping wheels without using these

00:26:19,890 --> 00:26:26,010
details or setup tools at all I will

00:26:22,890 --> 00:26:28,140
once it's being created is largely just

00:26:26,010 --> 00:26:29,770
a zip file and we can use different

00:26:28,140 --> 00:26:31,780
tools to generate them

00:26:29,770 --> 00:26:34,290
um because pip is already a separate

00:26:31,780 --> 00:26:37,090
tool app it could be extended to support

00:26:34,290 --> 00:26:39,540
piping packages which are have nothing

00:26:37,090 --> 00:26:42,610
to do with set of tools or these details

00:26:39,540 --> 00:26:44,170
but we are still away from multi version

00:26:42,610 --> 00:26:46,290
dependencies we would need metadata

00:26:44,170 --> 00:26:50,290
access which there is no good API for

00:26:46,290 --> 00:26:52,840
and also it's not just that we don't

00:26:50,290 --> 00:26:54,520
have a good way to access metadata we

00:26:52,840 --> 00:26:57,309
also have an import system which doesn't

00:26:54,520 --> 00:26:58,990
support multi versioning for various

00:26:57,309 --> 00:27:02,170
different reasons but I think it would

00:26:58,990 --> 00:27:04,170
be a very realistic way to move towards

00:27:02,170 --> 00:27:07,360
a completely new packaging ecosystem

00:27:04,170 --> 00:27:09,250
with less work than we currently

00:27:07,360 --> 00:27:12,220
collectively spent on trying to make

00:27:09,250 --> 00:27:14,080
what we have work because you just need

00:27:12,220 --> 00:27:16,480
to look at the in all the packages that

00:27:14,080 --> 00:27:18,429
we have all the issue trackers there is

00:27:16,480 --> 00:27:21,429
so much pain and suffering hidden there

00:27:18,429 --> 00:27:23,410
and that doesn't even show you the

00:27:21,429 --> 00:27:25,720
individual suffering someone does has

00:27:23,410 --> 00:27:28,330
when when they try to make setup tools

00:27:25,720 --> 00:27:29,620
working new and exciting ways I think I

00:27:28,330 --> 00:27:31,000
wasted about a month of my life

00:27:29,620 --> 00:27:33,730
doing nothing else but trying to make

00:27:31,000 --> 00:27:36,820
rusts to work with setup tools and I'm

00:27:33,730 --> 00:27:38,770
still unhappy so maybe maybe we could

00:27:36,820 --> 00:27:40,750
just channel this a little bit and build

00:27:38,770 --> 00:27:43,090
a different packaging infrastructure and

00:27:40,750 --> 00:27:47,530
I feel like the packaging community in

00:27:43,090 --> 00:27:48,730
Python is already going this way trick

00:27:47,530 --> 00:27:50,500
here would be to actually make a

00:27:48,730 --> 00:27:52,570
language standards because nobody

00:27:50,500 --> 00:27:56,020
actually wants to have the current

00:27:52,570 --> 00:27:58,420
language as a standard I think everybody

00:27:56,020 --> 00:28:00,640
who worked with Python long enough knows

00:27:58,420 --> 00:28:02,650
that it would try to simplify things so

00:28:00,640 --> 00:28:05,950
there's no point in standardizing what

00:28:02,650 --> 00:28:07,750
we have currently and JavaScript just

00:28:05,950 --> 00:28:09,309
standardized what they had because the

00:28:07,750 --> 00:28:12,250
language was a lot less stuff in there

00:28:09,309 --> 00:28:13,600
then in Python and when they figure out

00:28:12,250 --> 00:28:15,220
that some of the things that they had

00:28:13,600 --> 00:28:17,590
were impossible to make fast they

00:28:15,220 --> 00:28:21,309
actually changed they took away some

00:28:17,590 --> 00:28:23,140
features of the language and I don't

00:28:21,309 --> 00:28:26,890
think we as a community wanted to move

00:28:23,140 --> 00:28:28,630
the direction but maybe there is

00:28:26,890 --> 00:28:30,820
actually something that will get us this

00:28:28,630 --> 00:28:33,250
way for instance there's micro Python

00:28:30,820 --> 00:28:35,200
which clearly has had its own

00:28:33,250 --> 00:28:37,660
experiences with the complexity of the

00:28:35,200 --> 00:28:38,770
language and there is a page from that

00:28:37,660 --> 00:28:40,240
which says these are the differences

00:28:38,770 --> 00:28:42,670
between micro piles and

00:28:40,240 --> 00:28:44,830
- and maybe if we get some more like

00:28:42,670 --> 00:28:47,110
cpython slightly incompatible Python

00:28:44,830 --> 00:28:49,360
versions we will actually find a common

00:28:47,110 --> 00:28:51,400
subset that makes more sense than than

00:28:49,360 --> 00:28:55,179
what we currently assume the subsidies

00:28:51,400 --> 00:28:56,860
which is the entirety of cpython so now

00:28:55,179 --> 00:28:59,530
I feel like maybe pipe I would have been

00:28:56,860 --> 00:29:01,630
a little bit more successful by not

00:28:59,530 --> 00:29:03,700
trying to be cpython but trying to be

00:29:01,630 --> 00:29:04,840
more bold trying to do more exciting

00:29:03,700 --> 00:29:07,570
things that people actually have a good

00:29:04,840 --> 00:29:10,090
reason for for doing this and I think

00:29:07,570 --> 00:29:12,100
the biggest problem that other piping

00:29:10,090 --> 00:29:14,080
versions still have at this point is

00:29:12,100 --> 00:29:16,000
that we as a Python community there is

00:29:14,080 --> 00:29:17,590
this idea if you go to the documentation

00:29:16,000 --> 00:29:19,720
like how do I build an extension module

00:29:17,590 --> 00:29:21,130
it says use these two tools and setup

00:29:19,720 --> 00:29:23,290
tools to build a pipe in extension

00:29:21,130 --> 00:29:25,000
module and nobody ever told people that

00:29:23,290 --> 00:29:27,280
this is wrong and the documentation

00:29:25,000 --> 00:29:28,870
should really say that unless you really

00:29:27,280 --> 00:29:31,840
really know what you're doing don't do

00:29:28,870 --> 00:29:33,730
it please don't do it there is so it's

00:29:31,840 --> 00:29:36,760
like it makes no sense placed onto it

00:29:33,730 --> 00:29:38,440
because there is so many negative parts

00:29:36,760 --> 00:29:41,590
about building a patent extension module

00:29:38,440 --> 00:29:43,570
with the piping API you will suffer for

00:29:41,590 --> 00:29:45,100
this for a long time and there are so

00:29:43,570 --> 00:29:46,900
many better ways to do it like csfi

00:29:45,100 --> 00:29:48,580
where you actually built an independent

00:29:46,900 --> 00:29:50,320
library you try to consume it from

00:29:48,580 --> 00:29:52,660
Python and you get away from the idea of

00:29:50,320 --> 00:29:55,450
sending Python objects between your new

00:29:52,660 --> 00:29:57,429
worlds and the other one but there was

00:29:55,450 --> 00:29:58,809
no never anyone in the community said

00:29:57,429 --> 00:30:00,880
like it's a stupid idea to build titan

00:29:58,809 --> 00:30:03,040
extension modules and everybody still

00:30:00,880 --> 00:30:04,240
tries to do it um so maybe we should

00:30:03,040 --> 00:30:05,950
just put it into the documentation like

00:30:04,240 --> 00:30:07,660
there are alternatives to building zip I

00:30:05,950 --> 00:30:09,040
think essential modules because once we

00:30:07,660 --> 00:30:11,050
get away from this we can actually

00:30:09,040 --> 00:30:14,650
liberate ourselves and use more

00:30:11,050 --> 00:30:17,320
interesting Python interpreters um this

00:30:14,650 --> 00:30:19,450
is my favorite topic Unicode I think we

00:30:17,320 --> 00:30:20,830
did it completely wrong and the more I

00:30:19,450 --> 00:30:22,210
use other languages the more I'm

00:30:20,830 --> 00:30:25,630
convinced that we have Unicode

00:30:22,210 --> 00:30:28,840
completely wrong this is what rust is

00:30:25,630 --> 00:30:30,460
doing they use utf-8 everywhere and

00:30:28,840 --> 00:30:32,770
everything gets easier and where they

00:30:30,460 --> 00:30:36,540
can't use utf-8 because it's not

00:30:32,770 --> 00:30:39,670
possible to use a thing called WTF eight

00:30:36,540 --> 00:30:42,760
which is a wobbly transfer encoding

00:30:39,670 --> 00:30:45,580
format I guess and this allows them to

00:30:42,760 --> 00:30:50,860
be compatible with utf-16

00:30:45,580 --> 00:30:52,390
or UCS - I guess in in places where they

00:30:50,860 --> 00:30:52,850
have to interface with the world that is

00:30:52,390 --> 00:30:55,400
not come

00:30:52,850 --> 00:31:00,800
lately unicode aware on windows in

00:30:55,400 --> 00:31:02,870
particular and it turns out and the WTF

00:31:00,800 --> 00:31:05,480
eight also came up with JavaScript which

00:31:02,870 --> 00:31:08,480
for similar reasons as windows decided

00:31:05,480 --> 00:31:11,510
that two bytes per unicode character is

00:31:08,480 --> 00:31:13,490
everything they will ever need and so

00:31:11,510 --> 00:31:15,740
they found new and innovative ways to

00:31:13,490 --> 00:31:18,620
deal with this problem and they just

00:31:15,740 --> 00:31:21,260
embraced user fate everywhere and we

00:31:18,620 --> 00:31:24,020
should do too but it's very hard and the

00:31:21,260 --> 00:31:25,520
reason for us it's hard is because we

00:31:24,020 --> 00:31:27,920
use strings differently than other

00:31:25,520 --> 00:31:29,480
community sorry but the benefit of using

00:31:27,920 --> 00:31:31,550
beautif 8 everywhere is there's very

00:31:29,480 --> 00:31:33,560
little guessing about encodings did you

00:31:31,550 --> 00:31:37,550
know that if you open a file on patents

00:31:33,560 --> 00:31:40,160
free as in unicode to read mode or write

00:31:37,550 --> 00:31:43,370
mode it's not utf-8 by default it

00:31:40,160 --> 00:31:45,050
guesses its encoding it's utf-8 on most

00:31:43,370 --> 00:31:48,700
of the computers you have ever used but

00:31:45,050 --> 00:31:51,230
if I a sage into my server its ASCII

00:31:48,700 --> 00:31:53,120
because it guesses the encoding from the

00:31:51,230 --> 00:31:56,060
file system and it falls back to ASCII

00:31:53,120 --> 00:31:57,980
because unless it was changed recently

00:31:56,060 --> 00:32:02,090
but it used to fall back to ASCII if it

00:31:57,980 --> 00:32:04,070
couldn't figure it out and rust for

00:32:02,090 --> 00:32:06,320
instance decided that instead of trying

00:32:04,070 --> 00:32:08,750
to shoehorn more stuff into the unicode

00:32:06,320 --> 00:32:10,070
type they will build a separate string

00:32:08,750 --> 00:32:13,730
type to interface with the operating

00:32:10,070 --> 00:32:16,460
system so if you for instance use the

00:32:13,730 --> 00:32:18,500
Unicode api's on Python 3 to interface

00:32:16,460 --> 00:32:20,330
with the file system you will get

00:32:18,500 --> 00:32:21,650
Unicode strings back unless it can't

00:32:20,330 --> 00:32:23,210
decode the file name because it's

00:32:21,650 --> 00:32:24,830
invalid then you will also get the

00:32:23,210 --> 00:32:27,380
Unicode string back but it contains

00:32:24,830 --> 00:32:28,790
characters which are invalid unicode so

00:32:27,380 --> 00:32:30,380
if you pass on the string long enough

00:32:28,790 --> 00:32:33,530
eventually will break in the same way as

00:32:30,380 --> 00:32:35,780
it broke in python to just within much

00:32:33,530 --> 00:32:40,160
more confusing error message that it

00:32:35,780 --> 00:32:42,170
contains surrogate and I remember that I

00:32:40,160 --> 00:32:45,730
had this conversation at one point like

00:32:42,170 --> 00:32:48,290
five six years ago that the reason we

00:32:45,730 --> 00:32:53,150
don't want to use utf-8 is because

00:32:48,290 --> 00:32:54,140
everybody actually benefits from or not

00:32:53,150 --> 00:32:56,630
everybody but there lots of people

00:32:54,140 --> 00:32:58,220
actually benefit from only living in the

00:32:56,630 --> 00:33:01,330
basic plain which means only two bytes

00:32:58,220 --> 00:33:03,249
per character because for instance

00:33:01,330 --> 00:33:04,989
in Japanese languages that might be a

00:33:03,249 --> 00:33:09,129
more efficient representation in utf-8

00:33:04,989 --> 00:33:11,320
and and this also sparked sort of the

00:33:09,129 --> 00:33:14,679
the idea that in Python 3 a string will

00:33:11,320 --> 00:33:16,629
attempt to stay in one one byte for as

00:33:14,679 --> 00:33:18,730
long as it can then it will upgrade to

00:33:16,629 --> 00:33:20,440
two bytes until it no longer can and

00:33:18,730 --> 00:33:21,820
only when you have characters outside

00:33:20,440 --> 00:33:25,360
the basic plane they will go to four

00:33:21,820 --> 00:33:26,559
bytes per character and it turns out as

00:33:25,360 --> 00:33:29,830
of I think at least two or three years

00:33:26,559 --> 00:33:31,539
ago this optimization was doesn't make

00:33:29,830 --> 00:33:34,330
any more sense for a lot of applications

00:33:31,539 --> 00:33:37,600
because people use emojis and emojis are

00:33:34,330 --> 00:33:39,039
way past the basic plane so you're

00:33:37,600 --> 00:33:40,570
annoying this really absurd situation

00:33:39,039 --> 00:33:43,419
where if you render a template in Jinja

00:33:40,570 --> 00:33:45,159
2 it starts out with HTML code it fits

00:33:43,419 --> 00:33:47,049
into a skis with one byte per character

00:33:45,159 --> 00:33:48,639
you stream a little bit further you hit

00:33:47,049 --> 00:33:50,739
your first unicode character it Rhian

00:33:48,639 --> 00:33:52,210
codes everything into two bytes and then

00:33:50,739 --> 00:33:53,499
you hit the first emoji because I'm

00:33:52,210 --> 00:33:55,210
gonna left a funny comment and it does

00:33:53,499 --> 00:33:58,749
it all over again always four bytes per

00:33:55,210 --> 00:34:00,940
character so the the world has evolved

00:33:58,749 --> 00:34:02,950
to a point where Unicode is now used

00:34:00,940 --> 00:34:06,460
more than for the two bytes per

00:34:02,950 --> 00:34:09,399
character so could we move to this idea

00:34:06,460 --> 00:34:11,169
of having the debate everywhere we could

00:34:09,399 --> 00:34:13,119
very easily we just have to give up the

00:34:11,169 --> 00:34:15,210
idea that we can access a character in

00:34:13,119 --> 00:34:18,220
constant time and we can splice strings

00:34:15,210 --> 00:34:19,899
but we love slicing strings in Python so

00:34:18,220 --> 00:34:22,929
I think that's a little bit in a way of

00:34:19,899 --> 00:34:24,819
doing this but I'm not fully convinced

00:34:22,929 --> 00:34:27,490
that fundamentally the idea of

00:34:24,819 --> 00:34:28,690
representing being able to access a

00:34:27,490 --> 00:34:30,280
character and come some time doesn't

00:34:28,690 --> 00:34:33,869
make any sense and is not useful and

00:34:30,280 --> 00:34:37,030
also that we don't need string slicing

00:34:33,869 --> 00:34:38,980
but we would have to start moving us

00:34:37,030 --> 00:34:40,750
away from doing this so that we could

00:34:38,980 --> 00:34:43,540
then start embracing utf-8 is an

00:34:40,750 --> 00:34:46,960
internal encoding and we are very far of

00:34:43,540 --> 00:34:48,609
that I already talked about exception

00:34:46,960 --> 00:34:52,960
modules I would love to get rid of them

00:34:48,609 --> 00:34:55,659
as much as possible use more CFI and as

00:34:52,960 --> 00:34:58,119
a result use left less lip Python if

00:34:55,659 --> 00:35:01,299
you've tried to build a C extension in

00:34:58,119 --> 00:35:03,609
Python and you want to distribute it to

00:35:01,299 --> 00:35:05,049
other people using Linux there's a thing

00:35:03,609 --> 00:35:07,660
called many Linux one

00:35:05,049 --> 00:35:09,490
it's a docker image it contains a very

00:35:07,660 --> 00:35:12,400
very very old version of centers I think

00:35:09,490 --> 00:35:13,630
it's centos fight some probably eight to

00:35:12,400 --> 00:35:15,309
nine years old

00:35:13,630 --> 00:35:16,690
reason why you build it I mean very old

00:35:15,309 --> 00:35:20,259
linux's because then it's upwards

00:35:16,690 --> 00:35:22,210
compatible to the what on Linux is and

00:35:20,259 --> 00:35:25,240
it's very painful because you can't do

00:35:22,210 --> 00:35:29,829
modern SSL on this docker container but

00:35:25,240 --> 00:35:31,630
we can build C extension in Python on a

00:35:29,829 --> 00:35:33,190
very old Linux and it runs on GNU Linux

00:35:31,630 --> 00:35:35,289
is so inferior all we would have to do

00:35:33,190 --> 00:35:37,569
is make one extension for OS ten one

00:35:35,289 --> 00:35:39,789
extension for Windows two extensions for

00:35:37,569 --> 00:35:42,220
Linux one for 32-bit one for 64-bit and

00:35:39,789 --> 00:35:44,049
and we would be done um but because

00:35:42,220 --> 00:35:46,000
everybody links against lip - you

00:35:44,049 --> 00:35:49,750
actually have to build one for Python

00:35:46,000 --> 00:35:52,059
2.7 to bite character Unicode Python 2.7

00:35:49,750 --> 00:35:54,910
for bite character Unicode multiply

00:35:52,059 --> 00:35:58,210
these four links to little bit playing

00:35:54,910 --> 00:36:00,549
64-bit always 10 windows then you have

00:35:58,210 --> 00:36:03,519
to do the same thing for Python 3.3 3.4

00:36:00,549 --> 00:36:04,450
3.5 3.6 if you're happy and you can use

00:36:03,519 --> 00:36:06,130
the stable ABI

00:36:04,450 --> 00:36:07,359
eventually you don't have to do that to

00:36:06,130 --> 00:36:10,359
unicode thing anymore you can just

00:36:07,359 --> 00:36:11,950
assume one but to do a release of one

00:36:10,359 --> 00:36:13,420
binary extension module that people

00:36:11,950 --> 00:36:16,589
don't have to compile themselves you

00:36:13,420 --> 00:36:20,170
probably have to do like 21 24 different

00:36:16,589 --> 00:36:22,269
tables or wheels this is excessive and

00:36:20,170 --> 00:36:26,470
the only reason is lip pies if you build

00:36:22,269 --> 00:36:28,119
a CFI module you can get away with 4 and

00:36:26,470 --> 00:36:29,769
this is a benefit that was never really

00:36:28,119 --> 00:36:32,940
understood by the community this one now

00:36:29,769 --> 00:36:35,829
you know it when you see FF i if you can

00:36:32,940 --> 00:36:38,140
but this is a realistic train a change

00:36:35,829 --> 00:36:41,140
to move towards c FF i instead of

00:36:38,140 --> 00:36:43,119
extension modules it's impossible for a

00:36:41,140 --> 00:36:45,190
lot of libraries like numpy for instance

00:36:43,119 --> 00:36:47,289
will not be able to move to c FF i as

00:36:45,190 --> 00:36:51,250
far as I understand or anything that

00:36:47,289 --> 00:36:54,130
sends piping objects around but for if

00:36:51,250 --> 00:36:55,660
you want to make your trees and parts

00:36:54,130 --> 00:36:58,809
are fast or if you want to do something

00:36:55,660 --> 00:37:00,490
where you have a utility library written

00:36:58,809 --> 00:37:02,440
in some language and you want to use the

00:37:00,490 --> 00:37:04,869
functions in Python y-you don't have to

00:37:02,440 --> 00:37:06,579
pass the entire five objects around it's

00:37:04,869 --> 00:37:10,420
very possible and I think it's much

00:37:06,579 --> 00:37:11,829
easier to use as well but because I

00:37:10,420 --> 00:37:13,839
think everybody was pushed towards

00:37:11,829 --> 00:37:15,369
regular extension modules people don't

00:37:13,839 --> 00:37:19,059
even think that see FF I it might be

00:37:15,369 --> 00:37:20,680
even the better solution last part is

00:37:19,059 --> 00:37:22,259
something that we should steal from

00:37:20,680 --> 00:37:26,470
somewhere else

00:37:22,259 --> 00:37:28,119
lenders and type annotations I also put

00:37:26,470 --> 00:37:29,740
a bobble on there Barbara is a library

00:37:28,119 --> 00:37:31,930
for Python where you can JavaScript

00:37:29,740 --> 00:37:34,480
where I can take Chavez got quotes and

00:37:31,930 --> 00:37:36,519
you can do stuff with it and generate

00:37:34,480 --> 00:37:37,660
other JavaScript code and this actually

00:37:36,519 --> 00:37:38,950
turns out to have a really profound

00:37:37,660 --> 00:37:41,680
impact on the JavaScript community

00:37:38,950 --> 00:37:43,000
because you can use more modern language

00:37:41,680 --> 00:37:46,390
features on an older version of

00:37:43,000 --> 00:37:49,089
JavaScript and because it was accepted

00:37:46,390 --> 00:37:50,680
as being a possible pair of software

00:37:49,089 --> 00:37:53,680
development there's a concept called

00:37:50,680 --> 00:37:54,970
source maps where you can still figure

00:37:53,680 --> 00:37:58,539
out where the error was in the original

00:37:54,970 --> 00:38:00,220
entrence pilot code and this actually

00:37:58,539 --> 00:38:02,259
made it possible to target newer

00:38:00,220 --> 00:38:04,869
versions of JavaScript on very old one

00:38:02,259 --> 00:38:06,369
times and maybe something like this will

00:38:04,869 --> 00:38:10,029
also be an option in the patent

00:38:06,369 --> 00:38:12,460
community to use things like increasing

00:38:10,029 --> 00:38:14,140
functions more prominently in all the

00:38:12,460 --> 00:38:16,690
versions of heisman maybe there could be

00:38:14,140 --> 00:38:18,970
a thing where you can transpire patent

00:38:16,690 --> 00:38:21,609
to code on Python 3 who knows

00:38:18,970 --> 00:38:23,799
and then obviously typescript and flow

00:38:21,609 --> 00:38:25,509
are very popular extensions for

00:38:23,799 --> 00:38:28,019
JavaScript to get static typing in I

00:38:25,509 --> 00:38:31,029
think they're moving this way with

00:38:28,019 --> 00:38:32,559
typing and Python 3 but we never really

00:38:31,029 --> 00:38:33,940
embraced it as much as a JavaScript

00:38:32,559 --> 00:38:37,029
community did it

00:38:33,940 --> 00:38:39,279
also it's it's very common now in other

00:38:37,029 --> 00:38:41,170
communities to just run a program and it

00:38:39,279 --> 00:38:43,660
formats your codes to the one true style

00:38:41,170 --> 00:38:45,220
and there's no arguments about it go

00:38:43,660 --> 00:38:48,819
doesn't even let you compile code unless

00:38:45,220 --> 00:38:50,019
it follows the naming conventions we

00:38:48,819 --> 00:38:51,730
would never be able to go there because

00:38:50,019 --> 00:38:53,859
the standard library already has like 20

00:38:51,730 --> 00:38:55,509
different naming conventions but maybe

00:38:53,859 --> 00:38:57,220
for our own code we could start to

00:38:55,509 --> 00:38:58,569
embrace the idea that there is this one

00:38:57,220 --> 00:39:02,079
thing you run maybe that would be like a

00:38:58,569 --> 00:39:03,490
flake 8 fixed my code style there's some

00:39:02,079 --> 00:39:06,130
nice handsome Python to godus

00:39:03,490 --> 00:39:08,890
do this but there is one thing the

00:39:06,130 --> 00:39:10,930
learnt is that if you use this one tool

00:39:08,890 --> 00:39:13,029
to format your source codes according to

00:39:10,930 --> 00:39:14,680
some standards your linter will complain

00:39:13,029 --> 00:39:16,150
about the output of this tool of it

00:39:14,680 --> 00:39:17,769
being different because the linter was

00:39:16,150 --> 00:39:19,839
written by different people than the

00:39:17,769 --> 00:39:21,759
formatter and stuff like this not great

00:39:19,839 --> 00:39:24,119
but I think this is probably one of the

00:39:21,759 --> 00:39:27,460
more realistic chance that we have of

00:39:24,119 --> 00:39:30,579
moving the language into a new area

00:39:27,460 --> 00:39:34,480
where we can agree on standards and

00:39:30,579 --> 00:39:35,220
stuff yeah so what can you personally do

00:39:34,480 --> 00:39:37,520
abused

00:39:35,220 --> 00:39:40,950
language less don't do stuff like this

00:39:37,520 --> 00:39:42,420
there is so much code that like gets a

00:39:40,950 --> 00:39:45,680
random frame and assigns the local

00:39:42,420 --> 00:39:48,060
variable and is like hold it add DSL

00:39:45,680 --> 00:39:50,099
there is like a sub interface for a very

00:39:48,060 --> 00:39:53,310
long time just modify the classic hope

00:39:50,099 --> 00:39:55,410
through this get frame try to not

00:39:53,310 --> 00:39:58,680
subclass built-ins anymore there is only

00:39:55,410 --> 00:40:01,440
suffering stop writing non csfi

00:39:58,680 --> 00:40:03,240
extensions if if you can do so and just

00:40:01,440 --> 00:40:04,740
stop being clever versus modules because

00:40:03,240 --> 00:40:06,690
if you stop being clever these modules

00:40:04,740 --> 00:40:08,550
maybe we can make a really cool import

00:40:06,690 --> 00:40:11,220
system which lets us do multi version

00:40:08,550 --> 00:40:14,480
dependencies one of the biggest mistakes

00:40:11,220 --> 00:40:18,150
ever made was that pickle addresses its

00:40:14,480 --> 00:40:21,570
types by the internal dotted name and

00:40:18,150 --> 00:40:23,700
because so Frances if you import if you

00:40:21,570 --> 00:40:25,320
at runtime want to import a module it

00:40:23,700 --> 00:40:27,150
used to be that the under under import

00:40:25,320 --> 00:40:28,650
function was so impossible to use that

00:40:27,150 --> 00:40:31,290
everybody did under under import

00:40:28,650 --> 00:40:33,840
whatever they wanted to import ignore

00:40:31,290 --> 00:40:35,550
the return value and then assume that

00:40:33,840 --> 00:40:37,200
what they imported is actually instance

00:40:35,550 --> 00:40:39,869
modules so they will do under under

00:40:37,200 --> 00:40:42,560
employed food bar ignore return value

00:40:39,869 --> 00:40:44,880
and then returns his modules food at bar

00:40:42,560 --> 00:40:45,990
this obviously won't work with multi

00:40:44,880 --> 00:40:47,220
version dependencies because these

00:40:45,990 --> 00:40:49,290
modules would have to have different

00:40:47,220 --> 00:40:51,300
keys and that was just my API design

00:40:49,290 --> 00:40:53,040
mistake that was copy pasted all over

00:40:51,300 --> 00:40:55,380
the world and now everybody's still

00:40:53,040 --> 00:40:57,180
doing this but awareness is the first

00:40:55,380 --> 00:40:59,820
step if we know not to do this to be

00:40:57,180 --> 00:41:02,040
things anymore maybe we can evolve the

00:40:59,820 --> 00:41:04,560
language and with that if there is still

00:41:02,040 --> 00:41:18,040
some time left I will take questions

00:41:04,560 --> 00:41:18,040
[Applause]

00:41:21,660 --> 00:41:25,539
it's actually like if someone's have

00:41:24,099 --> 00:41:32,410
questions it's a microphone or how does

00:41:25,539 --> 00:41:35,099
it work I will just repeat the question

00:41:32,410 --> 00:41:35,099
so just tell me

00:42:01,240 --> 00:42:05,800
so the question is if you cut away the

00:42:03,790 --> 00:42:07,720
Hanks wood pipe and become less nice to

00:42:05,800 --> 00:42:09,370
use because a lot of the ecosystem

00:42:07,720 --> 00:42:12,240
actually depends on these hikes like she

00:42:09,370 --> 00:42:14,770
event and and other libraries and

00:42:12,240 --> 00:42:16,390
probably the answer is yes if you take

00:42:14,770 --> 00:42:18,850
it away completely you should never take

00:42:16,390 --> 00:42:21,670
away people's ability to experiment with

00:42:18,850 --> 00:42:23,650
this but it doesn't mean that everything

00:42:21,670 --> 00:42:25,270
has to stay a hack forever like I think

00:42:23,650 --> 00:42:28,240
it's nice to hack around temporarily to

00:42:25,270 --> 00:42:30,010
makes setup clothes nice but instead of

00:42:28,240 --> 00:42:32,590
continuing this hack forever we could

00:42:30,010 --> 00:42:34,570
just do it and see like there's a

00:42:32,590 --> 00:42:35,610
legitimate need for this maybe we can do

00:42:34,570 --> 00:42:37,540
it differently

00:42:35,610 --> 00:42:45,179
alright thank you

00:42:37,540 --> 00:42:45,179

YouTube URL: https://www.youtube.com/watch?v=IeSu_odkI5I


