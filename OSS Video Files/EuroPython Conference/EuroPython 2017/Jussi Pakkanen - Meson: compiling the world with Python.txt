Title: Jussi Pakkanen - Meson: compiling the world with Python
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Meson: compiling the world with Python
[EuroPython 2017 - Talk - 2017-07-10 - Arengo]
[Rimini, Italy]

Compiling source code into libraries and executables has always been problematic, especially for cross platform projects. Typical problems in existing build systems include slow build times, undecipherable syntax, lack of support for cross compilation and so on. Some people choose to not use a build system at all but instead just write a one-off Makefile, which will usually work fine on their machine and nowhere else. All this makes software development slower than it needs to be.

The Meson build system (http://mesonbuild.com) is a new build system designed from the ground up to provide a solution for these (and other) problems. It is implemented in Python 3 and provides a simple, non-Turing complete DSL for describing the build. The project provides built-in support for common tasks such as documentation generation, building Qt apps and Python extension modules. Meson is currently seeing a lot of uptake in the Free software world with big projects such as GStreamer, parts of GNOME, Wayland and even the X server either transitioning, or very strongly considering the transition to Meson. 

In this talk we go over the design of Meson, how to use it for new and existing projects and the benefits this brings, including faster compiles, less time wasted debugging the build system environment and easy access to modern software development tools and practices.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,370 --> 00:00:10,850
good morning welcome to the talk my name

00:00:08,450 --> 00:00:13,879
is Josie and I'm here to talk to you

00:00:10,850 --> 00:00:15,770
about build systems usually when I talk

00:00:13,879 --> 00:00:19,070
to people about build systems to reply I

00:00:15,770 --> 00:00:20,990
get is this which is that all these

00:00:19,070 --> 00:00:24,740
build systems are terrible and why do I

00:00:20,990 --> 00:00:26,630
care both let's look into this if you

00:00:24,740 --> 00:00:28,820
were in the keynote one of the points

00:00:26,630 --> 00:00:30,949
made there was to explicitly say that

00:00:28,820 --> 00:00:33,890
don't build any more Python extensions

00:00:30,949 --> 00:00:37,010
so with that in mind let's build Python

00:00:33,890 --> 00:00:41,620
3 extension module and to make it more

00:00:37,010 --> 00:00:48,700
interesting we're going to be using C

00:00:41,620 --> 00:00:52,160
C++ rust and Fortran all in the same

00:00:48,700 --> 00:00:56,510
extension module and if you've ever done

00:00:52,160 --> 00:00:58,220
this with these skills I salute you but

00:00:56,510 --> 00:01:01,960
here the height would look like if you

00:00:58,220 --> 00:01:04,850
would do the same thing with Mezen so

00:01:01,960 --> 00:01:06,770
first you start the thing by defining

00:01:04,850 --> 00:01:09,079
the project which in this case is called

00:01:06,770 --> 00:01:14,030
police make and the list of languages

00:01:09,079 --> 00:01:16,399
that you want to use and the next step

00:01:14,030 --> 00:01:17,350
is this function where we import by

00:01:16,399 --> 00:01:19,880
variously

00:01:17,350 --> 00:01:22,640
internal module system that we have in

00:01:19,880 --> 00:01:25,100
Mezen and this Python 3 module has all

00:01:22,640 --> 00:01:30,490
the knowledge to build Python extensions

00:01:25,100 --> 00:01:32,840
and then we find the dependency and this

00:01:30,490 --> 00:01:35,990
what it does is goes out to the system

00:01:32,840 --> 00:01:37,909
and finds out what are all the flags and

00:01:35,990 --> 00:01:40,219
linker flags and all that sort of things

00:01:37,909 --> 00:01:42,560
that you need to compile python 3

00:01:40,219 --> 00:01:45,229
applications on linux this would be

00:01:42,560 --> 00:01:47,090
going into package config and on other

00:01:45,229 --> 00:01:52,310
platforms it does a bunch of other magic

00:01:47,090 --> 00:01:54,679
stuff then we build a rust static

00:01:52,310 --> 00:01:57,499
library rust is a bit special so you

00:01:54,679 --> 00:02:01,340
have to do it this way but this is very

00:01:57,499 --> 00:02:03,889
quite quite simple and once you have

00:02:01,340 --> 00:02:06,770
that then we can start the actual

00:02:03,889 --> 00:02:10,490
extension module building so we call

00:02:06,770 --> 00:02:13,250
pi/3 mod dots extension module and we

00:02:10,490 --> 00:02:14,840
give the name and then we list the

00:02:13,250 --> 00:02:17,540
source files that we want to have in it

00:02:14,840 --> 00:02:18,140
in this case the C file the CPP file and

00:02:17,540 --> 00:02:20,540
the 4

00:02:18,140 --> 00:02:24,010
and file so as you can see we're using

00:02:20,540 --> 00:02:27,380
the modern age 90 and not PS at 77 and

00:02:24,010 --> 00:02:28,900
then we tell that we want to link the

00:02:27,380 --> 00:02:32,300
rust library that were built earlier

00:02:28,900 --> 00:02:35,510
with this and then we say that the

00:02:32,300 --> 00:02:39,380
dependencies of this project are the the

00:02:35,510 --> 00:02:41,630
Python dependency that is there and this

00:02:39,380 --> 00:02:46,100
is the build definition in its entirety

00:02:41,630 --> 00:02:50,140
this is all you need to write and then

00:02:46,100 --> 00:02:54,770
you can just compile it and it goes and

00:02:50,140 --> 00:02:57,380
this is so within the design goals of

00:02:54,770 --> 00:03:00,590
the system which were which you could

00:02:57,380 --> 00:03:02,870
see someone on the previous slide go off

00:03:00,590 --> 00:03:05,480
like this so there is the the platform

00:03:02,870 --> 00:03:08,080
that we have today which is Linux OS 10

00:03:05,480 --> 00:03:12,019
Windows bsds and a bunch of other ones

00:03:08,080 --> 00:03:14,750
we want to support all of them there are

00:03:12,019 --> 00:03:16,970
several different compilers GCC clang

00:03:14,750 --> 00:03:21,410
Visual Studio the Intel compiler we want

00:03:16,970 --> 00:03:23,329
to support all of those we try to hide

00:03:21,410 --> 00:03:26,120
as much of the platforms to sleep

00:03:23,329 --> 00:03:27,650
differences as possible including

00:03:26,120 --> 00:03:29,920
compiler flags and all that sort of

00:03:27,650 --> 00:03:32,540
stuff basically just want to say I want

00:03:29,920 --> 00:03:34,280
compiler warnings to be enabled and then

00:03:32,540 --> 00:03:39,079
we do that and we take care of all the

00:03:34,280 --> 00:03:41,420
backend stuff for you and out of the box

00:03:39,079 --> 00:03:43,430
we should provide support for tools that

00:03:41,420 --> 00:03:46,190
people are using today there's very

00:03:43,430 --> 00:03:47,959
little point in having like 7,000 line

00:03:46,190 --> 00:03:49,730
make files where you copy bits from one

00:03:47,959 --> 00:03:51,320
place to another because this worked in

00:03:49,730 --> 00:03:53,150
one project so maybe it's perks in this

00:03:51,320 --> 00:03:56,420
one as well but then it doesn't and then

00:03:53,150 --> 00:03:59,630
you're just debugging for quite a long

00:03:56,420 --> 00:04:01,880
time and the major architectural

00:03:59,630 --> 00:04:03,980
decisions of this system are not defined

00:04:01,880 --> 00:04:08,180
by what was in the default user land of

00:04:03,980 --> 00:04:10,310
Sun OS 3.5 circa 1987 because that's

00:04:08,180 --> 00:04:12,799
what like for example all the tools does

00:04:10,310 --> 00:04:15,170
size it's an admirable backwards

00:04:12,799 --> 00:04:20,060
compatibility claim but like maybe it's

00:04:15,170 --> 00:04:23,990
time to let go and at the very core of

00:04:20,060 --> 00:04:26,510
of Mezen is the domain-specific language

00:04:23,990 --> 00:04:29,060
that is used for defining these builds

00:04:26,510 --> 00:04:31,289
this is the thing that we spend most of

00:04:29,060 --> 00:04:33,979
our energy on like getting as good over

00:04:31,289 --> 00:04:36,449
definition language as possible and

00:04:33,979 --> 00:04:38,430
let's look at some of the design calls

00:04:36,449 --> 00:04:39,599
that we have now first we're going to

00:04:38,430 --> 00:04:42,599
look at some of the design mode

00:04:39,599 --> 00:04:45,330
principles because your product is

00:04:42,599 --> 00:04:46,619
defined by what it does not do more than

00:04:45,330 --> 00:04:48,419
its defined by what it actually does

00:04:46,619 --> 00:04:51,210
especially if you have something that is

00:04:48,419 --> 00:04:52,619
turing-complete but the things that you

00:04:51,210 --> 00:04:55,409
specifically are saying that we are not

00:04:52,619 --> 00:04:58,949
going to do help you make a lot better

00:04:55,409 --> 00:05:01,800
design designs later on so the main

00:04:58,949 --> 00:05:03,749
design thing is that Mazin is not a

00:05:01,800 --> 00:05:06,509
framework there are a bunch of build

00:05:03,749 --> 00:05:07,680
systems which say that though this is

00:05:06,509 --> 00:05:09,449
not a build system this is a framework

00:05:07,680 --> 00:05:11,520
with which you can build the perfect

00:05:09,449 --> 00:05:13,529
build system for your projects as if

00:05:11,520 --> 00:05:15,599
this was a good thing no we don't do

00:05:13,529 --> 00:05:18,330
that we have a very specifically focused

00:05:15,599 --> 00:05:23,039
we do this one thing we do it well we do

00:05:18,330 --> 00:05:24,300
it all and the there are a bunch of

00:05:23,039 --> 00:05:26,669
build systems that are declarative

00:05:24,300 --> 00:05:29,279
languages and declarative languages are

00:05:26,669 --> 00:05:30,779
really awesome when they work but the

00:05:29,279 --> 00:05:33,449
problem is that when they don't work

00:05:30,779 --> 00:05:37,199
it's it's really really painful to debug

00:05:33,449 --> 00:05:40,550
and because of this which methane is not

00:05:37,199 --> 00:05:42,899
a declarative language

00:05:40,550 --> 00:05:46,559
but we try to be as delicate declarative

00:05:42,899 --> 00:05:48,269
as possible and it's not Turing complete

00:05:46,559 --> 00:05:50,430
you can specify your own functions or

00:05:48,269 --> 00:05:52,499
recursion or any of that and the reason

00:05:50,430 --> 00:05:53,999
for this is that makes tooling much more

00:05:52,499 --> 00:05:55,229
easier to write because it's easier to

00:05:53,999 --> 00:06:00,389
understand what the things actually

00:05:55,229 --> 00:06:02,490
doing but it's not Python it's clipped

00:06:00,389 --> 00:06:04,050
it hides the fact that it's implemented

00:06:02,490 --> 00:06:07,699
in Python so it could be read

00:06:04,050 --> 00:06:07,699
implemented in any language at all

00:06:08,159 --> 00:06:13,249
so what those were the not principle so

00:06:10,740 --> 00:06:15,659
what are the actual design principles

00:06:13,249 --> 00:06:17,909
basically boils down to this instance

00:06:15,659 --> 00:06:19,199
every second you spend writing or

00:06:17,909 --> 00:06:20,819
debugging field its emissions is a

00:06:19,199 --> 00:06:22,349
second wasted you're not being

00:06:20,819 --> 00:06:24,569
productive when you're writing build

00:06:22,349 --> 00:06:26,219
definition rules it just boilerplate

00:06:24,569 --> 00:06:30,330
stuff that you have to do so let's do it

00:06:26,219 --> 00:06:32,249
as little of it as possible understand

00:06:30,330 --> 00:06:33,509
ability is the most important thing you

00:06:32,249 --> 00:06:35,719
should be able to look at your built

00:06:33,509 --> 00:06:37,800
definitions like one file in isolation

00:06:35,719 --> 00:06:39,779
fairly good understanding of what it

00:06:37,800 --> 00:06:41,249
does and it's not like some sort of

00:06:39,779 --> 00:06:42,779
spooky action at a distance where like

00:06:41,249 --> 00:06:44,750
it says here that it's going to do

00:06:42,779 --> 00:06:46,010
something but actually over there

00:06:44,750 --> 00:06:47,840
thing else which completely changes

00:06:46,010 --> 00:06:51,650
everything so we don't want to have any

00:06:47,840 --> 00:06:53,960
of that performance is important we

00:06:51,650 --> 00:06:56,810
needs to scale to tens of thousands of

00:06:53,960 --> 00:06:58,880
files even more and you have to have

00:06:56,810 --> 00:07:00,620
have this sort of performance built-in

00:06:58,880 --> 00:07:03,470
although the core stuff needs to be

00:07:00,620 --> 00:07:05,360
properly done you can't really like like

00:07:03,470 --> 00:07:10,670
bolt on afterwards some sort of

00:07:05,360 --> 00:07:13,760
performance zen of python explicit is

00:07:10,670 --> 00:07:15,590
better than implicit awesome all that

00:07:13,760 --> 00:07:17,600
good stuff there should only be one way

00:07:15,590 --> 00:07:18,620
to do something and it should be obvious

00:07:17,600 --> 00:07:21,260
awesome

00:07:18,620 --> 00:07:22,880
so we stole all of that and basically we

00:07:21,260 --> 00:07:24,710
just steal everything that is good from

00:07:22,880 --> 00:07:26,840
anyone if there's any there's no such

00:07:24,710 --> 00:07:28,550
thing as nih if someone has a good thing

00:07:26,840 --> 00:07:29,570
that they're doing we are not we're

00:07:28,550 --> 00:07:34,430
going to steal it and we're going to be

00:07:29,570 --> 00:07:36,380
proud about it and the one thing is that

00:07:34,430 --> 00:07:38,720
build definitions should be shorter than

00:07:36,380 --> 00:07:41,150
writing the exact compilation commands

00:07:38,720 --> 00:07:43,790
by hand let's look at an example a hello

00:07:41,150 --> 00:07:45,290
world example looks like this is define

00:07:43,790 --> 00:07:47,810
your project and then you say I wanna

00:07:45,290 --> 00:07:51,200
put an executable which has this one

00:07:47,810 --> 00:07:52,970
file and this is 64 characters and if

00:07:51,200 --> 00:07:55,340
you do it manually

00:07:52,970 --> 00:07:57,919
he said CCW all all the stuff you can

00:07:55,340 --> 00:07:59,720
pile a link and that's 54 characters so

00:07:57,919 --> 00:08:02,330
we didn't quite reach the goal however

00:07:59,720 --> 00:08:08,840
if you use GCC then is 56 characters and

00:08:02,330 --> 00:08:12,410
we win we also want to be usable across

00:08:08,840 --> 00:08:14,810
all for every single to use case and the

00:08:12,410 --> 00:08:17,450
only dependency that we have is Python 3

00:08:14,810 --> 00:08:19,640
and only pleasantly and the standard

00:08:17,450 --> 00:08:22,100
library anything outside of that we're

00:08:19,640 --> 00:08:23,450
not allowed to use any of that as an

00:08:22,100 --> 00:08:26,140
example there are a bunch of build

00:08:23,450 --> 00:08:28,510
systems that are implemented in Java and

00:08:26,140 --> 00:08:32,030
the problem there is that there are many

00:08:28,510 --> 00:08:35,000
platforms on which javac cannot run and

00:08:32,030 --> 00:08:37,339
let there's no CPU there's no memory all

00:08:35,000 --> 00:08:39,469
that stuff and and it's a dependency

00:08:37,339 --> 00:08:42,130
that a lot of projects can't take and

00:08:39,469 --> 00:08:45,050
even more projects don't want to take

00:08:42,130 --> 00:08:46,580
but we want to be able to support all of

00:08:45,050 --> 00:08:48,170
those and Python is really good because

00:08:46,580 --> 00:08:52,460
it's it's quite small it's

00:08:48,170 --> 00:08:56,839
self-contained and it's everywhere for

00:08:52,460 --> 00:08:58,120
design we've been doing the 90/90 slash

00:08:56,839 --> 00:08:59,980
one rule which

00:08:58,120 --> 00:09:01,810
is that there's 90% case and that should

00:08:59,980 --> 00:09:03,460
work out of the box it could almost

00:09:01,810 --> 00:09:05,380
always visit the case because it

00:09:03,460 --> 00:09:07,180
basically there's only so many ways you

00:09:05,380 --> 00:09:10,180
want to build an executable with some

00:09:07,180 --> 00:09:13,330
sources that the nine percent case

00:09:10,180 --> 00:09:16,000
should be possible and for the one

00:09:13,330 --> 00:09:17,680
percent case we can just taste like what

00:09:16,000 --> 00:09:19,480
you're doing is just so weird that we

00:09:17,680 --> 00:09:20,680
can support that and it would complicate

00:09:19,480 --> 00:09:22,630
everything else completely

00:09:20,680 --> 00:09:24,190
and usually it's like okay but if you do

00:09:22,630 --> 00:09:26,920
this other thing instead then we can

00:09:24,190 --> 00:09:29,110
just do that but it's totally okay for

00:09:26,920 --> 00:09:31,240
so this look like the weirdest of edge

00:09:29,110 --> 00:09:32,740
cases this has to say it okay we can't

00:09:31,240 --> 00:09:35,770
support that out of the box we have to

00:09:32,740 --> 00:09:39,520
do some of your own magic in practice

00:09:35,770 --> 00:09:44,290
this has been less than 1% well so but

00:09:39,520 --> 00:09:46,120
it's still there and and there are

00:09:44,290 --> 00:09:48,160
already people using it that they're

00:09:46,120 --> 00:09:49,630
they're like hundred build systems

00:09:48,160 --> 00:09:52,900
usually most of them have about two

00:09:49,630 --> 00:09:55,720
users but we have managed to get some of

00:09:52,900 --> 00:09:58,779
them and one of them the major users

00:09:55,720 --> 00:10:03,130
thus far has been the t3 or multimedia

00:09:58,779 --> 00:10:04,930
framework which is a 150 plugins and a

00:10:03,130 --> 00:10:07,300
base platform and all that cool stuff

00:10:04,930 --> 00:10:10,000
and they're using it to build on Windows

00:10:07,300 --> 00:10:14,709
and and OS 10 and Linux and all that

00:10:10,000 --> 00:10:16,060
stuff and then there's system D for

00:10:14,709 --> 00:10:18,370
those of you who don't know system D is

00:10:16,060 --> 00:10:20,500
the first project but first process that

00:10:18,370 --> 00:10:23,140
is spawned when a modern Linux system

00:10:20,500 --> 00:10:25,000
boots up and it's like the manager

00:10:23,140 --> 00:10:27,970
process which take care it takes care of

00:10:25,000 --> 00:10:32,290
all the other processes and they

00:10:27,970 --> 00:10:34,089
actually have a outstanding bill merger

00:10:32,290 --> 00:10:36,520
proposal to remove order tools

00:10:34,089 --> 00:10:38,260
altogether so then starting from the

00:10:36,520 --> 00:10:43,650
next release they're probably going to

00:10:38,260 --> 00:10:46,170
have only method for building the X or

00:10:43,650 --> 00:10:48,370
graphical user interface if you are

00:10:46,170 --> 00:10:50,650
Linux laptops you're probably using one

00:10:48,370 --> 00:10:52,930
of those using that and if you're not

00:10:50,650 --> 00:10:55,420
you're probably using Weiland which is

00:10:52,930 --> 00:10:57,640
the the up-and-coming new graphical view

00:10:55,420 --> 00:11:00,040
server and that has some build

00:10:57,640 --> 00:11:01,810
definition as well when Western is the

00:11:00,040 --> 00:11:05,370
reference implementation window main

00:11:01,810 --> 00:11:08,320
server that's the GDK widget toolkit

00:11:05,370 --> 00:11:11,079
which is predict it's multi-platform and

00:11:08,320 --> 00:11:11,740
in their four series that they have

00:11:11,079 --> 00:11:13,690
merged

00:11:11,740 --> 00:11:17,080
the the resident bill definition in the

00:11:13,690 --> 00:11:18,700
gonna I think they're gonna some at some

00:11:17,080 --> 00:11:22,720
point get rid of the old one but it's

00:11:18,700 --> 00:11:24,340
it's not not yet happening a lot of

00:11:22,720 --> 00:11:27,600
ground politically are are going as well

00:11:24,340 --> 00:11:28,870
modulus and a bunch of other ones and

00:11:27,600 --> 00:11:31,000
the

00:11:28,870 --> 00:11:32,620
PTV nonlinear Video Editor which is also

00:11:31,000 --> 00:11:37,150
implemented in Python it's a pretty cool

00:11:32,620 --> 00:11:38,740
project is totally check it out and of

00:11:37,150 --> 00:11:41,260
the website we have a list of a bunch of

00:11:38,740 --> 00:11:45,520
other projects that are also also using

00:11:41,260 --> 00:11:48,190
this and one of the main reasons why

00:11:45,520 --> 00:11:51,070
people are switching into messin is that

00:11:48,190 --> 00:11:53,860
you get some fairly hectic compile time

00:11:51,070 --> 00:11:56,980
improvements so as an example system D

00:11:53,860 --> 00:11:59,080
on Linux went from sixteen minutes to

00:11:56,980 --> 00:12:01,030
compile to two minutes and 32 seconds

00:11:59,080 --> 00:12:02,560
and if that seems weird to you this

00:12:01,030 --> 00:12:04,570
seems weird to me I went through this

00:12:02,560 --> 00:12:06,790
light like four times and every single

00:12:04,570 --> 00:12:08,290
time I saw this one is like that can't

00:12:06,790 --> 00:12:11,050
be right I have to read verify that and

00:12:08,290 --> 00:12:15,700
and every single time it's still 2

00:12:11,050 --> 00:12:19,030
minutes and 32 seconds and and so it's

00:12:15,700 --> 00:12:20,920
fairly heavy very difference if you are

00:12:19,030 --> 00:12:24,360
compiling Wayland on Raspberry Pi

00:12:20,920 --> 00:12:27,100
it went from six minutes to a minute and

00:12:24,360 --> 00:12:29,470
there's the free dot re which is a

00:12:27,100 --> 00:12:31,420
debugging tool kit and their cross

00:12:29,470 --> 00:12:35,950
compilation time of to iOS went from six

00:12:31,420 --> 00:12:40,210
minutes to one a half in practice what

00:12:35,950 --> 00:12:42,970
we seem to find a cell projects can go

00:12:40,210 --> 00:12:47,350
up to ten to twenty times faster if

00:12:42,970 --> 00:12:49,750
they're baked based and especially if

00:12:47,350 --> 00:12:52,630
you are on Windows because on Windows

00:12:49,750 --> 00:12:56,680
file system operations are like abysmal

00:12:52,630 --> 00:13:00,340
is low and because we don't use make and

00:12:56,680 --> 00:13:03,910
and we are not going to use make ever we

00:13:00,340 --> 00:13:05,800
don't have this problem and for

00:13:03,910 --> 00:13:07,060
incremental builds the difference

00:13:05,800 --> 00:13:08,560
because it's even bigger because there's

00:13:07,060 --> 00:13:10,480
a bunch of optimizations that we do

00:13:08,560 --> 00:13:15,580
where we can skip real inking of stuff

00:13:10,480 --> 00:13:18,130
and so we haven't done any large-scale

00:13:15,580 --> 00:13:19,540
tests with other ninja generators like

00:13:18,130 --> 00:13:22,300
the C make for example has a ninja

00:13:19,540 --> 00:13:24,070
back-end and but it seems that we

00:13:22,300 --> 00:13:26,050
produce slightly more efficient files

00:13:24,070 --> 00:13:27,760
but this is like

00:13:26,050 --> 00:13:33,220
it hasn't been conclusively proven by

00:13:27,760 --> 00:13:36,580
the way let's talk about built-in

00:13:33,220 --> 00:13:38,140
support for stuff so we support the

00:13:36,580 --> 00:13:39,459
sanitizer so address analyzer memory

00:13:38,140 --> 00:13:41,440
centers are you be senators that all

00:13:39,459 --> 00:13:43,060
stuff you just likes toggle the switch

00:13:41,440 --> 00:13:46,209
say almond is enabled and then you have

00:13:43,060 --> 00:13:48,850
it Howard support precompiled hitters

00:13:46,209 --> 00:13:51,520
cannot build all the things that you

00:13:48,850 --> 00:13:53,649
would expect and and likes can build is

00:13:51,520 --> 00:13:55,390
the static analyzer that comes with

00:13:53,649 --> 00:13:57,339
claim and if you have it installed is

00:13:55,390 --> 00:13:59,500
the there's a target called

00:13:57,339 --> 00:14:03,100
can build it just so I run it and then

00:13:59,500 --> 00:14:04,839
it runs the thing and reproducible

00:14:03,100 --> 00:14:07,600
builds that's another interesting thing

00:14:04,839 --> 00:14:09,520
this big thing that is going on with

00:14:07,600 --> 00:14:12,209
Debian and a bunch of other projects we

00:14:09,520 --> 00:14:15,610
basically want to prevent the in

00:14:12,209 --> 00:14:17,170
generation of binary packages which have

00:14:15,610 --> 00:14:19,089
all that are not in the original source

00:14:17,170 --> 00:14:21,490
so if you can produce from the same

00:14:19,089 --> 00:14:24,700
source files the same bit for bit

00:14:21,490 --> 00:14:25,870
identical binary files from many

00:14:24,700 --> 00:14:28,060
different people are going to do this

00:14:25,870 --> 00:14:29,709
then you can be fairly certain that the

00:14:28,060 --> 00:14:31,480
the pointer that you have is actually

00:14:29,709 --> 00:14:36,120
proper and you haven't been back door

00:14:31,480 --> 00:14:39,310
and basically want to support everything

00:14:36,120 --> 00:14:40,870
within reason because there's no point

00:14:39,310 --> 00:14:42,520
in everyone look trying to reinvent the

00:14:40,870 --> 00:14:44,320
wheel of how do I support this specific

00:14:42,520 --> 00:14:45,790
you don't want to all it just put do it

00:14:44,320 --> 00:14:50,649
once in the core system and then

00:14:45,790 --> 00:14:53,110
everyone can use it we also have a unit

00:14:50,649 --> 00:14:55,899
testing favored for running the tests we

00:14:53,110 --> 00:14:57,130
can cool stuff like setting your

00:14:55,899 --> 00:14:59,230
environment we have set environment

00:14:57,130 --> 00:15:01,270
variables and command line arguments and

00:14:59,230 --> 00:15:04,630
things to run and all that sort of stuff

00:15:01,270 --> 00:15:06,370
and we log a standard output standard

00:15:04,630 --> 00:15:12,910
error how long it took all of that good

00:15:06,370 --> 00:15:14,110
stuff and excuse me it's easy to add

00:15:12,910 --> 00:15:15,940
support for stuff like valgrind

00:15:14,110 --> 00:15:17,890
and all tests are run in parallel by

00:15:15,940 --> 00:15:19,300
default which is particularly nice if

00:15:17,890 --> 00:15:21,010
you are running valgrind because then

00:15:19,300 --> 00:15:24,880
they are about 10 to 20 X slower than

00:15:21,010 --> 00:15:26,470
they usually would be and you can run

00:15:24,880 --> 00:15:29,589
the test suite multiple times you want

00:15:26,470 --> 00:15:31,329
to you can run the test under gdb which

00:15:29,589 --> 00:15:33,910
is kind of nice as well and then you can

00:15:31,329 --> 00:15:35,920
just run tests under gdb until they fail

00:15:33,910 --> 00:15:37,240
and then you just like leave your

00:15:35,920 --> 00:15:39,160
machine running if you have a flaky test

00:15:37,240 --> 00:15:39,640
and then you come back to it and oh no

00:15:39,160 --> 00:15:42,760
there's

00:15:39,640 --> 00:15:46,180
the gdb prompt for the one the one 1000

00:15:42,760 --> 00:15:49,900
ones the next one failed which is Conrad

00:15:46,180 --> 00:15:53,290
as well cross-compilation will of course

00:15:49,900 --> 00:15:55,090
do a full Canadian course if you don't

00:15:53,290 --> 00:15:56,440
know what that means it's probably not

00:15:55,090 --> 00:15:58,600
very important but if you do know what

00:15:56,440 --> 00:16:00,370
it means then it's probably quite

00:15:58,600 --> 00:16:04,030
important for you and and we support

00:16:00,370 --> 00:16:05,710
that fully for Linux and Linux

00:16:04,030 --> 00:16:08,560
cross-compilation that's being used a

00:16:05,710 --> 00:16:11,410
lot and there are people who compiled

00:16:08,560 --> 00:16:13,600
from Linux Windows so that using the

00:16:11,410 --> 00:16:15,580
mingw packages that come with the distro

00:16:13,600 --> 00:16:17,620
so they can just generate all of their

00:16:15,580 --> 00:16:21,910
Windows packaging from their Linux

00:16:17,620 --> 00:16:26,350
desktop machines very easily Android

00:16:21,910 --> 00:16:28,150
works iOS works and also bare metal so

00:16:26,350 --> 00:16:32,160
you have an Arduino thing happening you

00:16:28,150 --> 00:16:34,690
can compile compile good messing and in

00:16:32,160 --> 00:16:37,090
this you need stuff like upload the

00:16:34,690 --> 00:16:39,490
target and these sorts of things are

00:16:37,090 --> 00:16:41,530
very easy to add and then when I'm doing

00:16:39,490 --> 00:16:44,890
Arduino development as I just always run

00:16:41,530 --> 00:16:46,750
ninja upload which compiles and uploads

00:16:44,890 --> 00:16:50,590
thing if it's if the everything works

00:16:46,750 --> 00:16:52,210
and there are very few changes in the

00:16:50,590 --> 00:16:55,090
build definitions that are excellent and

00:16:52,210 --> 00:16:56,590
usually you don't need anything yeah and

00:16:55,090 --> 00:16:58,390
it has the same build definition because

00:16:56,590 --> 00:17:00,340
all the parts that have to do with

00:16:58,390 --> 00:17:01,870
specifying that the cross environment

00:17:00,340 --> 00:17:05,220
are not in the build files they're

00:17:01,870 --> 00:17:05,220
actually somewhere completely separate

00:17:05,850 --> 00:17:11,650
but probably many of you were thinking

00:17:08,680 --> 00:17:13,390
like the most obvious question which

00:17:11,650 --> 00:17:16,209
always comes to people's minds when we

00:17:13,390 --> 00:17:18,640
talk about cross compilation which is

00:17:16,209 --> 00:17:21,699
what about bare metal embedded COBOL

00:17:18,640 --> 00:17:25,079
developments and I will glad to say that

00:17:21,699 --> 00:17:28,270
we just redo support that so they see

00:17:25,079 --> 00:17:31,840
there on the left you can see the COBOL

00:17:28,270 --> 00:17:34,630
program for running this external LCD

00:17:31,840 --> 00:17:37,800
screen and there's the screen running

00:17:34,630 --> 00:17:40,720
the COBOL program there and this is

00:17:37,800 --> 00:17:45,670
niacin working if you are in this sort

00:17:40,720 --> 00:17:48,010
of thing all those other things that you

00:17:45,670 --> 00:17:49,540
could do when cross compiling is that

00:17:48,010 --> 00:17:52,150
you can specify it in sort of like an

00:17:49,540 --> 00:17:53,460
exe wrapper and this is a program that

00:17:52,150 --> 00:17:55,289
you can use the or

00:17:53,460 --> 00:17:57,870
cross build files during the build time

00:17:55,289 --> 00:17:59,789
so this usually includes stuff like wine

00:17:57,870 --> 00:18:03,149
where you can run Windows programs or

00:17:59,789 --> 00:18:07,260
qmu which you can use to run like arm

00:18:03,149 --> 00:18:09,539
programs on an x86 machine and please

00:18:07,260 --> 00:18:10,980
type in nicely because you can have code

00:18:09,539 --> 00:18:12,990
generators that you compile and then

00:18:10,980 --> 00:18:15,029
you're using to generate more source

00:18:12,990 --> 00:18:17,880
files during the build so you can just

00:18:15,029 --> 00:18:19,710
run the executables as they are or you

00:18:17,880 --> 00:18:21,330
can specify that some of the executable

00:18:19,710 --> 00:18:22,950
should be built with the native compiler

00:18:21,330 --> 00:18:24,720
and not the cross compiler and then you

00:18:22,950 --> 00:18:28,289
can just run them and probably run a bit

00:18:24,720 --> 00:18:30,390
faster and you can also run the voltage

00:18:28,289 --> 00:18:32,130
suite of their application with all this

00:18:30,390 --> 00:18:34,200
so if you're on Linux you can run your

00:18:32,130 --> 00:18:39,330
full test suite for Windows when you're

00:18:34,200 --> 00:18:42,630
running a lot and as a next system will

00:18:39,330 --> 00:18:46,409
doing pretty well it's about four and a

00:18:42,630 --> 00:18:49,470
half years old and we have more than 100

00:18:46,409 --> 00:18:53,370
contributors at this time and which is

00:18:49,470 --> 00:18:55,260
about monthly releases and it's

00:18:53,370 --> 00:18:56,640
supported on all of the major is to be

00:18:55,260 --> 00:18:58,590
sold so debian fedora

00:18:56,640 --> 00:19:00,390
openSUSE and all of those and they have

00:18:58,590 --> 00:19:05,100
measured in the default package

00:19:00,390 --> 00:19:07,770
libraries so in case repositories we won

00:19:05,100 --> 00:19:09,929
fairly extensive test suite and they are

00:19:07,770 --> 00:19:11,880
the docker image that we use for testing

00:19:09,929 --> 00:19:14,130
the Linux part is about two and a half

00:19:11,880 --> 00:19:18,649
gigs of all the dependency that is

00:19:14,130 --> 00:19:22,559
needed to run all the actual tests and

00:19:18,649 --> 00:19:25,500
the building stuff is is relatively

00:19:22,559 --> 00:19:29,070
simple but dependencies are what makes

00:19:25,500 --> 00:19:36,659
things everything hard so we spend a lot

00:19:29,070 --> 00:19:38,659
of time thinking about this so the way

00:19:36,659 --> 00:19:42,240
that works is that in medicine you can

00:19:38,659 --> 00:19:44,460
build any project as a sub project of a

00:19:42,240 --> 00:19:47,520
different one and it's run in a sandbox

00:19:44,460 --> 00:19:51,600
environment so it can access stuff from

00:19:47,520 --> 00:19:53,250
the outside and it's isolated but then

00:19:51,600 --> 00:19:57,029
from the master project you can reach

00:19:53,250 --> 00:19:59,309
into it and take stuff from there so

00:19:57,029 --> 00:20:01,620
this makes it possible to have your

00:19:59,309 --> 00:20:03,029
dependencies either come from the system

00:20:01,620 --> 00:20:05,220
as like on a Linux machine where you

00:20:03,029 --> 00:20:06,960
just use its config files to get your

00:20:05,220 --> 00:20:07,560
dependencies or you can build them

00:20:06,960 --> 00:20:11,310
yourself

00:20:07,560 --> 00:20:14,130
and the build definition for file for

00:20:11,310 --> 00:20:15,780
both of these looks exactly the same you

00:20:14,130 --> 00:20:17,820
don't really care where independent is

00:20:15,780 --> 00:20:21,890
come from me to say I want this thing to

00:20:17,820 --> 00:20:23,820
be available and this works

00:20:21,890 --> 00:20:25,650
cross-platform is there's nothing

00:20:23,820 --> 00:20:28,970
specific about it so Windows OS and

00:20:25,650 --> 00:20:31,380
Android all you need to do is if your

00:20:28,970 --> 00:20:33,690
dependency that you're using compiles

00:20:31,380 --> 00:20:38,610
with messin on that platform then you

00:20:33,690 --> 00:20:41,820
can use it this is very similar to to

00:20:38,610 --> 00:20:43,920
rust cargo or B has a similar thing

00:20:41,820 --> 00:20:46,890
called up and I think go has something

00:20:43,920 --> 00:20:49,410
called Coke yet and but the thing is

00:20:46,890 --> 00:20:51,420
that this definition is not tied to any

00:20:49,410 --> 00:20:53,880
specific language it's it's completely

00:20:51,420 --> 00:20:56,280
language agnostic so you could use it

00:20:53,880 --> 00:21:00,680
for any any language dependency that you

00:20:56,280 --> 00:21:04,440
care this as a tech this is up for we

00:21:00,680 --> 00:21:06,680
okay sorry and we have the this cold rap

00:21:04,440 --> 00:21:11,220
DB which shows these dependencies online

00:21:06,680 --> 00:21:12,600
and this works in total cooperation with

00:21:11,220 --> 00:21:14,550
this topic so if you are this to a

00:21:12,600 --> 00:21:16,590
pitcher one of the things you hate more

00:21:14,550 --> 00:21:18,390
than anything else is that people embed

00:21:16,590 --> 00:21:20,430
the sources of the dependencies inside

00:21:18,390 --> 00:21:21,840
their packages and then they built those

00:21:20,430 --> 00:21:23,550
and then you have to rip them out and

00:21:21,840 --> 00:21:26,790
you and maybe they have changed it in

00:21:23,550 --> 00:21:28,170
all that stuff so this works in complete

00:21:26,790 --> 00:21:30,840
cooperation because you can just say

00:21:28,170 --> 00:21:32,760
that all I want is you're not only

00:21:30,840 --> 00:21:35,130
allowed to use system dependencies and

00:21:32,760 --> 00:21:35,640
if you're not having it those and it's a

00:21:35,130 --> 00:21:37,020
hard error

00:21:35,640 --> 00:21:41,790
don't try to compile your embedded

00:21:37,020 --> 00:21:43,980
source and never download anything from

00:21:41,790 --> 00:21:45,540
the internet so if you have a thing

00:21:43,980 --> 00:21:47,340
where you must have must build all of

00:21:45,540 --> 00:21:51,090
your stuff without accessing the

00:21:47,340 --> 00:21:53,460
internet we can enforce that this is a

00:21:51,090 --> 00:21:57,150
bit dry perhaps Aztek so let's let's

00:21:53,460 --> 00:21:59,760
look at a dependency demo so this is a

00:21:57,150 --> 00:22:02,280
simple program that uses Lua and it

00:21:59,760 --> 00:22:02,880
opens a bunch of PNG files so it depends

00:22:02,280 --> 00:22:05,880
on Lua

00:22:02,880 --> 00:22:11,220
with PNG and then the PNG depends on

00:22:05,880 --> 00:22:14,130
zealot and this is what it looks like so

00:22:11,220 --> 00:22:16,920
there's the the built a function file

00:22:14,130 --> 00:22:18,420
and there's a singles so see source file

00:22:16,920 --> 00:22:20,860
and then this is our projects folder

00:22:18,420 --> 00:22:24,260
which we look into a bit later

00:22:20,860 --> 00:22:26,090
so if we count the build file it looks

00:22:24,260 --> 00:22:27,710
like this so basicly just define the

00:22:26,090 --> 00:22:30,200
project and then you say that you have

00:22:27,710 --> 00:22:32,900
these dependencies which are lower and

00:22:30,200 --> 00:22:35,780
lead PNG and the fallback says that that

00:22:32,900 --> 00:22:38,180
where the the fallback dependency is so

00:22:35,780 --> 00:22:42,770
that's in the sub project called Lua or

00:22:38,180 --> 00:22:44,930
leap PNG then we just say I want to

00:22:42,770 --> 00:22:48,680
build an executable and then these are

00:22:44,930 --> 00:22:50,450
the dependencies that I have so and then

00:22:48,680 --> 00:22:53,780
the sub project folder looks like this

00:22:50,450 --> 00:22:57,800
and it only has is these three files

00:22:53,780 --> 00:23:00,080
which are called rap files and if we

00:22:57,800 --> 00:23:02,630
kept one of those then it looks like

00:23:00,080 --> 00:23:04,150
this basically it's just a URL file for

00:23:02,630 --> 00:23:08,120
where you download the source files and

00:23:04,150 --> 00:23:10,100
the the highest hash code for verifying

00:23:08,120 --> 00:23:13,700
that they're actually the real thing

00:23:10,100 --> 00:23:15,200
they haven't been a mighty amount so

00:23:13,700 --> 00:23:17,540
there's the source file and Ernest the

00:23:15,200 --> 00:23:19,280
patch file which in this case at the

00:23:17,540 --> 00:23:23,020
mess and L definitions because the

00:23:19,280 --> 00:23:26,720
original project doesn't have them and

00:23:23,020 --> 00:23:28,130
then you start run the configuring step

00:23:26,720 --> 00:23:31,040
that's what it looks like legacy

00:23:28,130 --> 00:23:32,420
downloads lead paint G and it downloads

00:23:31,040 --> 00:23:35,690
the patch and it does all the patching

00:23:32,420 --> 00:23:38,210
and as you can tell it says native

00:23:35,690 --> 00:23:40,700
dependencies that Lib found yes so in

00:23:38,210 --> 00:23:42,680
this case that was available in the

00:23:40,700 --> 00:23:44,390
system so it doesn't download and build

00:23:42,680 --> 00:23:48,980
it itself it just uses the system one

00:23:44,390 --> 00:23:51,880
and then if you can pilot then it looks

00:23:48,980 --> 00:23:54,890
like this and then there's 39

00:23:51,880 --> 00:23:58,100
compilation steps for you early PNG

00:23:54,890 --> 00:24:00,770
settle and this executable and and

00:23:58,100 --> 00:24:03,380
that's it and this now works works on

00:24:00,770 --> 00:24:04,490
all the platforms where the Lib PNG and

00:24:03,380 --> 00:24:08,840
zealot and Lua

00:24:04,490 --> 00:24:12,800
are available on and this is quite

00:24:08,840 --> 00:24:16,130
interesting in itself but what can we do

00:24:12,800 --> 00:24:19,640
with this so now we have the same with

00:24:16,130 --> 00:24:22,310
it's time we need to go deeper we need

00:24:19,640 --> 00:24:26,870
to all go all the way down and teve

00:24:22,310 --> 00:24:30,410
python section and ask the question can

00:24:26,870 --> 00:24:34,040
you compile C Python will itself

00:24:30,410 --> 00:24:35,960
let's find out here's a check out of a

00:24:34,040 --> 00:24:38,330
cpython repository which I took from the

00:24:35,960 --> 00:24:41,950
from the gig master some time ago and I

00:24:38,330 --> 00:24:45,170
wrote some of the bill definitions and

00:24:41,950 --> 00:24:50,000
the eysie running the methane command

00:24:45,170 --> 00:24:52,640
and it's on the configure so you get all

00:24:50,000 --> 00:24:56,290
the things in there I'll check the

00:24:52,640 --> 00:25:01,100
functions size of things all that and

00:24:56,290 --> 00:25:01,640
then you run the bill card which looks

00:25:01,100 --> 00:25:05,690
like this

00:25:01,640 --> 00:25:09,200
so you've spun 143 to compiler warnings

00:25:05,690 --> 00:25:10,490
and four compared to the stuff where you

00:25:09,200 --> 00:25:12,170
can in make this actually kind of nice

00:25:10,490 --> 00:25:14,330
because the only thing that is visible

00:25:12,170 --> 00:25:15,560
are the compiler warnings and it's not

00:25:14,330 --> 00:25:17,330
telling you that now I'm going in this

00:25:15,560 --> 00:25:19,070
directory I'm going in this route to I'm

00:25:17,330 --> 00:25:20,720
going this really I'm coming back and

00:25:19,070 --> 00:25:24,250
I'm going today and all of that goes

00:25:20,720 --> 00:25:27,470
away because you don't care what it is

00:25:24,250 --> 00:25:31,970
and then if you run the compiled poison

00:25:27,470 --> 00:25:36,770
with this H then you get the help output

00:25:31,970 --> 00:25:40,520
from the regular Python executable which

00:25:36,770 --> 00:25:42,820
is is kinda nice but compiling Python on

00:25:40,520 --> 00:25:46,250
Linux is not actually that difficult

00:25:42,820 --> 00:25:50,270
it's fairly straightforward so let's go

00:25:46,250 --> 00:25:53,000
deeper what about Windows so here's the

00:25:50,270 --> 00:25:57,380
screenshots of running on Windows 7 I

00:25:53,000 --> 00:25:58,880
think with Visual Studio the LibreOffice

00:25:57,380 --> 00:26:00,290
in this infinite wisdom has decided to

00:25:58,880 --> 00:26:02,930
scale this picture down for some reason

00:26:00,290 --> 00:26:05,320
so it's a bit blurry but there you can

00:26:02,930 --> 00:26:09,440
see it's running all the same tests and

00:26:05,320 --> 00:26:11,570
then if you run the compiled then you

00:26:09,440 --> 00:26:13,670
get this and this I don't know what

00:26:11,570 --> 00:26:16,780
those warnings are but they don't seem

00:26:13,670 --> 00:26:20,000
to matter and then if you try to run

00:26:16,780 --> 00:26:23,240
generated executable in the same way

00:26:20,000 --> 00:26:24,890
earlier then what you get is this error

00:26:23,240 --> 00:26:26,600
message which I don't know what it is

00:26:24,890 --> 00:26:27,920
because I don't really do much Windows

00:26:26,600 --> 00:26:31,730
development this is kind of complaining

00:26:27,920 --> 00:26:34,630
about some missing dll but ignoring that

00:26:31,730 --> 00:26:34,630
basically it works

00:26:35,770 --> 00:26:41,270
Atlee fixing the rest is left as an

00:26:38,360 --> 00:26:44,340
exercise to reader so let's look at the

00:26:41,270 --> 00:26:46,169
performance numbers of of this thing

00:26:44,340 --> 00:26:51,929
who in here knows how big the

00:26:46,169 --> 00:26:54,779
configuration file is in oh sorry long

00:26:51,929 --> 00:26:57,480
life so on my four-year-old by three

00:26:54,779 --> 00:26:59,669
eight seven seven with eight course the

00:26:57,480 --> 00:27:03,390
configured time on auto tools it takes

00:26:59,669 --> 00:27:05,610
13 seconds and with messing takes six

00:27:03,390 --> 00:27:08,220
seconds which is about 50% faster build

00:27:05,610 --> 00:27:10,760
time is 31 seconds which goes down 16

00:27:08,220 --> 00:27:13,940
which is again about 50 percent faster I

00:27:10,760 --> 00:27:16,320
also ran the test on Raspberry Pi 2 and

00:27:13,940 --> 00:27:18,630
configured time on that is 3 minutes and

00:27:16,320 --> 00:27:21,659
11 seconds and went to 132 point which

00:27:18,630 --> 00:27:25,139
again about 50% faster and the build

00:27:21,659 --> 00:27:28,200
time is from nine minutes to four and a

00:27:25,139 --> 00:27:31,830
half which is again about 50 percent so

00:27:28,200 --> 00:27:34,799
so 50% improvement overall it's is not

00:27:31,830 --> 00:27:37,470
entirely fair because it's not building

00:27:34,799 --> 00:27:41,490
all all the same things but it's roughly

00:27:37,470 --> 00:27:44,220
about the same so build definition

00:27:41,490 --> 00:27:47,610
sizing so how many of you here know how

00:27:44,220 --> 00:27:55,380
big configure a see is on Python any

00:27:47,610 --> 00:27:57,299
guesses anyone okay so the correct

00:27:55,380 --> 00:27:58,559
answer is that is four thousand five

00:27:57,299 --> 00:28:00,750
thousand four hundred and seventy seven

00:27:58,559 --> 00:28:02,309
lines and if you haven't read it I

00:28:00,750 --> 00:28:04,769
highly recommend that you do because

00:28:02,309 --> 00:28:07,380
it's it's both terrifying and all

00:28:04,769 --> 00:28:10,830
inspiring in the same exactly the same

00:28:07,380 --> 00:28:12,299
time it has still support for stuff you

00:28:10,830 --> 00:28:13,950
didn't even know existed and it's

00:28:12,299 --> 00:28:17,159
probably older than most people in the

00:28:13,950 --> 00:28:19,799
room and in addition to that there's the

00:28:17,159 --> 00:28:23,159
make 4.3 adults in which as you can tell

00:28:19,799 --> 00:28:25,799
is twice templated and that's 1,700

00:28:23,159 --> 00:28:29,100
lines and there's some make falls in the

00:28:25,799 --> 00:28:31,679
subgroups but I didn't tell those so in

00:28:29,100 --> 00:28:37,820
comparison the messin bill for the same

00:28:31,679 --> 00:28:40,919
is 629 lines which is like slightly less

00:28:37,820 --> 00:28:43,679
this only includes building the core and

00:28:40,919 --> 00:28:46,350
the essential modules that are parts and

00:28:43,679 --> 00:28:49,049
this has only been tested on Linux with

00:28:46,350 --> 00:28:52,289
GCC and windows on Visual Studio so this

00:28:49,049 --> 00:28:55,200
probably needs needs some work on some

00:28:52,289 --> 00:28:56,760
other ones but on the other hand we

00:28:55,200 --> 00:28:59,310
still have about 6,000

00:28:56,760 --> 00:29:01,710
spare until we reach the same same

00:28:59,310 --> 00:29:03,570
amount of codes that's the first one so

00:29:01,710 --> 00:29:08,490
I'm fairly confident with that

00:29:03,570 --> 00:29:13,260
that's it achievable all right

00:29:08,490 --> 00:29:15,390
but can we go deeper so here's something

00:29:13,260 --> 00:29:17,280
that I thought up as far as I can tell

00:29:15,390 --> 00:29:20,280
this is currently not possible but it's

00:29:17,280 --> 00:29:23,910
it's completely feasible to do so what

00:29:20,280 --> 00:29:27,180
if you're fighting compilation when

00:29:23,910 --> 00:29:31,070
something like this so if you compile

00:29:27,180 --> 00:29:34,800
another court code to compile the parser

00:29:31,070 --> 00:29:36,840
right and then you compile the standard

00:29:34,800 --> 00:29:42,300
library that you have from PI Pio files

00:29:36,840 --> 00:29:44,850
to py C files and then using a fairly

00:29:42,300 --> 00:29:49,800
simple script you can pile those Piz

00:29:44,850 --> 00:29:51,990
files into C libraries at C erase so a C

00:29:49,800 --> 00:29:56,490
file and update file listing those

00:29:51,990 --> 00:29:58,740
things right and then you compile the

00:29:56,490 --> 00:30:02,100
rest of the Python and all the rest of

00:29:58,740 --> 00:30:04,830
your application that you want and then

00:30:02,100 --> 00:30:06,780
you link the Python core plus the

00:30:04,830 --> 00:30:09,720
modules plus the standard library that

00:30:06,780 --> 00:30:14,100
you've built C arrays statically and

00:30:09,720 --> 00:30:17,310
this gives you a fully self-contained

00:30:14,100 --> 00:30:19,080
program exe and you can run it and

00:30:17,310 --> 00:30:20,970
doesn't need to unpack anything it

00:30:19,080 --> 00:30:23,490
doesn't need any file system access or

00:30:20,970 --> 00:30:25,200
anything it there's no possible way that

00:30:23,490 --> 00:30:28,950
you can read the wrong Pui C files

00:30:25,200 --> 00:30:32,910
because it only exit access to them that

00:30:28,950 --> 00:30:35,900
are inside your own executable so this

00:30:32,910 --> 00:30:39,090
would be a sub projectable Python and

00:30:35,900 --> 00:30:41,370
the things that you can do would be it's

00:30:39,090 --> 00:30:43,200
basically like freeze or PI to exe or

00:30:41,370 --> 00:30:45,870
this is C make Python which is a bit

00:30:43,200 --> 00:30:48,720
like this but if you have it inside the

00:30:45,870 --> 00:30:51,570
build system and it's inside the the

00:30:48,720 --> 00:30:53,130
core build of the language itself then

00:30:51,570 --> 00:30:56,820
it works on all platforms and all the

00:30:53,130 --> 00:30:59,790
use cases out of the box then you can

00:30:56,820 --> 00:31:02,190
create cross-platform applications where

00:30:59,790 --> 00:31:04,050
you embed Python because it's just one

00:31:02,190 --> 00:31:08,090
dependency and just compile it in and

00:31:04,050 --> 00:31:08,090
call it an and stuff starts happening

00:31:08,250 --> 00:31:14,490
and you can ship actual Exe files and

00:31:11,900 --> 00:31:17,790
there's no file expansion circus anymore

00:31:14,490 --> 00:31:19,380
one of the biggest pain points in the

00:31:17,790 --> 00:31:22,200
cross-platform development envision that

00:31:19,380 --> 00:31:25,650
we had is the shebang line because on

00:31:22,200 --> 00:31:27,300
Windows you must have the GUI extension

00:31:25,650 --> 00:31:29,400
because otherwise it doesn't work on

00:31:27,300 --> 00:31:31,620
other platforms you mustn't have them

00:31:29,400 --> 00:31:34,410
because that's the district will say you

00:31:31,620 --> 00:31:36,990
can't have that somewhere the user being

00:31:34,410 --> 00:31:40,500
Python points to Python 2 so it points

00:31:36,990 --> 00:31:42,930
to PI by 3 and and it's like it's in its

00:31:40,500 --> 00:31:46,200
enormous mess and if the Python exe

00:31:42,930 --> 00:31:50,520
itself goes away then all of these

00:31:46,200 --> 00:31:52,710
problems go away as well your

00:31:50,520 --> 00:31:54,090
application don't require python to be

00:31:52,710 --> 00:31:56,250
pre-installed on windows this is

00:31:54,090 --> 00:31:58,050
especially a good thing and they don't

00:31:56,250 --> 00:32:00,690
try to use the wrong version by accident

00:31:58,050 --> 00:32:01,800
you don't get weird symbol angle

00:32:00,690 --> 00:32:03,450
anything look elsewhere some of the

00:32:01,800 --> 00:32:06,660
symbols come from this PLL some come

00:32:03,450 --> 00:32:09,930
from that one and then you can combine

00:32:06,660 --> 00:32:12,620
this with g-d cave or would be where

00:32:09,930 --> 00:32:15,690
which is a great project for creating a

00:32:12,620 --> 00:32:17,640
multi-platform GUI application and then

00:32:15,690 --> 00:32:19,500
you can ship all the platform GUI

00:32:17,640 --> 00:32:21,930
applications which you can pile from

00:32:19,500 --> 00:32:24,090
your own source into like full

00:32:21,930 --> 00:32:25,710
executables and just ship them and your

00:32:24,090 --> 00:32:29,220
users don't have to think about any of

00:32:25,710 --> 00:32:31,530
that going on further so there was a

00:32:29,220 --> 00:32:33,930
presentation by I think just triplets

00:32:31,530 --> 00:32:36,090
how they're using Python where they

00:32:33,930 --> 00:32:37,890
compile and they boot directly into ufi

00:32:36,090 --> 00:32:40,020
well you can do that you can have bare

00:32:37,890 --> 00:32:42,660
metal support inside the Python so

00:32:40,020 --> 00:32:44,700
Python will be sort of like a micro less

00:32:42,660 --> 00:32:45,930
micro Python way if you have a plug

00:32:44,700 --> 00:32:48,540
slightly bigger thing and you want to

00:32:45,930 --> 00:32:52,320
control it completely from Python go

00:32:48,540 --> 00:32:54,420
ahead you can do that and if there are

00:32:52,320 --> 00:32:56,490
people who run containers then you can

00:32:54,420 --> 00:32:58,560
do stuff like tell your Linux kernel and

00:32:56,490 --> 00:33:01,110
you're the only process that's it on the

00:32:58,560 --> 00:33:03,510
system is the Python processes as the

00:33:01,110 --> 00:33:05,190
single process you launch that and this

00:33:03,510 --> 00:33:09,360
has interesting implications because

00:33:05,190 --> 00:33:11,610
most exploits in the world try to open

00:33:09,360 --> 00:33:13,710
the shell on the target machine if your

00:33:11,610 --> 00:33:15,810
system doesn't have a shell at all all

00:33:13,710 --> 00:33:18,990
of these things stopped working which is

00:33:15,810 --> 00:33:20,429
come nice and and there's also like sort

00:33:18,990 --> 00:33:21,620
of scale things that you can do because

00:33:20,429 --> 00:33:24,170
you don't have

00:33:21,620 --> 00:33:31,780
your images that you launched are very

00:33:24,170 --> 00:33:31,780
small so winding down so in conclusion

00:33:31,990 --> 00:33:36,830
pointing is set to become a core

00:33:34,640 --> 00:33:38,870
dependency for significant fraction of

00:33:36,830 --> 00:33:42,380
the Louisville and currently it hasn't

00:33:38,870 --> 00:33:46,000
been they have been using make and shell

00:33:42,380 --> 00:33:49,250
and oak and TR and set and all of those

00:33:46,000 --> 00:33:52,370
wonderful tools that we know and some

00:33:49,250 --> 00:33:54,140
love but which ours is complete

00:33:52,370 --> 00:33:57,170
maintenance nightmare so those are all

00:33:54,140 --> 00:34:01,220
going to go away eventually which is

00:33:57,170 --> 00:34:02,929
which is nice and one of the main things

00:34:01,220 --> 00:34:05,870
that comes from this is that everything

00:34:02,929 --> 00:34:08,000
will become faster so for those who

00:34:05,870 --> 00:34:10,550
don't know if you run a shell script and

00:34:08,000 --> 00:34:12,110
you do a string comparison what it

00:34:10,550 --> 00:34:14,810
actually does is that it spawns a new

00:34:12,110 --> 00:34:17,690
process every time you compare two

00:34:14,810 --> 00:34:20,780
strings and especially on Windows with

00:34:17,690 --> 00:34:23,210
the process spawning is slow then this

00:34:20,780 --> 00:34:27,280
like just being able to do in process

00:34:23,210 --> 00:34:30,200
string comparisons is a massive game and

00:34:27,280 --> 00:34:32,060
if we have these new sorts of tools or

00:34:30,200 --> 00:34:34,310
with with news of things and new things

00:34:32,060 --> 00:34:38,090
become possible some of which we

00:34:34,310 --> 00:34:39,919
probably don't even realize yet and so

00:34:38,090 --> 00:34:41,990
coming back to the original question was

00:34:39,919 --> 00:34:45,679
that all build systems are terrible and

00:34:41,990 --> 00:34:47,330
why should I care so in conclusion what

00:34:45,679 --> 00:34:49,129
I would like to say is that the reason

00:34:47,330 --> 00:34:51,010
you should care is because some build

00:34:49,129 --> 00:34:53,750
systems are actually fun next setting

00:34:51,010 --> 00:34:55,929
this has been my talk and keep an open

00:34:53,750 --> 00:35:02,029
for questions

00:34:55,929 --> 00:35:02,029
[Applause]

00:35:03,050 --> 00:35:15,359
we are the question nobody is

00:35:07,619 --> 00:35:18,960
- yeah is this a free thing you

00:35:15,359 --> 00:35:24,060
mentioned just an idea or some actual

00:35:18,960 --> 00:35:34,109
project we can look at so the oh is this

00:35:24,060 --> 00:35:37,109
microphone on okay okay so this one so

00:35:34,109 --> 00:35:43,020
this is not at the moment

00:35:37,109 --> 00:35:45,090
done it's a seller it could be done in

00:35:43,020 --> 00:35:46,859
in theory by someone else which is how

00:35:45,090 --> 00:35:48,990
these things always go but there's

00:35:46,859 --> 00:35:50,250
nothing like inherently difficult about

00:35:48,990 --> 00:35:53,190
this it's just work that needs to be

00:35:50,250 --> 00:35:55,650
done so like you need a example if you

00:35:53,190 --> 00:35:58,050
I'm don't I'm not entirely sure if the

00:35:55,650 --> 00:36:00,150
in Python modules the entry point is

00:35:58,050 --> 00:36:02,010
always named the same if it is then

00:36:00,150 --> 00:36:05,130
obviously you can't because all of the

00:36:02,010 --> 00:36:07,650
things go in the same same executable so

00:36:05,130 --> 00:36:10,170
they have to have unique names but as an

00:36:07,650 --> 00:36:13,200
example the gstreamer multimedia

00:36:10,170 --> 00:36:15,450
framework which is like 150 plugins they

00:36:13,200 --> 00:36:17,910
have all the macro magic necessary so if

00:36:15,450 --> 00:36:19,290
you're compiling dynamically shared

00:36:17,910 --> 00:36:21,570
libraries then they all get the same

00:36:19,290 --> 00:36:23,040
name and if your component and

00:36:21,570 --> 00:36:24,570
statically they may get unique names and

00:36:23,040 --> 00:36:26,550
something like this would need to be

00:36:24,570 --> 00:36:29,070
done if there are duplicated symbols but

00:36:26,550 --> 00:36:31,760
I'm not aware the like actual details of

00:36:29,070 --> 00:36:31,760
this possible

00:36:35,370 --> 00:36:42,120
thank you very much for your talk I'm

00:36:38,010 --> 00:36:46,890
curious how you make sure that Mason is

00:36:42,120 --> 00:36:50,310
still fast when you make a change so

00:36:46,890 --> 00:36:53,180
Kara I said we have the the testing

00:36:50,310 --> 00:36:56,520
framework which is in place and the

00:36:53,180 --> 00:36:58,140
biggest so currently when we run CI it

00:36:56,520 --> 00:37:00,360
takes quite a long time

00:36:58,140 --> 00:37:03,240
so if it gets lower we will definitely

00:37:00,360 --> 00:37:04,860
notice it quite quite quickly in fact

00:37:03,240 --> 00:37:07,860
and one of the biggest problems that we

00:37:04,860 --> 00:37:09,660
currently have is that due to some bugs

00:37:07,860 --> 00:37:13,320
in other parts of the things we have to

00:37:09,660 --> 00:37:15,210
do things a bit slower but only in CI in

00:37:13,320 --> 00:37:17,130
in regular use it doesn't matter is not

00:37:15,210 --> 00:37:19,230
an issue that comes up but for CI we

00:37:17,130 --> 00:37:22,710
have to do some budgeting and because of

00:37:19,230 --> 00:37:26,280
that it's like to work slower but but

00:37:22,710 --> 00:37:27,540
it's still feel pretty fast and we're

00:37:26,280 --> 00:37:29,760
very much counting on the fact that

00:37:27,540 --> 00:37:31,530
people are running building their stuff

00:37:29,760 --> 00:37:33,150
against missing master and if we get

00:37:31,530 --> 00:37:37,670
slower they fly sailing and then we'll

00:37:33,150 --> 00:37:37,670
fix it okay great thank you very much

00:37:37,760 --> 00:37:45,470
you have an ED another question

00:37:40,590 --> 00:37:48,330
ah yes great so you talked about

00:37:45,470 --> 00:37:51,480
compiling for for Windows for Mac OS X

00:37:48,330 --> 00:37:53,640
and so on it's on consider I have to

00:37:51,480 --> 00:37:58,790
build a product and it's an embedded

00:37:53,640 --> 00:38:02,930
product and I have some microcontroller

00:37:58,790 --> 00:38:07,020
can I use mass onto to work with some

00:38:02,930 --> 00:38:10,770
not yet known compiler and would you

00:38:07,020 --> 00:38:13,530
recommend it so currently we only

00:38:10,770 --> 00:38:17,280
support the compiler there so that's GCC

00:38:13,530 --> 00:38:19,170
clang ICC and then like 10 different

00:38:17,280 --> 00:38:22,920
Fortran compilers which some guy

00:38:19,170 --> 00:38:25,080
contributed and we don't you can compile

00:38:22,920 --> 00:38:26,820
on a compiler that's not specifically

00:38:25,080 --> 00:38:30,210
support because we need to know how you

00:38:26,820 --> 00:38:32,610
run that but if you want to add this we

00:38:30,210 --> 00:38:34,560
are open for patches will of patches if

00:38:32,610 --> 00:38:35,370
you if you send in and it's not actually

00:38:34,560 --> 00:38:39,510
that difficult

00:38:35,370 --> 00:38:41,910
so the the language support for D was

00:38:39,510 --> 00:38:44,610
added by one guy who had never seen the

00:38:41,910 --> 00:38:48,810
code base before in about two days and

00:38:44,610 --> 00:38:49,230
just adding a C compiler an existing so

00:38:48,810 --> 00:38:50,940
you comply

00:38:49,230 --> 00:38:57,170
I would probably not be that much of a

00:38:50,940 --> 00:39:00,690
job so that means that you have

00:38:57,170 --> 00:39:06,560
predefined rules for compiling what if I

00:39:00,690 --> 00:39:11,250
in a project I want to have my dedicated

00:39:06,560 --> 00:39:14,340
options so I want to change optimization

00:39:11,250 --> 00:39:16,980
levels and per what else is possible is

00:39:14,340 --> 00:39:19,380
that is it possible with meson or is it

00:39:16,980 --> 00:39:21,960
impossible because the rules are already

00:39:19,380 --> 00:39:26,369
closed so what we do is that this

00:39:21,960 --> 00:39:30,030
predefined target builds ation types so

00:39:26,369 --> 00:39:32,550
there's just debug this optimized for

00:39:30,030 --> 00:39:35,430
speed release and minimum size and then

00:39:32,550 --> 00:39:37,760
there's the nothing at all and then you

00:39:35,430 --> 00:39:40,109
can specify your own compiler flags and

00:39:37,760 --> 00:39:41,520
we just use those and we don't use any

00:39:40,109 --> 00:39:43,910
of our own so if you want to override

00:39:41,520 --> 00:39:48,770
that's fine

00:39:43,910 --> 00:39:51,750
another question No thank you so much

00:39:48,770 --> 00:39:56,520
the next talk will be done by Nikola

00:39:51,750 --> 00:39:58,970
lithography in some minutes all right

00:39:56,520 --> 00:39:58,970

YouTube URL: https://www.youtube.com/watch?v=sEO4DC8hm34


