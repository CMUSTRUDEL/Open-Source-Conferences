Title: Alex Martelli - Testing in Layers
Publication date: 2017-09-17
Playlist: EuroPython 2017
Description: 
	"Testing in Layers
[EuroPython 2017 - Talk - 2017-07-10 - PythonAnywhere Room]
[Rimini, Italy]

The role of automated testing at the heart of modern development and operations is a given. However, the traditional approach to testing, separating too-developer-focused unit testing and (often only semi-automated) end-to-end integration testing—is not optimal in the modern, fluid world of DevOps.

Nothing short of full automation is suitable for continuous integration; any “testing” requiring humans has a drastically different place in the continuum of development and deployment and should best be called by a completely different name like quality assurance. Within the realm of fully automated testing, the best approach, just as for other kinds of software, is modular and layered.

This talk highlights the proper design of components for testing purposes and explains how such a design lets you compose multiple, layered testing suites that span the gamut from fast, light-weight unit tests meant to run all the time during development, to full-fledged end-to-end tests of whole systems—and, crucially, the often-neglected intermediate layers, bridging the thoroughness of end-to-end tests with unit tests’ speed and ability to pinpoint the location of any problems that emerge, enabling rapid fixes of most such problems.

The talk also discusses the use of modular, layered testing components to validate software refactoring, and (when deployed in a load-testing arrangement) identify and validate software (and architectural) optimizations.

License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2017.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:04,570 --> 00:00:12,600
and Alex / Kelly you may know me I'm

00:00:07,500 --> 00:00:12,600
best known as the order of Python Nina

00:00:14,850 --> 00:00:20,260
okay I'm apologies in advance if the

00:00:18,670 --> 00:00:21,939
presentation is not up to my usual

00:00:20,260 --> 00:00:25,840
standards that I'm not used to being

00:00:21,939 --> 00:00:30,400
chained in one spot and Walker but there

00:00:25,840 --> 00:00:32,290
is no moving like as I said probably

00:00:30,400 --> 00:00:36,000
there's known for Python in a nutshell

00:00:32,290 --> 00:00:39,910
the third edition is just out cold with

00:00:36,000 --> 00:00:43,690
my wife Anna Martelli Ravenscroft and

00:00:39,910 --> 00:00:45,370
Steve Holden used to be the organizers

00:00:43,690 --> 00:00:48,789
of the very first icon but this is

00:00:45,370 --> 00:00:52,260
outside what I cover in Python a

00:00:48,789 --> 00:00:55,239
nutshell actually I would say they

00:00:52,260 --> 00:00:58,420
Python here is only used for examples

00:00:55,239 --> 00:01:01,120
and what I'm trying to show is just

00:00:58,420 --> 00:01:03,879
about as useful in any programming

00:01:01,120 --> 00:01:05,230
language you may be using because in any

00:01:03,879 --> 00:01:07,360
programming language the typical

00:01:05,230 --> 00:01:10,570
software system can be seen as a

00:01:07,360 --> 00:01:14,650
directed acyclic graph in which there's

00:01:10,570 --> 00:01:17,460
a lower layer of modules or services or

00:01:14,650 --> 00:01:19,900
components called them as you will that

00:01:17,460 --> 00:01:21,850
provides some functionality but don't

00:01:19,900 --> 00:01:26,340
depend on any other that you've written

00:01:21,850 --> 00:01:29,680
they may be interfacing external

00:01:26,340 --> 00:01:32,380
entities of course like a database and a

00:01:29,680 --> 00:01:35,890
domain name system in this example

00:01:32,380 --> 00:01:38,020
there's middle layers which both depend

00:01:35,890 --> 00:01:42,009
on some modules are not dependent upon

00:01:38,020 --> 00:01:45,180
and there's top layers that are not

00:01:42,009 --> 00:01:49,030
depended on that depend on any other

00:01:45,180 --> 00:01:53,670
subsystem so as long as you don't have

00:01:49,030 --> 00:01:56,799
any cycle in your directed graph any

00:01:53,670 --> 00:01:59,350
directed acyclic graph can have its node

00:01:56,799 --> 00:02:02,950
classified in these if you do have

00:01:59,350 --> 00:02:07,600
cycles you have far bigger problems then

00:02:02,950 --> 00:02:13,030
I can hope to address because the point

00:02:07,600 --> 00:02:16,270
is the arrows are dependencies if you

00:02:13,030 --> 00:02:17,560
have a cycle it means a depends on V and

00:02:16,270 --> 00:02:20,709
B depends on a

00:02:17,560 --> 00:02:23,620
you're in hell and just completely

00:02:20,709 --> 00:02:25,989
refactor everything break the dependency

00:02:23,620 --> 00:02:28,030
cycle that's much more important than

00:02:25,989 --> 00:02:31,150
anything else I or anybody else can

00:02:28,030 --> 00:02:33,370
teach you so leave the conference and go

00:02:31,150 --> 00:02:35,590
do that and break your dependency cycles

00:02:33,370 --> 00:02:38,170
it's really really you want to do that

00:02:35,590 --> 00:02:41,980
if you don't have dependency cycles this

00:02:38,170 --> 00:02:45,160
will always hold I've had some questions

00:02:41,980 --> 00:02:49,060
about why multiple top layers well duh

00:02:45,160 --> 00:02:54,280
it is 2017 I'm told so of course you

00:02:49,060 --> 00:02:57,730
will have an API and a web interface and

00:02:54,280 --> 00:03:00,160
perhaps a local graphical user interface

00:02:57,730 --> 00:03:02,530
and a local command-line interface so

00:03:00,160 --> 00:03:04,510
you will have multiple top level I

00:03:02,530 --> 00:03:08,260
certainly hope so if your system is

00:03:04,510 --> 00:03:11,140
written complicated enough so the next

00:03:08,260 --> 00:03:14,290
issue is okay so we have that thing why

00:03:11,140 --> 00:03:18,849
do we test it okay unfortunately in 45

00:03:14,290 --> 00:03:20,850
minutes I cannot I cannot compress a few

00:03:18,849 --> 00:03:23,440
hours worth of explanation of why

00:03:20,850 --> 00:03:26,829
testing is the crucial discipline in

00:03:23,440 --> 00:03:30,640
software development and I would

00:03:26,829 --> 00:03:33,190
recommend you go online find any other

00:03:30,640 --> 00:03:36,040
talk I've ever given and most other

00:03:33,190 --> 00:03:38,170
talks given by other people and get

00:03:36,040 --> 00:03:40,810
those to understand why you really want

00:03:38,170 --> 00:03:44,260
what you really have to test we won't be

00:03:40,810 --> 00:03:51,130
covering them today what I'm covering

00:03:44,260 --> 00:03:55,920
here is the how not not play why but the

00:03:51,130 --> 00:04:00,010
how the most antique traditional form of

00:03:55,920 --> 00:04:02,170
testing distinguish test into white box

00:04:00,010 --> 00:04:04,269
meaning tests that are written in full

00:04:02,170 --> 00:04:06,579
knowledge of what's inside the

00:04:04,269 --> 00:04:09,989
components being tested and black box

00:04:06,579 --> 00:04:14,799
which is supposed to only use the

00:04:09,989 --> 00:04:18,100
external connections made available by

00:04:14,799 --> 00:04:19,780
the components that has been dropped

00:04:18,100 --> 00:04:25,900
since a long time

00:04:19,780 --> 00:04:29,560
in professional practice it's not a very

00:04:25,900 --> 00:04:31,000
useful distinction however what how we

00:04:29,560 --> 00:04:35,070
do things in the

00:04:31,000 --> 00:04:39,300
modern way looks like the old way with

00:04:35,070 --> 00:04:42,400
new names and it's not much more useful

00:04:39,300 --> 00:04:44,980
we nowadays tend to have unit tests

00:04:42,400 --> 00:04:47,110
which are really white boxy typically

00:04:44,980 --> 00:04:50,440
looking a lot inside the components

00:04:47,110 --> 00:04:54,640
they're testing and they're written by

00:04:50,440 --> 00:04:56,680
developers for developers just to ease

00:04:54,640 --> 00:04:59,020
development nothing wrong with that but

00:04:56,680 --> 00:05:01,540
that's like one extreme and then we only

00:04:59,020 --> 00:05:04,150
have the other extreme integration tests

00:05:01,540 --> 00:05:08,169
which are end to end so they do have to

00:05:04,150 --> 00:05:10,680
go from soup to nuts I think is a

00:05:08,169 --> 00:05:15,610
British expression for a complete meal

00:05:10,680 --> 00:05:18,100
and it will often have stuff that cannot

00:05:15,610 --> 00:05:20,770
really be automated and therefore need a

00:05:18,100 --> 00:05:23,050
human being in the loop if you need a

00:05:20,770 --> 00:05:25,590
human being in the loop by my lights you

00:05:23,050 --> 00:05:27,820
don't really have a test you have a

00:05:25,590 --> 00:05:30,550
separate step of your software

00:05:27,820 --> 00:05:32,470
development and delivery cycle which I

00:05:30,550 --> 00:05:34,570
like to call quality assurance use a

00:05:32,470 --> 00:05:37,270
different term than testing because for

00:05:34,570 --> 00:05:40,030
my point of view testing has to be

00:05:37,270 --> 00:05:42,640
automated so for a complete end-to-end

00:05:40,030 --> 00:05:46,030
thing you can automate tests when the

00:05:42,640 --> 00:05:50,110
top unit is an API a command-line

00:05:46,030 --> 00:05:53,850
interface a web page using selenium and

00:05:50,110 --> 00:05:57,190
similar tools if it's a graphical unic

00:05:53,850 --> 00:05:59,830
interface running locally there are some

00:05:57,190 --> 00:06:01,960
tricks to do that but you'll never do it

00:05:59,830 --> 00:06:05,490
right and meanwhile what about all the

00:06:01,960 --> 00:06:09,850
other things we'd like to automate and

00:06:05,490 --> 00:06:12,479
we'd like to use in a continuous

00:06:09,850 --> 00:06:15,250
integration environment so that

00:06:12,479 --> 00:06:17,979
something gets fully integrated and

00:06:15,250 --> 00:06:21,490
released and deployed only when all

00:06:17,979 --> 00:06:24,070
tests pass if there have to be human in

00:06:21,490 --> 00:06:27,100
the testing group you just can do that

00:06:24,070 --> 00:06:30,250
humans are unreliable not not repeatable

00:06:27,100 --> 00:06:32,410
very bad at mechanically repeating a

00:06:30,250 --> 00:06:35,110
series of operation very slow very

00:06:32,410 --> 00:06:38,020
costly there's a million reasons you

00:06:35,110 --> 00:06:41,530
must not have humans in the loop of

00:06:38,020 --> 00:06:42,870
testing I have a completely different

00:06:41,530 --> 00:06:50,449
proposal

00:06:42,870 --> 00:06:53,490
we have a software system composed of

00:06:50,449 --> 00:06:55,590
components modules services micro

00:06:53,490 --> 00:06:57,690
services but nowadays whatever doesn't

00:06:55,590 --> 00:07:01,620
matter all the dependencies are all

00:06:57,690 --> 00:07:03,479
we're looking at which naturally forms

00:07:01,620 --> 00:07:09,240
layers why not

00:07:03,479 --> 00:07:11,400
structure our tests in the same way we

00:07:09,240 --> 00:07:14,220
inevitably naturally structure our

00:07:11,400 --> 00:07:16,970
software assuming we make it modular at

00:07:14,220 --> 00:07:21,440
all as opposed to one big million line

00:07:16,970 --> 00:07:26,940
program which I hope none of us would do

00:07:21,440 --> 00:07:29,880
in this view then of course we have unit

00:07:26,940 --> 00:07:32,460
tests they have to be very fast because

00:07:29,880 --> 00:07:35,340
running all the time they focus strictly

00:07:32,460 --> 00:07:38,820
on a components or module or service

00:07:35,340 --> 00:07:42,150
internal logic so that at the limit you

00:07:38,820 --> 00:07:43,650
can mock out every dependency I think

00:07:42,150 --> 00:07:45,900
they need to be fast

00:07:43,650 --> 00:07:49,229
essentially above all it's the top

00:07:45,900 --> 00:07:53,130
priority for your unit test is make them

00:07:49,229 --> 00:07:56,460
fast then building upon that and we'll

00:07:53,130 --> 00:07:59,010
see how will have higher layer tests but

00:07:56,460 --> 00:08:01,380
not on a single big jump from unit test

00:07:59,010 --> 00:08:04,260
all the way to end-to-end takes forever

00:08:01,380 --> 00:08:07,500
tests will do layers and layers of

00:08:04,260 --> 00:08:11,669
testing as you'll see it you can see

00:08:07,500 --> 00:08:15,919
this as a pattern language of testing

00:08:11,669 --> 00:08:19,229
structures pattern languages are most

00:08:15,919 --> 00:08:21,720
understood in this community for design

00:08:19,229 --> 00:08:24,900
purposes but they also apply to a lot of

00:08:21,720 --> 00:08:27,090
other human creating creative activity

00:08:24,900 --> 00:08:29,160
and one of them is testing in a sense we

00:08:27,090 --> 00:08:33,510
are talking about how to design but also

00:08:29,160 --> 00:08:36,150
to execute the test sometimes I have I

00:08:33,510 --> 00:08:38,990
get interesting objections at this point

00:08:36,150 --> 00:08:41,490
about what you mean fast above all I

00:08:38,990 --> 00:08:44,370
think at faster when I'm doing

00:08:41,490 --> 00:08:47,490
production staff tests I don't need to

00:08:44,370 --> 00:08:49,410
be fast right yes you do in a modern

00:08:47,490 --> 00:08:51,780
developed integrated development

00:08:49,410 --> 00:08:53,610
arrangement your tests your unit tests

00:08:51,780 --> 00:08:56,070
should be running all the time in the

00:08:53,610 --> 00:08:56,670
background as the system sees you've

00:08:56,070 --> 00:08:59,580
saved

00:08:56,670 --> 00:09:02,580
some changes to a file it should reload

00:08:59,580 --> 00:09:05,190
that and every dependency that in every

00:09:02,580 --> 00:09:09,180
test that can be affected and rerun them

00:09:05,190 --> 00:09:11,100
all for you in this if that's the setup

00:09:09,180 --> 00:09:13,770
you have and I hope so because it really

00:09:11,100 --> 00:09:15,990
multiplies your productivity and just

00:09:13,770 --> 00:09:20,400
about any IDE is able to do that today

00:09:15,990 --> 00:09:22,830
if you have that and your test set of

00:09:20,400 --> 00:09:25,020
tests that as we modified it takes 10

00:09:22,830 --> 00:09:27,810
seconds to run then if there's any

00:09:25,020 --> 00:09:30,060
problem you're alerted within 10 seconds

00:09:27,810 --> 00:09:33,150
of saving the problematic code so you

00:09:30,060 --> 00:09:35,850
it's still top of your mind you can see

00:09:33,150 --> 00:09:38,880
the error and probably say that we are

00:09:35,850 --> 00:09:43,070
doc see immediately what you did wrong

00:09:38,880 --> 00:09:46,530
fix it and proceed if it's five minutes

00:09:43,070 --> 00:09:51,180
you've lost mental context you've moved

00:09:46,530 --> 00:09:54,410
on to another task you now need quite a

00:09:51,180 --> 00:09:57,360
bit of time to get back in your mind to

00:09:54,410 --> 00:10:00,630
what was I thinking when I wrote that

00:09:57,360 --> 00:10:03,840
and now you're losing all of it you've

00:10:00,630 --> 00:10:05,670
done after seriously an order of

00:10:03,840 --> 00:10:07,800
magnitude impact on your productivity

00:10:05,670 --> 00:10:10,890
because you didn't think that your test

00:10:07,800 --> 00:10:14,280
should be first of all fast fast fast

00:10:10,890 --> 00:10:16,740
oh but integration test certainly can

00:10:14,280 --> 00:10:20,340
afford to be slow well I have a very

00:10:16,740 --> 00:10:23,580
recent case study showing why not python

00:10:20,340 --> 00:10:27,750
361 reduce candidate 1 so what was it

00:10:23,580 --> 00:10:33,420
three months ago something like that the

00:10:27,750 --> 00:10:36,390
okay in the in the speaker notes I have

00:10:33,420 --> 00:10:38,550
the URL to the discussion on Python

00:10:36,390 --> 00:10:40,950
committers about what was going on

00:10:38,550 --> 00:10:46,250
essentially Brett cannon had to announce

00:10:40,950 --> 00:10:46,250
he had turned off the gating of

00:10:46,880 --> 00:10:53,580
integration tests on the continuous

00:10:49,680 --> 00:10:56,550
integration of 361 a release candidate

00:10:53,580 --> 00:10:58,980
one because they were taking forever

00:10:56,550 --> 00:11:03,420
so actually integrating a pool request

00:10:58,980 --> 00:11:04,860
was getting so slow that the releasing

00:11:03,420 --> 00:11:07,770
question would have probably come out

00:11:04,860 --> 00:11:11,040
around 2023 or something like that

00:11:07,770 --> 00:11:12,960
if your integration tests aren't fast

00:11:11,040 --> 00:11:15,870
enough you might as well not have them

00:11:12,960 --> 00:11:17,970
that's how important Trust is for your

00:11:15,870 --> 00:11:20,540
integration test okay there's a

00:11:17,970 --> 00:11:21,840
difference here because if you are

00:11:20,540 --> 00:11:25,140
well-funded

00:11:21,840 --> 00:11:26,580
rich have general sponsors you can be

00:11:25,140 --> 00:11:28,530
running your integration test on a

00:11:26,580 --> 00:11:31,050
million machines well million would be a

00:11:28,530 --> 00:11:33,750
bit of an overkill but on a lot of

00:11:31,050 --> 00:11:36,420
machines so as long as this lowest one

00:11:33,750 --> 00:11:39,710
is fast enough the others are running in

00:11:36,420 --> 00:11:42,510
parallel and everything is rosy most

00:11:39,710 --> 00:11:46,400
open-source projects don't have

00:11:42,510 --> 00:11:50,850
unlimited amounts of machines at hand so

00:11:46,400 --> 00:11:53,490
we get charity by trayvis or weather and

00:11:50,850 --> 00:11:56,750
we can use I don't know the exit number

00:11:53,490 --> 00:12:00,510
very clean notice has been such a

00:11:56,750 --> 00:12:03,780
sponsor such a release engineer release

00:12:00,510 --> 00:12:06,360
a captain for so many releases of Python

00:12:03,780 --> 00:12:10,260
but I think it's a single-digit number

00:12:06,360 --> 00:12:14,390
of observers not anywhere like enough so

00:12:10,260 --> 00:12:19,620
you need to be fast fast fast now

00:12:14,390 --> 00:12:22,440
everything that applies to other forms

00:12:19,620 --> 00:12:24,750
of automated testing still does I wish I

00:12:22,440 --> 00:12:26,640
had a couple more hours to recap

00:12:24,750 --> 00:12:31,110
everything a probably bore out of you

00:12:26,640 --> 00:12:34,860
but so the first thing is all tests must

00:12:31,110 --> 00:12:37,320
be reproducible that seems obvious but

00:12:34,860 --> 00:12:39,720
people keep running into problems one of

00:12:37,320 --> 00:12:42,630
them is oh and I have a human there you

00:12:39,720 --> 00:12:45,810
can get it out or it's not an automated

00:12:42,630 --> 00:12:50,100
test but one example but but my module

00:12:45,810 --> 00:12:53,810
uses random numbers well then make sure

00:12:50,100 --> 00:12:57,750
that you're able to inject a fixed seed

00:12:53,810 --> 00:13:01,050
so that your test will actually be doing

00:12:57,750 --> 00:13:03,000
the same sequence of random numbers the

00:13:01,050 --> 00:13:06,540
bear some delicacy there because maybe

00:13:03,000 --> 00:13:08,880
on some cases you're you're calling the

00:13:06,540 --> 00:13:11,640
regenerator five times and other paths

00:13:08,880 --> 00:13:15,060
seven times so they same seed may not

00:13:11,640 --> 00:13:16,740
actually get you if you are using random

00:13:15,060 --> 00:13:19,380
numbers that presumably you know love

00:13:16,740 --> 00:13:19,860
that and can ensure keep it under

00:13:19,380 --> 00:13:20,400
control

00:13:19,860 --> 00:13:24,030
maximal

00:13:20,400 --> 00:13:25,890
common oh but my coded or something

00:13:24,030 --> 00:13:29,330
different depending on what today of the

00:13:25,890 --> 00:13:32,820
week it is or what time update is

00:13:29,330 --> 00:13:35,850
because it needs to do something if it's

00:13:32,820 --> 00:13:38,040
between 9 a.m. and 5 p.m. Monday to

00:13:35,850 --> 00:13:43,440
Friday something different out of hours

00:13:38,040 --> 00:13:48,000
well great but then you have to somehow

00:13:43,440 --> 00:13:51,210
fake out the time and make sure to test

00:13:48,000 --> 00:13:54,000
both in this case to behavior so that

00:13:51,210 --> 00:13:57,030
your program should have in office hours

00:13:54,000 --> 00:13:59,400
and out out of hours because otherwise

00:13:57,030 --> 00:14:01,650
if you're just letting the time be

00:13:59,400 --> 00:14:03,750
whatever time you happen to run the test

00:14:01,650 --> 00:14:07,020
on that's essentially random because you

00:14:03,750 --> 00:14:10,250
may be running them anytime all the time

00:14:07,020 --> 00:14:13,280
and many other excellent mandatory

00:14:10,250 --> 00:14:17,190
quality of tests whether layered or not

00:14:13,280 --> 00:14:21,060
the fundamental things apply now let's

00:14:17,190 --> 00:14:22,860
start with some bit more concrete to

00:14:21,060 --> 00:14:29,250
show what I'm talking about how do we

00:14:22,860 --> 00:14:33,870
test this database adapter well the

00:14:29,250 --> 00:14:37,520
first maybe I'm just testing my own

00:14:33,870 --> 00:14:40,800
logic then all I need to do is a mark of

00:14:37,520 --> 00:14:43,740
the external DB component incidentally

00:14:40,800 --> 00:14:46,440
there's a beginners talk about marks

00:14:43,740 --> 00:14:48,240
this afternoon which unless you're

00:14:46,440 --> 00:14:52,050
completely familiar with them mocking

00:14:48,240 --> 00:14:56,540
and batching is highly recommended it's

00:14:52,050 --> 00:14:59,700
kind of a prerequisite of this talk but

00:14:56,540 --> 00:15:02,310
even getting it after is better than not

00:14:59,700 --> 00:15:06,180
getting it at all so mocking is fine as

00:15:02,310 --> 00:15:08,070
long as you are certain you understand a

00:15:06,180 --> 00:15:13,110
hundred percent of the behavior

00:15:08,070 --> 00:15:16,290
characteristics of that external DB but

00:15:13,110 --> 00:15:19,140
there's a second possibility which when

00:15:16,290 --> 00:15:23,300
feasible can often be better use a fake

00:15:19,140 --> 00:15:26,190
also known as an emulated form of DB

00:15:23,300 --> 00:15:28,620
that's local that's control local so

00:15:26,190 --> 00:15:32,790
don't you don't have to pay for network

00:15:28,620 --> 00:15:33,490
traffic they original down things it's

00:15:32,790 --> 00:15:35,830
totally and

00:15:33,490 --> 00:15:39,600
your controls will point out some

00:15:35,830 --> 00:15:42,610
details masonry because you don't need

00:15:39,600 --> 00:15:45,430
gigabytes and gigabytes for a test so

00:15:42,610 --> 00:15:49,750
you can make a smaller version but the

00:15:45,430 --> 00:15:52,779
crucial thing it must respect all the

00:15:49,750 --> 00:15:55,600
same semantic constraints as the real

00:15:52,779 --> 00:15:58,600
system you'll be running in production

00:15:55,600 --> 00:16:01,029
what's a semantic constrain a one

00:15:58,600 --> 00:16:05,830
example that's unfortunately common

00:16:01,029 --> 00:16:07,300
among various databases after close the

00:16:05,830 --> 00:16:11,050
close method has been called on a

00:16:07,300 --> 00:16:13,870
connection any other no other method

00:16:11,050 --> 00:16:14,920
must be : that connection if any other

00:16:13,870 --> 00:16:19,000
method is called

00:16:14,920 --> 00:16:22,990
then a runtime error will be raised if

00:16:19,000 --> 00:16:25,320
this is the way the real DB behaves then

00:16:22,990 --> 00:16:31,480
it's absolutely crucial that the fake

00:16:25,320 --> 00:16:33,970
emulate this behavior so it keeps track

00:16:31,480 --> 00:16:37,060
of whether the connections been closed

00:16:33,970 --> 00:16:39,850
and if it's been closed and some other

00:16:37,060 --> 00:16:44,649
method gets cold then BOOM it raises

00:16:39,850 --> 00:16:48,760
that exception a mock of course will not

00:16:44,649 --> 00:16:52,870
do that not naturally unless you know

00:16:48,760 --> 00:16:55,930
you have to specifically watch for it if

00:16:52,870 --> 00:16:59,079
you do specifically know make sure your

00:16:55,930 --> 00:17:01,120
mock does have that because other future

00:16:59,079 --> 00:17:04,420
maintenance of the code may miss that

00:17:01,120 --> 00:17:07,059
subtle semantic constraint and if your

00:17:04,420 --> 00:17:09,339
mock has dis completeness it will help

00:17:07,059 --> 00:17:13,179
but this is an example of a general

00:17:09,339 --> 00:17:17,980
problem of mocking mark you stuff that

00:17:13,179 --> 00:17:20,140
you write to help your testing reflect

00:17:17,980 --> 00:17:23,380
the same understanding of the external

00:17:20,140 --> 00:17:26,559
system that your code reflects if you

00:17:23,380 --> 00:17:28,449
understood that close must be the last

00:17:26,559 --> 00:17:31,420
method calling the connection then you

00:17:28,449 --> 00:17:33,850
won't call anymore in your code and your

00:17:31,420 --> 00:17:36,730
marker will check and give an error if

00:17:33,850 --> 00:17:39,429
you do but if you don't understand that

00:17:36,730 --> 00:17:43,630
they test will pass anyway because the

00:17:39,429 --> 00:17:46,970
mock will not do the check so the

00:17:43,630 --> 00:17:49,370
problem it's a there's a common mode of

00:17:46,970 --> 00:17:51,440
potential failure between the tests not

00:17:49,370 --> 00:17:58,010
catching something in your code having

00:17:51,440 --> 00:18:01,640
that defect the only real solution to

00:17:58,010 --> 00:18:03,409
that is the fake which we'll get to

00:18:01,640 --> 00:18:06,140
again and again there's another talk

00:18:03,409 --> 00:18:08,900
specifically about verified fakes which

00:18:06,140 --> 00:18:12,679
is strongly recommend okay

00:18:08,900 --> 00:18:14,539
incidentally our fake in addition to

00:18:12,679 --> 00:18:16,970
having to respect all the semantical

00:18:14,539 --> 00:18:19,909
strengths of the thing it's faking may

00:18:16,970 --> 00:18:22,340
add others it mostly be can example for

00:18:19,909 --> 00:18:25,460
something like a database the fake could

00:18:22,340 --> 00:18:28,520
say no more than 32 megabytes of data

00:18:25,460 --> 00:18:31,010
just because it's in memory and that

00:18:28,520 --> 00:18:34,580
will make it should be enough for

00:18:31,010 --> 00:18:38,960
testing now given this set of

00:18:34,580 --> 00:18:41,720
constraints set of approaches this is

00:18:38,960 --> 00:18:45,530
where I use Python for examples and I

00:18:41,720 --> 00:18:47,840
assume that the mock module has been

00:18:45,530 --> 00:18:50,510
taken from the unit test package I'm not

00:18:47,840 --> 00:18:53,090
going to repeat this line it applies to

00:18:50,510 --> 00:18:54,710
all my successive example I'm using

00:18:53,090 --> 00:18:56,780
knock first

00:18:54,710 --> 00:19:00,380
because mock patches are such a great

00:18:56,780 --> 00:19:02,570
way to temporarily substitute something

00:19:00,380 --> 00:19:05,960
for a real component and then take it

00:19:02,570 --> 00:19:07,850
out of way automatically I do that mock

00:19:05,960 --> 00:19:10,309
offers in unit tests bookmark offers

00:19:07,850 --> 00:19:13,159
many way to do it and I always use in

00:19:10,309 --> 00:19:17,090
this examples the with statement because

00:19:13,159 --> 00:19:19,549
it's such a natural way to say do this

00:19:17,090 --> 00:19:23,299
temporarily okay our end of the with

00:19:19,549 --> 00:19:27,020
block and do it or whatever so I'm

00:19:23,299 --> 00:19:30,770
mocking I'm using auto spec in the mock

00:19:27,020 --> 00:19:34,039
talk I believe prefers the spec set and

00:19:30,770 --> 00:19:36,890
other things these are specific to unit

00:19:34,039 --> 00:19:39,169
tests mock and well worth pondering and

00:19:36,890 --> 00:19:41,870
that's why I strongly recommend this

00:19:39,169 --> 00:19:44,990
afternoon's talk but essentially it

00:19:41,870 --> 00:19:48,860
makes it puts in place something that

00:19:44,990 --> 00:19:51,080
will emulate most anything and for the

00:19:48,860 --> 00:19:56,059
details of the behavior you said it's a

00:19:51,080 --> 00:19:58,520
side effect field in particular here I'm

00:19:56,059 --> 00:19:59,730
setting the side effect of the cursor of

00:19:58,520 --> 00:20:03,540
the connection

00:19:59,730 --> 00:20:07,740
of the fake database so I've TB connect

00:20:03,540 --> 00:20:11,150
cursor side effect and then the body of

00:20:07,740 --> 00:20:14,040
tests what's that we'll see but it is a

00:20:11,150 --> 00:20:16,710
big chunk of code presumably split into

00:20:14,040 --> 00:20:21,090
functions methods whatever which

00:20:16,710 --> 00:20:22,080
exercise every meaningful path of the

00:20:21,090 --> 00:20:24,660
application code

00:20:22,080 --> 00:20:28,590
well the of the code I own the code I

00:20:24,660 --> 00:20:31,950
write now if what I'm doing is a second

00:20:28,590 --> 00:20:35,940
layer so using a fake instead of a mock

00:20:31,950 --> 00:20:38,520
then the typical structure is make the

00:20:35,940 --> 00:20:42,510
fake with appropriate parameters patch

00:20:38,520 --> 00:20:45,630
it into say new equal in in mock patch

00:20:42,510 --> 00:20:48,030
instead of a photo spectral which sets

00:20:45,630 --> 00:20:50,850
an existing object in way of the other

00:20:48,030 --> 00:20:53,610
and then populate in this case the

00:20:50,850 --> 00:20:57,030
database by actually executing for

00:20:53,610 --> 00:20:59,100
example sequel statements on on occur

00:20:57,030 --> 00:21:02,280
service connection and then the same

00:20:59,100 --> 00:21:04,800
body of tests as before because we've

00:21:02,280 --> 00:21:07,350
set up exactly the same situation except

00:21:04,800 --> 00:21:10,680
with a fake instead of a mock and we can

00:21:07,350 --> 00:21:14,930
proceed and for full integration test

00:21:10,680 --> 00:21:19,710
well I presume a I start an instance of

00:21:14,930 --> 00:21:23,490
the database presumably locally like for

00:21:19,710 --> 00:21:25,980
example on the machine i'm using for

00:21:23,490 --> 00:21:30,600
tests so I can connect so the connection

00:21:25,980 --> 00:21:32,610
can use a unique socket which is faster

00:21:30,600 --> 00:21:35,850
than a network socket that is have to

00:21:32,610 --> 00:21:39,690
use and it was actually on the net and

00:21:35,850 --> 00:21:42,870
and populated somehow maybe with just by

00:21:39,690 --> 00:21:44,130
executing stuff or importing done or

00:21:42,870 --> 00:21:48,330
something so it's got an initial

00:21:44,130 --> 00:21:51,840
situation and then the same body of test

00:21:48,330 --> 00:21:56,730
that I was using in unit tests which is

00:21:51,840 --> 00:21:59,610
where the novel's deal applies the body

00:21:56,730 --> 00:22:02,520
of test is a core reusable part of the

00:21:59,610 --> 00:22:04,860
test for a certain component it

00:22:02,520 --> 00:22:08,810
exercises all meaningful paths and that

00:22:04,860 --> 00:22:12,090
must include simulated errors

00:22:08,810 --> 00:22:13,180
incidentally if you're using mocks or

00:22:12,090 --> 00:22:17,470
other forms

00:22:13,180 --> 00:22:20,470
of spies will briefly summarize all the

00:22:17,470 --> 00:22:23,470
various test doubles later but you can

00:22:20,470 --> 00:22:28,660
also check what cause there are being

00:22:23,470 --> 00:22:33,070
what arguments be careful of not falling

00:22:28,660 --> 00:22:36,040
into the trap of white box I tease you

00:22:33,070 --> 00:22:38,950
don't want your tests to have exactly

00:22:36,040 --> 00:22:42,580
the same structure of the code so that

00:22:38,950 --> 00:22:44,920
if some innocuous change to the code

00:22:42,580 --> 00:22:46,720
causes the test to fail that's not the

00:22:44,920 --> 00:22:49,450
purpose that it has to give you

00:22:46,720 --> 00:22:52,060
confidence that the code is still

00:22:49,450 --> 00:22:54,580
working so they must not perfect so if

00:22:52,060 --> 00:22:56,470
it's indifferent whether a happens first

00:22:54,580 --> 00:22:59,730
and then B or vice versa

00:22:56,470 --> 00:23:07,840
make sure it's indifferent in your test

00:22:59,730 --> 00:23:11,140
the extra checks are optional mocks are

00:23:07,840 --> 00:23:13,990
also always spies so they make it free

00:23:11,140 --> 00:23:16,900
but you can always wrap anything with a

00:23:13,990 --> 00:23:20,410
spy to just follow those checks if

00:23:16,900 --> 00:23:22,180
you're really keen about them so the big

00:23:20,410 --> 00:23:24,070
point in any case is there is a

00:23:22,180 --> 00:23:26,470
difference between mocks and fakes and

00:23:24,070 --> 00:23:28,540
there are many other kind of test

00:23:26,470 --> 00:23:32,230
doubles unfortunately the classic

00:23:28,540 --> 00:23:37,180
article in the matter martin fowler's /

00:23:32,230 --> 00:23:39,700
this URL is very java oriented still as

00:23:37,180 --> 00:23:41,440
i mentioned at the start that these

00:23:39,700 --> 00:23:43,150
concepts apply to just about any

00:23:41,440 --> 00:23:44,860
programming language you might want to

00:23:43,150 --> 00:23:48,430
use except of course that to give

00:23:44,860 --> 00:23:50,620
examples in Java considering every every

00:23:48,430 --> 00:23:53,020
variable must be at least 45 characters

00:23:50,620 --> 00:23:56,730
long and with several capitals in the

00:23:53,020 --> 00:24:00,250
middle will take more pixels so that

00:23:56,730 --> 00:24:02,560
whatever did from my point of view

00:24:00,250 --> 00:24:04,660
rather than the important fine-grain

00:24:02,560 --> 00:24:07,090
detail between a dummy and a fake and a

00:24:04,660 --> 00:24:09,220
mark and a stub in a smile and so on is

00:24:07,090 --> 00:24:13,840
who owns it who maintains it who

00:24:09,220 --> 00:24:18,460
releases it a fake the way I'm using the

00:24:13,840 --> 00:24:21,760
term is something that is maintained and

00:24:18,460 --> 00:24:25,210
released by the same group with who

00:24:21,760 --> 00:24:26,380
maintains and release they software

00:24:25,210 --> 00:24:31,600
being faked

00:24:26,380 --> 00:24:34,030
so if I am part of a open source group

00:24:31,600 --> 00:24:36,370
maintaining and releasing a database I

00:24:34,030 --> 00:24:40,299
will have a fake version of the database

00:24:36,370 --> 00:24:43,900
ready for testing of an example of

00:24:40,299 --> 00:24:46,960
between complete SQLite which comes with

00:24:43,900 --> 00:24:50,850
the standard library is a perfectly

00:24:46,960 --> 00:24:54,309
usable database for a reasonably small

00:24:50,850 --> 00:25:00,059
store like a few few gigabyte of stuff

00:24:54,309 --> 00:25:03,580
but it also has a : memory : special

00:25:00,059 --> 00:25:06,100
word to use instead of a file name it

00:25:03,580 --> 00:25:09,460
will make the database in memory which

00:25:06,100 --> 00:25:13,090
can be useful for very small databases

00:25:09,460 --> 00:25:15,070
but more particularly for tests it's not

00:25:13,090 --> 00:25:18,909
complete as you'll see it's not that all

00:25:15,070 --> 00:25:22,360
you'd want to fake so again there's a

00:25:18,909 --> 00:25:24,210
talk later on validated fakes later this

00:25:22,360 --> 00:25:27,250
morning which I strongly recommend

00:25:24,210 --> 00:25:31,570
because it will go deeper into what I

00:25:27,250 --> 00:25:33,760
can barely mention so a mock is very

00:25:31,570 --> 00:25:36,460
flexible can simulate anything but

00:25:33,760 --> 00:25:38,620
because exactly because of that it can

00:25:36,460 --> 00:25:40,659
simulate something you think should

00:25:38,620 --> 00:25:43,840
exist but is not what actually exists

00:25:40,659 --> 00:25:49,200
the fake are the fast limited emulation

00:25:43,840 --> 00:25:52,630
of the exact set of things that do exist

00:25:49,200 --> 00:25:56,409
they both should and this is where as

00:25:52,630 --> 00:26:00,970
delightful short as a fake of itself be

00:25:56,409 --> 00:26:04,840
able to simulate any error that is they

00:26:00,970 --> 00:26:07,510
should be able to be set so that instead

00:26:04,840 --> 00:26:10,510
of giving a result they will raise an

00:26:07,510 --> 00:26:13,150
exception specified exception that's

00:26:10,510 --> 00:26:15,520
trivial with mark if you just assign the

00:26:13,150 --> 00:26:19,480
exception to the side-effect instead of

00:26:15,520 --> 00:26:22,780
T the result but for the fake the fake

00:26:19,480 --> 00:26:25,059
must have been presenters way or you can

00:26:22,780 --> 00:26:27,400
kind of hack it by wrapping a mock

00:26:25,059 --> 00:26:32,520
around the fake for the sole purpose

00:26:27,400 --> 00:26:35,530
that is get kinda grotty anyway the

00:26:32,520 --> 00:26:37,270
reason is that certain errors in

00:26:35,530 --> 00:26:39,760
particular which are crucial to be

00:26:37,270 --> 00:26:43,510
handled correctly are almost impossible

00:26:39,760 --> 00:26:46,510
to simulate a - to verify that your code

00:26:43,510 --> 00:26:48,940
makes any sense except if your mock or

00:26:46,510 --> 00:26:51,730
fake or whatever is able to simulate it

00:26:48,940 --> 00:26:54,610
for example what do you do if the CPU

00:26:51,730 --> 00:26:57,120
catches fire well you presumably can

00:26:54,610 --> 00:26:59,980
serve a CPU on fire exception and

00:26:57,120 --> 00:27:02,560
proceeded to to turn down but the point

00:26:59,980 --> 00:27:07,510
is how do you test that because it takes

00:27:02,560 --> 00:27:11,080
a lot of CPUs to be burned and and it's

00:27:07,510 --> 00:27:13,810
hard to automate - if you really need to

00:27:11,080 --> 00:27:16,300
do that the bus by far the best is there

00:27:13,810 --> 00:27:20,530
is a mark or something that raises the

00:27:16,300 --> 00:27:22,930
CPU on fire and then you check that you

00:27:20,530 --> 00:27:26,460
handle it gracefully now moving to a

00:27:22,930 --> 00:27:29,770
middle layer module what changes well

00:27:26,460 --> 00:27:32,350
for the pure unit test you can mock out

00:27:29,770 --> 00:27:35,230
the low-level module so no one else - on

00:27:32,350 --> 00:27:39,070
which depends in this case you have

00:27:35,230 --> 00:27:41,530
fewer risks so presumably all the

00:27:39,070 --> 00:27:45,250
modules and components were drawing are

00:27:41,530 --> 00:27:48,100
owned by the same team so there is good

00:27:45,250 --> 00:27:50,590
understanding around so you don't really

00:27:48,100 --> 00:27:54,370
risk or hopefully you don't you just

00:27:50,590 --> 00:27:56,230
need to get your mocs reviewed by these

00:27:54,370 --> 00:27:59,530
specialists who know whether the one who

00:27:56,230 --> 00:28:02,200
Noel - there is however a interesting

00:27:59,530 --> 00:28:04,960
alternative for a mid layer what if I

00:28:02,200 --> 00:28:07,060
use the actual l1 and l2 in this case

00:28:04,960 --> 00:28:09,730
there are no further dependencies so no

00:28:07,060 --> 00:28:10,450
further problem well it works is there

00:28:09,730 --> 00:28:13,330
fast enough

00:28:10,450 --> 00:28:16,390
don't you aren't you sure if they are

00:28:13,330 --> 00:28:20,410
that's what time it is for measuring the

00:28:16,390 --> 00:28:23,500
speed of a specific fragment of code if

00:28:20,410 --> 00:28:27,550
they are fast enough you don't need to

00:28:23,500 --> 00:28:30,520
do the mocking that makes it less work

00:28:27,550 --> 00:28:32,350
for you if you need to verify at the

00:28:30,520 --> 00:28:36,040
start you need the same amount of work

00:28:32,350 --> 00:28:38,650
but then if the actual modules are fast

00:28:36,040 --> 00:28:40,210
enough that are you don't have to

00:28:38,650 --> 00:28:44,230
maintain them going forward

00:28:40,210 --> 00:28:46,270
remember there are some priming that you

00:28:44,230 --> 00:28:48,570
need to be able to do in your low levels

00:28:46,270 --> 00:28:51,670
which includes simulating errors as well

00:28:48,570 --> 00:28:52,790
as whatever else is needed for speed

00:28:51,670 --> 00:28:57,530
like it

00:28:52,790 --> 00:29:02,210
into the cold memory thing in SQLite and

00:28:57,530 --> 00:29:05,660
this is the schema as again there's a

00:29:02,210 --> 00:29:09,560
prepare of with side-effects and then

00:29:05,660 --> 00:29:13,340
the body or the prepare with priming and

00:29:09,560 --> 00:29:16,850
then the body what about what about a

00:29:13,340 --> 00:29:20,180
high level like picking one well then

00:29:16,850 --> 00:29:25,280
you have several potential change of

00:29:20,180 --> 00:29:28,430
dependencies and you can do a pure unit

00:29:25,280 --> 00:29:30,980
test by mocking out the mid layers you

00:29:28,430 --> 00:29:34,180
can do a second layer by using the

00:29:30,980 --> 00:29:37,390
actual mid layers and mocking down below

00:29:34,180 --> 00:29:41,420
sometimes you can use the real one

00:29:37,390 --> 00:29:44,090
there's many possibilities of mixing you

00:29:41,420 --> 00:29:46,280
have to pick a subset because if you try

00:29:44,090 --> 00:29:48,140
to do every possible combination you

00:29:46,280 --> 00:29:52,310
suffer a combinatorial explosion and

00:29:48,140 --> 00:29:58,280
don't get extra useful coverage for your

00:29:52,310 --> 00:30:00,980
effort so I'm taking and picking one set

00:29:58,280 --> 00:30:07,550
of mocking verses actually and faking

00:30:00,980 --> 00:30:10,130
and this is the code for that single

00:30:07,550 --> 00:30:13,400
case so this time you see body of tests

00:30:10,130 --> 00:30:16,820
only ones but that's because this is

00:30:13,400 --> 00:30:20,120
only one of the many layers I recommend

00:30:16,820 --> 00:30:22,220
so what do you use well the decision

00:30:20,120 --> 00:30:27,020
depends a lot on the characteristic of

00:30:22,220 --> 00:30:29,210
your code again mock it probably fastest

00:30:27,020 --> 00:30:32,540
and least accurate actually the least

00:30:29,210 --> 00:30:36,080
work is fast enough if it designed to be

00:30:32,540 --> 00:30:39,460
primeval for speed and other things like

00:30:36,080 --> 00:30:42,290
faking errors sake is probably best if

00:30:39,460 --> 00:30:44,810
you're using software which releases it

00:30:42,290 --> 00:30:48,620
incidentally need not be open source for

00:30:44,810 --> 00:30:51,160
example Google cloud platform services

00:30:48,620 --> 00:30:54,020
are better all being released with

00:30:51,160 --> 00:30:55,430
emulators on the side so that you can

00:30:54,020 --> 00:30:58,220
run your test locally without

00:30:55,430 --> 00:31:00,710
necessarily I know because I lead the

00:30:58,220 --> 00:31:04,169
tech support for Google cloud platform

00:31:00,710 --> 00:31:07,080
and I really

00:31:04,169 --> 00:31:09,509
I know him hi engineering and product

00:31:07,080 --> 00:31:11,700
manager colleague by saying every time

00:31:09,509 --> 00:31:13,649
there's a bug in a customer which could

00:31:11,700 --> 00:31:16,200
have been avoided if they are drone test

00:31:13,649 --> 00:31:17,639
I go to my colleague and say see you

00:31:16,200 --> 00:31:19,529
couldn't run test because you didn't

00:31:17,639 --> 00:31:21,720
release an emulator for this service and

00:31:19,529 --> 00:31:23,820
that service when can I see it because

00:31:21,720 --> 00:31:28,559
otherwise I can send you the problems

00:31:23,820 --> 00:31:32,039
and so on and so forth anyway and one of

00:31:28,559 --> 00:31:34,200
the choices is to control the complexity

00:31:32,039 --> 00:31:37,980
sometimes it's not obvious when you say

00:31:34,200 --> 00:31:40,879
DNS domain name system for most people

00:31:37,980 --> 00:31:43,859
it means ok I get food comm and

00:31:40,879 --> 00:31:46,950
translate that into an IP one two three

00:31:43,859 --> 00:31:49,499
four that's known as the a record in DNS

00:31:46,950 --> 00:31:51,989
but DNS has a million other kind of

00:31:49,499 --> 00:31:55,619
records from the C name to the txt and

00:31:51,989 --> 00:31:58,889
maybe you need the TC record to validate

00:31:55,619 --> 00:32:01,379
the ownership of a domain and so on in

00:31:58,889 --> 00:32:03,659
which case it's not a trivial mock

00:32:01,379 --> 00:32:08,759
anymore as would be if you only need a

00:32:03,659 --> 00:32:12,059
day or what a records before finish I

00:32:08,759 --> 00:32:14,820
have an ask a very interesting question

00:32:12,059 --> 00:32:17,730
but does it apply to load testing well

00:32:14,820 --> 00:32:20,309
there's a whole thing about measuring

00:32:17,730 --> 00:32:22,859
performance so it takes the whole

00:32:20,309 --> 00:32:25,259
afternoon today so you may want to go

00:32:22,859 --> 00:32:27,840
back and if you really need load test

00:32:25,259 --> 00:32:29,999
for performance but unfortunately it

00:32:27,840 --> 00:32:32,279
doesn't apply the dead layering concept

00:32:29,999 --> 00:32:35,700
doesn't apply fully because you can't

00:32:32,279 --> 00:32:38,850
really measure based on the layer except

00:32:35,700 --> 00:32:41,039
end to end so there the end-to-end is

00:32:38,850 --> 00:32:42,809
needed you can take correctness for

00:32:41,039 --> 00:32:45,869
granted it needs to be tested by

00:32:42,809 --> 00:32:48,389
separate tests and low tests but speed

00:32:45,869 --> 00:32:51,359
if you need to measure precisely you

00:32:48,389 --> 00:32:56,970
need the end-to-end and different body

00:32:51,359 --> 00:32:58,859
of tests so you don't want they retest

00:32:56,970 --> 00:33:01,889
correctness correctness must be census

00:32:58,859 --> 00:33:04,320
separately you want to exercise the slow

00:33:01,889 --> 00:33:08,549
parts the heavy computational or or IO

00:33:04,320 --> 00:33:10,619
parts you can get boundary if if your

00:33:08,549 --> 00:33:12,690
lower layer of level models models you

00:33:10,619 --> 00:33:16,320
depend on have a service level agreement

00:33:12,690 --> 00:33:17,740
the kind of 90 percent of queries

00:33:16,320 --> 00:33:19,809
completing less than 30

00:33:17,740 --> 00:33:22,179
milisecond that kind of thing and you

00:33:19,809 --> 00:33:27,130
need to guarantee something similar to

00:33:22,179 --> 00:33:29,020
your users there is an approach which

00:33:27,130 --> 00:33:31,630
gives you a worst-case estimate

00:33:29,020 --> 00:33:34,510
essentially you can use the intermediate

00:33:31,630 --> 00:33:36,970
test to measure the actual time spent in

00:33:34,510 --> 00:33:39,850
your code and count the number of calls

00:33:36,970 --> 00:33:42,540
to the external services incidentally if

00:33:39,850 --> 00:33:44,920
the external services don't give you

00:33:42,540 --> 00:33:48,610
service level agreements then you cannot

00:33:44,920 --> 00:33:51,790
offer any in turn because any single

00:33:48,610 --> 00:33:55,270
calls to one of those could stop forever

00:33:51,790 --> 00:33:59,470
and this is about the body of tests for

00:33:55,270 --> 00:34:02,260
that on the other hand the question is

00:33:59,470 --> 00:34:03,820
but can I use this approach when what I

00:34:02,260 --> 00:34:06,220
want to test is our refactoring of

00:34:03,820 --> 00:34:08,889
course you can indeed if the refactoring

00:34:06,220 --> 00:34:11,050
by the incident wrinkles refactoring

00:34:08,889 --> 00:34:13,480
means changing the internals of the code

00:34:11,050 --> 00:34:17,129
without theoretically changing any of

00:34:13,480 --> 00:34:19,720
the externally observable behavior if

00:34:17,129 --> 00:34:21,700
it's all within a module this is the

00:34:19,720 --> 00:34:29,230
base case all of the talk applies

00:34:21,700 --> 00:34:32,950
entirely to testing that module they you

00:34:29,230 --> 00:34:35,020
may need to tweak test bodies the body

00:34:32,950 --> 00:34:37,119
of tests just to maintain coverage

00:34:35,020 --> 00:34:38,619
because maybe some things have gone away

00:34:37,119 --> 00:34:42,040
and you don't need to test them anymore

00:34:38,619 --> 00:34:44,919
or something for moving functionality

00:34:42,040 --> 00:34:48,129
between modules the first thing you do

00:34:44,919 --> 00:34:51,220
is you change the code and check that

00:34:48,129 --> 00:34:53,139
the unit tests of those modules at least

00:34:51,220 --> 00:34:57,010
the one from which you've taken things

00:34:53,139 --> 00:34:59,170
away fail this is the typical approach

00:34:57,010 --> 00:35:00,850
of tests first

00:34:59,170 --> 00:35:03,490
but it's automatic because you already

00:35:00,850 --> 00:35:05,770
have the test before you do the

00:35:03,490 --> 00:35:07,960
refactoring remember never a factor code

00:35:05,770 --> 00:35:11,859
without tests is what micro centers

00:35:07,960 --> 00:35:14,290
called legacy code always put some tests

00:35:11,859 --> 00:35:17,950
in place first if you're so unfortunate

00:35:14,290 --> 00:35:19,810
to have to deal with legacy code so you

00:35:17,950 --> 00:35:21,640
make the test fail you run the tests

00:35:19,810 --> 00:35:24,700
they automatically fail now you added

00:35:21,640 --> 00:35:27,100
the test bodies and potentially module

00:35:24,700 --> 00:35:28,980
mocks and fakes and now they pass check

00:35:27,100 --> 00:35:31,680
and then

00:35:28,980 --> 00:35:34,829
the intermediate levels showing that

00:35:31,680 --> 00:35:37,290
higher level modded intermediate tests

00:35:34,829 --> 00:35:42,030
in the version using the actual lower

00:35:37,290 --> 00:35:44,480
levels showing the higher level modules

00:35:42,030 --> 00:35:46,250
are not affected and everything is happy

00:35:44,480 --> 00:35:49,710
finally

00:35:46,250 --> 00:35:52,619
one problem with unit ESMA having to be

00:35:49,710 --> 00:35:56,250
passed is that sometimes not that not

00:35:52,619 --> 00:35:58,170
often just checking that a condition was

00:35:56,250 --> 00:36:01,260
actually satisfied can be too

00:35:58,170 --> 00:36:03,990
time-consuming to fit in the very short

00:36:01,260 --> 00:36:06,950
time I want my unit s to running when

00:36:03,990 --> 00:36:10,380
that happens what I've done sometimes is

00:36:06,950 --> 00:36:12,990
dump like snapshot the state of the

00:36:10,380 --> 00:36:16,920
whole system at the end check only was

00:36:12,990 --> 00:36:21,150
faster check and leave a nice blob

00:36:16,920 --> 00:36:23,430
reckon from which the whole earth the

00:36:21,150 --> 00:36:26,550
system status can be reconstructed as if

00:36:23,430 --> 00:36:29,390
I was doing snapshot and restart and

00:36:26,550 --> 00:36:32,640
then in the background a synchronously

00:36:29,390 --> 00:36:35,310
just run background jobs which

00:36:32,640 --> 00:36:37,440
continuously check for sanity whatever

00:36:35,310 --> 00:36:39,270
is very slow and long to check this has

00:36:37,440 --> 00:36:41,970
worked so well for me that I've started

00:36:39,270 --> 00:36:44,550
doing snapshot when performance affords

00:36:41,970 --> 00:36:46,440
even in Tet in production runs as

00:36:44,550 --> 00:36:48,869
opposed to test run a production run

00:36:46,440 --> 00:36:51,060
goes nobody complains everything seems

00:36:48,869 --> 00:36:54,030
to have gone well but I have a snapshot

00:36:51,060 --> 00:36:57,000
there and with some probability some

00:36:54,030 --> 00:36:59,609
random sample I sanity check afterwards

00:36:57,000 --> 00:37:02,790
once in a while this will let you catch

00:36:59,609 --> 00:37:06,690
a problem that was just barely hidden

00:37:02,790 --> 00:37:09,510
didn't hurt your users but your coated

00:37:06,690 --> 00:37:13,470
before is called your users which is by

00:37:09,510 --> 00:37:17,760
far the best thing and this lets out on

00:37:13,470 --> 00:37:20,280
to question an answer they everything

00:37:17,760 --> 00:37:24,480
including the speakers note which have

00:37:20,280 --> 00:37:28,110
been talking about is in that PDF on my

00:37:24,480 --> 00:37:31,530
website yes

00:37:28,110 --> 00:37:31,530
[Applause]

00:37:32,940 --> 00:37:38,609
do we have a mic for the questions

00:37:47,760 --> 00:37:52,920
one small question what do you think

00:37:49,950 --> 00:37:56,580
about possibility of fusing like real

00:37:52,920 --> 00:37:58,770
database assimilated database is that

00:37:56,580 --> 00:38:01,770
not okay that's better okay

00:37:58,770 --> 00:38:04,349
yeah what do you think about disability

00:38:01,770 --> 00:38:07,140
to use real database assimilated

00:38:04,349 --> 00:38:08,700
database but your date is memory so when

00:38:07,140 --> 00:38:09,750
era means the unit test you don't start

00:38:08,700 --> 00:38:12,540
anything you're just creating database

00:38:09,750 --> 00:38:14,670
memory put a few records and after it

00:38:12,540 --> 00:38:16,800
them it will be fast but at the same

00:38:14,670 --> 00:38:18,540
time it will give you a kind of you can

00:38:16,800 --> 00:38:20,580
be sure that everything works will be

00:38:18,540 --> 00:38:23,960
work on your database because sorry but

00:38:20,580 --> 00:38:27,300
I can't imagine our situation where

00:38:23,960 --> 00:38:31,440
there's an error right now

00:38:27,300 --> 00:38:33,270
I mean if is it is there a material

00:38:31,440 --> 00:38:36,000
difference between what I've written and

00:38:33,270 --> 00:38:38,250
what I should have written it is no than

00:38:36,000 --> 00:38:41,040
there is no error if yes then of course

00:38:38,250 --> 00:38:44,490
I can detect it so you'd need maybe

00:38:41,040 --> 00:38:45,960
afterwards we can sit down at with the

00:38:44,490 --> 00:38:48,570
subtitle and you can show me an example

00:38:45,960 --> 00:38:51,390
because I just cannot conceive of one it

00:38:48,570 --> 00:38:53,760
seems logical impossible if the checks

00:38:51,390 --> 00:38:56,720
are called if the checks take too long

00:38:53,760 --> 00:38:59,720
see the last part you do then comply

00:38:56,720 --> 00:38:59,720
okay

00:39:10,049 --> 00:39:15,970
so if your software is fast enough and

00:39:13,859 --> 00:39:19,059
let's say small enough whatever that

00:39:15,970 --> 00:39:20,109
means but it still has layers would you

00:39:19,059 --> 00:39:22,599
say that

00:39:20,109 --> 00:39:24,160
skipping mocking and faking is a good

00:39:22,599 --> 00:39:26,260
idea and just doing integration test

00:39:24,160 --> 00:39:27,910
either run fast because it kind of cuts

00:39:26,260 --> 00:39:41,650
down a workload of writing mocks and

00:39:27,910 --> 00:39:47,670
takes I need to stay nailed here if your

00:39:41,650 --> 00:39:52,660
code does pure intent totally CPU bound

00:39:47,670 --> 00:39:57,359
computational issues then the speed is

00:39:52,660 --> 00:40:03,180
constrained by our view such code is

00:39:57,359 --> 00:40:06,730
normally best move to numpy or similar

00:40:03,180 --> 00:40:10,569
libraries which you assume are correct

00:40:06,730 --> 00:40:13,599
because you know a requirements most

00:40:10,569 --> 00:40:17,650
famous quote given enough eyeballs all

00:40:13,599 --> 00:40:20,380
bugs are shallow with a million users of

00:40:17,650 --> 00:40:22,990
numpy bugs don't have a very long life

00:40:20,380 --> 00:40:27,220
there and this has a lot little

00:40:22,990 --> 00:40:30,780
advantage that by taking it for granted

00:40:27,220 --> 00:40:35,950
that lamp is correct you can mock doubt

00:40:30,780 --> 00:40:40,299
without anomalies and your whole test

00:40:35,950 --> 00:40:46,599
will be correct if as most programs your

00:40:40,299 --> 00:40:49,089
is a low bound then is we're mocking and

00:40:46,599 --> 00:40:50,349
faking and so on makes a big difference

00:40:49,089 --> 00:40:55,059
because a lot of darío

00:40:50,349 --> 00:40:58,630
may go I don't know to a magnetic disk

00:40:55,059 --> 00:41:01,540
well if it stays in memory instead

00:40:58,630 --> 00:41:04,089
that'll be faster it may go over the

00:41:01,540 --> 00:41:08,020
network if it stays local that will be

00:41:04,089 --> 00:41:11,349
faster and so on and so forth today the

00:41:08,020 --> 00:41:14,910
little bit by little bit you can easily

00:41:11,349 --> 00:41:19,589
gain order of magnitude by sufficient

00:41:14,910 --> 00:41:19,589
simulation and thank you

00:41:20,550 --> 00:41:28,410
how much longer do we have so one two

00:41:25,960 --> 00:41:28,410
more questions

00:41:35,190 --> 00:41:41,890
so it's lovely to hear that your team's

00:41:38,650 --> 00:41:44,049
produce good fakes how common would you

00:41:41,890 --> 00:41:46,000
say this is because my experience and

00:41:44,049 --> 00:41:48,789
flavor and fury sorry

00:41:46,000 --> 00:41:53,259
my experience with baking things is that

00:41:48,789 --> 00:41:56,140
the fakes do not exist elsewhere and you

00:41:53,259 --> 00:41:58,569
burn a lot of time failing to fully

00:41:56,140 --> 00:42:01,180
understand the system would you say that

00:41:58,569 --> 00:42:04,119
it is becoming more common you mentioned

00:42:01,180 --> 00:42:07,079
that your teams you push them harder to

00:42:04,119 --> 00:42:07,079
produce fakes

00:42:56,000 --> 00:43:00,950
I want to ask about integration test so

00:42:58,910 --> 00:43:04,700
what do you think in what detail would

00:43:00,950 --> 00:43:06,619
you include online distributed services

00:43:04,700 --> 00:43:09,170
in your integration test it doesn't seem

00:43:06,619 --> 00:43:12,559
seem feasible with CI but then you need

00:43:09,170 --> 00:43:21,609
to use marks or suck over some fakes for

00:43:12,559 --> 00:43:24,230
your online services so I'm sorry the

00:43:21,609 --> 00:43:26,869
acoustic is not hard if I understood

00:43:24,230 --> 00:43:30,049
correctly you're talking about real time

00:43:26,869 --> 00:43:33,079
software software with some kind of real

00:43:30,049 --> 00:43:36,349
time constraints let's assume your DBS

00:43:33,079 --> 00:43:38,539
in on another server somewhere it

00:43:36,349 --> 00:43:41,509
requires internet connection a socket

00:43:38,539 --> 00:43:44,539
something to run entrance integration

00:43:41,509 --> 00:43:47,869
tests on CI although I'm still not sure

00:43:44,539 --> 00:43:54,200
I pointed the question I believe that

00:43:47,869 --> 00:43:56,960
generally the more real life constraints

00:43:54,200 --> 00:44:00,170
the real software has the more the test

00:43:56,960 --> 00:44:03,890
will be living in simulated universes

00:44:00,170 --> 00:44:06,079
and to the universe where things can go

00:44:03,890 --> 00:44:09,319
well or badly in a simulated and

00:44:06,079 --> 00:44:12,339
controlled way I normally see get asked

00:44:09,319 --> 00:44:18,410
this about IOT Internet of Things

00:44:12,339 --> 00:44:21,019
applications where indeed the big deal

00:44:18,410 --> 00:44:23,450
is how do I deal with a million King

00:44:21,019 --> 00:44:26,029
gadget over the place well you don't

00:44:23,450 --> 00:44:29,720
well you do in your code I hope but not

00:44:26,029 --> 00:44:31,640
in your test that even they so-called

00:44:29,720 --> 00:44:36,559
end-to-end tests are you going to like

00:44:31,640 --> 00:44:38,599
have a million rumbles going around a

00:44:36,559 --> 00:44:42,710
huge room probably not there will be

00:44:38,599 --> 00:44:45,799
some level of simulation inevitably

00:44:42,710 --> 00:44:48,170
otherwise the test will be so cause it

00:44:45,799 --> 00:44:51,680
was like how do you test if so my

00:44:48,170 --> 00:44:53,480
software controls rocket putting men on

00:44:51,680 --> 00:44:57,140
Mars how do I test that well not

00:44:53,480 --> 00:44:59,119
end-to-end because it then you have to

00:44:57,140 --> 00:45:01,359
get them back from Mars it's a real

00:44:59,119 --> 00:45:01,359
problem

00:45:03,560 --> 00:45:09,229
okay thank you very much

00:45:05,760 --> 00:45:09,229

YouTube URL: https://www.youtube.com/watch?v=VzOOZxuqSVk


