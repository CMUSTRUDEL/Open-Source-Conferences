Title: Jiri Benes - Reliability in distributed systems
Publication date: 2018-08-22
Playlist: EuroPython 2018
Description: 
	Reliability in distributed systems
[EuroPython 2018 - Talk - 2018-07-25 - Smarkets]
[Edinburgh, UK]

By Jiri Benes

Is your system stable? Do you know what happens if any of your system's dependency will start failing? Do you even know what exactly each part of your system does or did any time in the past? Or how fast you will identify root of the problem in case your system goes down at 2am?

The talk focuses on distributed systems (microservices, APIs that communicate with databases, memory, third party services, etc.), monitoring, their failures and recovery in order to help you answer yourself questions above.

First part aims on importance of monitoring such systems on several levels - monitoring of hardware, application monitoring, monitoring from outside of the systems, detecting malfunctions based on anomalies within system's data flows.

Second part presents several standard techniques for preventing system failure in case of outage of dependency and technique how to recover from inconsistent state after outage.

Content of presentation is helpful and interesting for beginners and intermediates. Senior developers and developers working on reliable distributed systems should bear in mind content of this presentation and master shown techniques.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2018.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:05,690 --> 00:00:09,210
Thanks

00:00:07,260 --> 00:00:11,550
my name is Reba Nash and I work as a

00:00:09,210 --> 00:00:13,320
technique in a key that come and I would

00:00:11,550 --> 00:00:16,080
like to tell you a few words about this

00:00:13,320 --> 00:00:19,620
topic well the problem is that over

00:00:16,080 --> 00:00:21,660
years the systems are getting more and

00:00:19,620 --> 00:00:26,090
more complex we developed more

00:00:21,660 --> 00:00:28,980
complicated systems we have like higher

00:00:26,090 --> 00:00:31,050
requirements for systems to have like

00:00:28,980 --> 00:00:35,250
more complicated features more of

00:00:31,050 --> 00:00:37,739
features and especially in past years we

00:00:35,250 --> 00:00:39,930
are trying to usually break up like big

00:00:37,739 --> 00:00:42,750
monolithic applications into small

00:00:39,930 --> 00:00:47,790
chunks so the apps like have a lot of

00:00:42,750 --> 00:00:49,890
more dependencies and our like getting

00:00:47,790 --> 00:00:52,079
more complex in a general and the

00:00:49,890 --> 00:00:54,480
problem is that usually like anything

00:00:52,079 --> 00:00:57,200
can break down any of your dependencies

00:00:54,480 --> 00:01:01,079
like a neat work can down it can go down

00:00:57,200 --> 00:01:04,619
in the data center and whatever like

00:01:01,079 --> 00:01:08,010
anybody can do some humanistic and the

00:01:04,619 --> 00:01:10,170
system just can crash down like for

00:01:08,010 --> 00:01:13,140
example in past two months you may have

00:01:10,170 --> 00:01:16,260
noticed that one credit card scheme had

00:01:13,140 --> 00:01:17,970
like big outage in a Europe and a lot of

00:01:16,260 --> 00:01:20,340
people couldn't pay with credit cards

00:01:17,970 --> 00:01:24,270
and two weeks later it happened to a

00:01:20,340 --> 00:01:26,729
different credit card company and few

00:01:24,270 --> 00:01:29,670
weeks after there was a storm in Germany

00:01:26,729 --> 00:01:32,340
that cause like outage of one of big

00:01:29,670 --> 00:01:35,610
data centers and his company has like

00:01:32,340 --> 00:01:39,240
like really big budgets and they are

00:01:35,610 --> 00:01:41,820
doing the best to stay like available

00:01:39,240 --> 00:01:45,090
but I think can happen and they can just

00:01:41,820 --> 00:01:48,119
break down so we all of this talk is

00:01:45,090 --> 00:01:50,820
like to present few techniques that can

00:01:48,119 --> 00:01:54,540
help preventing of failing your app in

00:01:50,820 --> 00:01:57,119
case of the dependency will fail we will

00:01:54,540 --> 00:01:58,950
see some examples in Python and the

00:01:57,119 --> 00:02:01,170
other goal is to have actually

00:01:58,950 --> 00:02:04,079
visibility over your app to know what

00:02:01,170 --> 00:02:06,540
exactly is happening inside not just to

00:02:04,079 --> 00:02:08,909
deploy some app somewhere and not you

00:02:06,540 --> 00:02:14,040
know what is that thing there for

00:02:08,909 --> 00:02:17,340
example in my previous company we have

00:02:14,040 --> 00:02:20,040
been using the data center they were

00:02:17,340 --> 00:02:23,099
like more expensive that but they

00:02:20,040 --> 00:02:27,359
promised like 100 percent reliability

00:02:23,099 --> 00:02:29,969
and so we paid something extra to have

00:02:27,359 --> 00:02:33,389
something reliable what what happened

00:02:29,969 --> 00:02:36,419
once suddenly all of our apps running

00:02:33,389 --> 00:02:38,329
there just went down so we call them and

00:02:36,419 --> 00:02:41,549
asking when they gonna fix it

00:02:38,329 --> 00:02:44,579
they were asking things would we explain

00:02:41,549 --> 00:02:47,099
the servers they asked which ones we

00:02:44,579 --> 00:02:49,980
told them like all of them they didn't

00:02:47,099 --> 00:02:51,959
believe us so we advised go to your web

00:02:49,980 --> 00:02:53,790
not even this is running and they

00:02:51,959 --> 00:02:57,329
realize that they have a problem and

00:02:53,790 --> 00:03:00,150
what happened they found out that some

00:02:57,329 --> 00:03:03,419
maintainer some plumber actually broke a

00:03:00,150 --> 00:03:06,359
pipe in the building and all data center

00:03:03,419 --> 00:03:09,480
was flooded so they were like repairing

00:03:06,359 --> 00:03:11,639
the infrastructure over six days loading

00:03:09,480 --> 00:03:14,309
the backups and they didn't even know

00:03:11,639 --> 00:03:16,919
like that something actually happened I

00:03:14,309 --> 00:03:20,459
claimed to have like 100 percent

00:03:16,919 --> 00:03:23,120
reliability that they have backups one

00:03:20,459 --> 00:03:29,089
budget backups were in the same building

00:03:23,120 --> 00:03:31,799
so basically you can't trust anybody and

00:03:29,089 --> 00:03:35,159
you should know what is happening with

00:03:31,799 --> 00:03:36,989
your infrastructure so we'll go through

00:03:35,159 --> 00:03:41,069
some techniques that you can apply in

00:03:36,989 --> 00:03:42,749
Python to make your app more stable we

00:03:41,069 --> 00:03:43,260
will go through some monitoring and our

00:03:42,749 --> 00:03:47,099
thing

00:03:43,260 --> 00:03:49,079
and like there're some tips or do you

00:03:47,099 --> 00:03:51,419
can like 'man when you are deployed

00:03:49,079 --> 00:03:55,260
deploying infrastructure I would just

00:03:51,419 --> 00:03:57,629
think it strong so when you start

00:03:55,260 --> 00:04:00,629
actually developing the app you should

00:03:57,629 --> 00:04:03,599
think of what about what are you

00:04:00,629 --> 00:04:05,729
actually using in your app like if you

00:04:03,599 --> 00:04:08,819
have some third party API is databases

00:04:05,729 --> 00:04:10,830
read as ready sees what service you use

00:04:08,819 --> 00:04:14,940
where they are and

00:04:10,830 --> 00:04:18,480
and water and you should realize the

00:04:14,940 --> 00:04:20,700
importance of your resources like this

00:04:18,480 --> 00:04:22,560
database is it okay if it goes down for

00:04:20,700 --> 00:04:26,220
one minute what happens if it goes down

00:04:22,560 --> 00:04:27,930
for one hour do they have any s always

00:04:26,220 --> 00:04:30,120
like can you trust them

00:04:27,930 --> 00:04:32,460
do you have backups in no more different

00:04:30,120 --> 00:04:38,790
locations how do we use these resources

00:04:32,460 --> 00:04:40,980
like how often like very starting like

00:04:38,790 --> 00:04:44,220
building for example some django app it

00:04:40,980 --> 00:04:46,350
has only one database but over time like

00:04:44,220 --> 00:04:49,230
over years there will be more and more

00:04:46,350 --> 00:04:51,360
people working on that and suddenly you

00:04:49,230 --> 00:04:55,200
will have like dozens of dependencies

00:04:51,360 --> 00:04:59,790
sort of databases third-party aps and it

00:04:55,200 --> 00:05:01,740
can easily turn into a mess like I don't

00:04:59,790 --> 00:05:04,760
think that they originally designed it

00:05:01,740 --> 00:05:08,520
like this but somehow it can naturally

00:05:04,760 --> 00:05:11,070
happen that you are like with big

00:05:08,520 --> 00:05:13,890
spaghetti infrastructure in one of the

00:05:11,070 --> 00:05:16,650
previous companies again there was like

00:05:13,890 --> 00:05:19,200
some time period where DevOps usually

00:05:16,650 --> 00:05:21,690
once a week fountain server and nobody

00:05:19,200 --> 00:05:26,760
knew what is like what is running there

00:05:21,690 --> 00:05:29,220
and what is that we even had it so when

00:05:26,760 --> 00:05:34,650
you know that what are you actually

00:05:29,220 --> 00:05:37,890
using next thing is like to think about

00:05:34,650 --> 00:05:39,990
how you use it let's say we have some

00:05:37,890 --> 00:05:44,070
service and we have some dependency

00:05:39,990 --> 00:05:47,490
which can be some REST API now we see

00:05:44,070 --> 00:05:49,710
like healthy a communication we have a

00:05:47,490 --> 00:05:52,020
request on time with a request receive

00:05:49,710 --> 00:05:55,440
response immediately and everything is

00:05:52,020 --> 00:05:58,890
smooth but the problems becomes when the

00:05:55,440 --> 00:06:01,530
dependency is starting time outing you

00:05:58,890 --> 00:06:05,640
have like some delay when you get the

00:06:01,530 --> 00:06:10,310
response and your requests are starting

00:06:05,640 --> 00:06:15,570
piling up and being handled in parallel

00:06:10,310 --> 00:06:18,419
yeah so what are the consequences like

00:06:15,570 --> 00:06:21,840
your users of your service will have

00:06:18,419 --> 00:06:23,940
like a slower response

00:06:21,840 --> 00:06:27,540
another thing is that your app will

00:06:23,940 --> 00:06:30,210
start like eating resources for example

00:06:27,540 --> 00:06:33,270
if you didn't have some Python app which

00:06:30,210 --> 00:06:36,920
is not like fully async you may have

00:06:33,270 --> 00:06:40,740
depleted your application on workers and

00:06:36,920 --> 00:06:43,200
that will be like busy waiting and

00:06:40,740 --> 00:06:45,480
looking at the under resources and it

00:06:43,200 --> 00:06:47,310
may end up that new request that your

00:06:45,480 --> 00:06:48,870
app will start to be receiving it will

00:06:47,310 --> 00:06:51,890
just throw them away because you won't

00:06:48,870 --> 00:06:56,310
have anything to handle them

00:06:51,890 --> 00:06:58,910
so can you do check out like any

00:06:56,310 --> 00:07:03,240
communication with other systems and

00:06:58,910 --> 00:07:06,480
decide like how long is worth to waiting

00:07:03,240 --> 00:07:08,970
for the response yeah

00:07:06,480 --> 00:07:10,770
let's say we have for example some issue

00:07:08,970 --> 00:07:13,650
and in the corner you have information

00:07:10,770 --> 00:07:16,980
about the weather in Edinburgh which is

00:07:13,650 --> 00:07:18,900
like nice to know but it's not worse for

00:07:16,980 --> 00:07:21,690
user to wait one minute to load a ship

00:07:18,900 --> 00:07:24,060
to see like this information let's say

00:07:21,690 --> 00:07:25,620
that the weather API like timeout thing

00:07:24,060 --> 00:07:27,360
so we'll just cut the request for

00:07:25,620 --> 00:07:29,520
example after one second or three

00:07:27,360 --> 00:07:33,290
seconds and just didn't show the user

00:07:29,520 --> 00:07:36,390
the information most of the like Python

00:07:33,290 --> 00:07:40,200
libraries usually have parameter timeout

00:07:36,390 --> 00:07:42,150
which we which which with what we can as

00:07:40,200 --> 00:07:44,280
the number of seconds you want to

00:07:42,150 --> 00:07:48,420
actually wait for the response and

00:07:44,280 --> 00:07:50,400
otherwise cut the request so when you

00:07:48,420 --> 00:07:52,980
applied the communication can look like

00:07:50,400 --> 00:07:56,490
this I've know the dependency started

00:07:52,980 --> 00:07:58,920
piling up the request you are returning

00:07:56,490 --> 00:08:00,750
the response on time but you will lose

00:07:58,920 --> 00:08:05,730
the information you know they are

00:08:00,750 --> 00:08:08,790
response a few things to to be aware of

00:08:05,730 --> 00:08:11,520
like if you cut a request that actually

00:08:08,790 --> 00:08:14,220
money plays with some data for example

00:08:11,520 --> 00:08:19,110
storing in database and you cut it off

00:08:14,220 --> 00:08:21,870
it may be like executed anyway so you

00:08:19,110 --> 00:08:24,630
may store something in database or my

00:08:21,870 --> 00:08:28,890
place data and you don't know if you did

00:08:24,630 --> 00:08:31,950
or not and second thing like if you have

00:08:28,890 --> 00:08:34,470
some Buyten component for example that

00:08:31,950 --> 00:08:37,050
and devorah vivre days you need to take

00:08:34,470 --> 00:08:39,360
care of if you set time out

00:08:37,050 --> 00:08:41,610
not just to acquiring the result from

00:08:39,360 --> 00:08:44,160
ArrayList or database or also for

00:08:41,610 --> 00:08:47,040
initialization of communication because

00:08:44,160 --> 00:08:49,200
some of the libraries allows you to sell

00:08:47,040 --> 00:08:51,750
you on the timeout for the query itself

00:08:49,200 --> 00:08:55,050
so even though that you set up the

00:08:51,750 --> 00:08:58,290
timeouts you might end up like breaking

00:08:55,050 --> 00:09:02,550
your app because you did or the

00:08:58,290 --> 00:09:05,700
application the library doesn't allow to

00:09:02,550 --> 00:09:07,500
sell it properly it's like a really

00:09:05,700 --> 00:09:09,950
basic technique that should be in my

00:09:07,500 --> 00:09:12,900
opinion applied to any communication and

00:09:09,950 --> 00:09:16,380
one more like advanced technique is

00:09:12,900 --> 00:09:18,510
applying circuit breakers the philosophy

00:09:16,380 --> 00:09:22,350
behind it is like when you have some

00:09:18,510 --> 00:09:25,110
dependency that starts failing why

00:09:22,350 --> 00:09:28,590
should you communicate with it for

00:09:25,110 --> 00:09:33,930
example you have this issue with weather

00:09:28,590 --> 00:09:36,920
information if several users will end up

00:09:33,930 --> 00:09:40,050
holding the weather you will just stop

00:09:36,920 --> 00:09:45,180
displaying it at all and users won't get

00:09:40,050 --> 00:09:46,350
the information at all so if you know

00:09:45,180 --> 00:09:48,810
the dependency files

00:09:46,350 --> 00:09:50,580
you won't even wait for any timeouts or

00:09:48,810 --> 00:09:54,420
any seconds we will just immediately

00:09:50,580 --> 00:09:55,800
return instant alerts so you won't pile

00:09:54,420 --> 00:09:59,220
any requests or anything

00:09:55,800 --> 00:10:02,160
and also it's better for third party

00:09:59,220 --> 00:10:04,020
system recovery let's say that the other

00:10:02,160 --> 00:10:06,630
system is failing because it's

00:10:04,020 --> 00:10:09,410
overloaded so if you actually stop

00:10:06,630 --> 00:10:13,740
calling it you may give it a time to

00:10:09,410 --> 00:10:16,500
auto recover in Python there are some

00:10:13,740 --> 00:10:18,930
libraries usually implemented as the

00:10:16,500 --> 00:10:23,010
crater it will just set up the crater

00:10:18,930 --> 00:10:25,940
you will specify how many errors in row

00:10:23,010 --> 00:10:30,320
you will allow for this resource and

00:10:25,940 --> 00:10:33,570
some interval how long you will wait

00:10:30,320 --> 00:10:35,760
until you try to communicate with it

00:10:33,570 --> 00:10:39,390
again it will apply the crater for

00:10:35,760 --> 00:10:42,080
function in case the function will raise

00:10:39,390 --> 00:10:44,540
errors like five times in a row

00:10:42,080 --> 00:10:46,670
stop using the function decorator we'll

00:10:44,540 --> 00:10:50,840
stop calling the function for a 60

00:10:46,670 --> 00:10:55,880
seconds in this example how it works

00:10:50,840 --> 00:10:57,770
inside the breaker has three sides one

00:10:55,880 --> 00:11:00,020
is closed which means the communication

00:10:57,770 --> 00:11:04,610
is okay everything is moved and you call

00:11:00,020 --> 00:11:07,600
the dependency normally associate second

00:11:04,610 --> 00:11:10,580
state is open which means something is

00:11:07,600 --> 00:11:13,810
wrong and you stop calling the

00:11:10,580 --> 00:11:17,860
dependency at all and half open is state

00:11:13,810 --> 00:11:21,470
when you were open and you are trying to

00:11:17,860 --> 00:11:23,470
query you just try to send out a few

00:11:21,470 --> 00:11:27,500
queries if you request and you will see

00:11:23,470 --> 00:11:29,660
if it's healthy or not and based on that

00:11:27,500 --> 00:11:33,500
you will decide if you wait for or close

00:11:29,660 --> 00:11:33,950
the break room so communication I can do

00:11:33,500 --> 00:11:37,070
it like this

00:11:33,950 --> 00:11:41,090
you have first request that gives you

00:11:37,070 --> 00:11:44,060
like 100 or 200 or some success response

00:11:41,090 --> 00:11:46,210
so breaker is closed second request is

00:11:44,060 --> 00:11:48,950
still okay so you are keeping closed

00:11:46,210 --> 00:11:52,060
third request you will get some error or

00:11:48,950 --> 00:11:55,070
a timeout or just some error response

00:11:52,060 --> 00:11:58,720
but you will check that it's on a first

00:11:55,070 --> 00:12:01,600
error so you will keep the breaker coast

00:11:58,720 --> 00:12:04,430
then you will receive another request

00:12:01,600 --> 00:12:07,130
another error and you will see it

00:12:04,430 --> 00:12:10,760
slaughtered a like and error so I will

00:12:07,130 --> 00:12:13,070
open the breaker then there will be like

00:12:10,760 --> 00:12:17,390
this communication window that you will

00:12:13,070 --> 00:12:19,640
stop calling the dependency and after

00:12:17,390 --> 00:12:21,680
that you will try to you will get to

00:12:19,640 --> 00:12:23,870
half open state and try to sender some

00:12:21,680 --> 00:12:29,090
requests if you are ok you will close it

00:12:23,870 --> 00:12:32,390
and continue or at some time window

00:12:29,090 --> 00:12:36,080
again so the communication looks like

00:12:32,390 --> 00:12:38,240
this once you start receiving errors or

00:12:36,080 --> 00:12:41,600
timeouts you will just stop

00:12:38,240 --> 00:12:44,720
communicating with it so in general like

00:12:41,600 --> 00:12:47,270
you will return instant errors and he

00:12:44,720 --> 00:12:48,950
won't deplete any resources and he will

00:12:47,270 --> 00:12:50,690
give a time to recover for the system

00:12:48,950 --> 00:12:58,250
and

00:12:50,690 --> 00:13:01,280
- Python implementations yeah so far we

00:12:58,250 --> 00:13:06,020
have been using breakers and my mouse

00:13:01,280 --> 00:13:09,200
just to kill some dependence in a small

00:13:06,020 --> 00:13:11,840
foreign but in case you have something

00:13:09,200 --> 00:13:15,160
really critical to perform some action

00:13:11,840 --> 00:13:18,080
for example any shop if you are like

00:13:15,160 --> 00:13:20,480
handling the payment or something in

00:13:18,080 --> 00:13:23,480
case like the other system for example

00:13:20,480 --> 00:13:25,900
payment gateway will start failing you

00:13:23,480 --> 00:13:29,090
may really want the response so we will

00:13:25,900 --> 00:13:32,180
duplicate the request again they will

00:13:29,090 --> 00:13:36,050
get the response so from this

00:13:32,180 --> 00:13:38,390
perspective end link your request will

00:13:36,050 --> 00:13:40,610
take longer because you are internally

00:13:38,390 --> 00:13:45,380
calling the service more times but you

00:13:40,610 --> 00:13:48,170
will get your response again

00:13:45,380 --> 00:13:49,010
implementations it can be made as a

00:13:48,170 --> 00:13:52,550
decorator

00:13:49,010 --> 00:13:56,030
you will just setup like how many times

00:13:52,550 --> 00:13:58,340
you want to repeat the request it

00:13:56,030 --> 00:14:01,370
shouldn't be like infinite time or

00:13:58,340 --> 00:14:03,920
whatever you can specify how long he

00:14:01,370 --> 00:14:05,720
will wait between the requests probably

00:14:03,920 --> 00:14:07,820
you can set up also some jitter or

00:14:05,720 --> 00:14:10,730
something applied to function it

00:14:07,820 --> 00:14:12,800
functions at revs an exception function

00:14:10,730 --> 00:14:17,360
will be called again and again how we

00:14:12,800 --> 00:14:21,770
will configure it but there are also

00:14:17,360 --> 00:14:24,980
problems with first thing is if you

00:14:21,770 --> 00:14:27,890
actually calling some API like more

00:14:24,980 --> 00:14:32,570
times you might end up like changing

00:14:27,890 --> 00:14:35,180
data more times you can store some

00:14:32,570 --> 00:14:40,490
object database more times if it's

00:14:35,180 --> 00:14:42,680
actually internally executed and also

00:14:40,490 --> 00:14:47,840
bigger problem is when you are style

00:14:42,680 --> 00:14:49,760
piling repeaters either in your

00:14:47,840 --> 00:14:52,910
application internally on several

00:14:49,760 --> 00:14:56,180
illogical levels or through some other

00:14:52,910 --> 00:14:59,240
dependency you may end up like smashing

00:14:56,180 --> 00:15:02,150
some resource yeah

00:14:59,240 --> 00:15:03,390
here we have like one request to our

00:15:02,150 --> 00:15:05,190
service

00:15:03,390 --> 00:15:07,709
- we'll make free request - some

00:15:05,190 --> 00:15:09,810
dependency some dependency will make

00:15:07,709 --> 00:15:12,390
again free refers to other dependency

00:15:09,810 --> 00:15:17,839
and in general from one request you may

00:15:12,390 --> 00:15:21,329
end up with nine requests so this is

00:15:17,839 --> 00:15:23,450
really dangerous in case the final

00:15:21,329 --> 00:15:26,070
dependency will start failing because

00:15:23,450 --> 00:15:28,019
for example it's over loved it and with

00:15:26,070 --> 00:15:35,209
this much mechanism you can like totally

00:15:28,019 --> 00:15:38,279
smash it how to prevent it for example

00:15:35,209 --> 00:15:40,320
your API or the dependencies could

00:15:38,279 --> 00:15:43,019
return specific error codes which can

00:15:40,320 --> 00:15:45,390
tell you okay I'm overloaded don't

00:15:43,019 --> 00:15:48,570
repeat the request at all

00:15:45,390 --> 00:15:51,390
it won't help or okay I have some

00:15:48,570 --> 00:15:53,160
different kind of error you can repeat

00:15:51,390 --> 00:15:58,170
the request and we will see how it goes

00:15:53,160 --> 00:16:01,410
you can also set up some budgets what

00:15:58,170 --> 00:16:05,040
say that you will allow to some

00:16:01,410 --> 00:16:08,430
dependency repeat calls like 10 times in

00:16:05,040 --> 00:16:11,130
a minute so if you repeat it ten times

00:16:08,430 --> 00:16:13,230
in first 10 seconds it will just stop

00:16:11,130 --> 00:16:17,010
repeating it and give it like more time

00:16:13,230 --> 00:16:20,190
to recover or you can set up some

00:16:17,010 --> 00:16:22,620
idempotency mechanism for example you

00:16:20,190 --> 00:16:25,519
will get to your request header

00:16:22,620 --> 00:16:28,680
information which will tell the

00:16:25,519 --> 00:16:32,430
dependency that it's applicated request

00:16:28,680 --> 00:16:33,870
and app can like handle it properly it

00:16:32,430 --> 00:16:36,390
can help for example when you are

00:16:33,870 --> 00:16:39,750
manipulating the data you will see that

00:16:36,390 --> 00:16:41,670
you are sending the same request over

00:16:39,750 --> 00:16:43,800
they for example have been handled

00:16:41,670 --> 00:16:50,060
somehow so we will just return some

00:16:43,800 --> 00:16:54,089
error that is already as resolved and

00:16:50,060 --> 00:16:56,550
quick thing also if you don't have to do

00:16:54,089 --> 00:16:59,040
anything like synchronously for example

00:16:56,550 --> 00:17:01,410
again Europe you are receiving orders

00:16:59,040 --> 00:17:04,650
you want to see some confirmation email

00:17:01,410 --> 00:17:07,709
or something you can just put a request

00:17:04,650 --> 00:17:10,350
to some Q shuttle some task which will

00:17:07,709 --> 00:17:13,200
be handled async and

00:17:10,350 --> 00:17:15,030
the system will go like faster smoother

00:17:13,200 --> 00:17:19,710
because it doesn't have to perform the

00:17:15,030 --> 00:17:21,710
action synchronously also what is

00:17:19,710 --> 00:17:25,070
important on the other hand not to

00:17:21,710 --> 00:17:27,780
overcomplicate the system like to apply

00:17:25,070 --> 00:17:31,200
several of these mechanisms on several

00:17:27,780 --> 00:17:34,260
layers you may end up that somewhere

00:17:31,200 --> 00:17:38,940
will follow like how part of the trace

00:17:34,260 --> 00:17:42,000
back or some exception may not bubble up

00:17:38,940 --> 00:17:46,080
for some reason so you may have like

00:17:42,000 --> 00:17:48,450
hidden errors or partial informations or

00:17:46,080 --> 00:17:54,390
you can receive some error more times if

00:17:48,450 --> 00:17:59,130
you don't handle it properly okay and

00:17:54,390 --> 00:18:01,800
one more technique in our company we

00:17:59,130 --> 00:18:03,780
have developed and developed some system

00:18:01,800 --> 00:18:07,140
of Diagnostics or a repair we call it

00:18:03,780 --> 00:18:09,150
and it's in case that you have some

00:18:07,140 --> 00:18:13,860
communication that you actually want to

00:18:09,150 --> 00:18:18,180
do as synchronously information you need

00:18:13,860 --> 00:18:20,880
but in case it happens it's like okay

00:18:18,180 --> 00:18:24,270
ish to do it asynchronously after a few

00:18:20,880 --> 00:18:27,000
minutes so we have some system that

00:18:24,270 --> 00:18:29,340
perfectly checks this system for

00:18:27,000 --> 00:18:32,520
inconsistencies and based on that we

00:18:29,340 --> 00:18:34,590
will automatically fix them for example

00:18:32,520 --> 00:18:37,590
you are calling some dependencies

00:18:34,590 --> 00:18:40,110
internally it will start time outing so

00:18:37,590 --> 00:18:44,040
you can have some site the job that will

00:18:40,110 --> 00:18:48,360
actually pull the system for for the

00:18:44,040 --> 00:18:51,210
results of those actions and handle the

00:18:48,360 --> 00:18:53,430
information properly in the system it

00:18:51,210 --> 00:18:56,670
also helped us a few times with some

00:18:53,430 --> 00:18:59,490
buggy releases we have released some bug

00:18:56,670 --> 00:19:02,730
but the system like discovered some

00:18:59,490 --> 00:19:05,430
inconsistencies automatically fix it so

00:19:02,730 --> 00:19:07,650
we actually saw the errors we could

00:19:05,430 --> 00:19:12,080
handle it and there was like no damage

00:19:07,650 --> 00:19:12,080
done because the system outer healed

00:19:14,710 --> 00:19:19,840
so when we know what dependencies we

00:19:18,160 --> 00:19:24,430
have and how to handle them

00:19:19,840 --> 00:19:27,820
it's also really important to monitor it

00:19:24,430 --> 00:19:31,150
I was working once in a company and we

00:19:27,820 --> 00:19:33,490
have developed some issue and once

00:19:31,150 --> 00:19:38,110
somebody contacted us that we are

00:19:33,490 --> 00:19:41,500
selling something really cheap so we

00:19:38,110 --> 00:19:45,430
were like firm start happy that yeah we

00:19:41,500 --> 00:19:48,220
are above all the concurrence but then

00:19:45,430 --> 00:19:51,790
we dig out that we already selling it

00:19:48,220 --> 00:19:53,950
too cheap and we found out that there

00:19:51,790 --> 00:19:59,110
was some service calling the currency

00:19:53,950 --> 00:20:00,640
rates from a bank but it got broken in

00:19:59,110 --> 00:20:04,570
some time and the currency rates were

00:20:00,640 --> 00:20:06,490
not updated for a few weeks and there

00:20:04,570 --> 00:20:08,820
was in one country like bad political

00:20:06,490 --> 00:20:11,290
situation and the current cigarettes

00:20:08,820 --> 00:20:14,860
changed a little bit so we were selling

00:20:11,290 --> 00:20:19,540
it like cheaper like under price in some

00:20:14,860 --> 00:20:26,950
market so it was a little bit painful at

00:20:19,540 --> 00:20:28,600
the time so it's important to know what

00:20:26,950 --> 00:20:31,480
is actually happening in your system

00:20:28,600 --> 00:20:33,580
let's say you have a system that has

00:20:31,480 --> 00:20:37,210
like a dozen of dependencies something

00:20:33,580 --> 00:20:39,370
clashes down and you have to go to the

00:20:37,210 --> 00:20:42,880
system and see what is happening what

00:20:39,370 --> 00:20:45,550
exactly went down so you can monitor all

00:20:42,880 --> 00:20:49,390
of these resources measure responses

00:20:45,550 --> 00:20:51,750
times the errors it returns connection

00:20:49,390 --> 00:20:56,190
counts should pause writes

00:20:51,750 --> 00:20:57,960
if so SQL queries you can go deeper

00:20:56,190 --> 00:21:00,790
debug likes

00:20:57,960 --> 00:21:04,060
queries in post grab if you don't know

00:21:00,790 --> 00:21:06,100
the explained command you should

00:21:04,060 --> 00:21:10,480
definitely check it which can give you

00:21:06,100 --> 00:21:13,900
like details about execution plans of

00:21:10,480 --> 00:21:15,850
your SQL queries you may found out there

00:21:13,900 --> 00:21:18,340
is like something really inefficient and

00:21:15,850 --> 00:21:20,950
under a little bit heavier load it can

00:21:18,340 --> 00:21:26,260
actually like smash your database on

00:21:20,950 --> 00:21:26,909
deplete CPU or whatever you can install

00:21:26,260 --> 00:21:31,859
in your

00:21:26,909 --> 00:21:37,049
tighten up some IPA APM that way like

00:21:31,859 --> 00:21:39,450
for a very small work give you a really

00:21:37,049 --> 00:21:42,509
nice overview what is happening in your

00:21:39,450 --> 00:21:47,429
app you have like Boris or some

00:21:42,509 --> 00:21:52,049
marketing by default about accounts your

00:21:47,429 --> 00:21:54,869
API is doing overall database or

00:21:52,049 --> 00:21:56,879
already's or whatever and it can give

00:21:54,869 --> 00:21:59,639
you like great insight into your

00:21:56,879 --> 00:22:02,009
application and you will be surprised

00:21:59,639 --> 00:22:07,889
what is happening inside and how can you

00:22:02,009 --> 00:22:12,869
like debug it an example of monitoring

00:22:07,889 --> 00:22:15,629
is defined some pink endpoint also real

00:22:12,869 --> 00:22:17,879
a simple thing you'll actually use some

00:22:15,629 --> 00:22:20,700
third-party service that will radically

00:22:17,879 --> 00:22:22,679
check if your application is alive

00:22:20,700 --> 00:22:24,960
so it's good that it's not like part of

00:22:22,679 --> 00:22:27,690
your infrastructure it's something that

00:22:24,960 --> 00:22:31,349
could do the guys from the the first

00:22:27,690 --> 00:22:33,359
story and when you are doing the pink

00:22:31,349 --> 00:22:36,450
endpoint you should also define what

00:22:33,359 --> 00:22:39,289
does it even mean that your application

00:22:36,450 --> 00:22:42,450
is healthy so the pink endpoint could

00:22:39,289 --> 00:22:44,849
query database release or check some

00:22:42,450 --> 00:22:46,649
other dependencies to tell that your

00:22:44,849 --> 00:22:51,330
application is actually a life not just

00:22:46,649 --> 00:22:55,769
returning some dummy responses next

00:22:51,330 --> 00:22:59,759
level monitoring is always say that your

00:22:55,769 --> 00:23:02,539
application is okay but you can go a

00:22:59,759 --> 00:23:06,269
little bit further for example you may

00:23:02,539 --> 00:23:09,809
monitor the functionality not just your

00:23:06,269 --> 00:23:11,820
API call is healthy but something that

00:23:09,809 --> 00:23:14,940
was supposed to be happened actually

00:23:11,820 --> 00:23:19,440
happened for example if you process

00:23:14,940 --> 00:23:23,340
order you will send some statistics okay

00:23:19,440 --> 00:23:26,239
we have somebody purchased a TV in

00:23:23,340 --> 00:23:29,549
Germany and Sandra statistics somewhere

00:23:26,239 --> 00:23:32,369
it will not tell you the reason in case

00:23:29,549 --> 00:23:34,559
you are stopped selling televisions like

00:23:32,369 --> 00:23:36,299
what exactly happened but you will have

00:23:34,559 --> 00:23:39,520
some impulse that

00:23:36,299 --> 00:23:41,119
give you that it will be given to check

00:23:39,520 --> 00:23:43,649
[Music]

00:23:41,119 --> 00:23:46,950
for some issues let's say your

00:23:43,649 --> 00:23:50,459
application is like 100% okay but some

00:23:46,950 --> 00:23:53,609
firewall or something can like block the

00:23:50,459 --> 00:23:56,159
traffic or you can see that some

00:23:53,609 --> 00:24:03,979
datacenter just went down and you were

00:23:56,159 --> 00:24:09,079
cut of the traffic or something oh yeah

00:24:03,979 --> 00:24:14,029
what happened for example in our company

00:24:09,079 --> 00:24:16,919
we were we are selling high ticket and

00:24:14,029 --> 00:24:21,089
one evening we were we had this

00:24:16,919 --> 00:24:23,579
monitoring and we've been alerted like

00:24:21,089 --> 00:24:27,059
we are so linked maybe too much of the

00:24:23,579 --> 00:24:30,869
tickets so we are investigating it for

00:24:27,059 --> 00:24:32,190
hours we couldn't fight anything and we

00:24:30,869 --> 00:24:34,499
were selling more and more and we

00:24:32,190 --> 00:24:38,459
couldn't see the reason but would

00:24:34,499 --> 00:24:41,369
actually happened one bank I think it

00:24:38,459 --> 00:24:43,049
was in Indonesia they were charging

00:24:41,369 --> 00:24:47,489
actually the bank was charging customer

00:24:43,049 --> 00:24:49,559
only 1% of the price so we had

00:24:47,489 --> 00:24:53,570
information correct information about

00:24:49,559 --> 00:24:56,989
pricing but somewhere the bank had

00:24:53,570 --> 00:25:00,599
somebody release and actually starting

00:24:56,989 --> 00:25:03,929
charging customer less so everyone

00:25:00,599 --> 00:25:07,399
started buying this product and we

00:25:03,929 --> 00:25:09,779
couldn't find like the reason in time

00:25:07,399 --> 00:25:12,419
but if we didn't have this monitoring

00:25:09,779 --> 00:25:14,070
why couldn't image could be like much

00:25:12,419 --> 00:25:16,380
bigger because the banks eventually

00:25:14,070 --> 00:25:23,970
charge the customer and we hand

00:25:16,380 --> 00:25:26,250
the refund process also when you have a

00:25:23,970 --> 00:25:28,710
set of these metrics we currently in

00:25:26,250 --> 00:25:32,429
company have like hundreds of sake

00:25:28,710 --> 00:25:38,220
metrics so we have a team of analytics

00:25:32,429 --> 00:25:41,039
that are actually building some apps on

00:25:38,220 --> 00:25:43,380
top of it for detecting some anomalies

00:25:41,039 --> 00:25:45,570
which can give you like some impulse or

00:25:43,380 --> 00:25:51,090
inside that something is actually

00:25:45,570 --> 00:25:52,470
getting wrong and if I think from these

00:25:51,090 --> 00:25:58,799
helps there is usually something that

00:25:52,470 --> 00:26:02,340
will report you the error so when you

00:25:58,799 --> 00:26:07,620
have everything every dependency checked

00:26:02,340 --> 00:26:10,890
when you send information about it like

00:26:07,620 --> 00:26:14,070
if you have monitoring setup the next

00:26:10,890 --> 00:26:16,650
step is actually set up proper alerting

00:26:14,070 --> 00:26:18,990
it's nice to know that somewhere you

00:26:16,650 --> 00:26:23,070
have information that Redis is time

00:26:18,990 --> 00:26:27,510
mounting but you should be our tits to

00:26:23,070 --> 00:26:31,830
actually be able to take an action so if

00:26:27,510 --> 00:26:34,669
you if you have any monitors you can set

00:26:31,830 --> 00:26:38,549
up proper alerting you can set up

00:26:34,669 --> 00:26:41,539
responsible people for the arts for each

00:26:38,549 --> 00:26:45,030
of those like check the appropriate

00:26:41,539 --> 00:26:49,860
channel for the art if it's something

00:26:45,030 --> 00:26:53,880
like really important zero or some phone

00:26:49,860 --> 00:26:57,929
call also escalation policies in case

00:26:53,880 --> 00:27:03,539
like somebody is not able to respond to

00:26:57,929 --> 00:27:06,450
this alert also the really basic stuff

00:27:03,539 --> 00:27:09,330
you probably off you know we're all bar

00:27:06,450 --> 00:27:12,750
or a sentry or some error reporting to

00:27:09,330 --> 00:27:15,630
will just basically wrap your Python

00:27:12,750 --> 00:27:18,059
application and report the errors to

00:27:15,630 --> 00:27:24,780
some system and based on that you can be

00:27:18,059 --> 00:27:27,289
alerted again yeah so when you have

00:27:24,780 --> 00:27:31,559
monitoring and

00:27:27,289 --> 00:27:34,770
proper alert King next step is to check

00:27:31,559 --> 00:27:38,370
out if you have proper logging let's say

00:27:34,770 --> 00:27:41,730
we are elected but you should be all the

00:27:38,370 --> 00:27:44,460
time be able to to get details what is

00:27:41,730 --> 00:27:47,880
actually happening in your app if you

00:27:44,460 --> 00:27:50,309
are unlink communication with the

00:27:47,880 --> 00:27:51,120
resources above you know that we already

00:27:50,309 --> 00:27:53,840
went through

00:27:51,120 --> 00:27:57,539
you should think ok what happens if

00:27:53,840 --> 00:28:01,740
communication with this API Falls will I

00:27:57,539 --> 00:28:05,460
have some information to get details

00:28:01,740 --> 00:28:07,860
like instantly or not so everything

00:28:05,460 --> 00:28:12,179
should be like locked properly in case

00:28:07,860 --> 00:28:17,090
it makes sense in one of the companies

00:28:12,179 --> 00:28:20,400
we've been building for example CRM and

00:28:17,090 --> 00:28:23,370
one of the colleagues was working on the

00:28:20,400 --> 00:28:28,620
kora and there was like a relic called a

00:28:23,370 --> 00:28:33,539
database table and he made he was using

00:28:28,620 --> 00:28:38,039
primary key as count of the entries was

00:28:33,539 --> 00:28:40,890
one so he didn't do some sequence or

00:28:38,039 --> 00:28:43,620
auto increment and it was like working

00:28:40,890 --> 00:28:46,260
well til somebody removed the user from

00:28:43,620 --> 00:28:48,840
the database and cascade delete like

00:28:46,260 --> 00:28:52,620
delete a bunch of records and there was

00:28:48,840 --> 00:28:54,960
a huge mess in a database so the first

00:28:52,620 --> 00:28:58,669
thing when we noticed what do we want to

00:28:54,960 --> 00:29:02,880
do was to restore a backup of database

00:28:58,669 --> 00:29:05,280
we couldn't do that because our server

00:29:02,880 --> 00:29:09,059
provider had some outage and they didn't

00:29:05,280 --> 00:29:11,850
store our backups for a week or two so

00:29:09,059 --> 00:29:14,039
we spent several days of parsing his

00:29:11,850 --> 00:29:17,909
logs and reconstructing the database

00:29:14,039 --> 00:29:20,100
from it which was like really how things

00:29:17,909 --> 00:29:23,460
to do we didn't have like that grid

00:29:20,100 --> 00:29:24,870
logging to do it's like better way but

00:29:23,460 --> 00:29:29,240
at least we had something because

00:29:24,870 --> 00:29:29,240
otherwise it would be really screwed up

00:29:29,510 --> 00:29:35,650
yeah so proper logging we

00:29:32,440 --> 00:29:38,020
make your debugging like much easier you

00:29:35,650 --> 00:29:41,590
may consider storing importation

00:29:38,020 --> 00:29:44,890
important in foreign database to get

00:29:41,590 --> 00:29:50,590
like better statistics over it like more

00:29:44,890 --> 00:29:53,530
into detail or also consider adding

00:29:50,590 --> 00:29:55,690
request ID at work so you can Ballack

00:29:53,530 --> 00:29:59,280
together works from more different

00:29:55,690 --> 00:29:59,280
layers of logging

00:30:01,060 --> 00:30:07,900
so next step if you have everything

00:30:05,220 --> 00:30:11,460
handled properly you know if you are a

00:30:07,900 --> 00:30:14,710
partner if your infrastructure is that

00:30:11,460 --> 00:30:19,390
you need to put it somewhere so it's

00:30:14,710 --> 00:30:21,700
usually about the price or laziness and

00:30:19,390 --> 00:30:28,810
the features provided you can go with

00:30:21,700 --> 00:30:32,020
your own servers you can use hosting or

00:30:28,810 --> 00:30:36,010
cloud services and recently becoming

00:30:32,020 --> 00:30:38,740
more popular some service solutions for

00:30:36,010 --> 00:30:41,320
example on a VM that you can deploy like

00:30:38,740 --> 00:30:46,000
hello world app child writing these two

00:30:41,320 --> 00:30:48,430
lines and defining API endpoint in some

00:30:46,000 --> 00:30:52,030
way and everything isn't for you how to

00:30:48,430 --> 00:30:54,820
scaling and servers and basically

00:30:52,030 --> 00:30:57,370
everything you need just two lines of

00:30:54,820 --> 00:31:03,400
code which is like really convenient for

00:30:57,370 --> 00:31:06,610
some smaller services ok also consider

00:31:03,400 --> 00:31:09,550
auto scaling what happens that the load

00:31:06,610 --> 00:31:12,100
of your application like grows a little

00:31:09,550 --> 00:31:15,160
bit like your CPU or something is

00:31:12,100 --> 00:31:17,260
getting depleted usually in cloud

00:31:15,160 --> 00:31:19,390
services you can set up outer scaling

00:31:17,260 --> 00:31:23,860
policy to would have more servers or

00:31:19,390 --> 00:31:26,320
containers also consider like if one of

00:31:23,860 --> 00:31:29,760
the server's goes down what will happen

00:31:26,320 --> 00:31:32,980
you cannot restore them put up some

00:31:29,760 --> 00:31:35,610
other servers for example in different

00:31:32,980 --> 00:31:35,610
data center

00:31:37,620 --> 00:31:43,389
a few things that you can do for helping

00:31:40,919 --> 00:31:46,899
reliability of your app you can do also

00:31:43,389 --> 00:31:52,629
on web server for example also repeater

00:31:46,899 --> 00:31:54,399
on nginx level so if your request will

00:31:52,629 --> 00:31:56,409
file it will be automatically repeated

00:31:54,399 --> 00:31:59,799
and you don't have to touch anything in

00:31:56,409 --> 00:32:03,129
your app setup caching to help if it'll

00:31:59,799 --> 00:32:05,289
load you can proceed with Application

00:32:03,129 --> 00:32:09,580
Firewall that will give you like more

00:32:05,289 --> 00:32:11,049
features that can like may your app it's

00:32:09,580 --> 00:32:15,460
a bit more stable and you don't have to

00:32:11,049 --> 00:32:17,799
care about something on app level also

00:32:15,460 --> 00:32:20,409
when you develop ink you may consider

00:32:17,799 --> 00:32:23,730
like separated environments for

00:32:20,409 --> 00:32:31,119
development stage production testing

00:32:23,730 --> 00:32:32,730
also you have more layers of testing you

00:32:31,119 --> 00:32:36,970
can put your continuous integration

00:32:32,730 --> 00:32:41,499
smoke test integration test unit test

00:32:36,970 --> 00:32:45,669
you can try to send how some part of the

00:32:41,499 --> 00:32:48,669
traffic to some kind of instance it will

00:32:45,669 --> 00:32:52,509
be a basically release candidate so in

00:32:48,669 --> 00:32:53,980
case you are like not 100% sure that the

00:32:52,509 --> 00:32:55,960
Nereus will be okay

00:32:53,980 --> 00:32:59,320
you can test it in partially and some

00:32:55,960 --> 00:33:04,779
part of the traffic you can apply the

00:32:59,320 --> 00:33:06,490
performance test also when it comes to

00:33:04,779 --> 00:33:09,429
monitoring so far we've been talking

00:33:06,490 --> 00:33:11,769
just about application itself but the

00:33:09,429 --> 00:33:20,409
unit also might or the infrastructure

00:33:11,769 --> 00:33:23,049
itself yeah what can you also do with

00:33:20,409 --> 00:33:27,460
monitoring for example set up monitors

00:33:23,049 --> 00:33:31,899
on top of nginx you can be alerted you

00:33:27,460 --> 00:33:36,639
receive like a bunch of non 100-200

00:33:31,899 --> 00:33:38,980
requests in a row you have logs on a web

00:33:36,639 --> 00:33:42,269
server so you can define again a request

00:33:38,980 --> 00:33:45,719
ID populated to your app to join

00:33:42,269 --> 00:33:52,080
works together no more different levels

00:33:45,719 --> 00:33:55,080
of logging on runtime or companies

00:33:52,080 --> 00:33:58,080
bigger companies do actually simulates

00:33:55,080 --> 00:34:01,649
the outage you can turn off some data

00:33:58,080 --> 00:34:06,419
center or simulate that some dependency

00:34:01,649 --> 00:34:15,089
is down and see how actually your app is

00:34:06,419 --> 00:34:17,970
behaving if you do anything for

00:34:15,089 --> 00:34:20,760
preventing and your your app will

00:34:17,970 --> 00:34:23,329
actually have some knowledge it's

00:34:20,760 --> 00:34:26,099
usually good practice to write

00:34:23,329 --> 00:34:30,869
post-mortem after everything is resolved

00:34:26,099 --> 00:34:33,929
to actually get some log about what

00:34:30,869 --> 00:34:37,289
actually happened so you can learn from

00:34:33,929 --> 00:34:40,700
your files you will think deeply about

00:34:37,289 --> 00:34:45,690
what was actually happened you can apply

00:34:40,700 --> 00:34:48,599
the fixes for the current outage to

00:34:45,690 --> 00:34:50,789
other parts of the system because it can

00:34:48,599 --> 00:34:55,829
be vulnerable also you know to some

00:34:50,789 --> 00:35:00,960
issue and the key is like to keep track

00:34:55,829 --> 00:35:09,299
and get into a real cause of the

00:35:00,960 --> 00:35:13,410
problems so we went through some

00:35:09,299 --> 00:35:17,099
techniques how to prevent failing that

00:35:13,410 --> 00:35:21,210
can be applied on different levels of

00:35:17,099 --> 00:35:23,039
your application I mean you can do in

00:35:21,210 --> 00:35:30,750
Python code like timeouts breakers

00:35:23,039 --> 00:35:34,440
repeaters and yeah we've been we went to

00:35:30,750 --> 00:35:37,039
monitoring you should know like what you

00:35:34,440 --> 00:35:40,529
are actually using a monitor servers

00:35:37,039 --> 00:35:43,650
application from outside from different

00:35:40,529 --> 00:35:46,349
level of your application you can use a

00:35:43,650 --> 00:35:50,150
PMS and some custom functionality

00:35:46,349 --> 00:35:51,900
monitoring can play with it more deeply

00:35:50,150 --> 00:35:54,089
we have like

00:35:51,900 --> 00:35:59,160
a lot of different ways to test that

00:35:54,089 --> 00:36:02,130
your application is actually stable you

00:35:59,160 --> 00:36:04,710
should think of architecture there is

00:36:02,130 --> 00:36:07,890
like a lot of you can do about

00:36:04,710 --> 00:36:15,809
reliability or more different levels of

00:36:07,890 --> 00:36:18,539
your stack also which is really

00:36:15,809 --> 00:36:21,359
important the proper logging again you

00:36:18,539 --> 00:36:23,490
can apply it on more different layers

00:36:21,359 --> 00:36:26,970
and join them together to have really

00:36:23,490 --> 00:36:29,339
good overview what is happening inside

00:36:26,970 --> 00:36:32,150
not just to randomly attach your

00:36:29,339 --> 00:36:37,559
application when there is some outage

00:36:32,150 --> 00:36:41,069
and based on that also proper our think

00:36:37,559 --> 00:36:43,680
think of all the use cases for the

00:36:41,069 --> 00:36:46,230
others you set up if you know what we

00:36:43,680 --> 00:36:49,950
actually do with alert you will receive

00:36:46,230 --> 00:36:56,490
in advance how how to reach somebody who

00:36:49,950 --> 00:36:58,920
can handle it and I think it went a

00:36:56,490 --> 00:37:04,109
little bit faster than I expected

00:36:58,920 --> 00:37:04,880
so if you have some questions okay so

00:37:04,109 --> 00:37:08,039
anyone

00:37:04,880 --> 00:37:08,039
[Applause]

00:37:09,740 --> 00:37:16,440
so anyone having questions please come

00:37:12,300 --> 00:37:22,050
to the microphones by the way one also

00:37:16,440 --> 00:37:25,619
important thing our company is hosting a

00:37:22,050 --> 00:37:28,170
party tomorrow in a pub nearby so if you

00:37:25,619 --> 00:37:30,329
want to get free drinks or hang with

00:37:28,170 --> 00:37:32,730
people you can stop by

00:37:30,329 --> 00:37:46,410
Killick on boof and get some details or

00:37:32,730 --> 00:37:49,079
what it is just a second hi thanks for a

00:37:46,410 --> 00:37:52,790
year thanks ReadyTalk how do you know

00:37:49,079 --> 00:37:52,790
that your Manas monitoring system works

00:37:55,609 --> 00:38:03,900
you monitor it I suppose yes usually we

00:38:00,240 --> 00:38:07,260
have like more different levels of of

00:38:03,900 --> 00:38:12,060
monitoring so when we were thinking

00:38:07,260 --> 00:38:15,720
about the pinging of your application

00:38:12,060 --> 00:38:19,770
and I think that all of them would have

00:38:15,720 --> 00:38:21,569
to go down at the same time which is

00:38:19,770 --> 00:38:25,170
like the probabilities very slow because

00:38:21,569 --> 00:38:28,220
it's usually some for example some our

00:38:25,170 --> 00:38:32,880
cell hosting services or more different

00:38:28,220 --> 00:38:35,599
third parties within different data

00:38:32,880 --> 00:38:35,599
centers are

00:38:41,270 --> 00:38:47,060
yeah I saw some also about the

00:38:44,480 --> 00:38:51,460
consequences of not working in Europe

00:38:47,060 --> 00:38:51,460
and so it's like more different levels

00:38:58,349 --> 00:39:04,440
you mentioned the serverless there do

00:39:01,440 --> 00:39:06,990
you have any current for example a

00:39:04,440 --> 00:39:11,849
double yes do you have any kind of like

00:39:06,990 --> 00:39:14,940
metric on how many servers would be near

00:39:11,849 --> 00:39:16,769
for to get the same thing running in

00:39:14,940 --> 00:39:20,609
comparison to encircle for example I'm

00:39:16,769 --> 00:39:24,539
done server less sorry I I don't have

00:39:20,609 --> 00:39:28,109
like it was just recently starting

00:39:24,539 --> 00:39:31,079
playing with it so I don't have like any

00:39:28,109 --> 00:39:35,339
like deep insight to help you with this

00:39:31,079 --> 00:39:38,309
request but maybe we can if you want we

00:39:35,339 --> 00:39:40,259
can talk after you talk and I can ask

00:39:38,309 --> 00:39:41,369
some colleagues that have like a deep

00:39:40,259 --> 00:39:44,630
experiences with it

00:39:41,369 --> 00:39:44,630
cool thanks

00:39:50,620 --> 00:39:59,210
while before doing Python I have worked

00:39:53,180 --> 00:40:02,990
28 years in a bank in IT when you have a

00:39:59,210 --> 00:40:04,460
real incident I see that or the the

00:40:02,990 --> 00:40:06,320
combination channels when you have a

00:40:04,460 --> 00:40:10,130
real incident you really want to have a

00:40:06,320 --> 00:40:12,230
human in charge so I would suggest that

00:40:10,130 --> 00:40:15,020
as long as you have not talked with the

00:40:12,230 --> 00:40:16,940
human you're not sure that the alert has

00:40:15,020 --> 00:40:22,190
been taken into account especially when

00:40:16,940 --> 00:40:24,140
you're in escalation well it's my

00:40:22,190 --> 00:40:26,890
experience is that if there's no phone

00:40:24,140 --> 00:40:30,170
call you're not sure that somebody else

00:40:26,890 --> 00:40:33,320
yeah like usually it probably depends

00:40:30,170 --> 00:40:35,240
how important our it's and what is the

00:40:33,320 --> 00:40:37,580
response time you need if it's something

00:40:35,240 --> 00:40:40,610
like I said like definitely go with

00:40:37,580 --> 00:40:44,510
phone call anything sometimes okay just

00:40:40,610 --> 00:40:46,730
to Allerton some secondary system and

00:40:44,510 --> 00:40:48,470
it's okay if it's handled like in 30

00:40:46,730 --> 00:40:52,610
minutes because it's not becoming

00:40:48,470 --> 00:40:55,070
critical yet but I agree I definitely

00:40:52,610 --> 00:40:57,290
it's critical just go with phone and art

00:40:55,070 --> 00:41:01,880
anybody you can and do the best to reach

00:40:57,290 --> 00:41:04,340
the appropriate people hi

00:41:01,880 --> 00:41:06,410
I've got a question about mapping out

00:41:04,340 --> 00:41:08,690
dependencies because the human tation is

00:41:06,410 --> 00:41:11,180
all great but do you have any automated

00:41:08,690 --> 00:41:13,610
tools that will allow you to like make a

00:41:11,180 --> 00:41:20,000
graph of dependencies with some

00:41:13,610 --> 00:41:23,510
calculations and so on currently I think

00:41:20,000 --> 00:41:26,540
some of our teams like working with

00:41:23,510 --> 00:41:28,910
called formation and societies like to

00:41:26,540 --> 00:41:34,130
get all of these together to one place

00:41:28,910 --> 00:41:35,330
but I think that there is some solution

00:41:34,130 --> 00:41:38,630
being developed that could be like

00:41:35,330 --> 00:41:40,490
potentially open-source but it's

00:41:38,630 --> 00:41:42,020
definitely not in the stage that we

00:41:40,490 --> 00:41:45,550
could provide I think and I don't know

00:41:42,020 --> 00:41:47,650
about anything like that could I

00:41:45,550 --> 00:41:52,270
he'll pivot is faithful a little bit

00:41:47,650 --> 00:41:55,320
tricky often if you have like services

00:41:52,270 --> 00:41:55,320
on more different

00:41:55,500 --> 00:42:02,900
Hosting's thank you very much for

00:42:00,940 --> 00:42:07,659
everyone

00:42:02,900 --> 00:42:07,659

YouTube URL: https://www.youtube.com/watch?v=JbZZlpEY3iA


