Title: Almar Klein - Let’s embrace WebAssembly!
Publication date: 2018-08-22
Playlist: EuroPython 2018
Description: 
	Let’s embrace WebAssembly!
[EuroPython 2018 - Talk - 2018-07-25 - Lammermuir]
[Edinburgh, UK]

By Almar Klein

WebAssembly (WASM) is an open, low level binary format designed to be compact and run at native speed, while being memory-safe. WASM is primarily intended to run code in browsers, but its by no means limited to this. This makes it an interesting intermediate language (IR); code that compiles to WASM will (in the future) run basically anywhere. In short: WASM is coming and its great!

Unsurprisingly, WASM is being embraced by many communities, such as C++, Rust, Lua, and .NET. Sadly, there does not seem to be a lot of enthusiasm from the Python community yet…

Perhaps this is because Python is interpreted and can therefore not (easily) use WASM as a compilation target. It should be possible to compile a Python interpreter (like CPython or Pypy) to WASM and thereby run Python code in a browser. But the result would be pretty heavy-weight, so it would arguably not be a very practical.

Within the PPCI project (a pure Python compiler infrastructure) tooling has been developed to load, inspect, compile and even run WASM modules. This allows combining WASM and Python in new ways. In this talk we discuss two approaches by which the Python community might embrace WASM. 

Firstly, various projects already exist that compile Python functions to other languages (e.g. Numba, PScript), and we have type annotations. If Python functions would be compiled to WASM, the resulting code would run in any WASM runtime (e.g. the browser). This will be demonstrated with an example, for which the resulting code can be run either in a browser or inside Python itself. In either case, it’s pretty darn fast.

Secondly, rather than em using /em WASM, it might be interesting for Python to function as a platform to em run /em  and 
 em bind /em  WASM modules. Two of Python’s greater strengths are its rich ecosystem and its ability to glue things together. Let’s build on that! Imagine creating an application that consists of multiple WASM modules, perhaps compiled from different languages, and binding these together into a single Python app.

This will be demonstrated with a game, which is written in Rust, compiled to WASM, and running inside a Python process. The WASM module consumes a drawing API, which is in this case provided by Python, and Python feeds the WASM module with user input.

I hope that this talk inspires other Pythonistas to think about the advantages that WASM can bring to our ecosystem, and also about the role that Python can play in the growing WASM ecosystem.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2018.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:00,150 --> 00:00:07,710
[Applause]

00:00:04,730 --> 00:00:12,690
okay so how many of you already know

00:00:07,710 --> 00:00:15,599
what webassembly is it's pretty good um

00:00:12,690 --> 00:00:18,630
I really have two things to say in this

00:00:15,599 --> 00:00:20,640
talk and that is that one webassembly is

00:00:18,630 --> 00:00:23,609
awesome and it's not limited to the web

00:00:20,640 --> 00:00:25,800
and the other is that I think that we

00:00:23,609 --> 00:00:26,880
should explore ways to combine web

00:00:25,800 --> 00:00:28,980
assembly and peyten

00:00:26,880 --> 00:00:31,529
because there is a lot of interesting

00:00:28,980 --> 00:00:33,899
opportunities there and in this talk I

00:00:31,529 --> 00:00:36,270
will demonstrate three ways in which we

00:00:33,899 --> 00:00:40,440
can do that but let's start at the

00:00:36,270 --> 00:00:43,320
beginning so first get this out of the

00:00:40,440 --> 00:00:46,170
way web assembly is often abbreviated as

00:00:43,320 --> 00:00:48,270
W ASM and these are just one in the same

00:00:46,170 --> 00:00:51,420
thing and I'll use both terms in this

00:00:48,270 --> 00:00:54,539
talk so web assembly is an open standard

00:00:51,420 --> 00:00:57,390
so it's being developed by people from

00:00:54,539 --> 00:00:59,750
Mozilla Google Microsoft and even Apple

00:00:57,390 --> 00:01:03,300
so all the big names are on board and

00:00:59,750 --> 00:01:06,330
it's an standards for representing

00:01:03,300 --> 00:01:08,729
executable code at a very low level so

00:01:06,330 --> 00:01:13,590
the codes that it represents is going to

00:01:08,729 --> 00:01:17,130
execute at more or less native speed so

00:01:13,590 --> 00:01:20,610
in the classic way that's a programming

00:01:17,130 --> 00:01:21,930
language works like rust or C you have

00:01:20,610 --> 00:01:24,570
this programming language which is

00:01:21,930 --> 00:01:26,549
designed to be readable by humans a

00:01:24,570 --> 00:01:28,409
computer cannot execute that code

00:01:26,549 --> 00:01:30,869
directly it is first compiled to machine

00:01:28,409 --> 00:01:35,400
codes and these are the instructions

00:01:30,869 --> 00:01:37,530
that the computer will execute if a

00:01:35,400 --> 00:01:40,680
programming language wants to be able to

00:01:37,530 --> 00:01:42,600
work on different platforms or even on

00:01:40,680 --> 00:01:45,270
different operating systems on the same

00:01:42,600 --> 00:01:47,970
hardware you need to compile it and you

00:01:45,270 --> 00:01:49,770
need different compilers basically and

00:01:47,970 --> 00:01:53,280
what webassembly does it's it's just

00:01:49,770 --> 00:01:55,799
like in between of that it's a very low

00:01:53,280 --> 00:01:58,079
level representation of code but it's

00:01:55,799 --> 00:02:00,360
just high-level enough so that it does

00:01:58,079 --> 00:02:02,700
make very little assumptions about the

00:02:00,360 --> 00:02:06,810
underlying hardware that makes that it

00:02:02,700 --> 00:02:11,039
can be used as a generic machine code so

00:02:06,810 --> 00:02:13,180
to say and this last step of compilation

00:02:11,039 --> 00:02:15,129
to go from web assembly

00:02:13,180 --> 00:02:17,079
to the actual machine code of the

00:02:15,129 --> 00:02:19,420
current machine that you're running on

00:02:17,079 --> 00:02:21,579
is the responsibility of the

00:02:19,420 --> 00:02:23,920
environments that runs the web assembly

00:02:21,579 --> 00:02:26,950
module so most cases that would be the

00:02:23,920 --> 00:02:28,510
browser so you load a web assembly

00:02:26,950 --> 00:02:30,159
module in your browser at the moment

00:02:28,510 --> 00:02:33,760
that is instantiated it will do the

00:02:30,159 --> 00:02:37,000
compiling for you and all major browsers

00:02:33,760 --> 00:02:41,500
can do that for about a year now so you

00:02:37,000 --> 00:02:44,889
can already use web assembly so carrying

00:02:41,500 --> 00:02:48,010
on so web assembly is also designed to

00:02:44,889 --> 00:02:52,180
be very compact so the resulting

00:02:48,010 --> 00:02:55,359
binaries are very memory efficient at

00:02:52,180 --> 00:02:58,120
the same time web assembly comes with a

00:02:55,359 --> 00:03:00,099
human readable representation and

00:02:58,120 --> 00:03:01,989
there's a one-to-one relationship

00:03:00,099 --> 00:03:04,900
between the two so you can always turn

00:03:01,989 --> 00:03:06,639
the binary representation into the text

00:03:04,900 --> 00:03:08,950
representation and the other way around

00:03:06,639 --> 00:03:12,819
that's a great feature for instance when

00:03:08,950 --> 00:03:15,519
you're debugging and last but not least

00:03:12,819 --> 00:03:18,099
web assembly is also safe it's being

00:03:15,519 --> 00:03:20,889
designed primarily to run in the browser

00:03:18,099 --> 00:03:22,629
and you don't want any random web

00:03:20,889 --> 00:03:27,190
applications to be able to crash your

00:03:22,629 --> 00:03:29,139
web page let alone your system so web

00:03:27,190 --> 00:03:31,510
assembly is designed in such a way so

00:03:29,139 --> 00:03:37,299
that the codes can be validated to great

00:03:31,510 --> 00:03:39,430
extent at the compile stage so all in

00:03:37,299 --> 00:03:41,889
all there's a lot of Awesomeness in web

00:03:39,430 --> 00:03:44,379
assembly and it comes to no surprise

00:03:41,889 --> 00:03:47,439
that webassembly is being adopted by

00:03:44,379 --> 00:03:49,120
many open-source communities for

00:03:47,439 --> 00:03:51,009
instance the Lua community they are very

00:03:49,120 --> 00:03:54,250
excited because they now can write web

00:03:51,009 --> 00:03:55,810
apps in newer the russ community is very

00:03:54,250 --> 00:03:58,120
excited because they just want to write

00:03:55,810 --> 00:04:01,090
everything and rest including things for

00:03:58,120 --> 00:04:03,489
the web I've even seen people get

00:04:01,090 --> 00:04:08,769
excited about being able to write web

00:04:03,489 --> 00:04:10,299
apps in C++ the JavaScript community may

00:04:08,769 --> 00:04:12,579
be a bit different I think it depends on

00:04:10,299 --> 00:04:16,539
who you ask they all either see it as

00:04:12,579 --> 00:04:19,209
their salvation or as a threat but in

00:04:16,539 --> 00:04:21,190
all seriousness web assembly will not

00:04:19,209 --> 00:04:22,889
replace JavaScript JavaScript will

00:04:21,190 --> 00:04:25,960
probably be around for quite some time

00:04:22,889 --> 00:04:26,620
but what web assembly will do is bring

00:04:25,960 --> 00:04:28,389
an end

00:04:26,620 --> 00:04:32,620
the monopoly that JavaScript his

00:04:28,389 --> 00:04:35,400
JavaScript has in browser so then the

00:04:32,620 --> 00:04:37,570
part in community that's us

00:04:35,400 --> 00:04:40,540
there doesn't seem to be a lot of

00:04:37,570 --> 00:04:42,340
enthusiasm from our size at least I have

00:04:40,540 --> 00:04:44,800
not seen a lot of things I've heard a

00:04:42,340 --> 00:04:47,229
few things seeing seen a few things this

00:04:44,800 --> 00:04:50,650
morning I actually heard that the seitan

00:04:47,229 --> 00:04:53,590
team is trying out some things with it

00:04:50,650 --> 00:04:55,540
which is very exciting but for us

00:04:53,590 --> 00:04:59,520
there's not a not a lot happening it

00:04:55,540 --> 00:05:03,240
seems and maybe this makes sense because

00:04:59,520 --> 00:05:05,500
all these statically compiled languages

00:05:03,240 --> 00:05:09,039
it's pretty straightforward for them

00:05:05,500 --> 00:05:11,139
instead of no compiling to x86 or

00:05:09,039 --> 00:05:13,300
whatever they compile to web assembly

00:05:11,139 --> 00:05:15,280
and then they can render applications on

00:05:13,300 --> 00:05:16,960
the web of course there's some things

00:05:15,280 --> 00:05:19,630
that you have to do it's not easy but

00:05:16,960 --> 00:05:21,490
it's pretty straightforward a part in is

00:05:19,630 --> 00:05:23,380
an interpreted language so it's

00:05:21,490 --> 00:05:25,510
different we cannot do it in that way

00:05:23,380 --> 00:05:27,789
and also fighting is a bit weird because

00:05:25,510 --> 00:05:29,289
we have this ecosystem with a lot we

00:05:27,789 --> 00:05:30,610
have site and we have number there's a

00:05:29,289 --> 00:05:33,039
lot of weird things that we're doing

00:05:30,610 --> 00:05:36,930
with with our language so it's not very

00:05:33,039 --> 00:05:40,060
obvious where we can use web assembly

00:05:36,930 --> 00:05:43,000
nevertheless I think there are several

00:05:40,060 --> 00:05:46,720
ways in which we can make use of web

00:05:43,000 --> 00:05:51,669
assembly and I will demonstrate or

00:05:46,720 --> 00:05:53,020
mention free use cases in this talk so

00:05:51,669 --> 00:05:56,110
this is probably a good time to

00:05:53,020 --> 00:05:58,690
introduce PPC I so people saw is a

00:05:56,110 --> 00:06:01,870
project by Windell Bauman who sits over

00:05:58,690 --> 00:06:04,599
there and he has worked very hard for

00:06:01,870 --> 00:06:07,000
several years on making a pure parts and

00:06:04,599 --> 00:06:09,520
compiler infrastructure so that's a set

00:06:07,000 --> 00:06:12,550
of compilers and tooling written in pure

00:06:09,520 --> 00:06:14,349
Python it's completely crazy but it's

00:06:12,550 --> 00:06:17,590
very nice because it's very hackable and

00:06:14,349 --> 00:06:19,599
last year window and I met and I was

00:06:17,590 --> 00:06:21,550
giving a talk at Euro side by about web

00:06:19,599 --> 00:06:23,620
assembly and we sort of caught up and

00:06:21,550 --> 00:06:26,169
we've collaborated over the past year to

00:06:23,620 --> 00:06:29,310
bring support for web assembly to this

00:06:26,169 --> 00:06:32,050
library and in this talk I'll be using

00:06:29,310 --> 00:06:34,320
that library to do for in some of the

00:06:32,050 --> 00:06:34,320
demos

00:06:36,380 --> 00:06:40,710
so the first use guys I don't have any

00:06:39,180 --> 00:06:42,120
any demos for this but I think it's

00:06:40,710 --> 00:06:43,710
definitely worth mentioning but because

00:06:42,120 --> 00:06:45,420
it's probably the first thing that comes

00:06:43,710 --> 00:06:48,600
to mind when you think about peyten

00:06:45,420 --> 00:06:51,000
and webassembly and this is let's

00:06:48,600 --> 00:06:51,630
compile a Python interpreter to

00:06:51,000 --> 00:06:53,520
webassembly

00:06:51,630 --> 00:06:55,590
for instance take the source code of c

00:06:53,520 --> 00:06:57,330
peyten compiler to webassembly

00:06:55,590 --> 00:07:01,020
and then you can run it in a web and as

00:06:57,330 --> 00:07:03,600
you can and therefore you can run your

00:07:01,020 --> 00:07:08,730
python code on a web you can also do

00:07:03,600 --> 00:07:10,650
this with other with other Python

00:07:08,730 --> 00:07:12,990
interpreter so for instance micro Partin

00:07:10,650 --> 00:07:16,560
you could compile to web assembly and

00:07:12,990 --> 00:07:18,690
run on the web or pi PI so some examples

00:07:16,560 --> 00:07:21,560
are the most notable is pi o tight which

00:07:18,690 --> 00:07:24,570
takes c peyten and a couple of

00:07:21,560 --> 00:07:27,050
scientific libraries like pandas metro

00:07:24,570 --> 00:07:30,180
clip and numpy and it allows you to do

00:07:27,050 --> 00:07:32,040
data science in your browser in a sort

00:07:30,180 --> 00:07:34,140
of notebook like environment without

00:07:32,040 --> 00:07:38,490
having to install anything on your local

00:07:34,140 --> 00:07:40,560
system pi PI is relatively a pipe RGS is

00:07:38,490 --> 00:07:43,220
relatively well-known and tomorrow

00:07:40,560 --> 00:07:45,510
there's a Jesus

00:07:43,220 --> 00:07:47,730
tomorrow dares to talk about rust biotin

00:07:45,510 --> 00:07:49,560
which is an experiment experimental

00:07:47,730 --> 00:07:51,450
Python interpreter written interest and

00:07:49,560 --> 00:07:54,300
risk can be compiled to web assembly so

00:07:51,450 --> 00:07:57,150
you can do the same thing super now to

00:07:54,300 --> 00:07:58,950
doubt it in all these cases the Python

00:07:57,150 --> 00:08:00,780
code is still running in a VM so this is

00:07:58,950 --> 00:08:02,250
not some sort of Silver Bullet to make

00:08:00,780 --> 00:08:07,800
your culture and fast it just will make

00:08:02,250 --> 00:08:09,300
it possible to run it in a browser so

00:08:07,800 --> 00:08:12,120
the second years case that you would

00:08:09,300 --> 00:08:14,700
like to mention is to compile a subset

00:08:12,120 --> 00:08:16,050
of parts into web assembly so compiled

00:08:14,700 --> 00:08:18,860
snippets of peyten

00:08:16,050 --> 00:08:21,990
that use a subset of the syntax of

00:08:18,860 --> 00:08:24,180
peyten and compiled compiled debts to a

00:08:21,990 --> 00:08:26,130
web assembly module and once you have

00:08:24,180 --> 00:08:29,490
that module you can run it anywhere and

00:08:26,130 --> 00:08:31,620
with anywhere I mean ever anywhere where

00:08:29,490 --> 00:08:33,780
there is a web assembly compiler and

00:08:31,620 --> 00:08:35,940
that is in this case or at this moment

00:08:33,780 --> 00:08:36,510
that's all the modern browsers and

00:08:35,940 --> 00:08:39,750
nodejs

00:08:36,510 --> 00:08:42,450
and as I will show also peyten

00:08:39,750 --> 00:08:43,260
to some extent but I think that a few

00:08:42,450 --> 00:08:47,990
years from now

00:08:43,260 --> 00:08:47,990
anywhere will mean almost anywhere

00:08:48,900 --> 00:08:54,730
so to illustrate this I wrote a simple

00:08:52,420 --> 00:08:57,670
function that can calculate prime

00:08:54,730 --> 00:09:00,070
numbers so for instance we asked you to

00:08:57,670 --> 00:09:02,590
calculate a thousands prime number and

00:09:00,070 --> 00:09:08,050
that will give us seven thousand nine

00:09:02,590 --> 00:09:12,660
hundred and nineteen and we can compile

00:09:08,050 --> 00:09:12,660
this code to webassembly so we have

00:09:12,870 --> 00:09:20,620
implemented a very simple Python to web

00:09:17,860 --> 00:09:22,960
assembly compiler which takes quite a

00:09:20,620 --> 00:09:25,090
few shortcuts the most important one is

00:09:22,960 --> 00:09:27,130
that we assume that all variables are

00:09:25,090 --> 00:09:34,090
floating-point numbers and that makes a

00:09:27,130 --> 00:09:48,190
lot of things quite a bit easier so we

00:09:34,090 --> 00:09:50,520
take our it's there it's getting worse

00:09:48,190 --> 00:09:50,520
right

00:09:57,990 --> 00:10:04,810
so anyway we are we recombine the find

00:10:03,310 --> 00:10:07,060
prime function together with a small

00:10:04,810 --> 00:10:11,380
main function basically to bootstrap it

00:10:07,060 --> 00:10:13,420
and then we can compile that to a web

00:10:11,380 --> 00:10:16,360
assembly module so this web assembly

00:10:13,420 --> 00:10:20,370
module this this M is a internal

00:10:16,360 --> 00:10:20,370
representation of a web assembly module

00:10:26,580 --> 00:10:35,770
but and we can use that to for instance

00:10:32,890 --> 00:10:37,720
show the bytes that so basically the

00:10:35,770 --> 00:10:40,240
binary representation of this web

00:10:37,720 --> 00:10:45,430
assembly module and similarly we can

00:10:40,240 --> 00:10:48,550
show the textual representation of this

00:10:45,430 --> 00:10:54,360
web assembly module so this is the human

00:10:48,550 --> 00:10:54,360
readable form well wait a bit of effort

00:11:05,740 --> 00:11:12,880
and we can also show the interface and

00:11:09,870 --> 00:11:15,370
we'll look at these last bits quite a

00:11:12,880 --> 00:11:17,830
bit more further in this talk because

00:11:15,370 --> 00:11:20,260
the interface shows us what the module

00:11:17,830 --> 00:11:25,540
needs from the environments in which it

00:11:20,260 --> 00:11:27,490
runs and also what it provides but let's

00:11:25,540 --> 00:11:32,280
let's actually run this module so we

00:11:27,490 --> 00:11:32,280
have implemented a few simple functions

00:11:33,720 --> 00:11:39,340
for instance to run the code in note so

00:11:37,570 --> 00:11:39,910
in this case peyten is calling out to

00:11:39,340 --> 00:11:42,040
the notes

00:11:39,910 --> 00:11:44,770
jas executable running it in a

00:11:42,040 --> 00:11:47,350
subprocess giving it the webassembly

00:11:44,770 --> 00:11:48,640
binary and then node will execute the

00:11:47,350 --> 00:11:50,080
web assembly module that which is

00:11:48,640 --> 00:11:55,270
compiled and we can see that we get the

00:11:50,080 --> 00:11:58,030
same result and similarly we can run it

00:11:55,270 --> 00:11:59,890
in a notebook in this case point and

00:11:58,030 --> 00:12:02,770
we'll sense the by new rep assembly

00:11:59,890 --> 00:12:04,510
module to the browserify as some ipython

00:12:02,770 --> 00:12:11,110
mechanics and then we execute it in

00:12:04,510 --> 00:12:13,090
JavaScript so basically what we did we

00:12:11,110 --> 00:12:14,740
had a simple piece of code in the form

00:12:13,090 --> 00:12:16,840
of a function we compiled it to web

00:12:14,740 --> 00:12:19,840
assembly module now we can run it or at

00:12:16,840 --> 00:12:22,630
least in no GS and in a browser but as I

00:12:19,840 --> 00:12:25,240
mentioned we also added supports to P

00:12:22,630 --> 00:12:27,610
PCI to run to compile web assembly to

00:12:25,240 --> 00:12:33,190
native machine code and that means that

00:12:27,610 --> 00:12:36,460
we can do this so if we decorate our

00:12:33,190 --> 00:12:38,080
function which in this way this function

00:12:36,460 --> 00:12:39,580
is compiled to web assembly then

00:12:38,080 --> 00:12:41,920
compiled to machine code wrapped into

00:12:39,580 --> 00:12:44,080
new function and now we can execute this

00:12:41,920 --> 00:12:46,210
code and run it in all native machine

00:12:44,080 --> 00:12:48,610
code and it's quite a bit faster now

00:12:46,210 --> 00:12:50,680
it's not like massively faster yet

00:12:48,610 --> 00:12:52,600
because we don't do any optimization it

00:12:50,680 --> 00:12:54,730
just really want to one who relationship

00:12:52,600 --> 00:13:00,880
but you can see where where this could

00:12:54,730 --> 00:13:04,330
go if you follow this along so to

00:13:00,880 --> 00:13:06,220
summarize this if we take the approach

00:13:04,330 --> 00:13:08,320
of compiling a subset of poitain

00:13:06,220 --> 00:13:11,020
statically compiling a subset of byte in

00:13:08,320 --> 00:13:13,810
to web assembly modules you can use that

00:13:11,020 --> 00:13:15,520
for instance to run snippets of code for

00:13:13,810 --> 00:13:18,370
your web applications because you can

00:13:15,520 --> 00:13:19,900
run it in a browser or you can use it to

00:13:18,370 --> 00:13:22,330
run code

00:13:19,900 --> 00:13:25,420
faster you know if you take this further

00:13:22,330 --> 00:13:28,750
you can make solutions that are very

00:13:25,420 --> 00:13:30,250
similar to number or seitan one very

00:13:28,750 --> 00:13:32,380
nice feature of this is that the

00:13:30,250 --> 00:13:34,540
binaries to weapon so many modules are

00:13:32,380 --> 00:13:38,040
actually cross-platform and that can

00:13:34,540 --> 00:13:40,900
mean a lot for instance with packaging I

00:13:38,040 --> 00:13:42,490
should know though that you know the

00:13:40,900 --> 00:13:44,290
web's the part into web assembly

00:13:42,490 --> 00:13:46,150
compiler is really a proof of concept it

00:13:44,290 --> 00:13:49,810
needs a lot of work to be a proper

00:13:46,150 --> 00:13:52,180
compiler and also the you know you need

00:13:49,810 --> 00:13:55,600
a web simply to native compiler and this

00:13:52,180 --> 00:13:57,880
is all working perfectly in in modern

00:13:55,600 --> 00:13:59,920
browsers especially in Firefox I take to

00:13:57,880 --> 00:14:02,770
get a really good effort to to make it

00:13:59,920 --> 00:14:04,630
work really well and really fast but the

00:14:02,770 --> 00:14:09,060
version that we have in Python is really

00:14:04,630 --> 00:14:09,060
in an experiment experimental phase yet

00:14:10,140 --> 00:14:16,240
so the final use case that they would

00:14:12,430 --> 00:14:19,300
like to present is to use Python as a

00:14:16,240 --> 00:14:21,940
platform to bind and run web assembly

00:14:19,300 --> 00:14:25,330
modules so we're seeing that we can run

00:14:21,940 --> 00:14:28,300
a bind and will execute web so many

00:14:25,330 --> 00:14:31,180
modules in Python what if we take this

00:14:28,300 --> 00:14:35,110
further what if we would make it

00:14:31,180 --> 00:14:38,050
possible to load multiple weapon so many

00:14:35,110 --> 00:14:40,390
modules possibly written with different

00:14:38,050 --> 00:14:41,830
programming languages and binding them

00:14:40,390 --> 00:14:44,290
together right they they have this very

00:14:41,830 --> 00:14:46,480
explicit interfaces what we can bind

00:14:44,290 --> 00:14:49,810
them together in Python then running

00:14:46,480 --> 00:14:52,030
them as one coherent application I think

00:14:49,810 --> 00:14:54,310
this could work very well because

00:14:52,030 --> 00:14:57,160
historically Python has always been a

00:14:54,310 --> 00:15:00,850
very good glue language and Python also

00:14:57,160 --> 00:15:03,490
has a very rich rich ecosystem so if we

00:15:00,850 --> 00:15:05,740
went this way we could turn point in or

00:15:03,490 --> 00:15:10,030
the Python ecosystem in a really multi

00:15:05,740 --> 00:15:14,650
language ecosystem and to demonstrate

00:15:10,030 --> 00:15:17,350
this somewhat I've I've taken the rocket

00:15:14,650 --> 00:15:22,390
game and this is a game which is rotten

00:15:17,350 --> 00:15:23,860
written by someone else in rust so it's

00:15:22,390 --> 00:15:24,520
written in rest and then compiled to

00:15:23,860 --> 00:15:27,670
webassembly

00:15:24,520 --> 00:15:30,190
and it was used as an example to you

00:15:27,670 --> 00:15:33,280
know run web assembly run rust on the

00:15:30,190 --> 00:15:33,699
web the game looks like this you control

00:15:33,280 --> 00:15:36,489
a little

00:15:33,699 --> 00:15:44,069
Rockets you can steer you can shoot and

00:15:36,489 --> 00:15:46,359
that's basically it so if you browse the

00:15:44,069 --> 00:15:48,759
repository where this code is residing

00:15:46,359 --> 00:15:52,480
there is a little file there called

00:15:48,759 --> 00:15:55,480
program dot W ASM it's 60 kilobyte and

00:15:52,480 --> 00:15:57,220
it is the you know the code compiled to

00:15:55,480 --> 00:16:00,009
weapons this is the web assembly module

00:15:57,220 --> 00:16:03,399
basically so I downloaded this module I

00:16:00,009 --> 00:16:05,470
renamed it to Rockets dot W ASM and for

00:16:03,399 --> 00:16:10,019
the rest I didn't touch it at all and I

00:16:05,470 --> 00:16:12,669
can load this in in memory using P PCI

00:16:10,019 --> 00:16:14,919
so this is again the internal

00:16:12,669 --> 00:16:18,939
representation of that web assembly

00:16:14,919 --> 00:16:21,209
module we again can show the bytes of

00:16:18,939 --> 00:16:25,600
course it's a lot more than the previous

00:16:21,209 --> 00:16:31,359
module that we saw we can say also the

00:16:25,600 --> 00:16:36,759
textual representation well human

00:16:31,359 --> 00:16:38,289
readable is relative here I think but we

00:16:36,759 --> 00:16:39,789
can also serve the interface and this is

00:16:38,289 --> 00:16:41,799
where it gets interesting because the

00:16:39,789 --> 00:16:43,989
interface defines imports and exports

00:16:41,799 --> 00:16:46,539
and imports are the things that this

00:16:43,989 --> 00:16:50,829
module needs from the environment so we

00:16:46,539 --> 00:16:53,889
can see that it needs we can see that it

00:16:50,829 --> 00:16:56,589
needs the sine function and the cosine

00:16:53,889 --> 00:16:59,230
function and it needs some drawing

00:16:56,589 --> 00:17:02,619
functions because it's really a game

00:16:59,230 --> 00:17:04,659
engine it leaves the drawing to the host

00:17:02,619 --> 00:17:05,980
environment so it needs the function to

00:17:04,659 --> 00:17:08,649
draw the bullets the enemies the

00:17:05,980 --> 00:17:11,049
particles etc and we can also see that

00:17:08,649 --> 00:17:13,149
it exports some things and most

00:17:11,049 --> 00:17:15,220
importantly these are the controls to

00:17:13,149 --> 00:17:19,240
steer the ship so turning left right and

00:17:15,220 --> 00:17:21,669
shooting so if we look at this

00:17:19,240 --> 00:17:23,620
repository a bit closer we can see that

00:17:21,669 --> 00:17:25,689
there's a lot of rust there but there's

00:17:23,620 --> 00:17:28,240
a little bit of JavaScript too and we

00:17:25,689 --> 00:17:30,720
can see the draw player that the draw

00:17:28,240 --> 00:17:36,720
enemy function and these are really

00:17:30,720 --> 00:17:36,720
html5 html5 canvas drawing calls

00:17:41,770 --> 00:17:50,620
yeah so what's really happening this web

00:17:48,590 --> 00:17:52,640
assembly module is loaded into

00:17:50,620 --> 00:17:54,790
JavaScript and there's a little bit of

00:17:52,640 --> 00:17:57,290
JavaScript surrounding its to support it

00:17:54,790 --> 00:17:59,090
there's the code to load and compile the

00:17:57,290 --> 00:18:00,770
module and there's a little bit of codes

00:17:59,090 --> 00:18:02,210
you know to provide the sine function

00:18:00,770 --> 00:18:05,990
cosine function and drawing the drawing

00:18:02,210 --> 00:18:08,540
calls and also to turn JavaScript key

00:18:05,990 --> 00:18:12,440
events and turndown use them to control

00:18:08,540 --> 00:18:14,870
the ship using the exported functions so

00:18:12,440 --> 00:18:16,820
if we want to run this module in Python

00:18:14,870 --> 00:18:21,580
we need to do the same we need to give

00:18:16,820 --> 00:18:24,919
it the sine function cosine function and

00:18:21,580 --> 00:18:26,630
and some drawing function so we need

00:18:24,919 --> 00:18:29,150
something to draw to we need something

00:18:26,630 --> 00:18:32,000
to capture key events and we can for

00:18:29,150 --> 00:18:33,470
instance use QT for that and what we

00:18:32,000 --> 00:18:37,040
then get is something that looks like

00:18:33,470 --> 00:18:38,660
this we have a bunch of functions for

00:18:37,040 --> 00:18:41,270
instance the draw enemy functions that

00:18:38,660 --> 00:18:43,850
we do the cutie drawing calls there and

00:18:41,270 --> 00:18:48,440
it totals just like 100 or 200 lines of

00:18:43,850 --> 00:18:51,530
code we basically wrap all these methods

00:18:48,440 --> 00:18:53,929
up into a small dictionary which is sent

00:18:51,530 --> 00:18:57,820
along with the instantiation of this

00:18:53,929 --> 00:18:57,820
module and then it works

00:19:05,600 --> 00:19:15,890
so then we get if we run this we get

00:19:10,120 --> 00:19:17,810
this so what we see here is a game

00:19:15,890 --> 00:19:19,750
written in rust compiled to webassembly

00:19:17,810 --> 00:19:24,920
and now running in peyten

00:19:19,750 --> 00:19:26,810
and I I intentionally made everything

00:19:24,920 --> 00:19:43,250
really big because then it's easy to see

00:19:26,810 --> 00:19:45,500
in the back so it gets better so instead

00:19:43,250 --> 00:19:49,310
of QT you can also use from toolkit so

00:19:45,500 --> 00:19:53,630
from toolkit is a UI a way to create

00:19:49,310 --> 00:19:55,130
user interfaces in the shell I'm good I

00:19:53,630 --> 00:19:58,370
tried just now and it didn't work

00:19:55,130 --> 00:20:03,910
because the Wi-Fi stuck so let's try

00:19:58,370 --> 00:20:03,910
again real quick yeah

00:20:11,669 --> 00:20:20,379
so this is really geeky but yeah of

00:20:18,940 --> 00:20:31,450
course yeah you can shoot it's a bit

00:20:20,379 --> 00:20:31,960
especially over this weekend listen okay

00:20:31,450 --> 00:20:33,249
anyway

00:20:31,960 --> 00:20:35,139
at some point I thought well this game

00:20:33,249 --> 00:20:39,480
is not so hard to play let's make an

00:20:35,139 --> 00:20:42,129
ally so I wrote a little bit of C code

00:20:39,480 --> 00:20:44,169
it's really not that much which really

00:20:42,129 --> 00:20:46,990
it looks at what is the closest enemy

00:20:44,169 --> 00:20:50,100
tries to ship to Wars it's and then when

00:20:46,990 --> 00:20:55,090
the angle is small enough shoot and

00:20:50,100 --> 00:20:57,639
there's a websites called W AM fiddle

00:20:55,090 --> 00:20:59,740
and you can write C code there then you

00:20:57,639 --> 00:21:02,289
hit a button and then out comes a web

00:20:59,740 --> 00:21:04,269
assembly module so I used that and then

00:21:02,289 --> 00:21:08,799
I downloaded the web assembly module and

00:21:04,269 --> 00:21:11,559
then we can load it in here and we can

00:21:08,799 --> 00:21:17,169
show the interface so we can see that it

00:21:11,559 --> 00:21:19,059
needs it needs a toggle shoot toggle

00:21:17,169 --> 00:21:20,710
turn left and toggle turn right so it

00:21:19,059 --> 00:21:23,529
makes sense because it needs to have

00:21:20,710 --> 00:21:25,539
control of the ship and also it exports

00:21:23,529 --> 00:21:28,480
a draw player and a draw enemy function

00:21:25,539 --> 00:21:30,309
it is not going to actually draw these

00:21:28,480 --> 00:21:32,889
but it needs to coordinates to do

00:21:30,309 --> 00:21:42,220
calculations so if we bring this

00:21:32,889 --> 00:21:45,369
together we get this so this is a game

00:21:42,220 --> 00:21:47,619
engine written in rust a a I written in

00:21:45,369 --> 00:21:50,649
C and bound together and working

00:21:47,619 --> 00:21:52,830
together as one coherent application in

00:21:50,649 --> 00:21:52,830
Python

00:21:55,360 --> 00:22:07,540
running on Windows yeah so I should

00:22:05,440 --> 00:22:10,240
really say that all of what I've shown

00:22:07,540 --> 00:22:12,700
is really experimental and nothing is

00:22:10,240 --> 00:22:15,540
really ready for use from you know from

00:22:12,700 --> 00:22:18,100
the Python end but nevertheless

00:22:15,540 --> 00:22:19,480
webassembly is already usable and it's

00:22:18,100 --> 00:22:22,120
definitely coming and it's really

00:22:19,480 --> 00:22:24,880
awesome and it's definitely not limited

00:22:22,120 --> 00:22:27,850
to the web and I would like to encourage

00:22:24,880 --> 00:22:29,380
everyone to explore ways in which we can

00:22:27,850 --> 00:22:31,540
combine webassembly important because

00:22:29,380 --> 00:22:34,150
there's definitely more use cases

00:22:31,540 --> 00:22:38,860
possible and I just showed three

00:22:34,150 --> 00:22:46,430
examples here yeah that's it thank you

00:22:38,860 --> 00:22:46,430
[Applause]

00:22:53,640 --> 00:22:57,940
so thanks for showing like how it's

00:22:56,140 --> 00:22:59,740
useful for Python because this is

00:22:57,940 --> 00:23:02,140
actually more eye-opening that the web

00:22:59,740 --> 00:23:03,880
parts and sort of like playing a devil's

00:23:02,140 --> 00:23:05,500
advocate a bit what do you think about

00:23:03,880 --> 00:23:06,910
the web part and like because everyone

00:23:05,500 --> 00:23:08,500
is basically jumping oh I'm gonna just

00:23:06,910 --> 00:23:10,540
use my language my favorite language to

00:23:08,500 --> 00:23:13,840
write web now and how is it different

00:23:10,540 --> 00:23:17,020
from basically Java x or like octave x x

00:23:13,840 --> 00:23:19,270
or active scripting in flash basically

00:23:17,020 --> 00:23:22,630
isn't the same hell that we went into

00:23:19,270 --> 00:23:24,760
before and now this is yeah that's a

00:23:22,630 --> 00:23:27,250
very good question but this is different

00:23:24,760 --> 00:23:32,130
in several ways in that these web

00:23:27,250 --> 00:23:34,510
seminars are more lightweight basically

00:23:32,130 --> 00:23:37,180
yeah and they expose basically they are

00:23:34,510 --> 00:23:39,160
they expose what I need from the host

00:23:37,180 --> 00:23:40,960
environment for instance I need a sine

00:23:39,160 --> 00:23:42,670
function I need a cosine function and

00:23:40,960 --> 00:23:44,980
maybe the host environment will provide

00:23:42,670 --> 00:23:46,930
it but this could also be that's another

00:23:44,980 --> 00:23:48,370
web simone choule provides it and the

00:23:46,930 --> 00:23:50,190
host system only binds them together

00:23:48,370 --> 00:23:52,900
basically

00:23:50,190 --> 00:23:56,430
so it's kill something much better I

00:23:52,900 --> 00:24:07,499
guess then for instance Java applets

00:23:56,430 --> 00:24:12,489
Thanks Python did you

00:24:07,499 --> 00:24:15,969
work on to convert into webassembly yeah

00:24:12,489 --> 00:24:19,169
in this case it is a very well basically

00:24:15,969 --> 00:24:22,179
I stopped when my example was working

00:24:19,169 --> 00:24:23,649
it's only it assumes that every variable

00:24:22,179 --> 00:24:26,679
is a float for instance and that makes

00:24:23,649 --> 00:24:27,999
things a lot easier so if you want to

00:24:26,679 --> 00:24:30,249
extend this for instance it would be

00:24:27,999 --> 00:24:33,099
very good to have to use type annotation

00:24:30,249 --> 00:24:37,329
so that you can use multiple different

00:24:33,099 --> 00:24:40,899
types and still statically compiled but

00:24:37,329 --> 00:24:42,279
yeah it's a very very very strict subset

00:24:40,899 --> 00:24:58,809
at this point it's really proof of

00:24:42,279 --> 00:25:01,329
concept you need to ask two basic you

00:24:58,809 --> 00:25:03,669
need to provide an import function so

00:25:01,329 --> 00:25:06,959
that you get something from JavaScript

00:25:03,669 --> 00:25:10,659
to manipulate the Dom so there's no way

00:25:06,959 --> 00:25:13,570
so on itself webassembly cannot do a lot

00:25:10,659 --> 00:25:15,609
it cannot do file i/o because it has to

00:25:13,570 --> 00:25:17,529
be safe right so if you want to

00:25:15,609 --> 00:25:20,169
manipulate the Dom you need to define an

00:25:17,529 --> 00:25:23,229
function that you import and then in

00:25:20,169 --> 00:25:27,869
JavaScript you're going to make that

00:25:23,229 --> 00:25:27,869
function available that's how it works

00:25:45,989 --> 00:25:51,309
but what would be the limitations and

00:25:49,629 --> 00:25:53,649
maybe they're different for the tree

00:25:51,309 --> 00:25:56,619
that you showed like for example for

00:25:53,649 --> 00:25:57,159
importing Python modules were how would

00:25:56,619 --> 00:26:00,479
that work

00:25:57,159 --> 00:26:02,979
to import by third-party modules and

00:26:00,479 --> 00:26:05,769
would it be able to open circuits like

00:26:02,979 --> 00:26:07,479
to run a web server from inside the

00:26:05,769 --> 00:26:09,549
browser could you different things like

00:26:07,479 --> 00:26:12,940
a web server yeah good question

00:26:09,549 --> 00:26:17,529
so if you're in a browser there's no way

00:26:12,940 --> 00:26:19,450
to create a normal sockets so running a

00:26:17,529 --> 00:26:22,150
web server would be hard

00:26:19,450 --> 00:26:24,970
but you have WebSockets so you could

00:26:22,150 --> 00:26:26,580
expose them so again yeah you need to

00:26:24,970 --> 00:26:28,840
have some kind of import or export

00:26:26,580 --> 00:26:32,860
mechanism so that in JavaScript

00:26:28,840 --> 00:26:35,110
basically you write the you provide

00:26:32,860 --> 00:26:38,710
somehow web fonts socket functionality

00:26:35,110 --> 00:26:40,450
to the web assembly module and for

00:26:38,710 --> 00:26:43,600
importing modules

00:26:40,450 --> 00:26:46,930
I'm not these are really the the parts

00:26:43,600 --> 00:26:50,200
were compiling something to web assembly

00:26:46,930 --> 00:26:52,180
is hard these ask you know file i/o

00:26:50,200 --> 00:26:56,200
stuff like that you need to somehow

00:26:52,180 --> 00:26:58,600
convert it to use the browser's you know

00:26:56,200 --> 00:27:02,080
a virtual file system that it exposes

00:26:58,600 --> 00:27:03,670
stuff like that and importing you have

00:27:02,080 --> 00:27:05,970
some mechanism to do that but it's

00:27:03,670 --> 00:27:05,970
different

00:27:12,750 --> 00:27:25,860
possibly but I've not played with that

00:27:15,850 --> 00:27:29,740
part myself so things here written by

00:27:25,860 --> 00:27:33,610
the database come again database the

00:27:29,740 --> 00:27:36,400
assessment database access from from

00:27:33,610 --> 00:27:38,020
webassembly you mean yeah yeah yeah you

00:27:36,400 --> 00:27:41,860
could yeah but the only thing is that

00:27:38,020 --> 00:27:44,020
you then need to furnish then you define

00:27:41,860 --> 00:27:46,210
imports for accessing and manipulating

00:27:44,020 --> 00:27:48,400
the database and then in Python you

00:27:46,210 --> 00:27:51,040
write a little bit of glue code to

00:27:48,400 --> 00:27:53,410
actually provide that functionality so

00:27:51,040 --> 00:27:54,820
directly from webassembly no but you can

00:27:53,410 --> 00:27:56,290
you know you can import any

00:27:54,820 --> 00:27:58,000
functionality that you need and then you

00:27:56,290 --> 00:28:00,940
need to write some supporting codes in

00:27:58,000 --> 00:28:03,250
Python or you know JavaScript depending

00:28:00,940 --> 00:28:05,370
where you're running to make it work so

00:28:03,250 --> 00:28:07,900
you are saying when you compile your

00:28:05,370 --> 00:28:11,560
Python cognitive Python code

00:28:07,900 --> 00:28:13,150
handling ask sequel where you compare

00:28:11,560 --> 00:28:18,670
that web sampling there won't be a

00:28:13,150 --> 00:28:20,410
single web sampling file sir I don't I

00:28:18,670 --> 00:28:23,740
don't understand your person think about

00:28:20,410 --> 00:28:27,520
having a native Python code handling

00:28:23,740 --> 00:28:28,269
sequel mm-hmm whichever it is and your

00:28:27,520 --> 00:28:32,440
compiled

00:28:28,269 --> 00:28:34,389
a web server little file that won't just

00:28:32,440 --> 00:28:36,609
walk right you want to wrap everything

00:28:34,389 --> 00:28:41,109
in you know moves everything file and

00:28:36,609 --> 00:28:43,799
ran at no unless you take an initial

00:28:41,109 --> 00:28:46,179
compiler is somehow aware of that and

00:28:43,799 --> 00:28:49,809
automatically generates the imports and

00:28:46,179 --> 00:28:51,580
generating code so yeah it's it's a

00:28:49,809 --> 00:29:06,969
maybe we can talk afterwards and explain

00:28:51,580 --> 00:29:14,649
more details yeah so when you were

00:29:06,969 --> 00:29:23,019
running the Qt it's running inside the

00:29:14,649 --> 00:29:25,419
Poisson process it's well yeah it's

00:29:23,019 --> 00:29:27,369
machine code yeah so it's being compiled

00:29:25,419 --> 00:29:29,469
to machine code it's loaded into the bra

00:29:27,369 --> 00:29:33,039
into the part in process and then

00:29:29,469 --> 00:29:35,169
running there accepts that's for the

00:29:33,039 --> 00:29:37,809
Rockets like the Rockets game engine

00:29:35,169 --> 00:29:40,349
we emulated it because we have some bugs

00:29:37,809 --> 00:29:43,269
in it and we cannot we were unable to

00:29:40,349 --> 00:29:45,249
fix them before the talk so all the

00:29:43,269 --> 00:29:47,109
other parts are running truly a machine

00:29:45,249 --> 00:29:49,779
codes and rockets in this presentation

00:29:47,109 --> 00:29:57,999
was emulated but it's you know an

00:29:49,779 --> 00:30:00,749
implementation detail yeah it makes use

00:29:57,999 --> 00:30:03,879
of a trick that Luke can paniolo

00:30:00,749 --> 00:30:08,529
published in a lightning talk a few

00:30:03,879 --> 00:30:10,329
years ago at Syfy where you can load you

00:30:08,529 --> 00:30:12,279
know machine code into parts in memory

00:30:10,329 --> 00:30:17,289
and then execute that it's basically

00:30:12,279 --> 00:30:20,039
based on that please give our speaker

00:30:17,289 --> 00:30:20,039
and all-around applause

00:30:22,190 --> 00:30:24,250

YouTube URL: https://www.youtube.com/watch?v=u2kKxmb9BWs


