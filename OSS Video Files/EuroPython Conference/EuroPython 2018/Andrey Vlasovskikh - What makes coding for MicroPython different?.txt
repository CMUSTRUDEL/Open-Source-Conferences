Title: Andrey Vlasovskikh - What makes coding for MicroPython different?
Publication date: 2018-08-22
Playlist: EuroPython 2018
Description: 
	What makes coding for MicroPython different?
[EuroPython 2018 - Talk - 2018-07-25 - Lammermuir]
[Edinburgh, UK]

By Andrey Vlasovskikh

A microcontroller unit is a CPU, memory modules, and I/O devices on a single chip. There are tens of billions of microcontrollers in world: they are everywhere from watches to cars. Developers program them mostly in C, since their tiny hardware resources make it very hard to use higher-level langauges such as Python. In 2014 the MicroPython project was started with the goal of making it possible to program microcontrollers in Python.

Was it hard to make Python work on a device with only 16 KB of RAM? Is MicroPython a Python dialect or is it a different language? I'll start with the most important optimizations and the key differences in the language implementation to give you an idea of what MicroPython really is.

Most of us are not contributors to MicroPython though and it's much more important for us to understand how Python coding for microcontrollers is different from, say, web development or scripting. What do you need to learn in order to program your mictrocontroller-based IoT devices? I'll talk about several traits of Python coding for microcontrollers that make it different, but exciting to learn.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2018.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:02,179 --> 00:00:08,340
hello everyone I'm Andrey Vlasov skier

00:00:06,060 --> 00:00:10,440
I'm from st. Petersburg in Russia and

00:00:08,340 --> 00:00:12,259
I'm the lead developer of pycharm

00:00:10,440 --> 00:00:15,240
Community Edition at JetBrains

00:00:12,259 --> 00:00:17,369
I've also been working on various type

00:00:15,240 --> 00:00:20,369
hinton related stuff in Python

00:00:17,369 --> 00:00:22,500
especially on pipe for it for so I

00:00:20,369 --> 00:00:24,449
usually give talks about type he and

00:00:22,500 --> 00:00:26,609
static code analysis and stuff like that

00:00:24,449 --> 00:00:27,619
but now for something completely

00:00:26,609 --> 00:00:30,390
different

00:00:27,619 --> 00:00:34,200
microcontrollers well a microcontroller

00:00:30,390 --> 00:00:36,420
is a device that combines a CPU your

00:00:34,200 --> 00:00:39,360
memory and your input and output devices

00:00:36,420 --> 00:00:41,370
in a single device something like that

00:00:39,360 --> 00:00:43,559
it's really tiny I have a bunch of them

00:00:41,370 --> 00:00:46,410
over there I will show you more of them

00:00:43,559 --> 00:00:49,230
later and these devices are used

00:00:46,410 --> 00:00:50,820
everywhere so basically they are used to

00:00:49,230 --> 00:00:53,570
control physical equipment physical

00:00:50,820 --> 00:00:56,399
devices like proximity sensors excellent

00:00:53,570 --> 00:00:59,370
accelerometer accelerometers sorry

00:00:56,399 --> 00:01:01,500
LEDs servo motors and so on and there

00:00:59,370 --> 00:01:05,220
are billions of microcontrollers in the

00:01:01,500 --> 00:01:07,470
world it's the most frequently used a

00:01:05,220 --> 00:01:09,720
computing device actually because for

00:01:07,470 --> 00:01:13,340
example every cell phone and every PC

00:01:09,720 --> 00:01:15,750
has dozens of microcontrollers in it and

00:01:13,340 --> 00:01:18,420
microcontrollers are also very important

00:01:15,750 --> 00:01:21,689
for Internet of Things they are very

00:01:18,420 --> 00:01:24,240
cheap this allows us to use them for

00:01:21,689 --> 00:01:27,689
controlling everything in consumer

00:01:24,240 --> 00:01:30,270
electronics but why should you care why

00:01:27,689 --> 00:01:33,270
do I speak about microcontrollers at a

00:01:30,270 --> 00:01:36,270
Python event the reason is that you had

00:01:33,270 --> 00:01:38,479
to program them in C on or even in the

00:01:36,270 --> 00:01:41,880
assembler language but starting from

00:01:38,479 --> 00:01:44,070
2014 you can now use Python to program

00:01:41,880 --> 00:01:46,439
microcontrollers well sort of Python

00:01:44,070 --> 00:01:48,600
it's not exactly 100% compatible with

00:01:46,439 --> 00:01:51,329
your familiar C Python but still it

00:01:48,600 --> 00:01:53,460
close its close and you can only use it

00:01:51,329 --> 00:01:56,430
on some microcontrollers but I believe

00:01:53,460 --> 00:01:57,990
it's already good enough so how does it

00:01:56,430 --> 00:02:00,299
look like let me give you a quick

00:01:57,990 --> 00:02:01,829
example of what sort of things you can

00:02:00,299 --> 00:02:04,110
create with micro Python for example

00:02:01,829 --> 00:02:06,540
this is a small program then blinks an

00:02:04,110 --> 00:02:09,000
LED on this particular board and this

00:02:06,540 --> 00:02:10,830
board is connected via USB only to

00:02:09,000 --> 00:02:13,770
provide it with power you can perfectly

00:02:10,830 --> 00:02:15,720
run it using a battery

00:02:13,770 --> 00:02:19,220
so the code should look very familiar

00:02:15,720 --> 00:02:21,330
it's just a regular Python with a few

00:02:19,220 --> 00:02:23,850
imports that are specific to

00:02:21,330 --> 00:02:26,900
microcontrollers but other than that it

00:02:23,850 --> 00:02:30,180
should be a familiar and very readable

00:02:26,900 --> 00:02:32,400
why would you want to use Python instead

00:02:30,180 --> 00:02:36,480
of C well for obvious reasons Python is

00:02:32,400 --> 00:02:38,460
a high-level language and it does lots

00:02:36,480 --> 00:02:39,990
of stuff for you for example it manages

00:02:38,460 --> 00:02:43,260
your memory so you do not have to

00:02:39,990 --> 00:02:45,270
allocate and deallocate memory as you do

00:02:43,260 --> 00:02:47,430
in C for example and generally speaking

00:02:45,270 --> 00:02:50,220
high languages higher-level languages

00:02:47,430 --> 00:02:53,550
win over time so for example in the

00:02:50,220 --> 00:02:56,070
early 2000s C started to replace the

00:02:53,550 --> 00:02:58,260
assembler language on microcontrollers

00:02:56,070 --> 00:03:01,110
and I think now is the time to for

00:02:58,260 --> 00:03:03,750
Python to replace see you there but the

00:03:01,110 --> 00:03:06,750
problem is regular Python still doesn't

00:03:03,750 --> 00:03:09,170
fit so the CPUs are actually powerful

00:03:06,750 --> 00:03:11,700
enough for running Python but

00:03:09,170 --> 00:03:14,400
microcontrollers usually have only a

00:03:11,700 --> 00:03:18,000
tiny amount of RAM a typical amount is

00:03:14,400 --> 00:03:19,620
something like 100 kilobytes it's not

00:03:18,000 --> 00:03:20,430
your usual gigabytes like you have on

00:03:19,620 --> 00:03:23,340
your laptops

00:03:20,430 --> 00:03:26,310
it's not even megabytes like you like

00:03:23,340 --> 00:03:28,290
you did on your PC in the 90s it's

00:03:26,310 --> 00:03:30,840
really kilobytes the stuff from the 80s

00:03:28,290 --> 00:03:32,790
from the era of ZX spectrum and stuff

00:03:30,840 --> 00:03:35,220
like that so it's a really tiny amount

00:03:32,790 --> 00:03:38,460
of memory and see python requires a

00:03:35,220 --> 00:03:41,610
hundred to a thousand times more so

00:03:38,460 --> 00:03:43,190
enter a micro Python micro Python is

00:03:41,610 --> 00:03:46,050
basically a Python language

00:03:43,190 --> 00:03:49,440
implementation specifically designed for

00:03:46,050 --> 00:03:51,210
really low memory consumption so it's

00:03:49,440 --> 00:03:53,670
highly optimized exactly for this

00:03:51,210 --> 00:03:55,250
purpose it's not a form of C Python it's

00:03:53,670 --> 00:03:58,620
a completely different implementation

00:03:55,250 --> 00:04:02,840
and it's designed with this idea in mind

00:03:58,620 --> 00:04:05,960
for example markup Python can be run on

00:04:02,840 --> 00:04:10,020
BBC micro build this small device

00:04:05,960 --> 00:04:12,720
manufactured by BBC it has only 16 K of

00:04:10,020 --> 00:04:14,580
RAM 16 kilobytes is just enough for a

00:04:12,720 --> 00:04:17,370
few thousand of tweets more or less and

00:04:14,580 --> 00:04:18,900
even though you are able to run your

00:04:17,370 --> 00:04:21,090
markup Python or Apple there is a

00:04:18,900 --> 00:04:24,690
compiler for Python there and so on so

00:04:21,090 --> 00:04:26,180
it's very incredible so I would like to

00:04:24,690 --> 00:04:28,280
give you an impression of

00:04:26,180 --> 00:04:30,289
kind of optimization techniques micro

00:04:28,280 --> 00:04:33,320
Python used to achieve these results I'm

00:04:30,289 --> 00:04:35,539
not going to dive too much deep into the

00:04:33,320 --> 00:04:37,009
details but I think it's a good idea to

00:04:35,539 --> 00:04:40,130
have an impression of what kind of

00:04:37,009 --> 00:04:43,000
optimizations made it possible the first

00:04:40,130 --> 00:04:45,410
one is related to memory management

00:04:43,000 --> 00:04:46,280
micro Python uses only garbage

00:04:45,410 --> 00:04:48,229
collection

00:04:46,280 --> 00:04:51,229
it doesn't use reference counting for

00:04:48,229 --> 00:04:54,650
example like Degrassi Python does

00:04:51,229 --> 00:04:57,199
alongside with GC the reason for it is

00:04:54,650 --> 00:05:01,130
that in micro Python they don't want to

00:04:57,199 --> 00:05:03,349
store ref counting fields even with each

00:05:01,130 --> 00:05:04,910
Python object and in Python everything

00:05:03,349 --> 00:05:07,070
is an object so basically have to have

00:05:04,910 --> 00:05:09,979
these reference counting fields instead

00:05:07,070 --> 00:05:12,139
of that micro Python drops almost all

00:05:09,979 --> 00:05:14,690
the memory management fields except for

00:05:12,139 --> 00:05:16,099
a few bits that are acquired for garbage

00:05:14,690 --> 00:05:19,729
collection to mark your objects as

00:05:16,099 --> 00:05:22,070
traversed and you might have heard that

00:05:19,729 --> 00:05:25,520
garbage collection and the only method

00:05:22,070 --> 00:05:28,430
method for managing memory is quite slow

00:05:25,520 --> 00:05:29,900
especially when it has lots of RAM but

00:05:28,430 --> 00:05:31,460
for micro Python and Perl

00:05:29,900 --> 00:05:34,250
microcontrollers it's not really an

00:05:31,460 --> 00:05:36,110
issue because you have so little memory

00:05:34,250 --> 00:05:38,630
that you can traverse the whole memory

00:05:36,110 --> 00:05:40,729
in just like a milliseconds or so so

00:05:38,630 --> 00:05:42,620
it's a perfectly good technique to

00:05:40,729 --> 00:05:45,770
manage your memory on microcontrollers

00:05:42,620 --> 00:05:48,260
the next trick micro Python uses to

00:05:45,770 --> 00:05:51,080
reduce the amount of memory is storing

00:05:48,260 --> 00:05:54,380
integers in pointers well the idea is

00:05:51,080 --> 00:05:56,270
that memory is worth addressable it's

00:05:54,380 --> 00:05:58,220
not byte addressable so you cannot

00:05:56,270 --> 00:06:00,830
retrieve for example the third byte or

00:05:58,220 --> 00:06:03,139
the second byte you can Oliver only

00:06:00,830 --> 00:06:05,780
retrieve a word of memory a four byte

00:06:03,139 --> 00:06:08,030
word in a 32-bit architecture and you

00:06:05,780 --> 00:06:10,039
basically can retrieve it only if the

00:06:08,030 --> 00:06:13,099
memory address is divided by four in

00:06:10,039 --> 00:06:15,740
this architecture so you get your memory

00:06:13,099 --> 00:06:18,020
in words and this means this that the

00:06:15,740 --> 00:06:20,090
two lowest bits in your memory address

00:06:18,020 --> 00:06:22,520
are not really used used for any

00:06:20,090 --> 00:06:24,259
purposes you can just put some random

00:06:22,520 --> 00:06:24,650
stuff in there and it will continue to

00:06:24,259 --> 00:06:26,750
work

00:06:24,650 --> 00:06:29,270
so micro Python utilizes these two lost

00:06:26,750 --> 00:06:31,909
bits of for example if these two bits

00:06:29,270 --> 00:06:34,159
are zeros then it's a regular pointer to

00:06:31,909 --> 00:06:37,659
your memory block but if the lowest bit

00:06:34,159 --> 00:06:39,560
is 1 the rest of the 32 or 31 bits

00:06:37,659 --> 00:06:43,070
actually the X

00:06:39,560 --> 00:06:45,320
value of your integer so the integer in

00:06:43,070 --> 00:06:47,690
micro Python takes only four bytes of

00:06:45,320 --> 00:06:52,150
RAM and how many bytes of RAM does

00:06:47,690 --> 00:06:53,360
integer take in your C Python who knows

00:06:52,150 --> 00:06:57,440
00:06:53,360 --> 00:07:01,430
any other ideas 28 28 yeah for smaller

00:06:57,440 --> 00:07:04,130
integers it's 28 right so it's 4 4 4 4 4

00:07:01,430 --> 00:07:07,730
just storing the integer one having 28

00:07:04,130 --> 00:07:10,070
bytes of RAM is huge I think the next

00:07:07,730 --> 00:07:11,840
technique is storing your objects in

00:07:10,070 --> 00:07:14,660
read-only memory

00:07:11,840 --> 00:07:16,880
the thing about microcontrollers is that

00:07:14,660 --> 00:07:18,979
they have a single address space for

00:07:16,880 --> 00:07:22,700
both your RAM memory and your own memory

00:07:18,979 --> 00:07:25,130
so you can use the same pointers to

00:07:22,700 --> 00:07:27,800
point either to RAM or to your flash ROM

00:07:25,130 --> 00:07:29,800
memory your persistent storage so you

00:07:27,800 --> 00:07:32,990
can put immutable objects for example

00:07:29,800 --> 00:07:36,729
compiled built-in modules like C's or OS

00:07:32,990 --> 00:07:40,160
modules to your ROM to free up your RAM

00:07:36,729 --> 00:07:42,530
or for example strings are also good

00:07:40,160 --> 00:07:44,840
candidates to put them in wrong now

00:07:42,530 --> 00:07:47,330
let's consider importing the SIS module

00:07:44,840 --> 00:07:49,610
how much memory do we need in micro

00:07:47,330 --> 00:07:51,169
Python to import it well let's count we

00:07:49,610 --> 00:07:53,450
have to update our global or local

00:07:51,169 --> 00:07:55,940
dictionary with the name C's and the

00:07:53,450 --> 00:07:58,789
pointer to the Asus module well the

00:07:55,940 --> 00:08:00,650
string C's is stored on ROM so we need

00:07:58,789 --> 00:08:03,590
only one pointer to point to it and

00:08:00,650 --> 00:08:06,500
another pointer will point to the actual

00:08:03,590 --> 00:08:10,490
machine code for the SIS module so we'll

00:08:06,500 --> 00:08:12,470
need only 8 bytes of RAM to import the

00:08:10,490 --> 00:08:15,650
SIS module which is pretty impressive

00:08:12,470 --> 00:08:18,080
so using these kinds of optimizations

00:08:15,650 --> 00:08:19,820
micro Python was able to achieve these

00:08:18,080 --> 00:08:21,889
results and to be able to run on

00:08:19,820 --> 00:08:23,990
microcontrollers so what you get from

00:08:21,889 --> 00:08:27,639
micro Python is more or less the same

00:08:23,990 --> 00:08:30,580
language as C Python 3.4 with just a few

00:08:27,639 --> 00:08:33,500
differences for example handling complex

00:08:30,580 --> 00:08:35,860
object class hierarchies is a bit

00:08:33,500 --> 00:08:38,089
different or accessing your

00:08:35,860 --> 00:08:40,010
introspection techniques could also be a

00:08:38,089 --> 00:08:41,599
bit different but other than that the

00:08:40,010 --> 00:08:43,640
biggest change is that you don't have

00:08:41,599 --> 00:08:46,100
the full standard library of Python

00:08:43,640 --> 00:08:47,660
available microcontrollers for obvious

00:08:46,100 --> 00:08:48,680
reasons because there is just not enough

00:08:47,660 --> 00:08:51,260
space to do it

00:08:48,680 --> 00:08:52,610
so the standard library is reduced just

00:08:51,260 --> 00:08:55,820
to a few modules you can

00:08:52,610 --> 00:08:57,410
pick the right modules for you for your

00:08:55,820 --> 00:08:59,710
application and create a custom

00:08:57,410 --> 00:09:02,750
distribution of micro Python

00:08:59,710 --> 00:09:04,610
custom-built and these modules are

00:09:02,750 --> 00:09:06,020
usually reduced to the most important

00:09:04,610 --> 00:09:08,120
functions in the modules but they are

00:09:06,020 --> 00:09:11,830
not quite compatible with your regular

00:09:08,120 --> 00:09:15,050
makeup markup sorry simple modules so

00:09:11,830 --> 00:09:17,420
we've talked about the micro Python

00:09:15,050 --> 00:09:19,790
implementation but most of us are not

00:09:17,420 --> 00:09:21,740
really core developers of micro Python

00:09:19,790 --> 00:09:23,720
right we are more interested in using

00:09:21,740 --> 00:09:25,340
micro Python to create some sort of

00:09:23,720 --> 00:09:27,800
Internet of Things applications for

00:09:25,340 --> 00:09:30,980
example so I'm going to speak about

00:09:27,800 --> 00:09:33,200
seven features of what makes micro

00:09:30,980 --> 00:09:34,940
Python coding different from C Python

00:09:33,200 --> 00:09:37,370
and I think that salmon is the right

00:09:34,940 --> 00:09:40,850
amount for this talk starting from the

00:09:37,370 --> 00:09:43,100
future number zero as we count stuff in

00:09:40,850 --> 00:09:44,210
Python the development process it's

00:09:43,100 --> 00:09:48,500
really different

00:09:44,210 --> 00:09:51,530
well first think first you have only

00:09:48,500 --> 00:09:54,050
your own program run on microcontroller

00:09:51,530 --> 00:09:56,270
your microcontroller so you have no

00:09:54,050 --> 00:09:58,310
operating system so you don't have any

00:09:56,270 --> 00:09:59,750
processes and your threads and you are

00:09:58,310 --> 00:10:03,350
really the only program that is being

00:09:59,750 --> 00:10:06,650
run and you don't have your usual

00:10:03,350 --> 00:10:09,260
devices to for example enter stuff using

00:10:06,650 --> 00:10:12,380
keyboard to display stuff so you connect

00:10:09,260 --> 00:10:15,230
your device using a serial cable and the

00:10:12,380 --> 00:10:17,510
only way to upload some stuff to your

00:10:15,230 --> 00:10:20,300
device is via this serial USB connection

00:10:17,510 --> 00:10:22,490
so the first thing you should do is to

00:10:20,300 --> 00:10:24,500
flash the actual image the binary

00:10:22,490 --> 00:10:27,920
compiled image of micro Python to this

00:10:24,500 --> 00:10:29,870
board before esp8266 for this little

00:10:27,920 --> 00:10:32,090
board for example you can download it

00:10:29,870 --> 00:10:33,830
directly from the micro Python website

00:10:32,090 --> 00:10:35,840
and upload it using the package called

00:10:33,830 --> 00:10:38,450
ESP tool with a bunch of different

00:10:35,840 --> 00:10:41,870
options for that and then you'll get

00:10:38,450 --> 00:10:44,030
your rebel interactive rebel session

00:10:41,870 --> 00:10:46,040
available again we are this serial

00:10:44,030 --> 00:10:48,230
connection you'll get you the user stuff

00:10:46,040 --> 00:10:50,510
your compiler your exact function and

00:10:48,230 --> 00:10:53,570
multiply them for example will emulate

00:10:50,510 --> 00:10:55,520
or actually create a file system for you

00:10:53,570 --> 00:10:58,490
remember you don't have an operating

00:10:55,520 --> 00:11:00,230
systems you don't have your file system

00:10:58,490 --> 00:11:02,480
drivers there is no file system there

00:11:00,230 --> 00:11:04,850
micro Python will create one for you in

00:11:02,480 --> 00:11:05,960
order to provide you the ability to

00:11:04,850 --> 00:11:08,420
store two

00:11:05,960 --> 00:11:10,700
store staff using the convenient API of

00:11:08,420 --> 00:11:12,110
the file system so this way you can

00:11:10,700 --> 00:11:14,510
actually store your own programs and

00:11:12,110 --> 00:11:16,280
this is the main way actually so for

00:11:14,510 --> 00:11:19,130
example you can in the interactive

00:11:16,280 --> 00:11:22,490
session you can enter the you can open

00:11:19,130 --> 00:11:24,200
your pile and start putting your Python

00:11:22,490 --> 00:11:26,320
code in there as strings and then you

00:11:24,200 --> 00:11:29,210
save this file on your filesystem and

00:11:26,320 --> 00:11:32,150
you then can import your modules and

00:11:29,210 --> 00:11:34,280
this is the process for putting them

00:11:32,150 --> 00:11:36,560
onto your disk there are also command

00:11:34,280 --> 00:11:38,660
line tools to automate that but since

00:11:36,560 --> 00:11:41,000
I'm the lead developer of pumpkin

00:11:38,660 --> 00:11:42,410
intuition I thought that it could be a

00:11:41,000 --> 00:11:44,720
good idea to create a micro Python

00:11:42,410 --> 00:11:46,040
plugin for pycharm so if for example

00:11:44,720 --> 00:11:48,140
this plugin provides you with the

00:11:46,040 --> 00:11:50,960
ability to just click on a file and

00:11:48,140 --> 00:11:53,030
upload it to micro Python to execute it

00:11:50,960 --> 00:11:54,740
there but it also provides some static

00:11:53,030 --> 00:11:56,750
code analysis capabilities for example

00:11:54,740 --> 00:11:58,730
it will provide you with completion for

00:11:56,750 --> 00:12:00,350
markup Python modules and it will

00:11:58,730 --> 00:12:02,180
provide you with type checking and other

00:12:00,350 --> 00:12:05,390
code inspections that will ensure that

00:12:02,180 --> 00:12:07,940
your code looks correct and even more I

00:12:05,390 --> 00:12:09,620
have provided documentation for built-in

00:12:07,940 --> 00:12:12,230
functions and for functions from some

00:12:09,620 --> 00:12:16,100
micro passing modules the way I did it

00:12:12,230 --> 00:12:17,890
is by using Python type hinting stubs so

00:12:16,100 --> 00:12:21,320
there are some stuffed files where I

00:12:17,890 --> 00:12:24,290
actually recreate the API so of these

00:12:21,320 --> 00:12:26,420
modules using the pite the python type

00:12:24,290 --> 00:12:31,460
hinting syntax and the reason there is

00:12:26,420 --> 00:12:34,010
no documentation for the micro Python

00:12:31,460 --> 00:12:35,480
modules on the ESP devices or on other

00:12:34,010 --> 00:12:37,550
micro Python devices isn't that because

00:12:35,480 --> 00:12:40,130
dog strings just consume memory and

00:12:37,550 --> 00:12:42,530
don't do anything else and they don't

00:12:40,130 --> 00:12:44,780
put it there but here in in the in this

00:12:42,530 --> 00:12:46,940
plugin using type company installs you

00:12:44,780 --> 00:12:48,890
are able to look at your documentation

00:12:46,940 --> 00:12:51,170
while you are developing your code but

00:12:48,890 --> 00:12:53,930
that's enough about self-promotion let's

00:12:51,170 --> 00:12:56,030
continue with micro Python next the

00:12:53,930 --> 00:12:57,470
types of devices well there are some

00:12:56,030 --> 00:13:01,100
types of devices you might want to

00:12:57,470 --> 00:13:03,530
consider for example people often create

00:13:01,100 --> 00:13:05,000
sensors with their micro Python devices

00:13:03,530 --> 00:13:07,220
like temperature sensors or

00:13:05,000 --> 00:13:08,780
accelerometer so stuff like that and the

00:13:07,220 --> 00:13:10,580
typical program structure for this kind

00:13:08,780 --> 00:13:12,440
of device look looks like that you have

00:13:10,580 --> 00:13:14,060
your while true loop because again you

00:13:12,440 --> 00:13:16,010
are the only program that's run on your

00:13:14,060 --> 00:13:18,670
device so you have to run it forever and

00:13:16,010 --> 00:13:20,500
then you basically take a measurement

00:13:18,670 --> 00:13:22,840
from your sensor you store this data

00:13:20,500 --> 00:13:26,500
somewhere on your own memory or you can

00:13:22,840 --> 00:13:29,680
for example send it via Wi-Fi if you are

00:13:26,500 --> 00:13:32,050
an IOT device and then you go to sleep

00:13:29,680 --> 00:13:34,450
until the next day it's time to read the

00:13:32,050 --> 00:13:36,490
next portion of data another type of

00:13:34,450 --> 00:13:38,380
device what you might want to consider

00:13:36,490 --> 00:13:39,850
is controllers controllers actually

00:13:38,380 --> 00:13:42,430
control physical equipment physical

00:13:39,850 --> 00:13:44,290
hardware like LEDs like motors or

00:13:42,430 --> 00:13:47,350
switches and so on the protein structure

00:13:44,290 --> 00:13:49,420
looks similar to sensors but when you

00:13:47,350 --> 00:13:50,950
get some data from your user like when

00:13:49,420 --> 00:13:52,930
the user presses some button you

00:13:50,950 --> 00:13:55,240
actually have to drive your device you

00:13:52,930 --> 00:13:59,380
have to enable it you have to power it

00:13:55,240 --> 00:14:02,110
all or send you some commands to act for

00:13:59,380 --> 00:14:03,670
this device to react upon it so the

00:14:02,110 --> 00:14:05,460
program structure looks like that but

00:14:03,670 --> 00:14:07,840
there is an important kind of

00:14:05,460 --> 00:14:09,700
controllers called negative feedback

00:14:07,840 --> 00:14:12,910
loop controllers or just basically

00:14:09,700 --> 00:14:14,920
robots these devices maintain some

00:14:12,910 --> 00:14:16,960
constant conditions they live in some

00:14:14,920 --> 00:14:20,140
environment for example a thermostat is

00:14:16,960 --> 00:14:22,930
a good example of robot or for example a

00:14:20,140 --> 00:14:28,060
drone the term a thermostat

00:14:22,930 --> 00:14:29,950
keeps the amount of the the temperature

00:14:28,060 --> 00:14:31,480
constant so basically you have to read

00:14:29,950 --> 00:14:34,390
your actual temperature compared

00:14:31,480 --> 00:14:36,370
compared to your desired temperature and

00:14:34,390 --> 00:14:38,500
there is any different you should act

00:14:36,370 --> 00:14:40,570
upon this different to compensate for

00:14:38,500 --> 00:14:42,250
that and the same stuff applies to

00:14:40,570 --> 00:14:44,470
drones or for example for automotive

00:14:42,250 --> 00:14:47,140
electronics for example like anti-lock

00:14:44,470 --> 00:14:50,350
in braking systems they are all run on

00:14:47,140 --> 00:14:52,410
microcontrollers next thing is

00:14:50,350 --> 00:14:54,190
electronics well it's hard to talk about

00:14:52,410 --> 00:14:57,370
microcontrollers and not to mention

00:14:54,190 --> 00:14:59,470
electronics at least once well luckily

00:14:57,370 --> 00:15:01,450
for us only a few basic concepts of

00:14:59,470 --> 00:15:03,310
electronics are acquired so basically in

00:15:01,450 --> 00:15:04,420
order to start working this micro Python

00:15:03,310 --> 00:15:07,120
you only need your school level

00:15:04,420 --> 00:15:09,640
knowledge or physics or of electronics

00:15:07,120 --> 00:15:11,170
you have to know what the voltage is

00:15:09,640 --> 00:15:14,020
what the electric current is you have to

00:15:11,170 --> 00:15:15,730
know the Ohm's law obviously and just

00:15:14,020 --> 00:15:17,170
using this information you'll be able to

00:15:15,730 --> 00:15:20,020
create small projects like for example

00:15:17,170 --> 00:15:22,150
process will with LEDs the only extra

00:15:20,020 --> 00:15:24,400
thing you have to know is that LEDs have

00:15:22,150 --> 00:15:28,180
polarity so you have to respect that and

00:15:24,400 --> 00:15:30,040
they are sensitive to high levels of

00:15:28,180 --> 00:15:32,019
voltages and currents so you have to

00:15:30,040 --> 00:15:34,540
calculate the amount of

00:15:32,019 --> 00:15:36,819
stones you have to add to your

00:15:34,540 --> 00:15:39,819
electronic components in order to make

00:15:36,819 --> 00:15:43,899
this thing work and not to burn you can

00:15:39,819 --> 00:15:45,759
actually while while you aren't playing

00:15:43,899 --> 00:15:47,769
around with microcontrollers will you

00:15:45,759 --> 00:15:49,989
will encounter that there are recurrent

00:15:47,769 --> 00:15:51,819
patterns of electronics that you will be

00:15:49,989 --> 00:15:54,069
using with your devices for example of

00:15:51,819 --> 00:15:56,379
resistors batteries capacitors and so on

00:15:54,069 --> 00:15:59,769
and there are good tutorials on these

00:15:56,379 --> 00:16:02,529
topics that are very easy to read and so

00:15:59,769 --> 00:16:04,269
on using this URL this is a great

00:16:02,529 --> 00:16:07,660
resource to learn about basic stuff in

00:16:04,269 --> 00:16:10,029
electronics next up memory usage well

00:16:07,660 --> 00:16:12,129
I've talked a lot about how it was

00:16:10,029 --> 00:16:14,889
important for micro Python itself to

00:16:12,129 --> 00:16:18,339
keep them memory footprint low well you

00:16:14,889 --> 00:16:20,649
have to help in order to not use too

00:16:18,339 --> 00:16:21,910
much memory in your own code and from

00:16:20,649 --> 00:16:23,529
the practical point of view this

00:16:21,910 --> 00:16:25,629
basically means procedural programming

00:16:23,529 --> 00:16:27,579
so forget about your object-oriented

00:16:25,629 --> 00:16:29,439
class hierarchies with complex

00:16:27,579 --> 00:16:30,939
inheritance patterns and forget about

00:16:29,439 --> 00:16:32,860
your functional programming your pure

00:16:30,939 --> 00:16:34,929
functions that transmit transform

00:16:32,860 --> 00:16:37,149
immutable data you have to stick with

00:16:34,929 --> 00:16:39,999
basic stuff like yeah like you do in C

00:16:37,149 --> 00:16:41,949
with buffers that you reuse in order to

00:16:39,999 --> 00:16:44,019
not tolerate new memory and stuff like

00:16:41,949 --> 00:16:46,119
that unfortunately that is the case but

00:16:44,019 --> 00:16:47,920
I see it as a challenge because it's

00:16:46,119 --> 00:16:52,569
interesting how this kind of programming

00:16:47,920 --> 00:16:53,279
fits can be really used in your Python

00:16:52,569 --> 00:16:57,309
code

00:16:53,279 --> 00:17:00,069
next thing is device drivers when you

00:16:57,309 --> 00:17:02,230
think about your device driver usually

00:17:00,069 --> 00:17:03,639
think about like go into the Internet to

00:17:02,230 --> 00:17:05,409
download a driver for your printer it's

00:17:03,639 --> 00:17:07,839
some magical software that makes things

00:17:05,409 --> 00:17:09,730
work but in this world of my controllers

00:17:07,839 --> 00:17:12,279
you can write drivers in Python

00:17:09,730 --> 00:17:13,899
basically drivers are just libraries for

00:17:12,279 --> 00:17:16,689
working with your devices for example

00:17:13,899 --> 00:17:18,880
for this device it's a temperature and

00:17:16,689 --> 00:17:20,949
humidity sensor you can create your own

00:17:18,880 --> 00:17:23,319
driver well you have to know something

00:17:20,949 --> 00:17:25,329
about it like the spec about this device

00:17:23,319 --> 00:17:27,370
it has some pins it uses some wire

00:17:25,329 --> 00:17:29,440
protocol called I to see to communicate

00:17:27,370 --> 00:17:31,270
with you and to transmit this data but

00:17:29,440 --> 00:17:33,610
more or less this is the complete source

00:17:31,270 --> 00:17:35,590
code of this device driver in Python so

00:17:33,610 --> 00:17:37,779
basically you can see some concepts I

00:17:35,590 --> 00:17:40,000
have already talked about like only

00:17:37,779 --> 00:17:41,980
occasional use of object-oriented

00:17:40,000 --> 00:17:44,139
programming just to put your function as

00:17:41,980 --> 00:17:45,820
and your data structures together but

00:17:44,139 --> 00:17:48,220
other than that it's like

00:17:45,820 --> 00:17:51,160
procedural call you have your bytearray

00:17:48,220 --> 00:17:53,100
as a buffer that you reuse over and over

00:17:51,160 --> 00:17:55,990
and your each stuff into this buffer and

00:17:53,100 --> 00:17:57,670
then you have just like integers

00:17:55,990 --> 00:18:00,070
operations in order to calculate the

00:17:57,670 --> 00:18:02,890
actual value of temperature and humidity

00:18:00,070 --> 00:18:04,660
from this sensor and the implementation

00:18:02,890 --> 00:18:06,820
of the wire protocol for I to see is

00:18:04,660 --> 00:18:09,040
provides it by your microcontroller

00:18:06,820 --> 00:18:10,540
bye-bye sorry by your micro Python

00:18:09,040 --> 00:18:12,580
implementation so that you don't have to

00:18:10,540 --> 00:18:14,560
worry that much about it

00:18:12,580 --> 00:18:16,660
next stop hardware interrupt when you

00:18:14,560 --> 00:18:18,730
talk about hardware people often talk

00:18:16,660 --> 00:18:21,460
about things like the like I refuse or

00:18:18,730 --> 00:18:23,770
interrupt requests Hardware interrupts

00:18:21,460 --> 00:18:25,000
are basically callbacks if you are

00:18:23,770 --> 00:18:28,090
familiar with the web programming for

00:18:25,000 --> 00:18:30,340
example you know that you can set up a

00:18:28,090 --> 00:18:32,620
callback when there is an answer to your

00:18:30,340 --> 00:18:34,300
HTTP request a response for it

00:18:32,620 --> 00:18:36,280
well hardware interrupts are like

00:18:34,300 --> 00:18:38,560
callbacks but for hardware grants for

00:18:36,280 --> 00:18:40,300
example when the amount of voltage on

00:18:38,560 --> 00:18:42,250
that pin of your microcontroller God

00:18:40,300 --> 00:18:45,580
goes from digital zero to digital one

00:18:42,250 --> 00:18:47,740
you'll get your interrupt request your

00:18:45,580 --> 00:18:50,230
callback will be called so the code

00:18:47,740 --> 00:18:52,120
looks like regular Python callbacks the

00:18:50,230 --> 00:18:57,850
only thing is that you cannot do that

00:18:52,120 --> 00:19:00,310
much in this hardware callback functions

00:18:57,850 --> 00:19:02,140
because you have to be very careful this

00:19:00,310 --> 00:19:05,500
interrupt can occur at anything at any

00:19:02,140 --> 00:19:07,840
time and even during your micro Python

00:19:05,500 --> 00:19:09,310
internal working like in the middle of

00:19:07,840 --> 00:19:11,050
garbage collection for example and you

00:19:09,310 --> 00:19:12,670
obviously don't want to mess up with

00:19:11,050 --> 00:19:14,500
garbage collections who don't have you

00:19:12,670 --> 00:19:18,400
have to not retro locate any new memory

00:19:14,500 --> 00:19:20,260
here the item number six is power

00:19:18,400 --> 00:19:22,570
management it's in specially important

00:19:20,260 --> 00:19:25,180
for sound source you want your sensors

00:19:22,570 --> 00:19:27,520
to work on better in order to make them

00:19:25,180 --> 00:19:30,250
autonomous and if you take a typical

00:19:27,520 --> 00:19:32,620
battery and a typical ESP device it will

00:19:30,250 --> 00:19:35,580
live only from one day this is nowhere

00:19:32,620 --> 00:19:39,670
near enough and if you are careful with

00:19:35,580 --> 00:19:41,950
things and you use for examples machine

00:19:39,670 --> 00:19:45,820
that I'll in order to save some memory

00:19:41,950 --> 00:19:48,640
when you don't do stuff then you can get

00:19:45,820 --> 00:19:50,770
two days but in order to get more you

00:19:48,640 --> 00:19:53,110
have to use a technique called

00:19:50,770 --> 00:19:55,360
deep sleep basically you power down your

00:19:53,110 --> 00:19:57,520
CPU completely well first of all you

00:19:55,360 --> 00:19:59,630
store some state in order to be able to

00:19:57,520 --> 00:20:01,400
restore from from this power down but

00:19:59,630 --> 00:20:04,250
then you power down your CPU so it

00:20:01,400 --> 00:20:06,290
doesn't consume any energy and the only

00:20:04,250 --> 00:20:08,660
thing that keeps trying on your board is

00:20:06,290 --> 00:20:10,550
actually the real-time clock and you set

00:20:08,660 --> 00:20:15,380
your alarm clock in order to wake your

00:20:10,550 --> 00:20:17,900
Micah your CPU up after a certain amount

00:20:15,380 --> 00:20:20,540
of time and this way you can make your

00:20:17,900 --> 00:20:24,560
sensors work for like six months or so

00:20:20,540 --> 00:20:26,750
and item number seven is debugging well

00:20:24,560 --> 00:20:28,520
debugging is hard it was always hard but

00:20:26,750 --> 00:20:31,430
there is something wrong with my slide

00:20:28,520 --> 00:20:33,170
right and the reason for it is that I

00:20:31,430 --> 00:20:35,570
promise to talk about seven features and

00:20:33,170 --> 00:20:37,700
I started to count my fishes from zero

00:20:35,570 --> 00:20:40,400
and the debugging it was the seventh

00:20:37,700 --> 00:20:43,460
feature so I'm out of my range of my

00:20:40,400 --> 00:20:46,520
byte array of features so in micro

00:20:43,460 --> 00:20:48,770
Python and a simpleton if you access the

00:20:46,520 --> 00:20:51,380
item that is out of range you will get a

00:20:48,770 --> 00:20:53,330
nice index error the trace back that

00:20:51,380 --> 00:20:54,890
will have to debug your program and it's

00:20:53,330 --> 00:20:56,180
very helpful and it's really different

00:20:54,890 --> 00:20:57,980
from what you used to have on

00:20:56,180 --> 00:20:59,930
microcontrollers using C for example

00:20:57,980 --> 00:21:01,790
when your program just starts to behave

00:20:59,930 --> 00:21:04,130
sporadically when you read some random

00:21:01,790 --> 00:21:06,590
data from your memory and also having an

00:21:04,130 --> 00:21:08,690
interactive variable how helps a lot

00:21:06,590 --> 00:21:11,000
when you debug your code but I guess

00:21:08,690 --> 00:21:11,780
that's pretty much it because you don't

00:21:11,000 --> 00:21:16,220
have for example your step-by-step

00:21:11,780 --> 00:21:20,300
debugger yet and just to recap micro

00:21:16,220 --> 00:21:23,240
Python is highly optimized for memory

00:21:20,300 --> 00:21:26,060
usage and it's more or less compatible

00:21:23,240 --> 00:21:28,040
with the Python 3.4 and coding for

00:21:26,060 --> 00:21:31,490
microcontrollers it's really a fun it's

00:21:28,040 --> 00:21:33,080
a bit different but I can promise you

00:21:31,490 --> 00:21:34,730
it's a lot of fun to create your own

00:21:33,080 --> 00:21:37,220
hardware devices your Internet of Things

00:21:34,730 --> 00:21:38,810
applications or your combinations of

00:21:37,220 --> 00:21:41,570
hardware and software to create for

00:21:38,810 --> 00:21:45,980
example games for kids and so on and I

00:21:41,570 --> 00:21:49,070
have a few devices like BBC micro beat

00:21:45,980 --> 00:21:51,560
pie board and others you can stop by our

00:21:49,070 --> 00:21:54,230
booth at the expo hall right next to

00:21:51,560 --> 00:21:56,390
this room and I'll show you various live

00:21:54,230 --> 00:21:58,370
demos so you can get the hands-on

00:21:56,390 --> 00:21:59,780
experience with these devices and you

00:21:58,370 --> 00:22:03,420
can always reach me on Twitter if you

00:21:59,780 --> 00:22:12,989
have any questions so thank you

00:22:03,420 --> 00:22:12,989
[Applause]

00:22:14,360 --> 00:22:22,050
gives a try to my profile and maybe some

00:22:17,520 --> 00:22:24,120
IOT projects at home so if you have any

00:22:22,050 --> 00:22:26,870
questions now you can reach out to the

00:22:24,120 --> 00:22:26,870
mic on the side

00:22:31,379 --> 00:22:38,320
thank you for if I understand

00:22:36,190 --> 00:22:44,049
correctly when you upload your script it

00:22:38,320 --> 00:22:46,269
leaves in the memory yeah when when

00:22:44,049 --> 00:22:48,369
micro path interprets your Python code

00:22:46,269 --> 00:22:52,659
that keeps in in RAM yeah so you should

00:22:48,369 --> 00:22:57,729
be careful with not writing to large

00:22:52,659 --> 00:23:00,460
programs yeah yeah all you can rewrite

00:22:57,729 --> 00:23:01,179
stuff in C and put it in wrong but it's

00:23:00,460 --> 00:23:05,529
not ideal

00:23:01,179 --> 00:23:07,539
I saw us actually working on my

00:23:05,529 --> 00:23:09,460
microbiome project it was supposed to be

00:23:07,539 --> 00:23:11,229
like a music controller and why it's

00:23:09,460 --> 00:23:14,950
important because it has both input and

00:23:11,229 --> 00:23:17,080
display and I noticed because I got

00:23:14,950 --> 00:23:19,059
schooled in like assembly 10 years ago

00:23:17,080 --> 00:23:21,339
and so on and I'm basically done

00:23:19,059 --> 00:23:23,379
everything that man was no peeing and

00:23:21,339 --> 00:23:25,719
everything was basically in interrupts

00:23:23,379 --> 00:23:27,399
and my question is basically with Python

00:23:25,719 --> 00:23:30,009
now because we can't really go that much

00:23:27,399 --> 00:23:31,629
into object objective flex type

00:23:30,009 --> 00:23:33,700
programming how do you actually manage

00:23:31,629 --> 00:23:35,229
all this state when you everything like

00:23:33,700 --> 00:23:37,119
I know you have multiple buttons they

00:23:35,229 --> 00:23:40,359
all can interrupt each other's work but

00:23:37,119 --> 00:23:42,519
you can only like on your display have

00:23:40,359 --> 00:23:44,289
one thing to read on like how do you

00:23:42,519 --> 00:23:46,659
manage the state with having so many

00:23:44,289 --> 00:23:49,719
interrupts to work in the same space in

00:23:46,659 --> 00:23:52,359
the same device like if you not only one

00:23:49,719 --> 00:23:54,369
at the time yeah well I guess there are

00:23:52,359 --> 00:23:56,739
many techniques the thing I used

00:23:54,369 --> 00:24:00,009
personally is that I had a global object

00:23:56,739 --> 00:24:02,349
and store states in their fields more or

00:24:00,009 --> 00:24:04,119
less stuff like that so I don't know of

00:24:02,349 --> 00:24:23,379
any advanced techniques for managing

00:24:04,119 --> 00:24:25,809
this problem and for I guess there is no

00:24:23,379 --> 00:24:28,719
simple answer to this question if your

00:24:25,809 --> 00:24:31,210
battery dies that you cannot debug it

00:24:28,719 --> 00:24:33,519
and if your device is currently in deep

00:24:31,210 --> 00:24:36,039
sleep you have to provide a hardware

00:24:33,519 --> 00:24:40,200
signal to wake it up so debugging could

00:24:36,039 --> 00:24:40,200
be complicated for these applications

00:24:46,830 --> 00:24:53,399
you can run your micro Python

00:24:48,720 --> 00:24:56,399
interpreter on your laptop there won't

00:24:53,399 --> 00:24:58,889
be any hardware specific modules for

00:24:56,399 --> 00:25:01,649
that but if you mock them then you can

00:24:58,889 --> 00:25:14,639
test your like core logic but not the

00:25:01,649 --> 00:25:18,720
communications you have to mock them you

00:25:14,639 --> 00:25:21,869
mean CPU ice or memory wise I saw these

00:25:18,720 --> 00:25:23,850
back benchmarks on the internet don't

00:25:21,869 --> 00:25:26,009
remember the correctly the site for it

00:25:23,850 --> 00:25:27,929
but yeah there were benchmarks and I

00:25:26,009 --> 00:25:31,919
know that some people even used micro

00:25:27,929 --> 00:25:34,440
Python on their laptops just to consume

00:25:31,919 --> 00:25:36,059
less memory and to write faster code but

00:25:34,440 --> 00:25:48,119
of course this approach is limited to

00:25:36,059 --> 00:26:07,379
certain applications nothing comes to my

00:25:48,119 --> 00:26:11,789
mind unfortunately ah yes a right well

00:26:07,379 --> 00:26:14,759
if you buy devices like in small amounts

00:26:11,789 --> 00:26:18,179
then they cost more but you can order a

00:26:14,759 --> 00:26:20,580
huge pile of devices and then you'll get

00:26:18,179 --> 00:26:23,879
discounts I mean if you create consumer

00:26:20,580 --> 00:26:29,039
devices you create to sell them and you

00:26:23,879 --> 00:26:40,619
can buy them in bulk in order to reduce

00:26:29,039 --> 00:26:42,840
the cost divided by unit to tell people

00:26:40,619 --> 00:26:45,559
that there is an open space today at 4

00:26:42,840 --> 00:26:45,559
or great

00:26:45,750 --> 00:27:02,630
in general so if you are interested in

00:26:48,330 --> 00:27:07,999
that you can call great great thank you

00:27:02,630 --> 00:27:07,999

YouTube URL: https://www.youtube.com/watch?v=Hy0W8tBpZu4


