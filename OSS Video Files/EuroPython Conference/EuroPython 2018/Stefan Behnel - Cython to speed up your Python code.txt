Title: Stefan Behnel - Cython to speed up your Python code
Publication date: 2018-08-30
Playlist: EuroPython 2018
Description: 
	Cython to speed up your Python code
[EuroPython 2018 - Talk - 2018-07-26 - Moorfoot]
[Edinburgh, UK]

By Stefan Behnel

Cython is not only a very fast and comfortable way to talk to native code and libraries, it is also a widely used tool for speeding up Python code. The Cython compiler translates Python code to C or C++ code, and applies many static optimisations that make Python code run visibly faster than in the interpreter. But even better, it supports static type annotations that allow direct use of C/C++ data types and functions, which the compiler uses to convert and optimise the code into fast, native C. The tight integration of all three languages, Python, C and C++, makes it possible to freely mix Python features like generators and comprehensions with C/C++ features like native data types, pointer arithmetic or manually tuned memory management in the same code.

This talk by a core developer introduces the Cython compiler by interactive code examples, and shows how you can use it to speed up your Python code. You will learn how you can profile a Python module and use Cython to compile and optimise it into a fast binary extension module. All of that, without losing the ability to run it through common development tools like static analysers or coverage test tools.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2018.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:00,420 --> 00:00:06,420
so welcome to my talk it's about

00:00:03,270 --> 00:00:09,740
something yes

00:00:06,420 --> 00:00:12,690
thing is I regularly speak at

00:00:09,740 --> 00:00:14,250
conferences here and there and tell

00:00:12,690 --> 00:00:15,389
people about cycling

00:00:14,250 --> 00:00:18,359
teach them a bit in there I had a

00:00:15,389 --> 00:00:23,119
tutorial on Tuesday here I don't know of

00:00:18,359 --> 00:00:23,119
anyone yeah

00:00:23,310 --> 00:00:27,810
so question now to the audience I can

00:00:26,460 --> 00:00:30,210
present a couple of different things

00:00:27,810 --> 00:00:32,610
depending on what you want who's

00:00:30,210 --> 00:00:35,280
interested in a general introduction to

00:00:32,610 --> 00:00:37,140
siphon understanding but what is was

00:00:35,280 --> 00:00:39,200
like who's never used it and wants to

00:00:37,140 --> 00:00:43,350
know what it is

00:00:39,200 --> 00:00:45,300
that was quite a number of people so the

00:00:43,350 --> 00:00:48,059
actual topic that I proposed for today

00:00:45,300 --> 00:00:50,610
was more like I have some patent code

00:00:48,059 --> 00:00:53,329
and I want to optimize it without losing

00:00:50,610 --> 00:00:58,649
the ability to write it in Python so

00:00:53,329 --> 00:01:01,920
come by let's speed it up that's a bit

00:00:58,649 --> 00:01:10,740
of a less general topic who's interested

00:01:01,920 --> 00:01:12,119
in that who came for that okay so I'll

00:01:10,740 --> 00:01:17,549
just you know jump back and forth

00:01:12,119 --> 00:01:20,090
between whatever I can tell you hi I'm

00:01:17,549 --> 00:01:20,090
chef Anne bina

00:01:20,790 --> 00:01:27,090
I'm software data engineer everyone's

00:01:23,850 --> 00:01:29,939
also a trainer some given site and

00:01:27,090 --> 00:01:33,180
trainings in the air if you want me in

00:01:29,939 --> 00:01:36,150
house just talk to me and you know come

00:01:33,180 --> 00:01:41,220
over and teach your people there I'm

00:01:36,150 --> 00:01:45,860
using Titan since 2002 I am a Titan core

00:01:41,220 --> 00:01:50,720
developer ever since we forked the

00:01:45,860 --> 00:01:50,720
project from an existing project of

00:01:54,590 --> 00:02:00,329
that's what reports and Parks has

00:01:57,810 --> 00:02:03,810
basically not been updated much since

00:02:00,329 --> 00:02:05,250
then so we've pretty much taken over the

00:02:03,810 --> 00:02:09,690
project and everyone's using certain

00:02:05,250 --> 00:02:10,990
these things but thanks Greg for writing

00:02:09,690 --> 00:02:16,150
tires because

00:02:10,990 --> 00:02:19,060
wonderful tool to build site on so I do

00:02:16,150 --> 00:02:20,830
trainee salute consulting and I should

00:02:19,060 --> 00:02:24,700
joint trust you responded this

00:02:20,830 --> 00:02:29,370
conference last year and this motivating

00:02:24,700 --> 00:02:34,560
example a bit I'll tell you what you do

00:02:29,370 --> 00:02:36,850
so if you look forward tell in Google

00:02:34,560 --> 00:02:38,050
you'll see something that's right you'll

00:02:36,850 --> 00:02:40,540
get a lot of information about the hotel

00:02:38,050 --> 00:02:42,370
and if you click around a bit

00:02:40,540 --> 00:02:43,810
you'll also see that you know some of

00:02:42,370 --> 00:02:49,180
this information was actually provided

00:02:43,810 --> 00:02:52,810
by trust you so we know what hotel is

00:02:49,180 --> 00:02:55,600
and how good our channel is how do we do

00:02:52,810 --> 00:02:59,680
that well we crawl the web and we have

00:02:55,600 --> 00:03:01,290
partners and we reach hotel reviews by

00:02:59,680 --> 00:03:04,030
extra people all around the world

00:03:01,290 --> 00:03:07,690
collect them at a rate of about three

00:03:04,030 --> 00:03:09,850
million hotel reviews every week and

00:03:07,690 --> 00:03:13,600
then we do text analysis on them with

00:03:09,850 --> 00:03:15,190
data processing on them and we do that

00:03:13,600 --> 00:03:18,010
in lots of different languages including

00:03:15,190 --> 00:03:21,970
Spanish time Mandarin Japanese lots of

00:03:18,010 --> 00:03:23,830
languages and build this kind of

00:03:21,970 --> 00:03:28,630
information from it so we summarize all

00:03:23,830 --> 00:03:32,890
this there's a metal review so just a

00:03:28,630 --> 00:03:34,840
summarization of everything that 45,000

00:03:32,890 --> 00:03:38,200
people have been saying about hotels in

00:03:34,840 --> 00:03:40,840
this case and we can tell you what's

00:03:38,200 --> 00:03:43,150
special about you tell what people like

00:03:40,840 --> 00:03:44,860
what people dislike all of these things

00:03:43,150 --> 00:03:48,580
and you can actually go to trust you

00:03:44,860 --> 00:03:50,260
become anti Hotel name there and see

00:03:48,580 --> 00:03:53,860
this information about any Hotel you

00:03:50,260 --> 00:03:55,660
want pretty much all over the world so

00:03:53,860 --> 00:03:57,220
trust you no surprise and love data we

00:03:55,660 --> 00:04:01,210
all do all of a data processing in

00:03:57,220 --> 00:04:03,430
pattern and we used kind of the usual

00:04:01,210 --> 00:04:07,570
tools you would expect with numpy we use

00:04:03,430 --> 00:04:08,380
side by side learn pandas view space it

00:04:07,570 --> 00:04:11,380
to a certain extent

00:04:08,380 --> 00:04:17,830
Alex ml for the data extraction from the

00:04:11,380 --> 00:04:21,250
web and many of these tools actually use

00:04:17,830 --> 00:04:22,200
seitan or implemented in siphon some of

00:04:21,250 --> 00:04:26,850
them completely

00:04:22,200 --> 00:04:29,580
mostly and they're part of the Python

00:04:26,850 --> 00:04:31,410
data ecosystem so why is that an

00:04:29,580 --> 00:04:33,090
ecosystem oh it's an ecosystem because

00:04:31,410 --> 00:04:35,130
it's integrated okay

00:04:33,090 --> 00:04:39,530
everything works nicely together it

00:04:35,130 --> 00:04:42,540
change together and a big part of that

00:04:39,530 --> 00:04:45,990
came from the fact that people develop

00:04:42,540 --> 00:04:48,750
an umpire as basically in a data

00:04:45,990 --> 00:04:51,540
integration layer that all these tools

00:04:48,750 --> 00:04:53,780
could use could put that data into could

00:04:51,540 --> 00:04:57,000
use to share their data across some

00:04:53,780 --> 00:04:59,790
different different libraries even pass

00:04:57,000 --> 00:05:03,000
data on inter see libraries into native

00:04:59,790 --> 00:05:05,910
code to process this data so numpy

00:05:03,000 --> 00:05:08,070
integrates the data layer and you can

00:05:05,910 --> 00:05:10,530
say that cycling is the way to integrate

00:05:08,070 --> 00:05:12,840
the cold layer because what does I can

00:05:10,530 --> 00:05:17,520
give you it allows you to talk to native

00:05:12,840 --> 00:05:20,490
code it allows you to use all these tons

00:05:17,520 --> 00:05:22,170
of native libraries C libraries Fortran

00:05:20,490 --> 00:05:24,540
libraries out there connect them to a

00:05:22,170 --> 00:05:27,570
Python use them from Python integrate

00:05:24,540 --> 00:05:30,150
these libraries from your Python runtime

00:05:27,570 --> 00:05:34,410
okay so we're not pi integrates data

00:05:30,150 --> 00:05:36,780
sight integrates code so what is citing

00:05:34,410 --> 00:05:39,960
good for what integrates native code

00:05:36,780 --> 00:05:42,080
into Python that's one use case many

00:05:39,960 --> 00:05:46,800
people use it to speed up tighten code

00:05:42,080 --> 00:05:50,880
by compiling it compiling it in native

00:05:46,800 --> 00:05:53,970
code and surprisingly many people

00:05:50,880 --> 00:05:58,200
actually use it to write C code without

00:05:53,970 --> 00:05:59,910
having to write C code you know writing

00:05:58,200 --> 00:06:02,040
sequel is actually hard but impractical

00:05:59,910 --> 00:06:05,340
is much more fun and citing allows you

00:06:02,040 --> 00:06:08,880
to write patent code that translates to

00:06:05,340 --> 00:06:11,370
C so writing C without writing C so we

00:06:08,880 --> 00:06:13,280
write the C code so you don't have to

00:06:11,370 --> 00:06:15,720
[Music]

00:06:13,280 --> 00:06:20,400
our topic for today is speeding up

00:06:15,720 --> 00:06:22,170
patent code so kind of focus on that why

00:06:20,400 --> 00:06:23,580
you use site in general it's very

00:06:22,170 --> 00:06:25,020
pragmatic programming language it's

00:06:23,580 --> 00:06:28,080
actually a programming language so it's

00:06:25,020 --> 00:06:29,700
extends Python but it is Python you can

00:06:28,080 --> 00:06:32,580
take arbitrary pi think I would drop it

00:06:29,700 --> 00:06:34,370
into side and compile it usually runs

00:06:32,580 --> 00:06:38,570
faster

00:06:34,370 --> 00:06:42,020
but you can also use extended syntax or

00:06:38,570 --> 00:06:43,520
type annotations in the air to speed up

00:06:42,020 --> 00:06:46,940
your code to tell the compiler how to

00:06:43,520 --> 00:06:49,370
optimize your code beyond what the

00:06:46,940 --> 00:06:51,440
patent language allows so it's an

00:06:49,370 --> 00:06:54,590
optimizing compiler it's actually very

00:06:51,440 --> 00:06:57,020
production proven it's used to run I

00:06:54,590 --> 00:07:02,810
mean sure you showed you a cup of tools

00:06:57,020 --> 00:07:04,610
that uses its it's used to process

00:07:02,810 --> 00:07:06,740
I don't know only terabytes many

00:07:04,610 --> 00:07:09,169
petabytes of data out there

00:07:06,740 --> 00:07:11,690
and all sorts of Python libraries it's

00:07:09,169 --> 00:07:13,790
really widely used and the cool thing

00:07:11,690 --> 00:07:16,070
what language is that it's really about

00:07:13,790 --> 00:07:18,050
getting things done in the same way the

00:07:16,070 --> 00:07:20,450
Python I did it keeps you focus on the

00:07:18,050 --> 00:07:22,280
functionality rather than heaven on

00:07:20,450 --> 00:07:25,280
haven't you to look into all the

00:07:22,280 --> 00:07:27,740
boilerplate that it would need to do

00:07:25,280 --> 00:07:30,380
tour to a library or to speed up your

00:07:27,740 --> 00:07:32,480
photo optimizes you know if you optimize

00:07:30,380 --> 00:07:35,720
the code by rewriting it in a native

00:07:32,480 --> 00:07:39,350
language and C or C++ it gets really

00:07:35,720 --> 00:07:41,210
messy it's way more difficult than

00:07:39,350 --> 00:07:43,400
taking your existing Python code you

00:07:41,210 --> 00:07:45,530
test a Python code and just you know

00:07:43,400 --> 00:07:46,930
making it faster rather than rewriting

00:07:45,530 --> 00:07:53,000
it

00:07:46,930 --> 00:07:54,950
so one the the main property of the

00:07:53,000 --> 00:08:00,010
language legend that it allows to freely

00:07:54,950 --> 00:08:02,720
move between Python and C or C++ so

00:08:00,010 --> 00:08:05,770
takes Python code but it allows you to

00:08:02,720 --> 00:08:09,229
mix in C data types or C++ data types

00:08:05,770 --> 00:08:12,110
right in your pass code okay and that's

00:08:09,229 --> 00:08:14,060
the way for the compiler to decide that

00:08:12,110 --> 00:08:16,850
you as a user you were actually opting

00:08:14,060 --> 00:08:19,460
out of Python semantics

00:08:16,850 --> 00:08:22,130
typing object operations and saying you

00:08:19,460 --> 00:08:25,340
know all I really need here is a

00:08:22,130 --> 00:08:27,350
calculation of C doubles right native

00:08:25,340 --> 00:08:29,360
datatypes be fast I don't care about

00:08:27,350 --> 00:08:31,610
object operations anyway I don't want to

00:08:29,360 --> 00:08:33,289
pass around stuff through Python and so

00:08:31,610 --> 00:08:35,990
it just you know make it files computed

00:08:33,289 --> 00:08:38,839
as fast as you can and to make the

00:08:35,990 --> 00:08:40,550
language makes it very easy so it's lots

00:08:38,839 --> 00:08:44,480
of you right for that as passed on it as

00:08:40,550 --> 00:08:46,930
you want but as low level as mint okay

00:08:44,480 --> 00:08:46,930
first demo

00:08:48,100 --> 00:08:55,190
does everyone know the Jupiter notebook

00:08:50,750 --> 00:08:57,230
who does not know it nice it's just you

00:08:55,190 --> 00:09:00,440
know Jupiter's wonderful it's a

00:08:57,230 --> 00:09:03,890
wonderful piece of something it's a very

00:09:00,440 --> 00:09:07,160
interactive way to do programming even

00:09:03,890 --> 00:09:09,740
data and that's people use it to play

00:09:07,160 --> 00:09:14,660
around with with data visualize it in

00:09:09,740 --> 00:09:16,580
their browser and one cool thing of

00:09:14,660 --> 00:09:19,279
Jupiter is that it does not only support

00:09:16,580 --> 00:09:20,779
Python it sports lots of languages last

00:09:19,279 --> 00:09:23,050
time I checked which was led years ago

00:09:20,779 --> 00:09:25,279
there was already a dozen languages more

00:09:23,050 --> 00:09:28,070
it's probably way more now and one of

00:09:25,279 --> 00:09:30,950
those languages is citing all I have to

00:09:28,070 --> 00:09:35,810
do in Jupiter to make it support seitan

00:09:30,950 --> 00:09:37,180
is load exercising and I should restore

00:09:35,810 --> 00:09:48,860
my channel

00:09:37,180 --> 00:09:53,029
sure okay just a quick overview of what

00:09:48,860 --> 00:09:58,550
I'm using here legs - release latest I'm

00:09:53,029 --> 00:10:00,800
really syphon I'm you know I can take

00:09:58,550 --> 00:10:05,000
the risk of using and reduce certain

00:10:00,800 --> 00:10:09,620
version in the talk some numbers in

00:10:05,000 --> 00:10:12,260
jesusí 7 and important bit to understand

00:10:09,620 --> 00:10:13,970
is you know and place them when you

00:10:12,260 --> 00:10:17,209
write a Python code you write a module

00:10:13,970 --> 00:10:22,630
save it you say pattern port blah and

00:10:17,209 --> 00:10:22,630
you just know important ones in syphon

00:10:29,620 --> 00:10:37,760
it's an alpha version you mean 0:29 well

00:10:35,270 --> 00:10:40,790
it's it's production proven but we still

00:10:37,760 --> 00:10:45,190
say it's zero point something because so

00:10:40,790 --> 00:10:48,920
at some point ages ago we said that

00:10:45,190 --> 00:10:51,650
version 1.0 should be the version that

00:10:48,920 --> 00:10:54,770
runs aperture patent code and we still

00:10:51,650 --> 00:10:57,560
have one or two bucks in there that but

00:10:54,770 --> 00:11:00,290
we have to say well we have to fix those

00:10:57,560 --> 00:11:03,680
firsts before we can say that we can

00:11:00,290 --> 00:11:05,150
compile any particle out there and so

00:11:03,680 --> 00:11:08,660
it's still at zero point something and

00:11:05,150 --> 00:11:11,750
we haven't reconsidered the go for 1.0

00:11:08,660 --> 00:11:13,940
I think we should because no one cares

00:11:11,750 --> 00:11:17,930
what for title compatible built really

00:11:13,940 --> 00:11:20,810
is you know it works it's perfect it's

00:11:17,930 --> 00:11:23,050
wonderful and it's just it's zero point

00:11:20,810 --> 00:11:23,050
something

00:11:34,070 --> 00:11:39,290
okay I consider doing like Chrome and

00:11:37,339 --> 00:11:42,139
Firefox and just say you know there's

00:11:39,290 --> 00:11:53,990
actually not opened 29 it's 29 point

00:11:42,139 --> 00:11:57,139
something they go okay quick intro so

00:11:53,990 --> 00:11:59,420
he's a bit of petticoat I say from that

00:11:57,139 --> 00:12:02,079
input science I'm using the sine

00:11:59,420 --> 00:12:06,350
function from the Python math module I

00:12:02,079 --> 00:12:11,899
calculate 5 and says Bob it's about

00:12:06,350 --> 00:12:14,269
minus 1 Wallace so works now in order to

00:12:11,899 --> 00:12:19,899
do that with site then I can just

00:12:14,269 --> 00:12:24,290
and these this line here which instructs

00:12:19,899 --> 00:12:28,339
Jupiter to compile this cell inside them

00:12:24,290 --> 00:12:30,949
instead of just compile it and siphon

00:12:28,339 --> 00:12:34,399
and it builds an extension module from

00:12:30,949 --> 00:12:36,560
that better than it imports ok so it

00:12:34,399 --> 00:12:38,980
builds a shared library and that is also

00:12:36,560 --> 00:12:42,740
something to keep in mind it will siphon

00:12:38,980 --> 00:12:47,829
you step away from the simple right code

00:12:42,740 --> 00:12:50,810
import trying to write code compile

00:12:47,829 --> 00:12:53,449
import try ok so there's a build step

00:12:50,810 --> 00:12:57,110
involved from that point on it's usually

00:12:53,449 --> 00:12:59,060
brother okay so we run it it's actually

00:12:57,110 --> 00:13:01,490
pretty quick apparently I think was

00:12:59,060 --> 00:13:05,779
pretty compiled before so Jupiter caches

00:13:01,490 --> 00:13:09,079
these cells if it knows that they didn't

00:13:05,779 --> 00:13:12,170
change you see a little change in here

00:13:09,079 --> 00:13:18,410
what it before up there is I just said

00:13:12,170 --> 00:13:19,970
sign five and for Jupiter what Jupiter

00:13:18,410 --> 00:13:21,920
does is you know it takes the last

00:13:19,970 --> 00:13:26,240
expression last value that fell out of

00:13:21,920 --> 00:13:28,420
your cell and displays it for citing

00:13:26,240 --> 00:13:31,399
compiled cell that does not work why

00:13:28,420 --> 00:13:33,740
it's an extension module it's native

00:13:31,399 --> 00:13:35,209
code it's external Jupiter can look into

00:13:33,740 --> 00:13:36,589
it it doesn't know anything that falls

00:13:35,209 --> 00:13:39,290
out of it there is actually nothing

00:13:36,589 --> 00:13:45,350
falling out of it just you know executed

00:13:39,290 --> 00:13:47,110
imported and it's important as module as

00:13:45,350 --> 00:13:50,320
a decimal value that comes

00:13:47,110 --> 00:13:53,080
one time so um if I just run this it

00:13:50,320 --> 00:13:56,160
would display nothing but I have to be

00:13:53,080 --> 00:14:02,320
explicit then and say print this okay

00:13:56,160 --> 00:14:04,180
one difference um this you know right

00:14:02,320 --> 00:14:07,180
and doing the same thing and take the

00:14:04,180 --> 00:14:08,860
Python function calling it it doesn't

00:14:07,180 --> 00:14:10,990
make a difference if I call item

00:14:08,860 --> 00:14:12,490
function in compiled code when you fix

00:14:10,990 --> 00:14:15,700
your code it's pretty much the same

00:14:12,490 --> 00:14:19,140
thing nice thing about sizes now is I'm

00:14:15,700 --> 00:14:22,210
not limited to using Python things

00:14:19,140 --> 00:14:26,860
psiphon takes my code takes my Python

00:14:22,210 --> 00:14:28,630
code compiler to see so what I can do

00:14:26,860 --> 00:14:30,670
now is I can start using see things

00:14:28,630 --> 00:14:34,150
because you know my code ends up and see

00:14:30,670 --> 00:14:38,520
anyway and during see stuff as a total

00:14:34,150 --> 00:14:41,530
totally natural thing to do fancy so

00:14:38,520 --> 00:14:44,050
instead of importing the math sine

00:14:41,530 --> 00:14:47,950
function I do a static import and this

00:14:44,050 --> 00:14:49,540
is a syntax extension here in sizing

00:14:47,950 --> 00:14:52,150
code so this is no longer patent code

00:14:49,540 --> 00:14:55,270
cycle now I say see you port lips in

00:14:52,150 --> 00:15:00,400
math and that gives me the math header

00:14:55,270 --> 00:15:06,100
file from Lipsy and now I can use the C

00:15:00,400 --> 00:15:08,320
sine function yeah okay what I'm doing

00:15:06,100 --> 00:15:11,530
here is I'm assigning it to a patent

00:15:08,320 --> 00:15:15,310
variable in my module comparing that

00:15:11,530 --> 00:15:18,250
executing it and question now is what

00:15:15,310 --> 00:15:24,700
happens when I sign a c function to

00:15:18,250 --> 00:15:27,400
patent variable it becomes a callable

00:15:24,700 --> 00:15:28,960
right padico because it's kind of

00:15:27,400 --> 00:15:30,820
obvious what this should do right i mean

00:15:28,960 --> 00:15:33,580
i have function here said you can see

00:15:30,820 --> 00:15:35,890
the same function signature and i want

00:15:33,580 --> 00:15:38,710
it to be a patent thing so the most

00:15:35,890 --> 00:15:41,260
obvious thing to do is converted into a

00:15:38,710 --> 00:15:42,250
pratical what that does is it generates

00:15:41,260 --> 00:15:48,400
code for me

00:15:42,250 --> 00:15:50,550
that wraps c call ball in a private call

00:15:48,400 --> 00:15:56,990
walking

00:15:50,550 --> 00:16:01,709
I can now call it a reclaim you see that

00:15:56,990 --> 00:16:03,570
okay so I have a pattern called on now

00:16:01,709 --> 00:16:06,089
and when I call it from Jupiter it

00:16:03,570 --> 00:16:08,160
outputs the same thing as before there's

00:16:06,089 --> 00:16:09,959
kind of the quickest way to wrap a see

00:16:08,160 --> 00:16:12,630
function that has a you know Python

00:16:09,959 --> 00:16:14,940
light signature signs simple has it just

00:16:12,630 --> 00:16:18,450
you know gets a double in a double out

00:16:14,940 --> 00:16:20,670
CC double in out that means from Python

00:16:18,450 --> 00:16:25,160
side you can pass in any float object

00:16:20,670 --> 00:16:28,770
and get a fourth object background okay

00:16:25,160 --> 00:16:33,060
what this basically does internally is

00:16:28,770 --> 00:16:35,130
this spelled out so this is a long

00:16:33,060 --> 00:16:39,149
version of this right I'm writing

00:16:35,130 --> 00:16:41,520
pattern function which says C sorry

00:16:39,149 --> 00:16:43,920
takes a double another extension that

00:16:41,520 --> 00:16:46,620
they can use in sight and now I can type

00:16:43,920 --> 00:16:50,190
my arguments I could just write this

00:16:46,620 --> 00:16:52,860
fine I would do that in Python in syphon

00:16:50,190 --> 00:16:55,470
I can be explicit here and say what I

00:16:52,860 --> 00:16:57,140
actually want there is a C double okay

00:16:55,470 --> 00:17:00,180
whatever you put in as an argument

00:16:57,140 --> 00:17:01,980
should be converted into a C double and

00:17:00,180 --> 00:17:04,230
cycling will generate the conversion

00:17:01,980 --> 00:17:07,380
code for me so what I get here is a

00:17:04,230 --> 00:17:09,540
Python calvo function which takes an

00:17:07,380 --> 00:17:12,000
argument converts it into a suitable I

00:17:09,540 --> 00:17:18,660
get type error if that's not possible

00:17:12,000 --> 00:17:21,420
so string type error obviously and then

00:17:18,660 --> 00:17:22,740
inside of my function I just call the C

00:17:21,420 --> 00:17:25,010
sine function that's what you asked for

00:17:22,740 --> 00:17:25,010
it

00:17:25,189 --> 00:17:31,950
and I can do that from Jupiter again

00:17:27,600 --> 00:17:36,500
called a petal function and it runs the

00:17:31,950 --> 00:17:36,500
sine function internally okay

00:17:37,910 --> 00:17:45,030
nice feature of siphon when I say siphon

00:17:41,309 --> 00:17:46,559
- a what it generates so John is the C

00:17:45,030 --> 00:17:49,050
code for me but it definitely generates

00:17:46,559 --> 00:17:51,780
in a little HTML snippet for me that

00:17:49,050 --> 00:17:54,630
shows me how the compiler understand

00:17:51,780 --> 00:18:00,240
understood my code so this is a copy of

00:17:54,630 --> 00:18:01,270
my code and it has information that I

00:18:00,240 --> 00:18:04,650
can use

00:18:01,270 --> 00:18:08,410
to understand volcanoes micro helps me

00:18:04,650 --> 00:18:09,820
in optimizing my code and when I click

00:18:08,410 --> 00:18:13,240
on one of these lines I can actually see

00:18:09,820 --> 00:18:15,580
what's C code cyton generated for this

00:18:13,240 --> 00:18:18,700
line okay this is the function signature

00:18:15,580 --> 00:18:20,380
it's pretty involved because it has to

00:18:18,700 --> 00:18:22,690
do with the this would be error checking

00:18:20,380 --> 00:18:23,860
it has to do argument conversion as with

00:18:22,690 --> 00:18:27,250
lots of things in there it has to

00:18:23,860 --> 00:18:29,170
register a function a callable in in the

00:18:27,250 --> 00:18:31,270
module argument and all that so this is

00:18:29,170 --> 00:18:32,500
what comes out of this line when this

00:18:31,270 --> 00:18:35,380
line is actually the same lines actually

00:18:32,500 --> 00:18:38,170
more interesting I can see that there's

00:18:35,380 --> 00:18:42,130
an X argument going in so we have just

00:18:38,170 --> 00:18:45,610
know you're mangling the argument names

00:18:42,130 --> 00:18:47,770
when we generated C code to avoid name

00:18:45,610 --> 00:18:51,520
collisions this is basically variable X

00:18:47,770 --> 00:18:52,630
put in I call the C sine function on it

00:18:51,520 --> 00:18:56,350
and you can see that it's really

00:18:52,630 --> 00:18:58,330
straight C call to see sine and then

00:18:56,350 --> 00:19:02,260
since this is a Python function the end

00:18:58,330 --> 00:19:04,750
result has to be passed back into Python

00:19:02,260 --> 00:19:07,090
to my patent caller and for that it

00:19:04,750 --> 00:19:09,850
converts it from a C double to Python

00:19:07,090 --> 00:19:14,230
float and this is what this C API call

00:19:09,850 --> 00:19:17,140
is doing here okay so this is a nice way

00:19:14,230 --> 00:19:19,690
for me to you know for me as a as a

00:19:17,140 --> 00:19:21,400
sighted user to understand what Satan is

00:19:19,690 --> 00:19:24,070
doing with my cold how its interpreting

00:19:21,400 --> 00:19:27,330
it what becomes of my code and you can

00:19:24,070 --> 00:19:30,400
see that kind of yellow lines in him and

00:19:27,330 --> 00:19:33,130
those yellow lines give me additional

00:19:30,400 --> 00:19:37,690
information but tell me how much object

00:19:33,130 --> 00:19:40,360
or operations there are in each of these

00:19:37,690 --> 00:19:42,130
lines which is interesting when I want

00:19:40,360 --> 00:19:44,350
to start optimizing my code when I want

00:19:42,130 --> 00:19:46,720
to drop it into seeing maybe faster

00:19:44,350 --> 00:19:48,670
there because every yellow line tells me

00:19:46,720 --> 00:19:50,980
there's some object of operation going

00:19:48,670 --> 00:19:52,780
on there's some exception handling going

00:19:50,980 --> 00:19:55,060
on some error checking and that's of

00:19:52,780 --> 00:19:58,000
anything that uses to use interaction

00:19:55,060 --> 00:20:03,520
with the C Python runtime and if my role

00:19:58,000 --> 00:20:05,230
is to convert my code into fast C not

00:20:03,520 --> 00:20:08,050
using objects but using native data

00:20:05,230 --> 00:20:10,330
types then any yellow line is probably

00:20:08,050 --> 00:20:14,410
worth looking at okay at the back of the

00:20:10,330 --> 00:20:16,410
yellow the more object operations

00:20:14,410 --> 00:20:18,670
object interaction there is going on

00:20:16,410 --> 00:20:20,920
which is kind of obvious in this case I

00:20:18,670 --> 00:20:22,750
mean there's a signature so late ed

00:20:20,920 --> 00:20:24,340
conversions are exciting exception

00:20:22,750 --> 00:20:26,410
handling stuff like that lots of

00:20:24,340 --> 00:20:28,720
interaction going on there and this line

00:20:26,410 --> 00:20:31,060
is really just converting the end result

00:20:28,720 --> 00:20:37,540
of a sea call back into a pattern object

00:20:31,060 --> 00:20:40,660
so there's less operational okay know

00:20:37,540 --> 00:20:42,730
what makes and this is this is just a

00:20:40,660 --> 00:20:44,380
different way basically of spelling the

00:20:42,730 --> 00:20:47,320
initial example that I had right I'm

00:20:44,380 --> 00:20:49,330
wrapping a C function that's it what

00:20:47,320 --> 00:20:52,540
makes it more interesting then is in

00:20:49,330 --> 00:20:56,020
siphon once I have these have a wrapper

00:20:52,540 --> 00:20:58,360
function here I can move more code below

00:20:56,020 --> 00:21:02,020
the Python level and take functionality

00:20:58,360 --> 00:21:04,660
from - right and make my wrapper thicker

00:21:02,020 --> 00:21:07,270
I can put functionality into the wrapper

00:21:04,660 --> 00:21:12,700
between the C library that I'm talking

00:21:07,270 --> 00:21:16,060
to and the Python API that I'm providing

00:21:12,700 --> 00:21:19,530
to Python users so I can make my wrapper

00:21:16,060 --> 00:21:22,990
more intelligent smarter better-looking

00:21:19,530 --> 00:21:25,210
you know more pathani for pi user by

00:21:22,990 --> 00:21:29,830
putting more functionality at the lower

00:21:25,210 --> 00:21:32,110
level and hiding the little dirty words

00:21:29,830 --> 00:21:34,710
in the C API that the Python users

00:21:32,110 --> 00:21:37,150
shouldn't have to bother with okay

00:21:34,710 --> 00:21:39,010
simple example here instead of

00:21:37,150 --> 00:21:42,610
calculating just you know just calling

00:21:39,010 --> 00:21:45,520
the sine function I call sine Phi

00:21:42,610 --> 00:21:47,950
squared right I could do that in Python

00:21:45,520 --> 00:21:50,290
I could use my my wrapped sine function

00:21:47,950 --> 00:21:51,670
and you you know X square passenger the

00:21:50,290 --> 00:21:54,910
sine function and then would call it

00:21:51,670 --> 00:21:56,830
would get the sine of that but doing

00:21:54,910 --> 00:22:00,190
that a C is just much faster right it

00:21:56,830 --> 00:22:02,830
pushed on the the X it calculates x

00:22:00,190 --> 00:22:04,930
squared sine of x squared and then

00:22:02,830 --> 00:22:07,390
passes back that result much faster than

00:22:04,930 --> 00:22:09,630
two and half of them - I can do that

00:22:07,390 --> 00:22:09,630
here

00:22:12,140 --> 00:22:21,350
okay just two little things since we're

00:22:17,270 --> 00:22:24,530
in C now I can use menu memory handling

00:22:21,350 --> 00:22:27,290
in C this is how that would look like

00:22:24,530 --> 00:22:31,340
I have malloc and free so I can allocate

00:22:27,290 --> 00:22:33,320
some memory I mean taken memory handling

00:22:31,340 --> 00:22:36,440
is completely automatic right you have

00:22:33,320 --> 00:22:38,120
objects your references to them and when

00:22:36,440 --> 00:22:40,400
the last reference to an object goes

00:22:38,120 --> 00:22:42,830
away then the object just dies and gets

00:22:40,400 --> 00:22:48,080
collected that is not the case in fact

00:22:42,830 --> 00:22:50,450
totally not C is completely manual and

00:22:48,080 --> 00:22:53,120
so in C I would say you know and

00:22:50,450 --> 00:22:55,160
allocate some memory here if that fails

00:22:53,120 --> 00:22:58,730
I can now point it back and I just say

00:22:55,160 --> 00:23:00,559
erase memory error you wouldn't really

00:22:58,730 --> 00:23:06,470
do that in C right what about you do in

00:23:00,559 --> 00:23:09,679
C good yeah you run some some error code

00:23:06,470 --> 00:23:11,480
right say return minus 1 or something

00:23:09,679 --> 00:23:13,630
that tells the caller you know something

00:23:11,480 --> 00:23:15,140
went wrong and we have to handle it

00:23:13,630 --> 00:23:17,900
inside them

00:23:15,140 --> 00:23:20,179
Satan is Python right it integrates with

00:23:17,900 --> 00:23:21,770
pythons or you can just say you know

00:23:20,179 --> 00:23:23,960
rates memory erasing the exception from

00:23:21,770 --> 00:23:27,440
your side and hold I totally normal and

00:23:23,960 --> 00:23:30,260
this is this is totally what you do well

00:23:27,440 --> 00:23:31,850
if the allocation worked then I can use

00:23:30,260 --> 00:23:34,669
my memory for something and we have a

00:23:31,850 --> 00:23:37,880
couple of nice features and language

00:23:34,669 --> 00:23:40,940
that make array operations point

00:23:37,880 --> 00:23:47,030
operations a bit more you know handy and

00:23:40,940 --> 00:23:50,360
- it then they would know since so

00:23:47,030 --> 00:23:53,720
question was is those bound checked no

00:23:50,360 --> 00:23:56,210
because C 1 is just a memory never

00:23:53,720 --> 00:23:58,370
pointer this is one place in memory and

00:23:56,210 --> 00:24:01,520
here I'm actually explicitly telling

00:23:58,370 --> 00:24:03,740
syphon you know to assign something to

00:24:01,520 --> 00:24:07,850
the first two entries which is still

00:24:03,740 --> 00:24:10,640
much nicer than you you know in C but

00:24:07,850 --> 00:24:12,770
the pointers are just pointless that

00:24:10,640 --> 00:24:18,530
they're not erase erase I see bonds

00:24:12,770 --> 00:24:20,630
change okay so I can do this things no

00:24:18,530 --> 00:24:21,860
say just no prints if anything goes

00:24:20,630 --> 00:24:23,570
wrong here

00:24:21,860 --> 00:24:24,920
then I

00:24:23,570 --> 00:24:26,600
definitely wants to clean up my

00:24:24,920 --> 00:24:29,330
irritated memory alright so I want your

00:24:26,600 --> 00:24:32,330
free the memory and I do that with Troy

00:24:29,330 --> 00:24:34,550
finally as a vampire right

00:24:32,330 --> 00:24:37,610
so if print for example raises an

00:24:34,550 --> 00:24:38,930
exceptional can print no standard send

00:24:37,610 --> 00:24:40,070
out anymore for example were close

00:24:38,930 --> 00:24:41,840
already

00:24:40,070 --> 00:24:44,210
anything can go wrong yeah I'm doing a

00:24:41,840 --> 00:24:45,950
patent thing right so this can raise an

00:24:44,210 --> 00:24:48,440
exception and it just you know if that

00:24:45,950 --> 00:24:50,360
happens I say you know finally still

00:24:48,440 --> 00:24:59,200
make sure you're free my memory you got

00:24:50,360 --> 00:25:03,050
is what happens nice feature okay quick

00:24:59,200 --> 00:25:05,900
example for calling external code you

00:25:03,050 --> 00:25:10,340
seen the Lipsy lives design function

00:25:05,900 --> 00:25:12,590
that I called here's an example for

00:25:10,340 --> 00:25:15,020
calling an external library that is not

00:25:12,590 --> 00:25:17,780
just you know the air like live see but

00:25:15,020 --> 00:25:20,270
really an external library this does any

00:25:17,780 --> 00:25:22,490
who knows what do is was used to before

00:25:20,270 --> 00:25:25,490
yeah

00:25:22,490 --> 00:25:27,980
so Louisa is little it's really a small

00:25:25,490 --> 00:25:31,790
language it's a language that people use

00:25:27,980 --> 00:25:34,280
for embedding common in C++ project but

00:25:31,790 --> 00:25:37,300
you can obviously also embed them in why

00:25:34,280 --> 00:25:43,040
not so here's a little embarrassment for

00:25:37,300 --> 00:25:45,230
indictment first thing I have to do is I

00:25:43,040 --> 00:25:47,270
have to tell site then what the C API

00:25:45,230 --> 00:25:50,450
that I'm using here the Lewis yep yeah

00:25:47,270 --> 00:25:52,100
it looks like previously you may

00:25:50,450 --> 00:25:55,250
remember that I said you know see

00:25:52,100 --> 00:25:57,050
imported see now what that does is it

00:25:55,250 --> 00:25:59,600
looks up an external declaration file

00:25:57,050 --> 00:26:02,870
and finds the lips EMF declarations in

00:25:59,600 --> 00:26:05,720
there here I'm doing that in line in a

00:26:02,870 --> 00:26:06,950
module and this is the syntax for it and

00:26:05,720 --> 00:26:09,800
basically just say in Europe there's an

00:26:06,950 --> 00:26:12,560
external declaration described external

00:26:09,800 --> 00:26:14,300
code which comes from the lower edge

00:26:12,560 --> 00:26:17,420
file so that's the the header file that

00:26:14,300 --> 00:26:19,210
describes the API and it has couple

00:26:17,420 --> 00:26:22,540
things in there this is struct in there

00:26:19,210 --> 00:26:25,820
there's a function for creating run time

00:26:22,540 --> 00:26:27,980
for cleaning things up for a loading day

00:26:25,820 --> 00:26:31,670
a loading code into the dual runtime and

00:26:27,980 --> 00:26:34,279
it's 1/4 cup of functions and note that

00:26:31,670 --> 00:26:37,679
I did not copy

00:26:34,279 --> 00:26:40,649
complete vast yeah I mean they're just

00:26:37,679 --> 00:26:44,100
copied the functions that I need because

00:26:40,649 --> 00:26:47,489
that is all I need in my code remember

00:26:44,100 --> 00:26:49,769
that Titan translates my code to see

00:26:47,489 --> 00:26:52,200
right and then there's AC compiler

00:26:49,769 --> 00:26:53,789
afterwards that compiles that through

00:26:52,200 --> 00:26:56,309
shared library and the C compiler

00:26:53,789 --> 00:26:57,509
obviously sees the whole thing but Satan

00:26:56,309 --> 00:26:59,070
doesn't know you to know about the whole

00:26:57,509 --> 00:27:01,799
thing you just need to know what I'm

00:26:59,070 --> 00:27:05,850
using in order to generate proper C code

00:27:01,799 --> 00:27:08,070
but C compiler can compile Winston very

00:27:05,850 --> 00:27:11,549
nice so I'm really just doesn't

00:27:08,070 --> 00:27:15,210
functions here so that allow me to

00:27:11,549 --> 00:27:17,220
execute your code from - so what's my

00:27:15,210 --> 00:27:20,730
interface I'm defining a Python function

00:27:17,220 --> 00:27:23,580
that takes a quote as quote lure quote

00:27:20,730 --> 00:27:29,159
as a string and I'm doing a couple

00:27:23,580 --> 00:27:31,919
things might be Unicode string in - 3

00:27:29,159 --> 00:27:33,899
it's quite likely going to be Unicode

00:27:31,919 --> 00:27:36,869
string in that case I have to convert it

00:27:33,899 --> 00:27:39,629
because she doesn't know Unicode don't

00:27:36,869 --> 00:27:41,940
knows bytes in strings and that's how

00:27:39,629 --> 00:27:47,850
the UI works also so I conversion it to

00:27:41,940 --> 00:27:49,739
YouTube H will be executed there then I

00:27:47,850 --> 00:27:51,210
create a new Google runtime if that

00:27:49,739 --> 00:27:52,710
fails to just say raise memory error

00:27:51,210 --> 00:27:55,950
because that's what the documentation

00:27:52,710 --> 00:27:58,679
tells me if the creation of the engine

00:27:55,950 --> 00:28:01,320
fails documentation says it well it's

00:27:58,679 --> 00:28:03,239
probably a memory problem right couldn't

00:28:01,320 --> 00:28:05,940
be advocated so raise memory errors

00:28:03,239 --> 00:28:08,070
right thing and then whatever happens I

00:28:05,940 --> 00:28:10,799
use a try finally to make sure it flows

00:28:08,070 --> 00:28:12,570
down my runtime afterwards and clean up

00:28:10,799 --> 00:28:16,320
that's what I'm doing down yeah my

00:28:12,570 --> 00:28:20,429
finally so I'm cleaning up the flue a

00:28:16,320 --> 00:28:22,499
stack and closing the runtime to clean

00:28:20,429 --> 00:28:25,320
everything up to release the memory and

00:28:22,499 --> 00:28:29,549
then I've function in to pass in the

00:28:25,320 --> 00:28:32,159
dual code into Lua if that fails array

00:28:29,549 --> 00:28:34,499
syntax error will probably wrong syntax

00:28:32,159 --> 00:28:37,129
then I can execute my code using the C

00:28:34,499 --> 00:28:40,169
API function and I get some results back

00:28:37,129 --> 00:28:42,840
I'm lazy here and just expecting some

00:28:40,169 --> 00:28:45,119
number back I could look at what the

00:28:42,840 --> 00:28:46,810
result is improperly converted to some

00:28:45,119 --> 00:28:48,940
some corresponding patent

00:28:46,810 --> 00:28:51,130
but yeah only expected numbers okay one

00:28:48,940 --> 00:28:54,460
number is Rosen does it as a function to

00:28:51,130 --> 00:28:55,900
converting it to a scene number and then

00:28:54,460 --> 00:28:57,310
when you return that for my patent

00:28:55,900 --> 00:28:58,660
functions I think we'll see okay let's

00:28:57,310 --> 00:29:00,910
see number and you want to return it

00:28:58,660 --> 00:29:04,620
from path of functions or return it as a

00:29:00,910 --> 00:29:07,090
Python object so I couldn't I'll this

00:29:04,620 --> 00:29:09,700
here's a couple of lines of blue bar

00:29:07,090 --> 00:29:13,840
code recursive even actually the usual

00:29:09,700 --> 00:29:16,450
stupid benchmark and when I ran time it

00:29:13,840 --> 00:29:17,860
on that it's going to tell me about a

00:29:16,450 --> 00:29:20,530
few minutes you have 24 I could be

00:29:17,860 --> 00:29:26,530
calculated in two milliseconds a bit

00:29:20,530 --> 00:29:37,180
more okay that's how you use C libraries

00:29:26,530 --> 00:29:40,930
- okay so ten minutes so yeah second

00:29:37,180 --> 00:29:43,810
example um optimizing petticoat I chose

00:29:40,930 --> 00:29:47,290
the flip who knows do flip from the

00:29:43,810 --> 00:29:48,730
standard library you should look through

00:29:47,290 --> 00:29:51,130
the standard library documentation

00:29:48,730 --> 00:29:53,710
there's lots of nice goodies in there so

00:29:51,130 --> 00:29:55,210
what they flip does is you can pass two

00:29:53,710 --> 00:29:56,860
sequences in there and it's going to

00:29:55,210 --> 00:29:59,650
compare them and tell you what the

00:29:56,860 --> 00:30:03,670
difference is it's just like the UNIX

00:29:59,650 --> 00:30:05,260
diff but out at an API level right you

00:30:03,670 --> 00:30:08,620
can use directly from compile it's been

00:30:05,260 --> 00:30:10,540
there for a long time you know it's an

00:30:08,620 --> 00:30:13,990
11 most things in celebrity have been

00:30:10,540 --> 00:30:16,390
there for a long time so I'm going to

00:30:13,990 --> 00:30:18,250
optimize those little bit okay so as

00:30:16,390 --> 00:30:21,670
benchmark I'm using two called fuzzy

00:30:18,250 --> 00:30:22,960
fuzzy fuzzy wuzzy which comes with a

00:30:21,670 --> 00:30:25,720
little benchmark that's why I'm using it

00:30:22,960 --> 00:30:30,760
fuzzy wuzzy basically just as fuzzy

00:30:25,720 --> 00:30:32,680
comparison between between text okay so

00:30:30,760 --> 00:30:34,630
it has been two texts and it's gonna do

00:30:32,680 --> 00:30:37,900
the comparison and try to match the

00:30:34,630 --> 00:30:39,280
parts and well it's not really well

00:30:37,900 --> 00:30:40,030
relevant I'm just using it as a

00:30:39,280 --> 00:30:42,220
benchmark here

00:30:40,030 --> 00:30:46,390
and I'm using see profile for profiling

00:30:42,220 --> 00:30:48,690
to see how fast my programs running in

00:30:46,390 --> 00:30:48,690
wet

00:30:49,740 --> 00:31:01,920
so okay let's look at if let's run it

00:30:56,190 --> 00:31:09,020
first okay um I'll just clean up my

00:31:01,920 --> 00:31:11,429
stuff and then run benchmark so that's

00:31:09,020 --> 00:31:14,820
taking a couple seconds it's running

00:31:11,429 --> 00:31:16,559
multiple examples and the timings of the

00:31:14,820 --> 00:31:18,179
benchmark is just the time it takes to

00:31:16,559 --> 00:31:21,620
run the whole benchmark for fuzzy-wuzzy

00:31:18,179 --> 00:31:24,809
and so you'll see in a minute that it's

00:31:21,620 --> 00:31:28,040
dominated by the time it takes to flip

00:31:24,809 --> 00:31:28,040
to do the comparisons

00:31:40,420 --> 00:31:44,740
one thing you shouldn't forget when

00:31:42,190 --> 00:31:48,700
running benchmarks is some switching of

00:31:44,740 --> 00:31:50,500
energy handling of your laptop it's

00:31:48,700 --> 00:31:52,120
probably okay this time in this case

00:31:50,500 --> 00:31:53,890
because you know it's bit during

00:31:52,120 --> 00:31:56,890
computations before so probably not

00:31:53,890 --> 00:32:00,880
slowed down much yeah it's what I

00:31:56,890 --> 00:32:03,850
expected so 40 46 seconds for the whole

00:32:00,880 --> 00:32:06,610
run time okay now next thing I'm going

00:32:03,850 --> 00:32:10,690
to do is an run in C profile on the

00:32:06,610 --> 00:32:12,549
benchmark to see where time goes so I'm

00:32:10,690 --> 00:32:17,679
gonna run begin it's gonna take me

00:32:12,549 --> 00:32:22,210
longer to run you know who does not know

00:32:17,679 --> 00:32:24,309
C profile okay people

00:32:22,210 --> 00:32:27,669
so C profile what super offer does is

00:32:24,309 --> 00:32:29,910
basically it's traces your code on each

00:32:27,669 --> 00:32:32,049
function call it's going to tell you

00:32:29,910 --> 00:32:35,590
functions be called functions been

00:32:32,049 --> 00:32:38,770
exited and then afterwards it's going to

00:32:35,590 --> 00:32:41,200
present you know it's going to dump the

00:32:38,770 --> 00:32:44,470
profile somewhere and it's going to tell

00:32:41,200 --> 00:32:49,360
you what were the functions in the air

00:32:44,470 --> 00:32:51,610
that took most time and like where was

00:32:49,360 --> 00:32:53,200
most of the time spent and what was less

00:32:51,610 --> 00:32:57,100
relevant so it's a very quick way of

00:32:53,200 --> 00:33:01,990
assessing the runtime profile of the

00:32:57,100 --> 00:33:05,470
code and finger pointing points that you

00:33:01,990 --> 00:33:07,340
want to optimize first okay again it

00:33:05,470 --> 00:33:10,580
takes a while

00:33:07,340 --> 00:33:10,580
[Music]

00:33:13,549 --> 00:33:17,179
obviously Kate's longer now because as I

00:33:15,590 --> 00:33:19,880
said it's interested in your code right

00:33:17,179 --> 00:33:23,330
so it's really doing stuff while your

00:33:19,880 --> 00:33:28,179
code was running there are profiles out

00:33:23,330 --> 00:33:30,529
there that slow down your code much less

00:33:28,179 --> 00:33:34,940
and it's really worth looking into them

00:33:30,529 --> 00:33:38,600
when is the perf tool in Linux so if you

00:33:34,940 --> 00:33:41,720
have Linux definitely but it operates

00:33:38,600 --> 00:33:43,850
most of these tools operates add-on much

00:33:41,720 --> 00:33:45,169
lower levels so the if you see level

00:33:43,850 --> 00:33:47,929
information rather than patent level

00:33:45,169 --> 00:33:51,159
information and see profile just really

00:33:47,929 --> 00:33:54,380
gives you Python level information so

00:33:51,159 --> 00:33:57,020
I've executed lots of function calls how

00:33:54,380 --> 00:33:58,700
many other 153 million function calls

00:33:57,020 --> 00:34:03,590
along the way

00:33:58,700 --> 00:34:06,230
it took 78 seconds to run now and well

00:34:03,590 --> 00:34:12,520
the most costly function here is find

00:34:06,230 --> 00:34:18,619
longest match in the flip and it took 25

00:34:12,520 --> 00:34:24,619
seconds over one time all by itself plus

00:34:18,619 --> 00:34:29,330
it took an accumulated 34 seconds if you

00:34:24,619 --> 00:34:31,250
add the function its own function calls

00:34:29,330 --> 00:34:33,260
its internal function calls to it so the

00:34:31,250 --> 00:34:37,820
the whole time spent in that function

00:34:33,260 --> 00:34:43,450
was 34 seconds and so function and it's

00:34:37,820 --> 00:34:46,849
its own code that it uses and 25 seconds

00:34:43,450 --> 00:34:49,849
only directly in the function itself so

00:34:46,849 --> 00:34:53,780
that's a lot of processing time so I'll

00:34:49,849 --> 00:34:57,940
look into that function and you can you

00:34:53,780 --> 00:35:04,430
read this let's watch enough ladrón okay

00:34:57,940 --> 00:35:06,020
like this better okay so this is defined

00:35:04,430 --> 00:35:08,540
longest match function it's actually

00:35:06,020 --> 00:35:10,760
method which makes a bit more difficult

00:35:08,540 --> 00:35:14,589
to optimize but you know I'll just go

00:35:10,760 --> 00:35:18,440
forward a couple of quick speed ups here

00:35:14,589 --> 00:35:20,780
and it basically starts here you can see

00:35:18,440 --> 00:35:25,370
someone's already try to optimize this

00:35:20,780 --> 00:35:27,860
function quite a while ago apparent

00:35:25,370 --> 00:35:31,010
this is one of these Ana tricks that you

00:35:27,860 --> 00:35:33,770
would pull in Python a bit of an ugly

00:35:31,010 --> 00:35:36,170
trick normally what you would say is you

00:35:33,770 --> 00:35:39,140
know a and what they do here is they

00:35:36,170 --> 00:35:42,620
take the bound method of bees B contains

00:35:39,140 --> 00:35:44,090
and say it contains a okay so to replace

00:35:42,620 --> 00:35:45,410
the operator by a function call

00:35:44,090 --> 00:35:47,480
encouraging that was faster at the time

00:35:45,410 --> 00:35:53,060
I should chase it in still a bit faster

00:35:47,480 --> 00:35:54,920
in 307 but it's something that you don't

00:35:53,060 --> 00:35:57,170
need in cycling because operators inside

00:35:54,920 --> 00:36:00,410
them are actually much faster so I would

00:35:57,170 --> 00:36:02,990
one thing I would do is move that but

00:36:00,410 --> 00:36:05,570
they actually quicker gains to to make

00:36:02,990 --> 00:36:08,180
here and I'll start with those when you

00:36:05,570 --> 00:36:10,790
look at the code what it does is it has

00:36:08,180 --> 00:36:11,900
a nested loop and runs over a cup of

00:36:10,790 --> 00:36:13,490
data structures you don't need to

00:36:11,900 --> 00:36:15,230
understand what those data structures

00:36:13,490 --> 00:36:17,810
actually do it's you know this dick

00:36:15,230 --> 00:36:20,210
involved somewhere keeps track of stuff

00:36:17,810 --> 00:36:22,070
deep in list and you know it's doing

00:36:20,210 --> 00:36:24,320
things in there but that's a nested loop

00:36:22,070 --> 00:36:26,240
okay a nested loop always means that

00:36:24,320 --> 00:36:28,880
there's a lot of work going into looping

00:36:26,240 --> 00:36:30,680
and to doing stuff there and loops are

00:36:28,880 --> 00:36:33,290
very easy to speed up and cite them

00:36:30,680 --> 00:36:36,170
because you can you can replace the

00:36:33,290 --> 00:36:39,170
messy loops and do stuff directly in C

00:36:36,170 --> 00:36:41,300
rather than running through

00:36:39,170 --> 00:36:45,920
pythons iteration protocol so I'll do

00:36:41,300 --> 00:36:49,490
that first how do I do that well this is

00:36:45,920 --> 00:36:52,430
using a loop over a range so I know that

00:36:49,490 --> 00:36:58,250
these are actually integers and I can

00:36:52,430 --> 00:37:00,920
replace them by C integers okay most

00:36:58,250 --> 00:37:04,040
obvious change first I'm going to look

00:37:00,920 --> 00:37:06,410
into the usage of I then I can see that

00:37:04,040 --> 00:37:11,540
its use is used to index into your data

00:37:06,410 --> 00:37:13,430
structure well it's it's used as key in

00:37:11,540 --> 00:37:18,470
the dict and it's also used as index

00:37:13,430 --> 00:37:20,840
somewhere and that means that I'm so

00:37:18,470 --> 00:37:22,640
difference between C integers and Python

00:37:20,840 --> 00:37:25,660
integers is that Python integers are

00:37:22,640 --> 00:37:27,980
unbounded but they can have arbitrary

00:37:25,660 --> 00:37:30,050
they have an arbitrary value range they

00:37:27,980 --> 00:37:32,420
could be as large as your memory allows

00:37:30,050 --> 00:37:34,290
C integers are not see integers are

00:37:32,420 --> 00:37:36,540
always a range bounded

00:37:34,290 --> 00:37:40,440
this is the two bit integer which can

00:37:36,540 --> 00:37:45,540
take numbers up to two 2:31 stuff like

00:37:40,440 --> 00:37:48,120
that if it's signed and when you convert

00:37:45,540 --> 00:37:51,990
in Python code you recite them now to

00:37:48,120 --> 00:37:54,240
faster C code you have to take care of

00:37:51,990 --> 00:37:57,240
that right so I'm replacing Python

00:37:54,240 --> 00:38:00,210
integers save passengers which you can

00:37:57,240 --> 00:38:01,560
go obviously large by bounded C to just

00:38:00,210 --> 00:38:04,620
and I have to make sure that I'm not

00:38:01,560 --> 00:38:07,380
restricting the value range in valid way

00:38:04,620 --> 00:38:10,200
because you know C integers wrap around

00:38:07,380 --> 00:38:13,560
weird stuff when they got out of bounds

00:38:10,200 --> 00:38:17,790
but there is a integer type and that I

00:38:13,560 --> 00:38:21,720
can use you and that is it's called high

00:38:17,790 --> 00:38:25,730
size 2 or a size T if you want which is

00:38:21,720 --> 00:38:28,920
defined to be large enough to algorithm

00:38:25,730 --> 00:38:32,400
fit the size of your memory so it's a

00:38:28,920 --> 00:38:36,030
32-bit system it's a bit 64-bit system

00:38:32,400 --> 00:38:39,390
it's 64 bits and so forth and I'll type

00:38:36,030 --> 00:38:41,190
all variables in here using that type

00:38:39,390 --> 00:38:44,400
actually use a different type it's

00:38:41,190 --> 00:38:46,020
called pi size but that's just different

00:38:44,400 --> 00:38:50,700
name fruits that's used in the Python

00:38:46,020 --> 00:38:57,000
world I'll use that for my integer

00:38:50,700 --> 00:39:00,930
variables and I'll type them in in

00:38:57,000 --> 00:39:08,100
heaven annotation syntax so I have an I

00:39:00,930 --> 00:39:12,150
have je as an index I have we have a low

00:39:08,100 --> 00:39:15,960
a high so they're all index variables

00:39:12,150 --> 00:39:17,550
here and there's below and behind when I

00:39:15,960 --> 00:39:18,990
look through my code and those are all

00:39:17,550 --> 00:39:23,370
the index variables that are being used

00:39:18,990 --> 00:39:27,960
here and that's also best size which is

00:39:23,370 --> 00:39:31,590
also just an index best eye

00:39:27,960 --> 00:39:33,310
investigating ok yeah all of them that's

00:39:31,590 --> 00:39:35,650
nice Jane okay

00:39:33,310 --> 00:39:38,080
yep and through with my forests minutes

00:39:35,650 --> 00:39:42,850
I'll just go a bit into the question

00:39:38,080 --> 00:39:46,660
time and then run this there so I'll

00:39:42,850 --> 00:39:47,290
first compile it and using seitan eyes

00:39:46,660 --> 00:39:50,980
here

00:39:47,290 --> 00:39:53,050
so come on Mattie flip what does is just

00:39:50,980 --> 00:39:55,270
generated a C file for me you know it's

00:39:53,050 --> 00:39:57,970
calling the C compiler site nice is nice

00:39:55,270 --> 00:39:59,830
tool for doing like on one I just say

00:39:57,970 --> 00:40:04,060
site now is Michael would said no - is

00:39:59,830 --> 00:40:05,740
built in place compiled it generates the

00:40:04,060 --> 00:40:08,440
shared library for me and you can just

00:40:05,740 --> 00:40:16,020
import it and now when I run a benchmark

00:40:08,440 --> 00:40:19,840
again it's gonna be a lot faster already

00:40:16,020 --> 00:40:23,590
and well it's running look into the code

00:40:19,840 --> 00:40:25,450
again and just tell you there a couple

00:40:23,590 --> 00:40:28,960
more things that we can do one I already

00:40:25,450 --> 00:40:31,450
mentioned is I can replace this Python

00:40:28,960 --> 00:40:34,780
heck here by the just the expected

00:40:31,450 --> 00:40:40,090
operator so undo a patent optimization

00:40:34,780 --> 00:40:42,610
that is you know it can do but that's

00:40:40,090 --> 00:40:45,540
not beautiful and

00:40:42,610 --> 00:40:49,180
[Music]

00:40:45,540 --> 00:40:54,490
other things are using dicks here for

00:40:49,180 --> 00:40:56,080
example Dixon this here I'm calling the

00:40:54,490 --> 00:40:58,440
get method of a dict

00:40:56,080 --> 00:41:01,930
which in Python is looked up every time

00:40:58,440 --> 00:41:06,820
in sight then that actually very fast if

00:41:01,930 --> 00:41:09,600
site knows b2j is a ticked and so if I

00:41:06,820 --> 00:41:18,360
type BJ as dict

00:41:09,600 --> 00:41:26,100
which is the next thing I can do is

00:41:18,360 --> 00:41:26,100
arguments so e 2j

00:41:26,230 --> 00:41:32,980
[Music]

00:41:27,600 --> 00:41:35,619
Python dicts then that's also going to

00:41:32,980 --> 00:41:39,190
be sped up and you can see we're down

00:41:35,619 --> 00:41:43,300
from 46 seconds to 35 seconds just by

00:41:39,190 --> 00:41:46,510
typing the integers and one thing that

00:41:43,300 --> 00:41:50,920
that did is it allowed cycling to

00:41:46,510 --> 00:41:54,730
replace this integer range loop by a C

00:41:50,920 --> 00:41:56,710
for loop okay because all the index

00:41:54,730 --> 00:41:58,060
variables tight so it knows that you

00:41:56,710 --> 00:42:02,740
know there's nothing that can wrong I'm

00:41:58,060 --> 00:42:08,320
actually asking for C for loop here okay

00:42:02,740 --> 00:42:12,990
now try the the dict optimization next

00:42:08,320 --> 00:42:15,850
and then I'm already proved my torch and

00:42:12,990 --> 00:42:18,119
a should be time for one or two

00:42:15,850 --> 00:42:21,250
questions afterwards

00:42:18,119 --> 00:42:26,710
so it's compiling and the benchmark

00:42:21,250 --> 00:42:29,890
again this is a usual way how we go

00:42:26,710 --> 00:42:32,200
about optimizing code in in syphon right

00:42:29,890 --> 00:42:34,500
you take Python code to start typing

00:42:32,200 --> 00:42:39,330
variables replace them by C data types

00:42:34,500 --> 00:42:43,060
in there you use static typing for

00:42:39,330 --> 00:42:45,580
instructing siphon to opt out of general

00:42:43,060 --> 00:42:48,520
this is some kind of object semantics

00:42:45,580 --> 00:42:51,609
into this is a specific data type please

00:42:48,520 --> 00:42:53,619
optimize it optimize the code for it and

00:42:51,609 --> 00:42:58,740
seitan will generate codes for the data

00:42:53,619 --> 00:43:01,000
types that is usually faster and

00:42:58,740 --> 00:43:02,920
definitely more adapted to what you're

00:43:01,000 --> 00:43:05,740
doing in your code okay and that gives

00:43:02,920 --> 00:43:09,850
another five seconds run time so we down

00:43:05,740 --> 00:43:13,320
from 46 seconds to 30 seconds just by

00:43:09,850 --> 00:43:13,320
typing a couple variables here

00:43:17,590 --> 00:43:25,970
we got time for a few questions one or

00:43:20,660 --> 00:43:28,910
two just a couple of questions the first

00:43:25,970 --> 00:43:32,450
one is like we have seen that you can

00:43:28,910 --> 00:43:33,980
call random I mean custom see libraries

00:43:32,450 --> 00:43:36,350
from Python just by defining the

00:43:33,980 --> 00:43:37,880
interface for them is it possible to do

00:43:36,350 --> 00:43:46,490
the opposite I mean call Python code

00:43:37,880 --> 00:43:49,370
from C with using - yes so you can

00:43:46,490 --> 00:43:51,470
generate so-called CDF functions in

00:43:49,370 --> 00:43:54,200
seitan which are just C functions with a

00:43:51,470 --> 00:43:55,820
expected C signature and you can drop

00:43:54,200 --> 00:43:58,580
any sighting code in there any patent

00:43:55,820 --> 00:44:01,280
code in there and you can call the C

00:43:58,580 --> 00:44:04,370
function from C and then you can execute

00:44:01,280 --> 00:44:08,240
any code in there uncle and the second

00:44:04,370 --> 00:44:10,670
question is like whether syphon benefits

00:44:08,240 --> 00:44:14,180
in some way from using typing's hints

00:44:10,670 --> 00:44:16,480
like new python we have the function

00:44:14,180 --> 00:44:20,960
type hints and so on

00:44:16,480 --> 00:44:23,330
the syntax for this it does not really

00:44:20,960 --> 00:44:25,850
benefit all that much from you know

00:44:23,330 --> 00:44:27,860
normal pet for it for typing type

00:44:25,850 --> 00:44:29,840
annotations in Python because net that's

00:44:27,860 --> 00:44:32,600
not so much to gain from them for

00:44:29,840 --> 00:44:39,110
optimization they are for code checking

00:44:32,600 --> 00:44:41,000
than not less question so so we use

00:44:39,110 --> 00:44:43,070
siphon a lot these are really great tool

00:44:41,000 --> 00:44:45,130
and one of the things we mentioned the

00:44:43,070 --> 00:44:47,630
cyclone echo system is a linter

00:44:45,130 --> 00:44:50,660
sometimes love life like a dope appeal

00:44:47,630 --> 00:44:52,850
whatever like if we use some subset of

00:44:50,660 --> 00:44:55,100
what Flicka does like basically ignoring

00:44:52,850 --> 00:44:58,610
syntax errors but we wonder if there is

00:44:55,100 --> 00:45:00,140
I mean project or idea of maybe exposing

00:44:58,610 --> 00:45:03,250
the abstraction that tree or something

00:45:00,140 --> 00:45:07,220
so we can hook into existing Linton dude

00:45:03,250 --> 00:45:09,500
okay so to support you can do two things

00:45:07,220 --> 00:45:12,410
one is as long as you are really just

00:45:09,500 --> 00:45:14,540
optimizing Python codes you can use

00:45:12,410 --> 00:45:16,340
Python syntax for it and that keeps your

00:45:14,540 --> 00:45:18,530
code you optimize code you're compatible

00:45:16,340 --> 00:45:20,540
code impacting syntax and you can use

00:45:18,530 --> 00:45:24,050
all it happen towards as soon as you

00:45:20,540 --> 00:45:26,090
start calling you to see using native

00:45:24,050 --> 00:45:28,280
code

00:45:26,090 --> 00:45:30,560
you lose that ability because you know

00:45:28,280 --> 00:45:33,620
camping map to Python and that code can

00:45:30,560 --> 00:45:36,280
cannot run in pattern anymore so use

00:45:33,620 --> 00:45:40,220
certain syntax for that in which case

00:45:36,280 --> 00:45:42,440
there are a couple of motifs at least

00:45:40,220 --> 00:45:46,820
PyCharm definitely which supports siphon

00:45:42,440 --> 00:45:49,430
you can use that there probably also

00:45:46,820 --> 00:45:53,240
other ideas who are you know kind of

00:45:49,430 --> 00:45:58,090
having some some basic support or but

00:45:53,240 --> 00:46:00,410
I'm not aware of many many tools for

00:45:58,090 --> 00:46:04,510
code analysis and it's kind of stuff in

00:46:00,410 --> 00:46:07,130
on cyber court specifically syntax

00:46:04,510 --> 00:46:09,390
alright don't forget to rate to talk and

00:46:07,130 --> 00:46:15,449
let's give Stefan one round of applause

00:46:09,390 --> 00:46:15,449

YouTube URL: https://www.youtube.com/watch?v=4xpeJYWvbuU


