Title: Doug Hellmann - reno - A New Way to Manage Release Notes
Publication date: 2018-08-22
Playlist: EuroPython 2018
Description: 
	reno: A New Way to Manage Release Notes
[EuroPython 2018 - Talk - 2018-07-25 - Moorfoot]
[Edinburgh, UK]

By Doug Hellmann

reno is a tool for managing release notes in projects that support multiple branches of development, and releases, simultaneously. It solves the problem of managing release notes within patches that fix bugs, and makes it easier to cherry-pick changes between branches (allowing backports or forward ports). This talk will cover the requirements, and constraints, that led us to design and build reno. I will also show how to use it to create notes and publish them in your packages and via Sphinx-based documentation. Then I will talk about the impact reno, and the release notes publishing automation, had on our project and release processes.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2018.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:01,850 --> 00:00:08,099
Thank You Martin yeah so as Martin said

00:00:05,790 --> 00:00:09,719
my name is Doug Hellman I'm here to talk

00:00:08,099 --> 00:00:11,670
to you today about a tool called Reno

00:00:09,719 --> 00:00:13,759
which we built as part of the OpenStack

00:00:11,670 --> 00:00:16,109
community to manage our release notes

00:00:13,759 --> 00:00:17,940
it's not really relevant to the talk

00:00:16,109 --> 00:00:19,289
itself but I'll for those of you who

00:00:17,940 --> 00:00:21,480
might not know what OpenStack is I'll

00:00:19,289 --> 00:00:23,779
give you a sort of the elevator pitch it

00:00:21,480 --> 00:00:25,650
is the cloud management platform

00:00:23,779 --> 00:00:27,480
infrastructure management platform

00:00:25,650 --> 00:00:29,490
written in Python that gives you

00:00:27,480 --> 00:00:32,130
features like you might find in AWS or

00:00:29,490 --> 00:00:33,530
Azure or things like that and it's all

00:00:32,130 --> 00:00:37,320
open source and you can run it on your

00:00:33,530 --> 00:00:39,809
hardware in your own data center we

00:00:37,320 --> 00:00:41,670
consider release notes to be an

00:00:39,809 --> 00:00:44,219
important aspect of communicating with

00:00:41,670 --> 00:00:45,660
our users those of you who build

00:00:44,219 --> 00:00:47,760
libraries are probably used to

00:00:45,660 --> 00:00:49,079
explaining about what you've done in

00:00:47,760 --> 00:00:51,090
each release or if you've got an

00:00:49,079 --> 00:00:52,739
application that you distribute to other

00:00:51,090 --> 00:00:54,480
users and don't just host yourself

00:00:52,739 --> 00:00:56,670
you're probably used to doing the same

00:00:54,480 --> 00:00:58,320
thing sort of explaining what kinds of

00:00:56,670 --> 00:01:00,239
challenges you might run into to do an

00:00:58,320 --> 00:01:02,100
upgrade or what new features are present

00:01:00,239 --> 00:01:04,439
or what other kinds of changes are there

00:01:02,100 --> 00:01:06,570
with OpenStack in particular because of

00:01:04,439 --> 00:01:09,180
the complexity release notes are a very

00:01:06,570 --> 00:01:10,590
important part of our documentation and

00:01:09,180 --> 00:01:12,330
so I'm going to talk a little bit about

00:01:10,590 --> 00:01:15,119
a tool that we created to help us manage

00:01:12,330 --> 00:01:20,450
those in a way that let us maintain them

00:01:15,119 --> 00:01:24,060
more sustainably we we created it early

00:01:20,450 --> 00:01:26,310
early in 2015 as as our community was

00:01:24,060 --> 00:01:27,600
growing and we were seeing not just an

00:01:26,310 --> 00:01:29,610
increase in the number of different

00:01:27,600 --> 00:01:31,860
services and components to OpenStack

00:01:29,610 --> 00:01:34,320
itself but the contributors and the

00:01:31,860 --> 00:01:37,979
contributions that were coming in so we

00:01:34,320 --> 00:01:40,920
started out with six or seven projects

00:01:37,979 --> 00:01:43,799
service projects each managing an API

00:01:40,920 --> 00:01:49,530
and a Python client library to talk to

00:01:43,799 --> 00:01:51,509
that API and then over time we grew but

00:01:49,530 --> 00:01:53,310
in the early days each project was sort

00:01:51,509 --> 00:01:55,350
of responsible for doing their own thing

00:01:53,310 --> 00:01:57,240
with release nodes so we had a wiki and

00:01:55,350 --> 00:02:00,180
people would just go and manually put

00:01:57,240 --> 00:02:01,680
notes into the wiki maybe they would

00:02:00,180 --> 00:02:03,420
keep up to date with what they were

00:02:01,680 --> 00:02:04,920
doing and frequently they really

00:02:03,420 --> 00:02:06,930
wouldn't so at the end of a release

00:02:04,920 --> 00:02:08,550
cycle we would spend a bunch of time

00:02:06,930 --> 00:02:10,440
going through all of the work that we

00:02:08,550 --> 00:02:11,819
had done and our release cycles are

00:02:10,440 --> 00:02:13,769
every six months so

00:02:11,819 --> 00:02:15,900
that meant going back through six months

00:02:13,769 --> 00:02:17,909
worth of work for all of those projects

00:02:15,900 --> 00:02:20,459
and trying to understand which ones were

00:02:17,909 --> 00:02:22,469
user-facing changes what added new

00:02:20,459 --> 00:02:27,299
configuration options what might impact

00:02:22,469 --> 00:02:29,250
the upgrade and things like that that

00:02:27,299 --> 00:02:32,879
turned into a real challenge for us as

00:02:29,250 --> 00:02:35,250
we grew in particular because of the

00:02:32,879 --> 00:02:36,599
amount of changes that we were seeing so

00:02:35,250 --> 00:02:39,239
even at a point where we were still

00:02:36,599 --> 00:02:42,319
doing just six different projects that

00:02:39,239 --> 00:02:45,000
the changes ramped up very quickly and

00:02:42,319 --> 00:02:46,530
it also turned into a problem when we

00:02:45,000 --> 00:02:48,540
were back porting changes so our

00:02:46,530 --> 00:02:50,219
development model is that we do all of

00:02:48,540 --> 00:02:52,439
our development on the master branch and

00:02:50,219 --> 00:02:55,409
then we produce a stable release every

00:02:52,439 --> 00:02:57,750
six months and the stable release branch

00:02:55,409 --> 00:02:59,519
will see updates over the period of six

00:02:57,750 --> 00:03:02,790
to 18 months depending on how long it's

00:02:59,519 --> 00:03:04,739
maintained and those changes are limited

00:03:02,790 --> 00:03:07,049
to bug fixes so we call it stable

00:03:04,739 --> 00:03:08,730
because we don't back port features and

00:03:07,049 --> 00:03:10,709
we hope that that makes it a little more

00:03:08,730 --> 00:03:12,599
stable than it would otherwise be

00:03:10,709 --> 00:03:14,310
but those bug fixes typically come with

00:03:12,599 --> 00:03:17,879
changes that need release notes as well

00:03:14,310 --> 00:03:20,599
so as we saw more and more of those

00:03:17,879 --> 00:03:23,009
branches created and more and more

00:03:20,599 --> 00:03:24,810
patches and fixes going into them that

00:03:23,009 --> 00:03:27,329
turned into a problem for us too

00:03:24,810 --> 00:03:29,310
and then we really hit a stride where we

00:03:27,329 --> 00:03:32,400
were growing as a community so we grew

00:03:29,310 --> 00:03:36,389
from six projects teams to over 60

00:03:32,400 --> 00:03:38,639
different teams now and we have those 60

00:03:36,389 --> 00:03:40,829
teams managing 300 different or more

00:03:38,639 --> 00:03:43,379
deliverable objects so that we talk

00:03:40,829 --> 00:03:45,120
about deliverables meaning and artifact

00:03:43,379 --> 00:03:46,799
that we build and ship to someone so

00:03:45,120 --> 00:03:48,930
that's usually a library but it's often

00:03:46,799 --> 00:03:52,829
a service in some sort of package as

00:03:48,930 --> 00:03:54,750
well and the manual process is that we

00:03:52,829 --> 00:03:56,699
were using for six teams just we're not

00:03:54,750 --> 00:03:58,400
going to scale to sixty teams and and

00:03:56,699 --> 00:04:01,799
six hundred three hundred different

00:03:58,400 --> 00:04:04,079
deliverable objects we did scale out the

00:04:01,799 --> 00:04:06,120
release team so we originally had one

00:04:04,079 --> 00:04:07,650
person managing all of the releases and

00:04:06,120 --> 00:04:10,169
and he was doing a lot of work by hand

00:04:07,650 --> 00:04:13,229
the team doubled in size when I joined

00:04:10,169 --> 00:04:15,150
it but I'm extremely lazy so that really

00:04:13,229 --> 00:04:16,919
didn't actually double the amount of

00:04:15,150 --> 00:04:18,780
work that we were able to do instead of

00:04:16,919 --> 00:04:20,430
trying to do all of that work by hand I

00:04:18,780 --> 00:04:22,229
started thinking about ways that we

00:04:20,430 --> 00:04:24,150
could apply automation so as a good

00:04:22,229 --> 00:04:25,169
programmer I immediately tried to write

00:04:24,150 --> 00:04:30,419
a program to solve the

00:04:25,169 --> 00:04:32,069
right so I have not yet been able to

00:04:30,419 --> 00:04:33,779
figure out a way to automate writing

00:04:32,069 --> 00:04:34,139
release notes so I kind of set that

00:04:33,779 --> 00:04:37,409
aside

00:04:34,139 --> 00:04:38,909
and instead focus on making it easier

00:04:37,409 --> 00:04:41,099
for other people to do that work

00:04:38,909 --> 00:04:42,569
so making it easier to manage the

00:04:41,099 --> 00:04:44,490
release notes throughout the course of

00:04:42,569 --> 00:04:49,650
developing the project over a release

00:04:44,490 --> 00:04:51,479
cycle as well as automating the

00:04:49,650 --> 00:04:53,939
publishing of those release notes so we

00:04:51,479 --> 00:04:55,560
include them within the package that we

00:04:53,939 --> 00:04:57,120
distribute but we also want to publish

00:04:55,560 --> 00:04:59,129
them on our website so that they're easy

00:04:57,120 --> 00:05:01,310
to find and Google and that sort of

00:04:59,129 --> 00:05:01,310
thing

00:05:01,349 --> 00:05:06,960
when we sat down as a team to look at

00:05:04,729 --> 00:05:09,060
our different requirements for this

00:05:06,960 --> 00:05:11,189
project we kind of divided them into two

00:05:09,060 --> 00:05:13,110
different groups so we had some content

00:05:11,189 --> 00:05:14,729
requirements about how we wanted to

00:05:13,110 --> 00:05:16,439
manage content and some process

00:05:14,729 --> 00:05:20,150
requirements about how we wanted to make

00:05:16,439 --> 00:05:22,560
our process sustainable as we grew

00:05:20,150 --> 00:05:24,870
peer-review is a very important aspect

00:05:22,560 --> 00:05:26,789
of our community culture everything that

00:05:24,870 --> 00:05:28,499
we do within OpenStack is peer reviewed

00:05:26,789 --> 00:05:30,659
so every bit of code is posted for

00:05:28,499 --> 00:05:33,000
review and normally reviewed by two

00:05:30,659 --> 00:05:36,960
reviewers at least before it gets

00:05:33,000 --> 00:05:38,400
approved and merged we wanted to know we

00:05:36,960 --> 00:05:40,169
also wanted to be able to organize the

00:05:38,400 --> 00:05:42,319
content so I mentioned several different

00:05:40,169 --> 00:05:45,439
kinds of release notes like upgrades

00:05:42,319 --> 00:05:47,219
impacts bug fixes and and

00:05:45,439 --> 00:05:49,259
incompatibilities and things like that

00:05:47,219 --> 00:05:50,909
we wanted to be able to organize our

00:05:49,259 --> 00:05:53,580
release notes as they were published

00:05:50,909 --> 00:05:55,259
into those different kinds of notes so

00:05:53,580 --> 00:05:56,789
that you could go and read all about

00:05:55,259 --> 00:05:59,129
what you needed to know to do an upgrade

00:05:56,789 --> 00:06:01,729
in one section and not necessarily worry

00:05:59,129 --> 00:06:04,379
about new features in that section we

00:06:01,729 --> 00:06:05,909
also wanted to be able to change the

00:06:04,379 --> 00:06:07,469
release notes so we don't assume even

00:06:05,909 --> 00:06:10,259
with a peer-review process that we're

00:06:07,469 --> 00:06:12,449
gonna catch any mistakes or you know not

00:06:10,259 --> 00:06:13,860
miss something or have some other kind

00:06:12,449 --> 00:06:15,659
of errors so we knew we wanted to be

00:06:13,860 --> 00:06:19,710
able to go back later and change notes

00:06:15,659 --> 00:06:21,270
and hold releases and then it's very

00:06:19,710 --> 00:06:23,370
important due to the pace that we work

00:06:21,270 --> 00:06:25,949
at that we want to avoid merge conflicts

00:06:23,370 --> 00:06:28,409
so it can typically take a week or more

00:06:25,949 --> 00:06:32,189
to get a patch reviewed and merged even

00:06:28,409 --> 00:06:33,870
at a fast review period some of them

00:06:32,189 --> 00:06:35,639
take much longer than that and every

00:06:33,870 --> 00:06:37,319
time you encounter a merge conflict you

00:06:35,639 --> 00:06:38,260
basically have to start over because you

00:06:37,319 --> 00:06:39,880
have to

00:06:38,260 --> 00:06:41,470
based the patch and resubmit it it has

00:06:39,880 --> 00:06:42,970
to pass all the tests again and then you

00:06:41,470 --> 00:06:45,220
have to get reviewers to take a look at

00:06:42,970 --> 00:06:47,140
it again so we wanted to design a system

00:06:45,220 --> 00:06:48,340
that just completely avoided having to

00:06:47,140 --> 00:06:52,390
deal with merge conflicts as a

00:06:48,340 --> 00:06:54,810
contributor on the process side we had

00:06:52,390 --> 00:06:57,880
some other kinds of similar requirements

00:06:54,810 --> 00:07:00,930
we use two different kinds of versioning

00:06:57,880 --> 00:07:03,160
for our deliverables so libraries are

00:07:00,930 --> 00:07:05,050
versioned using semantic versioning

00:07:03,160 --> 00:07:06,730
which means that you increment the

00:07:05,050 --> 00:07:08,950
version number based on the kinds of

00:07:06,730 --> 00:07:10,960
changes that are in the new version not

00:07:08,950 --> 00:07:14,560
the number of changes that are in the

00:07:10,960 --> 00:07:16,030
new version for those kinds of things we

00:07:14,560 --> 00:07:17,620
don't know in advance when you write a

00:07:16,030 --> 00:07:19,090
release note what the next version is

00:07:17,620 --> 00:07:20,650
going to be so we didn't want release

00:07:19,090 --> 00:07:22,750
note authors that even have to think

00:07:20,650 --> 00:07:24,370
about version numbers we wanted them to

00:07:22,750 --> 00:07:25,840
be able to just contribute a note and it

00:07:24,370 --> 00:07:27,130
would automatically be applied to the

00:07:25,840 --> 00:07:30,190
correct version when the release was

00:07:27,130 --> 00:07:32,710
created I mentioned our stable branch

00:07:30,190 --> 00:07:35,050
policy we wanted to make sure that not

00:07:32,710 --> 00:07:36,460
just that we avoided merge conflicts on

00:07:35,050 --> 00:07:38,380
the master branch but that we also

00:07:36,460 --> 00:07:41,470
avoided merge conflicts when we back

00:07:38,380 --> 00:07:43,180
ported patches right now we use Gerrit

00:07:41,470 --> 00:07:44,800
as a review tool and you can backport a

00:07:43,180 --> 00:07:47,110
patch basically clicking a couple of

00:07:44,800 --> 00:07:48,790
buttons in a webpage and it will create

00:07:47,110 --> 00:07:51,040
the new patch on the new branch for you

00:07:48,790 --> 00:07:52,300
and apply it automatically and as soon

00:07:51,040 --> 00:07:54,970
as you start talking about merge

00:07:52,300 --> 00:07:57,880
conflicts there you raised the bar for

00:07:54,970 --> 00:07:59,650
back porting a bug fixed very you know

00:07:57,880 --> 00:08:01,330
makes it much harder to do that so we

00:07:59,650 --> 00:08:03,550
wanted to avoid merge conflicts there as

00:08:01,330 --> 00:08:05,260
well and then of course since the

00:08:03,550 --> 00:08:06,970
release team is very lazy we didn't want

00:08:05,260 --> 00:08:08,470
any manual processes involved in

00:08:06,970 --> 00:08:11,320
publishing the notes at the end of a

00:08:08,470 --> 00:08:13,090
release so we didn't also you know we

00:08:11,320 --> 00:08:14,080
didn't want to have the author of the

00:08:13,090 --> 00:08:15,730
release note have to worry about

00:08:14,080 --> 00:08:18,340
versioning we didn't want the release

00:08:15,730 --> 00:08:19,840
team to have to sit down and mark

00:08:18,340 --> 00:08:21,280
version numbers on a bunch of release

00:08:19,840 --> 00:08:22,540
notes or anything like that either

00:08:21,280 --> 00:08:26,370
we just wanted all of that stuff to be

00:08:22,540 --> 00:08:30,490
handled automatically we went through

00:08:26,370 --> 00:08:32,050
three different designs in the course of

00:08:30,490 --> 00:08:34,630
trying to figure out how to meet all of

00:08:32,050 --> 00:08:36,040
those requirements so the first one was

00:08:34,630 --> 00:08:37,870
sort of the obvious thing we were

00:08:36,040 --> 00:08:39,370
already using Sphinx for documentation

00:08:37,870 --> 00:08:40,780
we could just use Sphinx for release

00:08:39,370 --> 00:08:42,400
notes you could just write your release

00:08:40,780 --> 00:08:46,390
notes in a document and included in

00:08:42,400 --> 00:08:49,030
Sphinx that has a couple of different

00:08:46,390 --> 00:08:50,650
problems so either the release know

00:08:49,030 --> 00:08:51,840
daughter has to know the version number

00:08:50,650 --> 00:08:55,200
so they put it in the right

00:08:51,840 --> 00:08:56,670
place in the right file or someone has

00:08:55,200 --> 00:08:58,380
to go back later and apply the version

00:08:56,670 --> 00:09:00,210
number so that didn't meet either of

00:08:58,380 --> 00:09:01,980
those requirements for us and it's also

00:09:00,210 --> 00:09:04,770
messy for cherry-picking changes

00:09:01,980 --> 00:09:06,750
particularly if you if you organize

00:09:04,770 --> 00:09:09,330
things in a directory structure in some

00:09:06,750 --> 00:09:11,220
way when you cherry-pick a change back

00:09:09,330 --> 00:09:12,930
you then have to edit that change to put

00:09:11,220 --> 00:09:14,640
the new note in the correct place for

00:09:12,930 --> 00:09:19,680
the older branch because the version

00:09:14,640 --> 00:09:21,330
numbers the system is different we also

00:09:19,680 --> 00:09:23,670
thought about using to get commit

00:09:21,330 --> 00:09:25,350
messages so just having the patch author

00:09:23,670 --> 00:09:26,940
write that release note right in the get

00:09:25,350 --> 00:09:32,160
commit message as they were contributing

00:09:26,940 --> 00:09:35,190
to patch that would work mostly but the

00:09:32,160 --> 00:09:36,480
author sort of the audience for a commit

00:09:35,190 --> 00:09:38,790
message is very different from the

00:09:36,480 --> 00:09:42,210
audience for a release note so for a

00:09:38,790 --> 00:09:43,770
library it might be similar but really

00:09:42,210 --> 00:09:45,240
we wanted people to be focused on

00:09:43,770 --> 00:09:47,100
writing commit messages for the

00:09:45,240 --> 00:09:49,620
reviewers to understand what was going

00:09:47,100 --> 00:09:51,780
on in the patch and not necessarily the

00:09:49,620 --> 00:09:53,400
user having to go and read the get

00:09:51,780 --> 00:09:55,770
history to understand everything that

00:09:53,400 --> 00:09:57,810
had changed so we wanted them to have

00:09:55,770 --> 00:09:59,550
either a condensed version or an

00:09:57,810 --> 00:10:01,470
expanded version that explained in more

00:09:59,550 --> 00:10:03,630
detail for the correct audience for

00:10:01,470 --> 00:10:05,940
those release notes the commit messages

00:10:03,630 --> 00:10:07,920
are also largely immutable so once it's

00:10:05,940 --> 00:10:12,360
in that public repository your notes are

00:10:07,920 --> 00:10:14,610
basically set and that's done we also

00:10:12,360 --> 00:10:16,890
looked at the git notes feature which is

00:10:14,610 --> 00:10:18,210
I don't know a lot of the detail about

00:10:16,890 --> 00:10:20,460
this one but it's sort of a parallel

00:10:18,210 --> 00:10:22,620
thing to the git repository and you can

00:10:20,460 --> 00:10:25,110
do a little bit of extra set up and have

00:10:22,620 --> 00:10:28,140
notes attached to commits but not be

00:10:25,110 --> 00:10:29,790
part of the commit and that was an

00:10:28,140 --> 00:10:31,260
interesting approach and so we realized

00:10:29,790 --> 00:10:33,000
that you needed to do a bunch of extra

00:10:31,260 --> 00:10:34,590
setup with Garrett in order to make it

00:10:33,000 --> 00:10:36,360
work and the permissions were different

00:10:34,590 --> 00:10:38,580
and it wasn't really a reviewable thing

00:10:36,360 --> 00:10:42,900
so it fell down on our peer review

00:10:38,580 --> 00:10:45,060
criteria there and so we finally ended

00:10:42,900 --> 00:10:47,880
up with a system that we implemented as

00:10:45,060 --> 00:10:49,680
reno where we use data files inside of

00:10:47,880 --> 00:10:51,900
the commits to hold the release note

00:10:49,680 --> 00:10:55,020
content but they're not sphinx files

00:10:51,900 --> 00:10:57,480
they're just in independent data files

00:10:55,020 --> 00:11:00,360
and then we do some integration work to

00:10:57,480 --> 00:11:02,400
make those publishable because they're

00:11:00,360 --> 00:11:04,170
inside the patch they're reviewable so

00:11:02,400 --> 00:11:04,630
the reviewers can comment on them and

00:11:04,170 --> 00:11:06,700
reject

00:11:04,630 --> 00:11:11,230
and you can make changes as submit a new

00:11:06,700 --> 00:11:14,140
version we do read the release notes

00:11:11,230 --> 00:11:15,910
data out of the get objects so they're

00:11:14,140 --> 00:11:17,710
not it doesn't matter where they are on

00:11:15,910 --> 00:11:19,810
the file system they're all basically in

00:11:17,710 --> 00:11:21,370
one directory together and we look at

00:11:19,810 --> 00:11:23,230
the git history to figure out which

00:11:21,370 --> 00:11:25,120
version that go in because they're part

00:11:23,230 --> 00:11:28,420
of it commit we can tell which version

00:11:25,120 --> 00:11:31,720
that commit is in and so that's what

00:11:28,420 --> 00:11:33,880
Reno does Reno uses those data files and

00:11:31,720 --> 00:11:36,010
basically uses the git history as a

00:11:33,880 --> 00:11:38,020
database reading those particular files

00:11:36,010 --> 00:11:40,090
and then assembling them in whatever

00:11:38,020 --> 00:11:42,730
form you've asked for to build the

00:11:40,090 --> 00:11:45,880
release notes report

00:11:42,730 --> 00:11:47,680
it's a command-line tool so you start

00:11:45,880 --> 00:11:50,290
out with the reno add command and that

00:11:47,680 --> 00:11:52,260
you give it a slug just to sort of be

00:11:50,290 --> 00:11:54,520
able to identify what the file is

00:11:52,260 --> 00:11:56,500
frequently people will use bug numbers

00:11:54,520 --> 00:11:59,110
or they use a short abbreviation of the

00:11:56,500 --> 00:12:01,210
feature and we have a specification

00:11:59,110 --> 00:12:04,060
process which gives everything a sort of

00:12:01,210 --> 00:12:05,470
a unique name so sometimes the notes

00:12:04,060 --> 00:12:07,630
files will have those as part of the

00:12:05,470 --> 00:12:09,670
names as well and then reno adds a

00:12:07,630 --> 00:12:11,260
unique identifier to that slug that you

00:12:09,670 --> 00:12:13,180
give it so that it can track the history

00:12:11,260 --> 00:12:14,620
of that file across all of the branches

00:12:13,180 --> 00:12:18,970
and through all of the revisions that

00:12:14,620 --> 00:12:20,710
you have the files are placed in a

00:12:18,970 --> 00:12:22,180
subdirectory of the project like I said

00:12:20,710 --> 00:12:24,400
they're all just placed in one directory

00:12:22,180 --> 00:12:25,960
together they can be organized a little

00:12:24,400 --> 00:12:29,740
bit under that directory some teams have

00:12:25,960 --> 00:12:31,360
divided them up into different different

00:12:29,740 --> 00:12:33,460
kinds of organizations it doesn't really

00:12:31,360 --> 00:12:35,620
make any difference for that Reno

00:12:33,460 --> 00:12:37,480
because it's not reading the file system

00:12:35,620 --> 00:12:40,300
it doesn't really care what files the

00:12:37,480 --> 00:12:42,460
notes are actually in and the data file

00:12:40,300 --> 00:12:44,020
themselves are yamo files so this is an

00:12:42,460 --> 00:12:47,170
abbreviated version of what one of those

00:12:44,020 --> 00:12:49,390
would look like the section the keys

00:12:47,170 --> 00:12:52,000
there are section names and those are

00:12:49,390 --> 00:12:53,860
predefined but configurable so if you

00:12:52,000 --> 00:12:55,570
have a project and we have several

00:12:53,860 --> 00:12:57,490
projects outside of OpenStack that are

00:12:55,570 --> 00:12:59,680
using Reno that have a different set of

00:12:57,490 --> 00:13:01,600
features that they want to use or

00:12:59,680 --> 00:13:03,520
sections within their release notes that

00:13:01,600 --> 00:13:05,500
they want to use you can change what's

00:13:03,520 --> 00:13:07,480
that what those are and then Reno knows

00:13:05,500 --> 00:13:09,250
what order to apply the sections and

00:13:07,480 --> 00:13:11,980
then which sections each note goes in

00:13:09,250 --> 00:13:15,250
within the section within the data file

00:13:11,980 --> 00:13:17,350
you have a list of restructured text

00:13:15,250 --> 00:13:17,889
blobs that are just sort of inserted in

00:13:17,350 --> 00:13:20,170
in the

00:13:17,889 --> 00:13:21,730
order that are presented and using

00:13:20,170 --> 00:13:22,959
restructure text lets us integrate

00:13:21,730 --> 00:13:25,869
easily with Sphinx

00:13:22,959 --> 00:13:28,149
it also lets us do things like link off

00:13:25,869 --> 00:13:30,160
to bug reports or feature descriptions

00:13:28,149 --> 00:13:32,470
or specifications or that sort of thing

00:13:30,160 --> 00:13:35,259
so you get all of that nice markup and

00:13:32,470 --> 00:13:36,850
we use restructure text rather than HTML

00:13:35,259 --> 00:13:39,249
or something like that because we do

00:13:36,850 --> 00:13:41,980
actually generate PDF documentation for

00:13:39,249 --> 00:13:44,439
some of our translated sites especially

00:13:41,980 --> 00:13:46,089
those behind the Great Wall and China

00:13:44,439 --> 00:13:48,040
it's easier for them to download a PDF

00:13:46,089 --> 00:13:51,839
and share it than it is sometimes to get

00:13:48,040 --> 00:13:51,839
to web sites that are outside of China

00:13:52,259 --> 00:13:58,899
so the output from Reno we can take a

00:13:56,649 --> 00:14:01,749
look at an example repository so this is

00:13:58,899 --> 00:14:03,549
a typical graph showing the history with

00:14:01,749 --> 00:14:06,369
the beginning at the bottom and the most

00:14:03,549 --> 00:14:08,379
current commits at the top there and I

00:14:06,369 --> 00:14:09,519
have one stable branch that I've created

00:14:08,379 --> 00:14:11,309
just to be able to show what a

00:14:09,519 --> 00:14:13,689
cherry-pick is going to look like

00:14:11,309 --> 00:14:16,329
there's two different versions or tags

00:14:13,689 --> 00:14:18,339
so we have a 2.0 version that has four

00:14:16,329 --> 00:14:20,379
commits and if we assume that we're all

00:14:18,339 --> 00:14:21,759
good developers and care about our users

00:14:20,379 --> 00:14:23,169
we have a release note in each of those

00:14:21,759 --> 00:14:26,889
we're going to have four release notes

00:14:23,169 --> 00:14:28,419
for 2.0 and then version 1.0 is the

00:14:26,889 --> 00:14:31,449
first two commits there and that's going

00:14:28,419 --> 00:14:33,459
to include two release notes so if we

00:14:31,449 --> 00:14:36,279
look at the output of the report command

00:14:33,459 --> 00:14:39,220
for the 2.0 version we can see those

00:14:36,279 --> 00:14:41,079
four release notes with the I've just

00:14:39,220 --> 00:14:42,369
included the the letter names there so

00:14:41,079 --> 00:14:46,989
that you can tell that they're from each

00:14:42,369 --> 00:14:48,369
of those commits and it does that I've

00:14:46,989 --> 00:14:50,860
included them all in the the new

00:14:48,369 --> 00:14:52,209
features section just because that made

00:14:50,860 --> 00:14:53,679
it easier to fin on the slide but of

00:14:52,209 --> 00:14:57,689
course you can organize those into

00:14:53,679 --> 00:15:00,339
different sections as appropriate Reno

00:14:57,689 --> 00:15:02,220
figures out which notes to include by

00:15:00,339 --> 00:15:05,139
starting at the tag that you've given it

00:15:02,220 --> 00:15:07,239
as a start point and it reads the gate

00:15:05,139 --> 00:15:09,759
history one commit at a time looking for

00:15:07,239 --> 00:15:12,730
release note changes in those files and

00:15:09,759 --> 00:15:14,499
then then it assembles those into its

00:15:12,730 --> 00:15:15,789
database for that version and it omits

00:15:14,499 --> 00:15:18,789
them in the order that they've been

00:15:15,789 --> 00:15:21,129
presented and it knows that those notes

00:15:18,789 --> 00:15:23,499
apply to that version because they

00:15:21,129 --> 00:15:26,049
appear either on the commit that is

00:15:23,499 --> 00:15:27,910
tagged or before the commit that is

00:15:26,049 --> 00:15:30,410
tagged with the next version number or

00:15:27,910 --> 00:15:32,389
the previous version number I suppose so

00:15:30,410 --> 00:15:34,490
as its scanning backwards in history

00:15:32,389 --> 00:15:36,639
it's gonna find the 2.0 version first

00:15:34,490 --> 00:15:42,199
and then it will find the 1.8 version

00:15:36,639 --> 00:15:44,449
following that it is so Reno does the

00:15:42,199 --> 00:15:46,250
scanning using a pure Python library

00:15:44,449 --> 00:15:50,300
called Dulwich which is an

00:15:46,250 --> 00:15:51,860
implementation of the get library we

00:15:50,300 --> 00:15:53,269
chose that one because it's pip

00:15:51,860 --> 00:15:55,129
installable without any other

00:15:53,269 --> 00:15:58,009
dependencies which makes it easier to

00:15:55,129 --> 00:16:00,439
manage and work on release notes on

00:15:58,009 --> 00:16:02,329
various different platforms so there are

00:16:00,439 --> 00:16:05,720
a bunch of libraries that actually

00:16:02,329 --> 00:16:07,069
interface with get but this one because

00:16:05,720 --> 00:16:08,720
you can just pip install it it means

00:16:07,069 --> 00:16:10,009
folks that are on a Mac or on a Windows

00:16:08,720 --> 00:16:12,199
system they don't have to figure out how

00:16:10,009 --> 00:16:15,769
to install a ceiling in order to do the

00:16:12,199 --> 00:16:18,829
work with a Reno and using Dulwich has

00:16:15,769 --> 00:16:21,170
proved to be considerably more reliable

00:16:18,829 --> 00:16:22,759
than using the porcelain output from yes

00:16:21,170 --> 00:16:25,250
so the first version of Reno actually

00:16:22,759 --> 00:16:27,769
ran git as a command and then read the

00:16:25,250 --> 00:16:29,120
output and tried to parse it and then

00:16:27,769 --> 00:16:30,860
somewhere in there the porcelain

00:16:29,120 --> 00:16:32,389
formatting changed and we were no longer

00:16:30,860 --> 00:16:34,399
getting some of the data that we needed

00:16:32,389 --> 00:16:36,230
in order to track changes to file so we

00:16:34,399 --> 00:16:39,889
had to rewrite it using a library

00:16:36,230 --> 00:16:43,069
instead so if we look at the stable

00:16:39,889 --> 00:16:45,290
branch if we ask it to scan the history

00:16:43,069 --> 00:16:47,569
of a branch instead of asking for a

00:16:45,290 --> 00:16:50,509
specific version number we get two

00:16:47,569 --> 00:16:52,699
versions as output so using it's sort of

00:16:50,509 --> 00:16:56,120
standard version nomenclature of of

00:16:52,699 --> 00:17:00,380
tacking on a number of patches after a

00:16:56,120 --> 00:17:01,699
tag we get a 1.0 0-1 as a version and

00:17:00,380 --> 00:17:03,470
that's actually an unreleased version

00:17:01,699 --> 00:17:06,589
that represents the change that's on

00:17:03,470 --> 00:17:08,539
that branch after the tag and then a 1.0

00:17:06,589 --> 00:17:12,319
version that includes the a and the B

00:17:08,539 --> 00:17:14,329
commits so scanning a branch doesn't

00:17:12,319 --> 00:17:16,579
necessarily stop at the previous release

00:17:14,329 --> 00:17:18,799
so you can actually ask it give me the

00:17:16,579 --> 00:17:21,439
entire history of a series of releases

00:17:18,799 --> 00:17:24,199
on the on a given branch and that's

00:17:21,439 --> 00:17:26,750
useful particularly in the way that we

00:17:24,199 --> 00:17:28,669
publish releases so we name these stable

00:17:26,750 --> 00:17:30,200
branches so rocky is the current branch

00:17:28,669 --> 00:17:33,110
that we're in and they're alphabetical

00:17:30,200 --> 00:17:34,370
order so based on what the naming

00:17:33,110 --> 00:17:37,039
convention doesn't matter but they're in

00:17:34,370 --> 00:17:39,289
alphabetical order so you have a page

00:17:37,039 --> 00:17:41,059
for each project for each series and we

00:17:39,289 --> 00:17:43,250
can say show me all of the notes for

00:17:41,059 --> 00:17:44,060
that series altogether and you get all

00:17:43,250 --> 00:17:45,500
the versions that have

00:17:44,060 --> 00:17:50,960
and released all the patch updates and

00:17:45,500 --> 00:17:53,120
everything so I talked about backporting

00:17:50,960 --> 00:17:55,010
changes from one branch to another so if

00:17:53,120 --> 00:17:56,990
we take that committee and we copy it

00:17:55,010 --> 00:17:59,270
using cherry pick from the master branch

00:17:56,990 --> 00:18:01,190
onto the stable branch we get the note

00:17:59,270 --> 00:18:03,830
that goes with the code change and it

00:18:01,190 --> 00:18:05,540
ends up on that stable branch and then

00:18:03,830 --> 00:18:09,830
if we tag a new version at the end of

00:18:05,540 --> 00:18:12,790
that stable branch 10.1 meaning that

00:18:09,830 --> 00:18:15,760
it's a patch update with a bug fix in it

00:18:12,790 --> 00:18:18,290
we get the release notes willing for

00:18:15,760 --> 00:18:20,150
10.1 we'll include a copy of the note

00:18:18,290 --> 00:18:23,570
that was in the 2.0 release that's in

00:18:20,150 --> 00:18:25,130
that e.e commit and we can do that

00:18:23,570 --> 00:18:27,410
without making any changes to eat

00:18:25,130 --> 00:18:29,270
because it has a unique file name for

00:18:27,410 --> 00:18:31,190
the release note and assuming the rest

00:18:29,270 --> 00:18:33,110
of the code backports cleanly you can

00:18:31,190 --> 00:18:35,330
just back pour it and approve the patch

00:18:33,110 --> 00:18:37,490
now that doesn't always happen but we

00:18:35,330 --> 00:18:40,760
didn't want Reno to introduce as reasons

00:18:37,490 --> 00:18:43,100
to have back port problems so we we're

00:18:40,760 --> 00:18:47,000
still not a hundred percent there but

00:18:43,100 --> 00:18:49,130
we're doing the best we can and the the

00:18:47,000 --> 00:18:51,170
notes for 101 will look like this so

00:18:49,130 --> 00:18:52,820
that includes that ear Alise and then

00:18:51,170 --> 00:18:54,470
the previous commit that was there that

00:18:52,820 --> 00:19:00,020
hadn't been tagged yet so we get both

00:18:54,470 --> 00:19:02,060
notes when we publish our notes we

00:19:00,020 --> 00:19:04,640
published them from one job that happens

00:19:02,060 --> 00:19:06,800
when we tag a commit and so we actually

00:19:04,640 --> 00:19:08,540
have as I mentioned we have a different

00:19:06,800 --> 00:19:11,080
page for each release series and we

00:19:08,540 --> 00:19:13,610
publish all of that together at one time

00:19:11,080 --> 00:19:15,380
when a user reads the release notes

00:19:13,610 --> 00:19:16,640
though they don't read all of them they

00:19:15,380 --> 00:19:18,020
go and look at the version that they're

00:19:16,640 --> 00:19:19,430
installing and they want to see the

00:19:18,020 --> 00:19:22,520
release notes for that version or that

00:19:19,430 --> 00:19:24,230
series of versions and so having a note

00:19:22,520 --> 00:19:25,790
copied from one branch to another like

00:19:24,230 --> 00:19:27,440
this means that the user doesn't have to

00:19:25,790 --> 00:19:29,630
jump around and find the release notes

00:19:27,440 --> 00:19:32,330
in different places based on where the

00:19:29,630 --> 00:19:35,390
fix was originally applied and then back

00:19:32,330 --> 00:19:36,980
ported to that was a real problem for us

00:19:35,390 --> 00:19:38,210
with the wiki approach because people

00:19:36,980 --> 00:19:39,800
would back for at the code and then

00:19:38,210 --> 00:19:43,100
forget to go and copy the release note

00:19:39,800 --> 00:19:44,570
around and so the as you after the

00:19:43,100 --> 00:19:46,190
initial release on a stable branch

00:19:44,570 --> 00:19:49,970
basically the release notes were not

00:19:46,190 --> 00:19:51,860
really being updated very often in

00:19:49,970 --> 00:19:53,390
addition to doing a back port like that

00:19:51,860 --> 00:19:56,240
I mentioned that we needed to be able to

00:19:53,390 --> 00:19:57,170
change a patch change a release note in

00:19:56,240 --> 00:19:59,930
case there was a type

00:19:57,170 --> 00:20:02,240
or something like that so the way that

00:19:59,930 --> 00:20:04,400
works is you changed the release note

00:20:02,240 --> 00:20:07,610
file at any point in the history of the

00:20:04,400 --> 00:20:10,010
branch after it's been added and as reno

00:20:07,610 --> 00:20:12,380
scans through the history it finds the

00:20:10,010 --> 00:20:14,240
change first because it's starting with

00:20:12,380 --> 00:20:16,130
the newest patch in the branch and going

00:20:14,240 --> 00:20:17,930
backwards in history but it doesn't

00:20:16,130 --> 00:20:19,610
actually insert the content from the

00:20:17,930 --> 00:20:22,460
release note until it finds the add

00:20:19,610 --> 00:20:25,790
event where that file was initially

00:20:22,460 --> 00:20:27,710
created so it takes the content from the

00:20:25,790 --> 00:20:30,050
newest version of the file and inserts

00:20:27,710 --> 00:20:32,270
it at the location in the history of the

00:20:30,050 --> 00:20:34,490
original file and that lets us change

00:20:32,270 --> 00:20:36,440
the published version of the notes for

00:20:34,490 --> 00:20:39,110
an older release after that release has

00:20:36,440 --> 00:20:41,240
been cut we can't obviously change the

00:20:39,110 --> 00:20:42,590
content of the package for the 2.0

00:20:41,240 --> 00:20:43,700
release so if you're looking at the

00:20:42,590 --> 00:20:45,980
release notes that are inside the

00:20:43,700 --> 00:20:48,230
package we can't do anything about that

00:20:45,980 --> 00:20:52,790
but we can change them what we actually

00:20:48,230 --> 00:20:55,280
publish online and so this is the output

00:20:52,790 --> 00:20:56,720
for looking at the 2.0 release after

00:20:55,280 --> 00:20:58,760
that change has been applied you can see

00:20:56,720 --> 00:21:02,270
that there's no typo in the release note

00:20:58,760 --> 00:21:05,720
anymore and it's been changed outside of

00:21:02,270 --> 00:21:07,370
that it also understands that if you

00:21:05,720 --> 00:21:09,080
delete a release note file if for some

00:21:07,370 --> 00:21:11,750
reason the the note doesn't apply at all

00:21:09,080 --> 00:21:13,520
and you want to delete it when it sees

00:21:11,750 --> 00:21:16,250
that delete it basically ignores the

00:21:13,520 --> 00:21:18,920
file so it doesn't add it later so if

00:21:16,250 --> 00:21:20,210
you have a completely incorrect release

00:21:18,920 --> 00:21:22,160
note that somehow passed through all of

00:21:20,210 --> 00:21:25,310
the peer review you can just delete the

00:21:22,160 --> 00:21:26,720
whole thing and it will be ignored all

00:21:25,310 --> 00:21:30,500
right I've shown you a basic command

00:21:26,720 --> 00:21:32,660
line output for Reno it it does also

00:21:30,500 --> 00:21:34,580
integrate with Sphinx that was one of

00:21:32,660 --> 00:21:37,850
the key benefits for using restructure

00:21:34,580 --> 00:21:40,130
text so there's a sphinx directive to

00:21:37,850 --> 00:21:42,940
insert the release notes for a given

00:21:40,130 --> 00:21:45,640
series or version into the output of

00:21:42,940 --> 00:21:48,110
whatever your syncs documentation is

00:21:45,640 --> 00:21:49,970
this particular directive without any

00:21:48,110 --> 00:21:52,580
extra arguments is going to insert the

00:21:49,970 --> 00:21:53,810
full history of the current branch so

00:21:52,580 --> 00:21:55,010
that's really useful on the master

00:21:53,810 --> 00:21:56,360
branch because you basically get

00:21:55,010 --> 00:22:01,700
everything that's happening in the

00:21:56,360 --> 00:22:03,230
development series on to to publish the

00:22:01,700 --> 00:22:05,240
documentation for a stable branch you

00:22:03,230 --> 00:22:08,060
would specify that stable branch name or

00:22:05,240 --> 00:22:09,680
if you just want to have a version or a

00:22:08,060 --> 00:22:09,990
couple of versions you can include a

00:22:09,680 --> 00:22:11,580
rain

00:22:09,990 --> 00:22:13,110
a set of version numbers in there as

00:22:11,580 --> 00:22:14,970
well so it's easy to organize your

00:22:13,110 --> 00:22:17,190
published release notes in whatever way

00:22:14,970 --> 00:22:18,840
you want basically any arguments you can

00:22:17,190 --> 00:22:20,610
pass to the report command you can pass

00:22:18,840 --> 00:22:22,710
here through this Sphinx directive and

00:22:20,610 --> 00:22:24,690
then the output depending on what your

00:22:22,710 --> 00:22:25,830
styles are going to look like your CSS

00:22:24,690 --> 00:22:27,990
styles it's going to look something like

00:22:25,830 --> 00:22:29,429
this so you get version numbers inserted

00:22:27,990 --> 00:22:32,370
with headers and you get all of your

00:22:29,429 --> 00:22:34,470
sections with titles and then the

00:22:32,370 --> 00:22:37,440
release notes are inserted in order and

00:22:34,470 --> 00:22:39,840
we do maintain a consistent order so

00:22:37,440 --> 00:22:41,250
it's not necessarily predictable as

00:22:39,840 --> 00:22:42,809
you're writing the release notes but

00:22:41,250 --> 00:22:45,480
we're going to insert them in the order

00:22:42,809 --> 00:22:47,460
that I think it's sorted based on those

00:22:45,480 --> 00:22:48,780
unique IDs so that it's consistent so

00:22:47,460 --> 00:22:50,370
that if you publish a new version you

00:22:48,780 --> 00:22:53,720
don't suddenly scramble all of your

00:22:50,370 --> 00:22:53,720
release notes into a different order

00:22:53,990 --> 00:22:58,770
right so that's the tool the effect that

00:22:57,240 --> 00:23:00,900
had on the community was pretty

00:22:58,770 --> 00:23:03,840
impressive even beyond what we had

00:23:00,900 --> 00:23:05,790
anticipated so we've definitely

00:23:03,840 --> 00:23:08,100
increased the quantity of release notes

00:23:05,790 --> 00:23:10,470
that we're writing we are at something

00:23:08,100 --> 00:23:12,270
like 13,000 notes for those 300

00:23:10,470 --> 00:23:15,720
different projects now which is far more

00:23:12,270 --> 00:23:18,929
than we had even you know relative to

00:23:15,720 --> 00:23:20,670
this six projects at the beginning more

00:23:18,929 --> 00:23:24,179
importantly though we're changing the

00:23:20,670 --> 00:23:25,920
culture so in addition to encouraging

00:23:24,179 --> 00:23:27,960
people to write release that some of the

00:23:25,920 --> 00:23:29,730
teams are actually requiring that new

00:23:27,960 --> 00:23:31,380
features come with release notes new

00:23:29,730 --> 00:23:33,809
configuration options come with release

00:23:31,380 --> 00:23:35,700
notes less so for bug fixes unless

00:23:33,809 --> 00:23:39,929
there's a significant upgrade impact or

00:23:35,700 --> 00:23:41,940
something like that but that's not a

00:23:39,929 --> 00:23:43,830
pervasive thing throughout the community

00:23:41,940 --> 00:23:46,380
it's a few of the teams that are a

00:23:43,830 --> 00:23:47,880
little more a little more interested in

00:23:46,380 --> 00:23:49,429
have a little more impact in this sort

00:23:47,880 --> 00:23:53,429
of thing that a release note would in

00:23:49,429 --> 00:23:55,110
document and I consider that a win for

00:23:53,429 --> 00:23:56,880
my own laziness because I don't have to

00:23:55,110 --> 00:23:58,620
deal with release notes at all at this

00:23:56,880 --> 00:23:59,880
point it's basically every once in a

00:23:58,620 --> 00:24:01,440
while there's a bug report against the

00:23:59,880 --> 00:24:03,170
tool and I go work on that but I don't

00:24:01,440 --> 00:24:05,910
have to do with the actual documentation

00:24:03,170 --> 00:24:09,059
so if you're interested in trying Reno

00:24:05,910 --> 00:24:11,520
out we would love to hear from you it is

00:24:09,059 --> 00:24:13,410
set up by default to work using the

00:24:11,520 --> 00:24:15,240
OpenStack naming conventions and version

00:24:13,410 --> 00:24:17,460
conventions and patterns and that sort

00:24:15,240 --> 00:24:19,670
of thing but it's very configurable I

00:24:17,460 --> 00:24:21,590
think almost everything that would be

00:24:19,670 --> 00:24:24,170
a useful behavior has a configuration

00:24:21,590 --> 00:24:26,030
option now but if it's not then we're

00:24:24,170 --> 00:24:29,030
interested in making it more usable for

00:24:26,030 --> 00:24:30,890
more projects if you're not interested

00:24:29,030 --> 00:24:32,390
in Reno I'm still interested in having

00:24:30,890 --> 00:24:33,740
you write better release notes and

00:24:32,390 --> 00:24:34,970
actually write release notes so you

00:24:33,740 --> 00:24:37,760
might be interested in looking at a

00:24:34,970 --> 00:24:39,500
couple of other tools town-crier is a

00:24:37,760 --> 00:24:41,180
tool out of the twisted community which

00:24:39,500 --> 00:24:43,610
I didn't know about at the time that we

00:24:41,180 --> 00:24:46,070
built Reno but I believe it has the

00:24:43,610 --> 00:24:47,780
problem of requiring you to know either

00:24:46,070 --> 00:24:49,880
know in advance the version numbers or

00:24:47,780 --> 00:24:51,290
do something at the release point to

00:24:49,880 --> 00:24:53,000
deal with version numbers and so we

00:24:51,290 --> 00:24:55,490
wouldn't have met our needs anyway but

00:24:53,000 --> 00:24:57,170
it's still a good tool and then blurb is

00:24:55,490 --> 00:24:59,270
a tool that Larry Hastings wrote for the

00:24:57,170 --> 00:25:00,710
Python dev community and it has a

00:24:59,270 --> 00:25:03,020
similar sort of problem and both of

00:25:00,710 --> 00:25:04,400
those teams are releasing one thing and

00:25:03,020 --> 00:25:05,840
so it's not really a big deal for their

00:25:04,400 --> 00:25:07,640
release managers to take a little bit of

00:25:05,840 --> 00:25:09,800
action at the point of the release but

00:25:07,640 --> 00:25:11,420
for us with the scale of the number of

00:25:09,800 --> 00:25:13,970
things we're touching we didn't want to

00:25:11,420 --> 00:25:18,560
have to deal with any of those kinds of

00:25:13,970 --> 00:25:20,990
manual steps the documentation for Reno

00:25:18,560 --> 00:25:24,050
is on the open stacks website so doxed

00:25:20,990 --> 00:25:26,030
open stack dot org slash Reno and this

00:25:24,050 --> 00:25:28,460
sample repository that I used for this

00:25:26,030 --> 00:25:29,720
presentation is on my github account if

00:25:28,460 --> 00:25:31,450
you want to play with that and I'll be

00:25:29,720 --> 00:25:34,610
posting the slides from the presentation

00:25:31,450 --> 00:25:37,340
online as part of the conference website

00:25:34,610 --> 00:25:39,720
and that's all I have so if anybody has

00:25:37,340 --> 00:25:39,860
any questions I'd be happy to talk

00:25:39,720 --> 00:25:42,730
[Applause]

00:25:39,860 --> 00:25:48,869
[Music]

00:25:42,730 --> 00:25:48,869
[Applause]

00:25:49,180 --> 00:25:58,400
if anybody has any questions please

00:25:51,920 --> 00:26:01,520
raise end thank you for this

00:25:58,400 --> 00:26:04,240
presentation just a good question if I

00:26:01,520 --> 00:26:06,620
understand for now it's only on for kids

00:26:04,240 --> 00:26:10,160
but do you have any plan for any other

00:26:06,620 --> 00:26:14,570
VCS and second part of the question

00:26:10,160 --> 00:26:17,930
would it be easy to contribute and well

00:26:14,570 --> 00:26:20,080
for all the VCS is it just like coal box

00:26:17,930 --> 00:26:23,930
press settings always it like really

00:26:20,080 --> 00:26:26,030
forking the whole stuff yeah so I had

00:26:23,930 --> 00:26:27,890
not seriously considered other version

00:26:26,030 --> 00:26:30,110
control tools yet but I'm interested in

00:26:27,890 --> 00:26:34,460
talking to you about what it which one

00:26:30,110 --> 00:26:36,830
in particular are you interested in okay

00:26:34,460 --> 00:26:40,070
I don't know anything about that

00:26:36,830 --> 00:26:43,280
so you'd be up to you to do that I could

00:26:40,070 --> 00:26:45,620
I could help you there is I think a

00:26:43,280 --> 00:26:47,600
point at which we could add some some

00:26:45,620 --> 00:26:49,430
logic that would let you switch back and

00:26:47,600 --> 00:26:51,830
forth between those two things in the

00:26:49,430 --> 00:26:53,510
scanner in particular I don't know

00:26:51,830 --> 00:26:56,300
whether perforce is data model as

00:26:53,510 --> 00:26:58,340
similar to Gibbs it really relies on

00:26:56,300 --> 00:27:01,520
being able to walk through the history

00:26:58,340 --> 00:27:03,340
and see the topological sort of the

00:27:01,520 --> 00:27:05,630
commits and and that sort of thing so

00:27:03,340 --> 00:27:07,700
but but yeah I'd be happy to talk to you

00:27:05,630 --> 00:27:10,010
after about some of the details for that

00:27:07,700 --> 00:27:11,200
that would be interesting sure okay next

00:27:10,010 --> 00:27:15,010
question please

00:27:11,200 --> 00:27:19,430
basically the same but for me curio

00:27:15,010 --> 00:27:21,500
basically the same answer yeah okay it

00:27:19,430 --> 00:27:23,180
might be easier for mercurial because I

00:27:21,500 --> 00:27:26,600
think the data model is closer there

00:27:23,180 --> 00:27:29,390
yeah I'm I didn't quite understand how

00:27:26,600 --> 00:27:31,370
it knew when to stop going back in

00:27:29,390 --> 00:27:35,390
history so you gave an example where you

00:27:31,370 --> 00:27:37,700
ran it on rocky yes and it went back and

00:27:35,390 --> 00:27:40,850
then got mb which were from master yes

00:27:37,700 --> 00:27:42,830
how did it not go back to for example

00:27:40,850 --> 00:27:45,380
the commits that came before Queen's or

00:27:42,830 --> 00:27:46,610
something previous like sure yeah what

00:27:45,380 --> 00:27:49,790
what's the termination condition

00:27:46,610 --> 00:27:51,020
basically okay so I very drastically

00:27:49,790 --> 00:27:55,160
simplified the example in the

00:27:51,020 --> 00:27:57,350
presentation so the OpenStack we're on

00:27:55,160 --> 00:27:59,550
the rocky release cycle right now that

00:27:57,350 --> 00:28:02,130
means we have branches all the way

00:27:59,550 --> 00:28:05,490
through a potentially for some projects

00:28:02,130 --> 00:28:08,100
and it does a little bit of work to

00:28:05,490 --> 00:28:10,380
figure out where the previous stable

00:28:08,100 --> 00:28:13,880
branch came from and it stops before it

00:28:10,380 --> 00:28:16,440
gets to that point so that's not really

00:28:13,880 --> 00:28:20,130
it's very difficult to represent that in

00:28:16,440 --> 00:28:22,560
a slide and the hand waving is probably

00:28:20,130 --> 00:28:24,120
indicative of that but yeah it does have

00:28:22,560 --> 00:28:26,460
some smarts for doing that and that's

00:28:24,120 --> 00:28:28,190
you can turn that off so projects that

00:28:26,460 --> 00:28:31,590
don't have that kind of stable branch

00:28:28,190 --> 00:28:34,260
structure could basically ignore that

00:28:31,590 --> 00:28:36,860
feature and disable that but yeah okay

00:28:34,260 --> 00:28:39,720
we have time for one more final question

00:28:36,860 --> 00:28:41,220
thank you for the talking I understand

00:28:39,720 --> 00:28:43,680
that individual release notes are

00:28:41,220 --> 00:28:45,330
committed also to master so my question

00:28:43,680 --> 00:28:47,730
is how do you if you if you make a

00:28:45,330 --> 00:28:50,240
mistake in your release now how do you

00:28:47,730 --> 00:28:54,420
commit without force pushing to master

00:28:50,240 --> 00:28:57,060
yeah so you we don't do any force

00:28:54,420 --> 00:29:00,000
pushing ever all the changes are

00:28:57,060 --> 00:29:02,460
iterative so you apply another patch on

00:29:00,000 --> 00:29:04,650
top and then Reno as its scanning that

00:29:02,460 --> 00:29:06,900
history is sees a change to a file

00:29:04,650 --> 00:29:08,490
because it's scanning backwards in

00:29:06,900 --> 00:29:10,770
history it'll see the change before it

00:29:08,490 --> 00:29:12,300
sees the add so it'll hold on to the

00:29:10,770 --> 00:29:14,370
contents from the patch where you've

00:29:12,300 --> 00:29:17,130
changed it and when it gets to the point

00:29:14,370 --> 00:29:19,530
where you've added the file six months

00:29:17,130 --> 00:29:21,210
ago or a year ago or whatever then it

00:29:19,530 --> 00:29:24,270
will insert the note at that point in

00:29:21,210 --> 00:29:26,220
the history using the newer contents and

00:29:24,270 --> 00:29:28,470
it can do that because it's not reading

00:29:26,220 --> 00:29:30,270
the files that you commit off the file

00:29:28,470 --> 00:29:33,180
system it's reading them out of the get

00:29:30,270 --> 00:29:35,460
objects in the get history if that makes

00:29:33,180 --> 00:29:37,620
sense okay thank you very much for

00:29:35,460 --> 00:29:39,210
presentation let's have a round of

00:29:37,620 --> 00:29:40,860
applause for that thank you all very

00:29:39,210 --> 00:29:42,060
much for coming

00:29:40,860 --> 00:29:44,120
[Music]

00:29:42,060 --> 00:29:44,120

YouTube URL: https://www.youtube.com/watch?v=tEOGJ_h0Lx0


