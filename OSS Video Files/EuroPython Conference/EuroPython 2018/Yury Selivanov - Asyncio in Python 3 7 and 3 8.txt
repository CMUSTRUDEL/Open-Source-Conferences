Title: Yury Selivanov - Asyncio in Python 3 7 and 3 8
Publication date: 2018-08-22
Playlist: EuroPython 2018
Description: 
	Asyncio in Python 3.7 and 3.8.
[EuroPython 2018 - Talk - 2018-07-25 - Moorfoot]
[Edinburgh, UK]

By Yury Selivanov

The talk is aimed to give attendees a clear picture of new asyncio features in Python 3.7 and give an idea of what to expect in Python 3.8.  As a CPython core developer and the lead asyncio maintainer I believe I have a unique perspective to share with EuroPython guests.

Python 3.7 boasts a number of new amazing features: 


sendfile
start TLS
new high performance buffered protocols
context-local state via PEP 567
asyncio.run &amp; create_task &amp; other usability improvements
many performance improvements


The first part of the talk will be focusing on new APIs to explain them and give ideas how they can be used in production.

The second part of the talk will be focused on what to expect to see in asyncio in Python 3.8:


new performance tracking &amp; profiling API
supervisors &amp; cancel scopes
new timeouts API
a completely new way of writing asyncio applications


Some of these ideas are borrowed from Trio and Curio (two other popular async/await Python frameworks), many are borrowed from languages like Erlang and Scala. One thing I can say for certain is that 3.8 will be the biggest and most interesting asyncio release ever!



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2018.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:03,520 --> 00:00:09,469
okay guys guys will flood start so today

00:00:07,040 --> 00:00:11,450
we're gonna talk about Asian girl today

00:00:09,469 --> 00:00:14,120
and what might happen to tomorrow my

00:00:11,450 --> 00:00:15,950
name is Yuri Yuri selivanov I've been a

00:00:14,120 --> 00:00:17,990
core developer for about five years and

00:00:15,950 --> 00:00:20,119
during these five years I've been lucky

00:00:17,990 --> 00:00:22,099
enough to work in some some pretty

00:00:20,119 --> 00:00:25,489
interesting stuff and in Python that

00:00:22,099 --> 00:00:27,289
that includes the async/await syntax

00:00:25,489 --> 00:00:30,069
asynchronous generator is asynchronous

00:00:27,289 --> 00:00:34,059
comprehensions lately context variables

00:00:30,069 --> 00:00:36,920
I'm the lead maintainer of async i/o

00:00:34,059 --> 00:00:39,199
created develop library a while ago

00:00:36,920 --> 00:00:42,440
which is an alternative event loop

00:00:39,199 --> 00:00:45,620
implementation tracing kayo like it's

00:00:42,440 --> 00:00:47,719
used pretty pretty wild in a lot of lot

00:00:45,620 --> 00:00:50,210
of big companies used in production I

00:00:47,719 --> 00:00:52,429
co-created the async AG library with

00:00:50,210 --> 00:00:55,129
Elias who is also here today

00:00:52,429 --> 00:00:58,249
that's an asynchronous path berries Paz

00:00:55,129 --> 00:01:01,010
grayscale driver and I work on HDB which

00:00:58,249 --> 00:01:04,370
is an object relational database it's a

00:01:01,010 --> 00:01:05,810
new thing I unfortunately I won't be

00:01:04,370 --> 00:01:07,520
able to talk about it you'd be doing

00:01:05,810 --> 00:01:09,950
this this talk but if you have any

00:01:07,520 --> 00:01:11,630
questions after the talk I'll be happy

00:01:09,950 --> 00:01:13,310
to answer them and even of course you

00:01:11,630 --> 00:01:18,680
can follow me on Twitter and github my

00:01:13,310 --> 00:01:21,920
nickname there is one st1 so before we

00:01:18,680 --> 00:01:24,620
get to the meat of the talk let's I was

00:01:21,920 --> 00:01:27,800
briefly discuss how a thinker was born

00:01:24,620 --> 00:01:30,380
its history because it explains some of

00:01:27,800 --> 00:01:33,800
the idiosyncratic idiosyncrasies that it

00:01:30,380 --> 00:01:36,950
has in his design so we just started to

00:01:33,800 --> 00:01:38,780
work on async async' i/o around Python

00:01:36,950 --> 00:01:41,390
3.3 we just learned that yield from

00:01:38,780 --> 00:01:44,930
syntax and partly we actually landed at

00:01:41,390 --> 00:01:46,850
four for something like async i/o so we

00:01:44,930 --> 00:01:49,580
that was working on anything come on

00:01:46,850 --> 00:01:51,800
some asynchronous stuff back when he was

00:01:49,580 --> 00:01:54,910
working on Google and back then we

00:01:51,800 --> 00:01:58,310
actually had two different approaches to

00:01:54,910 --> 00:02:00,770
two asynchronous concurrent code in

00:01:58,310 --> 00:02:03,980
vitam that was green LEDs and stackless

00:02:00,770 --> 00:02:08,750
python and the those frameworks still

00:02:03,980 --> 00:02:12,640
exists that's she went to vamp lab and

00:02:08,750 --> 00:02:16,320
also libraries like twisted and tornado

00:02:12,640 --> 00:02:21,010
which were pretty popular with more

00:02:16,320 --> 00:02:23,290
but-but-but these days and they also

00:02:21,010 --> 00:02:25,300
influenced async i/o pretty pretty

00:02:23,290 --> 00:02:26,470
pretty significant time a pretty

00:02:25,300 --> 00:02:28,270
significant way

00:02:26,470 --> 00:02:30,490
for instance transfers and protocols and

00:02:28,270 --> 00:02:32,800
callbacks day they kind of all came from

00:02:30,490 --> 00:02:35,530
twister but it was obvious that we don't

00:02:32,800 --> 00:02:38,770
really want to move don't really want to

00:02:35,530 --> 00:02:40,420
choose the G went way of doing things we

00:02:38,770 --> 00:02:44,980
want we want we wanted things to be

00:02:40,420 --> 00:02:48,459
explicit so in Python 3.4 async i/o our

00:02:44,980 --> 00:02:52,630
lanced to python and become becomes part

00:02:48,459 --> 00:02:54,220
of part of the standard library it was

00:02:52,630 --> 00:02:57,640
not provisional and what what what that

00:02:54,220 --> 00:03:00,880
meant is that we could actually push new

00:02:57,640 --> 00:03:03,070
features and new things to async i/o in

00:03:00,880 --> 00:03:06,040
bug-fix releases new api so we could

00:03:03,070 --> 00:03:10,180
even break things but we didn't really

00:03:06,040 --> 00:03:12,910
do that I think I was focused on mostly

00:03:10,180 --> 00:03:14,650
low-level API so we recreated a lot of

00:03:12,910 --> 00:03:17,020
stuff from twisted we've had protocols

00:03:14,650 --> 00:03:19,450
and transports futures which are

00:03:17,020 --> 00:03:22,660
basically differed with the difference

00:03:19,450 --> 00:03:25,900
with some modifications and it also had

00:03:22,660 --> 00:03:30,730
four routines by the yield from syntax

00:03:25,900 --> 00:03:33,280
and was also a novel idea back then of

00:03:30,730 --> 00:03:34,930
course it had some high-level api's like

00:03:33,280 --> 00:03:37,120
streams and sub processes that were

00:03:34,930 --> 00:03:39,970
supposed to work with youth from

00:03:37,120 --> 00:03:42,640
Cortines but because the that that was

00:03:39,970 --> 00:03:46,630
kind of a new thing I some some of those

00:03:42,640 --> 00:03:49,690
API is very very perfect in fact I'm 35

00:03:46,630 --> 00:03:52,180
we got the async of weights index and

00:03:49,690 --> 00:03:53,680
that was I guess first public

00:03:52,180 --> 00:03:55,540
acknowledgement that asynchronous

00:03:53,680 --> 00:03:58,299
programming can be a first-class feature

00:03:55,540 --> 00:04:00,880
in Python a sinker was too provisional

00:03:58,299 --> 00:04:03,540
so we were trying to evolve with them

00:04:00,880 --> 00:04:06,430
even in black fixes bug-fix releases

00:04:03,540 --> 00:04:08,380
they received a bunch of new API eyes

00:04:06,430 --> 00:04:11,140
but nothing nothing significant nothing

00:04:08,380 --> 00:04:12,610
that stands out but then I created you

00:04:11,140 --> 00:04:14,610
you loop another was also pretty

00:04:12,610 --> 00:04:17,229
interesting because it was example of a

00:04:14,610 --> 00:04:20,019
first example of a library that kind

00:04:17,229 --> 00:04:22,990
allows you to swap the the standard

00:04:20,019 --> 00:04:24,460
event loop with with third party event

00:04:22,990 --> 00:04:25,780
of implementation completely and

00:04:24,460 --> 00:04:26,910
everything just continued to work

00:04:25,780 --> 00:04:29,590
magically

00:04:26,910 --> 00:04:31,840
back then also there would be the critic

00:04:29,590 --> 00:04:34,900
urea which was a pretty interesting

00:04:31,840 --> 00:04:36,580
moment because he he decided that we

00:04:34,900 --> 00:04:38,320
don't really need transport with

00:04:36,580 --> 00:04:40,270
transfers we don't really need protocols

00:04:38,320 --> 00:04:42,700
and callbacks and that you can basically

00:04:40,270 --> 00:04:45,190
write problems just with async await

00:04:42,700 --> 00:04:48,610
without all that all that craft and

00:04:45,190 --> 00:04:52,150
first the idea kinda seemed ridiculous

00:04:48,610 --> 00:04:54,310
to a lot of us but then we realized that

00:04:52,150 --> 00:04:56,710
yes he is right it's actually perfectly

00:04:54,310 --> 00:04:58,840
reasonable and perfectly possible to

00:04:56,710 --> 00:05:01,210
write programs with async await them

00:04:58,840 --> 00:05:03,460
what's more important is that those

00:05:01,210 --> 00:05:06,160
programs are easier to read and easier

00:05:03,460 --> 00:05:07,870
to maintain so we're looking at Curia

00:05:06,160 --> 00:05:09,580
and thinking what kind of features we

00:05:07,870 --> 00:05:14,140
can we can actually steal from it and

00:05:09,580 --> 00:05:15,669
kind of pour to async IO why people like

00:05:14,140 --> 00:05:19,390
us so much

00:05:15,669 --> 00:05:21,520
so both me Twitter and other core core

00:05:19,390 --> 00:05:23,979
developers work and paying attention so

00:05:21,520 --> 00:05:25,750
in Python three six async I stopped

00:05:23,979 --> 00:05:29,620
being provisional that that means that

00:05:25,750 --> 00:05:31,780
the evolution cycle for it got longer we

00:05:29,620 --> 00:05:33,880
have to wait for a major release

00:05:31,780 --> 00:05:35,560
we got a synchronous generators and the

00:05:33,880 --> 00:05:39,880
asynchronous comprehensions lands in

00:05:35,560 --> 00:05:42,130
Python and also fixed get event loop

00:05:39,880 --> 00:05:45,850
function and that that basically thanks

00:05:42,130 --> 00:05:47,860
to curio because before before Python

00:05:45,850 --> 00:05:50,919
three six gather and hook was really

00:05:47,860 --> 00:05:54,130
really weird it could return a new event

00:05:50,919 --> 00:05:55,930
loop a random event loop was basically

00:05:54,130 --> 00:05:58,660
completely unpredictable it all depended

00:05:55,930 --> 00:06:00,580
on the current policy and even the

00:05:58,660 --> 00:06:03,280
default policy nation had some weird

00:06:00,580 --> 00:06:05,680
bugs in it so it couldn't really use

00:06:03,280 --> 00:06:09,000
this this function to get the currently

00:06:05,680 --> 00:06:12,400
running event loop reliably and that

00:06:09,000 --> 00:06:14,500
that in part kinda created the spot in

00:06:12,400 --> 00:06:16,870
the nation value that you had to care

00:06:14,500 --> 00:06:19,240
about the event you have to use even

00:06:16,870 --> 00:06:21,520
even when you used async await you kind

00:06:19,240 --> 00:06:24,400
of always passed around the the event

00:06:21,520 --> 00:06:27,340
look to all libraries like a HTTP so

00:06:24,400 --> 00:06:29,569
once we fixed the this function and we

00:06:27,340 --> 00:06:32,330
fix that in in

00:06:29,569 --> 00:06:34,250
in such a way that it always returned

00:06:32,330 --> 00:06:36,020
the currently running event loop if you

00:06:34,250 --> 00:06:37,910
call this function from accordion

00:06:36,020 --> 00:06:39,470
beginners when he called from accordion

00:06:37,910 --> 00:06:42,020
there is only one event loop that

00:06:39,470 --> 00:06:45,169
currently runs coercion so it's pretty

00:06:42,020 --> 00:06:47,150
pretty well determined once we fixed

00:06:45,169 --> 00:06:49,520
that we kind of started to tell people

00:06:47,150 --> 00:06:51,410
well don't actually passive and loop

00:06:49,520 --> 00:06:54,169
around in the async/await applications

00:06:51,410 --> 00:06:56,630
just just you just don't need that just

00:06:54,169 --> 00:06:58,819
just use this function because all other

00:06:56,630 --> 00:07:01,490
libraries an API is used that function

00:06:58,819 --> 00:07:04,130
anyways it's all kind of just just

00:07:01,490 --> 00:07:06,650
started to work as expected correctly we

00:07:04,130 --> 00:07:09,500
added a bunch of low-level API stories

00:07:06,650 --> 00:07:13,039
in Keio of course in the 36 but again

00:07:09,500 --> 00:07:16,909
nothing significant and I was another

00:07:13,039 --> 00:07:18,830
interesting point but then Nathaniel

00:07:16,909 --> 00:07:20,810
Smith created this live it's called Treo

00:07:18,830 --> 00:07:23,870
and just like Curia was developed

00:07:20,810 --> 00:07:26,750
basically from scratch it's also only

00:07:23,870 --> 00:07:29,690
eighteen and a wait library it doesn't

00:07:26,750 --> 00:07:32,150
have any call backs or protocols but

00:07:29,690 --> 00:07:35,360
Nathaniel kind of focused more on

00:07:32,150 --> 00:07:38,030
usability on predictability of curation

00:07:35,360 --> 00:07:41,120
so it cold and we'll actually talk about

00:07:38,030 --> 00:07:43,000
a little bit later and Python 37 which

00:07:41,120 --> 00:07:46,490
is basically a couple of months old now

00:07:43,000 --> 00:07:48,740
the headline feature for async is

00:07:46,490 --> 00:07:49,400
context virus and also covered a little

00:07:48,740 --> 00:07:52,880
bit later

00:07:49,400 --> 00:07:55,849
it also converted async iOS own code to

00:07:52,880 --> 00:07:57,860
async await so if you look at async i

00:07:55,849 --> 00:08:00,229
outsource code in Python 37 you will see

00:07:57,860 --> 00:08:03,710
that it uses async available slightly

00:08:00,229 --> 00:08:05,840
more readable and modern and we finally

00:08:03,710 --> 00:08:09,020
learned that the async I run function

00:08:05,840 --> 00:08:11,090
and again I first thought about that

00:08:09,020 --> 00:08:12,710
function when I when I saw curio and

00:08:11,090 --> 00:08:15,169
wanted to actually land this function in

00:08:12,710 --> 00:08:17,120
taste xx but didn't have time to

00:08:15,169 --> 00:08:22,400
properly do that before the feature

00:08:17,120 --> 00:08:24,680
freeze period and very few other

00:08:22,400 --> 00:08:26,240
interesting API is that we added in

00:08:24,680 --> 00:08:28,849
three cell and actually a lot of them

00:08:26,240 --> 00:08:32,860
just to highlight caillette if you we

00:08:28,849 --> 00:08:35,779
now have a sound file so you can you can

00:08:32,860 --> 00:08:41,000
send files in an optimized we're using

00:08:35,779 --> 00:08:43,250
the OS and file system call

00:08:41,000 --> 00:08:45,860
on pretty much any transportation kayo

00:08:43,250 --> 00:08:48,740
you can upgrade transports from an

00:08:45,860 --> 00:08:52,189
unencrypted connection to a TLS

00:08:48,740 --> 00:08:54,050
connection a few high level and top

00:08:52,189 --> 00:08:56,300
level functions like create tasks and

00:08:54,050 --> 00:08:58,069
get running loop and buffered protocol

00:08:56,300 --> 00:09:00,620
which is a super low level API but

00:08:58,069 --> 00:09:03,800
essentially some protocols that involve

00:09:00,620 --> 00:09:06,829
a lot of hoping or just basically pass

00:09:03,800 --> 00:09:08,060
through the day with Buffett protocol

00:09:06,829 --> 00:09:10,879
you have a very tight control over

00:09:08,060 --> 00:09:12,949
buffers in connect you can avoid extract

00:09:10,879 --> 00:09:15,649
cookies and that can lead to some pretty

00:09:12,949 --> 00:09:17,540
significant performance improvements so

00:09:15,649 --> 00:09:20,810
now let's talk about async up wait and

00:09:17,540 --> 00:09:22,459
then in modern Asian kayo and a lot of

00:09:20,810 --> 00:09:25,779
people think that they think is pretty

00:09:22,459 --> 00:09:29,149
complex and of course they are right but

00:09:25,779 --> 00:09:32,750
one problem with async I with current

00:09:29,149 --> 00:09:36,319
async is that we we explain it wrong and

00:09:32,750 --> 00:09:38,660
how we should explain is in tourism it

00:09:36,319 --> 00:09:42,589
basically has two levels one is normal

00:09:38,660 --> 00:09:45,199
high level of async error and then whose

00:09:42,589 --> 00:09:47,809
functions like run gather create tasks

00:09:45,199 --> 00:09:49,699
leap streams API sub processes API logs

00:09:47,809 --> 00:09:51,920
all those primitives that he can use

00:09:49,699 --> 00:09:54,819
from async away and then it has a hard

00:09:51,920 --> 00:09:58,160
core layer that's basically for people

00:09:54,819 --> 00:10:01,670
who write framers who write libraries

00:09:58,160 --> 00:10:03,709
low-level details interface with C code

00:10:01,670 --> 00:10:06,019
and that's pretty much all of the

00:10:03,709 --> 00:10:07,970
internals of Asian guy or protocol

00:10:06,019 --> 00:10:12,050
transfers all methods on event opened

00:10:07,970 --> 00:10:14,269
even event loop itself a single futures

00:10:12,050 --> 00:10:17,240
basically you don't really need to know

00:10:14,269 --> 00:10:20,990
about them to program with modern Asian

00:10:17,240 --> 00:10:22,610
Rio if you if you are creating an HTTP

00:10:20,990 --> 00:10:24,529
application let's say it really don't

00:10:22,610 --> 00:10:26,990
need to bother with event we just use

00:10:24,529 --> 00:10:28,730
async await them at this at this point

00:10:26,990 --> 00:10:30,819
of time your application will kind of

00:10:28,730 --> 00:10:33,769
look like a three or curious location

00:10:30,819 --> 00:10:36,500
because you don't you just don't use

00:10:33,769 --> 00:10:38,209
those slow overall api's it's quickly

00:10:36,500 --> 00:10:41,959
about eating kind of run this was the

00:10:38,209 --> 00:10:43,309
popular pattern to run an async i/o

00:10:41,959 --> 00:10:45,920
application you basically had some

00:10:43,309 --> 00:10:47,959
continued importation curve and then you

00:10:45,920 --> 00:10:50,569
had you had to do this weird dance you

00:10:47,959 --> 00:10:52,339
have to get the current or creating new

00:10:50,569 --> 00:10:53,210
event who will get event loop function

00:10:52,339 --> 00:10:56,090
you

00:10:53,210 --> 00:10:58,040
- Raju wanted to run this court in with

00:10:56,090 --> 00:11:00,200
this run until complete method and then

00:10:58,040 --> 00:11:02,660
you closed the event the problem with

00:11:00,200 --> 00:11:04,820
this code isn't just that it's long and

00:11:02,660 --> 00:11:07,550
it's hard to type it's that it's also

00:11:04,820 --> 00:11:10,790
incorrect because when you when you type

00:11:07,550 --> 00:11:13,820
look close it doesn't really close or

00:11:10,790 --> 00:11:16,100
cancel currently active asynchronous

00:11:13,820 --> 00:11:18,320
tasks background asynchronous tasks and

00:11:16,100 --> 00:11:20,750
if you have a synchronous generators in

00:11:18,320 --> 00:11:22,550
your code those won't be cancelled as

00:11:20,750 --> 00:11:24,530
well as well and that's pretty important

00:11:22,550 --> 00:11:26,750
because those a synchronous generators

00:11:24,530 --> 00:11:29,240
they might have like a lot of logic in

00:11:26,750 --> 00:11:31,130
them they might have a try final

00:11:29,240 --> 00:11:33,140
statement you actually want this code to

00:11:31,130 --> 00:11:36,770
run but if you just close the loop

00:11:33,140 --> 00:11:38,810
nothing will happen so starting with

00:11:36,770 --> 00:11:40,250
Python 37 that's how that's how you

00:11:38,810 --> 00:11:42,560
would run your program and that's that's

00:11:40,250 --> 00:11:44,960
the recommended way to run an Asian guy

00:11:42,560 --> 00:11:47,410
program you just use the async around

00:11:44,960 --> 00:11:49,760
function and a single run isn't isn't

00:11:47,410 --> 00:11:52,340
isn't isn't a simple function that

00:11:49,760 --> 00:11:53,840
that's basically something that's

00:11:52,340 --> 00:11:55,490
basically the source code of async

00:11:53,840 --> 00:11:57,470
around without some extra checks and

00:11:55,490 --> 00:12:00,860
comma C you don't need to read it it's

00:11:57,470 --> 00:12:03,530
only here to together show that a lot of

00:12:00,860 --> 00:12:05,570
stuff is actually happening in in async

00:12:03,530 --> 00:12:07,880
around it's really hard to get all the

00:12:05,570 --> 00:12:11,240
details right to write this function so

00:12:07,880 --> 00:12:13,220
just use it ideally your async await

00:12:11,240 --> 00:12:16,940
program should have just one coroutine

00:12:13,220 --> 00:12:18,770
in which you initialize your program and

00:12:16,940 --> 00:12:22,760
you run that co-written with async I run

00:12:18,770 --> 00:12:24,410
just don't don't use those loop loop run

00:12:22,760 --> 00:12:26,840
until complete and round forever method

00:12:24,410 --> 00:12:30,290
there is there are no longer necessary

00:12:26,840 --> 00:12:32,660
basically and try to use async await for

00:12:30,290 --> 00:12:34,940
everything you you shouldn't really try

00:12:32,660 --> 00:12:37,460
to use the low-level API so I cannot

00:12:34,940 --> 00:12:39,740
really stress this let's point now few

00:12:37,460 --> 00:12:42,800
at this point of time you really don't

00:12:39,740 --> 00:12:45,380
need to know about futures and and

00:12:42,800 --> 00:12:47,030
callbacks just use a zero we don't pass

00:12:45,380 --> 00:12:49,640
a reference to the currently running

00:12:47,030 --> 00:12:51,530
event rule to any kind of libraries they

00:12:49,640 --> 00:12:54,890
will be able to get it reliably without

00:12:51,530 --> 00:12:57,410
your help so when we were working on

00:12:54,890 --> 00:12:59,090
async I'll run function there was

00:12:57,410 --> 00:13:00,860
another platter in the nation carrier

00:12:59,090 --> 00:13:01,430
and that's basically around the run

00:13:00,860 --> 00:13:04,040
forever

00:13:01,430 --> 00:13:05,780
function and servers so when you create

00:13:04,040 --> 00:13:06,860
a server you won't you kind of want to

00:13:05,780 --> 00:13:09,110
create it and

00:13:06,860 --> 00:13:11,060
accept incoming connections and you

00:13:09,110 --> 00:13:13,760
won't even look to just front us forever

00:13:11,060 --> 00:13:15,710
just execute and this is this is an

00:13:13,760 --> 00:13:17,660
example an actual example from Python

00:13:15,710 --> 00:13:20,990
documentation how you would run it and

00:13:17,660 --> 00:13:23,510
you see a lot of low-level code and it's

00:13:20,990 --> 00:13:26,180
really hard to get a sense of what what

00:13:23,510 --> 00:13:29,830
this code is doing so in fighting 3/7 we

00:13:26,180 --> 00:13:34,880
had a few of you more AP is the server

00:13:29,830 --> 00:13:37,100
now servers are asynchronous context

00:13:34,880 --> 00:13:40,430
managers so when when when they exit the

00:13:37,100 --> 00:13:41,990
context they are properly closed and we

00:13:40,430 --> 00:13:43,940
also have this earth forever matter

00:13:41,990 --> 00:13:46,130
which you can which you can just use

00:13:43,940 --> 00:13:48,290
inside that statement and you can use 18

00:13:46,130 --> 00:13:50,420
curve rod so what we have here is

00:13:48,290 --> 00:13:54,710
essentially the same code equivalent

00:13:50,420 --> 00:13:57,140
code but it's twice as short and it's

00:13:54,710 --> 00:13:59,720
actually more correct now we have this

00:13:57,140 --> 00:14:03,170
function and it's it's kind of low-level

00:13:59,720 --> 00:14:04,700
it kinda goes against whatever I was

00:14:03,170 --> 00:14:09,800
saying that you shouldn't care about

00:14:04,700 --> 00:14:11,810
event loop there are some some so

00:14:09,800 --> 00:14:14,470
sometimes you have to care about it only

00:14:11,810 --> 00:14:18,020
because we don't have async/await

00:14:14,470 --> 00:14:19,820
versions of all API yet in packing tree

00:14:18,020 --> 00:14:23,210
it will try to fix that so for instance

00:14:19,820 --> 00:14:25,220
if you want to listen for an OS signal

00:14:23,210 --> 00:14:27,710
you have to use this add signal handler

00:14:25,220 --> 00:14:29,000
function on the event loop so if you

00:14:27,710 --> 00:14:31,280
have a code like this you should

00:14:29,000 --> 00:14:33,500
basically rewrite it to use async I'll

00:14:31,280 --> 00:14:35,630
run and you use this new get running

00:14:33,500 --> 00:14:37,970
loop function that is allowed to be used

00:14:35,630 --> 00:14:38,540
only from async await just a couple of

00:14:37,970 --> 00:14:40,970
domes

00:14:38,540 --> 00:14:43,070
don't use the courts in decorator don't

00:14:40,970 --> 00:14:44,930
use the yield from will will just

00:14:43,070 --> 00:14:47,510
deprecated it and patent three it and

00:14:44,930 --> 00:14:50,600
remove it and trade or three nine or

00:14:47,510 --> 00:14:53,270
maybe maybe fine if I can for will just

00:14:50,600 --> 00:14:55,490
remove this this this whole legacy thing

00:14:53,270 --> 00:14:57,260
forever and don't use again don't use

00:14:55,490 --> 00:15:01,540
low-level API to do you don't you don't

00:14:57,260 --> 00:15:02,750
really need them so now let's talk about

00:15:01,540 --> 00:15:05,330
good

00:15:02,750 --> 00:15:07,450
async/await code and what code is good

00:15:05,330 --> 00:15:09,380
may be the one that you can write

00:15:07,450 --> 00:15:11,750
quickly or

00:15:09,380 --> 00:15:14,090
maintainable code or beautiful robust

00:15:11,750 --> 00:15:16,130
and fast many of those things are

00:15:14,090 --> 00:15:18,770
subjective and some of those things are

00:15:16,130 --> 00:15:19,290
highly subjective but the last two

00:15:18,770 --> 00:15:21,660
robust

00:15:19,290 --> 00:15:25,529
fast those you can actually measure and

00:15:21,660 --> 00:15:27,300
how you measure them the only way to to

00:15:25,529 --> 00:15:31,170
measure them correctly is to do

00:15:27,300 --> 00:15:33,120
monitoring in production and the the sad

00:15:31,170 --> 00:15:36,329
thing here is that it wasn't really

00:15:33,120 --> 00:15:38,639
possible to monitor correctly each

00:15:36,329 --> 00:15:42,029
entire code in Python

00:15:38,639 --> 00:15:44,370
36 and prior in fact in 37 we have now a

00:15:42,029 --> 00:15:46,589
context variables and now try to explain

00:15:44,370 --> 00:15:51,060
you why why it was such a big problem

00:15:46,589 --> 00:15:53,639
before so in order to understand why we

00:15:51,060 --> 00:15:57,180
needed context variables in Python 37

00:15:53,639 --> 00:15:59,009
here is how event loop sees your program

00:15:57,180 --> 00:16:02,220
or an event loop it's just basically a

00:15:59,009 --> 00:16:04,110
sequence of callbacks and once it it is

00:16:02,220 --> 00:16:05,759
done with the current sequence of

00:16:04,110 --> 00:16:07,560
callbacks there is another sequence of

00:16:05,759 --> 00:16:11,910
code books and other in another one so

00:16:07,560 --> 00:16:13,759
all all that event loop knows about this

00:16:11,910 --> 00:16:15,990
is basically those callbacks completely

00:16:13,759 --> 00:16:18,600
completely not connected with each other

00:16:15,990 --> 00:16:20,819
whereas in reality usually you have some

00:16:18,600 --> 00:16:22,980
structural new program those callbacks

00:16:20,819 --> 00:16:24,660
might be all related to some

00:16:22,980 --> 00:16:28,319
asynchronous tasks or something like

00:16:24,660 --> 00:16:30,000
that so in Python 37 we decided to

00:16:28,319 --> 00:16:32,010
address this program we decided that we

00:16:30,000 --> 00:16:33,750
need this structure in our a single

00:16:32,010 --> 00:16:36,720
program to at least monitor them it was

00:16:33,750 --> 00:16:38,160
profiled and reliably so I started to

00:16:36,720 --> 00:16:39,779
work in context virus and there are a

00:16:38,160 --> 00:16:40,470
couple of preps that you might be

00:16:39,779 --> 00:16:43,110
interested in

00:16:40,470 --> 00:16:48,389
that's bad 550 that's how it all started

00:16:43,110 --> 00:16:50,579
besides just fixing the the aging high

00:16:48,389 --> 00:16:52,459
or async/await problem it also tried to

00:16:50,579 --> 00:16:55,889
address this problem problem for

00:16:52,459 --> 00:16:57,470
generators and it was too complex so we

00:16:55,889 --> 00:16:59,670
created a spin-off pep-pep

00:16:57,470 --> 00:17:02,610
five-six-seven was slightly different

00:16:59,670 --> 00:17:05,189
API but simpler design there are around

00:17:02,610 --> 00:17:06,900
900 emails some Python ideas in fact in

00:17:05,189 --> 00:17:09,020
there because suddenly everybody had an

00:17:06,900 --> 00:17:12,480
opinion about context variables and

00:17:09,020 --> 00:17:15,870
async/await is really a tough bottle but

00:17:12,480 --> 00:17:18,990
we finally got it in so first of all

00:17:15,870 --> 00:17:20,659
it's magic and like with any magic you

00:17:18,990 --> 00:17:22,740
shouldn't just use it because you want

00:17:20,659 --> 00:17:25,589
sometimes the global variable is good

00:17:22,740 --> 00:17:27,569
enough for you can just use a keyword

00:17:25,589 --> 00:17:31,549
argument to a function it busts things

00:17:27,569 --> 00:17:33,120
explicitly but there are something some

00:17:31,549 --> 00:17:36,120
areas where you

00:17:33,120 --> 00:17:37,830
can't really do that they're shipped

00:17:36,120 --> 00:17:40,890
with patently seven part of standard

00:17:37,830 --> 00:17:43,020
library Asian kayo supports them out of

00:17:40,890 --> 00:17:45,900
the box and I think REO supports them

00:17:43,020 --> 00:17:49,530
now out of the box as well the decimal

00:17:45,900 --> 00:17:52,140
module uses it so that was actually a

00:17:49,530 --> 00:17:53,190
bargain thing before biggest impact in

00:17:52,140 --> 00:17:55,650
three six and and

00:17:53,190 --> 00:17:57,170
earlier if you do some decimal

00:17:55,650 --> 00:17:59,790
calculations in two different

00:17:57,170 --> 00:18:01,530
asynchronous tasks and run in parallel

00:17:59,790 --> 00:18:03,450
and you have different that's more

00:18:01,530 --> 00:18:06,150
context all those decimal countries will

00:18:03,450 --> 00:18:08,610
put the mixed up and you would get the

00:18:06,150 --> 00:18:11,820
wrong calculation so in fact in 37 we

00:18:08,610 --> 00:18:15,750
fixed it so because context variables

00:18:11,820 --> 00:18:17,100
aren't really a syntax extension you

00:18:15,750 --> 00:18:19,650
have to work with them programmatically

00:18:17,100 --> 00:18:23,340
import the context worst module you

00:18:19,650 --> 00:18:25,320
create you declare a context variable

00:18:23,340 --> 00:18:27,929
programmatically you just create an

00:18:25,320 --> 00:18:31,170
object to the name you use the set

00:18:27,929 --> 00:18:34,020
function plus sign above you to a

00:18:31,170 --> 00:18:36,240
context very variable and you use the

00:18:34,020 --> 00:18:38,490
get method to look up the ball or the

00:18:36,240 --> 00:18:40,770
current value for this complex variable

00:18:38,490 --> 00:18:44,550
so if we get back to async IO and how

00:18:40,770 --> 00:18:47,900
and how even loop sees your your program

00:18:44,550 --> 00:18:50,580
and you structural it if you actually

00:18:47,900 --> 00:18:53,760
create a context variable and just

00:18:50,580 --> 00:18:56,880
assign some random random number to it

00:18:53,760 --> 00:18:58,290
in every top-level asynchronous task in

00:18:56,880 --> 00:19:00,900
your application you will see a picture

00:18:58,290 --> 00:19:04,470
like this so basically we'll be able to

00:19:00,900 --> 00:19:05,910
trace the the to trace that number to

00:19:04,470 --> 00:19:10,380
trace the origin of this callback

00:19:05,910 --> 00:19:11,880
throughout your straw the execution so

00:19:10,380 --> 00:19:13,950
you can use context variables for

00:19:11,880 --> 00:19:16,230
monitoring all these profiling for

00:19:13,950 --> 00:19:18,870
tracing we can use it for localization

00:19:16,230 --> 00:19:22,590
for instance you if you know that the

00:19:18,870 --> 00:19:26,340
current user is an English or German

00:19:22,590 --> 00:19:27,900
speaking speaking and guy you can just

00:19:26,340 --> 00:19:29,130
put that language to the context

00:19:27,900 --> 00:19:31,290
variable and you will always know that

00:19:29,130 --> 00:19:34,320
you can use it for security you can put

00:19:31,290 --> 00:19:36,660
the current user ID or current security

00:19:34,320 --> 00:19:39,300
capabilities in the context variable and

00:19:36,660 --> 00:19:41,130
you will be able to read read those from

00:19:39,300 --> 00:19:42,780
basically any point in Europe

00:19:41,130 --> 00:19:44,940
creation you can use it obviously for

00:19:42,780 --> 00:19:46,950
debug you can just create a temporary

00:19:44,940 --> 00:19:50,250
context variable put something into it

00:19:46,950 --> 00:19:53,310
and see if if it reads in some homework

00:19:50,250 --> 00:19:54,630
or some asynchronous function basically

00:19:53,310 --> 00:19:56,370
to check if two things are connected

00:19:54,630 --> 00:19:59,880
something like that and you can use it

00:19:56,370 --> 00:20:02,220
for execution context for decimal campus

00:19:59,880 --> 00:20:03,900
or an umpire error context will really

00:20:02,220 --> 00:20:07,980
use context variables to work correctly

00:20:03,900 --> 00:20:11,040
in in in async/await but the big

00:20:07,980 --> 00:20:13,680
question is what we have in mind for

00:20:11,040 --> 00:20:15,840
18th i/o in python 3 8 and maybe python

00:20:13,680 --> 00:20:19,050
3 in island here I think it's a good

00:20:15,840 --> 00:20:21,990
time to start to talk about 300 300 was

00:20:19,050 --> 00:20:24,270
created by a nathaniel Smith around

00:20:21,990 --> 00:20:26,280
Python 3 6 and it's also designed from

00:20:24,270 --> 00:20:27,780
scratch it's incompatible with a

00:20:26,280 --> 00:20:29,850
scenario that's completely different

00:20:27,780 --> 00:20:31,980
design under the hood I think there is

00:20:29,850 --> 00:20:34,740
some intro clear I'm not sure how well

00:20:31,980 --> 00:20:36,870
it works right now and tree has very

00:20:34,740 --> 00:20:38,670
hard focus on usability and readability

00:20:36,870 --> 00:20:43,110
of the code so basically Nathaniel is

00:20:38,670 --> 00:20:45,540
obsessed with allowing you to control

00:20:43,110 --> 00:20:47,820
your code with the highest precision

00:20:45,540 --> 00:20:49,710
possible and to you I think got many

00:20:47,820 --> 00:20:52,320
things right and there is a YouTube talk

00:20:49,710 --> 00:20:55,200
of Nathaniel explaining 3 and why he

00:20:52,320 --> 00:20:57,300
created 3 bike on us a few months ago

00:20:55,200 --> 00:20:59,280
and if you haven't seen that talk please

00:20:57,300 --> 00:21:01,260
do it's it's it's an amazing talk and

00:20:59,280 --> 00:21:04,520
actually I used a couple of slides with

00:21:01,260 --> 00:21:07,910
Nathaniel permissions from his talk so

00:21:04,520 --> 00:21:10,440
this is how programs looked like in in

00:21:07,910 --> 00:21:14,760
1958 so basically we have a line number

00:21:10,440 --> 00:21:16,590
and you have a sequence of codes or

00:21:14,760 --> 00:21:18,570
commands and you could actually jump

00:21:16,590 --> 00:21:21,240
from one line to another and if you

00:21:18,570 --> 00:21:23,790
visualize all those jobs welcome you

00:21:21,240 --> 00:21:24,690
basically you basically see something

00:21:23,790 --> 00:21:26,880
like that so it was completely

00:21:24,690 --> 00:21:29,370
untraceable and then you wouldn't be

00:21:26,880 --> 00:21:33,330
actually able to to tell what this

00:21:29,370 --> 00:21:39,360
program is doing just by glancing at it

00:21:33,330 --> 00:21:41,850
and 10 years later Dijkstra wrote a

00:21:39,360 --> 00:21:44,610
letter which was titled go to state and

00:21:41,850 --> 00:21:46,320
considerate harm from them and came up

00:21:44,610 --> 00:21:48,480
with this idea of structured programming

00:21:46,320 --> 00:21:49,890
and the idea of structured programming

00:21:48,480 --> 00:21:52,240
and that is that you have some

00:21:49,890 --> 00:21:54,490
primitives that you can use

00:21:52,240 --> 00:21:56,559
to build your programs with you can have

00:21:54,490 --> 00:21:58,780
an if block you can have a loop we're

00:21:56,559 --> 00:22:01,420
gonna have loops you can have function

00:21:58,780 --> 00:22:03,460
calls and the idea is that there is only

00:22:01,420 --> 00:22:06,070
one entrance point and there is only one

00:22:03,460 --> 00:22:07,900
exit point in your logic so the code is

00:22:06,070 --> 00:22:10,330
always predictable there is no goal -

00:22:07,900 --> 00:22:12,850
there is no this random jobs any problem

00:22:10,330 --> 00:22:14,290
and if you really think about go - and

00:22:12,850 --> 00:22:16,360
you think about asynchronous programming

00:22:14,290 --> 00:22:18,730
you will see a lot of parallels if you

00:22:16,360 --> 00:22:20,770
if you use in async i/o if you use

00:22:18,730 --> 00:22:22,600
create task function it will create the

00:22:20,770 --> 00:22:25,360
task that will run in parallel you have

00:22:22,600 --> 00:22:27,070
no control over that task if if it fails

00:22:25,360 --> 00:22:27,850
with an exception nothing will happen

00:22:27,070 --> 00:22:30,520
for you

00:22:27,850 --> 00:22:35,830
you will probably see the logs but you

00:22:30,520 --> 00:22:36,670
can't really react to that exception so

00:22:35,830 --> 00:22:38,770
back to tree

00:22:36,670 --> 00:22:41,380
entry or nathaniel added this this

00:22:38,770 --> 00:22:44,080
concept of indoor syrian nursery is the

00:22:41,380 --> 00:22:48,309
only way to spawn some asynchronous

00:22:44,080 --> 00:22:52,540
tasks in n3o it's a funny name I think

00:22:48,309 --> 00:22:54,730
because tasks are born in a nursery they

00:22:52,540 --> 00:22:57,940
diner so basically it's not possible to

00:22:54,730 --> 00:23:01,270
graduate from nursery yeah it's a dark

00:22:57,940 --> 00:23:02,590
place but that's but that's but but

00:23:01,270 --> 00:23:05,860
that's the point that's kind of the

00:23:02,590 --> 00:23:08,170
whole point of nurseries is that once

00:23:05,860 --> 00:23:10,840
you once you go through this

00:23:08,170 --> 00:23:13,390
asynchronous width walk you are sure

00:23:10,840 --> 00:23:15,760
that all your tasks are done if one of

00:23:13,390 --> 00:23:17,350
them fails the other tasks will be

00:23:15,760 --> 00:23:19,570
canceled and the exception will be

00:23:17,350 --> 00:23:22,210
propagated correctly so you can surround

00:23:19,570 --> 00:23:24,550
this this aging with statement with the

00:23:22,210 --> 00:23:26,470
try except block and you will get your

00:23:24,550 --> 00:23:28,330
logic back so there is no go-to here

00:23:26,470 --> 00:23:31,630
there is some out of order execution

00:23:28,330 --> 00:23:34,570
because those two co-routines will run

00:23:31,630 --> 00:23:36,429
in parallel in this example but at the

00:23:34,570 --> 00:23:38,440
end of the async wit block they they

00:23:36,429 --> 00:23:41,890
they both will be done and that that's a

00:23:38,440 --> 00:23:43,450
guarantee so in trio there is almost no

00:23:41,890 --> 00:23:46,150
out of order execution and you can

00:23:43,450 --> 00:23:48,670
always trace the control flow exceptions

00:23:46,150 --> 00:23:50,380
are never lost so it's it's up to you if

00:23:48,670 --> 00:23:54,790
you want to ignore the exception by by

00:23:50,380 --> 00:23:57,220
default you have to handle them with and

00:23:54,790 --> 00:24:01,570
therefore with and drive blocks always

00:23:57,220 --> 00:24:03,559
work and I think that this is this

00:24:01,570 --> 00:24:05,450
approach kind of solve this

00:24:03,559 --> 00:24:08,720
let's go to problem concurrency a

00:24:05,450 --> 00:24:11,509
program become becomes traceable so if

00:24:08,720 --> 00:24:13,759
you go back to to async I own this whole

00:24:11,509 --> 00:24:16,399
mass of callbacks and allocated

00:24:13,759 --> 00:24:18,830
resources and an event movement imagine

00:24:16,399 --> 00:24:20,840
how an HTTP client library might might

00:24:18,830 --> 00:24:23,240
might might look like so it probably has

00:24:20,840 --> 00:24:24,919
some HTTP client object which spawns

00:24:23,240 --> 00:24:28,789
those callbacks and those callbacks

00:24:24,919 --> 00:24:31,399
spawn another callback and you maybe

00:24:28,789 --> 00:24:34,460
have a transport or some other resource

00:24:31,399 --> 00:24:36,350
allocated by your HTTP client and then

00:24:34,460 --> 00:24:39,590
something happens an exceptional error

00:24:36,350 --> 00:24:41,360
so what will happen and the the current

00:24:39,590 --> 00:24:43,220
answer to that is undefined like we

00:24:41,360 --> 00:24:45,350
don't know what to have what will happen

00:24:43,220 --> 00:24:47,740
if you have a callback written like this

00:24:45,350 --> 00:24:51,139
so you have a try except statement in it

00:24:47,740 --> 00:24:52,850
then you can actually handle handle any

00:24:51,139 --> 00:24:54,649
exception in your callback but you have

00:24:52,850 --> 00:24:56,779
to be explicit about it you have to care

00:24:54,649 --> 00:24:59,840
about it and most libraries actually

00:24:56,779 --> 00:25:02,539
don't they kind of think that everything

00:24:59,840 --> 00:25:06,019
will go just fine exceptions basically

00:25:02,539 --> 00:25:07,909
don't exist some invent some some

00:25:06,019 --> 00:25:10,639
mechanism to propagate those those

00:25:07,909 --> 00:25:14,119
exceptions back to the client but even

00:25:10,639 --> 00:25:15,799
in in HTTP and 18pt I'm pretty sure

00:25:14,119 --> 00:25:17,600
there are lots of box where it didn't

00:25:15,799 --> 00:25:19,490
really handle those exceptions correctly

00:25:17,600 --> 00:25:22,460
so it's essentially a bug magnet and I

00:25:19,490 --> 00:25:24,350
think in Asian girls constant point of

00:25:22,460 --> 00:25:27,409
pain because you have to care about

00:25:24,350 --> 00:25:32,149
those callbacks all the time so what we

00:25:27,409 --> 00:25:34,249
actually need we need a way to handle

00:25:32,149 --> 00:25:36,259
those exceptions and callbacks or any

00:25:34,249 --> 00:25:39,139
other resources that haven't moved

00:25:36,259 --> 00:25:42,049
alligator so if something happens even

00:25:39,139 --> 00:25:44,629
the async event location cave itself

00:25:42,049 --> 00:25:46,909
should help us to close to close those

00:25:44,629 --> 00:25:49,100
and deallocate those resources so I have

00:25:46,909 --> 00:25:52,129
an idea for patent 3 and this is just an

00:25:49,100 --> 00:25:54,139
idea I discuss it briefly with a few

00:25:52,129 --> 00:25:57,409
core developers and I think we'll have

00:25:54,139 --> 00:25:59,119
something like that in in 18k 38 and

00:25:57,409 --> 00:26:02,600
that's a low-level API it's called

00:25:59,119 --> 00:26:04,850
create supervisor and create supervisor

00:26:02,600 --> 00:26:07,159
returns you an asynchronous context

00:26:04,850 --> 00:26:10,129
context manager come to context object

00:26:07,159 --> 00:26:12,649
you can use it in a sink with statement

00:26:10,129 --> 00:26:13,590
and supervisor kinda mirrors all asian

00:26:12,649 --> 00:26:16,650
guy event will be

00:26:13,590 --> 00:26:18,510
so it will have the call soon method

00:26:16,650 --> 00:26:21,690
will have called later method create

00:26:18,510 --> 00:26:24,690
connection create server so the it is

00:26:21,690 --> 00:26:27,390
that we can kind of give a virtual event

00:26:24,690 --> 00:26:30,090
loop to any to any library that wants to

00:26:27,390 --> 00:26:32,610
use the that wants to use the event loop

00:26:30,090 --> 00:26:34,290
and we can track all those resources and

00:26:32,610 --> 00:26:36,090
you can pass it around if you want just

00:26:34,290 --> 00:26:38,130
like you would an event and this is a

00:26:36,090 --> 00:26:43,490
low-level API said meant to be used for

00:26:38,130 --> 00:26:45,810
in in libraries like a HTTP or async AG

00:26:43,490 --> 00:26:49,530
and this is an example of such a

00:26:45,810 --> 00:26:53,280
hypothetical HTTP library where you have

00:26:49,530 --> 00:26:54,750
a gap method so you get a reference the

00:26:53,280 --> 00:26:56,430
currently running event loop then you

00:26:54,750 --> 00:26:58,650
create a supervisor and you can work

00:26:56,430 --> 00:27:02,330
with this supervisor just the way you

00:26:58,650 --> 00:27:05,250
put with a normal a single event loop

00:27:02,330 --> 00:27:07,530
but what we have here is that because

00:27:05,250 --> 00:27:11,640
this supervisor will be unique to that

00:27:07,530 --> 00:27:14,400
point new library when we know all the

00:27:11,640 --> 00:27:17,280
resources that allocate so any unhandled

00:27:14,400 --> 00:27:19,080
exception will first propagate correctly

00:27:17,280 --> 00:27:24,320
and then we'll be able to clean up all

00:27:19,080 --> 00:27:27,180
those resources and there is another

00:27:24,320 --> 00:27:30,390
similar idea and again thanks to curio

00:27:27,180 --> 00:27:32,880
is to add a sink iota group in python to

00:27:30,390 --> 00:27:35,460
aide that's basically an alternative to

00:27:32,880 --> 00:27:37,830
a single gather which is I think very

00:27:35,460 --> 00:27:40,890
badly designed there are lots of

00:27:37,830 --> 00:27:43,140
historical reasons why God works like it

00:27:40,890 --> 00:27:45,270
like like it does but this thing would

00:27:43,140 --> 00:27:48,180
be would be way more convenient and way

00:27:45,270 --> 00:27:51,030
more flexible and this is actually looks

00:27:48,180 --> 00:27:54,570
pretty similar to trio and curio it's a

00:27:51,030 --> 00:27:58,050
very high level high level code so task

00:27:54,570 --> 00:27:58,830
group like we just use the the create

00:27:58,050 --> 00:28:02,010
supervisor

00:27:58,830 --> 00:28:05,100
under the hood and behave pretty pretty

00:28:02,010 --> 00:28:07,200
similar to how three or nursery's of

00:28:05,100 --> 00:28:10,790
working it's more convenient and gather

00:28:07,200 --> 00:28:13,530
gather has some very strange default

00:28:10,790 --> 00:28:16,050
default config options so for instance

00:28:13,530 --> 00:28:17,700
by default if you run five things by

00:28:16,050 --> 00:28:21,000
different a synchronous tasks with

00:28:17,700 --> 00:28:22,590
gather and one of them fail fails it

00:28:21,000 --> 00:28:24,130
will just propagate the exception and

00:28:22,590 --> 00:28:25,810
the the rest of them will contain

00:28:24,130 --> 00:28:27,790
the execution and those exceptions were

00:28:25,810 --> 00:28:29,890
results it will be just lost a lot of

00:28:27,790 --> 00:28:31,780
people just don't know about that but

00:28:29,890 --> 00:28:34,270
it's pretty dangerous have to have to be

00:28:31,780 --> 00:28:37,060
careful when you use a sinker guard and

00:28:34,270 --> 00:28:38,860
you can do more magic with task groups

00:28:37,060 --> 00:28:41,650
like if you have a million tasks to

00:28:38,860 --> 00:28:43,660
execute it would be unwise to push them

00:28:41,650 --> 00:28:48,130
out once you probably want to bucket

00:28:43,660 --> 00:28:51,310
them and execute them in in portions so

00:28:48,130 --> 00:28:53,260
what else can we expect from Python 3 it

00:28:51,310 --> 00:28:56,080
well first of all we hear you even if

00:28:53,260 --> 00:28:57,940
you don't write your don't submit your

00:28:56,080 --> 00:28:59,620
bugs and fish requests to box Python to

00:28:57,940 --> 00:29:02,590
work even if you were just trying and

00:28:59,620 --> 00:29:07,270
reddit or Twitter or hacker news we

00:29:02,590 --> 00:29:10,030
usually try to to find out those pain

00:29:07,270 --> 00:29:12,310
points that people have but please do

00:29:10,030 --> 00:29:13,870
submit your bugs in feature requests to

00:29:12,310 --> 00:29:16,780
box pattern 4 because we are really

00:29:13,870 --> 00:29:19,120
really listening a lot of people have

00:29:16,780 --> 00:29:20,860
this this idea that the entire core

00:29:19,120 --> 00:29:22,750
developers don't really care about what

00:29:20,860 --> 00:29:25,630
what people say or what that's that's

00:29:22,750 --> 00:29:28,150
not true the documentation has to be

00:29:25,630 --> 00:29:31,060
improved about two years ago I was

00:29:28,150 --> 00:29:33,430
standing at Europe I cannot promise that

00:29:31,060 --> 00:29:34,960
will update the documentation and I'm

00:29:33,430 --> 00:29:38,290
excited to announce that nothing has

00:29:34,960 --> 00:29:40,000
changed it so sucks

00:29:38,290 --> 00:29:41,740
but we'll go we'll try to improve with

00:29:40,000 --> 00:29:44,260
this as soon as possible

00:29:41,740 --> 00:29:46,900
likely will have great supervisor and

00:29:44,260 --> 00:29:48,670
task groups in in patently they might

00:29:46,900 --> 00:29:52,540
have different names or maybe will

00:29:48,670 --> 00:29:54,040
change some API details but it's it's

00:29:52,540 --> 00:29:57,100
very likely that those have something

00:29:54,040 --> 00:30:00,430
like that I'm also working to add low

00:29:57,100 --> 00:30:02,530
level tracing api I'll be doing that in

00:30:00,430 --> 00:30:03,700
YouTube first the kind of prototype and

00:30:02,530 --> 00:30:05,590
let people play with it

00:30:03,700 --> 00:30:08,080
the idea is that there are some services

00:30:05,590 --> 00:30:11,410
like Zipkin or New Relic and they allow

00:30:08,080 --> 00:30:13,720
it to look deeply in your code and

00:30:11,410 --> 00:30:15,490
figure out how it works and what about

00:30:13,720 --> 00:30:18,490
what was happening with it so we

00:30:15,490 --> 00:30:21,370
actually want to know for instance all

00:30:18,490 --> 00:30:23,920
tale latencies or all timings or how

00:30:21,370 --> 00:30:25,600
many bytes are pushed there's an

00:30:23,920 --> 00:30:27,370
protocol or transports and currently

00:30:25,600 --> 00:30:29,980
there is absolutely no way to do that

00:30:27,370 --> 00:30:32,110
amazing guy without patching the core so

00:30:29,980 --> 00:30:33,400
we want this don't this tracing API to

00:30:32,110 --> 00:30:38,500
be flexible and

00:30:33,400 --> 00:30:40,060
and usable for four people maybe we will

00:30:38,500 --> 00:30:42,220
implement timeout and canceled schools

00:30:40,060 --> 00:30:43,930
just like Rio and that's that's also a

00:30:42,220 --> 00:30:45,280
pretty unique feature and trio because

00:30:43,930 --> 00:30:47,560
it's really you don't really care about

00:30:45,280 --> 00:30:49,660
that Mouse at all you don't care about

00:30:47,560 --> 00:30:52,270
them when you write third-party

00:30:49,660 --> 00:30:54,130
libraries when you write HTG let's say

00:30:52,270 --> 00:30:59,170
HTTP client you don't really care about

00:30:54,130 --> 00:31:01,210
die lost trio cap kinda does all this

00:30:59,170 --> 00:31:03,100
work to handle them and to implement

00:31:01,210 --> 00:31:05,260
them in the course so you just write

00:31:03,100 --> 00:31:07,270
your code and if you want a timeout you

00:31:05,260 --> 00:31:10,630
just use a context manager around that

00:31:07,270 --> 00:31:13,660
call side and the timeout logical will

00:31:10,630 --> 00:31:16,330
be applied correctly and all allocated

00:31:13,660 --> 00:31:18,580
things will be cleaned out and managed

00:31:16,330 --> 00:31:19,840
for you and the same idea and I actually

00:31:18,580 --> 00:31:23,710
recommend you to read some of

00:31:19,840 --> 00:31:26,770
Nathaniel's blog posts those are pretty

00:31:23,710 --> 00:31:29,140
you can google them easily those are

00:31:26,770 --> 00:31:31,150
also interesting ideas about canceled

00:31:29,140 --> 00:31:32,890
scopes and how he does cancellations so

00:31:31,150 --> 00:31:34,510
a lot of those ideas they can be applied

00:31:32,890 --> 00:31:37,300
to each in Cairo in one way or another

00:31:34,510 --> 00:31:40,600
and we are now thinking about how we can

00:31:37,300 --> 00:31:43,270
how we can have the nation Cairo

00:31:40,600 --> 00:31:45,550
well there are other another idea that I

00:31:43,270 --> 00:31:47,830
have is to improve the streams API and

00:31:45,550 --> 00:31:50,080
basically not just a good but to

00:31:47,830 --> 00:31:52,750
substitute we substitute it with

00:31:50,080 --> 00:31:54,400
something sane because right now when

00:31:52,750 --> 00:31:56,610
you use streams you have this reader and

00:31:54,400 --> 00:31:58,750
writer object with different methods and

00:31:56,610 --> 00:32:01,120
for instance you want to close your

00:31:58,750 --> 00:32:03,640
stream which which close method you

00:32:01,120 --> 00:32:05,530
should call suna Colton reader or on the

00:32:03,640 --> 00:32:08,560
writer or maybe you should call to

00:32:05,530 --> 00:32:10,870
closed methods so it's really hard for

00:32:08,560 --> 00:32:13,270
people to grasp how streams work and I

00:32:10,870 --> 00:32:16,060
think that's part of the reason one one

00:32:13,270 --> 00:32:18,610
of the reasons why people don't really

00:32:16,060 --> 00:32:21,430
use those streams so I have an idea to

00:32:18,610 --> 00:32:23,740
design you a guy for a Chicago with two

00:32:21,430 --> 00:32:26,680
top-level functions a cinco connect an

00:32:23,740 --> 00:32:29,830
async I serve and have a single streams

00:32:26,680 --> 00:32:31,270
object working for them maybe we'll add

00:32:29,830 --> 00:32:33,010
a context manager for the shield

00:32:31,270 --> 00:32:35,470
function and shield function allows you

00:32:33,010 --> 00:32:38,920
to shield some code or some core team

00:32:35,470 --> 00:32:41,230
from from constellation and right now

00:32:38,920 --> 00:32:43,240
the only way in Asian guys to use this

00:32:41,230 --> 00:32:43,929
function but then you have to refactor

00:32:43,240 --> 00:32:46,090
your code

00:32:43,929 --> 00:32:48,249
have to move your finally walk into a

00:32:46,090 --> 00:32:50,350
function and then use it with the shield

00:32:48,249 --> 00:32:52,090
so it's it's really it's really painful

00:32:50,350 --> 00:32:54,360
we're also rewriting the ssl

00:32:52,090 --> 00:32:57,220
implementation an async i/o from scratch

00:32:54,360 --> 00:33:01,570
again i'm doing this work and you you

00:32:57,220 --> 00:33:04,990
look to kinda try this this rewrite in

00:33:01,570 --> 00:33:06,999
the wild but it will handle a lot of a

00:33:04,990 --> 00:33:09,249
lot of different bugs a lot of different

00:33:06,999 --> 00:33:11,710
a lot of inconsistencies that we now

00:33:09,249 --> 00:33:13,509
have in our ssl implementation in asian

00:33:11,710 --> 00:33:16,779
guy or like doing the cancellation

00:33:13,509 --> 00:33:21,129
correctly and doing things like SSL over

00:33:16,779 --> 00:33:23,830
ssl and there is another thing that that

00:33:21,129 --> 00:33:27,490
really worries me is that they canceled

00:33:23,830 --> 00:33:29,830
their in a sink i oh it's it's the right

00:33:27,490 --> 00:33:31,960
from exception and not from basic

00:33:29,830 --> 00:33:33,700
sessions so when people put try except

00:33:31,960 --> 00:33:36,070
exception in their code base and that's

00:33:33,700 --> 00:33:38,259
a pretty popular way to casual

00:33:36,070 --> 00:33:39,669
exceptions they kind of break the async

00:33:38,259 --> 00:33:43,570
error cancellation completely and

00:33:39,669 --> 00:33:45,159
entirely so we are thinking about fixing

00:33:43,570 --> 00:33:49,440
this but this is a backwards

00:33:45,159 --> 00:33:53,259
incompatible change so i have no idea we

00:33:49,440 --> 00:33:57,090
actually push this through and that's

00:33:53,259 --> 00:33:57,090
pretty much it thank you very much

00:34:03,960 --> 00:34:11,770
so we have pretty much time for Q&A

00:34:07,120 --> 00:34:19,119
please raise your hand or you can go

00:34:11,770 --> 00:34:21,760
here okay with not so much people - hey

00:34:19,119 --> 00:34:24,820
so I'm pretty much satisfied with the

00:34:21,760 --> 00:34:27,669
gather although I have been tweaking its

00:34:24,820 --> 00:34:31,210
options of it for example I can have

00:34:27,669 --> 00:34:36,090
like a list of stuff that yeah - these

00:34:31,210 --> 00:34:39,429
are results and exceptions so how is

00:34:36,090 --> 00:34:43,510
trios nursery for example better than

00:34:39,429 --> 00:34:47,050
just using gather with some more

00:34:43,510 --> 00:34:49,780
information about it yes so that's a

00:34:47,050 --> 00:34:51,820
very good question actually big because

00:34:49,780 --> 00:34:55,600
that's a fundamental problem right now

00:34:51,820 --> 00:34:57,190
in Python and Python you usually have

00:34:55,600 --> 00:34:59,230
some synchronous code and we can write

00:34:57,190 --> 00:35:01,800
only one exception I mean things like

00:34:59,230 --> 00:35:04,330
308 Cinco Curie or you can have your

00:35:01,800 --> 00:35:05,710
task group and will execute many

00:35:04,330 --> 00:35:07,420
different things in parallel so we can

00:35:05,710 --> 00:35:09,910
have many different exceptions coming

00:35:07,420 --> 00:35:12,160
from one point and the idea is to create

00:35:09,910 --> 00:35:16,210
some sort of multi error a thing that

00:35:12,160 --> 00:35:19,390
can can unveil up a few few few

00:35:16,210 --> 00:35:22,150
exceptions in it so will likely add a

00:35:19,390 --> 00:35:24,369
mechanism a built-in Python mechanism to

00:35:22,150 --> 00:35:27,550
to be able to create those kinds of

00:35:24,369 --> 00:35:30,460
multi errors and in in Python code so

00:35:27,550 --> 00:35:32,500
you will get and that mult multi here

00:35:30,460 --> 00:35:34,630
you will be able to catch it and then

00:35:32,500 --> 00:35:37,420
you will have to use some API it can go

00:35:34,630 --> 00:35:39,369
through those exceptions and make sense

00:35:37,420 --> 00:35:41,740
of them and the other thing is that

00:35:39,369 --> 00:35:44,020
gather uses some magic under the hood

00:35:41,740 --> 00:35:47,440
but if you just pass four genes together

00:35:44,020 --> 00:35:49,480
it will rub them implicitly with tasks

00:35:47,440 --> 00:35:54,070
and you won't have reference to those

00:35:49,480 --> 00:35:55,930
tasks in your code with a sink with a

00:35:54,070 --> 00:35:58,090
single task groups you will do that

00:35:55,930 --> 00:36:00,040
explicitly so you will have a reference

00:35:58,090 --> 00:36:02,250
to a task so you will be able to collect

00:36:00,040 --> 00:36:05,470
your results of the computation

00:36:02,250 --> 00:36:09,430
explicitly if you want after the aging

00:36:05,470 --> 00:36:11,260
with block so yeah that's that's the

00:36:09,430 --> 00:36:13,720
that's the idea the main challenge will

00:36:11,260 --> 00:36:16,430
be to add the multi error and have a

00:36:13,720 --> 00:36:19,890
nice UI

00:36:16,430 --> 00:36:23,130
okay thanks can I have one more

00:36:19,890 --> 00:36:26,940
follow-up actually if you do gathered do

00:36:23,130 --> 00:36:31,860
context variables from 37 go to those

00:36:26,940 --> 00:36:38,010
spawning of late right thanks so any

00:36:31,860 --> 00:36:41,790
more questions okay please don't forget

00:36:38,010 --> 00:36:45,030
to rate this session just go to a

00:36:41,790 --> 00:36:52,950
conference app and do it please don't

00:36:45,030 --> 00:36:55,950
leave the stock in nursery thank you

00:36:52,950 --> 00:36:59,430
so I've been using Python

00:36:55,950 --> 00:37:04,080
since Python 3.3 and some older stuff

00:36:59,430 --> 00:37:05,610
but I was wondering it seems like a lot

00:37:04,080 --> 00:37:07,680
of broken things were actually

00:37:05,610 --> 00:37:09,480
introduced in the older versions well I

00:37:07,680 --> 00:37:14,540
was kind of thinking you know everything

00:37:09,480 --> 00:37:16,890
is stable about async I oh can we expect

00:37:14,540 --> 00:37:19,950
more broken stuff where are we reaching

00:37:16,890 --> 00:37:23,580
some kind of stability then or are these

00:37:19,950 --> 00:37:28,560
just minor things in the ends yeah we

00:37:23,580 --> 00:37:30,810
don't want to break anything and I will

00:37:28,560 --> 00:37:34,830
try to be to be very careful about that

00:37:30,810 --> 00:37:36,900
I also don't expect a sink IO to

00:37:34,830 --> 00:37:38,640
completely stabilized and freeze we

00:37:36,900 --> 00:37:39,980
actually want to have those new API so

00:37:38,640 --> 00:37:42,420
we want to keep improving it

00:37:39,980 --> 00:37:45,510
unfortunately we cannot really improve

00:37:42,420 --> 00:37:48,540
it with the as fast as we want because

00:37:45,510 --> 00:37:50,430
it's tied to Python release cycle but I

00:37:48,540 --> 00:37:56,430
think that I think I were pretty

00:37:50,430 --> 00:37:58,820
different and in Python 4.2 or 4.3 but

00:37:56,430 --> 00:38:01,770
backwards compatible of course all right

00:37:58,820 --> 00:38:04,110
another one question then so if you

00:38:01,770 --> 00:38:06,600
introduced shield do you then also have

00:38:04,110 --> 00:38:11,360
to introduce destroy shield or is that

00:38:06,600 --> 00:38:11,360
not gone here endless battle

00:38:11,510 --> 00:38:16,130
yeah I don't know my people have ad

00:38:13,670 --> 00:38:19,359
levels so you can't really destroy a a

00:38:16,130 --> 00:38:23,510
two level shield or something like that

00:38:19,359 --> 00:38:25,700
we have no idea about that I kind of

00:38:23,510 --> 00:38:27,410
think that that that isn't really

00:38:25,700 --> 00:38:28,910
necessary if you show something then

00:38:27,410 --> 00:38:31,460
it's just important you should always

00:38:28,910 --> 00:38:33,740
let it a letter finish and if you have

00:38:31,460 --> 00:38:37,400
some hard time about them just kill -

00:38:33,740 --> 00:38:46,660
ninety program it will probably not just

00:38:37,400 --> 00:38:46,660
fine thank you anymore okay

00:38:49,690 --> 00:38:56,270
I'm just wondering what do you think is

00:38:52,220 --> 00:38:58,820
the future of UV loop like this is it

00:38:56,270 --> 00:38:59,990
still more performant and the standard I

00:38:58,820 --> 00:39:02,060
think I you loop and that's the main

00:38:59,990 --> 00:39:06,950
reason to keep using it will it ever be

00:39:02,060 --> 00:39:09,650
part of the standard library it can be

00:39:06,950 --> 00:39:11,390
part of standard library the way it is

00:39:09,650 --> 00:39:14,390
right now because it uses siphon and

00:39:11,390 --> 00:39:16,490
siphon is a huge dependency and also it

00:39:14,390 --> 00:39:21,050
gives asleep Vivian Lee Beuys is also a

00:39:16,490 --> 00:39:23,390
very complicated dependency to include

00:39:21,050 --> 00:39:26,330
something like you loop write an async

00:39:23,390 --> 00:39:28,190
i/o will have to write a lot of C code

00:39:26,330 --> 00:39:31,369
and that's basically hundreds of

00:39:28,190 --> 00:39:33,260
thousands of lines of code so probably

00:39:31,369 --> 00:39:35,540
it's not gonna happen anytime soon so it

00:39:33,260 --> 00:39:38,390
will just happily leave as a separate IP

00:39:35,540 --> 00:39:41,990
I module for a long time to come and by

00:39:38,390 --> 00:39:43,640
the way also check out another third

00:39:41,990 --> 00:39:46,609
party event loop implementation it's

00:39:43,640 --> 00:39:48,920
called Tokyo by Nikolai Kim the original

00:39:46,609 --> 00:39:51,080
creator of HTTP and it's written in rust

00:39:48,920 --> 00:39:54,380
and the whole point is that you can use

00:39:51,080 --> 00:39:57,140
talk here to kind a single single bridge

00:39:54,380 --> 00:39:59,480
between Python asynchronous world and

00:39:57,140 --> 00:40:01,460
rust the asynchronous frameworks is

00:39:59,480 --> 00:40:05,500
pretty interesting I think it's pretty

00:40:01,460 --> 00:40:05,500
stable right now I can use that as well

00:40:11,290 --> 00:40:18,230
hey thanks look so one of the things I

00:40:15,800 --> 00:40:20,450
was sort of confused with the context of

00:40:18,230 --> 00:40:23,750
ours is if you start doing things like

00:40:20,450 --> 00:40:26,090
you ensure future on a carry team and

00:40:23,750 --> 00:40:32,240
then sort of pass it around which

00:40:26,090 --> 00:40:34,700
context does that carotene get it always

00:40:32,240 --> 00:40:37,100
in hurts the context of where it was

00:40:34,700 --> 00:40:39,440
called uv8 where the task is created

00:40:37,100 --> 00:40:42,170
basically what task is created captures

00:40:39,440 --> 00:40:45,820
the current context and and keeps it

00:40:42,170 --> 00:40:45,820
forever okay

00:40:55,230 --> 00:41:03,310
hi do you think that you can you could

00:40:59,380 --> 00:41:05,440
add the concept of task having names to

00:41:03,310 --> 00:41:08,050
async IO because threads have names

00:41:05,440 --> 00:41:10,660
trios tasks have names but I think IO

00:41:08,050 --> 00:41:12,430
has no way to add names to tasks it's

00:41:10,660 --> 00:41:14,410
very useful when you're debugging stuff

00:41:12,430 --> 00:41:17,050
and for example boy chums

00:41:14,410 --> 00:41:19,510
Python has a tool that allows you to

00:41:17,050 --> 00:41:23,760
view although separate tasks but if they

00:41:19,510 --> 00:41:23,760
don't have names it gets a lot harder

00:41:24,180 --> 00:41:33,069
can be very good first contribution to

00:41:27,550 --> 00:41:34,319
the Python so don't help ok ok another

00:41:33,069 --> 00:41:38,109
question

00:41:34,319 --> 00:41:40,869
drills nurseries really trio's spawn

00:41:38,109 --> 00:41:43,690
tasks don't have any way of you know

00:41:40,869 --> 00:41:44,349
getting their results how do you feel

00:41:43,690 --> 00:41:47,410
about that

00:41:44,349 --> 00:41:50,020
getting results yeah big when you spawn

00:41:47,410 --> 00:41:53,290
tasks in trio you don't really get a

00:41:50,020 --> 00:41:55,390
task or potato you can just wait on so

00:41:53,290 --> 00:41:56,410
you have to use other primitives to get

00:41:55,390 --> 00:41:59,589
the results

00:41:56,410 --> 00:42:02,200
yeah so async AF is a lot history and we

00:41:59,589 --> 00:42:05,010
cannot just adopt that trio pattern and

00:42:02,200 --> 00:42:07,630
again Nathaniel is is very obsessed with

00:42:05,010 --> 00:42:09,700
providing just one way of launching

00:42:07,630 --> 00:42:12,160
tasks and that's on purpose that's why

00:42:09,700 --> 00:42:14,490
trio programs has some some qualities

00:42:12,160 --> 00:42:18,010
that 18k programs probably never will

00:42:14,490 --> 00:42:20,470
but I think that the current async IO

00:42:18,010 --> 00:42:22,619
way of doing things they getting the

00:42:20,470 --> 00:42:25,510
task object it's flexible enough and

00:42:22,619 --> 00:42:27,339
people will do just fine if we give them

00:42:25,510 --> 00:42:29,740
enough primitives like task groups to

00:42:27,339 --> 00:42:35,680
work with them and coherent way okay

00:42:29,740 --> 00:42:38,339
thanks we have done for one more short

00:42:35,680 --> 00:42:38,339
question

00:42:48,770 --> 00:42:55,760
hi is there a difference between context

00:42:51,780 --> 00:42:55,760
variables and dynamic variables in Lisp

00:42:56,620 --> 00:43:02,410
so back then when we had those 900

00:42:59,350 --> 00:43:05,020
emails on Python ideas and Python there

00:43:02,410 --> 00:43:07,870
PI I knew the answer and they I was able

00:43:05,020 --> 00:43:09,880
to articulate at 20 or 30 times now I

00:43:07,870 --> 00:43:12,250
don't remember it like like all the

00:43:09,880 --> 00:43:16,720
differences between dynamic scoping and

00:43:12,250 --> 00:43:19,420
and context variables one one particular

00:43:16,720 --> 00:43:22,240
difference is that context is basically

00:43:19,420 --> 00:43:25,750
an immutable mating in memories so once

00:43:22,240 --> 00:43:28,090
you capture it it loses the this link

00:43:25,750 --> 00:43:30,850
with the old context where it where it

00:43:28,090 --> 00:43:33,640
came from so you it won't see updates in

00:43:30,850 --> 00:43:35,260
their original parent context so this is

00:43:33,640 --> 00:43:36,340
probably the key difference but there

00:43:35,260 --> 00:43:38,740
are some other differences

00:43:36,340 --> 00:43:43,350
unfortunate I don't remember them all

00:43:38,740 --> 00:43:43,350
Thanks thanks so much

00:43:45,000 --> 00:43:48,099

YouTube URL: https://www.youtube.com/watch?v=ReXxO_azV-w


