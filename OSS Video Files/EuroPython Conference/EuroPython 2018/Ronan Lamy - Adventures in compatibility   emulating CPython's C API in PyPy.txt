Title: Ronan Lamy - Adventures in compatibility   emulating CPython's C API in PyPy
Publication date: 2018-08-22
Playlist: EuroPython 2018
Description: 
	Adventures in compatibility: emulating CPython's C API in PyPy
[EuroPython 2018 - Talk - 2018-07-25 - Smarkets]
[Edinburgh, UK]

By Ronan Lamy

PyPy is a fast and compliant implementation of Python. In other words, it's an interpreter for the Python language that can act as a full replacement for the reference interpreter, CPython. It's optimised to enable efficient just-in-time compilation of Python code to machine code, and has releases matching versions 2.7, 3.5 and soon(ish) 3.6. The PyPy project also developed cffi as a clean and efficient way of interfacing with C code.

However, many libraries in the Python ecosystem are implemented as C extensions, which target CPython's C API. Many others use Cython, which builds C extensions under the hood. Therefore, PyPy needs an emulation layer for the C API. 

This emulation needs to bridge the differences between the implementation languages and the object models of CPython and PyPy. The solution is called cpyext. It's implemented in a mixture of RPython and C, with most of the API functions and macros implemented in RPython. cpyext exposes PyObjects to the extension code that appear similar to CPython objects (as long as extension writers stay within the fuzzily defined boundaries of the public API) but are merely 'shadows' of the real PyPy objects.

After a brief presentation of PyPy, its goals, and its current statuts and roadmap, this talk will dive into the vexed topic of its handling of C extensions.  By the end of it, the audience should understand the operating principles of cpyext and have a clearer understanding of what happens when you install and run numpy, for instance, on top of PyPy. Some basic familiarity with CPython internals and how C extensions are made will be assumed.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2018.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:07,040 --> 00:00:15,559
so first a few words about me I have

00:00:11,389 --> 00:00:20,359
been pipe I co-developers for about six

00:00:15,559 --> 00:00:26,270
years now and well it's basically my job

00:00:20,359 --> 00:00:30,830
to work on open source and consulting

00:00:26,270 --> 00:00:33,110
related to it I have made a new Twitter

00:00:30,830 --> 00:00:40,940
how original

00:00:33,110 --> 00:00:43,130
so this talk so before diving in to see

00:00:40,940 --> 00:00:47,620
extensions and how support I mean by PI

00:00:43,130 --> 00:00:51,649
which is what's called C by xed just

00:00:47,620 --> 00:00:53,899
quick introduction to pi PI and a few

00:00:51,649 --> 00:00:56,899
words about what we're doing at the

00:00:53,899 --> 00:00:58,700
moment especially because this is I

00:00:56,899 --> 00:01:02,629
think the only pipe I talked the

00:00:58,700 --> 00:01:05,689
conference so pi PI

00:01:02,629 --> 00:01:07,640
that's our elevator pitch pi PI is a

00:01:05,689 --> 00:01:12,250
fast compliant alternative

00:01:07,640 --> 00:01:17,830
implementation of the Python language so

00:01:12,250 --> 00:01:24,320
what it means well first it means that

00:01:17,830 --> 00:01:28,909
we run Python programs but more than

00:01:24,320 --> 00:01:31,520
that we try to be compliant with well

00:01:28,909 --> 00:01:35,450
the specification of the Python language

00:01:31,520 --> 00:01:40,100
which as you probably know is just the

00:01:35,450 --> 00:01:43,430
source code of C Python so that causes a

00:01:40,100 --> 00:01:52,640
few issues but nevertheless we managed

00:01:43,430 --> 00:02:00,110
to to do that and to provide very decent

00:01:52,640 --> 00:02:03,290
speed for Python programs so to have an

00:02:00,110 --> 00:02:07,280
idea of the architecture of pi PI I like

00:02:03,290 --> 00:02:11,810
to start from the architecture of C

00:02:07,280 --> 00:02:18,790
Python which is a bit simpler so well -

00:02:11,810 --> 00:02:20,540
is written in C as you know and in the

00:02:18,790 --> 00:02:22,819
Python

00:02:20,540 --> 00:02:24,379
suitable you have two main parts you

00:02:22,819 --> 00:02:27,170
have the compiler that takes a source

00:02:24,379 --> 00:02:29,540
code turns it into byte code and you

00:02:27,170 --> 00:02:34,579
have the bytecode interpreter that takes

00:02:29,540 --> 00:02:36,609
each byte code and runs specific

00:02:34,579 --> 00:02:44,769
operation corresponding to the byte code

00:02:36,609 --> 00:02:49,639
pi PI it's quite similar except that

00:02:44,769 --> 00:02:51,829
well in the interpreter on top of the

00:02:49,639 --> 00:02:57,609
bytecode interpreter we have

00:02:51,829 --> 00:02:57,609
just-in-time compiler that works by

00:02:57,879 --> 00:03:07,639
observing hot loops in in the code well

00:03:04,099 --> 00:03:17,450
any sort of code that runs often and

00:03:07,639 --> 00:03:22,430
then this code is traced analyzed and so

00:03:17,450 --> 00:03:26,030
that it gets runtime information on the

00:03:22,430 --> 00:03:35,709
types and with this it automates

00:03:26,030 --> 00:03:41,810
optimized machine code now the the magic

00:03:35,709 --> 00:03:46,629
in in pi PI comes mostly from the a

00:03:41,810 --> 00:03:50,329
Python tool chain up there which

00:03:46,629 --> 00:03:54,949
generates more or less automatically the

00:03:50,329 --> 00:03:57,440
destined compiler and also add other

00:03:54,949 --> 00:04:06,530
features that work with wizard jet like

00:03:57,440 --> 00:04:09,769
the GC and the other good thing about

00:04:06,530 --> 00:04:16,039
this tool chain is that the language we

00:04:09,769 --> 00:04:21,919
use is a Python which is a subset of

00:04:16,039 --> 00:04:24,430
Python so we can easily test the

00:04:21,919 --> 00:04:24,430
interpreter

00:04:26,120 --> 00:04:38,960
now not a difference between cpython and

00:04:33,290 --> 00:04:44,950
pi PI it's to do with memory management

00:04:38,960 --> 00:04:52,280
so in C Python it's well it's just

00:04:44,950 --> 00:04:56,330
standard C application so it uses just

00:04:52,280 --> 00:04:59,930
malloc and free and all that which is

00:04:56,330 --> 00:05:02,419
not ideal for an interpreter that tends

00:04:59,930 --> 00:05:10,580
to allocate small objects in random

00:05:02,419 --> 00:05:14,210
places all the time and and also due to

00:05:10,580 --> 00:05:21,610
this simplistic model C Python needs to

00:05:14,210 --> 00:05:27,040
update reference counts all the time and

00:05:21,610 --> 00:05:27,040
contrast pi pi has quite performant

00:05:27,639 --> 00:05:37,430
garbage collector which is specially

00:05:30,080 --> 00:05:43,479
tuned for Python and that way and also

00:05:37,430 --> 00:05:48,080
it it works well with the with digit and

00:05:43,479 --> 00:05:51,710
well unless the knobs available user

00:05:48,080 --> 00:05:56,210
diff different which is when at which

00:05:51,710 --> 00:05:57,830
time does the location happen in pi PI

00:05:56,210 --> 00:06:00,470
since we have a garbage collector

00:05:57,830 --> 00:06:02,000
it's the allocation happens when the

00:06:00,470 --> 00:06:03,289
object is collected by the garbage

00:06:02,000 --> 00:06:06,680
collector

00:06:03,289 --> 00:06:11,960
whereas in C Python it's when the

00:06:06,680 --> 00:06:15,090
reference counts hits zero which happens

00:06:11,960 --> 00:06:17,730
because you've told

00:06:15,090 --> 00:06:20,360
the interpreter to decrement reference

00:06:17,730 --> 00:06:28,970
them so in cpython you know when

00:06:20,360 --> 00:06:32,550
irrigation happens usually but and

00:06:28,970 --> 00:06:33,930
another well the most interesting

00:06:32,550 --> 00:06:40,830
difference between pi PI and C Python

00:06:33,930 --> 00:06:45,360
its speed so people often say that pi pi

00:06:40,830 --> 00:06:50,940
provides magic speed ups and it it often

00:06:45,360 --> 00:06:53,700
does but it can do more than that it's

00:06:50,940 --> 00:06:55,620
true that well if you're lucky you can

00:06:53,700 --> 00:06:59,070
have your program that used to run on C

00:06:55,620 --> 00:07:04,410
Python try pi PI and cool it's twice

00:06:59,070 --> 00:07:07,470
faster that sounds great but actually if

00:07:04,410 --> 00:07:10,830
you in such a case if you try to

00:07:07,470 --> 00:07:13,050
optimize for pi pi you can get your code

00:07:10,830 --> 00:07:17,430
to be four times faster than on c python

00:07:13,050 --> 00:07:22,010
so why stop at just running pi PI you

00:07:17,430 --> 00:07:24,750
want to read the benefits optimize and

00:07:22,010 --> 00:07:29,760
well as usual if you want to optimize

00:07:24,750 --> 00:07:36,200
you first need to have good benchmarks

00:07:29,760 --> 00:07:39,030
and a good benchmark is something you

00:07:36,200 --> 00:07:41,070
really care about so it's not micro

00:07:39,030 --> 00:07:45,780
benchmark it's not a test

00:07:41,070 --> 00:07:50,610
it's something that matches the way you

00:07:45,780 --> 00:07:54,120
really use your code and once you have a

00:07:50,610 --> 00:07:59,960
benchmark well you should use a profiler

00:07:54,120 --> 00:08:03,510
to find the hot parts of the code and

00:07:59,960 --> 00:08:08,130
when pipe is basically only one provider

00:08:03,510 --> 00:08:12,780
that understands pi PI it's called VM

00:08:08,130 --> 00:08:17,949
probe and once you've done that then you

00:08:12,780 --> 00:08:23,140
can actually modify

00:08:17,949 --> 00:08:24,419
the code and few pointers for doing that

00:08:23,140 --> 00:08:30,699
[Music]

00:08:24,419 --> 00:08:33,310
first you need to avoid dynamic features

00:08:30,699 --> 00:08:35,740
at at runtime so at least in inner loops

00:08:33,310 --> 00:08:39,039
so it's going to use metaprogramming as

00:08:35,740 --> 00:08:42,760
much as you want before you run your

00:08:39,039 --> 00:08:44,649
main computation but in the inner loop

00:08:42,760 --> 00:08:53,890
there should be none of that

00:08:44,649 --> 00:08:57,010
and but what a side benefit of having a

00:08:53,890 --> 00:08:59,699
JIT is that you can use function calls

00:08:57,010 --> 00:09:05,350
because they because function calls are

00:08:59,699 --> 00:09:08,709
usually in line by a fighter jet so well

00:09:05,350 --> 00:09:13,899
so feel free to structure your code and

00:09:08,709 --> 00:09:16,209
there are a few optimizations that you

00:09:13,899 --> 00:09:20,860
need to be aware of in order to hit them

00:09:16,209 --> 00:09:27,970
and and or to avoid disabling them by

00:09:20,860 --> 00:09:32,010
accident so the one is that attribute

00:09:27,970 --> 00:09:38,680
access on instances is well optimized

00:09:32,010 --> 00:09:41,980
the effectively it's as if every class

00:09:38,680 --> 00:09:45,220
had a slot declaration and you don't

00:09:41,980 --> 00:09:50,470
need to look up an attribute name in a

00:09:45,220 --> 00:09:52,870
dict and the other thing is that we have

00:09:50,470 --> 00:09:55,720
what we call list strategies so when you

00:09:52,870 --> 00:09:59,350
have a list that contains a homogeneous

00:09:55,720 --> 00:10:02,560
list containing built-in types like int

00:09:59,350 --> 00:10:09,029
or float then access would be very fast

00:10:02,560 --> 00:10:14,649
it's as if you're in indexing or C array

00:10:09,029 --> 00:10:18,579
so let's have a few words about the

00:10:14,649 --> 00:10:23,800
current status I'll start by Python 3 so

00:10:18,579 --> 00:10:29,230
we've we have a we had our first fully

00:10:23,800 --> 00:10:31,990
supported release of well of any PI pi

00:10:29,230 --> 00:10:36,150
PI 3 last Christmas

00:10:31,990 --> 00:10:40,540
the latest version was released in April

00:10:36,150 --> 00:10:45,820
so we what we support is 3.5 at the

00:10:40,540 --> 00:10:49,530
moment and it's well just there are

00:10:45,820 --> 00:10:57,310
still things missing on windows but it's

00:10:49,530 --> 00:11:00,910
fully supported on Linux Mac BSD and so

00:10:57,310 --> 00:11:06,910
what we're working on its three point

00:11:00,910 --> 00:11:13,900
six we are about half way which is

00:11:06,910 --> 00:11:17,560
always a hard thing to say but I hope

00:11:13,900 --> 00:11:21,640
there's not that much left at least the

00:11:17,560 --> 00:11:26,170
main syntax features are there now it's

00:11:21,640 --> 00:11:30,190
only the details and and for Python 3 we

00:11:26,170 --> 00:11:34,720
need to work on more optimizations for

00:11:30,190 --> 00:11:37,660
things that well for things that didn't

00:11:34,720 --> 00:11:43,530
exist in a Python to the fact that we

00:11:37,660 --> 00:11:46,810
have Unicode everywhere async stuff is

00:11:43,530 --> 00:11:47,140
we need to find ways to make it a bit

00:11:46,810 --> 00:11:51,190
better

00:11:47,140 --> 00:11:58,420
it's decent but it could be better

00:11:51,190 --> 00:12:01,410
and well that it will Python 3 peyten

00:11:58,420 --> 00:12:07,780
- had a release at the same time as the

00:12:01,410 --> 00:12:11,740
items three and so in this release apart

00:12:07,780 --> 00:12:14,020
from the well yeah in this release we

00:12:11,740 --> 00:12:19,710
mainly had fewer incremental

00:12:14,020 --> 00:12:25,360
improvements so well I remind you that

00:12:19,710 --> 00:12:28,930
CF fi is still the the best way to to

00:12:25,360 --> 00:12:33,280
talk to to C code and it keeps being

00:12:28,930 --> 00:12:38,130
updated with every type i but the main

00:12:33,280 --> 00:12:42,310
highlight of the last release was the

00:12:38,130 --> 00:12:49,720
improvements to the extension

00:12:42,310 --> 00:12:52,930
compatibility and speed and so now you

00:12:49,720 --> 00:13:00,130
can peep install the main scientific

00:12:52,930 --> 00:13:04,630
libraries and we have a few wheels that

00:13:00,130 --> 00:13:09,460
you can check because they not you have

00:13:04,630 --> 00:13:15,790
no pie pie wheels on pi TI because of

00:13:09,460 --> 00:13:21,760
issues with many linux so if you use pi

00:13:15,790 --> 00:13:30,040
PI check out this website and you'll get

00:13:21,760 --> 00:13:36,130
binary wheels so with this I start main

00:13:30,040 --> 00:13:41,110
part of the talk which is C PI X so C PI

00:13:36,130 --> 00:13:47,589
X well what is C pi X really as a user

00:13:41,110 --> 00:13:50,920
you could just think of it as 500 H for

00:13:47,589 --> 00:13:56,320
pi PI when you want to when you need to

00:13:50,920 --> 00:13:56,930
to compile C extension you link it

00:13:56,320 --> 00:13:58,990
against

00:13:56,930 --> 00:14:04,220
[Music]

00:13:58,990 --> 00:14:06,080
you can pile it against 500 H well we do

00:14:04,220 --> 00:14:07,120
that once a Python and on pi PI you do

00:14:06,080 --> 00:14:13,550
exactly the same

00:14:07,120 --> 00:14:18,740
and with this Python that H the compiler

00:14:13,550 --> 00:14:22,790
will know where to find the actual C

00:14:18,740 --> 00:14:29,510
function you want to call from you from

00:14:22,790 --> 00:14:36,880
the extension so what in C pi X well

00:14:29,510 --> 00:14:43,790
this Python that H is mostly generated

00:14:36,880 --> 00:14:48,380
during the pi PI build and we have a bit

00:14:43,790 --> 00:14:51,710
of C code that sort of handwritten C

00:14:48,380 --> 00:14:55,370
code which is mostly a copy from C

00:14:51,710 --> 00:15:02,440
Python but most of the implementation

00:14:55,370 --> 00:15:08,150
comes from our a Python implementation

00:15:02,440 --> 00:15:13,790
and well what does it look like looks

00:15:08,150 --> 00:15:18,200
like this so this is a Python code this

00:15:13,790 --> 00:15:24,590
is the code that implements PI list set

00:15:18,200 --> 00:15:27,250
item and if you've already looked at the

00:15:24,590 --> 00:15:30,980
C Python source you'll notice that it's

00:15:27,250 --> 00:15:36,460
mostly the same logic will have some

00:15:30,980 --> 00:15:44,660
error checking and then we find where

00:15:36,460 --> 00:15:47,990
the well we fetch the place where we

00:15:44,660 --> 00:15:52,160
store some item in the list and we

00:15:47,990 --> 00:15:56,090
update and and we do add a craft because

00:15:52,160 --> 00:15:59,480
the old object is not we're friends

00:15:56,090 --> 00:16:02,270
anymore so this is well this looks quite

00:15:59,480 --> 00:16:06,290
simple and this is the good thing is

00:16:02,270 --> 00:16:08,750
that it is debuggable and testable

00:16:06,290 --> 00:16:15,680
because it is

00:16:08,750 --> 00:16:19,329
using our Python however this hides a

00:16:15,680 --> 00:16:23,060
lot of complexity which is in this

00:16:19,329 --> 00:16:27,350
decorator at the top and this decorator

00:16:23,060 --> 00:16:30,350
at the top does all the magic of moving

00:16:27,350 --> 00:16:34,850
between the C world and the a Python

00:16:30,350 --> 00:16:50,889
world and there's quite a lot of thing

00:16:34,850 --> 00:16:56,930
to do like I call that that and so what

00:16:50,889 --> 00:17:01,819
do we need to do to make C pious work so

00:16:56,930 --> 00:17:04,039
we have to a very different world when

00:17:01,819 --> 00:17:05,539
when we have a C extension that tries to

00:17:04,039 --> 00:17:08,179
talk to the pi PI

00:17:05,539 --> 00:17:11,360
interpreter so the fermentation

00:17:08,179 --> 00:17:16,870
languages are different but this means

00:17:11,360 --> 00:17:21,079
that the internal object structures

00:17:16,870 --> 00:17:26,600
different we have completely different

00:17:21,079 --> 00:17:28,760
memory model in inside pi PI we have

00:17:26,600 --> 00:17:30,980
managed memory we have a garbage

00:17:28,760 --> 00:17:40,039
collector that can move the objects

00:17:30,980 --> 00:17:43,070
around and but that's quite incompatible

00:17:40,039 --> 00:17:46,720
with the same model where you refer to

00:17:43,070 --> 00:17:51,830
things using pointers and pointers

00:17:46,720 --> 00:17:56,809
basically locations in memory so things

00:17:51,830 --> 00:18:00,260
move around C code gets confused and pi

00:17:56,809 --> 00:18:02,200
PI we have also a lot more control on on

00:18:00,260 --> 00:18:05,840
what's going on

00:18:02,200 --> 00:18:09,679
we have exceptions that can propagate

00:18:05,840 --> 00:18:13,120
and so we have internal exception inside

00:18:09,679 --> 00:18:13,120
interpreter that used

00:18:13,260 --> 00:18:22,330
for instance to implement the user level

00:18:17,460 --> 00:18:24,820
exceptions and but on inside the C

00:18:22,330 --> 00:18:30,400
extensions as well there are no

00:18:24,820 --> 00:18:32,770
exceptions in C so extensions need to

00:18:30,400 --> 00:18:35,169
set the thing called an error indicator

00:18:32,770 --> 00:18:40,380
that the interpreter needs to check from

00:18:35,169 --> 00:18:46,450
time to time also C extensions need to

00:18:40,380 --> 00:18:49,990
deal with ref count because you well you

00:18:46,450 --> 00:18:54,309
need to know when an object can be

00:18:49,990 --> 00:18:56,830
de-allocated and but in fact by PI we

00:18:54,309 --> 00:19:03,279
have garbage collector so we don't worry

00:18:56,830 --> 00:19:09,029
about that at all and so how do we

00:19:03,279 --> 00:19:14,350
bridge this and the main idea is to have

00:19:09,029 --> 00:19:18,070
these see objects linked to Python

00:19:14,350 --> 00:19:21,700
objects so they so that they are

00:19:18,070 --> 00:19:26,890
basically just proxies for for the

00:19:21,700 --> 00:19:31,330
actual object and the specific mechanism

00:19:26,890 --> 00:19:36,730
is just this line here so if you if you

00:19:31,330 --> 00:19:42,789
know C Python you notice that this up

00:19:36,730 --> 00:19:48,190
pipe Island is the only difference with

00:19:42,789 --> 00:19:54,870
what C Python does and this up pipe I

00:19:48,190 --> 00:19:59,279
link allows the allows sip IX layer to

00:19:54,870 --> 00:20:11,409
query the memory manager in order to

00:19:59,279 --> 00:20:17,350
find the the pipe I object and well and

00:20:11,409 --> 00:20:21,100
then it's just a matter of what a small

00:20:17,350 --> 00:20:24,510
matter of programming to implement all

00:20:21,100 --> 00:20:27,710
the C semantics so you need

00:20:24,510 --> 00:20:32,460
remember you're in crafts and decorous

00:20:27,710 --> 00:20:39,720
when you are implementing API functions

00:20:32,460 --> 00:20:47,280
in Python and but there are more

00:20:39,720 --> 00:20:51,179
problems like what do you do when if you

00:20:47,280 --> 00:20:53,340
want to call C function from Python

00:20:51,179 --> 00:21:00,120
which is the whole point of having a C

00:20:53,340 --> 00:21:03,360
extension and and so that's why we we

00:21:00,120 --> 00:21:07,420
have these magic decorators that handle

00:21:03,360 --> 00:21:09,260
the transformation magically and

00:21:07,420 --> 00:21:14,340
[Music]

00:21:09,260 --> 00:21:17,550
basically you know we had levels of

00:21:14,340 --> 00:21:21,860
indirection anytime we anytime we need

00:21:17,550 --> 00:21:26,670
to cross the boundary anytime there's

00:21:21,860 --> 00:21:28,980
some something to check because we are

00:21:26,670 --> 00:21:29,570
back from the see world where anything

00:21:28,980 --> 00:21:31,160
can happen

00:21:29,570 --> 00:21:40,200
[Music]

00:21:31,160 --> 00:21:44,220
so that's the general idea but well you

00:21:40,200 --> 00:21:48,360
probably know the rest of this quote or

00:21:44,220 --> 00:21:49,770
actually folks saying which is that all

00:21:48,360 --> 00:21:51,510
problems in computer science can be

00:21:49,770 --> 00:21:54,000
solved by another level of indirection

00:21:51,510 --> 00:21:59,730
except the problem of too many layers of

00:21:54,000 --> 00:22:02,130
indirection and we've recently noticed

00:21:59,730 --> 00:22:06,230
that we had too many layers of

00:22:02,130 --> 00:22:13,320
indirection so this was last year in

00:22:06,230 --> 00:22:15,540
Capetown and we've started to improve

00:22:13,320 --> 00:22:23,390
the performance of CPX

00:22:15,540 --> 00:22:27,300
so as I said crossing this boundary is

00:22:23,390 --> 00:22:31,320
it's expensive and because we have this

00:22:27,300 --> 00:22:36,090
magic going on we do it even without

00:22:31,320 --> 00:22:38,250
realizing because we can just we don't

00:22:36,090 --> 00:22:41,340
need to explicitly convert

00:22:38,250 --> 00:22:47,610
between the SeaWorld and pie-pie world

00:22:41,340 --> 00:22:54,120
it happens behind the scenes so we need

00:22:47,610 --> 00:22:57,690
to be more careful about that and by

00:22:54,120 --> 00:23:02,510
being more careful we can remove a lot

00:22:57,690 --> 00:23:05,549
of of this back and forth because it's

00:23:02,510 --> 00:23:13,470
you know in many cases it turned out to

00:23:05,549 --> 00:23:16,710
be completely useless and well it's an

00:23:13,470 --> 00:23:20,090
extension of this idea which is when you

00:23:16,710 --> 00:23:23,820
have an operation that can happen

00:23:20,090 --> 00:23:29,840
completely on the on the seaside then we

00:23:23,820 --> 00:23:33,510
should just implement it in C and never

00:23:29,840 --> 00:23:38,400
cross the boundary so well this requires

00:23:33,510 --> 00:23:40,770
some care as well because the because of

00:23:38,400 --> 00:23:46,260
the different and underlying assumptions

00:23:40,770 --> 00:23:52,080
of of pipe Island of the sea world but

00:23:46,260 --> 00:23:55,169
it's possible and and what we've started

00:23:52,080 --> 00:24:00,000
doing it it's not complete but the

00:23:55,169 --> 00:24:01,290
results are here so in blue it's just C

00:24:00,000 --> 00:24:05,780
Python as a reference

00:24:01,290 --> 00:24:10,770
Green is PI pi before these

00:24:05,780 --> 00:24:14,790
optimizations and red is after and this

00:24:10,770 --> 00:24:20,820
is a bunch of rather silly micro

00:24:14,790 --> 00:24:24,150
benchmark so that we just check the well

00:24:20,820 --> 00:24:28,080
the overhead of each specific operation

00:24:24,150 --> 00:24:32,660
so we used to be between four and six

00:24:28,080 --> 00:24:37,080
times slower than C Python and now we

00:24:32,660 --> 00:24:41,040
between the same speed and 50% faster so

00:24:37,080 --> 00:24:51,760
there's hope for the speed of C pi axed

00:24:41,040 --> 00:24:57,610
and and the future well it's too

00:24:51,760 --> 00:25:00,100
continue working on on this we can talk

00:24:57,610 --> 00:25:02,680
there were a few red bar that while we

00:25:00,100 --> 00:25:06,910
were still a lot slower than C Python

00:25:02,680 --> 00:25:12,210
it's probably doable to be faster than C

00:25:06,910 --> 00:25:12,210
Python no cases just requires work and

00:25:13,050 --> 00:25:19,750
and well we have pi PI open space this

00:25:17,140 --> 00:25:22,900
just this afternoon at 2:00 so if you

00:25:19,750 --> 00:25:26,410
want to come discuss with your own pipe

00:25:22,900 --> 00:25:30,270
our problems or new ideas and well

00:25:26,410 --> 00:25:30,270
that's it waiting for your questions

00:25:35,640 --> 00:25:39,060
anyone questions

00:25:49,200 --> 00:25:58,590
were there any extensions that this PI X

00:25:54,660 --> 00:26:02,040
was written in mind for or is it just

00:25:58,590 --> 00:26:09,650
for the general case and does that make

00:26:02,040 --> 00:26:12,780
sense so no it's for the general case

00:26:09,650 --> 00:26:18,180
well there are extensions we've been

00:26:12,780 --> 00:26:20,490
using as tests and also because there

00:26:18,180 --> 00:26:24,690
are extensions we really we would really

00:26:20,490 --> 00:26:32,360
like to make compatible with by pipe and

00:26:24,690 --> 00:26:32,360
well it was mainly numpy and it's now

00:26:32,900 --> 00:26:52,310
fully supports pi PI now I think no

00:26:43,800 --> 00:26:55,350
because I don't know sorry Harris one

00:26:52,310 --> 00:27:01,200
when will my PI drop support the plate

00:26:55,350 --> 00:27:03,530
into the current official answer is

00:27:01,200 --> 00:27:03,530
never

00:27:05,780 --> 00:27:19,530
reasons for that well a lot of our users

00:27:12,360 --> 00:27:27,150
are still on Python 2 and our tool chain

00:27:19,530 --> 00:27:33,420
is implemented in Python 2 so that's not

00:27:27,150 --> 00:27:38,640
motivation and and also as language

00:27:33,420 --> 00:27:43,410
implementers we quite happy to have

00:27:38,640 --> 00:27:46,650
something that doesn't change and so

00:27:43,410 --> 00:27:54,750
well that these are all the reason why

00:27:46,650 --> 00:27:59,140
pi pi likes python 2 and we see no no

00:27:54,750 --> 00:28:04,630
real reason to drop Python 2 we

00:27:59,140 --> 00:28:06,430
I have to to brown trees for Python to

00:28:04,630 --> 00:28:09,370
in Python tree that share a lot of code

00:28:06,430 --> 00:28:20,020
so it's not a major burden to keep

00:28:09,370 --> 00:28:23,260
supporting Python to visa I have a

00:28:20,020 --> 00:28:26,620
question about air Python yes how is it

00:28:23,260 --> 00:28:31,410
related to C Python is it subset or

00:28:26,620 --> 00:28:39,180
something like that well it is a subset

00:28:31,410 --> 00:28:42,940
so it you can run our Python code as

00:28:39,180 --> 00:28:47,830
Python code and that's what we do a lot

00:28:42,940 --> 00:28:52,240
for testing and that's quite convenient

00:28:47,830 --> 00:28:56,740
but the but the exact definition of a

00:28:52,240 --> 00:29:03,280
Python is just the subset of Python that

00:28:56,740 --> 00:29:06,670
can be understood by the tool chain so

00:29:03,280 --> 00:29:09,610
what about site and does this extension

00:29:06,670 --> 00:29:12,480
a compatibility layer make us my pi PI

00:29:09,610 --> 00:29:19,360
compatible with seitan yes yes

00:29:12,480 --> 00:29:21,730
seitan is fully well I won't say fully

00:29:19,360 --> 00:29:24,370
because there's one piece of code inside

00:29:21,730 --> 00:29:27,910
and that's supplied on specific but

00:29:24,370 --> 00:29:32,410
apart from that seitan is fully

00:29:27,910 --> 00:29:36,070
supported and extensions that use seitan

00:29:32,410 --> 00:29:39,220
now work on on pipe I scikit-learn

00:29:36,070 --> 00:29:41,470
which uses a lot of Titan now has

00:29:39,220 --> 00:29:45,100
experimental support for pi pipe for

00:29:41,470 --> 00:29:53,030
instance and the XML has supported by PI

00:29:45,100 --> 00:29:59,670
for years thank you very much

00:29:53,030 --> 00:29:59,670

YouTube URL: https://www.youtube.com/watch?v=qH0eeh-4XE8


