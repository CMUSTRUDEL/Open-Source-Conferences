Title: Antonio Verardi, Flavien Raynaud - How to write Rust instead of C, and get away with it yes, it's a
Publication date: 2018-08-22
Playlist: EuroPython 2018
Description: 
	How to write Rust instead of C, and get away with it (yes, it's a Python talk)
[EuroPython 2018 - Talk - 2018-07-25 - Lammermuir]
[Edinburgh, UK]

By Antonio Verardi, Flavien Raynaud

Have you ever tried optimizing a super-slow Python application and thought: “Oh! I wish I could just write this bit it in Rust”? Well, turns out you can!
We will show you how Rust is a better alternative than C to make your programs lightning fast, and how to get away with it; without your users even noticing.

As Infrastructure Engineers at Yelp, the challenge we face everyday is: scale. Yelp is mostly a Python shop and while this is great for development velocity, our work often revolves around making Python applications run faster. Until now, we have been using different techniques: faster interpreters, or, more often, C code.

Given its safety guarantees, performance and promise of better tooling than C, we decided we had to give Rust a try. The initial results helped reinforce that there was a lot of opportunity for Rust to play an important role in our production code.

Yelp heavily relies on the Apache Avro (https://avro.apache.org/) serialization format for its internal infrastructure. During the talk, we will show how we implemented an Avro serialization/deserialization library in Rust, how we were able to call it from Python (and in theory from any other language) with very little code, using tools such as cbindgen (https://github.com/eqrion/cbindgen/), CFFI (https://cffi.readthedocs.io/en/latest/) and Milksnake (https://github.com/getsentry/milksnake/).

This talk would outline how easy it is to write performant code in a language like Rust and call it from Python applications without users even realizing it, making this a great solution for production services.



License: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/
Please see our speaker release agreement for details: https://ep2018.europython.eu/en/speaker-release-agreement/
Captions: 
	00:00:00,490 --> 00:00:09,420
[Applause]

00:00:06,230 --> 00:00:11,190
cool good morning everyone and welcome

00:00:09,420 --> 00:00:11,940
to how to write trust instead of C and

00:00:11,190 --> 00:00:14,610
get away with it

00:00:11,940 --> 00:00:17,039
so Antonio and I both are software

00:00:14,610 --> 00:00:19,380
engineers at Yelp and we're here today

00:00:17,039 --> 00:00:21,930
to guide you through it so first of all

00:00:19,380 --> 00:00:23,220
we work for y'all's mission basically is

00:00:21,930 --> 00:00:28,859
connecting people with grade level

00:00:23,220 --> 00:00:30,300
businesses so yeah let's get started so

00:00:28,859 --> 00:00:33,450
first why are we here

00:00:30,300 --> 00:00:35,100
so Yelp it's mostly a Python shop so you

00:00:33,450 --> 00:00:37,350
can imagine like a user visiting the

00:00:35,100 --> 00:00:39,660
website and hitting some Python code and

00:00:37,350 --> 00:00:41,940
our use cases today would be data

00:00:39,660 --> 00:00:45,329
sterilization and so we rely a lot on

00:00:41,940 --> 00:00:47,750
the for Michael Avro Apache avril you

00:00:45,329 --> 00:00:51,239
can think Jason but binary with schemas

00:00:47,750 --> 00:00:53,340
so you have your user eating compiling

00:00:51,239 --> 00:00:56,039
code we do need to do data sterilization

00:00:53,340 --> 00:00:58,530
in Avro using the official Avro library

00:00:56,039 --> 00:01:00,600
written in Python then we get back the

00:00:58,530 --> 00:01:02,690
data magic happens and you get like

00:01:00,600 --> 00:01:06,000
great reviews for great local businesses

00:01:02,690 --> 00:01:08,549
so very quickly how other looks like so

00:01:06,000 --> 00:01:11,340
as I said you'd find a schema so this is

00:01:08,549 --> 00:01:13,650
how a schema looks like you just define

00:01:11,340 --> 00:01:15,630
like some it's just a JSON schema that's

00:01:13,650 --> 00:01:18,930
not gonna be inside your data but just

00:01:15,630 --> 00:01:22,470
needs you needed to encode your data so

00:01:18,930 --> 00:01:25,140
it's a Segura's asian format so who say

00:01:22,470 --> 00:01:26,939
sorry ization says usually hardened cpu

00:01:25,140 --> 00:01:30,509
and it's not where python usually shines

00:01:26,939 --> 00:01:32,159
a good example of our data I like if you

00:01:30,509 --> 00:01:33,360
take this this schema with the quick

00:01:32,159 --> 00:01:35,490
instance like in JSON you could look

00:01:33,360 --> 00:01:40,770
like like the first line and in average

00:01:35,490 --> 00:01:43,530
just one bytes so yeah quick flash back

00:01:40,770 --> 00:01:48,899
2004 when Europe was founded it was all

00:01:43,530 --> 00:01:50,759
Python now back to flash forward to 2018

00:01:48,899 --> 00:01:51,329
with the event like docker services

00:01:50,759 --> 00:01:55,140
etcetera

00:01:51,329 --> 00:01:56,610
yup we still mostly by Python but we've

00:01:55,140 --> 00:01:58,979
seen some services written in Java

00:01:56,610 --> 00:02:01,799
something go some and some interest

00:01:58,979 --> 00:02:03,360
nowadays so one of the new use cases you

00:02:01,799 --> 00:02:05,399
could think about would be well you have

00:02:03,360 --> 00:02:07,170
a user that visits Yelp and it hits some

00:02:05,399 --> 00:02:09,390
rest code at some point in the in the

00:02:07,170 --> 00:02:10,679
path and then you need a like a rest

00:02:09,390 --> 00:02:13,019
library to do

00:02:10,679 --> 00:02:15,450
sterilization in using Avril you get but

00:02:13,019 --> 00:02:17,510
data magic happens and you get great

00:02:15,450 --> 00:02:19,980
reviews for great local businesses so

00:02:17,510 --> 00:02:22,709
you can see the scheme coming along like

00:02:19,980 --> 00:02:24,480
well you have some Python code we never

00:02:22,709 --> 00:02:28,019
library within the Python or some rest

00:02:24,480 --> 00:02:29,370
code etc etc good thing about Russ is

00:02:28,019 --> 00:02:31,859
that well Antonia one can get you

00:02:29,370 --> 00:02:37,709
through it bit later but it's safe it's

00:02:31,859 --> 00:02:39,420
fast extra so why not why just here what

00:02:37,709 --> 00:02:42,389
if we could get something like this so

00:02:39,420 --> 00:02:45,180
yeah you have the user on yep that gets

00:02:42,389 --> 00:02:46,739
hits like a Python code it has data

00:02:45,180 --> 00:02:49,769
serialization using a ref library

00:02:46,739 --> 00:02:51,769
instead which is fast fast person I

00:02:49,769 --> 00:02:53,819
think for doing organization hopefully

00:02:51,769 --> 00:02:57,209
magic happens and then you get great

00:02:53,819 --> 00:02:59,909
data yeah so that's pretty much it

00:02:57,209 --> 00:03:03,209
before we move any further let's stop

00:02:59,909 --> 00:03:04,829
for a second and what you bring over be

00:03:03,209 --> 00:03:07,530
bring hopefully by the end of the talk

00:03:04,829 --> 00:03:10,319
so first is well outright rest code in

00:03:07,530 --> 00:03:13,560
Python packages why and when would you

00:03:10,319 --> 00:03:17,340
do that um some Python C and R as facts

00:03:13,560 --> 00:03:19,229
and jokes maybe so there definitely will

00:03:17,340 --> 00:03:23,329
be jokes but they might not be worth

00:03:19,229 --> 00:03:26,549
bringing home so without any further

00:03:23,329 --> 00:03:34,919
wait can relax Antonio introduce you to

00:03:26,549 --> 00:03:36,479
the problem so as flop said before from

00:03:34,919 --> 00:03:39,209
time to time when we are in production

00:03:36,479 --> 00:03:41,189
and we're looking at our Python code we

00:03:39,209 --> 00:03:42,530
look at the matrix we look at the

00:03:41,189 --> 00:03:46,379
application everything is going fine

00:03:42,530 --> 00:03:50,220
body feels kinda slow a little bit

00:03:46,379 --> 00:03:52,859
sluggish and really what we want here to

00:03:50,220 --> 00:03:55,519
do is take in Python from being a snail

00:03:52,859 --> 00:04:00,000
to be something a little bit faster

00:03:55,519 --> 00:04:01,620
remote works great so the first thing

00:04:00,000 --> 00:04:05,699
that you should try to do to make your

00:04:01,620 --> 00:04:09,750
Python code much faster is scaling up or

00:04:05,699 --> 00:04:13,620
out your application and that's it

00:04:09,750 --> 00:04:14,970
really end of the talk we can go 99

00:04:13,620 --> 00:04:17,810
percent of the time this is gonna work

00:04:14,970 --> 00:04:17,810
questions

00:04:18,530 --> 00:04:24,780
okay great I got a smartphone in the

00:04:21,300 --> 00:04:26,270
audience so from time to time this is

00:04:24,780 --> 00:04:28,650
not possible to do because you know

00:04:26,270 --> 00:04:30,840
coast like if you want to spin up one

00:04:28,650 --> 00:04:35,490
under this Santa so no ws is gonna be

00:04:30,840 --> 00:04:38,970
you know a bit of a bill or your you

00:04:35,490 --> 00:04:41,700
know your companyís other options maybe

00:04:38,970 --> 00:04:44,640
takes you know ten days to get a server

00:04:41,700 --> 00:04:48,480
something that so in those cases you may

00:04:44,640 --> 00:04:50,640
try to change interpreter and when I

00:04:48,480 --> 00:04:54,420
mean change interpreter I mean using pi

00:04:50,640 --> 00:04:56,430
PI what else so for the few ones to the

00:04:54,420 --> 00:04:58,410
no PI pi PI pi PI is a another

00:04:56,430 --> 00:05:01,280
interpreter for Python that is going to

00:04:58,410 --> 00:05:03,330
optimize your code based on you know

00:05:01,280 --> 00:05:05,160
just-in-time compilation

00:05:03,330 --> 00:05:07,950
type inference and this kind of stuff

00:05:05,160 --> 00:05:10,170
caching it's very very good and it sure

00:05:07,950 --> 00:05:12,000
it should be your second option as soon

00:05:10,170 --> 00:05:14,250
as you want to speed up your code or

00:05:12,000 --> 00:05:16,920
maybe you can use the first one in the

00:05:14,250 --> 00:05:19,080
second one together they work but in

00:05:16,920 --> 00:05:21,770
case this is not enough then it's time

00:05:19,080 --> 00:05:24,660
for us to bring out the big guns and

00:05:21,770 --> 00:05:27,720
this is the big gun for fighting using

00:05:24,660 --> 00:05:31,080
the C programming languages so as you

00:05:27,720 --> 00:05:33,830
know Python the main interpreter is

00:05:31,080 --> 00:05:37,920
called C Python and is developed in C

00:05:33,830 --> 00:05:40,650
being in C you can write C extension for

00:05:37,920 --> 00:05:43,260
it meaning that you can actually write C

00:05:40,650 --> 00:05:47,180
code compile it and make your Python

00:05:43,260 --> 00:05:50,430
application run the C code seamlessly so

00:05:47,180 --> 00:05:52,170
just you know just to get a feel on the

00:05:50,430 --> 00:05:57,600
crowd here how many people have ever

00:05:52,170 --> 00:06:00,720
written the C extension Wow nice

00:05:57,600 --> 00:06:05,430
how many people like writing C

00:06:00,720 --> 00:06:08,220
extensions yes you get a hang of it so

00:06:05,430 --> 00:06:10,500
nowadays you'll find a lot of projects

00:06:08,220 --> 00:06:14,340
and these celebrating C extensions they

00:06:10,500 --> 00:06:15,780
use C types or C FFI even better so C

00:06:14,340 --> 00:06:18,780
type is a module in the standard library

00:06:15,780 --> 00:06:21,270
C FFI is a library stat also developed

00:06:18,780 --> 00:06:23,610
by the people develop pi pi and some

00:06:21,270 --> 00:06:26,270
others basically what you can do with

00:06:23,610 --> 00:06:30,570
the c types or the C FFI library it's

00:06:26,270 --> 00:06:34,160
calling via the ABI will go for it later

00:06:30,570 --> 00:06:39,000
on functions to being defined and

00:06:34,160 --> 00:06:41,700
codified in a C binary so this way you

00:06:39,000 --> 00:06:43,410
don't need to you know fiddle with all

00:06:41,700 --> 00:06:45,540
the internals of the C Python

00:06:43,410 --> 00:06:47,340
interpreter you can just call these

00:06:45,540 --> 00:06:49,830
external functions pass arguments to

00:06:47,340 --> 00:06:52,290
them and then use the result and this

00:06:49,830 --> 00:06:54,120
also works with both C Python and pi PI

00:06:52,290 --> 00:06:56,490
without much of a difference in good

00:06:54,120 --> 00:06:59,880
performance for both YC extension kinda

00:06:56,490 --> 00:07:03,450
yeah at the moment and our library by ro

00:06:59,880 --> 00:07:05,370
Eris actually uses this approach the

00:07:03,450 --> 00:07:08,580
third option that you have is using

00:07:05,370 --> 00:07:10,770
seitan seitan is a compiler for python

00:07:08,580 --> 00:07:12,630
and it provides you a superset of the

00:07:10,770 --> 00:07:14,760
Python language and basically you can

00:07:12,630 --> 00:07:17,010
write some code and then is going to be

00:07:14,760 --> 00:07:20,310
compiled into C and executed by your

00:07:17,010 --> 00:07:22,980
application first ro the library we are

00:07:20,310 --> 00:07:25,700
gonna compare against uses this approach

00:07:22,980 --> 00:07:27,750
instead one thing to remember about

00:07:25,700 --> 00:07:30,960
seitan is that if you want your

00:07:27,750 --> 00:07:33,930
application to be fast both on pi PI and

00:07:30,960 --> 00:07:35,670
C Python you go that time to duplicate

00:07:33,930 --> 00:07:37,590
your code because the waiver the write

00:07:35,670 --> 00:07:40,410
your code is slightly difference and pi

00:07:37,590 --> 00:07:43,110
PI is in experimental support I believe

00:07:40,410 --> 00:07:45,600
anyway first of all does exactly this it

00:07:43,110 --> 00:07:48,720
has two version of the same code one for

00:07:45,600 --> 00:07:51,120
pi pi and work for c python so since

00:07:48,720 --> 00:07:53,990
we're gonna use c FF 5 for our code let

00:07:51,120 --> 00:07:57,750
me just you know go very very quickly

00:07:53,990 --> 00:07:59,250
through it so this is basically the code

00:07:57,750 --> 00:08:02,700
that you need to UCF refine your

00:07:59,250 --> 00:08:04,740
application basically you need the

00:08:02,700 --> 00:08:06,330
nether file with the Declaration of all

00:08:04,740 --> 00:08:10,140
the symbols so they're going to use and

00:08:06,330 --> 00:08:12,030
the binary file well you know the actual

00:08:10,140 --> 00:08:14,970
functions organy are going to leave any

00:08:12,030 --> 00:08:17,280
extra structs and finally you can call

00:08:14,970 --> 00:08:21,570
all the functions or destruct via the

00:08:17,280 --> 00:08:24,120
object you just created as I mentioned

00:08:21,570 --> 00:08:26,550
before the trick here is using the ABI

00:08:24,120 --> 00:08:28,800
API stands for application binary

00:08:26,550 --> 00:08:31,050
interface and it's just a set of rules

00:08:28,800 --> 00:08:32,849
that can be used to make your Python

00:08:31,050 --> 00:08:35,670
application or any application really

00:08:32,849 --> 00:08:37,680
talk with C functions so basically it's

00:08:35,670 --> 00:08:38,280
a way to put arguments in the stocks to

00:08:37,680 --> 00:08:39,780
read

00:08:38,280 --> 00:08:43,830
returns from the start this kind of

00:08:39,780 --> 00:08:44,790
stuff so basically as the API makes a

00:08:43,830 --> 00:08:47,660
fighter application to

00:08:44,790 --> 00:08:50,910
to see how do we make our rust

00:08:47,660 --> 00:08:53,340
application being called from Python

00:08:50,910 --> 00:08:57,320
application well what do we do is gonna

00:08:53,340 --> 00:09:01,830
be these guys in rust as it was see and

00:08:57,320 --> 00:09:04,200
then would make it work so at this point

00:09:01,830 --> 00:09:06,540
to talk you may ask yes sure this all

00:09:04,200 --> 00:09:09,360
works but this works in C as well so why

00:09:06,540 --> 00:09:12,180
should I bother writing rust instead of

00:09:09,360 --> 00:09:14,550
C well if you're a DS talk you probably

00:09:12,180 --> 00:09:17,700
have heard about rust before right

00:09:14,550 --> 00:09:21,180
say yes known to please great

00:09:17,700 --> 00:09:23,070
so rust as you know very cool features

00:09:21,180 --> 00:09:26,340
if compared to C the first one is

00:09:23,070 --> 00:09:28,980
guaranteed memory safety thanks to the

00:09:26,340 --> 00:09:30,750
ownership to the ownership our team that

00:09:28,980 --> 00:09:33,690
is encoded in the language and borrow

00:09:30,750 --> 00:09:36,060
checker and couple other stuff rust

00:09:33,690 --> 00:09:38,040
guarantees that you won't double free

00:09:36,060 --> 00:09:39,690
memory you want access memory that you

00:09:38,040 --> 00:09:43,200
should not access this kind of stuff and

00:09:39,690 --> 00:09:45,690
if you ever program see you know this is

00:09:43,200 --> 00:09:47,910
fantastic the second thing is

00:09:45,690 --> 00:09:49,890
concurrency without data races again

00:09:47,910 --> 00:09:52,530
thanks to the very smart compiler the

00:09:49,890 --> 00:09:55,770
Rastas third one is zero cost

00:09:52,530 --> 00:09:57,300
obstruction basically you only pay for

00:09:55,770 --> 00:09:59,430
the abstraction you use and this

00:09:57,300 --> 00:10:02,280
obstruction actually much better than C

00:09:59,430 --> 00:10:05,700
you have maps and least and arrays and

00:10:02,280 --> 00:10:07,890
everything and it just work for model

00:10:05,700 --> 00:10:11,070
syntax you an option result but are

00:10:07,890 --> 00:10:14,760
matching them anymore and for and the

00:10:11,070 --> 00:10:17,910
last one is awesome tooling like I love

00:10:14,760 --> 00:10:20,190
the tooling really cargo is amazing if

00:10:17,910 --> 00:10:22,790
you ever tried cargo compiling

00:10:20,190 --> 00:10:25,410
installing new application linting

00:10:22,790 --> 00:10:27,120
format it does everything for you it's

00:10:25,410 --> 00:10:31,020
just amazing and just works even cross

00:10:27,120 --> 00:10:33,420
computation just works now being this

00:10:31,020 --> 00:10:36,270
the problem and our approach I let flood

00:10:33,420 --> 00:10:38,220
black guide you through the other

00:10:36,270 --> 00:10:41,490
library debris brought and that is now

00:10:38,220 --> 00:10:47,040
used as the main our civilization and

00:10:41,490 --> 00:10:49,140
the civilization library for rust thank

00:10:47,040 --> 00:10:51,550
you so let's begin our journey for

00:10:49,140 --> 00:10:53,380
writing rest instead of C and

00:10:51,550 --> 00:10:56,500
everything in Python so first we need

00:10:53,380 --> 00:10:59,560
well some rest code so first how to

00:10:56,500 --> 00:11:01,660
write Avro using rest so we were looking

00:10:59,560 --> 00:11:03,100
on like what we did what anybody would

00:11:01,660 --> 00:11:05,080
do we were opening Google and Stack

00:11:03,100 --> 00:11:08,740
Overflow and looking for elaborate I was

00:11:05,080 --> 00:11:11,079
doing cyclization and DC realization we

00:11:08,740 --> 00:11:12,430
want to need to support Thursday which

00:11:11,079 --> 00:11:15,070
is for those of you who don't know what

00:11:12,430 --> 00:11:18,370
Thursday is it's a rest framework for

00:11:15,070 --> 00:11:20,110
doing stabilization and isolation of any

00:11:18,370 --> 00:11:22,420
arrest data structure so you only have

00:11:20,110 --> 00:11:23,980
to like implement the sterilizer in the

00:11:22,420 --> 00:11:26,560
decide riser and it gives you

00:11:23,980 --> 00:11:28,149
cogeneration and lots of cool features

00:11:26,560 --> 00:11:32,019
that you don't even need to worry about

00:11:28,149 --> 00:11:33,670
because it just works and last we wanted

00:11:32,019 --> 00:11:36,700
a library that was well supporting all

00:11:33,670 --> 00:11:40,180
the the specification of Avro which is

00:11:36,700 --> 00:11:41,769
more complicated than it seems so yeah

00:11:40,180 --> 00:11:43,750
we're working through all of this and we

00:11:41,769 --> 00:11:46,800
couldn't find any any good

00:11:43,750 --> 00:11:49,180
implementation that was hitting all the

00:11:46,800 --> 00:11:51,820
parameters so we did like any software

00:11:49,180 --> 00:11:56,230
engineers will do like when their free

00:11:51,820 --> 00:11:58,870
time we build our own so this is a virus

00:11:56,230 --> 00:12:00,610
or library that we wrote and that does

00:11:58,870 --> 00:12:03,339
all the things that we mentioned before

00:12:00,610 --> 00:12:06,700
very quickly how to use it in using rust

00:12:03,339 --> 00:12:08,800
so this is just a test structure and the

00:12:06,700 --> 00:12:10,959
only thing you need to to notice here to

00:12:08,800 --> 00:12:12,790
note here is these two attributes

00:12:10,959 --> 00:12:14,800
deserve licensure and sterilized so

00:12:12,790 --> 00:12:17,050
these are the 30 attributes and that's

00:12:14,800 --> 00:12:19,540
all you need to be able to to interact

00:12:17,050 --> 00:12:21,430
with the library user using for

00:12:19,540 --> 00:12:25,510
destructor and so certainly that's all

00:12:21,430 --> 00:12:27,490
the rest for us which is awesome next

00:12:25,510 --> 00:12:29,410
machine in beginning schemas so this is

00:12:27,490 --> 00:12:30,790
the way you define a schema I'm just

00:12:29,410 --> 00:12:35,079
passing your string and it's written as

00:12:30,790 --> 00:12:37,149
you like schema um now if you want to

00:12:35,079 --> 00:12:39,459
write data you need to have something

00:12:37,149 --> 00:12:41,410
and that can write so a writer you give

00:12:39,459 --> 00:12:42,820
a schema to the writer so that the data

00:12:41,410 --> 00:12:45,370
fits the schema and something that you

00:12:42,820 --> 00:12:47,740
can write into for the purpose of the

00:12:45,370 --> 00:12:49,990
talk is just like vector is just this

00:12:47,740 --> 00:12:51,430
it's gonna be like a byte array but it's

00:12:49,990 --> 00:12:53,019
basically anything that you can write in

00:12:51,430 --> 00:12:57,010
to so it can be a file can be a socket

00:12:53,019 --> 00:12:59,230
can be anything in writing to create a

00:12:57,010 --> 00:13:00,940
record there is like this is the

00:12:59,230 --> 00:13:02,600
automated way to create a record is a

00:13:00,940 --> 00:13:05,750
more manual way to create one

00:13:02,600 --> 00:13:08,300
like trading record in 27 - and going to

00:13:05,750 --> 00:13:10,730
be and then you can just happen records

00:13:08,300 --> 00:13:12,140
to the writer and flash it in in case so

00:13:10,730 --> 00:13:16,010
there's like some internal buffering so

00:13:12,140 --> 00:13:19,070
that's why the fresh is is used so you

00:13:16,010 --> 00:13:20,750
have Avro bytes now so now that you have

00:13:19,070 --> 00:13:22,700
your bites you might want to be able to

00:13:20,750 --> 00:13:24,500
read them and get no data structure

00:13:22,700 --> 00:13:27,710
that's so you can create a writer from

00:13:24,500 --> 00:13:29,660
this reader from this vise and I traitor

00:13:27,710 --> 00:13:31,550
for all the records of this reader and

00:13:29,660 --> 00:13:34,580
well that's that's all you need to know

00:13:31,550 --> 00:13:36,980
about to worry about so yeah that's it

00:13:34,580 --> 00:13:38,510
so far how to write averaging Russ it's

00:13:36,980 --> 00:13:40,610
very it's straightforward and so you

00:13:38,510 --> 00:13:43,580
have the library and I'm gonna let

00:13:40,610 --> 00:13:49,160
Antonio cater to the FFI layer of the

00:13:43,580 --> 00:13:51,280
presentation so how are we doing on

00:13:49,160 --> 00:13:54,860
coffee so far you still awake

00:13:51,280 --> 00:13:58,250
good because we can add more code so

00:13:54,860 --> 00:13:59,810
first thing if you just remember the

00:13:58,250 --> 00:14:02,360
library the fluff just showed you like

00:13:59,810 --> 00:14:04,730
20 seconds ago there are two things that

00:14:02,360 --> 00:14:07,610
we need to expose first one or structs

00:14:04,730 --> 00:14:09,500
so we can expose them in to way the

00:14:07,610 --> 00:14:11,390
first one is defining a struct for

00:14:09,500 --> 00:14:13,130
example we define this other string over

00:14:11,390 --> 00:14:16,040
here which is basically something that

00:14:13,130 --> 00:14:18,500
we use for passing smart strings instead

00:14:16,040 --> 00:14:20,960
of using pointers and you can define all

00:14:18,500 --> 00:14:22,670
your attribute in rust using some weird

00:14:20,960 --> 00:14:25,670
types if you have a programmed rust

00:14:22,670 --> 00:14:29,270
usually you don't use star Moot see char

00:14:25,670 --> 00:14:31,370
I mean these are Robo in tears those are

00:14:29,270 --> 00:14:33,230
just using these FFI layers foreign

00:14:31,370 --> 00:14:36,230
function interface that's what the

00:14:33,230 --> 00:14:39,020
acronym stands for and in this way your

00:14:36,230 --> 00:14:41,000
user the user of the library the user of

00:14:39,020 --> 00:14:43,910
the FFI library actually is going to be

00:14:41,000 --> 00:14:46,790
able to access all the attributes of the

00:14:43,910 --> 00:14:49,070
Sox territory and also remember to

00:14:46,790 --> 00:14:51,500
always specify this attribute warrior

00:14:49,070 --> 00:14:53,750
rep see this basically makes the russ

00:14:51,500 --> 00:14:55,460
compiler actually encode the struct in a

00:14:53,750 --> 00:14:58,250
way that can be understood by c

00:14:55,460 --> 00:15:00,920
application otherwise if you don't want

00:14:58,250 --> 00:15:01,850
your user to be able to access all the

00:15:00,920 --> 00:15:04,880
fields in structs

00:15:01,850 --> 00:15:07,040
you can use opa Condors we use it a lot

00:15:04,880 --> 00:15:09,140
in our application as well so you just

00:15:07,040 --> 00:15:10,820
define a manual over here and then you

00:15:09,140 --> 00:15:12,470
have your internal struct and you cast

00:15:10,820 --> 00:15:16,090
your struct when you return it back to

00:15:12,470 --> 00:15:18,310
this type I'll show you in a second

00:15:16,090 --> 00:15:23,290
so the second-last being that we need to

00:15:18,310 --> 00:15:25,720
expose is basically functions well it is

00:15:23,290 --> 00:15:27,130
pretty easy but the first time you look

00:15:25,720 --> 00:15:29,530
at them so this is called from your

00:15:27,130 --> 00:15:32,230
library as well they kind of you know

00:15:29,530 --> 00:15:34,750
they feel a bit intimidating so let's

00:15:32,230 --> 00:15:37,230
the structure them so basically the

00:15:34,750 --> 00:15:39,520
first thing that they do is just calling

00:15:37,230 --> 00:15:41,500
functions that are defined in the rust

00:15:39,520 --> 00:15:43,300
library so this one is the first

00:15:41,500 --> 00:15:45,370
function the fluff showed you before is

00:15:43,300 --> 00:15:47,740
the one parsing a string to get another

00:15:45,370 --> 00:15:50,110
scheme out of it so what we do in this

00:15:47,740 --> 00:15:52,000
function is just you know massaging a

00:15:50,110 --> 00:15:53,740
bit the arguments in this case the

00:15:52,000 --> 00:15:55,450
referencing the JSON pointer because

00:15:53,740 --> 00:15:57,940
it's still like I see like interface and

00:15:55,450 --> 00:16:00,400
converting it to a rusting and that's it

00:15:57,940 --> 00:16:03,520
the second thing we do is doing the same

00:16:00,400 --> 00:16:06,660
for the result so what we're doing here

00:16:03,520 --> 00:16:10,390
is using box which is basically the rust

00:16:06,660 --> 00:16:12,400
correspondence of writing something to

00:16:10,390 --> 00:16:13,780
the heap instead of the stock otherwise

00:16:12,400 --> 00:16:16,150
at the end of the function that will be

00:16:13,780 --> 00:16:19,090
de-allocated and also here we are

00:16:16,150 --> 00:16:21,310
actually casting into the OPAC handler I

00:16:19,090 --> 00:16:24,610
showed you before as you can say as you

00:16:21,310 --> 00:16:26,410
can see so given these the signature of

00:16:24,610 --> 00:16:29,230
the function becomes a little more clear

00:16:26,410 --> 00:16:31,780
so you get a pointer to another string

00:16:29,230 --> 00:16:34,960
you return a result with a pointer to

00:16:31,780 --> 00:16:36,550
another schema the real magic happens in

00:16:34,960 --> 00:16:38,350
this macro double wrote and the

00:16:36,550 --> 00:16:40,510
basically wraps all the function to be

00:16:38,350 --> 00:16:43,630
wrote in the FFI layer so if we go

00:16:40,510 --> 00:16:46,480
inside it basically this is what happens

00:16:43,630 --> 00:16:49,990
after the macro get expanded you'll get

00:16:46,480 --> 00:16:51,640
a first attribute on top which is

00:16:49,990 --> 00:16:53,800
basically the no mangle attributes just

00:16:51,640 --> 00:16:55,540
saying to the compiler a please don't

00:16:53,800 --> 00:16:58,090
mangle the name of my function because I

00:16:55,540 --> 00:16:59,740
want to access it afterwards and then

00:16:58,090 --> 00:17:02,350
adding these to the signature they

00:16:59,740 --> 00:17:05,470
basically say to rust so this is an

00:17:02,350 --> 00:17:10,180
unsafe function and this is going to be

00:17:05,470 --> 00:17:12,130
called from C code and finally basically

00:17:10,180 --> 00:17:14,380
wrapping the logic that we brought

00:17:12,130 --> 00:17:18,579
before into this little util that we

00:17:14,380 --> 00:17:21,160
called safe from wine so unfortunately

00:17:18,579 --> 00:17:23,560
when you write a file layers in rust you

00:17:21,160 --> 00:17:26,140
are basically dealing with C code on the

00:17:23,560 --> 00:17:28,209
other end you have some gotchas that you

00:17:26,140 --> 00:17:29,550
gotta take care of so the first one and

00:17:28,209 --> 00:17:31,770
that's why we

00:17:29,550 --> 00:17:34,650
that may not before it's unwind and

00:17:31,770 --> 00:17:37,140
safety unfortunately there is no common

00:17:34,650 --> 00:17:39,510
way between rust and C and all the other

00:17:37,140 --> 00:17:43,290
languages to have to be told to unwind

00:17:39,510 --> 00:17:45,270
the stack when there is a panic so what

00:17:43,290 --> 00:17:48,090
we need to do is catch in the panic and

00:17:45,270 --> 00:17:50,940
unwind in the stock in the rust way so

00:17:48,090 --> 00:17:52,920
it's clean when the when the control is

00:17:50,940 --> 00:17:55,560
given back to the C application calling

00:17:52,920 --> 00:17:58,890
our library the second finger error code

00:17:55,560 --> 00:18:01,470
since the the libraries actually gonna

00:17:58,890 --> 00:18:03,180
gonna look like a C library then we need

00:18:01,470 --> 00:18:05,460
to define error cause and the way for

00:18:03,180 --> 00:18:07,320
your user to get them and we need to do

00:18:05,460 --> 00:18:09,840
explicitly more even memory management

00:18:07,320 --> 00:18:12,120
because yes the library is pure rust but

00:18:09,840 --> 00:18:14,070
this little teen layer is going to be

00:18:12,120 --> 00:18:16,530
used by C applications so we need to be

00:18:14,070 --> 00:18:18,180
very careful in saying to the user what

00:18:16,530 --> 00:18:20,460
is managed what is owned what they need

00:18:18,180 --> 00:18:22,380
to free what they don't need to free all

00:18:20,460 --> 00:18:24,540
so we need to duplicate to nomes because

00:18:22,380 --> 00:18:26,520
unfortunately rusts this shortcoming at

00:18:24,540 --> 00:18:28,740
the moment complex arguments are a bit

00:18:26,520 --> 00:18:30,480
of a pain for example Python dictionary

00:18:28,740 --> 00:18:33,240
you need to serialize them with restorin

00:18:30,480 --> 00:18:35,370
in some some kind of an object and then

00:18:33,240 --> 00:18:38,310
feed them into your library and many

00:18:35,370 --> 00:18:39,090
many more and this is just this is too

00:18:38,310 --> 00:18:41,280
much really

00:18:39,090 --> 00:18:43,260
so you know what the solution to this

00:18:41,280 --> 00:18:47,970
what which one is the solution to this

00:18:43,260 --> 00:18:50,550
problem basically it's copy pasting go

00:18:47,970 --> 00:18:52,770
to our library copy paste the YouTube

00:18:50,550 --> 00:18:55,230
function copy paste the macro copy paste

00:18:52,770 --> 00:19:00,090
all the util structures and everything

00:18:55,230 --> 00:19:02,070
and you're almost there 90% now I would

00:19:00,090 --> 00:19:04,260
like to point you to a decent library

00:19:02,070 --> 00:19:06,570
instead of copy pasting but there is

00:19:04,260 --> 00:19:09,630
none that I really like and this is our

00:19:06,570 --> 00:19:10,920
second project on the FFI layer so on

00:19:09,630 --> 00:19:12,480
the third one we're probably going to

00:19:10,920 --> 00:19:15,150
write the library and then I'm going to

00:19:12,480 --> 00:19:18,600
point you to that the last thing that we

00:19:15,150 --> 00:19:21,570
need is the other file so as we remember

00:19:18,600 --> 00:19:23,190
first CF fi we need another file with

00:19:21,570 --> 00:19:25,380
the declaration of the symbols so we can

00:19:23,190 --> 00:19:27,570
find them in the actual binary now the

00:19:25,380 --> 00:19:29,550
other file is going to look exactly like

00:19:27,570 --> 00:19:33,060
all the definition that I showed you

00:19:29,550 --> 00:19:37,410
before but in C syntax so char star data

00:19:33,060 --> 00:19:39,180
this weird new int PTR underscore T what

00:19:37,410 --> 00:19:42,780
is what is that I don't even have idea

00:19:39,180 --> 00:19:44,940
this type def structs and everything so

00:19:42,780 --> 00:19:47,910
and again this is a pain code

00:19:44,940 --> 00:19:50,130
duplication other syntax but you know we

00:19:47,910 --> 00:19:52,110
have a solution for that to see by Jen

00:19:50,130 --> 00:19:54,330
see benjin is awesome

00:19:52,110 --> 00:19:56,340
is a fantastic open source project you

00:19:54,330 --> 00:19:58,380
can find it on github what you need to

00:19:56,340 --> 00:20:00,990
do is basically just hooking it up in

00:19:58,380 --> 00:20:03,060
your make file and with just this little

00:20:00,990 --> 00:20:05,280
command will auto-generate

00:20:03,060 --> 00:20:07,350
the other file for you it even

00:20:05,280 --> 00:20:09,420
transforms there are stock strings in

00:20:07,350 --> 00:20:12,840
comment it's amazing

00:20:09,420 --> 00:20:13,260
trust me again copy paste it and you're

00:20:12,840 --> 00:20:14,340
done

00:20:13,260 --> 00:20:19,650
you don't need to write another file

00:20:14,340 --> 00:20:22,380
anymore now that we know how to FFI flag

00:20:19,650 --> 00:20:24,690
that is our resident Python expert is

00:20:22,380 --> 00:20:27,480
going to explain to you how we basically

00:20:24,690 --> 00:20:29,190
wrap everything into a decent Python

00:20:27,480 --> 00:20:30,750
library so that the users won't even

00:20:29,190 --> 00:20:38,910
notice that we are using rust on the

00:20:30,750 --> 00:20:41,880
root so yeah on the on to the last step

00:20:38,910 --> 00:20:43,950
of our journey python so now that we

00:20:41,880 --> 00:20:45,030
have all the FFI layer and the rest

00:20:43,950 --> 00:20:47,100
layer that we don't even need to worry

00:20:45,030 --> 00:20:49,290
about not because we have FFA is what

00:20:47,100 --> 00:20:51,630
we're going to deal with the only thing

00:20:49,290 --> 00:20:55,170
that we have to do is well write 3 in

00:20:51,630 --> 00:20:57,540
python so yeah it's not great but that's

00:20:55,170 --> 00:20:59,520
how it is so if you for instance want to

00:20:57,540 --> 00:21:02,550
serialize an integer you just call the

00:20:59,520 --> 00:21:07,400
FFI function our value in new and give

00:21:02,550 --> 00:21:09,630
it an integer and that's as Antonio said

00:21:07,400 --> 00:21:11,490
support for complex data structures is

00:21:09,630 --> 00:21:14,370
not not really there so if you want like

00:21:11,490 --> 00:21:15,990
for instance sterilized Python list then

00:21:14,370 --> 00:21:17,610
you well create an array give you this

00:21:15,990 --> 00:21:19,260
cap give it a capacity in the beginning

00:21:17,610 --> 00:21:23,220
and for each of the items you manually

00:21:19,260 --> 00:21:25,230
like up and then to to the array and

00:21:23,220 --> 00:21:29,180
then you return you return it in the end

00:21:25,230 --> 00:21:31,710
so yeah well just writing C in Python

00:21:29,180 --> 00:21:35,670
but python is a little bit better than C

00:21:31,710 --> 00:21:38,460
and some some in some cases and and well

00:21:35,670 --> 00:21:40,530
code readability is one of them so what

00:21:38,460 --> 00:21:42,750
we did for our library which it's just

00:21:40,530 --> 00:21:45,120
an example and could be real angler it's

00:21:42,750 --> 00:21:48,900
just defining a small class and that

00:21:45,120 --> 00:21:50,260
map's each of the like primitive types

00:21:48,900 --> 00:21:53,650
that Python us and

00:21:50,260 --> 00:21:55,720
to a well see FFI function and depending

00:21:53,650 --> 00:21:57,850
on the type of the other of the values

00:21:55,720 --> 00:22:00,360
of the data that you want serialized

00:21:57,850 --> 00:22:03,580
just gonna call the the right function

00:22:00,360 --> 00:22:06,370
and it's well if you have like a nested

00:22:03,580 --> 00:22:10,300
value like like a dictionary it's just

00:22:06,370 --> 00:22:12,010
gonna call recursively and all the

00:22:10,300 --> 00:22:13,750
things that your user needs to worry

00:22:12,010 --> 00:22:17,860
about is this property in the end which

00:22:13,750 --> 00:22:19,180
is value which is yeah they don't need

00:22:17,860 --> 00:22:21,550
to worry about anything else that's just

00:22:19,180 --> 00:22:25,450
it just use the value property and

00:22:21,550 --> 00:22:28,600
that's all that the organ see um so I

00:22:25,450 --> 00:22:30,190
would it look like as a Python end user

00:22:28,600 --> 00:22:33,400
so if you have a schema well you just

00:22:30,190 --> 00:22:35,110
define a schema using the scheme as a

00:22:33,400 --> 00:22:36,730
string if you want a writer you create a

00:22:35,110 --> 00:22:40,150
writer with the schema shown what the

00:22:36,730 --> 00:22:41,440
data won't you just do it like this you

00:22:40,150 --> 00:22:43,210
flush the data you get two bytes you

00:22:41,440 --> 00:22:45,250
create the reader and for each of the

00:22:43,210 --> 00:22:48,130
items you you can I to write on them so

00:22:45,250 --> 00:22:50,170
it's well it's that's how it looks like

00:22:48,130 --> 00:22:51,670
for the end user it's just Python code

00:22:50,170 --> 00:22:53,230
it could be like written in Python could

00:22:51,670 --> 00:22:56,020
be done in secret and in rust

00:22:53,230 --> 00:22:59,620
we're is anything it looks like Python

00:22:56,020 --> 00:23:02,290
and so yeah we kind of like it so now

00:22:59,620 --> 00:23:04,660
that all your users can use your library

00:23:02,290 --> 00:23:06,490
you need to find a way to or package to

00:23:04,660 --> 00:23:09,250
librarian this read it to people that

00:23:06,490 --> 00:23:11,620
want to use it first you need the FFI

00:23:09,250 --> 00:23:14,020
code so we're just using pizza not your

00:23:11,620 --> 00:23:15,760
for that then every time you have a

00:23:14,020 --> 00:23:17,410
change into your FFI layer you need to

00:23:15,760 --> 00:23:20,350
make sure that you will compile it all

00:23:17,410 --> 00:23:23,320
the time so the way we do it is using

00:23:20,350 --> 00:23:25,150
cargo which is the packet we like the

00:23:23,320 --> 00:23:27,610
toolbox of for us and it does can do

00:23:25,150 --> 00:23:29,110
compilation for you so every time your

00:23:27,610 --> 00:23:31,090
code changes you need to make sure that

00:23:29,110 --> 00:23:33,490
you run this command if you want to

00:23:31,090 --> 00:23:35,740
package your Python package I mean you

00:23:33,490 --> 00:23:40,300
know define set of that pie and we'll

00:23:35,740 --> 00:23:42,400
run the comments and everything and yeah

00:23:40,300 --> 00:23:44,680
so I would the setup the pie look like

00:23:42,400 --> 00:23:46,930
in Python so that's pretty much how I

00:23:44,680 --> 00:23:49,630
would look like the only things that you

00:23:46,930 --> 00:23:51,640
need to worry about is this package data

00:23:49,630 --> 00:23:52,990
so this is stuff that is not Python that

00:23:51,640 --> 00:23:55,480
you're going to include as well in your

00:23:52,990 --> 00:23:57,460
package into make sure to include the

00:23:55,480 --> 00:23:58,300
header that Antonio just mentioned and

00:23:57,460 --> 00:24:01,360
also the world

00:23:58,300 --> 00:24:02,800
actual binary a brass binary you also

00:24:01,360 --> 00:24:03,290
need to make sure that zip safe is set

00:24:02,800 --> 00:24:07,310
to four

00:24:03,290 --> 00:24:09,830
because when you package Python packages

00:24:07,310 --> 00:24:12,230
that contain data files like binaries in

00:24:09,830 --> 00:24:14,680
our case there are no tip so if you just

00:24:12,230 --> 00:24:17,090
need to make sure that me sorry it is

00:24:14,680 --> 00:24:19,820
and last you need to worry about this

00:24:17,090 --> 00:24:23,330
beautys will so here is just a function

00:24:19,820 --> 00:24:24,560
that and it's over complicated for like

00:24:23,330 --> 00:24:26,780
it's just you need to make sure that you

00:24:24,560 --> 00:24:29,150
compile it for the right like python

00:24:26,780 --> 00:24:32,180
version api version due to crack

00:24:29,150 --> 00:24:33,980
platform and yeah it's it's a thing you

00:24:32,180 --> 00:24:34,400
just need to like too many things to

00:24:33,980 --> 00:24:37,520
worry about

00:24:34,400 --> 00:24:38,000
I don't want that but Mill snake is

00:24:37,520 --> 00:24:39,920
awesome

00:24:38,000 --> 00:24:42,050
so milk snake is an open source tool

00:24:39,920 --> 00:24:44,440
built by a company called sentry and

00:24:42,050 --> 00:24:48,320
what it gives you is basically a like

00:24:44,440 --> 00:24:51,230
it's awesome so let's launch the into

00:24:48,320 --> 00:24:53,270
this first you they give you a you can

00:24:51,230 --> 00:24:54,980
specify insert the pipe that okay I have

00:24:53,270 --> 00:24:57,350
an external something else that I want

00:24:54,980 --> 00:25:00,290
to build in our case it's just arrest

00:24:57,350 --> 00:25:02,060
arrest package it can be like any

00:25:00,290 --> 00:25:03,890
anything could be see if you want it

00:25:02,060 --> 00:25:06,470
could be you know anything that you need

00:25:03,890 --> 00:25:10,400
to build um so not get you call the

00:25:06,470 --> 00:25:16,010
comment anything you need to worry about

00:25:10,400 --> 00:25:18,140
is the well where is the binary and so

00:25:16,010 --> 00:25:20,060
it's platform-independent you just leave

00:25:18,140 --> 00:25:25,970
it where it should be and how it should

00:25:20,060 --> 00:25:28,370
look like and that's it last is well did

00:25:25,970 --> 00:25:29,930
header file this doesn't change and just

00:25:28,370 --> 00:25:32,000
gives you word where they had the finest

00:25:29,930 --> 00:25:34,250
so India and this is how you're set up

00:25:32,000 --> 00:25:36,080
that PI would look like the only thing

00:25:34,250 --> 00:25:38,390
you need to worry about is adding this

00:25:36,080 --> 00:25:39,980
and that's it you can just build a

00:25:38,390 --> 00:25:43,250
Python package it's gonna call the rest

00:25:39,980 --> 00:25:45,740
compilation and Indian you're gonna have

00:25:43,250 --> 00:25:50,180
your Python package and so you trust me

00:25:45,740 --> 00:25:52,130
milk snake is awesome so yeah now now

00:25:50,180 --> 00:25:54,560
you get a Python package that runs

00:25:52,130 --> 00:25:56,150
across code and but in the end like what

00:25:54,560 --> 00:25:57,140
it really worth it was it really faster

00:25:56,150 --> 00:25:59,000
what why bother

00:25:57,140 --> 00:26:05,120
I'm gonna let Antonio get it for you

00:25:59,000 --> 00:26:07,670
right all right since we're basically

00:26:05,120 --> 00:26:10,220
all scientists engineers this should be

00:26:07,670 --> 00:26:13,160
the best part to the talk for us numbers

00:26:10,220 --> 00:26:16,040
charts graphs let's start so this is

00:26:13,160 --> 00:26:16,550
just a random benchmark I mean no really

00:26:16,040 --> 00:26:19,670
run no money

00:26:16,550 --> 00:26:21,590
pretty good one for us but basically

00:26:19,670 --> 00:26:23,300
don't focus too much on the numbers this

00:26:21,590 --> 00:26:25,750
is just some you know encoding and

00:26:23,300 --> 00:26:29,150
decoding of Averell messages

00:26:25,750 --> 00:26:32,780
it's seconds on the left so the shorter

00:26:29,150 --> 00:26:35,450
the best and we can find that our code

00:26:32,780 --> 00:26:38,300
performs decently well Buffon's cpython

00:26:35,450 --> 00:26:40,670
and pi pi you can see the gets optimized

00:26:38,300 --> 00:26:42,320
and private rights not much for reads

00:26:40,670 --> 00:26:44,300
but you know you've got some

00:26:42,320 --> 00:26:47,420
optimization on pi pi as well so it

00:26:44,300 --> 00:26:50,360
works fine let's compare it with faster

00:26:47,420 --> 00:26:54,290
bro which is the library using site on

00:26:50,360 --> 00:26:56,060
instead of rustic sensors or we do so as

00:26:54,290 --> 00:26:58,730
you can see like sometimes you're faster

00:26:56,060 --> 00:27:01,630
sometimes they're faster but we're more

00:26:58,730 --> 00:27:04,670
or less they're like they are comparable

00:27:01,630 --> 00:27:07,640
this means that our approach using Russ

00:27:04,670 --> 00:27:09,980
extensions is comparable to seitan which

00:27:07,640 --> 00:27:13,880
is basically I would say the state of

00:27:09,980 --> 00:27:16,010
the art for making C code running into a

00:27:13,880 --> 00:27:18,130
Python application now this is very

00:27:16,010 --> 00:27:20,870
important we actually for example

00:27:18,130 --> 00:27:25,000
deliver much better performances on

00:27:20,870 --> 00:27:27,910
greens who knows why actually but we do

00:27:25,000 --> 00:27:33,410
now just for the sake of it let's

00:27:27,910 --> 00:27:37,520
compare both FASTA bro and pi RS against

00:27:33,410 --> 00:27:43,550
the pure Python opera library the one

00:27:37,520 --> 00:27:44,870
maintained by Apache I'm gonna change

00:27:43,550 --> 00:27:46,880
the scale so it knocks you out

00:27:44,870 --> 00:27:51,200
understanding what's going on this is

00:27:46,880 --> 00:27:55,760
the scale now as you can see on C Python

00:27:51,200 --> 00:27:57,980
the gains are real on point by the gains

00:27:55,760 --> 00:28:01,970
are still real like less than out for

00:27:57,980 --> 00:28:04,880
whatever but as you can see by pi really

00:28:01,970 --> 00:28:08,690
optimizes very well your Python code

00:28:04,880 --> 00:28:10,850
that's why before embarking in this very

00:28:08,690 --> 00:28:13,400
fine journey of writing glass exposing

00:28:10,850 --> 00:28:16,520
dozens you have FFI writing a Python

00:28:13,400 --> 00:28:20,330
wrapper and everything or write in C

00:28:16,520 --> 00:28:22,460
Python or writing sidon just try to

00:28:20,330 --> 00:28:26,990
change the interpreter really do it for

00:28:22,460 --> 00:28:28,280
me do it for yourself and okay before

00:28:26,990 --> 00:28:30,060
too close actually

00:28:28,280 --> 00:28:32,250
I'm sure that

00:28:30,060 --> 00:28:35,310
you know inside you really really really

00:28:32,250 --> 00:28:38,730
want to know but I know it's a different

00:28:35,310 --> 00:28:40,170
language but how much faster was just

00:28:38,730 --> 00:28:45,440
the other library

00:28:40,170 --> 00:28:47,880
dearest library well it's the red column

00:28:45,440 --> 00:28:50,580
yes

00:28:47,880 --> 00:28:53,340
so I change the scale again I'll compare

00:28:50,580 --> 00:28:56,610
it against only our library and this is

00:28:53,340 --> 00:28:59,550
the green column yes

00:28:56,610 --> 00:29:03,750
Rusty's fast very fast as fast as

00:28:59,550 --> 00:29:06,030
invisible to conclude last part of the

00:29:03,750 --> 00:29:09,500
talk since we promised in the title how

00:29:06,030 --> 00:29:12,570
to get away with it which is basically

00:29:09,500 --> 00:29:16,470
answering to two questions first one how

00:29:12,570 --> 00:29:18,270
to convince my colleagues well Russ is

00:29:16,470 --> 00:29:20,120
the most language the most loved

00:29:18,270 --> 00:29:22,800
language in the Stack Overflow survey

00:29:20,120 --> 00:29:24,990
for I can remember even how many years

00:29:22,800 --> 00:29:27,630
in a row and if so many people love Russ

00:29:24,990 --> 00:29:30,990
there must be a reason second

00:29:27,630 --> 00:29:33,540
compilation just works again cargo is

00:29:30,990 --> 00:29:38,670
awesome it just works cross-compilation

00:29:33,540 --> 00:29:41,520
just works here art of that fast recycle

00:29:38,670 --> 00:29:42,870
the recycle of Ross is only six weeks if

00:29:41,520 --> 00:29:45,120
I remember correctly so you don't need

00:29:42,870 --> 00:29:47,190
to wait years to see your favorite

00:29:45,120 --> 00:29:49,980
feature landing in at least a nightly

00:29:47,190 --> 00:29:52,710
build and it's a ton of fun otherwise me

00:29:49,980 --> 00:29:54,810
and faster than beer second question the

00:29:52,710 --> 00:29:57,000
most important actually and to convince

00:29:54,810 --> 00:29:59,490
my company because you know they can't

00:29:57,000 --> 00:30:01,830
pay the bills so first one is wheels

00:29:59,490 --> 00:30:05,430
compile ones is still everywhere

00:30:01,830 --> 00:30:08,040
well given platform so in our company

00:30:05,430 --> 00:30:10,530
job what we do for distributing these

00:30:08,040 --> 00:30:14,100
kind of packages is basically building a

00:30:10,530 --> 00:30:16,650
Python wheel somewhere in docker on

00:30:14,100 --> 00:30:20,250
Jenkins machines somewhere and then

00:30:16,650 --> 00:30:22,470
installing them on the same platform in

00:30:20,250 --> 00:30:25,440
production without even requiring the

00:30:22,470 --> 00:30:26,820
cargo installation or rust compiler you

00:30:25,440 --> 00:30:28,170
don't need compile any code if you

00:30:26,820 --> 00:30:29,450
already package the build for the right

00:30:28,170 --> 00:30:32,880
platform

00:30:29,450 --> 00:30:34,530
second is FFI interoperability and this

00:30:32,880 --> 00:30:38,640
is a blast that only comes with the C

00:30:34,530 --> 00:30:40,560
type C ff5 option so if you write a

00:30:38,640 --> 00:30:43,110
reciprocal or a strawberry and then you

00:30:40,560 --> 00:30:45,390
package it in FFI then it's a

00:30:43,110 --> 00:30:49,190
Cybil - basically all the languages in

00:30:45,390 --> 00:30:52,860
the world Java we are by a GN I or J

00:30:49,190 --> 00:30:55,710
Objective C C++ actually a t'elp we have

00:30:52,860 --> 00:30:59,400
another project where we have some rust

00:30:55,710 --> 00:31:01,920
code that is shipped to our website the

00:30:59,400 --> 00:31:03,990
despite on our Android application and

00:31:01,920 --> 00:31:05,000
our iOS application via the same

00:31:03,990 --> 00:31:07,830
mechanism

00:31:05,000 --> 00:31:10,350
Rusty's as fast as C which means the

00:31:07,830 --> 00:31:12,929
chip to run some games over here and

00:31:10,350 --> 00:31:13,320
it's safer than C so it's cheap to

00:31:12,929 --> 00:31:15,660
maintain

00:31:13,320 --> 00:31:18,510
so you know other gains for the company

00:31:15,660 --> 00:31:21,299
and finally is using production by many

00:31:18,510 --> 00:31:22,799
companies Yelp Mozilla Dropbox and many

00:31:21,299 --> 00:31:26,700
many others probably bigger than yours

00:31:22,799 --> 00:31:29,100
so why not try out so again what to

00:31:26,700 --> 00:31:31,890
bring home right trust itself see what

00:31:29,100 --> 00:31:34,919
was easy was the title C by Jerry's also

00:31:31,890 --> 00:31:37,650
remember that milk snake is also

00:31:34,919 --> 00:31:42,210
remember that as well and those are the

00:31:37,650 --> 00:31:44,940
links for the copy pasting so remember

00:31:42,210 --> 00:31:47,429
that we are hiring both London and

00:31:44,940 --> 00:31:48,320
number but instead of going through you

00:31:47,429 --> 00:31:51,750
know the usual

00:31:48,320 --> 00:31:54,630
shameless hiring plug I'm gonna tell a

00:31:51,750 --> 00:31:57,510
story here so basically I think he was

00:31:54,630 --> 00:31:59,220
four months ago three months ago I was

00:31:57,510 --> 00:32:01,740
pretty pissed off was drinking a coffee

00:31:59,220 --> 00:32:03,690
with flub and I was working on the other

00:32:01,740 --> 00:32:06,450
project the Ross project I was like oh

00:32:03,690 --> 00:32:09,179
man I really have a couple cool features

00:32:06,450 --> 00:32:12,780
and the one to implement but you know

00:32:09,179 --> 00:32:14,880
there is no good our librarian rust so I

00:32:12,780 --> 00:32:17,429
guess we're just gonna drop it and wait

00:32:14,880 --> 00:32:20,880
for someone to implement it and flowers

00:32:17,429 --> 00:32:24,090
right I see poor you poor thing

00:32:20,880 --> 00:32:26,340
then after a couple mom's again drinking

00:32:24,090 --> 00:32:29,730
coffee because we do love coffee

00:32:26,340 --> 00:32:32,130
fluff comes up to me and say oh by the

00:32:29,730 --> 00:32:35,250
way I've written the lab review you need

00:32:32,130 --> 00:32:36,990
it you wanna try it out and so if you

00:32:35,250 --> 00:32:39,870
want to work with these awesome

00:32:36,990 --> 00:32:43,380
colleagues to do your job for you then

00:32:39,870 --> 00:32:47,020
come to Yelp follow us on any social

00:32:43,380 --> 00:32:47,830
network to talk with

00:32:47,020 --> 00:32:51,000
[Applause]

00:32:47,830 --> 00:32:51,000
[Music]

00:32:54,929 --> 00:32:58,710
so any question

00:33:08,290 --> 00:33:16,370
right so I turn all works for the

00:33:11,420 --> 00:33:17,900
microphones over here so okay just talk

00:33:16,370 --> 00:33:20,710
normally and we're going to repeat it

00:33:17,900 --> 00:33:20,710
yeah let's do that

00:33:24,670 --> 00:33:27,829
[Music]

00:33:33,130 --> 00:33:38,660
no we just do distribution of wheels as

00:33:36,830 --> 00:33:40,190
a site so we are basically what we

00:33:38,660 --> 00:33:43,460
usually do for these kinds of libraries

00:33:40,190 --> 00:33:45,590
we have a Jenkins pipeline and we do

00:33:43,460 --> 00:33:47,600
have different docker containers for the

00:33:45,590 --> 00:33:49,700
various platform your building and every

00:33:47,600 --> 00:33:52,460
docker container is tolstoi dependencies

00:33:49,700 --> 00:33:54,590
you build the wheel then we basically

00:33:52,460 --> 00:33:59,050
upload the wheel to our internal piping

00:33:54,590 --> 00:33:59,050
and users can just install the wheel

00:34:00,130 --> 00:34:07,910
correct so the question was how do you

00:34:05,600 --> 00:34:10,130
do the distribution of these packages do

00:34:07,910 --> 00:34:12,020
you use Python wheels to use something

00:34:10,130 --> 00:34:14,419
else you distribute the source this kind

00:34:12,020 --> 00:34:18,980
of stuff thank you very much again and

00:34:14,419 --> 00:34:23,200
so and that before was the answer is

00:34:18,980 --> 00:34:23,200
that okay or does it answer the question

00:34:23,860 --> 00:34:33,410
we do not so yes what about my class we

00:34:29,600 --> 00:34:38,690
do not ship any Mac OS code we just have

00:34:33,410 --> 00:34:40,669
our a us library and for that one I

00:34:38,690 --> 00:34:48,410
don't know I'm not in the iOS team

00:34:40,669 --> 00:34:55,330
actually just have some macros that

00:34:48,410 --> 00:34:57,740
builder and the thing for ignite next

00:34:55,330 --> 00:35:01,490
okay I just go in order

00:34:57,740 --> 00:35:04,230
oh we have a mic great just to complete

00:35:01,490 --> 00:35:07,040
the previous question do you

00:35:04,230 --> 00:35:18,210
dependency when you build binary library

00:35:07,040 --> 00:35:21,859
in arrests I mean you could and yeah we

00:35:18,210 --> 00:35:24,540
just we just use the standard rust

00:35:21,859 --> 00:35:26,250
really this is just an encoding and

00:35:24,540 --> 00:35:29,430
decoding protocol

00:35:26,250 --> 00:35:33,560
so it's CPU intensive a lot of bytes

00:35:29,430 --> 00:35:35,790
going up and down but no more than that

00:35:33,560 --> 00:35:40,670
for the other project instead actually

00:35:35,790 --> 00:35:44,160
we have external dependency as cell and

00:35:40,670 --> 00:35:47,400
remember what else what we usually do

00:35:44,160 --> 00:35:49,680
it's basically installing them into well

00:35:47,400 --> 00:35:52,200
the machine or actually in docker if

00:35:49,680 --> 00:35:54,750
he's from the docker but they're not

00:35:52,200 --> 00:35:56,790
just you know dependencies told at the

00:35:54,750 --> 00:36:02,430
operating system level we don't package

00:35:56,790 --> 00:36:04,470
it with the device thank you very much

00:36:02,430 --> 00:36:07,050
for sharing with it's a very detailed

00:36:04,470 --> 00:36:10,440
journey that was very insightful and but

00:36:07,050 --> 00:36:12,030
the iPod seemed to be very painful now

00:36:10,440 --> 00:36:15,480
I'm just curious why did you do this

00:36:12,030 --> 00:36:17,160
both if I think if I thing your self as

00:36:15,480 --> 00:36:20,339
opposed to using one of the libraries

00:36:17,160 --> 00:36:23,700
like PI or three or rust C Python that

00:36:20,339 --> 00:36:27,119
would do this for you that's a very very

00:36:23,700 --> 00:36:29,220
good question actually so but let's take

00:36:27,119 --> 00:36:31,050
by you're free for example so for anyone

00:36:29,220 --> 00:36:33,180
who doesn't know PI you're free what it

00:36:31,050 --> 00:36:35,400
does is basically making possible to

00:36:33,180 --> 00:36:38,520
call python from rust and rust from

00:36:35,400 --> 00:36:43,560
python and it's very very similar to the

00:36:38,520 --> 00:36:45,300
C extension syntax so in you can use it

00:36:43,560 --> 00:36:48,589
it's gonna work it's gonna actually

00:36:45,300 --> 00:36:51,420
maybe be even faster than our library

00:36:48,589 --> 00:36:54,240
but the only problem is that if you use

00:36:51,420 --> 00:36:57,960
PI a free of this kind of of libraries

00:36:54,240 --> 00:37:00,450
then you're bound to Python instead with

00:36:57,960 --> 00:37:03,150
this approach you can use your FFI

00:37:00,450 --> 00:37:05,190
package layer in any other language if

00:37:03,150 --> 00:37:08,069
you want to be the wrapper for that and

00:37:05,190 --> 00:37:09,750
in a company like yelp where we are

00:37:08,069 --> 00:37:11,940
actually supporting a lot of languages

00:37:09,750 --> 00:37:14,910
even if python is our main one this is a

00:37:11,940 --> 00:37:16,800
very good prop and as fluffs showed at

00:37:14,910 --> 00:37:17,980
the very beginning is stead of airing

00:37:16,800 --> 00:37:19,720
you know

00:37:17,980 --> 00:37:21,849
permutation of avarice in many languages

00:37:19,720 --> 00:37:24,070
they can come with different queries we

00:37:21,849 --> 00:37:25,570
just have one and everything gets

00:37:24,070 --> 00:37:27,940
encoded and decoded with the same

00:37:25,570 --> 00:37:29,440
application so I guess that's good

00:37:27,940 --> 00:37:31,869
problem well yeah it was a very good

00:37:29,440 --> 00:37:33,460
very good question and there is also

00:37:31,869 --> 00:37:38,230
another talk about PI you're free I

00:37:33,460 --> 00:37:40,300
don't remember which today ok so there

00:37:38,230 --> 00:37:42,070
was a bit I was you know one of the

00:37:40,300 --> 00:37:49,300
shady advertisements over there but

00:37:42,070 --> 00:37:53,079
anyway good go to the talk any other

00:37:49,300 --> 00:37:55,839
question we are free yep yeah you

00:37:53,079 --> 00:37:58,750
mentioned that you would to write a

00:37:55,839 --> 00:38:01,750
generalized library for the fine layer

00:37:58,750 --> 00:38:04,300
from rust when you were if you were

00:38:01,750 --> 00:38:10,150
doing a project or E or or two in the

00:38:04,300 --> 00:38:16,859
future so when can we expect that of how

00:38:10,150 --> 00:38:16,859
much free time do you have too much soon

00:38:18,480 --> 00:38:21,480
next

00:38:29,859 --> 00:38:35,459
and so do you have the same code base

00:38:31,809 --> 00:38:38,380
for working with Python two and three or

00:38:35,459 --> 00:38:47,219
some difference between very good

00:38:38,380 --> 00:38:49,420
question it's exactly the same yeah

00:38:47,219 --> 00:38:51,279
we're gonna get the microphone back to

00:38:49,420 --> 00:38:52,749
the to the front at the end sorry

00:38:51,279 --> 00:38:54,999
from what I have seen like in the

00:38:52,749 --> 00:38:57,910
beginning of the talk you were using the

00:38:54,999 --> 00:39:00,339
CF advice API mode right yes and

00:38:57,910 --> 00:39:02,289
according to the safety fide project I

00:39:00,339 --> 00:39:04,359
mean at least taking the documentation

00:39:02,289 --> 00:39:06,369
it seems like to be the one which is

00:39:04,359 --> 00:39:09,609
more problematic and also the slowest

00:39:06,369 --> 00:39:11,410
one compared to the API mode yes

00:39:09,609 --> 00:39:14,289
experiment like with something like

00:39:11,410 --> 00:39:17,859
generating a C bridge which will compile

00:39:14,289 --> 00:39:20,469
into in extension I know games to be

00:39:17,859 --> 00:39:23,140
fair no okay cuz I mean from my

00:39:20,469 --> 00:39:25,809
experience it seems like that for small

00:39:23,140 --> 00:39:28,630
functions I mean the cost of calling it

00:39:25,809 --> 00:39:31,089
is much higher than for example the time

00:39:28,630 --> 00:39:33,430
of execution of the function itself so

00:39:31,089 --> 00:39:36,579
for this API mode I mean you have like

00:39:33,430 --> 00:39:38,739
the advantage of generosity so it works

00:39:36,579 --> 00:39:41,229
like for for many languages and uh not

00:39:38,739 --> 00:39:43,180
only Python but especially in Windows

00:39:41,229 --> 00:39:44,799
it's kind of very problematic if you

00:39:43,180 --> 00:39:49,180
have like different tool chains compiled

00:39:44,799 --> 00:39:52,089
with GCC or MS PC and I mean your code

00:39:49,180 --> 00:39:53,920
which is just ship it with shared object

00:39:52,089 --> 00:39:56,170
library I mean on Windows for example

00:39:53,920 --> 00:39:58,719
could not work that easily

00:39:56,170 --> 00:40:01,150
I guess you're correct to be fair we

00:39:58,719 --> 00:40:03,699
don't target Windows as well at Yelp so

00:40:01,150 --> 00:40:07,359
and I don't own a being the Windows

00:40:03,699 --> 00:40:10,319
machine so I guess I you know but I will

00:40:07,359 --> 00:40:10,319
try that out why not

00:40:18,000 --> 00:40:23,590
having better disrupts that your

00:40:19,900 --> 00:40:25,450
organization I mean when you decided to

00:40:23,590 --> 00:40:26,980
drugs for this project I should imagine

00:40:25,450 --> 00:40:36,630
you've already would have has a lot of

00:40:26,980 --> 00:40:40,150
C++ brothers and I love love em so today

00:40:36,630 --> 00:40:42,760
I don't think we're that many C++

00:40:40,150 --> 00:40:50,770
programmers yermian that leave didn't

00:40:42,760 --> 00:40:53,050
show it and II know yeah I guess so I

00:40:50,770 --> 00:40:55,210
mean we didn't have any like we just

00:40:53,050 --> 00:41:03,400
came in with something that was fast and

00:40:55,210 --> 00:41:05,860
people were happy about it so actually I

00:41:03,400 --> 00:41:08,920
have quite similar question but more

00:41:05,860 --> 00:41:11,440
specific about learning curve of rust

00:41:08,920 --> 00:41:17,980
and how much do you like boiled chicken

00:41:11,440 --> 00:41:20,500
I love it when my cookin pies and all

00:41:17,980 --> 00:41:23,050
the way all the time I yeah it's just

00:41:20,500 --> 00:41:25,600
Martin to me and I didn't like it but I

00:41:23,050 --> 00:41:27,640
mean during curve of arrest for like I

00:41:25,600 --> 00:41:28,990
try to rest maybe three years ago and I

00:41:27,640 --> 00:41:31,230
didn't like it it was too hard for me

00:41:28,990 --> 00:41:37,810
and then I came back six eight months

00:41:31,230 --> 00:41:40,330
ago and it's it's like it's fine you

00:41:37,810 --> 00:41:42,220
just need to take the time and it's like

00:41:40,330 --> 00:41:43,660
all the documentation all the tooling

00:41:42,220 --> 00:41:45,760
all the community everything is it's

00:41:43,660 --> 00:41:50,250
great so you know I hope those two to be

00:41:45,760 --> 00:41:53,250
able to let succeed in writing Russ code

00:41:50,250 --> 00:41:53,250
thanks

00:41:57,029 --> 00:42:01,900
so if you have any other question or you

00:41:59,950 --> 00:42:04,329
just want to offer us a coffee because

00:42:01,900 --> 00:42:06,900
they're free just come and talk to us

00:42:04,329 --> 00:42:10,059
directly thank you very much

00:42:06,900 --> 00:42:10,059

YouTube URL: https://www.youtube.com/watch?v=u6ZbF4apABk


