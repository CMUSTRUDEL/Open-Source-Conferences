Title: Honza Král - Designing a Pythonic Interface
Publication date: 2016-07-29
Playlist: EuroPython 2016
Description: 
	Honza Král - Designing a Pythonic Interface
[EuroPython 2016]
[19 July 2016]
[Bilbao, Euskadi, Spain]
(https://ep2016.europython.eu//conference/talks/designing-a-pythonic-interface)

When designing an abstraction for a complex system (an ORM-like
library in our case) you face a lot of design decisions and
challenges. This talk details how we chose to tackle those when
designing elasticsearch-dsl.

-----

The json query language for elasticsearch, as well as its other APIs,
can be very daunting to new users and can be a bit cumbersome when
working with python. That is why we created elasticsearch-dsl - a sort
of ORM for elasticsearch.

We will go through the design philosophy and obstacles found during
the development - trying to make a more pythonic interface for
elasticsearch while maintaining access to all of the features of the
underlying query language.

The focus of the talk is more on the library and interface design than
on elasticsearch and its query language itself, that is used only to
demonstrate the principles.
Captions: 
	00:00:00,060 --> 00:00:05,790
good morning please welcome our next

00:00:03,750 --> 00:00:09,560
speaker honzik rao we'll be talking

00:00:05,790 --> 00:00:09,560
about designing and pythonic interface

00:00:13,040 --> 00:00:20,340
thank you hello good morning

00:00:17,210 --> 00:00:21,689
I've been said my my name is on second

00:00:20,340 --> 00:00:26,869
island I would like to talk to you about

00:00:21,689 --> 00:00:26,869
designing a pythonic interface and

00:00:27,170 --> 00:00:33,780
probably for my talk which only occurred

00:00:30,029 --> 00:00:36,809
to me later is an illustrated guide to

00:00:33,780 --> 00:00:39,300
this because you all know what happens

00:00:36,809 --> 00:00:50,940
in in Python if you if you type import

00:00:39,300 --> 00:00:53,190
this of how it should look and how it

00:00:50,940 --> 00:00:54,899
should behave and that is what really

00:00:53,190 --> 00:00:57,840
this talk is about how to take those

00:00:54,899 --> 00:01:02,670
principles and apply them to designing

00:00:57,840 --> 00:01:04,769
an interface to a to a foreign system so

00:01:02,670 --> 00:01:07,650
first a little little motivation what

00:01:04,769 --> 00:01:09,229
what brought me here and that's that's

00:01:07,650 --> 00:01:12,810
elastic the company that I work for

00:01:09,229 --> 00:01:15,330
where I actually create a Python client

00:01:12,810 --> 00:01:17,460
for elastic search so search and

00:01:15,330 --> 00:01:19,740
analytics engine and it's not at all

00:01:17,460 --> 00:01:21,900
important for this talk but what is

00:01:19,740 --> 00:01:24,689
important is we'll be using it for some

00:01:21,900 --> 00:01:26,610
for some examples so don't be don't be

00:01:24,689 --> 00:01:30,590
alarmed if you see some JSON somewhere

00:01:26,610 --> 00:01:35,460
in there so let's get to it

00:01:30,590 --> 00:01:38,369
so import this the design of Python as I

00:01:35,460 --> 00:01:40,380
said a guiding set of principles and I

00:01:38,369 --> 00:01:43,829
always like them you know they sound

00:01:40,380 --> 00:01:46,320
cool and they they really make sense to

00:01:43,829 --> 00:01:49,110
me but I always struggle a little bit

00:01:46,320 --> 00:01:51,560
how do you apply them how do you apply

00:01:49,110 --> 00:01:56,040
them to code does that actually

00:01:51,560 --> 00:01:57,240
translate does it make any sense in this

00:01:56,040 --> 00:02:00,899
talk I would like to share how I

00:01:57,240 --> 00:02:03,240
actually discovered or maybe I just

00:02:00,899 --> 00:02:06,119
rationalized it away it doesn't really

00:02:03,240 --> 00:02:08,670
quite matter probably how I discovered

00:02:06,119 --> 00:02:11,879
how I use these principles when I design

00:02:08,670 --> 00:02:12,980
a new API and how I actually apply them

00:02:11,879 --> 00:02:17,569
in a real

00:02:12,980 --> 00:02:20,569
and because I actually said I a lot

00:02:17,569 --> 00:02:22,760
ain't just in the past sentence a little

00:02:20,569 --> 00:02:25,099
bit of disclaimer is in place this is

00:02:22,760 --> 00:02:28,630
obviously my personal opinion this is

00:02:25,099 --> 00:02:31,760
what I find that works for me and also

00:02:28,630 --> 00:02:34,670
some of you that may have seen my code

00:02:31,760 --> 00:02:38,380
and documentation or lack thereof

00:02:34,670 --> 00:02:41,120
so please do as I say and not as I do

00:02:38,380 --> 00:02:45,140
because I certainly am NOT I'm not

00:02:41,120 --> 00:02:50,720
perfect and my code definitely reflects

00:02:45,140 --> 00:02:54,470
that so any good talk begins with the

00:02:50,720 --> 00:02:57,610
definition right so API what do we mean

00:02:54,470 --> 00:03:01,760
by API what do we mean by an interface

00:02:57,610 --> 00:03:04,790
so for for this talk in particular we

00:03:01,760 --> 00:03:07,849
mean a Python API an interface to a

00:03:04,790 --> 00:03:10,459
foreign system so something that will

00:03:07,849 --> 00:03:14,530
allow you to talk to a third-party

00:03:10,459 --> 00:03:17,540
system in our case elasticsearch and

00:03:14,530 --> 00:03:20,630
this is something that typically you

00:03:17,540 --> 00:03:21,799
don't need in Python I mean python is

00:03:20,630 --> 00:03:23,209
turing-complete

00:03:21,799 --> 00:03:25,100
right you can right absolutely anything

00:03:23,209 --> 00:03:27,910
in Python so you don't need these

00:03:25,100 --> 00:03:30,739
interfaces you can communicate directly

00:03:27,910 --> 00:03:32,420
especially in case like like

00:03:30,739 --> 00:03:37,130
elasticsearch which actually just speaks

00:03:32,420 --> 00:03:39,530
HTTP and JSON you can just use requests

00:03:37,130 --> 00:03:42,350
or any other favorite HTTP library and

00:03:39,530 --> 00:03:43,880
talk to it directly but that's not

00:03:42,350 --> 00:03:46,459
really what you want to do you don't

00:03:43,880 --> 00:03:49,370
want to keep rediscovering the wheel and

00:03:46,459 --> 00:03:53,359
that's why we have api's the some

00:03:49,370 --> 00:03:57,160
somebody created an API to make things

00:03:53,359 --> 00:04:00,470
simpler to to hide away the complexity

00:03:57,160 --> 00:04:04,790
so you might talk about an API in this

00:04:00,470 --> 00:04:06,500
case that it is a service for code for

00:04:04,790 --> 00:04:09,049
the real code for the code that actually

00:04:06,500 --> 00:04:11,209
does the work for the application code

00:04:09,049 --> 00:04:15,230
and there is a huge difference between

00:04:11,209 --> 00:04:17,919
the the code of the API and the code of

00:04:15,230 --> 00:04:24,530
the application the the the real code

00:04:17,919 --> 00:04:26,710
because the API is really doesn't really

00:04:24,530 --> 00:04:29,960
apply for a specific use case

00:04:26,710 --> 00:04:33,140
because the API doesn't know anything

00:04:29,960 --> 00:04:34,730
about the real code so it can be used by

00:04:33,140 --> 00:04:37,820
many different people in many different

00:04:34,730 --> 00:04:39,350
organization and hopefully it will be

00:04:37,820 --> 00:04:42,110
like that's sort of what you hope for

00:04:39,350 --> 00:04:47,510
when you create an API right that people

00:04:42,110 --> 00:04:49,760
will use it that it will spread so the

00:04:47,510 --> 00:04:53,510
application on the other hand is always

00:04:49,760 --> 00:04:59,240
written to solve a specific purpose so

00:04:53,510 --> 00:05:02,150
the API fulfills a contract for førde

00:04:59,240 --> 00:05:05,450
that code and the contract can be either

00:05:02,150 --> 00:05:07,430
explicit or implicit it can either be

00:05:05,450 --> 00:05:10,070
explicit via documentation you can

00:05:07,430 --> 00:05:12,230
document the contract you can say these

00:05:10,070 --> 00:05:13,970
are the methods these are the responses

00:05:12,230 --> 00:05:16,520
and that's probably something that you

00:05:13,970 --> 00:05:18,050
should have either way but you can you

00:05:16,520 --> 00:05:20,740
can also have sort of an implicit

00:05:18,050 --> 00:05:25,010
contract a cultural one if you please

00:05:20,740 --> 00:05:26,930
which sort of makes the API behave as

00:05:25,010 --> 00:05:28,400
you would expect it it should be it

00:05:26,930 --> 00:05:33,080
should be natural and you should be able

00:05:28,400 --> 00:05:36,830
to rationalize and and to think about

00:05:33,080 --> 00:05:38,900
the API and avoid any any surprises

00:05:36,830 --> 00:05:41,660
that's sort of what you want for the

00:05:38,900 --> 00:05:44,000
users of your API to be able to use it

00:05:41,660 --> 00:05:47,320
as if it were part of their system to

00:05:44,000 --> 00:05:50,630
not having to think about it too much

00:05:47,320 --> 00:05:53,890
but first of all we need to we need to

00:05:50,630 --> 00:05:57,700
address some of the issues with the API

00:05:53,890 --> 00:06:01,970
the first one is that the API is vaguer

00:05:57,700 --> 00:06:03,440
then then application code and yes I

00:06:01,970 --> 00:06:08,960
actually had to look this up it is an

00:06:03,440 --> 00:06:11,270
actual word I wasn't sure for a while it

00:06:08,960 --> 00:06:15,020
is actually it is actually accepted by

00:06:11,270 --> 00:06:17,470
the dictionary okay the the the British

00:06:15,020 --> 00:06:22,720
protest again

00:06:17,470 --> 00:06:24,550
what a surprise so it is a lot vaguer it

00:06:22,720 --> 00:06:26,710
doesn't really know what it's going to

00:06:24,550 --> 00:06:28,570
be used for an application code is

00:06:26,710 --> 00:06:30,550
specific it solves and it solves a

00:06:28,570 --> 00:06:34,840
problem you create an application to

00:06:30,550 --> 00:06:38,020
scratch an itch to to deliver a solution

00:06:34,840 --> 00:06:41,290
to your customer or to power your

00:06:38,020 --> 00:06:44,140
product but your API can be used in so

00:06:41,290 --> 00:06:46,630
many different ways that you never you

00:06:44,140 --> 00:06:49,780
never know and making any sort of

00:06:46,630 --> 00:06:52,690
assumptions on how your API is going to

00:06:49,780 --> 00:06:57,340
be used is can be very can be very

00:06:52,690 --> 00:06:59,410
difficult so ultimately the API is just

00:06:57,340 --> 00:07:02,290
a tool and you always have to keep that

00:06:59,410 --> 00:07:05,500
in mind that it's a tool that should be

00:07:02,290 --> 00:07:11,370
a that anyone should be able to wheel to

00:07:05,500 --> 00:07:15,820
create patient and it's a tool to

00:07:11,370 --> 00:07:17,940
simplify access and to simplify access

00:07:15,820 --> 00:07:21,160
the crucial part there is to simplify

00:07:17,940 --> 00:07:23,610
and we have our first slide from design

00:07:21,160 --> 00:07:26,380
of Python simple is better than complex

00:07:23,610 --> 00:07:28,810
complex is better than complicated and

00:07:26,380 --> 00:07:31,990
that is the purpose of the API to

00:07:28,810 --> 00:07:33,940
actually facilitate this this line to

00:07:31,990 --> 00:07:37,660
take something that would be complicated

00:07:33,940 --> 00:07:40,240
opening a socket creating an HTTP header

00:07:37,660 --> 00:07:42,340
sending it over creating a JSON body

00:07:40,240 --> 00:07:44,140
sending it over receiving some responses

00:07:42,340 --> 00:07:47,860
determining if everything went okay

00:07:44,140 --> 00:07:50,650
etc etc that's definitely unnecessary

00:07:47,860 --> 00:07:54,010
complex and that applies to to anything

00:07:50,650 --> 00:07:56,020
if you want to work with HTTP you also

00:07:54,010 --> 00:07:57,490
probably wouldn't start with raw socket

00:07:56,020 --> 00:08:01,840
but you would use something like

00:07:57,490 --> 00:08:05,950
requests a well-designed library that

00:08:01,840 --> 00:08:08,979
just gives you exactly the functionality

00:08:05,950 --> 00:08:13,690
that you need in a way that you can that

00:08:08,979 --> 00:08:16,180
you can use so that's that's what

00:08:13,690 --> 00:08:21,100
simplifying access is about it's about

00:08:16,180 --> 00:08:24,040
hiding complexity so this is a query for

00:08:21,100 --> 00:08:26,320
a to elastic search don't worry if you

00:08:24,040 --> 00:08:28,630
if you don't understand it essentially

00:08:26,320 --> 00:08:31,030
what this is is I'm looking for

00:08:28,630 --> 00:08:34,390
something that that matches Python

00:08:31,030 --> 00:08:35,980
in the title it must not match beta in

00:08:34,390 --> 00:08:39,310
the description so I'm looking for

00:08:35,980 --> 00:08:42,940
release I'm filtering only those

00:08:39,310 --> 00:08:44,800
packages in category search and I want

00:08:42,940 --> 00:08:47,800
to do some aggregations I want to see

00:08:44,800 --> 00:08:52,080
the distribution of tags and the maximum

00:08:47,800 --> 00:08:54,490
lines so just some just some query

00:08:52,080 --> 00:08:56,920
assuming assuming a data set and that

00:08:54,490 --> 00:08:59,680
query is not important what is important

00:08:56,920 --> 00:09:02,710
that there is a lot more things on the

00:08:59,680 --> 00:09:06,190
screen than what I just read and I read

00:09:02,710 --> 00:09:08,740
all that this does in the end it just

00:09:06,190 --> 00:09:11,080
prints it out with the relevancy score

00:09:08,740 --> 00:09:14,260
and and the title of the risk of the

00:09:11,080 --> 00:09:16,990
document so there isn't really a lot of

00:09:14,260 --> 00:09:18,790
things actually going on but there is a

00:09:16,990 --> 00:09:22,030
lot of things that are being typed there

00:09:18,790 --> 00:09:26,650
so how do we how do we simplify that how

00:09:22,030 --> 00:09:30,010
do we hide the complexity well this is

00:09:26,650 --> 00:09:32,080
what I came up with and I'll spend the

00:09:30,010 --> 00:09:35,980
rest of my talk explaining to you why

00:09:32,080 --> 00:09:37,660
and how I came up with that I already

00:09:35,980 --> 00:09:40,570
see some people cringing because they've

00:09:37,660 --> 00:09:44,530
used this code before it's never a good

00:09:40,570 --> 00:09:46,030
sign okay so in this case I tried to

00:09:44,530 --> 00:09:48,970
extract only the things that are

00:09:46,030 --> 00:09:52,180
relevant only and the stuff that I

00:09:48,970 --> 00:09:55,690
actually read only the action items not

00:09:52,180 --> 00:09:58,270
really not really all the gravy all the

00:09:55,690 --> 00:10:01,660
boilerplate code and to me that's what

00:09:58,270 --> 00:10:05,470
an API should do it should hide away all

00:10:01,660 --> 00:10:07,390
the boilerplate while leaving all and

00:10:05,470 --> 00:10:09,610
that's that's the crucial part while

00:10:07,390 --> 00:10:13,650
living all of the important parts not

00:10:09,610 --> 00:10:16,990
just some but all of the important parts

00:10:13,650 --> 00:10:19,690
and that's sort of the embodiment of

00:10:16,990 --> 00:10:22,690
another line of design of Python be

00:10:19,690 --> 00:10:27,340
explicit explicit is better than

00:10:22,690 --> 00:10:29,440
implicit so while I hid away a lot of

00:10:27,340 --> 00:10:32,880
the complexity I didn't hide away the

00:10:29,440 --> 00:10:35,530
crucial parts and that's sort of the

00:10:32,880 --> 00:10:38,110
very important decision to what to hide

00:10:35,530 --> 00:10:40,000
and what not to hide because you can

00:10:38,110 --> 00:10:42,040
always go to the next step you can

00:10:40,000 --> 00:10:44,950
always imagine how you could make this

00:10:42,040 --> 00:10:46,870
even simpler for example just

00:10:44,950 --> 00:10:48,310
creating some sort of query language

00:10:46,870 --> 00:10:51,010
where you would just say the three words

00:10:48,310 --> 00:10:53,650
and say this should be there this

00:10:51,010 --> 00:10:56,890
shouldn't and this must be there as a

00:10:53,650 --> 00:10:58,840
filter etc but at that point it's it's

00:10:56,890 --> 00:11:01,330
getting hard to read it's getting hard

00:10:58,840 --> 00:11:08,620
to get into it's getting hard to reason

00:11:01,330 --> 00:11:11,380
about so be explicit and in in the word

00:11:08,620 --> 00:11:14,770
of code what that means is when you're

00:11:11,380 --> 00:11:19,840
hiding from complexity do hide the

00:11:14,770 --> 00:11:24,060
mechanics do not hide the meaning so if

00:11:19,840 --> 00:11:26,830
you're doing an HTTP request with

00:11:24,060 --> 00:11:28,900
requests you still have to know what is

00:11:26,830 --> 00:11:33,070
the difference between get and post and

00:11:28,900 --> 00:11:35,380
put that is the meaning that is of the

00:11:33,070 --> 00:11:37,800
mechanic what you don't really want to

00:11:35,380 --> 00:11:40,660
know about is about sockets and and

00:11:37,800 --> 00:11:43,600
parsing of HTTP headers you just want a

00:11:40,660 --> 00:11:45,310
convenient access to it so that's

00:11:43,600 --> 00:11:47,410
mechanics that's something that you

00:11:45,310 --> 00:11:50,950
should hide away that's something that's

00:11:47,410 --> 00:11:53,890
not specific to the problem that's

00:11:50,950 --> 00:11:56,440
specific to the implementation so this

00:11:53,890 --> 00:12:00,060
is sort of how how you how you draw the

00:11:56,440 --> 00:12:04,870
line what too high and what not to hide

00:12:00,060 --> 00:12:08,190
so if we look into into the the original

00:12:04,870 --> 00:12:08,190
the original code

00:12:08,410 --> 00:12:13,800
so you see I've highlighted the parts

00:12:11,440 --> 00:12:17,500
that are actually just the mechanics

00:12:13,800 --> 00:12:20,470
sorry about this where you see that

00:12:17,500 --> 00:12:22,480
either I have a bull query which which

00:12:20,470 --> 00:12:24,730
has three branches mas mas nought and

00:12:22,480 --> 00:12:28,180
filter and those can be those can be

00:12:24,730 --> 00:12:31,900
very confusing and also they don't

00:12:28,180 --> 00:12:35,800
matter they don't come they don't carry

00:12:31,900 --> 00:12:38,140
any information they're just a way that

00:12:35,800 --> 00:12:40,690
the query DSL the language that

00:12:38,140 --> 00:12:43,780
elasticsearch uses based on Jason how it

00:12:40,690 --> 00:12:47,440
expresses how to combine other queries

00:12:43,780 --> 00:12:49,840
it is it is the how it is not the what

00:12:47,440 --> 00:12:51,610
in this case this is not what you want

00:12:49,840 --> 00:12:55,450
to do this is how you want to do it and

00:12:51,610 --> 00:12:58,360
this is something that I I don't want my

00:12:55,450 --> 00:13:02,020
my users to have to know

00:12:58,360 --> 00:13:04,750
in order to use my library however I am

00:13:02,020 --> 00:13:09,250
fully comfortable enforcing them to know

00:13:04,750 --> 00:13:12,370
all the rest so I that's all that I hid

00:13:09,250 --> 00:13:18,370
I never I never hid the match or the

00:13:12,370 --> 00:13:19,390
term query so this is the meaning you

00:13:18,370 --> 00:13:21,220
still have to know what is the

00:13:19,390 --> 00:13:23,890
difference between a term query a match

00:13:21,220 --> 00:13:25,750
query and how to do how to new negation

00:13:23,890 --> 00:13:29,130
in this case the negation is in Python

00:13:25,750 --> 00:13:31,750
so we should all be familiar with it but

00:13:29,130 --> 00:13:34,450
that's the meaning that's the same as

00:13:31,750 --> 00:13:37,330
requests still asking you to know the

00:13:34,450 --> 00:13:41,920
difference between HTTP GET and HTTP

00:13:37,330 --> 00:13:44,350
post if I if I hid this away it would

00:13:41,920 --> 00:13:48,220
make a lot of a lot of people's lives

00:13:44,350 --> 00:13:51,190
easier but then you would have a very

00:13:48,220 --> 00:13:54,010
narrow ceiling after which there is

00:13:51,190 --> 00:13:57,930
nothing there is nothing you can do and

00:13:54,010 --> 00:14:01,780
also this means that I don't have to

00:13:57,930 --> 00:14:05,110
teach my users everything they can just

00:14:01,780 --> 00:14:07,060
use the skills that they already have by

00:14:05,110 --> 00:14:10,090
understanding the query yourself

00:14:07,060 --> 00:14:12,220
elasticsearch itself on the other side

00:14:10,090 --> 00:14:15,760
with the request example people

00:14:12,220 --> 00:14:18,580
understanding HTTP and HTTPS I don't

00:14:15,760 --> 00:14:21,700
have to reinvent that it's already there

00:14:18,580 --> 00:14:25,600
people already know it so all I have to

00:14:21,700 --> 00:14:27,670
do is give them access to it and a

00:14:25,600 --> 00:14:30,700
similar thing goes for goes for the

00:14:27,670 --> 00:14:34,240
results here I have some some crazy

00:14:30,700 --> 00:14:37,840
dictionaries with with underscore source

00:14:34,240 --> 00:14:41,050
and underscore score that can be a

00:14:37,840 --> 00:14:41,830
little difficult and again it just bears

00:14:41,050 --> 00:14:43,870
no meaning

00:14:41,830 --> 00:14:46,600
90% of the time people just want access

00:14:43,870 --> 00:14:49,360
to the fields or alternatively the meta

00:14:46,600 --> 00:14:52,120
fields so again just abstract it away

00:14:49,360 --> 00:14:54,850
hide it and also provide a more

00:14:52,120 --> 00:14:56,830
convenient way to access it so instead

00:14:54,850 --> 00:14:59,200
of square brackets and quotes and

00:14:56,830 --> 00:15:03,640
underscore source in every single line

00:14:59,200 --> 00:15:06,070
just use the title so this is something

00:15:03,640 --> 00:15:09,180
that just simplifies the mechanics while

00:15:06,070 --> 00:15:14,250
not actually taking anything away

00:15:09,180 --> 00:15:20,970
and also it's good to fully admit to the

00:15:14,250 --> 00:15:22,290
leakiness so in this case still showing

00:15:20,970 --> 00:15:25,080
all the different all the different

00:15:22,290 --> 00:15:27,150
query types all the different

00:15:25,080 --> 00:15:29,580
aggregations you see that I still force

00:15:27,150 --> 00:15:31,860
the users to name their aggregations

00:15:29,580 --> 00:15:34,530
just as they would in the in the query

00:15:31,860 --> 00:15:37,560
DSL so they can then get them back in

00:15:34,530 --> 00:15:42,000
the results it's a very thin abstract

00:15:37,560 --> 00:15:45,030
layer exactly because I want people who

00:15:42,000 --> 00:15:46,740
use elasticsearch in some other contexts

00:15:45,030 --> 00:15:49,110
maybe from another language maybe

00:15:46,740 --> 00:15:51,450
directly through the browser or the

00:15:49,110 --> 00:15:53,700
command line I want them to be more

00:15:51,450 --> 00:15:57,510
effective I don't want them to have to

00:15:53,700 --> 00:16:00,510
learn yet another tool to do what they

00:15:57,510 --> 00:16:02,520
already can do and also once they learn

00:16:00,510 --> 00:16:04,890
this tool I don't want that to go to

00:16:02,520 --> 00:16:07,620
waste if they have to change to that

00:16:04,890 --> 00:16:11,550
something else or if they have to ask

00:16:07,620 --> 00:16:13,830
for advice online if I if I created my

00:16:11,550 --> 00:16:17,520
own complete query language and then I

00:16:13,830 --> 00:16:19,200
had to ask someone on the internet so

00:16:17,520 --> 00:16:21,780
this is what I'm doing with Asik search

00:16:19,200 --> 00:16:24,510
can you help me well the answer will be

00:16:21,780 --> 00:16:26,310
no because nobody else will understand

00:16:24,510 --> 00:16:29,280
that query language so the

00:16:26,310 --> 00:16:33,300
standardization the the leaky

00:16:29,280 --> 00:16:36,450
abstraction here is very very important

00:16:33,300 --> 00:16:38,880
and very deliberate and it is also

00:16:36,450 --> 00:16:40,740
because well I'm lazy and I don't want

00:16:38,880 --> 00:16:42,980
to rewrite the entire documentation of

00:16:40,740 --> 00:16:47,400
elasticsearch what query does what

00:16:42,980 --> 00:16:50,700
there's that too so that's sort of

00:16:47,400 --> 00:16:55,200
another guiding guiding principles be

00:16:50,700 --> 00:16:58,610
familiar present to the user something

00:16:55,200 --> 00:17:01,830
that they they know from somewhere else

00:16:58,610 --> 00:17:05,580
whether it's a whether it's a universal

00:17:01,830 --> 00:17:07,980
concept like different types of HTTP

00:17:05,580 --> 00:17:11,250
requests or different types of queries

00:17:07,980 --> 00:17:16,440
in lastik search or something that's

00:17:11,250 --> 00:17:19,470
already been used before so don't be

00:17:16,440 --> 00:17:22,059
afraid to just copy shamelessly from

00:17:19,470 --> 00:17:24,980
stuff that you've seen

00:17:22,059 --> 00:17:26,990
so essentially you could sum up the the

00:17:24,980 --> 00:17:30,370
library that I created the elasticsearch

00:17:26,990 --> 00:17:33,679
DSL as a combination of these two things

00:17:30,370 --> 00:17:36,470
the second one we've already seen that's

00:17:33,679 --> 00:17:38,059
just using the raw elasticsearch api and

00:17:36,470 --> 00:17:43,030
the first one

00:17:38,059 --> 00:17:48,559
well--that's Gengo query sets so that I

00:17:43,030 --> 00:17:50,480
borrowed some some patterns from Jango

00:17:48,559 --> 00:17:54,080
some patterns from elasticsearch and

00:17:50,480 --> 00:17:56,630
combine them together so for example the

00:17:54,080 --> 00:17:58,789
the chaining the the fact that every

00:17:56,630 --> 00:18:00,860
additional filter whenever you add a

00:17:58,789 --> 00:18:04,039
filter you will get returned a copy of

00:18:00,860 --> 00:18:06,049
the of the query that comes from that

00:18:04,039 --> 00:18:09,320
comes from Jango that's something that

00:18:06,049 --> 00:18:11,900
people expect or at least are familiar

00:18:09,320 --> 00:18:13,789
with and then you have all the different

00:18:11,900 --> 00:18:17,780
all the different query types that come

00:18:13,789 --> 00:18:20,659
from from elasticsearch so Python people

00:18:17,780 --> 00:18:22,610
who want to use Asik search should be

00:18:20,659 --> 00:18:26,480
familiar with both of these concepts and

00:18:22,610 --> 00:18:27,350
the API should feel homey to them should

00:18:26,480 --> 00:18:29,990
feel familiar

00:18:27,350 --> 00:18:33,350
they shouldn't be surprised and they

00:18:29,990 --> 00:18:38,360
should be they should be effective so

00:18:33,350 --> 00:18:40,970
once I did that I turned into to another

00:18:38,360 --> 00:18:45,049
rule be consistent once you figure out

00:18:40,970 --> 00:18:46,909
your approach stick to it so special

00:18:45,049 --> 00:18:50,780
cases aren't special enough to break the

00:18:46,909 --> 00:18:55,309
rules so every single method that you

00:18:50,780 --> 00:18:58,429
have on this on the search object in our

00:18:55,309 --> 00:19:04,190
secure DSL will return you copy the the

00:18:58,429 --> 00:19:06,620
chaining works just as expected and the

00:19:04,190 --> 00:19:08,600
other important part that people

00:19:06,620 --> 00:19:12,590
sometimes forget about when talking

00:19:08,600 --> 00:19:14,690
about consistency is the naming name

00:19:12,590 --> 00:19:18,010
things consistently name name things

00:19:14,690 --> 00:19:22,190
consistently with other systems but more

00:19:18,010 --> 00:19:26,240
exactly within your system always call

00:19:22,190 --> 00:19:28,370
it the same and that is both in your

00:19:26,240 --> 00:19:29,630
code and also in your in your

00:19:28,370 --> 00:19:33,380
documentation

00:19:29,630 --> 00:19:36,860
and of course only do this if this makes

00:19:33,380 --> 00:19:39,470
sense because practicality always beats

00:19:36,860 --> 00:19:42,799
purity in in Python like we are we are

00:19:39,470 --> 00:19:48,169
practical people we we're not really

00:19:42,799 --> 00:19:52,520
interested in the in the pure purity

00:19:48,169 --> 00:19:55,880
just for just for its sake so don't be

00:19:52,520 --> 00:19:58,490
afraid to make an exception like try not

00:19:55,880 --> 00:20:02,450
to make one but if you have to that's

00:19:58,490 --> 00:20:05,690
okay so in our case we have we have the

00:20:02,450 --> 00:20:07,850
queries of the table that followed the

00:20:05,690 --> 00:20:11,260
pattern every to every call to a method

00:20:07,850 --> 00:20:16,100
will create a clone of the query object

00:20:11,260 --> 00:20:18,130
mutated and return it however when I try

00:20:16,100 --> 00:20:20,809
to do this for Earth for aggregations

00:20:18,130 --> 00:20:24,169
this just didn't work because

00:20:20,809 --> 00:20:27,559
aggregations can be nested and the first

00:20:24,169 --> 00:20:30,530
way how people me including try to

00:20:27,559 --> 00:20:34,659
represent nested aggregations would be

00:20:30,530 --> 00:20:37,429
just to nest nest the chaining calls and

00:20:34,659 --> 00:20:40,100
at that point it all broke down I

00:20:37,429 --> 00:20:44,600
couldn't no longer be creating a copy

00:20:40,100 --> 00:20:46,820
after every after every call so I had to

00:20:44,600 --> 00:20:49,610
I had to break the pattern so when you

00:20:46,820 --> 00:20:53,330
access as the eggs it's actually done in

00:20:49,610 --> 00:20:56,510
flights so don't be afraid to break the

00:20:53,330 --> 00:20:59,090
rules try not to but also keep in mind

00:20:56,510 --> 00:21:01,370
that it might happen that you just will

00:20:59,090 --> 00:21:05,179
have to and that's okay

00:21:01,370 --> 00:21:07,850
the Zen fight on says so and smarter

00:21:05,179 --> 00:21:10,000
people then me wrote that so I'm okay

00:21:07,850 --> 00:21:10,000
with it

00:21:11,600 --> 00:21:19,040
another very important rule when

00:21:14,570 --> 00:21:22,850
designing an API is be friendly be

00:21:19,040 --> 00:21:26,030
friendly to your users on both sides be

00:21:22,850 --> 00:21:28,340
friendly to the users of your API but

00:21:26,030 --> 00:21:32,710
also be be friendly to the system that

00:21:28,340 --> 00:21:37,670
you're trying to simplify access to and

00:21:32,710 --> 00:21:39,470
to me the only non obvious part well

00:21:37,670 --> 00:21:42,140
hardly obvious because it's still pretty

00:21:39,470 --> 00:21:45,860
obvious is to realize that Python is

00:21:42,140 --> 00:21:50,120
interactive a lot of people use Python

00:21:45,860 --> 00:21:53,750
from stuff like ipython or they use

00:21:50,120 --> 00:21:55,580
fancy IDs to explore that the api's and

00:21:53,750 --> 00:21:57,830
you should you should be able to support

00:21:55,580 --> 00:22:00,740
this you should be able to hold them

00:21:57,830 --> 00:22:02,510
with that by providing them all the

00:22:00,740 --> 00:22:07,100
tools that they could that they could

00:22:02,510 --> 00:22:12,190
ever need in the case of Python those

00:22:07,100 --> 00:22:15,560
those are the three main ones they're

00:22:12,190 --> 00:22:19,340
representation and and docstrings which

00:22:15,560 --> 00:22:25,670
if if implemented properly will greatly

00:22:19,340 --> 00:22:29,300
help with with actually allowing the

00:22:25,670 --> 00:22:34,550
users to explore the API and start using

00:22:29,300 --> 00:22:37,550
it both the beginner users who just came

00:22:34,550 --> 00:22:41,390
to your code for the first time and are

00:22:37,550 --> 00:22:43,340
just exploring around and also the

00:22:41,390 --> 00:22:47,410
advanced users where this can greatly

00:22:43,340 --> 00:22:53,800
speed up speed up the process for

00:22:47,410 --> 00:22:56,420
example the the representation string is

00:22:53,800 --> 00:23:00,500
underestimated and it can be super

00:22:56,420 --> 00:23:02,840
useful one of the most common questions

00:23:00,500 --> 00:23:05,630
that I get with elasticsearch DSL is I

00:23:02,840 --> 00:23:08,060
have this crazy query in in JSON that

00:23:05,630 --> 00:23:11,560
somebody wrote or some other tool

00:23:08,060 --> 00:23:15,500
generated how do i express this in

00:23:11,560 --> 00:23:17,360
elasticsearch DSL well I say that's easy

00:23:15,500 --> 00:23:19,430
you just create a query out of it by

00:23:17,360 --> 00:23:23,090
wrapping it in the in the queue object

00:23:19,430 --> 00:23:25,290
and just ask for the representation and

00:23:23,090 --> 00:23:27,210
what you get back is exact

00:23:25,290 --> 00:23:32,610
play the code that will that it would

00:23:27,210 --> 00:23:36,750
take to reconstruct that just using just

00:23:32,610 --> 00:23:38,520
using the DSL library so that's what

00:23:36,750 --> 00:23:41,880
really the representation strength

00:23:38,520 --> 00:23:44,910
should be a representation of the object

00:23:41,880 --> 00:23:48,210
that you can essentially retype into

00:23:44,910 --> 00:23:49,650
Python and get the same thing in some

00:23:48,210 --> 00:23:51,870
cases it's so practical if you have

00:23:49,650 --> 00:23:54,840
large objects obviously or you have

00:23:51,870 --> 00:23:58,200
something that can only exist exist once

00:23:54,840 --> 00:24:01,140
it's not that useful but in this case it

00:23:58,200 --> 00:24:05,100
is definitely definitely very useful and

00:24:01,140 --> 00:24:07,740
it saves me a lot of time because this

00:24:05,100 --> 00:24:10,530
is something that I myself use quite

00:24:07,740 --> 00:24:13,680
often that I have this I have this crazy

00:24:10,530 --> 00:24:15,900
dictionary containing a crazy query with

00:24:13,680 --> 00:24:19,140
ten different sub queries and 50

00:24:15,900 --> 00:24:21,780
aggregations and I want to manipulate it

00:24:19,140 --> 00:24:23,910
and manipulating the dictionary itself

00:24:21,780 --> 00:24:25,490
is is quite difficult that's why I

00:24:23,910 --> 00:24:29,640
created this library in the first place

00:24:25,490 --> 00:24:33,060
so I just wrap it in the wrap it in the

00:24:29,640 --> 00:24:37,800
cube just get the query object that I

00:24:33,060 --> 00:24:40,050
can work with and then when I want to

00:24:37,800 --> 00:24:43,520
put it in my code I can use the

00:24:40,050 --> 00:24:49,590
representation and and put it in there

00:24:43,520 --> 00:24:52,290
and of course of course doc strings B be

00:24:49,590 --> 00:24:54,210
nice to your users provide even some

00:24:52,290 --> 00:24:57,000
examples in your doc string those are

00:24:54,210 --> 00:25:00,120
the most useful if you if you're reading

00:24:57,000 --> 00:25:04,380
if you're reading a header of a method

00:25:00,120 --> 00:25:06,210
like this it's pretty pretty evident

00:25:04,380 --> 00:25:09,810
what it does but if it were anything

00:25:06,210 --> 00:25:12,780
more more involved with more parameters

00:25:09,810 --> 00:25:15,570
it's always nice to include an example

00:25:12,780 --> 00:25:18,150
right there both for when somebody's

00:25:15,570 --> 00:25:20,120
reading the code and also when

00:25:18,150 --> 00:25:23,700
somebody's just looking in their ipython

00:25:20,120 --> 00:25:28,050
off on what's what's actually what's

00:25:23,700 --> 00:25:30,630
actually going on so that's one part of

00:25:28,050 --> 00:25:32,700
Python being interactive that's the more

00:25:30,630 --> 00:25:35,800
obvious part

00:25:32,700 --> 00:25:38,020
the second part is enable iterative

00:25:35,800 --> 00:25:39,820
build because again the Zen of Python

00:25:38,020 --> 00:25:42,870
teaches us that flat is better than

00:25:39,820 --> 00:25:45,730
nested and sparse is better than dense

00:25:42,870 --> 00:25:48,010
so does that mean if you if you build

00:25:45,730 --> 00:25:50,680
something up if you if you want to build

00:25:48,010 --> 00:25:53,350
a sophisticated query into elasticsearch

00:25:50,680 --> 00:25:55,900
you keep adding closets first filter on

00:25:53,350 --> 00:25:59,020
this then on that add this aggregation

00:25:55,900 --> 00:26:01,810
and if the user requested this filtering

00:25:59,020 --> 00:26:04,030
add this kind of filter so there is a

00:26:01,810 --> 00:26:05,920
complicated state that you need to

00:26:04,030 --> 00:26:11,800
remember what the query currently looks

00:26:05,920 --> 00:26:14,080
like and it's a sign of a polite API as

00:26:11,800 --> 00:26:16,720
I would call it that it doesn't force

00:26:14,080 --> 00:26:19,360
you to remember the state but it can

00:26:16,720 --> 00:26:22,210
store the state internally so you can

00:26:19,360 --> 00:26:26,020
use the API from the get-go and start

00:26:22,210 --> 00:26:32,380
building your Larry in this case or your

00:26:26,020 --> 00:26:35,740
request in other cases and you don't

00:26:32,380 --> 00:26:38,620
have to store everything yourself so in

00:26:35,740 --> 00:26:41,970
our case it looks like this you can also

00:26:38,620 --> 00:26:44,890
see that this enables four nice

00:26:41,970 --> 00:26:47,920
practices like commenting the code and

00:26:44,890 --> 00:26:51,460
actually explaining to to the users what

00:26:47,920 --> 00:26:53,530
they're doing and I can go line by line

00:26:51,460 --> 00:26:56,950
and very easily very easily

00:26:53,530 --> 00:26:58,930
deconstructed even if you're new to new

00:26:56,950 --> 00:27:01,740
to elasticsearch you will probably be

00:26:58,930 --> 00:27:05,020
more or less able to tell what this does

00:27:01,740 --> 00:27:07,000
especially with the comments sir sure

00:27:05,020 --> 00:27:08,530
there's still some there so some magic

00:27:07,000 --> 00:27:10,810
there's still something that's specific

00:27:08,530 --> 00:27:13,260
drastic search we've talked about the

00:27:10,810 --> 00:27:16,690
term and match and all the different

00:27:13,260 --> 00:27:20,140
weirdness of the syntax but overall this

00:27:16,690 --> 00:27:22,630
should not be surprising I want to only

00:27:20,140 --> 00:27:28,180
filter category search then I want to

00:27:22,630 --> 00:27:30,310
match the title try thon etc etc but the

00:27:28,180 --> 00:27:33,310
most important part is I don't have to

00:27:30,310 --> 00:27:36,120
first build up some weird dictionary

00:27:33,310 --> 00:27:38,950
containing all the keyword arguments or

00:27:36,120 --> 00:27:41,590
represent the state in any way I can

00:27:38,950 --> 00:27:44,350
just keep creating and keep adding to

00:27:41,590 --> 00:27:47,620
the search object and

00:27:44,350 --> 00:27:52,230
be be happy with that so iterative bill

00:27:47,620 --> 00:27:55,299
it's often something that's that's

00:27:52,230 --> 00:27:59,260
underappreciated because it allows you

00:27:55,299 --> 00:28:03,809
to not care about this about the state

00:27:59,260 --> 00:28:07,809
which can be which can be very hard and

00:28:03,809 --> 00:28:10,559
finally when we're talking about being

00:28:07,809 --> 00:28:15,880
friendly safety is also very friendly

00:28:10,559 --> 00:28:18,460
you should always fail explicitly unless

00:28:15,880 --> 00:28:22,299
unless it's explicitly silenced so all

00:28:18,460 --> 00:28:25,809
your defaults should should actually be

00:28:22,299 --> 00:28:28,020
the safest possible so if you have if

00:28:25,809 --> 00:28:29,919
you have any option to fail for example

00:28:28,020 --> 00:28:33,280
elasticsearch will always give you

00:28:29,919 --> 00:28:35,590
response even if only 20% of your data

00:28:33,280 --> 00:28:38,380
is available it will give you a response

00:28:35,590 --> 00:28:40,539
and say hey I only see 20% of your data

00:28:38,380 --> 00:28:43,330
but here have some have some results

00:28:40,539 --> 00:28:45,070
anyway and then it's up to the user to

00:28:43,330 --> 00:28:50,559
decide whether that's good for them or

00:28:45,070 --> 00:28:53,169
bad when faced with the decision like

00:28:50,559 --> 00:28:55,360
this like do I do I fail in this case or

00:28:53,169 --> 00:29:00,490
is it okay and do I leave it to the user

00:28:55,360 --> 00:29:04,150
I say always fail but allow the user to

00:29:00,490 --> 00:29:06,100
override it allow the user to say I am

00:29:04,150 --> 00:29:10,059
aware that this is a situation that

00:29:06,100 --> 00:29:11,679
might happen and I don't care but at

00:29:10,059 --> 00:29:17,289
that point you force the user to

00:29:11,679 --> 00:29:19,620
explicitly own the responsibility to

00:29:17,289 --> 00:29:21,669
maybe even do something do some research

00:29:19,620 --> 00:29:24,669
you've noticed that that's something

00:29:21,669 --> 00:29:27,340
that that I've repeated quite often

00:29:24,669 --> 00:29:28,690
during this talk to not be afraid to

00:29:27,340 --> 00:29:30,330
force the user to actually burn

00:29:28,690 --> 00:29:33,370
something about what they're doing and

00:29:30,330 --> 00:29:36,669
this one is particularly important

00:29:33,370 --> 00:29:38,830
because it deals with yes with safety

00:29:36,669 --> 00:29:43,230
and it helps prevents nasty surprises

00:29:38,830 --> 00:29:43,230
once the user moves to production

00:29:47,300 --> 00:29:56,140
also think about how you test your code

00:29:51,920 --> 00:30:01,400
and how other people test their code

00:29:56,140 --> 00:30:04,460
provide some sort of a dummy interface

00:30:01,400 --> 00:30:09,200
or maybe just a set of tests test case

00:30:04,460 --> 00:30:12,340
classes for for the your favorite

00:30:09,200 --> 00:30:16,910
testing libraries out there so that

00:30:12,340 --> 00:30:19,700
people have lower barrier to entry to do

00:30:16,910 --> 00:30:22,340
some testing essentially obey the

00:30:19,700 --> 00:30:26,240
testing code make the testing as simple

00:30:22,340 --> 00:30:29,390
as possible because that's what you want

00:30:26,240 --> 00:30:31,490
to do ideally you already have some code

00:30:29,390 --> 00:30:33,320
like that somewhere somewhere in there

00:30:31,490 --> 00:30:36,230
already because you should be testing

00:30:33,320 --> 00:30:41,390
the API so it's only a matter of

00:30:36,230 --> 00:30:44,330
exposing exposing that part also to to

00:30:41,390 --> 00:30:47,170
your users sort of a test helpers or

00:30:44,330 --> 00:30:47,170
something like that

00:30:48,180 --> 00:30:55,380
and the final chapter is about API is

00:30:51,390 --> 00:30:57,540
still being code it's different from an

00:30:55,380 --> 00:31:00,300
application code and we've we've

00:30:57,540 --> 00:31:03,420
highlighted the reasons how but it's

00:31:00,300 --> 00:31:07,170
also similar in a lot of cases it needs

00:31:03,420 --> 00:31:09,680
to be tested things can change and you

00:31:07,170 --> 00:31:14,130
might need to you might need to adapt

00:31:09,680 --> 00:31:16,950
also there is a there is a lot of a lot

00:31:14,130 --> 00:31:20,940
of decisions going into how do you

00:31:16,950 --> 00:31:23,280
decide what goes in and what doesn't

00:31:20,940 --> 00:31:25,200
what are what are the features that you

00:31:23,280 --> 00:31:27,930
want as part of your library as part of

00:31:25,200 --> 00:31:31,200
your API and what do you leave sort of

00:31:27,930 --> 00:31:36,300
as an exercise to the user do I provide

00:31:31,200 --> 00:31:38,460
this set of helpers do I do I expose

00:31:36,300 --> 00:31:41,190
this functionality this this parameter

00:31:38,460 --> 00:31:44,100
or is it only used by a very few people

00:31:41,190 --> 00:31:47,190
and there are there are several several

00:31:44,100 --> 00:31:49,740
ways how to how to do that first of all

00:31:47,190 --> 00:31:51,870
is the actual decision but second is

00:31:49,740 --> 00:31:55,530
that's my favorite to avoid that

00:31:51,870 --> 00:31:58,260
decision and allow the more advanced

00:31:55,530 --> 00:32:01,800
users to sort of to always step away a

00:31:58,260 --> 00:32:05,190
little bit and provide them access to

00:32:01,800 --> 00:32:09,450
the lower light lower layer the more low

00:32:05,190 --> 00:32:12,270
level API in case of elasticsearch I can

00:32:09,450 --> 00:32:14,160
always go one step back and just send in

00:32:12,270 --> 00:32:17,250
a roll dictionary if I don't want to

00:32:14,160 --> 00:32:19,530
create the query using the the iterative

00:32:17,250 --> 00:32:22,410
syntax that I just showed you I can

00:32:19,530 --> 00:32:24,840
always just create it myself and at that

00:32:22,410 --> 00:32:27,210
point I don't have to care what options

00:32:24,840 --> 00:32:28,920
are supported by the DSL and which

00:32:27,210 --> 00:32:32,400
aren't I can just do everything manually

00:32:28,920 --> 00:32:35,160
and send it back the same again it's not

00:32:32,400 --> 00:32:37,560
a novel idea it's the same with the draw

00:32:35,160 --> 00:32:41,550
method on Jango for query sets where you

00:32:37,560 --> 00:32:43,290
can just send in a sequel query when you

00:32:41,550 --> 00:32:46,440
don't want to rely on the Oram to

00:32:43,290 --> 00:32:49,140
generate one for you so always allow

00:32:46,440 --> 00:32:54,720
access to the lower level if at all

00:32:49,140 --> 00:32:58,080
possible and also admit that no code is

00:32:54,720 --> 00:33:01,830
perfect and that goes especially for

00:32:58,080 --> 00:33:05,940
especially for api's because

00:33:01,830 --> 00:33:08,790
vaguer than than the actual application

00:33:05,940 --> 00:33:12,420
code and when deciding what to include

00:33:08,790 --> 00:33:14,670
and what not keep in mind the last line

00:33:12,420 --> 00:33:16,740
of Xenophon that we'll deal with today

00:33:14,670 --> 00:33:20,280
is now he's better than ever

00:33:16,740 --> 00:33:23,820
although never is often better than

00:33:20,280 --> 00:33:26,940
right now and that's the that's an

00:33:23,820 --> 00:33:28,350
important that's an important thing when

00:33:26,940 --> 00:33:30,420
you don't know whether to include

00:33:28,350 --> 00:33:33,990
something or not it's perfectly fine to

00:33:30,420 --> 00:33:38,120
say now especially if you if you have a

00:33:33,990 --> 00:33:41,130
way for the user to move around you and

00:33:38,120 --> 00:33:44,370
so I always prefer to give them away

00:33:41,130 --> 00:33:46,410
around my code then to try and support

00:33:44,370 --> 00:33:48,570
all the different possible avenues

00:33:46,410 --> 00:33:50,670
through my code because that can lead to

00:33:48,570 --> 00:33:52,890
a nightmare they can lead to a nightmare

00:33:50,670 --> 00:33:56,490
for my users with an overwhelming amount

00:33:52,890 --> 00:34:00,060
of options and definitely for a in a

00:33:56,490 --> 00:34:01,910
nightmare for me was supporting all the

00:34:00,060 --> 00:34:05,430
different all the different combinations

00:34:01,910 --> 00:34:10,409
so so think about what makes sense and

00:34:05,430 --> 00:34:14,870
how hard it is to do it without direct

00:34:10,409 --> 00:34:17,580
support in your code if it means that

00:34:14,870 --> 00:34:20,129
when I'm not supporting this option a

00:34:17,580 --> 00:34:22,830
user will have to create a dictionary

00:34:20,129 --> 00:34:25,080
and send it in manually I'm okay with

00:34:22,830 --> 00:34:27,330
that if it means that they will have to

00:34:25,080 --> 00:34:29,520
instantiate a new connection and talk to

00:34:27,330 --> 00:34:31,649
Sokka directly and and do some other

00:34:29,520 --> 00:34:34,110
complicated stuff maybe know that much

00:34:31,649 --> 00:34:38,490
and I want to I want to provide them

00:34:34,110 --> 00:34:41,520
that functionality directly so that's

00:34:38,490 --> 00:34:44,750
sort of the last part of how you decide

00:34:41,520 --> 00:34:48,750
what to support and what not to support

00:34:44,750 --> 00:34:52,050
and now I believe we have ten minutes

00:34:48,750 --> 00:34:53,669
for questions if you don't get your

00:34:52,050 --> 00:34:55,470
questions answered or you just want to

00:34:53,669 --> 00:35:01,760
yell at me there is my there is my

00:34:55,470 --> 00:35:01,760
Twitter and anybody has any questions

00:35:38,990 --> 00:35:47,920
thank you for your talk and I had a

00:35:42,470 --> 00:35:52,540
question so if we create a great API

00:35:47,920 --> 00:35:55,339
we've expressive ap expressive syntax

00:35:52,540 --> 00:35:59,420
don't you think that we're making the

00:35:55,339 --> 00:36:01,460
internals of the of the API more complex

00:35:59,420 --> 00:36:07,700
and really hard to maintain

00:36:01,460 --> 00:36:09,589
can we avoid that yes there's not

00:36:07,700 --> 00:36:12,890
necessarily a correlation between the

00:36:09,589 --> 00:36:16,520
complexity and the and the ease of use

00:36:12,890 --> 00:36:19,339
yes sometimes you might need to resolve

00:36:16,520 --> 00:36:21,319
to more complex things like using meta

00:36:19,339 --> 00:36:24,890
classes and descriptors if you want to

00:36:21,319 --> 00:36:28,010
make things nice but it's not it's not

00:36:24,890 --> 00:36:29,930
necessarily true so it might happen but

00:36:28,010 --> 00:36:34,930
it but it doesn't have to there is there

00:36:29,930 --> 00:36:37,780
is no direct correlation there Thanks

00:36:34,930 --> 00:36:40,780
anyone else

00:36:37,780 --> 00:36:40,780
gentlemen

00:36:43,719 --> 00:36:51,469
hi um what role do you think emulating

00:36:47,930 --> 00:36:55,119
built-in objects or using like Python

00:36:51,469 --> 00:36:59,779
types like the building types comes into

00:36:55,119 --> 00:37:03,799
writing a Python API for example when

00:36:59,779 --> 00:37:08,119
like when should you do you think you

00:37:03,799 --> 00:37:11,569
should use dictionaries lots or should

00:37:08,119 --> 00:37:16,190
you instead jeez like make a little DSL

00:37:11,569 --> 00:37:23,269
for your particular being more I see so

00:37:16,190 --> 00:37:25,729
I prefer to again decide what can you

00:37:23,269 --> 00:37:30,019
take away and then compare the results

00:37:25,729 --> 00:37:31,549
so if I use raw dictionaries and if I if

00:37:30,019 --> 00:37:35,239
I create my own thing

00:37:31,549 --> 00:37:38,420
what part of the pain goes away is it

00:37:35,239 --> 00:37:40,400
enough to justify the the extra

00:37:38,420 --> 00:37:43,069
dependency the work that will go into

00:37:40,400 --> 00:37:45,469
the API etc just sort of do this

00:37:43,069 --> 00:37:47,509
exercise in your mind like okay these

00:37:45,469 --> 00:37:49,640
things I can I can abstract away these

00:37:47,509 --> 00:37:51,380
things I can generate automatically so

00:37:49,640 --> 00:37:54,529
the user will only have to put in these

00:37:51,380 --> 00:37:56,630
these four things and then compare the

00:37:54,529 --> 00:37:58,940
results it might be that the differences

00:37:56,630 --> 00:38:03,319
wouldn't be big enough to justify

00:37:58,940 --> 00:38:06,229
creating a DSL creating a library from

00:38:03,319 --> 00:38:08,449
both the point of putting the work in

00:38:06,229 --> 00:38:11,269
and also forcing the people to learn

00:38:08,449 --> 00:38:14,930
that so that's that's what I do like

00:38:11,269 --> 00:38:17,299
every time I sort of mock-up how the API

00:38:14,930 --> 00:38:22,029
would look like and then I compare is it

00:38:17,299 --> 00:38:22,029
worth it or is it not does it make sense

00:38:23,850 --> 00:38:30,990
I think we have time for one more

00:38:25,440 --> 00:38:32,280
question anyone okay if you have any

00:38:30,990 --> 00:38:33,360
more questions you can just grab them a

00:38:32,280 --> 00:38:36,470
coffee order during lunch

00:38:33,360 --> 00:38:36,470

YouTube URL: https://www.youtube.com/watch?v=FPQrUuddT0s


