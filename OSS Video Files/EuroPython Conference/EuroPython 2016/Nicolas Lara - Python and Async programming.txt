Title: Nicolas Lara - Python and Async programming
Publication date: 2016-07-28
Playlist: EuroPython 2016
Description: 
	Nicolas Lara - Python and Async programming
[EuroPython 2016]
[18 July 2016]
[Bilbao, Euskadi, Spain]
(https://ep2016.europython.eu//conference/talks/python-and-async-programming)

How does the experienced python programmer fair when faced with
python's "new" way of doing async programming for the first time?

This talk details the different ways python provides for attacking the
problem of asynchronous programming and focuses on the best practices
for the future (as of python 3.4 and 3.5)

-----

How does the experienced python programmer fair when faced with
python's "new" way of doing async programing in for the first time?
Do we all know how and when to use Futures, yield from, asyncio,
coroutines, the async and await keywords, eventloops, and others?

A lot has changed in recent versions of Python when it comes to async
programming, concurrency, and parallelism. We still have very
different ways of approaching the problem in each version, but they
are finally (as of python 3.4/3.5) converging to a standard.

This talk explores, from the perspective of an experienced python
programmer with little to no experience in async programming, what the
"one obvious way" to do async programming in Python is supposed to be.
It does so but analysing examples of different categories of async
problems we may want to solve and what the correct way to solve them
with the latest versions of Python would be (along with the trade offs
of different approaches).

The examples include generic CPU-bound problems, IO-bound problems,
and "both-bound" problems; along with common tasks as building a
simple server, scraping, deferring a web response, and traversing
graphs.

When useful, I compare the solutions with the approach we would take
in languages that have been design for- and are known to be good at
async programming like Javascript and Go.
Captions: 
	00:00:00,089 --> 00:00:05,130
can everyone hear me yeah great I think

00:00:03,899 --> 00:00:07,379
they were supposed to be one of the

00:00:05,130 --> 00:00:09,750
organizers here to announce me but I

00:00:07,379 --> 00:00:14,400
don't see anyone and it's time so I

00:00:09,750 --> 00:00:16,020
guess I'll just start yeah so when I

00:00:14,400 --> 00:00:17,940
started looking into the sink I oh I

00:00:16,020 --> 00:00:20,130
noticed that a lot of people thought it

00:00:17,940 --> 00:00:22,199
was quite complicated to use and

00:00:20,130 --> 00:00:24,630
especially to get started with it so I

00:00:22,199 --> 00:00:27,630
gave this talk the subtitle do you need

00:00:24,630 --> 00:00:31,679
to be a wizard to use it and the answer

00:00:27,630 --> 00:00:33,149
is a little bit it's not that hard but

00:00:31,679 --> 00:00:35,010
when you're just getting started there

00:00:33,149 --> 00:00:38,399
are quite a few problems that you'll run

00:00:35,010 --> 00:00:40,649
into and well concurrency is

00:00:38,399 --> 00:00:43,140
intrinsically complicated so it's not

00:00:40,649 --> 00:00:44,370
anyone's fault but there are a lot of

00:00:43,140 --> 00:00:46,379
new concepts there are things you need

00:00:44,370 --> 00:00:49,440
to learn that are not just standard

00:00:46,379 --> 00:00:52,649
Python and it has a very long history

00:00:49,440 --> 00:00:55,559
all the way from the backboards to 2.7 -

00:00:52,649 --> 00:00:57,090
the new keywords in 3.5 the syntax has

00:00:55,559 --> 00:01:01,140
changed a lot and the things you do have

00:00:57,090 --> 00:01:04,379
changed a lot so when you try to figure

00:01:01,140 --> 00:01:07,080
out how to do something there's not one

00:01:04,379 --> 00:01:08,970
way to do it there are different ways in

00:01:07,080 --> 00:01:12,299
different versions and they will change

00:01:08,970 --> 00:01:14,630
quite a lot and sometimes they document

00:01:12,299 --> 00:01:19,590
the best best practice you will find is

00:01:14,630 --> 00:01:22,409
maybe deprecated now so yeah that can be

00:01:19,590 --> 00:01:25,070
a problem and if you don't know the

00:01:22,409 --> 00:01:29,430
internals some things will just be weird

00:01:25,070 --> 00:01:31,799
but you get used to those quite quickly

00:01:29,430 --> 00:01:33,780
and fortunately the code is quite easy

00:01:31,799 --> 00:01:35,549
the I think i/o code and did have is

00:01:33,780 --> 00:01:38,159
quite easy to read so you can look at

00:01:35,549 --> 00:01:39,990
the internals and figure those out and

00:01:38,159 --> 00:01:42,540
there's a lot of incompatible

00:01:39,990 --> 00:01:44,280
terminologies like core routines are

00:01:42,540 --> 00:01:47,159
generators except when they're not

00:01:44,280 --> 00:01:49,890
generators and not all generators are Co

00:01:47,159 --> 00:01:53,310
routines and you know you have api's

00:01:49,890 --> 00:01:55,500
like future that implements the same api

00:01:53,310 --> 00:01:57,000
but it's not you cannot really use them

00:01:55,500 --> 00:01:59,700
interchangeably and you'll run into

00:01:57,000 --> 00:02:01,710
trouble with those things and since it's

00:01:59,700 --> 00:02:06,600
so new there's this bottom-up approach

00:02:01,710 --> 00:02:09,090
to learning as in keio so you wanna it's

00:02:06,600 --> 00:02:12,180
very common that you start understanding

00:02:09,090 --> 00:02:12,569
first go routines that first generator

00:02:12,180 --> 00:02:14,129
is called

00:02:12,569 --> 00:02:15,629
teens and have to understand all the

00:02:14,129 --> 00:02:18,840
internals before you actually start

00:02:15,629 --> 00:02:21,359
writing code with zinc IO so my idea was

00:02:18,840 --> 00:02:23,099
try to simplify this and try to go

00:02:21,359 --> 00:02:25,769
through how I've learned this in Cairo

00:02:23,099 --> 00:02:30,569
and how I started writing things and the

00:02:25,769 --> 00:02:33,450
errors I ran into and see how other

00:02:30,569 --> 00:02:38,040
people can start writing code with us in

00:02:33,450 --> 00:02:40,980
Ko from this and I work at a web agency

00:02:38,040 --> 00:02:43,319
and I came to sync i/o because sometimes

00:02:40,980 --> 00:02:45,239
I think we have to do our concurrent in

00:02:43,319 --> 00:02:47,670
nature and I noticed that some of my

00:02:45,239 --> 00:02:49,859
co-workers just started going to all the

00:02:47,670 --> 00:02:52,049
languages mainly go and say well this is

00:02:49,859 --> 00:02:53,760
too complicated to do in Python I'll

00:02:52,049 --> 00:02:58,939
just write it and go create a service

00:02:53,760 --> 00:03:03,359
and then we can call the service to do

00:02:58,939 --> 00:03:05,730
to solve this problem but I realized

00:03:03,359 --> 00:03:09,510
that Python just added this whole thing

00:03:05,730 --> 00:03:10,950
to do concurrency that has to change the

00:03:09,510 --> 00:03:14,790
way concurrency is supposed to be done

00:03:10,950 --> 00:03:18,090
in Python and we were not really using

00:03:14,790 --> 00:03:20,519
that so I tried to see well can we do

00:03:18,090 --> 00:03:21,780
this with a sink IO instead and some of

00:03:20,519 --> 00:03:24,720
the problems were trying to solve are

00:03:21,780 --> 00:03:27,329
things like creating a back-end service

00:03:24,720 --> 00:03:30,859
for the server for real time with

00:03:27,329 --> 00:03:33,060
server-sent events or WebSockets and

00:03:30,859 --> 00:03:35,639
that would look something like this this

00:03:33,060 --> 00:03:37,590
is a very simple echo server but it's

00:03:35,639 --> 00:03:42,290
not very far from something you could

00:03:37,590 --> 00:03:45,030
actually use to run a WebSocket server

00:03:42,290 --> 00:03:47,790
we could for example try to fetch data

00:03:45,030 --> 00:03:49,079
from several api's concurrently which i

00:03:47,790 --> 00:03:50,370
think is something that is very common

00:03:49,079 --> 00:03:52,229
especially when you're doing

00:03:50,370 --> 00:03:55,229
service-oriented architecture you may

00:03:52,229 --> 00:03:57,840
have tons of api's that you want to get

00:03:55,229 --> 00:04:00,269
data from and if each one of these takes

00:03:57,840 --> 00:04:03,090
about 100 milliseconds and you want a

00:04:00,269 --> 00:04:05,250
query five to ten you might end up

00:04:03,090 --> 00:04:08,060
spending a whole second just waiting for

00:04:05,250 --> 00:04:11,189
IO well you could do this concurrently

00:04:08,060 --> 00:04:12,509
so that's quite easy to do with the

00:04:11,189 --> 00:04:15,269
think I oh it would look something like

00:04:12,509 --> 00:04:17,519
this and you don't have to pay too much

00:04:15,269 --> 00:04:22,349
attention to this example so I look at

00:04:17,519 --> 00:04:23,909
them in more detail later you can do

00:04:22,349 --> 00:04:25,830
some sort of pipeline processing which

00:04:23,909 --> 00:04:28,289
is very similar to before

00:04:25,830 --> 00:04:30,060
instead of just fetching the URLs you

00:04:28,289 --> 00:04:32,069
may want to process them afterwards

00:04:30,060 --> 00:04:35,490
maybe you want to put them in Redis

00:04:32,069 --> 00:04:37,139
maybe you want to parse them as Jayson

00:04:35,490 --> 00:04:42,030
and all these things you can do as

00:04:37,139 --> 00:04:43,919
synchronously and you could copy aside

00:04:42,030 --> 00:04:48,409
into disk again fetch a bunch of URLs

00:04:43,919 --> 00:04:52,139
then lock a file and write to that file

00:04:48,409 --> 00:04:53,430
or you may want to have a complex data

00:04:52,139 --> 00:04:56,159
structure that you want to have in

00:04:53,430 --> 00:04:58,379
memory and you want access but you want

00:04:56,159 --> 00:05:03,419
that every now and then this gets loaded

00:04:58,379 --> 00:05:05,639
from a store somewhere and that would

00:05:03,419 --> 00:05:11,490
look something like this this is just a

00:05:05,639 --> 00:05:16,080
sample code but yeah it would work fine

00:05:11,490 --> 00:05:18,120
any the same way and so as you can see

00:05:16,080 --> 00:05:20,629
all of this examples follow kind of the

00:05:18,120 --> 00:05:22,650
same pattern and that pattern is the

00:05:20,629 --> 00:05:26,310
concurrency model that we're gonna be

00:05:22,650 --> 00:05:28,169
using and there are several models that

00:05:26,310 --> 00:05:30,810
you could use and different languages

00:05:28,169 --> 00:05:34,050
implement different ones and there are

00:05:30,810 --> 00:05:37,949
normally a combination of different

00:05:34,050 --> 00:05:40,650
concurrency models and so I think I

00:05:37,949 --> 00:05:45,870
always basically a formalization of how

00:05:40,650 --> 00:05:48,419
we should do concurrency in Python now I

00:05:45,870 --> 00:05:50,310
think there are two parts to concurrency

00:05:48,419 --> 00:05:51,659
models the first one is how we write and

00:05:50,310 --> 00:05:54,509
understand our code and I think this is

00:05:51,659 --> 00:05:59,219
the most important one this is the one

00:05:54,509 --> 00:06:01,319
that we should focus on and you can see

00:05:59,219 --> 00:06:04,139
that as an API if you wanted to write an

00:06:01,319 --> 00:06:05,520
API for concurrency you could come up

00:06:04,139 --> 00:06:08,129
with something like this you could

00:06:05,520 --> 00:06:10,289
execute something the four runs execute

00:06:08,129 --> 00:06:12,930
something the background wait for a

00:06:10,289 --> 00:06:15,240
result or scheduled execution for things

00:06:12,930 --> 00:06:19,349
later and you can write some functions

00:06:15,240 --> 00:06:21,360
to do this and this is just like a

00:06:19,349 --> 00:06:23,159
pseudo code of something we may want to

00:06:21,360 --> 00:06:24,810
do if we wanted to have this concurrency

00:06:23,159 --> 00:06:26,729
model and if we did that concurrency

00:06:24,810 --> 00:06:29,490
model that would yield programs that

00:06:26,729 --> 00:06:31,560
look a certain way now a santaro will

00:06:29,490 --> 00:06:36,630
give us programs that look in the async

00:06:31,560 --> 00:06:39,120
Iowa and that would be a unified model

00:06:36,630 --> 00:06:41,760
of how we do concurrency in Python

00:06:39,120 --> 00:06:45,360
so the other part of a concurrency model

00:06:41,760 --> 00:06:46,680
is when the code runs and it can run

00:06:45,360 --> 00:06:49,229
traditionally in threads and processes

00:06:46,680 --> 00:06:51,360
you can runner in different machines if

00:06:49,229 --> 00:06:52,919
you use something like MPI or you can

00:06:51,360 --> 00:06:57,600
run an event loop and an event loop is a

00:06:52,919 --> 00:07:00,600
big part of what the SN ko model builds

00:06:57,600 --> 00:07:03,000
upon and I don't I'm not gonna look too

00:07:00,600 --> 00:07:04,380
much into this part of things because I

00:07:03,000 --> 00:07:05,760
don't think it matters that much I'm

00:07:04,380 --> 00:07:08,130
gonna look into the other one that is

00:07:05,760 --> 00:07:09,570
how is the code gonna look and how we're

00:07:08,130 --> 00:07:12,120
gonna understand that that code is

00:07:09,570 --> 00:07:14,340
correct and thus what we want from the

00:07:12,120 --> 00:07:16,410
point of view of concurrency and then

00:07:14,340 --> 00:07:20,280
these things might be interchangeable

00:07:16,410 --> 00:07:21,600
later so let's start looking a little

00:07:20,280 --> 00:07:24,360
bit to pythons answers to these

00:07:21,600 --> 00:07:26,550
questions but before we do that I want

00:07:24,360 --> 00:07:30,270
to tell you what a sync programming

00:07:26,550 --> 00:07:31,889
Python is not and that is just one thing

00:07:30,270 --> 00:07:36,690
and it's a solution to your guilt

00:07:31,889 --> 00:07:38,669
problems so if you are writing code that

00:07:36,690 --> 00:07:40,830
runs a lot of Python spends a lot of

00:07:38,669 --> 00:07:42,630
time is the C Python interpreter

00:07:40,830 --> 00:07:44,669
you're still gonna run into the global

00:07:42,630 --> 00:07:47,580
interpreter lock and this is not gonna

00:07:44,669 --> 00:07:50,700
save you from it there are some projects

00:07:47,580 --> 00:07:53,070
like the Galacta me and pi PI STM the

00:07:50,700 --> 00:07:55,110
uses software transactional memory that

00:07:53,070 --> 00:07:57,539
are trying to fix this in different ways

00:07:55,110 --> 00:08:00,260
but you know we'll have to see what they

00:07:57,539 --> 00:08:04,169
come up with but for now if you're gonna

00:08:00,260 --> 00:08:05,490
do something that is in that the Gil is

00:08:04,169 --> 00:08:08,250
getting in the way then you'll just have

00:08:05,490 --> 00:08:10,139
to go and run them in different

00:08:08,250 --> 00:08:13,710
processes like we've been doing for

00:08:10,139 --> 00:08:17,460
years so okay let's get started let's

00:08:13,710 --> 00:08:20,789
write some code but before we do that I

00:08:17,460 --> 00:08:24,270
wanted to discuss this one just to get

00:08:20,789 --> 00:08:27,860
it out of the way and we set the things

00:08:24,270 --> 00:08:30,870
to run in threads and processes and

00:08:27,860 --> 00:08:33,959
that's fine we can create thread pools

00:08:30,870 --> 00:08:36,240
and with thread pools we can then tell

00:08:33,959 --> 00:08:39,330
them to execute a process and it will

00:08:36,240 --> 00:08:41,729
look something like this but we can also

00:08:39,330 --> 00:08:43,919
run things on an event loop and this is

00:08:41,729 --> 00:08:45,690
the one that is new if we want to run

00:08:43,919 --> 00:08:47,450
something in the event loop we first

00:08:45,690 --> 00:08:49,350
need to know what an event loop is and

00:08:47,450 --> 00:08:50,980
anybody that's work with JavaScript

00:08:49,350 --> 00:08:53,230
probably knows this and

00:08:50,980 --> 00:08:56,050
many of you probably do but in case you

00:08:53,230 --> 00:08:58,180
don't it looks something like this

00:08:56,050 --> 00:08:59,320
it's just a loop that will run

00:08:58,180 --> 00:09:03,850
essentially forever

00:08:59,320 --> 00:09:07,870
and it will pick a task and based on

00:09:03,850 --> 00:09:09,880
some policy and ask that ask that task

00:09:07,870 --> 00:09:12,579
to be executed and that task will

00:09:09,880 --> 00:09:17,079
execute until it decides to suspend

00:09:12,579 --> 00:09:18,550
execution and as you can see there's

00:09:17,079 --> 00:09:20,500
nothing here that is preemptive like

00:09:18,550 --> 00:09:22,180
with threads the task will execute and

00:09:20,500 --> 00:09:24,670
eventually that task will have to tell

00:09:22,180 --> 00:09:26,019
the loop that it has returned from

00:09:24,670 --> 00:09:27,940
functions so that he can continue

00:09:26,019 --> 00:09:30,430
running otherwise the loop will be

00:09:27,940 --> 00:09:32,380
blocked right there once the test

00:09:30,430 --> 00:09:34,360
suspends execution then it can

00:09:32,380 --> 00:09:35,829
reschedule that test decide if the task

00:09:34,360 --> 00:09:37,300
has a result and he wants to do

00:09:35,829 --> 00:09:39,910
something with that result maybe we want

00:09:37,300 --> 00:09:42,579
to store it otherwise we just put that

00:09:39,910 --> 00:09:47,709
past bad back in our queue and select it

00:09:42,579 --> 00:09:49,449
again when we look back and if we want

00:09:47,709 --> 00:09:52,510
to use an event loop in Python it looks

00:09:49,449 --> 00:09:55,420
kind of like this you have a function

00:09:52,510 --> 00:09:59,550
and you can defined a function with the

00:09:55,420 --> 00:10:01,990
same keyword in python 3.5 and when you

00:09:59,550 --> 00:10:04,810
define a function that is supposed to

00:10:01,990 --> 00:10:06,339
run a synchronously that is the same

00:10:04,810 --> 00:10:07,959
keyword tells the function that is

00:10:06,339 --> 00:10:09,970
supposed to run a synchronously so that

00:10:07,959 --> 00:10:12,579
function will not execute unless a loop

00:10:09,970 --> 00:10:14,560
calls it and then we have the awake

00:10:12,579 --> 00:10:18,370
keyword to tell the loop when it's

00:10:14,560 --> 00:10:20,350
supposed to suspend execution so then we

00:10:18,370 --> 00:10:21,970
get an event loop and we tell it to run

00:10:20,350 --> 00:10:25,720
that function until it completes and

00:10:21,970 --> 00:10:27,310
that actually works and if we wanted to

00:10:25,720 --> 00:10:28,990
specify want to run this thing some

00:10:27,310 --> 00:10:31,029
threads instead we don't write a

00:10:28,990 --> 00:10:32,709
synchronous functions and we take a

00:10:31,029 --> 00:10:36,100
normal blocking function that we want to

00:10:32,709 --> 00:10:37,810
run in a thread and we have this utility

00:10:36,100 --> 00:10:39,459
called running executor that were

00:10:37,810 --> 00:10:41,380
actually allow us to just run the

00:10:39,459 --> 00:10:44,589
function and it will return something

00:10:41,380 --> 00:10:47,860
that is a synchronous and that the loop

00:10:44,589 --> 00:10:50,829
knows how to handle so this gives us a

00:10:47,860 --> 00:10:52,329
flexibility of being able to write our

00:10:50,829 --> 00:10:54,639
code write code that will look the same

00:10:52,329 --> 00:10:57,250
way and then choose whether it's gonna

00:10:54,639 --> 00:10:59,470
run in threads processes or in an event

00:10:57,250 --> 00:11:04,540
and have everything control through this

00:10:59,470 --> 00:11:06,040
event of abstraction now let's start

00:11:04,540 --> 00:11:08,529
writing some a cinco what do we need to

00:11:06,040 --> 00:11:11,439
know we need to know it at the asynch

00:11:08,529 --> 00:11:15,069
and await syntax which if we want to

00:11:11,439 --> 00:11:16,839
have a function that is not a

00:11:15,069 --> 00:11:18,160
synchronous that just blocks then that's

00:11:16,839 --> 00:11:20,350
fine we just write a regular function

00:11:18,160 --> 00:11:22,180
and we call it whenever we need it if we

00:11:20,350 --> 00:11:24,160
want to have a function that runs on an

00:11:22,180 --> 00:11:26,500
event loop and the can suspend execution

00:11:24,160 --> 00:11:28,889
then instead we use the async keyword

00:11:26,500 --> 00:11:31,240
and that function will not run by itself

00:11:28,889 --> 00:11:33,699
inside that function we can use a weight

00:11:31,240 --> 00:11:36,670
and a weight will just it's very similar

00:11:33,699 --> 00:11:38,529
to a return except when the function

00:11:36,670 --> 00:11:41,290
comes back it will continue execution

00:11:38,529 --> 00:11:45,689
from there so we tell the loop that we

00:11:41,290 --> 00:11:48,819
will suspend execution until some other

00:11:45,689 --> 00:11:50,079
function are available has finished and

00:11:48,819 --> 00:11:52,329
in this case it will be suspended

00:11:50,079 --> 00:12:00,250
situation or that executor where we're

00:11:52,329 --> 00:12:02,620
running the blocking function and one of

00:12:00,250 --> 00:12:05,110
the advantages of this is that this way

00:12:02,620 --> 00:12:08,139
we can specify explicitly when our code

00:12:05,110 --> 00:12:10,329
will suspend when it will execute so if

00:12:08,139 --> 00:12:12,009
we were to run this with threads the

00:12:10,329 --> 00:12:15,610
operating system will tell us when the

00:12:12,009 --> 00:12:17,559
function can stop or when it can't so we

00:12:15,610 --> 00:12:19,899
have to be a lot more careful in terms

00:12:17,559 --> 00:12:21,939
of synchronization whether here the

00:12:19,899 --> 00:12:24,220
function will continue to run until that

00:12:21,939 --> 00:12:28,240
function decides by itself that it will

00:12:24,220 --> 00:12:30,430
stop the other building block that we

00:12:28,240 --> 00:12:35,470
will need with this is futures so a

00:12:30,430 --> 00:12:37,930
future is basically a wrapper that can

00:12:35,470 --> 00:12:39,610
you can check it has three methods you

00:12:37,930 --> 00:12:42,250
can check if it's done you can check if

00:12:39,610 --> 00:12:45,970
it has a result or you can add a result

00:12:42,250 --> 00:12:47,829
to it so when you have a future and you

00:12:45,970 --> 00:12:49,990
check if it's done it normally isn't

00:12:47,829 --> 00:12:53,769
unless you have added a result to it

00:12:49,990 --> 00:12:55,300
then if you ask for a result it doesn't

00:12:53,769 --> 00:12:58,629
have it it will yield an exception

00:12:55,300 --> 00:13:03,189
otherwise it will you can set a result

00:12:58,629 --> 00:13:04,449
and then you will get a result and now

00:13:03,189 --> 00:13:06,339
we now we know there's background

00:13:04,449 --> 00:13:07,820
information so let's try to get a loop

00:13:06,339 --> 00:13:10,100
and start running things

00:13:07,820 --> 00:13:12,530
so we have a loop we want to create it

00:13:10,100 --> 00:13:15,740
run it stop it and schedule things on it

00:13:12,530 --> 00:13:18,350
so to create a loop we use the sync IO

00:13:15,740 --> 00:13:21,050
get event loop and that's it now we have

00:13:18,350 --> 00:13:24,110
a loop and it's not doing anything but

00:13:21,050 --> 00:13:26,720
we have one now if you want to run in

00:13:24,110 --> 00:13:28,460
you can just call run forever on it

00:13:26,720 --> 00:13:30,740
and they will do a success it will run

00:13:28,460 --> 00:13:32,510
forever unless there's an exception

00:13:30,740 --> 00:13:38,000
inside the loop in which case it would

00:13:32,510 --> 00:13:39,680
just throw the exception hmm now if we

00:13:38,000 --> 00:13:42,830
wanted to stop a loop and I think this

00:13:39,680 --> 00:13:44,630
is a little bit confusing a loop can

00:13:42,830 --> 00:13:46,250
only be stopped if it's running so if

00:13:44,630 --> 00:13:50,390
you have a loop and you want to tell it

00:13:46,250 --> 00:13:52,130
to stop you will have to ask it after

00:13:50,390 --> 00:13:54,260
you ask it to be marked to stop you need

00:13:52,130 --> 00:13:57,440
to ask it to run once otherwise the loop

00:13:54,260 --> 00:13:59,000
will not be considered stuff so if you

00:13:57,440 --> 00:14:00,980
want to stop a loop that it's not

00:13:59,000 --> 00:14:04,640
currently running you have to ask it to

00:14:00,980 --> 00:14:08,300
run forever and it will run once and

00:14:04,640 --> 00:14:10,040
then stop which is confusing is the type

00:14:08,300 --> 00:14:12,310
of things that you have to look at the

00:14:10,040 --> 00:14:14,660
internals to understand how it works but

00:14:12,310 --> 00:14:16,760
most of the times you don't have to do

00:14:14,660 --> 00:14:18,560
this

00:14:16,760 --> 00:14:20,240
instead what you do is something like

00:14:18,560 --> 00:14:23,540
this you want to run things on a loop

00:14:20,240 --> 00:14:24,800
instead of managing it manually so let's

00:14:23,540 --> 00:14:26,690
say we have this function that we want

00:14:24,800 --> 00:14:28,340
to run something you just prints a bunch

00:14:26,690 --> 00:14:30,890
of numbers and it waits one second

00:14:28,340 --> 00:14:33,050
between each number so you ask the loop

00:14:30,890 --> 00:14:35,600
to run and you complete and that's it it

00:14:33,050 --> 00:14:37,940
princess we expected it to it's just a

00:14:35,600 --> 00:14:39,260
little bit boring so instead what we

00:14:37,940 --> 00:14:42,560
would want to do it we've been talking

00:14:39,260 --> 00:14:47,060
about concurrency is run something more

00:14:42,560 --> 00:14:48,710
like this we say well we won half two of

00:14:47,060 --> 00:14:52,040
those functions running concurrently and

00:14:48,710 --> 00:14:53,900
if we do that we can use this ensure

00:14:52,040 --> 00:14:57,050
future that we'll just create a future

00:14:53,900 --> 00:14:58,670
and attach it to the loop and we write

00:14:57,050 --> 00:15:01,670
an extra function because we only know

00:14:58,670 --> 00:15:04,610
so far how to run one thing so I say

00:15:01,670 --> 00:15:06,650
okay go look and then when we execute

00:15:04,610 --> 00:15:09,230
that that would actually stop very

00:15:06,650 --> 00:15:12,050
quickly and give us an error and the

00:15:09,230 --> 00:15:14,840
reason this is happening is because we

00:15:12,050 --> 00:15:17,930
created these two futures but we didn't

00:15:14,840 --> 00:15:20,930
really nobody's waiting for them so when

00:15:17,930 --> 00:15:21,440
the root lock the loop runs it runs the

00:15:20,930 --> 00:15:23,990
Gopher

00:15:21,440 --> 00:15:26,029
and he knows that will it will stop when

00:15:23,990 --> 00:15:28,639
the goal function completes so that

00:15:26,029 --> 00:15:30,440
function creates one future it doesn't

00:15:28,639 --> 00:15:32,480
wait for it creates the second future

00:15:30,440 --> 00:15:34,519
doesn't wait for it and then it

00:15:32,480 --> 00:15:36,680
completes so the loop stops running and

00:15:34,519 --> 00:15:40,670
if you're debugging and sync I know you

00:15:36,680 --> 00:15:43,100
will get this nice helpful messages so

00:15:40,670 --> 00:15:45,110
instead what we can do is just await him

00:15:43,100 --> 00:15:47,870
and then we use a wait and we tell the

00:15:45,110 --> 00:15:51,589
loop well I want to run this two things

00:15:47,870 --> 00:15:53,480
but I want to wait for them don't end go

00:15:51,589 --> 00:15:56,089
until they were complete and if you do

00:15:53,480 --> 00:15:57,439
that it will work but if you look at the

00:15:56,089 --> 00:15:59,600
result you can see that he's actually

00:15:57,439 --> 00:16:01,459
running one task first in the second

00:15:59,600 --> 00:16:04,040
test after which it's not really

00:16:01,459 --> 00:16:05,720
concurrent it's just sequential and you

00:16:04,040 --> 00:16:09,560
might as well just have written regular

00:16:05,720 --> 00:16:12,800
functions so instead what we can do is

00:16:09,560 --> 00:16:15,110
try to figure this out and go back to

00:16:12,800 --> 00:16:18,620
the specification and see that we have a

00:16:15,110 --> 00:16:21,139
sink a oh that s completed so we can

00:16:18,620 --> 00:16:24,529
create this task that we want to run and

00:16:21,139 --> 00:16:26,660
then we ask a sink IO to give it back to

00:16:24,529 --> 00:16:29,029
us in a for loop in the order they

00:16:26,660 --> 00:16:31,100
complete and when one of them completes

00:16:29,029 --> 00:16:35,720
we get the future we wait for its result

00:16:31,100 --> 00:16:39,170
and then this works except it's really

00:16:35,720 --> 00:16:40,850
ugly it's this doesn't really look very

00:16:39,170 --> 00:16:42,439
pythonic and it's very complicated for

00:16:40,850 --> 00:16:45,110
just running a couple of things

00:16:42,439 --> 00:16:48,380
concurrently so what we have instead is

00:16:45,110 --> 00:16:50,990
this icon aggregators or they eater

00:16:48,380 --> 00:16:53,449
tools of a sink IO where we can do

00:16:50,990 --> 00:16:56,480
things like a sink IO dot wait which

00:16:53,449 --> 00:17:01,339
just will take a lot of quarantines or a

00:16:56,480 --> 00:17:04,159
list of tasks and not return until all

00:17:01,339 --> 00:17:05,390
of them have completed so if we run

00:17:04,159 --> 00:17:09,589
something like that we're actually

00:17:05,390 --> 00:17:14,750
running concurrently now and it still

00:17:09,589 --> 00:17:17,600
looks quite ugly but we can realize that

00:17:14,750 --> 00:17:19,500
if you if we're waiting or as in Kyoto

00:17:17,600 --> 00:17:22,530
wait then that means that I think

00:17:19,500 --> 00:17:25,079
the wait is an away table and that means

00:17:22,530 --> 00:17:27,810
that we can run that directly on her

00:17:25,079 --> 00:17:29,460
loop and then it would look something

00:17:27,810 --> 00:17:32,340
like this and this looks a lot more like

00:17:29,460 --> 00:17:34,770
an API we will want to work with create

00:17:32,340 --> 00:17:36,960
a bunch of tasks and ask the loop to

00:17:34,770 --> 00:17:43,920
wait for all of them and execute him

00:17:36,960 --> 00:17:47,160
concurrently and okay I wanted to make

00:17:43,920 --> 00:17:49,440
an aside here and remember the internals

00:17:47,160 --> 00:17:51,180
and how they can be complicated we have

00:17:49,440 --> 00:17:54,150
also this function for a loop to run

00:17:51,180 --> 00:17:56,250
once instead of running forever or until

00:17:54,150 --> 00:17:58,770
something completes and we shouldn't

00:17:56,250 --> 00:18:02,010
call it an underscore function but it's

00:17:58,770 --> 00:18:04,230
there so you call it and then you can

00:18:02,010 --> 00:18:05,970
see that you can run a loop step-by-step

00:18:04,230 --> 00:18:08,100
so whenever you're debugging a sync I

00:18:05,970 --> 00:18:09,870
owe you can just start running your loop

00:18:08,100 --> 00:18:12,710
step-by-step and printing stuff and

00:18:09,870 --> 00:18:14,790
you'll see what's actually happening

00:18:12,710 --> 00:18:17,190
okay but those are quite boring

00:18:14,790 --> 00:18:18,750
functions they're just printing stuff so

00:18:17,190 --> 00:18:21,270
let's try to build something that

00:18:18,750 --> 00:18:22,800
retrieves some results so I change the

00:18:21,270 --> 00:18:25,800
functional airbed now it's a countdown

00:18:22,800 --> 00:18:27,830
and now it just multiplies the numbers

00:18:25,800 --> 00:18:30,390
as it goes down and returns the result

00:18:27,830 --> 00:18:32,880
so we create our list of tasks when we

00:18:30,390 --> 00:18:34,410
wait on them and we assume that the

00:18:32,880 --> 00:18:36,960
tasks are gonna have some information

00:18:34,410 --> 00:18:40,110
for us when we get back thing is what we

00:18:36,960 --> 00:18:42,060
get is these coroutines and their core

00:18:40,110 --> 00:18:44,040
routines that have already executed so

00:18:42,060 --> 00:18:46,500
they're not very useful we can't really

00:18:44,040 --> 00:18:48,720
get any information from them so we can

00:18:46,500 --> 00:18:51,540
try to go back and say well I remember

00:18:48,720 --> 00:18:53,580
futures where something that I could use

00:18:51,540 --> 00:18:56,490
for knowing the results of things that

00:18:53,580 --> 00:18:59,160
haven't happened so we create a mess

00:18:56,490 --> 00:19:03,380
Futurists instead and run that and yeah

00:18:59,160 --> 00:19:05,610
now we have this task and a task is just

00:19:03,380 --> 00:19:08,580
it's just a core routine wrapped in the

00:19:05,610 --> 00:19:10,470
future that the loop is using internally

00:19:08,580 --> 00:19:14,190
and that's good we can access things

00:19:10,470 --> 00:19:16,500
from tasks so we iterate on over them

00:19:14,190 --> 00:19:19,710
and that's it we get the results there

00:19:16,500 --> 00:19:24,690
it's just we made this big ugly again

00:19:19,710 --> 00:19:26,919
and so is that what we can do is go back

00:19:24,690 --> 00:19:28,629
to our aggregator list

00:19:26,919 --> 00:19:30,009
which is they're not called aggregator

00:19:28,629 --> 00:19:34,210
sir by the way that's just than they

00:19:30,009 --> 00:19:36,429
might give him and we have this one

00:19:34,210 --> 00:19:38,710
called gathered that does very something

00:19:36,429 --> 00:19:41,139
very similar to wait except it will

00:19:38,710 --> 00:19:45,129
actually return all of the results and

00:19:41,139 --> 00:19:46,899
since the loop returns whatever the

00:19:45,129 --> 00:19:49,450
functioning was Ronny returns then we

00:19:46,899 --> 00:19:51,220
can just print those results and it does

00:19:49,450 --> 00:19:55,720
the same thing as before except it just

00:19:51,220 --> 00:19:57,399
looks a lot better now so okay what have

00:19:55,720 --> 00:19:59,289
we learned so far we have a sink in a

00:19:57,399 --> 00:20:02,970
wait we can create a way table functions

00:19:59,289 --> 00:20:05,769
whose executions can be suspended and

00:20:02,970 --> 00:20:08,590
with a weight we can suspend until

00:20:05,769 --> 00:20:10,749
another way to hold returns we have a

00:20:08,590 --> 00:20:13,629
loop that we can create we can ask it to

00:20:10,749 --> 00:20:16,779
run we can ask it to run something or

00:20:13,629 --> 00:20:18,609
run forever and we can stop it and we

00:20:16,779 --> 00:20:21,309
have this functions that allow us to

00:20:18,609 --> 00:20:25,090
wait for things so that we can run many

00:20:21,309 --> 00:20:27,309
things concurrently and at the same time

00:20:25,090 --> 00:20:32,109
get the results after or just make sure

00:20:27,309 --> 00:20:33,399
that we wait for all of them so okay

00:20:32,109 --> 00:20:35,889
that's good with that we can probably

00:20:33,399 --> 00:20:43,359
start writing some 11 more realistic

00:20:35,889 --> 00:20:45,999
code and we can write something like

00:20:43,359 --> 00:20:48,489
this this is an example as I said before

00:20:45,999 --> 00:20:50,080
just fetching a bunch of URLs you want

00:20:48,489 --> 00:20:53,320
to get those URLs and you want to get

00:20:50,080 --> 00:20:55,239
them all at the same time or

00:20:53,320 --> 00:20:57,580
concurrently and then just gather their

00:20:55,239 --> 00:21:00,909
results and you could do something like

00:20:57,580 --> 00:21:02,559
that and this works it will fetch all

00:21:00,909 --> 00:21:06,070
the URLs and all the URLs will be there

00:21:02,559 --> 00:21:08,499
at the end the only thing is that maybe

00:21:06,070 --> 00:21:10,509
we don't care about all of those URLs so

00:21:08,499 --> 00:21:12,940
we can try to do something a little more

00:21:10,509 --> 00:21:15,429
complex and say well maybe I just care

00:21:12,940 --> 00:21:18,039
about the first URL to return so let's

00:21:15,429 --> 00:21:20,649
write something that wants to solve that

00:21:18,039 --> 00:21:23,350
so we can write the first completed and

00:21:20,649 --> 00:21:25,749
it's very similar to before so we just

00:21:23,350 --> 00:21:30,639
went back to this as completed idea

00:21:25,749 --> 00:21:32,179
there has a timeout and we just wait for

00:21:30,639 --> 00:21:34,549
those

00:21:32,179 --> 00:21:36,619
wait for those co-routines to complete

00:21:34,549 --> 00:21:40,009
and when the first one completes we just

00:21:36,619 --> 00:21:42,590
return that and that's it and this looks

00:21:40,009 --> 00:21:45,730
like it would do the work except when we

00:21:42,590 --> 00:21:48,499
execute it we get a lot of errors and

00:21:45,730 --> 00:21:51,740
the reason we this is actually returning

00:21:48,499 --> 00:21:53,480
you can see the HTML up there that was

00:21:51,740 --> 00:21:54,649
supposed to be returned but then we're

00:21:53,480 --> 00:21:56,360
getting all this tests that have been

00:21:54,649 --> 00:21:59,119
destroyed and loop that hasn't been

00:21:56,360 --> 00:22:01,369
closed and the thing is with I think I

00:21:59,119 --> 00:22:03,049
owe you have to do explicit cleanup

00:22:01,369 --> 00:22:05,749
you're supposed to close your own loops

00:22:03,049 --> 00:22:07,669
and clean up your own mess so let's

00:22:05,749 --> 00:22:09,649
start just by closing the loop manually

00:22:07,669 --> 00:22:13,820
so that it will internally clean up some

00:22:09,649 --> 00:22:15,320
stuff whereas that looks good except at

00:22:13,820 --> 00:22:18,379
least we got rid of one error but we

00:22:15,320 --> 00:22:20,090
still have this test pending and the

00:22:18,379 --> 00:22:30,799
reason those tests are pending is

00:22:20,090 --> 00:22:33,220
because if we yes yeah if we go back to

00:22:30,799 --> 00:22:35,720
our original code but you can see that

00:22:33,220 --> 00:22:38,210
we're returning after the first test

00:22:35,720 --> 00:22:40,340
completes it's not the one this one

00:22:38,210 --> 00:22:41,960
we're returning is after the first test

00:22:40,340 --> 00:22:43,309
complete so the other ones are still in

00:22:41,960 --> 00:22:45,139
the loop and they're supposed to be

00:22:43,309 --> 00:22:46,940
executed but we're never waiting for

00:22:45,139 --> 00:22:51,740
them no one is waiting for those tests

00:22:46,940 --> 00:22:53,779
so what we can do instead is something

00:22:51,740 --> 00:22:56,840
like this we say well we're gonna

00:22:53,779 --> 00:22:58,580
execute do this exact same code except

00:22:56,840 --> 00:23:00,429
we're gonna wait for all the tests

00:22:58,580 --> 00:23:03,019
before this function returns and that

00:23:00,429 --> 00:23:05,119
works that gives us the right result the

00:23:03,019 --> 00:23:07,369
only problem is that this takes as long

00:23:05,119 --> 00:23:09,080
as the longest wait and if some api's

00:23:07,369 --> 00:23:10,730
are slower than the others you get

00:23:09,080 --> 00:23:13,220
something returning one millisecond and

00:23:10,730 --> 00:23:15,289
some of the return 100 milliseconds then

00:23:13,220 --> 00:23:16,940
you're gonna get the first one that's

00:23:15,289 --> 00:23:18,259
the result you're returning but then

00:23:16,940 --> 00:23:20,269
you're gonna have to wait 100

00:23:18,259 --> 00:23:25,869
milliseconds to until all the other ones

00:23:20,269 --> 00:23:28,669
complete so instead what you can do is

00:23:25,869 --> 00:23:30,529
something like this I guess you've

00:23:28,669 --> 00:23:32,179
started working with it you write

00:23:30,529 --> 00:23:35,330
another function say well now I want to

00:23:32,179 --> 00:23:39,409
cancel all my tests and then within your

00:23:35,330 --> 00:23:41,029
cleanup you you first run your function

00:23:39,409 --> 00:23:42,840
that returns what you want great I don't

00:23:41,029 --> 00:23:47,100
clean up before closing to the

00:23:42,840 --> 00:23:50,910
you cancel all the existing tasks and

00:23:47,100 --> 00:23:55,770
yeah that works it's not nice it's not

00:23:50,910 --> 00:23:58,350
very platonic anymore I think so instead

00:23:55,770 --> 00:24:04,110
would you have as well if we go back to

00:23:58,350 --> 00:24:06,230
the API and we used wait before and wait

00:24:04,110 --> 00:24:09,600
actually has other parameters like a

00:24:06,230 --> 00:24:11,430
timeout and return when and we can tell

00:24:09,600 --> 00:24:15,000
way to return when the first task

00:24:11,430 --> 00:24:18,930
completes and what wait returns is

00:24:15,000 --> 00:24:20,340
actually two sets of futures one for the

00:24:18,930 --> 00:24:22,260
tests that have been completed and one

00:24:20,340 --> 00:24:24,900
for the tasks that are pending

00:24:22,260 --> 00:24:26,790
so would you something like that for the

00:24:24,900 --> 00:24:30,060
pending tasks we ask them to cancel and

00:24:26,790 --> 00:24:32,100
for come they completed one we just get

00:24:30,060 --> 00:24:34,500
the first future and return that and

00:24:32,100 --> 00:24:36,840
this will work this prints were we want

00:24:34,500 --> 00:24:39,090
and get us a result we want the only

00:24:36,840 --> 00:24:43,410
issue is that this example is very well

00:24:39,090 --> 00:24:44,850
matched to what weight does so yeah if

00:24:43,410 --> 00:24:47,910
we wanted to return now the first

00:24:44,850 --> 00:24:51,420
completed but maybe the first two then

00:24:47,910 --> 00:24:52,950
this doesn't do the work anymore so we

00:24:51,420 --> 00:24:55,290
would probably have to go back to

00:24:52,950 --> 00:24:57,000
something like Han Solo or have to write

00:24:55,290 --> 00:25:02,030
our own function that deals with this

00:24:57,000 --> 00:25:07,050
thing but it's good to have this

00:25:02,030 --> 00:25:09,000
deceptions that we yeah we can either do

00:25:07,050 --> 00:25:11,910
wait and then deal with the pending ones

00:25:09,000 --> 00:25:14,610
or we can just write our function and

00:25:11,910 --> 00:25:17,490
then cancel the other ones or we could

00:25:14,610 --> 00:25:21,390
cancel and manually somewhere else but

00:25:17,490 --> 00:25:25,830
yeah so whenever we're working with a

00:25:21,390 --> 00:25:28,740
sync I oh the important thing here is we

00:25:25,830 --> 00:25:32,550
have to do cleanup and it's not always

00:25:28,740 --> 00:25:34,920
trivial and we have to close everything

00:25:32,550 --> 00:25:36,900
whenever it would use sockets readers

00:25:34,920 --> 00:25:38,310
executors everything has to be closed

00:25:36,900 --> 00:25:41,430
manually we shouldn't expect the

00:25:38,310 --> 00:25:46,280
framework to close things for us and we

00:25:41,430 --> 00:25:49,950
should know where a tasks are so okay

00:25:46,280 --> 00:25:54,220
gonna make this a little bit more fun

00:25:49,950 --> 00:25:57,529
before we end and now we have this first

00:25:54,220 --> 00:25:59,749
first completed API and let's say this

00:25:57,529 --> 00:26:04,159
is a very critical part of our code we

00:25:59,749 --> 00:26:05,299
normally query hundreds of API sand it's

00:26:04,159 --> 00:26:08,570
very important that we just get the

00:26:05,299 --> 00:26:11,029
first one quick and we might have

00:26:08,570 --> 00:26:13,309
something else in our stack that it's

00:26:11,029 --> 00:26:15,679
not Python and wants to use this so

00:26:13,309 --> 00:26:19,759
let's just build a server that returns

00:26:15,679 --> 00:26:23,659
this and so for this we just we're gonna

00:26:19,759 --> 00:26:27,859
use the same code as we used before and

00:26:23,659 --> 00:26:30,230
then we're gonna try to get a server

00:26:27,859 --> 00:26:33,259
that serves first completed so we go to

00:26:30,230 --> 00:26:36,409
our documentation we get this is

00:26:33,259 --> 00:26:39,080
basically the easiest server you can

00:26:36,409 --> 00:26:42,950
build this right from the documentation

00:26:39,080 --> 00:26:46,669
that's slightly modified and right now

00:26:42,950 --> 00:26:48,619
this is an echo service like okay so

00:26:46,669 --> 00:26:53,450
this runs in a sink i/o it runs in a

00:26:48,619 --> 00:26:55,690
little and if we want to build our own

00:26:53,450 --> 00:27:00,409
function into it we can just do

00:26:55,690 --> 00:27:02,269
something like this is that where this

00:27:00,409 --> 00:27:04,399
is exactly the same as the echo server

00:27:02,269 --> 00:27:06,649
we worked on before we just changed this

00:27:04,399 --> 00:27:08,210
code here in the middle that is just

00:27:06,649 --> 00:27:13,669
calling first completed and waiting for

00:27:08,210 --> 00:27:18,039
it so and this works you can run this

00:27:13,669 --> 00:27:20,720
code and you will execute it will run a

00:27:18,039 --> 00:27:24,279
server you can do netcat to it and you

00:27:20,720 --> 00:27:27,590
can and the good thing is that it will

00:27:24,279 --> 00:27:29,869
write right just from the example and

00:27:27,590 --> 00:27:33,879
adding a function there you will have a

00:27:29,869 --> 00:27:36,710
working server that executes and can

00:27:33,879 --> 00:27:38,690
handle a lot of requests but if we

00:27:36,710 --> 00:27:41,809
wanted to do instead of using just plain

00:27:38,690 --> 00:27:43,730
soccers do HTML we can start looking at

00:27:41,809 --> 00:27:48,529
a sink i/o libraries and look for

00:27:43,730 --> 00:27:51,739
example two into a i/o HTTP again just

00:27:48,529 --> 00:27:54,139
the same this is the basic area HTTP

00:27:51,739 --> 00:27:57,529
server just hooker

00:27:54,139 --> 00:27:59,929
function there and we have a completely

00:27:57,529 --> 00:28:01,430
asynchronous server that is returning

00:27:59,929 --> 00:28:06,980
while running and fetching

00:28:01,430 --> 00:28:11,690
things concurrently so okay is this an

00:28:06,980 --> 00:28:13,190
overkill yet probably it's we don't

00:28:11,690 --> 00:28:15,860
really need to build a server for this

00:28:13,190 --> 00:28:17,930
but it's good that we can and we can do

00:28:15,860 --> 00:28:20,920
it while running everything within one

00:28:17,930 --> 00:28:23,120
thread in a loop while using the same

00:28:20,920 --> 00:28:28,460
framework that we will use for all

00:28:23,120 --> 00:28:30,080
concurrency in Python so for other use

00:28:28,460 --> 00:28:31,970
cases may be something we would want to

00:28:30,080 --> 00:28:33,740
do instead it's just run the loop on a

00:28:31,970 --> 00:28:37,250
thread and we can do that too we can

00:28:33,740 --> 00:28:40,340
have our synchronous code and that that

00:28:37,250 --> 00:28:42,710
is your normal Python that is Python

00:28:40,340 --> 00:28:44,450
code that will be running and we can put

00:28:42,710 --> 00:28:46,700
the loop on a separate thread and then

00:28:44,450 --> 00:28:49,580
assign things to it for it to run him

00:28:46,700 --> 00:28:52,790
and then get him back things get a

00:28:49,580 --> 00:28:55,640
little bit more complicated here but

00:28:52,790 --> 00:28:59,390
this will work and you just have to get

00:28:55,640 --> 00:29:01,520
your make sure you clean things up and

00:28:59,390 --> 00:29:07,430
make sure you always call for the loop

00:29:01,520 --> 00:29:10,070
to run thread safe and there's a lot

00:29:07,430 --> 00:29:11,510
much to a sink i/o that I'm not gonna

00:29:10,070 --> 00:29:13,810
have time to go into

00:29:11,510 --> 00:29:15,920
there are low-level api is there's

00:29:13,810 --> 00:29:18,410
specifically queues for synchronization

00:29:15,920 --> 00:29:20,600
i are quite useful and you can build

00:29:18,410 --> 00:29:22,730
your own protocols for your servers and

00:29:20,600 --> 00:29:24,380
there are a lot of cool hacks and you

00:29:22,730 --> 00:29:26,960
should go check out the internals there

00:29:24,380 --> 00:29:30,170
if you go to github item messing kayo

00:29:26,960 --> 00:29:32,570
you have the actual code there that is

00:29:30,170 --> 00:29:36,400
very easy to read and that's basically

00:29:32,570 --> 00:29:39,140
the whole implementation and out of the

00:29:36,400 --> 00:29:42,730
external stuff person coyote one that

00:29:39,140 --> 00:29:46,190
they don't want it to name in itself is

00:29:42,730 --> 00:29:48,980
the possibility of creating alternative

00:29:46,190 --> 00:29:52,250
event loops we can do can use this

00:29:48,980 --> 00:29:55,070
framework while using event loops that

00:29:52,250 --> 00:30:02,900
do not come with a sync i/o and one of

00:29:55,070 --> 00:30:07,070
those is UV loop which ya would use this

00:30:02,900 --> 00:30:09,940
a lot of things internally but he claims

00:30:07,070 --> 00:30:14,110
to be very very fast

00:30:09,940 --> 00:30:16,720
if you look at their bench marches up

00:30:14,110 --> 00:30:20,740
there faster than no js' and about as

00:30:16,720 --> 00:30:23,050
fast as go and this is something that

00:30:20,740 --> 00:30:24,820
you can just plug in and you can run any

00:30:23,050 --> 00:30:26,350
of the code we've been writing and just

00:30:24,820 --> 00:30:27,970
change the loop and use you be loop

00:30:26,350 --> 00:30:31,600
instead and you will work with a

00:30:27,970 --> 00:30:33,280
separate loop so the the flexibility

00:30:31,600 --> 00:30:35,110
that this gives us is that we can write

00:30:33,280 --> 00:30:36,700
the same code and understand the code

00:30:35,110 --> 00:30:39,280
using this framework but at the same

00:30:36,700 --> 00:30:41,590
time we can change the internals that

00:30:39,280 --> 00:30:46,210
will run it in different ways and change

00:30:41,590 --> 00:30:48,100
how you will execute and there are a lot

00:30:46,210 --> 00:30:51,010
of third-party libraries for pretty much

00:30:48,100 --> 00:30:52,930
everything you want so if you want to

00:30:51,010 --> 00:30:54,700
start playing with this in Ko get some

00:30:52,930 --> 00:31:00,540
of these I start writing some a

00:30:54,700 --> 00:31:00,540

YouTube URL: https://www.youtube.com/watch?v=8sJUmFHHY-Y


