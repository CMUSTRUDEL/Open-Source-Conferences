Title: Kyle Knapp - Dynamic Class Generation in Python
Publication date: 2016-07-28
Playlist: EuroPython 2016
Description: 
	Kyle Knapp - Dynamic Class Generation in Python
[EuroPython 2016]
[18 July 2016]
[Bilbao, Euskadi, Spain]
(https://ep2016.europython.eu//conference/talks/dynamic-class-generation-in-python)

This talk is about dynamic class generation in python: the practice of
writing code that generates classes and their functionality at
runtime. It will use boto3, the AWS SDK for Python, as a basis to dive
into the basics, the benefits, and the drawbacks to dynamically
generating classes.

-----

This talk is about the concept of dynamic class generation in python.
The whole idea is writing code that generates classes and their
functionality at runtime. You now may be asking yourself, “That sounds
like a neat trick. Why would I ever generate my classes at runtime?”
Here are a few reasons why:

- It can decrease the physical size of your code.

- It can improve the workflow in adding new functionality.

- It can improve reliability of your code.

One example where the power of this concept has really been leveraged
is in boto3, the AWS SDK for Python. Dynamic class generation has
allowed boto3 to become heavily data driven such that most of its
classes and methods are generated based off JSON models representing
aspects of an AWS service’s API. For example, to add support for a new
AWS service API in boto3, just plop in a JSON file into the library
with no additional Python code required.

Using lessons and techniques drawn from developing boto3, this talk
will dive into the following topics related to dynamic class
generation:

- The basics of dynamic class generation such as how to effectively
dynamically generate classes.

- How to overcome some of the challenges of dynamic class generation.

- The tradeoffs in dynamically generating classes and discussion on
when it is appropriate.

By the end of this talk, the hope is that you will have a better
understanding of dynamic class generation and come away with helpful
ideas for your next big project.
Captions: 
	00:00:00,030 --> 00:00:05,040
okay so we're moving on to the last

00:00:02,550 --> 00:00:06,839
speaker before lunch so I'm guessing

00:00:05,040 --> 00:00:08,849
everybody's hungry but please refrain

00:00:06,839 --> 00:00:10,019
from just storming the doors two minutes

00:00:08,849 --> 00:00:11,790
before lunch

00:00:10,019 --> 00:00:13,349
please welcome Carol Knapp who's going

00:00:11,790 --> 00:00:21,420
to talk about dynamic class generation

00:00:13,349 --> 00:00:24,119
in Python all right then

00:00:21,420 --> 00:00:26,670
hello my name is Kyle Knapp and I'm a

00:00:24,119 --> 00:00:29,519
software developer at AWS where I

00:00:26,670 --> 00:00:31,980
primarily focus on developing the 80

00:00:29,519 --> 00:00:34,890
bits SDK for Python also known as boa 3

00:00:31,980 --> 00:00:36,329
and the AWS CLI which is a Python base

00:00:34,890 --> 00:00:38,489
command line tool to manage your ADA

00:00:36,329 --> 00:00:40,680
base resources and I'm gonna talk to you

00:00:38,489 --> 00:00:43,920
today about dynamic class generation in

00:00:40,680 --> 00:00:46,649
Python so let me first go over what you

00:00:43,920 --> 00:00:48,180
should expect in this talk first I'm

00:00:46,649 --> 00:00:50,010
gonna talk to you about the basics of

00:00:48,180 --> 00:00:51,890
dynamic last generation mainly what it

00:00:50,010 --> 00:00:54,210
is and how you would go about doing it

00:00:51,890 --> 00:00:56,430
then I'll talk about the benefits of

00:00:54,210 --> 00:00:59,579
doing it and when it is appropriate to

00:00:56,430 --> 00:01:01,379
use it and finally I'm going to build an

00:00:59,579 --> 00:01:02,879
application from the ground up that uses

00:01:01,379 --> 00:01:05,129
dynamic class generation and really

00:01:02,879 --> 00:01:06,920
shows you all the benefits you gain from

00:01:05,129 --> 00:01:09,750
it

00:01:06,920 --> 00:01:11,490
so let me start by answering the

00:01:09,750 --> 00:01:16,110
question what is dynamic class

00:01:11,490 --> 00:01:17,549
generation what it is is it generate the

00:01:16,110 --> 00:01:20,070
pattern it's a generate classes at

00:01:17,549 --> 00:01:21,780
runtime so all the functionality of a

00:01:20,070 --> 00:01:23,100
specific class so the definition of

00:01:21,780 --> 00:01:24,840
specific class doesn't exist in the

00:01:23,100 --> 00:01:28,220
source code and as a result it gets

00:01:24,840 --> 00:01:30,990
generated as the program runs and

00:01:28,220 --> 00:01:32,880
because the class doesn't exist in

00:01:30,990 --> 00:01:34,380
source code and the functionality needs

00:01:32,880 --> 00:01:36,270
to be generated from somewhere else in

00:01:34,380 --> 00:01:41,340
most cases it's some other data source

00:01:36,270 --> 00:01:43,409
such as a schema or API model so let me

00:01:41,340 --> 00:01:47,130
show you a simple example of how you can

00:01:43,409 --> 00:01:48,990
dynamically generate a class here I have

00:01:47,130 --> 00:01:50,579
a HelloWorld function that takes an

00:01:48,990 --> 00:01:53,729
object and prints hello world from that

00:01:50,579 --> 00:01:55,470
object I also have a class that called

00:01:53,729 --> 00:01:57,860
base class that takes an instance name

00:01:55,470 --> 00:02:00,540
as a parameter and sets it as a property

00:01:57,860 --> 00:02:02,729
now I call type usually usually if

00:02:00,540 --> 00:02:04,259
you're a familiar of using type it

00:02:02,729 --> 00:02:05,880
usually takes only one argument and it

00:02:04,259 --> 00:02:07,920
tells you the type of object but here

00:02:05,880 --> 00:02:10,259
type can also accept three different

00:02:07,920 --> 00:02:11,890
arguments where the first argument is

00:02:10,259 --> 00:02:13,960
the name of my class

00:02:11,890 --> 00:02:15,370
and the second is a tuple representing

00:02:13,960 --> 00:02:18,820
the inheritance I want this new class to

00:02:15,370 --> 00:02:20,290
have and the third parameter is a

00:02:18,820 --> 00:02:21,880
dictionary representing the additional

00:02:20,290 --> 00:02:24,640
properties I want to add to this class

00:02:21,880 --> 00:02:26,230
and once I call type it will actually

00:02:24,640 --> 00:02:28,960
create my new class such that I can

00:02:26,230 --> 00:02:30,520
instantiate it as sell now they opposed

00:02:28,960 --> 00:02:32,620
to introspect some of these variables

00:02:30,520 --> 00:02:35,880
here if I look at the done aim of my

00:02:32,620 --> 00:02:38,650
class or appropriately show my class

00:02:35,880 --> 00:02:40,690
next if I try to access one of the

00:02:38,650 --> 00:02:42,910
properties like instance name it will

00:02:40,690 --> 00:02:45,130
appropriately show up as my instance

00:02:42,910 --> 00:02:47,770
when I access that property and also I

00:02:45,130 --> 00:02:49,540
can call hello world from this instance

00:02:47,770 --> 00:02:51,040
to get that additional functionality of

00:02:49,540 --> 00:02:54,130
printing out how the world from the

00:02:51,040 --> 00:02:55,450
specific object so you're probably

00:02:54,130 --> 00:02:56,770
thinking is like okay that's cool but

00:02:55,450 --> 00:02:59,590
why should I care about dynamic class

00:02:56,770 --> 00:03:01,239
generation first of all it can improve

00:02:59,590 --> 00:03:03,520
your workflow improve your workflow in

00:03:01,239 --> 00:03:05,440
the sense that you will have you will

00:03:03,520 --> 00:03:06,820
have to read a minimal amount of Python

00:03:05,440 --> 00:03:08,860
code to actually add new functionality

00:03:06,820 --> 00:03:11,010
maybe not you may not even have to write

00:03:08,860 --> 00:03:13,209
any Python code at all which is cool

00:03:11,010 --> 00:03:15,910
second it can improve the railway

00:03:13,209 --> 00:03:17,620
ability of your code a lot of times how

00:03:15,910 --> 00:03:19,120
dynamic class generation works out is

00:03:17,620 --> 00:03:20,470
you have a generalized code path and

00:03:19,120 --> 00:03:22,630
most of our logic flows through that

00:03:20,470 --> 00:03:24,160
generalized code path as a result it

00:03:22,630 --> 00:03:27,250
becomes more heavily well used and

00:03:24,160 --> 00:03:29,610
tested then third it can actually reduce

00:03:27,250 --> 00:03:31,510
the physical size of your code because

00:03:29,610 --> 00:03:33,010
specific classes doesn't actually exist

00:03:31,510 --> 00:03:36,310
in the source code and therefore doesn't

00:03:33,010 --> 00:03:37,810
take up against the size and finally

00:03:36,310 --> 00:03:39,220
this is a production level pattern I'll

00:03:37,810 --> 00:03:42,100
go into an application that uses it a

00:03:39,220 --> 00:03:43,420
little bit later in the talk so now let

00:03:42,100 --> 00:03:45,519
me talk about some of the downsides of

00:03:43,420 --> 00:03:47,860
it first of all trace backs are a little

00:03:45,519 --> 00:03:49,239
bit difficult to follow mainly because a

00:03:47,860 --> 00:03:52,630
lot of times you're using a generalized

00:03:49,239 --> 00:03:54,940
source fat or Stowe's carrot and as a

00:03:52,630 --> 00:03:58,510
result you have to look through the data

00:03:54,940 --> 00:03:59,920
the data source that you're getting this

00:03:58,510 --> 00:04:03,970
functionality from to really identify

00:03:59,920 --> 00:04:05,350
where it's going wrong secondly IDC IDE

00:04:03,970 --> 00:04:05,709
support doesn't come right out of the

00:04:05,350 --> 00:04:07,870
box

00:04:05,709 --> 00:04:09,130
mainly because IDs need the source code

00:04:07,870 --> 00:04:13,329
to be able to autosuggest

00:04:09,130 --> 00:04:15,310
and it simply isn't there so now let me

00:04:13,329 --> 00:04:19,060
go into a production level application

00:04:15,310 --> 00:04:21,370
in terms of butter 3 photo 3 is the atps

00:04:19,060 --> 00:04:23,590
sdk for python so allows you to interact

00:04:21,370 --> 00:04:24,510
with all the different database API is

00:04:23,590 --> 00:04:27,300
available

00:04:24,510 --> 00:04:29,220
and boto curry is dynamic and it's

00:04:27,300 --> 00:04:30,690
data-driven it's dynamic in the sense

00:04:29,220 --> 00:04:33,840
that all of its clients and all of its

00:04:30,690 --> 00:04:35,190
resources are generated at runtime and

00:04:33,840 --> 00:04:36,900
data-driven in the sense that the

00:04:35,190 --> 00:04:39,390
functionality for these dynamically

00:04:36,900 --> 00:04:43,680
generated classes are pulled from JSON

00:04:39,390 --> 00:04:47,160
models representing in database API and

00:04:43,680 --> 00:04:50,010
what those two qualities allow for me as

00:04:47,160 --> 00:04:53,310
a maintainer of the SDK is an efficient

00:04:50,010 --> 00:04:55,080
workflow because with AWS it's

00:04:53,310 --> 00:04:57,420
constantly innovating constantly adding

00:04:55,080 --> 00:05:00,270
new features and services so being able

00:04:57,420 --> 00:05:01,680
to stay up to date and provide all these

00:05:00,270 --> 00:05:03,330
new features through the SDK is very

00:05:01,680 --> 00:05:05,430
important but it's very difficult when

00:05:03,330 --> 00:05:07,140
there's a lot of api's to work with with

00:05:05,430 --> 00:05:07,800
photo 3 in the fact that it's dynamic

00:05:07,140 --> 00:05:10,890
and data-driven

00:05:07,800 --> 00:05:12,720
all it takes for me is to simply update

00:05:10,890 --> 00:05:14,910
a new JSON model that's packaged in the

00:05:12,720 --> 00:05:16,920
library and I don't have to write any

00:05:14,910 --> 00:05:18,780
Python code at all and I'll immediately

00:05:16,920 --> 00:05:21,270
be able to take up that functionality I

00:05:18,780 --> 00:05:22,950
can spend my time doing some other work

00:05:21,270 --> 00:05:25,800
that doesn't that can't be really

00:05:22,950 --> 00:05:27,180
handled a dynamic class generation so

00:05:25,800 --> 00:05:33,750
now what I'm going to do is show you a

00:05:27,180 --> 00:05:36,630
demo of what this would look like so now

00:05:33,750 --> 00:05:42,660
what I'm gonna do is open up ipython

00:05:36,630 --> 00:05:44,430
here and now let's say a BBS came out of

00:05:42,660 --> 00:05:46,800
the new service called my service so if

00:05:44,430 --> 00:05:50,280
I try to create a client as client for

00:05:46,800 --> 00:05:52,220
my service I will probably get a runtime

00:05:50,280 --> 00:05:56,820
error saying this is not available so

00:05:52,220 --> 00:05:59,340
let's actually go fix this so what I'm

00:05:56,820 --> 00:06:02,190
gonna do now is let's say that we got a

00:05:59,340 --> 00:06:04,860
new API model for this service and I'm

00:06:02,190 --> 00:06:08,550
gonna open up this model to show you

00:06:04,860 --> 00:06:09,870
what it kind of looks like and if you

00:06:08,550 --> 00:06:12,090
look at it right here it's just it's

00:06:09,870 --> 00:06:16,020
just Amazon easy to use API model it's

00:06:12,090 --> 00:06:18,450
nothing new here and now if I what I can

00:06:16,020 --> 00:06:21,150
use now is the ad abyss TOI which here's

00:06:18,450 --> 00:06:23,700
the same data path as moto3

00:06:21,150 --> 00:06:25,290
in order to add this model of the same

00:06:23,700 --> 00:06:27,540
data path to the share so if I provide

00:06:25,290 --> 00:06:30,170
that for the service model the file that

00:06:27,540 --> 00:06:30,170
I just opened

00:06:31,490 --> 00:06:37,430
and then I provide a new say I want to

00:06:34,819 --> 00:06:41,690
rename the the service name to my

00:06:37,430 --> 00:06:43,520
service what that would do is just copy

00:06:41,690 --> 00:06:45,530
the file into the correct data path for

00:06:43,520 --> 00:06:50,710
bo2 free to search such that if I open

00:06:45,530 --> 00:06:53,449
up a Python again I can then use it so

00:06:50,710 --> 00:07:00,080
the import boat of three and create try

00:06:53,449 --> 00:07:02,000
to create the new client it

00:07:00,080 --> 00:07:03,560
appropriately creates and now I can

00:07:02,000 --> 00:07:04,910
actually just call one of ec twos

00:07:03,560 --> 00:07:08,120
operation so I'm just gonna do to

00:07:04,910 --> 00:07:09,440
describe regions call and it

00:07:08,120 --> 00:07:11,660
appropriately was able to make the call

00:07:09,440 --> 00:07:13,340
as well so this is really this was

00:07:11,660 --> 00:07:14,690
really cool because I didn't know how to

00:07:13,340 --> 00:07:18,520
write a single line of Python code in

00:07:14,690 --> 00:07:21,110
able to add new functionality so that

00:07:18,520 --> 00:07:23,449
being said you probably what we're now

00:07:21,110 --> 00:07:25,159
wondering when should I actually

00:07:23,449 --> 00:07:28,310
consider dynamically generate increased

00:07:25,159 --> 00:07:30,319
classes the one big point you probably

00:07:28,310 --> 00:07:32,419
want to look for is if there exists some

00:07:30,319 --> 00:07:34,009
canonical source of data where you can

00:07:32,419 --> 00:07:35,599
actually pull functionality from and

00:07:34,009 --> 00:07:38,030
better yet if there's more than one

00:07:35,599 --> 00:07:41,060
application possibly using this source

00:07:38,030 --> 00:07:43,130
of data a classic example is whether the

00:07:41,060 --> 00:07:45,289
eyes a lot of times what happens is you

00:07:43,130 --> 00:07:47,210
have to update a model anyways in order

00:07:45,289 --> 00:07:48,740
to generate some of the server code so

00:07:47,210 --> 00:07:50,240
being able to use that for the client

00:07:48,740 --> 00:07:53,570
code you get to pick up pick that up for

00:07:50,240 --> 00:07:55,520
free which is awesome then you can get

00:07:53,570 --> 00:07:58,099
in the case of databases where you have

00:07:55,520 --> 00:07:59,750
a defined schema and library is kind of

00:07:58,099 --> 00:08:02,300
like Sandman are able to use that schema

00:07:59,750 --> 00:08:07,039
to create a dynamic API is to interact

00:08:02,300 --> 00:08:08,659
with those databases so now what to

00:08:07,039 --> 00:08:10,250
actually build an application from the

00:08:08,659 --> 00:08:13,430
ground up that uses dynamic class

00:08:10,250 --> 00:08:15,909
generation the application we're gonna

00:08:13,430 --> 00:08:18,500
build is a lightweight boto three it

00:08:15,909 --> 00:08:21,320
involves having a client interface where

00:08:18,500 --> 00:08:25,400
it's methods are one-to-one mappings to

00:08:21,320 --> 00:08:26,810
the various api's and this applications

00:08:25,400 --> 00:08:29,630
to be all model driven there's not going

00:08:26,810 --> 00:08:32,149
to be any any code that's specific to a

00:08:29,630 --> 00:08:34,550
specific API method it's you be able to

00:08:32,149 --> 00:08:35,930
validate inputs based off models as can

00:08:34,550 --> 00:08:38,089
be able to parse responses based off

00:08:35,930 --> 00:08:40,800
models and it's for now it's only gonna

00:08:38,089 --> 00:08:43,110
support JSON RPC protocol

00:08:40,800 --> 00:08:46,499
so let me go over the steps real quick

00:08:43,110 --> 00:08:48,420
as well of what we're gonna do first I'm

00:08:46,499 --> 00:08:51,389
going to show you how you can write a

00:08:48,420 --> 00:08:53,399
simple JSON RPC client then I'm going to

00:08:51,389 --> 00:08:56,040
integrate API models to pickup input

00:08:53,399 --> 00:08:58,559
validation response parsing then I'm

00:08:56,040 --> 00:09:01,319
gonna add API specific methods to this

00:08:58,559 --> 00:09:02,759
application or the client interface for

00:09:01,319 --> 00:09:04,290
step I'm gonna make sure it's extensible

00:09:02,759 --> 00:09:05,910
so I can inject my new classes and

00:09:04,290 --> 00:09:09,329
finally I'm gonna actually add more

00:09:05,910 --> 00:09:12,509
api's so for those of you not familiar

00:09:09,329 --> 00:09:15,869
of JSON RPC let me briefly go over it so

00:09:12,509 --> 00:09:17,850
JSON RPC relies on using posts against a

00:09:15,869 --> 00:09:19,920
single URI where there's not any

00:09:17,850 --> 00:09:22,350
additional pass or curry strings you

00:09:19,920 --> 00:09:24,329
have to worry about and most of the data

00:09:22,350 --> 00:09:26,220
is in JSON bodies through the request

00:09:24,329 --> 00:09:28,619
and response so like in the request you

00:09:26,220 --> 00:09:30,119
will specify like a method or parameters

00:09:28,619 --> 00:09:31,649
you want to provide that method and a

00:09:30,119 --> 00:09:36,749
response it will return you a result

00:09:31,649 --> 00:09:39,839
from that method call so now let me go

00:09:36,749 --> 00:09:42,059
over some sample code of how this JSON

00:09:39,839 --> 00:09:43,379
RPC client work I don't worry about

00:09:42,059 --> 00:09:46,740
looking through it too deeply right now

00:09:43,379 --> 00:09:48,869
I'll walk through it with you so now if

00:09:46,740 --> 00:09:50,579
I was to try to stand sheet this client

00:09:48,869 --> 00:09:52,259
with an endpoint URL it would say about

00:09:50,579 --> 00:09:54,809
you and port URL for later when I tried

00:09:52,259 --> 00:09:56,759
to make an API call but for the make API

00:09:54,809 --> 00:09:59,009
call I all have to do is specify a

00:09:56,759 --> 00:10:00,929
method and parameters such that the

00:09:59,009 --> 00:10:03,089
method gets mapped to the method element

00:10:00,929 --> 00:10:04,610
and the JSON payload I'll send and the

00:10:03,089 --> 00:10:07,649
parameters will be mapped to the params

00:10:04,610 --> 00:10:10,049
element then once I have that payload

00:10:07,649 --> 00:10:12,029
set I can just use requests to just send

00:10:10,049 --> 00:10:14,699
a post to that URL with the JSON

00:10:12,029 --> 00:10:18,149
document and what already turn to me is

00:10:14,699 --> 00:10:19,949
a JSON document as well where you can

00:10:18,149 --> 00:10:21,689
see your here it will have the result of

00:10:19,949 --> 00:10:24,980
multiplying one by two by three together

00:10:21,689 --> 00:10:26,970
which as you would expect would be six

00:10:24,980 --> 00:10:29,220
so let's talk about what needs to be

00:10:26,970 --> 00:10:30,629
expanded on this this feels very general

00:10:29,220 --> 00:10:31,860
there's honestly you don't even need

00:10:30,629 --> 00:10:33,959
this class this client class right now

00:10:31,860 --> 00:10:36,540
you could probably just call requests

00:10:33,959 --> 00:10:38,309
directly you don't have any input

00:10:36,540 --> 00:10:39,660
validation you have no idea what methods

00:10:38,309 --> 00:10:42,149
you can use what parameters you can

00:10:39,660 --> 00:10:43,499
provide or even the types and also it

00:10:42,149 --> 00:10:45,499
returns an entire response so if you

00:10:43,499 --> 00:10:47,759
notice in the response there is a

00:10:45,499 --> 00:10:49,559
elements talking about what the ID of

00:10:47,759 --> 00:10:52,480
the request and response was in the

00:10:49,559 --> 00:10:54,670
version of JSON RPC being used

00:10:52,480 --> 00:10:56,440
so now let's talk about step two which

00:10:54,670 --> 00:10:59,320
is integrating the API model the sense

00:10:56,440 --> 00:11:00,880
of this client so currently where we're

00:10:59,320 --> 00:11:02,440
at we can create a client with an

00:11:00,880 --> 00:11:04,090
endpoint URL and make a generalized API

00:11:02,440 --> 00:11:06,100
call by the end of this step we'll be

00:11:04,090 --> 00:11:08,710
able to do it's actually take a JSON

00:11:06,100 --> 00:11:11,470
model load it and have our new client

00:11:08,710 --> 00:11:14,080
class consume this model such that I can

00:11:11,470 --> 00:11:15,760
make a model of the API call which what

00:11:14,080 --> 00:11:17,200
I won't do is be able to know if it's

00:11:15,760 --> 00:11:20,380
positional or keyword arguments use

00:11:17,200 --> 00:11:23,920
accept and appropriately print out just

00:11:20,380 --> 00:11:26,290
the result I wanted and then similarly

00:11:23,920 --> 00:11:28,150
if I if I pass an incorrect parameter

00:11:26,290 --> 00:11:30,940
type say like the string foo I can't

00:11:28,150 --> 00:11:32,650
multiply one by foo that will throw me a

00:11:30,940 --> 00:11:36,730
runtime error saying this is the type

00:11:32,650 --> 00:11:38,200
string I expected type integer so in

00:11:36,730 --> 00:11:40,510
order to get this working let's talk

00:11:38,200 --> 00:11:42,520
about an API valo schema here's a sample

00:11:40,510 --> 00:11:44,740
API schema that we are gonna use this is

00:11:42,520 --> 00:11:45,940
a lot simpler than some of other schemas

00:11:44,740 --> 00:11:47,260
you might see out there like in web

00:11:45,940 --> 00:11:48,790
butter three uses or looks something

00:11:47,260 --> 00:11:51,540
like swagger but for the sake of this

00:11:48,790 --> 00:11:54,520
presentation try to keep it simple so

00:11:51,540 --> 00:11:56,790
here what I do in the schema is you can

00:11:54,520 --> 00:11:59,740
identify what the endpoint URL here is

00:11:56,790 --> 00:12:01,060
for your API and also you can provide

00:11:59,740 --> 00:12:02,710
the operations that you may want to

00:12:01,060 --> 00:12:05,230
provide in our case where we have a

00:12:02,710 --> 00:12:07,890
multiply for now and for each operation

00:12:05,230 --> 00:12:10,270
you can specify an over overarching

00:12:07,890 --> 00:12:11,710
documentation for that method you can

00:12:10,270 --> 00:12:13,030
specify what the inputs supposed to look

00:12:11,710 --> 00:12:15,610
like and also what the outputs is

00:12:13,030 --> 00:12:18,010
supposed to look like as well it's but

00:12:15,610 --> 00:12:19,630
in terms of the inputs you can say what

00:12:18,010 --> 00:12:21,070
the type is in our case it's gonna be a

00:12:19,630 --> 00:12:23,770
list and therefore we wanted to have it

00:12:21,070 --> 00:12:26,440
be positional arguments and you can also

00:12:23,770 --> 00:12:29,080
specify what the doc how you want to

00:12:26,440 --> 00:12:32,440
describe this input as well and you can

00:12:29,080 --> 00:12:33,730
also model what what each element in

00:12:32,440 --> 00:12:35,650
this list will be in this case it's

00:12:33,730 --> 00:12:37,270
integer and you can do the same for the

00:12:35,650 --> 00:12:41,110
output when she get documentation and

00:12:37,270 --> 00:12:43,360
also specify it's an integer as well so

00:12:41,110 --> 00:12:45,820
now what we're gonna do is actually take

00:12:43,360 --> 00:12:48,220
this model and then try to run it

00:12:45,820 --> 00:12:49,450
through the client don't worry about

00:12:48,220 --> 00:12:52,060
trying to read through this right now I

00:12:49,450 --> 00:12:54,970
will go over as well so now what we do

00:12:52,060 --> 00:12:56,920
is we import the API JSON file into a

00:12:54,970 --> 00:12:59,800
model we can now have this model modeled

00:12:56,920 --> 00:13:01,630
client class consume the model and an

00:12:59,800 --> 00:13:04,570
initializer what I'll do is I'll create

00:13:01,630 --> 00:13:05,250
a pram validator and a response parser

00:13:04,570 --> 00:13:08,190
which will you

00:13:05,250 --> 00:13:10,140
the model to both validate in partial

00:13:08,190 --> 00:13:12,300
responses based off the provided

00:13:10,140 --> 00:13:16,260
parameters and the API response given

00:13:12,300 --> 00:13:18,990
back so now what I'll do is continue on

00:13:16,260 --> 00:13:21,480
and dist an she ate the inherited client

00:13:18,990 --> 00:13:23,700
initializer and then I'll be able to use

00:13:21,480 --> 00:13:26,910
the make model API call in which case

00:13:23,700 --> 00:13:28,800
what I'll first do is try to validate

00:13:26,910 --> 00:13:31,710
the parameters provided using the

00:13:28,800 --> 00:13:32,820
validator and the input model once we

00:13:31,710 --> 00:13:35,220
know these are these parameters are

00:13:32,820 --> 00:13:38,040
validated we'll then use the make API

00:13:35,220 --> 00:13:40,080
call which is inherited from the client

00:13:38,040 --> 00:13:43,470
class to in order to actually make a

00:13:40,080 --> 00:13:45,690
request against the API then we'll be

00:13:43,470 --> 00:13:46,020
able to parse the response based off the

00:13:45,690 --> 00:13:49,590
model

00:13:46,020 --> 00:13:53,370
and the response given back to us as

00:13:49,590 --> 00:13:55,830
cell now let's talk about when he's

00:13:53,370 --> 00:13:58,170
expanded on this step it still feels too

00:13:55,830 --> 00:13:59,880
general mainly because the API is still

00:13:58,170 --> 00:14:01,440
completely undocumented we have no idea

00:13:59,880 --> 00:14:03,600
what methods we can fry we have no idea

00:14:01,440 --> 00:14:05,550
what parameters and what the output is

00:14:03,600 --> 00:14:07,980
gonna be so let's go fix this by

00:14:05,550 --> 00:14:11,670
actually adding API specific methods by

00:14:07,980 --> 00:14:14,330
dynamically creating them so currently

00:14:11,670 --> 00:14:16,200
what we have is we can open up a model

00:14:14,330 --> 00:14:18,270
just ain't she a new client in make a

00:14:16,200 --> 00:14:20,610
model API call but by the end of step

00:14:18,270 --> 00:14:22,920
what we'll be able to do is now use a

00:14:20,610 --> 00:14:24,900
factory function to create a new client

00:14:22,920 --> 00:14:28,130
that will actually have these new

00:14:24,900 --> 00:14:30,270
methods that we want on the client and

00:14:28,130 --> 00:14:32,400
similarly if we call help on the client

00:14:30,270 --> 00:14:37,980
we can also get documentation on how wet

00:14:32,400 --> 00:14:39,390
it will actually look like so let's go

00:14:37,980 --> 00:14:41,910
over some code on how this would look

00:14:39,390 --> 00:14:44,040
so once we've loaded the JSON model and

00:14:41,910 --> 00:14:45,480
create the client we will then start

00:14:44,040 --> 00:14:47,430
initializing some of the variables

00:14:45,480 --> 00:14:49,200
needed for the type call later called

00:14:47,430 --> 00:14:50,940
later down the road in which case we

00:14:49,200 --> 00:14:53,010
just call the class name my client and

00:14:50,940 --> 00:14:54,420
set some class spaces we wanted to

00:14:53,010 --> 00:14:57,630
inherit from model client in this case

00:14:54,420 --> 00:14:59,640
and also we will create an empty

00:14:57,630 --> 00:15:01,800
dictionary for class properties that we

00:14:59,640 --> 00:15:03,300
want to dingle off that class so now

00:15:01,800 --> 00:15:04,950
what would do is actually open up the

00:15:03,300 --> 00:15:06,720
operate the model and look for all the

00:15:04,950 --> 00:15:09,089
different operations available to us and

00:15:06,720 --> 00:15:11,339
call this helper function get client

00:15:09,089 --> 00:15:14,160
method with the good client method well

00:15:11,339 --> 00:15:16,410
to do is actually define a new API a new

00:15:14,160 --> 00:15:18,370
function called underscore API call in

00:15:16,410 --> 00:15:21,339
which will be used as

00:15:18,370 --> 00:15:23,080
used by the sanity client so once we to

00:15:21,339 --> 00:15:25,150
return that defined function we attach

00:15:23,080 --> 00:15:27,790
it to we add it to the class properties

00:15:25,150 --> 00:15:29,230
that we'll provide to type which will

00:15:27,790 --> 00:15:31,270
actually create this new client class

00:15:29,230 --> 00:15:33,750
and then with this new client class

00:15:31,270 --> 00:15:36,670
we'll Stan she ate an instance of it

00:15:33,750 --> 00:15:38,860
such that now if I call multiply of 1 2

00:15:36,670 --> 00:15:41,880
3 it's actually crossing out to this

00:15:38,860 --> 00:15:45,010
newly define that defined API call here

00:15:41,880 --> 00:15:47,110
where self is now referring to the

00:15:45,010 --> 00:15:48,940
client that it got attached the the

00:15:47,110 --> 00:15:51,130
method got attached to and the make

00:15:48,940 --> 00:15:53,290
model API call which is what's called

00:15:51,130 --> 00:15:58,330
underneath of this function is inherited

00:15:53,290 --> 00:15:59,860
from the modeled client class but

00:15:58,330 --> 00:16:01,810
there's one big issue the doctrines are

00:15:59,860 --> 00:16:03,520
still not specific so if I try to call

00:16:01,810 --> 00:16:06,130
help on this client right now you'll

00:16:03,520 --> 00:16:08,290
just see exactly what I described which

00:16:06,130 --> 00:16:10,540
is multiply is just a proxy out to this

00:16:08,290 --> 00:16:12,460
underscore API call so let's figure out

00:16:10,540 --> 00:16:14,020
how to do that that's it's actually not

00:16:12,460 --> 00:16:15,580
too difficult you just add these two

00:16:14,020 --> 00:16:17,529
lines here which we're setting the

00:16:15,580 --> 00:16:19,060
dunder name in the dunder doc for the

00:16:17,529 --> 00:16:21,460
method that we add to the class

00:16:19,060 --> 00:16:23,860
properties such that when we call help

00:16:21,460 --> 00:16:25,420
now we will actually pick up these new

00:16:23,860 --> 00:16:28,300
the new documentation and the correct

00:16:25,420 --> 00:16:29,920
name for the method so if I said in the

00:16:28,300 --> 00:16:31,600
Nate the dunder name right here to

00:16:29,920 --> 00:16:33,850
whatever the string operation name it

00:16:31,600 --> 00:16:35,650
allows you to override that the fact

00:16:33,850 --> 00:16:37,779
that it looks like a proxy when you call

00:16:35,650 --> 00:16:39,279
help and then by setting the dunder doc

00:16:37,779 --> 00:16:41,920
you're actually able to set the

00:16:39,279 --> 00:16:44,589
documentation for that method the get

00:16:41,920 --> 00:16:45,850
doc string method our function is pretty

00:16:44,589 --> 00:16:48,550
much what it does is it takes the

00:16:45,850 --> 00:16:49,959
operation model and looks through all

00:16:48,550 --> 00:16:51,310
the different documentation elements if

00:16:49,959 --> 00:16:53,589
you remember from before if the API

00:16:51,310 --> 00:16:55,959
schema in order to Gen to concatenate

00:16:53,589 --> 00:16:57,850
together a string that has the

00:16:55,959 --> 00:17:01,620
operations and the type that parameter

00:16:57,850 --> 00:17:01,620
types and all the return types for you

00:17:01,770 --> 00:17:06,130
so let's talk about what needs to be

00:17:03,940 --> 00:17:07,959
expanded off this is a model first of

00:17:06,130 --> 00:17:09,250
all it's not extensible it's not

00:17:07,959 --> 00:17:10,480
extensible in the sense that we need to

00:17:09,250 --> 00:17:12,520
be able to support like something like

00:17:10,480 --> 00:17:14,500
custom class names or custom inheritance

00:17:12,520 --> 00:17:16,720
in this sense that we don't want to

00:17:14,500 --> 00:17:18,910
actually only have to rely on these

00:17:16,720 --> 00:17:21,640
model API methods we want to be able to

00:17:18,910 --> 00:17:23,860
add new functionality on top of it so

00:17:21,640 --> 00:17:26,110
let's talk about step four in which we

00:17:23,860 --> 00:17:29,470
make the client extensible let's start

00:17:26,110 --> 00:17:30,850
with this sample application where I

00:17:29,470 --> 00:17:33,460
create a cash client

00:17:30,850 --> 00:17:35,259
in a sense that we know that given us I

00:17:33,460 --> 00:17:36,549
set up a method and a set of parameters

00:17:35,259 --> 00:17:38,259
we're gonna get the same result every

00:17:36,549 --> 00:17:39,880
single time so it doesn't actually make

00:17:38,259 --> 00:17:41,830
sense to hit the server every single

00:17:39,880 --> 00:17:43,990
time to do it why not just store the met

00:17:41,830 --> 00:17:47,259
the result in memory and return that

00:17:43,990 --> 00:17:49,210
when needed so with this new client

00:17:47,259 --> 00:17:51,519
class I'll create a new dictionary

00:17:49,210 --> 00:17:54,429
representing the cache and then I

00:17:51,519 --> 00:17:56,169
override the make model API calls such

00:17:54,429 --> 00:17:57,700
that I create a new cache key consisting

00:17:56,169 --> 00:17:59,080
of the method the arguments in the

00:17:57,700 --> 00:18:01,990
keyword arguments that I provide and

00:17:59,080 --> 00:18:04,000
check to see if this key is in the

00:18:01,990 --> 00:18:05,289
operation cache and if it is I'll just

00:18:04,000 --> 00:18:07,120
print out where I'm returning for

00:18:05,289 --> 00:18:09,580
retrieving it from and also return the

00:18:07,120 --> 00:18:10,899
result from the cache then if it's not

00:18:09,580 --> 00:18:13,210
in the cache what I'll do is I'll

00:18:10,899 --> 00:18:17,139
actually make a call to the server and

00:18:13,210 --> 00:18:19,509
get the result in store for us so

00:18:17,139 --> 00:18:20,889
currently we're at we have this logic

00:18:19,509 --> 00:18:22,269
but there's not really a great way to

00:18:20,889 --> 00:18:24,309
actually hook in our cache client

00:18:22,269 --> 00:18:26,289
classes there's no option for us right

00:18:24,309 --> 00:18:28,059
now so bananas step we're gonna be able

00:18:26,289 --> 00:18:29,860
to do is take this new model and then

00:18:28,059 --> 00:18:31,419
actually create a client such that we

00:18:29,860 --> 00:18:33,009
can override what the name is if the

00:18:31,419 --> 00:18:35,289
class we want to use in its inheritance

00:18:33,009 --> 00:18:37,090
such that now if I call client dot

00:18:35,289 --> 00:18:38,950
multiply you can see where it's

00:18:37,090 --> 00:18:41,110
retrieving the result from and then if I

00:18:38,950 --> 00:18:42,669
call it again it will actually save that

00:18:41,110 --> 00:18:45,610
result in say it's returning from

00:18:42,669 --> 00:18:48,429
history and then I can also look at what

00:18:45,610 --> 00:18:50,230
the name is as well and see that it will

00:18:48,429 --> 00:18:52,870
return my super smart client as I

00:18:50,230 --> 00:18:54,159
defined before so how to do this it's

00:18:52,870 --> 00:18:55,990
actually pretty straightforward other

00:18:54,159 --> 00:18:57,970
than updating the signature for this

00:18:55,990 --> 00:18:59,649
function I just added this these two

00:18:57,970 --> 00:19:02,620
lines which sets a default that no class

00:18:59,649 --> 00:19:05,559
spaces were provided in order to do that

00:19:02,620 --> 00:19:07,419
or if now if I walk through this and I

00:19:05,559 --> 00:19:10,899
create a new client with the model and

00:19:07,419 --> 00:19:13,720
the customized string code name and the

00:19:10,899 --> 00:19:15,220
class basis you can see that my super

00:19:13,720 --> 00:19:17,559
smart client gets mapped to the class

00:19:15,220 --> 00:19:20,110
name when type is called and class

00:19:17,559 --> 00:19:21,669
spaces get error the cache clients to

00:19:20,110 --> 00:19:23,740
bolt gets mapped to class spaces when

00:19:21,669 --> 00:19:25,090
type is called so now when I call

00:19:23,740 --> 00:19:27,600
multiply you can see that it's

00:19:25,090 --> 00:19:30,129
appropriately using the cache client and

00:19:27,600 --> 00:19:32,230
when I call the dunder name it will

00:19:30,129 --> 00:19:35,889
appropriately use my super smart client

00:19:32,230 --> 00:19:38,200
for the string name so let's talk about

00:19:35,889 --> 00:19:39,250
what needs to be expanded here to be

00:19:38,200 --> 00:19:41,379
honest we're actually had a good base

00:19:39,250 --> 00:19:43,750
where there's not really any glaring

00:19:41,379 --> 00:19:44,050
holes except for the big elephant in the

00:19:43,750 --> 00:19:46,630
room

00:19:44,050 --> 00:19:51,190
which is there's only one API method so

00:19:46,630 --> 00:19:52,480
let's actually go fix that so in this

00:19:51,190 --> 00:19:55,810
final step we're gonna add more api's

00:19:52,480 --> 00:19:57,220
such that our engineers working on the

00:19:55,810 --> 00:20:02,010
server and we're hard at work and they

00:19:57,220 --> 00:20:04,540
had a to new api's add and subtract so

00:20:02,010 --> 00:20:07,090
in order to actually update this API

00:20:04,540 --> 00:20:08,530
they updated the models as well in order

00:20:07,090 --> 00:20:11,050
to generate some of the server code and

00:20:08,530 --> 00:20:14,710
as a result we got these new API models

00:20:11,050 --> 00:20:17,980
for free and to look at some of these

00:20:14,710 --> 00:20:19,720
API models you can see that for ad it's

00:20:17,980 --> 00:20:21,460
very similar to multiply in a sense it's

00:20:19,720 --> 00:20:23,770
as a list of integers and what over

00:20:21,460 --> 00:20:26,650
returned to you is a the sum of the

00:20:23,770 --> 00:20:28,540
integers as a single integer subtract is

00:20:26,650 --> 00:20:30,880
also that pretty much the same where

00:20:28,540 --> 00:20:32,380
it's a list of integers and it will

00:20:30,880 --> 00:20:35,470
return to you the difference of those

00:20:32,380 --> 00:20:37,030
integers as well as a major so now let's

00:20:35,470 --> 00:20:41,710
actually do a demo of what this will

00:20:37,030 --> 00:20:45,490
look like so if I open up a Python right

00:20:41,710 --> 00:20:48,520
here what I'm gonna do is I'm going to

00:20:45,490 --> 00:20:50,320
import a couple helper functions first

00:20:48,520 --> 00:20:52,450
I'm going to import one that lets me get

00:20:50,320 --> 00:20:54,040
my models for it pretty quickly without

00:20:52,450 --> 00:20:57,250
having to do that with opening up the

00:20:54,040 --> 00:21:00,700
files and loading it and I'll import the

00:20:57,250 --> 00:21:05,260
create client function so now if I open

00:21:00,700 --> 00:21:07,480
if I call get model what I'm going to do

00:21:05,260 --> 00:21:09,280
first is I'm going to open up the old

00:21:07,480 --> 00:21:12,760
model the one that only has that

00:21:09,280 --> 00:21:19,660
multiply in it such that when I create

00:21:12,760 --> 00:21:21,190
the client now you can see that it only

00:21:19,660 --> 00:21:22,900
has a three methods it has the

00:21:21,190 --> 00:21:25,300
generalized make API call it has the

00:21:22,900 --> 00:21:31,330
model 1 and also has a multiply so if I

00:21:25,300 --> 00:21:33,370
call multiply now it print out the

00:21:31,330 --> 00:21:34,990
correct answer of 6 but now if I try to

00:21:33,370 --> 00:21:36,970
call ad or something that I won't be

00:21:34,990 --> 00:21:39,580
able to do it because I had the API

00:21:36,970 --> 00:21:42,250
models not up-to-date here so now let me

00:21:39,580 --> 00:21:46,240
go fix that and use the new updated API

00:21:42,250 --> 00:21:48,760
model so they got for free so said if I

00:21:46,240 --> 00:21:50,980
create this client again and look at all

00:21:48,760 --> 00:21:53,140
the different options I have our methods

00:21:50,980 --> 00:21:55,330
I have LVT available to me now you can

00:21:53,140 --> 00:21:57,610
see that I have ads so if I do if I had

00:21:55,330 --> 00:22:00,070
one one against each other it's gonna

00:21:57,610 --> 00:22:04,809
me too and then if I call subtract on

00:22:00,070 --> 00:22:06,400
this instead appropriately show zero so

00:22:04,809 --> 00:22:07,750
this was really cool because I didn't

00:22:06,400 --> 00:22:09,580
actually have to write any more Python

00:22:07,750 --> 00:22:11,309
code once we once our application was

00:22:09,580 --> 00:22:13,720
kind of built from the ground up and

00:22:11,309 --> 00:22:18,070
adding new features in the future is not

00:22:13,720 --> 00:22:20,460
very difficult at all so now let me get

00:22:18,070 --> 00:22:26,549
to the kind of conclusion of this talk

00:22:20,460 --> 00:22:29,049
where but dynamic class generation I

00:22:26,549 --> 00:22:31,150
realized my sample application was super

00:22:29,049 --> 00:22:32,860
simple it was just adding subtracting

00:22:31,150 --> 00:22:34,360
multiplying numbers together there's not

00:22:32,860 --> 00:22:36,580
really even needs to be a Web API for

00:22:34,360 --> 00:22:38,440
this but what I want to get at is the

00:22:36,580 --> 00:22:39,910
fact that we started with an application

00:22:38,440 --> 00:22:42,070
you kind of built it to the ground up

00:22:39,910 --> 00:22:43,630
such that in order to add new

00:22:42,070 --> 00:22:45,610
functionality all it required was

00:22:43,630 --> 00:22:47,380
updating a new model or getting a new

00:22:45,610 --> 00:22:49,179
model hopefully your weren't even the

00:22:47,380 --> 00:22:50,320
one has got to update this new data

00:22:49,179 --> 00:22:52,720
source in order to pick up the new

00:22:50,320 --> 00:22:54,820
functionality and that's really powerful

00:22:52,720 --> 00:22:56,559
especially when you have a bunch of

00:22:54,820 --> 00:22:59,590
different other applications possibly

00:22:56,559 --> 00:23:01,240
using this similar model such that one

00:22:59,590 --> 00:23:02,890
update to the model can update and

00:23:01,240 --> 00:23:07,210
different applications that may be

00:23:02,890 --> 00:23:09,160
consuming it dynamic flash generation

00:23:07,210 --> 00:23:10,510
produces really robust code in yen

00:23:09,160 --> 00:23:12,700
because it's a generalized

00:23:10,510 --> 00:23:14,080
code path and all your logics are

00:23:12,700 --> 00:23:17,559
flowing in that through that down that

00:23:14,080 --> 00:23:20,980
as a result you get very well tested and

00:23:17,559 --> 00:23:22,809
heavily used code and one thing I really

00:23:20,980 --> 00:23:26,140
didn't talk about was features and bug

00:23:22,809 --> 00:23:28,690
fixes have a much wider spread impact in

00:23:26,140 --> 00:23:30,309
the sense that right now for the curt

00:23:28,690 --> 00:23:32,830
the client application I wrote it only

00:23:30,309 --> 00:23:35,290
supports JSON RPC protocol if I was to

00:23:32,830 --> 00:23:37,809
add something like a rest JSON or rest

00:23:35,290 --> 00:23:39,700
XML or query protocol what that opens it

00:23:37,809 --> 00:23:41,410
up for me is to you to be able to

00:23:39,700 --> 00:23:43,210
support a bunch of different API so that

00:23:41,410 --> 00:23:46,210
may be only running on that protocol and

00:23:43,210 --> 00:23:48,580
then in terms of bug fixes if I fix a

00:23:46,210 --> 00:23:50,740
bug in a certain date in a certain code

00:23:48,580 --> 00:23:52,299
path chances are even though I'm was

00:23:50,740 --> 00:23:54,070
targeted for one functionality if

00:23:52,299 --> 00:23:56,940
another function is using that same code

00:23:54,070 --> 00:24:01,320
path I probably fixed a bug in there too

00:23:56,940 --> 00:24:04,090
so I really hope you guys got a lot of

00:24:01,320 --> 00:24:06,280
ideas about how classic dynamic class

00:24:04,090 --> 00:24:08,440
generation works how to use it

00:24:06,280 --> 00:24:09,650
where we do use it and possibly have

00:24:08,440 --> 00:24:11,330
some ideas

00:24:09,650 --> 00:24:14,720
using it in your next big project or

00:24:11,330 --> 00:24:16,240
even current project today I would like

00:24:14,720 --> 00:24:18,710
to really thank you all for coming if

00:24:16,240 --> 00:24:20,330
you want to look at some of the

00:24:18,710 --> 00:24:23,690
presentation code here is a good hub

00:24:20,330 --> 00:24:24,890
repository for that here is the boat of

00:24:23,690 --> 00:24:26,420
three repository if you want to kind of

00:24:24,890 --> 00:24:28,820
look at the more nitty-gritty stuff on

00:24:26,420 --> 00:24:31,340
resources in client generate dynamic

00:24:28,820 --> 00:24:32,930
client generation and also boto core

00:24:31,340 --> 00:24:35,270
that's where most of the client the

00:24:32,930 --> 00:24:36,650
dynamic client generation happens by 2/3

00:24:35,270 --> 00:24:38,030
just kind of proxies out to that so if

00:24:36,650 --> 00:24:39,380
you want to actually see how clients get

00:24:38,030 --> 00:24:43,580
created there I'd recommend checking

00:24:39,380 --> 00:24:45,470
that out but otherwise I'll be here all

00:24:43,580 --> 00:24:48,140
week so if you guys have any questions

00:24:45,470 --> 00:24:50,090
about boat of three boat oak or seoi or

00:24:48,140 --> 00:24:50,809
about AWS come find me I'll be happy to

00:24:50,090 --> 00:24:52,820
talk about it

00:24:50,809 --> 00:24:55,150
but that's about it is there any

00:24:52,820 --> 00:24:55,150
questions

00:25:14,400 --> 00:25:21,039
thank you very much could you contrast

00:25:18,370 --> 00:25:24,220
this technique that you showed us with

00:25:21,039 --> 00:25:28,120
two other ways of doing a similar thing

00:25:24,220 --> 00:25:29,620
that is using the get at get at

00:25:28,120 --> 00:25:33,429
attribute okay

00:25:29,620 --> 00:25:34,750
and using metaclasses yeah so

00:25:33,429 --> 00:25:38,350
metaclasses is definitely something you

00:25:34,750 --> 00:25:40,029
can actually try to use it with because

00:25:38,350 --> 00:25:42,640
in reality type is just a meta class

00:25:40,029 --> 00:25:44,289
right so you could define your own

00:25:42,640 --> 00:25:47,200
metaclasses if you want some specific

00:25:44,289 --> 00:25:48,520
functionality out of it as well so like

00:25:47,200 --> 00:25:49,929
there's a bunch of different other

00:25:48,520 --> 00:25:52,210
approaches in order to dynamically

00:25:49,929 --> 00:25:54,429
generating classes is just type is one

00:25:52,210 --> 00:25:57,090
of them that is kind of built set built

00:25:54,429 --> 00:26:05,830
with for you right out of the box

00:25:57,090 --> 00:26:09,570
second anyone else were questions okay

00:26:05,830 --> 00:26:09,570

YouTube URL: https://www.youtube.com/watch?v=fhqE7aS6cj8


