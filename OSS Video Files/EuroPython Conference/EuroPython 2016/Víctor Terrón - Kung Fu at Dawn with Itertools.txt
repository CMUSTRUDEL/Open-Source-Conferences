Title: Víctor Terrón - Kung Fu at Dawn with Itertools
Publication date: 2016-07-28
Playlist: EuroPython 2016
Description: 
	Víctor Terrón - Kung Fu at Dawn with Itertools
[EuroPython 2016]
[18 July 2016]
[Bilbao, Euskadi, Spain]
(https://ep2016.europython.eu//conference/talks/kung-fu-at-dawn-with-itertools)

The itertools module is one of the cornerstones of advanced
programming in Python. This talk offers practical advice about
iterator algebra that can be put into practice immediately.
Discovering the itertools module means taking the veil from our eyes,
and once we use functions such as repeat(), takewhile(), dropwhile()
or product(), there is no return — it is impossible to come back to
the world of the mere mortals, where solutions are more complex and
need more memory.

-----

The itertools module is one of the cornerstones of advanced
programming in Python. Part of the standard library, it provides an
iterator algebra that allows us to elegantly chain abstractions,
enabling solutions that are both simpler and more memory efficient.

The goal of this talk is to offer practical advice and clear lessons
that can be immediately put into practice. Illustrating it with
numerous examples, attendees will leave having assimilated at least
several concepts that will improve their code undeniably and
irremediably. Emphasis will be on showing specific cases where a
traditional solution can be overhauled over and over with functions
from the itertools module.

Let’s say, for example, that we want to alternate indefinitely between
two values: -1 and 1. The novice would use a variable, updating its
value at each step, and the average user would maybe opt for an
endless generator. Both are worthy and honorable solutions, but they
pale before the mastery of the martial artist who only needs
itertools.cycle(). Because that is the nature of the itertools module:
once the veil falls from our eyes and we come across functions such as
repeat(), takewhile(), dropwhile() or product(), there is no return.
In this talk we will learn to identify when they can be used,
accomplishing with a single line of code what for the mere mortals
takes much more effort.
Captions: 
	00:00:00,000 --> 00:00:05,759
our news presenter is Victor Tehran he

00:00:03,120 --> 00:00:09,510
cited a reliability engineer at Google

00:00:05,759 --> 00:00:19,710
and he will present us a comfo atern

00:00:09,510 --> 00:00:21,570
with either tools and this is not confer

00:00:19,710 --> 00:00:23,850
but it was a super cool image so I have

00:00:21,570 --> 00:00:25,710
to use it we will make up for it later I

00:00:23,850 --> 00:00:27,510
also have a lot of things to say if any

00:00:25,710 --> 00:00:31,109
of you disagree spur you is raise your

00:00:27,510 --> 00:00:33,450
hand and disagree and we don't know how

00:00:31,109 --> 00:00:35,100
we loop over at least in Python right we

00:00:33,450 --> 00:00:38,579
are told this all the time we have to

00:00:35,100 --> 00:00:40,680
say for thing in whatever do thing for

00:00:38,579 --> 00:00:43,170
example here we're looping over the ends

00:00:40,680 --> 00:00:45,149
and we are always told that's way better

00:00:43,170 --> 00:00:47,100
than doing this which we might be

00:00:45,149 --> 00:00:48,989
tempted to do when we come from other

00:00:47,100 --> 00:00:51,270
languages we could say okay I'm going to

00:00:48,989 --> 00:00:53,520
generate all the indexes and I'm going

00:00:51,270 --> 00:00:56,449
to do stuff with the indexes accessing

00:00:53,520 --> 00:00:59,309
each one of the elements and even worse

00:00:56,449 --> 00:01:02,010
we know we don't want to do this like

00:00:59,309 --> 00:01:04,680
even instead of using range we could try

00:01:02,010 --> 00:01:06,869
to increase the value of index by hand

00:01:04,680 --> 00:01:09,750
we don't do this so we know we have to

00:01:06,869 --> 00:01:13,380
use what it's Python for loop which in

00:01:09,750 --> 00:01:15,600
other languages is a 4h and we know if

00:01:13,380 --> 00:01:17,400
it that's going to give us a higher

00:01:15,600 --> 00:01:19,740
instruction level which means it's the

00:01:17,400 --> 00:01:21,240
code is more readable it's trade or so

00:01:19,740 --> 00:01:23,880
we like it we don't have to think about

00:01:21,240 --> 00:01:26,700
what's going on we only say okay loop

00:01:23,880 --> 00:01:30,270
over this whatever it is and it works

00:01:26,700 --> 00:01:32,130
it's nice also it's safer and this is

00:01:30,270 --> 00:01:33,750
important because we are not working

00:01:32,130 --> 00:01:36,000
with index so we don't have to think

00:01:33,750 --> 00:01:38,850
that's a major goal in life we just have

00:01:36,000 --> 00:01:41,070
to do stuff for example if we try to

00:01:38,850 --> 00:01:43,530
work with indexes in hand it could this

00:01:41,070 --> 00:01:45,540
is a off by one error we forgot we we

00:01:43,530 --> 00:01:48,990
went too far and we try to access the

00:01:45,540 --> 00:01:51,479
NLT last element it's not there when we

00:01:48,990 --> 00:01:53,060
use it for each a Python for loop this

00:01:51,479 --> 00:01:55,790
is not something that can happen

00:01:53,060 --> 00:01:57,530
and of course it's not only going to

00:01:55,790 --> 00:02:00,020
work with list we can use it for example

00:01:57,530 --> 00:02:02,299
with strings for each letter in the

00:02:00,020 --> 00:02:04,640
string well leather is a multi variable

00:02:02,299 --> 00:02:06,920
we can access each one of the characters

00:02:04,640 --> 00:02:09,259
in the string we can also get it and use

00:02:06,920 --> 00:02:11,360
it with sets we can loop over the

00:02:09,259 --> 00:02:13,430
islands although we don't know the order

00:02:11,360 --> 00:02:15,590
in which we are going to see them we can

00:02:13,430 --> 00:02:18,020
loop over the Canaries for example here

00:02:15,590 --> 00:02:21,650
using items we can get the get the key

00:02:18,020 --> 00:02:24,530
and the value of each beam mappings and

00:02:21,650 --> 00:02:27,410
even with files we open a file and then

00:02:24,530 --> 00:02:29,570
we use the we loop over the file

00:02:27,410 --> 00:02:31,940
descriptor and we can loop over each one

00:02:29,570 --> 00:02:35,090
of the lines and that's the Python way

00:02:31,940 --> 00:02:38,420
in the end we can use loop with anything

00:02:35,090 --> 00:02:40,190
that's interval and that's you don't we

00:02:38,420 --> 00:02:43,310
take it for granted now the question

00:02:40,190 --> 00:02:46,519
what some iterable when we go to the

00:02:43,310 --> 00:02:48,680
docks it turns out all the answers are

00:02:46,519 --> 00:02:50,930
not only in stock workflow you can also

00:02:48,680 --> 00:02:53,360
go to the docks and written and it says

00:02:50,930 --> 00:02:55,550
ok and interval it's not yet capable of

00:02:53,360 --> 00:02:56,180
turning one element at a time blah blah

00:02:55,550 --> 00:02:59,440
blah blah

00:02:56,180 --> 00:03:02,420
it means our class has to implement a

00:02:59,440 --> 00:03:05,570
magic method dunder a third down there

00:03:02,420 --> 00:03:10,070
or also get iron let's focus on the

00:03:05,570 --> 00:03:13,340
first so ok we have to implement I turn

00:03:10,070 --> 00:03:17,329
this magic method what what's this magic

00:03:13,340 --> 00:03:19,790
and it says ok this methyl is going to

00:03:17,329 --> 00:03:22,760
be told when we need an iterator

00:03:19,790 --> 00:03:25,760
and it should it should return a new

00:03:22,760 --> 00:03:28,459
iterator ok so we know we know we need

00:03:25,760 --> 00:03:31,609
to implement ITER and make it return an

00:03:28,459 --> 00:03:33,859
iterator so first good at some point we

00:03:31,609 --> 00:03:38,209
will call either the built in and we

00:03:33,859 --> 00:03:40,070
will get the iterator and it's if we

00:03:38,209 --> 00:03:43,250
have a list of numbers for example we

00:03:40,070 --> 00:03:45,890
can say ok print down there either and

00:03:43,250 --> 00:03:47,270
yes it's there it's a method of the

00:03:45,890 --> 00:03:49,700
least object

00:03:47,270 --> 00:03:53,210
and if we call either we build and we

00:03:49,700 --> 00:03:56,750
get the interpreter and yes it's a list

00:03:53,210 --> 00:04:00,740
iterator object so I'm not lying but now

00:03:56,750 --> 00:04:03,680
what's an iterator well it turns out an

00:04:00,740 --> 00:04:06,530
iterator is something that conforms to

00:04:03,680 --> 00:04:09,200
the protocol which means you have to

00:04:06,530 --> 00:04:11,720
implement two different methods you have

00:04:09,200 --> 00:04:15,380
to first implement ITER again and you

00:04:11,720 --> 00:04:18,530
have to return self which makes sense

00:04:15,380 --> 00:04:20,450
but at first it doesn't look like but

00:04:18,530 --> 00:04:22,580
you have to do the same so this is

00:04:20,450 --> 00:04:25,460
remember we are writing we are writing

00:04:22,580 --> 00:04:27,320
our own iterator and the dogs are right

00:04:25,460 --> 00:04:30,230
it makes sense because in that case you

00:04:27,320 --> 00:04:33,290
can use the iterator with a fool with a

00:04:30,230 --> 00:04:34,760
four and any statements anything

00:04:33,290 --> 00:04:37,250
we're not anyway we don't care we will

00:04:34,760 --> 00:04:40,220
do these we can follow instructions and

00:04:37,250 --> 00:04:42,290
then we have to implement another magic

00:04:40,220 --> 00:04:46,010
method we have to implement next and

00:04:42,290 --> 00:04:47,990
next should return the next element and

00:04:46,010 --> 00:04:51,500
when there are no elements left which it

00:04:47,990 --> 00:04:53,210
should raise stop iteration I don't know

00:04:51,500 --> 00:04:55,340
what the second sentence means it's

00:04:53,210 --> 00:04:57,980
something with a low level and this was

00:04:55,340 --> 00:05:01,280
next in Python - but nobody is just

00:04:57,980 --> 00:05:04,940
backing - anymore and so now finally our

00:05:01,280 --> 00:05:07,760
clumsy and awkward iterator and we are

00:05:04,940 --> 00:05:10,940
looping over a set or a series of

00:05:07,760 --> 00:05:11,600
elements either is going to return self

00:05:10,940 --> 00:05:13,940
okay

00:05:11,600 --> 00:05:17,150
and next is going to return the next

00:05:13,940 --> 00:05:19,010
element once we are no more elements we

00:05:17,150 --> 00:05:22,160
went too far with index we are going to

00:05:19,010 --> 00:05:23,780
raise stop iteration J we did it and we

00:05:22,160 --> 00:05:27,980
can see once there are no lumps left

00:05:23,780 --> 00:05:29,540
stop iteration now something important

00:05:27,980 --> 00:05:31,550
we notice that when we work with

00:05:29,540 --> 00:05:35,630
iterators next it's going to return the

00:05:31,550 --> 00:05:37,790
next one but we can only use next with

00:05:35,630 --> 00:05:39,890
iterators so if we try to call next

00:05:37,790 --> 00:05:41,720
directly only list it's not going to

00:05:39,890 --> 00:05:43,680
work it's going to say okay no it's not

00:05:41,720 --> 00:05:47,669
an iterator you cannot

00:05:43,680 --> 00:05:50,190
so we have to call first eater and then

00:05:47,669 --> 00:05:52,410
we get the iterator and then we can call

00:05:50,190 --> 00:05:54,690
next as many times as we want until we

00:05:52,410 --> 00:05:58,020
hit this stop iteration iteration which

00:05:54,690 --> 00:06:00,900
means no more elements left and that's

00:05:58,020 --> 00:06:03,030
exactly what the for loop is doing under

00:06:00,900 --> 00:06:05,220
the hood it's called it's using either

00:06:03,030 --> 00:06:08,520
it's getting an iterator and then it

00:06:05,220 --> 00:06:10,800
starts going next forever until it sees

00:06:08,520 --> 00:06:13,110
stop iteration so if we want to

00:06:10,800 --> 00:06:15,300
implement the for loop in pure Python

00:06:13,110 --> 00:06:17,520
for no reason at all we will have to do

00:06:15,300 --> 00:06:20,610
something like this and that's basically

00:06:17,520 --> 00:06:24,570
what in global actual beautiful code

00:06:20,610 --> 00:06:26,520
it's happening see Python mmm now

00:06:24,570 --> 00:06:28,830
something nice we said okay your

00:06:26,520 --> 00:06:33,180
iterator this monster we wrote that

00:06:28,830 --> 00:06:34,680
races stop iteration easy has it has two

00:06:33,180 --> 00:06:36,900
ways it's raising an exception when

00:06:34,680 --> 00:06:39,360
there are no lemons left but we're not

00:06:36,900 --> 00:06:41,400
seeing any exception when we work with

00:06:39,360 --> 00:06:43,050
iPhone before over we loop over

00:06:41,400 --> 00:06:45,560
something we are not going to see an

00:06:43,050 --> 00:06:48,030
exception why because the for loop is

00:06:45,560 --> 00:06:50,669
actually listening for this stop

00:06:48,030 --> 00:06:53,130
iteration and that's the second it uses

00:06:50,669 --> 00:06:56,250
to stop processing so it's actually

00:06:53,130 --> 00:06:59,039
going to be expecting a stop iteration

00:06:56,250 --> 00:07:03,830
in the in one of the next calls and when

00:06:59,039 --> 00:07:07,139
that happens it breaks now generators

00:07:03,830 --> 00:07:09,900
generators are a special type of

00:07:07,139 --> 00:07:12,389
literature we all know how a normal

00:07:09,900 --> 00:07:14,970
function works we start in the function

00:07:12,389 --> 00:07:18,449
we do stop ending at some point we

00:07:14,970 --> 00:07:20,370
finish and we return mm-hmm and yes

00:07:18,449 --> 00:07:22,080
that's abuse but sometimes we don't

00:07:20,370 --> 00:07:24,240
think about it whatever we have to

00:07:22,080 --> 00:07:27,150
return for our motor function has to be

00:07:24,240 --> 00:07:29,820
done at once for example here we have a

00:07:27,150 --> 00:07:32,340
super simple function and it's it hasn't

00:07:29,820 --> 00:07:33,810
seen no exit point so we do something

00:07:32,340 --> 00:07:37,110
the first line second line and then we

00:07:33,810 --> 00:07:40,050
return a value we can have multiple

00:07:37,110 --> 00:07:42,870
simple points this is 101 we can return

00:07:40,050 --> 00:07:45,330
the function either in the first return

00:07:42,870 --> 00:07:46,710
or you see any second but once we hit

00:07:45,330 --> 00:07:49,050
one of the returns we are going to

00:07:46,710 --> 00:07:51,479
finish and we will never be back if our

00:07:49,050 --> 00:07:54,569
function doesn't have a return

00:07:51,479 --> 00:07:56,520
that's implicit No so actually Python

00:07:54,569 --> 00:07:58,199
functions are always returning something

00:07:56,520 --> 00:08:02,490
if we don't say return something it's

00:07:58,199 --> 00:08:05,279
returning now mmm now how is that a

00:08:02,490 --> 00:08:06,479
problem well it's not that for example

00:08:05,279 --> 00:08:08,879
let's say we want to work with old

00:08:06,479 --> 00:08:11,009
people numbers in the world we want a

00:08:08,879 --> 00:08:13,830
get even function with that it's going

00:08:11,009 --> 00:08:15,870
to give us a lot of even numbers until a

00:08:13,830 --> 00:08:18,029
threshold mmm

00:08:15,870 --> 00:08:20,159
with right we could write it this simple

00:08:18,029 --> 00:08:22,529
the ugly way or the Python way using

00:08:20,159 --> 00:08:25,919
rate which we cast three lists and it

00:08:22,529 --> 00:08:27,930
works mmm that could become a problem at

00:08:25,919 --> 00:08:29,789
some point we want to work with a lot of

00:08:27,930 --> 00:08:31,740
numbers because this function we said

00:08:29,789 --> 00:08:35,159
okay we have to return everything at the

00:08:31,740 --> 00:08:37,919
same time so if I want to sum billions

00:08:35,159 --> 00:08:39,870
and billions as Carl Sagan would say of

00:08:37,919 --> 00:08:42,680
numbers and we can't do that because

00:08:39,870 --> 00:08:45,779
that's not going to fit in in the memory

00:08:42,680 --> 00:08:48,209
so that's when we use generators because

00:08:45,779 --> 00:08:50,490
generators are functions that are able

00:08:48,209 --> 00:08:53,149
to return values one by one which means

00:08:50,490 --> 00:08:55,620
the state of the function is frozen and

00:08:53,149 --> 00:08:58,319
the we don't use which one we used yield

00:08:55,620 --> 00:09:00,089
and when we get to a deal we return a

00:08:58,319 --> 00:09:02,940
value and the function freezes there

00:09:00,089 --> 00:09:06,920
until we call the following next and

00:09:02,940 --> 00:09:09,779
over and over that's super cool and

00:09:06,920 --> 00:09:11,339
basically if we have one or more deals

00:09:09,779 --> 00:09:12,630
in our function it's not going to be a

00:09:11,339 --> 00:09:14,430
normal function it's going to be a

00:09:12,630 --> 00:09:16,019
generator function and it's going to be

00:09:14,430 --> 00:09:19,079
it's going to return a generator

00:09:16,019 --> 00:09:20,540
iterator which for shortly referred to

00:09:19,079 --> 00:09:23,130
as generator

00:09:20,540 --> 00:09:24,959
so for example here simple generator

00:09:23,130 --> 00:09:27,240
isn't news in return it's using geo

00:09:24,959 --> 00:09:28,920
which means we can call it up to three

00:09:27,240 --> 00:09:31,769
times and it's going it's going to

00:09:28,920 --> 00:09:33,389
return values one by one we'll assign

00:09:31,769 --> 00:09:35,399
there are no elements left so it's going

00:09:33,389 --> 00:09:37,640
to return us all iterator stopped

00:09:35,399 --> 00:09:40,339
iterate iteration

00:09:37,640 --> 00:09:42,200
so in this case we said okay we want to

00:09:40,339 --> 00:09:43,850
return all natural numbers okay I'm

00:09:42,200 --> 00:09:45,890
going to say I'm going to do this I have

00:09:43,850 --> 00:09:47,480
an endless loop it's not it's never

00:09:45,890 --> 00:09:49,310
going to work but I don't care because I

00:09:47,480 --> 00:09:51,350
am only returning elements one by one I

00:09:49,310 --> 00:09:55,070
mean this way I could keep calling this

00:09:51,350 --> 00:09:57,050
generator all the time and with a normal

00:09:55,070 --> 00:09:58,519
functional I dare you to try this but if

00:09:57,050 --> 00:10:00,380
you try to run this you will end up

00:09:58,519 --> 00:10:02,060
killing the process because it's never

00:10:00,380 --> 00:10:05,440
going to work we can never return all

00:10:02,060 --> 00:10:08,959
natural numbers as far as I know at once

00:10:05,440 --> 00:10:11,540
so TL DR I wasn't paying attention

00:10:08,959 --> 00:10:13,940
iterator object on which we call next

00:10:11,540 --> 00:10:16,339
that seemed we think we care and every

00:10:13,940 --> 00:10:19,070
generator is an iterator but not vice

00:10:16,339 --> 00:10:20,690
versa also and this is something greater

00:10:19,070 --> 00:10:22,670
Alex more telling what it wants on

00:10:20,690 --> 00:10:24,290
stackoverflow everything you can do with

00:10:22,670 --> 00:10:28,250
a generator you could do it with your

00:10:24,290 --> 00:10:30,829
own iterator class but generators give

00:10:28,250 --> 00:10:33,740
you a basic framework basically all the

00:10:30,829 --> 00:10:35,690
state keeping all the tipping state is

00:10:33,740 --> 00:10:37,790
already done for you the framework is

00:10:35,690 --> 00:10:39,950
there so if it's a simple most of the

00:10:37,790 --> 00:10:43,160
time depend for simple cases we can use

00:10:39,950 --> 00:10:45,560
a simple generator for extra points how

00:10:43,160 --> 00:10:47,660
do we measure a generator and we go away

00:10:45,560 --> 00:10:49,310
you know we can't because we know well

00:10:47,660 --> 00:10:51,320
we don't generate own numbers when they

00:10:49,310 --> 00:10:54,199
want so if we call n it's going to say

00:10:51,320 --> 00:10:57,470
type error you can do that we could call

00:10:54,199 --> 00:10:59,000
it we could cost cast it to a list and

00:10:57,470 --> 00:11:00,620
then we could call and what's the

00:10:59,000 --> 00:11:02,510
problem we'll as we said before we are

00:11:00,620 --> 00:11:06,140
going to be building all the list into

00:11:02,510 --> 00:11:07,670
memory mmm better we can use Sam we can

00:11:06,140 --> 00:11:09,350
say okay I'm going to add a lot of

00:11:07,670 --> 00:11:11,360
numbers one for each element in the

00:11:09,350 --> 00:11:14,300
generator so we have to exhaust the

00:11:11,360 --> 00:11:16,610
generator and in that way we can count

00:11:14,300 --> 00:11:19,399
it usefully for us convention when you

00:11:16,610 --> 00:11:21,440
say and restore I say throw a throwaway

00:11:19,399 --> 00:11:23,720
variable to signal we don't care about

00:11:21,440 --> 00:11:26,209
the actual value then wait time for

00:11:23,720 --> 00:11:28,189
something for every five minutes left

00:11:26,209 --> 00:11:30,220
I would need some water if that were

00:11:28,189 --> 00:11:30,220
possible

00:11:30,980 --> 00:11:38,209
if not it's fine and we have water we do

00:11:35,540 --> 00:11:42,139
have water okay that's the good life

00:11:38,209 --> 00:11:44,180
thank you um prime numbers prime numbers

00:11:42,139 --> 00:11:47,180
are great how will it turn how do we

00:11:44,180 --> 00:11:51,980
determine if a number is prime there are

00:11:47,180 --> 00:11:54,829
a lot of actual ways really mathematical

00:11:51,980 --> 00:11:56,329
ways but I like the simple stuff I am

00:11:54,829 --> 00:11:58,130
going to do it by him I'm going to try

00:11:56,329 --> 00:12:00,139
all possible numbers because the prime

00:11:58,130 --> 00:12:02,000
number only have only half is only going

00:12:00,139 --> 00:12:03,410
to have to do the source right you and

00:12:02,000 --> 00:12:05,389
it's one in itself

00:12:03,410 --> 00:12:07,339
okay I'm going to try all the other

00:12:05,389 --> 00:12:10,639
numbers and if there is at least one

00:12:07,339 --> 00:12:12,380
divisor you are not prime otherwise you

00:12:10,639 --> 00:12:14,089
are prime so I'm going to do it in this

00:12:12,380 --> 00:12:16,310
way it works now

00:12:14,089 --> 00:12:17,870
we don't have to do that really hugging

00:12:16,310 --> 00:12:20,180
thing do we need to do it by hand we

00:12:17,870 --> 00:12:23,329
said no no no use range and with range

00:12:20,180 --> 00:12:26,300
we can loop elegantly over all the

00:12:23,329 --> 00:12:28,250
candidate divisor this is a mandatory

00:12:26,300 --> 00:12:30,230
optimization although it's not strictly

00:12:28,250 --> 00:12:32,600
related to what we are saying here we

00:12:30,230 --> 00:12:34,820
can we only have to check divisors up

00:12:32,600 --> 00:12:36,949
t-square for it there are a lot of

00:12:34,820 --> 00:12:38,540
proofs I didn't understand them actually

00:12:36,949 --> 00:12:40,250
really bad

00:12:38,540 --> 00:12:41,899
Stack Overflow again there is a proof

00:12:40,250 --> 00:12:44,839
for humans they are but it basically

00:12:41,899 --> 00:12:47,420
says every non prime number will have a

00:12:44,839 --> 00:12:49,790
divisor the less than the square root or

00:12:47,420 --> 00:12:52,880
equal to so okay that's a lot of

00:12:49,790 --> 00:12:55,220
improvement don't for now so now integer

00:12:52,880 --> 00:12:57,589
how can we use it to something remotely

00:12:55,220 --> 00:12:59,060
useful into your factorization so we're

00:12:57,589 --> 00:13:02,300
going to the composing number into

00:12:59,060 --> 00:13:06,199
factors so for example 8 is 2 times 2

00:13:02,300 --> 00:13:07,850
times 2 and simples method again the

00:13:06,199 --> 00:13:10,699
trial division which means we are going

00:13:07,850 --> 00:13:13,310
to try all the prime numbers and we are

00:13:10,699 --> 00:13:16,730
going to OKC ok I need it by the number

00:13:13,310 --> 00:13:18,800
by these so write my solution here I

00:13:16,730 --> 00:13:22,279
said ok I want to go I want to get the

00:13:18,800 --> 00:13:24,260
first and prime numbers mmm how do we do

00:13:22,279 --> 00:13:26,600
it ok I'm going to build a an empty list

00:13:24,260 --> 00:13:29,000
and I am going to keep trying numbers ok

00:13:26,600 --> 00:13:31,250
number are the prime years then I put it

00:13:29,000 --> 00:13:33,110
into the list and finally I return it it

00:13:31,250 --> 00:13:35,160
worked again problem we are returning

00:13:33,110 --> 00:13:38,250
all the prime numbers at the same time

00:13:35,160 --> 00:13:40,890
and so okay we're here so let's use a

00:13:38,250 --> 00:13:42,720
generator I mean it's exactly the same

00:13:40,890 --> 00:13:44,940
but we don't use these memory in lists

00:13:42,720 --> 00:13:48,570
we can get we can return prime numbers

00:13:44,940 --> 00:13:50,340
as we generate them but now we are doing

00:13:48,570 --> 00:13:52,500
two different things here and that's how

00:13:50,340 --> 00:13:54,390
our code can break because we are at we

00:13:52,500 --> 00:13:56,220
are keeping track of how many universe

00:13:54,390 --> 00:13:58,530
we have generated so far and what's the

00:13:56,220 --> 00:13:59,190
next number we have to evaluate oops

00:13:58,530 --> 00:14:02,700
oops

00:13:59,190 --> 00:14:05,030
and that's I Tribune's count because we

00:14:02,700 --> 00:14:07,710
are in the other tools talk I don't -

00:14:05,030 --> 00:14:09,300
sounds it's super simple but cute it's

00:14:07,710 --> 00:14:11,820
it's going to make an iterator that the

00:14:09,300 --> 00:14:13,650
returns numbers and by default we are

00:14:11,820 --> 00:14:17,430
going to count from zero and the default

00:14:13,650 --> 00:14:20,310
step is one in other words it's like a

00:14:17,430 --> 00:14:22,860
range but with no upper limit we can

00:14:20,310 --> 00:14:26,370
call it keep calling keep calling it

00:14:22,860 --> 00:14:29,010
forever for example here okay next next

00:14:26,370 --> 00:14:30,810
next and we will get numbers and how is

00:14:29,010 --> 00:14:32,970
this usable well we can at least

00:14:30,810 --> 00:14:36,000
simplify our code a little bit we can

00:14:32,970 --> 00:14:39,240
say okay for a number in intervals count

00:14:36,000 --> 00:14:40,770
and that's never going to stop but still

00:14:39,240 --> 00:14:42,600
we're doing two things we are generating

00:14:40,770 --> 00:14:44,430
prime numbers and at the same time we

00:14:42,600 --> 00:14:46,440
are counting how many have we generated

00:14:44,430 --> 00:14:48,390
so far so I'm going to do something okay

00:14:46,440 --> 00:14:51,120
I'm going to split it in two different

00:14:48,390 --> 00:14:54,090
things first a generator of prime and

00:14:51,120 --> 00:14:56,010
prime numbers and then a function get

00:14:54,090 --> 00:14:57,690
Prime's which is going to be using the

00:14:56,010 --> 00:14:59,850
order generator and it's going to say

00:14:57,690 --> 00:15:02,070
okay how many have will return so far

00:14:59,850 --> 00:15:06,090
this many okay at some point we have

00:15:02,070 --> 00:15:08,880
enough we stop good but we can make it

00:15:06,090 --> 00:15:12,030
even better because okay we have reading

00:15:08,880 --> 00:15:14,400
a function there forget for Prime's we

00:15:12,030 --> 00:15:17,520
can use a simple generator expression or

00:15:14,400 --> 00:15:20,310
arguably maybe even better in this case

00:15:17,520 --> 00:15:22,800
we can say okay okay filter I'm going to

00:15:20,310 --> 00:15:25,350
filter all the numbers starting from two

00:15:22,800 --> 00:15:26,640
and I'm going to take only is prime

00:15:25,350 --> 00:15:28,950
because that's what the filter is going

00:15:26,640 --> 00:15:30,510
to do filter is going to lazily one by

00:15:28,950 --> 00:15:32,160
one it's going to check all the numbers

00:15:30,510 --> 00:15:34,980
every time we call next and it's going

00:15:32,160 --> 00:15:37,500
to return the next that satisfies this

00:15:34,980 --> 00:15:39,300
condition filter by the way was I three

00:15:37,500 --> 00:15:39,760
tools I feel there before but the game

00:15:39,300 --> 00:15:44,410
that

00:15:39,760 --> 00:15:46,210
all history mmm get Prime's now becomes

00:15:44,410 --> 00:15:47,770
this thing okay you have the counter and

00:15:46,210 --> 00:15:49,890
I have my list of primes

00:15:47,770 --> 00:15:52,030
because dang primes is going to be a

00:15:49,890 --> 00:15:54,130
it's going to be ready to turn in

00:15:52,030 --> 00:15:55,150
Princeville I want and we can count how

00:15:54,130 --> 00:15:57,580
many we need

00:15:55,150 --> 00:15:59,620
but now take how many this thing is a

00:15:57,580 --> 00:16:01,990
common pattern actually give me the

00:15:59,620 --> 00:16:04,810
first and elements of this interval and

00:16:01,990 --> 00:16:07,300
it turns out we cannot use slice

00:16:04,810 --> 00:16:08,560
impatient because it's going to complain

00:16:07,300 --> 00:16:10,810
actually it's going to say no a

00:16:08,560 --> 00:16:12,160
generator it's not subscrip double which

00:16:10,810 --> 00:16:13,720
makes sense because you are generating

00:16:12,160 --> 00:16:14,830
elements one by one if you are doing

00:16:13,720 --> 00:16:17,290
that how are you going to access

00:16:14,830 --> 00:16:19,600
randomly units you cannot do that but

00:16:17,290 --> 00:16:22,150
you can use it your either tools a slice

00:16:19,600 --> 00:16:24,760
which is basically like slicing tation

00:16:22,150 --> 00:16:27,790
but doing lately with all things

00:16:24,760 --> 00:16:30,400
interval so for example if we have item

00:16:27,790 --> 00:16:32,290
tools count which means all the numbers

00:16:30,400 --> 00:16:35,350
in the world and we say okay inter tools

00:16:32,290 --> 00:16:37,360
a slice if it five take five it's only

00:16:35,350 --> 00:16:40,420
going to return the first five and then

00:16:37,360 --> 00:16:41,980
stop but we can use it not only with

00:16:40,420 --> 00:16:44,650
generators we can use it with for

00:16:41,980 --> 00:16:47,440
example with a string and we are doing

00:16:44,650 --> 00:16:50,500
20 first three letters or we can and yes

00:16:47,440 --> 00:16:52,720
that's usual we can use steps other than

00:16:50,500 --> 00:16:55,780
one and we can start counting not from

00:16:52,720 --> 00:16:58,270
zero not from all their value so if we

00:16:55,780 --> 00:17:00,880
want the first and prime numbers we can

00:16:58,270 --> 00:17:03,790
say okay eater tools is lies primes and

00:17:00,880 --> 00:17:06,010
as many numbers as we need so let's

00:17:03,790 --> 00:17:07,300
rewrite our function now we get okay I

00:17:06,010 --> 00:17:09,130
have all the prime numbers in the world

00:17:07,300 --> 00:17:11,190
I am going to loop over this thing it

00:17:09,130 --> 00:17:14,410
slices returning and I am building them

00:17:11,190 --> 00:17:16,810
now that's okay we are looping over an

00:17:14,410 --> 00:17:20,650
array term and the only thing we do is

00:17:16,810 --> 00:17:22,620
given them that's what Jill from was

00:17:20,650 --> 00:17:26,230
invented from mmm

00:17:22,620 --> 00:17:28,750
deal from has well it allows us to do

00:17:26,230 --> 00:17:29,720
all your staff but the important part it

00:17:28,750 --> 00:17:32,120
allow us

00:17:29,720 --> 00:17:34,909
allows us to delegate part of the work

00:17:32,120 --> 00:17:38,330
to a different generator which means

00:17:34,909 --> 00:17:41,330
every time we call next G from is going

00:17:38,330 --> 00:17:42,200
to ask the second generator okay intron

00:17:41,330 --> 00:17:44,570
next

00:17:42,200 --> 00:17:46,130
give me your value and it's going to

00:17:44,570 --> 00:17:47,659
return it so it's basically the same

00:17:46,130 --> 00:17:50,090
thing as we were doing before it's the

00:17:47,659 --> 00:17:52,280
same thing as doing for and in thing

00:17:50,090 --> 00:17:54,500
Jill type thing we can do it with

00:17:52,280 --> 00:17:57,860
anything line with deal from so here

00:17:54,500 --> 00:18:01,340
spam is using deal from two which means

00:17:57,860 --> 00:18:03,440
we are simply calling in turn foo and

00:18:01,340 --> 00:18:05,870
return in the element so it's called to

00:18:03,440 --> 00:18:10,309
spam goes to fill and foo deals an

00:18:05,870 --> 00:18:14,330
element and spam deals it in turn and it

00:18:10,309 --> 00:18:16,280
works again not only with generators we

00:18:14,330 --> 00:18:18,220
can use it with anything that's interval

00:18:16,280 --> 00:18:21,950
for example here you're dealing from a

00:18:18,220 --> 00:18:24,260
string giving bubbles so we can rewrite

00:18:21,950 --> 00:18:27,049
our function as this we are simply okay

00:18:24,260 --> 00:18:30,020
we are taking a list of primes and we

00:18:27,049 --> 00:18:32,210
are taking how many would you say you

00:18:30,020 --> 00:18:36,950
need and it works for example in this

00:18:32,210 --> 00:18:39,049
case five and it works 18 minutes so far

00:18:36,950 --> 00:18:41,780
and I have not answered the question

00:18:39,049 --> 00:18:45,470
because we are actually not going to

00:18:41,780 --> 00:18:48,799
name this we don't want to get the first

00:18:45,470 --> 00:18:50,600
n prime numbers we want to get a series

00:18:48,799 --> 00:18:54,110
of prime numbers up to the square root

00:18:50,600 --> 00:18:57,669
that's what we said we have to do so no

00:18:54,110 --> 00:19:00,409
so we have to actually generate

00:18:57,669 --> 00:19:02,090
generators up to a value that's the

00:19:00,409 --> 00:19:04,340
threshold we don't we don't know how

00:19:02,090 --> 00:19:06,679
many we need we know the maximum value

00:19:04,340 --> 00:19:09,409
so we could say ok I'm going to do it

00:19:06,679 --> 00:19:11,690
the naive way I'm going to have these

00:19:09,409 --> 00:19:14,210
Prime's until function and I am going to

00:19:11,690 --> 00:19:16,010
loop over the primes at some point at

00:19:14,210 --> 00:19:18,620
some point I'm going to hit the limit

00:19:16,010 --> 00:19:20,600
and then it will stop if the value is

00:19:18,620 --> 00:19:21,320
less than the threshold I will deal this

00:19:20,600 --> 00:19:24,320
prime number

00:19:21,320 --> 00:19:26,900
and it turns out this is also a common

00:19:24,320 --> 00:19:29,690
this thing about we're looping until

00:19:26,900 --> 00:19:32,690
aids condition is no longer satisfied

00:19:29,690 --> 00:19:34,700
and that's take while I turtles take

00:19:32,690 --> 00:19:37,370
wild is going to make a new traitor

00:19:34,700 --> 00:19:38,900
that's going to return elements and it's

00:19:37,370 --> 00:19:40,940
going to stop you in the condition is

00:19:38,900 --> 00:19:43,130
normally true that's usually seen with

00:19:40,940 --> 00:19:45,740
lambda functions but it's not mandatory

00:19:43,130 --> 00:19:47,840
so for example here we we say okay you

00:19:45,740 --> 00:19:51,770
have numbers which is a lot of numbers

00:19:47,840 --> 00:19:54,560
and I want to take numbers while lambda

00:19:51,770 --> 00:19:56,450
X X less than four so I want to take

00:19:54,560 --> 00:19:58,790
numbers as long as they are less than

00:19:56,450 --> 00:20:00,830
four so the first time we call next on

00:19:58,790 --> 00:20:02,210
the iterator it's going to say okay I

00:20:00,830 --> 00:20:04,730
got one who's it's the first element

00:20:02,210 --> 00:20:07,880
it's one less than four yes

00:20:04,730 --> 00:20:09,740
so I'd yield it I return it I will try

00:20:07,880 --> 00:20:11,930
it sorry the same thing is going to

00:20:09,740 --> 00:20:13,940
happen with three with two with three

00:20:11,930 --> 00:20:16,430
but not with four because four is not

00:20:13,940 --> 00:20:18,260
going to is it's no longer going to

00:20:16,430 --> 00:20:21,110
satisfy satisfy the condition so it's

00:20:18,260 --> 00:20:24,410
going to stop iteration because there

00:20:21,110 --> 00:20:26,540
are no elements left again we don't have

00:20:24,410 --> 00:20:28,820
to use lambda functions if we have a

00:20:26,540 --> 00:20:31,730
function here which happened to be

00:20:28,820 --> 00:20:33,770
smaller than ten we could say okay take

00:20:31,730 --> 00:20:35,570
while where the predicate the condition

00:20:33,770 --> 00:20:39,950
is this function and we are going to

00:20:35,570 --> 00:20:42,710
evaluate it for each value so our khufu

00:20:39,950 --> 00:20:45,680
version of the thing we need is this I

00:20:42,710 --> 00:20:47,990
am dealing from take while where take

00:20:45,680 --> 00:20:50,510
while what's the condition okay that we

00:20:47,990 --> 00:20:53,930
are not yet there we have not hit the

00:20:50,510 --> 00:20:56,360
threshold and what about the opposite we

00:20:53,930 --> 00:20:58,550
have it it's drop while drop while it's

00:20:56,360 --> 00:21:01,160
going to make an iterator returning

00:20:58,550 --> 00:21:03,650
again elements but it's not it's going

00:21:01,160 --> 00:21:05,000
to ignore all the elements that make the

00:21:03,650 --> 00:21:07,100
condition true at some point the

00:21:05,000 --> 00:21:09,800
condition is not going to be true

00:21:07,100 --> 00:21:12,200
anymore and then we start up to the n

00:21:09,800 --> 00:21:13,580
with your turning elements so for

00:21:12,200 --> 00:21:15,590
example here here we are ignoring

00:21:13,580 --> 00:21:17,270
numbers as long as they are less than

00:21:15,590 --> 00:21:20,150
four so the first time we call next

00:21:17,270 --> 00:21:22,190
what's the what's dropped wild don't see

00:21:20,150 --> 00:21:24,590
it's going to see wine but one is not

00:21:22,190 --> 00:21:26,420
less than four so we drop it

00:21:24,590 --> 00:21:28,580
same thing with two same thing with

00:21:26,420 --> 00:21:30,830
three at some point we reach four four

00:21:28,580 --> 00:21:33,350
is not less than four so we have to

00:21:30,830 --> 00:21:36,350
return it and then we go on

00:21:33,350 --> 00:21:38,720
until the branch is over

00:21:36,350 --> 00:21:40,789
so combining both things we can write

00:21:38,720 --> 00:21:43,580
this cute function to get prime numbers

00:21:40,789 --> 00:21:46,100
within a range we can use tape while

00:21:43,580 --> 00:21:48,529
that's going to return an iterator and

00:21:46,100 --> 00:21:50,630
we can fit it we can pass it along to

00:21:48,529 --> 00:21:52,610
drop wild I mean that way we can

00:21:50,630 --> 00:21:56,419
generate we can generate all the prime

00:21:52,610 --> 00:22:00,409
numbers between start and stop and that

00:21:56,419 --> 00:22:02,659
and we could specify different values of

00:22:00,409 --> 00:22:05,269
course and by default we will generate

00:22:02,659 --> 00:22:07,460
everything from two to infinite but we

00:22:05,269 --> 00:22:08,210
could specify other values how is this

00:22:07,460 --> 00:22:09,950
useful

00:22:08,210 --> 00:22:12,110
well because finally to answer this

00:22:09,950 --> 00:22:15,470
thing we have the algorithm for integer

00:22:12,110 --> 00:22:18,820
factorization and we don't really care

00:22:15,470 --> 00:22:21,559
but we can go and operate we have to

00:22:18,820 --> 00:22:23,120
loop over all the prime numbers and for

00:22:21,559 --> 00:22:25,789
each prime number we try to divide the

00:22:23,120 --> 00:22:27,710
number by D prime number if we can

00:22:25,789 --> 00:22:30,889
divide it the prime number is a factor

00:22:27,710 --> 00:22:34,730
we save it and we keep doing it

00:22:30,889 --> 00:22:38,450
recursively so very quickly we have 30

00:22:34,730 --> 00:22:42,409
30 divisible by 2 it is so choosing

00:22:38,450 --> 00:22:45,350
factor and what's the quotient 15 so we

00:22:42,409 --> 00:22:46,940
start doing it recursively with 15 then

00:22:45,350 --> 00:22:50,149
we start with the first prime number

00:22:46,940 --> 00:22:52,580
it's two it's not visible we move on to

00:22:50,149 --> 00:22:56,480
the next and so on eventually we reach

00:22:52,580 --> 00:23:00,500
the best case if the and we will be over

00:22:56,480 --> 00:23:02,299
so here we are using Prime's until our

00:23:00,500 --> 00:23:05,330
need function using itertools

00:23:02,299 --> 00:23:08,389
under-the-hill good and we could change

00:23:05,330 --> 00:23:11,870
like every time we find a factor we

00:23:08,389 --> 00:23:14,659
create a new list and we concatenate it

00:23:11,870 --> 00:23:17,210
to the recursive call and well and we

00:23:14,659 --> 00:23:19,129
can see that it works note that we are

00:23:17,210 --> 00:23:21,760
actually going to using production that

00:23:19,129 --> 00:23:27,640
fits there more Campu

00:23:21,760 --> 00:23:29,080
now the unique command sometimes we have

00:23:27,640 --> 00:23:33,630
used unique command literally

00:23:29,080 --> 00:23:36,400
stackoverflow tells us to use it it's

00:23:33,630 --> 00:23:40,620
and you copy and paste without knowing

00:23:36,400 --> 00:23:43,930
what you're doing in your servers and

00:23:40,620 --> 00:23:47,110
unique is going to remove duplicate

00:23:43,930 --> 00:23:49,090
elements in Stannary input but only if

00:23:47,110 --> 00:23:51,520
they are together which means when you

00:23:49,090 --> 00:23:53,110
are starting and you go to IRC for you

00:23:51,520 --> 00:23:55,180
know than you ask how do we remove

00:23:53,110 --> 00:23:57,340
duplicate lines in a file this detailed

00:23:55,180 --> 00:23:59,710
UK you have to sort and then you pipe it

00:23:57,340 --> 00:24:03,370
to unique or this thing sort that's your

00:23:59,710 --> 00:24:05,920
right okay I I want to write it myself

00:24:03,370 --> 00:24:08,500
why not so let's say we only work with

00:24:05,920 --> 00:24:10,330
strings so I have to do something like

00:24:08,500 --> 00:24:12,160
this I have to say okay I am going to

00:24:10,330 --> 00:24:13,930
loop over all the words of the string

00:24:12,160 --> 00:24:16,240
I'm going to keep track of the result

00:24:13,930 --> 00:24:18,430
and everything is a new letter I have to

00:24:16,240 --> 00:24:21,760
say okay are you befriend then the last

00:24:18,430 --> 00:24:24,640
thing I saw if it's different

00:24:21,760 --> 00:24:27,490
I added if it's not ignore it so we all

00:24:24,640 --> 00:24:29,680
have to do it there may be faster ways

00:24:27,490 --> 00:24:33,460
this is a kind of simple way to do it

00:24:29,680 --> 00:24:35,560
and eventually we return the result okay

00:24:33,460 --> 00:24:39,100
here we can use goodbye goodbye super

00:24:35,560 --> 00:24:41,170
cool but it's also hard at first I try

00:24:39,100 --> 00:24:43,150
struggle to find examples that make

00:24:41,170 --> 00:24:46,930
sense that's this is the best I could

00:24:43,150 --> 00:24:50,170
find so you have to use and Roubaix is

00:24:46,930 --> 00:24:51,910
going to group elements yeah it's going

00:24:50,170 --> 00:24:53,830
to make an iterator that's going to

00:24:51,910 --> 00:24:56,110
return every time we call next it's

00:24:53,830 --> 00:25:00,250
going to return me to element tuple the

00:24:56,110 --> 00:25:02,680
key and group and what's a group well a

00:25:00,250 --> 00:25:05,740
new group is going to start when the

00:25:02,680 --> 00:25:08,980
value of the key changes the group

00:25:05,740 --> 00:25:11,590
objects themselves are an eternal thing

00:25:08,980 --> 00:25:14,100
so here we have this string with

00:25:11,590 --> 00:25:16,690
repeating elements we say okay goodbye

00:25:14,100 --> 00:25:19,390
tell me what's groups and it tells you

00:25:16,690 --> 00:25:23,800
okay it's a group by object Thank You

00:25:19,390 --> 00:25:26,380
Python so now we say okay next groups

00:25:23,800 --> 00:25:29,020
and it's going to give me okay the first

00:25:26,380 --> 00:25:30,179
group which is the first key and the

00:25:29,020 --> 00:25:31,799
first group and

00:25:30,179 --> 00:25:35,940
I say okay what's the key and it says

00:25:31,799 --> 00:25:38,490
it's a mm-hmm and what's group it's a

00:25:35,940 --> 00:25:40,740
group per object thank you again

00:25:38,490 --> 00:25:43,259
but well it's an interval so I wouldn't

00:25:40,740 --> 00:25:45,779
say okay I will keep going next until

00:25:43,259 --> 00:25:48,330
something happens and it turns out I can

00:25:45,779 --> 00:25:50,549
call it two times and it says okay you

00:25:48,330 --> 00:25:54,059
got an a you got a name and then you got

00:25:50,549 --> 00:25:56,429
a non-stop duration I didn't like so I

00:25:54,059 --> 00:25:57,899
don't know what's happening this is one

00:25:56,429 --> 00:26:00,720
of these cases where the docs have

00:25:57,899 --> 00:26:07,769
improved a lot whom still are hard to

00:26:00,720 --> 00:26:10,499
newcomers thank you it turns out the key

00:26:07,769 --> 00:26:14,039
is what the group contains for example a

00:26:10,499 --> 00:26:17,990
and the group are the actual elements so

00:26:14,039 --> 00:26:20,970
let's go to B it's going to tell us okay

00:26:17,990 --> 00:26:25,169
the key is B because this group has a

00:26:20,970 --> 00:26:27,059
lot of bits and the group itself is B

00:26:25,169 --> 00:26:29,159
because there was only one B and we're

00:26:27,059 --> 00:26:30,929
saying with C we have the keys

00:26:29,159 --> 00:26:34,590
C because in this group we have a lot we

00:26:30,929 --> 00:26:37,980
like sales and the group is CC C because

00:26:34,590 --> 00:26:40,409
we had three C's and this is super

00:26:37,980 --> 00:26:41,279
cereal right how could we use this to

00:26:40,409 --> 00:26:42,960
something useful

00:26:41,279 --> 00:26:44,639
well for example here we can write a

00:26:42,960 --> 00:26:46,409
little fine it looked for maybe it's

00:26:44,639 --> 00:26:48,809
simpler this way we can say okay print

00:26:46,409 --> 00:26:52,440
the key and the group and we can say

00:26:48,809 --> 00:26:55,830
okay first we saw a group that's ace and

00:26:52,440 --> 00:26:59,789
it had two A's same with B and with say

00:26:55,830 --> 00:27:01,679
we have three C's okay that's useful

00:26:59,789 --> 00:27:03,809
because for example here we wanted to

00:27:01,679 --> 00:27:05,700
remove duplicate elements if they are

00:27:03,809 --> 00:27:08,490
together we can say okay I'm going to

00:27:05,700 --> 00:27:12,149
group by all the elements and every time

00:27:08,490 --> 00:27:14,220
I meet if I find a new group I am going

00:27:12,149 --> 00:27:16,110
to take the key I don't care about a

00:27:14,220 --> 00:27:18,809
group because I don't want to remove

00:27:16,110 --> 00:27:21,090
duplicate elements so basically each key

00:27:18,809 --> 00:27:22,830
of each group is going to mark the

00:27:21,090 --> 00:27:25,799
beginning with the new set of distinct

00:27:22,830 --> 00:27:28,139
characters and we can do it like that or

00:27:25,799 --> 00:27:30,360
even or giving any simple way something

00:27:28,139 --> 00:27:32,909
else this is a common interview question

00:27:30,360 --> 00:27:33,850
you can find it online a lot I want a

00:27:32,909 --> 00:27:36,040
calm

00:27:33,850 --> 00:27:38,559
algorithm I am going to take a string

00:27:36,040 --> 00:27:40,990
and I'm going to use the counts so if I

00:27:38,559 --> 00:27:43,809
have three days I am going to replace it

00:27:40,990 --> 00:27:46,510
with three how do we do it

00:27:43,809 --> 00:27:48,850
well if you don't know the power of I

00:27:46,510 --> 00:27:52,929
turtles your life is paying a miscreant

00:27:48,850 --> 00:27:55,450
Orioles and blah blah especially because

00:27:52,929 --> 00:27:57,340
you don't you are supposed during an

00:27:55,450 --> 00:28:00,010
interview to come up with something like

00:27:57,340 --> 00:28:00,940
this you have to keep track of what's

00:28:00,010 --> 00:28:02,590
the current loop

00:28:00,940 --> 00:28:05,650
what's the number of times you've seen

00:28:02,590 --> 00:28:07,570
this last thing every time you start

00:28:05,650 --> 00:28:10,210
seeing a new group you have to restart

00:28:07,570 --> 00:28:12,670
your counter you have not to forget that

00:28:10,210 --> 00:28:14,350
eventually you're going to exit the four

00:28:12,670 --> 00:28:15,880
loop but do you still have something

00:28:14,350 --> 00:28:20,980
else in your hands so you have to obtain

00:28:15,880 --> 00:28:22,960
it at the end okay no higher it turns

00:28:20,980 --> 00:28:24,730
out you can use hydro tools and you can

00:28:22,960 --> 00:28:27,070
say okay I am going to group elements

00:28:24,730 --> 00:28:29,410
and every time I find a new group I take

00:28:27,070 --> 00:28:29,890
the key and how many times what what's

00:28:29,410 --> 00:28:32,020
the count

00:28:29,890 --> 00:28:33,640
okay I will count the groups how many

00:28:32,020 --> 00:28:36,160
elements were during the group and if

00:28:33,640 --> 00:28:38,110
you do that you change the key and the

00:28:36,160 --> 00:28:39,700
count of elements it's already in the

00:28:38,110 --> 00:28:45,100
group and you have your compression

00:28:39,700 --> 00:28:47,800
algorithm now key a elements in the

00:28:45,100 --> 00:28:50,770
group aaaa that's still strange and

00:28:47,800 --> 00:28:53,740
that's because by default group by using

00:28:50,770 --> 00:28:56,700
the Equality so a is equal to a because

00:28:53,740 --> 00:28:59,920
a is equal to a that's silly again right

00:28:56,700 --> 00:29:02,470
but it turns out the same way with sort

00:28:59,920 --> 00:29:04,450
or sorted we can use the key function we

00:29:02,470 --> 00:29:06,460
can you can use it with goodbye and we

00:29:04,450 --> 00:29:09,160
can say okay let's transform each

00:29:06,460 --> 00:29:11,110
element before we compare it and that's

00:29:09,160 --> 00:29:13,179
known as the key value for each element

00:29:11,110 --> 00:29:15,429
how is this useful okay I want to look

00:29:13,179 --> 00:29:17,920
later smile and I want to say okay I

00:29:15,429 --> 00:29:20,410
have it it's a series of words and I

00:29:17,920 --> 00:29:23,380
want blue and gray to go together

00:29:20,410 --> 00:29:25,900
because they have all four elements so

00:29:23,380 --> 00:29:27,970
if we don't know no better although this

00:29:25,900 --> 00:29:31,390
is still good we can say okay I'm going

00:29:27,970 --> 00:29:32,920
to use a hash table a dictionary Python

00:29:31,390 --> 00:29:35,500
it's going to be a default

00:29:32,920 --> 00:29:37,179
dict and I am going to say okay for each

00:29:35,500 --> 00:29:38,770
letter I'm going to count the number of

00:29:37,179 --> 00:29:40,330
elements and I am going to that key in

00:29:38,770 --> 00:29:43,090
the dictionary angle and I'm going to

00:29:40,330 --> 00:29:43,960
append the world okay but we can also do

00:29:43,090 --> 00:29:47,890
it with

00:29:43,960 --> 00:29:49,960
I can say okay I'm going to sort the the

00:29:47,890 --> 00:29:53,440
list by in Turkey and I am going to

00:29:49,960 --> 00:29:55,420
group all the letters and haha each

00:29:53,440 --> 00:29:56,860
group is already going to have all the

00:29:55,420 --> 00:29:59,140
letters that have the same length

00:29:56,860 --> 00:30:01,750
we could argue a lot I mean willing to

00:29:59,140 --> 00:30:03,910
do that whether this or the previous

00:30:01,750 --> 00:30:06,130
question was better and probably the

00:30:03,910 --> 00:30:08,500
other is faster I will argue that this

00:30:06,130 --> 00:30:09,610
is clearer because it's basically it's

00:30:08,500 --> 00:30:12,730
already in the name

00:30:09,610 --> 00:30:15,790
it's grouping things by a criteria in

00:30:12,730 --> 00:30:20,260
this case the rank it's all there now my

00:30:15,790 --> 00:30:24,400
favorite mathematics run away we have

00:30:20,260 --> 00:30:27,970
this function that I found online and we

00:30:24,400 --> 00:30:30,220
can use numpy to build a polynomial

00:30:27,970 --> 00:30:32,380
that's all the mathematics I know and we

00:30:30,220 --> 00:30:36,010
can evaluate it we can call the function

00:30:32,380 --> 00:30:39,760
and well I am stuck here I have to keep

00:30:36,010 --> 00:30:41,890
going it looks like this okay it's

00:30:39,760 --> 00:30:45,580
something I am going to say it's time

00:30:41,890 --> 00:30:48,550
versus something really really important

00:30:45,580 --> 00:30:50,590
and we are at work and we are monitoring

00:30:48,550 --> 00:30:53,170
this thing and I have a super cool

00:30:50,590 --> 00:30:56,740
teammate trying to do this and we spent

00:30:53,170 --> 00:31:00,400
three weeks in one single line of code

00:30:56,740 --> 00:31:02,050
so we said okay how do we do this we

00:31:00,400 --> 00:31:04,630
want to trigger an alarm we have to

00:31:02,050 --> 00:31:07,570
awake everybody if at some point we

00:31:04,630 --> 00:31:09,970
spent less than three seconds below zero

00:31:07,570 --> 00:31:11,920
I'm here by him we are relaxed we know

00:31:09,970 --> 00:31:16,360
the answer right it's true because

00:31:11,920 --> 00:31:18,370
between 0 and 3 there are at least 3

00:31:16,360 --> 00:31:22,270
seconds there where we were below the

00:31:18,370 --> 00:31:25,090
threshold for simplicity let's say ok I

00:31:22,270 --> 00:31:26,710
only care at such integers so we can

00:31:25,090 --> 00:31:30,250
evaluate it only there so now the

00:31:26,710 --> 00:31:33,100
question is riff is rephrased have we at

00:31:30,250 --> 00:31:34,570
some point being good are there are

00:31:33,100 --> 00:31:37,060
there that's the type of there are there

00:31:34,570 --> 00:31:40,150
are three consecutive points with

00:31:37,060 --> 00:31:42,790
negative sign you can do it the ugly way

00:31:40,150 --> 00:31:47,440
the beautiful way is like this I am

00:31:42,790 --> 00:31:49,540
going to use not the Equality thing for

00:31:47,440 --> 00:31:52,870
the grouping I am going to say ok I want

00:31:49,540 --> 00:31:55,180
to group values my whether they are

00:31:52,870 --> 00:31:56,560
negative or not and that's the key we

00:31:55,180 --> 00:32:00,340
use the case ok

00:31:56,560 --> 00:32:02,200
are you less than zero in this way every

00:32:00,340 --> 00:32:04,090
time what's the key going to be well the

00:32:02,200 --> 00:32:05,950
key is going to be the key value for

00:32:04,090 --> 00:32:07,510
each element so the key is going to be

00:32:05,950 --> 00:32:08,680
negative true or false

00:32:07,510 --> 00:32:10,750
which is going to say okay you are

00:32:08,680 --> 00:32:13,090
negative or not and the group is going

00:32:10,750 --> 00:32:15,370
to have the actual values so if we loop

00:32:13,090 --> 00:32:17,620
over it we can see that the first group

00:32:15,370 --> 00:32:20,080
the key is false because all the

00:32:17,620 --> 00:32:22,270
elements in this group according to

00:32:20,080 --> 00:32:24,400
these criteria are positive so the

00:32:22,270 --> 00:32:27,190
condition is for it's for the keys false

00:32:24,400 --> 00:32:29,650
and those are the four elements at the

00:32:27,190 --> 00:32:31,420
second group it turns out it's negative

00:32:29,650 --> 00:32:33,610
that's the key and we had at least three

00:32:31,420 --> 00:32:37,570
so yes the condition was true we have to

00:32:33,610 --> 00:32:41,040
trigger an alarm you can implement it

00:32:37,570 --> 00:32:44,470
without either tools I would not do that

00:32:41,040 --> 00:32:46,690
something simple we want to alternate

00:32:44,470 --> 00:32:49,810
indefinitely between numbers between

00:32:46,690 --> 00:32:52,780
minus 1 and 1 if we are absolute new

00:32:49,810 --> 00:32:57,160
converts how do we do it we quite a

00:32:52,780 --> 00:33:00,160
while true loop and we do that thing if

00:32:57,160 --> 00:33:01,150
I got any minus 1 I switch to a 1 and

00:33:00,160 --> 00:33:03,880
the other way around

00:33:01,150 --> 00:33:06,070
a little less beginner version would be

00:33:03,880 --> 00:33:07,750
ok I'm going to multiply by minus 1

00:33:06,070 --> 00:33:10,030
because somebody told me that's going to

00:33:07,750 --> 00:33:13,060
give me the opposite so it's simpler but

00:33:10,030 --> 00:33:14,830
still we're probably a place the first

00:33:13,060 --> 00:33:16,570
front row is going to die if we try to

00:33:14,830 --> 00:33:18,820
do this because it's ever going to end

00:33:16,570 --> 00:33:21,220
so we have to use the pro version and

00:33:18,820 --> 00:33:22,390
what's a pro version will I was paying

00:33:21,220 --> 00:33:24,900
attention it's going to be something

00:33:22,390 --> 00:33:26,560
entered to look right yes it's a

00:33:24,900 --> 00:33:28,330
generator

00:33:26,560 --> 00:33:29,860
Angiers we could write a generator we

00:33:28,330 --> 00:33:31,360
could say ok while true now what that

00:33:29,860 --> 00:33:32,500
went through it's never going to end but

00:33:31,360 --> 00:33:35,140
I don't care because I'm going to be

00:33:32,500 --> 00:33:37,300
using the iterator so I know every time

00:33:35,140 --> 00:33:39,910
I call next I'm going to get to the next

00:33:37,300 --> 00:33:41,980
element but we have the console version

00:33:39,910 --> 00:33:43,960
leaping forward seeing is cycle cycle

00:33:41,980 --> 00:33:47,710
it's going to take an interval and it's

00:33:43,960 --> 00:33:49,750
going to return elements one by one and

00:33:47,710 --> 00:33:52,030
Daeng is going to start over so we are

00:33:49,750 --> 00:33:53,399
going to loop endlessly over this input

00:33:52,030 --> 00:33:58,029
iterable

00:33:53,399 --> 00:34:00,669
and this is nice we are keeping a copy

00:33:58,029 --> 00:34:03,129
of the returned elements which means if

00:34:00,669 --> 00:34:05,110
the if we were using a generator as the

00:34:03,129 --> 00:34:08,970
input the generator event is going to

00:34:05,110 --> 00:34:12,069
run out of numbers elements sorry but

00:34:08,970 --> 00:34:16,720
cycle saved a copy so we can keep using

00:34:12,069 --> 00:34:19,179
it forever as we can see here G was a

00:34:16,720 --> 00:34:22,000
generator expression at some point it

00:34:19,179 --> 00:34:24,369
ran out of staff because we cycled over

00:34:22,000 --> 00:34:28,270
it giving one four nine one four nine

00:34:24,369 --> 00:34:30,520
all the time so if we try to use G again

00:34:28,270 --> 00:34:34,000
it says stop iteration you have nothing

00:34:30,520 --> 00:34:36,250
else but the cycle with other tools it's

00:34:34,000 --> 00:34:38,980
still working now if we want to iterate

00:34:36,250 --> 00:34:41,290
over two or more it travels how do we do

00:34:38,980 --> 00:34:43,450
it because let's say I want to go from

00:34:41,290 --> 00:34:47,710
one to ten and then I want to go down to

00:34:43,450 --> 00:34:49,810
two and keep doing that forever because

00:34:47,710 --> 00:34:52,960
I am playing Kerbal space program I

00:34:49,810 --> 00:34:55,899
never get to launch my Rockets I want to

00:34:52,960 --> 00:35:00,670
do that thing I want to cycle over two

00:34:55,899 --> 00:35:04,000
things over the first list from one to

00:35:00,670 --> 00:35:05,440
ten and then the second but Python is

00:35:04,000 --> 00:35:08,800
going to complain because cycle only

00:35:05,440 --> 00:35:10,630
takes one element and by extension how

00:35:08,800 --> 00:35:12,490
do we do it if you want to loop over two

00:35:10,630 --> 00:35:14,079
different it levels what do we do for

00:35:12,490 --> 00:35:16,780
example here we want to say 1 2 3 and

00:35:14,079 --> 00:35:18,880
then all the vowels do we do this like

00:35:16,780 --> 00:35:22,599
do we have to write two different for

00:35:18,880 --> 00:35:24,670
loops well we have chain chain is going

00:35:22,599 --> 00:35:26,589
to take a lot of things as input and

00:35:24,670 --> 00:35:28,599
it's going to make an iterator and this

00:35:26,589 --> 00:35:29,950
iterator it is super simple it's going

00:35:28,599 --> 00:35:32,020
to return elements from the first

00:35:29,950 --> 00:35:35,740
interrater then it's going to move to

00:35:32,020 --> 00:35:38,260
the second and so on so for example here

00:35:35,740 --> 00:35:41,319
we only have to say ok let's change to

00:35:38,260 --> 00:35:43,569
different levels the first waste and the

00:35:41,319 --> 00:35:46,730
second waste and it works and then in

00:35:43,569 --> 00:35:49,460
turn we can pass this along to cycle

00:35:46,730 --> 00:35:54,490
more canned food and we are five minutes

00:35:49,460 --> 00:35:54,490
that's at least 50 slides okay

00:35:54,619 --> 00:36:02,720
rolling dices if we want to roll if we

00:35:58,670 --> 00:36:04,369
roll two six-sided dices that is to

00:36:02,720 --> 00:36:06,140
normalize this how many unique

00:36:04,369 --> 00:36:08,749
combinations are there oh I remember

00:36:06,140 --> 00:36:12,019
that from high school that's the

00:36:08,749 --> 00:36:14,390
Cartesian product right so I am going to

00:36:12,019 --> 00:36:15,950
do a nested for loop and then they tell

00:36:14,390 --> 00:36:18,829
you okay and if you have three can you

00:36:15,950 --> 00:36:21,650
say okay I will write three for loops

00:36:18,829 --> 00:36:24,710
but at some point you have to generalize

00:36:21,650 --> 00:36:27,289
your solution and this is really hard

00:36:24,710 --> 00:36:29,749
for at first because okay how do we how

00:36:27,289 --> 00:36:31,309
do we do it well you can do it in

00:36:29,749 --> 00:36:32,930
different ways but you can use with

00:36:31,309 --> 00:36:35,359
curse them and you can say okay for each

00:36:32,930 --> 00:36:37,880
element I am going to combine it with

00:36:35,359 --> 00:36:40,789
all these sub products you create this

00:36:37,880 --> 00:36:43,130
ugly thing which I can prove it works

00:36:40,789 --> 00:36:46,130
but you have product and product is

00:36:43,130 --> 00:36:48,470
super simple product is going to make an

00:36:46,130 --> 00:36:52,039
iterator returning the Cartesian product

00:36:48,470 --> 00:36:54,230
of all the input iterables if you want

00:36:52,039 --> 00:36:58,069
to compute the product of something with

00:36:54,230 --> 00:37:05,930
itself you use repeat so you for example

00:36:58,069 --> 00:37:08,089
here we want to enroll yes oh oh yes we

00:37:05,930 --> 00:37:09,619
want to roll two dices we use repeat two

00:37:08,089 --> 00:37:12,710
and we can see that this first ten

00:37:09,619 --> 00:37:15,170
things it's returning our DOS so an is

00:37:12,710 --> 00:37:17,960
requesting if we're all four dice its

00:37:15,170 --> 00:37:20,119
how many outcomes in how many outcomes

00:37:17,960 --> 00:37:22,220
are they going to add up to five well

00:37:20,119 --> 00:37:23,930
that's simple I'm going to use product I

00:37:22,220 --> 00:37:27,170
am going to generate all the

00:37:23,930 --> 00:37:29,269
combinations but I don't want

00:37:27,170 --> 00:37:31,009
mathematics and I am going to filter all

00:37:29,269 --> 00:37:32,989
the results and I am going to take all

00:37:31,009 --> 00:37:34,579
that satisfy a condition what's the

00:37:32,989 --> 00:37:37,910
condition that the sum of all these

00:37:34,579 --> 00:37:40,009
sides equals 5 and well it turns out

00:37:37,910 --> 00:37:42,859
there are only 4 different results and

00:37:40,009 --> 00:37:45,980
finally pixels let's say we're working

00:37:42,859 --> 00:37:47,779
with pixels and lots of them and this is

00:37:45,980 --> 00:37:49,400
something we see a lot okay we have a

00:37:47,779 --> 00:37:51,799
constructor we have this init function

00:37:49,400 --> 00:37:54,739
and we say ok row and column and the

00:37:51,799 --> 00:37:57,259
constructor is only saying ok row equals

00:37:54,739 --> 00:37:59,239
row column equals column and then we

00:37:57,259 --> 00:38:00,410
have the wrapper because the magic

00:37:59,239 --> 00:38:03,170
method because we want to be able to

00:38:00,410 --> 00:38:05,780
print we see this a lot but

00:38:03,170 --> 00:38:07,250
this is a perfect example where we can

00:38:05,780 --> 00:38:09,260
use named Oh

00:38:07,250 --> 00:38:12,020
because the name couple is this

00:38:09,260 --> 00:38:13,900
wonderful factory function in the

00:38:12,020 --> 00:38:17,450
collections module which is going to

00:38:13,900 --> 00:38:21,020
create a new subclass of a couple for us

00:38:17,450 --> 00:38:23,780
which means if our class can be mean and

00:38:21,020 --> 00:38:25,700
mutable it's going to make our life way

00:38:23,780 --> 00:38:27,680
easier because we only have to say ok I

00:38:25,700 --> 00:38:30,500
am going to create a new class called

00:38:27,680 --> 00:38:32,569
pixel which has two fields row and

00:38:30,500 --> 00:38:34,250
column and that's going to do all the

00:38:32,569 --> 00:38:36,710
magic under a hill and it's going to

00:38:34,250 --> 00:38:38,720
create the new class pixel and with that

00:38:36,710 --> 00:38:41,900
object in your class we can create new

00:38:38,720 --> 00:38:44,780
objects and we have we get a lot of

00:38:41,900 --> 00:38:47,299
stuff for free if we need functionality

00:38:44,780 --> 00:38:50,030
we can use inheritance we inherit from

00:38:47,299 --> 00:38:52,130
this class and we can add our own own

00:38:50,030 --> 00:38:54,369
method for example here the distance I

00:38:52,130 --> 00:38:57,200
want to be able to compute the distance

00:38:54,369 --> 00:38:58,940
and now all this was an excuse because I

00:38:57,200 --> 00:39:02,240
wanted to say ok I want to get all the

00:38:58,940 --> 00:39:04,640
neighbors if they I have a pixel I want

00:39:02,240 --> 00:39:06,470
to be able to move up down left right on

00:39:04,640 --> 00:39:10,700
to the four corners I want to get all

00:39:06,470 --> 00:39:12,740
the eight neighbors of my pixel I'm cool

00:39:10,700 --> 00:39:14,960
I mean this is intermediate level so I

00:39:12,740 --> 00:39:19,520
know I have to use a generator I am

00:39:14,960 --> 00:39:20,930
going to use geo alright so I am going

00:39:19,520 --> 00:39:23,020
to do this thing I am going to deal

00:39:20,930 --> 00:39:28,369
eight times and I am going to return

00:39:23,020 --> 00:39:31,010
well if a to neighbors mmm yes about

00:39:28,369 --> 00:39:32,839
it's a lot of lines for nothing right so

00:39:31,010 --> 00:39:35,240
we can do this thing I am going to

00:39:32,839 --> 00:39:37,339
instead of working with creating all my

00:39:35,240 --> 00:39:39,890
objects manually I am going to confuse

00:39:37,339 --> 00:39:42,020
offsets I'm going to say okay at all

00:39:39,890 --> 00:39:45,770
times I'm going to move either at 0

00:39:42,020 --> 00:39:47,839
minus 1 or 1 in both axes so using that

00:39:45,770 --> 00:39:51,079
I can create the offsets and I can

00:39:47,839 --> 00:39:54,349
return all the neighbors of course when

00:39:51,079 --> 00:39:56,720
we get 0 and 0 as a product that's the

00:39:54,349 --> 00:39:58,849
odd bit pixel itself where we already

00:39:56,720 --> 00:40:00,980
are so we don't we don't have to use it

00:39:58,849 --> 00:40:04,579
we ignore it in all the other cases we

00:40:00,980 --> 00:40:06,349
can create in the object for super extra

00:40:04,579 --> 00:40:08,990
points that's a plus

00:40:06,349 --> 00:40:12,650
into instead of hard-coding the class

00:40:08,990 --> 00:40:15,510
name they are saying yield pixel

00:40:12,650 --> 00:40:18,960
we can not do that and we can say okay

00:40:15,510 --> 00:40:22,020
type self have you ever seen that if I

00:40:18,960 --> 00:40:24,030
do type self I can against CLS for

00:40:22,020 --> 00:40:26,640
example you could use any other name is

00:40:24,030 --> 00:40:28,530
it going to be a new class and so it's

00:40:26,640 --> 00:40:30,750
going to be the type of our class and

00:40:28,530 --> 00:40:32,849
then we can use it to create the new

00:40:30,750 --> 00:40:34,470
objects in that way if at some point we

00:40:32,849 --> 00:40:39,720
rename or class we don't have to track

00:40:34,470 --> 00:40:43,710
down these things and it works so we

00:40:39,720 --> 00:40:45,480
have covered a lot of stuff I didn't

00:40:43,710 --> 00:40:49,740
believe I didn't even actually believe I

00:40:45,480 --> 00:40:51,660
will be able to it's a lot of cool fans

00:40:49,740 --> 00:40:54,150
that are there in Python waiting for us

00:40:51,660 --> 00:40:57,000
but still we have only scratched

00:40:54,150 --> 00:41:03,780
scratched the surface there are a lot of

00:40:57,000 --> 00:41:06,599
things in the item tools module and even

00:41:03,780 --> 00:41:09,290
more important all these things that are

00:41:06,599 --> 00:41:11,790
so interesting well if they are for you

00:41:09,290 --> 00:41:14,730
all the building blocks in the ITER

00:41:11,790 --> 00:41:17,670
tools module are inspired in language

00:41:14,730 --> 00:41:20,730
like Haskell so we have been saying oh I

00:41:17,670 --> 00:41:23,640
tore tools is so cool when actually we

00:41:20,730 --> 00:41:26,760
were doing functional programming so

00:41:23,640 --> 00:41:29,819
maybe something worth looking into if

00:41:26,760 --> 00:41:32,040
you haven't yet because that's what we

00:41:29,819 --> 00:41:34,589
were doing here and if there are any

00:41:32,040 --> 00:41:36,770
questions I will happily take them thank

00:41:34,589 --> 00:41:36,770
you

00:41:48,520 --> 00:41:55,180
okay thank you very much we have one

00:41:51,920 --> 00:41:55,180
minute from one question

00:41:57,880 --> 00:42:00,480
yeah

00:42:07,940 --> 00:42:12,859
well great so thank you very much do you

00:42:10,460 --> 00:42:16,010
say these constructs as a trade-off

00:42:12,859 --> 00:42:18,109
between readability and elegance or

00:42:16,010 --> 00:42:20,359
something like that or you like visits

00:42:18,109 --> 00:42:23,200
sorry a sentence a trade-off between

00:42:20,359 --> 00:42:26,150
what between readability of the code and

00:42:23,200 --> 00:42:28,130
we'll the elegance of the brevity of the

00:42:26,150 --> 00:42:30,140
code because for some people to

00:42:28,130 --> 00:42:32,060
understand this they have to know about

00:42:30,140 --> 00:42:33,350
this high-level construction understand

00:42:32,060 --> 00:42:37,550
what they mean I don't know if you

00:42:33,350 --> 00:42:39,710
understand my point have you I thinking

00:42:37,550 --> 00:42:42,230
last night about this quote about how

00:42:39,710 --> 00:42:44,480
somebody said annexation I don't

00:42:42,230 --> 00:42:47,060
remember the name one person said if a

00:42:44,480 --> 00:42:50,050
new parameter language doesn't doesn't

00:42:47,060 --> 00:42:53,330
change the way you think it's worthless

00:42:50,050 --> 00:42:55,280
so these at first it's super ugly

00:42:53,330 --> 00:42:56,810
they grew by I agree it's super

00:42:55,280 --> 00:42:58,930
intimidating because what's happening

00:42:56,810 --> 00:43:02,240
here and at some point you start seeing

00:42:58,930 --> 00:43:05,300
the patterns and it turns out these are

00:43:02,240 --> 00:43:07,400
contract contracts are having a lot so I

00:43:05,300 --> 00:43:11,330
would agree that for newcomers from the

00:43:07,400 --> 00:43:14,450
outside this main may make not a lot of

00:43:11,330 --> 00:43:16,880
things but once you change your mindset

00:43:14,450 --> 00:43:19,880
I think you see there are problems that

00:43:16,880 --> 00:43:22,850
you simply fight a lot it's silly from

00:43:19,880 --> 00:43:29,080
one headlines to only two so in some

00:43:22,850 --> 00:43:29,080

YouTube URL: https://www.youtube.com/watch?v=iCrOGS1QlB8


