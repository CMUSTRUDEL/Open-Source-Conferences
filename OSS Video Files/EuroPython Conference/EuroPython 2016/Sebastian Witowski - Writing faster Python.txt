Title: Sebastian Witowski - Writing faster Python
Publication date: 2016-07-29
Playlist: EuroPython 2016
Description: 
	Sebastian Witowski - Writing faster Python
[EuroPython 2016]
[19 July 2016]
[Bilbao, Euskadi, Spain]
(https://ep2016.europython.eu//conference/talks/writing-faster-python)

Presentation on how you can write faster Python in your daily work. I
will briefly explain ways of profiling the code, discuss different
code structures and show how they can be improved. You will see what
is the fastest way to remove duplicates from a list, what is faster
than a _for_ loop or how “asking for permission” is slower than
“begging for forgiveness”.

-----

Did you know that Python preallocates integers from -5 to 257 ?
Reusing them 1000 times, instead of allocating memory for a bigger
integer, can save you a couple of milliseconds of code’s execution
time. If you want to learn more about this kind of optimizations then,
… well, probably this presentation is not for you :) Instead of going
into such small details, I will talk about more _"sane"_ ideas for
writing faster code.

After a very brief overview of how to optimize Python code (rule 1:
don’t do this, rule 2: don’t do this yet, rule 3: ok, but what if I
really want to do this ?), I will show simple and fast ways of
measuring the execution time and finally, discuss examples of how some
code structures could be improved.

You will see:

 - What is the fastest way of removing duplicates from a list

 - How much faster your code is when you reuse the built-in functions
instead of trying to reinvent the wheel

 - What is faster than the good ol’ _for_ loop

 - If the lookup is faster in a list or a set (and when it makes sense
to use each)

 - How the “It's better to beg for forgiveness than to ask for
permission” rule works in practice

I will NOT go into details of _"serious"_ optimization, like using
different Python implementation or rewriting critical code in C, etc.
Captions: 
	00:00:00,030 --> 00:00:03,629
good without further ado I'd like to

00:00:02,010 --> 00:00:05,400
present our next speaker Sebastian

00:00:03,629 --> 00:00:15,179
Sebastian we'll be talking about writing

00:00:05,400 --> 00:00:18,379
faster code give them a big hand okay hi

00:00:15,179 --> 00:00:18,379
everyone can you hear me

00:00:19,340 --> 00:00:24,869
okay so I would like to talk with you

00:00:22,320 --> 00:00:26,460
about writing faster code and last time

00:00:24,869 --> 00:00:28,050
I was giving a short talk short

00:00:26,460 --> 00:00:30,810
lightning talk about writing faster code

00:00:28,050 --> 00:00:32,550
I remember someone pointed out that well

00:00:30,810 --> 00:00:35,130
basically you can take your Python code

00:00:32,550 --> 00:00:39,540
rewrite it in C or C++ and it will be

00:00:35,130 --> 00:00:41,399
faster and I mean the guy was right so

00:00:39,540 --> 00:00:43,350
take any piece of Python code rewrite it

00:00:41,399 --> 00:00:45,780
in C or C++ and probably it will be out

00:00:43,350 --> 00:00:47,700
on automatically faster so I was

00:00:45,780 --> 00:00:50,160
thinking hmm if I say just writing

00:00:47,700 --> 00:00:52,379
faster code it might not be clear if I

00:00:50,160 --> 00:00:57,989
mean only Python or not so I had to fix

00:00:52,379 --> 00:00:59,609
the title of my presentation and I was

00:00:57,989 --> 00:01:01,170
very happy when you title I mean it

00:00:59,609 --> 00:01:03,359
makes it clear we are not going to talk

00:01:01,170 --> 00:01:04,979
about C or Java today but then I

00:01:03,359 --> 00:01:06,810
realized the title is too long I mean

00:01:04,979 --> 00:01:09,409
even though it's very clear thirty fits

00:01:06,810 --> 00:01:11,850
on the slide so I had to change it again

00:01:09,409 --> 00:01:14,340
so I got the version that means exactly

00:01:11,850 --> 00:01:15,810
the same thing but it's shorter so this

00:01:14,340 --> 00:01:18,119
is how I ended up with writing faster

00:01:15,810 --> 00:01:20,040
Python as a title for my today's talk so

00:01:18,119 --> 00:01:22,080
let's put aside the flamewar about which

00:01:20,040 --> 00:01:23,520
programming language is better we all

00:01:22,080 --> 00:01:27,060
know the answer your that's why you're

00:01:23,520 --> 00:01:28,650
here um Kryten was not created to be a

00:01:27,060 --> 00:01:30,570
fast language that you would use for

00:01:28,650 --> 00:01:33,600
some computations where every nanosecond

00:01:30,570 --> 00:01:35,100
counts and that's fine with me I mean

00:01:33,600 --> 00:01:38,159
Python is a great programming language

00:01:35,100 --> 00:01:40,259
that is very easy and fun to use Python

00:01:38,159 --> 00:01:42,720
is very easy to learn the fact that it's

00:01:40,259 --> 00:01:45,659
so easy to read and write code in Python

00:01:42,720 --> 00:01:47,670
it's very encouraging for people to knit

00:01:45,659 --> 00:01:49,229
for people new to software development I

00:01:47,670 --> 00:01:50,939
see that it's getting more and more

00:01:49,229 --> 00:01:52,560
popular in schools or at the

00:01:50,939 --> 00:01:55,470
universities as the first programming

00:01:52,560 --> 00:01:58,140
language and I am not surprised

00:01:55,470 --> 00:02:00,240
I mean imagine you're completely new to

00:01:58,140 --> 00:02:02,880
programming and someone tells you hey

00:02:00,240 --> 00:02:04,740
let me show you how much fun programming

00:02:02,880 --> 00:02:06,840
is and let's start with something super

00:02:04,740 --> 00:02:09,450
simple let's just bring some text to the

00:02:06,840 --> 00:02:12,840
screen and then he shows you those two

00:02:09,450 --> 00:02:13,720
examples I mean one of them is clearly

00:02:12,840 --> 00:02:15,070
not some

00:02:13,720 --> 00:02:17,260
think that you want to show to a

00:02:15,070 --> 00:02:20,410
beginner to encourage a more hair to

00:02:17,260 --> 00:02:22,930
start programming but also Python is not

00:02:20,410 --> 00:02:24,280
only useful useful for learning there

00:02:22,930 --> 00:02:26,050
are many big companies that are using

00:02:24,280 --> 00:02:28,390
Python companies with millions of users

00:02:26,050 --> 00:02:30,280
and billions of requests per month so

00:02:28,390 --> 00:02:33,670
your website is going to be fun using

00:02:30,280 --> 00:02:35,620
Python so python is usually fast enough

00:02:33,670 --> 00:02:37,960
but what if you decide that it's not

00:02:35,620 --> 00:02:39,820
fast enough anymore for example your

00:02:37,960 --> 00:02:41,980
website starts giving you time outs or

00:02:39,820 --> 00:02:43,960
maybe a faster code will bring more

00:02:41,980 --> 00:02:46,720
money if your company so it's time for

00:02:43,960 --> 00:02:49,240
optimization but how do you optimize the

00:02:46,720 --> 00:02:50,680
code but probably need to follow some

00:02:49,240 --> 00:02:53,500
rules so let's try to Google for that

00:02:50,680 --> 00:02:55,420
and if we open the first thing we see

00:02:53,500 --> 00:02:57,670
that there are only three rules Wow

00:02:55,420 --> 00:02:59,610
it's gonna be easier than we expected so

00:02:57,670 --> 00:03:02,530
let's take a closer look at those rules

00:02:59,610 --> 00:03:06,310
first rule of optimization done don't

00:03:02,530 --> 00:03:07,990
okay that was easy any questions but

00:03:06,310 --> 00:03:10,750
actually now there is more to that so

00:03:07,990 --> 00:03:12,940
what does it mean don't well nine out of

00:03:10,750 --> 00:03:15,400
ten times when you think that you need

00:03:12,940 --> 00:03:17,620
optimization you don't especially in the

00:03:15,400 --> 00:03:19,000
early stage of your products life you

00:03:17,620 --> 00:03:21,250
might think it would be nice to optimize

00:03:19,000 --> 00:03:23,050
your code a bit but well first of all

00:03:21,250 --> 00:03:26,110
you will waste time doing something that

00:03:23,050 --> 00:03:28,030
is probably not needed if you want your

00:03:26,110 --> 00:03:29,590
code to run faster you can started

00:03:28,030 --> 00:03:32,320
getting a faster hardware in the first

00:03:29,590 --> 00:03:33,280
place and second of all optimization

00:03:32,320 --> 00:03:36,040
comes with a cost

00:03:33,280 --> 00:03:38,430
most often the only cost is the time

00:03:36,040 --> 00:03:40,810
that you spend optimizing your code or

00:03:38,430 --> 00:03:42,459
sometimes you it's also the time that

00:03:40,810 --> 00:03:45,519
you need to fix what you just broke with

00:03:42,459 --> 00:03:47,170
your optimization but also optimize it

00:03:45,519 --> 00:03:48,910
the optimized code might not be as

00:03:47,170 --> 00:03:51,070
readable as it was in the first place

00:03:48,910 --> 00:03:53,739
and maybe your code is running faster

00:03:51,070 --> 00:03:55,239
but is now using more memory so unless

00:03:53,739 --> 00:03:57,820
you have really good reasons to optimize

00:03:55,239 --> 00:04:00,100
don't do this and if you know that you

00:03:57,820 --> 00:04:02,459
have reasons to optimize then we can

00:04:00,100 --> 00:04:05,920
move the second rule of optimization

00:04:02,459 --> 00:04:08,980
don't do this yet and this is how I

00:04:05,920 --> 00:04:12,040
understand this rule so first make sure

00:04:08,980 --> 00:04:14,320
your code works then make sure you have

00:04:12,040 --> 00:04:16,720
a good test suit and only then you're

00:04:14,320 --> 00:04:18,519
ready for optimization I love this rule

00:04:16,720 --> 00:04:21,430
it always reminds me how many time I

00:04:18,519 --> 00:04:23,470
broke it I mean so many times I was

00:04:21,430 --> 00:04:26,110
working on a piece of software and I

00:04:23,470 --> 00:04:27,620
started thinking HM maybe I can change

00:04:26,110 --> 00:04:29,900
this piece of code and it

00:04:27,620 --> 00:04:31,970
we'll be faster and maybe I will save

00:04:29,900 --> 00:04:32,949
like two lines of code was it a good

00:04:31,970 --> 00:04:36,050
idea

00:04:32,949 --> 00:04:38,750
no and not only because I ended up

00:04:36,050 --> 00:04:40,940
breaking things but most often I did end

00:04:38,750 --> 00:04:43,070
up breaking things but also I started

00:04:40,940 --> 00:04:44,660
jumping around the code and at some

00:04:43,070 --> 00:04:47,419
point I get confused what I was writing

00:04:44,660 --> 00:04:50,330
in the first place did it make my code

00:04:47,419 --> 00:04:51,740
faster I have no idea because I had

00:04:50,330 --> 00:04:54,080
nothing to compare it to in the first

00:04:51,740 --> 00:04:56,660
place if I would finish writing the code

00:04:54,080 --> 00:04:58,970
and then try to improve it I could

00:04:56,660 --> 00:05:01,850
measure both solutions and compare them

00:04:58,970 --> 00:05:03,800
but in that in that scenario I could

00:05:01,850 --> 00:05:06,919
only guess and that brings me to the

00:05:03,800 --> 00:05:09,260
last rule of optimization don't guess

00:05:06,919 --> 00:05:11,030
always profile your code human and are

00:05:09,260 --> 00:05:14,780
terrible in predicting the bottlenecks

00:05:11,030 --> 00:05:17,419
of your code so if you think that your

00:05:14,780 --> 00:05:19,729
code is slow first profile it and then

00:05:17,419 --> 00:05:22,910
see what part of it takes most of the

00:05:19,729 --> 00:05:25,940
time otherwise you might up you may end

00:05:22,910 --> 00:05:28,430
up spending time rewriting one piece of

00:05:25,940 --> 00:05:30,500
your code you just get like 1% of speed

00:05:28,430 --> 00:05:32,780
improvement well there are other parts

00:05:30,500 --> 00:05:37,010
of your software where you can gain way

00:05:32,780 --> 00:05:38,419
more improvement with less effort so

00:05:37,010 --> 00:05:40,130
there are plenty of profiling tools they

00:05:38,419 --> 00:05:42,020
were already quite a few talks during

00:05:40,130 --> 00:05:43,970
Euro fight on about profiling so I will

00:05:42,020 --> 00:05:45,320
not go into the details but if you don't

00:05:43,970 --> 00:05:47,870
know where to start you can take a look

00:05:45,320 --> 00:05:50,240
at the C profile module and it will show

00:05:47,870 --> 00:05:51,919
you a clear overview of how many times

00:05:50,240 --> 00:05:54,470
each function is called and when the

00:05:51,919 --> 00:05:56,750
code and where the code is spent and if

00:05:54,470 --> 00:05:58,190
you want to have some more advanced

00:05:56,750 --> 00:06:00,349
formatting you can add the pistils

00:05:58,190 --> 00:06:02,000
module also if you prefer the graphic

00:06:00,349 --> 00:06:05,960
interface you can take a look at the run

00:06:02,000 --> 00:06:07,580
snake run or snake these libraries so

00:06:05,960 --> 00:06:09,139
once we're ready for optimization we

00:06:07,580 --> 00:06:10,880
have to decide on which area we want to

00:06:09,139 --> 00:06:13,370
focus so there are different levels of

00:06:10,880 --> 00:06:14,570
optimization starting from the highest

00:06:13,370 --> 00:06:17,360
level you have the design level

00:06:14,570 --> 00:06:18,889
optimization so depending on the

00:06:17,360 --> 00:06:20,750
constraints and priorities of your

00:06:18,889 --> 00:06:23,539
system you can optimize it by

00:06:20,750 --> 00:06:25,070
redesigning it in my require rewriting

00:06:23,539 --> 00:06:27,289
your software in a different programming

00:06:25,070 --> 00:06:29,360
language or changing the database table

00:06:27,289 --> 00:06:32,210
or changing the architecture to perform

00:06:29,360 --> 00:06:33,919
less database queries so this kind of

00:06:32,210 --> 00:06:36,050
optimization will usually give it the

00:06:33,919 --> 00:06:38,930
best improvement but it also takes most

00:06:36,050 --> 00:06:40,640
time to do this so I don't encourage you

00:06:38,930 --> 00:06:41,600
to rewrite your software from the

00:06:40,640 --> 00:06:43,160
scratch but if

00:06:41,600 --> 00:06:45,920
have some critical parts of your code

00:06:43,160 --> 00:06:48,190
that are run often you can optimize them

00:06:45,920 --> 00:06:50,840
but by rewriting them in C or C++

00:06:48,190 --> 00:06:53,180
because C is faster you'll have some

00:06:50,840 --> 00:06:54,800
good speed improvement for free well not

00:06:53,180 --> 00:07:00,950
really for free now you'll have Python

00:06:54,800 --> 00:07:02,990
and C code in the same project so one

00:07:00,950 --> 00:07:05,450
level lower we have algorithm algorithms

00:07:02,990 --> 00:07:06,770
and data structures so now in good

00:07:05,450 --> 00:07:09,980
algorithms together with their

00:07:06,770 --> 00:07:12,100
complexity is a definitely helps you

00:07:09,980 --> 00:07:14,750
creating a good and efficient software

00:07:12,100 --> 00:07:17,660
for example if you want to get the sum

00:07:14,750 --> 00:07:19,070
of numbers from 1 to n the first idea

00:07:17,660 --> 00:07:20,750
might be to get a loop that goes through

00:07:19,070 --> 00:07:23,750
all the elements and ask them now it

00:07:20,750 --> 00:07:24,890
will work but it won't be fast instead

00:07:23,750 --> 00:07:26,900
you can use the algorithm for the

00:07:24,890 --> 00:07:28,820
arithmetic arithmetic sum which will

00:07:26,900 --> 00:07:32,150
give it the same results and it will not

00:07:28,820 --> 00:07:34,100
it will be more efficient so the next

00:07:32,150 --> 00:07:35,750
level is the source code optimization

00:07:34,100 --> 00:07:36,860
and this is something that I will talk

00:07:35,750 --> 00:07:39,710
about in the second part of the

00:07:36,860 --> 00:07:41,360
presentation and now we're moving to the

00:07:39,710 --> 00:07:44,750
build level which involves setting up

00:07:41,360 --> 00:07:46,280
some specific build flags so in your

00:07:44,750 --> 00:07:48,830
daily work it's not something that you

00:07:46,280 --> 00:07:50,420
will do often you can optimize Python

00:07:48,830 --> 00:07:52,670
for a specific architecture but if

00:07:50,420 --> 00:07:54,080
you're a web developer like me this is

00:07:52,670 --> 00:07:56,230
either something that you will do once

00:07:54,080 --> 00:07:58,700
per machine or you won't bother at all

00:07:56,230 --> 00:08:00,590
next we have the compiler level so we

00:07:58,700 --> 00:08:02,450
can make some optimizations if your

00:08:00,590 --> 00:08:05,240
program has if your programming language

00:08:02,450 --> 00:08:06,740
has a head of time compiler and since

00:08:05,240 --> 00:08:08,150
I'm talking about C Python day which

00:08:06,740 --> 00:08:10,310
doesn't really have a head of time

00:08:08,150 --> 00:08:13,370
compiler we're gonna skip that part as

00:08:10,310 --> 00:08:16,400
well and not last but not least we have

00:08:13,370 --> 00:08:18,140
the runtime level so it's related with a

00:08:16,400 --> 00:08:19,850
specific compiler that you're using some

00:08:18,140 --> 00:08:21,890
some compilers are faster than the

00:08:19,850 --> 00:08:23,810
others so for example if you replace c

00:08:21,890 --> 00:08:26,180
python with pi pi you can get some

00:08:23,810 --> 00:08:29,690
improvements depending on the use case

00:08:26,180 --> 00:08:31,820
of your software so but it really

00:08:29,690 --> 00:08:34,070
depends on what kind of piece of code

00:08:31,820 --> 00:08:35,360
you're writing so most of the time once

00:08:34,070 --> 00:08:37,400
you set up on a specific language

00:08:35,360 --> 00:08:38,810
implementation there is nothing you have

00:08:37,400 --> 00:08:41,000
to do to benefit from this kind of

00:08:38,810 --> 00:08:42,830
optimization it's usually up to the

00:08:41,000 --> 00:08:45,290
creators of the compilers to optimize

00:08:42,830 --> 00:08:46,910
them so simply update into the new Pro

00:08:45,290 --> 00:08:48,620
new version of the programming language

00:08:46,910 --> 00:08:52,250
you're using can make your code run a

00:08:48,620 --> 00:08:54,360
bit faster so when you optimize you

00:08:52,250 --> 00:08:59,549
probably want your code to run faster

00:08:54,360 --> 00:09:02,489
and also use less memory and basically

00:08:59,549 --> 00:09:04,679
less of everything the bad news is you

00:09:02,489 --> 00:09:06,269
can't have all of it optimization in

00:09:04,679 --> 00:09:08,850
what Andrea will usually cause

00:09:06,269 --> 00:09:10,769
deterioration in other areas so you

00:09:08,850 --> 00:09:13,949
always have to decide which resources

00:09:10,769 --> 00:09:16,199
are crucial and you have to optimize in

00:09:13,949 --> 00:09:18,119
that direction so it's possible that

00:09:16,199 --> 00:09:19,889
optimization will have nothing to do

00:09:18,119 --> 00:09:21,629
with the speed because there are other

00:09:19,889 --> 00:09:24,350
resources more important than their own

00:09:21,629 --> 00:09:27,089
speed for example who cares that your

00:09:24,350 --> 00:09:28,799
program is now 10 times faster when it's

00:09:27,089 --> 00:09:33,329
crashing half of the time because RAC is

00:09:28,799 --> 00:09:35,040
running out of memory also another

00:09:33,329 --> 00:09:37,799
important resource that people are often

00:09:35,040 --> 00:09:39,149
forgetting is the sanity a sanity of a

00:09:37,799 --> 00:09:41,129
person that will be maintaining your

00:09:39,149 --> 00:09:43,999
code so please be nice to that person

00:09:41,129 --> 00:09:46,799
you never know who that might be

00:09:43,999 --> 00:09:48,480
yeah so unless you're really writing a

00:09:46,799 --> 00:09:51,239
throwaway code if you're making your

00:09:48,480 --> 00:09:53,749
code harder to read and maintain then

00:09:51,239 --> 00:09:56,339
you're probably doing it wrong

00:09:53,749 --> 00:09:57,689
so having those things clear let's jump

00:09:56,339 --> 00:09:59,279
straight to how you can write faster

00:09:57,689 --> 00:10:05,999
Python also known as source code

00:09:59,279 --> 00:10:10,169
optimization my examples I'm using the

00:10:05,999 --> 00:10:10,949
version 3.5 point 1 of Python together

00:10:10,169 --> 00:10:12,480
with ipython

00:10:10,949 --> 00:10:15,149
although the example should work in both

00:10:12,480 --> 00:10:16,829
Python 2 and 5 and 3 so mention for

00:10:15,149 --> 00:10:18,509
measuring the execution time of my code

00:10:16,829 --> 00:10:21,029
I will be using the magic timing

00:10:18,509 --> 00:10:23,100
function it has some overhead comparing

00:10:21,029 --> 00:10:24,899
to the standard time in library but it

00:10:23,100 --> 00:10:27,029
doesn't really matter because as long as

00:10:24,899 --> 00:10:29,399
we use the same method to measure

00:10:27,029 --> 00:10:30,839
execution time of different functions we

00:10:29,399 --> 00:10:33,360
only need to know which method is fast

00:10:30,839 --> 00:10:35,819
and and by how much so for each of my

00:10:33,360 --> 00:10:37,739
examples I will write different versions

00:10:35,819 --> 00:10:41,009
of code measure the execution time and

00:10:37,739 --> 00:10:43,769
compare them so let's start with

00:10:41,009 --> 00:10:45,449
something simple let's say you want to

00:10:43,769 --> 00:10:47,669
count the number of elements in a list

00:10:45,449 --> 00:10:49,980
you can easily write a simple loop that

00:10:47,669 --> 00:10:52,799
will increment the counter and well this

00:10:49,980 --> 00:10:54,239
will work it will be very soon you can

00:10:52,799 --> 00:10:56,399
achieve the same results using the

00:10:54,239 --> 00:10:58,110
built-in Len function and as you can see

00:10:56,399 --> 00:11:00,569
for only one minion of results the

00:10:58,110 --> 00:11:03,119
difference is insanely huge so my first

00:11:00,569 --> 00:11:04,499
advice is not to reinvent the wheel but

00:11:03,119 --> 00:11:07,740
first check if there is a function that

00:11:04,499 --> 00:11:10,140
you can use right on 3.5 has 60

00:11:07,740 --> 00:11:11,700
building functions so it's nice to take

00:11:10,140 --> 00:11:13,860
a look at them and keep them in the back

00:11:11,700 --> 00:11:16,350
of your head because they might be handy

00:11:13,860 --> 00:11:17,910
at some point also before we start

00:11:16,350 --> 00:11:19,920
writing around version of order

00:11:17,910 --> 00:11:21,990
dictionary or a dictionary with default

00:11:19,920 --> 00:11:24,210
values take a look at the collection

00:11:21,990 --> 00:11:26,120
module from the standard library even

00:11:24,210 --> 00:11:28,620
though it contains only like ten

00:11:26,120 --> 00:11:30,960
different data types those are probably

00:11:28,620 --> 00:11:34,980
d datatypes you are looking for if the

00:11:30,960 --> 00:11:36,570
standard ones are not enough so let's

00:11:34,980 --> 00:11:38,700
say you have a list of 1 million

00:11:36,570 --> 00:11:41,310
elements and you want to select only the

00:11:38,700 --> 00:11:43,050
odd numbers so the night version would

00:11:41,310 --> 00:11:44,940
be to use the for loop so for each

00:11:43,050 --> 00:11:46,560
element of the list you check if it's

00:11:44,940 --> 00:11:49,350
odd and if it is you add it to another

00:11:46,560 --> 00:11:51,720
list but I already show you in the

00:11:49,350 --> 00:11:53,100
previous example that in most cases for

00:11:51,720 --> 00:11:53,460
loops can be replaced with something

00:11:53,100 --> 00:11:56,250
better

00:11:53,460 --> 00:11:59,940
in this case you could use the built-in

00:11:56,250 --> 00:12:01,440
filter function instead and in Python

00:11:59,940 --> 00:12:03,360
tool filter was returning a list

00:12:01,440 --> 00:12:05,250
directly in Python trees returning an

00:12:03,360 --> 00:12:07,320
iterator so I have to call the list

00:12:05,250 --> 00:12:10,470
function to get the same results as in

00:12:07,320 --> 00:12:13,170
case of the for loop and even though the

00:12:10,470 --> 00:12:15,300
list function has some impact on the

00:12:13,170 --> 00:12:16,770
performance it's negligible comparing to

00:12:15,300 --> 00:12:19,380
the time spent in the filter function

00:12:16,770 --> 00:12:22,260
yet you can see that filter performs

00:12:19,380 --> 00:12:22,920
even slower than the for loop why does

00:12:22,260 --> 00:12:24,480
this happen

00:12:22,920 --> 00:12:26,370
well the fact that filter is returning

00:12:24,480 --> 00:12:28,680
now an iterator is a clear sign that

00:12:26,370 --> 00:12:32,310
it's a wrong use case for this kind of

00:12:28,680 --> 00:12:34,650
function so if you want to get the whole

00:12:32,310 --> 00:12:37,590
list as a result it's better to use the

00:12:34,650 --> 00:12:40,050
list comprehension it's around 75% times

00:12:37,590 --> 00:12:43,370
faster than the for loop and at this for

00:12:40,050 --> 00:12:43,370
me it looks more clear

00:12:46,370 --> 00:12:50,269
when you want to execute a piece of code

00:12:48,110 --> 00:12:52,639
but you are not sure if it will be

00:12:50,269 --> 00:12:54,769
successful maybe some variables are not

00:12:52,639 --> 00:12:57,110
said or like in this case the class

00:12:54,769 --> 00:12:58,639
might be missing some attribute so you

00:12:57,110 --> 00:13:00,379
want to protect yourself somehow

00:12:58,639 --> 00:13:02,029
the first way you can do this is called

00:13:00,379 --> 00:13:05,029
look before you leap or ask for

00:13:02,029 --> 00:13:06,740
permissions what it means is that you

00:13:05,029 --> 00:13:08,480
first check if the class has a specific

00:13:06,740 --> 00:13:10,910
attribute and then you perform the

00:13:08,480 --> 00:13:13,339
operations usually this checking is done

00:13:10,910 --> 00:13:14,509
with the if statement however there is

00:13:13,339 --> 00:13:16,579
different approach that you could use

00:13:14,509 --> 00:13:19,009
and it's called beg for forgiveness

00:13:16,579 --> 00:13:20,449
so in this scenario you perform the

00:13:19,009 --> 00:13:23,029
operation without checking the

00:13:20,449 --> 00:13:24,860
conditions first but in case your ex

00:13:23,029 --> 00:13:27,290
your expect that something might break

00:13:24,860 --> 00:13:28,790
you wrap your code in a try except block

00:13:27,290 --> 00:13:30,889
and you catch the exceptions that were

00:13:28,790 --> 00:13:32,720
raised and as you can see in the simple

00:13:30,889 --> 00:13:35,899
example begging for forgiveness is like

00:13:32,720 --> 00:13:37,040
three times faster but it gets even

00:13:35,899 --> 00:13:39,199
better if you're checking for more

00:13:37,040 --> 00:13:41,809
conditions so here we are checking if

00:13:39,199 --> 00:13:44,209
three up tributes are present and asking

00:13:41,809 --> 00:13:45,889
for permission is still slower and now

00:13:44,209 --> 00:13:47,779
it's also getting more difficult to read

00:13:45,889 --> 00:13:50,569
so following the beg for forgiveness

00:13:47,779 --> 00:13:52,660
approach will result in a faster and

00:13:50,569 --> 00:13:54,709
more readable code so we could say that

00:13:52,660 --> 00:13:56,089
asking for forgiveness instead of

00:13:54,709 --> 00:13:59,329
checking the permissions is always a

00:13:56,089 --> 00:14:01,160
better way but we won't side up because

00:13:59,329 --> 00:14:03,410
it's not true exception handling is

00:14:01,160 --> 00:14:05,779
still quite expensive so if the

00:14:03,410 --> 00:14:07,339
attribute is actually missing then

00:14:05,779 --> 00:14:10,309
begging for forgiveness will be slower

00:14:07,339 --> 00:14:12,079
than asking for permissions so as a rule

00:14:10,309 --> 00:14:14,209
of thumb you can use the ask for

00:14:12,079 --> 00:14:16,040
permissions way if you know that it's

00:14:14,209 --> 00:14:17,660
very likely that that the attribute will

00:14:16,040 --> 00:14:19,879
be missing or there will be some other

00:14:17,660 --> 00:14:21,439
problems that you can predict otherwise

00:14:19,879 --> 00:14:24,170
if you're expecting that your code will

00:14:21,439 --> 00:14:27,019
work in most of the times try using

00:14:24,170 --> 00:14:30,019
using try except will result in a faster

00:14:27,019 --> 00:14:31,189
and quite often more readable code so

00:14:30,019 --> 00:14:33,050
for example if you're fetching some

00:14:31,189 --> 00:14:34,490
files from the internet and you expect

00:14:33,050 --> 00:14:36,470
that everything will be fine unless

00:14:34,490 --> 00:14:38,059
there is no internet connection so

00:14:36,470 --> 00:14:39,620
instead of checking if there is internet

00:14:38,059 --> 00:14:41,179
connection if it's fast enough if there

00:14:39,620 --> 00:14:43,850
are no timeouts just go for the try

00:14:41,179 --> 00:14:45,559
accept but then again I strongly advise

00:14:43,850 --> 00:14:47,980
you to measure both solutions and see

00:14:45,559 --> 00:14:50,360
maybe in your case it will be different

00:14:47,980 --> 00:14:53,449
so let's tackle another problem the

00:14:50,360 --> 00:14:55,670
membership testing so if you have a list

00:14:53,449 --> 00:14:57,790
and you want to check if it contains a

00:14:55,670 --> 00:14:59,590
specific element you can use it for loop

00:14:57,790 --> 00:15:01,270
but the problem is

00:14:59,590 --> 00:15:02,830
you are iterating over the whole list

00:15:01,270 --> 00:15:06,130
even though you're not really doing

00:15:02,830 --> 00:15:07,810
anything with all those elements so you

00:15:06,130 --> 00:15:09,850
can replace the for loop with the in

00:15:07,810 --> 00:15:11,680
statement it will check that specific

00:15:09,850 --> 00:15:15,610
element belongs to a given set of data

00:15:11,680 --> 00:15:17,050
and it will do this twice as fast but

00:15:15,610 --> 00:15:19,450
there is still one big problem with this

00:15:17,050 --> 00:15:21,070
approach the lookup time depends on

00:15:19,450 --> 00:15:22,840
where your element is located in that

00:15:21,070 --> 00:15:23,230
list if it's at the beginning of the

00:15:22,840 --> 00:15:25,210
list

00:15:23,230 --> 00:15:27,190
you're lucky and you will get it fast if

00:15:25,210 --> 00:15:29,830
it's at the end of the list you have to

00:15:27,190 --> 00:15:31,390
wait so what would be really nice here

00:15:29,830 --> 00:15:33,100
if we had a data structure that would

00:15:31,390 --> 00:15:34,900
have a constant lookup time and actually

00:15:33,100 --> 00:15:37,450
in fact when we have we have both sets

00:15:34,900 --> 00:15:40,810
and a dictionary that have constant

00:15:37,450 --> 00:15:43,750
lookup time so if we replace the list

00:15:40,810 --> 00:15:46,060
with a set then the lookup time becomes

00:15:43,750 --> 00:15:48,910
faster from just two times faster to

00:15:46,060 --> 00:15:51,760
hundreds of thousand times faster so

00:15:48,910 --> 00:15:53,590
where is the catch well you pay some

00:15:51,760 --> 00:15:55,690
time to convert this to a set and in

00:15:53,590 --> 00:15:58,000
this scenario converting this list to a

00:15:55,690 --> 00:15:59,410
set takes more time than any of the

00:15:58,000 --> 00:16:01,570
lookups in that list so it doesn't

00:15:59,410 --> 00:16:03,940
really make sense however if you're

00:16:01,570 --> 00:16:06,490
checking membership of different

00:16:03,940 --> 00:16:10,390
elements quite often it makes sense to

00:16:06,490 --> 00:16:11,440
first convert it to a set so speaking of

00:16:10,390 --> 00:16:13,770
sets they have another interesting

00:16:11,440 --> 00:16:15,850
feature they don't contain duplicates so

00:16:13,770 --> 00:16:17,800
basically if you have a list of elements

00:16:15,850 --> 00:16:19,750
and you want to remove the duplicates

00:16:17,800 --> 00:16:22,510
the fastest way to do this is to convert

00:16:19,750 --> 00:16:25,330
this list to a set but be aware that

00:16:22,510 --> 00:16:27,100
sets are not are not ordered so if you

00:16:25,330 --> 00:16:28,630
need to preserve the order take a look

00:16:27,100 --> 00:16:33,490
at the order dictionary from the

00:16:28,630 --> 00:16:35,680
collection module so if you want to sort

00:16:33,490 --> 00:16:38,860
the list you can either do this in place

00:16:35,680 --> 00:16:40,390
using the list of sort function or you

00:16:38,860 --> 00:16:42,730
can call the sorted function that will

00:16:40,390 --> 00:16:44,770
create a new list and unless you really

00:16:42,730 --> 00:16:46,840
need to have a new list sorting in place

00:16:44,770 --> 00:16:49,990
will be like six times faster in this

00:16:46,840 --> 00:16:54,130
scenario this is for 1 million of random

00:16:49,990 --> 00:16:56,830
numbers if you want to perform the same

00:16:54,130 --> 00:16:58,530
operation on a large set of data then

00:16:56,830 --> 00:17:01,180
you have two options

00:16:58,530 --> 00:17:03,060
you can write a function that performs

00:17:01,180 --> 00:17:06,250
the operation and call this function

00:17:03,060 --> 00:17:08,320
1,000 times or you can call a function

00:17:06,250 --> 00:17:11,170
that takes this set of data and performs

00:17:08,320 --> 00:17:12,910
the operation inside and the second

00:17:11,170 --> 00:17:15,579
approach will be faster so

00:17:12,910 --> 00:17:17,530
if you can in an easy way replace

00:17:15,579 --> 00:17:19,930
multiple calls to one function with just

00:17:17,530 --> 00:17:23,589
one function then quite often it's a

00:17:19,930 --> 00:17:25,360
good idea so what's the best way to

00:17:23,589 --> 00:17:27,940
check if a variable expression is true

00:17:25,360 --> 00:17:30,010
well you can explicitly compare this

00:17:27,940 --> 00:17:32,410
variable to true but in most cases

00:17:30,010 --> 00:17:34,780
you're adding additional redundancy so

00:17:32,410 --> 00:17:37,840
you can simplify your condition to just

00:17:34,780 --> 00:17:40,660
if variable and it will return true

00:17:37,840 --> 00:17:42,940
unless the variable is false nonzero

00:17:40,660 --> 00:17:44,830
empty string empty list or other false e

00:17:42,940 --> 00:17:48,030
expression and by doing that your

00:17:44,830 --> 00:17:50,230
comparison get faster by like 70% and

00:17:48,030 --> 00:17:52,480
the same rule applies when checking for

00:17:50,230 --> 00:17:55,810
false so the fastest way to do this is

00:17:52,480 --> 00:17:58,660
to use if not variable unless you really

00:17:55,810 --> 00:18:02,380
need to distinguish false from let's say

00:17:58,660 --> 00:18:05,490
non or zero or other false e values it

00:18:02,380 --> 00:18:09,460
also applies to empty data structures so

00:18:05,490 --> 00:18:11,170
simply doing if not a list is will be

00:18:09,460 --> 00:18:15,180
almost three times faster than

00:18:11,170 --> 00:18:15,180
explicitly checking the length of a list

00:18:17,220 --> 00:18:21,880
so let's take a look at different ways

00:18:19,360 --> 00:18:23,410
of defining functions in Python the most

00:18:21,880 --> 00:18:24,970
common one is to create a function with

00:18:23,410 --> 00:18:27,340
that keyword

00:18:24,970 --> 00:18:29,110
the other way is to declare an anonymous

00:18:27,340 --> 00:18:31,090
function with lambda if you assign this

00:18:29,110 --> 00:18:32,830
lambda to a variable it will act in the

00:18:31,090 --> 00:18:35,500
same way as a function created with the

00:18:32,830 --> 00:18:36,970
DEF keyword and as you can see they are

00:18:35,500 --> 00:18:39,850
both equally fast

00:18:36,970 --> 00:18:42,580
why because both versions do exactly the

00:18:39,850 --> 00:18:44,320
same thing we can disassemble the code

00:18:42,580 --> 00:18:46,660
of both versions with the dis library

00:18:44,320 --> 00:18:49,480
and we will see that inside is the same

00:18:46,660 --> 00:18:51,370
code so is there any difference well if

00:18:49,480 --> 00:18:53,500
your function has more than one line you

00:18:51,370 --> 00:18:56,230
can use lambda and you can't really put

00:18:53,500 --> 00:18:57,820
documentation inside of lambda also you

00:18:56,230 --> 00:18:59,710
could have peptide enabled in your code

00:18:57,820 --> 00:19:01,830
editor it will complain each time you

00:18:59,710 --> 00:19:05,560
try to assign lambda to a variable and

00:19:01,830 --> 00:19:07,060
in his write that does work really nice

00:19:05,560 --> 00:19:08,980
when you need a simple one-liner

00:19:07,060 --> 00:19:10,600
callback for your functions especially

00:19:08,980 --> 00:19:13,690
for functions like filter Babel reduce

00:19:10,600 --> 00:19:15,730
and there also some quite a few narrow

00:19:13,690 --> 00:19:17,440
use cases where it might be necessary to

00:19:15,730 --> 00:19:18,640
use lambda as a callback so if you want

00:19:17,440 --> 00:19:22,270
to read more you can check the link at

00:19:18,640 --> 00:19:24,580
the bottom but however in any other case

00:19:22,270 --> 00:19:26,350
I would definitely recommend to use that

00:19:24,580 --> 00:19:28,480
it's much cleaner you can

00:19:26,350 --> 00:19:32,410
documented properly and the performance

00:19:28,480 --> 00:19:35,260
is exactly the same so there are toys

00:19:32,410 --> 00:19:36,880
how you can create a name to this so you

00:19:35,260 --> 00:19:38,919
can either color this function or you

00:19:36,880 --> 00:19:41,140
can just use the list literal syntax and

00:19:38,919 --> 00:19:43,630
as you can see the literal syntax is

00:19:41,140 --> 00:19:45,370
faster why is it faster because if you

00:19:43,630 --> 00:19:47,470
call a function fightin first need to

00:19:45,370 --> 00:19:49,450
resolve this function and with the

00:19:47,470 --> 00:19:52,480
literal syntax there is no overhead for

00:19:49,450 --> 00:19:58,900
that and exact same thing happens for

00:19:52,480 --> 00:19:59,950
creating a dictionary okay I have two

00:19:58,900 --> 00:20:02,679
more examples that should be treated

00:19:59,950 --> 00:20:05,200
with caution even though the code can

00:20:02,679 --> 00:20:07,570
run faster I would not advise you to do

00:20:05,200 --> 00:20:08,919
this kind of optimization so sometimes

00:20:07,570 --> 00:20:12,280
even though you can squeeze some

00:20:08,919 --> 00:20:16,750
additional performance from your code it

00:20:12,280 --> 00:20:20,620
doesn't mean that you should do this so

00:20:16,750 --> 00:20:21,970
one thing is a variable assignment if

00:20:20,620 --> 00:20:23,860
you have a bunch of variables that you

00:20:21,970 --> 00:20:26,140
need to assign you can do this the

00:20:23,860 --> 00:20:28,929
normal sequential way or you can go for

00:20:26,140 --> 00:20:31,570
this crazy parallel assignment and I

00:20:28,929 --> 00:20:33,190
mean you can gain some speed but with

00:20:31,570 --> 00:20:34,570
this speed comes the head of your

00:20:33,190 --> 00:20:37,690
colleagues that will be reading this

00:20:34,570 --> 00:20:41,470
code later so in my opinion isn't worth

00:20:37,690 --> 00:20:43,690
it ok and another interesting property

00:20:41,470 --> 00:20:45,909
of Python is that the lookup for local

00:20:43,690 --> 00:20:48,460
variables is faster than the lookup for

00:20:45,909 --> 00:20:50,380
Global's or buildings so you can say

00:20:48,460 --> 00:20:51,850
save some time if you store the

00:20:50,380 --> 00:20:54,030
reference to a building function or a

00:20:51,850 --> 00:20:56,799
global function in a local variable so

00:20:54,030 --> 00:20:58,600
in this example the only difference is

00:20:56,799 --> 00:21:00,429
on the line 3 where I'm storing the

00:20:58,600 --> 00:21:04,780
reference to the global append in a

00:21:00,429 --> 00:21:07,240
local append variable and thanks to that

00:21:04,780 --> 00:21:08,710
this function is like 35% faster but

00:21:07,240 --> 00:21:11,559
then again if you see this code for the

00:21:08,710 --> 00:21:14,080
first time it's not very clear what it

00:21:11,559 --> 00:21:15,580
is what it is supposed to do it might be

00:21:14,080 --> 00:21:17,860
confusing to see this kind of append

00:21:15,580 --> 00:21:23,020
function because we are most more used

00:21:17,860 --> 00:21:25,030
to see the list dot append version to

00:21:23,020 --> 00:21:27,130
sum up there are different time kind of

00:21:25,030 --> 00:21:30,010
optimization it's quite often about the

00:21:27,130 --> 00:21:32,490
speed but not always and there are also

00:21:30,010 --> 00:21:34,750
different levels of optimization so

00:21:32,490 --> 00:21:36,850
sometimes if you cannot rewrite your

00:21:34,750 --> 00:21:39,520
whole application maybe you can use a

00:21:36,850 --> 00:21:40,210
different approach and even though the

00:21:39,520 --> 00:21:42,910
source code

00:21:40,210 --> 00:21:45,010
my zation it's not the fastest way to

00:21:42,910 --> 00:21:46,870
optimize your code those small

00:21:45,010 --> 00:21:50,410
improvements will add up and the main

00:21:46,870 --> 00:21:53,350
advantage of it is cheap so you can

00:21:50,410 --> 00:21:54,610
write you can optimize the code at the

00:21:53,350 --> 00:21:57,610
moment of writing you don't really need

00:21:54,610 --> 00:21:59,830
to rewrite something and as long as

00:21:57,610 --> 00:22:01,840
you're writing idiomatic code and you

00:21:59,830 --> 00:22:03,850
don't reinvent the wheel but already use

00:22:01,840 --> 00:22:05,680
the existing functions and data

00:22:03,850 --> 00:22:09,430
structures in Python then you're already

00:22:05,680 --> 00:22:10,870
doing it correctly so be curious when

00:22:09,430 --> 00:22:13,530
you're coding if you think that the

00:22:10,870 --> 00:22:15,850
different code structure can be faster

00:22:13,530 --> 00:22:19,330
you can quickly check it with the time

00:22:15,850 --> 00:22:20,620
it and then you can improve it alright

00:22:19,330 --> 00:22:22,450
my name is sebastian vettel ski and I

00:22:20,620 --> 00:22:24,280
work at Sun so if you guys want to talk

00:22:22,450 --> 00:22:26,590
about physics then you're probably on

00:22:24,280 --> 00:22:27,910
the wrong conference but if you want to

00:22:26,590 --> 00:22:31,530
talk about Python you can catch me

00:22:27,910 --> 00:22:31,530
somewhere on the courier thank

00:22:41,310 --> 00:22:44,950
two minutes for questions especially if

00:22:43,990 --> 00:22:47,170
you're happy to take one or two

00:22:44,950 --> 00:22:52,420
questions shall we have them fantastic

00:22:47,170 --> 00:22:55,000
who's got a question user awesome talk I

00:22:52,420 --> 00:22:57,520
have a quick question use you should

00:22:55,000 --> 00:22:59,440
have some profilers cool profilers do

00:22:57,520 --> 00:23:04,900
you have any preference every any

00:22:59,440 --> 00:23:07,150
favorite it really depends what you want

00:23:04,900 --> 00:23:09,220
to profile because if you care about the

00:23:07,150 --> 00:23:11,200
speed then the basic ones are fine but

00:23:09,220 --> 00:23:12,400
if you want to profile the memory usage

00:23:11,200 --> 00:23:14,500
then you might need to use different

00:23:12,400 --> 00:23:18,010
profiler so it really depends what do

00:23:14,500 --> 00:23:25,210
you want to profile any other questions

00:23:18,010 --> 00:23:27,190
yeah any good recommendation on books or

00:23:25,210 --> 00:23:29,370
source where we can find the best

00:23:27,190 --> 00:23:34,300
practices regarding this idiomatic

00:23:29,370 --> 00:23:38,320
Python and not from the top of my head

00:23:34,300 --> 00:23:40,870
but well definitely there is some guides

00:23:38,320 --> 00:23:44,290
on the official Python documentation but

00:23:40,870 --> 00:23:45,820
also for me it's a lot of googling for

00:23:44,290 --> 00:23:48,100
best practices also reading a lot of

00:23:45,820 --> 00:23:51,120
Stack Overflow there are some books but

00:23:48,100 --> 00:23:56,050
I can't give you the names right now

00:23:51,120 --> 00:23:57,310
more questions - yes Oh was that you

00:23:56,050 --> 00:23:59,830
sticking your hand up sir or just

00:23:57,310 --> 00:24:01,270
explaining something excitedly pretty

00:23:59,830 --> 00:24:04,210
really not a question any more questions

00:24:01,270 --> 00:24:07,290
no in that case let's thank our speaker

00:24:04,210 --> 00:24:07,290
for a fantastic talking right

00:24:08,519 --> 00:24:10,580

YouTube URL: https://www.youtube.com/watch?v=YjHsOrOOSuI


