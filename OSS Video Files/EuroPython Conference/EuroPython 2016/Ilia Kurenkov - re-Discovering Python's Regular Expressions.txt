Title: Ilia Kurenkov - re-Discovering Python's Regular Expressions
Publication date: 2016-07-29
Playlist: EuroPython 2016
Description: 
	Ilia Kurenkov - re-Discovering Python's Regular Expressions
[EuroPython 2016]
[19 July 2016]
[Bilbao, Euskadi, Spain]
(https://ep2016.europython.eu//conference/talks/rediscovering-pythons-regular-expressions)

As Armin Ronacher pointed out in a recent blog post, there is more to
Python's regular expression module than meets the eye. His post made
me wonder what other “hidden gems” are stashed away in Python’s `re`.
In the talk I share what I’ve learned about the inner workings of this
extremely popular and heavily used module.

-----

Anyone who has used Python to search text for substring patterns has
at least heard of the regular expression module. Many of us use it
extensively for parsers and lexers, extracting information .
And yet we know surprisingly little about its inner workings, as Armin
Ronacher demonstrated in his recent blog post, “Python's Hidden
Regular Expression Gems”. Inspired by this, I want to dive deeper into
Python’s `re` module and share what I find with folks at EuroPython.
My goal is that at the end of the day most of us walk away from this
talk with a better understanding of this extremely useful module.

Here are a few examples of the kinds of things I would like to cover:

 - A clear presentation of `re`’s overall structure.
 - What actually happens behind the scenes when you “compile” a
regular expression with `re.compile`?
 - What are the speed implications of using a callable as the
replacement argument to `re.sub`?
 - re.MatchObject interface: `group` vs. `groups` vs `groupdict`

To keep the talk entertaining as well as educational I plan to pepper
it with whatever interesting and/or funny trivia I find about the
module’s history and structure.

Prerequisites:
If you've ever used the `re` module, you should be fine :)
Captions: 
	00:00:00,000 --> 00:00:06,509
um okay next up is one of my favorite

00:00:04,560 --> 00:00:10,790
and I think a lot of other people out

00:00:06,509 --> 00:00:15,000
there regularly regular expressions

00:00:10,790 --> 00:00:23,340
we've got ilia right here that's how a

00:00:15,000 --> 00:00:27,029
run of applause and that adhere it thank

00:00:23,340 --> 00:00:28,439
you so I am indeed Delia and I am indeed

00:00:27,029 --> 00:00:31,470
here to talk about regular expressions

00:00:28,439 --> 00:00:34,710
in Python I'll just quickly say a couple

00:00:31,470 --> 00:00:36,510
words about myself I'm just finishing my

00:00:34,710 --> 00:00:40,260
first year in a master's program at the

00:00:36,510 --> 00:00:43,379
University of Potsdam i tinker ola with

00:00:40,260 --> 00:00:46,230
the natural language toolkits library in

00:00:43,379 --> 00:00:49,379
python and i made very very small bug

00:00:46,230 --> 00:00:53,699
fixes to see python and matplotlib i

00:00:49,379 --> 00:00:55,800
also work at a gym which is a german a

00:00:53,699 --> 00:00:58,050
start-up that's using digital technology

00:00:55,800 --> 00:01:02,520
to really change how we interact with

00:00:58,050 --> 00:01:05,610
fitness but my talk is uh not really

00:01:02,520 --> 00:01:08,580
related to anything as I do in November

00:01:05,610 --> 00:01:10,320
there was a post by I'm in Omaha who you

00:01:08,580 --> 00:01:12,930
guys I'm sure all know as the author of

00:01:10,320 --> 00:01:15,840
flask and ginger two and a bunch of

00:01:12,930 --> 00:01:18,390
other useful web libraries he wrote

00:01:15,840 --> 00:01:20,850
about how he used an undocumented

00:01:18,390 --> 00:01:24,380
feature of the regular expression module

00:01:20,850 --> 00:01:27,930
to improve his lecture performance and

00:01:24,380 --> 00:01:30,360
reading that I saw hey what other hidden

00:01:27,930 --> 00:01:31,799
gems are there in the regular expression

00:01:30,360 --> 00:01:35,030
module that we just don't know about and

00:01:31,799 --> 00:01:37,200
so I went through it a little bit and

00:01:35,030 --> 00:01:39,240
compiled a bunch of things that I

00:01:37,200 --> 00:01:42,150
thought were interesting and that's what

00:01:39,240 --> 00:01:43,530
I'm going to present today the talk will

00:01:42,150 --> 00:01:45,600
consist of the following things i'll

00:01:43,530 --> 00:01:48,720
just give a very brief short history of

00:01:45,600 --> 00:01:52,229
the modules development then we'll talk

00:01:48,720 --> 00:01:55,250
a lot about compilation then i'll go

00:01:52,229 --> 00:01:58,049
over regular the re modules flags and

00:01:55,250 --> 00:01:59,820
finally we'll talk about the match

00:01:58,049 --> 00:02:02,570
object interface like how what to do

00:01:59,820 --> 00:02:02,570
once you actually have

00:02:02,950 --> 00:02:08,750
alright the history part the current

00:02:07,100 --> 00:02:10,280
implementation of the regular expression

00:02:08,750 --> 00:02:12,680
module in Python is actually the third

00:02:10,280 --> 00:02:14,569
attempt at tackling this problem at

00:02:12,680 --> 00:02:17,300
first Python came with a module called

00:02:14,569 --> 00:02:19,370
reg ex that was sort of more similar to

00:02:17,300 --> 00:02:21,590
walk and grep in the sense that it was a

00:02:19,370 --> 00:02:24,890
deterministic engine and it was very

00:02:21,590 --> 00:02:26,750
basic functionality then people heard

00:02:24,890 --> 00:02:30,080
about about pearl and they said we want

00:02:26,750 --> 00:02:32,030
the same in Python and the reg ex module

00:02:30,080 --> 00:02:36,290
was phased out and replaced by the re

00:02:32,030 --> 00:02:38,390
module that had pyaari as the back end

00:02:36,290 --> 00:02:39,530
the origin the pu's a little bit unclear

00:02:38,390 --> 00:02:44,239
to me I think it's probably because of

00:02:39,530 --> 00:02:46,450
pearl and finally pyaari was optimized

00:02:44,239 --> 00:02:49,519
and basically rewritten from scratch as

00:02:46,450 --> 00:02:52,130
sre it's called sre because it was

00:02:49,519 --> 00:02:53,630
written by frederick lund from secret

00:02:52,130 --> 00:02:58,040
labs and i'm guessing that's where the S

00:02:53,630 --> 00:02:59,780
comes since then for about 15 years it's

00:02:58,040 --> 00:03:01,010
really just been like the only major

00:02:59,780 --> 00:03:03,349
feature that was added to it was in

00:03:01,010 --> 00:03:06,019
accord support and other than that it

00:03:03,349 --> 00:03:09,139
was just basic bug fixes so it's it's

00:03:06,019 --> 00:03:12,019
kind of old as far as code goes and you

00:03:09,139 --> 00:03:14,840
can see that it consists of a of a see

00:03:12,019 --> 00:03:17,420
module and a Python component and

00:03:14,840 --> 00:03:18,319
sometimes if you put the two next to

00:03:17,420 --> 00:03:19,700
each other it's kind of hard to tell

00:03:18,319 --> 00:03:23,480
which ones which just from the way

00:03:19,700 --> 00:03:26,269
they're written another another feature

00:03:23,480 --> 00:03:28,489
that that sort of got carried over I'll

00:03:26,269 --> 00:03:33,799
mention later when we talk about about

00:03:28,489 --> 00:03:37,519
flags so enough about history let's now

00:03:33,799 --> 00:03:39,410
let it sort of rip on a real problem and

00:03:37,519 --> 00:03:41,239
namely let's tackle something that's

00:03:39,410 --> 00:03:45,680
been bothering humans for a very long

00:03:41,239 --> 00:03:47,150
time let's search for God and I think

00:03:45,680 --> 00:03:48,769
the most appropriate place to start

00:03:47,150 --> 00:03:50,930
searching for God is actually the Bible

00:03:48,769 --> 00:03:52,940
so let's take the King James Version

00:03:50,930 --> 00:03:55,760
since it's freely available and it's

00:03:52,940 --> 00:03:57,560
just for megabyte txt file really easy

00:03:55,760 --> 00:04:01,280
just to load into memory as a string and

00:03:57,560 --> 00:04:03,760
then let re do its thing so we just

00:04:01,280 --> 00:04:05,620
import re and perform our research

00:04:03,760 --> 00:04:08,269
wonderful we get some results

00:04:05,620 --> 00:04:10,280
interesting but we kind of want to

00:04:08,269 --> 00:04:11,989
expand our search we want to start

00:04:10,280 --> 00:04:13,010
looking at maybe other text what other

00:04:11,989 --> 00:04:17,180
gods we can find

00:04:13,010 --> 00:04:20,329
some other text so let's say we try the

00:04:17,180 --> 00:04:21,639
new American Bible or let's try the wall

00:04:20,329 --> 00:04:24,080
street journal just for the heck of it

00:04:21,639 --> 00:04:27,080
and we can we can keep adding these

00:04:24,080 --> 00:04:28,490
until we're blue in the face but you

00:04:27,080 --> 00:04:31,789
probably you guys are all itching

00:04:28,490 --> 00:04:34,130
because I'm keep rewriting God all the

00:04:31,789 --> 00:04:35,750
time and it would be nice if I didn't

00:04:34,130 --> 00:04:37,070
have to if I wanted to change this

00:04:35,750 --> 00:04:40,070
regular expression didn't have to go and

00:04:37,070 --> 00:04:43,520
change it in 50 places so let's reuse

00:04:40,070 --> 00:04:45,860
the pattern the naive way to do this is

00:04:43,520 --> 00:04:47,870
to just save it to a variable and then

00:04:45,860 --> 00:04:52,610
plug that variable in everywhere where

00:04:47,870 --> 00:04:54,380
we had God before another way to do it

00:04:52,610 --> 00:04:57,199
is to compile it into something

00:04:54,380 --> 00:04:59,330
mysterious called a pattern object and

00:04:57,199 --> 00:05:04,910
then use the methods on this pattern

00:04:59,330 --> 00:05:06,320
object to search and the question is why

00:05:04,910 --> 00:05:07,940
why would we want to compile why would

00:05:06,320 --> 00:05:11,120
we want to do use this method instead of

00:05:07,940 --> 00:05:12,590
just using the string and the there's a

00:05:11,120 --> 00:05:17,479
several arguments used for this at

00:05:12,590 --> 00:05:20,000
institute to encourage it the official

00:05:17,479 --> 00:05:21,949
documentation says we can modify the

00:05:20,000 --> 00:05:25,250
search code scope a little bit so we can

00:05:21,949 --> 00:05:26,570
a pattern object dot search is different

00:05:25,250 --> 00:05:29,780
from our retail search and sums that you

00:05:26,570 --> 00:05:31,070
can give them this start position in any

00:05:29,780 --> 00:05:32,180
position so you can search in a part of

00:05:31,070 --> 00:05:34,910
the string instead of the whole string

00:05:32,180 --> 00:05:37,039
that's cool that's neat some other

00:05:34,910 --> 00:05:39,650
people say it improves readability this

00:05:37,039 --> 00:05:40,910
is kind of a question of taste so I'm

00:05:39,650 --> 00:05:44,810
not going to touch that in this talk at

00:05:40,910 --> 00:05:45,889
all I'm instead going to zero in on an

00:05:44,810 --> 00:05:48,050
argument that I've seen on stack

00:05:45,889 --> 00:05:51,050
overflow and that's the claims it's

00:05:48,050 --> 00:05:52,220
faster and I'm not entirely so sure

00:05:51,050 --> 00:05:56,270
about that

00:05:52,220 --> 00:06:01,000
so a is re to compile faster the claim

00:05:56,270 --> 00:06:03,650
is this sucks this is better for speed

00:06:01,000 --> 00:06:05,570
let's investigate that using the

00:06:03,650 --> 00:06:07,610
implementations of all this of all these

00:06:05,570 --> 00:06:09,800
methods so let's look at re that whoops

00:06:07,610 --> 00:06:13,190
are read out search first getting ahead

00:06:09,800 --> 00:06:14,870
of myself then re dead search as we can

00:06:13,190 --> 00:06:18,380
see uses something called underscore

00:06:14,870 --> 00:06:22,040
compile and then it does search on that

00:06:18,380 --> 00:06:25,820
object wonderful what does re to compile

00:06:22,040 --> 00:06:27,110
do oh it uses the same function so but

00:06:25,820 --> 00:06:30,410
just based on this evidence we could

00:06:27,110 --> 00:06:32,690
think that hmmm probably it's better if

00:06:30,410 --> 00:06:35,210
we compile it first and then you search

00:06:32,690 --> 00:06:38,630
because we would be saving ourselves a

00:06:35,210 --> 00:06:40,490
step but it's not all that simple if we

00:06:38,630 --> 00:06:42,080
look at the implementation of underscore

00:06:40,490 --> 00:06:45,250
compile we can notice a couple of things

00:06:42,080 --> 00:06:47,810
first of all it uses the cash secondly

00:06:45,250 --> 00:06:51,050
before it even starts doing anything

00:06:47,810 --> 00:06:53,390
else it checks that cash so what we

00:06:51,050 --> 00:06:56,270
thought was two compilations essentially

00:06:53,390 --> 00:06:57,710
now really boils down to the first

00:06:56,270 --> 00:06:59,090
compilation in our readout search and

00:06:57,710 --> 00:07:01,340
then the second time we do our readout

00:06:59,090 --> 00:07:03,980
search it's just a dictionary lookup so

00:07:01,340 --> 00:07:06,169
we're not actually losing that much that

00:07:03,980 --> 00:07:08,570
much speed of course this is dependent

00:07:06,169 --> 00:07:13,910
on when the cash gets cleared it said

00:07:08,570 --> 00:07:15,229
that 500 and normally I just based on

00:07:13,910 --> 00:07:18,020
playing around with it I wouldn't expect

00:07:15,229 --> 00:07:20,810
you to run into that limit if you do if

00:07:18,020 --> 00:07:22,280
you're loading some some framework or or

00:07:20,810 --> 00:07:24,770
module that uses regular expressions

00:07:22,280 --> 00:07:29,560
heavily you might and then you sort of

00:07:24,770 --> 00:07:32,600
get unprofitable performance but

00:07:29,560 --> 00:07:33,919
realistically offer for most programs

00:07:32,600 --> 00:07:36,950
there's not really going to be a serious

00:07:33,919 --> 00:07:38,900
benefit to to using compile in terms of

00:07:36,950 --> 00:07:41,419
speed it's going to be slightly faster

00:07:38,900 --> 00:07:44,060
if if cash is cleared and if you really

00:07:41,419 --> 00:07:46,130
really care about optimizing that much I

00:07:44,060 --> 00:07:47,870
would recommend you really think about

00:07:46,130 --> 00:07:50,000
the regular expressions themselves

00:07:47,870 --> 00:07:52,250
because Python and Perl for that matter

00:07:50,000 --> 00:07:55,620
and most advanced regular expression

00:07:52,250 --> 00:07:57,030
libraries use a nondeterministic regular

00:07:55,620 --> 00:07:59,430
expression engine in the back end and

00:07:57,030 --> 00:08:01,650
that is entirely driven by your regular

00:07:59,430 --> 00:08:04,229
expression so if you find a way to

00:08:01,650 --> 00:08:05,879
optimize that you'll gain lots of lots

00:08:04,229 --> 00:08:07,500
of speed I'm not going to talk about

00:08:05,879 --> 00:08:09,840
that specifically in this talk because

00:08:07,500 --> 00:08:12,599
people write books about that it's kind

00:08:09,840 --> 00:08:15,930
of a heavy topic instead I'm going to

00:08:12,599 --> 00:08:19,110
sort of close with close this this topic

00:08:15,930 --> 00:08:21,030
by say yeah sure use a rita compile but

00:08:19,110 --> 00:08:24,599
don't expect it to be super fast right

00:08:21,030 --> 00:08:26,849
away all right let's get back to the

00:08:24,599 --> 00:08:31,139
Bible you were reading it and you came

00:08:26,849 --> 00:08:33,719
across this this line you realized all

00:08:31,139 --> 00:08:35,669
crap my my reference question doesn't

00:08:33,719 --> 00:08:36,990
capture this what do I do so you go to

00:08:35,669 --> 00:08:40,079
the documentation you read a little bit

00:08:36,990 --> 00:08:42,690
and you find that there is a solution

00:08:40,079 --> 00:08:44,970
you can use something called a readout

00:08:42,690 --> 00:08:47,579
ignore case give it to re-type compile

00:08:44,970 --> 00:08:51,660
and then search and your searches will

00:08:47,579 --> 00:08:56,550
be case insensitive but what is our read

00:08:51,660 --> 00:09:02,040
ignore case if we print it it's just an

00:08:56,550 --> 00:09:04,500
integer and but we can stack them so we

00:09:02,040 --> 00:09:08,640
can combine several flags together using

00:09:04,500 --> 00:09:12,990
this pipe ething the bitwise or we can

00:09:08,640 --> 00:09:17,279
do this again ad infinitum so what

00:09:12,990 --> 00:09:19,740
happens underneath the hood actually the

00:09:17,279 --> 00:09:22,260
bitwise or basically takes advantage of

00:09:19,740 --> 00:09:25,800
the fact that all integers encoded

00:09:22,260 --> 00:09:28,320
binary obviously and if you choose your

00:09:25,800 --> 00:09:31,529
integers well it's namely if you choose

00:09:28,320 --> 00:09:33,600
them all to be powers of two they will

00:09:31,529 --> 00:09:35,970
be basically one hot and coatings where

00:09:33,600 --> 00:09:37,380
the the one the only one in the sequence

00:09:35,970 --> 00:09:39,810
will uniquely have will have a unique

00:09:37,380 --> 00:09:42,420
position so combining them chaining them

00:09:39,810 --> 00:09:45,120
with a pipe sorry was with the bitwise

00:09:42,420 --> 00:09:48,209
or will just let you know which ones are

00:09:45,120 --> 00:09:50,899
set and conversely if you use the

00:09:48,209 --> 00:09:53,490
bitwise and you can then figure out

00:09:50,899 --> 00:09:54,390
which options are present in which are

00:09:53,490 --> 00:09:58,790
not

00:09:54,390 --> 00:10:02,130
now this sort of was not on my radar for

00:09:58,790 --> 00:10:04,650
one simple reason I realized I don't use

00:10:02,130 --> 00:10:06,600
this pattern in Python almost at all and

00:10:04,650 --> 00:10:08,700
then I thought well maybe I'm crazy

00:10:06,600 --> 00:10:10,530
maybe I'm just I'm a linguist by

00:10:08,700 --> 00:10:13,770
training maybe I just right weird Python

00:10:10,530 --> 00:10:15,930
code but I also use other people's

00:10:13,770 --> 00:10:19,680
libraries and and they don't use this

00:10:15,930 --> 00:10:22,500
pattern either so maybe it's just rare

00:10:19,680 --> 00:10:24,000
videos uncommon for Python these days so

00:10:22,500 --> 00:10:26,250
I decided to verify this what better

00:10:24,000 --> 00:10:28,560
better way to verify than to check the

00:10:26,250 --> 00:10:29,820
standard library so I read through the

00:10:28,560 --> 00:10:31,850
documentation for the whole standard

00:10:29,820 --> 00:10:36,810
library a couple of sleepless nights and

00:10:31,850 --> 00:10:41,060
I found only two modules out of the 240

00:10:36,810 --> 00:10:44,940
ish that youth these bit are a flags and

00:10:41,060 --> 00:10:48,180
their OS for opening and accessing files

00:10:44,940 --> 00:10:51,000
and socket so there's two things that

00:10:48,180 --> 00:10:52,410
are interesting about this a almost like

00:10:51,000 --> 00:10:53,940
the standard library confirms my

00:10:52,410 --> 00:10:56,820
intuition that they're not very common

00:10:53,940 --> 00:11:00,630
and be the ones the do modules that do

00:10:56,820 --> 00:11:05,370
you use bidari flags are very low level

00:11:00,630 --> 00:11:07,650
stuff so to me it seems like the re

00:11:05,370 --> 00:11:10,020
module somehow miraculously retain

00:11:07,650 --> 00:11:11,640
something basically from an older era

00:11:10,020 --> 00:11:13,890
that was just sort of refactored out of

00:11:11,640 --> 00:11:16,680
more or less the the rest of the

00:11:13,890 --> 00:11:18,120
standard library but stayed in the the

00:11:16,680 --> 00:11:23,070
modules that had to do with level

00:11:18,120 --> 00:11:26,640
operations and re cool well that was

00:11:23,070 --> 00:11:28,230
that was a fun rabbit hole I'm not in

00:11:26,640 --> 00:11:30,540
the in the sort of natural progression

00:11:28,230 --> 00:11:32,760
in the life cycle of a regular

00:11:30,540 --> 00:11:34,830
expression normally would be to talk

00:11:32,760 --> 00:11:38,520
about search and matching but

00:11:34,830 --> 00:11:40,980
unfortunately my ste skills are just not

00:11:38,520 --> 00:11:42,240
up to par to have a coherent picture at

00:11:40,980 --> 00:11:44,010
this point they've improved quite a bit

00:11:42,240 --> 00:11:46,260
when I started since I started working

00:11:44,010 --> 00:11:47,550
on this but I nothing that I can they

00:11:46,260 --> 00:11:51,680
can present publicly so we're going to

00:11:47,550 --> 00:11:51,680
go straight to the match object

00:11:52,790 --> 00:11:59,220
so this section this this part of the

00:11:56,310 --> 00:12:00,329
talk is a little bit unusual form the

00:11:59,220 --> 00:12:01,709
previous ones because i'm actually not

00:12:00,329 --> 00:12:04,589
going to try to say anything new

00:12:01,709 --> 00:12:06,390
whatsoever i will just be rehashing

00:12:04,589 --> 00:12:11,430
things that everyone already knows the

00:12:06,390 --> 00:12:13,350
there are no real like underwater reefs

00:12:11,430 --> 00:12:14,760
or some weird stuff going on when it

00:12:13,350 --> 00:12:16,440
comes to mesh objects and the

00:12:14,760 --> 00:12:20,010
documentation is actually very clear

00:12:16,440 --> 00:12:22,500
about them and yet I find at least

00:12:20,010 --> 00:12:24,990
personally whenever I use the re module

00:12:22,500 --> 00:12:28,250
I have to look at it look it up every

00:12:24,990 --> 00:12:31,589
time all the difference between group

00:12:28,250 --> 00:12:32,940
groups group and then all the

00:12:31,589 --> 00:12:35,040
other stuff that you can deal with with

00:12:32,940 --> 00:12:38,579
match objects kind of throws me off a

00:12:35,040 --> 00:12:40,649
little bit and I don't think I'm the

00:12:38,579 --> 00:12:42,300
only one because I occasionally see code

00:12:40,649 --> 00:12:47,070
like this one when I when I read others

00:12:42,300 --> 00:12:50,640
code and hope is that I'll come up with

00:12:47,070 --> 00:12:53,730
like a simple and 16 a rule of thumb

00:12:50,640 --> 00:12:55,860
that will encourage people to sort of

00:12:53,730 --> 00:13:00,120
avoid using that because it's not really

00:12:55,860 --> 00:13:03,510
no you're not playing to strength so

00:13:00,120 --> 00:13:06,560
let's let's have an example we compile a

00:13:03,510 --> 00:13:09,630
regular expression and this one is I

00:13:06,560 --> 00:13:11,820
purpose did it to choose to be a little

00:13:09,630 --> 00:13:14,070
bit complicated it has two groups the

00:13:11,820 --> 00:13:16,199
first one and they're both named the

00:13:14,070 --> 00:13:18,690
first one is called leads and we're

00:13:16,199 --> 00:13:21,660
searching for the string god then we

00:13:18,690 --> 00:13:23,730
have a space and a second group that's

00:13:21,660 --> 00:13:26,459
named follows and there we can match any

00:13:23,730 --> 00:13:30,690
alphanumeric character at least one or

00:13:26,459 --> 00:13:36,010
more then we have a text I just chose

00:13:30,690 --> 00:13:39,260
one sentence and we get a match we do

00:13:36,010 --> 00:13:42,290
pattern object out search and we pretty

00:13:39,260 --> 00:13:44,420
much we see that one of them now what do

00:13:42,290 --> 00:13:47,810
we do well what can we do to get more

00:13:44,420 --> 00:13:49,610
information out of it basically the what

00:13:47,810 --> 00:13:52,850
I really want folks to take away from

00:13:49,610 --> 00:13:55,460
this is that the match object responds

00:13:52,850 --> 00:14:00,290
to three types of requests three

00:13:55,460 --> 00:14:03,320
questions first of all you can tell it

00:14:00,290 --> 00:14:05,180
to give you the whole match spring so

00:14:03,320 --> 00:14:08,840
this includes groups non-group stuck in

00:14:05,180 --> 00:14:11,600
between everything then you can ask it

00:14:08,840 --> 00:14:13,670
for an individual sub match so you can

00:14:11,600 --> 00:14:16,880
ask either just for God or for the

00:14:13,670 --> 00:14:19,880
follows group and finally you can get

00:14:16,880 --> 00:14:21,260
all the subgroups together ignore the

00:14:19,880 --> 00:14:22,130
strings you can order the parts of the

00:14:21,260 --> 00:14:23,450
regular expression that are not in

00:14:22,130 --> 00:14:27,440
Greece you just get the groups

00:14:23,450 --> 00:14:31,760
individually alright so the total match

00:14:27,440 --> 00:14:36,020
case you simply call match group and you

00:14:31,760 --> 00:14:39,110
get the entire string that match you can

00:14:36,020 --> 00:14:42,260
also call mash group with the 00 is

00:14:39,110 --> 00:14:45,800
implicit so the more the more clear ways

00:14:42,260 --> 00:14:47,390
to call it with that one and that's

00:14:45,800 --> 00:14:51,800
literally it that's all you did that's

00:14:47,390 --> 00:14:53,750
all there is to the total match then if

00:14:51,800 --> 00:14:56,290
you want to get individual subgroups you

00:14:53,750 --> 00:14:58,490
can start calling that group with

00:14:56,290 --> 00:15:02,300
integers starting with one because 0 is

00:14:58,490 --> 00:15:03,620
taken or you can give it the names if

00:15:02,300 --> 00:15:05,270
you named your group you can give it the

00:15:03,620 --> 00:15:07,760
names of the groups and that will also

00:15:05,270 --> 00:15:12,770
oh I made a typo in there that second

00:15:07,760 --> 00:15:15,530
match should be created finally if you

00:15:12,770 --> 00:15:18,520
want all the subgroups you just call

00:15:15,530 --> 00:15:21,650
that groups and that returns a tuple and

00:15:18,520 --> 00:15:24,050
if you have named groups you can also

00:15:21,650 --> 00:15:26,600
call thick thick that returns obviously

00:15:24,050 --> 00:15:31,550
an unordered dictionary

00:15:26,600 --> 00:15:34,850
so when when people do call group dick

00:15:31,550 --> 00:15:36,410
and then try to access individual keys

00:15:34,850 --> 00:15:38,569
in there really the what they're trying

00:15:36,410 --> 00:15:41,630
to go for is that group with the key

00:15:38,569 --> 00:15:43,699
name only you only really need these

00:15:41,630 --> 00:15:46,040
groups and that cryptic if you plan to

00:15:43,699 --> 00:15:47,360
somehow then pass on these the whole the

00:15:46,040 --> 00:15:53,000
whole data structure on to whatever

00:15:47,360 --> 00:15:56,000
you're you're processing and there's the

00:15:53,000 --> 00:15:57,410
that's more or less it the things I want

00:15:56,000 --> 00:16:02,089
you guys to take away from from this

00:15:57,410 --> 00:16:04,940
talk number one the re modules old the

00:16:02,089 --> 00:16:06,889
use of flags in re is kind of unique you

00:16:04,940 --> 00:16:10,610
don't really get that anywhere else in

00:16:06,889 --> 00:16:12,230
Python these days at least use re

00:16:10,610 --> 00:16:15,230
compile but don't hope that it'll

00:16:12,230 --> 00:16:19,069
magically speed up your code by lots of

00:16:15,230 --> 00:16:20,990
factors and finally I hope fingers

00:16:19,069 --> 00:16:23,360
crossed that you have you walk away with

00:16:20,990 --> 00:16:25,339
a slightly clearer motion of what the

00:16:23,360 --> 00:16:29,740
match object doesn't have to have to

00:16:25,339 --> 00:16:29,740
access it thank you

00:16:35,529 --> 00:16:48,139
okay do we have any questions do you

00:16:44,809 --> 00:16:51,529
know about Python Rex a Python Rex yeah

00:16:48,139 --> 00:16:54,050
it's a request like Nora expression for

00:16:51,529 --> 00:16:56,480
humans oh okay no I have a little bit

00:16:54,050 --> 00:16:59,149
I've heard of there's one there was an

00:16:56,480 --> 00:17:01,249
attempt to rewrite the reg ex module

00:16:59,149 --> 00:17:03,110
again and expand its functionality quite

00:17:01,249 --> 00:17:04,730
a bit and a few years back they were

00:17:03,110 --> 00:17:06,709
having lots and lots of wars on the

00:17:04,730 --> 00:17:08,539
mailing list about adding it back but

00:17:06,709 --> 00:17:11,270
they decided in the end basically not to

00:17:08,539 --> 00:17:13,250
do it but you can get it on pi PI yeah

00:17:11,270 --> 00:17:18,579
yeah I think I think it uses array

00:17:13,250 --> 00:17:18,579
anyway in the really okay cool

00:17:21,630 --> 00:17:30,450
I got two questions first is about the

00:17:26,459 --> 00:17:34,020
compile you compared compile and search

00:17:30,450 --> 00:17:38,100
by comparing code if have you measure it

00:17:34,020 --> 00:17:40,020
if if one of those is faster mm no I

00:17:38,100 --> 00:17:43,290
haven't have to admit I sort of went by

00:17:40,020 --> 00:17:46,470
the what which steps would be would be

00:17:43,290 --> 00:17:47,820
necessary to go and do it there's from

00:17:46,470 --> 00:17:49,530
the quarry couldn't see if there were

00:17:47,820 --> 00:17:51,990
any sort of optimizations that were not

00:17:49,530 --> 00:17:55,950
a parent that would then show up in

00:17:51,990 --> 00:17:58,020
timing um but we can definitely have a

00:17:55,950 --> 00:18:01,440
look at that as well okay second

00:17:58,020 --> 00:18:04,020
question is about betwa bit are used the

00:18:01,440 --> 00:18:10,220
second one which which library does it

00:18:04,020 --> 00:18:10,220
use a socket and os okay thank you

00:18:11,850 --> 00:18:16,840
also questioned about the flags but

00:18:14,410 --> 00:18:18,520
what's the I mean abuser a few times and

00:18:16,840 --> 00:18:21,760
I didn't think there was anything

00:18:18,520 --> 00:18:24,570
strange but what's the alternative

00:18:21,760 --> 00:18:26,980
anyway if you want to like do something

00:18:24,570 --> 00:18:28,930
the the usual thing would be have

00:18:26,980 --> 00:18:31,840
boolean flags right so you have explicit

00:18:28,930 --> 00:18:33,310
stuff saying this true this or what I've

00:18:31,840 --> 00:18:36,100
seen also in some places people use

00:18:33,310 --> 00:18:37,870
strings so you say this flag and then

00:18:36,100 --> 00:18:39,040
you could equate to a string and then

00:18:37,870 --> 00:18:44,940
you check it later in your code whether

00:18:39,040 --> 00:18:50,680
it you said to that string okay thanks

00:18:44,940 --> 00:18:54,750
any other questions already know cool

00:18:50,680 --> 00:18:54,750

YouTube URL: https://www.youtube.com/watch?v=FASl4pYm6lU


