Title: Alain Martin - Python as the keystone of building and testing C++ applications
Publication date: 2016-07-28
Playlist: EuroPython 2016
Description: 
	Alain Martin - Python as the keystone of building and testing C++ applications
[EuroPython 2016]
[18 July 2016]
[Bilbao, Euskadi, Spain]
(https://ep2016.europython.eu//conference/talks/python-as-the-keystone-of-building-and-testing-c-applications)

This talk explains how Abletonâ€™s developers use Python to build and
test C, C++ and Objective-C code. Our "build-system" is a collection
of Python scripts that simplify our workflows, and help us write
better software. The top-level scripts share a common design which
makes them easy to use, maintain and extend. This talk describes the
essence of that design, so you can apply it to your own project.

-----

At Ableton, we make [Live][1], [Push][2] and [Link][3], unique
software and hardware for music creation and performance. Live is a
C++ desktop application built from a 15-year old code base. Push is an
instrument embedding a multicolor display which renders a [Qt
Quick][4] scene powered by [Qt][5]. Link is a technology that keeps
music devices in time and is available to app developers as
[LinkKit][6], an iOS SDK. "But what does all that have to do with
Python?", you might ask.

This talk answers that question by explaining how our developers use
Python to build and test C, C++ and Objective-C source code. Based on
[GYP][7], what we call "build-system" is a collection of Python
scripts that simplify our workflows, and help us write better
software. The three top-level scripts, "configure.py", "build.py" and
"run.py", share a common design which makes them easy to use by
developers, as well as easy to maintain and extend. This talk
describes the essence of that design, so you can apply it to your own
project.

[1]: https://www.ableton.com/live/
[2]: https://www.ableton.com/push/
[3]: https://www.ableton.com/link/
[4]: https://www.qt.io/qt-quick/
[5]: http://www.qt.io/
[6]: https://ableton.github.io/linkkit/
[7]: https://gyp.gsrc.io/
Captions: 
	00:00:00,030 --> 00:00:06,420
okay so we have Alan Martin speaking

00:00:03,929 --> 00:00:10,500
about how to build C++ applications with

00:00:06,420 --> 00:00:13,469
Python as the core kind of so please

00:00:10,500 --> 00:00:16,250
introduce him and have to be big

00:00:13,469 --> 00:00:16,250
applause for him

00:00:26,660 --> 00:00:32,369
hi everybody I'm Alan and I work as a

00:00:30,119 --> 00:00:34,949
software engineer at Ableton in Berlin

00:00:32,369 --> 00:00:39,079
Germany let me introduce you to what we

00:00:34,949 --> 00:00:41,640
do at Ableton we make live push and Link

00:00:39,079 --> 00:00:45,720
software and hardware for music creation

00:00:41,640 --> 00:00:48,019
and performance first we make life but

00:00:45,720 --> 00:00:51,239
you can see on the laptop screen here

00:00:48,019 --> 00:00:53,159
life is a digital audio workstation for

00:00:51,239 --> 00:00:56,070
creating musical ideas turning them into

00:00:53,159 --> 00:00:56,909
songs and performing on stage on a

00:00:56,070 --> 00:01:00,030
technical level

00:00:56,909 --> 00:01:03,360
it's a C++ desktop application built for

00:01:00,030 --> 00:01:09,180
mac and windows from a pretty old code

00:01:03,360 --> 00:01:11,960
base 16 or older then we make push push

00:01:09,180 --> 00:01:14,280
is a USB device which becomes a powerful

00:01:11,960 --> 00:01:17,880
electronic music instrument when

00:01:14,280 --> 00:01:20,100
combined with life in embeds multicolor

00:01:17,880 --> 00:01:22,799
display at the top that renders a cute

00:01:20,100 --> 00:01:26,880
quick scene powered by cute which is a

00:01:22,799 --> 00:01:30,570
C++ application framework and then we

00:01:26,880 --> 00:01:33,479
make link link is a technology that

00:01:30,570 --> 00:01:37,079
keeps music applications and devices in

00:01:33,479 --> 00:01:39,659
sync by synchronizing their bit it is

00:01:37,079 --> 00:01:43,740
available to app developers as an iOS

00:01:39,659 --> 00:01:47,119
SDK now you might ask but what does that

00:01:43,740 --> 00:01:47,119
have to do with Python

00:01:47,580 --> 00:01:54,420
well we do use Python at Ableton first

00:01:51,810 --> 00:01:57,300
we use it to write remote scripts for

00:01:54,420 --> 00:02:01,500
MIDI controllers these MIDI controllers

00:01:57,300 --> 00:02:04,170
are devices like push that musicians can

00:02:01,500 --> 00:02:06,720
use to interact with life in order to

00:02:04,170 --> 00:02:09,930
enhance their music creation workflow

00:02:06,720 --> 00:02:12,270
and to perform when we use Python

00:02:09,930 --> 00:02:14,250
scripts to automate continuous

00:02:12,270 --> 00:02:18,450
integration and releasing new versions

00:02:14,250 --> 00:02:21,900
of life and last but not least since

00:02:18,450 --> 00:02:24,150
it's the topic of this talk we are using

00:02:21,900 --> 00:02:28,350
Python to build and test C++

00:02:24,150 --> 00:02:32,490
applications such as life so let's see

00:02:28,350 --> 00:02:35,640
how we are building live with Python in

00:02:32,490 --> 00:02:38,670
order to build C++ applications you have

00:02:35,640 --> 00:02:41,250
to compile C++ source files and

00:02:38,670 --> 00:02:45,660
sometimes also C and objective-c source

00:02:41,250 --> 00:02:48,990
files until you compile them into object

00:02:45,660 --> 00:02:51,150
files binaries which then are linked by

00:02:48,990 --> 00:02:55,440
the linker into libraries and

00:02:51,150 --> 00:02:58,590
executables when building live more than

00:02:55,440 --> 00:03:00,800
1,400 files are compiled to product 88

00:02:58,590 --> 00:03:03,930
libraries and eight executables

00:03:00,800 --> 00:03:06,180
fortunately they are tools to help you

00:03:03,930 --> 00:03:08,550
build syphillis specifications and you

00:03:06,180 --> 00:03:10,370
don't have to call the compiler and the

00:03:08,550 --> 00:03:13,920
linker manually yourself

00:03:10,370 --> 00:03:16,890
these tools are called build systems and

00:03:13,920 --> 00:03:18,989
you might already know the ones I've

00:03:16,890 --> 00:03:22,430
listed here

00:03:18,989 --> 00:03:26,310
unfortunately most build system tools

00:03:22,430 --> 00:03:28,970
support only one platform and we want to

00:03:26,310 --> 00:03:32,910
build life on Mac and Windows and

00:03:28,970 --> 00:03:35,220
actually life used to be built from make

00:03:32,910 --> 00:03:36,930
files on Mac and visual studio projects

00:03:35,220 --> 00:03:40,890
on Windows and it was a total

00:03:36,930 --> 00:03:43,260
maintenance nightmare we started using a

00:03:40,890 --> 00:03:45,360
higher-level tool that would abstract

00:03:43,260 --> 00:03:47,790
most of the platform differences

00:03:45,360 --> 00:03:50,950
this tool is

00:03:47,790 --> 00:03:54,580
Jib stands for generate your projects

00:03:50,950 --> 00:03:57,160
and it's a mid-level system a bit like

00:03:54,580 --> 00:03:59,830
cynic and cumec it's a multi-platform

00:03:57,160 --> 00:04:02,440
tool that generates files for platform

00:03:59,830 --> 00:04:05,590
specific build systems it can generate

00:04:02,440 --> 00:04:09,550
make files ninja build files Visual

00:04:05,590 --> 00:04:13,420
Studio Projects and Xcode projects and

00:04:09,550 --> 00:04:17,620
it is written in Python nowadays it is

00:04:13,420 --> 00:04:20,290
mostly used to build chromium electron

00:04:17,620 --> 00:04:23,380
which is the base of get herbs at home

00:04:20,290 --> 00:04:27,160
text editor not J's and the v8

00:04:23,380 --> 00:04:29,560
JavaScript engine and it is also

00:04:27,160 --> 00:04:34,720
integrated in the live repository to

00:04:29,560 --> 00:04:38,260
actually build live here is the live git

00:04:34,720 --> 00:04:41,889
repository very minimalistic view with

00:04:38,260 --> 00:04:44,350
just what matters for that talk and add

00:04:41,889 --> 00:04:46,990
everything we use get some modules to

00:04:44,350 --> 00:04:49,720
integrate third-party code or to reuse

00:04:46,990 --> 00:04:53,710
our own code across several projects and

00:04:49,720 --> 00:04:55,840
here in order to build and test live the

00:04:53,710 --> 00:04:59,530
live repository contains a build system

00:04:55,840 --> 00:05:05,050
which is also an Ableton repository as

00:04:59,530 --> 00:05:06,450
it gets a module and there's also root

00:05:05,050 --> 00:05:10,500
level

00:05:06,450 --> 00:05:14,160
zip file name live dodge it now let's

00:05:10,500 --> 00:05:18,210
see the content of build system so build

00:05:14,160 --> 00:05:20,580
system itself is a git repository and it

00:05:18,210 --> 00:05:23,100
contains first of all the jeep

00:05:20,580 --> 00:05:24,510
repository as a sub module so we have

00:05:23,100 --> 00:05:28,470
some kind of submerge exception

00:05:24,510 --> 00:05:33,060
happening here but it's manageable when

00:05:28,470 --> 00:05:36,000
it contains Python scripts to build and

00:05:33,060 --> 00:05:39,180
test C++ applications there are three

00:05:36,000 --> 00:05:42,960
top-level scripts configured that pi is

00:05:39,180 --> 00:05:46,520
responsible for calling with the

00:05:42,960 --> 00:05:49,110
right arguments then build that I called

00:05:46,520 --> 00:05:53,700
the correct build system tool either

00:05:49,110 --> 00:05:55,410
msbuild ninja or xcode build and then

00:05:53,700 --> 00:05:59,930
run that PI called

00:05:55,410 --> 00:06:02,790
C++ test runners or cute specific tools

00:05:59,930 --> 00:06:05,280
going into the full details of how life

00:06:02,790 --> 00:06:07,290
is built would take way too long for

00:06:05,280 --> 00:06:10,020
this talk so we're just going to use a

00:06:07,290 --> 00:06:16,590
simple hello world example to see how

00:06:10,020 --> 00:06:20,070
the pill system scripts do so here's the

00:06:16,590 --> 00:06:22,650
hello world project breathe simple for

00:06:20,070 --> 00:06:24,750
now it obviously contains a copy of the

00:06:22,650 --> 00:06:26,900
build system repository otherwise that

00:06:24,750 --> 00:06:30,090
wouldn't be the build system hello world

00:06:26,900 --> 00:06:33,690
and like in the life of history it has a

00:06:30,090 --> 00:06:36,180
top-level zip file the C++ code to

00:06:33,690 --> 00:06:40,290
compile is spread between a source

00:06:36,180 --> 00:06:44,460
folder and a test folder which also

00:06:40,290 --> 00:06:47,150
contains a copy of catch which is a C++

00:06:44,460 --> 00:06:49,740
unit test framework

00:06:47,150 --> 00:06:53,270
now let's have a look at hello world

00:06:49,740 --> 00:06:57,660
object here two targets are declared

00:06:53,270 --> 00:07:01,050
hello and hello world test they both

00:06:57,660 --> 00:07:04,050
will produce one executable build from

00:07:01,050 --> 00:07:07,410
one source file so pretty simple pretty

00:07:04,050 --> 00:07:10,470
easy you might find the tip syntax

00:07:07,410 --> 00:07:12,660
familiar and that would make sense

00:07:10,470 --> 00:07:17,250
because well it's a Python dictionary

00:07:12,660 --> 00:07:20,640
actually the content of Hello what the

00:07:17,250 --> 00:07:25,110
TPP is straightforward classic C++ hello

00:07:20,640 --> 00:07:27,260
world and in test hello world the TPP we

00:07:25,110 --> 00:07:30,300
use the cash test framework to just

00:07:27,260 --> 00:07:36,780
brightest really dummy Unitas that

00:07:30,300 --> 00:07:38,610
always passes now let's build that so to

00:07:36,780 --> 00:07:40,980
build and test the hello a project we

00:07:38,610 --> 00:07:44,580
first called the configure script it

00:07:40,980 --> 00:07:48,300
indicates what it's doing and for which

00:07:44,580 --> 00:07:50,480
configuration so when is the platform it

00:07:48,300 --> 00:07:55,980
could be Mac but I'm running on Windows

00:07:50,480 --> 00:07:59,960
64 stands for 64-bit could be 32 and DLL

00:07:55,980 --> 00:08:03,300
is the linking style it could be static

00:07:59,960 --> 00:08:06,480
configure that PI responsible for

00:08:03,300 --> 00:08:10,620
calling chip which loads the hello world

00:08:06,480 --> 00:08:13,380
that zip file and generate Visual Studio

00:08:10,620 --> 00:08:16,550
files since we are running this example

00:08:13,380 --> 00:08:20,130
on Windows the generated files end up

00:08:16,550 --> 00:08:24,450
under the IDE folder in a subfolder

00:08:20,130 --> 00:08:26,420
which matches the configuration in a

00:08:24,450 --> 00:08:29,190
second time we call the build script

00:08:26,420 --> 00:08:31,210
based on the configuration it prints

00:08:29,190 --> 00:08:34,180
what is about to happen

00:08:31,210 --> 00:08:37,260
then it calls msbuild since it's the

00:08:34,180 --> 00:08:39,729
default on Windows bit repeating myself

00:08:37,260 --> 00:08:42,580
you can see the msbuild

00:08:39,729 --> 00:08:45,430
console output that two executables have

00:08:42,580 --> 00:08:50,230
been built hello hello world and

00:08:45,430 --> 00:08:52,570
horrible textured exe build up I finally

00:08:50,230 --> 00:08:54,459
dreams what happened

00:08:52,570 --> 00:08:56,320
which is really convenient when there

00:08:54,459 --> 00:08:57,910
are dozens of targets with hundreds of

00:08:56,320 --> 00:09:03,089
files and you don't want to scroll

00:08:57,910 --> 00:09:06,010
everything like when we're building live

00:09:03,089 --> 00:09:09,790
the build artifacts end up under the

00:09:06,010 --> 00:09:12,220
output folder here again in a subfolder

00:09:09,790 --> 00:09:15,430
based on the configuration but it's one

00:09:12,220 --> 00:09:18,070
subfolder more called debug because when

00:09:15,430 --> 00:09:22,060
calling bill dot I we can choose between

00:09:18,070 --> 00:09:23,980
debug and reads this division to

00:09:22,060 --> 00:09:27,250
subfolders based on the configuration

00:09:23,980 --> 00:09:28,990
allows us to simply build and test

00:09:27,250 --> 00:09:33,640
several configurations of the same

00:09:28,990 --> 00:09:36,329
application in the same repository and

00:09:33,640 --> 00:09:45,760
now we can run the hello world executive

00:09:36,329 --> 00:09:48,130
hello to finish that example oh sorry we

00:09:45,760 --> 00:09:51,550
call the run script with the CPP test

00:09:48,130 --> 00:09:54,310
comment and it will basically call every

00:09:51,550 --> 00:09:58,870
C++ test runner from the correct output

00:09:54,310 --> 00:10:02,529
folder by convention only executables

00:09:58,870 --> 00:10:07,180
ending with tests are treated as C++

00:10:02,529 --> 00:10:11,890
test runners and thus lol exe won't run

00:10:07,180 --> 00:10:14,040
here only the zero one test run dot I

00:10:11,890 --> 00:10:17,130
also prunes a summary

00:10:14,040 --> 00:10:20,370
of which this one is fast in which I've

00:10:17,130 --> 00:10:23,040
failed which is again pretty convenient

00:10:20,370 --> 00:10:27,329
when you have dozens of them and you

00:10:23,040 --> 00:10:29,940
don't want to read all the output so now

00:10:27,329 --> 00:10:32,579
we've seen how build system works in a

00:10:29,940 --> 00:10:34,589
very small project but now let's talk

00:10:32,579 --> 00:10:39,060
about what it means to use it with

00:10:34,589 --> 00:10:40,410
complex applications such as life so

00:10:39,060 --> 00:10:42,870
compared to the hello world project

00:10:40,410 --> 00:10:46,769
there are a lot more files in the live

00:10:42,870 --> 00:10:49,259
repository so it takes much more time

00:10:46,769 --> 00:10:52,980
like really much more time to build and

00:10:49,259 --> 00:10:56,160
test but it works in the exact same way

00:10:52,980 --> 00:11:02,399
the only thing to do is simply configure

00:10:56,160 --> 00:11:05,610
build and run nothing more but don't get

00:11:02,399 --> 00:11:07,380
fooled by the apparent simplicity the

00:11:05,610 --> 00:11:10,440
fact that they are only free scripts to

00:11:07,380 --> 00:11:12,899
call doesn't guarantee on itself but V

00:11:10,440 --> 00:11:13,440
scripts are easy to use maintain and

00:11:12,899 --> 00:11:16,709
extend

00:11:13,440 --> 00:11:19,529
in fact these scripts could have been

00:11:16,709 --> 00:11:21,569
developed in a totally chaotic way and

00:11:19,529 --> 00:11:24,630
it would be a mess

00:11:21,569 --> 00:11:26,910
not only for developers work directly on

00:11:24,630 --> 00:11:29,130
them but also for developers who are

00:11:26,910 --> 00:11:32,610
using them to build and test their

00:11:29,130 --> 00:11:35,480
applications and developers really don't

00:11:32,610 --> 00:11:35,480
like to work with a mess

00:11:36,170 --> 00:11:41,760
so I mean you may have guessed we didn't

00:11:39,840 --> 00:11:44,550
develop our build system in a chaotic

00:11:41,760 --> 00:11:47,340
way thanksfully otherwise I wouldn't be

00:11:44,550 --> 00:11:51,780
giving a talk would still be unbailing

00:11:47,340 --> 00:11:54,540
hiding from my angry colleagues so no

00:11:51,780 --> 00:11:58,200
everything's fine instead of chaos we

00:11:54,540 --> 00:12:01,050
embraced consistency the three top level

00:11:58,200 --> 00:12:04,050
scripts configure build and run share a

00:12:01,050 --> 00:12:06,260
common architecture they only use

00:12:04,050 --> 00:12:09,390
modules from the Python standard library

00:12:06,260 --> 00:12:11,730
principally our class logging and sub

00:12:09,390 --> 00:12:14,970
process and they follow the same

00:12:11,730 --> 00:12:18,690
sequence of actions first we pass the

00:12:14,970 --> 00:12:22,620
arguments including finding the project

00:12:18,690 --> 00:12:25,020
zip file since it's the entry point then

00:12:22,620 --> 00:12:29,570
they figure out what the users the user

00:12:25,020 --> 00:12:29,570
wants to do and then they just do it

00:12:29,960 --> 00:12:36,390
more than just a common architecture

00:12:32,480 --> 00:12:40,520
these free scripts actually share a

00:12:36,390 --> 00:12:43,860
common design this design is made of

00:12:40,520 --> 00:12:45,750
design principles and by implementing

00:12:43,860 --> 00:12:49,290
these principles the scripts become

00:12:45,750 --> 00:12:52,680
easier to use maintain an extent now

00:12:49,290 --> 00:12:56,490
right now I want to share with you three

00:12:52,680 --> 00:12:59,970
of these design principles they are

00:12:56,490 --> 00:13:04,160
generic so you should be able to apply

00:12:59,970 --> 00:13:10,230
them to your own scripts first principle

00:13:04,160 --> 00:13:12,330
fail early loud and clear I don't really

00:13:10,230 --> 00:13:15,180
think I have to explain why but we'll go

00:13:12,330 --> 00:13:19,830
through an example just to be sure

00:13:15,180 --> 00:13:22,589
here is a small script we declare an

00:13:19,830 --> 00:13:26,520
argument buzzer with one argument target

00:13:22,589 --> 00:13:30,240
dear then we get the target directory

00:13:26,520 --> 00:13:33,720
actually out of the arguments and we

00:13:30,240 --> 00:13:39,690
count how many entries they are in Veda

00:13:33,720 --> 00:13:41,930
and we print it on the console when

00:13:39,690 --> 00:13:46,700
running the script on the hello world

00:13:41,930 --> 00:13:50,520
project there are six entrance

00:13:46,700 --> 00:13:53,210
everything stop now let's try to do the

00:13:50,520 --> 00:14:01,050
same thing on a non-existing director

00:13:53,210 --> 00:14:04,020
well exception so we get an error which

00:14:01,050 --> 00:14:06,360
is actually a platform specific error

00:14:04,020 --> 00:14:07,800
it's a Windows error so my colleague

00:14:06,360 --> 00:14:14,070
working on Mac won't even see the same

00:14:07,800 --> 00:14:15,990
thing here it's pretty easy to trace

00:14:14,070 --> 00:14:18,000
back where that error comes from then

00:14:15,990 --> 00:14:21,690
they are not so many lines in that

00:14:18,000 --> 00:14:23,460
script and it's pretty obvious what

00:14:21,690 --> 00:14:25,910
happened but if you have a really

00:14:23,460 --> 00:14:29,580
complex script which does a lot of thing

00:14:25,910 --> 00:14:31,800
it's really helpful to explain to the

00:14:29,580 --> 00:14:33,690
user what is wrong is what you typed on

00:14:31,800 --> 00:14:37,580
the common line it's not a bug in the

00:14:33,690 --> 00:14:40,590
script so how do we do that in Python

00:14:37,580 --> 00:14:43,580
well the trick is to check if the

00:14:40,590 --> 00:14:48,270
argument type as early as possible so

00:14:43,580 --> 00:14:50,730
here I have a function which basically

00:14:48,270 --> 00:14:53,580
takes a path figures out whether that

00:14:50,730 --> 00:14:57,290
path is a directory if it's not it

00:14:53,580 --> 00:15:03,270
raises an argument type error exception

00:14:57,290 --> 00:15:04,529
with comprehensive message otherwise it

00:15:03,270 --> 00:15:08,999
just returns the path

00:15:04,529 --> 00:15:12,569
and we use that function in the type of

00:15:08,999 --> 00:15:14,969
the argument so now I'm passing the

00:15:12,569 --> 00:15:18,449
arguments the arc passer will actually

00:15:14,969 --> 00:15:18,979
call that function and if everything is

00:15:18,449 --> 00:15:21,569
fine

00:15:18,979 --> 00:15:26,849
nothing changes still the same output

00:15:21,569 --> 00:15:29,639
the user sees the result but if the

00:15:26,849 --> 00:15:31,949
folder doesn't exist then we actually

00:15:29,639 --> 00:15:34,409
get an error message which is clear

00:15:31,949 --> 00:15:36,749
because now we know it's something wrong

00:15:34,409 --> 00:15:40,769
when passing the arguments and not a bug

00:15:36,749 --> 00:15:43,169
in the script so fail early loud and

00:15:40,769 --> 00:15:47,009
clear just to make the scripts easier to

00:15:43,169 --> 00:15:50,759
use the second design principle is

00:15:47,009 --> 00:15:52,729
support custom defaults so you might be

00:15:50,759 --> 00:15:55,679
wondering custom defaults

00:15:52,729 --> 00:16:00,779
don't really go together well let me

00:15:55,679 --> 00:16:04,279
explain I've showed you that

00:16:00,779 --> 00:16:07,349
Jib can also generate ninja build files

00:16:04,279 --> 00:16:09,689
ninja is not the default build tools on

00:16:07,349 --> 00:16:13,349
Windows and Mac but we support it

00:16:09,689 --> 00:16:15,869
because it's pretty fast so if I want to

00:16:13,349 --> 00:16:18,869
configure the hello world project with

00:16:15,869 --> 00:16:22,979
ninja then I could configure the

00:16:18,869 --> 00:16:27,329
complete script with - - ninja I get the

00:16:22,979 --> 00:16:29,789
output with extra ninja indication then

00:16:27,329 --> 00:16:32,879
I call the build script with - - Lucia

00:16:29,789 --> 00:16:34,379
and I get the ninja output and then I

00:16:32,879 --> 00:16:37,199
can run the hello world and everything

00:16:34,379 --> 00:16:41,830
is the same it's the same C++ code and

00:16:37,199 --> 00:16:45,399
the compiler course should be identical

00:16:41,830 --> 00:16:47,589
but I'm a lazy man I don't want to tap -

00:16:45,399 --> 00:16:51,820
- ninja every time I call configure or

00:16:47,589 --> 00:16:58,180
build and I do that a lot every day so

00:16:51,820 --> 00:17:02,440
to solve that issue we've created a way

00:16:58,180 --> 00:17:06,150
to have custom defaults so in a file

00:17:02,440 --> 00:17:10,329
which again is a Python the channel

00:17:06,150 --> 00:17:14,020
users can write what they want to be

00:17:10,329 --> 00:17:17,709
given to the arc passer as the first

00:17:14,020 --> 00:17:19,870
argument so these arguments go at the

00:17:17,709 --> 00:17:21,910
beginning and then whatever they put on

00:17:19,870 --> 00:17:23,439
the comment line goes next

00:17:21,910 --> 00:17:28,089
so they can always on the comment line

00:17:23,439 --> 00:17:34,179
override anything that is in the dot

00:17:28,089 --> 00:17:37,840
ossified so there's one dot ASCII file

00:17:34,179 --> 00:17:41,590
user in the user folder then they can

00:17:37,840 --> 00:17:43,390
they can be one assi file per build

00:17:41,590 --> 00:17:45,730
system repository so when you have

00:17:43,390 --> 00:17:48,309
several working copies it can be useful

00:17:45,730 --> 00:17:51,850
to have different settings based on the

00:17:48,309 --> 00:17:54,400
working copy so this file is get ignored

00:17:51,850 --> 00:17:57,850
it's not checked in the build system

00:17:54,400 --> 00:18:00,160
repository and then also said common

00:17:57,850 --> 00:18:02,260
line arguments at the end takes

00:18:00,160 --> 00:18:06,840
precedence since the are quaza

00:18:02,260 --> 00:18:06,840
reads the arguments from left to right

00:18:06,970 --> 00:18:14,919
so now with the content of the assi file

00:18:12,479 --> 00:18:17,200
including - - ninja when Colleen

00:18:14,919 --> 00:18:22,960
configured at PI and Bill dot pi I can't

00:18:17,200 --> 00:18:26,460
just call configure and call build and I

00:18:22,960 --> 00:18:26,460
don't have to type anything else

00:18:26,580 --> 00:18:34,869
now the third design principle do not

00:18:30,609 --> 00:18:37,149
integrate project specific features so

00:18:34,869 --> 00:18:40,419
the build system repository is

00:18:37,149 --> 00:18:44,080
completely live agnostic it doesn't know

00:18:40,419 --> 00:18:47,639
that it's used by life it can be used

00:18:44,080 --> 00:18:49,749
actually to build any C++ applications

00:18:47,639 --> 00:18:53,859
if we have a look at the build system

00:18:49,749 --> 00:18:57,159
repository and how its composed we saw

00:18:53,859 --> 00:19:02,139
this jab they are the three main scripts

00:18:57,159 --> 00:19:07,479
and to share code between the three main

00:19:02,139 --> 00:19:11,349
scripts there's a Python module which

00:19:07,479 --> 00:19:13,989
contains functions for argument passing

00:19:11,349 --> 00:19:17,249
like the existing G function I've just

00:19:13,989 --> 00:19:20,729
shown functions for getting the default

00:19:17,249 --> 00:19:23,830
arguments based on the platform and

00:19:20,729 --> 00:19:25,720
function to figure out where is the

00:19:23,830 --> 00:19:27,450
top-level zip file so there are some

00:19:25,720 --> 00:19:30,210
heuristic so

00:19:27,450 --> 00:19:32,639
as you as you've seen I don't have to

00:19:30,210 --> 00:19:34,710
specify where is the hello world that

00:19:32,639 --> 00:19:38,429
chip or the light that chip file when

00:19:34,710 --> 00:19:40,409
calling configure and build so now for

00:19:38,429 --> 00:19:43,740
this example it's imagine there is a

00:19:40,409 --> 00:19:48,539
fourth script because configure build

00:19:43,740 --> 00:19:52,010
and run are pretty big pretty complex so

00:19:48,539 --> 00:19:54,539
let's just go with a simple arc passer

00:19:52,010 --> 00:19:59,610
here is the content of the simple art

00:19:54,539 --> 00:20:02,610
puzzle we import octopus obviously we

00:19:59,610 --> 00:20:06,360
import constants from a build system but

00:20:02,610 --> 00:20:08,399
then we can use to define to specify the

00:20:06,360 --> 00:20:10,260
default value of the first argument

00:20:08,399 --> 00:20:13,100
which is the platform then we have the

00:20:10,260 --> 00:20:16,260
word size and then we have the linking

00:20:13,100 --> 00:20:19,110
and this script only prints the content

00:20:16,260 --> 00:20:21,960
of the argument namespace nothing fancy

00:20:19,110 --> 00:20:25,409
so let's call it just to see how it

00:20:21,960 --> 00:20:27,630
looks here we go just prints linking is

00:20:25,409 --> 00:20:34,039
the ll platform is win and what are the

00:20:27,630 --> 00:20:36,299
64 since these are the default values

00:20:34,039 --> 00:20:39,750
now let's go back to the hello world

00:20:36,299 --> 00:20:43,889
project in the hello world project I

00:20:39,750 --> 00:20:47,909
would like to call this script with I

00:20:43,889 --> 00:20:52,289
don't know a specific argument that I

00:20:47,909 --> 00:20:55,409
really would like to have so here we

00:20:52,289 --> 00:20:58,080
could imagine that we want the hello

00:20:55,409 --> 00:21:00,210
world to change the language so instead

00:20:58,080 --> 00:21:05,250
of saying hello world it would say boat

00:21:00,210 --> 00:21:07,220
whole amount of halal mundo whatever so

00:21:05,250 --> 00:21:10,019
we give the language on the command line

00:21:07,220 --> 00:21:12,670
obviously that won't work for now there

00:21:10,019 --> 00:21:17,890
is no such argument

00:21:12,670 --> 00:21:20,910
so now I might be a bit sneaky and ask

00:21:17,890 --> 00:21:26,980
can we add that to build system please

00:21:20,910 --> 00:21:30,540
no we do not integrate project-specific

00:21:26,980 --> 00:21:34,060
features ever because it adds

00:21:30,540 --> 00:21:36,580
maintenance cost and it leads to API

00:21:34,060 --> 00:21:38,500
breaking changes as soon as another

00:21:36,580 --> 00:21:41,140
project starts using that feature and

00:21:38,500 --> 00:21:46,300
when the original projects decides to

00:21:41,140 --> 00:21:50,890
chain to change it so no instead we make

00:21:46,300 --> 00:21:54,910
it easy to write script extensions so

00:21:50,890 --> 00:21:58,270
here we're back to the simple ugh buzzer

00:21:54,910 --> 00:22:01,140
script with some space because I'm gonna

00:21:58,270 --> 00:22:06,250
fill the blanks first thing we do is

00:22:01,140 --> 00:22:10,120
include another module from the build

00:22:06,250 --> 00:22:14,250
system then we create the script

00:22:10,120 --> 00:22:17,560
extension I will come back to that part

00:22:14,250 --> 00:22:20,590
in a few slides but basically we create

00:22:17,560 --> 00:22:23,200
the extension and then afterwards we use

00:22:20,590 --> 00:22:26,650
it so we have a function called extent

00:22:23,200 --> 00:22:28,810
arc passer before which we put before

00:22:26,650 --> 00:22:30,910
defining the other argument and another

00:22:28,810 --> 00:22:35,590
function called extent out buzzer after

00:22:30,910 --> 00:22:38,170
that we put after so this is the only

00:22:35,590 --> 00:22:41,080
thing we have to write in the build

00:22:38,170 --> 00:22:44,920
system script now let's see how it works

00:22:41,080 --> 00:22:47,390
in the top-level projects the first

00:22:44,920 --> 00:22:49,520
thing they have to do

00:22:47,390 --> 00:22:53,570
so the first thing hello world has to do

00:22:49,520 --> 00:22:56,510
here is create a bathroom module named

00:22:53,570 --> 00:23:01,100
build system extensions that's the

00:22:56,510 --> 00:23:06,530
convention it has to be like this and in

00:23:01,100 --> 00:23:10,040
that module we can there should be one

00:23:06,530 --> 00:23:13,100
file at least for now called simple arc

00:23:10,040 --> 00:23:16,370
buzzer and this file matches the name of

00:23:13,100 --> 00:23:20,120
the extension that was created here we

00:23:16,370 --> 00:23:21,860
define only one of the two functions so

00:23:20,120 --> 00:23:25,700
here we define the extent arc passer

00:23:21,860 --> 00:23:31,730
after and now when we call the script

00:23:25,700 --> 00:23:36,850
with our specific argument it works no

00:23:31,730 --> 00:23:38,530
errors so how does that black magic

00:23:36,850 --> 00:23:42,970
happens

00:23:38,530 --> 00:23:48,830
well first as I told you where is a

00:23:42,970 --> 00:23:51,410
script extensions Python module and in

00:23:48,830 --> 00:23:55,280
that module always a function called get

00:23:51,410 --> 00:23:57,110
script extension when calling that

00:23:55,280 --> 00:24:01,280
function we pass two things the first

00:23:57,110 --> 00:24:04,309
thing to pass is the script name and the

00:24:01,280 --> 00:24:06,290
minimal API so the minimal pie will

00:24:04,309 --> 00:24:09,490
define what are the functions that the

00:24:06,290 --> 00:24:09,490
extension has

00:24:12,090 --> 00:24:20,310
and now we go into the dirty deeds so

00:24:16,290 --> 00:24:28,320
who has ever done the first line import

00:24:20,310 --> 00:24:31,980
I am P okay less than ten so this is the

00:24:28,320 --> 00:24:35,400
low-level way of importing a Python

00:24:31,980 --> 00:24:36,360
module the first thing you have to do is

00:24:35,400 --> 00:24:40,110
to find it

00:24:36,360 --> 00:24:44,310
like sorry

00:24:40,110 --> 00:24:48,180
using collect a list of paths where that

00:24:44,310 --> 00:24:49,950
module could be and the name it has then

00:24:48,180 --> 00:24:53,100
if it has been found you can actually

00:24:49,950 --> 00:24:56,820
load it then there is a bit more craft

00:24:53,100 --> 00:24:58,530
to handle closing files and whatnot but

00:24:56,820 --> 00:25:00,630
what you have to keep in mind here is

00:24:58,530 --> 00:25:04,290
that now we have a function called find

00:25:00,630 --> 00:25:06,750
and load find and load module and this

00:25:04,290 --> 00:25:10,890
is now really useful to create the

00:25:06,750 --> 00:25:13,980
script extension so creating the script

00:25:10,890 --> 00:25:16,380
injection for real so we're back to

00:25:13,980 --> 00:25:18,810
describing that CAD script extension

00:25:16,380 --> 00:25:23,160
function takes two arguments the script

00:25:18,810 --> 00:25:26,070
name and the minimal API so the first

00:25:23,160 --> 00:25:29,310
thing to do is to find the build system

00:25:26,070 --> 00:25:31,350
extension module so the one I told you

00:25:29,310 --> 00:25:34,310
this is by convention it's hard words

00:25:31,350 --> 00:25:40,240
and we basically do that by just going

00:25:34,310 --> 00:25:45,190
up on the tree structure

00:25:40,240 --> 00:25:48,550
and listing all the parent quarters so

00:25:45,190 --> 00:25:51,520
we start at the hello world repository

00:25:48,550 --> 00:25:55,750
and then just go up up up up until the

00:25:51,520 --> 00:25:59,590
root of the drive and if in any of these

00:25:55,750 --> 00:26:01,630
folders varies a folder name built the

00:25:59,590 --> 00:26:04,240
same extension actually not just a

00:26:01,630 --> 00:26:09,160
folder a Python module name extensions

00:26:04,240 --> 00:26:11,850
then it is loaded and if we found it

00:26:09,160 --> 00:26:15,430
then we can try to find inside it a

00:26:11,850 --> 00:26:18,970
module which has this desired script

00:26:15,430 --> 00:26:21,970
name if nothing has been found that can

00:26:18,970 --> 00:26:25,300
happen because maybe the user the hello

00:26:21,970 --> 00:26:28,030
world project or another project has to

00:26:25,300 --> 00:26:31,450
find any extension the script extension

00:26:28,030 --> 00:26:34,300
is just a Demi empty object and then we

00:26:31,450 --> 00:26:37,750
iterate over each attribute of the

00:26:34,300 --> 00:26:39,940
minimal API and if the script extension

00:26:37,750 --> 00:26:43,570
doesn't have that attribute yet we just

00:26:39,940 --> 00:26:45,450
set it so that way the script extension

00:26:43,570 --> 00:26:46,690
that is written by this function is

00:26:45,450 --> 00:26:49,690
complete

00:26:46,690 --> 00:26:51,580
so the script that is using this object

00:26:49,690 --> 00:26:54,870
doesn't have to check whether the

00:26:51,580 --> 00:26:58,990
attributes exist and it can just rely on

00:26:54,870 --> 00:27:02,010
this minimal API being complete and yeah

00:26:58,990 --> 00:27:02,010
just work

00:27:03,410 --> 00:27:13,880
to wrap it up we're building life with

00:27:08,090 --> 00:27:14,420
Python and to echo the title of the the

00:27:13,880 --> 00:27:17,680
talk

00:27:14,420 --> 00:27:23,200
Python is indeed the key stone since

00:27:17,680 --> 00:27:23,200
without Python nobody can work on life

00:27:27,280 --> 00:27:34,340
about the design principles the thing to

00:27:32,030 --> 00:27:37,220
remember is that having some is good it

00:27:34,340 --> 00:27:39,650
helps you write better code but knowing

00:27:37,220 --> 00:27:43,160
and sharing them is better so I bet you

00:27:39,650 --> 00:27:45,580
to come to me and to your fellow your

00:27:43,160 --> 00:27:48,080
pythonista and share whatever design

00:27:45,580 --> 00:27:49,970
principles you are using in your code

00:27:48,080 --> 00:27:52,700
and in your scripts to make them better

00:27:49,970 --> 00:27:56,690
so then all together we can make the

00:27:52,700 --> 00:27:58,990
users of our scripts happy thank you for

00:27:56,690 --> 00:27:58,990
attention

00:28:04,009 --> 00:28:13,200
we actually have like a lot of time for

00:28:06,809 --> 00:28:15,269
questions so raise hands please yeah I

00:28:13,200 --> 00:28:17,399
said just a small question I was

00:28:15,269 --> 00:28:19,169
wondering why would you why did you

00:28:17,399 --> 00:28:21,330
decide to include the build system

00:28:19,169 --> 00:28:31,259
masses as a model instead of packaging

00:28:21,330 --> 00:28:35,309
in that deploying it we have kind of a

00:28:31,259 --> 00:28:38,249
history at every turn of having

00:28:35,309 --> 00:28:40,889
everything in the repository I mean

00:28:38,249 --> 00:28:45,119
almost everything so we obviously don't

00:28:40,889 --> 00:28:47,159
have the C++ compiler we don't have the

00:28:45,119 --> 00:28:49,940
Python interpreter itself but all the

00:28:47,159 --> 00:28:54,659
code we run we compiling we use is

00:28:49,940 --> 00:28:57,509
inside the live repository so having the

00:28:54,659 --> 00:28:58,919
same module so so so then that means

00:28:57,509 --> 00:29:00,599
that if you want to pick something like

00:28:58,919 --> 00:29:02,099
that hotfix or anything for your

00:29:00,599 --> 00:29:05,309
libraries you actually have to update

00:29:02,099 --> 00:29:09,450
your sub model right yes how its

00:29:05,309 --> 00:29:12,479
experience going that way I'm not I'm

00:29:09,450 --> 00:29:15,809
not saying that's bad no no it's fine

00:29:12,479 --> 00:29:20,779
we have done way more acrobatic things I

00:29:15,809 --> 00:29:23,929
think recent modules and so please

00:29:20,779 --> 00:29:23,929
somewhere else

00:29:25,909 --> 00:29:31,429
did you think about using waffles core

00:29:29,600 --> 00:29:36,529
scones instead of building your own

00:29:31,429 --> 00:29:41,510
build system so yeah so python-based

00:29:36,529 --> 00:29:47,179
yeah I know so the thing is laughs and

00:29:41,510 --> 00:29:51,169
scones called the compiler directly but

00:29:47,179 --> 00:29:55,100
we are really attached to using certain

00:29:51,169 --> 00:29:56,720
IDs like Xcode I know that Mac

00:29:55,100 --> 00:29:59,960
developers really like to use the tool

00:29:56,720 --> 00:30:03,260
and unfortunately Xcode only works if

00:29:59,960 --> 00:30:06,409
you have an actual Xcode project so deep

00:30:03,260 --> 00:30:08,899
being able to generate project files

00:30:06,409 --> 00:30:13,580
that are really look alike but really

00:30:08,899 --> 00:30:16,789
look like the native projects was a big

00:30:13,580 --> 00:30:19,990
plus and then the build system

00:30:16,789 --> 00:30:26,710
repository is merely a wrapper around

00:30:19,990 --> 00:30:26,710
Jib more questions

00:30:30,919 --> 00:30:42,649
the talkies being retorted so dumb

00:30:37,889 --> 00:30:45,989
question but did you look at Simic yes

00:30:42,649 --> 00:30:48,659
yes we looked at to make and we actually

00:30:45,989 --> 00:30:51,649
have a colleague who is one of the main

00:30:48,659 --> 00:30:55,590
maintainer of Simic

00:30:51,649 --> 00:30:58,379
the thing is that when the transition

00:30:55,590 --> 00:31:00,239
was made from the make files and Visual

00:30:58,379 --> 00:31:03,840
Studio that were checked in the library

00:31:00,239 --> 00:31:10,080
history to at that time Simic was

00:31:03,840 --> 00:31:18,590
still pretty annoying and but nowadays

00:31:10,080 --> 00:31:22,200
it's a viable option later our questions

00:31:18,590 --> 00:31:26,100
have one myself how do you actually do

00:31:22,200 --> 00:31:29,820
do you support dynamic loading like you

00:31:26,100 --> 00:31:32,609
have gone through the packages and going

00:31:29,820 --> 00:31:35,549
up like records in the directories to

00:31:32,609 --> 00:31:38,159
the parents looking for modules but how

00:31:35,549 --> 00:31:41,450
do you actually set up the order in

00:31:38,159 --> 00:31:41,450
which they are executed

00:31:45,360 --> 00:31:54,030
here basically the all parent folders

00:31:49,140 --> 00:31:55,590
function returns a list or no I think

00:31:54,030 --> 00:31:59,549
it's even a that's a generator but

00:31:55,590 --> 00:32:01,530
anyway it's so the list of the current

00:31:59,549 --> 00:32:03,360
folder and when its parent folder and

00:32:01,530 --> 00:32:06,570
when it's spam folder into the root and

00:32:03,360 --> 00:32:13,790
just because of the order in which the

00:32:06,570 --> 00:32:16,830
paths are yeah we have to go back here

00:32:13,790 --> 00:32:19,530
the find module function which takes all

00:32:16,830 --> 00:32:22,410
this path just does it for you so you

00:32:19,530 --> 00:32:25,860
just have a one extension you can only

00:32:22,410 --> 00:32:28,200
look for one file yeah so the first much

00:32:25,860 --> 00:32:30,480
build system extensions Python module

00:32:28,200 --> 00:32:33,210
that matches is the one loaded and

00:32:30,480 --> 00:32:39,179
that's the default behavior of Python

00:32:33,210 --> 00:32:42,419
for any kind of module I have you

00:32:39,179 --> 00:32:45,210
absolutely looked into them with setup

00:32:42,419 --> 00:32:50,340
tools you have like entry points and you

00:32:45,210 --> 00:32:53,400
can register like extensions if you want

00:32:50,340 --> 00:32:55,740
to have a look they it's not like if you

00:32:53,400 --> 00:32:58,320
have seen truck for example or PI test

00:32:55,740 --> 00:33:00,480
they load their functions like setting

00:32:58,320 --> 00:33:02,910
up extension points which you can

00:33:00,480 --> 00:33:05,910
actually extend through touch points and

00:33:02,910 --> 00:33:07,080
yeah dynamic although it doesn't look

00:33:05,910 --> 00:33:10,710
like you need it

00:33:07,080 --> 00:33:12,450
but yeah actually Indian we were pretty

00:33:10,710 --> 00:33:21,290
happy about the number of lines it is

00:33:12,450 --> 00:33:21,290

YouTube URL: https://www.youtube.com/watch?v=zZPGRV5Kw70


