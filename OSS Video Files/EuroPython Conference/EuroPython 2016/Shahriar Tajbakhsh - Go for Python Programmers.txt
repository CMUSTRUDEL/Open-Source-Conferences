Title: Shahriar Tajbakhsh - Go for Python Programmers
Publication date: 2016-07-29
Playlist: EuroPython 2016
Description: 
	Shahriar Tajbakhsh - Go for Python Programmers
[EuroPython 2016]
[19 July 2016]
[Bilbao, Euskadi, Spain]
(https://ep2016.europython.eu//conference/talks/go-for-python-programmers)

A side-by-side walkthrough of basic Go history, syntax, semantics and
tools compared to Python.

-----

There's been quite a bit of hype around Go for some time. In
particular within the Python community, we've seen some engineers
moving their stack from Python to Go or starting their new project in
Go. This talk is **not** about whether you should move from Python to
Go. Instead, this talk is for those who've been hearing all about all
the hype but haven't yet had a chance to take a proper look at Go.

We'll first _very_ briefly look at Go and Python's history. Then we'll
go through a high-level side-by-side walkthrough of basic Go syntax
and semantics compared to Python. Finally, we'll have a brief look at
a subset of the ecosystem and tools available to Go and Python
programmers for certain tasks such as testing, code formatting,
documentation generation etc.

By the end, you will not be a Go programmer but you'll have a high-
level feel for how the Go language operates.
Captions: 
	00:00:00,000 --> 00:00:15,540
so let's welcome shower with the talk go

00:00:03,300 --> 00:00:17,550
for Brighton developers thank you so we

00:00:15,540 --> 00:00:20,340
talked about go for Python programmers

00:00:17,550 --> 00:00:23,189
as a way of introduction my name is

00:00:20,340 --> 00:00:26,220
sherry are I'm a software engineer based

00:00:23,189 --> 00:00:27,869
in london i work at Oscar Oscar is a

00:00:26,220 --> 00:00:31,489
pretty cool company that we can talk

00:00:27,869 --> 00:00:34,020
about after talk if you're interested

00:00:31,489 --> 00:00:37,579
before I start I think I owe everyone an

00:00:34,020 --> 00:00:41,010
apology as I spent more and more time

00:00:37,579 --> 00:00:44,399
preparing this talk I realized it's

00:00:41,010 --> 00:00:47,670
probably not a great idea and it's not a

00:00:44,399 --> 00:00:50,090
great idea because it implies that we

00:00:47,670 --> 00:00:53,780
should use go as we would use Python and

00:00:50,090 --> 00:00:56,969
that results in onion idiomatic go code

00:00:53,780 --> 00:01:00,030
and it's just not it's just not a good

00:00:56,969 --> 00:01:02,129
idea and then I thought about a bit more

00:01:00,030 --> 00:01:07,110
and I was still convinced a bad idea

00:01:02,129 --> 00:01:09,210
this morning but I've done it now but my

00:01:07,110 --> 00:01:10,860
intention here is not to write go code

00:01:09,210 --> 00:01:14,610
like you write Python or write Python

00:01:10,860 --> 00:01:19,590
like you write go I think it's just as a

00:01:14,610 --> 00:01:21,330
way to compare two three languages more

00:01:19,590 --> 00:01:24,030
so I think this is probably more

00:01:21,330 --> 00:01:27,450
appropriate as a go conference not sure

00:01:24,030 --> 00:01:29,850
why it brought it to python but europe

00:01:27,450 --> 00:01:32,280
iphone but you know I spent the time now

00:01:29,850 --> 00:01:34,409
and we might as well have a go at it

00:01:32,280 --> 00:01:35,939
it's quite interesting regardless as

00:01:34,409 --> 00:01:39,030
long as we know that intention is not to

00:01:35,939 --> 00:01:41,790
write code like Python because why would

00:01:39,030 --> 00:01:43,920
you ever do that the talk structure is

00:01:41,790 --> 00:01:46,530
we're going to quickly go over some

00:01:43,920 --> 00:01:48,659
history very very basic brief history of

00:01:46,530 --> 00:01:50,939
the two languages then talk about

00:01:48,659 --> 00:01:54,570
general syntax or semantics compassion

00:01:50,939 --> 00:01:56,250
and finally one thing that I think is

00:01:54,570 --> 00:01:58,380
quite interesting because pythons very

00:01:56,250 --> 00:02:01,170
strong at it he's talking about like the

00:01:58,380 --> 00:02:04,740
ecosystems and tools available to

00:02:01,170 --> 00:02:06,630
developers to set the expectation this

00:02:04,740 --> 00:02:09,000
kind of theirs expected that you have

00:02:06,630 --> 00:02:10,709
some knowledge of Python at least to be

00:02:09,000 --> 00:02:13,020
able to make the comparison no

00:02:10,709 --> 00:02:17,580
particular knowledge of go required

00:02:13,020 --> 00:02:20,010
the depth at which we discussed go is

00:02:17,580 --> 00:02:22,610
not necessarily something intense it's

00:02:20,010 --> 00:02:26,160
going to be very brief very high level

00:02:22,610 --> 00:02:27,960
if anyone's in for a deep dive into for

00:02:26,160 --> 00:02:30,390
example comparing a sink I owego

00:02:27,960 --> 00:02:34,170
routines that's probably its own talk

00:02:30,390 --> 00:02:38,370
it's not going to be here but we can

00:02:34,170 --> 00:02:39,960
start with some history so go well let's

00:02:38,370 --> 00:02:43,050
start with Python Python first appeared

00:02:39,960 --> 00:02:48,000
around 90 91 and we know it was

00:02:43,050 --> 00:02:49,380
influenced a lot by ABC which was a by

00:02:48,000 --> 00:02:52,080
the name it was meant to be very simple

00:02:49,380 --> 00:02:54,030
programming language to learn I said to

00:02:52,080 --> 00:02:55,860
a Python a lot of pythons philosophy is

00:02:54,030 --> 00:03:01,680
from ABC and a bunch of other stuff

00:02:55,860 --> 00:03:04,920
Algol 68 Haskell modular 3 etc go on the

00:03:01,680 --> 00:03:08,520
other hand is very young 2009 was around

00:03:04,920 --> 00:03:11,550
the first time it appeared but did

00:03:08,520 --> 00:03:14,130
languages that influenced it still go

00:03:11,550 --> 00:03:18,330
way back so there is stuff like I'll go

00:03:14,130 --> 00:03:20,970
60 and pasco see fig influence but there

00:03:18,330 --> 00:03:22,290
is also one of the key things about go

00:03:20,970 --> 00:03:24,420
we'll talk about later is the

00:03:22,290 --> 00:03:26,190
concurrency and that was influenced by

00:03:24,420 --> 00:03:28,050
CSV which is not necessarily language

00:03:26,190 --> 00:03:30,060
also provide that later we're going to

00:03:28,050 --> 00:03:32,400
write it worry about to now but was he

00:03:30,060 --> 00:03:35,430
goes quite young it's been quite popular

00:03:32,400 --> 00:03:37,770
but Python obviously huge history it's

00:03:35,430 --> 00:03:42,990
been going on for a while or huge you

00:03:37,770 --> 00:03:46,709
know 1991 to start for syntax and

00:03:42,990 --> 00:03:48,840
semantics i think the most boring thing

00:03:46,709 --> 00:03:51,720
to do which i've done would be to just

00:03:48,840 --> 00:03:53,580
to a simple hello world and go over the

00:03:51,720 --> 00:03:56,459
basics and then like tryin to get bit

00:03:53,580 --> 00:03:59,700
deeper so we can see on the you're right

00:03:56,459 --> 00:04:01,920
the hello world in python with the weird

00:03:59,700 --> 00:04:04,020
caveat that I've half of an extra weird

00:04:01,920 --> 00:04:06,330
variable declaration that's just to show

00:04:04,020 --> 00:04:09,600
the example for declaration assignment

00:04:06,330 --> 00:04:13,020
and on the left is the go on and the

00:04:09,600 --> 00:04:15,810
thing about go is every go file has to

00:04:13,020 --> 00:04:18,570
have a package name for example so the

00:04:15,810 --> 00:04:20,549
first line I've ever go file is usually

00:04:18,570 --> 00:04:22,380
Pakistan it should be a comment so then

00:04:20,549 --> 00:04:23,790
after the first real line of any go file

00:04:22,380 --> 00:04:27,630
would be a package

00:04:23,790 --> 00:04:29,490
and that is pretty explicit and it's

00:04:27,630 --> 00:04:30,810
interesting in Python Packers work a bit

00:04:29,490 --> 00:04:33,270
differently you kind of know it from the

00:04:30,810 --> 00:04:37,830
directory if the director is a package

00:04:33,270 --> 00:04:41,490
of Python to butt in go that is super

00:04:37,830 --> 00:04:42,990
explicit you have to have the package

00:04:41,490 --> 00:04:48,780
declaration at the beginning of each

00:04:42,990 --> 00:04:49,950
file and the every single file go for

00:04:48,780 --> 00:04:52,110
that you put in the same directory has

00:04:49,950 --> 00:04:53,790
the same package again very explicit if

00:04:52,110 --> 00:04:55,500
everything is directly through every

00:04:53,790 --> 00:04:56,940
file in that directory will have package

00:04:55,500 --> 00:04:58,320
through at the top of it so when you're

00:04:56,940 --> 00:04:59,580
working with it you just go right to the

00:04:58,320 --> 00:05:03,860
top you know exactly what package you're

00:04:59,580 --> 00:05:05,850
in I quite like being explicit so does

00:05:03,860 --> 00:05:09,810
every other pipe in programmer I guess

00:05:05,850 --> 00:05:15,090
but the next thing typically like most

00:05:09,810 --> 00:05:16,710
bison files or import statements and it

00:05:15,090 --> 00:05:20,640
is very soon recycling you import

00:05:16,710 --> 00:05:22,380
packages there is no concept of you know

00:05:20,640 --> 00:05:23,580
patches on modules so you don't say from

00:05:22,380 --> 00:05:25,050
something import something you know so

00:05:23,580 --> 00:05:28,380
you generally import the whole package

00:05:25,050 --> 00:05:29,490
and then you can use that if you have

00:05:28,380 --> 00:05:31,320
multiple packages you put them on

00:05:29,490 --> 00:05:34,380
separate lines it doesn't matter how it

00:05:31,320 --> 00:05:36,900
works because it's quite simple you kind

00:05:34,380 --> 00:05:39,090
of use a parenthesis and then you just

00:05:36,900 --> 00:05:41,360
say import once and you just list

00:05:39,090 --> 00:05:44,940
everything in strength it doesn't matter

00:05:41,360 --> 00:05:47,060
and then there are also functions you

00:05:44,940 --> 00:05:49,890
know like there would be in any language

00:05:47,060 --> 00:05:51,480
we'll talk about this later they're

00:05:49,890 --> 00:05:53,640
weird thing that I put there which is a

00:05:51,480 --> 00:05:55,310
kind of Declaration and assignment that

00:05:53,640 --> 00:05:57,750
is not necessary with just to go over

00:05:55,310 --> 00:06:00,480
how that would work so for example text

00:05:57,750 --> 00:06:02,820
in this case is a string now one thing I

00:06:00,480 --> 00:06:05,640
didn't mention so go is statically typed

00:06:02,820 --> 00:06:08,190
with Prince poison being dynamically

00:06:05,640 --> 00:06:10,680
typed and in this case we haven't really

00:06:08,190 --> 00:06:15,150
said Texas string but the compiler can

00:06:10,680 --> 00:06:22,140
infer that we'll talk a little bit about

00:06:15,150 --> 00:06:24,540
that later speaking of declaration and

00:06:22,140 --> 00:06:29,700
types we can do a quick comparison of

00:06:24,540 --> 00:06:32,460
types in go on Python generally speaking

00:06:29,700 --> 00:06:35,669
there are kind of four types in go so we

00:06:32,460 --> 00:06:36,939
have the normal basic types and we look

00:06:35,669 --> 00:06:39,620
at them a bit

00:06:36,939 --> 00:06:41,379
we look at the list in a bit which is

00:06:39,620 --> 00:06:43,969
you have the instant flutes and stuff

00:06:41,379 --> 00:06:46,729
you have the aggregate types like a

00:06:43,969 --> 00:06:50,300
struct again we look at later the

00:06:46,729 --> 00:06:52,659
reference types like a nap and there is

00:06:50,300 --> 00:06:56,180
one thing there's an interface type that

00:06:52,659 --> 00:06:57,379
kind of doesn't exist in Python and I

00:06:56,180 --> 00:07:00,860
say kind of because we'll see

00:06:57,379 --> 00:07:04,789
conceptually Python uses it and there we

00:07:00,860 --> 00:07:06,379
do have the ABC staff but they work with

00:07:04,789 --> 00:07:10,340
different to how it works and go so

00:07:06,379 --> 00:07:12,340
we'll get to that shortly as well but as

00:07:10,340 --> 00:07:16,659
far as the basic data types are concerns

00:07:12,340 --> 00:07:19,099
go gives you a bit more granular types

00:07:16,659 --> 00:07:21,050
which is what you would expect because

00:07:19,099 --> 00:07:24,349
it statically typed so you kind of want

00:07:21,050 --> 00:07:28,039
to be a bitwise with what you choose so

00:07:24,349 --> 00:07:29,900
you have many different bits events and

00:07:28,039 --> 00:07:33,830
unsigned int in Python they're all just

00:07:29,900 --> 00:07:35,960
long you have again different sized

00:07:33,830 --> 00:07:38,240
floats in Python the disclosed we don't

00:07:35,960 --> 00:07:40,039
really need to care about how many bits

00:07:38,240 --> 00:07:42,740
there are in Python although we can if

00:07:40,039 --> 00:07:45,349
you want to do and then you have complex

00:07:42,740 --> 00:07:49,159
bulan string I guess pooling and string

00:07:45,349 --> 00:07:54,770
are pretty standard complex useful too

00:07:49,159 --> 00:07:56,120
so they're in turn you in as you know

00:07:54,770 --> 00:07:57,469
we're not specifying how many bits are

00:07:56,120 --> 00:08:00,409
in there that system dependent is

00:07:57,469 --> 00:08:02,710
usually 32 or 64 bits but it depends on

00:08:00,409 --> 00:08:04,789
the system where you're compiling

00:08:02,710 --> 00:08:09,289
nothing we need to worry about for the

00:08:04,789 --> 00:08:14,839
purpose of this talk the other category

00:08:09,289 --> 00:08:17,120
of taught types war aggro types one of

00:08:14,839 --> 00:08:19,370
them is an array which an array arrays

00:08:17,120 --> 00:08:21,500
are just fixed length sequence of 0 more

00:08:19,370 --> 00:08:23,870
elements of a particular type now

00:08:21,500 --> 00:08:26,449
they're not really lists in Python

00:08:23,870 --> 00:08:30,319
they're really more Python arrays that

00:08:26,449 --> 00:08:33,769
you can also use you know because they

00:08:30,319 --> 00:08:35,479
have to be tight and we'll show there is

00:08:33,769 --> 00:08:37,610
a concert there is something similar to

00:08:35,479 --> 00:08:40,849
lists in Python as well and go but

00:08:37,610 --> 00:08:43,640
they're not a raise and struct struct is

00:08:40,849 --> 00:08:45,560
just you know the thing you use as to

00:08:43,640 --> 00:08:48,110
contain certain fields inside it it

00:08:45,560 --> 00:08:50,870
could be soon it's classes seem to name

00:08:48,110 --> 00:08:54,300
so for which is really a class but what

00:08:50,870 --> 00:08:56,759
but it isn't you know it's not apples to

00:08:54,300 --> 00:08:58,709
apples but you typically you struct

00:08:56,759 --> 00:09:02,399
where you would probably use a class in

00:08:58,709 --> 00:09:05,579
Python or a dick or you know that kind

00:09:02,399 --> 00:09:10,259
of having fields and put you know to

00:09:05,579 --> 00:09:15,240
create a certain content then we have

00:09:10,259 --> 00:09:18,779
the reference types slices or the things

00:09:15,240 --> 00:09:20,160
that are very similar to list generally

00:09:18,779 --> 00:09:23,759
speaking you wouldn't want to work with

00:09:20,160 --> 00:09:26,370
arrays in go you have slices and slice

00:09:23,759 --> 00:09:28,050
is a kind of heart of an array and then

00:09:26,370 --> 00:09:30,139
you can do all sorts of stuff you would

00:09:28,050 --> 00:09:32,790
list with them through pretty powerful

00:09:30,139 --> 00:09:37,379
maps or basically dicks there are hash

00:09:32,790 --> 00:09:39,000
maps and yeah very similar nothing

00:09:37,379 --> 00:09:41,279
different there there's also this

00:09:39,000 --> 00:09:43,800
rational side called the channels and go

00:09:41,279 --> 00:09:46,560
that I come there is no equivalent

00:09:43,800 --> 00:09:48,990
Python really channels will talk about

00:09:46,560 --> 00:09:51,480
later or the way are used for

00:09:48,990 --> 00:09:57,029
concurrency and for like two processes

00:09:51,480 --> 00:09:58,439
to talk to each other and there an

00:09:57,029 --> 00:10:02,069
actual type we'll talk again later

00:09:58,439 --> 00:10:03,480
channels are typed there's also a

00:10:02,069 --> 00:10:06,240
pointer type I'm not going to talk about

00:10:03,480 --> 00:10:07,920
because it doesn't really matter what we

00:10:06,240 --> 00:10:09,509
matters in go but it doesn't matter for

00:10:07,920 --> 00:10:12,509
the purpose of discussing this

00:10:09,509 --> 00:10:17,160
comparison finally and I said there is

00:10:12,509 --> 00:10:19,050
an interface type in go ad is internet

00:10:17,160 --> 00:10:22,850
is used for generalization attractions

00:10:19,050 --> 00:10:22,850
as you would expect for an interface

00:10:23,720 --> 00:10:28,139
it's there's this thing I want to

00:10:26,339 --> 00:10:30,899
mention now we'll talk about later which

00:10:28,139 --> 00:10:35,100
is in go interfaces are satisfied

00:10:30,899 --> 00:10:36,480
implicitly and that is why I think

00:10:35,100 --> 00:10:38,100
they're very similar to how things work

00:10:36,480 --> 00:10:40,680
in Python again we'll talk about that

00:10:38,100 --> 00:10:42,990
later we can go back to the clergy and

00:10:40,680 --> 00:10:47,430
usage so there are really three ways you

00:10:42,990 --> 00:10:49,379
can declare an assigned stuff and go for

00:10:47,430 --> 00:10:51,809
example the first one is you know you do

00:10:49,379 --> 00:10:55,019
you create a variable of type string

00:10:51,809 --> 00:10:58,380
then you sign some texture now at the

00:10:55,019 --> 00:11:02,810
point where that variable is declared so

00:10:58,380 --> 00:11:05,570
vortex string text is an empty string

00:11:02,810 --> 00:11:07,340
and one of the things and go is that

00:11:05,570 --> 00:11:09,590
when you declare a variable it

00:11:07,340 --> 00:11:11,960
automatically takes a zero value of its

00:11:09,590 --> 00:11:14,810
type for example in this would be zero

00:11:11,960 --> 00:11:17,620
floats with zero point zero reference

00:11:14,810 --> 00:11:19,550
types would be Neil and that is quite

00:11:17,620 --> 00:11:21,170
interesting because it's meant to be

00:11:19,550 --> 00:11:24,710
used and you can have some fun with it

00:11:21,170 --> 00:11:25,790
for example if we wanted to take I don't

00:11:24,710 --> 00:11:28,070
know why we do this but if you want to

00:11:25,790 --> 00:11:31,250
take random input from user from the

00:11:28,070 --> 00:11:33,800
standard input and count the number of

00:11:31,250 --> 00:11:36,589
times they typed on type something we

00:11:33,800 --> 00:11:38,630
could create a map called counts and

00:11:36,589 --> 00:11:40,130
that's a map that's going for you know

00:11:38,630 --> 00:11:42,860
the keys of string and the value is an

00:11:40,130 --> 00:11:44,600
int it will be our count you take the

00:11:42,860 --> 00:11:46,730
input doesn't matter what you know how

00:11:44,600 --> 00:11:48,770
we do it with the new scanner and then

00:11:46,730 --> 00:11:51,500
you go through every time someone type

00:11:48,770 --> 00:11:53,270
something you read that and what we can

00:11:51,500 --> 00:11:56,330
do is we can look at that text as the

00:11:53,270 --> 00:11:58,790
key into the map but initially because

00:11:56,330 --> 00:12:00,680
it doesn't exist the default value the 0

00:11:58,790 --> 00:12:02,300
value for int is returned because that's

00:12:00,680 --> 00:12:04,070
the value of the map and then you can

00:12:02,300 --> 00:12:06,770
just do a bluff buff on that and you're

00:12:04,070 --> 00:12:08,839
good to go doing something similar in

00:12:06,770 --> 00:12:11,810
Python will probably this counter but if

00:12:08,839 --> 00:12:14,050
not this particular behavior results in

00:12:11,810 --> 00:12:17,060
something similar to default and

00:12:14,050 --> 00:12:18,890
but again every other type has 0 values

00:12:17,060 --> 00:12:22,420
too so in terms of o'reilly's floats

00:12:18,890 --> 00:12:22,420
have 0 values everything as your various

00:12:23,680 --> 00:12:29,960
functions are very similar to python the

00:12:26,870 --> 00:12:32,420
only thing is because those statically

00:12:29,960 --> 00:12:37,280
typed and kind of declaring your types

00:12:32,420 --> 00:12:39,560
matter you give your type we look at an

00:12:37,280 --> 00:12:42,080
example now in a parameter list you also

00:12:39,560 --> 00:12:44,270
need to have a result list for example

00:12:42,080 --> 00:12:45,620
you might taking an inch and return the

00:12:44,270 --> 00:12:49,100
string or taking an intern return a

00:12:45,620 --> 00:12:51,740
tuple of string and float so you would

00:12:49,100 --> 00:12:55,070
want to specify that a crappy example

00:12:51,740 --> 00:12:58,220
would be you know to take a and B and

00:12:55,070 --> 00:13:00,470
add it to each other if david McIver

00:12:58,220 --> 00:13:03,740
ultra hypothesis of the notion guys know

00:13:00,470 --> 00:13:05,570
it was here we probably stab me because

00:13:03,740 --> 00:13:11,089
that could break in so many ways but

00:13:05,570 --> 00:13:13,550
anyway so that function you know will

00:13:11,089 --> 00:13:16,160
take two int's will return an integer

00:13:13,550 --> 00:13:20,120
stance them one thing could also do

00:13:16,160 --> 00:13:25,100
which is kind of sweet is that you could

00:13:20,120 --> 00:13:26,780
name your results so you could say in

00:13:25,100 --> 00:13:28,010
this case call is C and then you can

00:13:26,780 --> 00:13:30,320
straightaway assigned to it and do stuff

00:13:28,010 --> 00:13:33,020
with it again in this case it doesn't

00:13:30,320 --> 00:13:35,240
make sense because I'll just I mean I

00:13:33,020 --> 00:13:39,290
even forgot to change return see as you

00:13:35,240 --> 00:13:43,490
can see so but you can do stuff like

00:13:39,290 --> 00:13:46,250
that and you know just like you could do

00:13:43,490 --> 00:13:48,680
recursion with functions like Python

00:13:46,250 --> 00:13:51,610
there's no tail call optimization or at

00:13:48,680 --> 00:13:54,350
least it wasn't last time i checked the

00:13:51,610 --> 00:14:01,459
idea being that if your function can be

00:13:54,350 --> 00:14:03,560
optimized just write a loop and a type

00:14:01,459 --> 00:14:05,839
of the function is a signature and it's

00:14:03,560 --> 00:14:08,030
just the sequence of inputs and the out

00:14:05,839 --> 00:14:09,829
sequence of outputs so the signature for

00:14:08,030 --> 00:14:12,200
this function any any function that

00:14:09,829 --> 00:14:14,329
takes to int and returns one else has

00:14:12,200 --> 00:14:17,270
the same signature and that is useful

00:14:14,329 --> 00:14:19,760
because like Python functions are

00:14:17,270 --> 00:14:21,589
first-class citizens in go as well so

00:14:19,760 --> 00:14:23,180
you can pass them around so you can have

00:14:21,589 --> 00:14:24,440
variables that point to them so you you

00:14:23,180 --> 00:14:26,120
know you might want to variable that

00:14:24,440 --> 00:14:28,670
points to a function that takes to ins

00:14:26,120 --> 00:14:33,350
and returns a string and that would be

00:14:28,670 --> 00:14:36,829
the signature of your function and I

00:14:33,350 --> 00:14:38,630
just said that the 0 value for functions

00:14:36,829 --> 00:14:41,390
is Neil we don't really care about that

00:14:38,630 --> 00:14:47,270
but again it's this emphasis that things

00:14:41,390 --> 00:14:52,490
have 0 values and you can return

00:14:47,270 --> 00:14:54,800
multiple values from a function like the

00:14:52,490 --> 00:14:57,170
top all that you can do in Python if you

00:14:54,800 --> 00:14:59,060
don't want one of them again the idiom

00:14:57,170 --> 00:15:02,839
is very similar use an underscore as a

00:14:59,060 --> 00:15:04,850
throwaway name and you take it but this

00:15:02,839 --> 00:15:08,510
is interesting because the ability to

00:15:04,850 --> 00:15:11,209
return multiple values from a function

00:15:08,510 --> 00:15:13,579
leads us nicely to how error and error

00:15:11,209 --> 00:15:16,850
handling is done and go which is quite a

00:15:13,579 --> 00:15:18,440
bit different to Python in Python we

00:15:16,850 --> 00:15:21,589
would typically do a try except else

00:15:18,440 --> 00:15:23,959
finally and we will cache exceptions and

00:15:21,589 --> 00:15:26,310
do things with them and go there are no

00:15:23,959 --> 00:15:29,340
there's no concept of an exception

00:15:26,310 --> 00:15:31,650
in that sense what you do is usually the

00:15:29,340 --> 00:15:36,360
last thing returned by function is an

00:15:31,650 --> 00:15:38,400
error and then you check for that check

00:15:36,360 --> 00:15:42,839
to see if it's neil if it is Neal then

00:15:38,400 --> 00:15:44,430
you're good if it's not kneel if it's

00:15:42,839 --> 00:15:49,410
not kneel then you're good that's

00:15:44,430 --> 00:15:53,300
incorrect but but you can do the same

00:15:49,410 --> 00:15:55,260
logic with with the errors in go

00:15:53,300 --> 00:15:58,050
sometimes you want to catch a particular

00:15:55,260 --> 00:15:59,339
one for example the IO package with you

00:15:58,050 --> 00:16:01,620
know if you'd return and end the file

00:15:59,339 --> 00:16:04,710
error so you can change you could say if

00:16:01,620 --> 00:16:08,540
error equals equals are you do AF lamb

00:16:04,710 --> 00:16:08,540
so you can't do specific ones as well

00:16:08,839 --> 00:16:13,470
now something you might say well what do

00:16:11,970 --> 00:16:15,180
we do it like finally how do we make

00:16:13,470 --> 00:16:19,050
sure if something gets run go have this

00:16:15,180 --> 00:16:22,140
concepts of defer and the ferry is often

00:16:19,050 --> 00:16:24,210
use word you would use finally or ensure

00:16:22,140 --> 00:16:26,100
in other languages and what it does it

00:16:24,210 --> 00:16:28,500
says okay so create a file doesn't

00:16:26,100 --> 00:16:30,600
matter how that does that and you defer

00:16:28,500 --> 00:16:32,790
closed file and what that says is run

00:16:30,600 --> 00:16:35,160
closer whenever I'm kind of leaving the

00:16:32,790 --> 00:16:37,800
scope of this function basically so you

00:16:35,160 --> 00:16:39,720
can do that immediately after the open

00:16:37,800 --> 00:16:42,000
resource you can immediately says if

00:16:39,720 --> 00:16:45,650
you're close it later and it's all in

00:16:42,000 --> 00:16:45,650
one place and you won't forget later

00:16:46,220 --> 00:16:51,270
we'll probably get back to this in a bit

00:16:48,810 --> 00:16:53,400
as well again but but it's kind of

00:16:51,270 --> 00:16:56,940
interesting interesting way of dealing

00:16:53,400 --> 00:16:59,600
with that there are however some times

00:16:56,940 --> 00:17:03,750
where there are genuinely exceptional

00:16:59,600 --> 00:17:07,740
circumstances you know dereferencing can

00:17:03,750 --> 00:17:10,640
nail pointer or alpha pounds in an array

00:17:07,740 --> 00:17:14,429
and in those cases go just panics and

00:17:10,640 --> 00:17:15,900
you can also panic is actually function

00:17:14,429 --> 00:17:17,910
that you can call yourself you can make

00:17:15,900 --> 00:17:21,329
your program penalty and the thing about

00:17:17,910 --> 00:17:22,949
panic is that the idea is that it will

00:17:21,329 --> 00:17:26,130
stop the execution of the code where it

00:17:22,949 --> 00:17:28,230
panicked it will run all the different

00:17:26,130 --> 00:17:30,120
functions and it would do them in the

00:17:28,230 --> 00:17:32,250
last in first out so if you do like

00:17:30,120 --> 00:17:35,400
three defers who kind of do this last

00:17:32,250 --> 00:17:37,890
one first and then the program crashes

00:17:35,400 --> 00:17:39,090
with a log message if you don't do

00:17:37,890 --> 00:17:46,890
anything with it

00:17:39,090 --> 00:17:49,380
and the the idea as far as I've seen and

00:17:46,890 --> 00:17:51,360
used and understood is that you don't

00:17:49,380 --> 00:17:53,309
really want to start panics you don't

00:17:51,360 --> 00:17:54,840
really want to handle them if there's

00:17:53,309 --> 00:17:57,480
been a situation where go as panicked

00:17:54,840 --> 00:17:59,909
then you kind of want it you know you're

00:17:57,480 --> 00:18:01,289
done but it is sometimes useful to

00:17:59,909 --> 00:18:05,190
recover from it and there's mechanisms

00:18:01,289 --> 00:18:07,500
to do that for example you know she have

00:18:05,190 --> 00:18:08,549
a web server and something bad happens

00:18:07,500 --> 00:18:11,760
you don't want to just keep the

00:18:08,549 --> 00:18:13,049
connection open you know forever you

00:18:11,760 --> 00:18:15,419
might want to recover from that panic

00:18:13,049 --> 00:18:17,190
even maybe send an error back to client

00:18:15,419 --> 00:18:18,539
and knit then maybe you can close

00:18:17,190 --> 00:18:22,049
everything or maybe you can recover from

00:18:18,539 --> 00:18:26,820
it we can take a quick example for

00:18:22,049 --> 00:18:28,620
example in a parser sometimes you know

00:18:26,820 --> 00:18:31,080
even if everything is appears to work

00:18:28,620 --> 00:18:32,690
fine the complexity of a job is in a way

00:18:31,080 --> 00:18:36,299
where bugs may still lurk in and

00:18:32,690 --> 00:18:37,230
generally speaking what you can do is

00:18:36,299 --> 00:18:38,640
don't do those cases you don't

00:18:37,230 --> 00:18:40,799
necessarily want to panic so there's

00:18:38,640 --> 00:18:42,090
there's this constant of recover so what

00:18:40,799 --> 00:18:45,120
you do right to the top your function

00:18:42,090 --> 00:18:48,419
you defer a function and because we said

00:18:45,120 --> 00:18:50,760
when in go you panicked all the deferred

00:18:48,419 --> 00:18:52,340
functions get gold so when this deferred

00:18:50,760 --> 00:18:55,860
function gets called off their panic

00:18:52,340 --> 00:18:57,360
recover will return that pack if there

00:18:55,860 --> 00:18:59,970
was a panic and if there was the case

00:18:57,360 --> 00:19:02,820
then if you deal with it and either die

00:18:59,970 --> 00:19:04,710
or try and control it and carry on with

00:19:02,820 --> 00:19:08,070
your program so in this gay in the case

00:19:04,710 --> 00:19:10,320
of a parser you can just write the error

00:19:08,070 --> 00:19:12,090
and carry on or you know whatever i took

00:19:10,320 --> 00:19:16,289
this the example directly from the go

00:19:12,090 --> 00:19:19,710
book and recover rule will return nail

00:19:16,289 --> 00:19:22,970
if there has been no panic so the it's

00:19:19,710 --> 00:19:25,649
not really a problem you also shouldn't

00:19:22,970 --> 00:19:30,690
i'm not going to go panic seni more they

00:19:25,649 --> 00:19:33,299
exist running out of time so what about

00:19:30,690 --> 00:19:37,559
object-oriented programming python is

00:19:33,299 --> 00:19:40,440
pretty object-oriented everything is an

00:19:37,559 --> 00:19:41,820
object goal is also apparently

00:19:40,440 --> 00:19:44,760
considered object oriented though goes

00:19:41,820 --> 00:19:46,350
definition of it is a bit so goes as an

00:19:44,760 --> 00:19:48,690
object is simply a value or variable

00:19:46,350 --> 00:19:49,710
that has methods and a method is a

00:19:48,690 --> 00:19:53,750
function associated with a particular

00:19:49,710 --> 00:19:58,500
type so you you know you could

00:19:53,750 --> 00:20:00,090
yes you have that and and I'll go

00:19:58,500 --> 00:20:03,720
through how you can use it in a sec

00:20:00,090 --> 00:20:05,850
there is no inheritance I don't

00:20:03,720 --> 00:20:08,820
particularly enjoy inheritance usually

00:20:05,850 --> 00:20:12,270
so calm composition is the way to do

00:20:08,820 --> 00:20:14,669
things and let me know we can go through

00:20:12,270 --> 00:20:19,380
a quick again point this example

00:20:14,669 --> 00:20:23,490
pointless because the point I don't even

00:20:19,380 --> 00:20:26,880
realize that so if I phone you define a

00:20:23,490 --> 00:20:30,720
class you know a point has x and y

00:20:26,880 --> 00:20:32,789
coordinates at least in 3d space in goal

00:20:30,720 --> 00:20:36,450
you would do the same with the struct so

00:20:32,789 --> 00:20:39,030
you you define type point it has an x

00:20:36,450 --> 00:20:40,740
and the y there float64 those are called

00:20:39,030 --> 00:20:45,150
fields so we have an exfil and a wide

00:20:40,740 --> 00:20:46,770
field and we all know how to add methods

00:20:45,150 --> 00:20:48,630
in Python you just add another death

00:20:46,770 --> 00:20:50,220
under there it takes self and then it

00:20:48,630 --> 00:20:52,340
does some stuff for example if you want

00:20:50,220 --> 00:20:58,740
to take the distance between two points

00:20:52,340 --> 00:21:01,530
well in go you kind of attach a function

00:20:58,740 --> 00:21:04,230
on to that type and you could do this to

00:21:01,530 --> 00:21:08,700
basically in any type any user defined

00:21:04,230 --> 00:21:11,000
type so although the it looks a bit

00:21:08,700 --> 00:21:13,200
different it's not i'm in the same scope

00:21:11,000 --> 00:21:16,860
you know that's how it works so that's

00:21:13,200 --> 00:21:18,390
how you end up having methods and both

00:21:16,860 --> 00:21:20,490
of those you know captain distance

00:21:18,390 --> 00:21:23,309
between two lines in the different

00:21:20,490 --> 00:21:25,169
languages but as i mentioned earlier

00:21:23,309 --> 00:21:31,230
there are no there's no inheritance and

00:21:25,169 --> 00:21:33,210
go but the way go kind of handles that

00:21:31,230 --> 00:21:35,870
the circumstances where you wouldnÃ­t

00:21:33,210 --> 00:21:39,480
inheritance is by struct embedding and

00:21:35,870 --> 00:21:41,610
when i first read this few months ago it

00:21:39,480 --> 00:21:43,950
said it composes types by struct

00:21:41,610 --> 00:21:47,250
embedding and I thought what by what was

00:21:43,950 --> 00:21:48,450
it it was a bit of a mouthful but when

00:21:47,250 --> 00:21:50,490
we take an example be pretty sweet

00:21:48,450 --> 00:21:52,830
imagine we had the point class now we

00:21:50,490 --> 00:21:55,110
had a named point glass and the point of

00:21:52,830 --> 00:21:58,350
it is a has an icky poncing points when

00:21:55,110 --> 00:22:00,120
talking up hmm so we have a point class

00:21:58,350 --> 00:22:02,700
and a named point class and a named

00:22:00,120 --> 00:22:05,640
point class had also has a name for a

00:22:02,700 --> 00:22:06,310
particular point in Python to do that

00:22:05,640 --> 00:22:08,200
you would probably

00:22:06,310 --> 00:22:11,140
you create a new name for in class sup

00:22:08,200 --> 00:22:13,920
class point and just add a new instance

00:22:11,140 --> 00:22:17,470
variable to it in girl what you can do

00:22:13,920 --> 00:22:20,140
we already had a point struct will

00:22:17,470 --> 00:22:22,060
create an aim point struct and you can

00:22:20,140 --> 00:22:23,890
embed point inside it and what does that

00:22:22,060 --> 00:22:26,530
mean is that when you create named

00:22:23,890 --> 00:22:28,570
points you already have access to X and

00:22:26,530 --> 00:22:32,770
you already have access to Y so you just

00:22:28,570 --> 00:22:34,420
we can show you here so named points you

00:22:32,770 --> 00:22:38,560
know you pass at that point and you can

00:22:34,420 --> 00:22:41,260
act this name point at X as if X was

00:22:38,560 --> 00:22:42,820
part of an named point because it is

00:22:41,260 --> 00:22:43,990
it's embedded inside it and you can you

00:22:42,820 --> 00:22:48,730
know call the functions and everything

00:22:43,990 --> 00:22:50,140
as well so that's the way I don't want

00:22:48,730 --> 00:22:54,550
to into inheritance is handled but

00:22:50,140 --> 00:22:56,460
that's the way you do embedding to for

00:22:54,550 --> 00:23:00,400
those kind of circumstances and

00:22:56,460 --> 00:23:04,470
obviously there is one more oh PS thing

00:23:00,400 --> 00:23:06,190
and go as well which are interfaces

00:23:04,470 --> 00:23:08,980
conceptually they're actually very

00:23:06,190 --> 00:23:10,840
similar to duck typing in Python you

00:23:08,980 --> 00:23:13,720
know when if you have done their land

00:23:10,840 --> 00:23:15,100
then something that needs Thunder Len

00:23:13,720 --> 00:23:17,560
just knows how to deal with it you don't

00:23:15,100 --> 00:23:20,070
really have too much or the dunder eco

00:23:17,560 --> 00:23:23,920
or whatever it's really the same and go

00:23:20,070 --> 00:23:25,690
and the way the earlier I mentioned that

00:23:23,920 --> 00:23:28,120
they're satisfied implicitly that's what

00:23:25,690 --> 00:23:31,300
that's what I meant you don't really

00:23:28,120 --> 00:23:33,070
have to do anything as long as a strut

00:23:31,300 --> 00:23:34,540
for example has all the methods that in

00:23:33,070 --> 00:23:35,890
today's expects it to have then it

00:23:34,540 --> 00:23:40,810
confirms that it satisfies that

00:23:35,890 --> 00:23:42,910
interface and an example kind of from

00:23:40,810 --> 00:23:44,860
the actual built entire package is like

00:23:42,910 --> 00:23:47,140
writers and readers and read writers so

00:23:44,860 --> 00:23:49,510
you know I writer interface as long as

00:23:47,140 --> 00:23:51,700
something has a right method that takes

00:23:49,510 --> 00:23:55,810
some bites and returns an intern error

00:23:51,700 --> 00:23:58,090
then that satisfies that interface and

00:23:55,810 --> 00:24:00,280
you can also mix it mix up in services

00:23:58,090 --> 00:24:05,410
like that so read writer and it takes

00:24:00,280 --> 00:24:09,670
writer and reader for example OS that

00:24:05,410 --> 00:24:11,230
stood out conforms to some of those it

00:24:09,670 --> 00:24:15,040
also conforms to the satisfies the

00:24:11,230 --> 00:24:16,810
clothes interface similar in some ways

00:24:15,040 --> 00:24:18,370
their ABCs in Python as well although i

00:24:16,810 --> 00:24:21,150
don't actually think it's just their way

00:24:18,370 --> 00:24:21,150
dark typing is

00:24:23,430 --> 00:24:30,220
I'm just trying to think I have one

00:24:25,300 --> 00:24:32,850
minute left let's let chu happens go one

00:24:30,220 --> 00:24:34,990
of its main strength is concurrency and

00:24:32,850 --> 00:24:39,420
that's kind of what everyone bangs on

00:24:34,990 --> 00:24:41,890
about Python also has concurrency

00:24:39,420 --> 00:24:44,320
concurrence ingo is mainly done in two

00:24:41,890 --> 00:24:45,730
ways either go routines which is the

00:24:44,320 --> 00:24:47,290
thing that is quite famous or

00:24:45,730 --> 00:24:48,070
traditional shared memory we're not

00:24:47,290 --> 00:24:50,590
going to talk about that because that's

00:24:48,070 --> 00:24:52,900
not really interesting and just to talk

00:24:50,590 --> 00:24:56,070
about communicating sequential processes

00:24:52,900 --> 00:24:58,630
I mentioned CSP earlier on it is some

00:24:56,070 --> 00:25:01,930
it's something Tony Hall was working on

00:24:58,630 --> 00:25:04,360
in 1970s and it isn't really programming

00:25:01,930 --> 00:25:07,360
language ESP is more of a formal formal

00:25:04,360 --> 00:25:09,490
language for defining how concurrent

00:25:07,360 --> 00:25:12,340
things interact and the thing that I

00:25:09,490 --> 00:25:15,010
don't know if it came from go or whether

00:25:12,340 --> 00:25:17,080
it was there before but people who do go

00:25:15,010 --> 00:25:20,080
off and say do not communicate by

00:25:17,080 --> 00:25:22,030
sharing memory instead Shea share memory

00:25:20,080 --> 00:25:24,130
by communicating so the whole idea is

00:25:22,030 --> 00:25:25,030
that you don't really share memory but

00:25:24,130 --> 00:25:29,740
you have these things we've talked about

00:25:25,030 --> 00:25:31,660
all channels that talk to each other the

00:25:29,740 --> 00:25:33,810
goal routines are just like we're like

00:25:31,660 --> 00:25:36,010
twitch threads managed by go runtime and

00:25:33,810 --> 00:25:38,800
they're pretty sweet to run you just a

00:25:36,010 --> 00:25:44,290
preprint go to a function and that's

00:25:38,800 --> 00:25:48,030
running separate goroutine true a quick

00:25:44,290 --> 00:25:50,470
example because we have I've to hurry up

00:25:48,030 --> 00:25:52,600
that's literally how it works you say go

00:25:50,470 --> 00:25:54,280
waste time and it does that in the

00:25:52,600 --> 00:25:56,920
background and it carries on so it

00:25:54,280 --> 00:25:58,480
prints end of main first then it will

00:25:56,920 --> 00:26:02,250
print time wasted because that things

00:25:58,480 --> 00:26:04,660
are late for two thousand milliseconds I

00:26:02,250 --> 00:26:07,900
don't know why anyone would do that but

00:26:04,660 --> 00:26:12,100
still and then there's the concept of

00:26:07,900 --> 00:26:15,730
channels and channels are the way you

00:26:12,100 --> 00:26:17,050
communicate between to go routines by

00:26:15,730 --> 00:26:18,220
the way you always have one go routine

00:26:17,050 --> 00:26:20,820
at least which is the main girl routine

00:26:18,220 --> 00:26:24,190
that's when you start the program and

00:26:20,820 --> 00:26:26,620
another basic example of a channel you

00:26:24,190 --> 00:26:28,660
created channels are like pipes and unix

00:26:26,620 --> 00:26:30,610
for example but they're typed you can't

00:26:28,660 --> 00:26:31,879
just put anything in it you type it so

00:26:30,610 --> 00:26:35,269
rotate the channel of tight

00:26:31,879 --> 00:26:37,879
then we have an anonymous function which

00:26:35,269 --> 00:26:40,009
is you know a bit like anything else you

00:26:37,879 --> 00:26:41,599
could do that you can't be enticing but

00:26:40,009 --> 00:26:44,869
I guess you have landis but they don't

00:26:41,599 --> 00:26:47,179
really work anyway you can write to a

00:26:44,869 --> 00:26:49,069
channel so that function rights 42 to a

00:26:47,179 --> 00:26:51,229
channel and both right rights and

00:26:49,069 --> 00:26:53,929
receiving from a channel or blocking

00:26:51,229 --> 00:26:55,690
operations and then over there front we

00:26:53,929 --> 00:27:04,119
can read from that channel so basically

00:26:55,690 --> 00:27:07,759
we'd like print 42 which is amazing and

00:27:04,119 --> 00:27:10,639
I'll do this bit in 30 seconds I wish I

00:27:07,759 --> 00:27:13,419
had more time but the ecosystem and

00:27:10,639 --> 00:27:17,209
tools in Python I think are pretty solid

00:27:13,419 --> 00:27:18,379
it the same goes for gold but gold comes

00:27:17,209 --> 00:27:20,659
with a lot of bills and stuff for

00:27:18,379 --> 00:27:22,929
example for testing there's you know in

00:27:20,659 --> 00:27:25,459
your terminal which I can go test and

00:27:22,929 --> 00:27:27,019
you can there are certain conventions

00:27:25,459 --> 00:27:28,699
that if you follow you can just test all

00:27:27,019 --> 00:27:31,579
your go code unit test is pretty good

00:27:28,699 --> 00:27:34,819
pie test is pretty sweet in Python that

00:27:31,579 --> 00:27:36,349
they're all really mature stuff we'd go

00:27:34,819 --> 00:27:39,379
you know anything that ends with

00:27:36,349 --> 00:27:41,659
underscore test our test files you could

00:27:39,379 --> 00:27:43,609
any any method that starts with test is

00:27:41,659 --> 00:27:45,139
a test method any method that starts

00:27:43,609 --> 00:27:47,389
with benchmark is a benchmark test

00:27:45,139 --> 00:27:49,489
method and something that's pretty

00:27:47,389 --> 00:27:54,139
interesting is any method that starts

00:27:49,489 --> 00:27:56,529
with example is a example function that

00:27:54,139 --> 00:27:59,449
provides a machine check documentation

00:27:56,529 --> 00:28:01,219
so that's pretty interesting too so

00:27:59,449 --> 00:28:04,459
really there is one way to do these

00:28:01,219 --> 00:28:07,519
things that go defines and it works

00:28:04,459 --> 00:28:10,429
pretty sweetly forego formatting or code

00:28:07,519 --> 00:28:13,219
formatting not go formatting you just

00:28:10,429 --> 00:28:15,769
again use the terminal go format your

00:28:13,219 --> 00:28:17,059
source and just format it so like if you

00:28:15,769 --> 00:28:20,479
install this as they plug into your ID

00:28:17,059 --> 00:28:23,629
every time you save it does that every

00:28:20,479 --> 00:28:26,179
go file looks the same I sometimes find

00:28:23,629 --> 00:28:28,249
you know we used to live like eight for

00:28:26,179 --> 00:28:30,529
our Python development and it doesn't

00:28:28,249 --> 00:28:32,419
necessarily do you know where to put a

00:28:30,529 --> 00:28:35,389
line break if your long lines too long

00:28:32,419 --> 00:28:38,809
with that kind of stuff well it does but

00:28:35,389 --> 00:28:40,219
you might not agree with it so that

00:28:38,809 --> 00:28:42,319
doesn't really happen because go just

00:28:40,219 --> 00:28:43,909
doesn't there is one way to do it and go

00:28:42,319 --> 00:28:44,860
we'll take care of it again for package

00:28:43,909 --> 00:28:46,720
management

00:28:44,860 --> 00:28:50,170
there's quite a few different ways doing

00:28:46,720 --> 00:28:51,429
in Python nicking the pip install as has

00:28:50,170 --> 00:28:55,570
at least been the most common in my

00:28:51,429 --> 00:28:57,940
lifetime goal has concept again from

00:28:55,570 --> 00:29:01,150
terminal comes with it go get package

00:28:57,940 --> 00:29:02,770
and it just gets it builds there another

00:29:01,150 --> 00:29:05,710
thing I package management virtual end

00:29:02,770 --> 00:29:07,090
is pretty well used in Python to manage

00:29:05,710 --> 00:29:09,880
different versions and pair project

00:29:07,090 --> 00:29:15,490
requirements you use go path environment

00:29:09,880 --> 00:29:18,010
variable when working to go it's it

00:29:15,490 --> 00:29:19,630
could be annoying but if you end up

00:29:18,010 --> 00:29:22,780
having a nice way of dealing with it

00:29:19,630 --> 00:29:25,410
then you know it's fine too i quite like

00:29:22,780 --> 00:29:30,669
virtual owned the way it works and that

00:29:25,410 --> 00:29:33,549
was fast finally go comes with document

00:29:30,669 --> 00:29:35,320
generation and you just do go doc any

00:29:33,549 --> 00:29:36,910
change to ensure of your go program now

00:29:35,320 --> 00:29:39,640
that there are quite a few tools again

00:29:36,910 --> 00:29:42,940
that do that for Python but I don't

00:29:39,640 --> 00:29:45,790
think it's you know in the standard way

00:29:42,940 --> 00:29:47,260
that go that's it it's you know one way

00:29:45,790 --> 00:29:52,330
of doing it and it just does it well and

00:29:47,260 --> 00:29:53,980
everything looks the same so those are

00:29:52,330 --> 00:29:57,580
kind of the ecosystems and tools and I

00:29:53,980 --> 00:29:59,380
guess the conclusion is that well none

00:29:57,580 --> 00:30:03,790
of us can you know I also coming out

00:29:59,380 --> 00:30:05,740
distal cargo programmers but and I'm not

00:30:03,790 --> 00:30:08,710
saying we should all move to go or all

00:30:05,740 --> 00:30:11,130
stay with Python but the idea was just

00:30:08,710 --> 00:30:14,169
to get a feel for what's there and go

00:30:11,130 --> 00:30:15,880
and that's it I don't think that you

00:30:14,169 --> 00:30:17,770
know nothing nothing to concrete just

00:30:15,880 --> 00:30:20,620
get a feel for go and I know a lot of

00:30:17,770 --> 00:30:24,480
people have been moving to it whatever

00:30:20,620 --> 00:30:27,929
you know if that's what you want to do

00:30:24,480 --> 00:30:27,929
anyway that's it thank

00:30:35,350 --> 00:30:40,760
okay so unfortunately we don't have any

00:30:37,910 --> 00:30:43,550
more time for the question and answers

00:30:40,760 --> 00:30:45,530
but you can chase him and ask him

00:30:43,550 --> 00:30:47,800
personally and now we enjoyed the coffee

00:30:45,530 --> 00:30:47,800

YouTube URL: https://www.youtube.com/watch?v=yqg4tEjzO9M


