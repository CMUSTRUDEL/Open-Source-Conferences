Title: Cameron Macleod - Implementing a Sound Identifier in Python
Publication date: 2016-07-28
Playlist: EuroPython 2016
Description: 
	Cameron Macleod - Implementing a Sound Identifier in Python
[EuroPython 2016]
[18 July 2016]
[Bilbao, Euskadi, Spain]
(https://ep2016.europython.eu//conference/talks/implementing-a-sound-identifier-in-python)

The talk will go over implementing a Shazam-style sound recogniser
using DSP techniques and some fantastic libraries. It will cover
implementation, challenges and further steps. The project is still a
work in progress and the code is [available on GitHub][1]. It was
inspired by the [Over-the-Air Audio Identification talk][2] at FOSDEM
2016.

[1]: https://github.com/notexactlyawe/abracadabra
[2]: https://fosdem.org/2016/schedule/event/audio_identification/

-----

The talk will go over the journey of implementing a Shazam-style sound
recogniser using DSP techniques and some fantastic libraries. It will
cover implementation, challenges and further steps. The project is
still a work in progress at the time of proposal and the code is
[available on GitHub][1]. It was inspired by the [Over-the-Air Audio
Identification talk][2] at FOSDEM 2016.

The basic structure of the project consists a classifier that
fingerprints audio and stores it in a searchable form and a recogniser
that fingerprints a smaller chunk of audio and then searches the
stored records to find the most suitable fit for it. The recogniser
will be exposed as an API to allow for different front-ends.

I will aim to introduce both the field of DSP and concepts behind
applications like Shazam in a simple easy-to-understand manner. The
audience will not need any prior experience in anything except Python.

[1]: https://github.com/notexactlyawe/abracadabra
[2]: https://fosdem.org/2016/schedule/event/audio_identification/
Captions: 
	00:00:00,410 --> 00:00:07,350
so now we have Cameron McLeod McLeod

00:00:05,609 --> 00:00:09,210
okay sorry

00:00:07,350 --> 00:00:10,980
speaking about implementing a sound

00:00:09,210 --> 00:00:14,580
identifier and Python I'm really excited

00:00:10,980 --> 00:00:16,080
about it so it's the Shazam thing but of

00:00:14,580 --> 00:00:16,440
course you're here just because you hear

00:00:16,080 --> 00:00:19,740
this

00:00:16,440 --> 00:00:23,689
okay so last talk for today except of

00:00:19,740 --> 00:00:23,689
the lightning talks of course have fun

00:00:25,189 --> 00:00:31,920
hello hello hello okay fantastic you can

00:00:29,939 --> 00:00:36,329
all hear me yeah thank you for coming

00:00:31,920 --> 00:00:38,340
I'm Cameron as a brief overview this is

00:00:36,329 --> 00:00:40,530
just really just the theory behind how

00:00:38,340 --> 00:00:41,430
Shazam used to work I don't think it

00:00:40,530 --> 00:00:42,629
still works like that because I

00:00:41,430 --> 00:00:44,940
published a paper on it therefore

00:00:42,629 --> 00:00:46,800
they've got something better now but a

00:00:44,940 --> 00:00:48,660
quick disclaimer I'm not an expert on

00:00:46,800 --> 00:00:49,800
literally anything and therefore

00:00:48,660 --> 00:00:51,059
everything contained within this

00:00:49,800 --> 00:00:54,210
presentation should be taken with a

00:00:51,059 --> 00:00:57,539
pinch of salt fantastic music

00:00:54,210 --> 00:01:00,000
information retrieval so imagine you are

00:00:57,539 --> 00:01:02,460
in the car or if you don't have a car

00:01:00,000 --> 00:01:03,840
you're listening to the radio and of

00:01:02,460 --> 00:01:06,299
course you're not controlling the music

00:01:03,840 --> 00:01:08,640
that's being played so a song comes on

00:01:06,299 --> 00:01:09,750
it might be Britney Spears or something

00:01:08,640 --> 00:01:11,460
you don't know it's Britney Spears but

00:01:09,750 --> 00:01:13,350
you think you know this is a pretty good

00:01:11,460 --> 00:01:15,080
song I could get into this and you want

00:01:13,350 --> 00:01:17,640
to find the name of it of course

00:01:15,080 --> 00:01:19,799
nowadays you've got things like Suzanne

00:01:17,640 --> 00:01:21,840
you've had it since 2001 to just

00:01:19,799 --> 00:01:25,650
identify quickly what this song is and

00:01:21,840 --> 00:01:27,630
the artists etc but this is where this

00:01:25,650 --> 00:01:29,610
is the basic problem from which music

00:01:27,630 --> 00:01:34,020
identity information retrieval comes

00:01:29,610 --> 00:01:36,720
from so music isn't easily searchable as

00:01:34,020 --> 00:01:39,630
a thing if you've got two different

00:01:36,720 --> 00:01:41,759
recordings or two different encodings of

00:01:39,630 --> 00:01:44,250
the same song or the same piece of audio

00:01:41,759 --> 00:01:47,640
it's going to vary quite wildly in bit

00:01:44,250 --> 00:01:49,740
representation and they're also quite

00:01:47,640 --> 00:01:51,810
large the files that you find that

00:01:49,740 --> 00:01:54,329
contain music so Shazam solves this

00:01:51,810 --> 00:01:56,009
using something called fingerprinting we

00:01:54,329 --> 00:01:58,439
all go through that in a bit but you've

00:01:56,009 --> 00:02:00,180
also got other applications within the

00:01:58,439 --> 00:02:01,560
field such as school search if you're a

00:02:00,180 --> 00:02:03,090
musician you've got that little piece of

00:02:01,560 --> 00:02:04,920
paper that you flick through quickly and

00:02:03,090 --> 00:02:06,060
incredibly because you're playing and

00:02:04,920 --> 00:02:07,680
you're flicking at the same time I think

00:02:06,060 --> 00:02:09,569
it's quite impressive and you're

00:02:07,680 --> 00:02:10,860
flicking through that and there's a

00:02:09,569 --> 00:02:11,980
search for that you can search by

00:02:10,860 --> 00:02:12,879
humming nowadays

00:02:11,980 --> 00:02:15,940
I can't remember the name of the

00:02:12,879 --> 00:02:17,319
applications to do it but they exist and

00:02:15,940 --> 00:02:19,569
today we're going to talk mostly about

00:02:17,319 --> 00:02:22,890
Shazam but the techniques I'll talk

00:02:19,569 --> 00:02:25,629
about will apply to other fields as well

00:02:22,890 --> 00:02:28,420
it's a little bit magic I'm gonna be

00:02:25,629 --> 00:02:31,330
honest but hopefully we'll understand it

00:02:28,420 --> 00:02:34,450
by the end ok so what did I choose

00:02:31,330 --> 00:02:36,489
Python for this cuz surely it's a pretty

00:02:34,450 --> 00:02:37,870
bad choice for real-time processing that

00:02:36,489 --> 00:02:40,480
you want to go fairly quickly if you

00:02:37,870 --> 00:02:42,970
want the user to not give up and just go

00:02:40,480 --> 00:02:45,160
away from their phone but the thing is

00:02:42,970 --> 00:02:45,940
it's actually not that bad for a data

00:02:45,160 --> 00:02:48,069
processing

00:02:45,940 --> 00:02:50,829
we've got languages sorry libraries like

00:02:48,069 --> 00:02:53,290
numpy scipy matplotlib for visualizing

00:02:50,829 --> 00:02:55,269
data when you're developing and pythons

00:02:53,290 --> 00:02:56,799
actually quite good for this a lot of

00:02:55,269 --> 00:03:00,459
numpy is written in C so it's fairly

00:02:56,799 --> 00:03:02,079
fast not only that but the best language

00:03:00,459 --> 00:03:04,090
in my opinion is the language that you

00:03:02,079 --> 00:03:05,140
know the best and I think since we're

00:03:04,090 --> 00:03:07,900
all at the Python conference that's

00:03:05,140 --> 00:03:09,670
probably going to be Python for us so

00:03:07,900 --> 00:03:13,329
here's the awesome demo that totally

00:03:09,670 --> 00:03:16,030
works I spent quite long time trying to

00:03:13,329 --> 00:03:17,109
get this to work and well it totally

00:03:16,030 --> 00:03:18,819
works but I'm not going to show you

00:03:17,109 --> 00:03:22,150
because it's far too cool for all you

00:03:18,819 --> 00:03:24,250
guys yeah it doesn't work I didn't build

00:03:22,150 --> 00:03:25,720
it the challenge to the listener is for

00:03:24,250 --> 00:03:28,889
you to go out and build it after I've

00:03:25,720 --> 00:03:28,889
told you how it works

00:03:29,010 --> 00:03:35,220
so quick show of hands if I was to say

00:03:32,760 --> 00:03:37,290
the words signals and Fourier transforms

00:03:35,220 --> 00:03:40,670
to people who would understand what I

00:03:37,290 --> 00:03:44,010
meant Oh lovely

00:03:40,670 --> 00:03:46,500
fantastic so yeah for those few people

00:03:44,010 --> 00:03:48,360
have been for a transform you take a

00:03:46,500 --> 00:03:50,700
signal in the time domain so it's time

00:03:48,360 --> 00:03:52,560
against amplitude and you extracted

00:03:50,700 --> 00:03:53,910
frequencies from it you don't need to

00:03:52,560 --> 00:03:55,680
know the maths behind it because they're

00:03:53,910 --> 00:03:57,989
awful if you've ever seen the equations

00:03:55,680 --> 00:04:01,500
it's got imaginary numbers and cosines

00:03:57,989 --> 00:04:04,290
and disgusting so signal is just

00:04:01,500 --> 00:04:07,200
information as well are you also hear me

00:04:04,290 --> 00:04:08,970
here say the words FFT all the phrase f

00:04:07,200 --> 00:04:11,790
of T that's just fast Fourier transform

00:04:08,970 --> 00:04:14,190
it's an algorithm used generally to

00:04:11,790 --> 00:04:15,510
calculate these things and it's faster

00:04:14,190 --> 00:04:18,539
than doing the infinite recursion that

00:04:15,510 --> 00:04:21,090
the masked thing uses so the basic

00:04:18,539 --> 00:04:23,490
structure application is a normalizer a

00:04:21,090 --> 00:04:25,590
fingerprint and some storage and

00:04:23,490 --> 00:04:26,970
afterwards and the thing to recognize

00:04:25,590 --> 00:04:29,449
with the normalizer is it's not

00:04:26,970 --> 00:04:31,710
normalized like you might have on itunes

00:04:29,449 --> 00:04:34,470
usually when people in audio talk about

00:04:31,710 --> 00:04:36,120
normalizes they take some audio multiple

00:04:34,470 --> 00:04:38,849
pieces and they make it all of the same

00:04:36,120 --> 00:04:41,340
sort of volume this is not that this is

00:04:38,849 --> 00:04:43,740
taking audio of different sample rates

00:04:41,340 --> 00:04:45,750
so how fast you've been digitizing it

00:04:43,740 --> 00:04:48,030
different bit depths sort of resolution

00:04:45,750 --> 00:04:50,729
of it in formats and turning it into a

00:04:48,030 --> 00:04:52,260
one single format this is great because

00:04:50,729 --> 00:04:54,030
it means we can write only one finger

00:04:52,260 --> 00:04:56,849
printer and it saves you a lot of

00:04:54,030 --> 00:04:59,039
development time not that I finished

00:04:56,849 --> 00:05:01,710
that so you might be able to use fire

00:04:59,039 --> 00:05:05,550
for mpeg-4 this which is a library that

00:05:01,710 --> 00:05:07,470
basically wraps ffmpeg and ffmpeg is a

00:05:05,550 --> 00:05:10,200
converter for all sorts of multimedia it

00:05:07,470 --> 00:05:12,450
does video as well but I looked at the

00:05:10,200 --> 00:05:15,599
page and last time I was updated was

00:05:12,450 --> 00:05:18,510
about 1934 so I decided again shoes than

00:05:15,599 --> 00:05:20,580
that there's also live AV codec which is

00:05:18,510 --> 00:05:23,010
the C version and you could use that

00:05:20,580 --> 00:05:25,879
directly with C typed but I viewed seat

00:05:23,010 --> 00:05:28,189
ups before and I decided against that

00:05:25,879 --> 00:05:29,779
so finger printer what do we want to do

00:05:28,189 --> 00:05:31,490
with the fingerprint well

00:05:29,779 --> 00:05:33,259
comparing like for like with audios

00:05:31,490 --> 00:05:37,729
percent doesn't work different bit

00:05:33,259 --> 00:05:39,649
depths different representations etc so

00:05:37,729 --> 00:05:42,050
we want to compress it as well not just

00:05:39,649 --> 00:05:44,270
that you've got smaller storage if

00:05:42,050 --> 00:05:45,979
you're taking fingerprints that come to

00:05:44,270 --> 00:05:49,279
about seven bytes each and you've got

00:05:45,979 --> 00:05:50,959
what a few hundred of these per song

00:05:49,279 --> 00:05:52,789
which is a lot smaller than three

00:05:50,959 --> 00:05:54,729
megabytes and if you're storing a

00:05:52,789 --> 00:05:56,809
million songs in your database then

00:05:54,729 --> 00:05:59,330
you're gonna want to compress it as much

00:05:56,809 --> 00:06:01,819
as you can this also gives us a faster

00:05:59,330 --> 00:06:03,229
search the last you have to search

00:06:01,819 --> 00:06:05,990
through the faster you can go through it

00:06:03,229 --> 00:06:09,379
and robustness in the presence of noise

00:06:05,990 --> 00:06:11,209
so if you're a for example over geek

00:06:09,379 --> 00:06:12,860
before the gig starts they play this

00:06:11,209 --> 00:06:14,779
music on the speakers and because it's a

00:06:12,860 --> 00:06:16,999
gig of someone you like because you're

00:06:14,779 --> 00:06:17,990
there you probably like the music that

00:06:16,999 --> 00:06:19,399
they're playing on the speakers you

00:06:17,990 --> 00:06:20,839
might wanna identify it but of course

00:06:19,399 --> 00:06:24,080
there's the drunk guy shouting next to

00:06:20,839 --> 00:06:26,569
you you want your phone to still

00:06:24,080 --> 00:06:29,449
recognize what song it is despite this

00:06:26,569 --> 00:06:31,159
noise that's going on you also want it

00:06:29,449 --> 00:06:33,079
to be that it can match only short

00:06:31,159 --> 00:06:34,519
recordings to the full original did you

00:06:33,079 --> 00:06:35,659
understand therefore the entirety of the

00:06:34,519 --> 00:06:38,559
song you're solving your phone like this

00:06:35,659 --> 00:06:39,709
like a proper numpty it's not that fun

00:06:38,559 --> 00:06:42,439
okay

00:06:39,709 --> 00:06:44,930
so here's the basic diagram of how the

00:06:42,439 --> 00:06:47,379
finger printer works it's fairly large

00:06:44,930 --> 00:06:50,389
but we'll go through line by line

00:06:47,379 --> 00:06:52,099
starting with the first one so these are

00:06:50,389 --> 00:06:54,949
the diagrams you so should

00:06:52,099 --> 00:06:56,749
saw before first off we take the audio

00:06:54,949 --> 00:07:00,469
which looks a lot like the left graph

00:06:56,749 --> 00:07:02,479
well but wiggly a' and longer and we

00:07:00,469 --> 00:07:04,399
bullets split it up into smaller Wiggly

00:07:02,479 --> 00:07:08,659
bits so that you can get frequencies of

00:07:04,399 --> 00:07:09,870
each individual we then do the Fourier

00:07:08,659 --> 00:07:12,960
on it

00:07:09,870 --> 00:07:15,690
and the advantage of this is that if you

00:07:12,960 --> 00:07:18,570
look to the previous one this the next

00:07:15,690 --> 00:07:22,140
signal you give out see is the same

00:07:18,570 --> 00:07:23,970
signal here but with noise added and the

00:07:22,140 --> 00:07:25,260
Fourier transform you can still see the

00:07:23,970 --> 00:07:27,810
fifty Hertz in the 80 Hertz quite

00:07:25,260 --> 00:07:33,270
clearly so this helps us to protect

00:07:27,810 --> 00:07:34,790
ourselves from the noise floor the other

00:07:33,270 --> 00:07:37,800
thing you want to do while we're here is

00:07:34,790 --> 00:07:40,470
humans don't listen to or don't

00:07:37,800 --> 00:07:42,330
experience frequency and sound linearly

00:07:40,470 --> 00:07:45,000
if you played someone a hundred percent

00:07:42,330 --> 00:07:46,470
and then a two hundred Hertz sound and

00:07:45,000 --> 00:07:48,440
then played them in 10,000 Hertz sound

00:07:46,470 --> 00:07:50,730
in ten thousand one hundred that sound

00:07:48,440 --> 00:07:51,810
the different the second one is going to

00:07:50,730 --> 00:07:53,820
seem a lot closer together

00:07:51,810 --> 00:07:54,980
because we hear the logarithmically so

00:07:53,820 --> 00:07:58,770
there's something called the mel scale

00:07:54,980 --> 00:08:00,480
which is basically logarithmic scale and

00:07:58,770 --> 00:08:02,790
the added benefit of that is that it

00:08:00,480 --> 00:08:04,110
cuts down the data so the highest smell

00:08:02,790 --> 00:08:05,700
we can hear is about four thousand

00:08:04,110 --> 00:08:09,510
whereas the highest frequency we can

00:08:05,700 --> 00:08:13,260
hear is about twenty two K so you then

00:08:09,510 --> 00:08:15,630
take this and you hash it oh hang on oh

00:08:13,260 --> 00:08:17,430
I skipped something yes

00:08:15,630 --> 00:08:21,180
I've skipped something sorry here we are

00:08:17,430 --> 00:08:23,160
so you take this and you make it into a

00:08:21,180 --> 00:08:25,080
spectrogram what we've done is we've

00:08:23,160 --> 00:08:26,940
taken this Fourier transform and we've

00:08:25,080 --> 00:08:28,710
got the high bits the large amplitude

00:08:26,940 --> 00:08:29,310
bits and we made them dark and we've got

00:08:28,710 --> 00:08:31,740
the low bits

00:08:29,310 --> 00:08:33,060
Dalila to bits and made them light and

00:08:31,740 --> 00:08:34,620
we've kind of turned it on its side and

00:08:33,060 --> 00:08:36,210
done this a bunch of times across the

00:08:34,620 --> 00:08:37,770
entire track and this gives you

00:08:36,210 --> 00:08:40,110
something called a spectrogram which you

00:08:37,770 --> 00:08:43,440
can see on the left it's basically a

00:08:40,110 --> 00:08:45,450
representation of frequency over time of

00:08:43,440 --> 00:08:47,370
the song or the piece of audio you've

00:08:45,450 --> 00:08:49,170
got so you want to take the highest

00:08:47,370 --> 00:08:50,550
points of this because as we told before

00:08:49,170 --> 00:08:52,010
the highest points always survive the

00:08:50,550 --> 00:08:55,820
noise

00:08:52,010 --> 00:08:58,810
and with that you can then you basically

00:08:55,820 --> 00:09:01,490
run a nearest neighbor search on it so

00:08:58,810 --> 00:09:04,940
you just check for local minima local

00:09:01,490 --> 00:09:07,400
maxima sorry and I think where I did

00:09:04,940 --> 00:09:11,390
this was I just sorted them and then

00:09:07,400 --> 00:09:12,550
pick the top 30 or whatever yes so we'll

00:09:11,390 --> 00:09:15,110
go back to the slides that whether

00:09:12,550 --> 00:09:19,220
you've got your anchor points you've got

00:09:15,110 --> 00:09:20,870
your maximum points now which exists a

00:09:19,220 --> 00:09:23,930
long time and you split these into

00:09:20,870 --> 00:09:25,430
larger regions in each region you want

00:09:23,930 --> 00:09:28,760
to find something called an anchor point

00:09:25,430 --> 00:09:31,850
and this anchor point is just used for

00:09:28,760 --> 00:09:33,620
pairing with other point so in the

00:09:31,850 --> 00:09:35,180
original shazam paper which you can find

00:09:33,620 --> 00:09:38,600
online I can show you a link if you want

00:09:35,180 --> 00:09:41,270
to afterwards he says okay you need to

00:09:38,600 --> 00:09:43,370
get some anchor points and you ask how

00:09:41,270 --> 00:09:47,300
and of course because it's a paper it

00:09:43,370 --> 00:09:49,580
doesn't respond which is unfortunate so

00:09:47,300 --> 00:09:50,870
I took maximum I decided the largest

00:09:49,580 --> 00:09:53,990
point in that region would be our anchor

00:09:50,870 --> 00:09:55,490
point and with this you literally just

00:09:53,990 --> 00:09:57,970
pair it up to every single point in the

00:09:55,490 --> 00:10:01,550
following region with the end region

00:09:57,970 --> 00:10:02,930
skip it so the reason we're doing this

00:10:01,550 --> 00:10:04,910
instead of just storing all the

00:10:02,930 --> 00:10:07,940
frequencies or the maximum points here

00:10:04,910 --> 00:10:09,980
is because in adds more entry so it

00:10:07,940 --> 00:10:12,080
makes your some more distinguishable so

00:10:09,980 --> 00:10:13,940
if you would have Metallica's wherever I

00:10:12,080 --> 00:10:15,020
may roam and you would have Britney

00:10:13,940 --> 00:10:17,270
Spears oops I did it again

00:10:15,020 --> 00:10:18,950
they might share some frequencies but

00:10:17,270 --> 00:10:20,390
we'd all probably agree they're fairly

00:10:18,950 --> 00:10:26,300
different songs even if you've never

00:10:20,390 --> 00:10:28,400
heard one of them you love them so by

00:10:26,300 --> 00:10:30,380
pairing them you've not only got that

00:10:28,400 --> 00:10:31,460
frequency in the other frequency but

00:10:30,380 --> 00:10:33,170
you've got the time difference between

00:10:31,460 --> 00:10:36,970
them it's adding more information more

00:10:33,170 --> 00:10:40,940
distinguished humility so here we go

00:10:36,970 --> 00:10:44,120
here is your hash this this is a hash we

00:10:40,940 --> 00:10:47,810
don't bother with sha-256 or whatever we

00:10:44,120 --> 00:10:51,080
literally just take the two points f1 f2

00:10:47,810 --> 00:10:53,210
and we connect them together so a bit on

00:10:51,080 --> 00:10:55,370
the Left f1 frequency one frequency -

00:10:53,210 --> 00:10:56,540
difference in time and you also store

00:10:55,370 --> 00:10:58,190
this along with the time of the first

00:10:56,540 --> 00:11:00,050
point so you can identify where in the

00:10:58,190 --> 00:11:04,040
track you are and the idea of the song

00:11:00,050 --> 00:11:06,020
that you're fingerprinting so that you

00:11:04,040 --> 00:11:08,360
can identify which song you actually

00:11:06,020 --> 00:11:10,670
have that's an important bit don't

00:11:08,360 --> 00:11:15,339
forget that there we are so storage

00:11:10,670 --> 00:11:18,860
you've now got this f1 f2 dt t1 and

00:11:15,339 --> 00:11:21,100
these kind of go together quite compress

00:11:18,860 --> 00:11:25,640
ly so you want it to be a fixed size

00:11:21,100 --> 00:11:27,620
because variable sized storage is wow

00:11:25,640 --> 00:11:30,320
it's quite slow sir surely comparatively

00:11:27,620 --> 00:11:34,100
and it's easier this way

00:11:30,320 --> 00:11:36,170
so frequencies in males as I said 4,000

00:11:34,100 --> 00:11:39,470
smells is about Heights you can hear so

00:11:36,170 --> 00:11:41,960
we can fit that into our bytes 4096 time

00:11:39,470 --> 00:11:45,500
is in milliseconds here it's arbitrary

00:11:41,960 --> 00:11:49,010
you could do it in system ticks if you

00:11:45,500 --> 00:11:50,240
felt particularly masochistic and that

00:11:49,010 --> 00:11:53,780
means you can store in about 10 bytes

00:11:50,240 --> 00:11:56,570
ass 1,024 that gives us a second worth

00:11:53,780 --> 00:11:59,270
between an anchor point and each pair

00:11:56,570 --> 00:12:01,460
point which is fair enough it gives you

00:11:59,270 --> 00:12:03,200
about 512 milliseconds for each region

00:12:01,460 --> 00:12:05,480
and you don't want anything near that

00:12:03,200 --> 00:12:07,040
the windows that we split into for the

00:12:05,480 --> 00:12:09,080
Fourier transform would be about 16

00:12:07,040 --> 00:12:12,440
milliseconds ish depending on what you

00:12:09,080 --> 00:12:14,870
configured it has and the reason we

00:12:12,440 --> 00:12:17,990
store this as milliseconds as opposed to

00:12:14,870 --> 00:12:21,140
window number of windows that we're

00:12:17,990 --> 00:12:23,839
using is because then if you change the

00:12:21,140 --> 00:12:26,060
number of windows per each region for

00:12:23,839 --> 00:12:28,780
the anchor points then you can keep

00:12:26,060 --> 00:12:28,780
compatibility

00:12:28,930 --> 00:12:37,370
so this also imposes a limitation on t1

00:12:34,399 --> 00:12:41,029
which is the time of the first point as

00:12:37,370 --> 00:12:42,740
that can be no more than here we go four

00:12:41,029 --> 00:12:44,540
million one hundred ninety-four thousand

00:12:42,740 --> 00:12:47,420
three hundred four milliseconds I didn't

00:12:44,540 --> 00:12:49,490
read that I memorized it so that's about

00:12:47,420 --> 00:12:51,829
70 minutes which if you're doing a music

00:12:49,490 --> 00:12:53,540
identification service that's that's

00:12:51,829 --> 00:12:55,970
going to get you the majority of all but

00:12:53,540 --> 00:12:56,600
the most obscure prog tracks for

00:12:55,970 --> 00:12:59,990
something else

00:12:56,600 --> 00:13:01,579
if you had an identification service for

00:12:59,990 --> 00:13:03,860
talk audio for example that could be

00:13:01,579 --> 00:13:06,980
something you build then you might want

00:13:03,860 --> 00:13:09,439
that feel to be bigger so then put these

00:13:06,980 --> 00:13:13,069
into a database and you can search

00:13:09,439 --> 00:13:15,230
through them what if you just want

00:13:13,069 --> 00:13:19,389
something that works there is an

00:13:15,230 --> 00:13:25,129
application out there called DejaVu

00:13:19,389 --> 00:13:28,339
that's it and it is this it's a Python

00:13:25,129 --> 00:13:29,509
implementation of Shazam I swear I

00:13:28,339 --> 00:13:32,149
didn't know it existed

00:13:29,509 --> 00:13:33,800
before I started this but it does

00:13:32,149 --> 00:13:35,569
literally just work you put it on your

00:13:33,800 --> 00:13:38,240
computer you kind of press play and it

00:13:35,569 --> 00:13:39,350
goes and it's fantastic if you're

00:13:38,240 --> 00:13:42,160
looking to do it that's the github

00:13:39,350 --> 00:13:46,639
address that's the guys name is genius

00:13:42,160 --> 00:13:49,040
go do something with it one file down

00:13:46,639 --> 00:13:50,000
take away we may look at them code

00:13:49,040 --> 00:13:52,850
because I've gone through this a bit

00:13:50,000 --> 00:13:56,329
quick this project was inspired by

00:13:52,850 --> 00:13:58,519
talking for stem i admit i didn't finish

00:13:56,329 --> 00:14:00,259
the project but i've learned a hell of a

00:13:58,519 --> 00:14:02,990
lot doing so i've never done any of this

00:14:00,259 --> 00:14:03,949
math ced SP stuff before it's quite cool

00:14:02,990 --> 00:14:06,529
you should look into it

00:14:03,949 --> 00:14:09,290
there are a lot of talks here and i've

00:14:06,529 --> 00:14:11,300
seen them from go to machine learning to

00:14:09,290 --> 00:14:13,879
the micro bit i here we might be able to

00:14:11,300 --> 00:14:16,250
get micro bits that sounds cool so pick

00:14:13,879 --> 00:14:18,259
something up and run with it and i want

00:14:16,250 --> 00:14:21,290
to see you guys here next year for

00:14:18,259 --> 00:14:23,420
example I saw one paper where a guy took

00:14:21,290 --> 00:14:25,370
multiple videos of a concert from

00:14:23,420 --> 00:14:27,420
different viewpoints and he synchronized

00:14:25,370 --> 00:14:28,800
more using fingerprints of the audio

00:14:27,420 --> 00:14:30,600
that could be something you guys have

00:14:28,800 --> 00:14:32,220
code implementing I think there's only

00:14:30,600 --> 00:14:36,050
been one implementation so far in the

00:14:32,220 --> 00:14:42,690
world always needs more questions all

00:14:36,050 --> 00:14:46,130
code code let's look at some code hello

00:14:42,690 --> 00:14:49,670
code okay cool so this is a notebook

00:14:46,130 --> 00:14:49,670
it's available on github

00:14:50,090 --> 00:14:54,570
I'll talk you through it quickly it's

00:14:52,620 --> 00:14:56,550
not very well organized you read in the

00:14:54,570 --> 00:14:58,650
audio this is what song looks like by

00:14:56,550 --> 00:15:02,040
the way it's quite cool if no one's ever

00:14:58,650 --> 00:15:04,800
seen that probably who are you then

00:15:02,040 --> 00:15:05,340
dude this was me figuring out how FFT is

00:15:04,800 --> 00:15:07,170
worked

00:15:05,340 --> 00:15:08,550
they're quite difficult that's what you

00:15:07,170 --> 00:15:14,310
get to start off with you don't want

00:15:08,550 --> 00:15:17,040
that if you get that so there you go Mel

00:15:14,310 --> 00:15:20,340
there's your mail frequency that's the

00:15:17,040 --> 00:15:22,080
equation off Wikipedia don't blame me we

00:15:20,340 --> 00:15:23,510
don't take that we just take the

00:15:22,080 --> 00:15:25,740
integers so that we got smaller storage

00:15:23,510 --> 00:15:31,700
that function is far more complicated

00:15:25,740 --> 00:15:34,140
than you speak and so this is normal

00:15:31,700 --> 00:15:36,120
this is your frequencies before the

00:15:34,140 --> 00:15:39,390
interview and that's hang on sorry

00:15:36,120 --> 00:15:41,010
that is your fft and as you can see the

00:15:39,390 --> 00:15:44,040
frequencies that we want are all near

00:15:41,010 --> 00:15:45,300
the bottom because that's well I mean

00:15:44,040 --> 00:15:47,460
this particular piece of audio is quite

00:15:45,300 --> 00:15:49,590
basic but that's where we generally tend

00:15:47,460 --> 00:15:52,830
hear the most of it so if you take the

00:15:49,590 --> 00:15:54,300
male version the bottom stretches out

00:15:52,830 --> 00:15:56,610
quite a lot more and you've got a lot

00:15:54,300 --> 00:15:58,970
more useful information for a lot less

00:15:56,610 --> 00:15:58,970
storage

00:15:59,590 --> 00:16:05,980
defining some stuff - finding some stuff

00:16:02,440 --> 00:16:08,600
not very interesting ooh spectrograms

00:16:05,980 --> 00:16:10,580
matplotlib I've been told it does

00:16:08,600 --> 00:16:13,570
spectrograms this doesn't look

00:16:10,580 --> 00:16:15,650
particularly Specter Grammy to me

00:16:13,570 --> 00:16:16,910
constellation maps I didn't actually

00:16:15,650 --> 00:16:20,060
plot that for those your constellation

00:16:16,910 --> 00:16:21,290
map and then the hashing this is all on

00:16:20,060 --> 00:16:24,050
github for you to look at if you

00:16:21,290 --> 00:16:29,840
particularly want it so yeah

00:16:24,050 --> 00:16:33,310
actual questions hello yes okay so you

00:16:29,840 --> 00:16:35,210
have to speak here because it's recorded

00:16:33,310 --> 00:16:37,310
really silly question

00:16:35,210 --> 00:16:39,620
what's a Mel and was it named after who

00:16:37,310 --> 00:16:42,980
came up with it I'm pretty sure it was

00:16:39,620 --> 00:16:44,960
and m/l is defined as two thousand five

00:16:42,980 --> 00:16:51,250
hundred ninety five times the log base

00:16:44,960 --> 00:16:54,170
10 of 1 over something of your frequency

00:16:51,250 --> 00:16:55,700
it's it's a very weird unit for

00:16:54,170 --> 00:16:57,740
frequency and it's basically a

00:16:55,700 --> 00:17:00,380
logarithmic scale for frequency as

00:16:57,740 --> 00:17:03,530
opposed to a linear one where's the

00:17:00,380 --> 00:17:03,890
equation did I skip it yeah I did there

00:17:03,530 --> 00:17:06,950
you go

00:17:03,890 --> 00:17:10,130
log base 10 of 1 plus your thing over

00:17:06,950 --> 00:17:12,770
700 don't ask me where he got that from

00:17:10,130 --> 00:17:14,570
it was an experiment in the 50s and they

00:17:12,770 --> 00:17:16,520
got a bunch of musicians and said okay

00:17:14,570 --> 00:17:17,690
can you hear this is that different from

00:17:16,520 --> 00:17:20,150
the one before is that different from

00:17:17,690 --> 00:17:23,709
the one before and they just sorted that

00:17:20,150 --> 00:17:23,709
and made a graph based off of

00:17:25,670 --> 00:17:31,520
more questions actually I have forgotten

00:17:28,710 --> 00:17:31,520
oh there's a question

00:17:31,940 --> 00:17:37,470
so the fingerprint of is of the entire

00:17:35,250 --> 00:17:39,390
song and it's just that collection of

00:17:37,470 --> 00:17:45,450
data points that you get yeah so the

00:17:39,390 --> 00:17:47,430
fingerprint is the collection or not

00:17:45,450 --> 00:17:51,780
that thing not that thing that thing you

00:17:47,430 --> 00:17:55,350
take this thing and you do this so for

00:17:51,780 --> 00:17:57,960
that each of these links would be one

00:17:55,350 --> 00:18:00,840
fingerprint and for the entire song

00:17:57,960 --> 00:18:02,760
you'd do that and that together would be

00:18:00,840 --> 00:18:04,410
the fingerprint of your song so so yeah

00:18:02,760 --> 00:18:05,790
each of those would be a hash and those

00:18:04,410 --> 00:18:07,710
hashes together would be the fingerprint

00:18:05,790 --> 00:18:09,690
of your song and so how do you compare

00:18:07,710 --> 00:18:11,190
the two finger person was that do you

00:18:09,690 --> 00:18:14,070
literally so you search for exact

00:18:11,190 --> 00:18:15,840
matches so the storage based a bit I

00:18:14,070 --> 00:18:17,610
didn't really do very well that's why I

00:18:15,840 --> 00:18:19,590
doesn't work but you compare the two

00:18:17,610 --> 00:18:24,990
matches see if they match exactly

00:18:19,590 --> 00:18:29,220
if not you can create basically a thing

00:18:24,990 --> 00:18:31,410
of how many match and then there was

00:18:29,220 --> 00:18:33,660
another talk on this can link you to its

00:18:31,410 --> 00:18:36,660
Faust and he's much cleverer than me and

00:18:33,660 --> 00:18:42,210
he knows these things I have a question

00:18:36,660 --> 00:18:45,300
so now I can ask myself so to what kind

00:18:42,210 --> 00:18:47,250
of distorts is it robust so if you for

00:18:45,300 --> 00:18:49,590
example or if you're a DJ and then

00:18:47,250 --> 00:18:53,610
you're pitching will it still work or

00:18:49,590 --> 00:18:57,660
sit them off so time-based distortions

00:18:53,610 --> 00:19:00,210
it should work because well within an

00:18:57,660 --> 00:19:01,860
extent if you obviously stretch it about

00:19:00,210 --> 00:19:03,990
5,000 times it's not gonna work but if

00:19:01,860 --> 00:19:05,190
you stretch it a little bit that should

00:19:03,990 --> 00:19:08,070
work because you've still got the finger

00:19:05,190 --> 00:19:09,780
prints it depends on your when you

00:19:08,070 --> 00:19:12,870
search it it depends on how accurate you

00:19:09,780 --> 00:19:15,960
want be or you decide the time should be

00:19:12,870 --> 00:19:17,190
how close the time should be in terms of

00:19:15,960 --> 00:19:19,320
other noise

00:19:17,190 --> 00:19:21,690
Shazam when they release this paper they

00:19:19,320 --> 00:19:23,460
said it was it worked perfectly over the

00:19:21,690 --> 00:19:23,940
GSM network so bit of history for

00:19:23,460 --> 00:19:26,519
everyone

00:19:23,940 --> 00:19:28,259
Shazaam wasn't always a nap it was a

00:19:26,519 --> 00:19:30,240
service that you rang up and then would

00:19:28,259 --> 00:19:31,740
be like hold your phone to the music and

00:19:30,240 --> 00:19:33,779
you told your phone to the music and

00:19:31,740 --> 00:19:35,309
then it would text you afterwards which

00:19:33,779 --> 00:19:38,789
was really quite calm that's how they

00:19:35,309 --> 00:19:40,799
started so be robust to the phone

00:19:38,789 --> 00:19:46,279
network and this robust to TV noise and

00:19:40,799 --> 00:19:46,279
things like that so okay more questions

00:19:46,399 --> 00:19:50,000
yes so do

00:19:54,870 --> 00:20:00,810
dunno if there is some similarity in the

00:19:57,640 --> 00:20:05,080
hashing system as to musicbrainz

00:20:00,810 --> 00:20:07,930
musicbrainz ah now I have something for

00:20:05,080 --> 00:20:11,890
this it's not that that's in fact all

00:20:07,930 --> 00:20:12,670
the processes what is musicbrainz I'm

00:20:11,890 --> 00:20:15,450
going to try and remember what

00:20:12,670 --> 00:20:15,450
musicbrainz is

00:20:18,090 --> 00:20:21,049
oh it's don't

00:20:22,320 --> 00:20:25,560
oh no I haven't written down what

00:20:24,000 --> 00:20:28,350
musicbrainz is sorry I'm no idea so

00:20:25,560 --> 00:20:32,750
musicbrainz is basically a database of

00:20:28,350 --> 00:20:34,650
hashes of tracks the whole track and

00:20:32,750 --> 00:20:38,790
basically it helps you you have some

00:20:34,650 --> 00:20:40,740
empty trays or files on your computer

00:20:38,790 --> 00:20:43,200
and you want to fix the tax to fit the

00:20:40,740 --> 00:20:45,900
title all the other it has a database of

00:20:43,200 --> 00:20:49,650
all of these tags occur and also a hash

00:20:45,900 --> 00:20:51,600
of that file so if you have an mp3

00:20:49,650 --> 00:20:54,000
converted from my head not eg from

00:20:51,600 --> 00:20:59,670
whatever it will still be able to find

00:20:54,000 --> 00:21:03,540
out with what break it is ok so if it's

00:20:59,670 --> 00:21:06,060
based off of the Shazam paper then yes

00:21:03,540 --> 00:21:07,830
it's similar however there are a few

00:21:06,060 --> 00:21:09,150
other big papers have been released in

00:21:07,830 --> 00:21:11,340
here computer vision for music

00:21:09,150 --> 00:21:13,170
identification was a very big one and

00:21:11,340 --> 00:21:15,450
that uses a slightly different technique

00:21:13,170 --> 00:21:18,320
in that it uses computer vision

00:21:15,450 --> 00:21:22,050
similarity things to calculate the hash

00:21:18,320 --> 00:21:28,760
that is a subject for a whole other 5

00:21:22,050 --> 00:21:28,760
talks so yes and no maybe

00:21:30,620 --> 00:21:37,530
okay more questions I'm still fit enough

00:21:34,890 --> 00:21:41,460
to come to everyone so also in the back

00:21:37,530 --> 00:21:44,760
nobody okay if there are no more

00:21:41,460 --> 00:21:46,920
questions then we can close the session

00:21:44,760 --> 00:21:49,740
and also the first day of the Europe

00:21:46,920 --> 00:21:52,950
Eisen I hope you had fun and learned a

00:21:49,740 --> 00:21:55,880
lot of stuff so see you tomorrow

00:21:52,950 --> 00:21:55,880

YouTube URL: https://www.youtube.com/watch?v=LZ7THTB88AE


