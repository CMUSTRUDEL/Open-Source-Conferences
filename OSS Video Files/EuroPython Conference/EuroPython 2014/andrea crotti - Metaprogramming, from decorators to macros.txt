Title: andrea crotti - Metaprogramming, from decorators to macros
Publication date: 2015-04-18
Playlist: EuroPython 2014
Description: 
	andrea crotti - Metaprogramming, from decorators to macros
[EuroPython 2014]
[24 July 2014]

Starting off with the meaning of metaprogramming we quickly dive into the different ways Python allows this.
First we talk about class and functions decorators, when decorators are not enough anymore we'll explore the wonders of metaclasses.
In the last part of the talk we'll talk about macros, first in Lisp and then using the amazing macropy library.

-----

This talk is a journey in the wonderful world of metaprogramming.
We start off with the meaning of metaprogramming and what it can be used for.

Then we look at what can be done in Python, introducing function and class decorators.
When decorators are not enough anymore we move to the black magic of metaclasses, showing how we can implemement a simple Django-like model with them.

In the bonus track we'll talk about macros, as the ultimate metaprogramming weapon, showing briefly how Lisp macros work and introducing the amazing [macropy library](https://github.com/lihaoyi/macropy).
Captions: 
	00:00:14,710 --> 00:00:20,619
so hi everyone this my Twitter account

00:00:17,830 --> 00:00:22,810
and this link here that you can see you

00:00:20,619 --> 00:00:24,189
can already download my only material

00:00:22,810 --> 00:00:26,140
and going to show that will be the

00:00:24,189 --> 00:00:27,610
decoder going to show and the slide

00:00:26,140 --> 00:00:31,560
source so you can have a look and play

00:00:27,610 --> 00:00:34,390
around you're welcome to open Python and

00:00:31,560 --> 00:00:35,829
interactively try the examples i'm going

00:00:34,390 --> 00:00:41,020
to show you because that's what i will

00:00:35,829 --> 00:00:42,370
do as well so I come from Italy but I

00:00:41,020 --> 00:00:44,559
live in London and I work for this

00:00:42,370 --> 00:00:48,039
company called d pop it's just a small

00:00:44,559 --> 00:00:49,359
advertisement slide where I tell just

00:00:48,039 --> 00:00:52,449
telling you that we are hiring we're

00:00:49,359 --> 00:00:53,859
looking for API developers and if you're

00:00:52,449 --> 00:00:57,670
interested just have a looked at the pub

00:00:53,859 --> 00:01:01,620
com jobs you're using Django salary or

00:00:57,670 --> 00:01:04,480
nice things MongoDB postgres etc sitter

00:01:01,620 --> 00:01:07,060
alright so what we're going to talk

00:01:04,480 --> 00:01:08,890
about today first of all I try to define

00:01:07,060 --> 00:01:12,640
what is meta programming and why is

00:01:08,890 --> 00:01:14,800
useful and then we are going to talk

00:01:12,640 --> 00:01:17,620
about least a little bit but not too

00:01:14,800 --> 00:01:20,619
much so don't be scared and then we're

00:01:17,620 --> 00:01:22,840
going to talk python by Python and how

00:01:20,619 --> 00:01:27,009
some techniques we can use for meta

00:01:22,840 --> 00:01:29,619
programming in Python so this is the

00:01:27,009 --> 00:01:31,689
definition I found Wikipedia about meta

00:01:29,619 --> 00:01:34,630
programming I don't know is the best one

00:01:31,689 --> 00:01:36,670
but let's try to go this one meta

00:01:34,630 --> 00:01:39,040
programming is the writing of computer

00:01:36,670 --> 00:01:42,640
programs that right or manipulate other

00:01:39,040 --> 00:01:45,009
programs or themselves as their data or

00:01:42,640 --> 00:01:49,890
that do part of the work at compile time

00:01:45,009 --> 00:01:53,500
that would be otherwise done at runtime

00:01:49,890 --> 00:01:55,570
so this is kind of still not very clear

00:01:53,500 --> 00:01:58,869
but I think we're going to see now in

00:01:55,570 --> 00:02:01,829
some examples how these what this really

00:01:58,869 --> 00:02:04,990
means I manipulate the program itself

00:02:01,829 --> 00:02:06,729
manipulate themselves well I don't know

00:02:04,990 --> 00:02:09,759
I'll show you show you later what that

00:02:06,729 --> 00:02:11,320
means so why on earth would you do that

00:02:09,759 --> 00:02:13,030
that's the most important question

00:02:11,320 --> 00:02:16,540
because that sounds really magic and

00:02:13,030 --> 00:02:18,580
really strange there are some scenarios

00:02:16,540 --> 00:02:20,890
where this really makes a big difference

00:02:18,580 --> 00:02:24,180
and normally it's used it's not really

00:02:20,890 --> 00:02:27,160
used for performance reasons or for

00:02:24,180 --> 00:02:28,670
making a better product it may be

00:02:27,160 --> 00:02:30,800
normally just used to

00:02:28,670 --> 00:02:34,099
be closer to the domain you're working

00:02:30,800 --> 00:02:36,920
it so you write an abstraction in a more

00:02:34,099 --> 00:02:39,560
powerful way and in the end you re you

00:02:36,920 --> 00:02:43,400
manage to minimize the line of code you

00:02:39,560 --> 00:02:46,310
f or you manage to make the old program

00:02:43,400 --> 00:02:47,810
more close to your domain and more easy

00:02:46,310 --> 00:02:51,310
to understand for the people in that

00:02:47,810 --> 00:02:54,530
domain so what's the cost of that well

00:02:51,310 --> 00:02:57,230
if you do it well nothing if you do

00:02:54,530 --> 00:03:03,440
wrong you might screw yourself up a

00:02:57,230 --> 00:03:06,500
little bit so next slide just a very

00:03:03,440 --> 00:03:11,200
small introduction to lease / so it was

00:03:06,500 --> 00:03:14,030
invented by mccarton 1958 so there was a

00:03:11,200 --> 00:03:16,880
very long time ago it's a grandfather of

00:03:14,030 --> 00:03:18,620
languages in a way and what people think

00:03:16,880 --> 00:03:21,500
about it is that there are a lot of

00:03:18,620 --> 00:03:24,350
parentheses that's how people see

00:03:21,500 --> 00:03:26,900
normally there is a reason however for

00:03:24,350 --> 00:03:30,319
all these parentheses so and then going

00:03:26,900 --> 00:03:34,070
to try to show you what it is this is

00:03:30,319 --> 00:03:37,579
the simplest possible well the simple

00:03:34,070 --> 00:03:41,239
factorial function and this how is the

00:03:37,579 --> 00:03:43,730
fine there is a special form the fan

00:03:41,239 --> 00:03:47,390
which this way of finding functions

00:03:43,730 --> 00:03:50,090
which takes an argument which is a name

00:03:47,390 --> 00:03:51,950
of the function the argument of the

00:03:50,090 --> 00:03:54,230
function and then there is another

00:03:51,950 --> 00:03:59,200
special form if which takes three

00:03:54,230 --> 00:04:03,049
arguments the conditioner the den and

00:03:59,200 --> 00:04:05,690
the else branch here and all that all

00:04:03,049 --> 00:04:08,840
these things are expressions s

00:04:05,690 --> 00:04:11,390
expressions to be precise I'm going to

00:04:08,840 --> 00:04:14,450
do a lot of kind of live coding so maybe

00:04:11,390 --> 00:04:19,880
I'll try now for the first time to just

00:04:14,450 --> 00:04:24,889
show you how things actually work so we

00:04:19,880 --> 00:04:29,930
go in Emacs here of course and I define

00:04:24,889 --> 00:04:34,190
this is the right blog for sbcl which is

00:04:29,930 --> 00:04:38,360
a common lisp interpreter and then I

00:04:34,190 --> 00:04:40,849
hear a defiant tutorial i computed

00:04:38,360 --> 00:04:42,500
everything works fine interesting things

00:04:40,849 --> 00:04:44,750
to note is that e

00:04:42,500 --> 00:04:48,350
and if I give a very high number it

00:04:44,750 --> 00:04:51,260
doesn't blow up like item would do even

00:04:48,350 --> 00:04:55,610
if it's a cursive because it's it's

00:04:51,260 --> 00:04:59,480
smarter about recursion invitin so let's

00:04:55,610 --> 00:05:03,410
continue solis pass very small very

00:04:59,480 --> 00:05:06,500
limited syntax and it's another property

00:05:03,410 --> 00:05:09,430
which is quite uncommon and not of many

00:05:06,500 --> 00:05:13,280
languages which is how my Cornish city

00:05:09,430 --> 00:05:15,260
that's a very difficult word that not

00:05:13,280 --> 00:05:18,050
easy to define but in practical means

00:05:15,260 --> 00:05:22,280
that the program itself is a valid

00:05:18,050 --> 00:05:25,250
representation of the data so here are

00:05:22,280 --> 00:05:28,550
sample what we have is the computation

00:05:25,250 --> 00:05:30,200
of the product between the sign of one

00:05:28,550 --> 00:05:33,080
and the cosine of two point zero three

00:05:30,200 --> 00:05:36,200
and what this actually means is that

00:05:33,080 --> 00:05:38,540
it's like setting an expression to a

00:05:36,200 --> 00:05:42,919
list where the first element of the list

00:05:38,540 --> 00:05:45,560
is a symbol star the second element is

00:05:42,919 --> 00:05:47,900
another list with sign symbol sign and

00:05:45,560 --> 00:05:50,210
101 and the third is another list with

00:05:47,900 --> 00:05:54,590
cosine into the three and then you

00:05:50,210 --> 00:05:58,550
evaluate that expression so why is all

00:05:54,590 --> 00:06:01,580
morn that that word these vehicles you

00:05:58,550 --> 00:06:04,610
can actually transform and pass around a

00:06:01,580 --> 00:06:08,270
program and manipulated easily as it was

00:06:04,610 --> 00:06:11,450
data so to make it more maybe more clear

00:06:08,270 --> 00:06:15,020
I try to say how is Python or more

00:06:11,450 --> 00:06:17,110
iconic but no but what if how would it

00:06:15,020 --> 00:06:19,850
look like if it could be for example

00:06:17,110 --> 00:06:22,520
that might be something i don't know if

00:06:19,850 --> 00:06:24,530
that make sense but suppose you can

00:06:22,520 --> 00:06:26,450
write suppose this is valid Python this

00:06:24,530 --> 00:06:29,270
is a way to define a function you owe

00:06:26,450 --> 00:06:31,490
you create a list and then first

00:06:29,270 --> 00:06:34,640
animated alice is def then your function

00:06:31,490 --> 00:06:37,880
then you have arg and then comma pass so

00:06:34,640 --> 00:06:39,860
this is a list and this is also how you

00:06:37,880 --> 00:06:42,440
define a function it's not true of

00:06:39,860 --> 00:06:46,400
course but that's how what would look

00:06:42,440 --> 00:06:49,130
like if it was so what is this thing is

00:06:46,400 --> 00:06:52,280
so important well first this is just to

00:06:49,130 --> 00:06:54,500
show how the valuation is done in Lisbon

00:06:52,280 --> 00:06:56,040
just to keep it clear as you note every

00:06:54,500 --> 00:07:00,000
operator is

00:06:56,040 --> 00:07:03,540
and then everything it's a cons in the

00:07:00,000 --> 00:07:05,640
end so you have here the star the

00:07:03,540 --> 00:07:08,490
multiplication sign then you have the

00:07:05,640 --> 00:07:11,820
two and you have another branch where

00:07:08,490 --> 00:07:14,640
you have the plus 3 to 4 and here Neil

00:07:11,820 --> 00:07:19,290
Neil because there is no other element

00:07:14,640 --> 00:07:21,510
in the concept so why is this a property

00:07:19,290 --> 00:07:24,690
important because in Lisp you can make

00:07:21,510 --> 00:07:29,510
mega programming to a very deep level

00:07:24,690 --> 00:07:32,460
you can make using macros so assume

00:07:29,510 --> 00:07:35,280
which you may be ever seen but in Lisp

00:07:32,460 --> 00:07:38,220
to set to do an assignment of a variable

00:07:35,280 --> 00:07:42,900
you do set Q extent for example which

00:07:38,220 --> 00:07:47,280
set to the symbol X the value 10 suppose

00:07:42,900 --> 00:07:49,050
I want to do something like set 10 to

00:07:47,280 --> 00:07:53,210
two variables at the same time like

00:07:49,050 --> 00:07:56,970
assigning two things to one value in one

00:07:53,210 --> 00:07:59,340
call is that possible well the moment is

00:07:56,970 --> 00:08:01,680
not possible but what if i write a

00:07:59,340 --> 00:08:05,550
function so i write this function

00:08:01,680 --> 00:08:07,790
defined set Q F X Y Z and then I do this

00:08:05,550 --> 00:08:12,330
I use the special form program which

00:08:07,790 --> 00:08:16,320
concatenate to multiple expressions but

00:08:12,330 --> 00:08:28,680
within them but that doesn't work so we

00:08:16,320 --> 00:08:43,560
can try it out developers was it set

00:08:28,680 --> 00:08:47,070
cool so now i do set Q 2 f do a a well a

00:08:43,560 --> 00:08:51,900
B and then say 10 it fails it says the

00:08:47,070 --> 00:08:54,210
variable a is unbound so well I was hold

00:08:51,900 --> 00:08:57,390
it but that kind of understandable in a

00:08:54,210 --> 00:09:00,360
way because I'm trying to set to create

00:08:57,390 --> 00:09:04,860
a special form with the function so

00:09:00,360 --> 00:09:08,220
that's not really possible so however if

00:09:04,860 --> 00:09:09,810
i rewrite this thing with the macro with

00:09:08,220 --> 00:09:11,760
were the only difference that he

00:09:09,810 --> 00:09:15,920
use def macro and here i use this

00:09:11,760 --> 00:09:22,860
backward and these comas here in front

00:09:15,920 --> 00:09:26,660
instead everything works fine see and

00:09:22,860 --> 00:09:33,150
they find the macro and then i do set qu

00:09:26,660 --> 00:09:34,830
q a be a be everything works so what's

00:09:33,150 --> 00:09:36,720
the difference the difference seems

00:09:34,830 --> 00:09:40,890
small but it's quite relevant because

00:09:36,720 --> 00:09:45,390
here this macro is basically a creating

00:09:40,890 --> 00:09:48,060
compile-time a new a new function that

00:09:45,390 --> 00:09:51,990
will get be templated when you call it

00:09:48,060 --> 00:09:53,700
so this is like it takes the symbol it

00:09:51,990 --> 00:09:56,160
doesn't try to evaluate it doesn't try

00:09:53,700 --> 00:09:59,730
to evaluate a or b it just pass it

00:09:56,160 --> 00:10:02,850
around to this quoted thing which then

00:09:59,730 --> 00:10:06,779
gets evaluated at runtime and these runs

00:10:02,850 --> 00:10:09,260
normally as it should so very powerful

00:10:06,779 --> 00:10:13,380
technique can we do the same if i turn

00:10:09,260 --> 00:10:15,600
mmm almost well i mean for to do this

00:10:13,380 --> 00:10:19,470
kind of thing you could do something

00:10:15,600 --> 00:10:22,350
like that which is horrible and yeah

00:10:19,470 --> 00:10:25,320
almost works but so basically you pass

00:10:22,350 --> 00:10:27,540
two strings like a and B and then you

00:10:25,320 --> 00:10:29,490
pass an expression you evaluate the

00:10:27,540 --> 00:10:33,300
expression and then you update the

00:10:29,490 --> 00:10:36,300
Global's with this thing yeah it's not

00:10:33,300 --> 00:10:43,200
even the same exactly but it kind of

00:10:36,300 --> 00:10:46,650
works by and undo that so yeah the least

00:10:43,200 --> 00:10:49,260
price reduction is over luckily we can

00:10:46,650 --> 00:10:51,660
pass something more interesting title so

00:10:49,260 --> 00:10:53,459
what can we do in Python for meta

00:10:51,660 --> 00:10:55,560
programming well we can have function

00:10:53,459 --> 00:10:58,530
decorators class decorators meter

00:10:55,560 --> 00:11:01,860
classes and then if you really want to

00:10:58,530 --> 00:11:04,530
be fancy you can manipulate the age they

00:11:01,860 --> 00:11:07,640
asked a syntax tree I'm going to show

00:11:04,530 --> 00:11:12,540
them in order they are also in order of

00:11:07,640 --> 00:11:14,370
difficulty way what is the decorator

00:11:12,540 --> 00:11:17,220
first decoder is just a syntactic sugar

00:11:14,370 --> 00:11:21,000
for a function that modifies the

00:11:17,220 --> 00:11:23,580
behavior of another function or class so

00:11:21,000 --> 00:11:28,770
this simply means

00:11:23,580 --> 00:11:30,540
dates below you you duet decorator or as

00:11:28,770 --> 00:11:31,890
the function and the same thing as

00:11:30,540 --> 00:11:35,160
defining the function and then

00:11:31,890 --> 00:11:41,490
redefining assigning to the return

00:11:35,160 --> 00:11:43,320
result of the decorator itself and let's

00:11:41,490 --> 00:11:46,290
see the first problem that we try to

00:11:43,320 --> 00:11:49,020
solve with the decorators assume I want

00:11:46,290 --> 00:11:51,330
to measure the time spent in a function

00:11:49,020 --> 00:11:55,140
and print it out to the standard output

00:11:51,330 --> 00:11:57,570
and see how long everything takes this

00:11:55,140 --> 00:12:01,640
is a decorator that does it so it takes

00:11:57,570 --> 00:12:05,220
the function it uses this nice wraps

00:12:01,640 --> 00:12:08,850
decorator defining in funk tools and

00:12:05,220 --> 00:12:13,140
this is just to make sure that all day

00:12:08,850 --> 00:12:15,240
like underlying attributes like doc and

00:12:13,140 --> 00:12:17,340
so on gets past correctly and they don't

00:12:15,240 --> 00:12:21,090
get lost along the way it would work

00:12:17,340 --> 00:12:23,580
anyway it's always good to put this so

00:12:21,090 --> 00:12:26,730
yeah and then you define as an inner

00:12:23,580 --> 00:12:30,360
function which will call the original

00:12:26,730 --> 00:12:33,350
one store the result somewhere store the

00:12:30,360 --> 00:12:36,900
time before and after and then print out

00:12:33,350 --> 00:12:40,310
the time spent and return the original

00:12:36,900 --> 00:12:43,980
result and then here you return this

00:12:40,310 --> 00:12:51,210
inner function you can show this how

00:12:43,980 --> 00:12:59,330
that works so now go to the show I open

00:12:51,210 --> 00:12:59,330
right item can you see in the back

00:12:59,390 --> 00:13:08,390
bigger maybe okay

00:13:20,959 --> 00:13:31,319
okay what was called Plato's tie-dye

00:13:26,549 --> 00:13:38,429
print ok so now I create another

00:13:31,319 --> 00:13:47,069
function time eight point does something

00:13:38,429 --> 00:13:50,789
time me so do anything useful then I

00:13:47,069 --> 00:13:56,279
call this and I get this message here

00:13:50,789 --> 00:13:59,249
function time eight took they should

00:13:56,279 --> 00:14:01,439
have set something else up because I

00:13:59,249 --> 00:14:12,529
change before this the talk of course

00:14:01,439 --> 00:14:12,529
and I made a mistake yeah this sorry

00:14:14,769 --> 00:14:21,089
I again

00:14:30,080 --> 00:14:54,750
all right no still the same ah yes thank

00:14:38,460 --> 00:15:02,330
you all right I can reload the

00:14:54,750 --> 00:15:02,330
decorators so that's work know what are

00:15:03,620 --> 00:15:10,620
no just our source okay let's do it i

00:15:09,000 --> 00:15:20,070
showed you the next example is more

00:15:10,620 --> 00:15:22,620
interesting okay so we have another

00:15:20,070 --> 00:15:24,570
problem i was still with timing but

00:15:22,620 --> 00:15:26,610
slightly different because i want to

00:15:24,570 --> 00:15:29,100
know when I when I mean levity something

00:15:26,610 --> 00:15:31,440
new like a new feature or I change the

00:15:29,100 --> 00:15:33,480
algorithm I want to know that the new

00:15:31,440 --> 00:15:36,720
one runs faster than the previous one

00:15:33,480 --> 00:15:38,550
but I just I don't want just to know it

00:15:36,720 --> 00:15:40,770
once I want to make sure this always

00:15:38,550 --> 00:15:43,680
like that so I want to have that running

00:15:40,770 --> 00:15:46,650
in a test somewhere like integration

00:15:43,680 --> 00:15:49,410
tests and say my new fancy algorithm is

00:15:46,650 --> 00:15:52,440
still faster than the crappy old one

00:15:49,410 --> 00:15:57,480
after six months of hacking on it and

00:15:52,440 --> 00:15:59,430
adding things so well I mean in theory

00:15:57,480 --> 00:16:01,020
with the previous approach we couldn't

00:15:59,430 --> 00:16:02,700
do that because we were just praying in

00:16:01,020 --> 00:16:06,990
the doubt so you can't just check all

00:16:02,700 --> 00:16:10,320
the time how things look like but with

00:16:06,990 --> 00:16:12,420
another decorator which also change the

00:16:10,320 --> 00:16:15,330
signature of the original function then

00:16:12,420 --> 00:16:17,880
we can do that so what a heavier is a

00:16:15,330 --> 00:16:20,460
test to check that the first

00:16:17,880 --> 00:16:23,610
implementation it's faster than second

00:16:20,460 --> 00:16:28,560
one and the way it works is that the new

00:16:23,610 --> 00:16:31,860
this decorator here will change the

00:16:28,560 --> 00:16:34,920
function return values and add the time

00:16:31,860 --> 00:16:38,850
spent in the function as secona and as a

00:16:34,920 --> 00:16:40,650
second return value and so I do this I

00:16:38,850 --> 00:16:41,459
do this for the second one and then i

00:16:40,650 --> 00:16:43,980
can check

00:16:41,459 --> 00:16:47,429
at the time of the first one is less

00:16:43,980 --> 00:16:49,949
than the time of the second one so now

00:16:47,429 --> 00:16:54,689
let's see how we actually implemented

00:16:49,949 --> 00:16:56,670
them so still quite simple actually

00:16:54,689 --> 00:17:00,720
exactly the same almost the only

00:16:56,670 --> 00:17:04,529
difference is that here we when we do

00:17:00,720 --> 00:17:07,770
the return we do we also add the time

00:17:04,529 --> 00:17:11,100
here so this is a interesting case and

00:17:07,770 --> 00:17:14,789
the differences that you can't use it in

00:17:11,100 --> 00:17:17,760
a import time way because if you could

00:17:14,789 --> 00:17:20,159
if you decorate your function in the

00:17:17,760 --> 00:17:21,390
module like that then it will mess up

00:17:20,159 --> 00:17:23,159
everything because you don't want you

00:17:21,390 --> 00:17:26,189
don't care about that time spent in

00:17:23,159 --> 00:17:28,470
production so you can only do that this

00:17:26,189 --> 00:17:30,750
way but this perfectly valid thing is

00:17:28,470 --> 00:17:34,559
ever saying it's just in 30 sugar to

00:17:30,750 --> 00:17:39,990
just replace the function at runtime in

00:17:34,559 --> 00:17:42,770
this way and then call it so let's see

00:17:39,990 --> 00:17:58,669
if this I have more luck with this one

00:17:42,770 --> 00:17:58,669
so decorators I'm it was it it change

00:18:02,500 --> 00:18:13,350
oh yes that works so yeah see I get at

00:18:09,400 --> 00:18:15,400
Apple and the first element is the

00:18:13,350 --> 00:18:19,960
result and the second element is the

00:18:15,400 --> 00:18:23,140
time spent very nice to actually see how

00:18:19,960 --> 00:18:32,890
things work it's interesting also to

00:18:23,140 --> 00:18:35,140
look at the code here of timely and yes

00:18:32,890 --> 00:18:37,600
and the Raps function did the nice thing

00:18:35,140 --> 00:18:40,600
to also make sure that the source code

00:18:37,600 --> 00:18:44,290
that is returned is the original one not

00:18:40,600 --> 00:18:48,850
the wrapped not the wrapped in the

00:18:44,290 --> 00:18:51,490
decorator alright so another example

00:18:48,850 --> 00:18:54,850
this is how you can decorate a class

00:18:51,490 --> 00:18:58,330
system suppose I want to add always the

00:18:54,850 --> 00:19:02,140
same method too many classes and this I

00:18:58,330 --> 00:19:04,090
mean I don't want to go in every class

00:19:02,140 --> 00:19:07,990
and change it and I don't want to make a

00:19:04,090 --> 00:19:10,780
superclass to may to make this this is

00:19:07,990 --> 00:19:13,420
another very simple way to do that you

00:19:10,780 --> 00:19:16,900
just this is the test where I have a

00:19:13,420 --> 00:19:19,660
class which are a response method and

00:19:16,900 --> 00:19:22,240
then when I associate this class and I

00:19:19,660 --> 00:19:25,690
called response I get the return I want

00:19:22,240 --> 00:19:28,240
the valley i want so this is the simple

00:19:25,690 --> 00:19:31,570
way to do it very clear a simple you

00:19:28,240 --> 00:19:34,420
just take the class here you assign two

00:19:31,570 --> 00:19:37,660
response an anonymous function which

00:19:34,420 --> 00:19:43,810
takes self letters this and then you

00:19:37,660 --> 00:19:45,970
turn the class itself yeah let's all for

00:19:43,810 --> 00:19:50,110
Dakota so now so let's pass to meta

00:19:45,970 --> 00:19:52,960
classes meta classes is the next way of

00:19:50,110 --> 00:19:55,960
doing Minter programming in python is

00:19:52,960 --> 00:19:57,250
more powerful and this more is also bit

00:19:55,960 --> 00:19:59,290
more difficult to understand in the

00:19:57,250 --> 00:20:02,470
beginning but it's really not that hard

00:19:59,290 --> 00:20:07,330
as hard as it looks as i'm going to show

00:20:02,470 --> 00:20:11,790
you so what's a metaclass well I met a

00:20:07,330 --> 00:20:14,770
class in python is just the same as a

00:20:11,790 --> 00:20:16,300
metaclass tends to a class like a class

00:20:14,770 --> 00:20:22,210
tends to an int in

00:20:16,300 --> 00:20:25,150
so it's a type of a class if you create

00:20:22,210 --> 00:20:27,880
a class in this way here is exactly the

00:20:25,150 --> 00:20:31,360
same thing as doing in this way with the

00:20:27,880 --> 00:20:35,920
type function I'm going to try to show

00:20:31,360 --> 00:20:40,180
you now a little bit for example if I

00:20:35,920 --> 00:20:41,860
now do this I forgot to mention in the

00:20:40,180 --> 00:20:46,000
beginning that all the code i'm showing

00:20:41,860 --> 00:20:48,640
is a Python 3 only well the difference

00:20:46,000 --> 00:20:50,830
does not many but yes if you try to run

00:20:48,640 --> 00:20:55,660
it on title to it will my fail or might

00:20:50,830 --> 00:21:01,990
not do what you want ok so what's the

00:20:55,660 --> 00:21:04,600
type of c-type and then if I try instead

00:21:01,990 --> 00:21:06,340
to create a type let's see what this

00:21:04,600 --> 00:21:09,790
takes this argument it takes an object

00:21:06,340 --> 00:21:15,160
or named Abe a list of bases and the

00:21:09,790 --> 00:21:20,950
dictionary so for example suppose I want

00:21:15,160 --> 00:21:26,200
to create a runtime a class like be we

00:21:20,950 --> 00:21:29,740
has s basis on the object and then as

00:21:26,200 --> 00:21:40,210
dictionary I have like a class attribute

00:21:29,740 --> 00:21:43,780
a 10 must be at Apollonius mistake ok so

00:21:40,210 --> 00:21:47,320
this is now class and I can instantiate

00:21:43,780 --> 00:21:50,320
the class and I can access the attribute

00:21:47,320 --> 00:21:55,650
a so this is another way of creating

00:21:50,320 --> 00:22:00,580
classes around I mean this is how in the

00:21:55,650 --> 00:22:02,260
in the background it works let's see the

00:22:00,580 --> 00:22:05,620
simplest possible metaclass

00:22:02,260 --> 00:22:08,250
implementation and how to use it so we

00:22:05,620 --> 00:22:12,520
have a class simple matter which

00:22:08,250 --> 00:22:14,710
subclasses type and then to use it in

00:22:12,520 --> 00:22:18,970
our own class we only need to create

00:22:14,710 --> 00:22:21,520
class subclassing object and then

00:22:18,970 --> 00:22:24,330
passing metaclass equal to simple made

00:22:21,520 --> 00:22:28,180
here in Python to it would have been

00:22:24,330 --> 00:22:29,260
underscored score metaclass here equal

00:22:28,180 --> 00:22:35,650
to something but

00:22:29,260 --> 00:22:39,960
is just the same thing now let's pass us

00:22:35,650 --> 00:22:43,480
have more interesting examples of thing

00:22:39,960 --> 00:22:46,210
in every oh my be like a jungle

00:22:43,480 --> 00:22:49,570
framework awesome it's very easy to

00:22:46,210 --> 00:22:53,290
define models that talk the database

00:22:49,570 --> 00:22:55,780
store data keep some information about

00:22:53,290 --> 00:22:59,590
the type and so on and so forth and this

00:22:55,780 --> 00:23:02,230
is kind of possible syntax that is used

00:22:59,590 --> 00:23:06,000
which I just made up but this quite

00:23:02,230 --> 00:23:09,130
similar enough I think and it looks like

00:23:06,000 --> 00:23:13,510
magic but it's not that hard to do in

00:23:09,130 --> 00:23:16,540
reality and this simple way to do it in

00:23:13,510 --> 00:23:19,090
this case if I want to accomplish

00:23:16,540 --> 00:23:22,660
something like that if I don't have meta

00:23:19,090 --> 00:23:25,450
classes I could just have a model for

00:23:22,660 --> 00:23:29,170
this particular case which takes the

00:23:25,450 --> 00:23:32,650
argument x and y and then initialize

00:23:29,170 --> 00:23:34,750
them ready so well I mean if you you can

00:23:32,650 --> 00:23:37,060
do that if you have some very simple

00:23:34,750 --> 00:23:40,990
it's nice but if you want to define many

00:23:37,060 --> 00:23:42,430
models if you want is very verbose

00:23:40,990 --> 00:23:44,770
because every time you have to declare

00:23:42,430 --> 00:23:48,010
everything and assign it there's a lot

00:23:44,770 --> 00:23:49,690
of boilerplate and also important thing

00:23:48,010 --> 00:23:52,960
I think is that you have no information

00:23:49,690 --> 00:23:57,760
about the types and why ill python is

00:23:52,960 --> 00:23:59,620
duck type databases are normally not so

00:23:57,760 --> 00:24:03,940
you need still need to have the

00:23:59,620 --> 00:24:06,760
information somewhere and so how how can

00:24:03,940 --> 00:24:12,580
we accomplish this kind of very nice

00:24:06,760 --> 00:24:17,440
thing in Python then we start by looking

00:24:12,580 --> 00:24:20,650
at how we can implement field type so

00:24:17,440 --> 00:24:23,080
which is this one so a field type will

00:24:20,650 --> 00:24:27,460
be a base class for things like integer

00:24:23,080 --> 00:24:29,830
or string and you can implement it so

00:24:27,460 --> 00:24:32,170
this is the test that will this the

00:24:29,830 --> 00:24:35,760
requirement for this kind of type I want

00:24:32,170 --> 00:24:35,760
to have three different things

00:24:37,870 --> 00:24:44,559
I want to be able to wait a minute oh no

00:24:42,490 --> 00:24:48,850
that's not the right test okay this one

00:24:44,559 --> 00:24:51,670
is like this Sorry Sorry no take it back

00:24:48,850 --> 00:24:54,220
this it the next day so this is the the

00:24:51,670 --> 00:24:57,340
model I want to have and these are the

00:24:54,220 --> 00:25:00,460
three requirement that i have for this

00:24:57,340 --> 00:25:05,010
model to behave like i want so i want to

00:25:00,460 --> 00:25:09,070
be able to create an object like this

00:25:05,010 --> 00:25:12,370
passing for example why and without

00:25:09,070 --> 00:25:16,840
passing x.x as default value why doesn't

00:25:12,370 --> 00:25:20,230
i want so I check that after I pass this

00:25:16,840 --> 00:25:23,140
why is set and the X is also set to

00:25:20,230 --> 00:25:24,790
default value I want to be able to know

00:25:23,140 --> 00:25:27,550
that if I pass something wrong like

00:25:24,790 --> 00:25:29,800
unknown hello you will give an exception

00:25:27,550 --> 00:25:31,900
and if I pass something of the wrong

00:25:29,800 --> 00:25:37,270
type it will always given a type error

00:25:31,900 --> 00:25:39,520
in this case so first we can look at how

00:25:37,270 --> 00:25:42,370
fields are implemented and here again

00:25:39,520 --> 00:25:47,590
this requirement for the field so if i

00:25:42,370 --> 00:25:50,290
create an integer when i pass 0 as value

00:25:47,590 --> 00:25:53,620
and the default one the value will take

00:25:50,290 --> 00:25:56,650
the president's if i try to set at any

00:25:53,620 --> 00:25:58,360
time something which is the wrong type i

00:25:56,650 --> 00:26:00,700
get a type error and also very

00:25:58,360 --> 00:26:03,940
importantly if I in the beginning create

00:26:00,700 --> 00:26:07,179
the element correctly and then I change

00:26:03,940 --> 00:26:10,240
the type to something else and then I

00:26:07,179 --> 00:26:13,270
also get a type error let's say an

00:26:10,240 --> 00:26:16,270
implementation of fields first which is

00:26:13,270 --> 00:26:20,020
not you done using meta classes but it's

00:26:16,270 --> 00:26:22,059
not done in this way so they need the

00:26:20,020 --> 00:26:27,250
most important thing is that we have a

00:26:22,059 --> 00:26:32,040
property here which has a also a setter

00:26:27,250 --> 00:26:36,550
and this property is the actual

00:26:32,040 --> 00:26:39,850
representing the value and whenever you

00:26:36,550 --> 00:26:42,520
try to set here the value which is also

00:26:39,850 --> 00:26:46,630
done at this point it will always check

00:26:42,520 --> 00:26:49,720
the type each X if the type is not an

00:26:46,630 --> 00:26:50,800
instance of this base type which every

00:26:49,720 --> 00:26:54,480
class

00:26:50,800 --> 00:26:56,770
we'll have to define then AO is a diaper

00:26:54,480 --> 00:27:03,940
let's see how is for example

00:26:56,770 --> 00:27:07,210
implementation of string or integer so

00:27:03,940 --> 00:27:10,780
very simple here we have a the base

00:27:07,210 --> 00:27:12,790
class here is integer and here is thing

00:27:10,780 --> 00:27:17,470
so the thought all you have to do is to

00:27:12,790 --> 00:27:19,630
find the base type and if the object

00:27:17,470 --> 00:27:25,600
passing is another instance of that then

00:27:19,630 --> 00:27:27,730
it will give a type error yep so let's

00:27:25,600 --> 00:27:30,190
go back now to the model the models

00:27:27,730 --> 00:27:32,920
metaclass and this is the actual instead

00:27:30,190 --> 00:27:34,570
the solution for all this which fits in

00:27:32,920 --> 00:27:37,450
this life so it must not be the

00:27:34,570 --> 00:27:41,980
difficult is the solution for the

00:27:37,450 --> 00:27:45,010
original problem the way it's done is

00:27:41,980 --> 00:27:47,890
that the subclass type as a done before

00:27:45,010 --> 00:27:50,110
in the previous example and then I I

00:27:47,890 --> 00:27:53,350
override the underscore nesco new method

00:27:50,110 --> 00:27:55,720
which is used to in during the

00:27:53,350 --> 00:27:58,420
construction of the class itself instead

00:27:55,720 --> 00:28:03,130
of the initial Asia initialization of

00:27:58,420 --> 00:28:05,380
the object like in it and then I get

00:28:03,130 --> 00:28:09,100
four arguments here I get the class I

00:28:05,380 --> 00:28:12,460
get the name I get the list of base

00:28:09,100 --> 00:28:19,540
classes and I have this important the

00:28:12,460 --> 00:28:22,810
classic which is all the attributes and

00:28:19,540 --> 00:28:27,490
methods of the class basically which we

00:28:22,810 --> 00:28:30,280
can modify so the way the way I want to

00:28:27,490 --> 00:28:32,500
do this is basically just replacing the

00:28:30,280 --> 00:28:36,520
init of the new class that I will create

00:28:32,500 --> 00:28:40,990
now with another in it that will do some

00:28:36,520 --> 00:28:44,320
extra checks and extra things for me

00:28:40,990 --> 00:28:47,590
automatically every time first of all I

00:28:44,320 --> 00:28:51,940
look over the attributes of the class

00:28:47,590 --> 00:28:55,030
and they check if the if the attribute

00:28:51,940 --> 00:28:58,600
of the class is an instance of a field

00:28:55,030 --> 00:29:02,260
then this is a field I just store it in

00:28:58,600 --> 00:29:04,940
a dictionary here and then I redefine an

00:29:02,260 --> 00:29:10,220
init here which takes time

00:29:04,940 --> 00:29:13,820
k WX so it can take X equal 1 y equal to

00:29:10,220 --> 00:29:16,790
a sauna so forth and then it will first

00:29:13,820 --> 00:29:19,880
of all check if there are some arguments

00:29:16,790 --> 00:29:24,500
which I pass in that are not known so if

00:29:19,880 --> 00:29:26,900
the set of the difference between the

00:29:24,500 --> 00:29:29,450
kid the arguments passed and the fields

00:29:26,900 --> 00:29:33,080
that I found looking inspecting the

00:29:29,450 --> 00:29:36,650
class is greater than zero then give an

00:29:33,080 --> 00:29:40,340
exception otherwise if not if everything

00:29:36,650 --> 00:29:45,770
is fine then look over this and then

00:29:40,340 --> 00:29:52,850
generate set an attribute to this object

00:29:45,770 --> 00:29:56,300
itself with the as a key the the name of

00:29:52,850 --> 00:29:59,990
the the argument and there's a value the

00:29:56,300 --> 00:30:03,130
value which I just now created by

00:29:59,990 --> 00:30:06,080
calling the class and passing the value

00:30:03,130 --> 00:30:09,800
so sounds more complicated than this

00:30:06,080 --> 00:30:12,440
maybe but don't show maybe now how it

00:30:09,800 --> 00:30:15,710
works and then after that the important

00:30:12,440 --> 00:30:17,390
step is that I redefine the init of the

00:30:15,710 --> 00:30:23,330
classic to the thing which already

00:30:17,390 --> 00:30:28,640
defined here and then I return just the

00:30:23,330 --> 00:30:37,700
super call and try to show you just very

00:30:28,640 --> 00:30:40,880
simple how this behaves maybe so if I

00:30:37,700 --> 00:30:44,240
now yes now the only thing I need to do

00:30:40,880 --> 00:30:55,520
is to define a model in this way class

00:30:44,240 --> 00:30:58,750
model yes and then I will simply if i

00:30:55,520 --> 00:30:58,750
define now another model

00:31:04,410 --> 00:31:17,780
I know import for the Saudi contact lee

00:31:19,640 --> 00:31:32,550
but for model and then i define X equal

00:31:24,690 --> 00:31:36,300
two models string okay now suppose I

00:31:32,550 --> 00:31:38,910
want to create an instance of this but I

00:31:36,300 --> 00:31:43,770
passed the wrong thing complaints and no

00:31:38,910 --> 00:31:47,000
arguments why I pass this it checks type

00:31:43,770 --> 00:31:51,630
and this never if I pass this instead

00:31:47,000 --> 00:31:54,420
everything will work quickly upside and

00:31:51,630 --> 00:31:58,860
the interesting thing if if i look at

00:31:54,420 --> 00:32:02,280
the init of this method it tells me

00:31:58,860 --> 00:32:08,010
we're actually it can i know sorry if i

00:32:02,280 --> 00:32:10,830
look at this yeah if i look at the in

00:32:08,010 --> 00:32:13,890
need of the class simple too it tells me

00:32:10,830 --> 00:32:17,160
that it comes from here function models

00:32:13,890 --> 00:32:23,430
metamodel new locals in it so that's

00:32:17,160 --> 00:32:25,920
where you find it all right another

00:32:23,430 --> 00:32:29,010
another example which is a bit more

00:32:25,920 --> 00:32:31,800
simple is how to for example make sure

00:32:29,010 --> 00:32:34,800
that we always call the super of the

00:32:31,800 --> 00:32:37,860
init in the subclasses of a superclass

00:32:34,800 --> 00:32:39,720
that we define I've seen this is doing

00:32:37,860 --> 00:32:42,060
for example in the module thread in dot

00:32:39,720 --> 00:32:44,580
pie if you forget to call the in it it

00:32:42,060 --> 00:32:46,290
will blow up and complain and if you

00:32:44,580 --> 00:32:48,540
look at the implementation it's

00:32:46,290 --> 00:32:51,690
basically just this it has an

00:32:48,540 --> 00:32:54,210
initialized false and English in it it

00:32:51,690 --> 00:32:57,780
will set initialize true and in every

00:32:54,210 --> 00:32:59,910
method that has to be working on an

00:32:57,780 --> 00:33:02,670
initialized object ed there is this

00:32:59,910 --> 00:33:05,250
check so that's a bit annoying and

00:33:02,670 --> 00:33:08,940
that's a bit too long maybe to do so

00:33:05,250 --> 00:33:13,560
this is what I want is that I call

00:33:08,940 --> 00:33:16,419
something and if I forgot to call the

00:33:13,560 --> 00:33:19,899
super in the init it should

00:33:16,419 --> 00:33:21,999
giving an assertion better and I think

00:33:19,899 --> 00:33:26,649
that's the implementation very simple I

00:33:21,999 --> 00:33:32,289
do I store the original in it somewhere

00:33:26,649 --> 00:33:34,210
and then I call it here I will replace

00:33:32,289 --> 00:33:36,909
the in it with another int which I'm

00:33:34,210 --> 00:33:39,759
doing I call it here just to make sure I

00:33:36,909 --> 00:33:42,759
don't lose anything and then I also add

00:33:39,759 --> 00:33:47,019
in a second assertion looking for a flag

00:33:42,759 --> 00:33:48,940
variable that is set so this is kind of

00:33:47,019 --> 00:33:51,609
doing the same thing but in a more

00:33:48,940 --> 00:33:57,269
generic way and so all you have to do in

00:33:51,609 --> 00:34:02,379
your class to use this is to just go

00:33:57,269 --> 00:34:04,539
here i define a class base passing the

00:34:02,379 --> 00:34:07,720
metaclass Cecchini and all i have to do

00:34:04,539 --> 00:34:09,700
is to define a flag variable equal val

00:34:07,720 --> 00:34:15,369
and this is it a valuable that I know

00:34:09,700 --> 00:34:19,240
that I always set in the init here so if

00:34:15,369 --> 00:34:24,399
something tries to subclass base and

00:34:19,240 --> 00:34:29,319
forget to call in it this here will be

00:34:24,399 --> 00:34:35,559
not set and then this will give an

00:34:29,319 --> 00:34:37,780
assertion error yep and nothing of the

00:34:35,559 --> 00:34:39,700
show very quickly is that just you can

00:34:37,780 --> 00:34:45,629
do even much worse than that if you want

00:34:39,700 --> 00:34:50,099
and this is a very simple function that

00:34:45,629 --> 00:34:53,470
analyze the aest of a given function

00:34:50,099 --> 00:34:57,880
parsing it parsing the source and then

00:34:53,470 --> 00:34:59,859
trying to find out a particular value a

00:34:57,880 --> 00:35:02,859
string and replacing it with something

00:34:59,859 --> 00:35:05,410
else that we should show you the actual

00:35:02,859 --> 00:35:09,430
example whispering easy to understand

00:35:05,410 --> 00:35:13,240
this is this is the function here which

00:35:09,430 --> 00:35:15,609
I want to replace runtime and what I

00:35:13,240 --> 00:35:19,660
want to replace is to remove the hello

00:35:15,609 --> 00:35:25,869
from the string so and this is what is

00:35:19,660 --> 00:35:29,410
doing I call it I exact this the return

00:35:25,869 --> 00:35:32,040
of this and then I call it again so what

00:35:29,410 --> 00:35:32,040
is going to

00:35:36,319 --> 00:35:46,020
is that a no yeah the first time it

00:35:44,700 --> 00:35:48,359
calls with a low or the second time

00:35:46,020 --> 00:35:51,300
Hollywood all right everything works

00:35:48,359 --> 00:35:54,200
fine so the thing is that of course this

00:35:51,300 --> 00:35:58,170
is very hard coded and it's not really

00:35:54,200 --> 00:36:00,510
the good idea but in theory a AST is

00:35:58,170 --> 00:36:02,700
just a tree so you can't reverse it any

00:36:00,510 --> 00:36:04,920
way you want so you can look for all the

00:36:02,700 --> 00:36:08,069
things that look like strings adapt this

00:36:04,920 --> 00:36:09,900
content or you can look for all day you

00:36:08,069 --> 00:36:12,630
can do anything you want and you can put

00:36:09,900 --> 00:36:14,490
that in a decorator or you can and in

00:36:12,630 --> 00:36:17,369
this this is the only way I think that

00:36:14,490 --> 00:36:20,430
you can reach something like as powerful

00:36:17,369 --> 00:36:23,040
as lease plus in vital and there is a

00:36:20,430 --> 00:36:24,660
library which I'm going to I don't have

00:36:23,040 --> 00:36:27,599
time to show because I knew was too much

00:36:24,660 --> 00:36:29,609
there is a library called macro pi where

00:36:27,599 --> 00:36:32,760
you can actually do things like that and

00:36:29,609 --> 00:36:34,950
this is valid Python even my syntax

00:36:32,760 --> 00:36:37,079
highlight that doesn't think it is but

00:36:34,950 --> 00:36:39,270
you will run and it will work and you

00:36:37,079 --> 00:36:42,450
can make a case class whether they can

00:36:39,270 --> 00:36:45,569
declare a class like that passing x and

00:36:42,450 --> 00:36:48,630
y and this automatically will create in

00:36:45,569 --> 00:36:50,609
it where the x and y and you can just

00:36:48,630 --> 00:36:53,040
accentuate it like that and everything

00:36:50,609 --> 00:36:55,349
will work correctly and that's how it's

00:36:53,040 --> 00:36:59,040
implemented so if we want to look it up

00:36:55,349 --> 00:37:02,309
is called micro pie so yeah that's it

00:36:59,040 --> 00:37:04,470
for me so any questions and then just

00:37:02,309 --> 00:37:07,079
the conclusion sorry well meta

00:37:04,470 --> 00:37:09,150
programming is fun you can make in just

00:37:07,079 --> 00:37:11,940
one fit in one slide the code to create

00:37:09,150 --> 00:37:15,859
a very simple style / app and then just

00:37:11,940 --> 00:37:15,859
be careful but yeah use it

00:37:22,559 --> 00:37:39,640
and for my wishes if you much code will

00:37:36,220 --> 00:37:46,569
be a certified psychic hard Sarah would

00:37:39,640 --> 00:37:48,700
you still be you yes I if I knew that

00:37:46,569 --> 00:37:50,650
the maintainer might be AB Psychopaths

00:37:48,700 --> 00:37:54,520
and serial killer would I still be using

00:37:50,650 --> 00:37:59,950
meta programming yes but i would comment

00:37:54,520 --> 00:38:01,750
it maybe leave out my name or or change

00:37:59,950 --> 00:38:09,690
the history of gate to make sure it

00:38:01,750 --> 00:38:09,690
doesn't come to me yeah another question

00:38:16,740 --> 00:38:25,569
I think the philosophy of python is that

00:38:23,559 --> 00:38:29,079
you shouldn't do things that are two

00:38:25,569 --> 00:38:32,500
readable and too hard to understand so

00:38:29,079 --> 00:38:35,289
it would kind of go against the language

00:38:32,500 --> 00:38:37,510
designed to do add more and I don't know

00:38:35,289 --> 00:38:39,880
what really you could but there are

00:38:37,510 --> 00:38:43,059
things you can do crazy things like

00:38:39,880 --> 00:38:46,569
macro pi does so it is possible already

00:38:43,059 --> 00:38:48,010
it's just I think it's enough and I

00:38:46,569 --> 00:38:53,190
wouldn't think you need more than that

00:38:48,010 --> 00:38:53,190
yeah yeah okay

00:38:54,180 --> 00:38:56,240

YouTube URL: https://www.youtube.com/watch?v=pXduirOmnJg


