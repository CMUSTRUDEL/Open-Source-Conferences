Title: Thomas Aglassinger - Solution oriented error handling
Publication date: 2015-04-18
Playlist: EuroPython 2014
Description: 
	Thomas Aglassinger - Solution oriented error handling
[EuroPython 2014]
[22 July 2014]

This talk shows how to use Python's built in error handling mechanisms to keep the productive code clean, derive error messages helpful for the user directly from the code and release ressources properly.

-----

Traditionally error handling is regarded an annoyance by developers because it removes the focus from the already difficult enough productive parts of the code to parts that ideally will never be called. And even if, end users seem to be ignore the error messages and just click "Ok" or call the help desk.

Solution oriented error handling uses Python's existing try/catch/finally idiom, with statement, assert statement and exception hierarchy in a way that keeps the code clean and easy to maintain. It gives a clear distinction between errors that can be solved by the end user, the system administrator and the developer. Naming conventions and a simple set of coding guidelines ensure that helpful error messages can be easily derived from the code.

Most code examples work with Python 2.6+ and Python 3.x, on a few occasions minor differences are pointed out.

Topics covered are:

1. Introduction to error handling in Python
    - What are errors?
    - How to represent errors in Python
    - Detecting errors
    - Delegating errors to the caller
    - clean resource management
2. Principles of solution oriented error handling
    - responsibilities between user, admin and developer
    - when to use raise or assert
3. Error messages
    - What are "good" error messages
    - How to derive error messages from the source code
    - Adding context to the error
    - How to report errors to the user
4. Solution oriented usage of Python's exception hierarchy
    - admins fix `EnvironmentError`
    - users fix `DataError`
        - representing `DataError`
        - converting exceptions to `DataError`
    - developers fix everything else
    - special Python exceptions not representing errors
5. Template for a solution oriented command line application
6. Best practices for `raise` and `except`
    - When to use `raise`?
    - When to use `except`?

This talk is a translation of a German [talk](https://github.com/roskakori/talks/tree/master/pygraz/errorhandling) given at the PyGRAZ user group and in a (slightly depythonized variant) the Grazer Linux Tag 2013 ([slides and video](http://glt13-programm.linuxtage.at/events/198.de.html)).
Captions: 
	00:00:14,740 --> 00:00:17,869
thank you and hello and welcome to my

00:00:17,050 --> 00:00:20,910
talk

00:00:17,869 --> 00:00:26,180
solution-oriented error-handling which

00:00:20,910 --> 00:00:31,110
is a set of simple set of guidelines to

00:00:26,180 --> 00:00:33,540
use the mechanisms of Python for an

00:00:31,110 --> 00:00:35,610
efficient way of error handling it does

00:00:33,540 --> 00:00:39,239
work with the standard library so you

00:00:35,610 --> 00:00:41,309
don't need any extensions it has it

00:00:39,239 --> 00:00:42,989
yields a small amount of dedicated error

00:00:41,309 --> 00:00:44,910
handling code and most of your code can

00:00:42,989 --> 00:00:47,159
focus on producing the result and

00:00:44,910 --> 00:00:51,780
producing the stuff your users actually

00:00:47,159 --> 00:00:53,910
want it yields helpful error messages

00:00:51,780 --> 00:00:56,789
that are easy to derive from the code

00:00:53,910 --> 00:00:59,609
and it consequently is simplified

00:00:56,789 --> 00:01:01,680
support in a way that users might be

00:00:59,609 --> 00:01:04,920
able to deal with more errors themselves

00:01:01,680 --> 00:01:06,630
without opening tickets or even if you

00:01:04,920 --> 00:01:08,550
get a ticket and the error messages in

00:01:06,630 --> 00:01:09,929
the ticket you get more information and

00:01:08,550 --> 00:01:14,369
better information to fix it yourself

00:01:09,929 --> 00:01:17,340
and support the user what I'm talking

00:01:14,369 --> 00:01:20,250
about now is I give a short introduction

00:01:17,340 --> 00:01:22,289
about errors in general then I give an

00:01:20,250 --> 00:01:24,840
overview of errors in Python how does

00:01:22,289 --> 00:01:26,240
Python represent errors with exception

00:01:24,840 --> 00:01:29,429
handling how does Python cleanup

00:01:26,240 --> 00:01:31,289
resources after errors then I'm going to

00:01:29,429 --> 00:01:33,899
focus on the principles of solution

00:01:31,289 --> 00:01:36,149
oriented error handling with a dedicated

00:01:33,899 --> 00:01:38,280
sections on error messages and error

00:01:36,149 --> 00:01:41,700
hierarchies or exception hierarchies and

00:01:38,280 --> 00:01:43,500
I'm summarizing the whole thing at the

00:01:41,700 --> 00:01:47,190
end with a couple of recommendations and

00:01:43,500 --> 00:01:52,020
guidelines you can apply to your code so

00:01:47,190 --> 00:01:53,729
about errors what are errors errors in

00:01:52,020 --> 00:01:56,160
the context I am talking about our

00:01:53,729 --> 00:01:59,429
conditions that prevent a program from

00:01:56,160 --> 00:02:06,270
producing the desired result so where

00:01:59,429 --> 00:02:06,720
two errors come from that was a user

00:02:06,270 --> 00:02:16,470
error

00:02:06,720 --> 00:02:21,490
oh it quit that's bad yeah

00:02:16,470 --> 00:02:23,650
they don't have any air handling or no

00:02:21,490 --> 00:02:25,930
proper air act no that was the system

00:02:23,650 --> 00:02:28,600
error handling so I don't know what's

00:02:25,930 --> 00:02:39,430
wrong I don't know what to report no all

00:02:28,600 --> 00:02:42,910
I can do is we started okay so at least

00:02:39,430 --> 00:02:44,590
it could recover from the error but now

00:02:42,910 --> 00:02:53,080
it's talking German to you which is

00:02:44,590 --> 00:02:55,270
seems inefficient and here we go we have

00:02:53,080 --> 00:02:58,950
a program that's supposed to produce a

00:02:55,270 --> 00:03:01,660
result where does the program come from

00:02:58,950 --> 00:03:05,280
the broker comes from you to developer

00:03:01,660 --> 00:03:07,600
you write the program you call it but

00:03:05,280 --> 00:03:10,630
you don't usually don't code it for

00:03:07,600 --> 00:03:12,460
yourself you code it for a user who

00:03:10,630 --> 00:03:13,960
wants the result that's why he comes to

00:03:12,460 --> 00:03:14,850
you says I want something useful please

00:03:13,960 --> 00:03:16,930
make it for me

00:03:14,850 --> 00:03:20,500
however the user usually doesn't only

00:03:16,930 --> 00:03:23,650
want to program he wants to provide

00:03:20,500 --> 00:03:26,940
input and the program should create a

00:03:23,650 --> 00:03:29,020
result depending on his input

00:03:26,940 --> 00:03:31,180
additionally to that you need a

00:03:29,020 --> 00:03:33,250
environment for the program to run in

00:03:31,180 --> 00:03:35,290
and the environment sometimes is

00:03:33,250 --> 00:03:37,510
provided by users sometimes it's

00:03:35,290 --> 00:03:41,020
provided by dedicated people we usually

00:03:37,510 --> 00:03:46,000
call operations so that's the whole

00:03:41,020 --> 00:03:48,850
thing we do basically so how can errors

00:03:46,000 --> 00:03:51,190
creep into the whole concept while the

00:03:48,850 --> 00:03:53,310
users can provide protein input you

00:03:51,190 --> 00:03:56,920
might use invalidate formats they might

00:03:53,310 --> 00:03:58,840
use values out of range operators can

00:03:56,920 --> 00:04:00,700
provide insufficient environment where

00:03:58,840 --> 00:04:02,200
there are access rights missing where

00:04:00,700 --> 00:04:05,590
you cannot connect to a network where a

00:04:02,200 --> 00:04:08,140
disk is full and developers can write a

00:04:05,590 --> 00:04:10,030
program that is broken in the sense that

00:04:08,140 --> 00:04:12,459
it misses corner cases that has

00:04:10,030 --> 00:04:14,110
incorrect results or a switch has team

00:04:12,459 --> 00:04:19,480
that has insufficient error handling

00:04:14,110 --> 00:04:19,989
like LibreOffice so how do errors get

00:04:19,480 --> 00:04:22,690
fixed

00:04:19,989 --> 00:04:24,910
well in case of LibreOffice if this ever

00:04:22,690 --> 00:04:28,030
gets fixed somebody will sit down and

00:04:24,910 --> 00:04:29,439
write a better program so it's pretty

00:04:28,030 --> 00:04:31,779
much the same with input a

00:04:29,439 --> 00:04:34,629
and to environment the RS get fixed by

00:04:31,779 --> 00:04:37,059
people they add more memory they had

00:04:34,629 --> 00:04:37,779
valid order changed in potatoes of the

00:04:37,059 --> 00:04:39,819
day of Elliot

00:04:37,779 --> 00:04:44,229
after that the program can continue and

00:04:39,819 --> 00:04:48,189
finally produce the desired result for

00:04:44,229 --> 00:04:51,639
people to actually Fitch fix errors they

00:04:48,189 --> 00:04:53,379
need information and eagerly the program

00:04:51,639 --> 00:04:57,909
provides this information which

00:04:53,379 --> 00:05:01,479
LibreOffice didn't actually it early the

00:04:57,909 --> 00:05:03,519
developer writes the program in a way so

00:05:01,479 --> 00:05:07,329
that it provides this information and

00:05:03,519 --> 00:05:10,689
this is what this talk is about solution

00:05:07,329 --> 00:05:12,039
oriented parenting is a way to make it

00:05:10,689 --> 00:05:17,649
easier for you to provide the

00:05:12,039 --> 00:05:25,300
information to fix errors okay errors in

00:05:17,649 --> 00:05:28,569
python the widely used way to represent

00:05:25,300 --> 00:05:31,659
errors are exceptions you can do funny

00:05:28,569 --> 00:05:33,610
values you can do global variables but

00:05:31,659 --> 00:05:35,829
essentially and consistently the

00:05:33,610 --> 00:05:38,139
standard library uses exceptions to

00:05:35,829 --> 00:05:40,329
represent errors and I encourage you to

00:05:38,139 --> 00:05:42,249
do the same the major benefit of

00:05:40,329 --> 00:05:44,199
exceptions is that they cannot be

00:05:42,249 --> 00:05:46,119
ignored accidentally you don't have to

00:05:44,199 --> 00:05:48,789
check is there an error once an

00:05:46,119 --> 00:05:51,249
exception is raised it just reverses up

00:05:48,789 --> 00:05:56,079
the calling stack until some routine

00:05:51,249 --> 00:05:58,389
decides to deal with the era the Python

00:05:56,079 --> 00:06:01,209
program cannot simply continue after an

00:05:58,389 --> 00:06:05,050
error already OQ it you'll see this is

00:06:01,209 --> 00:06:10,389
pretty simple so how do you detect

00:06:05,050 --> 00:06:12,699
errors well you use a if and the error

00:06:10,389 --> 00:06:15,069
condition and if the condition is true

00:06:12,699 --> 00:06:17,259
you know you have an error and then you

00:06:15,069 --> 00:06:20,559
just raise an exception here's a trivial

00:06:17,259 --> 00:06:25,649
example I have a height parameter and if

00:06:20,559 --> 00:06:29,139
it's less than zero or if it is zero the

00:06:25,649 --> 00:06:32,069
exception tells me that the height must

00:06:29,139 --> 00:06:32,069
be greater than zero

00:06:32,879 --> 00:06:37,059
what can I do once an exception is

00:06:35,079 --> 00:06:41,589
raised well I can handle it using the

00:06:37,059 --> 00:06:43,020
except clause in this case I try my

00:06:41,589 --> 00:06:46,020
routine passing invalid

00:06:43,020 --> 00:06:48,030
you get an exception and if I print the

00:06:46,020 --> 00:06:49,919
exception I get the error message on the

00:06:48,030 --> 00:06:52,080
screen in this case I would get the

00:06:49,919 --> 00:06:56,970
result hate is - free but must be

00:06:52,080 --> 00:06:59,220
greater than zero when I want to clean

00:06:56,970 --> 00:07:04,169
up after errors - has several mechanisms

00:06:59,220 --> 00:07:06,360
is a simple one or the first one in case

00:07:04,169 --> 00:07:08,220
of a file I try to open the file if it

00:07:06,360 --> 00:07:11,940
works out I try to process the data I

00:07:08,220 --> 00:07:14,729
read from the file and finally I just

00:07:11,940 --> 00:07:16,319
clean up by closing the file the

00:07:14,729 --> 00:07:18,599
interesting thing about that finally

00:07:16,319 --> 00:07:20,819
closes the file independent if there's

00:07:18,599 --> 00:07:24,690
an error or not it will always close the

00:07:20,819 --> 00:07:27,599
file I could also use the whiff

00:07:24,690 --> 00:07:30,599
statement for that there's a little bit

00:07:27,599 --> 00:07:32,789
different syntax less code and gives the

00:07:30,599 --> 00:07:35,669
same result in order for the wave

00:07:32,789 --> 00:07:37,919
statement to work you need context

00:07:35,669 --> 00:07:40,530
managers of the class you use in this

00:07:37,919 --> 00:07:43,800
case file object needs to provide a

00:07:40,530 --> 00:07:47,639
context manager I'm gonna rush through

00:07:43,800 --> 00:07:49,139
this a bit I can simply add a context

00:07:47,639 --> 00:07:51,690
context manager on the fly using the

00:07:49,139 --> 00:07:55,020
closing routine which is very useful in

00:07:51,690 --> 00:07:56,819
Python to place in in PI for free

00:07:55,020 --> 00:07:58,680
because most of the standard objects

00:07:56,819 --> 00:08:02,009
already have a context miniature but in

00:07:58,680 --> 00:08:04,650
this case I can add one by calling the

00:08:02,009 --> 00:08:08,580
result in a closing when you want to

00:08:04,650 --> 00:08:12,060
write your own context manager and then

00:08:08,580 --> 00:08:13,560
you have to add basically two standard

00:08:12,060 --> 00:08:18,860
routines to a class here's a very simple

00:08:13,560 --> 00:08:21,419
example this is a task to copy a file

00:08:18,860 --> 00:08:23,789
the initial part just allocates the

00:08:21,419 --> 00:08:26,639
source file and the target file to open

00:08:23,789 --> 00:08:30,060
it there is a run part which runs the

00:08:26,639 --> 00:08:31,860
task and it simply copies the bytes from

00:08:30,060 --> 00:08:33,930
one file to the other and there is a

00:08:31,860 --> 00:08:36,930
cleanup routine called closed which

00:08:33,930 --> 00:08:38,490
closes the two files as that naive

00:08:36,930 --> 00:08:43,500
variant because it doesn't do any error

00:08:38,490 --> 00:08:46,170
engine yet I could use this naive

00:08:43,500 --> 00:08:49,459
variant the way it is with a try and

00:08:46,170 --> 00:08:51,810
finally to open a copy test run it and

00:08:49,459 --> 00:08:55,050
execute it and clean up the resources

00:08:51,810 --> 00:08:55,470
afterwards if I want to do that with the

00:08:55,050 --> 00:08:57,240
County

00:08:55,470 --> 00:09:01,110
manager and the rift Clause I just have

00:08:57,240 --> 00:09:04,080
to add two routines enter and exit and

00:09:01,110 --> 00:09:05,640
they will always look like that the

00:09:04,080 --> 00:09:07,500
context manager can do a lot of things

00:09:05,640 --> 00:09:09,510
but if you just want to use it in a

00:09:07,500 --> 00:09:11,280
whiff clause there's nothing more to it

00:09:09,510 --> 00:09:14,190
as soon as you have a closed and

00:09:11,280 --> 00:09:15,810
initializer that allocates all the

00:09:14,190 --> 00:09:17,730
resources and the closed routine that

00:09:15,810 --> 00:09:20,640
gives all of them back that's the

00:09:17,730 --> 00:09:25,440
context manager these four lines of code

00:09:20,640 --> 00:09:29,630
and once you edit these you can use it

00:09:25,440 --> 00:09:32,400
with to disclose what's happening here

00:09:29,630 --> 00:09:35,400
the whiff Clause basically calls the

00:09:32,400 --> 00:09:37,920
init function at the part well create

00:09:35,400 --> 00:09:39,600
the object once you assign it to a

00:09:37,920 --> 00:09:42,810
variable it calls the entire function

00:09:39,600 --> 00:09:45,390
and assigns the value of the result of

00:09:42,810 --> 00:09:47,760
enter to the variable and once the whole

00:09:45,390 --> 00:09:50,190
lipgloss ends it calls the exit function

00:09:47,760 --> 00:09:52,170
that's basically what context manages to

00:09:50,190 --> 00:09:55,320
and I think it's a very simple way to

00:09:52,170 --> 00:10:01,440
not bother much about giving back

00:09:55,320 --> 00:10:04,490
resources here's an example of improved

00:10:01,440 --> 00:10:08,340
context manager because the initial

00:10:04,490 --> 00:10:10,530
variant basically only allocated the

00:10:08,340 --> 00:10:12,540
resources and you can run in a case when

00:10:10,530 --> 00:10:14,510
you allocate multiple resources that the

00:10:12,540 --> 00:10:17,400
initializer already breaks after

00:10:14,510 --> 00:10:19,320
allocating the source files but it

00:10:17,400 --> 00:10:20,970
cannot open the target file and you want

00:10:19,320 --> 00:10:23,640
to make sure to give back the target

00:10:20,970 --> 00:10:25,650
file so you basically remember all the

00:10:23,640 --> 00:10:27,420
resources initialized and with nan and

00:10:25,650 --> 00:10:30,000
make the clothes routine a bit smarter

00:10:27,420 --> 00:10:33,690
only close those files that are not none

00:10:30,000 --> 00:10:35,100
and in it also checks for errors and if

00:10:33,690 --> 00:10:37,560
there is an error it calls the close

00:10:35,100 --> 00:10:40,530
beforehand it's a pretty simple

00:10:37,560 --> 00:10:42,180
principle and then there's another

00:10:40,530 --> 00:10:45,990
statement to detect errors we already

00:10:42,180 --> 00:10:48,480
talked about race the always assert how

00:10:45,990 --> 00:10:52,080
many people know the assert statement

00:10:48,480 --> 00:10:54,390
I've used it already okay how many

00:10:52,080 --> 00:10:59,610
people think they they know when to use

00:10:54,390 --> 00:11:01,740
a shirt and when to use race that's all

00:10:59,610 --> 00:11:03,510
right so every jade was about the FIR to

00:11:01,740 --> 00:11:06,870
know about them

00:11:03,510 --> 00:11:09,240
and about 10% who think they know when

00:11:06,870 --> 00:11:11,550
to use it properly okay

00:11:09,240 --> 00:11:14,660
what is the asset statement well I could

00:11:11,550 --> 00:11:17,700
also detect an error using assert is

00:11:14,660 --> 00:11:20,550
again the previous example with the race

00:11:17,700 --> 00:11:23,490
I can do the same with assert by just

00:11:20,550 --> 00:11:24,630
specifying condition in this case it's

00:11:23,490 --> 00:11:26,460
not the error condition but the

00:11:24,630 --> 00:11:30,330
condition for the correct state hate

00:11:26,460 --> 00:11:31,980
must be greater than c0 and provide an

00:11:30,330 --> 00:11:34,620
error message which is optional in this

00:11:31,980 --> 00:11:39,540
case there is a couple of differences

00:11:34,620 --> 00:11:42,510
with assert internally it just raises an

00:11:39,540 --> 00:11:45,690
assertion error so to some extent it is

00:11:42,510 --> 00:11:48,210
comparable with race however you can be

00:11:45,690 --> 00:11:50,820
activated if you run - from the comment

00:11:48,210 --> 00:11:54,660
line with the - oh switch not the digit

00:11:50,820 --> 00:11:57,930
zero it activates the checking of

00:11:54,660 --> 00:11:59,730
assertions which might increase

00:11:57,930 --> 00:12:03,120
performance a little and might remove

00:11:59,730 --> 00:12:05,520
consistencies checks factors called by

00:12:03,120 --> 00:12:07,680
assert therefore must not have any side

00:12:05,520 --> 00:12:09,780
effects because otherwise the program

00:12:07,680 --> 00:12:13,440
starts to behaving differently whether -

00:12:09,780 --> 00:12:16,110
all specified or not and the question

00:12:13,440 --> 00:12:17,820
now is when do we use race and when do

00:12:16,110 --> 00:12:19,590
we use assert this is something I'm

00:12:17,820 --> 00:12:24,180
going to talk about a little bit later

00:12:19,590 --> 00:12:25,650
so in summary the gist of pythons

00:12:24,180 --> 00:12:29,310
exception handling is that you can

00:12:25,650 --> 00:12:32,220
detect errors with raise or assert you

00:12:29,310 --> 00:12:35,040
can deal with errors using try and

00:12:32,220 --> 00:12:37,260
accept and you can clean up using

00:12:35,040 --> 00:12:40,620
finally closing or context managers

00:12:37,260 --> 00:12:42,600
these are the tools - gives you when you

00:12:40,620 --> 00:12:46,230
install it everything of this is already

00:12:42,600 --> 00:12:48,030
there so the interesting parts that's

00:12:46,230 --> 00:12:50,820
now how do I use all this in a solution

00:12:48,030 --> 00:12:52,530
oriented way and the principles of

00:12:50,820 --> 00:12:56,070
solution oriented error handling are

00:12:52,530 --> 00:12:59,700
that you focus on the solution and not

00:12:56,070 --> 00:13:02,100
on what's wrong you have clear

00:12:59,700 --> 00:13:07,080
responsibilities between developers and

00:13:02,100 --> 00:13:09,930
the user and operator you have helpful

00:13:07,080 --> 00:13:11,910
and specific error messages and error

00:13:09,930 --> 00:13:13,770
conditions and error messages can be

00:13:11,910 --> 00:13:16,030
derived from the code so it is a

00:13:13,770 --> 00:13:19,130
developer centric approach

00:13:16,030 --> 00:13:21,740
when I talk about responsibilities let's

00:13:19,130 --> 00:13:24,650
take a look at the graphics that we had

00:13:21,740 --> 00:13:26,390
before the responsibility of the user

00:13:24,650 --> 00:13:30,620
enter operators is pretty clear they

00:13:26,390 --> 00:13:32,600
have to provide sufficient complete and

00:13:30,620 --> 00:13:35,060
valid input for the program to produce

00:13:32,600 --> 00:13:36,830
the result the operators have to provide

00:13:35,060 --> 00:13:37,760
an environment where the program has

00:13:36,830 --> 00:13:39,680
everything it needs

00:13:37,760 --> 00:13:46,010
concerning access rights memory and so

00:13:39,680 --> 00:13:48,830
on and the developer has the

00:13:46,010 --> 00:13:51,280
responsibility to write the program so

00:13:48,830 --> 00:13:54,080
that's something important to remember

00:13:51,280 --> 00:13:56,360
all we can do is write the program we

00:13:54,080 --> 00:13:58,610
cannot add memory at the user site we

00:13:56,360 --> 00:14:04,160
cannot add or change input so that it

00:13:58,610 --> 00:14:07,220
works the user has to do that however we

00:14:04,160 --> 00:14:09,950
also have another responsibility if the

00:14:07,220 --> 00:14:11,630
program cannot produce the result we

00:14:09,950 --> 00:14:14,330
have to provide helpful information to

00:14:11,630 --> 00:14:16,130
the user or we have to make the program

00:14:14,330 --> 00:14:19,880
to provide helpful information to the

00:14:16,130 --> 00:14:25,790
user so that they can fix any errors on

00:14:19,880 --> 00:14:32,120
site how can we do it using a cert well

00:14:25,790 --> 00:14:35,470
assert is a tool to detect errors by

00:14:32,120 --> 00:14:38,180
checking the internal program State

00:14:35,470 --> 00:14:40,160
ideally it detects errors before the

00:14:38,180 --> 00:14:43,100
program is delivered so it's a tool for

00:14:40,160 --> 00:14:45,950
the developer and if an assertion fails

00:14:43,100 --> 00:14:48,860
the developer has to fix the error by

00:14:45,950 --> 00:14:50,570
changing the code maybe he has to cover

00:14:48,860 --> 00:14:52,130
new requirements and whatnot but at the

00:14:50,570 --> 00:14:54,770
end of the day he will have to change

00:14:52,130 --> 00:14:56,120
the code for the assertion to go away so

00:14:54,770 --> 00:14:57,860
the target audience for the assertion

00:14:56,120 --> 00:14:59,810
clearance the developer and assertions

00:14:57,860 --> 00:15:03,140
that they have to detect parks in the

00:14:59,810 --> 00:15:05,810
program assertions are a very useful

00:15:03,140 --> 00:15:09,860
tool to establish clear responsibilities

00:15:05,810 --> 00:15:14,660
between Cola and calling routines you

00:15:09,860 --> 00:15:17,270
can particularly use it to validate

00:15:14,660 --> 00:15:20,150
parameters and point out invalid

00:15:17,270 --> 00:15:23,240
parameters so that's that's something

00:15:20,150 --> 00:15:25,670
apart from where I use it a lot this is

00:15:23,240 --> 00:15:28,320
called preconditions and assertions

00:15:25,670 --> 00:15:30,480
provide executable documentation

00:15:28,320 --> 00:15:33,120
so it's it's better to write assertions

00:15:30,480 --> 00:15:35,519
which actually check if a parameter is

00:15:33,120 --> 00:15:37,949
correct then to write documentation

00:15:35,519 --> 00:15:39,990
nobody reads and that might get out of

00:15:37,949 --> 00:15:40,920
date assertions are executed every time

00:15:39,990 --> 00:15:42,649
the program runs

00:15:40,920 --> 00:15:47,610
so once the assertion gets out of date

00:15:42,649 --> 00:15:50,250
you have to fix the assertion on the

00:15:47,610 --> 00:15:52,829
other hand raise you can use to detect

00:15:50,250 --> 00:15:55,019
errors in the data and environment in

00:15:52,829 --> 00:15:56,819
things the user and operators can solve

00:15:55,019 --> 00:15:58,560
so they can provide valid data a

00:15:56,819 --> 00:16:00,449
complete input or they can provide a

00:15:58,560 --> 00:16:02,399
sufficient environment with enough

00:16:00,449 --> 00:16:05,550
memory disk space and connections

00:16:02,399 --> 00:16:07,889
network connections raised is something

00:16:05,550 --> 00:16:09,690
to point out conditions to develop I

00:16:07,889 --> 00:16:11,970
cannot deal with at the time he writes

00:16:09,690 --> 00:16:14,220
the program he has no influence on these

00:16:11,970 --> 00:16:19,589
conditions the target audience clearly

00:16:14,220 --> 00:16:21,120
are the users and the operations so a

00:16:19,589 --> 00:16:23,160
couple of words converting error

00:16:21,120 --> 00:16:25,740
messages well you have a lot of

00:16:23,160 --> 00:16:27,779
usability guidelines and books about it

00:16:25,740 --> 00:16:30,000
written by usability people but very

00:16:27,779 --> 00:16:31,920
often they are too vague for developers

00:16:30,000 --> 00:16:33,720
to actually turn them into code so error

00:16:31,920 --> 00:16:37,079
messages should be pro-life precise

00:16:33,720 --> 00:16:39,720
constructive well how do I actually do

00:16:37,079 --> 00:16:41,579
that and in practice you see that many

00:16:39,720 --> 00:16:44,430
error messages talk a lot about the

00:16:41,579 --> 00:16:44,850
things that are wrong and all about what

00:16:44,430 --> 00:16:47,190
should I do

00:16:44,850 --> 00:16:48,600
what's what's actually it's precisely

00:16:47,190 --> 00:16:49,380
wrong what can I do what are my

00:16:48,600 --> 00:16:51,899
possibilities

00:16:49,380 --> 00:16:53,880
so the solution oriented approach to

00:16:51,899 --> 00:16:57,180
error messages is that they describe the

00:16:53,880 --> 00:16:59,819
actual state and value and the one that

00:16:57,180 --> 00:17:01,889
would have been expected the describe

00:16:59,819 --> 00:17:04,530
the actions necessary to solve the error

00:17:01,889 --> 00:17:06,299
and the describe the actions did lead to

00:17:04,530 --> 00:17:09,150
an error to provide context where the

00:17:06,299 --> 00:17:14,970
error comes from so how does it look in

00:17:09,150 --> 00:17:19,250
terms of code oh that was one slide

00:17:14,970 --> 00:17:21,689
ahead how does it look in terms of code

00:17:19,250 --> 00:17:24,540
generally code to detect errors look

00:17:21,689 --> 00:17:26,610
looks like that if an actual value is

00:17:24,540 --> 00:17:28,710
not the expected value then erase some

00:17:26,610 --> 00:17:34,110
error if the message actual must be

00:17:28,710 --> 00:17:37,710
expected so and I already have these in

00:17:34,110 --> 00:17:40,049
my code here's an example we already

00:17:37,710 --> 00:17:42,090
know it if hate is less and smaller than

00:17:40,049 --> 00:17:43,710
zero arrays a value arrow

00:17:42,090 --> 00:17:50,220
which she says hate must be greater than

00:17:43,710 --> 00:17:52,740
zero how do I describe the solution well

00:17:50,220 --> 00:17:54,620
I already did I already told them hate

00:17:52,740 --> 00:17:58,620
must be greater than zero

00:17:54,620 --> 00:18:00,539
so from this error message the user just

00:17:58,620 --> 00:18:03,240
have to do whatever is necessary to

00:18:00,539 --> 00:18:04,710
establish the expected condition for

00:18:03,240 --> 00:18:07,230
that of course he has to understand the

00:18:04,710 --> 00:18:09,120
program and how to use it a couple of

00:18:07,230 --> 00:18:12,000
more examples for such error messages

00:18:09,120 --> 00:18:14,940
date of birth must match a certain date

00:18:12,000 --> 00:18:16,890
format the option kala in the section

00:18:14,940 --> 00:18:23,100
layout of the config file must be one of

00:18:16,890 --> 00:18:24,779
red green blue so how do I describe the

00:18:23,100 --> 00:18:29,279
action and the value that led to the

00:18:24,779 --> 00:18:32,070
error when I raise an error I just

00:18:29,279 --> 00:18:36,539
specified the value i used in my error

00:18:32,070 --> 00:18:39,929
condition so in my case hate at the

00:18:36,539 --> 00:18:41,669
value minus zero and I just add it to

00:18:39,929 --> 00:18:44,520
the error message error message says

00:18:41,669 --> 00:18:47,809
hate is zero but must be greater than 8

00:18:44,520 --> 00:18:50,610
is minus 3 but must be greater than zero

00:18:47,809 --> 00:18:52,679
when I get an error already for Mary

00:18:50,610 --> 00:18:57,000
calling routine and I catch it with the

00:18:52,679 --> 00:18:58,679
accept statement I don't know what the

00:18:57,000 --> 00:19:00,659
initial condition was so I just have to

00:18:58,679 --> 00:19:02,549
rely on the initial message however I

00:19:00,659 --> 00:19:05,429
can add the context in which the error

00:19:02,549 --> 00:19:07,799
cured so I just described the action

00:19:05,429 --> 00:19:10,440
that could not be performed typically I

00:19:07,799 --> 00:19:15,090
cannot process I cannot connect or I

00:19:10,440 --> 00:19:19,620
cannot write to a file I cannot use the

00:19:15,090 --> 00:19:22,740
value of in a form in a certain field so

00:19:19,620 --> 00:19:26,340
I describe the item and in this message

00:19:22,740 --> 00:19:30,090
I have to use the terms to use a knows

00:19:26,340 --> 00:19:32,309
so not my variable names which ideally

00:19:30,090 --> 00:19:34,980
are the same but something the user

00:19:32,309 --> 00:19:36,299
knows and then all the information in

00:19:34,980 --> 00:19:38,159
the error message is something the user

00:19:36,299 --> 00:19:40,710
should be able to deal with provided he

00:19:38,159 --> 00:19:44,820
has enough knowledge about software and

00:19:40,710 --> 00:19:47,520
how to use it let's take a look at an

00:19:44,820 --> 00:19:49,860
example we already know this routine it

00:19:47,520 --> 00:19:51,820
is process something and gets a hate

00:19:49,860 --> 00:19:54,850
variable or I hate parameter

00:19:51,820 --> 00:19:58,210
and raises an exception if it is not in

00:19:54,850 --> 00:20:03,399
the valid range there's a routine that

00:19:58,210 --> 00:20:07,119
would process hate values it gets from

00:20:03,399 --> 00:20:11,889
file so basically it opens a file reads

00:20:07,119 --> 00:20:15,639
a line converts it to integer and checks

00:20:11,889 --> 00:20:17,499
for errors if everything goes wrong I if

00:20:15,639 --> 00:20:20,889
everything goes right there is no

00:20:17,499 --> 00:20:23,049
exception if there is an exception it

00:20:20,889 --> 00:20:25,859
writes an error message resists cannot

00:20:23,049 --> 00:20:30,849
process data in file and the file name

00:20:25,859 --> 00:20:33,279
line and the line number and the actual

00:20:30,849 --> 00:20:36,159
error message it caught in the value

00:20:33,279 --> 00:20:38,619
error and in summary the output of this

00:20:36,159 --> 00:20:42,340
in case of error would be cannot process

00:20:38,619 --> 00:20:46,769
data files some text line 17 hate is -

00:20:42,340 --> 00:20:49,629
free but must be greater than zero and

00:20:46,769 --> 00:20:52,899
basically you get all this for free from

00:20:49,629 --> 00:20:54,609
your code you already wrote so in

00:20:52,899 --> 00:20:56,739
summary a pattern for error messages

00:20:54,609 --> 00:20:59,470
cannot perform an action at the certain

00:20:56,739 --> 00:21:01,929
location something is actual but must be

00:20:59,470 --> 00:21:07,720
expected and you should have all of this

00:21:01,929 --> 00:21:09,700
available in your code and a couple of

00:21:07,720 --> 00:21:10,389
words on exception hierarchy to make it

00:21:09,700 --> 00:21:12,909
easier for you

00:21:10,389 --> 00:21:14,799
exceptions are classes in Python that

00:21:12,909 --> 00:21:17,739
are organized in a hierarchy which

00:21:14,799 --> 00:21:20,259
allows you to collect similar exceptions

00:21:17,739 --> 00:21:24,639
in groups and deal with them in the same

00:21:20,259 --> 00:21:27,070
way so we can use this to assign

00:21:24,639 --> 00:21:29,349
responsibilities it's already pretty

00:21:27,070 --> 00:21:31,599
clear that developers should fix this

00:21:29,349 --> 00:21:32,859
version errors in my experience is

00:21:31,599 --> 00:21:35,679
pretty clear that users and operators

00:21:32,859 --> 00:21:39,789
should fix OS errors however there is a

00:21:35,679 --> 00:21:42,159
quite large amount of exceptions where

00:21:39,789 --> 00:21:44,529
you can't really say who's responsible

00:21:42,159 --> 00:21:48,369
to fix it so it's your task to make this

00:21:44,529 --> 00:21:50,919
more specific in my experience I usually

00:21:48,369 --> 00:21:53,470
just define a data error because that's

00:21:50,919 --> 00:21:56,950
the arrows about user input users can

00:21:53,470 --> 00:22:00,820
fix and when I detect something invalid

00:21:56,950 --> 00:22:04,960
I just raise the data error exception is

00:22:00,820 --> 00:22:08,380
raised by other routines value error in

00:22:04,960 --> 00:22:10,450
look up era very often indicate at the

00:22:08,380 --> 00:22:12,220
data era so I just catch them with

00:22:10,450 --> 00:22:16,570
accept and re raise them as data error

00:22:12,220 --> 00:22:20,620
again here's an example how to define a

00:22:16,570 --> 00:22:24,690
data error pretty easy in Python how do

00:22:20,620 --> 00:22:27,430
I convert value error to a data error I

00:22:24,690 --> 00:22:30,040
just catch the value error and raise the

00:22:27,430 --> 00:22:33,610
data error where I leave the original

00:22:30,040 --> 00:22:36,240
message intact in Python free you can

00:22:33,610 --> 00:22:39,040
also preserve the stack trace by using

00:22:36,240 --> 00:22:42,970
exception chaining with a little example

00:22:39,040 --> 00:22:44,920
for that so I use a solution oriented

00:22:42,970 --> 00:22:47,920
exception hierarchy basically comes down

00:22:44,920 --> 00:22:50,710
to users fix data error and OS error and

00:22:47,920 --> 00:22:55,930
the developer fixes everything else in

00:22:50,710 --> 00:22:58,830
particular assertion error a couple of

00:22:55,930 --> 00:23:03,820
recommendations for accept and raise

00:22:58,830 --> 00:23:05,320
when do I use accept you have to use it

00:23:03,820 --> 00:23:07,660
at the utmost layer of your main routine

00:23:05,320 --> 00:23:10,630
and print an error message or do

00:23:07,660 --> 00:23:13,990
something useful with every exception in

00:23:10,630 --> 00:23:16,630
graphical applications you should use it

00:23:13,990 --> 00:23:19,890
for every enclosed user operation or

00:23:16,630 --> 00:23:22,300
action pattern as developers call it if

00:23:19,890 --> 00:23:24,310
enclosed operation fails you can say

00:23:22,300 --> 00:23:26,730
this operation failed and you have to

00:23:24,310 --> 00:23:29,710
establish this or that condition you

00:23:26,730 --> 00:23:31,300
cannot do mm except to convert other

00:23:29,710 --> 00:23:33,220
exceptions to data error as I've just

00:23:31,300 --> 00:23:39,910
shown to make it clear version who's

00:23:33,220 --> 00:23:42,730
responsible and you can use accept to

00:23:39,910 --> 00:23:45,100
convert errors in two valid States which

00:23:42,730 --> 00:23:47,500
is a bit of risky principle but where it

00:23:45,100 --> 00:23:49,510
works reasonably well is for example to

00:23:47,500 --> 00:23:54,370
provide default values for things that

00:23:49,510 --> 00:23:57,220
are simply not there so generally you

00:23:54,370 --> 00:23:59,500
hardly ever use accept and buy and you

00:23:57,220 --> 00:24:02,080
use it in a tightly focused way which

00:23:59,500 --> 00:24:03,700
means little work for the developer and

00:24:02,080 --> 00:24:05,560
which also means that the error handling

00:24:03,700 --> 00:24:07,390
in your code becomes very easy because

00:24:05,560 --> 00:24:09,610
most of the time you just clean up if

00:24:07,390 --> 00:24:12,340
there's an error you don't care because

00:24:09,610 --> 00:24:14,890
you can't fix it the user has to fix it

00:24:12,340 --> 00:24:16,750
the operator has to fix it so you just

00:24:14,890 --> 00:24:17,720
clean up and it traverses upwards the

00:24:16,750 --> 00:24:22,850
stack

00:24:17,720 --> 00:24:24,890
eventually the cola one of the calling

00:24:22,850 --> 00:24:27,610
routines will decide how to deal with it

00:24:24,890 --> 00:24:29,900
but it's not your problem at that moment

00:24:27,610 --> 00:24:31,580
the nice thing is that you don't have to

00:24:29,900 --> 00:24:33,110
care about producing the result because

00:24:31,580 --> 00:24:35,960
the exception mechanism already stops

00:24:33,110 --> 00:24:38,390
the productive part of your code and the

00:24:35,960 --> 00:24:41,030
benefit of all this is you have a clean

00:24:38,390 --> 00:24:43,070
code focusing on producing the result

00:24:41,030 --> 00:24:46,180
and it doesn't intermediate with try I

00:24:43,070 --> 00:24:46,180
accept and whatnot

00:24:46,210 --> 00:24:52,910
when do I detect an error well it's

00:24:51,230 --> 00:24:54,740
pretty easy if you use a natural naming

00:24:52,910 --> 00:24:57,650
in your code that means the routines in

00:24:54,740 --> 00:25:00,160
your code have the same name as the

00:24:57,650 --> 00:25:02,450
things they are supposed to perform and

00:25:00,160 --> 00:25:04,580
functions have the name of the things

00:25:02,450 --> 00:25:08,300
they're supposed to return because then

00:25:04,580 --> 00:25:10,820
an error condition is when it cannot do

00:25:08,300 --> 00:25:12,740
the thing it's supposed to perform as

00:25:10,820 --> 00:25:15,670
the name suggests or it cannot return

00:25:12,740 --> 00:25:18,230
the result it's supposed to return

00:25:15,670 --> 00:25:24,170
that's an error condition and in that

00:25:18,230 --> 00:25:26,000
case you just raise OS it okay here's a

00:25:24,170 --> 00:25:30,680
small template for a command line

00:25:26,000 --> 00:25:33,380
application how to apply that the

00:25:30,680 --> 00:25:35,270
interesting part is the most interesting

00:25:33,380 --> 00:25:37,010
part is here you have a production code

00:25:35,270 --> 00:25:39,860
that should produce a result if it

00:25:37,010 --> 00:25:44,300
cannot do it handles the data around OS

00:25:39,860 --> 00:25:46,070
error - and if there's anything else it

00:25:44,300 --> 00:25:49,010
just locks the exception including the

00:25:46,070 --> 00:25:50,390
stack trace and that's all there is and

00:25:49,010 --> 00:25:52,490
if it's a simple command-line

00:25:50,390 --> 00:25:54,230
application there is not a single except

00:25:52,490 --> 00:25:55,790
statement in it this may be a couple of

00:25:54,230 --> 00:25:57,950
raised statements where detect certain

00:25:55,790 --> 00:25:59,240
error conditions but other than that you

00:25:57,950 --> 00:26:04,130
don't have to bother about error

00:25:59,240 --> 00:26:07,490
handling and it gives a exit code 0 or 1

00:26:04,130 --> 00:26:10,250
depending on the general state ok

00:26:07,490 --> 00:26:11,900
so in summary solution oriented error

00:26:10,250 --> 00:26:13,970
handling is a set of guidelines to

00:26:11,900 --> 00:26:16,790
efficiently use hyphens exception

00:26:13,970 --> 00:26:19,210
handling the core consideration is who

00:26:16,790 --> 00:26:21,980
can fix the error

00:26:19,210 --> 00:26:24,190
users can fix errors during runtime if

00:26:21,980 --> 00:26:26,750
they are data errors or s errors

00:26:24,190 --> 00:26:28,940
developers can fix errors during the

00:26:26,750 --> 00:26:31,519
implementation if there are exceptions

00:26:28,940 --> 00:26:34,039
or assertions or other

00:26:31,519 --> 00:26:35,960
and you always clean up in case of era

00:26:34,039 --> 00:26:40,759
and you always clean up even if the

00:26:35,960 --> 00:26:45,590
result is produced with finally the with

00:26:40,759 --> 00:26:48,049
statement and context managers so error

00:26:45,590 --> 00:26:49,879
handling code basically consists of

00:26:48,049 --> 00:26:51,739
detecting a couple of conditions that

00:26:49,879 --> 00:26:54,559
indicate errors raised in the certain

00:26:51,739 --> 00:26:56,869
most of the time just delegate the

00:26:54,559 --> 00:27:00,200
exceptions and are the few specific

00:26:56,869 --> 00:27:01,850
locations catch them with accept and the

00:27:00,200 --> 00:27:03,739
pattern for helpful error messages is

00:27:01,850 --> 00:27:06,409
cannot perform action at location

00:27:03,739 --> 00:27:09,289
something is actual but must be expected

00:27:06,409 --> 00:27:14,649
which automatically describes the

00:27:09,289 --> 00:27:14,649
solution to the error okay

00:27:20,720 --> 00:27:26,990
so questions Thank You Thomas any

00:27:23,600 --> 00:27:31,130
questions there are two microphones okay

00:27:26,990 --> 00:27:34,850
okay yeah do you know if there is a way

00:27:31,130 --> 00:27:37,820
to emulate the from error from Python

00:27:34,850 --> 00:27:41,450
three in Python - sorry I can understand

00:27:37,820 --> 00:27:43,970
you is there a way to emulate the from

00:27:41,450 --> 00:27:47,300
error syntax from Python three in Python

00:27:43,970 --> 00:27:50,420
- only by hacking around there's no more

00:27:47,300 --> 00:27:53,690
clean way now you can use the original

00:27:50,420 --> 00:27:55,220
stack trace in your old exception but I

00:27:53,690 --> 00:27:56,900
think you have to go down into 30

00:27:55,220 --> 00:28:02,810
metaprogramming to actually do it I've

00:27:56,900 --> 00:28:04,910
never done it myself okay thanks I think

00:28:02,810 --> 00:28:06,530
we ran out of time for questions so you

00:28:04,910 --> 00:28:09,550
could get a one final round of applause

00:28:06,530 --> 00:28:09,550
- Thomas thank you very much

00:28:11,740 --> 00:28:13,800

YouTube URL: https://www.youtube.com/watch?v=j1mN7j83AV8


