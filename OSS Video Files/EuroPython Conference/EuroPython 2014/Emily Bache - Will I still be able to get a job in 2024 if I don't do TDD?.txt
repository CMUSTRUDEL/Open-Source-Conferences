Title: Emily Bache - Will I still be able to get a job in 2024 if I don't do TDD?
Publication date: 2015-04-18
Playlist: EuroPython 2014
Description: 
	Emily Bache - Will I still be able to get a job in 2024 if I don't do TDD?
[EuroPython 2014]
[22 July 2014]

Geoffrey Moores's book "Crossing the chasm" outlines the difficulties
faced by a new, disruptive technology, when adoption moves from
innovators and visionaries into the mainstream. Test Driven Development
is clearly a disruptive technology, that changes the way you approach
software design and testing. It hasn't yet been embraced by everyone,
but is it just a matter of time? Ten years from now, will a non-TDD
practicing developer experience the horror of being labelled a
technology adoption 'laggard', and be left working exclusively on
dreadfully boring legacy systems?
It could be a smart move to get down to your nearest Coding Dojo and
practice TDD on some Code Katas. On the other hand, the thing with
disruptive technologies is that even they can become disrupted when
something better comes along. What about Property-Based Testing?
Approval Testing? Outside-In Development?
In this talk, I'd like to look at the chasm-crossing potential of TDD
and some related technologies. My aim is that both you and I will still
be able to get a good job in 2024.

-----

TDD hasn't yet been embraced by everyone,
but is it just a matter of time? Ten years from now, will a non-TDD
practicing developer experience the horror of being labelled a
technology adoption 'laggard', and be left working exclusively on
dreadfully boring legacy systems?

It could be a smart move to get down to your nearest Coding Dojo and
practice TDD on some Code Katas. On the other hand, the thing with
disruptive technologies is that even they can become disrupted when
something better comes along. What about Property-Based Testing?
Approval Testing? Outside-In Development?

In this talk, I'd like to look at the chasm-crossing potential of TDD
and some related technologies. My aim is that both you and I will still
be able to get a good job in 2024.
Captions: 
	00:00:14,760 --> 00:00:18,250
so I make it very quick because we are

00:00:16,890 --> 00:00:20,740
five minutes

00:00:18,250 --> 00:00:21,520
minority this is Emily Baha'i from

00:00:20,740 --> 00:00:26,800
Sweden

00:00:21,520 --> 00:00:28,540
she's a long-term testing expert using

00:00:26,800 --> 00:00:30,640
test-driven development for at least 10

00:00:28,540 --> 00:00:32,110
years has given various talks and

00:00:30,640 --> 00:00:35,860
conferences about it she uses several

00:00:32,110 --> 00:00:42,070
languages ranging from Python met her in

00:00:35,860 --> 00:00:43,739
2004 to Scala Ruby and all kinds of

00:00:42,070 --> 00:00:46,930
things she's currently working with a

00:00:43,739 --> 00:00:48,340
company in Sweden and one thing that is

00:00:46,930 --> 00:00:50,829
interesting is that she's also doing

00:00:48,340 --> 00:00:54,219
coding dojos and has written the coding

00:00:50,829 --> 00:00:55,930
dojo handbook which is a special format

00:00:54,219 --> 00:00:58,809
where you actually sit together and you

00:00:55,930 --> 00:01:01,300
have people coding in front and

00:00:58,809 --> 00:01:06,970
everybody else commenting isn't that

00:01:01,300 --> 00:01:11,950
great and so I'm very much looking

00:01:06,970 --> 00:01:14,020
forward to Emily's insights about

00:01:11,950 --> 00:01:19,770
testing and if we all will still get

00:01:14,020 --> 00:01:19,770
jobs in a few years from now Emily

00:01:25,170 --> 00:01:30,719
Thank You Holger I'm very pleased to be

00:01:28,450 --> 00:01:33,640
invited to be here talking on this topic

00:01:30,719 --> 00:01:36,100
so when we had predicting the future

00:01:33,640 --> 00:01:38,710
it's good to have a model so this is a

00:01:36,100 --> 00:01:40,929
model of disruptive technology adoption

00:01:38,710 --> 00:01:44,530
that Jeffrey Moore came up with in his

00:01:40,929 --> 00:01:47,439
book crossing the chasm like in the 90s

00:01:44,530 --> 00:01:49,560
and he noticed that the kind of

00:01:47,439 --> 00:01:52,929
attributes of a technology that made

00:01:49,560 --> 00:01:54,250
early adopters flock to it were

00:01:52,929 --> 00:01:56,799
different from the kind of attributes

00:01:54,250 --> 00:01:59,229
that made the the broad mainstream the

00:01:56,799 --> 00:02:02,140
biggest part of the market come to a new

00:01:59,229 --> 00:02:03,610
technology and he this idea of a chasm

00:02:02,140 --> 00:02:06,099
between that technologies can be very

00:02:03,610 --> 00:02:08,289
successful amongst early adopters and

00:02:06,099 --> 00:02:12,670
then not make the transition to the

00:02:08,289 --> 00:02:14,829
mainstream so I found this this quite an

00:02:12,670 --> 00:02:16,390
interesting idea because well I don't

00:02:14,829 --> 00:02:19,000
know about you but I'm personally a bit

00:02:16,390 --> 00:02:21,640
of a serial early adopter new shiny

00:02:19,000 --> 00:02:24,700
technologies um I'm sure there's many

00:02:21,640 --> 00:02:28,269
people here who can beat this but I did

00:02:24,700 --> 00:02:32,440
start programming Python in 1999 which

00:02:28,269 --> 00:02:33,940
was fairly early maybe not that this I

00:02:32,440 --> 00:02:35,530
also wanted more evidence so I'm an

00:02:33,940 --> 00:02:38,670
early adopter this is a letter I got

00:02:35,530 --> 00:02:40,750
from Reed Hoffman in Knight 2011

00:02:38,670 --> 00:02:44,680
congratulating me on being one of the

00:02:40,750 --> 00:02:46,209
first million members of LinkedIn when

00:02:44,680 --> 00:02:49,150
they reached a hundred million members

00:02:46,209 --> 00:02:52,599
so I was on LinkedIn when you know it

00:02:49,150 --> 00:02:54,639
was new and cool but about this sir time

00:02:52,599 --> 00:02:56,889
probably about 2011 I noticed they

00:02:54,639 --> 00:03:00,000
started running these little adverts

00:02:56,889 --> 00:03:03,400
next to your profile page they would

00:03:00,000 --> 00:03:05,590
find some company that some of your

00:03:03,400 --> 00:03:07,900
contacts worked for and put up this

00:03:05,590 --> 00:03:09,400
little advert st. pitch yourself you

00:03:07,900 --> 00:03:12,639
could have a new job working for this

00:03:09,400 --> 00:03:15,099
company the thing is the company that

00:03:12,639 --> 00:03:18,190
they happen to pick this one virus

00:03:15,099 --> 00:03:22,260
thinking ah that's my worst nightmare

00:03:18,190 --> 00:03:25,299
that is the job I absolutely do not want

00:03:22,260 --> 00:03:27,310
the thing is what they if I can

00:03:25,299 --> 00:03:28,569
characterize bureaucratic corporation

00:03:27,310 --> 00:03:31,480
which is of course a figment of my

00:03:28,569 --> 00:03:35,530
imagination doesn't actually exist but

00:03:31,480 --> 00:03:37,900
this this company I know that they have

00:03:35,530 --> 00:03:38,720
this group of architects who don't write

00:03:37,900 --> 00:03:40,790
code any

00:03:38,720 --> 00:03:44,120
and they make all the decisions about

00:03:40,790 --> 00:03:46,040
what tools you're allowed to use so if

00:03:44,120 --> 00:03:48,049
it's not on their approved list you

00:03:46,040 --> 00:03:50,510
can't have it in fact you can't even

00:03:48,049 --> 00:03:51,860
download it because the machine is

00:03:50,510 --> 00:03:53,000
totally locked down and you can't

00:03:51,860 --> 00:03:55,879
install anything that they haven't

00:03:53,000 --> 00:03:58,069
approved so basically this company is

00:03:55,879 --> 00:04:02,810
pretty much guaranteed to use only

00:03:58,069 --> 00:04:04,129
zombie technologies so so when I'm

00:04:02,810 --> 00:04:09,200
talking about whether I'll be able to

00:04:04,129 --> 00:04:10,970
get a job in 2024 I'm really saying will

00:04:09,200 --> 00:04:14,030
I be able to get a job I actually want

00:04:10,970 --> 00:04:16,100
will I only be able to get a job where

00:04:14,030 --> 00:04:19,780
everyone is a technology laggard laggard

00:04:16,100 --> 00:04:22,280
I don't want to work there so is

00:04:19,780 --> 00:04:26,389
test-driven development going to be very

00:04:22,280 --> 00:04:29,000
important to get a good job in 2024 well

00:04:26,389 --> 00:04:31,520
I noticed them another commentator Allen

00:04:29,000 --> 00:04:34,010
Kelly made this prediction already and

00:04:31,520 --> 00:04:36,500
in fact he said by 2022 that it will be

00:04:34,010 --> 00:04:38,600
the case that programmers who don't

00:04:36,500 --> 00:04:41,840
practice test driven development will be

00:04:38,600 --> 00:04:44,030
unemployable it will not be acceptable

00:04:41,840 --> 00:04:47,720
to question TDD or claim that it is

00:04:44,030 --> 00:04:49,520
unproven and if you can't use TDD in a

00:04:47,720 --> 00:04:52,340
job interview exercise you will not get

00:04:49,520 --> 00:04:54,830
the job so I thought this was this was

00:04:52,340 --> 00:04:57,260
fairly stern stuff to be honest I mean I

00:04:54,830 --> 00:04:59,360
I'm a bit of a fan of TDD as you may

00:04:57,260 --> 00:05:01,910
have gathered but I thought is this

00:04:59,360 --> 00:05:04,760
right could it be that TDD is going to

00:05:01,910 --> 00:05:08,750
be absolutely ubiquitous in less than 10

00:05:04,760 --> 00:05:12,710
years because I as I see it TDD is a

00:05:08,750 --> 00:05:15,380
disruptive technology and is subject to

00:05:12,710 --> 00:05:18,020
this problem of crossing the chasm it's

00:05:15,380 --> 00:05:20,240
and I think it's disruptive because it

00:05:18,020 --> 00:05:21,950
is a very profoundly different way to

00:05:20,240 --> 00:05:23,479
develop software compared with the way

00:05:21,950 --> 00:05:27,260
that most people have been doing it so

00:05:23,479 --> 00:05:29,419
far and at this point I think I need to

00:05:27,260 --> 00:05:32,120
probably define a little bit more

00:05:29,419 --> 00:05:34,910
closely what I mean by test-driven

00:05:32,120 --> 00:05:40,039
development so I'm going to go for a

00:05:34,910 --> 00:05:42,139
narrow definition here of TDD where you

00:05:40,039 --> 00:05:45,740
have to write a test to drive pretty

00:05:42,139 --> 00:05:47,270
much every line of production code the

00:05:45,740 --> 00:05:49,250
units that your tests are test

00:05:47,270 --> 00:05:51,910
thing are completely isolated and that

00:05:49,250 --> 00:05:55,040
might mean using mock objects and so on

00:05:51,910 --> 00:05:57,260
you do your design in in tiny increments

00:05:55,040 --> 00:06:00,170
you you build up the code very very

00:05:57,260 --> 00:06:02,150
gradually using a lot of refactoring to

00:06:00,170 --> 00:06:05,720
pull out the pull together the design

00:06:02,150 --> 00:06:07,370
and you end up with hundreds of tests

00:06:05,720 --> 00:06:10,090
that will run in less than a second and

00:06:07,370 --> 00:06:14,350
when they fail their pinpointing exactly

00:06:10,090 --> 00:06:18,500
where the failures lie so this is a very

00:06:14,350 --> 00:06:20,870
narrow definition of TDD and last but

00:06:18,500 --> 00:06:24,230
not least when you get this to work it

00:06:20,870 --> 00:06:28,430
feels so good you feel so free to

00:06:24,230 --> 00:06:30,170
develop and and be productive and this

00:06:28,430 --> 00:06:33,860
is the kind of TDD that you might have

00:06:30,170 --> 00:06:36,710
seen demonstrated by Kent Beck or Robert

00:06:33,860 --> 00:06:38,090
Martin or Kevin honey this is the kind

00:06:36,710 --> 00:06:42,950
of thing that gets shown at conferences

00:06:38,090 --> 00:06:46,190
in short demos and many developers do

00:06:42,950 --> 00:06:49,190
use this and I think if I look at this

00:06:46,190 --> 00:06:51,950
very narrow definition of TDD I see

00:06:49,190 --> 00:06:54,380
early adopters using this but I don't

00:06:51,950 --> 00:06:57,410
see the wide majority and mainstream

00:06:54,380 --> 00:07:00,530
developer developing this way most of

00:06:57,410 --> 00:07:03,320
the time so what about in ten years time

00:07:00,530 --> 00:07:05,450
I think I might need a bit of evidence

00:07:03,320 --> 00:07:08,240
to back up my placing this in the in the

00:07:05,450 --> 00:07:11,810
early adopters still and and I found a

00:07:08,240 --> 00:07:14,630
quote from Kent back in 2009 when he was

00:07:11,810 --> 00:07:16,670
developing j-unit max which is a tool

00:07:14,630 --> 00:07:18,530
which is only useful if you're really

00:07:16,670 --> 00:07:22,520
doing that kind of minute by minutes

00:07:18,530 --> 00:07:24,200
very tight feedback TDD and he decided

00:07:22,520 --> 00:07:25,970
to stop developing that tool at that

00:07:24,200 --> 00:07:29,390
point because he estimated the global

00:07:25,970 --> 00:07:31,490
markets of Java programmers doing this

00:07:29,390 --> 00:07:33,950
kind of TDD was only a few thousand

00:07:31,490 --> 00:07:36,230
people so that mean that was five years

00:07:33,950 --> 00:07:38,510
ago but I still see this this kind of

00:07:36,230 --> 00:07:42,770
very narrow kind of TDD is not being

00:07:38,510 --> 00:07:45,070
very widespread so where are we going to

00:07:42,770 --> 00:07:47,590
be in ten years

00:07:45,070 --> 00:07:49,720
so this is another normal distribution

00:07:47,590 --> 00:07:51,270
which I found a picture of on the web

00:07:49,720 --> 00:07:53,620
which I thought was kind of interesting

00:07:51,270 --> 00:07:55,450
if you're color blind you might not be

00:07:53,620 --> 00:07:58,360
able to see the amount of women on this

00:07:55,450 --> 00:08:01,060
graph but I assure you that's that's the

00:07:58,360 --> 00:08:04,930
problem for the rest of us too but

00:08:01,060 --> 00:08:06,760
anyway I was at a conference it wasn't

00:08:04,930 --> 00:08:08,890
in the US actually it was in Europe but

00:08:06,760 --> 00:08:10,900
the the distribution of people at the

00:08:08,890 --> 00:08:13,840
conference I'm afraid was fairly similar

00:08:10,900 --> 00:08:15,040
and I was chatting with this guy and he

00:08:13,840 --> 00:08:16,120
was really interesting and he was

00:08:15,040 --> 00:08:19,900
talking about all these cool

00:08:16,120 --> 00:08:23,890
technologies and and Staffan I happened

00:08:19,900 --> 00:08:28,810
to glance down at his feet and I was a

00:08:23,890 --> 00:08:30,310
bit surprised at his shoes thinking at

00:08:28,810 --> 00:08:32,800
this point I'd actually never really

00:08:30,310 --> 00:08:34,000
seen a pair of shoes like this before I

00:08:32,800 --> 00:08:37,000
don't have you seen them with little

00:08:34,000 --> 00:08:39,550
toes they look quite odd so I asked him

00:08:37,000 --> 00:08:41,680
of course about the shoes and it turns

00:08:39,550 --> 00:08:43,750
out that he wasn't just an early adopter

00:08:41,680 --> 00:08:46,810
of all kinds of programming technologies

00:08:43,750 --> 00:08:48,730
he was also an early adopter of running

00:08:46,810 --> 00:08:52,240
shoe technology this is a pair of

00:08:48,730 --> 00:08:55,000
advanced running shoes as so the thing

00:08:52,240 --> 00:08:57,610
is at the time I was running around when

00:08:55,000 --> 00:08:59,140
I go jogging in a pair of shoes like the

00:08:57,610 --> 00:09:02,590
one on the right here with a really

00:08:59,140 --> 00:09:04,270
thick sole and the short persistent when

00:09:02,590 --> 00:09:05,890
I bought them assured me that this was

00:09:04,270 --> 00:09:09,190
the best kind of running shoe and it was

00:09:05,890 --> 00:09:10,720
gonna correct my pronation and and my

00:09:09,190 --> 00:09:13,720
running style and it was gonna be

00:09:10,720 --> 00:09:15,900
preventing injury and be great and then

00:09:13,720 --> 00:09:18,610
this guy I met had a pair of these

00:09:15,900 --> 00:09:21,250
minimal Fivefinger shoes which are

00:09:18,610 --> 00:09:23,230
completely different and he was clearly

00:09:21,250 --> 00:09:26,530
a an early adopter of this and he

00:09:23,230 --> 00:09:28,900
explained in with great enthusiasm all

00:09:26,530 --> 00:09:30,580
the benefits of these shoes so he was

00:09:28,900 --> 00:09:32,770
like saying oh it's got no padding on

00:09:30,580 --> 00:09:35,410
the heel whatsoever and that's a good

00:09:32,770 --> 00:09:37,570
thing because it changes the way you run

00:09:35,410 --> 00:09:39,490
and mix you don't shock your knees and

00:09:37,570 --> 00:09:41,500
it's got this really thin sole so you

00:09:39,490 --> 00:09:44,380
can feel what you're running on and

00:09:41,500 --> 00:09:45,790
adapt your stride your toes can spread

00:09:44,380 --> 00:09:48,370
out because they've each got their own

00:09:45,790 --> 00:09:50,530
little toe and gives you better lift off

00:09:48,370 --> 00:09:54,490
they're really light then slow you down

00:09:50,530 --> 00:09:57,630
and of course the killer feature people

00:09:54,490 --> 00:09:57,630
will stare at your feet

00:09:58,060 --> 00:10:04,250
so this is what it's about for an early

00:10:01,580 --> 00:10:05,690
adopter so I listen to all this and I

00:10:04,250 --> 00:10:07,760
did some research on the internet and I

00:10:05,690 --> 00:10:10,940
became convinced so of course I brought

00:10:07,760 --> 00:10:13,580
some new running shoes I'm an early

00:10:10,940 --> 00:10:16,550
adopter right so I was really happy with

00:10:13,580 --> 00:10:20,240
this pair of shoes and I but I had to

00:10:16,550 --> 00:10:21,980
learn how to run again to some extent so

00:10:20,240 --> 00:10:25,130
I had to start going on really quite

00:10:21,980 --> 00:10:27,080
short runs to adapt my stride to these

00:10:25,130 --> 00:10:28,700
new shoes because I was used to the the

00:10:27,080 --> 00:10:30,860
kind of the guy on the left you see this

00:10:28,700 --> 00:10:32,899
about to strike the ground with his heel

00:10:30,860 --> 00:10:34,430
first and when you've got these really

00:10:32,899 --> 00:10:36,890
thick soles on your running shoes that

00:10:34,430 --> 00:10:38,990
feels really really good I was doing

00:10:36,890 --> 00:10:40,550
that before but with these really thin

00:10:38,990 --> 00:10:42,050
shoes you have to run like the guy on

00:10:40,550 --> 00:10:44,450
the right you have to put the whole foot

00:10:42,050 --> 00:10:47,180
down at once and this is a bit of a

00:10:44,450 --> 00:10:50,060
change of style it took you know a few

00:10:47,180 --> 00:10:51,920
weeks to get used to it but actually

00:10:50,060 --> 00:10:53,930
eventually when I I got used to the

00:10:51,920 --> 00:10:55,870
shoes I was really happy I was running

00:10:53,930 --> 00:10:58,520
around the forest and my usual route and

00:10:55,870 --> 00:11:00,440
enjoying the the light-footed nurse and

00:10:58,520 --> 00:11:04,870
be able to feel what I was running on

00:11:00,440 --> 00:11:08,750
and it was great thing is it didn't last

00:11:04,870 --> 00:11:10,820
after a few months I think well the

00:11:08,750 --> 00:11:15,370
technical term for it I think is um

00:11:10,820 --> 00:11:15,370
autumn Swedish autumn

00:11:16,040 --> 00:11:21,240
it turns out that when your shoes are

00:11:19,620 --> 00:11:24,600
practically invisible and it just

00:11:21,240 --> 00:11:26,840
consists of very light fabric separating

00:11:24,600 --> 00:11:31,580
every toe into a kind of a waterlogged

00:11:26,840 --> 00:11:34,110
toe mass you get really cold feet

00:11:31,580 --> 00:11:36,150
and this was really difficult running

00:11:34,110 --> 00:11:40,350
around my forest track in Swedish autumn

00:11:36,150 --> 00:11:42,330
having freezing toes so so what do i do

00:11:40,350 --> 00:11:43,800
of course like I looked at the internet

00:11:42,330 --> 00:11:46,440
and I do some research and I find the

00:11:43,800 --> 00:11:50,550
latest cool technology and I buy some

00:11:46,440 --> 00:11:52,560
new running shoes so here I am with my

00:11:50,550 --> 00:11:55,320
my new running shoes that have no heel

00:11:52,560 --> 00:11:57,030
padding they have a thin sole my toes

00:11:55,320 --> 00:11:58,950
can still spread out although that

00:11:57,030 --> 00:12:01,460
there's actually no separated toes on

00:11:58,950 --> 00:12:05,910
these ones they're still really light

00:12:01,460 --> 00:12:08,340
and of course they are waterproof so

00:12:05,910 --> 00:12:10,380
this is the the killer feature for

00:12:08,340 --> 00:12:13,200
Swedish awesome running but

00:12:10,380 --> 00:12:19,220
unfortunately people no longer stared at

00:12:13,200 --> 00:12:22,650
my feet so this is a story about

00:12:19,220 --> 00:12:24,660
disruptive technology adoption and my

00:12:22,650 --> 00:12:27,330
points from this is basically two points

00:12:24,660 --> 00:12:29,580
early adopters do like to stick out and

00:12:27,330 --> 00:12:32,550
have people ask them about what's that

00:12:29,580 --> 00:12:34,920
cool thing you've got there and early

00:12:32,550 --> 00:12:36,990
adopters will also try out this new

00:12:34,920 --> 00:12:38,730
technology without very much proof that

00:12:36,990 --> 00:12:40,170
it has any advantage I mean I just took

00:12:38,730 --> 00:12:45,600
this guy's word for it really and some

00:12:40,170 --> 00:12:47,190
guys on the internet look cool so when

00:12:45,600 --> 00:12:50,340
you're looking at a technology going to

00:12:47,190 --> 00:12:52,470
the mainstream they actually a little

00:12:50,340 --> 00:12:54,990
bit more conservative probably don't

00:12:52,470 --> 00:12:56,460
want to stick out quite so much and they

00:12:54,990 --> 00:12:58,740
probably want a little bit more proof

00:12:56,460 --> 00:13:03,210
that there is actually Vantage in this

00:12:58,740 --> 00:13:04,530
technology before that's right so now I

00:13:03,210 --> 00:13:07,380
want to relate this to test-driven

00:13:04,530 --> 00:13:08,730
development because I of course I was an

00:13:07,380 --> 00:13:11,220
early adopter of test-driven development

00:13:08,730 --> 00:13:14,370
and I remember this this feeling of

00:13:11,220 --> 00:13:16,290
enjoying sticking out because I wanted

00:13:14,370 --> 00:13:18,360
to relate an incident where I was

00:13:16,290 --> 00:13:20,670
sitting coding and a guy comes to ask me

00:13:18,360 --> 00:13:22,940
something he's from the next team and he

00:13:20,670 --> 00:13:22,940
says

00:13:23,340 --> 00:13:27,870
ask me something and then he looks at my

00:13:24,840 --> 00:13:30,780
screen and he does a double take are you

00:13:27,870 --> 00:13:32,490
doing test German developments I've

00:13:30,780 --> 00:13:36,650
never seen anyone do that in production

00:13:32,490 --> 00:13:36,650
code but you mind if I watch

00:13:37,160 --> 00:13:45,270
okay so test-driven development is I

00:13:42,450 --> 00:13:47,850
think disruptive technology and I think

00:13:45,270 --> 00:13:50,520
to reach the mainstream these more

00:13:47,850 --> 00:13:53,340
conservative types it might need to

00:13:50,520 --> 00:13:54,990
adapt slightly become more practical the

00:13:53,340 --> 00:13:57,570
equivalents of losing the toes on the

00:13:54,990 --> 00:14:00,210
shoes but it has to do that without

00:13:57,570 --> 00:14:04,160
losing the essential benefits all the

00:14:00,210 --> 00:14:06,270
other things that we need TDD for and

00:14:04,160 --> 00:14:08,820
just like you want to keep the thin

00:14:06,270 --> 00:14:10,350
soles but maybe the toes were not the

00:14:08,820 --> 00:14:13,110
chrétien most crucial feature that was

00:14:10,350 --> 00:14:15,350
just that was just helping them to stick

00:14:13,110 --> 00:14:19,740
out and drive early adopters to use it

00:14:15,350 --> 00:14:21,570
so when I'm looking at TDD I think there

00:14:19,740 --> 00:14:22,860
are some very essential benefits to it

00:14:21,570 --> 00:14:26,280
when you're doing this narrow definition

00:14:22,860 --> 00:14:28,830
of TDD you get a lot of feedback from

00:14:26,280 --> 00:14:30,750
the tests on the design and how the

00:14:28,830 --> 00:14:35,070
design is is progressing are you

00:14:30,750 --> 00:14:39,660
managing to have isolated units are you

00:14:35,070 --> 00:14:41,700
managing to have a decoupled design you

00:14:39,660 --> 00:14:44,190
also get this effective self testing

00:14:41,700 --> 00:14:45,870
code that that is code that where you

00:14:44,190 --> 00:14:49,260
can push a button and it will check that

00:14:45,870 --> 00:14:51,330
it's it's still working but it will run

00:14:49,260 --> 00:14:52,860
itself tests and give you that feedback

00:14:51,330 --> 00:14:55,020
about whether you've broken it and

00:14:52,860 --> 00:14:58,860
that's what you need to enable you to

00:14:55,020 --> 00:15:00,990
refactor that code and of course as I

00:14:58,860 --> 00:15:03,420
mentioned before TDD feels really good

00:15:00,990 --> 00:15:06,030
you feel ready productive when you get

00:15:03,420 --> 00:15:08,520
into that state of just concentrating

00:15:06,030 --> 00:15:10,680
first on writing the tests I've gotten

00:15:08,520 --> 00:15:12,120
all my attention on that and then I get

00:15:10,680 --> 00:15:14,550
to write the implementation all my

00:15:12,120 --> 00:15:18,260
brainpower is just focused on how to do

00:15:14,550 --> 00:15:22,740
it what I want to do how I should do it

00:15:18,260 --> 00:15:25,560
so this this kind of essential benefits

00:15:22,740 --> 00:15:28,140
of TDD I'm not sure how many people

00:15:25,560 --> 00:15:30,360
really have experienced TDD in the

00:15:28,140 --> 00:15:32,520
narrower sense and I would encourage you

00:15:30,360 --> 00:15:33,980
that you could it wouldn't take you very

00:15:32,520 --> 00:15:37,430
long practicing a code

00:15:33,980 --> 00:15:39,830
cutter to experience this now I should

00:15:37,430 --> 00:15:42,800
explain a code cutter this is an idea

00:15:39,830 --> 00:15:45,110
that Dave Thomas came up with watching

00:15:42,800 --> 00:15:47,210
his son doing karate where he was

00:15:45,110 --> 00:15:49,160
practicing these canta exercises where

00:15:47,210 --> 00:15:51,140
you take a sequence of moves that you

00:15:49,160 --> 00:15:54,380
repeat until you can do them flawlessly

00:15:51,140 --> 00:15:56,210
and this puts those moves into your

00:15:54,380 --> 00:15:58,940
muscle memory so that when you're

00:15:56,210 --> 00:16:01,520
sparring in a more random situation

00:15:58,940 --> 00:16:08,120
these moves are just come naturally and

00:16:01,520 --> 00:16:09,680
you can do spa better so here like in

00:16:08,120 --> 00:16:12,050
this well encoding perhaps we could do

00:16:09,680 --> 00:16:13,760
small coding problems and repeat them

00:16:12,050 --> 00:16:16,670
until we could do them flawlessly and

00:16:13,760 --> 00:16:18,200
then those moves of test chip and

00:16:16,670 --> 00:16:23,300
development would would come naturally

00:16:18,200 --> 00:16:25,940
in a more production code situation so

00:16:23,300 --> 00:16:28,540
an example of a code calf - which I've

00:16:25,940 --> 00:16:31,250
done a bit is this is a very simple one

00:16:28,540 --> 00:16:32,750
write a function that returns true or

00:16:31,250 --> 00:16:35,540
false depending on whether the input

00:16:32,750 --> 00:16:37,340
integer is a leap year or not and a leap

00:16:35,540 --> 00:16:39,320
year is divisible by four but not

00:16:37,340 --> 00:16:42,500
otherwise divisible by 100 and less also

00:16:39,320 --> 00:16:44,990
visible by 400mm there's a rule you have

00:16:42,500 --> 00:16:47,360
to code it helpfully it comes with

00:16:44,990 --> 00:16:51,110
examples and these examples your test

00:16:47,360 --> 00:16:54,140
cases so this for a beginner at TDD this

00:16:51,110 --> 00:16:57,770
is very very easy to unction to write in

00:16:54,140 --> 00:17:00,230
FF any programmer really but you should

00:16:57,770 --> 00:17:04,070
be able to write this with TDD there are

00:17:00,230 --> 00:17:10,550
your test cases one by one and get how

00:17:04,070 --> 00:17:12,250
that loop feels how how are the I want

00:17:10,550 --> 00:17:16,010
you to feel that freedom and

00:17:12,250 --> 00:17:19,190
productivity and this this is a very

00:17:16,010 --> 00:17:21,530
simple code Carter it will teach you how

00:17:19,190 --> 00:17:24,050
to test drive a simple function that

00:17:21,530 --> 00:17:25,550
returns a boolean and then of course you

00:17:24,050 --> 00:17:27,080
need to probably do another Carter which

00:17:25,550 --> 00:17:30,020
would help you to learn to test driver

00:17:27,080 --> 00:17:34,040
you know more complex function Nora or

00:17:30,020 --> 00:17:36,710
class some cooperating classes so

00:17:34,040 --> 00:17:39,800
there's there's easier and harder ones

00:17:36,710 --> 00:17:43,790
of these but they will help you to

00:17:39,800 --> 00:17:45,390
experience TDD in ideal conditions TDD

00:17:43,790 --> 00:17:47,760
when it's really working

00:17:45,390 --> 00:17:51,600
running show shoes with toes and the

00:17:47,760 --> 00:17:55,440
Swedish summer when it really works so

00:17:51,600 --> 00:17:57,740
this is a great idea but of course you

00:17:55,440 --> 00:18:00,900
have doing a code Carter by yourself

00:17:57,740 --> 00:18:02,549
it's not half as much fun as getting

00:18:00,900 --> 00:18:05,309
together with others in a coding dojo

00:18:02,549 --> 00:18:07,049
just like in karate you go to the dojo

00:18:05,309 --> 00:18:09,900
and you practice your karate with other

00:18:07,049 --> 00:18:11,730
people you go to the coding dojo to

00:18:09,900 --> 00:18:14,309
learn about coding in a group and it's

00:18:11,730 --> 00:18:17,190
much more fun it's these two French guys

00:18:14,309 --> 00:18:19,400
who came up with the idea so it's

00:18:17,190 --> 00:18:20,549
basically you try and do this fairly

00:18:19,400 --> 00:18:22,679
semi-regularly

00:18:20,549 --> 00:18:25,230
and you get together maybe your team

00:18:22,679 --> 00:18:27,030
from work or or your Python user group

00:18:25,230 --> 00:18:29,580
in your town or maybe at a conference

00:18:27,030 --> 00:18:31,860
just some random people and of course

00:18:29,580 --> 00:18:34,410
you you write some code you do some code

00:18:31,860 --> 00:18:37,320
carters your practice TDD you

00:18:34,410 --> 00:18:40,590
collaborate discuss get feedback and it

00:18:37,320 --> 00:18:43,049
can be it can be really fun and I don't

00:18:40,590 --> 00:18:45,929
actually want to go into a lot of detail

00:18:43,049 --> 00:18:50,299
now about the coding dojo I've written a

00:18:45,929 --> 00:18:52,919
book that Holger mentioned that some

00:18:50,299 --> 00:18:55,320
enumerates exactly what is different

00:18:52,919 --> 00:18:57,450
about a coding dojo compared with any

00:18:55,320 --> 00:19:00,210
other kind of meeting where coders get

00:18:57,450 --> 00:19:03,330
together and hack which is also fun but

00:19:00,210 --> 00:19:05,790
it's a little different but one thing I

00:19:03,330 --> 00:19:09,000
wanted to pick out is the way that you

00:19:05,790 --> 00:19:10,350
could use a tool to help you to get

00:19:09,000 --> 00:19:11,970
feedback you've got the people at the

00:19:10,350 --> 00:19:14,400
dojo giving you feedback on how well

00:19:11,970 --> 00:19:17,610
you're doing TDD but you can also get a

00:19:14,400 --> 00:19:20,210
tool like cyber dojo this actually every

00:19:17,610 --> 00:19:25,049
time you run the tests it records and

00:19:20,210 --> 00:19:26,549
whether they passed Green failed red or

00:19:25,049 --> 00:19:29,520
there was a syntax error and it couldn't

00:19:26,549 --> 00:19:31,620
actually execute the tests and then you

00:19:29,520 --> 00:19:33,450
can see how often you're running the

00:19:31,620 --> 00:19:37,380
tests and whether you can see those

00:19:33,450 --> 00:19:39,750
cycles to DD cycles and you see this

00:19:37,380 --> 00:19:41,910
this is a bit irregular and there's not

00:19:39,750 --> 00:19:43,650
very clear cycles but after you you know

00:19:41,910 --> 00:19:45,630
this is example of a real pair this is

00:19:43,650 --> 00:19:47,700
not me this is some beginners I had in

00:19:45,630 --> 00:19:49,950
one of my coding dojos and then after

00:19:47,700 --> 00:19:53,070
six dojo is a similar pair and you can

00:19:49,950 --> 00:19:54,559
see that it's changed they running the

00:19:53,070 --> 00:19:57,320
tests more often

00:19:54,559 --> 00:20:00,740
a lot more green and you can start to

00:19:57,320 --> 00:20:02,899
see those cycles so that's something

00:20:00,740 --> 00:20:05,830
that you can do to fight you know get

00:20:02,899 --> 00:20:08,870
some extra feedback am i doing TDD now

00:20:05,830 --> 00:20:10,429
do I understand the essential benefits

00:20:08,870 --> 00:20:13,460
of it because that's really what I want

00:20:10,429 --> 00:20:16,700
you to know when to experience what TD

00:20:13,460 --> 00:20:19,309
tdd feels like when it's working and to

00:20:16,700 --> 00:20:20,990
be able to recognize problems suited to

00:20:19,309 --> 00:20:24,080
it so when you are like working in your

00:20:20,990 --> 00:20:25,639
production code and you realize oh I've

00:20:24,080 --> 00:20:27,950
got to write a function that's going to

00:20:25,639 --> 00:20:30,799
return a boolean I know how to test

00:20:27,950 --> 00:20:33,769
drive one of those and this gives you

00:20:30,799 --> 00:20:39,649
the tools you need to in your production

00:20:33,769 --> 00:20:42,350
code and then you'll recognize how to

00:20:39,649 --> 00:20:44,539
adapt TDD to your local conditions

00:20:42,350 --> 00:20:46,909
because this kind of TDD in the

00:20:44,539 --> 00:20:48,860
narrowest sense I think actually is only

00:20:46,909 --> 00:20:53,119
really appropriate in quite narrow

00:20:48,860 --> 00:20:54,649
conditions where and then actually in

00:20:53,119 --> 00:20:57,320
production a lot of production code this

00:20:54,649 --> 00:21:01,249
is really quite hard to do and you can

00:20:57,320 --> 00:21:04,159
end up in a lot really writing some very

00:21:01,249 --> 00:21:05,779
bad tests and so I think you need to be

00:21:04,159 --> 00:21:07,309
able to adapt your local conditions and

00:21:05,779 --> 00:21:08,869
that might be your you've got a web

00:21:07,309 --> 00:21:10,820
layer you've got databases you've got

00:21:08,869 --> 00:21:12,980
widgets and gooeys and rich clients and

00:21:10,820 --> 00:21:16,669
asynchronous code and everything else

00:21:12,980 --> 00:21:20,720
where it gets harder to do this kind of

00:21:16,669 --> 00:21:22,490
pure TDD so I start thinking about TDD

00:21:20,720 --> 00:21:23,749
in a much more general sense of well

00:21:22,490 --> 00:21:26,809
actually what what are the essential

00:21:23,749 --> 00:21:27,919
parts of it it's it's um working you've

00:21:26,809 --> 00:21:29,779
got to retain that feeling of

00:21:27,919 --> 00:21:31,549
productivity that's kind of essential

00:21:29,779 --> 00:21:33,860
you've got to learn to work

00:21:31,549 --> 00:21:35,299
incrementally that's sir one of the big

00:21:33,860 --> 00:21:38,360
parts of it and incrementally might not

00:21:35,299 --> 00:21:41,419
be quite such small steps as in the

00:21:38,360 --> 00:21:43,610
narrow version of TDD it's important to

00:21:41,419 --> 00:21:45,529
have testable units but they might not

00:21:43,610 --> 00:21:49,970
be quite as small and isolated as in

00:21:45,529 --> 00:21:52,159
that really pure TDD you need to think

00:21:49,970 --> 00:21:55,149
about designing api's separately from

00:21:52,159 --> 00:21:57,440
designing the implementations and

00:21:55,149 --> 00:21:59,809
probably beforehand but maybe not quite

00:21:57,440 --> 00:22:03,019
maybe not unit tests I don't maybe more

00:21:59,809 --> 00:22:04,020
more granular tests and this idea of

00:22:03,019 --> 00:22:06,660
self testing code

00:22:04,020 --> 00:22:08,490
having code that you can ask it do all

00:22:06,660 --> 00:22:11,880
the tests pass after my latest change

00:22:08,490 --> 00:22:15,180
and you can have self testing code

00:22:11,880 --> 00:22:16,500
without those tests being fast enough to

00:22:15,180 --> 00:22:19,080
run in that really tight

00:22:16,500 --> 00:22:21,360
minute-by-minute loop and that can still

00:22:19,080 --> 00:22:24,090
be really useful even if your test take

00:22:21,360 --> 00:22:26,220
10 minutes or an hour or overnight it's

00:22:24,090 --> 00:22:31,290
its test self testing code and that is

00:22:26,220 --> 00:22:34,230
worth something so I kind of wanted to

00:22:31,290 --> 00:22:35,670
go to talk about not just this narrow

00:22:34,230 --> 00:22:37,860
definition of TDD but what are the

00:22:35,670 --> 00:22:41,370
essential benefits that you can get

00:22:37,860 --> 00:22:43,980
without actually doing that bang on and

00:22:41,370 --> 00:22:45,840
then I got a plug Harry's book here

00:22:43,980 --> 00:22:47,580
because I've been reviewing this book

00:22:45,840 --> 00:22:50,850
test-driven development with Python and

00:22:47,580 --> 00:22:53,550
he's done a good job I think of showing

00:22:50,850 --> 00:22:56,040
you demonstrating with a lot of code how

00:22:53,550 --> 00:22:58,410
to do TDD when your local conditions are

00:22:56,040 --> 00:23:02,570
Django and you've got JavaScript and all

00:22:58,410 --> 00:23:05,430
of that stuff so I I do recommend that

00:23:02,570 --> 00:23:07,890
then I wanted to take this is that

00:23:05,430 --> 00:23:11,370
further what if your conditions are not

00:23:07,890 --> 00:23:14,340
just Swedish autumn what if we talking

00:23:11,370 --> 00:23:16,920
winter and I'm looking at my running

00:23:14,340 --> 00:23:20,910
track and thinking oh my cross-country

00:23:16,920 --> 00:23:23,640
skis this is a much better idea is there

00:23:20,910 --> 00:23:26,100
a situations where TDD just isn't the

00:23:23,640 --> 00:23:30,300
right approach because I think there are

00:23:26,100 --> 00:23:31,530
some areas where TDD just doesn't really

00:23:30,300 --> 00:23:34,050
do it for me

00:23:31,530 --> 00:23:37,260
and and I've got three of them here I

00:23:34,050 --> 00:23:39,510
wanted to talk about the first one is

00:23:37,260 --> 00:23:41,040
the problem of requirements I don't

00:23:39,510 --> 00:23:42,900
actually know what the user needs I

00:23:41,040 --> 00:23:44,460
could write a bunch of tests expressing

00:23:42,900 --> 00:23:48,210
what I think they need but I don't

00:23:44,460 --> 00:23:50,010
actually know or I could write the tests

00:23:48,210 --> 00:23:54,360
but I have no idea how to implement this

00:23:50,010 --> 00:23:56,520
or I've got some spaghetti legacy code

00:23:54,360 --> 00:23:58,020
with no tests how do I do that

00:23:56,520 --> 00:24:02,100
so these three problems I'm just going

00:23:58,020 --> 00:24:04,020
to look at a bit more so this problem of

00:24:02,100 --> 00:24:06,420
of requirements I've I've built this

00:24:04,020 --> 00:24:08,700
beautiful teapot that I think is exactly

00:24:06,420 --> 00:24:12,810
what the user needs unfortunately I made

00:24:08,700 --> 00:24:13,740
it with chocolate and it doesn't work so

00:24:12,810 --> 00:24:15,330
this is the

00:24:13,740 --> 00:24:17,010
I've not known what the user actually

00:24:15,330 --> 00:24:19,080
needs and this is only a problem if you

00:24:17,010 --> 00:24:20,580
are not actually the user yourself so a

00:24:19,080 --> 00:24:21,410
lot of commercial software falls into

00:24:20,580 --> 00:24:27,600
this category

00:24:21,410 --> 00:24:29,790
so the TDD loop here with unit tests has

00:24:27,600 --> 00:24:32,040
been some people have suggested really

00:24:29,790 --> 00:24:35,760
for a long time that you should augment

00:24:32,040 --> 00:24:38,100
this with a failing acceptance test so

00:24:35,760 --> 00:24:39,840
this inner loop is you go around on the

00:24:38,100 --> 00:24:43,110
normal you know minute by minutes coding

00:24:39,840 --> 00:24:46,200
activity and this outer loop is the

00:24:43,110 --> 00:24:48,870
scale of hours or days to get a whole

00:24:46,200 --> 00:24:51,809
feature working and that test passes

00:24:48,870 --> 00:24:53,670
when the whole feature works so the

00:24:51,809 --> 00:24:55,710
point with these acceptance tests is

00:24:53,670 --> 00:24:59,100
that you can't write them in isolation

00:24:55,710 --> 00:25:02,550
of the users or at least somebody who

00:24:59,100 --> 00:25:05,190
has talked to the users you have to talk

00:25:02,550 --> 00:25:07,470
to somebody else and there are various

00:25:05,190 --> 00:25:09,179
methods behavior driven development is

00:25:07,470 --> 00:25:10,650
the one I've got here with the three

00:25:09,179 --> 00:25:12,870
amigos discussions or you've got

00:25:10,650 --> 00:25:14,700
specification by example or you've got

00:25:12,870 --> 00:25:17,100
and just acceptance test-driven

00:25:14,700 --> 00:25:19,170
development these are all ways to extend

00:25:17,100 --> 00:25:21,420
TDD to not just be a thing that

00:25:19,170 --> 00:25:25,500
developers do but a thing that teams do

00:25:21,420 --> 00:25:28,050
and I think that's kind of useful when

00:25:25,500 --> 00:25:29,250
the user is not the same as yourself so

00:25:28,050 --> 00:25:32,280
when I look at although these are all

00:25:29,250 --> 00:25:34,920
the the benefits of TDD that I put up

00:25:32,280 --> 00:25:36,360
before and I think double loop TDD has

00:25:34,920 --> 00:25:39,059
all the same benefits because you're

00:25:36,360 --> 00:25:41,040
fundamentally doing TDD at the inner

00:25:39,059 --> 00:25:42,929
level but if you have the additional

00:25:41,040 --> 00:25:46,260
benefit to you you're hopefully building

00:25:42,929 --> 00:25:51,030
something the user needs so this is a

00:25:46,260 --> 00:25:55,230
useful extension to TDD the next

00:25:51,030 --> 00:25:57,870
situation I had was when you realize you

00:25:55,230 --> 00:26:00,090
have no idea how to implement this and

00:25:57,870 --> 00:26:03,510
I've put up a Sudoku board here because

00:26:00,090 --> 00:26:05,460
there's a very famous example of but Ron

00:26:03,510 --> 00:26:07,590
Jeffries one of the originators of

00:26:05,460 --> 00:26:09,750
extreme programming wrote some articles

00:26:07,590 --> 00:26:12,300
in his blog where he was showing how he

00:26:09,750 --> 00:26:15,510
was going to test drive a solution a

00:26:12,300 --> 00:26:18,750
Sudoku solver and he writes several

00:26:15,510 --> 00:26:21,450
articles and he writes lots of tests but

00:26:18,750 --> 00:26:23,100
the code is just know where this is he's

00:26:21,450 --> 00:26:24,720
getting nowhere solving this problem he

00:26:23,100 --> 00:26:25,510
clearly has no idea how to solve this

00:26:24,720 --> 00:26:27,490
problem

00:26:25,510 --> 00:26:28,990
or at least if he does he hasn't done a

00:26:27,490 --> 00:26:31,390
very good job of showing it

00:26:28,990 --> 00:26:33,940
and then there's this other example of

00:26:31,390 --> 00:26:36,610
Peter Norvig doing a sodoku solve in

00:26:33,940 --> 00:26:38,560
Python and if the code is absolutely

00:26:36,610 --> 00:26:41,070
beautiful I don't if you've seen it but

00:26:38,560 --> 00:26:43,630
it's really spot-on and he's using

00:26:41,070 --> 00:26:46,000
concepts like constraint propagation and

00:26:43,630 --> 00:26:47,950
backtracking search he understands the

00:26:46,000 --> 00:26:50,380
computer science of this and he does a

00:26:47,950 --> 00:26:53,710
really good job without test-driven

00:26:50,380 --> 00:26:55,620
development so the point is really if

00:26:53,710 --> 00:26:57,850
you don't know how to solve the problem

00:26:55,620 --> 00:27:00,910
TDD is not going to lead you to the

00:26:57,850 --> 00:27:02,650
solution I don't I in my opinion you

00:27:00,910 --> 00:27:03,940
need to probably go and find somebody

00:27:02,650 --> 00:27:06,520
who knows how to solve this kind of a

00:27:03,940 --> 00:27:11,650
problem and get some training or or

00:27:06,520 --> 00:27:13,360
mentoring research on the Internet but

00:27:11,650 --> 00:27:14,710
one of the concepts that's in XP from

00:27:13,360 --> 00:27:17,230
the start which I think Ron Jeffries

00:27:14,710 --> 00:27:20,790
should have known about is the spike

00:27:17,230 --> 00:27:23,980
solution now this is the by analogy with

00:27:20,790 --> 00:27:25,330
woodworking if you've got a piece of

00:27:23,980 --> 00:27:26,620
wood that you've is a kind that you've

00:27:25,330 --> 00:27:28,930
never worked with before you don't

00:27:26,620 --> 00:27:30,880
really understand you just get a spike

00:27:28,930 --> 00:27:33,160
and you stop hammering at the wood and

00:27:30,880 --> 00:27:35,680
playing with it and trying to understand

00:27:33,160 --> 00:27:37,360
how this piece of wood works and then

00:27:35,680 --> 00:27:38,620
you put that bit to one side and you

00:27:37,360 --> 00:27:40,690
take some more of this wood and you

00:27:38,620 --> 00:27:43,180
build your your cabinet once you've

00:27:40,690 --> 00:27:45,220
learnt how the thing works so this is in

00:27:43,180 --> 00:27:46,510
the same way with code if you if you've

00:27:45,220 --> 00:27:49,410
never built something like this before

00:27:46,510 --> 00:27:54,070
don't try and do test-driven development

00:27:49,410 --> 00:27:56,770
just hack about play with things try out

00:27:54,070 --> 00:28:00,010
algorithms and and just get to know your

00:27:56,770 --> 00:28:01,900
tools and when you know enough to build

00:28:00,010 --> 00:28:05,410
the thing properly put what you've

00:28:01,900 --> 00:28:08,110
hacked together to one side start over

00:28:05,410 --> 00:28:12,640
and then start doing TDD so that's the

00:28:08,110 --> 00:28:15,910
classic TDD and XP approach more

00:28:12,640 --> 00:28:18,010
recently some guy Dan North and Liz

00:28:15,910 --> 00:28:22,450
Keogh and others have been talking about

00:28:18,010 --> 00:28:24,190
spike and stabilize so you start just as

00:28:22,450 --> 00:28:26,350
with a spike solution and you get to

00:28:24,190 --> 00:28:28,390
know your tools you try on algorithms

00:28:26,350 --> 00:28:30,460
you read up on backtracking search and

00:28:28,390 --> 00:28:34,090
constraint propagation and try and

00:28:30,460 --> 00:28:37,930
understand them but instead of then

00:28:34,090 --> 00:28:39,399
throwing away your work you refactor it

00:28:37,930 --> 00:28:41,679
into something that

00:28:39,399 --> 00:28:46,320
can be tested with with unit tests and

00:28:41,679 --> 00:28:48,399
add the tests so this is this is not

00:28:46,320 --> 00:28:50,049
test-driven development because you

00:28:48,399 --> 00:28:52,299
start from code that works and that

00:28:50,049 --> 00:28:54,609
tests afterwards so if you look at all

00:28:52,299 --> 00:28:57,099
the the essential benefits of TDD and

00:28:54,609 --> 00:28:59,320
you're getting most of them you're

00:28:57,099 --> 00:29:01,330
getting these testable units because you

00:28:59,320 --> 00:29:04,029
do write the tests eventually but you're

00:29:01,330 --> 00:29:07,989
not forced to design your IP with my API

00:29:04,029 --> 00:29:10,089
before your implementation so it's a

00:29:07,989 --> 00:29:11,619
different slightly different but of

00:29:10,089 --> 00:29:13,389
course it has this benefit that you

00:29:11,619 --> 00:29:20,320
might go faster and be more productive

00:29:13,389 --> 00:29:24,219
than if you started over from scratch so

00:29:20,320 --> 00:29:27,339
this is a spike and stabilize the third

00:29:24,219 --> 00:29:29,499
situation where a classic TDD maybe

00:29:27,339 --> 00:29:33,039
doesn't work so well that's when you

00:29:29,499 --> 00:29:35,679
have spaghetti code and you can't find

00:29:33,039 --> 00:29:37,899
any units to extract and write unit

00:29:35,679 --> 00:29:38,349
tests for and this is this is a hard

00:29:37,899 --> 00:29:41,049
problem

00:29:38,349 --> 00:29:44,080
and Michael feathers wrote this book so

00:29:41,049 --> 00:29:45,879
about a decade ago in fact and he has

00:29:44,080 --> 00:29:48,639
lots of helpful advice in this book

00:29:45,879 --> 00:29:51,639
about how to get this code under test

00:29:48,639 --> 00:29:54,279
when it doesn't have any the thing is

00:29:51,639 --> 00:29:56,049
title of this book I think is kind of

00:29:54,279 --> 00:29:58,389
misleading what he really should have

00:29:56,049 --> 00:30:00,909
called this book and some guys in the

00:29:58,389 --> 00:30:03,419
internet agreed with me was this book

00:30:00,909 --> 00:30:07,539
should be called unit test anything a

00:30:03,419 --> 00:30:08,769
guide for Java C++ and C because all the

00:30:07,539 --> 00:30:11,229
examples in the book are in those

00:30:08,769 --> 00:30:14,979
languages and it really is focused on

00:30:11,229 --> 00:30:17,229
adding unit tests and that is really

00:30:14,979 --> 00:30:21,759
quite hard work because adding unit

00:30:17,229 --> 00:30:23,169
tests you have to take risks I mean the

00:30:21,759 --> 00:30:24,969
book is all about minimizing that but

00:30:23,169 --> 00:30:27,279
you still have to take some risks when

00:30:24,969 --> 00:30:28,960
you haven't got any tests you have to

00:30:27,279 --> 00:30:32,259
make some refactorings to extract some

00:30:28,960 --> 00:30:34,239
units to put unit tests round and as

00:30:32,259 --> 00:30:37,469
you're doing that you might make the

00:30:34,239 --> 00:30:39,879
wrong choices and just start to bake in

00:30:37,469 --> 00:30:41,529
units that are there in the code but

00:30:39,879 --> 00:30:44,139
actually are really poor abstractions

00:30:41,529 --> 00:30:46,149
because this is legacy code and make it

00:30:44,139 --> 00:30:49,659
harder for yourself to refactor towards

00:30:46,149 --> 00:30:51,820
better abstractions plus of course if

00:30:49,659 --> 00:30:53,260
you're adding unit tests there may be

00:30:51,820 --> 00:30:55,210
integration errors but

00:30:53,260 --> 00:30:58,140
the units that you've extracted and the

00:30:55,210 --> 00:31:00,400
your unit tests won't pick up on so

00:30:58,140 --> 00:31:03,400
although this is a this is a good

00:31:00,400 --> 00:31:05,800
approach this is hard to do well and I

00:31:03,400 --> 00:31:07,870
would I would start to start with some

00:31:05,800 --> 00:31:10,510
full system or integration tests instead

00:31:07,870 --> 00:31:13,600
basically that would be my starting

00:31:10,510 --> 00:31:15,550
point get get the self testing code even

00:31:13,600 --> 00:31:19,690
if those self tests take hours

00:31:15,550 --> 00:31:22,200
that's that's a more stable and safe

00:31:19,690 --> 00:31:26,980
situation to be in

00:31:22,200 --> 00:31:29,140
so a useful technique I've find for this

00:31:26,980 --> 00:31:31,660
kind of full system tests is approval

00:31:29,140 --> 00:31:34,180
testing now this is something that you

00:31:31,660 --> 00:31:35,800
may not have heard of because this is a

00:31:34,180 --> 00:31:38,320
case where I'm not actually an early

00:31:35,800 --> 00:31:42,850
adopter and one of the innovators for

00:31:38,320 --> 00:31:46,270
this technique so I'm this I really

00:31:42,850 --> 00:31:49,240
wanted to talk about this so I'm going

00:31:46,270 --> 00:31:52,450
to talk to you about it so let's say

00:31:49,240 --> 00:31:54,850
I've got a little program a command line

00:31:52,450 --> 00:31:58,450
program that I'm calling minesweeper and

00:31:54,850 --> 00:32:02,230
it takes on standard inputs a text file

00:31:58,450 --> 00:32:04,570
well ASCII art representing the

00:32:02,230 --> 00:32:07,270
positions of some mines on the minefield

00:32:04,570 --> 00:32:11,040
that's the Stars and produces the

00:32:07,270 --> 00:32:13,810
standard output a similar ASCII art

00:32:11,040 --> 00:32:16,900
augmented with these little clue numbers

00:32:13,810 --> 00:32:20,050
how many mines are next to this space on

00:32:16,900 --> 00:32:22,720
the minefield now some of you may

00:32:20,050 --> 00:32:25,780
remember a certain operating system that

00:32:22,720 --> 00:32:27,820
came with a game somewhat like this a

00:32:25,780 --> 00:32:30,130
few years ago that was kind of addictive

00:32:27,820 --> 00:32:31,990
but um you'll you'll notice that these

00:32:30,130 --> 00:32:34,270
kind of clues could be useful in that

00:32:31,990 --> 00:32:36,370
game although this isn't that game this

00:32:34,270 --> 00:32:38,340
is a much much simpler version which is

00:32:36,370 --> 00:32:41,680
much easier to test with this technique

00:32:38,340 --> 00:32:43,660
hence why I chose it so how do you test

00:32:41,680 --> 00:32:47,110
this how are we going to check that this

00:32:43,660 --> 00:32:49,510
little command-line tool is working well

00:32:47,110 --> 00:32:52,180
the unit testing approach you you come

00:32:49,510 --> 00:32:54,820
up with a little minefield and you do

00:32:52,180 --> 00:32:56,470
some assertions about certain positions

00:32:54,820 --> 00:32:59,470
on the outputs that the clues were

00:32:56,470 --> 00:33:02,890
correct in those positions so you maybe

00:32:59,470 --> 00:33:05,980
have some code this is Java sorry in

00:33:02,890 --> 00:33:07,780
approval testing you don't write a

00:33:05,980 --> 00:33:11,980
search statement

00:33:07,780 --> 00:33:14,960
we rely on gathering the actual output

00:33:11,980 --> 00:33:16,820
so the approval testing approach is

00:33:14,960 --> 00:33:20,000
saying well okay this is the input data

00:33:16,820 --> 00:33:22,880
when I feed in this to standard input I

00:33:20,000 --> 00:33:24,710
get this on standard outputs and I will

00:33:22,880 --> 00:33:27,230
inspect that the first time I I see it

00:33:24,710 --> 00:33:29,690
and check that it's correct and I will

00:33:27,230 --> 00:33:32,120
approve it and say okay now I have a

00:33:29,690 --> 00:33:34,490
test case this input produces this

00:33:32,120 --> 00:33:38,240
output and so long as it keeps doing

00:33:34,490 --> 00:33:40,190
that everything is fine of course at

00:33:38,240 --> 00:33:43,130
some point this test will fail the the

00:33:40,190 --> 00:33:45,110
new outputs will be different and then

00:33:43,130 --> 00:33:47,270
the test will fail with a diff and show

00:33:45,110 --> 00:33:49,670
you and your programmers you've seen a

00:33:47,270 --> 00:33:52,070
diff tool before this is very clear

00:33:49,670 --> 00:33:56,420
there's some zeros there that weren't

00:33:52,070 --> 00:33:58,700
there before the approved version is not

00:33:56,420 --> 00:34:02,960
matching the actual version but is this

00:33:58,700 --> 00:34:08,030
a bug or a feature well-known we can't

00:34:02,960 --> 00:34:10,399
tell so let's say this is a bug and this

00:34:08,030 --> 00:34:12,710
output is not wanted and we've got this

00:34:10,399 --> 00:34:14,929
test failure now and I can go and fix

00:34:12,710 --> 00:34:19,340
the problem until the approved outputs

00:34:14,929 --> 00:34:21,919
matches the actual output notice if I'd

00:34:19,340 --> 00:34:23,390
had to write assert statements I might

00:34:21,919 --> 00:34:24,890
not have remembered to write assert

00:34:23,390 --> 00:34:28,909
statements all of these kind of edge

00:34:24,890 --> 00:34:31,460
cases and maybe my unit tests would have

00:34:28,909 --> 00:34:33,050
just passed and not noticed this so this

00:34:31,460 --> 00:34:35,780
is actually real effects when I'm using

00:34:33,050 --> 00:34:37,840
this kind of testing I recently often

00:34:35,780 --> 00:34:41,210
find defects that I didn't anticipate

00:34:37,840 --> 00:34:43,040
when I wrote the tests and just defects

00:34:41,210 --> 00:34:46,610
that I wouldn't have found with my unit

00:34:43,040 --> 00:34:47,960
tests so that's that's an advantage of

00:34:46,610 --> 00:34:50,540
course the other scenario is that this

00:34:47,960 --> 00:34:53,149
is a feature and now I have a test that

00:34:50,540 --> 00:34:58,190
needs updating I want to approve the new

00:34:53,149 --> 00:35:00,140
version of the file and that's fairly

00:34:58,190 --> 00:35:01,640
with a good tool that should be pretty

00:35:00,140 --> 00:35:03,560
straightforward I just say okay I

00:35:01,640 --> 00:35:07,700
approve this new version err test now

00:35:03,560 --> 00:35:10,190
passing this is very straightforward

00:35:07,700 --> 00:35:11,510
just with with if you just got one test

00:35:10,190 --> 00:35:13,010
failing you could imagine doing this

00:35:11,510 --> 00:35:14,450
with a unit testing tool you could

00:35:13,010 --> 00:35:16,850
imagine taking that new output and

00:35:14,450 --> 00:35:17,900
pasting it into your test case that

00:35:16,850 --> 00:35:21,290
works until you've got

00:35:17,900 --> 00:35:23,090
three tests and then you suddenly start

00:35:21,290 --> 00:35:25,460
thinking oh this is boring

00:35:23,090 --> 00:35:28,190
pacing this there's texts all the time

00:35:25,460 --> 00:35:30,080
you need tool supports approval testing

00:35:28,190 --> 00:35:32,990
really only works with good tool support

00:35:30,080 --> 00:35:35,150
that helps you with this managing the

00:35:32,990 --> 00:35:36,980
behavior for whole test Suites with many

00:35:35,150 --> 00:35:39,110
tests potentially failing in similar

00:35:36,980 --> 00:35:42,550
ways and this is the tool that I'm a

00:35:39,110 --> 00:35:46,070
contributor for which is text testing

00:35:42,550 --> 00:35:48,440
and approval testing so it just

00:35:46,070 --> 00:35:49,870
summarizes about dipping the actual

00:35:48,440 --> 00:35:52,520
output against the approved outputs

00:35:49,870 --> 00:35:54,560
updating approve versions and finally

00:35:52,520 --> 00:35:56,720
defense you didn't anticipate so if I'm

00:35:54,560 --> 00:35:58,910
looking at the benefits of TDD I

00:35:56,720 --> 00:36:01,730
mentioned before you don't get all of

00:35:58,910 --> 00:36:04,100
them with this kind of testing you don't

00:36:01,730 --> 00:36:05,900
have to design any api's before you

00:36:04,100 --> 00:36:07,520
implement them you don't have to design

00:36:05,900 --> 00:36:12,800
testable units as you just have to have

00:36:07,520 --> 00:36:14,630
testable programs and these this is

00:36:12,800 --> 00:36:16,250
different from TDD but it has the

00:36:14,630 --> 00:36:19,640
advantage that you can test spaghetti

00:36:16,250 --> 00:36:21,110
code these tests don't care what's on

00:36:19,640 --> 00:36:22,640
the inside how well-designed the thing

00:36:21,110 --> 00:36:26,510
is inside it just cares about the

00:36:22,640 --> 00:36:29,900
outputs and the inputs so that's

00:36:26,510 --> 00:36:31,280
approval testing back to the essential

00:36:29,900 --> 00:36:33,950
question of this talk haven't gone off

00:36:31,280 --> 00:36:36,200
on a bit of a tangent there and so I

00:36:33,950 --> 00:36:38,690
said before that TDD in the narrower

00:36:36,200 --> 00:36:43,310
sense has not yet crossed the chasm and

00:36:38,690 --> 00:36:44,540
where will it be in ten years time well

00:36:43,310 --> 00:36:47,960
I think you've probably gathered by now

00:36:44,540 --> 00:36:50,930
that I think it's more useful to talk

00:36:47,960 --> 00:36:52,670
about TDD in a more general sense this

00:36:50,930 --> 00:36:55,550
one that I showed you before with these

00:36:52,670 --> 00:36:58,970
other advantages well it's similar

00:36:55,550 --> 00:37:00,860
advantages little different so when I

00:36:58,970 --> 00:37:03,890
look at these this more general version

00:37:00,860 --> 00:37:07,340
of TDD I can pick out self testing code

00:37:03,890 --> 00:37:09,950
as something which I think actually is

00:37:07,340 --> 00:37:13,100
already across the chasm I think every

00:37:09,950 --> 00:37:16,100
most teams I go to now have self tests

00:37:13,100 --> 00:37:18,950
for their code they're probably too slow

00:37:16,100 --> 00:37:21,710
to use in the TDD loop and they're

00:37:18,950 --> 00:37:23,660
probably not testing isolated units and

00:37:21,710 --> 00:37:26,870
all of that but they ask it's still

00:37:23,660 --> 00:37:28,490
useful and I think by 20 by 10 years

00:37:26,870 --> 00:37:31,610
time this will be pretty much ubiquitous

00:37:28,490 --> 00:37:36,140
that every every reasonably

00:37:31,610 --> 00:37:38,330
codebase will ship with self-tests so

00:37:36,140 --> 00:37:40,670
the other another aspects of more

00:37:38,330 --> 00:37:42,290
general TDD is this thing of working

00:37:40,670 --> 00:37:44,630
incrementally running the tests often

00:37:42,290 --> 00:37:47,660
and then the tests do have to run a bit

00:37:44,630 --> 00:37:51,290
faster you can't tolerate more than a

00:37:47,660 --> 00:37:53,900
couple of minutes for the tests to take

00:37:51,290 --> 00:37:56,300
while you're developing and this is this

00:37:53,900 --> 00:38:02,450
is really much more widespread I think

00:37:56,300 --> 00:38:04,400
than the narrow TDD but still this is

00:38:02,450 --> 00:38:05,840
probably not across the chasm yet but I

00:38:04,400 --> 00:38:09,070
think it will get there I think the

00:38:05,840 --> 00:38:11,720
benefits of working incrementally are

00:38:09,070 --> 00:38:13,790
really good and people realize that I

00:38:11,720 --> 00:38:15,410
think even the conservative majority

00:38:13,790 --> 00:38:17,930
will realize that working incrementally

00:38:15,410 --> 00:38:25,160
is a better way of working than only

00:38:17,930 --> 00:38:27,230
running your tests once a day the

00:38:25,160 --> 00:38:28,750
computers yes so that what that will

00:38:27,230 --> 00:38:30,860
help a good point

00:38:28,750 --> 00:38:34,400
tests will run more quickly because the

00:38:30,860 --> 00:38:36,230
the hardware will be faster okay but so

00:38:34,400 --> 00:38:38,480
this other thing this thing that I think

00:38:36,230 --> 00:38:41,030
characterizes TDD in the narrower sense

00:38:38,480 --> 00:38:44,420
is about using tests to drive your

00:38:41,030 --> 00:38:48,380
design and get design feedback this is

00:38:44,420 --> 00:38:50,330
not across the fat cousin and having

00:38:48,380 --> 00:38:52,940
said what I've said I'm not sure it's

00:38:50,330 --> 00:38:55,070
ever going to cross to the majority this

00:38:52,940 --> 00:38:57,650
is a very specific way of doing design

00:38:55,070 --> 00:39:00,230
that suits some people and not others

00:38:57,650 --> 00:39:03,260
and some people are too I mean I expand

00:39:00,230 --> 00:39:05,000
stablize does not have using the test to

00:39:03,260 --> 00:39:07,370
drive the design approval testing does

00:39:05,000 --> 00:39:09,650
not have the test driving the design and

00:39:07,370 --> 00:39:12,710
I think that maybe this is like the toes

00:39:09,650 --> 00:39:15,440
on the running shoes it works really

00:39:12,710 --> 00:39:17,510
well in some situations but actually for

00:39:15,440 --> 00:39:20,270
the majority it's just a little bit too

00:39:17,510 --> 00:39:23,060
extreme and that people will continue to

00:39:20,270 --> 00:39:25,610
do design in the ways that they've been

00:39:23,060 --> 00:39:31,640
taught and learn to do design and maybe

00:39:25,610 --> 00:39:32,930
not in this really tight TDD loop so

00:39:31,640 --> 00:39:35,660
maybe that's controversial they don't

00:39:32,930 --> 00:39:38,480
know but okay so whether you still get a

00:39:35,660 --> 00:39:40,500
job in 2024 at all well of course if

00:39:38,480 --> 00:39:41,790
you're going to a coding dojo

00:39:40,500 --> 00:39:43,560
and you're improving your skills this

00:39:41,790 --> 00:39:47,790
could really help because then you're

00:39:43,560 --> 00:39:49,380
you're um you're learning about how to

00:39:47,790 --> 00:39:51,540
do TDD and that's got to be a good thing

00:39:49,380 --> 00:39:54,440
and in an interview situation if you can

00:39:51,540 --> 00:39:57,000
do a code kata that's got to be good so

00:39:54,440 --> 00:39:58,860
of course it's not just about TDD you

00:39:57,000 --> 00:40:02,340
can learn all sorts of other programming

00:39:58,860 --> 00:40:05,010
skills so this is my last slide I wanted

00:40:02,340 --> 00:40:09,570
to just summarize what I've said will I

00:40:05,010 --> 00:40:12,090
still be able to get a job see if you

00:40:09,570 --> 00:40:14,100
can try learn TDD in the narrower sense

00:40:12,090 --> 00:40:15,810
see if you can experience that get a

00:40:14,100 --> 00:40:18,360
tool like cyber dojo give get some

00:40:15,810 --> 00:40:19,890
feedback from peers experience what it's

00:40:18,360 --> 00:40:25,320
like so you understand the essential

00:40:19,890 --> 00:40:28,890
benefits of this technology and can

00:40:25,320 --> 00:40:30,210
apply that to your local conditions I've

00:40:28,890 --> 00:40:30,810
talked about double-loop test-driven

00:40:30,210 --> 00:40:32,490
development

00:40:30,810 --> 00:40:34,650
I've talked about spiked and stabilized

00:40:32,490 --> 00:40:36,030
kind of design and approval testing

00:40:34,650 --> 00:40:38,580
these are techniques which may be

00:40:36,030 --> 00:40:42,870
up-and-coming extending TDD so that it

00:40:38,580 --> 00:40:45,270
works in more conditions and to answer

00:40:42,870 --> 00:40:48,120
the question I think of course you'll

00:40:45,270 --> 00:40:49,770
get a job in 2024 if you can write self

00:40:48,120 --> 00:40:53,130
testing code if you can work

00:40:49,770 --> 00:40:55,050
incrementally and you can do design even

00:40:53,130 --> 00:40:59,060
if you don't do your design with tests

00:40:55,050 --> 00:40:59,060
first thank you

00:41:17,800 --> 00:41:21,290
thank you very much Emily it's a great

00:41:20,180 --> 00:41:23,650
talk

00:41:21,290 --> 00:41:27,050
you have two microphones if you have any

00:41:23,650 --> 00:41:29,050
please walk up to the microphones you

00:41:27,050 --> 00:41:33,320
can't you bear and Derek

00:41:29,050 --> 00:41:34,880
we are going to have I think not much

00:41:33,320 --> 00:41:38,330
more than five minutes hello Emily I

00:41:34,880 --> 00:41:38,900
just would like to addition to the

00:41:38,330 --> 00:41:40,880
audience

00:41:38,900 --> 00:41:43,160
there's much as code coding do each row

00:41:40,880 --> 00:41:45,080
but also code retreat and this is a

00:41:43,160 --> 00:41:46,850
special event form where the people in

00:41:45,080 --> 00:41:49,460
Germany especially in my hometown

00:41:46,850 --> 00:41:53,000
pirouette mr. Osterberg meet literally

00:41:49,460 --> 00:41:55,400
at weekends sometimes a year and in

00:41:53,000 --> 00:41:58,340
other towns too and so they are we just

00:41:55,400 --> 00:41:59,660
do coding dojo to in a special form

00:41:58,340 --> 00:42:03,320
through the game of life

00:41:59,660 --> 00:42:04,310
yes I've led code retreats it's a it can

00:42:03,320 --> 00:42:09,380
be really fun day

00:42:04,310 --> 00:42:11,210
I'm also recommended over there I had a

00:42:09,380 --> 00:42:13,130
question about approval testing you you

00:42:11,210 --> 00:42:14,330
had the the slide up of approval testing

00:42:13,130 --> 00:42:16,310
and all the benefits that came with it

00:42:14,330 --> 00:42:18,500
and one of them was working it for

00:42:16,310 --> 00:42:20,420
mentally but at least with your example

00:42:18,500 --> 00:42:22,970
it's not really working incrementally

00:42:20,420 --> 00:42:24,920
can you explain how approval testing and

00:42:22,970 --> 00:42:27,080
incremental development work things that

00:42:24,920 --> 00:42:29,060
I didn't get that from right I've

00:42:27,080 --> 00:42:31,100
glossed over that you're quite right and

00:42:29,060 --> 00:42:34,070
the thing is if you've got um you know

00:42:31,100 --> 00:42:36,530
100 tests with all different variations

00:42:34,070 --> 00:42:38,750
of inputs and outputs you'll find that

00:42:36,530 --> 00:42:42,530
when when you get a when you change

00:42:38,750 --> 00:42:45,080
something in the code you get if you

00:42:42,530 --> 00:42:47,600
change too much at once all of those

00:42:45,080 --> 00:42:50,540
tests fail in in so many ways it's

00:42:47,600 --> 00:42:52,850
really hard to clean up the mess so you

00:42:50,540 --> 00:42:55,610
find yourself forcing to work in in just

00:42:52,850 --> 00:42:57,440
making one change at a time so that you

00:42:55,610 --> 00:42:59,570
can you can approve the new results

00:42:57,440 --> 00:43:01,250
across all those tests and it's really

00:42:59,570 --> 00:43:03,530
clear that it's just that change you

00:43:01,250 --> 00:43:05,990
didn't introduce something unexpected so

00:43:03,530 --> 00:43:08,000
it's it's not some it's not obvious

00:43:05,990 --> 00:43:10,040
you're quite right but my experience

00:43:08,000 --> 00:43:11,600
doing approval testing is that you do

00:43:10,040 --> 00:43:13,280
have to work incremental e or it doesn't

00:43:11,600 --> 00:43:14,930
work but but how do you even get to the

00:43:13,280 --> 00:43:16,850
point where you can run the test without

00:43:14,930 --> 00:43:18,080
having written the entire program that

00:43:16,850 --> 00:43:21,140
that's not guess that is the core right

00:43:18,080 --> 00:43:24,080
so you you start approving the results

00:43:21,140 --> 00:43:26,240
when they're incomplete so you write a

00:43:24,080 --> 00:43:27,380
program first that just returns this so

00:43:26,240 --> 00:43:29,750
you start with the mind suite but you

00:43:27,380 --> 00:43:31,850
have this input the first iteration just

00:43:29,750 --> 00:43:33,590
returns the same on output and you prove

00:43:31,850 --> 00:43:35,900
that and then you write something that

00:43:33,590 --> 00:43:37,640
will just write once around all of their

00:43:35,900 --> 00:43:39,950
minds and you approve that and then you

00:43:37,640 --> 00:43:41,090
write the code that will put twos and

00:43:39,950 --> 00:43:45,970
threes and things and then you approve

00:43:41,090 --> 00:43:45,970
that so you you do work incrementally

00:43:46,810 --> 00:43:51,350
yeah um thank you again for this

00:43:49,010 --> 00:43:53,300
wonderful talk things I have three

00:43:51,350 --> 00:43:56,530
things actually but um we will be really

00:43:53,300 --> 00:43:59,510
quick so first thing as approval testing

00:43:56,530 --> 00:44:01,130
III got reminded of something it's not

00:43:59,510 --> 00:44:03,470
that completely new because when I think

00:44:01,130 --> 00:44:05,120
of a software like gosh them that's a

00:44:03,470 --> 00:44:07,850
chemistry program that calculates

00:44:05,120 --> 00:44:10,070
some-some energies they did this in the

00:44:07,850 --> 00:44:12,950
70s because they had to make sure that

00:44:10,070 --> 00:44:15,560
when you install it on your computer it

00:44:12,950 --> 00:44:18,170
calculates the same values then that I

00:44:15,560 --> 00:44:19,790
did before so they put all the files and

00:44:18,170 --> 00:44:21,730
then when you run the test suite it

00:44:19,790 --> 00:44:24,710
actually makes it differently and

00:44:21,730 --> 00:44:27,500
comparing the actual result with some

00:44:24,710 --> 00:44:31,250
file that I just prepared and beforehand

00:44:27,500 --> 00:44:33,110
so but I mean doing it and this kind of

00:44:31,250 --> 00:44:37,580
approach is kind of new that thing

00:44:33,110 --> 00:44:39,320
second thing it has yeah science and

00:44:37,580 --> 00:44:41,960
there's another scenario that I wanted

00:44:39,320 --> 00:44:43,970
to point out where you don't use TDD

00:44:41,960 --> 00:44:46,670
really and this is in my opinion when

00:44:43,970 --> 00:44:48,470
you do rapid prototyping because it will

00:44:46,670 --> 00:44:51,890
slow you down you know you just want to

00:44:48,470 --> 00:44:53,360
get your code out so that didn't come up

00:44:51,890 --> 00:44:55,870
in you and you're three examples that

00:44:53,360 --> 00:44:59,050
you had but another question I have is

00:44:55,870 --> 00:45:01,880
to convince my employer to do it I mean

00:44:59,050 --> 00:45:04,880
I'm kind of new to this testing field

00:45:01,880 --> 00:45:06,950
but it will take more time to write your

00:45:04,880 --> 00:45:08,600
program and will be more expensive and I

00:45:06,950 --> 00:45:11,030
think that's one of the reasons why the

00:45:08,600 --> 00:45:13,550
majority has inducted yes so what do you

00:45:11,030 --> 00:45:16,010
say to that you're right the majority

00:45:13,550 --> 00:45:18,620
needs more proven benefits before

00:45:16,010 --> 00:45:21,970
they'll adopt a technology and I think

00:45:18,620 --> 00:45:23,220
the benefits of self testing code are

00:45:21,970 --> 00:45:27,839
obvious

00:45:23,220 --> 00:45:29,670
and I think most most people will accept

00:45:27,839 --> 00:45:31,290
that and so that's why self testing code

00:45:29,670 --> 00:45:33,210
I think really already has across the

00:45:31,290 --> 00:45:34,980
chasm the the thing with working

00:45:33,210 --> 00:45:37,050
incrementally that only becomes clear

00:45:34,980 --> 00:45:39,119
when you realize how much more effective

00:45:37,050 --> 00:45:47,010
a team can work when they're sharing

00:45:39,119 --> 00:45:47,700
code more often yeah you have to I don't

00:45:47,010 --> 00:45:49,290
know

00:45:47,700 --> 00:45:52,020
I'm an early adopter I just try stuff

00:45:49,290 --> 00:45:54,960
and what's gonna convince the majority

00:45:52,020 --> 00:45:57,060
I'm not so sure on perhaps you just have

00:45:54,960 --> 00:45:58,680
to pick the right employer yeah one one

00:45:57,060 --> 00:46:00,300
second we have one more question but

00:45:58,680 --> 00:46:02,550
please could you just for one minute

00:46:00,300 --> 00:46:04,500
still reduce your chatting because

00:46:02,550 --> 00:46:06,180
that's a bit hard to transcribe Thanks

00:46:04,500 --> 00:46:08,310
so one more questions about there I'm

00:46:06,180 --> 00:46:09,810
sorry oh yeah thank you for the talk and

00:46:08,310 --> 00:46:11,520
can we just make a quick show of hands

00:46:09,810 --> 00:46:16,980
who is already using TDD in their

00:46:11,520 --> 00:46:19,710
everyday job yeah this I should say this

00:46:16,980 --> 00:46:22,109
is people you meet at conferences the

00:46:19,710 --> 00:46:24,660
proportion of early adopters is much

00:46:22,109 --> 00:46:27,839
much higher that's why I love going to

00:46:24,660 --> 00:46:31,040
conferences one of the reasons thank you

00:46:27,839 --> 00:46:31,040

YouTube URL: https://www.youtube.com/watch?v=tS3oPThQ7y0


