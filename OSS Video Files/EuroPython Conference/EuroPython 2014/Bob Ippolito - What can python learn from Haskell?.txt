Title: Bob Ippolito - What can python learn from Haskell?
Publication date: 2015-04-18
Playlist: EuroPython 2014
Description: 
	Bob Ippolito - What can python learn from Haskell?
[EuroPython 2014]
[21 July 2014]

What can we learn from Erlang or Haskell for building reliable high
concurrency services? Bob was involved in many Python projects but
argues that for some domains there may be better methods found
elsewhere. He started looking for alternatives back in 2006 when
building high concurrency services at Mochi Media (originally with
Twisted), which led him to the land of Erlang and later Haskell. Bob is
going to talk about what he learned along the way. In particular, he’ll
cover some techniques that are used in functional programming languages
and how they can be used to solve problems in more performant, robust
and/or concise ways than the standard practices in Python. He is also
going to discuss some potential ways that the Python language and its
library ecosystem could evolve accordingly.

-----

What can we learn from Erlang or Haskell for building reliable high
concurrency services? Bob was involved in many Python projects but
argues that for some domains there may be better methods found
elsewhere. He started looking for alternatives back in 2006 when
building high concurrency services at Mochi Media (originally with
Twisted), which led him to the land of Erlang and later Haskell. Bob is
going to talk about what he learned along the way. In particular, he’ll
cover some techniques that are used in functional programming languages
and how they can be used to solve problems in more performant, robust
and/or concise ways than the standard practices in Python. He is also
going to discuss some potential ways that the Python language and its
library ecosystem could evolve accordingly.
Captions: 
	00:00:14,700 --> 00:00:20,070
and welcome to the next keynote from

00:00:17,279 --> 00:00:23,910
body frito I met Bob when he was

00:00:20,070 --> 00:00:26,250
involved in lithonia in Vilnius in 2006

00:00:23,910 --> 00:00:28,680
where he was also hacking on the pipe I

00:00:26,250 --> 00:00:31,439
project and of course he was also on

00:00:28,680 --> 00:00:33,750
several Python conferences but he

00:00:31,439 --> 00:00:36,360
actually instead of continuing with pipe

00:00:33,750 --> 00:00:40,140
I he went on doing something very

00:00:36,360 --> 00:00:44,399
commercially viable he found that much

00:00:40,140 --> 00:00:48,480
in media a company around advertising

00:00:44,399 --> 00:00:52,530
and as it happens he is now on he

00:00:48,480 --> 00:00:54,780
doesn't need to work anymore for for

00:00:52,530 --> 00:00:57,660
earning money but he can now go to

00:00:54,780 --> 00:01:00,180
conferences and give interesting talks

00:00:57,660 --> 00:01:01,800
and play with lots of fun things and one

00:01:00,180 --> 00:01:05,009
very interesting thing he's also doing

00:01:01,800 --> 00:01:07,610
is he's involved in mission bit which is

00:01:05,009 --> 00:01:10,640
an educational program in San Francisco

00:01:07,610 --> 00:01:14,899
Forty chirring children high school

00:01:10,640 --> 00:01:14,899
programming all kinds of stuff

00:01:18,540 --> 00:01:26,400
and he's doing that on his own time

00:01:22,410 --> 00:01:28,200
simply and he's also sometimes looking

00:01:26,400 --> 00:01:31,620
for the next big thing to be involved in

00:01:28,200 --> 00:01:35,130
but he's not eager to actually get there

00:01:31,620 --> 00:01:38,130
soon so I'm very happy that we have him

00:01:35,130 --> 00:01:43,010
here because he's he also wrote the HTTP

00:01:38,130 --> 00:01:46,170
a major HTTP server in alarm he has

00:01:43,010 --> 00:01:48,090
helped evolve the green light library

00:01:46,170 --> 00:01:50,640
and pie from and lots of lots of

00:01:48,090 --> 00:01:52,860
different things I think you have also

00:01:50,640 --> 00:01:55,619
been involved in the Jason simple Jason

00:01:52,860 --> 00:01:57,270
passing staff and you know he's done

00:01:55,619 --> 00:02:00,180
lots of stuff and pie from but also in

00:01:57,270 --> 00:02:01,710
along and recently also in Haskell so I

00:02:00,180 --> 00:02:03,990
think he's the perfect guy to tell us a

00:02:01,710 --> 00:02:08,930
bit about what Python can learn from

00:02:03,990 --> 00:02:08,930
Haskell and functional languages Bob

00:02:15,090 --> 00:02:19,930
thank you very much for inviting me to

00:02:17,710 --> 00:02:22,930
speak here today I'm going to tell you

00:02:19,930 --> 00:02:25,620
about some of the things that I don't

00:02:22,930 --> 00:02:27,730
like about Python but starting off I

00:02:25,620 --> 00:02:29,410
have done a lot of Python I've been

00:02:27,730 --> 00:02:32,050
doing it for a long time since about two

00:02:29,410 --> 00:02:34,240
thousand one most notably i'm the author

00:02:32,050 --> 00:02:37,870
of the simple JSON library which i still

00:02:34,240 --> 00:02:39,670
reluctantly maintain and i worked on a

00:02:37,870 --> 00:02:42,280
bunch of mac specific stuff by

00:02:39,670 --> 00:02:43,660
objective-c and all of that stuff so

00:02:42,280 --> 00:02:45,790
either you're welcome you're welcome

00:02:43,660 --> 00:02:47,800
where I'm sorry especially to Ronald

00:02:45,790 --> 00:02:51,400
over there who still maintains it as far

00:02:47,800 --> 00:02:52,990
as I know and as Holger said I founded a

00:02:51,400 --> 00:02:55,750
company called mochi media and I worked

00:02:52,990 --> 00:02:58,360
there for a while but not so long after

00:02:55,750 --> 00:03:01,150
I sold it I've been using Haskell for a

00:02:58,360 --> 00:03:03,880
couple years now most notably i ported

00:03:01,150 --> 00:03:06,930
the exorcism do I owe curriculum to

00:03:03,880 --> 00:03:09,400
their exorcism is a website which has

00:03:06,930 --> 00:03:10,840
programming practice problems in many

00:03:09,400 --> 00:03:14,740
many different languages including

00:03:10,840 --> 00:03:18,160
Python but also languages like Swift or

00:03:14,740 --> 00:03:19,840
f sharp or Haskell whatnot so I worked

00:03:18,160 --> 00:03:21,520
on the hospital curriculum and I provide

00:03:19,840 --> 00:03:24,220
a lot of code review to people that

00:03:21,520 --> 00:03:26,260
submit solutions in Haskell these days I

00:03:24,220 --> 00:03:28,180
do a bit of advising and investing I

00:03:26,260 --> 00:03:30,790
wrote up right open source code on the

00:03:28,180 --> 00:03:32,680
side and I teach and I'm on the board of

00:03:30,790 --> 00:03:35,080
a nonprofit called mission bid in San

00:03:32,680 --> 00:03:37,450
Francisco but you know we hope to expand

00:03:35,080 --> 00:03:41,470
beyond that once we've sufficiently

00:03:37,450 --> 00:03:43,150
covered the San Francisco area and so

00:03:41,470 --> 00:03:45,040
but before I start ragging on Python

00:03:43,150 --> 00:03:47,710
let's just say that python is not all

00:03:45,040 --> 00:03:49,120
bad but I only have 45 minutes to talk

00:03:47,710 --> 00:03:54,010
so I'm only going to talk about the bad

00:03:49,120 --> 00:03:56,230
things i love pythons community there

00:03:54,010 --> 00:03:58,360
are so many great ideas and libraries

00:03:56,230 --> 00:04:00,550
that come from here and you know python

00:03:58,360 --> 00:04:01,900
works wonderfully for many users i'm

00:04:00,550 --> 00:04:04,210
sure most of you are perfectly happy

00:04:01,900 --> 00:04:05,890
with python and for the issues that do

00:04:04,210 --> 00:04:08,320
exist there are often good enough

00:04:05,890 --> 00:04:12,760
workarounds like pi PI numba sites on

00:04:08,320 --> 00:04:15,430
etc and I'm actually not going to talk

00:04:12,760 --> 00:04:18,370
too much about Haskell but suffice it to

00:04:15,430 --> 00:04:20,520
say the Haskell's not all good I I learn

00:04:18,370 --> 00:04:22,930
a lot from it I think it's fantastic but

00:04:20,520 --> 00:04:25,540
notably it has a much smaller community

00:04:22,930 --> 00:04:27,490
this non strict evaluation stuff is just

00:04:25,540 --> 00:04:28,080
so different from from how most other

00:04:27,490 --> 00:04:30,810
languages

00:04:28,080 --> 00:04:33,240
evaluate code sometimes the

00:04:30,810 --> 00:04:35,729
documentation it's not a website with

00:04:33,240 --> 00:04:38,069
with some nice documentation it's it's

00:04:35,729 --> 00:04:39,990
like a postscript file that you download

00:04:38,069 --> 00:04:42,000
that somebody wrote for their PhD thesis

00:04:39,990 --> 00:04:43,919
and and that's kind of okay that's

00:04:42,000 --> 00:04:48,030
accepted in that community although

00:04:43,919 --> 00:04:50,400
that's changing slowly and and it can be

00:04:48,030 --> 00:04:52,050
intimidating to some because the the

00:04:50,400 --> 00:04:55,289
terminology mostly comes from

00:04:52,050 --> 00:04:57,599
mathematics so you have to become

00:04:55,289 --> 00:05:01,020
comfortable saying things like mono I'd

00:04:57,599 --> 00:05:02,490
functor mana etc which you know it takes

00:05:01,020 --> 00:05:04,800
people a little a little time to get

00:05:02,490 --> 00:05:08,969
used to if they haven't taken a category

00:05:04,800 --> 00:05:10,560
theory class and so if you're perfectly

00:05:08,969 --> 00:05:12,659
happy with Python and don't want it to

00:05:10,560 --> 00:05:15,090
change even a little bit you might want

00:05:12,659 --> 00:05:16,590
to leave now and go downstairs and hang

00:05:15,090 --> 00:05:21,300
out with all the cool companies in the

00:05:16,590 --> 00:05:23,069
basement and I you know I was a lot

00:05:21,300 --> 00:05:24,810
happier with Python and still until I

00:05:23,069 --> 00:05:27,629
started learning other languages like

00:05:24,810 --> 00:05:29,550
air lying in Haskell and I I didn't look

00:05:27,629 --> 00:05:31,500
for other languages until I really hit

00:05:29,550 --> 00:05:33,419
an area that Python just wasn't very

00:05:31,500 --> 00:05:36,870
good at and that's concurrency and

00:05:33,419 --> 00:05:39,090
network programming and I feel like I'm

00:05:36,870 --> 00:05:40,259
a better programmer having learned all

00:05:39,090 --> 00:05:44,639
of these different approaches to

00:05:40,259 --> 00:05:47,370
problems and a nice little quote that i

00:05:44,639 --> 00:05:49,259
ran across recently and I think this

00:05:47,370 --> 00:05:52,080
explains some of what we have in Python

00:05:49,259 --> 00:05:53,819
today nasty little paradox the better

00:05:52,080 --> 00:05:57,419
something works the less likely it will

00:05:53,819 --> 00:05:59,610
be improved and so these are some of the

00:05:57,419 --> 00:06:01,860
things that that I find that Python

00:05:59,610 --> 00:06:04,289
makes it hard to do Python makes it hard

00:06:01,860 --> 00:06:06,779
to write code that works it makes it

00:06:04,289 --> 00:06:09,569
hard to maintain code it makes it hard

00:06:06,779 --> 00:06:10,919
to create good abstractions and it

00:06:09,569 --> 00:06:14,940
certainly makes it hard to run code

00:06:10,919 --> 00:06:16,500
efficiently and so on the correctness

00:06:14,940 --> 00:06:18,479
topic you're going to make mistakes in

00:06:16,500 --> 00:06:22,050
any language it doesn't matter if it has

00:06:18,479 --> 00:06:24,300
an amazing type system or anything else

00:06:22,050 --> 00:06:26,879
you're going to make mistakes and the

00:06:24,300 --> 00:06:28,949
key is is to have tools that tell you

00:06:26,879 --> 00:06:31,919
what those mistakes are but Python

00:06:28,949 --> 00:06:33,779
defers all of that to run time so unless

00:06:31,919 --> 00:06:35,759
that code path happens it's not going to

00:06:33,779 --> 00:06:37,589
tell you anything the only thing it can

00:06:35,759 --> 00:06:40,620
tell you is if you use tabs instead of

00:06:37,589 --> 00:06:45,150
spaces or you know maybe if you put a

00:06:40,620 --> 00:06:47,430
colon in the wrong place and sadly the

00:06:45,150 --> 00:06:49,440
static analysis tools for Python today

00:06:47,430 --> 00:06:51,210
are very very primitive they could be

00:06:49,440 --> 00:06:53,250
better but it just hasn't been an active

00:06:51,210 --> 00:06:56,280
area of research I think this is because

00:06:53,250 --> 00:06:57,720
the people that that can understand this

00:06:56,280 --> 00:06:59,300
problem and know a lot about type

00:06:57,720 --> 00:07:01,860
systems and inference and whatnot

00:06:59,300 --> 00:07:03,720
basically move on to other languages

00:07:01,860 --> 00:07:09,540
that that support these things more

00:07:03,720 --> 00:07:11,610
readily and you can write code in Python

00:07:09,540 --> 00:07:13,650
that you know is correct and you do that

00:07:11,610 --> 00:07:16,020
by writing a lot of tests but some of

00:07:13,650 --> 00:07:18,060
these tests are things that that it

00:07:16,020 --> 00:07:19,830
should just be able to do for you like

00:07:18,060 --> 00:07:21,960
when you write an integer literal

00:07:19,830 --> 00:07:23,070
somewhere you know it's not a string and

00:07:21,960 --> 00:07:27,630
you shouldn't be able to add it to a

00:07:23,070 --> 00:07:30,750
string and so given that here's here's a

00:07:27,630 --> 00:07:34,139
simple example of a perfectly Pepe

00:07:30,750 --> 00:07:35,820
compliant Python file that shouldn't do

00:07:34,139 --> 00:07:40,229
anything the language guarantees that

00:07:35,820 --> 00:07:43,320
this code will not work because I inch

00:07:40,229 --> 00:07:45,660
and string are closed you can't override

00:07:43,320 --> 00:07:48,330
how they behave you can't change what

00:07:45,660 --> 00:07:50,460
plus does so no matter what this code is

00:07:48,330 --> 00:07:52,470
just going to blow up at runtime and we

00:07:50,460 --> 00:07:54,060
can very easily just glance at this and

00:07:52,470 --> 00:07:57,630
know that that's the case there there is

00:07:54,060 --> 00:08:00,479
no universe to which this code should do

00:07:57,630 --> 00:08:02,190
anything unless maybe you're

00:08:00,479 --> 00:08:04,830
introspecting the bytecode and doing

00:08:02,190 --> 00:08:07,020
something horrible but don't do that and

00:08:04,830 --> 00:08:08,700
so let's see what Python things all

00:08:07,020 --> 00:08:10,470
right so we throw the Python compiler at

00:08:08,700 --> 00:08:12,720
it we use this nice compile all thing

00:08:10,470 --> 00:08:14,190
which I often use an automated testing

00:08:12,720 --> 00:08:16,680
because it tells me if I screwed up the

00:08:14,190 --> 00:08:18,660
syntax and what does it do well nothing

00:08:16,680 --> 00:08:21,570
it compiles the file it's totally fine i

00:08:18,660 --> 00:08:25,080
get by code no error no warning nothing

00:08:21,570 --> 00:08:27,389
and so another popular tool for for

00:08:25,080 --> 00:08:30,570
looking at the surface of Python modules

00:08:27,389 --> 00:08:33,930
as pie flakes so I run pie flags it also

00:08:30,570 --> 00:08:36,300
tells me absolutely nothing and so what

00:08:33,930 --> 00:08:37,830
about pilant okay so I wrote all these

00:08:36,300 --> 00:08:41,250
nice doc strings and it's perfectly

00:08:37,830 --> 00:08:43,409
formatted so this is this is 10.0 out of

00:08:41,250 --> 00:08:45,630
10 I did nothing wrong here nothing

00:08:43,409 --> 00:08:48,300
whatsoever it runs all these tests and

00:08:45,630 --> 00:08:51,630
it's perfectly fine Python but I you

00:08:48,300 --> 00:08:53,250
know it's obviously not the case and do

00:08:51,630 --> 00:08:54,600
better tools exist well I certainly

00:08:53,250 --> 00:08:56,670
couldn't find anything

00:08:54,600 --> 00:08:58,910
and if I couldn't find anything that's

00:08:56,670 --> 00:08:58,910
bad

00:09:07,279 --> 00:09:11,930
it will cleat I would love to hear more

00:09:10,189 --> 00:09:13,850
about that to my understanding that's

00:09:11,930 --> 00:09:17,319
that's an IDE or something but maybe we

00:09:13,850 --> 00:09:17,319
can talk about that in questions after

00:09:20,230 --> 00:09:25,370
okay so nothing nothing that I could

00:09:22,730 --> 00:09:28,430
readily find could catch this simple

00:09:25,370 --> 00:09:30,769
case most of the tools are concerned

00:09:28,430 --> 00:09:32,509
with just the general case of Python

00:09:30,769 --> 00:09:35,930
where where you know anything can happen

00:09:32,509 --> 00:09:37,639
and dynamism is cool and and you can

00:09:35,930 --> 00:09:42,199
override things at runtime and then

00:09:37,639 --> 00:09:43,550
there's nothing wrong with that so so

00:09:42,199 --> 00:09:45,589
it's very difficult to write one of

00:09:43,550 --> 00:09:48,589
these tools when you accept that that

00:09:45,589 --> 00:09:50,360
every feature of Python is great and it

00:09:48,589 --> 00:09:51,470
should be used all the time but I don't

00:09:50,360 --> 00:09:54,649
think that's the case I think we should

00:09:51,470 --> 00:09:56,120
write more restricted code just that you

00:09:54,649 --> 00:09:58,610
know in the same way that we should

00:09:56,120 --> 00:10:01,100
indent consistently by either two or

00:09:58,610 --> 00:10:04,040
four spaces depending on where you come

00:10:01,100 --> 00:10:06,050
from or where you work and the thing is

00:10:04,040 --> 00:10:10,220
is that Python 3 already has the hooks

00:10:06,050 --> 00:10:12,350
that we need to do very good annotations

00:10:10,220 --> 00:10:14,889
and we can use those annotations to tell

00:10:12,350 --> 00:10:17,870
the tools what we expect to happen and

00:10:14,889 --> 00:10:19,160
there there is a tool that works in

00:10:17,870 --> 00:10:22,189
precisely this way and I'll talk about

00:10:19,160 --> 00:10:23,629
that in a little bit so here's what some

00:10:22,189 --> 00:10:26,809
other languages do with that example

00:10:23,629 --> 00:10:29,899
here's the airline version so I'd so

00:10:26,809 --> 00:10:32,480
it's you know a little more verbose in

00:10:29,899 --> 00:10:35,269
some ways and what does the airline

00:10:32,480 --> 00:10:36,800
compiler do well if I if I try and

00:10:35,269 --> 00:10:38,180
compile this it says warning this

00:10:36,800 --> 00:10:40,220
expression will fail with a battery

00:10:38,180 --> 00:10:42,139
exception and the interesting thing to

00:10:40,220 --> 00:10:43,699
note here is that are lying is a totally

00:10:42,139 --> 00:10:46,279
dynamic language it's not statically

00:10:43,699 --> 00:10:47,959
typed anywhere it has optional type

00:10:46,279 --> 00:10:52,819
annotations just like five and three

00:10:47,959 --> 00:10:55,189
does and airline also has even better

00:10:52,819 --> 00:10:57,350
tools it has this tool called dialyzer

00:10:55,189 --> 00:10:59,689
which does static analysis and success

00:10:57,350 --> 00:11:01,370
typing and all this fancy stuff and this

00:10:59,689 --> 00:11:04,850
gives me a more specific error about

00:11:01,370 --> 00:11:06,920
exactly why this is wrong I can't add 12

00:11:04,850 --> 00:11:08,990
to a string because it expects them to

00:11:06,920 --> 00:11:11,269
both be numbers given the first argument

00:11:08,990 --> 00:11:13,279
and the fact that plus doesn't work on

00:11:11,269 --> 00:11:16,129
lists there's a separate operator for

00:11:13,279 --> 00:11:17,389
that in this language and here's the the

00:11:16,129 --> 00:11:18,589
high school example and you might be

00:11:17,389 --> 00:11:20,300
thinking no way where's the type

00:11:18,589 --> 00:11:22,460
signature well there it is

00:11:20,300 --> 00:11:25,310
but this this is the full Haskell

00:11:22,460 --> 00:11:27,380
program you note that it's it's a you

00:11:25,310 --> 00:11:28,660
know just as simple as the Python one if

00:11:27,380 --> 00:11:31,160
not simpler because there's no

00:11:28,660 --> 00:11:34,040
underscores to be seen anywhere no

00:11:31,160 --> 00:11:36,140
equals or ifs or none of that you just

00:11:34,040 --> 00:11:39,890
write main and what main should be and

00:11:36,140 --> 00:11:41,390
then that's that and if I throw the

00:11:39,890 --> 00:11:43,750
Haskell compiler at it it's going to

00:11:41,390 --> 00:11:47,480
give me an error it says I I can't add

00:11:43,750 --> 00:11:49,340
the number one to the string one and to

00:11:47,480 --> 00:11:50,630
explain this a little bit we can kind of

00:11:49,340 --> 00:11:53,150
gloss over this because it doesn't

00:11:50,630 --> 00:11:56,510
really matter so it's saying this num

00:11:53,150 --> 00:11:59,030
chair thing because by default lists of

00:11:56,510 --> 00:12:01,150
chair are strings so that's what the

00:11:59,030 --> 00:12:04,310
chair and square brackets is and

00:12:01,150 --> 00:12:07,370
operations such as plus minus x negate

00:12:04,310 --> 00:12:09,200
etc belong to the num type class so it's

00:12:07,370 --> 00:12:13,430
saying that there is no instance of this

00:12:09,200 --> 00:12:15,800
num type class for list of chair and you

00:12:13,430 --> 00:12:17,210
could in theory implement such a num

00:12:15,800 --> 00:12:19,940
type class but you really shouldn't do

00:12:17,210 --> 00:12:22,640
that only truly numeric types such as

00:12:19,940 --> 00:12:25,310
int double rational etc should implement

00:12:22,640 --> 00:12:29,450
this num type class the Haskell folks

00:12:25,310 --> 00:12:32,270
are they like to write type classes only

00:12:29,450 --> 00:12:35,480
when there are algebraic laws that you

00:12:32,270 --> 00:12:41,630
can apply to them and here it's the the

00:12:35,480 --> 00:12:44,060
law for this particular category and so

00:12:41,630 --> 00:12:46,310
why is refactoring in Python hard well

00:12:44,060 --> 00:12:49,160
it's hard to refactor without good tests

00:12:46,310 --> 00:12:51,740
and not everybody writes good tests the

00:12:49,160 --> 00:12:53,960
types are very obvious tests and they're

00:12:51,740 --> 00:12:55,700
also documentation so in one way or

00:12:53,960 --> 00:12:59,600
another you're writing the types here

00:12:55,700 --> 00:13:00,920
anyway and we have refactoring is much

00:12:59,600 --> 00:13:03,110
easier in high school than it is in

00:13:00,920 --> 00:13:05,930
Python due to these types and also

00:13:03,110 --> 00:13:07,340
referential transparency can we do

00:13:05,930 --> 00:13:11,660
something like this in Python well the

00:13:07,340 --> 00:13:14,140
answer is yes so first we have this pure

00:13:11,660 --> 00:13:17,480
python nothing fancy breadth-first

00:13:14,140 --> 00:13:20,300
breadth-first traversal of a graph so we

00:13:17,480 --> 00:13:22,310
have a starting node which is some some

00:13:20,300 --> 00:13:26,030
number and then edges which is a

00:13:22,310 --> 00:13:28,280
dictionary of numbers to a list of

00:13:26,030 --> 00:13:30,770
outgoing edges and we do the simplest

00:13:28,280 --> 00:13:33,200
possible bad algorithm we have a list of

00:13:30,770 --> 00:13:33,889
all nodes that we visited a list that is

00:13:33,200 --> 00:13:37,519
the queue

00:13:33,889 --> 00:13:39,199
of nodes to visit and we simply go about

00:13:37,519 --> 00:13:43,069
our business traversing that queue and

00:13:39,199 --> 00:13:44,480
appending to it as needed and so we're

00:13:43,069 --> 00:13:47,329
going to do one little thing here is

00:13:44,480 --> 00:13:50,689
we're going to add type annotations to

00:13:47,329 --> 00:13:52,339
it from this typing module and so it's

00:13:50,689 --> 00:13:54,290
going to tell you all of the things that

00:13:52,339 --> 00:13:56,299
I just had to tell you in order to

00:13:54,290 --> 00:13:58,339
understand this algorithm the starting

00:13:56,299 --> 00:14:00,049
node is an integer the edges is a

00:13:58,339 --> 00:14:04,249
dictionary of integers to list of

00:14:00,049 --> 00:14:06,350
integers and it returns an iterator over

00:14:04,249 --> 00:14:08,720
integers and the only other thing that

00:14:06,350 --> 00:14:11,029
changed here as I had to annotate that

00:14:08,720 --> 00:14:13,009
visited is a list of integers because as

00:14:11,029 --> 00:14:15,649
an empty list this particular tool

00:14:13,009 --> 00:14:18,109
couldn't infer that but not nothing else

00:14:15,649 --> 00:14:21,499
had to pollute this code it's not it's

00:14:18,109 --> 00:14:24,980
not see or you know old C++ where I have

00:14:21,499 --> 00:14:26,929
to annotate visited and Q and node and

00:14:24,980 --> 00:14:28,850
and tell the compiler exactly what I

00:14:26,929 --> 00:14:32,509
expect it to be it can infer all the

00:14:28,850 --> 00:14:34,160
details and then what what I'm going to

00:14:32,509 --> 00:14:36,379
do is I'm going to make this algorithm a

00:14:34,160 --> 00:14:39,259
little bit more efficient so I know that

00:14:36,379 --> 00:14:42,290
that if I use a set for nodes that I

00:14:39,259 --> 00:14:45,679
visited and a double ended queue or deck

00:14:42,290 --> 00:14:49,069
for the queue then it's a more efficient

00:14:45,679 --> 00:14:50,779
algorithm because I it's not a linear

00:14:49,069 --> 00:14:53,929
traversal every time I look through it

00:14:50,779 --> 00:14:55,850
and so all I've done so far is I just

00:14:53,929 --> 00:14:58,239
changed the types the only changes I've

00:14:55,850 --> 00:15:00,439
made so far just these two lines and

00:14:58,239 --> 00:15:02,480
obviously this this isn't going to work

00:15:00,439 --> 00:15:05,089
because these data types don't implement

00:15:02,480 --> 00:15:06,829
the same methods so I run this my pie

00:15:05,089 --> 00:15:08,989
tool over it and it tells me exactly

00:15:06,829 --> 00:15:11,149
everything else I need to change to make

00:15:08,989 --> 00:15:13,790
this algorithm work and the only thing I

00:15:11,149 --> 00:15:16,879
had to do was what's change these two

00:15:13,790 --> 00:15:18,019
little lines just the types that's it

00:15:16,879 --> 00:15:19,339
and then it's going to tell me

00:15:18,019 --> 00:15:22,669
everything that's wrong with my program

00:15:19,339 --> 00:15:24,709
it says that on line 11 this deck has no

00:15:22,669 --> 00:15:28,910
attribute del item so that's that's

00:15:24,709 --> 00:15:31,699
right here and on line fourteen set has

00:15:28,910 --> 00:15:33,470
no append because it uses a different

00:15:31,699 --> 00:15:35,899
method name so i can simply look in the

00:15:33,470 --> 00:15:39,649
documentation and see what i need to

00:15:35,899 --> 00:15:44,119
change and so here here's the correct

00:15:39,649 --> 00:15:47,119
algorithm it's very very simple i just

00:15:44,119 --> 00:15:47,660
had to change this to a pop left and

00:15:47,119 --> 00:15:50,210
this to an

00:15:47,660 --> 00:15:52,040
now it works but my pie was able to tell

00:15:50,210 --> 00:15:56,480
me exactly where to look in the code to

00:15:52,040 --> 00:15:58,520
make that change and so is my pie the

00:15:56,480 --> 00:15:59,840
solution to this problem well you know

00:15:58,520 --> 00:16:02,090
it's the most sensible approach that

00:15:59,840 --> 00:16:05,420
I've seen so far but the author needs

00:16:02,090 --> 00:16:07,730
some help there are many tasks that that

00:16:05,420 --> 00:16:09,890
need to be done in my pie that don't

00:16:07,730 --> 00:16:11,780
really require deep knowledge of my pie

00:16:09,890 --> 00:16:13,820
itself or type systems such as

00:16:11,780 --> 00:16:17,120
annotating parts of the standard library

00:16:13,820 --> 00:16:19,760
or third-party libraries and although my

00:16:17,120 --> 00:16:21,950
pie does great stuff it doesn't yet

00:16:19,760 --> 00:16:24,140
catch the very simple integer plus

00:16:21,950 --> 00:16:25,700
string error yet but it can catch many

00:16:24,140 --> 00:16:30,410
other mistakes such as the one that i

00:16:25,700 --> 00:16:33,530
just showed and so why is pi PI or new

00:16:30,410 --> 00:16:35,390
it go scythe on or whatever not a

00:16:33,530 --> 00:16:37,130
solution of the problem well these

00:16:35,390 --> 00:16:38,900
projects are mostly concerned with just

00:16:37,130 --> 00:16:40,730
performance they don't really try and

00:16:38,900 --> 00:16:42,320
help you make your code more correct

00:16:40,730 --> 00:16:45,860
they don't they don't help with code

00:16:42,320 --> 00:16:47,630
quality but my pie I aim to do both but

00:16:45,860 --> 00:16:50,740
I think right now the important part is

00:16:47,630 --> 00:16:53,540
helping us improve our code quality and

00:16:50,740 --> 00:16:56,120
the nice thing is is that this is just

00:16:53,540 --> 00:16:58,700
Python 3 annotations that code runs

00:16:56,120 --> 00:17:01,700
exactly the same whether you're using my

00:16:58,700 --> 00:17:03,080
pie or Python 3 and Python 3 it's not

00:17:01,700 --> 00:17:05,570
going to do any of this type checking

00:17:03,080 --> 00:17:08,780
but the code works so it's fully

00:17:05,570 --> 00:17:11,630
portable to any Python 3 run time so my

00:17:08,780 --> 00:17:13,970
modest my pie proposal here is that we

00:17:11,630 --> 00:17:16,250
adopt this as a standard we should start

00:17:13,970 --> 00:17:19,880
using this typing module or you know

00:17:16,250 --> 00:17:22,010
some standard derived from it even in

00:17:19,880 --> 00:17:23,270
vanilla Python 3 like all the code in

00:17:22,010 --> 00:17:25,580
the standard library should have these

00:17:23,270 --> 00:17:26,960
annotations the documentation tools

00:17:25,580 --> 00:17:30,080
should be able to read these annotations

00:17:26,960 --> 00:17:32,600
and automatically right out nicely

00:17:30,080 --> 00:17:34,040
formatted documentation with hyperlinks

00:17:32,600 --> 00:17:36,350
for all the types and all this nice

00:17:34,040 --> 00:17:38,210
stuff and we we need to stop using

00:17:36,350 --> 00:17:40,250
function annotations for anything else

00:17:38,210 --> 00:17:42,560
as far as I understand they haven't been

00:17:40,250 --> 00:17:44,600
widely adopted for any other purpose so

00:17:42,560 --> 00:17:46,430
I think it's a good time to draw a line

00:17:44,600 --> 00:17:49,580
in the sand and say that function

00:17:46,430 --> 00:17:52,330
annotations are for type annotations and

00:17:49,580 --> 00:17:56,180
and just move forward with this proposal

00:17:52,330 --> 00:17:58,780
and you know help us improve pythons

00:17:56,180 --> 00:17:58,780
code quality

00:18:05,470 --> 00:18:10,720
and the nice thing is we don't we don't

00:18:08,620 --> 00:18:13,900
really have to rely on the quality of

00:18:10,720 --> 00:18:17,169
the mypie interpreter compiler or any of

00:18:13,900 --> 00:18:20,679
that fancy stuff we can just use it as a

00:18:17,169 --> 00:18:23,380
linting tool as just a step and just a

00:18:20,679 --> 00:18:26,110
set of tests to run over our code we can

00:18:23,380 --> 00:18:29,409
continue to use pi PI 3 or Python 3 or

00:18:26,110 --> 00:18:32,650
perhaps even the older Python vm once my

00:18:29,409 --> 00:18:34,510
pie is backported and what what you can

00:18:32,650 --> 00:18:38,260
do now is start contributing to my pie

00:18:34,510 --> 00:18:40,450
and and you know maybe write an official

00:18:38,260 --> 00:18:43,750
pep for for this proposal because I'm

00:18:40,450 --> 00:18:45,669
probably not going to do it and so so

00:18:43,750 --> 00:18:47,679
what well the code quality tools in

00:18:45,669 --> 00:18:50,500
Python are really far behind other

00:18:47,679 --> 00:18:53,260
languages you know I don't know what

00:18:50,500 --> 00:18:55,120
PyCharm does but I suspect that that

00:18:53,260 --> 00:18:59,559
it's not quite as good as Airlines

00:18:55,120 --> 00:19:01,539
dialyzer or you know Haskell and my pie

00:18:59,559 --> 00:19:03,400
is a huge step forward and it can be

00:19:01,539 --> 00:19:04,900
used with our existing tool chain the

00:19:03,400 --> 00:19:07,210
only thing we have to do is upgrade to

00:19:04,900 --> 00:19:08,590
Python 3 to make it work today and you

00:19:07,210 --> 00:19:09,940
know that's something that that we've

00:19:08,590 --> 00:19:12,580
all been trying to do for the past

00:19:09,940 --> 00:19:13,870
couple years and the only thing we'd

00:19:12,580 --> 00:19:15,520
have to give up is using function

00:19:13,870 --> 00:19:17,140
annotations for any other purpose and

00:19:15,520 --> 00:19:18,940
you know I don't think that's a big deal

00:19:17,140 --> 00:19:22,570
because I haven't really seen too many

00:19:18,940 --> 00:19:24,100
elsewhere and in a way without giving

00:19:22,570 --> 00:19:25,390
any meeting the function annotations

00:19:24,100 --> 00:19:27,730
it's hard to use them for anything at

00:19:25,390 --> 00:19:30,370
all except for some domain specific

00:19:27,730 --> 00:19:32,740
library specific purpose they're only

00:19:30,370 --> 00:19:34,059
truly useful if you can use them you

00:19:32,740 --> 00:19:39,100
know and all of the modules that you

00:19:34,059 --> 00:19:40,860
write and another thing that that I have

00:19:39,100 --> 00:19:43,419
trouble with and Python these days is

00:19:40,860 --> 00:19:46,150
mutability is just everywhere you can't

00:19:43,419 --> 00:19:48,610
turn it off and I think it's the wrong

00:19:46,150 --> 00:19:51,159
default it's a very very common source

00:19:48,610 --> 00:19:53,380
of bugs even even the the beginner case

00:19:51,159 --> 00:19:56,320
where where you're using default

00:19:53,380 --> 00:19:58,030
arguments and you you have some keyword

00:19:56,320 --> 00:20:01,419
arguments set to the empty list or an

00:19:58,030 --> 00:20:02,890
empty dictionary or empty set and you

00:20:01,419 --> 00:20:04,659
get behavior that you don't expect

00:20:02,890 --> 00:20:07,090
because people expect it to always be an

00:20:04,659 --> 00:20:08,110
empty set but you know if you add

00:20:07,090 --> 00:20:10,480
something to it it won't be empty

00:20:08,110 --> 00:20:14,049
anymore and it also prevents many

00:20:10,480 --> 00:20:15,909
optimizations you can't you can't do any

00:20:14,049 --> 00:20:17,559
multi-threaded stuff without locks if

00:20:15,909 --> 00:20:19,330
things are going to change all the time

00:20:17,559 --> 00:20:22,090
I in unpredictable

00:20:19,330 --> 00:20:26,200
ways and immutability should really be

00:20:22,090 --> 00:20:28,240
opt-in and so why why should it be

00:20:26,200 --> 00:20:29,740
opt-in well it sort of understand code

00:20:28,240 --> 00:20:31,960
when the underlying data might change

00:20:29,740 --> 00:20:33,670
you can reason about it locally but you

00:20:31,960 --> 00:20:35,410
really have no idea what else is going

00:20:33,670 --> 00:20:37,420
on especially in a multi-threaded

00:20:35,410 --> 00:20:39,720
environment the value of something could

00:20:37,420 --> 00:20:42,310
change from one line to the next and

00:20:39,720 --> 00:20:44,290
this means that you you either you

00:20:42,310 --> 00:20:46,600
either give up and just hope that nobody

00:20:44,290 --> 00:20:49,240
does anything bad or you do all kinds of

00:20:46,600 --> 00:20:53,620
defensive programming so any time you

00:20:49,240 --> 00:20:56,050
return a value from from your class say

00:20:53,620 --> 00:20:57,640
you're returning self dot value you're

00:20:56,050 --> 00:21:01,360
going to make sure that that value is a

00:20:57,640 --> 00:21:03,760
is a deep copy or you know something

00:21:01,360 --> 00:21:06,250
like that every time you you wrap it in

00:21:03,760 --> 00:21:07,510
some way or if you want to use it at key

00:21:06,250 --> 00:21:11,410
in a dictionary you have to just copy

00:21:07,510 --> 00:21:14,020
copy copy and copying is slow especially

00:21:11,410 --> 00:21:17,140
for large deep nested objects and

00:21:14,020 --> 00:21:19,390
sharing is prevented by copying unless

00:21:17,140 --> 00:21:22,420
these already happen to be immutable

00:21:19,390 --> 00:21:24,220
types like frozen sad or frozen

00:21:22,420 --> 00:21:27,460
or integers or strings or what have you

00:21:24,220 --> 00:21:29,500
and these days we care a lot about

00:21:27,460 --> 00:21:31,570
concurrent access and concurrent access

00:21:29,500 --> 00:21:36,130
require synchronization if everything is

00:21:31,570 --> 00:21:40,060
mutable all the time and so can we even

00:21:36,130 --> 00:21:41,740
fix this well I don't know because to

00:21:40,060 --> 00:21:44,620
truly fix this you're going to need some

00:21:41,740 --> 00:21:46,450
really large changes to the languages to

00:21:44,620 --> 00:21:48,280
the language in the libraries as we know

00:21:46,450 --> 00:21:50,350
because we've been trying to get rid of

00:21:48,280 --> 00:21:53,160
the Gil for longer than I've been using

00:21:50,350 --> 00:21:55,810
Python and it just hasn't worked so far

00:21:53,160 --> 00:21:57,790
but if if we're trying to fix this we

00:21:55,810 --> 00:22:00,040
can look towards languages like rust or

00:21:57,790 --> 00:22:03,490
Swift for good examples because these

00:22:00,040 --> 00:22:06,400
languages have opted-in mutability so in

00:22:03,490 --> 00:22:08,170
Swift for example if you use there then

00:22:06,400 --> 00:22:10,720
you're declaring a mutable variable but

00:22:08,170 --> 00:22:12,790
if use let then you're saying that that

00:22:10,720 --> 00:22:15,370
is a constant even even for a data

00:22:12,790 --> 00:22:17,560
structure like a dictionary or a set so

00:22:15,370 --> 00:22:22,690
maybe that's a bit more practical for

00:22:17,560 --> 00:22:24,550
Python to adopt and another thing that

00:22:22,690 --> 00:22:26,880
really gets me about python is that all

00:22:24,550 --> 00:22:29,860
of the abstractions are really expensive

00:22:26,880 --> 00:22:31,810
so some things like PI PI's jit can

00:22:29,860 --> 00:22:32,590
change some of the constant factors here

00:22:31,810 --> 00:22:35,110
and there

00:22:32,590 --> 00:22:37,240
but ultimately almost nothing is free

00:22:35,110 --> 00:22:39,309
function calls aren't free classes

00:22:37,240 --> 00:22:41,770
aren't free nothing gets optimized away

00:22:39,309 --> 00:22:45,010
so you're you're encouraged to inline

00:22:41,770 --> 00:22:47,770
code all over the place I and like you

00:22:45,010 --> 00:22:50,140
know make local references to Global's

00:22:47,770 --> 00:22:52,120
and and all this gnarly stuff like if

00:22:50,140 --> 00:22:54,159
you if you want to see what what this

00:22:52,120 --> 00:22:58,720
does to you go go look at the simple

00:22:54,159 --> 00:23:00,850
JSON code base because you know I I hate

00:22:58,720 --> 00:23:03,100
doing this all this in lining all this

00:23:00,850 --> 00:23:05,289
stuff because it's not fun and you don't

00:23:03,100 --> 00:23:07,270
want to do it with with decorators or

00:23:05,289 --> 00:23:10,539
AST manipulation or anything like that

00:23:07,270 --> 00:23:12,549
you just do it and it makes it more code

00:23:10,539 --> 00:23:14,380
that's harder to maintain but you do it

00:23:12,549 --> 00:23:16,299
because you get a 20-percent speed bump

00:23:14,380 --> 00:23:18,700
here a 20-percent speed bump there and

00:23:16,299 --> 00:23:21,279
you just live with it and and I really

00:23:18,700 --> 00:23:25,299
don't like that and the other thing is

00:23:21,279 --> 00:23:27,940
is that it classes in in Python are open

00:23:25,299 --> 00:23:29,679
you can always subclass them you can you

00:23:27,940 --> 00:23:31,990
can do all sorts of naughty things in

00:23:29,679 --> 00:23:35,200
classes and it makes it really hard to

00:23:31,990 --> 00:23:39,820
analyze them for correctness basically

00:23:35,200 --> 00:23:41,470
subclasses ruin everything and so a

00:23:39,820 --> 00:23:43,840
solution that other languages

00:23:41,470 --> 00:23:47,320
particularly the ML family of languages

00:23:43,840 --> 00:23:49,450
have come to is having a syntax to

00:23:47,320 --> 00:23:53,409
easily declare algebraic data types and

00:23:49,450 --> 00:23:57,340
so I'm not including Scala here so other

00:23:53,409 --> 00:23:59,500
languages do this reasonably and Python

00:23:57,340 --> 00:24:02,289
over the years has grown a lot of a lot

00:23:59,500 --> 00:24:07,299
of hacks to sort of give us some of this

00:24:02,289 --> 00:24:11,289
like the the new enums in Python 33 I

00:24:07,299 --> 00:24:13,600
think named tuple etc they all solve

00:24:11,289 --> 00:24:16,570
little pieces of this problem and even

00:24:13,600 --> 00:24:19,419
like the destructuring assignment in

00:24:16,570 --> 00:24:21,669
Python is sort of a subset of what you

00:24:19,419 --> 00:24:24,940
get with algebraic data types and other

00:24:21,669 --> 00:24:28,539
languages and so here's here's an

00:24:24,940 --> 00:24:31,690
example of what a typical problem looks

00:24:28,539 --> 00:24:34,179
like for a haskell developer say you're

00:24:31,690 --> 00:24:37,090
working with abstract syntax trees so

00:24:34,179 --> 00:24:39,520
here i am in Python I in order to say

00:24:37,090 --> 00:24:41,549
something is an abscess abstract syntax

00:24:39,520 --> 00:24:45,429
tree node I have to define this class

00:24:41,549 --> 00:24:46,210
all this class does is is define an eval

00:24:45,429 --> 00:24:49,120
method

00:24:46,210 --> 00:24:51,490
and then I have to define all of the

00:24:49,120 --> 00:24:53,410
different types of AST nodes so there's

00:24:51,490 --> 00:24:55,690
a constant which takes some integer

00:24:53,410 --> 00:24:58,210
there's this minus thing which is like a

00:24:55,690 --> 00:25:01,090
unary minus to negate the node and then

00:24:58,210 --> 00:25:02,740
I have to define add and multiply and

00:25:01,090 --> 00:25:05,350
you can see that that is quite a lot of

00:25:02,740 --> 00:25:08,950
code to do this when when ultimately it

00:25:05,350 --> 00:25:12,670
could be a lot simpler and so here's

00:25:08,950 --> 00:25:15,610
here's that whole thing in in Haskell so

00:25:12,670 --> 00:25:17,380
in Haskell I have the boilerplate to say

00:25:15,610 --> 00:25:19,720
oh hey this is a module in this would it

00:25:17,380 --> 00:25:21,490
exports so in Python I would have done

00:25:19,720 --> 00:25:23,740
that with under under all but I didn't

00:25:21,490 --> 00:25:25,930
really have room for it and here I'm

00:25:23,740 --> 00:25:28,060
just clearing all of the different types

00:25:25,930 --> 00:25:31,390
of AST nodes there's a constant node

00:25:28,060 --> 00:25:33,820
there's an ad node- and multiply and all

00:25:31,390 --> 00:25:36,070
that is very succinctly described I can

00:25:33,820 --> 00:25:38,230
look at this and I can see oh these are

00:25:36,070 --> 00:25:41,110
all of the things in AST can be if i

00:25:38,230 --> 00:25:42,550
look at the python I look oh maybe I

00:25:41,110 --> 00:25:44,410
should grep this code base to see if

00:25:42,550 --> 00:25:46,180
anything else subclasses AST anywhere

00:25:44,410 --> 00:25:47,350
you don't have to do that in haskell

00:25:46,180 --> 00:25:49,900
it's closed these are the only

00:25:47,350 --> 00:25:52,360
possibilities here there are ways to do

00:25:49,900 --> 00:25:55,120
extensibility but you don't always need

00:25:52,360 --> 00:25:57,250
that and it's it's harmful if you have

00:25:55,120 --> 00:25:59,380
that all the time because you can't you

00:25:57,250 --> 00:26:03,850
can't analyze this to say oh you didn't

00:25:59,380 --> 00:26:06,630
you didn't implement a evaluation four-

00:26:03,850 --> 00:26:09,610
or add it can't do that statically and

00:26:06,630 --> 00:26:12,160
so here's here's the whole evaluator in

00:26:09,610 --> 00:26:14,530
haskell you typically don't do this with

00:26:12,160 --> 00:26:16,750
separate functions for each type of node

00:26:14,530 --> 00:26:18,790
you just do it in one function and the

00:26:16,750 --> 00:26:22,240
compiler can tell me that I handled all

00:26:18,790 --> 00:26:25,360
these functions appropriately but the

00:26:22,240 --> 00:26:27,700
cool thing is is that in Haskell here it

00:26:25,360 --> 00:26:31,000
can do a lot for me so here I'm saying

00:26:27,700 --> 00:26:32,860
deriving show and eat and so what this

00:26:31,000 --> 00:26:34,660
does is it automatically writes the code

00:26:32,860 --> 00:26:38,230
for me to make sure that these have a

00:26:34,660 --> 00:26:41,350
sensible repper and implements like

00:26:38,230 --> 00:26:44,470
under under eq in a reasonable way so if

00:26:41,350 --> 00:26:46,390
I were to do that in Python this is what

00:26:44,470 --> 00:26:49,900
it would look like for just that one

00:26:46,390 --> 00:26:52,210
specific node so so in Haskell here I

00:26:49,900 --> 00:26:55,210
have this amount of code to solve the

00:26:52,210 --> 00:26:57,490
whole problem but in Python it's that

00:26:55,210 --> 00:27:00,220
much code to solve the problem for just

00:26:57,490 --> 00:27:01,929
one particular node so it's it's very

00:27:00,220 --> 00:27:03,970
difficult for for me to go back to

00:27:01,929 --> 00:27:06,600
python and work on these types of

00:27:03,970 --> 00:27:10,390
problems without ripping my hair out

00:27:06,600 --> 00:27:12,220
because python just gets in my way and

00:27:10,390 --> 00:27:16,720
and none of the tools can tell me if

00:27:12,220 --> 00:27:20,650
i've done it right and the other thing

00:27:16,720 --> 00:27:23,440
is is that in haskell we often write a

00:27:20,650 --> 00:27:25,570
lot of abstractions and we know that the

00:27:23,440 --> 00:27:27,549
compiler can unroll those those

00:27:25,570 --> 00:27:29,440
abstractions for us you can use

00:27:27,549 --> 00:27:31,600
something called new type to just make a

00:27:29,440 --> 00:27:35,260
wrapper around a data type that totally

00:27:31,600 --> 00:27:38,289
evaporates at runtime so if you say have

00:27:35,260 --> 00:27:40,210
a float in your library that really

00:27:38,289 --> 00:27:43,659
means time and you don't want to be able

00:27:40,210 --> 00:27:47,470
to add time to pounds and have it

00:27:43,659 --> 00:27:50,950
succeed you can wrap the float for time

00:27:47,470 --> 00:27:53,500
in a new type that that doesn't allow

00:27:50,950 --> 00:27:56,320
you to interface with other types

00:27:53,500 --> 00:27:58,570
without unwrapping it first and this is

00:27:56,320 --> 00:28:00,669
also used for things like like boolean's

00:27:58,570 --> 00:28:03,039
and whatnot so although there is a

00:28:00,669 --> 00:28:05,590
representation for true and false that

00:28:03,039 --> 00:28:08,860
that are 1 and 0 appropriately you have

00:28:05,590 --> 00:28:11,409
to unwrap that with with from enum so

00:28:08,860 --> 00:28:14,440
there's no reason to have code like 1

00:28:11,409 --> 00:28:17,590
plus true equals 2 in haskell because

00:28:14,440 --> 00:28:20,559
you can you can have this very efficient

00:28:17,590 --> 00:28:23,590
representation and without paying all

00:28:20,559 --> 00:28:25,120
this cost all the time and the other

00:28:23,590 --> 00:28:27,549
thing that that languages like Haskell

00:28:25,120 --> 00:28:30,309
can do is is in these abstract data

00:28:27,549 --> 00:28:33,039
types if it sees that the feel districts

00:28:30,309 --> 00:28:36,429
or you know meets the appropriate

00:28:33,039 --> 00:28:38,289
criteria it can unbox it and this is

00:28:36,429 --> 00:28:40,510
something that that is very hard to do

00:28:38,289 --> 00:28:43,840
in Python you can get a little bit of it

00:28:40,510 --> 00:28:46,780
with pi PI and and you can erase some of

00:28:43,840 --> 00:28:48,970
the costs using slots and stuff but but

00:28:46,780 --> 00:28:50,559
with the like Haskell or Swift or

00:28:48,970 --> 00:28:51,909
whatever you just get all this stuff for

00:28:50,559 --> 00:28:55,210
free you don't have to think about it

00:28:51,909 --> 00:28:57,520
and even function calls can be in line

00:28:55,210 --> 00:28:59,350
so you can you can write small functions

00:28:57,520 --> 00:29:00,820
that abstract little bits of code and

00:28:59,350 --> 00:29:03,190
you know that you're not going to pay

00:29:00,820 --> 00:29:06,880
for it because the inlining actually

00:29:03,190 --> 00:29:11,110
works even cross module although you do

00:29:06,880 --> 00:29:13,330
get some of this with pie pie and so on

00:29:11,110 --> 00:29:14,020
the performance topic i'm not going to

00:29:13,330 --> 00:29:16,330
focus

00:29:14,020 --> 00:29:18,220
too much on that because everything I've

00:29:16,330 --> 00:29:20,890
talked about provides more ahead of time

00:29:18,220 --> 00:29:22,990
information and this information could

00:29:20,890 --> 00:29:27,130
be used by tools like pi PI numbaa

00:29:22,990 --> 00:29:28,600
scythe on my pie etc and the important

00:29:27,130 --> 00:29:30,580
part is that these features save

00:29:28,600 --> 00:29:34,240
developer time by making it easier to

00:29:30,580 --> 00:29:36,730
write code but also this information can

00:29:34,240 --> 00:29:39,580
also be used for optimization and it can

00:29:36,730 --> 00:29:41,590
lead to better performance and the the

00:29:39,580 --> 00:29:43,690
trick here is is that once it's easier

00:29:41,590 --> 00:29:45,970
to write better code it's easier to

00:29:43,690 --> 00:29:48,430
optimize it because you can refactor it

00:29:45,970 --> 00:29:51,520
and you can have these types guide you

00:29:48,430 --> 00:29:53,470
to correct implementations and the other

00:29:51,520 --> 00:29:57,610
thing is is we really need to write less

00:29:53,470 --> 00:29:59,350
code in C and C++ because this is this

00:29:57,610 --> 00:30:01,570
is what holds us back this is why it's

00:29:59,350 --> 00:30:04,240
hard to remove the Gil because we all

00:30:01,570 --> 00:30:07,800
depend on numpy or whatever and these

00:30:04,240 --> 00:30:10,450
these api's are written in C and they

00:30:07,800 --> 00:30:12,550
need to work with the reference counting

00:30:10,450 --> 00:30:15,730
and acquire the gill and release the

00:30:12,550 --> 00:30:18,240
gill and when we're held back by that

00:30:15,730 --> 00:30:20,740
it's very difficult to change anything

00:30:18,240 --> 00:30:22,960
but when we have implementations of all

00:30:20,740 --> 00:30:25,150
these things in pure python it's much

00:30:22,960 --> 00:30:28,030
much easier to change the semantics so

00:30:25,150 --> 00:30:30,870
thank you pi PI for for spending all of

00:30:28,030 --> 00:30:36,180
this effort over the past decade or so

00:30:30,870 --> 00:30:36,180
making this even reasonable today

00:30:42,860 --> 00:30:52,289
and so unfortunately for for the same

00:30:48,019 --> 00:30:54,179
basic reasons the Python capi is really

00:30:52,289 --> 00:30:56,549
holding us back from doing concurrency

00:30:54,179 --> 00:30:58,230
properly it's not even something I can

00:30:56,549 --> 00:30:59,580
talk about solving until some of these

00:30:58,230 --> 00:31:02,190
other things are addressed like

00:30:59,580 --> 00:31:05,669
mutability and and not depending so much

00:31:02,190 --> 00:31:07,710
on these see libraries and but once we

00:31:05,669 --> 00:31:09,330
do those things then fixing the other

00:31:07,710 --> 00:31:12,029
deficiencies are going to be possible

00:31:09,330 --> 00:31:14,070
but you know they're there is somewhat

00:31:12,029 --> 00:31:16,110
of a silver lining here it's been shown

00:31:14,070 --> 00:31:18,419
that it's possible to have a mixed

00:31:16,110 --> 00:31:22,169
approach where you you write code in a

00:31:18,419 --> 00:31:24,419
subset of Python like pie parallel where

00:31:22,169 --> 00:31:28,159
that subset of Python can be compiled

00:31:24,419 --> 00:31:34,649
and work completely independently of the

00:31:28,159 --> 00:31:38,610
typical Python vm object system and so

00:31:34,649 --> 00:31:40,559
in summary i really think that we should

00:31:38,610 --> 00:31:42,539
look long and hard at incorporating all

00:31:40,559 --> 00:31:44,909
the good ideas for my pie in a python

00:31:42,539 --> 00:31:50,129
possibly even just the implementation as

00:31:44,909 --> 00:31:51,720
is and after that we can add some more

00:31:50,129 --> 00:31:53,999
of the conveniences that we find from

00:31:51,720 --> 00:31:55,619
other modern languages and to do that

00:31:53,999 --> 00:31:58,710
some of us are going to have to learn

00:31:55,619 --> 00:32:01,980
languages like Haskell or Erlang or ml

00:31:58,710 --> 00:32:05,100
or Swift or F sharp and actually come

00:32:01,980 --> 00:32:07,559
back to Python but it is a worthy

00:32:05,100 --> 00:32:09,360
endeavor even if you don't go back to

00:32:07,559 --> 00:32:12,480
python I highly recommend learning other

00:32:09,360 --> 00:32:15,570
languages I have learned so much by

00:32:12,480 --> 00:32:17,190
branching out a bit and if we manage to

00:32:15,570 --> 00:32:20,159
do some of these things then we can we

00:32:17,190 --> 00:32:25,999
can enjoy a safer faster and much more

00:32:20,159 --> 00:32:25,999
capable Python in the future and thank

00:32:38,630 --> 00:32:43,919
so thank you pop for the very honest

00:32:41,640 --> 00:32:46,350
analysis I think typically at Piper

00:32:43,919 --> 00:32:48,330
conferences you get a lot of you know

00:32:46,350 --> 00:32:50,580
hailing how great pie fulness and all

00:32:48,330 --> 00:32:53,280
this and I think it's Android was very

00:32:50,580 --> 00:32:55,169
much to ever come a long term Python

00:32:53,280 --> 00:32:59,330
user and also involved in other

00:32:55,169 --> 00:33:04,110
languages to get this honest analysis so

00:32:59,330 --> 00:33:05,610
questions to Bob yes Mike yep I got a

00:33:04,110 --> 00:33:07,350
question because i'm loading Haskell

00:33:05,610 --> 00:33:09,360
myself do you think it would be feasible

00:33:07,350 --> 00:33:10,620
to use Haskell as extension legging

00:33:09,360 --> 00:33:13,650
fruit pies and writing all those things

00:33:10,620 --> 00:33:15,960
currency recursive nurse trees their

00:33:13,650 --> 00:33:18,450
task is very good and writing extensions

00:33:15,960 --> 00:33:21,870
and really make them nice pison objects

00:33:18,450 --> 00:33:25,740
do you think it's possible I think it is

00:33:21,870 --> 00:33:27,960
possible certainly all of the FFI that

00:33:25,740 --> 00:33:32,100
you would need is exposed by Haskell to

00:33:27,960 --> 00:33:35,400
do that I'm not aware of any library

00:33:32,100 --> 00:33:37,440
that makes that particularly easy most

00:33:35,400 --> 00:33:38,940
of the effort is kind of the other way

00:33:37,440 --> 00:33:41,130
around where you're writing code in

00:33:38,940 --> 00:33:42,840
Haskell and you want to interface with C

00:33:41,130 --> 00:33:47,130
or objective c or something along those

00:33:42,840 --> 00:33:50,220
lines so unfortunately I think the

00:33:47,130 --> 00:33:54,990
upfront cost would be high to write all

00:33:50,220 --> 00:33:58,710
of the code to to expose Haskell ADT's

00:33:54,990 --> 00:34:01,500
as nice Python objects but if you were

00:33:58,710 --> 00:34:03,720
to do something that was a little more

00:34:01,500 --> 00:34:06,030
decoupled where maybe you're expecting

00:34:03,720 --> 00:34:06,990
primitive values in primitive values out

00:34:06,030 --> 00:34:11,010
that that would be a lot more

00:34:06,990 --> 00:34:14,190
straightforward to implement but I think

00:34:11,010 --> 00:34:16,230
that that as a learning exercise that

00:34:14,190 --> 00:34:19,470
might be a bit tricky like diving into

00:34:16,230 --> 00:34:22,619
the FFI and how to cross these barriers

00:34:19,470 --> 00:34:26,339
I think it's much more reasonable to try

00:34:22,619 --> 00:34:28,679
and learn Haskell in isolation may be

00:34:26,339 --> 00:34:32,599
speaking over a network to python rather

00:34:28,679 --> 00:34:32,599
than linking to it as a sea extension

00:34:32,990 --> 00:34:40,320
yes I'm just a small comment about the

00:34:37,260 --> 00:34:42,510
static analysis thing and Chad I is

00:34:40,320 --> 00:34:45,899
going to be able to find most of those

00:34:42,510 --> 00:34:48,450
bucks you presented and it's very new so

00:34:45,899 --> 00:34:50,080
you can't know it but still what I'm

00:34:48,450 --> 00:34:51,970
going to talk about it on wednesday

00:34:50,080 --> 00:34:58,510
okay great i'll have to come to that

00:34:51,970 --> 00:35:04,660
talk thank you hi thank you for the talk

00:34:58,510 --> 00:35:09,730
I just wanted to share some I see some

00:35:04,660 --> 00:35:12,190
correlation between the dynamism of a

00:35:09,730 --> 00:35:17,110
language and the size of its community

00:35:12,190 --> 00:35:20,200
if you look at JavaScript Python avian

00:35:17,110 --> 00:35:22,960
PHP they're all dynamic languages with

00:35:20,200 --> 00:35:27,880
huge communities and if you look at the

00:35:22,960 --> 00:35:31,390
say scalar Haskell Arang they are like

00:35:27,880 --> 00:35:35,320
very small tight community do it very

00:35:31,390 --> 00:35:37,540
correct very people focused on good

00:35:35,320 --> 00:35:42,010
programming practice but also incorrect

00:35:37,540 --> 00:35:44,050
now maybe there is some relation may

00:35:42,010 --> 00:35:46,450
solving in in the fact that they are

00:35:44,050 --> 00:35:50,550
dynamic that makes their communities

00:35:46,450 --> 00:35:56,040
grow so so fast and so lively so maybe

00:35:50,550 --> 00:35:56,040
by proposing more static approach

00:35:56,220 --> 00:36:01,510
introducing that Woods would actually

00:35:58,600 --> 00:36:03,880
hurt the community site something to

00:36:01,510 --> 00:36:05,770
think about I think that's that's

00:36:03,880 --> 00:36:08,290
certainly an interesting consideration

00:36:05,770 --> 00:36:12,370
but there are some very easy counter

00:36:08,290 --> 00:36:15,640
examples such as C or Java or C++ which

00:36:12,370 --> 00:36:19,080
have presumably larger communities than

00:36:15,640 --> 00:36:23,160
than many of the ones that you cited and

00:36:19,080 --> 00:36:27,670
hear what I'm proposing is not mandatory

00:36:23,160 --> 00:36:30,790
it is opt in full dynamism is still

00:36:27,670 --> 00:36:32,590
permitted it's it's simply encouraged to

00:36:30,790 --> 00:36:36,430
add these annotations where their

00:36:32,590 --> 00:36:39,640
possible and sensible and anything else

00:36:36,430 --> 00:36:41,320
would be simply inferred so it's not

00:36:39,640 --> 00:36:44,830
like C or Java where you have to write

00:36:41,320 --> 00:36:47,050
it everywhere it's more like the ML

00:36:44,830 --> 00:36:49,600
family of languages where where it just

00:36:47,050 --> 00:36:51,580
happens and I think they're there are

00:36:49,600 --> 00:36:53,260
other reasons that have nothing to do

00:36:51,580 --> 00:36:55,840
with the type system why those

00:36:53,260 --> 00:37:01,000
particular communities are smaller or

00:36:55,840 --> 00:37:03,100
larger than than others thank you I have

00:37:01,000 --> 00:37:03,790
a question myself also because I'm

00:37:03,100 --> 00:37:06,100
involved

00:37:03,790 --> 00:37:09,640
in testing and functional testing of

00:37:06,100 --> 00:37:12,430
systems to me it always felt that you

00:37:09,640 --> 00:37:14,200
have for any sufficiently large system

00:37:12,430 --> 00:37:17,230
you anyway have to do some kind of

00:37:14,200 --> 00:37:18,490
testing right and absolutely and you

00:37:17,230 --> 00:37:20,200
want to make sure that you have some

00:37:18,490 --> 00:37:23,350
kind of coverage on your code so

00:37:20,200 --> 00:37:25,270
actually your code lines touched and as

00:37:23,350 --> 00:37:27,580
soon as you have something like that

00:37:25,270 --> 00:37:29,440
like a test suite like you test the

00:37:27,580 --> 00:37:31,840
behavior not just the types but much

00:37:29,440 --> 00:37:34,840
more than just the types you get as a

00:37:31,840 --> 00:37:39,910
side effect the typesetting so your

00:37:34,840 --> 00:37:42,940
example of like the integra 1 + string 1

00:37:39,910 --> 00:37:45,160
would easily cause an error in this test

00:37:42,940 --> 00:37:48,640
feed but the tests also provide much

00:37:45,160 --> 00:37:50,770
more so basically my question is if you

00:37:48,640 --> 00:37:52,660
have a more powerful type system of

00:37:50,770 --> 00:37:54,730
which I can see the use of course you

00:37:52,660 --> 00:37:56,650
still have to write tests so you

00:37:54,730 --> 00:37:58,480
basically have to add more overhead and

00:37:56,650 --> 00:38:01,140
strictness there and you have to write

00:37:58,480 --> 00:38:04,660
your test suite so are you actually

00:38:01,140 --> 00:38:06,610
gaining that much I I think that that's

00:38:04,660 --> 00:38:08,500
an interesting point to bring up of

00:38:06,610 --> 00:38:10,630
course you would you would write tests

00:38:08,500 --> 00:38:14,050
but you no longer have to write so many

00:38:10,630 --> 00:38:15,580
of the obvious tests and in in languages

00:38:14,050 --> 00:38:18,610
where you do have these annotations

00:38:15,580 --> 00:38:23,250
available there are tools that can

00:38:18,610 --> 00:38:26,410
either exhaustively or like randomly

00:38:23,250 --> 00:38:30,070
generate input like basically it writes

00:38:26,410 --> 00:38:32,710
fuzz for free so in haskell i can i can

00:38:30,070 --> 00:38:35,980
write a quick check property based only

00:38:32,710 --> 00:38:38,680
on the types that will generate you know

00:38:35,980 --> 00:38:41,470
small inputs big inputs randomly to try

00:38:38,680 --> 00:38:44,080
and find errors and those tests are much

00:38:41,470 --> 00:38:49,560
much shorter to write because this

00:38:44,080 --> 00:38:53,050
information is available and the the

00:38:49,560 --> 00:38:55,420
advantage is is that it tells you what

00:38:53,050 --> 00:38:58,450
tests you need to write and additionally

00:38:55,420 --> 00:39:01,690
like say for example you have a library

00:38:58,450 --> 00:39:03,310
that accepts some input as jason and you

00:39:01,690 --> 00:39:04,720
you write the test for okay what if the

00:39:03,310 --> 00:39:07,270
input is a list what at the input is a

00:39:04,720 --> 00:39:09,160
dictionary what if the input is an

00:39:07,270 --> 00:39:11,650
integer but you forget to test what if

00:39:09,160 --> 00:39:13,780
the input is a float right but the types

00:39:11,650 --> 00:39:15,390
because they're there are separate types

00:39:13,780 --> 00:39:19,079
for each of these things

00:39:15,390 --> 00:39:20,400
you can look at you can try and compile

00:39:19,079 --> 00:39:21,960
it with something like Haskell and it

00:39:20,400 --> 00:39:25,260
can tell you that you don't have a case

00:39:21,960 --> 00:39:26,819
for floats so you can very easily write

00:39:25,260 --> 00:39:30,029
a lot of tests and get a lot of coverage

00:39:26,819 --> 00:39:31,859
in in Python and but miss these these

00:39:30,029 --> 00:39:36,150
cases that the type checker is going to

00:39:31,859 --> 00:39:38,700
catch and the these type annotations are

00:39:36,150 --> 00:39:42,180
very succinct you don't have to write

00:39:38,700 --> 00:39:44,190
many of them basically just in the

00:39:42,180 --> 00:39:47,369
arguments to your functions and and you

00:39:44,190 --> 00:39:51,240
end up writing that anyway in in some

00:39:47,369 --> 00:39:53,849
less principled a doc string format

00:39:51,240 --> 00:39:55,470
somewhere because the user of your

00:39:53,849 --> 00:39:58,140
system has to know what goes where

00:39:55,470 --> 00:40:01,140
anyway so this is just moving that that

00:39:58,140 --> 00:40:03,690
information into something that is

00:40:01,140 --> 00:40:08,369
actually verified either at compile time

00:40:03,690 --> 00:40:10,859
or runtime or both no thank you yeah and

00:40:08,369 --> 00:40:13,799
if you love I would just like to expand

00:40:10,859 --> 00:40:15,359
on your answer and another thing of your

00:40:13,799 --> 00:40:19,099
question and it's not only the

00:40:15,359 --> 00:40:21,299
correctness and testing that where's the

00:40:19,099 --> 00:40:23,490
extended typing helps but also the

00:40:21,299 --> 00:40:24,990
documentation of the problem at the

00:40:23,490 --> 00:40:26,309
program programs become much more

00:40:24,990 --> 00:40:28,559
maintainable when the developer

00:40:26,309 --> 00:40:30,150
immediately sees what type is returned

00:40:28,559 --> 00:40:31,829
and what type is expected of any

00:40:30,150 --> 00:40:33,779
arguments that go into the fraction the

00:40:31,829 --> 00:40:36,720
function that makes a development much

00:40:33,779 --> 00:40:39,450
more well-well easier and also it allows

00:40:36,720 --> 00:40:41,640
a tools to understand programs to

00:40:39,450 --> 00:40:43,140
dalhousie tools to navigate the program

00:40:41,640 --> 00:40:45,960
much more quickly like you can do in

00:40:43,140 --> 00:40:49,680
visual c or probably a charm or a idea

00:40:45,960 --> 00:40:52,230
etc in Eclipse so it helps develop much

00:40:49,680 --> 00:40:54,480
better tools that allow you to program

00:40:52,230 --> 00:40:56,549
much more efficiently it's not only the

00:40:54,480 --> 00:40:58,950
correctness part that's just my two

00:40:56,549 --> 00:41:03,720
cents yes thank you that is absolutely

00:40:58,950 --> 00:41:05,609
correct okay then thank you again Bob

00:41:03,720 --> 00:41:08,569
you're just directly going to start yes

00:41:05,609 --> 00:41:08,569
sorry thank you Bob

00:41:12,800 --> 00:41:15,940

YouTube URL: https://www.youtube.com/watch?v=pJOmlFf5Je4


