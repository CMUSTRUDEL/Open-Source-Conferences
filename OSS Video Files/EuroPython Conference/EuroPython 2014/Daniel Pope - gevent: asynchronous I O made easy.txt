Title: Daniel Pope - gevent: asynchronous I O made easy
Publication date: 2015-04-18
Playlist: EuroPython 2014
Description: 
	Daniel Pope - gevent: asynchronous I/O made easy
[EuroPython 2014]
[23 July 2014]

gevent provides highly scalable asynchronous I/O without becoming a nest of callbacks, or even needing code changes.
Daniel will explain how to get started with gevent, discuss patterns for its use and describe the differences with Twisted, Tornado and Tulip/asyncio.

-----

It has been claimed "Callbacks are the new GOTO". Most asynchronous IO libraries use callbacks extensively.

gevent (http://www.gevent.org) uses coroutines to provide highly scalable asynchronous I/O with a synchronous programming model that doesn't need code changes and callbacks. By elegantly monkey patching the Python standard library, both your code and all pure Python libraries become asynchronous too, making a separate collection of protocol implementations (in the style of Twisted) unnecessary.

Code written like this is easier to understand, particularly for more junior developers. Crucially, IO errors can be raised at the right places.

I will be introducing gevent's programming model, why it's easier, walk through simple code samples, and discuss experiences and metaphors for programming with it.
Captions: 
	00:00:15,699 --> 00:00:20,670
okay I guess

00:00:18,120 --> 00:00:23,840
Thanks coming of a ring my name is

00:00:20,670 --> 00:00:27,780
Daniel Pope I'm a web developer and

00:00:23,840 --> 00:00:30,120
delp's enthusiast and for the past few

00:00:27,780 --> 00:00:33,420
years I've been doing contracts doing

00:00:30,120 --> 00:00:35,730
sort of development and network systems

00:00:33,420 --> 00:00:37,830
back-end systems that kind of thing so

00:00:35,730 --> 00:00:41,010
I'm here to talk about G event g event

00:00:37,830 --> 00:00:44,180
as a framework for asynchronous i/o with

00:00:41,010 --> 00:00:47,070
a fully synchronous programming model so

00:00:44,180 --> 00:00:50,610
you may be familiar with things like

00:00:47,070 --> 00:00:56,309
tornado and twisted and the new async io

00:00:50,610 --> 00:00:58,199
in Python 3.3 and 3.4 and G event is a

00:00:56,309 --> 00:01:01,559
sort of direct competitor to that and I

00:00:58,199 --> 00:01:04,320
hope to demonstrate that it's easier to

00:01:01,559 --> 00:01:09,720
use and more flexible than any of those

00:01:04,320 --> 00:01:14,400
things so where this talk is going so

00:01:09,720 --> 00:01:16,590
first of all we'll meet G event and see

00:01:14,400 --> 00:01:18,840
some examples and then I'm going to

00:01:16,590 --> 00:01:24,480
discuss the theory behind G event and

00:01:18,840 --> 00:01:26,430
the the other so tornado interested in a

00:01:24,480 --> 00:01:29,940
cinco and how they compare and the

00:01:26,430 --> 00:01:31,980
programming models involved and then my

00:01:29,940 --> 00:01:37,560
talk briefly about my experiences with g

00:01:31,980 --> 00:01:40,980
event so asynchronous or aventador

00:01:37,560 --> 00:01:43,700
non-blocking i/o is any form of strategy

00:01:40,980 --> 00:01:48,210
for writing network programs where

00:01:43,700 --> 00:01:50,370
instead of blocking and your program

00:01:48,210 --> 00:01:52,860
suspending and waiting for a response

00:01:50,370 --> 00:01:54,720
for the i/o operation that you've

00:01:52,860 --> 00:01:57,450
requested the program goes away it does

00:01:54,720 --> 00:02:01,010
something else and resumes to the point

00:01:57,450 --> 00:02:06,530
that it resumes executing your code

00:02:01,010 --> 00:02:09,780
after the i/o operation is completed so

00:02:06,530 --> 00:02:15,050
diving into g event this is a very

00:02:09,780 --> 00:02:15,050
simple FG event program so

00:02:16,760 --> 00:02:23,659
to talk through the code the only G of n

00:02:19,939 --> 00:02:26,569
component we're using here is the stream

00:02:23,659 --> 00:02:30,140
server we pass in a connection handler

00:02:26,569 --> 00:02:34,519
and then for any connection that is

00:02:30,140 --> 00:02:38,780
received on that port the connection

00:02:34,519 --> 00:02:42,920
handler is called make filers a feature

00:02:38,780 --> 00:02:45,440
of socket and obviously so we're just

00:02:42,920 --> 00:02:47,269
echoing back lines so it make the file

00:02:45,440 --> 00:02:49,370
turns it into a file like object can

00:02:47,269 --> 00:02:51,890
iterate that the lines and send the back

00:02:49,370 --> 00:02:53,359
over the same socket so that's very

00:02:51,890 --> 00:02:58,790
similar to the code that you might write

00:02:53,359 --> 00:03:02,090
with with plain plain Python before 3.3

00:02:58,790 --> 00:03:05,180
if you're picking up a cinco accept that

00:03:02,090 --> 00:03:07,629
some magic happens so that is highly

00:03:05,180 --> 00:03:13,760
scalable so we'll talk about the magic

00:03:07,629 --> 00:03:17,450
later this is so this is a client that

00:03:13,760 --> 00:03:22,400
uses G event and what we're using here

00:03:17,450 --> 00:03:27,739
is your L lib to read 100 URLs on a pool

00:03:22,400 --> 00:03:29,959
of 20 thread like objects greenland's so

00:03:27,739 --> 00:03:32,419
those things are happening more or less

00:03:29,959 --> 00:03:34,669
in parallel so that when the somewhere

00:03:32,419 --> 00:03:39,590
in the middle of you you are a Lib your

00:03:34,669 --> 00:03:42,739
LM to we access a URL it does some some

00:03:39,590 --> 00:03:44,629
blocking to read data from that URL but

00:03:42,739 --> 00:03:46,340
while that's happening and while data is

00:03:44,629 --> 00:03:49,400
being received other things are

00:03:46,340 --> 00:03:52,849
scheduled and run so the clever thing

00:03:49,400 --> 00:03:56,019
here apart from that so this pool object

00:03:52,849 --> 00:03:58,910
is that we are able to use your a Lib to

00:03:56,019 --> 00:04:01,459
unmodified because of the first two

00:03:58,910 --> 00:04:05,209
lines where we do some clever monkey

00:04:01,459 --> 00:04:08,530
patching and people keep saying oh

00:04:05,209 --> 00:04:12,409
monkey patching that's a bit nasty and

00:04:08,530 --> 00:04:14,419
I'll explain a bit later why I think

00:04:12,409 --> 00:04:19,699
it's is actually rather elegant robin

00:04:14,419 --> 00:04:21,769
rather ugly so another example I

00:04:19,699 --> 00:04:23,599
actually had I could execute these

00:04:21,769 --> 00:04:25,880
examples but we probably don't have time

00:04:23,599 --> 00:04:28,580
and the network yeah might not be

00:04:25,880 --> 00:04:29,750
working so it an echo server is not

00:04:28,580 --> 00:04:34,880
particularly fascinating

00:04:29,750 --> 00:04:35,930
a chat server more so but but yeah you

00:04:34,880 --> 00:04:41,690
would probably probably wouldn't be able

00:04:35,930 --> 00:04:43,520
to connect to my machine so what's

00:04:41,690 --> 00:04:47,030
happening here we've got a reader and

00:04:43,520 --> 00:04:49,280
writer well greenland's effectively so

00:04:47,030 --> 00:04:52,460
what we're going to do is run each of

00:04:49,280 --> 00:04:54,440
those reader and writer objects in a

00:04:52,460 --> 00:04:57,880
single green lit so they will be

00:04:54,440 --> 00:05:01,610
happening effectively concurrently and

00:04:57,880 --> 00:05:04,010
the reader is just reading lines from a

00:05:01,610 --> 00:05:06,710
file and rebroadcasting them we've got a

00:05:04,010 --> 00:05:11,120
system of cues so that a broadcast can

00:05:06,710 --> 00:05:13,010
go to all of the subscribe users and the

00:05:11,120 --> 00:05:15,830
second part of this is the code that

00:05:13,010 --> 00:05:18,440
hooks it together so after receiving

00:05:15,830 --> 00:05:19,820
connection again this is sort of hosted

00:05:18,440 --> 00:05:22,850
with the the streaming server after

00:05:19,820 --> 00:05:24,980
receiving a connection we turn it into a

00:05:22,850 --> 00:05:27,590
file read name as a function that I've

00:05:24,980 --> 00:05:29,390
not included in this where we just read

00:05:27,590 --> 00:05:33,130
one line that is your username and loop

00:05:29,390 --> 00:05:35,750
until it's a valid username and then

00:05:33,130 --> 00:05:37,940
create a queue for the user and split

00:05:35,750 --> 00:05:39,950
out onto to green let's to actually just

00:05:37,940 --> 00:05:42,980
do one direction of the the

00:05:39,950 --> 00:05:48,520
communication at a time and the joint

00:05:42,980 --> 00:05:51,200
all and the tri finally ensure that the

00:05:48,520 --> 00:05:53,150
those green let's when they because

00:05:51,200 --> 00:05:55,400
green let's raise an exception if the

00:05:53,150 --> 00:06:01,640
connection is lost it will just remove

00:05:55,400 --> 00:06:05,750
the user when the connection is lost so

00:06:01,640 --> 00:06:07,430
moving on to to some theory so talk

00:06:05,750 --> 00:06:08,630
about a sink and Python the first thing

00:06:07,430 --> 00:06:11,000
you need to talk about a synchronous on

00:06:08,630 --> 00:06:13,640
it so this is a diagram of cool stack

00:06:11,000 --> 00:06:15,440
and obviously cool stats can be

00:06:13,640 --> 00:06:18,620
arbitrarily deep so I've got an example

00:06:15,440 --> 00:06:24,260
of a simple call stack where we want to

00:06:18,620 --> 00:06:26,930
get some get some data and that data is

00:06:24,260 --> 00:06:29,720
so I today we're going to process that

00:06:26,930 --> 00:06:31,910
data in the green function and we want

00:06:29,720 --> 00:06:35,690
to do one I operate io operation which

00:06:31,910 --> 00:06:41,000
is read one line from something a socket

00:06:35,690 --> 00:06:42,139
probably maybe a pipe so in synchronous

00:06:41,000 --> 00:06:45,800
i/o

00:06:42,139 --> 00:06:47,870
we we actually but the code executes is

00:06:45,800 --> 00:06:51,110
following the arrows get to the point

00:06:47,870 --> 00:06:52,909
where we block on Io and nothing happens

00:06:51,110 --> 00:06:56,960
process from our point of view the

00:06:52,909 --> 00:06:59,719
process has just stopped dead and the

00:06:56,960 --> 00:07:01,939
colonel then waits Rio and resumes us

00:06:59,719 --> 00:07:05,509
when that IO is ready so in fact it may

00:07:01,939 --> 00:07:08,199
block more than once but the everything

00:07:05,509 --> 00:07:10,550
stays completely intact and the

00:07:08,199 --> 00:07:13,969
execution continues when the IO is

00:07:10,550 --> 00:07:15,409
complete and obviously then the the line

00:07:13,969 --> 00:07:19,250
could be returned to the caller which

00:07:15,409 --> 00:07:26,240
will do some processing and the data is

00:07:19,250 --> 00:07:29,360
got so problems with with this kind of

00:07:26,240 --> 00:07:31,669
model in Python the the performance is

00:07:29,360 --> 00:07:35,210
is not good and the memory usage is not

00:07:31,669 --> 00:07:36,919
good so there is an excellent article

00:07:35,210 --> 00:07:42,050
which I actually failed to include a URL

00:07:36,919 --> 00:07:44,900
for so click that hyperlink so yeah well

00:07:42,050 --> 00:07:49,370
Google that but but it turns out that

00:07:44,900 --> 00:07:52,550
threads in Python the gill is not a

00:07:49,370 --> 00:07:56,689
kernel level object exactly so threads

00:07:52,550 --> 00:07:59,120
fight for the cpu CPU attention so it's

00:07:56,689 --> 00:08:04,430
actually much much worse than threads in

00:07:59,120 --> 00:08:07,430
other languages so there's also stack

00:08:04,430 --> 00:08:10,069
memory so a thread the colonel knows

00:08:07,430 --> 00:08:13,460
about threads and it prepares a bunch of

00:08:10,069 --> 00:08:15,589
snack that you can control it with you

00:08:13,460 --> 00:08:19,759
limit minus s but it prepares the stack

00:08:15,589 --> 00:08:21,680
ready to to do stuff in C basically so

00:08:19,759 --> 00:08:23,419
not particularly useful for Python you

00:08:21,680 --> 00:08:26,479
can turn that limit quite down quite low

00:08:23,419 --> 00:08:28,580
but you won't be able to get high

00:08:26,479 --> 00:08:30,589
scalability and similarly with processes

00:08:28,580 --> 00:08:32,029
you you've immediately lost the shared

00:08:30,589 --> 00:08:34,969
memory space which is useful about

00:08:32,029 --> 00:08:36,649
threads and you don't that thread is is

00:08:34,969 --> 00:08:38,089
basically a lightweight process there

00:08:36,649 --> 00:08:45,380
they're very similar kernel level

00:08:38,089 --> 00:08:50,029
objects yeah so I already mention this

00:08:45,380 --> 00:08:52,310
current model but the the what we're

00:08:50,029 --> 00:08:55,520
trying to do in all of these IO systems

00:08:52,310 --> 00:08:58,320
asynchronous i/o systems is

00:08:55,520 --> 00:09:00,450
when we are doing some I oh we want to

00:08:58,320 --> 00:09:02,370
jump out of what we're doing to let

00:09:00,450 --> 00:09:05,490
other things run and so that usually

00:09:02,370 --> 00:09:07,140
means there is a central place where it

00:09:05,490 --> 00:09:09,450
always means there is a central place

00:09:07,140 --> 00:09:12,029
that is waiting on Io doing all of the

00:09:09,450 --> 00:09:13,529
waiting for all of you all of the the

00:09:12,029 --> 00:09:15,690
things that are processing IO at that

00:09:13,529 --> 00:09:22,529
moment and presuming the right one when

00:09:15,690 --> 00:09:25,050
something happens so I've this is what

00:09:22,529 --> 00:09:27,360
it might look like so people were saying

00:09:25,050 --> 00:09:29,610
last night don't don't you select it

00:09:27,360 --> 00:09:32,100
doesn't scale but effectively all of the

00:09:29,610 --> 00:09:34,440
alternatives to select our I just sort

00:09:32,100 --> 00:09:37,190
of API improvements but the fundamental

00:09:34,440 --> 00:09:40,529
code will look a bit like this so

00:09:37,190 --> 00:09:43,260
something registers to to want to wait

00:09:40,529 --> 00:09:45,510
on a file descriptor for read or wait

00:09:43,260 --> 00:09:48,480
for right and then an event loop will be

00:09:45,510 --> 00:09:51,690
started which resumes for some

00:09:48,480 --> 00:09:54,540
definition of the function resume when

00:09:51,690 --> 00:09:57,200
that file descriptor has the capability

00:09:54,540 --> 00:10:00,209
to do to do that operation so if we

00:09:57,200 --> 00:10:06,240
register a waiter to wait for data being

00:10:00,209 --> 00:10:13,800
able to read select will return the list

00:10:06,240 --> 00:10:16,380
of file descriptors that are that on

00:10:13,800 --> 00:10:18,570
which you would then be able to win so

00:10:16,380 --> 00:10:20,760
select blocks sorry select blocks when

00:10:18,570 --> 00:10:24,240
it returns it returns those lists read

00:10:20,760 --> 00:10:27,000
write error and each of the items in

00:10:24,240 --> 00:10:29,070
that list is a file descriptor and so

00:10:27,000 --> 00:10:30,870
for every item in the every file

00:10:29,070 --> 00:10:32,339
descriptor in the list read it's

00:10:30,870 --> 00:10:33,899
guaranteed that you'll be able to read

00:10:32,339 --> 00:10:36,810
some number of lights which i think is

00:10:33,899 --> 00:10:39,149
like 512 or something so there is at

00:10:36,810 --> 00:10:42,709
least 512 bytes in the buffer to be read

00:10:39,149 --> 00:10:45,600
at that point and error handling

00:10:42,709 --> 00:10:46,890
obviously error handling is is actually

00:10:45,600 --> 00:10:49,470
very important in that work out great

00:10:46,890 --> 00:10:52,290
operations so I've emitted it for

00:10:49,470 --> 00:10:54,839
brevity but similar thing applies and

00:10:52,290 --> 00:10:57,149
then this is the the same thing that

00:10:54,839 --> 00:10:59,600
sort of slightly modified to show the

00:10:57,149 --> 00:11:02,010
time out how the time out part loops

00:10:59,600 --> 00:11:03,850
interacts with that so you may be

00:11:02,010 --> 00:11:05,350
wanting to do I oh and blocking on

00:11:03,850 --> 00:11:06,870
but you also won't want to be just

00:11:05,350 --> 00:11:09,519
blocking for an arbitrary amount of time

00:11:06,870 --> 00:11:12,069
so you could say wait for time out and

00:11:09,519 --> 00:11:14,529
then the last document to select is a

00:11:12,069 --> 00:11:16,630
time that we want to suspend and if know

00:11:14,529 --> 00:11:19,529
if nothing is returned on read write and

00:11:16,630 --> 00:11:24,069
error for the duration of that timeout

00:11:19,529 --> 00:11:26,589
then select will return anyway and we

00:11:24,069 --> 00:11:30,940
could do some process all other things

00:11:26,589 --> 00:11:36,670
that we're waiting for timeout right so

00:11:30,940 --> 00:11:41,470
get into different models of what resume

00:11:36,670 --> 00:11:42,970
might mean and so cool backs are the

00:11:41,470 --> 00:11:47,649
simplest approach they're they're used

00:11:42,970 --> 00:11:50,560
in JavaScript tornado io streams twisted

00:11:47,649 --> 00:11:54,690
deferred and async I oh all have this

00:11:50,560 --> 00:11:57,670
idea of callbacks from the event loop so

00:11:54,690 --> 00:11:59,290
this is the kind of what this does to

00:11:57,670 --> 00:12:03,040
the stack so whereas before we had a

00:11:59,290 --> 00:12:06,100
nice simple definition of what get data

00:12:03,040 --> 00:12:08,550
like that data was one thing now had to

00:12:06,100 --> 00:12:12,160
break it into we've had to break the the

00:12:08,550 --> 00:12:14,170
the red line function into to do the bit

00:12:12,160 --> 00:12:17,350
that sets up the getting the line and

00:12:14,170 --> 00:12:22,209
the bit that receives the line and or

00:12:17,350 --> 00:12:24,880
wait for a whole line perhaps so this is

00:12:22,209 --> 00:12:26,680
a lot more messy and you notice that

00:12:24,880 --> 00:12:30,279
I've drawn the return values as sort of

00:12:26,680 --> 00:12:32,170
of the return part as as light arrows

00:12:30,279 --> 00:12:33,189
because you can't do anything useful

00:12:32,170 --> 00:12:35,470
with the return values of callbacks

00:12:33,189 --> 00:12:36,699
they're not going to a useful place

00:12:35,470 --> 00:12:40,420
they're not going to contain any useful

00:12:36,699 --> 00:12:42,100
data so there is actually no way to ever

00:12:40,420 --> 00:12:44,110
break out of the cycle of court but cool

00:12:42,100 --> 00:12:46,480
acts and just turn into nice code where

00:12:44,110 --> 00:12:51,220
we can return values which is a really

00:12:46,480 --> 00:12:52,660
convenient way of programming so I've

00:12:51,220 --> 00:12:56,889
included some examples of cool back this

00:12:52,660 --> 00:13:00,240
is an imaginary HTTP library where I'm

00:12:56,889 --> 00:13:02,410
making a request for to an end point and

00:13:00,240 --> 00:13:05,170
passing in the function that I want to

00:13:02,410 --> 00:13:09,759
be called and it's got the ability to

00:13:05,170 --> 00:13:11,410
low Jason and so because I can't return

00:13:09,759 --> 00:13:13,660
now I've got to do something I've got to

00:13:11,410 --> 00:13:16,019
call back another callback with the the

00:13:13,660 --> 00:13:16,019
response

00:13:16,180 --> 00:13:24,380
and then if I wanted to link the request

00:13:20,540 --> 00:13:26,720
that I'm doing to a particular state of

00:13:24,380 --> 00:13:29,450
I work your pass arguments effectively

00:13:26,720 --> 00:13:33,589
then there's the one one way of doing it

00:13:29,450 --> 00:13:38,779
but one way is to use closures so the

00:13:33,589 --> 00:13:41,029
handle response is bound to the words

00:13:38,779 --> 00:13:46,130
closed over beer I D so it knows what

00:13:41,029 --> 00:13:50,930
your ideas which I've not used I've used

00:13:46,130 --> 00:13:52,700
cool back and said sorry but sort of

00:13:50,930 --> 00:13:54,140
more practical things this is this is

00:13:52,700 --> 00:13:56,300
something that I encountered a couple of

00:13:54,140 --> 00:14:00,470
years ago this is no just an errand QP

00:13:56,300 --> 00:14:03,290
library and here we're sort of four

00:14:00,470 --> 00:14:05,839
levels of callbacks deep and this is a

00:14:03,290 --> 00:14:07,399
simple example so in fact this just

00:14:05,839 --> 00:14:09,050
declares a queue but you might want to

00:14:07,399 --> 00:14:10,910
declare an exchange and binder cue to

00:14:09,050 --> 00:14:12,589
exchange so you're sort of six layers of

00:14:10,910 --> 00:14:15,709
callbacks deep before you've actually

00:14:12,589 --> 00:14:21,160
received a message so I don't like that

00:14:15,709 --> 00:14:24,020
at all that's that's really ugly to me

00:14:21,160 --> 00:14:25,670
so somebody won't say that I don't know

00:14:24,020 --> 00:14:27,670
I have been an attribution for this

00:14:25,670 --> 00:14:33,020
growth but call back so then you go to

00:14:27,670 --> 00:14:35,089
and we discussed how it's the it's an

00:14:33,020 --> 00:14:36,529
untidy cone structure where you split

00:14:35,089 --> 00:14:38,570
everything into tiny little component

00:14:36,529 --> 00:14:40,970
parts and you you're not able to do

00:14:38,570 --> 00:14:44,959
return values and also error handling

00:14:40,970 --> 00:14:46,580
you notice that the previous example has

00:14:44,959 --> 00:14:48,740
absolutely no error handling in there

00:14:46,580 --> 00:14:50,360
and if i wanted to our handling for all

00:14:48,740 --> 00:14:52,520
of those operations i might want to

00:14:50,360 --> 00:14:54,770
register an error handler in fact peaker

00:14:52,520 --> 00:14:56,779
you register the error handler once and

00:14:54,770 --> 00:14:58,339
then it just arbitrary it's something

00:14:56,779 --> 00:15:00,950
happened somewhere in the program but

00:14:58,339 --> 00:15:03,730
error handling with callbacks doubles

00:15:00,950 --> 00:15:06,290
the amount of work that you're doing so

00:15:03,730 --> 00:15:07,880
so people don't and the examples don't

00:15:06,290 --> 00:15:11,829
and then people copy the examples and

00:15:07,880 --> 00:15:16,700
error handling is just left on the floor

00:15:11,829 --> 00:15:20,510
so a simple approach to dealing with the

00:15:16,700 --> 00:15:24,410
complexity of callbacks is binding them

00:15:20,510 --> 00:15:26,450
into a class so that you have so rather

00:15:24,410 --> 00:15:28,920
than having the closure as I

00:15:26,450 --> 00:15:32,970
demonstrated earlier you have a

00:15:28,920 --> 00:15:34,860
that has method Sorak members and

00:15:32,970 --> 00:15:38,329
methods and things and the methods

00:15:34,860 --> 00:15:41,550
certain methods are pre-registered as

00:15:38,329 --> 00:15:45,540
callbacks for certain operations so this

00:15:41,550 --> 00:15:48,889
is something I wrote once bits truncated

00:15:45,540 --> 00:15:52,500
perhaps but this is a twisted

00:15:48,889 --> 00:15:56,100
application wrapping a subprocess and

00:15:52,500 --> 00:15:59,130
out received an e receives get called

00:15:56,100 --> 00:16:01,470
whenever there is a chunk of data for

00:15:59,130 --> 00:16:03,269
some reason the process protocol doesn't

00:16:01,470 --> 00:16:06,060
let you turn it easily into lines so I

00:16:03,269 --> 00:16:10,350
had to write that and then how do we

00:16:06,060 --> 00:16:13,829
break out of the this handler that's

00:16:10,350 --> 00:16:15,690
getting event achill their variance the

00:16:13,829 --> 00:16:18,329
three methods are being called on the

00:16:15,690 --> 00:16:20,040
object how do we turn that into useful

00:16:18,329 --> 00:16:22,079
things in another part of the program

00:16:20,040 --> 00:16:23,850
had to use something called a deferred q

00:16:22,079 --> 00:16:26,100
don't really remember the semantics of

00:16:23,850 --> 00:16:29,269
it but again that's that's a you

00:16:26,100 --> 00:16:31,699
register call backs into it I think so

00:16:29,269 --> 00:16:33,839
you're just this is just a

00:16:31,699 --> 00:16:36,300
simplification of some of the

00:16:33,839 --> 00:16:39,630
difficulties of callbacks but it doesn't

00:16:36,300 --> 00:16:42,000
really deal with the problem and you end

00:16:39,630 --> 00:16:44,310
up using callbacks anyway and you still

00:16:42,000 --> 00:16:47,730
have to split your processing into

00:16:44,310 --> 00:16:50,130
multiple chunks so if I wanted to say

00:16:47,730 --> 00:16:52,140
say I'd so I'm doing self doc you don't

00:16:50,130 --> 00:16:54,630
put here but if i was to decode the

00:16:52,140 --> 00:16:57,029
lines at that point and try and do

00:16:54,630 --> 00:16:59,550
another asynchronous operation how would

00:16:57,029 --> 00:17:03,510
I link that asynchronous operation which

00:16:59,550 --> 00:17:08,880
is another class to this class I've got

00:17:03,510 --> 00:17:11,939
to using cool banks basically and here's

00:17:08,880 --> 00:17:15,089
an example from a san kayo so it's

00:17:11,939 --> 00:17:16,910
exactly the same kind of thing the there

00:17:15,089 --> 00:17:20,250
is underlying a system of callbacks but

00:17:16,910 --> 00:17:22,650
in a sink i oh you have protocols and

00:17:20,250 --> 00:17:25,650
transports that are paired together so

00:17:22,650 --> 00:17:29,340
your transport is wrapping a type of

00:17:25,650 --> 00:17:30,900
thing like a like a well a subprocess or

00:17:29,340 --> 00:17:33,450
a network connection or something like

00:17:30,900 --> 00:17:37,350
that an ssl connection and the protocol

00:17:33,450 --> 00:17:40,169
is the processing for that but so it

00:17:37,350 --> 00:17:42,530
still call back based but you can eat

00:17:40,169 --> 00:17:45,000
your your

00:17:42,530 --> 00:17:46,380
wrapping it in a class and in there's a

00:17:45,000 --> 00:17:48,810
slightly I suppose that I think it's a

00:17:46,380 --> 00:17:52,350
slightly nicer API where we're twisted I

00:17:48,810 --> 00:17:54,300
had to use a process protocol and that

00:17:52,350 --> 00:18:10,710
would be different to a protocol that

00:17:54,300 --> 00:18:17,250
goes over the wire sorry okay okay right

00:18:10,710 --> 00:18:21,480
I'll try I'll try to do okay sorry where

00:18:17,250 --> 00:18:25,380
was I yes so I think the async i/o is

00:18:21,480 --> 00:18:27,180
slightly nicer than the than twisted

00:18:25,380 --> 00:18:31,290
because the protocols and the transports

00:18:27,180 --> 00:18:33,840
are are kept separate whereas in twisted

00:18:31,290 --> 00:18:38,420
they've been combined but the same

00:18:33,840 --> 00:18:41,610
problem supply so so then we get into a

00:18:38,420 --> 00:18:45,240
more modern technique of generator base

00:18:41,610 --> 00:18:48,900
co routines so this is this is present

00:18:45,240 --> 00:18:51,660
in tornado there's a tornado gen module

00:18:48,900 --> 00:18:54,360
and this is the that I suppose the key

00:18:51,660 --> 00:19:01,820
feature in the new ace in cayo in Python

00:18:54,360 --> 00:19:01,820
3.4 and so what we're doing here is

00:19:02,180 --> 00:19:09,000
we're using generators which so

00:19:07,080 --> 00:19:11,040
generator when generators were

00:19:09,000 --> 00:19:13,200
introduced it was noted they provide co

00:19:11,040 --> 00:19:16,710
routine like features and a co routine

00:19:13,200 --> 00:19:21,320
is is really what what gee event is

00:19:16,710 --> 00:19:25,890
built in but in this case we are using

00:19:21,320 --> 00:19:28,620
so we're trying to suspend operation but

00:19:25,890 --> 00:19:31,620
between the in the place that in the

00:19:28,620 --> 00:19:35,040
earlier example of blocking I oh we

00:19:31,620 --> 00:19:37,680
would have let the operating system call

00:19:35,040 --> 00:19:40,560
us back we are using yield and yield

00:19:37,680 --> 00:19:44,520
from to break out of the stack while

00:19:40,560 --> 00:19:46,380
preserving those stack frames and the

00:19:44,520 --> 00:19:47,790
event loop will and because the event

00:19:46,380 --> 00:19:48,930
loop is the parent the event loop knows

00:19:47,790 --> 00:19:53,190
that we're waiting for something to

00:19:48,930 --> 00:19:54,330
happen and it will return us back to the

00:19:53,190 --> 00:19:57,179
point it will really

00:19:54,330 --> 00:20:01,919
the stack when that operation is

00:19:57,179 --> 00:20:03,390
complete so so there's literally a

00:20:01,919 --> 00:20:07,260
division in the middle where the stack

00:20:03,390 --> 00:20:12,360
is torn down and preserved as generator

00:20:07,260 --> 00:20:15,360
objects and and resumed using send and

00:20:12,360 --> 00:20:16,649
there is one of the advantages of this

00:20:15,360 --> 00:20:23,309
method is that you can actually return

00:20:16,649 --> 00:20:27,779
data so I in in Python 3.4 when 20 years

00:20:23,309 --> 00:20:29,279
from 3.3 so before Python 3.3 you can

00:20:27,779 --> 00:20:33,720
actually return a value you've you've

00:20:29,279 --> 00:20:36,120
used generators generators in earlier

00:20:33,720 --> 00:20:39,000
pipe then you could not have a yield and

00:20:36,120 --> 00:20:41,789
a return of a value so that was a

00:20:39,000 --> 00:20:46,559
feature that had to be added to make

00:20:41,789 --> 00:20:50,159
this work and also you've used the yield

00:20:46,559 --> 00:20:53,370
so the semantics of yield are now

00:20:50,159 --> 00:20:55,409
coupled to breaking out of the stack

00:20:53,370 --> 00:20:57,899
rather than being able to actually use

00:20:55,409 --> 00:21:04,710
generators as a useful sort of looping

00:20:57,899 --> 00:21:07,350
tool so this is an example of a sink i/o

00:21:04,710 --> 00:21:09,149
and using those Co routines that so this

00:21:07,350 --> 00:21:15,090
is very similar example to the to the

00:21:09,149 --> 00:21:16,620
stack that that I showed that for some

00:21:15,090 --> 00:21:21,200
reason Sphinx wasn't able to highlight

00:21:16,620 --> 00:21:25,710
something with yield from in it but so

00:21:21,200 --> 00:21:31,740
so the async io sleep is a special type

00:21:25,710 --> 00:21:35,789
of generator that that returns an object

00:21:31,740 --> 00:21:37,590
that when when it's sorry yields an

00:21:35,789 --> 00:21:40,620
object that when it's yielded all the

00:21:37,590 --> 00:21:42,990
way through prints on back to the event

00:21:40,620 --> 00:21:45,860
loop the event loop will resume that

00:21:42,990 --> 00:21:48,960
generator by going back through the

00:21:45,860 --> 00:21:54,330
print some sending to print some sending

00:21:48,960 --> 00:21:57,630
from the yield from line into the yield

00:21:54,330 --> 00:22:01,320
from async eyes sleep line and and

00:21:57,630 --> 00:22:06,090
resuming the letting a san kayo dot

00:22:01,320 --> 00:22:08,670
sleep return actually and this is what

00:22:06,090 --> 00:22:13,420
it looks like in tornado

00:22:08,670 --> 00:22:18,010
so tornado has tornado works on Python

00:22:13,420 --> 00:22:23,350
too so there is no yield from there is

00:22:18,010 --> 00:22:26,200
no return value but that's yeah it's

00:22:23,350 --> 00:22:29,890
usable in Python 2 as well but you

00:22:26,200 --> 00:22:33,940
notice that we've had to put yield into

00:22:29,890 --> 00:22:35,230
the code we're really it doesn't it

00:22:33,940 --> 00:22:39,010
doesn't really make sense that we're

00:22:35,230 --> 00:22:41,860
yielding so what is an actual co routine

00:22:39,010 --> 00:22:44,380
so generators have been described as or

00:22:41,860 --> 00:22:46,300
the approach our generators has been

00:22:44,380 --> 00:22:50,650
described as semi co-wrote eens a full

00:22:46,300 --> 00:22:54,070
co routine can yield not just to the

00:22:50,650 --> 00:23:01,240
cooling frame but to anywhere so any

00:22:54,070 --> 00:23:03,550
other co routine and it doesn't require

00:23:01,240 --> 00:23:07,600
any collaboration from the other stack

00:23:03,550 --> 00:23:09,250
frames to do that so the the top level

00:23:07,600 --> 00:23:11,290
of the stack Frank just say hold on Park

00:23:09,250 --> 00:23:17,710
me i'm going to call back to the event

00:23:11,290 --> 00:23:20,620
loop so this is a bit what what it looks

00:23:17,710 --> 00:23:23,290
like so without having to suspend the

00:23:20,620 --> 00:23:25,780
the stack frame or modify the calling

00:23:23,290 --> 00:23:27,280
conventions to use yield from we get to

00:23:25,780 --> 00:23:30,160
the point where which we block and we

00:23:27,280 --> 00:23:34,090
just say yield to this event loop and

00:23:30,160 --> 00:23:36,670
the event loop when it's register to

00:23:34,090 --> 00:23:42,070
resume yields back to the point at which

00:23:36,670 --> 00:23:44,350
the this green lit was suspended so it's

00:23:42,070 --> 00:23:46,540
like blocking in the blocking i/o

00:23:44,350 --> 00:23:49,660
example except instead of blocking at

00:23:46,540 --> 00:23:53,170
the kernel level we just suspend this

00:23:49,660 --> 00:23:54,580
green lit yield to the event loop and

00:23:53,170 --> 00:23:56,140
the event loop does what the colonel

00:23:54,580 --> 00:24:00,970
would have done which is wait for i/o

00:23:56,140 --> 00:24:05,190
and resume us so going back to the async

00:24:00,970 --> 00:24:07,780
i/o example this is this is how the same

00:24:05,190 --> 00:24:11,170
the same piece of code booboo written

00:24:07,780 --> 00:24:14,020
with G event rather than having to use

00:24:11,170 --> 00:24:15,190
yield wrong so the only the only

00:24:14,020 --> 00:24:16,510
difference in terms of what you're

00:24:15,190 --> 00:24:19,210
calling is your calling G event not

00:24:16,510 --> 00:24:21,130
sleep you don't need to use yield from

00:24:19,210 --> 00:24:23,500
you write the code exactly as you

00:24:21,130 --> 00:24:25,720
normally writer and somewhere in chi

00:24:23,500 --> 00:24:27,310
event don't sleep the magic happens

00:24:25,720 --> 00:24:29,080
where it yields to the event loop and

00:24:27,310 --> 00:24:31,690
here I'm not even kicking it off from an

00:24:29,080 --> 00:24:35,680
event loop so the fact that i'm using g

00:24:31,690 --> 00:24:37,450
events sleep GN not sleep will create

00:24:35,680 --> 00:24:40,510
the event loop if it doesn't exist so

00:24:37,450 --> 00:24:47,250
the there's no i don't have to be

00:24:40,510 --> 00:24:47,250
spawned by an event loop so much simpler

00:24:52,260 --> 00:24:58,990
yes i think i've said most of those

00:24:55,330 --> 00:25:07,090
things in yes 0 in g event the event

00:24:58,990 --> 00:25:09,550
loop is called a hub so let me get back

00:25:07,090 --> 00:25:13,990
to the monkey patching so it's possible

00:25:09,550 --> 00:25:15,490
to just use g event monkey to modify the

00:25:13,990 --> 00:25:18,820
existing sleep function the time not

00:25:15,490 --> 00:25:20,250
sleep function which means so you have

00:25:18,820 --> 00:25:23,770
to do that before you import anything

00:25:20,250 --> 00:25:25,960
but in case you keep references to the

00:25:23,770 --> 00:25:27,910
old versions but it means that any

00:25:25,960 --> 00:25:29,800
existing code can run without

00:25:27,910 --> 00:25:33,940
modifications so you probably have code

00:25:29,800 --> 00:25:36,340
somewhere that uses time dot sleep you

00:25:33,940 --> 00:25:38,290
can make it run using g event just by

00:25:36,340 --> 00:25:40,510
starting your program with g event

00:25:38,290 --> 00:25:42,670
monkey import patchell patch all or

00:25:40,510 --> 00:25:44,650
however you want to express that or

00:25:42,670 --> 00:25:47,170
maybe have a launcher that launches your

00:25:44,650 --> 00:25:48,730
program with g event which is an

00:25:47,170 --> 00:25:50,740
approach that's often used for something

00:25:48,730 --> 00:25:52,630
like can so as it is available in g

00:25:50,740 --> 00:25:54,310
unicorn you could just say use a G event

00:25:52,630 --> 00:25:59,800
worker and it will do all of that stuff

00:25:54,310 --> 00:26:04,090
before your program starts so to tackle

00:25:59,800 --> 00:26:06,130
the nastiness of monkey patching I don't

00:26:04,090 --> 00:26:09,760
think it's is that ugly in this case

00:26:06,130 --> 00:26:11,860
because we're not arbitrarily monkey

00:26:09,760 --> 00:26:14,680
patching bits of the standard library at

00:26:11,860 --> 00:26:16,690
random times we're just starting we're

00:26:14,680 --> 00:26:19,000
starting Python with a completely

00:26:16,690 --> 00:26:20,650
different distribution of the the

00:26:19,000 --> 00:26:23,050
standard library that happens to be

00:26:20,650 --> 00:26:27,190
cooperative multitasking with this G

00:26:23,050 --> 00:26:30,040
event it's happened 'old as a library

00:26:27,190 --> 00:26:32,620
isn't rather than having like a Python

00:26:30,040 --> 00:26:34,279
hyphen G event program it's bundled

00:26:32,620 --> 00:26:37,340
there's a library so you can

00:26:34,279 --> 00:26:38,989
and choose to use it or not in different

00:26:37,340 --> 00:26:44,330
ways of calling your code so for example

00:26:38,989 --> 00:26:48,469
you might have a batch job that runs a

00:26:44,330 --> 00:26:50,239
batch job that runs without a

00:26:48,469 --> 00:26:54,499
synchronous code because it doesn't need

00:26:50,239 --> 00:26:57,469
it and you want to do some an ICP used

00:26:54,499 --> 00:26:59,149
up for it simplify your code by not

00:26:57,469 --> 00:27:00,289
doing 80 it tests tests are actually

00:26:59,149 --> 00:27:02,509
better you don't want to do asynchronous

00:27:00,289 --> 00:27:06,049
networking stuff in tests so you might

00:27:02,509 --> 00:27:08,619
call your business logic as as normal

00:27:06,049 --> 00:27:12,379
code and have it run synchronously and

00:27:08,619 --> 00:27:16,309
then just when you're when you switch

00:27:12,379 --> 00:27:18,339
into production you're using G event to

00:27:16,309 --> 00:27:20,899
do the a synchronous and asynchronous

00:27:18,339 --> 00:27:22,279
networking so and obviously you do

00:27:20,899 --> 00:27:23,649
integration tests with actually running

00:27:22,279 --> 00:27:26,450
through G event and that kind of thing

00:27:23,649 --> 00:27:27,889
but it's it's optional to use this you

00:27:26,450 --> 00:27:29,119
can use the full power of G event

00:27:27,889 --> 00:27:31,549
without doing it just means that you

00:27:29,119 --> 00:27:35,899
can't use existing pure Python libraries

00:27:31,549 --> 00:27:38,509
so I think as a massive advantage you

00:27:35,899 --> 00:27:40,219
you as I say here you can't use it if

00:27:38,509 --> 00:27:42,109
you're if you're writing a gln library

00:27:40,219 --> 00:27:44,839
you should not rely on monkey patching

00:27:42,109 --> 00:27:48,289
being present because you don't you

00:27:44,839 --> 00:27:49,909
don't know if the the cooler of your

00:27:48,289 --> 00:27:55,129
library is going to want to do the

00:27:49,909 --> 00:27:57,649
monkey patching so the monkey patching

00:27:55,129 --> 00:27:59,779
also works with async code using select

00:27:57,649 --> 00:28:02,389
so that immediately means that you can

00:27:59,779 --> 00:28:04,999
use existing libraries that are doing

00:28:02,389 --> 00:28:07,759
their own kind of networking so that

00:28:04,999 --> 00:28:09,320
will have their own event loop like pika

00:28:07,759 --> 00:28:10,219
there you could use pika if you really

00:28:09,320 --> 00:28:13,369
want it to deal with all of the

00:28:10,219 --> 00:28:15,859
callbacks but you need to ensure that

00:28:13,369 --> 00:28:18,320
it's using the select the Select

00:28:15,859 --> 00:28:20,469
function rather than a pole or cake you

00:28:18,320 --> 00:28:23,359
or any of the other more

00:28:20,469 --> 00:28:29,450
platform-specific alternatives that are

00:28:23,359 --> 00:28:32,599
that are usually better so just to

00:28:29,450 --> 00:28:34,759
quickly run through the kind of features

00:28:32,599 --> 00:28:37,239
in in G event you obviously need to be

00:28:34,759 --> 00:28:39,289
able to spawn a greenlit to allow

00:28:37,239 --> 00:28:43,330
concurrent operations that don't block

00:28:39,289 --> 00:28:46,369
each other so the fundamental unit of

00:28:43,330 --> 00:28:47,490
processing i/o with G event is to have

00:28:46,369 --> 00:28:49,440
these green lights

00:28:47,490 --> 00:28:52,230
you spawn green let's do each side of a

00:28:49,440 --> 00:28:54,750
like a reading of writing side you can

00:28:52,230 --> 00:28:56,610
kill green lips by passing an exception

00:28:54,750 --> 00:28:59,100
so that when the green light is resumed

00:28:56,610 --> 00:29:01,590
or sorry signal that green light to be

00:28:59,100 --> 00:29:03,210
immediately resumable but when it

00:29:01,590 --> 00:29:04,170
resumes that exception will be raised so

00:29:03,210 --> 00:29:05,550
that's actually an advantage over

00:29:04,170 --> 00:29:08,580
threats because you can't easily do that

00:29:05,550 --> 00:29:11,340
with threads in Python and then there's

00:29:08,580 --> 00:29:15,030
a green lit pool equivalent to multiple

00:29:11,340 --> 00:29:18,179
exciting about pool or other types of

00:29:15,030 --> 00:29:19,890
pools so if you wanted to do paralyzed

00:29:18,179 --> 00:29:22,590
network operations that's an easy way to

00:29:19,890 --> 00:29:25,230
dirt and then there's synchronization

00:29:22,590 --> 00:29:27,570
primitives to ensure concurrency between

00:29:25,230 --> 00:29:29,850
older to ensure all synchronization

00:29:27,570 --> 00:29:31,620
between your your green 'let's it's

00:29:29,850 --> 00:29:33,150
worth noting that green let's never run

00:29:31,620 --> 00:29:36,050
at the same actually at the same time

00:29:33,150 --> 00:29:39,710
unlike threads so these things are

00:29:36,050 --> 00:29:42,120
slightly less important but you're

00:29:39,710 --> 00:29:44,640
because you you know that you're never

00:29:42,120 --> 00:29:49,110
going to give up control of the cpu

00:29:44,640 --> 00:29:51,929
until you hit a blocking operation and

00:29:49,110 --> 00:29:54,390
message passing asyncresult is is pretty

00:29:51,929 --> 00:29:56,190
neat so you block on a single operation

00:29:54,390 --> 00:29:58,530
that's a useful way of turning callbacks

00:29:56,190 --> 00:30:00,270
back into synchronous programming so you

00:29:58,530 --> 00:30:01,860
want to have a synchronous programming

00:30:00,270 --> 00:30:04,080
model because it makes it easier so

00:30:01,860 --> 00:30:06,090
asyncresult you could just say when this

00:30:04,080 --> 00:30:06,990
callbacks raised set a value into this i

00:30:06,090 --> 00:30:08,309
t'ink result and that gives you

00:30:06,990 --> 00:30:11,640
something that you could block on as a

00:30:08,309 --> 00:30:14,250
sort of just get you do asyncresult get

00:30:11,640 --> 00:30:16,290
and it will return you the result or if

00:30:14,250 --> 00:30:19,110
there's an exception you set the

00:30:16,290 --> 00:30:20,370
exception and the the things waiting on

00:30:19,110 --> 00:30:23,160
it will actually receive the exception

00:30:20,370 --> 00:30:25,160
so synchronous error handling as well

00:30:23,160 --> 00:30:27,630
and this is an example of using the

00:30:25,160 --> 00:30:29,670
thread killing the green lit killing

00:30:27,630 --> 00:30:31,080
mechanisms so you can just use a context

00:30:29,670 --> 00:30:33,290
manager like that and you've

00:30:31,080 --> 00:30:37,679
automatically got a timeout on the

00:30:33,290 --> 00:30:40,230
contained section so anytime as like

00:30:37,679 --> 00:30:42,150
time not sleep or all blocking

00:30:40,230 --> 00:30:45,179
operations could be limited by the same

00:30:42,150 --> 00:30:46,559
time out and we've already met things

00:30:45,179 --> 00:30:49,940
like the stream server but there are

00:30:46,559 --> 00:30:56,929
whiskey servers and that kind of thing

00:30:49,940 --> 00:30:58,200
so I think I'll cover this in a way but

00:30:56,929 --> 00:31:00,240
you can

00:30:58,200 --> 00:31:03,000
have business logic that's completely

00:31:00,240 --> 00:31:05,370
unaware of G of n and unaware of the

00:31:03,000 --> 00:31:06,810
even without the monkey patching you can

00:31:05,370 --> 00:31:09,510
have business logic that's unaware of

00:31:06,810 --> 00:31:11,490
asynchronous and you pass in say a far

00:31:09,510 --> 00:31:15,930
like object which has been made green

00:31:11,490 --> 00:31:18,090
and it will the business logic wool will

00:31:15,930 --> 00:31:19,800
hit that and stop without having to

00:31:18,090 --> 00:31:21,570
change all of your call stack to

00:31:19,800 --> 00:31:23,490
collaborate in doing this this yield

00:31:21,570 --> 00:31:26,040
from shenanigans to get back to the

00:31:23,490 --> 00:31:27,930
event loop to be resumed eventually so I

00:31:26,040 --> 00:31:30,480
think that's a that's a huge advantage

00:31:27,930 --> 00:31:33,200
and I don't really want my business

00:31:30,480 --> 00:31:37,110
logic to be to have the idea of

00:31:33,200 --> 00:31:39,330
asynchronous backends potentially being

00:31:37,110 --> 00:31:43,280
being part of it and also have to deal

00:31:39,330 --> 00:31:43,280
with the occasional synchronous back end

00:31:50,210 --> 00:31:57,630
yeah so green let's have the advantage

00:31:55,250 --> 00:32:03,240
have all of the advantages of the kind

00:31:57,630 --> 00:32:06,750
of generator approach but yeah to sum it

00:32:03,240 --> 00:32:10,860
up these things are very light that the

00:32:06,750 --> 00:32:15,330
stack stack frames in Python that are on

00:32:10,860 --> 00:32:20,310
the heap so yeah need to hurry through

00:32:15,330 --> 00:32:21,720
some stuff ya know k generators what oh

00:32:20,310 --> 00:32:23,820
so it works in windows so i didn't

00:32:21,720 --> 00:32:26,130
mention that a disadvantage is that

00:32:23,820 --> 00:32:29,430
where it doesn't work on python through

00:32:26,130 --> 00:32:32,400
it this time so and that's a big deal of

00:32:29,430 --> 00:32:36,030
her some people there is a Python free

00:32:32,400 --> 00:32:41,490
branch I the answers of Python the three

00:32:36,030 --> 00:32:43,830
fork I don't I've not tried it it's it's

00:32:41,490 --> 00:32:46,680
obviously sort of usable for some things

00:32:43,830 --> 00:32:48,000
but that's not finished but but then

00:32:46,680 --> 00:32:50,220
we're talking about networking

00:32:48,000 --> 00:32:52,050
operations so if you want to write a

00:32:50,220 --> 00:32:54,480
network server in Python to that shunts

00:32:52,050 --> 00:32:56,280
bytes around around and use Python 3 for

00:32:54,480 --> 00:32:59,580
your user facing stuff and do a singer

00:32:56,280 --> 00:33:02,400
use async I o or use synchronous i/o

00:32:59,580 --> 00:33:05,430
just for that component that's that's

00:33:02,400 --> 00:33:08,040
something that might work for you and

00:33:05,430 --> 00:33:10,200
wherever we have locks we have the

00:33:08,040 --> 00:33:11,340
ability the possibility of deadlocks but

00:33:10,200 --> 00:33:17,090
that may exist another

00:33:11,340 --> 00:33:19,860
a sink frameworks as well so one pitbull

00:33:17,090 --> 00:33:22,200
the biggest pitfall is doing something

00:33:19,860 --> 00:33:23,880
that actually actually blocks instead of

00:33:22,200 --> 00:33:27,420
doing this fake blocking where we yield

00:33:23,880 --> 00:33:29,790
to the event loop so if you're using NEC

00:33:27,420 --> 00:33:34,860
libraries they probably do this and you

00:33:29,790 --> 00:33:36,930
have to modify the library or use any

00:33:34,860 --> 00:33:38,880
async support in that library and wrap

00:33:36,930 --> 00:33:41,460
it up into the GL n programming model to

00:33:38,880 --> 00:33:43,500
avoid blocking and likewise if you keep

00:33:41,460 --> 00:33:46,200
the CPU busy you'll never yield to any

00:33:43,500 --> 00:33:50,100
other green net so this isn't at all for

00:33:46,200 --> 00:33:51,870
CPU bound activities but you can you

00:33:50,100 --> 00:33:55,170
could obviously use the ability of the

00:33:51,870 --> 00:33:57,360
networking features of G event to

00:33:55,170 --> 00:33:59,010
delegate to synchronous back ends that

00:33:57,360 --> 00:34:00,540
are doing heavy lifting and return it

00:33:59,010 --> 00:34:03,980
through your your sort of network

00:34:00,540 --> 00:34:07,440
plumbing applications written in g event

00:34:03,980 --> 00:34:10,170
so i mentioned using one green leopard

00:34:07,440 --> 00:34:12,180
erection you don't want to try and merge

00:34:10,170 --> 00:34:14,190
these two into one green lets you want

00:34:12,180 --> 00:34:16,200
to do writing in one green and reading

00:34:14,190 --> 00:34:18,090
in one green lit because you only want

00:34:16,200 --> 00:34:19,110
to block in one place at a time

00:34:18,090 --> 00:34:20,340
certainly at the writer you're actually

00:34:19,110 --> 00:34:23,010
booking waiting for a message and

00:34:20,340 --> 00:34:25,110
blocking sending that message but you're

00:34:23,010 --> 00:34:30,270
you're not blocked on anything important

00:34:25,110 --> 00:34:33,420
any particular time you can obviously

00:34:30,270 --> 00:34:36,750
use this with multiprocessing and that's

00:34:33,420 --> 00:34:40,260
a kind of approach that's used in java

00:34:36,750 --> 00:34:43,320
and go and rust so these these systems

00:34:40,260 --> 00:34:45,270
do have green threads and green 'let's

00:34:43,320 --> 00:34:47,010
but they use multiple threads underneath

00:34:45,270 --> 00:34:51,480
them in PI thing we have to use

00:34:47,010 --> 00:34:53,370
processes underneath them but you can

00:34:51,480 --> 00:34:55,410
still get more scalability out of

00:34:53,370 --> 00:34:59,250
multiprocessor systems by using this

00:34:55,410 --> 00:35:03,450
approach on multiple processes and then

00:34:59,250 --> 00:35:07,140
a couple of years ago when i was doing

00:35:03,450 --> 00:35:09,180
this really heavily i wrote a micro

00:35:07,140 --> 00:35:10,920
framework which i think i gave a

00:35:09,180 --> 00:35:13,110
lightning talk a couple of years ago

00:35:10,920 --> 00:35:15,060
saying never write a micro framework it

00:35:13,110 --> 00:35:17,520
was a really stupid idea but but there

00:35:15,060 --> 00:35:21,960
is one so if you want to do g event with

00:35:17,520 --> 00:35:22,970
a restful g event and a green postgres

00:35:21,960 --> 00:35:25,150
driver that

00:35:22,970 --> 00:35:29,690
can do so the your database operations

00:35:25,150 --> 00:35:32,590
also do this fake blocking kind of thing

00:35:29,690 --> 00:35:37,880
then that's built into the tanuki on and

00:35:32,590 --> 00:35:40,880
in in sort of revulsion at pika and all

00:35:37,880 --> 00:35:42,590
of that callback stuff i wrote an m QP

00:35:40,880 --> 00:35:46,550
library that was actually from

00:35:42,590 --> 00:35:50,780
another one called puker but so there is

00:35:46,550 --> 00:35:53,050
a whereas most of the a n QP drivers try

00:35:50,780 --> 00:35:55,490
to be asynchronous through callbacks

00:35:53,050 --> 00:35:58,190
this gives you a completely synchronous

00:35:55,490 --> 00:36:00,170
programming models so remote cues can be

00:35:58,190 --> 00:36:01,940
exposed as local cues and you just

00:36:00,170 --> 00:36:06,109
iterate through the messages of the

00:36:01,940 --> 00:36:08,420
queue or loop over getting messages from

00:36:06,109 --> 00:36:11,599
a queue rather than having a callback

00:36:08,420 --> 00:36:14,300
call every time a message is available

00:36:11,599 --> 00:36:18,220
and and all of the other mqp operations

00:36:14,300 --> 00:36:18,220
as well so

00:36:27,130 --> 00:36:33,910
we have tons precious we have specials

00:36:30,280 --> 00:36:35,800
rattling if anybody close to e to go to

00:36:33,910 --> 00:36:38,500
another room session doesn't have a

00:36:35,800 --> 00:36:41,440
question would appreciate it the good

00:36:38,500 --> 00:36:43,570
before it do you have known some some

00:36:41,440 --> 00:36:47,490
peace professional otherwise if you have

00:36:43,570 --> 00:36:47,490
a question there's like this

00:37:10,150 --> 00:37:15,770
okay well this is more common than a

00:37:13,640 --> 00:37:18,770
question but we're skipping over that

00:37:15,770 --> 00:37:20,960
part real fast but gee event only uses

00:37:18,770 --> 00:37:22,820
the select system call on all operating

00:37:20,960 --> 00:37:25,160
systems which give sub optimal

00:37:22,820 --> 00:37:28,160
performance and other platforms like

00:37:25,160 --> 00:37:30,380
windows for example I I don't actually

00:37:28,160 --> 00:37:32,630
so somewhere in the heart of year then

00:37:30,380 --> 00:37:35,600
it will use the most appropriate thing

00:37:32,630 --> 00:37:37,580
for any particular operating said not

00:37:35,600 --> 00:37:39,710
for not for windows for probably not for

00:37:37,580 --> 00:37:42,500
windows so you it's a horrible choice

00:37:39,710 --> 00:37:44,630
for cross-platform really scalability

00:37:42,500 --> 00:37:46,670
but might be good if you know your

00:37:44,630 --> 00:37:49,940
target I think it probably is possible

00:37:46,670 --> 00:37:52,640
to to adapt your event to be more

00:37:49,940 --> 00:37:55,310
windows compatible because the the co

00:37:52,640 --> 00:37:57,770
routines approach is is sort of

00:37:55,310 --> 00:38:00,770
completely abstract you could use it

00:37:57,770 --> 00:38:03,440
yeah absolutely but us now its uses sub

00:38:00,770 --> 00:38:05,090
optimal system call on some platforms so

00:38:03,440 --> 00:38:07,910
it might be worth knowing if you're

00:38:05,090 --> 00:38:09,620
going to double in g event I in fairness

00:38:07,910 --> 00:38:11,930
i've never used our windows but i hear

00:38:09,620 --> 00:38:17,000
it work somewhat no me neither but worth

00:38:11,930 --> 00:38:22,430
knowing is there any optimal number of

00:38:17,000 --> 00:38:24,410
units you can use the wrong process is

00:38:22,430 --> 00:38:26,300
there any optimal number of units you

00:38:24,410 --> 00:38:29,330
should use parent process for example

00:38:26,300 --> 00:38:31,670
are all arranged or how many dylan's

00:38:29,330 --> 00:38:33,230
should you start how many workers green

00:38:31,670 --> 00:38:35,300
lights i will start with me greats as

00:38:33,230 --> 00:38:37,130
you want it's like just green lights are

00:38:35,300 --> 00:38:39,470
very very cheap so create as many as you

00:38:37,130 --> 00:38:41,630
need you can start to like like 1000

00:38:39,470 --> 00:38:43,970
yeah 10,000 green let's hoop road yeah

00:38:41,630 --> 00:38:48,340
100,000 who cares as long as you got

00:38:43,970 --> 00:38:51,560
memory i have a question regarding

00:38:48,340 --> 00:38:54,020
generators and co routines if you use a

00:38:51,560 --> 00:38:55,760
generator you hear if you have an

00:38:54,020 --> 00:38:58,340
asynchronous has to do and you exactly

00:38:55,760 --> 00:39:00,680
know that betweens year tend to resume

00:38:58,340 --> 00:39:04,160
the global state of the shared state may

00:39:00,680 --> 00:39:06,350
change and in g event you you don't see

00:39:04,160 --> 00:39:09,560
obvious visit for example time sleep may

00:39:06,350 --> 00:39:11,810
may suspend your your green LED NC State

00:39:09,560 --> 00:39:16,490
maybe differently when you wake up again

00:39:11,810 --> 00:39:19,010
so I yeah well so that's nothing to be

00:39:16,490 --> 00:39:19,660
to be careful of in all of the async

00:39:19,010 --> 00:39:21,970
framework

00:39:19,660 --> 00:39:24,640
that you can't really rely on global

00:39:21,970 --> 00:39:26,530
state something that is useful about G

00:39:24,640 --> 00:39:29,910
event is that it has its own threadlocal

00:39:26,530 --> 00:39:32,349
object so that and the monkey patch

00:39:29,910 --> 00:39:35,740
approach will apply that threadlocal

00:39:32,349 --> 00:39:37,210
object as the threading dot local so

00:39:35,740 --> 00:39:39,250
that means that you can have your local

00:39:37,210 --> 00:39:41,349
state in a threadlocal object and I

00:39:39,250 --> 00:39:43,420
think flask uses thread locals or

00:39:41,349 --> 00:39:45,819
something like that so with monkey

00:39:43,420 --> 00:39:49,119
patching the the flask global stuff

00:39:45,819 --> 00:39:52,210
should work although i don't think i've

00:39:49,119 --> 00:39:53,170
ever tried that so yeah but obviously it

00:39:52,210 --> 00:39:56,280
something to be careful about using

00:39:53,170 --> 00:40:02,829
global state when you're you're using

00:39:56,280 --> 00:40:05,670
anything concurrent same so if if g

00:40:02,829 --> 00:40:09,280
event was ported to python 3 could it be

00:40:05,670 --> 00:40:11,020
compatible with async I Oh for example

00:40:09,280 --> 00:40:13,510
could we use some library in that

00:40:11,020 --> 00:40:18,119
scenario that's written in the async i/o

00:40:13,510 --> 00:40:21,730
style I suspect she probably can yeah so

00:40:18,119 --> 00:40:23,319
async io is completely within Python it

00:40:21,730 --> 00:40:26,109
doesn't have any special python tricks

00:40:23,319 --> 00:40:29,230
whereas this this one see trick in g

00:40:26,109 --> 00:40:30,490
event and similar systems with co

00:40:29,230 --> 00:40:34,270
routines where you could jump to a

00:40:30,490 --> 00:40:36,700
different stack so that anything within

00:40:34,270 --> 00:40:39,730
completely within Python could

00:40:36,700 --> 00:40:43,180
potentially run on G event but I think

00:40:39,730 --> 00:40:46,359
the big hope for a sink I oh is that the

00:40:43,180 --> 00:40:47,890
event Lucan async io will come to be the

00:40:46,359 --> 00:40:49,480
standard event loop for everything

00:40:47,890 --> 00:40:52,799
including something like G event so you

00:40:49,480 --> 00:40:55,660
could run an async i/o event loop and

00:40:52,799 --> 00:40:58,059
have G event use that as its event loop

00:40:55,660 --> 00:41:00,640
meaning that all of the frameworks like

00:40:58,059 --> 00:41:04,119
twisted and tornado and G event annexing

00:41:00,640 --> 00:41:05,619
Co could all be using you know running

00:41:04,119 --> 00:41:07,809
on executives anko as it is at the

00:41:05,619 --> 00:41:10,150
moment you could probably use because as

00:41:07,809 --> 00:41:11,680
I said selectors is one of the things

00:41:10,150 --> 00:41:14,559
that's patched you could probably use

00:41:11,680 --> 00:41:17,020
tornado and twisted their own event

00:41:14,559 --> 00:41:19,150
loops within G event but actually

00:41:17,020 --> 00:41:24,279
bringing everything together is an open

00:41:19,150 --> 00:41:26,500
problem ok thanks hello do you have any

00:41:24,279 --> 00:41:28,210
idea on when G event will be ported to

00:41:26,500 --> 00:41:30,520
python free because you know i think

00:41:28,210 --> 00:41:32,000
it's a very important no dependency for

00:41:30,520 --> 00:41:34,490
a lot of projects like

00:41:32,000 --> 00:41:37,160
hundreds of thousands of projects and we

00:41:34,490 --> 00:41:39,200
twisted no I think it's one of the those

00:41:37,160 --> 00:41:41,990
dependencies which needs to be imported

00:41:39,200 --> 00:41:44,570
right right now you know you have any

00:41:41,990 --> 00:41:47,360
estimate on when Sochi event has only

00:41:44,570 --> 00:41:48,950
just reached version 1 at it was in

00:41:47,360 --> 00:41:52,610
November last year that it reached

00:41:48,950 --> 00:41:56,390
version 1.0 and I don't know how much

00:41:52,610 --> 00:42:00,260
effort is going into to writing a Python

00:41:56,390 --> 00:42:02,330
3 compatible G event so yeah no answer

00:42:00,260 --> 00:42:07,760
for that but if you're interested it get

00:42:02,330 --> 00:42:09,620
involved why not okay thanks thank you

00:42:07,760 --> 00:42:13,070
it was a very insightful presentation I

00:42:09,620 --> 00:42:15,050
would like to ask you where I work we

00:42:13,070 --> 00:42:17,180
use tornado for production and I

00:42:15,050 --> 00:42:20,660
synchronous Python sorry I didn't hear

00:42:17,180 --> 00:42:23,450
that spit bit noisy sorry tonight where

00:42:20,660 --> 00:42:25,760
I work we use tornado as I synchronous

00:42:23,450 --> 00:42:27,620
Python and it works really well just

00:42:25,760 --> 00:42:31,550
like G event I myself use G event in the

00:42:27,620 --> 00:42:33,470
past the problem is that we found a

00:42:31,550 --> 00:42:36,500
really hard bottleneck and that is the

00:42:33,470 --> 00:42:39,440
database because the database we

00:42:36,500 --> 00:42:41,420
couldn't find an asynchronous or and

00:42:39,440 --> 00:42:42,920
yeah right yes so there's a huge problem

00:42:41,420 --> 00:42:45,440
for us we don't try to use inline

00:42:42,920 --> 00:42:47,690
queries so do you have any idea of an

00:42:45,440 --> 00:42:50,750
asynchronous ORM or one that's being

00:42:47,690 --> 00:42:53,270
developed so there are ways around it if

00:42:50,750 --> 00:42:55,370
you want to do synchronous operations

00:42:53,270 --> 00:42:56,900
you can use an actual thread pool or

00:42:55,370 --> 00:42:59,450
something like that so wrap up the

00:42:56,900 --> 00:43:03,230
synchronous code with or multiprocessing

00:42:59,450 --> 00:43:05,240
pool so that you're passing the requests

00:43:03,230 --> 00:43:07,280
using g event and receiving the

00:43:05,240 --> 00:43:09,860
responses using g event but you only

00:43:07,280 --> 00:43:13,040
have say for blocking workers that are

00:43:09,860 --> 00:43:15,620
doing database tools that's that's one

00:43:13,040 --> 00:43:17,690
way around it I think so I've in nucleon

00:43:15,620 --> 00:43:20,120
I found a way of somebody had already

00:43:17,690 --> 00:43:23,870
written the example code for how to do

00:43:20,120 --> 00:43:29,450
how to make the postgres a psycho PG to

00:43:23,870 --> 00:43:31,130
driver co routine compatible by having

00:43:29,450 --> 00:43:32,720
the library itself tell you when it

00:43:31,130 --> 00:43:33,980
wants to block and then you are

00:43:32,720 --> 00:43:36,140
responsible for doing that kind of

00:43:33,980 --> 00:43:37,910
blocking so it is possible for some

00:43:36,140 --> 00:43:41,730
drivers but there are and there are

00:43:37,910 --> 00:43:50,640
workarounds for others ok thank you

00:43:41,730 --> 00:43:50,640

YouTube URL: https://www.youtube.com/watch?v=3lhsA5ywh00


