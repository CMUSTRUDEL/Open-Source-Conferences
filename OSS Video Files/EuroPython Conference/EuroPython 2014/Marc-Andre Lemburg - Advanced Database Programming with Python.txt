Title: Marc-Andre Lemburg - Advanced Database Programming with Python
Publication date: 2015-04-18
Playlist: EuroPython 2014
Description: 
	Marc-Andre Lemburg - Advanced Database Programming with Python
[EuroPython 2014]
[25 July 2014]

The Python DB-API 2.0 provides a direct interface to
many popular database backends. It makes interaction with
relational database very straight forward and allows tapping
into the full set of features these databases provide.
The talk will cover advanced database topics which are
relevant in production environments such as locks, distributed
transactions and transaction isolation.

-----

The Python DB-API 2.0 provides a direct interface to
many popular database backends. It makes interaction with
relational database very straight forward and allows tapping
into the full set of features these databases provide.

The talk will cover advanced database topics which are
relevant in production environments such as locks, distributed
transactions and transaction isolation.

----

The talk will give an in-depth discussion of advanced database
programming topics based on the Python DB-API 2.0: locks and
dead-locks, two-phase commits, transaction isolation, result
set scrolling, schema introspection and handling
multiple result sets.

Talks slides are available on request.
Captions: 
	00:00:15,840 --> 00:00:21,010
okay we will proceed mark and the

00:00:19,270 --> 00:00:24,190
Lemberg will talk about advanced

00:00:21,010 --> 00:00:28,590
database programming he's a seasoned

00:00:24,190 --> 00:00:32,500
Python developer being around since 1993

00:00:28,590 --> 00:00:34,809
also founder and CEO of GE genex comm

00:00:32,500 --> 00:00:37,180
one of the founding members of the

00:00:34,809 --> 00:00:40,600
Python software community of Python

00:00:37,180 --> 00:00:43,330
Software Foundation and a board member

00:00:40,600 --> 00:00:45,400
of the European society which brought

00:00:43,330 --> 00:00:54,040
this lovely conference to you give him a

00:00:45,400 --> 00:00:55,170
warm welcome please thank you very much

00:00:54,040 --> 00:00:57,070
for coming

00:00:55,170 --> 00:00:59,170
I'm gonna give a little talk about

00:00:57,070 --> 00:01:02,290
advanced database programming because

00:00:59,170 --> 00:01:04,930
we've in the past hired a lot about the

00:01:02,290 --> 00:01:06,820
easy stuff so I thought it might be a

00:01:04,930 --> 00:01:09,130
good idea to to talk a bit about the

00:01:06,820 --> 00:01:11,320
more advanced things a bit about myself

00:01:09,130 --> 00:01:12,910
I'm I'm mark Lemberg I've been using

00:01:11,320 --> 00:01:14,920
Python for a very long time

00:01:12,910 --> 00:01:17,890
I've studied mathematics I have a

00:01:14,920 --> 00:01:19,690
company doing Python projects I'm a core

00:01:17,890 --> 00:01:22,869
developer software Python Software

00:01:19,690 --> 00:01:27,010
Foundation member member of the European

00:01:22,869 --> 00:01:28,840
Society and I'm based in Dusseldorf so

00:01:27,010 --> 00:01:30,340
this is the agenda for the talk I don't

00:01:28,840 --> 00:01:32,409
know whether I can actually do

00:01:30,340 --> 00:01:35,439
everything then I have on this agenda

00:01:32,409 --> 00:01:37,600
because of the time constraints but I'll

00:01:35,439 --> 00:01:40,180
try first I'm gonna start with a short

00:01:37,600 --> 00:01:42,640
introduction of the Python database API

00:01:40,180 --> 00:01:46,689
2.0 how many of you know the Python

00:01:42,640 --> 00:01:47,200
database API interesting and not that

00:01:46,689 --> 00:01:51,720
many

00:01:47,200 --> 00:01:55,090
so the path and database API was was

00:01:51,720 --> 00:01:59,439
designed in the well the design started

00:01:55,090 --> 00:02:03,310
in the in the mid-90s that was the one

00:01:59,439 --> 00:02:06,549
dot l version which is now deprecated

00:02:03,310 --> 00:02:09,850
and we're now add to that Oh so it's a

00:02:06,549 --> 00:02:11,739
very old kind of standard that that was

00:02:09,850 --> 00:02:14,709
developed it's the this development is

00:02:11,739 --> 00:02:16,030
ongoing on the Python DB sake so if you

00:02:14,709 --> 00:02:17,560
want to join the discussion there you

00:02:16,030 --> 00:02:21,760
just have to subscribe to that mailing

00:02:17,560 --> 00:02:25,090
list and you can you can add your your

00:02:21,760 --> 00:02:26,919
thoughts to the standard it's supposed

00:02:25,090 --> 00:02:27,450
to be a very simple as kind of standard

00:02:26,919 --> 00:02:29,970
is supposed

00:02:27,450 --> 00:02:32,040
be easy to implement so that we get as

00:02:29,970 --> 00:02:34,410
many database bot modules as possible

00:02:32,040 --> 00:02:36,989
and I think that has worked out really

00:02:34,410 --> 00:02:38,670
well the two main concepts in the buy

00:02:36,989 --> 00:02:40,290
Python database API one is the

00:02:38,670 --> 00:02:41,970
connection object and the other is the

00:02:40,290 --> 00:02:43,440
cursor object so you use connection

00:02:41,970 --> 00:02:45,840
objects to actually connect to the

00:02:43,440 --> 00:02:47,970
database and also to manage your

00:02:45,840 --> 00:02:51,120
transactions and then if you want to run

00:02:47,970 --> 00:02:53,280
queries you open a cursor object and you

00:02:51,120 --> 00:02:55,019
run your queries on the cursor object

00:02:53,280 --> 00:02:57,870
and the cursor actually works like a

00:02:55,019 --> 00:02:59,849
cursor in a text processing system you

00:02:57,870 --> 00:03:01,950
actually scroll down or like it in the

00:02:59,849 --> 00:03:04,260
spreadsheet you scroll down in your

00:03:01,950 --> 00:03:07,920
results set and then get your data into

00:03:04,260 --> 00:03:11,069
your application so this is how a

00:03:07,920 --> 00:03:13,440
typical application looks like that uses

00:03:11,069 --> 00:03:16,200
the DB API so first you import your

00:03:13,440 --> 00:03:18,180
module you get to connect API from that

00:03:16,200 --> 00:03:20,730
module you open a connection you pass in

00:03:18,180 --> 00:03:21,269
your the database name the username and

00:03:20,730 --> 00:03:23,610
the password

00:03:21,269 --> 00:03:25,680
then you create a cursor object on the

00:03:23,610 --> 00:03:27,750
connection object and you run your

00:03:25,680 --> 00:03:29,910
queries on the on the cursor object and

00:03:27,750 --> 00:03:34,650
finally you free the resources by

00:03:29,910 --> 00:03:36,389
closing everything again so that was a

00:03:34,650 --> 00:03:39,930
short very very short introduction to

00:03:36,389 --> 00:03:42,810
the DB API the next part is going to be

00:03:39,930 --> 00:03:44,850
about transactions transactions are a

00:03:42,810 --> 00:03:46,769
very very useful thing in databases you

00:03:44,850 --> 00:03:48,959
can you can do stuff on your database

00:03:46,769 --> 00:03:50,549
and if you find that you've made a

00:03:48,959 --> 00:03:53,609
mistake you can just roll back your

00:03:50,549 --> 00:03:56,430
changes which is it's very nice to have

00:03:53,609 --> 00:03:58,530
it you need it in production system in

00:03:56,430 --> 00:04:03,720
production systems to work around bugs

00:03:58,530 --> 00:04:06,150
or input errors from from users so that

00:04:03,720 --> 00:04:08,600
your database doesn't become corrupted

00:04:06,150 --> 00:04:13,739
so it's very useful to to use these

00:04:08,600 --> 00:04:16,079
transactions however there are a few

00:04:13,739 --> 00:04:18,060
mistakes that people often make and and

00:04:16,079 --> 00:04:20,549
this sometimes causes people to not like

00:04:18,060 --> 00:04:22,740
transactions one common mistake is they

00:04:20,549 --> 00:04:25,080
forget to commit that changes so they

00:04:22,740 --> 00:04:28,289
apply a lot of changes on their cursors

00:04:25,080 --> 00:04:30,210
and connections and then close the

00:04:28,289 --> 00:04:31,410
application and see that the database

00:04:30,210 --> 00:04:33,720
hasn't really changed

00:04:31,410 --> 00:04:37,409
because the database API defaults to

00:04:33,720 --> 00:04:37,919
transactional it doesn't actually store

00:04:37,409 --> 00:04:40,630
the data

00:04:37,919 --> 00:04:44,419
if you don't do an explicit commit

00:04:40,630 --> 00:04:46,639
now a workaround for this is to just

00:04:44,419 --> 00:04:48,350
disable transactions which of course as

00:04:46,639 --> 00:04:51,590
possible in databases as well but it's

00:04:48,350 --> 00:04:53,720
not a really good workaround because

00:04:51,590 --> 00:04:57,289
instead of losing your changes you get

00:04:53,720 --> 00:04:59,240
data corruption for free another common

00:04:57,289 --> 00:05:01,130
mistake that people make is they they

00:04:59,240 --> 00:05:04,070
keep the transactions running for too

00:05:01,130 --> 00:05:05,600
long time and I'm coming to that later

00:05:04,070 --> 00:05:09,350
in the talk the transactions are

00:05:05,600 --> 00:05:11,509
basically your units of of locking

00:05:09,350 --> 00:05:13,550
things in the database so you want to

00:05:11,509 --> 00:05:15,650
keep transactions short to not lock

00:05:13,550 --> 00:05:18,380
other processes from accessing the

00:05:15,650 --> 00:05:21,320
database so what you have to do is you

00:05:18,380 --> 00:05:24,889
have to try to to make transactions

00:05:21,320 --> 00:05:27,289
short now the best practices of course

00:05:24,889 --> 00:05:29,389
like I said is always use transactions

00:05:27,289 --> 00:05:32,570
even if they are sometimes annoying

00:05:29,389 --> 00:05:35,180
don't use auto commit always try to make

00:05:32,570 --> 00:05:37,099
use of them keep your transactions short

00:05:35,180 --> 00:05:38,509
if they get too long you can run them in

00:05:37,099 --> 00:05:40,400
batches for example if you're loading

00:05:38,509 --> 00:05:43,250
data into your database it's it's much

00:05:40,400 --> 00:05:44,780
more convenient to do that in batches

00:05:43,250 --> 00:05:46,910
say a thousand rows a time and then you

00:05:44,780 --> 00:05:49,520
do commit that also keeps the

00:05:46,910 --> 00:05:52,880
transaction lock of the databases short

00:05:49,520 --> 00:05:56,539
and the performance will stay just fine

00:05:52,880 --> 00:05:57,860
so you won't really see the the overhead

00:05:56,539 --> 00:06:00,620
that is caused by the transaction

00:05:57,860 --> 00:06:02,150
mechanism and if you know that you're

00:06:00,620 --> 00:06:06,710
not actually writing to the database

00:06:02,150 --> 00:06:09,560
it's a very good practice to set the

00:06:06,710 --> 00:06:10,669
read-only flag on the database you can

00:06:09,560 --> 00:06:12,020
do that in the connection you can

00:06:10,669 --> 00:06:15,860
usually do that in the connection

00:06:12,020 --> 00:06:17,270
options and then the database will know

00:06:15,860 --> 00:06:21,590
that it's it's has a read-only

00:06:17,270 --> 00:06:23,780
connection so it'll basically not work

00:06:21,590 --> 00:06:27,830
on this not user transaction lock and

00:06:23,780 --> 00:06:33,620
make it make the whole query mechanism

00:06:27,830 --> 00:06:35,449
run much faster so that again was the

00:06:33,620 --> 00:06:38,270
simple kind of level of transactions

00:06:35,449 --> 00:06:40,520
then we have a more advanced level of

00:06:38,270 --> 00:06:42,320
transactions if you want to connect

00:06:40,520 --> 00:06:45,460
multiple databases and you want to have

00:06:42,320 --> 00:06:47,590
transaction span the different databases

00:06:45,460 --> 00:06:50,289
then you have to think about what what

00:06:47,590 --> 00:06:51,759
to do when you when you read data from

00:06:50,289 --> 00:06:54,130
one database and then put it into some

00:06:51,759 --> 00:06:56,050
other database of course you only want

00:06:54,130 --> 00:06:57,669
that to succeed if all the databases

00:06:56,050 --> 00:06:59,620
have actually received the data and

00:06:57,669 --> 00:07:04,000
that's what's called Trend distributed

00:06:59,620 --> 00:07:06,220
transactions typical use cases are in

00:07:04,000 --> 00:07:08,289
accounting for example you debit from

00:07:06,220 --> 00:07:10,060
from one account or one write a base and

00:07:08,289 --> 00:07:11,830
you credit the the amount to some other

00:07:10,060 --> 00:07:14,620
database you only want that to succeed

00:07:11,830 --> 00:07:17,470
if both databases have actually made the

00:07:14,620 --> 00:07:18,759
change and you have similar things in

00:07:17,470 --> 00:07:22,900
queue processing or if you want to

00:07:18,759 --> 00:07:24,759
integrate different applications now the

00:07:22,900 --> 00:07:25,690
the typical password that you'll hear

00:07:24,759 --> 00:07:27,490
when you're when talking about

00:07:25,690 --> 00:07:30,160
distributed transactions is two-phase

00:07:27,490 --> 00:07:33,669
commit which is the kind of the standard

00:07:30,160 --> 00:07:35,889
method of of approaching this problem so

00:07:33,669 --> 00:07:39,159
it works like this that you have a first

00:07:35,889 --> 00:07:40,720
phase in the first phase the commit is

00:07:39,159 --> 00:07:42,460
prepared so all the different databases

00:07:40,720 --> 00:07:44,169
are asked whether the commitment would

00:07:42,460 --> 00:07:48,250
would succeed with a high probability

00:07:44,169 --> 00:07:49,900
and if all databases say yes then you go

00:07:48,250 --> 00:07:53,139
to the second phase and you actually do

00:07:49,900 --> 00:07:56,590
the commit that's a tiny probability

00:07:53,139 --> 00:07:59,080
there that the the data is some database

00:07:56,590 --> 00:08:04,570
in that process may fail in that second

00:07:59,080 --> 00:08:07,360
phase and then I can say I'm sorry then

00:08:04,570 --> 00:08:08,919
your data is corrupt you have to work

00:08:07,360 --> 00:08:11,110
around that in some way because there's

00:08:08,919 --> 00:08:13,719
there's no easy way of undoing the

00:08:11,110 --> 00:08:16,810
second phase but most Ida bases just

00:08:13,719 --> 00:08:18,969
handle this fine to make it easier to

00:08:16,810 --> 00:08:20,440
deal with these transactions across

00:08:18,969 --> 00:08:22,719
multiple databases there's something

00:08:20,440 --> 00:08:26,169
called a transaction manager this is not

00:08:22,719 --> 00:08:28,930
in Python this is usually done in some

00:08:26,169 --> 00:08:32,950
other system for example there's MQ

00:08:28,930 --> 00:08:35,110
series from IBM or j2ee or Microsoft has

00:08:32,950 --> 00:08:38,560
this dtc mechanism some database systems

00:08:35,110 --> 00:08:41,229
db2 and Oracle offer these transaction

00:08:38,560 --> 00:08:44,589
managers you can sometimes hook into

00:08:41,229 --> 00:08:47,500
them from Python there are Python API

00:08:44,589 --> 00:08:49,630
for some of these and you can then use

00:08:47,500 --> 00:08:51,310
them or you can use a database specific

00:08:49,630 --> 00:08:54,430
specific one like for example the one

00:08:51,310 --> 00:08:57,010
that that's integrated into Postgres in

00:08:54,430 --> 00:08:58,730
the DB API we have address lists with a

00:08:57,010 --> 00:09:02,329
new set of api's

00:08:58,730 --> 00:09:04,370
the tpc api those are modeled after the

00:09:02,329 --> 00:09:07,579
IG's open standard for these transaction

00:09:04,370 --> 00:09:09,380
managers but unfortunately not many

00:09:07,579 --> 00:09:12,440
databases support this and that made it

00:09:09,380 --> 00:09:14,839
database modules actually provide these

00:09:12,440 --> 00:09:18,949
api's so you have to check your database

00:09:14,839 --> 00:09:23,510
with it supports this or not okay next

00:09:18,949 --> 00:09:27,490
point concurrent database access am I

00:09:23,510 --> 00:09:27,490
going too fast too slow

00:09:28,040 --> 00:09:31,490
concurrent database access is very

00:09:29,899 --> 00:09:34,430
important if you have multiple processes

00:09:31,490 --> 00:09:35,810
accessing your database for example if

00:09:34,430 --> 00:09:37,550
you have a web application because of

00:09:35,810 --> 00:09:40,639
the Gil you would normally want to have

00:09:37,550 --> 00:09:44,149
multiple processes set up to talk to

00:09:40,639 --> 00:09:46,430
your database and so it's important to

00:09:44,149 --> 00:09:48,470
think about how the databases deal with

00:09:46,430 --> 00:09:50,690
the problem of concurrent access so you

00:09:48,470 --> 00:09:53,000
have typical setups what I've written

00:09:50,690 --> 00:09:54,410
down here the most typical one is of

00:09:53,000 --> 00:09:57,170
course again the many writers many

00:09:54,410 --> 00:10:00,740
readers so there's no real special case

00:09:57,170 --> 00:10:03,139
that that fits in the common case you

00:10:00,740 --> 00:10:08,870
definitely need to make compromises in

00:10:03,139 --> 00:10:10,670
these setups so when when writing an

00:10:08,870 --> 00:10:13,880
application and thinking about this you

00:10:10,670 --> 00:10:15,529
have to ask yourself some questions for

00:10:13,880 --> 00:10:17,600
example should we just immediately see

00:10:15,529 --> 00:10:20,510
changes made by other transactions or

00:10:17,600 --> 00:10:22,579
maybe our other processes and should

00:10:20,510 --> 00:10:24,410
they even see things that went into the

00:10:22,579 --> 00:10:26,329
database even though the transactions in

00:10:24,410 --> 00:10:30,319
those processes have not yet been

00:10:26,329 --> 00:10:33,199
committed or should the reader just see

00:10:30,319 --> 00:10:35,240
everything as it was when it started the

00:10:33,199 --> 00:10:37,040
transaction so it doesn't see anything

00:10:35,240 --> 00:10:39,620
that came into the database after it

00:10:37,040 --> 00:10:41,870
started a transaction and the database

00:10:39,620 --> 00:10:45,560
they can the databases can can handle

00:10:41,870 --> 00:10:47,060
all these different situations they

00:10:45,560 --> 00:10:50,899
provide different what's called

00:10:47,060 --> 00:10:53,350
transaction isolation levels but they

00:10:50,899 --> 00:10:55,850
have to implement this using lakhs and

00:10:53,350 --> 00:10:57,589
lakhs is something that usually try to

00:10:55,850 --> 00:11:00,019
avoid in your application because they

00:10:57,589 --> 00:11:02,300
keep your your whole application from

00:11:00,019 --> 00:11:06,769
running in parallel and and using most

00:11:02,300 --> 00:11:08,959
of the the resources that you have so

00:11:06,769 --> 00:11:11,750
I'm going to walk through the typical

00:11:08,959 --> 00:11:14,150
sets of transactions

00:11:11,750 --> 00:11:15,890
isolation levels that you have the first

00:11:14,150 --> 00:11:18,320
one is the easiest one to implement it's

00:11:15,890 --> 00:11:21,290
read uncommitted which basically says

00:11:18,320 --> 00:11:23,690
you don't have any locks with read

00:11:21,290 --> 00:11:25,520
uncommitted isolation level all the

00:11:23,690 --> 00:11:26,780
processes that you have that talk to

00:11:25,520 --> 00:11:28,340
your database will immediately see

00:11:26,780 --> 00:11:31,460
everything that changes in the database

00:11:28,340 --> 00:11:33,230
even uncommitted changes so strange

00:11:31,460 --> 00:11:36,230
things can happen you can have 30 reads

00:11:33,230 --> 00:11:37,460
which means that you you read data from

00:11:36,230 --> 00:11:38,780
another process that hasn't been

00:11:37,460 --> 00:11:39,890
committed yet and you're not sure

00:11:38,780 --> 00:11:42,890
whether it's actually going to be

00:11:39,890 --> 00:11:46,310
committed later on you can have phantom

00:11:42,890 --> 00:11:47,780
reads which is something that basically

00:11:46,310 --> 00:11:49,400
says you you add something to the

00:11:47,780 --> 00:11:52,220
database in some other process and then

00:11:49,400 --> 00:11:54,770
you remove it again and and your process

00:11:52,220 --> 00:11:56,360
might have read this this row that was

00:11:54,770 --> 00:11:58,490
added by another process and later on is

00:11:56,360 --> 00:12:00,820
removed again so it's basically a

00:11:58,490 --> 00:12:02,630
phantom that you're working with and

00:12:00,820 --> 00:12:05,240
there are some other things that you

00:12:02,630 --> 00:12:07,340
have to watch out for if you want to

00:12:05,240 --> 00:12:09,290
read up on these things there's this URL

00:12:07,340 --> 00:12:11,750
down there it's gonna be in the in the

00:12:09,290 --> 00:12:14,620
talk slice you can click on it it's a

00:12:11,750 --> 00:12:17,330
very good explanation of these things

00:12:14,620 --> 00:12:19,730
then the next level is the read

00:12:17,330 --> 00:12:21,860
committed this is the default level in

00:12:19,730 --> 00:12:23,960
most database applications so when you

00:12:21,860 --> 00:12:27,230
open your connection you will usually

00:12:23,960 --> 00:12:29,510
get this oscillation level this

00:12:27,230 --> 00:12:31,670
isolation level basically says you only

00:12:29,510 --> 00:12:35,630
want to see changes that were committed

00:12:31,670 --> 00:12:38,750
to the database now you can still see

00:12:35,630 --> 00:12:41,000
changes that were made while you're

00:12:38,750 --> 00:12:43,010
running your current transaction so if

00:12:41,000 --> 00:12:44,420
some other process commits while you are

00:12:43,010 --> 00:12:47,900
running your transaction you will still

00:12:44,420 --> 00:12:51,040
see those but you will not see any

00:12:47,900 --> 00:12:54,410
uncommitted things from other processes

00:12:51,040 --> 00:12:58,280
so the way that it works is you you have

00:12:54,410 --> 00:13:00,950
this cursor this I drew this this table

00:12:58,280 --> 00:13:04,490
up there with the with the yellow bar in

00:13:00,950 --> 00:13:08,240
it it'll lock the current row it will

00:13:04,490 --> 00:13:11,300
put a read lock on it the database will

00:13:08,240 --> 00:13:13,310
if there is a write lock on a row it'll

00:13:11,300 --> 00:13:16,300
wait for that write lock to to be

00:13:13,310 --> 00:13:20,030
removed by the database so if some other

00:13:16,300 --> 00:13:22,580
transaction has written to that row that

00:13:20,030 --> 00:13:24,490
other transaction will have put a write

00:13:22,580 --> 00:13:26,830
lock on the row

00:13:24,490 --> 00:13:29,680
and the right lock is only removed if

00:13:26,830 --> 00:13:31,060
the transaction is committed so if the

00:13:29,680 --> 00:13:32,589
other transaction has committed to

00:13:31,060 --> 00:13:36,040
change then you can actually go ahead

00:13:32,589 --> 00:13:40,350
and actually read this row so this is

00:13:36,040 --> 00:13:40,350
basically you're just looking at one row

00:13:40,589 --> 00:13:47,050
then the next level is repeatable read

00:13:44,430 --> 00:13:49,450
this basically says that you Taino data

00:13:47,050 --> 00:13:50,980
won't change in the transaction so

00:13:49,450 --> 00:13:53,560
everything that was returned to your

00:13:50,980 --> 00:13:54,970
application by the database our scarran

00:13:53,560 --> 00:13:58,899
T to stay the same throughout the whole

00:13:54,970 --> 00:14:01,180
transaction and this of course requires

00:13:58,899 --> 00:14:03,130
more locks on the database so you you

00:14:01,180 --> 00:14:04,870
put locks on an obvious thing that you

00:14:03,130 --> 00:14:08,140
actually you pass back to the to the

00:14:04,870 --> 00:14:10,899
application and then the highest level

00:14:08,140 --> 00:14:14,830
is serializable which basically means

00:14:10,899 --> 00:14:18,399
whatever you do on your database the the

00:14:14,830 --> 00:14:20,140
database would will stay like that will

00:14:18,399 --> 00:14:22,630
say exactly like it was when you started

00:14:20,140 --> 00:14:24,970
the transaction and nothing will change

00:14:22,630 --> 00:14:29,079
and this requires lots and lots of locks

00:14:24,970 --> 00:14:30,700
the locks will not only address the

00:14:29,079 --> 00:14:32,050
things that you've read from the

00:14:30,700 --> 00:14:33,579
database or you've written to the

00:14:32,050 --> 00:14:35,740
database but everything that you've ever

00:14:33,579 --> 00:14:41,320
touched in the database so even whole

00:14:35,740 --> 00:14:43,660
tables if necessary all of these levels

00:14:41,320 --> 00:14:45,640
are necessary for some applications for

00:14:43,660 --> 00:14:47,380
example if you want to run a report you

00:14:45,640 --> 00:14:49,600
may have you may want to avoid

00:14:47,380 --> 00:14:51,370
inconsistencies in the report so you may

00:14:49,600 --> 00:14:55,329
for example want to use two serializable

00:14:51,370 --> 00:14:56,940
isolation level and there are these

00:14:55,329 --> 00:15:00,250
other levels can be used if you have

00:14:56,940 --> 00:15:05,829
situations that are not as strict about

00:15:00,250 --> 00:15:08,740
data processing so how do you do this in

00:15:05,829 --> 00:15:10,540
in Python there are two ways to do this

00:15:08,740 --> 00:15:13,360
well actually there are three you can

00:15:10,540 --> 00:15:16,600
usually have an option in the connection

00:15:13,360 --> 00:15:19,180
settings that you can set to to set a

00:15:16,600 --> 00:15:20,800
default isolation level but you can also

00:15:19,180 --> 00:15:23,200
do it dynamically in your application

00:15:20,800 --> 00:15:24,490
and you can actually do it on a per

00:15:23,200 --> 00:15:25,779
connection basis so you can have

00:15:24,490 --> 00:15:28,870
multiple connections to your database

00:15:25,779 --> 00:15:30,520
and different isolation levels you can

00:15:28,870 --> 00:15:32,890
run a statement set transaction

00:15:30,520 --> 00:15:34,900
isolation level for example or use

00:15:32,890 --> 00:15:36,940
sometimes some database modules have

00:15:34,900 --> 00:15:39,190
special ways of

00:15:36,940 --> 00:15:43,690
directly setting the option on the

00:15:39,190 --> 00:15:46,030
connection what's important to know is

00:15:43,690 --> 00:15:47,980
if you want to change the setting while

00:15:46,030 --> 00:15:49,420
having a connection open you need to

00:15:47,980 --> 00:15:51,010
make sure that no transaction is

00:15:49,420 --> 00:15:52,180
currently running on that connection so

00:15:51,010 --> 00:15:59,250
the easiest way to do that is just

00:15:52,180 --> 00:16:05,230
commit your connection or rollback write

00:15:59,250 --> 00:16:06,970
optimizations so you have a database

00:16:05,230 --> 00:16:09,460
application of course you want to run it

00:16:06,970 --> 00:16:11,290
as fast as possible the first thing that

00:16:09,460 --> 00:16:12,520
you should do is you should ask yourself

00:16:11,290 --> 00:16:14,980
what kind of system you're running

00:16:12,520 --> 00:16:16,720
whether you're running an OLTP system

00:16:14,980 --> 00:16:18,310
which means online transactions so

00:16:16,720 --> 00:16:20,380
you're interested in putting lots and

00:16:18,310 --> 00:16:22,840
lots of data in you're not so much

00:16:20,380 --> 00:16:25,870
interested in making complex queries on

00:16:22,840 --> 00:16:28,210
the database or you want the other thing

00:16:25,870 --> 00:16:30,070
you want to have data analysis so you

00:16:28,210 --> 00:16:32,820
already have all the data and usually a

00:16:30,070 --> 00:16:35,230
huge amount of data in your database and

00:16:32,820 --> 00:16:39,100
you're interested in doing complex

00:16:35,230 --> 00:16:40,990
queries multi-dimensional faceted search

00:16:39,100 --> 00:16:46,060
drill down all these things and then

00:16:40,990 --> 00:16:49,240
you'd use an OLAP system now just like

00:16:46,060 --> 00:16:52,120
with with transactions the the situation

00:16:49,240 --> 00:16:54,220
is often that you actually want the mix

00:16:52,120 --> 00:16:57,280
of both so you want to have both run

00:16:54,220 --> 00:16:59,620
fast so there's just one way you can do

00:16:57,280 --> 00:17:02,320
this depending on the size of databases

00:16:59,620 --> 00:17:05,410
that you're talking about one way is to

00:17:02,320 --> 00:17:06,820
put an OLTP system in front of your the

00:17:05,410 --> 00:17:08,740
system that's actually taking in the

00:17:06,820 --> 00:17:11,740
data and then every now and then you

00:17:08,740 --> 00:17:18,700
copy over that data into your oh l AP

00:17:11,740 --> 00:17:21,610
system to analyze it on a more lower

00:17:18,700 --> 00:17:23,260
level you can in python you can you have

00:17:21,610 --> 00:17:25,510
a certain number of problems that you

00:17:23,260 --> 00:17:28,180
can address directly one is for example

00:17:25,510 --> 00:17:30,400
your your queries run too slow and the

00:17:28,180 --> 00:17:32,620
queries are simple so you're just doing

00:17:30,400 --> 00:17:34,990
for example to select on a few on a few

00:17:32,620 --> 00:17:36,580
tables or few columns usual way to

00:17:34,990 --> 00:17:40,600
address that it's just you add more

00:17:36,580 --> 00:17:42,280
indexes because adding indexes is for

00:17:40,600 --> 00:17:44,020
easing database so some people they add

00:17:42,280 --> 00:17:47,290
indexes to everything they have in the

00:17:44,020 --> 00:17:49,510
database this slows down things because

00:17:47,290 --> 00:17:50,530
every time right into the database the

00:17:49,510 --> 00:17:52,510
database

00:17:50,530 --> 00:17:54,310
to update all these indexes and so you

00:17:52,510 --> 00:17:56,800
should really only put indexes on

00:17:54,310 --> 00:17:58,600
columns or on combinations of columns

00:17:56,800 --> 00:18:03,000
that you actually need in the database

00:17:58,600 --> 00:18:06,220
and the best way to find out which which

00:18:03,000 --> 00:18:08,290
tables and which columns you have to

00:18:06,220 --> 00:18:11,310
index it's best to use a query analyzer

00:18:08,290 --> 00:18:14,740
the database is usually offer a way to

00:18:11,310 --> 00:18:16,540
get the information about how a query is

00:18:14,740 --> 00:18:19,180
run in the database and you have a look

00:18:16,540 --> 00:18:21,130
at that you analyze the data and then

00:18:19,180 --> 00:18:23,350
you check which indexes you should put

00:18:21,130 --> 00:18:26,170
on the database and it'll increase the

00:18:23,350 --> 00:18:28,690
performance enormously if you're doing

00:18:26,170 --> 00:18:30,340
if you're using Python you can in some

00:18:28,690 --> 00:18:32,680
situations also add caching at the

00:18:30,340 --> 00:18:34,150
Python level so you visit you read your

00:18:32,680 --> 00:18:38,500
data from the database and you store it

00:18:34,150 --> 00:18:41,530
in memory for subsequent use you can

00:18:38,500 --> 00:18:43,960
even use sequel Lite for that if you

00:18:41,530 --> 00:18:48,340
have smaller data sets and do it in one

00:18:43,960 --> 00:18:51,360
in-memory processing now the next point

00:18:48,340 --> 00:18:54,100
is complex queries run too slow for

00:18:51,360 --> 00:18:56,350
example you have a report that's running

00:18:54,100 --> 00:18:59,460
on millions and millions of rows those

00:18:56,350 --> 00:19:02,500
will usually take a few minutes to run

00:18:59,460 --> 00:19:03,820
depending on how complex they are of

00:19:02,500 --> 00:19:06,880
course you just don't want to wait a few

00:19:03,820 --> 00:19:10,210
minutes for this so a common strategy

00:19:06,880 --> 00:19:13,390
for doing this is to pre-process some of

00:19:10,210 --> 00:19:15,460
the some parts of those queries so every

00:19:13,390 --> 00:19:17,590
say 50 minutes you run the queries you

00:19:15,460 --> 00:19:19,930
put them into a separate table and then

00:19:17,590 --> 00:19:26,320
you you run your reports on those query

00:19:19,930 --> 00:19:28,480
tables and again if your queries it

00:19:26,320 --> 00:19:31,390
themselves are too complex you can

00:19:28,480 --> 00:19:33,010
address that in Python as well what you

00:19:31,390 --> 00:19:36,340
do is you simply use split up your

00:19:33,010 --> 00:19:37,780
queries makes them easier to handle for

00:19:36,340 --> 00:19:39,550
the for the database and then you

00:19:37,780 --> 00:19:43,150
combine the results from those queries

00:19:39,550 --> 00:19:45,100
in Python a typical example of that is

00:19:43,150 --> 00:19:49,300
if you want to if you want to run a

00:19:45,100 --> 00:19:52,660
report that has aggregates right in the

00:19:49,300 --> 00:19:55,360
results set so doing that in in sequel

00:19:52,660 --> 00:19:57,280
is really hard and you can do it but

00:19:55,360 --> 00:19:59,800
it's really complex and it's much easier

00:19:57,280 --> 00:20:02,200
to do in Python so for this example you

00:19:59,800 --> 00:20:03,760
just run two queries you want run query

00:20:02,200 --> 00:20:05,560
for the details and you

00:20:03,760 --> 00:20:06,760
query for the for the aggregates and

00:20:05,560 --> 00:20:08,710
then you combine everything into a

00:20:06,760 --> 00:20:13,600
single table and use that in your

00:20:08,710 --> 00:20:15,520
application tips and tricks this is just

00:20:13,600 --> 00:20:19,090
a collection of random stuff that I just

00:20:15,520 --> 00:20:20,980
thought might be interesting for you

00:20:19,090 --> 00:20:23,320
typical problem you have is record ID

00:20:20,980 --> 00:20:25,900
creation so you want to put in a new row

00:20:23,320 --> 00:20:29,350
into your database if you need an ID for

00:20:25,900 --> 00:20:31,450
that for that record and you have this

00:20:29,350 --> 00:20:34,870
kind of chicken and egg problem because

00:20:31,450 --> 00:20:37,030
a typical way of doing that is to use an

00:20:34,870 --> 00:20:39,400
auto increment Karla meaning that in

00:20:37,030 --> 00:20:40,930
your database and just have the database

00:20:39,400 --> 00:20:42,730
deal with that or you have a sequence

00:20:40,930 --> 00:20:45,910
and get your IDs from that sequence in

00:20:42,730 --> 00:20:47,830
the database the problem there with the

00:20:45,910 --> 00:20:50,140
auto commit for example is race

00:20:47,830 --> 00:20:52,540
conditions because with the auto commit

00:20:50,140 --> 00:20:54,580
with the auto increment the database

00:20:52,540 --> 00:20:56,950
will take care of adding the the

00:20:54,580 --> 00:20:58,660
increment value and then you have to of

00:20:56,950 --> 00:21:01,150
course fetch that value again because

00:20:58,660 --> 00:21:05,110
you want to continue working on that row

00:21:01,150 --> 00:21:09,160
and the usual way is to ask the database

00:21:05,110 --> 00:21:10,900
for the last used ID and depending on

00:21:09,160 --> 00:21:12,840
how you do it you run into race

00:21:10,900 --> 00:21:14,830
conditions or you run into context can

00:21:12,840 --> 00:21:16,360
problems because it's not really clear

00:21:14,830 --> 00:21:18,970
what the last ID is that could have been

00:21:16,360 --> 00:21:21,070
some other transaction for example that

00:21:18,970 --> 00:21:22,300
also I've just inserted something and so

00:21:21,070 --> 00:21:25,330
it's not clear where to get that last

00:21:22,300 --> 00:21:27,280
are you from another way of doing that

00:21:25,330 --> 00:21:30,970
is you just you you let the auto

00:21:27,280 --> 00:21:33,270
increment field insert your ID for you

00:21:30,970 --> 00:21:35,800
and then you just query back the row

00:21:33,270 --> 00:21:37,720
simply by knowing what's in that row and

00:21:35,800 --> 00:21:39,370
you query the database for that row but

00:21:37,720 --> 00:21:42,460
that introduces the performance overhead

00:21:39,370 --> 00:21:44,770
so it's not really ideal something that

00:21:42,460 --> 00:21:47,230
we always use in our applications it's a

00:21:44,770 --> 00:21:50,830
very simple approach it's a kind of a

00:21:47,230 --> 00:21:53,170
randomized approach we simply have a big

00:21:50,830 --> 00:21:54,970
integer field for the ID and then we use

00:21:53,170 --> 00:21:58,090
a good random number generator to

00:21:54,970 --> 00:22:01,210
generate the ID for us and we just bet

00:21:58,090 --> 00:22:03,310
on not having collisions so we use that

00:22:01,210 --> 00:22:06,280
ID in the row we put it into the

00:22:03,310 --> 00:22:07,750
database and it usually succeeds in the

00:22:06,280 --> 00:22:10,120
very very rare cases where it doesn't

00:22:07,750 --> 00:22:13,560
succeed you just create a new random

00:22:10,120 --> 00:22:13,560
number and then you try again

00:22:14,250 --> 00:22:22,809
how does this work in Python well first

00:22:18,610 --> 00:22:26,559
you have to you have to set some some

00:22:22,809 --> 00:22:29,380
some constants so you have to have a row

00:22:26,559 --> 00:22:32,830
range ID what we often do is we set the

00:22:29,380 --> 00:22:35,530
highest bit so the ideas look nice then

00:22:32,830 --> 00:22:37,120
you have an API get random row ID this

00:22:35,530 --> 00:22:40,540
needs to be a thread local because every

00:22:37,120 --> 00:22:44,020
set thread should generates its own IDs

00:22:40,540 --> 00:22:45,250
so you don't get any overlaps and then

00:22:44,020 --> 00:22:48,100
you have to deal with setting up the

00:22:45,250 --> 00:22:49,929
random number generator and the best way

00:22:48,100 --> 00:22:51,970
to do that is to use system random to

00:22:49,929 --> 00:22:54,640
get a good seat for the random number

00:22:51,970 --> 00:22:57,669
tun ready and then you you put the seat

00:22:54,640 --> 00:22:59,230
you put it into hex and then you you fit

00:22:57,669 --> 00:23:01,809
a you see the random number generator

00:22:59,230 --> 00:23:07,419
with that and then use that in your

00:23:01,809 --> 00:23:09,130
thread local right next point is

00:23:07,419 --> 00:23:11,770
referential constraints people are

00:23:09,130 --> 00:23:12,850
usually very happy about using them does

00:23:11,770 --> 00:23:17,200
everyone know what the referential

00:23:12,850 --> 00:23:22,990
constraint is oh very few so it

00:23:17,200 --> 00:23:24,580
basically means this instead of for

00:23:22,990 --> 00:23:26,919
example you have a yeah the table up

00:23:24,580 --> 00:23:29,620
there with with you want to reference a

00:23:26,919 --> 00:23:31,750
product now instead of referencing the

00:23:29,620 --> 00:23:34,030
the product name directly in your table

00:23:31,750 --> 00:23:35,650
what you do is you reference the ID into

00:23:34,030 --> 00:23:38,980
the table that has all the product names

00:23:35,650 --> 00:23:40,720
and then you just put the ID into your

00:23:38,980 --> 00:23:43,120
table instead of the name and then in

00:23:40,720 --> 00:23:47,980
your report you combine all those things

00:23:43,120 --> 00:23:49,870
into into a nice-looking output and this

00:23:47,980 --> 00:23:51,880
process of referencing from one table to

00:23:49,870 --> 00:23:55,299
another is called a referential

00:23:51,880 --> 00:23:57,370
constraint usually you use foreign keys

00:23:55,299 --> 00:23:59,620
for that you can implement 1 to n

00:23:57,370 --> 00:24:01,990
mappings you can implement into M

00:23:59,620 --> 00:24:04,120
mappings the constraints are enforced by

00:24:01,990 --> 00:24:07,000
the database and that can sometimes lead

00:24:04,120 --> 00:24:09,669
to problems because if you for example

00:24:07,000 --> 00:24:12,250
you have lots of references in your day

00:24:09,669 --> 00:24:14,830
in your database schema and you want to

00:24:12,250 --> 00:24:17,020
load data into your database then it'll

00:24:14,830 --> 00:24:18,850
often fail because the the way that the

00:24:17,020 --> 00:24:21,580
data is loaded does not actually match

00:24:18,850 --> 00:24:23,620
those referential constraints and with

00:24:21,580 --> 00:24:25,070
some database you can switch off the the

00:24:23,620 --> 00:24:27,350
checking for those constraint

00:24:25,070 --> 00:24:31,009
during the load phase but it's not

00:24:27,350 --> 00:24:32,899
really ideal another thing that can

00:24:31,009 --> 00:24:36,049
happen is if you delete something then

00:24:32,899 --> 00:24:38,779
you can get cascaded delete which is not

00:24:36,049 --> 00:24:42,919
necessary what you want so what what we

00:24:38,779 --> 00:24:44,779
do for these things we just complete

00:24:42,919 --> 00:24:47,149
leave out the referential constraints

00:24:44,779 --> 00:24:49,789
and put everything into the into the

00:24:47,149 --> 00:24:51,320
Python database abstraction layer which

00:24:49,789 --> 00:24:52,909
has much more knowledge about these

00:24:51,320 --> 00:24:56,240
things is also a good idea to put those

00:24:52,909 --> 00:24:58,279
things into the business logic and then

00:24:56,240 --> 00:25:00,379
you avoid all these things so if you run

00:24:58,279 --> 00:25:02,690
into emotionally into an emergency

00:25:00,379 --> 00:25:04,970
situation where you have to quickly load

00:25:02,690 --> 00:25:06,350
data from a backup again you don't have

00:25:04,970 --> 00:25:07,789
to think about how to turn off the

00:25:06,350 --> 00:25:13,100
referential constraint you just load

00:25:07,789 --> 00:25:14,870
everything in works high availability is

00:25:13,100 --> 00:25:16,970
another one of those things that you

00:25:14,870 --> 00:25:20,330
have to think about so you have multiple

00:25:16,970 --> 00:25:22,460
databases one database server breaks

00:25:20,330 --> 00:25:25,450
want to switch over to the to the other

00:25:22,460 --> 00:25:28,309
one there very systems for doing that

00:25:25,450 --> 00:25:32,299
they tend to not always work perfectly

00:25:28,309 --> 00:25:34,039
so what something that can happen is you

00:25:32,299 --> 00:25:36,470
can have automatic fail back which means

00:25:34,039 --> 00:25:38,269
that you have a failover situation where

00:25:36,470 --> 00:25:39,950
the where the system switches to a

00:25:38,269 --> 00:25:41,990
different database and then it

00:25:39,950 --> 00:25:44,539
automatically comes back but you're not

00:25:41,990 --> 00:25:46,129
necessarily sure that all the database

00:25:44,539 --> 00:25:48,710
servers have actually synchronized by

00:25:46,129 --> 00:25:50,450
then so you can have to split what's

00:25:48,710 --> 00:25:53,120
called a split brain situation so you

00:25:50,450 --> 00:25:55,549
have the data is spread across different

00:25:53,120 --> 00:25:57,139
servers but you're not necessarily sure

00:25:55,549 --> 00:26:00,230
whether all the servers have the same

00:25:57,139 --> 00:26:02,659
data and of course some clients may miss

00:26:00,230 --> 00:26:04,070
the failover event so some clients may

00:26:02,659 --> 00:26:06,350
continue to write into a different

00:26:04,070 --> 00:26:09,080
database server than the one that is

00:26:06,350 --> 00:26:11,029
actually currently being used so again

00:26:09,080 --> 00:26:12,710
the best thing that you can do is you

00:26:11,029 --> 00:26:14,629
move back to python and manage

00:26:12,710 --> 00:26:16,159
everything in python and then you can

00:26:14,629 --> 00:26:17,720
also handle the communication between

00:26:16,159 --> 00:26:19,509
the clients and make sure that all the

00:26:17,720 --> 00:26:23,149
clients know about this failover event

00:26:19,509 --> 00:26:28,070
you can do the fail back in an optimal

00:26:23,149 --> 00:26:30,889
way and you can also use this for doing

00:26:28,070 --> 00:26:33,889
read optimizations you can have for

00:26:30,889 --> 00:26:35,570
example the database the application

00:26:33,889 --> 00:26:37,020
part writing to the database write to

00:26:35,570 --> 00:26:38,640
one database and then have the

00:26:37,020 --> 00:26:42,150
the synchronization between the

00:26:38,640 --> 00:26:44,190
databases take care of moving the data

00:26:42,150 --> 00:26:45,900
to the other server and at the same time

00:26:44,190 --> 00:26:47,700
while writing here you can read from the

00:26:45,900 --> 00:26:51,690
other database and you also avoid some

00:26:47,700 --> 00:26:56,400
of these locking issues so I actually

00:26:51,690 --> 00:26:59,300
made it 42 slides in half an hour that's

00:26:56,400 --> 00:26:59,300
it thank you for listening

00:27:07,280 --> 00:27:18,990
any questions yes Thanks so thank you

00:27:16,650 --> 00:27:20,010
for talk you said transactions shouldn't

00:27:18,990 --> 00:27:22,020
be too long

00:27:20,010 --> 00:27:25,260
also good measure for the size of

00:27:22,020 --> 00:27:27,330
transaction if you're writing to the

00:27:25,260 --> 00:27:28,799
database I'd say just maybe like ten to

00:27:27,330 --> 00:27:36,090
a hundred rows that you write in a

00:27:28,799 --> 00:27:38,850
single transaction okay thanks I you may

00:27:36,090 --> 00:27:41,669
not want to use random numbers for your

00:27:38,850 --> 00:27:45,090
for your IDs since you may break the

00:27:41,669 --> 00:27:49,020
internal awareness of location and the

00:27:45,090 --> 00:27:51,150
internal balance tree so it's maybe a

00:27:49,020 --> 00:27:53,640
good idea to use auto increment for the

00:27:51,150 --> 00:27:57,270
awareness of occasion otherwise you may

00:27:53,640 --> 00:28:00,630
have some performance issues during yeah

00:27:57,270 --> 00:28:03,419
during writing to the database okay yeah

00:28:00,630 --> 00:28:05,700
well we've measured it and it worked out

00:28:03,419 --> 00:28:07,590
fine so but we're in some databases

00:28:05,700 --> 00:28:13,470
we're using sequences for example from

00:28:07,590 --> 00:28:15,720
the database to generate those I think

00:28:13,470 --> 00:28:18,929
it depends on the implementation in the

00:28:15,720 --> 00:28:21,450
database so ycq land in ODB what may

00:28:18,929 --> 00:28:27,960
break them okay so alright we're mostly

00:28:21,450 --> 00:28:29,429
using Postgres so maybe hi I have a

00:28:27,960 --> 00:28:32,040
question maybe you can help me with that

00:28:29,429 --> 00:28:35,660
maybe I'm missing something because when

00:28:32,040 --> 00:28:38,400
you are talking about probably the slow

00:28:35,660 --> 00:28:42,390
complicated queries you suggested that

00:28:38,400 --> 00:28:45,510
you may split it into multiple simple

00:28:42,390 --> 00:28:47,160
quality queries and remove the wave of

00:28:45,510 --> 00:28:51,540
the computation a little bit to the

00:28:47,160 --> 00:28:54,169
Python and my question is why would it

00:28:51,540 --> 00:28:57,299
even speed up the process because I

00:28:54,169 --> 00:28:59,820
imagine that database is constructed in

00:28:57,299 --> 00:29:02,370
such a way that such query down in the

00:28:59,820 --> 00:29:05,040
maximum performance so what why would

00:29:02,370 --> 00:29:07,380
patent do the same logical thing faster

00:29:05,040 --> 00:29:09,210
it's it's not so much about speeding up

00:29:07,380 --> 00:29:10,559
the operation it's about making it

00:29:09,210 --> 00:29:11,970
possible in the first place because

00:29:10,559 --> 00:29:14,100
there are some things that you want to

00:29:11,970 --> 00:29:16,890
do in the reports that are not possible

00:29:14,100 --> 00:29:17,770
in sequel because sequel is too limited

00:29:16,890 --> 00:29:20,800
for the

00:29:17,770 --> 00:29:22,960
and it's in and even though if sometimes

00:29:20,800 --> 00:29:25,300
he can do things in sequel but but you

00:29:22,960 --> 00:29:26,770
get really huge sequel statements to do

00:29:25,300 --> 00:29:29,200
your processing well you have to resort

00:29:26,770 --> 00:29:30,820
to procedures and everything which makes

00:29:29,200 --> 00:29:32,440
things a lot more complicated so we

00:29:30,820 --> 00:29:34,510
found it's it's usually better instead

00:29:32,440 --> 00:29:36,220
of just wasting time thinking about how

00:29:34,510 --> 00:29:38,890
to structure your sequel properly and

00:29:36,220 --> 00:29:41,110
making a very complex it's easier to

00:29:38,890 --> 00:29:43,360
just have a few simple sequel queries

00:29:41,110 --> 00:29:45,700
and then just do the combination of

00:29:43,360 --> 00:29:48,070
those in in Python

00:29:45,700 --> 00:29:52,510
okay thanks the slow word made me

00:29:48,070 --> 00:29:54,309
confused yeah a bit thank you sorry hi

00:29:52,510 --> 00:29:56,650
thanks for the talk was very interesting

00:29:54,309 --> 00:29:58,600
just a suggestion based on the

00:29:56,650 --> 00:30:02,500
experience because I've been a DBA in a

00:29:58,600 --> 00:30:04,900
former life if you people do plan to do

00:30:02,500 --> 00:30:08,470
applications talk with your database

00:30:04,900 --> 00:30:10,660
people beforehand and just a usually

00:30:08,470 --> 00:30:12,550
nice they don't bite you just talk with

00:30:10,660 --> 00:30:14,470
the database people they can mail a make

00:30:12,550 --> 00:30:16,390
your life much easier because there is

00:30:14,470 --> 00:30:18,220
so much implementation detail to be

00:30:16,390 --> 00:30:20,950
considered so maybe that's a good

00:30:18,220 --> 00:30:22,990
question just to consider buy them lunch

00:30:20,950 --> 00:30:24,460
get out talk to hours of them it saves

00:30:22,990 --> 00:30:26,410
you about eight hours of programming

00:30:24,460 --> 00:30:29,110
time yes thank you thank you so that

00:30:26,410 --> 00:30:30,880
suggests by the way many of these things

00:30:29,110 --> 00:30:32,679
are database specifics so you really

00:30:30,880 --> 00:30:34,390
have to know your database if you want

00:30:32,679 --> 00:30:36,400
to make the proper decisions so they

00:30:34,390 --> 00:30:39,450
don't necessarily apply to all databases

00:30:36,400 --> 00:30:41,920
some databases are better some are worse

00:30:39,450 --> 00:30:45,540
we found that process is great database

00:30:41,920 --> 00:30:49,440
so use it that's our recommendation

00:30:45,540 --> 00:30:49,440

YouTube URL: https://www.youtube.com/watch?v=VWdGxmJLRgE


