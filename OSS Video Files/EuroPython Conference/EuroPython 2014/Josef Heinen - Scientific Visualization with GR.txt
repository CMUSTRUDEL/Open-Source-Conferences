Title: Josef Heinen - Scientific Visualization with GR
Publication date: 2015-04-18
Playlist: EuroPython 2014
Description: 
	Josef Heinen - Scientific Visualization with GR
[EuroPython 2014]
[25 July 2014]

Python developers often get frustrated when managing visualization packages that cover the specific needs in scientific or engineering environments. The GR framework could help. GR is a library for visualization applications ranging from publication-quality 2D graphs to the creation of complex 3D scenes and can easily be integrated into existing Python environments or distributions like Anaconda.

-----

Python has long been established in software development departments of research and industry, not least because of the proliferation of libraries such as *SciPy* and *Matplotlib*. However, when processing large amounts of data, in particular in combination with GUI toolkits (*Qt*) or three-dimensional visualizations (*OpenGL*), it seems that Python as an interpretative programming language may be reaching its limits.

---

*Outline*

- Introduction (1 min)
    - motivation
- GR framework (2 mins)
    - layer structure
    - output devices and capabilities
- GR3 framework (1 min)
    - layer structure
    - output capabilities (3 mins)
        - high-resolution images
        - POV-Ray scenes
        - OpenGL drawables
        - HTML5 / WebGL
- Simple 2D / 3D examples (2 min)
- Interoperability (PyQt/PySide, 3 min)
- How to speed up Python scripts (4 mins)
    - Numpy
    - Numba (Pro) 
- Animated visualization examples (live demos, 6 mins)
    - physics simulations
    - surfaces / meshes
    - molecule viewer
    - MRI voxel data
- Outlook (1 min)

*Notes*

Links to similar talks, tutorials or presentations can be found [here][1]. Unfortunately, most of them are in German language.

The GR framework has already been presented in a talk at PyCon DE [2012][2] and [2013][3], during a [poster session][4] at PyCon US 2013, and at [PythonCamps 2013][5] in Cologne. The slides for the PyCon.DE 2013 talk can be found [here][6].

As part of a collaboration the GR framework has been integrated into [NICOS][7] (a network-based control system completely written in Python) as a replacement for PyQwt.

  [1]: http://gr-framework.org/
  [2]: https://2012.de.pycon.org/programm/schedule/sessions/54
  [3]: https://2013.de.pycon.org/schedule/sessions/45/
  [4]: https://us.pycon.org/2013/schedule/presentation/158/
  [5]: http://josefheinen.de/rasberry-pi.html
  [6]: http://iffwww.iff.kfa-juelich.de/pub/doc/PyCon_DE_2013
  [7]: http://cdn.frm2.tum.de/fileadmin/stuff/services/ITServices/nicos-2.0/dirhtml/
Captions: 
	00:00:14,710 --> 00:00:20,890
Joseph I'm with the head of the

00:00:18,400 --> 00:00:22,690
scientific IT systems group at the

00:00:20,890 --> 00:00:26,080
portion sent home village in Germany and

00:00:22,690 --> 00:00:30,130
he will be giving a talk on the physical

00:00:26,080 --> 00:00:35,430
education system gr analogy is served

00:00:30,130 --> 00:00:35,430
ization system okay thanks Hef welcome

00:00:39,630 --> 00:00:44,920
so okay first of all thank you for

00:00:42,489 --> 00:00:46,899
coming here this morning my name is

00:00:44,920 --> 00:00:49,809
Josephine and together with my

00:00:46,899 --> 00:00:52,839
colleagues I'm working on different

00:00:49,809 --> 00:00:56,109
projects at forces central belief most

00:00:52,839 --> 00:00:58,000
of them are visualization systems and

00:00:56,109 --> 00:01:01,690
I'm proud to have the opportunity to

00:00:58,000 --> 00:01:06,960
give this talk here at Europe item about

00:01:01,690 --> 00:01:06,960
gr a framework for visualization systems

00:01:07,170 --> 00:01:11,980
so let me start with a question who is

00:01:09,610 --> 00:01:15,610
already using some scientific software

00:01:11,980 --> 00:01:21,310
with bison suchlike matplotlib my RV VT

00:01:15,610 --> 00:01:23,649
k or ok that's a big number as mentioned

00:01:21,310 --> 00:01:26,290
i am working at a research company and

00:01:23,649 --> 00:01:28,960
in the past years it turned out that

00:01:26,290 --> 00:01:31,780
they are a growing as there is a growing

00:01:28,960 --> 00:01:34,380
need for better and faster the

00:01:31,780 --> 00:01:39,670
visualization software especially

00:01:34,380 --> 00:01:41,890
scientists need easy to use methods for

00:01:39,670 --> 00:01:44,829
visualizing two and three-dimensional

00:01:41,890 --> 00:01:47,250
data sets possibly with a dynamic

00:01:44,829 --> 00:01:50,409
component and they want to create

00:01:47,250 --> 00:01:53,110
publication quality graphics and videos

00:01:50,409 --> 00:01:55,869
for their publications probably probably

00:01:53,110 --> 00:01:59,469
in the internet and they want to make

00:01:55,869 --> 00:02:04,509
glossy figures for high-impact walnuts

00:01:59,469 --> 00:02:06,159
or press releases at first glance those

00:02:04,509 --> 00:02:09,700
methods don't seem to be very

00:02:06,159 --> 00:02:12,880
challenging but we are talking about a

00:02:09,700 --> 00:02:17,650
later there are lot of scientific

00:02:12,880 --> 00:02:20,020
potting mix methods we need such as line

00:02:17,650 --> 00:02:22,140
bar graph curve plot scatter plots all

00:02:20,020 --> 00:02:25,170
these things you see on the slide here

00:02:22,140 --> 00:02:26,400
in principle there is nothing

00:02:25,170 --> 00:02:27,990
changing and there are thousands of

00:02:26,400 --> 00:02:33,120
solutions for all these kinds of

00:02:27,990 --> 00:02:35,480
plotting methods there are also powerful

00:02:33,120 --> 00:02:39,090
software libraries for scientific

00:02:35,480 --> 00:02:41,220
applications in Python those listed here

00:02:39,090 --> 00:02:46,650
on this slide are the most popular ones

00:02:41,220 --> 00:02:48,750
I think maybe I forgotten one but we all

00:02:46,650 --> 00:02:52,110
know matplotlib which is the workhorse

00:02:48,750 --> 00:02:55,950
and the de facto standard concerning

00:02:52,110 --> 00:02:57,680
graphics in Python and there's even my

00:02:55,950 --> 00:03:00,000
RV for for three-dimensional

00:02:57,680 --> 00:03:03,420
applications my RV which is very

00:03:00,000 --> 00:03:06,870
powerful and based on VT k and it offers

00:03:03,420 --> 00:03:10,100
the application interface called M lab

00:03:06,870 --> 00:03:13,880
which can be used in your own scripts

00:03:10,100 --> 00:03:15,959
that's VT k it's very versatile but it's

00:03:13,880 --> 00:03:19,200
difficult to learn because it's a very

00:03:15,959 --> 00:03:23,340
low level system and we have tools like

00:03:19,200 --> 00:03:26,810
wispy and OpenGL which are both very

00:03:23,340 --> 00:03:29,549
fast and which are limited to 3d and

00:03:26,810 --> 00:03:33,060
which are really the lowest level ap is

00:03:29,549 --> 00:03:35,959
44 graphics is pising and they are also

00:03:33,060 --> 00:03:39,480
some gooey towards Las shark just like a

00:03:35,959 --> 00:03:41,880
qwt with its corresponding 3d

00:03:39,480 --> 00:03:45,060
equivalents and the problem with this is

00:03:41,880 --> 00:03:48,260
that they are currently unmaintained at

00:03:45,060 --> 00:03:52,400
least four curves what my information is

00:03:48,260 --> 00:03:55,739
so there are some problems so far and

00:03:52,400 --> 00:03:58,620
the main problem I think is that the 2d

00:03:55,739 --> 00:04:02,209
world and the accelerated 3d world are

00:03:58,620 --> 00:04:06,870
separated you won't find a tool which

00:04:02,209 --> 00:04:10,650
provides services for both 3d and 3d 2d

00:04:06,870 --> 00:04:12,989
and 3d graphics and another problem is

00:04:10,650 --> 00:04:16,190
that some graphics backends only produce

00:04:12,989 --> 00:04:19,019
kind of figures so it's not possible to

00:04:16,190 --> 00:04:23,900
present present continuous data streams

00:04:19,019 --> 00:04:28,620
or from from from life sources and also

00:04:23,900 --> 00:04:30,030
affects me the experience that there's

00:04:28,620 --> 00:04:33,510
only a bare minimum level of

00:04:30,030 --> 00:04:36,440
interoperability so user interaction is

00:04:33,510 --> 00:04:40,610
somehow limited with with these tools

00:04:36,440 --> 00:04:44,420
also if we are talking about analyzing

00:04:40,610 --> 00:04:47,720
large data sets we often see that

00:04:44,420 --> 00:04:50,720
there's only a poor performance and also

00:04:47,720 --> 00:04:53,320
these api's are partly device and

00:04:50,720 --> 00:04:56,150
platform independent so your own scripts

00:04:53,320 --> 00:05:03,590
will suffer from some system

00:04:56,150 --> 00:05:06,770
dependencies after the time okay so

00:05:03,590 --> 00:05:09,580
let's parton get up and running and push

00:05:06,770 --> 00:05:12,530
for pride in there is a very nice

00:05:09,580 --> 00:05:14,870
distribution which has been introduced

00:05:12,530 --> 00:05:16,430
to you in the lighter in the in the

00:05:14,870 --> 00:05:19,820
keynote this morning it's called

00:05:16,430 --> 00:05:21,950
anaconda and I can only I would really

00:05:19,820 --> 00:05:25,880
like to recommend this distribution as

00:05:21,950 --> 00:05:32,480
it's very easy to install a complete

00:05:25,880 --> 00:05:35,600
scientific python snake but I think we

00:05:32,480 --> 00:05:39,680
need something more for example we need

00:05:35,600 --> 00:05:42,290
some more performance and this can also

00:05:39,680 --> 00:05:44,930
be achieved by anaconda atones for

00:05:42,290 --> 00:05:47,390
example number which is hot also be

00:05:44,930 --> 00:05:50,630
mentioned this morning which is capable

00:05:47,390 --> 00:05:54,350
of accelerating number or your python

00:05:50,630 --> 00:05:57,560
applications based which which contain

00:05:54,350 --> 00:06:01,310
vampire code even on GPU hardware on

00:05:57,560 --> 00:06:05,900
multi-core processors and i will give

00:06:01,310 --> 00:06:09,140
some example later there's something

00:06:05,900 --> 00:06:10,970
more we also want to achieve more

00:06:09,140 --> 00:06:14,060
graphics performs and interoperability

00:06:10,970 --> 00:06:17,000
and for this purpose i would like to

00:06:14,060 --> 00:06:18,919
introduce our gr framework which is a

00:06:17,000 --> 00:06:21,800
union frame universal framework for

00:06:18,919 --> 00:06:24,470
cross-platform visualization and the

00:06:21,800 --> 00:06:27,410
main keys key points are that it has a

00:06:24,470 --> 00:06:29,450
procedural graphics back end so you can

00:06:27,410 --> 00:06:32,540
really present continuous data streams

00:06:29,450 --> 00:06:36,500
and it has built-in device drivers so

00:06:32,540 --> 00:06:40,460
you can visualize both 2d and 3d scenes

00:06:36,500 --> 00:06:42,500
in in one canvas and there's a really

00:06:40,460 --> 00:06:45,980
good interoperability with

00:06:42,500 --> 00:06:48,800
GUI tool kits so you can establish a

00:06:45,980 --> 00:06:52,010
very good user interaction and as you

00:06:48,800 --> 00:06:59,720
can see in the bottom part of the slide

00:06:52,010 --> 00:07:02,600
it's also very easy to install so this

00:06:59,720 --> 00:07:04,790
would be our complete scientific bias

00:07:02,600 --> 00:07:08,060
and distribution I think we have

00:07:04,790 --> 00:07:10,940
everything we need especially we have

00:07:08,060 --> 00:07:13,640
more performance and interoperability so

00:07:10,940 --> 00:07:20,230
let me give some examples how this looks

00:07:13,640 --> 00:07:24,380
live you can see here a numeric

00:07:20,230 --> 00:07:28,840
simulation of a damp pendulum the

00:07:24,380 --> 00:07:32,060
calculation is done in the okapi

00:07:28,840 --> 00:07:35,270
aquaphor function you can see which is

00:07:32,060 --> 00:07:37,310
simply a numerical integration of this

00:07:35,270 --> 00:07:40,310
difference differential equation and you

00:07:37,310 --> 00:07:43,850
can see that you can mix graphics with

00:07:40,310 --> 00:07:46,280
text formulas and you can do all these

00:07:43,850 --> 00:07:49,820
things live while your script is running

00:07:46,280 --> 00:07:52,940
you don't have to produce figures or

00:07:49,820 --> 00:07:57,020
something like this the same works for

00:07:52,940 --> 00:08:00,200
3d you can see it here in this case with

00:07:57,020 --> 00:08:02,000
visualization is done with a API which

00:08:00,200 --> 00:08:05,530
has been written by a colleague of mine

00:08:02,000 --> 00:08:08,840
from young rim and he has written a

00:08:05,530 --> 00:08:12,080
OpenGL layer for GR which is called gr

00:08:08,840 --> 00:08:21,050
three and you see it's very performant

00:08:12,080 --> 00:08:24,979
and it does its job you can even ok you

00:08:21,050 --> 00:08:26,870
can even visualize live signals from

00:08:24,979 --> 00:08:33,530
from write files or from the microphone

00:08:26,870 --> 00:08:37,190
and let's lock x axis and this all runs

00:08:33,530 --> 00:08:38,990
in real time these are all things which

00:08:37,190 --> 00:08:45,010
are very hard to realize with other

00:08:38,990 --> 00:08:50,270
tools you can do this also in 3d I just

00:08:45,010 --> 00:08:56,200
pushed the audio away so so you can

00:08:50,270 --> 00:08:59,450
focus on the under graphics so the free

00:08:56,200 --> 00:09:02,510
spectrum is in this case visualized by

00:08:59,450 --> 00:09:05,180
by a surface plot which is realized with

00:09:02,510 --> 00:09:09,920
opengl and it's that fast as you could

00:09:05,180 --> 00:09:14,180
see you can also produce graphics with

00:09:09,920 --> 00:09:19,880
user interaction you can see here an MRI

00:09:14,180 --> 00:09:23,630
MRI application which renders some MRI

00:09:19,880 --> 00:09:26,720
data through a marching cubes algorithm

00:09:23,630 --> 00:09:30,440
which is part of our software and which

00:09:26,720 --> 00:09:36,160
can be rendered very very fast and moved

00:09:30,440 --> 00:09:41,930
the mouse so let's stop again about

00:09:36,160 --> 00:09:43,940
performance yeah we only have we not

00:09:41,930 --> 00:09:46,580
only have some some need for more

00:09:43,940 --> 00:09:49,070
graphics performance but also for for

00:09:46,580 --> 00:09:51,920
numerical performance and as mentioned

00:09:49,070 --> 00:09:53,780
before there's something called number

00:09:51,920 --> 00:09:57,020
which is part of anaconda but you also

00:09:53,780 --> 00:09:59,570
can install it for your own and there's

00:09:57,020 --> 00:10:03,710
number Pro which has some additional

00:09:59,570 --> 00:10:08,120
features it's a part of anaconda

00:10:03,710 --> 00:10:10,820
accelerate which cost a few bucks I

00:10:08,120 --> 00:10:17,420
don't know the actual price and it's

00:10:10,820 --> 00:10:21,140
capable of calculating numpy expressions

00:10:17,420 --> 00:10:24,050
on the GPU so you can write your own GPU

00:10:21,140 --> 00:10:27,430
kernels in Python and it's a really nice

00:10:24,050 --> 00:10:32,090
tool and it was to look at this software

00:10:27,430 --> 00:10:35,150
and they're even other tools like like

00:10:32,090 --> 00:10:40,940
KU + KU FFT cool rant but those tools

00:10:35,150 --> 00:10:44,620
are just dedicated to cuda hardware so

00:10:40,940 --> 00:10:49,640
in this case you can see how you can

00:10:44,620 --> 00:10:51,620
profit from such software you see a

00:10:49,640 --> 00:10:53,930
particle simulation which is very slow

00:10:51,620 --> 00:10:55,790
currently running at three frames per

00:10:53,930 --> 00:10:59,030
second and just by adding some

00:10:55,790 --> 00:11:02,020
decorators and an import statement for

00:10:59,030 --> 00:11:07,160
sure you can increase the performance by

00:11:02,020 --> 00:11:08,579
x 15 i think so it's you don't have to

00:11:07,160 --> 00:11:12,829
change your code and

00:11:08,579 --> 00:11:12,829
you can speed up your application

00:11:13,009 --> 00:11:19,410
enormously this is calculated in real

00:11:17,369 --> 00:11:23,220
time this would not be possible with

00:11:19,410 --> 00:11:25,170
this poor Python if you run the

00:11:23,220 --> 00:11:28,110
simulation pizen I think each frame is

00:11:25,170 --> 00:11:31,079
about three seconds in this case it was

00:11:28,110 --> 00:11:33,600
paralyzed or wrecked arised vectorized

00:11:31,079 --> 00:11:36,420
this is a i have several examples in our

00:11:33,600 --> 00:11:38,009
demo sweet just take a look at the

00:11:36,420 --> 00:11:44,249
website and you will see how the

00:11:38,009 --> 00:11:48,989
different optimizations work so let me

00:11:44,249 --> 00:11:51,540
introduce some of our success stories we

00:11:48,989 --> 00:11:55,860
have integrated our software in several

00:11:51,540 --> 00:11:58,920
of our applications we are working below

00:11:55,860 --> 00:12:03,259
both for experimental physicists and for

00:11:58,920 --> 00:12:06,989
info theoretical physicists and this is

00:12:03,259 --> 00:12:10,199
something for our instruments it's a

00:12:06,989 --> 00:12:12,749
life display for a small angle neutron

00:12:10,199 --> 00:12:18,540
diffraction matter and as you could see

00:12:12,749 --> 00:12:22,319
you can set the region of interest and

00:12:18,540 --> 00:12:24,989
the surface is generated in real time

00:12:22,319 --> 00:12:28,439
you can rotate it you can slip the axis

00:12:24,989 --> 00:12:33,029
and that's even more and all this can be

00:12:28,439 --> 00:12:36,629
done in real time so this is another

00:12:33,029 --> 00:12:40,799
example here we are processing a huge

00:12:36,629 --> 00:12:45,619
data set and it's also done in real time

00:12:40,799 --> 00:12:48,480
and which was formerly done by a

00:12:45,619 --> 00:12:50,610
proprietary solution and with the GRI

00:12:48,480 --> 00:12:55,769
make we could embed this into a cootie

00:12:50,610 --> 00:12:57,720
for my cootie for application which was

00:12:55,769 --> 00:12:59,399
a replace replacement for the existing

00:12:57,720 --> 00:13:01,949
solution and which is much much faster

00:12:59,399 --> 00:13:05,910
which can produce movies and all these

00:13:01,949 --> 00:13:11,399
funny things there's another example

00:13:05,910 --> 00:13:15,240
here Niko's it's a very complex network

00:13:11,399 --> 00:13:19,940
based control system which is used in

00:13:15,240 --> 00:13:23,160
at frost on track dimension in Munich

00:13:19,940 --> 00:13:27,680
for all the instruments which do neutron

00:13:23,160 --> 00:13:33,899
scattering and in this case we placed a

00:13:27,680 --> 00:13:37,170
pike qet cool WTO application with a

00:13:33,899 --> 00:13:39,959
couch EGR application and it's it was

00:13:37,170 --> 00:13:43,800
much faster it was more responsive and

00:13:39,959 --> 00:13:45,690
it it was it had some additional

00:13:43,800 --> 00:13:49,890
features which which we didn't have F

00:13:45,690 --> 00:13:55,200
before so this is a case study to see

00:13:49,890 --> 00:13:58,380
how fast you can simulate data born is a

00:13:55,200 --> 00:14:06,750
software for for simulating neutron and

00:13:58,380 --> 00:14:09,209
x-ray scattering to compare it it was a

00:14:06,750 --> 00:14:11,640
replacement for matplotlib at this point

00:14:09,209 --> 00:14:14,279
and it uses a single it uses a single

00:14:11,640 --> 00:14:18,149
call it's the line just in the bottom of

00:14:14,279 --> 00:14:20,760
the left side and if you look at the old

00:14:18,149 --> 00:14:23,940
code if you compare the old source code

00:14:20,760 --> 00:14:27,810
with a new one well that's only one line

00:14:23,940 --> 00:14:31,800
and an export statement to generate a

00:14:27,810 --> 00:14:34,230
movie for example so it's not such

00:14:31,800 --> 00:14:39,890
complicated to produce movies with a gr

00:14:34,230 --> 00:14:39,890
framework so what are the conclusions

00:14:40,550 --> 00:14:49,230
the use of Python with rgr framework and

00:14:45,230 --> 00:14:51,930
number and perhaps number pro extensions

00:14:49,230 --> 00:14:53,610
allow the relation realization of

00:14:51,930 --> 00:14:56,370
high-performance visualization

00:14:53,610 --> 00:15:00,329
applications both in scientific and

00:14:56,370 --> 00:15:02,399
technical environments and the GR

00:15:00,329 --> 00:15:06,630
framework can seamlessly be integrated

00:15:02,399 --> 00:15:11,640
into any Python environment i would

00:15:06,630 --> 00:15:14,490
suggest suggest to use anaconda the

00:15:11,640 --> 00:15:17,490
integration is simply done by a ctypes

00:15:14,490 --> 00:15:21,600
mechanism so you can also use it in your

00:15:17,490 --> 00:15:23,910
own python distribution and the

00:15:21,600 --> 00:15:25,670
combination condo and anaconda provider

00:15:23,910 --> 00:15:28,250
very easy to manage

00:15:25,670 --> 00:15:30,110
and ready to use bison distributions

00:15:28,250 --> 00:15:33,680
that can be an hour enhanced by the use

00:15:30,110 --> 00:15:36,110
of our gr framework especially with its

00:15:33,680 --> 00:15:42,070
functions for real time or 3d

00:15:36,110 --> 00:15:42,070
visualization functions so what's next

00:15:43,480 --> 00:15:51,050
we are not far from implementing a model

00:15:47,690 --> 00:15:53,600
molecular dynamics package and which

00:15:51,050 --> 00:15:56,990
will be do such results we have already

00:15:53,600 --> 00:15:59,600
all this stuff written in C and simply

00:15:56,990 --> 00:16:02,870
have to write some simple reports which

00:15:59,600 --> 00:16:06,020
will then be integrated into our dr

00:16:02,870 --> 00:16:08,920
framework and with this framework you

00:16:06,020 --> 00:16:12,170
will be able to do things like this year

00:16:08,920 --> 00:16:14,450
the simulation which has been calculated

00:16:12,170 --> 00:16:17,210
on a very big machine and the data is

00:16:14,450 --> 00:16:20,750
read with a simple Python script and

00:16:17,210 --> 00:16:25,310
then ran not with a GRE library you can

00:16:20,750 --> 00:16:27,410
then export this scene too for example

00:16:25,310 --> 00:16:31,040
pas vrai and produce a high quality

00:16:27,410 --> 00:16:34,930
graphics like shown in the right side of

00:16:31,040 --> 00:16:37,670
the slide and you can even do this in

00:16:34,930 --> 00:16:41,020
highest resolution if you give the

00:16:37,670 --> 00:16:43,700
correct parameters to those routines and

00:16:41,020 --> 00:16:50,270
you can see here it's very for your list

00:16:43,700 --> 00:16:54,470
realistic presentation of our DNA so

00:16:50,270 --> 00:16:56,870
what are our future plans well we have

00:16:54,470 --> 00:17:01,670
thought to combine the power of my plot

00:16:56,870 --> 00:17:04,160
lip and gr and we think it should be

00:17:01,670 --> 00:17:08,000
possible and the basic idea is to use

00:17:04,160 --> 00:17:11,690
the our resume plot let back and so this

00:17:08,000 --> 00:17:13,610
would speed up med plot lip and all your

00:17:11,690 --> 00:17:18,770
met what lip scripts would profit from

00:17:13,610 --> 00:17:21,260
this speed up I think it's possible we

00:17:18,770 --> 00:17:25,280
didn't start this development but I

00:17:21,260 --> 00:17:32,230
think we there's a good chance that we

00:17:25,280 --> 00:17:32,230
get this thing's running and

00:17:33,930 --> 00:17:38,920
there are even more challenges you

00:17:36,910 --> 00:17:42,550
learned about bouquet this morning and I

00:17:38,920 --> 00:17:44,620
think this should also be possible once

00:17:42,550 --> 00:17:47,740
we have the matplotlib integration it

00:17:44,620 --> 00:17:49,900
should also be possible to connect those

00:17:47,740 --> 00:17:52,660
scripts to the bouquet back end which

00:17:49,900 --> 00:17:57,040
travis mentioned this morning in the

00:17:52,660 --> 00:18:02,740
keynote at this part I think we should

00:17:57,040 --> 00:18:05,890
talk to Travis to cooperate on this

00:18:02,740 --> 00:18:08,320
slide you'll find some resources there's

00:18:05,890 --> 00:18:13,780
a website for our framework there's a

00:18:08,320 --> 00:18:18,030
good rebel it's hosted on by package in

00:18:13,780 --> 00:18:20,980
the index we even have first beam star a

00:18:18,030 --> 00:18:23,880
binary distribution store for the GR

00:18:20,980 --> 00:18:27,670
framework and the talk should be online

00:18:23,880 --> 00:18:33,850
on this link which you can find out

00:18:27,670 --> 00:18:36,460
later so some closing words maybe you

00:18:33,850 --> 00:18:38,650
hate me after this but I think that's

00:18:36,460 --> 00:18:40,390
important i think that visualization

00:18:38,650 --> 00:18:43,390
visualizations offer could be even

00:18:40,390 --> 00:18:45,130
better raphy the prerequisites of

00:18:43,390 --> 00:18:47,980
foreign application would be described

00:18:45,130 --> 00:18:52,330
in terms of usability responsiveness and

00:18:47,980 --> 00:18:54,970
interoperability instead of a list of

00:18:52,330 --> 00:18:57,700
software whiz with module dependencies

00:18:54,970 --> 00:19:00,040
we should use native api's on the

00:18:57,700 --> 00:19:03,070
different systems instead of do I

00:19:00,040 --> 00:19:06,600
toolkits and release updates should not

00:19:03,070 --> 00:19:09,940
break version compatibility this is

00:19:06,600 --> 00:19:14,560
something that I have observed very

00:19:09,940 --> 00:19:17,190
often so let me end up and thank you for

00:19:14,560 --> 00:19:17,190
your attention

00:19:22,880 --> 00:19:30,260
thanks for from me for this great talk

00:19:25,590 --> 00:19:30,260
any questions are there any questions

00:19:35,420 --> 00:19:40,440
one of the features of matplotlib that I

00:19:38,220 --> 00:19:42,780
find very convenient is its integration

00:19:40,440 --> 00:19:44,760
with ipython notebook because I can play

00:19:42,780 --> 00:19:46,740
with the visualization before I

00:19:44,760 --> 00:19:49,620
integrate it into some application or

00:19:46,740 --> 00:19:51,600
save a high resolution copy for

00:19:49,620 --> 00:19:55,950
publication or something like that so I

00:19:51,600 --> 00:19:57,510
wonder if is gr framework compatible

00:19:55,950 --> 00:19:59,850
with typewriter notebook and I use it

00:19:57,510 --> 00:20:02,850
from there right now it's not but

00:19:59,850 --> 00:20:05,040
because I some discrepancy on the others

00:20:02,850 --> 00:20:08,280
on the one side we are talking about

00:20:05,040 --> 00:20:12,210
immediate mode graphics and we'll

00:20:08,280 --> 00:20:15,810
ipython notebook there's just a sequence

00:20:12,210 --> 00:20:20,870
of commands and maybe if you get our med

00:20:15,810 --> 00:20:23,670
plot lip back and running as we

00:20:20,870 --> 00:20:25,410
reconsider that it could work then it

00:20:23,670 --> 00:20:28,050
might be possible to use an eye person

00:20:25,410 --> 00:20:41,280
but I'm not sure about this thank you

00:20:28,050 --> 00:20:42,870
we'll do our best thanks I'm doing all

00:20:41,280 --> 00:20:46,170
the training of neural networks inside

00:20:42,870 --> 00:20:47,910
cy thon very almost completely outside

00:20:46,170 --> 00:20:51,750
of global interpreter lock would it be

00:20:47,910 --> 00:20:54,120
possible for me to bind to see api's or

00:20:51,750 --> 00:20:55,980
see wife and I p is that are excluding

00:20:54,120 --> 00:20:58,530
global interpreter lock or do i have to

00:20:55,980 --> 00:21:00,060
bind back through python then as I want

00:20:58,530 --> 00:21:01,590
to visualize the training of the network

00:21:00,060 --> 00:21:05,340
during the training process and it's

00:21:01,590 --> 00:21:06,840
really cool for that oh I'm not sure

00:21:05,340 --> 00:21:13,860
about this I think we have to talk about

00:21:06,840 --> 00:21:18,030
this occupation I'm sorry are there any

00:21:13,860 --> 00:21:20,850
more questions okay I have a question

00:21:18,030 --> 00:21:24,300
and when you use this vectorize

00:21:20,850 --> 00:21:27,930
decorator and you use the same code in

00:21:24,300 --> 00:21:29,049
the yarn limited orb of a basic number

00:21:27,930 --> 00:21:31,330
version

00:21:29,049 --> 00:21:33,100
with this just do nothing or will it

00:21:31,330 --> 00:21:35,710
complain with the name error or

00:21:33,100 --> 00:21:38,499
something or import error it's this

00:21:35,710 --> 00:21:40,899
vectorize decorator available I mean

00:21:38,499 --> 00:21:46,779
even if it does nothing in the basic

00:21:40,899 --> 00:21:48,820
number version who so you mean if it's

00:21:46,779 --> 00:21:51,279
not present on your machine oh yeah yeah

00:21:48,820 --> 00:21:53,710
okay I mean I mean for example you have

00:21:51,279 --> 00:21:56,889
to spec to us which I think I understood

00:21:53,710 --> 00:21:58,749
only works for the pro version and if

00:21:56,889 --> 00:22:00,879
you have only the basic version and so

00:21:58,749 --> 00:22:05,980
that the difference is that the pro

00:22:00,879 --> 00:22:11,019
version is capable of pushing those llvm

00:22:05,980 --> 00:22:13,450
code on the on the GPU and the public

00:22:11,019 --> 00:22:18,009
version is only capable of paralyzing on

00:22:13,450 --> 00:22:20,470
your own cpu yeah so pro version is only

00:22:18,009 --> 00:22:23,159
needed if you want to use your GPU for

00:22:20,470 --> 00:22:27,700
the computing of vampire operations yeah

00:22:23,159 --> 00:22:29,409
what I meant is if I have if I get code

00:22:27,700 --> 00:22:32,409
from you which has the spectre rise

00:22:29,409 --> 00:22:34,539
decorator and i only have the basic

00:22:32,409 --> 00:22:36,369
version installed will it just not back

00:22:34,539 --> 00:22:39,730
to rise but otherwise ignore the

00:22:36,369 --> 00:22:43,210
vectorize decorator no this would not

00:22:39,730 --> 00:22:46,330
work okay so if you use want to try

00:22:43,210 --> 00:22:48,609
those demos you really have to to

00:22:46,330 --> 00:22:53,320
purchase the pro version but there are a

00:22:48,609 --> 00:22:55,929
lot of other demos which don't depend on

00:22:53,320 --> 00:23:00,580
on the pro version okay thanks a lot

00:22:55,929 --> 00:23:04,330
yeah okay if there are no okay meanwhile

00:23:00,580 --> 00:23:07,799
no questions have been added or okay so

00:23:04,330 --> 00:23:07,799
thanks again yeah

00:23:11,140 --> 00:23:13,200

YouTube URL: https://www.youtube.com/watch?v=hF_FBsdr-Qk


