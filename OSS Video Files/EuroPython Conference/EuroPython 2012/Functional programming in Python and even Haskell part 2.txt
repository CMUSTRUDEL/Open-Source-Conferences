Title: Functional programming in Python and even Haskell part 2
Publication date: 2015-04-19
Playlist: EuroPython 2012
Description: 
	[EuroPython 2012] S Trygubenko - 5 JULY 2012 in "Track Pizza Napoli"
Captions: 
	00:00:29,970 --> 00:00:50,280
one two one two three testing good one

00:01:07,050 --> 00:01:11,060
so it's time to start the link

00:01:41,860 --> 00:01:52,310
yeah yeah yeah I'll try not to overrun

00:01:48,640 --> 00:01:55,850
so so we start I think most of us are

00:01:52,310 --> 00:01:58,670
here so I've got some feedback on the

00:01:55,850 --> 00:02:01,610
solution that I provided and and I've

00:01:58,670 --> 00:02:03,560
improved it a little bit so what I

00:02:01,610 --> 00:02:05,660
wanted I wanted the PEC functionality to

00:02:03,560 --> 00:02:08,780
be in a separate function for the

00:02:05,660 --> 00:02:11,120
reasons to become clear later so and

00:02:08,780 --> 00:02:13,880
also the key is obviously already

00:02:11,120 --> 00:02:17,540
readily available so I passed it to back

00:02:13,880 --> 00:02:20,959
function and group is actually a

00:02:17,540 --> 00:02:22,580
generator so does anyone know what's the

00:02:20,959 --> 00:02:30,980
complexity of land operation on a

00:02:22,580 --> 00:02:33,110
generator ok so in that case whether you

00:02:30,980 --> 00:02:35,570
convert it to list outside of back or

00:02:33,110 --> 00:02:37,940
inside it's a question of clarity rather

00:02:35,570 --> 00:02:41,510
than efficiency so that's the solution I

00:02:37,940 --> 00:02:45,620
wanted so the next is the same in

00:02:41,510 --> 00:02:50,180
Haskell so in this case and I have

00:02:45,620 --> 00:02:51,950
spoken about this or mm probably not so

00:02:50,180 --> 00:02:57,110
this hostile solution was the same

00:02:51,950 --> 00:02:58,940
problem we have two functions apec

00:02:57,110 --> 00:03:00,410
function and encode function and co

00:02:58,940 --> 00:03:04,040
function is very similar to what you've

00:03:00,410 --> 00:03:08,299
seen before when we flottant the list so

00:03:04,040 --> 00:03:10,760
it groups the elements then it pipes

00:03:08,299 --> 00:03:14,120
it'll function which was made by

00:03:10,760 --> 00:03:15,680
carrying the first argument of map with

00:03:14,120 --> 00:03:17,959
a PEC function and PEG function is

00:03:15,680 --> 00:03:20,209
basically a function that takes a list

00:03:17,959 --> 00:03:24,680
of elements of type A and returns a

00:03:20,209 --> 00:03:27,110
tuple of lengths to and since we want

00:03:24,680 --> 00:03:29,180
our list to be polymorphic we don't

00:03:27,110 --> 00:03:33,310
actually specify what type of a is until

00:03:29,180 --> 00:03:38,720
this point here where we force it to be

00:03:33,310 --> 00:03:40,670
a member of the Equality tight class

00:03:38,720 --> 00:03:43,519
that's only constrained because we need

00:03:40,670 --> 00:03:48,260
to compare for equality for the purposes

00:03:43,519 --> 00:03:51,639
of invoking group so that's the Haskell

00:03:48,260 --> 00:03:53,810
solution and now the exercise is to

00:03:51,639 --> 00:03:58,040
modify the previous solution

00:03:53,810 --> 00:04:00,860
a little bit so that this is not

00:03:58,040 --> 00:04:03,560
particularly great compression when we

00:04:00,860 --> 00:04:06,800
have one element and we convert it into

00:04:03,560 --> 00:04:09,770
two pole thanks to so we want now an

00:04:06,800 --> 00:04:12,050
inhomogeneous list where if an element

00:04:09,770 --> 00:04:15,549
is repeated once it just copied as is

00:04:12,050 --> 00:04:23,930
and if element is repeated more than

00:04:15,549 --> 00:04:29,270
once then we want to pop okay so work on

00:04:23,930 --> 00:04:34,300
whatever you you forget so what is that

00:04:29,270 --> 00:04:36,800
is run length encoding to a one I think

00:04:34,300 --> 00:04:39,080
one of the two so it should have this

00:04:36,800 --> 00:04:41,000
set of tests I think the test for the

00:04:39,080 --> 00:04:44,530
second one is the same but with a verbal

00:04:41,000 --> 00:04:44,530
constraint so you can use either

00:04:54,220 --> 00:04:57,210
00:05:01,290 --> 00:05:04,290
yep

00:05:12,620 --> 00:05:29,180
it should be on the in the solutions for

00:05:15,169 --> 00:05:34,150
their okay yeah yeah that's a

00:05:29,180 --> 00:05:34,150
destructive non-recursive yeah

00:05:54,289 --> 00:06:02,199
yeah probably try it I haven't tested it

00:05:58,550 --> 00:06:02,199
if not pitches welcome

00:06:53,749 --> 00:06:56,749
music

00:06:57,340 --> 00:07:03,000
yeah this money

00:07:04,850 --> 00:07:07,850
yes

00:07:42,040 --> 00:07:44,610
it

00:07:50,849 --> 00:07:53,509
mmm

00:08:02,650 --> 00:08:07,530
yeah we bit messy doing this way

00:08:42,680 --> 00:08:45,070
oops

00:08:45,820 --> 00:08:48,750
hmm

00:08:54,499 --> 00:08:57,499
east

00:09:10,540 --> 00:09:13,110
and

00:09:17,970 --> 00:09:25,620
so we're probably done with this is the

00:09:23,759 --> 00:09:28,649
solution I came up with which can be

00:09:25,620 --> 00:09:31,589
refactored to sopek function has the

00:09:28,649 --> 00:09:35,089
same interface but basically I just have

00:09:31,589 --> 00:09:38,310
an if statement the checks if it's a

00:09:35,089 --> 00:09:41,430
list a sub list of lengths one in that

00:09:38,310 --> 00:09:45,389
case I just returning on and the encode

00:09:41,430 --> 00:09:47,639
function is the same so the Haskell

00:09:45,389 --> 00:09:53,220
version now that we've come up with

00:09:47,639 --> 00:09:57,269
homogeneous lists it is slightly more

00:09:53,220 --> 00:09:59,939
involved we have to define a list item

00:09:57,269 --> 00:10:02,699
again and we define it to have two

00:09:59,939 --> 00:10:07,050
constructors a single a and multiple in

00:10:02,699 --> 00:10:09,480
teh where the first argument is of type

00:10:07,050 --> 00:10:13,100
int and it represents the multiplicity

00:10:09,480 --> 00:10:17,009
and second one is the element itself and

00:10:13,100 --> 00:10:19,110
I realized pack as an if statement so if

00:10:17,009 --> 00:10:23,639
I check if it's of blanks one then I

00:10:19,110 --> 00:10:25,920
return single and I passed value and if

00:10:23,639 --> 00:10:29,309
otherwise it's multiple and the end this

00:10:25,920 --> 00:10:32,610
is a neat way of defining local

00:10:29,309 --> 00:10:35,519
variables in hostel in within that if

00:10:32,610 --> 00:10:38,160
statement so I take where I had to put

00:10:35,519 --> 00:10:39,480
it on one line to make sure it fits on

00:10:38,160 --> 00:10:42,559
the slide but you don't have to for

00:10:39,480 --> 00:10:48,559
clarity usually I'll line them here and

00:10:42,559 --> 00:10:48,559
encode function did not change a bit

00:10:51,439 --> 00:11:01,259
so say it again their constructors so

00:10:58,859 --> 00:11:07,169
you these are constructors you can

00:11:01,259 --> 00:11:08,909
create an item of type list a the

00:11:07,169 --> 00:11:11,129
following way you can write single and

00:11:08,909 --> 00:11:12,569
that item or you can multiple and then

00:11:11,129 --> 00:11:16,379
you have to provide multiplicity and

00:11:12,569 --> 00:11:19,799
they own it yeah this is this is a way

00:11:16,379 --> 00:11:29,219
to have a user-defined data types in

00:11:19,799 --> 00:11:32,189
Haskell oh it's here this is all of this

00:11:29,219 --> 00:11:34,439
this one liner is a definition yeah it's

00:11:32,189 --> 00:11:36,779
a definition so to read it you read it

00:11:34,439 --> 00:11:39,979
that the everything on the right is the

00:11:36,779 --> 00:11:44,909
constructors and on the left is the type

00:11:39,979 --> 00:11:51,719
yeah so the pison for the previous

00:11:44,909 --> 00:11:54,149
exercise yeah yeah it just I chose them

00:11:51,719 --> 00:11:56,369
I have this extra constraint I keep them

00:11:54,149 --> 00:12:00,589
in sync the cusco and bison solutions so

00:11:56,369 --> 00:12:00,589
it's easy to read so there is less as

00:12:01,849 --> 00:12:09,949
well the really functional functional

00:12:05,369 --> 00:12:09,949
way I'd say is please recursion here but

00:12:10,459 --> 00:12:17,449
we'll get to that in a second yep

00:12:20,310 --> 00:12:31,310
yeah so in that case we can have it as a

00:12:25,490 --> 00:12:34,080
generator expression yeah yeah cool so

00:12:31,310 --> 00:12:37,260
there is slight difference there and

00:12:34,080 --> 00:12:41,310
they yield is slightly faster I think I

00:12:37,260 --> 00:12:45,330
mentioned before yeah so this is a

00:12:41,310 --> 00:12:49,050
haskell solution please have a prod when

00:12:45,330 --> 00:12:52,620
you have time and the next exercise has

00:12:49,050 --> 00:12:54,210
the same set of constraints in terms of

00:12:52,620 --> 00:12:57,210
sorts but there is a verbal constraint

00:12:54,210 --> 00:13:00,300
what we been doing before we've been

00:12:57,210 --> 00:13:03,510
taking the list which was taken memory

00:13:00,300 --> 00:13:05,550
water and then we were creating another

00:13:03,510 --> 00:13:07,500
data structure that contains sub lists

00:13:05,550 --> 00:13:09,150
and what was this effectively meant

00:13:07,500 --> 00:13:11,550
we've created a copy of it only

00:13:09,150 --> 00:13:13,860
differently structured so at one point

00:13:11,550 --> 00:13:18,540
in the execution time there was the

00:13:13,860 --> 00:13:20,940
whole thing copied in memory so what we

00:13:18,540 --> 00:13:24,510
want to do now is to deflate on the fly

00:13:20,940 --> 00:13:27,150
so walk through the list and pack it

00:13:24,510 --> 00:13:34,440
without this extra overhead in terms of

00:13:27,150 --> 00:13:38,760
memory well what group by returns it

00:13:34,440 --> 00:13:41,760
returns so here with goodbye returns it

00:13:38,760 --> 00:13:45,630
returns and generator that will keep

00:13:41,760 --> 00:13:48,000
producing tuples of key group where key

00:13:45,630 --> 00:13:50,640
is the scalar and the group is a

00:13:48,000 --> 00:13:53,310
generator itself but then to work out

00:13:50,640 --> 00:14:00,030
the length we have to compute the length

00:13:53,310 --> 00:14:01,830
of it and we create a copy right so what

00:14:00,030 --> 00:14:03,780
I want you to do I want to restate the

00:14:01,830 --> 00:14:06,570
same solution in such a way so it

00:14:03,780 --> 00:14:10,400
doesn't have an extra copy of sub lists

00:14:06,570 --> 00:14:10,400
in yeah

00:14:10,930 --> 00:14:18,820
yeah whichever you prefer I would like

00:14:17,050 --> 00:14:26,790
to write it as an assault but I couldn't

00:14:18,820 --> 00:14:26,790
didn't have time so yeah I guess not

00:14:48,050 --> 00:14:51,050
mmm

00:14:51,480 --> 00:14:59,339
feel free to write version the

00:14:55,449 --> 00:14:59,339
district's if you answered

00:15:18,270 --> 00:15:25,050
so the difference is that I don't want

00:15:20,880 --> 00:15:27,000
to create sub lists I want to have to

00:15:25,050 --> 00:15:30,630
run links encoding where you run through

00:15:27,000 --> 00:15:39,330
the list element by element and encode

00:15:30,630 --> 00:15:44,160
it on the fly yeah if you will hear you

00:15:39,330 --> 00:15:46,380
can try and avoid using goodbye I guess

00:15:44,160 --> 00:15:48,980
what what we aren't sure here is the

00:15:46,380 --> 00:15:52,940
internals of how glue by operates right

00:15:48,980 --> 00:15:55,590
so because does group by actually if you

00:15:52,940 --> 00:15:58,020
try to complete the lengths of the

00:15:55,590 --> 00:16:00,290
generator that is returns as the second

00:15:58,020 --> 00:16:08,790
element of the tuple does it actually

00:16:00,290 --> 00:16:11,150
and inflate it in RAM I suspected as the

00:16:08,790 --> 00:16:11,150
way

00:16:18,200 --> 00:16:26,530
hmm so but were they don't want I don't

00:16:21,020 --> 00:16:26,530
want some listen memory yep

00:16:31,430 --> 00:16:36,170
well you can use the original list right

00:16:33,980 --> 00:16:40,480
the original list is always available so

00:16:36,170 --> 00:16:40,480
you can just walk through it right

00:18:16,600 --> 00:18:24,240
can we do sugar is in wood

00:19:17,270 --> 00:19:21,300
milk

00:19:19,410 --> 00:19:25,400
if you only have some species from there

00:19:21,300 --> 00:19:25,400
does it take I think

00:20:36,190 --> 00:20:38,940
hmm

00:21:42,380 --> 00:21:47,650
it works bro listen writer one

00:22:06,690 --> 00:22:13,649
so does anyone sold this post

00:22:52,080 --> 00:22:54,169
Oh

00:23:09,980 --> 00:23:19,010
so three people for people have done so

00:23:13,669 --> 00:23:22,040
i guess i should one for a bit and then

00:23:19,010 --> 00:23:24,890
I don't think if I show the solution it

00:23:22,040 --> 00:23:26,480
will change much the way you think about

00:23:24,890 --> 00:23:29,600
it because you'll have to write it

00:23:26,480 --> 00:23:32,049
anyway it by yourself so basically is

00:23:29,600 --> 00:23:36,169
this is a solution as well so it's

00:23:32,049 --> 00:23:39,220
that's what I came up with it's a bit

00:23:36,169 --> 00:23:42,440
more complex than the previous solution

00:23:39,220 --> 00:23:46,820
so I defined again a peg function which

00:23:42,440 --> 00:23:50,780
behaves similarly and there is some

00:23:46,820 --> 00:23:53,740
logic that goes as follows so if the

00:23:50,780 --> 00:23:58,510
links length of the list is less than

00:23:53,740 --> 00:23:58,510
two then I just returned the list

00:23:58,540 --> 00:24:06,260
otherwise I create this state variables

00:24:04,040 --> 00:24:09,140
multiplicity and Valley and initialize

00:24:06,260 --> 00:24:15,020
them and the result will be returned

00:24:09,140 --> 00:24:18,559
this M list and then i iterate over the

00:24:15,020 --> 00:24:21,799
constituents well starting from the

00:24:18,559 --> 00:24:24,230
second element 1 words and then if the

00:24:21,799 --> 00:24:26,419
element is the same as a min wise

00:24:24,230 --> 00:24:30,770
daren't i'll simply increment

00:24:26,419 --> 00:24:34,150
multiplicity otherwise i append a pack

00:24:30,770 --> 00:24:37,309
of multiplicity value to the resulting

00:24:34,150 --> 00:24:39,410
list and then there has to be one more

00:24:37,309 --> 00:24:40,940
peg statement if you consider this

00:24:39,410 --> 00:24:46,940
carefully in the Underland i return the

00:24:40,940 --> 00:24:50,900
list so it's it's quite a lot longer

00:24:46,940 --> 00:24:53,900
they would like but so the the

00:24:50,900 --> 00:24:59,150
equivalent solution in haskell again we

00:24:53,900 --> 00:25:01,640
use this we use the previous user

00:24:59,150 --> 00:25:03,260
defined data structure that I've showed

00:25:01,640 --> 00:25:05,120
earlier but it didn't fit on the screen

00:25:03,260 --> 00:25:06,890
this time which is which is not really

00:25:05,120 --> 00:25:09,740
fair to high school because you can

00:25:06,890 --> 00:25:11,870
actually meet the type signatures of

00:25:09,740 --> 00:25:14,660
those functions but I put them here

00:25:11,870 --> 00:25:17,540
anyway you remember the definition for

00:25:14,660 --> 00:25:20,750
the single and multiple and so these are

00:25:17,540 --> 00:25:22,330
just two helper functions so the tech

00:25:20,750 --> 00:25:25,140
function

00:25:22,330 --> 00:25:29,429
using what invention even first argument

00:25:25,140 --> 00:25:33,000
matches one is just returned single X

00:25:29,429 --> 00:25:35,860
otherwise you return multiple NX and

00:25:33,000 --> 00:25:39,010
this function takes care of an empty

00:25:35,860 --> 00:25:42,820
list and also a ton packs with every

00:25:39,010 --> 00:25:45,370
fast n into X and X s and invoke since

00:25:42,820 --> 00:25:47,620
auxiliary work function and walk

00:25:45,370 --> 00:25:50,769
function is a little bit more involved

00:25:47,620 --> 00:25:54,220
so what they do the first argument is a

00:25:50,769 --> 00:25:57,610
multiplicity I named em here so n but it

00:25:54,220 --> 00:25:59,769
was em in the other examples so

00:25:57,610 --> 00:26:01,929
multiplicity than the actual element and

00:25:59,769 --> 00:26:08,350
this is the accumulator that I keep

00:26:01,929 --> 00:26:10,809
passing around so if the x equals sorry

00:26:08,350 --> 00:26:17,110
the first line takes care of an empty

00:26:10,809 --> 00:26:19,210
list so if we've exhausted the list that

00:26:17,110 --> 00:26:24,840
we've passed in we just returned the

00:26:19,210 --> 00:26:27,880
list of the final and packed as wise

00:26:24,840 --> 00:26:30,610
this constructor matches so is this

00:26:27,880 --> 00:26:34,720
pattern matches all the other cases

00:26:30,610 --> 00:26:39,010
where we unpack the list into y and the

00:26:34,720 --> 00:26:41,769
remainder of the list and it's available

00:26:39,010 --> 00:26:45,190
is later and then we test for equality

00:26:41,769 --> 00:26:48,549
if X which is the current element and n

00:26:45,190 --> 00:26:52,029
its current multiplicity if x equals the

00:26:48,549 --> 00:26:54,370
head of the whatever is left to process

00:26:52,029 --> 00:26:59,740
we just increment the multiplicity and

00:26:54,370 --> 00:27:04,899
invoke walk again otherwise we invoke

00:26:59,740 --> 00:27:08,730
walk again prepending to the result of

00:27:04,899 --> 00:27:13,389
walk starting with multiplicity 1 and

00:27:08,730 --> 00:27:15,340
unpacking this into y and y is here we

00:27:13,389 --> 00:27:21,360
prepared this is a prepend the greater

00:27:15,340 --> 00:27:26,100
the what is now a full to pull back NX

00:27:21,360 --> 00:27:26,100
so that's the aspen solution

00:27:29,440 --> 00:27:35,960
penultimate exercise is the sorting a

00:27:33,409 --> 00:27:38,779
list by sub list lengths it was quite

00:27:35,960 --> 00:27:43,970
easy it's just a wine minor so I'll just

00:27:38,779 --> 00:27:50,419
show it so we pass the LAN function as a

00:27:43,970 --> 00:27:53,350
key to sort it and all the assertions

00:27:50,419 --> 00:27:57,980
are satisfied so it's a sorting function

00:27:53,350 --> 00:28:00,169
on the length of the list and what I'd

00:27:57,980 --> 00:28:03,710
like to show now is costco version of

00:28:00,169 --> 00:28:05,299
this it's a very similar wine liner you

00:28:03,710 --> 00:28:07,309
need to import some more stuff because

00:28:05,299 --> 00:28:09,129
it's not in prelude which is what the

00:28:07,309 --> 00:28:12,259
collection of functions available

00:28:09,129 --> 00:28:16,039
straightaway so but we import sold by

00:28:12,259 --> 00:28:18,679
and import from data or comparing

00:28:16,039 --> 00:28:21,559
function and then you essentially

00:28:18,679 --> 00:28:25,789
defined sort as the sort by comparing

00:28:21,559 --> 00:28:30,109
lengths and that's the classical

00:28:25,789 --> 00:28:32,629
solution so a more interesting Python

00:28:30,109 --> 00:28:35,480
task is to sort list bicyclist lengths

00:28:32,629 --> 00:28:38,389
frequency so what this means is you need

00:28:35,480 --> 00:28:42,499
somehow work out what are the most

00:28:38,389 --> 00:28:46,429
frequent lists by length and then use

00:28:42,499 --> 00:28:49,869
this information to sort the sub list so

00:28:46,429 --> 00:28:53,779
you can find it i think in the short

00:28:49,869 --> 00:28:57,049
list by frequency problem that pie in

00:28:53,779 --> 00:28:59,539
the directory and basically this is a

00:28:57,049 --> 00:29:02,570
test that it should satisfy I hope the

00:28:59,539 --> 00:29:07,129
exhaustive this time so what it does

00:29:02,570 --> 00:29:12,679
it's a list of sub lists and it sorts

00:29:07,129 --> 00:29:15,289
that list by the lengths of the wise if

00:29:12,679 --> 00:29:18,019
frequency of the lengths of those sub

00:29:15,289 --> 00:29:23,059
lists so for example take this case

00:29:18,019 --> 00:29:25,539
where the list sub list of blanks one is

00:29:23,059 --> 00:29:30,440
more frequent than sub list of links to

00:29:25,539 --> 00:29:34,029
so it puts them the rarest lists by

00:29:30,440 --> 00:29:34,029
lying stores and then it puts the

00:29:34,360 --> 00:29:46,240
put the more frequent ones so if you can

00:29:41,350 --> 00:29:49,930
leverage this solution by writing egg

00:29:46,240 --> 00:29:54,270
and new key function or perhaps if there

00:29:49,930 --> 00:29:54,270
is an easy way you can try that as well

00:30:39,510 --> 00:30:46,850
today oh I can feel my D is it

00:32:41,130 --> 00:32:47,860
stop iteration but that's only if you're

00:32:45,220 --> 00:32:50,679
defining it as an object you should

00:32:47,860 --> 00:32:52,660
really use the generators and as you

00:32:50,679 --> 00:33:02,620
make a nice little dude for you with a

00:32:52,660 --> 00:33:05,020
lot less boilerplate once once you exit

00:33:02,620 --> 00:33:06,370
from the generator function the

00:33:05,020 --> 00:33:11,100
exception will be automatically raise

00:33:06,370 --> 00:33:16,290
for you yeah so anything yeah when's it

00:33:11,100 --> 00:33:16,290
yeah cool

00:35:17,119 --> 00:35:27,980
for the current exercise so how many

00:35:24,890 --> 00:35:30,980
people solve this one all right so we

00:35:27,980 --> 00:35:33,799
should be moving on so this solution I

00:35:30,980 --> 00:35:39,740
came up with which might not be an

00:35:33,799 --> 00:35:44,509
optimal but basically so what i'm doing

00:35:39,740 --> 00:35:48,099
here i am using a dictionary to store

00:35:44,509 --> 00:35:51,650
all possible lengths and they

00:35:48,099 --> 00:35:59,680
multiplicities and then i define this

00:35:51,650 --> 00:35:59,680
frequency function that will return but

00:36:01,180 --> 00:36:10,160
counter ok so please send me a copy

00:36:05,990 --> 00:36:11,859
video solution I'll renew mine so but

00:36:10,160 --> 00:36:15,019
what it does is essentially here

00:36:11,859 --> 00:36:16,249
provides a gate finca c function l which

00:36:15,019 --> 00:36:22,910
is a function that returns a function

00:36:16,249 --> 00:36:28,029
that will sort the list so an equivalent

00:36:22,910 --> 00:36:30,289
solution in haskell I can really obtain

00:36:28,029 --> 00:36:35,960
but I have gained slightly different one

00:36:30,289 --> 00:36:39,799
so what I'm doing here I am sorting

00:36:35,960 --> 00:36:43,009
lists by comparing get frequency L will

00:36:39,799 --> 00:36:45,109
return the function that will sort so

00:36:43,009 --> 00:36:48,289
it's one-to-one correspondence between

00:36:45,109 --> 00:36:51,589
sort and frequency high school to poison

00:36:48,289 --> 00:36:57,799
so frequency what it will do a lot take

00:36:51,589 --> 00:36:59,989
care it takes sorry i defied couple of

00:36:57,799 --> 00:37:01,249
types so it is easy to read but you

00:36:59,989 --> 00:37:04,819
don't have to you can just put them in

00:37:01,249 --> 00:37:09,109
place but i define lengths and frequency

00:37:04,819 --> 00:37:12,829
as new types and so frequency function

00:37:09,109 --> 00:37:15,739
it takes a nap now which is a data

00:37:12,829 --> 00:37:17,280
structure that is implemented on denise

00:37:15,739 --> 00:37:22,200
is a tree and what

00:37:17,280 --> 00:37:26,670
does it returns so this is the indexing

00:37:22,200 --> 00:37:29,160
operator into a map to map you index

00:37:26,670 --> 00:37:32,040
into map using this key which is the

00:37:29,160 --> 00:37:35,250
length of L and it will provide in the

00:37:32,040 --> 00:37:37,620
end value which is the frequency row and

00:37:35,250 --> 00:37:40,770
that will be the key and which we will

00:37:37,620 --> 00:37:42,870
sort the function get frequency is a

00:37:40,770 --> 00:37:48,200
little bit more involved what it does

00:37:42,870 --> 00:37:51,960
first of all it creates a list of

00:37:48,200 --> 00:37:55,800
lengths of all the sub lists in the list

00:37:51,960 --> 00:37:58,980
and then it uses the sort function which

00:37:55,800 --> 00:38:01,350
I imported from data list and i did a

00:37:58,980 --> 00:38:03,540
qualified in particular is of the screen

00:38:01,350 --> 00:38:09,780
actually but it's a qualified import so

00:38:03,540 --> 00:38:14,760
sort will sort them by in a send in

00:38:09,780 --> 00:38:18,330
order and the map data structure it has

00:38:14,760 --> 00:38:20,910
a order of n in complexity method of

00:38:18,330 --> 00:38:23,580
constructing a map from a list of

00:38:20,910 --> 00:38:25,020
elements that are sending so i can

00:38:23,580 --> 00:38:27,540
construct the histogram the same way

00:38:25,020 --> 00:38:30,600
just the histogram is now using

00:38:27,540 --> 00:38:39,000
represented as a three-person dictionary

00:38:30,600 --> 00:38:41,840
and what I do next I am the actual body

00:38:39,000 --> 00:38:48,030
of this function is I want to return a

00:38:41,840 --> 00:38:51,650
function that will if piped to arguments

00:38:48,030 --> 00:38:54,690
into it will return at comparison so

00:38:51,650 --> 00:38:58,380
what this does it invokes frequency with

00:38:54,690 --> 00:39:02,130
the histogram we did we just built and

00:38:58,380 --> 00:39:06,420
the solar does so there is also this

00:39:02,130 --> 00:39:09,750
parish function which to build a map

00:39:06,420 --> 00:39:13,520
from ascending list map is a data

00:39:09,750 --> 00:39:16,350
structure with hold keys and values so

00:39:13,520 --> 00:39:17,730
this purpose I have created the lambda

00:39:16,350 --> 00:39:21,660
function this is a way to define a

00:39:17,730 --> 00:39:24,000
lambda function in esco this if if you

00:39:21,660 --> 00:39:28,570
stretch it a little backslash loops like

00:39:24,000 --> 00:39:30,190
a part of lambda so then

00:39:28,570 --> 00:39:34,060
it will return a tuple containing the

00:39:30,190 --> 00:39:37,660
length and the multiplicity of the

00:39:34,060 --> 00:39:41,350
element so all in all it's the same but

00:39:37,660 --> 00:39:45,070
there is a little difference which I

00:39:41,350 --> 00:39:48,610
would like to discuss first so twice and

00:39:45,070 --> 00:39:51,850
diction is I hash tables as some of you

00:39:48,610 --> 00:39:54,640
might know and hash tables implemented

00:39:51,850 --> 00:40:00,310
underneath as arrays of key value pairs

00:39:54,640 --> 00:40:02,800
and there is some heuristics of mapping

00:40:00,310 --> 00:40:04,480
key to an array index that is happening

00:40:02,800 --> 00:40:07,210
every time you index into a dictionary

00:40:04,480 --> 00:40:09,700
and which goes like so you computer for

00:40:07,210 --> 00:40:11,490
example if hash if it is new keys are

00:40:09,700 --> 00:40:15,040
strings where is a hash function that

00:40:11,490 --> 00:40:18,940
gets calculated and if you try it

00:40:15,040 --> 00:40:21,310
yourself 32-bit platform you'll get the

00:40:18,940 --> 00:40:23,260
following hash for a and then what

00:40:21,310 --> 00:40:28,060
happens there is some predefined array

00:40:23,260 --> 00:40:31,030
size which get converted into the index

00:40:28,060 --> 00:40:33,190
by using array size and then you use it

00:40:31,030 --> 00:40:38,950
in the X direction you look for the key

00:40:33,190 --> 00:40:41,230
value pair in the array so if the you

00:40:38,950 --> 00:40:43,390
have a collision what happens is this

00:40:41,230 --> 00:40:45,760
extra perturbation mechanism that looks

00:40:43,390 --> 00:40:48,670
for alternatives on the logic of which I

00:40:45,760 --> 00:40:51,100
I don't describe here but it's you can

00:40:48,670 --> 00:40:52,870
look it up and you keep doing the spirit

00:40:51,100 --> 00:40:56,260
herbaceous until you find the slot that

00:40:52,870 --> 00:41:00,280
is free and you populate it and then if

00:40:56,260 --> 00:41:03,850
you there is a bit more your wrist

00:41:00,280 --> 00:41:06,760
aquare if the array gets full and if the

00:41:03,850 --> 00:41:10,360
capacity is now over two-thirds it gets

00:41:06,760 --> 00:41:12,520
resized at that point and when you

00:41:10,360 --> 00:41:14,200
delete elements because of the

00:41:12,520 --> 00:41:16,330
perturbation making is we actually don't

00:41:14,200 --> 00:41:19,060
actually remove them you just mark them

00:41:16,330 --> 00:41:20,830
as dumps so that's the basics of the

00:41:19,060 --> 00:41:25,150
implementation of Python dictionaries

00:41:20,830 --> 00:41:28,980
and what we get as a result is the order

00:41:25,150 --> 00:41:31,690
of constant insertion and look up and

00:41:28,980 --> 00:41:36,630
older event construction so it's a very

00:41:31,690 --> 00:41:36,630
fast data structure where's

00:41:37,110 --> 00:41:44,890
yeah that's this beauty of car stables

00:41:41,730 --> 00:41:47,830
they're very very fast they draw back

00:41:44,890 --> 00:41:53,020
they immutable but yeah well it's a

00:41:47,830 --> 00:41:57,070
constant time now they are super fast so

00:41:53,020 --> 00:41:59,350
I'd like to stress it again the Python

00:41:57,070 --> 00:42:01,810
dictionaries insertion and look up our

00:41:59,350 --> 00:42:03,390
constant constant time operations that's

00:42:01,810 --> 00:42:05,890
why we love dictionary since that's why

00:42:03,390 --> 00:42:12,790
diction is implemented this way not some

00:42:05,890 --> 00:42:15,310
other way yeah but that's the heuristics

00:42:12,790 --> 00:42:18,550
behind the resizing what it does it make

00:42:15,310 --> 00:42:20,590
sure the Lord factor of this hash table

00:42:18,550 --> 00:42:23,470
is low so that even have very many

00:42:20,590 --> 00:42:26,110
collisions so what I'd like to contrast

00:42:23,470 --> 00:42:28,119
now is the this high school solution

00:42:26,110 --> 00:42:29,770
versus pricing solution because we've

00:42:28,119 --> 00:42:33,250
seen we solve the previous problem using

00:42:29,770 --> 00:42:36,930
dictionary in poison and I chose to

00:42:33,250 --> 00:42:42,220
implement it as a tree in Haskell so

00:42:36,930 --> 00:42:46,240
self balancing trees they access in

00:42:42,220 --> 00:42:50,560
insertion is an operation of complexity

00:42:46,240 --> 00:42:53,680
order of log n where n is a number of

00:42:50,560 --> 00:42:57,310
elements in the data structure and

00:42:53,680 --> 00:43:00,940
construction is n log n where in hash

00:42:57,310 --> 00:43:03,040
tables it's amortized other one you can

00:43:00,940 --> 00:43:06,119
have order of n worst-case excess

00:43:03,040 --> 00:43:08,280
insertion but amortized is constant and

00:43:06,119 --> 00:43:12,280
construction is cheaper as well

00:43:08,280 --> 00:43:16,830
asymptotically so what what this

00:43:12,280 --> 00:43:19,810
actually mean that the potentially the

00:43:16,830 --> 00:43:22,750
three data structures they require more

00:43:19,810 --> 00:43:26,260
reads memories and memories are slow so

00:43:22,750 --> 00:43:28,150
you include penalty their trees on the

00:43:26,260 --> 00:43:31,150
other hand they are if you want strong

00:43:28,150 --> 00:43:33,960
guarantees on how much it will take to

00:43:31,150 --> 00:43:37,030
look up in individual key value pair

00:43:33,960 --> 00:43:39,310
then trees are preferred because no

00:43:37,030 --> 00:43:42,600
matter what key value pair you look up

00:43:39,310 --> 00:43:45,880
it will always take log n time where's

00:43:42,600 --> 00:43:48,430
sorry if you insert it always take log n

00:43:45,880 --> 00:43:49,220
time where's in hash tables it can take

00:43:48,430 --> 00:43:52,849
order event

00:43:49,220 --> 00:43:54,530
so you keep putting stuff into your hash

00:43:52,849 --> 00:43:55,880
table and it will be really really fast

00:43:54,530 --> 00:43:59,090
by the occasion you'll just take a

00:43:55,880 --> 00:44:02,090
really long time whereas balance treats

00:43:59,090 --> 00:44:05,210
guarantee this asymptotic complexity but

00:44:02,090 --> 00:44:07,250
it's slower also the additional benefit

00:44:05,210 --> 00:44:10,460
of trees is that if you need this extra

00:44:07,250 --> 00:44:12,770
property that keys are sorted which

00:44:10,460 --> 00:44:14,780
would choose provided by default then

00:44:12,770 --> 00:44:17,300
you're better off using balanced trees

00:44:14,780 --> 00:44:20,240
and obviously trees need more ram

00:44:17,300 --> 00:44:23,060
because you have an array just values

00:44:20,240 --> 00:44:26,150
key value pairs with tree it's usually a

00:44:23,060 --> 00:44:30,020
node that contains the value and also

00:44:26,150 --> 00:44:31,790
you have pointers to branches so um it's

00:44:30,020 --> 00:44:36,580
an interesting difference there so I

00:44:31,790 --> 00:44:40,280
stables versus trees trees have another

00:44:36,580 --> 00:44:44,000
advantage that they can be recast in

00:44:40,280 --> 00:44:47,570
purely functional form so you can write

00:44:44,000 --> 00:44:52,130
cheese persistent data structures and

00:44:47,570 --> 00:44:55,339
that's why haskell community uses them a

00:44:52,130 --> 00:44:58,220
lot so trees also require total order

00:44:55,339 --> 00:45:00,619
relationship because if if you if all

00:44:58,220 --> 00:45:02,390
you have is a density operation so you

00:45:00,619 --> 00:45:07,580
can compare the honest for equality but

00:45:02,390 --> 00:45:09,200
not sort them then choose a nugget also

00:45:07,580 --> 00:45:13,130
you need to consider a good hashing

00:45:09,200 --> 00:45:15,890
function a fast one and it usually helps

00:45:13,130 --> 00:45:17,650
if you know a priori what is going to be

00:45:15,890 --> 00:45:22,690
the number of elements if you don't know

00:45:17,650 --> 00:45:25,190
then Stables probably better and

00:45:22,690 --> 00:45:27,050
complexity hash function emulation

00:45:25,190 --> 00:45:30,619
versus comparison operations some hash

00:45:27,050 --> 00:45:33,410
functions are really hard to believe we

00:45:30,619 --> 00:45:36,200
we have string hash functions and

00:45:33,410 --> 00:45:40,250
integer as functions that I quite fast

00:45:36,200 --> 00:45:43,820
so let's say a quote from the book real

00:45:40,250 --> 00:45:46,160
war Haskell is in map section which I'd

00:45:43,820 --> 00:45:50,510
like to I couldn't summarize it there

00:45:46,160 --> 00:45:53,630
myself or as we stated shorter so um

00:45:50,510 --> 00:45:56,290
I'll just read that so um internally map

00:45:53,630 --> 00:45:58,460
is implemented by nate balanced tree and

00:45:56,290 --> 00:46:00,080
compare it to hash table this is much

00:45:58,460 --> 00:46:01,890
more efficient representation in a

00:46:00,080 --> 00:46:05,430
language we see mutable they

00:46:01,890 --> 00:46:07,890
so if you meet that context immutable

00:46:05,430 --> 00:46:10,740
data then it's not but with mutable data

00:46:07,890 --> 00:46:12,780
is the most efficient one and this is

00:46:10,740 --> 00:46:14,430
the most visible example of how deeply

00:46:12,780 --> 00:46:16,140
pure functional programming affects how

00:46:14,430 --> 00:46:17,760
we write code we choose data structures

00:46:16,140 --> 00:46:20,160
and algorithms that we can express

00:46:17,760 --> 00:46:22,230
cleanly and that perform efficiently but

00:46:20,160 --> 00:46:23,850
our choices for specific tasks are often

00:46:22,230 --> 00:46:29,460
different from their counterparts in

00:46:23,850 --> 00:46:36,870
imperative languages so and there was

00:46:29,460 --> 00:46:39,570
this big war online about hash tables

00:46:36,870 --> 00:46:43,830
and costco so i decided to venture and

00:46:39,570 --> 00:46:46,980
investigated myself to see for myself

00:46:43,830 --> 00:46:49,970
what what's true what isn't so hash

00:46:46,980 --> 00:46:52,950
tables are mutable data structure and

00:46:49,970 --> 00:46:56,130
therefore kneadable data structures is

00:46:52,950 --> 00:46:58,500
not what Haskell specializes in and a

00:46:56,130 --> 00:47:00,090
priori see light performance should not

00:46:58,500 --> 00:47:03,780
be expected if you donate a hash table

00:47:00,090 --> 00:47:07,290
in esco even for very heavily optimized

00:47:03,780 --> 00:47:09,570
code and vs. still since high schoolers

00:47:07,290 --> 00:47:12,870
do not choose to use their stables they

00:47:09,570 --> 00:47:14,970
that part of the code based don't get a

00:47:12,870 --> 00:47:17,730
lot of attention in optimizations so

00:47:14,970 --> 00:47:19,590
even though they can be faster the

00:47:17,730 --> 00:47:21,540
current performance of them might be

00:47:19,590 --> 00:47:25,620
slower than what could theoretically be

00:47:21,540 --> 00:47:30,660
achieved and the this is the benchmark

00:47:25,620 --> 00:47:33,990
that I done Stewart and Norman Ramsey so

00:47:30,660 --> 00:47:36,390
what they did they they put up a tiny

00:47:33,990 --> 00:47:39,360
benchmark where you push on a costco

00:47:36,390 --> 00:47:41,310
hash table air ten millions of int in

00:47:39,360 --> 00:47:45,990
pairs and you perform one look up and

00:47:41,310 --> 00:47:49,350
time this so i am this all the code is

00:47:45,990 --> 00:47:54,600
available online but i just show it here

00:47:49,350 --> 00:48:00,390
so we importer the this code is a

00:47:54,600 --> 00:48:02,160
equivalent of the preferred way if you

00:48:00,390 --> 00:48:04,200
want to hash table like data structure

00:48:02,160 --> 00:48:07,380
in haskell what he would use you would

00:48:04,200 --> 00:48:10,830
use a integer map which is a fast map

00:48:07,380 --> 00:48:15,710
for integer keys and then what you will

00:48:10,830 --> 00:48:18,570
do you define a

00:48:15,710 --> 00:48:22,080
map and then you will perform a look up

00:48:18,570 --> 00:48:24,930
this is 100 ski that you want to look up

00:48:22,080 --> 00:48:26,550
and you print it to the screen so so

00:48:24,930 --> 00:48:28,860
this this is expensive bit where you

00:48:26,550 --> 00:48:33,930
construct it and then you'll perform one

00:48:28,860 --> 00:48:37,470
look up so that's benchmark using three

00:48:33,930 --> 00:48:39,240
data structure and the alternative HH

00:48:37,470 --> 00:48:42,830
table based solution in high school is

00:48:39,240 --> 00:48:46,530
as follows you use data hash table and I

00:48:42,830 --> 00:48:48,270
did a qualified in Perth as age so here

00:48:46,530 --> 00:48:51,060
is available list that particular

00:48:48,270 --> 00:48:55,290
namespaces age and I only chose to use

00:48:51,060 --> 00:48:57,990
these tell us so i'm just showing this

00:48:55,290 --> 00:48:59,340
so that you can refer to it later but it

00:48:57,990 --> 00:49:03,300
does essentially the same thing this is

00:48:59,340 --> 00:49:06,150
a container in which you insert a key

00:49:03,300 --> 00:49:08,340
and the value is the equals to the key

00:49:06,150 --> 00:49:11,580
and then you perform one look up I've

00:49:08,340 --> 00:49:18,450
index 100 so I benchmark through this

00:49:11,580 --> 00:49:21,600
and for I think 10 to the power of 8 10

00:49:18,450 --> 00:49:25,320
year 10 million pairs that's the result

00:49:21,600 --> 00:49:28,910
a gap on my laptop so the performance is

00:49:25,320 --> 00:49:31,260
really comparable I suspect the

00:49:28,910 --> 00:49:34,890
optimized version of hash tables to use

00:49:31,260 --> 00:49:36,330
less ram but since it's not the way it's

00:49:34,890 --> 00:49:38,550
implemented it has to use garbage

00:49:36,330 --> 00:49:42,540
collection and there was a bug in

00:49:38,550 --> 00:49:44,070
garbage collector so it was spending

00:49:42,540 --> 00:49:46,470
ninety-five percent of 18 garbage

00:49:44,070 --> 00:49:49,080
collecting but it was fixed and it's the

00:49:46,470 --> 00:49:51,600
performance we have now into my first

00:49:49,080 --> 00:49:53,130
sketch table so you what if you're in

00:49:51,600 --> 00:49:55,020
high school and you're much better off

00:49:53,130 --> 00:49:57,660
using maps then hash tables the

00:49:55,020 --> 00:50:00,270
performance is very comparable but with

00:49:57,660 --> 00:50:02,700
maps you get persistence by default and

00:50:00,270 --> 00:50:05,610
you get heavily optimized code because

00:50:02,700 --> 00:50:08,430
everybody used users maps in Haskell

00:50:05,610 --> 00:50:11,820
soap ISIL solution of this would be

00:50:08,430 --> 00:50:17,490
really one liner I just formatted it so

00:50:11,820 --> 00:50:19,920
the dictionary where we put a bunch of

00:50:17,490 --> 00:50:25,320
key value pairs and then we perform one

00:50:19,920 --> 00:50:28,960
wake up so I timed it and dictionary GC

00:50:25,320 --> 00:50:31,690
versus C poison it's

00:50:28,960 --> 00:50:33,880
most twice as fast and see Tyson to

00:50:31,690 --> 00:50:36,609
doing this task so which is to be

00:50:33,880 --> 00:50:39,250
expected they think because what we're

00:50:36,609 --> 00:50:40,869
doing I mean we have some interpreter we

00:50:39,250 --> 00:50:43,000
had accessing this data structure but

00:50:40,869 --> 00:50:45,010
underneath is really a see data

00:50:43,000 --> 00:50:48,490
structure that's invoked from tyson

00:50:45,010 --> 00:50:52,180
wears a skills hash tables are

00:50:48,490 --> 00:50:54,250
implemented in haskell and if you want

00:50:52,180 --> 00:50:56,200
to resort to the support where you call

00:50:54,250 --> 00:51:02,020
a c-like array from high school you can

00:50:56,200 --> 00:51:04,330
do and don't has written data judy which

00:51:02,020 --> 00:51:07,180
is a very fast mutable associative data

00:51:04,330 --> 00:51:10,480
types based in Judea race if you want

00:51:07,180 --> 00:51:12,790
you can look em up on Wikipedia so it's

00:51:10,480 --> 00:51:15,609
a good imperative need to be replacement

00:51:12,790 --> 00:51:20,640
for internet and in fact if you do that

00:51:15,609 --> 00:51:25,690
so I I just again copied the norms code

00:51:20,640 --> 00:51:28,390
where you import duty array as J and

00:51:25,690 --> 00:51:31,030
then you use it in the same panic button

00:51:28,390 --> 00:51:34,000
to form one look up and and so that's

00:51:31,030 --> 00:51:37,390
the performance you get so it's

00:51:34,000 --> 00:51:41,440
basically essentially the same but you

00:51:37,390 --> 00:51:44,230
get over a lot of Hoops in esco using

00:51:41,440 --> 00:51:46,180
mutable data structure and obviously if

00:51:44,230 --> 00:51:48,970
if it's a stateful data structure what

00:51:46,180 --> 00:51:51,040
osco keeps this membrane between pure

00:51:48,970 --> 00:51:52,810
and impure code is obviously if all the

00:51:51,040 --> 00:51:54,369
code fewer you'll never have any side

00:51:52,810 --> 00:51:57,490
effects he program prints nothing and

00:51:54,369 --> 00:51:59,380
doesn't interact with you so what they

00:51:57,490 --> 00:52:01,390
did they created this membrane that

00:51:59,380 --> 00:52:04,089
keeps the pure code from in pure and

00:52:01,390 --> 00:52:06,540
impure does all the interaction with

00:52:04,089 --> 00:52:10,030
outside world for stable data structures

00:52:06,540 --> 00:52:12,820
so if you choose to use something like

00:52:10,030 --> 00:52:14,830
Judy race or hash tables you will have

00:52:12,820 --> 00:52:18,940
to label explicitly all your type

00:52:14,830 --> 00:52:23,500
signatures in hostile with IO and many

00:52:18,940 --> 00:52:26,530
people prefer immutable so they don't

00:52:23,500 --> 00:52:29,200
have to do that so and I just pull down

00:52:26,530 --> 00:52:31,839
from somewhere unfortunately heavy

00:52:29,200 --> 00:52:35,940
credit but this is a c++ solution which

00:52:31,839 --> 00:52:38,320
have timed and this is JC vs C++

00:52:35,940 --> 00:52:39,170
admittedly C++ can probably the

00:52:38,320 --> 00:52:42,650
optimized

00:52:39,170 --> 00:52:44,599
but that's the first time so it's you're

00:52:42,650 --> 00:52:48,799
not gaining very much by going to C++

00:52:44,599 --> 00:53:01,040
here so at the end thank you very much

00:52:48,799 --> 00:53:03,710
if you have any questions please the

00:53:01,040 --> 00:53:05,839
o'reilly pictorial representation of

00:53:03,710 --> 00:53:09,950
poisonous place in the Haskell is the

00:53:05,839 --> 00:53:14,450
here clear Hercule and beetle so I think

00:53:09,950 --> 00:53:16,880
someone it's not actually my artwork I

00:53:14,450 --> 00:53:19,130
just replaced the chemo we should

00:53:16,880 --> 00:53:24,730
represent parole who starts close to end

00:53:19,130 --> 00:53:24,730
this but as many questions

00:53:32,220 --> 00:53:35,220
yep

00:53:51,700 --> 00:53:57,040
I use this as a rough guide I'm going to

00:53:55,540 --> 00:54:00,280
take two really good really good numbers

00:53:57,040 --> 00:54:02,890
we need to average a lot and probably

00:54:00,280 --> 00:54:06,520
instrumental khodam these are very rough

00:54:02,890 --> 00:54:08,760
diamonds so it depends on the floor of

00:54:06,520 --> 00:54:11,050
the machine at the time and but

00:54:08,760 --> 00:54:18,849
basically what should move in these two

00:54:11,050 --> 00:54:21,480
numbers here anymore all right okay

00:54:18,849 --> 00:54:21,480

YouTube URL: https://www.youtube.com/watch?v=J992TknDAT8


