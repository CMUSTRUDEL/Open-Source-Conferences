Title: Supercharging C++ Code with Embedded Python
Publication date: 2015-04-19
Playlist: EuroPython 2012
Description: 
	[EuroPython 2012] Michael Fotsch -  6 JULY 2012 in "Track Big Mac"
Captions: 
	00:00:05,609 --> 00:00:15,570
it didn't yesterday so that's why you

00:00:08,490 --> 00:00:17,669
get a second chance right okay thanks

00:00:15,570 --> 00:00:20,640
for coming as I said I I gave the same

00:00:17,669 --> 00:00:24,449
talk yesterday so I hope it will be much

00:00:20,640 --> 00:00:27,029
better or even better today so this is

00:00:24,449 --> 00:00:30,359
probably your last chance this year to

00:00:27,029 --> 00:00:32,940
hear this talk so my name is Michael

00:00:30,359 --> 00:00:34,890
fudge I work as a software architect for

00:00:32,940 --> 00:00:37,879
spill Oh international in the

00:00:34,890 --> 00:00:40,650
mathematics department there speedo

00:00:37,879 --> 00:00:44,129
manufacturers casino gaming machines and

00:00:40,650 --> 00:00:46,500
casinos systems we design and develop

00:00:44,129 --> 00:00:49,580
the physical machines as well as the

00:00:46,500 --> 00:00:53,070
game content to be used on third-party

00:00:49,580 --> 00:00:56,820
gaming machines and in my department in

00:00:53,070 --> 00:00:58,920
mathematics we are among other projects

00:00:56,820 --> 00:01:01,739
were responsible for the mathematical

00:00:58,920 --> 00:01:04,140
game engine that's what's being used by

00:01:01,739 --> 00:01:07,010
the mathematicians and game designers to

00:01:04,140 --> 00:01:10,859
define the rules of the game basically

00:01:07,010 --> 00:01:13,950
everything that has to do with games

00:01:10,859 --> 00:01:16,350
being paid for and the chances of

00:01:13,950 --> 00:01:21,780
winning and payouts and things like that

00:01:16,350 --> 00:01:24,450
and well we integrated Python

00:01:21,780 --> 00:01:27,450
interpreter into that to give the users

00:01:24,450 --> 00:01:29,579
of the engine flexibility to be able to

00:01:27,450 --> 00:01:32,789
extend the functionality of the engine

00:01:29,579 --> 00:01:35,100
with their own embedded Python plugins

00:01:32,789 --> 00:01:38,569
or Python scripts so that's what I'm

00:01:35,100 --> 00:01:41,039
what I'm going to talk about today I

00:01:38,569 --> 00:01:43,409
would first go through a number of use

00:01:41,039 --> 00:01:45,689
cases so just to explain what I mean by

00:01:43,409 --> 00:01:49,109
embedding a Python interpreter and why

00:01:45,689 --> 00:01:51,270
it might be useful and then I'll show

00:01:49,109 --> 00:01:53,850
you the technical details it turns out

00:01:51,270 --> 00:01:56,069
that embedding and extending Python have

00:01:53,850 --> 00:01:59,880
a lot in common in both cases you're

00:01:56,069 --> 00:02:02,039
using the Python C API so I will first

00:01:59,880 --> 00:02:03,659
go through a quick recap of writing

00:02:02,039 --> 00:02:05,850
extension modules I don't know how many

00:02:03,659 --> 00:02:09,799
of you had experience with writing

00:02:05,850 --> 00:02:09,799
extension modules if you have

00:02:09,800 --> 00:02:14,120
right yeah that's that's even more than

00:02:12,740 --> 00:02:16,960
yesterday I would assume even though the

00:02:14,120 --> 00:02:19,040
audience was a bit bigger yesterday so

00:02:16,960 --> 00:02:20,540
we'll start off with a recap of

00:02:19,040 --> 00:02:23,150
extending and then I'll show you the

00:02:20,540 --> 00:02:24,830
technical details of embedding the

00:02:23,150 --> 00:02:26,390
interpreter and then I'm going to talk a

00:02:24,830 --> 00:02:29,090
bit about the thought process behind

00:02:26,390 --> 00:02:31,940
putting Python into our game engine the

00:02:29,090 --> 00:02:35,750
specific challenges that we faced and

00:02:31,940 --> 00:02:39,320
how we solve them right in a nutshell

00:02:35,750 --> 00:02:41,300
this is what embedding a Python

00:02:39,320 --> 00:02:43,880
interpreter looks like you take the

00:02:41,300 --> 00:02:47,360
Python interpreter see python in our

00:02:43,880 --> 00:02:50,000
case and put it inside your existing c++

00:02:47,360 --> 00:02:53,060
program just like you would use any

00:02:50,000 --> 00:02:56,270
other utility library like you would use

00:02:53,060 --> 00:02:59,630
XPath for doing xml parsing you put in

00:02:56,270 --> 00:03:02,630
the c python interpreter to run Python

00:02:59,630 --> 00:03:07,360
code for you so that's the simple

00:03:02,630 --> 00:03:10,040
concept one of the prime examples of

00:03:07,360 --> 00:03:13,190
doing this kind of thing is what I call

00:03:10,040 --> 00:03:15,500
the word macro use case so you're

00:03:13,190 --> 00:03:18,680
probably aware in Microsoft Office there

00:03:15,500 --> 00:03:21,170
is this embedded Visual Basic language

00:03:18,680 --> 00:03:24,739
that allows users to write so-called

00:03:21,170 --> 00:03:27,680
macros which is pretty useful you can do

00:03:24,739 --> 00:03:29,180
things like read the data from a table

00:03:27,680 --> 00:03:32,260
in a Word document

00:03:29,180 --> 00:03:35,590
put it inside an Excel spreadsheet

00:03:32,260 --> 00:03:38,720
transform the data and create a chart

00:03:35,590 --> 00:03:41,570
right so very special kinds of

00:03:38,720 --> 00:03:44,780
functionality that you wouldn't want to

00:03:41,570 --> 00:03:47,780
hard code in your C++ program so here's

00:03:44,780 --> 00:03:50,630
an example like what might a Python

00:03:47,780 --> 00:03:54,380
macro look like that would color each

00:03:50,630 --> 00:03:55,209
word in a document in it in a different

00:03:54,380 --> 00:03:58,130
color

00:03:55,209 --> 00:04:02,209
right this is exactly the kind of

00:03:58,130 --> 00:04:05,780
functionality that you would never write

00:04:02,209 --> 00:04:07,550
a feature for in C++ but if your users

00:04:05,780 --> 00:04:11,300
have the opportunity to write a plug-in

00:04:07,550 --> 00:04:14,810
or a macro to do this then it it helps

00:04:11,300 --> 00:04:18,859
them and it helps you as the developer

00:04:14,810 --> 00:04:20,810
of the C++ program as well so that's one

00:04:18,859 --> 00:04:23,330
of the examples another thing that's

00:04:20,810 --> 00:04:26,090
actually pretty similar

00:04:23,330 --> 00:04:27,220
is using embedded Python for testing

00:04:26,090 --> 00:04:30,770
purposes

00:04:27,220 --> 00:04:34,009
the only difference maybe is that you

00:04:30,770 --> 00:04:35,569
might want to expose lower level classes

00:04:34,009 --> 00:04:39,139
of your application you might want to

00:04:35,569 --> 00:04:41,419
give the plugins access to the low level

00:04:39,139 --> 00:04:43,909
details and they will exercise some

00:04:41,419 --> 00:04:46,240
functionality and assert on the outcome

00:04:43,909 --> 00:04:55,330
things like that

00:04:46,240 --> 00:04:57,650
yeah so it's a possibility right and

00:04:55,330 --> 00:05:00,889
game engines have been using built-in

00:04:57,650 --> 00:05:04,030
scripting languages for ages some have

00:05:00,889 --> 00:05:07,629
even used Python like I think

00:05:04,030 --> 00:05:10,340
civilization for used Python to

00:05:07,629 --> 00:05:12,020
manipulate the map generation in some

00:05:10,340 --> 00:05:14,750
way and maybe they are even using it for

00:05:12,020 --> 00:05:17,840
enemy AI and these things and that's

00:05:14,750 --> 00:05:20,770
pretty nice because your level designers

00:05:17,840 --> 00:05:24,080
that you have on the project or the game

00:05:20,770 --> 00:05:27,169
designers they are not necessarily

00:05:24,080 --> 00:05:30,080
software developers right let alone C++

00:05:27,169 --> 00:05:32,240
developers so you can provide them with

00:05:30,080 --> 00:05:36,039
an engine where all the low-level

00:05:32,240 --> 00:05:39,500
details like I don't know AI algorithms

00:05:36,039 --> 00:05:41,690
pathfinding and and 3d rendering all of

00:05:39,500 --> 00:05:44,659
that is coded in C++

00:05:41,690 --> 00:05:48,860
but by using an extension language you

00:05:44,659 --> 00:05:52,009
can allow level designers to define the

00:05:48,860 --> 00:05:54,710
enemy AI for example and that's the use

00:05:52,009 --> 00:05:56,029
case at speed oh we're not doing

00:05:54,710 --> 00:05:58,639
first-person shooters like in this

00:05:56,029 --> 00:06:00,979
example here but it's also a game engine

00:05:58,639 --> 00:06:04,009
with its building blocks coded in C++

00:06:00,979 --> 00:06:06,469
and the game developers will or the the

00:06:04,009 --> 00:06:09,589
mathematicians in our case will use the

00:06:06,469 --> 00:06:11,839
extension language well why would you

00:06:09,589 --> 00:06:14,919
use Python for that you could just as

00:06:11,839 --> 00:06:21,020
well prepare a C++ plug-in architecture

00:06:14,919 --> 00:06:23,000
where your plugins or C++ dll's probably

00:06:21,020 --> 00:06:26,229
the most important reason why you

00:06:23,000 --> 00:06:28,879
wouldn't want to do this is the users

00:06:26,229 --> 00:06:33,349
might not feel comfortable or might not

00:06:28,879 --> 00:06:35,740
want to write C++ code just to colorize

00:06:33,349 --> 00:06:38,440
each word differently

00:06:35,740 --> 00:06:40,690
but some of your users I'm not saying

00:06:38,440 --> 00:06:42,759
all of them but some of your users will

00:06:40,690 --> 00:06:45,819
be willing to learn a little bit of

00:06:42,759 --> 00:06:49,720
Python or any other simple language to

00:06:45,819 --> 00:06:53,440
get their job done and that's very much

00:06:49,720 --> 00:06:56,199
feasible so some users will want to do

00:06:53,440 --> 00:06:59,199
this other users might not but still

00:06:56,199 --> 00:07:02,710
they can reuse the scripts and plugins

00:06:59,199 --> 00:07:07,210
that would say power users will create

00:07:02,710 --> 00:07:09,880
for them and also sandboxing might be an

00:07:07,210 --> 00:07:12,520
issue I personally wouldn't feel

00:07:09,880 --> 00:07:14,650
comfortable downloading a C++ DLL again

00:07:12,520 --> 00:07:16,900
to colorize the words in a document when

00:07:14,650 --> 00:07:20,370
I know that the C++ code can do pretty

00:07:16,900 --> 00:07:25,000
much anything on my machine with with my

00:07:20,370 --> 00:07:27,659
permissions the embedded Python

00:07:25,000 --> 00:07:30,639
interpreter can be changed so that it

00:07:27,659 --> 00:07:33,310
restricts the execution environment in

00:07:30,639 --> 00:07:35,800
various ways which on the one hand makes

00:07:33,310 --> 00:07:37,990
it easier for the users it's not so easy

00:07:35,800 --> 00:07:41,340
to break things or to crash the entire

00:07:37,990 --> 00:07:44,349
application and on the other hand it

00:07:41,340 --> 00:07:46,710
prevents lots of security issues that

00:07:44,349 --> 00:07:46,710
you might have

00:07:48,410 --> 00:07:55,130
good so let's look at the technical

00:07:51,560 --> 00:07:58,730
details first of writing extension

00:07:55,130 --> 00:08:00,350
modules that's the simple example of

00:07:58,730 --> 00:08:06,080
that you have in the lower right corner

00:08:00,350 --> 00:08:09,380
your complex c function and you want to

00:08:06,080 --> 00:08:12,500
be able to import your C++ code like any

00:08:09,380 --> 00:08:15,620
old Python module and invoke its

00:08:12,500 --> 00:08:20,510
functions or instantiate its classes use

00:08:15,620 --> 00:08:23,030
the global variables whatever and of

00:08:20,510 --> 00:08:25,160
course we were using this everyday many

00:08:23,030 --> 00:08:27,980
modules in the standard library like the

00:08:25,160 --> 00:08:32,060
regular expression module goes down to

00:08:27,980 --> 00:08:34,599
an extension module pretty quickly many

00:08:32,060 --> 00:08:36,110
language bindings of GUI libraries

00:08:34,599 --> 00:08:42,200
things like that

00:08:36,110 --> 00:08:45,350
our extension modules now a C++ compiler

00:08:42,200 --> 00:08:47,660
generates CPU instructions but Python

00:08:45,350 --> 00:08:49,700
only knows how to execute Python byte

00:08:47,660 --> 00:08:53,540
codes so these are seemingly

00:08:49,700 --> 00:08:56,810
incompatible worlds the data types were

00:08:53,540 --> 00:08:59,540
also quite different an integer in C is

00:08:56,810 --> 00:09:01,940
most more often than not just a 32-bit

00:08:59,540 --> 00:09:04,310
number but in Python we have a ref count

00:09:01,940 --> 00:09:06,980
we have a link to a type class and all

00:09:04,310 --> 00:09:09,410
these different things so also seemingly

00:09:06,980 --> 00:09:13,570
incompatible worlds the good thing

00:09:09,410 --> 00:09:16,310
though Python itself is just a C program

00:09:13,570 --> 00:09:24,290
right so it very well knows how to

00:09:16,310 --> 00:09:26,210
execute C code in fact large parts of

00:09:24,290 --> 00:09:29,600
the standard library or of the building

00:09:26,210 --> 00:09:31,970
modules are of course already

00:09:29,600 --> 00:09:34,070
implemented in C here is an example this

00:09:31,970 --> 00:09:36,980
is the radience function from the math

00:09:34,070 --> 00:09:39,830
module which converts an angle in

00:09:36,980 --> 00:09:42,860
degrees to an angle in radians and as

00:09:39,830 --> 00:09:45,590
you can see this this C function that it

00:09:42,860 --> 00:09:48,890
goes down to takes pie objects as its

00:09:45,590 --> 00:09:53,150
arguments and returns a PI object as its

00:09:48,890 --> 00:09:54,860
result and this is the actual code I

00:09:53,150 --> 00:09:56,800
think I stripped some error check in

00:09:54,860 --> 00:09:59,739
here

00:09:56,800 --> 00:10:01,019
the Python capi so the the internal

00:09:59,739 --> 00:10:04,179
functions of the Python interpreter

00:10:01,019 --> 00:10:08,619
provide all the necessary utility

00:10:04,179 --> 00:10:12,519
functions for converting to and from PI

00:10:08,619 --> 00:10:14,410
objects like PI float as double even if

00:10:12,519 --> 00:10:17,589
you have never seen this function you

00:10:14,410 --> 00:10:21,429
will recognize ok this takes a PI object

00:10:17,589 --> 00:10:23,049
and converts it to a double as long as

00:10:21,429 --> 00:10:24,970
the PI object really is a double if it

00:10:23,049 --> 00:10:27,730
is a string or something and there would

00:10:24,970 --> 00:10:29,529
be an error right and it performs the

00:10:27,730 --> 00:10:33,989
calculation and converts the result back

00:10:29,529 --> 00:10:37,329
to a PI object now let's go back to our

00:10:33,989 --> 00:10:38,889
simple function here it takes two

00:10:37,329 --> 00:10:42,040
integer arguments and returns and

00:10:38,889 --> 00:10:44,319
integers the result how would it have to

00:10:42,040 --> 00:10:46,470
look like in order for the Python

00:10:44,319 --> 00:10:49,869
interpreter to be able to call into it

00:10:46,470 --> 00:10:53,049
again we have to change the arguments to

00:10:49,869 --> 00:10:55,749
be PI objects so in this case as this is

00:10:53,049 --> 00:11:00,369
a topic our it's just a function we can

00:10:55,749 --> 00:11:02,170
pretty much ignore itself here it's it's

00:11:00,369 --> 00:11:04,509
not a method it's it's a function I

00:11:02,170 --> 00:11:06,549
think in practice the self will be a

00:11:04,509 --> 00:11:09,549
pointer to the module where the function

00:11:06,549 --> 00:11:11,439
resides but we won't need that so the

00:11:09,549 --> 00:11:14,980
arguments both arguments are in this PI

00:11:11,439 --> 00:11:19,569
object and the return value will be a PI

00:11:14,980 --> 00:11:22,089
object okay so first step find the

00:11:19,569 --> 00:11:26,350
Python capi function that will extract

00:11:22,089 --> 00:11:29,589
the values from a tool pi arg unpacked

00:11:26,350 --> 00:11:32,170
tuple will do that will extract the two

00:11:29,589 --> 00:11:35,139
PI objects from the tuple and assign

00:11:32,170 --> 00:11:37,619
them to new to PI object variables

00:11:35,139 --> 00:11:41,350
that's the first step

00:11:37,619 --> 00:11:45,610
then we convert the PI objects in these

00:11:41,350 --> 00:11:48,220
these two PI objects to integers again

00:11:45,610 --> 00:11:50,559
assuming they are actually integers I

00:11:48,220 --> 00:11:52,899
I'm not showing any error checking here

00:11:50,559 --> 00:11:57,939
this would be would make the code a bit

00:11:52,899 --> 00:12:01,529
longer then we can call the original C++

00:11:57,939 --> 00:12:04,629
implementation have it perform its

00:12:01,529 --> 00:12:08,480
computation and then the result is

00:12:04,629 --> 00:12:10,940
converted back to a Python integer

00:12:08,480 --> 00:12:14,050
and that's pretty much it now we have

00:12:10,940 --> 00:12:17,360
extended the Python interpreter with

00:12:14,050 --> 00:12:20,210
with some C++ code there is a bit of

00:12:17,360 --> 00:12:24,070
converting before actually doing our

00:12:20,210 --> 00:12:28,220
thing and a bit of converting afterwards

00:12:24,070 --> 00:12:32,270
this code will then be compiled into a

00:12:28,220 --> 00:12:34,700
shared object or DLL there is some

00:12:32,270 --> 00:12:37,310
boilerplate code as well that's not

00:12:34,700 --> 00:12:39,980
really important quite boring you have

00:12:37,310 --> 00:12:41,510
to list all your functions that you want

00:12:39,980 --> 00:12:44,030
to export you have to list all your

00:12:41,510 --> 00:12:45,170
classes you have to initialize something

00:12:44,030 --> 00:12:47,630
that's pretty simple

00:12:45,170 --> 00:12:50,000
boilerplate stuff you compile it all

00:12:47,630 --> 00:12:54,350
into a shared object and there we go

00:12:50,000 --> 00:12:57,200
that's that's the extension module so to

00:12:54,350 --> 00:12:59,750
reiterate once more take PI objects

00:12:57,200 --> 00:13:02,630
return PI objects use the Python C API

00:12:59,750 --> 00:13:09,380
to convert and there you go that's

00:13:02,630 --> 00:13:11,360
that's an extension module there are

00:13:09,380 --> 00:13:14,120
some tools and libraries that will help

00:13:11,360 --> 00:13:15,230
you write this boring wrapper code that

00:13:14,120 --> 00:13:17,930
I showed you

00:13:15,230 --> 00:13:20,300
swig the simplified wrapper interface

00:13:17,930 --> 00:13:23,330
generator is a tool that will parse your

00:13:20,300 --> 00:13:25,280
C header files or C++ header files and

00:13:23,330 --> 00:13:28,010
automatically generate the wrapper code

00:13:25,280 --> 00:13:31,700
for you I find the tool pretty good it

00:13:28,010 --> 00:13:33,890
works really well in the simple case of

00:13:31,700 --> 00:13:37,130
course it has its rough edges so it can

00:13:33,890 --> 00:13:39,860
happen that in complex cases especially

00:13:37,130 --> 00:13:42,650
when you want your wrapped code to be

00:13:39,860 --> 00:13:45,560
extra pythonic if you don't want it to

00:13:42,650 --> 00:13:47,390
just be like if you want everything to

00:13:45,560 --> 00:13:49,430
be a real Python dictionary or a

00:13:47,390 --> 00:13:52,250
dictionary of lists of tuples of

00:13:49,430 --> 00:13:54,800
dictionaries or whatever then yeah you

00:13:52,250 --> 00:13:58,370
kind of have to struggle against the the

00:13:54,800 --> 00:14:01,130
tool from time to time but still works

00:13:58,370 --> 00:14:03,350
pretty well and we're using it for let's

00:14:01,130 --> 00:14:05,530
say mission-critical extension modules

00:14:03,350 --> 00:14:08,150
that's below and it works pretty well

00:14:05,530 --> 00:14:08,480
boost Python takes a bit of a different

00:14:08,150 --> 00:14:12,920
approach

00:14:08,480 --> 00:14:15,470
it's a C++ library heavily based on C++

00:14:12,920 --> 00:14:18,110
templates I think there is also a tool

00:14:15,470 --> 00:14:20,970
that will parse header files and then

00:14:18,110 --> 00:14:23,680
generate boost Python code for you

00:14:20,970 --> 00:14:25,930
I'm sure it's a very good very

00:14:23,680 --> 00:14:30,010
well-thought-out library we ended up not

00:14:25,930 --> 00:14:33,250
using it it has quite it puts some

00:14:30,010 --> 00:14:36,010
demands on your compiler so you have to

00:14:33,250 --> 00:14:37,810
have a fairly decent C++ compiler and we

00:14:36,010 --> 00:14:40,480
certainly didn't have that on all our

00:14:37,810 --> 00:14:42,430
embedded platforms so it wasn't really

00:14:40,480 --> 00:14:48,520
an option but that's not to say that

00:14:42,430 --> 00:14:50,710
it's not a good a good choice so the

00:14:48,520 --> 00:14:52,860
next step would be going from writing an

00:14:50,710 --> 00:14:57,970
extension module to actually put in our

00:14:52,860 --> 00:15:00,670
Python interpreter inside the program so

00:14:57,970 --> 00:15:02,800
this was the extension use case where

00:15:00,670 --> 00:15:06,700
the Python executable is kind of your

00:15:02,800 --> 00:15:10,570
main program your main program that runs

00:15:06,700 --> 00:15:14,950
your Python code typically from a dot py

00:15:10,570 --> 00:15:18,040
file and your extension module is

00:15:14,950 --> 00:15:20,020
essentially a plug-in for the Python

00:15:18,040 --> 00:15:22,900
interpreter you extend the functionality

00:15:20,020 --> 00:15:25,030
of the interpreter which still remains

00:15:22,900 --> 00:15:29,260
the main program and it remains in

00:15:25,030 --> 00:15:32,500
charge of everything in the embedding

00:15:29,260 --> 00:15:35,080
use case you have your application as

00:15:32,500 --> 00:15:37,680
the main thing that controls everything

00:15:35,080 --> 00:15:41,170
the Python interpreter is merely a

00:15:37,680 --> 00:15:45,130
utility library inside your application

00:15:41,170 --> 00:15:47,050
your application classes control the

00:15:45,130 --> 00:15:52,480
Python interpreter and use it to perform

00:15:47,050 --> 00:15:54,490
some tasks and conversely the Python

00:15:52,480 --> 00:15:57,490
interpreter can call back into your

00:15:54,490 --> 00:15:58,990
application classes usually of course

00:15:57,490 --> 00:16:03,370
you will have the Python interpreter

00:15:58,990 --> 00:16:05,650
execute Python code in let's say that py

00:16:03,370 --> 00:16:08,950
files are in your whatever you call your

00:16:05,650 --> 00:16:10,540
your plugin files so that the plugins

00:16:08,950 --> 00:16:12,480
have access to the internals of the

00:16:10,540 --> 00:16:15,970
application and the application can use

00:16:12,480 --> 00:16:18,700
would say callbacks in the plugin for

00:16:15,970 --> 00:16:21,180
example so that's where aiming what

00:16:18,700 --> 00:16:21,180
we're aiming for

00:16:22,000 --> 00:16:27,550
the very high-level example kind of gets

00:16:25,360 --> 00:16:29,740
you started so with this you can test

00:16:27,550 --> 00:16:31,449
whether your include paths are correct

00:16:29,740 --> 00:16:34,750
and your linking to the correct version

00:16:31,449 --> 00:16:36,670
of the Python library is just to execute

00:16:34,750 --> 00:16:40,350
the piece of Python source code in a

00:16:36,670 --> 00:16:43,720
string include the Python header

00:16:40,350 --> 00:16:45,970
initialize the interpreter and then for

00:16:43,720 --> 00:16:48,220
example use PI run simple string to

00:16:45,970 --> 00:16:50,500
execute the bunch of Python code

00:16:48,220 --> 00:16:54,399
I would say that's already pretty cool

00:16:50,500 --> 00:16:56,709
although you might as well spawn a

00:16:54,399 --> 00:17:00,970
process on the on the shell for doing

00:16:56,709 --> 00:17:04,470
this right but that's let's say the

00:17:00,970 --> 00:17:07,900
hello world of embedding the interpreter

00:17:04,470 --> 00:17:10,990
now let's try something more interesting

00:17:07,900 --> 00:17:16,780
we have this C++ code here that reads

00:17:10,990 --> 00:17:19,000
lines from standard input calls a Python

00:17:16,780 --> 00:17:21,189
filter that we don't know yet how to

00:17:19,000 --> 00:17:23,380
invoke but it basically will allow the

00:17:21,189 --> 00:17:26,020
user to define a Python function that

00:17:23,380 --> 00:17:28,630
takes the string transforms it returns a

00:17:26,020 --> 00:17:31,510
new string and then we'll back in the

00:17:28,630 --> 00:17:34,000
C++ program will output the result to

00:17:31,510 --> 00:17:36,270
standard out so the interesting function

00:17:34,000 --> 00:17:39,909
here would be called Python filter and

00:17:36,270 --> 00:17:42,600
users can do whatever in their plugins

00:17:39,909 --> 00:17:42,600
obviously

00:17:43,330 --> 00:17:49,119
so that's what the function might look

00:17:45,039 --> 00:17:55,570
like takes an STL string first thing we

00:17:49,119 --> 00:17:57,399
do we import the filter dot py module so

00:17:55,570 --> 00:18:00,190
that's equivalent to the Python code

00:17:57,399 --> 00:18:03,039
import filter it's just that we're using

00:18:00,190 --> 00:18:05,919
the Python C API now PI import

00:18:03,039 --> 00:18:07,720
underscore import is the function that I

00:18:05,919 --> 00:18:09,789
chose there are variety there's a

00:18:07,720 --> 00:18:12,429
variety of functions taking some flags

00:18:09,789 --> 00:18:14,409
or whatever but this is the simplest

00:18:12,429 --> 00:18:17,529
form you just provide the name of the

00:18:14,409 --> 00:18:20,710
module and it will use its normal path

00:18:17,529 --> 00:18:24,879
lookup to locate the module import it

00:18:20,710 --> 00:18:30,070
and you get the module object as a PI

00:18:24,879 --> 00:18:31,690
object from that we can retrieve the

00:18:30,070 --> 00:18:34,600
filter function because that's an

00:18:31,690 --> 00:18:36,489
attribute of the module object so in

00:18:34,600 --> 00:18:39,190
Python code you would just use get

00:18:36,489 --> 00:18:41,200
Patrick and here we're using PI object

00:18:39,190 --> 00:18:43,960
underscore get after a string which

00:18:41,200 --> 00:18:47,739
takes the plug-in object and the name of

00:18:43,960 --> 00:18:49,840
the thing that we're looking for and we

00:18:47,739 --> 00:18:52,919
would treat which we receive the

00:18:49,840 --> 00:18:56,470
callable object as another PI object

00:18:52,919 --> 00:18:58,359
then we prepare the arguments tuple for

00:18:56,470 --> 00:19:02,409
the function which in our case will just

00:18:58,359 --> 00:19:03,999
be a tuple containing a single string so

00:19:02,409 --> 00:19:06,759
this works a bit like printf you have

00:19:03,999 --> 00:19:09,429
these format or these carrot special

00:19:06,759 --> 00:19:15,100
characters that designate with datatypes

00:19:09,429 --> 00:19:17,889
to put inside the tuple now we have the

00:19:15,100 --> 00:19:20,200
tuple as an object then we can use PI

00:19:17,889 --> 00:19:22,450
object underscore call object to

00:19:20,200 --> 00:19:25,960
actually invoke the callable passing the

00:19:22,450 --> 00:19:28,600
arguments which will return a string

00:19:25,960 --> 00:19:33,399
inside a PI object and we convert that

00:19:28,600 --> 00:19:37,029
back to a C string which c++ magic will

00:19:33,399 --> 00:19:41,019
then convert to an STL string so that's

00:19:37,029 --> 00:19:43,119
it very straightforward actually again

00:19:41,019 --> 00:19:46,179
what I'm not showing here is any error

00:19:43,119 --> 00:19:49,869
checking so what if the filter function

00:19:46,179 --> 00:19:52,929
doesn't actually return a string we have

00:19:49,869 --> 00:19:54,190
to react to that and also what I'm

00:19:52,929 --> 00:19:57,130
producing here is a pretty massive

00:19:54,190 --> 00:19:59,200
memory leak because all the objects

00:19:57,130 --> 00:20:01,840
were allocated or never freed their

00:19:59,200 --> 00:20:04,150
reference count remains one so at the

00:20:01,840 --> 00:20:08,350
end you would usually call the decrement

00:20:04,150 --> 00:20:11,320
reference counter macro on the module

00:20:08,350 --> 00:20:12,990
the callable things like that but I'm

00:20:11,320 --> 00:20:25,030
not showing that here because it

00:20:12,990 --> 00:20:25,750
wouldn't fit on the slide no not

00:20:25,030 --> 00:20:28,510
necessarily

00:20:25,750 --> 00:20:30,340
oh yeah so the question was whether you

00:20:28,510 --> 00:20:33,490
have what have to have a CE function

00:20:30,340 --> 00:20:35,560
like this for each Python function at

00:20:33,490 --> 00:20:37,360
what that you want to invoke right yeah

00:20:35,560 --> 00:20:39,310
so in this case it makes sense to have

00:20:37,360 --> 00:20:41,920
everything encapsulated in this single

00:20:39,310 --> 00:20:44,320
function that imports the module then

00:20:41,920 --> 00:20:47,050
retrieves the attribute calls it and

00:20:44,320 --> 00:20:48,760
converts everything in other cases you

00:20:47,050 --> 00:20:51,150
might do it differently right you you're

00:20:48,760 --> 00:20:54,580
just using the Python interpreter as

00:20:51,150 --> 00:20:57,100
your utility library it remains there

00:20:54,580 --> 00:20:59,260
it's it's always there so I could import

00:20:57,100 --> 00:21:02,290
the module in my startup routine once

00:20:59,260 --> 00:21:04,960
and then just keep the pointer to the

00:21:02,290 --> 00:21:08,100
module all the time and then whenever I

00:21:04,960 --> 00:21:11,560
want to invoke a function I would just

00:21:08,100 --> 00:21:15,400
call PI object call object directly from

00:21:11,560 --> 00:21:17,440
wherever I am so this is just you know

00:21:15,400 --> 00:21:19,630
to to have it encapsulated in a single

00:21:17,440 --> 00:21:20,950
place but yeah so it's really that's the

00:21:19,630 --> 00:21:23,950
way it works the Python interpreter is

00:21:20,950 --> 00:21:26,080
always there it has it state it keep it

00:21:23,950 --> 00:21:29,230
it keeps its state and whenever you like

00:21:26,080 --> 00:21:30,550
you everywhere in your C++ code even

00:21:29,230 --> 00:21:34,300
though it's it's a good question I would

00:21:30,550 --> 00:21:38,230
I would say or I at least what I try to

00:21:34,300 --> 00:21:41,050
do is keep my original application code

00:21:38,230 --> 00:21:45,010
and all the Python C API wrapper code

00:21:41,050 --> 00:21:47,920
separate so that I won't insert random

00:21:45,010 --> 00:21:50,320
calls to PI object underscore call

00:21:47,920 --> 00:21:52,360
object in my regular application classes

00:21:50,320 --> 00:21:55,170
so you have your regular application

00:21:52,360 --> 00:21:59,620
classes and then maybe you have some

00:21:55,170 --> 00:22:02,170
some special bridge code whatever where

00:21:59,620 --> 00:22:04,730
you actually do calling into the pipe in

00:22:02,170 --> 00:22:07,160
temporary yeah

00:22:04,730 --> 00:22:08,930
so yeah by the way I'm I think we'll

00:22:07,160 --> 00:22:12,130
have time at the end for four more

00:22:08,930 --> 00:22:14,750
questions if I'm if I make it on time

00:22:12,130 --> 00:22:17,750
yeah and the code that we just saw is

00:22:14,750 --> 00:22:21,950
roughly equivalent to this Python code

00:22:17,750 --> 00:22:25,820
here we import a module called get after

00:22:21,950 --> 00:22:28,550
prepare an arguments tuple and invoke

00:22:25,820 --> 00:22:31,390
the function and that's pretty much the

00:22:28,550 --> 00:22:34,850
task that you have when embedding Python

00:22:31,390 --> 00:22:38,530
think of the things that you want the

00:22:34,850 --> 00:22:41,210
Python interpreter to do we were used to

00:22:38,530 --> 00:22:44,510
thinking about these things in Python

00:22:41,210 --> 00:22:46,400
and then go to the Python C API

00:22:44,510 --> 00:22:50,390
reference manual and look up the

00:22:46,400 --> 00:22:52,880
equivalent Python C API calls to do all

00:22:50,390 --> 00:22:55,160
these interesting things it's really not

00:22:52,880 --> 00:22:59,840
rocket science it's it might be tedious

00:22:55,160 --> 00:23:04,820
and error-prone but it's not something

00:22:59,840 --> 00:23:10,310
you need a degree for in not inviting

00:23:04,820 --> 00:23:13,190
anyways and just like with writing

00:23:10,310 --> 00:23:15,980
extension modules all the time

00:23:13,190 --> 00:23:19,010
converting between PI objects and C++

00:23:15,980 --> 00:23:23,200
objects back and forth and also what you

00:23:19,010 --> 00:23:26,510
can do what I didn't show here in your

00:23:23,200 --> 00:23:28,850
Python plugins you might want to call

00:23:26,510 --> 00:23:31,460
back into the application classes right

00:23:28,850 --> 00:23:34,160
I didn't do here but actually you just

00:23:31,460 --> 00:23:36,620
combined the extension module approach

00:23:34,160 --> 00:23:39,140
with the embedding approach just as we

00:23:36,620 --> 00:23:42,830
did it before with the wrap sum function

00:23:39,140 --> 00:23:47,450
you wrap your internal of C++ functions

00:23:42,830 --> 00:23:50,390
and classes in this kind of extension

00:23:47,450 --> 00:23:53,120
code and register your extension

00:23:50,390 --> 00:23:55,850
functions with the embedded Python

00:23:53,120 --> 00:23:58,010
interpreter and once you do that you can

00:23:55,850 --> 00:24:01,160
just inside the embedded interpreter

00:23:58,010 --> 00:24:10,940
import your application classes works

00:24:01,160 --> 00:24:13,460
works pretty well that way so again

00:24:10,940 --> 00:24:16,640
there are C++ libraries to help you with

00:24:13,460 --> 00:24:19,880
this boost Python again wraps the entire

00:24:16,640 --> 00:24:23,810
Python C API so that you don't have to

00:24:19,880 --> 00:24:25,430
care about reference counting Python

00:24:23,810 --> 00:24:28,430
errors will be converted to C++

00:24:25,430 --> 00:24:30,020
exceptions and all these neat things

00:24:28,430 --> 00:24:32,930
helps a lot

00:24:30,020 --> 00:24:35,420
PI C execs is much simpler in that it

00:24:32,930 --> 00:24:37,910
doesn't use fancy templates it's just I

00:24:35,420 --> 00:24:42,740
think it does use templates but not in

00:24:37,910 --> 00:24:47,060
this boost kind of way it's much simpler

00:24:42,740 --> 00:24:49,550
I've tried both libraries again we ended

00:24:47,060 --> 00:24:52,610
up not using any of those in any

00:24:49,550 --> 00:24:54,530
production code that we have just

00:24:52,610 --> 00:24:57,530
because a library always introduces

00:24:54,530 --> 00:24:59,630
another point of failure right when you

00:24:57,530 --> 00:25:02,830
port to a new platform you suddenly have

00:24:59,630 --> 00:25:05,660
to worry about this library as well and

00:25:02,830 --> 00:25:09,920
Python itself and the Python C API is

00:25:05,660 --> 00:25:16,690
very very portable so it works on pretty

00:25:09,920 --> 00:25:18,750
much any platform so yeah I went for

00:25:16,690 --> 00:25:21,450
writing the wrapper code

00:25:18,750 --> 00:25:22,800
manually but again I would encourage you

00:25:21,450 --> 00:25:26,030
to take a look at the libraries whether

00:25:22,800 --> 00:25:26,030
they suit their needs

00:25:27,410 --> 00:25:33,870
okay so let's talk a bit about our

00:25:30,800 --> 00:25:37,220
experience that's below with with the

00:25:33,870 --> 00:25:41,960
embedded interpreter in the math engine

00:25:37,220 --> 00:25:44,250
so the engine already had built-in

00:25:41,960 --> 00:25:48,720
extension language which was a very

00:25:44,250 --> 00:25:51,360
simple flight code interpreter very

00:25:48,720 --> 00:25:54,480
limited though because it had to run on

00:25:51,360 --> 00:25:57,600
ancient hardware where you didn't have

00:25:54,480 --> 00:25:59,370
much memory so we only had one general

00:25:57,600 --> 00:26:02,280
data register there were no

00:25:59,370 --> 00:26:06,390
floating-point numbers anywhere and it

00:26:02,280 --> 00:26:10,890
was a bit difficult to use so at some

00:26:06,390 --> 00:26:13,670
point we had to write something better

00:26:10,890 --> 00:26:16,050
and the choice was basically between

00:26:13,670 --> 00:26:18,510
writing our own scripting language maybe

00:26:16,050 --> 00:26:22,890
with a parser generator like use flex

00:26:18,510 --> 00:26:25,200
and python to generate some parser for

00:26:22,890 --> 00:26:27,090
your own scripting language well but

00:26:25,200 --> 00:26:30,900
then the question is how do you design a

00:26:27,090 --> 00:26:34,410
good easy to use easy to learn powerful

00:26:30,900 --> 00:26:38,850
language when someone has already done

00:26:34,410 --> 00:26:41,460
the job and white nori does that so the

00:26:38,850 --> 00:26:43,590
choice it was pretty natural for us to

00:26:41,460 --> 00:26:47,250
use Python we have we already had many

00:26:43,590 --> 00:26:50,100
years of experience using Python for our

00:26:47,250 --> 00:26:53,760
programs and scripting tasks and all of

00:26:50,100 --> 00:27:02,310
that the Python source code itself is

00:26:53,760 --> 00:27:05,280
very portable that was an issue and the

00:27:02,310 --> 00:27:07,500
licensing fit our needs so that's also

00:27:05,280 --> 00:27:11,940
important the licensing allows us to

00:27:07,500 --> 00:27:15,420
embed the code inside our inside our

00:27:11,940 --> 00:27:17,880
library so that was a thing yeah and

00:27:15,420 --> 00:27:20,100
generally Python has a great community

00:27:17,880 --> 00:27:23,120
great documentation it was a very

00:27:20,100 --> 00:27:23,120
natural choice for us

00:27:24,600 --> 00:27:33,310
right so essentially we created a fork

00:27:30,370 --> 00:27:37,440
of the Python interpreter so the first

00:27:33,310 --> 00:27:40,690
step was just asking ourselves do we use

00:27:37,440 --> 00:27:43,390
any version of Python data from Python

00:27:40,690 --> 00:27:46,240
org or whatever comes with our Linux

00:27:43,390 --> 00:27:49,570
distribution or whatever or do we treat

00:27:46,240 --> 00:27:53,170
it as part of our code and do we clone

00:27:49,570 --> 00:27:55,120
the entire Python code and check it into

00:27:53,170 --> 00:27:57,400
the same source code repository and

00:27:55,120 --> 00:27:59,350
these things well that was obvious we

00:27:57,400 --> 00:28:01,780
wanted to track the Python source code

00:27:59,350 --> 00:28:04,090
and a specific version of that as part

00:28:01,780 --> 00:28:06,040
of our engine so at some point I took

00:28:04,090 --> 00:28:08,230
the Python 2 point 6 point something

00:28:06,040 --> 00:28:12,400
source code added it to our version

00:28:08,230 --> 00:28:15,100
control and we compile it right into our

00:28:12,400 --> 00:28:17,710
engine this way on all the different

00:28:15,100 --> 00:28:21,040
platforms we know exactly what code

00:28:17,710 --> 00:28:25,120
we're aiming up with now and the forking

00:28:21,040 --> 00:28:28,390
came in when we had to port the engine

00:28:25,120 --> 00:28:30,880
to platforms that don't have an

00:28:28,390 --> 00:28:34,000
officially supported Python version for

00:28:30,880 --> 00:28:36,760
them like Windows CE II version 5 or

00:28:34,000 --> 00:28:39,700
whatever there is no official Python

00:28:36,760 --> 00:28:44,020
port for that so we had to make little

00:28:39,700 --> 00:28:46,060
changes to the source code and most of

00:28:44,020 --> 00:28:48,520
the functionality in Python we don't

00:28:46,060 --> 00:28:51,490
even need so or of the standard library

00:28:48,520 --> 00:28:54,970
I should say so whenever I had trouble

00:28:51,490 --> 00:28:57,460
compiling something in relation to the

00:28:54,970 --> 00:29:00,070
file system on Windows C I just threw

00:28:57,460 --> 00:29:03,420
out the code right this is not useful

00:29:00,070 --> 00:29:05,650
for for patching in the in the official

00:29:03,420 --> 00:29:08,500
Python interpreter so essentially we

00:29:05,650 --> 00:29:10,960
created a fork and chances are that we

00:29:08,500 --> 00:29:14,470
are never going to upgrade to Python 2.7

00:29:10,960 --> 00:29:18,430
or python 2.3 which in our use case

00:29:14,470 --> 00:29:20,740
isn't the problem the users don't really

00:29:18,430 --> 00:29:23,200
care whether print is a statement or a

00:29:20,740 --> 00:29:26,080
keyword or a print is a function right

00:29:23,200 --> 00:29:31,060
as long as they can use our application

00:29:26,080 --> 00:29:31,660
classes in a nice clean syntax they're

00:29:31,060 --> 00:29:34,390
fine with that

00:29:31,660 --> 00:29:37,029
or they should be fine with that so

00:29:34,390 --> 00:29:41,720
that's one of the reason for

00:29:37,029 --> 00:29:43,519
for king we can make changes without

00:29:41,720 --> 00:29:49,789
having to worry about how that's

00:29:43,519 --> 00:29:52,100
generally useful for Python sandboxing

00:29:49,789 --> 00:29:55,309
is another reason why you might want to

00:29:52,100 --> 00:29:57,740
create a fork as I said file system

00:29:55,309 --> 00:29:59,299
functionality that didn't quite compile

00:29:57,740 --> 00:30:01,870
or where I had trouble finding the right

00:29:59,299 --> 00:30:04,429
header files for them I just threw out

00:30:01,870 --> 00:30:07,519
same thing goes for functionality that's

00:30:04,429 --> 00:30:09,350
maybe too dangerous or too tempting for

00:30:07,519 --> 00:30:11,090
your users there might be useful

00:30:09,350 --> 00:30:14,120
functionality that doesn't really create

00:30:11,090 --> 00:30:15,710
them big security concerns but where

00:30:14,120 --> 00:30:19,730
users can very easily get themselves

00:30:15,710 --> 00:30:21,379
into more trouble than it's worth right

00:30:19,730 --> 00:30:25,210
we don't want the mathematical game

00:30:21,379 --> 00:30:28,970
engine to open an HTTP server or

00:30:25,210 --> 00:30:31,129
whatever so we just we can throw out the

00:30:28,970 --> 00:30:33,590
functionality it would be even more

00:30:31,129 --> 00:30:37,039
important if you were to create a word

00:30:33,590 --> 00:30:39,980
processor say where documents contain

00:30:37,039 --> 00:30:43,789
plugins there it's even more important

00:30:39,980 --> 00:30:46,759
maybe you want to forbid opening of

00:30:43,789 --> 00:30:48,950
files or something like that and that

00:30:46,759 --> 00:30:51,950
would be kind of hard to do I had a

00:30:48,950 --> 00:30:53,929
question yesterday why we didn't go for

00:30:51,950 --> 00:30:57,519
something like restricted Python or

00:30:53,929 --> 00:31:00,379
existing solutions that try to limit the

00:30:57,519 --> 00:31:02,889
things that you can do with Python well

00:31:00,379 --> 00:31:05,149
the thing is these are general-purpose

00:31:02,889 --> 00:31:08,059
solutions or they are meant to be so

00:31:05,149 --> 00:31:11,029
they they work on top of standard Python

00:31:08,059 --> 00:31:13,490
and they try to give you control in some

00:31:11,029 --> 00:31:16,129
way you can decide what you want to be

00:31:13,490 --> 00:31:18,500
available and whatnot it's a lot easier

00:31:16,129 --> 00:31:21,860
if you just don't compile the things

00:31:18,500 --> 00:31:23,509
that you don't need that's one thing you

00:31:21,860 --> 00:31:28,549
just have to remove it from your make

00:31:23,509 --> 00:31:31,129
file not compile that module but then

00:31:28,549 --> 00:31:33,110
even if you need part of a module but

00:31:31,129 --> 00:31:35,090
not some other parts or you want to

00:31:33,110 --> 00:31:37,519
restrict the functionality of a function

00:31:35,090 --> 00:31:41,090
Innes maybe you want files to be

00:31:37,519 --> 00:31:43,070
readable but not writable not that we do

00:31:41,090 --> 00:31:46,429
this but it would be thinkable you can

00:31:43,070 --> 00:31:50,800
just go in to the Python function that's

00:31:46,429 --> 00:31:53,470
responsible for opening files and not

00:31:50,800 --> 00:31:55,390
right operations something like that

00:31:53,470 --> 00:31:57,660
would be possible so yeah and in our

00:31:55,390 --> 00:32:04,630
case it's mostly throwing out stuff that

00:31:57,660 --> 00:32:06,370
we don't need yeah one of the final

00:32:04,630 --> 00:32:10,180
issues with questions that we had was

00:32:06,370 --> 00:32:14,080
how do we allow users to debug their

00:32:10,180 --> 00:32:17,920
plugins with a normal Python script you

00:32:14,080 --> 00:32:19,570
can fire up your favorite IDE PyCharm or

00:32:17,920 --> 00:32:23,340
eclipse or Idol or whatever

00:32:19,570 --> 00:32:26,500
and you can single step through the code

00:32:23,340 --> 00:32:28,690
set breakpoints evaluate watch

00:32:26,500 --> 00:32:30,430
expressions things like that that's not

00:32:28,690 --> 00:32:33,010
really possible with an embedded

00:32:30,430 --> 00:32:35,650
interpreter because the the IDE doesn't

00:32:33,010 --> 00:32:41,130
know how to invoke your C++ program and

00:32:35,650 --> 00:32:45,520
step through the embedded interpreter so

00:32:41,130 --> 00:32:48,430
my first thought was maybe I can open up

00:32:45,520 --> 00:32:50,680
a remote PDB server or something and

00:32:48,430 --> 00:32:52,840
people could connect to that inside

00:32:50,680 --> 00:32:55,420
Eclipse and so on but then I realized

00:32:52,840 --> 00:32:57,190
that's not really the user base that we

00:32:55,420 --> 00:32:59,740
have - they wouldn't be familiar with

00:32:57,190 --> 00:33:02,050
how to use Eclipse let alone how to

00:32:59,740 --> 00:33:03,880
remote debug in there so really what I

00:33:02,050 --> 00:33:05,560
wanted is something like Microsoft

00:33:03,880 --> 00:33:08,530
Office has where you have a nice

00:33:05,560 --> 00:33:12,040
built-in script editor and a nice

00:33:08,530 --> 00:33:13,870
built-in debugger working single step

00:33:12,040 --> 00:33:18,430
set breakpoints it might not be the most

00:33:13,870 --> 00:33:21,520
fancy debugger ever but it works it's

00:33:18,430 --> 00:33:23,680
simple and your users will pretty much

00:33:21,520 --> 00:33:27,580
be able to use it so it turns out that

00:33:23,680 --> 00:33:31,060
python has tracing capabilities built-in

00:33:27,580 --> 00:33:34,120
so you can register a C function with

00:33:31,060 --> 00:33:36,820
the interpreter and that C function will

00:33:34,120 --> 00:33:39,790
then be invoked every time you execute a

00:33:36,820 --> 00:33:42,010
new line of Python code and also every

00:33:39,790 --> 00:33:44,320
time an exception is raised or a

00:33:42,010 --> 00:33:46,060
function is called or you return from a

00:33:44,320 --> 00:33:47,800
function so you have these various

00:33:46,060 --> 00:33:50,350
points during the execution of the

00:33:47,800 --> 00:33:54,970
scripts where this C callback is invoked

00:33:50,350 --> 00:33:57,160
and being notified whenever you execute

00:33:54,970 --> 00:34:00,760
a line of code is enough to implement

00:33:57,160 --> 00:34:02,500
single stepping breakpoints you just

00:34:00,760 --> 00:34:02,890
have to monitor which line you're in and

00:34:02,500 --> 00:34:08,110
if the

00:34:02,890 --> 00:34:10,179
the breakpoint stop there so that gets

00:34:08,110 --> 00:34:13,720
you 90% of the way to a decent debugger

00:34:10,179 --> 00:34:17,770
and the rest is finding out what the

00:34:13,720 --> 00:34:20,020
call stack is printing the variables

00:34:17,770 --> 00:34:22,750
inside a stack frame but that's also

00:34:20,020 --> 00:34:25,330
very easy you can do this in in the

00:34:22,750 --> 00:34:27,010
piece of Python code very easily because

00:34:25,330 --> 00:34:30,399
there are all these introspection

00:34:27,010 --> 00:34:33,399
features in Python and just have to

00:34:30,399 --> 00:34:35,640
figure out what the Python see API calls

00:34:33,399 --> 00:34:38,340
are for that and then you can evaluate

00:34:35,640 --> 00:34:40,690
expressions it's it's even better than

00:34:38,340 --> 00:34:43,649
visual studio or whatever you can you

00:34:40,690 --> 00:34:46,390
can you can write entire you can have an

00:34:43,649 --> 00:34:48,790
interactive Python interpreter right

00:34:46,390 --> 00:34:51,280
inside your embedded interpreter you can

00:34:48,790 --> 00:34:54,159
manipulate all your application classes

00:34:51,280 --> 00:34:57,550
while debugging so that's pretty neat

00:34:54,159 --> 00:35:00,940
and in one of the recent additions to

00:34:57,550 --> 00:35:05,500
our game engine that I hope users are

00:35:00,940 --> 00:35:10,270
going to appreciate all right so that's

00:35:05,500 --> 00:35:12,520
that's basically it as this is a short

00:35:10,270 --> 00:35:14,170
talk I couldn't go into all the

00:35:12,520 --> 00:35:17,050
technical details but if you're

00:35:14,170 --> 00:35:19,150
interested in the topic I put up the the

00:35:17,050 --> 00:35:22,540
article about the talk on my website so

00:35:19,150 --> 00:35:25,510
you can go there right now and read up

00:35:22,540 --> 00:35:27,220
on on this particular talk and I'm

00:35:25,510 --> 00:35:29,680
planning to write a number of follow-up

00:35:27,220 --> 00:35:33,060
articles that provide you with more

00:35:29,680 --> 00:35:38,310
step-by-step instructions and tutorials

00:35:33,060 --> 00:35:41,920
how to actually do this whole and paying

00:35:38,310 --> 00:35:44,860
stuff right and I should also mention

00:35:41,920 --> 00:35:47,590
that our company is hiring so if you're

00:35:44,860 --> 00:35:49,540
interested in any of these topics you

00:35:47,590 --> 00:35:51,520
don't have to be an expert in embedding

00:35:49,540 --> 00:35:53,920
Python or in writing extension modules

00:35:51,520 --> 00:35:57,700
but if you have a general interest in

00:35:53,920 --> 00:35:59,680
that we're hiring in the mathematics

00:35:57,700 --> 00:36:02,500
department where we're we're responsible

00:35:59,680 --> 00:36:06,280
for the math engine and the embedded

00:36:02,500 --> 00:36:08,230
interpreter so yeah you can go to our

00:36:06,280 --> 00:36:11,830
website or talk to me after the talk and

00:36:08,230 --> 00:36:15,150
I can give you the details so thanks a

00:36:11,830 --> 00:36:15,150
lot for for showing up

00:36:43,619 --> 00:36:50,799
so the question was whether we or just

00:36:46,869 --> 00:36:52,779
yeah I'm learning fast so the question

00:36:50,799 --> 00:36:54,729
was whether we're running the Python

00:36:52,779 --> 00:36:58,119
interpreter on the same thread as the

00:36:54,729 --> 00:37:03,729
C++ code and whether we can call back

00:36:58,119 --> 00:37:05,650
and forth between or actually you asked

00:37:03,729 --> 00:37:10,089
specifically about accessing Singleton's

00:37:05,650 --> 00:37:13,539
in C++ from the executed Python code

00:37:10,089 --> 00:37:15,880
yeah in fact I should also mention that

00:37:13,539 --> 00:37:17,739
now that you remind me uh our

00:37:15,880 --> 00:37:20,019
application is a single single threaded

00:37:17,739 --> 00:37:22,630
application which I like because it

00:37:20,019 --> 00:37:24,700
keeps things simple it would actually be

00:37:22,630 --> 00:37:26,410
possible to have several threads of

00:37:24,700 --> 00:37:28,749
execution with the embedded interpreter

00:37:26,410 --> 00:37:33,849
the interpreter is able to distinguish

00:37:28,749 --> 00:37:35,890
between various thread contexts but you

00:37:33,849 --> 00:37:38,920
will explicitly have to take care of

00:37:35,890 --> 00:37:40,749
locking and and all these things so we

00:37:38,920 --> 00:37:42,910
kind of avoid that so we are always on

00:37:40,749 --> 00:37:47,289
the same thread as the main c++

00:37:42,910 --> 00:37:49,660
application so going back actually to

00:37:47,289 --> 00:37:53,680
this example here so during the

00:37:49,660 --> 00:37:55,690
execution of our c++ code or here would

00:37:53,680 --> 00:38:00,279
be even better when you call the call

00:37:55,690 --> 00:38:04,630
python filter inside there we call into

00:38:00,279 --> 00:38:06,849
the Python interpreter so that's we're

00:38:04,630 --> 00:38:09,309
on the same thread so this will be will

00:38:06,849 --> 00:38:13,660
block the C++ code as long as the Python

00:38:09,309 --> 00:38:15,670
code executes and then when the Python

00:38:13,660 --> 00:38:18,640
interpreter the seek held inside the

00:38:15,670 --> 00:38:20,529
Python interpreter runs or the Python

00:38:18,640 --> 00:38:23,890
interpreter calls into an extension

00:38:20,529 --> 00:38:26,099
function that we registered it will

00:38:23,890 --> 00:38:33,219
still be all on the same thread

00:38:26,099 --> 00:38:35,439
so in let's go back even further so this

00:38:33,219 --> 00:38:37,479
wraps sum function I could have the same

00:38:35,439 --> 00:38:42,160
thing when I'm embedding the Python

00:38:37,479 --> 00:38:44,499
interpreter and if I register it with

00:38:42,160 --> 00:38:47,140
the embedded interpreter the Python

00:38:44,499 --> 00:38:49,269
plug-in code will be able to invoke it

00:38:47,140 --> 00:38:53,459
and it will still be on the same thread

00:38:49,269 --> 00:38:55,930
so it's nice and easy to follow along to

00:38:53,459 --> 00:38:58,660
debug that as there's nothing nothing

00:38:55,930 --> 00:39:01,559
fancy like a separate interpreter thread

00:38:58,660 --> 00:39:01,559
going on

00:39:28,229 --> 00:39:40,839
right right yeah so the question is

00:39:37,029 --> 00:39:43,059
whether we are calling the Python code

00:39:40,839 --> 00:39:45,549
directly from the C++ classes or what

00:39:43,059 --> 00:39:47,859
the separation is between the C++ and

00:39:45,549 --> 00:39:50,319
Python worlds so actually that's that's

00:39:47,859 --> 00:39:52,630
only just a question of how to organize

00:39:50,319 --> 00:39:55,119
your source code so everything happens

00:39:52,630 --> 00:39:57,640
on the same thread you could just as

00:39:55,119 --> 00:40:00,849
well mix in the Python C API functions

00:39:57,640 --> 00:40:03,130
every throughout the C++ code so that's

00:40:00,849 --> 00:40:05,619
really just a question of organizing

00:40:03,130 --> 00:40:08,170
your source code in our case what we had

00:40:05,619 --> 00:40:10,829
was an existing C++ mathematical game

00:40:08,170 --> 00:40:15,329
engine with all the classes in place and

00:40:10,829 --> 00:40:18,549
what I did not want to do is like go to

00:40:15,329 --> 00:40:20,859
100 different C++ files and add a Python

00:40:18,549 --> 00:40:25,479
C API call there and there and there and

00:40:20,859 --> 00:40:27,999
there so I tried to keep to have only a

00:40:25,479 --> 00:40:30,670
very small number of C++ compilation

00:40:27,999 --> 00:40:33,670
units that even include the Python

00:40:30,670 --> 00:40:35,890
header files right so when a C++

00:40:33,670 --> 00:40:38,349
function needs to invoke something in

00:40:35,890 --> 00:40:44,229
the Python world it will always go to

00:40:38,349 --> 00:40:47,650
that component of the application the

00:40:44,229 --> 00:40:50,259
interface to that C++ function will all

00:40:47,650 --> 00:40:53,170
be C++ datatypes so make sure never to

00:40:50,259 --> 00:40:57,039
pass a PI object into the C++ world or

00:40:53,170 --> 00:40:58,749
let's say too deep into the C++ world so

00:40:57,039 --> 00:41:01,930
it's yeah just basically just a matter

00:40:58,749 --> 00:41:04,479
of keeping everything tidy and and

00:41:01,930 --> 00:41:10,520
separated which will be a lot easier to

00:41:04,479 --> 00:41:16,210
maintain does that answer it yeah

00:41:10,520 --> 00:41:16,210
mentioned that they seek Moscati right

00:41:27,099 --> 00:41:34,829
right so the question was about the the

00:41:30,759 --> 00:41:37,839
Arab Pro me the another from Ness of of

00:41:34,829 --> 00:41:41,259
the the code that calls the the Python

00:41:37,839 --> 00:41:44,619
capi yeah that mostly comes from you

00:41:41,259 --> 00:41:49,329
having to explicitly check for error

00:41:44,619 --> 00:41:52,449
conditions and also the reference

00:41:49,329 --> 00:41:54,459
counting so it's it's very easy well as

00:41:52,449 --> 00:41:57,400
we all know it would be the same with

00:41:54,459 --> 00:41:59,619
malloc and free and that's why we prefer

00:41:57,400 --> 00:42:01,630
to use an STL vector or something like

00:41:59,619 --> 00:42:05,380
that so that these are the issues that

00:42:01,630 --> 00:42:08,410
come up and as far as tips go I would

00:42:05,380 --> 00:42:12,489
say use a C++ library that wraps the

00:42:08,410 --> 00:42:14,529
objects I know I said we don't but in

00:42:12,489 --> 00:42:18,809
our case we also have the luxury of

00:42:14,529 --> 00:42:22,299
having code generators for some parts of

00:42:18,809 --> 00:42:25,449
the engine where we actually know what

00:42:22,299 --> 00:42:27,699
the functionality of the engine is so we

00:42:25,449 --> 00:42:30,640
can automatically generate large parts

00:42:27,699 --> 00:42:33,789
of this error prone code so that

00:42:30,640 --> 00:42:35,920
alleviates the problem a bit but apart

00:42:33,789 --> 00:42:38,789
from that at least even if you're not

00:42:35,920 --> 00:42:42,539
using a library create a class that

00:42:38,789 --> 00:42:45,130
wraps PI objects and will automatically

00:42:42,539 --> 00:42:47,229
decrement the reference counter when it

00:42:45,130 --> 00:42:50,289
goes out of scope that gets you a very

00:42:47,229 --> 00:42:52,869
long way and as soon as you do that it's

00:42:50,289 --> 00:42:55,209
much easier to react to errors because

00:42:52,869 --> 00:42:57,309
wherever you are you can just raise and

00:42:55,209 --> 00:43:00,339
you know that all the reference counts

00:42:57,309 --> 00:43:02,289
will be taken care of right so otherwise

00:43:00,339 --> 00:43:05,109
if you don't do that you will be

00:43:02,289 --> 00:43:07,209
reluctant to react to errors immediately

00:43:05,109 --> 00:43:08,529
so you will try to say oh yeah I know

00:43:07,209 --> 00:43:11,469
that's something went wrong but I still

00:43:08,529 --> 00:43:14,339
have to do this and you know that that

00:43:11,469 --> 00:43:14,339
makes it there a problem

00:43:17,290 --> 00:43:29,860
anymore right yeah then thank you very

00:43:22,000 --> 00:43:33,870
much and if the audio didn't work out

00:43:29,860 --> 00:43:33,870

YouTube URL: https://www.youtube.com/watch?v=aK8gDUUBMiM


