Title: In search of reduced loading times
Publication date: 2015-04-19
Playlist: EuroPython 2012
Description: 
	[EuroPython 2012] Aposolis Bessas - 6 JULY 2012 in "Track Lasagne"
Captions: 
	00:00:49,150 --> 00:00:51,240
Oh

00:02:00,670 --> 00:02:07,540
come back to track lasagna next speaker

00:02:03,640 --> 00:02:09,670
is apostolis basis which is going to

00:02:07,540 --> 00:02:19,209
explain how to reduce loading times with

00:02:09,670 --> 00:02:22,840
Django apostolis caliber thanks for

00:02:19,209 --> 00:02:25,030
coming I am above stoli's and okay I

00:02:22,840 --> 00:02:26,980
work for transfix it is a Greek startup

00:02:25,030 --> 00:02:31,720
company and of course this is a jungle

00:02:26,980 --> 00:02:33,970
up other thing is that as transfers had

00:02:31,720 --> 00:02:36,550
to grow many things we press many things

00:02:33,970 --> 00:02:38,230
with the way we use Django and this is

00:02:36,550 --> 00:02:42,310
what this talk is about ethics that we

00:02:38,230 --> 00:02:45,160
learn the hard way so the first of the

00:02:42,310 --> 00:02:48,640
biggest part is about drm is about how

00:02:45,160 --> 00:02:53,019
to optimize they scale that we your or

00:02:48,640 --> 00:02:55,540
inquiries your RM use actually meets so

00:02:53,019 --> 00:02:56,500
first things first it you cannot

00:02:55,540 --> 00:02:58,840
optimize something that you can't

00:02:56,500 --> 00:03:01,510
measure thankfully there are many tools

00:02:58,840 --> 00:03:04,180
for Django that will tell you exactly

00:03:01,510 --> 00:03:08,859
how many queries you run how much time

00:03:04,180 --> 00:03:10,660
they take what are those committed where

00:03:08,859 --> 00:03:13,440
those queries are evaluated and stuff

00:03:10,660 --> 00:03:16,060
like that jungle debug tool Burke is I

00:03:13,440 --> 00:03:17,320
assume most of you already know it but

00:03:16,060 --> 00:03:21,790
there are other tools like jungle

00:03:17,320 --> 00:03:24,160
observer i recently django added to the

00:03:21,790 --> 00:03:26,950
logger a way to meet all SQL queries and

00:03:24,160 --> 00:03:29,440
there's also a setting in postgresql in

00:03:26,950 --> 00:03:30,940
case you use postgresql God logmein

00:03:29,440 --> 00:03:36,299
Eurasian statement which will log the

00:03:30,940 --> 00:03:38,350
most long queries which affect the most

00:03:36,299 --> 00:03:40,450
actually setting that you could also use

00:03:38,350 --> 00:03:45,390
in production to help you not get

00:03:40,450 --> 00:03:50,880
notified about very long time running

00:03:45,390 --> 00:03:53,590
queries so first let's talk about how

00:03:50,880 --> 00:03:57,250
about the valuations of query sets in

00:03:53,590 --> 00:04:00,579
Django but when you use the RM you

00:03:57,250 --> 00:04:03,430
actually create a query sets you can

00:04:00,579 --> 00:04:04,900
always equation however questions are

00:04:03,430 --> 00:04:08,079
not evaluated until at the very last

00:04:04,900 --> 00:04:09,280
minute whenever they are needed this

00:04:08,079 --> 00:04:12,580
however creates a couple of problems

00:04:09,280 --> 00:04:14,050
this is one of the very combination an

00:04:12,580 --> 00:04:17,049
issue that can be

00:04:14,050 --> 00:04:20,440
welcome easily miss this we create a

00:04:17,049 --> 00:04:23,890
query said that just tries to fetch all

00:04:20,440 --> 00:04:26,920
to-do items that belong to me and then

00:04:23,890 --> 00:04:30,310
it transfers count method to get the

00:04:26,920 --> 00:04:32,200
number of those items and then consider

00:04:30,310 --> 00:04:34,690
play passing the equation as a parameter

00:04:32,200 --> 00:04:36,580
the thing is that this particular

00:04:34,690 --> 00:04:39,250
example will evaluate the question twice

00:04:36,580 --> 00:04:43,560
so you will do the actual the actual

00:04:39,250 --> 00:04:46,210
query two times puts in many cases but

00:04:43,560 --> 00:04:48,490
there are many ways where if you are not

00:04:46,210 --> 00:04:50,020
very careful with how will serve al

00:04:48,490 --> 00:04:56,140
uated you will fall into this trap

00:04:50,020 --> 00:04:57,790
allowed I mean we have there if you

00:04:56,140 --> 00:04:58,960
check the queerest API in the jungle

00:04:57,790 --> 00:05:00,730
documentation you will see that there

00:04:58,960 --> 00:05:03,790
are many functions that will tell you

00:05:00,730 --> 00:05:06,100
that this thing of value exquisite so

00:05:03,790 --> 00:05:09,280
you very careful at which function use

00:05:06,100 --> 00:05:10,860
and how you use them to energy reduce

00:05:09,280 --> 00:05:13,390
the number of queries that you actually

00:05:10,860 --> 00:05:15,460
execute in this particular case it would

00:05:13,390 --> 00:05:17,470
be much much more helpful to evaluate

00:05:15,460 --> 00:05:19,750
the query set as a least in the first

00:05:17,470 --> 00:05:22,780
line since you seem care about the count

00:05:19,750 --> 00:05:25,150
and just run the length man the land

00:05:22,780 --> 00:05:28,270
method on top of that list that will

00:05:25,150 --> 00:05:32,620
reduce the question to just 1 i'm

00:05:28,270 --> 00:05:36,580
speaking about doing less queries there

00:05:32,620 --> 00:05:38,800
are there are two functions that jungle

00:05:36,580 --> 00:05:41,200
provides that will help with that the

00:05:38,800 --> 00:05:43,720
first one is the Select related and this

00:05:41,200 --> 00:05:45,400
is only used for 11 fields and foreign

00:05:43,720 --> 00:05:47,919
key fields the other one which goes

00:05:45,400 --> 00:05:50,380
added risk Philly just in jag 1.4 is

00:05:47,919 --> 00:05:52,090
that free pet related one and this was

00:05:50,380 --> 00:05:54,940
the problem of how to efficiently

00:05:52,090 --> 00:05:57,610
execute queries for many many relations

00:05:54,940 --> 00:06:01,090
and as well as the reverse direction in

00:05:57,610 --> 00:06:03,880
foreign keys so let's take a look at how

00:06:01,090 --> 00:06:07,510
this actually work first let's talk

00:06:03,880 --> 00:06:09,370
about select relating but in this

00:06:07,510 --> 00:06:11,290
particular example we have a one-to-one

00:06:09,370 --> 00:06:16,330
relation there is a user object on the

00:06:11,290 --> 00:06:17,680
profile log and let's assume that you

00:06:16,330 --> 00:06:19,930
want to use the user object but you also

00:06:17,680 --> 00:06:21,280
want to access in your view or in other

00:06:19,930 --> 00:06:25,780
parts of the code the profile because

00:06:21,280 --> 00:06:27,580
well if you'd be the pivot the default

00:06:25,780 --> 00:06:29,169
way I mean like

00:06:27,580 --> 00:06:31,120
selecting first the user object without

00:06:29,169 --> 00:06:33,729
the select related and then accessing

00:06:31,120 --> 00:06:35,379
the profile as an attribute of the user

00:06:33,729 --> 00:06:37,330
object you'll that with the beard to

00:06:35,379 --> 00:06:39,699
queries want to face the user and on to

00:06:37,330 --> 00:06:43,629
fit the profile itself using select

00:06:39,699 --> 00:06:46,479
related however added joy right at that

00:06:43,629 --> 00:06:49,120
point up by the way the dot query at the

00:06:46,479 --> 00:06:50,500
end returns a query object if I recall

00:06:49,120 --> 00:06:53,560
correctly and if you bring that it will

00:06:50,500 --> 00:06:56,439
print the exact SQL statement that would

00:06:53,560 --> 00:06:59,379
be executed in my exams I don't use the

00:06:56,439 --> 00:07:03,310
exact size K statement due to size but

00:06:59,379 --> 00:07:05,500
it's pretty much the same so using the

00:07:03,310 --> 00:07:07,000
Select related function will result in

00:07:05,500 --> 00:07:09,639
this query which is one query that will

00:07:07,000 --> 00:07:12,400
fetch in in one step both the user and

00:07:09,639 --> 00:07:18,729
the user and the profile object you

00:07:12,400 --> 00:07:20,979
don't care about the table names the

00:07:18,729 --> 00:07:24,279
objects in Django have the specific

00:07:20,979 --> 00:07:27,279
class where they store all attributed as

00:07:24,279 --> 00:07:29,229
they are fed from database so when you

00:07:27,279 --> 00:07:31,569
do when you use the Select related

00:07:29,229 --> 00:07:33,370
jungle will populate the pillar of the

00:07:31,569 --> 00:07:35,560
user object but it will also populate on

00:07:33,370 --> 00:07:36,940
cars the pins for the profile so when

00:07:35,560 --> 00:07:38,949
you access the profile later maybe in

00:07:36,940 --> 00:07:40,810
your user in that the blades there would

00:07:38,949 --> 00:07:46,750
there will be no more there won't be

00:07:40,810 --> 00:07:49,839
another SQL query executed ok next up is

00:07:46,750 --> 00:07:52,240
about professional lady Pripet related

00:07:49,839 --> 00:07:55,330
as I said before it's mostly for many

00:07:52,240 --> 00:07:58,029
too many fields the example that I use

00:07:55,330 --> 00:08:00,370
is directly from the jungle tutorial for

00:07:58,029 --> 00:08:03,430
1.4 we assume that there is a pizza

00:08:00,370 --> 00:08:06,210
object and the topping subject topics

00:08:03,430 --> 00:08:10,629
class sorry and there's a many-to-many

00:08:06,210 --> 00:08:12,310
relation to the to the normal way the

00:08:10,629 --> 00:08:13,960
way you would do it before Jack 1.4

00:08:12,310 --> 00:08:15,819
before prefetch related will be to press

00:08:13,960 --> 00:08:18,449
the picture objects and then iterate

00:08:15,819 --> 00:08:20,969
over them and fetch the toppings object

00:08:18,449 --> 00:08:24,099
however that results in n queries

00:08:20,969 --> 00:08:26,979
actually yeah for it spits object will

00:08:24,099 --> 00:08:31,300
craft execute an extra waited to the

00:08:26,979 --> 00:08:32,050
toppings table pets the the toppings

00:08:31,300 --> 00:08:34,599
that are related to the particular

00:08:32,050 --> 00:08:36,940
picture object this is where prefix

00:08:34,599 --> 00:08:41,070
related fitting prefeitura late will

00:08:36,940 --> 00:08:43,560
reduce those inquiries to just two

00:08:41,070 --> 00:08:45,930
query will read the all the pitch

00:08:43,560 --> 00:08:48,090
objects themselves and there's a second

00:08:45,930 --> 00:08:51,480
query that will try to fit all toppings

00:08:48,090 --> 00:08:53,820
as well as the pizza ID which is in the

00:08:51,480 --> 00:08:57,870
second night of the cone in the second

00:08:53,820 --> 00:09:00,450
side leg given that Peter ID it jungle

00:08:57,870 --> 00:09:03,030
is smart enough to know that the

00:09:00,450 --> 00:09:07,050
particular toppings objects belong to

00:09:03,030 --> 00:09:09,600
this particular pizza object so after

00:09:07,050 --> 00:09:12,330
having paid to the result it will just

00:09:09,600 --> 00:09:14,640
go over all pizza objects in Python code

00:09:12,330 --> 00:09:18,270
and try to fill in the cast with the

00:09:14,640 --> 00:09:24,150
particular top toppings objects is that

00:09:18,270 --> 00:09:29,100
clear so we went from n queries to just

00:09:24,150 --> 00:09:31,500
two which is pretty awesome by the way

00:09:29,100 --> 00:09:36,930
talking about caches and stuff like that

00:09:31,500 --> 00:09:38,400
I believe that many people there is an

00:09:36,930 --> 00:09:41,160
iterator faction which doesn't get

00:09:38,400 --> 00:09:43,590
mentioned the load what is the rate of

00:09:41,160 --> 00:09:45,890
function does is that it tells jungle to

00:09:43,590 --> 00:09:49,260
not cast the results from the database

00:09:45,890 --> 00:09:51,150
so normally jungle will cast the result

00:09:49,260 --> 00:09:52,770
so when you use the query set a second

00:09:51,150 --> 00:09:56,490
the third the first time you don't hit

00:09:52,770 --> 00:09:58,740
the database again but in in my

00:09:56,490 --> 00:10:00,690
experience most people don't use a query

00:09:58,740 --> 00:10:05,810
said the second time the only gives the

00:10:00,690 --> 00:10:05,810
ones and by using iterator you avoid

00:10:06,890 --> 00:10:14,700
increasing the memory use it since you

00:10:10,560 --> 00:10:17,910
don't fill the data in the cars less

00:10:14,700 --> 00:10:21,240
memories actually used this is specially

00:10:17,910 --> 00:10:23,220
useful for bigquery set whether it will

00:10:21,240 --> 00:10:26,220
that might place a lot of stuff your

00:10:23,220 --> 00:10:28,230
memories will increase dramatically and

00:10:26,220 --> 00:10:30,210
this end of relying to garbage

00:10:28,230 --> 00:10:34,440
collection or whatever you can just use

00:10:30,210 --> 00:10:37,320
the traitor and avoid this thing okay

00:10:34,440 --> 00:10:39,000
next step let's talk about on a date

00:10:37,320 --> 00:10:44,010
with another function to solid I think

00:10:39,000 --> 00:10:47,850
enjoy 1.3 but a note it does is it tries

00:10:44,010 --> 00:10:51,950
to do some aggregation stuff on top of

00:10:47,850 --> 00:10:54,870
your queries for instance you can

00:10:51,950 --> 00:10:59,279
because if you want to have a song

00:10:54,870 --> 00:11:02,279
or a maximum the maximum of a corner

00:10:59,279 --> 00:11:05,220
stuff like that one rule is to always

00:11:02,279 --> 00:11:10,170
use values with another function in the

00:11:05,220 --> 00:11:14,550
question API before the annotate let's

00:11:10,170 --> 00:11:17,510
see an example why is that let's assume

00:11:14,550 --> 00:11:20,400
that a big sub list from traffic's code

00:11:17,510 --> 00:11:22,950
more or less okay let's assume that you

00:11:20,400 --> 00:11:25,710
have a resource that is related to

00:11:22,950 --> 00:11:29,279
project and you are interested to find

00:11:25,710 --> 00:11:34,200
the word count which is a column with a

00:11:29,279 --> 00:11:35,490
resource Bible let's say that let's

00:11:34,200 --> 00:11:39,300
assume that you write the first query

00:11:35,490 --> 00:11:42,300
set and this is the part of the actual

00:11:39,300 --> 00:11:44,970
SQL query what this does is it tries to

00:11:42,300 --> 00:11:46,980
group by it does a group by over all

00:11:44,970 --> 00:11:49,500
attributes of the resource object with

00:11:46,980 --> 00:11:52,470
this in most cases wrong because when

00:11:49,500 --> 00:11:54,570
you do a group by in the scale you are

00:11:52,470 --> 00:11:56,970
mostly interested in some in a specific

00:11:54,570 --> 00:12:00,589
in a specific field and specific Adam

00:11:56,970 --> 00:12:02,820
not all of them but the thing is that

00:12:00,589 --> 00:12:06,180
when you grew by over all of them even

00:12:02,820 --> 00:12:08,150
if they are even if it was correct would

00:12:06,180 --> 00:12:10,709
mean that that the best would have to

00:12:08,150 --> 00:12:13,770
take all those columns see which are the

00:12:10,709 --> 00:12:16,080
same and try to group by stuff over all

00:12:13,770 --> 00:12:19,920
those columns but if you already know

00:12:16,080 --> 00:12:21,830
that this if you are only interested in

00:12:19,920 --> 00:12:25,589
the slug that is what differentiates

00:12:21,830 --> 00:12:27,480
rose from resources and use the values

00:12:25,589 --> 00:12:29,310
function before the annotate the group

00:12:27,480 --> 00:12:30,720
buys only over slag which is much more

00:12:29,310 --> 00:12:33,930
efficient instead of having to do a

00:12:30,720 --> 00:12:35,760
group x over all columns or whatever it

00:12:33,930 --> 00:12:43,470
just do a group x over there the one

00:12:35,760 --> 00:12:46,529
that is actually needed okay that's it

00:12:43,470 --> 00:12:49,740
there are many times that you have to

00:12:46,529 --> 00:12:54,480
use the rest well however powerful the

00:12:49,740 --> 00:12:56,430
jungle RM is there are times when it it

00:12:54,480 --> 00:12:59,870
does not allow you to do what you

00:12:56,430 --> 00:13:02,520
actually want in the most efficient way

00:12:59,870 --> 00:13:05,520
when you when you have to scale when you

00:13:02,520 --> 00:13:08,690
when your web application grows there

00:13:05,520 --> 00:13:11,520
will be a point that you will have to

00:13:08,690 --> 00:13:19,740
have to go out of the boundaries that

00:13:11,520 --> 00:13:21,470
DRM has anyway so don't be afraid to use

00:13:19,740 --> 00:13:23,730
the Royal queries wherever it is needed

00:13:21,470 --> 00:13:27,380
jungle provides two ways to do that

00:13:23,730 --> 00:13:31,110
there is the monitor the draw function

00:13:27,380 --> 00:13:34,410
which is a fact with a method on manager

00:13:31,110 --> 00:13:35,790
object there is also the it also allows

00:13:34,410 --> 00:13:41,970
you to use the cursor object directly

00:13:35,790 --> 00:13:44,970
from database and do what everyone so

00:13:41,970 --> 00:13:47,280
the monitor drop method absolutely

00:13:44,970 --> 00:13:48,900
return something return something that's

00:13:47,280 --> 00:13:53,520
called rock we reset it is not the query

00:13:48,900 --> 00:13:55,560
set it is a requested that was yeah that

00:13:53,520 --> 00:13:58,140
will generate from their own method this

00:13:55,560 --> 00:13:59,940
is something that is like equation it is

00:13:58,140 --> 00:14:03,450
MC query set however it is not the

00:13:59,940 --> 00:14:05,460
position so you this means that you

00:14:03,450 --> 00:14:07,980
cannot for instance use their own method

00:14:05,460 --> 00:14:10,730
that then apply filters slicing stuff

00:14:07,980 --> 00:14:13,670
like that no method is a final thing

00:14:10,730 --> 00:14:16,560
that's the way that would be executed on

00:14:13,670 --> 00:14:18,450
the other count the objects that are

00:14:16,560 --> 00:14:20,460
generated from a rock we reset our valve

00:14:18,450 --> 00:14:22,170
models are valid objects of your model

00:14:20,460 --> 00:14:26,220
so if you have a rock we reset that

00:14:22,170 --> 00:14:28,320
returns projects or pizzas or toppings

00:14:26,220 --> 00:14:31,230
whatever and get irate over that query

00:14:28,320 --> 00:14:32,940
set of the of that rope where is it the

00:14:31,230 --> 00:14:35,010
objects will be will be okay will be

00:14:32,940 --> 00:14:37,710
correct so you can use all methods as

00:14:35,010 --> 00:14:42,300
defined in your models or latitudes all

00:14:37,710 --> 00:14:45,180
properties and stuff like that so rocky

00:14:42,300 --> 00:14:47,760
resets are a way to construct more

00:14:45,180 --> 00:14:54,839
complex queries but still have some of

00:14:47,760 --> 00:14:57,030
the benefits of using the jungle RM this

00:14:54,839 --> 00:15:03,720
is an example of an of an advanced query

00:14:57,030 --> 00:15:05,970
ship over I was clearly sorry the basic

00:15:03,720 --> 00:15:08,310
thing about the ROM Baro method is to

00:15:05,970 --> 00:15:12,210
always return the idea of the column so

00:15:08,310 --> 00:15:16,110
that the jungle can can know that this

00:15:12,210 --> 00:15:20,490
object belongs to this rope so that can

00:15:16,110 --> 00:15:22,140
do the mapping between the two the

00:15:20,490 --> 00:15:24,460
example is not very

00:15:22,140 --> 00:15:26,830
important I just want to use the type

00:15:24,460 --> 00:15:28,660
use the crosstab method the crystal

00:15:26,830 --> 00:15:32,230
function which is possibly square

00:15:28,660 --> 00:15:34,930
specific and I could do it I could use

00:15:32,230 --> 00:15:38,830
whatever postgis provides or SQL

00:15:34,930 --> 00:15:44,770
provides and the result would be valid

00:15:38,830 --> 00:15:49,150
valid objects Clank oh by the way using

00:15:44,770 --> 00:15:52,080
the vero manager is a I think it is one

00:15:49,150 --> 00:15:55,360
of the very few ways you have to do

00:15:52,080 --> 00:15:57,220
where is that take advantage of the

00:15:55,360 --> 00:16:00,790
union of the acceptance not like that

00:15:57,220 --> 00:16:11,770
which at least we have you have needed

00:16:00,790 --> 00:16:13,360
them a lot of times Oh next web there

00:16:11,770 --> 00:16:15,130
are another two functions which are

00:16:13,360 --> 00:16:22,350
called different lonely in the query set

00:16:15,130 --> 00:16:27,070
API they do more or less similar things

00:16:22,350 --> 00:16:29,380
the defer function drugs Django to meet

00:16:27,070 --> 00:16:32,860
certain columns from the Select least so

00:16:29,380 --> 00:16:36,310
when you do is lake from whatever table

00:16:32,860 --> 00:16:37,750
ii it will omit specific goals the only

00:16:36,310 --> 00:16:41,410
faction does exact opposite it specifies

00:16:37,750 --> 00:16:45,250
which columns to use their particularly

00:16:41,410 --> 00:16:47,140
useful in cases where you you know for

00:16:45,250 --> 00:16:49,480
sure that you want you're not going to

00:16:47,140 --> 00:16:52,540
need some columns so why bother petting

00:16:49,480 --> 00:16:54,670
them because fretting columns results in

00:16:52,540 --> 00:16:59,800
higher this guy or network I owed to

00:16:54,670 --> 00:17:04,390
translate to you locally as an example

00:16:59,800 --> 00:17:06,610
maybe summer has toured a very big blob

00:17:04,390 --> 00:17:10,420
object something very big in the current

00:17:06,610 --> 00:17:12,370
which is rarely access using different

00:17:10,420 --> 00:17:16,660
only you can avoid fetching that all the

00:17:12,370 --> 00:17:21,190
time but only on demand so this is a

00:17:16,660 --> 00:17:23,100
true story from transfix code the

00:17:21,190 --> 00:17:26,130
problem when your web application grows

00:17:23,100 --> 00:17:28,480
incremental ian stomach that is that

00:17:26,130 --> 00:17:33,000
things that used to work at some point

00:17:28,480 --> 00:17:34,860
break completely so

00:17:33,000 --> 00:17:38,690
back in transcripts we had a drop down

00:17:34,860 --> 00:17:44,160
menu that the only thing he did was just

00:17:38,690 --> 00:17:47,250
have the list of projects too so this

00:17:44,160 --> 00:17:50,400
was the query said that was more or less

00:17:47,250 --> 00:17:52,950
it's not Jackie that that was used so

00:17:50,400 --> 00:17:54,390
only did was to exclude any private

00:17:52,950 --> 00:17:57,980
projects which are not sewn to the

00:17:54,390 --> 00:18:00,180
public run a distinct on them so that

00:17:57,980 --> 00:18:03,300
the same product that doesn't get some

00:18:00,180 --> 00:18:05,910
plies under the order them by name this

00:18:03,300 --> 00:18:10,260
used to work perfectly well but at some

00:18:05,910 --> 00:18:15,750
point yeah but some point that we took

00:18:10,260 --> 00:18:18,350
like 10 seconds out of the blue so this

00:18:15,750 --> 00:18:26,340
is the actual query that was executed

00:18:18,350 --> 00:18:33,420
right there as you can see it's exactly

00:18:26,340 --> 00:18:35,520
the exact same so what was the problem

00:18:33,420 --> 00:18:38,040
in this particular case the thing is

00:18:35,520 --> 00:18:40,800
that the weight distinct works in SQL

00:18:38,040 --> 00:18:43,350
databases is that in order for the

00:18:40,800 --> 00:18:46,830
database to know if if there are

00:18:43,350 --> 00:18:49,350
duplicate rows or duplicate values it

00:18:46,830 --> 00:18:52,350
has it first has to sort the result and

00:18:49,350 --> 00:19:00,480
then remove any duplicate values from

00:18:52,350 --> 00:19:02,430
that result yeah so looking at the I

00:19:00,480 --> 00:19:04,140
don't know coming up you know posters

00:19:02,430 --> 00:19:06,810
and the analyzed statement explaining

00:19:04,140 --> 00:19:08,160
our life statement but we can't the

00:19:06,810 --> 00:19:09,990
output of the explain analyze statement

00:19:08,160 --> 00:19:12,840
which is for the rest of you for that

00:19:09,990 --> 00:19:16,020
for those who don't know it's a way for

00:19:12,840 --> 00:19:20,040
posters to tell you exactly how to run a

00:19:16,020 --> 00:19:24,300
query if it were used Joyce if it did

00:19:20,040 --> 00:19:27,120
any sequential scans whatever so running

00:19:24,300 --> 00:19:30,330
that explain analyzing all that query

00:19:27,120 --> 00:19:31,830
revealed that the sorting part was done

00:19:30,330 --> 00:19:35,760
an external memory instead of doing an

00:19:31,830 --> 00:19:39,330
in-memory an in-memory sorting with

00:19:35,760 --> 00:19:41,730
quick shot for instance it turns out

00:19:39,330 --> 00:19:45,660
that there is a setting in Postgres that

00:19:41,730 --> 00:19:46,770
say that tells that instructs poultice

00:19:45,660 --> 00:19:51,560
comets around the

00:19:46,770 --> 00:19:51,560
use for sorting that was a bit low so

00:19:52,580 --> 00:19:58,620
the first thing that came to mind was

00:19:54,660 --> 00:20:00,240
just to bump that up a bit however not

00:19:58,620 --> 00:20:02,250
seem that the query you will see that we

00:20:00,240 --> 00:20:04,320
try to do a distinct overall attributes

00:20:02,250 --> 00:20:10,590
overall concert the project model

00:20:04,320 --> 00:20:12,960
actually has what if we just you fetch

00:20:10,590 --> 00:20:17,970
the only the concert we actually use the

00:20:12,960 --> 00:20:22,170
idea the name doing that magically solve

00:20:17,970 --> 00:20:24,740
the problem this is a real world example

00:20:22,170 --> 00:20:30,360
of why you would want to use only and

00:20:24,740 --> 00:20:33,600
only diff erent those kinds of functions

00:20:30,360 --> 00:20:37,470
on top of the queries and this is the

00:20:33,600 --> 00:20:42,810
link to a blog post about that anyway

00:20:37,470 --> 00:20:45,300
let's move on some some of web

00:20:42,810 --> 00:20:46,740
applications have to do a lot of other

00:20:45,300 --> 00:20:48,720
bio there are certain cases where you

00:20:46,740 --> 00:20:50,130
have to insert a lot of object without

00:20:48,720 --> 00:20:53,520
the base or updated at home to the

00:20:50,130 --> 00:20:56,310
database for those cases in jag 1.4

00:20:53,520 --> 00:21:01,650
there is a new function in the equation

00:20:56,310 --> 00:21:04,020
set API code bulk create bank raid and

00:21:01,650 --> 00:21:08,250
just inserts a lot of documents in one

00:21:04,020 --> 00:21:11,210
go the catch is that for those of you

00:21:08,250 --> 00:21:16,530
who are who depend on the post save

00:21:11,210 --> 00:21:19,620
modal signals they won't get cold either

00:21:16,530 --> 00:21:21,360
with the same method but okay so and

00:21:19,620 --> 00:21:23,880
this is the most one of the most

00:21:21,360 --> 00:21:28,680
efficient ways to do barking search the

00:21:23,880 --> 00:21:31,980
database there is another packet that we

00:21:28,680 --> 00:21:34,350
use which called Jungle bulk which does

00:21:31,980 --> 00:21:42,210
the same thing for previous verses of

00:21:34,350 --> 00:21:45,090
Jango but used on your own bill also in

00:21:42,210 --> 00:21:46,950
case of barking search the database for

00:21:45,090 --> 00:21:50,820
postgresql by the way we'll use postage

00:21:46,950 --> 00:21:53,970
scale in case you hadn't noticed there

00:21:50,820 --> 00:21:56,520
is a function from posters code copy and

00:21:53,970 --> 00:22:00,140
cop is the most efficient way impose the

00:21:56,520 --> 00:22:00,140
squirrel to insert stuff to the database

00:22:00,260 --> 00:22:08,900
like that the psyche of G module which

00:22:03,410 --> 00:22:11,180
is for Django allows you to have to use

00:22:08,900 --> 00:22:16,010
that function from within by the Python

00:22:11,180 --> 00:22:18,950
API speaking about coping remaining to

00:22:16,010 --> 00:22:20,630
say that when you want to scale when you

00:22:18,950 --> 00:22:22,220
want to grow your web application you

00:22:20,630 --> 00:22:24,440
have to take advantage of the database

00:22:22,220 --> 00:22:27,320
you have the advance of what it's tool

00:22:24,440 --> 00:22:29,210
you provide its tool you use provides I

00:22:27,320 --> 00:22:31,370
mean there's no point in using a

00:22:29,210 --> 00:22:33,950
database on trying to be as generic as

00:22:31,370 --> 00:22:37,730
possible or any other tool for that for

00:22:33,950 --> 00:22:40,640
that particular case if you run a

00:22:37,730 --> 00:22:43,670
business just use the poultice specific

00:22:40,640 --> 00:22:45,110
things and don't care about a migration

00:22:43,670 --> 00:22:50,300
to my spell this will never have

00:22:45,110 --> 00:22:57,140
probably okay next topic here is the

00:22:50,300 --> 00:23:02,690
normalization this is the definition

00:22:57,140 --> 00:23:04,580
provided by Wikipedia basically I don't

00:23:02,690 --> 00:23:08,180
know how many of you know of normal

00:23:04,580 --> 00:23:10,430
forms in SQL but the the goal of the

00:23:08,180 --> 00:23:13,240
norm of normalizing a database is to

00:23:10,430 --> 00:23:16,190
eliminate any duplication of information

00:23:13,240 --> 00:23:17,840
the goal is to have only one place where

00:23:16,190 --> 00:23:22,580
you stored data where you store specific

00:23:17,840 --> 00:23:26,030
a specific piece of data I think is that

00:23:22,580 --> 00:23:28,070
this does work very well sometimes when

00:23:26,030 --> 00:23:30,730
having to read from the database because

00:23:28,070 --> 00:23:33,770
at the baseball were basically written

00:23:30,730 --> 00:23:35,600
mostly for write down for I transactions

00:23:33,770 --> 00:23:38,890
in order to write as fast as possible it

00:23:35,600 --> 00:23:42,740
won't optimized to read from the so so

00:23:38,890 --> 00:23:44,000
normalization has to go that since every

00:23:42,740 --> 00:23:45,980
piece of data is every piece of

00:23:44,000 --> 00:23:48,470
information is only shot once in one

00:23:45,980 --> 00:23:50,330
place it is very stop dating whenever

00:23:48,470 --> 00:23:54,020
you have two dated you have a bit only

00:23:50,330 --> 00:23:56,930
in one place in organization is a

00:23:54,020 --> 00:23:59,120
process to relax that those constraints

00:23:56,930 --> 00:24:03,550
it had some excellent piece of red

00:23:59,120 --> 00:24:06,770
dotted see so that so that to make

00:24:03,550 --> 00:24:11,480
rating from the from database a little

00:24:06,770 --> 00:24:12,950
bit faster by the way dinner the

00:24:11,480 --> 00:24:14,070
normalization is a completely different

00:24:12,950 --> 00:24:16,220
thing from non-normalized

00:24:14,070 --> 00:24:18,600
asian na normalization is something that

00:24:16,220 --> 00:24:21,450
it's just not a normalized normalization

00:24:18,600 --> 00:24:24,450
cause specific goals Pacific their

00:24:21,450 --> 00:24:26,880
specific goal in mind of what you want

00:24:24,450 --> 00:24:32,400
to achieve and specific ways of how

00:24:26,880 --> 00:24:34,200
you're going to achieve that well so the

00:24:32,400 --> 00:24:36,060
normalization in case you have read only

00:24:34,200 --> 00:24:44,220
data you can you could you are free to

00:24:36,060 --> 00:24:48,030
use the normalization things to read

00:24:44,220 --> 00:24:49,500
only that a lot of data at all ever the

00:24:48,030 --> 00:24:50,850
only thing that costs you using the

00:24:49,500 --> 00:24:54,690
normalization this particular case is

00:24:50,850 --> 00:24:56,910
some extra is increasing the size of

00:24:54,690 --> 00:24:59,700
your database but you can talk about

00:24:56,910 --> 00:25:02,340
efficiency and breathing fast values

00:24:59,700 --> 00:25:06,900
from there fast that's not that's not

00:25:02,340 --> 00:25:11,010
your biggest problem for instance in

00:25:06,900 --> 00:25:12,900
transfix there is a particular table

00:25:11,010 --> 00:25:15,540
that we always got to join through

00:25:12,900 --> 00:25:18,030
another one to fetch the results just

00:25:15,540 --> 00:25:20,400
noting the the other tips I'd be a

00:25:18,030 --> 00:25:22,290
foreign key to the other table which was

00:25:20,400 --> 00:25:24,780
a read-only query dramatically

00:25:22,290 --> 00:25:32,720
eliminated eliminated a lot of lot of

00:25:24,780 --> 00:25:38,370
issues with that particular model x step

00:25:32,720 --> 00:25:42,450
is a meta options or drink attribute in

00:25:38,370 --> 00:25:45,030
jungle you can provide in the metaclass

00:25:42,450 --> 00:25:47,610
of a model you can have an attitude

00:25:45,030 --> 00:25:49,220
cause or drink which specifies what is

00:25:47,610 --> 00:25:51,210
the default which is the default

00:25:49,220 --> 00:25:55,170
ordering when you do quiz to the

00:25:51,210 --> 00:25:59,430
database yeah don't use that that is

00:25:55,170 --> 00:26:01,950
that's my advice we we will end up doing

00:25:59,430 --> 00:26:04,020
things like that here I'm just trying to

00:26:01,950 --> 00:26:06,600
delete all to-do items that belong to me

00:26:04,020 --> 00:26:08,430
and this results in another bite I don't

00:26:06,600 --> 00:26:11,210
have it and this results in order by

00:26:08,430 --> 00:26:14,340
which is every time I try to do anything

00:26:11,210 --> 00:26:16,050
I have two other an expressive daughter

00:26:14,340 --> 00:26:18,900
by without any arguments in order to

00:26:16,050 --> 00:26:22,080
clear that before or during which is

00:26:18,900 --> 00:26:24,240
tedious it beats a purse it beats a

00:26:22,080 --> 00:26:26,200
purpose it's better in my opinion at

00:26:24,240 --> 00:26:31,120
least better to be expression

00:26:26,200 --> 00:26:32,830
implicit just that the other by who in

00:26:31,120 --> 00:26:37,000
the exact places you want them you won't

00:26:32,830 --> 00:26:39,370
plug you actually need it okay that was

00:26:37,000 --> 00:26:42,580
basically for the RM some a few tips

00:26:39,370 --> 00:26:47,590
from the voice of API next step let's

00:26:42,580 --> 00:26:51,820
talk a bit about caching okay first of

00:26:47,590 --> 00:26:54,370
all regarding sessions the default back

00:26:51,820 --> 00:26:56,590
end in Django four sessions is that it's

00:26:54,370 --> 00:27:00,100
used my database for that which is

00:26:56,590 --> 00:27:02,320
obviously not a patient now there are

00:27:00,100 --> 00:27:05,680
other there are other backends like

00:27:02,320 --> 00:27:07,570
using them memphis dior yeah there's

00:27:05,680 --> 00:27:08,950
another one for using files particle

00:27:07,570 --> 00:27:12,070
correctly but that's not the patient

00:27:08,950 --> 00:27:13,870
either but there are others that can use

00:27:12,070 --> 00:27:15,070
the memcache before that so you don't

00:27:13,870 --> 00:27:19,860
have to the killer database on let's

00:27:15,070 --> 00:27:22,120
request in jag 1.4 if i recall correctly

00:27:19,860 --> 00:27:24,280
there was added support for signed

00:27:22,120 --> 00:27:26,820
cookies which you can also use so you

00:27:24,280 --> 00:27:29,410
don't have to use any session session so

00:27:26,820 --> 00:27:37,090
sorry the database of them testing for

00:27:29,410 --> 00:27:39,760
that another hidden feature of Django is

00:27:37,090 --> 00:27:42,820
that you can pre compile all all

00:27:39,760 --> 00:27:46,180
templates so you so that whenever FG is

00:27:42,820 --> 00:27:49,210
executed you don't pass the debate again

00:27:46,180 --> 00:27:51,810
compile it substituted the great advice

00:27:49,210 --> 00:27:54,790
to that I use that there is a way to

00:27:51,810 --> 00:27:58,750
instruct Django to have the pleasure

00:27:54,790 --> 00:28:00,910
always compile so that when one of you

00:27:58,750 --> 00:28:02,830
is executed and to play this has to be

00:28:00,910 --> 00:28:05,980
populated the only thing that gets done

00:28:02,830 --> 00:28:08,860
that gets executed is to just replace

00:28:05,980 --> 00:28:12,640
the correct values for the varieties one

00:28:08,860 --> 00:28:17,650
goes with that is that if you define or

00:28:12,640 --> 00:28:20,050
use custom notes you have to be very

00:28:17,650 --> 00:28:22,090
careful not to use any state in those

00:28:20,050 --> 00:28:25,360
nodes I don't know how many of you have

00:28:22,090 --> 00:28:27,790
written like a custom node for the plate

00:28:25,360 --> 00:28:29,380
but the way you do it is that there's an

00:28:27,790 --> 00:28:31,120
initializer and there's a render

00:28:29,380 --> 00:28:33,130
function but then it's a laser is called

00:28:31,120 --> 00:28:36,730
when compiling with the plate the red

00:28:33,130 --> 00:28:38,080
faction is called one actually showing

00:28:36,730 --> 00:28:42,880
that the plate to the

00:28:38,080 --> 00:28:47,890
since with sings by having the templates

00:28:42,880 --> 00:28:49,659
precompiled compiled only once in eight

00:28:47,890 --> 00:28:51,880
packs will only be good one so if you

00:28:49,659 --> 00:28:54,370
have any stating that it could be

00:28:51,880 --> 00:29:00,370
propagated to all codes which you

00:28:54,370 --> 00:29:05,769
probably don't want to do that other

00:29:00,370 --> 00:29:08,529
thing here is about the antitoxin the

00:29:05,769 --> 00:29:11,399
last modified date this is actually a an

00:29:08,529 --> 00:29:14,440
ICP this is a part of the HTTP protocol

00:29:11,399 --> 00:29:18,100
HTTP has a lot a big section about

00:29:14,440 --> 00:29:21,399
caching part of that is that is the

00:29:18,100 --> 00:29:23,740
entity tag section which says that for

00:29:21,399 --> 00:29:27,490
its request and response you can specify

00:29:23,740 --> 00:29:29,350
specific identity tag which is whatever

00:29:27,490 --> 00:29:31,539
with it does matter what it is actually

00:29:29,350 --> 00:29:35,169
the value what the value is it can be

00:29:31,539 --> 00:29:38,529
anything a simple string or you can you

00:29:35,169 --> 00:29:41,370
can specify the last modified date so

00:29:38,529 --> 00:29:44,679
when the browser sends a query to you

00:29:41,370 --> 00:29:47,289
you if you use the entity types or the

00:29:44,679 --> 00:29:48,909
last 25 days general can just check you

00:29:47,289 --> 00:29:52,029
can you can have a function that just

00:29:48,909 --> 00:29:53,380
checks the value of those two things

00:29:52,029 --> 00:29:55,659
either the entity that got the last

00:29:53,380 --> 00:29:58,539
modified date and depending on that

00:29:55,659 --> 00:30:00,309
value either return it 30 for status

00:29:58,539 --> 00:30:02,100
code to the browser which means that

00:30:00,309 --> 00:30:06,149
nothing has changed just use the cash

00:30:02,100 --> 00:30:09,820
don't bother me with any requests or

00:30:06,149 --> 00:30:12,639
actually send an updated result the

00:30:09,820 --> 00:30:14,649
thing is that this is only worthy if it

00:30:12,639 --> 00:30:17,019
is easier to calculate the enthalpy of

00:30:14,649 --> 00:30:22,330
the last modified date I mean there's no

00:30:17,019 --> 00:30:24,460
point in trying to fred's in doing

00:30:22,330 --> 00:30:27,159
something is expensive to find when when

00:30:24,460 --> 00:30:29,799
a node it was last modified where you

00:30:27,159 --> 00:30:32,500
could just return that object itself on

00:30:29,799 --> 00:30:34,419
the other hand what what using the 304

00:30:32,500 --> 00:30:36,490
source code actually surgeries bandwidth

00:30:34,419 --> 00:30:39,130
because you only send a three or four

00:30:36,490 --> 00:30:40,929
responds with no body and it can save

00:30:39,130 --> 00:30:44,039
you from actually calculating the call

00:30:40,929 --> 00:30:44,039
Nicole response

00:30:49,899 --> 00:30:58,100
yep for instance this is particularly

00:30:53,210 --> 00:31:00,200
useful for static pages for pages which

00:30:58,100 --> 00:31:02,239
don't change enough for instance the

00:31:00,200 --> 00:31:06,019
about page of the project since this is

00:31:02,239 --> 00:31:09,649
mostly static key changes are dumped how

00:31:06,019 --> 00:31:15,259
often is that can change what you could

00:31:09,649 --> 00:31:17,600
do is just add the having the cars are

00:31:15,259 --> 00:31:18,979
in red so whatever a simple key that

00:31:17,600 --> 00:31:21,409
says when one that page was last

00:31:18,979 --> 00:31:22,970
modified or just provide an ID tag there

00:31:21,409 --> 00:31:24,859
so whenever request comes for static

00:31:22,970 --> 00:31:28,940
page you just check your cash which

00:31:24,859 --> 00:31:31,340
pretty fast find the 304 coat check if

00:31:28,940 --> 00:31:36,639
this is if there's an updated note and

00:31:31,340 --> 00:31:39,169
just reply to that the only okay it is

00:31:36,639 --> 00:31:40,879
the only problem with her with this

00:31:39,169 --> 00:31:43,940
thing is how do you can personalize

00:31:40,879 --> 00:31:46,129
pages I mean if the investor page asim

00:31:43,940 --> 00:31:50,239
page that says that at the top that's

00:31:46,129 --> 00:31:56,090
the header and says okay John how are

00:31:50,239 --> 00:32:00,139
you today yeah having personalized pages

00:31:56,090 --> 00:32:03,289
is it is a bit account is a bit against

00:32:00,139 --> 00:32:06,259
having cast pages because they're so

00:32:03,289 --> 00:32:07,789
expensive might need to provide provide

00:32:06,259 --> 00:32:10,970
some updated information like extra

00:32:07,789 --> 00:32:14,239
staff that cannot be cast for all one

00:32:10,970 --> 00:32:15,619
way to feed that is to move some of the

00:32:14,239 --> 00:32:18,349
personalization some of the customer

00:32:15,619 --> 00:32:25,220
customization to the client but by using

00:32:18,349 --> 00:32:26,629
javascript so know if the only thing in

00:32:25,220 --> 00:32:28,609
your static page that change between

00:32:26,629 --> 00:32:30,799
users or whatever it's just big user

00:32:28,609 --> 00:32:32,779
name at the top you could have that user

00:32:30,799 --> 00:32:35,840
name sewn by javascript instead of

00:32:32,779 --> 00:32:38,389
having the actual page the actual

00:32:35,840 --> 00:32:40,190
response having the correct username so

00:32:38,389 --> 00:32:42,799
you can obviously kind of hero for code

00:32:40,190 --> 00:32:45,080
or even a return response from cass and

00:32:42,799 --> 00:32:52,700
coverage javascript do the extra

00:32:45,080 --> 00:32:56,310
personalization that is needed okay the

00:32:52,700 --> 00:32:58,110
next step is about yeah

00:32:56,310 --> 00:33:00,450
let me just add that there's a whole

00:32:58,110 --> 00:33:03,240
section in a basically protocol about

00:33:00,450 --> 00:33:06,270
caching there are very scary that you

00:33:03,240 --> 00:33:10,080
can use for that and by the way I

00:33:06,270 --> 00:33:13,050
whatever good part is that between the

00:33:10,080 --> 00:33:15,900
client and you and your server there

00:33:13,050 --> 00:33:18,120
could be a lot of extra proxies I like

00:33:15,900 --> 00:33:19,800
that that can handle the three or four

00:33:18,120 --> 00:33:21,600
stops cold so using for your first

00:33:19,800 --> 00:33:24,060
thoughts codes might have been such

00:33:21,600 --> 00:33:25,890
cases so that the proxy can just return

00:33:24,060 --> 00:33:30,630
quickly a response and it might not even

00:33:25,890 --> 00:33:38,700
get to you so next type optimizing

00:33:30,630 --> 00:33:40,140
algorithms okay actually yeah optimizing

00:33:38,700 --> 00:33:42,030
your SQL queries is the first step

00:33:40,140 --> 00:33:43,860
because with jungle they they play the

00:33:42,030 --> 00:33:47,430
jungle provides it's very easy to do

00:33:43,860 --> 00:33:50,610
some silly mistakes things that they are

00:33:47,430 --> 00:33:53,700
very easy to miss but ok there are tools

00:33:50,610 --> 00:33:55,260
for that you can actually find them with

00:33:53,700 --> 00:33:59,700
Chang debug tool belt check the queries

00:33:55,260 --> 00:34:03,090
and fix those gassing is a whole other

00:33:59,700 --> 00:34:07,140
thing you see that I am problem here

00:34:03,090 --> 00:34:09,000
perform here I just cast it and done but

00:34:07,140 --> 00:34:10,500
there's another class of problems which

00:34:09,000 --> 00:34:15,920
about the album's you use it themselves

00:34:10,500 --> 00:34:20,250
and sometimes they are the biggest

00:34:15,920 --> 00:34:22,110
hurdle for instance in transfix we've

00:34:20,250 --> 00:34:24,680
got the more or less the above kind of

00:34:22,110 --> 00:34:29,700
code let's say that you covet earnestly

00:34:24,680 --> 00:34:32,100
translations leaf which just has a cache

00:34:29,700 --> 00:34:34,650
and at the five cows and on the string

00:34:32,100 --> 00:34:35,700
by the way transfix is a localization of

00:34:34,650 --> 00:34:38,790
management platform that's why the

00:34:35,700 --> 00:34:41,010
relative translations so I grabbed so

00:34:38,790 --> 00:34:45,000
yeah you have a cache and you have a

00:34:41,010 --> 00:34:48,810
string and there's also the text where

00:34:45,000 --> 00:34:50,760
we have replaced its its appearance of

00:34:48,810 --> 00:34:52,650
the string with the house so that we

00:34:50,760 --> 00:34:55,290
know what it's got word string belongs

00:34:52,650 --> 00:34:56,730
to in the within the text so that we can

00:34:55,290 --> 00:34:59,880
use translations instead of the actual

00:34:56,730 --> 00:35:01,830
string so this how it would work this

00:34:59,880 --> 00:35:04,250
how you would get a translating fight

00:35:01,830 --> 00:35:07,350
back it will go over the translations

00:35:04,250 --> 00:35:09,869
and it would replace the house with a

00:35:07,350 --> 00:35:12,900
translated string

00:35:09,869 --> 00:35:15,359
however at some point this failed for

00:35:12,900 --> 00:35:18,420
someone tried to upload a very big file

00:35:15,359 --> 00:35:22,650
thousands of entries and it was quite

00:35:18,420 --> 00:35:26,069
slow so we have to go over this and try

00:35:22,650 --> 00:35:29,759
to make this as fast as possible the

00:35:26,069 --> 00:35:32,130
first thing to notice here is that we do

00:35:29,759 --> 00:35:34,140
a simple replacement there in the second

00:35:32,130 --> 00:35:37,559
line and however will use regular

00:35:34,140 --> 00:35:40,380
expressions which is we don't actually

00:35:37,559 --> 00:35:42,089
use in the actual line of calculators

00:35:40,380 --> 00:35:45,210
and a regular expressions however we use

00:35:42,089 --> 00:35:47,160
the regular expression module instead we

00:35:45,210 --> 00:35:50,039
could easily use the text dr. place at

00:35:47,160 --> 00:35:53,099
the sorry this they replace method of

00:35:50,039 --> 00:35:59,009
the string object of string object and I

00:35:53,099 --> 00:36:02,130
do it that way hey but when i run the

00:35:59,009 --> 00:36:04,529
exams i had a very big file of tens of

00:36:02,130 --> 00:36:08,309
thousands of entries and just by using

00:36:04,529 --> 00:36:11,400
that the replace method for the text it

00:36:08,309 --> 00:36:15,029
cut down the rank time your health with

00:36:11,400 --> 00:36:19,499
a pretty big improvement however that

00:36:15,029 --> 00:36:23,940
wasn't good enough yet so it turns out

00:36:19,499 --> 00:36:27,559
that the sub method of the remote of the

00:36:23,940 --> 00:36:31,650
regular expression module can accept a

00:36:27,559 --> 00:36:35,579
function which tells it what to what we

00:36:31,650 --> 00:36:38,130
used to replace the maths object with so

00:36:35,579 --> 00:36:40,710
instead of having a dictionary instead

00:36:38,130 --> 00:36:43,200
of going to operates translation and the

00:36:40,710 --> 00:36:47,190
reflects giving the text what we end up

00:36:43,200 --> 00:36:49,259
do is to just create a regular

00:36:47,190 --> 00:36:51,420
expression for all the md5 classes and

00:36:49,259 --> 00:36:54,890
whatever it must hear it will go over

00:36:51,420 --> 00:37:00,239
the dictionary return the correct value

00:36:54,890 --> 00:37:04,339
I'm yeah but this reduce the rank time

00:37:00,239 --> 00:37:07,019
are from 80 seconds to 2 or something

00:37:04,339 --> 00:37:10,259
why is that in the first case we would

00:37:07,019 --> 00:37:13,109
have to go over over the text would have

00:37:10,259 --> 00:37:17,029
to iterate over the over the last three

00:37:13,109 --> 00:37:19,950
texts a condom however many times

00:37:17,029 --> 00:37:22,259
however many translation we have so it

00:37:19,950 --> 00:37:23,520
was enacted to run over the text n times

00:37:22,259 --> 00:37:25,140
instead of just once

00:37:23,520 --> 00:37:28,290
well the second case we run over the

00:37:25,140 --> 00:37:30,870
text that's not just yeah just once and

00:37:28,290 --> 00:37:33,960
that's what they bring this from the

00:37:30,870 --> 00:37:35,940
bottom line is that specifically do

00:37:33,960 --> 00:37:38,520
anything more complicated than just

00:37:35,940 --> 00:37:40,950
simply selling some objects in your view

00:37:38,520 --> 00:37:43,500
you have to be very careful at what

00:37:40,950 --> 00:37:48,030
others you actually use and this is very

00:37:43,500 --> 00:37:51,180
easy to means by the way speaking of

00:37:48,030 --> 00:37:55,650
complicated actions let's talk a bit

00:37:51,180 --> 00:38:00,480
about IO IO in general is very expensive

00:37:55,650 --> 00:38:04,770
because get this car quite slow other

00:38:00,480 --> 00:38:07,020
thing yeah okay I think about I yo is

00:38:04,770 --> 00:38:09,360
that the wedge angle does it actually

00:38:07,020 --> 00:38:12,030
most web applications do it it is that

00:38:09,360 --> 00:38:15,210
is blogging there are two ways where you

00:38:12,030 --> 00:38:16,590
can go around this restriction the first

00:38:15,210 --> 00:38:20,100
nice to use thread for i/o so if you

00:38:16,590 --> 00:38:21,570
have i oh that many os many i/o

00:38:20,100 --> 00:38:24,360
operations which are independent of each

00:38:21,570 --> 00:38:25,650
other and they are taking a lot of time

00:38:24,360 --> 00:38:27,930
you could use thread so that you can

00:38:25,650 --> 00:38:30,420
send them in parallel forensic Python

00:38:27,930 --> 00:38:31,740
are actually bid for i/o so it's

00:38:30,420 --> 00:38:34,800
educating its thread in this particular

00:38:31,740 --> 00:38:38,070
case the other thing you could do is to

00:38:34,800 --> 00:38:41,310
use a synchronous i/o of course I'm not

00:38:38,070 --> 00:38:43,710
quite sure this is not a specific

00:38:41,310 --> 00:38:45,720
purdue's because views are different

00:38:43,710 --> 00:38:47,130
kind of thing but if you have any

00:38:45,720 --> 00:38:48,660
background operations and in background

00:38:47,130 --> 00:38:50,190
things that you do you could always just

00:38:48,660 --> 00:38:56,430
use a secret soy yo to make them even

00:38:50,190 --> 00:39:00,560
faster and love I don't know how many of

00:38:56,430 --> 00:39:05,580
you know Pete Jack's which is a

00:39:00,560 --> 00:39:10,290
JavaScript library that github some guys

00:39:05,580 --> 00:39:12,480
from github build in the new version of

00:39:10,290 --> 00:39:17,130
java script and then html5 there is a

00:39:12,480 --> 00:39:21,960
new a new API the history API which

00:39:17,130 --> 00:39:25,620
allows you to have it in JavaScript the

00:39:21,960 --> 00:39:27,000
whole history of the of the sessions and

00:39:25,620 --> 00:39:31,530
if you let the history of your browser

00:39:27,000 --> 00:39:33,360
and this is good Peter's hand this would

00:39:31,530 --> 00:39:36,480
protect us so there is an app for jungle

00:39:33,360 --> 00:39:37,260
called Jango physics which integrates

00:39:36,480 --> 00:39:39,150
pages with

00:39:37,260 --> 00:39:41,310
angle for those of you who don't know

00:39:39,150 --> 00:39:44,490
what pay taxes if you go to kick up and

00:39:41,310 --> 00:39:46,260
you just try to browse over over the

00:39:44,490 --> 00:39:48,090
tree of the search tree and you go to

00:39:46,260 --> 00:39:49,800
follow the link and select that the

00:39:48,090 --> 00:39:52,980
whole thing is done with PGX so this is

00:39:49,800 --> 00:39:56,300
a very good way to provide to give the

00:39:52,980 --> 00:40:05,670
user feeling of not speediness over

00:39:56,300 --> 00:40:08,840
being speedy okay so that was it it will

00:40:05,670 --> 00:40:12,800
a couple of tricks we have legend here

00:40:08,840 --> 00:40:17,220
during developing transfix I hope so

00:40:12,800 --> 00:40:24,660
everybody learn something new thank you

00:40:17,220 --> 00:40:31,320
very much it's really interesting does

00:40:24,660 --> 00:40:34,040
someone have any questions I think that

00:40:31,320 --> 00:40:39,330
I actually have a question to ask you

00:40:34,040 --> 00:40:42,870
know what i was seeing before is that

00:40:39,330 --> 00:40:45,420
you are also speaking about pj acts in

00:40:42,870 --> 00:40:47,010
fact i have seen it myself but i have

00:40:45,420 --> 00:40:50,190
not understood perfectly the way it

00:40:47,010 --> 00:40:51,960
actually works i know it uses Ajax but

00:40:50,190 --> 00:40:55,740
if you could tell me more about it yeah

00:40:51,960 --> 00:40:58,080
well basically in the newer versions in

00:40:55,740 --> 00:40:59,940
html5 there is a new JavaScript API

00:40:58,080 --> 00:41:01,380
which allows you to manipulate the

00:40:59,940 --> 00:41:05,160
history itself there are a couple of

00:41:01,380 --> 00:41:07,680
functions to state a pope status are

00:41:05,160 --> 00:41:09,720
like that so there's something like is

00:41:07,680 --> 00:41:13,110
that object and you push pages and

00:41:09,720 --> 00:41:17,580
Pope's pages where so this means that

00:41:13,110 --> 00:41:20,130
you are able to change the actual is

00:41:17,580 --> 00:41:22,200
basically ajax ajax goals but you can

00:41:20,130 --> 00:41:26,430
manipulate the location bar in your

00:41:22,200 --> 00:41:28,620
browser to show a different page and so

00:41:26,430 --> 00:41:30,930
it is whatever you follow a link or go

00:41:28,620 --> 00:41:33,660
back up to the back button it works

00:41:30,930 --> 00:41:36,750
because it just pops the previous

00:41:33,660 --> 00:41:39,630
configuration of the page so you don't

00:41:36,750 --> 00:41:40,950
do any extra clothes because using the

00:41:39,630 --> 00:41:43,380
back button works and that was a big

00:41:40,950 --> 00:41:45,410
problem with regex goals but the bug

00:41:43,380 --> 00:41:48,870
battle didn't work and with the basics

00:41:45,410 --> 00:41:50,730
with the history API to be precise this

00:41:48,870 --> 00:41:52,680
works you just press the back button

00:41:50,730 --> 00:41:55,740
you pop the state in your JavaScript and

00:41:52,680 --> 00:42:00,390
it works ansys and one less thing and

00:41:55,740 --> 00:42:04,050
since since this is different URL you

00:42:00,390 --> 00:42:06,030
can also serve normal hitch to that

00:42:04,050 --> 00:42:09,240
particular URL if it's not the pit x

00:42:06,030 --> 00:42:11,100
request we just serve the whole page so

00:42:09,240 --> 00:42:14,160
it can be the Bates can be bookmark oh

00:42:11,100 --> 00:42:16,560
my gosh have you ever seen backbone GS

00:42:14,160 --> 00:42:18,450
yeah its backbone it's a really really

00:42:16,560 --> 00:42:21,300
good library which has also all this

00:42:18,450 --> 00:42:23,160
history put together I don't know if

00:42:21,300 --> 00:42:26,340
they exist but I think there is some

00:42:23,160 --> 00:42:30,530
sort of plug-in for Django which handles

00:42:26,340 --> 00:42:34,940
both backbone on front-end and back-end

00:42:30,530 --> 00:42:37,320
yeah but it's really good if if you ever

00:42:34,940 --> 00:42:42,410
happen to see it please try it because

00:42:37,320 --> 00:42:42,410
it's really good and thank you very much

00:42:47,440 --> 00:42:59,050
I spoke to be the first boy I for the

00:42:55,720 --> 00:43:01,810
tears really yeah I guess they like the

00:42:59,050 --> 00:43:04,119
 do you / in fact you have can I

00:43:01,810 --> 00:43:06,460
knew past media somehow they're like

00:43:04,119 --> 00:43:10,450
yeah of course how can you pass me do

00:43:06,460 --> 00:43:14,140
you have a no just depend no I can't

00:43:10,450 --> 00:43:16,630
send them by bein yes yes right because

00:43:14,140 --> 00:43:19,270
as I am managing I always have to

00:43:16,630 --> 00:43:21,760
do this this this but I didn't have time

00:43:19,270 --> 00:43:23,560
to read all of it but I would like to

00:43:21,760 --> 00:43:46,599
have the possibility see them more at

00:43:23,560 --> 00:43:49,920
home my email is the fact some are some

00:43:46,599 --> 00:43:52,900
subjects you introduce but you don't go

00:43:49,920 --> 00:43:54,819
execution going all of them I'm not

00:43:52,900 --> 00:43:57,310
saying that you have to go in talion

00:43:54,819 --> 00:44:01,690
that further what you can do is like

00:43:57,310 --> 00:44:05,530
some some things you where's the 21

00:44:01,690 --> 00:44:10,079
hyphen like v JX I you know I read it

00:44:05,530 --> 00:44:10,079
but I i was in order to know more

00:44:15,270 --> 00:44:22,890
roll assign me confirmo que todo lasagna

00:44:19,480 --> 00:44:22,890

YouTube URL: https://www.youtube.com/watch?v=wmimppnIfLY


