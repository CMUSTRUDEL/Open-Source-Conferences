Title: Python for finance part 1
Publication date: 2015-04-19
Playlist: EuroPython 2012
Description: 
	[EuroPython 2012] Y Hilpisch - 6 JULY 2012 in "Track Pizza Margherita"
Captions: 
	00:01:51,009 --> 00:01:54,790
thank you good morning everybody

00:01:56,530 --> 00:02:00,770
this is my name is Eve I'm found the

00:01:59,060 --> 00:02:03,229
managing director of physician GmbH we

00:02:00,770 --> 00:02:05,360
are German company and our main topic is

00:02:03,229 --> 00:02:08,780
finance and for that we use pies and a

00:02:05,360 --> 00:02:11,120
lot we've developed commercial

00:02:08,780 --> 00:02:12,709
derivatives analytics suite which is

00:02:11,120 --> 00:02:14,209
available on the web if you visit our

00:02:12,709 --> 00:02:16,930
website and this is the first thing I

00:02:14,209 --> 00:02:21,440
want to do with you to go to our website

00:02:16,930 --> 00:02:23,900
w-w-w-whoa it is readable if not here's

00:02:21,440 --> 00:02:26,890
position again but come there you find

00:02:23,900 --> 00:02:29,299
the link I show it on the website just

00:02:26,890 --> 00:02:31,070
give me a second

00:02:29,299 --> 00:02:33,799
on the first page you find something

00:02:31,070 --> 00:02:36,320
like Europe Ison 2012 if you follow this

00:02:33,799 --> 00:02:39,260
link you will find another one which

00:02:36,320 --> 00:02:41,570
leads you to all the material that I

00:02:39,260 --> 00:02:45,590
will present today you will find the

00:02:41,570 --> 00:02:48,250
link I would do it for you with you if

00:02:45,590 --> 00:02:51,170
you follow the Europe highs in 2012 link

00:02:48,250 --> 00:02:54,290
you find a number of words what we are

00:02:51,170 --> 00:02:58,100
doing here and you fund by the way the

00:02:54,290 --> 00:02:59,600
slides I presented yesterday in the talk

00:02:58,100 --> 00:03:03,739
fast data mining with panels and pay

00:02:59,600 --> 00:03:07,310
tables and you also find a link leading

00:03:03,739 --> 00:03:10,430
you to the training slides if you

00:03:07,310 --> 00:03:11,480
download them it is a zip file and it's

00:03:10,430 --> 00:03:16,510
password-protected

00:03:11,480 --> 00:03:20,480
the password is simply Europe Ison 2012

00:03:16,510 --> 00:03:23,510
in one word the e in capital and the P

00:03:20,480 --> 00:03:25,740
in capital letters so if you have that

00:03:23,510 --> 00:03:28,200
you have everything you need for today

00:03:25,740 --> 00:03:32,210
if there's anybody having trouble with

00:03:28,200 --> 00:03:34,650
it just raise your hand and I like that

00:03:32,210 --> 00:03:38,250
it's written over there the password is

00:03:34,650 --> 00:03:41,720
Europe isin 2012 written in this way

00:03:38,250 --> 00:03:55,770
no slash nothing just one word and

00:03:41,720 --> 00:03:56,850
capital e capital P well first of all

00:03:55,770 --> 00:03:59,610
before we start is a little bit

00:03:56,850 --> 00:04:01,500
difficult to design a training which has

00:03:59,610 --> 00:04:03,510
a technical or industry background like

00:04:01,500 --> 00:04:05,580
finance because you don't know how what

00:04:03,510 --> 00:04:07,890
people you will confront in the training

00:04:05,580 --> 00:04:11,420
so first of all I want to ask question

00:04:07,890 --> 00:04:13,980
who of you has a background in finance

00:04:11,420 --> 00:04:15,960
working for example for bang going

00:04:13,980 --> 00:04:26,250
derivatives analytics or somewhere else

00:04:15,960 --> 00:04:30,090
oh it's only finance is quite large

00:04:26,250 --> 00:04:31,320
field yes I know that so this is even

00:04:30,090 --> 00:04:33,150
though specified when I talk about

00:04:31,320 --> 00:04:35,960
finance usually this mathematical

00:04:33,150 --> 00:04:37,880
finance it's more like oriented towards

00:04:35,960 --> 00:04:41,610
derivatives models and so forth

00:04:37,880 --> 00:04:44,010
simulation and that kind of stuff but I

00:04:41,610 --> 00:04:46,890
have also brought something which is

00:04:44,010 --> 00:04:48,630
more from a product context but the

00:04:46,890 --> 00:04:50,550
other of you you have more developer

00:04:48,630 --> 00:04:55,460
background or what what is your

00:04:50,550 --> 00:04:55,460
background maybe you can show some hints

00:04:56,150 --> 00:05:04,230
ok well this is quite but this is fine

00:05:01,010 --> 00:05:06,480
wonderful background so adding a little

00:05:04,230 --> 00:05:11,910
bit of finding theory it looks mainly

00:05:06,480 --> 00:05:13,380
the same I hope but the the focus will

00:05:11,910 --> 00:05:16,080
be on pison of course and how to

00:05:13,380 --> 00:05:18,240
implement stuff it is really a large

00:05:16,080 --> 00:05:21,590
again the broad words you see there are

00:05:18,240 --> 00:05:21,590
96 lights in it

00:05:23,270 --> 00:05:28,380
I've tried to structure it the following

00:05:25,860 --> 00:05:32,190
way I will start with some useful Python

00:05:28,380 --> 00:05:33,930
libraries for finance then I will play

00:05:32,190 --> 00:05:36,930
from my point of view the foundation

00:05:33,930 --> 00:05:38,950
with the the use of numpy then I

00:05:36,930 --> 00:05:41,350
represent how to implement

00:05:38,950 --> 00:05:52,260
that's quite loud isn't it on the other

00:05:41,350 --> 00:05:54,850
room it's actually lighter than me yeah

00:05:52,260 --> 00:05:59,820
because I don't have any of those fear

00:05:54,850 --> 00:06:01,900
sorry I think someone is already gonna

00:05:59,820 --> 00:06:05,050
at this part of it just briefly

00:06:01,900 --> 00:06:07,210
illustrate where some America topics

00:06:05,050 --> 00:06:10,360
which in my face when you work with such

00:06:07,210 --> 00:06:13,300
stuff I will have some bigger case

00:06:10,360 --> 00:06:15,610
studies which I've considered too large

00:06:13,300 --> 00:06:18,340
to do like in the training but the one

00:06:15,610 --> 00:06:21,400
presented I've provided the whole script

00:06:18,340 --> 00:06:23,080
so you can take a look at these clips by

00:06:21,400 --> 00:06:24,160
yourself you can check them you can work

00:06:23,080 --> 00:06:27,100
with them by the way there is no

00:06:24,160 --> 00:06:29,620
guarantee nor representation for the for

00:06:27,100 --> 00:06:31,420
the scripts for there's also no license

00:06:29,620 --> 00:06:34,530
attached to it so you can freely use

00:06:31,420 --> 00:06:37,840
them there's nothing special about it

00:06:34,530 --> 00:06:39,880
and we go on to something we have seen

00:06:37,840 --> 00:06:41,290
in my talk yesterday time series

00:06:39,880 --> 00:06:44,580
analysis with pandas

00:06:41,290 --> 00:06:47,290
I've always included some kind of brief

00:06:44,580 --> 00:06:48,880
exercises and then I want also at the

00:06:47,290 --> 00:06:51,040
case study which is a little bit longer

00:06:48,880 --> 00:06:54,390
and maybe too long to just do it

00:06:51,040 --> 00:06:57,220
together in the training then we have

00:06:54,390 --> 00:06:59,710
something about pie tables how to use

00:06:57,220 --> 00:07:01,870
pie tables beneficially I was a little

00:06:59,710 --> 00:07:03,850
bit surprised yesterday when I asked how

00:07:01,870 --> 00:07:05,740
many people know high tables are there

00:07:03,850 --> 00:07:07,900
only like I don't know five or six

00:07:05,740 --> 00:07:09,400
people raising their hands on my talk in

00:07:07,900 --> 00:07:11,800
comparison to pandas there have been

00:07:09,400 --> 00:07:14,260
more people so this was a little bit

00:07:11,800 --> 00:07:16,150
surprising for me but nevertheless we

00:07:14,260 --> 00:07:18,670
will take a look at it and I will

00:07:16,150 --> 00:07:20,890
present some some stuff with regard to

00:07:18,670 --> 00:07:22,810
how to maybe implement some financial

00:07:20,890 --> 00:07:25,690
projects if you have maybe a research

00:07:22,810 --> 00:07:27,670
background doing research at the

00:07:25,690 --> 00:07:29,470
university or even at corporations this

00:07:27,670 --> 00:07:31,450
could be beneficial for you just to

00:07:29,470 --> 00:07:34,630
close it up I will just present some

00:07:31,450 --> 00:07:36,820
example code how to use Tyson to speed

00:07:34,630 --> 00:07:40,420
up but we have experts in this regard

00:07:36,820 --> 00:07:42,910
here like Mike for example this is not a

00:07:40,420 --> 00:07:44,590
topic of priority for me but I think

00:07:42,910 --> 00:07:47,170
it's a large kind of stuff and if we

00:07:44,590 --> 00:07:48,970
cannot go into detail with regard to the

00:07:47,170 --> 00:07:51,350
one or the other topic then you will

00:07:48,970 --> 00:07:55,010
find everything in the slides

00:07:51,350 --> 00:08:02,300
in the script so don't worry if we don't

00:07:55,010 --> 00:08:04,430
get through it all once again we have a

00:08:02,300 --> 00:08:06,800
number of issues that we want to address

00:08:04,430 --> 00:08:09,410
but I cannot be exhaustive as we got to

00:08:06,800 --> 00:08:11,840
the pison capabilities in this field as

00:08:09,410 --> 00:08:14,530
I said before it's a large field finance

00:08:11,840 --> 00:08:18,260
so we can only touch upon some certain

00:08:14,530 --> 00:08:21,530
things that are important what we want

00:08:18,260 --> 00:08:23,510
to do actually is to provide a first

00:08:21,530 --> 00:08:26,750
impression of pythons advantages for

00:08:23,510 --> 00:08:28,010
pison for example in comparison to C++

00:08:26,750 --> 00:08:32,330
which is still dominating in the

00:08:28,010 --> 00:08:34,760
financial industry everyone like to lead

00:08:32,330 --> 00:08:36,320
you to further study did you say well

00:08:34,760 --> 00:08:38,210
this is interesting for me I didn't

00:08:36,320 --> 00:08:40,610
quite get it in the hole but I can dig

00:08:38,210 --> 00:08:42,800
deeper and figure out how to use it for

00:08:40,610 --> 00:08:45,080
myself as I said the majority of the

00:08:42,800 --> 00:08:46,910
content is secured in slides however I

00:08:45,080 --> 00:08:49,190
have left out something so there are

00:08:46,910 --> 00:08:51,470
three exercises where you won't find two

00:08:49,190 --> 00:08:56,330
solutions in the slides but we can get

00:08:51,470 --> 00:08:59,270
through them together the same slide as

00:08:56,330 --> 00:09:01,790
yesterday I'm not a developer so what we

00:08:59,270 --> 00:09:04,280
do today is not intended to teach you

00:09:01,790 --> 00:09:06,590
how to produce financial code which is

00:09:04,280 --> 00:09:08,180
ready for production it's more like how

00:09:06,590 --> 00:09:12,520
to prototype how to implement financial

00:09:08,180 --> 00:09:14,780
algorithms in Python so things like

00:09:12,520 --> 00:09:17,420
exception handling and so forth

00:09:14,780 --> 00:09:20,210
here you won't find them in the scripts

00:09:17,420 --> 00:09:22,070
it's just like the translation and many

00:09:20,210 --> 00:09:24,680
times the one-to-one translation of

00:09:22,070 --> 00:09:27,080
financial algorithms and aspects into

00:09:24,680 --> 00:09:28,970
Python code so be aware of is when you

00:09:27,080 --> 00:09:31,220
use it in practice but as I said before

00:09:28,970 --> 00:09:34,990
there's no warranty and no

00:09:31,220 --> 00:09:39,050
representation included in the scripts

00:09:34,990 --> 00:09:42,800
to start with and I have included this

00:09:39,050 --> 00:09:44,930
list also in in the description of the

00:09:42,800 --> 00:09:47,120
training and what do we consider as

00:09:44,930 --> 00:09:49,970
important or beneficial libraries for

00:09:47,120 --> 00:09:52,460
finance first of all like the mother of

00:09:49,970 --> 00:09:54,950
everything that we do in scientific

00:09:52,460 --> 00:09:57,710
areas whose prices numpy which you need

00:09:54,950 --> 00:10:00,980
for array operations and I sometimes say

00:09:57,710 --> 00:10:03,139
that finance is nothing else then

00:10:00,980 --> 00:10:04,910
you'll meet them a lot you need them all

00:10:03,139 --> 00:10:07,610
the time and you have to manipulate them

00:10:04,910 --> 00:10:09,260
in a fast manner then scifi a scientific

00:10:07,610 --> 00:10:13,010
library which provides among other

00:10:09,260 --> 00:10:17,019
statistical functions net blood lip if

00:10:13,010 --> 00:10:20,449
you want to generate 2d or 3d figures

00:10:17,019 --> 00:10:23,089
pandas a time series and panel data

00:10:20,449 --> 00:10:26,240
library which facilitates a number of

00:10:23,089 --> 00:10:29,209
data analysis stuffs considerably high

00:10:26,240 --> 00:10:31,760
tables if you need a database which is

00:10:29,209 --> 00:10:33,649
optimized for fast calculations so

00:10:31,760 --> 00:10:35,510
yesterday I said sometimes you have the

00:10:33,649 --> 00:10:37,040
case where maybe your data set doesn't

00:10:35,510 --> 00:10:39,110
fit in the memory but you can

00:10:37,040 --> 00:10:41,600
nevertheless use Paiste high tables to

00:10:39,110 --> 00:10:43,970
implement chess calculations on your

00:10:41,600 --> 00:10:46,040
hard disk and it won't take as long as

00:10:43,970 --> 00:10:48,589
for example vision was in sequel

00:10:46,040 --> 00:10:50,240
database titan if something is too slow

00:10:48,589 --> 00:10:52,730
from your perspective you might take a

00:10:50,240 --> 00:10:54,529
look at sizing add some static typing

00:10:52,730 --> 00:10:56,720
and maybe you can speed it up by a

00:10:54,529 --> 00:10:59,300
factor of 100 or sometimes in some cases

00:10:56,720 --> 00:11:01,490
as example show you can speed Python

00:10:59,300 --> 00:11:04,370
code up like a thousand times compared

00:11:01,490 --> 00:11:07,010
to pure pison but if you do array

00:11:04,370 --> 00:11:08,660
operations right with numpy there's at

00:11:07,010 --> 00:11:12,199
least from our perspective hardly you

00:11:08,660 --> 00:11:14,269
need for the things we would see today -

00:11:12,199 --> 00:11:16,430
well actually library is little bit more

00:11:14,269 --> 00:11:18,410
like a development environment and I

00:11:16,430 --> 00:11:21,110
really enjoy using it in terms of

00:11:18,410 --> 00:11:24,560
interactivity I don't know if you use it

00:11:21,110 --> 00:11:28,160
but I I like to use the Qt console which

00:11:24,560 --> 00:11:31,910
some nice features so for people who are

00:11:28,160 --> 00:11:36,019
used to MATLAB for example they're like

00:11:31,910 --> 00:11:37,519
such interactive person and and notebook

00:11:36,019 --> 00:11:42,019
yes I'll talk is a new thing I don't use

00:11:37,519 --> 00:11:44,660
it yet yeah just to present and I know

00:11:42,019 --> 00:11:47,480
some people change to notebook to

00:11:44,660 --> 00:11:50,389
present stuff which is also something

00:11:47,480 --> 00:11:52,519
from the mathematical world but I'm

00:11:50,389 --> 00:11:54,470
still working with the Kuti console

00:11:52,519 --> 00:11:57,470
shell for your convenience I've included

00:11:54,470 --> 00:11:58,639
in the slides the links you can just

00:11:57,470 --> 00:12:02,170
follow the links if you're missing

00:11:58,639 --> 00:12:04,519
something maybe like pandas for example

00:12:02,170 --> 00:12:07,310
what I also wanted suggest that you

00:12:04,519 --> 00:12:09,470
download maybe the SyFy lecture notes

00:12:07,310 --> 00:12:11,779
they are quite good I know they use them

00:12:09,470 --> 00:12:13,029
at your sci-fi every year and they're

00:12:11,779 --> 00:12:15,790
getting better and better

00:12:13,029 --> 00:12:18,310
so it's nice general introduction to

00:12:15,790 --> 00:12:21,069
paisa from a scientific perspective they

00:12:18,310 --> 00:12:24,579
will find a lot of valuable basic

00:12:21,069 --> 00:12:27,279
information if you are not used to using

00:12:24,579 --> 00:12:31,329
numpy for example just to touch upon one

00:12:27,279 --> 00:12:33,370
topic so people who are more from

00:12:31,329 --> 00:12:36,069
industry background interested in Pais

00:12:33,370 --> 00:12:38,620
and packages and so forth you can you

00:12:36,069 --> 00:12:43,360
might have a look at this link that you

00:12:38,620 --> 00:12:45,730
find typical ordered listed software so

00:12:43,360 --> 00:12:48,040
if you have a special topic in mind you

00:12:45,730 --> 00:12:52,750
might find the solution in this quite

00:12:48,040 --> 00:12:55,540
exhaustive list why do we consider

00:12:52,750 --> 00:12:57,579
pricing good for finance applications as

00:12:55,540 --> 00:12:58,930
I said today Pisan

00:12:57,579 --> 00:13:00,639
is used in the financial services

00:12:58,930 --> 00:13:03,100
industry but for the core applications

00:13:00,639 --> 00:13:07,600
they typically use plus plus and other

00:13:03,100 --> 00:13:10,930
compiled languages I see a major benefit

00:13:07,600 --> 00:13:12,519
in the multi purpose aspect of Pi for

00:13:10,930 --> 00:13:14,259
example if you compare it to MATLAB or

00:13:12,519 --> 00:13:16,660
are they are very good and what they do

00:13:14,259 --> 00:13:19,149
but there are many other fields where

00:13:16,660 --> 00:13:21,399
these packages specialized languages are

00:13:19,149 --> 00:13:22,959
not that good but pison in principle at

00:13:21,399 --> 00:13:26,160
least you can do everything you would

00:13:22,959 --> 00:13:29,639
like to do in terms of generating

00:13:26,160 --> 00:13:33,639
prototypes or even implementing

00:13:29,639 --> 00:13:35,920
production-ready applications the

00:13:33,639 --> 00:13:38,889
productivity I think is much higher

00:13:35,920 --> 00:13:42,819
compared to other languages you can

00:13:38,889 --> 00:13:45,250
seamlessly migrate from from the

00:13:42,819 --> 00:13:47,470
prototype state to the development State

00:13:45,250 --> 00:13:50,079
it is easy to maintain due to its

00:13:47,470 --> 00:13:51,850
compact as a readability I often speak

00:13:50,079 --> 00:13:53,500
to people from investment banks they

00:13:51,850 --> 00:13:56,110
have to maintain like financial models

00:13:53,500 --> 00:13:58,930
consisting of 50 thousand lines of C++

00:13:56,110 --> 00:14:01,120
code keep a change over the years so

00:13:58,930 --> 00:14:02,350
they have like half a year just to

00:14:01,120 --> 00:14:04,240
understand what other peoples have

00:14:02,350 --> 00:14:06,579
implemented and so forth and if you

00:14:04,240 --> 00:14:07,899
consider this one this is only one model

00:14:06,579 --> 00:14:09,939
and they have like hundreds of models

00:14:07,899 --> 00:14:12,639
you can imagine how many lines of code

00:14:09,939 --> 00:14:16,579
C++ code they have to maintain over the

00:14:12,639 --> 00:14:19,949
years and I think Python has

00:14:16,579 --> 00:14:21,540
major advantages in this area to say

00:14:19,949 --> 00:14:23,220
you've compact code and even if people

00:14:21,540 --> 00:14:26,970
haven't been involved in the development

00:14:23,220 --> 00:14:28,170
they are quite fast in understanding

00:14:26,970 --> 00:14:31,470
what is going on in there

00:14:28,170 --> 00:14:33,360
no cost of course I don't have to say

00:14:31,470 --> 00:14:35,310
anything about that it's future proof I

00:14:33,360 --> 00:14:36,660
think becoming better and better and

00:14:35,310 --> 00:14:38,879
huge development efforts around the

00:14:36,660 --> 00:14:41,730
world will make it even better in the

00:14:38,879 --> 00:14:44,310
future and good performance yesterday we

00:14:41,730 --> 00:14:46,500
saw and talked by Mike but it can be

00:14:44,310 --> 00:14:49,439
horas and in many situations faster than

00:14:46,500 --> 00:14:51,240
Fortran I like to compare to C++ and

00:14:49,439 --> 00:14:53,699
other languages or if you compare it to

00:14:51,240 --> 00:14:55,470
MATLAB for example you have at least the

00:14:53,699 --> 00:14:57,720
same performance so I think performs

00:14:55,470 --> 00:14:59,459
isn't issue anymore if you do it right

00:14:57,720 --> 00:15:04,110
but here we get to that a little bit

00:14:59,459 --> 00:15:06,810
later on socialite is yesterday our

00:15:04,110 --> 00:15:08,910
experience with parson is many fault

00:15:06,810 --> 00:15:11,189
we develop commercial suite we're doing

00:15:08,910 --> 00:15:13,500
research with pison we give trainings

00:15:11,189 --> 00:15:16,740
like this but many in a cooperative

00:15:13,500 --> 00:15:18,509
manner or environment usually we use it

00:15:16,740 --> 00:15:20,759
in client projects I use it as a

00:15:18,509 --> 00:15:22,980
lecturer at silent University where

00:15:20,759 --> 00:15:25,709
teach mathematical finance to illustrate

00:15:22,980 --> 00:15:27,180
the models and I just recently finished

00:15:25,709 --> 00:15:31,889
a book which is called derivatives

00:15:27,180 --> 00:15:33,660
analytics with pison like 300 plus pages

00:15:31,889 --> 00:15:37,079
where Allah straight every financial

00:15:33,660 --> 00:15:40,110
model and everything that I do and with

00:15:37,079 --> 00:15:44,370
the help of Python scripts so we use it

00:15:40,110 --> 00:15:46,649
SSE in a number of areas so I'm going to

00:15:44,370 --> 00:15:49,350
start with numpy as I said the mother of

00:15:46,649 --> 00:15:52,139
everything else we face today without

00:15:49,350 --> 00:15:55,740
numpy all the other stuff that we will

00:15:52,139 --> 00:15:59,819
see later on wouldn't work so first my

00:15:55,740 --> 00:16:03,329
question who is who loses numpy I don't

00:15:59,819 --> 00:16:05,879
want to ask who knows nothing only a few

00:16:03,329 --> 00:16:06,480
of you use numpy thought it would be the

00:16:05,879 --> 00:16:14,189
majority

00:16:06,480 --> 00:16:15,779
I could see using it when numpy as I

00:16:14,189 --> 00:16:17,879
write here is a powerful library that

00:16:15,779 --> 00:16:19,829
allows array manipulations in general

00:16:17,879 --> 00:16:22,170
sense linear algebra because there are a

00:16:19,829 --> 00:16:24,389
lot more functions in a comic format at

00:16:22,170 --> 00:16:27,329
high speed this becomes actually from

00:16:24,389 --> 00:16:31,980
the implementation in c so to say it's

00:16:27,329 --> 00:16:33,929
like a whop hole if you if you give

00:16:31,980 --> 00:16:36,480
something to an umpire in the hands of

00:16:33,929 --> 00:16:39,360
numpy you're sure that it will be run on

00:16:36,480 --> 00:16:41,670
optimized c code and a won't run on the

00:16:39,360 --> 00:16:43,620
level of Pi C so you have the

00:16:41,670 --> 00:16:45,660
convenience of PI's on the one hand very

00:16:43,620 --> 00:16:49,110
compact code but from find with the

00:16:45,660 --> 00:16:50,939
speed of C so if you use it right you

00:16:49,110 --> 00:16:56,040
can have C performance but nevertheless

00:16:50,939 --> 00:16:58,110
the elegance of Python code how does it

00:16:56,040 --> 00:17:02,459
work in principle these are just some

00:16:58,110 --> 00:17:03,839
examples which you might want to to

00:17:02,459 --> 00:17:06,179
implement by yourself you can follow

00:17:03,839 --> 00:17:10,110
them you can if you can output up and

00:17:06,179 --> 00:17:11,579
running if you import numpy everything

00:17:10,110 --> 00:17:15,209
from the umpire of something like

00:17:11,579 --> 00:17:18,689
arrange and if you say a is a range

00:17:15,209 --> 00:17:20,730
which means you start at zero in this

00:17:18,689 --> 00:17:23,309
case go to 20

00:17:20,730 --> 00:17:25,350
these are floats compared to the range

00:17:23,309 --> 00:17:27,689
function that you have which are based

00:17:25,350 --> 00:17:29,070
on integers and your step size is one

00:17:27,689 --> 00:17:31,380
that you get something which looks like

00:17:29,070 --> 00:17:34,080
this and you see here this is an array

00:17:31,380 --> 00:17:36,330
and the major advantage is that you can

00:17:34,080 --> 00:17:39,030
do a lot of stuff with arrays that would

00:17:36,330 --> 00:17:41,100
be like mess you in pure pison so for

00:17:39,030 --> 00:17:43,760
example just to start with you can

00:17:41,100 --> 00:17:46,559
resize this or more reformatted

00:17:43,760 --> 00:17:48,840
precising is little bit confusing but

00:17:46,559 --> 00:17:51,240
the size remains the same in terms of

00:17:48,840 --> 00:17:53,250
number of elements but you reshape it

00:17:51,240 --> 00:17:56,010
more or less that you say I want to have

00:17:53,250 --> 00:17:58,500
it four times five then you have an

00:17:56,010 --> 00:18:01,890
array in this form you see arrays are

00:17:58,500 --> 00:18:03,409
like vectors in mathematical terms and

00:18:01,890 --> 00:18:07,140
you have it like matrices

00:18:03,409 --> 00:18:09,899
two-dimensional objects but you can have

00:18:07,140 --> 00:18:14,059
it n dimensionally so it is very easy to

00:18:09,899 --> 00:18:20,700
have like n times M times J for example

00:18:14,059 --> 00:18:23,549
erase you can slice dice everything that

00:18:20,700 --> 00:18:25,649
you know of other stuff with with the

00:18:23,549 --> 00:18:29,039
erase we say here for example give me

00:18:25,649 --> 00:18:32,159
the very first element of the array a in

00:18:29,039 --> 00:18:35,549
this case it will be the first row as

00:18:32,159 --> 00:18:38,669
you see it type in a types so here you

00:18:35,549 --> 00:18:39,370
get the fourth row of it the typical

00:18:38,669 --> 00:18:41,650
pattern

00:18:39,370 --> 00:18:43,270
whirring starting at zero but you can

00:18:41,650 --> 00:18:45,400
also say give me a specific element

00:18:43,270 --> 00:18:47,590
where you have like a vector notation

00:18:45,400 --> 00:18:50,260
where you say give me the second element

00:18:47,590 --> 00:18:55,840
from the last role in this case and this

00:18:50,260 --> 00:18:58,870
is actually the t9o in the second row

00:18:55,840 --> 00:19:03,309
the last element you can have like

00:18:58,870 --> 00:19:07,840
slices which says for example in the

00:19:03,309 --> 00:19:11,050
second line give me from you see the

00:19:07,840 --> 00:19:14,590
third one to the second but last one to

00:19:11,050 --> 00:19:17,980
two things there are a number of

00:19:14,590 --> 00:19:19,660
conventions regarding array indices if

00:19:17,980 --> 00:19:22,000
you take a look at the documentation

00:19:19,660 --> 00:19:25,330
which is quite big right now this topic

00:19:22,000 --> 00:19:27,970
for itself to learn um PI to use it

00:19:25,330 --> 00:19:30,040
rightly if we take a look at it you will

00:19:27,970 --> 00:19:32,470
find a number of things that you have to

00:19:30,040 --> 00:19:35,800
take into account when using these array

00:19:32,470 --> 00:19:37,750
structures but my experiences you

00:19:35,800 --> 00:19:40,690
experience with students you have to

00:19:37,750 --> 00:19:42,460
play with these you have just to get

00:19:40,690 --> 00:19:44,470
some example where you want to work on

00:19:42,460 --> 00:19:46,090
and then you learn it best because there

00:19:44,470 --> 00:19:49,030
are so many things you have to notice

00:19:46,090 --> 00:19:52,570
about it that it may be a little bit

00:19:49,030 --> 00:19:53,860
messy to read the whole documentation so

00:19:52,570 --> 00:19:55,720
what you can do and this is ready

00:19:53,860 --> 00:19:58,090
convenience comes in in terms of

00:19:55,720 --> 00:20:00,760
financial calculations --is that you use

00:19:58,090 --> 00:20:05,890
these arrays s for example integers or

00:20:00,760 --> 00:20:08,280
floats when you say you want to have an

00:20:05,890 --> 00:20:10,990
integer which is a typical operation

00:20:08,280 --> 00:20:15,460
Python if a would be like an integer or

00:20:10,990 --> 00:20:17,800
a float let's say this would exactly

00:20:15,460 --> 00:20:19,770
look like this and with numpy you get

00:20:17,800 --> 00:20:22,600
the convenience for example of MATLAB

00:20:19,770 --> 00:20:24,550
MATLAB is the closest thing you know to

00:20:22,600 --> 00:20:26,500
an umpire that you can find where you

00:20:24,550 --> 00:20:28,929
can have all these mathematical

00:20:26,500 --> 00:20:31,780
operations with regard to the arrays

00:20:28,929 --> 00:20:35,620
with like a matrix we saw it before and

00:20:31,780 --> 00:20:39,010
you just say a times 0.5 then you have

00:20:35,620 --> 00:20:41,650
the whole matrix in one single operation

00:20:39,010 --> 00:20:43,960
and it is not done on the Python level

00:20:41,650 --> 00:20:46,390
it is done on the C level and it's

00:20:43,960 --> 00:20:48,330
executed quite fast you can have like

00:20:46,390 --> 00:20:51,510
squares you can add

00:20:48,330 --> 00:20:55,080
things together if the shape fits of

00:20:51,510 --> 00:20:56,850
course it does it's not as convenient as

00:20:55,080 --> 00:20:59,730
in pandas where it's taken care of

00:20:56,850 --> 00:21:01,920
missing data and numpy requires you that

00:20:59,730 --> 00:21:03,660
if you add something up that the shape

00:21:01,920 --> 00:21:17,880
is the same of the two things this is

00:21:03,660 --> 00:21:26,330
like the broadcasting the of course if

00:21:17,880 --> 00:21:28,970
it fits this is true broadcasting

00:21:26,330 --> 00:21:32,490
upwards but if you have like two

00:21:28,970 --> 00:21:33,420
two-dimensional arrays and it doesn't

00:21:32,490 --> 00:21:38,310
fit then it doesn't know how to

00:21:33,420 --> 00:21:45,240
broadcast your right eyeball it works

00:21:38,310 --> 00:21:47,370
but not in this sense but you will often

00:21:45,240 --> 00:21:49,290
encounter in finance and I will talk

00:21:47,370 --> 00:21:52,760
about this in more detail later is that

00:21:49,290 --> 00:21:55,950
you have algorithms which at first sight

00:21:52,760 --> 00:22:00,360
seem like you have to implement it by

00:21:55,950 --> 00:22:02,670
iterations by loops because you have

00:22:00,360 --> 00:22:05,220
more often than not in finance something

00:22:02,670 --> 00:22:07,350
like start with this and then go to the

00:22:05,220 --> 00:22:09,390
next step then iterate over this and

00:22:07,350 --> 00:22:11,640
again again and everyone who is

00:22:09,390 --> 00:22:14,580
developing it's like thinking of four

00:22:11,640 --> 00:22:16,950
loops or something else you can do that

00:22:14,580 --> 00:22:20,160
even with the the arrays of course

00:22:16,950 --> 00:22:22,770
because you can using indices for

00:22:20,160 --> 00:22:25,710
example and you can loop over the cynic

00:22:22,770 --> 00:22:29,070
over this array in this case it's again

00:22:25,710 --> 00:22:33,270
a one-dimensional array which has 50

00:22:29,070 --> 00:22:36,540
elements and 51 elements taking this row

00:22:33,270 --> 00:22:40,530
it's even more with step size of 1/2 so

00:22:36,540 --> 00:22:44,370
you can loop over the array by just

00:22:40,530 --> 00:22:47,190
using the index for example looking for

00:22:44,370 --> 00:22:49,800
something that is of interest for you if

00:22:47,190 --> 00:22:54,360
functions like enumerate where you get

00:22:49,800 --> 00:22:57,960
back the index itself and the value of

00:22:54,360 --> 00:23:00,330
it but as we will see just for

00:22:57,960 --> 00:23:02,700
completeness I won't use it

00:23:00,330 --> 00:23:05,820
later on if you do it right all the

00:23:02,700 --> 00:23:10,260
algorithms and I will present who mainly

00:23:05,820 --> 00:23:12,750
mainly have to say avoid loops and the

00:23:10,260 --> 00:23:14,610
PI's another it doesn't mean if you

00:23:12,750 --> 00:23:16,110
don't see a loop on the Pisan level that

00:23:14,610 --> 00:23:19,230
there's no looping on the sea level and

00:23:16,110 --> 00:23:21,360
um PI because of course you have to

00:23:19,230 --> 00:23:24,809
iterate over the single elements of the

00:23:21,360 --> 00:23:28,440
array but on the Pisan that we will see

00:23:24,809 --> 00:23:31,309
you can almost always avoid iterations

00:23:28,440 --> 00:23:31,309
if you do it right

00:23:31,460 --> 00:23:37,559
what is also quite convenient from a

00:23:35,850 --> 00:23:39,510
finance perspective is that you can

00:23:37,559 --> 00:23:41,190
easily generate random numbers when the

00:23:39,510 --> 00:23:46,830
numbers especially when you think of

00:23:41,190 --> 00:23:50,220
simulation tasks are necessary as always

00:23:46,830 --> 00:23:52,169
so you need them a lot we use all we

00:23:50,220 --> 00:23:54,600
need them for almost everything we do

00:23:52,169 --> 00:23:56,820
our derivatives analytic suite is

00:23:54,600 --> 00:23:58,620
completely Montecarlo base so we for

00:23:56,820 --> 00:24:01,500
everything we do we need random numbers

00:23:58,620 --> 00:24:03,899
and to get them easily and in the shape

00:24:01,500 --> 00:24:05,340
or in the same format as we use for the

00:24:03,899 --> 00:24:08,010
other calculations it's quite convenient

00:24:05,340 --> 00:24:11,789
so if you import everything from numpy

00:24:08,010 --> 00:24:15,690
but random you have a lot of functions

00:24:11,789 --> 00:24:19,230
available where you can generate like a

00:24:15,690 --> 00:24:21,149
single dimensional random number vectors

00:24:19,230 --> 00:24:23,039
or you have in this case two-dimensional

00:24:21,149 --> 00:24:26,010
but more often than not you will have

00:24:23,039 --> 00:24:28,980
mighty dimensional requirements so you

00:24:26,010 --> 00:24:30,720
can generate them in the same way two

00:24:28,980 --> 00:24:32,909
times three times four and you see here

00:24:30,720 --> 00:24:35,970
you have a multi-dimensional array with

00:24:32,909 --> 00:24:37,950
random numbers in the with a

00:24:35,970 --> 00:24:39,740
distribution that you acquired and there

00:24:37,950 --> 00:24:42,330
are a number of distributions available

00:24:39,740 --> 00:24:47,159
if not you will find some additional

00:24:42,330 --> 00:24:50,279
ones in the SyFy library but this the

00:24:47,159 --> 00:24:57,960
supply brief numpy is still quite good

00:24:50,279 --> 00:24:59,909
for our financial purposes when working

00:24:57,960 --> 00:25:02,600
with arrays and especially in a

00:24:59,909 --> 00:25:05,490
financial topic you often want to

00:25:02,600 --> 00:25:08,700
visualize stuff that you have calculated

00:25:05,490 --> 00:25:12,620
that you have simulated what may be plot

00:25:08,700 --> 00:25:14,660
some stock prices as path over time

00:25:12,620 --> 00:25:18,440
which is a time series or you maybe want

00:25:14,660 --> 00:25:22,420
to generate some histogram and this is

00:25:18,440 --> 00:25:25,400
quite easy using a mat plot lip hi plot

00:25:22,420 --> 00:25:27,710
to generate these two dimensional plots

00:25:25,400 --> 00:25:29,840
I haven't brought an example for the 3d

00:25:27,710 --> 00:25:34,730
plots but in general it's enough to have

00:25:29,840 --> 00:25:37,850
2d plot so you see two main things for

00:25:34,730 --> 00:25:41,000
example if here we imported everything

00:25:37,850 --> 00:25:44,630
from my plot lip I plot you can plot B

00:25:41,000 --> 00:25:47,570
which is an array you just say plot this

00:25:44,630 --> 00:25:49,670
array there are some options for example

00:25:47,570 --> 00:25:52,309
crit then you will get the crit on the

00:25:49,670 --> 00:25:55,070
figure x is tight this moves the X's to

00:25:52,309 --> 00:25:57,260
the data that you have provided and then

00:25:55,070 --> 00:25:59,990
your type show and a result might look

00:25:57,260 --> 00:26:02,210
like this it does make sense I don't

00:25:59,990 --> 00:26:03,800
want to argue about it these are just

00:26:02,210 --> 00:26:06,220
random numbers this is a random number

00:26:03,800 --> 00:26:09,140
vector which we have generated before

00:26:06,220 --> 00:26:12,650
and we have plotted them in the lines

00:26:09,140 --> 00:26:15,110
format you have also a number of options

00:26:12,650 --> 00:26:18,950
in terms of if you want to have dots or

00:26:15,110 --> 00:26:21,770
lines thicker lines colored lines if you

00:26:18,950 --> 00:26:25,100
want to have bars and every one of you

00:26:21,770 --> 00:26:27,080
who knows map blood lip knows that this

00:26:25,100 --> 00:26:28,610
is quite mighty if you don't know it

00:26:27,080 --> 00:26:30,890
just go to website map that lip they

00:26:28,610 --> 00:26:33,530
have a very nice gallery but you just

00:26:30,890 --> 00:26:34,910
click on an icon in the gallery and you

00:26:33,530 --> 00:26:37,070
will get the complete source code you

00:26:34,910 --> 00:26:39,650
can copy it for example to I hiding and

00:26:37,070 --> 00:26:42,590
you can put your data that you generated

00:26:39,650 --> 00:26:49,880
in it so it's quite easy to to apply

00:26:42,590 --> 00:26:52,040
this you can also generate subplots

00:26:49,880 --> 00:26:54,260
because sometimes you want to compare

00:26:52,040 --> 00:26:57,590
data or you have two different views on

00:26:54,260 --> 00:26:59,510
the same data or you have two series or

00:26:57,590 --> 00:27:04,970
two two different types of data then you

00:26:59,510 --> 00:27:07,910
want to combine in a in a single figure

00:27:04,970 --> 00:27:12,020
for example for reporting purposes what

00:27:07,910 --> 00:27:15,350
we want to do right now is to plot this

00:27:12,020 --> 00:27:19,670
random vector in two different ways the

00:27:15,350 --> 00:27:22,910
first is that we have you plot it as

00:27:19,670 --> 00:27:25,760
dots you see us before I just said plot

00:27:22,910 --> 00:27:27,850
B and in this case generated by default

00:27:25,760 --> 00:27:30,950
line

00:27:27,850 --> 00:27:33,650
if your parameter Isis in this way then

00:27:30,950 --> 00:27:37,520
we get red dots you have to check to

00:27:33,650 --> 00:27:40,880
help the help file of plots to get all

00:27:37,520 --> 00:27:43,580
the options that you will have for for

00:27:40,880 --> 00:27:50,090
the plot function and we want add to add

00:27:43,580 --> 00:27:52,460
as a subplot a bar plot here we have to

00:27:50,090 --> 00:27:55,700
provide the range for 20 numbers and we

00:27:52,460 --> 00:27:59,560
also provide again the two random number

00:27:55,700 --> 00:28:03,040
vector T and the result might look like

00:27:59,560 --> 00:28:05,240
so again it doesn't make sense from a

00:28:03,040 --> 00:28:08,000
technical point of view these are just

00:28:05,240 --> 00:28:10,520
random numbers which we plotted in this

00:28:08,000 --> 00:28:14,210
case as red dots you see there is no

00:28:10,520 --> 00:28:15,650
crit because I haven't haven't used the

00:28:14,210 --> 00:28:17,900
option to generate the credit here is a

00:28:15,650 --> 00:28:20,300
crit and you see the same stuff as the

00:28:17,900 --> 00:28:22,310
bar plot you can also change the middle

00:28:20,300 --> 00:28:24,290
point of the bars and everything else as

00:28:22,310 --> 00:28:27,730
I said my blood Lib is quite muddy right

00:28:24,290 --> 00:28:32,350
now so you will find a lot of options to

00:28:27,730 --> 00:28:32,350
visualize and to customize the figures

00:28:36,010 --> 00:28:43,790
so this just wasn't a couple of minutes

00:28:40,010 --> 00:28:46,190
like a run through through numpy only

00:28:43,790 --> 00:28:48,050
touching upon some important aspects at

00:28:46,190 --> 00:28:50,390
least the ones that I consider important

00:28:48,050 --> 00:28:52,430
for financial purposes for what I want

00:28:50,390 --> 00:28:55,940
to do with you right now is a little

00:28:52,430 --> 00:28:58,580
exercise we have seen almost everything

00:28:55,940 --> 00:29:01,760
or actually everything that we need to

00:28:58,580 --> 00:29:04,100
do what is written or asked here and as

00:29:01,760 --> 00:29:06,920
you want to generate to series with 50

00:29:04,100 --> 00:29:08,360
standard normal so I do random numbers

00:29:06,920 --> 00:29:10,280
they are they are not really random

00:29:08,360 --> 00:29:14,620
numbers as we know and the episode of

00:29:10,280 --> 00:29:14,620
random numbers it is an array of size

00:29:15,250 --> 00:29:23,720
100 - I wrote 50 no it must be 50 and -

00:29:19,780 --> 00:29:26,120
and we call it RN but it doesn't matter

00:29:23,720 --> 00:29:28,700
if you generate two times 100 numbers so

00:29:26,120 --> 00:29:30,710
there's no problem with that is just not

00:29:28,700 --> 00:29:32,930
consistent what I wrote here when I

00:29:30,710 --> 00:29:36,110
calculate is sum of the 250 number

00:29:32,930 --> 00:29:39,410
vectors ones vector wise

00:29:36,110 --> 00:29:41,000
no using numpy as it is intended there

00:29:39,410 --> 00:29:43,940
is a function which is called some

00:29:41,000 --> 00:29:47,900
simply we want to store in another rate

00:29:43,940 --> 00:29:53,020
array and we want to implement the

00:29:47,900 --> 00:29:53,020
second kind of thing we want to loop I

00:29:59,830 --> 00:30:04,670
think we start with it just start with

00:30:02,420 --> 00:30:06,590
it four things step by step I don't want

00:30:04,670 --> 00:30:08,360
to explain it if you if you have got

00:30:06,590 --> 00:30:10,610
through the first two steps then we go

00:30:08,360 --> 00:30:13,460
one step further so you have to import

00:30:10,610 --> 00:30:48,500
numpy right now if you haven't done it

00:30:13,460 --> 00:30:50,090
yet you have to import yeah there are

00:30:48,500 --> 00:30:51,890
two different styles and if you if you

00:30:50,090 --> 00:30:53,929
write something bigger or you develop

00:30:51,890 --> 00:30:58,520
your solution with a number of modules

00:30:53,929 --> 00:31:01,370
with many many things in it and even if

00:30:58,520 --> 00:31:03,169
you work with the team where you have to

00:31:01,370 --> 00:31:05,059
distribute the development then you

00:31:03,169 --> 00:31:07,640
would do it the way as Mike described it

00:31:05,059 --> 00:31:09,470
of course you don't do it but if you are

00:31:07,640 --> 00:31:17,120
scripting it makes it a little bit

00:31:09,470 --> 00:31:20,780
faster you don't have it so but you can

00:31:17,120 --> 00:31:22,250
do it both ways you can import you can

00:31:20,780 --> 00:31:28,120
star import it or you can import it as

00:31:22,250 --> 00:31:28,120
NP 564

00:32:53,580 --> 00:33:04,810
everyone out showing difficulties

00:32:55,770 --> 00:33:09,420
downloading just click on this i was so

00:33:04,810 --> 00:33:09,420
easy to click the link was too easy

00:33:17,430 --> 00:33:28,350
depends on the access 30 years not the

00:33:25,750 --> 00:33:28,350
sum of two vectors

00:33:32,670 --> 00:33:50,730
if you have a plus a as a vector also

00:33:48,810 --> 00:33:53,570
make it clear when you got it right you

00:33:50,730 --> 00:33:56,640
have like two vectors with 50 elements

00:33:53,570 --> 00:33:59,040
stored in a single numpy array like 50

00:33:56,640 --> 00:34:00,690
elements so what I am looking for is

00:33:59,040 --> 00:34:16,110
like the sum of the two vectors so we

00:34:00,690 --> 00:34:19,620
have a vector operation where this is

00:34:16,110 --> 00:34:22,050
true this what I just was doing here and

00:34:19,620 --> 00:34:24,000
now to show depending on the shell or

00:34:22,050 --> 00:34:27,570
the the tool you are using you get some

00:34:24,000 --> 00:34:30,060
nice hints for example an eye presence

00:34:27,570 --> 00:34:33,179
mic set you have the question mark help

00:34:30,060 --> 00:34:35,070
function but it also supports you on the

00:34:33,179 --> 00:34:38,370
fly that is for example here in this

00:34:35,070 --> 00:34:40,649
case if you say RN is standard normal

00:34:38,370 --> 00:34:43,409
and you have the first parenthesis

00:34:40,649 --> 00:34:45,690
opened then it already gives you some

00:34:43,409 --> 00:34:48,870
hints with regard to parameterization of

00:34:45,690 --> 00:34:52,140
this particular function here in this

00:34:48,870 --> 00:34:53,460
case it only expects the size if you

00:34:52,140 --> 00:34:56,970
don't provide anything then it will

00:34:53,460 --> 00:34:59,400
return a single random number but you

00:34:56,970 --> 00:35:02,670
can have like 100 random numbers or you

00:34:59,400 --> 00:35:10,470
can provide a different shape that you

00:35:02,670 --> 00:35:12,240
want to see so size is not only

00:35:10,470 --> 00:35:18,090
one-dimensional in terms of the number

00:35:12,240 --> 00:35:19,470
of Senate normal sort of random numbers

00:35:18,090 --> 00:35:21,000
that you want to get back you can

00:35:19,470 --> 00:35:31,890
provide the shape a multi-dimensional

00:35:21,000 --> 00:35:34,740
shape and this is now printed out what I

00:35:31,890 --> 00:35:39,200
try to illustrate over there if we've

00:35:34,740 --> 00:35:42,560
timed it like this you have like 250

00:35:39,200 --> 00:35:42,560
element vectors

00:35:44,070 --> 00:35:51,100
what I said in the first is you won

00:35:48,430 --> 00:35:53,230
after generating these two series you

00:35:51,100 --> 00:35:56,470
want to calculate the sum of these

00:35:53,230 --> 00:36:01,000
vectors as a vector operation and we

00:35:56,470 --> 00:36:15,340
want to store it in another vector so to

00:36:01,000 --> 00:36:18,360
say another array or in some and once

00:36:15,340 --> 00:36:29,380
again if you use to some function

00:36:18,360 --> 00:36:32,260
imported slump I and I can it is quite

00:36:29,380 --> 00:36:36,610
easy with my slides I can do it and I

00:36:32,260 --> 00:36:39,040
apply it and I can so see here you need

00:36:36,610 --> 00:36:41,680
a little bit more actually don't need

00:36:39,040 --> 00:36:46,510
more but you have more options to

00:36:41,680 --> 00:36:49,240
privatize it you provide the array where

00:36:46,510 --> 00:36:50,920
you want to calculate the sum over but

00:36:49,240 --> 00:36:53,320
if you have a multi dimensional array

00:36:50,920 --> 00:36:57,040
like this of course there are a number

00:36:53,320 --> 00:37:00,280
of options with regard to the whole sum

00:36:57,040 --> 00:37:02,620
or just the sum in the first dimension

00:37:00,280 --> 00:37:04,090
or the sum over this so you have to

00:37:02,620 --> 00:37:08,140
provide the X's where you want to

00:37:04,090 --> 00:37:10,660
calculate the disarm over details of

00:37:08,140 --> 00:37:20,890
this at this stage we don't need this

00:37:10,660 --> 00:37:24,720
but if we just put in our our array that

00:37:20,890 --> 00:37:27,370
we generated we get back to sum over all

00:37:24,720 --> 00:37:29,500
so it's sum of all the numbers that are

00:37:27,370 --> 00:37:30,940
stored in it it makes sense or not this

00:37:29,500 --> 00:37:33,730
is another question but it gives you

00:37:30,940 --> 00:37:36,940
even for a mighty dimensional array it

00:37:33,730 --> 00:37:40,360
gives you the overall sum so if you want

00:37:36,940 --> 00:37:43,840
to just to add up by a vector operation

00:37:40,360 --> 00:37:46,350
the two vectors then you can specify the

00:37:43,840 --> 00:37:46,350
XS

00:37:48,410 --> 00:38:01,260
let me do it once again we have the RN

00:37:58,290 --> 00:38:04,670
array and then we say we start with the

00:38:01,260 --> 00:38:04,670
0 just see what happens

00:38:08,990 --> 00:38:17,240
okay this is not what we meant to do

00:38:11,940 --> 00:38:20,870
because again with the vector operation

00:38:17,240 --> 00:38:25,770
we get a vector which has the same

00:38:20,870 --> 00:38:28,410
dimension as the first two vectors so if

00:38:25,770 --> 00:38:30,270
we get out just a vector with two

00:38:28,410 --> 00:39:03,750
elements obviously it is the wrong

00:38:30,270 --> 00:39:05,760
access that we've chosen it is depends

00:39:03,750 --> 00:39:10,680
on certain kinds of conventions there is

00:39:05,760 --> 00:39:12,360
one difference indeed is that but don't

00:39:10,680 --> 00:39:15,210
ask me which is the right one to do you

00:39:12,360 --> 00:39:17,010
have some performance topics in terms of

00:39:15,210 --> 00:39:20,790
usually you have matrices that look like

00:39:17,010 --> 00:39:23,340
this but more like 100 times 50,000 or

00:39:20,790 --> 00:39:25,620
something so if you have the bigger loop

00:39:23,340 --> 00:39:27,600
as the first loop it is better from a

00:39:25,620 --> 00:39:31,670
performance perspective makes up for

00:39:27,600 --> 00:39:31,670
like 10 20 percent from the layout

00:40:52,020 --> 00:40:57,520
nobody even checked by yourself if you

00:40:54,160 --> 00:41:11,500
have some special problem and you can

00:40:57,520 --> 00:41:14,550
easily change the layout so in this case

00:41:11,500 --> 00:41:29,830
we get back the array which consists of

00:41:14,550 --> 00:41:33,520
50 elements next thing you want to do

00:41:29,830 --> 00:41:35,770
just to illustrate some differences in

00:41:33,520 --> 00:41:38,740
terms of how to use numpy in certain

00:41:35,770 --> 00:41:40,270
instances and maybe what to avoid I'm

00:41:38,740 --> 00:41:43,390
going to start with calculating a

00:41:40,270 --> 00:41:45,660
cumulative sum index by index which

00:41:43,390 --> 00:41:45,660
means

00:41:47,670 --> 00:41:53,080
take the first element we add the second

00:41:50,770 --> 00:41:55,000
and store it somewhere we had to third

00:41:53,080 --> 00:41:57,040
and store it somewhere at the fourth and

00:41:55,000 --> 00:42:02,650
at the end we will have the cumulative

00:41:57,040 --> 00:42:05,530
sum over the whole vector can heat it

00:42:02,650 --> 00:42:07,510
for some purposes but I just want to use

00:42:05,530 --> 00:42:09,910
this we could have another example here

00:42:07,510 --> 00:42:13,869
but I think it illustrates quite well

00:42:09,910 --> 00:42:18,490
how to work with non P arrays we have in

00:42:13,869 --> 00:42:21,040
our end some now stored our sum over the

00:42:18,490 --> 00:42:24,550
two vectors what we want to do is to

00:42:21,040 --> 00:42:26,890
generate another 50 element vector till

00:42:24,550 --> 00:42:29,560
we get it right not a single sum we want

00:42:26,890 --> 00:42:35,650
to generate another vector as a set

00:42:29,560 --> 00:42:38,290
which adds up element by element the

00:42:35,650 --> 00:42:41,380
vector which we generated in the last

00:42:38,290 --> 00:42:45,849
step so you can do it two different ways

00:42:41,380 --> 00:42:51,490
the first is and I propose that we start

00:42:45,849 --> 00:42:54,700
with it that we that we calculate it by

00:42:51,490 --> 00:42:59,560
come sum which is a numpy function which

00:42:54,700 --> 00:43:02,830
you can apply to an array and the second

00:42:59,560 --> 00:43:05,109
is just to implement a short loop where

00:43:02,830 --> 00:43:08,950
you do it by yourself because we saw it

00:43:05,109 --> 00:43:11,170
yesterday and talked by Mike and was

00:43:08,950 --> 00:43:14,290
discussion around this people who are

00:43:11,170 --> 00:43:16,660
used to implement loops they always try

00:43:14,290 --> 00:43:19,240
to translate what they learned maybe in

00:43:16,660 --> 00:43:22,599
Fortran and C in C++ to translate this

00:43:19,240 --> 00:43:24,070
to Pisan as well so there is some kind

00:43:22,599 --> 00:43:26,290
of risk that you say oh I understand

00:43:24,070 --> 00:43:28,000
this algorithm this is some kind of loop

00:43:26,290 --> 00:43:29,710
and I want to implement it right now and

00:43:28,000 --> 00:43:31,960
pice and you start looping over it and

00:43:29,710 --> 00:43:34,210
forgetting about to take a look at how

00:43:31,960 --> 00:43:37,060
you could do it better in Python so we

00:43:34,210 --> 00:43:41,530
maybe start with the come sum function

00:43:37,060 --> 00:43:43,540
which is quite easy to apply and then I

00:43:41,530 --> 00:43:46,510
would propose that you try to implement

00:43:43,540 --> 00:43:50,010
the same kind of thing as a loop over

00:43:46,510 --> 00:43:53,109
the array that we generated beforehand

00:43:50,010 --> 00:43:54,619
so here you see our vector and what we

00:43:53,109 --> 00:43:58,519
want to do is

00:43:54,619 --> 00:44:01,039
the first element of our air and come

00:43:58,519 --> 00:44:03,650
vector should stay this thing this is

00:44:01,039 --> 00:44:05,509
the initialization in the second place

00:44:03,650 --> 00:44:07,069
you will find the sum of both and the

00:44:05,509 --> 00:44:09,950
third you will find the sum of the three

00:44:07,069 --> 00:44:12,470
and the fourth the sum of the four and

00:44:09,950 --> 00:44:16,670
the fifth the sum of the first five

00:44:12,470 --> 00:44:26,029
elements and so forth as I said you can

00:44:16,670 --> 00:44:27,829
do it like our income slide NP some and

00:44:26,029 --> 00:44:30,230
you see once again you have to provide

00:44:27,829 --> 00:44:32,779
an array and if you have a

00:44:30,230 --> 00:44:35,240
multi-dimensional array you can once

00:44:32,779 --> 00:44:38,450
again specify the axis that you want to

00:44:35,240 --> 00:45:00,079
use but in this case if only a one

00:44:38,450 --> 00:45:03,109
dimensional and you see once again with

00:45:00,079 --> 00:45:07,430
numpy we have add something which cries

00:45:03,109 --> 00:45:10,130
for loop but we have done it with a

00:45:07,430 --> 00:45:12,140
single function on the vampire level but

00:45:10,130 --> 00:45:13,759
nevertheless as a jest that you just try

00:45:12,140 --> 00:45:15,710
to implement a simple loop where you

00:45:13,759 --> 00:45:17,180
implement this come some function by

00:45:15,710 --> 00:45:29,450
yourself either by defining a function

00:45:17,180 --> 00:45:31,039
or by just implementing a loop there

00:45:29,450 --> 00:45:34,999
actually I think the number of ways how

00:45:31,039 --> 00:45:37,239
to attack this but either one should be

00:45:34,999 --> 00:45:37,239
fine

00:46:01,089 --> 00:46:10,970
actually what I've just done is to to

00:46:03,559 --> 00:46:12,650
plot our our income vector which already

00:46:10,970 --> 00:46:17,809
looks like some kind of stock price

00:46:12,650 --> 00:46:20,720
development or apart from being negative

00:46:17,809 --> 00:46:27,980
in some way it's more like a profit and

00:46:20,720 --> 00:46:31,910
loss development at least if you believe

00:46:27,980 --> 00:46:34,039
in efficient markets yes but when random

00:46:31,910 --> 00:46:39,019
in what way random of course not in a

00:46:34,039 --> 00:46:40,390
normal distributed way so this is but

00:46:39,019 --> 00:46:42,799
for a long time this was the major

00:46:40,390 --> 00:46:45,559
hypothesis that everything is standard

00:46:42,799 --> 00:46:48,499
normally this you but as you know right

00:46:45,559 --> 00:46:53,450
now we have fat tails at least on the

00:46:48,499 --> 00:46:55,339
one end so and also skewness which I

00:46:53,450 --> 00:47:23,960
described in detail in this book by the

00:46:55,339 --> 00:47:27,410
way just doesn't look like a stock price

00:47:23,960 --> 00:47:29,569
development it's more like an erratic

00:47:27,410 --> 00:47:32,660
thing or random numbers but if I use

00:47:29,569 --> 00:47:35,289
come some it becomes more like a typical

00:47:32,660 --> 00:47:35,289
movement

00:47:49,030 --> 00:48:03,170
you have your loops uh burning in the

00:48:01,640 --> 00:48:05,900
end you can easily compare it if you

00:48:03,170 --> 00:48:09,410
have a second vector you can subtract

00:48:05,900 --> 00:48:11,210
your your result from the one that comes

00:48:09,410 --> 00:48:30,500
from generated and you will see if it

00:48:11,210 --> 00:48:36,080
works correctly on yeah

00:48:30,500 --> 00:48:37,490
actually yes but actually it's a very

00:48:36,080 --> 00:48:39,170
good question because with our software

00:48:37,490 --> 00:48:42,770
we have some kind of programs in this

00:48:39,170 --> 00:48:45,619
regard because you can you can model

00:48:42,770 --> 00:48:47,810
derivatives where there are no benchmark

00:48:45,619 --> 00:48:49,010
models available you know typically when

00:48:47,810 --> 00:48:50,330
you say you implement the software you

00:48:49,010 --> 00:48:50,810
have some standard cases like a test

00:48:50,330 --> 00:48:52,640
suite

00:48:50,810 --> 00:48:55,310
you have to sign that benchmark models

00:48:52,640 --> 00:48:57,140
and you have your own results and you

00:48:55,310 --> 00:48:59,359
benchmark them against well-known

00:48:57,140 --> 00:49:01,820
results from other approaches from other

00:48:59,359 --> 00:49:05,540
formulas and so forth but you don't have

00:49:01,820 --> 00:49:09,560
them every time so you practically have

00:49:05,540 --> 00:49:11,840
no benchmark does this loop for this is

00:49:09,560 --> 00:49:13,250
like having extra Microsoft won't

00:49:11,840 --> 00:49:15,619
guarantee that everything that is

00:49:13,250 --> 00:49:17,300
calculated with Excel is right in the

00:49:15,619 --> 00:49:19,270
sense that it makes economically sense

00:49:17,300 --> 00:49:22,130
they say well two plus two is four

00:49:19,270 --> 00:49:25,369
hopefully by the for make sense in this

00:49:22,130 --> 00:49:27,470
context nobody knows and Microsoft would

00:49:25,369 --> 00:49:29,119
never guarantee and this is really a

00:49:27,470 --> 00:49:31,369
problem that we face is that if you

00:49:29,119 --> 00:49:32,990
allow people to model something then

00:49:31,369 --> 00:49:36,950
they expect that it's correctly

00:49:32,990 --> 00:49:41,080
valued in the end so we can't take any

00:49:36,950 --> 00:49:41,080
guarantee or representation for that so

00:49:50,260 --> 00:49:57,020
but this is same as with excellent if

00:49:52,849 --> 00:49:59,059
they would it if they would say we buy a

00:49:57,020 --> 00:50:00,559
service from you we give you some kind

00:49:59,059 --> 00:50:03,530
of model specifications of us and we

00:50:00,559 --> 00:50:05,329
expect fair values back then it would be

00:50:03,530 --> 00:50:07,250
different then we would have the

00:50:05,329 --> 00:50:10,760
responsibility that is correctly model

00:50:07,250 --> 00:50:13,099
that there are no flaws that is valuable

00:50:10,760 --> 00:50:16,240
at all with ourself and so forth but if

00:50:13,099 --> 00:50:19,490
we just provide the software you cannot

00:50:16,240 --> 00:50:22,130
if you want to predict a lottery numbers

00:50:19,490 --> 00:50:24,349
for next Saturday with XO and you fail

00:50:22,130 --> 00:50:28,839
in doing so you cannot get to the court

00:50:24,349 --> 00:50:28,839
and try to sue Microsoft

00:51:27,460 --> 00:51:32,510
so if once you see one possible

00:51:30,380 --> 00:51:35,180
implementation I think there are a

00:51:32,510 --> 00:51:37,850
number of others or to iterate over this

00:51:35,180 --> 00:51:42,170
adjust initialize a second vector which

00:51:37,850 --> 00:51:46,400
is the same size as our R in some vector

00:51:42,170 --> 00:51:48,740
I initialize the whole vector with my

00:51:46,400 --> 00:51:53,540
first value of the some vector and then

00:51:48,740 --> 00:51:59,030
iterate step by step adding step by step

00:51:53,540 --> 00:52:03,100
the next value so and you see in fact

00:51:59,030 --> 00:52:03,100
this is some kind of looping operation

00:52:03,700 --> 00:52:12,350
and this looping in pison if you have

00:52:07,220 --> 00:52:16,760
large vectors is this time intensive and

00:52:12,350 --> 00:52:18,110
needs a lot of time especially when the

00:52:16,760 --> 00:52:21,130
operations are little bit more

00:52:18,110 --> 00:52:25,490
complicated than summing up give my

00:52:21,130 --> 00:52:27,380
logarithms exponents and so forth and it

00:52:25,490 --> 00:52:29,480
will need a lot of time but if you do it

00:52:27,380 --> 00:52:33,890
if you do these kind of operations on

00:52:29,480 --> 00:52:36,410
the numpy level then you will save time

00:52:33,890 --> 00:52:40,760
in a considerable way not only in like

00:52:36,410 --> 00:52:46,250
10% or 20% you will speed it up more

00:52:40,760 --> 00:52:49,070
like 25 30 40 % depends on 40 times what

00:52:46,250 --> 00:52:51,770
percent 40 times it depends on what you

00:52:49,070 --> 00:52:53,270
are doing with it with our algorithms

00:52:51,770 --> 00:52:57,820
are financial algorithms to speed-up

00:52:53,270 --> 00:52:57,820
factor is like 25 to 30 times in average

00:53:02,740 --> 00:53:11,210
good enough because you have the

00:53:05,390 --> 00:53:12,860
overhead here you have this overhead of

00:53:11,210 --> 00:53:15,490
the communication between the two words

00:53:12,860 --> 00:53:15,490
so to say

00:53:22,190 --> 00:53:28,140
and I just made a check over there you

00:53:24,720 --> 00:53:32,420
see I subtracted the formal result from

00:53:28,140 --> 00:53:35,640
my own result and you see it's

00:53:32,420 --> 00:53:42,750
fortunately always zero which means -

00:53:35,640 --> 00:53:49,080
the results are the same so maybe next

00:53:42,750 --> 00:53:51,990
step to come to an end with this

00:53:49,080 --> 00:53:53,640
exercise you might want to plot to our

00:53:51,990 --> 00:53:56,250
income vector that you have now

00:53:53,640 --> 00:53:59,000
calculated you can plot your own or you

00:53:56,250 --> 00:54:03,030
can plot the result of the come sum

00:53:59,000 --> 00:54:07,490
operation and as a second exercise in

00:54:03,030 --> 00:54:11,360
terms of plotting you should try to plot

00:54:07,490 --> 00:54:14,580
to 250 run the number of actors as

00:54:11,360 --> 00:54:18,720
histograms and to put it into a single

00:54:14,580 --> 00:54:20,310
figure as subplots again we saw

00:54:18,720 --> 00:54:22,260
everything before if you take a look at

00:54:20,310 --> 00:54:24,450
the slides and the examples that are

00:54:22,260 --> 00:54:27,620
provided before you should be able to do

00:54:24,450 --> 00:54:27,620
that quite easily

00:55:45,099 --> 00:55:58,940
does it work

00:55:47,599 --> 00:56:24,160
oh it says it's a big one so we call

00:55:58,940 --> 00:56:28,900
what it's a good one standard normal and

00:56:24,160 --> 00:56:28,900
then well on vector I begin

00:56:33,110 --> 00:56:59,330
this is typically disappear taking on

00:56:37,670 --> 00:57:03,620
people to random so Stan come some

00:56:59,330 --> 00:57:11,360
vector what the swings then do it under

00:57:03,620 --> 00:57:29,660
source in the spectra I was he got in

00:57:11,360 --> 00:57:32,800
from businesses of the aesir's footage

00:57:29,660 --> 00:57:35,690
confidence see area

00:57:32,800 --> 00:57:37,910
come on slogan at me at canto xvii

00:57:35,690 --> 00:57:41,120
design the Scott Logan meter and it is

00:57:37,910 --> 00:58:01,000
Lanisha of audience up tanya has done

00:57:41,120 --> 00:58:03,410
tonight Vikas opens hip any relative

00:58:01,000 --> 00:58:07,010
would not Fatima here and there she'll

00:58:03,410 --> 00:58:09,560
reveal sorry I was talking to two guys

00:58:07,010 --> 00:58:11,990
in German and I was now in German mode

00:58:09,560 --> 00:58:13,640
what we want to do is to generate two

00:58:11,990 --> 00:58:18,020
different figures the one is just the

00:58:13,640 --> 00:58:20,000
come some vector that we want to plot it

00:58:18,020 --> 00:58:22,250
looks like as I said before like a stock

00:58:20,000 --> 00:58:24,710
price development and the second is a

00:58:22,250 --> 00:58:27,170
figure with two subplots we just provide

00:58:24,710 --> 00:58:29,840
the precision for the subplots and then

00:58:27,170 --> 00:58:33,850
first histogram for our first vector and

00:58:29,840 --> 00:58:36,850
second histogram for our second vector

00:58:33,850 --> 00:58:36,850
yeah

00:59:04,239 --> 00:59:09,369
and if you if you do from our import

00:59:14,710 --> 01:00:00,829
pipe lot Saipan so the two figures could

00:59:56,869 --> 01:00:02,479
look like this of course you will most

01:00:00,829 --> 01:00:04,430
probably see different figures because

01:00:02,479 --> 01:00:07,910
we are working with try to render number

01:00:04,430 --> 01:00:11,269
so your numbers won't be the same as

01:00:07,910 --> 01:00:14,690
mine here we see the first one or comes

01:00:11,269 --> 01:00:18,710
on plotted looks like a fair game in the

01:00:14,690 --> 01:00:21,319
long run it doesn't have to be and the

01:00:18,710 --> 01:00:25,309
second figure we generated are the two

01:00:21,319 --> 01:00:29,359
histograms and subplots in a single

01:00:25,309 --> 01:00:31,670
figure you could have also for subplots

01:00:29,359 --> 01:00:32,989
in a single figure or whatever for

01:00:31,670 --> 01:00:34,219
example if you're working with pandas

01:00:32,989 --> 01:00:37,069
what we will do shortly

01:00:34,219 --> 01:00:39,799
you have convenient functions where you

01:00:37,069 --> 01:00:42,589
for example can plot a data frame when

01:00:39,799 --> 01:00:44,869
it has like four different time series

01:00:42,589 --> 01:00:47,390
it will automatically generate four

01:00:44,869 --> 01:00:50,319
different subplots for each time series

01:00:47,390 --> 01:00:50,319
stored in the data frame

01:02:20,940 --> 01:02:45,160
it's a little bit confused because is

01:02:43,210 --> 01:02:48,220
like this is like two rows and we've

01:02:45,160 --> 01:02:53,770
only one column see two rows one column

01:02:48,220 --> 01:02:55,570
is first same otherwise you would have

01:02:53,770 --> 01:02:59,530
if you have two columns of course it's

01:02:55,570 --> 01:03:06,280
like 2 2 2 2 1 2 sounds like metrics

01:02:59,530 --> 01:03:07,780
style or is it a MATLAB oriented added

01:03:06,280 --> 01:03:09,520
to it yeah you can change later words

01:03:07,780 --> 01:03:12,640
upload so you can for example I could

01:03:09,520 --> 01:03:25,690
add some label to it or switch on the

01:03:12,640 --> 01:03:30,520
crit or whatever in the suppler so but

01:03:25,690 --> 01:03:35,470
it did but it did say that it generated

01:03:30,520 --> 01:03:37,330
something beforehand they are do this

01:03:35,470 --> 01:03:54,220
behind your window your current window

01:03:37,330 --> 01:03:55,720
or somewhere yeah but this is this is

01:03:54,220 --> 01:03:59,170
empty you haven't blotted something to

01:03:55,720 --> 01:04:01,920
it yeah sometimes it shows the empty

01:03:59,170 --> 01:04:01,920
plot but I

01:04:19,279 --> 01:04:48,299
okay just to import it from would you

01:04:43,260 --> 01:04:51,450
have in the first time maybe it's the I

01:04:48,299 --> 01:04:57,049
fibers it can be that you don't have

01:04:51,450 --> 01:04:57,049
installed the right graphical back-end

01:04:59,000 --> 01:05:05,849
you need something like UT or depends on

01:05:02,970 --> 01:05:09,510
I don't know the dependencies of the

01:05:05,849 --> 01:05:11,190
metal clip library so it could be that

01:05:09,510 --> 01:05:13,890
you need some kind of graphical back end

01:05:11,190 --> 01:05:20,549
which is not installed so for what I'm

01:05:13,890 --> 01:05:22,619
doing an ET QT backend it typically is

01:05:20,549 --> 01:05:26,690
in at least on the window which it uses

01:05:22,619 --> 01:05:26,690
its installed on the fly so I don't know

01:05:32,869 --> 01:05:38,270
maybe you should give it a try by the

01:05:35,690 --> 01:05:40,140
Synoptics package manager I don't know

01:05:38,270 --> 01:05:47,819
because it takes care of all the

01:05:40,140 --> 01:05:52,829
dependencies if you go oh alright but if

01:05:47,819 --> 01:05:55,920
you go to yours and synaptic see I don't

01:05:52,829 --> 01:05:59,400
have to but is this open to is it is

01:05:55,920 --> 01:06:01,819
equal to a package figure if you type

01:05:59,400 --> 01:06:01,819
again

01:06:01,850 --> 01:06:21,980
and also for action maybe just something

01:06:19,440 --> 01:06:39,360
different you installation zone

01:06:21,980 --> 01:06:42,360
sorry okay I think for everyone working

01:06:39,360 --> 01:06:45,660
in finance or close to finance or

01:06:42,360 --> 01:06:49,530
working in some similar field of

01:06:45,660 --> 01:06:52,320
expertise numpy is a very mighty library

01:06:49,530 --> 01:06:56,070
you might always give a try if you're

01:06:52,320 --> 01:06:58,020
working with data structures so it is

01:06:56,070 --> 01:07:03,210
quite fundamental we have right now if

01:06:58,020 --> 01:07:09,810
to take a look at my clock how much time

01:07:03,210 --> 01:07:14,130
is left I would move about 25 minutes so

01:07:09,810 --> 01:07:17,370
the next topics are only some kind of

01:07:14,130 --> 01:07:19,400
brief topics where you might get an

01:07:17,370 --> 01:07:21,330
impression how to work with some

01:07:19,400 --> 01:07:24,270
convenient functions which are mostly

01:07:21,330 --> 01:07:26,730
out of the disciple library for example

01:07:24,270 --> 01:07:28,770
what we have to use quite often but in

01:07:26,730 --> 01:07:31,650
almost any field of finance you have to

01:07:28,770 --> 01:07:33,210
approximate stuff approximate in a sense

01:07:31,650 --> 01:07:34,650
that you have a number of observations

01:07:33,210 --> 01:07:37,530
whether they come from from the stock

01:07:34,650 --> 01:07:40,400
market or from a physical experiment or

01:07:37,530 --> 01:07:42,570
biological kind of thing and you want to

01:07:40,400 --> 01:07:45,390
infer something you want to describe

01:07:42,570 --> 01:07:46,800
what you see you want well in a general

01:07:45,390 --> 01:07:48,330
sense to approximate something so you

01:07:46,800 --> 01:07:51,410
have different ways to do that the first

01:07:48,330 --> 01:07:54,750
and most simple one maybe is regression

01:07:51,410 --> 01:07:56,370
regression for us at least is one of the

01:07:54,750 --> 01:07:59,880
most important things that we do because

01:07:56,370 --> 01:08:02,940
the majority of our algorithms is mostly

01:07:59,880 --> 01:08:04,920
based on a cross step which includes

01:08:02,940 --> 01:08:07,470
regression so we use it a lot and we

01:08:04,920 --> 01:08:10,020
needed a lot and with Python it's

01:08:07,470 --> 01:08:11,410
enticing in combination with numpy it's

01:08:10,020 --> 01:08:15,369
quite easy to implement

01:08:11,410 --> 01:08:17,049
regressions so what about to illustrate

01:08:15,369 --> 01:08:20,199
is the most simple case ordinary

01:08:17,049 --> 01:08:23,230
least-squares regression where some kind

01:08:20,199 --> 01:08:26,190
of optimization function is minimized in

01:08:23,230 --> 01:08:30,370
that case and where we work with

01:08:26,190 --> 01:08:33,489
ordinary monomials X x squared X cube

01:08:30,370 --> 01:08:37,120
and we want to approximate desired

01:08:33,489 --> 01:08:39,940
function given a number pick n capital n

01:08:37,120 --> 01:08:42,870
of observations which might look like

01:08:39,940 --> 01:08:46,299
this and once again this could be

01:08:42,870 --> 01:08:48,940
financial numbers this could be physical

01:08:46,299 --> 01:08:51,580
numbers biological stuff or wherever you

01:08:48,940 --> 01:08:55,270
work and you want to approximate it

01:08:51,580 --> 01:08:57,580
maybe by polynomial of order 2 but as we

01:08:55,270 --> 01:09:00,310
will see we can easily scale it to

01:08:57,580 --> 01:09:03,029
include higher permeance what you can

01:09:00,310 --> 01:09:07,259
also easily do is have a multivariate

01:09:03,029 --> 01:09:10,000
kind of thing where you have different

01:09:07,259 --> 01:09:11,830
different variables which drive your

01:09:10,000 --> 01:09:14,230
function which means that X becomes a

01:09:11,830 --> 01:09:17,409
vector and is not a float or something

01:09:14,230 --> 01:09:21,100
else the task in this case is to

01:09:17,409 --> 01:09:23,440
minimize the sum over these but there's

01:09:21,100 --> 01:09:26,440
something missing I see right now there

01:09:23,440 --> 01:09:31,270
should be a square in it because it's

01:09:26,440 --> 01:09:37,210
least squares so there is a typo on this

01:09:31,270 --> 01:09:39,520
in this formula we want to minimize the

01:09:37,210 --> 01:09:41,980
sum over absolute numbers and not

01:09:39,520 --> 01:09:44,770
something that we might get negative as

01:09:41,980 --> 01:09:48,270
well as positive numbers but hopefully

01:09:44,770 --> 01:09:48,270
umpires and it's correctly implemented

01:09:49,469 --> 01:09:55,420
just a simple example which is quite

01:09:52,480 --> 01:10:00,639
artificial but it illustrates what we

01:09:55,420 --> 01:10:03,370
can do with it we may have some numbers

01:10:00,639 --> 01:10:05,830
like 20 observations for the cosine

01:10:03,370 --> 01:10:12,159
function over the interval from 0 to 1/2

01:10:05,830 --> 01:10:16,060
P and we want to approximate this

01:10:12,159 --> 01:10:18,370
function yr polyfit and put ey these are

01:10:16,060 --> 01:10:19,659
two functions which you find in the

01:10:18,370 --> 01:10:21,760
number library as well

01:10:19,659 --> 01:10:23,650
from poly fit you get the minimizing

01:10:21,760 --> 01:10:25,410
regression parameter spec these were the

01:10:23,650 --> 01:10:28,440
A's of the last slide

01:10:25,410 --> 01:10:30,870
you can use these then plug them in so

01:10:28,440 --> 01:10:36,480
to say in the prevention to generate

01:10:30,870 --> 01:10:39,810
values based on these parameters but you

01:10:36,480 --> 01:10:41,610
see here it's just really really simple

01:10:39,810 --> 01:10:45,930
example we generate these twenty

01:10:41,610 --> 01:10:48,770
observations for the cosine function and

01:10:45,930 --> 01:10:51,470
I want to illustrate like an

01:10:48,770 --> 01:10:54,990
approximation or regression with the

01:10:51,470 --> 01:10:57,240
constant number which a linear function

01:10:54,990 --> 01:10:59,280
with the quadratic function but you can

01:10:57,240 --> 01:11:02,970
easily scale it to include like the cube

01:10:59,280 --> 01:11:05,190
and even higher monomials into this when

01:11:02,970 --> 01:11:07,620
we get back our regression parameters we

01:11:05,190 --> 01:11:11,640
put them in into the profile function

01:11:07,620 --> 01:11:14,750
use our 20 observation points and one

01:11:11,640 --> 01:11:18,030
then graphically compare how good our

01:11:14,750 --> 01:11:20,940
our estimates our regression functions

01:11:18,030 --> 01:11:22,500
approximate the cosine function you will

01:11:20,940 --> 01:11:24,650
find this script if you want to load it

01:11:22,500 --> 01:11:28,590
if you want to check it by yourself in

01:11:24,650 --> 01:11:31,170
the folder which you've downloaded which

01:11:28,590 --> 01:11:38,820
is called topics till you find something

01:11:31,170 --> 01:11:51,060
called a rec and if you execute it you

01:11:38,820 --> 01:11:55,350
might see something like that you see

01:11:51,060 --> 01:11:59,970
the the yellow line here this is the

01:11:55,350 --> 01:12:03,270
cosine function we have to minimizing

01:11:59,970 --> 01:12:04,770
constant number which means it was the

01:12:03,270 --> 01:12:08,930
first regression we did just by a

01:12:04,770 --> 01:12:11,460
constant figure we then have the linear

01:12:08,930 --> 01:12:16,950
regression which are the blue dots and

01:12:11,460 --> 01:12:19,380
we have the quadratic function from the

01:12:16,950 --> 01:12:21,870
quadratic approximation you see below

01:12:19,380 --> 01:12:24,720
there the green triangles which is

01:12:21,870 --> 01:12:28,010
already quite good so perfect but for

01:12:24,720 --> 01:12:28,010
this purpose it would suffice

01:12:28,150 --> 01:13:12,489
a simpler F that's my next it was my

01:13:09,760 --> 01:13:13,960
next thing no problem but it's not

01:13:12,489 --> 01:13:15,370
actually piecewise regression because

01:13:13,960 --> 01:13:19,050
this would be a little bit messy because

01:13:15,370 --> 01:13:23,020
you would have to take care of all the

01:13:19,050 --> 01:13:25,120
interval limits relative like 3/4 then

01:13:23,020 --> 01:13:28,120
how to get it smooth how to get it

01:13:25,120 --> 01:13:30,840
continuous these are problem so but it's

01:13:28,120 --> 01:13:36,810
a good issue raised by Mike because

01:13:30,840 --> 01:13:39,670
quite often at least in what we do we

01:13:36,810 --> 01:13:42,429
face stuff which is not strictly convex

01:13:39,670 --> 01:13:45,460
or concave so in this case it's quite

01:13:42,429 --> 01:13:47,199
simple because we have like a metonic

01:13:45,460 --> 01:13:49,270
lee decreasing function which is quite

01:13:47,199 --> 01:13:52,719
smooth so we are able to approximate it

01:13:49,270 --> 01:13:59,020
quite well but for example I've worked

01:13:52,719 --> 01:14:04,690
on a payoff which looks quite simple in

01:13:59,020 --> 01:14:08,469
the sense it is simple but it's quite

01:14:04,690 --> 01:14:12,210
hard to approximate by regression so you

01:14:08,469 --> 01:14:17,500
can imagine if you have something I take

01:14:12,210 --> 01:14:21,159
another there it is if you have such a

01:14:17,500 --> 01:14:23,590
non-convex payoff of course you can have

01:14:21,159 --> 01:14:26,800
something like your constant number your

01:14:23,590 --> 01:14:29,110
something like linear would maybe be the

01:14:26,800 --> 01:14:32,199
same but if you start having something

01:14:29,110 --> 01:14:34,239
like a cube another cube or a quadratic

01:14:32,199 --> 01:14:37,640
function you have something like this

01:14:34,239 --> 01:14:40,740
this doesn't approximate this area

01:14:37,640 --> 01:14:42,870
you know then you start by with the cube

01:14:40,740 --> 01:14:45,750
thing this would maybe look like this

01:14:42,870 --> 01:14:48,360
it'd approximate this quite well but

01:14:45,750 --> 01:14:50,900
this really were so if you work only in

01:14:48,360 --> 01:14:53,010
this part of your payoff wonderful but

01:14:50,900 --> 01:14:55,170
if you have this play of you have to

01:14:53,010 --> 01:14:58,050
take care of the whole range of possible

01:14:55,170 --> 01:15:01,260
values so there is no way out of this

01:14:58,050 --> 01:15:04,140
trap but as Mike already suggested take

01:15:01,260 --> 01:15:06,720
some kind of different approach to it so

01:15:04,140 --> 01:15:13,860
one approach which works quite good in a

01:15:06,720 --> 01:15:16,950
low dimension is to use splines which is

01:15:13,860 --> 01:15:19,740
a concept of interpolation it's it is

01:15:16,950 --> 01:15:22,200
mathematically much more involved but in

01:15:19,740 --> 01:15:23,970
applications it is almost the same

01:15:22,200 --> 01:15:26,310
almost as straightforward as using

01:15:23,970 --> 01:15:28,380
regression so you have in a sub-module

01:15:26,310 --> 01:15:30,720
of siper interpolate you will find the

01:15:28,380 --> 01:15:34,260
function that you need for the cubix for

01:15:30,720 --> 01:15:37,910
the use of cubic splines here in this

01:15:34,260 --> 01:15:41,400
case you want to use the same numbers

01:15:37,910 --> 01:15:43,380
and what does what two cubic splines do

01:15:41,400 --> 01:15:52,950
in effect could be explain this like a

01:15:43,380 --> 01:15:54,620
form of intelligent regression once

01:15:52,950 --> 01:15:58,440
again if you have something like this

01:15:54,620 --> 01:16:01,800
like a non convex payoff cubic splines

01:15:58,440 --> 01:16:06,600
just say you have a number of intervals

01:16:01,800 --> 01:16:08,610
that you consider separately and for

01:16:06,600 --> 01:16:12,300
each interval you have your regression

01:16:08,610 --> 01:16:14,670
function and as the name suggests the

01:16:12,300 --> 01:16:17,370
regression function is one that is a

01:16:14,670 --> 01:16:21,180
cubic function so you have at least

01:16:17,370 --> 01:16:23,310
enough freedom for the interval and what

01:16:21,180 --> 01:16:26,430
it does in addition this is the kind of

01:16:23,310 --> 01:16:32,120
thing that we are often interested in it

01:16:26,430 --> 01:16:35,070
is smoothing it out on every interval

01:16:32,120 --> 01:16:38,370
limit so maybe you are not perfect here

01:16:35,070 --> 01:16:40,440
but one thing is to make sure that you

01:16:38,370 --> 01:16:42,960
have a continuous even twice

01:16:40,440 --> 01:16:44,340
differentiable function in the end this

01:16:42,960 --> 01:16:46,650
is what you often need when you do

01:16:44,340 --> 01:16:48,660
financial applications and you will be

01:16:46,650 --> 01:16:50,580
able why are cubic splines to

01:16:48,660 --> 01:16:53,070
approximate such a function

01:16:50,580 --> 01:16:54,450
well because you have lots of intimates

01:16:53,070 --> 01:16:57,360
you can scared of course you can say how

01:16:54,450 --> 01:16:59,100
large the interval should be and it

01:16:57,360 --> 01:17:03,270
makes life much more easier especially

01:16:59,100 --> 01:17:04,920
in cases where you need the approximate

01:17:03,270 --> 01:17:06,480
function that you get from your cubic

01:17:04,920 --> 01:17:09,810
splines expertise and have to

01:17:06,480 --> 01:17:12,600
differentiate it this is often the case

01:17:09,810 --> 01:17:13,860
if you work with right curves if you're

01:17:12,600 --> 01:17:16,320
something to do with interest rates

01:17:13,860 --> 01:17:19,710
interest rate related products then you

01:17:16,320 --> 01:17:21,630
have some set of yield observations

01:17:19,710 --> 01:17:23,970
where you say for this duration the

01:17:21,630 --> 01:17:26,670
yield is like one percent five years

01:17:23,970 --> 01:17:28,230
pluses like ten percent and so forth

01:17:26,670 --> 01:17:30,510
and you have a number of discreet

01:17:28,230 --> 01:17:33,180
observations but you need something that

01:17:30,510 --> 01:17:36,090
approximate this that is differentiable

01:17:33,180 --> 01:17:38,190
afterwards and you have to make sure

01:17:36,090 --> 01:17:40,260
that it's differentiable no matter what

01:17:38,190 --> 01:17:42,540
happens over there and there you want to

01:17:40,260 --> 01:17:47,490
use for example cubic splines to

01:17:42,540 --> 01:17:51,960
interpolate your observations it is

01:17:47,490 --> 01:17:54,780
something that is better in terms of

01:17:51,960 --> 01:17:58,620
results for certain conditions but you

01:17:54,780 --> 01:18:00,480
have to take care of the ordering for

01:17:58,620 --> 01:18:02,760
regression based approximation it

01:18:00,480 --> 01:18:05,160
doesn't matter if you have an ordered

01:18:02,760 --> 01:18:06,930
set of observation in the direction of

01:18:05,160 --> 01:18:10,320
your rarebits

01:18:06,930 --> 01:18:12,390
for example the x's so to say can come

01:18:10,320 --> 01:18:17,280
in any order but if you want to use

01:18:12,390 --> 01:18:20,100
cubic splines of course you must take

01:18:17,280 --> 01:18:23,010
care of the single observations that lie

01:18:20,100 --> 01:18:25,110
in the single intervals the

01:18:23,010 --> 01:18:26,850
approximation by a regressions is more

01:18:25,110 --> 01:18:29,130
like a global thing so it doesn't matter

01:18:26,850 --> 01:18:31,350
in which order you put in your

01:18:29,130 --> 01:18:32,460
observations because if it's globally

01:18:31,350 --> 01:18:34,470
done it doesn't matter if it's in the

01:18:32,460 --> 01:18:36,360
first place or is in the last one it

01:18:34,470 --> 01:18:37,860
gets the same weight but if you want to

01:18:36,360 --> 01:18:39,930
work with intervals of course you have

01:18:37,860 --> 01:18:42,660
to respect the structure that you want

01:18:39,930 --> 01:18:44,550
to impose so if you have some set which

01:18:42,660 --> 01:18:47,520
is not all that you would have to order

01:18:44,550 --> 01:18:51,660
your numbers first and then apply cubic

01:18:47,520 --> 01:18:53,820
splines to what you observe and what is

01:18:51,660 --> 01:18:56,070
another limitation and some certain

01:18:53,820 --> 01:18:57,750
sense is the cubic splines of limited or

01:18:56,070 --> 01:19:01,050
even no use for higher dimensional

01:18:57,750 --> 01:19:03,989
problems there are some approaches where

01:19:01,050 --> 01:19:06,960
you can have a mighty variate

01:19:03,989 --> 01:19:09,030
situations and it still works but in

01:19:06,960 --> 01:19:11,130
general for higher dimensional problems

01:19:09,030 --> 01:19:13,139
you don't have anything else but the

01:19:11,130 --> 01:19:16,800
question to make the approximations but

01:19:13,139 --> 01:19:20,489
at least as we would see in this short

01:19:16,800 --> 01:19:24,179
example when we use cubic splines

01:19:20,489 --> 01:19:28,199
to approximate our cosine function over

01:19:24,179 --> 01:19:30,749
the given interval 0 to 1/2 P and it is

01:19:28,199 --> 01:19:34,619
done where these two function splines

01:19:30,749 --> 01:19:37,980
grab and splines evaluate and you see

01:19:34,619 --> 01:19:41,130
the output oh of course you find this in

01:19:37,980 --> 01:19:42,929
the same folder this pre stripped in the

01:19:41,130 --> 01:19:45,869
same folder as I mentioned before and

01:19:42,929 --> 01:19:48,360
the CD result is in this case perfect

01:19:45,869 --> 01:19:51,090
and you will touch it from every

01:19:48,360 --> 01:19:54,929
observation point will patch it touch it

01:19:51,090 --> 01:19:57,840
perfectly and not only like differences

01:19:54,929 --> 01:20:04,670
of you know order something you see this

01:19:57,840 --> 01:20:04,670
already looks like yeah

01:20:20,280 --> 01:20:27,250
yes this is what with you of course if

01:20:23,860 --> 01:20:30,730
we do this kind of payoff with with

01:20:27,250 --> 01:20:33,790
regression then we also use this perfect

01:20:30,730 --> 01:20:35,740
function as the approximation because we

01:20:33,790 --> 01:20:37,720
know a little bit about the structure

01:20:35,740 --> 01:20:39,190
and in this case it's like obvious

01:20:37,720 --> 01:20:41,320
because we are working two dimension and

01:20:39,190 --> 01:20:43,510
so forth but you will have will face

01:20:41,320 --> 01:20:46,720
cases we don't have any clue which

01:20:43,510 --> 01:20:49,300
function to include to improve your

01:20:46,720 --> 01:20:52,150
approximation of course that the example

01:20:49,300 --> 01:20:53,290
with Pootie fit adjust the basic example

01:20:52,150 --> 01:20:54,850
when you use pulley fit and pulley

01:20:53,290 --> 01:20:57,940
valleys like the standard regression

01:20:54,850 --> 01:21:00,070
method built in a numpy you can use the

01:20:57,940 --> 01:21:01,900
least squares over there you can include

01:21:00,070 --> 01:21:03,070
any function that you can imagine this

01:21:01,900 --> 01:21:06,450
is what we actually do with our

01:21:03,070 --> 01:21:06,450
application as well

01:21:06,720 --> 01:21:23,590
I still didn't get it if you set up your

01:21:22,000 --> 01:21:25,990
problem by yourself not important fit

01:21:23,590 --> 01:21:27,760
and believe it just like monomials but

01:21:25,990 --> 01:21:29,740
you can use you can only scale in terms

01:21:27,760 --> 01:21:31,000
of order but if we use least squares

01:21:29,740 --> 01:21:32,950
then you define your functions by

01:21:31,000 --> 01:21:35,050
yourself you have you built your

01:21:32,950 --> 01:21:36,520
approximation problem by yourself then

01:21:35,050 --> 01:21:38,710
it minimizes the problem that you

01:21:36,520 --> 01:21:40,810
provided so you have full flexibility

01:21:38,710 --> 01:21:42,490
either monomials or whatever or

01:21:40,810 --> 01:21:51,400
combinations cross products you can

01:21:42,490 --> 01:21:53,980
include everything another topic just to

01:21:51,400 --> 01:21:57,420
mention it the last point in this regard

01:21:53,980 --> 01:22:00,820
is that is quite time-consuming

01:21:57,420 --> 01:22:02,860
cubic spline computations need time the

01:22:00,820 --> 01:22:05,530
question is done really fast but cubic

01:22:02,860 --> 01:22:07,420
splines are a little bit fast but if the

01:22:05,530 --> 01:22:12,220
result is much much better you may

01:22:07,420 --> 01:22:14,980
consider it nevertheless then another

01:22:12,220 --> 01:22:18,730
typical object or topic and finances

01:22:14,980 --> 01:22:21,250
optimization strictly speaking what we

01:22:18,730 --> 01:22:23,160
saw before are already two cases of

01:22:21,250 --> 01:22:25,320
optimization but

01:22:23,160 --> 01:22:27,180
in a more general sense you will face

01:22:25,320 --> 01:22:30,330
some functions that you either want to

01:22:27,180 --> 01:22:33,120
maximize like utility or or whatever

01:22:30,330 --> 01:22:35,130
your face in finance economics or that

01:22:33,120 --> 01:22:36,810
you want to minimize one of our standard

01:22:35,130 --> 01:22:39,540
problems is to minimize an error

01:22:36,810 --> 01:22:41,640
function we calibrate models the model

01:22:39,540 --> 01:22:44,070
has maybe like five seven or twelve

01:22:41,640 --> 01:22:46,470
input parameters and we want to

01:22:44,070 --> 01:22:49,320
calibrate the model to observe market

01:22:46,470 --> 01:22:52,920
prices that we see in the option markets

01:22:49,320 --> 01:22:56,100
and to this end we already know

01:22:52,920 --> 01:22:58,200
beforehand that there will be no perfect

01:22:56,100 --> 01:23:00,210
fit we are not able to calibrate the

01:22:58,200 --> 01:23:02,700
model perfectly but what we can do is to

01:23:00,210 --> 01:23:04,470
minimize the error function so we say

01:23:02,700 --> 01:23:07,170
okay our results that the model

01:23:04,470 --> 01:23:09,090
generates are benchmarked against the

01:23:07,170 --> 01:23:11,640
results we observe in the market and

01:23:09,090 --> 01:23:13,770
maybe you want to do something like we

01:23:11,640 --> 01:23:17,640
have seen before we want to minimize the

01:23:13,770 --> 01:23:20,190
squared differences unit so this is like

01:23:17,640 --> 01:23:22,890
a typical problem that you see where you

01:23:20,190 --> 01:23:25,260
have in general two major approaches one

01:23:22,890 --> 01:23:27,600
it's a global one where as I said before

01:23:25,260 --> 01:23:30,330
if you have five input parameters for a

01:23:27,600 --> 01:23:33,260
model and you want to minimize your

01:23:30,330 --> 01:23:35,580
function globally then you would like to

01:23:33,260 --> 01:23:37,770
apply maybe some kind of proof force

01:23:35,580 --> 01:23:40,920
algorithm where you say start with the

01:23:37,770 --> 01:23:43,770
first parameter at zero and iterate in

01:23:40,920 --> 01:23:46,890
point one steps two until you reach two

01:23:43,770 --> 01:23:49,320
and so forth so that you like flying all

01:23:46,890 --> 01:23:51,870
over the whole world and take a look at

01:23:49,320 --> 01:23:54,600
least briefly at every spot that you see

01:23:51,870 --> 01:23:56,340
in the world and then maybe as a next

01:23:54,600 --> 01:23:57,960
step or you even start with the local

01:23:56,340 --> 01:24:00,060
optimization say well this seems

01:23:57,960 --> 01:24:02,310
promising and we now want to take a

01:24:00,060 --> 01:24:04,680
little bit deeper and we want to local

01:24:02,310 --> 01:24:07,350
locally you take a look at it and to

01:24:04,680 --> 01:24:09,210
optimize it a little bit better then you

01:24:07,350 --> 01:24:11,520
have a number of functions available

01:24:09,210 --> 01:24:17,550
that you can use with Python or I must

01:24:11,520 --> 01:24:21,480
say part si PI as well here quite a

01:24:17,550 --> 01:24:25,380
really simple example once again where

01:24:21,480 --> 01:24:29,190
we have again a trigonometric function

01:24:25,380 --> 01:24:31,900
given like the scene functions very

01:24:29,190 --> 01:24:34,010
simple example take

01:24:31,900 --> 01:24:37,219
sign function over the interval four

01:24:34,010 --> 01:24:42,349
minus P to 0 the minimum value of minus

01:24:37,219 --> 01:24:44,060
one at half P again we know it but we

01:24:42,349 --> 01:24:48,800
are interested how paisa works it out

01:24:44,060 --> 01:24:50,389
and the library side PI has these

01:24:48,800 --> 01:24:52,790
functions stored in the sub-module

01:24:50,389 --> 01:24:54,199
optimize and you see here once again you

01:24:52,790 --> 01:24:59,179
will find it in the same folder once

01:24:54,199 --> 01:25:01,550
again what we do here is we just want to

01:24:59,179 --> 01:25:04,340
apply the brute force algorithm which is

01:25:01,550 --> 01:25:07,369
called put inside PI to the problem

01:25:04,340 --> 01:25:11,599
where we say just start iterating at

01:25:07,369 --> 01:25:14,860
minus P stop at 0 this interval that we

01:25:11,599 --> 01:25:17,750
interested in and go by the step size

01:25:14,860 --> 01:25:21,080
finish none just means that there is no

01:25:17,750 --> 01:25:23,270
rule in terms of when to finish this he

01:25:21,080 --> 01:25:25,369
has to do it no matter what what the

01:25:23,270 --> 01:25:27,409
results are in between and then you have

01:25:25,369 --> 01:25:30,260
the function for local minimization F

01:25:27,409 --> 01:25:33,199
min this is only one option out of a

01:25:30,260 --> 01:25:34,610
number of angus 10 different local

01:25:33,199 --> 01:25:39,560
minimizer that you will find in the

01:25:34,610 --> 01:25:44,150
library I just say minimize why this

01:25:39,560 --> 01:25:46,790
function and start at minus 1/2 or

01:25:44,150 --> 01:25:49,250
whatever if you don't have to give a

01:25:46,790 --> 01:25:51,830
starting point but in a certain sense it

01:25:49,250 --> 01:25:54,290
speeds it up of course if you have some

01:25:51,830 --> 01:25:56,929
knowledge about the structure and you

01:25:54,290 --> 01:26:00,889
have some guess where it would be good

01:25:56,929 --> 01:26:03,380
to find it so here in this case it's

01:26:00,889 --> 01:26:06,889
really a simple example but would do

01:26:03,380 --> 01:26:08,869
what we use it there are very highly

01:26:06,889 --> 01:26:10,639
structured functions that we have to

01:26:08,869 --> 01:26:11,960
minimize but the same approach still

01:26:10,639 --> 01:26:15,020
works very well in a multi-dimensional

01:26:11,960 --> 01:26:17,150
world so what I try here is just to give

01:26:15,020 --> 01:26:20,570
a very simple example but you can apply

01:26:17,150 --> 01:26:23,540
it to s complex functions at as you

01:26:20,570 --> 01:26:27,320
usually face in your daily work so the

01:26:23,540 --> 01:26:30,170
first s we see is a global minimum it

01:26:27,320 --> 01:26:32,929
was put out as minus one point five

01:26:30,170 --> 01:26:34,900
seven this is about half P and the local

01:26:32,929 --> 01:26:39,320
minimum which the local minimizer

01:26:34,900 --> 01:26:42,679
generated is almost the same and we see

01:26:39,320 --> 01:26:43,750
here it needed 18 iterations and it

01:26:42,679 --> 01:26:46,750
called the function

01:26:43,750 --> 01:26:48,610
thirty-six times so you have some kind

01:26:46,750 --> 01:26:50,890
of additional information if you like to

01:26:48,610 --> 01:26:55,810
you can get even some more information

01:26:50,890 --> 01:26:58,960
about the local minimization process as

01:26:55,810 --> 01:27:02,410
you know in this case I haven't read it

01:26:58,960 --> 01:27:04,000
out I just printed the result here but

01:27:02,410 --> 01:27:05,740
as I said before you get some more

01:27:04,000 --> 01:27:08,590
information from the local minimization

01:27:05,740 --> 01:27:14,500
algorithm generally than just the number

01:27:08,590 --> 01:27:17,410
that turned out at this stage one of the

01:27:14,500 --> 01:27:21,370
last small topics which you might face

01:27:17,410 --> 01:27:23,530
in finance is numerical integration more

01:27:21,370 --> 01:27:27,010
often than not you face a function which

01:27:23,530 --> 01:27:29,890
you can't integrate analytically but you

01:27:27,010 --> 01:27:32,350
will find inside PI once again

01:27:29,890 --> 01:27:34,840
libraries to do integration stuff

01:27:32,350 --> 01:27:37,000
American integration stuff and here

01:27:34,840 --> 01:27:39,880
again an example where we know the

01:27:37,000 --> 01:27:42,580
analytical value of the integral exactly

01:27:39,880 --> 01:27:45,040
in this case just the exponential

01:27:42,580 --> 01:27:48,130
function over the interval from 0 to 1

01:27:45,040 --> 01:27:51,870
and the value is approximately 1.7

01:27:48,130 --> 01:27:55,600
something Seifer helps out in this case

01:27:51,870 --> 01:27:59,380
in this case we use numerical quadrature

01:27:55,600 --> 01:28:01,750
scheme to do this and once again it

01:27:59,380 --> 01:28:04,840
seems quite easy to do this and you can

01:28:01,750 --> 01:28:07,360
do this with many more Maor much more

01:28:04,840 --> 01:28:09,150
complicated functions in this case but

01:28:07,360 --> 01:28:12,730
this is very simple we adjust the

01:28:09,150 --> 01:28:14,560
exponential functions and we want to get

01:28:12,730 --> 01:28:17,800
the value of the integral I'm just

01:28:14,560 --> 01:28:19,240
interested in the first first item of

01:28:17,800 --> 01:28:22,300
the vector which is given back by the

01:28:19,240 --> 01:28:24,040
function over this function from the

01:28:22,300 --> 01:28:28,300
interval which starts at zero and goes

01:28:24,040 --> 01:28:32,850
to one for us we need it quite often

01:28:28,300 --> 01:28:35,440
when we have to to numerically evaluate

01:28:32,850 --> 01:28:39,100
integrals with regard to option

01:28:35,440 --> 01:28:40,870
valuation functions these indicators are

01:28:39,100 --> 01:28:42,280
quite complex involving characteristic

01:28:40,870 --> 01:28:45,550
functions and so forth there we have

01:28:42,280 --> 01:28:47,920
some imaginary stuff and so forth but

01:28:45,550 --> 01:28:50,530
still Saipan tick redheads you out with

01:28:47,920 --> 01:28:52,570
this as I mentioned before just a simple

01:28:50,530 --> 01:28:55,010
example to give you hints where to look

01:28:52,570 --> 01:28:56,510
for but you can apply it to

01:28:55,010 --> 01:29:01,760
much more complicated stuff that you

01:28:56,510 --> 01:29:04,489
will face in practice so I think this is

01:29:01,760 --> 01:29:10,280
the right point to get to the coffee

01:29:04,489 --> 01:29:12,710
break and afterwards we will go on with

01:29:10,280 --> 01:29:15,230
some financial stuff which is a little

01:29:12,710 --> 01:29:17,030
bit more involved but first a question

01:29:15,230 --> 01:29:18,949
do we get the coffee break is like 45

01:29:17,030 --> 01:29:22,489
minutes so we need to 45 minutes or

01:29:18,949 --> 01:29:23,840
should we do it a little bit shorter and

01:29:22,489 --> 01:29:28,429
have a little bit more time for the

01:29:23,840 --> 01:29:30,019
stuff that follows afterwards should we

01:29:28,429 --> 01:29:34,699
like do like 20 minutes break

01:29:30,019 --> 01:29:37,070
is it okay okay shut it off for the

01:29:34,699 --> 01:29:46,489
coffee and some sweets and don't see you

01:29:37,070 --> 01:29:50,170
again later at 10:50 yeah we see each

01:29:46,489 --> 01:29:50,170

YouTube URL: https://www.youtube.com/watch?v=tJGGu2bqZeI


