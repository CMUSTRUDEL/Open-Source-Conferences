Title: Using sockets in Python
Publication date: 2015-04-19
Playlist: EuroPython 2012
Description: 
	[EuroPython 2012] F Buynooghe - 5 JULY 2012 in "Track Ravioli"
Captions: 
	00:00:49,949 --> 00:00:57,980
okay so the first talk of this this

00:00:53,460 --> 00:00:57,980
afternoon is particle circuits in Python

00:01:04,640 --> 00:01:11,630
yeah good afternoon my name is Flores

00:01:07,440 --> 00:01:15,600
Brannigan and yeah I'll be talking about

00:01:11,630 --> 00:01:16,979
sockets this is roughly what early I'll

00:01:15,600 --> 00:01:21,780
be trying to talk about this afternoon

00:01:16,979 --> 00:01:26,520
so basic sockets like first in white

00:01:21,780 --> 00:01:29,690
details so UDP TCP then we'll move on to

00:01:26,520 --> 00:01:31,950
his name resolution there's life I found

00:01:29,690 --> 00:01:37,310
quiet or some gotchas in there

00:01:31,950 --> 00:01:41,100
I can snag you and then move on to

00:01:37,310 --> 00:01:44,369
handling non-blocking sockets and then

00:01:41,100 --> 00:01:48,959
handling stream data as well which I

00:01:44,369 --> 00:01:51,690
found to be acquired an interesting

00:01:48,959 --> 00:01:53,880
topic because there yeah and then

00:01:51,690 --> 00:01:57,539
finally very quickly were mentioned some

00:01:53,880 --> 00:02:00,750
libraries and other tools how tired of

00:01:57,539 --> 00:02:03,299
the standard library that handle the

00:02:00,750 --> 00:02:05,189
sockets I'd like to start by apologizing

00:02:03,299 --> 00:02:07,530
really because sockets are a massive

00:02:05,189 --> 00:02:10,019
topic and it's very pretentious of me to

00:02:07,530 --> 00:02:12,060
come and tell you how you should be

00:02:10,019 --> 00:02:15,930
doing them I'm so apologize for any

00:02:12,060 --> 00:02:18,540
mistakes I make it's kind of based on my

00:02:15,930 --> 00:02:22,230
experience of writing socket code in the

00:02:18,540 --> 00:02:24,380
past couple of years and I'll yeah

00:02:22,230 --> 00:02:28,290
hopefully point out some bits that

00:02:24,380 --> 00:02:30,620
tripped me over when writing socket

00:02:28,290 --> 00:02:30,620
encode

00:02:30,770 --> 00:02:38,340
before we get started slides the code

00:02:35,700 --> 00:02:43,380
I'll show should work on Python 2.7 and

00:02:38,340 --> 00:02:48,030
3.2 most of it is probably applicable to

00:02:43,380 --> 00:02:50,040
other versions of past as well and a

00:02:48,030 --> 00:02:52,110
really important point is sockets work

00:02:50,040 --> 00:02:55,980
with bytes if you see a string in in the

00:02:52,110 --> 00:03:00,530
slides that's I drew mistake or Python

00:02:55,980 --> 00:03:03,150
2.7 output because everything is bytes

00:03:00,530 --> 00:03:06,930
I'm not gonna handle anything you know

00:03:03,150 --> 00:03:10,200
converting that's text yeah so from

00:03:06,930 --> 00:03:14,570
circle import star and I'll try to be a

00:03:10,200 --> 00:03:18,930
be version agnostic so most of it should

00:03:14,570 --> 00:03:21,060
deal deal with the ipv4 and ipv6 and I

00:03:18,930 --> 00:03:23,730
will not touch on any protocol design

00:03:21,060 --> 00:03:25,260
because that's a whole yeah i'll

00:03:23,730 --> 00:03:27,990
basically assume you know what protocol

00:03:25,260 --> 00:03:32,700
you want to talk designing protocol is a

00:03:27,990 --> 00:03:36,800
whole new area really if you like dead

00:03:32,700 --> 00:03:42,300
trees these are two really good books

00:03:36,800 --> 00:03:44,880
the Python one is by Brandon rodas it is

00:03:42,300 --> 00:03:48,000
kind of a gentle introduction and and

00:03:44,880 --> 00:03:52,050
but will will build up from from the

00:03:48,000 --> 00:03:55,110
basics it's it's I find it a really good

00:03:52,050 --> 00:03:56,970
book actually got covers very good

00:03:55,110 --> 00:03:58,769
detail as well as well as nicely

00:03:56,970 --> 00:04:02,190
building up for if you don't know much

00:03:58,769 --> 00:04:04,620
from I am tcp/ip to start with UNIX

00:04:02,190 --> 00:04:08,790
network programming is a C book but it

00:04:04,620 --> 00:04:10,590
is like dereference really it it if you

00:04:08,790 --> 00:04:12,000
need to know any anything that you don't

00:04:10,590 --> 00:04:14,700
know you're probably going to find it in

00:04:12,000 --> 00:04:21,450
there any obscure detail will probably

00:04:14,700 --> 00:04:24,840
be mentioned in there yeah it's and and

00:04:21,450 --> 00:04:27,740
yeah and the Python socket API is

00:04:24,840 --> 00:04:30,930
actually a really thin layer over to see

00:04:27,740 --> 00:04:33,169
API so you'll find it acquired directly

00:04:30,930 --> 00:04:33,169
applicable

00:04:35,070 --> 00:04:41,800
so moving on to basic sockets and

00:04:38,890 --> 00:04:47,350
basically yeah covering the common

00:04:41,800 --> 00:04:49,090
launch this VIP oh and UDP over IP so

00:04:47,350 --> 00:04:51,250
the Internet Protocol is like the layer

00:04:49,090 --> 00:04:53,560
below what you usually interact with

00:04:51,250 --> 00:04:57,100
it's basically a packet switch Network

00:04:53,560 --> 00:04:59,110
and and you can it can deliver packets

00:04:57,100 --> 00:05:04,690
to other to perform one and point to

00:04:59,110 --> 00:05:06,550
another end point the the order of those

00:05:04,690 --> 00:05:09,820
packets might not always be the same

00:05:06,550 --> 00:05:11,730
sometimes back to get lost just just

00:05:09,820 --> 00:05:16,060
have queues full and then they drop them

00:05:11,730 --> 00:05:18,730
sometimes packets get routed differently

00:05:16,060 --> 00:05:20,590
between the same two endpoints and what

00:05:18,730 --> 00:05:25,900
one of them are slower and suddenly got

00:05:20,590 --> 00:05:29,140
them out of order etc sometimes links

00:05:25,900 --> 00:05:30,520
art was not capable of carrying that big

00:05:29,140 --> 00:05:33,340
packs and they need to chop them up and

00:05:30,520 --> 00:05:35,260
then only one one of the fragments

00:05:33,340 --> 00:05:40,540
arrives and things like that so there's

00:05:35,260 --> 00:05:41,230
a lot of going on there also ipv4 and

00:05:40,540 --> 00:05:44,680
ipv6

00:05:41,230 --> 00:05:46,990
I think there's been lots of

00:05:44,680 --> 00:05:49,300
advertisement about ipv6 is running out

00:05:46,990 --> 00:05:51,010
ipv4 is running out sorry not by abuse

00:05:49,300 --> 00:05:54,490
except they hope that the last for a

00:05:51,010 --> 00:05:57,040
while but the main thing is this is an

00:05:54,490 --> 00:05:58,860
entirely different network so the two

00:05:57,040 --> 00:06:01,510
really don't interact the interact the

00:05:58,860 --> 00:06:05,590
aware where there is compatibility is

00:06:01,510 --> 00:06:08,950
really on the OS which has a dual stack

00:06:05,590 --> 00:06:12,310
you can use both kind of at the same

00:06:08,950 --> 00:06:16,630
time but on network level there they're

00:06:12,310 --> 00:06:19,000
completely separate and well yeah good

00:06:16,630 --> 00:06:22,630
afternoon now mostly look at what builds

00:06:19,000 --> 00:06:29,280
on top especially using UDP and TCP on

00:06:22,630 --> 00:06:33,070
top of those packets UDP and TCP they

00:06:29,280 --> 00:06:36,370
they are very the main difference is

00:06:33,070 --> 00:06:38,170
really one carries packets between two

00:06:36,370 --> 00:06:42,280
endpoints and it's very close actually

00:06:38,170 --> 00:06:44,650
towards IP it's Elvis and TCP is a

00:06:42,280 --> 00:06:45,470
stream of data stream of bytes

00:06:44,650 --> 00:06:49,340
essentially

00:06:45,470 --> 00:06:52,070
and I'll pretty much most of the things

00:06:49,340 --> 00:06:55,430
that I said about IP a class 5 for UDP

00:06:52,070 --> 00:06:56,660
they may not arrive they may arrive out

00:06:55,430 --> 00:07:00,290
of order

00:06:56,660 --> 00:07:04,880
and and there's also there's no idea

00:07:00,290 --> 00:07:08,030
about the connection so the kernels and

00:07:04,880 --> 00:07:12,980
the devices are in between etc I have no

00:07:08,030 --> 00:07:15,410
idea about what a what the two endpoints

00:07:12,980 --> 00:07:17,830
are really there's no no notion of state

00:07:15,410 --> 00:07:17,830
in there

00:07:18,460 --> 00:07:27,650
TCP is an override of streams and so

00:07:24,020 --> 00:07:29,690
sorry no other stream of bytes and the

00:07:27,650 --> 00:07:32,150
main thing here is that it's just one

00:07:29,690 --> 00:07:34,760
long stream there is no no distinction

00:07:32,150 --> 00:07:36,950
like a like a packet there's no big no

00:07:34,760 --> 00:07:38,990
certain length or anything it's just an

00:07:36,950 --> 00:07:41,720
infinite length of a stream until you

00:07:38,990 --> 00:07:43,970
close it and that has a really big

00:07:41,720 --> 00:07:47,030
impact on I think that's probably one of

00:07:43,970 --> 00:07:49,160
the most important points so could

00:07:47,030 --> 00:07:51,230
objects the methods that you used to

00:07:49,160 --> 00:07:54,080
send and receive data will operate

00:07:51,230 --> 00:07:56,060
differently depending on what will

00:07:54,080 --> 00:07:58,070
behave differently depending on the type

00:07:56,060 --> 00:08:02,530
of socket they're they're working on if

00:07:58,070 --> 00:08:08,090
you're working on on a UDP they will

00:08:02,530 --> 00:08:09,710
handle entire packets well if you if you

00:08:08,090 --> 00:08:12,680
calling the same methods on on a TCP

00:08:09,710 --> 00:08:15,080
socket you have no idea how much of the

00:08:12,680 --> 00:08:16,780
data you got you just got some bytes and

00:08:15,080 --> 00:08:20,090
that's it

00:08:16,780 --> 00:08:21,770
and yeah realizing that different that

00:08:20,090 --> 00:08:26,440
there's Matt it's the same methods will

00:08:21,770 --> 00:08:26,440
behave differently it's quite important

00:08:26,950 --> 00:08:33,740
so I apologize is this a little bit

00:08:31,760 --> 00:08:37,010
small I tried increasing the font size a

00:08:33,740 --> 00:08:42,050
bit over lunch but I couldn't do too

00:08:37,010 --> 00:08:46,540
much and this this is essentially the

00:08:42,050 --> 00:08:46,540
basics or for UDP

00:08:48,010 --> 00:08:53,810
there's this surprising map going on

00:08:51,200 --> 00:08:56,600
actually and so is that very first line

00:08:53,810 --> 00:08:58,600
on the server side and I'll treat as

00:08:56,600 --> 00:09:01,540
classical client-server kind of thing

00:08:58,600 --> 00:09:03,639
I create a socket with them and and the

00:09:01,540 --> 00:09:05,079
arguments are the address that and

00:09:03,639 --> 00:09:08,139
family you want in your address family

00:09:05,079 --> 00:09:11,350
is something like ipv4 ipv6 which are

00:09:08,139 --> 00:09:13,000
called F inot and I know at six and then

00:09:11,350 --> 00:09:17,199
the socket type is the next argument

00:09:13,000 --> 00:09:19,810
which is a stream or Datagram this is

00:09:17,199 --> 00:09:22,029
UDP so we pass the Datagram there is an

00:09:19,810 --> 00:09:24,040
theory a third argument to create

00:09:22,029 --> 00:09:27,519
sockets which specifies the protocol you

00:09:24,040 --> 00:09:31,269
want which would be IP Proteas UDP in

00:09:27,519 --> 00:09:33,850
this case in practice that is if you ask

00:09:31,269 --> 00:09:37,480
for an eye on a client six Datagram you

00:09:33,850 --> 00:09:41,920
will by default get UDP so usually you

00:09:37,480 --> 00:09:43,930
just leave off we don't bind the socket

00:09:41,920 --> 00:09:48,880
binding the socket tells the kernel that

00:09:43,930 --> 00:09:51,970
you want to listen on a certain IP

00:09:48,880 --> 00:09:56,560
address and port for incoming

00:09:51,970 --> 00:09:58,810
connections from other hosts you may

00:09:56,560 --> 00:10:02,740
notice that if you know how how to

00:09:58,810 --> 00:10:04,930
specify an ipv6 address in bayson that's

00:10:02,740 --> 00:10:07,329
not a valid IP v6 address because an

00:10:04,930 --> 00:10:13,300
ipv6 address is a tuple of four elements

00:10:07,329 --> 00:10:15,759
as you'll see down here actually but

00:10:13,300 --> 00:10:20,350
buying this kind of strange in that it

00:10:15,759 --> 00:10:22,420
just it's a tuple off of the end point

00:10:20,350 --> 00:10:25,839
you want to connect to want to bind to

00:10:22,420 --> 00:10:30,160
which is an IP address normally and the

00:10:25,839 --> 00:10:31,990
port number the importance of something

00:10:30,160 --> 00:10:34,240
handy in there if you pass in an empty

00:10:31,990 --> 00:10:37,029
string as the end point you wanna

00:10:34,240 --> 00:10:39,880
connect to then it will just pick the

00:10:37,029 --> 00:10:41,680
wild-card address for in whatever syntax

00:10:39,880 --> 00:10:43,930
your host operating system actually

00:10:41,680 --> 00:10:45,430
wants to do so if you want to bind to

00:10:43,930 --> 00:10:47,339
the wild-card address you use an empty

00:10:45,430 --> 00:10:51,160
string if you want to bind to a specific

00:10:47,339 --> 00:10:53,680
interface then you want your on a pass

00:10:51,160 --> 00:10:56,529
in the the IP address of that interface

00:10:53,680 --> 00:11:00,790
if you buy two specific interface you

00:10:56,529 --> 00:11:06,790
lose the ipv4 ipv6

00:11:00,790 --> 00:11:09,160
changeability short not an important

00:11:06,790 --> 00:11:12,759
number thousand fifty-five is just

00:11:09,160 --> 00:11:14,949
randomly chosen and brought up 2024 are

00:11:12,759 --> 00:11:16,629
reserved for the system so you on UNIX

00:11:14,949 --> 00:11:19,989
systems you'll need to be route in order

00:11:16,629 --> 00:11:22,569
to be able to open to listen on those

00:11:19,989 --> 00:11:23,980
sockets and there is somewhere I forget

00:11:22,569 --> 00:11:26,439
what the actual number is but there's

00:11:23,980 --> 00:11:29,769
somewhere a number port number and above

00:11:26,439 --> 00:11:32,079
that the kernel will use as a pool to

00:11:29,769 --> 00:11:36,429
create client sockets and that connects

00:11:32,079 --> 00:11:38,309
to two service Rockets so 2055 is one

00:11:36,429 --> 00:11:40,269
that as far as I know wasn't used

00:11:38,309 --> 00:11:44,980
doesn't really matter what's not using

00:11:40,269 --> 00:11:46,600
my laptop anyway just an example so the

00:11:44,980 --> 00:11:49,029
next next thing

00:11:46,600 --> 00:11:50,649
so what once it's bound the the kernel

00:11:49,029 --> 00:11:53,829
will actually be able to accept

00:11:50,649 --> 00:11:57,609
connections to that socket so the next

00:11:53,829 --> 00:12:01,299
line socket received from it's how you

00:11:57,609 --> 00:12:04,779
receive data from a UDP socket it's a

00:12:01,299 --> 00:12:07,029
blocking call so you'll that that call

00:12:04,779 --> 00:12:08,589
the block until the until there's

00:12:07,029 --> 00:12:14,339
actually a finding on accidents and some

00:12:08,589 --> 00:12:18,459
thank you the argument you give the 496

00:12:14,339 --> 00:12:21,100
for O 96 it's the maximum number of

00:12:18,459 --> 00:12:26,199
bytes you want to retrieve from your

00:12:21,100 --> 00:12:30,009
socket the there is some folklore about

00:12:26,199 --> 00:12:35,290
this that it should be ideally you page

00:12:30,009 --> 00:12:37,839
size of your RAM it's quiet I mean

00:12:35,290 --> 00:12:42,519
there's some you know truth in that

00:12:37,839 --> 00:12:44,499
probably generally it's also said to you

00:12:42,519 --> 00:12:47,499
that you should have bigger power of two

00:12:44,499 --> 00:12:51,149
as well to make just to make the copying

00:12:47,499 --> 00:12:54,100
a trammel quicker the thing is when you

00:12:51,149 --> 00:12:56,649
receive when you pick it really small

00:12:54,100 --> 00:12:58,809
you'll end up we just having to do lots

00:12:56,649 --> 00:13:00,129
of sync short calls to the kernel and

00:12:58,809 --> 00:13:02,410
and you have lots of small copy

00:13:00,129 --> 00:13:04,269
operations if you take too big you you

00:13:02,410 --> 00:13:10,539
you really using a lot of memory and all

00:13:04,269 --> 00:13:12,129
that so 4096 is a reasonable number you

00:13:10,539 --> 00:13:13,019
have often seeded up double of that as

00:13:12,129 --> 00:13:16,149
well

00:13:13,019 --> 00:13:20,139
it's one more thing that UDP it's Elvis

00:13:16,149 --> 00:13:24,190
if you receive because you lipids

00:13:20,139 --> 00:13:27,699
packets a Datagram protocol received

00:13:24,190 --> 00:13:30,430
from will return one packet at a time so

00:13:27,699 --> 00:13:33,279
you will always get exactly one packet

00:13:30,430 --> 00:13:34,720
if you had if a client sent already two

00:13:33,279 --> 00:13:35,500
packets and the colonel has got two

00:13:34,720 --> 00:13:37,570
packets in the queue

00:13:35,500 --> 00:13:39,490
you'll only get the first packets on its

00:13:37,570 --> 00:13:41,470
own and you'll just get that data and

00:13:39,490 --> 00:13:46,180
you know how much how how big that one

00:13:41,470 --> 00:13:48,880
packet to us if you pick your amount of

00:13:46,180 --> 00:13:52,720
data to receive too small so your packet

00:13:48,880 --> 00:13:55,540
is actually larger than than the data

00:13:52,720 --> 00:13:57,220
you requested you will forever lose the

00:13:55,540 --> 00:14:00,089
rest of that packet you cannot get it

00:13:57,220 --> 00:14:03,730
back the colonel just throws it away

00:14:00,089 --> 00:14:06,790
which is and I mean yeah then the client

00:14:03,730 --> 00:14:09,720
somehow needs to detect that or resend

00:14:06,790 --> 00:14:12,449
it all and that's up to protocol really

00:14:09,720 --> 00:14:17,350
but that's something to watch out for

00:14:12,449 --> 00:14:19,959
so once yeah once it's basically

00:14:17,350 --> 00:14:22,660
blocking due to get data let's switch to

00:14:19,959 --> 00:14:24,579
the client instead you'll notice that

00:14:22,660 --> 00:14:30,000
here at for the client I just create an

00:14:24,579 --> 00:14:33,100
ipv4 socket because I've ever fine it'd

00:14:30,000 --> 00:14:34,750
be because of binding to the wild-card

00:14:33,100 --> 00:14:39,760
address the server will actually receive

00:14:34,750 --> 00:14:42,089
both ipv4 and ipv6 clients so it's

00:14:39,760 --> 00:14:45,399
always best to use the wild-card address

00:14:42,089 --> 00:14:47,139
you hear a call and sent to and again it

00:14:45,399 --> 00:14:51,180
uses the ipv4 address of the server

00:14:47,139 --> 00:14:51,180
because this is just ipv4

00:14:51,990 --> 00:14:57,069
send all the same methods didn't all the

00:14:55,029 --> 00:14:59,110
different variations and return the

00:14:57,069 --> 00:15:04,709
number of bytes they actually sent

00:14:59,110 --> 00:15:07,420
across its so yeah so at that point the

00:15:04,709 --> 00:15:09,790
server will be able to receive that and

00:15:07,420 --> 00:15:12,819
if you look at the the server like

00:15:09,790 --> 00:15:15,519
returns the data itself Pakistan and the

00:15:12,819 --> 00:15:20,470
address of the client and if you look at

00:15:15,519 --> 00:15:22,630
the address its that's an ipv4 mapped IP

00:15:20,470 --> 00:15:25,630
address in ipv6 which

00:15:22,630 --> 00:15:27,520
special form of addresses that they

00:15:25,630 --> 00:15:28,720
created in actively sick space and is

00:15:27,520 --> 00:15:32,230
basically always looks like that

00:15:28,720 --> 00:15:35,290
so all zeros at the beginning than 16

00:15:32,230 --> 00:15:38,470
bits of one and enter two bits which is

00:15:35,290 --> 00:15:41,200
just a normal fee for address and that's

00:15:38,470 --> 00:15:45,250
a way of making it interoperable with

00:15:41,200 --> 00:15:49,440
with an ipv4 on the server side

00:15:45,250 --> 00:15:53,380
Dominator the last thing you'll notice

00:15:49,440 --> 00:15:56,140
is that I delete the socket object after

00:15:53,380 --> 00:15:58,690
I've closed it - just something weird

00:15:56,140 --> 00:15:59,920
there when you close the socket object

00:15:58,690 --> 00:16:03,340
it doesn't actually flows a socket

00:15:59,920 --> 00:16:04,840
object it just so kind of takes your

00:16:03,340 --> 00:16:07,900
Python object that you've got that makes

00:16:04,840 --> 00:16:10,000
it so that it becomes unusable and if

00:16:07,900 --> 00:16:11,650
you call Metis on it they will just give

00:16:10,000 --> 00:16:14,410
you exceptions but it hasn't actually

00:16:11,650 --> 00:16:16,570
closed the underlying socket the

00:16:14,410 --> 00:16:19,930
underlying socket will only close when

00:16:16,570 --> 00:16:22,090
it loses its reference count drops to

00:16:19,930 --> 00:16:25,090
zero and only Dan you will the the

00:16:22,090 --> 00:16:26,970
kernel release the resources that's a

00:16:25,090 --> 00:16:30,700
weird quirk I'm not entirely sure why

00:16:26,970 --> 00:16:34,060
they decided to do that the result of

00:16:30,700 --> 00:16:37,120
that is if I if one end closes a socket

00:16:34,060 --> 00:16:38,770
and it's not deleted yet and you use the

00:16:37,120 --> 00:16:40,510
other end will still be able to send

00:16:38,770 --> 00:16:44,890
data into it and it will just end up in

00:16:40,510 --> 00:16:47,200
the kernel buffers and client or well

00:16:44,890 --> 00:16:50,410
the other end won't know that their data

00:16:47,200 --> 00:16:52,660
is not being read by anyone anymore and

00:16:50,410 --> 00:16:55,150
it's only when when the saw could

00:16:52,660 --> 00:16:57,510
actually get actually cleaned up by the

00:16:55,150 --> 00:17:00,700
operating system

00:16:57,510 --> 00:17:03,390
later on now mention a shutdown method

00:17:00,700 --> 00:17:06,850
on the on a socket which can be used to

00:17:03,390 --> 00:17:09,850
actually close well not close the socket

00:17:06,850 --> 00:17:11,530
really and that is actually almost

00:17:09,850 --> 00:17:14,380
impossible but you can shut down the

00:17:11,530 --> 00:17:17,910
whole connection so that the both sides

00:17:14,380 --> 00:17:22,620
will know that the other side has gone

00:17:17,910 --> 00:17:26,740
and that's yeah that's mostly basics of

00:17:22,620 --> 00:17:30,190
UDP I think hopefully I've said

00:17:26,740 --> 00:17:34,150
everything on this side yeah

00:17:30,190 --> 00:17:36,419
the only thing extra here is the output

00:17:34,150 --> 00:17:40,470
of netstat on unit

00:17:36,419 --> 00:17:43,090
it's nice to be able to have a look

00:17:40,470 --> 00:17:45,549
after you've called the bank method on

00:17:43,090 --> 00:17:48,460
on your on your server socket you will

00:17:45,549 --> 00:17:51,400
be able to see a line like this saying

00:17:48,460 --> 00:17:53,860
UDP six and the local address it's

00:17:51,400 --> 00:17:56,590
listening on this is something like

00:17:53,860 --> 00:17:58,419
that's actually the ipv6 address that's

00:17:56,590 --> 00:18:00,490
done the call and then that's the port

00:17:58,419 --> 00:18:06,309
number which is slightly hard to read

00:18:00,490 --> 00:18:08,799
but so yeah it helps with them if you're

00:18:06,309 --> 00:18:11,230
not sure what you sockets are doing to

00:18:08,799 --> 00:18:13,720
find out what's going on this one more

00:18:11,230 --> 00:18:15,010
thing it can do it you'd be sockets and

00:18:13,720 --> 00:18:18,100
that is connecting them

00:18:15,010 --> 00:18:22,630
this is he really only useful for when

00:18:18,100 --> 00:18:27,610
you when you do it from a client if you

00:18:22,630 --> 00:18:29,500
connect to a specific end point you can

00:18:27,610 --> 00:18:31,000
only receive data from that end point

00:18:29,500 --> 00:18:33,520
and equal in some data to at the end

00:18:31,000 --> 00:18:35,620
point allows you to use just a normal

00:18:33,520 --> 00:18:37,059
sound method instead of send to you can

00:18:35,620 --> 00:18:41,830
you use to receive as well instead of

00:18:37,059 --> 00:18:44,350
receive from it's essentially the and it

00:18:41,830 --> 00:18:45,730
makes it slightly easy because the the

00:18:44,350 --> 00:18:47,169
colonel does the filtering for you you

00:18:45,730 --> 00:18:50,130
don't have to check oh did I actually

00:18:47,169 --> 00:18:52,059
expect data from from this end point

00:18:50,130 --> 00:18:54,760
because the Kerner will already have

00:18:52,059 --> 00:19:01,950
done that filtering for you and so

00:18:54,760 --> 00:19:06,960
that's yeah that's a benefit as well so

00:19:01,950 --> 00:19:11,710
tcp is builds on on the same kind of

00:19:06,960 --> 00:19:13,980
pattern the extra thing here so yeah

00:19:11,710 --> 00:19:17,850
again you can create a nine at six

00:19:13,980 --> 00:19:22,360
socket and you can receive a v4 and v6

00:19:17,850 --> 00:19:24,340
clients so the so crazy locking system

00:19:22,360 --> 00:19:27,150
binding is the same then the new thing

00:19:24,340 --> 00:19:30,070
is calling that listen

00:19:27,150 --> 00:19:33,280
so when you create a server socket in

00:19:30,070 --> 00:19:37,120
DCP it's not a normal socket and that

00:19:33,280 --> 00:19:41,290
can transfer data across it's only a

00:19:37,120 --> 00:19:44,620
socket that you can call except on and

00:19:41,290 --> 00:19:45,850
then we create a new socket for you once

00:19:44,620 --> 00:19:49,030
a client is connected

00:19:45,850 --> 00:19:51,039
to it you receive a new client socket

00:19:49,030 --> 00:19:52,780
and that client socket can actually

00:19:51,039 --> 00:19:53,530
transfer data with send and receive as

00:19:52,780 --> 00:19:56,289
you used to

00:19:53,530 --> 00:19:57,880
so when you create a service socrata

00:19:56,289 --> 00:20:02,740
thing you can really do is call accept

00:19:57,880 --> 00:20:06,100
on it and the listen call above it it's

00:20:02,740 --> 00:20:09,340
so accept is also a blocking call so if

00:20:06,100 --> 00:20:10,690
a client so if you call it a client

00:20:09,340 --> 00:20:14,010
connects and then you receive the

00:20:10,690 --> 00:20:18,429
clients socket that gets created for you

00:20:14,010 --> 00:20:20,260
the the listen call then is essentially

00:20:18,429 --> 00:20:22,510
saying if another client connects at the

00:20:20,260 --> 00:20:25,150
same time then then you got two clients

00:20:22,510 --> 00:20:27,520
queued up wanting to be accepted and the

00:20:25,150 --> 00:20:29,230
listen call specifies how many clients

00:20:27,520 --> 00:20:33,730
you're allowed to how many clients the

00:20:29,230 --> 00:20:37,270
kernel is allowed to queue up people

00:20:33,730 --> 00:20:39,130
usually pick you used to pick quite

00:20:37,270 --> 00:20:43,419
small numbers or something like five or

00:20:39,130 --> 00:20:44,799
something it depends on how how many

00:20:43,419 --> 00:20:48,460
clients you want to be able to handle it

00:20:44,799 --> 00:20:49,990
at one at the same time if if that queue

00:20:48,460 --> 00:20:54,309
is full then then the kernel won't be

00:20:49,990 --> 00:20:55,690
able to then the kernel will reject the

00:20:54,309 --> 00:20:57,549
client connections and the clients will

00:20:55,690 --> 00:21:03,010
have to go oh service unavailable or

00:20:57,549 --> 00:21:04,270
something and retry etc in practice you

00:21:03,010 --> 00:21:06,520
probably need to do a little bit of

00:21:04,270 --> 00:21:08,289
benchmarking or you can just use that

00:21:06,520 --> 00:21:10,870
constant in a socket module a so a

00:21:08,289 --> 00:21:13,330
maximum which is the maximum number

00:21:10,870 --> 00:21:16,690
that's the kernel will allow you to use

00:21:13,330 --> 00:21:18,820
in there which is a fairly saying that

00:21:16,690 --> 00:21:23,320
default if if you're actually handling

00:21:18,820 --> 00:21:26,799
your clients fairly quickly after that

00:21:23,320 --> 00:21:28,690
it looks very similar again you call

00:21:26,799 --> 00:21:30,309
them so you call accept you get your

00:21:28,690 --> 00:21:33,130
client socket and once you've got your

00:21:30,309 --> 00:21:39,179
client socket you can send the receive

00:21:33,130 --> 00:21:43,240
data in very much the same way and

00:21:39,179 --> 00:21:46,000
that's probably yeah that that's

00:21:43,240 --> 00:21:50,470
essentially the the the special bit

00:21:46,000 --> 00:21:52,270
about um PCP if you're looking at like

00:21:50,470 --> 00:21:55,330
nets that I've put to see what's going

00:21:52,270 --> 00:21:57,700
on after binding the socket you won't be

00:21:55,330 --> 00:21:59,470
able to see their soccer ass listening

00:21:57,700 --> 00:22:03,340
yet it's only when you call listen

00:21:59,470 --> 00:22:05,350
that it will start showing up as the

00:22:03,340 --> 00:22:07,600
soccer is listening once a client is

00:22:05,350 --> 00:22:12,730
connected you you should be able to see

00:22:07,600 --> 00:22:15,549
two entries sliders said saying because

00:22:12,730 --> 00:22:17,590
because this piece is stateful the

00:22:15,549 --> 00:22:19,539
kernel has this information about who is

00:22:17,590 --> 00:22:20,950
connected to who and and you can see the

00:22:19,539 --> 00:22:27,600
state they're in

00:22:20,950 --> 00:22:33,220
so it's an established connection and

00:22:27,600 --> 00:22:34,960
I've said this as well doesn't know yeah

00:22:33,220 --> 00:22:38,260
obviously the other very important thing

00:22:34,960 --> 00:22:41,590
and on TCP socket is when you call maybe

00:22:38,260 --> 00:22:46,240
I should go back when you call receive

00:22:41,590 --> 00:22:46,990
or send you you don't know how much data

00:22:46,240 --> 00:22:48,970
you get here

00:22:46,990 --> 00:22:51,130
I called receive on that and I've got

00:22:48,970 --> 00:22:53,950
the entire message that was kind of pure

00:22:51,130 --> 00:22:55,539
luck just because I was doing on my

00:22:53,950 --> 00:22:58,600
local host and nothing much gets in

00:22:55,539 --> 00:23:00,580
between but it could be that one I call

00:22:58,600 --> 00:23:02,770
receive on there because it is a stream

00:23:00,580 --> 00:23:04,900
of data without a beginning or an end I

00:23:02,770 --> 00:23:08,350
could have just received half of it or

00:23:04,900 --> 00:23:09,909
something like that oh yeah and I should

00:23:08,350 --> 00:23:13,390
say Sandahl as well

00:23:09,909 --> 00:23:15,909
similarly Sandahl it's kind of when you

00:23:13,390 --> 00:23:18,870
call just send on a TCP socket if the if

00:23:15,909 --> 00:23:21,250
the kernel has buffers are full it will

00:23:18,870 --> 00:23:23,320
say if you send a sense and some data

00:23:21,250 --> 00:23:25,809
across the dependent will try and send

00:23:23,320 --> 00:23:28,270
that data across but once it's it's own

00:23:25,809 --> 00:23:30,100
but if network buffers are full it will

00:23:28,270 --> 00:23:33,549
stop sending it and it may have sent

00:23:30,100 --> 00:23:35,770
half the message by then and then it

00:23:33,549 --> 00:23:38,710
would tell the sound will then return

00:23:35,770 --> 00:23:40,299
the number of bytes sent and if you know

00:23:38,710 --> 00:23:42,820
that you actually try to send more bytes

00:23:40,299 --> 00:23:45,220
you don't have to go and try sent again

00:23:42,820 --> 00:23:46,900
with the rest of your message do put

00:23:45,220 --> 00:23:49,179
those on the bytes hoping that kernel

00:23:46,900 --> 00:23:50,990
eventually will have space on its all

00:23:49,179 --> 00:23:54,140
its cues again

00:23:50,990 --> 00:23:56,059
so so usually you end up having to write

00:23:54,140 --> 00:23:57,500
a little little while true loop or

00:23:56,059 --> 00:23:58,909
something like that to send all to make

00:23:57,500 --> 00:24:00,980
sure all your data across if you just

00:23:58,909 --> 00:24:02,529
call Sam on the TCP socket you you don't

00:24:00,980 --> 00:24:05,480
know if your data sent across

00:24:02,529 --> 00:24:07,340
Sandahl does exactly that little looper

00:24:05,480 --> 00:24:08,840
but it does it's in the socket module

00:24:07,340 --> 00:24:18,710
it's implemented in C so it's a little

00:24:08,840 --> 00:24:22,370
bit faster so that's yeah sorry no there

00:24:18,710 --> 00:24:24,909
isn't just because there is no ant did

00:24:22,370 --> 00:24:34,929
it stream it's a stream of lights

00:24:24,909 --> 00:24:34,929
you don't ever know you know

00:24:37,250 --> 00:24:55,410
yeah I receive what's happened receive

00:24:41,550 --> 00:24:57,600
all it's just Debbie I'll okay t speech

00:24:55,410 --> 00:25:00,150
state diagram it's kind of you don't

00:24:57,600 --> 00:25:01,770
really need to know with us it's it's

00:25:00,150 --> 00:25:03,180
good to know it's exist and you can you

00:25:01,770 --> 00:25:05,040
can search for it when it when you've

00:25:03,180 --> 00:25:06,570
got issues and you can see what what

00:25:05,040 --> 00:25:09,390
trying to figure out what's going on

00:25:06,570 --> 00:25:11,220
with you socket the one thing I will

00:25:09,390 --> 00:25:13,650
point out here is it's basically the

00:25:11,220 --> 00:25:16,020
lifecycle of what a TCP socket goes

00:25:13,650 --> 00:25:18,150
through as you create it and then you

00:25:16,020 --> 00:25:19,770
connect etc and the different things

00:25:18,150 --> 00:25:21,540
your application can do what what it

00:25:19,770 --> 00:25:23,370
there from comes from the other end the

00:25:21,540 --> 00:25:25,710
one important thing down here is this

00:25:23,370 --> 00:25:27,270
time wage state right at the end of the

00:25:25,710 --> 00:25:28,680
conversation because TCP tries to give

00:25:27,270 --> 00:25:31,590
you guarantees about all data is

00:25:28,680 --> 00:25:33,480
delivered in order etc the curls need to

00:25:31,590 --> 00:25:35,790
do quite a lot of buffering and make and

00:25:33,480 --> 00:25:39,870
you know reorder stuff so that you get

00:25:35,790 --> 00:25:42,360
it exactly in the right order and right

00:25:39,870 --> 00:25:43,470
at the end because because IP delay

00:25:42,360 --> 00:25:45,840
they're building on this it's not

00:25:43,470 --> 00:25:47,520
reliable at all right at the end that

00:25:45,840 --> 00:25:49,980
they when they've shut down the

00:25:47,520 --> 00:25:53,130
connection they keep the socket open for

00:25:49,980 --> 00:25:54,750
a certain time based on latency that

00:25:53,130 --> 00:25:56,190
they received on that connection to test

00:25:54,750 --> 00:25:58,350
out before they try to do clever stuff

00:25:56,190 --> 00:26:02,390
but they keep the socket open even after

00:25:58,350 --> 00:26:02,390
you've shut it down from the application

00:26:03,110 --> 00:26:08,670
so if you if you happen to restart your

00:26:06,570 --> 00:26:11,820
application while that socket is still

00:26:08,670 --> 00:26:13,950
open you'll get something any trying to

00:26:11,820 --> 00:26:17,280
bind to that address it will say it's

00:26:13,950 --> 00:26:19,350
already in use and you can't use it and

00:26:17,280 --> 00:26:20,550
that's that's something forced for

00:26:19,350 --> 00:26:23,280
server application that's a fairly

00:26:20,550 --> 00:26:29,700
common problem which kind of leads us

00:26:23,280 --> 00:26:34,320
onto the next item which is sock

00:26:29,700 --> 00:26:35,850
adoptions really they're from a

00:26:34,320 --> 00:26:37,380
practical point of view there's lots of

00:26:35,850 --> 00:26:41,270
sock adoptions but from practical point

00:26:37,380 --> 00:26:46,520
of view this as a really really dress is

00:26:41,270 --> 00:26:46,520
the only one you likely to use often

00:26:47,450 --> 00:26:53,209
and this one tells you when when the run

00:26:50,269 --> 00:26:56,469
the socket is in time wait state it the

00:26:53,209 --> 00:27:00,079
kernel will allow you to creating a new

00:26:56,469 --> 00:27:03,309
Bob bind to that socket again and wait

00:27:00,079 --> 00:27:03,309
for incoming connections again

00:27:03,820 --> 00:27:11,570
so yes the because set socket options go

00:27:09,259 --> 00:27:14,599
god there's if you read the man pages of

00:27:11,570 --> 00:27:17,059
like TCP UDP and all those things you'll

00:27:14,599 --> 00:27:18,950
get find out that each layer in the

00:27:17,059 --> 00:27:21,099
stack actually has a lot of protocol

00:27:18,950 --> 00:27:25,249
options so that's why you have the first

00:27:21,099 --> 00:27:27,549
parameters is the level of in the stack

00:27:25,249 --> 00:27:30,109
that you want to work on which is um

00:27:27,549 --> 00:27:32,749
soccer in this case then you set the

00:27:30,109 --> 00:27:38,059
option to whatever value needs to be for

00:27:32,749 --> 00:27:40,969
a serious address it's 0 or 1 and that

00:27:38,059 --> 00:27:42,379
is for normal usage that's really the

00:27:40,969 --> 00:27:44,619
only socket options you're going to

00:27:42,379 --> 00:27:44,619
encounter

00:27:45,969 --> 00:27:53,539
then name resolution you probably all

00:27:50,899 --> 00:27:55,999
know the DNS system it's it's a fairly

00:27:53,539 --> 00:27:58,579
complex stuff and lots of stuff goes on

00:27:55,999 --> 00:28:02,859
over the network as well essentially try

00:27:58,579 --> 00:28:06,079
to it try try to not use the old fee for

00:28:02,859 --> 00:28:09,709
functions but use the ipv6 compatible

00:28:06,079 --> 00:28:12,950
ones at bottom I'll talk a bit more

00:28:09,709 --> 00:28:15,429
about get out there info get name info

00:28:12,950 --> 00:28:17,389
does the reverse so if you reverse

00:28:15,429 --> 00:28:20,539
hostname lookup so if you've got an IP

00:28:17,389 --> 00:28:24,469
address on first name not use that as

00:28:20,539 --> 00:28:28,489
often get out there in forever it's a

00:28:24,469 --> 00:28:30,289
very complicated function really am look

00:28:28,489 --> 00:28:33,109
it's really hard to implement as well

00:28:30,289 --> 00:28:36,379
it's you don't be surprised if you find

00:28:33,109 --> 00:28:40,190
it slightly buggy as well so certainly

00:28:36,379 --> 00:28:41,599
in libraries that emulate this lips in

00:28:40,190 --> 00:28:44,539
resolver libraries etc

00:28:41,599 --> 00:28:47,779
Lipsy tends to do a fairly good job of

00:28:44,539 --> 00:28:51,139
it and it's got a bunch of parameters

00:28:47,779 --> 00:28:57,469
and stuff the importance of stuff here

00:28:51,139 --> 00:28:59,629
really is the the hostname you pass in

00:28:57,469 --> 00:29:02,450
you can use non there but that's really

00:28:59,629 --> 00:29:05,239
special case kind of depends on non is

00:29:02,450 --> 00:29:08,179
normally the localhost but apart from

00:29:05,239 --> 00:29:10,249
when you pass in this special flag but

00:29:08,179 --> 00:29:13,159
you don't really tend to do that anyway

00:29:10,249 --> 00:29:14,719
you only tend to do that if if you're

00:29:13,159 --> 00:29:16,999
creating a server and you actually ask

00:29:14,719 --> 00:29:18,979
the user what interface should I be

00:29:16,999 --> 00:29:20,479
listening on because otherwise you just

00:29:18,979 --> 00:29:24,099
use the wild-card to address and you

00:29:20,479 --> 00:29:28,599
don't need to look up any host names

00:29:24,099 --> 00:29:30,859
port as well port can be a service named

00:29:28,599 --> 00:29:33,679
jack support number in which case you

00:29:30,859 --> 00:29:37,009
don't really care and on again

00:29:33,679 --> 00:29:38,269
normos if you don't care and that's kind

00:29:37,009 --> 00:29:40,459
of a special case as well that if you

00:29:38,269 --> 00:29:41,809
used to be you work with tcp and UDP you

00:29:40,459 --> 00:29:45,109
know you're always going to on the port

00:29:41,809 --> 00:29:47,089
number but but if you don't care about

00:29:45,109 --> 00:29:49,729
the port number don't put in a random

00:29:47,089 --> 00:29:51,919
port number because you probably get bad

00:29:49,729 --> 00:29:53,239
stuff back that doesn't actually match

00:29:51,919 --> 00:29:54,889
using norm if you if you don't care

00:29:53,239 --> 00:29:56,269
about it and if you want to use a

00:29:54,889 --> 00:30:01,759
service name basically don't use a

00:29:56,269 --> 00:30:03,649
service name because it's do SS all

00:30:01,759 --> 00:30:04,940
configured is differently and they may

00:30:03,649 --> 00:30:06,859
not all be set up the same way

00:30:04,940 --> 00:30:10,339
for example if you if you try and use

00:30:06,859 --> 00:30:13,669
www in there on some OS it will work on

00:30:10,339 --> 00:30:15,019
others in want just because their

00:30:13,669 --> 00:30:17,629
default confirmation doesn't include it

00:30:15,019 --> 00:30:20,149
for some reason so the only thing you

00:30:17,629 --> 00:30:22,069
can do that and that's really in the

00:30:20,149 --> 00:30:24,379
grasp of the system administrator so the

00:30:22,069 --> 00:30:27,879
only thing you can do though is if if

00:30:24,379 --> 00:30:31,219
you give the option to user to specify

00:30:27,879 --> 00:30:33,200
the port number then and then they can

00:30:31,219 --> 00:30:34,429
decide to use a service name and then

00:30:33,200 --> 00:30:36,289
it's up to them to make sure that that

00:30:34,429 --> 00:30:38,779
service name actually will resolve to

00:30:36,289 --> 00:30:40,069
the port number they want to use but if

00:30:38,779 --> 00:30:43,579
you're doing if your hard coding

00:30:40,069 --> 00:30:45,889
something just you use the use the port

00:30:43,579 --> 00:30:50,950
number that you know you want don't try

00:30:45,889 --> 00:30:53,059
to put put in your name other than that

00:30:50,950 --> 00:30:56,450
basically the general rule is try and

00:30:53,059 --> 00:31:00,889
specify as much information as you know

00:30:56,450 --> 00:31:02,479
in to the Guardian phone call you you

00:31:00,889 --> 00:31:05,570
get better results back that way

00:31:02,479 --> 00:31:08,150
essentially flags

00:31:05,570 --> 00:31:10,460
is that there's even more flags than the

00:31:08,150 --> 00:31:13,070
ones here I'm only going to mention the

00:31:10,460 --> 00:31:15,320
canonical name one actually if you if

00:31:13,070 --> 00:31:16,670
you wanna it's it's a handy thing if you

00:31:15,320 --> 00:31:19,280
want to say to the user

00:31:16,670 --> 00:31:22,820
oh I'm connecting to this host it's it's

00:31:19,280 --> 00:31:24,830
useful to know what to have a half it

00:31:22,820 --> 00:31:26,720
gives you sort of a reverse lookup as

00:31:24,830 --> 00:31:28,520
well but the important thing when you

00:31:26,720 --> 00:31:31,010
use canonical name is in the return

00:31:28,520 --> 00:31:33,980
value you get the return value is a list

00:31:31,010 --> 00:31:37,070
of results and the canonical name is

00:31:33,980 --> 00:31:39,260
only ever set in the first item in that

00:31:37,070 --> 00:31:40,520
list all the other items will have an

00:31:39,260 --> 00:31:49,070
empty string full canonical name

00:31:40,520 --> 00:31:53,960
returned so yeah this is an example if

00:31:49,070 --> 00:31:57,710
using it basically yeah the top example

00:31:53,960 --> 00:31:59,750
tries to specify as much as possible but

00:31:57,710 --> 00:32:01,460
again you know usually this will usually

00:31:59,750 --> 00:32:04,220
so we find usually you'll get a list of

00:32:01,460 --> 00:32:05,510
results that that actually matches and

00:32:04,220 --> 00:32:11,960
at the end point you're trying to

00:32:05,510 --> 00:32:14,960
connect to protocol you really always

00:32:11,960 --> 00:32:18,380
need to get at least stream or Datagram

00:32:14,960 --> 00:32:22,400
in because that those port numbers will

00:32:18,380 --> 00:32:24,200
change depending sometimes not later

00:32:22,400 --> 00:32:25,850
services anymore because they realized

00:32:24,200 --> 00:32:28,280
that was a bad design decision to change

00:32:25,850 --> 00:32:30,680
port numbers between TCP and UDP but

00:32:28,280 --> 00:32:36,530
it's important to at least specify the

00:32:30,680 --> 00:32:38,000
stream but in practice usually if if

00:32:36,530 --> 00:32:39,440
you're if you're a client connecting

00:32:38,000 --> 00:32:42,080
which is most of the time as serve we

00:32:39,440 --> 00:32:47,630
usually don't have to do an address

00:32:42,080 --> 00:32:51,680
lookup and in but in practice basically

00:32:47,630 --> 00:32:53,450
do both the results you just yeah

00:32:51,680 --> 00:32:56,360
people tend to just specify up to that

00:32:53,450 --> 00:32:59,990
so saying what do you want streamer or

00:32:56,360 --> 00:33:02,750
Datagram socket the one before saying

00:32:59,990 --> 00:33:07,220
you want this is what we want

00:33:02,750 --> 00:33:10,540
ipv4 ipv6 0 or air phones but and spec

00:33:07,220 --> 00:33:13,370
it gives you both and you basically just

00:33:10,540 --> 00:33:16,040
because search so so many things could

00:33:13,370 --> 00:33:18,140
be going on and and sometimes sometimes

00:33:16,040 --> 00:33:18,800
they are just buggy and you just try and

00:33:18,140 --> 00:33:20,540
loop

00:33:18,800 --> 00:33:23,240
over all the results that it gives you

00:33:20,540 --> 00:33:26,180
try do you get a connection then yes

00:33:23,240 --> 00:33:28,310
good luck carry on using that socket if

00:33:26,180 --> 00:33:33,530
not just go to next one and only break

00:33:28,310 --> 00:33:36,710
and fail at the end and that's exactly

00:33:33,530 --> 00:33:39,020
what create address helper function in

00:33:36,710 --> 00:33:43,880
the stock of module does as well the

00:33:39,020 --> 00:33:45,410
only thing there is that it's only for

00:33:43,880 --> 00:33:49,520
stream sockets it will not do that for

00:33:45,410 --> 00:33:52,580
UDP sockets there the it's a slightly

00:33:49,520 --> 00:33:57,200
weird API because host port again looks

00:33:52,580 --> 00:34:03,380
like an ipv4 address returns those IP

00:33:57,200 --> 00:34:08,440
for ipv6 and the other yeah the other

00:34:03,380 --> 00:34:11,870
two really not used after now I find

00:34:08,440 --> 00:34:13,580
that yeah if you want to start from a

00:34:11,870 --> 00:34:18,020
specific source address and prime artis

00:34:13,580 --> 00:34:19,730
is a is another tool that standard

00:34:18,020 --> 00:34:22,640
library provides from socket objects as

00:34:19,730 --> 00:34:24,760
well gives you a timeout but it's only

00:34:22,640 --> 00:34:28,850
really useful when you do simple

00:34:24,760 --> 00:34:30,740
sequential blocking calls in practice I

00:34:28,850 --> 00:34:34,040
find you know that's a fairly simplistic

00:34:30,740 --> 00:34:36,970
use case if it's it's alright it's nice

00:34:34,040 --> 00:34:42,140
for writing a quick script basically but

00:34:36,970 --> 00:34:43,850
yeah and then the yeah a quick note on

00:34:42,140 --> 00:34:45,530
the acceptance you get back out of out

00:34:43,850 --> 00:34:47,060
of socket so yeah the exception is

00:34:45,530 --> 00:34:49,429
always socrata error which is actually

00:34:47,060 --> 00:34:51,919
so across the firm IO error so you could

00:34:49,429 --> 00:34:53,960
catch that as well but if your honor if

00:34:51,919 --> 00:34:58,250
you want a nice user readable message

00:34:53,960 --> 00:35:03,740
you can use this error attribute makes

00:34:58,250 --> 00:35:06,230
it makes that something nice so non

00:35:03,740 --> 00:35:07,460
blocking sockets this is it's much it's

00:35:06,230 --> 00:35:09,680
more interesting if you're actually

00:35:07,460 --> 00:35:11,780
doing more complicated stuff you you

00:35:09,680 --> 00:35:16,930
wanna you want to handle multiple

00:35:11,780 --> 00:35:19,370
sockets in one one program really

00:35:16,930 --> 00:35:21,470
essentially the basics of it's very

00:35:19,370 --> 00:35:23,270
simple you just called said blocking

00:35:21,470 --> 00:35:24,620
false on it and then if you try and

00:35:23,270 --> 00:35:28,460
receive something but there was no one

00:35:24,620 --> 00:35:32,380
no there's no data sent up on it you get

00:35:28,460 --> 00:35:36,290
an exception this time I catch you

00:35:32,380 --> 00:35:38,630
and and if it's you need to check the

00:35:36,290 --> 00:35:41,020
our number and it if it would be

00:35:38,630 --> 00:35:43,490
blocking you would get you would block

00:35:41,020 --> 00:35:44,390
which comes from the renewal module by

00:35:43,490 --> 00:35:49,370
the way you have to import that

00:35:44,390 --> 00:35:50,810
separately but if you if you tried to do

00:35:49,370 --> 00:35:55,670
this by hand it will quickly get messy

00:35:50,810 --> 00:35:59,060
which is why we're usually 205 select

00:35:55,670 --> 00:36:01,550
come in select it's like one of a small

00:35:59,060 --> 00:36:05,240
family of little tools that can

00:36:01,550 --> 00:36:07,700
basically multiplex tell you when a

00:36:05,240 --> 00:36:10,310
socket is ready to do something that

00:36:07,700 --> 00:36:12,920
there's like Paul Andy Paul and KQ on

00:36:10,310 --> 00:36:15,110
different devices in order but select is

00:36:12,920 --> 00:36:17,450
also the most portable one and if you if

00:36:15,110 --> 00:36:19,460
you actually end up writing a simple

00:36:17,450 --> 00:36:20,450
loop yourself you're probably select

00:36:19,460 --> 00:36:23,660
it's probably going to be performing

00:36:20,450 --> 00:36:24,860
enough because if if it's not then you

00:36:23,660 --> 00:36:26,210
probably shouldn't be writing it

00:36:24,860 --> 00:36:29,300
yourself and use the library that does

00:36:26,210 --> 00:36:31,090
it for you so I would say just you

00:36:29,300 --> 00:36:37,570
select even though it's not the fastest

00:36:31,090 --> 00:36:40,610
it's just the only thing here so select

00:36:37,570 --> 00:36:42,740
you you give it a you give it a number

00:36:40,610 --> 00:36:44,990
of lists of sockets you're interested in

00:36:42,740 --> 00:36:46,640
and you say I want to read from this

00:36:44,990 --> 00:36:49,870
list of sockets I'm interested in

00:36:46,640 --> 00:36:53,630
writing it writing to these sockets and

00:36:49,870 --> 00:36:55,100
then select will return saying OD so

00:36:53,630 --> 00:36:57,680
could study that you wanted to read from

00:36:55,100 --> 00:37:02,360
this one is okay you can read from now

00:36:57,680 --> 00:37:05,720
and in the same for the right sockets

00:37:02,360 --> 00:37:09,650
the exceptional condition ones the third

00:37:05,720 --> 00:37:12,410
one it's really something you don't use

00:37:09,650 --> 00:37:14,600
them that's like weird features in in T

00:37:12,410 --> 00:37:17,390
speed that I like out-of-band

00:37:14,600 --> 00:37:18,650
communication stuff like that and it's

00:37:17,390 --> 00:37:20,420
something that in practice doesn't

00:37:18,650 --> 00:37:22,340
really get used they thought it was a

00:37:20,420 --> 00:37:25,580
neat idea when they were designing the

00:37:22,340 --> 00:37:27,940
protocols and and its really relating to

00:37:25,580 --> 00:37:30,680
that sort of stuff

00:37:27,940 --> 00:37:34,010
in practice it's not like something has

00:37:30,680 --> 00:37:36,920
gone wrong with your socket condition as

00:37:34,010 --> 00:37:38,600
you might be misled to think H it's a

00:37:36,920 --> 00:37:42,580
sort of condition that you usually don't

00:37:38,600 --> 00:37:44,750
you need for for normal usage

00:37:42,580 --> 00:37:46,420
lastly timeout it's

00:37:44,750 --> 00:37:49,460
because this is a blocking system called

00:37:46,420 --> 00:37:51,080
so so you can say when when you want to

00:37:49,460 --> 00:37:53,120
give up waiting for it if you want to

00:37:51,080 --> 00:37:55,820
regularly wake up or something

00:37:53,120 --> 00:37:58,340
you should really specify time and I

00:37:55,820 --> 00:38:01,970
find it in practice usually even if I

00:37:58,340 --> 00:38:04,940
don't if I if I know I want to block

00:38:01,970 --> 00:38:07,180
forever for example I still put it in a

00:38:04,940 --> 00:38:10,400
loop for the time out to for 60 seconds

00:38:07,180 --> 00:38:11,900
so that if something gone badly wrong

00:38:10,400 --> 00:38:18,740
you had you have a chance of ever

00:38:11,900 --> 00:38:22,940
getting out of it one one way of using

00:38:18,740 --> 00:38:24,470
this is a gracefully interrupting

00:38:22,940 --> 00:38:31,370
basically because because on your

00:38:24,470 --> 00:38:34,070
blocking calls it's yeah as I said if if

00:38:31,370 --> 00:38:36,890
you blocking forever you can never get

00:38:34,070 --> 00:38:39,560
out of it so sometimes you a way of

00:38:36,890 --> 00:38:42,410
easily waking up that that i/o loop that

00:38:39,560 --> 00:38:45,680
you're writing with and selects is by

00:38:42,410 --> 00:38:48,170
creating this OS though using OS dock

00:38:45,680 --> 00:38:50,950
pipe which create two two ends of pipe

00:38:48,170 --> 00:38:55,670
and and you can write read and write to

00:38:50,950 --> 00:38:58,520
one end or from the other and you can

00:38:55,670 --> 00:39:01,990
use that to wake up your i/o loop just

00:38:58,520 --> 00:39:04,730
make sure you're empty you emptied the

00:39:01,990 --> 00:39:07,730
you empty the pipe whenever you wake it

00:39:04,730 --> 00:39:09,560
up if you if you want to if your loop

00:39:07,730 --> 00:39:14,660
needs to break foot for waking up or

00:39:09,560 --> 00:39:16,760
something whatever you can do that the

00:39:14,660 --> 00:39:18,530
main thing to watch out if you use a

00:39:16,760 --> 00:39:19,730
riser pipe is you actually returns file

00:39:18,530 --> 00:39:21,770
descriptor number so they're only

00:39:19,730 --> 00:39:24,080
numbers not socket objects which is why

00:39:21,770 --> 00:39:26,060
you need use OS that read on it and also

00:39:24,080 --> 00:39:31,550
write rather than just calling don't

00:39:26,060 --> 00:39:33,920
send or receive or read all right so so

00:39:31,550 --> 00:39:39,560
that's the basics of creating a simple

00:39:33,920 --> 00:39:41,420
i/o loop and that kind of also brings us

00:39:39,560 --> 00:39:44,840
on to handling signals this is something

00:39:41,420 --> 00:39:47,000
that's often overlooked but basically

00:39:44,840 --> 00:39:48,320
that your program could could be

00:39:47,000 --> 00:39:52,190
receiving signals for for lots of

00:39:48,320 --> 00:39:53,960
reasons usually you get a system if you

00:39:52,190 --> 00:39:55,310
want to shut down or something or but

00:39:53,960 --> 00:39:56,900
there might be sick UPS

00:39:55,310 --> 00:39:58,430
we'll usually define signals of

00:39:56,900 --> 00:40:00,140
something and certainly when you're

00:39:58,430 --> 00:40:04,400
writing a library you don't know what

00:40:00,140 --> 00:40:05,990
what people are going to use it for so

00:40:04,400 --> 00:40:07,280
and an assistant course will get

00:40:05,990 --> 00:40:10,700
interrupted basically when there is a

00:40:07,280 --> 00:40:13,640
signal and they'll stop and you'll have

00:40:10,700 --> 00:40:14,540
to restart them this is not actually bad

00:40:13,640 --> 00:40:16,070
thing really

00:40:14,540 --> 00:40:19,910
despite fact that's actually quite

00:40:16,070 --> 00:40:22,100
annoying because if you're in a blocking

00:40:19,910 --> 00:40:23,870
call you you wanna and and someone sends

00:40:22,100 --> 00:40:27,500
you sick term and you want to do some

00:40:23,870 --> 00:40:29,150
some downloads your comm system if it

00:40:27,500 --> 00:40:31,370
was a blocking call you would never get

00:40:29,150 --> 00:40:33,770
out of it unless you together if you're

00:40:31,370 --> 00:40:35,980
writing in an i/o loop you probably have

00:40:33,770 --> 00:40:38,630
a mechanism of waking up your your loops

00:40:35,980 --> 00:40:39,800
separately and which you can do from a

00:40:38,630 --> 00:40:42,920
signal handler or something like that

00:40:39,800 --> 00:40:45,650
and in that case you know you need a

00:40:42,920 --> 00:40:52,520
little while true loop to just keep

00:40:45,650 --> 00:40:55,160
receiving if you get interrupted yeah in

00:40:52,520 --> 00:40:57,860
in blocking code you know be careful

00:40:55,160 --> 00:40:59,210
that you don't get your signals if you

00:40:57,860 --> 00:41:00,920
want to go out of the application and

00:40:59,210 --> 00:41:03,860
just go and restart it again and then

00:41:00,920 --> 00:41:05,150
you're blocked again and as a library

00:41:03,860 --> 00:41:07,070
you need to be slightly aware of that as

00:41:05,150 --> 00:41:09,260
well if you're writing just a simple

00:41:07,070 --> 00:41:11,000
application you can use this in the

00:41:09,260 --> 00:41:12,170
signal module sig interrupts you can say

00:41:11,000 --> 00:41:15,130
oh I don't actually want to be

00:41:12,170 --> 00:41:19,130
interrupted so Python will just for you

00:41:15,130 --> 00:41:22,760
restart the system calls but it's only

00:41:19,130 --> 00:41:26,600
if you control the whole application

00:41:22,760 --> 00:41:31,340
really and then handling stream data is

00:41:26,600 --> 00:41:32,690
a an interesting topic owl running out

00:41:31,340 --> 00:41:34,150
of time so I'll have to go through that

00:41:32,690 --> 00:41:37,190
fairly quickly

00:41:34,150 --> 00:41:41,570
basically because because on TCP it's

00:41:37,190 --> 00:41:44,180
just a stream of bytes you need to

00:41:41,570 --> 00:41:45,440
somehow generally unique you need to

00:41:44,180 --> 00:41:46,790
have a buffer and and collect those

00:41:45,440 --> 00:41:49,640
bytes until you know you've got enough

00:41:46,790 --> 00:41:52,520
of them and try and pass a packet or a

00:41:49,640 --> 00:41:54,770
frame so I'll call them now this is just

00:41:52,520 --> 00:41:57,380
an example of protocol header doesn't

00:41:54,770 --> 00:41:58,670
really matter the nice thing about this

00:41:57,380 --> 00:42:00,410
protocol is you've got a fixed header

00:41:58,670 --> 00:42:01,910
length so you know how much data you

00:42:00,410 --> 00:42:04,880
need before you can read your header and

00:42:01,910 --> 00:42:08,610
that usually the headers will say how

00:42:04,880 --> 00:42:11,730
much other data you get need to wait for

00:42:08,610 --> 00:42:13,650
so basically on your protocol a you'll

00:42:11,730 --> 00:42:15,110
you'll want to send and receive frames

00:42:13,650 --> 00:42:17,430
and you need to do

00:42:15,110 --> 00:42:20,820
buffering tube to be able to get the

00:42:17,430 --> 00:42:24,870
whole frame at a time there's this

00:42:20,820 --> 00:42:29,280
multiple ways of doing this the i/o

00:42:24,870 --> 00:42:32,100
module which is I think new in 2.6 it

00:42:29,280 --> 00:42:33,420
gives you IO the bytes in 2.6 I think

00:42:32,100 --> 00:42:40,440
it's still quite slow I think there

00:42:33,420 --> 00:42:42,960
irritancy for 2.7 and three point X so

00:42:40,440 --> 00:42:45,030
so it's basically string I hope I'm sure

00:42:42,960 --> 00:42:47,760
you are familiar with string iopa it's

00:42:45,030 --> 00:42:50,100
it will ensure you get bytes and it's

00:42:47,760 --> 00:42:51,390
compatible pi/3 so and that's why I

00:42:50,100 --> 00:42:56,310
prefer to use it and it makes it

00:42:51,390 --> 00:43:00,570
actually working with bytes so so yeah

00:42:56,310 --> 00:43:02,640
you can keep writing to that the the

00:43:00,570 --> 00:43:04,110
other easier kind of method usually so

00:43:02,640 --> 00:43:08,040
using a list of strings and you just

00:43:04,110 --> 00:43:09,420
about put strings together the reason

00:43:08,040 --> 00:43:10,950
sometimes you might want to avoid that

00:43:09,420 --> 00:43:12,630
is if you're receiving data you might

00:43:10,950 --> 00:43:15,290
get in small bits and things like that

00:43:12,630 --> 00:43:18,990
and you end up with quite fragmented

00:43:15,290 --> 00:43:22,230
memory so that's usually if you did by

00:43:18,990 --> 00:43:25,890
hand usually I tend to go for receiving

00:43:22,230 --> 00:43:28,620
data with IO by tires and and sending

00:43:25,890 --> 00:43:30,720
data would actually strings a list of

00:43:28,620 --> 00:43:32,310
strings because sounding usually your

00:43:30,720 --> 00:43:33,930
protocol a will say here's a hole it

00:43:32,310 --> 00:43:36,090
will know here's a whole packet and

00:43:33,930 --> 00:43:39,180
that's a fairly decent unit to to try

00:43:36,090 --> 00:43:41,310
and send that one go if you got entirely

00:43:39,180 --> 00:43:43,200
fixed data then you can use both byte

00:43:41,310 --> 00:43:46,260
array and you can save some more copies

00:43:43,200 --> 00:43:49,110
but byte array you can also if you know

00:43:46,260 --> 00:43:52,350
how much exactly you expect you can use

00:43:49,110 --> 00:43:56,190
copy into that sorry you'll receive into

00:43:52,350 --> 00:43:59,420
as is another soccer method and you can

00:43:56,190 --> 00:44:04,110
safely operations sort of long strings

00:43:59,420 --> 00:44:06,960
this is an example of receiving data

00:44:04,110 --> 00:44:09,570
with by tayo I'm gonna skipped straight

00:44:06,960 --> 00:44:11,280
past it because it's not enough time for

00:44:09,570 --> 00:44:15,380
it and then similar similarly for

00:44:11,280 --> 00:44:18,660
sending data the next thing though is a

00:44:15,380 --> 00:44:21,300
the next thing make file basically is a

00:44:18,660 --> 00:44:22,410
it's a method on on your socket that try

00:44:21,300 --> 00:44:25,069
a try

00:44:22,410 --> 00:44:27,450
do buffering of data for you and

00:44:25,069 --> 00:44:28,710
generally if you can use it try and use

00:44:27,450 --> 00:44:34,559
it because it will make your life much

00:44:28,710 --> 00:44:39,000
easier I will go to the example actually

00:44:34,559 --> 00:44:42,869
which is on the next slide basically

00:44:39,000 --> 00:44:44,369
here it's the easiest way of using this

00:44:42,869 --> 00:44:45,780
is if you've got a simple protocol that

00:44:44,369 --> 00:44:48,630
uses soccer just for one

00:44:45,780 --> 00:44:51,359
request/response kind of thing and so

00:44:48,630 --> 00:44:54,750
the client can send their is request and

00:44:51,359 --> 00:44:57,630
then it shuts down its read and it's

00:44:54,750 --> 00:45:01,250
right and sorry of the socket when it

00:44:57,630 --> 00:45:03,480
shuts down the right end of its socket

00:45:01,250 --> 00:45:05,940
you've only got half pipe left

00:45:03,480 --> 00:45:09,559
essentially the server will note stand

00:45:05,940 --> 00:45:12,539
and cedar has an end-of-file when and

00:45:09,559 --> 00:45:14,940
when you're reading from so the server

00:45:12,539 --> 00:45:16,619
this is should be all familiar when you

00:45:14,940 --> 00:45:20,549
accept and you on the clients or could

00:45:16,619 --> 00:45:25,440
you call made file and you read you read

00:45:20,549 --> 00:45:29,609
data from that if if this client had

00:45:25,440 --> 00:45:32,180
only sent 7 7 bytes across and hadn't

00:45:29,609 --> 00:45:35,789
shut down the its and all of the pipe

00:45:32,180 --> 00:45:38,460
read on the file on the file like object

00:45:35,789 --> 00:45:40,410
that you get back will block forever

00:45:38,460 --> 00:45:42,480
until they get and the file or the

00:45:40,410 --> 00:45:44,970
required number pipe so that's why it's

00:45:42,480 --> 00:45:45,930
usually if you can shut down one end of

00:45:44,970 --> 00:45:48,029
the pipe

00:45:45,930 --> 00:45:52,440
similarly then you can write until the

00:45:48,029 --> 00:45:54,180
ant and then if it is then the server if

00:45:52,440 --> 00:45:58,529
the client had been using make file as

00:45:54,180 --> 00:46:01,289
well the server we do share the hundred

00:45:58,529 --> 00:46:06,359
cents off of the socket shut down as

00:46:01,289 --> 00:46:08,690
well and and that way the client would

00:46:06,359 --> 00:46:11,940
be able to get eight and a file as well

00:46:08,690 --> 00:46:18,380
if you so that that's the easiest way of

00:46:11,940 --> 00:46:20,880
doing it if make file you can use it if

00:46:18,380 --> 00:46:22,680
if you don't wanna if you want to keep

00:46:20,880 --> 00:46:25,380
reusing your own socket for for multiple

00:46:22,680 --> 00:46:28,200
requests and responses or whatever it is

00:46:25,380 --> 00:46:29,730
you're doing but you you really need to

00:46:28,200 --> 00:46:33,480
know how much data you gonna get because

00:46:29,730 --> 00:46:35,580
it's the the retail and the file it is

00:46:33,480 --> 00:46:39,510
it's kind of annoying and if you don't

00:46:35,580 --> 00:46:41,070
know this then then like trying to read

00:46:39,510 --> 00:46:42,900
the head is afraid to be for example or

00:46:41,070 --> 00:46:44,700
something like that you're gonna have to

00:46:42,900 --> 00:46:47,010
do it in one bite at a time or something

00:46:44,700 --> 00:46:48,630
that becomes really inefficient as well

00:46:47,010 --> 00:46:49,920
because you even though there is

00:46:48,630 --> 00:46:52,530
buffering behind the scenes you know

00:46:49,920 --> 00:46:54,630
you're only you doing lots of loops and

00:46:52,530 --> 00:46:56,700
copy operations on very small amounts of

00:46:54,630 --> 00:46:58,740
data so that only really works if you if

00:46:56,700 --> 00:47:05,430
you got fixed and my hands of data in

00:46:58,740 --> 00:47:07,710
your protocol a you can use non blocking

00:47:05,430 --> 00:47:09,660
with this as well it just means that you

00:47:07,710 --> 00:47:11,940
read them

00:47:09,660 --> 00:47:14,160
a flush operation is like making sure

00:47:11,940 --> 00:47:17,700
that all the data is you don't in write

00:47:14,160 --> 00:47:21,180
is actually sent there but they can

00:47:17,700 --> 00:47:23,510
reach race he would block if you get it

00:47:21,180 --> 00:47:23,510
wrong okay

00:47:24,800 --> 00:47:32,910
so basically I'm not not multiplexing IO

00:47:29,900 --> 00:47:34,530
like handling multiple sockets multiple

00:47:32,910 --> 00:47:36,540
clients in in the server side is it's

00:47:34,530 --> 00:47:39,380
quite difficult and wife can I really

00:47:36,540 --> 00:47:42,150
would select it's fine for simple cases

00:47:39,380 --> 00:47:43,710
but if you know if you're doing

00:47:42,150 --> 00:47:45,630
something seriously you should probably

00:47:43,710 --> 00:47:49,470
try and see if someone else can already

00:47:45,630 --> 00:47:54,440
do this because yeah there are libraries

00:47:49,470 --> 00:47:58,500
that do i/o loops already I'll mention

00:47:54,440 --> 00:48:03,119
two kind of approaches green LED is this

00:47:58,500 --> 00:48:04,770
kind of a lightweight it's based off of

00:48:03,119 --> 00:48:07,200
stockless Python but it's an extension

00:48:04,770 --> 00:48:11,310
module for for C button and it allows

00:48:07,200 --> 00:48:14,570
you to basically juggle stacked parts

00:48:11,310 --> 00:48:18,000
about information it allows you to take

00:48:14,570 --> 00:48:21,330
multiple user level threads essentially

00:48:18,000 --> 00:48:23,520
in one kernel level thread and that will

00:48:21,330 --> 00:48:26,940
become obvious when when get to the

00:48:23,520 --> 00:48:28,200
example where that's useful because when

00:48:26,940 --> 00:48:29,820
you're doing i/o you don't actually want

00:48:28,200 --> 00:48:31,470
it necessarily to process multiple

00:48:29,820 --> 00:48:35,250
things at the same time you've got a

00:48:31,470 --> 00:48:37,200
global interlock anyway it's a bus or so

00:48:35,250 --> 00:48:42,750
so that that's a neat solution of

00:48:37,200 --> 00:48:46,740
quickly switching this like to two while

00:48:42,750 --> 00:48:48,900
three projects are based on on green net

00:48:46,740 --> 00:48:52,800
if antlers event and and concurrence

00:48:48,900 --> 00:48:56,700
it's kind of I don't know how alive or

00:48:52,800 --> 00:48:57,870
how much use days but I've never used it

00:48:56,700 --> 00:49:00,570
myself but it looks actually quite

00:48:57,870 --> 00:49:03,090
interesting but basically event the G

00:49:00,570 --> 00:49:05,490
event are quiet similar they kind of run

00:49:03,090 --> 00:49:07,650
a hub with this i/o loop in in the

00:49:05,490 --> 00:49:08,760
background they have different

00:49:07,650 --> 00:49:13,110
approaches of how to actually implement

00:49:08,760 --> 00:49:18,030
it and basically they change the socket

00:49:13,110 --> 00:49:24,290
implementation so you instead of yeah

00:49:18,030 --> 00:49:24,290
instead of using instead of using the

00:49:24,980 --> 00:49:29,670
instead of using they're not native

00:49:26,790 --> 00:49:32,910
sockets they will go and automatically

00:49:29,670 --> 00:49:37,320
switch to a hub so in the top example

00:49:32,910 --> 00:49:38,520
which is just a client connection when

00:49:37,320 --> 00:49:41,450
you do connect that's normally a

00:49:38,520 --> 00:49:41,450
blocking call for a client

00:49:41,990 --> 00:49:51,500
and it will when you do that connect

00:49:45,830 --> 00:49:53,450
instead of blocking in in event that you

00:49:51,500 --> 00:49:56,420
you will switch it will switch to the

00:49:53,450 --> 00:49:59,900
hub and the hub will use this main loop

00:49:56,420 --> 00:50:01,520
which does something select like and and

00:49:59,900 --> 00:50:03,500
on this switchback

00:50:01,520 --> 00:50:06,830
so if you if you look at a server

00:50:03,500 --> 00:50:10,640
example illustrates us nicely so you

00:50:06,830 --> 00:50:12,530
your your accepting' client which is a

00:50:10,640 --> 00:50:14,060
block and call so that this will switch

00:50:12,530 --> 00:50:17,780
to the hub and hub will then switch back

00:50:14,060 --> 00:50:21,020
to you when when it you when you got a

00:50:17,780 --> 00:50:24,380
client and then you spawn a handler in a

00:50:21,020 --> 00:50:26,380
way and after you spawn the handle you

00:50:24,380 --> 00:50:29,030
just go straight back into accept and

00:50:26,380 --> 00:50:30,500
you try to accept the next client which

00:50:29,030 --> 00:50:32,660
would block switch back to the hub and

00:50:30,500 --> 00:50:36,500
then the hub will say oh but I've got

00:50:32,660 --> 00:50:40,010
another task little or green thread

00:50:36,500 --> 00:50:43,880
whatever you want to call it that that's

00:50:40,010 --> 00:50:46,100
got something to do and then then in the

00:50:43,880 --> 00:50:49,250
able switch to that one and that one

00:50:46,100 --> 00:50:52,940
will then be able to do its receive its

00:50:49,250 --> 00:50:55,190
data etc again this calls block so if

00:50:52,940 --> 00:50:56,810
there's not enough data ready it will

00:50:55,190 --> 00:50:58,960
switch back to happen and be ready to

00:50:56,810 --> 00:51:01,400
switch to another tasks so that's how

00:50:58,960 --> 00:51:06,470
event that and the event is very similar

00:51:01,400 --> 00:51:09,260
as far as I'm aware the kind of handles

00:51:06,470 --> 00:51:11,750
that for you twisted this kind of a I

00:51:09,260 --> 00:51:13,880
think obligatory to mention in when

00:51:11,750 --> 00:51:16,220
you're talking about sockets it's it's

00:51:13,880 --> 00:51:20,000
kind of it's a very it's a framework

00:51:16,220 --> 00:51:21,800
approach so you you kind of have to

00:51:20,000 --> 00:51:24,980
design your application around it it's

00:51:21,800 --> 00:51:26,480
not a library day just going to use no

00:51:24,980 --> 00:51:28,880
one likes frameworks and no one likes

00:51:26,480 --> 00:51:32,869
callbacks thing is my personal opinion

00:51:28,880 --> 00:51:34,760
and but yeah it's called X based I know

00:51:32,869 --> 00:51:36,230
there's this like all the inline

00:51:34,760 --> 00:51:37,910
callback something that kind of makes it

00:51:36,230 --> 00:51:40,880
easier but I find it really awkward to

00:51:37,910 --> 00:51:42,980
use really on the other hand it is very

00:51:40,880 --> 00:51:47,750
very complete day you have implemented

00:51:42,980 --> 00:51:49,580
lots of protocols for you so if if

00:51:47,750 --> 00:51:51,230
you're happy working in the twisted

00:51:49,580 --> 00:51:53,810
framework kind of thing it's it's very

00:51:51,230 --> 00:51:56,600
good it's very mature

00:51:53,810 --> 00:51:59,930
and it handles a lot of Education that

00:51:56,600 --> 00:52:04,180
you probably spend a lot of time finding

00:51:59,930 --> 00:52:13,000
yourself so that's the upside of twisted

00:52:04,180 --> 00:52:15,920
yeah but yeah so yeah in general I find

00:52:13,000 --> 00:52:18,410
don't don't be afraid to use sockets but

00:52:15,920 --> 00:52:23,650
be aware of of actually handling them

00:52:18,410 --> 00:52:25,940
correctly and yeah if you need lots of a

00:52:23,650 --> 00:52:27,910
lot lots of clients or something don't

00:52:25,940 --> 00:52:29,780
don't try and do it yourself because

00:52:27,910 --> 00:52:33,530
someone else probably figured out

00:52:29,780 --> 00:52:38,390
already how to do that I'm a bit over

00:52:33,530 --> 00:52:41,590
time I apologize yeah so if there is we

00:52:38,390 --> 00:52:41,590
have time for two buses

00:52:53,289 --> 00:52:59,950
on the second or so slide when you pass

00:52:56,719 --> 00:53:04,009
an empty string to bind I believe it was

00:52:59,950 --> 00:53:07,219
and you said thanks to some magic that

00:53:04,009 --> 00:53:17,930
will bind both an eye net and I set my

00:53:07,219 --> 00:53:20,239
net six protocol that one that one if

00:53:17,930 --> 00:53:23,839
you look at that's an output it will

00:53:20,239 --> 00:53:26,690
show us listening on this is UDP so

00:53:23,839 --> 00:53:28,880
yours you'll see on the I think on the

00:53:26,690 --> 00:53:33,019
next slide it will show up as a UDP

00:53:28,880 --> 00:53:37,039
sockets but that UDP suckers or if it

00:53:33,019 --> 00:53:39,739
was TCC sip sort will be able to receive

00:53:37,039 --> 00:53:42,229
connections from both this is that

00:53:39,739 --> 00:53:43,630
Python magic core operating system magic

00:53:42,229 --> 00:53:45,430
that's operating system magic

00:53:43,630 --> 00:53:48,499
dose-dependent

00:53:45,430 --> 00:53:52,039
no day they all about in my experience

00:53:48,499 --> 00:53:54,229
they all seem to behave that way that

00:53:52,039 --> 00:53:56,809
that's the way that this their standard

00:53:54,229 --> 00:53:58,819
sauce I think are supposed to be fair

00:53:56,809 --> 00:54:03,559
enough that's fine second question if I

00:53:58,819 --> 00:54:07,249
may and when you may when you call make

00:54:03,559 --> 00:54:08,420
file from a socket yeah I believe

00:54:07,249 --> 00:54:12,160
Windows has the restriction where you

00:54:08,420 --> 00:54:14,599
can only you select on sockets so

00:54:12,160 --> 00:54:16,789
presumably after you've used make file

00:54:14,599 --> 00:54:20,890
you can no longer use select they're not

00:54:16,789 --> 00:54:26,450
special file and still work with select

00:54:20,890 --> 00:54:28,309
yeah your file objectives you have to do

00:54:26,450 --> 00:54:29,749
select on the socket the exact behind it

00:54:28,309 --> 00:54:32,269
I think and then you can use the file

00:54:29,749 --> 00:54:33,859
and then you can use the file object OSC

00:54:32,269 --> 00:54:35,119
okay because you still have you soccer

00:54:33,859 --> 00:54:37,759
the object you know you don't throw that

00:54:35,119 --> 00:54:40,119
away so you can do select on that okay

00:54:37,759 --> 00:54:40,119
thank you

00:54:40,890 --> 00:54:44,000
understand for one last question

00:54:50,540 --> 00:54:54,040

YouTube URL: https://www.youtube.com/watch?v=cPZokpaA0Vw


