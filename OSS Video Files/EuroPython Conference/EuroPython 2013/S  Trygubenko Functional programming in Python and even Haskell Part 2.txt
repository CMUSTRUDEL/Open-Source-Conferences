Title: S  Trygubenko Functional programming in Python and even Haskell Part 2
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	[Europython 2013]
S. Trygubenko - Functional programming in Python and even Haskell Part 2
4 July 2013
Track Pizza  Margherita
Captions: 
	00:00:24,050 --> 00:00:31,859
welcome back everyone now before leaving

00:00:27,390 --> 00:00:34,470
the word back to salmon just a little

00:00:31,859 --> 00:00:37,440
thing I want to remember you all this

00:00:34,470 --> 00:00:41,460
evening's certain 9pm we have pie riddle

00:00:37,440 --> 00:00:45,150
/ riddle is a most sought after and also

00:00:41,460 --> 00:00:47,339
feared even too easy in Europe ID on you

00:00:45,150 --> 00:00:52,140
have to solve every dollar and you can

00:00:47,339 --> 00:00:54,269
be you can win a mac air pro for free

00:00:52,140 --> 00:00:57,689
it's not that bad other than boss how

00:00:54,269 --> 00:01:00,000
smart you are we know you all like to

00:00:57,689 --> 00:01:05,339
both those marks you are I mean let's

00:01:00,000 --> 00:01:07,950
admit it and so you can go there from

00:01:05,339 --> 00:01:11,520
visit a land that tend to visit vente

00:01:07,950 --> 00:01:15,509
now back to go our teacher yes sounds

00:01:11,520 --> 00:01:17,689
good so we stopped at the

00:01:15,509 --> 00:01:22,790
non-destructive recursive solution

00:01:17,689 --> 00:01:25,409
before the coffee break I believe so

00:01:22,790 --> 00:01:32,130
next is a little bit more tricky

00:01:25,409 --> 00:01:34,740
exercise we should try and write a new

00:01:32,130 --> 00:01:39,630
solution with satisfying the same set of

00:01:34,740 --> 00:01:41,670
constraints keeping in mind that we want

00:01:39,630 --> 00:01:43,970
a non-destructive and non recursive

00:01:41,670 --> 00:01:43,970
solution

00:01:46,909 --> 00:01:53,909
so the general pattern I think here is

00:01:50,430 --> 00:01:57,030
that this is a little cleaner because it

00:01:53,909 --> 00:01:59,280
uses recursion and the next one will be

00:01:57,030 --> 00:02:02,909
a little more meaty depending on what

00:01:59,280 --> 00:02:06,390
you choose to have in there and there

00:02:02,909 --> 00:02:09,179
are many ways of solving this if you

00:02:06,390 --> 00:02:12,030
don't resort to recursion so obviously

00:02:09,179 --> 00:02:14,970
the non-destructive bit can be taken

00:02:12,030 --> 00:02:16,980
care of through many ways you can copy

00:02:14,970 --> 00:02:20,430
the whole thing at the beginning and

00:02:16,980 --> 00:02:24,060
then work with it or you can keep

00:02:20,430 --> 00:02:26,190
copying bits of it rather than copying

00:02:24,060 --> 00:02:28,890
the whole thing up front saving a little

00:02:26,190 --> 00:02:33,330
bit of RAM so it's it's a question of

00:02:28,890 --> 00:02:38,489
how you choose to traverse that nested

00:02:33,330 --> 00:02:41,000
list and so please choose whatever feels

00:02:38,489 --> 00:02:45,530
natural to you and write a

00:02:41,000 --> 00:02:45,530
non-destructive non recursive one

00:02:53,489 --> 00:02:57,879
it's the same problem as before so they

00:02:55,989 --> 00:03:03,159
set of assertions is flattened the list

00:02:57,879 --> 00:03:07,900
and the non-destructive bit and should

00:03:03,159 --> 00:03:11,319
be there so the this test should pass

00:03:07,900 --> 00:03:14,620
and we have one solution so far which is

00:03:11,319 --> 00:03:16,959
non-destructive but uses recursion but I

00:03:14,620 --> 00:03:20,409
wanted to you right there and what feels

00:03:16,959 --> 00:03:22,680
natural solution in Python not using

00:03:20,409 --> 00:03:22,680
recursion

00:03:29,470 --> 00:03:35,500
also if you do it really quickly try to

00:03:32,400 --> 00:03:38,460
assess what see and characteristics or

00:03:35,500 --> 00:03:43,210
your solution are and how it behaves and

00:03:38,460 --> 00:03:49,060
memory wise for example what's the worst

00:03:43,210 --> 00:03:52,440
case is it going to have a large memory

00:03:49,060 --> 00:03:56,500
footprint how does it scale with the

00:03:52,440 --> 00:03:58,150
nastiness of the list basically try to

00:03:56,500 --> 00:04:02,280
think about stuff like that when you

00:03:58,150 --> 00:04:02,280
write hmm any more questions

00:35:32,640 --> 00:35:52,119
now it will try a little bit iffy fun

00:35:36,630 --> 00:35:56,890
excellent thank you so we had some cool

00:35:52,119 --> 00:36:01,510
pretty good so how did it go did

00:35:56,890 --> 00:36:04,920
everyone Saul the and this one or how

00:36:01,510 --> 00:36:08,020
many people wrote them and non recursive

00:36:04,920 --> 00:36:10,630
non-destructive that satisfy the

00:36:08,020 --> 00:36:14,290
constraints fantastic what we r memory

00:36:10,630 --> 00:36:20,890
requirements like worst case and average

00:36:14,290 --> 00:36:24,430
case double in the worst case if it

00:36:20,890 --> 00:36:27,480
basically is a list it's that contains

00:36:24,430 --> 00:36:30,160
just atomic objects right and if it's

00:36:27,480 --> 00:36:33,060
arbitrarily nested it depends on the

00:36:30,160 --> 00:36:36,760
Lord how well they distribute it right

00:36:33,060 --> 00:36:39,460
mmm okay so I'm just going to quickly go

00:36:36,760 --> 00:36:41,800
through this solution that I came up

00:36:39,460 --> 00:36:45,420
with which I forgotten all about because

00:36:41,800 --> 00:36:48,190
it's quite quite involved but and so I

00:36:45,420 --> 00:36:52,690
defined an auxiliary function called

00:36:48,190 --> 00:36:56,020
them and a reverse shell a copy of a

00:36:52,690 --> 00:37:00,640
list so that I don't copy the and they

00:36:56,020 --> 00:37:03,730
all the sub lists and then and I use

00:37:00,640 --> 00:37:09,780
this stack and data structure like and

00:37:03,730 --> 00:37:12,670
so I basically and this is a work so and

00:37:09,780 --> 00:37:16,359
I've used the list but I used it in such

00:37:12,670 --> 00:37:19,510
a way so i can use pop which is quite

00:37:16,359 --> 00:37:23,020
efficient so so basically what i do i

00:37:19,510 --> 00:37:24,910
then while there is work to do i take

00:37:23,020 --> 00:37:27,660
the head of the stack if it is an

00:37:24,910 --> 00:37:27,660
instance of list

00:37:40,460 --> 00:37:45,740
so let's see so so what happens if the

00:37:43,010 --> 00:37:52,849
and the head is the instance of a list

00:37:45,740 --> 00:37:55,430
and we do when they see it works so we

00:37:52,849 --> 00:37:58,070
do a pop again and this is a head head

00:37:55,430 --> 00:38:01,820
and we append it to the work data

00:37:58,070 --> 00:38:06,140
structure and then if it is an instance

00:38:01,820 --> 00:38:08,300
of a list itself then we append it to a

00:38:06,140 --> 00:38:11,839
stack but we append a rigorous sure i'll

00:38:08,300 --> 00:38:14,240
copy again so so this particular

00:38:11,839 --> 00:38:18,380
solution is quite a messy one but it

00:38:14,240 --> 00:38:21,830
doesn't copy the the holistic copies

00:38:18,380 --> 00:38:24,020
just the top level of that list so it

00:38:21,830 --> 00:38:25,790
doesn't copy constituents of the list so

00:38:24,020 --> 00:38:28,849
potentially you can possess more with it

00:38:25,790 --> 00:38:31,070
but admittedly it'll be hard to maintain

00:38:28,849 --> 00:38:38,119
and modify and so no wonder I forgot all

00:38:31,070 --> 00:38:42,530
about it so so next is a a distracting

00:38:38,119 --> 00:38:45,260
non-recursive one so let's see what what

00:38:42,530 --> 00:38:46,490
we potentially going to do here I'm just

00:38:45,260 --> 00:38:50,650
going to show it because it's quite

00:38:46,490 --> 00:38:53,150
simple and you probably and have written

00:38:50,650 --> 00:38:56,240
something like that already so so

00:38:53,150 --> 00:39:02,180
basically if we if we allow ourselves to

00:38:56,240 --> 00:39:04,359
destroy and the data structures that we

00:39:02,180 --> 00:39:07,490
pass in we could just keep popping

00:39:04,359 --> 00:39:10,550
populating the result list with what we

00:39:07,490 --> 00:39:12,890
pop and then in the end we could just

00:39:10,550 --> 00:39:17,510
reverse the result so this this is a

00:39:12,890 --> 00:39:21,500
little less messy and still has the nice

00:39:17,510 --> 00:39:24,830
property of not increasing the memory

00:39:21,500 --> 00:39:27,410
overhead but obviously we have a side

00:39:24,830 --> 00:39:31,390
effect that and it will destroy what we

00:39:27,410 --> 00:39:31,390
pass into it yeah

00:39:32,460 --> 00:39:40,000
well in the end and I'm not I have not

00:39:37,630 --> 00:39:43,780
specified memory requirements who this

00:39:40,000 --> 00:39:50,560
but some reason I wanted this not to

00:39:43,780 --> 00:39:52,590
have the full blown copy of the data

00:39:50,560 --> 00:39:55,990
structures duty passing because then if

00:39:52,590 --> 00:39:58,660
in the case where you have a limited

00:39:55,990 --> 00:40:00,970
amount of RAM available you will

00:39:58,660 --> 00:40:05,400
basically be able to work with smaller

00:40:00,970 --> 00:40:05,400
best resident yeah

00:40:10,400 --> 00:40:19,130
mmhmm yeah that's nice yeah sure so

00:40:14,799 --> 00:40:23,799
that's good point so and now

00:40:19,130 --> 00:40:26,960
corresponding Haskell solutions the

00:40:23,799 --> 00:40:32,359
first the very first one that we solve

00:40:26,960 --> 00:40:42,829
using the using the non-destructive

00:40:32,359 --> 00:40:44,839
recursive solution so I hear the the

00:40:42,829 --> 00:40:48,910
basic problem with Haskell and solving

00:40:44,839 --> 00:40:51,529
this plan is that Haskell lists are and

00:40:48,910 --> 00:40:55,789
homogeneous so obviously we can't even

00:40:51,529 --> 00:40:58,940
construct something similar quite easily

00:40:55,789 --> 00:41:03,079
so basically what we end up doing is we

00:40:58,940 --> 00:41:06,020
have a user-defined data type which we

00:41:03,079 --> 00:41:09,049
call nest list that has a couple of

00:41:06,020 --> 00:41:11,210
constructors as the LM resistance for

00:41:09,049 --> 00:41:15,710
element constructor that has an element

00:41:11,210 --> 00:41:21,170
of type A and then it has a list

00:41:15,710 --> 00:41:27,789
constructor which is a list of nested

00:41:21,170 --> 00:41:27,789
lists of taipei so if you introduce this

00:41:28,240 --> 00:41:35,329
data type in the following function

00:41:32,119 --> 00:41:39,500
which basically takes an asset list data

00:41:35,329 --> 00:41:42,200
type and I i could have written it in a

00:41:39,500 --> 00:41:46,990
more generic fashion but then I've used

00:41:42,200 --> 00:41:53,660
in here so so what it does it maps

00:41:46,990 --> 00:41:57,529
nested lists holding hints on to list

00:41:53,660 --> 00:42:00,529
events so again is defined in two lines

00:41:57,529 --> 00:42:04,069
so if we put on match on the first

00:42:00,529 --> 00:42:07,460
argument and if the first argument is an

00:42:04,069 --> 00:42:10,160
element and then we bind what's inside

00:42:07,460 --> 00:42:12,910
the constructor 2x and then we simply

00:42:10,160 --> 00:42:15,799
return the list containing the dominant

00:42:12,910 --> 00:42:16,970
otherwise the only other choice is life

00:42:15,799 --> 00:42:22,579
because there are just two constructors

00:42:16,970 --> 00:42:23,990
is that first argument is a list and in

00:42:22,579 --> 00:42:28,630
that case X is now

00:42:23,990 --> 00:42:32,000
how that guy all of that guy and

00:42:28,630 --> 00:42:35,360
basically in that case we recurse we

00:42:32,000 --> 00:42:37,730
call button again on X but then there is

00:42:35,360 --> 00:42:41,540
a useful auxiliary function can cap nap

00:42:37,730 --> 00:42:45,130
and I don't know if you so I'm just

00:42:41,540 --> 00:42:45,130
going to put the microphone down person

00:42:51,640 --> 00:43:01,580
my little brother so for your ass no

00:42:57,500 --> 00:43:08,390
it's fantastic today thank you very much

00:43:01,580 --> 00:43:14,600
sir so and you can always in GHC I

00:43:08,390 --> 00:43:16,910
prompt type colon T and then function

00:43:14,600 --> 00:43:18,560
name and you could see signature so

00:43:16,910 --> 00:43:21,920
that's what it does it takes a function

00:43:18,560 --> 00:43:24,830
that map's ace to list of bees and then

00:43:21,920 --> 00:43:27,260
it takes a list of ace and returns a

00:43:24,830 --> 00:43:29,260
list of these so basically it you'll do

00:43:27,260 --> 00:43:32,020
the flattening bit as well as mapping

00:43:29,260 --> 00:43:35,660
which is why it's a convenience function

00:43:32,020 --> 00:43:37,340
so so that will satisfy the surgeons and

00:43:35,660 --> 00:43:41,270
you will see the high schooler surgeons

00:43:37,340 --> 00:43:47,200
are all them aesculus surgeons are full

00:43:41,270 --> 00:43:47,200
of constructors for that reason so next

00:43:49,210 --> 00:43:58,070
basically a date sorry where do we go so

00:43:54,950 --> 00:44:02,530
this place here is where i define a new

00:43:58,070 --> 00:44:07,180
and data type called nested list and

00:44:02,530 --> 00:44:11,630
this data type has a tight primer itself

00:44:07,180 --> 00:44:16,100
so it can hold something and that

00:44:11,630 --> 00:44:18,890
something can be basically we can

00:44:16,100 --> 00:44:21,680
construct this data type using ln

00:44:18,890 --> 00:44:24,430
constructor or we can construct it using

00:44:21,680 --> 00:44:24,430
this constructor

00:44:26,370 --> 00:44:31,350
no no no it's a user-defined constructor

00:44:40,040 --> 00:44:51,120
so a user defined data structure nested

00:44:44,910 --> 00:44:53,580
lists can be either an element in which

00:44:51,120 --> 00:44:55,860
case we proceed that element with a

00:44:53,580 --> 00:44:58,080
constructor and in that case constructor

00:44:55,860 --> 00:45:01,800
we choose to name it LMK we can name it

00:44:58,080 --> 00:45:03,120
what everyone or it can be a list right

00:45:01,800 --> 00:45:04,980
in which case there is a bit of

00:45:03,120 --> 00:45:08,220
technology here we just want to

00:45:04,980 --> 00:45:13,170
differentiate between the atomic value

00:45:08,220 --> 00:45:14,940
and the list of potentially the mixture

00:45:13,170 --> 00:45:17,730
of atomic and non-atomic values and

00:45:14,940 --> 00:45:22,430
that's the way to do it in haskell so it

00:45:17,730 --> 00:45:22,430
is because it says strictly type that's

00:45:23,360 --> 00:45:29,730
yeah exactly so we we use in prelude we

00:45:27,840 --> 00:45:32,940
already have the list data structure so

00:45:29,730 --> 00:45:36,150
you can say like well and it was 12 so

00:45:32,940 --> 00:45:41,720
or you can say something like one going

00:45:36,150 --> 00:45:44,870
to go on think so that's already defined

00:45:41,720 --> 00:45:51,090
but I could I could I could define this

00:45:44,870 --> 00:45:53,820
user defined data type myself so so

00:45:51,090 --> 00:45:58,140
let's see so if I don't want to use can

00:45:53,820 --> 00:46:01,680
cat nap and it's possible to use it was

00:45:58,140 --> 00:46:03,690
plus operator here so what we what we do

00:46:01,680 --> 00:46:07,800
we define a bit more involved flatten

00:46:03,690 --> 00:46:10,950
where again this part isn't changed if

00:46:07,800 --> 00:46:15,420
it's an element we just return a list

00:46:10,950 --> 00:46:17,670
containing it otherwise if we put an X

00:46:15,420 --> 00:46:21,030
on the list we further pattern match on

00:46:17,670 --> 00:46:23,910
the what's inside and we name the head

00:46:21,030 --> 00:46:27,210
of attacks and detail access and then

00:46:23,910 --> 00:46:30,360
obviously we need to now do sort of a

00:46:27,210 --> 00:46:34,310
double recursion we need to process X

00:46:30,360 --> 00:46:36,660
and then we need to process tale of

00:46:34,310 --> 00:46:40,560
what's inside the list constructor

00:46:36,660 --> 00:46:42,810
access and then if the this doesn't

00:46:40,560 --> 00:46:45,860
actually cover all the cases sir so we

00:46:42,810 --> 00:46:49,680
will have to add the line where and

00:46:45,860 --> 00:46:50,980
there is a list that contains sorry

00:46:49,680 --> 00:46:53,410
capital list

00:46:50,980 --> 00:46:58,240
perhaps badly named here containing an

00:46:53,410 --> 00:47:04,690
empty list here so I don't know does

00:46:58,240 --> 00:47:07,420
this make sense I guess I shouldn't have

00:47:04,690 --> 00:47:09,640
called this LM and lest because then in

00:47:07,420 --> 00:47:11,950
verbal communication list can be

00:47:09,640 --> 00:47:15,160
confused with capital list can be

00:47:11,950 --> 00:47:18,369
confused with a built-in list in haskell

00:47:15,160 --> 00:47:20,890
so but that's the way to do it if you

00:47:18,369 --> 00:47:26,170
want a heterogeneous elements inside the

00:47:20,890 --> 00:47:29,770
list so the next task is honors or

00:47:26,170 --> 00:47:32,850
questions is to do a another interesting

00:47:29,770 --> 00:47:37,180
exercise is called run-length encoding

00:47:32,850 --> 00:47:39,940
so the surgeons are basically telling us

00:47:37,180 --> 00:47:42,730
that what we want is we want to encode

00:47:39,940 --> 00:47:46,359
the data but now we want the encoding to

00:47:42,730 --> 00:47:47,859
be lossless so that remember when we

00:47:46,359 --> 00:47:50,340
were doing compress we actually just

00:47:47,859 --> 00:47:53,859
discarding information about how many

00:47:50,340 --> 00:47:56,350
elements where repeated in this

00:47:53,859 --> 00:48:01,660
succession but now for example if we

00:47:56,350 --> 00:48:03,730
have a list containing 001 we return a

00:48:01,660 --> 00:48:08,980
list of tuples containing the

00:48:03,730 --> 00:48:11,530
multiplicity and the value so if you can

00:48:08,980 --> 00:48:15,130
try knock the top click quickly and

00:48:11,530 --> 00:48:18,460
whichever feels more natural to you the

00:48:15,130 --> 00:48:21,190
recursive non-recursive using the list

00:48:18,460 --> 00:48:27,150
comprehension this is quite an easy

00:48:21,190 --> 00:48:27,150
exercise using the generator

00:49:03,400 --> 00:49:11,260
some people are done already yeah well

00:49:08,440 --> 00:49:15,730
you can use goodbye exactly so as you

00:49:11,260 --> 00:49:20,109
can see it's just goodbye isn't it the

00:49:15,730 --> 00:49:22,750
only I think distinction is a group by

00:49:20,109 --> 00:49:25,539
returns as a second element of tupelo an

00:49:22,750 --> 00:49:29,950
iterator right so you probably would

00:49:25,539 --> 00:49:35,520
need to and do a little bit of managing

00:49:29,950 --> 00:49:35,520
to to make it conform to these asserts

00:49:36,569 --> 00:49:45,309
so okay I'm gonna go forward with this

00:49:40,359 --> 00:49:48,069
so i just i used grew by and I wanted to

00:49:45,309 --> 00:49:51,010
factor out a bit of functionality into a

00:49:48,069 --> 00:49:55,539
function that I called pack so basically

00:49:51,010 --> 00:49:58,119
that it takes the length of the group

00:49:55,539 --> 00:50:02,079
and the key and returns it as a tuple

00:49:58,119 --> 00:50:05,740
and then I just returned a pack key

00:50:02,079 --> 00:50:10,599
group for keen group and grouping group

00:50:05,740 --> 00:50:15,760
by L so this using group by and the same

00:50:10,599 --> 00:50:19,510
in Haskell now we have the homogeneity

00:50:15,760 --> 00:50:22,500
that we wanted and so it's quite a clean

00:50:19,510 --> 00:50:25,270
solution here so again pack function

00:50:22,500 --> 00:50:28,289
risk group function which we now know

00:50:25,270 --> 00:50:32,230
about which returns a list of lists and

00:50:28,289 --> 00:50:34,240
all we need to do is pass this list into

00:50:32,230 --> 00:50:36,670
peck function and then peg function is a

00:50:34,240 --> 00:50:40,859
function taking the list of entities and

00:50:36,670 --> 00:50:45,000
returning a tuple containing an end and

00:50:40,859 --> 00:50:47,410
representative so what you take

00:50:45,000 --> 00:50:49,960
basically he ran in code function in

00:50:47,410 --> 00:50:57,010
this case is a simple map of whatever

00:50:49,960 --> 00:51:02,520
group is returning piped into this

00:50:57,010 --> 00:51:06,520
function which basically takes this list

00:51:02,520 --> 00:51:09,220
and then just packs it so an interesting

00:51:06,520 --> 00:51:11,859
thing here is that basically on the left

00:51:09,220 --> 00:51:15,160
on the right we have omitted actually

00:51:11,859 --> 00:51:16,880
one argument here because then huh SCOE

00:51:15,160 --> 00:51:18,710
has this interesting

00:51:16,880 --> 00:51:22,789
property called caring of functions

00:51:18,710 --> 00:51:34,789
where you can say things like like for

00:51:22,789 --> 00:51:36,650
example DM if you have a function X so

00:51:34,789 --> 00:51:39,559
if you define a simple function that

00:51:36,650 --> 00:51:43,339
takes makes a product of two I don't can

00:51:39,559 --> 00:51:48,609
everyone see that and so so you could

00:51:43,339 --> 00:51:52,839
say something like that g equals f of 1

00:51:48,609 --> 00:51:56,599
so what happen here we partially applied

00:51:52,839 --> 00:52:01,009
the arguments of f and call that a new

00:51:56,599 --> 00:52:04,970
name g so now i could say g10 in which

00:52:01,009 --> 00:52:06,980
120 so that's that's basically carrying

00:52:04,970 --> 00:52:10,039
it works so so what what's going on here

00:52:06,980 --> 00:52:13,279
he is in code actually it's taking and a

00:52:10,039 --> 00:52:17,059
premiere but it appears as if it doesn't

00:52:13,279 --> 00:52:19,269
because what's on the right also takes a

00:52:17,059 --> 00:52:22,400
tremor and it's the same we don't need

00:52:19,269 --> 00:52:25,519
to even name it but potentially could

00:52:22,400 --> 00:52:31,869
have written in code why map pack dot

00:52:25,519 --> 00:52:31,869
group why but it will be a tautology so

00:52:32,140 --> 00:52:40,220
so unless you really need to name your

00:52:34,640 --> 00:52:44,089
parameters you can write it this way but

00:52:40,220 --> 00:52:48,440
if you don't like in this case here you

00:52:44,089 --> 00:52:53,420
can omit it so so they take two is I

00:52:48,440 --> 00:52:57,259
believe I'm going back to the

00:52:53,420 --> 00:53:02,440
heterogeneous lists where you can try it

00:52:57,259 --> 00:53:06,920
as a kind of exercise layer basically

00:53:02,440 --> 00:53:09,309
instead of returning tuple in the case

00:53:06,920 --> 00:53:12,140
where there is repetition of

00:53:09,309 --> 00:53:16,130
multiplicity of one you just return the

00:53:12,140 --> 00:53:19,220
element itself and thereby and sending a

00:53:16,130 --> 00:53:21,589
message that there is just one so

00:53:19,220 --> 00:53:25,549
multiplicity is one so for example here

00:53:21,589 --> 00:53:27,530
instead of returning for a list of 0 0 1

00:53:25,549 --> 00:53:32,810
instead of returning

00:53:27,530 --> 00:53:35,660
a list of tuples containing 20 and 11 I

00:53:32,810 --> 00:53:38,780
just returned one here so which will

00:53:35,660 --> 00:53:42,140
save a little bit of storage so this

00:53:38,780 --> 00:53:46,130
will again if we use group by it's quite

00:53:42,140 --> 00:53:50,450
a trivial solution bison in Haskell we

00:53:46,130 --> 00:53:54,440
will need to define more we will define

00:53:50,450 --> 00:53:56,750
list item that can be a single a or it

00:53:54,440 --> 00:53:58,490
can be a multiple and if it is a

00:53:56,750 --> 00:54:01,610
multiple then we need to record

00:53:58,490 --> 00:54:06,680
multiplicity which will use an int to

00:54:01,610 --> 00:54:11,000
record in and we don't specify what a is

00:54:06,680 --> 00:54:14,120
here so um sopec function will look like

00:54:11,000 --> 00:54:16,100
this again this this is unchanged but

00:54:14,120 --> 00:54:22,730
what will happen here is that pack will

00:54:16,100 --> 00:54:25,580
take a list and if the if the m is equal

00:54:22,730 --> 00:54:29,480
one it's a multiplicity is one and we

00:54:25,580 --> 00:54:31,790
return single and single constructor and

00:54:29,480 --> 00:54:34,600
positive value otherwise we will return

00:54:31,790 --> 00:54:38,410
multiple with multiplicity and value and

00:54:34,600 --> 00:54:42,590
this is a where statement that allows to

00:54:38,410 --> 00:54:44,630
define what we mean by M and V so m is

00:54:42,590 --> 00:54:47,960
basically just the lengths of every

00:54:44,630 --> 00:54:51,170
constituent of what group returns and v

00:54:47,960 --> 00:54:54,050
is head well we know the sub lists

00:54:51,170 --> 00:54:59,980
contain identical elements so first this

00:54:54,050 --> 00:55:04,450
is good as any so so the take three is a

00:54:59,980 --> 00:55:10,940
more interesting one for example I

00:55:04,450 --> 00:55:16,270
wanted here to have a deflate but on the

00:55:10,940 --> 00:55:20,390
fly so instead of if you notice here and

00:55:16,270 --> 00:55:24,260
we had since we used grew by function

00:55:20,390 --> 00:55:27,980
what it did it it not fully inflated the

00:55:24,260 --> 00:55:30,580
list but it basically partition to it so

00:55:27,980 --> 00:55:35,860
it sort of created a list that contains

00:55:30,580 --> 00:55:35,860
the multiplicity but also

00:55:37,749 --> 00:55:44,599
so group I returned a list of tuples

00:55:41,960 --> 00:55:47,960
where the first element was key and the

00:55:44,599 --> 00:55:50,809
second element was an iterator that will

00:55:47,960 --> 00:55:54,019
iterate across the whole sub range of

00:55:50,809 --> 00:55:58,819
equal elements so they need to make sure

00:55:54,019 --> 00:56:01,489
that we don't do that up front and we do

00:55:58,819 --> 00:56:07,130
it as we go along I've created this

00:56:01,489 --> 00:56:10,910
exercise and so it's a little bit more

00:56:07,130 --> 00:56:12,769
involved again and because then there is

00:56:10,910 --> 00:56:16,099
a little bit of bookkeeping that we need

00:56:12,769 --> 00:56:19,099
to do so but the moment you can have a

00:56:16,099 --> 00:56:22,369
look at it later and if you're

00:56:19,099 --> 00:56:27,589
interested but the important point here

00:56:22,369 --> 00:56:30,470
is that if if you care about memory and

00:56:27,589 --> 00:56:33,940
if you have constrained resources you

00:56:30,470 --> 00:56:40,069
will have to run write more code to

00:56:33,940 --> 00:56:42,559
satisfy them so to quickly sum up what

00:56:40,069 --> 00:56:46,460
this does and basically pack that's what

00:56:42,559 --> 00:56:48,710
it used to do if that multiplicity equal

00:56:46,460 --> 00:56:51,859
one we return value otherwise we return

00:56:48,710 --> 00:56:57,410
it to pull so in code accepts list and

00:56:51,859 --> 00:57:02,029
then if it's basically if it links of it

00:56:57,410 --> 00:57:05,450
is greater than one then we prime this

00:57:02,029 --> 00:57:07,039
for loop and then we keep track of the

00:57:05,450 --> 00:57:09,499
current multiplicity and we keep

00:57:07,039 --> 00:57:12,440
incrementing it if the value is the same

00:57:09,499 --> 00:57:14,720
as what we've recorded otherwise we

00:57:12,440 --> 00:57:16,880
basically when once we cross the

00:57:14,720 --> 00:57:21,880
boundary between the same bunch of

00:57:16,880 --> 00:57:27,259
elements and the different element we

00:57:21,880 --> 00:57:30,259
append whatever we've gathered so far by

00:57:27,259 --> 00:57:34,130
piping it's into a peck function which

00:57:30,259 --> 00:57:36,380
will return what we want so so let's see

00:57:34,130 --> 00:57:38,989
the solution where we do on the fly

00:57:36,380 --> 00:57:42,019
encoding and I have done a similar one

00:57:38,989 --> 00:57:45,160
in Haskell and so you can have a look at

00:57:42,019 --> 00:57:50,270
it later it doesn't actually mean that

00:57:45,160 --> 00:57:53,450
this will run the same way as

00:57:50,270 --> 00:57:58,250
treats when it is compiled because of

00:57:53,450 --> 00:58:00,950
lazy evaluation so if you feel brave

00:57:58,250 --> 00:58:03,080
enough you could try and work out what

00:58:00,950 --> 00:58:06,440
actually is going on here in terms of

00:58:03,080 --> 00:58:11,620
that how these functions are interacting

00:58:06,440 --> 00:58:14,690
because obviously a lazy evaluation will

00:58:11,620 --> 00:58:17,570
change the way these entities are

00:58:14,690 --> 00:58:20,750
computed but it's a nice way of thinking

00:58:17,570 --> 00:58:23,780
about the problem if you want to think

00:58:20,750 --> 00:58:28,520
about it in terms of fun on the fly

00:58:23,780 --> 00:58:32,270
deflation so a final exercise which is

00:58:28,520 --> 00:58:35,660
quite interesting is a sorting a list by

00:58:32,270 --> 00:58:38,270
sub list properties like lengths for

00:58:35,660 --> 00:58:41,810
example or frequency so I'm going to

00:58:38,270 --> 00:58:45,410
show quickly a solution of sorting a

00:58:41,810 --> 00:58:50,830
list by sub list links and then this is

00:58:45,410 --> 00:58:50,830
a solution that uses a library function

00:58:53,230 --> 00:59:03,230
so for Roscoe is similarly a simple we

00:58:58,910 --> 00:59:05,710
just in return import I sold by function

00:59:03,230 --> 00:59:09,460
from data list and there is this

00:59:05,710 --> 00:59:13,310
function in data or called comparing so

00:59:09,460 --> 00:59:15,950
basically you define your sword as sort

00:59:13,310 --> 00:59:18,770
by comparing length and then again it

00:59:15,950 --> 00:59:23,380
takes a list of lists and then we'll

00:59:18,770 --> 00:59:26,360
return the list of lists so these are

00:59:23,380 --> 00:59:29,990
concise solutions but they use library

00:59:26,360 --> 00:59:31,760
functions so he and now the image and

00:59:29,990 --> 00:59:33,200
you don't have a library function like

00:59:31,760 --> 00:59:36,080
for example in there in the case where

00:59:33,200 --> 00:59:41,390
you want to sort by a sub-list length

00:59:36,080 --> 00:59:46,580
frequency so how about we try to modify

00:59:41,390 --> 00:59:49,480
this solution to sort by the sublist

00:59:46,580 --> 00:59:49,480
lengths frequency

00:59:53,380 --> 01:00:05,360
does it sound exciting enough yeah so

01:00:01,070 --> 01:00:09,280
how you going to go about it any any

01:00:05,360 --> 01:00:09,280
kind of path leads

01:00:12,049 --> 01:00:18,049
so basically what i want i have a list

01:00:14,869 --> 01:00:20,269
and list contains sub-lists this sub

01:00:18,049 --> 01:00:21,559
list can be of varying lengths they

01:00:20,269 --> 01:00:24,529
could be a bunch of sub lists of the

01:00:21,559 --> 01:00:27,589
same length in it and they could be all

01:00:24,529 --> 01:00:30,979
different so what I want to know upfront

01:00:27,589 --> 01:00:36,910
is how many lists of each length 0 and

01:00:30,979 --> 01:00:41,449
then the lists that are more frequently

01:00:36,910 --> 01:00:42,829
appearing in terms of legs if we sort in

01:00:41,449 --> 01:00:48,349
the send you know that which which this

01:00:42,829 --> 01:00:50,569
one is should come in the end so we

01:00:48,349 --> 01:00:53,390
could use the same pattern using sorted

01:00:50,569 --> 01:00:55,039
function but I guess the key function we

01:00:53,390 --> 01:01:00,579
can't use line anymore we need to define

01:00:55,039 --> 01:01:05,559
our own so then you try and write the

01:01:00,579 --> 01:01:05,559
the key function that will satisfy that

01:01:31,559 --> 01:01:39,059
how do by the way how do people feel if

01:01:34,859 --> 01:01:45,239
we run a little bit we all hungry or we

01:01:39,059 --> 01:01:47,539
could take a short break or continue now

01:01:45,239 --> 01:01:47,539
six

01:01:50,170 --> 01:01:56,830
well this is a final exercise so I have

01:01:55,090 --> 01:02:00,360
a little bit of more material which I

01:01:56,830 --> 01:02:00,360
can go over

01:02:10,690 --> 01:02:13,260
yes

01:02:17,050 --> 01:02:24,940
so and do you do you know how are you

01:02:21,550 --> 01:02:27,910
going to go about solving this know if

01:02:24,940 --> 01:02:32,550
anyone feels compelled to state how it's

01:02:27,910 --> 01:02:32,550
going to work yep go for it

01:02:42,640 --> 01:02:49,720
yeah and where would you take this

01:02:45,609 --> 01:02:52,480
dictionary from you'll have to construct

01:02:49,720 --> 01:02:54,880
it up front okay so you will have to

01:02:52,480 --> 01:02:58,390
work through the list one and to obtain

01:02:54,880 --> 01:03:01,269
this and then package this dictionary

01:02:58,390 --> 01:03:06,579
into a function get the interface right

01:03:01,269 --> 01:03:10,180
and then use that sorta del key equals

01:03:06,579 --> 01:03:14,109
whatever and this would be the way to do

01:03:10,180 --> 01:03:16,920
it so and it's reasonably simple so I

01:03:14,109 --> 01:03:21,099
guess and you could try and look at the

01:03:16,920 --> 01:03:27,160
hostel solution as well for that is it's

01:03:21,099 --> 01:03:29,529
very similar so it's a common pattern so

01:03:27,160 --> 01:03:32,049
I'm going to meet the solution and you

01:03:29,529 --> 01:03:38,109
could play with it later to make sure we

01:03:32,049 --> 01:03:41,049
don't run into other talk so here's the

01:03:38,109 --> 01:03:44,950
Haskell solution is basically and the

01:03:41,049 --> 01:03:48,789
analog of fun a dictionary in Haskell is

01:03:44,950 --> 01:03:53,769
matt is basically exactly what the

01:03:48,789 --> 01:03:57,130
George said is an imap from and into an

01:03:53,769 --> 01:03:59,859
end I just defined these types so there

01:03:57,130 --> 01:04:03,670
is more meaning in the name but so it's

01:03:59,859 --> 01:04:06,549
a map that maps lengths to frequency and

01:04:03,670 --> 01:04:09,609
then I constructed here you can import

01:04:06,549 --> 01:04:11,230
data map in haskell and play around the

01:04:09,609 --> 01:04:14,349
rev there are a bunch of constructors

01:04:11,230 --> 01:04:18,910
and one of them is from ascending list

01:04:14,349 --> 01:04:22,450
with whatever function you like to use

01:04:18,910 --> 01:04:25,960
when you have a key collision so here we

01:04:22,450 --> 01:04:29,079
obviously want to add keys so that

01:04:25,960 --> 01:04:33,029
basically we know how many sorry add

01:04:29,079 --> 01:04:36,400
values so we know how many sub lists of

01:04:33,029 --> 01:04:39,099
particular length zara so and then the

01:04:36,400 --> 01:04:41,589
solution is just this so try to

01:04:39,099 --> 01:04:44,170
basically pull it apart in your spare

01:04:41,589 --> 01:04:46,809
time and put it all back together and

01:04:44,170 --> 01:04:50,410
see how it works just biding print

01:04:46,809 --> 01:04:53,170
statements around here so so to

01:04:50,410 --> 01:04:55,940
summarize this you've noticed that we've

01:04:53,170 --> 01:05:01,400
used maps in nasco and diction

01:04:55,940 --> 01:05:06,740
using pison so here bison solution is

01:05:01,400 --> 01:05:09,020
basically a dictionary so I just wanted

01:05:06,740 --> 01:05:12,080
to talk about bison dictions a little

01:05:09,020 --> 01:05:16,130
bit so they implemented and Denise using

01:05:12,080 --> 01:05:20,180
a hash table data structure and a hash

01:05:16,130 --> 01:05:23,930
table is basically an array of key value

01:05:20,180 --> 01:05:30,080
pairs and so it's an associative

01:05:23,930 --> 01:05:32,690
container and you have some heuristics

01:05:30,080 --> 01:05:36,020
that takes a key and maps it into

01:05:32,690 --> 01:05:39,290
position in this array and basically for

01:05:36,020 --> 01:05:41,120
for example if if keys are strings it

01:05:39,290 --> 01:05:42,980
there is a hash function that you

01:05:41,120 --> 01:05:46,100
invoking string and returns something

01:05:42,980 --> 01:05:48,800
like that on the 32-bit platform and

01:05:46,100 --> 01:05:54,170
then you need to make a choice about

01:05:48,800 --> 01:05:56,420
your array size and then you mask it

01:05:54,170 --> 01:05:58,610
with array size minus one to actually

01:05:56,420 --> 01:06:00,620
get an array index and if you have a

01:05:58,610 --> 01:06:02,240
collision there is some more Urist

01:06:00,620 --> 01:06:04,460
except basically keeps perturbing the

01:06:02,240 --> 01:06:07,340
position until you find an empty

01:06:04,460 --> 01:06:10,250
location in your array of key value

01:06:07,340 --> 01:06:14,170
pairs and then once you found one you

01:06:10,250 --> 01:06:18,620
store it there so to make sure that the

01:06:14,170 --> 01:06:24,050
the performance is good this data

01:06:18,620 --> 01:06:25,430
structure is kept one-third empty so

01:06:24,050 --> 01:06:28,160
that there are not too many collisions

01:06:25,430 --> 01:06:31,690
and sorry not collisions rather there

01:06:28,160 --> 01:06:34,190
are no not too many perturbations and

01:06:31,690 --> 01:06:39,620
obviously since we have to go through

01:06:34,190 --> 01:06:41,840
this link perturbation thing if we

01:06:39,620 --> 01:06:44,770
remove something in the middle the rest

01:06:41,840 --> 01:06:47,540
might not become accessible anymore so

01:06:44,770 --> 01:06:51,170
instead of deleting items we just mark

01:06:47,540 --> 01:06:55,340
them as dummies so that's basically a

01:06:51,170 --> 01:06:57,380
very very fast implementation overview

01:06:55,340 --> 01:07:00,350
of Python dictionaries so the important

01:06:57,380 --> 01:07:02,150
bit is so that the the average case in

01:07:00,350 --> 01:07:05,680
certain look up in dictionaries are

01:07:02,150 --> 01:07:08,750
super fast they a constant time and

01:07:05,680 --> 01:07:12,410
that's why we love dictionary so much

01:07:08,750 --> 01:07:15,760
so in Haskell however as you noticed we

01:07:12,410 --> 01:07:20,510
use maps because maps actually can be

01:07:15,760 --> 01:07:23,330
implemented as immutable data structures

01:07:20,510 --> 01:07:26,150
in though there are maps that like for

01:07:23,330 --> 01:07:29,510
example red black trees in C++

01:07:26,150 --> 01:07:32,770
containers or they are all mutable but

01:07:29,510 --> 01:07:37,580
the hospital implementation uses the

01:07:32,770 --> 01:07:41,270
bounded balance in trees and the

01:07:37,580 --> 01:07:45,770
differences basically boils down to some

01:07:41,270 --> 01:07:50,350
asymptotic complexity and performance

01:07:45,770 --> 01:07:58,580
characteristics so balanced trees are

01:07:50,350 --> 01:08:04,580
guarantee that the retrieval and update

01:07:58,580 --> 01:08:06,380
are done in order of log n time and the

01:08:04,580 --> 01:08:09,040
additional benefit of them is the keys

01:08:06,380 --> 01:08:13,430
are sorted so if you if you need sorting

01:08:09,040 --> 01:08:17,330
sorted keys + good guaranteed

01:08:13,430 --> 01:08:22,190
performance you are better off with

01:08:17,330 --> 01:08:24,520
trees trees however use more RAM in the

01:08:22,190 --> 01:08:28,190
hash tables depend depending on the

01:08:24,520 --> 01:08:31,520
amount of depending on the load factor

01:08:28,190 --> 01:08:33,620
of a hash table it might be remember we

01:08:31,520 --> 01:08:35,950
had to make a decision about the size up

01:08:33,620 --> 01:08:40,940
front there might be a lot of empty

01:08:35,950 --> 01:08:43,490
slots in our array but on average I

01:08:40,940 --> 01:08:45,380
think in most use cases that trees need

01:08:43,490 --> 01:08:50,180
more ram because they have to store two

01:08:45,380 --> 01:08:54,410
pointers to every branch and also i'm

01:08:50,180 --> 01:08:56,299
told that the for low load vectors hash

01:08:54,410 --> 01:08:59,000
tables have fewer memory reads and three

01:08:56,299 --> 01:09:01,880
so they're more performant but it's

01:08:59,000 --> 01:09:04,279
mutable data structure and even though

01:09:01,880 --> 01:09:08,210
on average case considering that hash

01:09:04,279 --> 01:09:11,180
function is nice that has very few

01:09:08,210 --> 01:09:14,020
collisions and the staggering constant

01:09:11,180 --> 01:09:18,500
time performance is a very good thing

01:09:14,020 --> 01:09:20,509
but the amortized worst case is order

01:09:18,500 --> 01:09:22,140
event because you could always construct

01:09:20,509 --> 01:09:24,420
the contrived example where

01:09:22,140 --> 01:09:30,170
basically hash function is such that all

01:09:24,420 --> 01:09:35,490
the keys end up in the same bin and then

01:09:30,170 --> 01:09:37,650
the worst case is order of em so hash

01:09:35,490 --> 01:09:41,010
tables vs trees trees can be purely

01:09:37,650 --> 01:09:43,740
functional trees and require ordering

01:09:41,010 --> 01:09:46,350
relationship so if you're the entities

01:09:43,740 --> 01:09:53,330
you store it doesn't make sense for them

01:09:46,350 --> 01:09:53,330
to be ordered then hash tables a bear so

01:09:53,960 --> 01:09:58,950
sometimes hash function is quite a

01:09:56,970 --> 01:10:01,200
complex thing to evaluate so for example

01:09:58,950 --> 01:10:04,530
when you grow your hair stable if you

01:10:01,200 --> 01:10:06,900
reached the end of its capacity and then

01:10:04,530 --> 01:10:08,520
what what happens you need to increase

01:10:06,900 --> 01:10:11,040
the storage and then rehash everything

01:10:08,520 --> 01:10:15,620
so if you refresh function is very

01:10:11,040 --> 01:10:21,870
expensive and then it becomes a problem

01:10:15,620 --> 01:10:26,760
so here's an interesting quote from Don

01:10:21,870 --> 01:10:29,010
Stewart and at all basically map is

01:10:26,760 --> 01:10:32,880
implemented as a balanced binary tree

01:10:29,010 --> 01:10:34,680
and compared to a hash table it is much

01:10:32,880 --> 01:10:36,960
more efficient representation in a

01:10:34,680 --> 01:10:39,420
language with immutable data this is the

01:10:36,960 --> 01:10:41,040
most visible example of how deeply pure

01:10:39,420 --> 01:10:43,140
functional programming affects how we

01:10:41,040 --> 01:10:45,510
write code we choose data structures and

01:10:43,140 --> 01:10:49,890
algorithms that we can express cleanly

01:10:45,510 --> 01:10:57,120
that can perform efficiently but it's a

01:10:49,890 --> 01:11:00,560
constraint so so and then basically I've

01:10:57,120 --> 01:11:03,030
done a little bit more I ventured into

01:11:00,560 --> 01:11:05,010
trying to use hash tables even though

01:11:03,030 --> 01:11:09,390
it's a mutable data structure in high

01:11:05,010 --> 01:11:13,230
school and the by reading around I found

01:11:09,390 --> 01:11:14,670
out that basically since mutable data

01:11:13,230 --> 01:11:18,600
structures is not what Haskell

01:11:14,670 --> 01:11:21,150
specializes in you might not find a lot

01:11:18,600 --> 01:11:24,690
of high quality code floating around for

01:11:21,150 --> 01:11:28,050
this and they do not receive much

01:11:24,690 --> 01:11:30,780
attention therefore compiler might not

01:11:28,050 --> 01:11:33,060
do as good of a job at optimizing them

01:11:30,780 --> 01:11:34,560
so if you find an imperative data

01:11:33,060 --> 01:11:34,989
structure and try to use it from high

01:11:34,560 --> 01:11:37,119
school

01:11:34,989 --> 01:11:39,849
find out in the whole performance it

01:11:37,119 --> 01:11:41,829
might not necessarily reflect the

01:11:39,849 --> 01:11:44,769
ability of the language might reflect

01:11:41,829 --> 01:11:47,230
the basically the fact that community is

01:11:44,769 --> 01:11:51,190
not working there as much as working

01:11:47,230 --> 01:11:53,469
elsewhere and so and so basically what i

01:11:51,190 --> 01:11:56,920
did i took some examples from don't

01:11:53,469 --> 01:12:01,239
Stewart in Norman Ramsey and took a a

01:11:56,920 --> 01:12:03,699
hash table pushed 10 million integer

01:12:01,239 --> 01:12:07,329
integer pairs on it and perform one look

01:12:03,699 --> 01:12:11,650
up and so the data structure to use this

01:12:07,329 --> 01:12:13,510
data internet in this case and you can

01:12:11,650 --> 01:12:17,219
have a look at this later on the slides

01:12:13,510 --> 01:12:20,920
but the important point is that an

01:12:17,219 --> 01:12:24,789
intern app versus crash table performs

01:12:20,920 --> 01:12:26,949
performed comparable in this case so the

01:12:24,789 --> 01:12:28,749
internet is the top solution took about

01:12:26,949 --> 01:12:33,190
eight seconds and nine seconds for hash

01:12:28,749 --> 01:12:37,329
table so actually in delhi and for

01:12:33,190 --> 01:12:42,480
Haskell hash tables are notice as fast

01:12:37,329 --> 01:12:48,030
as they could have been so it actually

01:12:42,480 --> 01:12:51,309
makes us favor tree like data structures

01:12:48,030 --> 01:13:01,030
so pison solution obviously would be

01:12:51,309 --> 01:13:03,369
this so but the GC vs-si pison on this

01:13:01,030 --> 01:13:06,340
benchmark you can see that that Haskell

01:13:03,369 --> 01:13:08,739
is actually much lower and then see

01:13:06,340 --> 01:13:11,739
bison but then this is perhaps too harsh

01:13:08,739 --> 01:13:14,469
because pison dictionaries ici data

01:13:11,739 --> 01:13:17,320
structure access from bison where's

01:13:14,469 --> 01:13:19,900
Haskell is a data structure written in

01:13:17,320 --> 01:13:24,219
Haskell so if you want the same kind of

01:13:19,900 --> 01:13:28,889
a deal in Haskell you could probably try

01:13:24,219 --> 01:13:34,409
some try to interface to some

01:13:28,889 --> 01:13:34,409
implemented thin sea containers yeah

01:13:36,030 --> 01:13:44,500
I compile it with a minus 02 yeah so so

01:13:43,030 --> 01:13:47,500
basically what I did then instead of

01:13:44,500 --> 01:13:55,090
using flesh tables written in Haskell

01:13:47,500 --> 01:13:57,250
I've took what then Stuart the data Judy

01:13:55,090 --> 01:13:59,770
array which is a basically you can read

01:13:57,250 --> 01:14:02,969
up on it about it on wikipedia it's a

01:13:59,770 --> 01:14:08,830
fast mutable associative data type

01:14:02,969 --> 01:14:11,650
that's available and this is solution

01:14:08,830 --> 01:14:13,780
that's how it looks basically not very

01:14:11,650 --> 01:14:17,410
different from hash table we just import

01:14:13,780 --> 01:14:21,310
the different container and that

01:14:17,410 --> 01:14:23,890
basically did a much better job at

01:14:21,310 --> 01:14:28,300
performing one look up here so it's now

01:14:23,890 --> 01:14:30,430
comparable with C bison and then i found

01:14:28,300 --> 01:14:36,340
that typical c++ solutions while in

01:14:30,430 --> 01:14:41,800
benchmark that so GC pison and ask allow

01:14:36,340 --> 01:14:43,390
all around the same mark so thank you

01:14:41,800 --> 01:14:46,270
very much this is the end of my talking

01:14:43,390 --> 01:14:48,090
if you have any questions if you have

01:14:46,270 --> 01:14:50,710
any propositions regarding the

01:14:48,090 --> 01:14:56,140
improvement of the solutions if you

01:14:50,710 --> 01:15:01,150
found it particularly good one in terms

01:14:56,140 --> 01:15:03,400
of readability or it's a very short in

01:15:01,150 --> 01:15:06,120
terms of number of lines of code sent

01:15:03,400 --> 01:15:11,440
send it to me and i'll include it and

01:15:06,120 --> 01:15:13,770
post it with the slides so are there any

01:15:11,440 --> 01:15:13,770
questions

01:15:14,860 --> 01:15:23,889
I think everybody wants to deport unless

01:15:21,210 --> 01:15:26,889
on the pot on the Bison website all

01:15:23,889 --> 01:15:37,929
right if you mail me i can mail it to

01:15:26,889 --> 01:15:40,590
you back and so any more questions boom

01:15:37,929 --> 01:15:40,590

YouTube URL: https://www.youtube.com/watch?v=86EL6XUci-Q


