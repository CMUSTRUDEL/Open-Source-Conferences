Title: J  Hallén Testing for beginners
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	J  Hallén Testing for beginner
[Europython 2013]
5 July 2013
Track Tagliatelle
Captions: 
	00:00:20,700 --> 00:00:26,730
hi everyone we're going to begin the

00:00:23,250 --> 00:00:29,430
talk of jacoba Hallion about testing for

00:00:26,730 --> 00:00:32,279
beginners please shut up or turn off

00:00:29,430 --> 00:00:34,500
your cell phones and listen one just one

00:00:32,279 --> 00:00:38,940
note for any girl so today's veloster

00:00:34,500 --> 00:00:48,059
Google good girl a beggar so you're free

00:00:38,940 --> 00:00:50,090
absolutely free to take enjoy good

00:00:48,059 --> 00:00:55,080
morning you're welcome to this talk

00:00:50,090 --> 00:00:59,250
about testing i'm going to start it with

00:00:55,080 --> 00:01:05,009
an actual test out of code that we have

00:00:59,250 --> 00:01:06,960
written it in our company it tests

00:01:05,009 --> 00:01:11,490
something very simple it's a function

00:01:06,960 --> 00:01:15,180
where we have a date format with dashes

00:01:11,490 --> 00:01:21,030
in and this removes the dash from the

00:01:15,180 --> 00:01:25,080
forward and a test has the anatomy that

00:01:21,030 --> 00:01:28,770
it has some sort of setup then you do a

00:01:25,080 --> 00:01:31,920
call into the code then you do a

00:01:28,770 --> 00:01:35,280
comparison and then you have an expected

00:01:31,920 --> 00:01:39,330
value and that is the general setup of

00:01:35,280 --> 00:01:41,759
what the test is we're going to come

00:01:39,330 --> 00:01:48,619
back to this but first i'm going to grow

00:01:41,759 --> 00:01:48,619
in to some more theory about testing

00:01:48,890 --> 00:01:55,759
when we have a development process we

00:01:52,289 --> 00:01:58,860
have a user who has some sort of goals

00:01:55,759 --> 00:02:02,310
we need somebody to do an analysis of

00:01:58,860 --> 00:02:04,380
the goals of the user in order to get

00:02:02,310 --> 00:02:07,950
some requirements and then we have a

00:02:04,380 --> 00:02:11,160
coder who produces a program this is of

00:02:07,950 --> 00:02:14,190
course a very high level simplified

00:02:11,160 --> 00:02:17,550
model of what the development processes

00:02:14,190 --> 00:02:22,069
but in this development process we need

00:02:17,550 --> 00:02:22,069
to do testing in various different ways

00:02:23,300 --> 00:02:31,220
for the coder unit tests and integration

00:02:27,660 --> 00:02:32,540
tests are tools for assuring that the

00:02:31,220 --> 00:02:36,489
requirements

00:02:32,540 --> 00:02:40,219
are turned into code that actually

00:02:36,489 --> 00:02:43,340
fulfilled the requirements then we have

00:02:40,219 --> 00:02:46,640
system tests which actually span the

00:02:43,340 --> 00:02:49,189
whole area from user goals to the

00:02:46,640 --> 00:02:51,680
program to ensure that the entire system

00:02:49,189 --> 00:02:54,319
works together and then we have

00:02:51,680 --> 00:02:58,519
acceptance tests and deployment tests

00:02:54,319 --> 00:03:03,859
and talking about unit tests they're

00:02:58,519 --> 00:03:06,639
also known as component testing where we

00:03:03,859 --> 00:03:10,760
verify the functionality of a specific

00:03:06,639 --> 00:03:14,810
section of code normally it's either a

00:03:10,760 --> 00:03:17,299
function or a clause and this is

00:03:14,810 --> 00:03:22,639
actually the definition has taken from

00:03:17,299 --> 00:03:25,040
Wikipedia going up a level we have

00:03:22,639 --> 00:03:28,329
integration testing where we test the

00:03:25,040 --> 00:03:33,049
interface interface between components

00:03:28,329 --> 00:03:35,419
so we see that they inter operate in a

00:03:33,049 --> 00:03:37,609
correct way and there are actually two

00:03:35,419 --> 00:03:40,609
different schools for how to do this

00:03:37,609 --> 00:03:43,310
there is are those who say that the

00:03:40,609 --> 00:03:48,500
doing it gradually wastes a lot of time

00:03:43,310 --> 00:03:52,220
since that let's do it once to to test

00:03:48,500 --> 00:03:54,590
it all at the same time though I prefer

00:03:52,220 --> 00:03:59,510
the incremental model where you add

00:03:54,590 --> 00:04:01,599
things as you go along we're not going

00:03:59,510 --> 00:04:05,569
to go into details about these other

00:04:01,599 --> 00:04:07,220
tests because as a beginner the unit

00:04:05,569 --> 00:04:12,379
tests are the ones you should be

00:04:07,220 --> 00:04:15,829
focusing on system testing as I said

00:04:12,379 --> 00:04:18,139
tests a completely integrated system to

00:04:15,829 --> 00:04:20,630
see that it meets its requirements and

00:04:18,139 --> 00:04:23,599
here we're talking about the users needs

00:04:20,630 --> 00:04:27,770
rather than just the requirements

00:04:23,599 --> 00:04:31,070
specification there are testing

00:04:27,770 --> 00:04:34,159
frameworks for system testing but very

00:04:31,070 --> 00:04:37,699
often you have to do a lot of work on

00:04:34,159 --> 00:04:41,960
building your own setup for doing the

00:04:37,699 --> 00:04:45,060
system testing acceptance testing is

00:04:41,960 --> 00:04:49,410
about the user

00:04:45,060 --> 00:04:51,960
accepting the software as as it is does

00:04:49,410 --> 00:05:00,560
it actually solve the users problem or

00:04:51,960 --> 00:05:04,530
not deployment testing is something

00:05:00,560 --> 00:05:09,419
where I've actually rolled in a number

00:05:04,530 --> 00:05:11,730
of different tests that in the

00:05:09,419 --> 00:05:15,150
literature show up under the various

00:05:11,730 --> 00:05:18,900
different names but from a developer's

00:05:15,150 --> 00:05:22,350
point of view it is sort of a group of

00:05:18,900 --> 00:05:26,070
tests that you need to do in order to

00:05:22,350 --> 00:05:28,440
ensure that your code not only works in

00:05:26,070 --> 00:05:31,650
your development environment but that it

00:05:28,440 --> 00:05:37,850
works as intended in its deployed

00:05:31,650 --> 00:05:37,850
environment so here you have things like

00:05:39,320 --> 00:05:46,440
performance testing and tests that you

00:05:43,770 --> 00:05:49,260
have all the components that are needed

00:05:46,440 --> 00:05:51,150
in order to run your code that you have

00:05:49,260 --> 00:05:53,390
the right version of operating system

00:05:51,150 --> 00:05:53,390
etc

00:05:57,600 --> 00:06:05,130
but as beginners what we're focusing on

00:06:01,050 --> 00:06:08,150
our unit tests testing the components

00:06:05,130 --> 00:06:12,270
that you build and for this we have

00:06:08,150 --> 00:06:15,720
various different tools included in C

00:06:12,270 --> 00:06:19,530
Python in the standard library is pi

00:06:15,720 --> 00:06:23,670
unit which is a very good tool for doing

00:06:19,530 --> 00:06:28,320
tests it's an early tool it's a copy of

00:06:23,670 --> 00:06:30,330
the unit test tools for Java they're

00:06:28,320 --> 00:06:33,360
simple they're explicit and they're

00:06:30,330 --> 00:06:36,570
there in every version of Python out

00:06:33,360 --> 00:06:39,740
there so it's a good thing to use them

00:06:36,570 --> 00:06:42,120
unless you have more requirements and

00:06:39,740 --> 00:06:46,560
usually you have more requirements

00:06:42,120 --> 00:06:49,320
because you're doing a lot of testing

00:06:46,560 --> 00:06:52,980
when you've decided that you're going to

00:06:49,320 --> 00:06:55,020
do testing and then a framework that

00:06:52,980 --> 00:06:58,200
specialized on testing is a very good

00:06:55,020 --> 00:07:04,320
thing and we have two of them that are

00:06:58,200 --> 00:07:07,170
widely used and its pilot test it has an

00:07:04,320 --> 00:07:12,810
advanced algorithm for gathering up

00:07:07,170 --> 00:07:16,770
tests from your code base and then

00:07:12,810 --> 00:07:19,020
running them it has support for a number

00:07:16,770 --> 00:07:21,780
of different complex setups it will

00:07:19,020 --> 00:07:24,300
actually support your integration tests

00:07:21,780 --> 00:07:28,830
and your system tests as well as

00:07:24,300 --> 00:07:31,760
supporting unit testing and it has much

00:07:28,830 --> 00:07:36,630
better Diagnostics than per unit and

00:07:31,760 --> 00:07:38,760
then there is no test which is has more

00:07:36,630 --> 00:07:42,440
or less exactly the same functionality

00:07:38,760 --> 00:07:44,610
as pyro test but it's a different

00:07:42,440 --> 00:07:47,210
implementation so it works a little

00:07:44,610 --> 00:07:47,210
differently

00:07:49,289 --> 00:07:57,419
and I promised in in the information

00:07:55,830 --> 00:08:01,080
about this talk that I would give

00:07:57,419 --> 00:08:04,050
examples of both the pilot test and pi

00:08:01,080 --> 00:08:08,279
unit and this is the only example i'm

00:08:04,050 --> 00:08:11,159
giving up I unit because pyro test is

00:08:08,279 --> 00:08:14,189
actually from my perspective much easier

00:08:11,159 --> 00:08:17,759
to work with so it is a little more

00:08:14,189 --> 00:08:20,490
chatty this is the same test as I had on

00:08:17,759 --> 00:08:24,360
my first slide so instead of saying

00:08:20,490 --> 00:08:26,669
assert something equals something we

00:08:24,360 --> 00:08:33,120
have to say self dot assert equal and

00:08:26,669 --> 00:08:37,259
then something comma something and we

00:08:33,120 --> 00:08:40,800
also have to inherit the unit test or

00:08:37,259 --> 00:08:44,970
test case for things to work while with

00:08:40,800 --> 00:08:47,100
pi dot test you can just write your

00:08:44,970 --> 00:08:49,639
tests and then I drop test will take

00:08:47,100 --> 00:08:49,639
care of things

00:08:54,000 --> 00:08:59,640
a very important philosopher

00:08:56,180 --> 00:09:04,380
philosophical question is why are we

00:08:59,640 --> 00:09:09,180
unit testing how many reasons do we have

00:09:04,380 --> 00:09:12,270
to actually write tests and initially

00:09:09,180 --> 00:09:17,300
you think that well it is to say that

00:09:12,270 --> 00:09:23,030
your code works but it isn't that simple

00:09:17,300 --> 00:09:26,730
there are many reasons for writing tests

00:09:23,030 --> 00:09:31,170
the first one is that if we write a test

00:09:26,730 --> 00:09:35,430
we can formulate an idea of what our

00:09:31,170 --> 00:09:41,280
unit should do and what kind of

00:09:35,430 --> 00:09:43,530
interface it should provide now if we

00:09:41,280 --> 00:09:48,360
first write the code and then write the

00:09:43,530 --> 00:09:51,690
test we're not formulating an idea are

00:09:48,360 --> 00:09:54,870
we we already have the code so this

00:09:51,690 --> 00:09:58,290
implies that we should write our tests

00:09:54,870 --> 00:10:01,830
before we write the code because the

00:09:58,290 --> 00:10:05,330
test makes us think about what kind of

00:10:01,830 --> 00:10:05,330
interface the code should have

00:10:08,390 --> 00:10:18,580
next thing is that we checked that we do

00:10:14,030 --> 00:10:22,270
what the tasks tests ask while we do the

00:10:18,580 --> 00:10:24,920
development and always in the future

00:10:22,270 --> 00:10:28,490
since we're not doing manual tests who

00:10:24,920 --> 00:10:31,880
are doing automated tests we can reuse

00:10:28,490 --> 00:10:35,030
these tests over and over and over again

00:10:31,880 --> 00:10:37,700
every time we use the test we're

00:10:35,030 --> 00:10:40,450
actually getting a benefit of having

00:10:37,700 --> 00:10:45,530
spent the work or writing the test

00:10:40,450 --> 00:10:50,120
because it tells us that we haven't made

00:10:45,530 --> 00:10:57,770
a change that made the code not work in

00:10:50,120 --> 00:11:00,020
that piece next item is that we're

00:10:57,770 --> 00:11:05,350
writing tests to make the program

00:11:00,020 --> 00:11:11,150
testable now that sounds like a circular

00:11:05,350 --> 00:11:14,420
reasoning but it's not by making the

00:11:11,150 --> 00:11:18,560
program testable we're changing our own

00:11:14,420 --> 00:11:21,740
coding style so the program becomes

00:11:18,560 --> 00:11:25,610
different because we are writing tests

00:11:21,740 --> 00:11:28,750
and it becomes better because it becomes

00:11:25,610 --> 00:11:28,750
better structured

00:11:31,170 --> 00:11:39,510
we use tests to eliminate bug sources if

00:11:37,079 --> 00:11:45,360
we have a program that's in production

00:11:39,510 --> 00:11:46,769
and somebody finds a bug I don't know if

00:11:45,360 --> 00:11:51,180
it happens to you but it definitely

00:11:46,769 --> 00:11:54,709
happens to me when somebody finds about

00:11:51,180 --> 00:12:00,329
we are in the hurry because the

00:11:54,709 --> 00:12:04,290
customers are having problems having

00:12:00,329 --> 00:12:08,550
coverage of the code means that you can

00:12:04,290 --> 00:12:11,940
eliminate an enormous amount of sources

00:12:08,550 --> 00:12:16,170
for this bug because you have everything

00:12:11,940 --> 00:12:20,070
tested so it narrows down where the bug

00:12:16,170 --> 00:12:26,360
can be and this saves you an enormous

00:12:20,070 --> 00:12:26,360
amount of time in critical situations

00:12:29,920 --> 00:12:36,420
the next factor is that it helps us

00:12:32,649 --> 00:12:39,910
understand our code at a later stage

00:12:36,420 --> 00:12:43,420
when we've written the code it's been in

00:12:39,910 --> 00:12:47,589
production for two years and we need to

00:12:43,420 --> 00:12:51,910
make a change the tests actually tell us

00:12:47,589 --> 00:12:55,209
things about how the code works so when

00:12:51,910 --> 00:13:01,089
we need to do a refactoring this is

00:12:55,209 --> 00:13:05,610
really important I had a I have a friend

00:13:01,089 --> 00:13:09,250
who went to a course about my knee and

00:13:05,610 --> 00:13:15,670
had an Indian professor who started his

00:13:09,250 --> 00:13:18,579
lecture by saying mining is the

00:13:15,670 --> 00:13:24,760
profitable extraction of minerals from

00:13:18,579 --> 00:13:29,399
the earth if it is not profitable it's

00:13:24,760 --> 00:13:33,699
not mining it's may lead digging and

00:13:29,399 --> 00:13:37,089
about refactoring I have a similar thing

00:13:33,699 --> 00:13:43,329
and that is that if you're refactoring

00:13:37,089 --> 00:13:48,760
is the modification of your code under

00:13:43,329 --> 00:13:52,180
the constraints of tests if there are no

00:13:48,760 --> 00:13:56,160
tests it's not refactoring it's merely

00:13:52,180 --> 00:13:56,160
mucking around in your code

00:13:59,889 --> 00:14:09,939
finally tests tell us when we're done

00:14:05,279 --> 00:14:12,730
with a piece of code because the tests

00:14:09,939 --> 00:14:15,129
are the specifications of what the code

00:14:12,730 --> 00:14:20,470
is supposed to do as far as we

00:14:15,129 --> 00:14:23,230
understand our requirements so far so

00:14:20,470 --> 00:14:26,949
when your tests parts you know that

00:14:23,230 --> 00:14:30,339
you're done you need not work on this

00:14:26,949 --> 00:14:33,279
piece of code anymore and if you're

00:14:30,339 --> 00:14:35,829
writing your code without tests you

00:14:33,279 --> 00:14:43,419
don't really know if you solve the

00:14:35,829 --> 00:14:47,350
problem problem you set out to solve so

00:14:43,419 --> 00:14:53,699
when do we run our tests and essentially

00:14:47,350 --> 00:14:57,149
it is always we use the tests to check

00:14:53,699 --> 00:15:00,579
that the code we're working on passes

00:14:57,149 --> 00:15:05,829
sometimes a test suite takes very long

00:15:00,579 --> 00:15:11,040
time to run then we just run the parts

00:15:05,829 --> 00:15:11,040
that focus on the bits were working on

00:15:11,220 --> 00:15:18,040
you run your tests before you check in

00:15:14,079 --> 00:15:20,980
your code into a common repository to

00:15:18,040 --> 00:15:28,419
ensure that the common repository always

00:15:20,980 --> 00:15:32,410
works you should have automatic tests

00:15:28,419 --> 00:15:37,419
being run every time you push your code

00:15:32,410 --> 00:15:39,399
to a different repository so something

00:15:37,419 --> 00:15:43,049
runs automatically and you can go later

00:15:39,399 --> 00:15:45,569
and check did it pass or didn't it

00:15:43,049 --> 00:15:47,739
because if you made a mistake somewhere

00:15:45,569 --> 00:15:52,779
checked in some code that actually

00:15:47,739 --> 00:15:55,360
didn't run then this will find it you

00:15:52,779 --> 00:16:00,309
want to write also want to run your code

00:15:55,360 --> 00:16:04,779
nightly with a full test suite so that

00:16:00,309 --> 00:16:07,709
you have an audited trail of when your

00:16:04,779 --> 00:16:07,709
code is working

00:16:08,130 --> 00:16:14,590
you've written the test you've spent a

00:16:10,750 --> 00:16:20,680
lot of time on them so use them as much

00:16:14,590 --> 00:16:25,960
as you can now we come to the core of

00:16:20,680 --> 00:16:30,220
this talk what are we testing how do we

00:16:25,960 --> 00:16:35,680
write a test and it turns out that when

00:16:30,220 --> 00:16:40,590
you analyze what a test actually is we

00:16:35,680 --> 00:16:40,590
come up with five different cases

00:16:45,449 --> 00:16:53,160
what programs do are that they store

00:16:48,869 --> 00:16:54,869
information the unit puts the

00:16:53,160 --> 00:16:59,249
information somewhere in the data

00:16:54,869 --> 00:17:05,220
structure so the test for that is that

00:16:59,249 --> 00:17:07,649
we store the information in that the

00:17:05,220 --> 00:17:10,250
data structure will retrieve it and we

00:17:07,649 --> 00:17:14,100
check that it at is the same information

00:17:10,250 --> 00:17:20,220
so that where it gets stored is actually

00:17:14,100 --> 00:17:22,500
the same place as we retrieved when we

00:17:20,220 --> 00:17:24,870
have information in the data structure

00:17:22,500 --> 00:17:28,439
we want to retrieve it in order to do

00:17:24,870 --> 00:17:30,899
something with it so we store some

00:17:28,439 --> 00:17:35,250
information and then we check that we

00:17:30,899 --> 00:17:39,409
can retrieve it so these two kinds of

00:17:35,250 --> 00:17:43,289
tests are actually the same except that

00:17:39,409 --> 00:17:48,350
what is doing the setup and what is

00:17:43,289 --> 00:17:53,480
doing the checking change places and

00:17:48,350 --> 00:17:56,730
then we test calculating things and

00:17:53,480 --> 00:17:59,580
that's very simple to test you make the

00:17:56,730 --> 00:18:03,389
calculation and then you compare with

00:17:59,580 --> 00:18:10,110
the expected result so these kinds of

00:18:03,389 --> 00:18:13,289
tests are really really simple to do so

00:18:10,110 --> 00:18:16,130
here's an example of testing storing

00:18:13,289 --> 00:18:20,360
information it's a very simple example

00:18:16,130 --> 00:18:23,570
we have our class X which has a

00:18:20,360 --> 00:18:27,269
constructor and we test the constructor

00:18:23,570 --> 00:18:30,240
we create a value we create the object

00:18:27,269 --> 00:18:34,289
with this value and then we look inside

00:18:30,240 --> 00:18:38,039
the object in order to determine that

00:18:34,289 --> 00:18:44,070
the value we stored was the one we found

00:18:38,039 --> 00:18:47,610
in the object this seems trivial and it

00:18:44,070 --> 00:18:52,580
is trivial to do but the fact that we

00:18:47,610 --> 00:18:56,669
have this test means that if we change

00:18:52,580 --> 00:18:58,210
the name of this value for instance

00:18:56,669 --> 00:19:01,210
which we sometime

00:18:58,210 --> 00:19:07,260
do the test will fail and we will know

00:19:01,210 --> 00:19:07,260
to change this name everywhere it fails

00:19:10,110 --> 00:19:16,900
retrieving information here we have a

00:19:13,840 --> 00:19:19,990
getter in the object and in order to

00:19:16,900 --> 00:19:23,500
test it we store some information in the

00:19:19,990 --> 00:19:26,970
object we call the getter and we check

00:19:23,500 --> 00:19:33,190
that we get out the value we expected

00:19:26,970 --> 00:19:35,890
very very simple and then we have the

00:19:33,190 --> 00:19:40,960
example with the date calculation again

00:19:35,890 --> 00:19:46,030
that is the calculating bit so the hard

00:19:40,960 --> 00:19:51,940
things to test our testing input to the

00:19:46,030 --> 00:19:56,760
program and we consider everything that

00:19:51,940 --> 00:20:02,410
we haven't written ourselves as input so

00:19:56,760 --> 00:20:05,590
date databases user access socket

00:20:02,410 --> 00:20:09,970
connections third-party libraries it's

00:20:05,590 --> 00:20:14,800
all input and it's harder to test

00:20:09,970 --> 00:20:18,430
because we have to have some sort of

00:20:14,800 --> 00:20:22,330
known input on the channel we're testing

00:20:18,430 --> 00:20:25,240
and then when they need to check that it

00:20:22,330 --> 00:20:31,290
enters the program in the expected form

00:20:25,240 --> 00:20:31,290
and for output it's even harder because

00:20:31,620 --> 00:20:41,040
then we need to send out the output and

00:20:36,390 --> 00:20:44,500
then check somewhere outside the system

00:20:41,040 --> 00:20:47,070
that what we sent out was actually the

00:20:44,500 --> 00:20:47,070
correct thing

00:20:50,490 --> 00:20:59,970
so here's an example of the input we

00:20:54,920 --> 00:21:04,620
have a database in SQLite database so

00:20:59,970 --> 00:21:08,429
what we do in our pilots test setup is

00:21:04,620 --> 00:21:11,640
that we create a fixture where we set up

00:21:08,429 --> 00:21:16,470
the database and we put some information

00:21:11,640 --> 00:21:18,720
in it and then we can do a test that we

00:21:16,470 --> 00:21:22,010
retrieve the right sort of information

00:21:18,720 --> 00:21:22,010
from the database

00:21:26,169 --> 00:21:34,659
for output here's an example without

00:21:29,109 --> 00:21:38,769
code it's an example of where we're out

00:21:34,659 --> 00:21:41,529
putting things to a file so write the

00:21:38,769 --> 00:21:44,710
expected result by hand we may call to

00:21:41,529 --> 00:21:47,230
the generated to generate the file we

00:21:44,710 --> 00:21:49,840
want to to generate then we open that

00:21:47,230 --> 00:21:52,629
file we open the file with the expected

00:21:49,840 --> 00:21:56,109
result compare contents and if they're

00:21:52,629 --> 00:21:58,809
equal the test pass if not equal then we

00:21:56,109 --> 00:22:02,830
should probably show a diff between the

00:21:58,809 --> 00:22:06,909
files in order to give ourselves or the

00:22:02,830 --> 00:22:10,419
developer a hint about where the problem

00:22:06,909 --> 00:22:12,690
actually is this is not easy this is

00:22:10,419 --> 00:22:12,690
hard

00:22:16,070 --> 00:22:22,100
then you get combinations of all these

00:22:18,590 --> 00:22:26,620
because your code is never divided into

00:22:22,100 --> 00:22:29,270
the little bits the five little bits and

00:22:26,620 --> 00:22:32,750
this is actually we're testing becomes

00:22:29,270 --> 00:22:35,720
more difficult because you have all

00:22:32,750 --> 00:22:40,450
these different cases and you may have

00:22:35,720 --> 00:22:40,450
long series of what you're doing

00:22:41,200 --> 00:22:46,520
especially this one where you retrieve

00:22:43,700 --> 00:22:48,320
some information from inside the system

00:22:46,520 --> 00:22:50,570
you do a calculation and then you do

00:22:48,320 --> 00:22:54,680
your output this becomes a very

00:22:50,570 --> 00:23:00,460
complicated test indeed it becomes so

00:22:54,680 --> 00:23:00,460
complicated that we want to avoid it so

00:23:01,090 --> 00:23:07,790
how do we do that we refactor our code

00:23:04,480 --> 00:23:11,780
things that can be isolated should be

00:23:07,790 --> 00:23:14,960
broken out and isolated so that we can

00:23:11,780 --> 00:23:20,420
test them separately and this is what I

00:23:14,960 --> 00:23:23,980
talked about before that you make your

00:23:20,420 --> 00:23:23,980
code testable

00:23:26,730 --> 00:23:33,000
always make sure that you split out your

00:23:30,240 --> 00:23:40,500
outputs and inputs and test them

00:23:33,000 --> 00:23:43,169
separately separate retrieving

00:23:40,500 --> 00:23:48,240
information from storing information in

00:23:43,169 --> 00:23:53,130
your in your own code and when it comes

00:23:48,240 --> 00:23:57,120
to the output test the output with

00:23:53,130 --> 00:24:00,030
simple unchanging data don't put the

00:23:57,120 --> 00:24:02,640
information you're actually wanting to

00:24:00,030 --> 00:24:05,220
output on the channel because that's

00:24:02,640 --> 00:24:07,799
usually hard to test but if you have

00:24:05,220 --> 00:24:10,770
very simple data you can check that your

00:24:07,799 --> 00:24:16,500
output channel works and then what you

00:24:10,770 --> 00:24:19,309
put on it is tested as components inside

00:24:16,500 --> 00:24:19,309
your program

00:24:22,800 --> 00:24:24,860
you

00:24:27,370 --> 00:24:32,980
so how do you deal with the things that

00:24:29,680 --> 00:24:35,410
are really hard to test you may have

00:24:32,980 --> 00:24:39,910
components that you need to call that

00:24:35,410 --> 00:24:47,500
are too complex to do tests against you

00:24:39,910 --> 00:24:51,190
cheat instead of checking account

00:24:47,500 --> 00:24:57,960
against the component that you need to

00:24:51,190 --> 00:25:02,590
call you make a mock object which fakes

00:24:57,960 --> 00:25:05,230
the component so here I have a mock

00:25:02,590 --> 00:25:09,340
object of the database that we had

00:25:05,230 --> 00:25:11,559
before in the input example now a

00:25:09,340 --> 00:25:16,809
database needs to provide a cursor and

00:25:11,559 --> 00:25:19,450
it needs to provide an execute method so

00:25:16,809 --> 00:25:23,860
I'm cheating I'm saying that every time

00:25:19,450 --> 00:25:28,050
I call the execute method with some sort

00:25:23,860 --> 00:25:34,510
of sequel command I'm simply returning

00:25:28,050 --> 00:25:39,160
this list of items and that may be

00:25:34,510 --> 00:25:43,030
enough for the testing I need to do if

00:25:39,160 --> 00:25:46,960
my testing becomes more complex then I

00:25:43,030 --> 00:25:51,780
modify my mock object so it handles

00:25:46,960 --> 00:25:51,780
exactly those cases that I need to test

00:25:56,360 --> 00:26:05,059
the same thing with output instead of

00:26:01,059 --> 00:26:08,090
sending things off to a socket which is

00:26:05,059 --> 00:26:14,210
a really really hard to test I can mock

00:26:08,090 --> 00:26:17,120
my socket a socket is simply something

00:26:14,210 --> 00:26:19,309
to which you can connect and then you

00:26:17,120 --> 00:26:20,929
can write things too and certainly you

00:26:19,309 --> 00:26:25,660
can read as well but if I'm only

00:26:20,929 --> 00:26:31,549
interested in writing to it I just

00:26:25,660 --> 00:26:36,410
implement the right method so what I do

00:26:31,549 --> 00:26:40,850
is that I fake my socket and I make a

00:26:36,410 --> 00:26:45,679
string I or buffer that's a file in

00:26:40,850 --> 00:26:49,270
memory in Python and then I as I write

00:26:45,679 --> 00:26:53,809
things to this socket I collect it in

00:26:49,270 --> 00:26:57,710
this string I about buffer and at the

00:26:53,809 --> 00:27:01,460
end of my test I can call the get value

00:26:57,710 --> 00:27:03,980
on this buffer and there I have

00:27:01,460 --> 00:27:07,340
everything I've written to this fake

00:27:03,980 --> 00:27:09,640
socket and I can check did the

00:27:07,340 --> 00:27:15,230
information I wanted to be there

00:27:09,640 --> 00:27:16,460
actually end up there this is so

00:27:15,230 --> 00:27:20,150
important that there are several

00:27:16,460 --> 00:27:23,570
frameworks for making mock objects that

00:27:20,150 --> 00:27:25,700
help you do this and in Python 3 there

00:27:23,570 --> 00:27:30,350
is actually one included in the standard

00:27:25,700 --> 00:27:33,260
library which is really good I'm not

00:27:30,350 --> 00:27:36,520
going into details about how to use

00:27:33,260 --> 00:27:41,110
these you need to look look at the

00:27:36,520 --> 00:27:41,110
tutorials for how to do mock objects

00:27:44,269 --> 00:27:50,659
testing does not solve every single

00:27:47,179 --> 00:27:55,749
problem in the world it just gives you

00:27:50,659 --> 00:27:59,389
data points so your tests need to handle

00:27:55,749 --> 00:28:02,959
some sort of general case you should

00:27:59,389 --> 00:28:07,190
handle all edge cases that you know

00:28:02,959 --> 00:28:09,169
about so if you're doing division in the

00:28:07,190 --> 00:28:11,599
code you're testing then you should

00:28:09,169 --> 00:28:15,589
definitely test with something that

00:28:11,599 --> 00:28:20,239
gives you a division by zero to see what

00:28:15,589 --> 00:28:23,119
happens for exceptions you should

00:28:20,239 --> 00:28:27,829
certainly test all the ones that you

00:28:23,119 --> 00:28:32,959
have explicitly set up so if you have a

00:28:27,829 --> 00:28:37,450
try something except the condition then

00:28:32,959 --> 00:28:41,179
you should test for that exception and

00:28:37,450 --> 00:28:44,959
in PI test the idiom for testing an

00:28:41,179 --> 00:28:48,679
exception looks like that and if there

00:28:44,959 --> 00:28:53,029
are implicit exceptions once that may be

00:28:48,679 --> 00:28:56,509
raised for instance when indexing into a

00:28:53,029 --> 00:29:03,200
dictionary then you should take care of

00:28:56,509 --> 00:29:07,570
the important ones there as well so do i

00:29:03,200 --> 00:29:10,940
need to test all my code well it depends

00:29:07,570 --> 00:29:17,450
all untested code is a technical debt

00:29:10,940 --> 00:29:20,749
and technical debt accrues interest over

00:29:17,450 --> 00:29:25,249
time untested code will generate

00:29:20,749 --> 00:29:29,079
problems and the amount of testing you

00:29:25,249 --> 00:29:29,079
need to do depends on many factors

00:29:32,960 --> 00:29:37,730
but the technical debt is all the extra

00:29:36,080 --> 00:29:40,429
time and cost you have to spend in the

00:29:37,730 --> 00:29:44,570
future because you didn't write tests

00:29:40,429 --> 00:29:46,820
when you wrote the code so this becomes

00:29:44,570 --> 00:29:52,010
a very very strong argument for why you

00:29:46,820 --> 00:29:54,620
should be doing testing and if you can't

00:29:52,010 --> 00:29:57,289
do full coverage tests the most

00:29:54,620 --> 00:30:00,260
primitive parts of your system are the

00:29:57,289 --> 00:30:02,809
bits that you should be testing and the

00:30:00,260 --> 00:30:06,679
reason for this is that you need a very

00:30:02,809 --> 00:30:09,169
good foundation for your house without a

00:30:06,679 --> 00:30:12,260
good foundation your house will be

00:30:09,169 --> 00:30:16,039
rickety no no matter how well you build

00:30:12,260 --> 00:30:26,240
it so always test the most primitive

00:30:16,039 --> 00:30:29,090
parts first and I will finish this

00:30:26,240 --> 00:30:32,539
presentation by showing you practically

00:30:29,090 --> 00:30:35,690
how to develop tests it's going to take

00:30:32,539 --> 00:30:39,289
about five minutes but before that I I

00:30:35,690 --> 00:30:42,620
want to tell you that I'd open end we've

00:30:39,289 --> 00:30:46,610
been working with testing for seven or

00:30:42,620 --> 00:30:49,490
eight years now we're available if you

00:30:46,610 --> 00:30:53,720
need help getting started testing your

00:30:49,490 --> 00:30:56,630
code we can be Mentors we can help you

00:30:53,720 --> 00:30:59,360
with pair programming code review set up

00:30:56,630 --> 00:31:01,520
the tools set up the infrastructure so

00:30:59,360 --> 00:31:05,230
that you can test things so if you're

00:31:01,520 --> 00:31:05,230
interested come and talk to me

00:31:06,890 --> 00:31:13,480
so I have an assistant here who's going

00:31:09,800 --> 00:31:18,440
to help me with implementing some code I

00:31:13,480 --> 00:31:25,940
have decided that we need an iterator

00:31:18,440 --> 00:31:30,590
which generates dates fortnightly every

00:31:25,940 --> 00:31:33,950
two weeks so I've set up this

00:31:30,590 --> 00:31:37,910
constructor for him to to work with

00:31:33,950 --> 00:31:41,890
which all this test of a constructor

00:31:37,910 --> 00:31:45,290
which creates a fortnightly object and

00:31:41,890 --> 00:31:49,520
initializes it with a date and he

00:31:45,290 --> 00:31:52,250
doesn't have anything except the test so

00:31:49,520 --> 00:31:57,890
what he does now is that he runs the

00:31:52,250 --> 00:32:00,800
test to check that it doesn't pass and

00:31:57,890 --> 00:32:03,470
it doesn't pass it tells him that you

00:32:00,800 --> 00:32:09,670
don't actually have a more than module

00:32:03,470 --> 00:32:12,920
called fortnightly so he creates a file

00:32:09,670 --> 00:32:16,390
called fortnightly doc py and then he

00:32:12,920 --> 00:32:16,390
can run his test again

00:32:19,920 --> 00:32:26,640
and now he gets a different error can't

00:32:23,820 --> 00:32:28,890
import name fortnightly well he didn't

00:32:26,640 --> 00:32:34,940
put a class called fortnight leaned into

00:32:28,890 --> 00:32:34,940
his module so he creates the class

00:32:42,880 --> 00:32:51,900
and then it can run his test again well

00:32:45,580 --> 00:32:54,670
we have a clause that the default

00:32:51,900 --> 00:33:02,800
constructor for the class doesn't fit

00:32:54,670 --> 00:33:05,590
the model sorry doesn't fit the test so

00:33:02,800 --> 00:33:08,970
here we'll have to create a constructor

00:33:05,590 --> 00:33:08,970
for the class that fits

00:33:15,860 --> 00:33:28,070
and that works so now it complains that

00:33:24,160 --> 00:33:32,140
we don't have an attribute to current

00:33:28,070 --> 00:33:37,630
date so now he has to make his

00:33:32,140 --> 00:33:37,630
constructor actually do something

00:33:40,090 --> 00:33:46,450
and he is done he is implemented the

00:33:43,630 --> 00:33:48,909
constructor now he's fulfilled the

00:33:46,450 --> 00:33:51,940
specification now he can come to me and

00:33:48,909 --> 00:33:54,070
say well this component that I built it

00:33:51,940 --> 00:33:56,080
that doesn't actually do something so I

00:33:54,070 --> 00:34:04,809
tell him that well I have another test

00:33:56,080 --> 00:34:11,700
here it's in the buffer snippet so we

00:34:04,809 --> 00:34:16,330
add this test to our little tester and

00:34:11,700 --> 00:34:19,780
then he runs pi dot test again and it

00:34:16,330 --> 00:34:23,220
fails again because he hasn't

00:34:19,780 --> 00:34:23,220
implemented the bits

00:34:25,760 --> 00:34:38,510
so now he has to define the next method

00:34:31,730 --> 00:34:44,300
and he runs Python test again and now it

00:34:38,510 --> 00:34:47,600
complains that the dates that I'm trying

00:34:44,300 --> 00:34:51,440
to compare with or not the same because

00:34:47,600 --> 00:34:54,889
we're actually returning in none instead

00:34:51,440 --> 00:34:58,270
of the day so now he needs to make it

00:34:54,889 --> 00:34:58,270
returned a date as well

00:35:02,840 --> 00:35:09,200
and we're getting closer now we were

00:35:05,960 --> 00:35:12,500
getting told that we're getting the

00:35:09,200 --> 00:35:18,910
wrong date because we're just returning

00:35:12,500 --> 00:35:18,910
the the same day and not increasing it

00:35:19,270 --> 00:35:25,270
so now we need to increase the date by

00:35:22,280 --> 00:35:25,270
14 days

00:35:37,560 --> 00:35:45,690
and we thought we were done but we

00:35:41,820 --> 00:35:49,800
aren't because we're actually just

00:35:45,690 --> 00:35:53,520
increasing / date by 14 days and then we

00:35:49,800 --> 00:35:59,250
go back to the initial information we're

00:35:53,520 --> 00:36:02,150
not storing the information that that

00:35:59,250 --> 00:36:02,150
needed to be there

00:36:10,330 --> 00:36:24,040
so we store the information will run the

00:36:13,180 --> 00:36:27,480
test and it passes and that's the end of

00:36:24,040 --> 00:36:33,000
my talk I hope that this has given you

00:36:27,480 --> 00:36:39,540
the basis for how to think about testing

00:36:33,000 --> 00:36:39,540
the rest is just work thank you

00:36:53,400 --> 00:36:59,229
and you mentioned some frameworks for

00:36:56,859 --> 00:37:05,349
system testing have you got any names

00:36:59,229 --> 00:37:10,059
you can recommend to look at the 1i have

00:37:05,349 --> 00:37:13,289
to think that I have been using for

00:37:10,059 --> 00:37:16,390
testing web frameworks is selenium and

00:37:13,289 --> 00:37:19,479
indeed there have been a number of talks

00:37:16,390 --> 00:37:22,950
about testing here at Euro Python and I

00:37:19,479 --> 00:37:25,930
recommend her Percival's talk about

00:37:22,950 --> 00:37:28,630
testing with Django where he goes

00:37:25,930 --> 00:37:31,829
through how to use selenium to test your

00:37:28,630 --> 00:37:31,829
django framework

00:37:38,530 --> 00:37:47,200
how do you organize this you're putting

00:37:42,220 --> 00:37:50,020
the file library I don't know I'm not

00:37:47,200 --> 00:37:52,720
that that's that's a very good question

00:37:50,020 --> 00:37:56,860
and I should actually have put that into

00:37:52,720 --> 00:38:01,020
your toe into the talk what I normally

00:37:56,860 --> 00:38:04,960
do and what I detest supports is that

00:38:01,020 --> 00:38:07,630
beneath every directory where you put

00:38:04,960 --> 00:38:11,560
your code you put a directory called

00:38:07,630 --> 00:38:14,350
test and in that test you put files

00:38:11,560 --> 00:38:18,520
called test underscore and the name of

00:38:14,350 --> 00:38:20,710
the module you're testing and then you

00:38:18,520 --> 00:38:22,750
put all the tests for that module in

00:38:20,710 --> 00:38:25,230
there and then you can make sub

00:38:22,750 --> 00:38:28,780
directories if you need to distort

00:38:25,230 --> 00:38:33,750
information data that are used in those

00:38:28,780 --> 00:38:33,750
tests beneath beneath the test library

00:38:37,800 --> 00:38:48,340
certainly that's easier yes and then

00:38:45,670 --> 00:38:51,250
basically what what what we generally do

00:38:48,340 --> 00:38:57,940
is in the test file we mimic the

00:38:51,250 --> 00:38:59,260
structure of the module for each class

00:38:57,940 --> 00:39:01,480
in the module there will be a

00:38:59,260 --> 00:39:04,720
corresponding test class in the in the

00:39:01,480 --> 00:39:07,080
test file so that they sort of mirror

00:39:04,720 --> 00:39:07,080
each other

00:39:16,849 --> 00:39:26,749
which is the Python 3 instruction you

00:39:21,819 --> 00:39:29,839
mentioned before you said that for unit

00:39:26,749 --> 00:39:36,559
testing it has been introduced a great

00:39:29,839 --> 00:39:39,470
feature in Python 3 tomoka project mock

00:39:36,559 --> 00:39:42,499
object yes it's included in the library

00:39:39,470 --> 00:39:44,660
but mock object is for Python 2

00:39:42,499 --> 00:39:46,279
available as a separate package it's

00:39:44,660 --> 00:39:48,289
just not included in the standard

00:39:46,279 --> 00:39:55,130
library so it doesn't come with the

00:39:48,289 --> 00:39:58,849
distribution thanks I'm sorry about the

00:39:55,130 --> 00:40:02,180
time is 0 the next door could be about

00:39:58,849 --> 00:40:07,420
p.m. in Fond du ma in about the mass in

00:40:02,180 --> 00:40:07,420

YouTube URL: https://www.youtube.com/watch?v=-sCaA-ILuoQ


