Title: H  Král Beyond Search
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	H  Král Beyond Search
[Europython 2013]
5 July 2013
Track Ravioli
Captions: 
	00:00:35,760 --> 00:00:44,100
hello hello and good morning to room

00:00:41,339 --> 00:00:46,019
ravioli our next pick our first speaker

00:00:44,100 --> 00:00:49,530
of the day obviously is going to be

00:00:46,019 --> 00:00:58,649
honzik out from elasticsearch and he's

00:00:49,530 --> 00:01:02,789
going to speak about beyond search thank

00:00:58,649 --> 00:01:05,339
you so can everybody hear me regrets oh

00:01:02,789 --> 00:01:08,390
great so that's that part is working so

00:01:05,339 --> 00:01:17,039
let's hope the rest goes as well as well

00:01:08,390 --> 00:01:19,770
so so what I'll sing search is it is a

00:01:17,039 --> 00:01:24,210
very what we say is very buzzword

00:01:19,770 --> 00:01:26,610
compliant thing it's it yes all the

00:01:24,210 --> 00:01:30,090
other all the cool buzz words it's rest

00:01:26,610 --> 00:01:32,220
base HTTP uses JSON to communicate it's

00:01:30,090 --> 00:01:34,740
fully distributed the search it doesn

00:01:32,220 --> 00:01:37,950
Alex it just moved most of that in real

00:01:34,740 --> 00:01:40,500
time or what we call near real time it

00:01:37,950 --> 00:01:42,660
it is very scalable and it's open source

00:01:40,500 --> 00:01:46,379
and based on apache Lucene which is a

00:01:42,660 --> 00:01:48,599
very major implementation of inverted

00:01:46,379 --> 00:01:51,569
index and a lot of the search related

00:01:48,599 --> 00:01:54,599
stuff written in java one of the most

00:01:51,569 --> 00:01:57,840
advanced search engines out there what L

00:01:54,599 --> 00:02:01,530
sixers does is it enhances leucine with

00:01:57,840 --> 00:02:05,280
a lot of functionality in its core and

00:02:01,530 --> 00:02:09,450
also provides a distributed layer for

00:02:05,280 --> 00:02:11,190
for your for your document so I'll jump

00:02:09,450 --> 00:02:13,769
right in since they're already was an

00:02:11,190 --> 00:02:16,349
introductory talk bye-bye Dougal so if

00:02:13,769 --> 00:02:18,120
I'm going too fast or if I've skipped

00:02:16,349 --> 00:02:20,420
over something just raise your hand

00:02:18,120 --> 00:02:22,739
we'll deal with it right on the spot

00:02:20,420 --> 00:02:24,989
most of the talk will actually be in the

00:02:22,739 --> 00:02:26,760
form of life demo well one will show how

00:02:24,989 --> 00:02:30,900
you would typically use elastic search

00:02:26,760 --> 00:02:34,140
what are the possibilities and see how

00:02:30,900 --> 00:02:37,409
we're going so let's start with with the

00:02:34,140 --> 00:02:39,959
most simplest use case just use elastic

00:02:37,409 --> 00:02:44,099
search as you would a document data

00:02:39,959 --> 00:02:47,459
store so you can very easily just store

00:02:44,099 --> 00:02:48,550
some documents it's HTTP its rest so you

00:02:47,459 --> 00:02:51,310
just put a document

00:02:48,550 --> 00:02:53,680
and notice that there is a there are two

00:02:51,310 --> 00:02:55,690
words here the first is the name of the

00:02:53,680 --> 00:02:59,590
index the second is the name of the type

00:02:55,690 --> 00:03:02,080
so I'm using the index tag which for us

00:02:59,590 --> 00:03:04,570
will mean stack overflow I've actually

00:03:02,080 --> 00:03:07,090
taken some data from the from the

00:03:04,570 --> 00:03:09,580
publicly available data dump of stick

00:03:07,090 --> 00:03:12,400
overflow and that's what we'll be using

00:03:09,580 --> 00:03:13,960
as our as our test data so something is

00:03:12,400 --> 00:03:17,920
something real not something contrived

00:03:13,960 --> 00:03:20,620
so the first the first command is just

00:03:17,920 --> 00:03:22,240
basically asking question that's just

00:03:20,620 --> 00:03:23,860
some just some placeholder document but

00:03:22,240 --> 00:03:28,720
it should demonstrate how it actually

00:03:23,860 --> 00:03:32,140
works so index type ID I can also get it

00:03:28,720 --> 00:03:35,650
and delete it so far nothing nothing too

00:03:32,140 --> 00:03:38,200
interesting any any database or any any

00:03:35,650 --> 00:03:41,200
data store can do this so let's move

00:03:38,200 --> 00:03:43,390
over to search search is where the where

00:03:41,200 --> 00:03:46,210
the coal core of elastic search is as

00:03:43,390 --> 00:03:49,030
the name would suggest and these are two

00:03:46,210 --> 00:03:51,930
very simple very simple ways how to how

00:03:49,030 --> 00:03:54,700
to do search this one this first one is

00:03:51,930 --> 00:03:56,920
basically a way that we provide for

00:03:54,700 --> 00:03:59,020
convenience so that you can try it out

00:03:56,920 --> 00:04:01,150
when you just install elastic search

00:03:59,020 --> 00:04:03,880
which is a fancy word for saying

00:04:01,150 --> 00:04:06,160
download and run it no need to install

00:04:03,880 --> 00:04:08,470
no need to anything once you have Java

00:04:06,160 --> 00:04:12,760
you just install elastic search you on

00:04:08,470 --> 00:04:14,620
tar it you run it you're done so you can

00:04:12,760 --> 00:04:16,900
you can do this you can call this URL

00:04:14,620 --> 00:04:21,549
from a browser it will it will actually

00:04:16,900 --> 00:04:25,150
work what usually you'll end up using is

00:04:21,549 --> 00:04:27,760
the query dsl so it's the endpoint is

00:04:25,150 --> 00:04:29,850
the same its underscore search and we'll

00:04:27,760 --> 00:04:32,650
see more variants of that later on and

00:04:29,850 --> 00:04:36,130
the what this does is it basically takes

00:04:32,650 --> 00:04:39,280
a query in a leucine syntax and just

00:04:36,130 --> 00:04:42,130
execute sit but there is a there's a

00:04:39,280 --> 00:04:43,750
little problem with this the syntax the

00:04:42,130 --> 00:04:46,000
little scenes index is very powerful and

00:04:43,750 --> 00:04:47,440
you can do a lot of that but you really

00:04:46,000 --> 00:04:49,450
don't want to be in the business of

00:04:47,440 --> 00:04:52,000
concatenating strings and passing them

00:04:49,450 --> 00:04:54,460
on to the database we've usually all

00:04:52,000 --> 00:04:58,360
been there and it wasn't it wasn't very

00:04:54,460 --> 00:05:02,200
nice experience so what is what is

00:04:58,360 --> 00:05:06,900
instead what we'll do is a wheel

00:05:02,200 --> 00:05:10,150
use some our own career dsl so this is

00:05:06,900 --> 00:05:12,460
this is a pretty simple query for for

00:05:10,150 --> 00:05:15,420
elastic search and will now go quickly

00:05:12,460 --> 00:05:18,100
through it and see the difference so

00:05:15,420 --> 00:05:23,550
queries are composed of filters and

00:05:18,100 --> 00:05:26,560
queries filters range filter right here

00:05:23,550 --> 00:05:28,660
filters are bullying they either a

00:05:26,560 --> 00:05:31,720
document either matches a filter or

00:05:28,660 --> 00:05:34,900
doesn't no other options filters are

00:05:31,720 --> 00:05:37,090
very fast filters are cached so if you

00:05:34,900 --> 00:05:41,590
use the same filter over and over again

00:05:37,090 --> 00:05:43,660
it will be cached also the individual

00:05:41,590 --> 00:05:46,300
filters are cached later we'll see how

00:05:43,660 --> 00:05:47,980
we can combine queries and filters the

00:05:46,300 --> 00:05:50,500
filters are cash at the lowest possible

00:05:47,980 --> 00:05:51,940
level so if you have compound filter it

00:05:50,500 --> 00:05:54,820
will just use the caches for the

00:05:51,940 --> 00:05:59,080
individual sub filters and use them to

00:05:54,820 --> 00:06:01,000
to compute it so even when part but one

00:05:59,080 --> 00:06:02,470
of your filters it's changing you will

00:06:01,000 --> 00:06:06,430
still be using the cache very

00:06:02,470 --> 00:06:09,400
effectively so that's why rule of thumb

00:06:06,430 --> 00:06:13,860
always use filters unless you absolutely

00:06:09,400 --> 00:06:17,500
must use a query and the different query

00:06:13,860 --> 00:06:20,380
does not only tells you if your document

00:06:17,500 --> 00:06:22,600
matches but how well does it match it

00:06:20,380 --> 00:06:25,210
will calculate a relevant score of the

00:06:22,600 --> 00:06:28,690
given document based on a lot of factors

00:06:25,210 --> 00:06:30,550
based on the fields that match based on

00:06:28,690 --> 00:06:32,160
any potential boost factors that you

00:06:30,550 --> 00:06:38,170
provide it with your business knowledge

00:06:32,160 --> 00:06:39,940
based on the the term frequency in that

00:06:38,170 --> 00:06:44,020
document and in the other documents

00:06:39,940 --> 00:06:46,750
across your entire data set so this is

00:06:44,020 --> 00:06:49,240
this is pretty much the same in every

00:06:46,750 --> 00:06:51,880
search engine so I'll not go into into

00:06:49,240 --> 00:06:54,340
detail we can we can go at the end if

00:06:51,880 --> 00:06:56,050
somebody somebody has questions so what

00:06:54,340 --> 00:06:57,790
does this square you actually do so it's

00:06:56,050 --> 00:07:00,550
a filtered query so it contains a query

00:06:57,790 --> 00:07:01,960
and a filter filter just limits that we

00:07:00,550 --> 00:07:06,310
want everything that has been created

00:07:01,960 --> 00:07:10,690
after a January first 2012 and the query

00:07:06,310 --> 00:07:13,330
says that it must match a Python in

00:07:10,690 --> 00:07:15,150
either title or body this tells us that

00:07:13,330 --> 00:07:16,800
title is more important

00:07:15,150 --> 00:07:20,700
for us we've boosted it with a factor of

00:07:16,800 --> 00:07:23,670
10 and it must not match but a PHP in

00:07:20,700 --> 00:07:25,410
the title so for it is pretty

00:07:23,670 --> 00:07:28,890
straightforward pretty straightforward

00:07:25,410 --> 00:07:36,950
query and the this is this will be our

00:07:28,890 --> 00:07:39,090
our starting point for further that was

00:07:36,950 --> 00:07:43,530
there will be our starting point for

00:07:39,090 --> 00:07:46,680
further exploration so i have i have a

00:07:43,530 --> 00:07:48,600
similar similar cory here but i'm i'm

00:07:46,680 --> 00:07:51,420
really sorry i couldn't be showing you

00:07:48,600 --> 00:07:52,710
the data from Stack Overflow because I

00:07:51,420 --> 00:07:55,440
just don't have enough space on my hard

00:07:52,710 --> 00:07:58,170
drive so for the actual live demo I just

00:07:55,440 --> 00:08:00,870
I just took the data from DBA stack

00:07:58,170 --> 00:08:01,980
exchange so instead of programming

00:08:00,870 --> 00:08:05,160
languages we will be talking about

00:08:01,980 --> 00:08:08,340
databases so I've pretty much the same

00:08:05,160 --> 00:08:11,460
query using using using my sequel i'm

00:08:08,340 --> 00:08:16,730
using i'm using curl commands to

00:08:11,460 --> 00:08:16,730
actually actually execute everything and

00:08:16,970 --> 00:08:21,480
notice that i'm talking to an index

00:08:19,680 --> 00:08:25,040
that's called DBA stack exchange accom

00:08:21,480 --> 00:08:28,080
i'm i'm only searching for questions and

00:08:25,040 --> 00:08:31,830
so you can see already that the endpoint

00:08:28,080 --> 00:08:33,870
search can all can already be in the end

00:08:31,830 --> 00:08:35,850
on the index level on the type level or

00:08:33,870 --> 00:08:37,650
on the cluster level that means that

00:08:35,850 --> 00:08:41,940
will search across all the indices I

00:08:37,650 --> 00:08:44,910
could even do something like this which

00:08:41,940 --> 00:08:47,310
will serve search over multiple types I

00:08:44,910 --> 00:08:50,040
could do the same for for the for the

00:08:47,310 --> 00:08:54,740
index so let's see what happens when we

00:08:50,040 --> 00:08:54,740
actually execute this data

00:09:02,550 --> 00:09:04,610
you

00:09:08,410 --> 00:09:12,770
say that you believe me that these are

00:09:11,060 --> 00:09:17,480
these are actual questions from the

00:09:12,770 --> 00:09:20,240
basic exchange and we can actually do

00:09:17,480 --> 00:09:22,490
something about this so what we'll do as

00:09:20,240 --> 00:09:24,590
the first alteration to our query the

00:09:22,490 --> 00:09:26,630
query remains the same I've just added a

00:09:24,590 --> 00:09:30,170
line to limit the fields that we want to

00:09:26,630 --> 00:09:31,760
return usually there's not much used for

00:09:30,170 --> 00:09:33,320
this in your application unless you have

00:09:31,760 --> 00:09:35,330
some really large fields that you don't

00:09:33,320 --> 00:09:39,110
want to be getting back but if you

00:09:35,330 --> 00:09:42,290
actually want to be want to be showing

00:09:39,110 --> 00:09:46,040
it off at a conference it's very useful

00:09:42,290 --> 00:09:49,040
when you can actually see the documents

00:09:46,040 --> 00:09:53,360
that that that were returned so you can

00:09:49,040 --> 00:09:56,630
see here is the document the document ID

00:09:53,360 --> 00:09:58,730
the index where it's stored it scores so

00:09:56,630 --> 00:10:01,490
how relevant it is to our to our

00:09:58,730 --> 00:10:03,410
question what type it is it's the type

00:10:01,490 --> 00:10:07,580
of question and the two fields that we

00:10:03,410 --> 00:10:11,150
requested creation date and title so far

00:10:07,580 --> 00:10:13,970
nothing nothing surprising I'm going

00:10:11,150 --> 00:10:16,370
rather quickly over the examples feel

00:10:13,970 --> 00:10:18,170
free to raise your hand if I'm going a

00:10:16,370 --> 00:10:21,290
little bit too quickly or if you feel

00:10:18,170 --> 00:10:23,090
that I've skipped something if if you

00:10:21,290 --> 00:10:24,740
feel like that there's more than likely

00:10:23,090 --> 00:10:29,240
that somebody else feels like that too

00:10:24,740 --> 00:10:32,300
so it will not be wasted time but we've

00:10:29,240 --> 00:10:34,520
also also searched over over the body

00:10:32,300 --> 00:10:36,920
field and I don't want to return it hold

00:10:34,520 --> 00:10:39,710
because that's that would be unreadable

00:10:36,920 --> 00:10:41,450
as but especially with this font size so

00:10:39,710 --> 00:10:43,910
what I'll do is I'll add another

00:10:41,450 --> 00:10:45,860
component to the query and I'll ask

00:10:43,910 --> 00:10:49,330
alice sixers to highlight the results

00:10:45,860 --> 00:10:52,160
for me so I'll ask to highlight the

00:10:49,330 --> 00:10:54,350
results for fields title and body I'm

00:10:52,160 --> 00:10:57,440
just limiting the fragment size so it's

00:10:54,350 --> 00:10:59,320
not too so it's not too big so we can

00:10:57,440 --> 00:11:03,500
actually again fit on the screen and

00:10:59,320 --> 00:11:06,170
what this actually means is three

00:11:03,500 --> 00:11:12,410
different again I'm pretty printing here

00:11:06,170 --> 00:11:15,560
using just using just a Python but you

00:11:12,410 --> 00:11:18,500
can actually append a question mark

00:11:15,560 --> 00:11:19,800
pretty to any to any ausick search URL

00:11:18,500 --> 00:11:22,980
and it will do the pretty printing

00:11:19,800 --> 00:11:24,860
for you I just wanted the the actual

00:11:22,980 --> 00:11:31,500
shell files to be as simple as possible

00:11:24,860 --> 00:11:34,470
so this is already here we see that we

00:11:31,500 --> 00:11:36,959
have returned the body and the title

00:11:34,470 --> 00:11:40,620
with the list of matches where you can

00:11:36,959 --> 00:11:43,140
see that the parts that match our query

00:11:40,620 --> 00:11:46,769
so the parts that are my sequel are

00:11:43,140 --> 00:11:49,380
highlighted using using HTML tags of

00:11:46,769 --> 00:11:51,360
course we can we can override that and

00:11:49,380 --> 00:11:53,579
and choose either different tags or a

00:11:51,360 --> 00:11:57,930
different method of highlighting

00:11:53,579 --> 00:11:59,910
entirely so this is this would be very

00:11:57,930 --> 00:12:01,170
difficult to do on the client side not

00:11:59,910 --> 00:12:03,959
only what you need to get the entire

00:12:01,170 --> 00:12:06,570
entire document or entire body field and

00:12:03,959 --> 00:12:10,339
then search for the my sequel but

00:12:06,570 --> 00:12:13,440
because the data are matched based on of

00:12:10,339 --> 00:12:16,260
for the criteria for example we'll match

00:12:13,440 --> 00:12:19,170
it even if it's in different case will

00:12:16,260 --> 00:12:21,390
do stemming before we do before we do

00:12:19,170 --> 00:12:24,240
the search so for something like my my

00:12:21,390 --> 00:12:25,980
sequel it doesn't it's not much

00:12:24,240 --> 00:12:28,529
difference but for example imagine that

00:12:25,980 --> 00:12:30,870
we were searching for postgrads instead

00:12:28,529 --> 00:12:33,209
so we would be searching for postgres

00:12:30,870 --> 00:12:35,940
but we would naturally expect the

00:12:33,209 --> 00:12:40,140
database to find pulls grass and pull

00:12:35,940 --> 00:12:41,820
square sequel and PG sequel because all

00:12:40,140 --> 00:12:44,130
of these are synonyms for post grads and

00:12:41,820 --> 00:12:48,120
we can tell elasticsearch when we create

00:12:44,130 --> 00:12:50,130
an index for DBA that those those are

00:12:48,120 --> 00:12:53,100
synonyms so if we search our postgres

00:12:50,130 --> 00:12:55,500
and it would find PG sequel PG sequel

00:12:53,100 --> 00:12:57,420
would be highlighted which is not which

00:12:55,500 --> 00:12:59,310
is not trivial to do in your application

00:12:57,420 --> 00:13:02,279
you basically have to duplicate the

00:12:59,310 --> 00:13:06,089
entire logic that you that you've got

00:13:02,279 --> 00:13:10,290
our six search to do for you so just to

00:13:06,089 --> 00:13:13,579
show off a little more colleague of mine

00:13:10,290 --> 00:13:15,990
actually wrote a little tool just to

00:13:13,579 --> 00:13:19,730
pretty print the result of the query so

00:13:15,990 --> 00:13:24,170
this is this is how it how it looks

00:13:19,730 --> 00:13:24,170
unfortunately it doesn't really fit on

00:13:25,020 --> 00:13:29,340
fit to the width with this font but this

00:13:27,870 --> 00:13:32,250
is basically the document this is how

00:13:29,340 --> 00:13:34,680
we'll be looking at it now so we have

00:13:32,250 --> 00:13:38,010
the ID the title the metadata

00:13:34,680 --> 00:13:39,810
information so score index type we have

00:13:38,010 --> 00:13:42,630
the fields that we want want to return

00:13:39,810 --> 00:13:44,730
creation date and title and we have we

00:13:42,630 --> 00:13:51,000
have the highlights actually highlighted

00:13:44,730 --> 00:13:54,660
in in NC colors so what do we so what do

00:13:51,000 --> 00:13:56,880
we do next next let's start complicating

00:13:54,660 --> 00:14:00,480
things a little bit so far we've only

00:13:56,880 --> 00:14:07,560
been searching for for my sequel so

00:14:00,480 --> 00:14:10,710
let's search something that has my

00:14:07,560 --> 00:14:13,260
sequel but also doesn't have no sequel

00:14:10,710 --> 00:14:14,970
so we are looking for questions that

00:14:13,260 --> 00:14:17,160
somebody asked that somebody is asking

00:14:14,970 --> 00:14:20,430
about my sequel and he is not mentioning

00:14:17,160 --> 00:14:22,380
no sequel so what we did is instead of

00:14:20,430 --> 00:14:26,670
just the multi match we not suddenly

00:14:22,380 --> 00:14:29,820
have a bull query here and bull query

00:14:26,670 --> 00:14:33,330
has has several parts oh there's must

00:14:29,820 --> 00:14:35,610
must not and should so must and must not

00:14:33,330 --> 00:14:38,430
are pretty obvious the shoot clause

00:14:35,610 --> 00:14:41,400
would contain a queries that are

00:14:38,430 --> 00:14:44,610
optional but would but would contribute

00:14:41,400 --> 00:14:46,560
to the score of the document so a

00:14:44,610 --> 00:14:49,860
document that would match not only the

00:14:46,560 --> 00:14:51,690
mask claws but also also any queries

00:14:49,860 --> 00:14:59,340
from the shoot clauses would get higher

00:14:51,690 --> 00:15:04,920
up in in the result list so I am pretty

00:14:59,340 --> 00:15:07,380
sure that nothing has changed we still

00:15:04,920 --> 00:15:10,110
we still we still get all the all the

00:15:07,380 --> 00:15:12,630
documents that are relevant to us we

00:15:10,110 --> 00:15:14,990
didn't see any no sequel before so this

00:15:12,630 --> 00:15:17,610
is basically just a step in preparation

00:15:14,990 --> 00:15:20,220
preparation for that for the next one

00:15:17,610 --> 00:15:23,250
and before we actually before we

00:15:20,220 --> 00:15:26,280
actually get there there is one one

00:15:23,250 --> 00:15:31,320
thing one more theoretical thing we need

00:15:26,280 --> 00:15:33,480
to talk so our prayers have been have

00:15:31,320 --> 00:15:35,370
been answered because so far everything

00:15:33,480 --> 00:15:37,800
is working let's hope it will it will

00:15:35,370 --> 00:15:38,730
hold if we get into more interesting

00:15:37,800 --> 00:15:40,740
stuff

00:15:38,730 --> 00:15:43,709
and this is what i wanted to want it I

00:15:40,740 --> 00:15:45,899
wanted to talk to you typically with

00:15:43,709 --> 00:15:48,329
documents doors and search engines you

00:15:45,899 --> 00:15:50,459
worked with individual documents Alex

00:15:48,329 --> 00:15:52,889
urge has has two ways to actually

00:15:50,459 --> 00:15:54,360
introduce some actual relationships

00:15:52,889 --> 00:15:56,940
between documents the first one is

00:15:54,360 --> 00:15:58,709
parent-child in in the data set that we

00:15:56,940 --> 00:16:00,420
have we'll be using it to represent the

00:15:58,709 --> 00:16:02,519
relationship with Neil question and an

00:16:00,420 --> 00:16:05,550
answer so we are saying that then that

00:16:02,519 --> 00:16:08,880
an answer is a child of the question and

00:16:05,550 --> 00:16:11,490
what this enables us to do is we can

00:16:08,880 --> 00:16:13,829
search over the answers but we're turn

00:16:11,490 --> 00:16:15,690
the questions so we can filter the

00:16:13,829 --> 00:16:18,930
questions based on based on their

00:16:15,690 --> 00:16:21,240
answers and vice versa so how it's

00:16:18,930 --> 00:16:23,339
actually set up one's when you define

00:16:21,240 --> 00:16:26,190
the mapping which is the sort of schema

00:16:23,339 --> 00:16:29,940
for for the type so here we are defining

00:16:26,190 --> 00:16:32,279
the type for answer we'll just say that

00:16:29,940 --> 00:16:35,910
the parent is of a type question and

00:16:32,279 --> 00:16:38,430
then when we are indexing a one answer

00:16:35,910 --> 00:16:40,620
will just notify all sick search who

00:16:38,430 --> 00:16:43,019
what the parent is this is very

00:16:40,620 --> 00:16:47,459
important because this enables l6 urge

00:16:43,019 --> 00:16:49,410
to store the parent and the child in the

00:16:47,459 --> 00:16:52,319
same chart on the same machine in the

00:16:49,410 --> 00:16:54,329
cluster so that this join is actually

00:16:52,319 --> 00:16:57,180
possible because otherwise it would be

00:16:54,329 --> 00:17:00,630
very very expensive expensive operation

00:16:57,180 --> 00:17:02,760
so once we are using the parent-child

00:17:00,630 --> 00:17:04,410
relationship we need to make sure that

00:17:02,760 --> 00:17:06,630
we always specify the parent when we

00:17:04,410 --> 00:17:09,390
were dealing with the with the child

00:17:06,630 --> 00:17:13,530
because that determines where the child

00:17:09,390 --> 00:17:15,449
is stored and this of course allows us

00:17:13,530 --> 00:17:17,669
to do the hess parent and has child

00:17:15,449 --> 00:17:20,610
queries so this is an example of the his

00:17:17,669 --> 00:17:23,579
parent query so this is we are querying

00:17:20,610 --> 00:17:27,449
answers and we are looking for parents

00:17:23,579 --> 00:17:29,640
so for questions that i mentioned python

00:17:27,449 --> 00:17:32,040
in their in their body so this will

00:17:29,640 --> 00:17:35,340
return us all the questions to the

00:17:32,040 --> 00:17:40,049
answers that mention python how is that

00:17:35,340 --> 00:17:46,010
how is that useful let's see what we can

00:17:40,049 --> 00:17:46,010
what we can do deal with this so

00:17:46,639 --> 00:17:53,850
we ended up with a in the last step of

00:17:50,970 --> 00:17:56,159
the demo we ended up searching for

00:17:53,850 --> 00:17:59,190
questions that contain my sequel and not

00:17:56,159 --> 00:18:01,710
no sequel so what we will add is will

00:17:59,190 --> 00:18:04,649
actually add a has child query so we'll

00:18:01,710 --> 00:18:07,259
look for questions that mention my

00:18:04,649 --> 00:18:09,419
sequel don't mention no sequel but one

00:18:07,259 --> 00:18:12,149
of their responses do mention no sequel

00:18:09,419 --> 00:18:13,200
so we are basically looking for for

00:18:12,149 --> 00:18:15,059
questions that have been trolled

00:18:13,200 --> 00:18:17,190
somebody is looking for a problem with

00:18:15,059 --> 00:18:19,499
my sequel and somebody's offering a

00:18:17,190 --> 00:18:26,539
solution with no sequel not very helpful

00:18:19,499 --> 00:18:32,809
but we've all done it so unfortunately

00:18:26,539 --> 00:18:32,809
if we actually if we actually run it

00:18:36,649 --> 00:18:41,309
there's no much difference because we

00:18:38,850 --> 00:18:43,889
are still only returning the the

00:18:41,309 --> 00:18:46,590
question so we have we have no idea who

00:18:43,889 --> 00:18:48,419
who who the troll is what what's what's

00:18:46,590 --> 00:18:49,860
going on there we have just limited a

00:18:48,419 --> 00:18:51,539
limited the question so if we actually

00:18:49,860 --> 00:18:54,029
wanted to print this out to the user in

00:18:51,539 --> 00:18:59,850
a web interface that would that would be

00:18:54,029 --> 00:19:02,330
useful for us for us we'll just rewrite

00:18:59,850 --> 00:19:06,960
the query to work the other way around

00:19:02,330 --> 00:19:09,090
so we'll just do right now we are

00:19:06,960 --> 00:19:10,590
searching for answers so i turned the

00:19:09,090 --> 00:19:15,570
query around i'm searching for answers

00:19:10,590 --> 00:19:19,139
whose parent is mentions my sequel and

00:19:15,570 --> 00:19:22,830
not no sequel and the answer mentions

00:19:19,139 --> 00:19:25,919
mentions no sequel this is just just to

00:19:22,830 --> 00:19:28,409
show how composable and inflexible that

00:19:25,919 --> 00:19:31,529
the dsl is you can take the core queries

00:19:28,409 --> 00:19:35,879
so the match the multi match and another

00:19:31,529 --> 00:19:38,580
and compose them using the compost

00:19:35,879 --> 00:19:40,789
queries bull has parent and everything

00:19:38,580 --> 00:19:40,789
yes

00:19:43,440 --> 00:19:48,629
I'll ask you I'll repeat the question oh

00:19:50,309 --> 00:19:58,299
yeah so yeah I did take of the boot Oh

00:19:54,389 --> 00:19:59,649
so I'll just repeat it and when you

00:19:58,299 --> 00:20:02,200
switch this around did you deliberately

00:19:59,649 --> 00:20:03,639
take off the beast on the title it's a

00:20:02,200 --> 00:20:06,370
ton limitation or was that just like a

00:20:03,639 --> 00:20:09,580
tight body and it was it was something

00:20:06,370 --> 00:20:11,830
in between a typo and deliberation I

00:20:09,580 --> 00:20:13,360
just wanted to fit on on on the one page

00:20:11,830 --> 00:20:17,649
because I tested it with a slightly

00:20:13,360 --> 00:20:19,929
smaller font but uh there was there was

00:20:17,649 --> 00:20:21,429
no reason for me to do so the score of

00:20:19,929 --> 00:20:23,740
the of the parent will actually

00:20:21,429 --> 00:20:26,409
contribute to the score of the document

00:20:23,740 --> 00:20:27,639
I can actually even control that so i

00:20:26,409 --> 00:20:30,610
can i can say whether it just

00:20:27,639 --> 00:20:32,529
contributes or a dozen or or there is

00:20:30,610 --> 00:20:35,820
actually also has parent filter and

00:20:32,529 --> 00:20:38,529
stuff like that good catch by the way i

00:20:35,820 --> 00:20:40,779
was pretty sure nobody will notice that

00:20:38,529 --> 00:20:44,249
al i'll be able to get away with it i

00:20:40,779 --> 00:20:47,740
have to be more careful in the future so

00:20:44,249 --> 00:20:49,240
we've we've done the queries is not

00:20:47,740 --> 00:20:51,399
interesting we've just we've just turned

00:20:49,240 --> 00:20:53,710
it around it looks very it looks very

00:20:51,399 --> 00:20:59,409
similar but it does the exact opposite

00:20:53,710 --> 00:21:01,210
thing so when we actually run it finally

00:20:59,409 --> 00:21:04,389
we have we have some we have something

00:21:01,210 --> 00:21:05,799
interesting so yeah by the way your

00:21:04,389 --> 00:21:08,499
schema looks like something which could

00:21:05,799 --> 00:21:10,929
fit into no sequel solution seriously

00:21:08,499 --> 00:21:13,029
like somebody's asking for for help with

00:21:10,929 --> 00:21:17,590
my sequel and and you're just going to

00:21:13,029 --> 00:21:19,240
troll them no no so so this just this is

00:21:17,590 --> 00:21:21,279
just there to show that I was not lying

00:21:19,240 --> 00:21:23,799
when I was claiming that the query works

00:21:21,279 --> 00:21:30,129
in a certain way this is exactly exactly

00:21:23,799 --> 00:21:34,659
what it does so back to back to the

00:21:30,129 --> 00:21:37,029
original query and what we'll do now is

00:21:34,659 --> 00:21:39,100
we took the width to the original query

00:21:37,029 --> 00:21:42,159
which is here that the query filtered

00:21:39,100 --> 00:21:43,929
and we wrapped it once more in a custom

00:21:42,159 --> 00:21:46,899
query just to show you one more type of

00:21:43,929 --> 00:21:50,429
query and what custom score query does

00:21:46,899 --> 00:21:53,080
is it will allow you to transform the

00:21:50,429 --> 00:21:54,550
relevant score of the given document if

00:21:53,080 --> 00:21:56,950
you have some business knowledge

00:21:54,550 --> 00:21:59,910
for example imagine that you have a site

00:21:56,950 --> 00:22:03,970
a QA site where the individual vote

00:21:59,910 --> 00:22:09,010
individual users can vote how good how

00:22:03,970 --> 00:22:11,350
good a question or answer is once I

00:22:09,010 --> 00:22:13,780
learn to type i'll show you that i can

00:22:11,350 --> 00:22:15,820
then introduce a script that will

00:22:13,780 --> 00:22:18,610
actually take that into account so I'm

00:22:15,820 --> 00:22:20,710
taking the original score adding one

00:22:18,610 --> 00:22:22,300
because it looked better in the result

00:22:20,710 --> 00:22:24,400
you probably want to have some more

00:22:22,300 --> 00:22:26,350
complicated math formula here than what

00:22:24,400 --> 00:22:28,600
i'm doing here and i multiply by the

00:22:26,350 --> 00:22:30,280
rating of the document so i take a

00:22:28,600 --> 00:22:33,310
number from the document the popularity

00:22:30,280 --> 00:22:37,120
and I i will say that these documents

00:22:33,310 --> 00:22:43,720
are more important so it's not the same

00:22:37,120 --> 00:22:47,140
as as boosting which in which are which

00:22:43,720 --> 00:22:49,570
was shown in the score as well but this

00:22:47,140 --> 00:22:53,530
is just taking the the raw value of the

00:22:49,570 --> 00:22:55,810
score that the flow value and passing it

00:22:53,530 --> 00:23:00,000
through a transformation so what this

00:22:55,810 --> 00:23:03,270
will do is if we actually examine

00:23:00,000 --> 00:23:03,270
examine the results

00:23:07,530 --> 00:23:12,330
so we start with at the very bottom of

00:23:10,680 --> 00:23:14,490
our of our search result we have

00:23:12,330 --> 00:23:18,870
something with rating 1 and we see that

00:23:14,490 --> 00:23:23,310
it has it has 22 matches one in title 1

00:23:18,870 --> 00:23:26,070
and body it has a score of 2.9 if we go

00:23:23,310 --> 00:23:29,370
up we have something that has rating of

00:23:26,070 --> 00:23:32,130
3 and only one match so we can already

00:23:29,370 --> 00:23:34,020
see that it's actually working it has a

00:23:32,130 --> 00:23:36,840
rating of 3 so it's potentially three

00:23:34,020 --> 00:23:39,300
times better than than the previous

00:23:36,840 --> 00:23:42,690
document and if we go further up we have

00:23:39,300 --> 00:23:46,410
something that has a rating of one but

00:23:42,690 --> 00:23:49,410
it has a lot of a lot of hits the

00:23:46,410 --> 00:23:51,140
relevancy was was really high before we

00:23:49,410 --> 00:23:54,390
actually started transforming the

00:23:51,140 --> 00:23:57,180
transforming the score so this just

00:23:54,390 --> 00:24:00,630
shows you that it's not the same as if

00:23:57,180 --> 00:24:02,070
we were just sorting by the rating we

00:24:00,630 --> 00:24:04,620
are sort of taking the rating that's

00:24:02,070 --> 00:24:08,070
that's our own value and the relevancy

00:24:04,620 --> 00:24:09,780
score taken from taken from leucine

00:24:08,070 --> 00:24:12,240
taken from elasticsearch and we are

00:24:09,780 --> 00:24:14,790
combining them to provide better results

00:24:12,240 --> 00:24:17,070
either something that's very relevant or

00:24:14,790 --> 00:24:21,240
something that's not as relevant but

00:24:17,070 --> 00:24:27,560
it's very good so just just one just one

00:24:21,240 --> 00:24:31,860
query that that will allow us to to see

00:24:27,560 --> 00:24:37,350
to see some of a some more power of

00:24:31,860 --> 00:24:38,910
elasticsearch so now we we start with

00:24:37,350 --> 00:24:40,740
the same query so we still have the

00:24:38,910 --> 00:24:42,630
script we still have the fields and

00:24:40,740 --> 00:24:47,250
highlights and everything and we add one

00:24:42,630 --> 00:24:51,360
last thing and what we add is actually

00:24:47,250 --> 00:24:55,830
facets so what facets are are some sort

00:24:51,360 --> 00:24:58,950
of aggregation field so right right here

00:24:55,830 --> 00:25:02,910
we are asking for tags and frequency and

00:24:58,950 --> 00:25:06,120
tags is a terms facet and it uses the

00:25:02,910 --> 00:25:08,120
field tags that's very fancy and very

00:25:06,120 --> 00:25:11,640
cryptic and what it actually means is

00:25:08,120 --> 00:25:14,460
give me all the tags that occur in this

00:25:11,640 --> 00:25:17,070
in this result set in the entire results

00:25:14,460 --> 00:25:18,440
it's not just the ten items that I'm

00:25:17,070 --> 00:25:22,100
being

00:25:18,440 --> 00:25:26,000
I'm being returned and just just sum

00:25:22,100 --> 00:25:30,139
them up so we'll see the distribution of

00:25:26,000 --> 00:25:33,100
tags across across this result set at a

00:25:30,139 --> 00:25:38,000
cloud if you will and do a similar thing

00:25:33,100 --> 00:25:40,429
for dates so take every month and give

00:25:38,000 --> 00:25:41,659
me how many we are still searching for a

00:25:40,429 --> 00:25:46,519
question so how many questions were

00:25:41,659 --> 00:25:49,460
there during that month and this is this

00:25:46,519 --> 00:25:51,860
is something that that runs very

00:25:49,460 --> 00:25:57,620
effectively an elastic search even on

00:25:51,860 --> 00:26:01,490
large data sets and what it actually

00:25:57,620 --> 00:26:03,559
does is exactly as described so we see

00:26:01,490 --> 00:26:05,450
we see the facets so we see the

00:26:03,559 --> 00:26:09,019
fragments a for each month we see the

00:26:05,450 --> 00:26:12,409
number of questions for each tag we see

00:26:09,019 --> 00:26:16,690
the number of occurrences so this is

00:26:12,409 --> 00:26:20,299
this is a very powerful thing and we are

00:26:16,690 --> 00:26:22,429
slowly running out of time so this is

00:26:20,299 --> 00:26:24,350
very powerful thing for either faceted

00:26:22,429 --> 00:26:27,289
navigation so for example if you ever

00:26:24,350 --> 00:26:29,600
searched for a hotel or anything on the

00:26:27,289 --> 00:26:31,399
left side you had the number of hotels

00:26:29,600 --> 00:26:34,159
that have three stars and four stars

00:26:31,399 --> 00:26:36,740
that's where it came from that's that's

00:26:34,159 --> 00:26:40,460
just a facet that will tell you how many

00:26:36,740 --> 00:26:42,950
how many hotels in your in your in yours

00:26:40,460 --> 00:26:44,960
matches your search criteria that have

00:26:42,950 --> 00:26:46,759
three stars that have four stars when

00:26:44,960 --> 00:26:49,789
you click on it typically in the web

00:26:46,759 --> 00:26:51,559
interface it will just add the filter so

00:26:49,789 --> 00:26:53,570
this is where it came from and that's

00:26:51,559 --> 00:26:55,850
one one big use case for the faceted

00:26:53,570 --> 00:26:59,120
navigation the other use case for it is

00:26:55,850 --> 00:27:02,299
actually doing analytics so this is

00:26:59,120 --> 00:27:04,340
gabbana this is an open source plug in 4

00:27:02,299 --> 00:27:07,009
for elastic search it was it was

00:27:04,340 --> 00:27:08,870
developed to work with log stash for

00:27:07,009 --> 00:27:11,750
analyzing logs that are stored in

00:27:08,870 --> 00:27:14,029
elastic search but I like to I like to

00:27:11,750 --> 00:27:16,610
use it to demonstrate what facets can

00:27:14,029 --> 00:27:19,039
actually do so I'm searching across the

00:27:16,610 --> 00:27:21,200
index I have some hits here I can i can

00:27:19,039 --> 00:27:24,860
click and see the individual fields that

00:27:21,200 --> 00:27:26,659
that compose that i have i have the

00:27:24,860 --> 00:27:30,200
distribution over time in here i can

00:27:26,659 --> 00:27:31,360
just zoom in i have the tag cloud right

00:27:30,200 --> 00:27:35,110
here

00:27:31,360 --> 00:27:38,230
postgres equal six six percent sequel

00:27:35,110 --> 00:27:41,410
server twenty-five percent sad state of

00:27:38,230 --> 00:27:43,390
our database market and we have the

00:27:41,410 --> 00:27:49,600
distribution across number of comments 0

00:27:43,390 --> 00:27:53,440
0 to 2 is 357 2244 and more comments per

00:27:49,600 --> 00:27:56,260
question what what what where this is

00:27:53,440 --> 00:27:59,740
amazing is it actually enables us to

00:27:56,260 --> 00:28:02,530
combine to combine the analytics with

00:27:59,740 --> 00:28:04,270
the full-text search in this is what

00:28:02,530 --> 00:28:11,320
what this is what I was saying when I

00:28:04,270 --> 00:28:13,390
when I was mentioning near real-time so

00:28:11,320 --> 00:28:15,940
currently this is this is just this is

00:28:13,390 --> 00:28:20,140
just a couple hundred megabytes of data

00:28:15,940 --> 00:28:21,730
running running on my on my machine we

00:28:20,140 --> 00:28:24,309
have actually customers that have tens

00:28:21,730 --> 00:28:26,980
of terabytes of data in one cluster and

00:28:24,309 --> 00:28:28,929
they're running analytics right this and

00:28:26,980 --> 00:28:31,419
because of the distributed nature of

00:28:28,929 --> 00:28:39,700
elastic search everything works just

00:28:31,419 --> 00:28:42,340
fine so just to just to finish the very

00:28:39,700 --> 00:28:43,980
very very very quick overview of the of

00:28:42,340 --> 00:28:46,390
the additional additional features

00:28:43,980 --> 00:28:48,070
nested is it is a other type of

00:28:46,390 --> 00:28:50,950
relationship we are using that for

00:28:48,070 --> 00:28:52,780
comments which basically means take take

00:28:50,950 --> 00:28:55,419
the comments and embed them into the

00:28:52,780 --> 00:28:57,760
original original document we can still

00:28:55,419 --> 00:29:00,970
search over over the comments we can

00:28:57,760 --> 00:29:02,980
even facet over them and get the

00:29:00,970 --> 00:29:05,440
individual get the data for the

00:29:02,980 --> 00:29:08,370
individual comments so this would be a

00:29:05,440 --> 00:29:11,080
query that would search for for a

00:29:08,370 --> 00:29:14,040
question or answer where there is a

00:29:11,080 --> 00:29:18,790
comment that mentions Python and is

00:29:14,040 --> 00:29:21,490
written by somebody from Italy so a

00:29:18,790 --> 00:29:23,559
search on a search on an SD document and

00:29:21,490 --> 00:29:26,080
the last feature I want to mention is

00:29:23,559 --> 00:29:29,440
the percolator so the percolator is

00:29:26,080 --> 00:29:32,290
reversed search so you will index your

00:29:29,440 --> 00:29:34,480
queries and then you will run you'll run

00:29:32,290 --> 00:29:36,940
your queries basically with the document

00:29:34,480 --> 00:29:39,520
so you you have an index queries and you

00:29:36,940 --> 00:29:41,110
will just send in a document and you

00:29:39,520 --> 00:29:42,940
will get received the list of the

00:29:41,110 --> 00:29:44,970
queries that actually matched the name

00:29:42,940 --> 00:29:46,890
of the queries that matched so we're

00:29:44,970 --> 00:29:50,370
here i'm creating query that's called

00:29:46,890 --> 00:29:53,580
conf i'm looking for anything that has

00:29:50,370 --> 00:29:57,809
that has conference in its tile it

00:29:53,580 --> 00:30:00,780
should be title and then I'm just saying

00:29:57,809 --> 00:30:03,120
sending in sending in a document which

00:30:00,780 --> 00:30:05,760
actually has a conference in the title

00:30:03,120 --> 00:30:09,090
so the result of the second call would

00:30:05,760 --> 00:30:11,400
be oh the conf Corey matched so this is

00:30:09,090 --> 00:30:14,419
a very very efficient way very very easy

00:30:11,400 --> 00:30:18,600
way how to implement saved searches

00:30:14,419 --> 00:30:20,610
alert for for your users for example if

00:30:18,600 --> 00:30:23,610
you have a job board you can you can

00:30:20,610 --> 00:30:26,370
very easily let the users define their

00:30:23,610 --> 00:30:29,730
own queries using the whole power of

00:30:26,370 --> 00:30:32,190
elastic search dsl and then just then

00:30:29,730 --> 00:30:34,409
just alert them when there is it when

00:30:32,190 --> 00:30:38,190
there is a new ad matching matching

00:30:34,409 --> 00:30:40,169
their criteria so I'm afraid we don't

00:30:38,190 --> 00:30:43,080
have we don't have really time to go

00:30:40,169 --> 00:30:45,809
into into into the scaling part of parts

00:30:43,080 --> 00:30:47,850
of things because we we want to do we

00:30:45,809 --> 00:30:51,390
want to do some some questions instead

00:30:47,850 --> 00:30:53,820
so just to just to make it short there's

00:30:51,390 --> 00:30:55,650
nothing more i can i can i can say i

00:30:53,820 --> 00:30:59,280
haven't been kidding when i said that

00:30:55,650 --> 00:31:00,870
there are people storing tens and some

00:30:59,280 --> 00:31:03,330
even hundreds of terabytes of data in

00:31:00,870 --> 00:31:05,760
one cluster obviously you need some you

00:31:03,330 --> 00:31:07,470
need some hardware to do it but it it is

00:31:05,760 --> 00:31:10,460
Alice exerts its really good about

00:31:07,470 --> 00:31:13,650
scaling horizontally and not vertically

00:31:10,460 --> 00:31:15,450
so just to demonstrate this is the

00:31:13,650 --> 00:31:19,679
current state on my machine i'm running

00:31:15,450 --> 00:31:21,539
three clusters so for the 11 index three

00:31:19,679 --> 00:31:23,669
nodes i'm sorry so for the one index

00:31:21,539 --> 00:31:25,260
that's fairly small this is the

00:31:23,669 --> 00:31:27,809
distribution across the nodes I've

00:31:25,260 --> 00:31:30,270
decided beforehand that I want to split

00:31:27,809 --> 00:31:32,070
this index into five cards for each are

00:31:30,270 --> 00:31:33,330
there should be at least one replica so

00:31:32,070 --> 00:31:35,880
there should be at least two copies

00:31:33,330 --> 00:31:40,289
across the clusters so you can see one

00:31:35,880 --> 00:31:42,030
row is each node so if I were to lose

00:31:40,289 --> 00:31:45,150
one node I still wouldn't lose any data

00:31:42,030 --> 00:31:47,400
if I were to add one more node Aleksic

00:31:45,150 --> 00:31:50,100
search would just rebalance the shards

00:31:47,400 --> 00:31:53,730
so that each node would have roughly the

00:31:50,100 --> 00:31:56,450
same amount of charge so if anybody is

00:31:53,730 --> 00:31:58,179
interested in more of these features

00:31:56,450 --> 00:32:00,429
let's

00:31:58,179 --> 00:32:02,860
let's get together after after the talk

00:32:00,429 --> 00:32:11,409
and not bother everybody else right now

00:32:02,860 --> 00:32:18,369
there's time for questions that's

00:32:11,409 --> 00:32:20,320
amazing any questions yes hey can you go

00:32:18,369 --> 00:32:26,080
to one of the first slides with a

00:32:20,320 --> 00:32:27,450
filters in title probably okay there's

00:32:26,080 --> 00:32:34,720
an easy question to answer somebody else

00:32:27,450 --> 00:32:39,809
yeah and now the one slide back yeah so

00:32:34,720 --> 00:32:43,980
I are you trying to convince me that the

00:32:39,809 --> 00:32:49,450
next slide the query on the next life is

00:32:43,980 --> 00:32:52,480
easier that the previous slide honestly

00:32:49,450 --> 00:32:55,749
for me if I would be a user of this API

00:32:52,480 --> 00:32:58,899
I would like to ask the query exactly

00:32:55,749 --> 00:33:04,029
like this yes and even more I can feel

00:32:58,899 --> 00:33:09,580
this query into post because it easily

00:33:04,029 --> 00:33:12,730
fits and this very nested JSON I can't

00:33:09,580 --> 00:33:14,259
really do it so I understand it's not an

00:33:12,730 --> 00:33:17,529
easy thing to write it took me a couple

00:33:14,259 --> 00:33:21,340
tries to try to do this what's important

00:33:17,529 --> 00:33:24,610
to realize though is you are usually not

00:33:21,340 --> 00:33:26,320
worrying this manually you have you have

00:33:24,610 --> 00:33:28,720
usually some piece of code that will

00:33:26,320 --> 00:33:32,169
generate those queries for you and it's

00:33:28,720 --> 00:33:33,820
usually better to be to be generating

00:33:32,169 --> 00:33:36,879
something that's a well-defined data

00:33:33,820 --> 00:33:40,269
structure than to be generating a blob

00:33:36,879 --> 00:33:42,490
of text so we've we've all been there

00:33:40,269 --> 00:33:44,200
with sequel like of course it's it's

00:33:42,490 --> 00:33:46,240
very easy to concatenate some strings

00:33:44,200 --> 00:33:48,100
and get a sequel query but in the end

00:33:46,240 --> 00:33:50,230
you will end up using some sort of RM

00:33:48,100 --> 00:33:52,869
which if you look at it it's it's it's

00:33:50,230 --> 00:33:55,029
more difficult but this is exactly the

00:33:52,869 --> 00:34:00,070
reason because this you were you're

00:33:55,029 --> 00:34:02,649
working with you're working with with

00:34:00,070 --> 00:34:05,289
well-defined data structure and also one

00:34:02,649 --> 00:34:07,210
more thing because elasticsearch can

00:34:05,289 --> 00:34:08,619
actually understand this way better just

00:34:07,210 --> 00:34:11,590
the distinction between filters and

00:34:08,619 --> 00:34:13,990
queries it will will be able to be more

00:34:11,590 --> 00:34:17,680
ficient about the about the execution

00:34:13,990 --> 00:34:19,210
and you will have so much more power for

00:34:17,680 --> 00:34:21,790
example the multi match is not possible

00:34:19,210 --> 00:34:29,920
in in the simple in the end in this

00:34:21,790 --> 00:34:32,650
simple syntax API is not not intended to

00:34:29,920 --> 00:34:35,440
be exposed to end users that would like

00:34:32,650 --> 00:34:39,130
to perform a search but for developers

00:34:35,440 --> 00:34:41,830
that would like to develop some search

00:34:39,130 --> 00:34:43,540
functionality yes what you should you

00:34:41,830 --> 00:34:45,520
should all you should never let your

00:34:43,540 --> 00:34:47,380
users talk directly to elasticsearch and

00:34:45,520 --> 00:34:49,270
even letting them use this syntax is

00:34:47,380 --> 00:34:50,950
pretty dangerous yeah but sometimes i

00:34:49,270 --> 00:34:55,840
would like to expose the API that's

00:34:50,950 --> 00:34:59,410
trial yes users can can use to search

00:34:55,840 --> 00:35:01,210
something we with many critic crea teria

00:34:59,410 --> 00:35:03,550
so you can see here that I'm actually

00:35:01,210 --> 00:35:05,860
using the dsl I'm using the query string

00:35:03,550 --> 00:35:08,170
query which I can use anywhere when I'm

00:35:05,860 --> 00:35:10,900
using any any other type of query so I

00:35:08,170 --> 00:35:13,090
could have a must a multi match and a

00:35:10,900 --> 00:35:14,890
string query so i am i'm not i'm not

00:35:13,090 --> 00:35:17,530
losing that it's not it's not going away

00:35:14,890 --> 00:35:19,390
we're just recommending people not not

00:35:17,530 --> 00:35:21,700
to use it because it's very dangerous if

00:35:19,390 --> 00:35:23,620
you expose it to users because they can

00:35:21,700 --> 00:35:25,900
then search over any fields even those

00:35:23,620 --> 00:35:29,290
that they should know that they're there

00:35:25,900 --> 00:35:31,930
and they can do a lot of expensive

00:35:29,290 --> 00:35:34,900
operations that can actually help your

00:35:31,930 --> 00:35:37,810
performance what's the method to

00:35:34,900 --> 00:35:42,160
incrementally build in this is so that

00:35:37,810 --> 00:35:46,930
to minimize dist conization between

00:35:42,160 --> 00:35:48,820
search data and actual database ok so we

00:35:46,930 --> 00:35:51,160
get this question a lot we just we

00:35:48,820 --> 00:35:53,230
recommend that you just that you just

00:35:51,160 --> 00:35:56,410
build some sort of some sort of q if

00:35:53,230 --> 00:35:58,810
you're using python celery is a is it is

00:35:56,410 --> 00:36:00,970
a great way so whenever you have a you

00:35:58,810 --> 00:36:02,860
have a change in in database for example

00:36:00,970 --> 00:36:04,960
you're using Django so you'll just use

00:36:02,860 --> 00:36:07,210
the signals where model have model has

00:36:04,960 --> 00:36:10,600
changed you will dispatch you will

00:36:07,210 --> 00:36:13,180
dispatch a task into the queue that will

00:36:10,600 --> 00:36:15,790
then take the model and push push it

00:36:13,180 --> 00:36:18,760
into push it into elasticsearch that's

00:36:15,790 --> 00:36:21,250
that's how people generally do it some

00:36:18,760 --> 00:36:22,510
people only care about daily snapshots

00:36:21,250 --> 00:36:24,460
of the data so they would do bulk

00:36:22,510 --> 00:36:24,880
loading overnight there aren't there

00:36:24,460 --> 00:36:27,640
many way

00:36:24,880 --> 00:36:30,220
days I generally recommend using the Q

00:36:27,640 --> 00:36:32,980
approach with celery or whatever seller

00:36:30,220 --> 00:36:35,350
is the easiest I judged by your t-shirt

00:36:32,980 --> 00:36:39,760
that Django is probably what you're

00:36:35,350 --> 00:36:42,400
poison so you said that when there's one

00:36:39,760 --> 00:36:47,130
data structure which is well defined so

00:36:42,400 --> 00:36:51,570
this is formally defined would you haha

00:36:47,130 --> 00:36:55,900
sort of so I haven't seen a grammar yet

00:36:51,570 --> 00:36:58,510
so but it actually it actually is so you

00:36:55,900 --> 00:37:01,450
have a on the top level you always have

00:36:58,510 --> 00:37:05,260
query and and other potential things a

00:37:01,450 --> 00:37:07,690
query and either be a core query like

00:37:05,260 --> 00:37:10,330
this or some other query for example

00:37:07,690 --> 00:37:13,480
filtered which which again is well

00:37:10,330 --> 00:37:16,480
defined that it takes a query and a

00:37:13,480 --> 00:37:18,190
filter so it sits this composable model

00:37:16,480 --> 00:37:20,230
that's not defined in one place but if

00:37:18,190 --> 00:37:22,060
you actually look up the documentation

00:37:20,230 --> 00:37:24,010
for filtered query you'll find this

00:37:22,060 --> 00:37:25,620
information it is a query so you can use

00:37:24,010 --> 00:37:31,030
it anywhere where you would use a query

00:37:25,620 --> 00:37:34,030
but it's also it's also come then

00:37:31,030 --> 00:37:37,240
composed of a query and a filter and

00:37:34,030 --> 00:37:39,910
again a filter can either be either be

00:37:37,240 --> 00:37:41,710
this core filter or some other compound

00:37:39,910 --> 00:37:44,740
filter for example a bull filter that

00:37:41,710 --> 00:37:48,250
will take that range has to be the last

00:37:44,740 --> 00:37:54,280
two years also that the the rating must

00:37:48,250 --> 00:38:02,040
be at least 32 to 42 and and stuff like

00:37:54,280 --> 00:38:02,040
that so yes and now any other questions

00:38:03,240 --> 00:38:09,520
you've mentioned something about

00:38:05,140 --> 00:38:17,350
synonyms do have to provide like a

00:38:09,520 --> 00:38:20,680
dictionary it will guess or do you

00:38:17,350 --> 00:38:23,710
specify them in the query or no no this

00:38:20,680 --> 00:38:25,390
happens this happen at index time so

00:38:23,710 --> 00:38:28,810
actually when you're defining when

00:38:25,390 --> 00:38:30,610
you're defining the type you also define

00:38:28,810 --> 00:38:33,430
which method should be used for

00:38:30,610 --> 00:38:36,370
analyzing the text and there are many

00:38:33,430 --> 00:38:38,020
many many options when we do training we

00:38:36,370 --> 00:38:41,650
talked for three hours

00:38:38,020 --> 00:38:44,770
around just that and it will basically

00:38:41,650 --> 00:38:47,140
differ how you define how to break the

00:38:44,770 --> 00:38:49,510
text into individual tokens what then to

00:38:47,140 --> 00:38:51,580
do with the with the with it with the

00:38:49,510 --> 00:38:54,220
token afterwards and one of the possible

00:38:51,580 --> 00:38:55,990
steps is apply synonyms and you can

00:38:54,220 --> 00:38:59,350
either give it a file with the synonyms

00:38:55,990 --> 00:39:02,740
or just list them in the JSON when

00:38:59,350 --> 00:39:05,650
you're defining defining the type so

00:39:02,740 --> 00:39:07,600
okay I'm afraid that we ran out of time

00:39:05,650 --> 00:39:09,430
for questions I'll be I'll be outside if

00:39:07,600 --> 00:39:12,160
you if you want to if you want to ask

00:39:09,430 --> 00:39:15,000
more I'll be happy to talk more thank

00:39:12,160 --> 00:39:15,000

YouTube URL: https://www.youtube.com/watch?v=_lVijLepOAM


