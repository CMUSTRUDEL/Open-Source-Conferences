Title: C  Kerstiens Going beyond the Django ORM limitations with Postgres
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	C  Kerstiens Going beyond the Django ORM limitations with Postgres
[Europython 2013]
5 July 2013
Track Ravioli
Captions: 
	00:00:55,380 --> 00:01:02,980
hello and welcome back to room ravioli

00:00:59,790 --> 00:01:05,199
our next speaker of the day is going to

00:01:02,980 --> 00:01:07,630
be well it's quite clear so I just got

00:01:05,199 --> 00:01:09,700
to say the name Craig Christians I hope

00:01:07,630 --> 00:01:20,200
I said it well and he's going to speak

00:01:09,700 --> 00:01:22,270
about postgres thanks everyone so I'm

00:01:20,200 --> 00:01:24,130
Craig kirstine i work at Heroku as I was

00:01:22,270 --> 00:01:27,790
saying earlier specifically on the

00:01:24,130 --> 00:01:29,619
Heroku postgres team really quick show

00:01:27,790 --> 00:01:32,740
of hands how many people here use Django

00:01:29,619 --> 00:01:35,860
or have you use Django okay what I would

00:01:32,740 --> 00:01:38,050
expect how about a postgres similar ok a

00:01:35,860 --> 00:01:42,280
few less at least so maybe those of you

00:01:38,050 --> 00:01:45,729
that have them I can convince so really

00:01:42,280 --> 00:01:47,920
quickly before I kind of dig in a PSA if

00:01:45,729 --> 00:01:50,350
you're on a Mac and you use homebrew or

00:01:47,920 --> 00:01:52,840
macports and you've ever had issues with

00:01:50,350 --> 00:01:55,300
it in the future if you have issues you

00:01:52,840 --> 00:01:56,760
may want to look at postgres doubt this

00:01:55,300 --> 00:01:59,200
is something her okies helped create

00:01:56,760 --> 00:02:00,760
it's a native mac installer so it's like

00:01:59,200 --> 00:02:01,960
every other mac application it just kind

00:02:00,760 --> 00:02:06,460
of works you don't have to think about

00:02:01,960 --> 00:02:07,960
it and one other is a postgres weekly so

00:02:06,460 --> 00:02:11,200
this is a weekly newsletter that

00:02:07,960 --> 00:02:13,480
actually i curate with the peter cooper

00:02:11,200 --> 00:02:15,550
running the rest of it with about five

00:02:13,480 --> 00:02:17,410
to ten links every week on on postgres

00:02:15,550 --> 00:02:18,730
and how to use it take advantage of

00:02:17,410 --> 00:02:20,320
features that kind of thing so not

00:02:18,730 --> 00:02:21,730
really what's going on at the core

00:02:20,320 --> 00:02:26,620
development level but how do you as an

00:02:21,730 --> 00:02:28,450
end user take advantage of postgres so

00:02:26,620 --> 00:02:31,810
really quickly kind of why postgres

00:02:28,450 --> 00:02:33,940
there's a couple of links here one is to

00:02:31,810 --> 00:02:36,970
a talk that I gave earlier in the

00:02:33,940 --> 00:02:38,620
conference Tuesday one another it's just

00:02:36,970 --> 00:02:40,120
kind of a blog post how many people were

00:02:38,620 --> 00:02:44,200
in that talk on Tuesday or been in

00:02:40,120 --> 00:02:47,650
another overview postgres talk ok so a

00:02:44,200 --> 00:02:49,600
few so I'm a rehash a few things here

00:02:47,650 --> 00:02:52,840
but i'll try to get two more of the

00:02:49,600 --> 00:02:55,830
jenga side mostly but if you missed any

00:02:52,840 --> 00:02:58,930
of those this is kind of the the TLDR of

00:02:55,830 --> 00:03:02,350
why do you use postgres it's a pretty

00:02:58,930 --> 00:03:03,790
rich list and there's probably a lot of

00:03:02,350 --> 00:03:05,920
things missing from here

00:03:03,790 --> 00:03:07,290
a couple I think of really big things

00:03:05,920 --> 00:03:11,859
that stand out from other databases

00:03:07,290 --> 00:03:13,420
transactional ddl is really big foreign

00:03:11,859 --> 00:03:15,549
data wrappers these are absolutely

00:03:13,420 --> 00:03:16,989
awesome going to be a big part of the

00:03:15,549 --> 00:03:19,930
future of postgres this is where you can

00:03:16,989 --> 00:03:23,109
query data from inside postgres out to

00:03:19,930 --> 00:03:25,030
lie credits or MongoDB or Oracle or any

00:03:23,109 --> 00:03:26,739
other data source that you want there's

00:03:25,030 --> 00:03:30,000
even ones for like Twitter which I'm not

00:03:26,739 --> 00:03:31,629
sure the point but you can do it

00:03:30,000 --> 00:03:33,159
extensions are another really great

00:03:31,629 --> 00:03:35,620
thing where you going to add a little

00:03:33,159 --> 00:03:37,450
bit of extra functionality that sort of

00:03:35,620 --> 00:03:39,639
ships with postgres core postgres or

00:03:37,450 --> 00:03:41,739
maybe doesn't and we'll we'll highlight

00:03:39,639 --> 00:03:43,090
a little bit of that but I think the big

00:03:41,739 --> 00:03:46,150
thing is really momentum if you look at

00:03:43,090 --> 00:03:48,760
every release since probably 8 45 years

00:03:46,150 --> 00:03:51,099
ago every release is packed with a lot

00:03:48,760 --> 00:03:52,599
of new exciting features and its really

00:03:51,099 --> 00:03:54,280
starting to incorporate the best of

00:03:52,599 --> 00:03:56,829
every other database out there which is

00:03:54,280 --> 00:03:58,030
nice so is paying good attention to you

00:03:56,829 --> 00:03:59,950
know what's manga doing well what's

00:03:58,030 --> 00:04:01,659
MySQL doing well what's Oracle doing

00:03:59,950 --> 00:04:06,489
well and starting to pull those in so it

00:04:01,659 --> 00:04:09,729
can be much more of a data platform the

00:04:06,489 --> 00:04:12,250
big problem though is is this with

00:04:09,729 --> 00:04:14,680
Django I'm a big fan of Django it's

00:04:12,250 --> 00:04:17,079
great for applications it comes with a

00:04:14,680 --> 00:04:19,299
lot of batteries included but the short

00:04:17,079 --> 00:04:22,150
of it is it tries to treat all databases

00:04:19,299 --> 00:04:25,270
the same it tries to be just as fair to

00:04:22,150 --> 00:04:28,330
sequel light as it is to mysql as it is

00:04:25,270 --> 00:04:32,560
to postgres and and that creates certain

00:04:28,330 --> 00:04:37,150
problems so I mean one example of this

00:04:32,560 --> 00:04:40,750
is is data types in Postgres you have

00:04:37,150 --> 00:04:41,919
data types that look like this so

00:04:40,750 --> 00:04:43,960
postgres takes a bit of a different

00:04:41,919 --> 00:04:45,639
approach they don't believe that you

00:04:43,960 --> 00:04:47,680
have to have five or six data types and

00:04:45,639 --> 00:04:51,510
push everything into those you've got it

00:04:47,680 --> 00:04:56,310
just six data types for numbers alone

00:04:51,510 --> 00:04:58,360
you've got three for IP and mac address

00:04:56,310 --> 00:05:00,490
basically not working with networking

00:04:58,360 --> 00:05:01,870
directly in our database a nice thing

00:05:00,490 --> 00:05:04,630
about having these inside your database

00:05:01,870 --> 00:05:06,250
is it's optimized for it as well and

00:05:04,630 --> 00:05:08,729
knows how they index on it well better

00:05:06,250 --> 00:05:11,139
than just text and that kind of thing

00:05:08,729 --> 00:05:13,659
it's got shapes built-in even without

00:05:11,139 --> 00:05:15,070
post GIS which is an extension for

00:05:13,659 --> 00:05:16,900
Richard geospatial stuff you can do

00:05:15,070 --> 00:05:18,340
basic polygons

00:05:16,900 --> 00:05:21,250
the distance between those which is

00:05:18,340 --> 00:05:24,310
really nice now as I said it tries to

00:05:21,250 --> 00:05:27,490
treat all databases the same so then you

00:05:24,310 --> 00:05:30,340
have sequel light which has these data

00:05:27,490 --> 00:05:31,720
types and the really confusing part

00:05:30,340 --> 00:05:34,270
about this this is from the sequel light

00:05:31,720 --> 00:05:36,070
docks to me I don't understand how Knoll

00:05:34,270 --> 00:05:38,770
is a data type I thought it was a value

00:05:36,070 --> 00:05:41,860
of a data type so a reality there's

00:05:38,770 --> 00:05:45,729
really only four and I don't understand

00:05:41,860 --> 00:05:47,440
how that really maps to that so you're

00:05:45,729 --> 00:05:51,310
instantly limiting yourself when you

00:05:47,440 --> 00:05:53,710
kind of focus on only using the ORM even

00:05:51,310 --> 00:05:54,880
outside of the ORM if you kind of stick

00:05:53,710 --> 00:05:58,900
with the bare-bones you've got some

00:05:54,880 --> 00:06:01,990
limitations so postgres as you might

00:05:58,900 --> 00:06:04,449
expect is a pretty rich feature set with

00:06:01,990 --> 00:06:09,039
indexes it has multiple types so it has

00:06:04,449 --> 00:06:12,490
beat regen gist kan SP just so a variety

00:06:09,039 --> 00:06:14,889
of index types south which is soon

00:06:12,490 --> 00:06:17,110
getting in ported kind of to the core of

00:06:14,889 --> 00:06:18,729
django essentially only supports the

00:06:17,110 --> 00:06:21,099
beach we index it's just create index it

00:06:18,729 --> 00:06:22,780
has no other types of indexes there's

00:06:21,099 --> 00:06:24,610
also conditional and functional indexes

00:06:22,780 --> 00:06:27,160
which I don't believe South supports I

00:06:24,610 --> 00:06:28,930
could be wrong on that though and the

00:06:27,160 --> 00:06:31,780
other thing is that South migrations

00:06:28,930 --> 00:06:33,070
always run in a transaction who here is

00:06:31,780 --> 00:06:37,690
not familiar with create index

00:06:33,070 --> 00:06:39,190
concurrently ok a few hands so typically

00:06:37,690 --> 00:06:40,419
when you add an index it's going to take

00:06:39,190 --> 00:06:43,330
a lock on your table which means you

00:06:40,419 --> 00:06:45,520
can't write new data if you've ever done

00:06:43,330 --> 00:06:48,039
this in certain other databases I won't

00:06:45,520 --> 00:06:49,930
name any names this could take a day to

00:06:48,039 --> 00:06:51,340
add an index so you're improving

00:06:49,930 --> 00:06:52,750
performance but you're basically taking

00:06:51,340 --> 00:06:55,150
your application offline for a whole day

00:06:52,750 --> 00:06:56,740
create index concurrently is going to do

00:06:55,150 --> 00:06:59,380
this in the background it's going to be

00:06:56,740 --> 00:07:00,669
about two to three times slower but it's

00:06:59,380 --> 00:07:01,930
not going to hold a lock on your table

00:07:00,669 --> 00:07:03,580
and as soon as it's done creating that

00:07:01,930 --> 00:07:04,690
index it's going to start using it so

00:07:03,580 --> 00:07:06,930
you don't have to take your application

00:07:04,690 --> 00:07:09,130
online and you can improve performance

00:07:06,930 --> 00:07:10,930
but as I said self doesn't take

00:07:09,130 --> 00:07:12,669
advantage of it because it can't run the

00:07:10,930 --> 00:07:14,289
transaction so you kind of have to go

00:07:12,669 --> 00:07:20,050
outside south to take advantage of this

00:07:14,289 --> 00:07:23,699
or do it manually in there and my sequel

00:07:20,050 --> 00:07:23,699
well they have indexes

00:07:25,470 --> 00:07:30,940
so this is great but I kind of want to

00:07:30,100 --> 00:07:34,210
take advantage of all these cool

00:07:30,940 --> 00:07:35,680
features of postgres so digging in let's

00:07:34,210 --> 00:07:37,360
look at a few of them and then we'll see

00:07:35,680 --> 00:07:40,960
how we kind of actually use them within

00:07:37,360 --> 00:07:44,229
Django of course the first is a race

00:07:40,960 --> 00:07:46,300
this is probably my second favorite data

00:07:44,229 --> 00:07:48,490
type in my my absolute favorite needed

00:07:46,300 --> 00:07:50,740
data type in Postgres that's very

00:07:48,490 --> 00:07:52,270
underused if you've gone through the

00:07:50,740 --> 00:07:54,490
Django tutorial and created you know

00:07:52,270 --> 00:07:56,560
basic blog application or ever built a

00:07:54,490 --> 00:07:58,570
web front store you usually have

00:07:56,560 --> 00:08:00,160
categories this is really common a lot

00:07:58,570 --> 00:08:05,430
of applications you tag things or have

00:08:00,160 --> 00:08:07,389
categories and creating an extra call a

00:08:05,430 --> 00:08:11,050
table for that just seems like overkill

00:08:07,389 --> 00:08:12,190
to me postgres has native arrays just

00:08:11,050 --> 00:08:13,750
like you would in your application you

00:08:12,190 --> 00:08:15,759
can have an array in Postgres and you

00:08:13,750 --> 00:08:17,500
can have an array of any data type so

00:08:15,759 --> 00:08:20,560
here what I've done is said you know

00:08:17,500 --> 00:08:22,389
I've got tags for my my items in my

00:08:20,560 --> 00:08:24,250
shopping cart so I can tag these is

00:08:22,389 --> 00:08:25,900
whatever I want and then search on them

00:08:24,250 --> 00:08:28,870
just like you'd expect and this is all

00:08:25,900 --> 00:08:30,550
in the same row on the data but i can

00:08:28,870 --> 00:08:31,780
still filter index on it everything else

00:08:30,550 --> 00:08:35,560
i just don't have to have a whole other

00:08:31,780 --> 00:08:37,510
table for that so looking at inside

00:08:35,560 --> 00:08:39,849
postgres it's going to look something

00:08:37,510 --> 00:08:41,649
like this if I've got items that you can

00:08:39,849 --> 00:08:43,630
buy I've got a django pony which is a

00:08:41,649 --> 00:08:45,070
programming an animal and I've got a

00:08:43,630 --> 00:08:47,020
ruby gem which is programming and

00:08:45,070 --> 00:08:51,600
jewelry and I can you know filter on

00:08:47,020 --> 00:08:55,000
that just just like you'd expect in

00:08:51,600 --> 00:08:56,170
Django that's a little light but

00:08:55,000 --> 00:08:59,200
hopefully everyone can see that well

00:08:56,170 --> 00:09:02,560
enough there's a third party extension

00:08:59,200 --> 00:09:05,770
you can x install so there you're going

00:09:02,560 --> 00:09:09,370
to essentially install two things one is

00:09:05,770 --> 00:09:11,230
the data type itself and another is an

00:09:09,370 --> 00:09:13,779
expression manager so you can query on

00:09:11,230 --> 00:09:15,220
it you don't necessarily need the second

00:09:13,779 --> 00:09:18,310
one if you're not going to query and

00:09:15,220 --> 00:09:20,589
filter but in most cases you're going to

00:09:18,310 --> 00:09:21,700
do that in your application and then

00:09:20,589 --> 00:09:23,680
you're just going to use it down there

00:09:21,700 --> 00:09:25,720
you're going to say a ray field and the

00:09:23,680 --> 00:09:29,110
clear the type of it in this case it's a

00:09:25,720 --> 00:09:30,970
database type of bar char 255 you can do

00:09:29,110 --> 00:09:33,690
integers you can do essentially any type

00:09:30,970 --> 00:09:33,690
you like right in there

00:09:35,020 --> 00:09:39,410
so then I can have an item that I'm

00:09:37,940 --> 00:09:41,420
going to save and I just pass in an

00:09:39,410 --> 00:09:43,880
array of tags pretty straightforward

00:09:41,420 --> 00:09:44,930
like you expect and then when querying

00:09:43,880 --> 00:09:48,200
it I have to do something a little

00:09:44,930 --> 00:09:50,900
special I have to call this passing the

00:09:48,200 --> 00:09:54,020
sequel expression and that little @ sign

00:09:50,900 --> 00:09:55,820
with a greater than sign that's a sequel

00:09:54,020 --> 00:09:58,130
specific syntax so you're just passing

00:09:55,820 --> 00:10:00,260
in sequel syntax they're essentially

00:09:58,130 --> 00:10:02,300
this means that it contains the tag

00:10:00,260 --> 00:10:04,580
programming you could say where it

00:10:02,300 --> 00:10:07,130
contains all of the tags contains any of

00:10:04,580 --> 00:10:08,330
the tags you can get pretty specific

00:10:07,130 --> 00:10:10,040
there and you can just look up the

00:10:08,330 --> 00:10:11,330
post-crescent acts for doing that or you

00:10:10,040 --> 00:10:17,060
can pass in any filtering that you'd

00:10:11,330 --> 00:10:19,700
like they're so extensions extensions i

00:10:17,060 --> 00:10:22,640
mentioned are kind of this weird middle

00:10:19,700 --> 00:10:24,800
ground at least the 17 here extensions

00:10:22,640 --> 00:10:28,640
can ship with core postgres but aren't

00:10:24,800 --> 00:10:29,960
enabled by default so to turn any of

00:10:28,640 --> 00:10:33,530
these on you essentially say create

00:10:29,960 --> 00:10:35,060
extension H store in your database and

00:10:33,530 --> 00:10:36,620
it's available to you there's also

00:10:35,060 --> 00:10:39,560
third-party extensions that you can

00:10:36,620 --> 00:10:40,880
build and compile and install and a lot

00:10:39,560 --> 00:10:45,380
of the foreign data rappers take this

00:10:40,880 --> 00:10:46,700
effect one my favorite one actually my

00:10:45,380 --> 00:10:51,380
favorite data type is actually an

00:10:46,700 --> 00:10:52,970
extension this is an H store how many

00:10:51,380 --> 00:10:58,400
people are here are familiar with and

00:10:52,970 --> 00:10:59,900
have used H store all right so a store

00:10:58,400 --> 00:11:02,390
is a key value store inside your

00:10:59,900 --> 00:11:04,640
database so you can pass any kind of key

00:11:02,390 --> 00:11:07,100
random key value you want in there so it

00:11:04,640 --> 00:11:09,020
really starts to get schema list it's

00:11:07,100 --> 00:11:11,210
not a full document store it's not a

00:11:09,020 --> 00:11:15,170
full base on JSON document inside your

00:11:11,210 --> 00:11:17,330
database but I find most cases no

00:11:15,170 --> 00:11:19,760
sequels a bit of a loaded word it means

00:11:17,330 --> 00:11:20,870
a lot of things to a lot of people but

00:11:19,760 --> 00:11:23,210
the thing that really excites me about

00:11:20,870 --> 00:11:24,710
it is flexibility you can work really

00:11:23,210 --> 00:11:26,390
fast you don't have to fund to find

00:11:24,710 --> 00:11:28,070
columns ahead of time you don't have to

00:11:26,390 --> 00:11:29,589
run migration just start inserting a

00:11:28,070 --> 00:11:31,970
bunch of data and build your application

00:11:29,589 --> 00:11:33,950
so H store lets you do this pretty well

00:11:31,970 --> 00:11:36,770
so inside postgres you would just say

00:11:33,950 --> 00:11:38,060
create extension H store and then you

00:11:36,770 --> 00:11:42,170
would declare the data type down there

00:11:38,060 --> 00:11:45,020
so your data type is H store and then

00:11:42,170 --> 00:11:46,670
when you insert data you use this syntax

00:11:45,020 --> 00:11:47,520
essentially for your key and then your

00:11:46,670 --> 00:11:50,180
value

00:11:47,520 --> 00:11:53,280
one limitation is that it's only strings

00:11:50,180 --> 00:11:55,020
but i found this still pretty good for

00:11:53,280 --> 00:11:57,480
for flexibility i can live with that in

00:11:55,020 --> 00:11:59,100
most cases and you can pass any new

00:11:57,480 --> 00:12:03,030
strings right in there you don't have to

00:11:59,100 --> 00:12:04,560
define them ahead of time and then of

00:12:03,030 --> 00:12:07,110
course that you would expect you can use

00:12:04,560 --> 00:12:09,180
it directly in Django so another custom

00:12:07,110 --> 00:12:15,450
package you're going to install Django h

00:12:09,180 --> 00:12:17,880
door you're going to say my field is

00:12:15,450 --> 00:12:20,970
filled named data is an H store

00:12:17,880 --> 00:12:22,590
dictionary field and you're going to

00:12:20,970 --> 00:12:23,820
create this H store manager so that it

00:12:22,590 --> 00:12:24,780
kind of knows how to work with it inside

00:12:23,820 --> 00:12:29,780
the model it's going to give you a

00:12:24,780 --> 00:12:34,350
little bit of helper functions to it and

00:12:29,780 --> 00:12:37,590
then inserting data I can create a

00:12:34,350 --> 00:12:39,990
django pony so in this case in my

00:12:37,590 --> 00:12:42,390
shopping cart application I've got

00:12:39,990 --> 00:12:43,710
customers that rate products so in this

00:12:42,390 --> 00:12:47,610
case I'm gonna give the Django pony

00:12:43,710 --> 00:12:49,200
rating of 5 and then I'm going to create

00:12:47,610 --> 00:12:50,550
a regular pony and give it a color I'm

00:12:49,200 --> 00:12:53,070
going to give it a paint color and say

00:12:50,550 --> 00:12:56,520
it's a rating of 4 from here I can

00:12:53,070 --> 00:12:59,640
filter on these things so i can say give

00:12:56,520 --> 00:13:02,310
me a pony that contains any color so I

00:12:59,640 --> 00:13:04,640
want all colored ponies or give me all

00:13:02,310 --> 00:13:07,830
ponies that contain a rating equal to 5

00:13:04,640 --> 00:13:10,200
so I'm filtering on nadja on the keys or

00:13:07,830 --> 00:13:11,490
a key is equal to that value so same way

00:13:10,200 --> 00:13:13,770
you would normal sequel when you're

00:13:11,490 --> 00:13:15,060
filtering data you can do this on that

00:13:13,770 --> 00:13:17,850
schema what's data that you didn't have

00:13:15,060 --> 00:13:20,310
to define ahead of time so as I said

00:13:17,850 --> 00:13:22,830
this is easily my my favorite data type

00:13:20,310 --> 00:13:24,690
in Postgres it's a nice newest one we

00:13:22,830 --> 00:13:26,760
actually use it in production at Heroku

00:13:24,690 --> 00:13:27,990
for a lot of systems and it scales quite

00:13:26,760 --> 00:13:29,640
well so you don't have to worry too much

00:13:27,990 --> 00:13:36,270
about that you can definitely push it to

00:13:29,640 --> 00:13:37,620
its limits and take advantage of it but

00:13:36,270 --> 00:13:39,420
there are some limitations it's a key

00:13:37,620 --> 00:13:43,530
value store it's only strings you can't

00:13:39,420 --> 00:13:46,380
miss things in Postgres 92 there's a

00:13:43,530 --> 00:13:49,140
native JSON data type but it has some

00:13:46,380 --> 00:13:50,550
limitations as well so it's not doesn't

00:13:49,140 --> 00:13:52,260
have built-in operator so you can't

00:13:50,550 --> 00:13:54,510
search for specific values in the JSON

00:13:52,260 --> 00:13:56,430
this gets a lot better in Postgres 93

00:13:54,510 --> 00:14:00,690
which should be out just around the

00:13:56,430 --> 00:14:01,360
corner possibly by end of summer but you

00:14:00,690 --> 00:14:04,300
can't actually be

00:14:01,360 --> 00:14:08,350
something with p lv 8 how many people

00:14:04,300 --> 00:14:11,290
here have heard of p lv 80 k a few so p

00:14:08,350 --> 00:14:13,029
lv 8 is a procedural language inside

00:14:11,290 --> 00:14:17,230
postgres it's the full v8 JavaScript

00:14:13,029 --> 00:14:22,079
engine put inside postgres so with JSON

00:14:17,230 --> 00:14:23,920
I can insert JSON into my database and

00:14:22,079 --> 00:14:27,250
essentially that's it it'll validate

00:14:23,920 --> 00:14:31,990
that is valid JSON say this is good it's

00:14:27,250 --> 00:14:33,640
not incorrect with p lv 8 it's the same

00:14:31,990 --> 00:14:36,160
v8 engine that's inside chrome and

00:14:33,640 --> 00:14:38,200
mongodb directly inside postgres so you

00:14:36,160 --> 00:14:41,740
can create indexes on JavaScript

00:14:38,200 --> 00:14:43,450
functions you can create a JavaScript

00:14:41,740 --> 00:14:45,940
function that Alexa cute random

00:14:43,450 --> 00:14:50,800
arbitrary JavaScript as you pass it in I

00:14:45,940 --> 00:14:52,269
wouldn't recommend that but it comes

00:14:50,800 --> 00:14:53,440
with coffeescript as well so I mean it's

00:14:52,269 --> 00:14:55,269
pretty rich so you can do a lot of

00:14:53,440 --> 00:14:56,649
interesting things with it I think a

00:14:55,269 --> 00:14:58,420
really interesting use case right now is

00:14:56,649 --> 00:15:02,589
functional indexes so when you're

00:14:58,420 --> 00:15:04,959
indexing on some JavaScript function and

00:15:02,589 --> 00:15:08,380
of course you can use it with with

00:15:04,959 --> 00:15:11,740
Django you're going to install the JSON

00:15:08,380 --> 00:15:13,709
field type from the tea shop and you're

00:15:11,740 --> 00:15:17,980
just going to reference it in your model

00:15:13,709 --> 00:15:20,529
there are some warnings with this one so

00:15:17,980 --> 00:15:25,089
on github it's labeled Django JSON fills

00:15:20,529 --> 00:15:27,370
on the tea shop it's JSON field there is

00:15:25,089 --> 00:15:30,160
a django json field on a tea shop which

00:15:27,370 --> 00:15:33,910
is the wrong one so that's a bit

00:15:30,160 --> 00:15:37,269
confusing as well it's really it's

00:15:33,910 --> 00:15:39,040
really for postgres 93 and up at one

00:15:37,269 --> 00:15:40,269
point they supported postgres 92 but

00:15:39,040 --> 00:15:42,250
they reverted some of that since you

00:15:40,269 --> 00:15:44,320
couldn't search on data so as soon as

00:15:42,250 --> 00:15:45,220
post crest 93 is out I expect this

00:15:44,320 --> 00:15:51,790
package you'll get a good bit of

00:15:45,220 --> 00:15:54,730
improvement and be much more useful so

00:15:51,790 --> 00:15:56,050
queuing most of the time when you do

00:15:54,730 --> 00:15:58,949
queuing inside your database it looks

00:15:56,050 --> 00:16:03,610
like this if you do celery and kombu

00:15:58,949 --> 00:16:07,120
it's going to die at some point most

00:16:03,610 --> 00:16:09,160
people then go to to reddit or rabbitmq

00:16:07,120 --> 00:16:12,670
or something like that for their their

00:16:09,160 --> 00:16:15,190
queuing which essentially are our pub

00:16:12,670 --> 00:16:17,320
sub but postgres of course

00:16:15,190 --> 00:16:20,410
has this ability as well it's really a

00:16:17,320 --> 00:16:23,050
great q just don't do polling with it so

00:16:20,410 --> 00:16:25,840
postgres has something called listen

00:16:23,050 --> 00:16:27,610
notify listen notify is the same pub

00:16:25,840 --> 00:16:31,780
sell that you would expect it's just

00:16:27,610 --> 00:16:33,490
inside the database so there's a celery

00:16:31,780 --> 00:16:38,520
back-end that takes advantage of this

00:16:33,490 --> 00:16:41,500
called trunk you install trunk and

00:16:38,520 --> 00:16:44,080
basically you you run a sequel script to

00:16:41,500 --> 00:16:45,760
build up some tables for it or

00:16:44,080 --> 00:16:49,300
essentially I believe it's the commands

00:16:45,760 --> 00:16:51,160
that listen and notify and then down

00:16:49,300 --> 00:16:53,530
here you essentially defined your broker

00:16:51,160 --> 00:16:56,320
URL so you're going to say this is the

00:16:53,530 --> 00:16:58,660
the URL to your database there and this

00:16:56,320 --> 00:17:02,380
actually goes a long way in production

00:16:58,660 --> 00:17:04,060
we run the Ruby equivalent of this but

00:17:02,380 --> 00:17:07,270
the Python one would do just fine if

00:17:04,060 --> 00:17:10,689
we're a Python application this can work

00:17:07,270 --> 00:17:12,069
just as well as Redis or rabbitmq in a

00:17:10,689 --> 00:17:13,510
production situation so you don't have

00:17:12,069 --> 00:17:23,400
to spin up one more tool just to run a

00:17:13,510 --> 00:17:26,140
good cue text search so in most cases

00:17:23,400 --> 00:17:28,540
people look at all of these options as

00:17:26,140 --> 00:17:31,810
soon as they need it as soon as you need

00:17:28,540 --> 00:17:33,130
to search on large text documents a lot

00:17:31,810 --> 00:17:35,350
of times it's lately it seems to be

00:17:33,130 --> 00:17:38,200
elasticsearch a solar was popular for a

00:17:35,350 --> 00:17:40,840
little while both are good but as you

00:17:38,200 --> 00:17:43,240
might expect postgres can work great as

00:17:40,840 --> 00:17:46,710
well postgres has built in full-text

00:17:43,240 --> 00:17:49,690
search and it can play well with django

00:17:46,710 --> 00:17:52,120
so in defining it here's how it's going

00:17:49,690 --> 00:17:53,530
to look in the sequel you're still going

00:17:52,120 --> 00:17:55,300
to want to do a few of these things even

00:17:53,530 --> 00:17:56,620
when using with django you're going to

00:17:55,300 --> 00:17:58,300
probably want to create your index

00:17:56,620 --> 00:18:00,370
because Jenga is not automatically going

00:17:58,300 --> 00:18:01,990
to do this for you and you may want to

00:18:00,370 --> 00:18:04,510
create your procedure that's a trigger

00:18:01,990 --> 00:18:06,120
there as well but you're defining a

00:18:04,510 --> 00:18:09,190
separate field type up there at the top

00:18:06,120 --> 00:18:10,480
called TS vector and that's essentially

00:18:09,190 --> 00:18:15,010
going to track certain the things that

00:18:10,480 --> 00:18:18,370
it's going to need search on so inside

00:18:15,010 --> 00:18:20,050
django there's a few i'd say really

00:18:18,370 --> 00:18:21,720
important things here obviously the the

00:18:20,050 --> 00:18:27,460
package you're going to need to install

00:18:21,720 --> 00:18:28,870
its JRM PG full text and you're going to

00:18:27,460 --> 00:18:32,470
define your search

00:18:28,870 --> 00:18:33,910
decks as a filled in your model then

00:18:32,470 --> 00:18:36,130
down here in this search manager you're

00:18:33,910 --> 00:18:37,510
going to give it a lot of data this data

00:18:36,130 --> 00:18:40,420
is going to help us know what's a search

00:18:37,510 --> 00:18:41,740
on what kind of catalogs it's using does

00:18:40,420 --> 00:18:44,559
it auto update or do you update it

00:18:41,740 --> 00:18:48,490
manually basically you're doing a lot of

00:18:44,559 --> 00:18:49,750
setup and configuring right there of

00:18:48,490 --> 00:18:50,680
course this is kind of a one-time thing

00:18:49,750 --> 00:18:52,300
on your model and then in your

00:18:50,680 --> 00:18:55,510
application we're really using it it's

00:18:52,300 --> 00:18:59,440
fairly straightforward in this case you

00:18:55,510 --> 00:19:00,940
can search on where it's an object

00:18:59,440 --> 00:19:04,510
contains something like documentation

00:19:00,940 --> 00:19:06,700
and about or documentation or about so

00:19:04,510 --> 00:19:07,870
either or just like you'd expect and

00:19:06,700 --> 00:19:09,429
this is going to take advantage of the

00:19:07,870 --> 00:19:11,290
the postgres full-text search engine

00:19:09,429 --> 00:19:12,340
underneath the covers just like you'd

00:19:11,290 --> 00:19:19,390
expect so you don't have to think too

00:19:12,340 --> 00:19:22,630
much about it so indexes this isn't

00:19:19,390 --> 00:19:25,840
entirely applied to to the Django ORM

00:19:22,630 --> 00:19:28,030
but I think equally is valuable so in

00:19:25,840 --> 00:19:30,190
post Christ you've got a lot of indexes

00:19:28,030 --> 00:19:34,480
as I mentioned you've got be three gin

00:19:30,190 --> 00:19:38,050
just K&S peaches if you're anything like

00:19:34,480 --> 00:19:41,440
me when I first looked at this it was

00:19:38,050 --> 00:19:44,200
something like this it was quite

00:19:41,440 --> 00:19:46,090
confusing i read on them I didn't quite

00:19:44,200 --> 00:19:49,059
understand I still don't understand what

00:19:46,090 --> 00:19:50,800
SP justice for after having explained by

00:19:49,059 --> 00:19:52,780
post card consultants to me probably 20

00:19:50,800 --> 00:19:54,880
times all i hear is it's good for phone

00:19:52,780 --> 00:19:59,500
numbers so i guess if you're indexing

00:19:54,880 --> 00:20:01,600
phone numbers use it if you know in a

00:19:59,500 --> 00:20:03,040
very clear concise way what it's good

00:20:01,600 --> 00:20:06,970
for please come talk to me because I'd

00:20:03,040 --> 00:20:09,250
love to hear but there's a few really

00:20:06,970 --> 00:20:14,920
basic rules of thumbs it's not too hard

00:20:09,250 --> 00:20:16,390
to figure out and in most cases you want

00:20:14,920 --> 00:20:18,550
a b-tree you don't have to think about

00:20:16,390 --> 00:20:22,230
it btree is the default one when you say

00:20:18,550 --> 00:20:25,000
create index it's going to use a b-tree

00:20:22,230 --> 00:20:26,830
95 99 percent of the time this is what

00:20:25,000 --> 00:20:28,300
you want and as I said you probably want

00:20:26,830 --> 00:20:32,710
to do create index concurrently there

00:20:28,300 --> 00:20:36,790
and in all cases gin index a generalized

00:20:32,710 --> 00:20:38,800
inverted index so this isn't a perfect

00:20:36,790 --> 00:20:41,170
rule but i would say i'm ninety percent

00:20:38,800 --> 00:20:42,190
confident in this case you want to use

00:20:41,170 --> 00:20:44,409
it with an array

00:20:42,190 --> 00:20:48,340
eh store anytime you've got multiple

00:20:44,409 --> 00:20:53,169
values of data and one column that's

00:20:48,340 --> 00:20:56,950
kind of the default just the ruffle of

00:20:53,169 --> 00:20:59,500
thumb is full text search shapes and

00:20:56,950 --> 00:21:01,929
then a more narrow case of shapes

00:20:59,500 --> 00:21:05,529
espacio is so if you're doing anything

00:21:01,929 --> 00:21:08,350
with do django just as the one you want

00:21:05,529 --> 00:21:10,960
and again sometimes just well form gin

00:21:08,350 --> 00:21:16,809
and vice versa but these are pretty much

00:21:10,960 --> 00:21:19,690
the rough role of thumbs here geospatial

00:21:16,809 --> 00:21:22,809
stuff if you're doing anything with it

00:21:19,690 --> 00:21:25,720
just use to yo tengo it deserves its own

00:21:22,809 --> 00:21:29,320
kind of half hour slot there's actually

00:21:25,720 --> 00:21:30,759
a really good slide by Julia Hiken on it

00:21:29,320 --> 00:21:33,850
so you can check out her slides and I

00:21:30,759 --> 00:21:40,600
believe that the top the videos up on

00:21:33,850 --> 00:21:42,549
the pike on us videos as well so one

00:21:40,600 --> 00:21:44,700
thing that I find not nearly enough

00:21:42,549 --> 00:21:46,870
applications have is a read-only mode

00:21:44,700 --> 00:21:48,490
who here has the ability to flip your

00:21:46,870 --> 00:21:55,360
site into a completely read-only mode

00:21:48,490 --> 00:21:58,929
not write data to okay wow that's a

00:21:55,360 --> 00:22:00,220
that's surprising um so lanyard had a

00:21:58,929 --> 00:22:03,549
really good blog post about this they

00:22:00,220 --> 00:22:06,909
migrated completely from MySQL to

00:22:03,549 --> 00:22:09,940
postgres with no downtime for users now

00:22:06,909 --> 00:22:12,639
users couldn't say they're intending an

00:22:09,940 --> 00:22:13,870
event for about an hour or two hours but

00:22:12,639 --> 00:22:17,139
it wasn't the site was offline it was

00:22:13,870 --> 00:22:19,870
just in read-only mode this is something

00:22:17,139 --> 00:22:21,759
that every website should really have it

00:22:19,870 --> 00:22:23,470
means you can do things like migrations

00:22:21,759 --> 00:22:24,700
on your database by just saying here

00:22:23,470 --> 00:22:26,620
this is read only day that we're not

00:22:24,700 --> 00:22:27,519
writing new data and pointed at it well

00:22:26,620 --> 00:22:31,629
you do whatever you want under the

00:22:27,519 --> 00:22:33,100
covers this is great not only for you

00:22:31,629 --> 00:22:35,559
know if you have database migrations or

00:22:33,100 --> 00:22:37,059
issues but also security issues if you

00:22:35,559 --> 00:22:39,519
have a security thing and you want to be

00:22:37,059 --> 00:22:45,370
able to flip it in Rio Muni mode this is

00:22:39,519 --> 00:22:50,429
pretty important so this is a middleware

00:22:45,370 --> 00:22:52,059
i actually created called Jango DB tools

00:22:50,429 --> 00:22:55,389
essentially what you're going to do

00:22:52,059 --> 00:22:57,849
right here is install it

00:22:55,389 --> 00:23:00,940
put in the middle where and then say

00:22:57,849 --> 00:23:03,009
read-only mode equals true a better way

00:23:00,940 --> 00:23:04,479
to do this is actually read from an

00:23:03,009 --> 00:23:06,039
environment variable so you don't have

00:23:04,479 --> 00:23:08,769
to deploy new code you can just flip a

00:23:06,039 --> 00:23:10,959
bit if you're running on Heroku you just

00:23:08,769 --> 00:23:12,639
change a config bar if you're running

00:23:10,959 --> 00:23:14,579
with separate puppet ideally you can

00:23:12,639 --> 00:23:17,289
push the same environment variable out

00:23:14,579 --> 00:23:18,969
and really this is a great way so you

00:23:17,289 --> 00:23:20,139
can know how to deploy new code just

00:23:18,969 --> 00:23:22,239
change the environment change what's

00:23:20,139 --> 00:23:24,909
happening and then undo it when you're

00:23:22,239 --> 00:23:26,440
done and what this is going to do is you

00:23:24,909 --> 00:23:28,709
know prevent people from posting data to

00:23:26,440 --> 00:23:32,019
your site current people from logging in

00:23:28,709 --> 00:23:33,940
and actually I'd welcome any pull

00:23:32,019 --> 00:23:35,979
requests to I think a goal for this is

00:23:33,940 --> 00:23:37,899
to have a floating banner saying hey

00:23:35,979 --> 00:23:39,249
you're in read-only mode as well so

00:23:37,899 --> 00:23:40,809
right now it's not a perfect experience

00:23:39,249 --> 00:23:45,579
but it definitely accomplishes that same

00:23:40,809 --> 00:23:47,289
goal all right so one more thing and

00:23:45,579 --> 00:23:51,039
this will be the last time I'll pull you

00:23:47,289 --> 00:23:53,619
guys how many people here Ron connection

00:23:51,039 --> 00:23:57,339
pooling for your database like PG

00:23:53,619 --> 00:24:02,169
bouncer or PG pool okay so for every one

00:23:57,339 --> 00:24:03,459
that doesn't your jingle requests very

00:24:02,169 --> 00:24:07,179
possibly you're looking something like

00:24:03,459 --> 00:24:08,950
this so this is a pretty average

00:24:07,179 --> 00:24:12,489
application on Heroku out of the box

00:24:08,950 --> 00:24:14,049
stock Django and if you see right there

00:24:12,489 --> 00:24:15,609
there's connection time and the

00:24:14,049 --> 00:24:18,309
connection time is about 60 milliseconds

00:24:15,609 --> 00:24:21,700
and the rest of the request is maybe 15

00:24:18,309 --> 00:24:23,559
to 20 milliseconds it's very very common

00:24:21,700 --> 00:24:25,959
that or Django by default gets a

00:24:23,559 --> 00:24:27,759
connection every single request does

00:24:25,959 --> 00:24:30,940
some things and then releases that this

00:24:27,759 --> 00:24:34,059
is really really bad um you're spending

00:24:30,940 --> 00:24:36,369
a lot of time doing nothing PG bouncer

00:24:34,059 --> 00:24:37,809
is one option for this PG pool if you

00:24:36,369 --> 00:24:39,909
don't want to run those I would actually

00:24:37,809 --> 00:24:42,909
say there's some perfectly good options

00:24:39,909 --> 00:24:45,309
built into Django this is the path that

00:24:42,909 --> 00:24:48,149
both most other frameworks take it's

00:24:45,309 --> 00:24:53,200
just a application side connection polar

00:24:48,149 --> 00:24:56,049
so Django postgres pool JRM exe pool and

00:24:53,200 --> 00:24:58,329
django d be pool I'd mostly recommend

00:24:56,049 --> 00:25:03,009
this one just because I know the most

00:24:58,329 --> 00:25:05,889
about it because we wrote it essentially

00:25:03,009 --> 00:25:08,909
you install it you say here's my engine

00:25:05,889 --> 00:25:10,440
and you would do the same for self

00:25:08,909 --> 00:25:12,179
then you can configure how many

00:25:10,440 --> 00:25:14,009
connections you want in the pool do you

00:25:12,179 --> 00:25:15,539
want 10 or 20 or something like that and

00:25:14,009 --> 00:25:16,590
that's just going to keep it pool of

00:25:15,539 --> 00:25:17,759
connection so you don't have to go out

00:25:16,590 --> 00:25:20,669
and get a new connection every single

00:25:17,759 --> 00:25:22,979
time you're going to see much better

00:25:20,669 --> 00:25:24,919
performance here it's just a good

00:25:22,979 --> 00:25:26,999
practice most of the frameworks to it

00:25:24,919 --> 00:25:31,259
fortunately this gets a lot better in

00:25:26,999 --> 00:25:33,720
Django 16 so in 16 they have persistent

00:25:31,259 --> 00:25:34,979
connections so it's not a full pool but

00:25:33,720 --> 00:25:37,019
it doesn't have to get a new one every

00:25:34,979 --> 00:25:38,639
single time so it's definitely an

00:25:37,019 --> 00:25:41,220
improvement and then you have the

00:25:38,639 --> 00:25:46,470
ability to turn it on turn it off as

00:25:41,220 --> 00:25:51,509
well just like you expect in Django so

00:25:46,470 --> 00:25:52,739
coming back full circle postgres is a

00:25:51,509 --> 00:25:56,099
really great database with a lot of

00:25:52,739 --> 00:25:58,499
features my biggest kind of qualms with

00:25:56,099 --> 00:25:59,639
the Jenga community and the guys and I

00:25:58,499 --> 00:26:02,970
know and well and talk to them and

00:25:59,639 --> 00:26:06,090
complain regularly that treating all

00:26:02,970 --> 00:26:07,590
database is the same you're a good bit

00:26:06,090 --> 00:26:09,269
limited I think they're definitely

00:26:07,590 --> 00:26:11,940
thinking about this going forward with a

00:26:09,269 --> 00:26:13,499
lot of the database api's and how do

00:26:11,940 --> 00:26:14,940
they make it more pluggable so you could

00:26:13,499 --> 00:26:16,859
have a back-end that takes more

00:26:14,940 --> 00:26:19,349
advantage but we're still probably a

00:26:16,859 --> 00:26:21,499
ways off from that so to kind of wrap it

00:26:19,349 --> 00:26:25,109
up postgres it's a really great database

00:26:21,499 --> 00:26:26,460
the Django ORM it's not so bad it lets

00:26:25,109 --> 00:26:27,509
you kind of do some of these things you

00:26:26,460 --> 00:26:31,619
just have to do a little bit of extra

00:26:27,509 --> 00:26:34,739
work so thanks and then a special thanks

00:26:31,619 --> 00:26:37,710
to Andre who actually a lot of these

00:26:34,739 --> 00:26:40,409
packages or his not all but a lot of

00:26:37,710 --> 00:26:41,489
them are so the the array the a short

00:26:40,409 --> 00:26:43,799
packages that allow you to take

00:26:41,489 --> 00:26:46,739
advantage of that a big things for him

00:26:43,799 --> 00:26:48,830
for for creating and contributing thank

00:26:46,739 --> 00:26:48,830
you

00:26:53,910 --> 00:27:03,100
thank you very much hi thank you for the

00:26:59,110 --> 00:27:05,410
good talk I am always amazed when I see

00:27:03,100 --> 00:27:08,950
how many things we miss her from

00:27:05,410 --> 00:27:13,299
phosphorus being hidden behind the your

00:27:08,950 --> 00:27:15,580
eye on but and and I'm I'm not really

00:27:13,299 --> 00:27:19,480
afraid about getting locked in because I

00:27:15,580 --> 00:27:23,320
can see myself going anywhere else but

00:27:19,480 --> 00:27:26,320
how do you rent us I mean most of times

00:27:23,320 --> 00:27:28,390
I'm running tests on psycho lights so

00:27:26,320 --> 00:27:30,850
because it's my SS son many tests on

00:27:28,390 --> 00:27:32,230
postgres I think a really good practice

00:27:30,850 --> 00:27:34,179
is running the exact same thing in

00:27:32,230 --> 00:27:36,940
development and production if you're

00:27:34,179 --> 00:27:39,850
familiar with the twelve factor app if

00:27:36,940 --> 00:27:42,240
not check it out 12 factor net it's a

00:27:39,850 --> 00:27:46,419
lot of good best practices for

00:27:42,240 --> 00:27:48,880
developing service-based good scalable

00:27:46,419 --> 00:27:50,470
web applications and a really key one is

00:27:48,880 --> 00:27:55,540
that you have parity between development

00:27:50,470 --> 00:27:57,390
and production so if you're on Debbie

00:27:55,540 --> 00:28:00,790
and it's pretty easy to install postgres

00:27:57,390 --> 00:28:02,890
if you're on redhat it's pretty easy to

00:28:00,790 --> 00:28:05,710
install even if you're on a Mac check

00:28:02,890 --> 00:28:07,270
out postgres setup you can run postgres

00:28:05,710 --> 00:28:09,669
in memory mode which definitely cuts

00:28:07,270 --> 00:28:10,900
down on some of the time of startup and

00:28:09,669 --> 00:28:14,770
there's things you can do so it's not

00:28:10,900 --> 00:28:16,090
slow sequel light by running it locally

00:28:14,770 --> 00:28:17,200
and then running post-crescent

00:28:16,090 --> 00:28:19,299
production you're definitely going to

00:28:17,200 --> 00:28:21,220
introduce bugs at some point along the

00:28:19,299 --> 00:28:24,490
time sequel light a good example here is

00:28:21,220 --> 00:28:27,160
like if you say you have a bar chart of

00:28:24,490 --> 00:28:30,010
50 characters it'll let you just insert

00:28:27,160 --> 00:28:31,210
70 and it won't care as soon as the

00:28:30,010 --> 00:28:32,530
thing we didn't try to do this in

00:28:31,210 --> 00:28:36,309
production you could have a lot of

00:28:32,530 --> 00:28:39,510
interesting issues so I would definitely

00:28:36,309 --> 00:28:44,980
try to get to using both in both places

00:28:39,510 --> 00:28:49,270
yep great talk thanks a source thinking

00:28:44,980 --> 00:28:52,179
about listen and notify for a message

00:28:49,270 --> 00:28:54,520
queue because currently we use read this

00:28:52,179 --> 00:28:57,490
and then we have the problem that we

00:28:54,520 --> 00:29:00,280
want to send the ID of a newly created

00:28:57,490 --> 00:29:03,250
object and do some post processing on

00:29:00,280 --> 00:29:05,320
that one so we fire off the task to read

00:29:03,250 --> 00:29:09,480
this before the transaction actually

00:29:05,320 --> 00:29:13,750
commits and then then the task is faster

00:29:09,480 --> 00:29:16,690
right so it fires before the commit so

00:29:13,750 --> 00:29:20,200
the task can cannot find the newly

00:29:16,690 --> 00:29:23,860
created object if in certain cases I

00:29:20,200 --> 00:29:25,929
would so I was thinking about are these

00:29:23,860 --> 00:29:27,429
notifications are they included in the

00:29:25,929 --> 00:29:31,500
transactions because then that would

00:29:27,429 --> 00:29:34,480
solve the problem it wouldn't be

00:29:31,500 --> 00:29:35,710
guaranteed I believe but you could it

00:29:34,480 --> 00:29:38,320
depends on the back end I'd have to

00:29:35,710 --> 00:29:39,519
double check I think you could

00:29:38,320 --> 00:29:42,580
definitely make it play a little nicer

00:29:39,519 --> 00:29:44,169
to together using it as your cue you

00:29:42,580 --> 00:29:46,360
know it's separate so they'll listen

00:29:44,169 --> 00:29:49,509
notify is your cue just like it would be

00:29:46,360 --> 00:29:50,980
in Redis so if you had something like a

00:29:49,509 --> 00:29:52,929
lock on the table it may still have to

00:29:50,980 --> 00:29:54,580
wait for that for the object to be

00:29:52,929 --> 00:29:56,169
created so I wouldn't say it's a

00:29:54,580 --> 00:29:58,450
guarantee but it may give you a little

00:29:56,169 --> 00:30:00,610
bit of flexibility since your data is

00:29:58,450 --> 00:30:01,960
all there together that you have a

00:30:00,610 --> 00:30:04,179
little bit of safeguards but I wouldn't

00:30:01,960 --> 00:30:09,129
think it'd be a perfect magic bullet for

00:30:04,179 --> 00:30:11,049
solving a problem thank you for your

00:30:09,129 --> 00:30:13,690
great talk I've got a little mystery

00:30:11,049 --> 00:30:20,009
question why did you use a dream index

00:30:13,690 --> 00:30:20,009
in your teeth Wake Tech sampler um I

00:30:20,789 --> 00:30:26,200
don't have a good reason oh I I think it

00:30:24,460 --> 00:30:27,370
was probably just a old code sample I

00:30:26,200 --> 00:30:30,970
pulled from so there may have been a

00:30:27,370 --> 00:30:33,789
case it was a gin index sometimes genin

00:30:30,970 --> 00:30:38,559
just can be swapped interchangeably just

00:30:33,789 --> 00:30:40,870
oftentimes have Oh little less

00:30:38,559 --> 00:30:45,009
performance but smaller disk space and

00:30:40,870 --> 00:30:47,169
Jen have better performance but much

00:30:45,009 --> 00:30:49,629
bigger disk space to me usually disqus

00:30:47,169 --> 00:30:51,700
cheap but that's also not 100-percent

00:30:49,629 --> 00:30:53,769
the case it really varies on the data

00:30:51,700 --> 00:30:55,809
and what you're doing with it so if you

00:30:53,769 --> 00:30:59,230
really get in deep with those experiment

00:30:55,809 --> 00:31:03,190
with the two and Christoph Pettis has a

00:30:59,230 --> 00:31:06,309
good post on performance differences

00:31:03,190 --> 00:31:08,110
between Jen Jess and actually MongoDB as

00:31:06,309 --> 00:31:09,190
well I'm comparing all those so if you

00:31:08,110 --> 00:31:13,929
want you should be able to find that and

00:31:09,190 --> 00:31:17,379
begin pretty easily hi Craig a very good

00:31:13,929 --> 00:31:18,360
talk thank you about about promoting

00:31:17,379 --> 00:31:22,230
postgis these

00:31:18,360 --> 00:31:24,660
way and I wanted to add one thing about

00:31:22,230 --> 00:31:27,600
testing with postgres because you can

00:31:24,660 --> 00:31:31,770
actually use also PG tap if you want to

00:31:27,600 --> 00:31:34,080
do tests inside pause grace okay but

00:31:31,770 --> 00:31:36,360
that's that's not from a django point of

00:31:34,080 --> 00:31:38,610
view but more more from a pause guys

00:31:36,360 --> 00:31:42,090
point of view hi I was wondering and

00:31:38,610 --> 00:31:48,150
this is my question if you used if you

00:31:42,090 --> 00:31:51,990
ever used or try pgq for queuing Oh in a

00:31:48,150 --> 00:31:54,600
previous life yes but it's been a long

00:31:51,990 --> 00:31:56,340
long time so I find you know most

00:31:54,600 --> 00:31:59,460
application developers can be a little

00:31:56,340 --> 00:32:03,870
wary of it most Python developers is

00:31:59,460 --> 00:32:05,790
anyone here not use celery ok a few but

00:32:03,870 --> 00:32:07,830
I think celery is commonly the de facto

00:32:05,790 --> 00:32:09,030
or there's a few others that just allow

00:32:07,830 --> 00:32:12,480
you to control it a little better within

00:32:09,030 --> 00:32:14,010
your application but pgq if you're doing

00:32:12,480 --> 00:32:16,560
something really rigorous and hardcore

00:32:14,010 --> 00:32:18,270
is a really good option for queuing also

00:32:16,560 --> 00:32:22,020
because I think it could solve the issue

00:32:18,270 --> 00:32:26,100
of transsexuality requirements that was

00:32:22,020 --> 00:32:27,870
I think raised before uh yeah in that

00:32:26,100 --> 00:32:32,250
case actually pgq might be a good option

00:32:27,870 --> 00:32:33,690
to investigate yeah I'd have to think

00:32:32,250 --> 00:32:35,420
through it a little more and hear more

00:32:33,690 --> 00:32:40,980
on the detail but I think it could work

00:32:35,420 --> 00:32:43,350
ok thank you yeah I think maybe I'm

00:32:40,980 --> 00:32:47,690
wrong by the years ago postgis has a

00:32:43,350 --> 00:32:53,750
limitation for doing full text search in

00:32:47,690 --> 00:32:53,750
fields that I've not plain ASCII I

00:32:54,710 --> 00:33:01,050
believe it if it was a limitation years

00:32:58,170 --> 00:33:08,460
ago I think it's long been removed ok

00:33:01,050 --> 00:33:14,040
yeah great talk because you mentioned

00:33:08,460 --> 00:33:16,170
scaling and like sorry my my question is

00:33:14,040 --> 00:33:18,690
how do you handle like fault tolerance

00:33:16,170 --> 00:33:21,630
and like massively scaling and

00:33:18,690 --> 00:33:23,970
replication and things like that kind of

00:33:21,630 --> 00:33:27,990
like best practices and from your

00:33:23,970 --> 00:33:30,210
experience what seems to work sure oh

00:33:27,990 --> 00:33:31,110
that's the kind of all full a whole

00:33:30,210 --> 00:33:33,270
other can of worms

00:33:31,110 --> 00:33:36,330
so I can talk a little bit specifically

00:33:33,270 --> 00:33:37,740
what we do at Heroku so I mean we

00:33:36,330 --> 00:33:39,960
started talking really really big data

00:33:37,740 --> 00:33:41,420
sets you're looking at sharding the

00:33:39,960 --> 00:33:43,559
jingle routers are pretty good for that

00:33:41,420 --> 00:33:48,480
you can char it in a variety of ways

00:33:43,559 --> 00:33:51,690
there and it can work well at the

00:33:48,480 --> 00:33:54,120
database level postgres has streaming

00:33:51,690 --> 00:33:58,230
replication there's a variety of options

00:33:54,120 --> 00:34:03,630
there so there's a blue card oh there's

00:33:58,230 --> 00:34:06,900
a long dist there's actually a tool that

00:34:03,630 --> 00:34:09,270
we created call wally which ships the

00:34:06,900 --> 00:34:11,429
right ahead logs essentially what you're

00:34:09,270 --> 00:34:15,320
looking at is a combination of base

00:34:11,429 --> 00:34:27,929
backups and wall shipping commonly I

00:34:15,320 --> 00:34:29,760
believe Lucario maybe multimaster so

00:34:27,929 --> 00:34:32,669
multi master is making some progress I

00:34:29,760 --> 00:34:35,850
believe it's already nine that one and

00:34:32,669 --> 00:34:38,700
it will be there's actually a open

00:34:35,850 --> 00:34:41,369
source version written by a second

00:34:38,700 --> 00:34:43,230
quadrant which everyone can can download

00:34:41,369 --> 00:34:45,889
it's called bdr be directional

00:34:43,230 --> 00:34:48,570
replication and need some production on

00:34:45,889 --> 00:34:53,399
one of our customers and we hope it will

00:34:48,570 --> 00:34:56,159
be in the core of postgres in 94 we can

00:34:53,399 --> 00:34:57,920
is next year somewhat in secretary it's

00:34:56,159 --> 00:35:00,950
a mixed of physical and logical

00:34:57,920 --> 00:35:04,380
replication so through you can actually

00:35:00,950 --> 00:35:06,450
inspect world fires and decide which

00:35:04,380 --> 00:35:08,670
parts of the wall you can actually

00:35:06,450 --> 00:35:11,850
replicate you could also use that to

00:35:08,670 --> 00:35:15,780
replicate to our Oracle for example yeah

00:35:11,850 --> 00:35:18,859
so it's it's it's it's open source so if

00:35:15,780 --> 00:35:21,869
you if you actually look for bdr bdr

00:35:18,859 --> 00:35:25,650
postgresql you come up with with a patch

00:35:21,869 --> 00:35:27,660
and with a big you use arugula it's over

00:35:25,650 --> 00:35:29,580
for most of those I wouldn't recommend

00:35:27,660 --> 00:35:31,440
for the faint of heart most of the

00:35:29,580 --> 00:35:34,410
replication options in Postgres are a

00:35:31,440 --> 00:35:37,520
good bit of setup we created Wally to be

00:35:34,410 --> 00:35:39,960
really really lightweight in Postgres 93

00:35:37,520 --> 00:35:43,470
there's I think human readable right

00:35:39,960 --> 00:35:44,380
ahead logs and 94 the hope is multi

00:35:43,470 --> 00:35:45,850
master

00:35:44,380 --> 00:35:48,400
it's never guaranteed until nine floors

00:35:45,850 --> 00:35:50,320
released and there's also hope of

00:35:48,400 --> 00:35:52,420
logical replication which makes

00:35:50,320 --> 00:35:53,770
upgrading from one post press version to

00:35:52,420 --> 00:35:57,400
the other with no downtime or little

00:35:53,770 --> 00:36:00,550
downtime much much better today I'd look

00:35:57,400 --> 00:36:01,840
at if you kind of talked to the bus

00:36:00,550 --> 00:36:05,440
chris communty there's four or five

00:36:01,840 --> 00:36:08,470
really options for for sending up read

00:36:05,440 --> 00:36:09,730
replicas and higher availability and

00:36:08,470 --> 00:36:12,010
then up to its up to you on the

00:36:09,730 --> 00:36:13,450
application side really for shorting but

00:36:12,010 --> 00:36:18,670
the Django routers to make that really

00:36:13,450 --> 00:36:21,580
easy for you you mentioned the array

00:36:18,670 --> 00:36:23,530
type type 4 categories can you join the

00:36:21,580 --> 00:36:25,210
other way around so you have category

00:36:23,530 --> 00:36:27,880
and you want the post so can you join

00:36:25,210 --> 00:36:29,770
from that kind of type I mean yeah you

00:36:27,880 --> 00:36:31,870
can select like the distinct categories

00:36:29,770 --> 00:36:33,700
in joint out everyone that has that so I

00:36:31,870 --> 00:36:35,290
mean it's just looking to join the other

00:36:33,700 --> 00:36:37,660
way around so if you wanted to say i

00:36:35,290 --> 00:36:39,490
want all posts that have the Django

00:36:37,660 --> 00:36:46,830
category you could really easily filter

00:36:39,490 --> 00:36:46,830
on that easily okay yep anyone else

00:36:47,280 --> 00:36:51,360
alright thank you very much

00:36:58,120 --> 00:37:01,120

YouTube URL: https://www.youtube.com/watch?v=S-kbfpRpVsY


