Title: D.  Jemerov- Why Python Sucks
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	D.  Jemerov- Why Python Sucks 
[Europython 2013]
5 July 2013
Track Pizza Margherita
Captions: 
	00:00:04,790 --> 00:00:09,750
hello everyone we are really with our

00:00:07,799 --> 00:00:10,380
guests for the first part of is open

00:00:09,750 --> 00:00:13,259
space

00:00:10,380 --> 00:00:14,639
he's a dmitriy Jeremiah Benny you

00:00:13,259 --> 00:00:17,369
introduce yourself

00:00:14,639 --> 00:00:21,470
but Monsieur complimentary yoke the most

00:00:17,369 --> 00:00:23,820
brave maybe title of a discussion so far

00:00:21,470 --> 00:00:27,630
but that'll be a discussion a whiteout

00:00:23,820 --> 00:00:30,090
why python sucks we want to skin you

00:00:27,630 --> 00:00:34,469
alive until you are finished so you have

00:00:30,090 --> 00:00:37,140
some time to give some reason for your

00:00:34,469 --> 00:00:43,530
daring assertion okay okay

00:00:37,140 --> 00:00:46,829
yes first of all like like first of all

00:00:43,530 --> 00:00:48,270
yeah why do I think I'm it's worse for

00:00:46,829 --> 00:00:50,100
me to stand here and talk about this

00:00:48,270 --> 00:00:52,530
topic so I've actually work I've been

00:00:50,100 --> 00:00:54,059
working for JetBrains for the last ten

00:00:52,530 --> 00:00:57,270
years and JetBrains as a company has

00:00:54,059 --> 00:00:59,609
been building tools for like a lot of

00:00:57,270 --> 00:01:03,120
different languages that means Java C

00:00:59,609 --> 00:01:06,180
sharp Ruby pitch your Ruby Python big

00:01:03,120 --> 00:01:08,400
yes PHP and so on and I've been involved

00:01:06,180 --> 00:01:11,610
in development of a few of those and so

00:01:08,400 --> 00:01:13,409
I I and I've also been involved in

00:01:11,610 --> 00:01:15,090
developing kosslyn which is our

00:01:13,409 --> 00:01:15,630
programming language that we had built a

00:01:15,090 --> 00:01:17,610
jetbrains

00:01:15,630 --> 00:01:21,930
and so I have like a bit of exposure to

00:01:17,610 --> 00:01:23,280
different technologists and I think I

00:01:21,930 --> 00:01:25,110
can see like the upsides and downsides

00:01:23,280 --> 00:01:28,430
of different technologists like it may

00:01:25,110 --> 00:01:30,930
be a bit more than some other people and

00:01:28,430 --> 00:01:33,960
of course I don't have any hidden agenda

00:01:30,930 --> 00:01:36,320
I actually I really like Python I use it

00:01:33,960 --> 00:01:38,759
for a lot of my personal projects and

00:01:36,320 --> 00:01:40,829
but still there is there is stuff that I

00:01:38,759 --> 00:01:43,110
consider to be missing in in person

00:01:40,829 --> 00:01:44,250
compared to some other technologies so

00:01:43,110 --> 00:01:46,799
first of all let's start with the

00:01:44,250 --> 00:01:48,240
language so with the language we have

00:01:46,799 --> 00:01:50,310
this weird situation where essentially

00:01:48,240 --> 00:01:53,340
because of the pattern too and Python 3

00:01:50,310 --> 00:01:55,020
split the community the language

00:01:53,340 --> 00:01:57,630
evolution has essentially been frozen at

00:01:55,020 --> 00:02:00,450
Python 2.7 level so even though there

00:01:57,630 --> 00:02:02,490
are new features in Python 3 for example

00:02:00,450 --> 00:02:04,380
the talk that was the conference about

00:02:02,490 --> 00:02:06,299
annotations has shown that many people

00:02:04,380 --> 00:02:07,500
are simply not aware that buttons we

00:02:06,299 --> 00:02:11,280
have some new language features other

00:02:07,500 --> 00:02:12,599
than the Unicode support and that's one

00:02:11,280 --> 00:02:13,740
thing and another thing is that at this

00:02:12,599 --> 00:02:15,630
point it's simply not really

00:02:13,740 --> 00:02:18,000
feasible for people to develop Python 3

00:02:15,630 --> 00:02:19,980
only projects and for example there's

00:02:18,000 --> 00:02:22,260
bypassing project and by parsing version

00:02:19,980 --> 00:02:24,210
2 is only compatible with Python 3 and

00:02:22,260 --> 00:02:25,620
if you runs if you simply have your have

00:02:24,210 --> 00:02:27,270
your default path and set to Python 2

00:02:25,620 --> 00:02:29,100
and you run people install PI parsing

00:02:27,270 --> 00:02:30,510
you'll give you a syntax error and it

00:02:29,100 --> 00:02:32,790
will actually catch this version of Pi

00:02:30,510 --> 00:02:34,170
parsing it's somewhere in its internals

00:02:32,790 --> 00:02:35,610
so that if you want to install by

00:02:34,170 --> 00:02:37,380
parsing that works with your Python you

00:02:35,610 --> 00:02:39,630
have to do some extra work clearing the

00:02:37,380 --> 00:02:41,850
cache so what I'm saying that by

00:02:39,630 --> 00:02:42,990
building a Python 3 only project at this

00:02:41,850 --> 00:02:44,490
point you are essentially

00:02:42,990 --> 00:02:48,180
inconveniencing a whole lot of people

00:02:44,490 --> 00:02:51,470
and making it difficult making life

00:02:48,180 --> 00:02:53,580
difficult for everyone essentially and

00:02:51,470 --> 00:02:56,760
Guido has actually brought up this topic

00:02:53,580 --> 00:02:58,650
during the keynote at PyCon last year

00:02:56,760 --> 00:03:01,620
and his answer to the language evolution

00:02:58,650 --> 00:03:05,040
is that first of all yeah there is like

00:03:01,620 --> 00:03:08,490
too many like it's bad to do too many

00:03:05,040 --> 00:03:10,560
changes to the language so we were being

00:03:08,490 --> 00:03:12,060
conservative and you if you really miss

00:03:10,560 --> 00:03:13,800
some specific feature then please use a

00:03:12,060 --> 00:03:15,210
preprocessor like write your own

00:03:13,800 --> 00:03:16,830
preprocessor that will convert your

00:03:15,210 --> 00:03:19,290
dialect of Python into like these

00:03:16,830 --> 00:03:21,510
standard Python and then use that writer

00:03:19,290 --> 00:03:24,110
code which is a bad idea for like a

00:03:21,510 --> 00:03:26,670
large number of obvious reasons and

00:03:24,110 --> 00:03:29,520
actually my golden standard for language

00:03:26,670 --> 00:03:31,680
evolution is actually a c-sharp so we

00:03:29,520 --> 00:03:33,960
see shop had c-sharp obviously has also

00:03:31,680 --> 00:03:38,670
very large user base like larger than

00:03:33,960 --> 00:03:40,050
vitalizing and like every like every two

00:03:38,670 --> 00:03:42,270
years every 3 years something like that

00:03:40,050 --> 00:03:44,880
they are coming with major new version

00:03:42,270 --> 00:03:46,350
of the language that adds that makes

00:03:44,880 --> 00:03:47,970
essentially AB so every version of

00:03:46,350 --> 00:03:50,190
c-sharp essentially adds one change it

00:03:47,970 --> 00:03:52,290
elects or roughly speaking it so she

00:03:50,190 --> 00:03:54,420
shop to add the generics which are three

00:03:52,290 --> 00:03:55,110
added link to shop for added dynamic

00:03:54,420 --> 00:03:57,720
types

00:03:55,110 --> 00:03:59,490
c-sharp fire and maybe something else I

00:03:57,720 --> 00:04:02,190
don't remember and c-sharp v added a

00:03:59,490 --> 00:04:03,720
sink await and at this place so they are

00:04:02,190 --> 00:04:05,220
introducing features that matter that

00:04:03,720 --> 00:04:08,040
matter to a very large number of users

00:04:05,220 --> 00:04:10,410
and they are doing at a reasonable pace

00:04:08,040 --> 00:04:11,970
and they're like really tangibly making

00:04:10,410 --> 00:04:13,740
life better for users of the language

00:04:11,970 --> 00:04:15,150
and that's actually the kind of

00:04:13,740 --> 00:04:17,780
evolution that I would very much like to

00:04:15,150 --> 00:04:19,620
see in the Python community

00:04:17,780 --> 00:04:20,100
unfortunately it doesn't seem to be

00:04:19,620 --> 00:04:21,810
happening

00:04:20,100 --> 00:04:24,270
and by the way I think wait and see shop

00:04:21,810 --> 00:04:26,160
is a solution to the same problem that

00:04:24,270 --> 00:04:26,820
yield from is trying to solve in Python

00:04:26,160 --> 00:04:28,920
only that

00:04:26,820 --> 00:04:31,880
it's much nicer and much tighter and

00:04:28,920 --> 00:04:31,880
essentially works today

00:04:32,510 --> 00:04:37,140
then there are interpreters obviously is

00:04:35,280 --> 00:04:38,670
as soon as some as soon as someone

00:04:37,140 --> 00:04:41,100
raises the topic of interpreters

00:04:38,670 --> 00:04:43,110
yeah like the answer is pipe I like the

00:04:41,100 --> 00:04:47,150
respite by pipe is great pipe is going

00:04:43,110 --> 00:04:47,150
to make everyone happy I don't think so

00:04:47,510 --> 00:04:53,550
there are a number of reasons why I'm

00:04:49,890 --> 00:04:55,260
saying that so first of all like the

00:04:53,550 --> 00:04:56,520
very approach to fight like off pipe I

00:04:55,260 --> 00:04:59,010
like let's let's write the entire

00:04:56,520 --> 00:05:00,900
interpreter in Python it sounds very

00:04:59,010 --> 00:05:02,910
attractive so it cut in terms of like a

00:05:00,900 --> 00:05:04,590
tracking user so that it's it's all

00:05:02,910 --> 00:05:07,440
Python it's very easy to hack on and

00:05:04,590 --> 00:05:08,430
it's very easy to do stuff we've except

00:05:07,440 --> 00:05:09,900
that if you want to do something

00:05:08,430 --> 00:05:11,130
meaningful other than changing a trivial

00:05:09,900 --> 00:05:12,750
bug in the standard library we have to

00:05:11,130 --> 00:05:15,150
start at manual prod factors for two

00:05:12,750 --> 00:05:17,040
hours and you don't have any chance to

00:05:15,150 --> 00:05:18,600
do to make any meaningful contribution

00:05:17,040 --> 00:05:23,010
in the timeframe of a spring for example

00:05:18,600 --> 00:05:24,270
and you can compare that with for

00:05:23,010 --> 00:05:26,150
example the Ruby newest project that

00:05:24,270 --> 00:05:28,290
exists in the Ruby community so it's a

00:05:26,150 --> 00:05:30,360
it's an implementation of Ruby language

00:05:28,290 --> 00:05:33,300
it also positions itself to some degree

00:05:30,360 --> 00:05:34,530
too as Ruby written in Ruby and what

00:05:33,300 --> 00:05:37,260
they do is they actually have like

00:05:34,530 --> 00:05:39,720
likely very poor small virtual machine

00:05:37,260 --> 00:05:42,810
written in C++ using like more modern

00:05:39,720 --> 00:05:44,160
C++ vm development technologies and then

00:05:42,810 --> 00:05:48,210
there are as much of the language as

00:05:44,160 --> 00:05:49,590
possible using the using the using the

00:05:48,210 --> 00:05:51,210
primitives provided a virtual machine

00:05:49,590 --> 00:05:52,470
and that language itself so for example

00:05:51,210 --> 00:05:55,200
the hash table implementation is written

00:05:52,470 --> 00:05:57,090
in Ruby like in pythons it would be

00:05:55,200 --> 00:06:00,300
written in dictum in Python in this case

00:05:57,090 --> 00:06:02,340
and by having the by having much more of

00:06:00,300 --> 00:06:04,560
the code written in Ruby they have much

00:06:02,340 --> 00:06:07,710
greater possibility for visibility for

00:06:04,560 --> 00:06:09,270
insights between different parts of so

00:06:07,710 --> 00:06:10,890
the compiler can essentially see through

00:06:09,270 --> 00:06:14,190
the function calls and can do better job

00:06:10,890 --> 00:06:15,690
at inlining at optimizing code like and

00:06:14,190 --> 00:06:18,990
essentially giving better performance

00:06:15,690 --> 00:06:21,870
simply through the through the benefit

00:06:18,990 --> 00:06:25,280
of making it possible to see stuff

00:06:21,870 --> 00:06:30,000
across the boundaries of function calls

00:06:25,280 --> 00:06:31,800
and I think that that kind of approach

00:06:30,000 --> 00:06:33,600
is also much more hackable so if you

00:06:31,800 --> 00:06:35,970
want to change something yeah you had

00:06:33,600 --> 00:06:37,950
you don't have to go to wait see through

00:06:35,970 --> 00:06:39,450
like a long jet long

00:06:37,950 --> 00:06:41,100
running generation process and stuff

00:06:39,450 --> 00:06:42,480
like that you can simply go and change

00:06:41,100 --> 00:06:45,540
whatever you need and compile it but

00:06:42,480 --> 00:06:47,340
compile the interpreter and runs and

00:06:45,540 --> 00:06:49,380
another point that I would like to make

00:06:47,340 --> 00:06:51,240
in this case is that pipe art has been

00:06:49,380 --> 00:06:52,710
around for a very long time really

00:06:51,240 --> 00:06:55,500
really really long time and the approach

00:06:52,710 --> 00:06:57,960
that have been taking to like solving

00:06:55,500 --> 00:06:58,890
the performance issue is essentially the

00:06:57,960 --> 00:07:01,320
same the whole time

00:06:58,890 --> 00:07:02,790
it is nice and innovative but in the

00:07:01,320 --> 00:07:06,060
timeframe that they have been doing that

00:07:02,790 --> 00:07:07,950
for example Mozilla has gone through

00:07:06,060 --> 00:07:10,160
like three generations of gee technology

00:07:07,950 --> 00:07:13,020
so they used to have a tracing jeet and

00:07:10,160 --> 00:07:15,480
now they have another it was trace

00:07:13,020 --> 00:07:17,310
monkey jogger monkey iron monkey some

00:07:15,480 --> 00:07:21,600
other monkey I don't sorry I'm not very

00:07:17,310 --> 00:07:26,370
very deeply familiar with that but the

00:07:21,600 --> 00:07:28,380
the point is that by PI has essentially

00:07:26,370 --> 00:07:30,150
essentially standstill in two while

00:07:28,380 --> 00:07:31,920
there are the world around it

00:07:30,150 --> 00:07:33,420
essentially evolved and comes up with

00:07:31,920 --> 00:07:35,810
better ways to implement virtual

00:07:33,420 --> 00:07:35,810
machines yeah

00:07:43,860 --> 00:07:48,390
and I cannot commit here anyway so so I

00:07:46,620 --> 00:07:51,180
was under the impression that the way

00:07:48,390 --> 00:07:53,490
that high pi is now corresponds to what

00:07:51,180 --> 00:07:54,930
Wasilla is now so Mozilla has gone

00:07:53,490 --> 00:07:57,480
through iterations to get to a pi PI is

00:07:54,930 --> 00:07:59,400
now so pipe I was doing 10 years ago

00:07:57,480 --> 00:07:59,940
what Mozilla is doing now I don't think

00:07:59,400 --> 00:08:02,610
so

00:07:59,940 --> 00:08:04,050
so what pipe is what pipe I was doing

00:08:02,610 --> 00:08:06,180
and still is doing is essentially the

00:08:04,050 --> 00:08:07,650
tracing JIT approach and as far as I

00:08:06,180 --> 00:08:09,750
stand this is the trace monkey that is

00:08:07,650 --> 00:08:11,100
about to be led like it was recently

00:08:09,750 --> 00:08:12,870
removed from them as difficult based so

00:08:11,100 --> 00:08:14,490
my my understanding is that it's not

00:08:12,870 --> 00:08:16,020
what Mozilla doing is doing now but

00:08:14,490 --> 00:08:18,860
anyways it's like tangential we can

00:08:16,020 --> 00:08:18,860
discuss this problem easily

00:08:19,520 --> 00:08:25,920
another thing is joyful and I recently

00:08:23,610 --> 00:08:28,290
had to had to essentially do some

00:08:25,920 --> 00:08:29,820
prototyping at work like web web like a

00:08:28,290 --> 00:08:31,350
web development project and I didn't

00:08:29,820 --> 00:08:32,910
want to do this in Java I wanted to use

00:08:31,350 --> 00:08:35,040
this dynamic talent for this and

00:08:32,910 --> 00:08:37,260
unfortunately I had to choose JRuby

00:08:35,040 --> 00:08:40,350
rather than Java and the reason is that

00:08:37,260 --> 00:08:42,270
by being on the G so like all of our

00:08:40,350 --> 00:08:44,520
like web technology stacked runs on the

00:08:42,270 --> 00:08:47,610
JVM so we have monitoring tools we have

00:08:44,520 --> 00:08:50,250
like log analysis tools we have simply

00:08:47,610 --> 00:08:52,260
like ways to deploy and manage the web

00:08:50,250 --> 00:08:54,930
applications and they all are tied to

00:08:52,260 --> 00:08:58,050
the JVM and by being on the JVM I can

00:08:54,930 --> 00:09:00,230
simply rely on the oldies tools being

00:08:58,050 --> 00:09:02,220
available and kind of pretend that okay

00:09:00,230 --> 00:09:04,230
you shouldn't care that I'm doing this

00:09:02,220 --> 00:09:06,530
stuff not in Java it's just a war file

00:09:04,230 --> 00:09:08,760
just like everyone else is doing and

00:09:06,530 --> 00:09:11,250
jonathan is unfortunate not mature

00:09:08,760 --> 00:09:13,080
enough for being for using such

00:09:11,250 --> 00:09:16,830
environments yes you can build war files

00:09:13,080 --> 00:09:18,660
with jars and you can do this stuff but

00:09:16,830 --> 00:09:20,160
the language is not really up to date

00:09:18,660 --> 00:09:22,590
the performance of the implementation is

00:09:20,160 --> 00:09:25,350
nowhere near what JRuby can do and so on

00:09:22,590 --> 00:09:27,330
and being on the JVM is important in

00:09:25,350 --> 00:09:32,100
many cases and unfortunately Titan is

00:09:27,330 --> 00:09:34,440
not good enough for for this yet next

00:09:32,100 --> 00:09:36,120
point is mobile so we always obviously

00:09:34,440 --> 00:09:38,250
we all have the key we project which is

00:09:36,120 --> 00:09:40,500
which which which we all love and which

00:09:38,250 --> 00:09:42,330
is doing some great stuff but if you

00:09:40,500 --> 00:09:44,340
compare TV to what the Ruby guys have

00:09:42,330 --> 00:09:45,870
then you will find that it's again there

00:09:44,340 --> 00:09:48,360
is no comparison so first of all they

00:09:45,870 --> 00:09:50,210
have the Ruby motion project and it'll

00:09:48,360 --> 00:09:53,760
be motion is essentially a compiler of

00:09:50,210 --> 00:09:56,190
Ruby code to native iOS applications

00:09:53,760 --> 00:09:56,810
that can i OS and Mac OS application

00:09:56,190 --> 00:09:58,850
that can be

00:09:56,810 --> 00:10:01,100
deploy to the max to the Mac App Store

00:09:58,850 --> 00:10:02,840
you have full access to all the ApS

00:10:01,100 --> 00:10:05,750
provided by the operating system and

00:10:02,840 --> 00:10:07,670
simply you use an ie you don't have to

00:10:05,750 --> 00:10:10,010
use an ID user use a nice language to

00:10:07,670 --> 00:10:11,900
write your stuff in and the end result

00:10:10,010 --> 00:10:14,839
looks exactly like a native application

00:10:11,900 --> 00:10:16,310
written in objective-c the Android

00:10:14,839 --> 00:10:18,350
situation is a little bit better better

00:10:16,310 --> 00:10:23,930
for Python but still no we're not good

00:10:18,350 --> 00:10:25,400
enough compared to Ruby so in in that so

00:10:23,930 --> 00:10:26,810
we have this there is this Q Python

00:10:25,400 --> 00:10:31,310
project that is some kind of Python

00:10:26,810 --> 00:10:33,470
implemented on on Android but my

00:10:31,310 --> 00:10:35,150
understanding is that please correct me

00:10:33,470 --> 00:10:36,560
if I'm wrong I'm not trying to % sure of

00:10:35,150 --> 00:10:38,029
what I'm saying right now but my

00:10:36,560 --> 00:10:39,470
understanding is that like all the

00:10:38,029 --> 00:10:41,660
current Android implementations on

00:10:39,470 --> 00:10:43,760
Python implementations Android are based

00:10:41,660 --> 00:10:46,160
on the C Python code base and so they

00:10:43,760 --> 00:10:49,460
have to restrict to something called PJ

00:10:46,160 --> 00:10:51,380
and I use PI genius or whatever you call

00:10:49,460 --> 00:10:53,240
it to call the Android API s and this is

00:10:51,380 --> 00:10:54,500
limited so you can call the e path but

00:10:53,240 --> 00:10:58,550
for example you cannot implement an

00:10:54,500 --> 00:10:59,720
activity class in in Python you have to

00:10:58,550 --> 00:11:01,220
do you have to like that use the

00:10:59,720 --> 00:11:03,020
standard activity class that provided by

00:11:01,220 --> 00:11:06,560
the frame up in something some way plug

00:11:03,020 --> 00:11:08,150
into it and in the Ruby there in the

00:11:06,560 --> 00:11:09,110
Ruby world there is rubato which is

00:11:08,150 --> 00:11:10,520
based on JRuby

00:11:09,110 --> 00:11:12,110
and essentially you run G Ruby on

00:11:10,520 --> 00:11:13,760
Android and this is like a full-featured

00:11:12,110 --> 00:11:16,550
implementation of Ruby and it gives you

00:11:13,760 --> 00:11:18,290
full access to all of the api's that are

00:11:16,550 --> 00:11:20,500
on the platform there is no restrictions

00:11:18,290 --> 00:11:26,270
like you can implement classes you can

00:11:20,500 --> 00:11:29,680
do anything like and you get fairly nice

00:11:26,270 --> 00:11:29,680
performance and for a nice experience

00:11:30,520 --> 00:11:34,460
the next question is near the next issue

00:11:32,960 --> 00:11:37,070
is near and dear to my heart and the

00:11:34,460 --> 00:11:39,020
issues tooling and there are like two

00:11:37,070 --> 00:11:40,880
aspects of that distal activation first

00:11:39,020 --> 00:11:43,730
the first one is one that I have already

00:11:40,880 --> 00:11:46,580
brought up which is a introspection and

00:11:43,730 --> 00:11:48,980
profiling support so in this case

00:11:46,580 --> 00:11:50,780
unfortunately Ruby has nothing to show

00:11:48,980 --> 00:11:53,150
us as a good example but the Java and

00:11:50,780 --> 00:11:55,190
the suvarovs has have a lot to show how

00:11:53,150 --> 00:11:57,380
this how like a real modern virtual

00:11:55,190 --> 00:12:00,350
machine can can be implemented in this

00:11:57,380 --> 00:12:01,730
regard so they expose a ton a ton of

00:12:00,350 --> 00:12:02,959
information about everything that's

00:12:01,730 --> 00:12:05,959
happening inside the virtual machine

00:12:02,959 --> 00:12:07,370
garbage collection JIT performance you

00:12:05,959 --> 00:12:09,020
can see all the metrics of what's going

00:12:07,370 --> 00:12:10,550
on there like trace every object

00:12:09,020 --> 00:12:12,649
allocation trace every byte

00:12:10,550 --> 00:12:14,690
instruction being executed and so on and

00:12:12,649 --> 00:12:16,190
this gives you like great tools great

00:12:14,690 --> 00:12:19,850
profiling tools that people can build

00:12:16,190 --> 00:12:21,110
and like Canales NL for analyze like the

00:12:19,850 --> 00:12:22,760
application can analyze its own

00:12:21,110 --> 00:12:24,080
performance you can introspect your own

00:12:22,760 --> 00:12:25,820
virtual machine which you are Ronnie and

00:12:24,080 --> 00:12:27,140
see if maybe you don't have enough

00:12:25,820 --> 00:12:29,470
memory on maybe you are for some reason

00:12:27,140 --> 00:12:31,760
running too slow and would like to

00:12:29,470 --> 00:12:36,709
report would like to somehow

00:12:31,760 --> 00:12:38,329
troubleshoot this situation and I don't

00:12:36,709 --> 00:12:39,980
see any sign of development in this area

00:12:38,329 --> 00:12:43,100
none whatsoever

00:12:39,980 --> 00:12:45,890
and the second part is like directly

00:12:43,100 --> 00:12:50,110
tied but from what I'm working on which

00:12:45,890 --> 00:12:53,750
is ideas and static analysis tools and I

00:12:50,110 --> 00:12:55,250
see against very low very low levels of

00:12:53,750 --> 00:12:57,019
interests for adding like optional

00:12:55,250 --> 00:12:58,850
static typing or information to Python

00:12:57,019 --> 00:13:01,820
code so there is that there are these

00:12:58,850 --> 00:13:05,089
annotations that are in theory supposed

00:13:01,820 --> 00:13:07,459
to be used maybe somehow for adding type

00:13:05,089 --> 00:13:08,899
information first of all no one knows

00:13:07,459 --> 00:13:10,550
how exactly they should be used there is

00:13:08,899 --> 00:13:11,959
no standard there is no convention there

00:13:10,550 --> 00:13:15,800
is no library that could make use of

00:13:11,959 --> 00:13:17,480
those second there is there has been it

00:13:15,800 --> 00:13:18,740
was stated very explicitly that the

00:13:17,480 --> 00:13:20,329
standard library will never have this

00:13:18,740 --> 00:13:22,040
information so the Python standard

00:13:20,329 --> 00:13:23,990
library will never use annotations and

00:13:22,040 --> 00:13:25,490
what this means that every everyone

00:13:23,990 --> 00:13:28,970
working on a tool that wants to provide

00:13:25,490 --> 00:13:30,980
some smart code analysis support for for

00:13:28,970 --> 00:13:33,589
Python has to redo all the work again so

00:13:30,980 --> 00:13:36,399
we have a bunch of maybe I'll be able to

00:13:33,589 --> 00:13:36,399
show something

00:13:50,670 --> 00:13:54,960
so we have this file essentially is

00:13:55,950 --> 00:13:59,560
essentially specifying the types of the

00:13:58,120 --> 00:14:01,150
standard library functions like hold at

00:13:59,560 --> 00:14:02,950
what types the parameter have what what

00:14:01,150 --> 00:14:06,160
the return types are and stuff like that

00:14:02,950 --> 00:14:07,300
and we've had to build this information

00:14:06,160 --> 00:14:09,580
by ourselves and there was another

00:14:07,300 --> 00:14:12,310
project at Google that did some similar

00:14:09,580 --> 00:14:13,450
stuff I didn't know back in 2009 or

00:14:12,310 --> 00:14:14,710
something and essentially everyone who

00:14:13,450 --> 00:14:16,750
wants to build a good tool for Python

00:14:14,710 --> 00:14:18,010
has to build up a database of this stuff

00:14:16,750 --> 00:14:21,820
and that's really a shame and a lot of

00:14:18,010 --> 00:14:22,930
wasted effort and again this I there's

00:14:21,820 --> 00:14:25,180
like a bit of a chicken and egg problem

00:14:22,930 --> 00:14:28,589
and the key reason is no one I don't see

00:14:25,180 --> 00:14:28,589
and like any desire for this to change

00:14:30,150 --> 00:14:33,940
yeah and for example you did the

00:14:32,320 --> 00:14:35,500
OpenStack talk this morning was talking

00:14:33,940 --> 00:14:37,480
about like setting up a code review

00:14:35,500 --> 00:14:39,880
process for a project which has like 800

00:14:37,480 --> 00:14:41,650
developers and nine a hundred thousand

00:14:39,880 --> 00:14:43,540
lines of code and they also they wanted

00:14:41,650 --> 00:14:44,800
to have robust static analysis tools

00:14:43,540 --> 00:14:46,330
because it's only the only way to

00:14:44,800 --> 00:14:48,190
maintain sanity when you have a project

00:14:46,330 --> 00:14:49,900
of this size and the tools are not there

00:14:48,190 --> 00:14:51,970
and they're not coming there or like

00:14:49,900 --> 00:14:53,050
coming very slowly and if you compare

00:14:51,970 --> 00:14:54,490
this to what's happening with other

00:14:53,050 --> 00:14:56,470
languages for example there are like

00:14:54,490 --> 00:14:58,240
multiple standards like multi like there

00:14:56,470 --> 00:15:00,250
are multiple attempts to read built

00:14:58,240 --> 00:15:02,080
javascript with the purpose of providing

00:15:00,250 --> 00:15:03,430
better tooling so there is thought that

00:15:02,080 --> 00:15:05,350
Google builds and there is typescript

00:15:03,430 --> 00:15:07,240
that Microsoft builds and both of those

00:15:05,350 --> 00:15:09,790
even though there are dynamically types

00:15:07,240 --> 00:15:13,000
they have altered dynamic typing

00:15:09,790 --> 00:15:14,650
infrastructure that still support all

00:15:13,000 --> 00:15:16,630
the dynamic typing features that regular

00:15:14,650 --> 00:15:18,400
JavaScript supports they are fully

00:15:16,630 --> 00:15:20,050
statically typed and they can like they

00:15:18,400 --> 00:15:21,580
have like all the static type

00:15:20,050 --> 00:15:24,190
information that is required to build a

00:15:21,580 --> 00:15:26,200
robust ID to build refactoring tools to

00:15:24,190 --> 00:15:28,209
build code analysis tools and so on and

00:15:26,200 --> 00:15:31,410
like vendors of many other languages are

00:15:28,209 --> 00:15:33,550
also concerned with tooling so the scala

00:15:31,410 --> 00:15:34,930
developers the typesafe is heavily

00:15:33,550 --> 00:15:36,490
investing into tuning the developers of

00:15:34,930 --> 00:15:38,890
groovy the groovy language results are

00:15:36,490 --> 00:15:40,300
also heavily investing into dueling and

00:15:38,890 --> 00:15:41,770
here at PyCon we are debating whether

00:15:40,300 --> 00:15:43,480
beam is better than Emacs and both of

00:15:41,770 --> 00:15:46,410
those were developed in their like late

00:15:43,480 --> 00:15:48,060
70s 80s

00:15:46,410 --> 00:15:56,339
haven't gotten much better since that

00:15:48,060 --> 00:15:57,569
time yes and finally there is one thing

00:15:56,339 --> 00:15:59,940
that I wanted to show which is why I

00:15:57,569 --> 00:16:01,860
actually spent all the time messing with

00:15:59,940 --> 00:16:04,860
my screen is this there was a poster

00:16:01,860 --> 00:16:07,709
session at PyCon about the experience of

00:16:04,860 --> 00:16:09,269
novice people starting with Python and

00:16:07,709 --> 00:16:10,829
you should just dive in a write this

00:16:09,269 --> 00:16:13,439
thing down write down this link

00:16:10,829 --> 00:16:16,259
somewhere and simply go and look at this

00:16:13,439 --> 00:16:19,730
and despite all of the progress that

00:16:16,259 --> 00:16:23,430
python is making in education and like I

00:16:19,730 --> 00:16:26,399
don't know at spreading the joy of

00:16:23,430 --> 00:16:30,240
program into more and more audiences

00:16:26,399 --> 00:16:32,160
like outreach programs like getting kids

00:16:30,240 --> 00:16:33,899
to program getting I don't know latest

00:16:32,160 --> 00:16:35,759
program and so on and so forth despite

00:16:33,899 --> 00:16:37,500
investing a lot in to the community

00:16:35,759 --> 00:16:39,180
efforts that are still not that much

00:16:37,500 --> 00:16:43,819
being done on the side of the language

00:16:39,180 --> 00:16:47,550
itself to make like this novice trending

00:16:43,819 --> 00:16:51,360
so how do you compare Python to PHP is

00:16:47,550 --> 00:16:53,009
it at least better than PHP I find PHP

00:16:51,360 --> 00:16:55,470
like the most hopeful language and the

00:16:53,009 --> 00:17:00,540
most awful ecosystem in existence so no

00:16:55,470 --> 00:17:03,360
comparison in this regard I think I'm

00:17:00,540 --> 00:17:05,520
done so that's what I wanted to say and

00:17:03,360 --> 00:17:08,669
we have some time to discuss this and

00:17:05,520 --> 00:17:11,280
please go ahead criticize me and tell me

00:17:08,669 --> 00:17:14,689
why I'm all wrong and or what I missed

00:17:11,280 --> 00:17:14,689
and so on and if you live

00:17:20,140 --> 00:17:25,250
but I guess you believe I want to

00:17:22,939 --> 00:17:27,470
remember just a finger to everyone on

00:17:25,250 --> 00:17:30,440
our main side the european europe item

00:17:27,470 --> 00:17:32,990
dot you on the main menu you can find

00:17:30,440 --> 00:17:34,790
the voice italian mobile guide you go

00:17:32,990 --> 00:17:37,400
there you click use a large mobile

00:17:34,790 --> 00:17:39,530
application and you can go to a normal

00:17:37,400 --> 00:17:42,590
talk it even business open space so if

00:17:39,530 --> 00:17:46,220
you enjoyed that what is saying give me

00:17:42,590 --> 00:17:48,290
my good rating okay okay for a question

00:17:46,220 --> 00:17:52,910
from the public i leave you bommali okay

00:17:48,290 --> 00:18:02,630
i just i don't know any comments any

00:17:52,910 --> 00:18:06,860
okay yeah i it's on i think yeah yeah i

00:18:02,630 --> 00:18:09,020
think it works like it i like to your

00:18:06,860 --> 00:18:11,600
analysis a lot especially well at least

00:18:09,020 --> 00:18:14,780
the parts that I am aware of I must act

00:18:11,600 --> 00:18:17,960
would agree video and in particular I

00:18:14,780 --> 00:18:20,179
think the the situation like I I think

00:18:17,960 --> 00:18:21,830
starting typing like optional static

00:18:20,179 --> 00:18:24,770
typing would be really useful because

00:18:21,830 --> 00:18:28,549
and it would help a lot also was the

00:18:24,770 --> 00:18:30,500
performance problem in my opinion and

00:18:28,549 --> 00:18:32,419
perhaps I would allow to do what what

00:18:30,500 --> 00:18:34,429
what Rubinius does because you could

00:18:32,419 --> 00:18:36,169
rewrite the standard library using

00:18:34,429 --> 00:18:37,730
static typing and being high-performance

00:18:36,169 --> 00:18:41,750
you could solve that problem so I think

00:18:37,730 --> 00:18:43,750
that's kind of a big thing but I don't

00:18:41,750 --> 00:18:46,160
really see any problems unfortunately so

00:18:43,750 --> 00:18:52,210
okay I don't know I don't have any idea

00:18:46,160 --> 00:18:52,210
okay thanks okay

00:18:53,720 --> 00:18:58,370
best work okay two things

00:18:56,690 --> 00:19:02,720
well I haven't touched my pie in quite a

00:18:58,370 --> 00:19:06,529
bit of time but the the thing you said

00:19:02,720 --> 00:19:08,720
about the jeat the tracing and I think

00:19:06,529 --> 00:19:11,809
it's kinda different from the muscle

00:19:08,720 --> 00:19:13,880
implementation but the map I did which

00:19:11,809 --> 00:19:17,299
is actually a bit yeah it's actually

00:19:13,880 --> 00:19:19,549
built to be as far as know as most as

00:19:17,299 --> 00:19:21,110
possible and your stick from the

00:19:19,549 --> 00:19:23,330
implementation of your language from all

00:19:21,110 --> 00:19:25,970
the methods are called so you can have

00:19:23,330 --> 00:19:29,169
tapas or that experimental HP

00:19:25,970 --> 00:19:31,970
implementation built on it so it's kinda

00:19:29,169 --> 00:19:34,340
natural that maybe it's not as efficient

00:19:31,970 --> 00:19:37,010
or something else I mean appetite maybe

00:19:34,340 --> 00:19:39,200
is not as great as other projects like

00:19:37,010 --> 00:19:41,720
Ruby knows in the Python ecosystem

00:19:39,200 --> 00:19:43,700
because well it does not integrate as

00:19:41,720 --> 00:19:46,399
well we see extension importantly

00:19:43,700 --> 00:19:49,100
because it's a hard problem but it's a

00:19:46,399 --> 00:19:51,140
lot nicer I think resource project at

00:19:49,100 --> 00:19:54,230
least also it before the Killick there

00:19:51,140 --> 00:19:57,649
was also the object-oriented back-end

00:19:54,230 --> 00:20:01,429
and things like that so I maybe we have

00:19:57,649 --> 00:20:03,380
a lot of you too few practical uses for

00:20:01,429 --> 00:20:05,000
these alternative implementation but I

00:20:03,380 --> 00:20:08,450
don't think it's so but the other thing

00:20:05,000 --> 00:20:12,950
is Roboto I looked at it some time ago

00:20:08,450 --> 00:20:14,990
and it's well if you run a closure

00:20:12,950 --> 00:20:16,789
application on Android it takes

00:20:14,990 --> 00:20:19,250
something like six seven second or third

00:20:16,789 --> 00:20:21,860
time startup time Roboto it takes

00:20:19,250 --> 00:20:25,789
something like 15 seconds maybe they

00:20:21,860 --> 00:20:28,750
have been able to improve it but I don't

00:20:25,789 --> 00:20:31,630
think that actually using any

00:20:28,750 --> 00:20:34,789
dynamically typed language on the

00:20:31,630 --> 00:20:36,020
Android VM is quite feasible nowadays I

00:20:34,789 --> 00:20:38,809
mean you can you can do something but

00:20:36,020 --> 00:20:40,340
mmm a few users probably appreciate it

00:20:38,809 --> 00:20:43,279
and that's it

00:20:40,340 --> 00:20:47,090
so I mean they are both good points but

00:20:43,279 --> 00:20:48,500
again the so it's for Popeye I'm not

00:20:47,090 --> 00:20:49,850
trying to like to bash on the pipe I

00:20:48,500 --> 00:20:52,360
processor they're doing great research

00:20:49,850 --> 00:20:54,740
but what I'm saying is that we need more

00:20:52,360 --> 00:20:57,350
experiments using other approaches to

00:20:54,740 --> 00:20:58,850
like like other modern approaches to

00:20:57,350 --> 00:21:00,740
building good interpreters and simply we

00:20:58,850 --> 00:21:03,110
need more innovation and in terms of

00:21:00,740 --> 00:21:05,190
robotic yet it's true that is the

00:21:03,110 --> 00:21:07,680
performance problems are indeed there

00:21:05,190 --> 00:21:09,900
but I think it is possible to work on

00:21:07,680 --> 00:21:11,430
them and it is spotty it is worse it's a

00:21:09,900 --> 00:21:12,660
battle worth fighting so what that's

00:21:11,430 --> 00:21:14,010
what I'm saying and it's better it's

00:21:12,660 --> 00:21:16,790
worth fighting not only on the Ruby

00:21:14,010 --> 00:21:19,230
front but also in the Python file yep

00:21:16,790 --> 00:21:21,060
but I really like to talk I think it's

00:21:19,230 --> 00:21:22,530
valuable that we sort of all don't think

00:21:21,060 --> 00:21:24,480
we're all wonderful nothing's great I

00:21:22,530 --> 00:21:26,280
think this is really valuable

00:21:24,480 --> 00:21:27,600
partly because I've got a lot of

00:21:26,280 --> 00:21:29,250
parallel experience nothing in this

00:21:27,600 --> 00:21:31,200
conference three years and there's so

00:21:29,250 --> 00:21:33,120
many negative Perl comments which are

00:21:31,200 --> 00:21:35,310
completely unfounded it's all parallel

00:21:33,120 --> 00:21:36,660
dick technology but the real thing I

00:21:35,310 --> 00:21:39,860
want to say is I thought you would

00:21:36,660 --> 00:21:43,800
perhaps attack the threading in Perl

00:21:39,860 --> 00:21:46,560
Python I think that that to me is it is

00:21:43,800 --> 00:21:48,810
a weakness to kill all those issues so I

00:21:46,560 --> 00:21:50,940
do the other languages like you know

00:21:48,810 --> 00:21:53,220
Ruby and c-sharp what solutions are they

00:21:50,940 --> 00:21:57,150
have in the threading area compared to

00:21:53,220 --> 00:21:58,740
Python so it's far instead the situation

00:21:57,150 --> 00:22:00,810
in the Ruby world is not significantly

00:21:58,740 --> 00:22:03,210
different from that of Python I'm I

00:22:00,810 --> 00:22:05,640
think they also have a Jill you know

00:22:03,210 --> 00:22:07,230
even in the Ruby Y so they have actually

00:22:05,640 --> 00:22:08,930
rewritten the virtual machine in ruby

00:22:07,230 --> 00:22:11,010
1.9 so now they have like a real

00:22:08,930 --> 00:22:12,660
efficient byte code based interpreter

00:22:11,010 --> 00:22:14,340
instead of the ast walking interpreter

00:22:12,660 --> 00:22:16,530
but they still have the Jill and the

00:22:14,340 --> 00:22:19,050
problems are still roughly concave I

00:22:16,530 --> 00:22:21,360
don't need this the problems are still

00:22:19,050 --> 00:22:23,160
on the roughness of the same way and the

00:22:21,360 --> 00:22:25,290
station with DVM and c-sharp are are

00:22:23,160 --> 00:22:27,090
obviously much better because the these

00:22:25,290 --> 00:22:28,590
virtual machines have a lot they have

00:22:27,090 --> 00:22:30,750
very efficient trading implementations

00:22:28,590 --> 00:22:32,940
the very scalable garbage collectors

00:22:30,750 --> 00:22:37,320
very nicely detailed memory models for

00:22:32,940 --> 00:22:38,660
the VMS and it's much much better I'm a

00:22:37,320 --> 00:22:42,330
beginner

00:22:38,660 --> 00:22:43,800
- tester in my company so this is

00:22:42,330 --> 00:22:46,880
probably gonna be a really naive

00:22:43,800 --> 00:22:49,920
question but is the reason that

00:22:46,880 --> 00:22:51,330
c-sharp and Ruby are ahead of us in

00:22:49,920 --> 00:22:54,210
certain places is because they have

00:22:51,330 --> 00:22:57,450
corporate back in well Dolby does not

00:22:54,210 --> 00:22:59,190
have any corporate back so Ruby so yeah

00:22:57,450 --> 00:23:00,570
so - so she sharp is obviously bacon

00:22:59,190 --> 00:23:04,020
backed by Microsoft and they can hire

00:23:00,570 --> 00:23:05,460
very good people to work on it and but

00:23:04,020 --> 00:23:07,610
this is the Ruby is also essentially a

00:23:05,460 --> 00:23:09,810
community developed language so there is

00:23:07,610 --> 00:23:12,480
it's mostly developed in Japan actually

00:23:09,810 --> 00:23:14,220
so there was like it's like a whole lot

00:23:12,480 --> 00:23:15,190
a whole other group of problems with

00:23:14,220 --> 00:23:18,040
like Japanese - lie

00:23:15,190 --> 00:23:19,900
English translation I should go I did

00:23:18,040 --> 00:23:21,250
shouldn't go to it probably but it does

00:23:19,900 --> 00:23:22,420
not have any major copper baking so

00:23:21,250 --> 00:23:24,250
there are there are companies doing

00:23:22,420 --> 00:23:27,130
commercial stuff with Ruby adjust a

00:23:24,250 --> 00:23:28,360
engine yard for example just as there

00:23:27,130 --> 00:23:30,400
are companies doing commercial stuff

00:23:28,360 --> 00:23:33,280
it's Python but overall in all it's the

00:23:30,400 --> 00:23:34,450
same look we have a lot of like I've

00:23:33,280 --> 00:23:37,720
seen lots of signs with all the

00:23:34,450 --> 00:23:39,970
corporate sponsors so is the Pythian

00:23:37,720 --> 00:23:41,700
foundation pushing like this sort of

00:23:39,970 --> 00:23:44,200
like we want to go on down this track

00:23:41,700 --> 00:23:46,090
now to get like you some proper resource

00:23:44,200 --> 00:23:49,420
so is it are we just hoping that the

00:23:46,090 --> 00:23:51,130
open-source community will Python

00:23:49,420 --> 00:23:53,020
foundation I think does a very good job

00:23:51,130 --> 00:23:54,400
in general of supporting Python projects

00:23:53,020 --> 00:23:56,260
and solving problems in the Python

00:23:54,400 --> 00:23:58,270
community and I'm very impressed by that

00:23:56,260 --> 00:23:59,650
and by the way nothing I don't know an

00:23:58,270 --> 00:24:01,390
equivalent of that in like a day other

00:23:59,650 --> 00:24:02,950
language communities and it's one of the

00:24:01,390 --> 00:24:04,780
big advantages of but the Python world

00:24:02,950 --> 00:24:06,100
but the thing is that in terms of for

00:24:04,780 --> 00:24:08,260
example of the language implementations

00:24:06,100 --> 00:24:09,910
they have seem to have decided that pi

00:24:08,260 --> 00:24:11,680
pi is where it's at they are giving

00:24:09,910 --> 00:24:13,630
money to pi PI to fund its development

00:24:11,680 --> 00:24:15,220
and I don't think they are really

00:24:13,630 --> 00:24:25,000
backing any other research to build

00:24:15,220 --> 00:24:27,640
alternative bison implementations have

00:24:25,000 --> 00:24:30,730
you seen that the talk about the static

00:24:27,640 --> 00:24:32,080
compiler the one else cut yeah I've

00:24:30,730 --> 00:24:33,580
actually I've seen this talk at one of

00:24:32,080 --> 00:24:37,330
the previous conference I didn't go this

00:24:33,580 --> 00:24:41,040
this year but I didn't quite understand

00:24:37,330 --> 00:24:43,330
what like why he was saying that the the

00:24:41,040 --> 00:24:44,860
mainstream of the power fight and really

00:24:43,330 --> 00:24:46,830
is against this project and kind of

00:24:44,860 --> 00:24:49,150
things sees it as it shouldn't exist

00:24:46,830 --> 00:24:51,460
might be you're aware of the details of

00:24:49,150 --> 00:24:54,940
why why is the situation like that not

00:24:51,460 --> 00:24:56,680
really no but what do you think could

00:24:54,940 --> 00:24:59,290
that be useful as an alternative

00:24:56,680 --> 00:25:01,470
interpretation Clemente ssin which could

00:24:59,290 --> 00:25:04,060
kind of solve some of those problems

00:25:01,470 --> 00:25:06,430
I'm not sufficiently aware of the

00:25:04,060 --> 00:25:09,510
details sorry maybe but I cannot like

00:25:06,430 --> 00:25:09,510
claim in any other way

00:25:10,330 --> 00:25:13,110
okay

00:25:17,110 --> 00:25:22,030
so we're out of time right so we can

00:25:20,470 --> 00:25:23,710
continue outside of summer so I'm still

00:25:22,030 --> 00:25:34,060
around here with Bill I would love to

00:25:23,710 --> 00:25:35,680
talk about this morning and

00:25:34,060 --> 00:25:39,600
congratulation for proving your point

00:25:35,680 --> 00:25:39,600

YouTube URL: https://www.youtube.com/watch?v=PlXEsrhF1iE


