Title: L.  Hastings - All Singing All Dancing Python Bytecode
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	[Europython 2013]
L.  Hastings - All Singing All Dancing Python Bytecode
5 July 2013
Track Tagliatelle
Captions: 
	00:00:00,000 --> 00:00:02,030
I

00:00:04,330 --> 00:00:09,680
ok

00:00:07,140 --> 00:00:09,680
here

00:00:13,760 --> 00:00:21,660
Larry hosting where Hastings Hastings

00:00:16,770 --> 00:00:23,970
history is history hi 10 * tapatalk of

00:00:21,660 --> 00:00:27,210
Larry testing about the whole dancing or

00:00:23,970 --> 00:00:37,200
singing fightin bytecode please turn off

00:00:27,210 --> 00:00:39,090
your cell phones and enjoy okay I do

00:00:37,200 --> 00:00:41,670
have an hour but people were still

00:00:39,090 --> 00:00:43,410
shocked at how fast I went so I'm gonna

00:00:41,670 --> 00:00:45,149
go really fast because I have a lot of

00:00:43,410 --> 00:00:46,679
material to cover maybe we'll have time

00:00:45,149 --> 00:00:49,079
for questions or maybe you can just talk

00:00:46,679 --> 00:00:54,449
to me in the question answer in the

00:00:49,079 --> 00:00:56,850
halls afterwards so this is an

00:00:54,449 --> 00:00:58,980
intermediate level Python talk the talk

00:00:56,850 --> 00:01:01,710
is about all about Python specifically C

00:00:58,980 --> 00:01:03,120
Python I say C Python to differentiate

00:01:01,710 --> 00:01:05,820
the different implementations of Python

00:01:03,120 --> 00:01:07,530
so like Iron python is written in C

00:01:05,820 --> 00:01:08,909
sharp and Jaclyn's written in Java C

00:01:07,530 --> 00:01:10,680
Python is the version of Python written

00:01:08,909 --> 00:01:11,970
in C but it's the version of Python you

00:01:10,680 --> 00:01:13,650
get when you just type Python in and

00:01:11,970 --> 00:01:15,870
your prompt is probably the version of

00:01:13,650 --> 00:01:16,950
Python you're using now it probably

00:01:15,870 --> 00:01:18,299
actually is in the version of Python

00:01:16,950 --> 00:01:21,329
you're using because i'm giving the talk

00:01:18,299 --> 00:01:23,670
in Python 3 2 3 because I'm a Python

00:01:21,329 --> 00:01:26,399
core developer and 2 dot 7 is in my

00:01:23,670 --> 00:01:28,409
rearview mirror but the talk will be one

00:01:26,399 --> 00:01:32,369
hundred percent in Python there'll be no

00:01:28,409 --> 00:01:34,200
see anywhere in the slides and while the

00:01:32,369 --> 00:01:36,149
information is specific about C Python

00:01:34,200 --> 00:01:38,670
33 it's roughly applicable to some other

00:01:36,149 --> 00:01:40,469
places previous versions of Python 3

00:01:38,670 --> 00:01:42,630
it'll still be true it's even really

00:01:40,469 --> 00:01:44,520
still true about 2 dot seven it's even

00:01:42,630 --> 00:01:45,930
kind of true about pie pie the pie pie a

00:01:44,520 --> 00:01:48,860
byte code is very similar to C Python

00:01:45,930 --> 00:01:51,390
bytecode however ironpython and jake on

00:01:48,860 --> 00:01:53,460
the bike code itself is very dissimilar

00:01:51,390 --> 00:01:55,850
looking because the point of those is to

00:01:53,460 --> 00:01:59,759
use the native bytecode of their JVM or

00:01:55,850 --> 00:02:02,280
clr runtime however the concepts

00:01:59,759 --> 00:02:03,450
involved will generally be true and I

00:02:02,280 --> 00:02:04,560
think even some of the things that the

00:02:03,450 --> 00:02:08,149
some of the slides that i'll show you

00:02:04,560 --> 00:02:08,149
may even work on some of those systems

00:02:08,960 --> 00:02:15,500
now what is bytecode very simply pipe

00:02:13,040 --> 00:02:17,090
code is an instruction set for a virtual

00:02:15,500 --> 00:02:19,280
machine now it seems like every time I

00:02:17,090 --> 00:02:21,920
give a talk I give this same metaphor

00:02:19,280 --> 00:02:23,780
but a virtual machine is one of those

00:02:21,920 --> 00:02:25,970
really apt metaphors in computer science

00:02:23,780 --> 00:02:28,040
and that is both virtual and the machine

00:02:25,970 --> 00:02:31,610
it is virtual in the sense that it's not

00:02:28,040 --> 00:02:32,870
a solid piece of object of matter that

00:02:31,610 --> 00:02:36,350
you could go over and kick when it

00:02:32,870 --> 00:02:37,850
misbehaves and it's not um and it's a

00:02:36,350 --> 00:02:39,230
machine in that it has all the

00:02:37,850 --> 00:02:40,700
attributes of machine and when we say Ms

00:02:39,230 --> 00:02:44,180
machine here we really mean computers so

00:02:40,700 --> 00:02:46,280
it has registers it has a stack it has

00:02:44,180 --> 00:02:48,530
memory and has an instruction set and

00:02:46,280 --> 00:02:50,000
that instructions that we call bytecode

00:02:48,530 --> 00:02:51,530
when we're talking about a virtual

00:02:50,000 --> 00:02:53,330
machine in general because the

00:02:51,530 --> 00:02:55,250
instructions the individual instructions

00:02:53,330 --> 00:02:59,150
are one bite long that's what most

00:02:55,250 --> 00:03:01,510
people do now I would break C Python

00:02:59,150 --> 00:03:03,620
bytecode into roughly four categories

00:03:01,510 --> 00:03:06,020
these are very rough unfortunately

00:03:03,620 --> 00:03:08,330
there's stack manipulation opcodes like

00:03:06,020 --> 00:03:11,750
load and store these allow you to

00:03:08,330 --> 00:03:13,760
manipulate the stack their flow control

00:03:11,750 --> 00:03:16,760
operands like jump these allow you to

00:03:13,760 --> 00:03:18,710
manipulate the instruction pointer there

00:03:16,760 --> 00:03:20,840
are earth metic operations these allow

00:03:18,710 --> 00:03:23,210
you to perform math like plus and minus

00:03:20,840 --> 00:03:25,010
and times and divide and shift and then

00:03:23,210 --> 00:03:27,530
there's this grab ball bag of pythonic

00:03:25,010 --> 00:03:30,020
byte codes which do things that are

00:03:27,530 --> 00:03:32,740
specific to the Python interpreter like

00:03:30,020 --> 00:03:35,420
creating a couple or creating a set or

00:03:32,740 --> 00:03:37,730
loading a closure and there are some

00:03:35,420 --> 00:03:39,320
things that just exist as dirty little

00:03:37,730 --> 00:03:44,330
details to make the interpreters pipe

00:03:39,320 --> 00:03:47,870
life easier now when does the C Python

00:03:44,330 --> 00:03:49,730
use byte code the answer is all the time

00:03:47,870 --> 00:03:51,860
anytime the you are running Python code

00:03:49,730 --> 00:03:53,870
in the Python interpreter you're

00:03:51,860 --> 00:03:56,990
actually running bytecode which means

00:03:53,870 --> 00:03:58,790
actually that any X program that you can

00:03:56,990 --> 00:04:01,160
express in Python code you can express

00:03:58,790 --> 00:04:02,930
in bytecode the reverse however is not

00:04:01,160 --> 00:04:04,670
true there are programs you can express

00:04:02,930 --> 00:04:06,770
in bytecode the you cannot express in

00:04:04,670 --> 00:04:09,470
Python code like for instance you can

00:04:06,770 --> 00:04:12,590
jump arbitrarily any distance you want

00:04:09,470 --> 00:04:14,360
in the interpreter with bytecode you

00:04:12,590 --> 00:04:17,139
don't have a go-to instruction in Python

00:04:14,360 --> 00:04:20,530
and I think that's probably for the best

00:04:17,139 --> 00:04:21,849
now I have my coat at all the answer

00:04:20,530 --> 00:04:23,050
here is really simple this just helps

00:04:21,849 --> 00:04:24,580
you the management complexity when

00:04:23,050 --> 00:04:27,129
you're writing an interpreter this is a

00:04:24,580 --> 00:04:30,639
very standard paradigm for writing an

00:04:27,129 --> 00:04:33,189
interpreter everybody uses it Ruby uses

00:04:30,639 --> 00:04:36,400
it PHP use is it all those spy code is

00:04:33,189 --> 00:04:42,279
crazy every interpreter for python has

00:04:36,400 --> 00:04:44,139
some form of x code or another now it

00:04:42,279 --> 00:04:45,610
may be a little late we're five minutes

00:04:44,139 --> 00:04:48,550
in and now I'm asking the question why

00:04:45,610 --> 00:04:50,020
bother to look at it at all I was hoping

00:04:48,550 --> 00:04:51,370
you might have an answer for me since

00:04:50,020 --> 00:04:54,939
you're sitting here trying to learn

00:04:51,370 --> 00:04:56,229
about bytecode but I think there's only

00:04:54,939 --> 00:04:57,969
only one good answer if you want to

00:04:56,229 --> 00:04:59,349
learn by bytecode the reason you might

00:04:57,969 --> 00:05:00,909
want to learn by code is because it's an

00:04:59,349 --> 00:05:02,620
inherent part of the C Python

00:05:00,909 --> 00:05:04,090
interpreter and if you want a hack on C

00:05:02,620 --> 00:05:05,740
Python obviously you need to understand

00:05:04,090 --> 00:05:08,919
how it works one need to understand byte

00:05:05,740 --> 00:05:10,629
code so that totally makes sense there's

00:05:08,919 --> 00:05:11,650
some other reasons that people cite that

00:05:10,629 --> 00:05:13,539
I thought about and I don't think they

00:05:11,650 --> 00:05:16,900
really make that much sense so like

00:05:13,539 --> 00:05:18,099
people say you need to really understand

00:05:16,900 --> 00:05:19,240
what's going on in order to understand

00:05:18,099 --> 00:05:22,210
Python you really need to understand

00:05:19,240 --> 00:05:23,500
byte code and I guess that's kind of

00:05:22,210 --> 00:05:24,849
true it's sort of intellectually

00:05:23,500 --> 00:05:27,610
satisfying but the problem is where do

00:05:24,849 --> 00:05:29,229
you stop in order to send bytecode you

00:05:27,610 --> 00:05:31,000
have understand Python yup tons a

00:05:29,229 --> 00:05:32,860
bytecode but understand bytecode

00:05:31,000 --> 00:05:34,389
unionists and see and to really

00:05:32,860 --> 00:05:35,949
understand seeing you should understand

00:05:34,389 --> 00:05:37,000
assembler and to really understand

00:05:35,949 --> 00:05:39,219
assembler you need to understand

00:05:37,000 --> 00:05:41,199
processor microcode and understand

00:05:39,219 --> 00:05:42,610
microcode you need to understand digital

00:05:41,199 --> 00:05:44,529
logic and underneath that as transistors

00:05:42,610 --> 00:05:46,149
none Durney that is physics and

00:05:44,529 --> 00:05:47,439
electricity and understand you that is

00:05:46,149 --> 00:05:50,589
special relatively in quantum mechanics

00:05:47,439 --> 00:05:52,210
and I can guarantee you ladies and

00:05:50,589 --> 00:05:53,800
gentlemen that you can be a productive

00:05:52,210 --> 00:05:58,029
Python programmer for a long time and

00:05:53,800 --> 00:05:59,919
never understand quantum mechanics now

00:05:58,029 --> 00:06:04,419
some people like to write hand-tuned

00:05:59,919 --> 00:06:05,949
bytecode and to them I say well ok hand

00:06:04,419 --> 00:06:07,210
to bytecode means you write a little

00:06:05,949 --> 00:06:08,949
assembler and you write your own

00:06:07,210 --> 00:06:10,569
functions you skip the whole python step

00:06:08,949 --> 00:06:12,129
and you can squeeze out a couple of

00:06:10,569 --> 00:06:14,020
extra cycles this way but it's

00:06:12,129 --> 00:06:15,370
theoretically fragile although again in

00:06:14,020 --> 00:06:17,610
practice by co doesn't really change

00:06:15,370 --> 00:06:19,750
that much from in one version to another

00:06:17,610 --> 00:06:21,250
it's just that I think that you're kind

00:06:19,750 --> 00:06:22,569
of spending your time in the wrong place

00:06:21,250 --> 00:06:25,599
you're probably better off making your

00:06:22,569 --> 00:06:27,550
algorithms a little bit better finally

00:06:25,599 --> 00:06:28,539
this is the most likely reason if you're

00:06:27,550 --> 00:06:29,600
not going to be a core developer to

00:06:28,539 --> 00:06:31,640
understand a bite

00:06:29,600 --> 00:06:33,350
and this is that the bike code is the

00:06:31,640 --> 00:06:36,500
granularity at which the gill happens

00:06:33,350 --> 00:06:39,770
and which threading happens so a single

00:06:36,500 --> 00:06:41,600
statement like a equals B even that

00:06:39,770 --> 00:06:43,040
looks like a single atomic thing in

00:06:41,600 --> 00:06:45,260
Python but it's actually two pipe

00:06:43,040 --> 00:06:47,140
bytecode statements and something is

00:06:45,260 --> 00:06:50,240
complicated like a function call with

00:06:47,140 --> 00:06:52,390
parameters that have expressions or sub

00:06:50,240 --> 00:06:55,160
functions that can be many many many

00:06:52,390 --> 00:06:58,700
bytecode instructions and the thread

00:06:55,160 --> 00:07:00,860
could switch the gill could jump between

00:06:58,700 --> 00:07:02,810
threads at any point between any of

00:07:00,860 --> 00:07:05,000
those two byte code instructions so to

00:07:02,810 --> 00:07:07,510
really understand Python threading it's

00:07:05,000 --> 00:07:09,920
probably helpful to understand bytecode

00:07:07,510 --> 00:07:11,900
now in order to talk about bytecode I

00:07:09,920 --> 00:07:15,140
kind of need an example program so this

00:07:11,900 --> 00:07:16,700
is my example function in Python this is

00:07:15,140 --> 00:07:19,370
called gunk it doesn't do anything

00:07:16,700 --> 00:07:20,390
useful it's really pretty pointless it

00:07:19,370 --> 00:07:22,370
just demonstrates a bunch of things

00:07:20,390 --> 00:07:24,440
about bytecode that I want to go over so

00:07:22,370 --> 00:07:26,630
let me draw your attention to a few

00:07:24,440 --> 00:07:29,420
things about it we have one argument

00:07:26,630 --> 00:07:31,220
called a its business miller keyword it

00:07:29,420 --> 00:07:33,230
has a default of one and then we have a

00:07:31,220 --> 00:07:34,850
star args that's going to be all the

00:07:33,230 --> 00:07:37,520
remaining positional arguments stuck

00:07:34,850 --> 00:07:38,870
into a list then we have a keyword only

00:07:37,520 --> 00:07:40,820
argument name be with the default of

00:07:38,870 --> 00:07:42,740
three the body of the function we print

00:07:40,820 --> 00:07:44,540
out args we create a local variable

00:07:42,740 --> 00:07:47,030
called see we assign it a default value

00:07:44,540 --> 00:07:48,680
or initial value of none and then we

00:07:47,030 --> 00:07:50,960
return this stupid little tuple that

00:07:48,680 --> 00:07:54,470
contains a added to be and then we print

00:07:50,960 --> 00:07:56,360
outs and we add C to the end now there

00:07:54,470 --> 00:07:58,160
is a built-in disassembler that comes

00:07:56,360 --> 00:08:01,250
with python has for a long time it's

00:07:58,160 --> 00:08:03,530
called dis and this dot dis will print

00:08:01,250 --> 00:08:05,750
out the function by code for you so here

00:08:03,530 --> 00:08:08,810
is all the bytecode four discs all fit

00:08:05,750 --> 00:08:10,400
on the screen so i'll walk you through

00:08:08,810 --> 00:08:13,700
what all these columns mean this first

00:08:10,400 --> 00:08:15,710
column is the line number offset so the

00:08:13,700 --> 00:08:17,420
first four operations the first photo by

00:08:15,710 --> 00:08:19,280
codes were generated from the first line

00:08:17,420 --> 00:08:22,790
line number two and that line number is

00:08:19,280 --> 00:08:26,930
in the file rather than in the relevant

00:08:22,790 --> 00:08:27,980
to relative to the top of the or maybe

00:08:26,930 --> 00:08:30,230
it is relevant to the top of the

00:08:27,980 --> 00:08:31,910
function I can't remember anyway the

00:08:30,230 --> 00:08:34,070
second column that's the bytecode offset

00:08:31,910 --> 00:08:36,590
so the first byte code is obviously at 0

00:08:34,070 --> 00:08:38,360
that's low global the second one is at

00:08:36,590 --> 00:08:40,490
three now you may be wondering I thought

00:08:38,360 --> 00:08:42,410
I thought you said Larry that by codes

00:08:40,490 --> 00:08:43,039
were one bite and this boy this one is

00:08:42,410 --> 00:08:45,829
an offset

00:08:43,039 --> 00:08:48,529
what's going on is that by codes may or

00:08:45,829 --> 00:08:49,880
may not have an optional argument right

00:08:48,529 --> 00:08:52,310
now I want to establish this very early

00:08:49,880 --> 00:08:55,730
on I'm going to call the bytecode the op

00:08:52,310 --> 00:08:58,490
o P and this possible argument that

00:08:55,730 --> 00:09:00,319
would have is called the op argh this is

00:08:58,490 --> 00:09:01,610
the terminology used inside the Python

00:09:00,319 --> 00:09:03,440
interpreter a lot of places and so I

00:09:01,610 --> 00:09:05,720
just try and stick with it so some

00:09:03,440 --> 00:09:07,459
opcodes have an op aarde some of them

00:09:05,720 --> 00:09:09,290
don't I'll show you how to tell the

00:09:07,459 --> 00:09:10,790
difference in a minute but the first one

00:09:09,290 --> 00:09:13,100
does take a nap argh and when there is

00:09:10,790 --> 00:09:14,870
not barg it's the next two bytes in the

00:09:13,100 --> 00:09:16,930
byte code stream what you do is you take

00:09:14,870 --> 00:09:19,430
those two bytes in the byte code stream

00:09:16,930 --> 00:09:20,839
this one is the bottom eight bits this

00:09:19,430 --> 00:09:23,329
one is the top event so you shift it

00:09:20,839 --> 00:09:24,800
left to buy eight and then you or them

00:09:23,329 --> 00:09:30,519
together and that gives you a 16 bit

00:09:24,800 --> 00:09:33,620
unsigned number 02 656 65,000 that one

00:09:30,519 --> 00:09:35,120
so this third column obviously that's

00:09:33,620 --> 00:09:36,440
which bytecode you're talking about and

00:09:35,120 --> 00:09:38,990
these have been shown you symbolically

00:09:36,440 --> 00:09:40,790
they're actually just integers and then

00:09:38,990 --> 00:09:43,880
this column is showing you the op argh

00:09:40,790 --> 00:09:46,029
if there is one so the ah park is two or

00:09:43,880 --> 00:09:48,920
zero or one or three or whatever it is

00:09:46,029 --> 00:09:50,690
this column is a hint that this is

00:09:48,920 --> 00:09:55,220
showing you saying well this is kind of

00:09:50,690 --> 00:09:57,350
what the op art represents so low global

00:09:55,220 --> 00:09:59,180
is loading the global name print but the

00:09:57,350 --> 00:10:02,540
actual op code is low global zero and

00:09:59,180 --> 00:10:04,100
load fats to is loading args will go

00:10:02,540 --> 00:10:05,690
over and what all this stuff means in a

00:10:04,100 --> 00:10:07,420
minute but what I wanted to bring your

00:10:05,690 --> 00:10:10,670
attention is what I find dis

00:10:07,420 --> 00:10:14,060
dissatisfying about this i will remind

00:10:10,670 --> 00:10:17,839
you that a was positioned or keyword and

00:10:14,060 --> 00:10:19,550
i had a default of one args is this vogs

00:10:17,839 --> 00:10:21,290
array and it's always a list be was a

00:10:19,550 --> 00:10:23,600
keyword only and i had a default of 3

00:10:21,290 --> 00:10:24,889
and c was a local variable you can't

00:10:23,600 --> 00:10:26,329
tell the difference between these things

00:10:24,889 --> 00:10:28,459
there's nothing on the screen that shows

00:10:26,329 --> 00:10:30,110
you that ards contains this bar args

00:10:28,459 --> 00:10:32,839
list or that see was a local variable

00:10:30,110 --> 00:10:35,000
and a and B were parameters so there's a

00:10:32,839 --> 00:10:36,980
lot that this isn't showing you and in

00:10:35,000 --> 00:10:38,389
general there's a whole lot that this

00:10:36,980 --> 00:10:39,649
actually isn't showing you it's only

00:10:38,389 --> 00:10:41,899
showing you the bytecode really and just

00:10:39,649 --> 00:10:43,430
a little bit of extra information which

00:10:41,899 --> 00:10:44,839
is why when I was writing this talk I

00:10:43,430 --> 00:10:46,730
realized that I really had to give you

00:10:44,839 --> 00:10:48,709
the whole picture so the description of

00:10:46,730 --> 00:10:50,180
the talk is actually a little inaccurate

00:10:48,709 --> 00:10:51,860
in that I'm actually going to sort of do

00:10:50,180 --> 00:10:54,019
this holistic approach to bytecode I

00:10:51,860 --> 00:10:56,100
need to show you not only the byte codes

00:10:54,019 --> 00:10:57,959
themselves but I need to show you

00:10:56,100 --> 00:10:59,850
runtime environment that they run in AK

00:10:57,959 --> 00:11:02,550
the python vm just at a very high level

00:10:59,850 --> 00:11:03,930
just a couple of things about that but i

00:11:02,550 --> 00:11:06,120
also need to show you all the associated

00:11:03,930 --> 00:11:08,220
data and metadata that exists with the

00:11:06,120 --> 00:11:10,440
bytecode because biko doesn't run in

00:11:08,220 --> 00:11:13,649
isolation consider a sea program a

00:11:10,440 --> 00:11:15,990
modern c program c program isn't just

00:11:13,649 --> 00:11:17,759
the instructions the assembly language

00:11:15,990 --> 00:11:21,180
that make it up you also have all the

00:11:17,759 --> 00:11:22,649
static data you have the static integer

00:11:21,180 --> 00:11:25,290
that you initialize 20 or you have the

00:11:22,649 --> 00:11:26,490
strings a modern program that runs on a

00:11:25,290 --> 00:11:28,139
windowing system that's going to have

00:11:26,490 --> 00:11:30,060
all sorts of things embedded in the

00:11:28,139 --> 00:11:34,050
program it'll have dialog boxes and

00:11:30,060 --> 00:11:36,000
pointers and bitmaps and icons all that

00:11:34,050 --> 00:11:38,160
stuff is relevant and you can't

00:11:36,000 --> 00:11:40,170
understand the assembly language without

00:11:38,160 --> 00:11:41,550
understanding all of it and so there's a

00:11:40,170 --> 00:11:43,500
lot of this associated data and metadata

00:11:41,550 --> 00:11:44,730
with a byte code that you need to

00:11:43,500 --> 00:11:47,480
understand in order to understand

00:11:44,730 --> 00:11:50,370
everything and I'm going to go over all

00:11:47,480 --> 00:11:55,069
but we'll start with the bytecode so

00:11:50,370 --> 00:12:02,250
there are 101 op codes in C Python 33

00:11:55,069 --> 00:12:03,839
and each the bytecode program is I said

00:12:02,250 --> 00:12:05,519
list of bytes hear what I really meant

00:12:03,839 --> 00:12:06,689
was a byte string internally it's

00:12:05,519 --> 00:12:07,829
actually stored as a byte string but

00:12:06,689 --> 00:12:11,399
conceptual you can just think of it as

00:12:07,829 --> 00:12:15,420
an iterable of bytes each byte literally

00:12:11,399 --> 00:12:18,630
is 8-bit so an OP is a single byte 0 to

00:12:15,420 --> 00:12:19,980
255 and the op arg if it exists you take

00:12:18,630 --> 00:12:21,300
the next two instructions like I said

00:12:19,980 --> 00:12:23,160
and you shift it and you're them

00:12:21,300 --> 00:12:24,060
together how can you tell whether you

00:12:23,160 --> 00:12:26,220
have an op art for a particular

00:12:24,060 --> 00:12:28,800
instruction or not well there is a

00:12:26,220 --> 00:12:30,720
constant number it may change between

00:12:28,800 --> 00:12:32,339
implementations so you just always use a

00:12:30,720 --> 00:12:34,170
symbolic constant it's called dis not

00:12:32,339 --> 00:12:36,209
have underscore argument its current

00:12:34,170 --> 00:12:39,569
value is 90 and what this means is if

00:12:36,209 --> 00:12:42,000
the operand if the op is 90 or greater

00:12:39,569 --> 00:12:44,970
then it has an AA park and if it is less

00:12:42,000 --> 00:12:47,850
than 90 then it doesn't so in short the

00:12:44,970 --> 00:12:50,639
size of the OP is either one if it's

00:12:47,850 --> 00:12:53,579
less than 90 or three if it is nine

00:12:50,639 --> 00:12:54,870
you're great now let's talk about the vm

00:12:53,579 --> 00:12:57,449
the environment that all this stuff runs

00:12:54,870 --> 00:12:58,889
in there are three things that you

00:12:57,449 --> 00:13:00,779
really need to care about when you're

00:12:58,889 --> 00:13:03,000
talking about the Python runtime as a

00:13:00,779 --> 00:13:04,410
Python programmer there's the

00:13:03,000 --> 00:13:05,430
instruction pointer which you can

00:13:04,410 --> 00:13:07,019
manipulate again through jump

00:13:05,430 --> 00:13:08,339
instructions there's the stack we can

00:13:07,019 --> 00:13:09,360
which you manipulate through load and

00:13:08,339 --> 00:13:10,920
store

00:13:09,360 --> 00:13:12,240
there's what I call the fast locals

00:13:10,920 --> 00:13:13,709
array which you meet up with it

00:13:12,240 --> 00:13:15,240
specifically through load fast and store

00:13:13,709 --> 00:13:16,260
fast i'm going to show you the stack in

00:13:15,240 --> 00:13:19,140
a minute but i just wanted to talk about

00:13:16,260 --> 00:13:21,950
fast locals fast locals is a list it's

00:13:19,140 --> 00:13:24,420
literally a Python list and it contains

00:13:21,950 --> 00:13:27,029
all the local variables and actually all

00:13:24,420 --> 00:13:28,680
the parameters conceptually parameters

00:13:27,029 --> 00:13:30,180
are really just local variables that are

00:13:28,680 --> 00:13:31,950
pre-initialized before the function is

00:13:30,180 --> 00:13:33,570
run with funny values that somebody else

00:13:31,950 --> 00:13:38,010
gave you but they behave in every other

00:13:33,570 --> 00:13:40,829
way like parameter and to access them

00:13:38,010 --> 00:13:43,050
you call load fast and store fast to

00:13:40,829 --> 00:13:44,430
pull them in on push them onto the stack

00:13:43,050 --> 00:13:46,110
or pull them off the sack and store them

00:13:44,430 --> 00:13:50,670
away I'm it's much faster than the other

00:13:46,110 --> 00:13:52,230
mechanisms so let's talk about the stack

00:13:50,670 --> 00:13:53,940
real quick in case you've never seen the

00:13:52,230 --> 00:13:56,610
stack hopefully you have because it is a

00:13:53,940 --> 00:13:59,310
really bad diagrams but all the load

00:13:56,610 --> 00:14:00,570
instructions conceptually take something

00:13:59,310 --> 00:14:04,019
from somewhere off in memory somewhere

00:14:00,570 --> 00:14:06,029
and they take a new reference to it and

00:14:04,019 --> 00:14:08,970
put that on the top of the stack so

00:14:06,029 --> 00:14:11,430
amusingly here's a diagram our Python

00:14:08,970 --> 00:14:13,440
stack can store any arbitrary Python

00:14:11,430 --> 00:14:15,480
object so here we have a top old

00:14:13,440 --> 00:14:17,820
containing arbitrary gunk whatever it is

00:14:15,480 --> 00:14:19,709
on top of that we have a callable that

00:14:17,820 --> 00:14:21,149
represents the function print we're

00:14:19,709 --> 00:14:25,290
going to push the number 3 on top of it

00:14:21,149 --> 00:14:28,820
Wow look at that the symmetric operation

00:14:25,290 --> 00:14:30,930
is store what store does is it removes a

00:14:28,820 --> 00:14:33,540
reference from the top of the stack and

00:14:30,930 --> 00:14:35,430
stores it away in memory somewhere and

00:14:33,540 --> 00:14:36,959
if it's overriding an existing object

00:14:35,430 --> 00:14:38,100
and then the decrements the reference

00:14:36,959 --> 00:14:40,709
count of that object that's being

00:14:38,100 --> 00:14:44,390
overwritten so that would excitingly

00:14:40,709 --> 00:14:47,940
look like this pal slightly less

00:14:44,390 --> 00:14:49,980
uninteresting would be binary add binary

00:14:47,940 --> 00:14:53,610
add takes the top two things off of the

00:14:49,980 --> 00:14:56,040
stack bush and adds them together using

00:14:53,610 --> 00:14:57,600
thunder a door dunder our ad depending

00:14:56,040 --> 00:14:59,820
on whether they're playing nice today

00:14:57,600 --> 00:15:05,670
and pushes the result back onto the

00:14:59,820 --> 00:15:08,339
stack BAM 29 so now I mentioned load

00:15:05,670 --> 00:15:10,079
fast there are actually six different

00:15:08,339 --> 00:15:12,449
places that you can store and load

00:15:10,079 --> 00:15:14,339
memory from and I'm going to go over

00:15:12,449 --> 00:15:16,050
each one of them global variables and

00:15:14,339 --> 00:15:17,640
built-ins are accessed through an

00:15:16,050 --> 00:15:19,360
instruction called load global and you

00:15:17,640 --> 00:15:21,310
can also call store global

00:15:19,360 --> 00:15:22,690
the op aarde I'll tell you for each one

00:15:21,310 --> 00:15:24,279
of these all of these load instructions

00:15:22,690 --> 00:15:26,230
taken off argh so you can know which one

00:15:24,279 --> 00:15:29,890
you're talking about low global is kind

00:15:26,230 --> 00:15:33,760
of indirect the op argh is an index into

00:15:29,890 --> 00:15:37,420
an array which I'll show you of names

00:15:33,760 --> 00:15:39,160
called Co underscore names and so what

00:15:37,420 --> 00:15:41,019
you do is you take the OP bar you index

00:15:39,160 --> 00:15:43,450
into that names array which is an array

00:15:41,019 --> 00:15:44,829
of strings and whatever that string is

00:15:43,450 --> 00:15:47,079
that's the thing that you're going to

00:15:44,829 --> 00:15:49,540
load or store so that's what low global

00:15:47,079 --> 00:15:52,060
zero meant print because print was the

00:15:49,540 --> 00:15:55,660
zeroth string in the names array in my

00:15:52,060 --> 00:15:57,190
stupid little function gunk fast locals

00:15:55,660 --> 00:15:58,750
as i mentioned that's load fast and

00:15:57,190 --> 00:16:01,899
store fast and the ah park is just an

00:15:58,750 --> 00:16:04,420
index into that load faster ray locals

00:16:01,899 --> 00:16:06,310
AKA slow locals this was the original

00:16:04,420 --> 00:16:08,350
mechanism for local variables in python

00:16:06,310 --> 00:16:09,640
in the very early days it wasn't long it

00:16:08,350 --> 00:16:13,779
was less than it was a couple of months

00:16:09,640 --> 00:16:16,779
before we don't add adults but slow

00:16:13,779 --> 00:16:19,870
locals are just a dict that's attached

00:16:16,779 --> 00:16:21,390
to the function when it runs and this is

00:16:19,870 --> 00:16:26,769
still the mechanisms that's used for

00:16:21,390 --> 00:16:30,010
class variables for excuse me members

00:16:26,769 --> 00:16:32,019
class members for module level of things

00:16:30,010 --> 00:16:34,750
and four variables inside of them eval

00:16:32,019 --> 00:16:37,360
and you load and store those using load

00:16:34,750 --> 00:16:40,570
name and again the index here is an

00:16:37,360 --> 00:16:42,190
index into the names array const you can

00:16:40,570 --> 00:16:45,370
load with load const and there is just a

00:16:42,190 --> 00:16:46,920
table it's actually a couple of constant

00:16:45,370 --> 00:16:50,140
values associated with the function

00:16:46,920 --> 00:16:51,610
called co underscore consts there is no

00:16:50,140 --> 00:16:55,089
store const otherwise they wouldn't be

00:16:51,610 --> 00:16:56,470
very good consts and distort load and

00:16:55,089 --> 00:17:00,190
store object attributes there's load

00:16:56,470 --> 00:17:01,930
adder again the op arg is in the Nixon

00:17:00,190 --> 00:17:03,839
to the names racing on the name of the

00:17:01,930 --> 00:17:06,220
argument that you're going to load and

00:17:03,839 --> 00:17:07,569
you have to push the object onto the

00:17:06,220 --> 00:17:09,429
stack before you call load adder and

00:17:07,569 --> 00:17:12,910
finally there's the really crazy one

00:17:09,429 --> 00:17:14,679
fluid and save cell variables you use

00:17:12,910 --> 00:17:17,140
load dereference toward a ref now what

00:17:14,679 --> 00:17:18,579
our cell variables I'll show you in the

00:17:17,140 --> 00:17:20,620
next slide I just want to mention for

00:17:18,579 --> 00:17:22,689
now that load de Graaff once more uses

00:17:20,620 --> 00:17:24,760
the names array marques our index into

00:17:22,689 --> 00:17:26,740
the names right so what our cell

00:17:24,760 --> 00:17:28,419
variables actually two things I got to

00:17:26,740 --> 00:17:30,430
talk about here free variables and sell

00:17:28,419 --> 00:17:32,410
variables consider

00:17:30,430 --> 00:17:34,630
the function before you we have a

00:17:32,410 --> 00:17:36,430
function called foo inside we declare

00:17:34,630 --> 00:17:38,830
two variables a and B these are local

00:17:36,430 --> 00:17:42,310
variables and then we declare a nested

00:17:38,830 --> 00:17:45,430
function bar with non-local be this is

00:17:42,310 --> 00:17:48,670
everything we need now a is a local

00:17:45,430 --> 00:17:50,650
variable B is a local variable but a

00:17:48,670 --> 00:17:54,370
specific kind of local variable called a

00:17:50,650 --> 00:17:57,490
cell variable a cell variable is a local

00:17:54,370 --> 00:18:00,160
variable that is referred to in a nested

00:17:57,490 --> 00:18:01,360
function and that's the function could

00:18:00,160 --> 00:18:04,810
be a closure it could just be a normal

00:18:01,360 --> 00:18:08,740
message function like this inside the

00:18:04,810 --> 00:18:10,300
bar b is a free variable free variable

00:18:08,740 --> 00:18:13,210
is actually a term from compilers it

00:18:10,300 --> 00:18:14,650
means a variable that's defined in some

00:18:13,210 --> 00:18:18,100
other basic block something like that in

00:18:14,650 --> 00:18:22,180
Python specifically a free variable is a

00:18:18,100 --> 00:18:26,260
variable that was defined in an outer

00:18:22,180 --> 00:18:28,960
enclosing function there's some

00:18:26,260 --> 00:18:30,670
mechanism involved in managing cell and

00:18:28,960 --> 00:18:32,020
free variables that honestly I don't

00:18:30,670 --> 00:18:34,210
understand so I'm really not going to

00:18:32,020 --> 00:18:35,140
talk about them very much you can go

00:18:34,210 --> 00:18:36,670
your entire life without ever

00:18:35,140 --> 00:18:39,820
understanding them unless you're writing

00:18:36,670 --> 00:18:41,020
a python vm yourself anyway i don't

00:18:39,820 --> 00:18:42,250
really have time for more information

00:18:41,020 --> 00:18:44,800
about that because I'm already one

00:18:42,250 --> 00:18:47,200
running late probably so finally we're

00:18:44,800 --> 00:18:49,240
going to crack open the gunk object the

00:18:47,200 --> 00:18:51,910
gun callable and start examining the

00:18:49,240 --> 00:18:54,700
guts inside first of all gunk is of type

00:18:51,910 --> 00:18:56,080
function type in the types module and it

00:18:54,700 --> 00:18:57,460
shows up the referee is just class

00:18:56,080 --> 00:19:00,130
function you don't even get to see the

00:18:57,460 --> 00:19:03,280
name and if we look inside the gunk

00:19:00,130 --> 00:19:05,830
object we see a whole bunch of stuff the

00:19:03,280 --> 00:19:07,420
stuff that I made bold and large there

00:19:05,830 --> 00:19:10,600
is the stuff that's relevant

00:19:07,420 --> 00:19:12,010
specifically to function objects but

00:19:10,600 --> 00:19:13,900
there's one in particular that's really

00:19:12,010 --> 00:19:15,310
interesting here that's dunder code

00:19:13,900 --> 00:19:17,520
right in the middle of the second line

00:19:15,310 --> 00:19:19,780
there Thunder code is awfully important

00:19:17,520 --> 00:19:21,700
that's the code object which I'm going

00:19:19,780 --> 00:19:24,610
to break apart on this slide here so

00:19:21,700 --> 00:19:27,010
type of gunk Thunder code that is a type

00:19:24,610 --> 00:19:31,810
code type it is of class code in the

00:19:27,010 --> 00:19:33,910
wrapper and if we examine that we see a

00:19:31,810 --> 00:19:36,280
whole bunch of stuff again I made bold

00:19:33,910 --> 00:19:37,960
and large for your viewing pleasure it

00:19:36,280 --> 00:19:39,280
all starts with co underscore and this

00:19:37,960 --> 00:19:42,070
is all the stuff that's relevant to code

00:19:39,280 --> 00:19:43,440
options so every function object points

00:19:42,070 --> 00:19:44,909
to a code object and you need

00:19:43,440 --> 00:19:46,620
both of them in order to have a real

00:19:44,909 --> 00:19:49,620
callable that's implemented in Python

00:19:46,620 --> 00:19:51,389
this gives direct rise the question why

00:19:49,620 --> 00:19:52,769
I bother to have both of them at all why

00:19:51,389 --> 00:19:54,179
not if we're going to have both

00:19:52,769 --> 00:19:55,740
functionalities and code objects why not

00:19:54,179 --> 00:19:58,340
just fold the code object into the

00:19:55,740 --> 00:20:00,450
function object and just have one object

00:19:58,340 --> 00:20:02,820
now the first thing I'll point out to

00:20:00,450 --> 00:20:04,620
you is that code objects are Martha

00:20:02,820 --> 00:20:06,059
label and function objects are not

00:20:04,620 --> 00:20:11,309
marketable now what the hell does that

00:20:06,059 --> 00:20:12,899
mean marshall is a module in the Python

00:20:11,309 --> 00:20:15,120
standard library it's kind of like

00:20:12,899 --> 00:20:18,750
pickle it's a binary serialization

00:20:15,120 --> 00:20:20,820
protocol but you should never use it

00:20:18,750 --> 00:20:22,860
because it's awfully fragile it's really

00:20:20,820 --> 00:20:25,620
only good for one thing and that is it

00:20:22,860 --> 00:20:28,620
can serialize code objects and it's used

00:20:25,620 --> 00:20:31,409
for not pyc files so a pyc file

00:20:28,620 --> 00:20:33,809
literally in Python 303 a little oby see

00:20:31,409 --> 00:20:37,110
file literally looks like this there are

00:20:33,809 --> 00:20:39,179
4 12 bytes at the top which are 3 4 byte

00:20:37,110 --> 00:20:40,919
integers the first 4 byte integer is a

00:20:39,179 --> 00:20:43,649
magic value that says this was compiled

00:20:40,919 --> 00:20:45,629
by Python 3 2 320 the second four bytes

00:20:43,649 --> 00:20:47,490
is the date and time stamp of the odd py

00:20:45,629 --> 00:20:49,559
file at the time the py sifu was

00:20:47,490 --> 00:20:51,149
compiled and the third is the size of

00:20:49,559 --> 00:20:52,679
the file at the time it was compiled and

00:20:51,149 --> 00:20:54,600
actually by the way that size field

00:20:52,679 --> 00:20:56,070
that's a new one in Python 323 previous

00:20:54,600 --> 00:20:59,580
versions of Python just had eight bytes

00:20:56,070 --> 00:21:01,350
there after those 12 bytes is a single

00:20:59,580 --> 00:21:06,690
see realized code object that represents

00:21:01,350 --> 00:21:07,980
the function that is the module and so

00:21:06,690 --> 00:21:10,350
you need to be able to see relies code

00:21:07,980 --> 00:21:13,289
objects but function objects contain

00:21:10,350 --> 00:21:16,139
live data that can't be so realize with

00:21:13,289 --> 00:21:17,700
Marshall which will I'll talk about in a

00:21:16,139 --> 00:21:19,919
minute but it could be almost anything

00:21:17,700 --> 00:21:22,049
in there so that's what I thought the

00:21:19,919 --> 00:21:23,220
reason of it was just as an example here

00:21:22,049 --> 00:21:26,100
are some fields on the function object

00:21:23,220 --> 00:21:28,769
that contain references to objects that

00:21:26,100 --> 00:21:30,269
could theoretically not be marshal so I

00:21:28,769 --> 00:21:32,100
thought that was the reason i asked

00:21:30,269 --> 00:21:34,500
tweto about and he said no actually

00:21:32,100 --> 00:21:35,789
that's not the reason this different

00:21:34,500 --> 00:21:37,620
this distinction between the function

00:21:35,789 --> 00:21:39,929
optional code object existed before you

00:21:37,620 --> 00:21:41,940
could even marshal before you could have

00:21:39,929 --> 00:21:43,730
pyc files it's from very early in Python

00:21:41,940 --> 00:21:46,019
and the reason is nested functions

00:21:43,730 --> 00:21:50,519
consider on the previous slide we have

00:21:46,019 --> 00:21:52,080
that foo with the bar inside every time

00:21:50,519 --> 00:21:53,429
do you run the function foo it's going

00:21:52,080 --> 00:21:55,590
to create a new function object

00:21:53,429 --> 00:21:56,790
representing bar and if it had to

00:21:55,590 --> 00:21:58,860
populate everything that

00:21:56,790 --> 00:22:01,950
inside that that be well kind of slow on

00:21:58,860 --> 00:22:03,090
a computer in 1993 so it's a lot faster

00:22:01,950 --> 00:22:04,530
to take all the stuff that doesn't

00:22:03,090 --> 00:22:06,120
change they cannot change because it's

00:22:04,530 --> 00:22:08,010
immutable and stick it in one object

00:22:06,120 --> 00:22:09,390
called the code object and all the stuff

00:22:08,010 --> 00:22:11,070
that does change lives in the other one

00:22:09,390 --> 00:22:12,630
the function object and we just create a

00:22:11,070 --> 00:22:14,190
new function object every time you bind

00:22:12,630 --> 00:22:16,980
it so it was a speed and size

00:22:14,190 --> 00:22:20,360
optimization from a long time ago so

00:22:16,980 --> 00:22:23,520
back to cracking apart the code object

00:22:20,360 --> 00:22:24,810
code co underscore code this is what

00:22:23,520 --> 00:22:28,400
you've all been waiting for ladies and

00:22:24,810 --> 00:22:31,170
gentlemen this is the bike code for gunk

00:22:28,400 --> 00:22:32,490
isn't that great isn't that readable so

00:22:31,170 --> 00:22:35,490
that's the byte string and that really

00:22:32,490 --> 00:22:37,140
is it it's a little bit more readable or

00:22:35,490 --> 00:22:40,430
a little bit less unreadable in this

00:22:37,140 --> 00:22:43,230
form I'll I'll give you a couple hints

00:22:40,430 --> 00:22:45,660
every number that is greater than 10 is

00:22:43,230 --> 00:22:47,400
an OP code as it happens in this

00:22:45,660 --> 00:22:49,560
particular function every number that is

00:22:47,400 --> 00:22:52,800
less than 10 is part of a 2-byte op

00:22:49,560 --> 00:22:54,630
aarde sequence so 116 is low global and

00:22:52,800 --> 00:22:55,860
then those two zeros of course is going

00:22:54,630 --> 00:22:58,530
to combine together to be zero so that's

00:22:55,860 --> 00:23:01,020
low global zero the next 11 24 that's

00:22:58,530 --> 00:23:02,100
load fast the the first byte is low

00:23:01,020 --> 00:23:04,350
order bite so that's going to be load

00:23:02,100 --> 00:23:08,510
fast too then we have call function

00:23:04,350 --> 00:23:10,560
that's 131 the last one is return value

00:23:08,510 --> 00:23:13,260
it's still not terribly readable in this

00:23:10,560 --> 00:23:16,140
format but i'm going to show you the

00:23:13,260 --> 00:23:18,870
simplest possible assembler in python

00:23:16,140 --> 00:23:20,250
now i need to call in to disk to get

00:23:18,870 --> 00:23:22,560
some values that I can't get anywhere

00:23:20,250 --> 00:23:25,800
else but I can do it all on one screen

00:23:22,560 --> 00:23:27,510
and here it is I can't remember if I go

00:23:25,800 --> 00:23:31,050
over these do I have individual yes I do

00:23:27,510 --> 00:23:32,520
okay so our disassembler first it prints

00:23:31,050 --> 00:23:34,680
death than the name of the function and

00:23:32,520 --> 00:23:37,590
the coal and so it looks all pretty I

00:23:34,680 --> 00:23:40,980
pull out the the byte code from the code

00:23:37,590 --> 00:23:42,180
object inside of the callable I have my

00:23:40,980 --> 00:23:43,980
instruction pointer it's going to be 0

00:23:42,180 --> 00:23:47,040
and until I hit the end of the program I

00:23:43,980 --> 00:23:48,990
pull out the bytecode if it's greater

00:23:47,040 --> 00:23:50,780
than if it's less than 90 then I don't

00:23:48,990 --> 00:23:54,900
have an OP argh and I go forward by one

00:23:50,780 --> 00:23:56,550
else I pull out the OP argh assemble it

00:23:54,900 --> 00:23:59,520
properly and I advanced by three and

00:23:56,550 --> 00:24:01,860
then I look up the AH part in this dis

00:23:59,520 --> 00:24:05,640
module this dis da top name that's a map

00:24:01,860 --> 00:24:07,860
mapping integers two strings that are

00:24:05,640 --> 00:24:09,840
the symbolic by code names and I print

00:24:07,860 --> 00:24:10,480
up the op art following I just do that

00:24:09,840 --> 00:24:13,059
in the loop

00:24:10,480 --> 00:24:16,419
and if I run that on disassembled I get

00:24:13,059 --> 00:24:17,620
this so it's not terribly readable but

00:24:16,419 --> 00:24:20,169
it's eighty percent of what this is

00:24:17,620 --> 00:24:21,940
giving you I assert soloed 50 lodi 20

00:24:20,169 --> 00:24:24,160
again i'll point out everything takes

00:24:21,940 --> 00:24:26,620
not bark except for pop top binary ad

00:24:24,160 --> 00:24:29,110
and that's all they fit on them on the

00:24:26,620 --> 00:24:31,710
screen anyway so i'll show you more

00:24:29,110 --> 00:24:34,480
useful this is I'm we're in a little bit

00:24:31,710 --> 00:24:35,650
back to the code object now this is

00:24:34,480 --> 00:24:37,690
going to be a little bit of a slog I

00:24:35,650 --> 00:24:39,130
think I have like five or six slides in

00:24:37,690 --> 00:24:41,020
a row that are just about fields in the

00:24:39,130 --> 00:24:42,820
OP in the function and code objects so

00:24:41,020 --> 00:24:46,059
strap in it's going to be a

00:24:42,820 --> 00:24:48,790
heart-pounding ride just about the

00:24:46,059 --> 00:24:50,650
number of arguments this is positional

00:24:48,790 --> 00:24:53,470
arguments so gunk had one position

00:24:50,650 --> 00:24:57,429
argument that was a it had one keyword

00:24:53,470 --> 00:24:59,770
only argument and that was be the total

00:24:57,429 --> 00:25:01,990
number of local variables is for i'm so

00:24:59,770 --> 00:25:05,530
i'll remind you all the arguments and

00:25:01,990 --> 00:25:08,260
all the locals go into this so and

00:25:05,530 --> 00:25:10,360
there's actually a matching a list of

00:25:08,260 --> 00:25:12,309
their names called CEO andrew carve our

00:25:10,360 --> 00:25:16,450
names you can see what goes into it a B

00:25:12,309 --> 00:25:21,250
args and see so the locals contains

00:25:16,450 --> 00:25:22,840
these things in this order all keyword

00:25:21,250 --> 00:25:24,580
or positional arguments in the order

00:25:22,840 --> 00:25:26,830
they were declared followed by all

00:25:24,580 --> 00:25:29,830
keyword only arguments in the order they

00:25:26,830 --> 00:25:32,380
were declared followed by the star ARBs

00:25:29,830 --> 00:25:33,940
variable parameter if you have one

00:25:32,380 --> 00:25:35,710
followed by the starts to our keyword

00:25:33,940 --> 00:25:38,710
arguments a parameter if you have one

00:25:35,710 --> 00:25:40,750
followed by all local variables in the

00:25:38,710 --> 00:25:41,950
order they were declared it gets

00:25:40,750 --> 00:25:43,360
reordered here from the way that you

00:25:41,950 --> 00:25:45,549
necessarily put it inside the thing

00:25:43,360 --> 00:25:51,520
because that's the order that Python

00:25:45,549 --> 00:25:53,590
overrides on it default values for the

00:25:51,520 --> 00:25:56,559
function are not a lot actually bound

00:25:53,590 --> 00:25:58,600
until the there can be calculated at

00:25:56,559 --> 00:26:02,919
runtime you can have the default for a

00:25:58,600 --> 00:26:05,590
function be at uppal or a list or a dict

00:26:02,919 --> 00:26:07,210
or the result of a function call so it

00:26:05,590 --> 00:26:08,380
can't be computed statically so it's not

00:26:07,210 --> 00:26:09,460
part of the function not but it's not

00:26:08,380 --> 00:26:13,240
part of the code object is part of the

00:26:09,460 --> 00:26:15,730
function object so defaults is for

00:26:13,240 --> 00:26:18,100
positional parameters and what you do

00:26:15,730 --> 00:26:19,720
here is this just has enough of defaults

00:26:18,100 --> 00:26:22,150
for the ones that actually had default

00:26:19,720 --> 00:26:23,350
so if an example you had a function that

00:26:22,150 --> 00:26:25,600
had five position

00:26:23,350 --> 00:26:28,360
and the last three of them had default

00:26:25,600 --> 00:26:30,039
values then you gunk defaults would be a

00:26:28,360 --> 00:26:31,539
couple of three things and you just take

00:26:30,039 --> 00:26:32,770
and sort of shift it right to match the

00:26:31,539 --> 00:26:34,809
last positional parameter and you work

00:26:32,770 --> 00:26:38,020
your way backwards a little bit simpler

00:26:34,809 --> 00:26:40,450
is kwd Falls this is addicting keyword

00:26:38,020 --> 00:26:45,520
only parameters to their defaults and

00:26:40,450 --> 00:26:47,049
again it's on the function object the

00:26:45,520 --> 00:26:49,179
tables that I've referred to a minute

00:26:47,049 --> 00:26:50,530
ago so co underscore names this is the

00:26:49,179 --> 00:26:54,010
one that all of those different opcodes

00:26:50,530 --> 00:26:56,679
referred into so gunk only had one name

00:26:54,010 --> 00:26:58,539
it only used low global and that was

00:26:56,679 --> 00:27:00,010
print this none that appears here is

00:26:58,539 --> 00:27:02,890
actually just left over garbage from

00:27:00,010 --> 00:27:04,419
tokenizing there is no at no point will

00:27:02,890 --> 00:27:07,980
the Python interpreter actually refer to

00:27:04,419 --> 00:27:10,450
that coo underscore names index one I

00:27:07,980 --> 00:27:11,919
asked and they were just like yeah it's

00:27:10,450 --> 00:27:13,630
just leftover stuff it doesn't hurt

00:27:11,919 --> 00:27:18,970
anything we never bothered to fix it

00:27:13,630 --> 00:27:20,350
whatever we're pretty lazy I guess see I

00:27:18,970 --> 00:27:22,870
would underscore const this is another

00:27:20,350 --> 00:27:25,750
couple and this has the constant values

00:27:22,870 --> 00:27:27,610
that are accessed by load conf again

00:27:25,750 --> 00:27:30,520
gunk only had one which was none and so

00:27:27,610 --> 00:27:32,080
it's empty someone told me that every

00:27:30,520 --> 00:27:33,730
function always has a reference none

00:27:32,080 --> 00:27:35,169
even if you never refer to none inside

00:27:33,730 --> 00:27:41,530
of the function you just it just always

00:27:35,169 --> 00:27:43,480
adds one line numbers Python only uses

00:27:41,530 --> 00:27:45,850
line numbers when it's calculating trace

00:27:43,480 --> 00:27:46,840
backs or when you're in the debugger so

00:27:45,850 --> 00:27:49,030
this doesn't generally have to be a

00:27:46,840 --> 00:27:50,710
really performing thing so python has

00:27:49,030 --> 00:27:52,929
optimized very heavily for speed as

00:27:50,710 --> 00:27:55,179
opposed to size here makes you mean the

00:27:52,929 --> 00:27:57,700
opposite I'm speaking very quickly it's

00:27:55,179 --> 00:27:59,320
optimized for size not speed so it's a

00:27:57,700 --> 00:28:01,210
really inconvenient format there are two

00:27:59,320 --> 00:28:02,679
things that are relevant Co underscore

00:28:01,210 --> 00:28:04,990
first line number that the first line

00:28:02,679 --> 00:28:07,330
number in the file where the function

00:28:04,990 --> 00:28:09,400
started and then there is this really

00:28:07,330 --> 00:28:11,470
crazy LNO tab everybody hates this thing

00:28:09,400 --> 00:28:12,549
so again it's another byte string and

00:28:11,470 --> 00:28:14,740
it's completely unreadable in this

00:28:12,549 --> 00:28:16,929
format slightly better is this way the

00:28:14,740 --> 00:28:21,250
way that alano tab works is it is pairs

00:28:16,929 --> 00:28:23,740
of bytes that represent the Delta in the

00:28:21,250 --> 00:28:28,890
bytecode offset and the Delta in the

00:28:23,740 --> 00:28:32,590
line number offset and yeah yeah sorry

00:28:28,890 --> 00:28:34,540
and there are some stringent rules on

00:28:32,590 --> 00:28:36,130
how you have to compute them if you go

00:28:34,540 --> 00:28:37,390
over to a 55 and one li

00:28:36,130 --> 00:28:39,220
then you have to do something funny on

00:28:37,390 --> 00:28:40,300
and on and on it goes like I said it's a

00:28:39,220 --> 00:28:43,810
headache hopefully you'll never have to

00:28:40,300 --> 00:28:46,690
deal with it metadata associated with

00:28:43,810 --> 00:28:49,990
the function so Global's this is a

00:28:46,690 --> 00:28:53,170
reference to the module where the

00:28:49,990 --> 00:28:54,550
function was defined so that's how when

00:28:53,170 --> 00:28:56,140
you call a function and the function

00:28:54,550 --> 00:28:58,090
refers to a global variable it can

00:28:56,140 --> 00:29:00,280
always find it because it carries around

00:28:58,090 --> 00:29:04,480
its reference to its Global's dictionary

00:29:00,280 --> 00:29:07,210
wherever it goes gunk got modules just

00:29:04,480 --> 00:29:08,830
name the module code file name that's

00:29:07,210 --> 00:29:10,870
the name of the file where the function

00:29:08,830 --> 00:29:12,900
was defined i typed gunk into the

00:29:10,870 --> 00:29:15,250
interactive prompts so I got standard in

00:29:12,900 --> 00:29:17,800
co underscore name that's the name of

00:29:15,250 --> 00:29:20,890
the function Co underscore flags this is

00:29:17,800 --> 00:29:23,110
a bit field the number 71 is inscrutable

00:29:20,890 --> 00:29:25,810
and you'll see it a lot this is one of

00:29:23,110 --> 00:29:28,780
the least documented parts of functions

00:29:25,810 --> 00:29:30,400
and a byte code I'll go over what that

00:29:28,780 --> 00:29:35,110
means in a minute but you're not going

00:29:30,400 --> 00:29:37,870
to be happy and finally Co underscore

00:29:35,110 --> 00:29:39,910
stack size this is the the depth of the

00:29:37,870 --> 00:29:41,650
stack that will ever happen when this

00:29:39,910 --> 00:29:43,030
function is running Python pre

00:29:41,650 --> 00:29:45,010
calculates this in advance for two

00:29:43,030 --> 00:29:46,090
reasons one it allows you to predict in

00:29:45,010 --> 00:29:47,530
advance whether we're going to blow the

00:29:46,090 --> 00:29:49,810
stack by calling the next function and

00:29:47,530 --> 00:29:51,780
two it actually pre allocates the stack

00:29:49,810 --> 00:29:54,910
every time it calls a function and

00:29:51,780 --> 00:29:56,890
surprisingly it actually it does one

00:29:54,910 --> 00:29:58,210
allocation to get everything it needs a

00:29:56,890 --> 00:30:00,640
what that's called a frame object

00:29:58,210 --> 00:30:02,770
internally that represents the call the

00:30:00,640 --> 00:30:04,870
the the nested call on the on the stack

00:30:02,770 --> 00:30:06,820
and that frame object at the end has

00:30:04,870 --> 00:30:08,500
space for all the local variables and

00:30:06,820 --> 00:30:10,810
parameters followed by the entire stack

00:30:08,500 --> 00:30:15,280
in a variable amusingly called f

00:30:10,810 --> 00:30:17,350
underscore locals plus I think we're

00:30:15,280 --> 00:30:20,580
this is the last slide on all these

00:30:17,350 --> 00:30:22,660
fields thank goodness so annotations

00:30:20,580 --> 00:30:24,520
gunk doesn't have any annotations so

00:30:22,660 --> 00:30:25,870
this is empty but this is where

00:30:24,520 --> 00:30:27,940
annotations will be stored you remember

00:30:25,870 --> 00:30:29,760
Python 3 has that colon there's a type

00:30:27,940 --> 00:30:34,120
annotations for parameters on a function

00:30:29,760 --> 00:30:36,250
and it's in maps names to values and

00:30:34,120 --> 00:30:38,230
it's on again it's it's bound at a

00:30:36,250 --> 00:30:40,180
binding time so any can have arbitrary

00:30:38,230 --> 00:30:42,430
values in it so it's in a function

00:30:40,180 --> 00:30:45,100
object not the code object closure if

00:30:42,430 --> 00:30:47,559
gunk was a closure this would be an

00:30:45,100 --> 00:30:50,379
object but it's not so it's none

00:30:47,559 --> 00:30:53,409
cell bars and free VARs if gunk was a

00:30:50,379 --> 00:30:55,120
nested function or contained a nested

00:30:53,409 --> 00:30:57,370
function one of these might be empty but

00:30:55,120 --> 00:30:59,080
they're not like I said I'm not going to

00:30:57,370 --> 00:31:01,360
talk about four cell bars in free virus

00:30:59,080 --> 00:31:04,480
so I want to skip them now as I

00:31:01,360 --> 00:31:07,029
mentioned before modules in Python are

00:31:04,480 --> 00:31:08,649
callable objects consider that you just

00:31:07,029 --> 00:31:10,720
have a file and it contains code in it

00:31:08,649 --> 00:31:13,120
any time you have the ability to run

00:31:10,720 --> 00:31:14,679
code in Python you have a callable and

00:31:13,120 --> 00:31:17,259
anytime you have a call will you have a

00:31:14,679 --> 00:31:18,340
function and you have a code object so I

00:31:17,259 --> 00:31:19,990
think it's really interesting that

00:31:18,340 --> 00:31:21,070
modules are themselves cobbles which

00:31:19,990 --> 00:31:23,499
means that they're actually functions

00:31:21,070 --> 00:31:25,059
now what would a module look like if it

00:31:23,499 --> 00:31:27,700
was just a normal callable thing well

00:31:25,059 --> 00:31:29,289
actually it looked pretty generic it

00:31:27,700 --> 00:31:30,879
would a module doesn't take any

00:31:29,289 --> 00:31:33,129
parameters it would just have all the

00:31:30,879 --> 00:31:34,509
code inside it would use load name and

00:31:33,129 --> 00:31:37,840
store name it would never use load fast

00:31:34,509 --> 00:31:39,580
or fast and I will tell you that every

00:31:37,840 --> 00:31:41,259
function in Python always return

00:31:39,580 --> 00:31:42,580
something if you don't explicitly return

00:31:41,259 --> 00:31:45,159
something then you always return none

00:31:42,580 --> 00:31:47,230
and so modules don't return anything

00:31:45,159 --> 00:31:48,700
interesting there's no explicit return

00:31:47,230 --> 00:31:50,230
allowed in them and so they always just

00:31:48,700 --> 00:31:53,169
return none so you'll see this load

00:31:50,230 --> 00:31:55,899
constant on return value you'll see that

00:31:53,169 --> 00:31:58,419
a lot now by the same token the modules

00:31:55,899 --> 00:32:01,149
or call bolts classes or call bowls this

00:31:58,419 --> 00:32:03,039
is a little bit more complicated so

00:32:01,149 --> 00:32:04,779
first of all classes actually do take a

00:32:03,039 --> 00:32:06,610
parameter it's called Dunder locals I'll

00:32:04,779 --> 00:32:07,990
talk about that in a minute I kind of

00:32:06,610 --> 00:32:09,249
want to go from the bottom up here just

00:32:07,990 --> 00:32:10,990
because it gets from least to most

00:32:09,249 --> 00:32:13,360
complicated like what the hell's going

00:32:10,990 --> 00:32:15,549
on so again at the bottom we have a

00:32:13,360 --> 00:32:18,009
return none because classes don't return

00:32:15,549 --> 00:32:21,820
anything either they're not functions in

00:32:18,009 --> 00:32:23,320
the the strictest sense above that we

00:32:21,820 --> 00:32:24,730
have this load name store named load con

00:32:23,320 --> 00:32:27,940
store name those are setting up two

00:32:24,730 --> 00:32:29,919
attributes of the class that's done your

00:32:27,940 --> 00:32:31,720
module and under cual name and then

00:32:29,919 --> 00:32:34,210
above that we have this load fat 0 and

00:32:31,720 --> 00:32:37,539
store locals now what is that well load

00:32:34,210 --> 00:32:39,850
fast 0 I again remind you that's going

00:32:37,539 --> 00:32:42,039
to be loading either a parameter or a

00:32:39,850 --> 00:32:43,899
local variable in this case there's only

00:32:42,039 --> 00:32:45,369
one and it's 0 it's going to be the

00:32:43,899 --> 00:32:46,960
first parameter which is local so this

00:32:45,369 --> 00:32:49,179
is taking dunder locals and pushing on

00:32:46,960 --> 00:32:52,299
the stack then it call store locals what

00:32:49,179 --> 00:32:54,369
is store locals sort of locals is one of

00:32:52,299 --> 00:32:56,799
those crazy super pythonic things that's

00:32:54,369 --> 00:32:58,990
for the community the interpreter this

00:32:56,799 --> 00:33:00,070
is for a mechanism that was added in

00:32:58,990 --> 00:33:03,510
Python

00:33:00,070 --> 00:33:07,600
re called Thunder prepare it allows a

00:33:03,510 --> 00:33:10,660
metaclass so it used to be that a python

00:33:07,600 --> 00:33:11,860
class the client under was always

00:33:10,660 --> 00:33:13,630
a dick it was a real honest-to-goodness

00:33:11,860 --> 00:33:15,400
 and there are people who said I

00:33:13,630 --> 00:33:17,710
want to have a dick like object there I

00:33:15,400 --> 00:33:19,180
want to do exciting things I don't know

00:33:17,710 --> 00:33:20,710
what the hell you would use this for but

00:33:19,180 --> 00:33:22,480
it was important enough that it happened

00:33:20,710 --> 00:33:25,330
in Python 3 so there's this mechanism in

00:33:22,480 --> 00:33:27,370
a metaclass it's something called Dunder

00:33:25,330 --> 00:33:29,650
prepare that allows you to substitute

00:33:27,370 --> 00:33:31,780
your own dick like object for the real

00:33:29,650 --> 00:33:34,000
class you know when you create a

00:33:31,780 --> 00:33:35,920
class and this is how it gets there this

00:33:34,000 --> 00:33:38,200
dick like object or whatever it is is

00:33:35,920 --> 00:33:40,300
passed in to the class under in the

00:33:38,200 --> 00:33:45,700
parameter called locals and we store it

00:33:40,300 --> 00:33:47,050
into the class object there boy that was

00:33:45,700 --> 00:33:50,290
complicated when I had to figure that

00:33:47,050 --> 00:33:53,200
out to write these slides so now that's

00:33:50,290 --> 00:33:55,270
what the function looks like to declare

00:33:53,200 --> 00:33:56,440
the class but when you bind the class at

00:33:55,270 --> 00:33:58,210
runtime there's also a little bit of

00:33:56,440 --> 00:34:00,390
code day after run so this is what

00:33:58,210 --> 00:34:03,970
happens inside of the module let's say

00:34:00,390 --> 00:34:06,820
when you declare the class and this is

00:34:03,970 --> 00:34:09,520
what turns the class into the attribute

00:34:06,820 --> 00:34:11,410
that you refer to so the previous thing

00:34:09,520 --> 00:34:14,530
was at compile time this is at class

00:34:11,410 --> 00:34:16,240
binding time I kind of I really have to

00:34:14,530 --> 00:34:18,340
do this from the top down but it's just

00:34:16,240 --> 00:34:21,100
weird so first of all load build classes

00:34:18,340 --> 00:34:24,550
in those super pythonic only relevant to

00:34:21,100 --> 00:34:26,140
the Python implementation opcodes called

00:34:24,550 --> 00:34:28,510
load built class what that does is it

00:34:26,140 --> 00:34:30,430
pushes onto the stack a reference to a

00:34:28,510 --> 00:34:33,120
callable object called build underscore

00:34:30,430 --> 00:34:35,740
class its dunder build underscore class

00:34:33,120 --> 00:34:37,150
I'll get into that in a minute but just

00:34:35,740 --> 00:34:39,460
for now we'll just imagine that lurking

00:34:37,150 --> 00:34:42,520
at the bottom of the stack about that we

00:34:39,460 --> 00:34:44,530
push two things the code object that

00:34:42,520 --> 00:34:46,510
represents the class so the the contents

00:34:44,530 --> 00:34:48,700
of the class if it was a function that

00:34:46,510 --> 00:34:49,930
lives in that code object and then the

00:34:48,700 --> 00:34:52,870
name of the class and then we call this

00:34:49,930 --> 00:34:55,480
make function 0 make function takes

00:34:52,870 --> 00:34:58,600
these two things a code object and its

00:34:55,480 --> 00:35:02,650
name and creates a function object what

00:34:58,600 --> 00:35:04,570
is this 0 represent the OP arg is a bit

00:35:02,650 --> 00:35:08,170
field of three things combined together

00:35:04,570 --> 00:35:10,030
it's the number of annotations the

00:35:08,170 --> 00:35:11,620
number of defaults for positional

00:35:10,030 --> 00:35:12,140
parameters and the number of defaults

00:35:11,620 --> 00:35:15,110
for key

00:35:12,140 --> 00:35:16,640
only two parameters since classes don't

00:35:15,110 --> 00:35:20,300
take any of the above this number is

00:35:16,640 --> 00:35:22,520
just 0 the result of make function is a

00:35:20,300 --> 00:35:27,230
function object it's a callable object

00:35:22,520 --> 00:35:30,320
then we call we load another con sanda

00:35:27,230 --> 00:35:32,450
there the the class name again this is

00:35:30,320 --> 00:35:34,160
dis object I don't remember whose output

00:35:32,450 --> 00:35:35,390
this is actually it might be mine but we

00:35:34,160 --> 00:35:37,640
load the name of the class onto the

00:35:35,390 --> 00:35:39,290
stack and then we call call function to

00:35:37,640 --> 00:35:41,390
now what is called function do obviously

00:35:39,290 --> 00:35:43,550
that calls a callable object the

00:35:41,390 --> 00:35:46,730
parameter the the AH park here that's

00:35:43,550 --> 00:35:47,870
the number of positional parameters Ord

00:35:46,730 --> 00:35:50,360
with the number of key word only

00:35:47,870 --> 00:35:51,950
parameters the way that works it's kind

00:35:50,360 --> 00:35:53,750
of like the op art the keyword only

00:35:51,950 --> 00:35:55,880
parameters are shifted left by eight and

00:35:53,750 --> 00:35:57,080
the two numbers or together but the

00:35:55,880 --> 00:35:58,250
bottom eight represents them of

00:35:57,080 --> 00:35:59,390
positional parameters and that's all

00:35:58,250 --> 00:36:01,640
you're ever going to see on my slides so

00:35:59,390 --> 00:36:03,500
this it means call function and it takes

00:36:01,640 --> 00:36:05,300
two parameters so this is going to pop

00:36:03,500 --> 00:36:06,980
the top two things off the stack the

00:36:05,300 --> 00:36:08,300
first one is named the class the second

00:36:06,980 --> 00:36:09,890
is the result of make function which is

00:36:08,300 --> 00:36:14,440
our callable object or is it represents

00:36:09,890 --> 00:36:16,340
the cobble body of the class object and

00:36:14,440 --> 00:36:17,720
then it's going to call a function which

00:36:16,340 --> 00:36:19,550
is actually the third thing on the stack

00:36:17,720 --> 00:36:20,990
which is what we got from load build

00:36:19,550 --> 00:36:22,940
class so it's going to call this magical

00:36:20,990 --> 00:36:24,410
function called build class which takes

00:36:22,940 --> 00:36:25,910
these two parameters the cobble object

00:36:24,410 --> 00:36:27,800
represents the body of the class and the

00:36:25,910 --> 00:36:30,350
name of the class and that does all the

00:36:27,800 --> 00:36:32,570
magical wizzy things to actually make

00:36:30,350 --> 00:36:33,770
the class happen so if you want to

00:36:32,570 --> 00:36:36,200
create your own classes from bytecode

00:36:33,770 --> 00:36:37,310
you have to have all this stuff and you

00:36:36,200 --> 00:36:41,000
kind of have to have all the stuff on

00:36:37,310 --> 00:36:43,100
the previous slide 2 now a little bit

00:36:41,000 --> 00:36:45,080
more interesting I'm going to create a

00:36:43,100 --> 00:36:47,090
function by hand I'm not going to use

00:36:45,080 --> 00:36:49,520
Python to do it while i am going to use

00:36:47,090 --> 00:36:51,530
python do it but i'm not used f it only

00:36:49,520 --> 00:36:55,070
takes me four lines you're going to hate

00:36:51,530 --> 00:36:58,100
them i have to import types and then i

00:36:55,070 --> 00:37:01,340
create a toad code object with some of

00:36:58,100 --> 00:37:02,720
the most readable python effort and then

00:37:01,340 --> 00:37:04,430
i create a function object from that

00:37:02,720 --> 00:37:05,750
code object I'm cleverly calling it add

00:37:04,430 --> 00:37:08,450
you may be able to guess what it does

00:37:05,750 --> 00:37:10,280
yes it takes two parameters it adds them

00:37:08,450 --> 00:37:12,620
together returns the result so this

00:37:10,280 --> 00:37:15,950
prints 5 and there is no def add

00:37:12,620 --> 00:37:18,800
anywhere on the screen now you don't

00:37:15,950 --> 00:37:20,720
understand what any of that means so I'm

00:37:18,800 --> 00:37:22,070
going to do this again but it's going to

00:37:20,720 --> 00:37:24,420
take me three slides and i'm going to

00:37:22,070 --> 00:37:27,100
show you exactly what it means

00:37:24,420 --> 00:37:28,330
so first I needed some more imports so

00:37:27,100 --> 00:37:31,150
that I can show you these symbolic op

00:37:28,330 --> 00:37:33,580
constants the rest of this slide this is

00:37:31,150 --> 00:37:35,110
just for the bytecode so upload fast you

00:37:33,580 --> 00:37:36,850
can tell exactly what that means now and

00:37:35,110 --> 00:37:38,980
then the two bytes after it those are

00:37:36,850 --> 00:37:41,350
the op arc that it going to be ored

00:37:38,980 --> 00:37:44,530
together so this program is load fast

00:37:41,350 --> 00:37:48,610
zero load fastest one binary add return

00:37:44,530 --> 00:37:52,990
value disk top map that's a map of

00:37:48,610 --> 00:37:57,400
strings to up codes and then it's just a

00:37:52,990 --> 00:38:00,580
map so I'm pulling get off of it this is

00:37:57,400 --> 00:38:02,950
all of the parameters to the code object

00:38:00,580 --> 00:38:04,960
and there are an awful lot of them so

00:38:02,950 --> 00:38:07,480
our count to it takes to positional

00:38:04,960 --> 00:38:08,980
arguments keyword only art count and

00:38:07,480 --> 00:38:10,180
local count there are no locals there

00:38:08,980 --> 00:38:12,460
are no keyword only argument so those

00:38:10,180 --> 00:38:14,080
are both 0 the total number of locals

00:38:12,460 --> 00:38:15,820
again I told you that's the number of

00:38:14,080 --> 00:38:17,320
positional only arguments plus the

00:38:15,820 --> 00:38:21,040
number of key word only arguments plus

00:38:17,320 --> 00:38:23,260
star KWR stark args if we have one we've

00:38:21,040 --> 00:38:25,660
had one starts to RK w arts we had one

00:38:23,260 --> 00:38:26,830
you that one and the number of local

00:38:25,660 --> 00:38:28,780
variables so you would add that all

00:38:26,830 --> 00:38:30,610
together i skipped the stars and start

00:38:28,780 --> 00:38:32,380
start KW arts just because i was already

00:38:30,610 --> 00:38:34,120
running out of space but the total

00:38:32,380 --> 00:38:37,120
number of locals actually is again going

00:38:34,120 --> 00:38:38,380
to be two max stack depth the deepest

00:38:37,120 --> 00:38:40,030
the stack will ever get in my add

00:38:38,380 --> 00:38:43,270
function is to because i push two things

00:38:40,030 --> 00:38:45,310
on the stack flags this is that binary

00:38:43,270 --> 00:38:47,680
bit field flag thing that i mentioned a

00:38:45,310 --> 00:38:50,500
minute ago this is the basic thing that

00:38:47,680 --> 00:38:52,210
you need for a modern Python function so

00:38:50,500 --> 00:38:55,180
there are three fields here Co optimized

00:38:52,210 --> 00:38:58,140
co new locals and co no free what do

00:38:55,180 --> 00:39:02,050
those mean I'm still not entirely sure

00:38:58,140 --> 00:39:04,510
the best I can figure out is new locals

00:39:02,050 --> 00:39:08,950
means this function uses the fast locals

00:39:04,510 --> 00:39:10,590
array okay every function since 1992 has

00:39:08,950 --> 00:39:13,360
used the new locals array I think even

00:39:10,590 --> 00:39:15,520
module objects that don't have it for at

00:39:13,360 --> 00:39:16,960
all still specifying co new locals just

00:39:15,520 --> 00:39:18,340
everybody does we probably should have

00:39:16,960 --> 00:39:20,530
gotten rid of the constant in Python 3

00:39:18,340 --> 00:39:23,560
because everybody uses it what a co

00:39:20,530 --> 00:39:25,090
optimized mean see you optimize also it

00:39:23,560 --> 00:39:26,920
optimized in this case doesn't mean the

00:39:25,090 --> 00:39:29,110
code is optimized it means the namespace

00:39:26,920 --> 00:39:31,570
is optimized so it actually also kind of

00:39:29,110 --> 00:39:33,700
means this function uses the the fast

00:39:31,570 --> 00:39:36,550
locals array what it specifically means

00:39:33,700 --> 00:39:37,480
is local variables are stored in fast

00:39:36,550 --> 00:39:42,010
locals as opposed

00:39:37,480 --> 00:39:47,950
is too slow levels using CEO underscore

00:39:42,010 --> 00:39:50,800
name so who uses who does not get Co

00:39:47,950 --> 00:39:55,240
optimized it's a very similar list it's

00:39:50,800 --> 00:39:57,190
classes its modules and it's eval and

00:39:55,240 --> 00:39:59,170
back in the old days when you could say

00:39:57,190 --> 00:40:01,390
import star inside of a function doing

00:39:59,170 --> 00:40:03,070
that would turn off Co optimized because

00:40:01,390 --> 00:40:04,720
you can only use fast locals because you

00:40:03,070 --> 00:40:09,130
didn't know in advance what variables

00:40:04,720 --> 00:40:10,840
you were going to have on word oh one

00:40:09,130 --> 00:40:12,820
more Co underscore no free that just

00:40:10,840 --> 00:40:15,130
means this function it has no free ours

00:40:12,820 --> 00:40:16,119
nor serovars this saves Python some

00:40:15,130 --> 00:40:19,720
computation is just a little

00:40:16,119 --> 00:40:21,850
optimization flag so onward the function

00:40:19,720 --> 00:40:24,490
doesn't have any constants any names

00:40:21,850 --> 00:40:26,260
Global's any free bars our selves are so

00:40:24,490 --> 00:40:28,530
those all get the empty tupple it does

00:40:26,260 --> 00:40:31,060
have some local variables a and B

00:40:28,530 --> 00:40:33,369
specifically arguments so I put those in

00:40:31,060 --> 00:40:35,320
bar names theoretically I type this in

00:40:33,369 --> 00:40:36,640
standard in so I just put standard in

00:40:35,320 --> 00:40:38,770
for the file name name of the function

00:40:36,640 --> 00:40:40,210
is add the first line number is one the

00:40:38,770 --> 00:40:44,770
L&O tab is empty because I didn't want

00:40:40,210 --> 00:40:46,330
the headache of calculating it and we're

00:40:44,770 --> 00:40:47,859
off to the races we create the code

00:40:46,330 --> 00:40:49,780
object passing in all those things in

00:40:47,859 --> 00:40:51,910
the right spots and then the rest of the

00:40:49,780 --> 00:40:53,890
slide is exactly the same we we pass the

00:40:51,910 --> 00:40:56,350
code object and the Global's

00:40:53,890 --> 00:40:57,520
again function functions carry their

00:40:56,350 --> 00:40:59,530
Global's run with them so you have to

00:40:57,520 --> 00:41:01,180
pass that in when you create it and you

00:40:59,530 --> 00:41:02,859
get a call to object out of it and you

00:41:01,180 --> 00:41:05,440
call it when you pass in two and three

00:41:02,859 --> 00:41:08,070
and you get five now this was still kind

00:41:05,440 --> 00:41:10,359
of painful so that's why I wrote my own

00:41:08,070 --> 00:41:12,460
assembler in disassembler i called it

00:41:10,359 --> 00:41:14,470
maynard i will remind you that Maynard

00:41:12,460 --> 00:41:16,440
was the keeper of the holy hand grenade

00:41:14,470 --> 00:41:18,400
and monty python's the Holy Grail the

00:41:16,440 --> 00:41:19,960
Holy Hand Grenade of course being the

00:41:18,400 --> 00:41:27,700
finest disassembler known to man or

00:41:19,960 --> 00:41:30,100
beast so Maynard contains an assembler a

00:41:27,700 --> 00:41:33,490
disassembler all of the example code

00:41:30,100 --> 00:41:37,030
from this talk and a very bad idea which

00:41:33,490 --> 00:41:38,859
I'll talk about in a minute so here is

00:41:37,030 --> 00:41:40,090
Manor disassembling gunk and I declare

00:41:38,859 --> 00:41:42,670
that this is a lot more readable this

00:41:40,090 --> 00:41:44,500
way so you can tell a is a position or a

00:41:42,670 --> 00:41:45,880
keyword argument it has a default of 1 B

00:41:44,500 --> 00:41:47,859
is a keyword only argument it has a

00:41:45,880 --> 00:41:49,840
default of three we have a star arts

00:41:47,859 --> 00:41:51,010
variable called it arbs we have two

00:41:49,840 --> 00:41:53,830
global variables

00:41:51,010 --> 00:41:57,040
are to global to to external Global's we

00:41:53,830 --> 00:41:59,320
might refer to global and none this none

00:41:57,040 --> 00:42:00,790
this is this is actually disassembling

00:41:59,320 --> 00:42:02,770
gunk so it's printing out the nun from

00:42:00,790 --> 00:42:04,870
the names array but it doesn't actually

00:42:02,770 --> 00:42:06,970
ever get used and then we have the

00:42:04,870 --> 00:42:09,160
constant value called consonant up there

00:42:06,970 --> 00:42:11,230
then the body of gunk actually ran out

00:42:09,160 --> 00:42:12,850
of space so I only I sort of clipped it

00:42:11,230 --> 00:42:15,400
but we have low global print load fast

00:42:12,850 --> 00:42:16,420
args call function one that's calling

00:42:15,400 --> 00:42:18,790
the function with a single parameter

00:42:16,420 --> 00:42:21,190
which is args the function we're calling

00:42:18,790 --> 00:42:23,050
is print we pop top because we throw

00:42:21,190 --> 00:42:24,430
away the return code from call function

00:42:23,050 --> 00:42:26,890
because nobody ever cares what print

00:42:24,430 --> 00:42:29,320
returns load kant's none we store it and

00:42:26,890 --> 00:42:30,910
see that was that line C equals none so

00:42:29,320 --> 00:42:32,320
you can actually tell everything that's

00:42:30,910 --> 00:42:36,160
going on inside of the function when you

00:42:32,320 --> 00:42:37,900
disassemble it with gunk now eventually

00:42:36,160 --> 00:42:40,750
I think the goal with Maynard is going

00:42:37,900 --> 00:42:42,340
to be to make it to do doing recursive

00:42:40,750 --> 00:42:44,500
disassembly so like if you disassemble a

00:42:42,340 --> 00:42:46,360
module it would show you the class and

00:42:44,500 --> 00:42:48,460
then we disassemble a class in line and

00:42:46,360 --> 00:42:49,930
if you add a method it would disassemble

00:42:48,460 --> 00:42:51,820
the method in line all of that being

00:42:49,930 --> 00:42:53,430
nested it doesn't do that yet it just

00:42:51,820 --> 00:42:55,720
prints out oh I have a code object here

00:42:53,430 --> 00:42:58,150
but what if you want to look at the

00:42:55,720 --> 00:42:59,530
definition of a class well you can do

00:42:58,150 --> 00:43:01,150
that myth minutes till you just have to

00:42:59,530 --> 00:43:03,310
be a little creative so what you do is

00:43:01,150 --> 00:43:04,330
you declare your class and you do all

00:43:03,310 --> 00:43:05,620
the stuff you want to do inside of the

00:43:04,330 --> 00:43:07,120
class and you take that and you put it

00:43:05,620 --> 00:43:08,380
inside of a function then you

00:43:07,120 --> 00:43:10,450
disassemble the function with Maynard

00:43:08,380 --> 00:43:14,140
and you look through the output and

00:43:10,450 --> 00:43:16,120
you're going to see const index then a

00:43:14,140 --> 00:43:18,250
number and then the code operator

00:43:16,120 --> 00:43:20,620
represents the body of the class then

00:43:18,250 --> 00:43:22,990
just take this and pull it straight out

00:43:20,620 --> 00:43:24,940
of a hat see I told you guys going to

00:43:22,990 --> 00:43:27,340
run out of time you pull it straight out

00:43:24,940 --> 00:43:28,900
of the code object and disassemble that

00:43:27,340 --> 00:43:32,530
again and that's going to give you the

00:43:28,900 --> 00:43:34,450
body of the class object so here's the

00:43:32,530 --> 00:43:35,830
bad idea mentioned a minute ago I wanted

00:43:34,450 --> 00:43:37,300
to prove that you could write a language

00:43:35,830 --> 00:43:41,200
on top of Python without actually using

00:43:37,300 --> 00:43:42,910
def without a function a language that

00:43:41,200 --> 00:43:45,190
ran on the the Python bytecode

00:43:42,910 --> 00:43:47,290
interpreter that wasn't Python so I out

00:43:45,190 --> 00:43:49,420
of fourth it's called Perth it ships

00:43:47,290 --> 00:43:51,280
with Maynard it's a toy forth on top of

00:43:49,420 --> 00:43:53,980
the python vm it's not useful for

00:43:51,280 --> 00:43:56,890
anything but it does have integer float

00:43:53,980 --> 00:43:59,170
and string literals it defines all of

00:43:56,890 --> 00:44:00,310
these python words including colon and

00:43:59,170 --> 00:44:01,980
semicolon so you can define your own

00:44:00,310 --> 00:44:04,920
functions in perth

00:44:01,980 --> 00:44:06,810
if it supports recursion and that is

00:44:04,920 --> 00:44:08,880
just barely enough till though I would

00:44:06,810 --> 00:44:10,530
be rode up to run a Fibonacci generator

00:44:08,880 --> 00:44:11,970
because I assert you don't have a real

00:44:10,530 --> 00:44:17,520
programming language so you can run

00:44:11,970 --> 00:44:19,380
Fibonacci now I have I think six more

00:44:17,520 --> 00:44:21,300
slides 87 and we're going to bring

00:44:19,380 --> 00:44:23,700
everything all together I'm going to

00:44:21,300 --> 00:44:26,100
show you a Python virtual machine

00:44:23,700 --> 00:44:28,320
written in Python this is going to take

00:44:26,100 --> 00:44:30,060
a function disassemble it break it into

00:44:28,320 --> 00:44:32,820
byte codes and run the individual byte

00:44:30,060 --> 00:44:34,050
codes now gunk is really boring so I'm

00:44:32,820 --> 00:44:36,119
not going to do gunk I'm going to do a

00:44:34,050 --> 00:44:37,680
Fibonacci generator so this is the

00:44:36,119 --> 00:44:42,530
function I'm going to run this function

00:44:37,680 --> 00:44:42,530
in my own handwritten vm and here we go

00:44:42,650 --> 00:44:48,270
def vm takes a callable object and takes

00:44:46,470 --> 00:44:50,609
our arms i declare all my local

00:44:48,270 --> 00:44:52,590
variables code is the code object

00:44:50,609 --> 00:44:54,720
constants is the console table names is

00:44:52,590 --> 00:44:56,520
a name table program is the bytecode and

00:44:54,720 --> 00:44:58,470
locals is a total number of local

00:44:56,520 --> 00:45:00,420
variables global stichting built-ins

00:44:58,470 --> 00:45:02,340
 I have to pull the global sticked

00:45:00,420 --> 00:45:03,810
out of the function I have to pull the

00:45:02,340 --> 00:45:06,030
Bolton's out of the Global's

00:45:03,810 --> 00:45:09,869
 and then I use those for low

00:45:06,030 --> 00:45:11,700
global instruction pointer is 0 total

00:45:09,869 --> 00:45:13,290
locals array that's again that's going

00:45:11,700 --> 00:45:15,090
to be parameters plus the local

00:45:13,290 --> 00:45:17,070
variables so I take all the arguments

00:45:15,090 --> 00:45:19,680
and I just splat them in there and then

00:45:17,070 --> 00:45:21,270
i create slots for all of the profile

00:45:19,680 --> 00:45:22,560
the local variables which I set to an

00:45:21,270 --> 00:45:24,510
uninitialized value have acquired

00:45:22,560 --> 00:45:25,770
somewhere else that's so that we you can

00:45:24,510 --> 00:45:28,050
detect if you reference an uninitialized

00:45:25,770 --> 00:45:29,880
local variable and then i create a stack

00:45:28,050 --> 00:45:32,010
and the stack is empty it's just a list

00:45:29,880 --> 00:45:35,660
because the stack works perfectly list

00:45:32,010 --> 00:45:38,280
works perfectly well for a stack page 2

00:45:35,660 --> 00:45:41,010
this is our big while loop this is going

00:45:38,280 --> 00:45:42,830
to iterate forever so we pull out the

00:45:41,010 --> 00:45:45,390
current instruction at the current

00:45:42,830 --> 00:45:47,880
instruction pointer and we increment by

00:45:45,390 --> 00:45:50,670
1 if we have an argument I pull out the

00:45:47,880 --> 00:45:52,920
op aarde i reassemble it and I advanced

00:45:50,670 --> 00:45:54,660
by two more the rest of the entire

00:45:52,920 --> 00:45:57,330
function all it's going to be is these

00:45:54,660 --> 00:45:58,380
if op double equals statements all we're

00:45:57,330 --> 00:46:01,440
going to do for the rest of the function

00:45:58,380 --> 00:46:04,350
is handling individual opcodes first one

00:46:01,440 --> 00:46:07,140
is upload constant it's one line if op

00:46:04,350 --> 00:46:08,700
equals load const we look up a bog in

00:46:07,140 --> 00:46:12,480
the constants array and we add it to the

00:46:08,700 --> 00:46:13,980
top of the stack load fast we look up op

00:46:12,480 --> 00:46:15,060
argh in the locals array and we added at

00:46:13,980 --> 00:46:17,700
the top of the stack

00:46:15,060 --> 00:46:18,720
low global we take the op art we look it

00:46:17,700 --> 00:46:20,460
up in the names array and that's the

00:46:18,720 --> 00:46:22,020
name we're looking up if it's in the

00:46:20,460 --> 00:46:24,390
Global's we add that to the stack

00:46:22,020 --> 00:46:25,860
else we add that from the built-ins to

00:46:24,390 --> 00:46:30,120
the stack I don't handle an error

00:46:25,860 --> 00:46:33,120
because it's only handling fit next page

00:46:30,120 --> 00:46:34,500
if its binary add I pop the top two

00:46:33,120 --> 00:46:36,750
things off the stack add them together

00:46:34,500 --> 00:46:39,150
push the result same thing with binary

00:46:36,750 --> 00:46:41,340
subtract except i use a minus sign pop

00:46:39,150 --> 00:46:44,490
jump if false this is how you do if

00:46:41,340 --> 00:46:48,390
statements if the top value on the stack

00:46:44,490 --> 00:46:50,760
is false then the op arg is going to be

00:46:48,390 --> 00:46:52,470
the new instruction pointer offset so we

00:46:50,760 --> 00:46:54,180
just that's how we jump we change the

00:46:52,470 --> 00:46:59,040
instruction pointer to be this new value

00:46:54,180 --> 00:47:03,480
boom we're off to the races two more

00:46:59,040 --> 00:47:05,040
slides I think compare up we pop the top

00:47:03,480 --> 00:47:06,750
two things off the sack compare up this

00:47:05,040 --> 00:47:09,450
is the general-purpose mechanism used

00:47:06,750 --> 00:47:11,310
for comparison in Python that's for less

00:47:09,450 --> 00:47:12,840
than and greater than all those what's

00:47:11,310 --> 00:47:15,420
called rich comparisons so the way that

00:47:12,840 --> 00:47:17,220
works is you pop the top few things off

00:47:15,420 --> 00:47:18,840
the stock the stack and the op art

00:47:17,220 --> 00:47:20,670
represents which operation you're doing

00:47:18,840 --> 00:47:23,790
soap i underscore LT I had to get that

00:47:20,670 --> 00:47:26,430
out of inspect I think if it's LT then

00:47:23,790 --> 00:47:28,530
it's less than I return v is less than W

00:47:26,430 --> 00:47:30,570
if it's less than or equal to I do v

00:47:28,530 --> 00:47:34,050
less than or equal to W else I throw an

00:47:30,570 --> 00:47:35,730
exception regardless if I succeed then I

00:47:34,050 --> 00:47:40,830
just push that value to the top of the

00:47:35,730 --> 00:47:42,450
stack call function this is the last

00:47:40,830 --> 00:47:43,890
slide I really should have shown you the

00:47:42,450 --> 00:47:48,360
ascent the disassembly forfeit but I

00:47:43,890 --> 00:47:50,370
forgot call function so first the op

00:47:48,360 --> 00:47:51,990
again that's the number of key word only

00:47:50,370 --> 00:47:53,610
parameters in the number of positional

00:47:51,990 --> 00:47:55,170
only parameters I don't handle keyword

00:47:53,610 --> 00:47:57,420
only parameters so if the number is

00:47:55,170 --> 00:48:01,290
greater than 255 I assert I throw an

00:47:57,420 --> 00:48:02,850
assertion I fail but now op art

00:48:01,290 --> 00:48:04,770
represents the number of positional only

00:48:02,850 --> 00:48:07,350
parameters so I pop them off the stack

00:48:04,770 --> 00:48:09,480
and stick them into an array that

00:48:07,350 --> 00:48:11,720
becomes ards I pop the callable object

00:48:09,480 --> 00:48:14,280
off the stack and I call vm recursively

00:48:11,720 --> 00:48:16,920
splatting in the arguments there are

00:48:14,280 --> 00:48:18,360
turn value from vm is going to be the

00:48:16,920 --> 00:48:20,160
computed value of the function i just

00:48:18,360 --> 00:48:22,740
called I just push that on to the top of

00:48:20,160 --> 00:48:25,260
the stack and finally return value

00:48:22,740 --> 00:48:26,850
opcode I assert that the stack has depth

00:48:25,260 --> 00:48:27,840
one because it would be untidy if you

00:48:26,850 --> 00:48:29,220
had left left over

00:48:27,840 --> 00:48:31,560
the gunk on the stack although Python

00:48:29,220 --> 00:48:32,820
doesn't actually do this anyway I just

00:48:31,560 --> 00:48:36,270
take the top value off the stack which

00:48:32,820 --> 00:48:39,630
is zero and I return it oh I had all

00:48:36,270 --> 00:48:42,060
those well I forgot anyway this really

00:48:39,630 --> 00:48:44,520
really works if I Drive it from Python

00:48:42,060 --> 00:48:46,560
the number the Fibonacci numbers 0

00:48:44,520 --> 00:48:48,690
through 9 I call the real function I

00:48:46,560 --> 00:48:51,180
call my vm and pass in the same fib

00:48:48,690 --> 00:48:54,840
function it reduces identical results it

00:48:51,180 --> 00:48:57,120
really really works so if you ever

00:48:54,840 --> 00:48:59,040
choose to experiment with opcodes

00:48:57,120 --> 00:49:00,800
yourself writing your own functions and

00:48:59,040 --> 00:49:03,870
assembling them expect to see this a lot

00:49:00,800 --> 00:49:05,070
the Python interpreter the Python

00:49:03,870 --> 00:49:08,610
interpreter is not particularly

00:49:05,070 --> 00:49:10,890
resistant to malformed by code so expect

00:49:08,610 --> 00:49:12,240
it to crash and when it crashes it'll

00:49:10,890 --> 00:49:14,420
give you no hints you'll have to sit

00:49:12,240 --> 00:49:17,460
there and think now what did I do wrong

00:49:14,420 --> 00:49:19,290
I've asked other core developers if we

00:49:17,460 --> 00:49:20,850
could maybe make it a little stronger

00:49:19,290 --> 00:49:22,170
maybe check some things before we do

00:49:20,850 --> 00:49:24,630
them they're like yeah it's bytecode if

00:49:22,170 --> 00:49:27,630
you're doing bytecode then you should

00:49:24,630 --> 00:49:29,100
expect it crash is on you so finally

00:49:27,630 --> 00:49:30,630
some resources in case you want to read

00:49:29,100 --> 00:49:33,360
some more about it oops I have one of

00:49:30,630 --> 00:49:36,090
those who didn't fade in this inspect

00:49:33,360 --> 00:49:37,590
and under future that's you need to look

00:49:36,090 --> 00:49:38,790
in all of those modules they had all the

00:49:37,590 --> 00:49:41,100
constants you would need in order to

00:49:38,790 --> 00:49:43,460
deal with bytecodes dunder future has

00:49:41,100 --> 00:49:46,740
some that are specific to future

00:49:43,460 --> 00:49:48,900
importable things Maynard is my

00:49:46,740 --> 00:49:51,540
disassembler it's up on bitbucket sup on

00:49:48,900 --> 00:49:54,540
pi PI I think the bit bucket version is

00:49:51,540 --> 00:49:57,660
a little fresher if you want to read see

00:49:54,540 --> 00:50:00,270
the implementation of the Python virtual

00:49:57,660 --> 00:50:02,400
machine the byte codes are all

00:50:00,270 --> 00:50:05,130
implemented in this file Python /c of a

00:50:02,400 --> 00:50:07,590
lot C Python trunk and finally if you

00:50:05,130 --> 00:50:10,410
want to read another implementation of a

00:50:07,590 --> 00:50:11,640
Python virtual machine in Python net

00:50:10,410 --> 00:50:13,350
batchelder has been writing a very nice

00:50:11,640 --> 00:50:14,940
one called bite run that really does

00:50:13,350 --> 00:50:16,500
everything including local variables and

00:50:14,940 --> 00:50:20,690
sell variables sell variables and free

00:50:16,500 --> 00:50:20,690
variables okay I'm done

00:50:35,930 --> 00:50:46,530
Larry thank you very much oh ah Larry

00:50:43,950 --> 00:50:50,610
Larry thank you very much do you have

00:50:46,530 --> 00:50:54,150
for those spite code something like how

00:50:50,610 --> 00:50:57,030
many cycles do they take like we had for

00:50:54,150 --> 00:51:00,600
real assembler it's not cycles I know

00:50:57,030 --> 00:51:02,250
but know the answer that would be no you

00:51:00,600 --> 00:51:06,270
really can't tell some of them can be

00:51:02,250 --> 00:51:07,830
very slow indeed like a star star i

00:51:06,270 --> 00:51:11,220
think is a single byte code and that

00:51:07,830 --> 00:51:12,870
turns into a very complicated process so

00:51:11,220 --> 00:51:15,240
there and there there can be loops

00:51:12,870 --> 00:51:17,190
inside of byte codes there's really no

00:51:15,240 --> 00:51:19,230
established thing you can just sort of

00:51:17,190 --> 00:51:21,240
thing conceptually like edition is going

00:51:19,230 --> 00:51:23,310
to be fast actually you can't even think

00:51:21,240 --> 00:51:25,920
that because it's called Dunder add and

00:51:23,310 --> 00:51:30,420
undirected do anything inside so there's

00:51:25,920 --> 00:51:33,840
really no telling um so thank you that

00:51:30,420 --> 00:51:35,640
was impressive then I guess the Sony

00:51:33,840 --> 00:51:37,560
would have for that i was wondering if i

00:51:35,640 --> 00:51:40,950
define all this myself and then i'll set

00:51:37,560 --> 00:51:45,030
the max depth of my stack not deep

00:51:40,950 --> 00:51:47,760
enough I'll get a ul crash and that's

00:51:45,030 --> 00:51:50,490
actually this this is a good point so

00:51:47,760 --> 00:51:51,510
you have to calculate the stacked so the

00:51:50,490 --> 00:51:55,140
first thing you can do is just add a

00:51:51,510 --> 00:51:56,880
thousand and see if you run now what I

00:51:55,140 --> 00:51:58,110
will tell you is that the hardest thing

00:51:56,880 --> 00:51:59,700
actually in riding Maynard was

00:51:58,110 --> 00:52:01,350
calculating the stack depth because

00:51:59,700 --> 00:52:03,660
that's not information that's published

00:52:01,350 --> 00:52:06,870
anywhere in Python its internal only

00:52:03,660 --> 00:52:08,880
there's a function in c called calculate

00:52:06,870 --> 00:52:10,590
stack depth or something like that and i

00:52:08,880 --> 00:52:12,270
literally had to take that copy it out

00:52:10,590 --> 00:52:14,370
of the python source code put in dual

00:52:12,270 --> 00:52:16,680
function into a little program and then

00:52:14,370 --> 00:52:18,660
drive it from python to produce a table

00:52:16,680 --> 00:52:20,010
and Maynard is based off of that table

00:52:18,660 --> 00:52:22,110
and the other thing that I'll tell you

00:52:20,010 --> 00:52:24,450
this even more complicated is that the

00:52:22,110 --> 00:52:27,060
stack depth used by any instruction

00:52:24,450 --> 00:52:29,400
might change depending on the op argh

00:52:27,060 --> 00:52:31,380
for instance of the obvious one is call

00:52:29,400 --> 00:52:33,060
function call function the op art

00:52:31,380 --> 00:52:34,950
reflects how many arguments you have and

00:52:33,060 --> 00:52:36,390
so you can calculate how deep the stack

00:52:34,950 --> 00:52:39,150
is but you have to know the op art first

00:52:36,390 --> 00:52:40,440
so if you want to play with assembly

00:52:39,150 --> 00:52:42,510
again I would I would absolutely

00:52:40,440 --> 00:52:43,730
recommend that you look at Maynard and

00:52:42,510 --> 00:52:46,250
you can pull out the

00:52:43,730 --> 00:52:48,109
stack depth calculator I actually asked

00:52:46,250 --> 00:52:49,460
this week if I could just add that to

00:52:48,109 --> 00:52:50,869
python like we could stick it into this

00:52:49,460 --> 00:52:53,450
module somewhere a function that says

00:52:50,869 --> 00:52:55,280
for this OP with this out bar what's the

00:52:53,450 --> 00:52:56,630
stack depth change and people are like

00:52:55,280 --> 00:53:04,150
yeah that's fine so it'll probably go in

00:52:56,630 --> 00:53:04,150
two three four yes

00:53:05,890 --> 00:53:13,690
oh I went to sleep I talked too long

00:53:09,490 --> 00:53:19,080
hello okay so why the whole shifting

00:53:13,690 --> 00:53:21,670
thing with the arguments of opcodes

00:53:19,080 --> 00:53:23,880
because we don't wanted it that way it

00:53:21,670 --> 00:53:27,580
has to be one way or the other and

00:53:23,880 --> 00:53:29,890
arguably this is what's called network

00:53:27,580 --> 00:53:31,990
byte order you need to store them

00:53:29,890 --> 00:53:34,330
somehow and network by order is a pretty

00:53:31,990 --> 00:53:35,920
obvious order that everybody knows and

00:53:34,330 --> 00:53:37,630
so he just did never fight order I

00:53:35,920 --> 00:53:39,280
imagine that was his thinking you'd

00:53:37,630 --> 00:53:44,380
really have to go back to 92 92 in a

00:53:39,280 --> 00:53:47,610
scuitto I've stunned you all into

00:53:44,380 --> 00:53:47,610
silence okay thank you very much

00:53:51,559 --> 00:53:53,619

YouTube URL: https://www.youtube.com/watch?v=0IzXcjHs-P8


