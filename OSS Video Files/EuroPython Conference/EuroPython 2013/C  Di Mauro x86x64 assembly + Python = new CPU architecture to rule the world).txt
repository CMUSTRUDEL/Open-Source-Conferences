Title: C  Di Mauro x86x64 assembly + Python = new CPU architecture to rule the world)
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	[Europython 2013]
5 July 2013
Track Pizza Napoli
Captions: 
	00:00:05,990 --> 00:00:14,700
okay so welcome everybody this afternoon

00:00:11,519 --> 00:00:17,130
cesare tomorrow we gave us a short

00:00:14,700 --> 00:00:21,050
presentation talking about assembly

00:00:17,130 --> 00:00:21,050
programming in Python thank you

00:00:28,910 --> 00:00:34,110
thank you I'm Chesser tomorrow I'm a

00:00:32,040 --> 00:00:37,260
copy editor for a pond alleged alley

00:00:34,110 --> 00:00:41,720
which is a valiant technological blog

00:00:37,260 --> 00:00:46,830
and I wrote many articles about CPU

00:00:41,720 --> 00:00:53,100
architectures and two years ago I had an

00:00:46,830 --> 00:00:55,440
idea for a new architecture and since I

00:00:53,100 --> 00:01:00,960
I think that it's a very good idea I

00:00:55,440 --> 00:01:05,489
decided to to make it a bit more real

00:01:00,960 --> 00:01:08,940
and so i show you how i got a softer

00:01:05,489 --> 00:01:12,289
model for my for my architecture and i

00:01:08,940 --> 00:01:12,289
got some numbers

00:01:25,550 --> 00:01:36,680
hey problems okay our came from a

00:01:33,770 --> 00:01:41,950
forbidden for this idea I think it's

00:01:36,680 --> 00:01:45,320
because of the geek nature and geeks are

00:01:41,950 --> 00:01:47,870
strange people cause sometimes they

00:01:45,320 --> 00:01:53,060
think that the work that others are made

00:01:47,870 --> 00:01:56,450
that isn't cool it's bad and am at a

00:01:53,060 --> 00:01:58,910
point on the day life they start to

00:01:56,450 --> 00:02:02,300
start to write an A our language and

00:01:58,910 --> 00:02:04,640
compiler and they are on operating

00:02:02,300 --> 00:02:09,560
system and the first system and for a

00:02:04,640 --> 00:02:13,220
very low level geeks a a new CP

00:02:09,560 --> 00:02:17,150
architecture is a degree in tune to come

00:02:13,220 --> 00:02:19,370
and they should do this so they spend a

00:02:17,150 --> 00:02:22,310
lot of time doing the this deal because

00:02:19,370 --> 00:02:24,320
they inviting that yeah that the coast

00:02:22,310 --> 00:02:30,830
guy in the world and they want to show

00:02:24,320 --> 00:02:34,459
it sometimes if the pace cause we have a

00:02:30,830 --> 00:02:37,459
sieve example in real life of people

00:02:34,459 --> 00:02:41,600
that ran and made their wonderful

00:02:37,459 --> 00:02:46,400
language which many of us loves and use

00:02:41,600 --> 00:02:49,970
and we had other people to wrote a brand

00:02:46,400 --> 00:02:53,630
new operating system which are not unix

00:02:49,970 --> 00:02:58,340
bezel and there are other guys which are

00:02:53,630 --> 00:03:02,060
designed a new microprocessor which are

00:02:58,340 --> 00:03:04,730
inside in the billions of devices in

00:03:02,060 --> 00:03:08,540
this case is referring to a truck pedal

00:03:04,730 --> 00:03:12,950
which wrote we would design that 6502

00:03:08,540 --> 00:03:17,120
cpu which you find in apple to apple one

00:03:12,950 --> 00:03:19,930
upper to candor with 20 kind of 64 and

00:03:17,120 --> 00:03:19,930
and so on so

00:03:21,520 --> 00:03:31,150
but sometimes it's just a dream cause

00:03:26,370 --> 00:03:34,530
what in Gaza as a geek isn't a real we

00:03:31,150 --> 00:03:39,390
can can make a process which as such

00:03:34,530 --> 00:03:43,750
features and cause that they can be

00:03:39,390 --> 00:03:47,010
perfect from my point of view but in the

00:03:43,750 --> 00:03:50,530
real world it doesn't apply cuz it's a

00:03:47,010 --> 00:03:55,480
such a beast is too much complicated and

00:03:50,530 --> 00:03:58,000
doesn't have a real application and but

00:03:55,480 --> 00:04:04,870
that's because maybe a young people

00:03:58,000 --> 00:04:08,740
makes so much mystics and that's one how

00:04:04,870 --> 00:04:13,330
is the CPU market there are a few

00:04:08,740 --> 00:04:16,270
contenders cause in the end we have many

00:04:13,330 --> 00:04:19,080
security textures which are just died we

00:04:16,270 --> 00:04:23,560
can think about the alpha from digital

00:04:19,080 --> 00:04:28,840
and others which are survived but they

00:04:23,560 --> 00:04:35,650
share just a few market share I talked

00:04:28,840 --> 00:04:39,100
about mipsel powerpc and spark that's

00:04:35,650 --> 00:04:42,610
because nowadays we have only two big

00:04:39,100 --> 00:04:50,410
players which dominates the market to

00:04:42,610 --> 00:04:53,530
choose which is a arm and Intel what is

00:04:50,410 --> 00:04:55,840
the current status about CP

00:04:53,530 --> 00:04:58,270
architectures and what what are the

00:04:55,840 --> 00:05:02,680
needs for them which comes from the

00:04:58,270 --> 00:05:05,590
market and we know that Intel processors

00:05:02,680 --> 00:05:09,730
shines only when we think about the

00:05:05,590 --> 00:05:16,060
performance they give us a great

00:05:09,730 --> 00:05:21,220
performance but power fishing season the

00:05:16,060 --> 00:05:23,529
best day by a strong point whereas we

00:05:21,220 --> 00:05:25,809
have an unprocessed searcher and

00:05:23,529 --> 00:05:32,499
have a very good the power of efficiency

00:05:25,809 --> 00:05:37,179
but performance on so much good and the

00:05:32,499 --> 00:05:41,369
market demands for my mobile devices

00:05:37,179 --> 00:05:45,459
which every day must be a more powerful

00:05:41,369 --> 00:05:48,429
they integrate more memory so in the

00:05:45,459 --> 00:05:51,509
future we and it brings a 64-bit

00:05:48,429 --> 00:05:55,959
architectures for mobile device to and

00:05:51,509 --> 00:06:00,159
but mobile devices still need to consume

00:05:55,959 --> 00:06:02,229
a few watts and because we found them in

00:06:00,159 --> 00:06:06,159
the smartphone and tablets and so on

00:06:02,229 --> 00:06:11,379
very little devices service we know that

00:06:06,159 --> 00:06:13,239
need so much performance but the power

00:06:11,379 --> 00:06:17,189
efficiency is a much important too

00:06:13,239 --> 00:06:20,949
because and service must be an included

00:06:17,189 --> 00:06:23,619
in an efficient way so because we have a

00:06:20,949 --> 00:06:27,099
many course which are a packet to get

00:06:23,619 --> 00:06:31,029
together close and many racks which are

00:06:27,099 --> 00:06:34,019
a packet in the data centers so power is

00:06:31,029 --> 00:06:40,799
an important factor even for for service

00:06:34,019 --> 00:06:45,219
pc desktop we are between these two

00:06:40,799 --> 00:06:48,099
things between mobile and service coming

00:06:45,219 --> 00:06:54,479
from that book too i hand pieces for for

00:06:48,099 --> 00:06:59,349
gaming for example but in telling arm

00:06:54,479 --> 00:07:02,229
carry and some legacy stuff in the

00:06:59,349 --> 00:07:05,469
architecture we know that intelligence

00:07:02,229 --> 00:07:11,399
support serial ISAs from the very old

00:07:05,469 --> 00:07:18,009
Eddie 86 from 206 386 and the last is

00:07:11,399 --> 00:07:19,719
x64 Intel processors also must give you

00:07:18,009 --> 00:07:22,149
some common complex instructions which

00:07:19,719 --> 00:07:26,940
works on the BCD which is a very old

00:07:22,149 --> 00:07:29,610
data format and as instructions for

00:07:26,940 --> 00:07:33,300
raising up stack frame which is a very

00:07:29,610 --> 00:07:36,200
complex and also have some instructions

00:07:33,300 --> 00:07:40,110
which deal with with strings and other

00:07:36,200 --> 00:07:43,290
strange things and everything comes from

00:07:40,110 --> 00:07:48,530
the very old processors which was which

00:07:43,290 --> 00:07:53,340
were 8086 and area 1 and 36 Intel also

00:07:48,530 --> 00:07:55,140
must support and very old memory model

00:07:53,340 --> 00:07:58,050
which is the segmentation whereas

00:07:55,140 --> 00:08:01,100
nowadays we have only paging which is

00:07:58,050 --> 00:08:03,960
much more flexible and efficient and

00:08:01,100 --> 00:08:09,890
last but not least intel has many

00:08:03,960 --> 00:08:13,080
structions that gives for programmers

00:08:09,890 --> 00:08:16,680
adam isn't that that different from

00:08:13,080 --> 00:08:20,730
Intel because armor and its history has

00:08:16,680 --> 00:08:24,300
made a lot of ISAs we have the original

00:08:20,730 --> 00:08:27,480
one which was them on they to eye level

00:08:24,300 --> 00:08:33,660
intellect it and then it comes with the

00:08:27,480 --> 00:08:37,590
thumb and tongue to for code density

00:08:33,660 --> 00:08:40,349
which was the goal to reach then come

00:08:37,590 --> 00:08:43,890
with the thumb EE and the judge ela for

00:08:40,349 --> 00:08:49,410
the Java veto machine and the last one

00:08:43,890 --> 00:08:52,440
which is a waterborne is a arm 6404 for

00:08:49,410 --> 00:08:55,440
service Armas also some very complex

00:08:52,440 --> 00:08:58,830
instructions of it seems strange because

00:08:55,440 --> 00:09:00,900
it's a risky processor but and it has

00:08:58,830 --> 00:09:04,140
the possibility to learn store install

00:09:00,900 --> 00:09:07,890
multiple registers which is a very hard

00:09:04,140 --> 00:09:11,420
thing to do at the other level and I'm

00:09:07,890 --> 00:09:11,420
has also many instructions

00:09:13,710 --> 00:09:18,870
so in this scenario comes my

00:09:16,650 --> 00:09:23,010
architecture which I labor the next to

00:09:18,870 --> 00:09:28,050
64 tea and why this architecture because

00:09:23,010 --> 00:09:32,040
I think that s key assist architectures

00:09:28,050 --> 00:09:34,440
can say more and they can also be a very

00:09:32,040 --> 00:09:38,210
efficient in from the coding point of

00:09:34,440 --> 00:09:45,060
view which he lie right now is there a

00:09:38,210 --> 00:09:47,190
problem in which x86x64 us and I my

00:09:45,060 --> 00:09:50,010
architecture is as a decoding the

00:09:47,190 --> 00:09:53,670
section which is quite compatible to arm

00:09:50,010 --> 00:09:57,150
and family to in a terrible complexity

00:09:53,670 --> 00:10:01,790
and it gives a very good rock density

00:09:57,150 --> 00:10:05,070
code entity is an important thing to

00:10:01,790 --> 00:10:06,990
have to deal that's we don't need to

00:10:05,070 --> 00:10:09,720
talk there to think about just the

00:10:06,990 --> 00:10:12,750
performance or power efficiency when we

00:10:09,720 --> 00:10:18,270
talk about cpu architecture because and

00:10:12,750 --> 00:10:22,170
adding cop density he's a thing to deal

00:10:18,270 --> 00:10:25,950
with and that is was so so much

00:10:22,170 --> 00:10:30,090
important that armor made the hump come

00:10:25,950 --> 00:10:34,380
to is just to address this problem God

00:10:30,090 --> 00:10:37,260
density and that literally has also

00:10:34,380 --> 00:10:41,490
excellent performance that's because it

00:10:37,260 --> 00:10:45,090
comes from the x86 x64 architecture

00:10:41,490 --> 00:10:50,010
which was a high performance being a lot

00:10:45,090 --> 00:10:55,950
new new stuff and and it's very easy to

00:10:50,010 --> 00:10:58,080
emulate the intel cpu and at about the

00:10:55,950 --> 00:11:01,320
same speed and it's a problem for the

00:10:58,080 --> 00:11:03,600
same example for for arma we because the

00:11:01,320 --> 00:11:06,900
architecture is very different from my

00:11:03,600 --> 00:11:11,090
Intel and that's a problem if you have

00:11:06,900 --> 00:11:15,000
to to execute and all the legacy code

00:11:11,090 --> 00:11:18,030
and one of the most important thing I

00:11:15,000 --> 00:11:21,600
think is that this new architecture is a

00:11:18,030 --> 00:11:26,040
source level a compatible with x86 x64

00:11:21,600 --> 00:11:27,030
and why this because New York attackers

00:11:26,040 --> 00:11:31,530
needs

00:11:27,030 --> 00:11:35,360
a software to run so if we we can bring

00:11:31,530 --> 00:11:38,640
the all the software and just compile

00:11:35,360 --> 00:11:41,390
with the wooden architecture we can have

00:11:38,640 --> 00:11:44,820
a lot of software that can run on it

00:11:41,390 --> 00:11:47,040
it's a very important thing the nucleic

00:11:44,820 --> 00:11:50,400
sure has also 32 general purpose

00:11:47,040 --> 00:11:53,270
registers up to 128 similar registers

00:11:50,400 --> 00:11:59,100
and a every single single register as

00:11:53,270 --> 00:12:02,970
inside so that goes up to 1024 beats it

00:11:59,100 --> 00:12:06,510
can seem strange but sitting the

00:12:02,970 --> 00:12:12,630
machines and nowadays go for very wide

00:12:06,510 --> 00:12:18,120
registers to to calculate many data at

00:12:12,630 --> 00:12:21,770
the same time it also has a smart code

00:12:18,120 --> 00:12:28,350
padding and what does it mean we if we

00:12:21,770 --> 00:12:32,250
disassemble the x86 x64 code we can see

00:12:28,350 --> 00:12:36,450
that we have many nope instructions

00:12:32,250 --> 00:12:40,650
which were used to just pad the code

00:12:36,450 --> 00:12:44,490
cache and to align it to the cache line

00:12:40,650 --> 00:12:46,530
and it can be made in a much more smart

00:12:44,490 --> 00:12:51,140
and efficient way than inserting just

00:12:46,530 --> 00:12:55,260
knobs in the in the code flow also a

00:12:51,140 --> 00:12:57,980
destructions that way i would use just

00:12:55,260 --> 00:13:00,390
one two or three arguments can be easily

00:12:57,980 --> 00:13:04,080
promoted to use two three or four

00:13:00,390 --> 00:13:07,860
operands and so we can work just like

00:13:04,080 --> 00:13:11,930
RISC processors in a in a very efficient

00:13:07,860 --> 00:13:15,150
way the creature is also tough to be

00:13:11,930 --> 00:13:19,170
scalable from a better to hpc what does

00:13:15,150 --> 00:13:22,890
it mean it means that if I need elected

00:13:19,170 --> 00:13:26,160
sure intervention which was 4am and by

00:13:22,890 --> 00:13:28,950
the devices I can cut it using the junta

00:13:26,160 --> 00:13:30,600
little bits and using the only sixteen

00:13:28,950 --> 00:13:35,730
registers in

00:13:30,600 --> 00:13:39,000
they're in a very simple way or i can

00:13:35,730 --> 00:13:41,069
and i can put two then i can bring the

00:13:39,000 --> 00:13:47,430
the most from the from this architecture

00:13:41,069 --> 00:13:50,850
for the HPC service for example but if

00:13:47,430 --> 00:13:53,759
you have an idea and which is a beauty

00:13:50,850 --> 00:13:56,819
that is good if you don't don't prove

00:13:53,759 --> 00:14:01,560
that don't prove that it's a good it

00:13:56,819 --> 00:14:05,279
just it's just an idea and it's all so I

00:14:01,560 --> 00:14:10,829
I need to find a benchmark to compare my

00:14:05,279 --> 00:14:15,600
architecture with the leading market so

00:14:10,829 --> 00:14:21,660
I i think this because next sixty forty

00:14:15,600 --> 00:14:23,910
is just just a rewrite of x86x64 I I

00:14:21,660 --> 00:14:28,589
take them as a reference as a benchmark

00:14:23,910 --> 00:14:32,730
for from architecture and so what I mean

00:14:28,589 --> 00:14:36,149
now is just to to write a model for

00:14:32,730 --> 00:14:41,279
Micah teacher and that's where a Python

00:14:36,149 --> 00:14:46,860
came to show that market actual is good

00:14:41,279 --> 00:14:51,420
I have to to set some key points and we

00:14:46,860 --> 00:14:54,060
know that a cpu call you can be split in

00:14:51,420 --> 00:14:57,750
two parts the front end and the back end

00:14:54,060 --> 00:15:00,930
and we have the front end which fetch

00:14:57,750 --> 00:15:05,160
instruction from the memory decodes them

00:15:00,930 --> 00:15:10,230
and send them to the back end which just

00:15:05,160 --> 00:15:15,620
runs the instructions if I use the same

00:15:10,230 --> 00:15:18,950
back end of x86 x64 I am

00:15:15,620 --> 00:15:20,960
I can just think about the front end Joe

00:15:18,950 --> 00:15:24,680
so I have the back end which is the same

00:15:20,960 --> 00:15:27,620
of the Intel Architecture and I only

00:15:24,680 --> 00:15:35,650
need to compare the front end to show

00:15:27,620 --> 00:15:35,650
that market action is is good is a easy

00:15:35,680 --> 00:15:42,230
it's best that the best of architectures

00:15:39,620 --> 00:15:47,950
are even compared to int n1 Intel ones

00:15:42,230 --> 00:15:51,200
so i can compare the front ends the and

00:15:47,950 --> 00:15:55,730
i can compare the decoders and our can

00:15:51,200 --> 00:15:58,670
do this just I can take the opcode table

00:15:55,730 --> 00:16:02,720
and I can see the opcode structure and

00:15:58,670 --> 00:16:06,850
see how it's quite simple to do the code

00:16:02,720 --> 00:16:13,910
compared to the upload structure of x86

00:16:06,850 --> 00:16:17,330
x64 but I need also to to complete the

00:16:13,910 --> 00:16:22,339
work I need to map every extraction from

00:16:17,330 --> 00:16:24,890
the x86 x64 to my architecture and after

00:16:22,339 --> 00:16:32,360
these I need to collect some stats about

00:16:24,890 --> 00:16:35,690
the my instructions to do this stuff I

00:16:32,360 --> 00:16:41,029
needed an x86 disassembler for another

00:16:35,690 --> 00:16:44,260
Python I I found I found a stone free

00:16:41,029 --> 00:16:47,480
library which is an open source project

00:16:44,260 --> 00:16:51,770
which is a lightweight simple fast and

00:16:47,480 --> 00:16:53,480
well documented but it doesn't many

00:16:51,770 --> 00:16:57,380
structures at the same time using a

00:16:53,480 --> 00:17:01,790
buffer but it was a bit bucket so I I

00:16:57,380 --> 00:17:08,290
had to fix something and I also reported

00:17:01,790 --> 00:17:11,089
them it's a tracker and most of them are

00:17:08,290 --> 00:17:14,569
fixed but something something some stuff

00:17:11,089 --> 00:17:16,790
using a fixing now and it supports

00:17:14,569 --> 00:17:19,670
everything from the inter side from the

00:17:16,790 --> 00:17:25,790
very old architecture to the locks

00:17:19,670 --> 00:17:27,679
extensions extensions such a VX I made

00:17:25,790 --> 00:17:28,870
some improvements to describe it because

00:17:27,679 --> 00:17:33,250
I needed

00:17:28,870 --> 00:17:36,220
other stuff for my project first the

00:17:33,250 --> 00:17:40,180
Python proper locks some constants and

00:17:36,220 --> 00:17:42,010
functions so I add them and then I found

00:17:40,180 --> 00:17:44,200
that the decoding emotive instructions

00:17:42,010 --> 00:17:48,040
at the same time was an efficient from

00:17:44,200 --> 00:17:51,250
what I i need the soul I wrote a couple

00:17:48,040 --> 00:17:54,610
functions to do the this stuff monofin

00:17:51,250 --> 00:17:57,700
efficiently and I took the doors to the

00:17:54,610 --> 00:18:03,340
instruction class which it generates and

00:17:57,700 --> 00:18:07,750
to get some more usable information well

00:18:03,340 --> 00:18:14,050
it is also an elaborate to do the same

00:18:07,750 --> 00:18:17,470
PE binaries and distant tree comes to

00:18:14,050 --> 00:18:22,510
work with such tool which is called this

00:18:17,470 --> 00:18:24,760
lip I it shows some piece of P

00:18:22,510 --> 00:18:29,200
information I added some more which were

00:18:24,760 --> 00:18:32,080
very interesting for me and but it has a

00:18:29,200 --> 00:18:34,570
robot it just disassembly that the first

00:18:32,080 --> 00:18:38,520
distractions it encounters and just

00:18:34,570 --> 00:18:43,059
stops so I need to do to do a match

00:18:38,520 --> 00:18:45,490
complex worker to to get them out as

00:18:43,059 --> 00:18:49,450
many as a possible extraction Jesus

00:18:45,490 --> 00:18:54,660
handed from the from the stream already

00:18:49,450 --> 00:18:58,710
did and the first four instructions

00:18:54,660 --> 00:19:02,980
we're the ones that this little just

00:18:58,710 --> 00:19:06,160
disassembly and then stops here and how

00:19:02,980 --> 00:19:09,880
can i descend a lot of more instructions

00:19:06,160 --> 00:19:13,600
i just keep track of calls and jumps

00:19:09,880 --> 00:19:16,870
instructions i get their addresses so i

00:19:13,600 --> 00:19:21,000
can have other entry points where i can

00:19:16,870 --> 00:19:21,000
start to do the same the instructions

00:19:21,540 --> 00:19:31,740
how can it I our made it and ok I used

00:19:28,030 --> 00:19:35,340
an array to to mark every bite of

00:19:31,740 --> 00:19:38,160
the code stream and and the queue where

00:19:35,340 --> 00:19:40,830
I am and I put all the addresses that I

00:19:38,160 --> 00:19:45,960
am I found and then need to be a

00:19:40,830 --> 00:19:47,790
dissembler how it works when I am I get

00:19:45,960 --> 00:19:52,160
an instruction which is the same but I

00:19:47,790 --> 00:19:54,900
hi mark its bytes as already a

00:19:52,160 --> 00:19:56,610
disassembly so the next time that I

00:19:54,900 --> 00:19:59,790
found the design construction I just

00:19:56,610 --> 00:20:02,400
skipped the this process and when I

00:19:59,790 --> 00:20:05,309
found a jump or call I pack the address

00:20:02,400 --> 00:20:07,920
and they put it on the holocube so i can

00:20:05,309 --> 00:20:11,820
later and assassin then the code stream

00:20:07,920 --> 00:20:14,880
from this and when I found the absolute

00:20:11,820 --> 00:20:17,309
jumps read in San electric traction I

00:20:14,880 --> 00:20:20,610
just stopped and disassembly because I

00:20:17,309 --> 00:20:24,920
found them at Pointe du Lac i can safely

00:20:20,610 --> 00:20:24,920
and the same instructions from there oh

00:20:25,580 --> 00:20:32,210
I need also to collect some instructions

00:20:28,740 --> 00:20:35,460
samsung information for distractions and

00:20:32,210 --> 00:20:38,660
when i disassembled extraction i get its

00:20:35,460 --> 00:20:42,570
structural length and it's meh monica

00:20:38,660 --> 00:20:45,780
the arguments if there are n is the

00:20:42,570 --> 00:20:49,320
constant if it's used and then the

00:20:45,780 --> 00:20:52,429
addressing mode i collect some

00:20:49,320 --> 00:20:57,710
information generator starts using the

00:20:52,429 --> 00:21:02,280
counter class in the collections module

00:20:57,710 --> 00:21:04,800
now i have all the information about the

00:21:02,280 --> 00:21:10,920
instruction so i can translate it into

00:21:04,800 --> 00:21:13,500
from x86x64 to my architecture i bought

00:21:10,920 --> 00:21:17,370
a new module which I call the next 60 40

00:21:13,500 --> 00:21:19,920
not pie in 30 from scratch each it's

00:21:17,370 --> 00:21:24,660
about three thousand lines but it's

00:21:19,920 --> 00:21:27,720
enough to to assemble an extraction it

00:21:24,660 --> 00:21:29,970
works by converting the old addressing

00:21:27,720 --> 00:21:34,290
mode from the old architecture to my

00:21:29,970 --> 00:21:37,230
architecture it try to to pack the

00:21:34,290 --> 00:21:41,710
constant to an Intel format if it's

00:21:37,230 --> 00:21:44,230
possible to save on space and

00:21:41,710 --> 00:21:46,120
that it packs together the opcode to the

00:21:44,230 --> 00:21:52,179
addressing mode and a constant to

00:21:46,120 --> 00:21:56,110
generate the extraction byte string okay

00:21:52,179 --> 00:21:58,450
now finally I can get the numbers and

00:21:56,110 --> 00:22:02,500
compare my architecture with the real

00:21:58,450 --> 00:22:06,460
world and to do this I i used the adobe

00:22:02,500 --> 00:22:10,240
photoshop cs6 which was released as a

00:22:06,460 --> 00:22:13,059
public beta to use a go and i use it

00:22:10,240 --> 00:22:15,640
because it has many extractions that i

00:22:13,059 --> 00:22:18,850
can decode which about 1 million and

00:22:15,640 --> 00:22:22,240
seven hundred thousand which is enough

00:22:18,850 --> 00:22:25,830
to to get some concrete numbers about

00:22:22,240 --> 00:22:30,220
the efficiency of my instruction

00:22:25,830 --> 00:22:34,590
unfortunately for the 32 bit version max

00:22:30,220 --> 00:22:39,250
my extraction my architecture shows a

00:22:34,590 --> 00:22:43,630
bit more space which is needed to

00:22:39,250 --> 00:22:47,110
accomplish the same task so then decides

00:22:43,630 --> 00:22:49,779
is a better than the intel one it's a

00:22:47,110 --> 00:22:54,880
not so much cause it just just six

00:22:49,779 --> 00:23:00,399
percent and more space needed but its

00:22:54,880 --> 00:23:04,440
factor the things changes completely

00:23:00,399 --> 00:23:07,450
when i moved to 64 bits cause my

00:23:04,440 --> 00:23:14,110
architecture shows a very interesting

00:23:07,450 --> 00:23:20,190
int result globally i have i need much

00:23:14,110 --> 00:23:24,690
less space than the x64 architecture to

00:23:20,190 --> 00:23:26,919
to generate the extraction so my

00:23:24,690 --> 00:23:32,429
architecture is much much much more

00:23:26,919 --> 00:23:38,440
efficient efficient than the x64 and

00:23:32,429 --> 00:23:41,799
these with this data I am I think I can

00:23:38,440 --> 00:23:48,210
explain why I think by my architecture

00:23:41,799 --> 00:23:48,210
is a better plan x86 x64

00:23:50,279 --> 00:23:57,359
ok and now about Python I always worked

00:23:55,559 --> 00:24:02,179
it wasn't i wasn't possible possible

00:23:57,359 --> 00:24:05,159
without Python because and with Python I

00:24:02,179 --> 00:24:07,559
had the possibility to write a certain

00:24:05,159 --> 00:24:11,519
model from architecture in a few time

00:24:07,559 --> 00:24:14,989
and it let me experiment many ideas

00:24:11,519 --> 00:24:23,369
which I had in nine last two years and

00:24:14,989 --> 00:24:26,849
it can so I got also the about to go in

00:24:23,369 --> 00:24:28,919
hyah neighs versions of my architecture

00:24:26,849 --> 00:24:34,169
and I'm see developing an attempt one

00:24:28,919 --> 00:24:36,899
and so thanks to python I I'd

00:24:34,169 --> 00:24:39,719
possibility to go to have some numbers

00:24:36,899 --> 00:24:45,029
to to compare marca texture to the to

00:24:39,719 --> 00:24:51,389
the real world that's all if you have

00:24:45,029 --> 00:24:56,159
any question I can show details about

00:24:51,389 --> 00:24:59,879
market actual for cause it's my price

00:24:56,159 --> 00:25:03,059
stuff i was interested to see the

00:24:59,879 --> 00:25:05,570
comparison between the 32 and 64 bits

00:25:03,059 --> 00:25:09,029
there was a line with the average

00:25:05,570 --> 00:25:12,869
instructions yeah I I do not understand

00:25:09,029 --> 00:25:15,419
why you why do you think it doesn't work

00:25:12,869 --> 00:25:20,099
for 32-bit so yeah instruction sighs

00:25:15,419 --> 00:25:24,359
there is free to and increases on 44

00:25:20,099 --> 00:25:28,889
yeah yeah until it increases right so

00:25:24,359 --> 00:25:31,320
but why can't you be a small that's

00:25:28,889 --> 00:25:35,900
because my architecture is a quite

00:25:31,320 --> 00:25:40,030
different from regular one so for these

00:25:35,900 --> 00:25:45,110
k is it to bits Kaiser it's not as a

00:25:40,030 --> 00:25:47,720
much official and as the Denmark just

00:25:45,110 --> 00:25:49,900
random things I held on my mind TQ did

00:25:47,720 --> 00:25:53,600
you consider working with for example

00:25:49,900 --> 00:25:55,430
valgrind which i think i am not

00:25:53,600 --> 00:25:58,640
experienced in a few but it might it

00:25:55,430 --> 00:26:01,040
emulates architectures and that could be

00:25:58,640 --> 00:26:03,470
interesting to get a vagrant to run a

00:26:01,040 --> 00:26:06,290
program because you're not executing

00:26:03,470 --> 00:26:10,250
anything now right you are just I just

00:26:06,290 --> 00:26:12,440
disaster executable existing the actual

00:26:10,250 --> 00:26:15,110
runtime information no not random

00:26:12,440 --> 00:26:17,920
information I just translate the

00:26:15,110 --> 00:26:20,180
extractions from the Intel side to my

00:26:17,920 --> 00:26:24,680
architecture basically all you know you

00:26:20,180 --> 00:26:26,540
have a higher density yeah the encoding

00:26:24,680 --> 00:26:30,170
of instructions which is already quite

00:26:26,540 --> 00:26:33,200
an achievement because you you do not

00:26:30,170 --> 00:26:36,350
have a compiler which probably could

00:26:33,200 --> 00:26:38,570
make more take more advantage of your

00:26:36,350 --> 00:26:42,620
instruction set yes it's just a rough

00:26:38,570 --> 00:26:45,230
translation so I am I cannot take care

00:26:42,620 --> 00:26:49,750
of the improvements that Micah textured

00:26:45,230 --> 00:26:53,510
add I for example I interview to the

00:26:49,750 --> 00:26:56,600
memory to memory instruction which is

00:26:53,510 --> 00:27:00,020
much more efficient than the usual Lord

00:26:56,600 --> 00:27:02,120
on the register and store to memory

00:27:00,020 --> 00:27:04,370
which requires the two instructions and

00:27:02,120 --> 00:27:08,240
revised in the end register but you need

00:27:04,370 --> 00:27:09,950
to to trash just do this task with my

00:27:08,240 --> 00:27:13,040
instruction you don't need to rush

00:27:09,950 --> 00:27:15,230
register and it's much more efficient

00:27:13,040 --> 00:27:19,490
because you know just one instruction

00:27:15,230 --> 00:27:21,380
you do the things that the other

00:27:19,490 --> 00:27:25,100
architectures requires to two

00:27:21,380 --> 00:27:28,250
extractions and also and it doesn't hurt

00:27:25,100 --> 00:27:30,770
the pipeline because with the other kak

00:27:28,250 --> 00:27:34,180
architectures you have to know the value

00:27:30,770 --> 00:27:36,950
and then when you store it unique to and

00:27:34,180 --> 00:27:40,040
the previous instruction to finish the

00:27:36,950 --> 00:27:42,720
load before the next one it can be

00:27:40,040 --> 00:27:46,350
executed and

00:27:42,720 --> 00:27:50,580
you didn't compare to arm did you know

00:27:46,350 --> 00:27:54,360
and that's because Micah textured comes

00:27:50,580 --> 00:27:59,700
from life from Intel Intel is quite much

00:27:54,360 --> 00:28:02,909
performance than arm so yeah Intel is my

00:27:59,700 --> 00:28:05,970
my benchmark my friends in the Army is

00:28:02,909 --> 00:28:12,179
important if you think about the the

00:28:05,970 --> 00:28:15,330
power conception so I can compare to 20

00:28:12,179 --> 00:28:18,330
people now performance is what you get

00:28:15,330 --> 00:28:20,280
out of what that's even for the server

00:28:18,330 --> 00:28:22,470
would I think he wrote on your slide but

00:28:20,280 --> 00:28:25,169
the server should be fast but I think in

00:28:22,470 --> 00:28:30,059
reality now people are thinking how much

00:28:25,169 --> 00:28:32,400
energy do i need to deliver certain yes

00:28:30,059 --> 00:28:35,610
no instructions so actually I think

00:28:32,400 --> 00:28:36,600
that's kind of an obsolete information

00:28:35,610 --> 00:28:40,230
where you're giving there when you

00:28:36,600 --> 00:28:44,720
saying burnout cycles and be fast that's

00:28:40,230 --> 00:28:48,510
not the standard okay but and if you

00:28:44,720 --> 00:28:53,450
think about the our internal spends its

00:28:48,510 --> 00:28:57,870
energy in the coding destruction okay it

00:28:53,450 --> 00:29:02,280
is where my architecture comes I cannot

00:28:57,870 --> 00:29:05,760
show you my op code structure the opcode

00:29:02,280 --> 00:29:09,179
table but if you might take a look at it

00:29:05,760 --> 00:29:13,710
you can see that the extraction format

00:29:09,179 --> 00:29:16,590
is a very very simple to decode and this

00:29:13,710 --> 00:29:21,690
brings to a decoding section which is a

00:29:16,590 --> 00:29:23,590
much smaller I think so you got this

00:29:21,690 --> 00:29:26,440
magnitude thank you improve

00:29:23,590 --> 00:29:30,120
you wouldn't make it it would be lower

00:29:26,440 --> 00:29:33,549
that yeah I I proved that the decoder

00:29:30,120 --> 00:29:35,770
because they Intel and as a problems

00:29:33,549 --> 00:29:37,809
with the decoder which is very very

00:29:35,770 --> 00:29:40,360
complex requires a millions of East all

00:29:37,809 --> 00:29:43,090
the transistors to achieve the task and

00:29:40,360 --> 00:29:45,880
you cannot turn off the decoder in the

00:29:43,090 --> 00:29:49,710
in n cpu because extractions might need

00:29:45,880 --> 00:29:53,440
to be Fetchit the codon and executed ok

00:29:49,710 --> 00:29:56,380
Intel comes with some tricks with the

00:29:53,440 --> 00:29:59,320
nail em architecture such as using a

00:29:56,380 --> 00:30:01,600
little buffer for order to decode

00:29:59,320 --> 00:30:03,789
distractions so you don't need to decode

00:30:01,600 --> 00:30:08,289
them every time if you have a very

00:30:03,789 --> 00:30:12,700
little loop but it's just an Asian area

00:30:08,289 --> 00:30:14,620
in case on every other scenario you need

00:30:12,700 --> 00:30:18,789
to decode every time the instruction so

00:30:14,620 --> 00:30:23,950
the decoders run every time and the jaws

00:30:18,789 --> 00:30:27,210
a lot of power and one final question so

00:30:23,950 --> 00:30:30,220
you're not making a hybrid thing you are

00:30:27,210 --> 00:30:32,590
you will have a thin layer which allows

00:30:30,220 --> 00:30:34,990
you to be compatible with the internal

00:30:32,590 --> 00:30:36,549
architecture there's a translation by

00:30:34,990 --> 00:30:38,590
cooler to be built in hardware and

00:30:36,549 --> 00:30:40,120
banner could be compatible but you

00:30:38,590 --> 00:30:42,880
couldn't do that for on because

00:30:40,120 --> 00:30:44,770
initially it looked like it was a you

00:30:42,880 --> 00:30:46,690
had something which you could turn to

00:30:44,770 --> 00:30:48,820
translate arm into your thing and you

00:30:46,690 --> 00:30:51,520
could translate into and your thing and

00:30:48,820 --> 00:30:55,149
bama would have a processor which can

00:30:51,520 --> 00:30:57,399
run all the software yes and that's

00:30:55,149 --> 00:31:00,490
because that's why I've added some

00:30:57,399 --> 00:31:04,510
features on my text which I even talked

00:31:00,490 --> 00:31:07,840
about it to improve emulation of other

00:31:04,510 --> 00:31:11,649
architectures I think that although

00:31:07,840 --> 00:31:14,140
armata to which uses a 16 registers can

00:31:11,649 --> 00:31:17,950
be easily emulated by by my architecture

00:31:14,140 --> 00:31:21,549
as well as the Intel katek sure it's

00:31:17,950 --> 00:31:26,409
different for our 64 because of 64

00:31:21,549 --> 00:31:30,279
brings 30 general purpose registers so I

00:31:26,409 --> 00:31:34,659
have trouble mapping all the arm 64

00:31:30,279 --> 00:31:36,279
register to my Kotecha I had a pen

00:31:34,659 --> 00:31:38,229
a lot of registers with my protection

00:31:36,279 --> 00:31:41,499
yet 32like general purpose registers

00:31:38,229 --> 00:31:45,940
registers are I think good enough like a

00:31:41,499 --> 00:31:49,149
risc processor I we can do we can

00:31:45,940 --> 00:31:52,149
emulate a lot of architectures with the

00:31:49,149 --> 00:32:06,249
with this new one and officially and I

00:31:52,149 --> 00:32:10,950
think but not all any other questions ok

00:32:06,249 --> 00:32:10,950
so thanks again is that it thank you

00:32:35,740 --> 00:32:37,800

YouTube URL: https://www.youtube.com/watch?v=S0tirdmJrZI


