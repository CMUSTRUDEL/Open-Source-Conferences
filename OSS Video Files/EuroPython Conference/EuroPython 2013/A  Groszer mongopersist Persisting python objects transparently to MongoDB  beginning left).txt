Title: A  Groszer mongopersist Persisting python objects transparently to MongoDB  beginning left)
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	[Europython 2013]
K  Lautaportti Introduction to Cassandra
5 July 2013
TRACK tagliatelle
Captions: 
	00:00:00,319 --> 00:00:10,320
doesn't have DP manga sub-object set us

00:00:05,609 --> 00:00:15,420
to be visited attribute get extended in

00:00:10,320 --> 00:00:19,170
LA and our new object Roger gets also

00:00:15,420 --> 00:00:26,310
inserted into the person collection

00:00:19,170 --> 00:00:28,080
because we created a new object and as

00:00:26,310 --> 00:00:30,539
you see it's tough on friends or your

00:00:28,080 --> 00:00:36,149
name it's a lot more easier to access

00:00:30,539 --> 00:00:40,250
any attribute just then using find and

00:00:36,149 --> 00:00:40,250
whatever with vb refs

00:00:41,420 --> 00:00:46,309
if you have noticed it's very easy to

00:00:43,789 --> 00:00:49,760
create recursion there with person

00:00:46,309 --> 00:00:54,440
because I could add one more friend of

00:00:49,760 --> 00:00:56,809
Roger probably it Stefan again because

00:00:54,440 --> 00:01:01,089
they know each other so you can create a

00:00:56,809 --> 00:01:05,180
recursion which is ok so far you are

00:01:01,089 --> 00:01:07,909
subclassing persistent we could persist

00:01:05,180 --> 00:01:11,899
because those persistent objects we are

00:01:07,909 --> 00:01:13,970
stored a big database reference which is

00:01:11,899 --> 00:01:17,270
done very easy to resolve the circular

00:01:13,970 --> 00:01:20,630
differences but again if you are not

00:01:17,270 --> 00:01:25,780
supply sync persistent this is big

00:01:20,630 --> 00:01:25,780
problem so with circular references

00:01:28,640 --> 00:01:34,670
now we are coming too optimistic data

00:01:30,650 --> 00:01:37,130
damping which is otis process of dumping

00:01:34,670 --> 00:01:39,650
data during the transaction under the

00:01:37,130 --> 00:01:45,770
assumption transaction will succeed

00:01:39,650 --> 00:01:49,369
succeed the problem was that we are

00:01:45,770 --> 00:01:55,430
doing modifications to objects during a

00:01:49,369 --> 00:02:00,259
request and usually after some point we

00:01:55,430 --> 00:02:02,750
need to do a cry of MongoDB data I have

00:02:00,259 --> 00:02:07,479
a sample in the next slide and this

00:02:02,750 --> 00:02:07,479
query needs to access the modified data

00:02:09,250 --> 00:02:17,269
so we had to flush first and actually

00:02:14,269 --> 00:02:21,650
mobile versus is doing flushing before

00:02:17,269 --> 00:02:24,910
any query operation to have the object

00:02:21,650 --> 00:02:24,910
modifications in the database

00:02:29,090 --> 00:02:34,670
some arms and one body mangu persist

00:02:31,730 --> 00:02:39,379
also tries to delay writing data to the

00:02:34,670 --> 00:02:42,140
database as much as possible because the

00:02:39,379 --> 00:02:44,959
last round trips you have the faster you

00:02:42,140 --> 00:02:47,180
get but the query is the point where you

00:02:44,959 --> 00:02:49,209
need to flush unless you want to

00:02:47,180 --> 00:02:52,010
reimplement the or the query language

00:02:49,209 --> 00:02:56,780
okay keep it sync with the database and

00:02:52,010 --> 00:03:02,230
your local changes is just pain so the

00:02:56,780 --> 00:03:05,840
easiest was to just flush before query

00:03:02,230 --> 00:03:08,840
and also when go Percy skips the very

00:03:05,840 --> 00:03:12,590
original state of the object at the

00:03:08,840 --> 00:03:17,150
beginning of the transaction so we can

00:03:12,590 --> 00:03:21,739
revert in a case of a problem so in the

00:03:17,150 --> 00:03:25,280
examples for example if I would have

00:03:21,739 --> 00:03:27,079
issued transaction about the original

00:03:25,280 --> 00:03:31,310
state would have been restored in the

00:03:27,079 --> 00:03:34,040
database the small issue with having no

00:03:31,310 --> 00:03:36,019
transactions on MongoDB is that the

00:03:34,040 --> 00:03:38,870
database might be temporarily being

00:03:36,019 --> 00:03:43,989
inconsistent state but anyway you have

00:03:38,870 --> 00:03:43,989
to embrace this with no sequel databases

00:03:45,210 --> 00:03:50,670
and here's my example for optimistic

00:03:47,490 --> 00:03:56,190
data damping and change a few attributes

00:03:50,670 --> 00:03:58,530
I could have a lot of coding with me and

00:03:56,190 --> 00:04:01,310
note there is no transaction commits

00:03:58,530 --> 00:04:04,850
because the transaction is not done yet

00:04:01,310 --> 00:04:09,960
but I need to count the number of

00:04:04,850 --> 00:04:11,780
football objects-- which I just said so

00:04:09,960 --> 00:04:15,840
if there will be no flashing before the

00:04:11,780 --> 00:04:21,870
querying the count would return probably

00:04:15,840 --> 00:04:24,360
zero which is not what I want most of

00:04:21,870 --> 00:04:26,880
the time the request goes like this I'm

00:04:24,360 --> 00:04:29,310
changing a few attributes a few objects

00:04:26,880 --> 00:04:34,110
and then at the end of the transaction

00:04:29,310 --> 00:04:37,170
or request I need to list them again so

00:04:34,110 --> 00:04:39,990
that's the same story and of course the

00:04:37,170 --> 00:04:44,570
changed attributes or objects need to be

00:04:39,990 --> 00:04:44,570
listed not the original case

00:04:47,350 --> 00:04:56,820
right conflict detection as I said most

00:04:52,470 --> 00:04:59,890
no sequel databases do not handle this

00:04:56,820 --> 00:05:02,260
that means users you just write to the

00:04:59,890 --> 00:05:06,880
database then the documents and you have

00:05:02,260 --> 00:05:10,600
no idea whether someone changed it while

00:05:06,880 --> 00:05:14,100
you are doing your request so we added

00:05:10,600 --> 00:05:16,480
the under scope i underscore serial

00:05:14,100 --> 00:05:19,090
attribute which is actually just a

00:05:16,480 --> 00:05:24,430
number which gets incremented on each

00:05:19,090 --> 00:05:28,840
change this is good for conflict

00:05:24,430 --> 00:05:31,240
detection and completely a resolution we

00:05:28,840 --> 00:05:34,870
have three types of Anderson manga manga

00:05:31,240 --> 00:05:38,650
versus first one is the default there's

00:05:34,870 --> 00:05:42,700
no check conflict handler it's just

00:05:38,650 --> 00:05:48,070
ignores yeah first details but then

00:05:42,700 --> 00:05:53,950
ignores any conflict actually last flash

00:05:48,070 --> 00:05:58,060
given then the simple Syria conflict

00:05:53,950 --> 00:06:01,060
handle which will detect changes by

00:05:58,060 --> 00:06:05,830
comparing that serial number and will

00:06:01,060 --> 00:06:08,800
always raise conflict error on the third

00:06:05,830 --> 00:06:14,080
resolving Syria conflict handler which

00:06:08,800 --> 00:06:16,780
will again detect the conflict and we'll

00:06:14,080 --> 00:06:20,230
call each objects underscore p

00:06:16,780 --> 00:06:22,840
underscore little conflict method to

00:06:20,230 --> 00:06:25,350
allow the object to resolve the conflict

00:06:22,840 --> 00:06:25,350
themselves

00:06:27,140 --> 00:06:33,630
so having conflict error is a feature of

00:06:30,240 --> 00:06:36,840
zob toolkit because the hop took it with

00:06:33,630 --> 00:06:42,360
rise every request up to three times

00:06:36,840 --> 00:06:47,600
before giving up that's good because

00:06:42,360 --> 00:06:51,690
usually on the second or third try

00:06:47,600 --> 00:06:57,240
request will succeed because right

00:06:51,690 --> 00:07:01,820
conflict occurs when you get your data

00:06:57,240 --> 00:07:04,910
change by separate processes or threads

00:07:01,820 --> 00:07:07,440
request that means if your is why

00:07:04,910 --> 00:07:11,970
usually the other thread or the finished

00:07:07,440 --> 00:07:15,560
and you can do your changes so we just

00:07:11,970 --> 00:07:15,560
we try three times then give up

00:07:19,070 --> 00:07:25,730
we can have custom video serials risers

00:07:22,160 --> 00:07:30,950
in mongodb momo persist because as you

00:07:25,730 --> 00:07:35,780
see their date and it will create very

00:07:30,950 --> 00:07:41,270
very ugly Mungo data which makes let's

00:07:35,780 --> 00:07:48,530
acquiring almost impossible so in the DS

00:07:41,270 --> 00:07:51,680
serials serializer we have four methods

00:07:48,530 --> 00:07:54,770
two of them decide whether this

00:07:51,680 --> 00:07:59,270
civilized er is valid for the given data

00:07:54,770 --> 00:08:06,160
type this can read or can write and read

00:07:59,270 --> 00:08:06,160
and write itself does the wheel conversa

00:08:06,370 --> 00:08:10,360
civilization conversion

00:08:10,639 --> 00:08:16,780
you just need to register those zero

00:08:13,370 --> 00:08:21,949
dies s in Syria s dot zero address and

00:08:16,780 --> 00:08:25,340
I'm next right there with ordinal you

00:08:21,949 --> 00:08:30,189
get a nice number which you can then

00:08:25,340 --> 00:08:30,189
compare very much more easier

00:08:36,690 --> 00:08:48,540
so playing MongoDB this is one very nice

00:08:42,000 --> 00:08:50,640
feature that we chose on go DB one

00:08:48,540 --> 00:08:56,700
important thing is that you get the

00:08:50,640 --> 00:08:59,190
collection from the data manager because

00:08:56,700 --> 00:09:02,100
as I said all query methods will be

00:08:59,190 --> 00:09:04,920
arrived to flush first and if you get

00:09:02,100 --> 00:09:08,280
the collection from pymongo then it will

00:09:04,920 --> 00:09:14,790
be the bare bones collection which we

00:09:08,280 --> 00:09:17,640
are not flush the two easy ways to get

00:09:14,790 --> 00:09:20,520
the collection is by database name or

00:09:17,640 --> 00:09:24,290
collection name and the second is just

00:09:20,520 --> 00:09:24,290
use an object around

00:09:26,620 --> 00:09:32,970
you can use the usual manga collection

00:09:29,680 --> 00:09:39,370
methods fine fine one count whatever

00:09:32,970 --> 00:09:42,670
they will be wrapped with flash we

00:09:39,370 --> 00:09:45,190
provide some extra methods which oh yeah

00:09:42,670 --> 00:09:49,270
the previous ones define fine one return

00:09:45,190 --> 00:09:52,180
dict as usual for we have a few

00:09:49,270 --> 00:09:57,420
extra methods find objects and find out

00:09:52,180 --> 00:09:57,420
one object which will return real object

00:09:58,200 --> 00:10:03,550
there is data manager load which you can

00:10:01,510 --> 00:10:05,560
use if you have a database name

00:10:03,550 --> 00:10:08,290
collection name and the objects

00:10:05,560 --> 00:10:10,440
underscore ID handy to return the real

00:10:08,290 --> 00:10:10,440
object

00:10:13,410 --> 00:10:20,790
we have object caching a Mongol persist

00:10:17,720 --> 00:10:23,459
because database access and creating

00:10:20,790 --> 00:10:28,399
object in Python is quite slow so we can

00:10:23,459 --> 00:10:31,620
cache as much as we can first is

00:10:28,399 --> 00:10:34,019
database graph look up for Python

00:10:31,620 --> 00:10:38,519
classes because most of the time you

00:10:34,019 --> 00:10:41,399
need to know which class to create which

00:10:38,519 --> 00:10:45,540
class is to create the object we have

00:10:41,399 --> 00:10:48,300
object cache which toss any object that

00:10:45,540 --> 00:10:51,000
was created for the current glad because

00:10:48,300 --> 00:10:54,389
you will want to have the same very same

00:10:51,000 --> 00:10:56,970
object in the same threat there is

00:10:54,389 --> 00:11:00,540
document cash with which will store and

00:10:56,970 --> 00:11:01,889
alertly document from MongoDB so you

00:11:00,540 --> 00:11:04,189
don't have to make the trip to the

00:11:01,889 --> 00:11:04,189
database

00:11:06,430 --> 00:11:14,850
we have neat quite a lot new facility

00:11:11,310 --> 00:11:17,410
which looks because listed there

00:11:14,850 --> 00:11:21,240
including their attributes and keyboard

00:11:17,410 --> 00:11:26,790
attributes now why we did this is

00:11:21,240 --> 00:11:26,790
because you can have trace back locked

00:11:26,970 --> 00:11:31,810
you know MongoDB has its own quite

00:11:29,649 --> 00:11:33,990
logging facility but that definitely

00:11:31,810 --> 00:11:36,940
will not give you the trace backs

00:11:33,990 --> 00:11:40,450
sometimes it's very interesting from

00:11:36,940 --> 00:11:45,779
where your query or find method gets

00:11:40,450 --> 00:11:48,940
called also nice feature of soap is

00:11:45,779 --> 00:11:51,459
Dunder traceback info where you can put

00:11:48,940 --> 00:11:53,670
any data and that shows up in the trace

00:11:51,459 --> 00:11:53,670
back

00:11:58,460 --> 00:12:04,130
now we are getting two containers and

00:12:00,500 --> 00:12:08,810
collections nothing mangu con collection

00:12:04,130 --> 00:12:12,280
mapping is a dict actually its

00:12:08,810 --> 00:12:15,080
subclasses use a dick dick magazine

00:12:12,280 --> 00:12:18,920
which should give you all the methods as

00:12:15,080 --> 00:12:22,790
a big does so get items that item the

00:12:18,920 --> 00:12:26,540
light and keys items values whatever you

00:12:22,790 --> 00:12:30,700
want with the dunder manga collection

00:12:26,540 --> 00:12:34,160
property you specify the collection name

00:12:30,700 --> 00:12:40,450
where you want the items stored within

00:12:34,160 --> 00:12:44,270
the database the dunder mangu map MK is

00:12:40,450 --> 00:12:47,420
that you specify the object attribute

00:12:44,270 --> 00:12:49,930
which should be taken as the key of the

00:12:47,420 --> 00:12:49,930
mapping

00:12:55,790 --> 00:13:02,510
so this is the cpk ish corner why it's

00:12:59,540 --> 00:13:07,310
not just because it provides a lot of

00:13:02,510 --> 00:13:11,390
nice features and the soap edition is

00:13:07,310 --> 00:13:14,570
just the event it goes on at being an

00:13:11,390 --> 00:13:17,870
item to container or modifying object in

00:13:14,570 --> 00:13:19,910
so fires event but you don't need to

00:13:17,870 --> 00:13:25,520
care about those events if you are not

00:13:19,910 --> 00:13:28,060
using this all took it contained

00:13:25,520 --> 00:13:33,160
container than the named under parent I

00:13:28,060 --> 00:13:36,590
used in usual cpk applications or Zod be

00:13:33,160 --> 00:13:41,570
applications to build neat three

00:13:36,590 --> 00:13:44,060
structure and there there is very

00:13:41,570 --> 00:13:48,970
important to have let sit under named on

00:13:44,060 --> 00:13:48,970
the parent because of security and stuff

00:13:51,730 --> 00:14:01,300
no more contained is the counterpart

00:13:53,649 --> 00:14:04,839
part of the cpk contained class and it

00:14:01,300 --> 00:14:09,339
has to work quite hard on setting the

00:14:04,839 --> 00:14:11,230
dunder named under parent properties Don

00:14:09,339 --> 00:14:14,740
the point shouldn't be stored in the

00:14:11,230 --> 00:14:20,220
database because it might cause circular

00:14:14,740 --> 00:14:22,839
references but it's really needed to

00:14:20,220 --> 00:14:30,149
have a neatly working security system

00:14:22,839 --> 00:14:35,399
with cdk1 go container is again a

00:14:30,149 --> 00:14:41,380
mapping like interface but but it adds

00:14:35,399 --> 00:14:44,070
more features on top of the bear mobile

00:14:41,380 --> 00:14:47,889
collection like add where you can just

00:14:44,070 --> 00:14:55,240
simply add an object without knowing its

00:14:47,889 --> 00:14:57,610
key find find one returns object but

00:14:55,240 --> 00:15:00,550
those objects are contained constrained

00:14:57,610 --> 00:15:05,279
to the scope of the container because

00:15:00,550 --> 00:15:09,449
imagine in the route I have let say

00:15:05,279 --> 00:15:16,050
persons and employees and balls are

00:15:09,449 --> 00:15:16,050
stored in the same sort of container

00:15:16,199 --> 00:15:21,570
let's say two companies company a

00:15:18,490 --> 00:15:25,620
company b persons

00:15:21,570 --> 00:15:28,440
and if I query company a I don't want

00:15:25,620 --> 00:15:30,480
the person's of Company B so I have to

00:15:28,440 --> 00:15:40,830
filter or actually the content of

00:15:30,480 --> 00:15:44,160
filters the right items it has it will

00:15:40,830 --> 00:15:47,970
have only those items in it and find

00:15:44,160 --> 00:15:51,420
find one we will also constrain by

00:15:47,970 --> 00:15:56,010
adding the spec the rights back those

00:15:51,420 --> 00:16:03,030
items row fine narrow fine 112 part we

00:15:56,010 --> 00:16:06,150
are way too and success I didn't

00:16:03,030 --> 00:16:08,340
smuggle container uses the items object

00:16:06,150 --> 00:16:14,450
ids key so you don't have to provide

00:16:08,340 --> 00:16:14,450
your own name or key or whatever

00:16:19,900 --> 00:16:24,510
use your web application will be

00:16:21,610 --> 00:16:28,920
probably more solid so each thread

00:16:24,510 --> 00:16:32,920
should have its own manga data manager

00:16:28,920 --> 00:16:36,330
we have utility for that it's called

00:16:32,920 --> 00:16:39,910
mudita manager provider which you set up

00:16:36,330 --> 00:16:44,200
just once for the whole application and

00:16:39,910 --> 00:16:51,330
they need each request set up you do get

00:16:44,200 --> 00:16:51,330
the utility and instantiate data manager

00:16:52,530 --> 00:16:59,680
yes this is soap component architecture

00:16:55,860 --> 00:17:05,440
in play but don't be afraid if you

00:16:59,680 --> 00:17:08,950
import the right packages and do as the

00:17:05,440 --> 00:17:12,240
example does it will just work don't be

00:17:08,950 --> 00:17:12,240
afraid of the details

00:17:16,190 --> 00:17:22,810
and a patient's this is also a nice

00:17:18,500 --> 00:17:28,850
feature of ztk or so you can store

00:17:22,810 --> 00:17:33,910
metadata or any on any object something

00:17:28,850 --> 00:17:33,910
like dublin core permissions or whatever

00:17:34,090 --> 00:17:43,250
well dublin core is standard for

00:17:36,470 --> 00:17:46,990
metadata like creating modified which

00:17:43,250 --> 00:17:50,360
usually use with let's say document

00:17:46,990 --> 00:17:54,530
those get automatically updated by soap

00:17:50,360 --> 00:17:57,380
event but you don't have to care about

00:17:54,530 --> 00:17:59,800
this as i said if you are not using ztk

00:17:57,380 --> 00:17:59,800
or so

00:18:04,710 --> 00:18:08,000
and that was it

00:18:16,630 --> 00:18:20,440
professor west hills

00:18:31,840 --> 00:18:36,749
these

00:18:33,299 --> 00:18:38,879
thanks for the talk so how does this

00:18:36,749 --> 00:18:41,519
compare have you done any comparison

00:18:38,879 --> 00:18:47,970
speed wise to actually using just zody

00:18:41,519 --> 00:18:54,450
be comparison not but it should be on

00:18:47,970 --> 00:18:58,860
par because yes yo DB which is most of

00:18:54,450 --> 00:19:03,230
the time fire based back end which is

00:18:58,860 --> 00:19:05,909
also local for mongodb you have to go

00:19:03,230 --> 00:19:09,629
through the network maybe or if its

00:19:05,909 --> 00:19:14,359
local down also local but it should be

00:19:09,629 --> 00:19:14,359
very much on par thank you

00:19:19,110 --> 00:19:27,279
the do you handle how to recognize

00:19:22,499 --> 00:19:31,720
exception you may in the conflict know

00:19:27,279 --> 00:19:33,370
when when when you try to do a query in

00:19:31,720 --> 00:19:35,970
with my mum when it fails and it

00:19:33,370 --> 00:19:39,039
launches a another iconic exception

00:19:35,970 --> 00:19:41,620
which means that it will take electronic

00:19:39,039 --> 00:19:44,559
regalia so it should work the second

00:19:41,620 --> 00:19:48,999
time the most of the cases would I don't

00:19:44,559 --> 00:19:52,119
think so at the moment and another one

00:19:48,999 --> 00:19:55,809
did you compare or did you check a mini

00:19:52,119 --> 00:20:00,779
manga weenie manga a library quite

00:19:55,809 --> 00:20:00,779
similar oh he has less features

00:20:07,929 --> 00:20:13,749
the thing is actually because the

00:20:10,450 --> 00:20:17,769
persistent package is coming from Zod be

00:20:13,749 --> 00:20:22,960
so it's quite handy in this case because

00:20:17,769 --> 00:20:25,240
it does the persistence will we are

00:20:22,960 --> 00:20:29,039
notified that an icky boot was changed

00:20:25,240 --> 00:20:32,460
so you don't have to do the handstand

00:20:29,039 --> 00:20:32,460
just in case

00:20:35,340 --> 00:20:38,660
any other question

00:20:42,270 --> 00:20:48,340
so busy and one so I call my next talk

00:20:45,669 --> 00:20:52,570
will be a Phi p.m. here about to singing

00:20:48,340 --> 00:20:54,130
all dancing python by code so but jacket

00:20:52,570 --> 00:20:59,279
or gram for all the events of this

00:20:54,130 --> 00:21:03,570
afternoon now we are almost in launcher

00:20:59,279 --> 00:21:03,570

YouTube URL: https://www.youtube.com/watch?v=-S7KS-1-wdc


