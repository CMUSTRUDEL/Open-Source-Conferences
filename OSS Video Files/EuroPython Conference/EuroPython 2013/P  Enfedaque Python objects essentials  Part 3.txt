Title: P  Enfedaque Python objects essentials  Part 3
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	[Europython 2013]
P  Enfedaque Python objects essentials  Part 3
2 July 2013
TRACK pizza margherita
Captions: 
	00:00:00,000 --> 00:00:05,910
like a kind of closed classes and closed

00:00:03,240 --> 00:00:07,080
instances they cannot be modified it is

00:00:05,910 --> 00:00:09,360
the first thing that they would do and

00:00:07,080 --> 00:00:11,099
then I would implement the attribute

00:00:09,360 --> 00:00:22,230
axis and items access to avoid

00:00:11,099 --> 00:00:26,369
modifications may be okay so the as I

00:00:22,230 --> 00:00:30,359
said this success is is longer than the

00:00:26,369 --> 00:00:34,710
previous one and it's more complex there

00:00:30,359 --> 00:00:37,770
are two kinds of things to solve in in

00:00:34,710 --> 00:00:39,600
one case there is a problem of all style

00:00:37,770 --> 00:00:42,840
classes inheritance you have to solve it

00:00:39,600 --> 00:00:46,340
this is quite easy but then you have to

00:00:42,840 --> 00:00:50,280
implement to let's say amazing classes

00:00:46,340 --> 00:00:52,620
you have to implement do you remember

00:00:50,280 --> 00:00:55,379
well I have implemented in the exercise

00:00:52,620 --> 00:00:59,250
that is a custom order a big do you know

00:00:55,379 --> 00:01:02,550
what is or that dick in collections you

00:00:59,250 --> 00:01:04,080
have this this this this data type which

00:01:02,550 --> 00:01:07,409
is a dictionary which remembers the

00:01:04,080 --> 00:01:10,710
order way of keys that you added to this

00:01:07,409 --> 00:01:16,290
dictionary so what I want you to do is

00:01:10,710 --> 00:01:19,799
to implement a slicing a slicing of this

00:01:16,290 --> 00:01:23,750
custom order a big and I also want you

00:01:19,799 --> 00:01:27,390
to implement addition and subtraction

00:01:23,750 --> 00:01:30,210
the thing is that well it's a bit it's

00:01:27,390 --> 00:01:33,930
interesting implemented it's harder than

00:01:30,210 --> 00:01:38,130
the previous exercise of course and the

00:01:33,930 --> 00:01:39,990
second the third exercise you have to

00:01:38,130 --> 00:01:43,229
modify the attribute dick that I have

00:01:39,990 --> 00:01:45,149
shown you here and you have to modify

00:01:43,229 --> 00:01:50,549
the behavior it's something kite

00:01:45,149 --> 00:01:53,399
specific so you just have to make it to

00:01:50,549 --> 00:01:57,270
make it access the keys only if they

00:01:53,399 --> 00:01:59,820
exist another wise so so you remember we

00:01:57,270 --> 00:02:02,009
implemented attribute access so you have

00:01:59,820 --> 00:02:04,860
to me limit data would access to access

00:02:02,009 --> 00:02:07,590
the keys only when they already exist as

00:02:04,860 --> 00:02:09,390
a key otherwise you have to behave like

00:02:07,590 --> 00:02:15,120
if it was a

00:02:09,390 --> 00:02:17,220
attribute of your of your class okay so

00:02:15,120 --> 00:02:21,750
on one hand you have to change the

00:02:17,220 --> 00:02:23,220
custom order dick you have to change do

00:02:21,750 --> 00:02:26,520
you have to solve the inner a tense

00:02:23,220 --> 00:02:28,350
problem of custom option parcel and you

00:02:26,520 --> 00:02:33,630
have to modify that you would dig to

00:02:28,350 --> 00:02:40,530
have this more specific behavior ok you

00:02:33,630 --> 00:02:42,180
have you have the exercises folder and

00:02:40,530 --> 00:02:44,730
inside the exercises folder there is an

00:02:42,180 --> 00:02:48,180
exercise to folder and there you have

00:02:44,730 --> 00:02:50,400
three files the exercise that you have

00:02:48,180 --> 00:02:53,300
to modify the tests that you have to run

00:02:50,400 --> 00:02:55,620
with nose test and you have a solution

00:02:53,300 --> 00:02:57,750
you can check the solution if you want

00:02:55,620 --> 00:03:00,600
to compare with your solution or if you

00:02:57,750 --> 00:03:02,519
really get stuck whatever you at the end

00:03:00,600 --> 00:03:04,950
we will compare the solutions and we

00:03:02,519 --> 00:03:08,580
will discuss about it and will find

00:03:04,950 --> 00:03:10,260
actually we will will find interesting

00:03:08,580 --> 00:03:11,610
things to discuss with the solution

00:03:10,260 --> 00:03:14,579
because most probably you will implement

00:03:11,610 --> 00:03:15,989
something's different they desk to that

00:03:14,579 --> 00:03:18,570
you start working with it and start

00:03:15,989 --> 00:03:20,489
customizing for first time your objects

00:03:18,570 --> 00:03:22,680
or in this case my objects but start

00:03:20,489 --> 00:03:25,440
dealing with customization and and see

00:03:22,680 --> 00:03:28,170
possible pitfalls and this kind of

00:03:25,440 --> 00:03:32,940
things ok so let's say that i'm going to

00:03:28,170 --> 00:03:35,010
leave maybe 20 or 30 minutes in 20

00:03:32,940 --> 00:03:36,630
minutes i will ask you how you how are

00:03:35,010 --> 00:03:38,489
you doing ok and let's see how many

00:03:36,630 --> 00:03:41,760
people has finished or where are you

00:03:38,489 --> 00:03:45,480
okay and and then we will see if we live

00:03:41,760 --> 00:03:47,670
more or less time and so on and if you

00:03:45,480 --> 00:03:50,790
have any questions I'm here for the new

00:03:47,670 --> 00:03:53,280
people that came at the break I have a

00:03:50,790 --> 00:03:57,600
memory bandwidth the code otherwise in

00:03:53,280 --> 00:03:59,549
in the page of the new Python website if

00:03:57,600 --> 00:04:01,079
you go to the talk you will find a link

00:03:59,549 --> 00:04:04,350
to it hub where you can download the

00:04:01,079 --> 00:04:10,040
code and you only need Python 2007 and

00:04:04,350 --> 00:04:10,040
knows this ok so let's start

00:14:20,949 --> 00:14:26,000
okay it has been 10 minutes how are you

00:14:23,449 --> 00:14:31,279
doing how many has been II have finished

00:14:26,000 --> 00:14:34,910
the first one the thing of the newest I

00:14:31,279 --> 00:14:41,029
love the style inheritance okay good the

00:14:34,910 --> 00:14:45,529
DC and the second one how many of you

00:14:41,029 --> 00:14:49,490
have finished nobody good good then it's

00:14:45,529 --> 00:14:50,930
difficult good so here I had two

00:14:49,490 --> 00:14:55,040
questions I think it's important to

00:14:50,930 --> 00:14:57,560
share with you one question was in the

00:14:55,040 --> 00:15:00,680
attribute dick customization how we have

00:14:57,560 --> 00:15:03,110
to handle as a the data would so the

00:15:00,680 --> 00:15:05,689
thing is okay I check and needs not a

00:15:03,110 --> 00:15:08,029
key in the dictionary and then how I

00:15:05,689 --> 00:15:10,939
handle it what should I do the thing is

00:15:08,029 --> 00:15:12,709
that you should not handle it it's it's

00:15:10,939 --> 00:15:14,480
not the responsibility so call your

00:15:12,709 --> 00:15:16,430
super class and let the super class

00:15:14,480 --> 00:15:18,680
handle data would as a standard

00:15:16,430 --> 00:15:21,019
attribute access instead of doing it

00:15:18,680 --> 00:15:23,870
yourself and let the super class do it

00:15:21,019 --> 00:15:25,630
oh that's that that's the way I think

00:15:23,870 --> 00:15:28,160
that you should focus the problem

00:15:25,630 --> 00:15:29,569
because if you try to process the

00:15:28,160 --> 00:15:33,500
attribute to civility wit and do it

00:15:29,569 --> 00:15:35,779
everything yourself it's it's wet it's

00:15:33,500 --> 00:15:37,189
not what you wanted to do in your Indian

00:15:35,779 --> 00:15:39,889
subclass and it's something that it's

00:15:37,189 --> 00:15:41,959
already implemented somewhere so forget

00:15:39,889 --> 00:15:44,329
about how to implement it yourself and

00:15:41,959 --> 00:15:46,639
the legate to somebody that must

00:15:44,329 --> 00:15:48,709
probably knows how to do it and the

00:15:46,639 --> 00:15:51,470
other question was regarding the the

00:15:48,709 --> 00:15:55,810
addition and subtraction of dictionaries

00:15:51,470 --> 00:15:59,000
and and the thing is and why should

00:15:55,810 --> 00:16:03,829
should you return a new dictionary or

00:15:59,000 --> 00:16:05,750
should you update the the left side

00:16:03,829 --> 00:16:09,910
argument of the addition of the

00:16:05,750 --> 00:16:15,620
subtraction so in this case I have I

00:16:09,910 --> 00:16:17,839
choose I choose have chosen the first

00:16:15,620 --> 00:16:20,480
one to return a new object because maybe

00:16:17,839 --> 00:16:23,860
the most current thing the most current

00:16:20,480 --> 00:16:26,449
behavior compared with other other a

00:16:23,860 --> 00:16:29,720
standard types when you assume two

00:16:26,449 --> 00:16:31,459
numbers you get a new number when you

00:16:29,720 --> 00:16:33,449
assume two floats you get a new flock

00:16:31,459 --> 00:16:36,389
when you assume two strings you get any

00:16:33,449 --> 00:16:38,269
three you could think okay but it this

00:16:36,389 --> 00:16:40,679
behavior is normal because they are

00:16:38,269 --> 00:16:43,290
immutable and they cannot be changed

00:16:40,679 --> 00:16:46,350
yeah but when you assume two lists it

00:16:43,290 --> 00:16:48,509
has her rhythms and you list so that's

00:16:46,350 --> 00:16:51,689
why I'm returning a list would it be

00:16:48,509 --> 00:16:54,089
possible to customize the addition and

00:16:51,689 --> 00:16:56,249
subtraction to modify directly the

00:16:54,089 --> 00:16:58,919
object yes you can do it it's up to you

00:16:56,249 --> 00:17:01,709
but very mind that then maybe this

00:16:58,919 --> 00:17:04,709
operation is not so Corran with with the

00:17:01,709 --> 00:17:07,199
rest of standard types and maybe if

00:17:04,709 --> 00:17:09,689
somebody has to use your library your

00:17:07,199 --> 00:17:11,789
classes and it's not aware that the

00:17:09,689 --> 00:17:14,399
addition modifies the object it could be

00:17:11,789 --> 00:17:16,110
problematic so you have to understand

00:17:14,399 --> 00:17:18,929
both points of views I would love to

00:17:16,110 --> 00:17:21,179
have a sim an open and say okay I want

00:17:18,929 --> 00:17:23,399
to update the left side dictionary with

00:17:21,179 --> 00:17:26,669
this other dictionary instead of calling

00:17:23,399 --> 00:17:28,500
the update method i will let you have an

00:17:26,669 --> 00:17:32,220
operation it would be it would be lovely

00:17:28,500 --> 00:17:36,389
because it would save typing a bit but

00:17:32,220 --> 00:17:38,010
it's not so Corran maybe so well this

00:17:36,389 --> 00:17:39,470
this is the description I said that that

00:17:38,010 --> 00:17:42,149
we could find solving this problem

00:17:39,470 --> 00:17:44,460
sometimes it's difficult to implement

00:17:42,149 --> 00:17:47,370
some behavior that is expected it's a

00:17:44,460 --> 00:17:50,580
sign maybe for other kinds of types so

00:17:47,370 --> 00:17:52,260
it's you see the vision of twins and you

00:17:50,580 --> 00:17:55,710
understand perfectly how words the

00:17:52,260 --> 00:17:58,529
addition of twins but but when you are

00:17:55,710 --> 00:18:01,289
assuming two dictionaries well it's

00:17:58,529 --> 00:18:04,380
different or or or maybe other more

00:18:01,289 --> 00:18:06,120
complex classes and that that you will

00:18:04,380 --> 00:18:10,279
have when when you're implementing the

00:18:06,120 --> 00:18:10,279
business logic at home or wherever

00:18:14,080 --> 00:18:20,860
so I live 10 more minutes and I check

00:18:17,870 --> 00:18:20,860
again how are you doing

00:20:05,880 --> 00:20:11,950
another question here was the arguments

00:20:08,950 --> 00:20:13,990
of working with with dictionaries bear

00:20:11,950 --> 00:20:24,670
in mind that it's possible to construct

00:20:13,990 --> 00:20:36,610
a dictionary this way great aah sorry

00:20:24,670 --> 00:20:38,910
aah yeah it's better if I put it this

00:20:36,610 --> 00:20:38,910
way

00:20:48,809 --> 00:20:55,320
ok so when providing a list of tuples or

00:20:52,000 --> 00:20:59,730
I could provide a couple of tuples and

00:20:55,320 --> 00:21:03,759
the internal tapas half lengths to and

00:20:59,730 --> 00:21:08,279
dictionary will interpret it as key

00:21:03,759 --> 00:21:11,889
value key value ok key a value 1 TB

00:21:08,279 --> 00:21:13,899
value two ok and you can use also this

00:21:11,889 --> 00:21:16,889
this format when you call the update

00:21:13,899 --> 00:21:21,759
method of of the dick class or when you

00:21:16,889 --> 00:21:24,100
use a constructor and so on so with the

00:21:21,759 --> 00:21:27,820
test I'm using this format in some

00:21:24,100 --> 00:21:31,210
places and I also use zip with zip it

00:21:27,820 --> 00:21:36,690
takes two sequences two or more

00:21:31,210 --> 00:21:36,690
sequences and need it returned spares

00:21:41,770 --> 00:21:49,060
so with zip I can construct the this

00:21:45,370 --> 00:21:51,840
input here in a more easier way there is

00:21:49,060 --> 00:21:51,840
a built-in function

00:23:53,549 --> 00:24:02,739
so how is it going let's raise your hand

00:23:59,559 --> 00:24:06,909
if you have finished besides the first

00:24:02,739 --> 00:24:12,549
one besides FS exercise also one of the

00:24:06,909 --> 00:24:15,549
other two one hand oops too ok two three

00:24:12,549 --> 00:24:18,700
ok the thing is that we're running out

00:24:15,549 --> 00:24:21,879
of time we have taken lots of time with

00:24:18,700 --> 00:24:27,669
explanation maybe too much and we should

00:24:21,879 --> 00:24:30,279
try to move on ok so well if you want

00:24:27,669 --> 00:24:34,089
you can continue with exercise or let's

00:24:30,279 --> 00:24:36,070
let's both maybe or we continue with

00:24:34,089 --> 00:24:38,169
exercise either we continuously site and

00:24:36,070 --> 00:24:40,330
I will have to shorten the other

00:24:38,169 --> 00:24:43,629
explanations of the rest of the training

00:24:40,330 --> 00:24:47,769
or we leave the exercise here we discuss

00:24:43,629 --> 00:24:50,619
a solution and then I will not shorten

00:24:47,769 --> 00:24:53,109
so much the rest of the training so who

00:24:50,619 --> 00:24:56,019
wants to end exercise now let's what

00:24:53,109 --> 00:25:00,309
raise your hand ok I think that we will

00:24:56,019 --> 00:25:06,969
finish exercise now good ok so let's go

00:25:00,309 --> 00:25:10,989
ahead with the solutions so here the

00:25:06,969 --> 00:25:18,070
inheritance was wrong and which was a

00:25:10,989 --> 00:25:22,779
solution volunteer yeah in a different

00:25:18,070 --> 00:25:26,499
object that's it pretty easy if you read

00:25:22,779 --> 00:25:28,389
it from from from another style class

00:25:26,499 --> 00:25:30,820
just inherit from object and you will be

00:25:28,389 --> 00:25:33,969
able to customize all these kind of

00:25:30,820 --> 00:25:35,799
things that we have done right now ok if

00:25:33,969 --> 00:25:37,450
you don't do it you won't be able to do

00:25:35,799 --> 00:25:40,619
it and you will have problems and you

00:25:37,450 --> 00:25:42,969
will find a stranger or sometimes it's

00:25:40,619 --> 00:25:45,460
sometimes it's a bit difficult to

00:25:42,969 --> 00:25:46,960
realize that you are really in editing

00:25:45,460 --> 00:25:49,719
from analyst type class maybe that

00:25:46,960 --> 00:25:53,229
laziest thing is to use the type as I

00:25:49,719 --> 00:25:57,719
did at the beginning of the the of this

00:25:53,229 --> 00:25:57,719
model ok and and then you can check it

00:25:58,169 --> 00:26:04,239
yeah you just type and then it looks

00:26:01,419 --> 00:26:05,030
Korean compared with class otherwise it

00:26:04,239 --> 00:26:08,450
wouldn't

00:26:05,030 --> 00:26:13,490
and if you try to annotate and do things

00:26:08,450 --> 00:26:16,820
is you would get strange errors so next

00:26:13,490 --> 00:26:19,430
example you have to implement slicing

00:26:16,820 --> 00:26:22,220
addition and subtraction and this is the

00:26:19,430 --> 00:26:24,470
right implementation look we discuss

00:26:22,220 --> 00:26:26,570
about it previously and this is how you

00:26:24,470 --> 00:26:30,020
have to do you are going to receive a

00:26:26,570 --> 00:26:33,140
slice object this is kai tricky as i

00:26:30,020 --> 00:26:36,590
said as i said initially we had a

00:26:33,140 --> 00:26:39,080
underscore underscore get slice but then

00:26:36,590 --> 00:26:41,600
it was removed and it and you have to

00:26:39,080 --> 00:26:45,910
implement it a swing at item so you get

00:26:41,600 --> 00:26:48,920
item method is able to deal with indexes

00:26:45,910 --> 00:26:50,900
like accessing a certain position inside

00:26:48,920 --> 00:26:53,390
the list or at apple is able to deal

00:26:50,900 --> 00:26:57,560
with keys like accessing a dictionary

00:26:53,390 --> 00:26:59,000
and it is able to deal with slicing and

00:26:57,560 --> 00:27:01,160
in this case we are implementing

00:26:59,000 --> 00:27:07,190
something maybe a bit strange because

00:27:01,160 --> 00:27:09,920
it's like you are doing a slicing of a

00:27:07,190 --> 00:27:11,330
dictionary which is strange but it's up

00:27:09,920 --> 00:27:13,520
to you you have to customize your

00:27:11,330 --> 00:27:15,910
objects as you want no as you feel that

00:27:13,520 --> 00:27:18,680
that you are able to do it as I said

00:27:15,910 --> 00:27:20,420
bear in mind that maybe later other

00:27:18,680 --> 00:27:23,780
people have to use your classes your

00:27:20,420 --> 00:27:25,760
instances I have to deal with them so do

00:27:23,780 --> 00:27:30,020
things in a coiling way and done and

00:27:25,760 --> 00:27:33,770
done the new kind of black magic or this

00:27:30,020 --> 00:27:36,410
kind of strange stuff okay in this case

00:27:33,770 --> 00:27:43,600
I bet on a new instance remember is

00:27:36,410 --> 00:27:48,980
slicing always veterans a new object and

00:27:43,600 --> 00:27:51,170
I just use a slicing in the items so if

00:27:48,980 --> 00:27:56,290
I take a dictionary for instance this

00:27:51,170 --> 00:27:56,290
dictionary i created a while ago sorry

00:28:06,880 --> 00:28:15,500
if you call to the items method you get

00:28:09,800 --> 00:28:18,200
this list so I'm just creating a

00:28:15,500 --> 00:28:23,090
dictionary I knew actually a new custom

00:28:18,200 --> 00:28:27,740
order dick providing this list but

00:28:23,090 --> 00:28:36,590
applying the slicing inside it ok

00:28:27,740 --> 00:28:42,860
questions understood ok so addition and

00:28:36,590 --> 00:28:45,230
subtraction the thing is that with this

00:28:42,860 --> 00:28:47,180
cousin and it's what we discussed a few

00:28:45,230 --> 00:28:49,250
moments ago that it's up to you if you

00:28:47,180 --> 00:28:50,890
want to update your own object or you

00:28:49,250 --> 00:28:53,270
want to create a new object and updated

00:28:50,890 --> 00:28:57,470
it's up to you and you have to you have

00:28:53,270 --> 00:28:59,390
to you have to decide the way you apply

00:28:57,470 --> 00:29:02,210
it in this case I created anyone because

00:28:59,390 --> 00:29:05,090
I feel that it's more coding with the

00:29:02,210 --> 00:29:07,010
addition of least numbers doubles or

00:29:05,090 --> 00:29:09,080
whatever ok and the same with a

00:29:07,010 --> 00:29:11,270
subtraction but in the subtraction I

00:29:09,080 --> 00:29:13,730
don't have the update method so I have

00:29:11,270 --> 00:29:16,820
to do it in a more tricky way where they

00:29:13,730 --> 00:29:19,430
have to implement it this is called list

00:29:16,820 --> 00:29:22,490
comprehension so I'm not pretty sure if

00:29:19,430 --> 00:29:26,060
you are if you are familiar with with

00:29:22,490 --> 00:29:28,670
with the student axis it's like a kind

00:29:26,060 --> 00:29:35,140
of for loop but expressed in a different

00:29:28,670 --> 00:29:38,720
way yeah i'm not using it result but i'm

00:29:35,140 --> 00:29:41,240
calling it this way yeah maybe the thing

00:29:38,720 --> 00:29:44,050
is that one day i should i just i should

00:29:41,240 --> 00:29:46,730
have put a more understandable

00:29:44,050 --> 00:29:49,570
implementation sorry for this yeah there

00:29:46,730 --> 00:29:49,570
was a question that I think

00:29:54,370 --> 00:30:03,860
my nose between sets like all the

00:30:00,230 --> 00:30:06,710
elements that are in the first that are

00:30:03,860 --> 00:30:11,650
not in the in the second are in the

00:30:06,710 --> 00:30:16,220
minds and in the the the result of sub

00:30:11,650 --> 00:30:19,460
if I have to set an eye s1 and s2 and

00:30:16,220 --> 00:30:23,780
ice I visit what this is what I do here

00:30:19,460 --> 00:30:26,660
s2 i have a new set with those yeah yeah

00:30:23,780 --> 00:30:30,880
yeah you mean you mean to remove the

00:30:26,660 --> 00:30:33,980
intersection of the set right remove the

00:30:30,880 --> 00:30:35,570
the other intersection yes with

00:30:33,980 --> 00:30:37,640
intersection you get the elements in

00:30:35,570 --> 00:30:40,610
both and then you remove from the first

00:30:37,640 --> 00:30:44,560
set the elements of intersection yeah

00:30:40,610 --> 00:30:48,590
this is what it does here but but maybe

00:30:44,560 --> 00:30:50,780
yeah the thing is all just that i put

00:30:48,590 --> 00:30:52,700
here known so in this case it doesn't

00:30:50,780 --> 00:30:55,460
give an error if i tried to subtract a

00:30:52,700 --> 00:31:01,220
key which was not present in the in the

00:30:55,460 --> 00:31:07,100
in the first dictionary okay so we try

00:31:01,220 --> 00:31:09,260
it and it worked fine we can assume to a

00:31:07,100 --> 00:31:11,360
slices of the same dictionary and it is

00:31:09,260 --> 00:31:16,960
almost the same dictionary without the

00:31:11,360 --> 00:31:20,510
index which is indexed three ok it works

00:31:16,960 --> 00:31:23,330
and now the implementation of that you

00:31:20,510 --> 00:31:26,810
would because I said the thing here is

00:31:23,330 --> 00:31:30,350
that I rely on the on the ancestor on

00:31:26,810 --> 00:31:34,390
the superclass to perform the management

00:31:30,350 --> 00:31:34,390
of attributes ok yeah

00:31:39,130 --> 00:31:44,840
we are going to be supper in the next

00:31:42,080 --> 00:31:49,010
model that's why yet there he asked

00:31:44,840 --> 00:31:51,530
something because it's not bandage he

00:31:49,010 --> 00:31:54,050
knows super which is the thing that we

00:31:51,530 --> 00:32:01,370
are going to see in the next module so

00:31:54,050 --> 00:32:03,230
so yeah actually it works fine you can

00:32:01,370 --> 00:32:05,120
check the solution later and see it and

00:32:03,230 --> 00:32:06,800
if you have more doubts you can i'll be

00:32:05,120 --> 00:32:11,740
here the whole week so you can ask me

00:32:06,800 --> 00:32:14,480
and the thing as as was asked is that

00:32:11,740 --> 00:32:21,190
there is a way to implement it still

00:32:14,480 --> 00:32:24,350
better and let's go through it okay

00:32:21,190 --> 00:32:26,000
links to all the documentation all the

00:32:24,350 --> 00:32:30,680
official documentation for this stuff

00:32:26,000 --> 00:32:32,810
okay and let's move ahead we are going

00:32:30,680 --> 00:32:38,530
to see method resolution order supper

00:32:32,810 --> 00:32:38,530
and get attr okay let's see how it works

00:32:39,220 --> 00:32:45,470
okay let's imagine that wimp lemon other

00:32:42,800 --> 00:32:48,380
boss dictionary in this case the only

00:32:45,470 --> 00:32:51,830
thing that we are doing is printing each

00:32:48,380 --> 00:32:57,710
time an attribute this access an item is

00:32:51,830 --> 00:33:01,990
accessed or modified okay check this we

00:32:57,710 --> 00:33:04,700
have great attribute and get it it here

00:33:01,990 --> 00:33:07,250
we have seen gated it here this is

00:33:04,700 --> 00:33:11,960
called only when the attribute is not

00:33:07,250 --> 00:33:16,010
found okay and we attribute is called

00:33:11,960 --> 00:33:19,100
always so if you want to intercept the

00:33:16,010 --> 00:33:23,030
attribute access always you can use

00:33:19,100 --> 00:33:29,380
getattribute instead of get a tier okay

00:33:23,030 --> 00:33:32,750
you have both and it's up to you so

00:33:29,380 --> 00:33:37,820
pretty stupid dictionary it just prints

00:33:32,750 --> 00:33:40,640
I access the key three sorry the key C

00:33:37,820 --> 00:33:45,250
and it I tried to change its value two

00:33:40,640 --> 00:33:47,960
three so my my my class Prince this

00:33:45,250 --> 00:33:50,330
formation

00:33:47,960 --> 00:33:54,950
I take to access attributes and it

00:33:50,330 --> 00:33:56,480
brings again I tried to access an

00:33:54,950 --> 00:34:00,980
attribute and its capture by they

00:33:56,480 --> 00:34:03,230
attribute so on so pretty simple okay it

00:34:00,980 --> 00:34:05,630
just prints what I'm trying to access

00:34:03,230 --> 00:34:12,590
inside a tribute at a tribute or class

00:34:05,630 --> 00:34:15,560
or sorry or or item so the thing is what

00:34:12,590 --> 00:34:18,220
happens if we want we want to merge this

00:34:15,560 --> 00:34:20,810
behavior with our previous at you dick

00:34:18,220 --> 00:34:24,170
we plant a dictionary with a tribute

00:34:20,810 --> 00:34:26,000
access and we have a dictionary which

00:34:24,170 --> 00:34:29,210
prints all the excesses that we are

00:34:26,000 --> 00:34:36,430
doing and we will both how we should

00:34:29,210 --> 00:34:36,430
solve it so minus the solution anybody

00:34:37,330 --> 00:34:43,310
okay there are different options yeah

00:34:41,840 --> 00:34:47,920
this was the implementation of the

00:34:43,310 --> 00:34:50,570
triple deke the previous 2d option one

00:34:47,920 --> 00:34:55,930
multiple inheritance right it's here

00:34:50,570 --> 00:34:59,000
it's easy to use it just right here the

00:34:55,930 --> 00:35:04,550
old ancestors classes and it should work

00:34:59,000 --> 00:35:11,120
let's try it oops something happens look

00:35:04,550 --> 00:35:16,850
I say x equals 7 and X does not appear

00:35:11,120 --> 00:35:19,700
here ok so it's not working at all it

00:35:16,850 --> 00:35:24,140
prints all the excesses but it's not

00:35:19,700 --> 00:35:25,820
attribute dick it's not being used or

00:35:24,140 --> 00:35:29,630
the attribute the behavior is not being

00:35:25,820 --> 00:35:31,430
used we do the other way we use

00:35:29,630 --> 00:35:32,840
attribute dick and we use verbose leak

00:35:31,430 --> 00:35:36,410
and we change the order of the ancestors

00:35:32,840 --> 00:35:38,780
what happens is that now activity quirks

00:35:36,410 --> 00:35:43,430
better actually have change oh sorry no

00:35:38,780 --> 00:35:48,260
we change a and here a is changed

00:35:43,430 --> 00:35:50,810
however if you look at it carefully you

00:35:48,260 --> 00:35:54,860
will see how some accesses are not are

00:35:50,810 --> 00:35:58,270
not love it ok so we're vasilich is not

00:35:54,860 --> 00:35:58,270
behaving as expected

00:35:58,760 --> 00:36:03,170
the Fisk inclusion is that the order of

00:36:01,670 --> 00:36:06,020
the ancestors the others the super

00:36:03,170 --> 00:36:08,420
classes matters it's important to

00:36:06,020 --> 00:36:11,180
understand the deep mother's so it'll

00:36:08,420 --> 00:36:14,690
you define one and the other or the

00:36:11,180 --> 00:36:17,300
other way your code could behave in

00:36:14,690 --> 00:36:20,440
different ways but we can improve it

00:36:17,300 --> 00:36:22,940
okay we can we can enhance this behavior

00:36:20,440 --> 00:36:25,460
other options to implement our

00:36:22,940 --> 00:36:29,540
dictionary with both merge behaviors

00:36:25,460 --> 00:36:32,710
could be to implement a new class from

00:36:29,540 --> 00:36:37,840
scratch implement a class implement both

00:36:32,710 --> 00:36:37,840
both behaviors in absolute new class

00:36:38,170 --> 00:36:43,760
well you have to implement everything

00:36:40,190 --> 00:36:45,410
from scratch it's not that you should

00:36:43,760 --> 00:36:47,620
try to reduce so you have introducing

00:36:45,410 --> 00:36:50,990
okay don't repeat yourself remember

00:36:47,620 --> 00:36:53,750
another option a change verbose thick

00:36:50,990 --> 00:36:56,630
turning it from a Triple D in this case

00:36:53,750 --> 00:37:00,580
we have to change the call the code

00:36:56,630 --> 00:37:04,580
sorry to change the calls look at our

00:37:00,580 --> 00:37:08,120
implementation for both big and you will

00:37:04,580 --> 00:37:11,090
see how L ways we're calling the

00:37:08,120 --> 00:37:13,340
superclass lately so if we change the

00:37:11,090 --> 00:37:17,710
deed we should come here and say okay

00:37:13,340 --> 00:37:22,340
now you will read from attr dick and

00:37:17,710 --> 00:37:25,070
here you are not going to call dick you

00:37:22,340 --> 00:37:31,640
have to call attr dick otherwise you

00:37:25,070 --> 00:37:34,540
would skip attr dick okay understood

00:37:31,640 --> 00:37:34,540
yeah question

00:37:40,310 --> 00:37:44,970
because if you call light ugly dick you

00:37:43,410 --> 00:37:48,810
are skipping at you would dig and then

00:37:44,970 --> 00:37:51,150
you would then it one execute so you

00:37:48,810 --> 00:37:59,460
wouldn't have its its behavior actually

00:37:51,150 --> 00:38:04,380
I IDK services name is in the name of

00:37:59,460 --> 00:38:05,820
day of the superclass so you are calling

00:38:04,380 --> 00:38:09,450
you are calling directly the superclass

00:38:05,820 --> 00:38:11,220
here you need it from the super class

00:38:09,450 --> 00:38:14,010
and here you call the superclass

00:38:11,220 --> 00:38:17,340
directly and you say I want to execute

00:38:14,010 --> 00:38:21,780
this method defined in this super in

00:38:17,340 --> 00:38:24,390
disks ancestor so you should change it

00:38:21,780 --> 00:38:26,730
and put a tribute dick here and a tree

00:38:24,390 --> 00:38:28,800
would be in all the places so you have

00:38:26,730 --> 00:38:30,120
to change the code again and we don't

00:38:28,800 --> 00:38:33,480
want to change the code we want to

00:38:30,120 --> 00:38:35,880
reduce everything we have other options

00:38:33,480 --> 00:38:37,980
but none of them are right because the

00:38:35,880 --> 00:38:39,750
problem the problem here is that the

00:38:37,980 --> 00:38:43,760
initial implementation of our classes is

00:38:39,750 --> 00:38:47,640
wrong we should do it in a better way

00:38:43,760 --> 00:38:51,660
the solution is super super

00:38:47,640 --> 00:38:54,600
uncooperative methods so according to

00:38:51,660 --> 00:38:56,820
the to documentation super veterans

00:38:54,600 --> 00:39:00,170
approxi objector delegates method calls

00:38:56,820 --> 00:39:04,020
to a parent or sibling class of type

00:39:00,170 --> 00:39:10,170
type is specified here in your call to

00:39:04,020 --> 00:39:13,380
sober typically you call super with your

00:39:10,170 --> 00:39:15,930
current class and self the method that

00:39:13,380 --> 00:39:17,370
you want to execute and your arguments

00:39:15,930 --> 00:39:23,310
typically the same argument that you

00:39:17,370 --> 00:39:26,600
received let me remind that it only

00:39:23,310 --> 00:39:30,720
works for new way style classes and

00:39:26,600 --> 00:39:32,730
maybe good news is that in Python 3 both

00:39:30,720 --> 00:39:34,950
arguments are optional because by

00:39:32,730 --> 00:39:40,530
default it takes the current class and

00:39:34,950 --> 00:39:42,660
it takes self so most probably you read

00:39:40,530 --> 00:39:44,820
this and you think i have not understood

00:39:42,660 --> 00:39:45,950
anything what's this and let's an

00:39:44,820 --> 00:39:50,540
example and you will end

00:39:45,950 --> 00:39:54,230
better okay look now we're implementing

00:39:50,540 --> 00:39:56,930
our bell Bozek we're still in a dick

00:39:54,230 --> 00:40:03,020
from dick but in this case we call

00:39:56,930 --> 00:40:08,329
supper so as the documentation set is a

00:40:03,020 --> 00:40:12,710
proxy which at the end what it will make

00:40:08,329 --> 00:40:14,780
is that this call will be execute in one

00:40:12,710 --> 00:40:17,480
of your ancestors in which ancestor it

00:40:14,780 --> 00:40:20,810
doesn't matter you don't have to worry

00:40:17,480 --> 00:40:23,390
which ancestor you have to go to call to

00:40:20,810 --> 00:40:27,650
find this method super will take the

00:40:23,390 --> 00:40:29,599
list of ancestors of self will go one

00:40:27,650 --> 00:40:31,940
after the other looking for get

00:40:29,599 --> 00:40:34,430
attribute understand us forget attribute

00:40:31,940 --> 00:40:36,619
method and we'll call it for you so you

00:40:34,430 --> 00:40:39,290
have to worry what I have to call this

00:40:36,619 --> 00:40:46,099
exam method in which exact ancestor

00:40:39,290 --> 00:40:48,200
super will do it in this case is the

00:40:46,099 --> 00:40:50,240
same because you are editing directly

00:40:48,200 --> 00:40:54,950
from dick in this case is the same at

00:40:50,240 --> 00:40:56,900
the end it will call dick at the end it

00:40:54,950 --> 00:41:02,329
calls dick in this example in this

00:40:56,900 --> 00:41:04,520
executed example but in our problem

00:41:02,329 --> 00:41:07,250
trying to merge both classes it will

00:41:04,520 --> 00:41:10,010
help us and we will see how ok let's

00:41:07,250 --> 00:41:14,750
continue it and then we will see it the

00:41:10,010 --> 00:41:17,240
thing is that you delegate to supper the

00:41:14,750 --> 00:41:21,700
decision of which super class is going

00:41:17,240 --> 00:41:21,700
to be used to heat this method

00:41:24,640 --> 00:41:30,910
so you don't have to to be aware of what

00:41:28,269 --> 00:41:33,730
exactly it's a fine or where I'm going

00:41:30,910 --> 00:41:36,970
to find it or which names you that right

00:41:33,730 --> 00:41:40,210
here and what happens if I change the

00:41:36,970 --> 00:41:44,220
ancestor and whatever let's say a bit

00:41:40,210 --> 00:41:52,450
more examples and so we also changed

00:41:44,220 --> 00:41:55,960
attr dick and we also use supper again

00:41:52,450 --> 00:41:58,319
in this case we would call dick directly

00:41:55,960 --> 00:41:58,319
ok

00:42:03,310 --> 00:42:07,900
so it repeat the only thing that they

00:42:05,890 --> 00:42:10,860
have changed is that instead of calling

00:42:07,900 --> 00:42:14,050
that they directly I call supper I

00:42:10,860 --> 00:42:20,310
provide the current class and I provide

00:42:14,050 --> 00:42:22,840
self and now i implement this new class

00:42:20,310 --> 00:42:26,680
look at the signature of this new class

00:42:22,840 --> 00:42:30,240
is quite easy at simple I need it from

00:42:26,680 --> 00:42:30,240
both the zone

00:42:37,270 --> 00:42:44,950
but both now just supper instead of

00:42:41,340 --> 00:42:47,710
calling directly to super class the

00:42:44,950 --> 00:42:52,000
thing is that now when verbose league

00:42:47,710 --> 00:42:56,290
called supper it wouldn't go to call his

00:42:52,000 --> 00:43:00,130
ancestor it will go to code ancestor the

00:42:56,290 --> 00:43:01,660
next ancestor of this new class because

00:43:00,130 --> 00:43:07,180
now you are working with a different

00:43:01,660 --> 00:43:09,580
class let's try it we will see that it

00:43:07,180 --> 00:43:16,060
works and then we will see carefully and

00:43:09,580 --> 00:43:18,640
in detail how it works so I implement my

00:43:16,060 --> 00:43:24,610
verbose sorry i instantiate my verbosity

00:43:18,640 --> 00:43:27,190
boutique my new class I tried to set an

00:43:24,610 --> 00:43:32,290
item and it works fine ok this was easy

00:43:27,190 --> 00:43:37,780
I tried to set an item it had to set an

00:43:32,290 --> 00:43:40,660
attribute and it works fine and now I

00:43:37,780 --> 00:43:43,480
try to set an attribute which is

00:43:40,660 --> 00:43:45,570
rotating the finest key remember the

00:43:43,480 --> 00:43:48,310
behavior of our activity customized if

00:43:45,570 --> 00:43:50,350
the killer did exist we modify the key

00:43:48,310 --> 00:43:54,100
otherwise we modified attribute so

00:43:50,350 --> 00:43:58,080
what's happening set attr is called and

00:43:54,100 --> 00:44:02,430
then set EDT air calls set item it works

00:43:58,080 --> 00:44:06,420
we have both behaviors here it's magic

00:44:02,430 --> 00:44:11,350
thanks to supper just thanks to supper

00:44:06,420 --> 00:44:13,480
why because with supper you don't have

00:44:11,350 --> 00:44:17,140
to care which ancestor you are calling

00:44:13,480 --> 00:44:19,240
and in this case then sisters list that

00:44:17,140 --> 00:44:23,730
you have to check is the ancestors list

00:44:19,240 --> 00:44:23,730
of the real class that you are using

00:44:23,910 --> 00:44:32,650
let's see up much more easy example much

00:44:29,950 --> 00:44:35,470
is your example ok we try to achieve an

00:44:32,650 --> 00:44:37,690
attribute and it also works we call

00:44:35,470 --> 00:44:40,870
getattribute remember this one is called

00:44:37,690 --> 00:44:44,260
always with sentiment this one is called

00:44:40,870 --> 00:44:47,530
when the activity is not found and we

00:44:44,260 --> 00:44:49,570
had implemented this one to try to look

00:44:47,530 --> 00:44:51,109
for an item inside the dictionary and

00:44:49,570 --> 00:44:57,440
with this item so everything

00:44:51,109 --> 00:44:59,390
working as as we wanted we could try

00:44:57,440 --> 00:45:04,430
another option we could change very

00:44:59,390 --> 00:45:08,059
Bostic to narrate from attr dick and

00:45:04,430 --> 00:45:10,970
thanks to using supper we only have to

00:45:08,059 --> 00:45:15,349
change this line of code only this line

00:45:10,970 --> 00:45:18,170
nothing else and the rest will continue

00:45:15,349 --> 00:45:23,809
working and again our examples will

00:45:18,170 --> 00:45:27,440
continue working all of them let's see

00:45:23,809 --> 00:45:28,910
how it works in detail so in my young

00:45:27,440 --> 00:45:30,680
words i would say that separates and

00:45:28,910 --> 00:45:33,940
implicit ancestors method invocation

00:45:30,680 --> 00:45:37,609
mechanism so you have to worry which a

00:45:33,940 --> 00:45:41,839
superclass is going to be used supper

00:45:37,609 --> 00:45:45,499
will do it for you give us call it

00:45:41,839 --> 00:45:48,710
cooperative super-cold pattern or call

00:45:45,499 --> 00:45:51,589
next method pattern and you have all the

00:45:48,710 --> 00:45:53,989
description here it's maybe it's a bit

00:45:51,589 --> 00:45:55,849
difficult so yeah I said that it was an

00:45:53,989 --> 00:45:58,819
introductory training and maybe this

00:45:55,849 --> 00:46:00,920
part is a bit more difficult but let's

00:45:58,819 --> 00:46:02,359
see in the tail ok let you know that

00:46:00,920 --> 00:46:06,769
example and you will understand for sure

00:46:02,359 --> 00:46:11,210
this example we have a class called a

00:46:06,769 --> 00:46:14,989
and this class has a method the method

00:46:11,210 --> 00:46:19,660
will pray in the type of self and we

00:46:14,989 --> 00:46:22,519
sell and we will say that it's in a ok

00:46:19,660 --> 00:46:28,039
we have another class in editing from a

00:46:22,519 --> 00:46:31,720
it does the same but it called supper so

00:46:28,039 --> 00:46:31,720
it costs the same method in the ancestor

00:46:32,619 --> 00:46:39,940
right so if I create an instance of

00:46:35,390 --> 00:46:39,940
being in a ruby that method

00:46:41,809 --> 00:46:50,989
we are calling this method right this

00:46:47,569 --> 00:46:54,829
method is executed this plain statement

00:46:50,989 --> 00:46:57,709
is executed so it prints the type of the

00:46:54,829 --> 00:47:02,979
of self and it prints this text and it

00:46:57,709 --> 00:47:08,390
called supper and supper looks for any

00:47:02,979 --> 00:47:18,829
ancestor which has this method defined

00:47:08,390 --> 00:47:26,359
and calls it right to hear it's easy any

00:47:18,829 --> 00:47:30,979
questions yeah question if two super

00:47:26,359 --> 00:47:33,109
classes have at the same method we will

00:47:30,979 --> 00:47:35,539
see this example we will see this

00:47:33,109 --> 00:47:39,229
example yeah this is a good example of

00:47:35,539 --> 00:47:42,949
supper okay so up to here is easy let's

00:47:39,229 --> 00:47:47,989
see this case we have another class

00:47:42,949 --> 00:47:51,619
which is also a subclass of a and that's

00:47:47,989 --> 00:47:56,630
exactly the same damn be Prince

00:47:51,619 --> 00:48:02,920
something and calls supper and at the

00:47:56,630 --> 00:48:10,670
end we have a subclass of both we have D

00:48:02,920 --> 00:48:13,789
so class of B and C and both have the

00:48:10,670 --> 00:48:16,429
method define as well as a as well as

00:48:13,789 --> 00:48:18,559
the so all the classes have method

00:48:16,429 --> 00:48:22,929
defined and method does the same in all

00:48:18,559 --> 00:48:27,130
the classes print a line and cold supper

00:48:22,929 --> 00:48:27,130
so we have this diagram okay

00:48:33,520 --> 00:48:38,250
and where's a hit it this is what

00:48:36,220 --> 00:48:38,250
happens

00:48:42,410 --> 00:48:51,289
we call thee we call the method and

00:48:47,480 --> 00:48:56,960
didn't method is called and then it

00:48:51,289 --> 00:48:59,450
called supper looking at the diagram at

00:48:56,960 --> 00:49:06,579
the diagram which is an egg's ancestor

00:48:59,450 --> 00:49:09,020
of the V and the method in B is called

00:49:06,579 --> 00:49:10,789
okay and the method in vehicles supper

00:49:09,020 --> 00:49:16,940
again so it has to call the next

00:49:10,789 --> 00:49:23,260
semester which is an ex ancestor who set

00:49:16,940 --> 00:49:26,750
a but the thing here is that you are not

00:49:23,260 --> 00:49:32,799
well the question was tricky the next

00:49:26,750 --> 00:49:35,480
ancestor of who who are you who is self

00:49:32,799 --> 00:49:40,880
it's an instance of the and who is the

00:49:35,480 --> 00:49:42,589
next ancestor of me see so supper will

00:49:40,880 --> 00:49:47,470
call see because it's an ex ancestor of

00:49:42,589 --> 00:49:51,349
thee that's why I'm printing always

00:49:47,470 --> 00:49:54,130
sells the type to let you see how self

00:49:51,349 --> 00:49:58,970
is there ways an instance of thee and

00:49:54,130 --> 00:50:01,700
you have to look at the ancestors of the

00:49:58,970 --> 00:50:05,299
not advanced ester of be ordered

00:50:01,700 --> 00:50:09,130
ancestor of see otherwise in most of the

00:50:05,299 --> 00:50:13,150
cases see methods would never be called

00:50:09,130 --> 00:50:15,740
because it would go straight from B to a

00:50:13,150 --> 00:50:17,539
directly and you don't want this because

00:50:15,740 --> 00:50:23,089
that's why you you are narrating from

00:50:17,539 --> 00:50:28,099
both classes you want both behaviors if

00:50:23,089 --> 00:50:30,289
you have to ace what you mean you have

00:50:28,099 --> 00:50:32,809
two ways actually you have to wait here

00:50:30,289 --> 00:50:36,640
both be incinerate from a so you have

00:50:32,809 --> 00:50:36,640
this this is a schema

00:50:37,670 --> 00:50:45,049
yeah I have a but at the end yeah but

00:50:42,410 --> 00:50:48,559
it's the same in both so both in it from

00:50:45,049 --> 00:50:51,530
the same it's not it's not it's not a

00:50:48,559 --> 00:50:54,319
tree in this case it's not a three if

00:50:51,530 --> 00:51:04,180
you had a one and A two you will have

00:50:54,319 --> 00:51:04,180
them 81 a1 and a2 so if

00:51:11,990 --> 00:51:15,970
and it was see right

00:51:24,790 --> 00:51:35,500
but then only once because look at this

00:51:32,070 --> 00:51:37,660
you call the method in D and call supper

00:51:35,500 --> 00:51:41,320
supper cause the next ancestor the Nexus

00:51:37,660 --> 00:51:44,710
sensor this be it calls again supper and

00:51:41,320 --> 00:51:48,730
the next ancestor according to the SC ok

00:51:44,710 --> 00:51:50,740
so you call c and then a it called

00:51:48,730 --> 00:51:53,590
supper again what's the next ancestor in

00:51:50,740 --> 00:51:56,200
the list so the next ancestor is only a

00:51:53,590 --> 00:51:59,530
there is only one eh there is no 2 a's

00:51:56,200 --> 00:52:02,230
so now the question that you should be

00:51:59,530 --> 00:52:06,480
doing here is and how I know exactly the

00:52:02,230 --> 00:52:06,480
list of of ancestors well you can do Oh

00:52:07,830 --> 00:52:19,630
method resolution order ooh and here you

00:52:15,850 --> 00:52:22,420
have the list there are no repetitions

00:52:19,630 --> 00:52:25,270
on the list well if you had a really

00:52:22,420 --> 00:52:29,110
complex schema something like being

00:52:25,270 --> 00:52:30,640
anything from a and I don't know but at

00:52:29,110 --> 00:52:34,360
the end you will have only one ancestor

00:52:30,640 --> 00:52:38,010
so its class only once ok and this is

00:52:34,360 --> 00:52:46,440
what super uses super takes self and

00:52:38,010 --> 00:52:46,440
taste a method resolution order ok

00:52:46,609 --> 00:52:52,069
so the key here is to understand that

00:52:49,339 --> 00:52:54,019
the next ancestor the method resolution

00:52:52,069 --> 00:52:56,720
ordered it's always taken according to

00:52:54,019 --> 00:52:58,759
the current class according to self

00:52:56,720 --> 00:53:05,269
which in this in our example is the

00:52:58,759 --> 00:53:08,569
always d always did okay otherwise see

00:53:05,269 --> 00:53:13,369
would be C methods with the Mesa created

00:53:08,569 --> 00:53:20,799
most of the times so let's implement any

00:53:13,369 --> 00:53:26,660
for an example a to see to be too but

00:53:20,799 --> 00:53:31,069
check it see in a rich from a but be in

00:53:26,660 --> 00:53:35,299
a lit from C so we have this this

00:53:31,069 --> 00:53:37,400
implementation the implementation of

00:53:35,299 --> 00:53:40,160
method is always the same print

00:53:37,400 --> 00:53:41,480
something and cold supper okay so in

00:53:40,160 --> 00:53:45,289
this case we have a linear in return

00:53:41,480 --> 00:53:46,819
schema instead of a vitamin but the

00:53:45,289 --> 00:53:52,480
method dissolution order it's exactly

00:53:46,819 --> 00:53:56,119
the same in this case is more obvious

00:53:52,480 --> 00:53:57,739
because it's completely linear but it's

00:53:56,119 --> 00:54:01,940
it's the same method resolution order

00:53:57,739 --> 00:54:04,640
that's why if you look carefully at the

00:54:01,940 --> 00:54:06,890
two solutions they propose with verbose

00:54:04,640 --> 00:54:09,950
leak and attribute dick I implemented

00:54:06,890 --> 00:54:12,140
both hey there multiple inheritance on

00:54:09,950 --> 00:54:14,630
or either change one instance to nail it

00:54:12,140 --> 00:54:17,630
from the other but using supper you only

00:54:14,630 --> 00:54:19,519
change the first line of the equation of

00:54:17,630 --> 00:54:21,529
the class and nothing else you only say

00:54:19,519 --> 00:54:25,640
okay now your ancestor is this one and

00:54:21,529 --> 00:54:28,180
nothing else changed okay so if if

00:54:25,640 --> 00:54:31,220
you're a good method in this D to the

00:54:28,180 --> 00:54:32,839
trestle is exactly the same because the

00:54:31,220 --> 00:54:36,730
method resolution order is exactly the

00:54:32,839 --> 00:54:36,730
same here you have

00:54:38,170 --> 00:54:43,800
this is what really matters and this is

00:54:40,330 --> 00:54:46,660
what you have to do to understand so

00:54:43,800 --> 00:54:50,200
there is an amazing description on

00:54:46,660 --> 00:54:52,780
whether multiple inheritances is the

00:54:50,200 --> 00:54:56,080
avail and you should avoid it or you

00:54:52,780 --> 00:54:58,480
should take it or I'm not going into

00:54:56,080 --> 00:54:59,800
this description but you have to be

00:54:58,480 --> 00:55:01,270
careful and you have to understand this

00:54:59,800 --> 00:55:03,940
thing you have to understand exactly how

00:55:01,270 --> 00:55:05,620
it works what's happening okay you have

00:55:03,940 --> 00:55:09,010
to understand that there is a method

00:55:05,620 --> 00:55:11,470
resolution order and that always the

00:55:09,010 --> 00:55:14,340
method resolution order it's taken

00:55:11,470 --> 00:55:24,040
according to self according to the

00:55:14,340 --> 00:55:28,210
subclass and this big piece of text

00:55:24,040 --> 00:55:30,580
explains how it works let's see as I

00:55:28,210 --> 00:55:34,950
said the method the method resolution

00:55:30,580 --> 00:55:34,950
ordered is taken a waste from self a

00:55:35,520 --> 00:55:45,340
indie in this method so the first call

00:55:40,510 --> 00:55:49,120
to d road method we called supper and we

00:55:45,340 --> 00:55:53,290
will find and call be because we take

00:55:49,120 --> 00:55:55,750
this method resolution order we know

00:55:53,290 --> 00:55:59,080
that we are indeed so we have to take

00:55:55,750 --> 00:56:02,640
the next one from B and the next one

00:55:59,080 --> 00:56:05,830
sorry from D and the next one is V

00:56:02,640 --> 00:56:08,260
supper goes here takes the Declaration

00:56:05,830 --> 00:56:15,040
and says okay it has method define i

00:56:08,260 --> 00:56:18,220
call it if method was not define it will

00:56:15,040 --> 00:56:20,460
continue looking in the next classes but

00:56:18,220 --> 00:56:24,040
method is a fine so it calls it and

00:56:20,460 --> 00:56:26,650
method mb calls against Harper ok call

00:56:24,040 --> 00:56:28,150
second supper and what happens that we

00:56:26,650 --> 00:56:32,680
have to take again the method resolution

00:56:28,150 --> 00:56:35,620
order Dre with respect to an instance of

00:56:32,680 --> 00:56:40,330
D so the method is Lucien order as we

00:56:35,620 --> 00:56:42,970
have seen is d bc a but now we are

00:56:40,330 --> 00:56:47,110
calling it from be that's why you

00:56:42,970 --> 00:56:49,470
provide here be to let supper know

00:56:47,110 --> 00:56:52,030
exactly from where it's being called

00:56:49,470 --> 00:56:55,300
this is to let supper know

00:56:52,030 --> 00:56:58,080
in which index in this double it has to

00:56:55,300 --> 00:57:03,600
start looking for another ancestor and

00:56:58,080 --> 00:57:07,780
as we're now in be the next one is C and

00:57:03,600 --> 00:57:10,150
the method in C is called and the same

00:57:07,780 --> 00:57:16,860
happens it called supper and it goes to

00:57:10,150 --> 00:57:20,620
a and execute method in a and it's not

00:57:16,860 --> 00:57:29,020
it's not calling supper so all the older

00:57:20,620 --> 00:57:30,630
calls end and that's it it's the first

00:57:29,020 --> 00:57:33,780
time it's very difficult to understand

00:57:30,630 --> 00:57:37,720
if you don't try to play a bit with this

00:57:33,780 --> 00:57:39,940
diamana schema or tied a bit more

00:57:37,720 --> 00:57:44,020
complex but at the end in most of the

00:57:39,940 --> 00:57:45,730
cases you don't have diamana schemas but

00:57:44,020 --> 00:57:48,670
maybe you have a linear a schema a

00:57:45,730 --> 00:57:50,230
linearly returns a schema and the thing

00:57:48,670 --> 00:57:52,210
is that with supper you have to worry

00:57:50,230 --> 00:57:54,190
which is your ancestor and and in the

00:57:52,210 --> 00:57:56,080
future you can change your your ancestor

00:57:54,190 --> 00:57:58,960
and inherit from another class and you

00:57:56,080 --> 00:58:01,360
have to worry again to change all the

00:57:58,960 --> 00:58:03,700
all the all the places that you were

00:58:01,360 --> 00:58:09,300
calling to the ancestor this is this is

00:58:03,700 --> 00:58:13,150
why this is this is the thing cyber okay

00:58:09,300 --> 00:58:14,980
as we have seen this process ensures

00:58:13,150 --> 00:58:19,270
that all ancestors of a class always

00:58:14,980 --> 00:58:21,970
inspected and I always execute otherwise

00:58:19,270 --> 00:58:27,700
in our diamana schema see methods

00:58:21,970 --> 00:58:29,920
wouldn't be called the same happens with

00:58:27,700 --> 00:58:31,240
get attribute or with a tribute acts as

00:58:29,920 --> 00:58:36,010
a standard a tree root access it's

00:58:31,240 --> 00:58:38,260
exactly the same now we have this schema

00:58:36,010 --> 00:58:43,210
and we have an attribute define in two

00:58:38,260 --> 00:58:47,790
places when I called d3 that class

00:58:43,210 --> 00:58:47,790
attribute which value will be returned

00:58:51,380 --> 00:58:58,099
when i call the three-dot class

00:58:56,420 --> 00:59:04,119
attribute which value i'm going to

00:58:58,099 --> 00:59:06,440
retrieve c3 yeah this is the same

00:59:04,119 --> 00:59:08,720
attribute the three-ball also takes the

00:59:06,440 --> 00:59:10,039
method resolution order and goes to all

00:59:08,720 --> 00:59:13,430
the super classes looking for an

00:59:10,039 --> 00:59:17,329
attribute or a method it's the same

00:59:13,430 --> 00:59:21,589
because as I said methods are attributes

00:59:17,329 --> 00:59:24,740
but later you'll secure them here you

00:59:21,589 --> 00:59:27,049
have so you would say why they

00:59:24,740 --> 00:59:29,269
implemented this thing well the thing is

00:59:27,049 --> 00:59:31,819
that with introduction of the newest

00:59:29,269 --> 00:59:35,569
I'll classes absolutely everything in a

00:59:31,819 --> 00:59:38,930
reads from object so suddenly in all the

00:59:35,569 --> 00:59:40,819
style you had this diagram and with

00:59:38,930 --> 00:59:43,250
introduction of object you started

00:59:40,819 --> 00:59:45,950
having this diagram and they realize

00:59:43,250 --> 00:59:48,890
that the old implementation of the

00:59:45,950 --> 00:59:52,329
missile dissolution or there was going

00:59:48,890 --> 00:59:55,480
to ignore see and it shouldn't happen

00:59:52,329 --> 01:00:04,099
that's why all this stuff was introduced

00:59:55,480 --> 01:00:06,650
ok so I have even more examples of how

01:00:04,099 --> 01:00:09,049
to exploit it using verbose league an

01:00:06,650 --> 01:00:13,059
attribute deep actually this example

01:00:09,049 --> 01:00:13,059
text to exploit mix-ins which is

01:00:13,660 --> 01:00:19,490
implement both without inheriting from

01:00:16,640 --> 01:00:21,619
dig and at the end we implement my class

01:00:19,490 --> 01:00:23,809
in editing from verbose attribute and

01:00:21,619 --> 01:00:30,920
dig and it works exactly the same way

01:00:23,809 --> 01:00:32,960
that it did the first time because it's

01:00:30,920 --> 01:00:36,170
method resolution order is exactly the

01:00:32,960 --> 01:00:39,140
same so now i have an exercise the thing

01:00:36,170 --> 01:00:41,509
is that we have run out of time there is

01:00:39,140 --> 01:00:44,390
still another model this is shorter but

01:00:41,509 --> 01:00:46,279
i think it's time again to vote if I

01:00:44,390 --> 01:00:49,130
have no problem to stay here a bit more

01:00:46,279 --> 01:00:51,319
in this new model there are no exercises

01:00:49,130 --> 01:00:54,920
but I I explain what's underscore

01:00:51,319 --> 01:00:58,190
underscore new and what's a metaclass so

01:00:54,920 --> 01:01:01,599
the thing is if you want you can stay we

01:00:58,190 --> 01:01:01,599
have a bit more time right

01:01:02,320 --> 01:01:08,810
how much more time I think that maybe 10

01:01:05,150 --> 01:01:11,690
minutes I hope I hope it depends on the

01:01:08,810 --> 01:01:14,140
Dubs so we will skip the exercise you

01:01:11,690 --> 01:01:16,340
can do it at home or when you want and

01:01:14,140 --> 01:01:18,500
if you really want if you want you can

01:01:16,340 --> 01:01:20,060
leave I'm sorry but but we have taken

01:01:18,500 --> 01:01:21,800
out of time with with the previous

01:01:20,060 --> 01:01:24,320
explanations and other jobs or not this

01:01:21,800 --> 01:01:26,390
kind of thing so it's up to you if you

01:01:24,320 --> 01:01:31,220
want to stay I will stay 10 minutes more

01:01:26,390 --> 01:01:40,150
and let's see what's new ok so let's

01:01:31,220 --> 01:01:43,840
let's go straight to the last one well

01:01:40,150 --> 01:01:46,640
never staff underscore underscore new

01:01:43,840 --> 01:01:48,790
anybody knows what's on the screen score

01:01:46,640 --> 01:01:48,790
New

01:01:56,090 --> 01:02:02,750
it's a real constructor of the instance

01:01:59,680 --> 01:02:07,610
it's a method in charge of really

01:02:02,750 --> 01:02:12,320
creating any object because look here in

01:02:07,610 --> 01:02:16,240
it receives helps as an argument so in

01:02:12,320 --> 01:02:19,370
it is receiving as as the first argument

01:02:16,240 --> 01:02:21,890
it's receiving and already created an

01:02:19,370 --> 01:02:25,340
already existing instance an already

01:02:21,890 --> 01:02:28,160
existing object because neil has created

01:02:25,340 --> 01:02:30,160
this object but most of the times you

01:02:28,160 --> 01:02:33,500
don't need new that's why most probably

01:02:30,160 --> 01:02:35,840
most of you have never used new because

01:02:33,500 --> 01:02:39,230
most of the times you don't need it but

01:02:35,840 --> 01:02:41,570
it exists and it's here and you can

01:02:39,230 --> 01:02:44,630
customize how your instance is created

01:02:41,570 --> 01:02:47,150
but really created not how its

01:02:44,630 --> 01:02:49,910
initialize here unity lies the instance

01:02:47,150 --> 01:02:51,500
you feel its content you take its

01:02:49,910 --> 01:02:53,930
attributes and you put value to the

01:02:51,500 --> 01:02:55,790
attributes and this kind of things but

01:02:53,930 --> 01:03:00,290
here is where you really create the

01:02:55,790 --> 01:03:02,900
object so in this case I'm just printing

01:03:00,290 --> 01:03:07,960
what it has to do and as we have seen

01:03:02,900 --> 01:03:10,670
I'm Colin supper get used to cold supper

01:03:07,960 --> 01:03:12,890
as much as possible because this way it

01:03:10,670 --> 01:03:15,140
makes you easier to in edit and it's

01:03:12,890 --> 01:03:19,100
make it makes you easier to too late

01:03:15,140 --> 01:03:23,180
that extend your code so I'm really

01:03:19,100 --> 01:03:27,080
delegating the the the creation to my

01:03:23,180 --> 01:03:29,330
super class and Ivan I don't I don't

01:03:27,080 --> 01:03:31,790
have to worry on who is my super class

01:03:29,330 --> 01:03:35,120
okay so I'm on the printing here that

01:03:31,790 --> 01:03:37,790
new has been called and Here I am

01:03:35,120 --> 01:03:41,600
painting the type of the other of the

01:03:37,790 --> 01:03:45,020
return value and look at this we are

01:03:41,600 --> 01:03:47,450
returning something here again in it

01:03:45,020 --> 01:03:49,580
initializes the instance modifies its

01:03:47,450 --> 01:03:55,780
content and that's not right on anything

01:03:49,580 --> 01:03:55,780
but new returns a new object okay

01:03:56,280 --> 01:04:02,670
let's use it we create an instance and

01:04:00,060 --> 01:04:06,510
you can see how new is call

01:04:02,670 --> 01:04:17,640
automatically and then later in it is

01:04:06,510 --> 01:04:22,020
called okay let's call it oh yeah sorry

01:04:17,640 --> 01:04:25,500
explanation new is a special static

01:04:22,020 --> 01:04:27,540
method but you have to declare it or the

01:04:25,500 --> 01:04:30,570
final static because it's automatically

01:04:27,540 --> 01:04:34,440
done okay and it's called when you call

01:04:30,570 --> 01:04:37,250
the class look at this what's the

01:04:34,440 --> 01:04:39,240
difference between calling these

01:04:37,250 --> 01:04:40,560
synthetically here what's the difference

01:04:39,240 --> 01:04:46,770
between calling this and calling any

01:04:40,560 --> 01:04:48,240
other function so for instance Len it

01:04:46,770 --> 01:04:50,010
looks the same and actually the same

01:04:48,240 --> 01:04:54,090
when you get an instance you are

01:04:50,010 --> 01:04:58,470
executing the class when you execute the

01:04:54,090 --> 01:05:02,670
class new is called the result of new is

01:04:58,470 --> 01:05:09,030
taken and then in it is called on that

01:05:02,670 --> 01:05:12,150
instance okay understanding here is that

01:05:09,030 --> 01:05:16,320
when calling new with supper you have to

01:05:12,150 --> 01:05:18,630
provide here the class in the previous

01:05:16,320 --> 01:05:23,010
examples with supper you did not have to

01:05:18,630 --> 01:05:25,020
provide self Airways but in the name you

01:05:23,010 --> 01:05:35,070
have to do it it's the only strange

01:05:25,020 --> 01:05:37,560
thing okay so a we can we can implement

01:05:35,070 --> 01:05:40,440
it sorry we can we can use multiple

01:05:37,560 --> 01:05:43,830
inheritance we create an instance of

01:05:40,440 --> 01:05:48,060
this of this multiple inheritance class

01:05:43,830 --> 01:05:51,180
and we see that our type is still our

01:05:48,060 --> 01:05:54,710
new type okay bye boss creator dick but

01:05:51,180 --> 01:05:59,730
now we provided some arguments and look

01:05:54,710 --> 01:06:02,850
new is returning us those arguments well

01:05:59,730 --> 01:06:04,800
it's print is printing them so what's

01:06:02,850 --> 01:06:09,600
the saving you let's go again to the

01:06:04,800 --> 01:06:12,030
implementation new is receiving all the

01:06:09,600 --> 01:06:14,610
moments of the initialization of the

01:06:12,030 --> 01:06:19,140
class of the instance of each instance

01:06:14,610 --> 01:06:21,630
okay so if you want you can capture it

01:06:19,140 --> 01:06:24,510
and you can check it and you can do some

01:06:21,630 --> 01:06:27,300
stuff but look it's not calling directly

01:06:24,510 --> 01:06:30,000
in it so for instance what you could do

01:06:27,300 --> 01:06:34,010
here you could check those arguments and

01:06:30,000 --> 01:06:37,560
implement a kind of factory pattern and

01:06:34,010 --> 01:06:41,570
depending on the arguments veteran an

01:06:37,560 --> 01:06:44,400
instance upon another it's up to you

01:06:41,570 --> 01:06:48,540
okay let's see a better example we can

01:06:44,400 --> 01:06:54,690
implement a singleton how we implement a

01:06:48,540 --> 01:06:59,250
singleton we store the new instance as a

01:06:54,690 --> 01:07:02,460
new attribute if the attribute does not

01:06:59,250 --> 01:07:04,890
exist we created for the first time and

01:07:02,460 --> 01:07:08,100
the rest of times we return it that

01:07:04,890 --> 01:07:14,370
again this way we have applied to the

01:07:08,100 --> 01:07:20,820
singleton you understand it somebody

01:07:14,370 --> 01:07:24,990
said no there yeah so how it works let's

01:07:20,820 --> 01:07:27,000
use it okay python comes here and takes

01:07:24,990 --> 01:07:29,670
this statement and says okay you have to

01:07:27,000 --> 01:07:32,190
train to create a new instance I take my

01:07:29,670 --> 01:07:36,360
single tone I take the class and I call

01:07:32,190 --> 01:07:39,390
new new is called the first time I

01:07:36,360 --> 01:07:42,450
arrived here do you know what does this

01:07:39,390 --> 01:07:48,980
function this function checks if an

01:07:42,450 --> 01:07:53,160
object has an attribute so I check

01:07:48,980 --> 01:07:55,170
inside the class if the class has the

01:07:53,160 --> 01:07:57,060
attribute the class does not have the

01:07:55,170 --> 01:08:00,930
attribute that not has the unique

01:07:57,060 --> 01:08:05,220
instance that we are going to have so we

01:08:00,930 --> 01:08:06,900
created and we write to knit what

01:08:05,220 --> 01:08:11,970
happens the next time the second the

01:08:06,900 --> 01:08:14,760
second call new is colerain we go here

01:08:11,970 --> 01:08:16,680
we check a we already have this

01:08:14,760 --> 01:08:18,600
attribute so that's not only directly

01:08:16,680 --> 01:08:19,940
and we are returning out with the same

01:08:18,600 --> 01:08:21,569
instance

01:08:19,940 --> 01:08:25,889
what's the problem of this

01:08:21,569 --> 01:08:28,799
implementation what happens if I

01:08:25,889 --> 01:08:31,650
implement in it underscore underscore in

01:08:28,799 --> 01:08:35,580
it and inside under screen is coordinate

01:08:31,650 --> 01:08:40,520
I I utilize some values inside the

01:08:35,580 --> 01:08:42,690
instance in it would be called each time

01:08:40,520 --> 01:08:44,639
so you have to be careful when you

01:08:42,690 --> 01:08:46,380
implement a singleton this way actually

01:08:44,639 --> 01:08:48,630
they're the best way to implement a

01:08:46,380 --> 01:08:51,000
single tony python is just use a plane

01:08:48,630 --> 01:08:54,540
module and they find that your your

01:08:51,000 --> 01:08:57,540
attributes and they find their your

01:08:54,540 --> 01:08:59,449
functions and use it this way because it

01:08:57,540 --> 01:09:03,299
is easier than this this implementation

01:08:59,449 --> 01:09:05,159
otherwise if you implement a singleton

01:09:03,299 --> 01:09:06,929
this way you have to be really careful

01:09:05,159 --> 01:09:09,089
in the underscore underscore in it

01:09:06,929 --> 01:09:12,270
because for instance utilize an

01:09:09,089 --> 01:09:14,239
attribute with value zero it's time its

01:09:12,270 --> 01:09:16,920
standard you retrieve a new a new

01:09:14,239 --> 01:09:18,659
instance actually the same instance of

01:09:16,920 --> 01:09:20,909
the singleton you would be changing it

01:09:18,659 --> 01:09:27,739
in it because in it is called anyways if

01:09:20,909 --> 01:09:27,739
it exists so you have to be careful okay

01:09:28,069 --> 01:09:37,080
we can also a new is used to customize

01:09:32,549 --> 01:09:39,509
the creation of built-in types it's not

01:09:37,080 --> 01:09:41,219
possible to declare to to customize the

01:09:39,509 --> 01:09:44,339
in it then the skylanders coordinate

01:09:41,219 --> 01:09:47,489
when subclassing float for instance so

01:09:44,339 --> 01:09:51,270
you can do it in New this is a Maggie

01:09:47,489 --> 01:09:55,139
class but well it takes a float and it

01:09:51,270 --> 01:10:00,179
drowns the flood afloat to do the same

01:09:55,139 --> 01:10:02,580
as position let's try it the only way to

01:10:00,179 --> 01:10:07,100
do it is in the new depending on which

01:10:02,580 --> 01:10:07,100
built-in type you are you are in editing

01:10:08,510 --> 01:10:15,239
and this is a usage of new factory

01:10:12,239 --> 01:10:19,230
pattern singleton a customized certain

01:10:15,239 --> 01:10:21,540
built-in types yeah this is it single

01:10:19,230 --> 01:10:24,150
top pattern after I would recommend you

01:10:21,540 --> 01:10:27,090
use a plane module and that's all

01:10:24,150 --> 01:10:33,720
factory pattern so classing in multiple

01:10:27,090 --> 01:10:39,570
types set time and also in custom metal

01:10:33,720 --> 01:10:47,850
places what's a metaclass anybody know

01:10:39,570 --> 01:10:51,770
the answer yeah that's it amita class is

01:10:47,850 --> 01:10:54,840
the class of the class or the type of

01:10:51,770 --> 01:10:59,160
your class if you want you don't want to

01:10:54,840 --> 01:11:01,920
repeat class but we have our dictionary

01:10:59,160 --> 01:11:05,820
and type is verbose creators dictionary

01:11:01,920 --> 01:11:12,960
fine what's the type of the type type of

01:11:05,820 --> 01:11:15,390
the type is type in other words what's

01:11:12,960 --> 01:11:19,890
the class of the class the class of a

01:11:15,390 --> 01:11:26,460
class is type what does it mean it means

01:11:19,890 --> 01:11:31,020
that when Python came here when the Dead

01:11:26,460 --> 01:11:33,390
better had to read these statements it

01:11:31,020 --> 01:11:37,020
created that class the class is also an

01:11:33,390 --> 01:11:45,710
object inside Python and you are able to

01:11:37,020 --> 01:11:47,850
customize which kind of object is it so

01:11:45,710 --> 01:11:50,280
the first thing that they have to say

01:11:47,850 --> 01:11:53,900
here is that Tim Peters I'm not sure if

01:11:50,280 --> 01:11:56,430
you know who is Tim Peters it's one of

01:11:53,900 --> 01:11:59,630
let's say creators of Python or the

01:11:56,430 --> 01:12:06,030
contributors to python and he said that

01:11:59,630 --> 01:12:08,640
something like said something like if

01:12:06,030 --> 01:12:10,860
you don't know what our meta classes

01:12:08,640 --> 01:12:15,780
it's because maybe you don't need meta

01:12:10,860 --> 01:12:17,730
glasses so today here we you are going

01:12:15,780 --> 01:12:21,210
to at least try to understand what are

01:12:17,730 --> 01:12:22,830
they but bear in mind that it's

01:12:21,210 --> 01:12:25,620
something really complex it's like like

01:12:22,830 --> 01:12:27,780
new if up to now you have never used new

01:12:25,620 --> 01:12:28,860
maybe it's because you have never most

01:12:27,780 --> 01:12:36,090
probably is because you have never

01:12:28,860 --> 01:12:39,810
needed new ok but let's implement a

01:12:36,090 --> 01:12:41,520
metaclass okay well look if you take the

01:12:39,810 --> 01:12:46,010
bus k director and booster and we take

01:12:41,520 --> 01:12:46,010
it's tied directly this is it

01:12:46,660 --> 01:12:56,060
by default the metaclass so the type of

01:12:50,900 --> 01:13:01,160
all the classes is type as we are seeing

01:12:56,060 --> 01:13:04,360
here but you can customize it this is a

01:13:01,160 --> 01:13:04,360
metaclass implementation

01:13:09,290 --> 01:13:14,630
okay it just again it's called supper so

01:13:12,290 --> 01:13:20,140
it does nothing besides printing a lot

01:13:14,630 --> 01:13:20,140
of stuff printing all its arguments okay

01:13:25,559 --> 01:13:33,719
yes only half new as you as we have seen

01:13:29,699 --> 01:13:36,659
near with each time an instance is

01:13:33,719 --> 01:13:38,789
created not initialized okay so pay

01:13:36,659 --> 01:13:41,159
attention we're going to see how empty

01:13:38,789 --> 01:13:47,669
glass is used but it happened really

01:13:41,159 --> 01:13:50,219
fast why because look at this the

01:13:47,669 --> 01:13:52,979
metaclass is used when the class is

01:13:50,219 --> 01:13:58,800
created when it's created the class it's

01:13:52,979 --> 01:14:02,789
created an import time look at all these

01:13:58,800 --> 01:14:07,530
traces here so the metaclass has already

01:14:02,789 --> 01:14:12,929
run the new method has already been

01:14:07,530 --> 01:14:16,619
executed when this console it has taken

01:14:12,929 --> 01:14:18,809
all this piece of code and and has

01:14:16,619 --> 01:14:20,669
interpreted it it has created the class

01:14:18,809 --> 01:14:26,489
and it's at that moment when the

01:14:20,669 --> 01:14:27,929
metaclass is taken and it's used it's

01:14:26,489 --> 01:14:30,629
really important to understand this this

01:14:27,929 --> 01:14:33,569
stuff so it's exactly the same thing

01:14:30,629 --> 01:14:35,369
that we had with immutable define as

01:14:33,569 --> 01:14:38,010
default values or as class attributes

01:14:35,369 --> 01:14:40,019
the end is created at the import time

01:14:38,010 --> 01:14:45,780
and this is at the same moment when the

01:14:40,019 --> 01:14:48,749
metaclass is used at what can you do

01:14:45,780 --> 01:14:54,959
here let's let's look at the arguments

01:14:48,749 --> 01:15:00,389
of the metaclass we received the

01:14:54,959 --> 01:15:05,789
metaclass we received the name of the

01:15:00,389 --> 01:15:11,419
new class we received ancestors of the

01:15:05,789 --> 01:15:14,639
new class here object and we received

01:15:11,419 --> 01:15:18,569
this dictionary was this dictionary this

01:15:14,639 --> 01:15:22,289
dictionary is the content is a content

01:15:18,569 --> 01:15:27,929
of the class its method its class

01:15:22,289 --> 01:15:30,030
attributes so what do you why do you

01:15:27,929 --> 01:15:35,010
wanna meet a class what do you think

01:15:30,030 --> 01:15:38,339
that you could do here you could for

01:15:35,010 --> 01:15:38,920
instance force that all your classes

01:15:38,339 --> 01:15:40,989
have

01:15:38,920 --> 01:15:42,820
set time attributes you could that clear

01:15:40,989 --> 01:15:47,770
in the dictionary you could additionally

01:15:42,820 --> 01:15:56,800
modify it or you could take the methods

01:15:47,770 --> 01:15:58,150
and decorate them if you want so it's

01:15:56,800 --> 01:16:03,730
important on the standard the metaclass

01:15:58,150 --> 01:16:11,020
axe is used in import time okay so let's

01:16:03,730 --> 01:16:13,630
an example and we will have finished now

01:16:11,020 --> 01:16:16,900
we can check the type of our meta

01:16:13,630 --> 01:16:22,620
classes class and time it's not type

01:16:16,900 --> 01:16:22,620
anymore now it's over metaclass okay

01:16:26,280 --> 01:16:33,690
yeah less less one minute I will not one

01:16:29,350 --> 01:16:35,860
not but ok but so let's see real example

01:16:33,690 --> 01:16:38,560
have you understood how it works a

01:16:35,860 --> 01:16:40,420
metaclass any any doubts any questions

01:16:38,560 --> 01:16:49,989
because this is the last example and we

01:16:40,420 --> 01:16:51,640
finish so no it's how you have to you

01:16:49,989 --> 01:16:54,910
you have two ways to define the

01:16:51,640 --> 01:16:56,980
metaclass you can you can define inside

01:16:54,910 --> 01:17:00,580
the a class a class at ewood called

01:16:56,980 --> 01:17:03,070
underscore underscore metaclass or you

01:17:00,580 --> 01:17:05,199
can define it system-wide with a global

01:17:03,070 --> 01:17:11,199
variable called metaclass also

01:17:05,199 --> 01:17:16,179
underscored metaclass so in my case the

01:17:11,199 --> 01:17:18,100
most the way I must use meta classes is

01:17:16,179 --> 01:17:22,030
to apply the craters on the month

01:17:18,100 --> 01:17:26,770
instead of going to all the methods of

01:17:22,030 --> 01:17:29,949
my of my class I'm decorating all all of

01:17:26,770 --> 01:17:31,840
them with with the odd symbol and

01:17:29,949 --> 01:17:36,420
putting the decorator I can do it here

01:17:31,840 --> 01:17:40,030
in my metaclass let's see an example how

01:17:36,420 --> 01:17:45,480
how many of you know or have implemented

01:17:40,030 --> 01:17:49,080
ever a decorator well

01:17:45,480 --> 01:17:50,610
it's not our goal today so you have to

01:17:49,080 --> 01:17:58,710
believe me that this is implementation

01:17:50,610 --> 01:18:06,570
of a liquidator this is a method which

01:17:58,710 --> 01:18:11,340
can decorate attributes and this is my

01:18:06,570 --> 01:18:15,480
metaclass look here instead of creating

01:18:11,340 --> 01:18:19,550
the class with the original attribute

01:18:15,480 --> 01:18:22,410
dictionary I call my method to decorate

01:18:19,550 --> 01:18:26,880
them this may forget to the same

01:18:22,410 --> 01:18:29,850
dictionary but I look at it and each

01:18:26,880 --> 01:18:33,330
method I found inside it is a created

01:18:29,850 --> 01:18:37,530
with my decorator in this case the

01:18:33,330 --> 01:18:42,000
decorator prints something if the result

01:18:37,530 --> 01:18:44,870
is not evaluated as true okay in the

01:18:42,000 --> 01:18:48,840
doll how I use it typically i have

01:18:44,870 --> 01:18:50,010
configuration somewhere and I write in

01:18:48,840 --> 01:18:51,840
the configuration the name of the

01:18:50,010 --> 01:18:55,200
methods do they want or the name of the

01:18:51,840 --> 01:18:58,230
classes that they want to decorate and i

01:18:55,200 --> 01:19:01,110
only use it in when when in development

01:18:58,230 --> 01:19:05,340
like testing you can implement decorator

01:19:01,110 --> 01:19:07,230
to do login to the timing or this kind

01:19:05,340 --> 01:19:08,850
of things and this way you can easily

01:19:07,230 --> 01:19:12,150
say okay i want to decorate exactly this

01:19:08,850 --> 01:19:14,340
method name and this method name and I

01:19:12,150 --> 01:19:16,590
in let me meet a classic rate them and I

01:19:14,340 --> 01:19:19,010
don't have to go to the model where they

01:19:16,590 --> 01:19:21,810
are defined and right there add

01:19:19,010 --> 01:19:24,000
decorator and this kind of stuff I can

01:19:21,810 --> 01:19:26,400
save it and I do it here it's really

01:19:24,000 --> 01:19:28,350
complex I repeat what Tim Peter said if

01:19:26,400 --> 01:19:29,640
you don't if you have if you don't

01:19:28,350 --> 01:19:33,270
understand them if you don't need it

01:19:29,640 --> 01:19:39,420
most probably it's it's you you wouldn't

01:19:33,270 --> 01:19:41,540
need yeah so this is it it works and I

01:19:39,420 --> 01:19:44,430
have decorated and I have decorated

01:19:41,540 --> 01:19:48,270
automatically all the methods inside my

01:19:44,430 --> 01:19:52,500
class with this meta class ok so to swim

01:19:48,270 --> 01:19:56,520
up really fast with new you intercept

01:19:52,500 --> 01:19:58,780
the creation of instances it is executed

01:19:56,520 --> 01:20:01,619
on instantiation time

01:19:58,780 --> 01:20:05,639
when the instance is created and it

01:20:01,619 --> 01:20:07,929
affects all the instances one by one on

01:20:05,639 --> 01:20:10,329
the other hand you have the metaclass

01:20:07,929 --> 01:20:13,329
with a metaclass you can intercept the

01:20:10,329 --> 01:20:16,420
clear the creation of a class of the

01:20:13,329 --> 01:20:18,880
class itself so it's executed on import

01:20:16,420 --> 01:20:20,829
time and its effects to all instances

01:20:18,880 --> 01:20:22,719
but only at once so if you change

01:20:20,829 --> 01:20:26,110
something in the metaclass you change

01:20:22,719 --> 01:20:30,489
forever for all the instances that you

01:20:26,110 --> 01:20:32,739
create of that class and with this I

01:20:30,489 --> 01:20:34,780
think that we can finish so take a look

01:20:32,739 --> 01:20:39,849
at it and I'll be here the whole week

01:20:34,780 --> 01:20:41,650
and you have more dogs come and be led

01:20:39,849 --> 01:20:44,789
to transfer you dubs sorry for the

01:20:41,650 --> 01:20:44,789
timing no no

01:20:50,120 --> 01:20:56,130
thanks to Pablo remember you all to

01:20:53,070 --> 01:20:58,920
bottle his car so its very name because

01:20:56,130 --> 01:21:03,020
I think issue with the service on a war

01:20:58,920 --> 01:21:06,180
mobile application lunch is usually in a

01:21:03,020 --> 01:21:09,060
dining room of your tail and forever

01:21:06,180 --> 01:21:12,240
your other question you can find in a

01:21:09,060 --> 01:21:14,160
your guidebook here but you was given

01:21:12,240 --> 01:21:17,750
him a beggar ok thanks again Pablo

01:21:14,160 --> 01:21:17,750

YouTube URL: https://www.youtube.com/watch?v=LTXOP7ykwy8


