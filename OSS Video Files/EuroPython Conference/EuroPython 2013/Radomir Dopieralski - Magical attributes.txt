Title: Radomir Dopieralski - Magical attributes
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	[EuroPython 2013] Radomir Dopieralski - Magical attributes - 05 July 2013 "Track Spaghetti"
Captions: 
	00:00:00,000 --> 00:00:14,880
I get the Trent a second I come in tomm

00:00:05,250 --> 00:00:17,220
oh ok so let's welcome radomir now

00:00:14,880 --> 00:00:19,770
everybody knows who is and which talk is

00:00:17,220 --> 00:00:30,990
that because I repeated it six times and

00:00:19,770 --> 00:00:33,450
now so welcome ok thank you I'm going to

00:00:30,990 --> 00:00:37,380
tell you about the Magica attributes in

00:00:33,450 --> 00:00:40,320
Python those are all the attributes that

00:00:37,380 --> 00:00:43,290
start with double underscore and with

00:00:40,320 --> 00:00:46,920
double underscore there is one

00:00:43,290 --> 00:00:51,360
clarification first I will be talking

00:00:46,920 --> 00:00:53,879
about Python to mostly 2.7 there have

00:00:51,360 --> 00:00:55,440
been several changes in Python 3 I will

00:00:53,879 --> 00:00:59,309
try to point them out but I can't

00:00:55,440 --> 00:01:03,570
promise you that I will remember so this

00:00:59,309 --> 00:01:07,409
talk is about Python 2.7 if you need to

00:01:03,570 --> 00:01:10,400
see the differences most of information

00:01:07,409 --> 00:01:15,290
is the spot in this talk is from the

00:01:10,400 --> 00:01:20,100
pythons data object model documentation

00:01:15,290 --> 00:01:22,770
so date so so if you need to reach

00:01:20,100 --> 00:01:24,750
something or clarify something let's go

00:01:22,770 --> 00:01:26,850
to the documentation most of the things

00:01:24,750 --> 00:01:30,450
are there some of the things I had to

00:01:26,850 --> 00:01:33,240
track or look into the source code to to

00:01:30,450 --> 00:01:38,040
be sure how they work but those are

00:01:33,240 --> 00:01:39,420
mostly small details second thing is i

00:01:38,040 --> 00:01:43,649
will be talking about new-style classes

00:01:39,420 --> 00:01:47,329
the old style classes behave a little

00:01:43,649 --> 00:01:51,299
bit different underneath underneath and

00:01:47,329 --> 00:01:54,270
I don't want have time to tell about

00:01:51,299 --> 00:01:57,000
that there will be some simplifications

00:01:54,270 --> 00:01:59,250
i will be showing you code that kind of

00:01:57,000 --> 00:02:01,820
does what python actually does but it

00:01:59,250 --> 00:02:04,220
will be simplified it won't be

00:02:01,820 --> 00:02:06,860
taking care of the old all the corner

00:02:04,220 --> 00:02:11,120
cases because I want it to be simple

00:02:06,860 --> 00:02:13,370
easy to understand and finally this is a

00:02:11,120 --> 00:02:15,140
half hour talk I won't cover all the

00:02:13,370 --> 00:02:17,120
attributes that i would like to cover

00:02:15,140 --> 00:02:20,150
its not comprehensive there are lots of

00:02:17,120 --> 00:02:23,690
other attributes there but are you also

00:02:20,150 --> 00:02:27,670
very useful and interesting but it won't

00:02:23,690 --> 00:02:31,550
fit in this presentation so that's that

00:02:27,670 --> 00:02:35,420
we'll start with collections and they

00:02:31,550 --> 00:02:37,690
have they have a lot of useful medical

00:02:35,420 --> 00:02:46,430
attributes but those are the most

00:02:37,690 --> 00:02:49,610
commonly used and well the easiest way

00:02:46,430 --> 00:02:53,060
to explain how code works is to show the

00:02:49,610 --> 00:02:55,580
code so I to throughout this

00:02:53,060 --> 00:02:59,360
presentation I will be showing you code

00:02:55,580 --> 00:03:04,459
that explains how vital internally

00:02:59,360 --> 00:03:08,570
interprets the different things that you

00:03:04,459 --> 00:03:11,299
tell it so basically if you call a land

00:03:08,570 --> 00:03:15,250
on something it will just call the

00:03:11,299 --> 00:03:21,410
Thunder up by the dander is a short form

00:03:15,250 --> 00:03:25,640
double underscore and basically calls

00:03:21,410 --> 00:03:30,860
land in course contains and not in its

00:03:25,640 --> 00:03:34,970
basically not social Dana so that that

00:03:30,860 --> 00:03:37,880
simple when you use the square brackets

00:03:34,970 --> 00:03:39,980
it's it calls get items that item and

00:03:37,880 --> 00:03:45,380
then I can depending on the context

00:03:39,980 --> 00:03:47,390
that's also very easy when you use

00:03:45,380 --> 00:03:51,120
square brackets with with the slice

00:03:47,390 --> 00:03:54,930
notation with the Collins

00:03:51,120 --> 00:03:58,379
it depends actually how what the object

00:03:54,930 --> 00:04:04,370
that you call it on Hoss if it helps has

00:03:58,379 --> 00:04:07,319
the gates lies a method which is

00:04:04,370 --> 00:04:09,569
deprecated or sets light on those lines

00:04:07,319 --> 00:04:12,810
depending on what operation you are

00:04:09,569 --> 00:04:15,840
doing so if you didn't provide the step

00:04:12,810 --> 00:04:17,850
and it has a good slice it will call

00:04:15,840 --> 00:04:21,600
call that but before it will call that

00:04:17,850 --> 00:04:25,350
it will normalize the parameters that

00:04:21,600 --> 00:04:28,710
you pass so as you can see it will make

00:04:25,350 --> 00:04:31,139
sure well if it's not there it will be

00:04:28,710 --> 00:04:34,169
if their start is not there it will be 0

00:04:31,139 --> 00:04:37,590
and if it's negative it will add the

00:04:34,169 --> 00:04:40,229
length of your correction and the same

00:04:37,590 --> 00:04:42,840
way with end if it's not there it will

00:04:40,229 --> 00:04:46,139
be max int which is kind of arbitrary

00:04:42,840 --> 00:04:49,979
actually because my toe is not limited

00:04:46,139 --> 00:04:54,570
them to maxine in what size of the

00:04:49,979 --> 00:04:57,690
numbers you can use but this is all the

00:04:54,570 --> 00:05:02,669
old interface so and then also it will

00:04:57,690 --> 00:05:04,889
be get fixed if it's negative and it

00:05:02,669 --> 00:05:06,660
will call the gate slice or such lies or

00:05:04,889 --> 00:05:10,260
they'll slice depending on what you are

00:05:06,660 --> 00:05:14,300
doing one thing to remember this doesn't

00:05:10,260 --> 00:05:14,300
go aren t that it will be positive so

00:05:14,479 --> 00:05:20,280
it's may still be negative when it gets

00:05:17,310 --> 00:05:24,060
to your to your method and that's the

00:05:20,280 --> 00:05:26,430
deprecated way because right now it will

00:05:24,060 --> 00:05:28,650
just create a slice object from those

00:05:26,430 --> 00:05:34,560
parameters that you pass and will pass

00:05:28,650 --> 00:05:40,949
it to to get out or set up or there are

00:05:34,560 --> 00:05:43,289
like like before yes so you can just

00:05:40,949 --> 00:05:47,690
track if it's a slice object and then

00:05:43,289 --> 00:05:47,690
handle it how you want

00:05:48,080 --> 00:05:56,689
one of the most powerful things in in

00:05:52,789 --> 00:05:59,060
Python that really make it simple to

00:05:56,689 --> 00:06:01,699
write programs is the iterator protocol

00:05:59,060 --> 00:06:05,419
and when when you for example when you

00:06:01,699 --> 00:06:09,349
write a for loop this is what what

00:06:05,419 --> 00:06:11,990
Python will do behind the scenes it will

00:06:09,349 --> 00:06:14,689
take your sequence and create an

00:06:11,990 --> 00:06:18,110
iterator out of it I'll at least try to

00:06:14,689 --> 00:06:20,990
create an iterator out of it and it does

00:06:18,110 --> 00:06:24,409
that by by calling the title method on

00:06:20,990 --> 00:06:26,240
that the item metal is supposed to

00:06:24,409 --> 00:06:29,060
return an iterator for for that

00:06:26,240 --> 00:06:34,069
particular collection then it will

00:06:29,060 --> 00:06:36,590
iterate in a row loop and keep calling

00:06:34,069 --> 00:06:39,319
next on that iterator together the next

00:06:36,590 --> 00:06:41,629
element from the collection and it will

00:06:39,319 --> 00:06:45,020
keep doing that until you write a stop

00:06:41,629 --> 00:06:49,669
iteration exception when you do that it

00:06:45,020 --> 00:06:52,759
will just exit the loop of course you

00:06:49,669 --> 00:06:55,550
can have an alt class in the fall loop

00:06:52,759 --> 00:06:58,789
and things like that and break and

00:06:55,550 --> 00:07:02,539
continue so that's not handled in here

00:06:58,789 --> 00:07:05,089
but this is the basic ID so to make

00:07:02,539 --> 00:07:08,960
something iterable you just put an

00:07:05,089 --> 00:07:11,779
either method on it and make it return

00:07:08,960 --> 00:07:16,819
the iterator usually you just make this

00:07:11,779 --> 00:07:22,339
item method iterator generator itself so

00:07:16,819 --> 00:07:26,750
just yield things from it when you make

00:07:22,339 --> 00:07:29,629
your own object like object apart

00:07:26,750 --> 00:07:33,349
from the get up and get item and set

00:07:29,629 --> 00:07:35,960
item and their item methods there are

00:07:33,349 --> 00:07:41,719
lot of useful methods in the dict like

00:07:35,960 --> 00:07:45,740
like update or or I don't know husky and

00:07:41,719 --> 00:07:48,440
then stuff like that and reading them

00:07:45,740 --> 00:07:52,129
all by hand is a lot of boilerplate so

00:07:48,440 --> 00:07:56,089
you can just make your object inherit

00:07:52,129 --> 00:07:59,710
from this dick mixing and that will let

00:07:56,089 --> 00:08:02,320
you it will use the basic met

00:07:59,710 --> 00:08:05,350
that you already have to implement all

00:08:02,320 --> 00:08:07,000
the rest of them so you don't have to

00:08:05,350 --> 00:08:10,000
write them themselves of course they

00:08:07,000 --> 00:08:14,820
won't be optimal but you can always add

00:08:10,000 --> 00:08:18,160
your own optimal implementations later

00:08:14,820 --> 00:08:20,520
ok let's go to attribute this is the

00:08:18,160 --> 00:08:23,560
most complicated part so brace yourself

00:08:20,520 --> 00:08:26,020
by the way if you feel if you are not

00:08:23,560 --> 00:08:27,640
confused in if you feel like you

00:08:26,020 --> 00:08:32,310
understand everything you are not

00:08:27,640 --> 00:08:32,310
learning so considering is a good thing

00:08:33,000 --> 00:08:42,460
ok so when you access something on an

00:08:37,390 --> 00:08:46,140
object to the dot operator it's actually

00:08:42,460 --> 00:08:49,270
called get attribute on that thing and

00:08:46,140 --> 00:08:52,000
we will get to the details of get

00:08:49,270 --> 00:08:55,420
attribute in a moment because that part

00:08:52,000 --> 00:09:03,190
a bit complicated and when you set some

00:08:55,420 --> 00:09:06,100
value it will call setup and it will

00:09:03,190 --> 00:09:08,950
only take four set up on the class of

00:09:06,100 --> 00:09:11,680
this thing so if you have an object and

00:09:08,950 --> 00:09:14,320
you just monkey patch a set up on it

00:09:11,680 --> 00:09:17,640
that won't work it has to be on the

00:09:14,320 --> 00:09:20,830
class of the object actually a lot of

00:09:17,640 --> 00:09:22,390
those magical attributes have to be

00:09:20,830 --> 00:09:28,630
defined on the class not on the object

00:09:22,390 --> 00:09:31,540
directly so that's kind of a safety

00:09:28,630 --> 00:09:34,480
mechanism so that you don't shoot

00:09:31,540 --> 00:09:38,560
yourself in the foot also it's faster

00:09:34,480 --> 00:09:40,300
that way and well the implementation is

00:09:38,560 --> 00:09:43,090
pretty straightforward if there is a

00:09:40,300 --> 00:09:46,060
setup it will call the setup otherwise

00:09:43,090 --> 00:09:48,700
it will do the default think so what you

00:09:46,060 --> 00:09:52,210
expect it will add up the value to the

00:09:48,700 --> 00:09:54,310
dicks of that object and it will only

00:09:52,210 --> 00:09:56,890
add the value to the local dick it will

00:09:54,310 --> 00:10:00,310
never modify the things that you inherit

00:09:56,890 --> 00:10:01,420
from so all modifications are only on

00:10:00,310 --> 00:10:05,050
the object that you are actually

00:10:01,420 --> 00:10:07,600
modifying and the same is with them sort

00:10:05,050 --> 00:10:10,010
of that's pretty straightforward

00:10:07,600 --> 00:10:17,180
getattribute is a little bit more

00:10:10,010 --> 00:10:21,980
complicated because it has to check all

00:10:17,180 --> 00:10:25,190
the classes from which you inherit so

00:10:21,980 --> 00:10:27,650
first it will check if there is if there

00:10:25,190 --> 00:10:31,430
is your the name we are trying to access

00:10:27,650 --> 00:10:35,000
if it is in the dict of the attributes

00:10:31,430 --> 00:10:37,820
that you have directly if it is it will

00:10:35,000 --> 00:10:41,660
just return that immediately no

00:10:37,820 --> 00:10:43,310
questions asked of course you can you

00:10:41,660 --> 00:10:48,740
can overwrite this get attributes to

00:10:43,310 --> 00:10:50,900
have your own behavior but if you don't

00:10:48,740 --> 00:10:54,710
then it will check all the classes that

00:10:50,900 --> 00:10:57,410
you inherit from and it will track the

00:10:54,710 --> 00:11:01,130
dell D and if it's there it will return

00:10:57,410 --> 00:11:05,480
that and finally if it doesn't find find

00:11:01,130 --> 00:11:09,740
it in in the object and in the classes

00:11:05,480 --> 00:11:12,589
it will call get out so you can override

00:11:09,740 --> 00:11:14,570
only days to handle the missing

00:11:12,589 --> 00:11:16,160
attributes if you only want to handle

00:11:14,570 --> 00:11:19,220
the attributes that are not there on

00:11:16,160 --> 00:11:22,460
your object directly then define gether

00:11:19,220 --> 00:11:24,500
if you want to have control over all

00:11:22,460 --> 00:11:35,330
attribute access you overwrite get

00:11:24,500 --> 00:11:38,720
attribute okay and that was a lie

00:11:35,330 --> 00:11:43,130
actually because those methods are much

00:11:38,720 --> 00:11:48,050
more complicated so there is the

00:11:43,130 --> 00:11:51,560
so-called descriptor descriptor protocol

00:11:48,050 --> 00:11:54,860
in Python and then I probably already

00:11:51,560 --> 00:11:57,830
talks about this descriptive protocol

00:11:54,860 --> 00:12:00,560
and they were covered in the table let's

00:11:57,830 --> 00:12:04,820
just quickly look at what how it works

00:12:00,560 --> 00:12:08,150
so the part that is different is when

00:12:04,820 --> 00:12:10,670
the attribute is on the class itself it

00:12:08,150 --> 00:12:13,730
doesn't well when it's on the object

00:12:10,670 --> 00:12:19,420
directly it doesn't change if it's on

00:12:13,730 --> 00:12:21,310
the class it will it will still

00:12:19,420 --> 00:12:23,470
look for the attribute on that class and

00:12:21,310 --> 00:12:27,240
if it's there on that class it will

00:12:23,470 --> 00:12:30,130
check if the attribute has a get method

00:12:27,240 --> 00:12:32,410
if there is a get method instead of

00:12:30,130 --> 00:12:34,330
returning the attribute that it found it

00:12:32,410 --> 00:12:38,440
will call that get method and return

00:12:34,330 --> 00:12:43,870
that so that's how for example property

00:12:38,440 --> 00:12:46,660
works instead of getting the property

00:12:43,870 --> 00:12:49,420
object you are you know it calls the

00:12:46,660 --> 00:12:52,750
accessor on that product property they

00:12:49,420 --> 00:12:55,570
get method and it's the same for set out

00:12:52,750 --> 00:12:59,080
and a lot it's it just looks very

00:12:55,570 --> 00:13:01,450
complicated because I had to slap this

00:12:59,080 --> 00:13:06,400
class searching code in there because

00:13:01,450 --> 00:13:11,140
they didn't have it initially and it's

00:13:06,400 --> 00:13:17,280
set and actually I can scroll that and

00:13:11,140 --> 00:13:19,810
delete so they do the same stuff and

00:13:17,280 --> 00:13:23,080
this is very powerful and I will show

00:13:19,810 --> 00:13:25,270
you that a lot of Python internals is

00:13:23,080 --> 00:13:27,970
actually based on these descriptor

00:13:25,270 --> 00:13:30,190
protocols so for example object methods

00:13:27,970 --> 00:13:34,690
are also descriptors functions are

00:13:30,190 --> 00:13:36,970
descriptors so there is an example of

00:13:34,690 --> 00:13:41,290
how you can make your own property

00:13:36,970 --> 00:13:43,380
decorator that will do a simplified

00:13:41,290 --> 00:13:46,270
version of what the real one does

00:13:43,380 --> 00:13:51,280
basically you just have a club that has

00:13:46,270 --> 00:13:54,820
a get method and it calls the your

00:13:51,280 --> 00:13:57,250
decorated function so the function that

00:13:54,820 --> 00:13:59,590
you've decorated and if you use it like

00:13:57,250 --> 00:14:06,970
this you get the same thing that's

00:13:59,590 --> 00:14:10,920
prepared to give you okay and you can

00:14:06,970 --> 00:14:14,650
also see how how get takes the instance

00:14:10,920 --> 00:14:17,800
of the of the object that you're

00:14:14,650 --> 00:14:20,860
accessing and the class on which it was

00:14:17,800 --> 00:14:24,880
actually defined so you can have you can

00:14:20,860 --> 00:14:28,120
for example call other things on this on

00:14:24,880 --> 00:14:29,860
this class and when you actually access

00:14:28,120 --> 00:14:31,100
that rebuilt on the club directly the

00:14:29,860 --> 00:14:37,310
instance will be known

00:14:31,100 --> 00:14:41,800
you'll only get down there let's go to

00:14:37,310 --> 00:14:46,180
functions so when you call a function

00:14:41,800 --> 00:14:49,940
this is a little bit awkward because

00:14:46,180 --> 00:14:51,830
yeah when you call a function Python

00:14:49,940 --> 00:14:55,130
actually calls the curl method of that

00:14:51,830 --> 00:14:57,560
function but you can see this is kind of

00:14:55,130 --> 00:15:00,110
turtles out the way down so this

00:14:57,560 --> 00:15:04,390
actually happens in C code so it's not

00:15:00,110 --> 00:15:07,700
like this directly but if you examine a

00:15:04,390 --> 00:15:09,260
function object if you did run dear on a

00:15:07,700 --> 00:15:13,010
functional block you can see that it

00:15:09,260 --> 00:15:15,530
actually has a cold method on it so it's

00:15:13,010 --> 00:15:17,870
internally working like that too and you

00:15:15,530 --> 00:15:20,120
can put a call method also on your own

00:15:17,870 --> 00:15:22,040
objects on your own classes and even on

00:15:20,120 --> 00:15:29,930
modules so you can have a color

00:15:22,040 --> 00:15:34,330
colorable model it just works one

00:15:29,930 --> 00:15:36,620
important thing because the a lot of

00:15:34,330 --> 00:15:42,010
magical attributes on a function like

00:15:36,620 --> 00:15:46,190
dogs drink and module name and it's a

00:15:42,010 --> 00:15:48,170
package name and things like that when

00:15:46,190 --> 00:15:51,950
you are making a decorator that wraps

00:15:48,170 --> 00:15:55,430
that function you and and returns and a

00:15:51,950 --> 00:15:57,470
different function the the wrapper the

00:15:55,430 --> 00:15:59,630
wrapper usually don't doesn't have all

00:15:57,470 --> 00:16:02,810
those attributes so it's important to

00:15:59,630 --> 00:16:05,210
use this decorator that will copy all

00:16:02,810 --> 00:16:08,530
the dog strings module name and things

00:16:05,210 --> 00:16:12,020
like that into your new function so that

00:16:08,530 --> 00:16:16,340
for example fluff views will will still

00:16:12,020 --> 00:16:18,590
work it's especially important if you

00:16:16,340 --> 00:16:25,190
have some code that uses the function

00:16:18,590 --> 00:16:28,480
name later on okay as you know python

00:16:25,190 --> 00:16:32,390
has closed so you can define a function

00:16:28,480 --> 00:16:34,700
inside another function and that inner

00:16:32,390 --> 00:16:36,170
function has access to the variable to

00:16:34,700 --> 00:16:40,430
the local variables of the outer

00:16:36,170 --> 00:16:42,650
function here is an example of a simple

00:16:40,430 --> 00:16:48,060
closure

00:16:42,650 --> 00:16:50,940
if you run this we have a function

00:16:48,060 --> 00:16:54,540
factory we call it two times to create

00:16:50,940 --> 00:16:57,630
two different functions and if you look

00:16:54,540 --> 00:17:00,870
at the results of calling them you can

00:16:57,630 --> 00:17:05,900
see that each of those functions has its

00:17:00,870 --> 00:17:08,610
own copy of the variable variable and

00:17:05,900 --> 00:17:11,730
that's because every time you call

00:17:08,610 --> 00:17:14,190
function factory a new function scope is

00:17:11,730 --> 00:17:17,190
created in memory and it has to be kept

00:17:14,190 --> 00:17:25,170
for the inner function to work because

00:17:17,190 --> 00:17:29,250
the inner function uses that variable so

00:17:25,170 --> 00:17:31,680
the closure is actually kept on the

00:17:29,250 --> 00:17:35,490
function object itself it's called in

00:17:31,680 --> 00:17:38,520
the under closure attribute and you can

00:17:35,490 --> 00:17:40,500
actually look at it it's full of cell

00:17:38,520 --> 00:17:44,640
objects and sell objects are a way of

00:17:40,500 --> 00:17:46,530
encapsulating those kind of keeping a

00:17:44,640 --> 00:17:53,190
reference to those variables inside a

00:17:46,530 --> 00:17:55,350
different scope the way methods are

00:17:53,190 --> 00:17:59,160
implemented using the scripture protocol

00:17:55,350 --> 00:18:01,920
so you probably have noticed that when

00:17:59,160 --> 00:18:05,250
you pass a method around for example to

00:18:01,920 --> 00:18:08,820
add a function function parameter it

00:18:05,250 --> 00:18:11,760
actually brings its object with it it

00:18:08,820 --> 00:18:13,770
may seem like the obvious thing to do

00:18:11,760 --> 00:18:16,640
but for example Java Script doesn't do

00:18:13,770 --> 00:18:20,460
that in JavaScript there is a lot of

00:18:16,640 --> 00:18:22,410
hassle when you have to have the metal

00:18:20,460 --> 00:18:25,620
but also you have to pass the object

00:18:22,410 --> 00:18:27,180
somehow so it knows on which object to

00:18:25,620 --> 00:18:30,320
call the method in Python that's

00:18:27,180 --> 00:18:32,910
automatic and that's because of this

00:18:30,320 --> 00:18:37,640
descriptor protocol so basically

00:18:32,910 --> 00:18:41,700
whenever you access a function through

00:18:37,640 --> 00:18:45,630
to the dot notation it doesn't return

00:18:41,700 --> 00:18:49,950
you and the function itself it gives you

00:18:45,630 --> 00:18:54,150
a rapper object that this bound method

00:18:49,950 --> 00:18:58,810
object that keeps our reference to the

00:18:54,150 --> 00:19:01,570
to the object it was caught on what it

00:18:58,810 --> 00:19:04,270
was taken from so when you and when you

00:19:01,570 --> 00:19:07,840
call it it will actually call it with

00:19:04,270 --> 00:19:10,660
which self-defense argument so that's

00:19:07,840 --> 00:19:13,930
how it's done internally and if you

00:19:10,660 --> 00:19:16,300
access it on the class you will get this

00:19:13,930 --> 00:19:23,380
unbound method think that that has

00:19:16,300 --> 00:19:26,770
actually is lovely that does it so it's

00:19:23,380 --> 00:19:29,500
important to remember that this bound

00:19:26,770 --> 00:19:33,690
method object is created at the moment

00:19:29,500 --> 00:19:36,970
when you use the dot operator and

00:19:33,690 --> 00:19:41,920
usually that's transparent but if you

00:19:36,970 --> 00:19:45,130
for example have when you have a list of

00:19:41,920 --> 00:19:48,640
callbacks on some object and you use

00:19:45,130 --> 00:19:52,390
week references to store them because

00:19:48,640 --> 00:19:55,390
you don't want to for the call box to

00:19:52,390 --> 00:19:58,980
keep the object alive when the when

00:19:55,390 --> 00:20:02,500
nothing else is referring to this object

00:19:58,980 --> 00:20:06,940
so it's it's wise to use with references

00:20:02,500 --> 00:20:09,820
but then if you add to this list the

00:20:06,940 --> 00:20:13,030
bound methods not just functions but

00:20:09,820 --> 00:20:15,490
bound methods of object they will

00:20:13,030 --> 00:20:17,350
disappear instantly because they were

00:20:15,490 --> 00:20:19,630
created at the moment you use the dot

00:20:17,350 --> 00:20:24,940
operator and there is no other reference

00:20:19,630 --> 00:20:29,340
to them because they are special objects

00:20:24,940 --> 00:20:33,640
just for for this instance of the of the

00:20:29,340 --> 00:20:35,740
object so it's much it's important you

00:20:33,640 --> 00:20:38,200
have to actually wrap them in an

00:20:35,740 --> 00:20:43,630
additional objects or something like

00:20:38,200 --> 00:20:48,850
that to to keep them alive okay let's go

00:20:43,630 --> 00:20:52,360
to the object lifecycle there the three

00:20:48,850 --> 00:20:54,960
important method to you have on an

00:20:52,360 --> 00:20:54,960
object

00:20:56,049 --> 00:21:03,940
then you how new actually works it will

00:21:07,690 --> 00:21:13,640
taste it will try to create an instance

00:21:11,150 --> 00:21:18,559
of your object and it will do it by

00:21:13,640 --> 00:21:23,799
calling the new operator of the of the

00:21:18,559 --> 00:21:27,110
class Europe that you are using and that

00:21:23,799 --> 00:21:28,760
actually goes all the way up to object

00:21:27,110 --> 00:21:32,059
because we are talking about new-style

00:21:28,760 --> 00:21:34,640
classes so if you don't have a new on

00:21:32,059 --> 00:21:38,270
your class it will go to the super class

00:21:34,640 --> 00:21:42,710
of that and and so on until it reaches

00:21:38,270 --> 00:21:45,500
the new of the object itself and it will

00:21:42,710 --> 00:21:48,130
create an instance of that and if that

00:21:45,500 --> 00:21:51,260
new method returns and in actual

00:21:48,130 --> 00:21:55,520
instance of the class you are creating

00:21:51,260 --> 00:21:59,540
it will also call in it on it but you

00:21:55,520 --> 00:22:02,390
can have of course overwrite new and you

00:21:59,540 --> 00:22:05,600
can make it threaten anything like

00:22:02,390 --> 00:22:08,840
addict or an int or a drink or anything

00:22:05,600 --> 00:22:15,830
and then of course it won't call it on

00:22:08,840 --> 00:22:18,710
it so that's that that's that and that's

00:22:15,830 --> 00:22:22,640
also implemented through a call method

00:22:18,710 --> 00:22:25,610
on on the class itself so if you examine

00:22:22,640 --> 00:22:31,880
a class object you will see that it that

00:22:25,610 --> 00:22:34,970
it has a call method a couple of notes

00:22:31,880 --> 00:22:38,960
on them I won't explain well it's

00:22:34,970 --> 00:22:41,840
supposed to to remove it's supposed to

00:22:38,960 --> 00:22:44,750
be cold when when all references to your

00:22:41,840 --> 00:22:48,440
object are gone so when it's being

00:22:44,750 --> 00:22:52,929
garbage collected basically just before

00:22:48,440 --> 00:22:57,020
it garbage collected there is count but

00:22:52,929 --> 00:22:59,870
because you don't really know when that

00:22:57,020 --> 00:23:01,880
happens in C Python it usually happens

00:22:59,870 --> 00:23:05,179
when there are no more references of the

00:23:01,880 --> 00:23:06,870
object but if there are cycles it may

00:23:05,179 --> 00:23:09,630
happen later

00:23:06,870 --> 00:23:12,240
because situs won't be garbage collected

00:23:09,630 --> 00:23:15,780
by the reference counter it will be a

00:23:12,240 --> 00:23:19,290
bit collected by the garbage book and if

00:23:15,780 --> 00:23:22,170
it's dighton on ironpython or any or pie

00:23:19,290 --> 00:23:26,520
pie you don't know you really don't know

00:23:22,170 --> 00:23:28,410
when that's going to be cold and you

00:23:26,520 --> 00:23:31,110
don't know what you have a viable

00:23:28,410 --> 00:23:33,030
because for example it may be called at

00:23:31,110 --> 00:23:35,910
the end of your program when everything

00:23:33,030 --> 00:23:37,980
is being garbage collected and for

00:23:35,910 --> 00:23:40,170
example this is module might have been

00:23:37,980 --> 00:23:44,760
already garbage collected so you cannot

00:23:40,170 --> 00:23:46,110
call this path and think like that so

00:23:44,760 --> 00:23:48,750
you really don't know what you have

00:23:46,110 --> 00:23:51,780
available you should really just do the

00:23:48,750 --> 00:23:54,690
minimum code if you really must you

00:23:51,780 --> 00:23:57,059
still of course all exceptions in that

00:23:54,690 --> 00:23:59,130
code are ignored because it's cold

00:23:57,059 --> 00:24:01,140
outside of the execution flow of your

00:23:59,130 --> 00:24:04,230
program there is no way to draw in an

00:24:01,140 --> 00:24:06,450
exception and to catch it somehow so

00:24:04,230 --> 00:24:08,340
exceptions are ignored warnings are

00:24:06,450 --> 00:24:15,330
printed directly to the standard output

00:24:08,340 --> 00:24:18,000
you cannot intercept that anyway and one

00:24:15,330 --> 00:24:22,380
more reason to not use them to really

00:24:18,000 --> 00:24:27,030
think twice before you use them if you

00:24:22,380 --> 00:24:29,340
have bigger tip item at least has two

00:24:27,030 --> 00:24:33,540
mechanism for collecting for for garbage

00:24:29,340 --> 00:24:35,970
collecting objects one is the reference

00:24:33,540 --> 00:24:38,940
counting and that works if you don't

00:24:35,970 --> 00:24:42,660
have any cycles if you have a cycle you

00:24:38,940 --> 00:24:45,600
have for example an object and a that

00:24:42,660 --> 00:24:47,820
references B&B that references a they

00:24:45,600 --> 00:24:51,510
will still have reference count of one

00:24:47,820 --> 00:24:53,660
even if nothing else references them so

00:24:51,510 --> 00:24:55,950
they would stay in the memory forever

00:24:53,660 --> 00:24:58,800
that's why python has an additional

00:24:55,950 --> 00:25:01,140
mechanism that once in a while looks

00:24:58,800 --> 00:25:05,280
through the all the objects in memory

00:25:01,140 --> 00:25:09,620
and and actually I think Judith mark and

00:25:05,280 --> 00:25:12,440
sweep Argo algorithm to get rid of them

00:25:09,620 --> 00:25:15,260
and how it gets rid of them is that it

00:25:12,440 --> 00:25:18,680
breaks one of the of the references that

00:25:15,260 --> 00:25:20,990
the objects have to each other so it's

00:25:18,680 --> 00:25:23,720
it forces garbage collection of one of

00:25:20,990 --> 00:25:26,780
those objects the problem is if you have

00:25:23,720 --> 00:25:28,790
del it cannot do that because it doesn't

00:25:26,780 --> 00:25:31,640
know if you need the other objects in

00:25:28,790 --> 00:25:33,860
the Dell metals itself so it won't do

00:25:31,640 --> 00:25:36,290
that so if you have tell those object

00:25:33,860 --> 00:25:39,380
will stay in memory forever until you

00:25:36,290 --> 00:25:42,140
stop your program so be careful with

00:25:39,380 --> 00:25:49,640
them and to really don't use it if you

00:25:42,140 --> 00:25:51,740
don't really need it okay classes there

00:25:49,640 --> 00:25:55,100
are lots of interesting attributes on

00:25:51,740 --> 00:26:01,250
the classes I will briefly cover those

00:25:55,100 --> 00:26:05,140
dolls and metaclass it's kind of a scary

00:26:01,250 --> 00:26:07,850
thing in Python but it's really simple

00:26:05,140 --> 00:26:13,790
the scariest things are how you can use

00:26:07,850 --> 00:26:18,200
it and when you define a class in Python

00:26:13,790 --> 00:26:25,340
when you type this class statement what

00:26:18,200 --> 00:26:30,890
happens actually is this code so I tone

00:26:25,340 --> 00:26:35,350
calls the type met type building with

00:26:30,890 --> 00:26:37,460
with the name of your class the list of

00:26:35,350 --> 00:26:41,540
subclasses that is you were super

00:26:37,460 --> 00:26:45,020
classic that in inherits basis and the

00:26:41,540 --> 00:26:47,900
dict of objects that you actually put in

00:26:45,020 --> 00:26:53,210
the class definition if you have been to

00:26:47,900 --> 00:26:56,510
the SQL alchemy talk two days ago it was

00:26:53,210 --> 00:27:01,370
actually explained in the guy showed how

00:26:56,510 --> 00:27:03,140
SQL alchemy uses that internally and he

00:27:01,370 --> 00:27:06,309
shows that actually it doesn't have to

00:27:03,140 --> 00:27:09,770
be type it's the type of the object I

00:27:06,309 --> 00:27:14,150
mean it's typed because object is of the

00:27:09,770 --> 00:27:15,360
type type so it actually calls the class

00:27:14,150 --> 00:27:20,520
of the

00:27:15,360 --> 00:27:20,520
superclass that's that it's complicated

00:27:20,550 --> 00:27:27,550
okay so you can use that for example to

00:27:24,640 --> 00:27:29,800
have this is a horrible example but it's

00:27:27,550 --> 00:27:32,590
simple at least please don't do that in

00:27:29,800 --> 00:27:37,110
miracle you can have a class that

00:27:32,590 --> 00:27:42,220
produces you dicks you can use the class

00:27:37,110 --> 00:27:45,870
syntax to have a dick and how you do it

00:27:42,220 --> 00:27:50,470
it's just you make this function that

00:27:45,870 --> 00:27:52,960
takes the name takes the bases and take

00:27:50,470 --> 00:27:56,050
the dictionary ignores everything that

00:27:52,960 --> 00:27:59,200
it took just delay deletes the metaclass

00:27:56,050 --> 00:28:03,040
attribute because that's how you pass it

00:27:59,200 --> 00:28:07,600
to your class oh you don't want it there

00:28:03,040 --> 00:28:10,360
and returns the dick and that's actually

00:28:07,600 --> 00:28:16,740
instead of class this will produce you

00:28:10,360 --> 00:28:21,490
addict this is a very powerful thing you

00:28:16,740 --> 00:28:27,370
can you can customize everything in your

00:28:21,490 --> 00:28:30,250
class using that and i actually prefer

00:28:27,370 --> 00:28:33,010
to use cloth decorators when I can

00:28:30,250 --> 00:28:36,160
because they are kind of easier to

00:28:33,010 --> 00:28:38,320
understand easier to explain but you can

00:28:36,160 --> 00:28:40,750
do what you would do in a class the

00:28:38,320 --> 00:28:42,520
greater the thing that you cannot do it

00:28:40,750 --> 00:28:45,070
class decorator is to do something

00:28:42,520 --> 00:28:47,260
before you create the car so for example

00:28:45,070 --> 00:28:50,470
you couldn't do this with class

00:28:47,260 --> 00:28:52,570
decorator right actually you do you

00:28:50,470 --> 00:28:55,360
could because you would return the dicta

00:28:52,570 --> 00:28:57,610
of the club but the class would still be

00:28:55,360 --> 00:29:04,180
created at some point so you throw that

00:28:57,610 --> 00:29:07,150
away and in Python 3 the syntax format

00:29:04,180 --> 00:29:11,400
actress is completely different and you

00:29:07,150 --> 00:29:11,400
can also have a

00:29:12,550 --> 00:29:18,330
tells you what should be that because in

00:29:15,010 --> 00:29:21,130
Python to this D is always addicted and

00:29:18,330 --> 00:29:23,860
in Python 3 you can make it an order

00:29:21,130 --> 00:29:27,850
addicts from them that could be useful

00:29:23,860 --> 00:29:29,350
or or whatever you want so you have this

00:29:27,850 --> 00:29:33,150
prepare method that actually creates

00:29:29,350 --> 00:29:39,580
this before it's it gets populated

00:29:33,150 --> 00:29:43,840
that's also pretty cool okay another

00:29:39,580 --> 00:29:47,230
thing you can you have a control over

00:29:43,840 --> 00:29:49,720
how is influenced works because it's

00:29:47,230 --> 00:29:52,690
instance will check for this instance

00:29:49,720 --> 00:29:54,880
click method and if it's there on the

00:29:52,690 --> 00:29:57,010
class it will use that instead of

00:29:54,880 --> 00:30:02,440
checking if it's actually the instance

00:29:57,010 --> 00:30:05,170
of the class you are looking for and the

00:30:02,440 --> 00:30:07,450
same thing is for its subclass you can

00:30:05,170 --> 00:30:10,630
also control surplus and that's actually

00:30:07,450 --> 00:30:13,420
how a PC are implemented in vitam they

00:30:10,630 --> 00:30:14,860
are implemented practically in in pure

00:30:13,420 --> 00:30:17,560
python there is no magic in there

00:30:14,860 --> 00:30:22,960
actually well there are a lot of magical

00:30:17,560 --> 00:30:26,260
attributes in there but ok operator this

00:30:22,960 --> 00:30:29,410
is just a quick view to get definitely

00:30:26,260 --> 00:30:33,090
look into the documentation you can

00:30:29,410 --> 00:30:39,070
overwrite them to change how the object

00:30:33,090 --> 00:30:43,920
handles that operator and for example

00:30:39,070 --> 00:30:48,400
you can use it to make this kind of

00:30:43,920 --> 00:30:52,720
operation record their object that's how

00:30:48,400 --> 00:30:55,960
I school alchemy does it's doubt the

00:30:52,720 --> 00:30:57,730
filter method because you can to the

00:30:55,960 --> 00:31:02,410
filter method you can pass expressions

00:30:57,730 --> 00:31:04,860
that involves the field object and the

00:31:02,410 --> 00:31:08,920
field objects has code like this

00:31:04,860 --> 00:31:11,860
actually inside that records what

00:31:08,920 --> 00:31:14,800
operations you are calling on it and it

00:31:11,860 --> 00:31:18,580
always returns itself well itself it

00:31:14,800 --> 00:31:23,260
wraps itself in an object that

00:31:18,580 --> 00:31:25,080
represents those operations so the

00:31:23,260 --> 00:31:28,380
result of this code

00:31:25,080 --> 00:31:30,930
you can create an A and B and then do

00:31:28,380 --> 00:31:34,380
some operations on it and if you print

00:31:30,930 --> 00:31:38,340
them you can see that I also a very

00:31:34,380 --> 00:31:41,730
overridden the rep to actually go

00:31:38,340 --> 00:31:44,730
through recursively to to all those

00:31:41,730 --> 00:31:48,090
wrappers and print them in a in a nice

00:31:44,730 --> 00:31:50,820
one so if you need ever need to create

00:31:48,090 --> 00:31:53,550
your own domain specific language that

00:31:50,820 --> 00:31:58,610
has any any calculations in it you can

00:31:53,550 --> 00:32:06,840
use that that sounds pretty neat trick

00:31:58,610 --> 00:32:10,890
comparisons okay one thing is hush for

00:32:06,840 --> 00:32:15,090
an object to be if you want to use an

00:32:10,890 --> 00:32:17,550
object as a key in addict or other or as

00:32:15,090 --> 00:32:21,200
a member of a set it has to need this

00:32:17,550 --> 00:32:26,270
hash because it tells it how to how to

00:32:21,200 --> 00:32:26,270
wait to put it in the dick basically and

00:32:26,450 --> 00:32:35,040
the only well it's it has to be an int

00:32:31,110 --> 00:32:37,980
and if the objects are equal the hashes

00:32:35,040 --> 00:32:41,550
has to be have to be equal that's the

00:32:37,980 --> 00:32:51,410
only thing that you need to do with this

00:32:41,550 --> 00:32:51,410
hash and actually when they are equal

00:32:55,410 --> 00:33:02,550
to be okay i will check that later and

00:32:59,940 --> 00:33:11,040
maybe I meant them the slides will be

00:33:02,550 --> 00:33:14,270
available so probably okay I have to

00:33:11,040 --> 00:33:18,660
click that in the code because that's

00:33:14,270 --> 00:33:20,460
okay and the default cash method all the

00:33:18,660 --> 00:33:23,550
objects that you create have the default

00:33:20,460 --> 00:33:28,530
cash method and it's the ID itself so

00:33:23,550 --> 00:33:31,950
different objects different instances we

00:33:28,530 --> 00:33:36,230
know that's why it's not is the default

00:33:31,950 --> 00:33:39,090
is like that but you can have to object

00:33:36,230 --> 00:33:45,480
hashing to the same value if you

00:33:39,090 --> 00:33:49,230
consider them equal in your logic okay

00:33:45,480 --> 00:33:55,440
and I won't go into details about this

00:33:49,230 --> 00:33:59,190
comparison metric methods it's just 11

00:33:55,440 --> 00:34:03,500
nice decorator in the functions module

00:33:59,190 --> 00:34:06,920
if you just define equals and later than

00:34:03,500 --> 00:34:10,040
this decorator will define all the rest

00:34:06,920 --> 00:34:13,470
for you using the total ordering

00:34:10,040 --> 00:34:16,530
mathematical principles whatever it will

00:34:13,470 --> 00:34:20,610
work as you expect normal objects to us

00:34:16,530 --> 00:34:25,490
as numbers work so that's also a neat

00:34:20,610 --> 00:34:25,490
trick so thank you and

00:34:31,850 --> 00:34:43,590
and no questions thank you for the talk

00:34:40,620 --> 00:34:46,530
so one thing which I noticed many times

00:34:43,590 --> 00:34:49,440
by mistake is that not equal they

00:34:46,530 --> 00:34:53,190
understand the not net neck is now

00:34:49,440 --> 00:34:54,929
defined by default as not yech so that

00:34:53,190 --> 00:34:56,370
happened to me very often to say what

00:34:54,929 --> 00:34:59,550
why it's not working I'm working and

00:34:56,370 --> 00:35:02,120
then you know the reason why it was none

00:34:59,550 --> 00:35:05,130
of this well because it's not

00:35:02,120 --> 00:35:08,580
necessarily that in depending on your

00:35:05,130 --> 00:35:12,000
object for example the non objects it's

00:35:08,580 --> 00:35:15,690
never equal and it's never not equal to

00:35:12,000 --> 00:35:19,200
anything yeah it also always returns

00:35:15,690 --> 00:35:23,190
false perform equal and for non equal so

00:35:19,200 --> 00:35:25,320
if the phone numbers we have some

00:35:23,190 --> 00:35:28,230
intuition that not equals and equals

00:35:25,320 --> 00:35:30,980
should be negations of itself but for

00:35:28,230 --> 00:35:33,950
different objects it's not necessary to

00:35:30,980 --> 00:35:37,950
so that that's why you have this

00:35:33,950 --> 00:35:43,100
decorator to define all the stuff you

00:35:37,950 --> 00:35:43,100
need and that just worked ok thanks out

00:35:44,660 --> 00:36:05,460
no questions ok oh sorry also look it up

00:36:01,200 --> 00:36:07,980
on closures they work differently in

00:36:05,460 --> 00:36:11,570
some pythons than other because you

00:36:07,980 --> 00:36:16,050
cannot assign to stuff in your closure

00:36:11,570 --> 00:36:19,110
like I I think so i might be confused no

00:36:16,050 --> 00:36:21,330
i think you can always assign to stuff

00:36:19,110 --> 00:36:25,800
in you because because those are just

00:36:21,330 --> 00:36:28,620
fire was pulled from the upper scope so

00:36:25,800 --> 00:36:31,530
there are normal variables I don't know

00:36:28,620 --> 00:36:33,480
if I can use a list like an example that

00:36:31,530 --> 00:36:35,610
would work with mutable objects but I

00:36:33,480 --> 00:36:38,480
think there were some restrictions so i

00:36:35,610 --> 00:36:44,599
but i might be right

00:36:38,480 --> 00:36:47,579
because they are if you just do a

00:36:44,599 --> 00:36:49,890
parable equals something it will create

00:36:47,579 --> 00:36:52,829
a local variable that will shuttle the

00:36:49,890 --> 00:36:56,329
one from the outer scope right and in

00:36:52,829 --> 00:36:59,339
Python 2 there is no way to import

00:36:56,329 --> 00:37:02,940
variable that is not global and not

00:36:59,339 --> 00:37:05,790
local in to your scope to your scope in

00:37:02,940 --> 00:37:07,740
Python 3 there is a non-local keywords

00:37:05,790 --> 00:37:10,859
for that and they fixed it you can

00:37:07,740 --> 00:37:16,980
actually do that and in Python to you

00:37:10,859 --> 00:37:20,910
are right you cannot do that Thank You

00:37:16,980 --> 00:37:26,010
radomir do you or anyone has valid

00:37:20,910 --> 00:37:29,400
reason to use dunno dil Dil bundle yeah

00:37:26,010 --> 00:37:31,980
no I don't know of anyone who actually

00:37:29,400 --> 00:37:34,980
needs that I know that it's needed on

00:37:31,980 --> 00:37:39,530
things like file when you want to close

00:37:34,980 --> 00:37:45,210
the file when you are done with it but

00:37:39,530 --> 00:37:49,290
really you can easily get around without

00:37:45,210 --> 00:37:52,530
that and use the we graph model has some

00:37:49,290 --> 00:37:55,380
tools that let you do tricks without

00:37:52,530 --> 00:37:59,690
having to use bell and still have some

00:37:55,380 --> 00:37:59,690
finalization for your for you object

00:37:59,780 --> 00:38:08,369
yeah context managers and things like

00:38:02,700 --> 00:38:14,220
that and that is really really it's a

00:38:08,369 --> 00:38:17,369
hack and it's it hurts sometimes in

00:38:14,220 --> 00:38:20,099
strange ways if you would so so really

00:38:17,369 --> 00:38:22,740
you shouldn't use it lightly and I don't

00:38:20,099 --> 00:38:25,410
know of anybody who actually needs it so

00:38:22,740 --> 00:38:27,030
it's needed inside the Python itself and

00:38:25,410 --> 00:38:29,700
since it was there they made it

00:38:27,030 --> 00:38:33,319
available because that's the fields of

00:38:29,700 --> 00:38:35,970
your Python to and for the users but

00:38:33,319 --> 00:38:38,359
usually it's easy to shoot yourself in a

00:38:35,970 --> 00:38:38,359
food

00:38:39,119 --> 00:38:52,839
yes we hate them okay you've got one

00:38:46,619 --> 00:38:55,380
quick question no okay thank you very

00:38:52,839 --> 00:38:55,380

YouTube URL: https://www.youtube.com/watch?v=rj4mf5aNhh0


