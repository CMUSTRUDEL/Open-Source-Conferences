Title: Christophe Pettus - Extending Python into PostgreSQL
Publication date: 2015-04-18
Playlist: EuroPython 2013
Description: 
	[EuroPython 2013] 
Christophe Pettus - Extending Python into PostgreSQL - 05 July 2013 "Track Lasagne"
Captions: 
	00:00:03,620 --> 00:00:11,030
okay so i hope you enjoyed your coffee

00:00:07,670 --> 00:00:16,910
now we are here with Christophe Pettis

00:00:11,030 --> 00:00:20,340
here and we'll see how to embed the

00:00:16,910 --> 00:00:27,210
Python into postgresql thank you crystal

00:00:20,340 --> 00:00:29,250
hello so we're going to talk about

00:00:27,210 --> 00:00:31,109
postcodes Python and squid this is not

00:00:29,250 --> 00:00:33,180
the reverse proxy cache this is the

00:00:31,109 --> 00:00:36,300
cephalopod we're talking about here see

00:00:33,180 --> 00:00:37,950
squid as i mentioned i'm american which

00:00:36,300 --> 00:00:40,020
means i speak very loud and very quickly

00:00:37,950 --> 00:00:42,870
so please wave if I start becoming

00:00:40,020 --> 00:00:46,190
completely incomprehensible so let's

00:00:42,870 --> 00:00:49,739
talk about squid so what is a squid

00:00:46,190 --> 00:00:51,780
conceptually what is a squid so for the

00:00:49,739 --> 00:00:54,239
purposes of this talk a squid has three

00:00:51,780 --> 00:00:56,550
attributes as a linkedin centimeters a

00:00:54,239 --> 00:00:58,140
number of tentacles and awaiting

00:00:56,550 --> 00:01:01,020
kilograms those are the defining

00:00:58,140 --> 00:01:03,329
characteristics of a squid and of course

00:01:01,020 --> 00:01:04,650
we're using postgres because you know i

00:01:03,329 --> 00:01:07,200
work for a company called postgresql

00:01:04,650 --> 00:01:10,320
expert so da and we're using Python

00:01:07,200 --> 00:01:13,110
because well I like I'm going to talk

00:01:10,320 --> 00:01:14,700
about Ruby here and we're using psycho

00:01:13,110 --> 00:01:16,320
PG too because there's really no other

00:01:14,700 --> 00:01:19,799
intelligent way right now to talk to

00:01:16,320 --> 00:01:21,299
postgres from Python so we all do

00:01:19,799 --> 00:01:23,610
something like this we create a squid

00:01:21,299 --> 00:01:25,320
object with you know it's an initializer

00:01:23,610 --> 00:01:27,150
and you know we set this and then we

00:01:25,320 --> 00:01:28,409
return a string and you know there's

00:01:27,150 --> 00:01:29,369
probably a rapper and you know a bunch

00:01:28,409 --> 00:01:31,939
of other stuff here that we're not

00:01:29,369 --> 00:01:35,040
showing and that we instantiate a squid

00:01:31,939 --> 00:01:36,630
and then in Postgres we do something

00:01:35,040 --> 00:01:38,430
like this you know the squid has a key

00:01:36,630 --> 00:01:40,110
you know let's do a big cereal primary

00:01:38,430 --> 00:01:42,840
key because you know we're all used to

00:01:40,110 --> 00:01:44,909
django and that's why you do it um and

00:01:42,840 --> 00:01:46,229
lengthened all of this stuff these

00:01:44,909 --> 00:01:47,729
probably should be decimals instead of

00:01:46,229 --> 00:01:51,180
floats unless we want really big and

00:01:47,729 --> 00:01:52,470
really small squids but whatever and you

00:01:51,180 --> 00:01:55,049
know we want to make sure that we have

00:01:52,470 --> 00:01:58,399
like sensible squids you know not alien

00:01:55,049 --> 00:02:02,280
exotic squids here okay that's good and

00:01:58,399 --> 00:02:06,170
then we do an insert a squid in to the

00:02:02,280 --> 00:02:09,000
table okay and you know commit it and

00:02:06,170 --> 00:02:12,850
then we select then we get the squid

00:02:09,000 --> 00:02:15,040
back out and then we instantiate up

00:02:12,850 --> 00:02:17,410
out of the weave San see a new object I

00:02:15,040 --> 00:02:19,870
was a row we got see squids and post

00:02:17,410 --> 00:02:26,260
Chris and we're done okay that was a

00:02:19,870 --> 00:02:28,030
short presentation but then someone

00:02:26,260 --> 00:02:29,650
comes along and says now we have we want

00:02:28,030 --> 00:02:31,990
two different tables and they both have

00:02:29,650 --> 00:02:33,430
to have squid in them and it's a oh why

00:02:31,990 --> 00:02:35,290
didn't you tell me that before we did

00:02:33,430 --> 00:02:37,060
the first push that's ok we just

00:02:35,290 --> 00:02:38,170
replicate the schema actually post chris

00:02:37,060 --> 00:02:39,850
has this neat little feature where you

00:02:38,170 --> 00:02:41,770
can like replica you could create a

00:02:39,850 --> 00:02:43,840
Atlantic squid in Pacific squid and just

00:02:41,770 --> 00:02:45,790
say I want one just like the one I'll

00:02:43,840 --> 00:02:47,770
have what he's having you know it's

00:02:45,790 --> 00:02:49,570
which included by including all you pick

00:02:47,770 --> 00:02:52,960
up the constraint also so that's kind of

00:02:49,570 --> 00:02:55,180
neat and we write something like this

00:02:52,960 --> 00:02:58,750
and then now at this point we should be

00:02:55,180 --> 00:03:00,820
thinking wait a second like having to do

00:02:58,750 --> 00:03:02,410
these string concatenation to build the

00:03:00,820 --> 00:03:04,530
table name and that's always a sign that

00:03:02,410 --> 00:03:07,690
maybe you're going down the wrong path

00:03:04,530 --> 00:03:08,920
in a you do it sometimes you know if

00:03:07,690 --> 00:03:11,130
you're writing schema manipulation

00:03:08,920 --> 00:03:13,690
functions that kind of thing but since

00:03:11,130 --> 00:03:16,030
sensibly enough we can't do print we

00:03:13,690 --> 00:03:19,390
can't do string substitution in there to

00:03:16,030 --> 00:03:20,830
do um we can't pass in it as a parameter

00:03:19,390 --> 00:03:23,640
to the execute call we have to actually

00:03:20,830 --> 00:03:25,870
bunch the string and then in thinking

00:03:23,640 --> 00:03:28,510
you know this point we're thinking wait

00:03:25,870 --> 00:03:30,370
doesn't postgresql have types it says so

00:03:28,510 --> 00:03:33,370
right on like the front page of the site

00:03:30,370 --> 00:03:35,710
and maybe we can use the custom type

00:03:33,370 --> 00:03:37,900
facility

00:03:35,710 --> 00:03:39,400
but then you think okay but you know

00:03:37,900 --> 00:03:43,060
this is what things like post Chiss

00:03:39,400 --> 00:03:44,890
define types um you know and then you

00:03:43,060 --> 00:03:46,600
probably have to write C and PL pgsql

00:03:44,890 --> 00:03:48,600
and ready to probably scheme in Erlang

00:03:46,600 --> 00:03:51,490
or something to get this stuff to work

00:03:48,600 --> 00:03:53,710
and you install a vm you know it's going

00:03:51,490 --> 00:03:55,300
to be too horrible and then it says well

00:03:53,710 --> 00:03:56,680
that's great but we want operators and

00:03:55,300 --> 00:03:58,300
we want indexing learn all that good

00:03:56,680 --> 00:04:00,790
stuff that comes with real types and

00:03:58,300 --> 00:04:02,710
just okay you just don't do this you

00:04:00,790 --> 00:04:04,630
know python people I'm sorry you're just

00:04:02,710 --> 00:04:06,040
not allowed to do any of this stuff but

00:04:04,630 --> 00:04:07,690
you would be wrong I want to get the

00:04:06,040 --> 00:04:09,130
slide from from one of the original Star

00:04:07,690 --> 00:04:11,110
Trek they where Kirk spins around says

00:04:09,130 --> 00:04:14,050
you're wrong I just think it's great

00:04:11,110 --> 00:04:17,170
here it's actually really easy to create

00:04:14,050 --> 00:04:18,400
custom types in Postgres and you can

00:04:17,170 --> 00:04:20,380
write custom post chris types of your

00:04:18,400 --> 00:04:22,540
application without too much nasty code

00:04:20,380 --> 00:04:25,810
a little bit of nasty code but not too

00:04:22,540 --> 00:04:27,580
much nasty code and you can write

00:04:25,810 --> 00:04:29,830
functions that run inside a postgres in

00:04:27,580 --> 00:04:34,570
Python you actually have two different

00:04:29,830 --> 00:04:36,580
ways of doing so post chris has a really

00:04:34,570 --> 00:04:38,770
extensible type system the reason we

00:04:36,580 --> 00:04:40,270
have things like post Chiss is because

00:04:38,770 --> 00:04:42,400
it's able to extend the typing system

00:04:40,270 --> 00:04:43,660
this is the reason that we get that post

00:04:42,400 --> 00:04:46,690
chris gets post just in other databases

00:04:43,660 --> 00:04:49,960
kind of don't you can create your own

00:04:46,690 --> 00:04:51,580
types and you can create ha they're kind

00:04:49,960 --> 00:04:53,440
of two flavors there are high level

00:04:51,580 --> 00:04:54,970
aggregate types which are structures of

00:04:53,440 --> 00:04:57,220
existing types that are already defined

00:04:54,970 --> 00:04:58,720
in Postgres or you can define low

00:04:57,220 --> 00:05:00,520
language sea level types that have their

00:04:58,720 --> 00:05:03,160
own bit patterns that are completely

00:05:00,520 --> 00:05:05,020
other other completely isolated from the

00:05:03,160 --> 00:05:07,500
rest of postgres we're not going to talk

00:05:05,020 --> 00:05:07,500
about those today

00:05:08,180 --> 00:05:12,350
well now something that's kind of

00:05:10,160 --> 00:05:13,759
interesting about post-crisis anytime

00:05:12,350 --> 00:05:16,789
you declare a table you're really

00:05:13,759 --> 00:05:18,350
declaring a type you're declaring a row

00:05:16,789 --> 00:05:20,090
type that says I'm declaring a new type

00:05:18,350 --> 00:05:21,620
that has these fields in it and oh by

00:05:20,090 --> 00:05:24,470
the way I'd like a table made out of

00:05:21,620 --> 00:05:25,970
that type too please um you generally

00:05:24,470 --> 00:05:27,620
don't need to know this it's hidden

00:05:25,970 --> 00:05:28,940
under the covers but if you've ever

00:05:27,620 --> 00:05:32,780
written how many people have any

00:05:28,940 --> 00:05:34,940
experience with PL pgsql not bad okay

00:05:32,780 --> 00:05:37,430
yeah and you pass around like record

00:05:34,940 --> 00:05:39,350
types and you know row type percent in

00:05:37,430 --> 00:05:42,590
that delightful syntax that everyone

00:05:39,350 --> 00:05:43,669
loves wrote i % type name that's what

00:05:42,590 --> 00:05:46,810
you're doing you say I want one just

00:05:43,669 --> 00:05:49,099
like that one which is pretty neat um

00:05:46,810 --> 00:05:51,789
but you can declare a type without

00:05:49,099 --> 00:05:55,250
having to create a table of it like this

00:05:51,789 --> 00:05:56,660
pink we say we want to squid and what's

00:05:55,250 --> 00:05:59,000
going to have a and it looks just like a

00:05:56,660 --> 00:06:02,240
road at a table declaration only no

00:05:59,000 --> 00:06:05,210
table appears it's just a type and

00:06:02,240 --> 00:06:08,300
that's great but okay how do we get this

00:06:05,210 --> 00:06:10,849
in and out of Python psycho PG 2 has

00:06:08,300 --> 00:06:12,970
pretty it has perfectly good facilities

00:06:10,849 --> 00:06:15,139
for going both directions in and out and

00:06:12,970 --> 00:06:16,639
the good part about it is once you set

00:06:15,139 --> 00:06:17,990
it up it just works there's a little bit

00:06:16,639 --> 00:06:20,750
of grungy code you have to write you

00:06:17,990 --> 00:06:24,229
know because that's life but once you

00:06:20,750 --> 00:06:25,610
set it up it works really well so we

00:06:24,229 --> 00:06:28,880
take our squid class and we add this

00:06:25,610 --> 00:06:31,610
conform method double underscore conform

00:06:28,880 --> 00:06:33,169
and you just sort of copy and paste this

00:06:31,610 --> 00:06:34,610
and you say the protocol is this then

00:06:33,169 --> 00:06:39,500
you return itself and then you have get

00:06:34,610 --> 00:06:43,039
quoted and what the heck is with that so

00:06:39,500 --> 00:06:46,580
there's the cycle bg2 defines the I SQL

00:06:43,039 --> 00:06:49,340
quote protocol you implement two

00:06:46,580 --> 00:06:53,060
functions a double underscore conform

00:06:49,340 --> 00:06:55,070
and get quoted it's a little bit

00:06:53,060 --> 00:06:56,690
indirect it's one of these it returns a

00:06:55,070 --> 00:06:58,550
thing that calls a thing that returns a

00:06:56,690 --> 00:07:00,889
thing the thing that Python programmers

00:06:58,550 --> 00:07:04,159
including myself kind of get crazy about

00:07:00,889 --> 00:07:06,770
this stuff so conform returns an object

00:07:04,159 --> 00:07:08,900
that implements get quoted it doesn't

00:07:06,770 --> 00:07:10,820
actually conform the object itself it

00:07:08,900 --> 00:07:13,250
returns an object which is then called

00:07:10,820 --> 00:07:14,750
to do the work of the quoted work the

00:07:13,250 --> 00:07:17,120
good part is if you implement get quoted

00:07:14,750 --> 00:07:20,389
in your method your object you just

00:07:17,120 --> 00:07:21,710
return self and you're done and get

00:07:20,389 --> 00:07:23,750
quoted returns the the

00:07:21,710 --> 00:07:28,520
out to convert it into sequel quoted

00:07:23,750 --> 00:07:31,640
format which is what it's usually just a

00:07:28,520 --> 00:07:33,830
strength if you have internal quotes

00:07:31,640 --> 00:07:35,210
inside that object like you're returning

00:07:33,830 --> 00:07:37,130
strings that could have internal quotes

00:07:35,210 --> 00:07:40,310
you need to follow the sequel coding

00:07:37,130 --> 00:07:42,350
conventions not pythons so that can be a

00:07:40,310 --> 00:07:44,360
little bit complicated there are lots of

00:07:42,350 --> 00:07:46,310
supporting stuff encyclopedia however to

00:07:44,360 --> 00:07:48,380
handle this for you so don't panic you

00:07:46,310 --> 00:07:49,640
can always just keep calling is quoted

00:07:48,380 --> 00:07:53,990
on string objects and things like that

00:07:49,640 --> 00:07:55,610
until you get everything done the to

00:07:53,990 --> 00:07:57,890
communicate with postgres custom types

00:07:55,610 --> 00:07:59,930
are serialized into strings we send the

00:07:57,890 --> 00:08:00,950
same representation to put to the

00:07:59,930 --> 00:08:04,820
database we get the string

00:08:00,950 --> 00:08:06,680
representation back generally if all

00:08:04,820 --> 00:08:08,780
else fails in Postgres you cast things

00:08:06,680 --> 00:08:11,120
to and from strings that's sort of the

00:08:08,780 --> 00:08:12,800
basic most easy is the easiest way of

00:08:11,120 --> 00:08:16,520
getting stuff in and out of Postgres

00:08:12,800 --> 00:08:20,960
database um aggregate types are enclosed

00:08:16,520 --> 00:08:22,340
in parentheses the right quoting

00:08:20,960 --> 00:08:25,460
conventions on the stuff inside the

00:08:22,340 --> 00:08:27,230
commas between the commas now squids are

00:08:25,460 --> 00:08:29,360
easy because we have where we just have

00:08:27,230 --> 00:08:31,070
three numbers so we just use the string

00:08:29,360 --> 00:08:32,510
representation since there aren't any

00:08:31,070 --> 00:08:36,230
fields that could contain quotes in that

00:08:32,510 --> 00:08:39,380
so we're not going to make that simpler

00:08:36,230 --> 00:08:40,940
example if there were strings you could

00:08:39,380 --> 00:08:42,380
just call it call the appropriate get

00:08:40,940 --> 00:08:43,850
quoted method on these and keep going

00:08:42,380 --> 00:08:45,590
until you've got everything quoted up

00:08:43,850 --> 00:08:47,330
the way you want sequel Cody conventions

00:08:45,590 --> 00:08:50,090
are horrible by the way they are real

00:08:47,330 --> 00:08:52,520
it's really really unfortunate but you

00:08:50,090 --> 00:08:56,960
know state of the art 1975 level

00:08:52,520 --> 00:08:58,760
technology um then we wrap the whole

00:08:56,960 --> 00:09:00,440
thing in sequel string quotes and add a

00:08:58,760 --> 00:09:03,950
cast to it the cast isn't actually

00:09:00,440 --> 00:09:07,910
required but I like to but it makes for

00:09:03,950 --> 00:09:09,710
a better example this way well that's

00:09:07,910 --> 00:09:11,300
great because we wrote the squid class

00:09:09,710 --> 00:09:13,840
but what if you're doing this with other

00:09:11,300 --> 00:09:16,070
with classes that you didn't write

00:09:13,840 --> 00:09:17,870
what's cool about this is that you can

00:09:16,070 --> 00:09:19,400
actually register these adaptor classes

00:09:17,870 --> 00:09:21,350
for things that you don't have access to

00:09:19,400 --> 00:09:22,730
the source code on well it's you know

00:09:21,350 --> 00:09:24,500
python so you kind of always have access

00:09:22,730 --> 00:09:25,940
to sort code but you that you don't

00:09:24,500 --> 00:09:29,540
really have Liberty to modify for

00:09:25,940 --> 00:09:30,800
whatever reason the adapter function

00:09:29,540 --> 00:09:33,200
takes that object and returns an object

00:09:30,800 --> 00:09:34,580
that implements get quoted so you can

00:09:33,200 --> 00:09:35,480
write adapter objects that say here's

00:09:34,580 --> 00:09:37,190
how I'm going to quote

00:09:35,480 --> 00:09:38,990
this object and send it to and from the

00:09:37,190 --> 00:09:40,850
database so that's nice if you need to

00:09:38,990 --> 00:09:45,320
write a wrap-up code that you didn't

00:09:40,850 --> 00:09:47,570
actually write there's also an as-is

00:09:45,320 --> 00:09:50,600
method that says basically if the

00:09:47,570 --> 00:09:53,300
hipster or unicode on this is fine just

00:09:50,600 --> 00:09:54,529
return in which is easy for ninety

00:09:53,300 --> 00:09:59,209
percent of objects that don't have

00:09:54,529 --> 00:10:01,399
really fancy internal structure so ok

00:09:59,209 --> 00:10:07,670
now we create a table like this we just

00:10:01,399 --> 00:10:09,350
say it's a squid cool and then instead

00:10:07,670 --> 00:10:11,750
of having to break out the fields and

00:10:09,350 --> 00:10:12,589
all that stuff we just say notice also

00:10:11,750 --> 00:10:15,019
there's a little bit better

00:10:12,589 --> 00:10:17,589
encapsulation here because we haven't

00:10:15,019 --> 00:10:22,790
had to explicitly tease the object apart

00:10:17,589 --> 00:10:24,320
that's kind of nice oops and then when

00:10:22,790 --> 00:10:25,610
we insert it we just insert the squid

00:10:24,320 --> 00:10:27,260
object we don't have to break it apart

00:10:25,610 --> 00:10:30,040
into fields and enumerate the fields

00:10:27,260 --> 00:10:30,040
there and do all that stuff

00:10:30,410 --> 00:10:34,160
but okay we got to squid in now how do

00:10:32,360 --> 00:10:37,100
we get the squid out so you need to

00:10:34,160 --> 00:10:38,060
write a cast function it this this goes

00:10:37,100 --> 00:10:39,800
the other way takes a string

00:10:38,060 --> 00:10:41,149
representation and returns the object

00:10:39,800 --> 00:10:42,829
and then we were to register that

00:10:41,149 --> 00:10:44,569
function with psycho pg2 to say anytime

00:10:42,829 --> 00:10:47,959
you get a squid out here's how you deal

00:10:44,569 --> 00:10:49,879
with it the problem you know the old

00:10:47,959 --> 00:10:50,990
joke is you you have a problem and you

00:10:49,879 --> 00:10:52,310
think i know i'll use regular

00:10:50,990 --> 00:10:55,490
expressions and now you have two

00:10:52,310 --> 00:10:57,470
problems you end up writing rig exes a

00:10:55,490 --> 00:10:59,259
lot doing this stuff because you get

00:10:57,470 --> 00:11:05,720
these strings out you need to parse them

00:10:59,259 --> 00:11:08,509
so for example here's a interest here's

00:11:05,720 --> 00:11:13,550
a not particularly superleague clever

00:11:08,509 --> 00:11:16,519
regex that parses out the the fields of

00:11:13,550 --> 00:11:19,029
the squid so you can do to do thank God

00:11:16,519 --> 00:11:21,860
for these thank God for named groups um

00:11:19,029 --> 00:11:24,889
I hate those dollar sign one thing um

00:11:21,860 --> 00:11:27,230
and then you know you do some casting

00:11:24,889 --> 00:11:28,759
and then you return the squid I mean it

00:11:27,230 --> 00:11:30,170
is a pretty nasty function and it does

00:11:28,759 --> 00:11:32,449
have but the good part is it's also

00:11:30,170 --> 00:11:33,980
encapsulated inside the object so it's

00:11:32,449 --> 00:11:35,779
not like every single client of this

00:11:33,980 --> 00:11:41,060
thing has to write this thing which is

00:11:35,779 --> 00:11:43,759
nicer and then you register it you say

00:11:41,060 --> 00:11:45,110
okay what will just pass the 7,000 7200

00:11:43,759 --> 00:11:47,569
I mean you know what else will we pass

00:11:45,110 --> 00:11:50,959
in there and a squid in a cast and all

00:11:47,569 --> 00:11:58,310
that stuff and we're done okay sorry

00:11:50,959 --> 00:11:59,959
what's 77 2007 what is with that so here

00:11:58,310 --> 00:12:02,480
is a kind of unfortunate thing

00:11:59,959 --> 00:12:05,480
postgresql has these things called away

00:12:02,480 --> 00:12:07,910
its object ideas every type in Postgres

00:12:05,480 --> 00:12:12,050
among them in every row every table used

00:12:07,910 --> 00:12:14,660
to be every row had an object ID um it's

00:12:12,050 --> 00:12:16,279
a 32-bit number and it's the unique

00:12:14,660 --> 00:12:19,309
identifier for that object inside a

00:12:16,279 --> 00:12:21,050
postgres the problem is when you create

00:12:19,309 --> 00:12:25,250
a new type it's dynamically assigned and

00:12:21,050 --> 00:12:27,559
you need to tell the and when psycho pg2

00:12:25,250 --> 00:12:30,319
gets the query back it doesn't isn't

00:12:27,559 --> 00:12:33,589
told squid quote squid it's told here's

00:12:30,319 --> 00:12:35,509
a 72 here's a 70 2007 just deal with it

00:12:33,589 --> 00:12:40,910
you know what that is right blegh blegh

00:12:35,509 --> 00:12:42,230
um so we have to tell it um every

00:12:40,910 --> 00:12:43,740
database schema object has annoyed

00:12:42,230 --> 00:12:46,110
inside a postgres

00:12:43,740 --> 00:12:47,430
the problem is every time you create it

00:12:46,110 --> 00:12:48,870
it's dynamically assigned so it can be

00:12:47,430 --> 00:12:51,030
different from every one day to every

00:12:48,870 --> 00:12:55,230
database and I hate that stuff you know

00:12:51,030 --> 00:12:57,300
not good um and if you dump and restore

00:12:55,230 --> 00:12:59,640
the database it changes or potentially

00:12:57,300 --> 00:13:01,440
could change so that's not so this is

00:12:59,640 --> 00:13:03,200
really this is unfortunate and it's just

00:13:01,440 --> 00:13:05,850
one of those things that you deal with

00:13:03,200 --> 00:13:08,850
you can however extract it from the

00:13:05,850 --> 00:13:13,320
database you do query you know get a

00:13:08,850 --> 00:13:17,430
null squid back and grab the oi doubt of

00:13:13,320 --> 00:13:18,900
it out of the result so the good news is

00:13:17,430 --> 00:13:21,180
then you can cash that because what

00:13:18,900 --> 00:13:22,620
because assuming assuming you're not

00:13:21,180 --> 00:13:24,390
like dynamically recreating the database

00:13:22,620 --> 00:13:25,860
between queries which if you're doing

00:13:24,390 --> 00:13:29,760
that you may want to revisit that

00:13:25,860 --> 00:13:33,270
decision you could you once you got it

00:13:29,760 --> 00:13:35,910
you got it that's good and now select

00:13:33,270 --> 00:13:37,860
just works you select the squid and

00:13:35,910 --> 00:13:41,800
notice I'm printing the class here so

00:13:37,860 --> 00:13:46,360
that you know that I'm not cheating see

00:13:41,800 --> 00:13:48,870
so that's cool okay but wait we had a

00:13:46,360 --> 00:13:51,040
check constraint on the table and

00:13:48,870 --> 00:13:52,450
because we don't want you know mutant

00:13:51,040 --> 00:13:55,510
squids getting into this database you

00:13:52,450 --> 00:13:58,329
know squids with 47 tentacles no forget

00:13:55,510 --> 00:14:00,339
it let me write a trigger that's when

00:13:58,329 --> 00:14:01,779
we've handling it but you know then

00:14:00,339 --> 00:14:03,579
we're started well we don't want to

00:14:01,779 --> 00:14:05,260
write PL pgsql because we're Python

00:14:03,579 --> 00:14:07,450
people and we don't want to deal with

00:14:05,260 --> 00:14:10,089
the whole separate language but we don't

00:14:07,450 --> 00:14:13,630
have to you can write the trigger and PL

00:14:10,089 --> 00:14:15,040
Python um the functions run inside a

00:14:13,630 --> 00:14:19,149
postscript like any other back end

00:14:15,040 --> 00:14:22,570
function in PL pgsql the run like PGP of

00:14:19,149 --> 00:14:26,500
they are parallel to PL pgsql functions

00:14:22,570 --> 00:14:28,269
so great let's do that one thing to note

00:14:26,500 --> 00:14:29,980
is that when you create a database by

00:14:28,269 --> 00:14:31,870
default it won't have PL Python

00:14:29,980 --> 00:14:34,000
installed in it so you have to create

00:14:31,870 --> 00:14:35,640
that language one thing you can do is

00:14:34,000 --> 00:14:38,290
create it in the template one database

00:14:35,640 --> 00:14:41,680
so that any new database you create then

00:14:38,290 --> 00:14:44,589
will automatically pick it up the you by

00:14:41,680 --> 00:14:47,980
the way is not because we're like that

00:14:44,589 --> 00:14:51,490
it's the Romanian version it's um untrue

00:14:47,980 --> 00:14:53,350
it's it means untrusted untrusted

00:14:51,490 --> 00:14:55,120
languages are ones that are the

00:14:53,350 --> 00:14:57,970
postgresql typing system is not

00:14:55,120 --> 00:14:59,950
automatically enforced so you can step

00:14:57,970 --> 00:15:01,570
outside of the postgres typing system

00:14:59,950 --> 00:15:04,209
because you have like direct file system

00:15:01,570 --> 00:15:05,470
access so you can so you could you could

00:15:04,209 --> 00:15:06,790
you know said all these permissions on

00:15:05,470 --> 00:15:09,100
the table and then they'd say well

00:15:06,790 --> 00:15:13,930
that's all very nice and do you know f

00:15:09,100 --> 00:15:16,180
open then there you go all this means in

00:15:13,930 --> 00:15:17,920
practice is the only kind of user that

00:15:16,180 --> 00:15:19,329
can create a function in an untrusted

00:15:17,920 --> 00:15:23,020
language is a super user because they

00:15:19,329 --> 00:15:25,180
can do anything anyway and then you say

00:15:23,020 --> 00:15:26,470
okay I've got a great great Christoph do

00:15:25,180 --> 00:15:29,079
to do to do and it gives you a nasty

00:15:26,470 --> 00:15:32,170
error and said you did it ed said it it

00:15:29,079 --> 00:15:33,790
didn't like that one thing to remember

00:15:32,170 --> 00:15:36,640
is that if you're installing from

00:15:33,790 --> 00:15:40,000
packages make sure you apt-get the dash

00:15:36,640 --> 00:15:41,649
contribs not just the may the base

00:15:40,000 --> 00:15:43,480
because you'll need that for Python and

00:15:41,649 --> 00:15:44,649
if you're building from source remember

00:15:43,480 --> 00:15:47,890
you have to build with you with Python

00:15:44,649 --> 00:15:49,480
option that's the 99 percent of time if

00:15:47,890 --> 00:15:53,170
it won't let you create PL Python you

00:15:49,480 --> 00:15:54,880
that's why so yeah that's great but

00:15:53,170 --> 00:15:56,770
which Python do we get

00:15:54,880 --> 00:15:58,630
you get the system interpreter of

00:15:56,770 --> 00:16:00,970
whichever one you're doing unless you

00:15:58,630 --> 00:16:04,330
point it at a different interpreter when

00:16:00,970 --> 00:16:06,430
you build it you can specifically choose

00:16:04,330 --> 00:16:10,330
PL Python to you or PL Python 3 you

00:16:06,430 --> 00:16:13,930
right now you get Python 2 if you say

00:16:10,330 --> 00:16:16,600
Python Python 3 sometime in the future

00:16:13,930 --> 00:16:19,720
this will change that python3 that

00:16:16,600 --> 00:16:22,300
Python you three get some will get

00:16:19,720 --> 00:16:25,540
Python Python there PL Python you will

00:16:22,300 --> 00:16:27,220
get Python 3 instead of Python 2 there

00:16:25,540 --> 00:16:28,840
are no immediate plans to change to

00:16:27,220 --> 00:16:30,340
cause that to happen however so at the

00:16:28,840 --> 00:16:35,140
moment that's pretty safe to get your

00:16:30,340 --> 00:16:36,550
Python to the the creation syntax is

00:16:35,140 --> 00:16:39,850
same as any other function create a

00:16:36,550 --> 00:16:41,620
replace function with this and then the

00:16:39,850 --> 00:16:45,100
string quotes and bang there's your

00:16:41,620 --> 00:16:47,320
Python there's an automatic module

00:16:45,100 --> 00:16:49,120
defined called PLP why that has a lot of

00:16:47,320 --> 00:16:51,250
the utility functions necessary to talk

00:16:49,120 --> 00:16:56,050
to the database in it for example raise

00:16:51,250 --> 00:16:58,110
notice and look there it goes gives you

00:16:56,050 --> 00:17:04,569
a nice little notice the world truth

00:16:58,110 --> 00:17:07,120
tada okay um there is no function body

00:17:04,569 --> 00:17:09,790
you don't declare it as a function you

00:17:07,120 --> 00:17:12,579
could you it's just the function body so

00:17:09,790 --> 00:17:15,100
there's no def at the top it wraps it

00:17:12,579 --> 00:17:17,140
appeal Python wraps this up for you you

00:17:15,100 --> 00:17:18,730
can call any installed package if the

00:17:17,140 --> 00:17:20,949
interpreter can see it as part of the

00:17:18,730 --> 00:17:24,370
standard Python path you can call it you

00:17:20,949 --> 00:17:26,680
may not want to call it but you can but

00:17:24,370 --> 00:17:28,900
you can't directly call any other stored

00:17:26,680 --> 00:17:30,190
procedure well what would be really nice

00:17:28,900 --> 00:17:31,630
is if you could just type the name of

00:17:30,190 --> 00:17:34,120
another PL Python function and run it

00:17:31,630 --> 00:17:35,860
like any other function but you can't

00:17:34,120 --> 00:17:38,380
because the way post chris balls off

00:17:35,860 --> 00:17:40,660
stored procedures you what's called the

00:17:38,380 --> 00:17:43,780
server programming interface that PLP

00:17:40,660 --> 00:17:47,430
why module you have to like you have to

00:17:43,780 --> 00:17:52,360
write a select that calls it this blows

00:17:47,430 --> 00:17:53,560
unfortunately though this module PLP why

00:17:52,360 --> 00:17:55,420
contains all the stuff that lets you

00:17:53,560 --> 00:17:57,040
call the other the other good news of

00:17:55,420 --> 00:17:58,300
course is that you can call any function

00:17:57,040 --> 00:18:03,640
including ones that are not written in

00:17:58,300 --> 00:18:05,950
PL python using that so um something to

00:18:03,640 --> 00:18:07,960
note before people go crazy with this is

00:18:05,950 --> 00:18:11,770
the post goes back end is single thread

00:18:07,960 --> 00:18:14,890
do not create threads you have a single

00:18:11,770 --> 00:18:18,460
thread of execution if you break it

00:18:14,890 --> 00:18:20,590
there is no warranty on this you you can

00:18:18,460 --> 00:18:22,510
screw it's a one things about being an

00:18:20,590 --> 00:18:24,970
untrusted languages you're running

00:18:22,510 --> 00:18:27,790
inside the actual thread of the back end

00:18:24,970 --> 00:18:29,200
and it's memory space you will you have

00:18:27,790 --> 00:18:30,700
every right in the world and every

00:18:29,200 --> 00:18:32,560
ability in the world to completely screw

00:18:30,700 --> 00:18:34,240
it up and cause database problems so

00:18:32,560 --> 00:18:36,580
don't do that the chance of actually

00:18:34,240 --> 00:18:38,800
causing data corruption is extremely

00:18:36,580 --> 00:18:41,290
small but the chance of causing really

00:18:38,800 --> 00:18:42,820
weird behavior from the clients point of

00:18:41,290 --> 00:18:45,440
view is extremely high if you start

00:18:42,820 --> 00:18:50,779
doing things like threading

00:18:45,440 --> 00:18:52,009
okay so here's a trigger um we grab this

00:18:50,779 --> 00:18:54,679
is just because we want to throw an

00:18:52,009 --> 00:18:58,629
exception we chop our little squid into

00:18:54,679 --> 00:19:02,210
calamari here by this the the TD is a

00:18:58,629 --> 00:19:04,879
automatically declared hash associative

00:19:02,210 --> 00:19:07,789
array that contains the new data of the

00:19:04,879 --> 00:19:11,690
row that's coming in and we say it's a

00:19:07,789 --> 00:19:14,210
swig and we split it into pieces there

00:19:11,690 --> 00:19:16,429
and then we get the number of tentacles

00:19:14,210 --> 00:19:17,990
and we say no if they're more than 32 or

00:19:16,429 --> 00:19:19,820
less than three tentacles i'm told that

00:19:17,990 --> 00:19:21,470
actually squids have a fixed number of

00:19:19,820 --> 00:19:25,159
tentacles but i'm a program or not a

00:19:21,470 --> 00:19:27,500
marine biologist and we raise us and we

00:19:25,159 --> 00:19:30,019
raise an exception otherwise we return

00:19:27,500 --> 00:19:34,100
okay for four reasons that escape me

00:19:30,019 --> 00:19:35,720
this is the way you say you you return

00:19:34,100 --> 00:19:39,620
this is how you return from a trigger if

00:19:35,720 --> 00:19:41,389
everything's okay so okay in Python all

00:19:39,620 --> 00:19:43,509
right looks like a pretty normal Python

00:19:41,389 --> 00:19:49,610
function couple of extra stuff there but

00:19:43,509 --> 00:19:52,429
um so in the TD composite types like the

00:19:49,610 --> 00:19:54,019
squid are come in as their string

00:19:52,429 --> 00:19:56,059
representation it would be kind of nice

00:19:54,019 --> 00:20:00,740
if they were already parsed apart for

00:19:56,059 --> 00:20:03,470
you they aren't um the thing is it's a

00:20:00,740 --> 00:20:06,350
little tune on trigger stored procedures

00:20:03,470 --> 00:20:12,470
they're past as hashes they are parsed

00:20:06,350 --> 00:20:14,559
apart why no idea but anyway enough of

00:20:12,470 --> 00:20:17,509
that we can attach the trigger here

00:20:14,559 --> 00:20:21,139
create the constraint they transfer your

00:20:17,509 --> 00:20:23,779
juju do so and then we try to insert a

00:20:21,139 --> 00:20:29,570
47 tentacled squid and bang won't let

00:20:23,779 --> 00:20:30,889
you great problem solved one the little

00:20:29,570 --> 00:20:35,509
thing is your now that we're using

00:20:30,889 --> 00:20:37,610
composite types is nulls so Rho types

00:20:35,509 --> 00:20:39,769
have really straight a row type is in is

00:20:37,610 --> 00:20:44,200
the post restraining composite type one

00:20:39,769 --> 00:20:54,440
of these guys for example that's true

00:20:44,200 --> 00:20:58,460
that's also true yeah um null is great

00:20:54,440 --> 00:21:01,429
you know some some of to some of the 0

00:20:58,460 --> 00:21:03,799
and a null is zero sum of a null of some

00:21:01,429 --> 00:21:06,169
of no Rose is no I mean I don't get it

00:21:03,799 --> 00:21:08,350
but whatever you just have to learn the

00:21:06,169 --> 00:21:08,350
rules

00:21:08,570 --> 00:21:13,580
okay well now that we now we need to

00:21:10,970 --> 00:21:15,679
look for squids so here's a everybody

00:21:13,580 --> 00:21:19,360
wherever everybody knows explain analyze

00:21:15,679 --> 00:21:21,980
output so you know easy to read right um

00:21:19,360 --> 00:21:26,809
the so this is great so we're searching

00:21:21,980 --> 00:21:31,419
for squid here whose length is between

00:21:26,809 --> 00:21:35,059
uh whose is between 100 and 101

00:21:31,419 --> 00:21:36,679
centimeters inclusive and it dutifully

00:21:35,059 --> 00:21:39,620
squeeze the whole table it takes two

00:21:36,679 --> 00:21:42,320
point six ish seconds to do that that's

00:21:39,620 --> 00:21:45,679
not so great I mean you know it is you

00:21:42,320 --> 00:21:48,679
know it's scanning what a 10 million

00:21:45,679 --> 00:21:50,179
squid but come on that's a long time you

00:21:48,679 --> 00:21:53,750
know we want our squid now thank you

00:21:50,179 --> 00:21:55,970
very much so but squids fortunately have

00:21:53,750 --> 00:21:57,529
total ordering squids are ordered by

00:21:55,970 --> 00:22:00,740
length and nothing else that's just how

00:21:57,529 --> 00:22:02,740
squids are just accept this so given

00:22:00,740 --> 00:22:05,840
that can we speed up searching on these

00:22:02,740 --> 00:22:10,179
yes we can create full btree indexes on

00:22:05,840 --> 00:22:12,409
custom types with relatively little pain

00:22:10,179 --> 00:22:14,299
the first thing we need to do is to find

00:22:12,409 --> 00:22:15,590
a squid comparison function well we just

00:22:14,299 --> 00:22:19,070
said that the only thing that matters is

00:22:15,590 --> 00:22:20,720
length so we just say do this it behaves

00:22:19,070 --> 00:22:21,889
like you know good old-fashioned

00:22:20,720 --> 00:22:24,409
comparison functions they've been around

00:22:21,889 --> 00:22:27,320
since Fortran I'm return negative 1 this

00:22:24,409 --> 00:22:28,519
if the left is less than right one if

00:22:27,320 --> 00:22:32,509
it's greater than right 0 if they're

00:22:28,519 --> 00:22:34,159
equal ok and you know here and notice

00:22:32,509 --> 00:22:37,399
here that the squids are kind of doing

00:22:34,159 --> 00:22:39,710
the right thing the parameters are doing

00:22:37,399 --> 00:22:41,570
a much more logical thing that they come

00:22:39,710 --> 00:22:44,179
in as hashes rather than that weird TD

00:22:41,570 --> 00:22:46,100
having to parse it apart thing sorry

00:22:44,179 --> 00:22:48,519
about that I I wasn't the implementer

00:22:46,100 --> 00:22:48,519
here um

00:22:49,040 --> 00:22:54,150
so we've defined a comparison function

00:22:52,410 --> 00:22:58,230
and now we also have to find any quality

00:22:54,150 --> 00:23:01,500
function why cuz just work with me here

00:22:58,230 --> 00:23:03,480
um so we say we defining quality on

00:23:01,500 --> 00:23:05,160
squids which is if the left if the links

00:23:03,480 --> 00:23:07,380
are the same that we they are equal

00:23:05,160 --> 00:23:08,820
squids notice this is equality not

00:23:07,380 --> 00:23:10,620
identity very important there could be

00:23:08,820 --> 00:23:14,370
two different squids you know squids

00:23:10,620 --> 00:23:16,860
have individuality we then tell postgres

00:23:14,370 --> 00:23:19,110
about this operator we do the left arm

00:23:16,860 --> 00:23:21,150
you know we say what types of left to

00:23:19,110 --> 00:23:23,160
right are the procedure to run what

00:23:21,150 --> 00:23:25,140
function is the commutation of that

00:23:23,160 --> 00:23:27,030
function so equality is its own so

00:23:25,140 --> 00:23:29,250
that's easy what function is what

00:23:27,030 --> 00:23:33,900
operator is the negation of it not evil

00:23:29,250 --> 00:23:35,820
um and you can read the documentation on

00:23:33,900 --> 00:23:37,170
these these are basically hints to the

00:23:35,820 --> 00:23:40,170
planner about the behavior of these

00:23:37,170 --> 00:23:42,320
functions this also says they can be

00:23:40,170 --> 00:23:44,309
used for hashes and merge joints

00:23:42,320 --> 00:23:46,050
generally the tight if free quality

00:23:44,309 --> 00:23:48,030
operators it's just kind of a cut and

00:23:46,050 --> 00:23:49,679
paste on these guys you read the docs

00:23:48,030 --> 00:23:53,730
about it which are completely cryptic

00:23:49,679 --> 00:23:55,800
and undecipherable right um so then we

00:23:53,730 --> 00:23:57,240
define a less than operator do to do to

00:23:55,800 --> 00:23:59,400
do you can kind of see a pattern

00:23:57,240 --> 00:24:00,990
emerging here we're not going to go

00:23:59,400 --> 00:24:04,950
through them all they pretty much all

00:24:00,990 --> 00:24:06,960
follow this pattern then we define an

00:24:04,950 --> 00:24:08,490
operator class this basically marshalls

00:24:06,960 --> 00:24:10,110
together all the operators to tell it

00:24:08,490 --> 00:24:14,040
everything you need to know about this

00:24:10,110 --> 00:24:15,390
type so one two three four you know but

00:24:14,040 --> 00:24:16,950
posters has been around for a while so

00:24:15,390 --> 00:24:19,950
some of its user interface some of its

00:24:16,950 --> 00:24:22,170
api's are kind of hito an 80's style so

00:24:19,950 --> 00:24:25,620
unfortunately here we go and we tilt the

00:24:22,170 --> 00:24:27,929
screen comparison at this point we can

00:24:25,620 --> 00:24:29,880
just do that you can create an index on

00:24:27,929 --> 00:24:31,020
it and it works takes a little while

00:24:29,880 --> 00:24:33,059
because it's calling this Python

00:24:31,020 --> 00:24:35,360
functions all over and over again 10

00:24:33,059 --> 00:24:38,340
million times it takes a while but now

00:24:35,360 --> 00:24:42,120
we get a much more we'll get another

00:24:38,340 --> 00:24:44,760
easy to read explain output but same

00:24:42,120 --> 00:24:48,570
query hot cash I ran it i did a hot cash

00:24:44,760 --> 00:24:51,200
on both 12 millisec 5 milliseconds much

00:24:48,570 --> 00:24:54,590
better

00:24:51,200 --> 00:25:00,110
same number of squids come back that's

00:24:54,590 --> 00:25:03,049
pretty cool so short talk we can

00:25:00,110 --> 00:25:05,809
implement you can do this we didn't have

00:25:03,049 --> 00:25:09,049
to write any PL pgsql to get we got

00:25:05,809 --> 00:25:10,279
indexes we got comparisons we can use

00:25:09,049 --> 00:25:12,889
that we can use the type fully

00:25:10,279 --> 00:25:15,649
encapsulated inside a postgres we didn't

00:25:12,889 --> 00:25:19,370
lose any database features here san post

00:25:15,649 --> 00:25:20,990
Chris does what it does and you can have

00:25:19,370 --> 00:25:24,620
custom operators on these you can build

00:25:20,990 --> 00:25:26,149
indexes do all that stuff and you say

00:25:24,620 --> 00:25:28,909
well that's great for squid but you know

00:25:26,149 --> 00:25:30,679
I'm allergic to shellfish so the thing

00:25:28,909 --> 00:25:36,080
is this work obviously this generalizes

00:25:30,679 --> 00:25:37,610
very good for example you there are

00:25:36,080 --> 00:25:40,309
range types now in post Chris that you

00:25:37,610 --> 00:25:41,720
can use this with CI tech CI Texas an

00:25:40,309 --> 00:25:44,389
extension type that wolf king of

00:25:41,720 --> 00:25:45,950
case-insensitive comparisons so all that

00:25:44,389 --> 00:25:48,980
business about having create a separate

00:25:45,950 --> 00:25:51,529
index with lower for pepper for user

00:25:48,980 --> 00:25:53,990
names don't do that just declare them

00:25:51,529 --> 00:25:56,059
see I text

00:25:53,990 --> 00:25:57,380
any time you want to advance attribute

00:25:56,059 --> 00:25:59,330
types that you want to adapt to postgres

00:25:57,380 --> 00:26:00,980
you use the same pattern so for example

00:25:59,330 --> 00:26:02,800
if you want to bring see I text into

00:26:00,980 --> 00:26:04,340
your application you can do this

00:26:02,800 --> 00:26:06,860
obviously if you're using a framework

00:26:04,340 --> 00:26:08,750
like Django tons and tons of the stuff

00:26:06,860 --> 00:26:10,850
has already been done for you but if you

00:26:08,750 --> 00:26:12,470
have your own custom ones or you want to

00:26:10,850 --> 00:26:13,580
do that or you have a different

00:26:12,470 --> 00:26:16,429
framework that hasn't gotten there yet

00:26:13,580 --> 00:26:18,679
that's great and you don't have to

00:26:16,429 --> 00:26:20,240
define the type inside a Python you can

00:26:18,679 --> 00:26:22,580
adapt the type without having to have

00:26:20,240 --> 00:26:25,880
written it so it's just stuff not just

00:26:22,580 --> 00:26:28,210
for squid anymore and that's it any

00:26:25,880 --> 00:26:28,210
questions

00:26:41,620 --> 00:26:46,310
what about modifying your types i mean

00:26:44,360 --> 00:26:48,230
migrations i have a feeling that it's

00:26:46,310 --> 00:26:50,000
going to be really painful and you

00:26:48,230 --> 00:26:54,050
should avoid it as much as possible well

00:26:50,000 --> 00:26:55,190
right yes it um I never I never hesitate

00:26:54,050 --> 00:26:59,240
to say something is going to be painful

00:26:55,190 --> 00:27:02,000
when it is it's not so bad the question

00:26:59,240 --> 00:27:04,550
you do have to be a little bit judicious

00:27:02,000 --> 00:27:06,380
in your application it's it's the the

00:27:04,550 --> 00:27:09,380
problem is the synchronization problem

00:27:06,380 --> 00:27:11,600
at some point your code is in a state

00:27:09,380 --> 00:27:13,430
that knows about the new type the the

00:27:11,600 --> 00:27:16,160
the new version of the type and the

00:27:13,430 --> 00:27:18,170
database is not-- has it reaches that

00:27:16,160 --> 00:27:20,390
state the question is in what order do

00:27:18,170 --> 00:27:22,370
they do so and who who is more

00:27:20,390 --> 00:27:24,410
permissive if the application is

00:27:22,370 --> 00:27:26,600
sufficiently permissive that it can

00:27:24,410 --> 00:27:28,520
handle the the serialization and

00:27:26,600 --> 00:27:31,850
deserialization to the old type

00:27:28,520 --> 00:27:33,590
definition you're probably okay for

00:27:31,850 --> 00:27:34,730
example one question is for example in a

00:27:33,590 --> 00:27:37,280
composite type if you're adding a new

00:27:34,730 --> 00:27:39,350
field it'll probably want to decide how

00:27:37,280 --> 00:27:42,440
what you do for a default for that field

00:27:39,350 --> 00:27:45,590
you set it to null do you set it for a

00:27:42,440 --> 00:27:47,330
default if you're conforming function is

00:27:45,590 --> 00:27:48,800
sufficiently permissive you're okay

00:27:47,330 --> 00:27:50,510
because you can roll forward the

00:27:48,800 --> 00:27:53,750
database and then the application

00:27:50,510 --> 00:27:56,330
catches up at some point so um you can

00:27:53,750 --> 00:28:00,410
certainly get into really ugly scenarios

00:27:56,330 --> 00:28:02,420
no question about that but generally

00:28:00,410 --> 00:28:05,690
with all database schema migrations you

00:28:02,420 --> 00:28:08,090
need to think about there will be this

00:28:05,690 --> 00:28:09,800
window when things are not in sync and

00:28:08,090 --> 00:28:11,750
how you know how long is that window and

00:28:09,800 --> 00:28:13,850
how and what do you do during that

00:28:11,750 --> 00:28:16,280
window my personal philosophy is is that

00:28:13,850 --> 00:28:18,230
because the database kind is atomically

00:28:16,280 --> 00:28:19,730
switch you know you're using a sensible

00:28:18,230 --> 00:28:21,500
migration system like south or something

00:28:19,730 --> 00:28:23,540
like that the database at some point

00:28:21,500 --> 00:28:25,250
atomically switches to the new version

00:28:23,540 --> 00:28:26,900
you want the application to be the

00:28:25,250 --> 00:28:28,790
permissive one that can handle both

00:28:26,900 --> 00:28:32,110
versions of the app of the database that

00:28:28,790 --> 00:28:34,610
that you know that can be a lot of some

00:28:32,110 --> 00:28:36,500
less than pretty code especially when

00:28:34,610 --> 00:28:42,170
you're on my database migration number

00:28:36,500 --> 00:28:44,830
423 but you know so that's but you can

00:28:42,170 --> 00:28:44,830
mitigate it

00:28:51,160 --> 00:28:55,840
so the squid example is very good for

00:28:53,830 --> 00:28:57,310
didactic purses purposes because you can

00:28:55,840 --> 00:28:59,410
understand what you're doing but so far

00:28:57,310 --> 00:29:01,630
I'm not sold on why I would do this

00:28:59,410 --> 00:29:03,400
route rather than just use sickle

00:29:01,630 --> 00:29:04,930
alchemy so can you maybe give more like

00:29:03,400 --> 00:29:07,630
teasers like what is possible with this

00:29:04,930 --> 00:29:10,740
approach as opposed to using a norm well

00:29:07,630 --> 00:29:15,850
that's that's a really good question um

00:29:10,740 --> 00:29:20,170
if I would say the the there are two

00:29:15,850 --> 00:29:21,820
there are two exist one is if you if

00:29:20,170 --> 00:29:24,190
there's a built-in tie if there's a sea

00:29:21,820 --> 00:29:26,140
level type that is that's something

00:29:24,190 --> 00:29:28,330
that's really useful then obviously

00:29:26,140 --> 00:29:30,250
you're doing this adaptation but you

00:29:28,330 --> 00:29:31,810
don't have an adaptation for it having

00:29:30,250 --> 00:29:33,970
this adaptation mechanism can be very

00:29:31,810 --> 00:29:36,040
handy like your use this is what post

00:29:33,970 --> 00:29:38,320
just does you know for all of its stuff

00:29:36,040 --> 00:29:39,670
and you it would be kind of silly if you

00:29:38,320 --> 00:29:43,060
couldn't use post just from Python

00:29:39,670 --> 00:29:45,730
natively it's what what geo Django does

00:29:43,060 --> 00:29:48,400
for that kind of thing um the composite

00:29:45,730 --> 00:29:50,500
type example is some the the other

00:29:48,400 --> 00:29:52,300
example is if you're dealing with things

00:29:50,500 --> 00:29:55,120
that do not all focus straight through

00:29:52,300 --> 00:29:57,400
the arm the arm is not the only access

00:29:55,120 --> 00:30:00,070
to the database this is one of you know

00:29:57,400 --> 00:30:01,990
I love arms I do tons of Django writing

00:30:00,070 --> 00:30:03,700
i'm kind of a big defender PGX about

00:30:01,990 --> 00:30:04,960
using arms because i have an application

00:30:03,700 --> 00:30:06,790
programmer background than the

00:30:04,960 --> 00:30:10,390
alternative would make me slit my wrists

00:30:06,790 --> 00:30:12,460
but that being said databases almost

00:30:10,390 --> 00:30:15,250
inevitably have clients that are not

00:30:12,460 --> 00:30:16,870
armed centric and for doing this kind of

00:30:15,250 --> 00:30:18,940
and for doing this kind of encapsulation

00:30:16,870 --> 00:30:23,940
and maintenance it can be very handy to

00:30:18,940 --> 00:30:26,740
be able to build these row types so the

00:30:23,940 --> 00:30:28,840
in some ways i would say this is a skill

00:30:26,740 --> 00:30:31,210
set that you can kind of generalize to a

00:30:28,840 --> 00:30:34,330
lot of different things like like other

00:30:31,210 --> 00:30:35,650
built-in types and things like this will

00:30:34,330 --> 00:30:37,990
this be something you slam into every

00:30:35,650 --> 00:30:40,900
database all the time probably not but

00:30:37,990 --> 00:30:42,910
you know some but I've done it a bunch

00:30:40,900 --> 00:30:45,550
of times in even using an arm like

00:30:42,910 --> 00:30:47,770
Django's arm it's perfectly fine to you

00:30:45,550 --> 00:30:49,330
know you can you can you can you can get

00:30:47,770 --> 00:30:51,760
both worlds you can still use the arm

00:30:49,330 --> 00:30:55,950
and just wrap up the end then wrap up

00:30:51,760 --> 00:30:55,950
the type inside of Jenga

00:31:10,179 --> 00:31:18,460
and maybe maybe just to justify your

00:31:15,519 --> 00:31:21,279
water name sorry Tom's opinion maybe

00:31:18,460 --> 00:31:24,869
could also explain that we can use

00:31:21,279 --> 00:31:28,509
extensions in Postgres so maybe to

00:31:24,869 --> 00:31:30,490
perform migrations from a version to

00:31:28,509 --> 00:31:33,249
another one in an atomic way and

00:31:30,490 --> 00:31:36,369
transactional way we could we could use

00:31:33,249 --> 00:31:37,600
X postgresql extensions well in the

00:31:36,369 --> 00:31:40,299
sense of the create extension mechanism

00:31:37,600 --> 00:31:42,279
yeah the create extension mechanism joke

00:31:40,299 --> 00:31:44,049
yeah and it's I mean the most custom

00:31:42,279 --> 00:31:45,759
types in Postgres these days now that we

00:31:44,049 --> 00:31:47,649
have extensions that's how they're

00:31:45,759 --> 00:31:51,879
introduced into the system is with

00:31:47,649 --> 00:31:53,440
create extension which is a bit you know

00:31:51,879 --> 00:31:56,139
that's a little that wasn't quite what I

00:31:53,440 --> 00:31:57,580
was about here but it's a if you are

00:31:56,139 --> 00:31:58,899
creating custom types that would be the

00:31:57,580 --> 00:32:00,519
right way to package them up because

00:31:58,899 --> 00:32:02,470
then they're much easier to integrate

00:32:00,519 --> 00:32:03,490
into a migration system especially at

00:32:02,470 --> 00:32:04,899
the point you're talking about Craig all

00:32:03,490 --> 00:32:05,799
the operator operators and operator

00:32:04,899 --> 00:32:07,600
classes and things like that because

00:32:05,799 --> 00:32:09,610
that's a fair number of objects so

00:32:07,600 --> 00:32:10,659
having a B we'll just say create

00:32:09,610 --> 00:32:13,059
extension rather than dump a whole

00:32:10,659 --> 00:32:14,379
sequel file in is very handy of course

00:32:13,059 --> 00:32:15,730
i'll create extension does in this case

00:32:14,379 --> 00:32:18,960
is dumped a whole sequel file in but

00:32:15,730 --> 00:32:18,960
it's much cleaner way of doing it

00:32:29,639 --> 00:32:37,499
um so do you think it's mindful to

00:32:32,959 --> 00:32:40,079
someone right the support for secular in

00:32:37,499 --> 00:32:44,009
an example Django framework to create

00:32:40,079 --> 00:32:47,759
those fields models and wrap it do you

00:32:44,009 --> 00:32:51,989
peel viton thing and make it rightly

00:32:47,759 --> 00:32:55,409
into database I'm not quite following in

00:32:51,989 --> 00:32:59,039
my apologies it's like you're presented

00:32:55,409 --> 00:33:03,419
here the way to make your own data

00:32:59,039 --> 00:33:06,929
models in in the pollsters yes and what

00:33:03,419 --> 00:33:10,109
about creating the way Django can make

00:33:06,929 --> 00:33:14,070
those models right in the database it's

00:33:10,109 --> 00:33:15,659
to be consistent with the RM well they

00:33:14,070 --> 00:33:17,820
believe it's pretty much the same

00:33:15,659 --> 00:33:20,159
comment he have which is why do go

00:33:17,820 --> 00:33:22,529
through all of the these these pushups

00:33:20,159 --> 00:33:24,440
as it were if you can just say well I

00:33:22,529 --> 00:33:27,149
just create my model object in Django

00:33:24,440 --> 00:33:30,559
there are two reasons one is frequently

00:33:27,149 --> 00:33:33,509
you have things that you do not want to

00:33:30,559 --> 00:33:35,309
share between models via foreign key you

00:33:33,509 --> 00:33:37,829
want to actually embed them in ever in

00:33:35,309 --> 00:33:39,149
multiple models you know for performance

00:33:37,829 --> 00:33:40,559
reasons or because they're really you

00:33:39,149 --> 00:33:42,749
don't want a centralized table or

00:33:40,559 --> 00:33:47,429
they're really conceptually autonomous

00:33:42,749 --> 00:33:49,589
things but you you don't want to have to

00:33:47,429 --> 00:33:52,679
write them over and over the same field

00:33:49,589 --> 00:33:55,079
cluster over and over and over again one

00:33:52,679 --> 00:33:56,669
example that you could argue this either

00:33:55,079 --> 00:33:58,649
way in the particular case all I can say

00:33:56,669 --> 00:34:01,799
is a made sense at the time was an

00:33:58,649 --> 00:34:03,029
address was when we're at some point you

00:34:01,799 --> 00:34:04,559
we were looking at the database and

00:34:03,029 --> 00:34:05,879
there was like a dress the same set of

00:34:04,559 --> 00:34:08,190
address fields were appearing all over

00:34:05,879 --> 00:34:10,139
the place it didn't make sense to unify

00:34:08,190 --> 00:34:12,450
them into a centralized table for

00:34:10,139 --> 00:34:14,279
performance reasons but it was just kind

00:34:12,450 --> 00:34:16,230
of ugly and every time we had to update

00:34:14,279 --> 00:34:18,629
change whether the address was it meant

00:34:16,230 --> 00:34:21,119
changing you know touching 12 models and

00:34:18,629 --> 00:34:23,579
so we decided to cluster that into a

00:34:21,119 --> 00:34:26,069
sing into an address row type and embed

00:34:23,579 --> 00:34:29,429
that and then you and that worked very

00:34:26,069 --> 00:34:31,529
well so you know you this is not

00:34:29,429 --> 00:34:33,929
something you will probably do you know

00:34:31,529 --> 00:34:37,889
every every you know every just replace

00:34:33,929 --> 00:34:39,389
like cluster everything into cluster

00:34:37,889 --> 00:34:40,600
everything into these row types was very

00:34:39,389 --> 00:34:43,450
handy if you have

00:34:40,600 --> 00:34:45,430
need it so so we rather think it's in

00:34:43,450 --> 00:34:48,610
after post process think like you

00:34:45,430 --> 00:34:50,830
created your modules create your RM and

00:34:48,610 --> 00:34:53,290
touch that together and you want to

00:34:50,830 --> 00:34:55,420
optimize it then you tend to make it

00:34:53,290 --> 00:34:57,700
changes in the it's like any software

00:34:55,420 --> 00:34:59,890
design at some point you notice oh man I

00:34:57,700 --> 00:35:01,510
typed I've typed this 12 times and you

00:34:59,890 --> 00:35:03,190
go back to do it sometimes you know in

00:35:01,510 --> 00:35:05,230
advance you know for whatever reason

00:35:03,190 --> 00:35:07,420
because the the the problem domain just

00:35:05,230 --> 00:35:09,430
sign up drove you towards a particular

00:35:07,420 --> 00:35:10,720
solution in the particular case the

00:35:09,430 --> 00:35:12,910
address thing I mentioned that was a

00:35:10,720 --> 00:35:14,800
case where it was you know I'm getting

00:35:12,910 --> 00:35:16,240
sick of updating this well what really

00:35:14,800 --> 00:35:21,720
happened was I forgot to update at one

00:35:16,240 --> 00:35:21,720
point it was like a head decided enough

00:35:23,370 --> 00:35:30,610
I'm quite scared by me no fretting thing

00:35:27,910 --> 00:35:32,560
but because it's kind of hard to know if

00:35:30,610 --> 00:35:36,400
you're using Fred's using third-party

00:35:32,560 --> 00:35:38,650
code so that essentially means just do

00:35:36,400 --> 00:35:40,780
very little them well it depends on what

00:35:38,650 --> 00:35:42,610
you're into pity you do have to be

00:35:40,780 --> 00:35:44,140
judicious about what libraries you your

00:35:42,610 --> 00:35:45,670
but you know what third part what

00:35:44,140 --> 00:35:47,830
modules you're calling could could you

00:35:45,670 --> 00:35:53,530
make it a runtime error it's somebody

00:35:47,830 --> 00:35:54,970
great today Fred um potentially i know

00:35:53,530 --> 00:35:57,220
i'm not familiar with the pl Python

00:35:54,970 --> 00:35:59,200
inter internals I mean there are things

00:35:57,220 --> 00:36:01,570
for example if you're calling datetime

00:35:59,200 --> 00:36:03,730
if daytime is doing threading somebody

00:36:01,570 --> 00:36:05,080
needs to be hit because that is not you

00:36:03,730 --> 00:36:07,120
know think primitive types like that

00:36:05,080 --> 00:36:08,320
should not be spawning threads to do

00:36:07,120 --> 00:36:12,070
things that you never know with

00:36:08,320 --> 00:36:13,960
somebody's doing something don't may

00:36:12,070 --> 00:36:16,390
happen in places you don't expect

00:36:13,960 --> 00:36:18,610
probably not that I'm so you have to be

00:36:16,390 --> 00:36:21,430
very very careful no very very

00:36:18,610 --> 00:36:26,280
knowledgeable of Alfea well it's um

00:36:21,430 --> 00:36:30,940
there's I'm a little skeptical that

00:36:26,280 --> 00:36:33,370
routine that that routine core python

00:36:30,940 --> 00:36:35,860
modules are spawning threads willy-nilly

00:36:33,370 --> 00:36:38,650
without anyone without any documentation

00:36:35,860 --> 00:36:40,840
that that is what they are doing I'm a

00:36:38,650 --> 00:36:42,700
little skeptical of that I'm perfectly

00:36:40,840 --> 00:36:45,970
willing to be proven wrong because I

00:36:42,700 --> 00:36:47,080
frequently am but now if you're dragging

00:36:45,970 --> 00:36:49,870
in third part you know if you're doing

00:36:47,080 --> 00:36:51,880
bunch of hip installs and especially if

00:36:49,870 --> 00:36:53,200
that code has you know it for example I

00:36:51,880 --> 00:36:54,250
would not be right I would not call

00:36:53,200 --> 00:36:56,260
requests from

00:36:54,250 --> 00:36:57,520
side of a one of these first of all

00:36:56,260 --> 00:37:00,280
doing that kind of stuff from inside of

00:36:57,520 --> 00:37:02,440
a back-end you you are gumming up the

00:37:00,280 --> 00:37:04,690
request loop so anything you know I

00:37:02,440 --> 00:37:05,950
would one thing to think about is if

00:37:04,690 --> 00:37:08,830
you're doing anything that has any kind

00:37:05,950 --> 00:37:10,780
of asynchronous behavior a back-end a

00:37:08,830 --> 00:37:13,000
back-end stored procedure is not the

00:37:10,780 --> 00:37:14,950
place to be doing it because the clients

00:37:13,000 --> 00:37:18,610
waiting for you you know it's that kind

00:37:14,950 --> 00:37:21,790
of thing so there it does mean that you

00:37:18,610 --> 00:37:23,530
need to you know I postgres isn't an

00:37:21,790 --> 00:37:25,330
application server you know that's it's

00:37:23,530 --> 00:37:27,960
not intended for you know back at the

00:37:25,330 --> 00:37:32,170
back end loop is not intended for that

00:37:27,960 --> 00:37:34,180
but um yeah you know you you are you

00:37:32,170 --> 00:37:35,860
know the the upside is you get to live

00:37:34,180 --> 00:37:37,300
inside the database you get hype or

00:37:35,860 --> 00:37:39,700
high-speed access directly to it the bad

00:37:37,300 --> 00:37:43,240
news is you do have to be very judicious

00:37:39,700 --> 00:37:45,190
about what you do and I might have

00:37:43,240 --> 00:37:48,250
missed it but did you give any numbers

00:37:45,190 --> 00:37:52,480
about what can I gain from it in terms

00:37:48,250 --> 00:37:55,210
of speed no I I didn't wouldn't you well

00:37:52,480 --> 00:37:57,010
I had head I the numbers close to hand I

00:37:55,210 --> 00:38:00,550
would but you are certainly you are

00:37:57,010 --> 00:38:02,080
saving the the part of it is it depends

00:38:00,550 --> 00:38:03,460
on how far away from the database server

00:38:02,080 --> 00:38:04,840
you are if you're talking to database

00:38:03,460 --> 00:38:07,330
server over a local socket you're

00:38:04,840 --> 00:38:08,470
probably saving some but not a ton if

00:38:07,330 --> 00:38:11,470
you're talking about if you're talking

00:38:08,470 --> 00:38:13,390
through you know if you have two VMs in

00:38:11,470 --> 00:38:14,920
Amazon one's way over here one's way

00:38:13,390 --> 00:38:16,090
over here and you have PG bouncer and PG

00:38:14,920 --> 00:38:18,010
pool at a bunch of stuff between them

00:38:16,090 --> 00:38:21,450
you're saving a lot because of the

00:38:18,010 --> 00:38:21,450
request overhead so

00:38:23,400 --> 00:38:28,120
and some things and you know and some

00:38:26,740 --> 00:38:29,770
things like building it like index

00:38:28,120 --> 00:38:31,720
operators you have to do inside of the

00:38:29,770 --> 00:38:34,240
index operation triggers you have no

00:38:31,720 --> 00:38:36,730
choice so the the overheads not an issue

00:38:34,240 --> 00:38:39,940
there yeah related question to the

00:38:36,730 --> 00:38:43,360
performance overhead I guess most of

00:38:39,940 --> 00:38:47,170
these these for these examples the

00:38:43,360 --> 00:38:50,680
performance overhead is basically on

00:38:47,170 --> 00:38:53,140
insert right well it's on the the main

00:38:50,680 --> 00:38:55,260
performance overhead is there are two

00:38:53,140 --> 00:38:58,090
sets of performance overhead one is

00:38:55,260 --> 00:39:00,400
comparing calling doing everything

00:38:58,090 --> 00:39:02,440
through database operations remotely you

00:39:00,400 --> 00:39:03,940
know from a clot from the client as

00:39:02,440 --> 00:39:06,340
opposed to running it inside the

00:39:03,940 --> 00:39:09,400
postgres core inside the back end the

00:39:06,340 --> 00:39:13,750
other is Python overhead versus the raw

00:39:09,400 --> 00:39:15,250
sequel execution overhead as a this is a

00:39:13,750 --> 00:39:16,240
little bit outside but we were talking

00:39:15,250 --> 00:39:18,190
about here but I'll give sort of a

00:39:16,240 --> 00:39:19,810
general rule there people frequently ask

00:39:18,190 --> 00:39:21,280
well should i use PL python because i

00:39:19,810 --> 00:39:23,020
like it i like python i'm familiar with

00:39:21,280 --> 00:39:25,990
it and all this stuff or should i use PL

00:39:23,020 --> 00:39:28,480
pgsql and the answer is how much of this

00:39:25,990 --> 00:39:30,340
is pure query if the answer is a lot of

00:39:28,480 --> 00:39:31,540
its pure querying you're probably going

00:39:30,340 --> 00:39:34,720
to be fat it's probably going to be

00:39:31,540 --> 00:39:35,980
faster running PL pgsql is it does kind

00:39:34,720 --> 00:39:38,530
of have privileged access to the

00:39:35,980 --> 00:39:40,360
database is it's it's AP it's its

00:39:38,530 --> 00:39:42,820
connection to the day basis is faster

00:39:40,360 --> 00:39:44,860
than then this in part because it's

00:39:42,820 --> 00:39:47,590
pretty parsed and a budget and things

00:39:44,860 --> 00:39:49,690
like that if what you're doing is mainly

00:39:47,590 --> 00:39:51,910
computation though with a little bit of

00:39:49,690 --> 00:39:54,130
database access the Python will be

00:39:51,910 --> 00:39:55,960
faster almost any language will be

00:39:54,130 --> 00:39:58,210
faster because every expression in PL

00:39:55,960 --> 00:40:01,390
pgsql is actually executed by the query

00:39:58,210 --> 00:40:05,050
engine so if you say select 1 plus 2

00:40:01,390 --> 00:40:07,450
into something or i equals y equals i

00:40:05,050 --> 00:40:09,430
plus 1 which you have done is built a

00:40:07,450 --> 00:40:11,320
query that queries i plus 1 from the

00:40:09,430 --> 00:40:13,180
database and returns the value it

00:40:11,320 --> 00:40:14,590
assigns it to I that's not going to be

00:40:13,180 --> 00:40:19,150
as fast as running it aside the Python

00:40:14,590 --> 00:40:20,500
interpreter so there is a little more

00:40:19,150 --> 00:40:21,670
overhead because it has it takes the

00:40:20,500 --> 00:40:23,290
string and it's basically doing and

00:40:21,670 --> 00:40:25,060
execute on it it's having to parse it up

00:40:23,290 --> 00:40:27,940
and do all that kind of stuff there is

00:40:25,060 --> 00:40:29,620
um there is a way of saving plans so if

00:40:27,940 --> 00:40:31,480
you're doing a bunch of like a ton of

00:40:29,620 --> 00:40:35,520
inserts or something like that you save

00:40:31,480 --> 00:40:35,520
the plan in Python and do it repeatedly

00:40:44,820 --> 00:40:53,680
any more questions okay thank you very

00:40:52,060 --> 00:40:55,740
much crystal

00:40:53,680 --> 00:40:55,740

YouTube URL: https://www.youtube.com/watch?v=BpLz_5x_vTo


