Title: Christian Trebing - Building a multi-purpose platform for bulk data using sqlalchemy
Publication date: 2015-08-08
Playlist: EuroPython 2015
Description: 
	Christian Trebing - Building a multi-purpose platform for bulk data using sqlalchemy
[EuroPython 2015]
[23 July 2015]
[Bilbao, Euskadi, Spain]

At Blue Yonder, we've built a platform that can accept and process
bulk amounts of data for multiple business domains (e.g. handling
retail store location and sales data) using SQLAlchemy as a database
abstraction layer.

We wanted to use as much of SQLAlchemy as possible, but we quickly
found that the ORM (Object Relational Mapper) is not suitable for
handling large amounts of data at once. At the same time, we did not
want each team of developers working on individual business domains to
have to handcraft their own SQL statements. To solve this problem, we
built an application configuration that closely resembles an
SQLAlchemy model, but also contains application-specific logic
settings.

In this talk I will demonstrate:

 - an application architecture for multiple business domains

 - the structure of the domain configuration utilized in the
generation of the SQLAlchemy model, SQLAlchemy core statements, and
other application functionality

 - how the domain configuration is used throughout the application
(consuming and parsing incoming data, storing it in a database and
ensuring data quality)
Captions: 
	00:00:00,000 --> 00:00:04,230
Tomas and I'm working on the team while

00:00:02,580 --> 00:00:05,730
we process that data will we make that

00:00:04,230 --> 00:00:08,179
available for the machine learning and

00:00:05,730 --> 00:00:11,429
what we therefore build this ati's and

00:00:08,179 --> 00:00:13,530
that's the main topic of my talk it's

00:00:11,429 --> 00:00:16,080
mainly three things you can see here in

00:00:13,530 --> 00:00:20,550
the title it's building a mighty purpose

00:00:16,080 --> 00:00:22,619
platform meaning we want to use it for

00:00:20,550 --> 00:00:25,230
different business domains I will

00:00:22,619 --> 00:00:28,140
explain that later on we have five datas

00:00:25,230 --> 00:00:30,599
or not just a few data sets but lots of

00:00:28,140 --> 00:00:33,570
data which need to be processed at a

00:00:30,599 --> 00:00:35,250
fast way and we do it using sequel alka

00:00:33,570 --> 00:00:37,500
mean these are the three points that you

00:00:35,250 --> 00:00:39,090
will see throughout the presentation we

00:00:37,500 --> 00:00:41,160
are introducing a way of building data

00:00:39,090 --> 00:00:42,690
processing applications that can be used

00:00:41,160 --> 00:00:47,730
in many the sort of business domains

00:00:42,690 --> 00:00:49,890
that's the topic yeah sequel alchemy we

00:00:47,730 --> 00:00:52,110
are building on sequel alchemy I mean

00:00:49,890 --> 00:00:53,430
most of us you know that it's just a

00:00:52,110 --> 00:00:55,320
statement from the website which are

00:00:53,430 --> 00:00:57,329
copied here and have to say what I

00:00:55,320 --> 00:00:59,460
really like about sequel alchemy is that

00:00:57,329 --> 00:01:01,730
gives you so much flexibility in how to

00:00:59,460 --> 00:01:04,680
build your application you really have

00:01:01,730 --> 00:01:07,290
both ends of the spectrum doing it much

00:01:04,680 --> 00:01:09,299
better base oriented for high

00:01:07,290 --> 00:01:11,580
performance and you can you also have

00:01:09,299 --> 00:01:13,799
the OEM where you can program in a much

00:01:11,580 --> 00:01:17,369
more abstract way and within our

00:01:13,799 --> 00:01:20,810
application we use both of these flavors

00:01:17,369 --> 00:01:24,270
depending on in what area we are and

00:01:20,810 --> 00:01:29,070
what we do exactly in the API processing

00:01:24,270 --> 00:01:31,590
part by the show here so let's build a

00:01:29,070 --> 00:01:33,990
multi-domain platform watch do we have

00:01:31,590 --> 00:01:37,350
to do what do our customers expect from

00:01:33,990 --> 00:01:40,409
us well we have to load the part data

00:01:37,350 --> 00:01:42,899
why a CSV file this is what I will show

00:01:40,409 --> 00:01:46,259
in my example or in real life we also

00:01:42,899 --> 00:01:50,399
use XML files we get that into the

00:01:46,259 --> 00:01:53,790
system why are where HTTP interface

00:01:50,399 --> 00:01:57,360
where I post request we have to verify

00:01:53,790 --> 00:01:59,850
that data we have had several talks

00:01:57,360 --> 00:02:01,619
already regarding cleaned a big data

00:01:59,850 --> 00:02:04,920
which is not always clean which can be

00:02:01,619 --> 00:02:06,869
quite messy and so that our machine

00:02:04,920 --> 00:02:09,300
learning can work on that we need to

00:02:06,869 --> 00:02:11,910
have clean data that has validated

00:02:09,300 --> 00:02:12,750
preferences and that's one important

00:02:11,910 --> 00:02:15,600
part of our work

00:02:12,750 --> 00:02:17,730
occasion what we do yeah and we use it

00:02:15,600 --> 00:02:20,190
for different business domain so what we

00:02:17,730 --> 00:02:24,320
currently do in our company is for

00:02:20,190 --> 00:02:28,440
retail for tourism and for other areas

00:02:24,320 --> 00:02:30,780
but yeah what I will show on the demo I

00:02:28,440 --> 00:02:32,490
will explain on the next slide then so

00:02:30,780 --> 00:02:34,560
there's still a lot of technical to

00:02:32,490 --> 00:02:37,050
deuce what we have to do we have to

00:02:34,560 --> 00:02:39,690
create a database schema based on the

00:02:37,050 --> 00:02:42,959
business domain wherein we have to parse

00:02:39,690 --> 00:02:44,820
the cs we we have to save that part CSV

00:02:42,959 --> 00:02:47,010
data into the database will have to

00:02:44,820 --> 00:02:49,230
validate the data validations there can

00:02:47,010 --> 00:02:51,120
be multiple things we have to check that

00:02:49,230 --> 00:02:53,160
the required fields are filled we have

00:02:51,120 --> 00:02:56,190
to check that the data is correct and

00:02:53,160 --> 00:02:59,850
that in a date field there is no time

00:02:56,190 --> 00:03:02,880
for example or are no other descriptions

00:02:59,850 --> 00:03:04,530
like today or tomorrow and you have to

00:03:02,880 --> 00:03:07,380
check that the references between the

00:03:04,530 --> 00:03:09,150
data results are correct we want to give

00:03:07,380 --> 00:03:10,590
the feedback we want to give feedback to

00:03:09,150 --> 00:03:12,870
the customer about the processing

00:03:10,590 --> 00:03:15,989
processing status of the office data

00:03:12,870 --> 00:03:18,380
whether it was accepted whether we were

00:03:15,989 --> 00:03:21,540
able to process it order stand with it

00:03:18,380 --> 00:03:23,970
and it is important for us that we can

00:03:21,540 --> 00:03:26,640
separate the data that we received from

00:03:23,970 --> 00:03:28,890
the customer from the clean and related

00:03:26,640 --> 00:03:31,200
data that we will use for machine

00:03:28,890 --> 00:03:34,230
learning so we want to be always be able

00:03:31,200 --> 00:03:38,750
to track what was sent to us and what we

00:03:34,230 --> 00:03:41,250
made from that having thought about that

00:03:38,750 --> 00:03:45,329
let's have a look at our first customer

00:03:41,250 --> 00:03:47,549
our first customer is a pup and what

00:03:45,329 --> 00:03:51,329
could a pub want from a machine learning

00:03:47,549 --> 00:03:53,940
algorithm it wants to predict how many

00:03:51,329 --> 00:03:56,370
drinks are so it in the next evening's

00:03:53,940 --> 00:03:59,790
so that they can plan accordingly how

00:03:56,370 --> 00:04:02,579
much to buy how much water's to have so

00:03:59,790 --> 00:04:04,560
to do that they want to send us the

00:04:02,579 --> 00:04:07,470
drinks they have available they want to

00:04:04,560 --> 00:04:12,630
send us how many drinks were ordered /

00:04:07,470 --> 00:04:15,720
evening for the last half year and how

00:04:12,630 --> 00:04:19,489
many wizard has dead on each evening so

00:04:15,720 --> 00:04:19,489
that we can do our learning on that

00:04:19,830 --> 00:04:25,240
how could the data model for this look

00:04:22,210 --> 00:04:29,530
like it's quite simple we have found the

00:04:25,240 --> 00:04:33,070
one hand the drinks the orders reference

00:04:29,530 --> 00:04:34,480
the drinks and the visitors that's just

00:04:33,070 --> 00:04:39,160
another table that we have for

00:04:34,480 --> 00:04:41,110
information I told you that we need to

00:04:39,160 --> 00:04:44,140
separate the data we got from the

00:04:41,110 --> 00:04:48,580
customer to the data that invalidated to

00:04:44,140 --> 00:04:51,130
do that we have two sets of tables on

00:04:48,580 --> 00:04:53,680
the one hand these are the stage tables

00:04:51,130 --> 00:04:55,510
these are the data we got from the

00:04:53,680 --> 00:04:57,190
customer just as we get it from the

00:04:55,510 --> 00:04:59,140
customer so maybe he sent several

00:04:57,190 --> 00:05:00,880
updates then we have several lines in

00:04:59,140 --> 00:05:03,430
them maybe they're summed up leg hurts

00:05:00,880 --> 00:05:05,650
because you sent the same guy twice then

00:05:03,430 --> 00:05:07,570
we have several lines in there and maybe

00:05:05,650 --> 00:05:11,110
there are some errors in then we also

00:05:07,570 --> 00:05:13,030
have them all in that stage what you

00:05:11,110 --> 00:05:15,460
want to get out of that process is the

00:05:13,030 --> 00:05:17,290
core and in the car we also have two

00:05:15,460 --> 00:05:20,650
drinks to order center bulletins are

00:05:17,290 --> 00:05:23,080
there we have one unique ID for each

00:05:20,650 --> 00:05:25,420
data records and one we have updates to

00:05:23,080 --> 00:05:29,260
the data we will update that data record

00:05:25,420 --> 00:05:31,030
are not saving at several times so the

00:05:29,260 --> 00:05:33,460
machine learning algorithms can use that

00:05:31,030 --> 00:05:39,490
and can be confident that they will get

00:05:33,460 --> 00:05:43,330
sensible data how could such a CSV

00:05:39,490 --> 00:05:47,050
delivery look like well let's take a

00:05:43,330 --> 00:05:48,640
simple pub we have some beer we have

00:05:47,050 --> 00:05:52,419
some additional information here

00:05:48,640 --> 00:05:55,060
alcoholic content we have whiskey let's

00:05:52,419 --> 00:05:58,630
see maybe the pubs in Scotland we serve

00:05:55,060 --> 00:06:00,010
Scottish whiskey without an e and we

00:05:58,630 --> 00:06:02,980
have some coke for the people not

00:06:00,010 --> 00:06:06,700
wanting some euro whiskey and you have

00:06:02,980 --> 00:06:10,060
these orders on that day we searched n

00:06:06,700 --> 00:06:13,390
beer and egg coke on the 11th of July 15

00:06:10,060 --> 00:06:17,169
beer and two whiskey and on 12 of July

00:06:13,390 --> 00:06:20,350
we sold 13 beer and one yeah well we got

00:06:17,169 --> 00:06:22,540
a new waiter from Ireland there there

00:06:20,350 --> 00:06:25,720
rather whiskey with an E but it would be

00:06:22,540 --> 00:06:28,300
bad for us as we only know the Scottish

00:06:25,720 --> 00:06:32,530
whiskey but things can happen

00:06:28,300 --> 00:06:36,550
we get back at delivery now what do we

00:06:32,530 --> 00:06:39,099
want to do with that ideally what our

00:06:36,550 --> 00:06:42,639
code should be able to do it should find

00:06:39,099 --> 00:06:45,729
references between objects so we have

00:06:42,639 --> 00:06:48,400
that stage table here these are the

00:06:45,729 --> 00:06:50,560
orders we get and you can see thats the

00:06:48,400 --> 00:06:53,440
external code you saw that's the drinks

00:06:50,560 --> 00:06:55,960
you saw on that's the count you saw on

00:06:53,440 --> 00:06:59,289
the orders table and then there's this

00:06:55,960 --> 00:07:01,840
new column the drinks reference this is

00:06:59,289 --> 00:07:05,500
nothing the customer sent to us this is

00:07:01,840 --> 00:07:07,479
the reference to the unique IDs of the

00:07:05,500 --> 00:07:09,460
drinks we want to find they are

00:07:07,479 --> 00:07:13,240
available here in the car you can see

00:07:09,460 --> 00:07:15,789
Lockhart table you see here we have you

00:07:13,240 --> 00:07:18,580
a deal and we want to write that in

00:07:15,789 --> 00:07:22,180
there s one implementation detail I

00:07:18,580 --> 00:07:24,280
missed at the last slide here we don't

00:07:22,180 --> 00:07:27,099
have a foreign key relationship between

00:07:24,280 --> 00:07:28,870
this column and this column here can be

00:07:27,099 --> 00:07:32,969
anything in so at the moment that's

00:07:28,870 --> 00:07:35,229
empty but in the corn we defined a

00:07:32,969 --> 00:07:36,969
foreign key relationship between that

00:07:35,229 --> 00:07:39,130
table and at the head table so that also

00:07:36,969 --> 00:07:41,319
the database ensures that really less

00:07:39,130 --> 00:07:44,800
sensible data in here so whenever we

00:07:41,319 --> 00:07:47,289
want to copy that data to the table we

00:07:44,800 --> 00:07:50,139
really need to make sure that we find

00:07:47,289 --> 00:07:51,940
the correct references first this we do

00:07:50,139 --> 00:07:54,310
in two steps we have the reference

00:07:51,940 --> 00:07:57,400
finding step which writes them in here

00:07:54,310 --> 00:08:00,310
and then when they are in it rides the

00:07:57,400 --> 00:08:02,680
validated data to the car and copies and

00:08:00,310 --> 00:08:05,259
then you can see it omits just this

00:08:02,680 --> 00:08:07,419
information but keeps the reference

00:08:05,259 --> 00:08:10,569
information with a foreign key to the

00:08:07,419 --> 00:08:13,090
drinks table and you also see the last

00:08:10,569 --> 00:08:15,219
line is submitted this whiskey he could

00:08:13,090 --> 00:08:17,169
not process he did not copy it in there

00:08:15,219 --> 00:08:19,509
we have to decide in our application

00:08:17,169 --> 00:08:21,310
whether we throw an exception then

00:08:19,509 --> 00:08:22,960
whether it will write some lock try to

00:08:21,310 --> 00:08:25,419
give information to the customer in some

00:08:22,960 --> 00:08:31,990
way but at least it should not come into

00:08:25,419 --> 00:08:35,289
the car so our task as developers us how

00:08:31,990 --> 00:08:37,620
can we write the code that does these

00:08:35,289 --> 00:08:37,620
steps

00:08:37,660 --> 00:08:44,000
how do we do that we have several

00:08:40,820 --> 00:08:46,490
possibilities we have plain SQL works

00:08:44,000 --> 00:08:48,200
fine and if we want to start playing

00:08:46,490 --> 00:08:50,270
around with that that's always a good

00:08:48,200 --> 00:08:52,460
choice I'm just playing around with the

00:08:50,270 --> 00:08:55,880
database to be able that that's really a

00:08:52,460 --> 00:08:58,580
sensible way of doing that we can do

00:08:55,880 --> 00:09:02,600
that in the car so sequel alchemy calm

00:08:58,580 --> 00:09:05,420
modern witches closely resembles the

00:09:02,600 --> 00:09:08,990
sequel alchemy and where we have here

00:09:05,420 --> 00:09:13,010
orders stage this is a sequel alchemy

00:09:08,990 --> 00:09:15,770
meter data object which contains the

00:09:13,010 --> 00:09:18,500
information about the stage table for

00:09:15,770 --> 00:09:20,630
the orders we issue an update statement

00:09:18,500 --> 00:09:22,730
and we say what are the values the

00:09:20,630 --> 00:09:26,510
values are that the strings reference

00:09:22,730 --> 00:09:29,360
column should be filled by a select and

00:09:26,510 --> 00:09:33,800
you want to select the IDS of the Corps

00:09:29,360 --> 00:09:37,610
table of the drinks where the external

00:09:33,800 --> 00:09:42,530
code of that car table equals the drinks

00:09:37,610 --> 00:09:45,110
name of the order stage and let me just

00:09:42,530 --> 00:09:47,660
go back to show it to you again here we

00:09:45,110 --> 00:09:50,330
want to make sure really that this ID

00:09:47,660 --> 00:09:54,200
gets into that column and that for

00:09:50,330 --> 00:09:57,470
exactly where these this name of drinks

00:09:54,200 --> 00:10:00,290
matches here the external code of the

00:09:57,470 --> 00:10:02,960
car so therefore okay this works fine

00:10:00,290 --> 00:10:06,890
that's a nice idea and I would say maybe

00:10:02,960 --> 00:10:09,740
would be the best for implementation we

00:10:06,890 --> 00:10:11,210
have slightly in our in the back of our

00:10:09,740 --> 00:10:13,070
hatch that we might get different

00:10:11,210 --> 00:10:15,740
customers with different models and we

00:10:13,070 --> 00:10:18,380
are thinking about what maybe it would

00:10:15,740 --> 00:10:20,630
be a good idea to look in the RM so that

00:10:18,380 --> 00:10:23,720
we are more flexible there we have here

00:10:20,630 --> 00:10:25,820
the the tables as objects and we have

00:10:23,720 --> 00:10:28,760
each grow as an object and it's much

00:10:25,820 --> 00:10:33,470
nicer to implement the stuff here we can

00:10:28,760 --> 00:10:36,500
loop over the orders we can grill we can

00:10:33,470 --> 00:10:39,950
query the table with the correct filters

00:10:36,500 --> 00:10:42,320
and update the table it works fine also

00:10:39,950 --> 00:10:44,360
but as we do here the single database

00:10:42,320 --> 00:10:46,100
access that might be not a good idea

00:10:44,360 --> 00:10:47,050
from a performance point of view when

00:10:46,100 --> 00:10:49,660
you really have

00:10:47,050 --> 00:10:51,790
customers but these are the things the

00:10:49,660 --> 00:10:56,440
tools we have attend at the moment so

00:10:51,790 --> 00:10:57,820
let's assume in our team we use that

00:10:56,440 --> 00:11:00,360
statement and we are really happy

00:10:57,820 --> 00:11:03,040
everything works fine we have great data

00:11:00,360 --> 00:11:09,190
customers happy our data scientists are

00:11:03,040 --> 00:11:12,070
happy everything's good now well as you

00:11:09,190 --> 00:11:15,220
can see it good or bad the customer is

00:11:12,070 --> 00:11:17,890
happy the pub and she tells the brewery

00:11:15,220 --> 00:11:19,000
about that so they are talking when

00:11:17,890 --> 00:11:21,550
they're getting a delivery and the

00:11:19,000 --> 00:11:23,380
brewery is quite excited because they

00:11:21,550 --> 00:11:24,970
say well that machine learning stuff

00:11:23,380 --> 00:11:28,329
were you read about that in the

00:11:24,970 --> 00:11:31,269
newspapers we are thinking about our

00:11:28,329 --> 00:11:33,610
brewery we have to some machines where

00:11:31,269 --> 00:11:36,310
we have the boilers and the fermenters

00:11:33,610 --> 00:11:38,589
and we have some sensors in there we

00:11:36,310 --> 00:11:43,180
measure some stuff like temperature and

00:11:38,589 --> 00:11:46,839
pressure and then must be some way to to

00:11:43,180 --> 00:11:48,880
find out I mean brewing and storing beer

00:11:46,839 --> 00:11:51,040
is quite a long process we want to know

00:11:48,880 --> 00:11:53,380
in the beginning what will be the

00:11:51,040 --> 00:11:55,720
quality of our beer in the end couldn't

00:11:53,380 --> 00:11:57,130
you help us with that and our data

00:11:55,720 --> 00:12:00,399
scientists are quite happy with that

00:11:57,130 --> 00:12:02,350
interesting new task and we just need to

00:12:00,399 --> 00:12:06,459
get the data into the system this can't

00:12:02,350 --> 00:12:09,670
be that complicated well looking at that

00:12:06,459 --> 00:12:12,640
statement here hmmm it might be we have

00:12:09,670 --> 00:12:16,089
to rewrite all that because there are

00:12:12,640 --> 00:12:19,060
different references between the between

00:12:16,089 --> 00:12:20,589
the categories may not have machines we

00:12:19,060 --> 00:12:21,880
now have sensors we now have

00:12:20,589 --> 00:12:26,230
measurements all are named differently

00:12:21,880 --> 00:12:27,790
and to make that customer happy we would

00:12:26,230 --> 00:12:30,550
have to rewrite that complete statement

00:12:27,790 --> 00:12:32,079
so it would work but when we look into

00:12:30,550 --> 00:12:34,630
the future and maybe they are more

00:12:32,079 --> 00:12:36,820
interested more in dress more

00:12:34,630 --> 00:12:40,810
interesting business domains then we

00:12:36,820 --> 00:12:42,850
might have really lots of work to do so

00:12:40,810 --> 00:12:49,180
what could be the solution we thought in

00:12:42,850 --> 00:12:51,430
our team and we sent well we could

00:12:49,180 --> 00:12:54,610
describe these things in a more abstract

00:12:51,430 --> 00:12:57,610
way we can say we have one business

00:12:54,610 --> 00:12:59,740
domain which is to pop at first and the

00:12:57,610 --> 00:13:01,420
pub consists of categories we have

00:12:59,740 --> 00:13:04,060
drinks with the orders and we have the

00:13:01,420 --> 00:13:06,520
visitors they consist of the elements

00:13:04,060 --> 00:13:08,860
well that's the external code that's a

00:13:06,520 --> 00:13:14,050
reference to drinks they have some types

00:13:08,860 --> 00:13:16,810
we need for the database and what is

00:13:14,050 --> 00:13:18,730
some of these elements are special we

00:13:16,810 --> 00:13:21,400
looked at that reference finding task

00:13:18,730 --> 00:13:23,440
and we have seen they need special

00:13:21,400 --> 00:13:27,010
processing and it would be good if you

00:13:23,440 --> 00:13:28,800
just could have a way to determine that

00:13:27,010 --> 00:13:32,020
these are special elements that we can

00:13:28,800 --> 00:13:34,630
inherit here from that element and we

00:13:32,020 --> 00:13:37,030
also have I mean each element has a name

00:13:34,630 --> 00:13:39,280
which we see in this year's we find and

00:13:37,030 --> 00:13:42,340
it has a name on the database which is

00:13:39,280 --> 00:13:45,520
well most cases to see as the name in

00:13:42,340 --> 00:13:48,130
capital letters but for this order

00:13:45,520 --> 00:13:50,530
drinks reference you had seen there's an

00:13:48,130 --> 00:13:53,380
additional field there's this name

00:13:50,530 --> 00:13:54,670
reference you remember in our reference

00:13:53,380 --> 00:13:57,730
finding step we wanted to fill that

00:13:54,670 --> 00:14:00,220
column in the stage table so we add this

00:13:57,730 --> 00:14:05,350
hearon a subclass and we say that this

00:14:00,220 --> 00:14:07,630
belongs to the category so what does

00:14:05,350 --> 00:14:10,390
that help us if we can do that I mean we

00:14:07,630 --> 00:14:12,190
also thought that somehow resembles a

00:14:10,390 --> 00:14:14,440
sequel alchemy model also I mean a

00:14:12,190 --> 00:14:17,740
sequel alchemy model also has some

00:14:14,440 --> 00:14:20,920
tables it has some elements it has some

00:14:17,740 --> 00:14:22,390
types it has foreign keys but the sequel

00:14:20,920 --> 00:14:23,890
alchemy model is for a database

00:14:22,390 --> 00:14:26,530
description it's not so much for an

00:14:23,890 --> 00:14:28,390
algorithmic processing of that stuff so

00:14:26,530 --> 00:14:31,120
therefore I will discuss that at the end

00:14:28,390 --> 00:14:35,380
we said it really makes sense to have

00:14:31,120 --> 00:14:37,690
this in a more abstractly how now does

00:14:35,380 --> 00:14:40,150
that look like I mean sequel alchemy

00:14:37,690 --> 00:14:42,490
also has powers us here in om for

00:14:40,150 --> 00:14:45,790
example we have the generic our imposter

00:14:42,490 --> 00:14:47,980
and we have here in the sequel economy

00:14:45,790 --> 00:14:49,450
model with our business domain and we

00:14:47,980 --> 00:14:52,180
have the business domain that is also

00:14:49,450 --> 00:14:53,860
described in the application so in both

00:14:52,180 --> 00:14:56,920
here we need to have that business

00:14:53,860 --> 00:15:00,130
domain what we wanted to do we wanted to

00:14:56,920 --> 00:15:01,810
factor out some knowledge of that so

00:15:00,130 --> 00:15:03,310
that this application does not need to

00:15:01,810 --> 00:15:05,490
know that the system and that we really

00:15:03,310 --> 00:15:09,010
can set the CN that domain model and

00:15:05,490 --> 00:15:11,110
that we can have specific task renderer

00:15:09,010 --> 00:15:12,050
so for reference finding we have here

00:15:11,110 --> 00:15:14,089
one render

00:15:12,050 --> 00:15:16,580
r which uses that information to

00:15:14,089 --> 00:15:19,910
generate sequel statements and we can

00:15:16,580 --> 00:15:23,420
have one for other tasks also how does

00:15:19,910 --> 00:15:26,810
it look like I will give you hear a code

00:15:23,420 --> 00:15:28,850
sample for that pup so we have here the

00:15:26,810 --> 00:15:31,339
domain the category the elements from

00:15:28,850 --> 00:15:34,220
our lingo package we have that pub which

00:15:31,339 --> 00:15:36,740
is a domain and that part consists of

00:15:34,220 --> 00:15:38,720
three categories the drinks the visitors

00:15:36,740 --> 00:15:41,060
and the orders that's quite easy to

00:15:38,720 --> 00:15:43,310
write down I mean there there's nothing

00:15:41,060 --> 00:15:46,250
more than you need and it's easily

00:15:43,310 --> 00:15:49,399
understandable the interesting stuff is

00:15:46,250 --> 00:15:53,750
here that reference which you see links

00:15:49,399 --> 00:15:55,880
directly to the drinks having that how

00:15:53,750 --> 00:15:59,420
does that task specific renderer looks

00:15:55,880 --> 00:16:02,269
like so this is Python code which at

00:15:59,420 --> 00:16:04,820
first checks for each category what are

00:16:02,269 --> 00:16:07,490
the references in there and we can just

00:16:04,820 --> 00:16:09,110
check that within its instance and we

00:16:07,490 --> 00:16:10,430
look over the references we have here

00:16:09,110 --> 00:16:12,279
just one but there might be other

00:16:10,430 --> 00:16:14,750
categories where we have multiple ones

00:16:12,279 --> 00:16:16,600
we are getting the stage and Contra

00:16:14,750 --> 00:16:19,010
birds from the sequel alchemy metadata

00:16:16,600 --> 00:16:21,680
as you can see here we can find that by

00:16:19,010 --> 00:16:24,260
the name of the stage table we can find

00:16:21,680 --> 00:16:27,170
the reference card table and we issue an

00:16:24,260 --> 00:16:28,940
update statement so this update

00:16:27,170 --> 00:16:32,290
statement here you see update the stage

00:16:28,940 --> 00:16:35,000
with what well use these values are

00:16:32,290 --> 00:16:37,399
constructed and Emma Kelly so because we

00:16:35,000 --> 00:16:39,709
cannot give here the keyword arguments

00:16:37,399 --> 00:16:41,600
dynamically we construct the diktat

00:16:39,709 --> 00:16:43,760
first and this is here the update

00:16:41,600 --> 00:16:45,350
with the keyword values and you see here

00:16:43,760 --> 00:16:47,779
that's the column which should be

00:16:45,350 --> 00:16:49,520
updated and this is a sequel alchemy

00:16:47,779 --> 00:16:53,420
cause statement on how to update that

00:16:49,520 --> 00:16:56,630
with what name so we print that I will

00:16:53,420 --> 00:17:02,149
show in the demo and then we can execute

00:16:56,630 --> 00:17:04,640
that so now let's switch to that you can

00:17:02,149 --> 00:17:06,470
see that this really works what are

00:17:04,640 --> 00:17:10,760
prepared in the demo is a simple as you

00:17:06,470 --> 00:17:17,860
let light database and I have prepared

00:17:10,760 --> 00:17:17,860
some script no that's quite

00:17:20,819 --> 00:17:26,110
do it that way okay great so at the

00:17:24,399 --> 00:17:28,209
moment we do not have to see polite

00:17:26,110 --> 00:17:31,749
database you'll see here these tables do

00:17:28,209 --> 00:17:35,889
not exist at all and what we want to do

00:17:31,749 --> 00:17:37,749
we want to create them we do that by

00:17:35,889 --> 00:17:42,700
calling our Python script create

00:17:37,749 --> 00:17:45,100
database and these tables are there you

00:17:42,700 --> 00:17:46,749
can see here by the way we have a

00:17:45,100 --> 00:17:48,369
configuration file but we'll see what's

00:17:46,749 --> 00:17:51,039
the database and what does our business

00:17:48,369 --> 00:17:55,629
domain so now we need to get data in

00:17:51,039 --> 00:17:59,019
there so we've contact I transcript we

00:17:55,629 --> 00:18:04,299
do the CSV import we do that at first

00:17:59,019 --> 00:18:06,129
for the drinks category and you see here

00:18:04,299 --> 00:18:08,950
that's the sequel statement created from

00:18:06,129 --> 00:18:15,240
that and that's here in the category so

00:18:08,950 --> 00:18:17,980
now we do that for the orders also and

00:18:15,240 --> 00:18:19,389
you see it's in here now we want to do

00:18:17,980 --> 00:18:22,389
the reference finding and for sure

00:18:19,389 --> 00:18:24,190
before we find that references the order

00:18:22,389 --> 00:18:28,360
the drinks need to get into the car

00:18:24,190 --> 00:18:30,279
otherwise it doesn't make sense so what

00:18:28,360 --> 00:18:32,529
do we do we are calling the core load

00:18:30,279 --> 00:18:35,769
script and reading that at first for the

00:18:32,529 --> 00:18:38,950
drinks you see here that is to generate

00:18:35,769 --> 00:18:42,580
a sequel statement and this is the corn

00:18:38,950 --> 00:18:47,399
and you see that that drinks ref column

00:18:42,580 --> 00:18:50,259
is empty so now for the most interesting

00:18:47,399 --> 00:18:52,929
you can see these SQL statements are

00:18:50,259 --> 00:18:55,240
issued and here you see that this is

00:18:52,929 --> 00:18:57,580
filled and also that the orders core is

00:18:55,240 --> 00:18:59,559
filled well it does not fit completely

00:18:57,580 --> 00:19:04,480
on the screen but you can see that it's

00:18:59,559 --> 00:19:07,059
all in there so that works fine that's

00:19:04,480 --> 00:19:10,149
great but that was a step we were

00:19:07,059 --> 00:19:13,090
already five so let's go thank you now

00:19:10,149 --> 00:19:15,730
let's go back and let's say we have to

00:19:13,090 --> 00:19:17,679
know another domain we have a brewery

00:19:15,730 --> 00:19:19,720
and the brewery we say it has machines

00:19:17,679 --> 00:19:22,570
it has sends us and it has measurements

00:19:19,720 --> 00:19:24,519
and that brewery here you can see it

00:19:22,570 --> 00:19:27,340
refer the census reference to machines

00:19:24,519 --> 00:19:29,169
and the measurements reference the

00:19:27,340 --> 00:19:29,900
sensors I would like to show that the

00:19:29,169 --> 00:19:31,480
demo also

00:19:29,900 --> 00:19:33,980
but unfortunately the timer's not

00:19:31,480 --> 00:19:36,050
sufficient for that but it's really as

00:19:33,980 --> 00:19:37,610
simple as we have seen it here you just

00:19:36,050 --> 00:19:39,620
need to change the conflict Jason you

00:19:37,610 --> 00:19:41,120
create the database and the new tables

00:19:39,620 --> 00:19:42,890
will be there and you can import the

00:19:41,120 --> 00:19:47,900
differences we fight this will be in

00:19:42,890 --> 00:19:52,070
there also so what does that mean when

00:19:47,900 --> 00:19:55,130
we say what does this domain model model

00:19:52,070 --> 00:19:58,340
help us well it is optimized for a high

00:19:55,130 --> 00:19:59,810
throughput as we you see this SQL

00:19:58,340 --> 00:20:02,330
statements that are issued there can be

00:19:59,810 --> 00:20:04,790
processed directly on the database so we

00:20:02,330 --> 00:20:07,100
put all things in the database into the

00:20:04,790 --> 00:20:09,830
stage and now we have some processing of

00:20:07,100 --> 00:20:11,510
our domain knowledge and will generate

00:20:09,830 --> 00:20:14,480
the sequel statements and the things

00:20:11,510 --> 00:20:16,420
will be processed on the database that's

00:20:14,480 --> 00:20:20,600
really good fit for analytical models

00:20:16,420 --> 00:20:23,510
when I when I thought about the demo

00:20:20,600 --> 00:20:25,190
here for the talk I found it might not

00:20:23,510 --> 00:20:27,200
that fit that well for transactional

00:20:25,190 --> 00:20:30,080
models where you have more complex n2m

00:20:27,200 --> 00:20:33,830
relations but for analytical models this

00:20:30,080 --> 00:20:35,630
is really great and helps a lot when I

00:20:33,830 --> 00:20:37,700
compare that to a sequel alchemy model

00:20:35,630 --> 00:20:39,470
which is also some kind of meta model

00:20:37,700 --> 00:20:41,990
then we see that the sequel alchemy is

00:20:39,470 --> 00:20:43,790
focused on a database description the

00:20:41,990 --> 00:20:47,750
domain model in contrast can contain

00:20:43,790 --> 00:20:50,150
more information in our team we had also

00:20:47,750 --> 00:20:53,060
the task that we have that we have

00:20:50,150 --> 00:20:55,820
time-dependent stuff so some drinks are

00:20:53,060 --> 00:20:57,710
only available at several days or maybe

00:20:55,820 --> 00:20:59,600
they were available last week but are

00:20:57,710 --> 00:21:01,490
not available this week and we need to

00:20:59,600 --> 00:21:03,470
check these crosstime dependencies also

00:21:01,490 --> 00:21:06,560
this can be done in the domain model

00:21:03,470 --> 00:21:08,630
also we can note that there and we can

00:21:06,560 --> 00:21:10,970
generate the sequel alchemy model out of

00:21:08,630 --> 00:21:16,250
the domain model so in that case we have

00:21:10,970 --> 00:21:17,750
both what is an additional bonus as we

00:21:16,250 --> 00:21:20,240
can use that to my model for much

00:21:17,750 --> 00:21:21,920
further stuff you can see here we can

00:21:20,240 --> 00:21:24,350
generate a sequel alchemy model we can

00:21:21,920 --> 00:21:26,270
generate a sequel for our tasks we have

00:21:24,350 --> 00:21:28,430
to csv loader configuration but also

00:21:26,270 --> 00:21:30,740
what we do we generate documentation out

00:21:28,430 --> 00:21:33,380
of that so how to fill that CSV tables

00:21:30,740 --> 00:21:35,630
and we continue our demo data and much

00:21:33,380 --> 00:21:39,530
more stuff but that's just to show you

00:21:35,630 --> 00:21:42,300
some ideas so that you are able also to

00:21:39,530 --> 00:21:45,630
have some questions I will close you

00:21:42,300 --> 00:21:48,230
and that's what I wanted to show you are

00:21:45,630 --> 00:21:48,230
there any questions

00:22:04,340 --> 00:22:11,419
right is a lingual library open source

00:22:07,970 --> 00:22:14,750
and available no this is something we

00:22:11,419 --> 00:22:16,549
developed internally I i mean what i did

00:22:14,750 --> 00:22:18,289
here for that chart i prepared a small

00:22:16,549 --> 00:22:22,010
demo application and i also thought

00:22:18,289 --> 00:22:25,760
about providing that but I've seen it it

00:22:22,010 --> 00:22:29,600
takes much stuff around to make that

00:22:25,760 --> 00:22:31,789
example some more sensible and yeah

00:22:29,600 --> 00:22:33,620
before making that open source we I

00:22:31,789 --> 00:22:36,559
would have to check also internally and

00:22:33,620 --> 00:22:38,390
our company and before going into that

00:22:36,559 --> 00:22:41,120
direction I just want to see see whether

00:22:38,390 --> 00:22:42,559
there's interest at all and that so if

00:22:41,120 --> 00:22:44,179
there are some questions to that or want

00:22:42,559 --> 00:22:51,140
to get some further updates which

00:22:44,179 --> 00:22:56,289
intentions talk after the shop any more

00:22:51,140 --> 00:22:56,289

YouTube URL: https://www.youtube.com/watch?v=iiclNoOd4ls


