Title: Dmitry Trofimov - Can Rust make Python shine?
Publication date: 2015-08-08
Playlist: EuroPython 2015
Description: 
	Dmitry Trofimov - Can Rust make Python shine?
[EuroPython 2015]
[20 July 2015]
[Bilbao, Euskadi, Spain]

Rust is a new programming language from Mozilla. It is fast, safe and
beautiful. It is also a very good option when needing performance. In
this talk we're going to look at Rust and see what it offers and how
we can leverage it as Python developers. And we'll do it with a case
study: a statistical profiler for Python.
Captions: 
	00:00:04,850 --> 00:00:10,679
okay let's start first I briefly

00:00:08,130 --> 00:00:13,830
introduce myself my name is Mitra chemo

00:00:10,679 --> 00:00:17,100
I work for JetBrains I am Tim leading

00:00:13,830 --> 00:00:19,230
developer of pycharm ID but today I

00:00:17,100 --> 00:00:20,699
won't be speaking about PyCharm in this

00:00:19,230 --> 00:00:22,430
talk if you want to discuss anything

00:00:20,699 --> 00:00:25,170
about pycharm control the brains booth

00:00:22,430 --> 00:00:26,880
by sham team will be there during all

00:00:25,170 --> 00:00:30,150
the conference ready to answer all your

00:00:26,880 --> 00:00:35,040
questions don't be shy

00:00:30,150 --> 00:00:37,200
mostly I develop in Java and Python Java

00:00:35,040 --> 00:00:41,399
has been my primary development language

00:00:37,200 --> 00:00:43,739
for many years and Python for me is more

00:00:41,399 --> 00:00:46,020
than a language that I use it's like a

00:00:43,739 --> 00:00:48,270
subject of constant investigation like a

00:00:46,020 --> 00:00:50,670
snake that I examine which therefore

00:00:48,270 --> 00:00:52,710
scales it hairs which teeth and what is

00:00:50,670 --> 00:00:56,489
inside of it how to debug it how to

00:00:52,710 --> 00:00:58,859
profile it and also I'm curious about

00:00:56,489 --> 00:01:01,649
new programming languages and how a year

00:00:58,859 --> 00:01:03,480
ago I started to play with rusty beet I

00:01:01,649 --> 00:01:06,450
knew nothing about it at that moment

00:01:03,480 --> 00:01:07,799
still I don't know much about it now but

00:01:06,450 --> 00:01:10,409
I hope that I will be able to introduce

00:01:07,799 --> 00:01:12,510
it to those who are not aware of it at

00:01:10,409 --> 00:01:17,400
all by the way who hope you have heard

00:01:12,510 --> 00:01:19,680
about rust that's pretty much how many

00:01:17,400 --> 00:01:22,950
of you have tried it already developed

00:01:19,680 --> 00:01:24,659
some stuff oh that's cool for those who

00:01:22,950 --> 00:01:26,460
have tried it it will be I hope will be

00:01:24,659 --> 00:01:30,930
also interesting because I will show

00:01:26,460 --> 00:01:35,909
some corner corner cases yes so what is

00:01:30,930 --> 00:01:39,780
known about rust yes and answering one

00:01:35,909 --> 00:01:41,880
more question why did I pick rust why

00:01:39,780 --> 00:01:45,899
why did I started to invest my time and

00:01:41,880 --> 00:01:50,040
learn it I found it interesting and also

00:01:45,899 --> 00:01:54,030
I wanted to develop profiler for Python

00:01:50,040 --> 00:01:58,009
and to make it work fast so ok I'll tell

00:01:54,030 --> 00:02:01,710
about it rust rust is Mozilla project

00:01:58,009 --> 00:02:05,329
and they actually are using it already

00:02:01,710 --> 00:02:08,489
for the new browser engine called server

00:02:05,329 --> 00:02:11,190
the project started in 2010 as a side

00:02:08,489 --> 00:02:12,060
project of Mozilla employee got great

00:02:11,190 --> 00:02:16,080
Anwar

00:02:12,060 --> 00:02:21,720
and the version 1 was released on May 15

00:02:16,080 --> 00:02:25,020
this year so now it is 1.1 and before

00:02:21,720 --> 00:02:29,360
version 1 things were changing very very

00:02:25,020 --> 00:02:32,519
high pace in rust breaking compatibility

00:02:29,360 --> 00:02:35,220
and now it's still changing standard

00:02:32,519 --> 00:02:36,660
library is not polished yet and the co

00:02:35,220 --> 00:02:39,930
system around it is just starting to

00:02:36,660 --> 00:02:42,239
emerge but now it's has backward

00:02:39,930 --> 00:02:45,900
compatibility and this allows to develop

00:02:42,239 --> 00:02:49,110
production applications in rust so what

00:02:45,900 --> 00:02:52,680
is the rust what did I know about it

00:02:49,110 --> 00:02:56,580
when I started to learn it what exactly

00:02:52,680 --> 00:02:59,549
captured my eye they told that it is

00:02:56,580 --> 00:03:02,250
fast prevents nearly all seek faults

00:02:59,549 --> 00:03:05,280
your aunty's thread safety close to the

00:03:02,250 --> 00:03:09,780
metal it has zero cost abstractions but

00:03:05,280 --> 00:03:12,150
imagine and type inference and that

00:03:09,780 --> 00:03:15,239
sounded very cool I thought it would be

00:03:12,150 --> 00:03:16,890
very interesting to learn it first I

00:03:15,239 --> 00:03:18,390
started to listen some talks on YouTube

00:03:16,890 --> 00:03:20,040
nothing became clear for them then I

00:03:18,390 --> 00:03:22,739
found some specification it turned out

00:03:20,040 --> 00:03:25,890
that it is already outdated the language

00:03:22,739 --> 00:03:29,400
had just changed and then I found rust

00:03:25,890 --> 00:03:32,040
book for all of you who's interested I

00:03:29,400 --> 00:03:34,530
recommend this book the starting point

00:03:32,040 --> 00:03:36,630
it's online and very well written and I

00:03:34,530 --> 00:03:38,340
don't think that a talk can help you to

00:03:36,630 --> 00:03:41,880
teach the language that's why today I

00:03:38,340 --> 00:03:43,500
won't explain basics of rust at all I

00:03:41,880 --> 00:03:45,590
don't have a goal to teach you the

00:03:43,500 --> 00:03:49,380
language but to give you a feeling of it

00:03:45,590 --> 00:03:53,100
ok so let's start with a small but real

00:03:49,380 --> 00:03:54,810
problem and as the spears main advantage

00:03:53,100 --> 00:03:58,560
of rust a little bit computational

00:03:54,810 --> 00:03:59,880
problem like computing primes so the

00:03:58,560 --> 00:04:01,980
problem is to compute prime numbers

00:03:59,880 --> 00:04:04,350
between 2 and n and the prime number is

00:04:01,980 --> 00:04:08,910
a number that has no divisors except

00:04:04,350 --> 00:04:10,230
itself and 1 so like 2 3 5 so on and we

00:04:08,910 --> 00:04:12,920
also how problem with the help of an

00:04:10,230 --> 00:04:15,269
algorithm called rapid conceive

00:04:12,920 --> 00:04:18,120
algorithm is simple the work with this

00:04:15,269 --> 00:04:22,680
way we first take all the numbers from 2

00:04:18,120 --> 00:04:24,400
to n and then iteratively throw away

00:04:22,680 --> 00:04:26,139
those who have divisors

00:04:24,400 --> 00:04:29,830
something like that we start to take -

00:04:26,139 --> 00:04:34,060
and then with away or events and then we

00:04:29,830 --> 00:04:36,669
proceed to the number three we take as a

00:04:34,060 --> 00:04:40,300
prime throw the multiples of three and

00:04:36,669 --> 00:04:42,430
then it will be five and all multiples

00:04:40,300 --> 00:04:43,290
of five are thrown away and seven and so

00:04:42,430 --> 00:04:46,240
on

00:04:43,290 --> 00:04:50,770
so here we see a Python implementation

00:04:46,240 --> 00:04:51,250
of offenseive it's quite beautiful isn't

00:04:50,770 --> 00:04:54,190
it

00:04:51,250 --> 00:04:56,320
here we initialize our non primes as a

00:04:54,190 --> 00:04:59,560
empty set and then we iterate through a

00:04:56,320 --> 00:05:02,139
range and if the current number is not

00:04:59,560 --> 00:05:05,110
in the set we increment our counter and

00:05:02,139 --> 00:05:06,970
update all the multiples we put it into

00:05:05,110 --> 00:05:10,419
the set of the non primes and then

00:05:06,970 --> 00:05:15,360
return it from the function okay so

00:05:10,419 --> 00:05:19,270
let's run it this is our function and

00:05:15,360 --> 00:05:21,610
also we have here main function which

00:05:19,270 --> 00:05:24,070
takes command line argument as n and

00:05:21,610 --> 00:05:32,169
then execute our function and prints

00:05:24,070 --> 00:05:36,000
output okay so it's something like okay

00:05:32,169 --> 00:05:41,289
so we have four between two and ten and

00:05:36,000 --> 00:05:41,950
for 100 we have something it seems to be

00:05:41,289 --> 00:05:46,090
correct

00:05:41,950 --> 00:05:48,580
okay let's measure the speed the time of

00:05:46,090 --> 00:05:51,460
this problem we will comment out the

00:05:48,580 --> 00:06:02,789
output because it's always slows down

00:05:51,460 --> 00:06:02,789
the execution and ok and for 1 million

00:06:03,300 --> 00:06:14,740
makes something like this one yes it's

00:06:11,940 --> 00:06:19,539
more than half a second it's pretty fast

00:06:14,740 --> 00:06:20,919
but what if our task is what we do care

00:06:19,539 --> 00:06:26,199
about speed what if our task is to

00:06:20,919 --> 00:06:29,520
implement the algorithm as efficient as

00:06:26,199 --> 00:06:32,740
possible one of the obvious solution

00:06:29,520 --> 00:06:34,330
solutions is to use C programming

00:06:32,740 --> 00:06:36,090
language because everyone knows that C's

00:06:34,330 --> 00:06:39,360
very fast Nazif

00:06:36,090 --> 00:06:41,130
and very well very good programs are

00:06:39,360 --> 00:06:44,040
written and see for example C Python I'd

00:06:41,130 --> 00:06:51,870
written on C so let's implement this

00:06:44,040 --> 00:06:55,620
algorithm and C so the problem now is a

00:06:51,870 --> 00:06:58,370
bit longer but it pretty much the same

00:06:55,620 --> 00:07:01,139
so we have our defense function

00:06:58,370 --> 00:07:03,270
unfortunately there is no set in the

00:07:01,139 --> 00:07:07,080
standardized and library of C so we use

00:07:03,270 --> 00:07:09,150
array of primes and we wear all items

00:07:07,080 --> 00:07:11,880
mark is 1 this means that is prime and

00:07:09,150 --> 00:07:16,500
when it's 0 it's not prime and then we

00:07:11,880 --> 00:07:21,720
iterate through it and if it's prime we

00:07:16,500 --> 00:07:24,720
increment our counter and then update of

00:07:21,720 --> 00:07:27,300
the multiples of 0 and then we put our

00:07:24,720 --> 00:07:29,280
array into the result structure and

00:07:27,300 --> 00:07:33,389
unfortunately there is no T of tuples in

00:07:29,280 --> 00:07:38,580
in C so we need to have this result

00:07:33,389 --> 00:07:44,419
structure which holds a counter and how

00:07:38,580 --> 00:07:48,419
array so when here we execute it and

00:07:44,419 --> 00:07:52,560
bring the counter and then we want to

00:07:48,419 --> 00:07:55,320
print all the primes we first put them

00:07:52,560 --> 00:07:58,140
into there another array which is the

00:07:55,320 --> 00:08:00,720
length of of the counter so we iterate

00:07:58,140 --> 00:08:05,610
again we put them and then we print them

00:08:00,720 --> 00:08:10,940
so it looks quite quite similar so we

00:08:05,610 --> 00:08:10,940
need to compile this

00:08:14,110 --> 00:08:25,580
and we run it for ten okay it works

00:08:22,580 --> 00:08:30,770
correct now we run it for hundred whoops

00:08:25,580 --> 00:08:35,240
and we have segmentation fault anybody

00:08:30,770 --> 00:08:40,300
knows where the error is yeah I know

00:08:35,240 --> 00:08:45,709
that it's difficult but let's see it it

00:08:40,300 --> 00:08:48,200
managed to print the count of primes

00:08:45,709 --> 00:08:50,450
so probably the earth somewhere here

00:08:48,200 --> 00:08:55,520
let's examine those lines again so we

00:08:50,450 --> 00:08:58,220
have all primes array and wishes the

00:08:55,520 --> 00:09:04,400
length of the total primes and then we

00:08:58,220 --> 00:09:08,300
trade through our first primes array and

00:09:04,400 --> 00:09:12,140
if the number is prime we increment this

00:09:08,300 --> 00:09:14,330
counter and put it here so probably we

00:09:12,140 --> 00:09:16,040
could think that we have we go out of

00:09:14,330 --> 00:09:21,790
range here but it's impossible because

00:09:16,040 --> 00:09:24,410
we start from zero and we increment it

00:09:21,790 --> 00:09:28,700
with the same condition where we

00:09:24,410 --> 00:09:32,810
incremented here when this is true so it

00:09:28,700 --> 00:09:35,330
shouldn't go out of the range and here

00:09:32,810 --> 00:09:39,440
we just print the data out of the array

00:09:35,330 --> 00:09:41,750
what is the problem and actually that's

00:09:39,440 --> 00:09:44,600
that kind of kind of problem that could

00:09:41,750 --> 00:09:46,310
be called like a beautiful journey in C

00:09:44,600 --> 00:09:50,089
because you have no idea what's going on

00:09:46,310 --> 00:09:53,200
and I'll tell you what's the problem the

00:09:50,089 --> 00:09:58,700
problem is not here but the problem is

00:09:53,200 --> 00:10:00,800
here because when we returned our prime

00:09:58,700 --> 00:10:03,800
sarey we thought that we are returning

00:10:00,800 --> 00:10:07,150
array but actually what we do in C is

00:10:03,800 --> 00:10:09,529
that we return the pointer to this array

00:10:07,150 --> 00:10:13,880
so this is a pointer to array it's not

00:10:09,529 --> 00:10:15,830
array itself and array was allocated in

00:10:13,880 --> 00:10:20,300
the beginning of the function on the

00:10:15,830 --> 00:10:22,630
stack and actually it was valid only in

00:10:20,300 --> 00:10:26,850
the scope of the function and when we

00:10:22,630 --> 00:10:30,170
after we returned the pointer to this

00:10:26,850 --> 00:10:31,470
arrey and we go out of the scope

00:10:30,170 --> 00:10:34,920
disarray

00:10:31,470 --> 00:10:39,089
it's it's just no more it has ceased to

00:10:34,920 --> 00:10:42,870
be in it it expired and gone to meet its

00:10:39,089 --> 00:10:46,230
maker so and we still have a pointer to

00:10:42,870 --> 00:10:48,000
do it and that is the problem very

00:10:46,230 --> 00:10:51,569
common for C programmers so that's

00:10:48,000 --> 00:10:53,550
called a dangling pointer the pointer

00:10:51,569 --> 00:10:59,160
that points to Nome where to some random

00:10:53,550 --> 00:11:03,050
some random memory and that's why we get

00:10:59,160 --> 00:11:03,050
it would have a segmentation fault here

00:11:08,240 --> 00:11:14,040
so our task was to get our primes as

00:11:12,240 --> 00:11:17,449
fast as possible solution was implement

00:11:14,040 --> 00:11:20,190
and seed but this is not a solution I

00:11:17,449 --> 00:11:22,920
know that there are programs implemented

00:11:20,190 --> 00:11:25,980
in c and probably there are people who

00:11:22,920 --> 00:11:28,589
are convenient with c and who know how

00:11:25,980 --> 00:11:31,259
to use c efficiently and probably they

00:11:28,589 --> 00:11:34,680
don't make such errors but something

00:11:31,259 --> 00:11:37,680
still tells me that sometimes they do

00:11:34,680 --> 00:11:40,050
and i personally after years of java and

00:11:37,680 --> 00:11:42,600
python just can't imagine how to live in

00:11:40,050 --> 00:11:47,759
the world where you can suddenly become

00:11:42,600 --> 00:11:52,110
a pointer to random data in memory so

00:11:47,759 --> 00:11:56,209
let's carry on to rust finally let's

00:11:52,110 --> 00:11:56,209
implement the same in rust

00:12:10,020 --> 00:12:20,190
what will what we will do now is just to

00:12:16,100 --> 00:12:25,110
re-implement our c program but in rust

00:12:20,190 --> 00:12:28,070
and we will see how rust compiler

00:12:25,110 --> 00:12:28,070
handles this situation

00:12:36,900 --> 00:12:43,920
so here we have our C program and here

00:12:41,850 --> 00:12:44,940
we have quite the same Russ program if

00:12:43,920 --> 00:12:46,560
you don't understand

00:12:44,940 --> 00:12:49,640
little synthase details it doesn't

00:12:46,560 --> 00:12:58,160
matter because I just want you to to

00:12:49,640 --> 00:13:00,510
understand one basic concept for example

00:12:58,160 --> 00:13:04,860
what we do here we have the same

00:13:00,510 --> 00:13:08,190
structure and actually it denotes the

00:13:04,860 --> 00:13:12,150
same as in c we have counter that is

00:13:08,190 --> 00:13:16,710
integer and this is the the pointer the

00:13:12,150 --> 00:13:20,070
pointer to array there is no pointers in

00:13:16,710 --> 00:13:24,690
rust but these denotes like it's called

00:13:20,070 --> 00:13:26,790
slice in rust so it doesn't hold the

00:13:24,690 --> 00:13:30,000
data it doesn't hold the data it just

00:13:26,790 --> 00:13:32,339
points to some data external for that

00:13:30,000 --> 00:13:35,370
structure so it's actually the same as

00:13:32,339 --> 00:13:39,270
you can see and that here we allocate

00:13:35,370 --> 00:13:43,700
how vector initialize it and Twitter 8

00:13:39,270 --> 00:13:47,250
and we increment the counter then we do

00:13:43,700 --> 00:13:49,490
the same as in C and here we return our

00:13:47,250 --> 00:13:53,839
vector as a slice

00:13:49,490 --> 00:13:53,839
ok so let's compile that

00:13:58,910 --> 00:14:13,170
oops I messed up with typing yes and we

00:14:08,490 --> 00:14:16,680
have compilation error and Ross compiler

00:14:13,170 --> 00:14:21,600
tells us that primes does not live long

00:14:16,680 --> 00:14:23,760
enough so what it tells us that exactly

00:14:21,600 --> 00:14:26,640
what we have here that hey man you

00:14:23,760 --> 00:14:29,040
cannot compile that I won't allow you

00:14:26,640 --> 00:14:31,350
because you just want to return the

00:14:29,040 --> 00:14:33,630
pointer to the memory that will expire

00:14:31,350 --> 00:14:39,029
after we leave the context of this

00:14:33,630 --> 00:14:42,060
function and actually the this seems to

00:14:39,029 --> 00:14:45,930
be very strict but what is better to get

00:14:42,060 --> 00:14:49,440
this error just in time the first run

00:14:45,930 --> 00:14:52,890
your program or to debug some mysterious

00:14:49,440 --> 00:14:56,790
simulation fold just in the weeks after

00:14:52,890 --> 00:15:01,080
you deployed your program on to your

00:14:56,790 --> 00:15:06,360
users for example I think this is much

00:15:01,080 --> 00:15:08,570
better but let's let's run it let's make

00:15:06,360 --> 00:15:15,060
it work

00:15:08,570 --> 00:15:15,930
we won't fix this exact copy because it

00:15:15,060 --> 00:15:18,420
doesn't make sense

00:15:15,930 --> 00:15:21,120
instead of that we just really meant it

00:15:18,420 --> 00:15:25,770
from scratch in more a dramatic rust

00:15:21,120 --> 00:15:27,810
because the rust has set and it has to

00:15:25,770 --> 00:15:32,420
pose like Python so we have much shorter

00:15:27,810 --> 00:15:36,320
solution and it resembles us Python and

00:15:32,420 --> 00:15:36,320
okay let's run it

00:15:47,470 --> 00:16:01,510
okay and for 1 million something like so

00:15:55,180 --> 00:16:05,730
yes it's 20 milliseconds so it's like 25

00:16:01,510 --> 00:16:05,730
or 30 times faster than Python

00:16:12,800 --> 00:16:20,720
and the concept that that helped Roth

00:16:17,360 --> 00:16:23,089
compiler to to reduce the error that we

00:16:20,720 --> 00:16:27,369
had is called life times if you are

00:16:23,089 --> 00:16:33,529
interested about it read book so

00:16:27,369 --> 00:16:38,540
concluding our comparison Python is 25

00:16:33,529 --> 00:16:41,329
times slower than rust and C doesn't

00:16:38,540 --> 00:16:43,579
work just but so rust is fast and safe

00:16:41,329 --> 00:16:46,639
but that is exactly what they told us in

00:16:43,579 --> 00:16:48,769
the beginning nothing new and returning

00:16:46,639 --> 00:16:55,670
to our main topic can rust to make my

00:16:48,769 --> 00:16:57,319
passing shine yes but if you search in

00:16:55,670 --> 00:16:59,299
the internet about communication between

00:16:57,319 --> 00:17:00,589
rust and Python you'll quickly find some

00:16:59,299 --> 00:17:03,350
tutorials about foreign function

00:17:00,589 --> 00:17:08,750
interface --is millions you will even

00:17:03,350 --> 00:17:12,709
find examples like this these examples

00:17:08,750 --> 00:17:16,010
are quite clear and simple and they work

00:17:12,709 --> 00:17:20,689
if you try so this allows you to call

00:17:16,010 --> 00:17:24,889
rust code from your Python code but it's

00:17:20,689 --> 00:17:26,929
not enough what if I want to access the

00:17:24,889 --> 00:17:29,240
PI's internals from rust what if I want

00:17:26,929 --> 00:17:31,820
convert vital string objects to rust

00:17:29,240 --> 00:17:34,100
drink what if I want to return a complex

00:17:31,820 --> 00:17:35,870
object from rust but what if I want to

00:17:34,100 --> 00:17:42,320
make rust library in portable as the

00:17:35,870 --> 00:17:45,529
model implies and actually that is what

00:17:42,320 --> 00:17:46,789
is needed in real applications for

00:17:45,529 --> 00:17:49,250
example a Python profiler

00:17:46,789 --> 00:17:55,039
by the way hope you have ever used the

00:17:49,250 --> 00:17:58,190
profiler for Python that's cool mmm but

00:17:55,039 --> 00:18:01,309
for those of you who hadn't tell what

00:17:58,190 --> 00:18:03,049
profile is profiler is a program that

00:18:01,309 --> 00:18:06,220
measures frequency and duration of

00:18:03,049 --> 00:18:08,510
function calls of another program and

00:18:06,220 --> 00:18:11,960
normally the last of her health has the

00:18:08,510 --> 00:18:14,450
better so let's make a Python profile

00:18:11,960 --> 00:18:18,380
and rust and to see how it goes actually

00:18:14,450 --> 00:18:20,149
what that was my initial idea idea when

00:18:18,380 --> 00:18:23,730
I started to experiment with rust to try

00:18:20,149 --> 00:18:26,460
to make for example a simple tiny

00:18:23,730 --> 00:18:29,580
while there are two major types of

00:18:26,460 --> 00:18:32,940
profilers tracing profilers and sampling

00:18:29,580 --> 00:18:35,910
profilers also called statistical

00:18:32,940 --> 00:18:38,880
performers and statistical profilers

00:18:35,910 --> 00:18:41,340
they periodically capture frames of

00:18:38,880 --> 00:18:42,780
running program and normally it has less

00:18:41,340 --> 00:18:46,050
overhead and tracing profiler which

00:18:42,780 --> 00:18:47,910
traces all calls on the program let's

00:18:46,050 --> 00:18:51,180
see how to prevent statistical profile

00:18:47,910 --> 00:18:53,100
and rust but here we won't go step by

00:18:51,180 --> 00:18:56,460
step implement all the problem because

00:18:53,100 --> 00:18:58,950
we don't have so much time we will just

00:18:56,460 --> 00:19:00,570
focus on two important aspects and maybe

00:18:58,950 --> 00:19:06,770
we'll learn something along the way and

00:19:00,570 --> 00:19:10,350
the aspects are periodically and frames

00:19:06,770 --> 00:19:13,160
so how to run tasks periodically there

00:19:10,350 --> 00:19:15,810
is not no time in rust and a library yet

00:19:13,160 --> 00:19:18,690
but there is a wonderful library called

00:19:15,810 --> 00:19:22,550
me on metal IO mu is a lightweight

00:19:18,690 --> 00:19:24,540
library providing effectively different

00:19:22,550 --> 00:19:29,780
operational system abstractions like

00:19:24,540 --> 00:19:32,850
diamond and we just create a event loop

00:19:29,780 --> 00:19:36,600
set up at time an event in it and then

00:19:32,850 --> 00:19:38,970
we run a new thread and we pass the our

00:19:36,600 --> 00:19:43,320
event handler and what is interesting

00:19:38,970 --> 00:19:46,230
here is an event handler our handler

00:19:43,320 --> 00:19:49,170
will capture frames and save them to

00:19:46,230 --> 00:19:52,920
statistics map that is a sampler object

00:19:49,170 --> 00:19:54,810
that we created called sample and as our

00:19:52,920 --> 00:19:56,910
timer works in a separate thread that

00:19:54,810 --> 00:19:58,580
means that our sampler is a resource

00:19:56,910 --> 00:20:00,500
that are shared between different

00:19:58,580 --> 00:20:05,730
threads

00:20:00,500 --> 00:20:08,240
so it's shared mutable resource which is

00:20:05,730 --> 00:20:11,580
believed to be very dangerous

00:20:08,240 --> 00:20:15,330
as everybody knows that shared interval

00:20:11,580 --> 00:20:18,270
state is the root of all evil but not in

00:20:15,330 --> 00:20:20,790
rust rust grant gives you a safe shared

00:20:18,270 --> 00:20:25,590
beautiful state which sounds like a lie

00:20:20,790 --> 00:20:29,010
but it's true what we do is we just put

00:20:25,590 --> 00:20:31,170
our sampler into mutex a mutual

00:20:29,010 --> 00:20:34,470
exclusion primitive useful for protected

00:20:31,170 --> 00:20:36,750
protecting shared data when you create a

00:20:34,470 --> 00:20:39,030
mutex you transfer ownership

00:20:36,750 --> 00:20:42,030
the data into the music's immediately

00:20:39,030 --> 00:20:44,549
given up the access to it and then any

00:20:42,030 --> 00:20:47,460
access to the data through the mutex

00:20:44,549 --> 00:20:50,880
will block threats waiting for the log

00:20:47,460 --> 00:20:54,210
to became available thus making the data

00:20:50,880 --> 00:20:59,640
accessible only through them through the

00:20:54,210 --> 00:21:01,460
mutex by one thread at a time and to

00:20:59,640 --> 00:21:04,770
pass the reference to another thread we

00:21:01,460 --> 00:21:06,570
wrap it with the air sea our sea

00:21:04,770 --> 00:21:09,539
provides reference counting through

00:21:06,570 --> 00:21:12,200
atomic operations and it's also safe

00:21:09,539 --> 00:21:15,900
between threads and having done all that

00:21:12,200 --> 00:21:19,429
rust compiler guarantees us that we

00:21:15,900 --> 00:21:23,549
won't have any race conditions never

00:21:19,429 --> 00:21:28,740
it's just impossible and not having done

00:21:23,549 --> 00:21:31,890
that well you can't access that object

00:21:28,740 --> 00:21:34,400
from different threads as compiler won't

00:21:31,890 --> 00:21:37,830
allow you to do that it won't allow you

00:21:34,400 --> 00:21:39,960
even to pass this mutable data to

00:21:37,830 --> 00:21:41,750
another thread so it will be single

00:21:39,960 --> 00:21:44,280
thread users only

00:21:41,750 --> 00:21:48,150
so compile the grant gives you that you

00:21:44,280 --> 00:21:51,330
your program will work and to understand

00:21:48,150 --> 00:21:57,120
this better read about ownership and

00:21:51,330 --> 00:21:59,730
rust so capturing current frame for

00:21:57,120 --> 00:22:02,580
simplicity will capture only current

00:21:59,730 --> 00:22:05,250
execution line as we are not interested

00:22:02,580 --> 00:22:07,890
in in call three at the moment there are

00:22:05,250 --> 00:22:10,860
three pieces of information a file name

00:22:07,890 --> 00:22:15,919
function name and line number that we

00:22:10,860 --> 00:22:15,919
will collect at every tick of our timer

00:22:16,730 --> 00:22:24,000
in Python there is a function in modules

00:22:20,610 --> 00:22:26,580
fees that is called current frame under

00:22:24,000 --> 00:22:29,190
the hood use function by thread current

00:22:26,580 --> 00:22:34,620
frames looking into the cpython

00:22:29,190 --> 00:22:36,539
internals we will find out that the

00:22:34,620 --> 00:22:40,020
structure that we need is called

00:22:36,539 --> 00:22:41,700
actually underscore frame so we have

00:22:40,020 --> 00:22:46,200
this underscore frame structure that

00:22:41,700 --> 00:22:49,679
points to some to some byte code object

00:22:46,200 --> 00:22:50,200
that we also need and what we need now

00:22:49,679 --> 00:22:53,650
we

00:22:50,200 --> 00:22:55,120
to convert its some somehow from from C

00:22:53,650 --> 00:22:59,410
structure to Russ structure to be able

00:22:55,120 --> 00:23:03,240
to use it in rust and that could be

00:22:59,410 --> 00:23:06,340
sometimes hard because some C types are

00:23:03,240 --> 00:23:10,930
not very obvious how to map to rust

00:23:06,340 --> 00:23:13,060
types there is no no no strict mapping

00:23:10,930 --> 00:23:16,150
no direct meeting because they are just

00:23:13,060 --> 00:23:18,970
absent in dramatic rust so there are

00:23:16,150 --> 00:23:22,870
special rust types for that to fulfill

00:23:18,970 --> 00:23:26,730
that gap for example C void is analog of

00:23:22,870 --> 00:23:33,520
void and asterisk mute is a special type

00:23:26,730 --> 00:23:37,930
that reflects see pointers and normally

00:23:33,520 --> 00:23:40,180
there is now in rust at all but to check

00:23:37,930 --> 00:23:46,090
this row pointer so we have special

00:23:40,180 --> 00:23:50,830
method is now so knowing that we write

00:23:46,090 --> 00:23:56,140
our code and remember that when one tiny

00:23:50,830 --> 00:23:58,360
thing which is important when you call

00:23:56,140 --> 00:24:01,180
in C function or using row pointer a

00:23:58,360 --> 00:24:03,790
rough can't guarantee safety anymore all

00:24:01,180 --> 00:24:08,680
such expressions should be within unsafe

00:24:03,790 --> 00:24:11,230
block and I think that is what they mean

00:24:08,680 --> 00:24:14,800
when they say that rust prevents nearly

00:24:11,230 --> 00:24:16,810
all sig fault because the world nearly

00:24:14,800 --> 00:24:19,600
means that it doesn't prevent stick

00:24:16,810 --> 00:24:25,330
false and say block when you work with C

00:24:19,600 --> 00:24:28,690
code so knowing this mapping knowing how

00:24:25,330 --> 00:24:33,100
to use and safe locks we just create our

00:24:28,690 --> 00:24:37,570
structures and rust and since that we

00:24:33,100 --> 00:24:42,400
are very close there is everything that

00:24:37,570 --> 00:24:45,490
what we need but how to convert Python

00:24:42,400 --> 00:24:47,710
string to a rust ring funny but that was

00:24:45,490 --> 00:24:53,680
nearly the hardest problem I faced

00:24:47,710 --> 00:24:55,060
because actually it was difficult and at

00:24:53,680 --> 00:25:00,850
some point I came up with something like

00:24:55,060 --> 00:25:03,530
this so it's just to convert the Python

00:25:00,850 --> 00:25:10,880
string to the rust wrinkles last line

00:25:03,530 --> 00:25:12,860
and it did work sometimes it didn't

00:25:10,880 --> 00:25:14,810
handle some differences between white

00:25:12,860 --> 00:25:17,840
strings and unicode strings and I was

00:25:14,810 --> 00:25:21,080
already already started to implement

00:25:17,840 --> 00:25:23,060
that but then I came across a library

00:25:21,080 --> 00:25:25,640
called trusty Python by Daniel Boone

00:25:23,060 --> 00:25:29,570
Walton and my life became much more

00:25:25,640 --> 00:25:31,610
easier that is a beautiful library and I

00:25:29,570 --> 00:25:34,430
highly recommend it actually it appeared

00:25:31,610 --> 00:25:37,910
that the most things that I needed to

00:25:34,430 --> 00:25:42,920
communicate Rustin Python was there I

00:25:37,910 --> 00:25:45,350
only need to to add some details for my

00:25:42,920 --> 00:25:50,000
specific case and also it's very good

00:25:45,350 --> 00:25:52,810
example of thrust code for example a

00:25:50,000 --> 00:25:58,250
string conversion using this library

00:25:52,810 --> 00:26:00,830
looks like that and also it handles all

00:25:58,250 --> 00:26:03,980
the cases with Unicode doing

00:26:00,830 --> 00:26:06,590
representation and also it provides very

00:26:03,980 --> 00:26:10,100
very important abstractions like a

00:26:06,590 --> 00:26:16,790
special log correspondent to the global

00:26:10,100 --> 00:26:19,040
interpreter lock and Python yes and this

00:26:16,790 --> 00:26:23,170
is this is how you can expose your

00:26:19,040 --> 00:26:27,080
native rust library at the Python model

00:26:23,170 --> 00:26:30,020
using using the rust mattresses it's

00:26:27,080 --> 00:26:34,580
amazing they read the sources it's very

00:26:30,020 --> 00:26:36,260
very cool written so it's just this line

00:26:34,580 --> 00:26:38,830
there are a lot of more under the hood

00:26:36,260 --> 00:26:46,700
and they are very interesting

00:26:38,830 --> 00:26:52,550
so enough it was much code and much very

00:26:46,700 --> 00:26:56,120
much details but I'm a Finnish team now

00:26:52,550 --> 00:26:59,140
as we have couple means let's see how

00:26:56,120 --> 00:26:59,140
our profiler works

00:27:05,610 --> 00:27:08,790
stupid name

00:27:09,870 --> 00:27:12,770
so

00:27:25,520 --> 00:27:33,550
so we're profiling this offense that way

00:27:28,940 --> 00:27:42,380
that we have written at the first time

00:27:33,550 --> 00:27:44,660
okay that's not interesting we need wow

00:27:42,380 --> 00:27:49,130
I thought that it will happen at some

00:27:44,660 --> 00:27:54,920
point it's impossible to make life demo

00:27:49,130 --> 00:28:11,410
without fails yeah

00:27:54,920 --> 00:28:11,410
so we comment out our print okay

00:28:19,640 --> 00:28:24,820
okay it's very simple now it's very

00:28:22,790 --> 00:28:29,120
basic but what about it tells us that

00:28:24,820 --> 00:28:37,750
the 85% of our time banned in the light

00:28:29,120 --> 00:28:37,750
eight and 14% and light seven actually

00:28:38,080 --> 00:28:47,120
nearly 1% was for output of this line

00:28:41,990 --> 00:28:49,640
so line eight is this one so what we are

00:28:47,120 --> 00:28:54,679
doing here is we updating our set in

00:28:49,640 --> 00:28:56,150
array and what we are doing here 15:14

00:28:54,679 --> 00:28:57,679
percent is we're incrementing the

00:28:56,150 --> 00:29:01,690
counter inside the array

00:28:57,679 --> 00:29:11,299
it looks believable so it looks very

00:29:01,690 --> 00:29:14,570
very logical yes and if you still care

00:29:11,299 --> 00:29:17,210
about performance in your Python

00:29:14,570 --> 00:29:19,630
applications but you don't want to dig

00:29:17,210 --> 00:29:22,340
that deep into the native code I

00:29:19,630 --> 00:29:23,809
recommend you to listen to the talk of

00:29:22,340 --> 00:29:28,900
my colleague Katrina Lucifer

00:29:23,809 --> 00:29:35,350
that will take place on 23rd of July and

00:29:28,900 --> 00:29:39,770
Thursday she will show you how to write

00:29:35,350 --> 00:29:44,440
performant Python code without using any

00:29:39,770 --> 00:29:44,440
C or rust thank you for your attention

00:29:49,300 --> 00:30:07,420
questions is it possible to distribute

00:30:03,760 --> 00:30:12,010
rust code as a Python package style

00:30:07,420 --> 00:30:16,240
which can be installed using people yes

00:30:12,010 --> 00:30:21,310
I've came across a little library that

00:30:16,240 --> 00:30:24,520
allows you easy Li to write your setup

00:30:21,310 --> 00:30:27,040
dot pi this way that it will compile

00:30:24,520 --> 00:30:29,800
your host code if you have frost compile

00:30:27,040 --> 00:30:31,720
that installed maybe it even downloads

00:30:29,800 --> 00:30:34,570
it I don't know I never tried it I

00:30:31,720 --> 00:30:38,520
wanted to try it but had no time before

00:30:34,570 --> 00:30:42,460
and you just type setup setup your PI

00:30:38,520 --> 00:30:45,250
builder install and it builds your rust

00:30:42,460 --> 00:30:48,370
from scratch like for see the type PI

00:30:45,250 --> 00:30:50,410
allows you to install six tensions so

00:30:48,370 --> 00:30:52,830
there is library that allows it for us

00:30:50,410 --> 00:30:52,830
also

00:30:58,460 --> 00:31:05,679

YouTube URL: https://www.youtube.com/watch?v=weAxEoEfl0M


