Title: Stephan Jaensch - Building mobile APIs with services at Yelp
Publication date: 2015-08-08
Playlist: EuroPython 2015
Description: 
	Stephan Jaensch - Building mobile APIs with services at Yelp
[EuroPython 2015]
[21 July 2015]
[Bilbao, Euskadi, Spain]

At Yelp, we ship code multiple times a day and have maintained this
pace as our team has grown to 300+ and our codebase to several million
lines of Python code. This talk explores the pain points we
experienced along the ways, how our service-oriented architecture
alleviates them, and the infrastructure we built to develop, test, and
deploy in this highly-distributed environment. As a case study, we’ll
be looking at the backend powering the new Yelp Business Owner Android
and iOS apps.

At the start, most of the development at Yelp occurred in a single,
monolithic web application, creatively named “yelp-main” (naming is
hard!). As the company grew, our developers were spending increasing
amounts of time trying to ship code. After recognizing this pain
point, we started experimenting with a service oriented architecture
to scale the development process, and so far it’s been a resounding
success. Over the course of the last three years, we’ve gone from
writing our first service to having over seventy production services.
Along the way, we’ve dabbled with Docker containers, Pyramid,
SQLAlchemy, uWSGI, gevent, and virtualenv in an effort to build the
next-generation service platform for our engineers.
Captions: 
	00:00:04,430 --> 00:00:10,200
thank you and sorry for the flicker I

00:00:07,880 --> 00:00:15,049
hope you can manage to see the slides

00:00:10,200 --> 00:00:18,300
anyway who here knows what Yelp is oh

00:00:15,049 --> 00:00:22,170
that's actually okay so you're actually

00:00:18,300 --> 00:00:24,900
quite a few people so I'll be quick well

00:00:22,170 --> 00:00:27,660
yep yeps mission is about to connect

00:00:24,900 --> 00:00:30,060
people with great local businesses we

00:00:27,660 --> 00:00:34,860
have a website and app and a mobile

00:00:30,060 --> 00:00:38,760
website we have a 142 million unique

00:00:34,860 --> 00:00:42,300
active visitors monthly we have 77

00:00:38,760 --> 00:00:45,149
million reviews by those users and we

00:00:42,300 --> 00:00:46,440
are available in over 30 countries we

00:00:45,149 --> 00:00:49,410
most recently launched in the

00:00:46,440 --> 00:00:51,780
Philippines and we're not only for

00:00:49,410 --> 00:00:54,780
finding like great restaurants and bars

00:00:51,780 --> 00:00:58,440
but also like great doctors great shops

00:00:54,780 --> 00:01:00,239
and any other kind of local business we

00:00:58,440 --> 00:01:02,399
also have this is probably like less

00:01:00,239 --> 00:01:04,650
known we have yelp for business owners

00:01:02,399 --> 00:01:06,720
so if you're a business owner you can

00:01:04,650 --> 00:01:09,960
come to Yelp you can claim your business

00:01:06,720 --> 00:01:12,479
you can mark it as your own and you can

00:01:09,960 --> 00:01:14,549
then measure visitor activity on your

00:01:12,479 --> 00:01:16,500
Yelp page you can interact with

00:01:14,549 --> 00:01:19,470
customers so if customers leave a review

00:01:16,500 --> 00:01:22,110
for your business you can reply to that

00:01:19,470 --> 00:01:24,810
and public or in private and you can

00:01:22,110 --> 00:01:28,549
upload photos for your business and do a

00:01:24,810 --> 00:01:31,530
bunch of other things so when I'm I'm a

00:01:28,549 --> 00:01:34,590
back-end developer for the business

00:01:31,530 --> 00:01:37,799
owner app I worked on the main yelp app

00:01:34,590 --> 00:01:41,100
back end before that I map iphone users

00:01:37,799 --> 00:01:42,930
since 2008 I started doing a lot of

00:01:41,100 --> 00:01:45,960
Django work back then before switching

00:01:42,930 --> 00:01:49,710
to application and now mobile

00:01:45,960 --> 00:01:55,140
development so let's take a look at why

00:01:49,710 --> 00:01:57,030
we're going to okay that's really not

00:01:55,140 --> 00:02:01,860
good there's supposed to be an image

00:01:57,030 --> 00:02:04,290
there about Yelp let's take a look we

00:02:01,860 --> 00:02:06,450
were founded in 2004 and actually like

00:02:04,290 --> 00:02:09,600
one of the co-founders Jeremy Stoppelman

00:02:06,450 --> 00:02:12,750
is still running the

00:02:09,600 --> 00:02:15,120
the company is our CEO and all of our

00:02:12,750 --> 00:02:18,600
code was in a central repository we

00:02:15,120 --> 00:02:21,060
called yelled name which means the code

00:02:18,600 --> 00:02:23,010
for the website including templates the

00:02:21,060 --> 00:02:25,250
mobile web the mobile backend and

00:02:23,010 --> 00:02:28,410
business owner site all in one

00:02:25,250 --> 00:02:32,940
repository which means we had a lot of

00:02:28,410 --> 00:02:34,830
homegrown code and as people worked on

00:02:32,940 --> 00:02:36,630
it and they introduce new abstractions

00:02:34,830 --> 00:02:40,080
they didn't remove the old ones and it

00:02:36,630 --> 00:02:42,720
was hard to reason about the code do

00:02:40,080 --> 00:02:44,160
these big refactorings so as you outgrew

00:02:42,720 --> 00:02:47,400
and we are still growing we're still

00:02:44,160 --> 00:02:49,290
hiring people this started to become a

00:02:47,400 --> 00:02:52,070
bottleneck we actually like at one point

00:02:49,290 --> 00:02:54,960
we had three different ways to do

00:02:52,070 --> 00:02:57,720
sequels statements was execute sequel

00:02:54,960 --> 00:03:01,920
statements in the of Maine that was not

00:02:57,720 --> 00:03:04,920
nice so yeah we cannot really refactor

00:03:01,920 --> 00:03:06,690
all the code and I want to dig deeper

00:03:04,920 --> 00:03:13,610
into another area that really highlights

00:03:06,690 --> 00:03:13,610
our bottleneck I'm really sorry like

00:03:23,240 --> 00:03:26,240
okay

00:03:30,440 --> 00:03:34,850
it's really sorry about this

00:03:43,670 --> 00:03:46,670
ok

00:03:50,160 --> 00:03:53,160
ok

00:04:07,600 --> 00:04:10,140
um

00:04:18,139 --> 00:04:20,829
just

00:04:38,280 --> 00:04:47,130
you

00:04:39,990 --> 00:04:50,520
oh sorry about all of this yeah so we

00:04:47,130 --> 00:04:52,290
had a lot of homegrown code finally we

00:04:50,520 --> 00:04:56,550
see the images this is what Yelp looked

00:04:52,290 --> 00:04:59,100
like back then we have a lot of yeah

00:04:56,550 --> 00:05:01,620
abstractions I talked about that so

00:04:59,100 --> 00:05:04,590
let's talk about the push process which

00:05:01,620 --> 00:05:08,040
is what we call when we deploy the app

00:05:04,590 --> 00:05:11,490
code we do deploy up code several times

00:05:08,040 --> 00:05:13,560
a day this is done by a push master

00:05:11,490 --> 00:05:18,030
which is an engineer that has production

00:05:13,560 --> 00:05:20,190
system access people take their code

00:05:18,030 --> 00:05:22,080
changes their code review changes they

00:05:20,190 --> 00:05:24,900
want to push to production and they join

00:05:22,080 --> 00:05:27,530
a push and then the push mess runs this

00:05:24,900 --> 00:05:30,450
push we have like several tools to

00:05:27,530 --> 00:05:32,100
assist us in doing this you see a

00:05:30,450 --> 00:05:35,850
screenshot of push manager which is

00:05:32,100 --> 00:05:37,830
actually open source where we manage the

00:05:35,850 --> 00:05:41,340
pushes and people can say hey I want to

00:05:37,830 --> 00:05:43,020
join this Porsche and I want to push my

00:05:41,340 --> 00:05:45,900
changes to production and as you can

00:05:43,020 --> 00:05:48,360
hopefully see it's not that clear

00:05:45,900 --> 00:05:52,680
there's like a small red a bar next to

00:05:48,360 --> 00:05:54,660
my push I you I ran and it's red which

00:05:52,680 --> 00:05:57,900
means this push didn't make it to

00:05:54,660 --> 00:06:00,570
production we had to abandon it and I'm

00:05:57,900 --> 00:06:04,380
going to talk a bit out about why this

00:06:00,570 --> 00:06:06,390
might happen so when we run a push at

00:06:04,380 --> 00:06:09,030
first there are some automatic checks

00:06:06,390 --> 00:06:10,800
that take all changes build a deployment

00:06:09,030 --> 00:06:14,220
branch where they merge all the changes

00:06:10,800 --> 00:06:17,460
in the deployment branches then yep well

00:06:14,220 --> 00:06:20,460
deployed to a stage system and then

00:06:17,460 --> 00:06:21,990
after manual verifications of all people

00:06:20,460 --> 00:06:23,790
that join this push they need to be

00:06:21,990 --> 00:06:26,790
present they need to verify that their

00:06:23,790 --> 00:06:29,550
changes work on the stage system and if

00:06:26,790 --> 00:06:32,250
everything is okay or test suite we are

00:06:29,550 --> 00:06:34,770
happy with our test suite runs then we

00:06:32,250 --> 00:06:37,050
send this branch to production we do the

00:06:34,770 --> 00:06:39,780
same thing we watch production for a

00:06:37,050 --> 00:06:42,060
certain amount of time and if we are

00:06:39,780 --> 00:06:44,540
happy the push gets certified the

00:06:42,060 --> 00:06:47,850
changes get merged into master and

00:06:44,540 --> 00:06:48,800
starting from that the changes are live

00:06:47,850 --> 00:06:50,930
and

00:06:48,800 --> 00:06:52,789
we've done people when they branch off

00:06:50,930 --> 00:06:55,370
and they started to work on a new change

00:06:52,789 --> 00:06:58,460
that will branch off of these changes

00:06:55,370 --> 00:07:01,639
this is a two hour process with really

00:06:58,460 --> 00:07:03,919
no upper bound why no upper bound

00:07:01,639 --> 00:07:06,080
because like if we find problems let's

00:07:03,919 --> 00:07:08,509
say on the stage system we need to take

00:07:06,080 --> 00:07:10,699
out the problematic change rebuild the

00:07:08,509 --> 00:07:14,090
deployment branch put it again on stage

00:07:10,699 --> 00:07:16,940
system run our test Suites go again to

00:07:14,090 --> 00:07:19,520
production and so on and so on until we

00:07:16,940 --> 00:07:22,610
have a new code version that is good and

00:07:19,520 --> 00:07:24,110
it we can leave on production as you see

00:07:22,610 --> 00:07:25,879
here is green shot this is actually like

00:07:24,110 --> 00:07:30,770
another tool that helps us during the

00:07:25,879 --> 00:07:32,449
push where you can see which holes in

00:07:30,770 --> 00:07:34,250
our data centers are already running the

00:07:32,449 --> 00:07:37,669
new version of the code this is the

00:07:34,250 --> 00:07:39,409
green bars which hosts in the data

00:07:37,669 --> 00:07:41,360
centers are running the old version of

00:07:39,409 --> 00:07:43,280
the code which is the red bars and the

00:07:41,360 --> 00:07:45,889
yellow bars are the holes that are in

00:07:43,280 --> 00:07:49,909
the process of bouncing so switching to

00:07:45,889 --> 00:07:51,740
the new code version I have to say like

00:07:49,909 --> 00:07:53,949
our release engineering team they are

00:07:51,740 --> 00:07:56,930
hard at work and like optimizing this

00:07:53,949 --> 00:07:58,669
process they're really like making it

00:07:56,930 --> 00:08:01,789
better and better more automatic but

00:07:58,669 --> 00:08:04,550
still it was obvious that like this

00:08:01,789 --> 00:08:07,639
doesn't scale you can run only so many

00:08:04,550 --> 00:08:10,909
pushes a day and add the more people

00:08:07,639 --> 00:08:12,740
join Yelp and we are still growing the

00:08:10,909 --> 00:08:18,590
harder it becomes to have like a push

00:08:12,740 --> 00:08:20,870
without issues so some yeah intelligent

00:08:18,590 --> 00:08:22,490
mindset together at Yelp and they

00:08:20,870 --> 00:08:24,139
thought about a solution and they found

00:08:22,490 --> 00:08:26,750
one I don't think we are the first

00:08:24,139 --> 00:08:29,539
company that came up with this solution

00:08:26,750 --> 00:08:33,050
but it's yeah kind of obvious we need to

00:08:29,539 --> 00:08:35,570
modularize we are at a certain size

00:08:33,050 --> 00:08:37,099
where you can not work with a single

00:08:35,570 --> 00:08:40,550
code base you can only run so many

00:08:37,099 --> 00:08:42,770
pushes a day as I just said and even if

00:08:40,550 --> 00:08:44,449
you increase the number of pushes the

00:08:42,770 --> 00:08:47,209
number of people that develop at Yelp

00:08:44,449 --> 00:08:50,870
also increases so yeah you will run into

00:08:47,209 --> 00:08:54,529
problems eventually so let's build

00:08:50,870 --> 00:08:58,310
services how do services solve this

00:08:54,529 --> 00:09:00,350
problem well each service is developed

00:08:58,310 --> 00:09:01,920
and deployed independently so you don't

00:09:00,350 --> 00:09:04,800
actually need to

00:09:01,920 --> 00:09:06,829
you know about this huge co-pays you

00:09:04,800 --> 00:09:09,389
just need to know about your service

00:09:06,829 --> 00:09:14,040
service pushes are very easy and very

00:09:09,389 --> 00:09:18,120
quick people can do it themselves after

00:09:14,040 --> 00:09:20,820
like short training services or usually

00:09:18,120 --> 00:09:23,790
only cover like one aspect or one set of

00:09:20,820 --> 00:09:26,519
features which also makes it very easy

00:09:23,790 --> 00:09:30,060
to like introduce new technologies to

00:09:26,519 --> 00:09:34,230
refactor code reduce technical debt all

00:09:30,060 --> 00:09:36,389
that kind of thing and it's actually it

00:09:34,230 --> 00:09:39,209
might even bring some performance

00:09:36,389 --> 00:09:41,339
benefits since when you have like this

00:09:39,209 --> 00:09:44,310
big monolithic code base in Python it's

00:09:41,339 --> 00:09:47,639
not that easy to parallelize things

00:09:44,310 --> 00:09:49,740
right so when you switch to a

00:09:47,639 --> 00:09:51,360
service-oriented architecture even

00:09:49,740 --> 00:09:53,310
though at first you might think hey like

00:09:51,360 --> 00:09:56,070
I'm doing network request instead of

00:09:53,310 --> 00:09:59,579
like function calls this should be

00:09:56,070 --> 00:10:01,079
slower it might be actually faster than

00:09:59,579 --> 00:10:03,660
before if you do those requests

00:10:01,079 --> 00:10:08,250
asynchronously at the same time and just

00:10:03,660 --> 00:10:11,339
wait for the longest result we actually

00:10:08,250 --> 00:10:13,709
also wrote like job service principles

00:10:11,339 --> 00:10:17,130
it's like a list of do and don'ts for

00:10:13,709 --> 00:10:19,709
services or reasoning about services or

00:10:17,130 --> 00:10:24,510
thoughts go check it out it's on on

00:10:19,709 --> 00:10:28,110
github yeah so why might we not want to

00:10:24,510 --> 00:10:30,269
do services because well k else might

00:10:28,110 --> 00:10:32,779
ensue like I actually stole this from

00:10:30,269 --> 00:10:35,790
hat Fred hatful like a colleague of mine

00:10:32,779 --> 00:10:41,000
he also gave a talk about services you

00:10:35,790 --> 00:10:43,890
can find it online it's really good well

00:10:41,000 --> 00:10:46,140
why not services consistency is really

00:10:43,890 --> 00:10:49,110
hard it's actually like non-existent

00:10:46,140 --> 00:10:52,319
there is no such thing as a transaction

00:10:49,110 --> 00:10:54,839
over like several service calls you

00:10:52,319 --> 00:10:57,240
don't have clear dependency or usage

00:10:54,839 --> 00:10:58,800
graph so which means you need to

00:10:57,240 --> 00:11:00,990
maintain your interfaces you know API

00:10:58,800 --> 00:11:04,139
for ever since you don't know who is

00:11:00,990 --> 00:11:06,720
going to use it and for how long it also

00:11:04,139 --> 00:11:09,089
means like that testing like one huge

00:11:06,720 --> 00:11:12,240
self-contained codebase it's easy it

00:11:09,089 --> 00:11:13,949
might not be simple but it's easy but

00:11:12,240 --> 00:11:14,780
how do you test your loosely coupled

00:11:13,949 --> 00:11:17,780
service

00:11:14,780 --> 00:11:19,390
which are out there so this is the case

00:11:17,780 --> 00:11:24,680
I was talking about how do you make sure

00:11:19,390 --> 00:11:27,110
stuff doesn't break unit tests everybody

00:11:24,680 --> 00:11:30,020
loves unit tests or at least many people

00:11:27,110 --> 00:11:33,140
do but in my opinion they are great but

00:11:30,020 --> 00:11:36,080
they are not enough since in a world of

00:11:33,140 --> 00:11:38,960
loosely coupled services a breakage many

00:11:36,080 --> 00:11:41,960
times occurs at the interface level so

00:11:38,960 --> 00:11:45,950
like some service you call it subtly

00:11:41,960 --> 00:11:47,930
changes its interface its API the

00:11:45,950 --> 00:11:51,290
developers maybe didn't even intend to

00:11:47,930 --> 00:11:53,440
and yes your call breaks the answer is

00:11:51,290 --> 00:11:57,440
not that what you expected it to be and

00:11:53,440 --> 00:11:59,990
this is a huge problem what's our

00:11:57,440 --> 00:12:04,070
solution to that our solution is

00:11:59,990 --> 00:12:05,810
acceptance tests so instead of mocking

00:12:04,070 --> 00:12:08,240
either like with unit tests at a

00:12:05,810 --> 00:12:11,390
function lever or further out we don't

00:12:08,240 --> 00:12:13,730
do any mocking we run all the code from

00:12:11,390 --> 00:12:17,330
the request as it comes in through all

00:12:13,730 --> 00:12:19,100
services we might call back the whole

00:12:17,330 --> 00:12:21,890
workflow and then we test the response

00:12:19,100 --> 00:12:25,250
we get and make sure it's what we want

00:12:21,890 --> 00:12:27,590
it to be it's as close to production as

00:12:25,250 --> 00:12:31,750
possible without like setting up your

00:12:27,590 --> 00:12:37,160
own dedicated stage environment and it's

00:12:31,750 --> 00:12:39,560
yeah what we do at edl so we put all the

00:12:37,160 --> 00:12:42,230
components to services anything else you

00:12:39,560 --> 00:12:44,300
need in docker images we spin up those

00:12:42,230 --> 00:12:47,450
talker containers we use production code

00:12:44,300 --> 00:12:51,230
for these containers and we use docker

00:12:47,450 --> 00:12:54,890
compose it was previously called fig to

00:12:51,230 --> 00:12:57,380
manage these teas infrastructure it's a

00:12:54,890 --> 00:12:59,840
bit heavy weight so it takes a long time

00:12:57,380 --> 00:13:01,640
to run not the test itself that's

00:12:59,840 --> 00:13:04,040
actually fairly quick but like spinning

00:13:01,640 --> 00:13:06,610
up all those darker containers setting

00:13:04,040 --> 00:13:10,400
everything up that takes quite some time

00:13:06,610 --> 00:13:13,220
and it actually grows with the number of

00:13:10,400 --> 00:13:15,650
services you have obviously like so you

00:13:13,220 --> 00:13:17,980
call more services so your acceptance

00:13:15,650 --> 00:13:22,760
testing setup has to grow accordingly

00:13:17,980 --> 00:13:24,710
yeah so it's a bit heavy weight but we

00:13:22,760 --> 00:13:26,660
are really happy with the results since

00:13:24,710 --> 00:13:28,639
it gives you a certain amount of

00:13:26,660 --> 00:13:31,759
confidence in your changes because you

00:13:28,639 --> 00:13:36,829
can say yeah this is going to work in

00:13:31,759 --> 00:13:39,649
production so just an example of what

00:13:36,829 --> 00:13:42,740
this might look like this is part of the

00:13:39,649 --> 00:13:45,199
acceptance testing set up for the this

00:13:42,740 --> 00:13:48,290
own rap back end so we have some configs

00:13:45,199 --> 00:13:50,480
we have the main busy app definition

00:13:48,290 --> 00:13:52,459
where you can see under links this is

00:13:50,480 --> 00:13:54,709
like all the dependencies we have all

00:13:52,459 --> 00:13:57,980
the direct dependencies those are like

00:13:54,709 --> 00:14:00,199
several different services within Yelp

00:13:57,980 --> 00:14:03,319
internal API is actually like the

00:14:00,199 --> 00:14:05,689
service front end of yelp main so that's

00:14:03,319 --> 00:14:08,209
like our legacy code base and you can

00:14:05,689 --> 00:14:11,079
see on the right that one itself has a

00:14:08,209 --> 00:14:15,199
bunch of dependencies so that's how your

00:14:11,079 --> 00:14:17,990
acceptance testing set up grows yeah but

00:14:15,199 --> 00:14:20,480
as I said it can be a bit cumbersome

00:14:17,990 --> 00:14:23,149
also like setting up test data because

00:14:20,480 --> 00:14:25,610
some services have their own data store

00:14:23,149 --> 00:14:27,649
so when you create your test features

00:14:25,610 --> 00:14:30,110
you need to make sure like all services

00:14:27,649 --> 00:14:33,139
are like NSYNC at the same data so your

00:14:30,110 --> 00:14:35,779
tests work but overall we're pretty

00:14:33,139 --> 00:14:38,689
happy with it so now that we know why we

00:14:35,779 --> 00:14:41,480
do services and how we make sure they

00:14:38,689 --> 00:14:44,300
don't break randomly what's our service

00:14:41,480 --> 00:14:47,720
stack we originally started with tornado

00:14:44,300 --> 00:14:50,569
but that did not work out quite as well

00:14:47,720 --> 00:14:52,519
as we hoped so our current stack is

00:14:50,569 --> 00:14:55,970
pyramid just the latest version of

00:14:52,519 --> 00:15:00,170
pyramid with you whiskey and SQL alchemy

00:14:55,970 --> 00:15:03,019
and it works out quite well we use HTTP

00:15:00,170 --> 00:15:07,519
obviously as transport protocol JSON for

00:15:03,019 --> 00:15:09,470
the data format and one very important

00:15:07,519 --> 00:15:12,500
block of our service tag is swagger

00:15:09,470 --> 00:15:15,410
which is an API framework so with

00:15:12,500 --> 00:15:17,980
swagger you specify your API you're

00:15:15,410 --> 00:15:20,959
right actually JSON to specify your API

00:15:17,980 --> 00:15:23,629
and there's a bunch of tools included

00:15:20,959 --> 00:15:26,889
one of them is swagger UI which helps

00:15:23,629 --> 00:15:30,529
you visualize the API you just defined

00:15:26,889 --> 00:15:33,170
this is what it looks like for for a

00:15:30,529 --> 00:15:37,309
random service at Yelp I think this is

00:15:33,170 --> 00:15:39,350
business media so you see your methods

00:15:37,309 --> 00:15:40,279
get and post you see the endpoint you

00:15:39,350 --> 00:15:42,860
see the

00:15:40,279 --> 00:15:46,040
parameters your service expects or that

00:15:42,860 --> 00:15:48,920
endpoint expects the data model your you

00:15:46,040 --> 00:15:51,199
you will get as a response so you can

00:15:48,920 --> 00:15:55,519
browse and find all the endpoints you

00:15:51,199 --> 00:15:58,129
might need for your work so where does

00:15:55,519 --> 00:16:00,740
more it also does request and response

00:15:58,129 --> 00:16:03,050
validation optionally but I would

00:16:00,740 --> 00:16:04,370
encourage you to to activate that since

00:16:03,050 --> 00:16:06,680
it makes sure like your request

00:16:04,370 --> 00:16:09,529
parameters are there and in the

00:16:06,680 --> 00:16:14,089
specified type as specified in the spec

00:16:09,529 --> 00:16:19,009
your response is actually fits what we

00:16:14,089 --> 00:16:20,990
saw here in the data model it does data

00:16:19,009 --> 00:16:24,139
structure and basic type checking on

00:16:20,990 --> 00:16:26,689
individual field level and it works

00:16:24,139 --> 00:16:30,499
dynamically by reading a services back

00:16:26,689 --> 00:16:34,490
so this library called bravado it was

00:16:30,499 --> 00:16:37,670
called swagger pie it's open source we

00:16:34,490 --> 00:16:39,769
it's on get up on our github account and

00:16:37,670 --> 00:16:42,139
it like dynamically reads this back and

00:16:39,769 --> 00:16:44,269
generates your stub so you can like do

00:16:42,139 --> 00:16:48,759
function calls on method calls in Python

00:16:44,269 --> 00:16:51,410
would actually do the HTTP requests and

00:16:48,759 --> 00:16:53,990
we used to do that with client libraries

00:16:51,410 --> 00:16:56,689
which was quite painful so say you

00:16:53,990 --> 00:16:59,089
wanted to develop a new endpoint for

00:16:56,689 --> 00:17:01,100
your service you would do that then you

00:16:59,089 --> 00:17:04,069
would check out the client library you

00:17:01,100 --> 00:17:06,110
would generate the stub code for that

00:17:04,069 --> 00:17:08,000
new endpoint you would commit that after

00:17:06,110 --> 00:17:09,949
it went through code review you would

00:17:08,000 --> 00:17:12,770
bump the client library version number

00:17:09,949 --> 00:17:14,990
and only then when people upgrade it to

00:17:12,770 --> 00:17:18,230
the new client library they could use

00:17:14,990 --> 00:17:20,899
your new endpoint all of this swagger

00:17:18,230 --> 00:17:23,209
pie or bravado takes care of it for us

00:17:20,899 --> 00:17:26,089
and it makes it really nice to work with

00:17:23,209 --> 00:17:30,110
it so let's talk a bit about a specific

00:17:26,089 --> 00:17:32,799
service the biz app service which is the

00:17:30,110 --> 00:17:36,320
service that powers our biz on wrap

00:17:32,799 --> 00:17:38,030
clients Android and iOS clients it's a

00:17:36,320 --> 00:17:40,070
bit of a special snowflake since it's

00:17:38,030 --> 00:17:42,200
one of the very few services at Yelp you

00:17:40,070 --> 00:17:44,090
can reach from the outside usually they

00:17:42,200 --> 00:17:47,809
you can only reach them from the

00:17:44,090 --> 00:17:50,120
internal network it's also unlike other

00:17:47,809 --> 00:17:52,559
services it's not constrained to like

00:17:50,120 --> 00:17:55,590
one set of features or one area

00:17:52,559 --> 00:17:59,879
it contains the whole API for our App

00:17:55,590 --> 00:18:02,340
clients and it has no local data storm

00:17:59,879 --> 00:18:05,100
so actually many services have their own

00:18:02,340 --> 00:18:07,379
data store we don't so often times we

00:18:05,100 --> 00:18:09,809
are just a proxy we are calling other

00:18:07,379 --> 00:18:11,749
services we are calling Yelp main we are

00:18:09,809 --> 00:18:13,740
aggregating data and returning

00:18:11,749 --> 00:18:18,749
formatting it and reaching it and

00:18:13,740 --> 00:18:22,649
returning it to our clients so how does

00:18:18,749 --> 00:18:24,899
our mobile 18 I look like well it's it's

00:18:22,649 --> 00:18:27,960
an arrestee API right one resource /

00:18:24,899 --> 00:18:30,539
endpoint do multiple calls to fetch

00:18:27,960 --> 00:18:33,389
related resources but weblog probably

00:18:30,539 --> 00:18:35,190
already know all of this and this is how

00:18:33,389 --> 00:18:39,779
we develop services that yell but not

00:18:35,190 --> 00:18:41,730
how you do a mobile API because you are

00:18:39,779 --> 00:18:43,799
over a cellular network you want to be

00:18:41,730 --> 00:18:46,799
as efficient as possible and you want to

00:18:43,799 --> 00:18:50,309
do as few calls as possible so what we

00:18:46,799 --> 00:18:54,600
do is we have one endpoint per client

00:18:50,309 --> 00:18:57,090
app page so for every page your app

00:18:54,600 --> 00:18:59,159
displays we just wanted to do if

00:18:57,090 --> 00:19:02,700
possible just one network request and

00:18:59,159 --> 00:19:04,950
send it all the data it needs for post

00:19:02,700 --> 00:19:06,929
endpoints whenever like you you want to

00:19:04,950 --> 00:19:09,419
save something from the client we not

00:19:06,929 --> 00:19:11,789
only acknowledge that the right happened

00:19:09,419 --> 00:19:13,649
successfully but we also send the client

00:19:11,789 --> 00:19:16,440
back all data it might need for

00:19:13,649 --> 00:19:19,590
follow-up pages to display that this is

00:19:16,440 --> 00:19:22,340
quite different from our yeah lower

00:19:19,590 --> 00:19:26,490
level service ap is that really are more

00:19:22,340 --> 00:19:29,669
resti so you can say that yeah we

00:19:26,490 --> 00:19:32,600
aggregate we do like many service calls

00:19:29,669 --> 00:19:35,519
for typically many service calls for one

00:19:32,600 --> 00:19:38,879
client requests we get and we just

00:19:35,519 --> 00:19:43,470
aggregate and send data back and act as

00:19:38,879 --> 00:19:47,610
a proxy so what does it mean to develop

00:19:43,470 --> 00:19:50,399
mobile app back end I come from web

00:19:47,610 --> 00:19:53,669
development I imagine some of you do as

00:19:50,399 --> 00:19:57,360
well turns out mobile apps have releases

00:19:53,669 --> 00:19:59,429
in our case for the bits owner app they

00:19:57,360 --> 00:20:02,190
are synchronized so we release android

00:19:59,429 --> 00:20:03,740
and iOS at the same time with the same

00:20:02,190 --> 00:20:06,890
set of features

00:20:03,740 --> 00:20:09,410
and iOS apps need to be reviewed as you

00:20:06,890 --> 00:20:11,570
might have heard and this actually takes

00:20:09,410 --> 00:20:14,210
quite some time I remember like it used

00:20:11,570 --> 00:20:16,700
to be like five days nowadays I think

00:20:14,210 --> 00:20:18,860
our longest review time was 11 days I

00:20:16,700 --> 00:20:21,500
think it's back to about nine days

00:20:18,860 --> 00:20:23,990
that's actually like quite a long time

00:20:21,500 --> 00:20:26,030
and you probably want to test the whole

00:20:23,990 --> 00:20:28,220
thing before you release it and in this

00:20:26,030 --> 00:20:32,660
case releasing means submitting it to

00:20:28,220 --> 00:20:35,350
review to Apple so our API needs to be

00:20:32,660 --> 00:20:37,670
done sooner than the client

00:20:35,350 --> 00:20:40,700
implementation and which means it needs

00:20:37,670 --> 00:20:42,710
to be done way sooner than when the app

00:20:40,700 --> 00:20:46,580
is released or when you can download it

00:20:42,710 --> 00:20:50,050
on your phone how else is it different

00:20:46,580 --> 00:20:53,090
than web development you cannot upgrade

00:20:50,050 --> 00:20:56,210
the client whenever you upgrade the

00:20:53,090 --> 00:20:58,130
server in fact some clients never

00:20:56,210 --> 00:21:01,760
upgrade like we still have a tiny

00:20:58,130 --> 00:21:03,530
portion of users on the 10 release for

00:21:01,760 --> 00:21:07,820
the biz owner app which we released late

00:21:03,530 --> 00:21:11,390
last year so unless you want to drop

00:21:07,820 --> 00:21:15,380
support for those users you need to

00:21:11,390 --> 00:21:18,670
support your API forever which means you

00:21:15,380 --> 00:21:22,880
cannot do backwards incompatible changes

00:21:18,670 --> 00:21:26,360
how do we deal with that we do a multi

00:21:22,880 --> 00:21:28,400
version API so we have the same endpoint

00:21:26,360 --> 00:21:31,580
with a different version in this case we

00:21:28,400 --> 00:21:34,670
append the version at the end and we do

00:21:31,580 --> 00:21:37,660
maintain and test all versions to make

00:21:34,670 --> 00:21:41,690
sure they still work this is obviously

00:21:37,660 --> 00:21:44,360
it costs something it costs effort so

00:21:41,690 --> 00:21:46,760
maintaining multiple versions we don't

00:21:44,360 --> 00:21:48,950
want to do that needlessly so what are

00:21:46,760 --> 00:21:51,410
the ways we can think of to make sure we

00:21:48,950 --> 00:21:53,870
don't have to do multiple versions all

00:21:51,410 --> 00:21:56,960
the time it turns out if you just add

00:21:53,870 --> 00:21:59,150
data to the response that's backwards

00:21:56,960 --> 00:22:00,860
compatible our clients they will just

00:21:59,150 --> 00:22:04,490
ignore it the legacy clients the old

00:22:00,860 --> 00:22:06,980
clients and our response validation what

00:22:04,490 --> 00:22:09,080
swagger does for you it's also smart

00:22:06,980 --> 00:22:11,210
enough to just ignore additional data

00:22:09,080 --> 00:22:15,440
just make sure that the data as its

00:22:11,210 --> 00:22:18,750
defined in the spec is there and once we

00:22:15,440 --> 00:22:21,060
develop on the server and we add that

00:22:18,750 --> 00:22:24,600
new field we also added to the spec so

00:22:21,060 --> 00:22:28,530
actually our response will be it will be

00:22:24,600 --> 00:22:30,480
ok it will validate right so this is

00:22:28,530 --> 00:22:33,240
what it looks like this is an example

00:22:30,480 --> 00:22:35,340
out of a JSON inspect for an API and you

00:22:33,240 --> 00:22:38,790
see the green part we just added one

00:22:35,340 --> 00:22:40,920
field time zone type string with a

00:22:38,790 --> 00:22:43,320
description and we could do that without

00:22:40,920 --> 00:22:45,270
having to do any other change to that

00:22:43,320 --> 00:22:48,000
file so obviously like we didn't

00:22:45,270 --> 00:22:52,530
introduce a new version endpoint it

00:22:48,000 --> 00:22:55,650
would just work so how do we make sure

00:22:52,530 --> 00:22:58,650
it actually does work in production well

00:22:55,650 --> 00:23:01,550
we do some monitoring we monitor the

00:22:58,650 --> 00:23:04,770
number of requests the server errors

00:23:01,550 --> 00:23:07,170
task you send push notifications here

00:23:04,770 --> 00:23:12,030
are some examples this is a tool like an

00:23:07,170 --> 00:23:14,280
older tool must not see it where we look

00:23:12,030 --> 00:23:16,380
at the types of errors that happened at

00:23:14,280 --> 00:23:18,600
the rate of errors we now have like a

00:23:16,380 --> 00:23:20,730
bunch of nice Cabana for dashboards we

00:23:18,600 --> 00:23:24,120
can like actually do almost anything you

00:23:20,730 --> 00:23:26,640
want we send a bunch of our metrics to

00:23:24,120 --> 00:23:28,500
signal effects so you can build nice

00:23:26,640 --> 00:23:31,980
dashboards you can visualize them

00:23:28,500 --> 00:23:35,340
analyze them and we use alas alert which

00:23:31,980 --> 00:23:37,590
is really nice open source tool we open

00:23:35,340 --> 00:23:39,090
source I think last year now you should

00:23:37,590 --> 00:23:42,240
really check it out it's very easy to

00:23:39,090 --> 00:23:44,940
set up your own alerts so you know

00:23:42,240 --> 00:23:47,040
whenever something is wrong for app

00:23:44,940 --> 00:23:49,770
crashes so whenever our client apps

00:23:47,040 --> 00:23:54,540
crash we use crashlytics both on Android

00:23:49,770 --> 00:23:56,550
and iOS and as soon as you reach a

00:23:54,540 --> 00:23:59,070
certain size you probably need an

00:23:56,550 --> 00:24:02,070
on-call rotation so you need to wake up

00:23:59,070 --> 00:24:04,860
people whenever things break we use

00:24:02,070 --> 00:24:07,470
pagerduty for that we have integrated a

00:24:04,860 --> 00:24:10,380
last word in the pagerduty so for severe

00:24:07,470 --> 00:24:13,550
errors we get paged we have integrated

00:24:10,380 --> 00:24:19,380
crashlytics so if our app crashes spike

00:24:13,550 --> 00:24:23,280
we get paged yeah that's basically

00:24:19,380 --> 00:24:25,730
already about it I want to just mention

00:24:23,280 --> 00:24:28,570
another talk if you are interested in

00:24:25,730 --> 00:24:31,210
services Scott Trillia is

00:24:28,570 --> 00:24:33,809
going to hold another and give another

00:24:31,210 --> 00:24:36,399
talk about services Arrested Development

00:24:33,809 --> 00:24:39,700
surviving the awkward adolescence of a

00:24:36,399 --> 00:24:43,929
micro services based application that

00:24:39,700 --> 00:24:45,940
was hard it's Friday 11am in the Python

00:24:43,929 --> 00:24:48,990
anywhere room go check it out and it's

00:24:45,940 --> 00:24:51,909
really a great talk also some other

00:24:48,990 --> 00:24:54,309
shameless plugs we are hiring so if that

00:24:51,909 --> 00:24:57,100
sounded interesting to you I check out

00:24:54,309 --> 00:24:59,740
yelp third column / careers and even if

00:24:57,100 --> 00:25:03,129
you don't find like your ideal job

00:24:59,740 --> 00:25:05,320
opening contact me or contact us on our

00:25:03,129 --> 00:25:07,840
booth we will figure something out we

00:25:05,320 --> 00:25:10,269
are always looking for talented people

00:25:07,840 --> 00:25:12,519
we actually have offices in Hamburg

00:25:10,269 --> 00:25:16,919
Germany this is where I work also in

00:25:12,519 --> 00:25:20,139
London and obviously in San Francisco

00:25:16,919 --> 00:25:22,269
yeah we also have an engineering hub

00:25:20,139 --> 00:25:24,580
where we aggregate our blog post we have

00:25:22,269 --> 00:25:28,720
our open source efforts documented there

00:25:24,580 --> 00:25:31,120
and more we are on Twitter and last but

00:25:28,720 --> 00:25:32,799
not least this is a fun one I urge you

00:25:31,120 --> 00:25:35,559
to check it out the yelp data set

00:25:32,799 --> 00:25:37,389
challenge if you ever wanted to do some

00:25:35,559 --> 00:25:40,419
data analysis but you didn't have data

00:25:37,389 --> 00:25:44,080
or you didn't know what to do go look

00:25:40,419 --> 00:25:46,899
that up the last one just ended but the

00:25:44,080 --> 00:25:48,970
new one will probably start like before

00:25:46,899 --> 00:25:50,980
the end of summer go check the website

00:25:48,970 --> 00:25:53,230
will be announced there and the deadline

00:25:50,980 --> 00:25:55,779
will be sometime by the end of the year

00:25:53,230 --> 00:26:00,399
yeah it's a lot of fun and you might

00:25:55,779 --> 00:26:02,379
actually even win some money so that's

00:26:00,399 --> 00:26:04,629
all thank you very much sorry for the

00:26:02,379 --> 00:26:08,070
technical difficulties and yeah if you

00:26:04,629 --> 00:26:08,070
have any questions just ask

00:26:13,920 --> 00:26:24,150
I can you talk a bit more about your

00:26:22,110 --> 00:26:27,050
aggregate are like is it something up

00:26:24,150 --> 00:26:30,540
answers do you plan to open source it or

00:26:27,050 --> 00:26:33,320
is it a process on its own or is it a

00:26:30,540 --> 00:26:39,510
web server module or how does it work

00:26:33,320 --> 00:26:42,660
aggregating what for your IP is well you

00:26:39,510 --> 00:26:48,090
say like you have an aggregate or for

00:26:42,660 --> 00:26:50,970
making only one request and to not and

00:26:48,090 --> 00:26:54,180
one request by page and not then request

00:26:50,970 --> 00:26:57,270
for that's basically like what our biz

00:26:54,180 --> 00:27:01,290
app service does so when when a client

00:26:57,270 --> 00:27:04,470
an app makes a request https requests to

00:27:01,290 --> 00:27:06,870
our servers it hits to our servers it

00:27:04,470 --> 00:27:09,300
hits our service and our service does

00:27:06,870 --> 00:27:11,280
everything it needs to like satisfy that

00:27:09,300 --> 00:27:13,890
request so it will do multiple service

00:27:11,280 --> 00:27:16,920
calls aggregate the data collected from

00:27:13,890 --> 00:27:19,440
different services from Yelp main put it

00:27:16,920 --> 00:27:21,930
together fetch related data everything

00:27:19,440 --> 00:27:26,160
the client needs and then send that back

00:27:21,930 --> 00:27:28,620
to the client in JSON over HTTPS so

00:27:26,160 --> 00:27:30,870
actually like our service this is like

00:27:28,620 --> 00:27:34,500
what we develop is the aggregator and

00:27:30,870 --> 00:27:36,330
does all of this and yeah and sometimes

00:27:34,500 --> 00:27:37,980
like when we want to aggregate that data

00:27:36,330 --> 00:27:40,080
there is like I mentioned this

00:27:37,980 --> 00:27:42,540
internally interface into Yelp main

00:27:40,080 --> 00:27:45,690
sometimes there is no interface for the

00:27:42,540 --> 00:27:48,060
data we need so actually we will also be

00:27:45,690 --> 00:27:52,160
developing that interface and then use

00:27:48,060 --> 00:27:52,160
it to fetch and aggregate data

00:27:56,659 --> 00:28:03,369
I have actually two questions the first

00:27:59,749 --> 00:28:07,700
one is what was the problem with tornado

00:28:03,369 --> 00:28:09,349
miss gears yeah I was fearing that issue

00:28:07,700 --> 00:28:13,879
might combine was actually not at Yelp

00:28:09,349 --> 00:28:15,739
when when this was tried out you might

00:28:13,879 --> 00:28:17,690
try to ask Scott about it I don't know

00:28:15,739 --> 00:28:20,239
if he knows you can also come to our

00:28:17,690 --> 00:28:22,549
booth there are other people we can ask

00:28:20,239 --> 00:28:24,950
honestly I can I cannot tell you I just

00:28:22,549 --> 00:28:27,619
know that it didn't work out well and

00:28:24,950 --> 00:28:30,529
now we are really happy with pyramid

00:28:27,619 --> 00:28:32,029
okay and the second question is how do

00:28:30,529 --> 00:28:36,950
you handle logging in the docker

00:28:32,029 --> 00:28:39,169
containers yeah that is an issue we do

00:28:36,950 --> 00:28:42,289
log in it's it's done inside the darker

00:28:39,169 --> 00:28:43,999
containers we expose them the law in

00:28:42,289 --> 00:28:46,159
folders as volumes so you can actually

00:28:43,999 --> 00:28:49,249
like start another docker container and

00:28:46,159 --> 00:28:51,259
mount those volumes from the individual

00:28:49,249 --> 00:28:59,720
docker containers and look at the logs

00:28:51,259 --> 00:29:04,879
anything necessary hi thanks for the

00:28:59,720 --> 00:29:06,739
talk can you come and more on your

00:29:04,879 --> 00:29:09,409
development process because I can

00:29:06,739 --> 00:29:11,599
imagine that testing it's a huge

00:29:09,409 --> 00:29:15,769
overhead so do you have separate team

00:29:11,599 --> 00:29:19,159
that makes the testing or does every

00:29:15,769 --> 00:29:21,979
developer is able to set up the whole

00:29:19,159 --> 00:29:24,769
infrastructure with Dockers how does it

00:29:21,979 --> 00:29:27,919
work thanks um yeah that's a great

00:29:24,769 --> 00:29:30,529
question um yes every developer is

00:29:27,919 --> 00:29:32,840
supposed to not only write the code but

00:29:30,529 --> 00:29:35,330
also write the test so typically like

00:29:32,840 --> 00:29:38,599
the development processes you you create

00:29:35,330 --> 00:29:41,149
a branch from within get right you do

00:29:38,599 --> 00:29:43,729
your development once you're ready you

00:29:41,149 --> 00:29:46,309
post your changes for code review other

00:29:43,729 --> 00:29:49,249
developers review the code and hopefully

00:29:46,309 --> 00:29:51,320
if they pay attention and you did a

00:29:49,249 --> 00:29:53,389
change without adding tests for that

00:29:51,320 --> 00:29:55,639
change they will say hey like you should

00:29:53,389 --> 00:29:58,279
write a test for that the developer then

00:29:55,639 --> 00:30:01,429
decides well is a unit test enough do I

00:29:58,279 --> 00:30:03,080
need an acceptance test but yes every

00:30:01,429 --> 00:30:07,429
developer is able to run the whole test

00:30:03,080 --> 00:30:08,930
suite on their local machine and then

00:30:07,429 --> 00:30:13,910
run the test

00:30:08,930 --> 00:30:15,830
yes so actually like when I say local

00:30:13,910 --> 00:30:18,170
machine we have something called

00:30:15,830 --> 00:30:20,300
developer playground where you look log

00:30:18,170 --> 00:30:23,300
into a machine where you do your actual

00:30:20,300 --> 00:30:25,640
work on and it has like everything ready

00:30:23,300 --> 00:30:27,830
for you to run the test so docker is

00:30:25,640 --> 00:30:31,010
installed everything is there we have

00:30:27,830 --> 00:30:34,130
our own local docker registry so it will

00:30:31,010 --> 00:30:43,910
just yes run the tests and you can write

00:30:34,130 --> 00:30:45,530
them and run them by yourself hi thank

00:30:43,910 --> 00:30:46,880
you very much for the talk I just have a

00:30:45,530 --> 00:30:49,660
basic question how do you services

00:30:46,880 --> 00:30:53,600
communicate actually I didn't get this

00:30:49,660 --> 00:30:54,950
you mean as in San Francisco so no your

00:30:53,600 --> 00:30:57,950
internal services because you said you

00:30:54,950 --> 00:31:02,960
have a module structure and yes so it's

00:30:57,950 --> 00:31:04,940
just HTTP calls with ya json data

00:31:02,960 --> 00:31:06,470
exchange so that's basically how they

00:31:04,940 --> 00:31:11,680
all communicate unless it's like

00:31:06,470 --> 00:31:11,680
something very special thank you

00:31:21,399 --> 00:31:27,830
you mentioned the acceptance test when

00:31:24,619 --> 00:31:31,580
you do deploys do you do any logging to

00:31:27,830 --> 00:31:36,110
avoid to deploys of the services that

00:31:31,580 --> 00:31:39,830
are required in the acceptance test so

00:31:36,110 --> 00:31:43,070
if if one service depends on service be

00:31:39,830 --> 00:31:45,379
and both this service and be once they

00:31:43,070 --> 00:31:48,919
want to be deployed what do you do then

00:31:45,379 --> 00:31:52,059
ah ok that's like since it's so loosely

00:31:48,919 --> 00:31:55,309
coupled either you have to pay like real

00:31:52,059 --> 00:31:58,340
good attention or you cannot do that so

00:31:55,309 --> 00:32:02,690
each service is considered independent

00:31:58,340 --> 00:32:04,309
so if you need like a deployment or you

00:32:02,690 --> 00:32:07,549
have a deployment of your service and it

00:32:04,309 --> 00:32:09,200
needs to have some other changes and

00:32:07,549 --> 00:32:12,200
other services before you can do that

00:32:09,200 --> 00:32:14,090
deployment you you just you as a

00:32:12,200 --> 00:32:15,590
developer as the owner of that service

00:32:14,090 --> 00:32:18,259
you need to make sure you don't deploy

00:32:15,590 --> 00:32:21,049
too early usually like when we do a

00:32:18,259 --> 00:32:22,759
deploy the whole test suite is run as

00:32:21,049 --> 00:32:25,489
the first thing even before we go to

00:32:22,759 --> 00:32:28,299
stage so hopefully if you have good test

00:32:25,489 --> 00:32:31,399
coverage you would like notice then that

00:32:28,299 --> 00:32:33,470
things are not there but generally it's

00:32:31,399 --> 00:32:35,509
your responsibility since we have loose

00:32:33,470 --> 00:32:37,399
coupling that you don't deploy breaking

00:32:35,509 --> 00:32:39,649
changes to other services that you

00:32:37,399 --> 00:32:41,629
remain backwards compatible and that if

00:32:39,649 --> 00:32:43,820
you depend on changes from other service

00:32:41,629 --> 00:32:47,919
that you do the deployment in the right

00:32:43,820 --> 00:32:47,919
order you're getting

00:32:52,419 --> 00:33:01,419
I think the for the talk so what can you

00:32:58,899 --> 00:33:03,820
please clarify what is the problem with

00:33:01,419 --> 00:33:05,830
the testing services so you said that

00:33:03,820 --> 00:33:07,629
each service and specification there is

00:33:05,830 --> 00:33:10,330
some tooling around it like swagger

00:33:07,629 --> 00:33:12,789
which verifies that social server

00:33:10,330 --> 00:33:14,470
response matches the specification and

00:33:12,789 --> 00:33:16,929
so there are service a which depends on

00:33:14,470 --> 00:33:18,759
service be and why can adjust service a

00:33:16,929 --> 00:33:21,700
expect the service be is always

00:33:18,759 --> 00:33:23,249
producing valid responses and it looks

00:33:21,700 --> 00:33:25,570
like you don't really need to run a

00:33:23,249 --> 00:33:27,609
request through all the services around

00:33:25,570 --> 00:33:30,879
and with the production version of

00:33:27,609 --> 00:33:34,590
service before that yes great question

00:33:30,879 --> 00:33:37,539
so it's mainly about the human factor so

00:33:34,590 --> 00:33:39,700
we don't have the tooling in place to

00:33:37,539 --> 00:33:43,480
check for this automatically basically

00:33:39,700 --> 00:33:45,580
our acceptance tests are that tooling to

00:33:43,480 --> 00:33:48,609
make sure a new service deployment

00:33:45,580 --> 00:33:51,279
doesn't break anything it has happened

00:33:48,609 --> 00:33:53,489
in the past multiple times actually

00:33:51,279 --> 00:33:57,279
remember once that a service got

00:33:53,489 --> 00:33:58,929
deployed which then broke something

00:33:57,279 --> 00:34:00,789
inside yelled main because yelled main

00:33:58,929 --> 00:34:02,830
called that service because the

00:34:00,789 --> 00:34:06,249
developers they just didn't think of the

00:34:02,830 --> 00:34:09,190
fact that this small change was actually

00:34:06,249 --> 00:34:11,260
not backwards compatible since we don't

00:34:09,190 --> 00:34:13,720
have something like as rigid to make

00:34:11,260 --> 00:34:15,540
like sure hey you you cannot deploy a

00:34:13,720 --> 00:34:17,950
change that's not backwards compatible

00:34:15,540 --> 00:34:22,859
we have to write tests for that and

00:34:17,950 --> 00:34:22,859
that's basically our our check for that

00:34:25,540 --> 00:34:33,520
hi thanks for the good presentation if I

00:34:30,730 --> 00:34:36,130
understood correctly you have a mobile

00:34:33,520 --> 00:34:38,940
API like an API specific to mobile

00:34:36,130 --> 00:34:42,240
applications have you ever considered

00:34:38,940 --> 00:34:45,179
having different slightly different

00:34:42,240 --> 00:34:47,590
structure or information return to

00:34:45,179 --> 00:34:52,360
different types of devices like

00:34:47,590 --> 00:34:55,330
different for Android and iOS yes we

00:34:52,360 --> 00:34:57,490
actually do that for our what we call

00:34:55,330 --> 00:35:00,580
consumer apps so basically the apps you

00:34:57,490 --> 00:35:03,160
will download on your device we not only

00:35:00,580 --> 00:35:06,760
might do that depending on device type

00:35:03,160 --> 00:35:10,060
but also depending on the version of the

00:35:06,760 --> 00:35:14,110
app you run and other factors so yes yes

00:35:10,060 --> 00:35:16,240
we do that up until now we will we have

00:35:14,110 --> 00:35:18,400
been able to get away with just

00:35:16,240 --> 00:35:20,530
different version endpoints and sending

00:35:18,400 --> 00:35:23,410
generally the same data both to Android

00:35:20,530 --> 00:35:25,300
and iOS but we are in the process of

00:35:23,410 --> 00:35:28,420
actually developing something similar

00:35:25,300 --> 00:35:31,810
for the biz owner app as well doesn't it

00:35:28,420 --> 00:35:35,050
make testing your API more complicated

00:35:31,810 --> 00:35:37,480
Oh much more complicated it's it's like

00:35:35,050 --> 00:35:40,150
basically any of these checks is like

00:35:37,480 --> 00:35:42,160
another branch in your code so yes

00:35:40,150 --> 00:35:44,290
that's why we are trying to avoid that

00:35:42,160 --> 00:35:52,920
as much as possible yeah completely

00:35:44,290 --> 00:35:52,920
agree thanks hey I think one okay

00:36:00,480 --> 00:36:08,550
it's extra talk so question is a you had

00:36:04,740 --> 00:36:13,260
a Yelp main and was the definition of

00:36:08,550 --> 00:36:16,890
reasons like how you recognize that you

00:36:13,260 --> 00:36:18,840
need to decouple this main from service

00:36:16,890 --> 00:36:20,520
I mean how you can I service first like

00:36:18,840 --> 00:36:24,570
what's the definition of yours the

00:36:20,520 --> 00:36:27,930
service first well we try to put like

00:36:24,570 --> 00:36:30,359
any new code we write if it's reasonable

00:36:27,930 --> 00:36:33,030
we try to put it inside and service and

00:36:30,359 --> 00:36:36,300
then use that from the airplane or

00:36:33,030 --> 00:36:39,390
wherever to decouple our code there are

00:36:36,300 --> 00:36:41,630
also efforts going on and taking code

00:36:39,390 --> 00:36:43,800
which is already in the Old Main

00:36:41,630 --> 00:36:46,770
extracting it and putting it into

00:36:43,800 --> 00:36:49,260
services just so our development speed

00:36:46,770 --> 00:36:52,230
can increase ramping up new developers

00:36:49,260 --> 00:36:54,840
actually becomes much faster since code

00:36:52,230 --> 00:37:06,480
is just simply less complicated and less

00:36:54,840 --> 00:37:08,670
huge that's difficult to like answer

00:37:06,480 --> 00:37:11,430
generally but if you look at our yelp

00:37:08,670 --> 00:37:13,830
service principles there's like I could

00:37:11,430 --> 00:37:15,960
actually reasons about that so I kind of

00:37:13,830 --> 00:37:17,460
like mention all of it but I encourage

00:37:15,960 --> 00:37:21,150
you to check it out it's actually like

00:37:17,460 --> 00:37:23,130
handles that topic and if you want to

00:37:21,150 --> 00:37:25,140
talk more about this like I will be at

00:37:23,130 --> 00:37:27,480
the booth now there's also a bunch of

00:37:25,140 --> 00:37:30,660
other awesome Yelp engineers there so

00:37:27,480 --> 00:37:34,880
just come talk to us we're happy to nerd

00:37:30,660 --> 00:37:34,880

YouTube URL: https://www.youtube.com/watch?v=UUkyzCwgqPw


