Title: Tibor Arpas - Mashing up py.test, coverage.py and ast.py to take TDD to a new level
Publication date: 2015-08-08
Playlist: EuroPython 2015
Description: 
	Tibor Arpas - Mashing up py.test, coverage.py and ast.py to take TDD to a new level
[EuroPython 2015]
[21 July 2015]
[Bilbao, Euskadi, Spain]

Users and developers especially, hate waiting. Computing has adapted
and we almost never wait for the computer for more then 10 seconds.
One big exception is runnig a test suite which takes MINUTES on many
projects. That is incredibly distracting, frustrating and dragging the
whole concept of automated tests down.

I present a technique and a tool (py.test plugin called "testmon")
which automatically selects only tests affected by recent changes.
Does it sound too good to be true? Python developers rightfully have a
suspecting attitude towards any tool which tries to be too clever
about their source code. Code completion and symbol searching doesn't
need to be 100% reliable but messing with the test suite execution? I
show that we can cut test suite execution time significantly but
maintain it's reliability.
Captions: 
	00:00:01,909 --> 00:00:07,319
thanks and thanks for coming everybody

00:00:04,609 --> 00:00:10,019
so the title of the talk is smashing up

00:00:07,319 --> 00:00:14,250
by test coverage by and ASD that pie to

00:00:10,019 --> 00:00:16,619
take TDD to a new level let me say just

00:00:14,250 --> 00:00:18,660
quick things about me I've been a

00:00:16,619 --> 00:00:21,720
freelance programmer since the beginning

00:00:18,660 --> 00:00:23,789
of my career like 20 years ago a couple

00:00:21,720 --> 00:00:25,080
times I took responsibility for the

00:00:23,789 --> 00:00:27,660
whole project and hired a few

00:00:25,080 --> 00:00:32,550
subcontractors to deliver it I chose on

00:00:27,660 --> 00:00:34,920
one project I chose patent for the

00:00:32,550 --> 00:00:36,840
delivery it was in 2008 and I didn't

00:00:34,920 --> 00:00:39,870
have to touch anything else since then

00:00:36,840 --> 00:00:41,610
fortunately at the moment I have five by

00:00:39,870 --> 00:00:44,430
ten subcontractors in one of his in

00:00:41,610 --> 00:00:46,800
bratislava working for one client on a

00:00:44,430 --> 00:00:54,629
long-term project and I'm looking for

00:00:46,800 --> 00:00:58,530
more clients okay I would like I have a

00:00:54,629 --> 00:01:00,090
little survey also serving time so how

00:00:58,530 --> 00:01:06,570
many of you did write at least one

00:01:00,090 --> 00:01:11,880
automated test cool who has tests you'd

00:01:06,570 --> 00:01:16,380
longer than two minutes how about longer

00:01:11,880 --> 00:01:25,080
than 10 minutes okay so some some some

00:01:16,380 --> 00:01:29,549
hands well okay eight hours okay to two

00:01:25,080 --> 00:01:36,380
hands who is getting a broken built too

00:01:29,549 --> 00:01:36,380
frequently let's go who's using knows

00:01:37,430 --> 00:01:46,829
how about pie test more people okay so

00:01:44,360 --> 00:01:49,020
these are three user interaction limits

00:01:46,829 --> 00:01:51,270
100 milliseconds is the limit for use it

00:01:49,020 --> 00:01:53,670
to feel the system is reacting

00:01:51,270 --> 00:01:56,100
immediately one second is the limit for

00:01:53,670 --> 00:01:57,659
users flow for to stay and interrupted

00:01:56,100 --> 00:01:59,880
even though they not will notice the

00:01:57,659 --> 00:02:01,590
delay and test second is the limit for

00:01:59,880 --> 00:02:06,329
users until they think the system is

00:02:01,590 --> 00:02:08,610
broken and start doing something else so

00:02:06,329 --> 00:02:10,319
computing adapted developers have done a

00:02:08,610 --> 00:02:11,550
good job in making it all quicker in

00:02:10,319 --> 00:02:13,770
recent years there is very few

00:02:11,550 --> 00:02:15,180
activities in today's computing

00:02:13,770 --> 00:02:20,250
you have to wait for more than 10

00:02:15,180 --> 00:02:24,930
seconds but how about executing a test

00:02:20,250 --> 00:02:27,090
suit it takes it takes minutes or hours

00:02:24,930 --> 00:02:29,340
it's 50 times slower than most of the

00:02:27,090 --> 00:02:31,920
other computer tasks it brings intensive

00:02:29,340 --> 00:02:34,590
load on the computer delays with other

00:02:31,920 --> 00:02:38,340
tasks fans screaming so what are the

00:02:34,590 --> 00:02:40,710
consequences developers hate waiting

00:02:38,340 --> 00:02:43,110
more than anybody else as executing

00:02:40,710 --> 00:02:45,120
tests tests interferes with the workflow

00:02:43,110 --> 00:02:47,370
so much is no wonder the data under

00:02:45,120 --> 00:02:49,200
pressure or distraction some developer

00:02:47,370 --> 00:02:51,420
doesn't run the test or doesn't notice

00:02:49,200 --> 00:02:53,670
negative results and come into failing

00:02:51,420 --> 00:02:55,230
built which makes the lives of other

00:02:53,670 --> 00:02:58,800
developers more difficult and sometimes

00:02:55,230 --> 00:03:02,220
starts downwards Bureau broken tested

00:02:58,800 --> 00:03:04,350
means adult life span increases the

00:03:02,220 --> 00:03:06,300
developer is valuing using and

00:03:04,350 --> 00:03:08,760
maintaining that you the most are most

00:03:06,300 --> 00:03:12,210
punished and lays the most time actually

00:03:08,760 --> 00:03:14,490
think that the test execution time is

00:03:12,210 --> 00:03:18,600
the single biggest flaw of automated

00:03:14,490 --> 00:03:25,590
tests idea as a whole but how about

00:03:18,600 --> 00:03:27,870
running just affected that majority of

00:03:25,590 --> 00:03:32,760
code changes are local so it advised to

00:03:27,870 --> 00:03:34,260
run the whole to suit each time there is

00:03:32,760 --> 00:03:36,570
of course a solution most of us have

00:03:34,260 --> 00:03:38,820
used the developer things I'm changing

00:03:36,570 --> 00:03:41,250
just this module so let's just execute

00:03:38,820 --> 00:03:43,800
the related test however it's quite

00:03:41,250 --> 00:03:46,290
cumbersome and unreliable good luck

00:03:43,800 --> 00:03:52,370
being correct in this Hank picking when

00:03:46,290 --> 00:03:55,230
the dependencies look like this and also

00:03:52,370 --> 00:03:57,959
one of the one of the properties are one

00:03:55,230 --> 00:04:01,800
of the purpose purposes of testitude is

00:03:57,959 --> 00:04:04,620
to discover failure which you didn't

00:04:01,800 --> 00:04:06,900
think of being able to cause with the

00:04:04,620 --> 00:04:10,800
change right influencing something you

00:04:06,900 --> 00:04:12,330
wouldn't wouldn't think of so let's

00:04:10,800 --> 00:04:14,700
explore the idea of affected and

00:04:12,330 --> 00:04:16,980
unaffected and unaffected tests on a

00:04:14,700 --> 00:04:19,350
very simple project comprised of one

00:04:16,980 --> 00:04:21,000
Python file let me have your utmost

00:04:19,350 --> 00:04:23,220
attention and please have a look at this

00:04:21,000 --> 00:04:25,040
grandiose project and try to grasp it

00:04:23,220 --> 00:04:27,800
completely

00:04:25,040 --> 00:04:29,360
for those who you don't we don't know by

00:04:27,800 --> 00:04:30,860
this discovers and drowns any methods

00:04:29,360 --> 00:04:34,570
which are called test to underscore

00:04:30,860 --> 00:04:38,650
something's so this constitutes valid

00:04:34,570 --> 00:04:42,170
testitude including with the death cold

00:04:38,650 --> 00:04:44,150
cold on the test and here we have a grid

00:04:42,170 --> 00:04:46,700
of dependencies between tests and

00:04:44,150 --> 00:04:49,430
methods of particular project whatever

00:04:46,700 --> 00:04:51,350
you do inside the subject method body

00:04:49,430 --> 00:04:56,900
there is no chance you will influence

00:04:51,350 --> 00:04:58,730
test underscore ad have a look at the

00:04:56,900 --> 00:05:01,640
source code again you can hack all the

00:04:58,730 --> 00:05:04,070
inside subtract and test underscore ad

00:05:01,640 --> 00:05:07,340
is not going to be influenced it never

00:05:04,070 --> 00:05:10,370
calls subtract four test underscore add

00:05:07,340 --> 00:05:11,930
add to start calling subtract any of the

00:05:10,370 --> 00:05:16,340
methods it's already calling have to

00:05:11,930 --> 00:05:20,980
change which will trigger execution and

00:05:16,340 --> 00:05:20,980
will create an updated dependency matrix

00:05:21,280 --> 00:05:26,360
so back to the dependency matrix out of

00:05:24,110 --> 00:05:28,700
six positions we have four crossed ones

00:05:26,360 --> 00:05:30,500
so almost all of them but on bigger

00:05:28,700 --> 00:05:32,020
projects the ratio is going to be much

00:05:30,500 --> 00:05:34,610
smaller so there is a lot of methods

00:05:32,020 --> 00:05:37,610
that can be changed and only influence

00:05:34,610 --> 00:05:40,400
small ratio the tests maybe are

00:05:37,610 --> 00:05:43,010
suspicious about how could we track the

00:05:40,400 --> 00:05:44,840
matrix in dynamic language like Python I

00:05:43,010 --> 00:05:46,880
remember feeling the same way when I

00:05:44,840 --> 00:05:48,350
when hearing about coverage reporting

00:05:46,880 --> 00:05:52,310
for the first time I thought that it

00:05:48,350 --> 00:05:53,870
would be fragile slow and unreliable but

00:05:52,310 --> 00:05:57,020
now it's very good it's stable and

00:05:53,870 --> 00:05:58,760
widely used project creating a matrix on

00:05:57,020 --> 00:06:01,840
the slide it's just a little addition to

00:05:58,760 --> 00:06:03,830
coverage by itself it is the same limit

00:06:01,840 --> 00:06:05,690
obviously at the moment it doesn't work

00:06:03,830 --> 00:06:07,880
across technology stakes you cannot

00:06:05,690 --> 00:06:10,160
track execution of C++ code or

00:06:07,880 --> 00:06:13,340
JavaScript trigger from triggered from

00:06:10,160 --> 00:06:16,130
Python it also doesn't track data fail

00:06:13,340 --> 00:06:17,780
that data file changes if that's input

00:06:16,130 --> 00:06:20,180
of your tests and it changes the

00:06:17,780 --> 00:06:22,450
execution path you'll get wrong results

00:06:20,180 --> 00:06:27,440
but for the circumstances where it works

00:06:22,450 --> 00:06:29,690
it works very fine now let me show you a

00:06:27,440 --> 00:06:33,490
tool which automatically executes only

00:06:29,690 --> 00:06:33,490
affected tests on every file change

00:06:36,100 --> 00:06:38,160
you

00:06:39,500 --> 00:06:53,890
three tests to the cutie I change one

00:06:43,280 --> 00:06:53,890
method to another two

00:06:56,210 --> 00:06:58,270
you

00:07:13,540 --> 00:07:19,690
so if you want to be evil a little bit

00:07:15,920 --> 00:07:19,690
you can join two methods

00:07:29,409 --> 00:07:36,309
so it was screencast so that it doesn't

00:07:32,349 --> 00:07:38,860
go wrong on the presentation look how it

00:07:36,309 --> 00:07:42,039
went right or everything went as

00:07:38,860 --> 00:07:46,809
expected so the idea transferred into a

00:07:42,039 --> 00:07:50,489
tool is testimony or pyta statesman

00:07:46,809 --> 00:07:52,659
resides on testimony org page and github

00:07:50,489 --> 00:07:57,239
and let's go briefly through the

00:07:52,659 --> 00:07:57,239
libraries which is which it is based on

00:08:01,050 --> 00:08:06,610
coverage pi it's a giant which which

00:08:05,019 --> 00:08:08,800
allows all these after some

00:08:06,610 --> 00:08:11,169
initialization and executing of this

00:08:08,800 --> 00:08:15,189
code snippet we get the file names and

00:08:11,169 --> 00:08:17,079
line numbers of executed gold coverage

00:08:15,189 --> 00:08:18,639
pies mostly use this command line

00:08:17,079 --> 00:08:21,009
reporting tool but the features of

00:08:18,639 --> 00:08:23,679
courage by which tests on uses are

00:08:21,009 --> 00:08:26,550
almost documented and almost part of the

00:08:23,679 --> 00:08:29,409
API it doesn't sound very good but

00:08:26,550 --> 00:08:32,769
really there is just a little mother to

00:08:29,409 --> 00:08:35,409
undocumented attribute used and also

00:08:32,769 --> 00:08:37,599
that bachelor with outer of coverage by

00:08:35,409 --> 00:08:40,180
reached out when we started with Desmond

00:08:37,599 --> 00:08:43,360
that he would like to know if there is

00:08:40,180 --> 00:08:47,970
any obstacles and and probably also fix

00:08:43,360 --> 00:08:52,240
fix them if something makes problems and

00:08:47,970 --> 00:08:54,790
also Ned would like to add to coverage

00:08:52,240 --> 00:08:59,170
by the functionality the feature to

00:08:54,790 --> 00:09:03,180
track which which tests or which methods

00:08:59,170 --> 00:09:06,550
are actually executing which lines so

00:09:03,180 --> 00:09:09,730
it's exactly the information which we

00:09:06,550 --> 00:09:12,009
are tracking and in this way it could

00:09:09,730 --> 00:09:17,949
convert or there could be and joint

00:09:12,009 --> 00:09:19,930
effort so after executing each test with

00:09:17,949 --> 00:09:21,870
coverage we are getting file names and

00:09:19,930 --> 00:09:24,309
lines of codes triggered by the test

00:09:21,870 --> 00:09:26,740
from there we need to get methods which

00:09:24,309 --> 00:09:28,860
are executed and AST from standard

00:09:26,740 --> 00:09:31,480
libraries could good tool to do that

00:09:28,860 --> 00:09:34,259
that was my first contact with syntax

00:09:31,480 --> 00:09:36,790
tricks when i when i implement it

00:09:34,259 --> 00:09:39,819
testimony from the name you can imagine

00:09:36,790 --> 00:09:42,370
what they are the syntax trees i would

00:09:39,819 --> 00:09:42,700
say they are much more they are not much

00:09:42,370 --> 00:09:44,470
more

00:09:42,700 --> 00:09:46,540
struggling other things in programming

00:09:44,470 --> 00:09:49,360
so for me the word abstract is actually

00:09:46,540 --> 00:09:51,970
quite distracting Testament only needs

00:09:49,360 --> 00:09:54,220
to parse the Python source code and

00:09:51,970 --> 00:09:58,030
understand it enough to know where the

00:09:54,220 --> 00:09:59,950
line boundaries of method body are so

00:09:58,030 --> 00:10:02,410
AST library is a little overkill for

00:09:59,950 --> 00:10:05,050
this but a bit but it's ready and it

00:10:02,410 --> 00:10:07,630
works in all versions of Python also

00:10:05,050 --> 00:10:12,490
future ones and I was glad to learn the

00:10:07,630 --> 00:10:14,830
basics if you would like to be if you

00:10:12,490 --> 00:10:16,740
would be interested in learning clay st

00:10:14,830 --> 00:10:23,460
a little bit more i recommend the two

00:10:16,740 --> 00:10:23,460
resources there to study on the slide

00:10:23,580 --> 00:10:36,010
obviously testimony so by just plugging

00:10:27,850 --> 00:10:40,960
so far Speights seems to have more more

00:10:36,010 --> 00:10:44,230
active community recently and also mum

00:10:40,960 --> 00:10:47,310
here I was surprised too to see more

00:10:44,230 --> 00:10:53,680
hands raised when you and ask about

00:10:47,310 --> 00:10:57,010
about which which test runner you use

00:10:53,680 --> 00:10:58,780
but I know I know and I have the thing

00:10:57,010 --> 00:11:04,510
there's a lot of projects using those

00:10:58,780 --> 00:11:07,120
and not switching anytime soon so I'm

00:11:04,510 --> 00:11:09,730
interested in also porting testament to

00:11:07,120 --> 00:11:12,400
to knows and if if anybody has

00:11:09,730 --> 00:11:14,830
experience in doing some advanced

00:11:12,400 --> 00:11:19,570
stuffing knows i would be glad to to

00:11:14,830 --> 00:11:26,380
torrent and maybe I we we need help with

00:11:19,570 --> 00:11:28,870
that also one interesting aspect of the

00:11:26,380 --> 00:11:32,130
whole project of test moon was that I

00:11:28,870 --> 00:11:36,520
thought that this is a valuable tool

00:11:32,130 --> 00:11:39,270
which many people could use and it would

00:11:36,520 --> 00:11:44,890
save them a lot of time so I asked for

00:11:39,270 --> 00:11:47,980
for money on IndieGoGo and I didn't have

00:11:44,890 --> 00:11:51,010
any followers or blog or any other open

00:11:47,980 --> 00:11:54,460
source tools I used before or developed

00:11:51,010 --> 00:11:55,779
before so it was really difficult to get

00:11:54,460 --> 00:11:57,459
the word out

00:11:55,779 --> 00:12:01,060
still though you know the motive the

00:11:57,459 --> 00:12:03,879
mount got got collected so that was that

00:12:01,060 --> 00:12:05,740
was a nice and inspiring thing and I

00:12:03,879 --> 00:12:06,970
would encourage you if you have if you

00:12:05,740 --> 00:12:11,079
have done something good for the

00:12:06,970 --> 00:12:13,930
community and have blog or followers and

00:12:11,079 --> 00:12:17,290
would like to dedicate your time to to

00:12:13,930 --> 00:12:23,410
do some valuable tool to don't hesitate

00:12:17,290 --> 00:12:29,339
and and use this route I think there

00:12:23,410 --> 00:12:29,339
will be more more feed in the future so

00:12:30,509 --> 00:12:40,569
nice okay a little sneak peek into the

00:12:33,970 --> 00:12:43,629
into the future I hate the way the test

00:12:40,569 --> 00:12:46,540
used results are presented on the

00:12:43,629 --> 00:12:51,639
console I hate scrolling on the console

00:12:46,540 --> 00:12:53,740
and wheeling through the stack traces so

00:12:51,639 --> 00:12:57,819
I was thinking about some better way to

00:12:53,740 --> 00:13:00,639
represent the errors and I think the

00:12:57,819 --> 00:13:03,069
best way would be or the best I can

00:13:00,639 --> 00:13:07,480
think of so far would be to present

00:13:03,069 --> 00:13:10,240
errors inside the text editor you use so

00:13:07,480 --> 00:13:12,100
something similar to to a linter for

00:13:10,240 --> 00:13:20,050
example and this is a screenshot from

00:13:12,100 --> 00:13:23,019
from Adam it has a very good like a way

00:13:20,050 --> 00:13:25,569
an easy way to add a linter and some

00:13:23,019 --> 00:13:28,839
code shaker and in the combination with

00:13:25,569 --> 00:13:31,389
the interactivity of testimony where you

00:13:28,839 --> 00:13:35,500
get when you can get the results really

00:13:31,389 --> 00:13:39,040
quickly I think this is this is the way

00:13:35,500 --> 00:13:41,740
for the future to to make it as a linter

00:13:39,040 --> 00:13:45,009
to of course it's not specific to to

00:13:41,740 --> 00:13:50,559
test on it this would apply to any test

00:13:45,009 --> 00:13:55,089
runner but I think it in the combination

00:13:50,559 --> 00:14:00,939
of the quick feedback and good good

00:13:55,089 --> 00:14:02,649
presentation would be great okay so this

00:14:00,939 --> 00:14:06,750
is the conclusion testimonies awesome

00:14:02,649 --> 00:14:10,620
use it please give me feedback share

00:14:06,750 --> 00:14:14,230
tell your colleagues and so

00:14:10,620 --> 00:14:15,850
this is contacts again and it's time we

00:14:14,230 --> 00:14:28,300
have enough time for questions so I hope

00:14:15,850 --> 00:14:29,230
there's there is many of them please

00:14:28,300 --> 00:14:30,790
raise your hand if you guys have

00:14:29,230 --> 00:14:43,480
questions we'll get the microphone to

00:14:30,790 --> 00:14:46,510
you come on but be shy okay hello is

00:14:43,480 --> 00:14:50,550
there any way to force some tests to run

00:14:46,510 --> 00:14:54,220
all the time like for example I have a

00:14:50,550 --> 00:14:57,780
test that test database trigger and I

00:14:54,220 --> 00:15:01,570
want it to run all the time can I do is

00:14:57,780 --> 00:15:03,730
not yet not yet it's a it doesn't have

00:15:01,570 --> 00:15:05,800
many features so so let's see how it

00:15:03,730 --> 00:15:08,950
goes and it also kept it mean kept

00:15:05,800 --> 00:15:12,510
minimal so that it's easy to study and

00:15:08,950 --> 00:15:16,810
to prove the concept really works and

00:15:12,510 --> 00:15:22,020
then you know adding features is like

00:15:16,810 --> 00:15:24,340
the next step behind yeah go ahead okay

00:15:22,020 --> 00:15:26,110
you show Testament running kind of is a

00:15:24,340 --> 00:15:29,500
process it monitored a bunch of files

00:15:26,110 --> 00:15:31,210
but can it also produce a report that I

00:15:29,500 --> 00:15:33,820
can process on my own or does it have an

00:15:31,210 --> 00:15:36,490
API that I can use to tell me how source

00:15:33,820 --> 00:15:40,090
source code lines map two tests that i

00:15:36,490 --> 00:15:43,060
could use information myself oh no not

00:15:40,090 --> 00:15:45,900
yet I guess that's the like that's the

00:15:43,060 --> 00:15:49,480
addition to coverage that pie i

00:15:45,900 --> 00:15:51,280
mentioned like because if you have some

00:15:49,480 --> 00:15:53,050
I don't know what would be maybe can you

00:15:51,280 --> 00:15:57,640
can you give him the microphone back

00:15:53,050 --> 00:15:59,470
what would be the use or maybe yeah we

00:15:57,640 --> 00:16:06,490
talked about it but maybe you can talk

00:15:59,470 --> 00:16:08,020
that tell the use the UK use case I have

00:16:06,490 --> 00:16:10,780
in mind was from my lightning talk

00:16:08,020 --> 00:16:12,880
yesterday the mutation testing right one

00:16:10,780 --> 00:16:14,350
of the stumbling blocks for that is it

00:16:12,880 --> 00:16:16,000
takes a long time to run all the tests

00:16:14,350 --> 00:16:17,589
inside this these loops so if you can

00:16:16,000 --> 00:16:20,680
determine exactly the tests you want to

00:16:17,589 --> 00:16:22,010
run based on some you know get diff or

00:16:20,680 --> 00:16:24,110
something like that

00:16:22,010 --> 00:16:25,130
you can drastically reduce the run time

00:16:24,110 --> 00:16:26,930
for these kinds of things and make them

00:16:25,130 --> 00:16:28,010
practical so that would be where

00:16:26,930 --> 00:16:29,630
something like this could come in really

00:16:28,010 --> 00:16:32,330
handy for that kind of work that's why I

00:16:29,630 --> 00:16:33,740
was mourning it I can't see how I'm just

00:16:32,330 --> 00:16:36,380
trying I'm trying to envision how I

00:16:33,740 --> 00:16:39,740
could use this to to make to make my

00:16:36,380 --> 00:16:41,570
stuff work better yeah well I said there

00:16:39,740 --> 00:16:44,120
is not many features and there is no api

00:16:41,570 --> 00:16:46,190
so but it's really really small tool so

00:16:44,120 --> 00:16:49,240
it would be easy to add any of those

00:16:46,190 --> 00:16:49,240
look at this point

00:16:59,710 --> 00:17:08,400
um yeah I how do you test test one good

00:17:04,570 --> 00:17:10,810
question it has a pursuit but I haven't

00:17:08,400 --> 00:17:15,250
there is a problem in calling coverage

00:17:10,810 --> 00:17:18,070
by Erick rusev Lee all right so I can

00:17:15,250 --> 00:17:21,280
have a test shoot but I cannot use the

00:17:18,070 --> 00:17:25,360
plug-in itself which is a little bit of

00:17:21,280 --> 00:17:27,339
a bummer but but yeah there is also

00:17:25,360 --> 00:17:31,090
solution I could on the parts which are

00:17:27,339 --> 00:17:33,130
which rely on the coverage the next

00:17:31,090 --> 00:17:37,780
feature would be to test known to add

00:17:33,130 --> 00:17:41,490
would be to a manually specify methods

00:17:37,780 --> 00:17:46,120
and tests to manually specify the

00:17:41,490 --> 00:17:49,270
dependency so that even if the tracking

00:17:46,120 --> 00:17:53,890
is lost in the recursion it would to

00:17:49,270 --> 00:17:56,680
work and does it track changes that you

00:17:53,890 --> 00:17:58,540
make in pilot test fixtures as well so

00:17:56,680 --> 00:18:01,420
if you update a fixture will it detected

00:17:58,540 --> 00:18:03,550
as part of well if its data files

00:18:01,420 --> 00:18:05,950
features if it's um Jason and like

00:18:03,550 --> 00:18:07,540
what's jungle fixtures right then oh

00:18:05,950 --> 00:18:11,380
that was one of the things I mentioned

00:18:07,540 --> 00:18:15,910
that it doesn't work when you know

00:18:11,380 --> 00:18:19,240
across across technology stacks and it

00:18:15,910 --> 00:18:21,190
doesn't work then you have data file

00:18:19,240 --> 00:18:24,640
input or some inputs from external

00:18:21,190 --> 00:18:27,310
services so ideally you would have a

00:18:24,640 --> 00:18:30,040
test shoot which constructs everything

00:18:27,310 --> 00:18:32,110
in Python code also the fixtures then

00:18:30,040 --> 00:18:36,360
it's a then it's then it's a Python code

00:18:32,110 --> 00:18:36,360
and it's tracked execution

00:18:39,259 --> 00:18:44,220
and could you go back to the little

00:18:42,570 --> 00:18:48,539
example you gave with the subtraction

00:18:44,220 --> 00:18:50,460
edition stuff yep so what you did not

00:18:48,539 --> 00:18:54,899
show in the the little screen cast was

00:18:50,460 --> 00:18:58,409
what if thus abstract methods gained a

00:18:54,899 --> 00:19:01,159
call to add how would it deal with that

00:18:58,409 --> 00:19:05,549
so you had a new dependency vegetated

00:19:01,159 --> 00:19:07,080
2211 function right how would it know

00:19:05,549 --> 00:19:09,409
that we didn't know that after running

00:19:07,080 --> 00:19:14,159
the test ones or when we wouldn't notice

00:19:09,409 --> 00:19:18,899
if you add a call of ADD method to

00:19:14,159 --> 00:19:22,919
subtract metal yeah right the subtract

00:19:18,899 --> 00:19:25,379
method is called by two tests right so

00:19:22,919 --> 00:19:28,919
all of them would be both of them would

00:19:25,379 --> 00:19:31,799
be Rex acute it that's subtraction test

00:19:28,919 --> 00:19:34,859
both the test ad would be and it's now a

00:19:31,799 --> 00:19:36,629
new dependency in substrate it wouldn't

00:19:34,859 --> 00:19:39,359
be an it wouldn't gain the dependency

00:19:36,629 --> 00:19:42,649
also right so there's a new dependency

00:19:39,359 --> 00:19:46,289
because subtract now called ad and the

00:19:42,649 --> 00:19:49,710
test air doesn't call subtract ok got it

00:19:46,289 --> 00:19:52,200
ok my fault thanks also that's a good

00:19:49,710 --> 00:19:56,730
remark like we've been using the test on

00:19:52,200 --> 00:19:58,429
the one of the project and most of the

00:19:56,730 --> 00:20:01,980
bug reports have been like this

00:19:58,429 --> 00:20:04,070
fortunately so so we found out that

00:20:01,980 --> 00:20:08,309
testimony is right which which is quite

00:20:04,070 --> 00:20:10,889
quite a good surprise because because

00:20:08,309 --> 00:20:13,109
yeah I also was afraid that it's going

00:20:10,889 --> 00:20:16,710
to be fragile and and start but the

00:20:13,109 --> 00:20:19,289
biggest problem actually is that tests

00:20:16,710 --> 00:20:21,389
are dependent independent even if you

00:20:19,289 --> 00:20:23,779
don't know about it there is some

00:20:21,389 --> 00:20:26,869
fixtures which that doesn't get

00:20:23,779 --> 00:20:29,669
initialized or something like that so

00:20:26,869 --> 00:20:33,090
then you get failures because there's no

00:20:29,669 --> 00:20:35,159
no always runs some other dynamic subset

00:20:33,090 --> 00:20:36,840
of your test you that which doesn't

00:20:35,159 --> 00:20:39,299
happen and many in any other

00:20:36,840 --> 00:20:42,179
circumstances so so that's like the

00:20:39,299 --> 00:20:46,019
biggest problem another thing ok next

00:20:42,179 --> 00:20:48,690
question if my test cause a helper

00:20:46,019 --> 00:20:50,639
function sorry if my test calls a helper

00:20:48,690 --> 00:20:51,680
function and the help of function

00:20:50,639 --> 00:20:56,390
changes

00:20:51,680 --> 00:20:59,930
good NHS yeah because it's the part of

00:20:56,390 --> 00:21:04,850
the tree yes oh it's not the part of the

00:20:59,930 --> 00:21:08,240
tree it's part of the execution I well

00:21:04,850 --> 00:21:13,790
the syntax tree or the ast parsing is

00:21:08,240 --> 00:21:15,770
only used at the end of the whole

00:21:13,790 --> 00:21:17,450
analysis and it's not that important

00:21:15,770 --> 00:21:22,180
that the important thing here is that

00:21:17,450 --> 00:21:26,510
when you run the test and you the test

00:21:22,180 --> 00:21:29,090
cause the helper function it's in the

00:21:26,510 --> 00:21:32,030
list of executed lines and executed

00:21:29,090 --> 00:21:34,250
methods of the of that test and it's in

00:21:32,030 --> 00:21:36,890
the dependency matrix it will appear as

00:21:34,250 --> 00:21:38,240
a dependency so that probably answers

00:21:36,890 --> 00:21:41,290
flourish this question which was about

00:21:38,240 --> 00:21:44,480
Titus pictures not about a data file

00:21:41,290 --> 00:21:45,860
about text file hi test fixtures in

00:21:44,480 --> 00:21:47,570
other words it was a question about

00:21:45,860 --> 00:21:51,470
staying in the Python world not a

00:21:47,570 --> 00:21:53,720
question about Jason fixtures yeah it

00:21:51,470 --> 00:21:56,210
that answers the question yes I think

00:21:53,720 --> 00:22:00,740
sisters are are created by a method tour

00:21:56,210 --> 00:22:03,710
right so so it's going to get tracked um

00:22:00,740 --> 00:22:05,420
does it how does it restart the test

00:22:03,710 --> 00:22:07,540
runner is in it does it restart the

00:22:05,420 --> 00:22:10,580
entire process oh this is very good

00:22:07,540 --> 00:22:13,430
focus testimony is implemented as a

00:22:10,580 --> 00:22:15,770
pilot test plug in right so how does it

00:22:13,430 --> 00:22:18,080
restart the test run when it tries to

00:22:15,770 --> 00:22:20,990
run new tests as in how does it affect

00:22:18,080 --> 00:22:23,060
session scope fixtures or do you restart

00:22:20,990 --> 00:22:28,160
the entire process or exactly how does

00:22:23,060 --> 00:22:31,520
not work well I I'm not sure about the

00:22:28,160 --> 00:22:34,520
session session sculpt fixtures it

00:22:31,520 --> 00:22:36,650
really depends on the changes or are you

00:22:34,520 --> 00:22:39,770
asking about the round time itself like

00:22:36,650 --> 00:22:42,020
I can about about the fiction setup and

00:22:39,770 --> 00:22:43,550
teardown basically so after it's running

00:22:42,020 --> 00:22:45,890
a couple of tests will attend down all

00:22:43,550 --> 00:22:48,830
the fixtures and restart them again next

00:22:45,890 --> 00:22:52,790
test or digits I'm not sure this might

00:22:48,830 --> 00:22:55,340
be well not tested yet I'm not sure how

00:22:52,790 --> 00:22:58,040
it could behave so that a session

00:22:55,340 --> 00:22:59,450
fixture is you know always run if I

00:22:58,040 --> 00:23:02,090
understand correctly always around just

00:22:59,450 --> 00:23:05,299
one since in the beginning of the test

00:23:02,090 --> 00:23:08,799
execution right

00:23:05,299 --> 00:23:12,070
and if you change anything in there that

00:23:08,799 --> 00:23:17,779
probably it's not tracked because the

00:23:12,070 --> 00:23:20,659
specific test doesn't execute any of the

00:23:17,779 --> 00:23:24,669
session picture right so that wouldn't

00:23:20,659 --> 00:23:29,830
wouldn't get caught wouldn't get

00:23:24,669 --> 00:23:29,830
registered as a as a dependency

00:23:39,499 --> 00:23:47,159
do you understand correctly that if the

00:23:44,039 --> 00:23:50,899
function does something nasty for

00:23:47,159 --> 00:23:53,970
example change some global value and

00:23:50,899 --> 00:23:58,169
other function depends on it on this

00:23:53,970 --> 00:24:00,600
global value so we canna can broke can

00:23:58,169 --> 00:24:05,429
break the function which you haven't

00:24:00,600 --> 00:24:09,450
edited and we the tests will not run for

00:24:05,429 --> 00:24:12,809
the odd function for the old one it this

00:24:09,450 --> 00:24:17,549
is quite difficult to explain but you

00:24:12,809 --> 00:24:20,309
know if that evil function changes some

00:24:17,549 --> 00:24:23,759
global value it will appear in the

00:24:20,309 --> 00:24:26,399
dependency matrix either it's called by

00:24:23,759 --> 00:24:31,379
a test or it's not for every single test

00:24:26,399 --> 00:24:33,659
you can say that and for the tests which

00:24:31,379 --> 00:24:36,059
do not call the function it doesn't

00:24:33,659 --> 00:24:38,700
matter what the evil function do the

00:24:36,059 --> 00:24:43,289
world can explode in that function but

00:24:38,700 --> 00:24:48,570
the tests are not executed the tests do

00:24:43,289 --> 00:24:51,479
not execute it so for example if if my

00:24:48,570 --> 00:24:53,970
function depends on the state the

00:24:51,479 --> 00:24:57,989
function function a depends on the state

00:24:53,970 --> 00:25:01,259
and then I have function be that starts

00:24:57,989 --> 00:25:04,759
to modify this state and makes in

00:25:01,259 --> 00:25:08,729
runtime makes my original function break

00:25:04,759 --> 00:25:13,950
how well that either whether this is a

00:25:08,729 --> 00:25:16,950
test to dependency right because the

00:25:13,950 --> 00:25:21,200
evil function gets called in test 1 and

00:25:16,950 --> 00:25:23,999
then the test two relies on that on that

00:25:21,200 --> 00:25:25,919
under global value so that's what I

00:25:23,999 --> 00:25:29,940
called test dependency and I talked

00:25:25,919 --> 00:25:32,129
about that would be a problem but if

00:25:29,940 --> 00:25:34,499
there is you know if the tests are

00:25:32,129 --> 00:25:36,599
independent and the test two doesn't

00:25:34,499 --> 00:25:38,970
rely on the value and resets it again or

00:25:36,599 --> 00:25:42,359
doesn't use the value it doesn't matter

00:25:38,970 --> 00:25:46,399
it gets registered or or it it works as

00:25:42,359 --> 00:25:46,399
it should okay

00:25:53,520 --> 00:25:59,580

YouTube URL: https://www.youtube.com/watch?v=nrSZthcAN2U


