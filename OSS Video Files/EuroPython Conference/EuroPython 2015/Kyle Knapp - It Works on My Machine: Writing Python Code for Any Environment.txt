Title: Kyle Knapp - It Works on My Machine: Writing Python Code for Any Environment
Publication date: 2015-08-08
Playlist: EuroPython 2015
Description: 
	Kyle Knapp - It Works on My Machine: Writing Python Code for Any Environment
[EuroPython 2015]
[20 July 2015]
[Bilbao, Euskadi, Spain]

Have you ever developed a nice, well-working python program on one
environment, only to have it blow up with exceptions and tracebacks
when you run it on a different environment? Have no fear! This talk
will show you how to write and maintain python code that is compatible
across environments that may differ by python versions and/or
operating systems.

Techniques and tips will be drawn from lessons and experiences gained
from making the AWS CLI, a python-based command line tool to manage
AWS resources, compatible across a wide range of environments. In a
case-study-like format, real-life compatibility issues encountered
while developing the AWS CLI will be presented along with how we
resolved each of them. These real-life examples will encompass, but
will not be limited to, the following topics:

• How to use functions and classes that may differ across python
versions and/or operating systems

• How to handle version-specific bugs

• How to handle strings, bytes, and Unicode across python versions

• How to handle differing locale settings

• How to handle file operations across operating systems

• How and when to vendor dependencies

• How to write tests that are compatible across python versions and
operating systems

• How to create a testing environment that monitors compatibility of
code across various environments

Ultimately, the goal of these examples is introduce to you some
effective, real-world programming practices to overcome your current
or next compatibility issue.
Captions: 
	00:00:00,000 --> 00:00:05,160
go all right hi everyone my name is Kyle

00:00:02,970 --> 00:00:07,470
Knapp and I am a software developer at

00:00:05,160 --> 00:00:10,200
AWS where I primarily focus on

00:00:07,470 --> 00:00:12,570
developing the 18 best Python SDK also

00:00:10,200 --> 00:00:14,400
known as bodo and the a degree of COI

00:00:12,570 --> 00:00:15,990
which is a python-based command-line

00:00:14,400 --> 00:00:18,330
interface for managing your alias

00:00:15,990 --> 00:00:20,039
resources and this is my talk it works

00:00:18,330 --> 00:00:25,740
on my machine writing Python code for

00:00:20,039 --> 00:00:27,570
any of our what that graphics but must

00:00:25,740 --> 00:00:31,969
be there um so does this look familiar

00:00:27,570 --> 00:00:34,530
where that you start developing on a

00:00:31,969 --> 00:00:38,850
Hutt you start developing on your own

00:00:34,530 --> 00:00:40,170
machine and it works fine and so you

00:00:38,850 --> 00:00:43,079
decide you're going to push it to

00:00:40,170 --> 00:00:46,829
another computer say it's a server or a

00:00:43,079 --> 00:00:49,379
or a github repo or another colleague

00:00:46,829 --> 00:00:50,850
that might be using it they're supposed

00:00:49,379 --> 00:00:52,320
to be there supposed to be a graphic

00:00:50,850 --> 00:00:53,879
that kind of goes around showing it

00:00:52,320 --> 00:00:56,670
fails at the end once you get the

00:00:53,879 --> 00:00:58,469
success but see how that works okay so

00:00:56,670 --> 00:01:01,050
you may be wondering why does

00:00:58,469 --> 00:01:03,149
compatibility matter if it works in my

00:01:01,050 --> 00:01:05,540
environment why do why would I care that

00:01:03,149 --> 00:01:08,670
it works on something somebody else's

00:01:05,540 --> 00:01:13,260
well if you ever want to adopt more

00:01:08,670 --> 00:01:14,250
users for your program most users are

00:01:13,260 --> 00:01:15,570
not going to be running on the same

00:01:14,250 --> 00:01:16,830
environment as you they're going to be

00:01:15,570 --> 00:01:18,869
using a different Python version a

00:01:16,830 --> 00:01:20,040
different operating system and therefore

00:01:18,869 --> 00:01:23,180
it's important that you're able you

00:01:20,040 --> 00:01:23,180
could be able to run it successfully

00:01:23,479 --> 00:01:28,020
secondly usability helps drive

00:01:26,090 --> 00:01:30,470
popularity when there's no barriers to

00:01:28,020 --> 00:01:33,960
entry to actually use your program it

00:01:30,470 --> 00:01:36,689
helps widen the range of possible users

00:01:33,960 --> 00:01:39,420
many popular Python programs out there

00:01:36,689 --> 00:01:41,579
such as Django Flass requests they all

00:01:39,420 --> 00:01:43,049
used they all have compatibility across

00:01:41,579 --> 00:01:46,439
a bunch of different operating systems

00:01:43,049 --> 00:01:49,920
in Python versions and finally most of

00:01:46,439 --> 00:01:51,720
the time it is not difficult to ensure

00:01:49,920 --> 00:01:54,090
compatibility across the different

00:01:51,720 --> 00:01:55,740
environments often times it's just a

00:01:54,090 --> 00:01:57,479
line here and there oftentimes is a

00:01:55,740 --> 00:02:00,090
little bit a couple times it's a little

00:01:57,479 --> 00:02:02,460
bit more difficult but let me go over

00:02:00,090 --> 00:02:04,140
what will be covered in stock first

00:02:02,460 --> 00:02:06,360
going to go into background about the

00:02:04,140 --> 00:02:10,259
sample application that most of the

00:02:06,360 --> 00:02:12,090
topics internet be based around then I'm

00:02:10,259 --> 00:02:13,120
going to talk about the different Python

00:02:12,090 --> 00:02:16,000
versions and how

00:02:13,120 --> 00:02:17,230
to ensure compatibility across that I'm

00:02:16,000 --> 00:02:19,120
going to talk about how to get

00:02:17,230 --> 00:02:21,640
compatibility across operating systems

00:02:19,120 --> 00:02:26,409
and finally how to write tests to ensure

00:02:21,640 --> 00:02:27,610
compatibility and help improve it so the

00:02:26,409 --> 00:02:29,470
sample application I can be talking

00:02:27,610 --> 00:02:31,480
about is the 80s command-line interface

00:02:29,470 --> 00:02:34,599
like I said before it's a python-based

00:02:31,480 --> 00:02:37,120
Co I used for managing your AWS

00:02:34,599 --> 00:02:38,560
resources I decided to choose this

00:02:37,120 --> 00:02:41,260
application because I have a lot of

00:02:38,560 --> 00:02:43,450
experience with it and in the end it to

00:02:41,260 --> 00:02:45,450
see it's SEO lai most users are not

00:02:43,450 --> 00:02:48,010
Python developers are not concerned with

00:02:45,450 --> 00:02:49,209
what python versions are running or the

00:02:48,010 --> 00:02:51,190
operating system they just wanted to

00:02:49,209 --> 00:02:53,769
work in the shell and so many of the

00:02:51,190 --> 00:02:58,390
topics i'm going to cover our base from

00:02:53,769 --> 00:03:01,659
my experience working on the CLI the AWC

00:02:58,390 --> 00:03:04,209
oh I is compatible on Python versions to

00:03:01,659 --> 00:03:07,329
from 265 and higher in Python 3 verses

00:03:04,209 --> 00:03:08,680
33 and higher and is also compatible on

00:03:07,329 --> 00:03:13,750
a bunch of different operating systems

00:03:08,680 --> 00:03:15,310
such as Linux Mac unix and windows so

00:03:13,750 --> 00:03:17,230
the first topic I'm going to cover in

00:03:15,310 --> 00:03:21,069
terms of compatibility is Python

00:03:17,230 --> 00:03:23,620
versions this some of the subtopics I'm

00:03:21,069 --> 00:03:24,910
going to cover our renaming the

00:03:23,620 --> 00:03:27,280
differences in string types across

00:03:24,910 --> 00:03:31,000
Python versions and the possible

00:03:27,280 --> 00:03:32,530
limitations you may run to so with

00:03:31,000 --> 00:03:34,810
renaming a lot of times when you're

00:03:32,530 --> 00:03:37,780
working with a across Python major

00:03:34,810 --> 00:03:41,019
versions the modules or the classes or

00:03:37,780 --> 00:03:43,590
the functions may be renamed and this

00:03:41,019 --> 00:03:46,720
hat wait when ever developing on CL I

00:03:43,590 --> 00:03:48,099
sometimes run into this and the question

00:03:46,720 --> 00:03:51,160
you may be asking how do you handle that

00:03:48,099 --> 00:03:54,669
renaming the most general solution is to

00:03:51,160 --> 00:03:57,489
use 66 is a compatibility library to

00:03:54,669 --> 00:04:00,280
help you write Python code as compatible

00:03:57,489 --> 00:04:01,900
across Python 2 and Python 3 and it will

00:04:00,280 --> 00:04:05,440
handle a lot of these conversions for

00:04:01,900 --> 00:04:07,480
you so here's an example the class

00:04:05,440 --> 00:04:10,239
string i/o which is a class that wraps

00:04:07,480 --> 00:04:11,349
data into a file like object and Python

00:04:10,239 --> 00:04:13,660
2 you've imported from the string i/o

00:04:11,349 --> 00:04:16,419
library but in Python 3 you import it

00:04:13,660 --> 00:04:19,000
from the i/o library the issue here is

00:04:16,419 --> 00:04:21,159
if you wrote a python to style of

00:04:19,000 --> 00:04:23,409
formatting it and you ran on Python 3

00:04:21,159 --> 00:04:25,930
code you'll get a bunch of importers but

00:04:23,409 --> 00:04:26,770
fortunately the solution is quite simple

00:04:25,930 --> 00:04:29,889
thanks

00:04:26,770 --> 00:04:32,340
six you can just simply import six or

00:04:29,889 --> 00:04:34,569
import string 0 from the six library

00:04:32,340 --> 00:04:36,250
however this brings up the edge case of

00:04:34,569 --> 00:04:38,530
what happens when there's no six

00:04:36,250 --> 00:04:40,090
compatibility for example in the CLI we

00:04:38,530 --> 00:04:43,000
have to use the format date function

00:04:40,090 --> 00:04:44,560
which is a function that returns a

00:04:43,000 --> 00:04:46,930
string in the form of what you expect to

00:04:44,560 --> 00:04:49,479
see in an email and Python to you import

00:04:46,930 --> 00:04:52,659
from emailed capital u Dalls and from

00:04:49,479 --> 00:04:54,729
Python 3 you import it from lowercase

00:04:52,659 --> 00:04:59,139
util and like I said before there's no

00:04:54,729 --> 00:05:00,280
six conversion for you so the solution

00:04:59,139 --> 00:05:01,990
of that is to have your own

00:05:00,280 --> 00:05:03,819
compatibility module to handle all these

00:05:01,990 --> 00:05:05,620
conversions a lot of the projects I work

00:05:03,819 --> 00:05:08,919
on their call it's called a compatible

00:05:05,620 --> 00:05:10,479
why file and simply just have this logic

00:05:08,919 --> 00:05:12,520
first to check to see what the Python

00:05:10,479 --> 00:05:14,620
version you're working on and if it's

00:05:12,520 --> 00:05:16,360
Python for example if it's Python 3 you

00:05:14,620 --> 00:05:19,210
import the Python free version of doing

00:05:16,360 --> 00:05:21,520
of importing format date and if it's

00:05:19,210 --> 00:05:25,150
Python to you just do the Python 2

00:05:21,520 --> 00:05:26,319
version of it then to build on top of

00:05:25,150 --> 00:05:27,940
that whenever you need to actually use

00:05:26,319 --> 00:05:31,000
format date you just import it directly

00:05:27,940 --> 00:05:34,360
from the compat module note that it's a

00:05:31,000 --> 00:05:36,789
lot better to use the bot at the bottom

00:05:34,360 --> 00:05:38,860
way of importation speak instead of

00:05:36,789 --> 00:05:40,449
having this code block in every single

00:05:38,860 --> 00:05:41,889
file you need this format date because

00:05:40,449 --> 00:05:42,940
if you ever want to change the logic

00:05:41,889 --> 00:05:46,180
you'll have to change in every single

00:05:42,940 --> 00:05:47,710
spot so the lessons learned here is you

00:05:46,180 --> 00:05:50,259
six it's great for handling all those

00:05:47,710 --> 00:05:52,599
compatibility those name conviction jizz

00:05:50,259 --> 00:05:56,650
across Python versions and if you can't

00:05:52,599 --> 00:05:59,099
do it use the compatible I filed so now

00:05:56,650 --> 00:06:01,840
we've talked about renaming there's also

00:05:59,099 --> 00:06:04,599
string type differences across all the

00:06:01,840 --> 00:06:06,099
different Python versions so you'll get

00:06:04,599 --> 00:06:07,389
a change a name and also change and

00:06:06,099 --> 00:06:11,529
functionality that you actually will

00:06:07,389 --> 00:06:14,289
have to handle so in one example of how

00:06:11,529 --> 00:06:17,529
to handle string types is input to the

00:06:14,289 --> 00:06:21,039
CLI so it with input the CLI will have a

00:06:17,529 --> 00:06:22,960
bunch of different types of input we

00:06:21,039 --> 00:06:25,690
could be receiving and here's an example

00:06:22,960 --> 00:06:27,940
of a CLI commands so we're trying to run

00:06:25,690 --> 00:06:30,460
the EC to describe regions command which

00:06:27,940 --> 00:06:32,110
will just print out what regions are

00:06:30,460 --> 00:06:36,729
available for you and you see two and

00:06:32,110 --> 00:06:38,949
the input we apply is Regents names the

00:06:36,729 --> 00:06:40,270
value being us west to underneath the

00:06:38,949 --> 00:06:41,830
CLI it would be using it

00:06:40,270 --> 00:06:43,690
uses the art parce library to create a

00:06:41,830 --> 00:06:46,330
namespace of all the inputs that got

00:06:43,690 --> 00:06:49,050
received and inside of this namespace

00:06:46,330 --> 00:06:51,880
the values may differ even across

00:06:49,050 --> 00:06:53,170
strength data types so across different

00:06:51,880 --> 00:06:55,630
Python versions you can have different

00:06:53,170 --> 00:06:57,370
string types so I keep talking about

00:06:55,630 --> 00:06:59,920
this this Python string type so let me

00:06:57,370 --> 00:07:02,710
cover them now and there's two ways to

00:06:59,920 --> 00:07:04,810
represent Python strings there is string

00:07:02,710 --> 00:07:08,460
data represented as bytes and string

00:07:04,810 --> 00:07:12,160
data represented as unicode in Python to

00:07:08,460 --> 00:07:14,740
the string class is string data

00:07:12,160 --> 00:07:17,080
represented as binary and Unicode class

00:07:14,740 --> 00:07:20,080
is string data represented as Unicode

00:07:17,080 --> 00:07:23,050
and then this changes though in Python 3

00:07:20,080 --> 00:07:25,840
and Python 3 bytes is the class that

00:07:23,050 --> 00:07:28,660
represents string data is binary and

00:07:25,840 --> 00:07:30,910
string is the class that represents

00:07:28,660 --> 00:07:34,360
string data as Unicode so that can be

00:07:30,910 --> 00:07:36,340
kind of confusing wrap the bad to put on

00:07:34,360 --> 00:07:37,990
put more on top of that there's

00:07:36,340 --> 00:07:40,660
different functionality between the two

00:07:37,990 --> 00:07:42,520
Python classes our Python versions so

00:07:40,660 --> 00:07:43,810
for example if you try to mix the two

00:07:42,520 --> 00:07:45,520
different string type so here we're

00:07:43,810 --> 00:07:48,610
trying to concatenate a byte string foo

00:07:45,520 --> 00:07:50,620
with a unicode strength bar pythons here

00:07:48,610 --> 00:07:53,440
we'll do some implicit complicit

00:07:50,620 --> 00:07:55,270
decoding for you such that when you

00:07:53,440 --> 00:07:58,750
concatenate the two together you'll get

00:07:55,270 --> 00:08:01,000
the Unicode string foo bar by decoding

00:07:58,750 --> 00:08:03,520
foo first and then adding the two

00:08:01,000 --> 00:08:06,070
together however this can cause issues

00:08:03,520 --> 00:08:07,690
for you if you take this example right

00:08:06,070 --> 00:08:09,460
here where you take the bike string e 2

00:08:07,690 --> 00:08:11,860
and can you go through this Unicode

00:08:09,460 --> 00:08:14,920
string bar you'll get decoding errors

00:08:11,860 --> 00:08:16,690
where it tries to decode the e tube byte

00:08:14,920 --> 00:08:20,440
string but it can't because it's a ski

00:08:16,690 --> 00:08:21,820
and it's out of range in Python for me

00:08:20,440 --> 00:08:23,470
it's a little bit more strict on how to

00:08:21,820 --> 00:08:25,810
handle this so if you take the same line

00:08:23,470 --> 00:08:27,490
as before you'll just get the error you

00:08:25,810 --> 00:08:29,260
can can't you can't concatenate bytes to

00:08:27,490 --> 00:08:34,780
string and straight up and you won't get

00:08:29,260 --> 00:08:37,450
have a bag message so the problem here

00:08:34,780 --> 00:08:39,010
is how do you handle this when

00:08:37,450 --> 00:08:40,750
especially when you have no control of

00:08:39,010 --> 00:08:43,240
the inputs that you may be receiving and

00:08:40,750 --> 00:08:48,780
you know that mixing string data types

00:08:43,240 --> 00:08:52,600
is not good so the solution that we

00:08:48,780 --> 00:08:53,840
found through my development is to

00:08:52,600 --> 00:08:57,020
ensure that the string

00:08:53,840 --> 00:08:59,660
consistency is consistent right off the

00:08:57,020 --> 00:09:02,450
get-go for input to your program so take

00:08:59,660 --> 00:09:05,420
this take this method or this method

00:09:02,450 --> 00:09:08,720
that we use when we receive an art parse

00:09:05,420 --> 00:09:10,580
namespace the method parson arch takes

00:09:08,720 --> 00:09:12,980
to the namespace here it first

00:09:10,580 --> 00:09:15,170
determines what the terminal encoding is

00:09:12,980 --> 00:09:17,060
being used for standard input and then

00:09:15,170 --> 00:09:21,980
what it will do is will iterate through

00:09:17,060 --> 00:09:24,260
each namespace and that was provided and

00:09:21,980 --> 00:09:26,450
to determine if there's any string to

00:09:24,260 --> 00:09:28,820
string binary types so for example here

00:09:26,450 --> 00:09:30,800
we're using six which has a useful

00:09:28,820 --> 00:09:32,360
helper method determines if the string

00:09:30,800 --> 00:09:33,770
data is represented binary depending on

00:09:32,360 --> 00:09:37,040
what Python version you're running on

00:09:33,770 --> 00:09:39,470
and if it is binary we determined to

00:09:37,040 --> 00:09:42,260
decode it to a string data type

00:09:39,470 --> 00:09:44,770
represents Unicode such that any string

00:09:42,260 --> 00:09:48,710
data type and the namespace is

00:09:44,770 --> 00:09:50,750
represented as Unicode so lessons

00:09:48,710 --> 00:09:52,850
learned here is that Python strings

00:09:50,750 --> 00:09:55,100
differ semantically and functionally and

00:09:52,850 --> 00:09:57,290
you do not want to mix the string data

00:09:55,100 --> 00:09:58,640
types especially at the in the palace

00:09:57,290 --> 00:10:00,410
zebra project because this can be very

00:09:58,640 --> 00:10:02,540
hard to trace back what happened what

00:10:00,410 --> 00:10:04,130
went wrong and to do so make sure you

00:10:02,540 --> 00:10:07,820
ensure that the type is going to consist

00:10:04,130 --> 00:10:09,140
in as soon as possible so I've been

00:10:07,820 --> 00:10:11,900
talking about a lot of these three

00:10:09,140 --> 00:10:13,910
namings and change the functionality but

00:10:11,900 --> 00:10:16,180
what happens when the there's the

00:10:13,910 --> 00:10:19,160
functionality straight up doesn't exist

00:10:16,180 --> 00:10:21,260
for when developing on the CLI there's a

00:10:19,160 --> 00:10:23,870
couple occasions where there is no

00:10:21,260 --> 00:10:27,080
functionality especially for Python

00:10:23,870 --> 00:10:30,220
version 26 and our solution to that is

00:10:27,080 --> 00:10:33,590
to actually backport the functionality

00:10:30,220 --> 00:10:36,470
an example of a back port is the order

00:10:33,590 --> 00:10:37,910
dick class it's a pipe it's an ordered

00:10:36,470 --> 00:10:39,260
dictionary that keeps track of when you

00:10:37,910 --> 00:10:41,630
insert your keys into the dictionary

00:10:39,260 --> 00:10:44,360
it's in Python 27 and higher but not in

00:10:41,630 --> 00:10:45,740
Python 26 and we don't add this

00:10:44,360 --> 00:10:49,370
functionality from scratch it's a pretty

00:10:45,740 --> 00:10:51,520
large class to be writing by hand so how

00:10:49,370 --> 00:10:53,780
do you would you go about doing this

00:10:51,520 --> 00:10:55,610
first you would want to add a

00:10:53,780 --> 00:10:56,990
conditional dependency fortunately

00:10:55,610 --> 00:10:59,570
there's a third party package that

00:10:56,990 --> 00:11:01,370
implements order for us and we

00:10:59,570 --> 00:11:03,770
can pull that in as a conditional penisy

00:11:01,370 --> 00:11:06,650
so take a take this snippet of code from

00:11:03,770 --> 00:11:07,640
our setup py file and we take our

00:11:06,650 --> 00:11:10,130
original requirement or

00:11:07,640 --> 00:11:13,490
our normal requirement and then we use

00:11:10,130 --> 00:11:15,890
the system version info tuple and

00:11:13,490 --> 00:11:17,660
determine if the Python version is 26

00:11:15,890 --> 00:11:20,090
and if it is will actually append this

00:11:17,660 --> 00:11:23,690
new conditional appendices into the into

00:11:20,090 --> 00:11:27,650
the requirements then the second step in

00:11:23,690 --> 00:11:29,840
order to make to hide the lack of

00:11:27,650 --> 00:11:33,230
functionality is to import it using the

00:11:29,840 --> 00:11:35,330
compatible file in this case here's an

00:11:33,230 --> 00:11:37,700
example snippet where we first try to

00:11:35,330 --> 00:11:40,130
import order from where we

00:11:37,700 --> 00:11:41,990
expected to be if it was Python 27 which

00:11:40,130 --> 00:11:43,850
is a collections library if not we'll

00:11:41,990 --> 00:11:47,780
import it from the third party package

00:11:43,850 --> 00:11:49,370
that we pulled in so the lessons learned

00:11:47,780 --> 00:11:51,710
is you may have needed back board when

00:11:49,370 --> 00:11:53,510
needed but you want to make sure you

00:11:51,710 --> 00:11:54,950
limit the effect on untargeted python

00:11:53,510 --> 00:11:56,780
versions especially with the

00:11:54,950 --> 00:11:59,330
dependencies you want to make sure that

00:11:56,780 --> 00:12:01,070
you are not pulling in an unnecessary

00:11:59,330 --> 00:12:02,480
dependency especially for like Python 27

00:12:01,070 --> 00:12:06,140
you don't need ordered because

00:12:02,480 --> 00:12:08,570
it's already in the library for you so

00:12:06,140 --> 00:12:11,270
next I'm going to talk about operating

00:12:08,570 --> 00:12:12,500
systems and how to get compatibility

00:12:11,270 --> 00:12:13,940
across all the different operating a

00:12:12,500 --> 00:12:17,360
bunch of our operating systems you may

00:12:13,940 --> 00:12:19,550
run into so the first topic I'm going to

00:12:17,360 --> 00:12:20,990
talk about is file handling then I'm

00:12:19,550 --> 00:12:23,240
gonna talk about how to handle file pass

00:12:20,990 --> 00:12:25,160
and then finally fact functionality and

00:12:23,240 --> 00:12:27,590
lack of functionality or how may differ

00:12:25,160 --> 00:12:29,630
across operating systems so file

00:12:27,590 --> 00:12:31,820
handling most likely if you have a

00:12:29,630 --> 00:12:34,370
python application that you're going to

00:12:31,820 --> 00:12:36,590
be have to deal files the interface for

00:12:34,370 --> 00:12:38,510
files across operating systems is pretty

00:12:36,590 --> 00:12:40,940
similar you can note it's you pretty

00:12:38,510 --> 00:12:43,580
much can open up a file with read or

00:12:40,940 --> 00:12:45,350
brighter and bites but it's really the

00:12:43,580 --> 00:12:47,450
undocumented functionality that you got

00:12:45,350 --> 00:12:50,810
to be aware of that may be a limitation

00:12:47,450 --> 00:12:52,700
on the operating system so for my

00:12:50,810 --> 00:12:54,890
introduction for my introduction for

00:12:52,700 --> 00:12:57,290
this I'm going to talk about the AWS s3

00:12:54,890 --> 00:12:59,840
CP command what this does is it uploads

00:12:57,290 --> 00:13:02,420
files from your local file system to

00:12:59,840 --> 00:13:05,000
Amazon s3 which is Amazon's storage

00:13:02,420 --> 00:13:06,890
service and you similarly can download

00:13:05,000 --> 00:13:10,580
files from s3 and copy it around your

00:13:06,890 --> 00:13:13,400
buckets and when it runs this command

00:13:10,580 --> 00:13:15,530
this command will work and parallel so

00:13:13,400 --> 00:13:18,620
it does it makes a request to s3 in

00:13:15,530 --> 00:13:21,069
parallel and does all the writing and

00:13:18,620 --> 00:13:23,989
stuff like that

00:13:21,069 --> 00:13:26,360
so original implementation of how we did

00:13:23,989 --> 00:13:28,759
this was we would have multiple threads

00:13:26,360 --> 00:13:32,290
in this case let's say three we would

00:13:28,759 --> 00:13:35,989
make we make concurrent requests to s3

00:13:32,290 --> 00:13:39,170
where we're doing range gets for a

00:13:35,989 --> 00:13:41,569
specific object and once we get the one

00:13:39,170 --> 00:13:45,170
once each thread will get their data

00:13:41,569 --> 00:13:47,209
they will then write the pot right to

00:13:45,170 --> 00:13:49,069
the specific point of filed note that

00:13:47,209 --> 00:13:50,749
they know exactly where the right saying

00:13:49,069 --> 00:13:52,069
that is a range get so they can seek to

00:13:50,749 --> 00:13:53,360
where they want to in a file and they

00:13:52,069 --> 00:13:57,489
know how the content length so they know

00:13:53,360 --> 00:13:59,920
when they're done writing thus the syph

00:13:57,489 --> 00:14:01,850
there the each thread won't be

00:13:59,920 --> 00:14:05,360
corrupting another part of a thread

00:14:01,850 --> 00:14:09,319
smile however we ran into problems with

00:14:05,360 --> 00:14:12,199
that where if you start if you start

00:14:09,319 --> 00:14:14,600
with a brand new file and you try

00:14:12,199 --> 00:14:16,699
seeking to it the operating system will

00:14:14,600 --> 00:14:19,100
extend the file with a bunch of it with

00:14:16,699 --> 00:14:20,480
a bunch of zeros and when you're

00:14:19,100 --> 00:14:22,610
extending the file in writing to the

00:14:20,480 --> 00:14:24,949
same time some versions of Windows we

00:14:22,610 --> 00:14:26,809
found does not actually sub does not

00:14:24,949 --> 00:14:28,639
have support for that or there's

00:14:26,809 --> 00:14:31,639
limitations in it and what happens we

00:14:28,639 --> 00:14:33,919
get corrupted files so our solution to

00:14:31,639 --> 00:14:35,389
that was to add io thread to limit the

00:14:33,919 --> 00:14:38,480
amount of concurrent interactions of the

00:14:35,389 --> 00:14:40,279
file here we take the normal three

00:14:38,480 --> 00:14:41,660
threads and they pass on their data to

00:14:40,279 --> 00:14:44,559
this IO thread which will then

00:14:41,660 --> 00:14:47,809
sequentially write the data to the file

00:14:44,559 --> 00:14:50,720
note that the the bottleneck here is not

00:14:47,809 --> 00:14:52,489
up to io thread as making the request to

00:14:50,720 --> 00:14:54,529
across the network and retrieving the

00:14:52,489 --> 00:14:58,540
data is much slower than writing it to

00:14:54,529 --> 00:15:01,639
the file so lessons learned here is that

00:14:58,540 --> 00:15:05,329
file handling behavior it can it can it

00:15:01,639 --> 00:15:08,329
can very brightly or not greatly but it

00:15:05,329 --> 00:15:11,779
can vary it get very steadily and you

00:15:08,329 --> 00:15:14,480
need to be aware of it and also in order

00:15:11,779 --> 00:15:16,939
to help cover these undocumented

00:15:14,480 --> 00:15:18,649
behaviors is to limit the number of

00:15:16,939 --> 00:15:21,619
concurrent interactions you may have

00:15:18,649 --> 00:15:24,949
with a file so I didn't cover all the

00:15:21,619 --> 00:15:27,259
top issues we've ran into but one

00:15:24,949 --> 00:15:28,939
example is if you have a file open and

00:15:27,259 --> 00:15:30,559
you try to remove a file handle open you

00:15:28,939 --> 00:15:33,110
actually try to remove it you'll get a

00:15:30,559 --> 00:15:34,220
bunch of trace backs on windows so the

00:15:33,110 --> 00:15:35,990
best way to avoid all the

00:15:34,220 --> 00:15:40,450
is just a limit how many interactions

00:15:35,990 --> 00:15:43,010
you may you may be having so if you are

00:15:40,450 --> 00:15:46,610
handling files you're most likely having

00:15:43,010 --> 00:15:51,320
to deal with I'll pass and how the

00:15:46,610 --> 00:15:53,480
location of files represented so for the

00:15:51,320 --> 00:15:57,590
intro I'm going to build off my previous

00:15:53,480 --> 00:15:59,570
example with the AWS s3 CP command which

00:15:57,590 --> 00:16:02,480
has a recursive option which lets you

00:15:59,570 --> 00:16:06,170
upload or download a whole directory to

00:16:02,480 --> 00:16:10,220
s3 in back it relies on being able to

00:16:06,170 --> 00:16:13,400
list files the problem is file path

00:16:10,220 --> 00:16:15,350
stiffer across operating systems so for

00:16:13,400 --> 00:16:17,390
example if you take Linux if you get the

00:16:15,350 --> 00:16:20,600
current working directory all all of

00:16:17,390 --> 00:16:22,370
your paths will be have a separator of a

00:16:20,600 --> 00:16:25,520
forward slash but for Windows ill be

00:16:22,370 --> 00:16:28,340
back slashes and the way s3 is

00:16:25,520 --> 00:16:31,220
represented in the CLI is the Linux

00:16:28,340 --> 00:16:33,560
version so for example if you take this

00:16:31,220 --> 00:16:35,150
here where you have a local linux

00:16:33,560 --> 00:16:38,540
machine and you transferring a file to

00:16:35,150 --> 00:16:40,280
s3 it it's located at underneath my dirt

00:16:38,540 --> 00:16:42,320
with the name my file if you want to

00:16:40,280 --> 00:16:43,430
transfer to test three you don't have to

00:16:42,320 --> 00:16:45,430
worry about any debris naming is there

00:16:43,430 --> 00:16:48,410
anything it'll just transport just fine

00:16:45,430 --> 00:16:52,720
where the object in s3 will be named my

00:16:48,410 --> 00:16:52,720
file and have a prefix of my dear

00:16:52,810 --> 00:16:56,660
however for Windows is a little bit

00:16:54,680 --> 00:16:59,690
different the note that in Windows it's

00:16:56,660 --> 00:17:03,460
a backslash and thus in order to handle

00:16:59,690 --> 00:17:06,970
it you actually need to chain yet the

00:17:03,460 --> 00:17:09,920
normalize the separator in this case and

00:17:06,970 --> 00:17:12,500
that allows you to transfer to s3 and

00:17:09,920 --> 00:17:14,360
still have this same function out and

00:17:12,500 --> 00:17:20,510
desired functionality of having a prefix

00:17:14,360 --> 00:17:23,420
my dear with the name my file so the

00:17:20,510 --> 00:17:25,460
general solution to handling these is to

00:17:23,420 --> 00:17:28,190
use the OS library there's a lot of neat

00:17:25,460 --> 00:17:31,010
functionality that will let you let you

00:17:28,190 --> 00:17:32,690
handle a lot of these these things

00:17:31,010 --> 00:17:35,660
yelling mate that may run you may run

00:17:32,690 --> 00:17:38,960
into for example for the for the example

00:17:35,660 --> 00:17:42,230
I just provided if you can use the OS

00:17:38,960 --> 00:17:43,700
step property which will determine what

00:17:42,230 --> 00:17:45,320
separators use for your path you can

00:17:43,700 --> 00:17:47,450
replace it with a normalized version

00:17:45,320 --> 00:17:51,519
which was was a forward slash in my ex

00:17:47,450 --> 00:17:53,630
Apple so the lessons learned here our

00:17:51,519 --> 00:17:55,429
files are representing can be

00:17:53,630 --> 00:17:57,049
represented differently across operating

00:17:55,429 --> 00:17:59,240
systems and you want to be wary and use

00:17:57,049 --> 00:18:01,639
OS whenever you're handling file paths

00:17:59,240 --> 00:18:05,480
because if you have a hard coded value

00:18:01,639 --> 00:18:10,159
in there it'll it will mess up your your

00:18:05,480 --> 00:18:12,559
Python program and finally I going to

00:18:10,159 --> 00:18:14,500
like I talked about and across major

00:18:12,559 --> 00:18:16,669
Python versions I'm going to talk about

00:18:14,500 --> 00:18:24,350
function differences in functionality

00:18:16,669 --> 00:18:26,659
across operating systems so given one

00:18:24,350 --> 00:18:28,100
example of where we ran into different

00:18:26,659 --> 00:18:30,320
functionality across operating systems

00:18:28,100 --> 00:18:33,490
this is with the CLI help command so

00:18:30,320 --> 00:18:37,070
what the co help command will do is if

00:18:33,490 --> 00:18:39,710
oops if you type on the command line

00:18:37,070 --> 00:18:42,440
just any command + help you'll get a man

00:18:39,710 --> 00:18:44,600
page that shows up and the man page will

00:18:42,440 --> 00:18:47,990
let you scroll through it and l claps as

00:18:44,600 --> 00:18:51,019
as needed implementation wise all we do

00:18:47,990 --> 00:18:54,169
is we generate the output and then we

00:18:51,019 --> 00:18:56,419
pipe out the output to a pager such as

00:18:54,169 --> 00:18:59,149
the command line utilities less or more

00:18:56,419 --> 00:19:02,840
I think the one thing you want to note

00:18:59,149 --> 00:19:04,279
that is less is like more but has a

00:19:02,840 --> 00:19:05,899
little bit more functionality so for

00:19:04,279 --> 00:19:08,000
example if Wes if you hit the bottom of

00:19:05,899 --> 00:19:13,940
a page when you're paging you can scroll

00:19:08,000 --> 00:19:16,460
back up so the problem that we ran into

00:19:13,940 --> 00:19:19,340
was that Linux has the ability to use

00:19:16,460 --> 00:19:21,860
both more and less but for Windows you

00:19:19,340 --> 00:19:25,990
can only use more we didn't want we did

00:19:21,860 --> 00:19:28,669
not want to make if we did not want to

00:19:25,990 --> 00:19:31,340
subtract any functionality based off the

00:19:28,669 --> 00:19:33,649
operating system such as only deciding

00:19:31,340 --> 00:19:36,649
to use more for no matter the operating

00:19:33,649 --> 00:19:37,820
system because linux has the

00:19:36,649 --> 00:19:40,190
functionality for a list which is a

00:19:37,820 --> 00:19:42,710
little bit better pager to use so

00:19:40,190 --> 00:19:45,139
ideally what we what ideally what we

00:19:42,710 --> 00:19:47,779
want is for linux operating systems to

00:19:45,139 --> 00:19:52,370
use less in for windows machines users

00:19:47,779 --> 00:19:55,760
to use more so the solution here is to

00:19:52,370 --> 00:19:58,340
actually have platform specific code the

00:19:55,760 --> 00:20:00,110
if you use the platform system call that

00:19:58,340 --> 00:20:01,880
what that will let you do is

00:20:00,110 --> 00:20:03,590
determine what operating system you're

00:20:01,880 --> 00:20:06,230
running on and in this snippet what I'm

00:20:03,590 --> 00:20:09,559
doing is I'm checking to see if the

00:20:06,230 --> 00:20:12,470
system is windows and I'll return a help

00:20:09,559 --> 00:20:14,990
renderer specific for windows if so and

00:20:12,470 --> 00:20:17,929
if not I will return a POSIX help render

00:20:14,990 --> 00:20:19,580
and if you look at these subclasses the

00:20:17,929 --> 00:20:21,890
pager side get assigned to it or what

00:20:19,580 --> 00:20:24,860
you expect so for Windows we have that

00:20:21,890 --> 00:20:29,929
pay the utility more and for posix we

00:20:24,860 --> 00:20:31,850
have less however there's a little bit

00:20:29,929 --> 00:20:34,750
more you can actually apply to this to

00:20:31,850 --> 00:20:37,549
help the healthiness of your program

00:20:34,750 --> 00:20:39,320
ideally when you have to have to

00:20:37,549 --> 00:20:41,090
overcome these different functionality

00:20:39,320 --> 00:20:45,470
differences it's a good idea to follow

00:20:41,090 --> 00:20:47,450
LSP which is to make sure that the group

00:20:45,470 --> 00:20:49,549
the objects in your group has the same

00:20:47,450 --> 00:20:51,049
interface such that any object or meth

00:20:49,549 --> 00:20:53,620
or function that may be calling these

00:20:51,049 --> 00:20:56,179
objects can expect the similar interface

00:20:53,620 --> 00:20:58,400
so for example if you take the parent

00:20:56,179 --> 00:21:00,679
class from the windows help render and

00:20:58,400 --> 00:21:02,510
the plastics help render you'll notice

00:21:00,679 --> 00:21:05,419
that I only has one public method which

00:21:02,510 --> 00:21:07,400
is a render method and the render method

00:21:05,419 --> 00:21:09,830
pretty much hides all the differences in

00:21:07,400 --> 00:21:12,140
functionality between windows and non

00:21:09,830 --> 00:21:13,880
went non windows machines and it'll just

00:21:12,140 --> 00:21:18,110
pipe the output the output that gets

00:21:13,880 --> 00:21:20,000
generated to the appropriate pager so

00:21:18,110 --> 00:21:21,590
similarly you can take like the help

00:21:20,000 --> 00:21:23,809
command that actually runs that actually

00:21:21,590 --> 00:21:26,360
runs it and all it all it has to do is

00:21:23,809 --> 00:21:27,530
call it get renderer and it would not

00:21:26,360 --> 00:21:29,179
have to worry about what operating

00:21:27,530 --> 00:21:31,610
systems running on it will just retrieve

00:21:29,179 --> 00:21:33,410
the appropriate appropriate class and

00:21:31,610 --> 00:21:36,410
then it can just call the render method

00:21:33,410 --> 00:21:41,780
on it to make sure to actually do get

00:21:36,410 --> 00:21:45,070
get it to do what you want it to do so

00:21:41,780 --> 00:21:48,380
the lesson learned here are the

00:21:45,070 --> 00:21:51,130
operating system operating system

00:21:48,380 --> 00:21:54,350
functionality may differ and if it does

00:21:51,130 --> 00:21:56,630
you may it is alright to have platform

00:21:54,350 --> 00:21:58,340
specific code but if you are going to

00:21:56,630 --> 00:22:00,110
add platform specific code you want to

00:21:58,340 --> 00:22:02,750
make sure you create some parity in the

00:22:00,110 --> 00:22:05,000
public interfaces such that it doesn't

00:22:02,750 --> 00:22:06,770
any compromises you make in one class

00:22:05,000 --> 00:22:08,059
has an effect all the functionality of

00:22:06,770 --> 00:22:11,510
your other classes or throughout your

00:22:08,059 --> 00:22:13,290
program so now that you learn some of

00:22:11,510 --> 00:22:14,790
the tips and tricks about

00:22:13,290 --> 00:22:17,160
compatibility crossed Python versions

00:22:14,790 --> 00:22:20,460
I'm going to cover how to write tests

00:22:17,160 --> 00:22:22,820
and run to write tests and run tests two

00:22:20,460 --> 00:22:25,020
inch to help better your compatibility

00:22:22,820 --> 00:22:27,990
across the various super environments

00:22:25,020 --> 00:22:30,090
veyron min to sew on your first cup of

00:22:27,990 --> 00:22:33,930
writing test I can't stress the

00:22:30,090 --> 00:22:36,210
importance of having a good sweet of up

00:22:33,930 --> 00:22:38,490
test just for the different possible

00:22:36,210 --> 00:22:40,170
issues you may run into it's ultimately

00:22:38,490 --> 00:22:41,700
your safety net because you're not

00:22:40,170 --> 00:22:46,290
there's a bunch of different compatible

00:22:41,700 --> 00:22:47,880
be issues you may run into and you're

00:22:46,290 --> 00:22:49,650
not going to catch a mold it's really

00:22:47,880 --> 00:22:52,890
going to help you it's really going to

00:22:49,650 --> 00:22:55,230
help you in the end I'm going to most of

00:22:52,890 --> 00:23:00,060
my cut examples are going to be from via

00:22:55,230 --> 00:23:01,560
unit test module and you have to

00:23:00,060 --> 00:23:03,600
remember that all the techniques I

00:23:01,560 --> 00:23:05,070
talked about before still apply so if

00:23:03,600 --> 00:23:06,870
you have source code that's can pat even

00:23:05,070 --> 00:23:08,490
though it's compatible on a bunch of

00:23:06,870 --> 00:23:10,140
different Python versions or operating

00:23:08,490 --> 00:23:12,450
systems if your tests aren't compatible

00:23:10,140 --> 00:23:14,790
they're still going to fail so it's

00:23:12,450 --> 00:23:21,600
important to have compatibility there as

00:23:14,790 --> 00:23:23,460
well an important note is to if you're

00:23:21,600 --> 00:23:25,710
going to use unit tests it'd be good to

00:23:23,460 --> 00:23:28,740
be pulling unit test two for Python 26

00:23:25,710 --> 00:23:30,540
in Python 26 it does have unit tests

00:23:28,740 --> 00:23:33,390
possible unit tests but the

00:23:30,540 --> 00:23:35,730
functionality is not the same as pipe

00:23:33,390 --> 00:23:39,690
for Python 27 and higher so similarly

00:23:35,730 --> 00:23:41,280
like how we did how we made a use the

00:23:39,690 --> 00:23:44,910
functionality in the camp at depuy why

00:23:41,280 --> 00:23:48,540
file we can do it such here where if

00:23:44,910 --> 00:23:51,240
it's Python 26 will use unit test will

00:23:48,540 --> 00:23:53,580
import unit test you as unit test and if

00:23:51,240 --> 00:23:59,190
it's not we'll just use the regular unit

00:23:53,580 --> 00:24:01,920
test module so best practices one of the

00:23:59,190 --> 00:24:03,720
best way to catch if your program is

00:24:01,920 --> 00:24:06,540
capable to run on a bunch of different

00:24:03,720 --> 00:24:08,280
environments is to actually throw a

00:24:06,540 --> 00:24:12,000
bunch of common problem causing inputs

00:24:08,280 --> 00:24:15,210
into it and see what happens for example

00:24:12,000 --> 00:24:17,570
if one good one good value to put it in

00:24:15,210 --> 00:24:20,040
there is unicode and it's also note that

00:24:17,570 --> 00:24:21,990
just having that making the string a

00:24:20,040 --> 00:24:24,240
unico type is not enough even throwing

00:24:21,990 --> 00:24:25,830
some unicode values in there is great

00:24:24,240 --> 00:24:26,370
determine if your your program is going

00:24:25,830 --> 00:24:31,140
to have any

00:24:26,370 --> 00:24:33,540
to coding errors at what not similarly

00:24:31,140 --> 00:24:36,360
throwing in some bites as well is a good

00:24:33,540 --> 00:24:37,740
idea as you can often catch a lot of the

00:24:36,360 --> 00:24:39,300
different types of decoding years that

00:24:37,740 --> 00:24:42,200
you may run into or if you're mixing

00:24:39,300 --> 00:24:45,240
across any in the bowels of your project

00:24:42,200 --> 00:24:48,990
finally for file paths it's a good idea

00:24:45,240 --> 00:24:51,270
to to have some nest to destruction

00:24:48,990 --> 00:24:53,880
nested files in it such as the like a

00:24:51,270 --> 00:24:56,730
has a directory it's just not just away

00:24:53,880 --> 00:24:58,320
your current working directory and even

00:24:56,730 --> 00:25:01,110
throw some Unicode into your files to

00:24:58,320 --> 00:25:05,760
see how if you're actually modifying the

00:25:01,110 --> 00:25:07,260
file pass how its able to handle that so

00:25:05,760 --> 00:25:09,590
another thing I would like to talk about

00:25:07,260 --> 00:25:11,790
is file handling in terms of testing a

00:25:09,590 --> 00:25:16,320
lot of times there's a pattern where you

00:25:11,790 --> 00:25:18,920
would you'll knock out a you'll knock

00:25:16,320 --> 00:25:22,590
out a lot of the opera dou s library or

00:25:18,920 --> 00:25:24,300
maybe the open open method to in order

00:25:22,590 --> 00:25:26,910
to create like this file like object

00:25:24,300 --> 00:25:28,559
like a string I or bytes I oh ideally

00:25:26,910 --> 00:25:30,600
for especially for integration tests

00:25:28,559 --> 00:25:33,090
it's it's better to use actual files

00:25:30,600 --> 00:25:36,120
because there's too great of a

00:25:33,090 --> 00:25:38,370
difference in parity between file like

00:25:36,120 --> 00:25:40,740
objects like string IM and actual file

00:25:38,370 --> 00:25:42,960
like objects and if your file if your

00:25:40,740 --> 00:25:45,900
program is using files it only makes

00:25:42,960 --> 00:25:50,730
sense that you use the real thing so

00:25:45,900 --> 00:25:51,960
here's an example of what you're one of

00:25:50,730 --> 00:25:54,990
your test cases could look like in

00:25:51,960 --> 00:25:58,050
setting up a file to use for example

00:25:54,990 --> 00:26:00,510
here in the setup this setup method what

00:25:58,050 --> 00:26:03,540
we do is we create a temporary directory

00:26:00,510 --> 00:26:05,580
and you from that type or directory you

00:26:03,540 --> 00:26:09,120
can add any file you want and write some

00:26:05,580 --> 00:26:11,610
data into it and then similarly once you

00:26:09,120 --> 00:26:13,110
done setting it up you can any test case

00:26:11,610 --> 00:26:14,880
can actually run in use that file you

00:26:13,110 --> 00:26:16,590
just created for the setup and then any

00:26:14,880 --> 00:26:19,170
and you could just tear it down it's a

00:26:16,590 --> 00:26:20,700
great way to be able to test on the real

00:26:19,170 --> 00:26:23,580
thing the real type of files you will

00:26:20,700 --> 00:26:25,740
expecting a program and then finally

00:26:23,580 --> 00:26:27,750
there you may run into the situation

00:26:25,740 --> 00:26:29,820
where you actually need a test for an

00:26:27,750 --> 00:26:33,210
environment for an environment specific

00:26:29,820 --> 00:26:36,090
behavior and ideally what you want to

00:26:33,210 --> 00:26:38,250
make sure to do is to share code paths

00:26:36,090 --> 00:26:40,039
in your tests but when you can't it's

00:26:38,250 --> 00:26:42,919
alright to skip tests

00:26:40,039 --> 00:26:45,779
to skip tests you can just use the Skip

00:26:42,919 --> 00:26:49,440
decorator in this case I'm skipping if

00:26:45,779 --> 00:26:52,230
it's a Python 3 version and I can also

00:26:49,440 --> 00:26:53,519
skip if it's a platform-specific so for

00:26:52,230 --> 00:26:57,149
example here i'm skipping if it's not

00:26:53,519 --> 00:27:01,320
mac or linux so you may be asking now

00:26:57,149 --> 00:27:03,389
when do I know to skip test ideally

00:27:01,320 --> 00:27:04,860
skipping test you should only be

00:27:03,389 --> 00:27:06,899
skipping tested the functionality you

00:27:04,860 --> 00:27:08,399
expect differs so like the output

00:27:06,899 --> 00:27:10,049
differs based off what operating system

00:27:08,399 --> 00:27:12,059
or your Python version you're using or

00:27:10,049 --> 00:27:14,250
if the functionality is just straight-up

00:27:12,059 --> 00:27:16,289
doesn't exist so if you're testing

00:27:14,250 --> 00:27:17,970
special files such as symbolic links or

00:27:16,289 --> 00:27:21,779
socket files some linux that doesn't

00:27:17,970 --> 00:27:26,220
have any representation in windows would

00:27:21,779 --> 00:27:28,260
be it's it's appropriate to skip here so

00:27:26,220 --> 00:27:30,630
to reiterate some of the main points

00:27:28,260 --> 00:27:33,240
here you want to make sure that you are

00:27:30,630 --> 00:27:35,429
testing common treble inputs to get a

00:27:33,240 --> 00:27:40,169
realistic idea of how it's a little

00:27:35,429 --> 00:27:41,880
handle possible issues use the use

00:27:40,169 --> 00:27:44,880
expected types such as the trouble

00:27:41,880 --> 00:27:47,010
inputs and actual files and then skip

00:27:44,880 --> 00:27:50,610
only when you absolutely need to as I

00:27:47,010 --> 00:27:52,380
said before in the previous slide so now

00:27:50,610 --> 00:27:53,970
that you have your test suite written

00:27:52,380 --> 00:27:56,190
you want to know how to actually run the

00:27:53,970 --> 00:27:57,269
test and make sure it runs on all the

00:27:56,190 --> 00:28:05,070
different environments that you can

00:27:57,269 --> 00:28:06,990
possibly use so one of one of utility to

00:28:05,070 --> 00:28:08,370
make sure you have in your way house is

00:28:06,990 --> 00:28:10,110
virtual and creating virtual

00:28:08,370 --> 00:28:11,519
environments for specific Python

00:28:10,110 --> 00:28:13,679
versions is great for when you're

00:28:11,519 --> 00:28:15,600
developing and testing such that you

00:28:13,679 --> 00:28:17,789
know how well it runs for a specific

00:28:15,600 --> 00:28:20,519
version and also here's a couple of

00:28:17,789 --> 00:28:22,260
tools for testing that is great nose is

00:28:20,519 --> 00:28:25,230
a test runner that can run through test

00:28:22,260 --> 00:28:26,309
suite there's talks which will you can

00:28:25,230 --> 00:28:27,809
use it to set up your virtual

00:28:26,309 --> 00:28:29,850
environments around your tested and just

00:28:27,809 --> 00:28:31,110
tear down your virtual environments the

00:28:29,850 --> 00:28:33,149
end and can do that for a bunch of

00:28:31,110 --> 00:28:35,130
different Python versions and there's

00:28:33,149 --> 00:28:38,399
also pie test which provides a lot of

00:28:35,130 --> 00:28:41,490
similar functionality so here's an

00:28:38,399 --> 00:28:45,179
example of a tox ini file that you can

00:28:41,490 --> 00:28:47,340
you can find in CLI where what we'll do

00:28:45,179 --> 00:28:48,750
is all i have to do it's quite simple

00:28:47,340 --> 00:28:51,210
you just have to list the different

00:28:48,750 --> 00:28:52,210
environments that you want to support so

00:28:51,210 --> 00:28:55,120
for example here we

00:28:52,210 --> 00:28:57,430
support two six two three four and then

00:28:55,120 --> 00:28:59,470
you all have to do is to specify what

00:28:57,430 --> 00:29:00,940
the dependencies are such as there's a

00:28:59,470 --> 00:29:03,040
choir miss a text saying what the

00:29:00,940 --> 00:29:04,570
defense for the tests required and then

00:29:03,040 --> 00:29:06,940
the commands you run run so here we're

00:29:04,570 --> 00:29:09,160
just running those to run an actual test

00:29:06,940 --> 00:29:11,620
suite and similarly we can have

00:29:09,160 --> 00:29:15,130
conditional dependencies for Python 26

00:29:11,620 --> 00:29:17,520
and note that there's the requirements

00:29:15,130 --> 00:29:23,470
26 specifically for the unit testitude

00:29:17,520 --> 00:29:25,750
dependency so finally you may be right

00:29:23,470 --> 00:29:27,190
wondering how to a handle like different

00:29:25,750 --> 00:29:29,320
operating systems you only have like

00:29:27,190 --> 00:29:31,510
access to a linux machine how do I make

00:29:29,320 --> 00:29:34,090
sure that I'm running on a Windows there

00:29:31,510 --> 00:29:35,920
i would recommend using CI systems there

00:29:34,090 --> 00:29:38,320
are two good ones are Travis and Jenkins

00:29:35,920 --> 00:29:40,960
Travis automatically links up to your

00:29:38,320 --> 00:29:42,370
github repo so cannot only tech it can

00:29:40,960 --> 00:29:45,850
automatically test a bunch of these

00:29:42,370 --> 00:29:47,170
different pushes that you make and make

00:29:45,850 --> 00:29:48,550
sure that support across all the

00:29:47,170 --> 00:29:51,880
different Python versions and then

00:29:48,550 --> 00:29:54,100
similarly for Jenkins what you can do is

00:29:51,880 --> 00:29:56,020
you can launch it like a nice tea to

00:29:54,100 --> 00:29:58,810
Windows instance with Jenkins installed

00:29:56,020 --> 00:30:00,490
and you can run builds up for your tests

00:29:58,810 --> 00:30:04,350
based off what got recently got pushed

00:30:00,490 --> 00:30:07,330
to your to your repo so in conclusion

00:30:04,350 --> 00:30:10,320
some of the major topics that I would

00:30:07,330 --> 00:30:13,510
like to reiterate is to use 6 whenever

00:30:10,320 --> 00:30:16,060
you run into a Python compatibility

00:30:13,510 --> 00:30:18,070
issue I thon renaming expect are also

00:30:16,060 --> 00:30:20,440
determining like what Python version

00:30:18,070 --> 00:30:23,050
you're running on or determining what

00:30:20,440 --> 00:30:25,450
string type you're dealing with for

00:30:23,050 --> 00:30:27,700
string types remember that mixing the

00:30:25,450 --> 00:30:29,020
two are bad there's different there's

00:30:27,700 --> 00:30:30,460
different naming conventions across the

00:30:29,020 --> 00:30:32,440
major Python versions and the best way

00:30:30,460 --> 00:30:33,940
to handle it is to ensure that they're

00:30:32,440 --> 00:30:38,470
all the same at the very beginning of

00:30:33,940 --> 00:30:40,090
program file handling the one of the

00:30:38,470 --> 00:30:45,880
major issues we will run is there is

00:30:40,090 --> 00:30:47,920
that if there might be there may be

00:30:45,880 --> 00:30:49,300
undocumented behavior that you may not

00:30:47,920 --> 00:30:50,980
be at one aware of and the best way to

00:30:49,300 --> 00:30:54,190
avoid it is to limit the concurrent

00:30:50,980 --> 00:30:56,590
interactions with it and if I no limit

00:30:54,190 --> 00:30:58,120
and then with limitation handling what

00:30:56,590 --> 00:30:59,530
you need to do is oftentimes just

00:30:58,120 --> 00:31:00,970
backboard the functionality on pensate

00:30:59,530 --> 00:31:02,320
for the functionality and then hide it

00:31:00,970 --> 00:31:04,460
whether if you're importing it

00:31:02,320 --> 00:31:07,550
differently or if you are

00:31:04,460 --> 00:31:11,030
or if you're trying to use LSP to hide

00:31:07,550 --> 00:31:12,890
all the functionality differences and it

00:31:11,030 --> 00:31:16,610
finally you want also test as closely as

00:31:12,890 --> 00:31:18,350
possible to reality this will oftentimes

00:31:16,610 --> 00:31:23,750
catch a lot of these different issues

00:31:18,350 --> 00:31:27,400
you may run into and it finally read the

00:31:23,750 --> 00:31:29,570
documentation I said final a bunch but

00:31:27,400 --> 00:31:31,130
they're often times it's just a one

00:31:29,570 --> 00:31:32,840
liner and they're saying it's this

00:31:31,130 --> 00:31:34,520
Python version supported or this

00:31:32,840 --> 00:31:36,980
operating system supported it can help

00:31:34,520 --> 00:31:40,150
you save save great chapels the next

00:31:36,980 --> 00:31:44,540
time you're writing your project and

00:31:40,150 --> 00:31:48,080
thanks again here is my github repo for

00:31:44,540 --> 00:31:52,460
the ABC oh I here is my profile I think

00:31:48,080 --> 00:31:56,000
I'm about overtime on the hunt 3 30

00:31:52,460 --> 00:31:58,880
minute though okay okay um yeah so

00:31:56,000 --> 00:32:00,440
here's my github repo and my profile if

00:31:58,880 --> 00:32:03,410
you have any questions about any of the

00:32:00,440 --> 00:32:07,220
projects I work on free friel to ask me

00:32:03,410 --> 00:32:09,310
I'm going to be here all week and thanks

00:32:07,220 --> 00:32:09,310
again

00:32:15,850 --> 00:32:23,140
so we have known some more time left any

00:32:18,730 --> 00:32:25,150
questions I've been using a device Eli

00:32:23,140 --> 00:32:28,950
for a while and I'm fine I was finding

00:32:25,150 --> 00:32:31,750
it quite hard to get used to the help

00:32:28,950 --> 00:32:34,090
like handling with Helen handling the

00:32:31,750 --> 00:32:36,160
commendation and what's available on

00:32:34,090 --> 00:32:38,140
this oh no come online because usually

00:32:36,160 --> 00:32:40,570
when you work on unix based systems then

00:32:38,140 --> 00:32:42,429
the convention is like data help at the

00:32:40,570 --> 00:32:45,970
end of the command to see the actual

00:32:42,429 --> 00:32:48,610
help and then man as for manual pages is

00:32:45,970 --> 00:32:50,950
that because of the compatibility with

00:32:48,610 --> 00:32:53,320
windows systems that you decided to use

00:32:50,950 --> 00:32:57,400
like just help at the end and no manual

00:32:53,320 --> 00:32:58,840
um for that it was just I think there's

00:32:57,400 --> 00:33:00,970
just the implementation detail it was

00:32:58,840 --> 00:33:05,289
like how we decided to sign it I believe

00:33:00,970 --> 00:33:06,820
we just decided to use help just I mean

00:33:05,289 --> 00:33:09,250
the windows doesn't have in Windows

00:33:06,820 --> 00:33:15,659
doesn't have a man page right so having

00:33:09,250 --> 00:33:15,659
a help is intuitive in that case okay

00:33:19,440 --> 00:33:26,260
there's also the Biden future library I

00:33:23,230 --> 00:33:29,590
think it's the alternative to six yeah

00:33:26,260 --> 00:33:32,679
features yeah yeah but do you have like

00:33:29,590 --> 00:33:36,690
how its compared to six I know that six

00:33:32,679 --> 00:33:38,679
is quite old yeah some rumors were that

00:33:36,690 --> 00:33:42,220
Biden future has some different

00:33:38,679 --> 00:33:44,380
approaches I think yeah for this exam I

00:33:42,220 --> 00:33:46,600
was just doing it based off what the COI

00:33:44,380 --> 00:33:48,730
and a lot of projects we do we just used

00:33:46,600 --> 00:33:50,830
six because it's it's just a very low

00:33:48,730 --> 00:33:53,169
weight tepa way of handling these

00:33:50,830 --> 00:33:54,880
compatibilities and instead for summer

00:33:53,169 --> 00:33:56,799
projects we actually do use features for

00:33:54,880 --> 00:33:59,289
example for a boat 03 we use features

00:33:56,799 --> 00:34:03,299
for some of our multiprocessor

00:33:59,289 --> 00:34:03,299
multi-threaded processes

00:34:09,319 --> 00:34:14,089
what's the hardest to support like

00:34:11,659 --> 00:34:19,249
windows or bison to at six or three

00:34:14,089 --> 00:34:21,529
firsts too I think it's just I would say

00:34:19,249 --> 00:34:22,849
just getting it all work getting it all

00:34:21,529 --> 00:34:24,649
working on across all the different

00:34:22,849 --> 00:34:26,979
machines is there different environments

00:34:24,649 --> 00:34:30,139
just hard i I don't I wouldn't say that

00:34:26,979 --> 00:34:32,779
one part of the others certainly there's

00:34:30,139 --> 00:34:34,839
some some Python bridges and hyper

00:34:32,779 --> 00:34:37,459
limitations windows have limitations but

00:34:34,839 --> 00:34:39,469
it's just trying to get it all to work

00:34:37,459 --> 00:34:43,039
well because sometimes you may have

00:34:39,469 --> 00:34:44,719
logic for one that is it doesn't work

00:34:43,039 --> 00:34:46,099
another but then you change it it and it

00:34:44,719 --> 00:34:48,379
doesn't work on the other machine and

00:34:46,099 --> 00:34:53,659
it's it's sometimes tricky but it so

00:34:48,379 --> 00:34:56,890
it's always doable I will ask you a

00:34:53,659 --> 00:34:59,900
question if I am developing with some

00:34:56,890 --> 00:35:01,989
Titan library that is in the DB an

00:34:59,900 --> 00:35:06,440
ordinary ubuntu in a package and

00:35:01,989 --> 00:35:09,079
sometimes they update it just the

00:35:06,440 --> 00:35:11,509
packager will be updated and then i am

00:35:09,079 --> 00:35:14,959
not sure if it works so i can use visual

00:35:11,509 --> 00:35:17,839
and as you thought there are some

00:35:14,959 --> 00:35:21,650
packages that are depending dependent on

00:35:17,839 --> 00:35:23,509
other external packages that are not

00:35:21,650 --> 00:35:25,989
directly with bite and connected some

00:35:23,509 --> 00:35:29,680
some some see libraries how would you

00:35:25,989 --> 00:35:32,690
via trove and fill eyes these packages

00:35:29,680 --> 00:35:36,549
here the question is how can you repeat

00:35:32,690 --> 00:35:41,359
the question how would you manage the

00:35:36,549 --> 00:35:44,359
different versions of ubuntu or Debian

00:35:41,359 --> 00:35:48,170
packages that are not tighten like it is

00:35:44,359 --> 00:35:51,949
that our see libraries that get updated

00:35:48,170 --> 00:35:53,749
sometimes in the background and I'm not

00:35:51,949 --> 00:35:57,769
sure whether I can use it with the new

00:35:53,749 --> 00:35:59,539
pipe in package or not usually there's a

00:35:57,769 --> 00:36:00,949
verte that doesn't have a version

00:35:59,539 --> 00:36:02,299
strapped to it so you can actually walk

00:36:00,949 --> 00:36:04,219
down to a version eight ER so you feel

00:36:02,299 --> 00:36:11,209
comfortable with those in the burgh

00:36:04,219 --> 00:36:14,479
always yeah i'm not i am not too sure

00:36:11,209 --> 00:36:16,579
about that you can yeah i would just

00:36:14,479 --> 00:36:18,079
suggest that making sure that you're

00:36:16,579 --> 00:36:19,609
strapped down to a specific person that

00:36:18,079 --> 00:36:20,810
your skin comfortable with this probably

00:36:19,609 --> 00:36:25,030
the best way to go about that

00:36:20,810 --> 00:36:25,030
okay thank you any more questions

00:36:35,220 --> 00:36:40,360
the only problem that I see is that in

00:36:38,290 --> 00:36:45,850
my opinion you need to have a clear idea

00:36:40,360 --> 00:36:48,640
of what you need to to do differently

00:36:45,850 --> 00:36:51,430
for a different environment it's not

00:36:48,640 --> 00:36:54,040
something that is going to come on its

00:36:51,430 --> 00:36:55,870
own so how can I know what I need to

00:36:54,040 --> 00:37:01,120
make differently for a different

00:36:55,870 --> 00:37:06,700
environment I mean windows worse

00:37:01,120 --> 00:37:10,300
differently from linux and 2.7 works

00:37:06,700 --> 00:37:12,790
differently from 2.6 or whatever but I

00:37:10,300 --> 00:37:15,520
don't know the difference is so I cannot

00:37:12,790 --> 00:37:19,390
foresee them how can I know them before

00:37:15,520 --> 00:37:22,150
I have to test them okay well probably

00:37:19,390 --> 00:37:24,280
the best way to do that is to just like

00:37:22,150 --> 00:37:26,620
I said using a virtual land for spinning

00:37:24,280 --> 00:37:30,700
up like an ec2 instance with the whip n

00:37:26,620 --> 00:37:32,560
ec2 instance that's a great way to just

00:37:30,700 --> 00:37:34,150
fiddle around with your project as

00:37:32,560 --> 00:37:36,460
you're developing it to see if there's

00:37:34,150 --> 00:37:42,940
any issues that you may run into as you

00:37:36,460 --> 00:37:45,870
are developing no more questions okay

00:37:42,940 --> 00:37:45,870

YouTube URL: https://www.youtube.com/watch?v=DOQUPQZTXXs


