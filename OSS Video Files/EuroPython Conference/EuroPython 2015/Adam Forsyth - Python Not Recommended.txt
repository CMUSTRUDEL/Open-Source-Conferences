Title: Adam Forsyth - Python Not Recommended
Publication date: 2015-08-08
Playlist: EuroPython 2015
Description: 
	Adam Forsyth - Python Not Recommended
[EuroPython 2015]
[21 July 2015]
[Bilbao, Euskadi, Spain]

Braintree is a Ruby shop. By default, we use Ruby and Rails for
projects. We also use Ruby-based projects for much of our tooling,
including puppet, capistrano, and rake. However, we strongly believe
in using the right tool for the job. What that means has evolved over
ti
me, and I'll discuss what solutions we chose in the past as well as
our current choices.

So what's it like doing Python at a Ruby shop? You get lots of jokes
about language features Ruby has but Python lacks and lots of
disbelief that Python will survive the 2/3 split. People also tend to
apply the best practices and conventions of Ruby to Python code as if
t
hey were the same. Python's major inroad at Braintree has been,
surprisingly enough, as a platform for high-concurrency situations.
This is a direct result of the power of Tornado as a platform for
asynchronous I/O. It also helps that many Python is very approachable
and
many developers have at least some experience with it.

Braintree has three pieces of our infrastructure using Python and
Tornado -- an incoming request proxy; an outgoing request proxy; and a
webook delivery service. They've served us well for 3+ years but all
suffer from a number of problems. The outdated concurrency feature
s of CPython / Python 2 as well as our lack of experience with and
commitment to Tornado have always been an issue. As the meat of the
talk, I'll speak in depth about the other issues we've encountered
with each of the three applications and our short- and long- term solu
tions to the problems.

The state as of the end of 2014 appeared dire for Python at Braintree.
All the old Python code in our stack is on the way out, and Python has
been specifically recommended agaist for new projects. Our Python
client library is used by some of our largest merchants, and is
ready for the future by supporting Python 2.6+ and Python 3.3+ in a
single codebase. We also have a vibrant Python community at Venmo, our
sister company. Both Braintree and Venmo support Python by attending,
hosting, sponsoring, and speaking at meetups, conferences, and
other events in Chicago, New York, and elsewhere. At Braintree, our
Data Science team uses Python almost exclusively and they're becoming
a bigger part of our business every day. We also use custom tooling
written in Python to manage our infrastructure.
Captions: 
	00:00:03,290 --> 00:00:08,250
work at a company called Braintree we

00:00:06,720 --> 00:00:10,679
make it really easy for you to accept

00:00:08,250 --> 00:00:13,530
credit cards PayPal and other payment

00:00:10,679 --> 00:00:15,150
methods online and in mobile apps this

00:00:13,530 --> 00:00:16,590
talk is not currently on github but it

00:00:15,150 --> 00:00:20,910
will be shortly you'll be able to find

00:00:16,590 --> 00:00:23,220
it there so let's talk about the title

00:00:20,910 --> 00:00:24,779
of the talk I found not recommended it

00:00:23,220 --> 00:00:27,000
might sound like it's a joke but I mean

00:00:24,779 --> 00:00:28,140
it quite literally at the company where

00:00:27,000 --> 00:00:31,769
I work we have something called the

00:00:28,140 --> 00:00:33,660
radar and it contains information on the

00:00:31,769 --> 00:00:35,100
technologies we use whether you should

00:00:33,660 --> 00:00:36,899
use them whether you should never use

00:00:35,100 --> 00:00:38,070
them again and sort of where to look for

00:00:36,899 --> 00:00:45,660
examples and other relevant information

00:00:38,070 --> 00:00:47,730
and in the radar Python is specifically

00:00:45,660 --> 00:00:50,250
listed as currently in use but not

00:00:47,730 --> 00:00:52,170
recommended so this talk is about why we

00:00:50,250 --> 00:00:54,629
originally used it why it's not

00:00:52,170 --> 00:00:56,190
recommended now and what we still like

00:00:54,629 --> 00:00:58,500
it for and what we're going to use it

00:00:56,190 --> 00:01:00,780
for in the future so first some

00:00:58,500 --> 00:01:02,399
background the obvious question is what

00:01:00,780 --> 00:01:03,539
do we use instead if we don't use Python

00:01:02,399 --> 00:01:05,729
there's got to be something else we use

00:01:03,539 --> 00:01:07,950
as our general purpose language and the

00:01:05,729 --> 00:01:10,260
answer is ruby brain tree he loves ruby

00:01:07,950 --> 00:01:13,080
brain tree uses ruby by default for

00:01:10,260 --> 00:01:15,570
pretty much everything but i promise

00:01:13,080 --> 00:01:17,820
this isn't a ruby talk i personally am a

00:01:15,570 --> 00:01:21,140
python person I don't love Ruby so we'll

00:01:17,820 --> 00:01:24,060
we'll talk about it only as background

00:01:21,140 --> 00:01:26,430
braintree has bought into the Ruby

00:01:24,060 --> 00:01:28,380
ecosystem we use rails as our web

00:01:26,430 --> 00:01:30,869
framework we use Capistrano for remote

00:01:28,380 --> 00:01:32,579
server management we use puppet for

00:01:30,869 --> 00:01:34,560
configuration management and we use rake

00:01:32,579 --> 00:01:38,939
for sort of scripting builds and

00:01:34,560 --> 00:01:41,070
automation so you probably wonder what

00:01:38,939 --> 00:01:43,020
is what's it like doing Python at a ruby

00:01:41,070 --> 00:01:46,619
shop something I've been doing for three

00:01:43,020 --> 00:01:47,759
years now there's a lot of jokes about

00:01:46,619 --> 00:01:50,490
Python because it doesn't have

00:01:47,759 --> 00:01:53,729
quote-unquote real lambdas which people

00:01:50,490 --> 00:01:55,590
just mean that function definitions are

00:01:53,729 --> 00:01:57,210
statements and not expressions and

00:01:55,590 --> 00:01:58,740
people would like just to be able to

00:01:57,210 --> 00:02:01,380
define a function where they want and

00:01:58,740 --> 00:02:03,329
even though functionally the same people

00:02:01,380 --> 00:02:05,130
don't like the syntax difference it's

00:02:03,329 --> 00:02:07,320
seen as an elegant compared to Ruby or

00:02:05,130 --> 00:02:09,030
elixir or closure this is both because

00:02:07,320 --> 00:02:10,830
of the statement expression dichotomy

00:02:09,030 --> 00:02:12,580
but also because of the generally

00:02:10,830 --> 00:02:14,830
structured syntax and

00:02:12,580 --> 00:02:16,750
because in these languages magic is

00:02:14,830 --> 00:02:19,300
really easy with macros in the lisp or

00:02:16,750 --> 00:02:21,130
with everything in Ruby is magic and

00:02:19,300 --> 00:02:23,920
it's just a little harder in Python and

00:02:21,130 --> 00:02:25,450
people don't like that it's sometimes

00:02:23,920 --> 00:02:26,770
gets dismissed as a dying language

00:02:25,450 --> 00:02:28,990
because of some of the negative

00:02:26,770 --> 00:02:31,570
publicity around the slow adoption of

00:02:28,990 --> 00:02:33,100
Python 3 I don't see it as a failure i

00:02:31,570 --> 00:02:34,990
don't think the python communities use

00:02:33,100 --> 00:02:36,910
it of failure but people outside the

00:02:34,990 --> 00:02:39,910
Python community sometimes see it that

00:02:36,910 --> 00:02:43,330
way the languages are also similar in a

00:02:39,910 --> 00:02:44,950
lot of ways almost too similar for their

00:02:43,330 --> 00:02:47,610
own good when you're a Ruby programmer a

00:02:44,950 --> 00:02:49,690
lot of people will sort of apply

00:02:47,610 --> 00:02:51,160
judgments that you apply to Ruby code to

00:02:49,690 --> 00:02:53,890
Python code without taking into account

00:02:51,160 --> 00:02:56,050
the difference in idiom and so if you

00:02:53,890 --> 00:02:57,220
were to apply to braintree as a Python

00:02:56,050 --> 00:02:58,450
developer might hurt you a little

00:02:57,220 --> 00:03:00,310
because people are going to expect your

00:02:58,450 --> 00:03:02,110
Python code to be written like Ruby and

00:03:00,310 --> 00:03:05,530
it also means that our Python code can

00:03:02,110 --> 00:03:07,330
be a little less than idiomatic so

00:03:05,530 --> 00:03:08,860
despite using a lot of Ruby first and

00:03:07,330 --> 00:03:11,500
foremost we believe in using the right

00:03:08,860 --> 00:03:13,660
tool for the job so you're not going to

00:03:11,500 --> 00:03:16,840
find a ton of this at braintree although

00:03:13,660 --> 00:03:18,550
it does happen once in a while so what

00:03:16,840 --> 00:03:20,500
do I mean when when is Ruby not the

00:03:18,550 --> 00:03:23,320
right tool for the job and we sort of

00:03:20,500 --> 00:03:27,970
found two main times one is when you

00:03:23,320 --> 00:03:30,310
need the JVM ecosystem you might say Joe

00:03:27,970 --> 00:03:32,230
just use JRuby and you have access to

00:03:30,310 --> 00:03:35,380
everything well we found that that gets

00:03:32,230 --> 00:03:36,970
a little messy and that it's not really

00:03:35,380 --> 00:03:38,830
good long-term solution although we have

00:03:36,970 --> 00:03:41,650
done it in the past when we need a Java

00:03:38,830 --> 00:03:44,440
in the short term primarily will need to

00:03:41,650 --> 00:03:48,459
use Java if some third party who maybe

00:03:44,440 --> 00:03:50,380
wrote their API in 1999 only has doesn't

00:03:48,459 --> 00:03:51,730
have an open API spec and they'll just

00:03:50,380 --> 00:03:54,160
give you a library and your choices or

00:03:51,730 --> 00:03:57,820
C++ or Java well we're going to choose

00:03:54,160 --> 00:04:00,580
Java there's also a lot of great tools

00:03:57,820 --> 00:04:02,260
that work best with the JVM like Apache

00:04:00,580 --> 00:04:04,060
kafka which is a message broker for

00:04:02,260 --> 00:04:07,570
handling high-volume data feeds and

00:04:04,060 --> 00:04:09,370
apache cassandra which is a distributed

00:04:07,570 --> 00:04:13,930
database for handling large amounts of

00:04:09,370 --> 00:04:16,780
data so what do we use when we need the

00:04:13,930 --> 00:04:19,120
JVM well like I said we have tried jruby

00:04:16,780 --> 00:04:20,979
and historically along with Java we

00:04:19,120 --> 00:04:22,930
haven't found it to be that great and

00:04:20,979 --> 00:04:24,070
then more recently over the past maybe

00:04:22,930 --> 00:04:26,410
year and a half two years at this point

00:04:24,070 --> 00:04:27,580
we have used closure pretty successful

00:04:26,410 --> 00:04:28,960
although we've still found that there

00:04:27,580 --> 00:04:31,800
are times that you really want to use

00:04:28,960 --> 00:04:35,200
Java directly so the other main time

00:04:31,800 --> 00:04:36,910
that we find that Ruby is in the right

00:04:35,200 --> 00:04:40,150
tool is when you need to write a smart

00:04:36,910 --> 00:04:42,580
proxy now our business is basically to

00:04:40,150 --> 00:04:44,170
sit between somebody who wants to sell

00:04:42,580 --> 00:04:46,750
something online and the banks and card

00:04:44,170 --> 00:04:49,060
networks so we basically are a smart

00:04:46,750 --> 00:04:52,210
proxy and so our big smart proxies build

00:04:49,060 --> 00:04:54,490
up a lot of little smart proxies you can

00:04:52,210 --> 00:04:56,530
see this is the logo from a party that

00:04:54,490 --> 00:04:58,690
Braintree and PayPal through it South by

00:04:56,530 --> 00:05:02,560
Southwest a couple years ago it's smart

00:04:58,690 --> 00:05:04,390
has a brand so it fits we have really

00:05:02,560 --> 00:05:05,560
high uptime requirements we need to be

00:05:04,390 --> 00:05:07,240
available when there are temporary

00:05:05,560 --> 00:05:08,740
networking problems when we need

00:05:07,240 --> 00:05:11,080
failover services we have to run

00:05:08,740 --> 00:05:13,810
database migrations when we get huge cap

00:05:11,080 --> 00:05:15,700
traffic spikes like I don't know uber is

00:05:13,810 --> 00:05:17,650
it's New Years and uber is running tons

00:05:15,700 --> 00:05:20,860
of tons of rides and they want to charge

00:05:17,650 --> 00:05:22,450
people's credit cards and we also have a

00:05:20,860 --> 00:05:24,760
big problem with the services behind us

00:05:22,450 --> 00:05:27,250
the banks the card networks going down

00:05:24,760 --> 00:05:29,280
and we need at the very worst case

00:05:27,250 --> 00:05:32,590
requests to fail gracefully and

00:05:29,280 --> 00:05:33,880
preferably if the outage times are short

00:05:32,590 --> 00:05:35,920
like on the order of a few seconds we

00:05:33,880 --> 00:05:39,610
want those requests to succeed even

00:05:35,920 --> 00:05:41,200
though the service behind us failed so

00:05:39,610 --> 00:05:43,780
we use them to make our outgoing

00:05:41,200 --> 00:05:45,970
connections appeal appear highly

00:05:43,780 --> 00:05:48,730
available to our internal services we

00:05:45,970 --> 00:05:49,960
use them to pause incoming requests so

00:05:48,730 --> 00:05:51,550
that our internal services won't

00:05:49,960 --> 00:05:53,140
actually see any requests coming in and

00:05:51,550 --> 00:05:54,370
we can do whatever we want to them but

00:05:53,140 --> 00:05:57,520
actually clients are still able to

00:05:54,370 --> 00:05:59,890
connect to us we do custom rate-limiting

00:05:57,520 --> 00:06:01,630
we have pretty complex rules for how

00:05:59,890 --> 00:06:04,169
much capacity different clients and

00:06:01,630 --> 00:06:06,520
different types of requests can use and

00:06:04,169 --> 00:06:09,460
we because we integrate with a lot of

00:06:06,520 --> 00:06:12,220
legacy services we often find that we

00:06:09,460 --> 00:06:15,100
need really weird SSL or persistent

00:06:12,220 --> 00:06:16,390
connection configurations and and this

00:06:15,100 --> 00:06:18,730
is something that we've often had to do

00:06:16,390 --> 00:06:22,090
ourselves we also have very complex

00:06:18,730 --> 00:06:24,730
retrial logic and a lot of other custom

00:06:22,090 --> 00:06:27,550
logic that we need this is where we

00:06:24,730 --> 00:06:29,560
historically used python it might seem a

00:06:27,550 --> 00:06:30,940
little odd since handling a large number

00:06:29,560 --> 00:06:32,890
of requests doing a lot of concurrency

00:06:30,940 --> 00:06:34,960
is not necessarily the first place you

00:06:32,890 --> 00:06:36,690
think of Python but it was actually a

00:06:34,960 --> 00:06:40,129
pretty good fit for a long time

00:06:36,690 --> 00:06:43,369
specifically because of tornado tornado

00:06:40,129 --> 00:06:46,459
is a web server and framework for doing

00:06:43,369 --> 00:06:48,169
non-blocking i/o and you get the

00:06:46,459 --> 00:06:50,539
benefits from Python of rapid

00:06:48,169 --> 00:06:52,189
development and easy to learn and you

00:06:50,539 --> 00:06:53,889
still get the necessary io concurrency

00:06:52,189 --> 00:06:57,619
the handle tens of thousands of requests

00:06:53,889 --> 00:06:59,419
so back in 2013 Python was in pretty

00:06:57,619 --> 00:07:01,369
good shape at Braintree it was in use

00:06:59,419 --> 00:07:03,439
for several of these internal proxies it

00:07:01,369 --> 00:07:05,539
served us well for a couple of years and

00:07:03,439 --> 00:07:08,269
it had several internal advocates not

00:07:05,539 --> 00:07:09,529
just me but other people too so what

00:07:08,269 --> 00:07:12,919
happened that I'm giving a talk called

00:07:09,529 --> 00:07:14,869
Python not recommended the platform

00:07:12,919 --> 00:07:17,809
really did fail us as we started the

00:07:14,869 --> 00:07:20,619
scale concurrency and the framework

00:07:17,809 --> 00:07:23,869
really isn't enough nowadays we sort of

00:07:20,619 --> 00:07:27,439
expect our languages to have concurrency

00:07:23,869 --> 00:07:29,839
built in as Python 3 now does and as go

00:07:27,439 --> 00:07:31,909
and many other languages do and you

00:07:29,839 --> 00:07:33,139
really expect that concurrency logic to

00:07:31,909 --> 00:07:35,659
not get in your way when you're writing

00:07:33,139 --> 00:07:37,129
business logic which we found that the

00:07:35,659 --> 00:07:39,679
concurrency logic and tornado really

00:07:37,129 --> 00:07:43,419
does it was also too much work to keep

00:07:39,679 --> 00:07:46,249
up with changes and tornado we looked at

00:07:43,419 --> 00:07:47,569
new versions a couple of times and it

00:07:46,249 --> 00:07:50,029
would have really been a complete

00:07:47,569 --> 00:07:51,589
rewrite to use the new AP is and we

00:07:50,029 --> 00:07:52,819
really didn't want to spend the time for

00:07:51,589 --> 00:07:54,079
that and we didn't trust that we would

00:07:52,819 --> 00:07:56,899
be able to make those changes without

00:07:54,079 --> 00:07:58,369
breaking anything and so because we were

00:07:56,899 --> 00:08:01,279
using an outdated tornado version

00:07:58,369 --> 00:08:03,499
maintenance overhead could really be

00:08:01,279 --> 00:08:04,789
pretty high you can't Google things

00:08:03,499 --> 00:08:06,619
easily because people have moved on to

00:08:04,789 --> 00:08:08,179
newer versions it's hard to find the

00:08:06,619 --> 00:08:10,309
right docs and you end up and call back

00:08:08,179 --> 00:08:13,189
hell because you're still using old less

00:08:10,309 --> 00:08:16,669
elegant api's we found that logging

00:08:13,189 --> 00:08:18,919
actually has an unsettling lehigh

00:08:16,669 --> 00:08:23,599
overhead every time we led logged a line

00:08:18,919 --> 00:08:25,219
we saw requests pause and eventually

00:08:23,599 --> 00:08:27,529
those pauses added up to enough to be

00:08:25,219 --> 00:08:29,990
really significant as our volume scaled

00:08:27,529 --> 00:08:33,769
and then there's no sni support in

00:08:29,990 --> 00:08:35,300
Python to historically S&I lets you

00:08:33,769 --> 00:08:38,300
serve multiple as sales certificates in

00:08:35,300 --> 00:08:41,680
same server port a lot of our customers

00:08:38,300 --> 00:08:44,180
used it and it was only very recently

00:08:41,680 --> 00:08:45,889
introduced into python too but the

00:08:44,180 --> 00:08:47,839
version of Tornado we're using is so old

00:08:45,889 --> 00:08:50,720
that even if the Python supports it the

00:08:47,839 --> 00:08:53,269
tornado version doesn't the applications

00:08:50,720 --> 00:08:53,600
that we wrote also really failed us and

00:08:53,269 --> 00:08:55,490
a lot

00:08:53,600 --> 00:08:57,589
this ties in with those platform

00:08:55,490 --> 00:09:00,139
failures but it's also to a large extent

00:08:57,589 --> 00:09:02,449
our fault the smart proxies are really

00:09:00,139 --> 00:09:04,100
too smart the logic was all mixed in

00:09:02,449 --> 00:09:05,839
with the concurrency boilerplate making

00:09:04,100 --> 00:09:07,279
it hard to understand and they were

00:09:05,839 --> 00:09:09,259
trying to do so many things that the

00:09:07,279 --> 00:09:10,459
code ended up that was meant to do one

00:09:09,259 --> 00:09:12,139
thing was coupled with the code that was

00:09:10,459 --> 00:09:14,060
meant to do something else so when we

00:09:12,139 --> 00:09:16,009
tried to rip out the code to do

00:09:14,060 --> 00:09:17,449
connection pausing it completely broke

00:09:16,009 --> 00:09:19,069
rate limiting and we had to put it back

00:09:17,449 --> 00:09:21,009
and leave this completely now unused

00:09:19,069 --> 00:09:23,000
code in the in the codebase

00:09:21,009 --> 00:09:25,339
straightforward Python implementations

00:09:23,000 --> 00:09:27,079
as we scaled were not fast enough so the

00:09:25,339 --> 00:09:29,660
rate-limiting code started to add an

00:09:27,079 --> 00:09:33,110
unacceptable amount of overhead to every

00:09:29,660 --> 00:09:34,490
request that came in we also found that

00:09:33,110 --> 00:09:36,829
in addition to being too smart the

00:09:34,490 --> 00:09:39,380
practice were not smart enough we

00:09:36,829 --> 00:09:41,810
couldn't just write certain pieces of

00:09:39,380 --> 00:09:44,420
business in the proxy the business logic

00:09:41,810 --> 00:09:48,410
had to be duplicated in the main

00:09:44,420 --> 00:09:49,819
application and that's something that we

00:09:48,410 --> 00:09:52,579
really don't like we don't like writing

00:09:49,819 --> 00:09:53,720
the same logic twice and none of these

00:09:52,579 --> 00:09:56,149
applications were really built for

00:09:53,720 --> 00:09:58,579
horizontal scalability they all assumed

00:09:56,149 --> 00:10:00,769
that a single or in some cases a small

00:09:58,579 --> 00:10:02,779
number of instances would be enough

00:10:00,769 --> 00:10:04,850
forever and so they weren't designed for

00:10:02,779 --> 00:10:07,209
us to run ten or a hundred of these they

00:10:04,850 --> 00:10:11,839
were designed for us to run two or three

00:10:07,209 --> 00:10:14,180
so what solutions to be switched to what

00:10:11,839 --> 00:10:17,389
did we what made Python obsolete in

00:10:14,180 --> 00:10:20,029
these areas so for our incoming requests

00:10:17,389 --> 00:10:22,160
proxy we've switched to a combination of

00:10:20,029 --> 00:10:24,529
engine X and H a proxy along with PG

00:10:22,160 --> 00:10:26,509
bouncer so in engine X and H a proxy

00:10:24,529 --> 00:10:28,699
were able to do approximately the same

00:10:26,509 --> 00:10:31,389
complicated rate-limiting logic and load

00:10:28,699 --> 00:10:34,880
balancing that we were able to do

00:10:31,389 --> 00:10:37,519
previously with our proxy in a pull

00:10:34,880 --> 00:10:39,380
layer and we've also moved pausing

00:10:37,519 --> 00:10:41,660
completely out of the proxy layer and

00:10:39,380 --> 00:10:42,889
into PG bouncer which is basically

00:10:41,660 --> 00:10:47,660
another proxy that sits between the

00:10:42,889 --> 00:10:51,259
applications in postgresql we then wrote

00:10:47,660 --> 00:10:53,209
our main outgoing proxy as in no DJ s

00:10:51,259 --> 00:10:55,970
but this was actually a failed attempt

00:10:53,209 --> 00:10:58,160
it had all the same types of problems as

00:10:55,970 --> 00:11:00,620
Python it was still trying to write our

00:10:58,160 --> 00:11:02,269
own tool to do a job that we were an

00:11:00,620 --> 00:11:04,610
expert set and we had problems with

00:11:02,269 --> 00:11:06,559
failed persistent connections and with

00:11:04,610 --> 00:11:07,490
memory leaks in node that led us to

00:11:06,559 --> 00:11:10,760
abandon it and move

00:11:07,490 --> 00:11:13,850
to engine X and H a proxy now the key

00:11:10,760 --> 00:11:15,830
here was timing is that H a proxy 1.6

00:11:13,850 --> 00:11:18,440
had features that we really needed and

00:11:15,830 --> 00:11:20,750
so we've we've now moved to that and it

00:11:18,440 --> 00:11:24,589
allows us to remove another custom piece

00:11:20,750 --> 00:11:27,200
of code from our system finally our sort

00:11:24,589 --> 00:11:29,810
of most complicated outgoing proxy we've

00:11:27,200 --> 00:11:32,120
decided to rewrite to enclosure using

00:11:29,810 --> 00:11:33,740
apache Kafka and it allows us to

00:11:32,120 --> 00:11:35,630
centralize all the logic in a single

00:11:33,740 --> 00:11:37,520
application we can build it pretty

00:11:35,630 --> 00:11:39,320
easily to horizontally scale almost

00:11:37,520 --> 00:11:41,120
linearly and of course you get sni

00:11:39,320 --> 00:11:44,300
support with the JVM right out of the

00:11:41,120 --> 00:11:45,800
box and unfortunately we canceled that

00:11:44,300 --> 00:11:46,970
project because it wasn't a high

00:11:45,800 --> 00:11:50,330
priority it was going to take a lot of

00:11:46,970 --> 00:11:53,540
time and so instead i wrote a monkey

00:11:50,330 --> 00:11:55,490
patch of tornado to support S&I even

00:11:53,540 --> 00:11:57,290
though it's a really really old version

00:11:55,490 --> 00:11:58,820
tornado so it's not great we still have

00:11:57,290 --> 00:12:01,670
logic duplication between different

00:11:58,820 --> 00:12:03,440
applications and we still have sort of

00:12:01,670 --> 00:12:05,510
lack of horizontal scalability we

00:12:03,440 --> 00:12:07,610
basically run two of these proxies but

00:12:05,510 --> 00:12:12,470
for now it's okay but the problems are

00:12:07,610 --> 00:12:15,860
unsolved so as of late 2014 all the

00:12:12,470 --> 00:12:19,160
smart proxies were on the way out or in

00:12:15,860 --> 00:12:21,079
use but not because we wanted to not

00:12:19,160 --> 00:12:22,670
recommended for new projects it's

00:12:21,079 --> 00:12:25,670
official it's in the documentation that

00:12:22,670 --> 00:12:27,860
we use at Braintree and there were fewer

00:12:25,670 --> 00:12:29,209
internal advocates now this isn't

00:12:27,860 --> 00:12:31,339
because all the Python developers got

00:12:29,209 --> 00:12:33,170
mad and left braintree but a lot of

00:12:31,339 --> 00:12:35,510
people who used to really like Python

00:12:33,170 --> 00:12:39,579
now have moved on and prefer our

00:12:35,510 --> 00:12:41,510
languages like go or closure or lick sir

00:12:39,579 --> 00:12:43,040
some of which have more in common with

00:12:41,510 --> 00:12:44,990
Ruby so you can understand it and some

00:12:43,040 --> 00:12:48,050
of which just have better concurrency

00:12:44,990 --> 00:12:49,370
primitives than Python 2 just to be

00:12:48,050 --> 00:12:51,800
clear I don't fall into any of these

00:12:49,370 --> 00:12:55,579
groups i still like python and still use

00:12:51,800 --> 00:12:57,649
it outside of work so this is kind of

00:12:55,579 --> 00:12:59,779
sad and it makes it really sound like

00:12:57,649 --> 00:13:02,300
the state of python at braintree was

00:12:59,779 --> 00:13:05,990
really sad but that's because that's the

00:13:02,300 --> 00:13:07,399
point of the talk we've definitely there

00:13:05,990 --> 00:13:09,740
is something we will never use Python

00:13:07,399 --> 00:13:11,540
for again but actually things are

00:13:09,740 --> 00:13:13,339
looking up overall we're now using

00:13:11,540 --> 00:13:15,800
Python in areas where it really shows

00:13:13,339 --> 00:13:17,779
its strength instead of just sort of as

00:13:15,800 --> 00:13:19,930
the Swiss Army knife glue code of our

00:13:17,779 --> 00:13:22,930
code base

00:13:19,930 --> 00:13:24,640
so the first place is data analysis this

00:13:22,930 --> 00:13:28,839
is probably surprising today exactly no

00:13:24,640 --> 00:13:31,000
one our business analysts have really

00:13:28,839 --> 00:13:32,950
used it to replace Excel to write sort

00:13:31,000 --> 00:13:34,480
of one-off reports and do smaller

00:13:32,950 --> 00:13:36,760
monthly tasks that don't really need to

00:13:34,480 --> 00:13:39,339
be automated our data analysts have

00:13:36,760 --> 00:13:41,290
moved more and more from writing giant

00:13:39,339 --> 00:13:43,600
crazy blocks of SQL to putting more

00:13:41,290 --> 00:13:45,459
logic in Python so that the code is more

00:13:43,600 --> 00:13:47,410
maintainable and understandable to a

00:13:45,459 --> 00:13:48,310
larger group of people and these are

00:13:47,410 --> 00:13:50,050
people who may be done a little

00:13:48,310 --> 00:13:52,140
programming before but are really buying

00:13:50,050 --> 00:13:54,790
into Python very rapidly which is cool

00:13:52,140 --> 00:13:57,160
and finally our data scientists are

00:13:54,790 --> 00:13:59,050
really using it to replace our part of

00:13:57,160 --> 00:14:00,610
that is because of the great modeling

00:13:59,050 --> 00:14:02,529
and analysis tools that Python now has

00:14:00,610 --> 00:14:04,180
but primarily it's because it's a lot

00:14:02,529 --> 00:14:05,980
easier to deploy your solution it's a

00:14:04,180 --> 00:14:09,040
lot easier to do the sort of ETL steps

00:14:05,980 --> 00:14:12,540
that happened before you do the modeling

00:14:09,040 --> 00:14:15,430
in Python that it ever it wasn't our

00:14:12,540 --> 00:14:17,350
finally well the next thing is really

00:14:15,430 --> 00:14:18,760
infrastructure management and this is

00:14:17,350 --> 00:14:22,000
somewhere that historically we bought

00:14:18,760 --> 00:14:24,459
into puppet wholesale we have huge

00:14:22,000 --> 00:14:28,209
repositories full of puppet code puppet

00:14:24,459 --> 00:14:30,160
is a ruby based tool but recently we

00:14:28,209 --> 00:14:33,310
found that python has a really good and

00:14:30,160 --> 00:14:35,620
easier and we use it to manage certain

00:14:33,310 --> 00:14:37,600
resources like IP address physical ports

00:14:35,620 --> 00:14:38,920
server locations this is something we

00:14:37,600 --> 00:14:41,320
actually didn't do with puppet we did

00:14:38,920 --> 00:14:43,779
with a bunch of Google Spreadsheets so

00:14:41,320 --> 00:14:46,779
the centralized application with a lot

00:14:43,779 --> 00:14:49,720
of the like better views into the data

00:14:46,779 --> 00:14:52,480
is really helpful we've also use it to

00:14:49,720 --> 00:14:54,459
manage cloud instances because we run

00:14:52,480 --> 00:14:55,959
our own physical hardware for a lot of

00:14:54,459 --> 00:14:57,730
things we had a pretty unsophisticated

00:14:55,959 --> 00:15:00,670
setup for managing cloud infrastructures

00:14:57,730 --> 00:15:02,170
namely we used the AED user interfaces

00:15:00,670 --> 00:15:04,420
we basically log into the website and

00:15:02,170 --> 00:15:05,470
would start and snap instances now that

00:15:04,420 --> 00:15:08,140
we're starting to do more and more

00:15:05,470 --> 00:15:12,520
things automatically and need scale a

00:15:08,140 --> 00:15:14,440
excuse me you scaling we had to have an

00:15:12,520 --> 00:15:18,010
automated tool and Python is the right

00:15:14,440 --> 00:15:22,329
way to do that and finally we use our

00:15:18,010 --> 00:15:25,390
switches for slightly complicated setups

00:15:22,329 --> 00:15:27,040
we do try and make sure that even if

00:15:25,390 --> 00:15:28,990
switches fail in our data center

00:15:27,040 --> 00:15:31,690
everything keeps going so everything is

00:15:28,990 --> 00:15:33,520
all the networking is mesh and the

00:15:31,690 --> 00:15:35,410
switch configurations are

00:15:33,520 --> 00:15:37,510
pretty complicated and we didn't find a

00:15:35,410 --> 00:15:39,970
good way to manage them with puppet and

00:15:37,510 --> 00:15:42,010
we found that rather than writing a

00:15:39,970 --> 00:15:43,510
custom puppet module which is can be

00:15:42,010 --> 00:15:45,640
pretty complicated it was actually

00:15:43,510 --> 00:15:47,590
easier to emulate what puppet does in

00:15:45,640 --> 00:15:49,860
Python and pull from the same data

00:15:47,590 --> 00:15:52,990
source that our puppet repository does

00:15:49,860 --> 00:15:54,580
and so all the code is in Python and

00:15:52,990 --> 00:15:56,290
it's like a hundred lines rather than

00:15:54,580 --> 00:15:57,370
writing a very complicated puppet module

00:15:56,290 --> 00:16:00,280
that we'd never be able to change

00:15:57,370 --> 00:16:02,200
because no other stood how it worked the

00:16:00,280 --> 00:16:05,230
Python community is sort of the final

00:16:02,200 --> 00:16:06,730
thing it's a big advantage of the

00:16:05,230 --> 00:16:08,950
language in my opinion and something

00:16:06,730 --> 00:16:11,310
that has been very beneficial to

00:16:08,950 --> 00:16:13,720
Braintree we host a lot of Python

00:16:11,310 --> 00:16:17,650
meetups we have a monthly project night

00:16:13,720 --> 00:16:19,810
we host chippy the chicago python meetup

00:16:17,650 --> 00:16:22,120
about twice a year we've done a couple

00:16:19,810 --> 00:16:24,820
of events with pi ladies now and one

00:16:22,120 --> 00:16:26,890
with Django girls and we've also

00:16:24,820 --> 00:16:28,630
sponsored other events outside the

00:16:26,890 --> 00:16:31,150
office and this has really helped with

00:16:28,630 --> 00:16:32,590
our hiring we've hired several people

00:16:31,150 --> 00:16:34,450
now who first heard about Braintree

00:16:32,590 --> 00:16:35,650
through these events and came to

00:16:34,450 --> 00:16:37,300
Braintree even though they don't get to

00:16:35,650 --> 00:16:39,520
write Python because they know we

00:16:37,300 --> 00:16:40,930
support the community and recruiting is

00:16:39,520 --> 00:16:43,870
one of the hardest things we do so this

00:16:40,930 --> 00:16:45,280
has been super helpful we also find that

00:16:43,870 --> 00:16:47,320
giving talks is a great way to spread

00:16:45,280 --> 00:16:49,390
the word about Braintree and I'm not the

00:16:47,320 --> 00:16:51,850
only one giving Python talks one of my

00:16:49,390 --> 00:16:54,430
colleagues has given a couple in Chicago

00:16:51,850 --> 00:16:57,550
and has given one with me at

00:16:54,430 --> 00:16:59,980
Northwestern University our customers

00:16:57,550 --> 00:17:01,570
also use Python so having us support the

00:16:59,980 --> 00:17:03,790
Python community makes them feel more

00:17:01,570 --> 00:17:05,320
connected to us some of the biggest

00:17:03,790 --> 00:17:07,839
startups in the world who are customers

00:17:05,320 --> 00:17:09,459
of ours have pretty large Python code

00:17:07,839 --> 00:17:11,140
bases and it's much easier for them to

00:17:09,459 --> 00:17:13,270
keep using Python to connect to us and

00:17:11,140 --> 00:17:18,339
that includes as they migrated to Python

00:17:13,270 --> 00:17:21,040
3 we have our Python library is single

00:17:18,339 --> 00:17:22,990
code base Python 2 and Python 3 and a

00:17:21,040 --> 00:17:25,209
significant amount of Python 3 traffic

00:17:22,990 --> 00:17:28,810
comes to our API so having that and

00:17:25,209 --> 00:17:31,690
supporting sort of the next the future

00:17:28,810 --> 00:17:36,490
of python has helped us gain and keep

00:17:31,690 --> 00:17:38,920
merchants so now we're at 2015 so what's

00:17:36,490 --> 00:17:40,690
the state of Python now Python 2 is

00:17:38,920 --> 00:17:42,430
definitely showing its age internally

00:17:40,690 --> 00:17:44,800
and in general especially around

00:17:42,430 --> 00:17:47,020
concurrency I don't think anybody really

00:17:44,800 --> 00:17:48,880
disagrees with that and

00:17:47,020 --> 00:17:51,970
as the standard tools like H a proxy and

00:17:48,880 --> 00:17:53,620
engine acts improved more and more we're

00:17:51,970 --> 00:17:55,420
sort of losing a use case for Python

00:17:53,620 --> 00:17:56,680
being the jack-of-all-trades the

00:17:55,420 --> 00:17:59,260
language you can use to write whatever

00:17:56,680 --> 00:18:00,880
tool you need is a little less important

00:17:59,260 --> 00:18:02,940
as the standard tools tend to be there

00:18:00,880 --> 00:18:05,230
for scaling and for high-availability

00:18:02,940 --> 00:18:07,480
data science is really important for

00:18:05,230 --> 00:18:10,060
pythons future I think it gets the foot

00:18:07,480 --> 00:18:12,520
in the door for Python at pretty much

00:18:10,060 --> 00:18:14,650
every company which is a great way to

00:18:12,520 --> 00:18:17,140
keep people who like Python interested

00:18:14,650 --> 00:18:20,410
and to sort of keep it in your mind for

00:18:17,140 --> 00:18:22,120
when to choose it for other projects the

00:18:20,410 --> 00:18:24,970
community is also really important it's

00:18:22,120 --> 00:18:27,670
been great for us at braintree and it's

00:18:24,970 --> 00:18:31,900
just one of the reasons that python is

00:18:27,670 --> 00:18:36,870
as successful as it is thank you that's

00:18:31,900 --> 00:18:36,870
all I have I'm glad to take questions

00:18:50,710 --> 00:18:58,460
Thanks first great talk thanks a lot

00:18:53,510 --> 00:19:00,500
I'll question about like if you see

00:18:58,460 --> 00:19:02,360
yourself as a tech hub more or less if

00:19:00,500 --> 00:19:04,370
you have some impact sorry I'm having

00:19:02,360 --> 00:19:05,540
trouble understanding you so now I'm a

00:19:04,370 --> 00:19:09,050
little hard of hearing so you're gonna

00:19:05,540 --> 00:19:14,060
have to speak up Thanks and the question

00:19:09,050 --> 00:19:17,570
is about if you have any interns I mean

00:19:14,060 --> 00:19:20,210
people who like students or such walk

00:19:17,570 --> 00:19:23,150
into your company I'll be keen on

00:19:20,210 --> 00:19:26,480
learning python or something more how

00:19:23,150 --> 00:19:27,890
does they act in your community I'm

00:19:26,480 --> 00:19:29,660
sorry could somebody else repeat the

00:19:27,890 --> 00:19:31,070
question I just had trouble

00:19:29,660 --> 00:19:34,280
understanding at is it advice for

00:19:31,070 --> 00:19:36,200
students about choosing Python or

00:19:34,280 --> 00:19:39,050
something else if they come to your

00:19:36,200 --> 00:19:41,090
company or your like environment the

00:19:39,050 --> 00:19:42,920
keen on learning python or something

00:19:41,090 --> 00:19:45,790
else like Ruby or stuff so what do they

00:19:42,920 --> 00:19:48,110
do what do they choose how do they act

00:19:45,790 --> 00:19:52,760
do they choose to learn Ruby or choose

00:19:48,110 --> 00:19:58,070
to learn Python yeah yeah mom so I think

00:19:52,760 --> 00:19:59,990
that we definitely look for people who

00:19:58,070 --> 00:20:01,400
don't want to do one specific thing we

00:19:59,990 --> 00:20:03,320
look for people who want to learn and

00:20:01,400 --> 00:20:05,330
want to use whatever tool is best for

00:20:03,320 --> 00:20:06,920
the job at braintree so I think that a

00:20:05,330 --> 00:20:09,380
lot of the people we hire and a lot of

00:20:06,920 --> 00:20:10,940
the students we talked to our people who

00:20:09,380 --> 00:20:13,430
have maybe done Python at school but are

00:20:10,940 --> 00:20:16,030
open to learning anything I'm not sure

00:20:13,430 --> 00:20:16,030
if that answers your question

00:20:21,960 --> 00:20:25,770
the the non-programmers or the

00:20:24,539 --> 00:20:27,659
non-professional program is like the

00:20:25,770 --> 00:20:30,059
analysts you talked about did they

00:20:27,659 --> 00:20:31,860
choose Python because they tried other

00:20:30,059 --> 00:20:34,440
options and like closure and didn't like

00:20:31,860 --> 00:20:36,390
them or because they already knew Python

00:20:34,440 --> 00:20:38,250
her because you suggested it what was

00:20:36,390 --> 00:20:43,770
how does it find its way into their

00:20:38,250 --> 00:20:45,870
their job so the sort of a guy who

00:20:43,770 --> 00:20:50,820
started our business analyst and

00:20:45,870 --> 00:20:53,309
analytics team he'd been doing a lot of

00:20:50,820 --> 00:20:58,140
our reporting manually in Excel for

00:20:53,309 --> 00:21:00,000
years and he decided to learn to program

00:20:58,140 --> 00:21:02,220
and so first he actually learned Ruby

00:21:00,000 --> 00:21:06,110
and he wrote a web application that we

00:21:02,220 --> 00:21:06,110

YouTube URL: https://www.youtube.com/watch?v=JBItMmAvlN4


