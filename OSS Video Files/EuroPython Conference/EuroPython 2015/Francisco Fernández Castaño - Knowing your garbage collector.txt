Title: Francisco Fern치ndez Casta침o - Knowing your garbage collector
Publication date: 2015-08-08
Playlist: EuroPython 2015
Description: 
	Francisco Fern치ndez Casta침o - Knowing your garbage collector
[EuroPython 2015]
[20 July 2015]
[Bilbao, Euskadi, Spain]

As Python programmers we're used to program without taking care about allocating
memory for our objects and later on freeing them, Python garbage collector
takes care of this task automatically for us.

Garbage collection is one of the most challenging topics in computer science,
there are a lot of research around the topic and different ways to tackle
the problem.

Knowing how our language does this process give us a better understanding
of underlying interpreter and allow us to know why problems like cycles
can happen in CPython interpreters.

So, this talk aims to be and introduction to the topic and a walkaround
through different approaches followed in CPython and PyPy:

* Generational Reference counting with cycles detector on CPython.
* Incremental version of the MiniMark GC on PyPy.
Captions: 
	00:00:03,110 --> 00:00:08,580
so hi thank you for coming Francisco

00:00:06,870 --> 00:00:10,590
Fernandez here you have my twitter

00:00:08,580 --> 00:00:13,469
handle if you want to ask me something

00:00:10,590 --> 00:00:14,759
we're in the talk or whatever also you

00:00:13,469 --> 00:00:17,750
have some questions during the talk

00:00:14,759 --> 00:00:20,100
don't doubt about interrupting me so

00:00:17,750 --> 00:00:21,810
okay a little star today I'm going to

00:00:20,100 --> 00:00:24,960
talk about a garbage collection on

00:00:21,810 --> 00:00:27,840
Python here we have the agenda of the

00:00:24,960 --> 00:00:31,260
this today talk in first place aloo an

00:00:27,840 --> 00:00:33,899
introduction then include the motivation

00:00:31,260 --> 00:00:37,170
why I think this talk could be

00:00:33,899 --> 00:00:39,379
interesting for a Python developer so no

00:00:37,170 --> 00:00:42,210
problem some manual memory management

00:00:39,379 --> 00:00:45,000
Sun definition some garbage collection

00:00:42,210 --> 00:00:47,969
from academia that I think is also quite

00:00:45,000 --> 00:00:51,120
interesting to do know about and also

00:00:47,969 --> 00:00:54,629
every solution has some trade-offs so we

00:00:51,120 --> 00:00:57,600
will explore them later on we will see

00:00:54,629 --> 00:00:59,940
how C Python implements a garbage

00:00:57,600 --> 00:01:02,190
collection we need to know something

00:00:59,940 --> 00:01:05,040
we're a little bit about this

00:01:02,190 --> 00:01:08,250
implementation so there will be a little

00:01:05,040 --> 00:01:11,880
bit about see on would see and then I'll

00:01:08,250 --> 00:01:15,240
explain the algorithm itself and finally

00:01:11,880 --> 00:01:18,990
the cycle detector and if I have enough

00:01:15,240 --> 00:01:21,780
time I'll try to do a high overview of

00:01:18,990 --> 00:01:26,549
how pipe i approach garbage collection

00:01:21,780 --> 00:01:29,100
so let me start okay what's what's the

00:01:26,549 --> 00:01:31,350
motivation on knowing more about garbage

00:01:29,100 --> 00:01:33,119
collection or memory management we don't

00:01:31,350 --> 00:01:36,360
need to take care of most of the dynoed

00:01:33,119 --> 00:01:39,329
memory in Python where some kind of

00:01:36,360 --> 00:01:42,360
lucky most of the time we are working on

00:01:39,329 --> 00:01:46,229
business logic layer because probably

00:01:42,360 --> 00:01:48,990
most of us we are developers not Python

00:01:46,229 --> 00:01:51,560
core developers we don't do and native

00:01:48,990 --> 00:01:54,509
extensions so we use a lot of

00:01:51,560 --> 00:01:58,290
extractions that the language give to us

00:01:54,509 --> 00:02:01,229
without knowing more for example we use

00:01:58,290 --> 00:02:02,670
a lot dictionaries and we don't know we

00:02:01,229 --> 00:02:05,280
don't need to take care about how the

00:02:02,670 --> 00:02:07,049
dictionaries are implemented or the

00:02:05,280 --> 00:02:10,020
layer between the operating system and

00:02:07,049 --> 00:02:13,050
the standard library and also memories

00:02:10,020 --> 00:02:16,320
another abstraction that we have

00:02:13,050 --> 00:02:19,170
sometimes is useful to know about so

00:02:16,320 --> 00:02:21,060
we'll know more today I hope that you

00:02:19,170 --> 00:02:26,880
want know more about how memory is

00:02:21,060 --> 00:02:30,060
managing in Python okay but monitoring

00:02:26,880 --> 00:02:34,080
memory manual is is hard how many of you

00:02:30,060 --> 00:02:36,030
are familiar with C or C++ place race so

00:02:34,080 --> 00:02:39,930
you know prolly you know how difficult

00:02:36,030 --> 00:02:43,020
sometimes is managing memory manually

00:02:39,930 --> 00:02:45,930
there is a lot of problems but I try to

00:02:43,020 --> 00:02:49,080
list here well the most known is memory

00:02:45,930 --> 00:02:51,630
leaks but basically is that we allocate

00:02:49,080 --> 00:02:53,820
memory for some resourced and after

00:02:51,630 --> 00:02:57,330
using it we do not be allocated within

00:02:53,820 --> 00:03:00,900
the widow death most of the times by

00:02:57,330 --> 00:03:04,200
accident no purpose another problem that

00:03:00,900 --> 00:03:05,880
we have is the ownership let's say for

00:03:04,200 --> 00:03:09,120
example like in this snippet of code

00:03:05,880 --> 00:03:11,790
this is some kind of library and this

00:03:09,120 --> 00:03:13,800
library allocates memory on the hip and

00:03:11,790 --> 00:03:16,680
it returns a pointer okay everything

00:03:13,800 --> 00:03:19,920
fine but who is responsible on three

00:03:16,680 --> 00:03:23,820
industry sauce with the library to do i

00:03:19,920 --> 00:03:26,010
do the free 3d source this leads to the

00:03:23,820 --> 00:03:28,500
protein or double fries what happened if

00:03:26,010 --> 00:03:30,450
I free the resource and again the

00:03:28,500 --> 00:03:33,030
library somehow had the pointer and

00:03:30,450 --> 00:03:34,530
finally tried to free we end up with a

00:03:33,030 --> 00:03:38,489
segmentation fault in the rest of the

00:03:34,530 --> 00:03:42,360
cases another problem that you can have

00:03:38,489 --> 00:03:44,370
is dangling pointers for example with

00:03:42,360 --> 00:03:47,250
another snippet of code we are

00:03:44,370 --> 00:03:50,670
allocating here party on the stack and

00:03:47,250 --> 00:03:53,459
returning the reference and once we are

00:03:50,670 --> 00:03:56,340
out of the scope this address is not

00:03:53,459 --> 00:04:00,630
valid anymore so again we will end up

00:03:56,340 --> 00:04:02,280
with strange behaviors cementation for

00:04:00,630 --> 00:04:06,270
will be the rest of the cases because

00:04:02,280 --> 00:04:08,850
you know that something is wrong values

00:04:06,270 --> 00:04:12,540
that are not correctly is a difficult

00:04:08,850 --> 00:04:15,060
one some languages propose some

00:04:12,540 --> 00:04:18,060
solutions answer pads on patents but for

00:04:15,060 --> 00:04:21,090
example C++ they try to apply as much as

00:04:18,060 --> 00:04:25,110
possible right pattern they also

00:04:21,090 --> 00:04:26,490
introduce some some tools under standard

00:04:25,110 --> 00:04:29,550
library like unique point

00:04:26,490 --> 00:04:31,770
sir pointer and also there are another

00:04:29,550 --> 00:04:35,069
approaches like in rest that they try to

00:04:31,770 --> 00:04:37,139
make language safe on compile time there

00:04:35,069 --> 00:04:39,539
is lot of solutions I don't know if in

00:04:37,139 --> 00:04:44,610
see you have much tools to deal with

00:04:39,539 --> 00:04:47,610
that but we cannot have garbage

00:04:44,610 --> 00:04:49,710
collection in every scenario there are

00:04:47,610 --> 00:04:51,870
some scenarios where is mandatory to

00:04:49,710 --> 00:04:53,910
have full control of memory one other

00:04:51,870 --> 00:04:56,039
thing could be embedded systems where we

00:04:53,910 --> 00:04:59,909
have very limited resources and we need

00:04:56,039 --> 00:05:03,630
to carefully at build with memory also

00:04:59,909 --> 00:05:05,849
for example we have very demanding

00:05:03,630 --> 00:05:08,940
applications like a video game can be

00:05:05,849 --> 00:05:12,120
where for example we need to know very

00:05:08,940 --> 00:05:14,310
carefully how the memory layout is to

00:05:12,120 --> 00:05:16,380
try to avoid a cache misses and so on

00:05:14,310 --> 00:05:19,349
and also applications and need

00:05:16,380 --> 00:05:22,590
determinism because most of the items as

00:05:19,349 --> 00:05:24,900
far as I know garbage collection we

00:05:22,590 --> 00:05:27,690
don't know for sure when our resources

00:05:24,900 --> 00:05:29,849
delicated so there are scenarios where

00:05:27,690 --> 00:05:33,330
garbage collection works another than

00:05:29,849 --> 00:05:34,620
not but what is all this about the

00:05:33,330 --> 00:05:38,039
garbage collection probably most of you

00:05:34,620 --> 00:05:40,550
know what is but you would like to

00:05:38,039 --> 00:05:43,080
introduce you a little bit about history

00:05:40,550 --> 00:05:45,690
yeah we have a picture of mr. John

00:05:43,080 --> 00:05:48,990
McCarthy playing chess with a computer

00:05:45,690 --> 00:05:51,360
and he was kind of inventor of garbage

00:05:48,990 --> 00:05:53,400
collection in this paper from the ninth

00:05:51,360 --> 00:05:55,080
exists is the first mention to garbage

00:05:53,400 --> 00:05:56,759
collection on record set function of

00:05:55,080 --> 00:05:59,400
symbolic expressions and their

00:05:56,759 --> 00:06:02,069
computation my machine and it's kind of

00:05:59,400 --> 00:06:04,500
funny because he described the whole

00:06:02,069 --> 00:06:08,460
process he described Malcolm swivel

00:06:04,500 --> 00:06:10,349
coriander and as a footnote he says ok

00:06:08,460 --> 00:06:12,750
I've been named in this process garbage

00:06:10,349 --> 00:06:16,039
collection but I know that occur unas

00:06:12,750 --> 00:06:19,229
had bit picky and I won't use finally

00:06:16,039 --> 00:06:21,990
academia uses garbage collection so kind

00:06:19,229 --> 00:06:23,969
of funny so what's the formal definition

00:06:21,990 --> 00:06:26,330
of garbage collection garbage collection

00:06:23,969 --> 00:06:29,310
is basically automatic memory management

00:06:26,330 --> 00:06:31,680
while a mediator runs it fraternally

00:06:29,310 --> 00:06:33,719
allocates memory from the hip it more

00:06:31,680 --> 00:06:35,520
memory donnell available is needed the

00:06:33,719 --> 00:06:38,219
collector reclaims a nice memory and

00:06:35,520 --> 00:06:40,620
return if they hit this sounds too

00:06:38,219 --> 00:06:42,900
formal but is quite

00:06:40,620 --> 00:06:45,150
for the mutator do you have their

00:06:42,900 --> 00:06:48,840
definition but vehicle is our business

00:06:45,150 --> 00:06:53,130
logic signals the hip is where the

00:06:48,840 --> 00:06:57,030
memory is allocated and the collector is

00:06:53,130 --> 00:06:59,220
their garbage collection algorithm

00:06:57,030 --> 00:07:00,949
itself in our case python which are

00:06:59,220 --> 00:07:06,240
machines they won't that take care about

00:07:00,949 --> 00:07:08,940
collecting a nose and its resources if

00:07:06,240 --> 00:07:11,220
you want to dig deeper into this topic

00:07:08,940 --> 00:07:15,139
more in the academic side and this is a

00:07:11,220 --> 00:07:19,169
quite good book it's quite extensive but

00:07:15,139 --> 00:07:25,100
it's not so so formal so I recommend you

00:07:19,169 --> 00:07:27,510
to take a look but as I told you before

00:07:25,100 --> 00:07:31,979
every solution has some trade-offs

00:07:27,510 --> 00:07:33,810
nothing is perfect so we decide we are a

00:07:31,979 --> 00:07:37,110
language implement a terse and we decide

00:07:33,810 --> 00:07:39,900
to have a garbage collector language we

00:07:37,110 --> 00:07:42,720
have to know that prolly will need more

00:07:39,900 --> 00:07:46,530
resources we will have performance

00:07:42,720 --> 00:07:50,310
impacts because the algorithm has to run

00:07:46,530 --> 00:07:53,280
so we are losing CPU cycles there and on

00:07:50,310 --> 00:07:58,080
some algorithms we don't know for sure

00:07:53,280 --> 00:08:00,479
when resources will be free okay so now

00:07:58,080 --> 00:08:05,520
we will start looking into how the

00:08:00,479 --> 00:08:07,050
Python implements garbage collection it

00:08:05,520 --> 00:08:10,889
implements a reference counting

00:08:07,050 --> 00:08:12,360
algorithm okay but before we need to

00:08:10,889 --> 00:08:16,440
know a little bit about how is

00:08:12,360 --> 00:08:19,500
implemented in see this is the main

00:08:16,440 --> 00:08:21,840
object that is exposed mostly for us as

00:08:19,500 --> 00:08:25,080
a user all the time this is a pie object

00:08:21,840 --> 00:08:28,770
that is basically a strap with 22

00:08:25,080 --> 00:08:32,339
members one of them is feisty that

00:08:28,770 --> 00:08:36,599
basically is for us an integral name of

00:08:32,339 --> 00:08:39,539
ref count okay this biz member holds the

00:08:36,599 --> 00:08:43,140
number of incoming references that out

00:08:39,539 --> 00:08:47,010
death has so for example if this is

00:08:43,140 --> 00:08:49,709
another an instance be an object a as a

00:08:47,010 --> 00:08:51,450
reference to to be the country's one

00:08:49,709 --> 00:08:54,030
because it has one incoming reference

00:08:51,450 --> 00:08:56,520
and the other member is just

00:08:54,030 --> 00:09:02,520
pointer to the type this allows us to

00:08:56,520 --> 00:09:05,970
have dynamic typing okay so let's see an

00:09:02,520 --> 00:09:09,330
simple example for the purpose of this

00:09:05,970 --> 00:09:12,360
top that I want to be educational we

00:09:09,330 --> 00:09:15,420
will only take care about instances we

00:09:12,360 --> 00:09:19,230
know that a full class is also an object

00:09:15,420 --> 00:09:22,800
but for simplifying we only deal with in

00:09:19,230 --> 00:09:27,570
some instances okay so how does this

00:09:22,800 --> 00:09:31,710
look graphically okay mean is the main

00:09:27,570 --> 00:09:34,440
module and it holds two references 14 to

00:09:31,710 --> 00:09:36,330
another one for my list so those

00:09:34,440 --> 00:09:40,110
contests that I told you before are both

00:09:36,330 --> 00:09:44,730
one okay because only main is reference

00:09:40,110 --> 00:09:47,430
it in full on my list but let's make

00:09:44,730 --> 00:09:51,630
this more interesting less up and food

00:09:47,430 --> 00:09:54,750
to my list now for will have two

00:09:51,630 --> 00:09:58,980
references we can see graphically like

00:09:54,750 --> 00:10:03,780
this okay now full has both main and

00:09:58,980 --> 00:10:05,910
also my list reference it in him but

00:10:03,780 --> 00:10:09,000
that's happened but who takes care about

00:10:05,910 --> 00:10:11,730
this counter presumably is the C Python

00:10:09,000 --> 00:10:14,610
implementation so here we have a snippet

00:10:11,730 --> 00:10:17,580
of the standard library the only subject

00:10:14,610 --> 00:10:21,690
this function what it does is given the

00:10:17,580 --> 00:10:28,080
list self it appends the object be in

00:10:21,690 --> 00:10:31,790
your case foot on my list okay and take

00:10:28,080 --> 00:10:34,400
a look in into this line by in ref on V

00:10:31,790 --> 00:10:36,690
this is the point where we are

00:10:34,400 --> 00:10:41,430
incrementing by one the counter because

00:10:36,690 --> 00:10:45,540
now the the list self in this case has a

00:10:41,430 --> 00:10:49,830
reference to 2v okay this line is set in

00:10:45,540 --> 00:10:53,490
the last position element how does this

00:10:49,830 --> 00:10:58,670
pie link ref looks like like in a lot of

00:10:53,490 --> 00:11:01,830
places in C Python is our ugly macro

00:10:58,670 --> 00:11:05,240
basically what it does is does a custom

00:11:01,830 --> 00:11:11,330
Opie and increment by 1 the

00:11:05,240 --> 00:11:13,730
can't you see but what happened when an

00:11:11,330 --> 00:11:18,020
object is not referenced by another one

00:11:13,730 --> 00:11:22,459
anymore well presumably the counter will

00:11:18,020 --> 00:11:24,470
be decremented by one so we can we end

00:11:22,459 --> 00:11:28,040
up with this case in the same picture as

00:11:24,470 --> 00:11:31,399
before because now my list on index zero

00:11:28,040 --> 00:11:35,089
that before had food inside now has

00:11:31,399 --> 00:11:37,520
known so now we end up again with the

00:11:35,089 --> 00:11:40,220
same picture because my list is not

00:11:37,520 --> 00:11:47,720
holding our reference to food anymore ok

00:11:40,220 --> 00:11:50,959
so too again as a return of one and how

00:11:47,720 --> 00:11:54,260
does it look like on C Python level

00:11:50,959 --> 00:11:58,610
again this is part of the list optical

00:11:54,260 --> 00:12:03,890
bootsy file that implements the dlist C

00:11:58,610 --> 00:12:06,950
Python and again we have very much like

00:12:03,890 --> 00:12:08,959
the inverse operation in graph on the

00:12:06,950 --> 00:12:11,329
old item that basically is the one that

00:12:08,959 --> 00:12:13,970
we are not interested anymore what

00:12:11,329 --> 00:12:17,899
happens there in that macro basically

00:12:13,970 --> 00:12:20,750
the counter is decremented by one but it

00:12:17,899 --> 00:12:24,440
also happened one check there in this

00:12:20,750 --> 00:12:27,620
counter is equal to 0 we know for sure

00:12:24,440 --> 00:12:30,170
that no other element no other object in

00:12:27,620 --> 00:12:34,190
the system running is interested in that

00:12:30,170 --> 00:12:39,110
of Declan amor so we can safely dialogue

00:12:34,190 --> 00:12:44,029
that that object this is what happened

00:12:39,110 --> 00:12:47,779
here does the check here if if this

00:12:44,029 --> 00:12:52,060
greater than is greater than 0 ok that's

00:12:47,779 --> 00:12:59,300
on text another case it delegate it okay

00:12:52,060 --> 00:13:02,899
it's clear till now hmm and what let's

00:12:59,300 --> 00:13:07,850
let's reproduce this case in our little

00:13:02,899 --> 00:13:10,339
example now we say to the model okay i'm

00:13:07,850 --> 00:13:14,630
not interested in info anymore delete

00:13:10,339 --> 00:13:16,970
all the references that okay so ref

00:13:14,630 --> 00:13:20,120
count reaches value 0 so

00:13:16,970 --> 00:13:22,699
we delegated what we then the garbage

00:13:20,120 --> 00:13:25,819
collector okay and the interesting thing

00:13:22,699 --> 00:13:28,519
is that once we know for sure that no

00:13:25,819 --> 00:13:30,579
other object reference it poo we can

00:13:28,519 --> 00:13:33,040
delegate we don't need to wait till

00:13:30,579 --> 00:13:39,470
collection like in other algorithms okay

00:13:33,040 --> 00:13:42,680
production phase but do you notice any

00:13:39,470 --> 00:13:45,230
problem that this approach can have any

00:13:42,680 --> 00:13:50,930
clue probably most of you know that what

00:13:45,230 --> 00:13:53,600
what happens but cycles what happened

00:13:50,930 --> 00:13:58,370
with cycles these habits don't work for

00:13:53,600 --> 00:14:01,069
four cycles okay like this now let's

00:13:58,370 --> 00:14:05,300
imagine the poo has a reference to list

00:14:01,069 --> 00:14:07,720
and we create a cycle full as a

00:14:05,300 --> 00:14:12,949
reference to my list and my list to full

00:14:07,720 --> 00:14:15,019
like this okay now both objects live in

00:14:12,949 --> 00:14:20,629
main modules or no problem they are

00:14:15,019 --> 00:14:26,209
there but what happen if we don't take

00:14:20,629 --> 00:14:29,649
care anymore out for my list we end up

00:14:26,209 --> 00:14:33,259
with a cycle and those objects are not

00:14:29,649 --> 00:14:36,050
delegated because both of this has a

00:14:33,259 --> 00:14:38,480
reference count of one and it's not

00:14:36,050 --> 00:14:40,970
possible that anyone reference it again

00:14:38,480 --> 00:14:42,910
because we don't have reference on our

00:14:40,970 --> 00:14:46,129
system we delete from the module remain

00:14:42,910 --> 00:14:47,899
so we end up with a memory leak and I

00:14:46,129 --> 00:14:50,029
told you before that one of the problems

00:14:47,899 --> 00:14:52,339
with minimal manual memory management is

00:14:50,029 --> 00:14:55,339
memory leaks and we also have here an

00:14:52,339 --> 00:14:58,309
ammonia leak so what was the pro of

00:14:55,339 --> 00:15:00,519
having garbage collection well we are

00:14:58,309 --> 00:15:04,699
lucky and in C Python implementation

00:15:00,519 --> 00:15:06,350
they implemented a cycle detector well

00:15:04,699 --> 00:15:10,660
this is another topology that we can

00:15:06,350 --> 00:15:13,579
have more complex cycles this is how

00:15:10,660 --> 00:15:16,540
those are very very simple examples but

00:15:13,579 --> 00:15:24,019
in the real world they are more complex

00:15:16,540 --> 00:15:25,870
but yeah what what happened if we have a

00:15:24,019 --> 00:15:29,570
bike on a cycle

00:15:25,870 --> 00:15:32,570
we'll explore how the Python implements

00:15:29,570 --> 00:15:37,339
algorithm to to check if there is I

00:15:32,570 --> 00:15:40,250
cycles do that garbage collectors to

00:15:37,339 --> 00:15:43,880
know more or less all the objects that

00:15:40,250 --> 00:15:47,779
are allocated on the run time and this

00:15:43,880 --> 00:15:50,120
is keep track on this on this the linked

00:15:47,779 --> 00:15:53,540
list this is a note of a lower linked

00:15:50,120 --> 00:15:57,230
list that lives in DC module with this

00:15:53,540 --> 00:16:00,339
this signature and for performance

00:15:57,230 --> 00:16:03,050
reasons and there are three generations

00:16:00,339 --> 00:16:05,630
implementation because doing a whole

00:16:03,050 --> 00:16:08,690
list can or looking for cycles on their

00:16:05,630 --> 00:16:11,720
living objects is quite costly so what

00:16:08,690 --> 00:16:14,360
they do is they divided into three three

00:16:11,720 --> 00:16:19,070
generations from the youngest one to the

00:16:14,360 --> 00:16:21,589
oldest ones and we do step by step so we

00:16:19,070 --> 00:16:26,660
don't need to check for the whole the

00:16:21,589 --> 00:16:30,860
whole living objects ok and well this is

00:16:26,660 --> 00:16:35,089
some some citrix to this is high union I

00:16:30,860 --> 00:16:39,709
don't don't take them worry about it is

00:16:35,089 --> 00:16:44,959
just some some details so let's

00:16:39,709 --> 00:16:48,140
represent our example like the one

00:16:44,959 --> 00:16:50,660
before we have those three generations

00:16:48,140 --> 00:16:52,970
and we have a full and my list both of

00:16:50,660 --> 00:16:57,950
them probably you can see in the back

00:16:52,970 --> 00:17:02,420
but both of them has the value one on GC

00:16:57,950 --> 00:17:06,650
rift dressed what was the key idea of

00:17:02,420 --> 00:17:11,600
the cycle detection algorithm on Monty

00:17:06,650 --> 00:17:13,880
Python the key idea is that we know the

00:17:11,600 --> 00:17:16,610
object that belong to a generation so

00:17:13,880 --> 00:17:20,420
what we can do is extract all the

00:17:16,610 --> 00:17:28,010
internal references on the on that

00:17:20,420 --> 00:17:30,730
generation and those objects with number

00:17:28,010 --> 00:17:33,590
of reference bigger than 0 they have

00:17:30,730 --> 00:17:37,330
references from other generation objects

00:17:33,590 --> 00:17:42,880
I don't know if I explain

00:17:37,330 --> 00:17:45,970
butter but the idea is that we we keep

00:17:42,880 --> 00:17:48,970
track only when we subtract all the

00:17:45,970 --> 00:17:50,950
reference internal references in the in

00:17:48,970 --> 00:17:56,039
the same generation I'll go step-by-step

00:17:50,950 --> 00:18:00,100
trying to explain better to do that

00:17:56,039 --> 00:18:03,640
types on internally on on C Python

00:18:00,100 --> 00:18:05,769
implementation has this method that ass

00:18:03,640 --> 00:18:09,519
tracked how to traverse all the

00:18:05,769 --> 00:18:12,610
references on an object so for example i

00:18:09,519 --> 00:18:17,139
implemented this as a Python 2 to be

00:18:12,610 --> 00:18:19,630
more clear so for example leak distract

00:18:17,139 --> 00:18:21,909
traversing all the references basically

00:18:19,630 --> 00:18:25,899
as iterating over the key and value and

00:18:21,909 --> 00:18:29,889
applying some function a list basically

00:18:25,899 --> 00:18:32,590
iterate over the all elements and apply

00:18:29,889 --> 00:18:35,559
a function this is a utility that we

00:18:32,590 --> 00:18:38,769
have for for this kind of problems like

00:18:35,559 --> 00:18:45,010
psycho detection okay so those tools

00:18:38,769 --> 00:18:47,350
help to to implement everything ok so

00:18:45,010 --> 00:18:52,360
let us start let's think that we only

00:18:47,350 --> 00:18:54,779
have full on my list on my generation 0k

00:18:52,360 --> 00:18:57,669
to simplify things as much as possible

00:18:54,779 --> 00:18:59,409
so I start iterating over the first

00:18:57,669 --> 00:19:02,820
element that in this case is the one

00:18:59,409 --> 00:19:06,010
marked in red who and what I do is using

00:19:02,820 --> 00:19:08,289
these functions depending on the type i

00:19:06,010 --> 00:19:10,870
iterate over all the references that

00:19:08,289 --> 00:19:13,779
piece out did have okay in this case is

00:19:10,870 --> 00:19:15,820
only my list and I apply one function

00:19:13,779 --> 00:19:18,850
this function what it does basically is

00:19:15,820 --> 00:19:21,070
checked that the number of references is

00:19:18,850 --> 00:19:24,100
greater than zero and decrement by one

00:19:21,070 --> 00:19:27,130
so with this way we are breaking the

00:19:24,100 --> 00:19:29,590
cycles okay because all the cycle all

00:19:27,130 --> 00:19:32,139
the internal references I'd agreement or

00:19:29,590 --> 00:19:35,529
decremented so if we have a case like

00:19:32,139 --> 00:19:38,230
like this one we are breaking it we r

00:19:35,529 --> 00:19:40,750
martinez unreachable so this is a first

00:19:38,230 --> 00:19:43,779
step for only has a reference to my list

00:19:40,750 --> 00:19:48,070
decrement by one now the reference is 0

00:19:43,779 --> 00:19:50,260
okay the next step we have my list as

00:19:48,070 --> 00:19:53,020
their nests object in

00:19:50,260 --> 00:19:57,280
generation 0 and again we decrement by

00:19:53,020 --> 00:20:00,760
one so now we know that those of them

00:19:57,280 --> 00:20:08,020
could be unreachable outside of my of my

00:20:00,760 --> 00:20:10,900
generation okay the next step is moving

00:20:08,020 --> 00:20:14,950
the subject to a new list call and

00:20:10,900 --> 00:20:19,600
receive all and one step that we have to

00:20:14,950 --> 00:20:21,430
take carries we need to check on object

00:20:19,600 --> 00:20:25,180
that are reachable all the references

00:20:21,430 --> 00:20:27,820
because there can be cases where some

00:20:25,180 --> 00:20:30,330
more depth get a value of zero but very

00:20:27,820 --> 00:20:33,670
some kind of topology like one cycle

00:20:30,330 --> 00:20:37,090
like the one that we were seeing before

00:20:33,670 --> 00:20:39,340
and two other references this end up

00:20:37,090 --> 00:20:42,240
having zero understood but they are

00:20:39,340 --> 00:20:46,480
still reachable by these two objects so

00:20:42,240 --> 00:20:51,340
we have to check for that also after

00:20:46,480 --> 00:20:53,500
that we move to an reachable list those

00:20:51,340 --> 00:20:55,900
of the data retrieval are moved to the

00:20:53,500 --> 00:21:01,630
next generation because they can live

00:20:55,900 --> 00:21:03,610
more but I prepare like a little demo in

00:21:01,630 --> 00:21:08,940
written in Python before I did this

00:21:03,610 --> 00:21:16,830
using ddv that was too much so let's

00:21:08,940 --> 00:21:20,490
let's take a look I have time anything

00:21:16,830 --> 00:21:23,740
can you see the code word no order yeah

00:21:20,490 --> 00:21:26,160
well I try to represent like more or

00:21:23,740 --> 00:21:29,980
less implementation on Python to make it

00:21:26,160 --> 00:21:32,710
easier to understand hey do you remember

00:21:29,980 --> 00:21:36,520
this power link list this is one of the

00:21:32,710 --> 00:21:40,300
represent the note on how the garbage

00:21:36,520 --> 00:21:43,900
collector take trax all the allocated

00:21:40,300 --> 00:21:45,820
objects okay these are some helper

00:21:43,900 --> 00:21:49,110
methods that implement the traversal

00:21:45,820 --> 00:21:53,860
methods you know how to iterate over the

00:21:49,110 --> 00:21:56,830
their references one least some examples

00:21:53,860 --> 00:21:59,830
we will run an example now okay and here

00:21:56,830 --> 00:22:03,789
we have the garbage collector object

00:21:59,830 --> 00:22:06,129
okay it has in this case two generations

00:22:03,789 --> 00:22:10,419
with two threshold that i didn't mention

00:22:06,129 --> 00:22:12,850
before but we don't do us psycho

00:22:10,419 --> 00:22:15,269
detective each time that we allocate an

00:22:12,850 --> 00:22:19,869
object there is some threshold that they

00:22:15,269 --> 00:22:23,049
they study them and if we allocate more

00:22:19,869 --> 00:22:29,979
other than than that vessel and cycle

00:22:23,049 --> 00:22:33,669
detection cyclase is fire okay here we

00:22:29,979 --> 00:22:37,950
have the biz logic let's say that I want

00:22:33,669 --> 00:22:40,869
to instantiate some class what i do is i

00:22:37,950 --> 00:22:44,799
append to my first generation this

00:22:40,869 --> 00:22:47,979
object with on this link list and i

00:22:44,799 --> 00:22:50,159
check this threshold okay it's my

00:22:47,979 --> 00:22:54,210
generation greater than the threshold

00:22:50,159 --> 00:23:00,399
yes i try i collect i do a collection

00:22:54,210 --> 00:23:03,849
how does how is this collect cycle okay

00:23:00,399 --> 00:23:06,549
we get some references for be more

00:23:03,849 --> 00:23:08,769
comfortable programming the first step

00:23:06,549 --> 00:23:13,149
is we need to update the references

00:23:08,769 --> 00:23:15,879
because on the node this node don't have

00:23:13,149 --> 00:23:18,309
the most updated reference count because

00:23:15,879 --> 00:23:20,769
as I told you before we don't run the

00:23:18,309 --> 00:23:24,999
cycle detection all the time so you can

00:23:20,769 --> 00:23:31,119
have a value that is all there okay so

00:23:24,999 --> 00:23:32,979
the first step is we iterate over all

00:23:31,119 --> 00:23:36,009
the generation that we are interested in

00:23:32,979 --> 00:23:41,019
and we update the reference count with

00:23:36,009 --> 00:23:43,889
the pile that one okay the next step is

00:23:41,019 --> 00:23:46,269
this one of breaking cycles just

00:23:43,889 --> 00:23:49,479
subtracting one on the internal

00:23:46,269 --> 00:23:56,679
references okay so let's take a look how

00:23:49,479 --> 00:23:58,859
this what we do is again we draped over

00:23:56,679 --> 00:24:02,619
the whole list of this generation and

00:23:58,859 --> 00:24:05,159
using this helper method that abstract

00:24:02,619 --> 00:24:08,499
how to iterate over all the references

00:24:05,159 --> 00:24:11,590
we pass a function as an argument okay

00:24:08,499 --> 00:24:14,349
and this function basically what this

00:24:11,590 --> 00:24:15,980
does is it checks that the reference are

00:24:14,349 --> 00:24:19,280
greater than zero and decrement

00:24:15,980 --> 00:24:23,679
i won this is a helper method don't

00:24:19,280 --> 00:24:27,169
worry about it so we end up with the

00:24:23,679 --> 00:24:43,580
after this step I will run one example

00:24:27,169 --> 00:24:53,559
oops you know how to evaluate all they

00:24:43,580 --> 00:25:03,500
felt only Python I'm pretty new to

00:24:53,559 --> 00:25:07,490
notebooks sorry ok we'll do like a step

00:25:03,500 --> 00:25:11,480
by step to see it clear ok we allocate

00:25:07,490 --> 00:25:14,450
one list we are trying to replicate our

00:25:11,480 --> 00:25:16,549
sample we have a list and an instance of

00:25:14,450 --> 00:25:31,160
an object and with we are creating a

00:25:16,549 --> 00:25:33,679
cycle ok we are locate we will explore

00:25:31,160 --> 00:25:40,910
lime manually I don't know what's

00:25:33,679 --> 00:25:43,850
happening demo ok after this step on our

00:25:40,910 --> 00:25:47,059
example we will get those two object

00:25:43,850 --> 00:25:50,570
with a count of 0 so the next step is

00:25:47,059 --> 00:25:52,870
just take those eight cases where we can

00:25:50,570 --> 00:25:55,370
get some object with a count of 0 but

00:25:52,870 --> 00:26:00,380
some other object can reference hit them

00:25:55,370 --> 00:26:04,010
so what we do is in first place we used

00:26:00,380 --> 00:26:08,480
again tippy traverse and we use another

00:26:04,010 --> 00:26:13,340
callback that basically what it does is

00:26:08,480 --> 00:26:16,490
if we find one object that has a count 0

00:26:13,340 --> 00:26:19,850
this is a false false positive as and

00:26:16,490 --> 00:26:23,960
reach also we need to keep track that is

00:26:19,850 --> 00:26:25,230
still reachable in other case with dust

00:26:23,960 --> 00:26:29,100
jacket at

00:26:25,230 --> 00:26:30,929
refs are greater than zero and after

00:26:29,100 --> 00:26:34,470
that we have lost to list the

00:26:30,929 --> 00:26:39,320
unreachable object and the young ones so

00:26:34,470 --> 00:26:43,710
we know that these ones can be believed

00:26:39,320 --> 00:26:45,990
but it's not so simple so we move the

00:26:43,710 --> 00:26:50,340
retrieval of death in this generation to

00:26:45,990 --> 00:26:53,040
the older one and I'll explain later on

00:26:50,340 --> 00:26:56,280
what we need to do with weak references

00:26:53,040 --> 00:27:00,059
and finally steps and we finally delete

00:26:56,280 --> 00:27:01,950
all the other garbage this is there are

00:27:00,059 --> 00:27:05,010
some edge cases that i'll try to Selena

00:27:01,950 --> 00:27:07,290
but did you understand more or less the

00:27:05,010 --> 00:27:11,870
algorithm should I explain something

00:27:07,290 --> 00:27:11,870
more or is clear okay

00:27:18,610 --> 00:27:25,010
but I told you before there are some

00:27:21,560 --> 00:27:27,740
problems with this approach we need to

00:27:25,010 --> 00:27:30,080
take care of and finalize it I mean

00:27:27,740 --> 00:27:32,480
underscore underscore bill there are two

00:27:30,080 --> 00:27:35,420
kinds of finalizes ones are kind of

00:27:32,480 --> 00:27:39,440
legacy and those cannot be delegated

00:27:35,420 --> 00:27:45,560
safely so we end up having memory leaks

00:27:39,440 --> 00:27:48,290
if we have legacy analysis we deal with

00:27:45,560 --> 00:27:51,440
understand score deal it also has to

00:27:48,290 --> 00:27:55,580
take care alot of eight cases so please

00:27:51,440 --> 00:27:57,440
don't use may finally surfs and finally

00:27:55,580 --> 00:28:00,770
we have to take care also about where

00:27:57,440 --> 00:28:02,360
with references what it does is check

00:28:00,770 --> 00:28:04,250
one the ones that are reachable and

00:28:02,360 --> 00:28:08,810
execute the callback that they have

00:28:04,250 --> 00:28:11,030
associated so what makes them OD happy

00:28:08,810 --> 00:28:13,220
that is incremental these are gonna

00:28:11,030 --> 00:28:14,900
finish incremental also as it works it

00:28:13,220 --> 00:28:19,910
frees memory we don't need to wait to

00:28:14,900 --> 00:28:22,010
cycle to recover memory and a modest

00:28:19,910 --> 00:28:24,370
worried because as you can see detect

00:28:22,010 --> 00:28:26,450
the 13 cycles is kind of hard not

00:28:24,370 --> 00:28:28,520
algorithm itself but there is a lot of

00:28:26,450 --> 00:28:31,490
eight cases that I didn't mention that

00:28:28,520 --> 00:28:34,970
is kind of complex and even we also have

00:28:31,490 --> 00:28:38,930
some size overhead on own objects that

00:28:34,970 --> 00:28:41,210
this movie ref count and as a personal

00:28:38,930 --> 00:28:44,150
opinion also in C Python garbage

00:28:41,210 --> 00:28:47,900
collection is 22 couple couple to the

00:28:44,150 --> 00:28:50,390
model so that we have a countering in

00:28:47,900 --> 00:28:55,070
the main object of the interpreter so is

00:28:50,390 --> 00:29:01,010
not so so we cannot change the model

00:28:55,070 --> 00:29:03,470
easily so that's as a side note and I

00:29:01,010 --> 00:29:07,070
have little time now like five minutes

00:29:03,470 --> 00:29:12,880
I'll try to do our view of how pipe I

00:29:07,070 --> 00:29:15,020
handle garbage collection and memory so

00:29:12,880 --> 00:29:17,780
probably most of you are familiar with

00:29:15,020 --> 00:29:22,060
pipe is an alternative implementation of

00:29:17,780 --> 00:29:24,790
python is written in our Python and

00:29:22,060 --> 00:29:27,010
regarding to veritable axiom for

00:29:24,790 --> 00:29:30,910
it has some point that are quite

00:29:27,010 --> 00:29:33,580
interesting and one is that it's kind of

00:29:30,910 --> 00:29:37,540
agnostic to the garbage collection

00:29:33,580 --> 00:29:42,370
algorithm so during translation time

00:29:37,540 --> 00:29:46,000
that is how do you get the interpreter

00:29:42,370 --> 00:29:48,730
at the end and you can if i'm not wrong

00:29:46,000 --> 00:29:50,530
you can change the model of garbage

00:29:48,730 --> 00:29:53,980
collection algorithm that you want to

00:29:50,530 --> 00:29:56,680
use so this allow pi PI developers to

00:29:53,980 --> 00:29:58,870
experiment over time with different

00:29:56,680 --> 00:30:01,810
approaches that I think is is a good

00:29:58,870 --> 00:30:05,320
good thing not to be tight 11

00:30:01,810 --> 00:30:07,560
implementation and the algorithm by

00:30:05,320 --> 00:30:11,890
default nowadays is in mini mac and

00:30:07,560 --> 00:30:16,180
let's let's explore a little bit of pi

00:30:11,890 --> 00:30:19,600
PI one of the things that pi PI

00:30:16,180 --> 00:30:22,360
developers notice is that we allocate

00:30:19,600 --> 00:30:26,440
lot well we interpreted allocates a lot

00:30:22,360 --> 00:30:29,170
of objects during with a short lifetime

00:30:26,440 --> 00:30:31,810
so for example we have some so much

00:30:29,170 --> 00:30:35,650
samples here like for comprehension we

00:30:31,810 --> 00:30:40,380
are in allocating objects that will live

00:30:35,650 --> 00:30:42,910
very very slowly even when we are

00:30:40,380 --> 00:30:46,650
calling a method on a class we are

00:30:42,910 --> 00:30:50,260
creating a new object abounded method

00:30:46,650 --> 00:30:52,960
with a very very short life so those

00:30:50,260 --> 00:30:56,590
objects will be delegated in a

00:30:52,960 --> 00:30:59,350
performant way okay so they end up with

00:30:56,590 --> 00:31:02,470
this kind of memory model they divided

00:30:59,350 --> 00:31:05,130
into two areas one for the journal

00:31:02,470 --> 00:31:08,230
optics this one that leaves early and

00:31:05,130 --> 00:31:11,190
done the joinery is divided into two

00:31:08,230 --> 00:31:13,780
areas the nursery that a suffix is

00:31:11,190 --> 00:31:17,680
another area where all the others that

00:31:13,780 --> 00:31:22,120
don't fit in in the romanov area go

00:31:17,680 --> 00:31:24,790
there and also some arenas to to hold

00:31:22,120 --> 00:31:29,470
the objects that are older than and they

00:31:24,790 --> 00:31:37,390
don't want so

00:31:29,470 --> 00:31:39,220
so how does it work it performs what

00:31:37,390 --> 00:31:41,890
they call minor and major collection

00:31:39,220 --> 00:31:45,880
minor collection is fear farm on on the

00:31:41,890 --> 00:31:48,820
zone area so I is fast because we don't

00:31:45,880 --> 00:31:53,200
need to revert to the old life objects

00:31:48,820 --> 00:31:57,250
and objects are moved only once to to

00:31:53,200 --> 00:31:59,650
the old area and also major collection

00:31:57,250 --> 00:32:02,169
is done incrementally at the end they

00:31:59,650 --> 00:32:05,740
implement kind of American trip

00:32:02,169 --> 00:32:08,350
everything that well this is are the

00:32:05,740 --> 00:32:12,520
faces that they implemented in first

00:32:08,350 --> 00:32:15,490
place they do I scam face then mark they

00:32:12,520 --> 00:32:18,159
sweep finally the executive analysis

00:32:15,490 --> 00:32:23,380
because we have the same problems have

00:32:18,159 --> 00:32:28,330
seen C Python here we have some so much

00:32:23,380 --> 00:32:32,440
kima how my country works in general

00:32:28,330 --> 00:32:35,770
this is a very very is the same the same

00:32:32,440 --> 00:32:37,870
extremist in the paper of McCarthy

00:32:35,770 --> 00:32:40,030
basically what we do we know for sure

00:32:37,870 --> 00:32:42,450
the root of the main objects and we

00:32:40,030 --> 00:32:45,549
traverse the graph of the of memory and

00:32:42,450 --> 00:32:48,100
we mark on this reversal which ones are

00:32:45,549 --> 00:32:49,710
writable once we know which ones are

00:32:48,100 --> 00:32:52,929
writable with the right over the whole

00:32:49,710 --> 00:32:57,700
the whole list and we strip we delegate

00:32:52,929 --> 00:33:02,409
the ones that were not mark yeah that's

00:32:57,700 --> 00:33:04,929
it quite quite simple in million mark

00:33:02,409 --> 00:33:08,380
and sweep can collect cycles because we

00:33:04,929 --> 00:33:11,169
basically are doing a graph traversal

00:33:08,380 --> 00:33:13,030
but type implementation can be more

00:33:11,169 --> 00:33:18,100
complex to understand and C Python

00:33:13,030 --> 00:33:21,280
because this for me and one full

00:33:18,100 --> 00:33:24,309
collection west of the world I mean that

00:33:21,280 --> 00:33:27,130
we cannot assess well as him when we are

00:33:24,309 --> 00:33:31,390
detecting cycles and C Python we cannot

00:33:27,130 --> 00:33:33,900
perform other operations so yeah

00:33:31,390 --> 00:33:33,900
questions

00:33:43,539 --> 00:33:54,609
start up front if there are any the

00:33:47,379 --> 00:33:57,340
review of the back I thanks for the

00:33:54,609 --> 00:33:58,989
explanation of these algorithms what I

00:33:57,340 --> 00:34:00,789
would be interested in as a Python

00:33:58,989 --> 00:34:03,639
developers to anything I should take

00:34:00,789 --> 00:34:05,109
care about in my coat so that I enable

00:34:03,639 --> 00:34:07,509
the garbage collector to do this work

00:34:05,109 --> 00:34:10,540
most efficiently I try to avoid the

00:34:07,509 --> 00:34:12,909
underscore underscore bill methods for

00:34:10,540 --> 00:34:15,369
example because there are a lot of eight

00:34:12,909 --> 00:34:22,929
cases that interpreter has to take care

00:34:15,369 --> 00:34:25,990
of so that's one off with papaya say

00:34:22,929 --> 00:34:30,299
there is a possibility of the stop the

00:34:25,990 --> 00:34:35,260
world issue on garbage collection it is

00:34:30,299 --> 00:34:41,200
there a way to any future implementation

00:34:35,260 --> 00:34:44,919
or theoretically to circumvent the

00:34:41,200 --> 00:34:47,309
circumstance for example splitting

00:34:44,919 --> 00:34:52,750
memory anger but collecting different

00:34:47,309 --> 00:34:56,679
yes they do that upload so they stops as

00:34:52,750 --> 00:34:59,410
far as i know they're not so long so but

00:34:56,679 --> 00:35:02,200
it could be interesting having like in

00:34:59,410 --> 00:35:04,450
the jkb n where you have parallel

00:35:02,200 --> 00:35:12,819
strategies and so on it will be

00:35:04,450 --> 00:35:16,119
interesting what about threads all they

00:35:12,819 --> 00:35:18,130
do do kind of have parallel code running

00:35:16,119 --> 00:35:22,690
because they'll all interpreter lock as

00:35:18,130 --> 00:35:24,849
far as i know but i don't get your

00:35:22,690 --> 00:35:27,160
question can you elaborate more or if i

00:35:24,849 --> 00:35:29,799
run more than one thread and where the

00:35:27,160 --> 00:35:34,079
locates and then it has to be garbage

00:35:29,799 --> 00:35:37,420
collected is the garbage collectors

00:35:34,079 --> 00:35:39,069
specific both red or is it Global 12 is

00:35:37,420 --> 00:35:42,210
global as far as I know MC Python

00:35:39,069 --> 00:35:42,210
bye-bye I'm not sure

00:35:50,960 --> 00:35:56,330
can you force the garbage collector to

00:35:53,540 --> 00:35:59,390
run or simply sit free also to ignore it

00:35:56,330 --> 00:36:02,240
if you can if you call it can you repeat

00:35:59,390 --> 00:36:04,430
the question I hear you well can you

00:36:02,240 --> 00:36:08,300
force the garbage collector to run and

00:36:04,430 --> 00:36:12,460
if it does is it the free to ignore it

00:36:08,300 --> 00:36:15,400
that you can force a cycle on GC module

00:36:12,460 --> 00:36:19,970
and listen to Python you can import DC

00:36:15,400 --> 00:36:25,210
and you can force a collection cycle

00:36:19,970 --> 00:36:28,850
detection because on reference counting

00:36:25,210 --> 00:36:30,770
resources are free when when they are

00:36:28,850 --> 00:36:35,480
not use any more to come force a cycle

00:36:30,770 --> 00:36:43,160
detection but you have an API to manage

00:36:35,480 --> 00:36:46,580
right collector good an object be

00:36:43,160 --> 00:36:48,620
redirected by its finalizar over here

00:36:46,580 --> 00:36:52,610
you can you're available can an object

00:36:48,620 --> 00:36:57,080
be resurrected by its finalizar yeah

00:36:52,610 --> 00:37:01,190
yeah those that's one of educator that

00:36:57,080 --> 00:37:04,480
you have to handle yeah that's why is

00:37:01,190 --> 00:37:04,480
not good practice to

00:37:11,579 --> 00:37:17,549
is the garbage collector the one that

00:37:14,569 --> 00:37:20,549
collects cycles clattering and in

00:37:17,549 --> 00:37:23,479
statistics can I inspect and see some

00:37:20,549 --> 00:37:28,499
statistics and you have through this API

00:37:23,479 --> 00:37:32,190
from DC modules you can do contact as

00:37:28,499 --> 00:37:36,049
far as I can remember number of ritual

00:37:32,190 --> 00:37:36,049
objects let me check

00:37:50,390 --> 00:38:05,189
well do you have over here documented

00:37:58,559 --> 00:38:07,469
somewhere but ate it check for aesthetic

00:38:05,189 --> 00:38:10,849
risk all the time so important disease

00:38:07,469 --> 00:38:14,749
you can you can access to some of them

00:38:10,849 --> 00:38:14,749
yeah definitely

00:38:24,410 --> 00:38:32,760
does it run with a certain frequency or

00:38:28,220 --> 00:38:35,700
how often or unsee Python depends on

00:38:32,760 --> 00:38:37,920
this threshold so it's time that an

00:38:35,700 --> 00:38:41,720
object is allocated is appended to the

00:38:37,920 --> 00:38:45,090
younger generation list and once we

00:38:41,720 --> 00:38:51,330
reach this threshold cycle detection

00:38:45,090 --> 00:38:59,280
cycle our case is done last question

00:38:51,330 --> 00:39:03,300
we'll have time for more so do you know

00:38:59,280 --> 00:39:05,550
about some user-friendly tools to detect

00:39:03,300 --> 00:39:11,280
memory leaks before you deploy your

00:39:05,550 --> 00:39:15,270
application I think there are some but I

00:39:11,280 --> 00:39:19,170
don't know on the worst case you can use

00:39:15,270 --> 00:39:22,700
magnum but not so it's definitely and

00:39:19,170 --> 00:39:24,930
you have to know the internment but

00:39:22,700 --> 00:39:30,600
probably there are some that I'm not

00:39:24,930 --> 00:39:33,710
aware of sorry great presentation thank

00:39:30,600 --> 00:39:33,710

YouTube URL: https://www.youtube.com/watch?v=sSMPiQZTyrI


