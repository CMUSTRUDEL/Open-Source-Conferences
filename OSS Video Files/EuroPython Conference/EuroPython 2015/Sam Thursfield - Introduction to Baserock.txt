Title: Sam Thursfield - Introduction to Baserock
Publication date: 2015-08-08
Playlist: EuroPython 2015
Description: 
	Sam Thursfield - Introduction to Baserock
[EuroPython 2015]
[21 July 2015]
[Bilbao, Euskadi, Spain]

The Baserock project is about creating system images from source code
in a clean, reproducible way. All of the tooling is written in Python.

In this talk I'll explain a bit about the core idea of Baserock:
declarative system definitions (expressed in YAML) that can be built
and deployed in various ways.

Then I'll go into more detail about the tools available, and some of
the cool things that they can do: distributed building, atomic system
updates, creating custom container images, and more.

Find out more about the Baserock project at http://www.baserock.org/
Captions: 
	00:00:00,000 --> 00:00:06,930
oh please join me in welcoming Sam thank

00:00:04,319 --> 00:00:10,650
you everyone everyone hear me is that

00:00:06,930 --> 00:00:12,509
too loud too quiet that's okay brilliant

00:00:10,650 --> 00:00:14,460
well thanks for coming to this talk I'm

00:00:12,509 --> 00:00:17,699
going to be talking about integrating

00:00:14,460 --> 00:00:19,260
software into collections of software

00:00:17,699 --> 00:00:20,760
that work together where it sounds easy

00:00:19,260 --> 00:00:23,310
sounds like a solved problem but

00:00:20,760 --> 00:00:25,529
actually isn't how many people how many

00:00:23,310 --> 00:00:28,380
people do that here work in

00:00:25,529 --> 00:00:30,750
distributions or creating software for

00:00:28,380 --> 00:00:35,190
embedded systems how many people here a

00:00:30,750 --> 00:00:40,649
few so do you find it easy is that other

00:00:35,190 --> 00:00:42,750
pain points so the bass rock project is

00:00:40,649 --> 00:00:46,140
developing tools to try and make this

00:00:42,750 --> 00:00:48,539
process easier the goal isn't to replace

00:00:46,140 --> 00:00:50,760
traditional distributions the goal is to

00:00:48,539 --> 00:00:53,579
develop it's kind of a research project

00:00:50,760 --> 00:00:56,899
to develop a set of parts which work

00:00:53,579 --> 00:00:59,550
together but also work independently and

00:00:56,899 --> 00:01:02,460
so people can adopt any of the parts

00:00:59,550 --> 00:01:04,860
that they see beautiful for them all the

00:01:02,460 --> 00:01:06,750
tooling is written in Python it's all

00:01:04,860 --> 00:01:08,310
free of legacy well the project started

00:01:06,750 --> 00:01:10,409
about four years ago so it's not

00:01:08,310 --> 00:01:13,560
completely free of legacy for more free

00:01:10,409 --> 00:01:18,810
of legacy than most existing things in

00:01:13,560 --> 00:01:22,259
this area so the project started with

00:01:18,810 --> 00:01:24,720
this problem build a working Linux

00:01:22,259 --> 00:01:28,470
operating system straight from the

00:01:24,720 --> 00:01:29,970
source code and how many if I ask how

00:01:28,470 --> 00:01:31,650
many lines of Python code do you think

00:01:29,970 --> 00:01:36,420
it would take you to do that any guesses

00:01:31,650 --> 00:01:39,030
no guesses well I'll give a couple of

00:01:36,420 --> 00:01:40,770
hints so the project of dealing with

00:01:39,030 --> 00:01:43,159
source code we have a solution for that

00:01:40,770 --> 00:01:45,630
which is a server which mirrors every

00:01:43,159 --> 00:01:47,340
form of version control every popular

00:01:45,630 --> 00:01:49,590
form of version control and mirrors

00:01:47,340 --> 00:01:53,399
tarballs all in to get repositories on

00:01:49,590 --> 00:01:55,439
one server so the build tool doesn't

00:01:53,399 --> 00:01:57,390
have to deal with downloading tar balls

00:01:55,439 --> 00:01:58,770
from random places or anything else it

00:01:57,390 --> 00:02:01,409
can consider that everything can get

00:01:58,770 --> 00:02:03,390
most things are in get now but it

00:02:01,409 --> 00:02:04,530
imports things from mercurial subversion

00:02:03,390 --> 00:02:09,060
and whatever else so you get a

00:02:04,530 --> 00:02:10,649
consistent interface and then also all

00:02:09,060 --> 00:02:12,800
the build instructions that you need to

00:02:10,649 --> 00:02:16,130
spelled out in this can

00:02:12,800 --> 00:02:18,560
yamel format so this is an example of a

00:02:16,130 --> 00:02:20,720
simple build instruction for binutils

00:02:18,560 --> 00:02:23,810
this is the instruction we have for

00:02:20,720 --> 00:02:26,690
Python while the C Python interpreter so

00:02:23,810 --> 00:02:29,300
it says use the standard commands for

00:02:26,690 --> 00:02:31,640
auto tools but override the configure

00:02:29,300 --> 00:02:33,800
commands run something when it finishes

00:02:31,640 --> 00:02:36,620
to create a symlink so we have a

00:02:33,800 --> 00:02:38,630
reference distribution which describes

00:02:36,620 --> 00:02:40,910
how to build the whole system in form

00:02:38,630 --> 00:02:43,280
like this there's another slightly more

00:02:40,910 --> 00:02:45,170
complicated yamel document which then

00:02:43,280 --> 00:02:48,920
says what ref to build and how to fit it

00:02:45,170 --> 00:02:50,330
all together but that's it and so with

00:02:48,920 --> 00:02:52,130
these parts we actually have a build

00:02:50,330 --> 00:02:54,800
tool which produces a work in operating

00:02:52,130 --> 00:02:57,290
system with about two thousand lines of

00:02:54,800 --> 00:02:59,900
Python which is an order of magnitude

00:02:57,290 --> 00:03:02,630
simpler than anything else you'll find

00:02:59,900 --> 00:03:04,760
in this area I think and that's because

00:03:02,630 --> 00:03:06,920
we've taken the approach that writing a

00:03:04,760 --> 00:03:09,560
build system should be easy enough that

00:03:06,920 --> 00:03:12,260
this squirrel monkey could do it if we

00:03:09,560 --> 00:03:13,940
solve the problems around all the

00:03:12,260 --> 00:03:15,920
problems in the area then the bill tool

00:03:13,940 --> 00:03:17,360
itself becomes trivial which is good

00:03:15,920 --> 00:03:19,459
because writing a build tool is quite a

00:03:17,360 --> 00:03:22,880
thankless task nobody really enjoys

00:03:19,459 --> 00:03:24,170
doing it so if we remove all of the the

00:03:22,880 --> 00:03:26,720
problems around it and it becomes

00:03:24,170 --> 00:03:29,480
trivial at least but not trivial but

00:03:26,720 --> 00:03:32,870
fairly easy lines of code is a bit of a

00:03:29,480 --> 00:03:35,810
horrible metric and i don't mean assign

00:03:32,870 --> 00:03:37,190
too much meaning to it but the tool in

00:03:35,810 --> 00:03:39,140
question is kind of a prototype is

00:03:37,190 --> 00:03:40,700
called ybd and we have an older build

00:03:39,140 --> 00:03:43,910
tool as well come off which is a lot

00:03:40,700 --> 00:03:45,860
bigger I'll go through the bits of Base

00:03:43,910 --> 00:03:50,989
Rock so what do you need to actually

00:03:45,860 --> 00:03:53,840
build such a system these are the the

00:03:50,989 --> 00:03:55,700
items that you need really I'll go

00:03:53,840 --> 00:04:01,370
through each of those in a bit more

00:03:55,700 --> 00:04:04,160
detail so and the source code mirroring

00:04:01,370 --> 00:04:07,010
service that's a server appliance called

00:04:04,160 --> 00:04:08,690
trove we have one running which I should

00:04:07,010 --> 00:04:11,000
be able to show you in a browser so

00:04:08,690 --> 00:04:13,310
here's when we have live at get base rug

00:04:11,000 --> 00:04:15,440
and it contains lots and lots of git

00:04:13,310 --> 00:04:17,930
repositories quite boring but it's good

00:04:15,440 --> 00:04:20,060
to have a consistent interface and

00:04:17,930 --> 00:04:23,030
there's an easy way you submit a patch

00:04:20,060 --> 00:04:26,150
against a repo calories and it mirrors

00:04:23,030 --> 00:04:30,710
more things you can also set up your own

00:04:26,150 --> 00:04:32,060
instance of this or the actual mirroring

00:04:30,710 --> 00:04:35,479
tool at the heart of this is a simple

00:04:32,060 --> 00:04:37,130
script called Laurie which takes a JSON

00:04:35,479 --> 00:04:40,789
file which describes where to get source

00:04:37,130 --> 00:04:43,850
code from and pushes it into gate so

00:04:40,789 --> 00:04:45,259
that source code mirroring you then need

00:04:43,850 --> 00:04:47,240
a way of describing build instructions

00:04:45,259 --> 00:04:49,039
I'm gonna go into that in more detail

00:04:47,240 --> 00:04:50,960
later on because I think it's one of the

00:04:49,039 --> 00:04:53,479
most interesting parts of the project so

00:04:50,960 --> 00:04:57,169
I'm not going to touch on that now you

00:04:53,479 --> 00:04:58,580
then need a build tool to actually hang

00:04:57,169 --> 00:05:00,350
on I've done this in the wrong order so

00:04:58,580 --> 00:05:03,229
you need a language for creating build

00:05:00,350 --> 00:05:05,990
instructions and then you need some

00:05:03,229 --> 00:05:08,900
actual build instructions so separated

00:05:05,990 --> 00:05:12,590
we've defined the syntax for describing

00:05:08,900 --> 00:05:14,810
how to build stuff and then in order for

00:05:12,590 --> 00:05:16,580
the tool to be useful we have a set of

00:05:14,810 --> 00:05:19,370
definitions that you can use to build a

00:05:16,580 --> 00:05:22,820
system as well but you don't have to use

00:05:19,370 --> 00:05:24,800
those definitions so this is it's quite

00:05:22,820 --> 00:05:27,080
hard to visualize build systems and

00:05:24,800 --> 00:05:28,849
build tools so I apologize for the fact

00:05:27,080 --> 00:05:33,220
that a lot of my slides of screenshots

00:05:28,849 --> 00:05:36,139
of a terminal i also have a few diagrams

00:05:33,220 --> 00:05:37,940
but this is the list of package

00:05:36,139 --> 00:05:40,669
groupings we call them strata they're

00:05:37,940 --> 00:05:43,310
like layers in bitbake and you can see

00:05:40,669 --> 00:05:46,430
if the text is big enough the sun fairly

00:05:43,310 --> 00:05:49,250
standard packages gtk cute various

00:05:46,430 --> 00:05:52,490
Python libraries open stack is in there

00:05:49,250 --> 00:05:55,190
you can actually use Base Rock tools to

00:05:52,490 --> 00:05:58,580
deploy an OpenStack dunno instance which

00:05:55,190 --> 00:06:00,169
is quite impressive i think and going

00:05:58,580 --> 00:06:02,750
back to building a working gnu/linux

00:06:00,169 --> 00:06:04,490
system we release every so often we have

00:06:02,750 --> 00:06:06,620
we release one of the reference systems

00:06:04,490 --> 00:06:09,260
got the build reference system which you

00:06:06,620 --> 00:06:12,169
can download from here else just to show

00:06:09,260 --> 00:06:15,289
that it does in fact work this is me

00:06:12,169 --> 00:06:18,919
loading the VM image in q mu so this is

00:06:15,289 --> 00:06:22,400
a bass rock reference system and it

00:06:18,919 --> 00:06:24,380
boots to a bash prompt and there we are

00:06:22,400 --> 00:06:28,010
it's a Linux system built entirely from

00:06:24,380 --> 00:06:30,740
source code one cool thing about stuff

00:06:28,010 --> 00:06:33,919
that's book with bass rock is every

00:06:30,740 --> 00:06:36,050
image contains metadata that shows you

00:06:33,919 --> 00:06:38,360
exactly what repo and what ref

00:06:36,050 --> 00:06:39,920
everything was built from so this is /

00:06:38,360 --> 00:06:42,000
bass rock directory

00:06:39,920 --> 00:06:43,470
is that big enough by the way because

00:06:42,000 --> 00:06:45,960
it's qmu I can't really make it any

00:06:43,470 --> 00:06:48,290
bigger without using a serial console so

00:06:45,960 --> 00:06:51,090
I apologize if you can't read it but

00:06:48,290 --> 00:06:52,770
there's a bunch of metadata files one

00:06:51,090 --> 00:06:55,980
for each component in the system and

00:06:52,770 --> 00:06:59,040
then fire up on one of them briefly it

00:06:55,980 --> 00:07:01,440
contains metadata about this is the Z

00:06:59,040 --> 00:07:02,990
glib component and it was built from it

00:07:01,440 --> 00:07:06,780
was built with these build instructions

00:07:02,990 --> 00:07:09,120
this was the environment these were the

00:07:06,780 --> 00:07:12,150
versions of the dependencies and at the

00:07:09,120 --> 00:07:15,210
bottom it shows you the URL of the repo

00:07:12,150 --> 00:07:18,330
it was built from and exactly what char

00:07:15,210 --> 00:07:21,090
one it was built from so if you've got

00:07:18,330 --> 00:07:23,490
the source code mirrored in the server i

00:07:21,090 --> 00:07:25,500
showed you then you can go from any

00:07:23,490 --> 00:07:28,380
system that's been built and you can

00:07:25,500 --> 00:07:30,660
look at exactly what commit of what git

00:07:28,380 --> 00:07:33,960
repository everything was built from so

00:07:30,660 --> 00:07:35,280
there's no other system broke and I

00:07:33,960 --> 00:07:38,180
can't actually work out what I'm running

00:07:35,280 --> 00:07:38,180
that problem goes away

00:07:43,009 --> 00:07:49,759
so we have the build instructions there

00:07:46,039 --> 00:07:53,449
in a repository on get dr. org we call

00:07:49,759 --> 00:07:54,949
them definitions then we have a tool in

00:07:53,449 --> 00:07:57,979
fact two tools which you can use to

00:07:54,949 --> 00:08:00,110
build them so source code from get goes

00:07:57,979 --> 00:08:01,339
in the build tool just runs a sequence

00:08:00,110 --> 00:08:04,719
of shell commands in the right order

00:08:01,339 --> 00:08:07,639
which just like I say should be easy and

00:08:04,719 --> 00:08:09,979
produces a binary and then we have an

00:08:07,639 --> 00:08:13,939
artifact cut which just holds tarballs

00:08:09,979 --> 00:08:16,009
of binaries and so there's two tools

00:08:13,939 --> 00:08:17,779
morph is the older one which has a lot

00:08:16,009 --> 00:08:21,229
of features some of which it doesn't

00:08:17,779 --> 00:08:23,419
actually need it turns out and it has

00:08:21,229 --> 00:08:25,879
some quite cool things you can it has a

00:08:23,419 --> 00:08:28,520
distributed plug-in so you can set up

00:08:25,879 --> 00:08:31,219
multiple morph workers and have them

00:08:28,520 --> 00:08:32,899
share builds at the component level so

00:08:31,219 --> 00:08:34,969
if you've heard of this CC which

00:08:32,899 --> 00:08:37,130
distributes at the level of the source

00:08:34,969 --> 00:08:38,719
file morph can distribute at the level

00:08:37,130 --> 00:08:41,870
of the actual component so you could

00:08:38,719 --> 00:08:46,149
have different packages compiling on

00:08:41,870 --> 00:08:48,709
different systems why bday is more of a

00:08:46,149 --> 00:08:51,410
proof of concept that shows that you can

00:08:48,709 --> 00:08:53,000
make a radically simple built or they're

00:08:51,410 --> 00:08:56,810
both as well they're available on get da

00:08:53,000 --> 00:08:58,430
bass rock dog so after you built

00:08:56,810 --> 00:09:00,709
something it's not much use having a

00:08:58,430 --> 00:09:04,190
tarball really so you then need a tool

00:09:00,709 --> 00:09:06,230
to deploy it and deployment is a bit

00:09:04,190 --> 00:09:08,120
more messy than building I think

00:09:06,230 --> 00:09:09,649
building is quite a well-defined problem

00:09:08,120 --> 00:09:12,050
I say building I should be saying

00:09:09,649 --> 00:09:13,600
building and integration because there's

00:09:12,050 --> 00:09:18,470
more to it than just running compilers

00:09:13,600 --> 00:09:19,730
but the output is a binary once you try

00:09:18,470 --> 00:09:21,920
to run the binary you need to do some

00:09:19,730 --> 00:09:23,870
extra work to deploy it so for example

00:09:21,920 --> 00:09:26,089
if you want to deploy to OpenStack you

00:09:23,870 --> 00:09:29,060
need to create a disk image upload that

00:09:26,089 --> 00:09:31,579
as an image to OpenStack glance and then

00:09:29,060 --> 00:09:33,560
boot it if you want to deploy it to

00:09:31,579 --> 00:09:36,199
darker than you need to import it into

00:09:33,560 --> 00:09:38,750
docker as a tar file if you want to

00:09:36,199 --> 00:09:40,430
deploy it to real hardware then you may

00:09:38,750 --> 00:09:42,110
have to put it on an SD card wait five

00:09:40,430 --> 00:09:44,389
minutes take the SD card out put it in

00:09:42,110 --> 00:09:47,209
the machine so deployment is a bit more

00:09:44,389 --> 00:09:48,709
messy and there is tooling and bass rock

00:09:47,209 --> 00:09:50,660
to do that at the moment but actually

00:09:48,709 --> 00:09:53,740
I'd like to get rid of it completely I'm

00:09:50,660 --> 00:09:56,780
much how many people here know uncibal

00:09:53,740 --> 00:09:58,160
good that soup was great I'd much

00:09:56,780 --> 00:10:00,230
I'd really like to replace our

00:09:58,160 --> 00:10:02,990
deployment functionality with an ansible

00:10:00,230 --> 00:10:04,310
module so we don't have to think about

00:10:02,990 --> 00:10:06,830
that and bass track anymore because I

00:10:04,310 --> 00:10:11,390
think uncibal solves a lot of problems

00:10:06,830 --> 00:10:14,590
really neatly so you have deployment the

00:10:11,390 --> 00:10:17,450
last piece of the puzzle is caching

00:10:14,590 --> 00:10:20,390
because you need you don't want to build

00:10:17,450 --> 00:10:22,100
things more than once and because of the

00:10:20,390 --> 00:10:23,450
way bass rock trucks the inputs of

00:10:22,100 --> 00:10:26,090
everything it builds and it builds

00:10:23,450 --> 00:10:28,640
everything in an isolated staging area

00:10:26,090 --> 00:10:31,430
like an isolated to route you can be

00:10:28,640 --> 00:10:34,010
sure that what if you run the same build

00:10:31,430 --> 00:10:36,080
twice you get the same thing out not

00:10:34,010 --> 00:10:39,530
always the same bit although we are

00:10:36,080 --> 00:10:42,430
working on that but you get a lot of the

00:10:39,530 --> 00:10:45,710
artifact which works the same each time

00:10:42,430 --> 00:10:46,970
so you can cash basically by hashing all

00:10:45,710 --> 00:10:48,950
of the inputs and all of the

00:10:46,970 --> 00:10:51,050
dependencies coming up with an identity

00:10:48,950 --> 00:10:52,910
and then saying right this is what I

00:10:51,050 --> 00:10:55,160
built I'll refer to it with this hash

00:10:52,910 --> 00:10:56,660
and if something's already built it then

00:10:55,160 --> 00:10:58,580
it's already cached and you don't need

00:10:56,660 --> 00:11:00,500
to build it again so we have a simple

00:10:58,580 --> 00:11:05,030
cache server which you can use for

00:11:00,500 --> 00:11:08,660
storing artifacts now there are a couple

00:11:05,030 --> 00:11:10,640
of other bits the we have a continuous

00:11:08,660 --> 00:11:12,380
builder which is really just a shell

00:11:10,640 --> 00:11:14,030
script which runs from the morph built

00:11:12,380 --> 00:11:15,350
all over and over again so it's not that

00:11:14,030 --> 00:11:20,210
interesting I'm going to talk about that

00:11:15,350 --> 00:11:23,030
and we have I talked about sun boxing

00:11:20,210 --> 00:11:25,190
builds we recently spun out the code to

00:11:23,030 --> 00:11:28,610
do some boxing into a simple Python

00:11:25,190 --> 00:11:31,370
library called sandbox lib so it has one

00:11:28,610 --> 00:11:33,800
API basically it has one function call

00:11:31,370 --> 00:11:36,290
and a couple of others one main function

00:11:33,800 --> 00:11:39,140
call which runs a command like

00:11:36,290 --> 00:11:43,010
sub-process be open but you can specify

00:11:39,140 --> 00:11:45,770
a couple of things that you do or don't

00:11:43,010 --> 00:11:48,530
want to share or isolate so you can say

00:11:45,770 --> 00:11:50,030
put it in a new isolated mount space so

00:11:48,530 --> 00:11:52,730
it can't see the mounts from the system

00:11:50,030 --> 00:11:54,430
or put it in a new network name space so

00:11:52,730 --> 00:11:56,720
it can't connect to the internet and

00:11:54,430 --> 00:11:59,750
mount these extra directories from the

00:11:56,720 --> 00:12:01,070
host or make certain bits read-only it

00:11:59,750 --> 00:12:02,900
doesn't implement that functionality

00:12:01,070 --> 00:12:04,730
itself because there's lots of tools

00:12:02,900 --> 00:12:06,350
that already do it but they have

00:12:04,730 --> 00:12:08,060
different strengths and weaknesses for

00:12:06,350 --> 00:12:10,339
example a lot of the containerization

00:12:08,060 --> 00:12:12,589
tools like docker and

00:12:10,339 --> 00:12:15,740
system dns born and rocket need to be

00:12:12,589 --> 00:12:17,389
run as root where you can use a much

00:12:15,740 --> 00:12:21,620
simpler tool called linux user to root

00:12:17,389 --> 00:12:23,720
and run that as a user most of those are

00:12:21,620 --> 00:12:26,089
linux specific so it also has a chroot

00:12:23,720 --> 00:12:28,999
backend which will run on any POSIX OS

00:12:26,089 --> 00:12:30,860
but doesn't support most of the sandbox

00:12:28,999 --> 00:12:34,100
and capabilities because in a chroot you

00:12:30,860 --> 00:12:37,970
can't or using just POSIX api's you

00:12:34,100 --> 00:12:39,589
can't say and open a new mount namespace

00:12:37,970 --> 00:12:41,509
because they're a Linux specific feature

00:12:39,589 --> 00:12:45,050
so the chroot back end is fairly

00:12:41,509 --> 00:12:50,839
incapable but it allows you to degrade

00:12:45,050 --> 00:12:52,850
sandbox and capabilities if you want so

00:12:50,839 --> 00:12:54,980
there's the chart again filled in with

00:12:52,850 --> 00:12:57,550
the names of some components I'm just

00:12:54,980 --> 00:12:57,550
going to take a good

00:13:03,790 --> 00:13:07,910
so I said the most of the part that

00:13:06,140 --> 00:13:12,320
interests me the most about bass rock is

00:13:07,910 --> 00:13:14,210
the definitions language which refer to

00:13:12,320 --> 00:13:16,490
as declarative build instructions or

00:13:14,210 --> 00:13:20,150
declarative definitions and the idea is

00:13:16,490 --> 00:13:22,010
to turn build instructions into data at

00:13:20,150 --> 00:13:23,450
the moment that code there's a lot to

00:13:22,010 --> 00:13:26,210
build instructions in the world I mean

00:13:23,450 --> 00:13:29,150
Debian has build instructions for 10,000

00:13:26,210 --> 00:13:31,310
or 100,000 packages but it's all code

00:13:29,150 --> 00:13:35,810
it's really hard to reason about it

00:13:31,310 --> 00:13:37,460
unless you understand all seven build

00:13:35,810 --> 00:13:40,160
systems that double unis developed over

00:13:37,460 --> 00:13:41,960
the years whereas declarative build

00:13:40,160 --> 00:13:44,060
instructions we want to treat the build

00:13:41,960 --> 00:13:46,190
instructions are simple sequences of

00:13:44,060 --> 00:13:48,980
commands so they can be treated a lot

00:13:46,190 --> 00:13:52,430
more like data and there's we discourage

00:13:48,980 --> 00:13:54,170
kind of ad hoc implementing features in

00:13:52,430 --> 00:13:58,670
shell scripts in the build instructions

00:13:54,170 --> 00:14:00,800
and there's no logic for the bill tool

00:13:58,670 --> 00:14:03,110
mixed in so if you look at build route

00:14:00,800 --> 00:14:05,780
which is a tool written largely and make

00:14:03,110 --> 00:14:07,940
for building and systems from source

00:14:05,780 --> 00:14:09,470
code build routes great but nobody

00:14:07,940 --> 00:14:10,970
really understands how to have the core

00:14:09,470 --> 00:14:13,040
of it works anymore because all the

00:14:10,970 --> 00:14:14,900
instructions are in and make and tied up

00:14:13,040 --> 00:14:16,670
with the build definitions themselves

00:14:14,900 --> 00:14:18,080
and so while it works it's quite

00:14:16,670 --> 00:14:22,220
difficult to actually make changes to it

00:14:18,080 --> 00:14:23,480
anymore finally I really don't like

00:14:22,220 --> 00:14:24,920
shell scripts so I'd like to minimize

00:14:23,480 --> 00:14:27,050
the number of shell scripts in the world

00:14:24,920 --> 00:14:31,790
I'd much rather have everything as data

00:14:27,050 --> 00:14:35,930
on Python scripts so what we've done is

00:14:31,790 --> 00:14:37,250
defined this language yammer language

00:14:35,930 --> 00:14:38,600
was defined a few years ago and we're

00:14:37,250 --> 00:14:40,760
now trying to rationalize it and turn it

00:14:38,600 --> 00:14:45,770
into something formal and useful outside

00:14:40,760 --> 00:14:47,360
bass rock we have a i defined the schema

00:14:45,770 --> 00:14:49,460
of the current data model i tried to

00:14:47,360 --> 00:14:53,510
make a nice graph and instead i came up

00:14:49,460 --> 00:14:54,890
with this graph which shows you the

00:14:53,510 --> 00:14:57,230
entities we have at the minute so we

00:14:54,890 --> 00:14:59,330
have a command sequence that's the

00:14:57,230 --> 00:15:01,430
fundamental unit of building something

00:14:59,330 --> 00:15:04,240
you run a sequence of commands for

00:15:01,430 --> 00:15:06,560
example configure make make install and

00:15:04,240 --> 00:15:09,920
then there's something called a chunk

00:15:06,560 --> 00:15:11,690
which is kind of like a package we have

00:15:09,920 --> 00:15:15,320
these groupings called strata and

00:15:11,690 --> 00:15:16,010
systems which i think in for the future

00:15:15,320 --> 00:15:19,790
will do away with

00:15:16,010 --> 00:15:22,160
then just have one sort of component

00:15:19,790 --> 00:15:23,420
that contains other components really I

00:15:22,160 --> 00:15:26,050
think the main problem in doing that

00:15:23,420 --> 00:15:28,340
work is coming up with word which means

00:15:26,050 --> 00:15:30,110
component that contains other components

00:15:28,340 --> 00:15:32,930
without having it be really long or

00:15:30,110 --> 00:15:34,040
really weird as they say naming things

00:15:32,930 --> 00:15:36,230
is one of the hardest problems in

00:15:34,040 --> 00:15:37,610
computer science so at the moment we

00:15:36,230 --> 00:15:40,400
have this data model which is still

00:15:37,610 --> 00:15:42,590
fairly simple the final entity is the

00:15:40,400 --> 00:15:44,870
cluster which represents a cluster of

00:15:42,590 --> 00:15:46,160
systems so when you deploy something

00:15:44,870 --> 00:15:48,380
with bass rock tools you deploy a

00:15:46,160 --> 00:15:51,830
cluster even if there's only one system

00:15:48,380 --> 00:15:54,380
and so we have our reference systems

00:15:51,830 --> 00:15:57,220
repository contains a set of chunks for

00:15:54,380 --> 00:16:00,170
things like Python gtk cute and

00:15:57,220 --> 00:16:02,830
different Python libraries it contains

00:16:00,170 --> 00:16:05,390
strata which integrate those into

00:16:02,830 --> 00:16:08,570
logical groupings so for example is a

00:16:05,390 --> 00:16:11,420
cute 5 stratum which contains the

00:16:08,570 --> 00:16:14,360
various bits of cute that you need to

00:16:11,420 --> 00:16:16,880
use it then systems which have a

00:16:14,360 --> 00:16:20,450
specific purpose so for example the

00:16:16,880 --> 00:16:22,850
OpenStack server system contains a bunch

00:16:20,450 --> 00:16:25,190
of different things its purpose is to

00:16:22,850 --> 00:16:28,130
deploy an OpenStack system that you can

00:16:25,190 --> 00:16:30,130
then host other films in there's also a

00:16:28,130 --> 00:16:32,840
build system which has build tools in

00:16:30,130 --> 00:16:36,110
such things and it's easy to define your

00:16:32,840 --> 00:16:37,880
own ones I'll show you I meant to show

00:16:36,110 --> 00:16:40,730
this earlier actually I was going to

00:16:37,880 --> 00:16:43,160
show ybd starting to build something it

00:16:40,730 --> 00:16:46,750
won't finish because it will take hours

00:16:43,160 --> 00:16:50,270
and I would probably run out of time but

00:16:46,750 --> 00:16:53,480
this is the definitions are reference

00:16:50,270 --> 00:16:55,310
definitions repository in the system's

00:16:53,480 --> 00:17:05,000
directory so if I can make that a bit

00:16:55,310 --> 00:17:07,040
bigger we define the build system and it

00:17:05,000 --> 00:17:10,370
contains a simple list of the strata

00:17:07,040 --> 00:17:12,800
that you want so for example core Python

00:17:10,370 --> 00:17:16,070
libraries and the SP which contains

00:17:12,800 --> 00:17:19,670
Linux and a bootloader different Python

00:17:16,070 --> 00:17:22,490
libraries uncibal cloud in it and such

00:17:19,670 --> 00:17:24,800
things and then I fight owl oops I don't

00:17:22,490 --> 00:17:29,120
want to do that if I tell ybd to build

00:17:24,800 --> 00:17:29,809
that it all I'm not entirely sure how

00:17:29,120 --> 00:17:30,769
far

00:17:29,809 --> 00:17:32,299
not sure if I'm connected to the

00:17:30,769 --> 00:17:38,749
internet or not it won't get too far

00:17:32,299 --> 00:17:43,629
anyway it's still loading things from

00:17:38,749 --> 00:17:43,629
disk in fact I'll come back to that

00:17:45,100 --> 00:17:50,240
another interesting thing we can do with

00:17:48,200 --> 00:17:53,029
once the definitions are considered data

00:17:50,240 --> 00:17:55,370
is there's a lot of existing data

00:17:53,029 --> 00:17:58,399
analysis tools which you can use to look

00:17:55,370 --> 00:17:59,929
at them so I made this this is why BD

00:17:58,399 --> 00:18:03,559
actually building something so it's

00:17:59,929 --> 00:18:07,240
calculated and identity for each

00:18:03,559 --> 00:18:07,240
component involved in the build and

00:18:07,539 --> 00:18:11,269
pretty soon it'll get to the point of

00:18:09,559 --> 00:18:18,769
running some running configure for

00:18:11,269 --> 00:18:20,059
binutils probably there we go so this is

00:18:18,769 --> 00:18:22,669
what a bass rock build tool actually

00:18:20,059 --> 00:18:24,440
looks like it's just running a command

00:18:22,669 --> 00:18:26,029
and this will take in about four hours

00:18:24,440 --> 00:18:31,009
you'll get a system out the other side

00:18:26,029 --> 00:18:33,590
which I won't show you the so going back

00:18:31,009 --> 00:18:36,470
to browsing the definitions I found an

00:18:33,590 --> 00:18:40,429
awesome Python library called RDF lib

00:18:36,470 --> 00:18:43,759
web so RDF lib lets you browse and lets

00:18:40,429 --> 00:18:47,539
you deal with linked data and in Python

00:18:43,759 --> 00:18:51,679
an RDF lib web lets you create a really

00:18:47,539 --> 00:18:53,419
simple browser to explore it so this is

00:18:51,679 --> 00:18:55,309
running on my local machine I

00:18:53,419 --> 00:18:57,980
implemented it in about four lines of

00:18:55,309 --> 00:19:01,429
Python using our dear Philip Webb and it

00:18:57,980 --> 00:19:03,529
shows you all so I can look through what

00:19:01,429 --> 00:19:06,139
a chunk is it has these different

00:19:03,529 --> 00:19:09,019
properties and then I can look through

00:19:06,139 --> 00:19:11,840
all the chunks that we have defined in

00:19:09,019 --> 00:19:15,499
the reference definitions is C Python

00:19:11,840 --> 00:19:18,980
and that defines some configure commands

00:19:15,499 --> 00:19:22,610
for example and then it shows me the

00:19:18,980 --> 00:19:25,519
linkage between them so that gets

00:19:22,610 --> 00:19:29,869
referred to in a few different strata

00:19:25,519 --> 00:19:31,580
for example so my point is that this is

00:19:29,869 --> 00:19:33,799
really easy to do once build

00:19:31,580 --> 00:19:37,159
instructions are represented as simple

00:19:33,799 --> 00:19:40,759
Amal files or stored in the database you

00:19:37,159 --> 00:19:42,769
can reuse analysis tools like this which

00:19:40,759 --> 00:19:43,530
has not developed at all for build tools

00:19:42,769 --> 00:19:44,910
but

00:19:43,530 --> 00:19:46,320
it's a general-purpose thing and we can

00:19:44,910 --> 00:19:48,330
now use it for analyzing build

00:19:46,320 --> 00:19:49,890
instructions and I'd like to generate

00:19:48,330 --> 00:19:51,150
some interest in graphs in future as

00:19:49,890 --> 00:19:53,580
well haven't been to a lot of data

00:19:51,150 --> 00:19:55,050
visualization talks yesterday I'm very

00:19:53,580 --> 00:20:04,950
interested in making pretty graphs and

00:19:55,050 --> 00:20:06,930
network diagrams now so the final part

00:20:04,950 --> 00:20:09,300
of the talk is how this can be useful

00:20:06,930 --> 00:20:12,900
for Python development and how many

00:20:09,300 --> 00:20:15,630
people use virtual and so virtual ends

00:20:12,900 --> 00:20:18,900
really useful quite a simple way of

00:20:15,630 --> 00:20:21,750
isolating a Python dependencies it has a

00:20:18,900 --> 00:20:23,520
few problems which is if you want to

00:20:21,750 --> 00:20:26,010
install the library that needs a system

00:20:23,520 --> 00:20:27,330
library and you don't have installed on

00:20:26,010 --> 00:20:29,670
your system there's nothing virtual end

00:20:27,330 --> 00:20:31,500
can do about that so you can use the

00:20:29,670 --> 00:20:35,400
bass rock tooling to build a container

00:20:31,500 --> 00:20:36,660
which tracks all of the dependencies

00:20:35,400 --> 00:20:39,660
that you need rather than just the

00:20:36,660 --> 00:20:40,770
Python ones I wouldn't recommend if you

00:20:39,660 --> 00:20:42,270
don't have a problem with virtual and

00:20:40,770 --> 00:20:44,100
keep using it because it's much more

00:20:42,270 --> 00:20:45,780
convenient but if you find yourself

00:20:44,100 --> 00:20:47,250
reaching the limits of what virtual n

00:20:45,780 --> 00:20:49,650
can do and finding the apps that you

00:20:47,250 --> 00:20:52,320
have to start installing packages and

00:20:49,650 --> 00:20:54,960
tracking dependencies elsewhere bass

00:20:52,320 --> 00:20:57,030
rock gives you a way of defining

00:20:54,960 --> 00:21:00,390
everything all the Python dependencies

00:20:57,030 --> 00:21:02,100
or the C library dependencies and right

00:21:00,390 --> 00:21:08,610
down to the toolchain you used to build

00:21:02,100 --> 00:21:10,740
it and creating definitions by hand is a

00:21:08,610 --> 00:21:12,570
bit boring so we have a tool called the

00:21:10,740 --> 00:21:17,070
import tool which can import metadata

00:21:12,570 --> 00:21:19,620
from other packaging systems and we

00:21:17,070 --> 00:21:22,530
developed a way of importing information

00:21:19,620 --> 00:21:24,210
from pi PI so quite a lot of work went

00:21:22,530 --> 00:21:27,810
into this quite a lot of research by one

00:21:24,210 --> 00:21:30,270
of my colleagues and we tried looking at

00:21:27,810 --> 00:21:32,820
the source repose of Python projects and

00:21:30,270 --> 00:21:36,120
using a patched version of PIP to

00:21:32,820 --> 00:21:37,980
analyze what dependencies it expressed

00:21:36,120 --> 00:21:39,960
but it's actually quite difficult to get

00:21:37,980 --> 00:21:42,840
information that way the problem is

00:21:39,960 --> 00:21:45,540
again because setup py is code people

00:21:42,840 --> 00:21:47,400
can really do anything there and so you

00:21:45,540 --> 00:21:49,710
find setup p why's that don't make sense

00:21:47,400 --> 00:21:51,810
to pick when you run it in the repo so

00:21:49,710 --> 00:21:54,540
what we've what we've ended up doing is

00:21:51,810 --> 00:21:56,940
we have a solution which sets up a

00:21:54,540 --> 00:21:57,149
virtual end of environment users pit to

00:21:56,940 --> 00:21:58,950
in

00:21:57,149 --> 00:22:00,619
all the package and then you should pick

00:21:58,950 --> 00:22:02,940
fries to get the list of dependencies

00:22:00,619 --> 00:22:04,679
it's not the most efficient solution

00:22:02,940 --> 00:22:06,599
because you have to compile any embedded

00:22:04,679 --> 00:22:11,159
c extensions or other things but it has

00:22:06,599 --> 00:22:19,169
the advantage that always works does

00:22:11,159 --> 00:22:21,389
anyone want to see this so hey yeah well

00:22:19,169 --> 00:22:24,330
the idea is to generate something which

00:22:21,389 --> 00:22:27,299
can be used in a tool that useful

00:22:24,330 --> 00:22:30,210
outside of Python libraries so I can

00:22:27,299 --> 00:22:31,859
show you if you name a package and I can

00:22:30,210 --> 00:22:34,919
show it working if I have an internet

00:22:31,859 --> 00:22:43,529
connection I can show you an interest in

00:22:34,919 --> 00:22:45,210
one Alex and well I found that some

00:22:43,529 --> 00:22:46,379
packages something that you expect to

00:22:45,210 --> 00:22:48,929
have a lot of dependencies don't

00:22:46,379 --> 00:22:51,960
actually list any for example Django and

00:22:48,929 --> 00:22:54,629
numpy don't list their dependencies in a

00:22:51,960 --> 00:22:56,929
machine-readable way they list them in

00:22:54,629 --> 00:22:56,929
the readme

00:23:01,610 --> 00:23:08,750
sadly no so I guess this is going to be

00:23:06,650 --> 00:23:14,780
quite a lot of compilation so I still

00:23:08,750 --> 00:23:16,160
there I shall leave that ok well the

00:23:14,780 --> 00:23:19,030
final bit I want to talk about is why

00:23:16,160 --> 00:23:21,230
we're doing this there's a few reasons

00:23:19,030 --> 00:23:23,179
one is that packing and operating

00:23:21,230 --> 00:23:26,840
systems is quite fun and hacking an

00:23:23,179 --> 00:23:28,840
operating system tooling one is that it

00:23:26,840 --> 00:23:31,700
there's a lot of best practices today

00:23:28,840 --> 00:23:34,520
which some people follow and some don't

00:23:31,700 --> 00:23:37,549
and we find ourselves a lot of the time

00:23:34,520 --> 00:23:39,890
cleaning up after in projects where the

00:23:37,549 --> 00:23:41,179
best practices haven't been followed so

00:23:39,890 --> 00:23:44,540
making tooling where you can't actually

00:23:41,179 --> 00:23:49,520
avoid following best practices it's a

00:23:44,540 --> 00:23:52,309
goal and some of these are not depending

00:23:49,520 --> 00:23:54,590
on third party hosting most build

00:23:52,309 --> 00:23:57,230
systems today download tar balls from

00:23:54,590 --> 00:23:58,880
upstream websites which is great until

00:23:57,230 --> 00:24:01,790
the website disappears or gets

00:23:58,880 --> 00:24:04,400
compromised recently 'get aureus dog

00:24:01,790 --> 00:24:06,020
went offline for example forever and all

00:24:04,400 --> 00:24:07,760
of the source code mera donga Tory has

00:24:06,020 --> 00:24:09,770
disappeared which would be really

00:24:07,760 --> 00:24:11,240
annoying except that we'd been mirroring

00:24:09,770 --> 00:24:13,460
all of the projects we needed for years

00:24:11,240 --> 00:24:15,890
anyway and so it didn't make much

00:24:13,460 --> 00:24:17,690
difference at some point we have to find

00:24:15,890 --> 00:24:19,820
the new up streams for the ones that

00:24:17,690 --> 00:24:22,429
have moved so they keep up to date but

00:24:19,820 --> 00:24:23,840
you can imagine if you if you have a

00:24:22,429 --> 00:24:25,850
build system which clones stuff from

00:24:23,840 --> 00:24:29,240
'get aureus and then the day before you

00:24:25,850 --> 00:24:30,440
release it disappears that's a real

00:24:29,240 --> 00:24:34,850
problem where if you have a source

00:24:30,440 --> 00:24:37,280
mirror you're insulated from that and so

00:24:34,850 --> 00:24:39,400
but making a source mirror is really

00:24:37,280 --> 00:24:41,840
easy using the trove server appliance

00:24:39,400 --> 00:24:43,730
trusting third-party binaries is another

00:24:41,840 --> 00:24:44,990
thing which seems to be coming really

00:24:43,730 --> 00:24:48,919
common at the moment with the rise of

00:24:44,990 --> 00:24:51,230
docker which is great right download a

00:24:48,919 --> 00:24:52,910
binary which you can't really inspect

00:24:51,230 --> 00:24:55,850
the source for run it as root on your

00:24:52,910 --> 00:24:59,480
computer in a in a bunch of namespaces

00:24:55,850 --> 00:25:01,760
no so but you build things from source

00:24:59,480 --> 00:25:03,049
instead you that's why we want to write

00:25:01,760 --> 00:25:05,870
tooling which builds everything from

00:25:03,049 --> 00:25:07,870
source so you don't have to trust random

00:25:05,870 --> 00:25:10,870
binary is downloaded from the internet

00:25:07,870 --> 00:25:10,870
and

00:25:11,399 --> 00:25:15,089
two other things keeping things up to

00:25:13,259 --> 00:25:18,599
date and making it as easy as possible

00:25:15,089 --> 00:25:21,719
to fix them up stream so because

00:25:18,599 --> 00:25:23,580
everything's in get you can clone any

00:25:21,719 --> 00:25:24,809
any component that you think is there is

00:25:23,580 --> 00:25:26,759
a problem in you can clone it straight

00:25:24,809 --> 00:25:28,499
away from a local server you don't have

00:25:26,759 --> 00:25:30,989
to worry about what format it's in or

00:25:28,499 --> 00:25:32,580
anything else and then once you've

00:25:30,989 --> 00:25:34,049
worked out what the problem is you can

00:25:32,580 --> 00:25:37,219
then a later date try and submit it to

00:25:34,049 --> 00:25:39,690
the project but it we discourage

00:25:37,219 --> 00:25:41,429
patching things in the build

00:25:39,690 --> 00:25:44,249
instructions a lot of distributions

00:25:41,429 --> 00:25:46,349
carry endless patches against projects

00:25:44,249 --> 00:25:47,519
which never seem to get up streams and

00:25:46,349 --> 00:25:49,440
some of them can't be some of them are

00:25:47,519 --> 00:25:51,210
legitimate things which are destroy

00:25:49,440 --> 00:25:53,489
specific but we really want to

00:25:51,210 --> 00:25:55,109
discourage patching things because it

00:25:53,489 --> 00:25:58,739
makes it more difficult then you come to

00:25:55,109 --> 00:26:00,479
upgrade from Python 3.42 both and 3.5

00:25:58,739 --> 00:26:02,849
and it turns out half your patches no

00:26:00,479 --> 00:26:05,820
longer apply and so you don't upgrade

00:26:02,849 --> 00:26:08,059
for a long time so we encourage building

00:26:05,820 --> 00:26:10,889
things directly from source code and

00:26:08,059 --> 00:26:12,269
that's all I wanted to talk about so

00:26:10,889 --> 00:26:14,809
thanks a lot for listening I'll be happy

00:26:12,269 --> 00:26:14,809
to take any questions

00:26:27,420 --> 00:26:29,480
you

00:26:30,940 --> 00:26:37,250
hello thank you I have a lot of

00:26:33,470 --> 00:26:40,420
questions first can you compare your

00:26:37,250 --> 00:26:45,050
system with sparker with what sorry

00:26:40,420 --> 00:26:47,960
Parker Parker Parker locker um I yes i

00:26:45,050 --> 00:26:51,170
have used parker the packer starts by

00:26:47,960 --> 00:26:52,730
taking an image that's already built so

00:26:51,170 --> 00:26:56,330
it will take a say in a bunt a base

00:26:52,730 --> 00:26:57,920
image and then it runs I can run a bunch

00:26:56,330 --> 00:27:00,380
of different commands like it can run a

00:26:57,920 --> 00:27:02,540
chef and run a chef script or an ansible

00:27:00,380 --> 00:27:05,630
and run an ansible script and then it

00:27:02,540 --> 00:27:08,360
can deploy the image somewhere so it's

00:27:05,630 --> 00:27:09,920
in a related area and they overlap I

00:27:08,360 --> 00:27:12,230
actually thought at one point about

00:27:09,920 --> 00:27:14,870
writing a bass rock plugin for Paco

00:27:12,230 --> 00:27:16,910
which could instead of starting with an

00:27:14,870 --> 00:27:19,070
ubuntu image would start by building or

00:27:16,910 --> 00:27:22,400
using a cached version of a system from

00:27:19,070 --> 00:27:23,960
source code so the answer is they can

00:27:22,400 --> 00:27:25,520
they can interoperate at the moment they

00:27:23,960 --> 00:27:28,280
don't but I'd like to look at how to

00:27:25,520 --> 00:27:32,809
integrate bass rock with packer thanks

00:27:28,280 --> 00:27:35,840
um does biz rocks works on Windows or on

00:27:32,809 --> 00:27:38,900
the UNIX systems the tooling only works

00:27:35,840 --> 00:27:41,179
on what ybd works in any puzzle system

00:27:38,900 --> 00:27:43,309
most of some of the tools only work in

00:27:41,179 --> 00:27:45,590
bass rock itself to free us from having

00:27:43,309 --> 00:27:50,110
to track dependencies and make it work

00:27:45,590 --> 00:27:53,720
on our distributions so linux or POSIX

00:27:50,110 --> 00:27:57,260
about continuous some continuous tools

00:27:53,720 --> 00:28:02,000
like rocket or wagga Oh Alexei can work

00:27:57,260 --> 00:28:05,450
without road do you use them on POSIX

00:28:02,000 --> 00:28:07,250
systems and not at the moment now but

00:28:05,450 --> 00:28:10,460
I'd be interested in implementing that

00:28:07,250 --> 00:28:14,240
in the sandboxing library if you want at

00:28:10,460 --> 00:28:16,040
all like I'm great yeah and last

00:28:14,240 --> 00:28:19,190
questions about doing all about Nick's

00:28:16,040 --> 00:28:20,570
package manager Nick's OS yes that's an

00:28:19,190 --> 00:28:22,160
excellent question I do know about

00:28:20,570 --> 00:28:24,800
Nick's OS and think it's a great project

00:28:22,160 --> 00:28:26,330
I'm terrified of the complexity but I

00:28:24,800 --> 00:28:28,309
would very much like to align everything

00:28:26,330 --> 00:28:32,080
we're doing with them as it becomes

00:28:28,309 --> 00:28:32,080
possible okay thank you

00:28:35,450 --> 00:28:39,289
I'm a bit slow between the errors so

00:28:37,909 --> 00:28:41,389
forgive me you probably already

00:28:39,289 --> 00:28:46,190
addressed this do I understand correctly

00:28:41,389 --> 00:28:47,960
that with bass rock I can do a sort of

00:28:46,190 --> 00:28:49,940
gin to type system where the entire

00:28:47,960 --> 00:28:52,370
system is built from source but there's

00:28:49,940 --> 00:28:55,700
no way that I can start from like a

00:28:52,370 --> 00:28:58,690
Santos base or debian-based that's

00:28:55,700 --> 00:29:01,130
correct yeah that's that's it yeah okay

00:28:58,690 --> 00:29:03,380
so that that Packer integration would be

00:29:01,130 --> 00:29:14,090
pretty awesome Kohi I should go write

00:29:03,380 --> 00:29:15,590
that myself thank you hey so if I

00:29:14,090 --> 00:29:17,330
understand correctly this build is

00:29:15,590 --> 00:29:18,700
happening as it's a chroot that you're

00:29:17,330 --> 00:29:20,690
essentially running these commands to

00:29:18,700 --> 00:29:22,429
put binaries into the true and you

00:29:20,690 --> 00:29:24,049
mentioned there's an integration thing

00:29:22,429 --> 00:29:26,419
that happens afterwards if you're going

00:29:24,049 --> 00:29:30,080
to perform modifications of things in

00:29:26,419 --> 00:29:32,929
the truth imagining I saw post and post

00:29:30,080 --> 00:29:35,120
install commands yeah so they're opposed

00:29:32,929 --> 00:29:37,490
to install commands basically those

00:29:35,120 --> 00:29:39,649
exist so that you don't have to override

00:29:37,490 --> 00:29:41,510
the default install commands so for

00:29:39,649 --> 00:29:43,909
example for auto tools the default is

00:29:41,510 --> 00:29:46,519
make install okay so you're not actually

00:29:43,909 --> 00:29:49,370
having to execute any commands inside of

00:29:46,519 --> 00:29:51,860
the truth itself yeah those commands all

00:29:49,370 --> 00:29:53,649
run inside that your roots okay so now

00:29:51,860 --> 00:29:56,059
I'm wondering how do you deal with

00:29:53,649 --> 00:29:58,070
architecture differences for example or

00:29:56,059 --> 00:29:59,929
things of that nature where you there

00:29:58,070 --> 00:30:02,179
you're built host doesn't support the

00:29:59,929 --> 00:30:04,429
target like running executables

00:30:02,179 --> 00:30:06,980
executables inside the target so cross

00:30:04,429 --> 00:30:08,529
compiling yeah that's one example yeah

00:30:06,980 --> 00:30:10,970
it doesn't support cross-compiling

00:30:08,529 --> 00:30:13,909
deliberately to avoid the complexity of

00:30:10,970 --> 00:30:15,110
supporting cross-compiling okay well

00:30:13,909 --> 00:30:16,850
yeah there's a whole other set of

00:30:15,110 --> 00:30:18,889
scenarios that I've run into a similar

00:30:16,850 --> 00:30:20,750
tooling were like selinux is another

00:30:18,889 --> 00:30:22,789
example very word your bill host doesn't

00:30:20,750 --> 00:30:27,110
support it or across major kernel

00:30:22,789 --> 00:30:29,809
versions that type of thing we recommend

00:30:27,110 --> 00:30:32,450
running build inside Base Rock vm or

00:30:29,809 --> 00:30:34,610
chroot and so the only thing that

00:30:32,450 --> 00:30:35,870
affects us is kernel versions and so

00:30:34,610 --> 00:30:37,460
there is a requirement on what Colonel

00:30:35,870 --> 00:30:39,380
you have but you can get around that by

00:30:37,460 --> 00:30:41,330
using a vm okay so you're trying to use

00:30:39,380 --> 00:30:44,649
same target and Bill toes essentially

00:30:41,330 --> 00:30:44,649
yeah yeah okay cool

00:30:49,430 --> 00:30:55,500
hi so I have a couple of questions how

00:30:52,230 --> 00:30:58,650
how do you bootstrap this like where do

00:30:55,500 --> 00:31:00,180
you get make from that's a good question

00:30:58,650 --> 00:31:02,880
the bootstraps actually quite

00:31:00,180 --> 00:31:06,059
interesting it's based on the Linux from

00:31:02,880 --> 00:31:09,000
scratch bootstrap if you want to see the

00:31:06,059 --> 00:31:22,170
gory details and you can look in the

00:31:09,000 --> 00:31:26,070
definitions repository which is an arc

00:31:22,170 --> 00:31:28,410
it's over and the gist of it is that we

00:31:26,070 --> 00:31:31,260
start by building from tar balls we

00:31:28,410 --> 00:31:32,970
build we have a bootstrap build mode

00:31:31,260 --> 00:31:36,290
which happens outside the chroot and

00:31:32,970 --> 00:31:39,270
uses the host tools so that builds I

00:31:36,290 --> 00:31:41,790
think that it builds a GCC in a bin

00:31:39,270 --> 00:31:44,370
utils and then with that it builds a

00:31:41,790 --> 00:31:48,720
stage two which is six components i

00:31:44,370 --> 00:31:50,940
think make gtc busy box and G Lib C and

00:31:48,720 --> 00:31:53,600
then it builds everything again with

00:31:50,940 --> 00:31:59,750
those tools energy route so we use

00:31:53,600 --> 00:31:59,750
basically clever ordering and the actual

00:32:01,070 --> 00:32:08,309
the description of this is in here so

00:32:06,540 --> 00:32:10,590
it's kind of explained in comments and

00:32:08,309 --> 00:32:13,950
you see it starts it does stage 1

00:32:10,590 --> 00:32:16,950
binutils stage 1 GCC and then the next

00:32:13,950 --> 00:32:19,050
API headers d lipsy and so on and the

00:32:16,950 --> 00:32:20,880
bootstraps quite good because it's

00:32:19,050 --> 00:32:23,250
really easy to cross bootstrap to a new

00:32:20,880 --> 00:32:24,660
platform so base rocks been ported to a

00:32:23,250 --> 00:32:27,300
bunch of different architectures already

00:32:24,660 --> 00:32:29,580
like arm and mips and we did a arm

00:32:27,300 --> 00:32:31,230
big-endian port which i think there's

00:32:29,580 --> 00:32:34,140
one of the only OS is you can run on arm

00:32:31,230 --> 00:32:36,120
big-endian at the moment because it's

00:32:34,140 --> 00:32:37,800
you only need to cross build about six

00:32:36,120 --> 00:32:41,429
things and then the rest you can native

00:32:37,800 --> 00:32:43,830
build ok and so a follow-up question if

00:32:41,429 --> 00:32:47,820
you if there's a security vulnerability

00:32:43,830 --> 00:32:50,610
in say G lipsy or something low level

00:32:47,820 --> 00:32:54,030
which you assume the implication is

00:32:50,610 --> 00:32:56,280
you'd have to rebuild most of your image

00:32:54,030 --> 00:32:58,650
there's a way that you can cheat by

00:32:56,280 --> 00:33:01,620
adding the newcomb a new version of

00:32:58,650 --> 00:33:04,950
component on top so if you wanted you

00:33:01,620 --> 00:33:06,900
could add G lipsy again and override the

00:33:04,950 --> 00:33:10,080
existent version and deploy that as an

00:33:06,900 --> 00:33:11,610
upgrade but yeah the design of it

00:33:10,080 --> 00:33:13,470
encourages rebuilding everything from

00:33:11,610 --> 00:33:14,820
source which is an ideal when doing a

00:33:13,470 --> 00:33:17,760
security update you need a lot of

00:33:14,820 --> 00:33:19,650
compile machinery the more of us

00:33:17,760 --> 00:33:28,770
providing distributed build workers the

00:33:19,650 --> 00:33:32,640
better in that scenario so we used

00:33:28,770 --> 00:33:34,380
Knicks great and you clearly are trying

00:33:32,640 --> 00:33:37,140
to fix the same kind of problems that

00:33:34,380 --> 00:33:40,440
they are trying to fix using similar

00:33:37,140 --> 00:33:42,240
components and so were you aware of

00:33:40,440 --> 00:33:45,210
Nick's when you started your project

00:33:42,240 --> 00:33:46,410
beta rock uh I was yeah I wasn't

00:33:45,210 --> 00:33:48,360
actually one of the founders of bass

00:33:46,410 --> 00:33:50,490
rock I've kind of got involved in it

00:33:48,360 --> 00:33:53,760
later on I was a way of nicks I've never

00:33:50,490 --> 00:33:57,540
really used it much I found it has quite

00:33:53,760 --> 00:33:59,910
an area of complexity that build

00:33:57,540 --> 00:34:04,410
definitions rather than being data a

00:33:59,910 --> 00:34:06,180
sort of functional code so i think long

00:34:04,410 --> 00:34:10,140
term I definitely definitely need to

00:34:06,180 --> 00:34:13,080
align the two projects but to get in

00:34:10,140 --> 00:34:14,669
usenix because you were scared of it in

00:34:13,080 --> 00:34:15,780
a way yeah I think the people who

00:34:14,669 --> 00:34:18,419
originally came up with beige like

00:34:15,780 --> 00:34:20,120
didn't at all think of using nicks so

00:34:18,419 --> 00:34:25,800
some of its been developed in parallel

00:34:20,120 --> 00:34:27,600
okay thank you i should add part of part

00:34:25,800 --> 00:34:30,620
of the original goals of beige Rockies

00:34:27,600 --> 00:34:30,620
to reduce complexity

00:34:36,029 --> 00:34:42,279
um oh yeah let's see if I like some

00:34:38,710 --> 00:34:44,619
elders done anything um there we go it's

00:34:42,279 --> 00:34:47,230
generated a stratum which has I'll XML

00:34:44,619 --> 00:34:52,839
and see if i siphon in it I can share it

00:34:47,230 --> 00:34:54,549
you in here so that's quite a simple

00:34:52,839 --> 00:34:56,799
example in the end wasn't the most

00:34:54,549 --> 00:34:58,990
efficient solution but it worked and so

00:34:56,799 --> 00:35:00,339
it just saves you writing definitions by

00:34:58,990 --> 00:35:02,200
hand for things where there's metadata

00:35:00,339 --> 00:35:05,289
that already exists there's also

00:35:02,200 --> 00:35:08,289
importance for Ruby gems and NPM

00:35:05,289 --> 00:35:10,660
something else now is that the least

00:35:08,289 --> 00:35:14,829
useful bootable linux distribution ever

00:35:10,660 --> 00:35:21,880
I don't know depends how much she liked

00:35:14,829 --> 00:35:25,930
using lxml from the console any final

00:35:21,880 --> 00:35:29,670
questions okay great well thank you very

00:35:25,930 --> 00:35:29,670

YouTube URL: https://www.youtube.com/watch?v=qYGlMCk15hs


