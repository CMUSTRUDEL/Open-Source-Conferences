Title: Andrey Syschikov - Practical usage of advanced Python constructs
Publication date: 2015-08-08
Playlist: EuroPython 2015
Description: 
	Andrey Syschikov - Practical usage of advanced Python constructs
[EuroPython 2015]
[24 July 2015]
[Bilbao, Euskadi, Spain]

Python is a language of choice for developers with wide range of
experience, for some it is a first programming language, others switch
to Python after years of experience. Python provides friendly syntax
and smooth learning curve. This sometimes leads to developers lacking
comprehension of some more advanced constructs.

It happens that experienced developers jump into using Python and
sometimes miss less known Python language constructs. On the other
hands people who purposefully learned Python sometimes lack practical
ideas for how to apply those constructs.

This talk will be specifically focused on the practical usages of
advanced Python constructs like iterators, generators, decorators and
context managers. Goal of the talk is to share ideas about how those
constructs can be used for practical purposes in real projects. Prior
knowledge is not required, there will be a brief introduction to every
construct being presented.
Captions: 
	00:00:00,860 --> 00:00:06,810
so I would assume that we hear all of

00:00:04,920 --> 00:00:09,080
Python or maybe your company offer to

00:00:06,810 --> 00:00:11,849
pay for the trip and you couldn't say no

00:00:09,080 --> 00:00:14,759
we love Python because of its expression

00:00:11,849 --> 00:00:20,850
power and nice learning curve and it's a

00:00:14,759 --> 00:00:23,130
coding style the fact that many language

00:00:20,850 --> 00:00:25,260
language features look like native

00:00:23,130 --> 00:00:26,820
languages the general

00:00:25,260 --> 00:00:30,150
straightforwardness of Python and

00:00:26,820 --> 00:00:32,550
general lack of a lack of hidden tricks

00:00:30,150 --> 00:00:35,329
makes it appealing both at the first

00:00:32,550 --> 00:00:37,440
language for people who just started

00:00:35,329 --> 00:00:39,360
programming and as a new language for

00:00:37,440 --> 00:00:43,170
experienced developers practice shows

00:00:39,360 --> 00:00:44,430
that you can quickly start doing useful

00:00:43,170 --> 00:00:47,160
things in Python if you are already

00:00:44,430 --> 00:00:49,590
experienced programmer so I used to a

00:00:47,160 --> 00:00:51,270
program for microsoft.net on c-sharp for

00:00:49,590 --> 00:00:54,420
five years before I got into my first

00:00:51,270 --> 00:00:56,430
Python project I I didn't really know

00:00:54,420 --> 00:00:58,590
that much about Python I didn't have any

00:00:56,430 --> 00:01:00,809
formal training in Python or read any

00:00:58,590 --> 00:01:02,250
book in Python so my approach was purely

00:01:00,809 --> 00:01:03,930
practical I was only interested in

00:01:02,250 --> 00:01:05,760
getting my tasks done and not really

00:01:03,930 --> 00:01:07,979
getting too deep into theories it was

00:01:05,760 --> 00:01:10,110
three years ago since that I learned a

00:01:07,979 --> 00:01:12,810
lot about Python but what I noticed that

00:01:10,110 --> 00:01:15,150
many tutorials books blog posts that

00:01:12,810 --> 00:01:18,090
feature advanced concept they usually

00:01:15,150 --> 00:01:19,470
use really impractical examples like for

00:01:18,090 --> 00:01:21,479
example how to generate Fibonacci

00:01:19,470 --> 00:01:23,850
numbers who really generates Fibonacci

00:01:21,479 --> 00:01:25,890
numbers in production so that's why I

00:01:23,850 --> 00:01:28,560
decided to make this talk and provide

00:01:25,890 --> 00:01:30,180
some practical examples on usage of

00:01:28,560 --> 00:01:32,759
advanced language constructs in Python

00:01:30,180 --> 00:01:34,890
so I'm not really here today to teach

00:01:32,759 --> 00:01:37,650
you but more to provide interesting

00:01:34,890 --> 00:01:39,509
ideas examples to inspire you to

00:01:37,650 --> 00:01:41,520
practically use those constructs so

00:01:39,509 --> 00:01:43,470
quick check please raise your hands

00:01:41,520 --> 00:01:46,100
those who use a yield keyword in

00:01:43,470 --> 00:01:49,500
production code last in within last year

00:01:46,100 --> 00:01:52,920
wow I'm surprised a lot of people good

00:01:49,500 --> 00:01:56,159
who wrote a himself a decorator

00:01:52,920 --> 00:01:58,469
in last year in production okay great

00:01:56,159 --> 00:02:00,799
who wrote context manager within last

00:01:58,469 --> 00:02:03,210
year okay

00:02:00,799 --> 00:02:05,430
so it's good so yeah you're more

00:02:03,210 --> 00:02:06,960
familiar with the theory so I can not

00:02:05,430 --> 00:02:09,539
really focus too much on it and jump to

00:02:06,960 --> 00:02:11,459
example so for my examples in this talk

00:02:09,539 --> 00:02:12,140
I used a code from my project that

00:02:11,459 --> 00:02:15,110
worked

00:02:12,140 --> 00:02:19,130
and I collected the quote from different

00:02:15,110 --> 00:02:21,350
open-source libraries so what is it

00:02:19,130 --> 00:02:25,100
herbal and Python all the definitions I

00:02:21,350 --> 00:02:27,820
took from official glossary so well it

00:02:25,100 --> 00:02:30,440
uses a pretty vague abstract definitions

00:02:27,820 --> 00:02:33,470
so what it practically is a terrible

00:02:30,440 --> 00:02:36,950
terrible is a object that has eater and

00:02:33,470 --> 00:02:40,010
method where can be used in Python it

00:02:36,950 --> 00:02:42,740
can be used in for statement in the loop

00:02:40,010 --> 00:02:45,200
it can be used in list comprehensions or

00:02:42,740 --> 00:02:47,420
in generator expressions or you can pass

00:02:45,200 --> 00:02:51,020
it to functions that expect eater but

00:02:47,420 --> 00:02:53,030
like all any sum filter whatever and

00:02:51,020 --> 00:02:54,830
I would like to draw your attention to

00:02:53,030 --> 00:02:55,880
Turtles for those who don't know it

00:02:54,830 --> 00:02:57,890
provides a lot of very useful

00:02:55,880 --> 00:03:01,970
functionality to work with the turbos in

00:02:57,890 --> 00:03:04,250
iterators so I said that iterable

00:03:01,970 --> 00:03:07,450
returns iterator so what's the iterator

00:03:04,250 --> 00:03:10,580
iterator basically the whole

00:03:07,450 --> 00:03:12,380
functionality of iterator is to keep the

00:03:10,580 --> 00:03:13,550
current state of iteration like for

00:03:12,380 --> 00:03:15,410
example if you we are generating our

00:03:13,550 --> 00:03:19,220
list is to remember the current element

00:03:15,410 --> 00:03:21,260
and that's being returned and basically

00:03:19,220 --> 00:03:23,950
only thing it has to do it has to

00:03:21,260 --> 00:03:26,060
provide a next method which basically

00:03:23,950 --> 00:03:29,930
produces a new value on every iteration

00:03:26,060 --> 00:03:32,750
or raises stop iteration exception if

00:03:29,930 --> 00:03:34,780
the iterator exhausted well how it can

00:03:32,750 --> 00:03:37,519
be created you can create a class

00:03:34,780 --> 00:03:40,010
implement method nets and in some shaded

00:03:37,519 --> 00:03:43,310
I would like to point out this

00:03:40,010 --> 00:03:44,720
completely impractical way and I won't

00:03:43,310 --> 00:03:48,140
be really talking about it then

00:03:44,720 --> 00:03:49,580
generator expression generator

00:03:48,140 --> 00:03:52,280
expression looks very much like list

00:03:49,580 --> 00:03:54,200
comprehensions except that it use round

00:03:52,280 --> 00:03:56,540
brackets it's an important difference

00:03:54,200 --> 00:03:59,480
basically in list comprehensions you

00:03:56,540 --> 00:04:02,030
immediately force the creation of the

00:03:59,480 --> 00:04:05,269
whole list and production of the whole

00:04:02,030 --> 00:04:08,989
various so it takes memory and it's not

00:04:05,269 --> 00:04:11,630
very actually useful and well so our my

00:04:08,989 --> 00:04:13,220
strong opinion is that for most of the

00:04:11,630 --> 00:04:15,019
time you should prefer generator

00:04:13,220 --> 00:04:18,140
expressions over list comprehensions

00:04:15,019 --> 00:04:19,729
because it saves memory and sometimes

00:04:18,140 --> 00:04:21,130
you don't even need the whole list of

00:04:19,729 --> 00:04:24,820
them

00:04:21,130 --> 00:04:27,760
all the values then generator functions

00:04:24,820 --> 00:04:30,550
so generators generators is a function

00:04:27,760 --> 00:04:32,500
that has a yield keyword in it well many

00:04:30,550 --> 00:04:34,540
of you Redskins so I won't go too deep

00:04:32,500 --> 00:04:37,510
so this is the most practical way to

00:04:34,540 --> 00:04:39,160
create a complex iterators in Python it

00:04:37,510 --> 00:04:42,340
was introduced in the same version of

00:04:39,160 --> 00:04:44,740
Python as iterators because yeah how

00:04:42,340 --> 00:04:46,450
thorough Python immediately understood

00:04:44,740 --> 00:04:49,210
that creating classes for iteration is

00:04:46,450 --> 00:04:52,360
not very convenient it you can read the

00:04:49,210 --> 00:04:54,100
discussion about it in pepper to 5/5 it

00:04:52,360 --> 00:04:56,740
grew into something way larger into

00:04:54,100 --> 00:05:00,910
corrosions but this is outside of the

00:04:56,740 --> 00:05:03,880
scope so quick quick glance car works so

00:05:00,910 --> 00:05:05,980
if function has a yogi worked in it it's

00:05:03,880 --> 00:05:07,480
marked as a generator when you call it

00:05:05,980 --> 00:05:09,880
it doesn't actually execute a function

00:05:07,480 --> 00:05:12,520
it just creates iterator object when you

00:05:09,880 --> 00:05:14,530
iterate over it the control flow will

00:05:12,520 --> 00:05:17,650
actually step into function and go to

00:05:14,530 --> 00:05:20,890
the first yield then return it to the

00:05:17,650 --> 00:05:22,840
loop outside and then stop until next

00:05:20,890 --> 00:05:25,180
iteration so let's quickly run through

00:05:22,840 --> 00:05:28,330
it so this how it will be executed will

00:05:25,180 --> 00:05:30,340
go will print yield it will return but

00:05:28,330 --> 00:05:32,620
on next iteration it will start from the

00:05:30,340 --> 00:05:36,550
next line and go until next yield or end

00:05:32,620 --> 00:05:38,980
the function so this will print the want

00:05:36,550 --> 00:05:41,350
0 to so what's the difference between

00:05:38,980 --> 00:05:44,830
the regular function is that it

00:05:41,350 --> 00:05:46,990
remembers it stays between the calls so

00:05:44,830 --> 00:05:50,350
what can it be practically used for

00:05:46,990 --> 00:05:51,820
because many people when they study and

00:05:50,350 --> 00:05:54,280
the subject they don't really know well

00:05:51,820 --> 00:05:58,480
ok this seems cool but what can I do one

00:05:54,280 --> 00:06:00,640
of the very common usage of generators

00:05:58,480 --> 00:06:03,040
is basically to create a view over a

00:06:00,640 --> 00:06:05,020
collection do some filtering and mapping

00:06:03,040 --> 00:06:06,490
so this is the code from a project I've

00:06:05,020 --> 00:06:09,010
worked on we had some list of fields

00:06:06,490 --> 00:06:12,160
some of them were considered dynamic

00:06:09,010 --> 00:06:13,840
start with some prefix and basically we

00:06:12,160 --> 00:06:15,460
needed to get a list of the field name

00:06:13,840 --> 00:06:18,460
dynamic field names in different places

00:06:15,460 --> 00:06:21,010
so we wrote this simple a generator

00:06:18,460 --> 00:06:22,930
what's good about it first you don't

00:06:21,010 --> 00:06:25,060
need to copy-paste this for and if

00:06:22,930 --> 00:06:27,760
everywhere you need the list second it

00:06:25,060 --> 00:06:30,580
it looks clean it's easy to read well

00:06:27,760 --> 00:06:34,020
it's multi-line list comprehensions or

00:06:30,580 --> 00:06:37,030
generator expressions are well ugly so

00:06:34,020 --> 00:06:37,960
this is the well this we want some

00:06:37,030 --> 00:06:41,069
filtering and then we

00:06:37,960 --> 00:06:44,800
some mapping so another common way to

00:06:41,069 --> 00:06:47,940
write generators is to flatten lists so

00:06:44,800 --> 00:06:50,229
this code comes from Django framework so

00:06:47,940 --> 00:06:51,849
flattening lists if you have a list of

00:06:50,229 --> 00:06:54,970
lists and you want to iterate over all

00:06:51,849 --> 00:06:58,479
sub elements as if it was a single

00:06:54,970 --> 00:07:00,940
stream of values so they it's basically

00:06:58,479 --> 00:07:03,009
usually done with the nested force and

00:07:00,940 --> 00:07:04,660
so they created this iterator so they

00:07:03,009 --> 00:07:06,460
don't need to copy/paste this to force

00:07:04,660 --> 00:07:08,860
everywhere it's actually good and bad

00:07:06,460 --> 00:07:11,800
example because it's our tools mojo

00:07:08,860 --> 00:07:15,880
provides a much easier way to flatten

00:07:11,800 --> 00:07:18,220
list with a iterables that's and that's

00:07:15,880 --> 00:07:19,479
the how it can be done in one line so

00:07:18,220 --> 00:07:21,729
it's very popular question on Stack

00:07:19,479 --> 00:07:23,169
Overflow so I would assume that well

00:07:21,729 --> 00:07:25,690
yeah people have difficulties with it

00:07:23,169 --> 00:07:28,150
but there can be more complicated

00:07:25,690 --> 00:07:30,580
flattening list logic this code comes

00:07:28,150 --> 00:07:32,560
from Django alright from ginger it's a

00:07:30,580 --> 00:07:35,110
templating engine used often use with

00:07:32,560 --> 00:07:37,900
flask frameworks so they have a list of

00:07:35,110 --> 00:07:41,560
items and item can't be a node or

00:07:37,900 --> 00:07:44,530
released so if it's not we return it we

00:07:41,560 --> 00:07:47,409
owed it if it's a list we go into sub

00:07:44,530 --> 00:07:50,830
loop so this is here you can't use

00:07:47,409 --> 00:07:54,190
really eater tools so this is an example

00:07:50,830 --> 00:07:56,440
of more complex flattening so what it

00:07:54,190 --> 00:07:58,840
can be also good for generators is to

00:07:56,440 --> 00:08:01,389
save memory so this code comes from

00:07:58,840 --> 00:08:04,870
request library is so called HTTP

00:08:01,389 --> 00:08:06,460
library for humans whatever it means but

00:08:04,870 --> 00:08:08,949
it's very convenient for library to do

00:08:06,460 --> 00:08:11,620
HTTP requests so somewhere in the depths

00:08:08,949 --> 00:08:13,659
of it they have a socket object or I

00:08:11,620 --> 00:08:16,509
know some sort of wrapper self dot role

00:08:13,659 --> 00:08:20,409
that can that well it's a network stream

00:08:16,509 --> 00:08:21,820
it's a sequence of bytes but require a

00:08:20,409 --> 00:08:24,550
responses from servers can be fairly

00:08:21,820 --> 00:08:27,159
large we don't really want to load them

00:08:24,550 --> 00:08:29,770
in memory completely so they wrote

00:08:27,159 --> 00:08:31,840
iterator that breaks it into chunks and

00:08:29,770 --> 00:08:34,000
you can iterate over those chunks

00:08:31,840 --> 00:08:35,890
without actually loading the whole

00:08:34,000 --> 00:08:37,329
content of the response into memory

00:08:35,890 --> 00:08:39,820
that's very convenient because it saves

00:08:37,329 --> 00:08:42,279
memory and it's convenient basically

00:08:39,820 --> 00:08:46,480
because users of this function may not

00:08:42,279 --> 00:08:48,910
really need a whole whole response in

00:08:46,480 --> 00:08:50,930
memory they it can be used to directly

00:08:48,910 --> 00:08:53,420
write those chunks into file

00:08:50,930 --> 00:08:56,630
so you can save it locally but it's good

00:08:53,420 --> 00:08:58,400
for memory and performance so it's more

00:08:56,630 --> 00:09:01,390
a little bit more complicated so this is

00:08:58,400 --> 00:09:04,190
their internal usage of this chunks

00:09:01,390 --> 00:09:09,260
iterator so what's they doing here

00:09:04,190 --> 00:09:11,660
so it's iterator that takes iterator of

00:09:09,260 --> 00:09:15,650
chunks and produce iterator of strings

00:09:11,660 --> 00:09:17,960
so chunks have a fixed lens but strings

00:09:15,650 --> 00:09:20,330
it can be arbitrary length and they are

00:09:17,960 --> 00:09:23,480
divided by delimiter so what they do

00:09:20,330 --> 00:09:25,340
here they break a chunk into strings but

00:09:23,480 --> 00:09:28,850
it can happen that the remainder of

00:09:25,340 --> 00:09:31,970
chunk is incomplete line and we need to

00:09:28,850 --> 00:09:35,360
know to get another chunk to complete it

00:09:31,970 --> 00:09:38,770
so here we introduce a state a local

00:09:35,360 --> 00:09:41,840
variable pending which carries over a

00:09:38,770 --> 00:09:45,290
leftover of chunk that is uncompleted

00:09:41,840 --> 00:09:49,670
string they keep it before between

00:09:45,290 --> 00:09:52,400
yields and they edit to chunk so that

00:09:49,670 --> 00:09:56,360
they can they remember it between calls

00:09:52,400 --> 00:09:58,190
so that they can connect it with the

00:09:56,360 --> 00:10:01,310
rest of the string and return it so if

00:09:58,190 --> 00:10:03,170
if the chunk there are no more chunks

00:10:01,310 --> 00:10:05,060
then they assume that painting is

00:10:03,170 --> 00:10:07,910
complete string and return it it's a

00:10:05,060 --> 00:10:12,050
convenient example how also you can save

00:10:07,910 --> 00:10:15,050
memory and create iterator over iterator

00:10:12,050 --> 00:10:17,840
with the generators so iterators

00:10:15,050 --> 00:10:20,780
generators are also convenient to

00:10:17,840 --> 00:10:23,240
traverse complex data structures so this

00:10:20,780 --> 00:10:25,670
is example of first code of standard OS

00:10:23,240 --> 00:10:28,160
module at a function walk I simplified

00:10:25,670 --> 00:10:29,630
it significantly while it's like 200

00:10:28,160 --> 00:10:34,520
lines of code but this is the core of it

00:10:29,630 --> 00:10:37,820
so it uses a recursive iterate recursive

00:10:34,520 --> 00:10:40,820
generators so it's a very convenient in

00:10:37,820 --> 00:10:45,640
this case because file system is three

00:10:40,820 --> 00:10:48,260
data structure so walk returns couple of

00:10:45,640 --> 00:10:50,750
current paths the list of deere's

00:10:48,260 --> 00:10:52,550
in this path and list of files then it

00:10:50,750 --> 00:10:55,340
goes over the list of directories in

00:10:52,550 --> 00:10:57,890
current path and calls itself basically

00:10:55,340 --> 00:11:01,100
and here's the results so in the end if

00:10:57,890 --> 00:11:03,290
we iterate over walk generator we will

00:11:01,100 --> 00:11:06,529
get a flat list of

00:11:03,290 --> 00:11:11,480
theoretical data that's very convenient

00:11:06,529 --> 00:11:13,699
also it raters can be infinite so some

00:11:11,480 --> 00:11:15,709
people may wondering what why would you

00:11:13,699 --> 00:11:17,930
need infinite iterator you can't even

00:11:15,709 --> 00:11:19,399
iterate over it you can do four over it

00:11:17,930 --> 00:11:23,269
because it will like it will be memory

00:11:19,399 --> 00:11:24,829
and burn CPU this is example this is

00:11:23,269 --> 00:11:28,100
Django templating language for those who

00:11:24,829 --> 00:11:32,089
aren't familiar it just basically copies

00:11:28,100 --> 00:11:35,569
the 4/4 tag copies its contents it's

00:11:32,089 --> 00:11:38,569
here generates rows in a table so we

00:11:35,569 --> 00:11:41,209
would like to often in you know in web

00:11:38,569 --> 00:11:43,160
we have tables there the rows come in

00:11:41,209 --> 00:11:45,889
different colors one after another so a

00:11:43,160 --> 00:11:49,009
jungle has this cycle tag which actually

00:11:45,889 --> 00:11:50,350
will produce on every call Row 1 Row 2

00:11:49,009 --> 00:11:52,279
Row 1 Row 2

00:11:50,350 --> 00:11:55,279
internally it's implemented with the

00:11:52,279 --> 00:11:59,329
inter tools cycle iterator which is

00:11:55,279 --> 00:12:00,829
infinite iterator in the lower part in

00:11:59,329 --> 00:12:02,180
the lower part you can see well it

00:12:00,829 --> 00:12:04,490
basically takes it terrible and then

00:12:02,180 --> 00:12:07,579
repeats it one by items one by one

00:12:04,490 --> 00:12:10,670
forever so every time this tag is called

00:12:07,579 --> 00:12:14,389
it calls render method and it just calls

00:12:10,670 --> 00:12:16,370
next item on the traitor so it's not a

00:12:14,389 --> 00:12:18,430
problem that the iterator here is

00:12:16,370 --> 00:12:20,600
infinite it will not never try to

00:12:18,430 --> 00:12:24,040
integrate over it completely it will

00:12:20,600 --> 00:12:27,350
call it exactly as many times as four

00:12:24,040 --> 00:12:28,790
iterates so this is very nice and clean

00:12:27,350 --> 00:12:30,949
code you don't need to maintain any

00:12:28,790 --> 00:12:32,750
state like which value was returned

00:12:30,949 --> 00:12:36,050
previously you just call next on cycle

00:12:32,750 --> 00:12:40,160
so again I advertise you itertools a

00:12:36,050 --> 00:12:43,540
module so those are the most common

00:12:40,160 --> 00:12:45,790
practical examples for using but I

00:12:43,540 --> 00:12:48,500
recommend you to research deeper because

00:12:45,790 --> 00:12:50,870
iterative generators is very complex

00:12:48,500 --> 00:12:53,889
topic and Python it has way more

00:12:50,870 --> 00:12:58,819
advanced usages so I recommend you to

00:12:53,889 --> 00:13:02,089
look more into it or tools it or tools

00:12:58,819 --> 00:13:04,939
module and master it because it can

00:13:02,089 --> 00:13:06,529
improve your productivity then actually

00:13:04,939 --> 00:13:09,290
yield is not the statement it is

00:13:06,529 --> 00:13:13,959
expression so it can be used as a

00:13:09,290 --> 00:13:16,700
mechanism to pass values from color to

00:13:13,959 --> 00:13:21,380
generator this can

00:13:16,700 --> 00:13:23,720
did later led python to even more

00:13:21,380 --> 00:13:26,090
advanced stuff so now then i recommend

00:13:23,720 --> 00:13:28,790
you to read about yield from its

00:13:26,090 --> 00:13:31,100
so-called generation delegations and

00:13:28,790 --> 00:13:33,680
they're those two features are used to

00:13:31,100 --> 00:13:35,780
implement corrodens in python which is

00:13:33,680 --> 00:13:40,210
also very interesting and based on

00:13:35,780 --> 00:13:43,040
corrodens there is a new relatively new

00:13:40,210 --> 00:13:46,220
module well the whole concept in Python

00:13:43,040 --> 00:13:48,320
code I think it's project tulip it's for

00:13:46,220 --> 00:13:49,430
a synchronous input output and they're

00:13:48,320 --> 00:13:52,010
heavily based on core audience

00:13:49,430 --> 00:13:54,680
generators and iterators actually don't

00:13:52,010 --> 00:13:57,890
need to photo the slides I will put them

00:13:54,680 --> 00:13:59,690
online and so yeah you can don't worry

00:13:57,890 --> 00:14:02,210
if you miss something you can check it

00:13:59,690 --> 00:14:05,990
out later on so another advanced feature

00:14:02,210 --> 00:14:08,270
that's all often not used in practice by

00:14:05,990 --> 00:14:12,200
well maybe starter developers its

00:14:08,270 --> 00:14:15,050
decorators so again many of you raise

00:14:12,200 --> 00:14:16,430
hands so I would assume that many of you

00:14:15,050 --> 00:14:21,170
know how to create works basically

00:14:16,430 --> 00:14:24,440
decorator wraps your function with some

00:14:21,170 --> 00:14:27,470
inner function what basically all it

00:14:24,440 --> 00:14:29,180
does it assigns to your function they

00:14:27,470 --> 00:14:32,650
decorated the wrapped version of your

00:14:29,180 --> 00:14:35,570
function what is it good for practically

00:14:32,650 --> 00:14:38,320
with the decorator you can modify input

00:14:35,570 --> 00:14:41,840
arguments you can modify return value

00:14:38,320 --> 00:14:43,460
well you can do things before functions

00:14:41,840 --> 00:14:45,320
called after functions called you can

00:14:43,460 --> 00:14:47,030
actually not call the function at all so

00:14:45,320 --> 00:14:49,520
your decorator may decide not to call

00:14:47,030 --> 00:14:52,010
function for some reason you can modify

00:14:49,520 --> 00:14:54,320
some global state some outer variable

00:14:52,010 --> 00:14:56,360
some thread locals and stuff like this

00:14:54,320 --> 00:14:58,580
for this function and then set them back

00:14:56,360 --> 00:15:02,000
to the values that were before that and

00:14:58,580 --> 00:15:04,610
it can usefully decrees can be useful to

00:15:02,000 --> 00:15:11,090
assign metadata to functions of all

00:15:04,610 --> 00:15:13,520
sorts so this is example from flask web

00:15:11,090 --> 00:15:17,470
framework the heavily used decorators so

00:15:13,520 --> 00:15:20,630
we they demonstrate two things here it

00:15:17,470 --> 00:15:22,820
it is hello is a web view it's basically

00:15:20,630 --> 00:15:25,640
a function that is called when when you

00:15:22,820 --> 00:15:28,310
call your your web server

00:15:25,640 --> 00:15:29,760
/hello or slash hello name so what they

00:15:28,310 --> 00:15:33,750
do here they

00:15:29,760 --> 00:15:37,220
use decorators to parse URL into

00:15:33,750 --> 00:15:41,100
function arguments and another usage of

00:15:37,220 --> 00:15:43,079
decorator here is that it basically

00:15:41,100 --> 00:15:45,600
makes it possible to discover the

00:15:43,079 --> 00:15:48,029
function so the so the framework knows

00:15:45,600 --> 00:15:51,240
which functions are web views so in this

00:15:48,029 --> 00:15:54,899
sense it provides a metadata for your

00:15:51,240 --> 00:15:58,139
application this is the small snippet

00:15:54,899 --> 00:16:00,779
from from my current project so we have

00:15:58,139 --> 00:16:03,269
this we want to make extensible list of

00:16:00,779 --> 00:16:05,670
extendable list of well some filters

00:16:03,269 --> 00:16:07,709
whatever that means and we would like to

00:16:05,670 --> 00:16:10,560
associate we would like to show them on

00:16:07,709 --> 00:16:13,199
UI so users can select from a list so we

00:16:10,560 --> 00:16:16,079
need some like sort of label for those

00:16:13,199 --> 00:16:19,380
fields so I created this decorator that

00:16:16,079 --> 00:16:23,760
provides a human readable description

00:16:19,380 --> 00:16:25,949
that we is used on UI also I can query

00:16:23,760 --> 00:16:29,579
all the functions in the modules and

00:16:25,949 --> 00:16:31,850
check if if they have this if they have

00:16:29,579 --> 00:16:34,410
this decorator so it's also good for

00:16:31,850 --> 00:16:37,110
discovery and for providing metadata

00:16:34,410 --> 00:16:42,360
that can be used and for example in UI

00:16:37,110 --> 00:16:44,370
later on so color or not so with a

00:16:42,360 --> 00:16:46,889
decorator you can make it a crater that

00:16:44,370 --> 00:16:49,620
decides maybe actually we shouldn't call

00:16:46,889 --> 00:16:53,250
the underlying function at all this is

00:16:49,620 --> 00:16:55,529
again simplified example from Jango they

00:16:53,250 --> 00:16:58,860
have a decorator called permission

00:16:55,529 --> 00:17:02,519
required so you can apply this decorator

00:16:58,860 --> 00:17:04,049
on a webview function and check if the

00:17:02,519 --> 00:17:07,559
currently logged user has certain

00:17:04,049 --> 00:17:10,500
permission to call this webview so what

00:17:07,559 --> 00:17:14,250
we can see here they check if the

00:17:10,500 --> 00:17:16,770
current user has this permission if user

00:17:14,250 --> 00:17:19,110
has this permission they call they call

00:17:16,770 --> 00:17:20,610
the actual function if user does

00:17:19,110 --> 00:17:23,660
confirmation they don't even call the

00:17:20,610 --> 00:17:26,520
function so that's that's how you can

00:17:23,660 --> 00:17:28,500
check whether you should actually call

00:17:26,520 --> 00:17:31,530
functional not always error or whatever

00:17:28,500 --> 00:17:34,410
do something else this is a decorator

00:17:31,530 --> 00:17:36,630
rate limit we created in one of my

00:17:34,410 --> 00:17:40,380
projects basically it's also for web

00:17:36,630 --> 00:17:44,010
views it counts in a cache how often

00:17:40,380 --> 00:17:46,020
Paige is called by certain IP address

00:17:44,010 --> 00:17:48,570
and for example if it's called more than

00:17:46,020 --> 00:17:50,970
10 times in a minute we will not

00:17:48,570 --> 00:17:53,400
generate the response will show an error

00:17:50,970 --> 00:17:58,500
with very simple mechanism from prevent

00:17:53,400 --> 00:18:02,309
of abusing of service yeah so if the

00:17:58,500 --> 00:18:07,679
user calls it too often we can prevent

00:18:02,309 --> 00:18:10,799
call completely a caching is very big

00:18:07,679 --> 00:18:13,950
feature that can be done with decorators

00:18:10,799 --> 00:18:16,049
so this is in our project we created

00:18:13,950 --> 00:18:19,169
really simple and I have to confess a

00:18:16,049 --> 00:18:21,990
little bit stupid cashing decorator that

00:18:19,169 --> 00:18:24,740
we apply on properties exclusively

00:18:21,990 --> 00:18:28,440
that's important point so we have this

00:18:24,740 --> 00:18:31,230
num persons and it counts it's the

00:18:28,440 --> 00:18:34,559
jungle around so basically just counts

00:18:31,230 --> 00:18:36,690
related objects so this function is

00:18:34,559 --> 00:18:38,640
called this properties it called a lot

00:18:36,690 --> 00:18:40,890
in reports so we have a reports that

00:18:38,640 --> 00:18:44,390
call this function I don't like 20 times

00:18:40,890 --> 00:18:47,309
right and we can just drop this

00:18:44,390 --> 00:18:52,650
decorator carries out here and can very

00:18:47,309 --> 00:18:58,080
conveniently prevent too many of the

00:18:52,650 --> 00:19:01,650
calls so how we implemented it it's also

00:18:58,080 --> 00:19:03,390
very straightforward so you can see here

00:19:01,650 --> 00:19:09,120
we get the funk name that will be none

00:19:03,390 --> 00:19:14,030
persons in this case so if the far the

00:19:09,120 --> 00:19:17,909
object has this attribute we do get

00:19:14,030 --> 00:19:20,520
attribute if it's not if it's not in the

00:19:17,909 --> 00:19:24,240
object we actually call the property

00:19:20,520 --> 00:19:26,789
calculated and then set corresponding

00:19:24,240 --> 00:19:31,230
attribute and the subsequent cost this

00:19:26,789 --> 00:19:33,960
property will return the cash value so

00:19:31,230 --> 00:19:36,960
what's bad about it is basically that

00:19:33,960 --> 00:19:38,150
yeah it's a underlying object or data

00:19:36,960 --> 00:19:42,920
changes

00:19:38,150 --> 00:19:45,120
well you there is no way to enforce

00:19:42,920 --> 00:19:49,560
recalculation but this is good

00:19:45,120 --> 00:19:51,630
for simple cases like for example yeah

00:19:49,560 --> 00:19:56,970
if you're sure that your object won't

00:19:51,630 --> 00:19:59,640
change so the proper way to care with

00:19:56,970 --> 00:20:02,310
the decorators there is this awesome I

00:19:59,640 --> 00:20:05,190
really like this library called dogpile

00:20:02,310 --> 00:20:09,110
it actually creates proper and very

00:20:05,190 --> 00:20:13,140
sophisticated way to cache to cache

00:20:09,110 --> 00:20:16,770
functions and methods everything so the

00:20:13,140 --> 00:20:18,030
key decorated there is Karen arguments

00:20:16,770 --> 00:20:20,510
you can provide different backends

00:20:18,030 --> 00:20:26,210
memcache local memory wood anything and

00:20:20,510 --> 00:20:29,280
they will actually cache the function

00:20:26,210 --> 00:20:33,480
for corresponding arguments as well so

00:20:29,280 --> 00:20:35,880
it's it the cache key will include the

00:20:33,480 --> 00:20:38,070
function arguments it's very smart you

00:20:35,880 --> 00:20:40,590
can refresh it you can refresh values

00:20:38,070 --> 00:20:42,420
and everything I recommend I suggest

00:20:40,590 --> 00:20:43,740
everyone to look into this because

00:20:42,420 --> 00:20:47,610
that's probably the most sophisticated

00:20:43,740 --> 00:20:52,920
caching and library with the decorators

00:20:47,610 --> 00:20:55,740
I've seen so far my my personal award

00:20:52,920 --> 00:21:00,780
for most creative use of decorators goes

00:20:55,740 --> 00:21:04,860
to unstable unstable is a very powerful

00:21:00,780 --> 00:21:06,720
tool for IT automation you can use it

00:21:04,860 --> 00:21:09,240
for deploying your code and servers

00:21:06,720 --> 00:21:11,670
manage your infrastructure I was

00:21:09,240 --> 00:21:14,190
recommended to look into it it's

00:21:11,670 --> 00:21:16,500
powerful but inside of it they have a

00:21:14,190 --> 00:21:18,660
very interesting decorator called time

00:21:16,500 --> 00:21:20,940
out now so you can just apply to

00:21:18,660 --> 00:21:23,490
function what it does if the function

00:21:20,940 --> 00:21:26,370
takes longer than well by default 10

00:21:23,490 --> 00:21:29,070
seconds to execute they stop a function

00:21:26,370 --> 00:21:31,770
execution and raise an error how

00:21:29,070 --> 00:21:36,540
demented it so they implemented it using

00:21:31,770 --> 00:21:40,790
a UNIX signals so before the function is

00:21:36,540 --> 00:21:44,730
called this said sig alarm with a

00:21:40,790 --> 00:21:46,620
callback so and then they said the alarm

00:21:44,730 --> 00:21:47,320
to seconds so what happens how does it

00:21:46,620 --> 00:21:53,470
work

00:21:47,320 --> 00:21:57,940
it's a kernel feature of Linux well any

00:21:53,470 --> 00:21:59,710
other POSIX compatible oh yes it will it

00:21:57,940 --> 00:22:04,120
will set this alarm internally and when

00:21:59,710 --> 00:22:05,410
this alarm goes off it will call it will

00:22:04,120 --> 00:22:07,840
call the handler method so and the

00:22:05,410 --> 00:22:10,420
another method will arise timeout error

00:22:07,840 --> 00:22:13,780
and this timeout error will appear

00:22:10,420 --> 00:22:15,430
within a function and it will exit the

00:22:13,780 --> 00:22:17,950
function immediately so it takes longer

00:22:15,430 --> 00:22:21,150
it just stops the function and exits so

00:22:17,950 --> 00:22:24,940
this is a pretty nice way to do a

00:22:21,150 --> 00:22:27,550
function by timeout without using

00:22:24,940 --> 00:22:29,710
threads I'll be asleep and will not work

00:22:27,550 --> 00:22:34,680
on Windows sorry but this is mostly for

00:22:29,710 --> 00:22:41,620
Linux operating systems digging deeper

00:22:34,680 --> 00:22:43,810
so decorators are can be way more

00:22:41,620 --> 00:22:46,690
complex than examples that I showed as

00:22:43,810 --> 00:22:50,050
there was a previous talk today

00:22:46,690 --> 00:22:52,240
unfortunately I missed it but I cover

00:22:50,050 --> 00:22:54,520
the covered I hope maybe someone if you

00:22:52,240 --> 00:22:56,320
were there like in the program they

00:22:54,520 --> 00:22:58,690
wrote that they will cover advanced

00:22:56,320 --> 00:23:00,220
cases of a decorator so in Decorah

00:22:58,690 --> 00:23:02,650
category in decorators you can decorate

00:23:00,220 --> 00:23:05,020
classes and decorate yourself can be a

00:23:02,650 --> 00:23:07,090
class that maintains a state so you can

00:23:05,020 --> 00:23:09,340
create way more complex things but I

00:23:07,090 --> 00:23:12,700
would say in for more most practical

00:23:09,340 --> 00:23:15,310
cases the simple decorators are enough

00:23:12,700 --> 00:23:18,490
but I recommend you to research more

00:23:15,310 --> 00:23:22,240
into this so contacts managers context

00:23:18,490 --> 00:23:26,200
manager this is how well how we call

00:23:22,240 --> 00:23:30,390
with the with statement it is just very

00:23:26,200 --> 00:23:33,840
simple thing is basically it calls enter

00:23:30,390 --> 00:23:36,430
a context manager object and returns a

00:23:33,840 --> 00:23:38,290
value and signs to variable then it

00:23:36,430 --> 00:23:40,690
calls the extra code that is within

00:23:38,290 --> 00:23:43,630
there with statement and finally it

00:23:40,690 --> 00:23:46,120
costs exit so what it what it can be

00:23:43,630 --> 00:23:48,760
good for it's good for if you want

00:23:46,120 --> 00:23:50,880
deterministic release of unmanage

00:23:48,760 --> 00:23:54,010
resources for example files

00:23:50,880 --> 00:23:56,830
everyone must use with with files in

00:23:54,010 --> 00:23:58,350
python because it will close the file

00:23:56,830 --> 00:24:00,590
immediately after you stopped using it

00:23:58,350 --> 00:24:02,539
it's also good to me

00:24:00,590 --> 00:24:05,210
fight some global states for example you

00:24:02,539 --> 00:24:07,520
can select a piece of code that will be

00:24:05,210 --> 00:24:10,460
executed within transactions or you can

00:24:07,520 --> 00:24:12,169
set some setting just for this piece of

00:24:10,460 --> 00:24:14,929
code and then restore the settings and

00:24:12,169 --> 00:24:17,330
it can be used a lot of interesting

00:24:14,929 --> 00:24:21,740
tricks for logging for more advanced

00:24:17,330 --> 00:24:24,350
logging and debugging so a couple of

00:24:21,740 --> 00:24:27,740
examples in Django so they have session

00:24:24,350 --> 00:24:30,710
transaction so on exit exit basically

00:24:27,740 --> 00:24:33,940
they check if the current scope would in

00:24:30,710 --> 00:24:37,309
a transaction if yes then we need to

00:24:33,940 --> 00:24:42,049
commit the transaction or well on error

00:24:37,309 --> 00:24:47,149
rollback so that's that will put it in a

00:24:42,049 --> 00:24:50,240
transaction the important here is that

00:24:47,149 --> 00:24:52,130
finally it's called always so whatever

00:24:50,240 --> 00:24:56,929
there is error in transactions or not it

00:24:52,130 --> 00:24:59,539
will call this the exit method always so

00:24:56,929 --> 00:25:02,240
for example in requests library they

00:24:59,539 --> 00:25:04,730
have a session context manager when you

00:25:02,240 --> 00:25:06,590
exit it it closes the session it's also

00:25:04,730 --> 00:25:09,200
good because you should close it as fast

00:25:06,590 --> 00:25:11,020
as you stopped using it and not when

00:25:09,200 --> 00:25:15,710
garbage collector picks it and close it

00:25:11,020 --> 00:25:18,110
this is a small context manager that I

00:25:15,710 --> 00:25:21,140
wrote for debugging basically when it

00:25:18,110 --> 00:25:23,240
enters it stores internally the time

00:25:21,140 --> 00:25:24,950
when you enter it into a function or not

00:25:23,240 --> 00:25:27,320
function of the piece of code and when

00:25:24,950 --> 00:25:30,770
you exit it just prints the amount of

00:25:27,320 --> 00:25:34,520
milliseconds it took it took to execute

00:25:30,770 --> 00:25:36,980
your piece of code this is very simple

00:25:34,520 --> 00:25:39,820
and very easy to do micro profiling

00:25:36,980 --> 00:25:42,740
small chunks of codes without you know

00:25:39,820 --> 00:25:45,620
doing too much calling profiler and all

00:25:42,740 --> 00:25:48,789
this stuff so digging deeper again I of

00:25:45,620 --> 00:25:52,279
course didn't cover all the usages of

00:25:48,789 --> 00:25:53,480
context managers so Jenga does a lot of

00:25:52,279 --> 00:25:56,720
stuff with the context managers

00:25:53,480 --> 00:26:00,200
especially when cancer transactions they

00:25:56,720 --> 00:26:02,330
also have it's both decorator and

00:26:00,200 --> 00:26:04,880
context manager because it traps some

00:26:02,330 --> 00:26:07,039
piece of code so also you can implement

00:26:04,880 --> 00:26:09,679
with decorators and context mentors you

00:26:07,039 --> 00:26:11,840
can implement database locality so you

00:26:09,679 --> 00:26:13,730
can select for example that say that

00:26:11,840 --> 00:26:13,940
this function or this piece of code the

00:26:13,730 --> 00:26:15,889
pen

00:26:13,940 --> 00:26:18,710
if it's decorator or context manager all

00:26:15,889 --> 00:26:20,720
the queries will be executed against a

00:26:18,710 --> 00:26:22,009
slave database it's for example useful

00:26:20,720 --> 00:26:24,470
for reporting you have a function

00:26:22,009 --> 00:26:27,080
generating report you can create a

00:26:24,470 --> 00:26:29,389
context manager saying okay use slave

00:26:27,080 --> 00:26:31,370
database for all queries in this also

00:26:29,389 --> 00:26:34,190
more sophisticated log and debug not

00:26:31,370 --> 00:26:36,259
just stupid milliseconds which is

00:26:34,190 --> 00:26:38,720
actually where it has very low precision

00:26:36,259 --> 00:26:42,350
and yeah I can do some more

00:26:38,720 --> 00:26:45,230
sophisticated profiling so that's it

00:26:42,350 --> 00:26:47,149
thank you very much this is my email you

00:26:45,230 --> 00:26:50,169
can send me suggestions questions

00:26:47,149 --> 00:26:55,429
whatever I registered that stupid domain

00:26:50,169 --> 00:26:58,190
for my personal blog I'm gonna put the

00:26:55,429 --> 00:27:01,009
slides and there and I started a series

00:26:58,190 --> 00:27:02,690
of posts which basically I covered the

00:27:01,009 --> 00:27:04,100
same stuff but in more details with

00:27:02,690 --> 00:27:07,070
better explanation so if you miss

00:27:04,100 --> 00:27:08,809
something you can come there and yeah

00:27:07,070 --> 00:27:10,850
all the all the content from the slides

00:27:08,809 --> 00:27:13,240
will be there within the blog so thank

00:27:10,850 --> 00:27:13,240
you very much

00:27:18,480 --> 00:27:27,400
do we have a time for questions okay one

00:27:24,070 --> 00:27:30,010
question did your deceit is our cache

00:27:27,400 --> 00:27:31,960
module in the standard library that's

00:27:30,010 --> 00:27:33,160
kind of doing the same thing as one of

00:27:31,960 --> 00:27:36,910
your examples

00:27:33,160 --> 00:27:39,780
it just caches the result code the

00:27:36,910 --> 00:27:43,360
result value for specific parameter sets

00:27:39,780 --> 00:27:43,870
so maybe you can also use that one

00:27:43,360 --> 00:27:46,300
question

00:27:43,870 --> 00:27:51,220
did you already discover a good pattern

00:27:46,300 --> 00:27:55,840
to how to handle open files sorry it's

00:27:51,220 --> 00:27:58,300
covered what to handle open files if the

00:27:55,840 --> 00:28:00,730
context is not as localized and

00:27:58,300 --> 00:28:04,110
sometimes with with so you basically

00:28:00,730 --> 00:28:06,850
need to give around open file handle and

00:28:04,110 --> 00:28:08,710
still you need to make sure that it is

00:28:06,850 --> 00:28:17,320
closed at some time is there a good time

00:28:08,710 --> 00:28:18,670
for that well yeah well with the context

00:28:17,320 --> 00:28:21,160
well answering the first question yes

00:28:18,670 --> 00:28:23,230
there is there is a lot of this caching

00:28:21,160 --> 00:28:25,390
there are a lot of caring done with the

00:28:23,230 --> 00:28:27,250
decrease in very different libraries but

00:28:25,390 --> 00:28:29,680
I recommend to check out that well

00:28:27,250 --> 00:28:32,070
because as I said it's the most advanced

00:28:29,680 --> 00:28:35,710
one it has the richest functionality

00:28:32,070 --> 00:28:38,260
coming to the next one well if you want

00:28:35,710 --> 00:28:40,900
to use file in different place well then

00:28:38,260 --> 00:28:42,910
it's a little bit it gets a little bit

00:28:40,900 --> 00:28:45,670
more complicated then yeah you will you

00:28:42,910 --> 00:28:47,830
can't use a well context mentors are

00:28:45,670 --> 00:28:48,460
good for small chunks of code so if you

00:28:47,830 --> 00:28:52,180
have UN's

00:28:48,460 --> 00:28:55,360
but yeah you can write your own class

00:28:52,180 --> 00:28:58,900
that will store a file handler and once

00:28:55,360 --> 00:29:01,060
this and you can call closed on your own

00:28:58,900 --> 00:29:03,130
class when you finish dealing with this

00:29:01,060 --> 00:29:07,120
I wouldn't as far as I know there is no

00:29:03,130 --> 00:29:09,870
like straightforward thing to do it with

00:29:07,120 --> 00:29:09,870
the context managers

00:29:17,710 --> 00:29:26,920
sorry is it going to crap yeah this is

00:29:22,770 --> 00:29:28,810
your right this is a tricky part yes

00:29:26,920 --> 00:29:30,010
decorator's the order of decorators

00:29:28,810 --> 00:29:32,800
effect effects it

00:29:30,010 --> 00:29:35,710
so some decorators for some decorates

00:29:32,800 --> 00:29:39,960
it's important the order is important in

00:29:35,710 --> 00:29:44,260
which you do it but for some it's not so

00:29:39,960 --> 00:29:45,700
yeah order matters in general case in

00:29:44,260 --> 00:29:48,100
more specific so you can write the

00:29:45,700 --> 00:29:53,560
decorators that for example I will can

00:29:48,100 --> 00:29:55,900
give you specific wonderful

00:29:53,560 --> 00:29:58,600
so here it's important a property should

00:29:55,900 --> 00:30:00,520
come before a cache result otherwise if

00:29:58,600 --> 00:30:02,110
you do it the other way it won't work it

00:30:00,520 --> 00:30:04,780
just won't work proper properly but

00:30:02,110 --> 00:30:08,200
because the property is a special it's a

00:30:04,780 --> 00:30:09,670
built-in decorator yeah but you can for

00:30:08,200 --> 00:30:13,090
simple decorator you can write the logic

00:30:09,670 --> 00:30:15,340
in the way that it wouldn't matter so it

00:30:13,090 --> 00:30:22,210
really depends yeah particularly

00:30:15,340 --> 00:30:24,370
decorators I think it actually no it's

00:30:22,210 --> 00:30:26,620
actually first it will call cache result

00:30:24,370 --> 00:30:28,570
decorator and the only then it will call

00:30:26,620 --> 00:30:30,340
property so that's why it's important

00:30:28,570 --> 00:30:33,040
that property will be like outermost

00:30:30,340 --> 00:30:40,200
yeah yeah this is a tricky this is

00:30:33,040 --> 00:30:40,200
tricky part in other questions

00:30:42,179 --> 00:30:45,679
you still have a few minutes

00:30:51,190 --> 00:30:58,340
hello thank for the talk just one

00:30:54,740 --> 00:31:01,370
observation about the rap decorator that

00:30:58,340 --> 00:31:04,370
the standard library offers so I saw

00:31:01,370 --> 00:31:06,260
that in one example that's present and

00:31:04,370 --> 00:31:08,269
in the others when you are writing a

00:31:06,260 --> 00:31:12,320
wrapper function you are not using that

00:31:08,269 --> 00:31:15,200
so I think it's worth mentioning that it

00:31:12,320 --> 00:31:17,960
is better to use because it copies the

00:31:15,200 --> 00:31:19,820
duck string and functions naming those

00:31:17,960 --> 00:31:21,460
things yeah you're absolutely right

00:31:19,820 --> 00:31:23,840
you're absolutely right

00:31:21,460 --> 00:31:28,399
practically you should use yeah reps

00:31:23,840 --> 00:31:29,840
from funky tools mojo that's absolutely

00:31:28,399 --> 00:31:32,899
right because it will keep the function

00:31:29,840 --> 00:31:35,240
name and doc string and all the stuff

00:31:32,899 --> 00:31:38,860
yeah but it was just like too much for

00:31:35,240 --> 00:31:38,860
the talk but you're right thanks for not

00:31:42,429 --> 00:31:48,340
questions comments

00:31:44,330 --> 00:31:48,340

YouTube URL: https://www.youtube.com/watch?v=UNr49W08vnc


