Title: LinuxFest - JSON Web Tokens Will Improve Your Life
Publication date: 2017-10-18
Playlist: 2017 Videos
Description: 
	This talk is part of the Ohio LinuxFest development track. It was held in Franklin C at 3PM. The speaker is John Anderson.
Captions: 
	00:00:00,000 --> 00:00:03,000
purple shirt in the back but I asked you

00:00:01,500 --> 00:00:05,190
to close like at least one of those

00:00:03,000 --> 00:00:07,350
doors that we don't have as much always

00:00:05,190 --> 00:00:09,750
track - thank you

00:00:07,350 --> 00:00:12,030
welcome to JSON web tokens will improve

00:00:09,750 --> 00:00:15,199
your life I'm John

00:00:12,030 --> 00:00:18,060
I go by Gene Hackman aces online Twitter

00:00:15,199 --> 00:00:20,430
get up so if you want to tweet about

00:00:18,060 --> 00:00:24,180
this talk and how bad it is be sure to

00:00:20,430 --> 00:00:25,769
tag me so I get the feedback in fact a

00:00:24,180 --> 00:00:28,170
job I am the vice president for

00:00:25,769 --> 00:00:30,960
technology at a small custom software

00:00:28,170 --> 00:00:33,840
development tech consultancy training

00:00:30,960 --> 00:00:37,020
shop called affinity interactive we're

00:00:33,840 --> 00:00:39,480
on Barrett by interactive and this is my

00:00:37,020 --> 00:00:43,800
dog Sammy Sammy plays an important role

00:00:39,480 --> 00:00:48,300
in this talk she's on Twitter - at Sammy

00:00:43,800 --> 00:00:51,780
came back so I got promoted into this VP

00:00:48,300 --> 00:00:54,120
of Technology go now instead of like

00:00:51,780 --> 00:00:58,859
writing code and doing cool stuff I like

00:00:54,120 --> 00:01:01,559
they go to meetings in the wiki so I

00:00:58,859 --> 00:01:03,449
don't do that much code anymore but when

00:01:01,559 --> 00:01:05,400
I do end up with a coding project Sammy

00:01:03,449 --> 00:01:07,920
is kind of my pair of programmer helper

00:01:05,400 --> 00:01:10,950
from underneath my desk which is workers

00:01:07,920 --> 00:01:13,320
bed is right there right so what's it

00:01:10,950 --> 00:01:15,659
what's a GWT or Jason web token are in

00:01:13,320 --> 00:01:18,960
John who's heard of these before this

00:01:15,659 --> 00:01:21,840
top five or six people all right so

00:01:18,960 --> 00:01:22,650
anybody using them what are you people

00:01:21,840 --> 00:01:24,330
awesome

00:01:22,650 --> 00:01:26,820
so if you wanted to find out what a

00:01:24,330 --> 00:01:29,630
jason web token was you might plug that

00:01:26,820 --> 00:01:32,100
into your favorite search engine

00:01:29,630 --> 00:01:35,220
whatever and you would probably end up

00:01:32,100 --> 00:01:37,650
in a website called jout IO which is a

00:01:35,220 --> 00:01:39,500
site that's set up by the people who

00:01:37,650 --> 00:01:42,720
invented these and there you would learn

00:01:39,500 --> 00:01:45,810
right here that jason web tokens are an

00:01:42,720 --> 00:01:47,549
open industry standard RC 7519 method

00:01:45,810 --> 00:01:53,250
for representing claims securely between

00:01:47,549 --> 00:01:55,049
two parties and you might come away from

00:01:53,250 --> 00:01:59,880
that description a little bit mystified

00:01:55,049 --> 00:02:08,429
like Sammy was Sammy suffers from a

00:01:59,880 --> 00:02:10,319
horrible condition known as resting so

00:02:08,429 --> 00:02:11,870
you might at this point go well I need

00:02:10,319 --> 00:02:13,830
to figure this out and they said IRC

00:02:11,870 --> 00:02:17,820
7519 and so you might go

00:02:13,830 --> 00:02:20,220
RFC 7519 try to read it which I have

00:02:17,820 --> 00:02:22,820
done which is how I know that the

00:02:20,220 --> 00:02:25,200
official pronunciation of JWT is jot

00:02:22,820 --> 00:02:27,420
because that happens to be spelled out

00:02:25,200 --> 00:02:31,230
in RFC ii i can see that the way you

00:02:27,420 --> 00:02:33,480
pronounce GWT is ja it's a very

00:02:31,230 --> 00:02:34,920
confusing read the first time you read

00:02:33,480 --> 00:02:37,410
it because there are a bunch of acronyms

00:02:34,920 --> 00:02:41,160
that aren't actually defined in this RFC

00:02:37,410 --> 00:02:43,620
and reading RFC's in general is sort of

00:02:41,160 --> 00:02:45,420
a art I mean you often know the

00:02:43,620 --> 00:02:47,190
specialized vocabulary and the way they

00:02:45,420 --> 00:02:49,290
use words like can and should it must

00:02:47,190 --> 00:02:51,240
but this one was a little bit more

00:02:49,290 --> 00:02:53,970
opaque normal and it turns out that

00:02:51,240 --> 00:02:57,090
that's because it's not actually 1rc

00:02:53,970 --> 00:03:00,780
you really need to read all six of these

00:02:57,090 --> 00:03:02,670
so fully understand the nature of JSON

00:03:00,780 --> 00:03:04,110
web tokens so we have Jason web

00:03:02,670 --> 00:03:06,780
signature is Jason about encryption

00:03:04,110 --> 00:03:08,459
Jason what key is Jason about algorithms

00:03:06,780 --> 00:03:10,410
Jason web tokens and my personal

00:03:08,459 --> 00:03:12,270
favorite examples of protecting content

00:03:10,410 --> 00:03:15,110
using JSON objects signing an encryption

00:03:12,270 --> 00:03:15,110
Jose

00:03:15,590 --> 00:03:20,880
it's a lot rfcs

00:03:18,140 --> 00:03:23,010
Sammy was not too impressed with the RFC

00:03:20,880 --> 00:03:27,209
issues not they'll pick up theory or

00:03:23,010 --> 00:03:30,510
reading so having read most of these a

00:03:27,209 --> 00:03:31,830
few times I can tell you that you can

00:03:30,510 --> 00:03:34,880
think of JSON web tokens as a

00:03:31,830 --> 00:03:37,380
lightweight alternative kinda-sorta

00:03:34,880 --> 00:03:39,420
that will also work with command line

00:03:37,380 --> 00:03:41,070
apps or mobile apps and desktop apps

00:03:39,420 --> 00:03:43,980
they don't have to be specific to the

00:03:41,070 --> 00:03:46,080
web the function is an authorization or

00:03:43,980 --> 00:03:48,300
an access control mechanism unless the

00:03:46,080 --> 00:03:50,970
same way olaf does but you can use them

00:03:48,300 --> 00:03:52,560
without losing your locomotive of like

00:03:50,970 --> 00:03:54,930
happens if you have to implement OAuth

00:03:52,560 --> 00:03:56,700
and there also across the main friendly

00:03:54,930 --> 00:03:59,730
so you can have a JSON web token to be

00:03:56,700 --> 00:04:01,650
issued by one host and then give it to a

00:03:59,730 --> 00:04:04,019
second host and those host kids rather

00:04:01,650 --> 00:04:05,780
depend on that JSON watch over and we'll

00:04:04,019 --> 00:04:08,400
see how that works

00:04:05,780 --> 00:04:10,739
Jason web tokens are composed of stuff

00:04:08,400 --> 00:04:13,950
you probably already are familiar with

00:04:10,739 --> 00:04:16,680
it use so they're just plain old Jason

00:04:13,950 --> 00:04:18,299
objects or pojos if you've done any kind

00:04:16,680 --> 00:04:21,209
of JavaScript programming you've seen it

00:04:18,299 --> 00:04:22,919
that jason object there stringify

00:04:21,209 --> 00:04:26,160
decoding and cryptographically signed

00:04:22,919 --> 00:04:27,570
and then usually transmitted or HTTP or

00:04:26,160 --> 00:04:30,360
https but they don't

00:04:27,570 --> 00:04:32,280
the specification is actually completely

00:04:30,360 --> 00:04:35,060
agnostic as to how you transmit these

00:04:32,280 --> 00:04:37,290
things around what do they look like

00:04:35,060 --> 00:04:39,600
they're a simple dot the limited

00:04:37,290 --> 00:04:42,030
strength that has three parts there's a

00:04:39,600 --> 00:04:43,290
header a payload and a signature and

00:04:42,030 --> 00:04:44,940
we're going to break down each one of

00:04:43,290 --> 00:04:47,010
those parts in turn but basically they

00:04:44,940 --> 00:04:49,020
just look like this the X and x axis the

00:04:47,010 --> 00:04:51,480
header the yyy is the payload and the

00:04:49,020 --> 00:04:55,260
CCC is the signature just three parts

00:04:51,480 --> 00:04:56,790
separated by dots so we look break those

00:04:55,260 --> 00:04:59,310
down and look at them in more detail the

00:04:56,790 --> 00:05:02,340
header again it's just a plain old JSON

00:04:59,310 --> 00:05:05,250
object that then gets base64 encoded

00:05:02,340 --> 00:05:07,710
stringify than a 64 encoded and the

00:05:05,250 --> 00:05:10,140
header typically contains metadata here

00:05:07,710 --> 00:05:12,150
is a key of algae that's the algorithm

00:05:10,140 --> 00:05:13,860
that's going to be used for signing the

00:05:12,150 --> 00:05:17,310
JSON web token in this case it's age

00:05:13,860 --> 00:05:19,380
match sha-256 and then the type of token

00:05:17,310 --> 00:05:20,790
this adjacent web token there are

00:05:19,380 --> 00:05:21,960
different types I'm not going to talk

00:05:20,790 --> 00:05:23,790
about them too much but you want to

00:05:21,960 --> 00:05:26,700
specify what the type of your key of

00:05:23,790 --> 00:05:28,770
your token is in there and the other

00:05:26,700 --> 00:05:30,270
payload this is the part you're actually

00:05:28,770 --> 00:05:32,580
interested in the data that you're

00:05:30,270 --> 00:05:35,100
putting in the token it's another of a64

00:05:32,580 --> 00:05:37,350
stratified pojo and it contains what the

00:05:35,100 --> 00:05:39,530
specification calls claims which is

00:05:37,350 --> 00:05:43,620
fancy security talk for key value pairs

00:05:39,530 --> 00:05:45,840
right so it's just a JSON web object and

00:05:43,620 --> 00:05:47,430
there are three types of keys that you

00:05:45,840 --> 00:05:49,230
can use in the payload there are

00:05:47,430 --> 00:05:51,600
reserved keys public keys and private

00:05:49,230 --> 00:05:53,160
keys reserved keys are certain ones that

00:05:51,600 --> 00:05:55,440
are spelled out in this packet or

00:05:53,160 --> 00:05:58,560
reserved for the use of the spec such as

00:05:55,440 --> 00:06:02,540
this would I 80 that's for an epic

00:05:58,560 --> 00:06:04,920
timestamp of when this token was issued

00:06:02,540 --> 00:06:07,140
public keys I don't have a good example

00:06:04,920 --> 00:06:08,640
of because the specification allows for

00:06:07,140 --> 00:06:10,140
a public key which would be something

00:06:08,640 --> 00:06:13,740
that you would get published through an

00:06:10,140 --> 00:06:15,450
ia in a specification for so sort of

00:06:13,740 --> 00:06:17,220
JSON web token you're using an large

00:06:15,450 --> 00:06:19,380
public service when you want to reserve

00:06:17,220 --> 00:06:21,780
that heat for your use and then you have

00:06:19,380 --> 00:06:23,940
public or sorry private keys which are

00:06:21,780 --> 00:06:25,200
just the ones you make up and use within

00:06:23,940 --> 00:06:28,130
your application you know if you're

00:06:25,200 --> 00:06:30,630
registered them and here we have name

00:06:28,130 --> 00:06:32,790
admin and false those are both private

00:06:30,630 --> 00:06:34,560
keys that we just made up want to stick

00:06:32,790 --> 00:06:37,050
in this data structure and do something

00:06:34,560 --> 00:06:39,510
well and then finally we have the

00:06:37,050 --> 00:06:41,100
signature which is composed of the

00:06:39,510 --> 00:06:43,830
encoded header potion

00:06:41,100 --> 00:06:46,380
plus the encoded payload Kojo plus a

00:06:43,830 --> 00:06:49,580
secret Plus that signing algorithm that

00:06:46,380 --> 00:06:49,580
we had in the algorithm

00:06:50,420 --> 00:06:55,410
so a quick digression about my code

00:06:53,580 --> 00:07:00,150
samples so I might be showing a lot at

00:06:55,410 --> 00:07:02,220
this time maybe too much code because I

00:07:00,150 --> 00:07:04,710
really wanted to try it home how simple

00:07:02,220 --> 00:07:07,290
and elegant these are to use and how

00:07:04,710 --> 00:07:09,360
easy they are to use and showing you how

00:07:07,290 --> 00:07:12,360
they work on code level is the easiest

00:07:09,360 --> 00:07:14,100
way to do that in real practice for most

00:07:12,360 --> 00:07:15,510
of the code that I'm showing you would

00:07:14,100 --> 00:07:17,280
never write this code there are

00:07:15,510 --> 00:07:18,720
libraries that are exist for this that

00:07:17,280 --> 00:07:20,340
are maintained by people who know what

00:07:18,720 --> 00:07:22,620
they are actually doing and so you

00:07:20,340 --> 00:07:26,370
shouldn't use my code to generate vision

00:07:22,620 --> 00:07:27,510
web tokens for each code sample that I

00:07:26,370 --> 00:07:30,030
show I'm going to show you the whole

00:07:27,510 --> 00:07:32,100
thing all at once I don't expect you to

00:07:30,030 --> 00:07:34,680
read it the point is just how few minds

00:07:32,100 --> 00:07:36,270
there are but still 20 lines of code on

00:07:34,680 --> 00:07:37,710
a slide you won't be able to read

00:07:36,270 --> 00:07:41,640
I'll go through and break it down into

00:07:37,710 --> 00:07:43,620
chunks and then finally in a few cases

00:07:41,640 --> 00:07:45,570
that I'm not going to necessarily point

00:07:43,620 --> 00:07:47,520
out some error checking code or other

00:07:45,570 --> 00:07:50,250
stuff that you would want in real code

00:07:47,520 --> 00:07:51,990
has been removed from my code to make it

00:07:50,250 --> 00:07:54,630
easier to present so don't do the

00:07:51,990 --> 00:07:57,480
planning copy and paste this and try to

00:07:54,630 --> 00:08:00,900
use it please or if you do I'm not

00:07:57,480 --> 00:08:03,360
responsible so this is code in

00:08:00,900 --> 00:08:05,460
JavaScript to make a JSON web token and

00:08:03,360 --> 00:08:07,440
again the point here is not for you to

00:08:05,460 --> 00:08:10,440
read this but just a look and see that's

00:08:07,440 --> 00:08:12,330
not that much code that's a very small

00:08:10,440 --> 00:08:15,210
amount of code so if we step through

00:08:12,330 --> 00:08:17,340
this and break it down we start off with

00:08:15,210 --> 00:08:20,610
the helper function that's going to take

00:08:17,340 --> 00:08:22,490
a job at Jason object and base64

00:08:20,610 --> 00:08:25,650
encoding so we're going to stringify it

00:08:22,490 --> 00:08:27,960
make a buffer and turn that bugger the

00:08:25,650 --> 00:08:30,900
basics before then return write some

00:08:27,960 --> 00:08:33,020
simple helper function just convert that

00:08:30,900 --> 00:08:35,310
JSON object in the base64

00:08:33,020 --> 00:08:37,349
we have a second helper function to

00:08:35,310 --> 00:08:39,599
generate an h-back signature which takes

00:08:37,349 --> 00:08:43,680
a string and a secret and then it

00:08:39,599 --> 00:08:46,080
creates an H map using the sha-256

00:08:43,680 --> 00:08:48,240
algorithm with the secret sticks to

00:08:46,080 --> 00:08:52,710
string into it and it generates a head

00:08:48,240 --> 00:08:54,740
signature and returns it again not to

00:08:52,710 --> 00:08:56,480
mark the actual

00:08:54,740 --> 00:08:57,980
and this is the two bits from the

00:08:56,480 --> 00:08:59,570
previous slides you've got the headers

00:08:57,980 --> 00:09:02,420
that's playing the algorithm and the

00:08:59,570 --> 00:09:05,480
type of token and the payload with the

00:09:02,420 --> 00:09:07,850
name of that and I eat eat patters in no

00:09:05,480 --> 00:09:09,770
practice of course we want to get the

00:09:07,850 --> 00:09:11,990
current timestamp through the IAT header

00:09:09,770 --> 00:09:15,650
or not heard about a particular value

00:09:11,990 --> 00:09:17,810
and then we have a secret now we're

00:09:15,650 --> 00:09:19,490
going to put those all together generate

00:09:17,810 --> 00:09:21,620
the signature we're going to make the

00:09:19,490 --> 00:09:25,940
encoded header like base64 encoding the

00:09:21,620 --> 00:09:27,170
header encoding halo-halo and then we're

00:09:25,940 --> 00:09:29,330
going to generate the signature using

00:09:27,170 --> 00:09:31,940
that age maket function and the

00:09:29,330 --> 00:09:34,130
signature is just the header dot the

00:09:31,940 --> 00:09:36,260
payload and the secret that's used to

00:09:34,130 --> 00:09:38,720
generate the signature now we have a

00:09:36,260 --> 00:09:40,100
header a payload at the signature and we

00:09:38,720 --> 00:09:42,620
just can catenate this together with

00:09:40,100 --> 00:09:45,890
dots and that's it that's a completely

00:09:42,620 --> 00:09:47,510
valid JSON web token if you take that

00:09:45,890 --> 00:09:49,040
jason web token and do a little

00:09:47,510 --> 00:09:51,590
JavaScript manage to put in one breaks

00:09:49,040 --> 00:09:53,960
it looks like that and that's the actual

00:09:51,590 --> 00:09:58,040
like I literally just grab that code to

00:09:53,960 --> 00:09:59,540
make this slide that's what that's what

00:09:58,040 --> 00:10:02,240
one looks like that's the header that's

00:09:59,540 --> 00:10:04,130
the payload and that's the signature now

00:10:02,240 --> 00:10:06,290
the critical bit of all of this and the

00:10:04,130 --> 00:10:08,480
reason for doing it the way you're doing

00:10:06,290 --> 00:10:10,190
it and the cool thing about these is I

00:10:08,480 --> 00:10:13,640
didn't take that Jason left opened I

00:10:10,190 --> 00:10:15,470
generated I can give it to you and I can

00:10:13,640 --> 00:10:18,830
require that you give it that to me

00:10:15,470 --> 00:10:20,510
later and I can tell you haven't messed

00:10:18,830 --> 00:10:23,560
with the contents of it because if you

00:10:20,510 --> 00:10:26,690
have the signature will be valid anymore

00:10:23,560 --> 00:10:28,400
right so I can give this to somebody as

00:10:26,690 --> 00:10:30,140
part of what transactions require them

00:10:28,400 --> 00:10:32,210
to give it back to me when they want

00:10:30,140 --> 00:10:34,100
something from me I didn't check the

00:10:32,210 --> 00:10:36,110
claims that are in it and be sure that

00:10:34,100 --> 00:10:39,020
they're actually the Queen's that I put

00:10:36,110 --> 00:10:43,370
in there and that all depends on the

00:10:39,020 --> 00:10:46,670
stage so I kind of put the whole fun of

00:10:43,370 --> 00:10:50,240
the jason the demi TDI of site earlier

00:10:46,670 --> 00:10:51,890
but there is some useful stuff at GWT do

00:10:50,240 --> 00:10:53,570
one of these whole things that you

00:10:51,890 --> 00:10:55,700
probably can't read in that slide is

00:10:53,570 --> 00:10:57,500
where this red circle is it says the

00:10:55,700 --> 00:10:59,900
butter there and they have this

00:10:57,500 --> 00:11:01,610
web-based butter for Jason much opens

00:10:59,900 --> 00:11:04,370
where you could go and paste in your

00:11:01,610 --> 00:11:05,750
JSON web token and this is the same

00:11:04,370 --> 00:11:08,380
Jason what token that was on the

00:11:05,750 --> 00:11:08,380
previous slide

00:11:09,449 --> 00:11:14,439
but trust me it's the same one and it

00:11:12,069 --> 00:11:16,300
hopefully color codes the header and the

00:11:14,439 --> 00:11:18,519
payload and signature and then you can

00:11:16,300 --> 00:11:20,439
see over here there's the decoded better

00:11:18,519 --> 00:11:25,839
that's exactly what we put in and

00:11:20,439 --> 00:11:27,369
there's the decoded so this is really

00:11:25,839 --> 00:11:28,480
helpful when you're using JSON web

00:11:27,369 --> 00:11:29,740
tokens when you're trying to get

00:11:28,480 --> 00:11:32,309
something to work and it can't quite

00:11:29,740 --> 00:11:34,540
work plug this in and make sure that

00:11:32,309 --> 00:11:37,720
what skin in there is actually what you

00:11:34,540 --> 00:11:40,600
think you put in there the other really

00:11:37,720 --> 00:11:43,509
useful thing on the GW VI of site and

00:11:40,600 --> 00:11:45,639
get the word inside that bed circle but

00:11:43,509 --> 00:11:47,920
it says libraries in there they have a

00:11:45,639 --> 00:11:49,839
list of every JSON web token

00:11:47,920 --> 00:11:51,220
implementation for every language that

00:11:49,839 --> 00:11:54,879
they've been able to track

00:11:51,220 --> 00:11:57,639
so there are JT libraries for dotnet

00:11:54,879 --> 00:11:59,740
Python no Java JavaScript Ruby go Perl

00:11:57,639 --> 00:12:02,499
PHP Haskell Russ Lewis column for

00:11:59,740 --> 00:12:06,100
objective-c Swift and Delphi you make

00:12:02,499 --> 00:12:08,800
using Delphi right anybody know who we

00:12:06,100 --> 00:12:14,829
don't think with Delphi was like half

00:12:08,800 --> 00:12:16,689
the crowd so supportive just general

00:12:14,829 --> 00:12:18,339
rule of thumb if an open-source project

00:12:16,689 --> 00:12:20,170
has support for Delphi they probably

00:12:18,339 --> 00:12:26,410
have support for whatever did you care

00:12:20,170 --> 00:12:29,709
about all right start at this point

00:12:26,410 --> 00:12:31,869
Sammy Kirk back up will pass the RFC

00:12:29,709 --> 00:12:35,319
reading stage we've seen kinda how

00:12:31,869 --> 00:12:36,999
simple and elegant the JWT spec is and

00:12:35,319 --> 00:12:39,519
how easy it is to make adjacent web

00:12:36,999 --> 00:12:41,619
token so she started asking like how do

00:12:39,519 --> 00:12:44,740
I actually use these in my application

00:12:41,619 --> 00:12:46,740
and one thing you can do with the JSON

00:12:44,740 --> 00:12:50,110
web token is sort of a basic

00:12:46,740 --> 00:12:53,019
authentication authorization I flow much

00:12:50,110 --> 00:12:56,410
like a cookie only slightly different so

00:12:53,019 --> 00:12:58,119
I saw this image from the GPIO site you

00:12:56,410 --> 00:13:01,360
normally you have a client-server kind

00:12:58,119 --> 00:13:03,490
of thing here the client comes in and

00:13:01,360 --> 00:13:05,170
hits Anna fit occasion endpoint / the

00:13:03,490 --> 00:13:06,730
law together or whatever gives a

00:13:05,170 --> 00:13:09,069
username and password the server

00:13:06,730 --> 00:13:11,649
validates that and then generates and

00:13:09,069 --> 00:13:13,119
send back a JSON web token and now

00:13:11,649 --> 00:13:14,949
whenever the client wants to do

00:13:13,119 --> 00:13:17,350
something with the API it sends that

00:13:14,949 --> 00:13:19,590
jason web token back in but it's request

00:13:17,350 --> 00:13:22,020
unless the same way that a cookie

00:13:19,590 --> 00:13:23,790
but not quite as automatically and then

00:13:22,020 --> 00:13:25,770
the server can validate the signature on

00:13:23,790 --> 00:13:27,480
the token it strap the information back

00:13:25,770 --> 00:13:29,600
out of it use that to generate the

00:13:27,480 --> 00:13:32,070
response and send the response to that

00:13:29,600 --> 00:13:35,610
fairly standard workloads you're using

00:13:32,070 --> 00:13:37,550
JSON web tokens instead of cookies there

00:13:35,610 --> 00:13:39,600
are other ways to use it will see later

00:13:37,550 --> 00:13:42,960
because the specification is

00:13:39,600 --> 00:13:52,470
intentionally very flexible and agnostic

00:13:42,960 --> 00:13:54,030
on how you yeah they're getting

00:13:52,470 --> 00:13:55,740
protection for man-in-the-middle attacks

00:13:54,030 --> 00:13:57,750
thank you for the transition so things

00:13:55,740 --> 00:14:01,020
that you should be aware of the header

00:13:57,750 --> 00:14:04,020
and the payload are not encrypted right

00:14:01,020 --> 00:14:06,210
there just base64 encoded anybody can

00:14:04,020 --> 00:14:09,300
base64 to decode that and get back

00:14:06,210 --> 00:14:11,730
whatever you put in there right so just

00:14:09,300 --> 00:14:13,680
like a cookie where somebody can read

00:14:11,730 --> 00:14:15,330
the contents of the cookie don't put

00:14:13,680 --> 00:14:17,490
somebody's social security number in one

00:14:15,330 --> 00:14:20,400
of these right that's a bad idea

00:14:17,490 --> 00:14:23,100
but it's perfectly fine to put like the

00:14:20,400 --> 00:14:25,710
row ID of the database table where you

00:14:23,100 --> 00:14:27,240
store their actual information so that

00:14:25,710 --> 00:14:29,250
then when you get it back you can get

00:14:27,240 --> 00:14:30,950
that idea pull that right out do your

00:14:29,250 --> 00:14:34,950
business

00:14:30,950 --> 00:14:37,590
you do need to control expiration and

00:14:34,950 --> 00:14:39,540
reissue yourself that's why there's that

00:14:37,590 --> 00:14:41,820
issues that issue that header in each

00:14:39,540 --> 00:14:45,600
jason mojo can generate for real will

00:14:41,820 --> 00:14:48,840
also have a key in it called ESP which

00:14:45,600 --> 00:14:51,090
is the timestamp for when it expires and

00:14:48,840 --> 00:14:53,280
you need to have a method within your

00:14:51,090 --> 00:14:54,840
api or whatever if somebody has a token

00:14:53,280 --> 00:14:56,640
that's about to expire they need to have

00:14:54,840 --> 00:15:00,560
a way where they can use that to get a

00:14:56,640 --> 00:15:00,560
new fresh go again with a long flight

00:15:07,850 --> 00:15:11,540
right what kind of expiration time

00:15:09,950 --> 00:15:14,770
should you have and the answer to that

00:15:11,540 --> 00:15:17,120
is going to depend on your application I

00:15:14,770 --> 00:15:17,690
don't think there's a hard best we'll

00:15:17,120 --> 00:15:21,440
see later

00:15:17,690 --> 00:15:23,570
one of the kind of let me come back to

00:15:21,440 --> 00:15:28,070
that it is a big question it is

00:15:23,570 --> 00:15:30,080
immediately so so many pies I've seen

00:15:28,070 --> 00:15:32,420
will actually send back a fresh

00:15:30,080 --> 00:15:34,850
different JSON web token with every

00:15:32,420 --> 00:15:37,040
response so you get a token what you

00:15:34,850 --> 00:15:38,450
login but then on the next response you

00:15:37,040 --> 00:15:40,040
get there's a different token and they

00:15:38,450 --> 00:15:42,890
expect you to cycle that token on the

00:15:40,040 --> 00:15:44,990
client-side I think that's a little bit

00:15:42,890 --> 00:15:47,360
of overkill but again it depends on your

00:15:44,990 --> 00:15:49,700
specific application and the other thing

00:15:47,360 --> 00:15:50,360
to be aware of is that there's no sort

00:15:49,700 --> 00:15:53,540
of

00:15:50,360 --> 00:15:55,130
unlike cookies there's no control for

00:15:53,540 --> 00:15:57,410
what you do with this JSON web token on

00:15:55,130 --> 00:15:59,840
the client-side site egg and give you a

00:15:57,410 --> 00:16:02,810
JSON web token and you can give that to

00:15:59,840 --> 00:16:04,820
him back to site B and as long as site a

00:16:02,810 --> 00:16:07,190
and B have shared the secret that was

00:16:04,820 --> 00:16:09,460
used for the signature site B and

00:16:07,190 --> 00:16:11,480
validated token the magician by sighted

00:16:09,460 --> 00:16:13,850
you this is nice

00:16:11,480 --> 00:16:15,260
you do need to share that secret but you

00:16:13,850 --> 00:16:19,390
can do sort of single sign-on

00:16:15,260 --> 00:16:19,390
cross-domain style stuff

00:16:20,080 --> 00:16:25,280
all right so how do you actually throw

00:16:22,340 --> 00:16:27,860
these tokens around it's up to you for

00:16:25,280 --> 00:16:29,960
web programming there are various things

00:16:27,860 --> 00:16:31,760
you can do you can just see realize that

00:16:29,960 --> 00:16:33,920
token out and put it in and get requests

00:16:31,760 --> 00:16:36,380
will see an example of that a little bit

00:16:33,920 --> 00:16:39,260
you could put it in the post body the

00:16:36,380 --> 00:16:41,390
parameter or something that we feel a

00:16:39,260 --> 00:16:43,160
lot is there is an authorization header

00:16:41,390 --> 00:16:45,020
that's a part of the HTTP spec that's

00:16:43,160 --> 00:16:46,970
used for basic auth that supports

00:16:45,020 --> 00:16:49,070
various other schemes one of which is

00:16:46,970 --> 00:16:50,030
called a bearer scheme so you put in a

00:16:49,070 --> 00:16:52,760
header that looks like this

00:16:50,030 --> 00:16:55,280
authorization colon bearer and then the

00:16:52,760 --> 00:16:59,660
token and that just gets transmitted as

00:16:55,280 --> 00:17:01,850
part of the HTTP request right so

00:16:59,660 --> 00:17:03,620
Sammy's impatient with theory she wants

00:17:01,850 --> 00:17:05,089
to see some actual implementation code

00:17:03,620 --> 00:17:07,790
so how would you actually use this

00:17:05,089 --> 00:17:11,470
whether it really look like so here's

00:17:07,790 --> 00:17:14,780
some node code for generating a token

00:17:11,470 --> 00:17:17,839
basically implementing authentication so

00:17:14,780 --> 00:17:19,230
again that's not a whole lot of code so

00:17:17,839 --> 00:17:21,990
let's step through that

00:17:19,230 --> 00:17:23,669
so generating at Okanagan this is an

00:17:21,990 --> 00:17:25,589
Express app so the first thing we're

00:17:23,669 --> 00:17:27,839
going to do is declare a route this is

00:17:25,589 --> 00:17:30,779
how you declare about in Express you say

00:17:27,839 --> 00:17:33,240
slash user slash login it's going to go

00:17:30,779 --> 00:17:34,649
to this user login function and then

00:17:33,240 --> 00:17:36,990
we're going to load a helper library

00:17:34,649 --> 00:17:39,240
called JWT this is something we use

00:17:36,990 --> 00:17:43,880
internally as a wrapper that we wrote

00:17:39,240 --> 00:17:43,880
around the module called JSON web token

00:17:45,350 --> 00:17:50,429
we put a helper wrapper around it so

00:17:48,240 --> 00:17:53,130
that we can hurt code some things like

00:17:50,429 --> 00:17:54,840
which algorithm we're using and the way

00:17:53,130 --> 00:17:56,940
we're doing secret management so we

00:17:54,840 --> 00:17:58,980
don't have the secret stream all around

00:17:56,940 --> 00:18:01,710
our code base and localized in one spot

00:17:58,980 --> 00:18:04,440
so that's also a pattern and I click on

00:18:01,710 --> 00:18:08,010
that and then we have the user login

00:18:04,440 --> 00:18:10,260
function so the way express routes work

00:18:08,010 --> 00:18:11,880
is you get past the request object that

00:18:10,260 --> 00:18:13,649
you can pass their response object that

00:18:11,880 --> 00:18:14,220
you're expected to fill out it's fairly

00:18:13,649 --> 00:18:16,860
common

00:18:14,220 --> 00:18:19,470
okay so the first thing we're going to

00:18:16,860 --> 00:18:22,080
do is say does the request body have an

00:18:19,470 --> 00:18:24,720
email and a password grammar today this

00:18:22,080 --> 00:18:27,240
is a that's the two things we need a

00:18:24,720 --> 00:18:28,830
password if you don't have those we're

00:18:27,240 --> 00:18:32,669
gonna send you back before hundred and

00:18:28,830 --> 00:18:35,159
we're done if we do have those we're

00:18:32,669 --> 00:18:38,269
going to use the username to pull the

00:18:35,159 --> 00:18:41,039
user information out of the database and

00:18:38,269 --> 00:18:44,820
we're going to make a claims variable

00:18:41,039 --> 00:18:47,279
and if the password that we got when we

00:18:44,820 --> 00:18:49,230
catch it matches the hashed version that

00:18:47,279 --> 00:18:51,029
we have stored as part of the user we're

00:18:49,230 --> 00:18:53,669
going to stick that user ID and that

00:18:51,029 --> 00:18:55,380
cleans object otherwise if the password

00:18:53,669 --> 00:18:57,330
doesn't validate we're going to throw

00:18:55,380 --> 00:19:01,519
for a one error until you need to login

00:18:57,330 --> 00:19:04,049
you screwed it up we're done otherwise

00:19:01,519 --> 00:19:05,970
we're going to assign those claims and

00:19:04,049 --> 00:19:07,200
this is good as just the helper function

00:19:05,970 --> 00:19:09,570
it's going to generate adjacent web

00:19:07,200 --> 00:19:12,090
token using the secret that's embedded

00:19:09,570 --> 00:19:13,559
inside that GWT library we're going to

00:19:12,090 --> 00:19:15,720
take that token we're going to stick it

00:19:13,559 --> 00:19:18,630
in a special application header that we

00:19:15,720 --> 00:19:20,549
have defined and documented in our API

00:19:18,630 --> 00:19:23,250
and we're going to return that along

00:19:20,549 --> 00:19:25,559
with a 200 and now the client will pull

00:19:23,250 --> 00:19:27,090
the tow it back out and the next time

00:19:25,559 --> 00:19:29,890
they want to make a request in this API

00:19:27,090 --> 00:19:32,330
will send the taupe

00:19:29,890 --> 00:19:34,310
all right so that's you're making one

00:19:32,330 --> 00:19:37,250
it's good how do you validate it

00:19:34,310 --> 00:19:40,100
what is that look like so this is a

00:19:37,250 --> 00:19:41,570
stress we're gonna use a middleware that

00:19:40,100 --> 00:19:46,970
is here a minute again this is not a

00:19:41,570 --> 00:19:48,740
whole lot of code breaking this down so

00:19:46,970 --> 00:19:51,410
we're going to load up that GWT helper

00:19:48,740 --> 00:19:53,810
library again and then this is the way

00:19:51,410 --> 00:19:55,220
you define a middleware and express

00:19:53,810 --> 00:19:57,410
people know in a middleware is so if

00:19:55,220 --> 00:19:59,540
you're doing web programming in an HTTP

00:19:57,410 --> 00:20:02,540
stack basic middleware is a piece of

00:19:59,540 --> 00:20:05,390
code that you inject into the response I

00:20:02,540 --> 00:20:08,030
hope it gets control before the actual

00:20:05,390 --> 00:20:10,940
thing that the endpoint so this is gonna

00:20:08,030 --> 00:20:13,340
run on every request before any other

00:20:10,940 --> 00:20:16,580
downstream code happens and it will have

00:20:13,340 --> 00:20:18,560
the ability to modify the requests or

00:20:16,580 --> 00:20:20,540
reject the request and just stop

00:20:18,560 --> 00:20:22,310
processing so this is a perfect way to

00:20:20,540 --> 00:20:25,220
check whether somebody is logged in and

00:20:22,310 --> 00:20:28,400
authenticated so this is how you define

00:20:25,220 --> 00:20:30,830
a middleware and express you call apt

00:20:28,400 --> 00:20:33,380
I'd use with a callback and that

00:20:30,830 --> 00:20:36,170
callback expects to get the request the

00:20:33,380 --> 00:20:38,300
response and a callback function for the

00:20:36,170 --> 00:20:39,590
next step in the middleware pipeline so

00:20:38,300 --> 00:20:41,840
everything works right you're going to

00:20:39,590 --> 00:20:43,490
call that next assumption and things are

00:20:41,840 --> 00:20:45,380
going to keep rolling down but if you

00:20:43,490 --> 00:20:47,480
want to you can also bail out of the

00:20:45,380 --> 00:20:50,660
response cycle at this point just return

00:20:47,480 --> 00:20:52,580
a response so first thing we're going to

00:20:50,660 --> 00:20:55,160
do is make a place in the request object

00:20:52,580 --> 00:20:56,780
to hold the decoded JSON web token and

00:20:55,160 --> 00:20:59,690
the optimistic hope that that's going to

00:20:56,780 --> 00:21:02,420
work and then we're going to do some

00:20:59,690 --> 00:21:04,040
promise stuff is slightly didn't go

00:21:02,420 --> 00:21:05,690
through this plane but what we're going

00:21:04,040 --> 00:21:08,480
to do here is get the authentication

00:21:05,690 --> 00:21:09,920
header out of your request and then once

00:21:08,480 --> 00:21:13,010
we have it we're going to pass it into

00:21:09,920 --> 00:21:15,470
this function that function is going to

00:21:13,010 --> 00:21:17,300
make sure the there was a value in that

00:21:15,470 --> 00:21:20,720
authentication header and it's gonna

00:21:17,300 --> 00:21:21,980
break it into two pieces based on a

00:21:20,720 --> 00:21:24,200
string and it's going to make sure that

00:21:21,980 --> 00:21:26,090
the first piece is there because there

00:21:24,200 --> 00:21:28,100
are other schemes you can't find an

00:21:26,090 --> 00:21:30,470
authorization header and all we want to

00:21:28,100 --> 00:21:33,050
deal with this two bears so if it is

00:21:30,470 --> 00:21:34,520
bear then we're going to call the verify

00:21:33,050 --> 00:21:38,270
function and I'm hoping the library and

00:21:34,520 --> 00:21:41,180
give it the token if it doesn't validate

00:21:38,270 --> 00:21:42,230
we're going to throw an exception and if

00:21:41,180 --> 00:21:44,030
we don't have

00:21:42,230 --> 00:21:46,550
authorization header at all were thrown

00:21:44,030 --> 00:21:51,290
exception and then we're going to chain

00:21:46,550 --> 00:21:53,840
another function on to this because if

00:21:51,290 --> 00:21:55,850
the validation does work we're going to

00:21:53,840 --> 00:21:58,940
just return the value of the validation

00:21:55,850 --> 00:22:01,670
which is the decoded jason claim object

00:21:58,940 --> 00:22:03,350
from adjacent web captain so if that

00:22:01,670 --> 00:22:05,720
works we call this next function in a

00:22:03,350 --> 00:22:08,300
chain pass at that payload it sticks the

00:22:05,720 --> 00:22:10,250
payload into that JWT slot under request

00:22:08,300 --> 00:22:11,840
object calls the next function in the

00:22:10,250 --> 00:22:12,260
middle row chain and we go on our merry

00:22:11,840 --> 00:22:14,570
way

00:22:12,260 --> 00:22:15,710
because the token validated and we're

00:22:14,570 --> 00:22:18,230
just going to keep processing the

00:22:15,710 --> 00:22:20,390
request however if we threw one of those

00:22:18,230 --> 00:22:22,280
exceptions we have a catch block at the

00:22:20,390 --> 00:22:25,840
end of the promise we're going to grab

00:22:22,280 --> 00:22:27,440
that error and here's the whole right

00:22:25,840 --> 00:22:29,600
anytime you have an authentication

00:22:27,440 --> 00:22:31,430
system you can't require as an occasion

00:22:29,600 --> 00:22:34,820
for every endpoint because you have to

00:22:31,430 --> 00:22:37,430
have one endpoint to become

00:22:34,820 --> 00:22:39,620
authentication right so we check here to

00:22:37,430 --> 00:22:42,230
say oh this this request for the user

00:22:39,620 --> 00:22:44,540
login in point if it was that one you

00:22:42,230 --> 00:22:47,480
can get to so we will go ahead and call

00:22:44,540 --> 00:22:50,990
the next option we require to be posting

00:22:47,480 --> 00:22:52,430
right because yet user login doesn't

00:22:50,990 --> 00:22:57,500
make any sense we certainly don't want

00:22:52,430 --> 00:22:59,150
somebody playing a password otherwise if

00:22:57,500 --> 00:23:03,140
there's any sort of other error function

00:22:59,150 --> 00:23:06,800
throw a 401 say you need to authenticate

00:23:03,140 --> 00:23:09,410
and would have done this cause of the

00:23:06,800 --> 00:23:13,070
request to be sent out from the rest of

00:23:09,410 --> 00:23:15,380
the middle trip middleware chain again

00:23:13,070 --> 00:23:18,020
you want a log that this stuff is not in

00:23:15,380 --> 00:23:20,980
there right so that's cool that's pretty

00:23:18,020 --> 00:23:25,610
simple kind of recapitulates of cookies

00:23:20,980 --> 00:23:30,380
Sammis like alright I'm happy I might

00:23:25,610 --> 00:23:33,920
use JSON web tokens in my project shurik

00:23:30,380 --> 00:23:36,740
requester what else yeah what else can

00:23:33,920 --> 00:23:38,330
Jason let's do one thing that we've done

00:23:36,740 --> 00:23:40,370
it very successfully with an application

00:23:38,330 --> 00:23:44,900
of work is what we call free signing

00:23:40,370 --> 00:23:46,910
continent requests so the scenario is we

00:23:44,900 --> 00:23:49,280
have a applications of web-based

00:23:46,910 --> 00:23:52,220
application that stores documents for

00:23:49,280 --> 00:23:53,780
people it's a client-side angular how it

00:23:52,220 --> 00:23:54,600
uses the JSON web tokens for

00:23:53,780 --> 00:23:56,490
authentication

00:23:54,600 --> 00:24:00,179
session management and it uses the

00:23:56,490 --> 00:24:01,770
authorization fare scheme for that well

00:24:00,179 --> 00:24:03,780
this is a document store we want to

00:24:01,770 --> 00:24:05,940
display some of those documents or JPEGs

00:24:03,780 --> 00:24:07,679
if somebody is looking at their

00:24:05,940 --> 00:24:10,740
documents we want to show them like a

00:24:07,679 --> 00:24:13,169
thumbnail image of the JPEG so how do

00:24:10,740 --> 00:24:15,299
you do that how do you display your

00:24:13,169 --> 00:24:17,250
download images via the browser when

00:24:15,299 --> 00:24:19,890
you're requiring every endpoint to be

00:24:17,250 --> 00:24:21,240
authenticated and all the browser is

00:24:19,890 --> 00:24:24,570
going to see is an image link with a

00:24:21,240 --> 00:24:27,750
source attribute and it's not going to

00:24:24,570 --> 00:24:29,460
send a special HTTP header it's just

00:24:27,750 --> 00:24:31,320
going to send it normally to BP request

00:24:29,460 --> 00:24:33,330
visits just a web browser it knows

00:24:31,320 --> 00:24:34,440
nothing that you're Jason watch okay so

00:24:33,330 --> 00:24:36,600
what's the solution

00:24:34,440 --> 00:24:40,340
it's Jason web tokens of course you're

00:24:36,600 --> 00:24:43,350
in a talk about Jason watch opens like

00:24:40,340 --> 00:24:45,600
so what we do is we generate a claim

00:24:43,350 --> 00:24:48,929
that contains the document ID so we have

00:24:45,600 --> 00:24:50,850
an issue that header and expiration

00:24:48,929 --> 00:24:52,559
header and the document ID that

00:24:50,850 --> 00:24:54,720
corresponds to the road and database

00:24:52,559 --> 00:24:56,730
with the documents that the story if you

00:24:54,720 --> 00:24:58,679
look at these expiration you should have

00:24:56,730 --> 00:25:01,740
an expiration heathers carefully you can

00:24:58,679 --> 00:25:03,690
see it's only valid for 60 seconds it's

00:25:01,740 --> 00:25:06,450
got an extremely short lifetime because

00:25:03,690 --> 00:25:08,669
basically we're going to create the code

00:25:06,450 --> 00:25:09,960
the HTML code page that we're going to

00:25:08,669 --> 00:25:11,730
display that's going to have all these

00:25:09,960 --> 00:25:13,860
thumbnail documents and if that's going

00:25:11,730 --> 00:25:16,020
to get loaded in the browser and as the

00:25:13,860 --> 00:25:17,700
web browser is processing it it's going

00:25:16,020 --> 00:25:20,010
to make these image source requests

00:25:17,700 --> 00:25:24,179
rapidly so this doesn't need to be a

00:25:20,010 --> 00:25:26,250
long-lived token we sign that token and

00:25:24,179 --> 00:25:27,570
we just embedded in the URL and this is

00:25:26,250 --> 00:25:31,190
literally what it looks like so I'll

00:25:27,570 --> 00:25:33,990
just content slash Jason much okay on

00:25:31,190 --> 00:25:36,179
the server side when we get a request

00:25:33,990 --> 00:25:39,390
that looks like this we have a route

00:25:36,179 --> 00:25:43,799
defined for a get request to slash

00:25:39,390 --> 00:25:45,600
content wildcard that we pull that Jason

00:25:43,799 --> 00:25:48,210
web token out of the wild card match we

00:25:45,600 --> 00:25:50,190
validate it extract a document ID out of

00:25:48,210 --> 00:25:53,690
the payload get that document from the

00:25:50,190 --> 00:25:53,690
database and send it back

00:25:54,710 --> 00:25:58,820
Sam is impressed by that one

00:26:00,270 --> 00:26:05,440
all right so what else can you do that

00:26:03,100 --> 00:26:07,210
so that's an example of how you can

00:26:05,440 --> 00:26:08,830
encode that token and just send it in a

00:26:07,210 --> 00:26:16,510
get request right it doesn't have to be

00:26:08,830 --> 00:26:19,720
in the plant didn't sign it

00:26:16,510 --> 00:26:21,880
we generated server-side Sony assistant

00:26:19,720 --> 00:26:24,940
send it to a point in the Senate that we

00:26:21,880 --> 00:26:27,040
plant in the HTML okay right then it's

00:26:24,940 --> 00:26:29,020
gonna render a display and then as it's

00:26:27,040 --> 00:26:56,740
going oh this is definitely going to

00:26:29,020 --> 00:27:04,660
fetch the image it is that URL there may

00:26:56,740 --> 00:27:06,250
be other ways so another problem that I

00:27:04,660 --> 00:27:09,390
have this was actually kind of one of

00:27:06,250 --> 00:27:11,500
the inspirations for giving his talk I

00:27:09,390 --> 00:27:14,620
feel like I'm running I've been doing

00:27:11,500 --> 00:27:18,010
web programming for let's say more than

00:27:14,620 --> 00:27:19,690
15 years and even at that and I feel

00:27:18,010 --> 00:27:21,490
like I've run into this problem over and

00:27:19,690 --> 00:27:24,429
over again and JSON web tokens have

00:27:21,490 --> 00:27:25,800
given me sort of the first solution to

00:27:24,429 --> 00:27:29,200
this that I actually don't

00:27:25,800 --> 00:27:32,350
and that recurring element is some form

00:27:29,200 --> 00:27:34,750
of lightweight access control so you're

00:27:32,350 --> 00:27:36,340
making an API or something that you're

00:27:34,750 --> 00:27:39,280
gonna put on the left and you don't want

00:27:36,340 --> 00:27:40,870
the whole Internet to see it right so

00:27:39,280 --> 00:27:43,600
you have three options one you could

00:27:40,870 --> 00:27:47,950
leave it wide open of a MongoDB pattern

00:27:43,600 --> 00:27:50,470
I don't recommend that you can write a

00:27:47,950 --> 00:27:52,510
full authentication subsystem again

00:27:50,470 --> 00:27:54,940
right and deal with things like

00:27:52,510 --> 00:27:57,100
self-service Password Reset and it has

00:27:54,940 --> 00:27:59,620
been paged to manage users and blah blah

00:27:57,100 --> 00:28:02,260
blah who's written more than one of

00:27:59,620 --> 00:28:05,380
those yeah who wants to write another

00:28:02,260 --> 00:28:10,090
one right okay or you can use something

00:28:05,380 --> 00:28:12,110
like oh ah which we've used a lot whose

00:28:10,090 --> 00:28:14,240
lights using a lot

00:28:12,110 --> 00:28:17,390
had one person either end up one so

00:28:14,240 --> 00:28:19,100
every late or you can go to even

00:28:17,390 --> 00:28:22,610
something heavier weight like saml who's

00:28:19,100 --> 00:28:28,700
used sample who like wants to never hear

00:28:22,610 --> 00:28:30,290
that word ever again yes okay so so

00:28:28,700 --> 00:28:32,300
where's the middle ground right where's

00:28:30,290 --> 00:28:34,220
the middle ground between the bank vault

00:28:32,300 --> 00:28:36,710
approach and the completely wide open

00:28:34,220 --> 00:28:40,910
door approach like where's I want a

00:28:36,710 --> 00:28:43,460
screen door bugs out that is not gonna

00:28:40,910 --> 00:28:44,960
survive somebody would like determine

00:28:43,460 --> 00:28:48,110
intent to get it sighs I don't really

00:28:44,960 --> 00:28:50,090
hear that much right I just want to not

00:28:48,110 --> 00:28:56,000
have annoying people knocking my stuff

00:28:50,090 --> 00:28:58,070
down so repeat you have an API you don't

00:28:56,000 --> 00:28:59,720
want to make anybody you don't wanna

00:28:58,070 --> 00:29:00,980
make anybody that stated to use it but

00:28:59,720 --> 00:29:03,220
you don't want to leave it wide open to

00:29:00,980 --> 00:29:06,170
the internet either you basically want

00:29:03,220 --> 00:29:09,320
author is that that occasion was sorry

00:29:06,170 --> 00:29:11,780
authorization without indication so what

00:29:09,320 --> 00:29:13,970
you can do with Jason web tokens there's

00:29:11,780 --> 00:29:17,060
a way in the spat spelled out where

00:29:13,970 --> 00:29:20,720
instead of using a single secret you can

00:29:17,060 --> 00:29:22,850
use an RSA key pair as the secret and

00:29:20,720 --> 00:29:24,590
you can include so basically you sign

00:29:22,850 --> 00:29:26,780
things with the private half of the key

00:29:24,590 --> 00:29:29,210
there and there's a special defined

00:29:26,780 --> 00:29:31,610
header where you can include the public

00:29:29,210 --> 00:29:34,730
half of the key pair in the JSON web

00:29:31,610 --> 00:29:37,430
token it's called jwk which stands for

00:29:34,730 --> 00:29:41,390
Jason web key so this allows you to

00:29:37,430 --> 00:29:43,670
generate tokens client-side and send

00:29:41,390 --> 00:29:48,110
them in and then verify them in the

00:29:43,670 --> 00:29:50,420
server side so to set it up you call up

00:29:48,110 --> 00:29:52,490
your authorized API client or exchange

00:29:50,420 --> 00:29:55,280
email or you even write a website to do

00:29:52,490 --> 00:29:58,790
this and give them or have them generate

00:29:55,280 --> 00:30:01,010
an RSA key pair and you keep track of

00:29:58,790 --> 00:30:02,480
the fingerprint of the public key that's

00:30:01,010 --> 00:30:04,250
gonna become important in about two

00:30:02,480 --> 00:30:06,860
slides you need the fingerprint of the

00:30:04,250 --> 00:30:08,480
public key to make this work but the

00:30:06,860 --> 00:30:09,980
client can generate the key pair

00:30:08,480 --> 00:30:13,940
themselves they just need to tell you

00:30:09,980 --> 00:30:16,070
the fingerprint on the client side they

00:30:13,940 --> 00:30:19,250
generated Jason and web token that

00:30:16,070 --> 00:30:21,950
contains the public half in the header

00:30:19,250 --> 00:30:23,570
it's defined for and it's public there's

00:30:21,950 --> 00:30:24,840
no problem with this you're expected to

00:30:23,570 --> 00:30:27,690
share the public s

00:30:24,840 --> 00:30:30,150
there they sign the JSON web token with

00:30:27,690 --> 00:30:32,549
the private half they have to include

00:30:30,150 --> 00:30:35,340
issues that issued at the expired claims

00:30:32,549 --> 00:30:37,590
and they send the JSON web token in with

00:30:35,340 --> 00:30:41,340
their API request in the bare header or

00:30:37,590 --> 00:30:43,770
wherever on the API side you get the

00:30:41,340 --> 00:30:46,980
jason web token you extract the public

00:30:43,770 --> 00:30:49,169
key you validate the signature using a

00:30:46,980 --> 00:30:51,029
public key now right which will only

00:30:49,169 --> 00:30:53,520
work if the key was signed with the

00:30:51,029 --> 00:30:55,470
corresponding private out and then you

00:30:53,520 --> 00:30:57,419
validate that that public key

00:30:55,470 --> 00:31:00,809
fingerprint is on your white list of

00:30:57,419 --> 00:31:03,480
allowed public key fingerprints that you

00:31:00,809 --> 00:31:05,460
maintain if the public key is white

00:31:03,480 --> 00:31:07,409
listed in the key validates we know that

00:31:05,460 --> 00:31:15,299
the person who made the JSON web token

00:31:07,409 --> 00:31:17,190
is authorized to use the API now the

00:31:15,299 --> 00:31:18,539
bigger print part is really critical

00:31:17,190 --> 00:31:20,490
because if you don't check the

00:31:18,539 --> 00:31:23,220
fingerprint against the whitelist of non

00:31:20,490 --> 00:31:25,470
fingerprints in the RSA key pair will

00:31:23,220 --> 00:31:29,000
pass through this right so chaining that

00:31:25,470 --> 00:31:31,620
fingerprint is really important you

00:31:29,000 --> 00:31:34,380
still also need to validate the issue

00:31:31,620 --> 00:31:37,350
that and inspired claims any other rules

00:31:34,380 --> 00:31:39,659
you have in your API if you've picked a

00:31:37,350 --> 00:31:40,260
good library for this it should do this

00:31:39,659 --> 00:31:43,529
for you

00:31:40,260 --> 00:32:03,029
yes 2013 is not that far away does the

00:31:43,529 --> 00:32:04,799
expired at all so 17 and again with this

00:32:03,029 --> 00:32:06,720
right despite the fact that you're using

00:32:04,799 --> 00:32:09,000
there's a key pair there's nothing

00:32:06,720 --> 00:32:10,830
encrypted right you it's still trivial

00:32:09,000 --> 00:32:12,570
to get the stuff back out of the header

00:32:10,830 --> 00:32:15,990
and the payload so you still shouldn't

00:32:12,570 --> 00:32:17,850
but social security numbers in there the

00:32:15,990 --> 00:32:20,370
enemy is impatient to see code again so

00:32:17,850 --> 00:32:25,289
here's the client-side code this happens

00:32:20,370 --> 00:32:26,850
to be in Perl instead of no project but

00:32:25,289 --> 00:32:28,649
don't be scared I'll walk you through it

00:32:26,850 --> 00:32:32,399
it's extremely readable I promise it's

00:32:28,649 --> 00:32:35,610
not scary so we're gonna load up some

00:32:32,399 --> 00:32:38,440
libraries for a library called GWT it's

00:32:35,610 --> 00:32:40,870
used for encoding and tokens

00:32:38,440 --> 00:32:43,059
another RSA library and then we're gonna

00:32:40,870 --> 00:32:45,179
have an HTTP request light break we're

00:32:43,059 --> 00:32:49,000
gonna read our public and private keys

00:32:45,179 --> 00:32:51,399
the bot system in the things not to view

00:32:49,000 --> 00:32:52,690
category not storing your keys and files

00:32:51,399 --> 00:32:57,669
in the same directory as your

00:32:52,690 --> 00:32:59,679
application is and then we're going to

00:32:57,669 --> 00:33:02,940
generate it okay here we're using a

00:32:59,679 --> 00:33:06,039
different algorithm this is RSA sha-512

00:33:02,940 --> 00:33:09,340
we're gonna include an extra header in

00:33:06,039 --> 00:33:13,779
this Jaden Yuki slot which is the public

00:33:09,340 --> 00:33:14,950
key exported in jwk format and then

00:33:13,779 --> 00:33:17,110
we're going to use the private key to

00:33:14,950 --> 00:33:19,629
sign it our payload is just going to be

00:33:17,110 --> 00:33:22,419
the issue that and the current time and

00:33:19,629 --> 00:33:24,100
the kernel genuine theme library has

00:33:22,419 --> 00:33:25,779
this cool relative expression thing

00:33:24,100 --> 00:33:28,029
where you could say I want an expiration

00:33:25,779 --> 00:33:29,769
header that's this many seconds after

00:33:28,029 --> 00:33:33,700
the issue to echo so this has been a

00:33:29,769 --> 00:33:36,850
last for outbound and then we make an

00:33:33,700 --> 00:33:39,340
HTTP request to our endpoint include

00:33:36,850 --> 00:33:42,340
that in the authorization header and we

00:33:39,340 --> 00:33:46,179
just encode adjacent bodies of the

00:33:42,340 --> 00:33:48,309
request so the really critical bit to

00:33:46,179 --> 00:33:51,669
this is adding a public key to the

00:33:48,309 --> 00:33:54,909
header the Jason Webb key format isn't

00:33:51,669 --> 00:33:56,649
not can't say it's not standard because

00:33:54,909 --> 00:34:00,730
there's an RFC for it but it's not a

00:33:56,649 --> 00:34:02,740
normal like PDM type format a bunch of

00:34:00,730 --> 00:34:04,450
libraries don't support it it took me

00:34:02,740 --> 00:34:06,429
about eight hours total like there was

00:34:04,450 --> 00:34:08,530
one coding day involved in getting all

00:34:06,429 --> 00:34:12,310
this to work and about four hours of it

00:34:08,530 --> 00:34:14,139
was figuring out those waiting lines to

00:34:12,310 --> 00:34:17,800
get the JSON web key exported in the

00:34:14,139 --> 00:34:27,220
right format so find a library that

00:34:17,800 --> 00:34:30,010
supports that monkey API again not a

00:34:27,220 --> 00:34:31,540
whole lot of code first thing we're

00:34:30,010 --> 00:34:33,819
going to do is get the tokens we're

00:34:31,540 --> 00:34:36,790
gonna load up that same GT library or

00:34:33,819 --> 00:34:39,429
RSA library a web framework called

00:34:36,790 --> 00:34:41,980
dancer which is a pro port of Sinatra

00:34:39,429 --> 00:34:44,909
Tony Mason with Sinatra stuff micro web

00:34:41,980 --> 00:34:46,869
framework an exception handling library

00:34:44,909 --> 00:34:50,500
we're going to pull that authorization

00:34:46,869 --> 00:34:52,400
header out of the request headers and

00:34:50,500 --> 00:34:54,530
then we're going to define a key

00:34:52,400 --> 00:34:55,880
or a variable to hold the token and

00:34:54,530 --> 00:34:59,960
we're going to return it for a one

00:34:55,880 --> 00:35:01,490
unless and what we're doing here is

00:34:59,960 --> 00:35:02,870
taking an authorization header and

00:35:01,490 --> 00:35:10,010
matching against a regular expression

00:35:02,870 --> 00:35:11,180
from there I'm sorry I'm a pro guy but I

00:35:10,010 --> 00:35:15,080
don't include at least one regular

00:35:11,180 --> 00:35:16,760
expression I get kicked out so this is

00:35:15,080 --> 00:35:18,380
it so what we're doing here is saving

00:35:16,760 --> 00:35:21,110
authorization header finding everything

00:35:18,380 --> 00:35:24,170
after bear to get in line and sticking

00:35:21,110 --> 00:35:25,610
it into dollar token and if we can't do

00:35:24,170 --> 00:35:29,600
that that regular expression doesn't

00:35:25,610 --> 00:35:34,880
match we just return route 401 the

00:35:29,600 --> 00:35:37,010
answer really didn't make it so then

00:35:34,880 --> 00:35:38,720
we're going to try to decode it and can

00:35:37,010 --> 00:35:40,910
turn now to confirm that it's valid and

00:35:38,720 --> 00:35:43,430
valid validate the is unit and

00:35:40,910 --> 00:35:45,650
expiration claims trimming a header and

00:35:43,430 --> 00:35:49,700
payload variables and then this try

00:35:45,650 --> 00:35:50,420
block is going to use the decode

00:35:49,700 --> 00:35:52,580
jadibooti

00:35:50,420 --> 00:35:54,380
function from the library we're gonna

00:35:52,580 --> 00:35:56,180
give it the token we're gonna ask is it

00:35:54,380 --> 00:35:59,180
be code the header we're going to tell

00:35:56,180 --> 00:36:01,370
it that the RSA sha-512 algorithm is the

00:35:59,180 --> 00:36:03,170
only one that works we're going to ask

00:36:01,370 --> 00:36:06,470
it the verify the issue death and

00:36:03,170 --> 00:36:08,750
expiration claims so if you give me a

00:36:06,470 --> 00:36:11,540
token that was issued in the future this

00:36:08,750 --> 00:36:13,820
will fail if you give me a token that it

00:36:11,540 --> 00:36:15,590
has an expiration time before the issue

00:36:13,820 --> 00:36:18,230
time this will fail if you give me a

00:36:15,590 --> 00:36:21,050
tokens expire this will fail if you give

00:36:18,230 --> 00:36:23,930
me a token that wasn't using RSA sha-512

00:36:21,050 --> 00:36:26,360
this will fail and if the token itself

00:36:23,930 --> 00:36:28,840
doesn't validate this will fail any of

00:36:26,360 --> 00:36:31,850
those failures will throw an exception

00:36:28,840 --> 00:36:36,740
we don't catch that exception because

00:36:31,850 --> 00:36:39,140
the other thing it will do so we just

00:36:36,740 --> 00:36:42,560
returned 401 unless we got a header and

00:36:39,140 --> 00:36:44,780
payload so we get down pass underneath

00:36:42,560 --> 00:36:47,860
this 401 line we've got a header we've

00:36:44,780 --> 00:36:50,870
got a payload the token is valid

00:36:47,860 --> 00:36:52,340
okay so just to recapitulate that the

00:36:50,870 --> 00:36:54,260
key and the header is wrong it fails

00:36:52,340 --> 00:36:55,910
it's not the right algorithm fails if it

00:36:54,260 --> 00:36:58,190
doesn't have those claims or if they're

00:36:55,910 --> 00:37:01,450
bogus it fails and all of that

00:36:58,190 --> 00:37:01,450
validation happens within

00:37:04,119 --> 00:37:08,470
you do need this to do a few more checks

00:37:06,250 --> 00:37:11,019
so I think you should have go here in a

00:37:08,470 --> 00:37:13,210
second so if we specify in our APA

00:37:11,019 --> 00:37:15,970
documentation that you shall not

00:37:13,210 --> 00:37:18,819
generate a Jason web token with more

00:37:15,970 --> 00:37:20,920
than a 30-minute expiration more than a

00:37:18,819 --> 00:37:23,289
30-minute lifetime so I need to make

00:37:20,920 --> 00:37:27,069
sure that that is it's true I don't want

00:37:23,289 --> 00:37:28,660
people generating forever right and I

00:37:27,069 --> 00:37:30,430
also need to make sure that this isn't

00:37:28,660 --> 00:37:33,609
some random key pair that it's on my

00:37:30,430 --> 00:37:35,170
playlist so the first thing I do is

00:37:33,609 --> 00:37:37,329
check that the expiration is now sorry

00:37:35,170 --> 00:37:39,460
unlike the API got to say less than one

00:37:37,329 --> 00:37:42,250
hour so I checked to make sure the

00:37:39,460 --> 00:37:45,609
expiration time - the issue that time is

00:37:42,250 --> 00:37:47,650
less than and then I checked that the

00:37:45,609 --> 00:37:50,470
included public key is in my whitelist

00:37:47,650 --> 00:37:54,099
so here I'm going to generate an RSA key

00:37:50,470 --> 00:37:56,740
object I'm going to stick the header

00:37:54,099 --> 00:37:59,109
jiggity K key into it and then I'm gonna

00:37:56,740 --> 00:38:02,680
generate a thumbprint and make sure that

00:37:59,109 --> 00:38:03,940
that thumbprint is in my white list that

00:38:02,680 --> 00:38:07,690
looks like it's similar to a replay

00:38:03,940 --> 00:38:10,299
attack you're not validating that iat is

00:38:07,690 --> 00:38:14,319
currently that happens in the library

00:38:10,299 --> 00:38:15,789
level it's subject to replay attack if

00:38:14,319 --> 00:38:22,390
somebody gets the token before it

00:38:15,789 --> 00:38:24,160
expires and uses it again so that's it

00:38:22,390 --> 00:38:26,619
we know the public key in the header is

00:38:24,160 --> 00:38:28,329
by the finger thread so we know that the

00:38:26,619 --> 00:38:31,150
private key images that sign it will

00:38:28,329 --> 00:38:33,670
validate and therefore this JSON web

00:38:31,150 --> 00:38:35,380
token came from the private key holder

00:38:33,670 --> 00:38:39,730
by definition it is on the how-to

00:38:35,380 --> 00:38:41,319
yeah this whole thing depends on the

00:38:39,730 --> 00:38:43,690
person who has the private key you could

00:38:41,319 --> 00:38:47,109
try to keep credit it's right there in

00:38:43,690 --> 00:38:49,150
the name but revoking a key is as simple

00:38:47,109 --> 00:38:52,509
as removing the corresponding public key

00:38:49,150 --> 00:38:53,829
fingerprint from the whitelist how your

00:38:52,509 --> 00:38:58,210
server works you might not even have to

00:38:53,829 --> 00:38:59,710
restart your server um so yeah and as

00:38:58,210 --> 00:39:01,380
the gentleman in the front row pointed

00:38:59,710 --> 00:39:04,059
out this is subject to a replay attack

00:39:01,380 --> 00:39:07,150
but that's fine this is a screen door

00:39:04,059 --> 00:39:10,569
right you walk away from your house and

00:39:07,150 --> 00:39:12,730
the outside is a screen door and

00:39:10,569 --> 00:39:13,760
somebody has a pocketknife you're

00:39:12,730 --> 00:39:17,780
subject to a pocket

00:39:13,760 --> 00:39:19,760
right so it's a matter of deciding what

00:39:17,780 --> 00:39:22,010
risk profile is acceptable to you the

00:39:19,760 --> 00:39:24,560
API that we were trying to protect was

00:39:22,010 --> 00:39:28,609
extremely low value basically wanted to

00:39:24,560 --> 00:39:30,500
keep out flies which is why discrete or

00:39:28,609 --> 00:39:32,690
protein rather if you're protecting

00:39:30,500 --> 00:39:35,690
something that is more secure yes you

00:39:32,690 --> 00:39:37,400
should consider physical attacks but for

00:39:35,690 --> 00:39:38,869
this for Tobey Elizabeth thirty minutes

00:39:37,400 --> 00:39:46,820
that's required to be transmitted over

00:39:38,869 --> 00:39:49,520
HTTP there are some more advanced usages

00:39:46,820 --> 00:39:50,990
of JSON web hook as possible so you can

00:39:49,520 --> 00:39:54,109
encrypt the payloads

00:39:50,990 --> 00:39:56,600
that's called Jason web encryption

00:39:54,109 --> 00:39:58,040
I haven't read enough of that RFC to

00:39:56,600 --> 00:39:59,359
understand it to a point where I can

00:39:58,040 --> 00:40:02,180
explain it because it kind of is my

00:39:59,359 --> 00:40:04,400
shepherd another thing that made my head

00:40:02,180 --> 00:40:06,350
hurt was the notion of nested jason web

00:40:04,400 --> 00:40:08,270
tokens where you have adjacent web token

00:40:06,350 --> 00:40:10,790
that contains another jason web token

00:40:08,270 --> 00:40:12,770
typically that is used where the

00:40:10,790 --> 00:40:14,410
external one would be unencrypted that

00:40:12,770 --> 00:40:17,330
it would include an encrypted one

00:40:14,410 --> 00:40:18,650
vice-versa if you're interested in

00:40:17,330 --> 00:40:23,570
either one of those I recommend that you

00:40:18,650 --> 00:40:26,690
read those RFC is and finally this is

00:40:23,570 --> 00:40:29,300
Sammy's friend pepper pepper is a

00:40:26,690 --> 00:40:31,190
Chinese Crested which is popularly known

00:40:29,300 --> 00:40:32,930
as the ugly dog breed in the world

00:40:31,190 --> 00:40:34,790
sometimes called oh my god what's wrong

00:40:32,930 --> 00:40:40,670
with that dog but they're just supposed

00:40:34,790 --> 00:40:42,890
to like that I wouldn't be remiss if I

00:40:40,670 --> 00:40:45,020
did not tell you that some people are

00:40:42,890 --> 00:40:47,840
not fans of JSON web tokens I hope at

00:40:45,020 --> 00:40:50,390
this point you understand that I am okay

00:40:47,840 --> 00:40:52,670
but it's not that hard if you look on

00:40:50,390 --> 00:40:54,560
without to find articles with titles

00:40:52,670 --> 00:40:59,750
like don't ever use adjacent Oh joking

00:40:54,560 --> 00:41:01,280
forever or Jason Weber life and the

00:40:59,750 --> 00:41:03,920
objection suggestive up to again it's

00:41:01,280 --> 00:41:05,990
fall into one of two categories category

00:41:03,920 --> 00:41:10,520
number one is based on the fact that the

00:41:05,990 --> 00:41:12,410
original RFC have a fairly clarity one

00:41:10,520 --> 00:41:14,510
of the acceptable algorithm types and in

00:41:12,410 --> 00:41:17,119
fact one of the two algorithm types that

00:41:14,510 --> 00:41:20,510
libraries are required to implement is

00:41:17,119 --> 00:41:21,530
called nine the other one is age match

00:41:20,510 --> 00:41:24,230
sha-256

00:41:21,530 --> 00:41:27,610
the none algorithm basically says hey

00:41:24,230 --> 00:41:30,160
there is no signature so if I generate

00:41:27,610 --> 00:41:32,740
Jason web token with the non header and

00:41:30,160 --> 00:41:35,220
give it to you library basically just

00:41:32,740 --> 00:41:39,220
doesn't try to validate the signature

00:41:35,220 --> 00:41:41,920
which is kind of bad it turns out that

00:41:39,220 --> 00:41:43,870
if you're depending on the value of the

00:41:41,920 --> 00:41:47,140
header and adjacent web token you got

00:41:43,870 --> 00:41:49,570
from someone who you don't trust they

00:41:47,140 --> 00:41:51,730
can edit what's in a header and change

00:41:49,570 --> 00:41:53,230
that algorithm to none and if you have

00:41:51,730 --> 00:41:56,110
one of these buggy libraries it will

00:41:53,230 --> 00:41:59,920
tell you that he is still valid this has

00:41:56,110 --> 00:42:02,410
been fixed this was found in 2015

00:41:59,920 --> 00:42:04,300
pretty much every major library and I

00:42:02,410 --> 00:42:06,460
think this is tracked on the GWT i/o

00:42:04,300 --> 00:42:07,780
library list has been updated so that

00:42:06,460 --> 00:42:09,730
you have a signature with it not

00:42:07,780 --> 00:42:12,730
algorithm that still has a signature of

00:42:09,730 --> 00:42:15,250
the validate any code that you are using

00:42:12,730 --> 00:42:17,860
you should specify an acceptable list of

00:42:15,250 --> 00:42:20,760
algorithms like I did in my early

00:42:17,860 --> 00:42:23,560
example and you should not basically

00:42:20,760 --> 00:42:26,590
don't blindly trust the algorithm that's

00:42:23,560 --> 00:42:28,390
in the heaven that fixes that problem

00:42:26,590 --> 00:42:29,950
but there are some people who have taken

00:42:28,390 --> 00:42:31,420
the attitude of well they screw that up

00:42:29,950 --> 00:42:36,970
really big we can't trust anything

00:42:31,420 --> 00:42:38,980
they've ever done which the second

00:42:36,970 --> 00:42:40,950
objection is that the spec in general is

00:42:38,980 --> 00:42:43,600
too flexible and has too many options

00:42:40,950 --> 00:42:47,710
I'm a pro guy this is not an argument

00:42:43,600 --> 00:42:51,040
that is going to over ever so you know

00:42:47,710 --> 00:42:52,930
make your own choices personally I think

00:42:51,040 --> 00:42:55,360
the Jason web tokens solve some fairly

00:42:52,930 --> 00:42:58,780
common problems in a pretty elegant and

00:42:55,360 --> 00:43:01,240
simple and easy to understand way and

00:42:58,780 --> 00:43:04,930
this is really cool and that you should

00:43:01,240 --> 00:43:06,280
maybe think about using all right so

00:43:04,930 --> 00:43:09,130
I'll take questions here in a minute I

00:43:06,280 --> 00:43:11,920
want to thank the JM utena IO people and

00:43:09,130 --> 00:43:14,530
off o calm who's a identity provider as

00:43:11,920 --> 00:43:16,120
a service company that really came up

00:43:14,530 --> 00:43:18,310
with Jason Webb tokens I want to thank

00:43:16,120 --> 00:43:19,870
the organizers for accepting this talk I

00:43:18,310 --> 00:43:22,120
want to thank all of you for coming to

00:43:19,870 --> 00:43:25,560
the talk and has ended questions and I

00:43:22,120 --> 00:43:28,120
want to make my company for peeing too

00:43:25,560 --> 00:43:29,620
we're pretty cool if you need any custom

00:43:28,120 --> 00:43:31,480
software developer a technology

00:43:29,620 --> 00:43:34,180
consultant upon come talk to me I'll

00:43:31,480 --> 00:43:37,560
give you a card and I'm happy to take

00:43:34,180 --> 00:43:37,560

YouTube URL: https://www.youtube.com/watch?v=4-SZNVHwO1Y


