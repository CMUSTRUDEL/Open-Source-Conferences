Title: [OLF 2020] Baremetal RISC-V Renode
Publication date: 2020-12-08
Playlist: 2020 Videos
Description: 
	Speaker: Zak Kohler
Explore the line between hardware and software by writing code with absolute control over the cpu and peripherals. We’ll explore how to do this using a completely free and open source simulator (Renode), toolchain (GCC), and instruction set (RISC-V). Using assembly, we’ll initialize parts of the system such as CPU interrupts and privilege levels, and setting up a call stack so we can use C. Using C we’ll build a handler for serial IO. Finally we’ll talk about the next steps in building a toy operating system such as building a simple monitor menu, memory management, and multitasking.
Captions: 
	00:00:04,000 --> 00:00:07,839
hello

00:00:05,120 --> 00:00:09,679
thank you all for attending um it'll be

00:00:07,839 --> 00:00:12,880
fun to adjust to this

00:00:09,679 --> 00:00:16,160
virtual conference experience

00:00:12,880 --> 00:00:19,439
um can everyone see my screen

00:00:16,160 --> 00:00:23,039
i should be sharing my presentation now

00:00:19,439 --> 00:00:24,000
um so i'll be talking about bare metal

00:00:23,039 --> 00:00:28,000
risk five

00:00:24,000 --> 00:00:28,400
reno'd so first i'll give an overview

00:00:28,000 --> 00:00:32,399
about

00:00:28,400 --> 00:00:36,160
what each of those terms mean and then

00:00:32,399 --> 00:00:39,040
i will go through some code examples

00:00:36,160 --> 00:00:40,559
on how to set up kind of a basic

00:00:39,040 --> 00:00:41,840
environment

00:00:40,559 --> 00:00:45,840
and how you can run some of these

00:00:41,840 --> 00:00:45,840
examples yourself

00:00:49,360 --> 00:00:58,239
okay can you see the slides now

00:00:54,399 --> 00:01:01,280
oh okay

00:00:58,239 --> 00:01:01,280
good thing i double checked

00:01:02,879 --> 00:01:10,400
all right so i'm zach kohler

00:01:07,520 --> 00:01:12,080
uh originally i was went to school for

00:01:10,400 --> 00:01:14,000
chemical engineering

00:01:12,080 --> 00:01:16,320
i've been programming a lot longer than

00:01:14,000 --> 00:01:18,720
before i went to college

00:01:16,320 --> 00:01:19,840
and my day job used to be a materials

00:01:18,720 --> 00:01:22,240
engineer

00:01:19,840 --> 00:01:24,400
and i've really turned into a software

00:01:22,240 --> 00:01:26,320
developer

00:01:24,400 --> 00:01:28,000
some of my interests that are relevant

00:01:26,320 --> 00:01:31,040
to this talk are programming

00:01:28,000 --> 00:01:33,439
electronics and retro computing

00:01:31,040 --> 00:01:34,320
and some of my not so relevant interests

00:01:33,439 --> 00:01:38,320
include drawing

00:01:34,320 --> 00:01:38,320
punk rock and making cheese

00:01:39,759 --> 00:01:44,240
so what are my motivation for this talk

00:01:44,640 --> 00:01:49,600
so computer systems are built off of

00:01:47,360 --> 00:01:51,840
layers and layers of abstractions

00:01:49,600 --> 00:01:53,759
and these simple interfaces allow

00:01:51,840 --> 00:01:56,320
complex systems

00:01:53,759 --> 00:01:57,520
so every time you send a text message

00:01:56,320 --> 00:01:59,360
you don't think about the radios

00:01:57,520 --> 00:02:02,000
involved you don't think about your

00:01:59,360 --> 00:02:03,040
the kernel on your phone all of this is

00:02:02,000 --> 00:02:04,880
considered good

00:02:03,040 --> 00:02:06,719
because it allows you to do something

00:02:04,880 --> 00:02:09,840
very complex

00:02:06,719 --> 00:02:09,840
using something simple

00:02:12,800 --> 00:02:17,360
when you're looking at doing anything

00:02:15,440 --> 00:02:18,560
with a user application in a computer

00:02:17,360 --> 00:02:20,480
system

00:02:18,560 --> 00:02:23,200
you're interacting with this very top

00:02:20,480 --> 00:02:25,680
layer the the application

00:02:23,200 --> 00:02:26,879
and that'll talk to an operating system

00:02:25,680 --> 00:02:30,239
um

00:02:26,879 --> 00:02:33,760
at the layers of the levels

00:02:30,239 --> 00:02:35,599
below that are kind of invisible to most

00:02:33,760 --> 00:02:37,680
software developers

00:02:35,599 --> 00:02:40,560
and everything below the application is

00:02:37,680 --> 00:02:43,120
kind of transparent to the end user

00:02:40,560 --> 00:02:44,400
so kind of what motivated me was i

00:02:43,120 --> 00:02:47,360
didn't understand how

00:02:44,400 --> 00:02:48,800
kind of cpus worked and how what an

00:02:47,360 --> 00:02:50,560
instruction set really was i kind of

00:02:48,800 --> 00:02:51,920
knew how assembly worked

00:02:50,560 --> 00:02:53,599
but i wanted to learn more about

00:02:51,920 --> 00:02:55,120
hardware and so

00:02:53,599 --> 00:02:57,040
over the last couple years i've been

00:02:55,120 --> 00:03:00,000
building some uh

00:02:57,040 --> 00:03:01,200
simple hardware projects where i bread

00:03:00,000 --> 00:03:04,640
boarded a motherboard

00:03:01,200 --> 00:03:06,560
and connected a cpu to one chip of ram

00:03:04,640 --> 00:03:08,640
and kind of single step that hardware

00:03:06,560 --> 00:03:11,440
cpu

00:03:08,640 --> 00:03:13,440
um that was a z80 and i just built kind

00:03:11,440 --> 00:03:14,319
of a toy clock and ran it at about one

00:03:13,440 --> 00:03:15,840
hertz

00:03:14,319 --> 00:03:18,000
so every time i press the button it was

00:03:15,840 --> 00:03:19,760
one clock cycle

00:03:18,000 --> 00:03:21,760
and then after that i kind of moved on i

00:03:19,760 --> 00:03:25,519
said okay that's a cpu that's a

00:03:21,760 --> 00:03:28,159
microcomputer that was used in early pcs

00:03:25,519 --> 00:03:30,000
what if i built my own cpu and i could

00:03:28,159 --> 00:03:31,360
kind of look inside of that cpu as it

00:03:30,000 --> 00:03:34,480
was going

00:03:31,360 --> 00:03:37,599
so i built this simple uh cpu

00:03:34,480 --> 00:03:39,920
in python where you kind of

00:03:37,599 --> 00:03:41,840
could connect you could connect memory

00:03:39,920 --> 00:03:43,360
you can connect the cpu and you can code

00:03:41,840 --> 00:03:45,680
your own instructions

00:03:43,360 --> 00:03:47,360
and actually build a assembler for that

00:03:45,680 --> 00:03:50,560
cpu

00:03:47,360 --> 00:03:50,959
and so this talk is kind of my next step

00:03:50,560 --> 00:03:53,360
on this

00:03:50,959 --> 00:03:57,519
journey of understanding the the

00:03:53,360 --> 00:03:57,519
interface between hardware and software

00:03:59,040 --> 00:04:05,920
so bare metal risk five reno'd

00:04:02,400 --> 00:04:09,519
um as i said

00:04:05,920 --> 00:04:10,000
uh this is my next step and it's kind of

00:04:09,519 --> 00:04:12,720
a

00:04:10,000 --> 00:04:14,000
vendor-free environment to write and

00:04:12,720 --> 00:04:17,359
play with these toy operating

00:04:14,000 --> 00:04:19,759
systems so operating systems sit right

00:04:17,359 --> 00:04:22,240
between the application and the hardware

00:04:19,759 --> 00:04:24,479
uh before i was kind of messing around

00:04:22,240 --> 00:04:26,160
with the cpu architecture

00:04:24,479 --> 00:04:27,840
and now i've moved up just a little bit

00:04:26,160 --> 00:04:28,960
i'm kind of like playing in this area

00:04:27,840 --> 00:04:31,360
what sits between

00:04:28,960 --> 00:04:32,960
applications and the hardware so you

00:04:31,360 --> 00:04:34,080
have drivers and you have an operating

00:04:32,960 --> 00:04:36,479
system and

00:04:34,080 --> 00:04:39,360
fundamentally the linux it's a kernel

00:04:36,479 --> 00:04:42,400
it's the it's the operating system

00:04:39,360 --> 00:04:45,360
it talks to the hardware so

00:04:42,400 --> 00:04:46,720
what does bare metal mean bare metal is

00:04:45,360 --> 00:04:49,840
if you compile

00:04:46,720 --> 00:04:52,160
a c program into an executable

00:04:49,840 --> 00:04:54,240
normally if you just run gcc and then

00:04:52,160 --> 00:04:56,560
all of your c files and header files

00:04:54,240 --> 00:04:57,919
you compile it into a binary and

00:04:56,560 --> 00:04:59,680
executable

00:04:57,919 --> 00:05:03,120
but it still relies on the operating

00:04:59,680 --> 00:05:06,400
system to host that executing process

00:05:03,120 --> 00:05:07,280
it allocates the stack and memory for

00:05:06,400 --> 00:05:09,680
you

00:05:07,280 --> 00:05:11,199
and it takes care of some anytime you

00:05:09,680 --> 00:05:11,600
need to interact with hardware you can

00:05:11,199 --> 00:05:14,880
make

00:05:11,600 --> 00:05:15,759
a api call or a system call to the

00:05:14,880 --> 00:05:17,440
kernel

00:05:15,759 --> 00:05:19,199
so you don't have to write something to

00:05:17,440 --> 00:05:22,479
access a disk you don't have to write

00:05:19,199 --> 00:05:25,440
something to access a file

00:05:22,479 --> 00:05:26,639
when you compile bare metal or with gt

00:05:25,440 --> 00:05:29,520
gcc

00:05:26,639 --> 00:05:30,560
it's dash free standing you're telling

00:05:29,520 --> 00:05:33,280
that compiler

00:05:30,560 --> 00:05:34,400
that you're going to run this c program

00:05:33,280 --> 00:05:35,759
and there's not going to be any

00:05:34,400 --> 00:05:39,120
operating system that

00:05:35,759 --> 00:05:40,320
you rely on at all so why would you do

00:05:39,120 --> 00:05:42,000
that

00:05:40,320 --> 00:05:43,680
um well if you're writing an operating

00:05:42,000 --> 00:05:45,680
system you're not going to rely on

00:05:43,680 --> 00:05:47,759
another operating system

00:05:45,680 --> 00:05:49,680
so when you compile a linux kernel

00:05:47,759 --> 00:05:50,479
you'll do dash freestanding and that

00:05:49,680 --> 00:05:52,479
says

00:05:50,479 --> 00:05:54,479
you know there's no main there's there's

00:05:52,479 --> 00:05:56,400
no entry point that has to come from

00:05:54,479 --> 00:05:59,440
somewhere else like a bootloader

00:05:56,400 --> 00:05:59,919
you're just writing a a binary blob that

00:05:59,440 --> 00:06:03,120
has

00:05:59,919 --> 00:06:04,560
uh cpu instructions um

00:06:03,120 --> 00:06:06,479
also if you if you need to write

00:06:04,560 --> 00:06:09,039
something like a driver and

00:06:06,479 --> 00:06:10,800
you need to access the hardware directly

00:06:09,039 --> 00:06:11,680
or you're doing an embedded system where

00:06:10,800 --> 00:06:13,360
you

00:06:11,680 --> 00:06:15,520
don't want to rely on an entire

00:06:13,360 --> 00:06:19,199
operating system you can also compile

00:06:15,520 --> 00:06:21,919
this way and have your own bootloader

00:06:19,199 --> 00:06:22,960
so this gives up everything that linux

00:06:21,919 --> 00:06:26,319
gives you

00:06:22,960 --> 00:06:29,759
but when you do that you can use it to

00:06:26,319 --> 00:06:32,960
learn a lot more about why you really

00:06:29,759 --> 00:06:34,080
should love linux um

00:06:32,960 --> 00:06:35,759
sometimes when you need something

00:06:34,080 --> 00:06:36,319
lighter weight you don't want a full

00:06:35,759 --> 00:06:39,360
linux

00:06:36,319 --> 00:06:41,520
uh kernel to be you know shipped on a

00:06:39,360 --> 00:06:42,479
internet of things device there are also

00:06:41,520 --> 00:06:44,319
minimal

00:06:42,479 --> 00:06:46,160
very small operating systems that are

00:06:44,319 --> 00:06:48,160
kind of taking that role

00:06:46,160 --> 00:06:49,599
of sitting between you and the hardware

00:06:48,160 --> 00:06:50,400
and those are called real-time operating

00:06:49,599 --> 00:06:54,160
systems

00:06:50,400 --> 00:06:54,160
and they have a different performance

00:06:55,199 --> 00:06:59,360
performance trade-offs and a kind of

00:06:57,039 --> 00:07:03,199
full desktop linux

00:06:59,360 --> 00:07:07,120
but we'll talk about that a little more

00:07:03,199 --> 00:07:09,360
so what is risk five um

00:07:07,120 --> 00:07:10,960
when you read it it says risk v but it's

00:07:09,360 --> 00:07:12,720
actually pronounced risk five it's the

00:07:10,960 --> 00:07:15,840
fifth iteration of an open

00:07:12,720 --> 00:07:16,479
standard instruction set architecture um

00:07:15,840 --> 00:07:19,599
so

00:07:16,479 --> 00:07:22,080
basically if you think like intel cpus

00:07:19,599 --> 00:07:24,560
and amd cpus are x86

00:07:22,080 --> 00:07:25,840
and then mobile devices are almost all

00:07:24,560 --> 00:07:27,440
arm

00:07:25,840 --> 00:07:29,039
and then you you have all these

00:07:27,440 --> 00:07:30,000
different ways that you can compile an

00:07:29,039 --> 00:07:33,360
executable and

00:07:30,000 --> 00:07:35,440
tell a cpu how how to you know compute

00:07:33,360 --> 00:07:37,440
certain functions

00:07:35,440 --> 00:07:39,199
um risk five is is kind of the fifth

00:07:37,440 --> 00:07:40,639
generation of this open standard that

00:07:39,199 --> 00:07:43,280
they've made

00:07:40,639 --> 00:07:44,160
and it's finally been tuned it was more

00:07:43,280 --> 00:07:46,160
of an academic

00:07:44,160 --> 00:07:47,680
thing until it got to the fifth

00:07:46,160 --> 00:07:49,280
iteration where they realized we've

00:07:47,680 --> 00:07:51,599
learned a lot over the years from things

00:07:49,280 --> 00:07:53,280
like spark and mips and alpha

00:07:51,599 --> 00:07:55,440
and we're going to take the best of all

00:07:53,280 --> 00:07:57,199
of these closed source worlds

00:07:55,440 --> 00:07:58,879
and put these concepts into an open

00:07:57,199 --> 00:07:59,919
architecture that can scale from

00:07:58,879 --> 00:08:02,720
embedded

00:07:59,919 --> 00:08:04,800
all the way up to super computers so

00:08:02,720 --> 00:08:07,520
it's kind of poised to be

00:08:04,800 --> 00:08:08,560
the the next big architecture i just saw

00:08:07,520 --> 00:08:12,240
they released a

00:08:08,560 --> 00:08:16,160
dev board for a pc

00:08:12,240 --> 00:08:16,160
in risk five a couple days ago

00:08:17,280 --> 00:08:22,080
so it's kind of a very nice orthogonal

00:08:20,240 --> 00:08:26,000
instruction set to learn on

00:08:22,080 --> 00:08:29,199
and it's probably going to be the future

00:08:26,000 --> 00:08:30,240
what is renode it's a simulator designed

00:08:29,199 --> 00:08:33,120
for

00:08:30,240 --> 00:08:34,159
testing and debugging uh embedded

00:08:33,120 --> 00:08:37,200
firmware

00:08:34,159 --> 00:08:41,360
so you have uh

00:08:37,200 --> 00:08:43,680
qemu but that that's kind of

00:08:41,360 --> 00:08:45,200
um you classically used for running

00:08:43,680 --> 00:08:46,880
desktop applications across

00:08:45,200 --> 00:08:50,399
architectures on linux

00:08:46,880 --> 00:08:50,800
but renode is a little bit more friendly

00:08:50,399 --> 00:08:53,519
to

00:08:50,800 --> 00:08:54,000
embedded devices um i found it has a

00:08:53,519 --> 00:08:56,399
really nice

00:08:54,000 --> 00:08:57,120
tool set you can add leds to blank you

00:08:56,399 --> 00:08:59,279
can add

00:08:57,120 --> 00:09:00,480
serial controls and it's all configured

00:08:59,279 --> 00:09:03,600
by a very

00:09:00,480 --> 00:09:05,200
simple uh configuration file format

00:09:03,600 --> 00:09:07,120
and you can even set up networks of

00:09:05,200 --> 00:09:08,720
multiple devices and simulate that all

00:09:07,120 --> 00:09:13,600
as a whole

00:09:08,720 --> 00:09:16,000
um for you can uh

00:09:13,600 --> 00:09:18,160
you can also like piecemeal out simulate

00:09:16,000 --> 00:09:19,920
some and connect real hardware to some

00:09:18,160 --> 00:09:21,760
just kind of like a hybrid simulation

00:09:19,920 --> 00:09:23,040
environment but it's growing in

00:09:21,760 --> 00:09:25,839
popularity

00:09:23,040 --> 00:09:28,560
among a couple different sets of people

00:09:25,839 --> 00:09:29,440
embedded and like fpga embedded also you

00:09:28,560 --> 00:09:32,320
can run

00:09:29,440 --> 00:09:32,320
using renode

00:09:33,440 --> 00:09:38,720
um you could think of a emulator

00:09:36,800 --> 00:09:41,200
when you're playing a video game it has

00:09:38,720 --> 00:09:43,920
a certain one single processor

00:09:41,200 --> 00:09:46,000
and a certain graphics card and a

00:09:43,920 --> 00:09:47,680
certain way to produce audio

00:09:46,000 --> 00:09:50,240
and all those are tuned like if you have

00:09:47,680 --> 00:09:52,160
a nintendo it it acts a certain way and

00:09:50,240 --> 00:09:55,440
it's always configured the same way

00:09:52,160 --> 00:09:57,680
or uh some other platform

00:09:55,440 --> 00:09:58,959
would would be kind of like a static

00:09:57,680 --> 00:10:01,760
renode

00:09:58,959 --> 00:10:02,640
with the configuration file you can say

00:10:01,760 --> 00:10:04,800
add

00:10:02,640 --> 00:10:05,760
the different pieces of the cpu to

00:10:04,800 --> 00:10:09,839
whatever you want

00:10:05,760 --> 00:10:14,000
into that system and then put it in

00:10:09,839 --> 00:10:14,000
and load your rom onto that system

00:10:16,560 --> 00:10:20,560
so what is my tool chain

00:10:20,880 --> 00:10:28,320
i use the gcc risk 5

00:10:24,560 --> 00:10:30,079
tool set so in order to run risk 5

00:10:28,320 --> 00:10:31,600
we're going to need to make a cross

00:10:30,079 --> 00:10:33,680
compiling tool chain so you can't use

00:10:31,600 --> 00:10:36,000
the gcc that comes with your system

00:10:33,680 --> 00:10:39,120
you have to build a special gcc that

00:10:36,000 --> 00:10:42,480
will run on x86 but compile

00:10:39,120 --> 00:10:42,480
to risk five

00:10:42,800 --> 00:10:46,160
um so once you build the tool chain it

00:10:44,720 --> 00:10:48,560
takes a while

00:10:46,160 --> 00:10:50,240
you can pull down the sources and

00:10:48,560 --> 00:10:52,880
compile from scratch and

00:10:50,240 --> 00:10:54,320
the thing that you'll be running will be

00:10:52,880 --> 00:10:56,880
uh

00:10:54,320 --> 00:10:57,360
of many others is calls but it will look

00:10:56,880 --> 00:11:00,480
like this

00:10:57,360 --> 00:11:02,000
risk 532 so that's the architecture it

00:11:00,480 --> 00:11:05,360
also comes with the gdb

00:11:02,000 --> 00:11:07,920
bin utils and other executables in that

00:11:05,360 --> 00:11:07,920
tool chain

00:11:09,680 --> 00:11:14,000
um so renaud it runs on the mono

00:11:12,640 --> 00:11:16,640
framework so it's

00:11:14,000 --> 00:11:18,560
actually a dot net app but it also has

00:11:16,640 --> 00:11:21,200
some native components

00:11:18,560 --> 00:11:22,560
you can also compile this from scratch

00:11:21,200 --> 00:11:24,959
and

00:11:22,560 --> 00:11:27,519
basically once you get it compiled you

00:11:24,959 --> 00:11:30,000
just feed it this hardware configuration

00:11:27,519 --> 00:11:31,279
and you can set up a custom hardware

00:11:30,000 --> 00:11:33,440
platform

00:11:31,279 --> 00:11:35,519
for whatever you're simulating so if you

00:11:33,440 --> 00:11:37,360
have a certain development board

00:11:35,519 --> 00:11:38,800
it has you could tell it how much ram

00:11:37,360 --> 00:11:42,000
tell it what kind of a

00:11:38,800 --> 00:11:43,440
cpu and plug in different levels

00:11:42,000 --> 00:11:46,000
of emulation for each of those

00:11:43,440 --> 00:11:48,000
components

00:11:46,000 --> 00:11:50,560
and uh it does like the logging and

00:11:48,000 --> 00:11:51,760
input output for that

00:11:50,560 --> 00:11:57,279
so the first thing we're going to go

00:11:51,760 --> 00:12:00,560
over is a simple example

00:11:57,279 --> 00:12:00,560
we're going to blink an led

00:12:00,800 --> 00:12:04,240
this is the fun part of the talk

00:12:06,959 --> 00:12:13,120
um so basically

00:12:10,399 --> 00:12:15,200
if you pull down my repo this is the

00:12:13,120 --> 00:12:18,240
bare minimum you need to get started

00:12:15,200 --> 00:12:20,320
is if you get into the one underscore

00:12:18,240 --> 00:12:22,839
blinky folder

00:12:20,320 --> 00:12:25,680
activate the tool chain and call make

00:12:22,839 --> 00:12:28,959
launch

00:12:25,680 --> 00:12:30,639
you start up the reno emulator

00:12:28,959 --> 00:12:34,000
and this is the monitor terminal that

00:12:30,639 --> 00:12:36,959
controls reno itself

00:12:34,000 --> 00:12:39,440
and you can see i've turned on logging

00:12:36,959 --> 00:12:41,680
and this is the led blinking

00:12:39,440 --> 00:12:43,839
i don't have a physical led but i'm

00:12:41,680 --> 00:12:46,000
logging out whenever the led turns on

00:12:43,839 --> 00:12:47,680
and off

00:12:46,000 --> 00:12:49,519
and the really cool thing about running

00:12:47,680 --> 00:12:51,519
this in reno'd

00:12:49,519 --> 00:12:52,880
as compared to say putting it onto

00:12:51,519 --> 00:12:54,720
actual hardware

00:12:52,880 --> 00:12:55,920
this is very easy to recompile and

00:12:54,720 --> 00:12:57,360
change and make it do something

00:12:55,920 --> 00:12:59,600
different

00:12:57,360 --> 00:13:02,240
and it's also very easy to debug so i've

00:12:59,600 --> 00:13:07,040
also set up the debug commands

00:13:02,240 --> 00:13:09,760
so that it has started a gdb server here

00:13:07,040 --> 00:13:11,120
and i can go in and see exactly where in

00:13:09,760 --> 00:13:13,360
the assembly

00:13:11,120 --> 00:13:15,120
and in the actual compiled binary we're

00:13:13,360 --> 00:13:17,279
stepping

00:13:15,120 --> 00:13:19,680
and so now at this gdp prompt if i

00:13:17,279 --> 00:13:22,320
wanted to step through the instructions

00:13:19,680 --> 00:13:24,560
one by one you can see we're in the

00:13:22,320 --> 00:13:26,399
delay loop

00:13:24,560 --> 00:13:27,760
it's a very big delay loop when you're

00:13:26,399 --> 00:13:29,040
going at one hertz

00:13:27,760 --> 00:13:31,600
so what we're going to do is set a

00:13:29,040 --> 00:13:31,600
breakpoint

00:13:32,399 --> 00:13:40,639
and at the toggle led

00:13:37,279 --> 00:13:40,639
um location

00:13:43,760 --> 00:13:48,399
let's see if i got this right

00:13:46,880 --> 00:13:50,959
okay so now i've set up a break point

00:13:48,399 --> 00:13:52,160
here and now i can continue

00:13:50,959 --> 00:13:53,839
and now it's running through the delay

00:13:52,160 --> 00:13:54,720
loop it's slower because i have gdb

00:13:53,839 --> 00:13:57,839
attached but

00:13:54,720 --> 00:13:59,360
finally we get here and we break

00:13:57,839 --> 00:14:00,639
and we're going to step through these

00:13:59,360 --> 00:14:02,959
four instructions we're going to read in

00:14:00,639 --> 00:14:06,480
the old led state into a register

00:14:02,959 --> 00:14:09,760
from ram we're going to xor with

00:14:06,480 --> 00:14:13,120
this bit mask here so

00:14:09,760 --> 00:14:15,839
this is led 1 1 and this is led

00:14:13,120 --> 00:14:17,360
0 so we're only going to be toggling led

00:14:15,839 --> 00:14:21,040
zero and you can see where it says

00:14:17,360 --> 00:14:22,320
led uh state changed false state change

00:14:21,040 --> 00:14:25,839
true

00:14:22,320 --> 00:14:27,760
and we go through here i will say

00:14:25,839 --> 00:14:29,120
step instruction so now we've read the

00:14:27,760 --> 00:14:32,720
state

00:14:29,120 --> 00:14:34,480
we've applied the mask we swapped it out

00:14:32,720 --> 00:14:35,199
and then we write it so we got the state

00:14:34,480 --> 00:14:38,639
change

00:14:35,199 --> 00:14:40,000
and now it says false now we go through

00:14:38,639 --> 00:14:43,519
and we're back we're stuck

00:14:40,000 --> 00:14:44,000
we're in that loop again so if i say

00:14:43,519 --> 00:14:47,279
continue

00:14:44,000 --> 00:14:49,600
i get back in there and we could do that

00:14:47,279 --> 00:14:49,600
again

00:14:50,880 --> 00:14:55,760
so i'm going to quit here and it ends

00:14:54,320 --> 00:14:59,360
the renowed session and

00:14:55,760 --> 00:15:03,360
now i can exit from gdb

00:14:59,360 --> 00:15:03,360
and if i wanted to change that bitmask

00:15:06,079 --> 00:15:13,760
come in here and

00:15:10,800 --> 00:15:14,720
you can see where we've said how much to

00:15:13,760 --> 00:15:16,399
delay

00:15:14,720 --> 00:15:18,240
but here's the mask so i'm going to just

00:15:16,399 --> 00:15:22,959
change this to

00:15:18,240 --> 00:15:22,959
a one so now it's masking both leds

00:15:23,760 --> 00:15:31,600
and come over here i can recompile

00:15:28,079 --> 00:15:35,120
so it ran this risk 5 gcc

00:15:31,600 --> 00:15:38,839
bare metal and now you can see both led

00:15:35,120 --> 00:15:41,279
0 and led 1 are both blinking

00:15:38,839 --> 00:15:44,399
alternately

00:15:41,279 --> 00:15:46,959
and so as you can see it's a very uh

00:15:44,399 --> 00:15:48,880
fast iteration environment where we can

00:15:46,959 --> 00:15:50,800
go through

00:15:48,880 --> 00:15:52,160
and change your software change the

00:15:50,800 --> 00:15:54,800
firmware reload

00:15:52,160 --> 00:15:56,240
it reload it into hardware and test so

00:15:54,800 --> 00:15:58,399
if you're building something substantial

00:15:56,240 --> 00:16:00,959
this is great you don't have to wait

00:15:58,399 --> 00:16:02,560
make some image flash it onto a chip and

00:16:00,959 --> 00:16:03,519
then get some feedback and then how do

00:16:02,560 --> 00:16:06,000
you debug

00:16:03,519 --> 00:16:07,680
you know and typically you'd hook up an

00:16:06,000 --> 00:16:10,160
actual hardware debugger

00:16:07,680 --> 00:16:10,800
or some sort of jtag so that you can get

00:16:10,160 --> 00:16:13,279
gdb

00:16:10,800 --> 00:16:14,079
on the real hardware but for the first

00:16:13,279 --> 00:16:15,600
00:16:14,079 --> 00:16:17,360
of integration it would be really nice

00:16:15,600 --> 00:16:18,959
if you could do it all on

00:16:17,360 --> 00:16:21,759
your laptop especially if you have a

00:16:18,959 --> 00:16:24,800
fast emulator

00:16:21,759 --> 00:16:26,639
so what did i just run there

00:16:24,800 --> 00:16:28,000
when i say there's a configuration file

00:16:26,639 --> 00:16:30,639
for renode

00:16:28,000 --> 00:16:31,839
this is what i'm talking about this

00:16:30,639 --> 00:16:35,600
entire thing

00:16:31,839 --> 00:16:38,959
specifies the platform the system

00:16:35,600 --> 00:16:39,759
so i say we have memory attached to the

00:16:38,959 --> 00:16:43,759
system bus

00:16:39,759 --> 00:16:46,079
at location zero and the memory

00:16:43,759 --> 00:16:46,079
is

00:16:47,839 --> 00:16:53,279
this is hex but there's a certain number

00:16:50,320 --> 00:16:55,440
of bytes this way more than i need

00:16:53,279 --> 00:16:57,279
and we specify that we connect a cpu

00:16:55,440 --> 00:16:58,720
also to the system bus

00:16:57,279 --> 00:17:00,240
um so basically this is like kind of

00:16:58,720 --> 00:17:02,480
like plugging you could think of system

00:17:00,240 --> 00:17:03,759
bus is plugging into the motherboard

00:17:02,480 --> 00:17:06,640
and then the only thing that's in the

00:17:03,759 --> 00:17:10,240
motherboard are these two leds

00:17:06,640 --> 00:17:12,000
and a piece of gpio hardware

00:17:10,240 --> 00:17:14,000
and you can see where it says at system

00:17:12,000 --> 00:17:16,880
bus with a certain memory location

00:17:14,000 --> 00:17:19,360
what that's saying is it's memory

00:17:16,880 --> 00:17:21,760
mapping your gpio port

00:17:19,360 --> 00:17:22,720
onto the memory at a different location

00:17:21,760 --> 00:17:24,959
so

00:17:22,720 --> 00:17:26,319
if you were to write an assembly to read

00:17:24,959 --> 00:17:28,799
and write to memory

00:17:26,319 --> 00:17:31,039
or to one of these locations below forty

00:17:28,799 --> 00:17:33,360
thousand hex

00:17:31,039 --> 00:17:34,799
you'd be manipulating an actual stateful

00:17:33,360 --> 00:17:37,440
memory

00:17:34,799 --> 00:17:39,360
but if you interact and use your cpu

00:17:37,440 --> 00:17:42,400
instructions to read and write

00:17:39,360 --> 00:17:45,440
to this location you're you're

00:17:42,400 --> 00:17:46,799
writing to the emulated hardware and

00:17:45,440 --> 00:17:48,480
putting the state of what you want the

00:17:46,799 --> 00:17:50,720
leds to be

00:17:48,480 --> 00:17:52,400
into this location so what we were doing

00:17:50,720 --> 00:17:54,960
in that assembly level program

00:17:52,400 --> 00:17:55,919
that we just looked at we were reading

00:17:54,960 --> 00:17:58,559
reading and writing

00:17:55,919 --> 00:18:00,240
a byte to this memory location and that

00:17:58,559 --> 00:18:02,000
byte was being then

00:18:00,240 --> 00:18:03,679
taken by the simulated hardware and put

00:18:02,000 --> 00:18:06,320
out onto the leds

00:18:03,679 --> 00:18:08,640
um this is showing how to make a

00:18:06,320 --> 00:18:12,160
connection that the arrow means

00:18:08,640 --> 00:18:13,280
connect this gpio port 0 up to this led

00:18:12,160 --> 00:18:16,240
that's defined here so

00:18:13,280 --> 00:18:17,760
here we say we have leds and here's

00:18:16,240 --> 00:18:19,760
where we say make the connection from

00:18:17,760 --> 00:18:21,520
gpio to the led

00:18:19,760 --> 00:18:23,919
and then we turn on debugging for that

00:18:21,520 --> 00:18:26,840
led

00:18:23,919 --> 00:18:28,000
um and so that sets up the hardware

00:18:26,840 --> 00:18:29,840
platform

00:18:28,000 --> 00:18:31,520
initializing the hardware platform so

00:18:29,840 --> 00:18:33,760
actually loading in our firmware

00:18:31,520 --> 00:18:35,280
and doing everything it takes to run is

00:18:33,760 --> 00:18:37,760
this simple

00:18:35,280 --> 00:18:39,200
um basically we create a machine this is

00:18:37,760 --> 00:18:42,640
kind of like boilerplate

00:18:39,200 --> 00:18:46,559
load platform description and this vex

00:18:42,640 --> 00:18:47,440
risk five uh reno'd platform that's this

00:18:46,559 --> 00:18:49,679
file

00:18:47,440 --> 00:18:50,559
so basically it's a script that's saying

00:18:49,679 --> 00:18:51,760
you know we're gonna create a new

00:18:50,559 --> 00:18:52,640
machine and we're gonna load this

00:18:51,760 --> 00:18:54,240
platform

00:18:52,640 --> 00:18:55,760
and so we have one instance we have one

00:18:54,240 --> 00:18:57,360
machine you know we're not creating a

00:18:55,760 --> 00:19:00,559
network here but we could

00:18:57,360 --> 00:19:04,080
there's a single machine and then we

00:19:00,559 --> 00:19:04,480
load into that machine uh an elf image

00:19:04,080 --> 00:19:06,400
so

00:19:04,480 --> 00:19:07,600
it's actually the same exact file format

00:19:06,400 --> 00:19:09,840
we don't use a custom

00:19:07,600 --> 00:19:11,360
bare metal format or raw binary we use

00:19:09,840 --> 00:19:14,559
an elf format

00:19:11,360 --> 00:19:16,559
and reno knows how to load that

00:19:14,559 --> 00:19:18,960
and put that into memory for us so it

00:19:16,559 --> 00:19:21,600
knows where the memory starts

00:19:18,960 --> 00:19:22,480
and we are able to load our image

00:19:21,600 --> 00:19:26,160
directly

00:19:22,480 --> 00:19:28,480
into memory and then the

00:19:26,160 --> 00:19:30,000
cpu has a certain location where it

00:19:28,480 --> 00:19:31,440
knows to start executing from so it's

00:19:30,000 --> 00:19:33,760
not main

00:19:31,440 --> 00:19:34,640
but it's a actual memory location i

00:19:33,760 --> 00:19:37,360
think zero

00:19:34,640 --> 00:19:39,360
or maybe it's a different jump address

00:19:37,360 --> 00:19:42,160
this starts at gdb server so

00:19:39,360 --> 00:19:43,440
this is like plugging in your jtag and

00:19:42,160 --> 00:19:44,880
this is turning on logging so we can

00:19:43,440 --> 00:19:46,320
actually see the led blink and then

00:19:44,880 --> 00:19:47,840
start is just start

00:19:46,320 --> 00:19:49,360
any of these commands could be typed

00:19:47,840 --> 00:19:52,640
into that little black reno'd prompt

00:19:49,360 --> 00:19:54,559
that you saw come up the monitor

00:19:52,640 --> 00:19:57,919
but this lets me do it repeatedly every

00:19:54,559 --> 00:19:59,280
time when i do a launch

00:19:57,919 --> 00:20:01,360
and the program we already kind of

00:19:59,280 --> 00:20:02,559
peaked at

00:20:01,360 --> 00:20:04,159
so now that you understand kind of what

00:20:02,559 --> 00:20:05,919
the harder register looks like here

00:20:04,159 --> 00:20:07,919
we're defining a constant of what that

00:20:05,919 --> 00:20:10,320
memory location is

00:20:07,919 --> 00:20:11,440
and we're saying read from that memory

00:20:10,320 --> 00:20:14,320
location

00:20:11,440 --> 00:20:16,159
now we put that we put that in here we i

00:20:14,320 --> 00:20:18,400
just leave that in register a5

00:20:16,159 --> 00:20:19,360
that's not how it would really be done

00:20:18,400 --> 00:20:21,120
but uh

00:20:19,360 --> 00:20:23,120
that's how i do it in this small example

00:20:21,120 --> 00:20:26,240
stored into register five

00:20:23,120 --> 00:20:27,760
and we read the values from it apply

00:20:26,240 --> 00:20:29,039
that bit mask and then rewrite it to

00:20:27,760 --> 00:20:30,880
that memory location

00:20:29,039 --> 00:20:32,400
and then the simulated hardware or

00:20:30,880 --> 00:20:35,919
emulated hardware

00:20:32,400 --> 00:20:39,440
will pick up that change when we write

00:20:35,919 --> 00:20:39,440
and toggle that led

00:20:43,520 --> 00:20:48,080
so everything that it takes to make this

00:20:45,919 --> 00:20:50,240
elf binary is right here

00:20:48,080 --> 00:20:51,760
so we're right now we only have an

00:20:50,240 --> 00:20:54,240
assembly file but you can also

00:20:51,760 --> 00:20:56,159
compile c to bare metal that's very easy

00:20:54,240 --> 00:20:58,320
as standard

00:20:56,159 --> 00:20:59,919
um i turned on gdb so we can have all

00:20:58,320 --> 00:21:01,440
the symbols in reference so that when

00:20:59,919 --> 00:21:02,240
you're in your gdb console you can

00:21:01,440 --> 00:21:04,880
reference

00:21:02,240 --> 00:21:06,159
uh particular spots in memory uh turn

00:21:04,880 --> 00:21:09,039
off optimization

00:21:06,159 --> 00:21:10,880
so that your instructions can map

00:21:09,039 --> 00:21:11,919
directly to lines of code rather than

00:21:10,880 --> 00:21:13,760
jump around or

00:21:11,919 --> 00:21:16,880
inline some functions this gives you

00:21:13,760 --> 00:21:20,000
kind of verbatim what you've asked for

00:21:16,880 --> 00:21:21,520
name of your output file and we tell it

00:21:20,000 --> 00:21:23,039
don't use main don't assume we have an

00:21:21,520 --> 00:21:24,720
operating system don't rely on

00:21:23,039 --> 00:21:26,320
any header files having the same

00:21:24,720 --> 00:21:29,600
semantic meaning

00:21:26,320 --> 00:21:32,000
and uh

00:21:29,600 --> 00:21:32,880
don't use a standard library so it's

00:21:32,000 --> 00:21:35,600
basically

00:21:32,880 --> 00:21:39,200
mechanically translating c code into

00:21:35,600 --> 00:21:39,200
machine code in risk five

00:21:40,159 --> 00:21:44,000
so now we're gonna make a serial port or

00:21:42,640 --> 00:21:47,440
a serial connection

00:21:44,000 --> 00:21:47,440
and we're going to write a driver for it

00:21:48,640 --> 00:21:52,559
in uh in linux you kind of have an

00:21:50,880 --> 00:21:53,679
interface that you would implement maybe

00:21:52,559 --> 00:21:56,880
a character

00:21:53,679 --> 00:21:58,960
uh character block level driver

00:21:56,880 --> 00:22:00,559
for a device here we're going to talk

00:21:58,960 --> 00:22:02,480
just directly to the hardware so there's

00:22:00,559 --> 00:22:03,200
no abstraction for writing a driver it's

00:22:02,480 --> 00:22:04,880
not a

00:22:03,200 --> 00:22:06,320
it's not a module that we can load or

00:22:04,880 --> 00:22:07,919
unload at runtime

00:22:06,320 --> 00:22:13,039
it's just we are talking to the hardware

00:22:07,919 --> 00:22:14,480
register just like we did with the led

00:22:13,039 --> 00:22:16,240
so this is a more complicated example

00:22:14,480 --> 00:22:19,039
i'm showing the code at the same time

00:22:16,240 --> 00:22:19,039
let me move this

00:22:19,440 --> 00:22:21,919
preview

00:22:22,799 --> 00:22:26,000
so first i'll talk about the assembly

00:22:25,679 --> 00:22:28,240
what

00:22:26,000 --> 00:22:29,600
what do we need to do to get a serial

00:22:28,240 --> 00:22:33,360
driver running

00:22:29,600 --> 00:22:35,200
uh here is the memory location

00:22:33,360 --> 00:22:36,880
that we're going to be accessing so this

00:22:35,200 --> 00:22:41,120
uart base uart

00:22:36,880 --> 00:22:43,919
is a universal asynchronous

00:22:41,120 --> 00:22:46,159
i'm not sure but it's it's a serial

00:22:43,919 --> 00:22:49,360
connection or it can be put over serial

00:22:46,159 --> 00:22:52,000
um and each of these are the offsets for

00:22:49,360 --> 00:22:53,919
uh receive and transmit and then

00:22:52,000 --> 00:22:54,880
different signals so if the buffer gets

00:22:53,919 --> 00:22:57,120
full

00:22:54,880 --> 00:22:58,720
or if there's nothing to read these

00:22:57,120 --> 00:23:01,919
signals are turned on

00:22:58,720 --> 00:23:03,360
and writing ones and zeros to each of

00:23:01,919 --> 00:23:05,200
these registers

00:23:03,360 --> 00:23:06,480
which are offset in memory from this

00:23:05,200 --> 00:23:08,799
base

00:23:06,480 --> 00:23:10,159
allow it to read and write to that uh

00:23:08,799 --> 00:23:11,840
piece of hardware so it's

00:23:10,159 --> 00:23:14,080
it's memory mapped i o and it's going to

00:23:11,840 --> 00:23:16,159
be a serial port

00:23:14,080 --> 00:23:17,679
um other things that we didn't have to

00:23:16,159 --> 00:23:19,600
do when we were just doing a blinking

00:23:17,679 --> 00:23:22,960
led

00:23:19,600 --> 00:23:26,880
uh one of them is set up

00:23:22,960 --> 00:23:31,120
interrupts so all of this code

00:23:26,880 --> 00:23:31,120
from line 17 down to

00:23:31,919 --> 00:23:38,640
42 is turning on

00:23:35,039 --> 00:23:41,520
interrupts saying uh

00:23:38,640 --> 00:23:43,679
where where to jump in the binary when

00:23:41,520 --> 00:23:46,400
you do hit a machine level interrupt

00:23:43,679 --> 00:23:48,559
so the handler for that interrupt and

00:23:46,400 --> 00:23:51,440
setting up a stack so that we can use

00:23:48,559 --> 00:23:52,640
c functions and when you do a context

00:23:51,440 --> 00:23:56,720
switch it'll take all your

00:23:52,640 --> 00:23:58,400
registers from your cpu put it into the

00:23:56,720 --> 00:24:00,080
stack and store it for later so when you

00:23:58,400 --> 00:24:01,679
return you can

00:24:00,080 --> 00:24:04,000
put those back for a while i didn't set

00:24:01,679 --> 00:24:05,919
up the stack and when i'd call a c

00:24:04,000 --> 00:24:07,520
function it would just keep overwriting

00:24:05,919 --> 00:24:08,240
the same spot because there's no stack

00:24:07,520 --> 00:24:10,320
pointer

00:24:08,240 --> 00:24:12,080
and so basically i there there was no

00:24:10,320 --> 00:24:14,240
stack and i couldn't return out of the

00:24:12,080 --> 00:24:16,720
function so it would just go execute

00:24:14,240 --> 00:24:18,080
off into nowhere it was kind of

00:24:16,720 --> 00:24:19,679
mysterious behavior

00:24:18,080 --> 00:24:20,960
but that's what you don't get any of

00:24:19,679 --> 00:24:22,640
those luxuries you have to set that up

00:24:20,960 --> 00:24:24,240
yourself

00:24:22,640 --> 00:24:25,840
um everything we're running here is at

00:24:24,240 --> 00:24:28,480
like the machine level

00:24:25,840 --> 00:24:29,279
or emma mode so it's not supervised mode

00:24:28,480 --> 00:24:32,720
this is like running

00:24:29,279 --> 00:24:36,320
in like the ring zero or ring one of the

00:24:32,720 --> 00:24:37,360
uh in like the highest privileged ring

00:24:36,320 --> 00:24:39,039
in x86

00:24:37,360 --> 00:24:40,720
that's what machine mode is we don't do

00:24:39,039 --> 00:24:42,559
anything with making

00:24:40,720 --> 00:24:45,279
other processes we're running kind of as

00:24:42,559 --> 00:24:45,279
a kernel here

00:24:45,600 --> 00:24:51,440
and all the driver is is

00:24:48,640 --> 00:24:53,279
this mt vec is whenever we get a machine

00:24:51,440 --> 00:24:54,559
level interrupt

00:24:53,279 --> 00:24:56,640
right now we're just going to assume

00:24:54,559 --> 00:24:57,919
that it's the uh uart because it's the

00:24:56,640 --> 00:24:58,880
only piece of hardware that's attached

00:24:57,919 --> 00:25:00,320
it's the only thing could throw the

00:24:58,880 --> 00:25:02,799
interrupt

00:25:00,320 --> 00:25:04,880
and so what we're going to do is receive

00:25:02,799 --> 00:25:07,520
that character

00:25:04,880 --> 00:25:08,240
and we're going to call this a function

00:25:07,520 --> 00:25:11,679
this is a

00:25:08,240 --> 00:25:15,200
pseudo instruction that will call

00:25:11,679 --> 00:25:18,640
this which is defined in c

00:25:15,200 --> 00:25:21,360
and fancy character basically says

00:25:18,640 --> 00:25:22,240
we have this character array and we're

00:25:21,360 --> 00:25:23,760
going to plug in

00:25:22,240 --> 00:25:25,200
a single character so kind of

00:25:23,760 --> 00:25:26,640
surrounding a character by a bunch of

00:25:25,200 --> 00:25:28,799
hash signs

00:25:26,640 --> 00:25:30,320
and we had to write the print function

00:25:28,799 --> 00:25:32,240
loop over those characters print them

00:25:30,320 --> 00:25:34,480
out and make sure we get the right uh

00:25:32,240 --> 00:25:36,000
uart base in there into the register

00:25:34,480 --> 00:25:38,000
that we're going to use

00:25:36,000 --> 00:25:39,520
because uh you can see we're putting the

00:25:38,000 --> 00:25:42,559
uart base into

00:25:39,520 --> 00:25:45,919
register a2 and then this uh

00:25:42,559 --> 00:25:46,960
put c that relies on that a2 being your

00:25:45,919 --> 00:25:49,679
uart base

00:25:46,960 --> 00:25:51,120
and we're saying write this character

00:25:49,679 --> 00:25:54,880
this byte

00:25:51,120 --> 00:25:56,400
into the register rxtx and then it fires

00:25:54,880 --> 00:25:57,840
off uh

00:25:56,400 --> 00:26:00,720
with the hardware and the hardware knows

00:25:57,840 --> 00:26:05,840
how to connect that um to my gui

00:26:00,720 --> 00:26:05,840
so let's run through this or do a demo

00:26:05,919 --> 00:26:12,240
so hit make launch and we're gonna get

00:26:08,880 --> 00:26:12,240
the monitor window here again

00:26:12,480 --> 00:26:19,039
and over here i'm going to

00:26:16,000 --> 00:26:21,919
connect via telnet to

00:26:19,039 --> 00:26:22,720
a telnet server that reno just spawned

00:26:21,919 --> 00:26:24,480
for me

00:26:22,720 --> 00:26:26,159
that connects up to that virtual uart so

00:26:24,480 --> 00:26:29,279
the uart has an interface to say

00:26:26,159 --> 00:26:32,000
hey connect this to a virtual serial and

00:26:29,279 --> 00:26:33,679
so now when i type into here

00:26:32,000 --> 00:26:36,159
it receives the character and echoes it

00:26:33,679 --> 00:26:36,159
back to me

00:26:36,840 --> 00:26:42,240
hello and it just prints it

00:26:39,200 --> 00:26:46,080
back echoes it back but fancy

00:26:42,240 --> 00:26:48,320
so a lot all of this is just

00:26:46,080 --> 00:26:50,640
to handle that uh interrupt and get back

00:26:48,320 --> 00:26:50,640
to you

00:26:50,840 --> 00:26:56,000
um so that's that example

00:26:57,600 --> 00:27:07,840
let me close out here

00:27:12,240 --> 00:27:16,400
okay so let's bring it all back together

00:27:16,880 --> 00:27:20,799
so kind of the theme here and motivation

00:27:19,120 --> 00:27:21,760
is understanding how operating systems

00:27:20,799 --> 00:27:23,679
work

00:27:21,760 --> 00:27:24,880
kind of take it for granted that you

00:27:23,679 --> 00:27:26,480
plug in a hard drive

00:27:24,880 --> 00:27:28,080
and you can partition it and just start

00:27:26,480 --> 00:27:30,960
writing files

00:27:28,080 --> 00:27:33,360
uh but there's so much more um and the

00:27:30,960 --> 00:27:35,440
reason that operating systems even exist

00:27:33,360 --> 00:27:36,559
so i always like to say the first

00:27:35,440 --> 00:27:39,039
operating system

00:27:36,559 --> 00:27:40,720
were human operators it was literally a

00:27:39,039 --> 00:27:42,399
system that they followed

00:27:40,720 --> 00:27:45,679
everything was batch processed and you

00:27:42,399 --> 00:27:48,559
had kind of one set of instructions that

00:27:45,679 --> 00:27:50,159
you would ran run on a new set of data

00:27:48,559 --> 00:27:51,760
over and over again

00:27:50,159 --> 00:27:54,399
and every single program had full

00:27:51,760 --> 00:27:57,440
control of the system like i just did

00:27:54,399 --> 00:28:00,960
any uh any instruction could write to

00:27:57,440 --> 00:28:02,159
any bit of memory and you would just run

00:28:00,960 --> 00:28:03,520
through straight and there were no

00:28:02,159 --> 00:28:05,760
interruptions

00:28:03,520 --> 00:28:08,240
um things changed when you finally had

00:28:05,760 --> 00:28:11,279
like a pdp one

00:28:08,240 --> 00:28:12,080
it's an interactive uh interactive

00:28:11,279 --> 00:28:13,840
system where

00:28:12,080 --> 00:28:15,760
you could say interrupt the program and

00:28:13,840 --> 00:28:18,159
have something else happen

00:28:15,760 --> 00:28:18,960
and so what an operating system gives

00:28:18,159 --> 00:28:21,279
you

00:28:18,960 --> 00:28:22,960
is a way to get away from the hardware

00:28:21,279 --> 00:28:25,760
they give you standard interfaces to

00:28:22,960 --> 00:28:28,080
talk to the real world

00:28:25,760 --> 00:28:28,960
these come in the form of drivers memory

00:28:28,080 --> 00:28:32,000
allocation

00:28:28,960 --> 00:28:33,440
file systems and processes so but the

00:28:32,000 --> 00:28:34,799
example i just showed you didn't have

00:28:33,440 --> 00:28:38,720
any processes

00:28:34,799 --> 00:28:40,320
um so that's kind of the next step that

00:28:38,720 --> 00:28:42,480
i want to take i want to start building

00:28:40,320 --> 00:28:46,000
a real-time operating system

00:28:42,480 --> 00:28:49,279
that would that you would be able to uh

00:28:46,000 --> 00:28:51,360
take a small another program and

00:28:49,279 --> 00:28:53,279
load it at runtime like i could type

00:28:51,360 --> 00:28:56,080
into my serial terminal

00:28:53,279 --> 00:28:58,559
a command and load in a new program that

00:28:56,080 --> 00:29:00,240
runs and interacts with that

00:28:58,559 --> 00:29:03,440
virtual operating system or the the

00:29:00,240 --> 00:29:03,440
small rtos

00:29:04,799 --> 00:29:07,039
um

00:29:07,919 --> 00:29:11,200
the other thing that operating systems

00:29:09,279 --> 00:29:14,159
do is instead of doing one thing all the

00:29:11,200 --> 00:29:16,080
time so right there i was sitting in a

00:29:14,159 --> 00:29:18,080
a polling loop saying there's nothing to

00:29:16,080 --> 00:29:20,720
do i'm waiting for an interrupt

00:29:18,080 --> 00:29:22,159
uh back in back in the batch processing

00:29:20,720 --> 00:29:23,919
days you you want to do that you'd sit

00:29:22,159 --> 00:29:25,520
there and run all the way through

00:29:23,919 --> 00:29:27,520
when you time share and you have a whole

00:29:25,520 --> 00:29:28,960
bunch of processes you could have two

00:29:27,520 --> 00:29:30,159
programmings running at once and it's

00:29:28,960 --> 00:29:31,760
kind of like

00:29:30,159 --> 00:29:33,679
chopping up the time of your program

00:29:31,760 --> 00:29:35,200
saying okay run this for a millisecond

00:29:33,679 --> 00:29:37,919
run this other program for mill saying

00:29:35,200 --> 00:29:39,760
you have 200 programs running at once

00:29:37,919 --> 00:29:41,679
and so it's kind of interesting to think

00:29:39,760 --> 00:29:43,039
like if you had to change your card deck

00:29:41,679 --> 00:29:45,600
100 times a second it'd just be

00:29:43,039 --> 00:29:45,600
impossible

00:29:48,320 --> 00:29:52,159
so other things that i would explore in

00:29:50,559 --> 00:29:54,320
this kind of area

00:29:52,159 --> 00:29:55,360
is how to do process control what would

00:29:54,320 --> 00:29:57,840
it take to

00:29:55,360 --> 00:29:59,360
make a simple program that could run on

00:29:57,840 --> 00:30:01,679
the bare metal

00:29:59,360 --> 00:30:02,960
and display you up a little menu and

00:30:01,679 --> 00:30:05,840
allow you to

00:30:02,960 --> 00:30:07,600
run a another elf you know it could be

00:30:05,840 --> 00:30:09,760
the loader for the next elf

00:30:07,600 --> 00:30:11,120
program so what is the minimum amount of

00:30:09,760 --> 00:30:13,120
code

00:30:11,120 --> 00:30:15,840
where you can make a loader for another

00:30:13,120 --> 00:30:17,679
program it shouldn't be too much

00:30:15,840 --> 00:30:19,360
i'm concurrency so instead of just

00:30:17,679 --> 00:30:21,120
loading one other program

00:30:19,360 --> 00:30:24,000
how can i make it split the time of the

00:30:21,120 --> 00:30:26,320
cpu between running more than one

00:30:24,000 --> 00:30:29,200
other program at a time and share the

00:30:26,320 --> 00:30:30,399
hardware that's a much harder problem

00:30:29,200 --> 00:30:33,279
but it'd be very interesting to

00:30:30,399 --> 00:30:34,720
understand that so one method is kind of

00:30:33,279 --> 00:30:38,320
a simple polling loop

00:30:34,720 --> 00:30:41,039
but you could also do something

00:30:38,320 --> 00:30:41,039
more fancy

00:30:41,919 --> 00:30:45,279
memory management so how do you how you

00:30:43,679 --> 00:30:46,880
say this program you get this little

00:30:45,279 --> 00:30:48,840
piece of virtual memory and this other

00:30:46,880 --> 00:30:51,760
program you get another piece of memory

00:30:48,840 --> 00:30:53,440
basically you work with the hardware and

00:30:51,760 --> 00:30:55,520
tell the hardware

00:30:53,440 --> 00:30:57,120
this this is running under this context

00:30:55,520 --> 00:30:58,240
and you only get like the small amount

00:30:57,120 --> 00:31:00,159
of memory

00:30:58,240 --> 00:31:01,679
and it looks like it has control of an

00:31:00,159 --> 00:31:03,279
entire world but really it's just kind

00:31:01,679 --> 00:31:05,840
of a subset

00:31:03,279 --> 00:31:08,080
um how do we handle it when we do like a

00:31:05,840 --> 00:31:09,840
divide by zero of a software interrupt

00:31:08,080 --> 00:31:12,880
something bad that happens in the cpu

00:31:09,840 --> 00:31:14,399
you need to recover from that

00:31:12,880 --> 00:31:16,399
um so all of these things could be

00:31:14,399 --> 00:31:18,480
explored by developing an rtos

00:31:16,399 --> 00:31:20,080
or a real-time operating system

00:31:18,480 --> 00:31:22,000
something very minimal a toy operating

00:31:20,080 --> 00:31:24,159
system just something for learning

00:31:22,000 --> 00:31:25,440
um you know there's production rtos is

00:31:24,159 --> 00:31:27,600
like zephyr

00:31:25,440 --> 00:31:29,279
but i just want to build something uh to

00:31:27,600 --> 00:31:31,200
learn

00:31:29,279 --> 00:31:32,640
and after that i'd love to you know run

00:31:31,200 --> 00:31:33,360
it on renode and then run it on real

00:31:32,640 --> 00:31:35,440
hardware

00:31:33,360 --> 00:31:38,480
there's a whole bunch of uh people that

00:31:35,440 --> 00:31:38,480
they build um

00:31:38,880 --> 00:31:42,240
they have they have hardware development

00:31:40,480 --> 00:31:44,640
boards for their hardware

00:31:42,240 --> 00:31:46,240
and then they build the reno'd models

00:31:44,640 --> 00:31:47,279
for you so you can pull in their

00:31:46,240 --> 00:31:48,640
platform

00:31:47,279 --> 00:31:50,399
test you could you could test and

00:31:48,640 --> 00:31:51,200
develop software and not even have their

00:31:50,399 --> 00:31:52,880
hardware

00:31:51,200 --> 00:31:55,120
so i want to know what that process is

00:31:52,880 --> 00:31:55,120
like

00:31:57,039 --> 00:32:03,519
um so thank you uh

00:32:00,399 --> 00:32:05,840
i'm not sure on my time here but

00:32:03,519 --> 00:32:06,960
i want to cover uh basically what what

00:32:05,840 --> 00:32:10,000
i've covered here

00:32:06,960 --> 00:32:10,880
is available at on my blog or will be

00:32:10,000 --> 00:32:14,080
soon

00:32:10,880 --> 00:32:16,240
and i'm going to be covering building

00:32:14,080 --> 00:32:19,039
kind of a real-time operating system and

00:32:16,240 --> 00:32:21,360
following some more of these follow-ups

00:32:19,039 --> 00:32:24,559
just to learn more

00:32:21,360 --> 00:32:27,440
there's a very good youtube series

00:32:24,559 --> 00:32:28,159
if you search miros or mira samick

00:32:27,440 --> 00:32:30,480
you'll find

00:32:28,159 --> 00:32:31,679
uh it's like a 17 part series on

00:32:30,480 --> 00:32:33,120
building a

00:32:31,679 --> 00:32:34,720
real-time operating system after he

00:32:33,120 --> 00:32:36,320
teaches you the fundamentals

00:32:34,720 --> 00:32:38,000
and he doesn't use reno and doesn't use

00:32:36,320 --> 00:32:38,960
risk five he's using arm and he's using

00:32:38,000 --> 00:32:41,360
real hardware

00:32:38,960 --> 00:32:42,399
but it's a really good introduction to

00:32:41,360 --> 00:32:44,640
modern

00:32:42,399 --> 00:32:46,559
embedded development so i'm going to

00:32:44,640 --> 00:32:47,919
kind of make a r toss in the spirit of

00:32:46,559 --> 00:32:50,320
his rtos

00:32:47,919 --> 00:32:51,919
but with risk five and using renowed um

00:32:50,320 --> 00:32:54,080
and if you want to follow that

00:32:51,919 --> 00:32:57,360
uh i'll be announcing those on my

00:32:54,080 --> 00:33:11,840
twitter handle y2k bugger

00:32:57,360 --> 00:33:11,840
thank you

00:33:12,559 --> 00:33:17,200
well thanks everyone for being part of

00:33:15,279 --> 00:33:19,600
zack's presentation here

00:33:17,200 --> 00:33:20,960
we do have some time for questions and

00:33:19,600 --> 00:33:23,440
answers so

00:33:20,960 --> 00:33:24,080
we'll pause here briefly if you have a

00:33:23,440 --> 00:33:28,000
question for

00:33:24,080 --> 00:33:31,760
zach please put it in the q a section

00:33:28,000 --> 00:33:34,159
of your zoom session right now

00:33:31,760 --> 00:33:35,600
and just a reminder for those of us who

00:33:34,159 --> 00:33:38,640
are joining on the internet

00:33:35,600 --> 00:33:39,919
at large via our youtube stream if you

00:33:38,640 --> 00:33:44,000
would like to participate

00:33:39,919 --> 00:33:44,000

YouTube URL: https://www.youtube.com/watch?v=JkeRezvCVfM


