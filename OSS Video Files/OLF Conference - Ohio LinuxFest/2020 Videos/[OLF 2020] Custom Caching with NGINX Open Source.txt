Title: [OLF 2020] Custom Caching with NGINX Open Source
Publication date: 2021-01-06
Playlist: 2020 Videos
Description: 
	Speaker: Jessica Dooley

Slide Deck: https://marchpane.net/nginx-cache-OLF2020.pdf



– NGINX Open Source is a F/OSS web server with a powerful feature set.
– Every project has a set of constraints unique to the customer’s needs.
– A small organization can build on innovations that larger teams have shared with the community. You don’t have to re-invent the wheel: ask the right questions and read the manual.

In 2014, NPR’s Digital Services team published a write-up of their NGINX “botcache” webserver configuration, designed to protect Drupal websites from excess bot-generated traffic. In 2020, their project was exactly what I was looking for. I’ll share how I used their “botcache” project write-up as a template to explore NGINX Open Source’s features, and ended up building a customized NGINX caching server that protects Drupal websites from bot-generated load and accelerates page loads while permitting unlimited customer traffic. Along the way, I’ll look at simple performance metrics, scoping a project’s goals to the customer’s desired outcomes, explore NGINX community resources, and share specific configuration choices that generated the most improvements.
Captions: 
	00:00:02,800 --> 00:00:06,799
well thank you very much

00:00:04,240 --> 00:00:07,440
um i appreciate it i'm excited to be

00:00:06,799 --> 00:00:10,480
here

00:00:07,440 --> 00:00:13,200
my name is jessica dooley and i will

00:00:10,480 --> 00:00:13,759
talk about this project as warner

00:00:13,200 --> 00:00:17,760
mentioned

00:00:13,759 --> 00:00:20,720
um a custom caching server using nginx

00:00:17,760 --> 00:00:22,400
and how i used npr digital services

00:00:20,720 --> 00:00:25,439
teams right up of their bot

00:00:22,400 --> 00:00:26,240
cache project to as a template to

00:00:25,439 --> 00:00:30,160
protect

00:00:26,240 --> 00:00:32,239
drupal websites from bot traffic um this

00:00:30,160 --> 00:00:34,000
is an operations talk basically my

00:00:32,239 --> 00:00:37,200
background is operations

00:00:34,000 --> 00:00:39,200
and i spent a number of years as an i.t

00:00:37,200 --> 00:00:41,200
generalist and i really what i really

00:00:39,200 --> 00:00:44,239
enjoy about being a generalist

00:00:41,200 --> 00:00:47,440
is that you you have hands-on with all

00:00:44,239 --> 00:00:49,120
um phases of an it service from

00:00:47,440 --> 00:00:51,440
planning it and designing it through

00:00:49,120 --> 00:00:53,680
implementation and through support

00:00:51,440 --> 00:00:54,640
um i find that really satisfying just

00:00:53,680 --> 00:00:57,199
because of the

00:00:54,640 --> 00:00:58,399
the process improvement aspect you're

00:00:57,199 --> 00:01:00,399
able to to accept

00:00:58,399 --> 00:01:02,160
feedback from your end users and sort of

00:01:00,399 --> 00:01:02,960
bake that in as you iterate in the

00:01:02,160 --> 00:01:04,559
future

00:01:02,960 --> 00:01:06,799
i've really enjoyed attending the ohio

00:01:04,559 --> 00:01:08,640
linux fest over over the last few years

00:01:06,799 --> 00:01:11,280
and i've gotten a lot of

00:01:08,640 --> 00:01:12,720
encouragement and ideas um from from

00:01:11,280 --> 00:01:16,080
listening to the presenters so

00:01:12,720 --> 00:01:18,479
a big big thank you to the whole team

00:01:16,080 --> 00:01:20,240
um and to the sponsors for making sure

00:01:18,479 --> 00:01:22,960
that ohio linux fest was able to

00:01:20,240 --> 00:01:26,080
continue this year in a virtual form

00:01:22,960 --> 00:01:28,479
um so where did this project come from

00:01:26,080 --> 00:01:30,159
last year i took a role as a linux

00:01:28,479 --> 00:01:32,880
infrastructure specialist

00:01:30,159 --> 00:01:34,000
with an organization here in columbus

00:01:32,880 --> 00:01:36,000
we're a small team

00:01:34,000 --> 00:01:37,200
that focuses primarily on internet and

00:01:36,000 --> 00:01:39,360
network services

00:01:37,200 --> 00:01:40,320
but we also provide some bespoke drupal

00:01:39,360 --> 00:01:42,079
websites

00:01:40,320 --> 00:01:44,000
and we have a web developer who is

00:01:42,079 --> 00:01:46,159
product owner for those websites and i

00:01:44,000 --> 00:01:47,439
inherited responsibility for the hosting

00:01:46,159 --> 00:01:50,560
aspect

00:01:47,439 --> 00:01:54,240
so for a sense of scale we've got

00:01:50,560 --> 00:01:56,079
80 customer websites and um

00:01:54,240 --> 00:01:57,680
they are informational and they're

00:01:56,079 --> 00:02:00,000
primarily they're primarily

00:01:57,680 --> 00:02:01,520
serving anonymous views so they're not

00:02:00,000 --> 00:02:04,479
you know people aren't creating user

00:02:01,520 --> 00:02:06,960
accounts they're not e-commerce

00:02:04,479 --> 00:02:09,440
they're being served on a lamp stack so

00:02:06,960 --> 00:02:10,800
a linux flavor with apache and mysql and

00:02:09,440 --> 00:02:13,840
php

00:02:10,800 --> 00:02:15,360
um and for a sense of scalar they see

00:02:13,840 --> 00:02:17,520
about 21 000

00:02:15,360 --> 00:02:18,400
unique visitors a day but they have a

00:02:17,520 --> 00:02:21,440
problem

00:02:18,400 --> 00:02:24,080
um so on a regular basis

00:02:21,440 --> 00:02:24,560
our monitoring would fire off an alert

00:02:24,080 --> 00:02:27,520
for

00:02:24,560 --> 00:02:28,319
a degradation of performance of on these

00:02:27,520 --> 00:02:30,160
websites

00:02:28,319 --> 00:02:31,599
there would be a big spike in requests

00:02:30,160 --> 00:02:32,640
that would cause high resource

00:02:31,599 --> 00:02:34,080
utilization

00:02:32,640 --> 00:02:36,000
to the point that the website's

00:02:34,080 --> 00:02:38,400
performance would suffer and they would

00:02:36,000 --> 00:02:40,160
slow or the server might even become

00:02:38,400 --> 00:02:43,200
unresponsive

00:02:40,160 --> 00:02:46,800
and these are not organic spikes from

00:02:43,200 --> 00:02:47,680
from customers um or actual actual users

00:02:46,800 --> 00:02:49,040
visiting the site

00:02:47,680 --> 00:02:51,120
they're they're essentially bought

00:02:49,040 --> 00:02:54,480
traffic a web crawl

00:02:51,120 --> 00:02:56,400
um a researcher maybe a security scan

00:02:54,480 --> 00:02:59,280
they'll have a user agent like python

00:02:56,400 --> 00:03:00,959
crawler or maybe it'll be 12

00:02:59,280 --> 00:03:03,120
adjacent ip addresses that are

00:03:00,959 --> 00:03:04,720
registered to a cloud hosting provider

00:03:03,120 --> 00:03:06,959
and they're just kind of hammering the

00:03:04,720 --> 00:03:09,920
website with requests

00:03:06,959 --> 00:03:12,159
for um older content they're essentially

00:03:09,920 --> 00:03:14,640
crawling the whole site

00:03:12,159 --> 00:03:16,239
and that traffic is impacting the

00:03:14,640 --> 00:03:17,280
availability and the performance of the

00:03:16,239 --> 00:03:20,080
websites

00:03:17,280 --> 00:03:21,440
and that's far from optimal that's not

00:03:20,080 --> 00:03:24,720
ideal at all i really don't

00:03:21,440 --> 00:03:27,040
want that to happen um it shouldn't be

00:03:24,720 --> 00:03:29,760
possible so what can i do to make

00:03:27,040 --> 00:03:31,440
that not happen i could throw more

00:03:29,760 --> 00:03:32,799
system resources at the problem but

00:03:31,440 --> 00:03:35,040
that's not a good answer

00:03:32,799 --> 00:03:36,239
it costs more and i don't need all of

00:03:35,040 --> 00:03:38,560
those system resources

00:03:36,239 --> 00:03:39,920
all of the time and if i use an auto

00:03:38,560 --> 00:03:41,680
scaling solution

00:03:39,920 --> 00:03:43,680
i don't think i'm seeing a business

00:03:41,680 --> 00:03:46,239
return on investment

00:03:43,680 --> 00:03:46,959
on that because i'm just feeding those

00:03:46,239 --> 00:03:49,920
extra

00:03:46,959 --> 00:03:50,959
cpu cycles to bots and we're already

00:03:49,920 --> 00:03:53,200
using you know some

00:03:50,959 --> 00:03:54,720
some basic measures like fail to ban

00:03:53,200 --> 00:03:56,400
with rate limiting or

00:03:54,720 --> 00:03:59,280
tweaking the apache configuration but

00:03:56,400 --> 00:04:02,239
it's not enough to solve this problem

00:03:59,280 --> 00:04:04,000
so that's the question i'm asking how

00:04:02,239 --> 00:04:05,760
can i more effectively serve this type

00:04:04,000 --> 00:04:08,959
of dynamic web content

00:04:05,760 --> 00:04:10,720
to anonymous visitors um

00:04:08,959 --> 00:04:12,480
so when i started asking that question

00:04:10,720 --> 00:04:15,280
this is

00:04:12,480 --> 00:04:17,040
the post that i found i found a write-up

00:04:15,280 --> 00:04:19,919
uh published in 2014

00:04:17,040 --> 00:04:22,639
by rick ennis an sre with national

00:04:19,919 --> 00:04:24,880
public radio's digital services team

00:04:22,639 --> 00:04:26,240
uh called hardening drupal against badly

00:04:24,880 --> 00:04:28,400
behaved bots

00:04:26,240 --> 00:04:30,800
and surprised pikachu face is an

00:04:28,400 --> 00:04:32,960
unironic depiction of my delight

00:04:30,800 --> 00:04:34,880
reading this because this sounds exactly

00:04:32,960 --> 00:04:37,840
like the problem that i'm having

00:04:34,880 --> 00:04:39,520
and they're describing just you know in

00:04:37,840 --> 00:04:41,680
a sort of a conversational way

00:04:39,520 --> 00:04:42,800
the architecture that they built to deal

00:04:41,680 --> 00:04:44,880
with that

00:04:42,800 --> 00:04:46,160
and how it protected their suite of

00:04:44,880 --> 00:04:49,120
drupal websites

00:04:46,160 --> 00:04:50,720
from this type of traffic so that's very

00:04:49,120 --> 00:04:52,320
exciting

00:04:50,720 --> 00:04:54,000
sounds like the solution i need but i

00:04:52,320 --> 00:04:56,720
have a number of questions

00:04:54,000 --> 00:04:57,280
obviously this write-up was created by a

00:04:56,720 --> 00:05:00,479
team of

00:04:57,280 --> 00:05:02,800
sres at a larger organization so

00:05:00,479 --> 00:05:04,560
um and and this is a post it's a blog

00:05:02,800 --> 00:05:07,680
post you know it's not a cookbook

00:05:04,560 --> 00:05:10,000
so can i can i replicate this um

00:05:07,680 --> 00:05:11,759
are they using nginx community edition

00:05:10,000 --> 00:05:14,160
features or are they using

00:05:11,759 --> 00:05:16,639
the commercial edition are they writing

00:05:14,160 --> 00:05:18,160
a bespoke project here that i won't be

00:05:16,639 --> 00:05:20,080
able to replicate

00:05:18,160 --> 00:05:21,759
can i scale this down and can i

00:05:20,080 --> 00:05:24,080
customize it to fit the needs of my

00:05:21,759 --> 00:05:26,639
organizations

00:05:24,080 --> 00:05:28,320
how can i measure the impact that

00:05:26,639 --> 00:05:30,080
implementing this project would have is

00:05:28,320 --> 00:05:32,000
it really going to solve my problem

00:05:30,080 --> 00:05:33,360
and of course when you're looking at any

00:05:32,000 --> 00:05:36,639
new idea

00:05:33,360 --> 00:05:38,800
what else do i not know to ask so to

00:05:36,639 --> 00:05:42,080
answer this question i decided to

00:05:38,800 --> 00:05:44,160
treat this write-up that they published

00:05:42,080 --> 00:05:46,000
like a template like a cookbook and try

00:05:44,160 --> 00:05:46,880
to recreate their exact design in a

00:05:46,000 --> 00:05:49,280
sandbox

00:05:46,880 --> 00:05:50,240
so that i could discover whether that

00:05:49,280 --> 00:05:52,560
was possible

00:05:50,240 --> 00:05:53,919
and whether it would be a good fit for

00:05:52,560 --> 00:05:55,440
our organization and then

00:05:53,919 --> 00:05:57,360
benchmark and see you know try to

00:05:55,440 --> 00:06:00,160
replicate some of that aggressive

00:05:57,360 --> 00:06:02,000
um spikes and requests and see what

00:06:00,160 --> 00:06:04,720
impact this project had

00:06:02,000 --> 00:06:05,680
uh in my environment if it was a viable

00:06:04,720 --> 00:06:08,000
solution

00:06:05,680 --> 00:06:09,600
i have some project organizational

00:06:08,000 --> 00:06:10,560
guidelines here's what i want to do to

00:06:09,600 --> 00:06:13,280
fit

00:06:10,560 --> 00:06:15,039
this outcome to my needs from my

00:06:13,280 --> 00:06:16,560
organization i don't want to spend more

00:06:15,039 --> 00:06:18,240
because i'm trying to tune the service

00:06:16,560 --> 00:06:21,039
that already exists

00:06:18,240 --> 00:06:23,360
i don't want to ask my customers to make

00:06:21,039 --> 00:06:25,680
any changes i don't want to impact

00:06:23,360 --> 00:06:26,479
their experience of their their drupal

00:06:25,680 --> 00:06:28,960
website

00:06:26,479 --> 00:06:30,880
in any way um and i also don't want to

00:06:28,960 --> 00:06:32,400
change or interfere with the websites

00:06:30,880 --> 00:06:34,639
i'm not trying to

00:06:32,400 --> 00:06:36,639
tune or change those sites i'm trying to

00:06:34,639 --> 00:06:38,960
tune how they're delivered

00:06:36,639 --> 00:06:40,400
basically i want to eliminate the impact

00:06:38,960 --> 00:06:43,440
of this bot traffic

00:06:40,400 --> 00:06:46,880
and improve the website's performance

00:06:43,440 --> 00:06:49,919
so just a brief digression into

00:06:46,880 --> 00:06:54,000
why nginx you know what differentiates

00:06:49,919 --> 00:06:55,840
nginx um apache is a wonderful swiss

00:06:54,000 --> 00:06:58,479
army knife of a web server

00:06:55,840 --> 00:06:59,840
and it can do all the things this is

00:06:58,479 --> 00:07:03,039
kind of reductive but

00:06:59,840 --> 00:07:04,000
fundamentally apaches need for system

00:07:03,039 --> 00:07:06,960
resources

00:07:04,000 --> 00:07:07,840
scales linearly with web requests that

00:07:06,960 --> 00:07:11,120
it's serving

00:07:07,840 --> 00:07:11,840
that's not 100 true but it's reductively

00:07:11,120 --> 00:07:14,800
it's a good

00:07:11,840 --> 00:07:17,120
you know sort of summary nginx was

00:07:14,800 --> 00:07:19,759
developed in the early 2000s to address

00:07:17,120 --> 00:07:20,800
that very issue what do you do when

00:07:19,759 --> 00:07:22,880
you're getting

00:07:20,800 --> 00:07:24,800
thousands upon thousands of concurrent

00:07:22,880 --> 00:07:25,440
visitors and you want your web server to

00:07:24,800 --> 00:07:28,479
be able to

00:07:25,440 --> 00:07:31,599
serve them all without just chewing up

00:07:28,479 --> 00:07:32,240
system resources um and that is what

00:07:31,599 --> 00:07:34,880
nginx

00:07:32,240 --> 00:07:35,840
does basically through an architecture

00:07:34,880 --> 00:07:38,880
that is

00:07:35,840 --> 00:07:40,639
um asynchronous and non-blocking it's

00:07:38,880 --> 00:07:42,479
using a single process to serve

00:07:40,639 --> 00:07:44,720
thousands of requests

00:07:42,479 --> 00:07:46,080
but nginx is not the same thing as

00:07:44,720 --> 00:07:48,479
apache at all it's it

00:07:46,080 --> 00:07:50,319
serves static web content so if you need

00:07:48,479 --> 00:07:51,599
to serve dynamic web content you're

00:07:50,319 --> 00:07:53,840
going to have to hand

00:07:51,599 --> 00:07:54,960
off the process of generating that to a

00:07:53,840 --> 00:07:58,160
secondary

00:07:54,960 --> 00:08:00,720
tool um nginx can can

00:07:58,160 --> 00:08:01,440
be very powerful as a reverse proxy in

00:08:00,720 --> 00:08:03,759
front

00:08:01,440 --> 00:08:05,520
of apache and then you let apache do

00:08:03,759 --> 00:08:08,319
that dynamic web generation and

00:08:05,520 --> 00:08:10,160
nginx serves the requests i was open

00:08:08,319 --> 00:08:13,440
sourced in 2004

00:08:10,160 --> 00:08:16,080
and it was acquired by f5 last year

00:08:13,440 --> 00:08:18,080
um i thought these metrics collected by

00:08:16,080 --> 00:08:19,039
w3 technology surveys were kind of

00:08:18,080 --> 00:08:22,160
interesting

00:08:19,039 --> 00:08:23,039
um the biggest web server on the

00:08:22,160 --> 00:08:25,039
internet

00:08:23,039 --> 00:08:26,960
right now is cloudflare but between

00:08:25,039 --> 00:08:30,560
apache and nginx

00:08:26,960 --> 00:08:31,280
um if you look at the top 1000 busiest

00:08:30,560 --> 00:08:35,360
sites

00:08:31,280 --> 00:08:37,440
nginx has 40 46 of those sites compared

00:08:35,360 --> 00:08:38,560
to apaches 13. so that's kind of an

00:08:37,440 --> 00:08:41,839
interesting

00:08:38,560 --> 00:08:45,600
metric i thought um

00:08:41,839 --> 00:08:47,040
so essentially what i'm trying to do is

00:08:45,600 --> 00:08:49,519
i'm looking at this blog post

00:08:47,040 --> 00:08:50,240
i'm breaking down the features and i am

00:08:49,519 --> 00:08:52,800
trying to sort of

00:08:50,240 --> 00:08:54,000
reverse engineer what they did and see

00:08:52,800 --> 00:08:56,240
if i can recreate

00:08:54,000 --> 00:08:58,080
it and whether the features that they

00:08:56,240 --> 00:08:58,959
describe would be suitable for my use

00:08:58,080 --> 00:09:02,399
case

00:08:58,959 --> 00:09:04,640
so here's a little

00:09:02,399 --> 00:09:06,560
extra from their article basically they

00:09:04,640 --> 00:09:08,240
they have a pair of nginx servers

00:09:06,560 --> 00:09:09,600
they're configured as a reverse proxy

00:09:08,240 --> 00:09:12,080
cache in front of drupal

00:09:09,600 --> 00:09:13,680
this decreases database load by serving

00:09:12,080 --> 00:09:16,080
frequently used pages

00:09:13,680 --> 00:09:18,480
and it can also maintain uptime by

00:09:16,080 --> 00:09:20,480
serving pages when the database is down

00:09:18,480 --> 00:09:22,560
uh serving anonymous pages so that's

00:09:20,480 --> 00:09:23,760
good for my use case so i really like

00:09:22,560 --> 00:09:26,480
the sound of that

00:09:23,760 --> 00:09:28,480
but what differentiates that from i mean

00:09:26,480 --> 00:09:32,800
that's just caching right that's

00:09:28,480 --> 00:09:35,040
classic traditional content caching um

00:09:32,800 --> 00:09:37,279
so why won't maybe that's all i need

00:09:35,040 --> 00:09:41,040
will caching solve this problem

00:09:37,279 --> 00:09:43,920
it will not and here's why most commonly

00:09:41,040 --> 00:09:45,200
um a cache is small it doesn't contain

00:09:43,920 --> 00:09:47,120
your whole site content

00:09:45,200 --> 00:09:48,320
it's organically populated it's being

00:09:47,120 --> 00:09:51,120
populated by requests

00:09:48,320 --> 00:09:52,959
as they come in and it's stored usually

00:09:51,120 --> 00:09:55,120
in memory for performance reasons

00:09:52,959 --> 00:09:56,880
there are a lot of caching products

00:09:55,120 --> 00:09:58,640
right there there's varnish there's

00:09:56,880 --> 00:09:59,360
memcache there's redis there's all kinds

00:09:58,640 --> 00:10:02,399
of things that are

00:09:59,360 --> 00:10:04,160
commonly in use that type of cache did

00:10:02,399 --> 00:10:06,240
not solve npr's problem with their

00:10:04,160 --> 00:10:09,360
drupal sites and it wouldn't solve mine

00:10:06,240 --> 00:10:11,360
because the problem traffic is a as a

00:10:09,360 --> 00:10:13,360
high intensity high density

00:10:11,360 --> 00:10:14,880
burst of requests that are asking for

00:10:13,360 --> 00:10:18,079
old content

00:10:14,880 --> 00:10:20,320
they're a full site crawl that type

00:10:18,079 --> 00:10:22,560
of of when those requests come in to a

00:10:20,320 --> 00:10:24,399
traditional cache

00:10:22,560 --> 00:10:26,320
the cache has been populated organically

00:10:24,399 --> 00:10:27,839
by common requests so those pages are

00:10:26,320 --> 00:10:29,920
not in your cache so those

00:10:27,839 --> 00:10:31,839
requests have to be passed on to your

00:10:29,920 --> 00:10:33,200
origin server which then has to generate

00:10:31,839 --> 00:10:35,920
that old content

00:10:33,200 --> 00:10:36,240
it comes back down to the cache it bumps

00:10:35,920 --> 00:10:38,399
out

00:10:36,240 --> 00:10:39,680
all of your most current content that

00:10:38,399 --> 00:10:41,760
was in the cache

00:10:39,680 --> 00:10:42,880
and now you've got a double hit on your

00:10:41,760 --> 00:10:45,519
origin server

00:10:42,880 --> 00:10:46,880
as your normal traffic continues to ask

00:10:45,519 --> 00:10:49,680
for those common pages

00:10:46,880 --> 00:10:50,480
which the origin has to generate again

00:10:49,680 --> 00:10:53,760
um

00:10:50,480 --> 00:10:54,480
so the caching alone is not going to

00:10:53,760 --> 00:10:58,399
help me

00:10:54,480 --> 00:11:00,800
so what kind of caching would help um

00:10:58,399 --> 00:11:02,880
broadly speaking there are two

00:11:00,800 --> 00:11:06,240
approaches right to keeping your cash

00:11:02,880 --> 00:11:09,440
content fresh there is

00:11:06,240 --> 00:11:11,519
uh it's the old the old joke right about

00:11:09,440 --> 00:11:13,680
cash invalidation there are two hard

00:11:11,519 --> 00:11:15,760
problems in computer science

00:11:13,680 --> 00:11:17,360
cash invalidation naming things and off

00:11:15,760 --> 00:11:20,720
by one errors

00:11:17,360 --> 00:11:24,000
so um cash invalidation is

00:11:20,720 --> 00:11:25,839
the process of the the source of the

00:11:24,000 --> 00:11:27,200
content that dynamic content that's

00:11:25,839 --> 00:11:30,000
being updated and changing

00:11:27,200 --> 00:11:30,959
needs the mechanism to notify the cache

00:11:30,000 --> 00:11:33,279
hey replace

00:11:30,959 --> 00:11:34,800
that cached version of this content that

00:11:33,279 --> 00:11:36,240
you have with a fresher

00:11:34,800 --> 00:11:37,839
version because something's changed

00:11:36,240 --> 00:11:41,120
there's something new

00:11:37,839 --> 00:11:42,959
nginx plus implements that as a

00:11:41,120 --> 00:11:44,880
as an enterprise feature that they will

00:11:42,959 --> 00:11:46,480
sell you with an api

00:11:44,880 --> 00:11:48,240
they've implemented something they call

00:11:46,480 --> 00:11:49,839
the purge methods you send a purge

00:11:48,240 --> 00:11:52,800
request to the api

00:11:49,839 --> 00:11:54,240
it notifies the cache to replace that

00:11:52,800 --> 00:11:57,360
content with a newer version

00:11:54,240 --> 00:11:59,920
and since community edition of nginx

00:11:57,360 --> 00:12:00,399
contains all the core features there are

00:11:59,920 --> 00:12:02,160
other

00:12:00,399 --> 00:12:03,760
third-party you know you can roll your

00:12:02,160 --> 00:12:05,839
own um

00:12:03,760 --> 00:12:07,760
caching validation mechanism there are

00:12:05,839 --> 00:12:10,880
some on github i believe

00:12:07,760 --> 00:12:13,440
and then drupal itself is doing its own

00:12:10,880 --> 00:12:15,279
built-in caching it has two layers in

00:12:13,440 --> 00:12:16,480
fact one stored in the database and one

00:12:15,279 --> 00:12:18,800
on disk

00:12:16,480 --> 00:12:19,600
so drupal has implemented an interesting

00:12:18,800 --> 00:12:22,079
mechanism

00:12:19,600 --> 00:12:22,959
that they implement they call it cache

00:12:22,079 --> 00:12:24,800
tags

00:12:22,959 --> 00:12:26,959
i will move along from that for time but

00:12:24,800 --> 00:12:29,440
it's it's interesting to read about

00:12:26,959 --> 00:12:31,120
so then there's the that with that model

00:12:29,440 --> 00:12:32,560
you could potentially your cache could

00:12:31,120 --> 00:12:35,040
be populated forever

00:12:32,560 --> 00:12:36,639
because your content is notifying it

00:12:35,040 --> 00:12:38,480
when it needs to be refreshed

00:12:36,639 --> 00:12:40,959
so that's very efficient from the cash

00:12:38,480 --> 00:12:41,360
perspective but it's not very efficient

00:12:40,959 --> 00:12:43,360
from

00:12:41,360 --> 00:12:45,839
maybe your design and implementation

00:12:43,360 --> 00:12:49,200
perspective of getting that

00:12:45,839 --> 00:12:51,279
working then there's the the complete

00:12:49,200 --> 00:12:53,279
opposite approach micro caching

00:12:51,279 --> 00:12:56,320
which is the concept that you can cache

00:12:53,279 --> 00:12:58,720
anything but only for a moment in time

00:12:56,320 --> 00:12:59,440
so no content that you're serving is

00:12:58,720 --> 00:13:01,839
more than

00:12:59,440 --> 00:13:03,600
one second 10 seconds 60 seconds out of

00:13:01,839 --> 00:13:06,079
date there's a really nice write-up

00:13:03,600 --> 00:13:06,880
about the benefits that that can have by

00:13:06,079 --> 00:13:10,880
owen garrett

00:13:06,880 --> 00:13:13,839
on f5 of f5 on nginx.com

00:13:10,880 --> 00:13:15,120
website so the idea would be say you've

00:13:13,839 --> 00:13:18,560
got a very active

00:13:15,120 --> 00:13:20,880
website and um you set your micro cache

00:13:18,560 --> 00:13:23,040
expiration time to 10 seconds and in

00:13:20,880 --> 00:13:24,480
that 10 seconds 100 requests come in for

00:13:23,040 --> 00:13:27,360
the same content

00:13:24,480 --> 00:13:29,040
of those 100 requests only one needs to

00:13:27,360 --> 00:13:31,519
be generated from scratch

00:13:29,040 --> 00:13:33,440
and the other 99 requests can be served

00:13:31,519 --> 00:13:34,800
by that cash content that's valid during

00:13:33,440 --> 00:13:37,120
that 10 second window

00:13:34,800 --> 00:13:38,480
so that's getting a little closer that

00:13:37,120 --> 00:13:42,480
sounds like something

00:13:38,480 --> 00:13:42,480
that i could really use um

00:13:42,880 --> 00:13:49,360
but what about so i'm trying to sandbox

00:13:46,000 --> 00:13:51,519
trying to recreate npr's solution

00:13:49,360 --> 00:13:54,399
the first thing that i encounter as i'm

00:13:51,519 --> 00:13:56,639
just setting this up and playing with it

00:13:54,399 --> 00:13:58,880
is that i have to deal with the fact

00:13:56,639 --> 00:13:59,839
that drupal already has its own built-in

00:13:58,880 --> 00:14:02,800
caches

00:13:59,839 --> 00:14:03,680
and so as a way to sort of administer

00:14:02,800 --> 00:14:06,959
that

00:14:03,680 --> 00:14:09,120
they are configuring values in

00:14:06,959 --> 00:14:10,800
the traditional cache control headers

00:14:09,120 --> 00:14:11,440
they've got values in cache control

00:14:10,800 --> 00:14:13,519
header

00:14:11,440 --> 00:14:16,639
and very header and etag and expires

00:14:13,519 --> 00:14:20,000
header and

00:14:16,639 --> 00:14:20,639
as engine x acts as a reverse proxy

00:14:20,000 --> 00:14:22,079
where your

00:14:20,639 --> 00:14:23,680
downstream client requests are

00:14:22,079 --> 00:14:25,920
terminated then it's

00:14:23,680 --> 00:14:27,680
it at that moment in time it swaps from

00:14:25,920 --> 00:14:30,399
being a server to a client

00:14:27,680 --> 00:14:32,160
and it passes on a request to my

00:14:30,399 --> 00:14:33,600
upstream my apache server with those

00:14:32,160 --> 00:14:36,000
drupal websites

00:14:33,600 --> 00:14:37,040
gets the response back caches it and

00:14:36,000 --> 00:14:40,320
then serves

00:14:37,040 --> 00:14:42,480
that that cache data to the clients so

00:14:40,320 --> 00:14:44,959
when nginx is acting as a client by

00:14:42,480 --> 00:14:48,720
default it's respecting drupal's

00:14:44,959 --> 00:14:50,160
cache headers that is a problem for me

00:14:48,720 --> 00:14:50,639
because that's that's not really what i

00:14:50,160 --> 00:14:53,040
want

00:14:50,639 --> 00:14:53,680
what i want is a completely transparent

00:14:53,040 --> 00:14:55,680
layer

00:14:53,680 --> 00:14:57,199
of nginx caching that sits between

00:14:55,680 --> 00:14:59,279
drupal's website

00:14:57,199 --> 00:15:00,800
and it's building cache and the clients

00:14:59,279 --> 00:15:02,720
and doesn't conflict

00:15:00,800 --> 00:15:04,639
with what drupal's doing so i don't want

00:15:02,720 --> 00:15:06,240
to modify those on the fly

00:15:04,639 --> 00:15:08,639
i don't want to really hook into what

00:15:06,240 --> 00:15:11,199
drupal is doing so here's what i can do

00:15:08,639 --> 00:15:13,279
about that very simply i can tell nginx

00:15:11,199 --> 00:15:14,480
ignore drupal's cache control headers

00:15:13,279 --> 00:15:17,120
don't modify them

00:15:14,480 --> 00:15:18,240
and pass them on unchanged to the client

00:15:17,120 --> 00:15:20,720
at that point my

00:15:18,240 --> 00:15:22,320
only sort of issue or responsibility is

00:15:20,720 --> 00:15:23,440
to ensure that my nginx cache

00:15:22,320 --> 00:15:25,519
configuration

00:15:23,440 --> 00:15:26,639
does not conflict with drupal's cache

00:15:25,519 --> 00:15:29,360
configuration

00:15:26,639 --> 00:15:29,920
in any way so i'm trying to narrow down

00:15:29,360 --> 00:15:33,120
the

00:15:29,920 --> 00:15:35,120
best fit of caching for this use case

00:15:33,120 --> 00:15:36,480
i don't want to cache current content i

00:15:35,120 --> 00:15:38,720
want to cache all

00:15:36,480 --> 00:15:40,320
content to help me deal with those

00:15:38,720 --> 00:15:42,639
random crawls

00:15:40,320 --> 00:15:43,440
i want to put it on a disc and not in

00:15:42,639 --> 00:15:46,000
memory

00:15:43,440 --> 00:15:47,839
because my main concern is again those

00:15:46,000 --> 00:15:49,920
requests for unusual content

00:15:47,839 --> 00:15:50,959
i want to improve site reliability not

00:15:49,920 --> 00:15:53,600
necessarily

00:15:50,959 --> 00:15:54,880
just speed i'm not going to mess with

00:15:53,600 --> 00:15:56,399
cache and validation

00:15:54,880 --> 00:15:58,480
because that would get complicated and

00:15:56,399 --> 00:16:01,839
messy i would need to get drupal and

00:15:58,480 --> 00:16:03,600
nginx kind of interfacing about that um

00:16:01,839 --> 00:16:05,360
so that leaves some variant of micro

00:16:03,600 --> 00:16:08,160
caching my main goal

00:16:05,360 --> 00:16:08,800
is to not allow incoming requests to be

00:16:08,160 --> 00:16:10,800
passed on

00:16:08,800 --> 00:16:12,000
indiscriminately to the upstream drupal

00:16:10,800 --> 00:16:16,079
server

00:16:12,000 --> 00:16:17,759
so part of the winning combination

00:16:16,079 --> 00:16:19,440
involves some of these directives and

00:16:17,759 --> 00:16:23,759
what they boil down to

00:16:19,440 --> 00:16:26,800
is notifying nginx when it's okay

00:16:23,759 --> 00:16:29,600
to serve stale or out-of-date

00:16:26,800 --> 00:16:30,880
cached content so that sounds bad that

00:16:29,600 --> 00:16:31,440
sounds like something you don't want to

00:16:30,880 --> 00:16:33,440
do

00:16:31,440 --> 00:16:34,720
the reason it's okay is because you're

00:16:33,440 --> 00:16:36,560
micro caching

00:16:34,720 --> 00:16:38,959
none of your cache content is going to

00:16:36,560 --> 00:16:39,759
be older than a few seconds or a few

00:16:38,959 --> 00:16:44,399
minutes

00:16:39,759 --> 00:16:46,240
uh in time at that point it goes stale

00:16:44,399 --> 00:16:47,839
and the next request is going to prompt

00:16:46,240 --> 00:16:51,839
an updated copy

00:16:47,839 --> 00:16:56,399
to be downloaded and replace that

00:16:51,839 --> 00:16:57,519
in the nginx cache um so

00:16:56,399 --> 00:16:59,040
how are we going to accomplish that

00:16:57,519 --> 00:17:00,079
we're going to ignore drupal's cache

00:16:59,040 --> 00:17:02,399
control headers

00:17:00,079 --> 00:17:04,000
we're going to select uh content to

00:17:02,399 --> 00:17:07,039
cache based on a scheme that is

00:17:04,000 --> 00:17:09,120
appropriate for anonymous page views

00:17:07,039 --> 00:17:10,640
we're only going to cache the get and

00:17:09,120 --> 00:17:13,520
head methods we're not going to cache

00:17:10,640 --> 00:17:14,319
posts or anything like that we're going

00:17:13,520 --> 00:17:17,199
to

00:17:14,319 --> 00:17:18,240
turn on proxy cache lock so if a burst

00:17:17,199 --> 00:17:20,480
of requests come in

00:17:18,240 --> 00:17:22,559
all for the same content only one of

00:17:20,480 --> 00:17:24,319
them will be passed on to the upstream

00:17:22,559 --> 00:17:26,319
and the subsequent requests

00:17:24,319 --> 00:17:28,319
will not be passed on they will be told

00:17:26,319 --> 00:17:29,919
to wait until the upstream is done

00:17:28,319 --> 00:17:31,760
generating a fresh copy and then they

00:17:29,919 --> 00:17:33,200
will all get that fresh copy

00:17:31,760 --> 00:17:35,360
we're going to cash aggressively we're

00:17:33,200 --> 00:17:38,480
going to say proxy cash min uses

00:17:35,360 --> 00:17:38,880
one first time you see it cash it we're

00:17:38,480 --> 00:17:40,960
going to

00:17:38,880 --> 00:17:42,559
update in the background so it's okay to

00:17:40,960 --> 00:17:45,840
serve an incoming request

00:17:42,559 --> 00:17:46,640
with stale content if your upstream is

00:17:45,840 --> 00:17:48,559
busy

00:17:46,640 --> 00:17:50,559
updating the cache if your upstream is

00:17:48,559 --> 00:17:53,039
timing out and not responding to you

00:17:50,559 --> 00:17:55,520
if it's in an error state go ahead and

00:17:53,039 --> 00:17:57,360
serve your request with stale content

00:17:55,520 --> 00:17:59,200
and then you can even configure it down

00:17:57,360 --> 00:18:02,000
to the detailed level of saying for

00:17:59,200 --> 00:18:03,039
any specific http response that comes

00:18:02,000 --> 00:18:07,440
from your upstream

00:18:03,039 --> 00:18:11,919
in that case serves stale content um

00:18:07,440 --> 00:18:13,200
so i'll i don't want to i'll skip ahead

00:18:11,919 --> 00:18:13,679
kind of for time but then what do you do

00:18:13,200 --> 00:18:16,000
about

00:18:13,679 --> 00:18:17,200
what do you do about people who are

00:18:16,000 --> 00:18:19,039
going to authenticate

00:18:17,200 --> 00:18:20,799
you're in our case a small number of

00:18:19,039 --> 00:18:21,840
users who do need to authenticate and

00:18:20,799 --> 00:18:24,640
log in

00:18:21,840 --> 00:18:24,960
you make provision for them by ensuring

00:18:24,640 --> 00:18:27,520
that

00:18:24,960 --> 00:18:30,080
as soon as a person begins the process

00:18:27,520 --> 00:18:32,160
of authenticating to the drupal website

00:18:30,080 --> 00:18:34,480
their session their requests their

00:18:32,160 --> 00:18:36,400
traffic is not stored in the cache and

00:18:34,480 --> 00:18:38,799
is not served from the cache

00:18:36,400 --> 00:18:39,520
so you just exempt that authenticated

00:18:38,799 --> 00:18:43,440
user

00:18:39,520 --> 00:18:44,960
entirely um and so you you do not have

00:18:43,440 --> 00:18:46,799
any danger of serving

00:18:44,960 --> 00:18:48,640
cached content to an authenticated user

00:18:46,799 --> 00:18:49,280
or serving an authenticated user's

00:18:48,640 --> 00:18:52,000
content

00:18:49,280 --> 00:18:53,440
from your cache to an anonymous user it

00:18:52,000 --> 00:18:56,640
will not happen

00:18:53,440 --> 00:18:59,039
so that's good as far as it goes it's

00:18:56,640 --> 00:19:00,480
very helpful i've already created a sort

00:18:59,039 --> 00:19:04,160
of a screen

00:19:00,480 --> 00:19:07,520
a helpful um a sort of a blocker

00:19:04,160 --> 00:19:09,520
that's going to slow down the ability of

00:19:07,520 --> 00:19:11,440
any given

00:19:09,520 --> 00:19:13,039
traffic to reach my upstream server

00:19:11,440 --> 00:19:14,799
because there are a lot of conditions

00:19:13,039 --> 00:19:16,080
under which nginx is just going to go

00:19:14,799 --> 00:19:19,360
ahead and

00:19:16,080 --> 00:19:21,360
um serve them from the cache but that

00:19:19,360 --> 00:19:23,120
hasn't yet addressed the bot cache

00:19:21,360 --> 00:19:24,559
portion of the project so that that's

00:19:23,120 --> 00:19:27,919
the fun part this

00:19:24,559 --> 00:19:31,039
is what npr developed basically

00:19:27,919 --> 00:19:32,240
to that design they have added another

00:19:31,039 --> 00:19:34,480
layer a mechanism

00:19:32,240 --> 00:19:36,000
of just examining the user agent of

00:19:34,480 --> 00:19:37,760
every request

00:19:36,000 --> 00:19:39,360
matching it up to a list and if they

00:19:37,760 --> 00:19:40,160
evaluate that that is a bot they're

00:19:39,360 --> 00:19:42,160
going to divert

00:19:40,160 --> 00:19:44,960
that request away from their upstream

00:19:42,160 --> 00:19:47,919
entirely and send it to a static

00:19:44,960 --> 00:19:48,799
fully pre-populated cache that they call

00:19:47,919 --> 00:19:52,000
bot cache

00:19:48,799 --> 00:19:53,520
so in their design enginex is also

00:19:52,000 --> 00:19:55,200
helping reduce load a number of ways

00:19:53,520 --> 00:19:57,200
right it's the reverse proxy you're

00:19:55,200 --> 00:19:58,640
terminating the client's tls connection

00:19:57,200 --> 00:20:00,799
there on your nginx server and you're

00:19:58,640 --> 00:20:02,880
determining that keep a live session

00:20:00,799 --> 00:20:04,480
and you're caching so apache no longer

00:20:02,880 --> 00:20:06,400
has to worry about that

00:20:04,480 --> 00:20:07,919
um and then at this point they're

00:20:06,400 --> 00:20:10,640
diverting some traffic

00:20:07,919 --> 00:20:11,600
into a bot cache server based on user

00:20:10,640 --> 00:20:13,360
agent

00:20:11,600 --> 00:20:15,360
they've got an in-memory high-speed

00:20:13,360 --> 00:20:18,159
cache on their main nginx setup

00:20:15,360 --> 00:20:18,960
and a slower disk cache full of every

00:20:18,159 --> 00:20:22,000
page

00:20:18,960 --> 00:20:23,039
on their bot cache so that's how you do

00:20:22,000 --> 00:20:26,080
that

00:20:23,039 --> 00:20:28,559
it's incredibly simple in nginx um

00:20:26,080 --> 00:20:30,320
using map directives you simply inspect

00:20:28,559 --> 00:20:33,360
that user agent

00:20:30,320 --> 00:20:37,120
the map directive allows you to set

00:20:33,360 --> 00:20:38,720
uh to set the value of a variable based

00:20:37,120 --> 00:20:41,600
on a different variable

00:20:38,720 --> 00:20:42,799
um so if i look at the user agent and i

00:20:41,600 --> 00:20:45,360
say by default

00:20:42,799 --> 00:20:46,640
i'm going to set set my bot check

00:20:45,360 --> 00:20:48,720
variable to off

00:20:46,640 --> 00:20:50,720
but if that user agent is found in a

00:20:48,720 --> 00:20:51,600
list or matches a string or a regular

00:20:50,720 --> 00:20:53,760
expression

00:20:51,600 --> 00:20:56,400
in a list that i have maintained or

00:20:53,760 --> 00:20:58,159
created then i'm going to set that to on

00:20:56,400 --> 00:20:59,440
then depending on whether bot check is

00:20:58,159 --> 00:21:02,240
set to on or off

00:20:59,440 --> 00:21:03,440
i'm going to determine which upstream

00:21:02,240 --> 00:21:06,320
source of content

00:21:03,440 --> 00:21:08,080
to direct that request to in in the

00:21:06,320 --> 00:21:08,799
default case in the off case i'm just

00:21:08,080 --> 00:21:11,200
going to send

00:21:08,799 --> 00:21:13,360
that request to my drupal server if the

00:21:11,200 --> 00:21:15,679
content isn't available in the cache

00:21:13,360 --> 00:21:17,760
if it was a bot user agent i'm diverting

00:21:15,679 --> 00:21:20,480
it to bot cash

00:21:17,760 --> 00:21:22,000
so that's great as far as it goes but

00:21:20,480 --> 00:21:25,600
that isn't really going to solve

00:21:22,000 --> 00:21:28,400
my problem for a number of reasons

00:21:25,600 --> 00:21:30,159
um can i so far so far i've replicated

00:21:28,400 --> 00:21:31,919
npr's project which is great

00:21:30,159 --> 00:21:33,760
and the essential features were free

00:21:31,919 --> 00:21:34,799
they were all part of nginx community

00:21:33,760 --> 00:21:38,720
edition

00:21:34,799 --> 00:21:41,280
but for my use case

00:21:38,720 --> 00:21:42,799
so to get a test a sense of how this

00:21:41,280 --> 00:21:44,799
would really work in production

00:21:42,799 --> 00:21:46,400
i look at a bunch of logs i look at i

00:21:44,799 --> 00:21:47,440
don't know a month's worth of logs or a

00:21:46,400 --> 00:21:50,559
couple months

00:21:47,440 --> 00:21:52,880
and i discover that only seven percent

00:21:50,559 --> 00:21:54,640
of my requests

00:21:52,880 --> 00:21:56,799
would i be able to unambiguously

00:21:54,640 --> 00:22:00,159
identify as a bot

00:21:56,799 --> 00:22:01,039
user agent so at that point that leaves

00:22:00,159 --> 00:22:03,039
00:22:01,039 --> 00:22:04,799
of traffic that wouldn't be addressed by

00:22:03,039 --> 00:22:06,960
this block cash solution

00:22:04,799 --> 00:22:09,120
at all and for those reasons that we

00:22:06,960 --> 00:22:11,520
talked about with the with the cash

00:22:09,120 --> 00:22:13,679
they would still generate load on the

00:22:11,520 --> 00:22:16,080
upstream because those rarely used pages

00:22:13,679 --> 00:22:18,000
are not up to date and current in my in

00:22:16,080 --> 00:22:20,159
my normal cache so i don't like that

00:22:18,000 --> 00:22:22,159
that's not solving my problem and then i

00:22:20,159 --> 00:22:26,080
look at say an example one of the

00:22:22,159 --> 00:22:28,720
the most aggressive uh crawls that i saw

00:22:26,080 --> 00:22:30,559
was like 20 different ip addresses from

00:22:28,720 --> 00:22:32,559
a cloud hosting provider

00:22:30,559 --> 00:22:34,240
and they all had a valid current

00:22:32,559 --> 00:22:35,760
up-to-date user agent that you would

00:22:34,240 --> 00:22:38,960
expect from a browser

00:22:35,760 --> 00:22:39,679
so that's this bot cache is not going to

00:22:38,960 --> 00:22:43,120
save me

00:22:39,679 --> 00:22:44,559
from that traffic at all even if i

00:22:43,120 --> 00:22:47,360
reverse the logic

00:22:44,559 --> 00:22:48,240
and say tried to create some list of

00:22:47,360 --> 00:22:51,120
known

00:22:48,240 --> 00:22:52,960
friendly user agents i'm still going to

00:22:51,120 --> 00:22:55,120
misclassify some visitors

00:22:52,960 --> 00:22:56,480
and again that doesn't really sound like

00:22:55,120 --> 00:23:00,080
what i want to do

00:22:56,480 --> 00:23:01,679
um here are a summary

00:23:00,080 --> 00:23:03,120
from npr's article of the

00:23:01,679 --> 00:23:06,480
characteristics that i

00:23:03,120 --> 00:23:09,600
do want from their bot cash project i

00:23:06,480 --> 00:23:11,520
i don't want to clear um

00:23:09,600 --> 00:23:13,280
less frequently used content from my

00:23:11,520 --> 00:23:15,360
cache i want to cache the whole site

00:23:13,280 --> 00:23:16,320
even if some pages are not accessed very

00:23:15,360 --> 00:23:18,559
often

00:23:16,320 --> 00:23:20,240
because of that i want to cache it on

00:23:18,559 --> 00:23:22,880
disk in a file system

00:23:20,240 --> 00:23:23,919
just because ram would get expensive

00:23:22,880 --> 00:23:26,960
really quickly

00:23:23,919 --> 00:23:30,159
and then the logic if a request

00:23:26,960 --> 00:23:30,960
is going to place undo load on my

00:23:30,159 --> 00:23:33,280
upstream

00:23:30,960 --> 00:23:34,640
i just want to serve it from the cache

00:23:33,280 --> 00:23:38,159
even if it may be

00:23:34,640 --> 00:23:40,000
out of date so what if i could configure

00:23:38,159 --> 00:23:42,159
all of those benefits

00:23:40,000 --> 00:23:43,120
of this bought cash design into my

00:23:42,159 --> 00:23:46,400
primary

00:23:43,120 --> 00:23:47,039
singular cache and limit traffic based

00:23:46,400 --> 00:23:50,240
on

00:23:47,039 --> 00:23:54,799
the rate of requests over time

00:23:50,240 --> 00:23:58,400
instead of on a list of user agents

00:23:54,799 --> 00:24:00,400
so um as soon as i asked the right

00:23:58,400 --> 00:24:03,360
question i found the answer

00:24:00,400 --> 00:24:04,080
that is already implemented in nginx and

00:24:03,360 --> 00:24:07,440
it's just

00:24:04,080 --> 00:24:09,520
called limit request zone basically it's

00:24:07,440 --> 00:24:11,279
a directive that can be used to limit

00:24:09,520 --> 00:24:14,799
the processing rate

00:24:11,279 --> 00:24:16,400
of requests coming from a single ip

00:24:14,799 --> 00:24:18,480
so this is not the same as limiting

00:24:16,400 --> 00:24:21,520
connections and it's not

00:24:18,480 --> 00:24:22,400
the same as placing an overall limit on

00:24:21,520 --> 00:24:25,919
your server

00:24:22,400 --> 00:24:29,279
this is saying per ip rate limit how

00:24:25,919 --> 00:24:30,480
fast we will serve their requests and so

00:24:29,279 --> 00:24:32,960
that's what i'm able

00:24:30,480 --> 00:24:33,679
to do just very simply starting at the

00:24:32,960 --> 00:24:36,240
bottom

00:24:33,679 --> 00:24:37,120
on this slide i configure a limit

00:24:36,240 --> 00:24:39,120
request zone

00:24:37,120 --> 00:24:42,080
normally that would just look at the ip

00:24:39,120 --> 00:24:44,080
address but i've added a layer to this

00:24:42,080 --> 00:24:46,320
i've put a variable called external and

00:24:44,080 --> 00:24:48,320
then i've applied a rate limit let's say

00:24:46,320 --> 00:24:49,520
an arbitrary value like five requests

00:24:48,320 --> 00:24:52,799
per second

00:24:49,520 --> 00:24:55,039
um and then if some requests from some

00:24:52,799 --> 00:24:56,159
ip address exceeds that rate

00:24:55,039 --> 00:24:59,200
they're going to get returned an

00:24:56,159 --> 00:25:01,600
arbitrary status like 429 which says

00:24:59,200 --> 00:25:03,279
no slow down too fast and there's

00:25:01,600 --> 00:25:05,039
there's more nuance to it than that that

00:25:03,279 --> 00:25:05,600
i have not included here like you can

00:25:05,039 --> 00:25:08,320
configure

00:25:05,600 --> 00:25:09,679
burstiness so that say you want to make

00:25:08,320 --> 00:25:12,880
allowances for

00:25:09,679 --> 00:25:15,200
um a friendly or a valid request that

00:25:12,880 --> 00:25:16,960
just happens to briefly exceed your rate

00:25:15,200 --> 00:25:18,480
limit you can configure in a burst

00:25:16,960 --> 00:25:20,799
directive so it's okay

00:25:18,480 --> 00:25:22,960
they don't get rate limited if they

00:25:20,799 --> 00:25:23,520
briefly exceed and then go back to a

00:25:22,960 --> 00:25:26,799
more

00:25:23,520 --> 00:25:29,600
a rate that is lower than your limit but

00:25:26,799 --> 00:25:30,240
what do i do about the fact that i never

00:25:29,600 --> 00:25:33,039
ever ever

00:25:30,240 --> 00:25:34,640
want to hit valid customer visits with a

00:25:33,039 --> 00:25:35,200
rate limit that's not what i want to

00:25:34,640 --> 00:25:36,960
happen

00:25:35,200 --> 00:25:38,720
at all i want to ensure it doesn't

00:25:36,960 --> 00:25:41,840
happen

00:25:38,720 --> 00:25:43,760
our organization acts as a network an

00:25:41,840 --> 00:25:44,559
internet service provider to a very

00:25:43,760 --> 00:25:47,600
specific

00:25:44,559 --> 00:25:51,279
group of organizations

00:25:47,600 --> 00:25:53,840
so for our customers location

00:25:51,279 --> 00:25:55,360
where they are doing business where they

00:25:53,840 --> 00:25:56,799
might have a large number of computers

00:25:55,360 --> 00:25:59,200
that could conceivably

00:25:56,799 --> 00:26:01,440
all re make a request at the same moment

00:25:59,200 --> 00:26:04,159
in time from behind the same ip

00:26:01,440 --> 00:26:05,600
i know what those ips are and i'm always

00:26:04,159 --> 00:26:07,600
going to know what they are

00:26:05,600 --> 00:26:09,120
so i leverage the fact that i have that

00:26:07,600 --> 00:26:12,960
information to basically

00:26:09,120 --> 00:26:15,679
exempt known customer site ips

00:26:12,960 --> 00:26:16,080
and also their sister organizations from

00:26:15,679 --> 00:26:18,880
this

00:26:16,080 --> 00:26:20,799
rate limit and at that point i can make

00:26:18,880 --> 00:26:23,919
a very good assumption

00:26:20,799 --> 00:26:24,320
based on other factors that the rest of

00:26:23,919 --> 00:26:26,640
my

00:26:24,320 --> 00:26:28,159
good or valid or the traffic that i

00:26:26,640 --> 00:26:30,240
don't want to rate limit is typically

00:26:28,159 --> 00:26:32,880
coming from distributed ips

00:26:30,240 --> 00:26:33,840
um people on home internet service

00:26:32,880 --> 00:26:35,600
providers

00:26:33,840 --> 00:26:37,279
um where you're not getting a large

00:26:35,600 --> 00:26:39,919
number of people

00:26:37,279 --> 00:26:40,480
so um again i did that with a map

00:26:39,919 --> 00:26:42,960
directive

00:26:40,480 --> 00:26:44,480
i gave an exemption list of ips that

00:26:42,960 --> 00:26:46,559
would be exempt from this rate limit

00:26:44,480 --> 00:26:48,000
and then everyone else defaulted into

00:26:46,559 --> 00:26:51,200
the rate limit so that's

00:26:48,000 --> 00:26:54,080
great at that point i've got a project

00:26:51,200 --> 00:26:55,840
i've got a cache is fully populated with

00:26:54,080 --> 00:26:58,480
every possible page

00:26:55,840 --> 00:27:00,000
i can repopulate it on a schedule that

00:26:58,480 --> 00:27:02,000
is suitable to me

00:27:00,000 --> 00:27:03,360
and every single request that comes in

00:27:02,000 --> 00:27:04,480
is going to be greeted with a

00:27:03,360 --> 00:27:07,679
combination

00:27:04,480 --> 00:27:09,120
of either um being passed

00:27:07,679 --> 00:27:11,360
either hitting the cash it's being

00:27:09,120 --> 00:27:13,120
served from the cash notifying the cash

00:27:11,360 --> 00:27:15,520
hey go get a fresh copy

00:27:13,120 --> 00:27:17,360
um if if the if there are too many

00:27:15,520 --> 00:27:18,840
requests we'll serve out a stale request

00:27:17,360 --> 00:27:20,000
while we're waiting for that upstream to

00:27:18,840 --> 00:27:22,880
respond

00:27:20,000 --> 00:27:24,320
or if the requests are just exceeding a

00:27:22,880 --> 00:27:25,520
reasonable rate which i have

00:27:24,320 --> 00:27:27,919
pre-configured

00:27:25,520 --> 00:27:29,039
arbitrarily their request will get

00:27:27,919 --> 00:27:30,720
turned away

00:27:29,039 --> 00:27:33,679
so that's sort of generation one

00:27:30,720 --> 00:27:36,320
generation two of making that

00:27:33,679 --> 00:27:38,399
ideal in my opinion would be to move

00:27:36,320 --> 00:27:42,080
that rate limiting component

00:27:38,399 --> 00:27:45,360
from my reverse proxy at the edge

00:27:42,080 --> 00:27:47,679
onto my origin server at the upstream

00:27:45,360 --> 00:27:49,360
so the cache and everything else remains

00:27:47,679 --> 00:27:51,840
at my edge server

00:27:49,360 --> 00:27:53,600
then all of those requests are passed to

00:27:51,840 --> 00:27:55,039
the upstream when they don't meet

00:27:53,600 --> 00:27:57,760
you know they don't they're not a cash

00:27:55,039 --> 00:27:58,320
hit but the upstream enforces the rate

00:27:57,760 --> 00:28:00,240
limit

00:27:58,320 --> 00:28:02,240
the reason that that could be so cool is

00:28:00,240 --> 00:28:02,880
that that would return that arbitrary

00:28:02,240 --> 00:28:06,159
whatever

00:28:02,880 --> 00:28:09,520
response that i choose to return um

00:28:06,159 --> 00:28:13,360
429 or something else i could include

00:28:09,520 --> 00:28:16,399
that response in my proxy cash stale

00:28:13,360 --> 00:28:18,799
while whatever directive so i could say

00:28:16,399 --> 00:28:20,080
if you see this this response that i'm

00:28:18,799 --> 00:28:22,080
specifically returning

00:28:20,080 --> 00:28:23,919
when the rate limit is invoked go ahead

00:28:22,080 --> 00:28:26,399
and serve a stale copy

00:28:23,919 --> 00:28:27,600
from the cache then literally no one's

00:28:26,399 --> 00:28:29,279
ever been blocked

00:28:27,600 --> 00:28:31,600
everyone's always getting served the

00:28:29,279 --> 00:28:34,240
only people seeing maybe older content

00:28:31,600 --> 00:28:36,399
are those crawlers that are being

00:28:34,240 --> 00:28:38,880
unfriendly to our system resources

00:28:36,399 --> 00:28:39,919
so that i like the sound of that a lot

00:28:38,880 --> 00:28:43,039
um

00:28:39,919 --> 00:28:43,679
so now jumping onto just the little

00:28:43,039 --> 00:28:45,520
practical

00:28:43,679 --> 00:28:47,840
implementation parts this was

00:28:45,520 --> 00:28:50,000
interesting information that npr shared

00:28:47,840 --> 00:28:51,360
they how do they gonna populate that bot

00:28:50,000 --> 00:28:53,360
cash that they created

00:28:51,360 --> 00:28:54,960
they started by using wget with the

00:28:53,360 --> 00:28:58,000
recursive um

00:28:54,960 --> 00:29:00,320
option but they had a problem such that

00:28:58,000 --> 00:29:02,799
they were creating new content faster

00:29:00,320 --> 00:29:03,760
than they could crawl it uh so much so

00:29:02,799 --> 00:29:06,080
that they would miss

00:29:03,760 --> 00:29:07,760
30 of their content by crawling

00:29:06,080 --> 00:29:08,880
recursively and they weren't creating

00:29:07,760 --> 00:29:11,279
content 30

00:29:08,880 --> 00:29:12,000
faster but the indexing of the pages was

00:29:11,279 --> 00:29:14,080
changing

00:29:12,000 --> 00:29:15,360
and so whole pages of content were being

00:29:14,080 --> 00:29:18,320
missed

00:29:15,360 --> 00:29:20,640
so very simple solution they just do a

00:29:18,320 --> 00:29:22,080
database stump they ask drupal hey tell

00:29:20,640 --> 00:29:24,880
me a list of all of your

00:29:22,080 --> 00:29:25,600
pages your urls and then they feed that

00:29:24,880 --> 00:29:29,279
list

00:29:25,600 --> 00:29:31,760
into a wget crawler so that's great

00:29:29,279 --> 00:29:33,679
i can pre-populate my cash even with

00:29:31,760 --> 00:29:34,880
those less popular or less frequently

00:29:33,679 --> 00:29:37,200
accessed pages

00:29:34,880 --> 00:29:39,039
i can set up cash a separate one for

00:29:37,200 --> 00:29:41,120
every website for every customer

00:29:39,039 --> 00:29:42,399
i could repopulate it on a schedule or

00:29:41,120 --> 00:29:44,960
on demand

00:29:42,399 --> 00:29:45,679
and i can leverage the fact that i can

00:29:44,960 --> 00:29:47,840
just ask

00:29:45,679 --> 00:29:49,200
drupal to tell me for a list of what

00:29:47,840 --> 00:29:51,760
pages to crawl

00:29:49,200 --> 00:29:52,559
um this is kind of a simplified example

00:29:51,760 --> 00:29:55,600
you can really

00:29:52,559 --> 00:29:58,000
wget is surprisingly flexible and

00:29:55,600 --> 00:29:59,919
one of the main reasons that i didn't do

00:29:58,000 --> 00:30:03,279
something else i just went ahead and

00:29:59,919 --> 00:30:04,240
used wget to populate my cache was this

00:30:03,279 --> 00:30:07,279
nifty directive

00:30:04,240 --> 00:30:08,480
page requisites by default wget actually

00:30:07,279 --> 00:30:11,520
isn't going to download

00:30:08,480 --> 00:30:13,600
every single asset that a browser

00:30:11,520 --> 00:30:15,520
would download to display a page it's

00:30:13,600 --> 00:30:17,360
not going to get some of those assets

00:30:15,520 --> 00:30:18,640
that are external and you want to

00:30:17,360 --> 00:30:21,919
populate your cache with

00:30:18,640 --> 00:30:23,200
all of them so page requisites will do

00:30:21,919 --> 00:30:25,120
that you can set your own

00:30:23,200 --> 00:30:26,799
user agent so you can exclude that from

00:30:25,120 --> 00:30:30,320
your logging or your metrics

00:30:26,799 --> 00:30:31,919
you can rate limit your crawl this base

00:30:30,320 --> 00:30:33,279
directive looks redundant but it's a

00:30:31,919 --> 00:30:36,320
necessary prerequisite

00:30:33,279 --> 00:30:37,120
to this input file directive where you

00:30:36,320 --> 00:30:41,120
are feeding

00:30:37,120 --> 00:30:44,080
in the appropriate list of site urls

00:30:41,120 --> 00:30:45,679
for that specific domain so that's

00:30:44,080 --> 00:30:48,840
populating the cache

00:30:45,679 --> 00:30:51,760
and then what about the project of

00:30:48,840 --> 00:30:53,600
deployment um so i i built out all these

00:30:51,760 --> 00:30:55,679
configurations in staging

00:30:53,600 --> 00:30:57,919
i automated building the configuration

00:30:55,679 --> 00:30:58,799
files just sort of like a best practice

00:30:57,919 --> 00:31:00,399
because you can't

00:30:58,799 --> 00:31:01,600
you can't have any fuzzy thinking if

00:31:00,399 --> 00:31:03,120
you're scripting something it's going to

00:31:01,600 --> 00:31:06,559
do exactly what you tell it

00:31:03,120 --> 00:31:08,799
so by building the actual configs with

00:31:06,559 --> 00:31:10,880
um scripting that helped me make sure i

00:31:08,799 --> 00:31:13,760
was doing what i meant to do

00:31:10,880 --> 00:31:14,880
for for rolling this out in front of our

00:31:13,760 --> 00:31:17,039
existing service

00:31:14,880 --> 00:31:18,080
i also wrote scripts for every step of

00:31:17,039 --> 00:31:19,840
that process

00:31:18,080 --> 00:31:22,320
and for each script that i wrote i wrote

00:31:19,840 --> 00:31:24,799
a mirror image script to roll it back

00:31:22,320 --> 00:31:25,440
uh to roll a config change back and then

00:31:24,799 --> 00:31:27,440
i also

00:31:25,440 --> 00:31:29,360
automated a test that would tell me

00:31:27,440 --> 00:31:32,080
check for success and notify me

00:31:29,360 --> 00:31:33,360
if that if that expected configuration

00:31:32,080 --> 00:31:35,840
change was failing

00:31:33,360 --> 00:31:37,679
then i set up a run book that enumerated

00:31:35,840 --> 00:31:38,080
everything i would need to do to deploy

00:31:37,679 --> 00:31:40,559
it

00:31:38,080 --> 00:31:41,840
and then i went over that several times

00:31:40,559 --> 00:31:43,840
and then very importantly

00:31:41,840 --> 00:31:46,080
i left in time in my maintenance window

00:31:43,840 --> 00:31:49,519
in case i needed to roll it back

00:31:46,080 --> 00:31:52,640
you think i missed something i did um

00:31:49,519 --> 00:31:54,159
so the silliest thing too

00:31:52,640 --> 00:31:55,840
i implemented this in a maintenance

00:31:54,159 --> 00:31:56,880
window it worked great for about an hour

00:31:55,840 --> 00:31:58,960
and then all of a sudden

00:31:56,880 --> 00:32:00,559
it stopped dead and all sites requests

00:31:58,960 --> 00:32:02,880
were failing what

00:32:00,559 --> 00:32:04,320
so i used those rollback scripts that i

00:32:02,880 --> 00:32:07,679
had written

00:32:04,320 --> 00:32:08,000
undid my changes uh step back look at it

00:32:07,679 --> 00:32:10,960
and

00:32:08,000 --> 00:32:12,960
i quickly recognized what i had done i

00:32:10,960 --> 00:32:15,679
had failed to

00:32:12,960 --> 00:32:16,880
white list a an ip address that was

00:32:15,679 --> 00:32:19,360
moving

00:32:16,880 --> 00:32:22,799
in the fail to ban of the server that

00:32:19,360 --> 00:32:25,519
was losing that ip address

00:32:22,799 --> 00:32:26,799
so i was able to then schedule a new

00:32:25,519 --> 00:32:28,000
maintenance window and use the scripts

00:32:26,799 --> 00:32:31,039
scriptside written

00:32:28,000 --> 00:32:33,360
to put it all back in place the next

00:32:31,039 --> 00:32:33,360
time

00:32:33,679 --> 00:32:40,399
so let's see here is it going to

00:32:38,240 --> 00:32:42,000
proceed okay so there's a little bit of

00:32:40,399 --> 00:32:44,640
automation that's kind of handy

00:32:42,000 --> 00:32:45,919
just to make this this server be

00:32:44,640 --> 00:32:48,960
self-maintaining

00:32:45,919 --> 00:32:49,760
um i think probably the most interesting

00:32:48,960 --> 00:32:53,279
one

00:32:49,760 --> 00:32:56,080
was i implemented a custom service

00:32:53,279 --> 00:32:57,519
so drupal is doing its own caching right

00:32:56,080 --> 00:32:59,600
internal to itself

00:32:57,519 --> 00:33:01,039
and nginx isn't interfering with that it

00:32:59,600 --> 00:33:04,000
is passing its

00:33:01,039 --> 00:33:05,679
um cache related headers onto the

00:33:04,000 --> 00:33:07,039
browser the client that's requesting

00:33:05,679 --> 00:33:10,799
that site

00:33:07,039 --> 00:33:13,760
so our um web developer

00:33:10,799 --> 00:33:14,880
has enabled a feature of drupal called

00:33:13,760 --> 00:33:16,640
rebuild cache

00:33:14,880 --> 00:33:18,240
and that means that any customer any

00:33:16,640 --> 00:33:19,919
authenticated user who's interacting

00:33:18,240 --> 00:33:21,919
with their website and seeing some

00:33:19,919 --> 00:33:24,399
unexpected results can press this

00:33:21,919 --> 00:33:28,000
rebuild cache button to clear drupal's

00:33:24,399 --> 00:33:28,480
two built-in caches so in order to make

00:33:28,000 --> 00:33:31,760
this

00:33:28,480 --> 00:33:33,919
nginx cache as transparent as possible i

00:33:31,760 --> 00:33:35,039
implemented a little service on the

00:33:33,919 --> 00:33:37,440
nginx server

00:33:35,039 --> 00:33:39,600
that watches for invocations that

00:33:37,440 --> 00:33:42,960
rebuild cash button in drupal

00:33:39,600 --> 00:33:44,159
and mirrors that clears nginx's cache

00:33:42,960 --> 00:33:47,360
for that website

00:33:44,159 --> 00:33:47,760
just so that the user um will never see

00:33:47,360 --> 00:33:50,720
any

00:33:47,760 --> 00:33:51,519
anything unexpected if drupal's cache

00:33:50,720 --> 00:33:53,600
gets cleared

00:33:51,519 --> 00:33:55,120
and genex's cache gets cleared and then

00:33:53,600 --> 00:33:58,799
i also schedule

00:33:55,120 --> 00:33:59,440
that website for a uh the the cache to

00:33:58,799 --> 00:34:03,360
be

00:33:59,440 --> 00:34:05,360
repopulated when that happens you can

00:34:03,360 --> 00:34:07,120
accomplish that with any automation

00:34:05,360 --> 00:34:10,320
flavor that suits your style

00:34:07,120 --> 00:34:12,639
i used bash because it makes me happy

00:34:10,320 --> 00:34:13,599
okay so instrumentation you can really

00:34:12,639 --> 00:34:17,119
do quite a bit

00:34:13,599 --> 00:34:19,440
to instrument um nginx i did

00:34:17,119 --> 00:34:20,560
two levels of vlogging partly because i

00:34:19,440 --> 00:34:23,280
had a

00:34:20,560 --> 00:34:24,879
locally installed matomo instance that i

00:34:23,280 --> 00:34:27,520
had been importing

00:34:24,879 --> 00:34:29,520
um apache vhost combined logs and i

00:34:27,520 --> 00:34:32,079
wanted data continuity in that so i

00:34:29,520 --> 00:34:34,000
set up one level of nginx logs that were

00:34:32,079 --> 00:34:36,320
going to have the exact same data so

00:34:34,000 --> 00:34:37,760
i could keep getting my nice matomo web

00:34:36,320 --> 00:34:39,679
analytics dashboards

00:34:37,760 --> 00:34:41,119
and then i implemented a second set of

00:34:39,679 --> 00:34:43,200
logging with

00:34:41,119 --> 00:34:44,240
instrumentation about the cache and

00:34:43,200 --> 00:34:47,679
instrumentation

00:34:44,240 --> 00:34:49,919
that described performance on um

00:34:47,679 --> 00:34:50,720
like timing of communication between

00:34:49,919 --> 00:34:53,040
nginx

00:34:50,720 --> 00:34:54,639
and the apache upstream how long each

00:34:53,040 --> 00:34:55,200
step of that request and response

00:34:54,639 --> 00:34:58,560
process

00:34:55,200 --> 00:35:00,400
took a nice benefit of having that

00:34:58,560 --> 00:35:00,800
instrumentation is that you can pass it

00:35:00,400 --> 00:35:04,000
on

00:35:00,800 --> 00:35:07,200
to nginx amplify this is their sas

00:35:04,000 --> 00:35:08,560
monitoring offering it's just a python

00:35:07,200 --> 00:35:10,880
agent that you can install

00:35:08,560 --> 00:35:12,640
locally in nginx and it sends your

00:35:10,880 --> 00:35:14,640
monitoring data to an amplified

00:35:12,640 --> 00:35:17,440
dashboard

00:35:14,640 --> 00:35:17,760
monitors the operating system engine x

00:35:17,440 --> 00:35:21,359
um

00:35:17,760 --> 00:35:23,119
php and my sql and it also takes

00:35:21,359 --> 00:35:24,400
advantage of that instrumentation that

00:35:23,119 --> 00:35:27,119
you have configured

00:35:24,400 --> 00:35:29,839
in your nginx logs if any and that is

00:35:27,119 --> 00:35:33,359
free for up to five agents

00:35:29,839 --> 00:35:35,359
in their community edition and yes i did

00:35:33,359 --> 00:35:36,480
cherry picked that nice screenshot when

00:35:35,359 --> 00:35:39,920
there was 100

00:35:36,480 --> 00:35:41,200
application health score um so

00:35:39,920 --> 00:35:44,240
quickly i thought just about

00:35:41,200 --> 00:35:45,920
benchmarking i think my biggest takeaway

00:35:44,240 --> 00:35:48,240
just fooling about with this was don't

00:35:45,920 --> 00:35:49,119
conflate environment factors with server

00:35:48,240 --> 00:35:51,440
performance

00:35:49,119 --> 00:35:52,960
so your benchmarking results obviously

00:35:51,440 --> 00:35:54,720
in a staging environment are going to be

00:35:52,960 --> 00:35:56,640
quite different from in production

00:35:54,720 --> 00:35:58,000
because you're removing some of those

00:35:56,640 --> 00:36:01,040
elements um

00:35:58,000 --> 00:36:02,800
that could introduce confusion i'm in

00:36:01,040 --> 00:36:05,599
staging i'm testing over the lan

00:36:02,800 --> 00:36:06,079
in production i would be testing over um

00:36:05,599 --> 00:36:09,040
some

00:36:06,079 --> 00:36:09,920
network um lengths that i can't really

00:36:09,040 --> 00:36:13,520
control

00:36:09,920 --> 00:36:15,440
so apache bench is a nifty tool for

00:36:13,520 --> 00:36:17,040
testing anonymous content which is what

00:36:15,440 --> 00:36:18,640
i have to deal with so that's good as

00:36:17,040 --> 00:36:21,680
far as it goes

00:36:18,640 --> 00:36:24,720
except that it's only testing

00:36:21,680 --> 00:36:25,280
one domain at a time one page at a time

00:36:24,720 --> 00:36:26,720
right so

00:36:25,280 --> 00:36:28,480
in a way i almost feel like those

00:36:26,720 --> 00:36:31,839
results would be weighted

00:36:28,480 --> 00:36:33,280
in favor of caching i mean that's okay

00:36:31,839 --> 00:36:35,040
that is what we're testing

00:36:33,280 --> 00:36:36,720
i didn't need to mess with something

00:36:35,040 --> 00:36:37,599
like jmeter or something where i could

00:36:36,720 --> 00:36:39,520
configure

00:36:37,599 --> 00:36:41,359
i wasn't trying to benchmark logging in

00:36:39,520 --> 00:36:44,320
or anything like that just

00:36:41,359 --> 00:36:45,040
how does apache compare with nginx with

00:36:44,320 --> 00:36:47,680
the cache

00:36:45,040 --> 00:36:49,520
serving these web pages but apache bench

00:36:47,680 --> 00:36:51,599
is a single threaded application so i

00:36:49,520 --> 00:36:54,720
thought could i feed apache bench

00:36:51,599 --> 00:36:58,400
to something like gnu parallels which

00:36:54,720 --> 00:37:00,160
can implement different scripts that are

00:36:58,400 --> 00:37:02,320
single threaded in perilous that you can

00:37:00,160 --> 00:37:04,000
take advantage of all your system cores

00:37:02,320 --> 00:37:06,079
you can also distribute those jobs

00:37:04,000 --> 00:37:07,119
across multiple servers or multiple

00:37:06,079 --> 00:37:10,640
machines

00:37:07,119 --> 00:37:12,960
and indeed i was able to do that

00:37:10,640 --> 00:37:14,079
um in fact i found a really detailed

00:37:12,960 --> 00:37:15,040
write-up about it with some good

00:37:14,079 --> 00:37:17,280
suggestions

00:37:15,040 --> 00:37:19,440
on a blog by simon holywell so i have

00:37:17,280 --> 00:37:20,000
the link to that in there if you'd like

00:37:19,440 --> 00:37:23,440
to

00:37:20,000 --> 00:37:26,400
look at it so just to compare a few

00:37:23,440 --> 00:37:27,280
um tests done in staging versus in

00:37:26,400 --> 00:37:29,839
production

00:37:27,280 --> 00:37:31,839
this is in staging so all of the system

00:37:29,839 --> 00:37:34,400
resources are equal between the two

00:37:31,839 --> 00:37:35,920
endpoints and there's no network delay

00:37:34,400 --> 00:37:37,920
it's on the lan

00:37:35,920 --> 00:37:39,040
i did a time-based rather than number

00:37:37,920 --> 00:37:42,400
based test

00:37:39,040 --> 00:37:42,880
and for my nginx server apache bench

00:37:42,400 --> 00:37:44,720
actually

00:37:42,880 --> 00:37:45,920
maxed out the number of requests that it

00:37:44,720 --> 00:37:48,640
will perform

00:37:45,920 --> 00:37:50,800
during a period of time it hit 50 000

00:37:48,640 --> 00:37:52,720
requests and it just quit it's like okay

00:37:50,800 --> 00:37:54,240
you're done that's enough for you but it

00:37:52,720 --> 00:37:57,200
was six more than six

00:37:54,240 --> 00:37:58,000
times faster to have this configuration

00:37:57,200 --> 00:38:01,359
of caching

00:37:58,000 --> 00:38:03,839
on nginx versus just natively requesting

00:38:01,359 --> 00:38:05,520
apache keeping in mind that's with

00:38:03,839 --> 00:38:08,400
drupal's caching

00:38:05,520 --> 00:38:11,119
enabled so for both of these tests

00:38:08,400 --> 00:38:14,240
drupal's own built-in caching is on

00:38:11,119 --> 00:38:17,599
this is the performance that i'm seeing

00:38:14,240 --> 00:38:20,720
with nginx um and in production

00:38:17,599 --> 00:38:21,920
it was under just under three times

00:38:20,720 --> 00:38:25,520
faster which is still

00:38:21,920 --> 00:38:27,599
great um i was very pleased with that

00:38:25,520 --> 00:38:29,920
amount of improvement

00:38:27,599 --> 00:38:31,760
so i've looking back at the project i

00:38:29,920 --> 00:38:32,960
have answered all the questions that i

00:38:31,760 --> 00:38:36,720
set out for myself

00:38:32,960 --> 00:38:38,000
i was satisfied that i had customized

00:38:36,720 --> 00:38:40,000
the project

00:38:38,000 --> 00:38:41,440
so that it would actually suit our

00:38:40,000 --> 00:38:44,079
organization's needs

00:38:41,440 --> 00:38:44,640
i just have a couple of questions left

00:38:44,079 --> 00:38:46,640
what about

00:38:44,640 --> 00:38:48,480
what did i not know to ask and what

00:38:46,640 --> 00:38:52,400
impact is this having

00:38:48,480 --> 00:38:54,400
so i think my takeaway was that

00:38:52,400 --> 00:38:56,079
documentation is very important but

00:38:54,400 --> 00:38:58,240
staging is even more important

00:38:56,079 --> 00:38:59,599
often i would learn about something as

00:38:58,240 --> 00:39:01,760
i'm researching this

00:38:59,599 --> 00:39:02,720
i'm setting it up i think oh okay this

00:39:01,760 --> 00:39:05,200
is what will happen

00:39:02,720 --> 00:39:07,040
that's not what would happen the

00:39:05,200 --> 00:39:08,000
directives would interact in ways that i

00:39:07,040 --> 00:39:09,680
didn't expect

00:39:08,000 --> 00:39:11,280
so reading the documentation was one

00:39:09,680 --> 00:39:13,200
thing staging it and seeing what

00:39:11,280 --> 00:39:15,920
happened was another thing

00:39:13,200 --> 00:39:17,359
there's an awesome community driven

00:39:15,920 --> 00:39:19,839
listserv

00:39:17,359 --> 00:39:20,720
that nginx offers i've got a link for

00:39:19,839 --> 00:39:23,119
that there too

00:39:20,720 --> 00:39:24,320
and it's really valuable it's very

00:39:23,119 --> 00:39:26,960
active every day

00:39:24,320 --> 00:39:28,320
and just reading that um pretty

00:39:26,960 --> 00:39:32,160
educational

00:39:28,320 --> 00:39:33,839
so my takeaways um from this project

00:39:32,160 --> 00:39:35,280
what does your organization need you

00:39:33,839 --> 00:39:39,359
solve for that don't

00:39:35,280 --> 00:39:42,000
you don't necessarily have to um adopt

00:39:39,359 --> 00:39:44,240
what is a best practice or the standard

00:39:42,000 --> 00:39:46,240
practice for a particular technology

00:39:44,240 --> 00:39:48,160
um adapt it so that it's actually

00:39:46,240 --> 00:39:50,240
meeting your business case

00:39:48,160 --> 00:39:51,520
um instrument everything because

00:39:50,240 --> 00:39:53,119
somebody will ask you for that

00:39:51,520 --> 00:39:55,280
information and that somebody

00:39:53,119 --> 00:39:56,560
will be you and document everything for

00:39:55,280 --> 00:39:58,720
the same reason

00:39:56,560 --> 00:40:00,240
do plan for failure and have a rollback

00:39:58,720 --> 00:40:02,000
plan ready to go

00:40:00,240 --> 00:40:03,520
not just in your head but hopefully

00:40:02,000 --> 00:40:05,200
automated and tested

00:40:03,520 --> 00:40:07,440
because at some point something will go

00:40:05,200 --> 00:40:08,480
wrong and then what does success look

00:40:07,440 --> 00:40:11,359
like

00:40:08,480 --> 00:40:12,560
for our particular implementation since

00:40:11,359 --> 00:40:14,240
this has been in production there have

00:40:12,560 --> 00:40:17,599
been no more incidents

00:40:14,240 --> 00:40:18,319
caused by traffic so i'd call that a

00:40:17,599 --> 00:40:20,480
success

00:40:18,319 --> 00:40:21,839
it has dealt with that traffic problem

00:40:20,480 --> 00:40:23,760
we've got less spend

00:40:21,839 --> 00:40:26,240
on the server resources because apache

00:40:23,760 --> 00:40:28,400
needs so much fewer resources

00:40:26,240 --> 00:40:30,079
to serve the same requests to the same

00:40:28,400 --> 00:40:32,319
clients in a timely manner

00:40:30,079 --> 00:40:34,079
we've got reduced administrative demand

00:40:32,319 --> 00:40:34,800
because i no longer need to in the

00:40:34,079 --> 00:40:36,800
future

00:40:34,800 --> 00:40:38,319
our web developer doesn't need to ask

00:40:36,800 --> 00:40:40,640
her customers to

00:40:38,319 --> 00:40:42,800
execute a dns change i've got this

00:40:40,640 --> 00:40:45,920
reverse proxy and it now owns

00:40:42,800 --> 00:40:47,520
our the ip address for those sites and

00:40:45,920 --> 00:40:49,760
so we can

00:40:47,520 --> 00:40:51,440
migrate them forward as needed

00:40:49,760 --> 00:40:54,240
maintenance impact is reduced

00:40:51,440 --> 00:40:55,560
i can turn off my apache upstream server

00:40:54,240 --> 00:40:58,400
all of the pages are

00:40:55,560 --> 00:40:59,280
pre-populated and regularly repopulated

00:40:58,400 --> 00:41:01,040
into the cache

00:40:59,280 --> 00:41:02,800
they will go right on being served while

00:41:01,040 --> 00:41:05,760
i do maintenance upstream

00:41:02,800 --> 00:41:06,000
um this request response time there's a

00:41:05,760 --> 00:41:08,480
lot

00:41:06,000 --> 00:41:09,599
of kinds of metrics that metric is the

00:41:08,480 --> 00:41:11,920
length of time it takes

00:41:09,599 --> 00:41:13,280
nginx to communicate a request it's

00:41:11,920 --> 00:41:15,280
received to apache

00:41:13,280 --> 00:41:16,720
and get that back and send it on to the

00:41:15,280 --> 00:41:20,240
client and that

00:41:16,720 --> 00:41:22,800
has improved significantly and then you

00:41:20,240 --> 00:41:23,760
can see they're just some metrics um

00:41:22,800 --> 00:41:25,280
these metrics

00:41:23,760 --> 00:41:26,960
these cash performance metrics would

00:41:25,280 --> 00:41:29,520
vary wildly with

00:41:26,960 --> 00:41:30,000
how how you're configuring your cash

00:41:29,520 --> 00:41:33,200
what's

00:41:30,000 --> 00:41:34,800
your cash validity lifetime what is um

00:41:33,200 --> 00:41:36,480
are you micro caching what are some of

00:41:34,800 --> 00:41:38,960
those rules but

00:41:36,480 --> 00:41:40,079
we've got a 50 hit rate which i think is

00:41:38,960 --> 00:41:42,720
just massive

00:41:40,079 --> 00:41:43,520
for a micro caching implementation of

00:41:42,720 --> 00:41:46,079
this kind

00:41:43,520 --> 00:41:47,520
and authenticated users um which always

00:41:46,079 --> 00:41:48,000
bypass the cache they're not really

00:41:47,520 --> 00:41:49,680
adding any

00:41:48,000 --> 00:41:51,920
load because that's only two percent of

00:41:49,680 --> 00:41:54,960
the overall requests

00:41:51,920 --> 00:41:57,200
so i have included a few resources links

00:41:54,960 --> 00:41:59,760
to resources that were really helpful

00:41:57,200 --> 00:42:01,359
in investigating and experimenting with

00:41:59,760 --> 00:42:02,319
these technologies and setting up this

00:42:01,359 --> 00:42:05,200
project

00:42:02,319 --> 00:42:06,319
um thank you so much for your your time

00:42:05,200 --> 00:42:08,960
and your attention

00:42:06,319 --> 00:42:11,119
um come and say hi to me on twitter i

00:42:08,960 --> 00:42:13,359
just love that dumpster fire

00:42:11,119 --> 00:42:14,240
or send me an email and the slides are

00:42:13,359 --> 00:42:17,839
available

00:42:14,240 --> 00:42:17,839
online thank you

00:42:19,280 --> 00:42:26,079
great job jessica i i agree with you

00:42:22,560 --> 00:42:29,520
twitter is certainly a dumpster fire

00:42:26,079 --> 00:42:32,240
i love it anyway i can't help myself

00:42:29,520 --> 00:42:32,240
it's so bad

00:42:33,280 --> 00:42:38,640
well you um had a great presentation

00:42:37,119 --> 00:42:41,920
there it looks like

00:42:38,640 --> 00:42:44,319
nixie needs to understand i went the

00:42:41,920 --> 00:42:47,760
whole conference without doing that

00:42:44,319 --> 00:42:50,720
um said thing during the

00:42:47,760 --> 00:42:52,720
well 2020 right right without speaking

00:42:50,720 --> 00:42:54,480
well unmuted i just wanted to know what

00:42:52,720 --> 00:42:56,640
princess bride video that was since you

00:42:54,480 --> 00:42:57,920
didn't get a chance to play it

00:42:56,640 --> 00:43:00,079
was that never make a bet with a

00:42:57,920 --> 00:43:03,359
sicilian when death is on the line or

00:43:00,079 --> 00:43:04,560
oh i'm sorry on my screen on my screen

00:43:03,359 --> 00:43:07,599
it did play so i didn't

00:43:04,560 --> 00:43:09,119
really it's just um i

00:43:07,599 --> 00:43:10,640
i do not think that means what you think

00:43:09,119 --> 00:43:12,880
it means oh yes

00:43:10,640 --> 00:43:16,240
i i maybe it did play i just wanted to

00:43:12,880 --> 00:43:16,240
hear you do the reenactment

00:43:16,720 --> 00:43:20,560
there's a depiction of me trying to

00:43:18,640 --> 00:43:23,599
understand the documentation

00:43:20,560 --> 00:43:25,440
that's not what that does yeah but yeah

00:43:23,599 --> 00:43:28,079
i have some questions i don't know for

00:43:25,440 --> 00:43:30,800
how we're rolling here you i will let

00:43:28,079 --> 00:43:33,680
warner um i defer to warner

00:43:30,800 --> 00:43:34,079
we could probably fit in one but we are

00:43:33,680 --> 00:43:37,359
already

00:43:34,079 --> 00:43:38,240
oh no one i guess my time i used it my

00:43:37,359 --> 00:43:39,599
time

00:43:38,240 --> 00:43:41,599
oh does that mean you don't want

00:43:39,599 --> 00:43:43,440
questions no i will i will accept

00:43:41,599 --> 00:43:45,040
that i'm just sorry i didn't leave any

00:43:43,440 --> 00:43:46,880
time for that okay how about this i'll

00:43:45,040 --> 00:43:48,800
ask two questions that you can pick

00:43:46,880 --> 00:43:50,640
um what's the difference between nginx

00:43:48,800 --> 00:43:51,680
and engine x plus like the commercial

00:43:50,640 --> 00:43:54,079
license

00:43:51,680 --> 00:43:54,800
and then um i've always been a big fan

00:43:54,079 --> 00:43:56,560
of npr

00:43:54,800 --> 00:43:57,839
programming with open source community

00:43:56,560 --> 00:44:01,119
view on openness

00:43:57,839 --> 00:44:02,560
what open tools does npr use internally

00:44:01,119 --> 00:44:03,280
i like both of those questions you can

00:44:02,560 --> 00:44:04,960
decide though

00:44:03,280 --> 00:44:07,520
that's an awesome question i have no

00:44:04,960 --> 00:44:08,240
idea what npr uses internally because my

00:44:07,520 --> 00:44:10,720
whole perspective

00:44:08,240 --> 00:44:12,000
is just reading their sre blog the

00:44:10,720 --> 00:44:14,079
difference between engine

00:44:12,000 --> 00:44:15,680
plus and community edition is plus is

00:44:14,079 --> 00:44:17,040
the enterprise edition and there's a

00:44:15,680 --> 00:44:20,319
whole list of features

00:44:17,040 --> 00:44:22,480
you can find the comparison on nginx.com

00:44:20,319 --> 00:44:24,480
they actually that's a great source of

00:44:22,480 --> 00:44:26,400
documentation for both editions because

00:44:24,480 --> 00:44:28,240
they're really good about specifying

00:44:26,400 --> 00:44:29,760
this feature is free for all this

00:44:28,240 --> 00:44:33,359
feature is paid

00:44:29,760 --> 00:44:34,319
gotcha yeah you let me know if i have

00:44:33,359 --> 00:44:36,800
more

00:44:34,319 --> 00:44:38,880
i i have more well we should probably

00:44:36,800 --> 00:44:40,720
move on i i know this next part of our

00:44:38,880 --> 00:44:42,640
program is going to be tighter but

00:44:40,720 --> 00:44:44,560
thanks so much jessica really

00:44:42,640 --> 00:44:47,280
appreciated your presentation

00:44:44,560 --> 00:44:47,280
and your answer

00:44:48,560 --> 00:44:50,720

YouTube URL: https://www.youtube.com/watch?v=ydmlQoR7cZw


