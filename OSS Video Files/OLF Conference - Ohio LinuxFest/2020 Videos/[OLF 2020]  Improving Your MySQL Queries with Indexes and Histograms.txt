Title: [OLF 2020]  Improving Your MySQL Queries with Indexes and Histograms
Publication date: 2020-12-31
Playlist: 2020 Videos
Description: 
	Speaker: David Stokes
Nobody complains that the database is too fast. Many seek to improve the performance of their queries by adding indexes and are shocked to find performance may worsen. Histograms do not have the overhead of indexes but it is not a one size fits all cure. The query optimizer, much like a GPS, uses historical information to find your data and like a GPS it can be mislead on the current status. This session will cover indexes, histograms, there best uses, and how to determine which will help your situation.
Captions: 
	00:00:01,920 --> 00:00:05,520
well thank you all for having me back

00:00:03,439 --> 00:00:07,919
and thanks for joining virtually

00:00:05,520 --> 00:00:08,800
uh i gotta warn you i've set an alarm uh

00:00:07,919 --> 00:00:11,759
this is a

00:00:08,800 --> 00:00:13,840
a talk that i i give that normally runs

00:00:11,759 --> 00:00:16,160
upwards of 90 minutes so

00:00:13,840 --> 00:00:18,320
uh to spare you i've set a timer if you

00:00:16,160 --> 00:00:19,600
have questions please pop them up i'll

00:00:18,320 --> 00:00:22,080
monitor q a

00:00:19,600 --> 00:00:24,000
as best i can if you need to get a hold

00:00:22,080 --> 00:00:25,760
of me here's my contact information

00:00:24,000 --> 00:00:27,760
i am the my school community manager for

00:00:25,760 --> 00:00:31,439
north america

00:00:27,760 --> 00:00:33,200
and uh first thing i have to go over is

00:00:31,439 --> 00:00:35,760
the oracle safe harbor agreement i am

00:00:33,200 --> 00:00:38,559
talking 99.9999

00:00:35,760 --> 00:00:40,960
today about the free to download license

00:00:38,559 --> 00:00:42,960
to the gpl version 2

00:00:40,960 --> 00:00:44,000
mysql community server and community

00:00:42,960 --> 00:00:46,079
software

00:00:44,000 --> 00:00:47,520
however if during question and answer i

00:00:46,079 --> 00:00:50,000
go off intelligent

00:00:47,520 --> 00:00:51,520
on a future product uh this is the

00:00:50,000 --> 00:00:52,879
legalese saying take that with a grain

00:00:51,520 --> 00:00:53,920
of salt i don't have perfect knowledge

00:00:52,879 --> 00:00:56,559
what's coming up

00:00:53,920 --> 00:00:59,120
so get past that real quick by the way

00:00:56,559 --> 00:01:00,160
if you're running mysql56 next february

00:00:59,120 --> 00:01:02,559
i believe it's the

00:01:00,160 --> 00:01:04,960
fifth or the sixth of february uh

00:01:02,559 --> 00:01:07,200
mysql56 reaches end of life status no

00:01:04,960 --> 00:01:09,439
more bug fixes no more support uh you're

00:01:07,200 --> 00:01:11,360
officially running dinosaur equipment

00:01:09,439 --> 00:01:13,200
and as someone who loves vintage cars

00:01:11,360 --> 00:01:15,520
and richard's vintage guitars

00:01:13,200 --> 00:01:16,720
and vintage motorcycles uh believe me

00:01:15,520 --> 00:01:18,560
the older the things are

00:01:16,720 --> 00:01:20,159
the harder they are to get repaired and

00:01:18,560 --> 00:01:21,759
to find parts for

00:01:20,159 --> 00:01:23,439
plus it's harder to find people who know

00:01:21,759 --> 00:01:24,880
how to work those old versions so if

00:01:23,439 --> 00:01:28,479
you're running five six

00:01:24,880 --> 00:01:30,320
please update uh by the way if you're

00:01:28,479 --> 00:01:30,960
interested in trying the mysql database

00:01:30,320 --> 00:01:32,479
service

00:01:30,960 --> 00:01:34,560
uh you can get three hundred dollars in

00:01:32,479 --> 00:01:37,119
credits uh free

00:01:34,560 --> 00:01:38,720
uh just go to that website and you get a

00:01:37,119 --> 00:01:40,320
full version of the mysql enterprise

00:01:38,720 --> 00:01:41,520
edition which means you get enterprise

00:01:40,320 --> 00:01:44,640
backup the

00:01:41,520 --> 00:01:46,159
encryption stuff and all that 300

00:01:44,640 --> 00:01:49,280
with some with one or two instances will

00:01:46,159 --> 00:01:49,280
last you quite a while

00:01:49,439 --> 00:01:53,439
and uh so what is this session about

00:01:52,399 --> 00:01:55,280
well

00:01:53,439 --> 00:01:56,960
very rarely do i ever hear anyone

00:01:55,280 --> 00:01:58,479
complain that you know this database is

00:01:56,960 --> 00:02:01,759
just running too darn fast

00:01:58,479 --> 00:02:04,320
my applications just can't keep up um

00:02:01,759 --> 00:02:05,119
speeding up queries if you follow

00:02:04,320 --> 00:02:08,800
certain

00:02:05,119 --> 00:02:11,760
websites which i won't name um

00:02:08,800 --> 00:02:12,879
stack overflow um you'll you'll see that

00:02:11,760 --> 00:02:14,319
uh

00:02:12,879 --> 00:02:16,400
a lot of folks see it as a dark art it's

00:02:14,319 --> 00:02:18,560
not a dark art it's kind of a misguided

00:02:16,400 --> 00:02:20,080
science but it's not a dark art

00:02:18,560 --> 00:02:22,400
uh the understanding how to speed up

00:02:20,080 --> 00:02:25,040
queries is often seen as a

00:02:22,400 --> 00:02:26,400
as magic but it's really not and we're

00:02:25,040 --> 00:02:28,319
going to look at the proper uses of

00:02:26,400 --> 00:02:29,520
indexes histograms locking options and

00:02:28,319 --> 00:02:30,959
some of the other ways to speed up

00:02:29,520 --> 00:02:32,879
queries

00:02:30,959 --> 00:02:34,560
one of the problems that i see is that

00:02:32,879 --> 00:02:38,000
this is a very dry subject

00:02:34,560 --> 00:02:39,680
i mean we're talking stack dump tracing

00:02:38,000 --> 00:02:42,720
drive for assembly language

00:02:39,680 --> 00:02:44,239
level stuff uh very very dry if you

00:02:42,720 --> 00:02:44,879
don't catch it the first time you walk

00:02:44,239 --> 00:02:46,480
through this

00:02:44,879 --> 00:02:48,560
this is recorded watch it again the

00:02:46,480 --> 00:02:50,560
slides are online

00:02:48,560 --> 00:02:52,959
about by the way the link down at the

00:02:50,560 --> 00:02:56,080
bottom in red is where you can get the

00:02:52,959 --> 00:02:57,920
the slides i also just tweeted it um

00:02:56,080 --> 00:03:00,000
also this is a presentation with lots of

00:02:57,920 --> 00:03:01,040
text on screen i'm sorry there's really

00:03:00,000 --> 00:03:03,920
no other way to

00:03:01,040 --> 00:03:07,599
uh to give this information over if i

00:03:03,920 --> 00:03:07,599
could do it with sock puppets i would

00:03:08,640 --> 00:03:12,159
now uh something else we're not going to

00:03:10,800 --> 00:03:15,200
cover today is

00:03:12,159 --> 00:03:16,080
system configuration of your os not to

00:03:15,200 --> 00:03:18,640
cover the

00:03:16,080 --> 00:03:20,159
configuration of mysql i'm not going to

00:03:18,640 --> 00:03:22,480
talk about hardware there are wonderful

00:03:20,159 --> 00:03:25,599
talks out there on hardware

00:03:22,480 --> 00:03:27,040
things like disk buffers that lie to you

00:03:25,599 --> 00:03:29,040
throughput channels that aren't quite

00:03:27,040 --> 00:03:31,280
working the way and also networking

00:03:29,040 --> 00:03:32,159
if you're doing a lot of replication and

00:03:31,280 --> 00:03:35,599
you're also

00:03:32,159 --> 00:03:37,840
running dns and ldap services

00:03:35,599 --> 00:03:39,200
on the same network segment your

00:03:37,840 --> 00:03:40,480
database is occasionally going to have

00:03:39,200 --> 00:03:42,000
problems that aren't really related to

00:03:40,480 --> 00:03:43,760
the database but it'll be blamed on the

00:03:42,000 --> 00:03:45,519
database

00:03:43,760 --> 00:03:46,879
also not talking today about normalizing

00:03:45,519 --> 00:03:48,720
your data

00:03:46,879 --> 00:03:50,799
in the relational world you want to set

00:03:48,720 --> 00:03:52,480
up your data with minimum redundancies

00:03:50,799 --> 00:03:54,239
and by doing this you have it in

00:03:52,480 --> 00:03:55,040
manageable chunks that work with set

00:03:54,239 --> 00:03:57,360
theory

00:03:55,040 --> 00:03:58,840
this relational calculus and believe it

00:03:57,360 --> 00:04:01,680
or not the math actually does

00:03:58,840 --> 00:04:03,120
work um unfortunately can't go into that

00:04:01,680 --> 00:04:05,760
today because we've only got

00:04:03,120 --> 00:04:07,120
30 some odd minutes and what i'd like to

00:04:05,760 --> 00:04:09,519
emphasize that you can't

00:04:07,120 --> 00:04:10,720
build a skyscraper on a sandy beach it's

00:04:09,519 --> 00:04:12,080
just not going to take

00:04:10,720 --> 00:04:15,040
the pressure and it's going to collapse

00:04:12,080 --> 00:04:16,639
on you for normalization i recommend

00:04:15,040 --> 00:04:18,720
third form or normal i am now

00:04:16,639 --> 00:04:19,440
recommending using json columns for

00:04:18,720 --> 00:04:21,519
stubbed

00:04:19,440 --> 00:04:22,479
information uh if you have to make

00:04:21,519 --> 00:04:25,040
multiple dives

00:04:22,479 --> 00:04:25,919
to get your customers billing address

00:04:25,040 --> 00:04:27,919
for instance

00:04:25,919 --> 00:04:30,479
you might want to slightly denormalize

00:04:27,919 --> 00:04:31,759
by using a json column

00:04:30,479 --> 00:04:34,000
also think about how you're going to use

00:04:31,759 --> 00:04:35,600
your data if you're recording a whole

00:04:34,000 --> 00:04:37,280
bunch of sales

00:04:35,600 --> 00:04:39,199
from cash register data and you're going

00:04:37,280 --> 00:04:40,320
to do time series analysis that's going

00:04:39,199 --> 00:04:41,600
to be a little bit different than if

00:04:40,320 --> 00:04:44,400
you're going to go back go back and do

00:04:41,600 --> 00:04:46,479
some transactional analysis

00:04:44,400 --> 00:04:48,880
once again don't eat fork with a don't

00:04:46,479 --> 00:04:50,800
use a fork to eat your soup

00:04:48,880 --> 00:04:52,400
by the way badly normalized data will

00:04:50,800 --> 00:04:54,000
hurt the performance of your queries no

00:04:52,400 --> 00:04:55,759
matter how much training you give

00:04:54,000 --> 00:04:58,160
give it a doctor will not be faster than

00:04:55,759 --> 00:05:00,000
the thoroughbred horse

00:04:58,160 --> 00:05:02,000
okay the optimizer uh consider the

00:05:00,000 --> 00:05:05,039
optimizer the brain and nervous system

00:05:02,000 --> 00:05:06,639
of the database it uh

00:05:05,039 --> 00:05:08,560
wants to look at your query and try to

00:05:06,639 --> 00:05:12,400
figure out the fastest most

00:05:08,560 --> 00:05:15,440
inexpensive way to get your data to you

00:05:12,400 --> 00:05:17,360
the trouble here is that this is quite a

00:05:15,440 --> 00:05:19,759
complex problem

00:05:17,360 --> 00:05:21,280
uh there's lots of academic papers come

00:05:19,759 --> 00:05:23,440
on this every week

00:05:21,280 --> 00:05:25,039
and most are built on a cost model that

00:05:23,440 --> 00:05:28,720
mathematical cost model

00:05:25,039 --> 00:05:30,080
is based on uh basically disk reads

00:05:28,720 --> 00:05:31,280
because that used to be the slowest

00:05:30,080 --> 00:05:32,720
thing in the entire chain

00:05:31,280 --> 00:05:34,080
and that's what we're still using it for

00:05:32,720 --> 00:05:35,199
and there's some advances in that but

00:05:34,080 --> 00:05:38,639
that's a little too

00:05:35,199 --> 00:05:39,440
crazy for this talk now the optimizer

00:05:38,639 --> 00:05:41,680
wants to look at

00:05:39,440 --> 00:05:42,960
every option you give it a query it

00:05:41,680 --> 00:05:44,880
tears it apart

00:05:42,960 --> 00:05:46,160
and it says okay i know where this piece

00:05:44,880 --> 00:05:47,520
of information is i know where this

00:05:46,160 --> 00:05:49,440
piece of information is what's the

00:05:47,520 --> 00:05:51,759
shortest way between them

00:05:49,440 --> 00:05:54,400
and it's kind of like a gps positioning

00:05:51,759 --> 00:05:57,440
uh gps in your phone or your car

00:05:54,400 --> 00:06:00,720
uh it's built on historical statistics

00:05:57,440 --> 00:06:02,720
these statistics are are great but

00:06:00,720 --> 00:06:04,479
if i want to go to the local uh my local

00:06:02,720 --> 00:06:05,440
favorite restaurant it's left out of the

00:06:04,479 --> 00:06:07,120
driveway right

00:06:05,440 --> 00:06:08,479
at the end of the street over the

00:06:07,120 --> 00:06:10,720
railroad tracks

00:06:08,479 --> 00:06:13,199
and the restaurant's right on the left

00:06:10,720 --> 00:06:14,800
well my gps doesn't know what the trains

00:06:13,199 --> 00:06:17,440
parked across its tracks doesn't know

00:06:14,800 --> 00:06:19,440
the guy two houses down had a water

00:06:17,440 --> 00:06:21,440
leak and flooded out the road so

00:06:19,440 --> 00:06:24,000
historical information is great but it

00:06:21,440 --> 00:06:26,400
doesn't always help if you're adding a

00:06:24,000 --> 00:06:29,360
lot of data or changing a lot of data

00:06:26,400 --> 00:06:31,520
the optimizer can easily get confused by

00:06:29,360 --> 00:06:33,680
the way mysql wants to optimize each

00:06:31,520 --> 00:06:35,360
query every time it sees it there's no

00:06:33,680 --> 00:06:36,560
locking down the query plan like in

00:06:35,360 --> 00:06:38,080
oracle

00:06:36,560 --> 00:06:39,520
uh later in this presentation look for

00:06:38,080 --> 00:06:40,240
optimizer hints if you want to see how

00:06:39,520 --> 00:06:42,720
there's a way

00:06:40,240 --> 00:06:44,000
kind of how to do that oh by the way i

00:06:42,720 --> 00:06:46,080
will teach you how to look at a query

00:06:44,000 --> 00:06:48,800
plan and how to get it

00:06:46,080 --> 00:06:50,240
so if your query has five joints the

00:06:48,800 --> 00:06:52,960
optimizer has

00:06:50,240 --> 00:06:53,759
a hundred well has five factorial or 120

00:06:52,960 --> 00:06:55,919
different options

00:06:53,759 --> 00:06:57,360
just for the joints that doesn't get

00:06:55,919 --> 00:06:58,639
into anything on the right hand side of

00:06:57,360 --> 00:07:01,280
the where clause

00:06:58,639 --> 00:07:02,720
so if you have 120 different ways you

00:07:01,280 --> 00:07:05,360
can assemble that thing

00:07:02,720 --> 00:07:06,560
you have the ultimate ikea slash lego

00:07:05,360 --> 00:07:08,720
nightmare

00:07:06,560 --> 00:07:10,800
but there are heuristics that the

00:07:08,720 --> 00:07:12,639
optimizer follows

00:07:10,800 --> 00:07:14,720
now for you you're going to end up using

00:07:12,639 --> 00:07:17,120
something called explain

00:07:14,720 --> 00:07:18,000
now explain something i could teach in a

00:07:17,120 --> 00:07:20,240
two-week class

00:07:18,000 --> 00:07:21,759
and kind of get the major highlights on

00:07:20,240 --> 00:07:23,120
uh in five minutes i'm not going to be

00:07:21,759 --> 00:07:25,039
able to get to too much but i'll kind of

00:07:23,120 --> 00:07:27,199
give you the oversight

00:07:25,039 --> 00:07:28,479
uh this is the syntax i've explained by

00:07:27,199 --> 00:07:30,000
the way that's our new shell on the

00:07:28,479 --> 00:07:32,960
right hand side which has command

00:07:30,000 --> 00:07:32,960
completion and wonderful

00:07:33,360 --> 00:07:36,240
help section there

00:07:36,400 --> 00:07:40,319
by the way if you go through the mysql

00:07:38,400 --> 00:07:43,120
manual it's worth reading chapter 8

00:07:40,319 --> 00:07:44,319
if you're trying to figure out how to

00:07:43,120 --> 00:07:45,919
get a handle on this

00:07:44,319 --> 00:07:47,280
it explains a lot of in detail there's

00:07:45,919 --> 00:07:48,400
some books that i'll mention later that

00:07:47,280 --> 00:07:52,479
are worth

00:07:48,400 --> 00:07:55,360
pursuing now the trouble with explain is

00:07:52,479 --> 00:07:57,280
there's different types of explain

00:07:55,360 --> 00:07:58,560
we have straight explain explain with

00:07:57,280 --> 00:08:01,680
different formats explain

00:07:58,560 --> 00:08:03,759
analyze and visual explain this is an

00:08:01,680 --> 00:08:05,840
example of running explain on a query

00:08:03,759 --> 00:08:07,680
uh hopefully you can see my my mouse

00:08:05,840 --> 00:08:09,360
bouncing around here

00:08:07,680 --> 00:08:11,360
put explain in front of the query

00:08:09,360 --> 00:08:13,360
explain select from star

00:08:11,360 --> 00:08:15,680
select star from the table city where

00:08:13,360 --> 00:08:18,560
country code equals gbr

00:08:15,680 --> 00:08:20,319
that's my actual query over here are the

00:08:18,560 --> 00:08:21,680
details that the optimizer gets back

00:08:20,319 --> 00:08:23,759
from explaining it's saying well we're

00:08:21,680 --> 00:08:25,360
hitting the table city

00:08:23,759 --> 00:08:28,000
we have a reference in here the

00:08:25,360 --> 00:08:30,319
references to country code equals gbr

00:08:28,000 --> 00:08:31,520
possible keys we could use or indexes is

00:08:30,319 --> 00:08:33,599
country code

00:08:31,520 --> 00:08:35,039
by the way that uh index likes a three

00:08:33,599 --> 00:08:37,680
we'll get into why the length count

00:08:35,039 --> 00:08:38,800
is uh important later uh filtered we'll

00:08:37,680 --> 00:08:40,800
go into that a little bit later

00:08:38,800 --> 00:08:42,640
but down here is the actual query plan

00:08:40,800 --> 00:08:43,760
where the optimizer takes what you gave

00:08:42,640 --> 00:08:46,160
it up here

00:08:43,760 --> 00:08:49,040
and rewrites it so that the database can

00:08:46,160 --> 00:08:50,240
return what you asked for

00:08:49,040 --> 00:08:52,160
once again if you don't get this the

00:08:50,240 --> 00:08:53,360
first time through watch again go

00:08:52,160 --> 00:08:55,920
through the slide deck

00:08:53,360 --> 00:08:57,600
play with it visual explain comes with

00:08:55,920 --> 00:08:58,959
mysql workbench which is another free

00:08:57,600 --> 00:09:00,800
tool that we have

00:08:58,959 --> 00:09:03,200
and that's basically the same

00:09:00,800 --> 00:09:06,320
information just in a graphical format

00:09:03,200 --> 00:09:07,760
by the way green boxes usually are good

00:09:06,320 --> 00:09:10,399
red boxes mean you have to have a little

00:09:07,760 --> 00:09:10,399
bit of concern

00:09:10,640 --> 00:09:15,040
well we also have tree format this will

00:09:13,120 --> 00:09:17,040
tell you that

00:09:15,040 --> 00:09:18,560
this is slightly different query it's

00:09:17,040 --> 00:09:20,320
using something called a hash join

00:09:18,560 --> 00:09:21,360
between two tables in this case we're

00:09:20,320 --> 00:09:23,440
going to have

00:09:21,360 --> 00:09:24,880
the table city joined to the table

00:09:23,440 --> 00:09:28,080
called country

00:09:24,880 --> 00:09:28,080
and we're going to

00:09:28,320 --> 00:09:32,000
mash those together and this is coming

00:09:30,800 --> 00:09:36,560
back with some information

00:09:32,000 --> 00:09:38,880
on uh the relative cost of the various

00:09:36,560 --> 00:09:41,040
various optimizations or the joinings

00:09:38,880 --> 00:09:42,880
that we're doing

00:09:41,040 --> 00:09:44,160
for medical json this gives you even

00:09:42,880 --> 00:09:45,600
more information

00:09:44,160 --> 00:09:47,200
i don't think any of you are probably

00:09:45,600 --> 00:09:48,160
going to want this level of information

00:09:47,200 --> 00:09:50,560
maybe in a couple years

00:09:48,160 --> 00:09:52,160
so it's nice to show you that it's here

00:09:50,560 --> 00:09:53,040
once again it tells us the table we're

00:09:52,160 --> 00:09:54,560
going after

00:09:53,040 --> 00:09:56,959
the number of rows it's going to have to

00:09:54,560 --> 00:09:57,360
scan over here it says we're getting a

00:09:56,959 --> 00:10:00,720
hash

00:09:57,360 --> 00:10:03,839
join the read cost the evaluation cost

00:10:00,720 --> 00:10:05,680
prefix cost data read per join is going

00:10:03,839 --> 00:10:07,680
to be six megabytes

00:10:05,680 --> 00:10:09,440
so the information's out there is just

00:10:07,680 --> 00:10:12,240
learning how to decipher it

00:10:09,440 --> 00:10:14,480
now something we did add in mysql 8018

00:10:12,240 --> 00:10:15,680
by the way the latest is 802.22 so if

00:10:14,480 --> 00:10:18,959
this has been out there for

00:10:15,680 --> 00:10:20,240
a bit over a year normally explain uses

00:10:18,959 --> 00:10:22,079
historical information

00:10:20,240 --> 00:10:23,600
explain analyze actually goes out and

00:10:22,079 --> 00:10:25,279
runs your query

00:10:23,600 --> 00:10:27,519
so big warning if you have a big nasty

00:10:25,279 --> 00:10:28,880
analytics query that you think is going

00:10:27,519 --> 00:10:30,079
to run for a couple hours and suck up

00:10:28,880 --> 00:10:32,320
all the memory uh

00:10:30,079 --> 00:10:33,600
probably better to avoid this during

00:10:32,320 --> 00:10:35,680
business hours

00:10:33,600 --> 00:10:37,120
so explain analyze goes out there and

00:10:35,680 --> 00:10:38,959
runs the query

00:10:37,120 --> 00:10:40,880
and comes back and gives you the actual

00:10:38,959 --> 00:10:43,440
time by the way if you

00:10:40,880 --> 00:10:45,120
are playing with explain and explain

00:10:43,440 --> 00:10:46,079
analyze and know a big variance between

00:10:45,120 --> 00:10:48,959
actual time

00:10:46,079 --> 00:10:50,800
and the time that the estimate is run

00:10:48,959 --> 00:10:51,920
explain analyze on the table and double

00:10:50,800 --> 00:10:54,240
check the indexes

00:10:51,920 --> 00:10:56,000
uh just to make sure they're they're not

00:10:54,240 --> 00:10:58,240
mismatched in size or

00:10:56,000 --> 00:11:00,079
data type and that should clean up

00:10:58,240 --> 00:11:03,360
things a bit for you

00:11:00,079 --> 00:11:05,680
so more on using explain later

00:11:03,360 --> 00:11:07,040
on to something else even more fun

00:11:05,680 --> 00:11:09,680
indexes

00:11:07,040 --> 00:11:10,399
uh oftentimes you see people throw

00:11:09,680 --> 00:11:13,279
indexes

00:11:10,399 --> 00:11:14,000
at a database because they've read

00:11:13,279 --> 00:11:16,880
somewhere that

00:11:14,000 --> 00:11:18,240
indexing makes everything faster and

00:11:16,880 --> 00:11:21,279
indexes do let you

00:11:18,240 --> 00:11:22,880
track down things faster however there

00:11:21,279 --> 00:11:25,040
are some problems with indexes there's

00:11:22,880 --> 00:11:25,680
some overhead and often people apply

00:11:25,040 --> 00:11:28,560
indexes

00:11:25,680 --> 00:11:29,360
poorly let's see nothing on the qa right

00:11:28,560 --> 00:11:31,519
now

00:11:29,360 --> 00:11:33,600
so think of the index as a table with

00:11:31,519 --> 00:11:36,000
shortcuts to another table

00:11:33,600 --> 00:11:37,440
uh so someone comes and looks up the

00:11:36,000 --> 00:11:38,160
vehicle identification number of your

00:11:37,440 --> 00:11:40,640
car

00:11:38,160 --> 00:11:41,519
that's an index into another table that

00:11:40,640 --> 00:11:44,800
actually has

00:11:41,519 --> 00:11:47,360
the real data on your car so the the

00:11:44,800 --> 00:11:49,279
index is actually kind of a a small

00:11:47,360 --> 00:11:51,360
junior version of the table

00:11:49,279 --> 00:11:52,320
by the way the more indexes and tables

00:11:51,360 --> 00:11:53,760
you have

00:11:52,320 --> 00:11:55,360
the more this database wants to have

00:11:53,760 --> 00:11:56,560
them in memory and the more memories

00:11:55,360 --> 00:11:57,760
taken up

00:11:56,560 --> 00:11:59,839
by the way if you've never heard this

00:11:57,760 --> 00:12:02,320
before databases love memory

00:11:59,839 --> 00:12:04,399
more than a faster processor so memory

00:12:02,320 --> 00:12:07,839
is where you spend your your money

00:12:04,399 --> 00:12:10,399
so mysql has many types of indexes

00:12:07,839 --> 00:12:12,079
once again this is the syntax for

00:12:10,399 --> 00:12:14,959
creating indexes

00:12:12,079 --> 00:12:16,079
we have unique full text spatial a whole

00:12:14,959 --> 00:12:20,079
bunch of qualifiers

00:12:16,079 --> 00:12:21,440
algorithms block sizes

00:12:20,079 --> 00:12:23,360
whether you want to be a bee tree or

00:12:21,440 --> 00:12:24,639
hash but that's kind of beyond the pale

00:12:23,360 --> 00:12:27,600
for today

00:12:24,639 --> 00:12:29,440
so let's create a simple table with a

00:12:27,600 --> 00:12:31,920
primary key

00:12:29,440 --> 00:12:33,839
mysql's main storage engine inodb

00:12:31,920 --> 00:12:36,320
prefers to have a primary key

00:12:33,839 --> 00:12:37,120
if you don't specify one it will pick

00:12:36,320 --> 00:12:38,720
one

00:12:37,120 --> 00:12:40,880
it will make up a dummy one and i can

00:12:38,720 --> 00:12:43,839
guarantee you will not be performant

00:12:40,880 --> 00:12:45,279
so pick your own primary key so we have

00:12:43,839 --> 00:12:48,079
a simple table here

00:12:45,279 --> 00:12:49,920
table called t1 we have three columns

00:12:48,079 --> 00:12:51,600
now the first one's an integer

00:12:49,920 --> 00:12:53,200
we're saying it's not null i'll go in

00:12:51,600 --> 00:12:55,839
the null later uh we're gonna

00:12:53,200 --> 00:12:57,120
auto increment so every time we input a

00:12:55,839 --> 00:12:58,560
row of data

00:12:57,120 --> 00:13:00,320
it's gonna take whatever the previous

00:12:58,560 --> 00:13:02,639
value was and increment it by

00:13:00,320 --> 00:13:04,160
whatever you set it to be usually a one

00:13:02,639 --> 00:13:04,639
and we're gonna call this our primary

00:13:04,160 --> 00:13:06,160
key

00:13:04,639 --> 00:13:07,680
so this is how we're going to look up

00:13:06,160 --> 00:13:09,200
most of the data on

00:13:07,680 --> 00:13:11,600
this table then we have two other

00:13:09,200 --> 00:13:11,600
columns

00:13:11,839 --> 00:13:15,519
now an index is a list of keys and

00:13:14,720 --> 00:13:16,880
you'll also

00:13:15,519 --> 00:13:19,200
you'll often hear them used

00:13:16,880 --> 00:13:20,000
interchangeably which can kind of get

00:13:19,200 --> 00:13:22,160
confusing

00:13:20,000 --> 00:13:23,680
but there is a slight difference but in

00:13:22,160 --> 00:13:24,880
the mysql world you can kind of use them

00:13:23,680 --> 00:13:27,200
interchangeably

00:13:24,880 --> 00:13:28,399
so don't worry about that if you see key

00:13:27,200 --> 00:13:32,079
and think index or

00:13:28,399 --> 00:13:34,480
vice versa now the primary key

00:13:32,079 --> 00:13:35,440
is one that's hopefully uniquely defined

00:13:34,480 --> 00:13:37,600
for a row and

00:13:35,440 --> 00:13:38,480
should be immutable uh you don't want to

00:13:37,600 --> 00:13:41,519
go back and

00:13:38,480 --> 00:13:42,720
up those move stuff around later as i

00:13:41,519 --> 00:13:45,760
mentioned before

00:13:42,720 --> 00:13:47,600
nodb wants a primary key very badly and

00:13:45,760 --> 00:13:48,720
please don't use null values i'll give

00:13:47,600 --> 00:13:50,880
them another thing

00:13:48,720 --> 00:13:52,639
also it wants the numbers to

00:13:50,880 --> 00:13:54,320
monotonically increase

00:13:52,639 --> 00:13:56,720
that's like going one two three four

00:13:54,320 --> 00:13:59,279
five or 10 20 30 40.

00:13:56,720 --> 00:14:01,279
if you really really love uuids which do

00:13:59,279 --> 00:14:02,880
not monotonically increase and are kind

00:14:01,279 --> 00:14:05,839
of a waste of space

00:14:02,880 --> 00:14:07,279
we have a function called uuid to bin uh

00:14:05,839 --> 00:14:11,120
which will

00:14:07,279 --> 00:14:11,120
let you work with mysql efficiently

00:14:11,199 --> 00:14:14,480
so something else you can do is you can

00:14:13,680 --> 00:14:17,440
actually index

00:14:14,480 --> 00:14:18,160
on the prefix of a column sometimes

00:14:17,440 --> 00:14:21,600
getting right

00:14:18,160 --> 00:14:24,560
in the rough area is close enough

00:14:21,600 --> 00:14:26,480
saying like you have last names that are

00:14:24,560 --> 00:14:28,160
75 characters long

00:14:26,480 --> 00:14:30,079
but you do some analysis on that you

00:14:28,160 --> 00:14:32,399
find out that 99.9

00:14:30,079 --> 00:14:34,399
of your customers uh the after the first

00:14:32,399 --> 00:14:35,600
10 characters there's very little things

00:14:34,399 --> 00:14:38,720
that aren't unique

00:14:35,600 --> 00:14:40,240
uh you might have 24 5 um von

00:14:38,720 --> 00:14:42,000
vluchensteins but

00:14:40,240 --> 00:14:44,079
if you get devon blue you you're a

00:14:42,000 --> 00:14:45,839
pretty good

00:14:44,079 --> 00:14:47,519
pretty good close to the records that

00:14:45,839 --> 00:14:50,480
you want so in this case

00:14:47,519 --> 00:14:50,880
we're going to create an index part of

00:14:50,480 --> 00:14:52,800
name

00:14:50,880 --> 00:14:56,839
on the customer field and we're going to

00:14:52,800 --> 00:14:58,240
use the first 10 characters of the name

00:14:56,839 --> 00:14:59,680
column

00:14:58,240 --> 00:15:01,360
uh you can also have multi-column

00:14:59,680 --> 00:15:03,760
indexes in this

00:15:01,360 --> 00:15:04,800
table we have columns for last name and

00:15:03,760 --> 00:15:06,560
first name

00:15:04,800 --> 00:15:08,800
so we're going to create an index last

00:15:06,560 --> 00:15:11,120
name then first name

00:15:08,800 --> 00:15:12,880
so to use this column we can search on

00:15:11,120 --> 00:15:15,199
last name and first name or just

00:15:12,880 --> 00:15:16,320
last name it won't work on just first

00:15:15,199 --> 00:15:18,000
name

00:15:16,320 --> 00:15:20,160
it kind of works left to right so put

00:15:18,000 --> 00:15:21,440
the highest cardinality index on the

00:15:20,160 --> 00:15:23,600
first field

00:15:21,440 --> 00:15:25,279
if you're using year month day that

00:15:23,600 --> 00:15:26,000
index will work on your month day year

00:15:25,279 --> 00:15:28,560
month and year

00:15:26,000 --> 00:15:30,160
but not month day or just day or just

00:15:28,560 --> 00:15:31,440
month

00:15:30,160 --> 00:15:33,920
whether if you have questions pop them

00:15:31,440 --> 00:15:37,920
up on q a i'll

00:15:33,920 --> 00:15:39,600
check on that when when i can

00:15:37,920 --> 00:15:41,519
hashing value sometimes you have data

00:15:39,600 --> 00:15:43,920
that just doesn't quite fit

00:15:41,519 --> 00:15:44,800
uh that mold so what you can do is you

00:15:43,920 --> 00:15:47,120
can

00:15:44,800 --> 00:15:47,920
uh concat in this example we're counting

00:15:47,120 --> 00:15:51,360
two values

00:15:47,920 --> 00:15:51,360
and using md5 hash

00:15:51,440 --> 00:15:55,839
sometimes um things just don't work out

00:15:55,120 --> 00:15:57,360
the way you want

00:15:55,839 --> 00:15:59,040
also you can have things called a

00:15:57,360 --> 00:15:59,440
covering index where the index will

00:15:59,040 --> 00:16:00,959
cover

00:15:59,440 --> 00:16:02,320
all the values you need to return a

00:16:00,959 --> 00:16:05,680
query you don't actually have to dive

00:16:02,320 --> 00:16:05,680
into the data table itself

00:16:06,639 --> 00:16:10,320
i mentioned that a little bit before i

00:16:08,240 --> 00:16:12,079
went to slide uh unique indexes there's

00:16:10,320 --> 00:16:14,720
only one value per row

00:16:12,079 --> 00:16:16,800
um full text indexes if you're doing

00:16:14,720 --> 00:16:20,320
tech searches we can do

00:16:16,800 --> 00:16:21,680
uh with an odb a full text search that's

00:16:20,320 --> 00:16:23,279
pretty interesting one of the

00:16:21,680 --> 00:16:25,120
interesting features is you can actually

00:16:23,279 --> 00:16:26,399
say uh the first word

00:16:25,120 --> 00:16:28,480
that you're searching for has to be

00:16:26,399 --> 00:16:30,079
within x numbers of the number of words

00:16:28,480 --> 00:16:33,440
of the second one

00:16:30,079 --> 00:16:35,519
uh secondary indexes this is um

00:16:33,440 --> 00:16:36,720
your you have your primary index and you

00:16:35,519 --> 00:16:37,759
have something else in that column

00:16:36,720 --> 00:16:39,519
you've indexed maybe

00:16:37,759 --> 00:16:41,199
the customer zip code well that

00:16:39,519 --> 00:16:43,600
secondary index will actually

00:16:41,199 --> 00:16:45,040
point to the entry for the primary index

00:16:43,600 --> 00:16:47,120
entry for the table

00:16:45,040 --> 00:16:50,160
and spatial indexes these are actually

00:16:47,120 --> 00:16:51,759
our trees for gis type data very

00:16:50,160 --> 00:16:52,240
interesting but not what we're covering

00:16:51,759 --> 00:16:54,639
today

00:16:52,240 --> 00:16:55,440
in detail also we have functional

00:16:54,639 --> 00:16:57,920
indexes

00:16:55,440 --> 00:16:58,639
um here's some examples functional

00:16:57,920 --> 00:17:00,720
indexes

00:16:58,639 --> 00:17:02,480
are the result of some sort of function

00:17:00,720 --> 00:17:04,640
so if you want to round up to the

00:17:02,480 --> 00:17:07,679
nearest 100 to be able to

00:17:04,640 --> 00:17:09,199
give people price cost breaks um or you

00:17:07,679 --> 00:17:10,720
want to sub two things

00:17:09,199 --> 00:17:12,160
like the second example here call one

00:17:10,720 --> 00:17:13,039
plus call two so that's the cost of

00:17:12,160 --> 00:17:14,319
goods sold

00:17:13,039 --> 00:17:18,400
and the shipping cost so you have a

00:17:14,319 --> 00:17:20,319
rough idea what your costs are

00:17:18,400 --> 00:17:22,640
multi-value indexes came out fairly

00:17:20,319 --> 00:17:25,280
recently with the json data type

00:17:22,640 --> 00:17:27,199
we had a lot of people putting in uh

00:17:25,280 --> 00:17:27,839
very extensive json documents with

00:17:27,199 --> 00:17:30,640
arrays

00:17:27,839 --> 00:17:31,840
in there and before multi-volume indexes

00:17:30,640 --> 00:17:35,760
every

00:17:31,840 --> 00:17:39,919
index entry could only point to one

00:17:35,760 --> 00:17:42,240
row in a data table well with all these

00:17:39,919 --> 00:17:44,080
arrays that didn't quite make sense so

00:17:42,240 --> 00:17:45,520
with multi-value indexes you could now

00:17:44,080 --> 00:17:49,679
have more index pointers

00:17:45,520 --> 00:17:53,280
than than rows and in this example here

00:17:49,679 --> 00:17:56,880
we're looking for the value of 3

00:17:53,280 --> 00:17:58,799
in that json array

00:17:56,880 --> 00:18:00,480
by the way that really pays off above

00:17:58,799 --> 00:18:03,280
about 20 million rows

00:18:00,480 --> 00:18:04,480
the speed is just absolutely amazing so

00:18:03,280 --> 00:18:07,200
mysql has

00:18:04,480 --> 00:18:08,080
two main types of index structures uh

00:18:07,200 --> 00:18:10,720
the balance

00:18:08,080 --> 00:18:11,360
tree which you see on the left there

00:18:10,720 --> 00:18:14,000
values

00:18:11,360 --> 00:18:15,120
0 to 40 here pulling off on this left

00:18:14,000 --> 00:18:18,160
branch

00:18:15,120 --> 00:18:19,919
and that's further broken down it's a

00:18:18,160 --> 00:18:23,039
binary search

00:18:19,919 --> 00:18:25,919
it's worked well for for several years

00:18:23,039 --> 00:18:27,679
hash joints basically they're more

00:18:25,919 --> 00:18:28,000
efficient than the traditional nested

00:18:27,679 --> 00:18:32,400
loop

00:18:28,000 --> 00:18:32,400
join that mysql is known for um

00:18:33,280 --> 00:18:36,600
you'll see a lot of your queries once

00:18:34,880 --> 00:18:40,080
you get running i think it was

00:18:36,600 --> 00:18:41,600
8018 8019 era

00:18:40,080 --> 00:18:45,039
just suddenly start running a lot faster

00:18:41,600 --> 00:18:45,039
because the hash joins are automatic

00:18:45,360 --> 00:18:50,320
now please keep in mind uh the optimizer

00:18:48,640 --> 00:18:54,240
is a complicated piece of software but

00:18:50,320 --> 00:18:56,559
some of the heuristics are not exactly

00:18:54,240 --> 00:18:57,760
enlightened if there is a choice between

00:18:56,559 --> 00:19:00,000
multiple indexes

00:18:57,760 --> 00:19:00,799
on joining tables or searching for

00:19:00,000 --> 00:19:03,919
something

00:19:00,799 --> 00:19:05,520
uh mysql normally grabs the index with

00:19:03,919 --> 00:19:07,360
the smallest number of rows

00:19:05,520 --> 00:19:09,280
uh hope it hopefully thinks it's the

00:19:07,360 --> 00:19:10,640
most

00:19:09,280 --> 00:19:12,480
my skulls selective use indexes on

00:19:10,640 --> 00:19:14,960
columns more efficiently if they're clay

00:19:12,480 --> 00:19:17,120
declared as the same type and size

00:19:14,960 --> 00:19:18,320
so compare apples with apples bananas

00:19:17,120 --> 00:19:21,360
with bananas

00:19:18,320 --> 00:19:22,080
uh far car and car are great but doing

00:19:21,360 --> 00:19:26,320
varchar

00:19:22,080 --> 00:19:28,400
and say a real value or a decimal

00:19:26,320 --> 00:19:29,760
it's going to have to be cast and each

00:19:28,400 --> 00:19:30,880
row is going to have to be cast so you

00:19:29,760 --> 00:19:34,240
can see where that has

00:19:30,880 --> 00:19:36,640
extra complexity there by the way

00:19:34,240 --> 00:19:38,240
check your string collations and

00:19:36,640 --> 00:19:39,600
character sets

00:19:38,240 --> 00:19:41,440
for instance if i'm doing something with

00:19:39,600 --> 00:19:44,240
utf-8 mb4

00:19:41,440 --> 00:19:47,520
and i'm combining it with latin one it

00:19:44,240 --> 00:19:49,280
kind of gets messy things have to be

00:19:47,520 --> 00:19:52,559
set up and evaluated separately it's

00:19:49,280 --> 00:19:54,799
just not an easy comparison okay

00:19:52,559 --> 00:19:56,000
null back in the early days of

00:19:54,799 --> 00:19:59,039
structured query language

00:19:56,000 --> 00:20:00,559
they wanted a way to represent that they

00:19:59,039 --> 00:20:05,600
didn't know something

00:20:00,559 --> 00:20:08,240
so they came with the idea of no

00:20:05,600 --> 00:20:09,200
the old binary trick was zero for false

00:20:08,240 --> 00:20:11,919
one for true

00:20:09,200 --> 00:20:14,159
and don't know null uh great idea the

00:20:11,919 --> 00:20:17,280
only trouble is null has kind of um

00:20:14,159 --> 00:20:19,039
some nasty side effects uh this is a

00:20:17,280 --> 00:20:22,559
nice visual example of

00:20:19,039 --> 00:20:23,600
of um what null can mean to a lot of

00:20:22,559 --> 00:20:26,880
folks

00:20:23,600 --> 00:20:30,320
uh it's not exactly true but it's a it's

00:20:26,880 --> 00:20:32,880
it's cute so

00:20:30,320 --> 00:20:34,240
if you have a column that you're

00:20:32,880 --> 00:20:35,600
indexing and you have a whole bunch of

00:20:34,240 --> 00:20:37,520
null values in there

00:20:35,600 --> 00:20:39,520
uh it's kind of like you go through the

00:20:37,520 --> 00:20:41,360
kitchen looking for a knife and you know

00:20:39,520 --> 00:20:42,640
it's not with the rest of the silverware

00:20:41,360 --> 00:20:44,559
and you eventually have to get down to

00:20:42,640 --> 00:20:45,600
the junk drawer and between pulling out

00:20:44,559 --> 00:20:47,200
the

00:20:45,600 --> 00:20:49,520
uh the flashlights holding dead

00:20:47,200 --> 00:20:50,880
batteries and that old strip of velcro

00:20:49,520 --> 00:20:52,640
that you're going to use for something

00:20:50,880 --> 00:20:54,000
somewhere in that junk drawer are your

00:20:52,640 --> 00:20:57,200
null values so

00:20:54,000 --> 00:20:59,280
they're not very efficient so please

00:20:57,200 --> 00:21:03,600
avoid nulls in your primary

00:20:59,280 --> 00:21:05,679
keys and your indexes invisible indexes

00:21:03,600 --> 00:21:07,679
uh this is something when i heard about

00:21:05,679 --> 00:21:10,080
i thought that's kind of a weird idea

00:21:07,679 --> 00:21:12,559
what is an invisible index

00:21:10,080 --> 00:21:14,559
well in the past if you were trying to

00:21:12,559 --> 00:21:16,880
figure out if an index was helping you

00:21:14,559 --> 00:21:17,600
what you do is you look at that index

00:21:16,880 --> 00:21:19,600
and say i

00:21:17,600 --> 00:21:21,840
don't know if you're a good index or not

00:21:19,600 --> 00:21:25,200
you'd run explain on your query

00:21:21,840 --> 00:21:26,080
you'd remove that index just uh delete

00:21:25,200 --> 00:21:27,760
it

00:21:26,080 --> 00:21:29,600
uh run your run explain and while you're

00:21:27,760 --> 00:21:31,760
looking at the output to explain

00:21:29,600 --> 00:21:32,960
you get phone calls texts screams from

00:21:31,760 --> 00:21:34,880
down the hallway

00:21:32,960 --> 00:21:37,039
especially from a power user about their

00:21:34,880 --> 00:21:40,080
their query suddenly running very slowly

00:21:37,039 --> 00:21:43,200
i guess what they're using that index

00:21:40,080 --> 00:21:44,320
well you uh decide that you need to get

00:21:43,200 --> 00:21:47,200
that index back

00:21:44,320 --> 00:21:48,240
and it can take seconds minutes hours

00:21:47,200 --> 00:21:50,240
days

00:21:48,240 --> 00:21:52,320
uh hopefully not longer than a couple

00:21:50,240 --> 00:21:54,960
minutes but sometimes it takes longer

00:21:52,320 --> 00:21:56,080
to rebuild that index well after

00:21:54,960 --> 00:21:58,880
invisible indexes

00:21:56,080 --> 00:21:59,919
uh what you can do is look at that index

00:21:58,880 --> 00:22:02,960
say i'm

00:21:59,919 --> 00:22:05,200
doubtful about your use run explain make

00:22:02,960 --> 00:22:07,200
the index invisible the optimizer can no

00:22:05,200 --> 00:22:10,720
longer see that index it's a

00:22:07,200 --> 00:22:13,840
uh a server wide

00:22:10,720 --> 00:22:15,200
blank out of that index rerun explain

00:22:13,840 --> 00:22:17,360
suddenly you start getting the text

00:22:15,200 --> 00:22:18,159
screams from the power user about slow

00:22:17,360 --> 00:22:20,400
query

00:22:18,159 --> 00:22:21,200
you make the index visible again power

00:22:20,400 --> 00:22:23,919
user is happy

00:22:21,200 --> 00:22:25,120
everyone goes along their way and you

00:22:23,919 --> 00:22:27,120
start playing it on the network

00:22:25,120 --> 00:22:30,559
javascript gdpr or slack or

00:22:27,120 --> 00:22:32,080
the cloud by the way the sys schema

00:22:30,559 --> 00:22:33,840
which is something you can look up using

00:22:32,080 --> 00:22:35,360
mysql workbench

00:22:33,840 --> 00:22:37,520
will show you which indexes have not

00:22:35,360 --> 00:22:39,360
been used and are candidates for removal

00:22:37,520 --> 00:22:41,280
they'll also show you

00:22:39,360 --> 00:22:42,880
queries that are running without indexes

00:22:41,280 --> 00:22:46,400
that are candidates to be

00:22:42,880 --> 00:22:50,080
indexed for the removal ones

00:22:46,400 --> 00:22:51,600
i always urge caution make a big backup

00:22:50,080 --> 00:22:54,720
or two before you delete them

00:22:51,600 --> 00:22:56,799
and i recommend turning invisible by the

00:22:54,720 --> 00:22:57,600
way after a reboot is not a good time to

00:22:56,799 --> 00:23:00,640
look at the

00:22:57,600 --> 00:23:02,000
uh the statistics because the statistics

00:23:00,640 --> 00:23:05,200
are historical

00:23:02,000 --> 00:23:05,840
and get wiped out after a reboot so if

00:23:05,200 --> 00:23:09,280
you

00:23:05,840 --> 00:23:11,520
see an index it hasn't been used in

00:23:09,280 --> 00:23:13,440
two weeks maybe because this was after

00:23:11,520 --> 00:23:14,799
reboot by the way some indexes are out

00:23:13,440 --> 00:23:16,320
there that are only used once a quarter

00:23:14,799 --> 00:23:19,360
or once a year so

00:23:16,320 --> 00:23:21,760
be careful before you blow anything away

00:23:19,360 --> 00:23:22,960
how to use invisible index real simple

00:23:21,760 --> 00:23:26,159
alter table

00:23:22,960 --> 00:23:28,000
table name and name the index

00:23:26,159 --> 00:23:31,280
and make it invisible then if you want

00:23:28,000 --> 00:23:33,280
to turn it visible it's just reverse

00:23:31,280 --> 00:23:35,520
histograms this is something that came

00:23:33,280 --> 00:23:38,960
out with 8-0 so it's been out here since

00:23:35,520 --> 00:23:41,039
april of 2018. they're kind of

00:23:38,960 --> 00:23:42,000
a different way of looking at things

00:23:41,039 --> 00:23:44,080
kind of the

00:23:42,000 --> 00:23:46,640
uh the other end of the spectrum from

00:23:44,080 --> 00:23:48,320
indexes and no they're not gluten free

00:23:46,640 --> 00:23:51,360
or keto friendly

00:23:48,320 --> 00:23:54,480
this is a histogram of the heights of

00:23:51,360 --> 00:23:57,279
one ten thousand u.s females as you see

00:23:54,480 --> 00:23:59,440
here the height tends to center around

00:23:57,279 --> 00:24:01,840
these two values and peak off

00:23:59,440 --> 00:24:05,520
but about three thousand women at i'm

00:24:01,840 --> 00:24:07,279
guessing that's 165 centimeters

00:24:05,520 --> 00:24:08,559
so wikipedia says the histogram is an

00:24:07,279 --> 00:24:11,360
accurate representation of the

00:24:08,559 --> 00:24:12,960
distribution of numerical data

00:24:11,360 --> 00:24:14,720
this means the optimizer knows where

00:24:12,960 --> 00:24:17,440
your data is

00:24:14,720 --> 00:24:18,480
if it doesn't have the statistics it

00:24:17,440 --> 00:24:20,880
kind of has to

00:24:18,480 --> 00:24:22,799
search around and find everything so the

00:24:20,880 --> 00:24:24,480
histograms help the optimizer find the

00:24:22,799 --> 00:24:25,760
most efficient query plan to fetch the

00:24:24,480 --> 00:24:28,000
data

00:24:25,760 --> 00:24:29,440
now there are two types singleton and

00:24:28,000 --> 00:24:31,279
equiheight

00:24:29,440 --> 00:24:32,480
by the way it's going to a histogram is

00:24:31,279 --> 00:24:35,760
going to

00:24:32,480 --> 00:24:39,760
divide up your data into logical buckets

00:24:35,760 --> 00:24:41,679
and histograms are primarily useful for

00:24:39,760 --> 00:24:43,440
non-indexed columns

00:24:41,679 --> 00:24:45,360
if the data doesn't churn a lot or

00:24:43,440 --> 00:24:46,080
doesn't churn at all i'd recommend using

00:24:45,360 --> 00:24:49,520
a histogram

00:24:46,080 --> 00:24:52,880
over an index by the way every time you

00:24:49,520 --> 00:24:55,520
update delete or modify an index

00:24:52,880 --> 00:24:57,440
entry there's overhead there and if you

00:24:55,520 --> 00:24:59,840
have several indexes on a table

00:24:57,440 --> 00:25:00,960
and you're doing lots of updates things

00:24:59,840 --> 00:25:04,320
can slow down there

00:25:00,960 --> 00:25:04,320
histograms don't have that

00:25:04,640 --> 00:25:08,799
and that's kind of the reason there by

00:25:06,799 --> 00:25:10,000
the way occasionally the optimizer will

00:25:08,799 --> 00:25:12,840
make index dives

00:25:10,000 --> 00:25:14,640
to double check the statistics on

00:25:12,840 --> 00:25:16,960
indexes

00:25:14,640 --> 00:25:18,400
the system does not actually double

00:25:16,960 --> 00:25:19,039
check with you to make sure if it's okay

00:25:18,400 --> 00:25:20,880
to do that

00:25:19,039 --> 00:25:22,720
just after you left for lunch or go home

00:25:20,880 --> 00:25:24,960
for the long weekend

00:25:22,720 --> 00:25:26,480
so index dives happen when you don't

00:25:24,960 --> 00:25:29,840
expect them and they can

00:25:26,480 --> 00:25:32,000
impact performance okay

00:25:29,840 --> 00:25:33,279
um occasionally optimizer fails to find

00:25:32,000 --> 00:25:34,480
the most efficient plan and ends up

00:25:33,279 --> 00:25:37,760
spending a lot of time

00:25:34,480 --> 00:25:40,000
executing the query uh that is necessary

00:25:37,760 --> 00:25:41,120
oh i need to go back on histograms uh

00:25:40,000 --> 00:25:42,799
the two types

00:25:41,120 --> 00:25:44,559
equal height uh so like you have a

00:25:42,799 --> 00:25:46,159
hundred entries

00:25:44,559 --> 00:25:47,600
and you set it up in four buckets you

00:25:46,159 --> 00:25:49,360
know that each of those four buckets is

00:25:47,600 --> 00:25:51,440
going to have 25 entries

00:25:49,360 --> 00:25:52,880
or you have 36 entries that all the

00:25:51,440 --> 00:25:54,159
entries are alphabetized so you know

00:25:52,880 --> 00:25:55,120
that all the entries that start with an

00:25:54,159 --> 00:25:59,120
a are going to be in

00:25:55,120 --> 00:26:00,000
bucket a so the optimizer assumes that

00:25:59,120 --> 00:26:01,919
the data is

00:26:00,000 --> 00:26:04,000
evenly distributed in columns which

00:26:01,919 --> 00:26:07,120
might not be true

00:26:04,000 --> 00:26:08,960
there's all sorts of of

00:26:07,120 --> 00:26:10,559
interesting data analysis tools that go

00:26:08,960 --> 00:26:13,039
along with this

00:26:10,559 --> 00:26:14,960
so the optimizer often doesn't have

00:26:13,039 --> 00:26:16,240
enough information on you know how many

00:26:14,960 --> 00:26:19,760
rows are in each table

00:26:16,240 --> 00:26:21,520
and their distribution so once again the

00:26:19,760 --> 00:26:23,200
two types of histograms equal height one

00:26:21,520 --> 00:26:26,799
bucket is a range of values

00:26:23,200 --> 00:26:29,120
once again we have an example here of

00:26:26,799 --> 00:26:30,559
having people line up a to g h to l m to

00:26:29,120 --> 00:26:32,480
t u to z

00:26:30,559 --> 00:26:33,679
uh singleton one bucket represents a

00:26:32,480 --> 00:26:37,360
single value

00:26:33,679 --> 00:26:40,080
um of that so here's an example of

00:26:37,360 --> 00:26:42,240
doing a frequency histogram we're going

00:26:40,080 --> 00:26:43,840
to have three buckets 101 102

00:26:42,240 --> 00:26:45,919
103. don't happen to know what happened

00:26:43,840 --> 00:26:46,720
to 104. we're going to insert into a

00:26:45,919 --> 00:26:52,080
table

00:26:46,720 --> 00:26:55,360
two 101s three 102s and one 104.

00:26:52,080 --> 00:26:58,320
if we do select from our table we see

00:26:55,360 --> 00:27:00,240
that we have the two 101s the three 102s

00:26:58,320 --> 00:27:01,760
and the 1104

00:27:00,240 --> 00:27:04,240
and we created a histogram with three

00:27:01,760 --> 00:27:06,480
buckets now the optimizer knows

00:27:04,240 --> 00:27:07,840
that if we're looking for something that

00:27:06,480 --> 00:27:10,799
has

00:27:07,840 --> 00:27:11,840
a value of 101 it's going to be

00:27:10,799 --> 00:27:14,480
somewhere in the first

00:27:11,840 --> 00:27:16,799
third of all the data if it's looking

00:27:14,480 --> 00:27:18,480
for something that's 101 or 102

00:27:16,799 --> 00:27:21,360
it knows it's going to be somewhere in

00:27:18,480 --> 00:27:24,000
the first 83 percent of the data

00:27:21,360 --> 00:27:25,679
and anything with 104 is going to be in

00:27:24,000 --> 00:27:30,240
the first hundred percent of the data

00:27:25,679 --> 00:27:33,440
by the way this is a singleton histogram

00:27:30,240 --> 00:27:36,000
now uh looking at the statistics of this

00:27:33,440 --> 00:27:36,799
the cumulative frequency we know that

00:27:36,000 --> 00:27:40,640
00:27:36,799 --> 00:27:43,039
is 33 percent of our of our data

00:27:40,640 --> 00:27:44,559
and we know that 102 the cumulative

00:27:43,039 --> 00:27:46,080
frequency is 83

00:27:44,559 --> 00:27:49,440
even though it's only 50 percent of our

00:27:46,080 --> 00:27:52,000
data but this gives the optimizer a

00:27:49,440 --> 00:27:55,520
better chance of finding your data

00:27:52,000 --> 00:27:55,520
very quickly very efficiently

00:27:55,679 --> 00:27:59,919
easy to create and remove histograms

00:27:58,320 --> 00:28:03,840
first example here

00:27:59,919 --> 00:28:07,279
analyze table update histograms on table

00:28:03,840 --> 00:28:08,880
on columns 1 c1 c2 and c3 each having 10

00:28:07,279 --> 00:28:11,919
buckets

00:28:08,880 --> 00:28:13,520
and we can also come back later and redo

00:28:11,919 --> 00:28:16,399
the histogram

00:28:13,520 --> 00:28:18,240
on c1 and c2 and we can decide that we

00:28:16,399 --> 00:28:19,840
don't really need a histogram on c2

00:28:18,240 --> 00:28:23,039
so these are three different histograms

00:28:19,840 --> 00:28:24,320
on three different columns

00:28:23,039 --> 00:28:26,720
if you want instrument information on

00:28:24,320 --> 00:28:30,000
histograms they're out there

00:28:26,720 --> 00:28:31,679
in our information schema

00:28:30,000 --> 00:28:34,000
they can tell you the table name the

00:28:31,679 --> 00:28:37,039
population the data type you're looking

00:28:34,000 --> 00:28:37,039
at in the bucket count

00:28:37,200 --> 00:28:40,399
now where histograms sign you'll have to

00:28:39,039 --> 00:28:40,960
give forgive me for giving this kind of

00:28:40,399 --> 00:28:42,320
elaborate

00:28:40,960 --> 00:28:44,399
demonstration we're going to create

00:28:42,320 --> 00:28:46,320
another simple table

00:28:44,399 --> 00:28:47,440
we're going to have in that table two

00:28:46,320 --> 00:28:49,600
values of one

00:28:47,440 --> 00:28:50,720
three values of two and three values of

00:28:49,600 --> 00:28:53,760
three

00:28:50,720 --> 00:28:57,440
so two ones three twos and four

00:28:53,760 --> 00:28:58,159
threes without a histogram we run

00:28:57,440 --> 00:29:00,080
explain

00:28:58,159 --> 00:29:02,799
we're going to explain select star from

00:29:00,080 --> 00:29:04,159
our table where x is greater than zero

00:29:02,799 --> 00:29:06,240
and remember that all our values are

00:29:04,159 --> 00:29:08,960
greater than zero

00:29:06,240 --> 00:29:10,720
the optimizer without a histogram is

00:29:08,960 --> 00:29:12,159
going to go well we know the table has

00:29:10,720 --> 00:29:16,000
nine rows in there

00:29:12,159 --> 00:29:18,559
and i'm going to guess that i know where

00:29:16,000 --> 00:29:20,399
it is i know where i'm gonna have to

00:29:18,559 --> 00:29:23,440
read at least a third of the table

00:29:20,399 --> 00:29:25,360
to get the information well

00:29:23,440 --> 00:29:27,679
we know that all the values are greater

00:29:25,360 --> 00:29:30,240
than that so

00:29:27,679 --> 00:29:31,679
the the filtered value here is kind of a

00:29:30,240 --> 00:29:33,279
estimated percentage of the table rows

00:29:31,679 --> 00:29:36,640
that need to be

00:29:33,279 --> 00:29:38,399
looked at now where the histogram

00:29:36,640 --> 00:29:39,679
shines is we go ahead and create a

00:29:38,399 --> 00:29:42,559
histogram on

00:29:39,679 --> 00:29:42,960
our table with three buckets now when we

00:29:42,559 --> 00:29:44,960
run

00:29:42,960 --> 00:29:46,559
the explain on there it knows where all

00:29:44,960 --> 00:29:48,320
the data is it

00:29:46,559 --> 00:29:49,520
it says yeah i i know where i'm gonna

00:29:48,320 --> 00:29:51,840
have to go i'm gonna have to get all the

00:29:49,520 --> 00:29:51,840
data

00:29:52,720 --> 00:29:56,640
now if you run explain analyze uh we'll

00:29:54,640 --> 00:29:59,279
come back and give you the actual

00:29:56,640 --> 00:30:01,360
costs and the time that it takes to run

00:29:59,279 --> 00:30:04,480
everything

00:30:01,360 --> 00:30:05,919
now i'm kind of running uh down in my

00:30:04,480 --> 00:30:06,720
last five minutes before i go to

00:30:05,919 --> 00:30:09,279
dedicated q

00:30:06,720 --> 00:30:10,399
a by the way if you do have questions

00:30:09,279 --> 00:30:12,720
please pop them in the q

00:30:10,399 --> 00:30:14,559
a there are other tweaks you can do to

00:30:12,720 --> 00:30:15,760
speed things up

00:30:14,559 --> 00:30:17,679
you can use explain to see what your

00:30:15,760 --> 00:30:18,480
query is doing are there file sorts full

00:30:17,679 --> 00:30:21,039
table scans

00:30:18,480 --> 00:30:22,240
temporary tables do the join orders look

00:30:21,039 --> 00:30:24,480
right uh

00:30:22,240 --> 00:30:26,240
the the configuration side or the

00:30:24,480 --> 00:30:27,520
buffers and cache is big enough do you

00:30:26,240 --> 00:30:31,440
have enough memory

00:30:27,520 --> 00:30:34,000
uh are your are your disks just slow

00:30:31,440 --> 00:30:34,880
uh that still happens these days uh

00:30:34,000 --> 00:30:37,520
something you do

00:30:34,880 --> 00:30:40,880
is we've made two changes to locking in

00:30:37,520 --> 00:30:42,480
mysql80 uh no way and skipped lock

00:30:40,880 --> 00:30:44,399
this might help you re-change the way

00:30:42,480 --> 00:30:46,000
you use your data

00:30:44,399 --> 00:30:47,760
for example here we want to buy some

00:30:46,000 --> 00:30:49,840
concert tickets and

00:30:47,760 --> 00:30:52,159
we're going to start a transaction and

00:30:49,840 --> 00:30:53,760
we're going to go out and select a seat

00:30:52,159 --> 00:30:55,520
and a row and we're going to grab the

00:30:53,760 --> 00:30:57,039
cost while we're at it from a table

00:30:55,520 --> 00:30:58,799
called seats

00:30:57,039 --> 00:31:00,640
and what we want to do is we're looking

00:30:58,799 --> 00:31:04,799
for seat numbers 3 and 4

00:31:00,640 --> 00:31:06,640
in rows 5 and 6 that are not booked

00:31:04,799 --> 00:31:08,000
now we want to grab them because we want

00:31:06,640 --> 00:31:10,159
to book them

00:31:08,000 --> 00:31:11,919
and this will automatically skip over

00:31:10,159 --> 00:31:14,640
the lock tables before this

00:31:11,919 --> 00:31:17,679
the database would wait until those rows

00:31:14,640 --> 00:31:17,679
became available

00:31:17,760 --> 00:31:21,600
lock no weight basically says if there's

00:31:20,559 --> 00:31:24,720
nothing there

00:31:21,600 --> 00:31:24,720
immediately returned to me

00:31:25,200 --> 00:31:28,399
now other ways you can do oops got a

00:31:27,200 --> 00:31:32,240
question

00:31:28,399 --> 00:31:33,600
let's see uh

00:31:32,240 --> 00:31:34,559
is there a link to the 90 minute full

00:31:33,600 --> 00:31:35,840
version of the talks that you have

00:31:34,559 --> 00:31:37,440
mentioned in the beginning

00:31:35,840 --> 00:31:39,519
uh yes i'll have to look it up though

00:31:37,440 --> 00:31:41,039
and i will post it on my twitter at

00:31:39,519 --> 00:31:47,840
stoker

00:31:41,039 --> 00:31:47,840
um let me type that

00:31:53,919 --> 00:31:59,519
okay so get that out there

00:31:57,440 --> 00:32:02,159
okay other fast ways resource groups

00:31:59,519 --> 00:32:04,960
optimize your hands partitioning

00:32:02,159 --> 00:32:05,840
and resource groups this is where you

00:32:04,960 --> 00:32:09,200
can dedicate

00:32:05,840 --> 00:32:10,240
virtual cpus to certain classes of

00:32:09,200 --> 00:32:13,279
queries

00:32:10,240 --> 00:32:16,000
in this example we create a batch

00:32:13,279 --> 00:32:17,840
group and we dedicate two cpus and set

00:32:16,000 --> 00:32:20,080
it to a low thread priority

00:32:17,840 --> 00:32:20,960
so every time we set a resource group

00:32:20,080 --> 00:32:24,320
batch in

00:32:20,960 --> 00:32:25,919
a in a series of commands or we put in

00:32:24,320 --> 00:32:26,799
this optimizer hint the stuff here in

00:32:25,919 --> 00:32:29,840
magenta

00:32:26,799 --> 00:32:30,320
the optimizer knows to set those to go

00:32:29,840 --> 00:32:34,080
to that

00:32:30,320 --> 00:32:36,799
that lower priority optimizer hints

00:32:34,080 --> 00:32:37,760
these are little comments you can put

00:32:36,799 --> 00:32:39,919
into your

00:32:37,760 --> 00:32:43,600
your query so like you know it's better

00:32:39,919 --> 00:32:45,840
to join t1 to t2 than t2 to t1

00:32:43,600 --> 00:32:46,799
the optimizer will see this hopefully

00:32:45,840 --> 00:32:48,720
you'll know that you're

00:32:46,799 --> 00:32:50,960
you know what you're doing and away you

00:32:48,720 --> 00:32:50,960
go

00:32:51,120 --> 00:32:54,399
partitioning you can actually divvy up

00:32:52,720 --> 00:32:55,600
your data over various partitions if

00:32:54,399 --> 00:32:58,559
you're running into nrgb

00:32:55,600 --> 00:33:00,240
or our ndb storage engines so if you

00:32:58,559 --> 00:33:00,799
want to keep the data for the last

00:33:00,240 --> 00:33:04,159
quarter

00:33:00,799 --> 00:33:05,679
on partition a stuff for the previous

00:33:04,159 --> 00:33:07,279
three quarters on another partition and

00:33:05,679 --> 00:33:08,320
stuff for years passed on yet another

00:33:07,279 --> 00:33:10,480
set of disks

00:33:08,320 --> 00:33:12,159
you can do that the optimizer knows

00:33:10,480 --> 00:33:14,799
about that and knows how to go grab it

00:33:12,159 --> 00:33:17,039
off the various partitions

00:33:14,799 --> 00:33:18,880
okay um this is an interesting example

00:33:17,039 --> 00:33:20,559
of what the optimizer actually does

00:33:18,880 --> 00:33:22,960
uh this is our query we're going to go

00:33:20,559 --> 00:33:26,159
out and we're going to select city.name

00:33:22,960 --> 00:33:27,440
from the city table country.name from

00:33:26,159 --> 00:33:28,880
the country table

00:33:27,440 --> 00:33:30,480
now these two tables have been set up so

00:33:28,880 --> 00:33:33,519
that city.country code

00:33:30,480 --> 00:33:34,799
is the hook into the country table using

00:33:33,519 --> 00:33:37,840
the code column

00:33:34,799 --> 00:33:38,559
and we only want to know the city names

00:33:37,840 --> 00:33:42,320
for

00:33:38,559 --> 00:33:44,000
gbr where the country code is equal gbr

00:33:42,320 --> 00:33:45,360
so once again we're looking for city

00:33:44,000 --> 00:33:47,760
name country name

00:33:45,360 --> 00:33:49,120
from these two tables that's how we're

00:33:47,760 --> 00:33:52,320
matching them up

00:33:49,120 --> 00:33:53,919
and this is a qualifier

00:33:52,320 --> 00:33:55,840
so if we run explain on this it comes

00:33:53,919 --> 00:33:58,159
back and tells us yes you're

00:33:55,840 --> 00:33:59,600
you're doing this on two tables country

00:33:58,159 --> 00:34:01,440
and city

00:33:59,600 --> 00:34:02,799
uh notice that country is a smaller

00:34:01,440 --> 00:34:04,880
table so it's going to have to look at

00:34:02,799 --> 00:34:08,240
that first

00:34:04,880 --> 00:34:12,560
now the actual query plan that we get is

00:34:08,240 --> 00:34:14,079
select world.city dot name as name

00:34:12,560 --> 00:34:15,679
world by the way is a scheme or database

00:34:14,079 --> 00:34:17,919
we have all this and

00:34:15,679 --> 00:34:18,960
united kingdom as name so that

00:34:17,919 --> 00:34:23,040
country.name

00:34:18,960 --> 00:34:23,040
it's automatically rewritten that for us

00:34:23,679 --> 00:34:27,119
so it's already done some magic for us

00:34:25,760 --> 00:34:29,760
even on a very simple query

00:34:27,119 --> 00:34:29,760
such as this

00:34:32,879 --> 00:34:35,679
if you're explaining analyze it will go

00:34:34,399 --> 00:34:36,159
out and give us the real cost of how

00:34:35,679 --> 00:34:39,359
everything

00:34:36,159 --> 00:34:42,480
runs now

00:34:39,359 --> 00:34:45,919
oops there was my timer um

00:34:42,480 --> 00:34:49,040
let me uh run through this one slide uh

00:34:45,919 --> 00:34:50,320
learning to read this is kind of hard i

00:34:49,040 --> 00:34:52,399
have some books

00:34:50,320 --> 00:34:53,919
that i will get to that i recommend that

00:34:52,399 --> 00:34:56,960
you're going to have to

00:34:53,919 --> 00:34:58,560
these are exercises i run through

00:34:56,960 --> 00:35:00,839
by the way where else look for

00:34:58,560 --> 00:35:03,680
information the mysql manual

00:35:00,839 --> 00:35:05,520
forms.mysql.com also we have a mysql

00:35:03,680 --> 00:35:06,800
community slack please join you're part

00:35:05,520 --> 00:35:07,760
of the community now that you've sat

00:35:06,800 --> 00:35:10,079
through this

00:35:07,760 --> 00:35:10,960
great book you need this book uh jesper

00:35:10,079 --> 00:35:12,880
whispered crow

00:35:10,960 --> 00:35:14,480
i used to work at our support group uh

00:35:12,880 --> 00:35:16,880
the book's about five inches

00:35:14,480 --> 00:35:18,000
thick i'm on my second re-reading of it

00:35:16,880 --> 00:35:20,160
i'm still learning stuff

00:35:18,000 --> 00:35:21,599
very interesting uh this is an older

00:35:20,160 --> 00:35:23,680
book if you're running older versions of

00:35:21,599 --> 00:35:25,119
mysql it's getting dated along the tooth

00:35:23,680 --> 00:35:27,359
a lot of things have changed

00:35:25,119 --> 00:35:30,000
uh this is my book if you're using json

00:35:27,359 --> 00:35:31,839
and mysql

00:35:30,000 --> 00:35:33,440
the way if you are a startup oracle can

00:35:31,839 --> 00:35:34,800
help you they have this wonderful

00:35:33,440 --> 00:35:36,720
program where they give you lots of

00:35:34,800 --> 00:35:38,160
credits and lots of help

00:35:36,720 --> 00:35:40,240
if you are a startup please take a look

00:35:38,160 --> 00:35:43,359
at that and with that

00:35:40,240 --> 00:35:45,119
there's my contact information

00:35:43,359 --> 00:35:46,640
and once again the slides are there and

00:35:45,119 --> 00:35:48,640
i will get the

00:35:46,640 --> 00:35:50,000
the longer link out there for the q and

00:35:48,640 --> 00:35:51,920
a

00:35:50,000 --> 00:35:54,720
and with that i've got the q a window if

00:35:51,920 --> 00:35:56,000
there's any questions

00:35:54,720 --> 00:35:57,599
i can say more about the benefits of

00:35:56,000 --> 00:35:59,040
histogram versus index when your data

00:35:57,599 --> 00:36:03,599
doesn't churn i don't follow

00:35:59,040 --> 00:36:05,839
logic okay indexes are designed

00:36:03,599 --> 00:36:07,680
i used to be able to use the uh the

00:36:05,839 --> 00:36:08,960
library reference card system but very

00:36:07,680 --> 00:36:11,680
few libraries actually have those

00:36:08,960 --> 00:36:14,720
anymore where they actually have cards

00:36:11,680 --> 00:36:19,040
histograms you kind of uh divvy up your

00:36:14,720 --> 00:36:20,960
your data in buckets so that you know

00:36:19,040 --> 00:36:22,560
you know the a's are over here b's are

00:36:20,960 --> 00:36:24,560
over there and all that

00:36:22,560 --> 00:36:26,079
index is as soon as you insert a piece

00:36:24,560 --> 00:36:30,079
of data there's a new index

00:36:26,079 --> 00:36:32,480
entry in there what i mean by don't

00:36:30,079 --> 00:36:33,760
churn is indexes are better when you're

00:36:32,480 --> 00:36:36,320
you're adding or

00:36:33,760 --> 00:36:37,760
changing a lot of data histograms you

00:36:36,320 --> 00:36:40,079
make the histogram once you

00:36:37,760 --> 00:36:41,440
you throw them in the bucket a and it

00:36:40,079 --> 00:36:41,839
doesn't know that if he changed the last

00:36:41,440 --> 00:36:44,480
name

00:36:41,839 --> 00:36:45,839
from adams to jorgensen that the name

00:36:44,480 --> 00:36:48,560
has changed he'd have to rerun the

00:36:45,839 --> 00:36:52,880
histogram on that

00:36:48,560 --> 00:36:52,880
uh i missed the in the output um

00:36:53,119 --> 00:36:57,440
since i answered that okay uh now the

00:36:56,000 --> 00:36:58,320
second question i have i missed in the

00:36:57,440 --> 00:37:00,720
output explanation

00:36:58,320 --> 00:37:02,640
what is the cost well cost based

00:37:00,720 --> 00:37:04,079
optimizers have been around for 40 some

00:37:02,640 --> 00:37:06,960
odd years and the idea is

00:37:04,079 --> 00:37:08,960
that you want to get the data back from

00:37:06,960 --> 00:37:10,960
your query at the lowest cost cost being

00:37:08,960 --> 00:37:12,079
disk reads because disk reads are very

00:37:10,960 --> 00:37:13,760
very slow

00:37:12,079 --> 00:37:15,280
uh disk reads are a hundred thousand

00:37:13,760 --> 00:37:15,839
times slower than reading out of memory

00:37:15,280 --> 00:37:19,680
so you

00:37:15,839 --> 00:37:22,720
kind of go for the um

00:37:19,680 --> 00:37:25,520
the the worst case

00:37:22,720 --> 00:37:25,520
scenario there

00:37:25,839 --> 00:37:30,640
let's see thank you carl and catherine

00:37:29,119 --> 00:37:33,359
um if there's any other questions i'll

00:37:30,640 --> 00:37:36,240
be here for a while

00:37:33,359 --> 00:37:36,800
and if you have any questions please do

00:37:36,240 --> 00:37:40,800
not

00:37:36,800 --> 00:37:43,160
hesitate to ping me david.stokes oracle

00:37:40,800 --> 00:37:44,640
i have a blog at

00:37:43,160 --> 00:37:46,320
elephantdolphin.blogspot.com i'm at

00:37:44,640 --> 00:37:48,160
stoker on twitter

00:37:46,320 --> 00:37:50,320
once again please join the mysql

00:37:48,160 --> 00:37:50,720
community slack a lot of our engineers

00:37:50,320 --> 00:37:52,640
hang

00:37:50,720 --> 00:37:54,560
out there so if you have a question

00:37:52,640 --> 00:37:58,079
about the optimizer the new shell

00:37:54,560 --> 00:38:01,280
replication anything like that

00:37:58,079 --> 00:38:03,760
you're more than more than

00:38:01,280 --> 00:38:06,240
welcome to join us and back to nixie

00:38:03,760 --> 00:38:06,240
advance

00:38:06,960 --> 00:38:10,400

YouTube URL: https://www.youtube.com/watch?v=CQcdxOqz1n8


