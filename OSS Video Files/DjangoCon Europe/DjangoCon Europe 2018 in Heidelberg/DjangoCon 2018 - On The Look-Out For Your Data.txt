Title: DjangoCon 2018 - On The Look-Out For Your Data
Publication date: 2018-05-24
Playlist: DjangoCon Europe 2018 in Heidelberg
Description: 
	https://media.ccc.de/v/hd-42-on-the-look-out-for-your-data



Do you have data in the database of your Django project? Do you want to find that the needle in the haystack of your data? There are plenty options how you can achieve that. With various levels of complexity, confidence, and reliability. I'll give an insight into what the most common are nowadays.

You're tasked with building a search for the project you're working on. But where do you start? What search implementation are you going to use? There's a sheer unlimited set of ways to implement "I'm looking for X in Y" out there. Elasticsearch, LIKE and ILIKE queries, MySQL's Fulltext Search, PostgreSQL's Fulltext Search, Solr, Whoosh, Xapian, to only name a few. I'll be looking at the most common ones and will be showing some basic implementation techniques.

You should be familiar with Django in so much as that I'm not talking about how to create or update an object in a database. You should also have an idea of what database transactions are. The talk will feature some code snippets that I will provide in full, afterward.

Markus Holtermann
Captions: 
	00:00:07,010 --> 00:00:11,599
okay please welcome Marcus Alderman

00:00:16,730 --> 00:00:22,020
thanks everybody for coming and today I

00:00:20,130 --> 00:00:24,720
want to talk about the data we have in

00:00:22,020 --> 00:00:28,140
our databases this pile of information

00:00:24,720 --> 00:00:32,580
that we have that we want to see and

00:00:28,140 --> 00:00:36,239
want to find something inside and I want

00:00:32,580 --> 00:00:38,010
to give you an idea of how we can do

00:00:36,239 --> 00:00:41,579
that this in general and what we should

00:00:38,010 --> 00:00:42,690
look out for when doing that a short

00:00:41,579 --> 00:00:45,120
introduction to myself

00:00:42,690 --> 00:00:47,430
um about myself I'm Marcus Waterman I'm

00:00:45,120 --> 00:00:50,129
a general contributor I'm a software

00:00:47,430 --> 00:00:52,789
engineer later pay and I happen to be

00:00:50,129 --> 00:00:57,300
one of this year's django con europe and

00:00:52,789 --> 00:01:02,070
organizers let me start off with asking

00:00:57,300 --> 00:01:04,830
this question what is search and let me

00:01:02,070 --> 00:01:10,110
start off with asking how to search in

00:01:04,830 --> 00:01:14,190
Django well let's start answering the

00:01:10,110 --> 00:01:16,020
first question and when we look at the

00:01:14,190 --> 00:01:20,250
Oxford English Dictionary and use

00:01:16,020 --> 00:01:22,319
non-technical terms to define search we

00:01:20,250 --> 00:01:26,190
find an explanation for the word for the

00:01:22,319 --> 00:01:28,380
verb to search which goes like try to

00:01:26,190 --> 00:01:32,880
find something by looking and otherwise

00:01:28,380 --> 00:01:37,649
seeking carefully and thoroughly ok so

00:01:32,880 --> 00:01:40,470
what does this actually mean let's take

00:01:37,649 --> 00:01:43,709
this apart we try to find something by

00:01:40,470 --> 00:01:45,920
looking so does this mean that if we

00:01:43,709 --> 00:01:49,429
fail at looking something for something

00:01:45,920 --> 00:01:52,110
we're not searching does it mean that

00:01:49,429 --> 00:01:54,090
when we try but can't find something

00:01:52,110 --> 00:01:57,360
this is fine and we shouldn't worry

00:01:54,090 --> 00:02:00,479
about that there are these two words

00:01:57,360 --> 00:02:02,429
carefully and thoroughly in there does

00:02:00,479 --> 00:02:04,319
that mean when we don't look carefully

00:02:02,429 --> 00:02:06,560
and thoroughly we are not searching are

00:02:04,319 --> 00:02:11,610
we not searching correctly to be such

00:02:06,560 --> 00:02:15,349
wrote the wrong way and well this is one

00:02:11,610 --> 00:02:19,340
of what I want to like look into when we

00:02:15,349 --> 00:02:22,379
think about how we search in Django and

00:02:19,340 --> 00:02:25,650
looking at this definition though I see

00:02:22,379 --> 00:02:28,099
that and can understand that search is

00:02:25,650 --> 00:02:28,099
hard

00:02:29,879 --> 00:02:36,340
and we actually all know this you have

00:02:34,959 --> 00:02:38,739
this situation where you want to leave

00:02:36,340 --> 00:02:40,629
here apartment your house want to go

00:02:38,739 --> 00:02:42,640
something so you grab your coat your

00:02:40,629 --> 00:02:42,849
shoes you grab your where are my car

00:02:42,640 --> 00:02:45,280
keys

00:02:42,849 --> 00:02:48,069
where's my wallet so you look for

00:02:45,280 --> 00:02:50,500
minutes well probably not hours but you

00:02:48,069 --> 00:02:52,360
look around until you eventually find

00:02:50,500 --> 00:02:53,739
them probably at a place where they

00:02:52,360 --> 00:02:57,160
belong in the bowl and if in the

00:02:53,739 --> 00:02:58,599
corridor and on the cupboard but why

00:02:57,160 --> 00:03:01,060
didn't we look there right away

00:02:58,599 --> 00:03:04,900
and should be should we have looked

00:03:01,060 --> 00:03:06,340
there right away and when you look at

00:03:04,900 --> 00:03:09,790
this from a more computer science

00:03:06,340 --> 00:03:12,910
perspective then let me ask the question

00:03:09,790 --> 00:03:16,930
for you to pick a number between one and

00:03:12,910 --> 00:03:20,260
zero that I've thought of like you can

00:03:16,930 --> 00:03:23,530
go with is it number one I said no isn't

00:03:20,260 --> 00:03:26,019
number two no number three still no and

00:03:23,530 --> 00:03:28,360
you can go on and on and you will

00:03:26,019 --> 00:03:31,239
eventually come up with the number I

00:03:28,360 --> 00:03:33,489
picked great it's not really efficient

00:03:31,239 --> 00:03:36,819
though like imagine five billion numbers

00:03:33,489 --> 00:03:39,790
you're gonna ask all day long so you go

00:03:36,819 --> 00:03:40,450
with let's make it random it's number 85

00:03:39,790 --> 00:03:46,239
nope

00:03:40,450 --> 00:03:49,359
17 nope 48 nope and well if you keep

00:03:46,239 --> 00:03:53,019
track of the numbers you ask you may hit

00:03:49,359 --> 00:03:55,690
the number I thought of earlier but you

00:03:53,019 --> 00:03:57,880
may not so there needs to be an

00:03:55,690 --> 00:04:00,519
improvement to that and in computer

00:03:57,880 --> 00:04:03,370
science in when you have a search sorted

00:04:00,519 --> 00:04:05,889
in set of information you can use

00:04:03,370 --> 00:04:09,069
something called binary search which is

00:04:05,889 --> 00:04:09,430
in this case is it number 50 no it's

00:04:09,069 --> 00:04:12,340
smaller

00:04:09,430 --> 00:04:13,690
is it number 25 no it's the smaller this

00:04:12,340 --> 00:04:16,479
is number 12 yes

00:04:13,690 --> 00:04:18,940
so with only three questions you never

00:04:16,479 --> 00:04:21,570
have done this number out of a hundred

00:04:18,940 --> 00:04:24,760
which is pretty great

00:04:21,570 --> 00:04:27,550
now let's try to apply this to Jenga and

00:04:24,760 --> 00:04:33,220
let's see where we find this in Django

00:04:27,550 --> 00:04:34,210
or when using Django and who have you

00:04:33,220 --> 00:04:36,520
think they are

00:04:34,210 --> 00:04:39,630
think they have built or used search

00:04:36,520 --> 00:04:42,910
engine go can I get a show of hands

00:04:39,630 --> 00:04:48,700
okay that's about half the room maybe a

00:04:42,910 --> 00:04:51,700
bit more that's good but I think all of

00:04:48,700 --> 00:04:56,740
you who have used Django or DRM have

00:04:51,700 --> 00:05:00,700
actually used such let's look at this

00:04:56,740 --> 00:05:02,560
code example we have a view that gets a

00:05:00,700 --> 00:05:05,650
request in the primer is the primary key

00:05:02,560 --> 00:05:07,510
we use get object or 404 to fetch the

00:05:05,650 --> 00:05:12,060
particular article from the database and

00:05:07,510 --> 00:05:15,850
then we return a response to the user

00:05:12,060 --> 00:05:19,240
well this is search it's a particular

00:05:15,850 --> 00:05:21,550
point part of search but a user asks for

00:05:19,240 --> 00:05:23,260
something to fight to and ask us for an

00:05:21,550 --> 00:05:26,800
article with a particular primary key

00:05:23,260 --> 00:05:29,740
and we try to find this article if we

00:05:26,800 --> 00:05:31,690
don't we return a 404 we don't give a

00:05:29,740 --> 00:05:34,570
server error so we are careful about

00:05:31,690 --> 00:05:36,730
this so looking at thinking about the

00:05:34,570 --> 00:05:39,420
definition trying to find something by

00:05:36,730 --> 00:05:42,760
carefully and thoroughly looking for it

00:05:39,420 --> 00:05:46,120
this is search it's a particular search

00:05:42,760 --> 00:05:48,880
some equality search in the database we

00:05:46,120 --> 00:05:51,190
use but it's this search if you can make

00:05:48,880 --> 00:05:53,560
this more complex or in court as complex

00:05:51,190 --> 00:05:56,050
as we want we can add only published

00:05:53,560 --> 00:05:58,330
articles that have been written in this

00:05:56,050 --> 00:06:00,490
particular time period it's still

00:05:58,330 --> 00:06:05,710
searched we still try to find something

00:06:00,490 --> 00:06:09,370
given some constraints so this is fine

00:06:05,710 --> 00:06:12,400
this is this works but how about

00:06:09,370 --> 00:06:14,290
searching text because this is something

00:06:12,400 --> 00:06:18,550
where we well we currently look up

00:06:14,290 --> 00:06:20,950
something by a primary key and well

00:06:18,550 --> 00:06:23,220
searching text is a bit more complicated

00:06:20,950 --> 00:06:25,930
because the difference between text and

00:06:23,220 --> 00:06:29,250
like columns in a database or primary

00:06:25,930 --> 00:06:32,860
key it's it's kind of unstructured data

00:06:29,250 --> 00:06:35,380
think about search engines like being

00:06:32,860 --> 00:06:38,740
dr. Google all those others that are out

00:06:35,380 --> 00:06:40,180
there what information do they have like

00:06:38,740 --> 00:06:43,060
literally what information do they have

00:06:40,180 --> 00:06:45,820
it's the URL of a website they saw it's

00:06:43,060 --> 00:06:47,700
the time they last visited it it's the

00:06:45,820 --> 00:06:50,650
bare HTML they were able to download

00:06:47,700 --> 00:06:52,600
it's maybe the title tag they passed out

00:06:50,650 --> 00:06:53,020
of that and then this all the other

00:06:52,600 --> 00:06:55,060
fancy

00:06:53,020 --> 00:06:57,250
stuff that comes on top of like trying

00:06:55,060 --> 00:07:01,539
to figure out the meaning of what the

00:06:57,250 --> 00:07:03,430
text actually says but searching text

00:07:01,539 --> 00:07:06,580
essentially means we have this pile of

00:07:03,430 --> 00:07:12,610
unstructured data that we want to find

00:07:06,580 --> 00:07:14,440
something in and thinking about the the

00:07:12,610 --> 00:07:16,870
quote of the definition of trying again

00:07:14,440 --> 00:07:18,280
trying to find something by looking and

00:07:16,870 --> 00:07:21,220
otherwise seeking carefully and

00:07:18,280 --> 00:07:22,240
thoroughly this means in the context of

00:07:21,220 --> 00:07:25,389
searching text

00:07:22,240 --> 00:07:28,300
we should probably well return all the

00:07:25,389 --> 00:07:32,830
things that kind of match or such search

00:07:28,300 --> 00:07:37,419
terms so we go ahead modify the view we

00:07:32,830 --> 00:07:39,370
had and we do this instead of using get

00:07:37,419 --> 00:07:43,150
object or four or four we use get list

00:07:39,370 --> 00:07:46,690
or 404 which returns a 404 if we don't

00:07:43,150 --> 00:07:48,849
have at least one object and instead of

00:07:46,690 --> 00:07:51,400
looking something up by primary key we

00:07:48,849 --> 00:07:54,639
look it up but we're using by contains

00:07:51,400 --> 00:07:57,460
on the text of an article and looking up

00:07:54,639 --> 00:08:04,690
the search query from the from the get

00:07:57,460 --> 00:08:07,180
hand request so we are both careful here

00:08:04,690 --> 00:08:09,219
because we still return a 4 or 4 of this

00:08:07,180 --> 00:08:11,520
articles of that we don't find an

00:08:09,219 --> 00:08:14,620
article we don't return the server error

00:08:11,520 --> 00:08:17,289
we still try because we use I contains

00:08:14,620 --> 00:08:20,259
we just we don't use contains so we make

00:08:17,289 --> 00:08:22,469
sure we don't care about upper case

00:08:20,259 --> 00:08:25,360
lower case mixed case words and so on

00:08:22,469 --> 00:08:28,659
but when we look at the database

00:08:25,360 --> 00:08:32,979
perspective of that we get pretty much

00:08:28,659 --> 00:08:37,390
this sequel and this is not particularly

00:08:32,979 --> 00:08:39,370
efficient unfortunately so if you want

00:08:37,390 --> 00:08:41,649
Postgres per squares can't you

00:08:39,370 --> 00:08:44,740
physically can't build an easily build

00:08:41,649 --> 00:08:47,520
an index on this to index to make such

00:08:44,740 --> 00:08:47,520
crews efficient

00:08:48,959 --> 00:08:58,180
my secret has this full-text search flag

00:08:53,500 --> 00:09:01,899
in next thingy I'm not really sure if

00:08:58,180 --> 00:09:05,110
this is actually what we want so let's

00:09:01,899 --> 00:09:07,329
stick the Postgres here um you can

00:09:05,110 --> 00:09:10,000
however make this more efficient in

00:09:07,329 --> 00:09:16,600
Postgres and there's a post class

00:09:10,000 --> 00:09:19,690
extension called trigrams and trigrams

00:09:16,600 --> 00:09:23,139
are character combination or in a

00:09:19,690 --> 00:09:27,699
trigram is when you have a piece of text

00:09:23,139 --> 00:09:29,560
or string and you chunk it off in parts

00:09:27,699 --> 00:09:33,850
of three characters with certain

00:09:29,560 --> 00:09:37,389
constraints and using the post quest

00:09:33,850 --> 00:09:39,160
trigram extension you can chunk up your

00:09:37,389 --> 00:09:41,860
entire text into trigrams and then use

00:09:39,160 --> 00:09:44,889
that for search but to give you an idea

00:09:41,860 --> 00:09:47,259
of what trigrams look like if you use

00:09:44,889 --> 00:09:50,139
the shell trigram methods and Postgres

00:09:47,259 --> 00:09:55,329
and sequel then in the term I love

00:09:50,139 --> 00:09:59,980
Django you end up with this so this is

00:09:55,329 --> 00:10:02,920
indexable in Postgres and it's indexable

00:09:59,980 --> 00:10:06,449
by with an operator class that the

00:10:02,920 --> 00:10:09,550
Postgres trigram extension provides now

00:10:06,449 --> 00:10:15,519
Django has class-based indexes for a few

00:10:09,550 --> 00:10:20,139
versions now and with a bit of internal

00:10:15,519 --> 00:10:22,449
stuff that's not documented what still

00:10:20,139 --> 00:10:24,779
fits on one slide you can create in

00:10:22,449 --> 00:10:27,250
class based index that creates an

00:10:24,779 --> 00:10:30,310
effectively creates index that's usable

00:10:27,250 --> 00:10:34,029
in an eye contains curry and can be used

00:10:30,310 --> 00:10:37,389
with an eye contains curry so the key

00:10:34,029 --> 00:10:41,410
here is the gist trigram ops operator up

00:10:37,389 --> 00:10:43,930
here and that we use upper here because

00:10:41,410 --> 00:10:45,699
Django's eye contains turns to search

00:10:43,930 --> 00:10:50,529
them into uppercase letters as well and

00:10:45,699 --> 00:10:52,660
this works like this stuff underneath is

00:10:50,529 --> 00:10:55,540
somewhat Django internal not documented

00:10:52,660 --> 00:10:58,750
but well so be it because we should all

00:10:55,540 --> 00:11:00,880
look into how Django is built out Django

00:10:58,750 --> 00:11:02,820
dust things and then leverage the things

00:11:00,880 --> 00:11:06,760
we need

00:11:02,820 --> 00:11:07,870
and we can add this to a we can create a

00:11:06,760 --> 00:11:10,000
an index

00:11:07,870 --> 00:11:11,710
we can add this to an index definition

00:11:10,000 --> 00:11:16,440
on the model and Jenny will just happily

00:11:11,710 --> 00:11:20,320
create a migration for that now

00:11:16,440 --> 00:11:23,560
searching text so we've found an

00:11:20,320 --> 00:11:25,600
efficient way to search through the pile

00:11:23,560 --> 00:11:27,550
of information to all the news articles

00:11:25,600 --> 00:11:29,350
all the blog articles we write and

00:11:27,550 --> 00:11:33,700
provide users with an interface to do

00:11:29,350 --> 00:11:36,070
actually find something great now they

00:11:33,700 --> 00:11:38,830
come ahead and like actually use the

00:11:36,070 --> 00:11:40,630
search and unfortunately they don't

00:11:38,830 --> 00:11:43,140
really find the things they're looking

00:11:40,630 --> 00:11:46,810
for because what you're doing here is

00:11:43,140 --> 00:11:49,330
while searching text not really that

00:11:46,810 --> 00:11:52,540
what we look or what we understand when

00:11:49,330 --> 00:11:54,400
we talk about searching text when you

00:11:52,540 --> 00:11:56,110
talk about searching text what we

00:11:54,400 --> 00:12:01,330
actually might mean is something called

00:11:56,110 --> 00:12:04,420
full text search and full text search

00:12:01,330 --> 00:12:06,960
has a few constraints or few things it

00:12:04,420 --> 00:12:10,180
does compared to what we've done so far

00:12:06,960 --> 00:12:12,070
one of that is that we don't really care

00:12:10,180 --> 00:12:14,500
about the word order in your search

00:12:12,070 --> 00:12:16,480
terms it doesn't really matter if you

00:12:14,500 --> 00:12:18,880
look for Django migrations or migrations

00:12:16,480 --> 00:12:21,220
Django there is also be the same

00:12:18,880 --> 00:12:23,470
there's no prioritizing words that come

00:12:21,220 --> 00:12:27,490
first or what's the less prioritizing

00:12:23,470 --> 00:12:30,430
words that come last there's something

00:12:27,490 --> 00:12:34,990
in in language that's called stemming

00:12:30,430 --> 00:12:38,020
and effectively words has a half a base

00:12:34,990 --> 00:12:39,970
or stem that they originate from so you

00:12:38,020 --> 00:12:42,250
have a computer you have the verb to

00:12:39,970 --> 00:12:46,150
compute you have commutation and the

00:12:42,250 --> 00:12:47,680
stem is compute so it doesn't really

00:12:46,150 --> 00:12:50,200
matter if there's a computer doing

00:12:47,680 --> 00:12:52,510
something and if there's somebody

00:12:50,200 --> 00:12:54,910
computing something or if there's a

00:12:52,510 --> 00:12:56,500
computation happening like it's the

00:12:54,910 --> 00:12:59,290
meaning that there's something being

00:12:56,500 --> 00:13:02,440
computed and like evolved that's what

00:12:59,290 --> 00:13:07,470
somebody is looking for and this is what

00:13:02,440 --> 00:13:07,470
we look for when we search

00:13:07,589 --> 00:13:16,600
and there's also something called stop

00:13:11,980 --> 00:13:19,899
words jingle is the best provides this

00:13:16,600 --> 00:13:24,430
very same meaning as Django best is

00:13:19,899 --> 00:13:26,589
enter and on by for these are words that

00:13:24,430 --> 00:13:30,040
don't really provide that much meaning

00:13:26,589 --> 00:13:31,899
to in a text well they provide context

00:13:30,040 --> 00:13:34,899
in a in a sentence but they don't

00:13:31,899 --> 00:13:35,649
provide context and information in a

00:13:34,899 --> 00:13:40,029
search query

00:13:35,649 --> 00:13:42,339
I sell great we have all these features

00:13:40,029 --> 00:13:45,100
and we want to do this how the heck are

00:13:42,339 --> 00:13:47,769
we going to do this if you have Postgres

00:13:45,100 --> 00:13:51,760
you can use the double on Oscar search

00:13:47,769 --> 00:13:54,160
lookup and the documentation of this on

00:13:51,760 --> 00:13:55,839
this topic is pretty great so I'm not

00:13:54,160 --> 00:14:00,610
going to go into details here this is a

00:13:55,839 --> 00:14:03,550
link for that on django 2.0 instead I

00:14:00,610 --> 00:14:07,540
want to go into a bit more advanced part

00:14:03,550 --> 00:14:11,350
of of where search can go and for now

00:14:07,540 --> 00:14:13,540
we've we've used our database as the

00:14:11,350 --> 00:14:18,519
data as as the search engine effectively

00:14:13,540 --> 00:14:21,100
but what happens when even Postgres

00:14:18,519 --> 00:14:22,930
build in such doesn't really give us the

00:14:21,100 --> 00:14:26,290
information and doesn't really do all

00:14:22,930 --> 00:14:30,730
these fancy things we want to do well we

00:14:26,290 --> 00:14:32,649
go and use external tools and this is

00:14:30,730 --> 00:14:34,269
great they do their job properly and

00:14:32,649 --> 00:14:36,810
they are built for doing full-text

00:14:34,269 --> 00:14:39,790
search and other kinds of searches and

00:14:36,810 --> 00:14:41,680
only to name a few exceptions solar

00:14:39,790 --> 00:14:47,170
Lucie in Russia elastic search there's

00:14:41,680 --> 00:14:51,459
heaps more out there they are great they

00:14:47,170 --> 00:14:55,089
do the job properly and they all have

00:14:51,459 --> 00:14:58,959
their benefits and in the problems and

00:14:55,089 --> 00:15:00,550
they have the quirks and you it takes a

00:14:58,959 --> 00:15:03,699
bit to get used to them and understand

00:15:00,550 --> 00:15:08,230
them but once you get ahold of that and

00:15:03,699 --> 00:15:10,180
hang of them great so know you have a

00:15:08,230 --> 00:15:12,069
different problem though it's not that

00:15:10,180 --> 00:15:13,569
the search engine you use doesn't really

00:15:12,069 --> 00:15:16,089
provide it doesn't develop diverse

00:15:13,569 --> 00:15:17,880
search results that you want the problem

00:15:16,089 --> 00:15:21,840
that you have is that

00:15:17,880 --> 00:15:23,340
it's different all that you first need

00:15:21,840 --> 00:15:25,950
to get information into the search

00:15:23,340 --> 00:15:28,650
engine into their data store but because

00:15:25,950 --> 00:15:31,290
effectively you had your data Postgres

00:15:28,650 --> 00:15:33,210
or database before and now next to your

00:15:31,290 --> 00:15:35,460
database you have your search engine

00:15:33,210 --> 00:15:40,170
it's a kind of second database and you

00:15:35,460 --> 00:15:45,960
need to synchronize them and since

00:15:40,170 --> 00:15:48,300
jingle 1.9 there's been on Jango 1.9 we

00:15:45,960 --> 00:15:51,660
added the the django editor feature

00:15:48,300 --> 00:15:54,660
called transaction hooks which means

00:15:51,660 --> 00:15:57,060
that when you start it when you have it

00:15:54,660 --> 00:16:00,660
when you are inside a transaction you

00:15:57,060 --> 00:16:03,230
can tell django to do something after a

00:16:00,660 --> 00:16:05,880
transaction has successfully committed

00:16:03,230 --> 00:16:07,860
so you do all the things and then we may

00:16:05,880 --> 00:16:11,060
have nested transactions and then

00:16:07,860 --> 00:16:13,890
eventually you do transaction commit and

00:16:11,060 --> 00:16:16,700
the data is saved to the database saved

00:16:13,890 --> 00:16:19,220
into the database django gets the

00:16:16,700 --> 00:16:21,390
positive response back from the database

00:16:19,220 --> 00:16:23,490
transaction successful and then django

00:16:21,390 --> 00:16:26,730
is going to call all this transaction

00:16:23,490 --> 00:16:29,210
whose looks you registered over time in

00:16:26,730 --> 00:16:31,560
the correct order and all these things

00:16:29,210 --> 00:16:33,770
great so you have your safe you overrate

00:16:31,560 --> 00:16:35,910
your safe method on the model and

00:16:33,770 --> 00:16:37,590
whenever you do that you update your

00:16:35,910 --> 00:16:39,900
search you probably don't want to do

00:16:37,590 --> 00:16:42,330
this inside the request but like trigger

00:16:39,900 --> 00:16:47,310
a synchronous talk like about tasks like

00:16:42,330 --> 00:16:49,920
celery but you can effectively update

00:16:47,310 --> 00:16:52,530
your search reliable every time you save

00:16:49,920 --> 00:16:56,130
an article now keep in mind please

00:16:52,530 --> 00:16:59,880
that's the update method on a cruise set

00:16:56,130 --> 00:17:03,140
does not call safe on every instance so

00:16:59,880 --> 00:17:05,819
you need to do something there as well

00:17:03,140 --> 00:17:08,189
similarly you want to delete an article

00:17:05,819 --> 00:17:11,819
from your database whatever whatever or

00:17:08,189 --> 00:17:14,250
whatever you want to do that you can use

00:17:11,819 --> 00:17:16,380
the same idea there's a bit of a gotcha

00:17:14,250 --> 00:17:18,959
here because Django sets the primary key

00:17:16,380 --> 00:17:20,310
to null after it deleted an instance so

00:17:18,959 --> 00:17:22,530
you need to keep track of the primary

00:17:20,310 --> 00:17:24,930
key before you actually trigger the

00:17:22,530 --> 00:17:26,900
deletion and go into the transaction but

00:17:24,930 --> 00:17:30,060
that's fine you can deal with that

00:17:26,900 --> 00:17:31,590
likewise the dotty lead on the free set

00:17:30,060 --> 00:17:36,150
doesn't call the individual

00:17:31,590 --> 00:17:40,830
Methos so doing this this is great this

00:17:36,150 --> 00:17:44,669
works awesome this just one tiny thing

00:17:40,830 --> 00:17:47,570
that we didn't consider yet you write

00:17:44,669 --> 00:17:49,620
your article it's added to the database

00:17:47,570 --> 00:17:52,710
it's available in the search engine

00:17:49,620 --> 00:17:56,159
great that's fine you delete your

00:17:52,710 --> 00:17:58,500
article somebody hits the dis search

00:17:56,159 --> 00:18:00,510
engine you get a return value for a

00:17:58,500 --> 00:18:03,150
result from the search engine which

00:18:00,510 --> 00:18:04,770
still contains the deleted article

00:18:03,150 --> 00:18:06,570
because it hasn't been triggered and

00:18:04,770 --> 00:18:07,399
hasn't been propagated to the search

00:18:06,570 --> 00:18:10,470
engine yet

00:18:07,399 --> 00:18:13,740
so you have this this time window of

00:18:10,470 --> 00:18:15,600
where your search engine has more

00:18:13,740 --> 00:18:18,630
information than your or different

00:18:15,600 --> 00:18:21,390
information than your ad database and it

00:18:18,630 --> 00:18:22,980
has additional information and this can

00:18:21,390 --> 00:18:24,419
potentially lead to several hours

00:18:22,980 --> 00:18:27,360
depending on how you actually implement

00:18:24,419 --> 00:18:30,059
your search so what I highly recommend

00:18:27,360 --> 00:18:34,710
is to maintain a complete search index

00:18:30,059 --> 00:18:36,960
so what does it mean actually well let's

00:18:34,710 --> 00:18:40,950
say you have your search result page

00:18:36,960 --> 00:18:42,690
like a block new site whatever and you

00:18:40,950 --> 00:18:43,919
want to deliver that and have your

00:18:42,690 --> 00:18:46,080
search them and want to deliver this

00:18:43,919 --> 00:18:49,559
page to a user there's essentially two

00:18:46,080 --> 00:18:51,840
options you either search for the

00:18:49,559 --> 00:18:53,880
articles then use the search the primary

00:18:51,840 --> 00:18:58,740
keys fetch all this from the database

00:18:53,880 --> 00:19:00,390
and show to the user or you have all the

00:18:58,740 --> 00:19:02,789
information in the search engine as well

00:19:00,390 --> 00:19:04,200
your reason and you use only the

00:19:02,789 --> 00:19:07,020
information that you get back from the

00:19:04,200 --> 00:19:10,860
search engine that means you include

00:19:07,020 --> 00:19:13,529
things like the URL the modification

00:19:10,860 --> 00:19:17,010
made even if a user doesn't search by

00:19:13,529 --> 00:19:20,460
that inside your search engine which

00:19:17,010 --> 00:19:24,779
means you will not hit your database at

00:19:20,460 --> 00:19:28,140
all when you when you when a user hits

00:19:24,779 --> 00:19:31,110
your search and when you think about

00:19:28,140 --> 00:19:33,020
this a bit further if you for example

00:19:31,110 --> 00:19:36,000
use elasticsearch and Postgres and

00:19:33,020 --> 00:19:38,580
managed to set up your website in a way

00:19:36,000 --> 00:19:40,740
that you have a reach and you have a

00:19:38,580 --> 00:19:42,690
read Heaviside with like a few people

00:19:40,740 --> 00:19:44,940
that write something to the database

00:19:42,690 --> 00:19:45,510
database every now and then you could

00:19:44,940 --> 00:19:49,140
put end

00:19:45,510 --> 00:19:51,990
we built a website that's foreign usual

00:19:49,140 --> 00:19:54,690
users and visitors only reads data from

00:19:51,990 --> 00:19:58,980
elasticsearch and only your colleagues

00:19:54,690 --> 00:20:01,590
or the employees right to that so if you

00:19:58,980 --> 00:20:04,170
put set up a maintenance for Postgres

00:20:01,590 --> 00:20:05,780
you could potentially shut off Postgres

00:20:04,170 --> 00:20:08,610
and your website would keep running and

00:20:05,780 --> 00:20:10,590
nobody would notice because all the

00:20:08,610 --> 00:20:15,540
users serve content is served from

00:20:10,590 --> 00:20:18,240
elasticsearch and Postgres version

00:20:15,540 --> 00:20:23,690
updates can potentially be a bit tricky

00:20:18,240 --> 00:20:30,420
but that's yeah a whole different topic

00:20:23,690 --> 00:20:31,770
so what is search we try to find

00:20:30,420 --> 00:20:38,960
something by looking or otherwise

00:20:31,770 --> 00:20:43,890
seeking carefully and thoroughly when we

00:20:38,960 --> 00:20:48,600
look at this again we try to find

00:20:43,890 --> 00:20:51,810
something so we try to not raise server

00:20:48,600 --> 00:20:55,710
errors we did this we managed to return

00:20:51,810 --> 00:20:58,500
a 4 or 4 which is magnificent which is

00:20:55,710 --> 00:21:02,850
far better to a user than no server

00:20:58,500 --> 00:21:07,310
error 5 4 4 500 500 500 and 3 all these

00:21:02,850 --> 00:21:09,990
things that a usual user can't deal with

00:21:07,310 --> 00:21:14,520
we are careful about this because the

00:21:09,990 --> 00:21:18,840
search engines we use are aware of stuff

00:21:14,520 --> 00:21:22,800
like stemming they are aware of stuff

00:21:18,840 --> 00:21:28,980
like what order they are aware of stuff

00:21:22,800 --> 00:21:31,230
like making sure we use certain or that

00:21:28,980 --> 00:21:33,630
the potentially even words have have

00:21:31,230 --> 00:21:37,560
similar meanings and like there's a

00:21:33,630 --> 00:21:40,190
whole bunch of things that search

00:21:37,560 --> 00:21:46,080
engines can do that your usual database

00:21:40,190 --> 00:21:49,530
probably doesn't and when we go this way

00:21:46,080 --> 00:21:53,190
there's this this point in time and some

00:21:49,530 --> 00:21:54,870
somewhere where you want to have an

00:21:53,190 --> 00:21:56,310
external search engine because the

00:21:54,870 --> 00:21:58,320
benefits of that even though the

00:21:56,310 --> 00:21:59,160
maintaining and maintenance overhead of

00:21:58,320 --> 00:22:02,130
it is

00:21:59,160 --> 00:22:05,160
bigger you don't want to have such as

00:22:02,130 --> 00:22:06,930
part of your implementation application

00:22:05,160 --> 00:22:11,340
and have it implemented in your

00:22:06,930 --> 00:22:13,620
application and this is essentially this

00:22:11,340 --> 00:22:16,740
careful and thoroughly we make sure that

00:22:13,620 --> 00:22:19,700
whatever user enters is carefully

00:22:16,740 --> 00:22:26,010
evaluated and carefully and thoroughly

00:22:19,700 --> 00:22:27,630
like treated so there's a bunch of

00:22:26,010 --> 00:22:29,370
things um I need to make the first

00:22:27,630 --> 00:22:32,430
repository public because this is an

00:22:29,370 --> 00:22:34,680
implementation of a bunch of things I

00:22:32,430 --> 00:22:38,220
wrote while reading while writing the

00:22:34,680 --> 00:22:40,440
talk like code examples of how you use I

00:22:38,220 --> 00:22:42,480
contains that the index classes are in

00:22:40,440 --> 00:22:47,010
there there's an elastic search

00:22:42,480 --> 00:22:49,830
integration there is a bit on this on

00:22:47,010 --> 00:22:53,940
the postcode search in Postgres internal

00:22:49,830 --> 00:22:55,740
searching in there and well then there's

00:22:53,940 --> 00:22:59,630
the search engine go topic that I linked

00:22:55,740 --> 00:23:08,140
before and this to current article on

00:22:59,630 --> 00:23:08,790
and Postgres search alright thank you

00:23:08,140 --> 00:23:10,140
[Applause]

00:23:08,790 --> 00:23:13,390
[Music]

00:23:10,140 --> 00:23:13,390
[Applause]

00:23:15,800 --> 00:23:21,710
okay Thank You Marcus we've got some

00:23:18,060 --> 00:23:25,340
time left for questions if we have any

00:23:21,710 --> 00:23:25,340
yeah don't be shy

00:23:26,150 --> 00:23:31,560
hi Marcus thank you um just when you

00:23:30,540 --> 00:23:34,350
were talking about maintaining the full

00:23:31,560 --> 00:23:36,030
search index and you were kind of saying

00:23:34,350 --> 00:23:37,650
put it into elasticsearch and then put

00:23:36,030 --> 00:23:39,120
the article in there so that they read

00:23:37,650 --> 00:23:41,130
just straight from that the thing that

00:23:39,120 --> 00:23:43,620
came to my mind is well why put it in

00:23:41,130 --> 00:23:47,160
Postgres at all or not like it was just

00:23:43,620 --> 00:23:52,770
a why not drop post case and just very

00:23:47,160 --> 00:23:54,630
fair point let's say well there's just

00:23:52,770 --> 00:23:57,450
different ways to answer this I guess

00:23:54,630 --> 00:23:59,180
first Chris or Django has an ORM which

00:23:57,450 --> 00:24:02,700
is an object relational mapper

00:23:59,180 --> 00:24:06,900
elasticsearch is not really relational

00:24:02,700 --> 00:24:09,600
it's more document store and if you want

00:24:06,900 --> 00:24:13,800
to use the ORM then using elastic

00:24:09,600 --> 00:24:15,510
searches like not really away but if you

00:24:13,800 --> 00:24:18,990
use the RM and then deal with that

00:24:15,510 --> 00:24:19,590
yourself based on how your application

00:24:18,990 --> 00:24:23,850
actually works

00:24:19,590 --> 00:24:27,240
this can be properly dealt with the

00:24:23,850 --> 00:24:29,400
other thing is that you're most people

00:24:27,240 --> 00:24:32,570
or most projects these days from my

00:24:29,400 --> 00:24:35,910
perspective are still relational and I

00:24:32,570 --> 00:24:37,860
think in in many places objects or

00:24:35,910 --> 00:24:39,630
document stores or column stores or all

00:24:37,860 --> 00:24:42,390
these things they have a they have a

00:24:39,630 --> 00:24:43,710
reason they're out there but for most

00:24:42,390 --> 00:24:48,330
applications that's out there these days

00:24:43,710 --> 00:24:49,830
it's still read and relational and a lot

00:24:48,330 --> 00:24:53,400
of the benefits that relational

00:24:49,830 --> 00:24:55,800
databases are great at just vanish the

00:24:53,400 --> 00:24:58,500
moment where you go with some other than

00:24:55,800 --> 00:25:02,430
right where you try to force your foster

00:24:58,500 --> 00:25:05,700
data into these other data stores and so

00:25:02,430 --> 00:25:09,090
yeah I think that's having the usual the

00:25:05,700 --> 00:25:10,620
keeping the ORM part in there and talk

00:25:09,090 --> 00:25:12,720
to post quest or layer database like

00:25:10,620 --> 00:25:14,310
this and then just yeah this is

00:25:12,720 --> 00:25:17,480
something that's that deals with the

00:25:14,310 --> 00:25:20,780
load so to say provide some benefits

00:25:17,480 --> 00:25:25,860
perfect answer thank you thank you

00:25:20,780 --> 00:25:27,540
okay do we have any more questions thank

00:25:25,860 --> 00:25:29,630
you very much again Marcus then thank

00:25:27,540 --> 00:25:29,630
you

00:25:30,450 --> 00:25:34,630
[Music]

00:25:32,570 --> 00:25:34,630

YouTube URL: https://www.youtube.com/watch?v=GpynTvoxPHI


