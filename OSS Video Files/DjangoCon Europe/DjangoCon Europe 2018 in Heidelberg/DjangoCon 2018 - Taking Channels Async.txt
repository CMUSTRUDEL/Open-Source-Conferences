Title: DjangoCon 2018 - Taking Channels Async
Publication date: 2018-05-24
Playlist: DjangoCon Europe 2018 in Heidelberg
Description: 
	https://media.ccc.de/v/hd-26-taking-channels-async



We take a look at Channels 2.0 and the changes it brings by going fully async, examining not only why the change makes things better, but also how we've managed to bridge between Django's synchronous world and the async world, and what the future might hold for Django and Channels.

The Channels project has taken a major turn with version 2.0, embracing Python's async functionality and building applications around an async event loop rather than worker processes. But why the big change? And what does it mean for Django?

We'll look at the progress Channels is making in turning more of the request/response cycle into native async code - how far can we get down the stack before making APIs async becomes hard? Can we make it as far as the ORM? How do we bridge between Django's synchronous world and the async world when we do reach that boundary?

We also take a look at how it's changed both Channels consumers, opening up the possibility of mixing async calls in with your synchronous code, and how it's changed what the ASGI spec looks like and what that might mean for adoption.

And, finally, we'll look what's next for Django and Channels, and maybe how it will affect the Python web world as a whole.

Andrew Godwin
Captions: 
	00:00:06,450 --> 00:00:10,870
next we have Andrew Godwin who is here

00:00:08,889 --> 00:00:12,760
presenting taking it channels async

00:00:10,870 --> 00:00:14,110
Andrew is a member of the Django core

00:00:12,760 --> 00:00:16,150
team and has been working with Django

00:00:14,110 --> 00:00:18,609
since 2007 on projects such as South

00:00:16,150 --> 00:00:20,199
migrations and of course channels

00:00:18,609 --> 00:00:22,150
he works at Eventbrite as a senior

00:00:20,199 --> 00:00:24,369
software engineer he will not be taking

00:00:22,150 --> 00:00:25,480
questions so if you have a question that

00:00:24,369 --> 00:00:35,530
you have for Andrew please take that

00:00:25,480 --> 00:00:37,840
once this talk is over Thank You Lacey

00:00:35,530 --> 00:00:40,240
so yes I am here to talk to you about

00:00:37,840 --> 00:00:42,520
channels and don't worry this is not the

00:00:40,240 --> 00:00:43,990
same as yes they talk about Jakob oh and

00:00:42,520 --> 00:00:46,450
this is a different kind of talk about

00:00:43,990 --> 00:00:47,950
some of the history of channels some of

00:00:46,450 --> 00:00:49,390
the reasoning behind the Virgin change

00:00:47,950 --> 00:00:51,430
are some of the things it might mean for

00:00:49,390 --> 00:00:52,210
Django in the future but first a little

00:00:51,430 --> 00:00:55,660
bit about myself

00:00:52,210 --> 00:00:56,080
Oh once again this is not working there

00:00:55,660 --> 00:00:58,810
we go

00:00:56,080 --> 00:01:00,730
so as lady said I'm a Django core team

00:00:58,810 --> 00:01:03,520
member I work at Eventbrite and I have

00:01:00,730 --> 00:01:06,430
this bad habit of doing things like

00:01:03,520 --> 00:01:09,070
network programming for fun now it's not

00:01:06,430 --> 00:01:10,630
a particularly fun activity I don't

00:01:09,070 --> 00:01:13,510
recommend it as a side hobby but it's a

00:01:10,630 --> 00:01:15,610
thing I do nonetheless and this started

00:01:13,510 --> 00:01:17,890
in 2015 on the project that back then

00:01:15,610 --> 00:01:19,600
was called Django on air this was the

00:01:17,890 --> 00:01:22,120
very first code name for what channels

00:01:19,600 --> 00:01:24,190
became I was sitting down thinking I

00:01:22,120 --> 00:01:26,320
should make a thing that isn't

00:01:24,190 --> 00:01:29,170
migrations it had been quite a few years

00:01:26,320 --> 00:01:30,640
at this point and I wanted to look at

00:01:29,170 --> 00:01:33,280
WebSockets and real time stuff

00:01:30,640 --> 00:01:36,190
eventually that became the thing we know

00:01:33,280 --> 00:01:39,190
today called channels and overtime

00:01:36,190 --> 00:01:42,330
channels 0.1 was released in 2015

00:01:39,190 --> 00:01:45,850
became channels 1.0 released in 2017

00:01:42,330 --> 00:01:47,440
this first version of channels had quite

00:01:45,850 --> 00:01:50,200
a few things going for it and there are

00:01:47,440 --> 00:01:52,840
a few particular design reasons in its

00:01:50,200 --> 00:01:53,530
development that ended up making it not

00:01:52,840 --> 00:01:56,710
so great

00:01:53,530 --> 00:01:57,790
the key problem it had was because of

00:01:56,710 --> 00:02:00,310
the time of its inception

00:01:57,790 --> 00:02:02,920
remember this 2015 Python 3 is not such

00:02:00,310 --> 00:02:06,640
a big thing I wanted to make it Python

00:02:02,920 --> 00:02:08,679
2.7 compatible this of course means you

00:02:06,640 --> 00:02:10,869
can't use things like a sin kayo you

00:02:08,679 --> 00:02:12,400
can't use things that are in modern

00:02:10,869 --> 00:02:14,740
Python you're restricted to things from

00:02:12,400 --> 00:02:16,090
quite a few years ago I ended up using

00:02:14,740 --> 00:02:18,280
twisted to the web server because

00:02:16,090 --> 00:02:19,640
twisted is way well understood it's very

00:02:18,280 --> 00:02:23,030
well known

00:02:19,640 --> 00:02:25,040
and running Jango synchronously for an

00:02:23,030 --> 00:02:26,900
idea of how this looks this is a rough

00:02:25,040 --> 00:02:29,360
architectural diagram of how channels

00:02:26,900 --> 00:02:31,760
used to run in version one you had two

00:02:29,360 --> 00:02:34,819
different processes a web server which

00:02:31,760 --> 00:02:37,430
is called Daphne and runs entwisted then

00:02:34,819 --> 00:02:40,330
a Redis middle layer which transported

00:02:37,430 --> 00:02:43,700
messages to and from the web server to

00:02:40,330 --> 00:02:45,620
separate Django worker processes if you

00:02:43,700 --> 00:02:47,930
use channels 1.0 you would have been

00:02:45,620 --> 00:02:50,270
familiar with how to run a server and

00:02:47,930 --> 00:02:51,620
then separately run workers and if the

00:02:50,270 --> 00:02:53,900
worker wasn't running there were some

00:02:51,620 --> 00:02:57,620
weird error cases it didn't work super

00:02:53,900 --> 00:02:59,810
well and in general it just had too many

00:02:57,620 --> 00:03:02,600
moving pieces one of the problems the

00:02:59,810 --> 00:03:04,790
design is it was really Hubble sort of

00:03:02,600 --> 00:03:07,820
undermined by the fact it has to support

00:03:04,790 --> 00:03:10,190
Python to this of course not only is

00:03:07,820 --> 00:03:14,209
having too many moving pieces meant no

00:03:10,190 --> 00:03:15,709
support for async i/o and ultimately the

00:03:14,209 --> 00:03:18,200
end result of this design and all the

00:03:15,709 --> 00:03:19,970
moving pieces and the complexity when it

00:03:18,200 --> 00:03:21,970
was very easy to shoot yourself in the

00:03:19,970 --> 00:03:24,380
foot I

00:03:21,970 --> 00:03:25,970
my personal belief of Django is it's

00:03:24,380 --> 00:03:28,190
designed to give you a safe environment

00:03:25,970 --> 00:03:30,650
to experiment in and understand what

00:03:28,190 --> 00:03:32,329
you're doing and ultimately channels one

00:03:30,650 --> 00:03:34,160
didn't really have that it was

00:03:32,329 --> 00:03:36,260
experimental but not perfect and

00:03:34,160 --> 00:03:38,600
ultimately I think the design of all I

00:03:36,260 --> 00:03:41,930
did was wrong this is something you have

00:03:38,600 --> 00:03:44,570
to admit on stage like this and so I had

00:03:41,930 --> 00:03:47,079
to sort of sit down last year and relook

00:03:44,570 --> 00:03:50,480
at everything again and in the light of

00:03:47,079 --> 00:03:52,549
2017 Python 3 being a supported thing

00:03:50,480 --> 00:03:55,250
Django 2 at that point had been released

00:03:52,549 --> 00:03:56,650
and only supported Python 3 I really

00:03:55,250 --> 00:04:00,040
what it meant for channels to be and

00:03:56,650 --> 00:04:02,989
then this year I released channels 2.0

00:04:00,040 --> 00:04:05,049
channels to is a pretty substantial

00:04:02,989 --> 00:04:08,239
rewrite of the channels one code base

00:04:05,049 --> 00:04:10,519
the most important thing is it is a sink

00:04:08,239 --> 00:04:13,280
i/o native it has that built-in support

00:04:10,519 --> 00:04:15,290
for running async code using the things

00:04:13,280 --> 00:04:17,870
that Python 3 gives you things like

00:04:15,290 --> 00:04:20,479
async death and proper awaits

00:04:17,870 --> 00:04:22,760
it also supports both synchronous

00:04:20,479 --> 00:04:25,100
threads and asynchronous co-routines

00:04:22,760 --> 00:04:27,260
and even better because of all this

00:04:25,100 --> 00:04:28,810
built-in support in Python because we

00:04:27,260 --> 00:04:31,010
can do things in the same process

00:04:28,810 --> 00:04:32,840
it meant deploying it became a lot

00:04:31,010 --> 00:04:33,350
easier rather than having those two

00:04:32,840 --> 00:04:35,510
separate

00:04:33,350 --> 00:04:38,150
processes you now just have like you do

00:04:35,510 --> 00:04:41,870
with WSGI a single web server process

00:04:38,150 --> 00:04:43,730
inside of which lives Django and so

00:04:41,870 --> 00:04:47,450
that's got the the overview of the

00:04:43,730 --> 00:04:50,210
rewrite it was about 75% of a rewrite I

00:04:47,450 --> 00:04:52,790
would say it wasn't particularly rip

00:04:50,210 --> 00:04:54,230
everything out start again but over the

00:04:52,790 --> 00:04:56,690
course of months I took every file

00:04:54,230 --> 00:04:59,660
examined it kept what I could then threw

00:04:56,690 --> 00:05:02,450
away what I couldn't and a lot of it had

00:04:59,660 --> 00:05:05,060
to be thrown away for one key reason and

00:05:02,450 --> 00:05:08,270
that is that I had to start making

00:05:05,060 --> 00:05:10,430
Django partially async now if you're not

00:05:08,270 --> 00:05:12,200
familiar with pythons async support one

00:05:10,430 --> 00:05:14,360
of the main problems you have is that

00:05:12,200 --> 00:05:16,640
asynchronous functions and synchronous

00:05:14,360 --> 00:05:18,890
functions have a different calling

00:05:16,640 --> 00:05:20,510
interface you can't mix and match them

00:05:18,890 --> 00:05:22,460
it's very hard to make a library that

00:05:20,510 --> 00:05:24,830
supports both of them and of course

00:05:22,460 --> 00:05:26,750
Django has been around for quite a long

00:05:24,830 --> 00:05:29,990
time it has a lot of wonderful

00:05:26,750 --> 00:05:32,600
synchronous parts here is a very basic

00:05:29,990 --> 00:05:35,270
diagram of some parts of Django in a

00:05:32,600 --> 00:05:37,640
layer stack it's not quite as simple as

00:05:35,270 --> 00:05:40,640
that but you get the idea and all of

00:05:37,640 --> 00:05:41,480
this is synchronous and given that I

00:05:40,640 --> 00:05:44,630
wanted to make things

00:05:41,480 --> 00:05:47,120
asynchronous I had to sit there and work

00:05:44,630 --> 00:05:48,800
out what to rewrite in channels 1 all

00:05:47,120 --> 00:05:50,690
this is running in a synchronous worker

00:05:48,800 --> 00:05:53,600
process I could keep it it kept working

00:05:50,690 --> 00:05:55,970
as it was in channels 2 because it's

00:05:53,600 --> 00:05:58,280
shared in the same process underneath an

00:05:55,970 --> 00:06:00,290
asynchronous event loop you have to make

00:05:58,280 --> 00:06:01,400
sure that things yield to each other

00:06:00,290 --> 00:06:03,440
there's it's called cooperative

00:06:01,400 --> 00:06:06,470
multitasking you have to be cooperative

00:06:03,440 --> 00:06:09,830
and so one of the things channels 2 does

00:06:06,470 --> 00:06:12,290
is in choose a second almost parallel

00:06:09,830 --> 00:06:15,260
kind of stack for doing a lot of this

00:06:12,290 --> 00:06:16,790
stuff you can see that everything in

00:06:15,260 --> 00:06:18,800
that box on the left-hand side there

00:06:16,790 --> 00:06:21,320
that remains synchronous even under

00:06:18,800 --> 00:06:24,860
channels things like the ORM and the old

00:06:21,320 --> 00:06:26,780
Django views they're kept as is for

00:06:24,860 --> 00:06:30,140
backwards compatibility reasons pretty

00:06:26,780 --> 00:06:32,240
much on top of that the other things the

00:06:30,140 --> 00:06:34,610
ASCII routing the ascii middleware I'll

00:06:32,240 --> 00:06:37,310
explain what as he means later those all

00:06:34,610 --> 00:06:39,050
exist in a pure async world and for that

00:06:37,310 --> 00:06:41,450
reason they're basically ground-up

00:06:39,050 --> 00:06:44,600
rewrites of a lot of Django things like

00:06:41,450 --> 00:06:47,180
the author middleware in channels for

00:06:44,600 --> 00:06:49,250
example it does give you a

00:06:47,180 --> 00:06:51,949
use objects like the Django or

00:06:49,250 --> 00:06:53,090
middleware does but a lot of the inside

00:06:51,949 --> 00:06:55,039
of it is written in an entirely

00:06:53,090 --> 00:06:59,539
different way to try and be asynchronous

00:06:55,039 --> 00:07:02,930
and this is one of the things like I had

00:06:59,539 --> 00:07:05,960
to try and make Django async native most

00:07:02,930 --> 00:07:07,430
of the way through its stack again it's

00:07:05,960 --> 00:07:09,289
not all the way through and I'll talk

00:07:07,430 --> 00:07:11,900
about a little bit why and plans for

00:07:09,289 --> 00:07:14,120
that near the end of the talk but the

00:07:11,900 --> 00:07:17,000
first thing I look at is how I did that

00:07:14,120 --> 00:07:19,400
and one of the things you may have seen

00:07:17,000 --> 00:07:22,550
in the talk yesterday about channels was

00:07:19,400 --> 00:07:25,400
these two functions sink to a sink and a

00:07:22,550 --> 00:07:27,590
sink to sink these are the two functions

00:07:25,400 --> 00:07:30,610
took me about two months to write and

00:07:27,590 --> 00:07:34,970
perfect they are incredibly tricky and

00:07:30,610 --> 00:07:37,039
the name as it suggests tells you that

00:07:34,970 --> 00:07:39,560
one of them turns synchronous functions

00:07:37,039 --> 00:07:41,900
into a way table asynchronous functions

00:07:39,560 --> 00:07:43,940
the other one turns away table

00:07:41,900 --> 00:07:46,310
asynchronous functions into synchronous

00:07:43,940 --> 00:07:49,340
functions and each of them have their

00:07:46,310 --> 00:07:51,080
role to play in the process let's start

00:07:49,340 --> 00:07:54,440
by looking at sink could async this is

00:07:51,080 --> 00:07:57,169
the easier one of the two so why do we

00:07:54,440 --> 00:07:59,180
need this well as you've seen Django has

00:07:57,169 --> 00:08:01,849
a lot of synchronous code the RM is a

00:07:59,180 --> 00:08:03,800
very good example I am not the sort of

00:08:01,849 --> 00:08:05,990
person who can sit down rewrite the ORM

00:08:03,800 --> 00:08:08,750
in a year that's not a project I can do

00:08:05,990 --> 00:08:11,240
and so we have to run that kind of code

00:08:08,750 --> 00:08:13,370
in threads if you run synchronous code

00:08:11,240 --> 00:08:15,530
on the main event loop because it's

00:08:13,370 --> 00:08:17,300
cooperative multitasking you're going to

00:08:15,530 --> 00:08:18,860
sit there and block the event loop all

00:08:17,300 --> 00:08:21,500
the time the synchronous code is running

00:08:18,860 --> 00:08:23,449
it's not an error which is unfortunate

00:08:21,500 --> 00:08:25,880
it just sort of sits there and slows

00:08:23,449 --> 00:08:28,460
down making you really hard to look at

00:08:25,880 --> 00:08:30,259
what's happening and so you have to take

00:08:28,460 --> 00:08:32,630
your synchronous code put it off the

00:08:30,259 --> 00:08:34,370
event loop and put it aside into a

00:08:32,630 --> 00:08:37,579
thread and let it sit there in the

00:08:34,370 --> 00:08:40,430
thread idling and doing its stuff python

00:08:37,579 --> 00:08:43,190
has pretty reasonable support for this

00:08:40,430 --> 00:08:45,560
it gets better in version 3.7 but in

00:08:43,190 --> 00:08:48,020
version 3.5 it looks a little bit like

00:08:45,560 --> 00:08:50,870
this you get your event loop to the top

00:08:48,020 --> 00:08:52,970
line there you make a future to run in

00:08:50,870 --> 00:08:55,970
the executor there's a thing called a

00:08:52,970 --> 00:08:58,100
thread pool executor in Python which as

00:08:55,970 --> 00:09:00,740
the name suggests runs things and

00:08:58,100 --> 00:09:01,040
threads and then use the tree await the

00:09:00,740 --> 00:09:03,650
few

00:09:01,040 --> 00:09:06,140
when you do the await call the event

00:09:03,650 --> 00:09:07,760
loop pauses that co-routine starts the

00:09:06,140 --> 00:09:10,130
thread up and then when the thread

00:09:07,760 --> 00:09:13,520
finishes it notices and resumes your Co

00:09:10,130 --> 00:09:15,980
routine we left off as I said this is

00:09:13,520 --> 00:09:17,600
good for not just calling the ORM but

00:09:15,980 --> 00:09:20,390
things like rendering templates

00:09:17,600 --> 00:09:22,280
Django's template system can do blocking

00:09:20,390 --> 00:09:23,570
requests you can call the RM inside it

00:09:22,280 --> 00:09:26,000
you can call other parts of Django

00:09:23,570 --> 00:09:28,610
inside it and also handing off to django

00:09:26,000 --> 00:09:31,250
views channels is designed to live

00:09:28,610 --> 00:09:33,230
alongside your existing django view code

00:09:31,250 --> 00:09:34,580
and use it in the middleware and so we

00:09:33,230 --> 00:09:36,590
don't want to disrupt that we want to

00:09:34,580 --> 00:09:38,450
keep that view code and a happy

00:09:36,590 --> 00:09:39,920
synchronous world where you don't have

00:09:38,450 --> 00:09:43,240
to sit there and rewrite it all to be

00:09:39,920 --> 00:09:46,700
async to even get started with channels

00:09:43,240 --> 00:09:49,940
let's turn to the more difficult task

00:09:46,700 --> 00:09:52,490
which is async to sync now as I said

00:09:49,940 --> 00:09:55,760
before async code runs on an event loop

00:09:52,490 --> 00:09:57,920
and generally in Python your main thread

00:09:55,760 --> 00:09:59,930
the thread that your program starts in

00:09:57,920 --> 00:10:02,390
is where you run your event loop and

00:09:59,930 --> 00:10:04,670
often what you'll do is you'll be in a

00:10:02,390 --> 00:10:06,830
synchronous thread and you'll want to

00:10:04,670 --> 00:10:07,820
call an asynchronous piece of code you

00:10:06,830 --> 00:10:09,980
may have seen in yesterday's

00:10:07,820 --> 00:10:11,780
presentation about channels all the

00:10:09,980 --> 00:10:14,360
different methods on channel layers are

00:10:11,780 --> 00:10:15,680
all asynchronous you can't send to a

00:10:14,360 --> 00:10:18,860
group without it being an asynchronous

00:10:15,680 --> 00:10:21,020
call and so if you're in a random

00:10:18,860 --> 00:10:23,840
management PI script if you're in the RM

00:10:21,020 --> 00:10:26,120
if you're anywhere in Django that's sort

00:10:23,840 --> 00:10:28,460
of old synchronous code you want to call

00:10:26,120 --> 00:10:31,100
this async code but from a synchronous

00:10:28,460 --> 00:10:34,220
context now if you remember the previous

00:10:31,100 --> 00:10:37,190
code was pretty easel easy to read well

00:10:34,220 --> 00:10:39,380
formatted this is the short version of

00:10:37,190 --> 00:10:41,180
acing to sync as you can see it's not

00:10:39,380 --> 00:10:42,260
particularly readable you're not going

00:10:41,180 --> 00:10:46,040
to be able to see it from there

00:10:42,260 --> 00:10:47,960
but the essence what it does is it makes

00:10:46,040 --> 00:10:49,580
a thing called a future a future is a

00:10:47,960 --> 00:10:52,370
thing in in Python and many other

00:10:49,580 --> 00:10:54,650
languages that says hey I'm gonna go and

00:10:52,370 --> 00:10:56,210
do a thing and when I finish I'm gonna

00:10:54,650 --> 00:11:00,200
give you the result so it makes the

00:10:56,210 --> 00:11:02,300
future and then it has to jump from the

00:11:00,200 --> 00:11:04,460
thread it's in to the main thread

00:11:02,300 --> 00:11:07,880
because Python async is not thread safe

00:11:04,460 --> 00:11:09,770
in a wonderful mind-bending way and then

00:11:07,880 --> 00:11:12,890
once it's on the main thread has to then

00:11:09,770 --> 00:11:14,660
go and find the main event loop get the

00:11:12,890 --> 00:11:16,069
Mako routine

00:11:14,660 --> 00:11:18,350
get the future from the other thread it

00:11:16,069 --> 00:11:21,199
just left tie that thread into the other

00:11:18,350 --> 00:11:22,819
co-routine and then go when you finished

00:11:21,199 --> 00:11:25,850
unblock this thread and sort of put its

00:11:22,819 --> 00:11:28,610
hands up like this this is where most of

00:11:25,850 --> 00:11:31,399
the pain came from during development it

00:11:28,610 --> 00:11:32,959
is tricky to do it's still not perfect

00:11:31,399 --> 00:11:36,800
it's it's a long way from where it was

00:11:32,959 --> 00:11:39,170
and the key thing this does for all the

00:11:36,800 --> 00:11:42,800
difficulty in development is it lets us

00:11:39,170 --> 00:11:45,980
provide a sync native api's I can write

00:11:42,800 --> 00:11:49,040
things like the channel layers once and

00:11:45,980 --> 00:11:51,709
then let django code use them wherever

00:11:49,040 --> 00:11:53,540
it is this solves one of the problems I

00:11:51,709 --> 00:11:55,699
have with channels one and the reason I

00:11:53,540 --> 00:11:57,589
didn't do a sync there I didn't want to

00:11:55,699 --> 00:11:59,360
write everything twice I didn't want to

00:11:57,589 --> 00:12:00,920
have to have the channel layer

00:11:59,360 --> 00:12:02,899
synchronous and the channel layer

00:12:00,920 --> 00:12:04,790
asynchronous even for things like

00:12:02,899 --> 00:12:07,279
middleware I didn't want to have to have

00:12:04,790 --> 00:12:09,500
the synchronous user middleware and the

00:12:07,279 --> 00:12:11,029
asynchronous use a little where for four

00:12:09,500 --> 00:12:13,279
channels as well as the Django one as

00:12:11,029 --> 00:12:15,319
well and this is one of the things where

00:12:13,279 --> 00:12:17,720
channels philosophy in general is that

00:12:15,319 --> 00:12:19,880
both synchronous and asynchronous code

00:12:17,720 --> 00:12:22,250
are useful my goal is not to make

00:12:19,880 --> 00:12:24,259
everyone write async code it is more

00:12:22,250 --> 00:12:26,300
difficult more complicated and harder to

00:12:24,259 --> 00:12:29,029
debug my goal is to let you write it

00:12:26,300 --> 00:12:30,649
when you want to and then let you use

00:12:29,029 --> 00:12:33,350
synchronous code the rest of the time

00:12:30,649 --> 00:12:36,290
and so it's very important to have that

00:12:33,350 --> 00:12:38,300
cross compatibility where you can call

00:12:36,290 --> 00:12:40,009
the other world the synchronous world

00:12:38,300 --> 00:12:43,730
from the asynchronous world and vice

00:12:40,009 --> 00:12:44,899
versa whenever you want to and not just

00:12:43,730 --> 00:12:47,870
let's let you use

00:12:44,899 --> 00:12:49,250
Django's code and charles code wherever

00:12:47,870 --> 00:12:51,470
you want but to have your own code

00:12:49,250 --> 00:12:54,199
written that way if you want to write a

00:12:51,470 --> 00:12:56,540
reusable application that uses async

00:12:54,199 --> 00:12:58,250
code with these kind of functions you

00:12:56,540 --> 00:13:00,170
can ship it in the knowledge that people

00:12:58,250 --> 00:13:01,430
can call it from anywhere they're not

00:13:00,170 --> 00:13:04,670
really locked out of it because they're

00:13:01,430 --> 00:13:06,439
on synchronous code Jango this is an

00:13:04,670 --> 00:13:09,769
unfortunate part of pythons design for

00:13:06,439 --> 00:13:12,579
async there's many many articles online

00:13:09,769 --> 00:13:14,600
about the trade-offs that Python made

00:13:12,579 --> 00:13:18,500
they were made many years ago as well

00:13:14,600 --> 00:13:21,439
but the key thing is generally you'll

00:13:18,500 --> 00:13:23,449
find async api's and libraries are

00:13:21,439 --> 00:13:25,610
entirely separate to synchronous ones

00:13:23,449 --> 00:13:27,829
for example the Redis library that we

00:13:25,610 --> 00:13:28,340
use for the channel layer in channels

00:13:27,829 --> 00:13:32,180
two

00:13:28,340 --> 00:13:33,980
is AI Oh Redis it's an async i/o only

00:13:32,180 --> 00:13:36,590
version of the library you can't call it

00:13:33,980 --> 00:13:37,460
from a synchronous context easily if I

00:13:36,590 --> 00:13:39,770
was going to ship a version that

00:13:37,460 --> 00:13:41,960
supported both I have to import two

00:13:39,770 --> 00:13:44,090
different Redis libraries write two

00:13:41,960 --> 00:13:47,300
separate code paths one for synchronous

00:13:44,090 --> 00:13:49,820
one for asynchronous and somehow manage

00:13:47,300 --> 00:13:51,650
the state so that if you listened on a

00:13:49,820 --> 00:13:53,180
synchronous thread and then waited on

00:13:51,650 --> 00:13:55,430
that asynchronous throw that they talk

00:13:53,180 --> 00:13:57,620
to each other properly this is why we

00:13:55,430 --> 00:13:59,120
have as compatibility layers if you want

00:13:57,620 --> 00:14:01,010
to see more about this particular

00:13:59,120 --> 00:14:03,380
problem about separate interfaces and

00:14:01,010 --> 00:14:04,870
how to understand them I have a blog

00:14:03,380 --> 00:14:07,760
post on the topic you can go and read

00:14:04,870 --> 00:14:09,470
it's not particularly long but it covers

00:14:07,760 --> 00:14:12,110
a lot more than I can in this talk about

00:14:09,470 --> 00:14:14,660
the different worlds and how you want to

00:14:12,110 --> 00:14:16,970
manage and think about taking your code

00:14:14,660 --> 00:14:21,260
and running it in both an asynchronous

00:14:16,970 --> 00:14:24,020
context and in a synchronous context but

00:14:21,260 --> 00:14:26,330
let's go back to that Django diagram and

00:14:24,020 --> 00:14:29,660
there is one key feature on this diagram

00:14:26,330 --> 00:14:31,630
that may be a little bit smaller loaded

00:14:29,660 --> 00:14:34,730
you on the bottom right hand corner

00:14:31,630 --> 00:14:38,180
right here in fact there is a small

00:14:34,730 --> 00:14:39,320
arrow that arrow on both the small

00:14:38,180 --> 00:14:42,710
version and the big version of the

00:14:39,320 --> 00:14:47,420
diagram is representing the incoming

00:14:42,710 --> 00:14:50,680
request from outside now in the nice old

00:14:47,420 --> 00:14:53,780
Python we all know and love that is WSGI

00:14:50,680 --> 00:14:56,050
it's a very well understood standard

00:14:53,780 --> 00:14:59,380
it's been around for many many years and

00:14:56,050 --> 00:15:02,210
pretty much every single framework

00:14:59,380 --> 00:15:06,860
application server in the Python

00:15:02,210 --> 00:15:10,150
ecosystem supports it but of course it

00:15:06,860 --> 00:15:12,500
has one problem it's synchronous and

00:15:10,150 --> 00:15:15,380
this is not a thing where I can say oh

00:15:12,500 --> 00:15:18,160
we're just gonna wrap channels in async

00:15:15,380 --> 00:15:20,690
to sync and put it underneath the WSGI

00:15:18,160 --> 00:15:22,850
generally when you do asynchronous stuff

00:15:20,690 --> 00:15:24,050
you have to make it asynchronous from

00:15:22,850 --> 00:15:26,180
the outside in

00:15:24,050 --> 00:15:28,940
to make things efficient so you have to

00:15:26,180 --> 00:15:31,400
make the routing and the handling and

00:15:28,940 --> 00:15:34,190
the middleware asynchronous but maybe

00:15:31,400 --> 00:15:36,050
the ORM is still synchronous if you

00:15:34,190 --> 00:15:38,690
don't do it that way you end up having

00:15:36,050 --> 00:15:41,600
to block a whole Python thread or a

00:15:38,690 --> 00:15:42,140
whole Python process just waiting for

00:15:41,600 --> 00:15:45,019
one

00:15:42,140 --> 00:15:46,880
asynchronous program to run and so the

00:15:45,019 --> 00:15:50,899
problem we really faced is how do we

00:15:46,880 --> 00:15:53,269
make WSGI async now the easy answer is

00:15:50,899 --> 00:15:56,240
you put an A in it and of course that

00:15:53,269 --> 00:15:58,130
makes it async and this is not quite

00:15:56,240 --> 00:16:01,250
what I did but it is the essence of what

00:15:58,130 --> 00:16:03,920
happened over the past few years I have

00:16:01,250 --> 00:16:07,519
been trying to develop a standard called

00:16:03,920 --> 00:16:10,730
a SGI which is like WSGI but for

00:16:07,519 --> 00:16:14,149
asynchronous situations and one of the

00:16:10,730 --> 00:16:17,060
key things with WSGI is that it is

00:16:14,149 --> 00:16:17,870
simplistic has a design that's easy to

00:16:17,060 --> 00:16:20,660
understand

00:16:17,870 --> 00:16:23,390
you make a function the function gets

00:16:20,660 --> 00:16:26,060
given two arguments and Enver on which

00:16:23,390 --> 00:16:28,670
is basically here's the request and the

00:16:26,060 --> 00:16:30,140
part and stuff and a callable that says

00:16:28,670 --> 00:16:32,630
call this when you want to start your

00:16:30,140 --> 00:16:33,950
response so you take the Enver on you

00:16:32,630 --> 00:16:36,410
send the headers with a second to level

00:16:33,950 --> 00:16:39,620
and then you just return data it's

00:16:36,410 --> 00:16:42,320
simple it's easy to understand there was

00:16:39,620 --> 00:16:46,910
an ASG I won to match with channels one

00:16:42,320 --> 00:16:49,519
it was shall we say over complicated by

00:16:46,910 --> 00:16:52,310
half and so as part of the channels to

00:16:49,519 --> 00:16:54,890
redesign I sat down looked a SGI as well

00:16:52,310 --> 00:16:57,589
with the goal of how do we make a

00:16:54,890 --> 00:17:00,050
standard that not just Django can use

00:16:57,589 --> 00:17:03,079
but the wider Python world can use as

00:17:00,050 --> 00:17:06,890
well this is the essence what I ended up

00:17:03,079 --> 00:17:08,929
with and a SGO application is a little

00:17:06,890 --> 00:17:11,600
bit more complex than the WSGI one but

00:17:08,929 --> 00:17:14,929
not very much so you have basically a

00:17:11,600 --> 00:17:17,540
thing that you call usually a class with

00:17:14,929 --> 00:17:20,569
a scope the scope is like the m4 and has

00:17:17,540 --> 00:17:22,010
the path it has the method in HTTP it

00:17:20,569 --> 00:17:25,240
tells you all the information about the

00:17:22,010 --> 00:17:28,280
connection and then when you've got your

00:17:25,240 --> 00:17:30,950
instance the application it then calls

00:17:28,280 --> 00:17:33,410
the co-routine section the async death

00:17:30,950 --> 00:17:35,270
in this example and then sets it off as

00:17:33,410 --> 00:17:38,500
hey here's the thing to receive data

00:17:35,270 --> 00:17:41,750
here's the send data do what you want

00:17:38,500 --> 00:17:44,510
one of the nice things about this is but

00:17:41,750 --> 00:17:45,830
it just gives you a KO routine you don't

00:17:44,510 --> 00:17:48,230
have to listen straightaway

00:17:45,830 --> 00:17:49,790
what channels actually does is before it

00:17:48,230 --> 00:17:52,820
listens on the socket for incoming

00:17:49,790 --> 00:17:54,679
requests it first spins up the Redis

00:17:52,820 --> 00:17:55,940
channel layer and makes a name for

00:17:54,679 --> 00:17:58,220
itself and listens on

00:17:55,940 --> 00:18:01,100
then sock it to and so what channel's

00:17:58,220 --> 00:18:03,110
consumers do is listen on both the

00:18:01,100 --> 00:18:05,629
receive callable from the server and

00:18:03,110 --> 00:18:07,159
also on reddit's which means that manner

00:18:05,629 --> 00:18:08,929
what you're sending and where the events

00:18:07,159 --> 00:18:11,299
are coming from you're still going to

00:18:08,929 --> 00:18:13,460
have that same co-routine and that same

00:18:11,299 --> 00:18:14,929
instance handling them this is one of

00:18:13,460 --> 00:18:16,759
the things you heard Jacopo talked about

00:18:14,929 --> 00:18:19,250
yesterday where you can store things on

00:18:16,759 --> 00:18:21,049
self because it's a single instance this

00:18:19,250 --> 00:18:23,929
one class is hidden there in a tight

00:18:21,049 --> 00:18:26,600
loop working at what's happening the

00:18:23,929 --> 00:18:28,519
other thing with a SGI that actually

00:18:26,600 --> 00:18:31,669
came from the first django conure if i

00:18:28,519 --> 00:18:33,350
ever attended back in Prague in 2009 is

00:18:31,669 --> 00:18:35,480
a concept called Turtles all the way

00:18:33,350 --> 00:18:37,159
down this is something I think I think I

00:18:35,480 --> 00:18:39,559
can credit to this island willerson or

00:18:37,159 --> 00:18:41,779
maybe Adrian I forget who it was but the

00:18:39,559 --> 00:18:45,259
idea is that in Django as it stands now

00:18:41,779 --> 00:18:47,269
the middleware and the views and the URL

00:18:45,259 --> 00:18:49,399
routing all have different interfaces

00:18:47,269 --> 00:18:51,289
they're all separate things you can't

00:18:49,399 --> 00:18:53,419
layer them in different ways you can't

00:18:51,289 --> 00:18:56,809
have URL routing depend on something

00:18:53,419 --> 00:18:58,759
from in a middleware for example and I

00:18:56,809 --> 00:19:00,440
didn't really want this one of the

00:18:58,759 --> 00:19:02,929
things I've wanted in Django for a long

00:19:00,440 --> 00:19:05,809
time is to have those pieces have a very

00:19:02,929 --> 00:19:07,009
similar interface and again one of the

00:19:05,809 --> 00:19:08,570
problems with WSGI

00:19:07,009 --> 00:19:11,480
was it didn't really give you that

00:19:08,570 --> 00:19:13,909
flexibility whereas what we can do in

00:19:11,480 --> 00:19:16,700
channels is we can say oh no we have

00:19:13,909 --> 00:19:20,389
more flexibility in channels you have a

00:19:16,700 --> 00:19:23,509
URL Rooter is just an SGA application

00:19:20,389 --> 00:19:25,759
that takes other applications everything

00:19:23,509 --> 00:19:29,240
from the middle where the consumers to

00:19:25,759 --> 00:19:31,340
the routing it's all just an SEO

00:19:29,240 --> 00:19:33,500
application but doesn't just mean it's

00:19:31,340 --> 00:19:36,320
swappable in Django it means that you

00:19:33,500 --> 00:19:38,179
can put other non Django things above

00:19:36,320 --> 00:19:39,559
and below it one of the things I'm

00:19:38,179 --> 00:19:42,139
trying to encourage that we missed out

00:19:39,559 --> 00:19:44,299
in WSGI because it's slightly late

00:19:42,139 --> 00:19:46,909
adoption is the idea that you can swap

00:19:44,299 --> 00:19:49,190
piece around of frameworks well if I

00:19:46,909 --> 00:19:52,039
want a bit of flask in my Django app in

00:19:49,190 --> 00:19:53,809
channels if and when we get flasks to

00:19:52,039 --> 00:19:56,629
have support for this then you can do

00:19:53,809 --> 00:19:58,340
that kind of stuff and then the question

00:19:56,629 --> 00:20:01,460
really becomes well what does this mean

00:19:58,340 --> 00:20:03,080
for Django I have you know stood here

00:20:01,460 --> 00:20:04,730
and talked about and influenced two

00:20:03,080 --> 00:20:07,309
channels and how you make Django more

00:20:04,730 --> 00:20:09,830
async but all of this is very much

00:20:07,309 --> 00:20:11,990
external channels is a Django project

00:20:09,830 --> 00:20:14,330
but it is still not in the Django core

00:20:11,990 --> 00:20:17,299
repository and so the question really

00:20:14,330 --> 00:20:19,490
becomes well will it become that should

00:20:17,299 --> 00:20:22,039
it become that and this really comes

00:20:19,490 --> 00:20:25,039
down to one question which is how much

00:20:22,039 --> 00:20:26,480
can we make async as I said earlier the

00:20:25,039 --> 00:20:28,700
whole idea is that you want to make

00:20:26,480 --> 00:20:31,760
things asynchronous from the outside in

00:20:28,700 --> 00:20:33,860
you want to progressively turn more and

00:20:31,760 --> 00:20:36,320
more parts of Django into an

00:20:33,860 --> 00:20:39,649
asynchronous capable part of the system

00:20:36,320 --> 00:20:41,630
and because we have those functions let

00:20:39,649 --> 00:20:45,169
us go between asynchronous and

00:20:41,630 --> 00:20:47,809
synchronous worlds what we can do is we

00:20:45,169 --> 00:20:50,510
can in theory slowly replace Django

00:20:47,809 --> 00:20:52,549
piece by piece progressively making more

00:20:50,510 --> 00:20:54,110
and more of asynchronous but still

00:20:52,549 --> 00:20:57,139
keeping full backwards compatibility

00:20:54,110 --> 00:21:00,010
still keeping the old views and

00:20:57,139 --> 00:21:02,360
everything we still use today and

00:21:00,010 --> 00:21:05,269
there's one particular problem with this

00:21:02,360 --> 00:21:06,860
vision and that is the RM you know as

00:21:05,269 --> 00:21:09,049
you heard from Casey the ORM is a very

00:21:06,860 --> 00:21:11,360
complex beast of many different parts

00:21:09,049 --> 00:21:13,279
inside it I've been doing Django for

00:21:11,360 --> 00:21:16,010
over a decade I still don't understand

00:21:13,279 --> 00:21:18,470
all of it and the idea of making

00:21:16,010 --> 00:21:20,840
asynchronous initially seemed very

00:21:18,470 --> 00:21:24,399
difficult a lot of it is built around

00:21:20,840 --> 00:21:28,149
these synchronous database bindings and

00:21:24,399 --> 00:21:30,919
synchronous ways of writing queries and

00:21:28,149 --> 00:21:33,799
at this similar talk at PyCon a few

00:21:30,919 --> 00:21:36,500
weeks ago I was pretty much sure that I

00:21:33,799 --> 00:21:39,049
couldn't do this but talking to people

00:21:36,500 --> 00:21:40,850
since then having the idea I'm now

00:21:39,049 --> 00:21:43,429
pretty sure we could do this there is

00:21:40,850 --> 00:21:45,860
again a way we can slowly make things

00:21:43,429 --> 00:21:48,049
asynchronous the key thing here with a

00:21:45,860 --> 00:21:50,210
project as big as Django is that we

00:21:48,049 --> 00:21:53,090
can't do it all at once there's no way

00:21:50,210 --> 00:21:55,309
we can take Django flip everything

00:21:53,090 --> 00:21:57,380
asynchronous and ship it in one go and

00:21:55,309 --> 00:21:59,090
only is that a huge amount of code and

00:21:57,380 --> 00:22:01,970
maintenance work it's gonna result in

00:21:59,090 --> 00:22:04,789
the huge number of bugs and so any plan

00:22:01,970 --> 00:22:07,279
we have to have has to be iterative has

00:22:04,789 --> 00:22:08,929
to go in small steps let us release it

00:22:07,279 --> 00:22:10,580
over the course of many releases and

00:22:08,929 --> 00:22:13,639
have people feedback how it works

00:22:10,580 --> 00:22:16,070
and with the rme in particular I am now

00:22:13,639 --> 00:22:18,230
convinced we can slowly take the ORM and

00:22:16,070 --> 00:22:19,789
make it more and more synchronous this

00:22:18,230 --> 00:22:21,590
is still a thing I need to write up and

00:22:19,789 --> 00:22:23,810
present the rest of the core team and

00:22:21,590 --> 00:22:25,760
the Django developer community

00:22:23,810 --> 00:22:28,100
but this is one of the things and the

00:22:25,760 --> 00:22:30,230
final pieces for saying maybe we can

00:22:28,100 --> 00:22:32,630
start making Django itself asynchronous

00:22:30,230 --> 00:22:36,380
now you can bring parts of channels back

00:22:32,630 --> 00:22:37,840
into the core if it makes sense and then

00:22:36,380 --> 00:22:40,100
this gets to a bigger picture as well

00:22:37,840 --> 00:22:43,040
there's really a question here off you

00:22:40,100 --> 00:22:46,460
know I'm trying to replace WSGI with an

00:22:43,040 --> 00:22:48,110
SGI standard at PyCon we had a meeting

00:22:46,460 --> 00:22:50,750
of different a few different frameworks

00:22:48,110 --> 00:22:52,790
and servers generally agreed there was a

00:22:50,750 --> 00:22:56,090
need for this and we should do it but

00:22:52,790 --> 00:22:58,160
there still is a question here like you

00:22:56,090 --> 00:22:59,780
don't just replace a standard there's

00:22:58,160 --> 00:23:01,130
the old joke that you have oh well we

00:22:59,780 --> 00:23:02,540
have five standards and none of the

00:23:01,130 --> 00:23:04,910
standards are any good so we're gonna

00:23:02,540 --> 00:23:07,130
invent a new standard and narrator there

00:23:04,910 --> 00:23:08,930
are now six standards like that's the

00:23:07,130 --> 00:23:12,140
problem we face it fragmentation is

00:23:08,930 --> 00:23:14,180
terrible one of the things I really have

00:23:12,140 --> 00:23:17,000
to focus on with SGI is making sure that

00:23:14,180 --> 00:23:18,470
it is backwards compatible there is a

00:23:17,000 --> 00:23:21,590
thing that we actually ship with

00:23:18,470 --> 00:23:25,630
channels that lets you run WSGI

00:23:21,590 --> 00:23:28,490
applications as a SGI applications and

00:23:25,630 --> 00:23:31,190
that's part of it but the other part of

00:23:28,490 --> 00:23:33,020
it is is they're in need we can sure we

00:23:31,190 --> 00:23:35,000
can do the technical work but that's

00:23:33,020 --> 00:23:36,590
only part of the equation part of

00:23:35,000 --> 00:23:38,870
running a framework is making sure that

00:23:36,590 --> 00:23:42,260
you use that your users want your

00:23:38,870 --> 00:23:44,540
changes to migrations when I was in it

00:23:42,260 --> 00:23:46,190
is a feature pretty much everyone needed

00:23:44,540 --> 00:23:48,440
even they didn't they didn't know they

00:23:46,190 --> 00:23:50,960
had to have it WebSockets is much less

00:23:48,440 --> 00:23:53,390
of that thing WebSockets a niche they're

00:23:50,960 --> 00:23:56,300
not a super important part of many

00:23:53,390 --> 00:23:58,490
people's web development process long

00:23:56,300 --> 00:24:01,970
polling is a bit more important but it's

00:23:58,490 --> 00:24:04,100
still much more niche and so there's a

00:24:01,970 --> 00:24:06,770
real question here do we need to replace

00:24:04,100 --> 00:24:08,120
it and one of the things that first

00:24:06,770 --> 00:24:10,580
appears people's like well you should

00:24:08,120 --> 00:24:11,660
obviously take it and write a pet and go

00:24:10,580 --> 00:24:13,370
straight to the Python development

00:24:11,660 --> 00:24:15,290
mailing list and then have them approve

00:24:13,370 --> 00:24:18,110
it the big rubber stamp that's not

00:24:15,290 --> 00:24:19,790
really how things work one of the things

00:24:18,110 --> 00:24:23,360
in the history of WSGI

00:24:19,790 --> 00:24:25,640
is it came about after the fact when I

00:24:23,360 --> 00:24:27,980
started doing Django wsg I wasn't a

00:24:25,640 --> 00:24:30,620
standard it came about in those first

00:24:27,980 --> 00:24:33,260
few years because of the arising in need

00:24:30,620 --> 00:24:36,350
and the work between things at the time

00:24:33,260 --> 00:24:37,190
like Cherry Pie and Django and turbo

00:24:36,350 --> 00:24:39,160
gears there

00:24:37,190 --> 00:24:42,800
all trying to work on a similar solution

00:24:39,160 --> 00:24:44,900
one of the things I think is to have a

00:24:42,800 --> 00:24:47,060
standard working you have to have

00:24:44,900 --> 00:24:49,160
multiple servers implementing it and

00:24:47,060 --> 00:24:53,180
multiple frameworks implementing it as

00:24:49,160 --> 00:24:55,670
well now I am very grateful that not

00:24:53,180 --> 00:24:57,920
just Daphne which is the channel sort of

00:24:55,670 --> 00:24:59,810
built-in shipped with server but also

00:24:57,920 --> 00:25:03,320
Django rest framework

00:24:59,810 --> 00:25:05,510
you've a corn also now has full a SGI

00:25:03,320 --> 00:25:07,610
support so that kind of makes me much

00:25:05,510 --> 00:25:09,800
happier on the server front there's also

00:25:07,610 --> 00:25:12,500
apparently we work in twisted and

00:25:09,800 --> 00:25:13,630
twisted supported natively this then

00:25:12,500 --> 00:25:16,760
leaves hanging multiple frameworks

00:25:13,630 --> 00:25:18,500
Django Shah Django is a big framework we

00:25:16,760 --> 00:25:19,730
are not the only framework in Python we

00:25:18,500 --> 00:25:21,710
had to be friendly and play with

00:25:19,730 --> 00:25:23,270
everyone else and so talking with people

00:25:21,710 --> 00:25:24,830
like pyramid and flask and other

00:25:23,270 --> 00:25:27,080
frameworks to try and make this

00:25:24,830 --> 00:25:30,380
important to try and make this agreed

00:25:27,080 --> 00:25:33,020
upon is important as well and this is

00:25:30,380 --> 00:25:34,670
ongoing in a slow process but in general

00:25:33,020 --> 00:25:37,280
there's pretty good buy-in people seem

00:25:34,670 --> 00:25:39,770
to these days believe there's a need for

00:25:37,280 --> 00:25:42,980
having not just WebSockets but like I

00:25:39,770 --> 00:25:45,290
want to run HTTP things at last long

00:25:42,980 --> 00:25:47,570
time like slow requests or long poles or

00:25:45,290 --> 00:25:52,340
any other number of things that aren't

00:25:47,570 --> 00:25:54,140
WebSockets HTTP and then you get the

00:25:52,340 --> 00:25:57,140
final real question here which is well

00:25:54,140 --> 00:25:59,480
sure we can have Django async we can

00:25:57,140 --> 00:26:03,230
have an async version of WSGI

00:25:59,480 --> 00:26:07,010
we can have the RMB async do we want

00:26:03,230 --> 00:26:09,590
that asynchronous code is difficult it

00:26:07,010 --> 00:26:12,020
is and trust me I've been doing it for

00:26:09,590 --> 00:26:14,810
three or four years now a massive pain

00:26:12,020 --> 00:26:17,840
to debug there are so many more error

00:26:14,810 --> 00:26:19,820
cases and edge cases to handle you can

00:26:17,840 --> 00:26:22,250
make things that silently slow things

00:26:19,820 --> 00:26:23,750
down but don't fail there's a magical

00:26:22,250 --> 00:26:27,050
environment variable in Python you can

00:26:23,750 --> 00:26:28,970
turn called python async code debug it

00:26:27,050 --> 00:26:30,560
will try and find like old this KO

00:26:28,970 --> 00:26:33,530
routine is too slow or you didn't await

00:26:30,560 --> 00:26:35,060
properly here but then the end result is

00:26:33,530 --> 00:26:38,060
it's still difficult you can still miss

00:26:35,060 --> 00:26:40,430
it and await and your code apparently

00:26:38,060 --> 00:26:42,290
works perfectly but in reality is only

00:26:40,430 --> 00:26:46,340
working in a single high routine at once

00:26:42,290 --> 00:26:48,410
and so this is why the channels

00:26:46,340 --> 00:26:49,880
philosophy is to let you write both both

00:26:48,410 --> 00:26:50,990
synchronous and asynchronous are

00:26:49,880 --> 00:26:52,820
important

00:26:50,990 --> 00:26:55,400
any plan I think we should outline for

00:26:52,820 --> 00:26:57,830
the future should have both I want to

00:26:55,400 --> 00:27:00,500
keep the ability to have that nice easy

00:26:57,830 --> 00:27:03,170
synchronous interface for most of the

00:27:00,500 --> 00:27:05,960
work you do and then when you need it

00:27:03,170 --> 00:27:08,120
this is Django strength when you need to

00:27:05,960 --> 00:27:10,640
go deeper when you need more complexity

00:27:08,120 --> 00:27:13,040
Django can then open up and let you into

00:27:10,640 --> 00:27:14,809
that deeper section and say okay you

00:27:13,040 --> 00:27:16,220
asked for it there's now like you have

00:27:14,809 --> 00:27:18,170
much more control over the requests you

00:27:16,220 --> 00:27:21,530
have asynchronous code now and it's

00:27:18,170 --> 00:27:24,770
there and ultimately the big question

00:27:21,530 --> 00:27:28,250
here is you know what is Django channels

00:27:24,770 --> 00:27:29,809
is a project done by a much smaller

00:27:28,250 --> 00:27:31,720
number of people than core Django it's

00:27:29,809 --> 00:27:33,679
me and a few other contributors and

00:27:31,720 --> 00:27:36,080
compare it to Django is sometimes

00:27:33,679 --> 00:27:38,780
difficult like should Django be doing

00:27:36,080 --> 00:27:40,040
this what is Django's goal is there like

00:27:38,780 --> 00:27:41,540
we don't have a mission statement or

00:27:40,040 --> 00:27:43,790
things like court or things like that

00:27:41,540 --> 00:27:47,570
and ultimately the question is like

00:27:43,790 --> 00:27:48,640
should we be taking Django and adding

00:27:47,570 --> 00:27:50,690
this stuff into which we would be

00:27:48,640 --> 00:27:53,450
preparing Django for this new

00:27:50,690 --> 00:27:55,250
asynchronous wave and it's a lot of work

00:27:53,450 --> 00:27:57,530
we're gonna have to if we're gonna make

00:27:55,250 --> 00:27:59,840
the ORM asynchronous sit down to a lot

00:27:57,530 --> 00:28:01,250
of nasty testing and rewriting and

00:27:59,840 --> 00:28:01,670
thread pooling and all the things like

00:28:01,250 --> 00:28:03,380
that

00:28:01,670 --> 00:28:05,750
I personally believe it's that that's

00:28:03,380 --> 00:28:08,720
the case but my word is not the word of

00:28:05,750 --> 00:28:09,980
the Django core team and I think it's

00:28:08,720 --> 00:28:12,830
one of discussions to have but

00:28:09,980 --> 00:28:15,470
ultimately Django is not just asked but

00:28:12,830 --> 00:28:17,840
all of you as well and so I encourage

00:28:15,470 --> 00:28:20,000
you to you know come and talk to me and

00:28:17,840 --> 00:28:21,559
other core team members come and talk up

00:28:20,000 --> 00:28:23,240
the sprints about this stuff and like I

00:28:21,559 --> 00:28:25,040
really ought to know about what you

00:28:23,240 --> 00:28:27,230
think Django is where we should be going

00:28:25,040 --> 00:28:29,990
and if these kind of changes are

00:28:27,230 --> 00:28:31,940
important to you and with that thank you

00:28:29,990 --> 00:28:37,539
very much

00:28:31,940 --> 00:28:37,539
[Music]

00:28:39,320 --> 00:28:41,380

YouTube URL: https://www.youtube.com/watch?v=qSsM97u-Cc8


