Title: DjangoCon 2018 - Representing Hierarchies in Relational Databases
Publication date: 2018-05-23
Playlist: DjangoCon Europe 2018 in Heidelberg
Description: 
	https://media.ccc.de/v/hd-29-representing-hierarchies-in-relational-databases



In this talk, I’ll explain the fundamental problem representing deep hierarchies in relational databases. To address this problem, we can use a database design pattern, named Materialized Path Trees.

Many data structures require a representation, where one parent node can have any arbitrary number of children. Inside relational databases, this typically is represented by a foreign key onto its own table. In Django’s ORM, we use ``models.ForeignKey('self', ...)``, to create this kind of recursive relationship.
The major problem with this kind of representation is, that it doesn’t scale for deep trees. Whenever we have to traverse the tree from a given starting node, our code has to perform one database query per hierarchy level.
To circumvent this, some database vendors implemented SQL dialects, to fetch a whole subtree with one query. Long time ago, Oracle for instance implemented 'CONNECT BY', which is proprietary and not part of the SQL standard. Nowadays, newer releases of most major database vendors implemented the 'WITH RECURSIVE' clause, which has been added to the SQL-99 standard. This allows us to build recursive queries.

Fortunately there is a clever recipe to represent hierarchies in relational databases using standard SQL techniques, but without the mentioned scaling problem: Materialized Path Trees, discovered by Vadim Tropashko. Django’s ecosystem offers two libraries, which implement this design pattern: **django-mptt** and **django-treebeard**. I also would like to mention **django-tree**, which only works on Postgres, using their SQL extension mentioned before.
In this talk I’ll explain the design patterns for Materialized Path Trees. Furthermore I’ll show the pros and cons of both libraries.

Jacob Rief
Captions: 
	00:00:06,690 --> 00:00:10,830
Jacob has

00:00:11,890 --> 00:00:20,920
um yeah I know what I'm doing um

00:00:18,450 --> 00:00:23,310
relational databases and stuff so let's

00:00:20,920 --> 00:00:23,310
give him a hand

00:00:25,130 --> 00:00:28,260
[Music]

00:00:28,919 --> 00:00:33,070
hello okay

00:00:31,119 --> 00:00:35,800
welcome to my talk about representing

00:00:33,070 --> 00:00:38,230
trees in databases and many thanks to

00:00:35,800 --> 00:00:42,760
the organizers to bring jancker con

00:00:38,230 --> 00:00:46,930
Europe to this wonderful location hi I'm

00:00:42,760 --> 00:00:52,329
Jacob in 1997 I use Python for the first

00:00:46,930 --> 00:00:54,760
time and in 2011 I switched to Django

00:00:52,329 --> 00:00:58,149
and since then I never looked back and I

00:00:54,760 --> 00:01:00,910
only use Django for web development I

00:00:58,149 --> 00:01:03,690
must admit that I contributed almost

00:01:00,910 --> 00:01:06,520
nothing to the Django framework itself

00:01:03,690 --> 00:01:12,640
instead I'm maintaining a few popular

00:01:06,520 --> 00:01:15,100
search party django apps for instance

00:01:12,640 --> 00:01:18,640
django shop that's an ecommerce

00:01:15,100 --> 00:01:23,350
framework based on Django CMS Django

00:01:18,640 --> 00:01:26,140
angular on dry Django Con 2014 I give a

00:01:23,350 --> 00:01:30,369
talk on how giant angularjs plays nice

00:01:26,140 --> 00:01:32,799
with django Django CMS cascade that's a

00:01:30,369 --> 00:01:36,610
full-featured plug-in system for Django

00:01:32,799 --> 00:01:39,880
CMS django WebSocket Redis a WebSocket

00:01:36,610 --> 00:01:44,560
library for Django written in 2013

00:01:39,880 --> 00:01:47,469
before channels was available Django

00:01:44,560 --> 00:01:49,899
admin suitable to a had sorting

00:01:47,469 --> 00:01:54,520
capabilities to list views in the Django

00:01:49,899 --> 00:01:58,119
admin Django sauce processor reference

00:01:54,520 --> 00:02:04,509
for your sauce your s CSS files directly

00:01:58,119 --> 00:02:08,940
from Django templates and Python code in

00:02:04,509 --> 00:02:12,460
late 2016 on Django under the hood I

00:02:08,940 --> 00:02:17,980
inherited together with Jacopo and

00:02:12,460 --> 00:02:21,160
others Django Treebeard from the den

00:02:17,980 --> 00:02:23,260
maintainer Gustavo pecan and having to

00:02:21,160 --> 00:02:24,360
maintain that library inspired me to

00:02:23,260 --> 00:02:29,160
give this

00:02:24,360 --> 00:02:32,130
here I'm working as a freelance software

00:02:29,160 --> 00:02:36,900
developer and live in Innsbruck in

00:02:32,130 --> 00:02:40,560
Austria so what's our problem and what

00:02:36,900 --> 00:02:43,080
we do we try to solve say we have a

00:02:40,560 --> 00:02:45,630
grocery store with a bunch of products

00:02:43,080 --> 00:02:47,270
organized in different categories and

00:02:45,630 --> 00:02:50,640
sub-categories

00:02:47,270 --> 00:02:54,240
and just as in the virtual world where

00:02:50,640 --> 00:02:58,560
we use database tables and model to

00:02:54,240 --> 00:03:01,980
model products and categories in django

00:02:58,560 --> 00:03:04,980
we use a model entity to describe each

00:03:01,980 --> 00:03:08,130
category these model entities then are

00:03:04,980 --> 00:03:11,340
grouped into a tree

00:03:08,130 --> 00:03:13,350
whenever we have to render a list view

00:03:11,340 --> 00:03:16,980
of our products belonging to say

00:03:13,350 --> 00:03:22,170
category meat we need to know its

00:03:16,980 --> 00:03:25,350
subcategories or when we want to render

00:03:22,170 --> 00:03:28,350
the breadcrumbs for category turkeys we

00:03:25,350 --> 00:03:30,780
need to know their ancestors when

00:03:28,350 --> 00:03:33,269
building a database model it turns out

00:03:30,780 --> 00:03:36,000
that the most obvious solution is not

00:03:33,269 --> 00:03:38,430
always the best in this presentation I

00:03:36,000 --> 00:03:43,220
will show four different solutions to

00:03:38,430 --> 00:03:47,040
solve this problem where else do we use

00:03:43,220 --> 00:03:49,799
hierarchical representations in content

00:03:47,040 --> 00:03:54,470
management systems to organize pages and

00:03:49,799 --> 00:03:57,870
nested content hierarchies incorporates

00:03:54,470 --> 00:04:03,209
for discussion threads for emulating

00:03:57,870 --> 00:04:06,540
folders and many more so solution one is

00:04:03,209 --> 00:04:08,370
the adjacent lists that's the most

00:04:06,540 --> 00:04:11,549
natural representation of a tree in a

00:04:08,370 --> 00:04:14,580
database is to have a foreign key

00:04:11,549 --> 00:04:16,739
pointing to its parent node here the

00:04:14,580 --> 00:04:21,120
numbers in the nodes represent their

00:04:16,739 --> 00:04:25,650
primary keys as Django model it looks

00:04:21,120 --> 00:04:28,110
like this we add inaudible foreign key

00:04:25,650 --> 00:04:31,560
pointing on to self this creates a

00:04:28,110 --> 00:04:36,900
recursive relationship this statesman

00:04:31,560 --> 00:04:38,129
shows the simplified transition of our

00:04:36,900 --> 00:04:40,559
Django model in

00:04:38,129 --> 00:04:42,749
database schema and this kind of

00:04:40,559 --> 00:04:47,279
representation commonly is known as the

00:04:42,749 --> 00:04:50,129
adjacent list sequel pattern a common

00:04:47,279 --> 00:04:53,489
use case is to find all notes below a

00:04:50,129 --> 00:04:55,830
given note in this example we look for

00:04:53,489 --> 00:05:00,599
the descendants of the highlighted note

00:04:55,830 --> 00:05:02,879
a pison function to get to this its

00:05:00,599 --> 00:05:06,179
descendants might be implemented such as

00:05:02,879 --> 00:05:08,849
this first we create a career set for

00:05:06,179 --> 00:05:12,240
all immediate children then we

00:05:08,849 --> 00:05:15,119
recursively call that function for

00:05:12,240 --> 00:05:17,009
overall children in that query set here

00:05:15,119 --> 00:05:21,089
the problem is that traversing the tree

00:05:17,009 --> 00:05:23,789
scales really badly we need one database

00:05:21,089 --> 00:05:25,679
query for each depth level this adds

00:05:23,789 --> 00:05:28,019
many round trips between the database

00:05:25,679 --> 00:05:30,899
and our drank application and we get an

00:05:28,019 --> 00:05:35,039
iterator instead of a query set losing

00:05:30,899 --> 00:05:37,379
all the useful methods on that class an

00:05:35,039 --> 00:05:41,550
alternative would be to to do the

00:05:37,379 --> 00:05:45,389
recursive join over all the nodes the

00:05:41,550 --> 00:05:48,029
sequel statement for such a query might

00:05:45,389 --> 00:05:49,769
look like this since we don't know the

00:05:48,029 --> 00:05:51,779
depths of the tree building such a

00:05:49,769 --> 00:05:54,089
statement in a generic way is nearly

00:05:51,779 --> 00:05:56,369
impossible and results are grouped by

00:05:54,089 --> 00:06:00,479
columns rather than by rows so that's

00:05:56,369 --> 00:06:03,329
not a very good option ascending the

00:06:00,479 --> 00:06:06,300
tree is a bit simpler here we look for

00:06:03,329 --> 00:06:08,490
the ancestor of the highlighted node but

00:06:06,300 --> 00:06:10,769
we still have to do a recursion on the

00:06:08,490 --> 00:06:15,179
function get ancestors with four

00:06:10,769 --> 00:06:17,339
separate queries to the database here we

00:06:15,179 --> 00:06:20,159
also use the chain keyword to build our

00:06:17,339 --> 00:06:23,009
result set but again we return an

00:06:20,159 --> 00:06:25,559
iterator instead of a query set losing

00:06:23,009 --> 00:06:27,259
all the useful method on the methods

00:06:25,559 --> 00:06:30,449
under Clause

00:06:27,259 --> 00:06:33,689
another problem is attribute filtering

00:06:30,449 --> 00:06:38,159
say our notes are colored and we want to

00:06:33,689 --> 00:06:42,389
find the red ones if we change the code

00:06:38,159 --> 00:06:47,399
to filter by color we would miss out the

00:06:42,389 --> 00:06:49,169
node with the ID 16 therefore we must do

00:06:47,399 --> 00:06:51,240
the filtering by the application and

00:06:49,169 --> 00:06:51,780
thus this means that we first have to

00:06:51,240 --> 00:06:54,540
fetch

00:06:51,780 --> 00:06:57,810
notes from the database and afterwards

00:06:54,540 --> 00:07:00,330
we can apply the filter in Python but

00:06:57,810 --> 00:07:04,230
that causes a lot of unnecessary data

00:07:00,330 --> 00:07:06,930
transfer therefore some engineers have

00:07:04,230 --> 00:07:09,480
looked for alternative solutions for

00:07:06,930 --> 00:07:14,820
instance the materialized path tree was

00:07:09,480 --> 00:07:18,810
described by Vadim Tabasco in sequel

00:07:14,820 --> 00:07:21,630
design patterns and published in 2006 in

00:07:18,810 --> 00:07:24,410
the materialized path tree we encode the

00:07:21,630 --> 00:07:27,390
position of each node inside a car field

00:07:24,410 --> 00:07:30,750
for each depth level we used the verts

00:07:27,390 --> 00:07:34,080
with a fixed step length the root node

00:07:30,750 --> 00:07:36,930
starts with a - its first child we

00:07:34,080 --> 00:07:42,330
append another a giving a a for its

00:07:36,930 --> 00:07:47,130
sibling we use a B for its next child

00:07:42,330 --> 00:07:50,520
uses a B a and its sibling a BB and so

00:07:47,130 --> 00:07:52,620
on this materialized pass is applied to

00:07:50,520 --> 00:07:54,840
all nodes of the tree if you have

00:07:52,620 --> 00:07:57,540
multiple trees the pass field on the

00:07:54,840 --> 00:08:00,150
root note of the second tree starts with

00:07:57,540 --> 00:08:06,830
a B therefore we can have multiple

00:08:00,150 --> 00:08:09,900
routes multiple trees with one root each

00:08:06,830 --> 00:08:13,590
here we create a Jenga model for our

00:08:09,900 --> 00:08:20,669
node instead of a foreign key onto self

00:08:13,590 --> 00:08:23,820
we use an index car field named path in

00:08:20,669 --> 00:08:27,450
that field we store an encoded position

00:08:23,820 --> 00:08:30,600
of our note inside the tree by default

00:08:27,450 --> 00:08:32,460
Django Treebeard uses a step length of

00:08:30,600 --> 00:08:35,219
four with an alphabet of Sergey six

00:08:32,460 --> 00:08:38,490
characters this allows each node to have

00:08:35,219 --> 00:08:42,539
a maximum of about 1.6 million immediate

00:08:38,490 --> 00:08:44,550
children but in the next slide for

00:08:42,539 --> 00:08:49,980
simplicity I use a step length of one

00:08:44,550 --> 00:08:53,370
with an alphabet of 26 characters so

00:08:49,980 --> 00:08:55,250
here are examples we want to find all

00:08:53,370 --> 00:09:01,800
the ascendance of the highlighted note

00:08:55,250 --> 00:09:03,900
the pass field contains the word AAA so

00:09:01,800 --> 00:09:06,000
we look for all notes starting with that

00:09:03,900 --> 00:09:09,860
pattern

00:09:06,000 --> 00:09:14,100
this Python function returns a query set

00:09:09,860 --> 00:09:16,260
for all the descendants here we use the

00:09:14,100 --> 00:09:18,990
starts with restriction on the query

00:09:16,260 --> 00:09:21,360
filter this makes use of the database

00:09:18,990 --> 00:09:25,310
index on the pass field therefore we

00:09:21,360 --> 00:09:28,470
have a fast query to fetch the subtree

00:09:25,310 --> 00:09:33,600
we also want to exclude the starting

00:09:28,470 --> 00:09:37,470
node from the query set and this is a

00:09:33,600 --> 00:09:39,540
simplified sequel statement it uses the

00:09:37,470 --> 00:09:39,810
like clause with the percent sign at the

00:09:39,540 --> 00:09:42,240
end

00:09:39,810 --> 00:09:44,190
therefore the text index works in the

00:09:42,240 --> 00:09:46,620
database acts as expected

00:09:44,190 --> 00:09:49,500
remember beginning the like clause with

00:09:46,620 --> 00:09:52,350
a person sign would require a full table

00:09:49,500 --> 00:09:56,400
scan but so the database index still

00:09:52,350 --> 00:09:59,550
works if you create your own tree model

00:09:56,400 --> 00:10:02,070
use an alphabet with consistent sorting

00:09:59,550 --> 00:10:06,120
order and check the relations of your

00:10:02,070 --> 00:10:07,650
database you'd have utf-8 characters in

00:10:06,120 --> 00:10:09,990
your alphabet are not a good choice

00:10:07,650 --> 00:10:12,900
because depending on your database

00:10:09,990 --> 00:10:17,220
settings and language settings they may

00:10:12,900 --> 00:10:19,140
have different sorting orders with this

00:10:17,220 --> 00:10:24,660
short addition to the code we can return

00:10:19,140 --> 00:10:26,850
the query set ordered by depths level we

00:10:24,660 --> 00:10:30,690
want to traverse the tree from the

00:10:26,850 --> 00:10:35,870
highlighted node upwards again we use

00:10:30,690 --> 00:10:40,530
the pass field here it's divert AAA CA

00:10:35,870 --> 00:10:42,660
by removing the letters from the end of

00:10:40,530 --> 00:10:48,140
the word we can build a list of ancestor

00:10:42,660 --> 00:10:49,590
pass values in our example eh-eh-eh-eh

00:10:48,140 --> 00:10:53,310
eh-eh-eh-eh

00:10:49,590 --> 00:10:55,020
and finally our root note a now it's

00:10:53,310 --> 00:10:57,300
just a simple lookup to find the

00:10:55,020 --> 00:11:02,790
ancestor nodes we just have to check if

00:10:57,300 --> 00:11:05,460
the path attribute is in that list this

00:11:02,790 --> 00:11:10,260
time we return the query set ordered by

00:11:05,460 --> 00:11:11,760
tree level from the bottom to top nested

00:11:10,260 --> 00:11:14,910
sets tree is another approach for

00:11:11,760 --> 00:11:17,430
solving our tree problem it and it has

00:11:14,910 --> 00:11:18,340
been described by Joe Chalco in trees

00:11:17,430 --> 00:11:20,650
and hurricanes

00:11:18,340 --> 00:11:25,779
in sequel for Smarties and published in

00:11:20,650 --> 00:11:27,970
2012 the idea between us the sets is to

00:11:25,779 --> 00:11:30,940
create an envelope over the over the

00:11:27,970 --> 00:11:33,580
tree each node has two integer fields

00:11:30,940 --> 00:11:36,520
left and right they both follow this

00:11:33,580 --> 00:11:39,310
rule for each note left is smaller than

00:11:36,520 --> 00:11:41,230
all descendants of the given node right

00:11:39,310 --> 00:11:46,089
is greater than all descendants of a

00:11:41,230 --> 00:11:48,490
given node we can draw a graph

00:11:46,089 --> 00:11:51,250
connecting these numbers together then

00:11:48,490 --> 00:11:53,350
this graph cuts each notes twice the

00:11:51,250 --> 00:11:56,170
first time while descending and the

00:11:53,350 --> 00:11:58,000
second time while ascending except for

00:11:56,170 --> 00:12:00,130
leaf nodes they always have consecutive

00:11:58,000 --> 00:12:05,620
numbers for the left and right values

00:12:00,130 --> 00:12:07,720
here for instance 16 and 17 using these

00:12:05,620 --> 00:12:10,029
two numbers we can traverse the tree in

00:12:07,720 --> 00:12:13,870
both directions with one single database

00:12:10,029 --> 00:12:17,730
query in django we add two positive

00:12:13,870 --> 00:12:20,560
integer fields to our nested sets model

00:12:17,730 --> 00:12:25,600
remember left and right are not foreign

00:12:20,560 --> 00:12:28,270
keys but your indexed and seized since

00:12:25,600 --> 00:12:33,850
these numbers are used a lot in our

00:12:28,270 --> 00:12:36,100
queries we add a database index so we

00:12:33,850 --> 00:12:39,820
want to find all the ascendance of the

00:12:36,100 --> 00:12:42,550
highlighted note first we take the left

00:12:39,820 --> 00:12:45,280
and the right value of that node we know

00:12:42,550 --> 00:12:48,550
that both values for left and right of

00:12:45,280 --> 00:12:53,200
all descendants lie between those two

00:12:48,550 --> 00:12:55,720
numbers between 3 and 20 to this simple

00:12:53,200 --> 00:13:01,110
pricing function returns a query set of

00:12:55,720 --> 00:13:04,450
all descendants first we construct a

00:13:01,110 --> 00:13:08,860
range query this filters out the whole

00:13:04,450 --> 00:13:11,650
subtree of our node finally we exclude

00:13:08,860 --> 00:13:15,279
the node from the query since we are

00:13:11,650 --> 00:13:19,440
interested only in the subtree and again

00:13:15,279 --> 00:13:19,440
we get a query set as expected

00:13:19,450 --> 00:13:25,060
this time however unordered by depth for

00:13:22,870 --> 00:13:29,270
completeness this is the simplified

00:13:25,060 --> 00:13:32,100
sequel statement for that query

00:13:29,270 --> 00:13:36,390
we want to find the ancestors of the

00:13:32,100 --> 00:13:39,450
highlighted node first we check the left

00:13:36,390 --> 00:13:42,390
and right values of that node we know

00:13:39,450 --> 00:13:45,060
that the left value of all ancestors

00:13:42,390 --> 00:13:48,690
must be smaller than our notes left

00:13:45,060 --> 00:13:51,030
value we also know that the right value

00:13:48,690 --> 00:13:54,420
of our ancestors must be greater than

00:13:51,030 --> 00:13:56,670
our notes right value this Python

00:13:54,420 --> 00:13:59,970
function returns a query set of all

00:13:56,670 --> 00:14:02,730
ancestors with these two values we can

00:13:59,970 --> 00:14:08,610
narrow down the query using a simple

00:14:02,730 --> 00:14:12,510
comparison and again we get the expected

00:14:08,610 --> 00:14:15,930
query set for ordering we could either

00:14:12,510 --> 00:14:19,470
use the left or right value and here for

00:14:15,930 --> 00:14:22,860
completeness check the sequel statement

00:14:19,470 --> 00:14:29,460
for that query simplified sequels

00:14:22,860 --> 00:14:29,970
statement so adding a note to a nested

00:14:29,460 --> 00:14:32,300
sets

00:14:29,970 --> 00:14:35,220
tree is a little bit more complicated

00:14:32,300 --> 00:14:38,940
say we want to add a new node just

00:14:35,220 --> 00:14:44,610
between below dehy below the highlighted

00:14:38,940 --> 00:14:48,390
node this Python function inserts a

00:14:44,610 --> 00:14:50,670
child node into our tree first we filter

00:14:48,390 --> 00:14:54,720
out the nodes which will be affected by

00:14:50,670 --> 00:14:56,790
the update then we conditionally update

00:14:54,720 --> 00:14:59,430
the left values depending on their

00:14:56,790 --> 00:15:03,210
position the right value is always

00:14:59,430 --> 00:15:05,580
increased by two now that we updated the

00:15:03,210 --> 00:15:10,140
right part of the tree we can use the

00:15:05,580 --> 00:15:12,650
two frite values for left and right the

00:15:10,140 --> 00:15:15,390
new node now becomes part of the tree

00:15:12,650 --> 00:15:22,470
deleting a node is a similar operation

00:15:15,390 --> 00:15:24,570
with opposite deltas solution for common

00:15:22,470 --> 00:15:28,380
table expressions have been introduced

00:15:24,570 --> 00:15:31,110
into the NC sequel 99 standard and are

00:15:28,380 --> 00:15:34,530
now supported by all major databases

00:15:31,110 --> 00:15:37,740
systems in my sequel since version 8 in

00:15:34,530 --> 00:15:40,860
moriah DB since version 10.2 point to

00:15:37,740 --> 00:15:41,970
the sequel Lite since three point eight

00:15:40,860 --> 00:15:46,259
point three and

00:15:41,970 --> 00:15:48,750
Kress since 8.4 common table expressions

00:15:46,259 --> 00:15:51,269
are used to simplify complex joins and

00:15:48,750 --> 00:15:54,500
sub queries and to provide a means to

00:15:51,269 --> 00:15:59,550
query hierarchical data

00:15:54,500 --> 00:16:02,689
here's a working sequel statement first

00:15:59,550 --> 00:16:06,389
we define a virtual table called tree

00:16:02,689 --> 00:16:09,360
this sequel finds our starting node and

00:16:06,389 --> 00:16:11,970
initializes the recursive function this

00:16:09,360 --> 00:16:14,790
part recursively fetches the descendants

00:16:11,970 --> 00:16:17,100
of our starting node the last sequel

00:16:14,790 --> 00:16:21,600
statement fetches all descendants of the

00:16:17,100 --> 00:16:23,970
node with ID for excluding itself if you

00:16:21,600 --> 00:16:26,069
have duplicates removed y'all but this

00:16:23,970 --> 00:16:29,910
requires extra time for sorting source

00:16:26,069 --> 00:16:32,339
or leave it out by default remember

00:16:29,910 --> 00:16:34,769
don't put the semicolon after the wizard

00:16:32,339 --> 00:16:39,149
current clause otherwise our virtual

00:16:34,769 --> 00:16:41,639
table tree is not available anymore with

00:16:39,149 --> 00:16:44,310
this query we can use the adjacent list

00:16:41,639 --> 00:16:47,339
pattern to fetch all descendants with

00:16:44,310 --> 00:16:49,649
one single query the tree still Traverse

00:16:47,339 --> 00:16:52,199
recursively but this time inside the

00:16:49,649 --> 00:16:54,480
database and that's much faster because

00:16:52,199 --> 00:16:58,350
we have only one round trip from our

00:16:54,480 --> 00:17:01,110
application to the database to fetch the

00:16:58,350 --> 00:17:05,010
ancestors of a given starting node we

00:17:01,110 --> 00:17:08,309
just have to reverse the condition to my

00:17:05,010 --> 00:17:10,439
knowledge the Django or M currently does

00:17:08,309 --> 00:17:13,409
not offer any functions to implement

00:17:10,439 --> 00:17:16,110
common table expressions so if we want

00:17:13,409 --> 00:17:21,000
to use this database feature we have to

00:17:16,110 --> 00:17:24,679
use raw sequel now let's compare the

00:17:21,000 --> 00:17:27,990
different solutions the adjacent lists

00:17:24,679 --> 00:17:33,210
without common table expressions shines

00:17:27,990 --> 00:17:34,340
for all operations except for tree

00:17:33,210 --> 00:17:37,500
traversal

00:17:34,340 --> 00:17:41,669
however this is the operation we usually

00:17:37,500 --> 00:17:44,909
use most it only requires one additional

00:17:41,669 --> 00:17:47,010
field pointing on on to the parent node

00:17:44,909 --> 00:17:49,799
therefore we don't have any size

00:17:47,010 --> 00:17:52,470
limitations if you need multiple roots

00:17:49,799 --> 00:17:55,440
and sibling ordering you need to you

00:17:52,470 --> 00:17:58,230
need extra fields in your database model

00:17:55,440 --> 00:18:01,140
the materialized path tree is a good

00:17:58,230 --> 00:18:03,570
compromise for all operations the path

00:18:01,140 --> 00:18:06,330
field has the nice side effect that we

00:18:03,570 --> 00:18:09,090
don't need an extra fields for multiple

00:18:06,330 --> 00:18:11,640
routes or sibling ordering depending on

00:18:09,090 --> 00:18:15,080
the alphabet and step lengths the size

00:18:11,640 --> 00:18:17,820
of the tree then is naturally limited

00:18:15,080 --> 00:18:20,370
strings and the path field can become

00:18:17,820 --> 00:18:23,130
very long in addition we have to create

00:18:20,370 --> 00:18:26,940
a text index this requires a lot of

00:18:23,130 --> 00:18:28,500
extra memory nested sets pattern is

00:18:26,940 --> 00:18:31,290
another interesting approach and

00:18:28,500 --> 00:18:32,270
commonly used treat reversals are very

00:18:31,290 --> 00:18:35,340
fast

00:18:32,270 --> 00:18:37,680
however when adding or deleting a note

00:18:35,340 --> 00:18:40,920
we must update big parts of the tree if

00:18:37,680 --> 00:18:45,440
you get one of the left or right numbers

00:18:40,920 --> 00:18:45,440
wrong your complete tree is screwed up

00:18:48,770 --> 00:18:53,550
by using common table expressions in

00:18:51,450 --> 00:18:56,610
adjacent lists the problem of slow tree

00:18:53,550 --> 00:18:58,620
traversal is solved therefore in my

00:18:56,610 --> 00:19:00,470
opinion this is the best choice it

00:18:58,620 --> 00:19:03,480
should be used whenever possible

00:19:00,470 --> 00:19:06,810
computing the depth now depths of a node

00:19:03,480 --> 00:19:08,520
can be integrated into the recursive

00:19:06,810 --> 00:19:13,830
sequence statement while fetching the

00:19:08,520 --> 00:19:16,380
tree so let's compare three libraries

00:19:13,830 --> 00:19:20,850
which are available to solve the tree

00:19:16,380 --> 00:19:23,010
problem Jango M PTT is the most well

00:19:20,850 --> 00:19:26,730
known library it implements the nested

00:19:23,010 --> 00:19:30,170
sets tree pattern but identifies itself

00:19:26,730 --> 00:19:34,910
as as modified pre-order tree traversal

00:19:30,170 --> 00:19:37,410
therefore M PTT Jango tree Bert

00:19:34,910 --> 00:19:39,750
implements the first three sequel

00:19:37,410 --> 00:19:42,170
pattern I've shown the adjacent lists

00:19:39,750 --> 00:19:47,130
without common table expressions

00:19:42,170 --> 00:19:49,860
materialized paths and nested sets they

00:19:47,130 --> 00:19:51,780
all share the same API to manipulate the

00:19:49,860 --> 00:19:55,440
tree so it's easy to exchange one

00:19:51,780 --> 00:19:58,380
against the other and Jango tree is the

00:19:55,440 --> 00:20:01,200
newest player of Jango apps to solve

00:19:58,380 --> 00:20:03,260
this problem it's by the way the only

00:20:01,200 --> 00:20:07,320
one using common table expressions

00:20:03,260 --> 00:20:08,850
however it declares itself as alpha and

00:20:07,320 --> 00:20:12,090
only supports

00:20:08,850 --> 00:20:14,880
as the database therefore if your app

00:20:12,090 --> 00:20:18,809
shall be uh Nepean ated to any databases

00:20:14,880 --> 00:20:23,639
that's not an option for you a side note

00:20:18,809 --> 00:20:26,299
in Django CMS version 3.1 Django MPT T

00:20:23,639 --> 00:20:32,009
has been replaced by Django Treebeard

00:20:26,299 --> 00:20:34,679
their release notes States site over the

00:20:32,009 --> 00:20:37,049
years MPEG has proven not to be fast

00:20:34,679 --> 00:20:39,450
enough for big tree operations with more

00:20:37,049 --> 00:20:41,730
than thousand notes tree corruption

00:20:39,450 --> 00:20:45,240
because of transactional errors has also

00:20:41,730 --> 00:20:47,940
been a problem in further Django

00:20:45,240 --> 00:20:50,429
Treebeard should make working with and

00:20:47,940 --> 00:20:55,049
using Django CMS better faster and

00:20:50,429 --> 00:20:59,580
reliable and for instance the other big

00:20:55,049 --> 00:21:02,399
CMS wagtail and Django Oscar they both

00:20:59,580 --> 00:21:06,210
use Django Treebeard to manage their

00:21:02,399 --> 00:21:10,200
internal trees so what I would like to

00:21:06,210 --> 00:21:12,960
see in the future at commentating the

00:21:10,200 --> 00:21:16,679
table expressions support directly into

00:21:12,960 --> 00:21:23,360
the jungle or M there is an issue it's

00:21:16,679 --> 00:21:27,710
28 919 is a proposal for this but it's

00:21:23,360 --> 00:21:31,049
no decisions have taken be taken yet and

00:21:27,710 --> 00:21:33,899
if realized implement a tree library

00:21:31,049 --> 00:21:36,899
similar to those three which already

00:21:33,899 --> 00:21:38,970
exist and if you're working on a project

00:21:36,899 --> 00:21:41,149
which requires a modern tree

00:21:38,970 --> 00:21:46,970
implementation for your Django project

00:21:41,149 --> 00:21:46,970
please contact me any questions

00:21:54,460 --> 00:21:58,580
we will take questions in the form of a

00:21:56,809 --> 00:22:04,730
question at the microphone if anyone has

00:21:58,580 --> 00:22:09,350
any questions no one no questions

00:22:04,730 --> 00:22:12,770
will you take questions later oh hi

00:22:09,350 --> 00:22:15,620
Russell as one of you go over the

00:22:12,770 --> 00:22:19,490
indexing requirements on on the those

00:22:15,620 --> 00:22:23,809
forms of the tree again so it is it's

00:22:19,490 --> 00:22:25,970
just a matter of text indexing the the

00:22:23,809 --> 00:22:29,360
past realized path and an integer

00:22:25,970 --> 00:22:31,370
indexing the the left or right right so

00:22:29,360 --> 00:22:33,320
is that all you need is everything you

00:22:31,370 --> 00:22:34,460
need okay here you get all the

00:22:33,320 --> 00:22:36,200
performance benefits you don't actually

00:22:34,460 --> 00:22:38,120
need to do anything special on those

00:22:36,200 --> 00:22:40,520
indexes beyond them doing basic integer

00:22:38,120 --> 00:22:42,350
basic string indexing well if you have

00:22:40,520 --> 00:22:45,080
if you have special database

00:22:42,350 --> 00:22:48,530
requirements maybe but those libraries

00:22:45,080 --> 00:22:53,350
they just use the normal normal in the

00:22:48,530 --> 00:23:02,090
indexes which are available sure okay so

00:22:53,350 --> 00:23:04,340
anybody else so in your research did you

00:23:02,090 --> 00:23:08,299
not find any implementations of a

00:23:04,340 --> 00:23:10,309
closure table sorry in your research did

00:23:08,299 --> 00:23:12,169
you not find any implementations of a

00:23:10,309 --> 00:23:17,690
closure table for Jengo that's another

00:23:12,169 --> 00:23:20,690
form of doing trees no that's some I

00:23:17,690 --> 00:23:25,400
somehow missed out okay it's just

00:23:20,690 --> 00:23:29,169
curious why yep yeah okay because all

00:23:25,400 --> 00:23:33,559
the libraries I was using was they

00:23:29,169 --> 00:23:36,049
either used MPT tea or Qi Bert and I

00:23:33,559 --> 00:23:38,330
never encountered any requirements for

00:23:36,049 --> 00:23:43,850
that for that django application so

00:23:38,330 --> 00:23:48,470
sorry about that but you mentioned the

00:23:43,850 --> 00:23:51,559
need of extra memory for querying with

00:23:48,470 --> 00:23:53,750
django Trabert like the text field that

00:23:51,559 --> 00:23:57,620
you see that it requires a lot of extra

00:23:53,750 --> 00:24:01,100
memory can you give us an example of

00:23:57,620 --> 00:24:03,710
size on how much is a lot of memory well

00:24:01,100 --> 00:24:06,169
you have to consider that with django

00:24:03,710 --> 00:24:10,399
tree board you have a step length of 4

00:24:06,169 --> 00:24:13,489
was so each depth level has four

00:24:10,399 --> 00:24:17,749
characters and if you have a if you have

00:24:13,489 --> 00:24:21,379
let's say depths of thousand then you

00:24:17,749 --> 00:24:24,259
have 4,000 characters per node and you

00:24:21,379 --> 00:24:25,519
have to build an index over those 4,000

00:24:24,259 --> 00:24:29,600
characters per node

00:24:25,519 --> 00:24:33,259
so that's may sum up in case you have

00:24:29,600 --> 00:24:35,720
some size limitations on your database

00:24:33,259 --> 00:24:38,119
and database it's not really nowadays

00:24:35,720 --> 00:24:41,019
it's not really really huge but I just

00:24:38,119 --> 00:24:45,769
wanted to mention it that it could be

00:24:41,019 --> 00:24:47,690
for instance the nested sets they're the

00:24:45,769 --> 00:24:50,720
limitations are much smaller because you

00:24:47,690 --> 00:24:52,489
have only numbers and just injured

00:24:50,720 --> 00:24:55,609
integer numbers as your built-in index

00:24:52,489 --> 00:24:58,460
over over those integer numbers okay

00:24:55,609 --> 00:25:02,450
thank you yeah

00:24:58,460 --> 00:25:05,749
so yeah you mentioned that you replaced

00:25:02,450 --> 00:25:09,289
Jango and PTT with jungle tree burden in

00:25:05,749 --> 00:25:11,899
general CMS right no I didn't I didn't

00:25:09,289 --> 00:25:14,239
do it but the developers of Django CMS

00:25:11,899 --> 00:25:16,909
did it yes so do you have knowledge

00:25:14,239 --> 00:25:20,269
which of the algorithms from Django tree

00:25:16,909 --> 00:25:24,679
birthday they use as a default as a

00:25:20,269 --> 00:25:25,330
materialized path alright sorry of

00:25:24,679 --> 00:25:35,059
course

00:25:25,330 --> 00:25:37,369
okay okay ah perfect math question is

00:25:35,059 --> 00:25:40,100
there or why do you limit the alphabet

00:25:37,369 --> 00:25:42,230
because if I think about if you store a

00:25:40,100 --> 00:25:43,580
varchar field and you would store it as

00:25:42,230 --> 00:25:46,159
utf-8 for example where you would do

00:25:43,580 --> 00:25:48,259
this 8-bit per character if you limit

00:25:46,159 --> 00:25:53,059
your alphabet you kind of waste a lot of

00:25:48,259 --> 00:25:54,440
bits in in that tree path why not use of

00:25:53,059 --> 00:25:56,950
the larger alphabet that is like

00:25:54,440 --> 00:25:59,090
complete setters for example you do fade

00:25:56,950 --> 00:26:02,210
first of all I have to say it didn't

00:25:59,090 --> 00:26:03,889
write any of those libraries I inherited

00:26:02,210 --> 00:26:06,350
Django Treebeard

00:26:03,889 --> 00:26:09,879
because Gustavo pecan gave up

00:26:06,350 --> 00:26:13,639
development and since we used that in

00:26:09,879 --> 00:26:15,590
applications for for clients and since

00:26:13,639 --> 00:26:19,489
Django CMS relied on it

00:26:15,590 --> 00:26:23,149
somebody had to take over the the

00:26:19,489 --> 00:26:25,849
maintenance of that library I just

00:26:23,149 --> 00:26:30,889
looked into the code and I saw that he

00:26:25,849 --> 00:26:33,409
was using 36 characters I assume it's

00:26:30,889 --> 00:26:35,989
because of I assume it's because of

00:26:33,409 --> 00:26:38,710
collation problems if you if your

00:26:35,989 --> 00:26:41,299
databases are configured and different

00:26:38,710 --> 00:26:46,149
with different sorting order for

00:26:41,299 --> 00:26:48,519
alphabets I assume I don't know thanks

00:26:46,149 --> 00:26:54,200
we have time for one more

00:26:48,519 --> 00:26:56,119
okay did he do any performance checks

00:26:54,200 --> 00:26:58,519
that you have some numbers compared to

00:26:56,119 --> 00:27:01,340
the client-side solutions with the CTE

00:26:58,519 --> 00:27:04,580
solutions on the database systems no I

00:27:01,340 --> 00:27:09,259
didn't do that I didn't I didn't make

00:27:04,580 --> 00:27:10,340
any benchmarks on that okay let's think

00:27:09,259 --> 00:27:13,760
Jacob again

00:27:10,340 --> 00:27:13,760

YouTube URL: https://www.youtube.com/watch?v=CRxjoklS8v0


