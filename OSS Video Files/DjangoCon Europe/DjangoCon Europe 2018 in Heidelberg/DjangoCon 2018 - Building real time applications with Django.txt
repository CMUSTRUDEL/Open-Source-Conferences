Title: DjangoCon 2018 - Building real time applications with Django
Publication date: 2018-05-23
Playlist: DjangoCon Europe 2018 in Heidelberg
Description: 
	https://media.ccc.de/v/hd-65-building-real-time-applications-with-django



Since the introduction of Channels, real time web has become much easier to work with in Django: discover how you can easily create yours with Django!

Since the introduction of Channels, real time web has become much easier to work with in Django. It’s now possible to build real time applications with much less effort in managing the idiosyncrasies of the async programming and a lot of batteries are included. Starting with a brief introduction to Channels (targeting version 2.0), we will see how to build a real time application, both on the Django and the frontend side and how easy it’s to start experimenting with it. The talk has a very hands-on approach, to allow the attendees to experiment with the proposed solution and approach, and starting immediately building their own real time applications with Django.

Iacopo Spalletti
Captions: 
	00:00:06,279 --> 00:00:11,670
the next speaker is Jakob asperity and

00:00:12,510 --> 00:00:20,380
he's going to talk to us about well we

00:00:18,130 --> 00:00:22,480
all know the old web like the you click

00:00:20,380 --> 00:00:25,210
and then even if you're German it's

00:00:22,480 --> 00:00:27,099
still the thing where the page loads and

00:00:25,210 --> 00:00:29,650
loads and doesn't load and doesn't load

00:00:27,099 --> 00:00:30,849
and you may get internet and maybe you

00:00:29,650 --> 00:00:32,800
get to the point where your website

00:00:30,849 --> 00:00:35,050
actually loads and he's talking to us

00:00:32,800 --> 00:00:37,210
about application or web applications

00:00:35,050 --> 00:00:49,000
that load in real time don't know how

00:00:37,210 --> 00:00:52,030
that works in Germany hi everyone I'm

00:00:49,000 --> 00:00:55,060
Yakko possibility and I'm CTO and

00:00:52,030 --> 00:00:57,160
founder of of nebula and we build stuff

00:00:55,060 --> 00:01:00,640
with Python basically and I've been

00:00:57,160 --> 00:01:03,100
using Django since 2009 I'm mantener of

00:01:00,640 --> 00:01:05,680
a few Django applications and one of the

00:01:03,100 --> 00:01:08,560
core developer of Django CMS I'm very

00:01:05,680 --> 00:01:10,990
thrilled to be on stage for my first

00:01:08,560 --> 00:01:13,600
time a speaker at GenCon Europe and I'm

00:01:10,990 --> 00:01:20,800
scared of talking about channels with

00:01:13,600 --> 00:01:23,200
Andrew in in the room but yeah so for

00:01:20,800 --> 00:01:26,050
some time now web has evolved into being

00:01:23,200 --> 00:01:28,840
much more than just click request

00:01:26,050 --> 00:01:31,690
response cycle of the good old days and

00:01:28,840 --> 00:01:34,090
richness and complexity of modern web

00:01:31,690 --> 00:01:36,280
application has grown and most of them

00:01:34,090 --> 00:01:38,799
requires a lot of different tools to

00:01:36,280 --> 00:01:41,500
build to be built and run this is

00:01:38,799 --> 00:01:43,930
awesome as little nerdiness is eager to

00:01:41,500 --> 00:01:46,420
learn new shiny tools but you end up

00:01:43,930 --> 00:01:48,190
eating a complexity wall in in limiting

00:01:46,420 --> 00:01:49,810
the amount of stuff you can throw out an

00:01:48,190 --> 00:01:53,200
application to run before it start to

00:01:49,810 --> 00:01:55,360
crumble there are already a lot of great

00:01:53,200 --> 00:01:56,890
Python frameworks to work with the the

00:01:55,360 --> 00:01:58,990
synchronous web and their synchronous

00:01:56,890 --> 00:02:01,630
communication but would it be nice to

00:01:58,990 --> 00:02:05,799
have at the jungle way to do this this

00:02:01,630 --> 00:02:09,039
stuff so channels and channels has been

00:02:05,799 --> 00:02:10,569
created to go beyond the request the

00:02:09,039 --> 00:02:12,819
HTTP request/response

00:02:10,569 --> 00:02:15,040
without losing the django awesomeness

00:02:12,819 --> 00:02:16,900
it's not part of jungles from framework

00:02:15,040 --> 00:02:18,460
but it's still maintained by the by the

00:02:16,900 --> 00:02:21,070
jungle project

00:02:18,460 --> 00:02:22,900
and is a framework built to deal with

00:02:21,070 --> 00:02:25,120
all the synchronous particles so it's

00:02:22,900 --> 00:02:27,700
not limited to two WebSockets and you

00:02:25,120 --> 00:02:30,930
can use any a synchronous protocol with

00:02:27,700 --> 00:02:33,070
with channels and but we will assume

00:02:30,930 --> 00:02:35,650
WebSockets for the rest of the talk

00:02:33,070 --> 00:02:38,860
which is also part of the channel score

00:02:35,650 --> 00:02:41,920
and so channels two is the shiny

00:02:38,860 --> 00:02:44,740
shiniest the newest version which is

00:02:41,920 --> 00:02:47,050
just a few months old it changed a lot

00:02:44,740 --> 00:02:51,040
of things from the channels one version

00:02:47,050 --> 00:02:54,910
which served us serve with us for a lot

00:02:51,040 --> 00:02:58,000
of years and I will assume version two

00:02:54,910 --> 00:03:00,010
for for the rest of the talk the talk

00:02:58,000 --> 00:03:02,710
will not assume any previous knowledge

00:03:00,010 --> 00:03:04,840
of channels probably and you will go

00:03:02,710 --> 00:03:07,540
more into the details of channels

00:03:04,840 --> 00:03:10,990
I'll explain so I explained the basic

00:03:07,540 --> 00:03:13,450
concepts and a start might be boring but

00:03:10,990 --> 00:03:15,870
I found it very important to understand

00:03:13,450 --> 00:03:18,400
them to actually being able to write

00:03:15,870 --> 00:03:21,070
sensible application sense accessible

00:03:18,400 --> 00:03:23,830
channels application I wanted to talk to

00:03:21,070 --> 00:03:26,290
be very actionable very practical so we

00:03:23,830 --> 00:03:29,140
will have a sample application we will

00:03:26,290 --> 00:03:32,050
see together and I will drill down into

00:03:29,140 --> 00:03:34,840
the code to show the intricacies or the

00:03:32,050 --> 00:03:37,960
pitfalls of of channels of building

00:03:34,840 --> 00:03:40,480
channels application so let's see some

00:03:37,960 --> 00:03:42,640
concepts the first one is a synchronous

00:03:40,480 --> 00:03:44,800
what what means are synchronous in this

00:03:42,640 --> 00:03:47,770
in this context let's say that a

00:03:44,800 --> 00:03:49,500
synchronous means even driven so some

00:03:47,770 --> 00:03:52,570
event happens and our application

00:03:49,500 --> 00:03:55,150
respond to it for example a client

00:03:52,570 --> 00:03:57,430
connect to a socket end points and a

00:03:55,150 --> 00:03:59,740
function is called or an object is

00:03:57,430 --> 00:04:02,650
created in the database and another

00:03:59,740 --> 00:04:05,080
function is called and this is a big

00:04:02,650 --> 00:04:07,780
change from from the usual synchronous

00:04:05,080 --> 00:04:09,580
HTTP world if you are interested in how

00:04:07,780 --> 00:04:12,640
Jango works in the synchronous world

00:04:09,580 --> 00:04:16,030
have a look at Jacob Kaplan or stock at

00:04:12,640 --> 00:04:19,750
jungle 102 2015 about the whole request

00:04:16,030 --> 00:04:23,320
response cycle which is very it's been

00:04:19,750 --> 00:04:25,360
very interesting and insightful a

00:04:23,320 --> 00:04:27,130
problem with the synchronous code is

00:04:25,360 --> 00:04:29,580
this is general more complex to

00:04:27,130 --> 00:04:31,810
understand and write because it's known

00:04:29,580 --> 00:04:40,900
because of its normally

00:04:31,810 --> 00:04:43,450
your nature and so it's it's in yeah

00:04:40,900 --> 00:04:46,870
it's more complex and channels one

00:04:43,450 --> 00:04:49,330
decided to hide most of these of its

00:04:46,870 --> 00:04:54,010
complexity while channels two embraces

00:04:49,330 --> 00:04:56,919
it and expose the asynchronous core you

00:04:54,010 --> 00:04:59,710
can still write a synchronous code but

00:04:56,919 --> 00:05:04,419
you can switch to the synchronous if you

00:04:59,710 --> 00:05:08,560
if you need one of the portland concept

00:05:04,419 --> 00:05:12,190
and base of of channels is the SGI

00:05:08,560 --> 00:05:14,320
protocol which has been developed

00:05:12,190 --> 00:05:16,479
together with channels but is actually

00:05:14,320 --> 00:05:19,270
broader than than channels and provide

00:05:16,479 --> 00:05:20,800
an implementation independent

00:05:19,270 --> 00:05:23,050
specification of a synchronous

00:05:20,800 --> 00:05:24,820
interfaces basically as the same role as

00:05:23,050 --> 00:05:29,800
whiskey interface in the synchronous

00:05:24,820 --> 00:05:32,620
world and one of the big change in

00:05:29,800 --> 00:05:34,479
channels too is the SGI all the way down

00:05:32,620 --> 00:05:36,760
approach every building blocks of

00:05:34,479 --> 00:05:40,060
channels is an SGI application so you

00:05:36,760 --> 00:05:43,350
can mix them compose and pipeline

00:05:40,060 --> 00:05:50,440
basically them to to create your own

00:05:43,350 --> 00:05:53,440
pipeline and your own application the

00:05:50,440 --> 00:05:55,510
the first building block of channels is

00:05:53,440 --> 00:05:59,289
the protocol server which is the one

00:05:55,510 --> 00:06:02,289
that implements this guy's specification

00:05:59,289 --> 00:06:05,320
for a specific protocol so it you have a

00:06:02,289 --> 00:06:08,110
protocol server for WebSockets you can

00:06:05,320 --> 00:06:13,330
have another one for I don't know some

00:06:08,110 --> 00:06:16,510
IOT protocol or whatever and the

00:06:13,330 --> 00:06:18,820
protocol server is the part of software

00:06:16,510 --> 00:06:22,380
that interacts with the connection with

00:06:18,820 --> 00:06:27,039
the network or with the external world

00:06:22,380 --> 00:06:29,139
for channels has Daphne as the reference

00:06:27,039 --> 00:06:32,410
implementation for a protocol server

00:06:29,139 --> 00:06:34,960
which speaks HTTP a WebSockets but yeah

00:06:32,410 --> 00:06:38,470
you can have any kind of protocol server

00:06:34,960 --> 00:06:41,550
and you can have many of them to speak

00:06:38,470 --> 00:06:41,550
different protocols

00:06:42,150 --> 00:06:45,690
behind the protocol server there is a

00:06:43,830 --> 00:06:48,090
routing because when you have the

00:06:45,690 --> 00:06:53,040
connection established you need to route

00:06:48,090 --> 00:06:57,810
this connection somewhere and so it pops

00:06:53,040 --> 00:07:01,470
incoming messages to consumers and again

00:06:57,810 --> 00:07:04,500
being routers SGI application they can

00:07:01,470 --> 00:07:08,310
be nested and composed together and we

00:07:04,500 --> 00:07:10,590
will see some examples later you may

00:07:08,310 --> 00:07:13,110
have different protocols which will have

00:07:10,590 --> 00:07:16,260
different kind of routing so you will

00:07:13,110 --> 00:07:19,680
have basically routers according to the

00:07:16,260 --> 00:07:21,870
different protocol server you have scope

00:07:19,680 --> 00:07:25,830
is also one of the big change in

00:07:21,870 --> 00:07:29,040
channels too every time a connection is

00:07:25,830 --> 00:07:30,660
established a scope is created and all

00:07:29,040 --> 00:07:32,790
the information regarding the connection

00:07:30,660 --> 00:07:36,150
all the information the protocol that we

00:07:32,790 --> 00:07:39,990
want to deliver to you are put into into

00:07:36,150 --> 00:07:43,290
the scope so you have the connection and

00:07:39,990 --> 00:07:45,330
then the scope is created and the

00:07:43,290 --> 00:07:52,830
application instance is provided this

00:07:45,330 --> 00:07:55,470
this cope butwhat's and channel channel

00:07:52,830 --> 00:07:57,150
used to be basically the building block

00:07:55,470 --> 00:07:59,910
of channels one version in chance we

00:07:57,150 --> 00:08:04,550
changed a lot its its nature it used to

00:07:59,910 --> 00:08:07,560
be the basic communication system

00:08:04,550 --> 00:08:09,690
between them the the protocol server and

00:08:07,560 --> 00:08:12,419
the rest of the application in channels

00:08:09,690 --> 00:08:14,940
2 is basically an IPC mechanism for the

00:08:12,419 --> 00:08:17,460
differ for consumers to to speak to to

00:08:14,940 --> 00:08:20,970
each other and it's where events

00:08:17,460 --> 00:08:21,900
basically happens as channels one is a

00:08:20,970 --> 00:08:26,280
first-in first-out

00:08:21,900 --> 00:08:28,650
at most once q and then we have the

00:08:26,280 --> 00:08:32,909
consumers which are the main attraction

00:08:28,650 --> 00:08:34,919
of building your SGI applications it

00:08:32,909 --> 00:08:38,909
handle events that happens on a

00:08:34,919 --> 00:08:40,919
connection or in a channel layer and the

00:08:38,909 --> 00:08:42,900
big change is that consumers are

00:08:40,919 --> 00:08:45,210
stateful so whenever connection is

00:08:42,900 --> 00:08:48,420
established an instance is instantiated

00:08:45,210 --> 00:08:52,500
and the connection and the instance will

00:08:48,420 --> 00:08:54,260
leave together and so each connection is

00:08:52,500 --> 00:09:00,110
managed by a single because

00:08:54,260 --> 00:09:03,260
for instance group also changed a lot in

00:09:00,110 --> 00:09:06,110
version two they're now basically just

00:09:03,260 --> 00:09:11,480
labels attached to them to the consumer

00:09:06,110 --> 00:09:15,500
to group them into into sensible sets of

00:09:11,480 --> 00:09:17,240
of consumers instances events are the

00:09:15,500 --> 00:09:20,330
base concepts of a synchronous

00:09:17,240 --> 00:09:23,840
programming and they are triggered along

00:09:20,330 --> 00:09:26,330
the lifetime of our instance basically

00:09:23,840 --> 00:09:28,160
and they can come from the from the

00:09:26,330 --> 00:09:30,200
connection like when the connection is

00:09:28,160 --> 00:09:32,180
established or a user send a message or

00:09:30,200 --> 00:09:35,660
they can come from the channels layer

00:09:32,180 --> 00:09:38,480
while you something put a message in the

00:09:35,660 --> 00:09:40,370
channel layer and and the consumer will

00:09:38,480 --> 00:09:46,280
will respond because in the end

00:09:40,370 --> 00:09:50,560
consumers consume events and last but

00:09:46,280 --> 00:09:52,940
not least WebSockets is mostly used

00:09:50,560 --> 00:09:55,460
consumed by by JavaScript we are not

00:09:52,940 --> 00:09:59,090
limited there is Python implementation

00:09:55,460 --> 00:10:02,450
of WebSockets a client or any language

00:09:59,090 --> 00:10:04,910
actually but if you need JavaScript

00:10:02,450 --> 00:10:09,200
channels ships are very lightweight

00:10:04,910 --> 00:10:15,010
library to make easier to use WebSockets

00:10:09,200 --> 00:10:18,340
in in the browser so a brief recap

00:10:15,010 --> 00:10:21,650
channels to expose their synchronous

00:10:18,340 --> 00:10:23,270
it's a synchronous interface the a and

00:10:21,650 --> 00:10:28,910
it uses as in ko

00:10:23,270 --> 00:10:31,490
so it only Python 3 and up only but and

00:10:28,910 --> 00:10:34,880
but this allows you to write synchronous

00:10:31,490 --> 00:10:38,750
and the synchronous code in in channels

00:10:34,880 --> 00:10:43,220
so you are much more free to do your own

00:10:38,750 --> 00:10:46,190
implementation it also changed the way

00:10:43,220 --> 00:10:49,790
it handles the the connection because

00:10:46,190 --> 00:10:52,520
now everything runs in the same in the

00:10:49,790 --> 00:10:55,280
same process so Django and the consumers

00:10:52,520 --> 00:10:58,610
run in the same process this allows to

00:10:55,280 --> 00:11:01,640
make consumers stateful along the other

00:10:58,610 --> 00:11:04,800
advantages then you have middle words

00:11:01,640 --> 00:11:08,189
which are similar to the whiskey ones

00:11:04,800 --> 00:11:10,559
and as I said the SGI all the way down

00:11:08,189 --> 00:11:14,009
approach which makes much more flexible

00:11:10,559 --> 00:11:17,459
in building application but ok enough

00:11:14,009 --> 00:11:19,619
theory let's see some action and this is

00:11:17,459 --> 00:11:22,079
a simple application I I built for this

00:11:19,619 --> 00:11:24,600
for this talk it is a very simple one

00:11:22,079 --> 00:11:26,939
it's simplified version of a I'm an

00:11:24,600 --> 00:11:29,670
application we actually built is not

00:11:26,939 --> 00:11:33,110
present 100% of our channels features

00:11:29,670 --> 00:11:35,100
but is is a good subset to start with

00:11:33,110 --> 00:11:37,860
what's the features of this application

00:11:35,100 --> 00:11:40,649
is let's call it pou Fulks Google Docs

00:11:37,860 --> 00:11:43,589
because you can count active users it

00:11:40,649 --> 00:11:46,649
can tell if other users are reading or

00:11:43,589 --> 00:11:48,660
editing a document and you have browser

00:11:46,649 --> 00:11:52,350
notification when something happens in

00:11:48,660 --> 00:11:55,619
the into the application application

00:11:52,350 --> 00:11:58,230
logic is very very coarse and very race

00:11:55,619 --> 00:12:01,829
condition prone is just yep just to

00:11:58,230 --> 00:12:05,459
expose the channels features not not to

00:12:01,829 --> 00:12:07,739
how to build a real application as I

00:12:05,459 --> 00:12:11,910
don't want to sacrifice Eaton's to the

00:12:07,739 --> 00:12:15,749
live demo god I prefer a video and I

00:12:11,910 --> 00:12:16,379
will explain as it runs so a year on

00:12:15,749 --> 00:12:18,839
right

00:12:16,379 --> 00:12:21,420
you have Lila with the dashboard open

00:12:18,839 --> 00:12:23,459
and on the left you will have fry at the

00:12:21,420 --> 00:12:27,509
moment Lila is the only one on the

00:12:23,459 --> 00:12:29,869
dashboard you see maybe it is little not

00:12:27,509 --> 00:12:33,319
very readable but you have a one here

00:12:29,869 --> 00:12:36,629
Fry's login there is the notification

00:12:33,319 --> 00:12:39,689
permission check but the users are now -

00:12:36,629 --> 00:12:42,299
and you have these green labels on the

00:12:39,689 --> 00:12:44,100
each document that says that nobody is

00:12:42,299 --> 00:12:47,100
doing nothing with it

00:12:44,100 --> 00:12:49,769
now fries is opened document so Leela

00:12:47,100 --> 00:12:53,939
knows that fries in because the label is

00:12:49,769 --> 00:12:56,910
yellow and the fries name is on is there

00:12:53,939 --> 00:13:02,189
then fries open the form and label turns

00:12:56,910 --> 00:13:05,939
red with the fry name fries saved saves

00:13:02,189 --> 00:13:09,629
the document and that's the that's the

00:13:05,939 --> 00:13:14,189
notification Leela clicks on it the

00:13:09,629 --> 00:13:17,279
document opens and fries the anon fries

00:13:14,189 --> 00:13:23,699
dashboard the label turns

00:13:17,279 --> 00:13:26,790
yellow so it's very basic and stupid so

00:13:23,699 --> 00:13:28,230
to speak but it allows to see a lot of

00:13:26,790 --> 00:13:30,660
different things regarding channels

00:13:28,230 --> 00:13:32,550
these are the three parts of channels

00:13:30,660 --> 00:13:35,610
you are going to touch when you build

00:13:32,550 --> 00:13:40,370
your own application so channel layers

00:13:35,610 --> 00:13:43,980
routing and consumers channel layers is

00:13:40,370 --> 00:13:48,930
basically where is the back and storage

00:13:43,980 --> 00:13:51,540
of of the messages that runs between the

00:13:48,930 --> 00:13:53,819
between the consumers so you basically

00:13:51,540 --> 00:13:57,029
have just to configure it and use it one

00:13:53,819 --> 00:13:58,860
of the existing channel layer you can

00:13:57,029 --> 00:14:02,610
build your own this is one of the

00:13:58,860 --> 00:14:07,170
default ones and you have the SGI

00:14:02,610 --> 00:14:09,839
application setting which will tell that

00:14:07,170 --> 00:14:13,230
the protocol server where to send

00:14:09,839 --> 00:14:16,199
messages i configured routing but this

00:14:13,230 --> 00:14:19,860
as everything is an SGI application i

00:14:16,199 --> 00:14:23,970
can put any I see I hear not necessarily

00:14:19,860 --> 00:14:29,639
a routing but what's the routing routing

00:14:23,970 --> 00:14:33,839
is similar to to the jungle Kampf and so

00:14:29,639 --> 00:14:36,000
you have a lot of different SGI

00:14:33,839 --> 00:14:39,180
applications here that route the

00:14:36,000 --> 00:14:43,410
messages along the long decision tree

00:14:39,180 --> 00:14:44,100
basics and let's see more in detail how

00:14:43,410 --> 00:14:48,449
it works

00:14:44,100 --> 00:14:51,199
so this is our top-level routing you

00:14:48,449 --> 00:14:53,790
have the middle words which is this one

00:14:51,199 --> 00:14:56,759
as we said is similar to the whiskey

00:14:53,790 --> 00:14:59,639
ones basically they aid they add data

00:14:56,759 --> 00:15:03,389
onto unto the scope object according to

00:14:59,639 --> 00:15:05,220
some logic channels have some that pulls

00:15:03,389 --> 00:15:07,199
data from the HTTP protocol on

00:15:05,220 --> 00:15:09,269
profitable upgrade and put and make it

00:15:07,199 --> 00:15:11,339
available into the into the scope and

00:15:09,269 --> 00:15:14,160
then throughout the routers themselves

00:15:11,339 --> 00:15:17,430
here you have the protocol type router

00:15:14,160 --> 00:15:19,290
which rubs the the messages according to

00:15:17,430 --> 00:15:22,589
their protocol because channels is is

00:15:19,290 --> 00:15:27,209
multi protocol and you have the URL

00:15:22,589 --> 00:15:29,730
router which is the WebSocket specific

00:15:27,209 --> 00:15:30,870
router to route messages according to

00:15:29,730 --> 00:15:33,029
their path now

00:15:30,870 --> 00:15:36,770
that this buff function is exactly the

00:15:33,029 --> 00:15:41,490
same is exactly the Django Ural golf

00:15:36,770 --> 00:15:44,160
function one thing to to bear in mind as

00:15:41,490 --> 00:15:48,120
the routing is established whenever the

00:15:44,160 --> 00:15:50,690
connection is established so each

00:15:48,120 --> 00:15:53,190
consumer is tied to a single connection

00:15:50,690 --> 00:15:55,080
in this application you will see a lot

00:15:53,190 --> 00:15:58,650
of different consumers is probably

00:15:55,080 --> 00:16:00,330
advisable to have more less consumers

00:15:58,650 --> 00:16:02,940
because each consumer will have a

00:16:00,330 --> 00:16:05,160
connection memory footprint etc and so

00:16:02,940 --> 00:16:08,220
it's less efficient to have too many

00:16:05,160 --> 00:16:12,779
codes code scattered in many into many

00:16:08,220 --> 00:16:15,930
consumers and then you have the

00:16:12,779 --> 00:16:19,740
application routing as as you see here i

00:16:15,930 --> 00:16:21,810
i i link the status path to this

00:16:19,740 --> 00:16:25,580
documents routing which is this one

00:16:21,810 --> 00:16:29,190
which routes the path to the different

00:16:25,580 --> 00:16:31,860
consumers again this is exactly same

00:16:29,190 --> 00:16:34,740
syntax as django eurocom this is

00:16:31,860 --> 00:16:37,709
specific to the WebSocket implementation

00:16:34,740 --> 00:16:40,200
of of channels different protocols don't

00:16:37,709 --> 00:16:44,010
have the concept of path so they have to

00:16:40,200 --> 00:16:49,529
come up with their own routing syntax

00:16:44,010 --> 00:16:53,100
but this is the general idea so let's

00:16:49,529 --> 00:16:57,300
see some consumers because there is

00:16:53,100 --> 00:16:58,740
where the stuff happens consumers are

00:16:57,300 --> 00:17:00,200
the building blocks of channels

00:16:58,740 --> 00:17:04,709
application they are protocol

00:17:00,200 --> 00:17:06,179
independent dependent sorry as the entry

00:17:04,709 --> 00:17:07,530
points are defined by the protocol

00:17:06,179 --> 00:17:11,010
server because the protocol server

00:17:07,530 --> 00:17:12,420
defined events that happens now for

00:17:11,010 --> 00:17:16,020
example we are going to use the

00:17:12,420 --> 00:17:18,390
WebSocket consumer which is which is

00:17:16,020 --> 00:17:21,390
kind of high-level class there are a lot

00:17:18,390 --> 00:17:28,199
of classes which allows to work with

00:17:21,390 --> 00:17:30,900
more low level stuff if you need in case

00:17:28,199 --> 00:17:33,510
of WebSocket we have these three entry

00:17:30,900 --> 00:17:35,820
points connect disconnect and receive

00:17:33,510 --> 00:17:37,760
according to the different events client

00:17:35,820 --> 00:17:40,080
connect disconnect or send message

00:17:37,760 --> 00:17:41,990
they're optional the default

00:17:40,080 --> 00:17:44,410
implementation of WebSocket consumer

00:17:41,990 --> 00:17:46,270
does something with it

00:17:44,410 --> 00:17:50,140
by doing the accept of the connection

00:17:46,270 --> 00:17:54,010
etc and you're going to need to write

00:17:50,140 --> 00:17:59,320
your own Events Manager yeah you haven't

00:17:54,010 --> 00:18:01,090
Handler and we will see why in this

00:17:59,320 --> 00:18:02,380
example this is a very basic consumer

00:18:01,090 --> 00:18:06,070
very stupid one

00:18:02,380 --> 00:18:08,590
you have on connection there is this

00:18:06,070 --> 00:18:12,790
thing we will see more in detail later

00:18:08,590 --> 00:18:17,140
which sends a message to a group to the

00:18:12,790 --> 00:18:19,750
users group and there is this method

00:18:17,140 --> 00:18:22,210
defined on the same class which matches

00:18:19,750 --> 00:18:24,940
and handle the events in this case it

00:18:22,210 --> 00:18:28,150
just relays the number of users which is

00:18:24,940 --> 00:18:30,210
static files own not much useful back to

00:18:28,150 --> 00:18:34,350
the back to the clients and we will go

00:18:30,210 --> 00:18:40,390
we will see the details each step set up

00:18:34,350 --> 00:18:43,030
so counting users in our case counting

00:18:40,390 --> 00:18:45,700
users is very safe because a very simple

00:18:43,030 --> 00:18:47,950
because we have a stateful connection so

00:18:45,700 --> 00:18:50,530
we when a client connect we just

00:18:47,950 --> 00:18:54,280
increment in some way that the number of

00:18:50,530 --> 00:18:57,790
users we create a message here with the

00:18:54,280 --> 00:19:01,720
actual number of users connected and we

00:18:57,790 --> 00:19:05,380
send them back to the users group this

00:19:01,720 --> 00:19:08,140
this group each consumer is attached to

00:19:05,380 --> 00:19:11,350
a group according to this to this

00:19:08,140 --> 00:19:15,490
attribute this is currently I I set it

00:19:11,350 --> 00:19:18,820
as a static users string actually please

00:19:15,490 --> 00:19:23,170
note the comma this is a tuple not not

00:19:18,820 --> 00:19:25,120
as not a simple string but I can use I

00:19:23,170 --> 00:19:28,630
will use a property here to make more

00:19:25,120 --> 00:19:30,730
dynamic another in following example so

00:19:28,630 --> 00:19:33,190
I send this message and in this same

00:19:30,730 --> 00:19:35,380
consumer I just read the message with a

00:19:33,190 --> 00:19:39,300
number of users and I'll send them back

00:19:35,380 --> 00:19:39,300
to the to the clients

00:19:40,840 --> 00:19:46,360
I can write JavaScript is that this is

00:19:43,360 --> 00:19:49,600
awesome this is very simple javascript

00:19:46,360 --> 00:19:53,470
code i i've been able to write by using

00:19:49,600 --> 00:19:56,590
the the WebSocket client library we've

00:19:53,470 --> 00:19:59,440
shipped by by channels here I connect to

00:19:56,590 --> 00:20:01,690
a path define somehow somewhere but it's

00:19:59,440 --> 00:20:04,240
basically the endpoint I configure it in

00:20:01,690 --> 00:20:06,460
the indoor outing then I listen to the

00:20:04,240 --> 00:20:08,799
incoming data from from the connection

00:20:06,460 --> 00:20:11,260
and I do something with it and it's in

00:20:08,799 --> 00:20:14,140
this case I just read the number of

00:20:11,260 --> 00:20:19,990
users and I update the label on top of

00:20:14,140 --> 00:20:23,159
the of the window so we know how many

00:20:19,990 --> 00:20:27,909
users we have but now we want to check

00:20:23,159 --> 00:20:30,340
who's who's doing what and in this case

00:20:27,909 --> 00:20:32,200
we have two different consumers one to

00:20:30,340 --> 00:20:37,510
track the single document and want to

00:20:32,200 --> 00:20:39,429
track the list this is not very

00:20:37,510 --> 00:20:42,730
different from from the other example

00:20:39,429 --> 00:20:45,850
here I count the number of users I I

00:20:42,730 --> 00:20:48,429
have but in this case I I also need to

00:20:45,850 --> 00:20:53,770
check that the Stata Center and the slug

00:20:48,429 --> 00:20:57,100
and then I send them I sent back sorry

00:20:53,770 --> 00:20:59,740
the the number of of users actually is a

00:20:57,100 --> 00:21:01,840
more complex structure which says okay

00:20:59,740 --> 00:21:05,409
there are these users in this document

00:21:01,840 --> 00:21:08,200
with this faces so read or or edit and

00:21:05,409 --> 00:21:10,779
please note that in this case the group

00:21:08,200 --> 00:21:13,000
I'm sending the message to is is a slack

00:21:10,779 --> 00:21:16,330
which is something I captured from from

00:21:13,000 --> 00:21:19,059
the path and I defined I attach this one

00:21:16,330 --> 00:21:22,690
into this number of groups defining the

00:21:19,059 --> 00:21:25,779
property so this is dynamic when the

00:21:22,690 --> 00:21:28,090
consumer is associated is attached to

00:21:25,779 --> 00:21:34,179
the according to the slack of its of its

00:21:28,090 --> 00:21:37,390
path again I send a message and this

00:21:34,179 --> 00:21:40,659
this method sends back sends back the

00:21:37,390 --> 00:21:42,340
message but I want to go more into the

00:21:40,659 --> 00:21:44,500
details of what's happening here because

00:21:42,340 --> 00:21:47,860
this is basically the concept the entire

00:21:44,500 --> 00:21:49,960
concept of of channels so in the connect

00:21:47,860 --> 00:21:52,299
I call this I think to sync function

00:21:49,960 --> 00:21:54,400
which is a helper function that map's

00:21:52,299 --> 00:21:56,890
the synchronous

00:21:54,400 --> 00:21:59,290
part of channels which in this case is

00:21:56,890 --> 00:22:01,150
the groups and method with the

00:21:59,290 --> 00:22:03,280
synchronous part which is the connect

00:22:01,150 --> 00:22:05,650
the connector is a simple synchronous

00:22:03,280 --> 00:22:08,860
function so I can use or am here and

00:22:05,650 --> 00:22:11,070
another synchronous function the channel

00:22:08,860 --> 00:22:14,530
layer is an attribute phone on my

00:22:11,070 --> 00:22:17,590
consumer instance which will map the the

00:22:14,530 --> 00:22:18,990
current channel layer and the groups and

00:22:17,590 --> 00:22:21,010
is is the function that actually

00:22:18,990 --> 00:22:23,800
interacts with the synchronous part and

00:22:21,010 --> 00:22:25,480
send message as I said the the self slag

00:22:23,800 --> 00:22:29,800
is the current is the group I want to

00:22:25,480 --> 00:22:33,610
send a message to and what's the message

00:22:29,800 --> 00:22:36,550
the message is basically a dictionary in

00:22:33,610 --> 00:22:39,700
this case I using JSON WebSocket so it

00:22:36,550 --> 00:22:43,570
must be a JSON Sarai's Abal dictionary

00:22:39,700 --> 00:22:45,250
but you can if you go more into the if

00:22:43,570 --> 00:22:49,080
you use different base classes you can

00:22:45,250 --> 00:22:52,030
have also have been binary messages and

00:22:49,080 --> 00:22:55,900
the important part here is that is the

00:22:52,030 --> 00:22:59,110
type key which I can actually can invent

00:22:55,900 --> 00:23:03,880
basically document dot stages which is

00:22:59,110 --> 00:23:06,310
mapped to to a method in this case

00:23:03,880 --> 00:23:10,480
document underscore stages which must be

00:23:06,310 --> 00:23:13,930
implemented in each consumer which is

00:23:10,480 --> 00:23:17,650
attached to the slug to this specific

00:23:13,930 --> 00:23:20,770
slug group and the important part to

00:23:17,650 --> 00:23:23,130
understand is that even if those two

00:23:20,770 --> 00:23:26,350
methods are implemented in the same

00:23:23,130 --> 00:23:30,670
class they are not executed into the

00:23:26,350 --> 00:23:32,980
same instances because this is in cold

00:23:30,670 --> 00:23:36,450
in the single instance where that they

00:23:32,980 --> 00:23:40,450
haven't has been catched or happens and

00:23:36,450 --> 00:23:43,240
this one is executed in all the consumer

00:23:40,450 --> 00:23:48,220
resistances listening on the same on the

00:23:43,240 --> 00:23:50,020
same group so that's that's really

00:23:48,220 --> 00:23:54,130
important to understand that by using

00:23:50,020 --> 00:23:57,070
events you can propagate things from one

00:23:54,130 --> 00:24:00,400
group to to another a to what sorry to

00:23:57,070 --> 00:24:02,440
one consumer instance to another the

00:24:00,400 --> 00:24:04,630
consume the document list is is more

00:24:02,440 --> 00:24:08,010
simply it's basically the same just

00:24:04,630 --> 00:24:11,760
doesn't count the user and

00:24:08,010 --> 00:24:13,950
and and is attached to a different to

00:24:11,760 --> 00:24:16,350
different group but the logic is is the

00:24:13,950 --> 00:24:17,070
same and the front end is very similar I

00:24:16,350 --> 00:24:19,289
connect

00:24:17,070 --> 00:24:22,409
I listen and then I do different stuff

00:24:19,289 --> 00:24:26,669
according to the two different to the

00:24:22,409 --> 00:24:30,389
different data one important thing to

00:24:26,669 --> 00:24:32,940
know is that you can use channels

00:24:30,389 --> 00:24:35,429
functions outside the channels world by

00:24:32,940 --> 00:24:38,159
using assing to sync you can for example

00:24:35,429 --> 00:24:41,010
in this normal mode model I can just

00:24:38,159 --> 00:24:46,620
send a message to some to some group and

00:24:41,010 --> 00:24:49,529
some consumer will handle it and this is

00:24:46,620 --> 00:24:52,080
awesome because channels 2 doesn't ship

00:24:49,529 --> 00:24:56,250
data binding anymore because it was

00:24:52,080 --> 00:24:59,159
there to say to binding to the cont to

00:24:56,250 --> 00:25:01,380
the community basically to do so it's

00:24:59,159 --> 00:25:03,419
kind of sad but it's it's nice because

00:25:01,380 --> 00:25:08,909
community can come up with other ideas

00:25:03,419 --> 00:25:12,750
and I try to I make an experiment by

00:25:08,909 --> 00:25:16,130
resurrecting a very stupid application I

00:25:12,750 --> 00:25:19,380
I built called Django naka and we'll

00:25:16,130 --> 00:25:21,389
quickly go through it is based on Django

00:25:19,380 --> 00:25:25,019
meta which is a SEO and social media

00:25:21,389 --> 00:25:26,940
social network meter tag library but it

00:25:25,019 --> 00:25:29,940
basically hooks into signal and send

00:25:26,940 --> 00:25:32,909
messages to a default consumer so this

00:25:29,940 --> 00:25:35,100
is the basic class these are some method

00:25:32,909 --> 00:25:36,990
and this is the message we are going to

00:25:35,100 --> 00:25:40,919
send and these are the methods you are

00:25:36,990 --> 00:25:43,620
going to use but again the idea is that

00:25:40,919 --> 00:25:46,950
in the in the mixing because it's mixing

00:25:43,620 --> 00:25:50,309
based you connect on class association

00:25:46,950 --> 00:25:53,220
you connect to the different events

00:25:50,309 --> 00:25:55,940
press a boss save etc the same for for

00:25:53,220 --> 00:25:59,309
delete to a notification function and

00:25:55,940 --> 00:26:03,360
the notification function which interns

00:25:59,309 --> 00:26:05,419
call this method which can decide if a

00:26:03,360 --> 00:26:08,519
knock or a message should be sent

00:26:05,419 --> 00:26:11,789
serialized message and then send this

00:26:08,519 --> 00:26:13,470
this part is executed in Django in your

00:26:11,789 --> 00:26:17,190
normal jungle model because it is a

00:26:13,470 --> 00:26:19,409
normal model mixing and in turns calls

00:26:17,190 --> 00:26:21,330
this very simple consumer who just

00:26:19,409 --> 00:26:23,820
listen on am

00:26:21,330 --> 00:26:25,890
a group I just used a language to have

00:26:23,820 --> 00:26:31,860
different language notification and it

00:26:25,890 --> 00:26:35,610
sent the message to the user it is very

00:26:31,860 --> 00:26:38,490
horrible idea so I expect that next will

00:26:35,610 --> 00:26:40,860
will happen something I don't know maybe

00:26:38,490 --> 00:26:44,010
based on Junqueira sprit moralizer or

00:26:40,860 --> 00:26:46,320
another kind of thing it would be nice

00:26:44,010 --> 00:26:49,370
thing to talk during during the springs

00:26:46,320 --> 00:26:54,180
if you are if you are up to

00:26:49,370 --> 00:26:56,340
so in the end channels make very easy to

00:26:54,180 --> 00:26:59,250
to make use or even to reentered a

00:26:56,340 --> 00:27:01,020
parting I can I have been able to build

00:26:59,250 --> 00:27:03,780
on a synchronous application without

00:27:01,020 --> 00:27:09,630
actually knowing the how to build one

00:27:03,780 --> 00:27:12,270
and so mix danger barrier lower and

00:27:09,630 --> 00:27:14,370
allows you to interact with the Django

00:27:12,270 --> 00:27:18,960
API which is obviously awesome for the

00:27:14,370 --> 00:27:23,780
people in this in this room so thank you

00:27:18,960 --> 00:27:23,780
all and any question

00:27:30,040 --> 00:27:37,730
thank you yeah Cooper we have time for a

00:27:33,830 --> 00:27:39,400
few questions if you have them there's a

00:27:37,730 --> 00:27:43,060
microphone right up at the front here

00:27:39,400 --> 00:27:46,430
okay and I'm getting scared

00:27:43,060 --> 00:27:51,230
hello thank you for doing half my talk

00:27:46,430 --> 00:27:52,970
for me it's very useful no it's my um my

00:27:51,230 --> 00:27:54,770
question view is like you know with with

00:27:52,970 --> 00:27:58,460
all the different things you've seen

00:27:54,770 --> 00:28:00,260
with channels what what part would you

00:27:58,460 --> 00:28:01,580
say still needs work like what what do

00:28:00,260 --> 00:28:05,630
you think is the rough edges without

00:28:01,580 --> 00:28:08,780
stuff still well for maybe no I've not

00:28:05,630 --> 00:28:12,530
alighted it but for example one pitfall

00:28:08,780 --> 00:28:14,690
is that if you don't define a method

00:28:12,530 --> 00:28:17,000
that handle them invent and it might not

00:28:14,690 --> 00:28:19,310
happen you have you don't have any way

00:28:17,000 --> 00:28:21,200
to check this sounds line less you write

00:28:19,310 --> 00:28:24,830
tests obviously but there is no safety

00:28:21,200 --> 00:28:27,050
check in that regarding that so you can

00:28:24,830 --> 00:28:29,240
send a message to a group and then some

00:28:27,050 --> 00:28:32,110
consumer may fail because doesn't handle

00:28:29,240 --> 00:28:36,260
that that kind of event that that bent

00:28:32,110 --> 00:28:40,100
that's that's but it took me a while to

00:28:36,260 --> 00:28:42,110
wrap my head up around channels too

00:28:40,100 --> 00:28:45,020
because I I've made some experiments

00:28:42,110 --> 00:28:47,960
with version one and so basically the

00:28:45,020 --> 00:28:50,870
the whole concepts part is how I try to

00:28:47,960 --> 00:28:55,520
structure my mind around channels too

00:28:50,870 --> 00:28:58,340
but after that is no I I find very easy

00:28:55,520 --> 00:29:04,060
to to work with it so great work thank

00:28:58,340 --> 00:29:04,060
you all there mark more questions

00:29:04,720 --> 00:29:11,980
one two no okay thank you thank you very

00:29:09,680 --> 00:29:11,980
much

00:29:13,580 --> 00:29:15,640

YouTube URL: https://www.youtube.com/watch?v=bhW7wDRtFEY


