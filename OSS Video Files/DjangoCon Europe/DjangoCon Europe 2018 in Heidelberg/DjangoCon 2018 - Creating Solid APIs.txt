Title: DjangoCon 2018 - Creating Solid APIs
Publication date: 2018-05-23
Playlist: DjangoCon Europe 2018 in Heidelberg
Description: 
	https://media.ccc.de/v/hd-73-creating-solid-apis



Increasingly, our apps are used not by humans but by other apps - via their APIs. Thus it is increasingly important that your APIs are well-designed and easy to consume for other developers.
I will share tips and good practices on authentication, versioning, documentation, response structure, and why it all matters.

Adding a few API endpoints to your application for internal consumption is easy. Creating APIs that other developers will love to use is a much harder problem.
You'll need to think about solving variety of topics such as versioning, authentication, response structure, documentation and more. There are existing good practices for each of them, but often developers who haven't done a lot of API work aren't familiar with them.

My talk will show how to build on top of Django and DRF and find reasonable solutions for those problems.
I will talk about JSON API, OAuth2, and other technologies and show how they fit into the puzzle.
Benefits of standardized response structure, as well as auto-generated documentation will also be discussed.

I'll introduce OAuth2, discussing when it is a good choice and when not, as well as some trickier parts of it.
Next we'll look at why a standardized response structure such as JSON API makes lives of 3rd-party developers easier. We'll then move on to versioning and how you can change your API without breaking all existing apps. And the talk wouldn't be complete without looking at documenting your APIs and why the docs should be auto-generated.

Rivo Laks
Captions: 
	00:00:06,250 --> 00:00:11,139
api's are not just used by humans did

00:00:08,740 --> 00:00:12,519
you know that you need to make sure that

00:00:11,139 --> 00:00:14,940
there's authentication versioning

00:00:12,519 --> 00:00:14,940
document

00:00:15,010 --> 00:00:27,880
boats so Rheem is gonna tell us all

00:00:17,560 --> 00:00:31,060
about that thank you and good afternoon

00:00:27,880 --> 00:00:35,199
I am Revo and this is my talk on how to

00:00:31,060 --> 00:00:37,420
create solid api's our applications are

00:00:35,199 --> 00:00:40,059
increasingly being used not by humans

00:00:37,420 --> 00:00:42,910
but by other applications via their

00:00:40,059 --> 00:00:46,809
api's api's are eating the world they

00:00:42,910 --> 00:00:50,170
say but ironically api's themselves are

00:00:46,809 --> 00:00:52,150
first always used by humans by the other

00:00:50,170 --> 00:00:55,510
developers who are integrating with your

00:00:52,150 --> 00:00:58,120
application and this means that your api

00:00:55,510 --> 00:01:02,010
is must target not just machines but

00:00:58,120 --> 00:01:04,809
even more importantly humans as well I

00:01:02,010 --> 00:01:06,720
come from Thor gate a product

00:01:04,809 --> 00:01:09,340
development agency based in Estonia

00:01:06,720 --> 00:01:12,960
we're working on various applications

00:01:09,340 --> 00:01:16,690
mostly using Python Django and react and

00:01:12,960 --> 00:01:19,570
various other technologies this talk was

00:01:16,690 --> 00:01:22,540
inspired by a project where API had top

00:01:19,570 --> 00:01:24,730
priority from day one the focus was on

00:01:22,540 --> 00:01:28,180
creating a platform for managing

00:01:24,730 --> 00:01:30,370
forestry related data and other

00:01:28,180 --> 00:01:32,890
developers had to be able to interface

00:01:30,370 --> 00:01:37,030
with it fetch the data do various

00:01:32,890 --> 00:01:39,220
operations on it and the UI itself also

00:01:37,030 --> 00:01:44,320
had to be built on top of the publicly

00:01:39,220 --> 00:01:47,170
available API provided by us now as most

00:01:44,320 --> 00:01:50,230
developers I had used and even created

00:01:47,170 --> 00:01:54,390
api's before but this project had higher

00:01:50,230 --> 00:01:58,630
demands and so it got me thinking what

00:01:54,390 --> 00:02:01,230
does it take to create the api's that

00:01:58,630 --> 00:02:06,880
other developers would love to use and

00:02:01,230 --> 00:02:09,539
this talk aims to share what I found so

00:02:06,880 --> 00:02:12,340
let's begin with the definition of API

00:02:09,539 --> 00:02:15,819
usually it's defined as application

00:02:12,340 --> 00:02:17,709
programming interface but a better

00:02:15,819 --> 00:02:21,069
definition might be application

00:02:17,709 --> 00:02:23,560
programmer interface because when you

00:02:21,069 --> 00:02:27,360
think about it an API is basically a

00:02:23,560 --> 00:02:31,170
user interface for other developers

00:02:27,360 --> 00:02:33,120
and that brings us to the question how

00:02:31,170 --> 00:02:41,730
do you make that user interface really

00:02:33,120 --> 00:02:45,030
good one quickly covering what I'm going

00:02:41,730 --> 00:02:47,490
to talk more in depth about I think that

00:02:45,030 --> 00:02:50,990
good API should have documentation that

00:02:47,490 --> 00:02:54,570
is not just out there but also helpful I

00:02:50,990 --> 00:02:57,210
think that it's very important to use

00:02:54,570 --> 00:03:01,190
standards to bring familiarity to your

00:02:57,210 --> 00:03:03,570
users and get them started Foster and

00:03:01,190 --> 00:03:05,430
you should make sure that the user has

00:03:03,570 --> 00:03:09,570
to deal with as little issues as

00:03:05,430 --> 00:03:12,540
possible meaning lack of friction this

00:03:09,570 --> 00:03:15,290
talk focuses on the Web API is but much

00:03:12,540 --> 00:03:18,960
of the topic is also applicable to

00:03:15,290 --> 00:03:23,640
packages and libraries and code bases in

00:03:18,960 --> 00:03:26,730
general as well so let's begin with the

00:03:23,640 --> 00:03:28,980
documentation it's too often overlooked

00:03:26,730 --> 00:03:31,410
we don't really want to do this because

00:03:28,980 --> 00:03:34,470
it's not the fun part at least when

00:03:31,410 --> 00:03:36,090
we're developing but when you're trying

00:03:34,470 --> 00:03:38,250
to make sense of something created by

00:03:36,090 --> 00:03:40,770
others or even by yourself

00:03:38,250 --> 00:03:44,220
a while ago then documentation becomes

00:03:40,770 --> 00:03:46,860
much more important documentation is

00:03:44,220 --> 00:03:51,300
also often the first point of contact

00:03:46,860 --> 00:03:53,489
that people have with your API so that

00:03:51,300 --> 00:03:57,030
means that they could decide whether to

00:03:53,489 --> 00:03:59,130
stick with your API or go looking go on

00:03:57,030 --> 00:04:01,680
looking for alternatives based on just

00:03:59,130 --> 00:04:03,420
that I do the same myself all the time

00:04:01,680 --> 00:04:05,520
when I'm looking for a solution to some

00:04:03,420 --> 00:04:08,640
common problem and there are usually

00:04:05,520 --> 00:04:10,739
variety of packages available and then

00:04:08,640 --> 00:04:12,959
the first impression of the readme as

00:04:10,739 --> 00:04:16,190
well as the documentation is quite

00:04:12,959 --> 00:04:19,230
important deciding factor and

00:04:16,190 --> 00:04:21,600
documentation thoughts take effort and I

00:04:19,230 --> 00:04:24,180
admit that I'm not that good at doing

00:04:21,600 --> 00:04:26,970
them myself either but that does not

00:04:24,180 --> 00:04:29,160
mean that we shouldn't try and if you

00:04:26,970 --> 00:04:31,500
only took just single thing from my talk

00:04:29,160 --> 00:04:34,919
then I guess then I think that it should

00:04:31,500 --> 00:04:38,060
be that documentation is really worth

00:04:34,919 --> 00:04:38,060
putting some effort into

00:04:38,909 --> 00:04:44,919
so now that we know that documentation

00:04:42,309 --> 00:04:49,240
is sort of like sales pages for your API

00:04:44,919 --> 00:04:53,429
or packages let's think about how to

00:04:49,240 --> 00:04:53,429
make those sales pages really awesome

00:04:54,689 --> 00:05:02,770
when I first start looking at some API

00:04:58,059 --> 00:05:04,809
or API documentation what do I want

00:05:02,770 --> 00:05:07,899
there to be what should go in this

00:05:04,809 --> 00:05:12,369
documentation one of my first questions

00:05:07,899 --> 00:05:13,899
is how do I even access it do I need to

00:05:12,369 --> 00:05:17,740
sign up for some developer account

00:05:13,899 --> 00:05:21,580
before I can start poking at it

00:05:17,740 --> 00:05:23,729
what is the root URL of the API if your

00:05:21,580 --> 00:05:26,919
API has browsable

00:05:23,729 --> 00:05:29,830
possible interface and does not require

00:05:26,919 --> 00:05:31,779
any authentication then I can just take

00:05:29,830 --> 00:05:34,949
this root URL put it into the browser

00:05:31,779 --> 00:05:37,300
and start looking around immediately I

00:05:34,949 --> 00:05:39,639
also want to know what the

00:05:37,300 --> 00:05:43,479
authentication options or requirements

00:05:39,639 --> 00:05:45,430
are do I need to use something like go

00:05:43,479 --> 00:05:49,300
out do you have some custom token

00:05:45,430 --> 00:05:52,180
authentication and then there are some

00:05:49,300 --> 00:05:54,999
generic sort of mundane stuff that often

00:05:52,180 --> 00:05:58,300
goes overlooked like character formats

00:05:54,999 --> 00:06:02,139
or encoding x' in python world we're

00:05:58,300 --> 00:06:04,389
quite used to utf-8 everywhere but when

00:06:02,139 --> 00:06:06,789
you have external developers interfacing

00:06:04,389 --> 00:06:11,289
with your code then they might have

00:06:06,789 --> 00:06:14,289
quite different options or experiences

00:06:11,289 --> 00:06:16,149
about the character encodings and so you

00:06:14,289 --> 00:06:19,479
should always make it explicit in your

00:06:16,149 --> 00:06:23,050
documentation the same goes for stuff

00:06:19,479 --> 00:06:25,990
like timestamp formats either 8601 is

00:06:23,050 --> 00:06:27,819
quite commonly used but again it's

00:06:25,990 --> 00:06:31,869
better made explicit in the

00:06:27,819 --> 00:06:34,539
documentation I also want to know how

00:06:31,869 --> 00:06:39,099
stuff like pagination or versioning

00:06:34,539 --> 00:06:40,709
works and I want to know about the

00:06:39,099 --> 00:06:44,039
common errors that I might encounter

00:06:40,709 --> 00:06:46,269
this means that if I do get an error I

00:06:44,039 --> 00:06:48,729
can immediately come back to your

00:06:46,269 --> 00:06:51,830
documentation and for example find out

00:06:48,729 --> 00:06:55,180
that I'm sending the authentication

00:06:51,830 --> 00:06:59,030
in an in an invalid way and instead of

00:06:55,180 --> 00:07:01,790
spending my time trying to work out the

00:06:59,030 --> 00:07:04,340
solution myself I immediately have your

00:07:01,790 --> 00:07:08,710
documentation as the main anchor point

00:07:04,340 --> 00:07:10,850
of sorts and perhaps most importantly

00:07:08,710 --> 00:07:13,580
include some code that I can immediately

00:07:10,850 --> 00:07:15,980
copy and paste and get started as soon

00:07:13,580 --> 00:07:19,610
as possible because even if it's just

00:07:15,980 --> 00:07:22,550
copy pasted code if it's running and

00:07:19,610 --> 00:07:24,680
works then it gives this sort of warm

00:07:22,550 --> 00:07:27,590
and fuzzy feeling to to your users and

00:07:24,680 --> 00:07:33,770
they are much more likely to keep using

00:07:27,590 --> 00:07:35,590
your API you probably also have

00:07:33,770 --> 00:07:39,860
different end points for different

00:07:35,590 --> 00:07:43,510
resources in your API so what do I want

00:07:39,860 --> 00:07:47,360
to know about each of those first of all

00:07:43,510 --> 00:07:49,850
the URL of the endpoint I also want to

00:07:47,360 --> 00:07:52,970
know what operations can be done with

00:07:49,850 --> 00:07:56,260
that resource for example you might have

00:07:52,970 --> 00:07:59,750
listing and perhaps a detail view and

00:07:56,260 --> 00:08:03,290
perhaps I can also update the data of

00:07:59,750 --> 00:08:05,210
the objects for each of those I also

00:08:03,290 --> 00:08:08,450
want to know what request and response

00:08:05,210 --> 00:08:11,270
data looks like so this is this is

00:08:08,450 --> 00:08:14,960
especially important for more

00:08:11,270 --> 00:08:17,479
complicated operations like update where

00:08:14,960 --> 00:08:21,800
I have to potentially specify lots of

00:08:17,479 --> 00:08:24,650
data which can be in some quite

00:08:21,800 --> 00:08:27,590
complicated format and I want to

00:08:24,650 --> 00:08:31,580
immediately see the structure of that

00:08:27,590 --> 00:08:34,400
format there might also be some optional

00:08:31,580 --> 00:08:37,909
parameters available for example the

00:08:34,400 --> 00:08:41,690
ListView might be sortable and I want to

00:08:37,909 --> 00:08:43,610
know how how can i specify what to sort

00:08:41,690 --> 00:08:46,940
it by or if we're talking about

00:08:43,610 --> 00:08:49,130
filtering then you might have different

00:08:46,940 --> 00:08:51,980
filtering options available but with

00:08:49,130 --> 00:08:57,460
some constraints and it always pays to

00:08:51,980 --> 00:09:00,530
list those out there might also be some

00:08:57,460 --> 00:09:03,020
permissions involved for example as an

00:09:00,530 --> 00:09:04,880
administrator I might be able to change

00:09:03,020 --> 00:09:08,450
all the objects

00:09:04,880 --> 00:09:12,200
but less privileged users can only view

00:09:08,450 --> 00:09:15,280
them or perhaps update only a partial

00:09:12,200 --> 00:09:15,280
set of the attributes

00:09:20,450 --> 00:09:25,490
the only thing that's worse than lack of

00:09:23,540 --> 00:09:28,310
documentation though is when that

00:09:25,490 --> 00:09:32,570
documentation is outdated so how do you

00:09:28,310 --> 00:09:35,870
keep it fresh the answer for me is in

00:09:32,570 --> 00:09:37,459
out degeneration I think that your

00:09:35,870 --> 00:09:39,860
documentation should always be

00:09:37,459 --> 00:09:43,790
automatically generated based on the

00:09:39,860 --> 00:09:46,760
code itself which sort of implicitly

00:09:43,790 --> 00:09:51,949
means that that you are always in sync

00:09:46,760 --> 00:09:54,170
and usually the approach that I'm using

00:09:51,949 --> 00:09:56,899
at least is that you start with the code

00:09:54,170 --> 00:09:59,149
itself then based on the code you

00:09:56,899 --> 00:10:02,060
generate schema which is basically

00:09:59,149 --> 00:10:05,389
machine readable documentation for your

00:10:02,060 --> 00:10:07,490
API listing all the same endpoints as

00:10:05,389 --> 00:10:09,980
well as their potential parameters and

00:10:07,490 --> 00:10:10,790
so on and so forth and then based on

00:10:09,980 --> 00:10:14,360
that schema

00:10:10,790 --> 00:10:18,920
you can further generate the user user

00:10:14,360 --> 00:10:21,040
oriented documentation there are

00:10:18,920 --> 00:10:24,620
different standards available for those

00:10:21,040 --> 00:10:25,699
the most common perhaps are open api and

00:10:24,620 --> 00:10:27,980
swagger

00:10:25,699 --> 00:10:31,339
the front end that gives you nice

00:10:27,980 --> 00:10:33,050
interactive documentation but i would

00:10:31,339 --> 00:10:36,459
say that most importantly you should

00:10:33,050 --> 00:10:38,899
just figure out what your tools support

00:10:36,459 --> 00:10:41,720
for example if you're using Django rest

00:10:38,899 --> 00:10:43,970
framework then there are variety of

00:10:41,720 --> 00:10:46,760
packages available which either provides

00:10:43,970 --> 00:10:50,660
swagger integration or a different form

00:10:46,760 --> 00:10:55,100
of how to generated and or interactive

00:10:50,660 --> 00:10:58,640
documentation and it's nice if your

00:10:55,100 --> 00:11:02,660
documentation also provides those same

00:10:58,640 --> 00:11:05,269
code examples next to the text so that

00:11:02,660 --> 00:11:07,940
if I'm dealing with some end point that

00:11:05,269 --> 00:11:10,459
perhaps I haven't used before then I can

00:11:07,940 --> 00:11:15,279
immediately copy/paste the Python code

00:11:10,459 --> 00:11:17,779
and again get rolling much faster

00:11:15,279 --> 00:11:19,730
finally if you already have that scheme

00:11:17,779 --> 00:11:23,060
available then you can also use it for

00:11:19,730 --> 00:11:25,760
some more as a Taric things like you can

00:11:23,060 --> 00:11:27,860
also generate client libraries this

00:11:25,760 --> 00:11:31,040
means that your users don't have to make

00:11:27,860 --> 00:11:33,410
the HTTP requests themselves anymore but

00:11:31,040 --> 00:11:34,279
instead they can use a friendlier Python

00:11:33,410 --> 00:11:37,129
package

00:11:34,279 --> 00:11:39,370
again is automatically in sync with your

00:11:37,129 --> 00:11:39,370
code

00:11:44,280 --> 00:11:50,520
next let's talk about standards

00:11:47,400 --> 00:11:53,230
standardization and why that matters

00:11:50,520 --> 00:11:56,440
following standards is good because it

00:11:53,230 --> 00:11:58,150
gives your users a sense of familiarity

00:11:56,440 --> 00:12:00,570
if you create something that's

00:11:58,150 --> 00:12:02,950
completely unique and handcraft it then

00:12:00,570 --> 00:12:05,680
your users will have to learn everything

00:12:02,950 --> 00:12:08,200
about it but if instead you follow some

00:12:05,680 --> 00:12:10,990
widespread standards then they probably

00:12:08,200 --> 00:12:13,420
already have have experience with

00:12:10,990 --> 00:12:15,460
something that that is either using the

00:12:13,420 --> 00:12:17,320
same standard or something similar and

00:12:15,460 --> 00:12:21,640
then they can transfer this knowledge

00:12:17,320 --> 00:12:23,830
onto using your API and just as

00:12:21,640 --> 00:12:26,890
importantly standards usually have some

00:12:23,830 --> 00:12:29,370
thoughts already put into them and they

00:12:26,890 --> 00:12:31,930
will help you avoid some common pitfalls

00:12:29,370 --> 00:12:35,080
this is quite similar to how frameworks

00:12:31,930 --> 00:12:37,630
make decisions for you such as how to

00:12:35,080 --> 00:12:40,300
store passwords for example and they

00:12:37,630 --> 00:12:46,090
thus keep you safe from storing them in

00:12:40,300 --> 00:12:47,920
securely and when it comes to api's my

00:12:46,090 --> 00:12:50,010
current standard of choice is chasing

00:12:47,920 --> 00:12:52,780
API

00:12:50,010 --> 00:12:55,600
despite the perhaps unfortunate name

00:12:52,780 --> 00:12:59,230
chasing API is not just an API that uses

00:12:55,600 --> 00:13:01,540
Chasen in its responses but instead it's

00:12:59,230 --> 00:13:05,230
an actual specification for building

00:13:01,540 --> 00:13:08,140
api's it was created by outdoors of

00:13:05,230 --> 00:13:11,850
ember and it offers quite comprehensive

00:13:08,140 --> 00:13:14,560
solution to building efficient api's and

00:13:11,850 --> 00:13:17,310
I should stress that this is just one

00:13:14,560 --> 00:13:20,520
option of several which are available

00:13:17,310 --> 00:13:23,410
for example craft QL largely

00:13:20,520 --> 00:13:25,720
accomplishes the same goals and there is

00:13:23,410 --> 00:13:27,040
a craft ul talk coming up on Friday so

00:13:25,720 --> 00:13:29,070
you might be interested in that one as

00:13:27,040 --> 00:13:29,070
well

00:13:29,790 --> 00:13:35,710
one of the most important aspects of

00:13:32,170 --> 00:13:38,590
chasing API is that it defines a generic

00:13:35,710 --> 00:13:42,040
yet flexible structure for the API

00:13:38,590 --> 00:13:44,830
responses so let's look at how those

00:13:42,040 --> 00:13:48,640
structures how those responses are

00:13:44,830 --> 00:13:51,310
structured I'm going to use a project

00:13:48,640 --> 00:13:54,580
management tool of sorts as an example

00:13:51,310 --> 00:13:57,190
project it basically lets users define

00:13:54,580 --> 00:13:57,790
projects and ten epochs within those

00:13:57,190 --> 00:14:01,180
projects

00:13:57,790 --> 00:14:04,470
and stories within the epics kind of

00:14:01,180 --> 00:14:04,470
similar to help Basecamp works

00:14:07,990 --> 00:14:14,530
so here we can see that the client makes

00:14:10,570 --> 00:14:16,600
requests to the projects listing and the

00:14:14,530 --> 00:14:20,380
response document has three top-level

00:14:16,600 --> 00:14:23,110
members the links the data and the

00:14:20,380 --> 00:14:28,150
included and let's look at those one by

00:14:23,110 --> 00:14:31,150
one first the links they are important

00:14:28,150 --> 00:14:34,030
because they enable discovery of related

00:14:31,150 --> 00:14:36,820
endpoints in this case because we asked

00:14:34,030 --> 00:14:40,360
for list of projects then the responses

00:14:36,820 --> 00:14:42,690
paginated and the next link allows us to

00:14:40,360 --> 00:14:44,950
very easily get the next page of results

00:14:42,690 --> 00:14:47,080
the client here doesn't really need to

00:14:44,950 --> 00:14:49,420
know about how the server side handles

00:14:47,080 --> 00:14:53,940
this it just has to know that it needs

00:14:49,420 --> 00:14:59,170
to follow the link in the same fashion

00:14:53,940 --> 00:15:01,480
your route URL of the API should respond

00:14:59,170 --> 00:15:06,010
with links to each of the individual

00:15:01,480 --> 00:15:07,960
resource pages so that means that as a

00:15:06,010 --> 00:15:10,030
user of the API I don't need to know

00:15:07,960 --> 00:15:12,520
which endpoints or resources are

00:15:10,030 --> 00:15:17,860
available I can just ask the route URL

00:15:12,520 --> 00:15:20,530
and find out that way next up we have

00:15:17,860 --> 00:15:23,620
data which contains the so called

00:15:20,530 --> 00:15:27,430
primary data the resource resources that

00:15:23,620 --> 00:15:29,890
you asked for and in this case we ask

00:15:27,430 --> 00:15:33,310
for a list of projects so the data

00:15:29,890 --> 00:15:35,710
itself is a list as well if we ask for

00:15:33,310 --> 00:15:40,650
one specific project it would be just

00:15:35,710 --> 00:15:44,080
one JSON object and as you can see each

00:15:40,650 --> 00:15:47,170
resource has type and ID which you need

00:15:44,080 --> 00:15:50,740
to identify it and they can also include

00:15:47,170 --> 00:15:54,550
links in this case we get linked to that

00:15:50,740 --> 00:15:57,790
detail page of this one project and we

00:15:54,550 --> 00:16:00,550
can use the same detail link to update

00:15:57,790 --> 00:16:02,620
it for example or delete it or do

00:16:00,550 --> 00:16:07,150
anything else that requires this one

00:16:02,620 --> 00:16:08,470
specific project next up are the

00:16:07,150 --> 00:16:09,460
attributes which are quite

00:16:08,470 --> 00:16:12,400
self-explanatory

00:16:09,460 --> 00:16:15,610
in this case we get the project's

00:16:12,400 --> 00:16:17,920
creation timestamp which uses the ISO

00:16:15,610 --> 00:16:19,340
standard as well as the project's name

00:16:17,920 --> 00:16:23,900
and description

00:16:19,340 --> 00:16:27,260
and the resources can also have related

00:16:23,900 --> 00:16:31,580
objects under the relationships object

00:16:27,260 --> 00:16:34,250
so let's take a look at those next you

00:16:31,580 --> 00:16:38,210
can see that the project here has first

00:16:34,250 --> 00:16:43,220
of all created by a sort of foreign key

00:16:38,210 --> 00:16:47,600
or relation which is a user with ID 199

00:16:43,220 --> 00:16:50,330
and then it has a list of epochs this

00:16:47,600 --> 00:16:52,550
list is only a single has only a single

00:16:50,330 --> 00:16:59,450
element at the moment the epoch with ID

00:16:52,550 --> 00:17:01,730
3 1 0 1 and the idea between those

00:16:59,450 --> 00:17:04,150
relationships is that you can use the

00:17:01,730 --> 00:17:08,750
type and ID which again uniquely

00:17:04,150 --> 00:17:11,360
identify this resource to look up the

00:17:08,750 --> 00:17:15,800
related objects in the included

00:17:11,360 --> 00:17:23,270
resources and included resources is the

00:17:15,800 --> 00:17:27,709
third top-level key that we looked at in

00:17:23,270 --> 00:17:30,560
this case we have two related objects

00:17:27,709 --> 00:17:32,480
included in the data here the first is

00:17:30,560 --> 00:17:35,180
the same epoch and the second is the

00:17:32,480 --> 00:17:37,220
user and both of those look exactly like

00:17:35,180 --> 00:17:39,890
the primary data looked they have type

00:17:37,220 --> 00:17:42,470
and ID and they can have attributes and

00:17:39,890 --> 00:17:47,720
links and also relationships of their

00:17:42,470 --> 00:17:49,520
own now why is that important because it

00:17:47,720 --> 00:17:52,360
means that you only have to make a

00:17:49,520 --> 00:17:56,720
single Network request most of the time

00:17:52,360 --> 00:18:00,410
meaning that if I want to show details

00:17:56,720 --> 00:18:03,740
page of a project for example and I want

00:18:00,410 --> 00:18:06,500
to list the epochs of each project on

00:18:03,740 --> 00:18:08,510
that details page then using this

00:18:06,500 --> 00:18:10,970
approach I only need to make a single

00:18:08,510 --> 00:18:13,300
Network request and I get all the data

00:18:10,970 --> 00:18:15,350
that I'm interested in back immediately

00:18:13,300 --> 00:18:18,500
without having to make follow-up

00:18:15,350 --> 00:18:21,500
requests and this is very important if

00:18:18,500 --> 00:18:24,650
your application is for example a mobile

00:18:21,500 --> 00:18:28,420
network mobile application which is

00:18:24,650 --> 00:18:28,420
working on a potentially slow Network

00:18:29,190 --> 00:18:35,500
so how did that make you feel if you

00:18:33,640 --> 00:18:38,950
haven't used JSON API before then

00:18:35,500 --> 00:18:42,250
perhaps it looked a bit weird or bloated

00:18:38,950 --> 00:18:44,800
even if I wanted to receive the name of

00:18:42,250 --> 00:18:46,840
the user that created a project then

00:18:44,800 --> 00:18:51,340
there are quite a few layers of

00:18:46,840 --> 00:18:52,780
indirection to jump through and yet if I

00:18:51,340 --> 00:18:56,080
now give you a response for another

00:18:52,780 --> 00:18:59,500
object from that same API and told you

00:18:56,080 --> 00:19:01,990
that it had updated pi field which is

00:18:59,500 --> 00:19:04,809
also a user and I'm interested in the

00:19:01,990 --> 00:19:07,420
email of that user then you would know

00:19:04,809 --> 00:19:09,460
exactly how to do that because the data

00:19:07,420 --> 00:19:11,250
would be structured in exactly the same

00:19:09,460 --> 00:19:13,750
way

00:19:11,250 --> 00:19:16,870
furthermore if I gave you a different

00:19:13,750 --> 00:19:19,150
API completely unrelated to this one and

00:19:16,870 --> 00:19:21,760
told that that one uses the Chasen API

00:19:19,150 --> 00:19:25,690
as well then you would know how to use

00:19:21,760 --> 00:19:28,150
that other API as well and that is the

00:19:25,690 --> 00:19:30,790
power of Standardization it brings

00:19:28,150 --> 00:19:33,400
familiarity and makes concepts that you

00:19:30,790 --> 00:19:38,110
already know applicable to something new

00:19:33,400 --> 00:19:42,090
as well so let's look at some more

00:19:38,110 --> 00:19:42,090
features of JSON API

00:19:44,799 --> 00:19:52,429
the included objects or related objects

00:19:49,250 --> 00:19:55,610
they are actually configurable so the

00:19:52,429 --> 00:19:58,250
first get request here gives you the

00:19:55,610 --> 00:20:00,440
results that I already showed you but if

00:19:58,250 --> 00:20:03,470
you're interested in comments of each

00:20:00,440 --> 00:20:05,330
project then you can say that you want

00:20:03,470 --> 00:20:08,240
the comments to be included as well and

00:20:05,330 --> 00:20:11,770
again you don't have to make any extra

00:20:08,240 --> 00:20:14,210
network requests to get them and you can

00:20:11,770 --> 00:20:17,720
customize not only to include it data

00:20:14,210 --> 00:20:20,929
but fields for each resource type as

00:20:17,720 --> 00:20:23,750
well so the third example here says that

00:20:20,929 --> 00:20:27,559
for projects you're only interested in

00:20:23,750 --> 00:20:31,520
name and the comments and again this is

00:20:27,559 --> 00:20:34,580
important if you're building clients for

00:20:31,520 --> 00:20:36,919
slow networks where basically each byte

00:20:34,580 --> 00:20:40,450
matters and you don't want to send data

00:20:36,919 --> 00:20:40,450
over the network that you won't be using

00:20:43,870 --> 00:20:51,559
you already briefly saw the pagination

00:20:46,730 --> 00:20:54,110
style the list responses basically have

00:20:51,559 --> 00:20:56,660
next and traveling's which the client

00:20:54,110 --> 00:20:58,520
only has to follow and this means that

00:20:56,660 --> 00:21:02,840
the client doesn't really have to know

00:20:58,520 --> 00:21:04,820
or care about how the server implements

00:21:02,840 --> 00:21:07,970
pagination or what pagination style is

00:21:04,820 --> 00:21:10,370
used in my example I'm using cursor

00:21:07,970 --> 00:21:13,610
based data nation because I sort of like

00:21:10,370 --> 00:21:16,130
it it solves many issues for example

00:21:13,610 --> 00:21:19,010
when you get new objects heading into

00:21:16,130 --> 00:21:21,830
the database but depending on the

00:21:19,010 --> 00:21:24,140
application type it might be that you

00:21:21,830 --> 00:21:26,780
want to use page number based pagination

00:21:24,140 --> 00:21:29,360
and again for the clients it would only

00:21:26,780 --> 00:21:32,600
it would only mean that the next link

00:21:29,360 --> 00:21:35,510
would look slightly different but they

00:21:32,600 --> 00:21:39,490
wouldn't need to know how to implement

00:21:35,510 --> 00:21:39,490
this particular paging style themselves

00:21:40,870 --> 00:21:47,120
chasing API also specifies to some

00:21:44,660 --> 00:21:51,710
extent how to do stuff like filtering

00:21:47,120 --> 00:21:54,800
and ordering on list views but also they

00:21:51,710 --> 00:21:59,930
are sort of implementation-dependent to

00:21:54,800 --> 00:22:03,890
some extent anyway let's talk about

00:21:59,930 --> 00:22:05,720
errors errors happen and you can't

00:22:03,890 --> 00:22:08,390
really protect against that but what you

00:22:05,720 --> 00:22:10,790
can do is making it easy for the user to

00:22:08,390 --> 00:22:14,540
figure out why something happened and

00:22:10,790 --> 00:22:17,630
how to fix it and again the goal here is

00:22:14,540 --> 00:22:19,670
to basically reduce friction so that the

00:22:17,630 --> 00:22:22,430
user wouldn't throw up their hands and

00:22:19,670 --> 00:22:26,230
walk away but instead would get help as

00:22:22,430 --> 00:22:30,830
as easily and as quickly as possible and

00:22:26,230 --> 00:22:34,580
the way chasing API returns errors is

00:22:30,830 --> 00:22:37,040
that if something goes wrong the results

00:22:34,580 --> 00:22:40,160
or the response will contain top-level

00:22:37,040 --> 00:22:43,490
error ski which is list of everything

00:22:40,160 --> 00:22:44,990
that went wrong and in this case we can

00:22:43,490 --> 00:22:48,170
see that there was some invalid

00:22:44,990 --> 00:22:50,750
attribute the detail here is something

00:22:48,170 --> 00:22:53,000
that you might show to the user saying

00:22:50,750 --> 00:22:56,660
name must contain at least three letters

00:22:53,000 --> 00:22:58,970
and then the source is something that's

00:22:56,660 --> 00:23:01,220
machine readable and which you can use

00:22:58,970 --> 00:23:05,710
to find out for example the exact form

00:23:01,220 --> 00:23:05,710
field where the problem originated from

00:23:10,220 --> 00:23:15,570
there are also some special cases for

00:23:13,650 --> 00:23:18,810
example when you want to transmit the

00:23:15,570 --> 00:23:21,990
large amount of data and in those cases

00:23:18,810 --> 00:23:24,240
maybe Jason API does not make sense and

00:23:21,990 --> 00:23:26,460
you need different perhaps more

00:23:24,240 --> 00:23:29,010
specialized format

00:23:26,460 --> 00:23:32,190
I should note though that the Jason API

00:23:29,010 --> 00:23:35,100
is responses or rather all the Chasen

00:23:32,190 --> 00:23:37,530
responses should be compressed and that

00:23:35,100 --> 00:23:39,720
means that the plotinus that you sort of

00:23:37,530 --> 00:23:42,480
see when looking at the requests it

00:23:39,720 --> 00:23:46,140
might not actually be a problem or it is

00:23:42,480 --> 00:23:50,160
not as much of a problem as you might

00:23:46,140 --> 00:23:53,310
think but an even better solution might

00:23:50,160 --> 00:23:57,030
be you still use JSON API and just

00:23:53,310 --> 00:24:00,690
include link to the actual raw data in

00:23:57,030 --> 00:24:03,840
your main API response so sort of moving

00:24:00,690 --> 00:24:07,200
to date out of panned and chase an API

00:24:03,840 --> 00:24:10,560
already has the links object that you

00:24:07,200 --> 00:24:12,600
could use to implement it and here's an

00:24:10,560 --> 00:24:15,900
example of an application that does

00:24:12,600 --> 00:24:19,020
something with data set and we ask for

00:24:15,900 --> 00:24:22,140
specific data set here what we get in

00:24:19,020 --> 00:24:26,070
response is sort of metadata and then

00:24:22,140 --> 00:24:28,260
there is a link to data DG set which is

00:24:26,070 --> 00:24:32,720
the actual raw data that the client can

00:24:28,260 --> 00:24:32,720
then follow and download and use

00:24:35,420 --> 00:24:42,540
so to wrap up the standardization part I

00:24:38,940 --> 00:24:45,150
want to once again stress that that

00:24:42,540 --> 00:24:48,000
specific standard is not that important

00:24:45,150 --> 00:24:50,700
I like chasing API if you look if you

00:24:48,000 --> 00:24:53,610
like craft QL for example that's cool

00:24:50,700 --> 00:24:55,500
too but the important part is that you

00:24:53,610 --> 00:24:58,730
give users something that they might

00:24:55,500 --> 00:24:58,730
already be familiar with

00:25:01,970 --> 00:25:08,760
now most api's don't deal with just

00:25:05,910 --> 00:25:10,890
public data or even if they do you still

00:25:08,760 --> 00:25:13,160
might want to be able to identify the

00:25:10,890 --> 00:25:16,190
clients for various purposes like

00:25:13,160 --> 00:25:18,540
request limits or something similar and

00:25:16,190 --> 00:25:20,820
that means that you need to think about

00:25:18,540 --> 00:25:23,550
the authentication how do you identify

00:25:20,820 --> 00:25:26,610
who is making the request as well as

00:25:23,550 --> 00:25:30,990
authorization which is what is this

00:25:26,610 --> 00:25:33,090
particular user allowed to access the

00:25:30,990 --> 00:25:35,640
best practice here depends largely on

00:25:33,090 --> 00:25:39,060
the use case I will be covering two

00:25:35,640 --> 00:25:41,370
major options the first one is token

00:25:39,060 --> 00:25:44,340
authentication this is the simple one

00:25:41,370 --> 00:25:47,220
where clients basically send an HTTP

00:25:44,340 --> 00:25:50,450
HTTP header containing a simple token

00:25:47,220 --> 00:25:50,450
with each request

00:25:53,010 --> 00:25:58,870
token authentication is useful for

00:25:55,420 --> 00:26:00,640
client-server situations where the

00:25:58,870 --> 00:26:03,820
client is for example a native mobile

00:26:00,640 --> 00:26:06,750
application and when the user logs into

00:26:03,820 --> 00:26:09,400
that mobile application then the

00:26:06,750 --> 00:26:12,160
application will get the users

00:26:09,400 --> 00:26:15,550
authorization token which is then sent

00:26:12,160 --> 00:26:17,890
with each subsequent request and test

00:26:15,550 --> 00:26:21,460
server knows that the request comes from

00:26:17,890 --> 00:26:24,280
this specific user and if you think

00:26:21,460 --> 00:26:28,390
about the ten session cookies are also

00:26:24,280 --> 00:26:30,309
basically one kind of tokens so it might

00:26:28,390 --> 00:26:32,050
be that your API is only ever accessed

00:26:30,309 --> 00:26:33,820
from the browsers and in that case

00:26:32,050 --> 00:26:37,240
session cookies might actually be

00:26:33,820 --> 00:26:40,440
everything you need if you're using

00:26:37,240 --> 00:26:43,840
Django rest framework then once again

00:26:40,440 --> 00:26:46,360
know your to link rest framework already

00:26:43,840 --> 00:26:50,920
has built-in support for token

00:26:46,360 --> 00:26:53,760
authentication for more complicated

00:26:50,920 --> 00:26:57,750
situations though there is a wealth to

00:26:53,760 --> 00:27:01,300
what is meant for creating platforms

00:26:57,750 --> 00:27:03,100
think Facebook where a third party

00:27:01,300 --> 00:27:05,730
application can request access to the

00:27:03,100 --> 00:27:09,070
users data and then the platform

00:27:05,730 --> 00:27:12,309
verifies this request and asks for the

00:27:09,070 --> 00:27:14,620
users permission and then grants the

00:27:12,309 --> 00:27:17,380
application a token which is both

00:27:14,620 --> 00:27:22,720
application specific as well as user

00:27:17,380 --> 00:27:25,090
specific what do is quite complex

00:27:22,720 --> 00:27:28,870
protocol it covers many different use

00:27:25,090 --> 00:27:31,440
cases and flows like for mobile

00:27:28,870 --> 00:27:33,610
applications web applications

00:27:31,440 --> 00:27:36,540
applications which might be in your

00:27:33,610 --> 00:27:39,460
living room and have very limited UI and

00:27:36,540 --> 00:27:42,520
it's good because once again you will be

00:27:39,460 --> 00:27:45,610
you will be using proven standards that

00:27:42,520 --> 00:27:48,640
have evolved over the years and have a

00:27:45,610 --> 00:27:52,000
lot of thought put into and many corner

00:27:48,640 --> 00:27:53,860
cases solved but the downside is that it

00:27:52,000 --> 00:27:58,360
also requires quite a lot of attention

00:27:53,860 --> 00:28:00,190
when you're implementing it luckily

00:27:58,360 --> 00:28:02,140
there are various libraries available

00:28:00,190 --> 00:28:05,500
that take care most of that low-level

00:28:02,140 --> 00:28:06,010
plumbing work if you're using Django and

00:28:05,500 --> 00:28:08,680
Chang

00:28:06,010 --> 00:28:12,610
framework then there is Chango Roth

00:28:08,680 --> 00:28:16,540
toolkit which takes care of basically

00:28:12,610 --> 00:28:18,760
making a wealth quite easy if you're not

00:28:16,540 --> 00:28:21,250
using Django then there is a wealth leap

00:28:18,760 --> 00:28:25,990
which the Chango of toolkit itself

00:28:21,250 --> 00:28:27,160
builds upon and overtly bit more

00:28:25,990 --> 00:28:29,290
difficult to work with

00:28:27,160 --> 00:28:31,060
but on the other hand if you need to

00:28:29,290 --> 00:28:35,440
change something that's relatively low

00:28:31,060 --> 00:28:38,320
level then you have to go there for our

00:28:35,440 --> 00:28:40,570
own API project we had to add some

00:28:38,320 --> 00:28:43,630
functionality on top of the Chango Roth

00:28:40,570 --> 00:28:46,480
toolkit and some of this was due to the

00:28:43,630 --> 00:28:50,920
missing features for example we need it

00:28:46,480 --> 00:28:53,950
better redirect URI validation but most

00:28:50,920 --> 00:28:55,630
of the problems or missing features were

00:28:53,950 --> 00:28:58,740
due to the requirements of the project

00:28:55,630 --> 00:29:02,800
itself for example we needed to pass

00:28:58,740 --> 00:29:06,340
pass around more info about token and

00:29:02,800 --> 00:29:08,140
the user that it's connected with and we

00:29:06,340 --> 00:29:10,360
also had to reimplementation swear

00:29:08,140 --> 00:29:12,910
developers could register their

00:29:10,360 --> 00:29:16,020
applications because we wanted them to

00:29:12,910 --> 00:29:16,020
be more user friendly

00:29:23,230 --> 00:29:29,380
once you have the structure and that the

00:29:26,169 --> 00:29:33,399
authentication figured out you should

00:29:29,380 --> 00:29:34,960
also think about versioning versioning

00:29:33,399 --> 00:29:37,990
is really something that you should

00:29:34,960 --> 00:29:39,750
think about from day one because it's

00:29:37,990 --> 00:29:42,279
very important to bolt it on later

00:29:39,750 --> 00:29:45,789
because once people will be using your

00:29:42,279 --> 00:29:47,889
API they will be assuming that it never

00:29:45,789 --> 00:29:51,610
changes because you didn't tell them

00:29:47,889 --> 00:29:53,889
otherwise but if you have versioning

00:29:51,610 --> 00:29:56,279
from the beginning then it will be

00:29:53,889 --> 00:29:58,840
easier to manage these expectations and

00:29:56,279 --> 00:30:01,240
you should also make it clear how long

00:29:58,840 --> 00:30:04,750
the old versions will be supported and

00:30:01,240 --> 00:30:08,230
how developers can find out what changed

00:30:04,750 --> 00:30:12,700
and and those what those support

00:30:08,230 --> 00:30:15,159
schedules are so let's look at how the

00:30:12,700 --> 00:30:17,649
clients can specify versions in their

00:30:15,159 --> 00:30:19,870
API requests there are once again

00:30:17,649 --> 00:30:22,470
different options here and I'll cover

00:30:19,870 --> 00:30:26,860
two of the most popular ones

00:30:22,470 --> 00:30:30,490
the first one is header based versioning

00:30:26,860 --> 00:30:32,200
where the clients specified the version

00:30:30,490 --> 00:30:37,059
they're interested in as part of the

00:30:32,200 --> 00:30:39,460
accept HTTP header in this example the

00:30:37,059 --> 00:30:42,279
client once again asked asks for the

00:30:39,460 --> 00:30:44,289
list of projects and says that it wants

00:30:42,279 --> 00:30:52,630
the response to be in JSON format and

00:30:44,289 --> 00:30:55,510
the version to be 1.0 headers are more

00:30:52,630 --> 00:30:58,809
idealistic approach because the version

00:30:55,510 --> 00:31:02,049
that you use is sort of meta information

00:30:58,809 --> 00:31:05,710
and with the header based versioning you

00:31:02,049 --> 00:31:07,679
keep it out of the URL pots but headers

00:31:05,710 --> 00:31:10,389
are also a bit harder to use and test

00:31:07,679 --> 00:31:13,690
for example you can't specify the

00:31:10,389 --> 00:31:17,740
headers when you're just browsing the

00:31:13,690 --> 00:31:20,710
API so in the real world both based

00:31:17,740 --> 00:31:24,490
versioning might make more sense and be

00:31:20,710 --> 00:31:28,960
a more pragmatic choice this is when you

00:31:24,490 --> 00:31:31,299
basically prefix the URL with the

00:31:28,960 --> 00:31:34,870
version itself so in this case we have

00:31:31,299 --> 00:31:36,150
the slash b1r appended to the URL that

00:31:34,870 --> 00:31:39,419
we're using

00:31:36,150 --> 00:31:41,940
and this can make debugging easier as

00:31:39,419 --> 00:31:44,760
well because if your server logs contain

00:31:41,940 --> 00:31:47,460
URLs then you automatically sort of have

00:31:44,760 --> 00:31:51,150
the versioning information attached to

00:31:47,460 --> 00:31:53,450
those URLs and as you can see once again

00:31:51,150 --> 00:31:56,760
Django rest framework provides

00:31:53,450 --> 00:32:04,190
out-of-the-box functionality for both of

00:31:56,760 --> 00:32:07,679
those cases once you've chosen which

00:32:04,190 --> 00:32:09,750
variant to go with then you need need to

00:32:07,679 --> 00:32:12,390
think about what the version should be

00:32:09,750 --> 00:32:13,830
some people prefer to use integers like

00:32:12,390 --> 00:32:18,960
v1 and v2

00:32:13,830 --> 00:32:21,210
others prefer dates and I'm also a fan

00:32:18,960 --> 00:32:23,850
of the dates lately because they're sort

00:32:21,210 --> 00:32:25,500
of less emotional which means that you

00:32:23,850 --> 00:32:28,919
don't have to think about whether the

00:32:25,500 --> 00:32:33,630
next version will be B 1.1 or is it big

00:32:28,919 --> 00:32:36,659
enough chains to justify version 2 and I

00:32:33,630 --> 00:32:41,909
think that's a good thing because it

00:32:36,659 --> 00:32:44,640
lets you focus on the API itself you

00:32:41,909 --> 00:32:48,029
should also once again in short sure

00:32:44,640 --> 00:32:50,700
that the upgrades are easy to make by

00:32:48,029 --> 00:32:58,010
the developers and they have access to

00:32:50,700 --> 00:33:00,929
change logs and upgrading information so

00:32:58,010 --> 00:33:02,610
discover the client side of things but

00:33:00,929 --> 00:33:06,299
how do you handle versioning on the

00:33:02,610 --> 00:33:08,460
server side for incremental changes a

00:33:06,299 --> 00:33:11,610
nice approach is to use version

00:33:08,460 --> 00:33:15,330
transformers this is actually quite

00:33:11,610 --> 00:33:18,330
similar to how Jango middlewares work so

00:33:15,330 --> 00:33:20,779
basically you would write your core API

00:33:18,330 --> 00:33:25,320
code only for the latest version and

00:33:20,779 --> 00:33:27,480
then if request comes in using an older

00:33:25,320 --> 00:33:30,149
version then you would have the version

00:33:27,480 --> 00:33:33,299
transformer sort of transform that

00:33:30,149 --> 00:33:35,309
request into a newer version which could

00:33:33,299 --> 00:33:38,580
then be processed by the core code

00:33:35,309 --> 00:33:41,149
itself and once the core code gives you

00:33:38,580 --> 00:33:44,010
a response again for the latest version

00:33:41,149 --> 00:33:46,590
then you can use the transformer to

00:33:44,010 --> 00:33:49,410
transform that latest version back into

00:33:46,590 --> 00:33:53,070
something that the client understands

00:33:49,410 --> 00:33:55,350
and this approach is also stackable in

00:33:53,070 --> 00:33:59,690
the sense that if you're if you have

00:33:55,350 --> 00:34:04,860
multiple upgrades or say three versions

00:33:59,690 --> 00:34:07,080
then if the client is asking for version

00:34:04,860 --> 00:34:09,929
one and your latest is version three

00:34:07,080 --> 00:34:12,960
then you can have two transformers one

00:34:09,929 --> 00:34:15,270
that knows how to go from v1 to v2 and

00:34:12,960 --> 00:34:17,850
the other way and then the second

00:34:15,270 --> 00:34:25,770
transformer that knows what the changes

00:34:17,850 --> 00:34:29,070
between b2 and b3 are and this approach

00:34:25,770 --> 00:34:31,919
makes it quite easy to do smaller

00:34:29,070 --> 00:34:35,879
smaller changes like changing some field

00:34:31,919 --> 00:34:38,120
names or adding new fields and notably

00:34:35,879 --> 00:34:42,960
stripe is also using their

00:34:38,120 --> 00:34:47,250
disapprobation about it if you're more

00:34:42,960 --> 00:34:50,639
interested but this won't really work

00:34:47,250 --> 00:34:52,710
for massive and breaking changes in that

00:34:50,639 --> 00:34:55,139
case you might just need to create a

00:34:52,710 --> 00:35:02,550
completely new API implementation and

00:34:55,139 --> 00:35:05,520
duplicate some code in progress getting

00:35:02,550 --> 00:35:07,380
to the more practical side of things we

00:35:05,520 --> 00:35:12,080
have put a lot of what I just talked

00:35:07,380 --> 00:35:15,710
about into a package called DG API core

00:35:12,080 --> 00:35:20,940
it's basically an add-on built on top of

00:35:15,710 --> 00:35:23,970
Jango REST API chasing API package which

00:35:20,940 --> 00:35:27,570
in turn is built on top of the Django

00:35:23,970 --> 00:35:30,300
rest framework package and where the

00:35:27,570 --> 00:35:33,270
Chasen api package basically makes rest

00:35:30,300 --> 00:35:38,850
framework compatible with the Chasen API

00:35:33,270 --> 00:35:43,290
spec the DG API core package adds some

00:35:38,850 --> 00:35:45,960
additional stuff on top of that some of

00:35:43,290 --> 00:35:50,550
those features include documentation

00:35:45,960 --> 00:35:53,580
generation it also comes with

00:35:50,550 --> 00:35:56,760
pre-configured settings so that you

00:35:53,580 --> 00:36:01,020
don't have to configure all the response

00:35:56,760 --> 00:36:03,060
and request and response processors for

00:36:01,020 --> 00:36:06,480
the for the rest framework

00:36:03,060 --> 00:36:08,790
and it also contains some utilities for

00:36:06,480 --> 00:36:12,150
view sets and serializers so that you

00:36:08,790 --> 00:36:16,500
can for example return different fields

00:36:12,150 --> 00:36:19,500
for listing and detail requests so that

00:36:16,500 --> 00:36:22,850
the listing request returns some summary

00:36:19,500 --> 00:36:26,610
data and then the detail requests

00:36:22,850 --> 00:36:31,860
returned the full details of each object

00:36:26,610 --> 00:36:35,070
and there are also similar packages out

00:36:31,860 --> 00:36:37,890
there which one is the best for you

00:36:35,070 --> 00:36:40,740
again depends on the use case you should

00:36:37,890 --> 00:36:45,690
really just once again know what your

00:36:40,740 --> 00:36:48,980
tooling has and what other alternatives

00:36:45,690 --> 00:36:48,980
are add-ons are out there

00:36:49,550 --> 00:36:55,500
finally let's also look at the same

00:36:52,110 --> 00:37:01,470
thing from the clients perspective if

00:36:55,500 --> 00:37:06,300
we're trying to use an API and see how

00:37:01,470 --> 00:37:09,270
all of that is actually in use so as an

00:37:06,300 --> 00:37:11,460
example scenario let's say that I have

00:37:09,270 --> 00:37:14,700
some audio and I want to do speech

00:37:11,460 --> 00:37:16,680
recognition on it I will be using Amazon

00:37:14,700 --> 00:37:21,000
Web Services and Google cloud platform

00:37:16,680 --> 00:37:24,570
as examples they're both quite good

00:37:21,000 --> 00:37:27,900
because they have comprehensive list of

00:37:24,570 --> 00:37:30,150
services and they cover all of those

00:37:27,900 --> 00:37:33,810
services with a single library that

00:37:30,150 --> 00:37:39,870
provides access to them in a unified and

00:37:33,810 --> 00:37:42,630
familiar way so first of all of course I

00:37:39,870 --> 00:37:45,660
took a look at that documentation in

00:37:42,630 --> 00:37:48,990
both cases that documentation was out

00:37:45,660 --> 00:37:51,750
there of course quite easy to find but

00:37:48,990 --> 00:37:53,880
perhaps slightly overwhelming just

00:37:51,750 --> 00:37:56,280
because of the immense amount of

00:37:53,880 --> 00:38:00,030
services provided by both Google as well

00:37:56,280 --> 00:38:03,420
as Amazon but importantly in both cases

00:38:00,030 --> 00:38:06,390
they also provide code examples so once

00:38:03,420 --> 00:38:09,300
again if I want to I can just copy and

00:38:06,390 --> 00:38:12,530
paste some starter code and get moving

00:38:09,300 --> 00:38:12,530
really really fast

00:38:13,520 --> 00:38:20,100
they provide quite comprehensive client

00:38:17,430 --> 00:38:23,010
packages for the Google there is the

00:38:20,100 --> 00:38:25,680
Google cloud package for Amazon's for

00:38:23,010 --> 00:38:30,120
Amazon there's poetry both are

00:38:25,680 --> 00:38:32,370
installable from pip once that part is

00:38:30,120 --> 00:38:35,940
done you need to run through authentic

00:38:32,370 --> 00:38:40,680
ation table to provide some command line

00:38:35,940 --> 00:38:42,870
tools to get that done and then you have

00:38:40,680 --> 00:38:46,290
quite thorough documentation that lists

00:38:42,870 --> 00:38:48,720
all the different operations that the

00:38:46,290 --> 00:38:53,600
API support as well as all the different

00:38:48,720 --> 00:38:53,600
parameters for each of the endpoints so

00:38:54,020 --> 00:39:00,540
this is an example of how it would work

00:38:56,970 --> 00:39:04,710
in case of Amazon first you import

00:39:00,540 --> 00:39:08,190
package itself that PO 2 3 then you ask

00:39:04,710 --> 00:39:10,050
it for a transcribe client and once you

00:39:08,190 --> 00:39:12,480
have that client you can just call

00:39:10,050 --> 00:39:16,800
methods on it like start transcription

00:39:12,480 --> 00:39:18,840
job and pass it your audio data as well

00:39:16,800 --> 00:39:22,230
as perhaps some other optional

00:39:18,840 --> 00:39:26,580
parameters and you get the response with

00:39:22,230 --> 00:39:30,300
the results back the Google's case is

00:39:26,580 --> 00:39:33,060
quite similar you once again import the

00:39:30,300 --> 00:39:35,910
speech client and then instantiate it

00:39:33,060 --> 00:39:38,970
and then you can call methods on it like

00:39:35,910 --> 00:39:44,640
recognize here and again posit your

00:39:38,970 --> 00:39:46,680
audio data get the results back and as I

00:39:44,640 --> 00:39:49,320
mentioned both of those SDKs provide

00:39:46,680 --> 00:39:53,190
common interface for all of the included

00:39:49,320 --> 00:39:57,060
services for example in Amazon's case s3

00:39:53,190 --> 00:40:01,610
easy to the transcribe that you see here

00:39:57,060 --> 00:40:04,650
and again it plays on the familiarity

00:40:01,610 --> 00:40:08,100
side of things so once you know how to

00:40:04,650 --> 00:40:10,590
do transcriptions for example it would

00:40:08,100 --> 00:40:14,670
be quite easy for you to use some other

00:40:10,590 --> 00:40:16,980
service as well and as you can see both

00:40:14,670 --> 00:40:19,980
of those SDKs are quite similar to each

00:40:16,980 --> 00:40:21,900
other as well they use common and

00:40:19,980 --> 00:40:25,760
familiar patterns they don't try to

00:40:21,900 --> 00:40:25,760
invent something really really unique

00:40:26,290 --> 00:40:31,660
and again this means that the potential

00:40:29,990 --> 00:40:35,030
pool of developers who are able to

00:40:31,660 --> 00:40:39,400
quickly and easily start using it is so

00:40:35,030 --> 00:40:40,700
much bigger their documentation is

00:40:39,400 --> 00:40:42,710
thorough

00:40:40,700 --> 00:40:45,770
they provide getting started pages and

00:40:42,710 --> 00:40:49,010
code examples and what you can't see

00:40:45,770 --> 00:40:52,010
here is that at least partially they are

00:40:49,010 --> 00:40:55,970
both automatically generated from the

00:40:52,010 --> 00:40:58,850
same schema so basically they take the

00:40:55,970 --> 00:41:01,940
API schema and then from that they

00:40:58,850 --> 00:41:04,610
generate both the documentation as well

00:41:01,940 --> 00:41:08,060
as the client libraries for python and

00:41:04,610 --> 00:41:10,040
some other languages as well and again

00:41:08,060 --> 00:41:16,930
this means that everything is nicely in

00:41:10,040 --> 00:41:19,340
sync so let's wrap this up

00:41:16,930 --> 00:41:22,220
documentation matters because it's

00:41:19,340 --> 00:41:25,910
usually the first impression that users

00:41:22,220 --> 00:41:29,870
will get about your API so make sure you

00:41:25,910 --> 00:41:33,140
invest into it embrace standards because

00:41:29,870 --> 00:41:37,280
they bring familiarity and make it

00:41:33,140 --> 00:41:40,250
easier to use your API and use

00:41:37,280 --> 00:41:43,900
automation to ensure that things don't

00:41:40,250 --> 00:41:46,310
go out of date this applies to both

00:41:43,900 --> 00:41:49,940
documentation as well as perhaps client

00:41:46,310 --> 00:41:52,370
libraries and in general reduce friction

00:41:49,940 --> 00:41:55,400
as much as possible by friction I mean I

00:41:52,370 --> 00:41:58,040
pulled up small potential issues that

00:41:55,400 --> 00:42:01,460
try people away from your API or your

00:41:58,040 --> 00:42:05,960
product and think of the humans

00:42:01,460 --> 00:42:08,320
basically here you can see my contacts I

00:42:05,960 --> 00:42:11,240
will be tweeting my slides later and

00:42:08,320 --> 00:42:13,790
perhaps to a blog post on the same topic

00:42:11,240 --> 00:42:19,749
thanks for listening

00:42:13,790 --> 00:42:19,749
[Music]

00:42:21,390 --> 00:42:24,089
we have a couple of minutes for

00:42:23,230 --> 00:42:26,740
questions

00:42:24,089 --> 00:42:27,970
if people want to go up to one of the

00:42:26,740 --> 00:42:29,950
many microphones that I've just

00:42:27,970 --> 00:42:33,250
discovered they go all the way up and

00:42:29,950 --> 00:42:36,310
down and you can get your present after

00:42:33,250 --> 00:42:38,140
you've answered some questions hi hello

00:42:36,310 --> 00:42:42,490
wondering on whether you had any

00:42:38,140 --> 00:42:46,599
thoughts on clients returning python

00:42:42,490 --> 00:42:49,240
objects versus dictionaries i think if

00:42:46,599 --> 00:42:51,820
you have a good client library

00:42:49,240 --> 00:42:54,970
then returning python or taxi is

00:42:51,820 --> 00:42:56,770
preferable because if you have a like if

00:42:54,970 --> 00:42:58,599
you have a dictionary then you had you

00:42:56,770 --> 00:43:02,109
sort of have to go into that dictionary

00:42:58,599 --> 00:43:06,790
manually and using an actual Python

00:43:02,109 --> 00:43:10,500
object can provide shortcuts so I think

00:43:06,790 --> 00:43:10,500
that way is the preferable way

00:43:15,910 --> 00:43:22,299
since you're using Django rest framework

00:43:18,069 --> 00:43:25,000
you surely have seen a core API which is

00:43:22,299 --> 00:43:31,779
integrated so what's the main difference

00:43:25,000 --> 00:43:34,000
between Jason API and core API I'm not

00:43:31,779 --> 00:43:36,910
entirely sure but I think core API is

00:43:34,000 --> 00:43:39,819
more about the scheme itself feel free

00:43:36,910 --> 00:43:42,789
to correct me if I'm wrong and chasing

00:43:39,819 --> 00:43:47,589
API really defines the responses that

00:43:42,789 --> 00:43:50,950
your API outputs so I think core API

00:43:47,589 --> 00:43:53,500
solves the schema part but chasing API

00:43:50,950 --> 00:43:59,069
is for the request and response formats

00:43:53,500 --> 00:44:03,190
and related things but I might be wrong

00:43:59,069 --> 00:44:09,400
I had the impression that core API he

00:44:03,190 --> 00:44:14,069
does exactly this that job you didn't

00:44:09,400 --> 00:44:14,069
you didn't use it anyway no I did not

00:44:15,029 --> 00:44:22,059
thank you thank you for the talk I

00:44:18,819 --> 00:44:24,520
wonder if you would design your API is

00:44:22,059 --> 00:44:26,829
for mobile clients differently because

00:44:24,520 --> 00:44:32,819
of the size the size of the data matters

00:44:26,829 --> 00:44:35,200
there a lot I think that JSON API

00:44:32,819 --> 00:44:37,930
already gives you rather good tools

00:44:35,200 --> 00:44:40,059
because you can customize which related

00:44:37,930 --> 00:44:43,829
objects are included in the response as

00:44:40,059 --> 00:44:46,480
well as which fields are included so

00:44:43,829 --> 00:44:48,490
depending on your specific use case you

00:44:46,480 --> 00:44:51,579
might want to go further from that then

00:44:48,490 --> 00:44:54,569
perhaps go as far as to using some

00:44:51,579 --> 00:44:58,270
binary protocol instead of chasing but

00:44:54,569 --> 00:45:01,569
yeah it really depends on what your use

00:44:58,270 --> 00:45:04,510
cases are the advantage of chasing API

00:45:01,569 --> 00:45:06,339
is that it works for a variety of use

00:45:04,510 --> 00:45:09,460
cases and it works quite well for those

00:45:06,339 --> 00:45:13,240
so if you have the mobile clients as

00:45:09,460 --> 00:45:16,180
well as some other API integrations with

00:45:13,240 --> 00:45:19,500
other services for example then you

00:45:16,180 --> 00:45:25,220
don't need to create too many specific

00:45:19,500 --> 00:45:27,660
api's thank you thanks

00:45:25,220 --> 00:45:32,700
we still have a few more minutes if

00:45:27,660 --> 00:45:36,390
people have questions going once going

00:45:32,700 --> 00:45:37,600
twice well let's thank our speaker again

00:45:36,390 --> 00:45:42,060
thanks again

00:45:37,600 --> 00:45:42,060

YouTube URL: https://www.youtube.com/watch?v=1pgQXzoUcgk


