Title: DjangoCon 2018 - It's about time
Publication date: 2018-05-25
Playlist: DjangoCon Europe 2018 in Heidelberg
Description: 
	https://media.ccc.de/v/hd-18-it-s-about-time



Why is dealing with dates and time so difficult? Well, it's because time has a very sordid history. Join us on a deep dive into that history, and how that history affects the data modelling and APIs we use every day.

Here's a fun experiment: Mention timezones within earshot of any experienced programmer. Now wait until the profanity stops.

Handling dates and time is an incredibly common requirement in computer applications. That's hardly surprising - we all use computers to record when we did old things, track how long things take, and to plan when we're going to do things. So why is dealing with time so difficult?

Well, it's because time has a very sordid history. What we even think of as time has changed. In this talk, you'll travel through time, and see the impact that two thousand years of history have had on our modern life. You'll be shown how all this wibbly-wobbly, timey-wimey history stuff affects the data modelling and APIs we use on a daily basis.

This is going to take... some time.

Russell Keith-Magee
Captions: 
	00:00:06,310 --> 00:00:12,980
now next up our last talk aptly titled

00:00:10,480 --> 00:00:15,049
it's about

00:00:12,980 --> 00:00:16,939
so we've seen a lot of rustle already on

00:00:15,049 --> 00:00:18,890
the stage which is a good thing because

00:00:16,939 --> 00:00:20,800
he's graciously agreed to run the

00:00:18,890 --> 00:00:23,419
Lightning's Hawks on day one and to

00:00:20,800 --> 00:00:28,070
masterfully very great Thank You Russ

00:00:23,419 --> 00:00:30,199
and now Russell who is a veteran member

00:00:28,070 --> 00:00:33,199
of the Django core team and I think 12

00:00:30,199 --> 00:00:34,879
years wasn't it and it's very very

00:00:33,199 --> 00:00:37,339
involved with Python and Django

00:00:34,879 --> 00:00:41,480
especially is going to tell us why

00:00:37,339 --> 00:00:47,260
handling time and time zones is so very

00:00:41,480 --> 00:00:47,260
very very complex and painful thank you

00:00:51,520 --> 00:00:56,719
well good afternoon as today I said I'm

00:00:54,800 --> 00:00:58,100
Russell Keith McGee I come from knowing

00:00:56,719 --> 00:00:59,989
our country otherwise known as Perth

00:00:58,100 --> 00:01:01,850
Western Australia you may know me from

00:00:59,989 --> 00:01:05,149
my work as an ambassador for wasp Khan

00:01:01,850 --> 00:01:07,340
and my work on conference catering in my

00:01:05,149 --> 00:01:08,929
day job I am a senior data engineer at

00:01:07,340 --> 00:01:11,270
savato we're a market research company

00:01:08,929 --> 00:01:13,039
we use Python and data science to help

00:01:11,270 --> 00:01:14,990
brands to understand their customers

00:01:13,039 --> 00:01:16,580
they help me to get the conferences like

00:01:14,990 --> 00:01:19,099
Jango Khan for which I am very much

00:01:16,580 --> 00:01:20,660
thankful but I am better known because

00:01:19,099 --> 00:01:22,789
of my involvement in the Jango community

00:01:20,660 --> 00:01:25,250
I've been a member of the Jango Corps

00:01:22,789 --> 00:01:26,420
team for just over 12 years I was

00:01:25,250 --> 00:01:28,700
president of the Jango software

00:01:26,420 --> 00:01:30,410
foundation from 2010 to 2015 and I

00:01:28,700 --> 00:01:34,310
served on the Jango Technical Review

00:01:30,410 --> 00:01:35,929
Board for the 1.73 1.11 releases more

00:01:34,310 --> 00:01:37,640
recently I've been doing most of my

00:01:35,929 --> 00:01:39,619
open-source contribution work on the be

00:01:37,640 --> 00:01:41,989
ware project be ware is trying to bring

00:01:39,619 --> 00:01:44,119
Python to modern computing platforms

00:01:41,989 --> 00:01:45,979
like phones and tablets the aim is to

00:01:44,119 --> 00:01:48,170
make using Python as simple for

00:01:45,979 --> 00:01:49,580
developing native applications as Jango

00:01:48,170 --> 00:01:51,440
makes web development something that's

00:01:49,580 --> 00:01:54,890
accessible to newcomers but powerful

00:01:51,440 --> 00:01:56,629
enough for real heavy lifting but no

00:01:54,890 --> 00:01:58,429
matter how simple Jango makes web

00:01:56,629 --> 00:02:00,170
programming or beware makers makes

00:01:58,429 --> 00:02:02,509
mobile programming there are some

00:02:00,170 --> 00:02:05,420
problems that are just capital H hard

00:02:02,509 --> 00:02:08,149
and one of the big ones is dates and

00:02:05,420 --> 00:02:10,910
time something you might not know about

00:02:08,149 --> 00:02:13,400
me I'm actually a her ology nuts I love

00:02:10,910 --> 00:02:15,470
clocks and watches and how that happened

00:02:13,400 --> 00:02:18,080
is an interesting and conveniently

00:02:15,470 --> 00:02:20,690
topical story my undergraduate

00:02:18,080 --> 00:02:22,129
university degree is in physics I went

00:02:20,690 --> 00:02:24,319
to university intending to do as much

00:02:22,129 --> 00:02:26,180
computing as I could so I picked up some

00:02:24,319 --> 00:02:26,390
first-year computer programming units as

00:02:26,180 --> 00:02:28,310
a

00:02:26,390 --> 00:02:30,080
dibbs now at this point I had been

00:02:28,310 --> 00:02:31,640
programming for years so classes

00:02:30,080 --> 00:02:33,020
covering if-statements and wild libs

00:02:31,640 --> 00:02:35,120
really wasn't that much of a technical

00:02:33,020 --> 00:02:36,950
challenge but the time came for our

00:02:35,120 --> 00:02:38,660
first mid semester assignment and one of

00:02:36,950 --> 00:02:40,550
the requirements write a program that

00:02:38,660 --> 00:02:41,840
will ask the user for a date and return

00:02:40,550 --> 00:02:44,900
whether it's a leap year and how many

00:02:41,840 --> 00:02:47,060
days will be in that year now that was

00:02:44,900 --> 00:02:48,680
meant to be a prompt to do a bunch of

00:02:47,060 --> 00:02:51,080
keyboard inputs convert a string to an

00:02:48,680 --> 00:02:53,720
integer take modulo four use an if

00:02:51,080 --> 00:02:56,060
statement but I decided I wasn't going

00:02:53,720 --> 00:02:58,280
to do the obvious thing I was going to

00:02:56,060 --> 00:03:00,489
show off a bit and build the best darn

00:02:58,280 --> 00:03:02,690
calendar utility or world and ever seen

00:03:00,489 --> 00:03:05,090
which started beyond a little bit of a

00:03:02,690 --> 00:03:07,850
journey because when you dig into it

00:03:05,090 --> 00:03:09,320
it's not as simple as just mod for the

00:03:07,850 --> 00:03:10,970
solar year the amount of time it takes

00:03:09,320 --> 00:03:12,590
for the Sun to orbit the earth when you

00:03:10,970 --> 00:03:14,209
measure from equinox to equinox is

00:03:12,590 --> 00:03:17,330
something like three hundred and sixty

00:03:14,209 --> 00:03:19,700
five point two four two one nine days so

00:03:17,330 --> 00:03:21,590
in addition to a leap year every four

00:03:19,700 --> 00:03:23,570
years we make a special case every

00:03:21,590 --> 00:03:25,820
hundred years and don't add the leap day

00:03:23,570 --> 00:03:27,380
in February and then every 400 years we

00:03:25,820 --> 00:03:30,500
make a special case of the special case

00:03:27,380 --> 00:03:31,820
and we do at the leap day where did

00:03:30,500 --> 00:03:32,870
these rules come from well they're

00:03:31,820 --> 00:03:34,820
actually called the Gregorian calendar

00:03:32,870 --> 00:03:36,890
because they were adopted by Pope

00:03:34,820 --> 00:03:40,519
Gregory the 13th in a papal bull named

00:03:36,890 --> 00:03:42,079
Integra tzimmes in October of 1580 - why

00:03:40,519 --> 00:03:44,269
did they adopt such a complex set of

00:03:42,079 --> 00:03:46,910
rules well because the Year was shifting

00:03:44,269 --> 00:03:48,530
prior to 1580 to the Western Roman

00:03:46,910 --> 00:03:50,269
Catholic world used what was called the

00:03:48,530 --> 00:03:53,390
Julian calendar Julian calendar was

00:03:50,269 --> 00:03:55,459
adopted by Julius Caesar in 45 BC but it

00:03:53,390 --> 00:03:59,209
only had the four year leap year rule

00:03:55,459 --> 00:04:02,510
and so every 128 years it gets a day

00:03:59,209 --> 00:04:05,209
ahead of the solar year and as a result

00:04:02,510 --> 00:04:07,070
by the 1500s the solar year was 10 days

00:04:05,209 --> 00:04:08,510
out of alignment with the calendar year

00:04:07,070 --> 00:04:10,670
so that meant that the vernal equinox

00:04:08,510 --> 00:04:12,440
the date in northern spring when the day

00:04:10,670 --> 00:04:16,789
and night of the same length it didn't

00:04:12,440 --> 00:04:19,160
happen on March 20th but on April 1st so

00:04:16,789 --> 00:04:20,660
what well it's a problem when one of

00:04:19,160 --> 00:04:22,400
your major religious holidays is

00:04:20,660 --> 00:04:25,100
observed relative to the vernal equinox

00:04:22,400 --> 00:04:26,539
the date of Easter technically is the

00:04:25,100 --> 00:04:28,640
first Sunday after the first

00:04:26,539 --> 00:04:31,970
ecclesiastical full moon falling on or

00:04:28,640 --> 00:04:33,650
after the vernal equinox so if the date

00:04:31,970 --> 00:04:35,479
of the vernal equinox is shifting

00:04:33,650 --> 00:04:38,060
relative to the solar year there's a

00:04:35,479 --> 00:04:39,200
problem the problem of calculating the

00:04:38,060 --> 00:04:40,470
date of Easter is known as known

00:04:39,200 --> 00:04:42,330
technically as computer

00:04:40,470 --> 00:04:43,710
from the latin word for computation and

00:04:42,330 --> 00:04:44,990
it was the major problem that was

00:04:43,710 --> 00:04:47,190
addressed by astronomy and mathematics

00:04:44,990 --> 00:04:48,170
between the age of Aristotle and the

00:04:47,190 --> 00:04:50,940
Renaissance

00:04:48,170 --> 00:04:52,230
the process of adopting the Gregorian

00:04:50,940 --> 00:04:54,870
calendar has some pretty hilarious

00:04:52,230 --> 00:04:57,510
consequences pop quiz

00:04:54,870 --> 00:04:59,430
this is the 100th anniversary of Red

00:04:57,510 --> 00:05:03,810
October the start of the 1918 Russian

00:04:59,430 --> 00:05:06,570
Revolution what month did it start in if

00:05:03,810 --> 00:05:09,060
you said October you'd be wrong because

00:05:06,570 --> 00:05:11,130
Imperial Russia as part of the Eastern

00:05:09,060 --> 00:05:13,440
Orthodoxy didn't adopt the Roman

00:05:11,130 --> 00:05:15,810
Catholic Gregorian calendar until after

00:05:13,440 --> 00:05:18,780
the Revolution so when the October

00:05:15,810 --> 00:05:20,790
Revolution happened on October 25th that

00:05:18,780 --> 00:05:22,830
was on the Julian calendar but it was

00:05:20,790 --> 00:05:25,650
November 7th in Western Europe on the

00:05:22,830 --> 00:05:27,000
Gregorian calendar the Roman Catholic

00:05:25,650 --> 00:05:29,700
world made the calendar adjustment in

00:05:27,000 --> 00:05:32,730
October of 1580 - so that year October

00:05:29,700 --> 00:05:35,070
only had twenty days but only in the

00:05:32,730 --> 00:05:37,410
Roman Catholic world Sweden changed in

00:05:35,070 --> 00:05:40,230
1700 but got the math wrong over

00:05:37,410 --> 00:05:42,600
compensated by a day and so in 1712 they

00:05:40,230 --> 00:05:47,400
adjusted again resulting in the one and

00:05:42,600 --> 00:05:52,410
only example of February 30th the

00:05:47,400 --> 00:05:55,230
British Empire the British Empire

00:05:52,410 --> 00:05:58,920
changed in 1750 - the turkey didn't

00:05:55,230 --> 00:06:01,170
change until 1926 and so the number of

00:05:58,920 --> 00:06:03,480
days in the year and the number of days

00:06:01,170 --> 00:06:07,080
in February and even the number of days

00:06:03,480 --> 00:06:09,180
in October can vary depending upon what

00:06:07,080 --> 00:06:12,090
year you're evaluating and where you are

00:06:09,180 --> 00:06:13,980
in the world so that's where my

00:06:12,090 --> 00:06:15,390
interesting dates and time started let's

00:06:13,980 --> 00:06:18,890
just say that my first year computer

00:06:15,390 --> 00:06:21,390
science assignment was comprehensive and

00:06:18,890 --> 00:06:24,330
Liz Murphy my first year computer

00:06:21,390 --> 00:06:27,990
science lecturer was a very very patient

00:06:24,330 --> 00:06:30,120
woman now I didn't just tell this story

00:06:27,990 --> 00:06:31,980
for amusement value he is amusing but I

00:06:30,120 --> 00:06:33,750
did want to make a point like a lot of

00:06:31,980 --> 00:06:36,090
problems in computer science something

00:06:33,750 --> 00:06:39,270
that seems relatively simple like what

00:06:36,090 --> 00:06:41,970
is your name what is your sex how many

00:06:39,270 --> 00:06:43,830
days are there this year can seem really

00:06:41,970 --> 00:06:46,260
simple on the surface and trivially easy

00:06:43,830 --> 00:06:48,030
to implement but in practice you

00:06:46,260 --> 00:06:49,320
actually need to understand a lot of

00:06:48,030 --> 00:06:52,800
human history if you're going to

00:06:49,320 --> 00:06:54,150
implement a robust solution but they are

00:06:52,800 --> 00:06:56,910
solvable problem

00:06:54,150 --> 00:06:59,700
these edge cases exist for reasons and

00:06:56,910 --> 00:07:00,960
there is logic behind them and frankly

00:06:59,700 --> 00:07:02,610
the logic and the reasons are

00:07:00,960 --> 00:07:04,380
fascinating you just have to be aware

00:07:02,610 --> 00:07:07,350
that there are edge cases and pay

00:07:04,380 --> 00:07:08,430
attention to them for example once you

00:07:07,350 --> 00:07:09,450
start to realize that there are

00:07:08,430 --> 00:07:11,040
different types of years you can

00:07:09,450 --> 00:07:12,810
understand why most non Christian

00:07:11,040 --> 00:07:14,640
holidays change date from either year

00:07:12,810 --> 00:07:17,040
they're not changing date they're based

00:07:14,640 --> 00:07:18,660
on a different calendar Judaism operates

00:07:17,040 --> 00:07:20,580
on what's called a lunisolar calendar

00:07:18,660 --> 00:07:22,530
its calendar it's a calendar based on

00:07:20,580 --> 00:07:24,510
the phases of the Moon the Jewish

00:07:22,530 --> 00:07:26,280
calendar adds an extra month on the

00:07:24,510 --> 00:07:27,870
second or every second or third year to

00:07:26,280 --> 00:07:30,510
adjust for the precession between the

00:07:27,870 --> 00:07:32,490
lunar and the solar year Islam operates

00:07:30,510 --> 00:07:34,800
on an astronomical lunar calendar so the

00:07:32,490 --> 00:07:37,410
Islamic year is 10 to 11 year as 10 to

00:07:34,800 --> 00:07:39,630
11 days shorter than the solar year and

00:07:37,410 --> 00:07:41,640
the date of Ramadan processes relative

00:07:39,630 --> 00:07:43,980
to the Gregorian calendar by 10 or 11

00:07:41,640 --> 00:07:46,530
days every year China Japan Korea

00:07:43,980 --> 00:07:48,360
Vietnam Mongolia and Nepal many others

00:07:46,530 --> 00:07:50,160
particularly in Asia also operate their

00:07:48,360 --> 00:07:52,020
calendars on a lunar basis which is why

00:07:50,160 --> 00:07:55,500
the date of the lunar new year Chinese

00:07:52,020 --> 00:07:57,330
New Year varies every year and helpfully

00:07:55,500 --> 00:07:59,370
Google the provided demonstration for us

00:07:57,330 --> 00:08:01,290
just this week sitting in this room

00:07:59,370 --> 00:08:04,020
jumping on Google and search for dates

00:08:01,290 --> 00:08:08,370
on some devices like mine it told you

00:08:04,020 --> 00:08:11,790
the year was 26 51 at 2561 which it is

00:08:08,370 --> 00:08:13,680
in Thailand big on the Thai Buddhist

00:08:11,790 --> 00:08:14,700
calendar which is loony solar measured

00:08:13,680 --> 00:08:17,670
from the date that Buddha found

00:08:14,700 --> 00:08:19,680
enlightenment the problems we see on a

00:08:17,670 --> 00:08:20,970
daily basis with date and time handling

00:08:19,680 --> 00:08:22,530
are because people either don't

00:08:20,970 --> 00:08:24,150
understand the complexities of the

00:08:22,530 --> 00:08:26,250
problem they're trying to solve or they

00:08:24,150 --> 00:08:28,020
don't care or they don't communicate the

00:08:26,250 --> 00:08:29,610
limitations of the solution they've used

00:08:28,020 --> 00:08:31,470
or they're willing to make those

00:08:29,610 --> 00:08:33,900
limitations somebody else's problem in

00:08:31,470 --> 00:08:36,420
the future which is exactly how he got

00:08:33,900 --> 00:08:38,130
y2k a generation of programmers took the

00:08:36,420 --> 00:08:39,810
vernacular of the time and wrote systems

00:08:38,130 --> 00:08:43,950
that stored the year using two digits

00:08:39,810 --> 00:08:46,500
instead of 475 instead of 1975 and in

00:08:43,950 --> 00:08:48,090
1975 the math works fine and bytes were

00:08:46,500 --> 00:08:51,330
actually expensive so is kind of worth

00:08:48,090 --> 00:08:53,070
it but come 1999 that shortcut

00:08:51,330 --> 00:08:55,440
transforms from a space-saving

00:08:53,070 --> 00:08:58,440
optimization to a major engineering

00:08:55,440 --> 00:09:00,450
headache and yet despite the fact that

00:08:58,440 --> 00:09:02,850
as an industry we went through this 18

00:09:00,450 --> 00:09:05,070
years ago I still see official forms

00:09:02,850 --> 00:09:06,670
that ask for a date and provide true

00:09:05,070 --> 00:09:08,540
boxes for the year

00:09:06,670 --> 00:09:11,150
and we're lining up for a repeat

00:09:08,540 --> 00:09:13,430
performance in less than 20 years many

00:09:11,150 --> 00:09:15,140
computer systems store time using epoch

00:09:13,430 --> 00:09:18,230
the number of seconds since midnight UTC

00:09:15,140 --> 00:09:20,480
January 1st 1970 which will be fine

00:09:18,230 --> 00:09:23,600
right up until 3:14 in the morning on

00:09:20,480 --> 00:09:25,310
January 19 2030 when that count would be

00:09:23,600 --> 00:09:27,740
larger than what you can store in a

00:09:25,310 --> 00:09:29,330
signed 32-bit integer and if you're

00:09:27,740 --> 00:09:30,830
inclined to think ah it's a problem I'll

00:09:29,330 --> 00:09:32,839
solve in the future Oh will we will be

00:09:30,830 --> 00:09:34,880
using 64-bit machines by then well

00:09:32,839 --> 00:09:37,100
firstly you want to guess how much 1970s

00:09:34,880 --> 00:09:40,400
COBOL code had to be updated in 1999 and

00:09:37,100 --> 00:09:42,620
secondly we've already seen epoch bugs

00:09:40,400 --> 00:09:45,800
in May 2006

00:09:42,620 --> 00:09:48,020
aol's servers crashed why because their

00:09:45,800 --> 00:09:50,480
code involved generating events that

00:09:48,020 --> 00:09:52,790
should never timeout and the programmer

00:09:50,480 --> 00:09:53,900
used the hack they just added a billion

00:09:52,790 --> 00:09:56,300
seconds to the current timestamp

00:09:53,900 --> 00:09:58,970
whenever they created an event which was

00:09:56,300 --> 00:10:02,000
fine until 127 in the morning on May

00:09:58,970 --> 00:10:03,950
13th 2006 when adding 1 billion seconds

00:10:02,000 --> 00:10:06,710
to the current epoch overflowed the

00:10:03,950 --> 00:10:08,420
32-bit signed limit and never happened

00:10:06,710 --> 00:10:12,230
events were being created with an

00:10:08,420 --> 00:10:14,540
already expired timestamp but here's the

00:10:12,230 --> 00:10:17,500
thing there's a very fine line between

00:10:14,540 --> 00:10:20,150
really cool hack and horrible nasty hack

00:10:17,500 --> 00:10:22,339
generally it's a really cool hack right

00:10:20,150 --> 00:10:24,980
up until everything breaks horribly but

00:10:22,339 --> 00:10:27,380
all computer systems have limitations

00:10:24,980 --> 00:10:29,630
all computers make assumptions

00:10:27,380 --> 00:10:31,130
the problem with AOL server wasn't that

00:10:29,630 --> 00:10:33,530
they used a hack to make dates not

00:10:31,130 --> 00:10:34,910
expiring the problem with y2k wasn't

00:10:33,530 --> 00:10:37,130
that the system used two characters to

00:10:34,910 --> 00:10:39,589
store a year the problem was that the

00:10:37,130 --> 00:10:41,120
technique that was used set a hard

00:10:39,589 --> 00:10:43,850
deadline for the end of life of that

00:10:41,120 --> 00:10:45,620
code and that end of life either wasn't

00:10:43,850 --> 00:10:47,780
understood at the time wasn't

00:10:45,620 --> 00:10:49,580
institutionally communicated and as a

00:10:47,780 --> 00:10:53,300
result when the clock ran out

00:10:49,580 --> 00:10:55,459
hilarity ensued ok so how do we bide our

00:10:53,300 --> 00:10:57,290
time with Python well there is not

00:10:55,459 --> 00:10:59,510
surprisingly a Python module named time

00:10:57,290 --> 00:11:01,310
time is a library for thinking about

00:10:59,510 --> 00:11:03,800
time the way your computer thinks about

00:11:01,310 --> 00:11:06,080
it it contains multiple clocks there is

00:11:03,800 --> 00:11:08,330
wall clock time which is epoch there's

00:11:06,080 --> 00:11:09,589
monatomic time so monotonic time

00:11:08,330 --> 00:11:11,510
something Q that matters if you're

00:11:09,589 --> 00:11:13,790
coordinating between multiple servers

00:11:11,510 --> 00:11:15,740
there's CPU time which is the time as

00:11:13,790 --> 00:11:16,880
observed by your CPU and there's a

00:11:15,740 --> 00:11:18,260
performance counter a very high

00:11:16,880 --> 00:11:19,880
resolution timer that doesn't have a

00:11:18,260 --> 00:11:21,530
good baseline

00:11:19,880 --> 00:11:22,880
these different clocks all have

00:11:21,530 --> 00:11:24,710
different resolutions different

00:11:22,880 --> 00:11:27,890
baselines and as a result different use

00:11:24,710 --> 00:11:30,050
cases internally they measure store time

00:11:27,890 --> 00:11:32,510
as offset against some baseline usually

00:11:30,050 --> 00:11:34,100
an integer or a float some methods

00:11:32,510 --> 00:11:35,570
accept a return a data structure called

00:11:34,100 --> 00:11:37,040
structure time which is a thin wrapper

00:11:35,570 --> 00:11:38,660
around an operating system data

00:11:37,040 --> 00:11:40,730
structure that captures a bunch of time

00:11:38,660 --> 00:11:43,040
related details year month day of the

00:11:40,730 --> 00:11:44,810
month hour minute second but also the

00:11:43,040 --> 00:11:46,880
day of the week with Monday being day

00:11:44,810 --> 00:11:49,910
zero and the year day the index of the

00:11:46,880 --> 00:11:52,550
day into the year it also has an is DST

00:11:49,910 --> 00:11:55,790
flag which can be 0 1 or minus 1 for no

00:11:52,550 --> 00:11:57,740
yes and don't know structure time and

00:11:55,790 --> 00:11:59,540
the rest of the time module operates on

00:11:57,740 --> 00:12:01,310
what's called local system time so

00:11:59,540 --> 00:12:03,140
whatever time zone your operating system

00:12:01,310 --> 00:12:05,660
thinks it is is what time you'll get

00:12:03,140 --> 00:12:07,520
that time zone can then be manipulated

00:12:05,660 --> 00:12:09,590
at a system level but also at a user

00:12:07,520 --> 00:12:11,330
level using an environment variable so

00:12:09,590 --> 00:12:13,190
there are multiple places in your server

00:12:11,330 --> 00:12:15,590
stack where your understanding of time

00:12:13,190 --> 00:12:19,010
can be modified by settings outside your

00:12:15,590 --> 00:12:20,360
own code but the good news in practice

00:12:19,010 --> 00:12:22,730
unless you're doing something that

00:12:20,360 --> 00:12:24,530
interacts with epoch in some way time is

00:12:22,730 --> 00:12:25,940
almost certainly not the module you want

00:12:24,530 --> 00:12:27,410
to be using and if you're dealing with

00:12:25,940 --> 00:12:29,330
leap if you're dealing with epoch and

00:12:27,410 --> 00:12:32,480
you're not dealing with hardware you're

00:12:29,330 --> 00:12:34,070
almost certainly doing it wrong the

00:12:32,480 --> 00:12:35,450
module you probably want for most of

00:12:34,070 --> 00:12:37,280
your date and time requirements is the

00:12:35,450 --> 00:12:38,900
date/time module date/time contains

00:12:37,280 --> 00:12:41,480
tools for dealing with dates and times

00:12:38,900 --> 00:12:44,060
at a human level days months years hours

00:12:41,480 --> 00:12:45,800
minutes seconds and so on the

00:12:44,060 --> 00:12:47,510
Constructors all seem relatively

00:12:45,800 --> 00:12:49,730
straightforward if you actually use

00:12:47,510 --> 00:12:52,070
these constructors though you're going

00:12:49,730 --> 00:12:55,420
to have a bad time take the first one

00:12:52,070 --> 00:12:57,740
for instance that's a date sure where

00:12:55,420 --> 00:12:59,330
every conference call for papers has

00:12:57,740 --> 00:13:00,950
this problem the plaque on Australia

00:12:59,330 --> 00:13:05,480
call for a papers for example closes on

00:13:00,950 --> 00:13:08,030
May 28 May 28 where okay so you just

00:13:05,480 --> 00:13:09,980
attach a time right yeah but what time

00:13:08,030 --> 00:13:11,510
zone well in the case of plaque on

00:13:09,980 --> 00:13:13,040
Australia its AoE anywhere on earth

00:13:11,510 --> 00:13:15,700
which means you've got almost four days

00:13:13,040 --> 00:13:17,930
left to submit your proposal get on that

00:13:15,700 --> 00:13:19,730
but okay what about things that really

00:13:17,930 --> 00:13:21,290
did actually happen on a date you know

00:13:19,730 --> 00:13:23,420
like births and deaths they're all on a

00:13:21,290 --> 00:13:24,950
day right well as soon as you don't have

00:13:23,420 --> 00:13:27,740
information for a date

00:13:24,950 --> 00:13:29,780
you've lost vital context and if you try

00:13:27,740 --> 00:13:32,089
to do math without the context you're

00:13:29,780 --> 00:13:33,440
going to get bitten someone asked to

00:13:32,089 --> 00:13:34,640
Google now how old is

00:13:33,440 --> 00:13:38,170
even Hawking and got the response

00:13:34,640 --> 00:13:40,850
Stephen Hawking died tomorrow at age 76

00:13:38,170 --> 00:13:42,320
Stephen Hawking did die on March 14th

00:13:40,850 --> 00:13:44,210
and he did do a lot of interesting

00:13:42,320 --> 00:13:46,340
things with space-time but without

00:13:44,210 --> 00:13:48,170
knowing that he died in England and the

00:13:46,340 --> 00:13:50,540
person asking the question was in the US

00:13:48,170 --> 00:13:53,210
where it was still March 13th you can't

00:13:50,540 --> 00:13:55,310
do the math you're missing vital

00:13:53,210 --> 00:13:57,230
information you make an assumption and

00:13:55,310 --> 00:13:59,660
the assumption has in this case

00:13:57,230 --> 00:14:01,760
hilarious consequences and if you

00:13:59,660 --> 00:14:03,830
specify time information without a date

00:14:01,760 --> 00:14:06,740
the time also loses context and you get

00:14:03,830 --> 00:14:08,450
some similar problems okay so that means

00:14:06,740 --> 00:14:11,000
we should generally be using date times

00:14:08,450 --> 00:14:13,610
the constructor for date time has one

00:14:11,000 --> 00:14:15,500
non obvious part though teaser info it's

00:14:13,610 --> 00:14:17,270
the time zone info now if you don't

00:14:15,500 --> 00:14:18,710
provide a teaser info object when you

00:14:17,270 --> 00:14:20,990
construct your date time object it's

00:14:18,710 --> 00:14:23,390
what's called a naive date time and for

00:14:20,990 --> 00:14:26,120
most practical purposes it's useless a

00:14:23,390 --> 00:14:29,510
date and time without a time zone is an

00:14:26,120 --> 00:14:31,250
accident waiting to happen if you do

00:14:29,510 --> 00:14:32,930
provide a teaser info object which you

00:14:31,250 --> 00:14:33,860
have is called an aware date time and

00:14:32,930 --> 00:14:36,170
that's something you can actually work

00:14:33,860 --> 00:14:38,780
with okay so where do you get a teaser

00:14:36,170 --> 00:14:40,100
info object from well to make date time

00:14:38,780 --> 00:14:41,660
actually useful you actually have to use

00:14:40,100 --> 00:14:43,490
a third party module and the module you

00:14:41,660 --> 00:14:45,560
should probably be using is called PI TZ

00:14:43,490 --> 00:14:47,540
I'd argue if you're doing anything with

00:14:45,560 --> 00:14:49,700
dates and times and you don't have pi TZ

00:14:47,540 --> 00:14:51,740
as a dependency you are almost certainly

00:14:49,700 --> 00:14:53,630
doing dates and times wrong it's a third

00:14:51,740 --> 00:14:56,450
party module because it can't be built

00:14:53,630 --> 00:14:58,190
into Python ordering to Jango and one of

00:14:56,450 --> 00:14:58,990
the reason why is another one of those

00:14:58,190 --> 00:15:02,090
human things

00:14:58,990 --> 00:15:04,010
hi TZ is a wrapper around the Olson time

00:15:02,090 --> 00:15:05,540
zone database the Olson database is

00:15:04,010 --> 00:15:07,280
published as a set of text files in a

00:15:05,540 --> 00:15:09,830
human readable format which are

00:15:07,280 --> 00:15:11,150
themselves hilarious to read these are

00:15:09,830 --> 00:15:13,280
compiled into machine readable format

00:15:11,150 --> 00:15:15,200
for use by libraries like quite easy it

00:15:13,280 --> 00:15:17,480
contains a list of time zones an offset

00:15:15,200 --> 00:15:19,160
of that time zone from UTC the time at

00:15:17,480 --> 00:15:22,520
the Greenwich prime meridian and it is

00:15:19,160 --> 00:15:24,770
published regularly multiple updates per

00:15:22,520 --> 00:15:27,830
year the current database is called the

00:15:24,770 --> 00:15:30,560
2018 II database it has had five updates

00:15:27,830 --> 00:15:32,360
this year that record regular update

00:15:30,560 --> 00:15:34,430
cater cycle is why it can't be part of

00:15:32,360 --> 00:15:37,040
Python itself it has a release cadence

00:15:34,430 --> 00:15:39,530
that isn't compatible with pythons the

00:15:37,040 --> 00:15:42,110
2018 database was published on March so

00:15:39,530 --> 00:15:44,180
I'm a fourth because North Korea gave

00:15:42,110 --> 00:15:45,860
the world five days notice that they

00:15:44,180 --> 00:15:47,059
were going to change their time zone to

00:15:45,860 --> 00:15:49,989
match South Korea

00:15:47,059 --> 00:15:56,629
sometimes countries make these changes

00:15:49,989 --> 00:15:58,429
retrospectively okay but like why is a

00:15:56,629 --> 00:15:59,989
whole database format needed you dot

00:15:58,429 --> 00:16:02,239
your time zone is just an integer number

00:15:59,989 --> 00:16:06,649
of hours off it from GMT had an hour for

00:16:02,239 --> 00:16:08,299
daylight savings right no here are some

00:16:06,649 --> 00:16:10,609
amusing selections from the time zone

00:16:08,299 --> 00:16:12,319
database file Darwin in the Northern

00:16:10,609 --> 00:16:15,189
Territory of Australia observe a nine

00:16:12,319 --> 00:16:17,569
hours and 30 minutes offset from UTC

00:16:15,189 --> 00:16:19,339
Adelaide in South Australia observes a

00:16:17,569 --> 00:16:20,809
nine hours and 30 minutes offset but

00:16:19,339 --> 00:16:22,609
with ten hours 30 during daylight

00:16:20,809 --> 00:16:23,929
savings but the daylight savings

00:16:22,609 --> 00:16:25,309
transition transition dates are

00:16:23,929 --> 00:16:26,629
different to the dates used in the US

00:16:25,309 --> 00:16:28,369
and Europe because we're in the southern

00:16:26,629 --> 00:16:31,939
hemisphere so summer time is six months

00:16:28,369 --> 00:16:34,399
out of phase Broken Hill is a town in

00:16:31,939 --> 00:16:36,409
the state of New South Wales even though

00:16:34,399 --> 00:16:39,229
it's in New South Wales it observes

00:16:36,409 --> 00:16:41,389
South Australian time but it uses New

00:16:39,229 --> 00:16:43,969
South Wales dates for daylight savings

00:16:41,389 --> 00:16:48,349
transitions which most of the time is

00:16:43,969 --> 00:16:49,429
the same but not always eucla is a very

00:16:48,349 --> 00:16:52,219
small border town in Western Australia

00:16:49,429 --> 00:16:53,899
population about 300 it doesn't observe

00:16:52,219 --> 00:16:56,239
Western Australian standard time of plus

00:16:53,899 --> 00:16:58,819
8 hours it uses 8 hours and 45 minutes

00:16:56,239 --> 00:17:00,439
offset except when Western Australia

00:16:58,819 --> 00:17:03,079
observes daylight saving which it

00:17:00,439 --> 00:17:04,129
generally doesn't set for about every 20

00:17:03,079 --> 00:17:05,179
years when the government goes on a

00:17:04,129 --> 00:17:06,350
spree and decides it's going to

00:17:05,179 --> 00:17:07,399
experiment for a couple of years and

00:17:06,350 --> 00:17:10,789
then go back to not having daylight

00:17:07,399 --> 00:17:12,529
savings again Lord Howe Island uses a 10

00:17:10,789 --> 00:17:14,959
hours and 30 minute offset during the

00:17:12,529 --> 00:17:17,449
winter and offsets by 30 minutes for

00:17:14,959 --> 00:17:20,929
daylight saving we haven't even left

00:17:17,449 --> 00:17:23,929
Australia yet this region down here

00:17:20,929 --> 00:17:26,209
doesn't look anything like this it looks

00:17:23,929 --> 00:17:28,129
like this and last I heard there was a

00:17:26,209 --> 00:17:30,019
django deployment in antarctica so this

00:17:28,129 --> 00:17:33,559
is a case that django core team have to

00:17:30,019 --> 00:17:34,879
care about even this map can potentially

00:17:33,559 --> 00:17:36,619
get you into trouble the border of

00:17:34,879 --> 00:17:39,169
Kashmir is a disputed region between

00:17:36,619 --> 00:17:40,999
India and Pakistan all maps in India

00:17:39,169 --> 00:17:43,070
have to show the whole of Kashmir as

00:17:40,999 --> 00:17:45,110
part of India and foreign publications

00:17:43,070 --> 00:17:46,610
have to stamp near each incorrect map to

00:17:45,110 --> 00:17:48,350
say that it does not represent the true

00:17:46,610 --> 00:17:52,429
map of India as per the instructions of

00:17:48,350 --> 00:17:53,960
the Government of India so Windows 95

00:17:52,429 --> 00:17:56,090
was threatened with a ban in India

00:17:53,960 --> 00:17:58,460
because of the way windows displayed its

00:17:56,090 --> 00:18:00,320
time zone map similar problems occur for

00:17:58,460 --> 00:18:00,890
occupied and disputed regions all over

00:18:00,320 --> 00:18:03,170
the world

00:18:00,890 --> 00:18:05,390
timezones can't always be determined by

00:18:03,170 --> 00:18:07,280
a simple mapping polygon and for this

00:18:05,390 --> 00:18:11,990
reason PI TC doesn't include geography

00:18:07,280 --> 00:18:13,640
it just has the timezone names so once

00:18:11,990 --> 00:18:15,950
you've installed PI T Z pip install ty

00:18:13,640 --> 00:18:17,900
TZ you can reference any time zone by

00:18:15,950 --> 00:18:20,450
name or just use the UTC timezone

00:18:17,900 --> 00:18:22,160
actually using that timezone object

00:18:20,450 --> 00:18:25,550
however hmm that's a little more

00:18:22,160 --> 00:18:27,820
difficult so surely we just create a PI

00:18:25,550 --> 00:18:31,220
TZ object and create a date time right

00:18:27,820 --> 00:18:36,200
well no what's wrong with this picture

00:18:31,220 --> 00:18:38,809
it's 4:46 p.m. 25th of May 2018 LMT plus

00:18:36,200 --> 00:18:41,179
53 minutes what cell MT where 253

00:18:38,809 --> 00:18:42,470
minutes come from well back in the day

00:18:41,179 --> 00:18:43,820
time zones weren't something that was

00:18:42,470 --> 00:18:45,200
shared across the whole of a continental

00:18:43,820 --> 00:18:47,030
region they were based on train

00:18:45,200 --> 00:18:49,190
timetables and every train station kept

00:18:47,030 --> 00:18:50,750
its own concept of time the only buyer

00:18:49,190 --> 00:18:52,040
only was only when we got centrally

00:18:50,750 --> 00:18:54,470
coordinated time that the idea of

00:18:52,040 --> 00:18:56,510
central European Standard Time existed

00:18:54,470 --> 00:18:58,010
and when you try to map historical times

00:18:56,510 --> 00:19:00,320
on the modern time zones you get some

00:18:58,010 --> 00:19:03,620
interesting offsets Berlin for example

00:19:00,320 --> 00:19:05,870
was 53 minutes ahead of LM T Ln T is

00:19:03,620 --> 00:19:08,120
local mean time it's essentially the

00:19:05,870 --> 00:19:12,050
same as UTC but UTC didn't exist until

00:19:08,120 --> 00:19:14,210
1960 and because LM t plus 53 minutes is

00:19:12,050 --> 00:19:17,030
the earliest chronological entry in the

00:19:14,210 --> 00:19:19,040
Olsen database for Berlin in the absence

00:19:17,030 --> 00:19:23,179
of any other information that's the one

00:19:19,040 --> 00:19:25,520
that gets used so time zones are time

00:19:23,179 --> 00:19:26,870
sensitive which if you think about it

00:19:25,520 --> 00:19:28,580
makes sense because you can't apply

00:19:26,870 --> 00:19:31,730
summer time for a date in the middle of

00:19:28,580 --> 00:19:33,830
winter so what you need to do is create

00:19:31,730 --> 00:19:36,679
a naive date/time object and then

00:19:33,830 --> 00:19:38,390
localize that object when you localize

00:19:36,679 --> 00:19:40,040
the time zone definition can then take

00:19:38,390 --> 00:19:41,960
into account the date you're converting

00:19:40,040 --> 00:19:45,800
and construct the appropriate teaser

00:19:41,960 --> 00:19:47,300
info object so the date time module

00:19:45,800 --> 00:19:49,130
gives you primitives for storing dates

00:19:47,300 --> 00:19:51,950
but those primitives are difficult to

00:19:49,130 --> 00:19:53,210
construct and unfortunately it's even

00:19:51,950 --> 00:19:55,670
harder when you consider that in many

00:19:53,210 --> 00:19:59,240
cases the data isn't coming in in nice

00:19:55,670 --> 00:20:01,280
clean well sorted numerical formats the

00:19:59,240 --> 00:20:02,510
problem of parsing dates from text is

00:20:01,280 --> 00:20:04,550
one of the areas where Python standard

00:20:02,510 --> 00:20:06,140
library has limitations and it's not

00:20:04,550 --> 00:20:08,360
because the standard library is bad it's

00:20:06,140 --> 00:20:12,919
because it's a hard problem and it's a

00:20:08,360 --> 00:20:14,600
hard problem because of people so today

00:20:12,919 --> 00:20:17,690
is May 25th neck

00:20:14,600 --> 00:20:20,780
Friday is the 1st of June 2018

00:20:17,690 --> 00:20:25,220
I mean it's June 1st 2018

00:20:20,780 --> 00:20:27,320
I mean it's 2018 s June 1st day month

00:20:25,220 --> 00:20:29,150
year month day year and year month day

00:20:27,320 --> 00:20:30,470
are all common orderings for dates

00:20:29,150 --> 00:20:32,510
depending upon where you are in the

00:20:30,470 --> 00:20:33,679
world and if you're accepting date input

00:20:32,510 --> 00:20:35,720
you have to be aware that there are

00:20:33,679 --> 00:20:38,179
cultural variations in the way people

00:20:35,720 --> 00:20:41,539
represent dates and sometimes all three

00:20:38,179 --> 00:20:43,850
numbers are valid date/time has a

00:20:41,539 --> 00:20:45,950
mechanism for pausing dates STRP time if

00:20:43,850 --> 00:20:47,539
you happen to know the exact format that

00:20:45,950 --> 00:20:49,850
your humans will be importing dates it

00:20:47,539 --> 00:20:51,289
generally works fine the problem is that

00:20:49,850 --> 00:20:54,350
you probably don't know the format that

00:20:51,289 --> 00:20:56,630
your humans will be providing dates are

00:20:54,350 --> 00:20:57,799
standards to the rescue ISO 8601 is the

00:20:56,630 --> 00:20:59,600
international standard format for

00:20:57,799 --> 00:21:01,010
representing dates and like all good

00:20:59,600 --> 00:21:04,220
international standards is the format

00:21:01,010 --> 00:21:06,470
nobody actually uses it uses year month

00:21:04,220 --> 00:21:08,690
day hour minute second in a very precise

00:21:06,470 --> 00:21:11,659
format within either a UTC offset in

00:21:08,690 --> 00:21:14,450
hours minutes or z4 Zulu or UTC time it

00:21:11,659 --> 00:21:16,580
is also unfortunately a format the

00:21:14,450 --> 00:21:19,940
date/time STRP time doesn't pass

00:21:16,580 --> 00:21:22,100
natively there's also a subtle problem

00:21:19,940 --> 00:21:25,669
lying in wait with any ad iso 8601

00:21:22,100 --> 00:21:27,200
format date/time iso 8601 specifies the

00:21:25,669 --> 00:21:29,900
time in hours minutes seconds and then

00:21:27,200 --> 00:21:32,030
specifies a UTC offset in hours minutes

00:21:29,900 --> 00:21:35,450
which means we've got a problem because

00:21:32,030 --> 00:21:37,700
a UTC offset isn't a timezone take my

00:21:35,450 --> 00:21:41,000
own time zone UTC + 8 hours it's not

00:21:37,700 --> 00:21:43,840
just important because of me 1/6 of the

00:21:41,000 --> 00:21:46,820
world's population lives in my timezone

00:21:43,840 --> 00:21:49,220
so what wait you TC + 8 hours won't tell

00:21:46,820 --> 00:21:51,620
you is which time zone those people are

00:21:49,220 --> 00:21:53,960
living in so it uniquely identifies a

00:21:51,620 --> 00:21:55,700
point in time but it doesn't help you

00:21:53,960 --> 00:21:58,010
work out the right format for a

00:21:55,700 --> 00:21:59,330
particular user and it doesn't tell you

00:21:58,010 --> 00:22:00,620
if any of those places are observing

00:21:59,330 --> 00:22:02,659
currently observing daylight saving time

00:22:00,620 --> 00:22:06,470
or when daylight saving time goes into

00:22:02,659 --> 00:22:08,539
effect dealing with dates is clearly a

00:22:06,470 --> 00:22:09,799
very very complex problem and so lots of

00:22:08,539 --> 00:22:11,990
people have tried their hands are doing

00:22:09,799 --> 00:22:14,330
a better date you till arrow moment Maya

00:22:11,990 --> 00:22:16,130
delorean they're all pi PI modules that

00:22:14,330 --> 00:22:17,840
attempt to make date/time handling

00:22:16,130 --> 00:22:19,340
easier and date parsing is one of the

00:22:17,840 --> 00:22:21,020
areas that they've tackled whether

00:22:19,340 --> 00:22:22,909
they've succeeded or not is a bit of a

00:22:21,020 --> 00:22:24,770
value judgment they do tend to be more

00:22:22,909 --> 00:22:27,230
flexible in what they accept as valid

00:22:24,770 --> 00:22:28,550
input however the price paid for that

00:22:27,230 --> 00:22:30,950
flexibility is occasion

00:22:28,550 --> 00:22:33,110
in accuracy no amount of fancy logic

00:22:30,950 --> 00:22:37,700
will tell you whether one 6:18 is June

00:22:33,110 --> 00:22:39,650
1st June 18 or January 6 so your mileage

00:22:37,700 --> 00:22:41,690
may vary if you use these libraries be

00:22:39,650 --> 00:22:43,520
aware they are not magic ones for fixing

00:22:41,690 --> 00:22:45,620
date handling they make assumptions

00:22:43,520 --> 00:22:48,620
those assumptions have consequences and

00:22:45,620 --> 00:22:50,720
that's not a bad thing all code makes

00:22:48,620 --> 00:22:52,580
assumptions you just need to be aware

00:22:50,720 --> 00:22:54,410
what assumptions you are making and

00:22:52,580 --> 00:22:57,740
validate that those assumptions are

00:22:54,410 --> 00:22:59,270
reasonable but once you've been able to

00:22:57,740 --> 00:23:00,890
pass in date and time you've got a time

00:22:59,270 --> 00:23:03,050
zone you've got a valid time stamp now

00:23:00,890 --> 00:23:05,660
we just need to keep it that way which

00:23:03,050 --> 00:23:07,010
is harder than you think so we've

00:23:05,660 --> 00:23:09,560
created our time stamp we can now do

00:23:07,010 --> 00:23:10,190
some date/time math what time was it 10

00:23:09,560 --> 00:23:12,080
minutes ago

00:23:10,190 --> 00:23:14,720
well we use time Delta which is part of

00:23:12,080 --> 00:23:17,870
date/time and we get the time 10 minutes

00:23:14,720 --> 00:23:20,840
ago fantastic great let's try a

00:23:17,870 --> 00:23:22,910
different time say 305 a.m. March 25th

00:23:20,840 --> 00:23:24,410
2018 Central European summer time what

00:23:22,910 --> 00:23:26,990
time was that 10 minutes ago well we

00:23:24,410 --> 00:23:29,090
just subtract 10 minutes right well

00:23:26,990 --> 00:23:31,190
although because that says the time 10

00:23:29,090 --> 00:23:34,880
minutes ago was 255 Central European

00:23:31,190 --> 00:23:36,800
summer time but at 2:00 a.m. March 25th

00:23:34,880 --> 00:23:37,550
Central European Time Zone started

00:23:36,800 --> 00:23:42,560
daylight saving

00:23:37,550 --> 00:23:45,470
so 255 c est doesn't exist the date time

00:23:42,560 --> 00:23:50,120
makes no sense no accurate clock red 255

00:23:45,470 --> 00:23:52,010
a.m. and c EST started at 3:00 what you

00:23:50,120 --> 00:23:54,110
need to do is normalize the timezone

00:23:52,010 --> 00:23:56,840
normalization takes a timezone aware

00:23:54,110 --> 00:23:58,400
object and adjusts T's that info to be

00:23:56,840 --> 00:24:00,230
correct for the time that is currently

00:23:58,400 --> 00:24:04,000
being stored in this case the time 10

00:24:00,230 --> 00:24:07,130
minutes before 3:05 a.m. was 1:55 a.m.

00:24:04,000 --> 00:24:10,090
Central European Time and you need to do

00:24:07,130 --> 00:24:12,380
this every time you do date/time math

00:24:10,090 --> 00:24:15,080
because of another the edge case leap

00:24:12,380 --> 00:24:16,730
seconds just as a leap year exists to

00:24:15,080 --> 00:24:19,730
adjust the calendar year relative to the

00:24:16,730 --> 00:24:21,950
solar year a leap second exists to

00:24:19,730 --> 00:24:25,130
adjust the solar day against the

00:24:21,950 --> 00:24:26,810
calendar day leap seconds are an extra

00:24:25,130 --> 00:24:29,240
second added to the last day of the

00:24:26,810 --> 00:24:30,590
month usually December or June but the

00:24:29,240 --> 00:24:32,870
standard does actually allow for it to

00:24:30,590 --> 00:24:34,700
occur in any months there's no fixed

00:24:32,870 --> 00:24:36,890
schedule for adding leap seconds they

00:24:34,700 --> 00:24:38,510
are announced about 6 months in advance

00:24:36,890 --> 00:24:41,750
and they result in clocks that

00:24:38,510 --> 00:24:42,530
legitimately read 23 59 60 and although

00:24:41,750 --> 00:24:46,280
it's never happened

00:24:42,530 --> 00:24:49,790
23:59 61 is also a legal timely seconds

00:24:46,280 --> 00:24:53,180
can also be negative so 23 59 59 might

00:24:49,790 --> 00:24:55,280
not occur on a given date leap seconds

00:24:53,180 --> 00:24:57,590
have been around since the 1970s and yet

00:24:55,280 --> 00:24:59,540
Apple Amazon Netflix Pinterest Instagram

00:24:57,590 --> 00:25:01,820
and Twitter had a 40 minute outage in

00:24:59,540 --> 00:25:03,830
2015 because of a leap second bug in a

00:25:01,820 --> 00:25:05,600
router they were using CloudFlare had an

00:25:03,830 --> 00:25:07,220
outage in 2016 because their dns

00:25:05,600 --> 00:25:09,500
resolver didn't account for leap seconds

00:25:07,220 --> 00:25:12,350
the New York Stock Exchange routinely

00:25:09,500 --> 00:25:14,060
stops operations for 61 minutes during

00:25:12,350 --> 00:25:17,690
leap second transitions to make sure

00:25:14,060 --> 00:25:19,100
they don't have problems so any math

00:25:17,690 --> 00:25:21,950
around eight times is inherently

00:25:19,100 --> 00:25:23,510
difficult to so you've got yourself a

00:25:21,950 --> 00:25:24,950
date/time object you know the time zone

00:25:23,510 --> 00:25:26,570
of the person who gave you the data you

00:25:24,950 --> 00:25:27,800
passed it correctly and we've made sure

00:25:26,570 --> 00:25:29,690
that we've got the math right when we

00:25:27,800 --> 00:25:31,340
transformed it now it's time to display

00:25:29,690 --> 00:25:33,200
to another user this means we need to

00:25:31,340 --> 00:25:34,940
know the time zone of the person reading

00:25:33,200 --> 00:25:37,700
the data you want to in order to display

00:25:34,940 --> 00:25:40,400
it and all of the same problems happen

00:25:37,700 --> 00:25:42,110
all over again time zone offsets formats

00:25:40,400 --> 00:25:43,870
all these problems exist on the res

00:25:42,110 --> 00:25:46,280
display end as well as the input end if

00:25:43,870 --> 00:25:48,200
you've got a time zone aware date/time

00:25:46,280 --> 00:25:49,850
object converting to other time zones

00:25:48,200 --> 00:25:51,830
it's relatively straightforward you can

00:25:49,850 --> 00:25:53,930
always use an as time zone method on the

00:25:51,830 --> 00:25:55,130
date/time object itself but you need to

00:25:53,930 --> 00:25:56,110
make sure you actually know the time

00:25:55,130 --> 00:25:58,580
zone that you're targeting

00:25:56,110 --> 00:26:00,440
but there's another trap that developers

00:25:58,580 --> 00:26:02,030
and designers fall into they do it with

00:26:00,440 --> 00:26:04,640
the best of intentions trying to make

00:26:02,030 --> 00:26:06,350
numerical data seem more human when you

00:26:04,640 --> 00:26:08,450
say your product is going to be released

00:26:06,350 --> 00:26:10,910
this summer or for the Americans this

00:26:08,450 --> 00:26:13,880
fall everyone's south of the Equator

00:26:10,910 --> 00:26:16,340
rolls their eyes if there's any

00:26:13,880 --> 00:26:18,590
possibility your audiences intent is

00:26:16,340 --> 00:26:21,020
international please don't use phrases

00:26:18,590 --> 00:26:22,760
like this they aren't helpful they like

00:26:21,020 --> 00:26:24,980
an inside joke they're great if you know

00:26:22,760 --> 00:26:26,780
the context but just plain confusing if

00:26:24,980 --> 00:26:29,180
you don't and if your intention is to

00:26:26,780 --> 00:26:32,030
communicate effectively why would you

00:26:29,180 --> 00:26:33,770
intentionally be confusing and you may

00:26:32,030 --> 00:26:36,140
think oh but my audience is all local

00:26:33,770 --> 00:26:37,760
they all know this really tell me more

00:26:36,140 --> 00:26:39,290
about that what about recent immigrants

00:26:37,760 --> 00:26:40,940
what about people from outside the

00:26:39,290 --> 00:26:43,190
country who need to use use your service

00:26:40,940 --> 00:26:45,740
there is no service more American than

00:26:43,190 --> 00:26:47,090
the IRS the US tax office I am an

00:26:45,740 --> 00:26:48,980
Australian citizen who has lived in

00:26:47,090 --> 00:26:50,930
Australia my entire life but I have to

00:26:48,980 --> 00:26:52,490
dig through the IRS website to work out

00:26:50,930 --> 00:26:54,620
how to sort out my tax affairs with my

00:26:52,490 --> 00:26:56,540
employer when they say they're closed on

00:26:54,620 --> 00:26:58,160
Labor Day well for me

00:26:56,540 --> 00:27:02,810
Labor Day is the first Monday in March

00:26:58,160 --> 00:27:04,940
so why is the IRS closed in September my

00:27:02,810 --> 00:27:06,860
humble request for anyone doing any sort

00:27:04,940 --> 00:27:08,660
of date time based design is when you're

00:27:06,860 --> 00:27:09,560
using dates consider how they're going

00:27:08,660 --> 00:27:11,630
to be consumed

00:27:09,560 --> 00:27:14,060
if you ever display a date always

00:27:11,630 --> 00:27:15,620
display a year always use a text version

00:27:14,060 --> 00:27:17,780
of the month localized for your reader

00:27:15,620 --> 00:27:20,960
always display a time zone and in logs

00:27:17,780 --> 00:27:23,000
always use an ISO 8601 format details

00:27:20,960 --> 00:27:24,590
like year and timezone don't have to be

00:27:23,000 --> 00:27:26,390
front and center in your design they can

00:27:24,590 --> 00:27:29,240
be like a column heading or as hava text

00:27:26,390 --> 00:27:31,670
but included somehow reading a blog post

00:27:29,240 --> 00:27:33,740
that says published 3rd of May without a

00:27:31,670 --> 00:27:35,480
year how do I know if this information

00:27:33,740 --> 00:27:36,890
is current or not and if you're trying

00:27:35,480 --> 00:27:39,080
to correlate between the log of a

00:27:36,890 --> 00:27:40,910
database and a log of a web server and

00:27:39,080 --> 00:27:42,470
you've got a time stamp precise to the

00:27:40,910 --> 00:27:44,330
millisecond and then you work out the

00:27:42,470 --> 00:27:46,070
two events are different by 8 hours

00:27:44,330 --> 00:27:49,160
because one of them is in Perth time and

00:27:46,070 --> 00:27:51,080
one of them is in UTC that's fun or more

00:27:49,160 --> 00:27:52,700
likely in Django installs six hours out

00:27:51,080 --> 00:27:57,710
because one is in UTC time and one of

00:27:52,700 --> 00:28:00,830
them is in Chicago time thanks Adrian so

00:27:57,710 --> 00:28:02,990
in summary a date means nothing without

00:28:00,830 --> 00:28:04,640
a time a time means nothing without a

00:28:02,990 --> 00:28:07,370
date both of them are meaningless

00:28:04,640 --> 00:28:09,560
without a time zone or more specifically

00:28:07,370 --> 00:28:11,960
an accurate time zone resist the

00:28:09,560 --> 00:28:13,880
temptation to guess every time you guess

00:28:11,960 --> 00:28:16,610
someone's time zone assume you're going

00:28:13,880 --> 00:28:18,620
to get it wrong when you read dates

00:28:16,610 --> 00:28:20,090
localized for the author's format and do

00:28:18,620 --> 00:28:21,710
everything you can to get that right

00:28:20,090 --> 00:28:24,110
once you've got time zone information

00:28:21,710 --> 00:28:26,870
don't ever lose it because you can't get

00:28:24,110 --> 00:28:28,550
it back localized for the reader on

00:28:26,870 --> 00:28:31,040
output and consider how that output will

00:28:28,550 --> 00:28:33,860
be consumed not just now but in a year

00:28:31,040 --> 00:28:35,390
from now two years from now in many

00:28:33,860 --> 00:28:37,430
respects there's a really strong

00:28:35,390 --> 00:28:39,050
parallel here with Unicode handling the

00:28:37,430 --> 00:28:41,420
fundamental thing about getting Unicode

00:28:39,050 --> 00:28:44,510
right you need to know not guess know

00:28:41,420 --> 00:28:48,200
what format your data is in is it ASCII

00:28:44,510 --> 00:28:50,710
is it Latin 1 is it CP 1252 is it utf-8

00:28:48,200 --> 00:28:53,180
or is it actually a Unicode string

00:28:50,710 --> 00:28:55,160
porting from Python 2 to Python 3

00:28:53,180 --> 00:28:57,620
forced you to pay attention to this

00:28:55,160 --> 00:28:59,750
detail and verified every step whether

00:28:57,620 --> 00:29:01,730
the data you had was a Unicode string or

00:28:59,750 --> 00:29:04,100
data encoded in a particular format and

00:29:01,730 --> 00:29:06,530
if it was encoded what format was it in

00:29:04,100 --> 00:29:08,360
if you've got an existing blob of bytes

00:29:06,530 --> 00:29:10,310
and you don't know its format it's

00:29:08,360 --> 00:29:12,020
really really hard to accurately

00:29:10,310 --> 00:29:14,270
versus engineer that format you can

00:29:12,020 --> 00:29:16,240
guess your guests might even work right

00:29:14,270 --> 00:29:18,890
up until the point that it doesn't

00:29:16,240 --> 00:29:20,930
similarly if you don't have or you lose

00:29:18,890 --> 00:29:23,000
date time or times and information

00:29:20,930 --> 00:29:24,530
related to a timestamp it is almost

00:29:23,000 --> 00:29:27,080
impossible to reverse engineer

00:29:24,530 --> 00:29:29,000
accurately the only solution is to be

00:29:27,080 --> 00:29:30,560
really rigorous from the outset and make

00:29:29,000 --> 00:29:32,690
sure at every step of the process you

00:29:30,560 --> 00:29:35,750
know what you have once you've got it

00:29:32,690 --> 00:29:37,850
don't forget what you've got the good

00:29:35,750 --> 00:29:40,520
news if you think time is hard now you

00:29:37,850 --> 00:29:41,990
ain't seen nothing yet we are as a

00:29:40,520 --> 00:29:44,090
species on the cusp of becoming

00:29:41,990 --> 00:29:45,650
interplanetary which means certain basic

00:29:44,090 --> 00:29:48,200
assumptions about dates and times are

00:29:45,650 --> 00:29:51,610
about to go out the window a day on

00:29:48,200 --> 00:29:54,560
Venus is longer than a year on Venus a

00:29:51,610 --> 00:29:56,750
day in a year isn't the same length on

00:29:54,560 --> 00:29:58,670
any two planets so what's going to

00:29:56,750 --> 00:30:00,770
happen with times when a day isn't

00:29:58,670 --> 00:30:03,110
twenty-four hours long or time zones

00:30:00,770 --> 00:30:04,700
when to planetary times overlap what

00:30:03,110 --> 00:30:06,890
about signal propagation time between

00:30:04,700 --> 00:30:08,840
two planets now okay you're probably not

00:30:06,890 --> 00:30:12,620
gonna have those problems this week at

00:30:08,840 --> 00:30:14,420
work but GPS satellites already required

00:30:12,620 --> 00:30:17,000
date time calculations that involve

00:30:14,420 --> 00:30:18,680
adjustments due to special relativity so

00:30:17,000 --> 00:30:21,620
it's not as far off as you think and

00:30:18,680 --> 00:30:23,180
besides how many y2k problems do you

00:30:21,620 --> 00:30:24,440
think were caused by someone thinking

00:30:23,180 --> 00:30:29,390
they didn't need to worry about the

00:30:24,440 --> 00:30:30,920
distant future of the year 2000 but my

00:30:29,390 --> 00:30:33,470
time is running out so I better Robert

00:30:30,920 --> 00:30:34,520
wrap up as I said at the start my

00:30:33,470 --> 00:30:36,680
undergraduate degree is in physics

00:30:34,520 --> 00:30:38,360
physics is the study of fundamental

00:30:36,680 --> 00:30:40,070
forces and very early in a physics

00:30:38,360 --> 00:30:42,800
degree you get introduced the idea of

00:30:40,070 --> 00:30:44,900
MKS a MKS a is the set of fundamental

00:30:42,800 --> 00:30:47,120
units meters kelvins seconds and amperes

00:30:44,900 --> 00:30:48,110
and because the fundamental units are

00:30:47,120 --> 00:30:50,390
important they've all been quantified

00:30:48,110 --> 00:30:52,070
there is an ISO standard kilogram it's a

00:30:50,390 --> 00:30:54,350
thing that defines what a kilogram is

00:30:52,070 --> 00:30:56,150
you can hold it you can compare it to

00:30:54,350 --> 00:30:58,010
other kilograms and you can do the same

00:30:56,150 --> 00:31:00,290
with two samples of Kelvin two samples

00:30:58,010 --> 00:31:04,460
of amperes but you can't do that with

00:31:00,290 --> 00:31:08,030
time is this second the same length is

00:31:04,460 --> 00:31:09,980
this second who knows you can't put a

00:31:08,030 --> 00:31:13,490
second in a bottle times ephemeral it

00:31:09,980 --> 00:31:16,900
just is so don't feel too bad about time

00:31:13,490 --> 00:31:19,310
being hard it is that's just physics and

00:31:16,900 --> 00:31:20,720
it's really easy to throw your hands up

00:31:19,310 --> 00:31:23,090
in the air and declare time zones how do

00:31:20,720 --> 00:31:24,269
they even work and I'll admit even I do

00:31:23,090 --> 00:31:26,459
that when I've been bitten by them

00:31:24,269 --> 00:31:29,190
the third time in a day but just like

00:31:26,459 --> 00:31:30,539
physics and humans you can understand

00:31:29,190 --> 00:31:32,159
them if you put your mind to it and

00:31:30,539 --> 00:31:34,080
consider the Fulbright's of human

00:31:32,159 --> 00:31:36,929
experience treated as a challenge rather

00:31:34,080 --> 00:31:39,499
than an impossibility and plan and like

00:31:36,929 --> 00:31:43,619
all planning the best time to plan is

00:31:39,499 --> 00:31:45,089
ahead of time lastly if I may a quick

00:31:43,619 --> 00:31:46,409
plug as I mentioned at the start my open

00:31:45,089 --> 00:31:48,419
source contributions at the moment are

00:31:46,409 --> 00:31:50,549
mostly focused on B we're making Python

00:31:48,419 --> 00:31:52,320
a viable development platform for native

00:31:50,549 --> 00:31:54,149
apps and mobile platforms that's not my

00:31:52,320 --> 00:31:56,219
day job the simple fact is that time is

00:31:54,149 --> 00:31:57,479
money financial support means faster

00:31:56,219 --> 00:31:58,889
progress if you liked what you heard

00:31:57,479 --> 00:32:00,509
today if you want to help me and the

00:31:58,889 --> 00:32:01,739
beware project progressed faster one way

00:32:00,509 --> 00:32:03,809
you can do that is to join the project

00:32:01,739 --> 00:32:05,940
as a financial member plans start at us

00:32:03,809 --> 00:32:07,289
$10 a month details on that link if you

00:32:05,940 --> 00:32:08,879
want any more about beware or you have

00:32:07,289 --> 00:32:09,929
fresh ideas on how to monetize open

00:32:08,879 --> 00:32:11,609
source so you just want to chat about

00:32:09,929 --> 00:32:13,710
weird time zones and cool clocks please

00:32:11,609 --> 00:32:13,840
get in touch thank you very much

00:32:13,710 --> 00:32:15,770
[Music]

00:32:13,840 --> 00:32:18,880
[Applause]

00:32:15,770 --> 00:32:18,880

YouTube URL: https://www.youtube.com/watch?v=qabriMQ1SYs


