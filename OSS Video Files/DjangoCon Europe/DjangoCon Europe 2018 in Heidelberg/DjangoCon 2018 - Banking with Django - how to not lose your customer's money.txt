Title: DjangoCon 2018 - Banking with Django - how to not lose your customer's money
Publication date: 2018-05-25
Playlist: DjangoCon Europe 2018 in Heidelberg
Description: 
	https://media.ccc.de/v/hd-110-banking-with-django-how-to-not-lose-your-customer-s-money



Topic: Banking with Django - how to not lose  your customer's money
Abstract: How Holvi decided to pick Django as part of their core infrastructure. I'll go through both the business reasons for using Django for banking (5-10 minutes), and technical details of how we do reliable distributed software which keeps our and customer's money safe (10-20 minutes).



Anssi Kääriäinen
Captions: 
	00:00:06,649 --> 00:00:12,539
our next speaker is auntie Caroline and

00:00:10,740 --> 00:00:18,270
I hope I pronounced in last name

00:00:12,539 --> 00:00:21,210
correctly he's one of the she's a part

00:00:18,270 --> 00:00:23,609
of the Django team and brought a huge

00:00:21,210 --> 00:00:25,859
part of the ORM and now is he's going to

00:00:23,609 --> 00:00:27,750
talk to us today about how we lose all

00:00:25,859 --> 00:00:40,739
our customers money sorry how we not

00:00:27,750 --> 00:00:42,690
lose our customers money so my name is

00:00:40,739 --> 00:00:45,989
Monica and I'm here to talk about using

00:00:42,690 --> 00:00:49,860
Django in a banking setup and of course

00:00:45,989 --> 00:00:53,780
about the making reliable banking with

00:00:49,860 --> 00:00:58,049
Django or first bit about me so I

00:00:53,780 --> 00:00:59,400
probably as a back-end lead I've been

00:00:58,049 --> 00:01:01,489
working over there for a couple of years

00:00:59,400 --> 00:01:05,150
I enjoy it a lot

00:01:01,489 --> 00:01:09,649
I'm also have been doing some homework

00:01:05,150 --> 00:01:11,009
so from 2012 I have been Django core

00:01:09,649 --> 00:01:13,469
contributor

00:01:11,009 --> 00:01:16,859
we have done the over him a lot until a

00:01:13,469 --> 00:01:18,840
couple of years ago now I have a couple

00:01:16,859 --> 00:01:20,399
of small kids so that's taking all of my

00:01:18,840 --> 00:01:24,509
time but I'm hoping to get back to

00:01:20,399 --> 00:01:28,439
jungle at some point so first a quick

00:01:24,509 --> 00:01:31,020
introduction to what all of it does so

00:01:28,439 --> 00:01:33,929
we offer business banking services to

00:01:31,020 --> 00:01:37,020
micro entrepreneurs in Finland Germany

00:01:33,929 --> 00:01:40,079
Austria and to e residents of St Estonia

00:01:37,020 --> 00:01:42,600
the interested ins is actually a pretty

00:01:40,079 --> 00:01:46,560
fun set up so anywhere in the world you

00:01:42,600 --> 00:01:49,770
can go to Estonian Embassy register as

00:01:46,560 --> 00:01:52,350
an Estonian and then you can set up

00:01:49,770 --> 00:01:59,299
banking you can set up a business like

00:01:52,350 --> 00:02:02,749
you were real Estonian origin and that

00:01:59,299 --> 00:02:04,829
way you can without ever visiting

00:02:02,749 --> 00:02:09,119
Estonia you can actually set up a

00:02:04,829 --> 00:02:10,709
business in Europe holy - holy has a

00:02:09,119 --> 00:02:13,830
payment account so it's very much like a

00:02:10,709 --> 00:02:15,750
banking bank account except for legal

00:02:13,830 --> 00:02:18,570
reasons it's kind of different but for

00:02:15,750 --> 00:02:20,160
practical purposes it's it offers us a

00:02:18,570 --> 00:02:22,890
payment it off as you

00:02:20,160 --> 00:02:24,570
MasterCard it offers your online

00:02:22,890 --> 00:02:26,460
payments which you can use with the

00:02:24,570 --> 00:02:29,310
whole the online shop on top of the bank

00:02:26,460 --> 00:02:31,230
account we have a we have some business

00:02:29,310 --> 00:02:33,570
tools so we have Universal you can

00:02:31,230 --> 00:02:35,280
create invoices send them to somebody

00:02:33,570 --> 00:02:37,170
collect money so you get the separate

00:02:35,280 --> 00:02:38,940
transfer you know we automatically match

00:02:37,170 --> 00:02:41,280
the payment to the universe we do the

00:02:38,940 --> 00:02:44,250
bookkeeping for you or we have an online

00:02:41,280 --> 00:02:48,120
shop so you can sell stuff online it's

00:02:44,250 --> 00:02:50,580
for small shops but it's really quick to

00:02:48,120 --> 00:02:54,120
set up so it takes a couple of minutes

00:02:50,580 --> 00:02:55,620
to start selling something online again

00:02:54,120 --> 00:02:59,130
you get the money immediately when

00:02:55,620 --> 00:03:00,510
somebody pay buy something from you you

00:02:59,130 --> 00:03:03,210
get the money immediately on your

00:03:00,510 --> 00:03:06,690
account and we do the bookkeeping or

00:03:03,210 --> 00:03:08,100
that for you finally we have the expense

00:03:06,690 --> 00:03:11,130
handling so when you are traveling you

00:03:08,100 --> 00:03:13,170
can go to somewhere every taxi or use

00:03:11,130 --> 00:03:17,250
your MasterCard you get a push

00:03:13,170 --> 00:03:19,470
notification when you paid so you can do

00:03:17,250 --> 00:03:21,360
the bookkeeping easily on the go you

00:03:19,470 --> 00:03:23,910
take pictures to resit you do the

00:03:21,360 --> 00:03:27,209
category systems Yeti stuff so you get

00:03:23,910 --> 00:03:31,050
the bookkeeping preparation done or real

00:03:27,209 --> 00:03:34,560
time so that is what whole bit us it's

00:03:31,050 --> 00:03:36,720
an interesting opening try it out if you

00:03:34,560 --> 00:03:41,550
are in one of the markets or well if you

00:03:36,720 --> 00:03:44,820
want to be an Estonian otech stuck

00:03:41,550 --> 00:03:47,100
nothing more special going on in there

00:03:44,820 --> 00:03:48,780
but I'll go through it in any case so

00:03:47,100 --> 00:03:51,959
you understand what we are using on the

00:03:48,780 --> 00:03:53,190
backend side so we have jungle of course

00:03:51,959 --> 00:03:58,290
and then we have Django rest framework

00:03:53,190 --> 00:04:01,170
or using PostgreSQL then we have celery

00:03:58,290 --> 00:04:04,620
for a synchronous Taft for doing these

00:04:01,170 --> 00:04:08,310
schedule tasks using Reddy's behind that

00:04:04,620 --> 00:04:11,580
or we have angular on the front end side

00:04:08,310 --> 00:04:14,480
I don't know that much about it but it

00:04:11,580 --> 00:04:17,850
works really well for us we have the

00:04:14,480 --> 00:04:21,720
native mobile apps we have iOS Android

00:04:17,850 --> 00:04:24,690
and finally we are running all of this

00:04:21,720 --> 00:04:28,500
on Amazon so we use s3v is the easy to

00:04:24,690 --> 00:04:30,120
you will use a lot of services areas for

00:04:28,500 --> 00:04:32,550
example from Amazon and it's working

00:04:30,120 --> 00:04:35,990
really well there for us jungle for us

00:04:32,550 --> 00:04:35,990
has been a good

00:04:36,440 --> 00:04:41,850
the ecosystem is really nice for pretty

00:04:39,900 --> 00:04:45,090
much anything you want to do you find

00:04:41,850 --> 00:04:49,880
something already or existing so that's

00:04:45,090 --> 00:04:52,350
a big plus when you using Django it's

00:04:49,880 --> 00:04:53,790
it's an overstatement to say that it's

00:04:52,350 --> 00:04:56,460
easy to find developers but there are a

00:04:53,790 --> 00:04:57,930
lot of developers using jungle at the

00:04:56,460 --> 00:05:00,450
moment in Finland of course you know

00:04:57,930 --> 00:05:04,260
anybody who has seen a computer is

00:05:00,450 --> 00:05:05,850
immediately hired so so it's kind of not

00:05:04,260 --> 00:05:07,320
that easy to find the developers but at

00:05:05,850 --> 00:05:10,140
least there are a lot of developers who

00:05:07,320 --> 00:05:13,350
know the jungle and finally it's

00:05:10,140 --> 00:05:15,330
reliable it's proven software it works

00:05:13,350 --> 00:05:19,470
really well for banking setup we are

00:05:15,330 --> 00:05:22,530
using jungle for 99% of the code we have

00:05:19,470 --> 00:05:27,240
so and it works really well it's

00:05:22,530 --> 00:05:32,100
reliable it's as all of the basic things

00:05:27,240 --> 00:05:38,730
you need for building something for

00:05:32,100 --> 00:05:40,860
banking so my sub topic for today is

00:05:38,730 --> 00:05:43,650
that how not to lose your customers

00:05:40,860 --> 00:05:46,710
money there are two options the first

00:05:43,650 --> 00:05:48,890
option which we try to use is reliable

00:05:46,710 --> 00:05:51,570
payments you don't lose the payments you

00:05:48,890 --> 00:05:54,180
always get them go through the system

00:05:51,570 --> 00:05:57,180
and everybody's happy but in case

00:05:54,180 --> 00:05:59,670
there's an error somewhere you lose a

00:05:57,180 --> 00:06:01,770
message you you have a box somewhere

00:05:59,670 --> 00:06:03,900
it's not that you lose your customers

00:06:01,770 --> 00:06:06,510
money you actually lose your own money

00:06:03,900 --> 00:06:08,580
you need to use a lot of time for each

00:06:06,510 --> 00:06:11,070
error case to solve it out that hey is

00:06:08,580 --> 00:06:12,450
this really an error case what's

00:06:11,070 --> 00:06:14,670
happening in the system where is the

00:06:12,450 --> 00:06:17,400
money and in the worst case you for

00:06:14,670 --> 00:06:19,590
example can double execute a payment you

00:06:17,400 --> 00:06:23,640
send thousand years two times to

00:06:19,590 --> 00:06:25,950
somewhere and it's often impossible to

00:06:23,640 --> 00:06:27,510
get the money back so there it went you

00:06:25,950 --> 00:06:29,910
lost your own money but you actually

00:06:27,510 --> 00:06:32,370
don't ever lose your customers money

00:06:29,910 --> 00:06:34,650
because that's the way banks work you

00:06:32,370 --> 00:06:38,879
you take the losses for yourself instead

00:06:34,650 --> 00:06:41,770
of anything one for the customers

00:06:38,879 --> 00:06:45,789
so I'm quickly going to introduce the

00:06:41,770 --> 00:06:48,370
play payment flow so just to have the

00:06:45,789 --> 00:06:50,349
mindset for how this thing works in

00:06:48,370 --> 00:06:53,860
Holloway this is a bit simplified but it

00:06:50,349 --> 00:06:55,569
it has all the major pieces in there so

00:06:53,860 --> 00:06:57,969
it starts with customer verifying a

00:06:55,569 --> 00:07:01,419
payment typing in the Iban and stuff

00:06:57,969 --> 00:07:03,610
like that then they receive a push

00:07:01,419 --> 00:07:05,979
notification with the security token so

00:07:03,610 --> 00:07:09,460
we do two-factor authentication with

00:07:05,979 --> 00:07:12,310
that they type it in click verify the

00:07:09,460 --> 00:07:14,680
payment goes out then actually starts

00:07:12,310 --> 00:07:16,780
the kind of the payment processing

00:07:14,680 --> 00:07:20,379
inside hold so first we make a message

00:07:16,780 --> 00:07:22,979
we recording this in the front end side

00:07:20,379 --> 00:07:26,770
where the customer facing side of the

00:07:22,979 --> 00:07:30,159
back end and then we send a message to

00:07:26,770 --> 00:07:32,469
cor accounting the next player which

00:07:30,159 --> 00:07:35,050
handles actually the all of the money we

00:07:32,469 --> 00:07:38,050
want to keep that at least concept

00:07:35,050 --> 00:07:39,969
conceptually separate from the customer

00:07:38,050 --> 00:07:43,120
facing features for security for

00:07:39,969 --> 00:07:44,979
performers for you can change the

00:07:43,120 --> 00:07:48,279
customer facing features quickly but you

00:07:44,979 --> 00:07:51,610
want to keep the core accounting such

00:07:48,279 --> 00:07:53,529
that you don't change it too often then

00:07:51,610 --> 00:07:55,000
kora counting will be send a message to

00:07:53,529 --> 00:07:57,159
approvers this is something that was

00:07:55,000 --> 00:07:58,779
kind of a surprise for me that actually

00:07:57,159 --> 00:08:03,250
the approvers how do you verify that

00:07:58,779 --> 00:08:07,300
this payment is ok that's that's causing

00:08:03,250 --> 00:08:09,219
a lot of the issues when you are trying

00:08:07,300 --> 00:08:12,250
to build a banking setup so you have a

00:08:09,219 --> 00:08:15,120
lot of compliance rules from the law for

00:08:12,250 --> 00:08:17,680
example that you don't send money to

00:08:15,120 --> 00:08:19,990
terrorists you don't send money for

00:08:17,680 --> 00:08:21,789
money laundering purposes and then you

00:08:19,990 --> 00:08:24,849
of course need to handle your own risk

00:08:21,789 --> 00:08:27,940
so you check that is everything ok with

00:08:24,849 --> 00:08:32,500
the payment from kind of somebody trying

00:08:27,940 --> 00:08:35,349
to empty their account illegally then

00:08:32,500 --> 00:08:36,579
okay somehow we approve the payment by

00:08:35,349 --> 00:08:39,820
some machine learning approach or

00:08:36,579 --> 00:08:41,349
manually we get an other message for the

00:08:39,820 --> 00:08:43,240
core accounting that ok this money is

00:08:41,349 --> 00:08:45,399
now ok to move out of start of holiday

00:08:43,240 --> 00:08:47,640
then you get the message to bank gateway

00:08:45,399 --> 00:08:50,740
bank address the system we use for

00:08:47,640 --> 00:08:53,140
interacting the external banking world

00:08:50,740 --> 00:08:56,320
the external banking world in many cases

00:08:53,140 --> 00:08:59,320
it's based on technologies from 80s it's

00:08:56,320 --> 00:09:01,180
very much bad based so in the banquette

00:08:59,320 --> 00:09:03,430
where we take all of the payments and

00:09:01,180 --> 00:09:07,600
build the backs of those send an XML

00:09:03,430 --> 00:09:09,190
somewhere outside of our system but

00:09:07,600 --> 00:09:10,750
inside holily everything is message

00:09:09,190 --> 00:09:14,950
space and everything is real bad but

00:09:10,750 --> 00:09:18,040
when it gets to the external banking

00:09:14,950 --> 00:09:19,480
then it turns to into a batch into the

00:09:18,040 --> 00:09:21,279
other direction it's pretty much the

00:09:19,480 --> 00:09:23,350
same setup so now you get the bad from

00:09:21,279 --> 00:09:25,120
external banking then you get the

00:09:23,350 --> 00:09:28,720
payments message to Korra counting from

00:09:25,120 --> 00:09:30,910
your bank gateway you do the approvals

00:09:28,720 --> 00:09:33,279
couple of messaging go going over in

00:09:30,910 --> 00:09:36,850
there then you get the message to the

00:09:33,279 --> 00:09:39,130
business tools so the customer facing

00:09:36,850 --> 00:09:41,649
backend where we do all of the

00:09:39,130 --> 00:09:43,570
bookkeeping and stuff like that

00:09:41,649 --> 00:09:47,470
and finally you try to automate the

00:09:43,570 --> 00:09:49,510
bookkeeping and or depending on the case

00:09:47,470 --> 00:09:52,500
you send a notification to the customer

00:09:49,510 --> 00:09:58,560
and now you receive hundred euros of

00:09:52,500 --> 00:10:01,240
money so the reliability in this case

00:09:58,560 --> 00:10:05,350
for a startup you must have a hundred

00:10:01,240 --> 00:10:08,770
payment today it's low amount at this

00:10:05,350 --> 00:10:11,080
point you probably have a kind of simple

00:10:08,770 --> 00:10:12,910
system still so you just use couple of

00:10:11,080 --> 00:10:14,980
messages you don't do the approvals by

00:10:12,910 --> 00:10:19,510
having a separate system somewhere but

00:10:14,980 --> 00:10:21,370
you do it maybe by just using a jungle

00:10:19,510 --> 00:10:24,370
admin and checking the tail it seems

00:10:21,370 --> 00:10:27,370
okay you reliably my reliability might

00:10:24,370 --> 00:10:29,560
not be that high three nines so one in

00:10:27,370 --> 00:10:31,480
thousand messages of these two messages

00:10:29,560 --> 00:10:33,640
across this means that you get one case

00:10:31,480 --> 00:10:36,279
a week it's fine

00:10:33,640 --> 00:10:39,130
that's easily doable by hand so no

00:10:36,279 --> 00:10:40,959
problem in that case actually an

00:10:39,130 --> 00:10:43,630
interesting story about how early in the

00:10:40,959 --> 00:10:45,430
beginning very beginning of hallway the

00:10:43,630 --> 00:10:50,290
system we have such that when when the

00:10:45,430 --> 00:10:52,510
user type payment out they fill the form

00:10:50,290 --> 00:10:54,279
clicked ok pay this what's happened in

00:10:52,510 --> 00:10:55,779
the backend was that somebody copied the

00:10:54,279 --> 00:10:59,079
data from John who had been to an

00:10:55,779 --> 00:11:01,959
external bank by hand and it worked for

00:10:59,079 --> 00:11:04,470
the very beginning of Holloway so kind

00:11:01,959 --> 00:11:11,519
of getting back to the sophistication

00:11:04,470 --> 00:11:14,100
we had in the morning by Daniel so if

00:11:11,519 --> 00:11:16,350
you are stored up you can do something

00:11:14,100 --> 00:11:19,980
very unsophisticated and it works really

00:11:16,350 --> 00:11:21,449
well for for the beginning so you can

00:11:19,980 --> 00:11:22,680
prove the concept and then start

00:11:21,449 --> 00:11:26,779
improving it now

00:11:22,680 --> 00:11:29,910
all these now in the mid sized faced

00:11:26,779 --> 00:11:32,399
these numbers are not real numbers from

00:11:29,910 --> 00:11:36,060
holiday we have a bit different numbers

00:11:32,399 --> 00:11:39,839
but this kind of reflects what we have

00:11:36,060 --> 00:11:42,240
in oven so 10,000 payments day file

00:11:39,839 --> 00:11:45,089
method see spare payment so now as you

00:11:42,240 --> 00:11:48,089
saw the flows the messaging amounts are

00:11:45,089 --> 00:11:50,879
now a bit higher we have the approval

00:11:48,089 --> 00:11:52,560
system we have the backend or the

00:11:50,879 --> 00:11:54,720
customer facing back-end we have the

00:11:52,560 --> 00:11:58,350
core accounting back-end talking with

00:11:54,720 --> 00:12:00,149
each other the reliability has gone up a

00:11:58,350 --> 00:12:02,639
bit so you lose one mess it's out of

00:12:00,149 --> 00:12:06,689
10,000 this means that you get on

00:12:02,639 --> 00:12:08,310
average 5 cases a day and if it takes

00:12:06,689 --> 00:12:10,709
you a couple of hours if you haven't

00:12:08,310 --> 00:12:13,019
automated resolving the payments if it

00:12:10,709 --> 00:12:15,689
takes a couple of hours per payment

00:12:13,019 --> 00:12:17,790
failed payment you need now a dedicated

00:12:15,689 --> 00:12:21,089
person maybe even two dedicated persons

00:12:17,790 --> 00:12:22,740
to solo out these payments and it's

00:12:21,089 --> 00:12:24,199
really not cost-effective so at this

00:12:22,740 --> 00:12:26,430
point you want to start to have

00:12:24,199 --> 00:12:31,649
reliability and we are now building the

00:12:26,430 --> 00:12:33,660
reliability for the messaging finally on

00:12:31,649 --> 00:12:36,089
the enterprise level just as an example

00:12:33,660 --> 00:12:37,560
if you get my million payments a day ten

00:12:36,089 --> 00:12:42,360
messages per payment so now you are

00:12:37,560 --> 00:12:44,069
making it more micro service style you

00:12:42,360 --> 00:12:46,230
have improved your reliability you have

00:12:44,069 --> 00:12:49,529
invested a lot on your architecture kind

00:12:46,230 --> 00:12:51,149
of the hardware and now you have five

00:12:49,529 --> 00:12:54,120
nines reliability which is really good

00:12:51,149 --> 00:12:55,769
but you still get 100 cases today which

00:12:54,120 --> 00:12:58,470
means that you have a department of

00:12:55,769 --> 00:13:01,019
solving these cases so when you scale up

00:12:58,470 --> 00:13:07,079
you want to build more reliability into

00:13:01,019 --> 00:13:10,439
your system so the thing that I see very

00:13:07,079 --> 00:13:12,809
often is that people build these systems

00:13:10,439 --> 00:13:14,519
micro services or other word systems

00:13:12,809 --> 00:13:16,770
where you have messaging but they don't

00:13:14,519 --> 00:13:20,160
build reliably into the messaging

00:13:16,770 --> 00:13:22,440
that's fine if you don't have that many

00:13:20,160 --> 00:13:24,779
messages or if it's fine to lose some

00:13:22,440 --> 00:13:26,760
messages so if you for example to push

00:13:24,779 --> 00:13:28,890
notifications we send to the customers

00:13:26,760 --> 00:13:30,899
it's fun to lose one in 10,000 it's not

00:13:28,890 --> 00:13:33,180
a problem at all but the payment message

00:13:30,899 --> 00:13:34,770
is its family we lose it pretty much

00:13:33,180 --> 00:13:36,630
it's done we will get a call from the

00:13:34,770 --> 00:13:38,640
customer that hey no my money is missing

00:13:36,630 --> 00:13:42,060
do something and we get to do the work

00:13:38,640 --> 00:13:45,540
or we get to paid money so we want to

00:13:42,060 --> 00:13:50,370
build the messaging reliable so the idea

00:13:45,540 --> 00:13:52,290
we are using is that we in the origin

00:13:50,370 --> 00:13:54,570
system for example in the approval

00:13:52,290 --> 00:13:57,330
system when we record at hey okay this

00:13:54,570 --> 00:14:00,089
payment is now approved at the same time

00:13:57,330 --> 00:14:02,790
we record a message to the local

00:14:00,089 --> 00:14:06,390
database inside the same transaction so

00:14:02,790 --> 00:14:08,459
if the approval gets committed to the

00:14:06,390 --> 00:14:12,149
database also the dead message gets

00:14:08,459 --> 00:14:15,270
committed to the database then on commit

00:14:12,149 --> 00:14:17,940
using jungles on commit you can find

00:14:15,270 --> 00:14:20,040
more about it in the documentation we

00:14:17,940 --> 00:14:22,170
send the message so only after it has

00:14:20,040 --> 00:14:24,690
been committed to the database we send

00:14:22,170 --> 00:14:26,399
the message to the next system the idea

00:14:24,690 --> 00:14:28,200
over here is that if you send the

00:14:26,399 --> 00:14:31,440
message before it's committed to the

00:14:28,200 --> 00:14:36,810
system you can have the hardest to debug

00:14:31,440 --> 00:14:40,550
failure case so for example if you have

00:14:36,810 --> 00:14:43,260
the customer verifying a payment you

00:14:40,550 --> 00:14:47,070
first record that inside the transaction

00:14:43,260 --> 00:14:49,200
to the database then you send the

00:14:47,070 --> 00:14:50,760
message about that and then for some

00:14:49,200 --> 00:14:53,670
reason the transaction does not get

00:14:50,760 --> 00:14:55,709
committed you have a message over in the

00:14:53,670 --> 00:14:58,230
core accounting that okay customers and

00:14:55,709 --> 00:15:01,440
hundred euros of money out of the

00:14:58,230 --> 00:15:03,089
account but in the original system you

00:15:01,440 --> 00:15:04,529
see nothing about that you might have

00:15:03,089 --> 00:15:06,420
something in the logs but you have this

00:15:04,529 --> 00:15:09,990
phantom message you don't not see

00:15:06,420 --> 00:15:13,200
anything in the database and it's really

00:15:09,990 --> 00:15:14,790
hard to debug these cases so use on

00:15:13,200 --> 00:15:17,940
commit if you are doing messaging

00:15:14,790 --> 00:15:20,190
because in the other direction it's

00:15:17,940 --> 00:15:24,209
quite reliable but when you get to error

00:15:20,190 --> 00:15:27,089
case it's really hard to debug okay now

00:15:24,209 --> 00:15:29,800
one commit is not guaranteed to run or

00:15:27,089 --> 00:15:31,810
you can have some errors actually yeah

00:15:29,800 --> 00:15:33,430
on comets we are actually in hallway we

00:15:31,810 --> 00:15:37,240
are creating an awesome Chronos task

00:15:33,430 --> 00:15:40,029
which we then execute because on commit

00:15:37,240 --> 00:15:43,320
you don't want to run anything heavy but

00:15:40,029 --> 00:15:46,029
you can kind of do lightweight HTTP

00:15:43,320 --> 00:15:47,950
requests for example in the oncoming but

00:15:46,029 --> 00:15:50,079
it might fail you might have a network

00:15:47,950 --> 00:15:52,209
error you might have a the other system

00:15:50,079 --> 00:15:53,560
might be dumb it might be overloaded so

00:15:52,209 --> 00:15:55,930
if you get the backs of payments in

00:15:53,560 --> 00:15:57,339
thousand payments coming in and you fire

00:15:55,930 --> 00:16:02,709
you as fast as you can to the other

00:15:57,339 --> 00:16:05,100
system it will get overloaded and then

00:16:02,709 --> 00:16:08,589
you need to retry so the idea is that

00:16:05,100 --> 00:16:10,750
only on commit you send the message from

00:16:08,589 --> 00:16:13,420
the local database then you retry if it

00:16:10,750 --> 00:16:15,100
doesn't go first true finally on the

00:16:13,420 --> 00:16:17,470
receiving side when you re trying you

00:16:15,100 --> 00:16:20,920
need to deduplicate so you get this it

00:16:17,470 --> 00:16:24,070
importance a set up where basically the

00:16:20,920 --> 00:16:27,130
semantics are exactly ones this way we

00:16:24,070 --> 00:16:29,980
have reliable message messaging this

00:16:27,130 --> 00:16:32,440
works I have also been talking with some

00:16:29,980 --> 00:16:35,410
consultants from other companies and

00:16:32,440 --> 00:16:37,029
they are using for banking and they are

00:16:35,410 --> 00:16:40,750
using something very much like this so

00:16:37,029 --> 00:16:42,339
it's it's a proven system it's some some

00:16:40,750 --> 00:16:44,190
might say that it's a maybe a bit

00:16:42,339 --> 00:16:49,089
heavyweight but it's it's really

00:16:44,190 --> 00:16:50,620
reliable okay now you can abstract this

00:16:49,089 --> 00:16:53,680
model you can have this inbox outbox

00:16:50,620 --> 00:16:56,500
model so in the original system you have

00:16:53,680 --> 00:16:59,709
the outbox where you record the messages

00:16:56,500 --> 00:17:01,300
basically you have an OID you have to

00:16:59,709 --> 00:17:02,890
payload you have a couple of time stamps

00:17:01,300 --> 00:17:05,890
when the message was created when this

00:17:02,890 --> 00:17:10,990
when was it processed or sent out from

00:17:05,890 --> 00:17:14,169
the system then you do the uncommon send

00:17:10,990 --> 00:17:16,780
and so on on receiving side all of the

00:17:14,169 --> 00:17:19,559
messages from the outbox of the other

00:17:16,780 --> 00:17:21,760
system you store them in an inbox and

00:17:19,559 --> 00:17:23,740
you should have a unique constraint on

00:17:21,760 --> 00:17:25,540
the inbox so that the origin sorry you

00:17:23,740 --> 00:17:25,990
don't process the same message multiple

00:17:25,540 --> 00:17:28,390
times

00:17:25,990 --> 00:17:31,660
so doing a deep dublicate and by having

00:17:28,390 --> 00:17:33,730
a PostgreSQL unique constraint or

00:17:31,660 --> 00:17:38,130
database unique constraint so it doesn't

00:17:33,730 --> 00:17:40,480
need to be both Cresco finally you do

00:17:38,130 --> 00:17:42,580
reconciliation checks with the inbox and

00:17:40,480 --> 00:17:43,510
outbox you check okay in the last hour

00:17:42,580 --> 00:17:48,130
how many

00:17:43,510 --> 00:17:49,660
messages did I send from system a how

00:17:48,130 --> 00:17:53,260
many messages you are having the alt box

00:17:49,660 --> 00:17:56,470
and in the receiving system you said

00:17:53,260 --> 00:18:01,960
check okay how many messages there are

00:17:56,470 --> 00:18:06,400
in the inbox they would count smash if

00:18:01,960 --> 00:18:08,650
they don't you can react fast also you

00:18:06,400 --> 00:18:10,840
can easily if some message is lost

00:18:08,650 --> 00:18:12,880
somewhere even with this setup you can

00:18:10,840 --> 00:18:14,440
from the alt box you can just have an

00:18:12,880 --> 00:18:21,040
admin view and click some message that

00:18:14,440 --> 00:18:23,860
ok resend this ok how do you actually

00:18:21,040 --> 00:18:26,460
transport the messages for reliability

00:18:23,860 --> 00:18:30,460
it turns out it's not important

00:18:26,460 --> 00:18:31,900
you can use HTTP with rest so now the

00:18:30,460 --> 00:18:32,830
simple setup is that you have an one

00:18:31,900 --> 00:18:34,780
origin system

00:18:32,830 --> 00:18:37,080
you have one receiver system and you

00:18:34,780 --> 00:18:41,620
send the messages just using the

00:18:37,080 --> 00:18:43,890
standard request library and then rest

00:18:41,620 --> 00:18:46,540
framework on the other side it works

00:18:43,890 --> 00:18:49,570
pretty well of course you can have these

00:18:46,540 --> 00:18:50,920
cases where you overload the other

00:18:49,570 --> 00:18:53,050
system but it's fine

00:18:50,920 --> 00:18:56,380
you have this free trying logic so it

00:18:53,050 --> 00:19:00,880
will be eventually sent over to the

00:18:56,380 --> 00:19:05,650
other system but if you want to do for

00:19:00,880 --> 00:19:07,270
example this pub/sub type of thing it's

00:19:05,650 --> 00:19:11,440
really nice to use something in between

00:19:07,270 --> 00:19:14,050
that does the pub/sub so you from the

00:19:11,440 --> 00:19:17,280
origin you still have the route box from

00:19:14,050 --> 00:19:22,900
the outbox uncommit you sent to Kafka

00:19:17,280 --> 00:19:27,310
Kafka does it thing it can do things

00:19:22,900 --> 00:19:29,740
like check with receivers are allowed to

00:19:27,310 --> 00:19:31,840
see which messages you can't get the

00:19:29,740 --> 00:19:36,010
rate-limiting because the receivers can

00:19:31,840 --> 00:19:37,840
play the log as fast as they can but if

00:19:36,010 --> 00:19:40,720
they fall behind it's fine they can just

00:19:37,840 --> 00:19:44,230
keep on doing their stuff until they

00:19:40,720 --> 00:19:45,760
catch up and of course two receivers

00:19:44,230 --> 00:19:49,930
over here there can be different systems

00:19:45,760 --> 00:19:52,660
and so you get through pub/sub so you

00:19:49,930 --> 00:19:54,370
can do stuff like okay I got to payment

00:19:52,660 --> 00:19:56,320
in at the same time send push

00:19:54,370 --> 00:19:57,340
notifications to customers at the same

00:19:56,320 --> 00:20:00,760
time

00:19:57,340 --> 00:20:03,180
to do some machine learning or use some

00:20:00,760 --> 00:20:05,200
machine learning based approach on the

00:20:03,180 --> 00:20:07,960
category session so we can check that

00:20:05,200 --> 00:20:10,870
okay how to push this message to

00:20:07,960 --> 00:20:13,450
bookkeeping and so and so you can you

00:20:10,870 --> 00:20:16,330
can do the true pub/sub with Kafka so

00:20:13,450 --> 00:20:18,700
the transport using Kafka it's important

00:20:16,330 --> 00:20:21,250
or it's very useful when you are trying

00:20:18,700 --> 00:20:23,170
to get these benefits but it's not

00:20:21,250 --> 00:20:26,320
actually that important for reliable

00:20:23,170 --> 00:20:28,660
team and finally of course you have the

00:20:26,320 --> 00:20:30,760
art books in box model over here still

00:20:28,660 --> 00:20:32,110
so you can do the reconciliation of ok I

00:20:30,760 --> 00:20:40,140
have these methods in actually being

00:20:32,110 --> 00:20:44,920
sent so this was mostly about

00:20:40,140 --> 00:20:46,600
reliability considerations of messaging

00:20:44,920 --> 00:20:50,080
so now you have a message thing set up

00:20:46,600 --> 00:20:53,830
that works really well it turns out as

00:20:50,080 --> 00:20:55,780
you very likely know that the most

00:20:53,830 --> 00:21:01,030
likely reason for error is that somebody

00:20:55,780 --> 00:21:04,060
makes a programming mistakes so what we

00:21:01,030 --> 00:21:07,390
are doing is that we have this of course

00:21:04,060 --> 00:21:09,190
we are using pretty standard practices

00:21:07,390 --> 00:21:14,550
for developing our software so we have

00:21:09,190 --> 00:21:17,200
this Destrehan development approach

00:21:14,550 --> 00:21:19,180
we've write tests we have continuous in

00:21:17,200 --> 00:21:21,130
the questions we do reviews in github so

00:21:19,180 --> 00:21:23,880
everything that goes in it's actually

00:21:21,130 --> 00:21:28,750
from compliance point of view also

00:21:23,880 --> 00:21:30,970
important that you review the code so

00:21:28,750 --> 00:21:34,090
everything needs to be checked by

00:21:30,970 --> 00:21:37,930
somebody else we react quickly to

00:21:34,090 --> 00:21:40,570
failures so this is actually pretty

00:21:37,930 --> 00:21:44,290
important from the customers point of

00:21:40,570 --> 00:21:46,030
view that if a payment is delayed for a

00:21:44,290 --> 00:21:48,130
couple of hours it's it's fine

00:21:46,030 --> 00:21:51,730
if we react to it if the customer needs

00:21:48,130 --> 00:21:56,680
to call us you have a problem in this

00:21:51,730 --> 00:21:58,840
problem customer trust in Holloway and

00:21:56,680 --> 00:22:00,190
of course you get to do a lot of more

00:21:58,840 --> 00:22:02,590
work because then you need to do the

00:22:00,190 --> 00:22:05,710
customer communications that ok yes this

00:22:02,590 --> 00:22:07,570
payment was was lost B we fixed it by

00:22:05,710 --> 00:22:10,649
doing something and now it's fine

00:22:07,570 --> 00:22:13,149
so it cost you a lot of money

00:22:10,649 --> 00:22:14,739
always fix the origin or reason so if

00:22:13,149 --> 00:22:17,229
you find that hey something strange is

00:22:14,739 --> 00:22:21,099
happening try to find out what's the

00:22:17,229 --> 00:22:23,649
origin or reason do do not just check

00:22:21,099 --> 00:22:25,239
that okay I made the payment now go

00:22:23,649 --> 00:22:27,909
through I just clicked somewhere that

00:22:25,239 --> 00:22:29,289
okay to retry this but try to find out

00:22:27,909 --> 00:22:31,959
what's what's wrong in the system

00:22:29,289 --> 00:22:34,769
because when you are scaling up you want

00:22:31,959 --> 00:22:37,359
to get more and more reliability

00:22:34,769 --> 00:22:39,759
otherwise it's going to be really really

00:22:37,359 --> 00:22:43,319
painful if you go for the end price

00:22:39,759 --> 00:22:45,339
level and we are using monitoring and

00:22:43,319 --> 00:22:47,949
Reconciliation I said a bit about the

00:22:45,339 --> 00:22:51,129
reconciliation of the inbox outbox model

00:22:47,949 --> 00:22:53,349
but there is also reconciliation you can

00:22:51,129 --> 00:22:55,719
do on a business logical level so you

00:22:53,349 --> 00:22:58,539
check in one system that how much money

00:22:55,719 --> 00:23:01,329
you have moved out use checking in other

00:22:58,539 --> 00:23:03,669
systems that do they match the do the

00:23:01,329 --> 00:23:07,479
amounts match if you do this constantly

00:23:03,669 --> 00:23:10,149
you'll quickly see the cases where you

00:23:07,479 --> 00:23:12,729
have these error cases and you can fix

00:23:10,149 --> 00:23:16,269
them quickly without needing to wait for

00:23:12,729 --> 00:23:17,979
customers to call you in many cases it

00:23:16,269 --> 00:23:20,409
happens actually if the customers call

00:23:17,979 --> 00:23:23,349
you it takes a lot of time to react

00:23:20,409 --> 00:23:26,440
because I have seen a couple of cases

00:23:23,349 --> 00:23:27,969
where it has taken more than a week than

00:23:26,440 --> 00:23:30,159
when you get to initial call that has

00:23:27,969 --> 00:23:33,429
something is broken we may lose one

00:23:30,159 --> 00:23:36,969
payment in 10,000 say something is

00:23:33,429 --> 00:23:39,699
broken and then you let it run for a

00:23:36,969 --> 00:23:41,349
while and you lose more payments and

00:23:39,699 --> 00:23:44,559
then it gets really painful to fix the

00:23:41,349 --> 00:23:48,429
data the kind of the data is already in

00:23:44,559 --> 00:23:50,709
the accounting of the company and you

00:23:48,429 --> 00:23:52,539
need to somehow then v past date which

00:23:50,709 --> 00:23:55,079
is something you really don't want to

00:23:52,539 --> 00:23:57,699
change the account statement of your

00:23:55,079 --> 00:24:01,419
bank account or the payment account if

00:23:57,699 --> 00:24:07,059
you need to do that it's going to cost

00:24:01,419 --> 00:24:08,829
you a lot in customer trust for

00:24:07,059 --> 00:24:11,319
monitoring we are also using data doc so

00:24:08,829 --> 00:24:15,249
on the infrastructure that works really

00:24:11,319 --> 00:24:18,609
well for us so we get and sentry also so

00:24:15,249 --> 00:24:19,960
we get a bit nice alerts when we have

00:24:18,609 --> 00:24:21,850
these error cases

00:24:19,960 --> 00:24:25,149
usually you actually want to check this

00:24:21,850 --> 00:24:27,039
error rate instead of individual errors

00:24:25,149 --> 00:24:30,940
when you have a bit more volume because

00:24:27,039 --> 00:24:33,340
it's it's kind of assumed that some of

00:24:30,940 --> 00:24:36,690
the cases are going to fail once and

00:24:33,340 --> 00:24:36,690
then you retry and then they go through

00:24:39,929 --> 00:24:44,460
okay that was pretty much it

00:24:44,639 --> 00:24:49,990
one thing I could say a bit more about

00:24:47,139 --> 00:24:51,999
is this sophistication so what I said in

00:24:49,990 --> 00:24:54,820
the start of the slide is that when you

00:24:51,999 --> 00:24:57,190
have a small system you don't need to

00:24:54,820 --> 00:24:59,919
have this reliability yet built in but

00:24:57,190 --> 00:25:02,080
if you aim to scale or if you are now

00:24:59,919 --> 00:25:04,419
scaling you will face this problem at

00:25:02,080 --> 00:25:07,059
some point if you have these messages if

00:25:04,419 --> 00:25:08,769
you're working with money you can't lose

00:25:07,059 --> 00:25:14,740
if you are working with messages you can

00:25:08,769 --> 00:25:17,289
lose so in that case I really would

00:25:14,740 --> 00:25:19,389
recommend that you use this this kind of

00:25:17,289 --> 00:25:24,820
setup where you have actual reliability

00:25:19,389 --> 00:25:26,889
on the messaging setup so that was it

00:25:24,820 --> 00:25:29,379
thank you I'd like to thank the

00:25:26,889 --> 00:25:31,860
organizers organizers this has been a

00:25:29,379 --> 00:25:35,860
really nice example of how to set up

00:25:31,860 --> 00:25:38,409
kind of inclusive professional well

00:25:35,860 --> 00:25:41,519
organized event while still keeping it

00:25:38,409 --> 00:25:41,519
relaxed thank you very much

00:25:46,890 --> 00:26:02,410
thank you and see we got some time for

00:25:50,440 --> 00:26:05,410
questions before we go into lunch so

00:26:02,410 --> 00:26:06,940
about the inbox outbox model can you

00:26:05,410 --> 00:26:09,750
talk a little bit about that in the

00:26:06,940 --> 00:26:12,460
sense of um are there are two completely

00:26:09,750 --> 00:26:15,430
database clusters also are the system

00:26:12,460 --> 00:26:17,170
separated for security reasons because

00:26:15,430 --> 00:26:19,630
you could as well just have two inbox

00:26:17,170 --> 00:26:20,860
and outbox model in one database or even

00:26:19,630 --> 00:26:23,890
in the same table to do the

00:26:20,860 --> 00:26:25,300
reconciliation oh if you have these two

00:26:23,890 --> 00:26:28,440
different systems of course then you

00:26:25,300 --> 00:26:31,480
have need to have them in two different

00:26:28,440 --> 00:26:35,500
databases also if you are using two

00:26:31,480 --> 00:26:36,940
different databases all right we are

00:26:35,500 --> 00:26:39,640
actually doing we have kind of a large

00:26:36,940 --> 00:26:41,830
Manolis code base right now but we are

00:26:39,640 --> 00:26:45,460
doing messaging from the same codebase

00:26:41,830 --> 00:26:48,690
back to the same codebase so even in

00:26:45,460 --> 00:26:51,640
that setup it could have this inbox

00:26:48,690 --> 00:26:53,950
different model outbox different model

00:26:51,640 --> 00:26:56,020
where you can the outbox record

00:26:53,950 --> 00:26:59,500
different data so in the outbox you

00:26:56,020 --> 00:27:02,110
record that okay the inbox message ID

00:26:59,500 --> 00:27:06,820
was this I received it at this time this

00:27:02,110 --> 00:27:09,880
time the inbox original inbox creatin

00:27:06,820 --> 00:27:11,530
was this in the outbox you record

00:27:09,880 --> 00:27:14,500
basically just the data and when you

00:27:11,530 --> 00:27:16,210
sent it when you created it so then you

00:27:14,500 --> 00:27:18,130
can reconnect on to create time of the

00:27:16,210 --> 00:27:22,270
outbox and in works and even if you are

00:27:18,130 --> 00:27:25,030
using it inside one one system one code

00:27:22,270 --> 00:27:30,490
base I'll go for two different database

00:27:25,030 --> 00:27:32,590
models just for the reason of if you

00:27:30,490 --> 00:27:34,990
want that somewhat split it up then it's

00:27:32,590 --> 00:27:35,590
easy to do also when you are a small

00:27:34,990 --> 00:27:38,470
company

00:27:35,590 --> 00:27:41,500
Agro not not go for micro systems but

00:27:38,470 --> 00:27:44,080
have one large code base but have these

00:27:41,500 --> 00:27:47,560
messaging approaches even if you are

00:27:44,080 --> 00:27:49,660
using a bigger bigger codebase so that's

00:27:47,560 --> 00:27:52,020
when you scale you can split it up if

00:27:49,660 --> 00:28:00,420
you need to

00:27:52,020 --> 00:28:05,550
do we have more questions s12 the

00:28:00,420 --> 00:28:07,860
microphone hey I was wondering whether

00:28:05,550 --> 00:28:09,929
you considered instead of this inbox and

00:28:07,860 --> 00:28:12,830
outbox model to use only append only

00:28:09,929 --> 00:28:15,480
data structures and keeping pointers and

00:28:12,830 --> 00:28:17,220
basically following following the logs

00:28:15,480 --> 00:28:19,920
from one and copying to the other one I

00:28:17,220 --> 00:28:21,929
mean I'm asking this this because I'm

00:28:19,920 --> 00:28:23,940
involved with a project we do 100

00:28:21,929 --> 00:28:27,090
million messages per day and it's not

00:28:23,940 --> 00:28:29,520
okay to lose a single one and it's not

00:28:27,090 --> 00:28:31,740
really hard to do if you emulate the

00:28:29,520 --> 00:28:35,040
patterns of how Kafka does it internally

00:28:31,740 --> 00:28:37,350
also in in your own databases you could

00:28:35,040 --> 00:28:39,120
depending on the case you could you

00:28:37,350 --> 00:28:42,420
could use Kafka direct this also instead

00:28:39,120 --> 00:28:44,190
of recording anything in the database

00:28:42,420 --> 00:28:46,350
you first record the message and then

00:28:44,190 --> 00:28:49,080
you process it in the database so you go

00:28:46,350 --> 00:28:54,390
kind of moving from kavkaza transport

00:28:49,080 --> 00:28:56,309
for messages you move for Kafka as the

00:28:54,390 --> 00:28:58,679
data stories of the messages so that's

00:28:56,309 --> 00:29:01,110
one way then you use Kafka for these are

00:28:58,679 --> 00:29:05,480
pointers and stuff like that you could

00:29:01,110 --> 00:29:08,370
also do that into the database I'm I

00:29:05,480 --> 00:29:11,250
haven't considered how to do that so not

00:29:08,370 --> 00:29:13,679
sure how it would work the audio over

00:29:11,250 --> 00:29:15,450
here is that you would use the outbox

00:29:13,679 --> 00:29:17,040
model and send it to Kafka so if you

00:29:15,450 --> 00:29:18,990
want this hundred hundred million

00:29:17,040 --> 00:29:22,380
messages per day so you get it

00:29:18,990 --> 00:29:24,030
reliability reliably to Kafka and then

00:29:22,380 --> 00:29:26,010
you can use Kafka for the kind of having

00:29:24,030 --> 00:29:29,220
two pointers on doing to replace and

00:29:26,010 --> 00:29:31,140
stuff like that my question was because

00:29:29,220 --> 00:29:34,020
the outbox introduces the mutable

00:29:31,140 --> 00:29:36,690
intermediate storage it introduces also

00:29:34,020 --> 00:29:39,900
the chance to lose the message oh it

00:29:36,690 --> 00:29:42,720
happened only the outbox so or well you

00:29:39,900 --> 00:29:45,420
will delete it after 30 days so you just

00:29:42,720 --> 00:29:47,370
insert new messages over there and the

00:29:45,420 --> 00:29:49,230
only update you do is that okay now this

00:29:47,370 --> 00:29:51,950
has been pushed to somewhere but that's

00:29:49,230 --> 00:29:51,950
the only update

00:29:53,100 --> 00:30:00,509
okay other no questions going once going

00:29:59,740 --> 00:30:02,580
twice

00:30:00,509 --> 00:30:06,200
Thank You antsy thank you

00:30:02,580 --> 00:30:06,200

YouTube URL: https://www.youtube.com/watch?v=PEo7I8N8zlU


