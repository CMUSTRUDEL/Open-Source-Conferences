Title: DjangoCon 2018 - Making smarter queries with advanced ORM resources
Publication date: 2018-05-23
Playlist: DjangoCon Europe 2018 in Heidelberg
Description: 
	https://media.ccc.de/v/hd-127-making-smarter-queries-with-advanced-orm-resources



Django ORM has lots of resources for making complex database queries and the documentation brings good examples on how to apply each one of them, but understanding how to orchestrate all of those resources on real-life projects may not be so simple. My goal with this talk is to show through examples how to combine some of the QuerySet Methods, Query Expressions and other optimization techniques to make the most of DB resources when processing information inside the code is not an option.

When we start modelling an application, we don’t always know how it’s models will evolve and it may be even more difficult to foresee their behaviour when big amounts of data are stored in their respective tables. With tables getting bigger through the project’s life apparently harmless operations may become impossible to make. Thankfully, databases are already prepared for dealing with large amounts of data and resource consuming operations and Django’s ORM provides solutions for most of them.

For this talk I’m going to build an example Django project, populate it’s tables with big enough datasets and formulate complex questions to demand the most on the ORM’s possibilities. For each question I’m writing at least one solution using the resources described in the QueryExpressions section of Django’s Docs to then analyse the SQL generated by it and the pros and cons between operational costs and code complexity.

The following topics will be covered:
    - Using F() expressions for filtering, ordering and annotate operations
    - Using Max, Min, Avg with annotations
    - Compare Subquery expressions to queryset equivalents
    - Present the new Window functions for partitioned operations
    - Using Union queries

Mariana Bedran Lesche
Captions: 
	00:00:06,689 --> 00:00:13,799
hi I'm Mariana I work at lab coats

00:00:11,980 --> 00:00:16,740
officer

00:00:13,799 --> 00:00:21,210
Recife those are the great people that

00:00:16,740 --> 00:00:25,669
work with me as I have a pretty

00:00:21,210 --> 00:00:30,349
different name that's my nickname

00:00:25,669 --> 00:00:35,969
everywhere so anywhere you gonna find me

00:00:30,349 --> 00:00:40,890
my children so I'm from Brazil I'm come

00:00:35,969 --> 00:00:42,750
from this town right there in Italy near

00:00:40,890 --> 00:00:45,020
here Janeiro they say the best thing

00:00:42,750 --> 00:00:49,100
about Notaro is the view from Rio and

00:00:45,020 --> 00:00:49,100
well it's probably too good

00:01:22,100 --> 00:01:28,640
good yeah I think I got all the

00:01:25,970 --> 00:01:33,410
technical problems from the conference

00:01:28,640 --> 00:01:35,210
so if the speakers can be okay they

00:01:33,410 --> 00:01:38,119
nothing gonna happen to you

00:01:35,210 --> 00:01:41,570
so well then I'm come from the thyroid

00:01:38,119 --> 00:01:45,290
that little city round there in Rio I

00:01:41,570 --> 00:01:48,200
recently moved to Recife that's up there

00:01:45,290 --> 00:01:51,170
North both there are very beautiful

00:01:48,200 --> 00:01:55,720
places if you ever come to Brazil come

00:01:51,170 --> 00:02:02,200
visit us lots of beaches and warm and

00:01:55,720 --> 00:02:08,690
music great places so then that's me and

00:02:02,200 --> 00:02:11,120
let's talk about why I came here so you

00:02:08,690 --> 00:02:16,840
know when you go to Django documentation

00:02:11,120 --> 00:02:20,870
and you go through the or am stuff and

00:02:16,840 --> 00:02:23,480
all of those pages you never get to well

00:02:20,870 --> 00:02:27,080
I used to look at them and say hmm never

00:02:23,480 --> 00:02:30,530
use those stuff let's make a talk to

00:02:27,080 --> 00:02:34,340
talk about them and learn them on the

00:02:30,530 --> 00:02:36,799
way that's my biggest motivation to be

00:02:34,340 --> 00:02:41,299
here I have a reason to learn of those

00:02:36,799 --> 00:02:44,180
things I didn't know about then yeah I

00:02:41,299 --> 00:02:46,610
just wanted to test all of those things

00:02:44,180 --> 00:02:54,950
I only saw on the documentation and

00:02:46,610 --> 00:03:00,110
never got to use so well I a while ago I

00:02:54,950 --> 00:03:04,280
worked at a in the owner PHP Pro project

00:03:00,110 --> 00:03:08,269
a legacy PHP project terrible but the

00:03:04,280 --> 00:03:11,630
good thing about it is that I as we had

00:03:08,269 --> 00:03:15,920
to just write raw sea Cove all the time

00:03:11,630 --> 00:03:22,730
I ended up learning some interesting

00:03:15,920 --> 00:03:26,900
sequel stuff and at some point I got to

00:03:22,730 --> 00:03:29,570
a place where I could implement some

00:03:26,900 --> 00:03:34,080
things in sepal directly that I had had

00:03:29,570 --> 00:03:37,620
no idea how to do in Django so

00:03:34,080 --> 00:03:40,740
I was I've been wondering for a long

00:03:37,620 --> 00:03:43,530
time well how do I get those things two

00:03:40,740 --> 00:03:47,010
things together how do i implement the

00:03:43,530 --> 00:03:50,520
things I already know in sequel with the

00:03:47,010 --> 00:03:54,810
ORM because well we're writing django

00:03:50,520 --> 00:04:00,830
software we want to use Django so could

00:03:54,810 --> 00:04:05,490
I put the two of them together and when

00:04:00,830 --> 00:04:09,990
would be the good situation to have that

00:04:05,490 --> 00:04:12,630
knowledge to use those things well you

00:04:09,990 --> 00:04:18,620
know in Django documentation has a whole

00:04:12,630 --> 00:04:24,480
section about improving your queries

00:04:18,620 --> 00:04:28,470
about optimization strategies so well

00:04:24,480 --> 00:04:32,550
you've already added indexes to your

00:04:28,470 --> 00:04:35,940
tables you have already passionated your

00:04:32,550 --> 00:04:39,919
requests you have added select related

00:04:35,940 --> 00:04:43,800
and prefetch related to your query sets

00:04:39,919 --> 00:04:48,750
you have tried using values values lists

00:04:43,800 --> 00:04:52,640
only differ on your presets as you might

00:04:48,750 --> 00:04:55,800
know all of those are methods that

00:04:52,640 --> 00:04:59,550
reduce the number of columns they we get

00:04:55,800 --> 00:05:04,050
from the database you have set up your

00:04:59,550 --> 00:05:08,190
database cache you can use assert known

00:05:04,050 --> 00:05:10,620
queries on your methods on your test to

00:05:08,190 --> 00:05:13,530
guarantee that you're not doing extra

00:05:10,620 --> 00:05:16,080
queries that you don't have to you have

00:05:13,530 --> 00:05:19,280
done all of that but still sometimes

00:05:16,080 --> 00:05:25,590
that's not enough and we still have to

00:05:19,280 --> 00:05:28,620
improve our database queries so how do

00:05:25,590 --> 00:05:35,550
we do that there are some interesting

00:05:28,620 --> 00:05:39,390
tricks that we could use so how did I

00:05:35,550 --> 00:05:43,620
choose to organize it choose a big data

00:05:39,390 --> 00:05:47,850
set because well I can't I could just

00:05:43,620 --> 00:05:50,930
try to implement code on fake data

00:05:47,850 --> 00:05:54,300
but then I wouldn't get the real feel of

00:05:50,930 --> 00:05:58,830
knowing if what I was doing was actually

00:05:54,300 --> 00:06:04,050
working or it was just pretty cold so I

00:05:58,830 --> 00:06:07,290
wanted to have real data then I would

00:06:04,050 --> 00:06:10,410
come up with some interesting questions

00:06:07,290 --> 00:06:15,690
and try to answer that questions using

00:06:10,410 --> 00:06:22,350
those methods I never got to use not all

00:06:15,690 --> 00:06:26,160
of that came as I expected to so well

00:06:22,350 --> 00:06:29,520
but from the beginning I just took too

00:06:26,160 --> 00:06:34,790
long to start it that was my biggest

00:06:29,520 --> 00:06:40,110
problem and while dealing with real data

00:06:34,790 --> 00:06:43,020
means that you don't have the perfect

00:06:40,110 --> 00:06:46,620
data so if you the data wasn't created

00:06:43,020 --> 00:06:49,650
with Jango great chance that it's not

00:06:46,620 --> 00:06:52,050
gonna be perfect for your jungle madness

00:06:49,650 --> 00:06:56,610
so I had to validate data while

00:06:52,050 --> 00:07:03,380
importing it and my machine above as you

00:06:56,610 --> 00:07:08,520
can see it's not a very great one so I

00:07:03,380 --> 00:07:11,640
had to create an importing scripts that

00:07:08,520 --> 00:07:14,310
at the same time didn't kill my machine

00:07:11,640 --> 00:07:17,130
consuming all of its memory and I like

00:07:14,310 --> 00:07:20,100
it kill my machine hundreds of times I

00:07:17,130 --> 00:07:23,280
was just got used to rebooting it all

00:07:20,100 --> 00:07:26,400
the time and at the same time didn't

00:07:23,280 --> 00:07:30,120
take forever to import of the day I was

00:07:26,400 --> 00:07:33,330
already using booked create and it's

00:07:30,120 --> 00:07:36,750
still like I was creating a hundred

00:07:33,330 --> 00:07:40,620
thousand entries each time and it was

00:07:36,750 --> 00:07:45,840
still not enough to implement to import

00:07:40,620 --> 00:07:50,460
all of the descent so and then well

00:07:45,840 --> 00:07:53,610
after a header data turns out that

00:07:50,460 --> 00:07:56,580
putting all of these things together are

00:07:53,610 --> 00:07:59,400
not quite easy so when you look at the

00:07:56,580 --> 00:08:00,970
documentation everything looks pretty

00:07:59,400 --> 00:08:03,910
simple but

00:08:00,970 --> 00:08:07,390
when you try to put it together with Rio

00:08:03,910 --> 00:08:12,910
dieter then well things get a little bit

00:08:07,390 --> 00:08:15,550
scarier but in in the end I got some

00:08:12,910 --> 00:08:19,150
results I can want to show you so what's

00:08:15,550 --> 00:08:22,120
the data I'm gonna talk about open data

00:08:19,150 --> 00:08:25,000
from Brazil we have a law in Brazil that

00:08:22,120 --> 00:08:30,250
says that all public data must be

00:08:25,000 --> 00:08:35,830
available there's a information access

00:08:30,250 --> 00:08:40,750
bill but what's the problem with that in

00:08:35,830 --> 00:08:42,940
real life things don't work that well so

00:08:40,750 --> 00:08:47,050
the data is there it's not that

00:08:42,940 --> 00:08:50,830
accessible so not every government

00:08:47,050 --> 00:08:54,690
agency complies sometimes you people

00:08:50,830 --> 00:08:54,690
have to go to justice to get to data

00:08:54,720 --> 00:09:01,320
well each government agency has its own

00:08:58,060 --> 00:09:08,440
data so you have to like run around

00:09:01,320 --> 00:09:11,800
asking each one of them they not always

00:09:08,440 --> 00:09:16,390
in open formats so some of them provided

00:09:11,800 --> 00:09:19,270
data in PDFs or such things and the

00:09:16,390 --> 00:09:21,190
biggest problem is that while people

00:09:19,270 --> 00:09:24,790
that could benefit from from the data

00:09:21,190 --> 00:09:29,830
don't have the technical skills to to

00:09:24,790 --> 00:09:33,250
analyze it to get it then a friend of

00:09:29,830 --> 00:09:36,880
mine called avenue he has a great

00:09:33,250 --> 00:09:39,970
project brazil you to gather all this

00:09:36,880 --> 00:09:43,150
data and make it available clean it and

00:09:39,970 --> 00:09:46,240
so that people can go to a single source

00:09:43,150 --> 00:09:50,290
and get clean data so they can analyze

00:09:46,240 --> 00:09:53,380
it then well as i was preparing my talk

00:09:50,290 --> 00:09:55,810
I asked however well do you have any

00:09:53,380 --> 00:09:59,290
interesting data for me so I could like

00:09:55,810 --> 00:10:02,680
use on my talk he provide me with some

00:09:59,290 --> 00:10:07,990
nice data data sets I choose some of

00:10:02,680 --> 00:10:11,700
them and like why not prepare a talk and

00:10:07,990 --> 00:10:13,640
then in the end come up with a nice

00:10:11,700 --> 00:10:16,070
database that

00:10:13,640 --> 00:10:19,490
could be used somewhere else to like

00:10:16,070 --> 00:10:24,730
give something interesting to other

00:10:19,490 --> 00:10:27,950
people then while I chose two datasets

00:10:24,730 --> 00:10:31,220
one of them is from all the partners

00:10:27,950 --> 00:10:36,260
from companies in Brazil

00:10:31,220 --> 00:10:39,880
it contains basically the CN PG that's

00:10:36,260 --> 00:10:43,580
unique in the identifier for companies

00:10:39,880 --> 00:10:46,280
the partners name the category of the

00:10:43,580 --> 00:10:50,170
partners if it's a legal entity if it's

00:10:46,280 --> 00:10:52,580
a natural person or it's a foreigner the

00:10:50,170 --> 00:10:58,340
partnership category there are many of

00:10:52,580 --> 00:11:02,540
them and the partners cnpj it means if

00:10:58,340 --> 00:11:05,210
the partner is a company then I we have

00:11:02,540 --> 00:11:08,270
the number it doesn't find a company

00:11:05,210 --> 00:11:12,710
that owns that other company that's one

00:11:08,270 --> 00:11:18,070
dataset and it became those stables so I

00:11:12,710 --> 00:11:22,550
have a partnership table that relates

00:11:18,070 --> 00:11:25,640
companies to their partners so the

00:11:22,550 --> 00:11:28,250
company can have a foreign partner a

00:11:25,640 --> 00:11:31,430
natural personal partner or another

00:11:28,250 --> 00:11:38,420
company as a partner and they all belong

00:11:31,430 --> 00:11:44,480
to States then another data set is the

00:11:38,420 --> 00:11:47,330
Chamber of Deputies expenses so we have

00:11:44,480 --> 00:11:50,300
National Congress each deputy has the

00:11:47,330 --> 00:11:54,530
right to spend a certain amount of money

00:11:50,300 --> 00:11:58,670
on their activities and the data set

00:11:54,530 --> 00:12:00,500
describes how they spent that money so I

00:11:58,670 --> 00:12:05,710
have a unique identifiers for the

00:12:00,500 --> 00:12:08,360
deputies the party his name the date the

00:12:05,710 --> 00:12:11,870
reference for the month and year the

00:12:08,360 --> 00:12:14,630
amount description and the company they

00:12:11,870 --> 00:12:20,390
spent the money on and some other fields

00:12:14,630 --> 00:12:23,240
okay and those become my tables oh I can

00:12:20,390 --> 00:12:27,379
I have an expense it's related to a

00:12:23,240 --> 00:12:29,749
deputy the deputy is related to a party

00:12:27,379 --> 00:12:34,220
and the state and the expense can be

00:12:29,749 --> 00:12:38,269
related to a company that can buy it

00:12:34,220 --> 00:12:40,729
strong be related to a state to good and

00:12:38,269 --> 00:12:46,309
then let's go to the interesting part

00:12:40,729 --> 00:12:48,939
the queries first thing I want to talk

00:12:46,309 --> 00:12:51,739
about this prefecture but I just

00:12:48,939 --> 00:12:53,329
discovered it like two months ago and it

00:12:51,739 --> 00:12:59,769
like changed my life

00:12:53,329 --> 00:13:03,079
I've been using them at work for

00:12:59,769 --> 00:13:06,529
retrieving related objects given a

00:13:03,079 --> 00:13:09,109
certain context I'm specifically using

00:13:06,529 --> 00:13:11,599
that on a project right now where we

00:13:09,109 --> 00:13:15,319
have like a small system for us to

00:13:11,599 --> 00:13:17,539
control the finances of the company so

00:13:15,319 --> 00:13:21,439
that Fernando can pay the other partners

00:13:17,539 --> 00:13:25,519
their salaries so when we retrieve the

00:13:21,439 --> 00:13:29,449
data from a user we want all the related

00:13:25,519 --> 00:13:32,720
data from that user so how much time he

00:13:29,449 --> 00:13:35,659
worked on that month the expenses he had

00:13:32,720 --> 00:13:40,189
on that month the days he didn't work

00:13:35,659 --> 00:13:43,369
etc so we have an API

00:13:40,189 --> 00:13:47,179
I get the users information from the API

00:13:43,369 --> 00:13:49,939
and all the related data well but when I

00:13:47,179 --> 00:13:53,299
get all the related data from a user I

00:13:49,939 --> 00:13:56,239
don't want the data from last year that

00:13:53,299 --> 00:14:00,639
doesn't interest me so I have an app

00:13:56,239 --> 00:14:03,739
that calculates the salary for a month

00:14:00,639 --> 00:14:07,039
so I only the only thing that interests

00:14:03,739 --> 00:14:12,379
me is the data in the context of that

00:14:07,039 --> 00:14:16,489
specific month so the best way I found

00:14:12,379 --> 00:14:18,799
out here now to get those related data

00:14:16,489 --> 00:14:23,029
in a context is with the prefetch

00:14:18,799 --> 00:14:25,549
objects and so in our case here with the

00:14:23,029 --> 00:14:28,729
data I presented to you how we do that

00:14:25,549 --> 00:14:31,729
imagine we have a serialized pretty

00:14:28,729 --> 00:14:35,389
simple model serialize er I want to

00:14:31,729 --> 00:14:40,069
describe the deputy all his fields with

00:14:35,389 --> 00:14:40,769
the depth of two that means I go one two

00:14:40,069 --> 00:14:44,670
laugh

00:14:40,769 --> 00:14:46,860
of relations from that model okay so

00:14:44,670 --> 00:14:51,689
then I create a list view to list all my

00:14:46,860 --> 00:14:55,589
deputies what would we do normally on a

00:14:51,689 --> 00:14:59,850
preset I get a select related to get all

00:14:55,589 --> 00:15:04,519
the party to which this deputy belongs

00:14:59,850 --> 00:15:08,399
to the state where he was elected from

00:15:04,519 --> 00:15:14,629
with a select related so then this year

00:15:08,399 --> 00:15:17,970
like related will create joins with on

00:15:14,629 --> 00:15:20,879
statement on the database and then the

00:15:17,970 --> 00:15:24,199
prefetch related will create another

00:15:20,879 --> 00:15:30,480
query that will get all the expenses

00:15:24,199 --> 00:15:35,220
filtered by the deputies IDs okay that's

00:15:30,480 --> 00:15:37,559
what you need to show related models but

00:15:35,220 --> 00:15:41,369
then I would get all the deputies and

00:15:37,559 --> 00:15:44,519
all the expenses from my database and it

00:15:41,369 --> 00:15:48,660
would be a huge query I don't want all

00:15:44,519 --> 00:15:53,730
the data so how would I do to get all

00:15:48,660 --> 00:15:58,459
only the data specific to a context so

00:15:53,730 --> 00:16:01,529
I'm gonna refactor my view too well

00:15:58,459 --> 00:16:04,920
first I'm gonna set a month and a year

00:16:01,529 --> 00:16:09,929
as a default parameter so you're only

00:16:04,920 --> 00:16:18,769
allowed to get data from a year from a

00:16:09,929 --> 00:16:23,639
month okay then I get first my deputies

00:16:18,769 --> 00:16:28,019
preset so I get all my deputies on and

00:16:23,639 --> 00:16:31,860
all the parties and and states related

00:16:28,019 --> 00:16:37,470
to it I set the default month and year

00:16:31,860 --> 00:16:41,600
and then what I do is there's a less

00:16:37,470 --> 00:16:45,869
line missing there I think it's okay so

00:16:41,600 --> 00:16:48,059
I'm gonna get all of the query

00:16:45,869 --> 00:16:51,990
parameters that the user pass it to me

00:16:48,059 --> 00:16:55,370
and pass to that to that medic called

00:16:51,990 --> 00:16:58,640
prefetch expenses

00:16:55,370 --> 00:17:02,420
I'm gonna like you should never do that

00:16:58,640 --> 00:17:04,730
in real life don't get the credit

00:17:02,420 --> 00:17:07,130
pyramids from your user and just put

00:17:04,730 --> 00:17:09,770
them in on your model that's just for

00:17:07,130 --> 00:17:11,660
example you you would normally use

00:17:09,770 --> 00:17:15,199
Django filter or something like that I

00:17:11,660 --> 00:17:18,380
just created that method here to show

00:17:15,199 --> 00:17:21,320
how it would work so I get all those

00:17:18,380 --> 00:17:25,220
filters pass them directly to him to my

00:17:21,320 --> 00:17:31,930
crew set and that's when I prefetch the

00:17:25,220 --> 00:17:34,430
data so yeah it's a little bit

00:17:31,930 --> 00:17:40,400
unfermented here but it's okay

00:17:34,430 --> 00:17:42,940
well the prefetch object creates a

00:17:40,400 --> 00:17:45,580
prefetch for me so instead of

00:17:42,940 --> 00:17:49,130
prefetching by the related name I

00:17:45,580 --> 00:17:54,350
prefetch with a prefetch obrecht object

00:17:49,130 --> 00:18:01,100
and I pass a query for that professor

00:17:54,350 --> 00:18:06,530
inject so I will filter all the expenses

00:18:01,100 --> 00:18:12,380
by the pet parameters I got and after

00:18:06,530 --> 00:18:14,000
this the expenses are futures I bet I

00:18:12,380 --> 00:18:20,120
pass them as a prefect

00:18:14,000 --> 00:18:23,270
that means when my user types in that he

00:18:20,120 --> 00:18:26,960
wants all the deputies and he wants all

00:18:23,270 --> 00:18:31,570
the deputies with his their expenses on

00:18:26,960 --> 00:18:37,310
the month third on the third month of

00:18:31,570 --> 00:18:42,800
2018 and they wanted the expenses that

00:18:37,310 --> 00:18:45,860
was that are bigger than 100 instead of

00:18:42,800 --> 00:18:49,460
each deputy with all the expenses from

00:18:45,860 --> 00:18:54,980
four years ago I only get the expenses

00:18:49,460 --> 00:19:00,200
that match that exact parameter so it

00:18:54,980 --> 00:19:04,450
creates a single query I only fetch the

00:19:00,200 --> 00:19:04,450
data I have I never had to once

00:19:04,480 --> 00:19:11,409
make a loop over the data

00:19:09,039 --> 00:19:13,480
I just retrieved them directly from the

00:19:11,409 --> 00:19:19,570
database exactly the way I want them to

00:19:13,480 --> 00:19:24,970
be so that's the first use useful thing

00:19:19,570 --> 00:19:29,649
I've discovered recently then second

00:19:24,970 --> 00:19:33,960
thing and was very funny to do we can

00:19:29,649 --> 00:19:42,179
filter aggregates didn't know that like

00:19:33,960 --> 00:19:46,029
before I was planning a talk so you know

00:19:42,179 --> 00:19:50,350
Django aggregate functions we can sum we

00:19:46,029 --> 00:19:52,869
can average we have max Brian's standard

00:19:50,350 --> 00:19:56,710
deviation we have lots of aggregate

00:19:52,869 --> 00:20:02,830
functions but we can also aggregate on

00:19:56,710 --> 00:20:07,149
filtered things so I'm gonna annotate

00:20:02,830 --> 00:20:14,379
all of my deputies and I wanna field on

00:20:07,149 --> 00:20:18,779
my deputy object that says which was how

00:20:14,379 --> 00:20:25,659
much did he spend on a month and a year

00:20:18,779 --> 00:20:28,119
so have you used f f strings love of

00:20:25,659 --> 00:20:32,919
strings I'm like using them everywhere

00:20:28,119 --> 00:20:36,009
love them just beautiful so I'm gonna

00:20:32,919 --> 00:20:41,139
annotate my deputy with the field with

00:20:36,009 --> 00:20:44,080
the expenses of a particular month how

00:20:41,139 --> 00:20:46,119
am I gonna do that I'm gonna use the sum

00:20:44,080 --> 00:20:49,679
that's the aggregate expression

00:20:46,119 --> 00:20:53,739
everybody knows and I can then feel

00:20:49,679 --> 00:20:59,230
future that some so instead of summing

00:20:53,739 --> 00:21:01,960
up all the values already know instead

00:20:59,230 --> 00:21:04,509
of summing the values of all of the

00:21:01,960 --> 00:21:08,470
expenses I'm gonna just sum the ones

00:21:04,509 --> 00:21:13,720
that match my future so I get the sum of

00:21:08,470 --> 00:21:15,910
a specific field and when you look at

00:21:13,720 --> 00:21:19,180
the query they make

00:21:15,910 --> 00:21:24,610
they make a future on that some

00:21:19,180 --> 00:21:25,500
expression with a join on the expenses

00:21:24,610 --> 00:21:28,900
okay

00:21:25,500 --> 00:21:33,550
well but there's also the filtered

00:21:28,900 --> 00:21:37,750
relations they can do the same thing not

00:21:33,550 --> 00:21:40,630
that beautiful but they did almost the

00:21:37,750 --> 00:21:42,940
same thing I can get a filtered relation

00:21:40,630 --> 00:21:47,490
it's the same thing I'm gonna get my

00:21:42,940 --> 00:21:51,220
deputies I'm gonna filter the expenses

00:21:47,490 --> 00:21:54,060
use the same condition as you see the

00:21:51,220 --> 00:21:58,450
condition is basically the same one

00:21:54,060 --> 00:22:01,000
filter them by month in year I'm gonna

00:21:58,450 --> 00:22:05,020
then create a first annotation of that

00:22:01,000 --> 00:22:08,470
that says all the expenses that were

00:22:05,020 --> 00:22:11,650
made in that month year and then I'm

00:22:08,470 --> 00:22:15,780
gonna do a second annotate that's gonna

00:22:11,650 --> 00:22:19,450
sum up all of them okay

00:22:15,780 --> 00:22:23,110
they both do the same things when well

00:22:19,450 --> 00:22:25,900
if you look at the query they make the

00:22:23,110 --> 00:22:29,860
conditions of month and year instead of

00:22:25,900 --> 00:22:34,800
appearing on a future like here they

00:22:29,860 --> 00:22:38,490
appear inside that where statement and

00:22:34,800 --> 00:22:43,000
here they appear inside the on condition

00:22:38,490 --> 00:22:46,450
what's the different performance that's

00:22:43,000 --> 00:22:49,810
the first query I don't really

00:22:46,450 --> 00:22:51,880
understand all the things they do around

00:22:49,810 --> 00:22:55,750
there but the main thing is the number

00:22:51,880 --> 00:22:58,900
up here it shows how efficient the

00:22:55,750 --> 00:23:02,320
queries that's the first one and that's

00:22:58,900 --> 00:23:06,000
the second one it's incredibly faster

00:23:02,320 --> 00:23:13,720
like they do basically the same thing

00:23:06,000 --> 00:23:16,090
instead of filtering here and here but

00:23:13,720 --> 00:23:18,490
the fact that the filter is on an

00:23:16,090 --> 00:23:21,640
unconditioned makes it huge difference

00:23:18,490 --> 00:23:26,340
so the code is not that beautiful like

00:23:21,640 --> 00:23:30,610
when you look at it it's like

00:23:26,340 --> 00:23:33,580
bigger and has a strange thing in the

00:23:30,610 --> 00:23:41,040
middle but makes a big difference in

00:23:33,580 --> 00:23:45,970
real life and you can also aggregate

00:23:41,040 --> 00:23:50,520
annotations that's also great so I did

00:23:45,970 --> 00:23:56,280
the same annotation as before but with a

00:23:50,520 --> 00:24:01,120
bit with but for all the months from

00:23:56,280 --> 00:24:05,679
2009 to 2010 gonna do the same

00:24:01,120 --> 00:24:09,240
annotation so I'm gonna have a Spence

00:24:05,679 --> 00:24:12,929
for month annotated for each deputy and

00:24:09,240 --> 00:24:16,570
then I can aggregate those annotations

00:24:12,929 --> 00:24:19,540
so each deputy will have a field that

00:24:16,570 --> 00:24:26,920
says how much he spent on a specific

00:24:19,540 --> 00:24:27,850
month and then I can do the average of

00:24:26,920 --> 00:24:34,630
that son

00:24:27,850 --> 00:24:39,610
so the that field that says gosh twos

00:24:34,630 --> 00:24:43,059
year month will be aggregated so each

00:24:39,610 --> 00:24:48,340
deputy will have an attribute for each

00:24:43,059 --> 00:24:51,400
month in the last lots of months and I'm

00:24:48,340 --> 00:24:55,200
gonna calculate the average for each one

00:24:51,400 --> 00:24:58,450
of those we end up with a huge

00:24:55,200 --> 00:25:02,800
dictionary and we could also use those

00:24:58,450 --> 00:25:06,640
to build rafts by plot is beautiful

00:25:02,800 --> 00:25:09,880
don't know what we would I use that that

00:25:06,640 --> 00:25:13,179
thing for but if someone's interested in

00:25:09,880 --> 00:25:17,040
how they've arrived at their expenses

00:25:13,179 --> 00:25:22,650
like with 2/3 patent methods I got this

00:25:17,040 --> 00:25:26,440
beautiful plot okay and the nicest thing

00:25:22,650 --> 00:25:28,960
sub-queries I've always wondered how to

00:25:26,440 --> 00:25:35,380
do that in Django and now we can do from

00:25:28,960 --> 00:25:38,410
two versions so I wanna know which

00:25:35,380 --> 00:25:42,040
deputies have companies

00:25:38,410 --> 00:25:44,680
we cannot do know that for sure because

00:25:42,040 --> 00:25:47,950
I don't have any unique identifiers for

00:25:44,680 --> 00:25:51,370
people the only way to identify them is

00:25:47,950 --> 00:25:54,160
by the name so that's not very accurate

00:25:51,370 --> 00:25:59,020
they well there can be people with the

00:25:54,160 --> 00:26:02,380
same names but anyway I'm gonna I wanted

00:25:59,020 --> 00:26:07,300
to like at least know which deputies

00:26:02,380 --> 00:26:16,000
have could have companies in their names

00:26:07,300 --> 00:26:19,870
so I make a query on the companies and I

00:26:16,000 --> 00:26:24,460
wanna know which companies have

00:26:19,870 --> 00:26:28,900
partnerships that belongs to natural

00:26:24,460 --> 00:26:32,470
pose people and I want to know the name

00:26:28,900 --> 00:26:36,640
of the people that owns these companies

00:26:32,470 --> 00:26:38,410
and I want to compare that name to

00:26:36,640 --> 00:26:42,370
something else what's that something

00:26:38,410 --> 00:26:45,850
else a reference to the query that's

00:26:42,370 --> 00:26:50,500
outside of it that's how we use the out

00:26:45,850 --> 00:26:54,040
ref so the documentation normally shows

00:26:50,500 --> 00:26:57,040
you how to use the out ref with primary

00:26:54,040 --> 00:26:59,200
keys but what's the fun in using primary

00:26:57,040 --> 00:27:03,550
keys we already have the relationships

00:26:59,200 --> 00:27:06,610
we can use reference to any keys so I

00:27:03,550 --> 00:27:10,690
use the reference to a name so I have

00:27:06,610 --> 00:27:12,970
companies the partnerships they have the

00:27:10,690 --> 00:27:15,340
name of their partners and I want to

00:27:12,970 --> 00:27:19,540
compare them with the names that appear

00:27:15,340 --> 00:27:22,210
in the query that's outside of it and I

00:27:19,540 --> 00:27:26,890
want to compare the state they're in so

00:27:22,210 --> 00:27:29,800
it's probably like as I don't have the

00:27:26,890 --> 00:27:33,970
any unique identifiers I know I want to

00:27:29,800 --> 00:27:35,950
know if they belong to the same state so

00:27:33,970 --> 00:27:39,040
I do the same thing with the stage I

00:27:35,950 --> 00:27:44,830
make reference to the query that's

00:27:39,040 --> 00:27:47,470
outside of it so they match and we can

00:27:44,830 --> 00:27:50,200
annotate that and I discovered I think I

00:27:47,470 --> 00:27:51,040
forgot to put here I discovered that one

00:27:50,200 --> 00:27:53,680
tenth

00:27:51,040 --> 00:27:59,560
after our deputies have probably

00:27:53,680 --> 00:28:03,430
companies on in their names and that's

00:27:59,560 --> 00:28:07,540
the period they make so it's basically

00:28:03,430 --> 00:28:13,180
select on the company's table with

00:28:07,540 --> 00:28:17,650
joints to the partnerships then we can

00:28:13,180 --> 00:28:24,910
reference the columns from the inner

00:28:17,650 --> 00:28:28,360
query and the outer query then I think

00:28:24,910 --> 00:28:29,910
yeah I think that's it I hope you get

00:28:28,360 --> 00:28:36,279
something from it

00:28:29,910 --> 00:28:36,279

YouTube URL: https://www.youtube.com/watch?v=eUM3b2q27pI


