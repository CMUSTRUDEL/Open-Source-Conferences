Title: DjangoCon 2019 - How (and why!) to build a Django based project with SQLAlchemy Core
Publication date: 2019-04-23
Playlist: DjangoCon Europe 2019 in Copenhagen
Description: 
	https://2019.djangocon.eu/talks/how-and-why-to-build-a-django-based-project-with-s/

By Gleb Pushkov
Captions: 
	00:00:01,310 --> 00:00:06,779
hello my name is Gleb I'm software

00:00:04,440 --> 00:00:08,429
developer from Ukraine Kiev or working

00:00:06,779 --> 00:00:10,740
with Python jungle more than six years

00:00:08,429 --> 00:00:15,030
currently employed at jungle stars and

00:00:10,740 --> 00:00:16,980
today I want to show to share with you

00:00:15,030 --> 00:00:19,710
actually a lot of information so I have

00:00:16,980 --> 00:00:21,539
to be really fast to fit on the time and

00:00:19,710 --> 00:00:23,760
I hope when you have some time for

00:00:21,539 --> 00:00:26,580
questions but I don't promise it and

00:00:23,760 --> 00:00:29,670
actually I want to start with motivation

00:00:26,580 --> 00:00:32,070
why should we actually need to mix

00:00:29,670 --> 00:00:34,290
jungle at sqlalchemy core which benefits

00:00:32,070 --> 00:00:36,930
we can get and in which cases it could

00:00:34,290 --> 00:00:40,860
be useful for us so actually the main

00:00:36,930 --> 00:00:43,230
use case is data analysis application so

00:00:40,860 --> 00:00:46,260
your application works mostly with

00:00:43,230 --> 00:00:48,719
aggregations so you don't work with

00:00:46,260 --> 00:00:53,129
all right single lines of table you

00:00:48,719 --> 00:00:56,550
don't have REST API or you don't modify

00:00:53,129 --> 00:00:58,289
single rows of your data so you only

00:00:56,550 --> 00:01:01,170
interested in aggregating some

00:00:58,289 --> 00:01:03,809
calculations so you likely will have a

00:01:01,170 --> 00:01:07,170
lot of data so you have two queries to

00:01:03,809 --> 00:01:09,299
be really performant and precise well

00:01:07,170 --> 00:01:11,580
maybe you could have some if you have

00:01:09,299 --> 00:01:14,159
some pattern of the pages you could

00:01:11,580 --> 00:01:17,070
build some wire which you generate such

00:01:14,159 --> 00:01:19,860
advanced queries for you so you maybe

00:01:17,070 --> 00:01:23,790
have such a wire and it's really easy to

00:01:19,860 --> 00:01:27,270
build it with SQL alchemy and maybe you

00:01:23,790 --> 00:01:29,460
also want to you design your queries in

00:01:27,270 --> 00:01:31,290
SQL in the console you check performance

00:01:29,460 --> 00:01:33,090
how it works then you satisfied and you

00:01:31,290 --> 00:01:36,350
want to move them to Python it's really

00:01:33,090 --> 00:01:39,030
easy to do it with SQL alchemy also and

00:01:36,350 --> 00:01:41,490
maybe your data source which you work

00:01:39,030 --> 00:01:43,920
with doesn't motive lis supported by

00:01:41,490 --> 00:01:46,259
Django and maybe sort party applications

00:01:43,920 --> 00:01:49,530
which provides support and integrations

00:01:46,259 --> 00:01:51,240
they are not fit units so this some the

00:01:49,530 --> 00:01:55,229
main use case when you

00:01:51,240 --> 00:01:57,180
Whiteley should check this tool so I

00:01:55,229 --> 00:01:58,799
really like jungle I really like jungle

00:01:57,180 --> 00:02:04,020
realm it's fantastic tool

00:01:58,799 --> 00:02:09,649
you even can forgot how to SQL but yeah

00:02:04,020 --> 00:02:12,440
it's greatly wolves it allows you to

00:02:09,649 --> 00:02:15,500
focus on the implementing of business

00:02:12,440 --> 00:02:18,530
teachers instead of doing some stuff so

00:02:15,500 --> 00:02:23,300
you really can deliver your features

00:02:18,530 --> 00:02:25,100
much faster and more reliable way and in

00:02:23,300 --> 00:02:28,790
what releases Django

00:02:25,100 --> 00:02:30,980
got a lot of cool features so like sub

00:02:28,790 --> 00:02:35,060
queries window functions so you already

00:02:30,980 --> 00:02:36,950
heard it yesterday from Siegert and so

00:02:35,060 --> 00:02:40,460
you have less reasons to switch to raw

00:02:36,950 --> 00:02:43,790
SQL but if we build the data analysis

00:02:40,460 --> 00:02:46,460
application Django Ram has its own

00:02:43,790 --> 00:02:49,160
specific so let's talk about this so for

00:02:46,460 --> 00:02:51,380
example if we want to we have properties

00:02:49,160 --> 00:02:54,230
and we have owners and we want to find

00:02:51,380 --> 00:02:56,330
for example five properties which in the

00:02:54,230 --> 00:02:58,760
city which start with the letter key and

00:02:56,330 --> 00:03:01,580
we want to get the user name of the

00:02:58,760 --> 00:03:06,140
owner so we do in select row edit which

00:03:01,580 --> 00:03:08,720
performs left outer join we can also

00:03:06,140 --> 00:03:11,390
limit amount of fields which we want so

00:03:08,720 --> 00:03:15,560
query is a bit simpler but in Python it

00:03:11,390 --> 00:03:17,180
OS readable so I want you to focus on

00:03:15,560 --> 00:03:20,870
these two lines so as you see we have

00:03:17,180 --> 00:03:25,730
left outer join and we have limit and if

00:03:20,870 --> 00:03:28,090
we see they explain how in which orders

00:03:25,730 --> 00:03:30,680
this operation performed we see that

00:03:28,090 --> 00:03:32,450
first of all we find the properties

00:03:30,680 --> 00:03:35,510
which we are interested in its huge

00:03:32,450 --> 00:03:38,120
amount of properties and only then we

00:03:35,510 --> 00:03:40,280
join to each of the rows the property we

00:03:38,120 --> 00:03:43,190
join owners and only only after that we

00:03:40,280 --> 00:03:45,080
do in a limit so this is not performance

00:03:43,190 --> 00:03:47,900
this is not the way that we want to

00:03:45,080 --> 00:03:51,110
execute the query likely we want to have

00:03:47,900 --> 00:03:53,090
a query like this so we have nested

00:03:51,110 --> 00:03:56,150
select it's like correlated sub-query

00:03:53,090 --> 00:04:00,019
and we select only fuels we interested

00:03:56,150 --> 00:04:03,890
in so we are doing limit there and then

00:04:00,019 --> 00:04:06,440
we join users to these five roles so

00:04:03,890 --> 00:04:09,830
it's very performant it's good believe

00:04:06,440 --> 00:04:12,350
me you have not to read it and with a

00:04:09,830 --> 00:04:14,900
scale alchemy core such query will we

00:04:12,350 --> 00:04:18,370
coexist and as you see on the first line

00:04:14,900 --> 00:04:21,500
we simply build this method select which

00:04:18,370 --> 00:04:23,930
do in a limit so this sub query and we

00:04:21,500 --> 00:04:25,160
simply insert it in other select and

00:04:23,930 --> 00:04:27,380
perform join

00:04:25,160 --> 00:04:29,780
so it's really straightforward and you

00:04:27,380 --> 00:04:32,090
can really fast understand what's going

00:04:29,780 --> 00:04:34,790
on on the knees I enjoy more Ramsey

00:04:32,090 --> 00:04:37,790
square we look like this that's why

00:04:34,790 --> 00:04:40,250
because all your query we should Butte

00:04:37,790 --> 00:04:42,950
it starts from model model like declare

00:04:40,250 --> 00:04:46,370
for you the from Klaus which will be

00:04:42,950 --> 00:04:49,100
used on the queries so the sub queries

00:04:46,370 --> 00:04:52,250
that we have they could be used on the

00:04:49,100 --> 00:04:54,500
select where heaven but we can't put it

00:04:52,250 --> 00:04:57,860
into the from so we can't make select

00:04:54,500 --> 00:05:02,000
from select so we of course can build a

00:04:57,860 --> 00:05:05,300
similar feature similar query we will

00:05:02,000 --> 00:05:07,190
can get a primary case of the properties

00:05:05,300 --> 00:05:11,240
which we interested in and put it into

00:05:07,190 --> 00:05:14,090
sub queries so it's also performant so

00:05:11,240 --> 00:05:16,100
it's okay but this example showed us

00:05:14,090 --> 00:05:17,900
that actually jeong chorim and SQL

00:05:16,100 --> 00:05:20,000
alchemy course they have all different

00:05:17,900 --> 00:05:23,690
wires and they design it to solve

00:05:20,000 --> 00:05:26,690
different needs of different problems so

00:05:23,690 --> 00:05:29,770
in Django stack we have under wine loan

00:05:26,690 --> 00:05:34,220
public API which is a query set query

00:05:29,770 --> 00:05:38,870
but documentation doesn't recommend to

00:05:34,220 --> 00:05:41,300
use it but in SQL alchemy core it's like

00:05:38,870 --> 00:05:43,970
on top of the SQL so it's very close to

00:05:41,300 --> 00:05:46,310
SQL and as you can see it's very

00:05:43,970 --> 00:05:49,460
readable it's really easy to understand

00:05:46,310 --> 00:05:52,430
and you can build your query easily on

00:05:49,460 --> 00:05:55,610
the other hand as you see jungle Ram

00:05:52,430 --> 00:05:58,130
sample the first filter it's actually

00:05:55,610 --> 00:06:01,580
the work was the values it would be a

00:05:58,130 --> 00:06:03,470
group by annotate would be a list of

00:06:01,580 --> 00:06:05,030
fields list of aggregations which you

00:06:03,470 --> 00:06:07,370
want to perform on the query and the

00:06:05,030 --> 00:06:09,140
last filter would be actually a Helen

00:06:07,370 --> 00:06:12,500
clause which will apply on the top of

00:06:09,140 --> 00:06:16,490
your query so it's not strength directly

00:06:12,500 --> 00:06:21,140
map up to the SQL level and when you

00:06:16,490 --> 00:06:23,000
building queries with on ORM such

00:06:21,140 --> 00:06:26,419
queries you really feel that you don't

00:06:23,000 --> 00:06:29,240
have the most freedom and I want to show

00:06:26,419 --> 00:06:32,090
one more example for for example we have

00:06:29,240 --> 00:06:33,919
two tables we have properties of owners

00:06:32,090 --> 00:06:36,050
and in properties table we have

00:06:33,919 --> 00:06:38,870
apartments and we have buildings so

00:06:36,050 --> 00:06:41,300
apartments place it in buildings and

00:06:38,870 --> 00:06:44,240
they have this building ideas so it's

00:06:41,300 --> 00:06:47,300
self relation to the table so let's

00:06:44,240 --> 00:06:50,810
start building our fancy query with SQL

00:06:47,300 --> 00:06:52,750
alchemy we doing simple select from the

00:06:50,810 --> 00:06:54,860
properties table we just select

00:06:52,750 --> 00:06:57,860
information which we want like building

00:06:54,860 --> 00:06:59,570
ID owner and sale price and we want to

00:06:57,860 --> 00:07:02,780
get the properties which are for sale

00:06:59,570 --> 00:07:06,950
and which has sale price so simple

00:07:02,780 --> 00:07:09,200
select then we can add more level where

00:07:06,950 --> 00:07:12,800
we do in select from the previous select

00:07:09,200 --> 00:07:16,280
so but here we want to replace the owner

00:07:12,800 --> 00:07:20,090
ID with user with username so we have to

00:07:16,280 --> 00:07:22,850
join users and we simply replace it then

00:07:20,090 --> 00:07:25,970
we decide that we need to go deeper and

00:07:22,850 --> 00:07:28,520
we add one more level so we built well

00:07:25,970 --> 00:07:31,010
on three in which so we have building

00:07:28,520 --> 00:07:33,260
IDs so we can group by our apartments

00:07:31,010 --> 00:07:35,210
and get the total price of the all

00:07:33,260 --> 00:07:39,020
apartments which are for sale in this

00:07:35,210 --> 00:07:43,580
building so we will group by we apply

00:07:39,020 --> 00:07:47,960
the functions that we need and it's very

00:07:43,580 --> 00:07:50,510
readable and on the last level we can we

00:07:47,960 --> 00:07:53,090
have only unique building ID so we can

00:07:50,510 --> 00:07:55,820
join building related information here

00:07:53,090 --> 00:07:59,900
so we have only roles which we want to

00:07:55,820 --> 00:08:03,620
to join so we can add like total

00:07:59,900 --> 00:08:08,630
apartment amount to the to the building

00:08:03,620 --> 00:08:11,030
so your query would be like this so it's

00:08:08,630 --> 00:08:14,210
select from select from select from

00:08:11,030 --> 00:08:17,360
select and on each level you doing like

00:08:14,210 --> 00:08:20,420
join group by again join so this is

00:08:17,360 --> 00:08:22,760
freedom I'm talking about so SQL alchemy

00:08:20,420 --> 00:08:26,420
allows you to build any type of such

00:08:22,760 --> 00:08:29,120
queries which is really cool another

00:08:26,420 --> 00:08:33,290
example about jungle limitations and

00:08:29,120 --> 00:08:36,890
readability imagine the case we also

00:08:33,290 --> 00:08:39,200
work with properties so we want to find

00:08:36,890 --> 00:08:41,150
the first price which is bigger than 1

00:08:39,200 --> 00:08:43,100
million and then we want to get all

00:08:41,150 --> 00:08:45,980
properties which has the same price

00:08:43,100 --> 00:08:51,290
which we just found so the query we want

00:08:45,980 --> 00:08:52,640
to build is like this so we put like

00:08:51,290 --> 00:08:55,160
Versailles price equal

00:08:52,640 --> 00:08:57,530
- and aggregation overall the table by

00:08:55,160 --> 00:09:00,380
our condition let's try to do it in

00:08:57,530 --> 00:09:03,260
general our first attempt would be to

00:09:00,380 --> 00:09:05,600
use aggregate but aggregate queries

00:09:03,260 --> 00:09:08,210
evaluated immediately so it will doesn't

00:09:05,600 --> 00:09:10,880
work for us because we have two queries

00:09:08,210 --> 00:09:14,060
to database two trips which is not

00:09:10,880 --> 00:09:17,900
performant so we want to use sub queries

00:09:14,060 --> 00:09:23,210
sub queries use we've worked with query

00:09:17,900 --> 00:09:27,080
sets and that's why we have to change

00:09:23,210 --> 00:09:29,990
our minimum aggregation MIMO to the such

00:09:27,080 --> 00:09:32,630
trick like order by ascending by price

00:09:29,990 --> 00:09:35,030
and get the first one so it will get the

00:09:32,630 --> 00:09:38,630
minimum price but as you see in our

00:09:35,030 --> 00:09:40,880
select we have also order by limit one

00:09:38,630 --> 00:09:43,640
and it's it's not readable and if you

00:09:40,880 --> 00:09:46,370
see order by or distinct account in your

00:09:43,640 --> 00:09:48,830
SQL query they are not performant and

00:09:46,370 --> 00:09:50,660
this is not the way that you want to

00:09:48,830 --> 00:09:54,170
build queries if you work with big

00:09:50,660 --> 00:09:56,180
amounts of data so we can leverage under

00:09:54,170 --> 00:09:59,960
a while non-public API which I mentioned

00:09:56,180 --> 00:10:01,970
earlier so as you see we have a query

00:09:59,960 --> 00:10:05,120
said dot query add annotations so we

00:10:01,970 --> 00:10:07,190
manually add this annotation which we

00:10:05,120 --> 00:10:09,530
want is summary says that it should be

00:10:07,190 --> 00:10:12,260
applied over the old table and we

00:10:09,530 --> 00:10:14,480
actually get the query which we want but

00:10:12,260 --> 00:10:17,120
yeah it's not recommended in the jungle

00:10:14,480 --> 00:10:18,230
documentation so it's up to up to you do

00:10:17,120 --> 00:10:21,770
we want to use it or not

00:10:18,230 --> 00:10:26,120
and one more way we can subscribers and

00:10:21,770 --> 00:10:30,950
we can overwrite template but yeah we

00:10:26,120 --> 00:10:34,120
also get the SQL which we want but this

00:10:30,950 --> 00:10:36,800
solution is too raw as for me

00:10:34,120 --> 00:10:38,590
so on the other hand with the skill

00:10:36,800 --> 00:10:41,090
alchemy this is pretty straightforward

00:10:38,590 --> 00:10:43,580
as you see on the first while we

00:10:41,090 --> 00:10:46,070
building also select and in the second

00:10:43,580 --> 00:10:48,380
one in the where we simply put this

00:10:46,070 --> 00:10:50,510
select into the condition and it will do

00:10:48,380 --> 00:10:53,510
all the magic and will you get the query

00:10:50,510 --> 00:10:56,900
which you want more limitations in John

00:10:53,510 --> 00:10:59,300
Gorham adjoins you can't join tables

00:10:56,900 --> 00:11:01,040
which are not related if they don't have

00:10:59,300 --> 00:11:05,030
relation you totally don't have ability

00:11:01,040 --> 00:11:06,040
to do joins you can't do right outer

00:11:05,030 --> 00:11:08,290
join

00:11:06,040 --> 00:11:11,500
but yeah it's very rare but sometimes it

00:11:08,290 --> 00:11:14,170
happens but I have to mention it also

00:11:11,500 --> 00:11:17,860
Django decides for you when to make

00:11:14,170 --> 00:11:20,770
inner or left outer join and you not you

00:11:17,860 --> 00:11:24,250
doesn't know what's happening Denis if

00:11:20,770 --> 00:11:26,860
you don't print query or you you can you

00:11:24,250 --> 00:11:29,760
can't change it from left outer to inner

00:11:26,860 --> 00:11:35,560
if you can if you want to simply cut out

00:11:29,760 --> 00:11:37,750
some Rose which has no values and Django

00:11:35,560 --> 00:11:40,750
also generates for you this join

00:11:37,750 --> 00:11:44,110
condition on condition and you can

00:11:40,750 --> 00:11:46,690
barely customize it you can't get rid of

00:11:44,110 --> 00:11:50,440
it you can't change this default you can

00:11:46,690 --> 00:11:54,310
only use future relation which will add

00:11:50,440 --> 00:11:57,520
end and that's actually all so you can

00:11:54,310 --> 00:12:02,910
provide or or some more explicit logic

00:11:57,520 --> 00:12:05,140
some some more complex logic to do join

00:12:02,910 --> 00:12:09,000
recursive column table expressions are

00:12:05,140 --> 00:12:11,440
also not supported by jungle yet it's

00:12:09,000 --> 00:12:14,620
useful when you work with the roles

00:12:11,440 --> 00:12:16,810
which has like parent ID and Zara it's

00:12:14,620 --> 00:12:19,120
point to another row which has parent ID

00:12:16,810 --> 00:12:21,430
another row or another row and you want

00:12:19,120 --> 00:12:24,210
to take all of them and make some

00:12:21,430 --> 00:12:26,860
aggregation or calculation over them so

00:12:24,210 --> 00:12:30,520
currently you can do it with raw SQL or

00:12:26,860 --> 00:12:32,950
SQL alchemy also it there is the library

00:12:30,520 --> 00:12:34,780
like django city forest but it has

00:12:32,950 --> 00:12:38,470
limitations and it improvement

00:12:34,780 --> 00:12:40,270
implemented via extra but extra would be

00:12:38,470 --> 00:12:43,270
duplicated so it's not recommended to

00:12:40,270 --> 00:12:47,730
use so this library is not not usable

00:12:43,270 --> 00:12:52,270
currently one more example about how

00:12:47,730 --> 00:12:54,460
django syntax is for file from SQL so

00:12:52,270 --> 00:12:56,530
it's actually from Django documentation

00:12:54,460 --> 00:12:59,130
I like it very much so as you see we

00:12:56,530 --> 00:13:02,950
have book we have outers we have store

00:12:59,130 --> 00:13:06,490
stores and if we do in this annotation

00:13:02,950 --> 00:13:09,760
in one wine so of aggregation of

00:13:06,490 --> 00:13:12,730
multiple tables so we get the wrong

00:13:09,760 --> 00:13:15,690
aggregation so in fact instead of sub

00:13:12,730 --> 00:13:18,860
queries it will be a joint so you simply

00:13:15,690 --> 00:13:20,840
multiple multiple I amount of roles and

00:13:18,860 --> 00:13:23,120
all your irrigation will produce wrong

00:13:20,840 --> 00:13:25,780
result account could be fixed it with

00:13:23,120 --> 00:13:30,350
distinct true so it will kick out all

00:13:25,780 --> 00:13:33,620
roles which are redundant but actually

00:13:30,350 --> 00:13:35,930
other grens which will produce the

00:13:33,620 --> 00:13:39,260
result which you don't actually want to

00:13:35,930 --> 00:13:41,630
get so this is if you not read the

00:13:39,260 --> 00:13:45,770
commutation precise and as you could

00:13:41,630 --> 00:13:47,150
fail in such issue so to sum up it's

00:13:45,770 --> 00:13:49,220
hard to read

00:13:47,150 --> 00:13:52,100
advance it queries in jungle it's hard

00:13:49,220 --> 00:13:56,480
to understand what's going on SQL level

00:13:52,100 --> 00:13:58,610
and yeah it's take time to convert query

00:13:56,480 --> 00:14:01,460
from SQL to Python if you design it it's

00:13:58,610 --> 00:14:04,280
somewhere and it's not so flexible so

00:14:01,460 --> 00:14:07,970
some parts you can't change or you have

00:14:04,280 --> 00:14:12,950
to change your original SQL query to

00:14:07,970 --> 00:14:16,070
make jungle to be able to build it but

00:14:12,950 --> 00:14:20,230
this is not a problem in 95% of the

00:14:16,070 --> 00:14:23,000
cases 95 with the number from my head so

00:14:20,230 --> 00:14:26,000
usually it's ok we have ability to

00:14:23,000 --> 00:14:27,980
switch to raw SQL and if you have a few

00:14:26,000 --> 00:14:30,490
such places it's not an issue and it

00:14:27,980 --> 00:14:34,550
doesn't hurt mayn't ability of our

00:14:30,490 --> 00:14:36,320
product but if you build data analysis

00:14:34,550 --> 00:14:38,390
application where you have only

00:14:36,320 --> 00:14:42,110
aggregations it's really good heard it's

00:14:38,390 --> 00:14:44,450
like the same site as you so so it's

00:14:42,110 --> 00:14:48,230
it's ok to look in such - like SQL

00:14:44,450 --> 00:14:50,690
alchemy for such type of project so

00:14:48,230 --> 00:14:54,230
here's a brief tutorial for you how to

00:14:50,690 --> 00:14:56,270
start and what you have to expect with

00:14:54,230 --> 00:14:58,490
this integration first of all you have

00:14:56,270 --> 00:15:00,350
to create engine it's a global variable

00:14:58,490 --> 00:15:03,920
which describe your connection to

00:15:00,350 --> 00:15:05,450
database and SQL alchemy comes by

00:15:03,920 --> 00:15:09,530
default this connection pooling

00:15:05,450 --> 00:15:12,080
functionality so you get a coupon but if

00:15:09,530 --> 00:15:15,260
you want your connection to behave the

00:15:12,080 --> 00:15:17,120
same as Jungle work like Django

00:15:15,260 --> 00:15:21,230
connection you have to disable pooling

00:15:17,120 --> 00:15:23,810
with no pool from architecture point of

00:15:21,230 --> 00:15:27,760
view your application would look like

00:15:23,810 --> 00:15:31,310
this so you can one instance you have VI

00:15:27,760 --> 00:15:32,070
you have 4 workers which are processes

00:15:31,310 --> 00:15:35,070
each of

00:15:32,070 --> 00:15:37,710
I'm configured to have a treads and each

00:15:35,070 --> 00:15:40,320
thread manage its own connection so you

00:15:37,710 --> 00:15:44,460
have 32 Django connections and 32

00:15:40,320 --> 00:15:47,160
sqlalchemy connections so likely later

00:15:44,460 --> 00:15:50,130
when you get the user so maybe when you

00:15:47,160 --> 00:15:51,960
instances have start scaling so you

00:15:50,130 --> 00:15:54,600
would like to add some connections

00:15:51,960 --> 00:15:56,640
pulling the wire right PG bouncer for

00:15:54,600 --> 00:16:00,960
example if you use posters because for

00:15:56,640 --> 00:16:03,570
posters it Forks a process for each

00:16:00,960 --> 00:16:05,580
connection so it's quite expensive to

00:16:03,570 --> 00:16:07,560
hold connections it's take at least 10

00:16:05,580 --> 00:16:10,380
megabytes of RAM so if you have two

00:16:07,560 --> 00:16:12,420
instances you just simply lost 1.2

00:16:10,380 --> 00:16:14,460
gigabytes of RAM simply to hold these

00:16:12,420 --> 00:16:17,310
connections so that's why connection

00:16:14,460 --> 00:16:21,000
pulling wire would be recommended for

00:16:17,310 --> 00:16:23,340
you if your application grow then you

00:16:21,000 --> 00:16:27,260
need to understand how you will work

00:16:23,340 --> 00:16:30,270
with the tables so you have few options

00:16:27,260 --> 00:16:33,180
there are two wipers which allows you to

00:16:30,270 --> 00:16:35,970
integrate a scale community jungle first

00:16:33,180 --> 00:16:37,590
of them are Jimmy it's has a mapping of

00:16:35,970 --> 00:16:40,230
the jungle fields and it's built

00:16:37,590 --> 00:16:42,450
sqlalchemy representation of this field

00:16:40,230 --> 00:16:45,840
of these tables and attach it to the

00:16:42,450 --> 00:16:49,710
models another one it's table reflection

00:16:45,840 --> 00:16:52,860
it's used it's SQL alchemy technique

00:16:49,710 --> 00:16:56,130
which allows you right here you say okay

00:16:52,860 --> 00:16:58,950
I have this table I want to get a Python

00:16:56,130 --> 00:17:00,990
representation of of this table so it

00:16:58,950 --> 00:17:03,930
generates it for you but it takes some

00:17:00,990 --> 00:17:07,260
time so you have to cache it maybe on

00:17:03,930 --> 00:17:09,900
application lounge also you can define

00:17:07,260 --> 00:17:12,390
your tables explicitly or define visit

00:17:09,900 --> 00:17:15,470
online expressions if you define

00:17:12,390 --> 00:17:18,750
explicitly its look like general models

00:17:15,470 --> 00:17:21,060
but you can keep it more simpler because

00:17:18,750 --> 00:17:23,610
we only read the data so you can provide

00:17:21,060 --> 00:17:28,020
only names of the table of the counts

00:17:23,610 --> 00:17:31,110
but I also advise you to specify foreign

00:17:28,020 --> 00:17:34,710
keys because SQL alchemy automatically

00:17:31,110 --> 00:17:37,620
pick up this relation so you have not to

00:17:34,710 --> 00:17:39,810
specify own condition for joins so it

00:17:37,620 --> 00:17:43,530
would be a bit simpler and code

00:17:39,810 --> 00:17:45,820
how you can use such tables so you build

00:17:43,530 --> 00:17:48,640
a query and you can see at your

00:17:45,820 --> 00:17:52,000
which stores accounts and you use it

00:17:48,640 --> 00:17:55,150
like a reference and result which you

00:17:52,000 --> 00:17:57,520
get each roll of result is roll proxy

00:17:55,150 --> 00:18:00,370
which actually behaves like name at

00:17:57,520 --> 00:18:03,370
Apple or act Apple or like dictionary so

00:18:00,370 --> 00:18:06,730
it's very handy and also it's possible

00:18:03,370 --> 00:18:07,960
to define your tables and columns within

00:18:06,730 --> 00:18:11,740
the wine expressions they are

00:18:07,960 --> 00:18:15,190
lightweight so you simply put the names

00:18:11,740 --> 00:18:18,190
in the query or but if you have to keep

00:18:15,190 --> 00:18:20,650
the reference for the column to the

00:18:18,190 --> 00:18:24,190
table which is refers to you can define

00:18:20,650 --> 00:18:27,250
it like this so the usage would be like

00:18:24,190 --> 00:18:30,280
on the previous slide actually that's

00:18:27,250 --> 00:18:35,650
all what you need to know but did

00:18:30,280 --> 00:18:38,610
somebody say two tests death is not so

00:18:35,650 --> 00:18:41,590
straightforward it has some pitfalls and

00:18:38,610 --> 00:18:43,450
something which is worse to mention so

00:18:41,590 --> 00:18:46,240
first of all if you remember we create

00:18:43,450 --> 00:18:49,150
it in Jenny's global variable so once

00:18:46,240 --> 00:18:51,640
the interpreter will read this wine it

00:18:49,150 --> 00:18:55,120
will evaluate it so we can use all right

00:18:51,640 --> 00:18:58,540
settings we can't use by test fixtures

00:18:55,120 --> 00:19:00,880
or hooks to change this setting because

00:18:58,540 --> 00:19:02,950
our wine would be already evaluated so

00:19:00,880 --> 00:19:05,500
likely you will have to introduce a

00:19:02,950 --> 00:19:08,860
function like this so if it's test it

00:19:05,500 --> 00:19:13,710
has ADD test prefix for you otherwise

00:19:08,860 --> 00:19:17,950
you will lose your data another

00:19:13,710 --> 00:19:21,850
interesting feature which a face it it's

00:19:17,950 --> 00:19:25,090
hope I test worked with cursors so if

00:19:21,850 --> 00:19:28,090
you have a result proxy it's actually a

00:19:25,090 --> 00:19:30,490
wrapper around a DB IP cursor and you

00:19:28,090 --> 00:19:32,500
have ability to iterate over the roles

00:19:30,490 --> 00:19:34,420
so you don't want all of them into

00:19:32,500 --> 00:19:36,010
memory you just iterating across them so

00:19:34,420 --> 00:19:38,560
you have a function to like process

00:19:36,010 --> 00:19:40,750
roles and maybe somewhere inside there

00:19:38,560 --> 00:19:43,360
is you write tests and there is

00:19:40,750 --> 00:19:45,790
exception and it fails so by tests will

00:19:43,360 --> 00:19:49,030
mark this test has failed and it will

00:19:45,790 --> 00:19:51,730
hang on forever because it doesn't allow

00:19:49,030 --> 00:19:54,640
a garbage collector to close the

00:19:51,730 --> 00:19:57,970
connection usually it does usually it's

00:19:54,640 --> 00:19:59,710
performed automatically so you have to

00:19:57,970 --> 00:20:02,409
do such tricks like

00:19:59,710 --> 00:20:04,179
for example right a decorator which

00:20:02,409 --> 00:20:07,059
applied to this function which to rate

00:20:04,179 --> 00:20:10,659
and produce exception for example in

00:20:07,059 --> 00:20:14,590
case of some error so you simply run

00:20:10,659 --> 00:20:16,899
across all arguments and if it's result

00:20:14,590 --> 00:20:19,570
proxy if it's your cursor you close and

00:20:16,899 --> 00:20:21,309
raise exception but it looks not so

00:20:19,570 --> 00:20:23,620
straightforward

00:20:21,309 --> 00:20:25,509
and the most important thing which you

00:20:23,620 --> 00:20:27,639
have to keep in mind when you develop

00:20:25,509 --> 00:20:29,440
such type of application that you have

00:20:27,639 --> 00:20:32,590
two connections and each of this

00:20:29,440 --> 00:20:35,409
connection have its own our transaction

00:20:32,590 --> 00:20:38,649
insulation level so if you use this case

00:20:35,409 --> 00:20:43,059
and you populate the database with model

00:20:38,649 --> 00:20:44,620
money or factory boy it will happen in

00:20:43,059 --> 00:20:47,289
Django connection

00:20:44,620 --> 00:20:47,769
so for test case in start of the each

00:20:47,289 --> 00:20:50,259
test

00:20:47,769 --> 00:20:52,480
jong-kook reads transaction for you but

00:20:50,259 --> 00:20:54,519
it doesn't commit it in the end it makes

00:20:52,480 --> 00:20:57,580
a rollback so transaction is never

00:20:54,519 --> 00:20:59,769
committed and SQL alchemy doesn't cease

00:20:57,580 --> 00:21:03,909
the data which was produced it in this

00:20:59,769 --> 00:21:06,039
test so this some kind of issue but

00:21:03,909 --> 00:21:09,070
still you can use test case in your

00:21:06,039 --> 00:21:12,759
application but just keep in mind that

00:21:09,070 --> 00:21:14,620
yeah it when you write tests for the

00:21:12,759 --> 00:21:18,309
code which works with one connection and

00:21:14,620 --> 00:21:21,820
you populate the test database with the

00:21:18,309 --> 00:21:23,500
same connection but yeah if you

00:21:21,820 --> 00:21:26,230
populated the data with SQL alchemy

00:21:23,500 --> 00:21:28,450
connection you have to clean your tables

00:21:26,230 --> 00:21:31,240
by yourself between the tests maybe with

00:21:28,450 --> 00:21:33,820
hooks or fixtures and also it's

00:21:31,240 --> 00:21:36,070
theoretically it's possible to share the

00:21:33,820 --> 00:21:38,799
data which was created and not committed

00:21:36,070 --> 00:21:40,769
so you need to change the transaction

00:21:38,799 --> 00:21:43,809
relational level on the SQL alchemy

00:21:40,769 --> 00:21:45,460
connection to read uncommitted but yeah

00:21:43,809 --> 00:21:50,620
it's not recommended but it's it's

00:21:45,460 --> 00:21:52,269
possible and also you you can use

00:21:50,620 --> 00:21:55,960
transaction test case and there is no

00:21:52,269 --> 00:22:01,360
issues with that so it's fine but such

00:21:55,960 --> 00:22:04,000
tests work slower because there are in

00:22:01,360 --> 00:22:07,090
how this transaction test case works

00:22:04,000 --> 00:22:09,009
they doing a post migrate signal between

00:22:07,090 --> 00:22:11,409
each test so they truncate all the

00:22:09,009 --> 00:22:12,760
tables which have models and then the

00:22:11,409 --> 00:22:15,280
launch pose

00:22:12,760 --> 00:22:16,720
great signal which creates permissions

00:22:15,280 --> 00:22:19,150
and content types

00:22:16,720 --> 00:22:22,180
so it takes some time so such this would

00:22:19,150 --> 00:22:24,160
be smaller yeah and if you work with

00:22:22,180 --> 00:22:26,140
tables which it doesn't have relation to

00:22:24,160 --> 00:22:28,500
jungle models you also have to clean up

00:22:26,140 --> 00:22:32,410
them between tests by yourself

00:22:28,500 --> 00:22:33,940
so drawbacks it's a bit hard to start

00:22:32,410 --> 00:22:36,370
because it's not too much information

00:22:33,940 --> 00:22:39,580
about such integration on the run mode

00:22:36,370 --> 00:22:43,360
such like tutorial like ok you have to

00:22:39,580 --> 00:22:46,390
do this but documentation of SQL alchemy

00:22:43,360 --> 00:22:49,540
is quite good but sometimes it work some

00:22:46,390 --> 00:22:53,080
examples but overall it's it's nice to

00:22:49,540 --> 00:22:58,390
work with and yeah you can find that

00:22:53,080 --> 00:23:01,540
it's not very easy to work with if you

00:22:58,390 --> 00:23:03,400
want to debug your query which you made

00:23:01,540 --> 00:23:05,830
in Python so you print it into the

00:23:03,400 --> 00:23:08,650
console and you will see that all

00:23:05,830 --> 00:23:12,550
parameters which you have maybe 20 or 30

00:23:08,650 --> 00:23:14,680
of them if it's hardware they it would

00:23:12,550 --> 00:23:17,740
be a placeholders instead of values

00:23:14,680 --> 00:23:20,020
which you want it to be there so it's a

00:23:17,740 --> 00:23:24,490
bit annoying to insert them manually

00:23:20,020 --> 00:23:29,470
because this functionality is done by DB

00:23:24,490 --> 00:23:31,330
ERP which doing this this safe insert of

00:23:29,470 --> 00:23:32,950
the parameters into the queries so SQL

00:23:31,330 --> 00:23:38,020
alchemy doesn't have such functionality

00:23:32,950 --> 00:23:42,490
of escaping your values to omit this

00:23:38,020 --> 00:23:45,550
injection SQL injections and yeah it's

00:23:42,490 --> 00:23:46,960
there are some solutions but it's not so

00:23:45,550 --> 00:23:50,920
straightforward so it's a bit annoying

00:23:46,960 --> 00:23:52,870
and you have slower tests because

00:23:50,920 --> 00:23:55,420
rightly you will use more transaction to

00:23:52,870 --> 00:23:58,390
space which are slower but it's also

00:23:55,420 --> 00:24:00,990
depends and here you have more

00:23:58,390 --> 00:24:03,730
connections to database but the most

00:24:00,990 --> 00:24:06,820
important thing to keep in mind that you

00:24:03,730 --> 00:24:09,280
can't no longer use Ohio libraries like

00:24:06,820 --> 00:24:11,560
Django future so pagination because they

00:24:09,280 --> 00:24:14,740
design it to work with corsets and now

00:24:11,560 --> 00:24:18,040
you have only like dictionary so tuples

00:24:14,740 --> 00:24:20,740
at least so you have to find some query

00:24:18,040 --> 00:24:24,460
set independent libraries or come with

00:24:20,740 --> 00:24:26,200
your own solutions to cover this gap but

00:24:24,460 --> 00:24:28,690
let's talk about anything

00:24:26,200 --> 00:24:31,480
so you actually get the full control

00:24:28,690 --> 00:24:33,610
over SQL level which is really cool and

00:24:31,480 --> 00:24:34,870
it gives you freedom to build whatever

00:24:33,610 --> 00:24:37,540
you want

00:24:34,870 --> 00:24:39,880
yeah it's faster to express a skill in

00:24:37,540 --> 00:24:42,040
Python code so if you have some data

00:24:39,880 --> 00:24:44,350
analysis guy which brings you tons of

00:24:42,040 --> 00:24:46,570
queries and say okay build this query

00:24:44,350 --> 00:24:49,870
some Python it's really easy to build

00:24:46,570 --> 00:24:52,930
them modify yeah and if you have some

00:24:49,870 --> 00:24:56,500
wire which creates such queries for you

00:24:52,930 --> 00:24:59,470
dynamically you have in SQL alchemy you

00:24:56,500 --> 00:25:01,510
have all obstructions over SQL so you

00:24:59,470 --> 00:25:03,790
can use them white building blocks and

00:25:01,510 --> 00:25:05,950
you can do whatever you want it's very

00:25:03,790 --> 00:25:08,050
handy to do this and you have cross

00:25:05,950 --> 00:25:10,420
readability meant ability and and

00:25:08,050 --> 00:25:13,810
performance because actually what you

00:25:10,420 --> 00:25:18,190
design it in SQL you generate it from

00:25:13,810 --> 00:25:21,190
Python so if you know SQL well enough so

00:25:18,190 --> 00:25:25,540
you will do correct queries and

00:25:21,190 --> 00:25:27,400
performance that's all

00:25:25,540 --> 00:25:29,640
I don't know do we have time for

00:25:27,400 --> 00:25:29,640
questions

00:25:30,270 --> 00:25:41,940
[Applause]

00:25:42,040 --> 00:25:48,530
we do have a few - a few minutes for

00:25:44,840 --> 00:25:51,530
questions so if anyone wants to come to

00:25:48,530 --> 00:25:56,420
the front or if we have anyone online

00:25:51,530 --> 00:25:58,450
with Django J gokon Q a hashtag we can

00:25:56,420 --> 00:26:01,460
answer a few questions

00:25:58,450 --> 00:26:03,710
hello thanks for the talk one question

00:26:01,460 --> 00:26:05,660
coming to my mind you said you're having

00:26:03,710 --> 00:26:07,130
two database connections which is

00:26:05,660 --> 00:26:10,190
obvious because you have Django and

00:26:07,130 --> 00:26:13,370
sickle alchemy did you explore the

00:26:10,190 --> 00:26:16,040
possibility of writing and I think you

00:26:13,370 --> 00:26:19,130
know SQL alchemy it's a database dialect

00:26:16,040 --> 00:26:21,610
which would reach over to the Django

00:26:19,130 --> 00:26:24,290
connection and reuse the underlying

00:26:21,610 --> 00:26:29,320
database API connection instead of

00:26:24,290 --> 00:26:31,820
having the - sorry could you repeat so

00:26:29,320 --> 00:26:34,550
there would be the possibility to write

00:26:31,820 --> 00:26:37,610
a custom back-end for sequel alchemy

00:26:34,550 --> 00:26:41,810
which would then reuse the connection

00:26:37,610 --> 00:26:44,600
textual did you actually there is a

00:26:41,810 --> 00:26:47,090
library currently it's under development

00:26:44,600 --> 00:26:49,930
it's like genres kill alchemy and it

00:26:47,090 --> 00:26:52,850
tries to be inserted into the wire which

00:26:49,930 --> 00:26:55,940
generates the squares so there are some

00:26:52,850 --> 00:26:57,920
attempts to merge them together but this

00:26:55,940 --> 00:27:00,920
is as far as I know they're currently

00:26:57,920 --> 00:27:03,380
under development and likely it would be

00:27:00,920 --> 00:27:06,710
not so easy and straightforward so I

00:27:03,380 --> 00:27:10,250
haven't tried this but I'm not sure that

00:27:06,710 --> 00:27:15,380
this good good way to move the

00:27:10,250 --> 00:27:19,250
application okay thanks for the talk it

00:27:15,380 --> 00:27:21,530
was interesting and I probably can guess

00:27:19,250 --> 00:27:27,560
at the answer but I wanted to know from

00:27:21,530 --> 00:27:31,340
you you haven't talked about the admin

00:27:27,560 --> 00:27:34,150
stuff in Django would it be possible to

00:27:31,340 --> 00:27:39,050
use the escal alchemy with the admin

00:27:34,150 --> 00:27:41,960
probably not no I there are some

00:27:39,050 --> 00:27:44,420
attempts also to bring this - to the

00:27:41,960 --> 00:27:46,010
jungle stack but the solution which I

00:27:44,420 --> 00:27:49,450
currently talking about it's mostly

00:27:46,010 --> 00:27:53,940
about yet designing your queries which

00:27:49,450 --> 00:27:58,809
be displayed for the users maybe you can

00:27:53,940 --> 00:28:00,970
use it if you start customizing what

00:27:58,809 --> 00:28:04,659
your jangada mean maybe you can insert

00:28:00,970 --> 00:28:07,690
there but it's it will be not easily

00:28:04,659 --> 00:28:10,299
integrated and Django admin it's mostly

00:28:07,690 --> 00:28:13,570
its ORM so it works with single roles

00:28:10,299 --> 00:28:16,179
but this is aggregation so you can help

00:28:13,570 --> 00:28:19,059
build custom dashboard somewhere to show

00:28:16,179 --> 00:28:20,769
the numbers overall numbers but if you

00:28:19,059 --> 00:28:23,320
want to work with single roles so you

00:28:20,769 --> 00:28:26,350
have to stick with John Gorham okay

00:28:23,320 --> 00:28:28,149
thank you we have a little bit less than

00:28:26,350 --> 00:28:34,269
one minute so we can answer about one

00:28:28,149 --> 00:28:38,409
more question so you mentioned in your

00:28:34,269 --> 00:28:41,049
target you start usually with a big SQL

00:28:38,409 --> 00:28:44,409
query that you already have so I was

00:28:41,049 --> 00:28:46,000
wondering if you experts to store that

00:28:44,409 --> 00:28:50,139
query as a stored procedure in the

00:28:46,000 --> 00:28:53,320
database and query and using crisis to

00:28:50,139 --> 00:28:56,260
launch the stored procedures and what

00:28:53,320 --> 00:28:59,289
are the pros and cons compared to you as

00:28:56,260 --> 00:29:03,279
you like your project oh I think it's

00:28:59,289 --> 00:29:06,760
mostly about how how to use them manage

00:29:03,279 --> 00:29:08,860
and maintain your stored procedures

00:29:06,760 --> 00:29:11,500
because if you have ever seen in Python

00:29:08,860 --> 00:29:13,870
code in Python project it's easily to

00:29:11,500 --> 00:29:21,039
manage to change and to influence and

00:29:13,870 --> 00:29:23,470
that so I can say about pros and cons

00:29:21,039 --> 00:29:25,600
it's from my point of view it's mostly

00:29:23,470 --> 00:29:29,139
about how it will be main table in the

00:29:25,600 --> 00:29:31,480
long run so my opinion it's better to

00:29:29,139 --> 00:29:33,669
have ever seen in in Python and not move

00:29:31,480 --> 00:29:35,919
this functionality to database because

00:29:33,669 --> 00:29:41,700
it would be not so explicit and not

00:29:35,919 --> 00:29:45,849
transparent what we going on thank you

00:29:41,700 --> 00:29:45,849

YouTube URL: https://www.youtube.com/watch?v=fpc6lkMdKzY


