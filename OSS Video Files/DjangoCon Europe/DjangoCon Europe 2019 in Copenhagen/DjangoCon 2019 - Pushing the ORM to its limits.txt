Title: DjangoCon 2019 - Pushing the ORM to its limits
Publication date: 2019-04-23
Playlist: DjangoCon Europe 2019 in Copenhagen
Description: 
	https://2019.djangocon.eu/talks/pushing-the-orm-to-its-limits/

By Sigurd LjÃ¸dal: https://twitter.com/sigurdlj
Captions: 
	00:00:00,000 --> 00:00:11,040
you and everyone here I have slides yeah

00:00:09,830 --> 00:00:14,820
okay

00:00:11,040 --> 00:00:19,680
hello I am Seeger and I am a developer

00:00:14,820 --> 00:00:24,119
at colonial thought I know where we eat

00:00:19,680 --> 00:00:26,609
to a lot of stuff in Django we built an

00:00:24,119 --> 00:00:30,929
online grocery store with logistics and

00:00:26,609 --> 00:00:34,489
we've used deorum for quite a lot so I'm

00:00:30,929 --> 00:00:37,739
going to tell you a bit about that and

00:00:34,489 --> 00:00:40,020
you will find the models then I'm going

00:00:37,739 --> 00:00:43,860
to use in my examples and Django project

00:00:40,020 --> 00:00:51,649
on my github account which you can see

00:00:43,860 --> 00:00:55,739
on that URL okay so let's get started

00:00:51,649 --> 00:00:58,469
quick agenda I'm first going to show you

00:00:55,739 --> 00:01:02,160
some quick tips and tricks to optimize

00:00:58,469 --> 00:01:06,030
your code to reduce your repetition and

00:01:02,160 --> 00:01:08,640
yeah various others minor things then

00:01:06,030 --> 00:01:11,220
I'm going to deep dive into sub queries

00:01:08,640 --> 00:01:15,210
which is something you can do in the RM

00:01:11,220 --> 00:01:19,950
now I will show you a bit about custom

00:01:15,210 --> 00:01:23,270
constraints and indexes a quick example

00:01:19,950 --> 00:01:26,310
of window functions using the ORM and

00:01:23,270 --> 00:01:31,670
finally a bit about how you can actually

00:01:26,310 --> 00:01:35,570
add your own custom stuff to the ORM and

00:01:31,670 --> 00:01:38,579
a quick disclaimer

00:01:35,570 --> 00:01:42,659
unfortunately my talk is quite code

00:01:38,579 --> 00:01:45,030
heavy so I'm sorry to those who are not

00:01:42,659 --> 00:01:50,399
developers but I hope you will be

00:01:45,030 --> 00:01:53,899
allowed to follow along okay so some

00:01:50,399 --> 00:01:56,909
quick tips and tricks the first one is

00:01:53,899 --> 00:02:00,149
you can add your own custom query sets

00:01:56,909 --> 00:02:02,280
and managers to your models which is

00:02:00,149 --> 00:02:05,399
really useful if you have a lot of views

00:02:02,280 --> 00:02:09,679
or serializers that access common

00:02:05,399 --> 00:02:12,239
objects for example we use it a lot for

00:02:09,679 --> 00:02:13,230
confirmed orders is a single thing that

00:02:12,239 --> 00:02:18,989
we do

00:02:13,230 --> 00:02:22,500
time so what you can do is have subclass

00:02:18,989 --> 00:02:25,620
of model store manager and model toad

00:02:22,500 --> 00:02:28,110
query set and you can implement any

00:02:25,620 --> 00:02:31,410
methods you like to do on this so in

00:02:28,110 --> 00:02:34,170
this example I have a method to create

00:02:31,410 --> 00:02:39,260
an order which will also for example

00:02:34,170 --> 00:02:42,629
create the lines for each product or

00:02:39,260 --> 00:02:44,879
filter out any orders that are delivered

00:02:42,629 --> 00:02:48,660
in case I'm looking at undelivered

00:02:44,879 --> 00:02:52,230
orders and this can be instantiated on

00:02:48,660 --> 00:02:56,220
the order model by setting the objects

00:02:52,230 --> 00:02:58,940
attribute like this and then you can

00:02:56,220 --> 00:03:03,359
access this through the objects

00:02:58,940 --> 00:03:07,290
reference on your model and the query

00:03:03,359 --> 00:03:10,829
set method can be chained like any other

00:03:07,290 --> 00:03:13,980
method on default query sets so this is

00:03:10,829 --> 00:03:17,970
useful if like I said you do a lot of

00:03:13,980 --> 00:03:21,959
things repetitively ok another quick

00:03:17,970 --> 00:03:24,630
thing if you are ever wondering why is

00:03:21,959 --> 00:03:26,790
something doing something weird or just

00:03:24,630 --> 00:03:31,290
wondering how is this working under the

00:03:26,790 --> 00:03:36,870
hood you can inspect your queries so if

00:03:31,290 --> 00:03:40,019
we have a query set and we convert it to

00:03:36,870 --> 00:03:43,260
a string then it will actually print out

00:03:40,019 --> 00:03:48,299
the actual SQL being run in the database

00:03:43,260 --> 00:03:51,200
and another new thing in Django 2.1 is

00:03:48,299 --> 00:03:55,829
that django has support for explain

00:03:51,200 --> 00:03:58,889
which will run an explained query in the

00:03:55,829 --> 00:04:00,810
database show you the output and this is

00:03:58,889 --> 00:04:04,799
really useful if you're wondering why is

00:04:00,810 --> 00:04:08,549
my query slow what is it's actually

00:04:04,799 --> 00:04:11,760
doing yeah and it has a lot of options

00:04:08,549 --> 00:04:13,799
you can specify in this example I set

00:04:11,760 --> 00:04:16,169
verbose true which is giving me extra

00:04:13,799 --> 00:04:19,500
output you can specify what formats you

00:04:16,169 --> 00:04:24,210
want if you want it to be to do analyze

00:04:19,500 --> 00:04:26,330
which is a deeper check and yep just a

00:04:24,210 --> 00:04:28,880
quick note this output is

00:04:26,330 --> 00:04:31,850
really database dependent so this is

00:04:28,880 --> 00:04:36,250
example from Postgres in other databases

00:04:31,850 --> 00:04:42,800
you most likely get different results

00:04:36,250 --> 00:04:44,930
yeah another quick example if you do

00:04:42,800 --> 00:04:48,410
something like this where we iterate

00:04:44,930 --> 00:04:51,320
over each order and then print out the

00:04:48,410 --> 00:04:54,889
customers name and then we have a set of

00:04:51,320 --> 00:04:57,889
lines on an order and we print out each

00:04:54,889 --> 00:05:01,389
line this will generate a lot of queries

00:04:57,889 --> 00:05:04,760
against the database which can be slow

00:05:01,389 --> 00:05:08,090
so what we can do here is use select

00:05:04,760 --> 00:05:11,949
related and prefetch related the first

00:05:08,090 --> 00:05:14,960
one will in this example fetch all the

00:05:11,949 --> 00:05:16,699
customers so the first example on

00:05:14,960 --> 00:05:20,110
adapter will not generate an extract

00:05:16,699 --> 00:05:24,440
query in the loop and the second one is

00:05:20,110 --> 00:05:26,330
fetching all the lines so the second

00:05:24,440 --> 00:05:29,320
example there will not generate extra

00:05:26,330 --> 00:05:32,510
queries and select related is for

00:05:29,320 --> 00:05:35,479
references where you have one-to-one or

00:05:32,510 --> 00:05:38,150
one-to-many so for example an order only

00:05:35,479 --> 00:05:40,669
has one customer but an order has

00:05:38,150 --> 00:05:44,830
multiple lines so then we have to use

00:05:40,669 --> 00:05:48,620
prefetch related which will generate

00:05:44,830 --> 00:05:50,510
join in Titan instead of the database so

00:05:48,620 --> 00:05:58,970
it's separate query but it will be run

00:05:50,510 --> 00:06:01,159
once for an entire query set ok and just

00:05:58,970 --> 00:06:05,389
a quick note on this don't optimize

00:06:01,159 --> 00:06:07,039
prematurely if you do this point Lee you

00:06:05,389 --> 00:06:10,880
might actually end up with slower

00:06:07,039 --> 00:06:13,400
queries so just be aware of this and

00:06:10,880 --> 00:06:20,630
know that you actually have a problem

00:06:13,400 --> 00:06:23,510
before you optimize too much and another

00:06:20,630 --> 00:06:28,750
quick tip you can also use the database

00:06:23,510 --> 00:06:33,349
to avoid race conditions for it select

00:06:28,750 --> 00:06:35,960
for update will for any row in the

00:06:33,349 --> 00:06:38,900
database returned by that query it will

00:06:35,960 --> 00:06:43,340
keep a lock for the duration of

00:06:38,900 --> 00:06:46,430
transaction so in this case when I say

00:06:43,340 --> 00:06:49,190
product of inventory minus one I can be

00:06:46,430 --> 00:06:52,220
sure that no other object or no other

00:06:49,190 --> 00:06:55,580
query has modified the same object in

00:06:52,220 --> 00:06:58,520
the database and then I can safely save

00:06:55,580 --> 00:07:02,990
and when the transaction ends in this

00:06:58,520 --> 00:07:06,919
case 1d with block exits it will release

00:07:02,990 --> 00:07:11,270
in the database and this is really

00:07:06,919 --> 00:07:15,050
useful in some cases it's also a bit

00:07:11,270 --> 00:07:16,640
heavy maybe so if you can model

00:07:15,050 --> 00:07:19,850
something in a different way maybe

00:07:16,640 --> 00:07:22,270
consider it but yeah it's worth knowing

00:07:19,850 --> 00:07:28,160
that it is an option available to you

00:07:22,270 --> 00:07:32,780
okay so let's have a deep dive into sub

00:07:28,160 --> 00:07:37,130
queries which is something that the

00:07:32,780 --> 00:07:39,080
Django Orem got in i think it was one

00:07:37,130 --> 00:07:41,720
point eleven so it's been around for

00:07:39,080 --> 00:07:44,930
quite a while but it's really powerful

00:07:41,720 --> 00:07:48,800
and allows you to do a lot so I will now

00:07:44,930 --> 00:07:49,520
show you first an example where for each

00:07:48,800 --> 00:07:52,430
customer

00:07:49,520 --> 00:07:58,039
I want the timestamp when they place

00:07:52,430 --> 00:08:00,560
their latest order so I have this query

00:07:58,039 --> 00:08:04,610
and yeah it's a lot of code there's a

00:08:00,560 --> 00:08:08,660
lot going on but we use the analyse

00:08:04,610 --> 00:08:11,360
method and annotate method sorry on the

00:08:08,660 --> 00:08:14,450
query set which allows us to add new

00:08:11,360 --> 00:08:18,770
fields basically to the resulting

00:08:14,450 --> 00:08:24,260
objects and we use the sub query class

00:08:18,770 --> 00:08:27,800
which wraps separate query set where we

00:08:24,260 --> 00:08:29,900
can basically do anything we want and we

00:08:27,800 --> 00:08:33,130
can also use the special class called

00:08:29,900 --> 00:08:36,289
outer ref which will reference the

00:08:33,130 --> 00:08:39,409
wrapping query outside of this so in

00:08:36,289 --> 00:08:44,750
this case I am referencing the primary

00:08:39,409 --> 00:08:47,870
key of the customer and then I'm so this

00:08:44,750 --> 00:08:50,320
basically returns a corset with all the

00:08:47,870 --> 00:08:53,100
orders of that customer

00:08:50,320 --> 00:08:56,050
and then ordering it by timestamp

00:08:53,100 --> 00:08:58,540
selecting only the timestamp because

00:08:56,050 --> 00:09:01,149
that's the one value I'm interested in

00:08:58,540 --> 00:09:04,660
and so queries only allow you to write

00:09:01,149 --> 00:09:07,540
return a single value in these cases and

00:09:04,660 --> 00:09:09,940
then I'm limiting it to the first one

00:09:07,540 --> 00:09:13,440
because it's going to be added as a

00:09:09,940 --> 00:09:16,589
column so I can only have one value and

00:09:13,440 --> 00:09:20,139
the result of this is that I can say

00:09:16,589 --> 00:09:21,550
latest order time on a customer and my

00:09:20,139 --> 00:09:26,769
example is wrong it should have been a

00:09:21,550 --> 00:09:30,069
timestamp sorry yeah and it's also

00:09:26,769 --> 00:09:33,009
possible to do exists queries where you

00:09:30,069 --> 00:09:35,940
basically replace sub query with exists

00:09:33,009 --> 00:09:38,470
and then you can check basically does

00:09:35,940 --> 00:09:44,259
something exist in the database without

00:09:38,470 --> 00:09:46,569
actually fetching the data but we can

00:09:44,259 --> 00:09:51,399
also use sub queries to do aggregation

00:09:46,569 --> 00:09:54,339
so say that we have a sales target where

00:09:51,399 --> 00:09:59,860
we each month want to sell for a certain

00:09:54,339 --> 00:10:03,399
amount and then we try to check if we've

00:09:59,860 --> 00:10:06,310
reached that target then we want every

00:10:03,399 --> 00:10:10,300
single order that matches the year and

00:10:06,310 --> 00:10:13,690
month specified on the sales target we

00:10:10,300 --> 00:10:18,160
use values list to group by those two

00:10:13,690 --> 00:10:22,290
fields where we extract the year from

00:10:18,160 --> 00:10:25,149
the date and the month from the 8th this

00:10:22,290 --> 00:10:26,920
these two values will be unique for

00:10:25,149 --> 00:10:31,389
everything that matches the first filter

00:10:26,920 --> 00:10:35,019
so the group by is basically an old but

00:10:31,389 --> 00:10:39,610
it's something we have to do and the

00:10:35,019 --> 00:10:42,389
current Django arm but yeah this is or

00:10:39,610 --> 00:10:47,529
at least this is how it's documented

00:10:42,389 --> 00:10:50,769
then we annotate the sum this basically

00:10:47,529 --> 00:10:53,769
is a group by that does it we play by

00:10:50,769 --> 00:10:56,949
the two top levels calculates some of

00:10:53,769 --> 00:10:59,410
the total of the lines and then we

00:10:56,949 --> 00:11:00,930
return like in the other example a

00:10:59,410 --> 00:11:03,300
values list

00:11:00,930 --> 00:11:05,880
and because we've grouped by something

00:11:03,300 --> 00:11:09,300
this will only return a single values we

00:11:05,880 --> 00:11:13,290
don't have to limit this to a single row

00:11:09,300 --> 00:11:20,190
and the result of this is that we get a

00:11:13,290 --> 00:11:21,990
gross total the object and this is

00:11:20,190 --> 00:11:27,270
currently the only way this is

00:11:21,990 --> 00:11:30,089
documented but say that we don't have

00:11:27,270 --> 00:11:30,810
anything unique to group by what do we

00:11:30,089 --> 00:11:34,440
do then

00:11:30,810 --> 00:11:40,410
so let's say we have a database table

00:11:34,440 --> 00:11:45,029
where we have three values and we want

00:11:40,410 --> 00:11:48,330
to select only or just placed on weekend

00:11:45,029 --> 00:11:51,480
date which is seven and one if you use

00:11:48,330 --> 00:11:56,370
the Django or M so the last one here

00:11:51,480 --> 00:11:59,029
should not be included okay so yeah we

00:11:56,370 --> 00:12:04,260
do the same filtering where we say

00:11:59,029 --> 00:12:06,690
weekday is either 7 or 1 but it can be

00:12:04,260 --> 00:12:09,510
either 7 or 1 so we don't have anything

00:12:06,690 --> 00:12:13,320
unique to group by what do we do then

00:12:09,510 --> 00:12:18,779
well we could try to just select the sum

00:12:13,320 --> 00:12:20,250
directly but because of how the way sum

00:12:18,779 --> 00:12:26,459
is implemented in Django

00:12:20,250 --> 00:12:28,740
this will add group by on the ID of the

00:12:26,459 --> 00:12:32,370
order objects so basically what you see

00:12:28,740 --> 00:12:37,529
is that we get the first value which is

00:12:32,370 --> 00:12:41,370
not really what we wanted well there is

00:12:37,529 --> 00:12:44,040
a trick we can do here which is sorry

00:12:41,370 --> 00:12:49,560
yeah so we have the same table same

00:12:44,040 --> 00:12:53,190
values and by replacing some with just

00:12:49,560 --> 00:12:57,420
func and specifying that we want to use

00:12:53,190 --> 00:13:00,329
the SQL function named sum we get the

00:12:57,420 --> 00:13:04,170
result we want and the trick here is

00:13:00,329 --> 00:13:08,940
that sum is a subclass of aggregate and

00:13:04,170 --> 00:13:11,910
aggregate does add group by clause where

00:13:08,940 --> 00:13:14,550
if we don't already have specified what

00:13:11,910 --> 00:13:17,430
to group by it will group by

00:13:14,550 --> 00:13:20,370
the primary key of the current query set

00:13:17,430 --> 00:13:23,880
which in this case is the order ID but

00:13:20,370 --> 00:13:25,620
funk is not a subclass of aggregate so

00:13:23,880 --> 00:13:28,320
this will actually just calculate the

00:13:25,620 --> 00:13:30,899
sum across all rows without grouping

00:13:28,320 --> 00:13:35,880
which is what we wanted in the first

00:13:30,899 --> 00:13:38,730
place so this it's not the prettiest it

00:13:35,880 --> 00:13:42,959
does work though so it's worth knowing

00:13:38,730 --> 00:13:45,959
and yeah and a note on this is sometimes

00:13:42,959 --> 00:13:49,860
it's really useful to inspect the query

00:13:45,959 --> 00:13:52,140
sets query attribute that's basically

00:13:49,860 --> 00:13:56,279
how I discovered this I discovered that

00:13:52,140 --> 00:14:00,000
okay some adds a group by clause but

00:13:56,279 --> 00:14:02,100
this doesn't so yeah hopefully we can

00:14:00,000 --> 00:14:04,950
implement this in Django at some point

00:14:02,100 --> 00:14:11,000
but right now this is a solution that

00:14:04,950 --> 00:14:14,660
works done let's have a quick look on

00:14:11,000 --> 00:14:17,940
custom constraints and indexes which

00:14:14,660 --> 00:14:21,120
Django has had support for unique

00:14:17,940 --> 00:14:25,579
constraints for quite a while but custom

00:14:21,120 --> 00:14:28,440
constraints and indexes new starting in

00:14:25,579 --> 00:14:32,010
Django 2.0 I think you can specify

00:14:28,440 --> 00:14:36,320
custom indexes and starting in Django

00:14:32,010 --> 00:14:39,990
2.2 you can specify either conditional

00:14:36,320 --> 00:14:43,380
constraints or conditional indexes so

00:14:39,990 --> 00:14:46,290
let's have a look at that first unique

00:14:43,380 --> 00:14:50,790
constraint so say we have a sales target

00:14:46,290 --> 00:14:53,940
where we specify a month and a year here

00:14:50,790 --> 00:14:57,449
we don't want to have duplicate values

00:14:53,940 --> 00:15:00,949
we can only have one target for a single

00:14:57,449 --> 00:15:03,720
month so we use unique together and

00:15:00,949 --> 00:15:05,820
specify that year and month should be

00:15:03,720 --> 00:15:11,550
dealt out those two in combination

00:15:05,820 --> 00:15:15,000
should be unique so yeah this has been

00:15:11,550 --> 00:15:17,630
around for a long time new now is that

00:15:15,000 --> 00:15:23,040
we can have partial unique constraint

00:15:17,630 --> 00:15:26,470
say that on an order we don't want to

00:15:23,040 --> 00:15:31,860
allow customers to actually have

00:15:26,470 --> 00:15:37,660
multiple unshipped orders now we can set

00:15:31,860 --> 00:15:40,660
my did my slight disappear okay sorry

00:15:37,660 --> 00:15:42,220
okay so we can set instead of setting

00:15:40,660 --> 00:15:45,460
unique together we actually set

00:15:42,220 --> 00:15:49,480
constraints to the list of constraints

00:15:45,460 --> 00:15:53,170
so in this case we say we want to field

00:15:49,480 --> 00:15:56,920
customer and it's shipped to be unique

00:15:53,170 --> 00:16:01,390
together but only in the case where is

00:15:56,920 --> 00:16:04,450
shipped is set to false this will do

00:16:01,390 --> 00:16:06,760
basically the same as the other example

00:16:04,450 --> 00:16:10,530
on the previous slide but it will do it

00:16:06,760 --> 00:16:15,700
only on rows for that condition is true

00:16:10,530 --> 00:16:20,080
so this is useful for a lot of things if

00:16:15,700 --> 00:16:21,970
you have any rows with null values one

00:16:20,080 --> 00:16:24,370
row with null is considered different

00:16:21,970 --> 00:16:26,190
from another row with null so if you

00:16:24,370 --> 00:16:28,930
want to have unique constraint saying

00:16:26,190 --> 00:16:31,240
only one row should be allowed to be

00:16:28,930 --> 00:16:35,350
null this is basically the only way to

00:16:31,240 --> 00:16:37,960
do it you say is you filter by the row

00:16:35,350 --> 00:16:40,990
that is null and say it has to be unique

00:16:37,960 --> 00:16:43,060
on some other way and you can have a

00:16:40,990 --> 00:16:48,960
separate constraint constraining other

00:16:43,060 --> 00:16:52,150
values where it's not now yeah and

00:16:48,960 --> 00:16:56,170
another new type of constraint in Django

00:16:52,150 --> 00:16:58,630
2.2 is checking constraints this is

00:16:56,170 --> 00:17:01,660
similar to what we've had in Django for

00:16:58,630 --> 00:17:04,990
quite a while where we have validators

00:17:01,660 --> 00:17:07,060
on fields that's basically when you set

00:17:04,990 --> 00:17:10,720
a value it will check run some

00:17:07,060 --> 00:17:13,410
validators to check if the value you

00:17:10,720 --> 00:17:16,210
have entered is within some constraint

00:17:13,410 --> 00:17:19,150
but new here is that you can make the

00:17:16,210 --> 00:17:23,830
database do this so you can say for

00:17:19,150 --> 00:17:27,850
example on our monthly sales target we

00:17:23,830 --> 00:17:33,240
can say the month must be in the range 1

00:17:27,850 --> 00:17:36,010
to 12 inclusive which basically it's

00:17:33,240 --> 00:17:38,440
indeed Julian and Gregorian calendars

00:17:36,010 --> 00:17:40,240
are the valid months and we don't want

00:17:38,440 --> 00:17:44,470
any rows with values

00:17:40,240 --> 00:17:46,210
outside of that this is unlike the

00:17:44,470 --> 00:17:48,640
normal validators in Django

00:17:46,210 --> 00:17:52,510
this is well dated by the database so

00:17:48,640 --> 00:17:56,470
this will protect you if you have a bulk

00:17:52,510 --> 00:17:59,380
inserts bulk updates if you access the

00:17:56,470 --> 00:18:03,360
database outside of Django it will still

00:17:59,380 --> 00:18:10,440
be checked so it can be really useful

00:18:03,360 --> 00:18:16,150
okay and then we have partial indexes

00:18:10,440 --> 00:18:20,020
this is it's similar in Postgres it's

00:18:16,150 --> 00:18:22,720
actually the same basically as partial

00:18:20,020 --> 00:18:26,670
constraints except it doesn't limit you

00:18:22,720 --> 00:18:32,170
but it will help you maybe speed up some

00:18:26,670 --> 00:18:35,500
indexes some queries or if you have like

00:18:32,170 --> 00:18:38,230
if you have a table with a lot of null

00:18:35,500 --> 00:18:40,540
values that you don't want to have in

00:18:38,230 --> 00:18:43,510
your index you can specify a condition

00:18:40,540 --> 00:18:46,780
on the index that just index the values

00:18:43,510 --> 00:18:51,790
that don't have no or in this case just

00:18:46,780 --> 00:18:55,510
index D and shipped orders so those are

00:18:51,790 --> 00:19:00,480
the ones that we most often access so we

00:18:55,510 --> 00:19:04,210
want the queries on that to be fast ok

00:19:00,480 --> 00:19:10,360
window functions is another new thing in

00:19:04,210 --> 00:19:14,380
Django 2.0 a quick example this is for

00:19:10,360 --> 00:19:18,690
each order I want to fetch the ID of the

00:19:14,380 --> 00:19:22,900
previous order from the same customer so

00:19:18,690 --> 00:19:30,309
yeah our alpha terribly one to use the

00:19:22,900 --> 00:19:33,940
window class from the or and we use a

00:19:30,309 --> 00:19:39,280
function called lag which is referencing

00:19:33,940 --> 00:19:42,400
a value in a different row in the query

00:19:39,280 --> 00:19:45,130
set so in this case it's using specified

00:19:42,400 --> 00:19:46,929
one it's the previous row I could

00:19:45,130 --> 00:19:50,530
specify too and it would go two steps

00:19:46,929 --> 00:19:53,420
back and similar and then we say

00:19:50,530 --> 00:19:56,600
partition by the customer ID because

00:19:53,420 --> 00:19:59,390
wanted an order from the same customer

00:19:56,600 --> 00:20:01,910
and then I specify that you order it by

00:19:59,390 --> 00:20:04,790
the creative time to get the previous

00:20:01,910 --> 00:20:07,720
one and this results in a query set

00:20:04,790 --> 00:20:11,690
where we have annotated an ID on it and

00:20:07,720 --> 00:20:14,330
this this is a really basic example but

00:20:11,690 --> 00:20:17,800
it can be really powerful if for example

00:20:14,330 --> 00:20:20,990
we want to calculate a cumulative sum of

00:20:17,800 --> 00:20:24,890
gross amounts for each order where it

00:20:20,990 --> 00:20:27,410
goes or we want to compare the total

00:20:24,890 --> 00:20:30,440
sales amount on an order to the previous

00:20:27,410 --> 00:20:38,240
order for example so this has a lot of

00:20:30,440 --> 00:20:41,120
uses if we want to extend that erm with

00:20:38,240 --> 00:20:44,510
our own functionality in cases where we

00:20:41,120 --> 00:20:49,870
don't really find what we need it's also

00:20:44,510 --> 00:20:52,340
possible so one example is okay the

00:20:49,870 --> 00:20:55,520
database has a function that I want to

00:20:52,340 --> 00:20:59,600
use but the or arm does currently not

00:20:55,520 --> 00:21:02,060
expose it well we can create our own

00:20:59,600 --> 00:21:05,180
subclass of funk which you've seen

00:21:02,060 --> 00:21:07,610
earlier and specify that the function

00:21:05,180 --> 00:21:11,270
used should be in this example round

00:21:07,610 --> 00:21:13,670
which is doing our rounding of a number

00:21:11,270 --> 00:21:18,200
in the database instead of having to do

00:21:13,670 --> 00:21:20,960
it in Python code so this is everything

00:21:18,200 --> 00:21:23,000
that's required to use that function use

00:21:20,960 --> 00:21:30,920
it like any of the other annotations

00:21:23,000 --> 00:21:34,790
that we have from Django you can also do

00:21:30,920 --> 00:21:36,830
more complex examples so in this case

00:21:34,790 --> 00:21:40,100
I'm implementing

00:21:36,830 --> 00:21:43,700
a function that takes a separate date

00:21:40,100 --> 00:21:46,580
and time column and combines them

00:21:43,700 --> 00:21:48,410
together to get a date time if for

00:21:46,580 --> 00:21:51,170
example I want to compare this to

00:21:48,410 --> 00:21:56,090
another table where I have the date time

00:21:51,170 --> 00:22:00,170
as a proper date time value so we take

00:21:56,090 --> 00:22:04,520
in two inputs arity to the two columns

00:22:00,170 --> 00:22:06,220
and we output a date time and this one

00:22:04,520 --> 00:22:08,740
is implemented separative

00:22:06,220 --> 00:22:10,659
or a different database packet so in

00:22:08,740 --> 00:22:13,539
this example I'm going to show you the

00:22:10,659 --> 00:22:21,000
process code so we implement this

00:22:13,539 --> 00:22:24,610
function it takes in arguments and we

00:22:21,000 --> 00:22:27,280
annotate the given values with some

00:22:24,610 --> 00:22:30,039
extra information so in this example we

00:22:27,280 --> 00:22:34,630
want to add the time zone to be sure

00:22:30,039 --> 00:22:37,799
that we get the value in the in intended

00:22:34,630 --> 00:22:40,630
time zone we specify a template which

00:22:37,799 --> 00:22:45,640
django will use to generate the actual

00:22:40,630 --> 00:22:49,059
SQL in this case we have the two values

00:22:45,640 --> 00:22:52,960
we get in and we append the time zone

00:22:49,059 --> 00:22:59,110
and then we do add SQL cast to a

00:22:52,960 --> 00:23:02,890
timestamp TC so we will and then we will

00:22:59,110 --> 00:23:04,630
allow this to be done by Django and we

00:23:02,890 --> 00:23:07,150
can use it like this at the bottom here

00:23:04,630 --> 00:23:09,520
so basically we specify the two fields

00:23:07,150 --> 00:23:15,130
that have the date and time and the

00:23:09,520 --> 00:23:20,309
output of this will be at date time last

00:23:15,130 --> 00:23:24,419
example I want to write some custom ORM

00:23:20,309 --> 00:23:27,429
custom SQL sorry okay

00:23:24,419 --> 00:23:30,880
first example I want to use the age

00:23:27,429 --> 00:23:35,860
function in Postgres so i annotate my

00:23:30,880 --> 00:23:40,929
query set with raw SQL class or this

00:23:35,860 --> 00:23:44,049
same thing can be done using extra this

00:23:40,929 --> 00:23:46,630
has a lot more options so yeah check out

00:23:44,049 --> 00:23:49,780
the documentation if you are interested

00:23:46,630 --> 00:23:53,260
or if I actually want to write the

00:23:49,780 --> 00:23:58,679
entire SQL myself I can do that using

00:23:53,260 --> 00:24:02,710
raw on the Karissa or I can actually

00:23:58,679 --> 00:24:05,320
build the entire thing myself

00:24:02,710 --> 00:24:09,250
using just database cursor where I can

00:24:05,320 --> 00:24:14,440
run my own SQL and get any output

00:24:09,250 --> 00:24:17,740
so we execute a SQL and use fetch one

00:24:14,440 --> 00:24:20,610
which will return one row in this case

00:24:17,740 --> 00:24:25,210
will be a toefl where the value is just

00:24:20,610 --> 00:24:27,460
okay and there's so much more to the

00:24:25,210 --> 00:24:30,250
jungle or am that I would what I've been

00:24:27,460 --> 00:24:32,460
able to fit into 30 minutes so please

00:24:30,250 --> 00:24:36,130
have a look at documentation

00:24:32,460 --> 00:24:40,300
specifically the ORM query set API

00:24:36,130 --> 00:24:43,690
documentation is really useful yeah okay

00:24:40,300 --> 00:24:46,570
so thank you if you want to contact me

00:24:43,690 --> 00:24:49,570
you can find me on Twitter I will

00:24:46,570 --> 00:24:53,200
publish blog posts after the conference

00:24:49,570 --> 00:24:55,120
with some more details and yeah we also

00:24:53,200 --> 00:24:59,880
have a stamp so you can find me there if

00:24:55,120 --> 00:24:59,880
you have any questions okay thank you

00:25:05,860 --> 00:25:10,870
all right thank you very much Tigger

00:25:08,230 --> 00:25:12,279
that was very informative I just

00:25:10,870 --> 00:25:15,929
realized I need to go back to the office

00:25:12,279 --> 00:25:15,929

YouTube URL: https://www.youtube.com/watch?v=MPpPu6c8wsM


