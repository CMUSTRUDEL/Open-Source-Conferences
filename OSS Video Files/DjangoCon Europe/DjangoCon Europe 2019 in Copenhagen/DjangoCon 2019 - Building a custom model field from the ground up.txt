Title: DjangoCon 2019 - Building a custom model field from the ground up
Publication date: 2019-04-23
Playlist: DjangoCon Europe 2019 in Copenhagen
Description: 
	https://2019.djangocon.eu/talks/building-a-custom-model-field-from-the-ground-up/

By Dmitry Dygalo: https://twitter.com/Stranger6667
Captions: 
	00:00:00,000 --> 00:00:06,359
so now I have the pleasure of

00:00:01,829 --> 00:00:07,980
introducing Dmitri de gallo that's right

00:00:06,359 --> 00:00:10,110
okay great

00:00:07,980 --> 00:00:19,710
building a custom model field from the

00:00:10,110 --> 00:00:20,330
ground up hello everybody can you hear

00:00:19,710 --> 00:00:25,500
me

00:00:20,330 --> 00:00:27,359
cool so I'm Dimitri and I'm working at

00:00:25,500 --> 00:00:30,240
Kiva dot-com as a technical team lead

00:00:27,359 --> 00:00:34,739
I'm located in Prague Czech Republic I

00:00:30,240 --> 00:00:37,200
do Python from 2010 I comment in couple

00:00:34,739 --> 00:00:44,570
of open-source projects like junk money

00:00:37,200 --> 00:00:44,570
and I love open source and traveling so

00:00:44,629 --> 00:00:51,899
who use custom model fields could you

00:00:48,000 --> 00:00:57,030
raise your hands nice who tried to build

00:00:51,899 --> 00:01:00,930
your own cool okay so basically why do

00:00:57,030 --> 00:01:03,510
we need it first use case is when we

00:01:00,930 --> 00:01:07,110
need to mop some custom database types

00:01:03,510 --> 00:01:07,590
into Python objects and the other way

00:01:07,110 --> 00:01:10,710
around

00:01:07,590 --> 00:01:15,210
store some complex Python objects in the

00:01:10,710 --> 00:01:19,470
database so it's two ways interaction

00:01:15,210 --> 00:01:22,259
and there is a use case for it

00:01:19,470 --> 00:01:25,170
the project is called Jenga money it

00:01:22,259 --> 00:01:29,040
provides you money and currency objects

00:01:25,170 --> 00:01:32,310
and integrates everything into jungle or

00:01:29,040 --> 00:01:34,170
M also it has forums amine integration

00:01:32,310 --> 00:01:36,869
template tags Django rest framework

00:01:34,170 --> 00:01:41,329
integration currencies stuff like this

00:01:36,869 --> 00:01:44,340
this project is kind of made sure it was

00:01:41,329 --> 00:01:49,220
started in 2011 as a fork of another

00:01:44,340 --> 00:01:52,729
project I started to commit into it in

00:01:49,220 --> 00:01:55,950
2013 and I use it in my previous job I

00:01:52,729 --> 00:01:57,899
started to maintain it hopefully a

00:01:55,950 --> 00:02:01,049
couple of years ago and the interesting

00:01:57,899 --> 00:02:03,689
fact is that there are two maintained

00:02:01,049 --> 00:02:06,630
years here on the conference and I first

00:02:03,689 --> 00:02:09,640
time it Benjamin here after six years of

00:02:06,630 --> 00:02:18,020
working together on the project

00:02:09,640 --> 00:02:20,210
okay a little overview of the topics

00:02:18,020 --> 00:02:23,000
that we will cover today first of all we

00:02:20,210 --> 00:02:27,260
will inspect the storage level how to

00:02:23,000 --> 00:02:30,530
map money to model what are the queries

00:02:27,260 --> 00:02:36,170
underneath how the scrapers could help

00:02:30,530 --> 00:02:38,540
you then we'll make some craze we'll try

00:02:36,170 --> 00:02:41,450
a lookup API and introduce some

00:02:38,540 --> 00:02:44,750
expressions and some extras like

00:02:41,450 --> 00:02:48,910
migrations serialization validation

00:02:44,750 --> 00:02:54,260
stuff like this so let's go for storage

00:02:48,910 --> 00:02:56,960
in our domain we have money basically it

00:02:54,260 --> 00:03:00,560
consists of two things amount and

00:02:56,960 --> 00:03:03,200
currency and we can use it like this so

00:03:00,560 --> 00:03:07,700
we have money amount currency we have

00:03:03,200 --> 00:03:09,740
decimal l string also we can use some

00:03:07,700 --> 00:03:14,240
arithmetic s-- like addition subtraction

00:03:09,740 --> 00:03:17,960
some other operation also we can

00:03:14,240 --> 00:03:21,290
localize the representation depending on

00:03:17,960 --> 00:03:24,500
the locale we want to use and I have a

00:03:21,290 --> 00:03:29,840
question for you who use decimal or

00:03:24,500 --> 00:03:37,460
numeric type for storing money floating

00:03:29,840 --> 00:03:40,840
point types couple of integers okay I

00:03:37,460 --> 00:03:45,140
believe that the preferred way is to use

00:03:40,840 --> 00:03:49,570
decimal or numeric for stringing because

00:03:45,140 --> 00:03:53,270
otherwise you could face precision loss

00:03:49,570 --> 00:03:56,510
in most of the cases so we need to map

00:03:53,270 --> 00:03:59,680
these to our beautiful model okay for

00:03:56,510 --> 00:04:04,400
example we have item to buy and we have

00:03:59,680 --> 00:04:07,790
simple name and our new money field sir

00:04:04,400 --> 00:04:10,700
I would recommend to start always with

00:04:07,790 --> 00:04:13,850
designing the interface or how you would

00:04:10,700 --> 00:04:17,710
use your new field so basically we need

00:04:13,850 --> 00:04:20,120
some basic operations create get update

00:04:17,710 --> 00:04:22,650
it's it could be done in different ways

00:04:20,120 --> 00:04:28,590
but there are some examples

00:04:22,650 --> 00:04:31,860
in the code so safe get some F is safe

00:04:28,590 --> 00:04:35,880
and refreshing no complex queries yet

00:04:31,860 --> 00:04:38,490
and I really recommend you to make the

00:04:35,880 --> 00:04:42,840
test cases from from these expectations

00:04:38,490 --> 00:04:47,370
from your interface just just like this

00:04:42,840 --> 00:04:50,729
or you can use built-in jungle test

00:04:47,370 --> 00:04:57,150
cases or use PI test whatever you think

00:04:50,729 --> 00:04:59,699
will fit here so on the storage level we

00:04:57,150 --> 00:05:02,610
can we can approach in a different ways

00:04:59,699 --> 00:05:04,590
for example we can store data in

00:05:02,610 --> 00:05:08,990
different fields as we do in Jango money

00:05:04,590 --> 00:05:14,630
which is not really good in all cases so

00:05:08,990 --> 00:05:18,030
it's standard scale and unfortunately

00:05:14,630 --> 00:05:18,660
managing two fields at once is not

00:05:18,030 --> 00:05:21,030
trivial

00:05:18,660 --> 00:05:24,389
in all cases I will show you some

00:05:21,030 --> 00:05:29,940
examples of the consequences of such

00:05:24,389 --> 00:05:33,720
decisions okay how can we connect it to

00:05:29,940 --> 00:05:36,419
the database we have our money and we

00:05:33,720 --> 00:05:38,539
need to store amount in a decimal field

00:05:36,419 --> 00:05:41,550
and currency and char field and

00:05:38,539 --> 00:05:46,200
underlying data types in the database

00:05:41,550 --> 00:05:50,099
are numeric inverter sir and how we will

00:05:46,200 --> 00:05:52,940
do it on the Python level there is nice

00:05:50,099 --> 00:05:55,789
nice thing called descriptors and

00:05:52,940 --> 00:05:59,490
basically it allows you to customize

00:05:55,789 --> 00:06:03,330
attribute access so get set or delete

00:05:59,490 --> 00:06:10,800
you can customize these things actually

00:06:03,330 --> 00:06:13,289
and in our case we need to build a money

00:06:10,800 --> 00:06:16,530
instance when we getting something from

00:06:13,289 --> 00:06:19,979
the field and we need to set another

00:06:16,530 --> 00:06:26,070
field when we are sitting something to

00:06:19,979 --> 00:06:28,830
this price field so for this purpose we

00:06:26,070 --> 00:06:32,990
can utilize control contribute to class

00:06:28,830 --> 00:06:35,910
and add also these currents feel there

00:06:32,990 --> 00:06:40,670
but does it seem hockey to

00:06:35,910 --> 00:06:43,680
who think that is hacky approach yes

00:06:40,670 --> 00:06:47,720
there is nice alternative called

00:06:43,680 --> 00:06:51,600
structure type is from SQL 1999 a belief

00:06:47,720 --> 00:06:54,000
and it implies the usual way of

00:06:51,600 --> 00:06:56,700
implementing custom fields because it's

00:06:54,000 --> 00:07:00,510
much easier to map one field from

00:06:56,700 --> 00:07:03,030
database to one field in gender in

00:07:00,510 --> 00:07:06,630
Postgres you can for example create type

00:07:03,030 --> 00:07:11,940
chunk of money as amount and currency of

00:07:06,630 --> 00:07:14,970
certain types and the queries will be a

00:07:11,940 --> 00:07:17,490
bit different so you need to twice

00:07:14,970 --> 00:07:19,830
brackets a little bit poor but

00:07:17,490 --> 00:07:23,000
surprisingly it's not supported by my

00:07:19,830 --> 00:07:27,600
scale and oh if 20 years is not enough

00:07:23,000 --> 00:07:29,430
so and also you would have some overhead

00:07:27,600 --> 00:07:33,740
for attribute access because you need to

00:07:29,430 --> 00:07:39,000
get the tuple with the data and then

00:07:33,740 --> 00:07:41,190
extract some fuel from the structure

00:07:39,000 --> 00:07:43,860
type but however it could be mitigated

00:07:41,190 --> 00:07:46,110
twist using indexes in the worst case

00:07:43,860 --> 00:07:49,800
for example in sequential scan you'll

00:07:46,110 --> 00:07:53,700
have to evaluate the condition for each

00:07:49,800 --> 00:07:56,970
arrow but for index only scan we'll get

00:07:53,700 --> 00:08:01,950
everything from the index so there are

00:07:56,970 --> 00:08:06,710
some ways to mitigate it and how we can

00:08:01,950 --> 00:08:06,710
implement these two ways communication

00:08:08,240 --> 00:08:16,800
in Django fields provided this couple of

00:08:11,040 --> 00:08:20,190
different methods and we need basically

00:08:16,800 --> 00:08:21,930
two of them from DB value and here we

00:08:20,190 --> 00:08:24,810
need to construct the money instance

00:08:21,930 --> 00:08:29,190
from some DB level string curie

00:08:24,810 --> 00:08:30,840
other object and get prepped value we

00:08:29,190 --> 00:08:35,070
need to construct database level

00:08:30,840 --> 00:08:38,930
instances and a little disclaimer some

00:08:35,070 --> 00:08:42,300
examples are a little bit sloppy because

00:08:38,930 --> 00:08:45,660
there are no like corner cases and maybe

00:08:42,300 --> 00:08:48,720
some error validation but i would like

00:08:45,660 --> 00:08:49,250
to emphasize that it's only like core

00:08:48,720 --> 00:08:51,380
action

00:08:49,250 --> 00:08:55,910
that you need to make and also there are

00:08:51,380 --> 00:08:59,330
many other places to extend these are

00:08:55,910 --> 00:09:03,260
the basic ones sir for the first part

00:08:59,330 --> 00:09:07,780
the summary is designed the interface

00:09:03,260 --> 00:09:09,890
first and use it as a test cases

00:09:07,780 --> 00:09:13,460
discovery or database queries because

00:09:09,890 --> 00:09:17,480
you need to map Python to database you

00:09:13,460 --> 00:09:19,910
need to know both files the site in your

00:09:17,480 --> 00:09:22,880
database support if you really need to

00:09:19,910 --> 00:09:24,470
be database agnostic or maybe you work

00:09:22,880 --> 00:09:29,750
on post guess and you're happy with it

00:09:24,470 --> 00:09:33,620
up to you and one field is simpler than

00:09:29,750 --> 00:09:37,550
multiple fields on on Django level at

00:09:33,620 --> 00:09:41,270
least try structure types for composite

00:09:37,550 --> 00:09:46,580
values school feature okay let's let's

00:09:41,270 --> 00:09:48,470
make some queries basically we can make

00:09:46,580 --> 00:09:51,830
some lookups transforms use some

00:09:48,470 --> 00:09:54,230
expressions like we need to have some

00:09:51,830 --> 00:09:58,339
items that price is greater than 10

00:09:54,230 --> 00:10:01,040
euros or only vanish crowns as a

00:09:58,339 --> 00:10:05,839
currency or maybe only amount more than

00:10:01,040 --> 00:10:09,620
100 or price is equal to some other

00:10:05,839 --> 00:10:12,800
field define your behavior unambiguously

00:10:09,620 --> 00:10:17,120
first of all and expect your database

00:10:12,800 --> 00:10:20,210
queries again so basically these lookups

00:10:17,120 --> 00:10:23,380
and transforms could be could look like

00:10:20,210 --> 00:10:29,660
this on the database level you will need

00:10:23,380 --> 00:10:34,070
this transformation a bit later so I

00:10:29,660 --> 00:10:38,540
believe from Janka 1.8 there is a lookup

00:10:34,070 --> 00:10:41,000
it guy that really really cool thing you

00:10:38,540 --> 00:10:49,450
need to basically define your lookup and

00:10:41,000 --> 00:10:52,240
register it with register look up here

00:10:49,450 --> 00:10:55,180
so basically what you need to do is to

00:10:52,240 --> 00:10:59,650
omit some SQL and some parameters for

00:10:55,180 --> 00:11:01,870
your queries on the database level there

00:10:59,650 --> 00:11:05,290
are a lot of existing lookups that you

00:11:01,870 --> 00:11:11,050
can reuse however was the best thing is

00:11:05,290 --> 00:11:12,310
that you need some SQL as an output so

00:11:11,050 --> 00:11:16,170
you need to construct left side right

00:11:12,310 --> 00:11:18,970
side and parameters for transforms like

00:11:16,170 --> 00:11:22,120
extracting some certain subfields from

00:11:18,970 --> 00:11:26,560
the structure type you can utilize a

00:11:22,120 --> 00:11:30,970
similar thing called transform you need

00:11:26,560 --> 00:11:34,690
to again create some SQL as an output

00:11:30,970 --> 00:11:39,100
and have some output field for amount

00:11:34,690 --> 00:11:43,840
it's the small field and for currency is

00:11:39,100 --> 00:11:47,080
char field basically if you will go this

00:11:43,840 --> 00:11:51,550
way basic expressions should work out of

00:11:47,080 --> 00:11:55,000
the box for example here we have some

00:11:51,550 --> 00:11:58,960
number of items and values and annotate

00:11:55,000 --> 00:12:03,000
works just out of the box maybe some

00:11:58,960 --> 00:12:06,550
order by and some other simple

00:12:03,000 --> 00:12:08,950
expressions but if you need to use

00:12:06,550 --> 00:12:11,320
something more sophisticated with F

00:12:08,950 --> 00:12:13,870
expressions for example you need to

00:12:11,320 --> 00:12:20,440
extend here domain because it's not

00:12:13,870 --> 00:12:23,110
aware of gender at all so here with

00:12:20,440 --> 00:12:25,750
money we have magic methods for addition

00:12:23,110 --> 00:12:31,200
subtraction and so on so we need to add

00:12:25,750 --> 00:12:35,500
a knowledge of expressions from Django

00:12:31,200 --> 00:12:37,750
like it is an example so also you need

00:12:35,500 --> 00:12:41,970
to adapt your lookup implementation

00:12:37,750 --> 00:12:44,440
because it's also not over yet about the

00:12:41,970 --> 00:12:50,260
expressions so you need to handle it as

00:12:44,440 --> 00:12:52,560
well and for structure types you could

00:12:50,260 --> 00:12:57,640
create for example your own expressions

00:12:52,560 --> 00:13:02,500
like sub column or something similar and

00:12:57,640 --> 00:13:06,250
use it like this to make some custom

00:13:02,500 --> 00:13:11,590
curious so create custom expressions if

00:13:06,250 --> 00:13:14,920
needed the summary for the korean part

00:13:11,590 --> 00:13:17,320
is pretty much the same you need to

00:13:14,920 --> 00:13:19,990
define your lookups transforms and

00:13:17,320 --> 00:13:23,980
behavior unambiguously you need to know

00:13:19,990 --> 00:13:28,570
your database queries and map these item

00:13:23,980 --> 00:13:31,000
things to database things you slow

00:13:28,570 --> 00:13:33,520
copyright to build desired queries it's

00:13:31,000 --> 00:13:39,250
really nice - we started the project

00:13:33,520 --> 00:13:43,990
when it was like jungle 1.34 and dragged

00:13:39,250 --> 00:13:47,410
a lot of different hacks to like have

00:13:43,990 --> 00:13:53,110
the same behavior so I really recommend

00:13:47,410 --> 00:13:57,040
to use to copy by instead extent magic

00:13:53,110 --> 00:14:00,400
methods on your domain entities - for AF

00:13:57,040 --> 00:14:02,920
expression support and create custom

00:14:00,400 --> 00:14:10,270
expressions for your structure types if

00:14:02,920 --> 00:14:13,900
you need it ok extras at some point you

00:14:10,270 --> 00:14:16,900
might need to migrate your data so

00:14:13,900 --> 00:14:20,740
immigrations for this case you need to

00:14:16,900 --> 00:14:24,490
first full extent the construct method

00:14:20,740 --> 00:14:28,420
on the class of Fairfield in this case

00:14:24,490 --> 00:14:33,850
you will have your custom options in

00:14:28,420 --> 00:14:36,880
migrations also your domain entities are

00:14:33,850 --> 00:14:39,820
not aware about integrations you could

00:14:36,880 --> 00:14:44,200
use the constructible decorator to add

00:14:39,820 --> 00:14:48,960
this support so if you want to have some

00:14:44,200 --> 00:14:51,990
default value like this you need to wrap

00:14:48,960 --> 00:14:54,570
your domain entities in this decorator

00:14:51,990 --> 00:14:58,600
mmm

00:14:54,570 --> 00:15:02,110
serialization so maybe you would like to

00:14:58,600 --> 00:15:04,510
use fixtures or something like this you

00:15:02,110 --> 00:15:07,150
need to define you you need to have a

00:15:04,510 --> 00:15:09,520
module we use two things a steriliser

00:15:07,150 --> 00:15:12,730
class and this I realize will be

00:15:09,520 --> 00:15:14,360
sterilizer callable and for example this

00:15:12,730 --> 00:15:17,899
implementation whoo

00:15:14,360 --> 00:15:21,619
in Lille from field and for our custom

00:15:17,899 --> 00:15:25,999
structure type we emit a dictionary that

00:15:21,619 --> 00:15:27,610
contains this nested fields and yeah

00:15:25,999 --> 00:15:33,319
here is a result

00:15:27,610 --> 00:15:36,199
nested field okay for deserialization

00:15:33,319 --> 00:15:38,629
support we need to update our get trap

00:15:36,199 --> 00:15:42,559
value because in this case we will have

00:15:38,629 --> 00:15:46,959
a dictionary so update it and it will

00:15:42,559 --> 00:15:51,230
work after it we need to register ours

00:15:46,959 --> 00:15:56,839
sort of serialization module and the

00:15:51,230 --> 00:16:00,049
good place is app config so basically

00:15:56,839 --> 00:16:05,860
you can define fold-up config and in

00:16:00,049 --> 00:16:13,339
this case ready will be fired after well

00:16:05,860 --> 00:16:15,559
in some time when Jango initializes at

00:16:13,339 --> 00:16:17,449
some point you would like to maybe we

00:16:15,559 --> 00:16:22,279
would like to validate your field

00:16:17,449 --> 00:16:24,379
somehow like sets minimum values some

00:16:22,279 --> 00:16:26,959
maximum for different currencies

00:16:24,379 --> 00:16:30,309
something critics and gender price use a

00:16:26,959 --> 00:16:32,959
lot of tools already built like

00:16:30,309 --> 00:16:34,309
validators for a minimum values maximum

00:16:32,959 --> 00:16:39,610
values you need to extend it a little

00:16:34,309 --> 00:16:43,610
bit to work with your domain instances

00:16:39,610 --> 00:16:48,970
in this case we have like different

00:16:43,610 --> 00:16:52,489
boundaries for amount and for certain

00:16:48,970 --> 00:17:00,829
currencies so you can define anything

00:16:52,489 --> 00:17:04,519
you want a bad example of consequences

00:17:00,829 --> 00:17:06,350
of some decisions like having two

00:17:04,519 --> 00:17:09,789
different fields and working through

00:17:06,350 --> 00:17:09,789
decorator through

00:17:13,700 --> 00:17:19,370
the Scriptures right is the years

00:17:17,450 --> 00:17:25,540
because we need to enjoy money we need

00:17:19,370 --> 00:17:28,610
to hook some modules we need to update

00:17:25,540 --> 00:17:32,240
some functions inside and run time it's

00:17:28,610 --> 00:17:36,440
really really hockey and I would not

00:17:32,240 --> 00:17:39,560
recommend to do it ever but it was like

00:17:36,440 --> 00:17:41,540
six years ago we didn't have many

00:17:39,560 --> 00:17:45,260
options like hook up repair and stuff

00:17:41,540 --> 00:17:48,650
like this but for structure types it

00:17:45,260 --> 00:17:53,540
will work out of the box ok so the

00:17:48,650 --> 00:17:55,280
summary for the third part extent

00:17:53,540 --> 00:17:58,600
existing tools from Django there are a

00:17:55,280 --> 00:18:01,370
lot of them really validator serializers

00:17:58,600 --> 00:18:03,490
migrations everything is there what you

00:18:01,370 --> 00:18:06,800
need to extend them in certain points

00:18:03,490 --> 00:18:11,510
this application config Turk is there to

00:18:06,800 --> 00:18:13,940
register your extensions think about

00:18:11,510 --> 00:18:17,600
possible use cases for if you maybe you

00:18:13,940 --> 00:18:22,750
don't need a serialization or something

00:18:17,600 --> 00:18:26,300
like this ok and some refer three talked

00:18:22,750 --> 00:18:29,510
always start with the interface design

00:18:26,300 --> 00:18:31,930
first you need to know what you would

00:18:29,510 --> 00:18:37,780
like what would you expect from your

00:18:31,930 --> 00:18:40,460
custom field and use it for your tests

00:18:37,780 --> 00:18:41,630
explore underlying database queries

00:18:40,460 --> 00:18:43,970
because it's really important because

00:18:41,630 --> 00:18:48,080
you need to map two worlds Python

00:18:43,970 --> 00:18:50,540
databases experiment with your

00:18:48,080 --> 00:18:54,010
implementation choose the most simple

00:18:50,540 --> 00:18:56,210
and unambiguous and try to evaluate

00:18:54,010 --> 00:18:59,600
impossible consequences of chosen

00:18:56,210 --> 00:19:04,930
approach because we have like maybe 70%

00:18:59,600 --> 00:19:04,930
of the code that works only for

00:19:05,200 --> 00:19:12,800
supporting new things like lookup API

00:19:09,920 --> 00:19:16,580
and similar behavior that is in Django

00:19:12,800 --> 00:19:19,580
from some point but we went another way

00:19:16,580 --> 00:19:20,410
and we need to have a lot of hacks for

00:19:19,580 --> 00:19:23,420
it

00:19:20,410 --> 00:19:26,240
so jungle provides you with a lot of

00:19:23,420 --> 00:19:27,440
extendable tools for mapping care the

00:19:26,240 --> 00:19:30,620
main entities

00:19:27,440 --> 00:19:33,700
the database use them it's only half

00:19:30,620 --> 00:19:33,700
thank you very much

00:19:42,610 --> 00:19:47,780
whistles awesome we have about six

00:19:45,830 --> 00:19:52,490
minutes for questions that means we can

00:19:47,780 --> 00:19:55,220
do about three four questions just a

00:19:52,490 --> 00:19:58,490
reminder that you can do it online with

00:19:55,220 --> 00:20:05,230
django con QA a hashtag and the irst

00:19:58,490 --> 00:20:05,230
channel great thought Thanks

00:20:05,350 --> 00:20:12,920
structured types is new to me I'm sorry

00:20:09,620 --> 00:20:17,630
if I missed it but is that what was the

00:20:12,920 --> 00:20:19,490
approach she took for creating a

00:20:17,630 --> 00:20:22,070
structured type via django migration

00:20:19,490 --> 00:20:24,080
once again please creating a structured

00:20:22,070 --> 00:20:26,420
type viroid Ranga migrate yeah yeah it's

00:20:24,080 --> 00:20:30,080
possible or you need to run this skill

00:20:26,420 --> 00:20:33,050
like I had an example create type name

00:20:30,080 --> 00:20:36,410
of the type as some structure it would

00:20:33,050 --> 00:20:39,620
work I say put on run SQL mic yes okay

00:20:36,410 --> 00:20:43,870
so maybe in some newer Django versions

00:20:39,620 --> 00:20:43,870
it could be supported I don't know

00:20:43,960 --> 00:20:51,470
another question about migrations you

00:20:47,360 --> 00:20:54,980
mentioned the the construct that is

00:20:51,470 --> 00:20:57,650
needed for creating the field type but

00:20:54,980 --> 00:21:01,640
did you also need to make special

00:20:57,650 --> 00:21:03,830
migration operations to add specific

00:21:01,640 --> 00:21:07,490
migration operations to support your

00:21:03,830 --> 00:21:08,800
field type and if so how did you go

00:21:07,490 --> 00:21:12,500
about that

00:21:08,800 --> 00:21:18,020
okay basically it depends on the

00:21:12,500 --> 00:21:21,610
database I believe that in Postgres you

00:21:18,020 --> 00:21:24,560
still have alter type stuff like this

00:21:21,610 --> 00:21:26,780
however I'm not sure about the others

00:21:24,560 --> 00:21:29,900
but in general case yes you need to

00:21:26,780 --> 00:21:32,600
define your extension for some alter

00:21:29,900 --> 00:21:38,090
field or something like this basically

00:21:32,600 --> 00:21:43,940
it's probably the most frequent use case

00:21:38,090 --> 00:21:48,850
I believe so yes and and when you define

00:21:43,940 --> 00:21:52,250
this sort of operations then the Django

00:21:48,850 --> 00:21:53,210
autumn migration creator will not use

00:21:52,250 --> 00:21:58,390
them will not deter

00:21:53,210 --> 00:22:01,899
you use it mainly as far as I know maybe

00:21:58,390 --> 00:22:01,899
something changed

00:22:08,539 --> 00:22:15,469
hi hello I didn't know about this that

00:22:12,349 --> 00:22:17,779
you can read is a register custom your

00:22:15,469 --> 00:22:20,239
serialize above Jango do you know if

00:22:17,779 --> 00:22:24,979
it's also picked up by the Django rest

00:22:20,239 --> 00:22:26,989
framework oh I don't know if it's in

00:22:24,979 --> 00:22:29,299
Junger and currently for example in

00:22:26,989 --> 00:22:32,539
Django money we are basically we replace

00:22:29,299 --> 00:22:35,570
ji-sun sterilizer with our own to add

00:22:32,539 --> 00:22:38,809
support so it should be used because

00:22:35,570 --> 00:22:40,849
it's in gender but for Django rest

00:22:38,809 --> 00:22:44,569
framework you probably need a little bit

00:22:40,849 --> 00:22:46,789
more like not regarding sterilization

00:22:44,569 --> 00:22:50,629
but like having support for this type of

00:22:46,789 --> 00:22:58,039
fields in sterilizers for example okay

00:22:50,629 --> 00:23:05,719
thanks any other questions please

00:22:58,039 --> 00:23:08,209
questions online um hi what do you think

00:23:05,719 --> 00:23:11,919
about using adjacent field if you have

00:23:08,209 --> 00:23:15,229
more than like two things to store yes

00:23:11,919 --> 00:23:18,889
jeezum is a bit different however I

00:23:15,229 --> 00:23:22,099
think it could be used there is no

00:23:18,889 --> 00:23:25,219
decimal in Jesus than dirt right some

00:23:22,099 --> 00:23:27,559
leaf floating current so for this exact

00:23:25,219 --> 00:23:29,569
use case I wouldn't recommend to use it

00:23:27,559 --> 00:23:33,019
because of the precision loss by default

00:23:29,569 --> 00:23:38,539
or you can use string maybe and wrap it

00:23:33,019 --> 00:23:42,019
somehow so it could be used yes as an

00:23:38,539 --> 00:23:45,079
option but I don't know about the

00:23:42,019 --> 00:23:48,789
performance issues or stuff like this it

00:23:45,079 --> 00:23:54,069
could be similar most probably

00:23:48,789 --> 00:23:56,959
hey I'm wondering if you can use like

00:23:54,069 --> 00:24:00,399
aggregate functions like sum and average

00:23:56,959 --> 00:24:04,940
and all of that using like the fields

00:24:00,399 --> 00:24:09,169
does it work ah I believe only like

00:24:04,940 --> 00:24:11,299
hound stuff it will work out of the box

00:24:09,169 --> 00:24:15,199
but for every CH you still need to

00:24:11,299 --> 00:24:18,349
extract amount part out of it and in

00:24:15,199 --> 00:24:21,890
plain SQL it will be average of the

00:24:18,349 --> 00:24:26,570
square brackets dot amount for it

00:24:21,890 --> 00:24:28,940
yeah so you need to compile this SQL so

00:24:26,570 --> 00:24:31,789
basically need to extend a little bit

00:24:28,940 --> 00:24:34,390
these aggregates okay time to carry

00:24:31,789 --> 00:24:34,390
support for it

00:24:42,830 --> 00:24:48,120
we have time for about one more question

00:24:44,970 --> 00:24:50,010
isn't it a little bit redundant normally

00:24:48,120 --> 00:24:52,920
you have one row in the database and

00:24:50,010 --> 00:24:56,010
everything isn't the same currency so

00:24:52,920 --> 00:24:58,590
isn't it a bit redundant to always keep

00:24:56,010 --> 00:25:01,140
that and that's another answer to the

00:24:58,590 --> 00:25:03,360
question before if you do aggregates you

00:25:01,140 --> 00:25:05,850
don't want to sum up let's say that is

00:25:03,360 --> 00:25:06,840
Crona and euros together because it

00:25:05,850 --> 00:25:10,770
doesn't make any sense

00:25:06,840 --> 00:25:14,010
it depends on the use case for example I

00:25:10,770 --> 00:25:16,170
usually work with card transactions for

00:25:14,010 --> 00:25:18,420
example for missed payments and we store

00:25:16,170 --> 00:25:23,390
different currencies and we need to

00:25:18,420 --> 00:25:26,850
aggregate by different currency sir I

00:25:23,390 --> 00:25:29,850
would say it more in implementation wise

00:25:26,850 --> 00:25:32,570
because having two fills is a bit more

00:25:29,850 --> 00:25:35,820
complex and here in one field it's

00:25:32,570 --> 00:25:39,570
always an option is a trade-off you have

00:25:35,820 --> 00:25:42,150
little bit of simpler implementation but

00:25:39,570 --> 00:25:45,990
you have like limited database support

00:25:42,150 --> 00:25:48,600
and maybe some performance downgrade so

00:25:45,990 --> 00:25:52,050
it's things to consider for your use

00:25:48,600 --> 00:25:54,330
case it you always need to consider all

00:25:52,050 --> 00:25:57,120
these factors but in some case it could

00:25:54,330 --> 00:25:59,760
help to reduce some complexity from your

00:25:57,120 --> 00:26:03,210
code in some cases not so in your case

00:25:59,760 --> 00:26:05,340
you have sometimes row with a lot of

00:26:03,210 --> 00:26:09,090
different amounts and different

00:26:05,340 --> 00:26:13,410
currencies I would say that we have

00:26:09,090 --> 00:26:15,540
different amounts of the same row yeah

00:26:13,410 --> 00:26:21,000
yeah yes I mean like different monies

00:26:15,540 --> 00:26:24,859
okay yes thank you so much

00:26:21,000 --> 00:26:24,859

YouTube URL: https://www.youtube.com/watch?v=g12fkl9NCrM


