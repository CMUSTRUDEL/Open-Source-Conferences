Title: DjangoCon 2020 | Search Options in Django - Stefan Baerisch
Publication date: 2020-09-30
Playlist: DjangoCon Europe 2020 (Virtual)
Description: 
	DjangoCon Europe 2020 (Virtual)
September 19, 2020 - 12h35 (GMT+1)

"Search Options in Django" by Stefan Baerisch

I like websites with search bars. If the search function works well, I can enter a few words and get a list of results, with the things that interest me at the top. Whether you use it as a help system or for product information, search functionality can add a lot of value to a Django application. But implementing proper search functionality is not easy. Django offers multiple ways to implement search functionality, each with its advantages and disadvantages. This talk will give you an overview of the different ways in which you can implement search functionality in Django. We will look at the full-text search options that come with databases and the use of a dedicated search engine like Elastic Search or Postgres. Along the way, you will learn about the different ways in which you can index your data to learn how to evaluate your search results.
Captions: 
	00:00:20,880 --> 00:00:24,480
okay

00:00:22,080 --> 00:00:26,720
hello everyone welcome from munich i

00:00:24,480 --> 00:00:29,359
hope you're well wherever you are

00:00:26,720 --> 00:00:32,399
and yeah thank you for joining the talk

00:00:29,359 --> 00:00:34,559
on search options in django

00:00:32,399 --> 00:00:36,399
in the next well half hour so we'll just

00:00:34,559 --> 00:00:39,040
have a short overview about

00:00:36,399 --> 00:00:40,000
different ways you can implement voltex

00:00:39,040 --> 00:00:43,360
search

00:00:40,000 --> 00:00:46,640
with django in django and we will also

00:00:43,360 --> 00:00:49,280
well look at some well some background

00:00:46,640 --> 00:00:52,800
why you would want to do it

00:00:49,280 --> 00:00:54,559
so yeah just shortly about me

00:00:52,800 --> 00:00:56,559
so i'm basically a software engineer by

00:00:54,559 --> 00:00:58,640
trade that unless

00:00:56,559 --> 00:01:00,559
well some project management on the side

00:00:58,640 --> 00:01:03,359
for the last couple of years

00:01:00,559 --> 00:01:05,280
and i started out in search then did

00:01:03,359 --> 00:01:07,520
some data processing in

00:01:05,280 --> 00:01:10,080
python and then slowly worked myself to

00:01:07,520 --> 00:01:10,080
watch anger

00:01:10,400 --> 00:01:15,040
yes well first of all some background on

00:01:12,479 --> 00:01:16,400
full text search

00:01:15,040 --> 00:01:18,640
many of the things that i'm saying might

00:01:16,400 --> 00:01:20,479
be obvious but i think it's

00:01:18,640 --> 00:01:22,159
just interesting to repeat it so why do

00:01:20,479 --> 00:01:26,000
we want to search

00:01:22,159 --> 00:01:28,320
and not query well we still have a lot

00:01:26,000 --> 00:01:30,960
of video in our lives this talk is

00:01:28,320 --> 00:01:31,759
like an example but there's also a lot

00:01:30,960 --> 00:01:35,680
of text

00:01:31,759 --> 00:01:37,520
and if we search within text we well

00:01:35,680 --> 00:01:39,520
we have to take many things into account

00:01:37,520 --> 00:01:41,280
we might have typos we might use

00:01:39,520 --> 00:01:42,640
different languages

00:01:41,280 --> 00:01:45,439
different documents are written in

00:01:42,640 --> 00:01:45,759
different ways some shorter some longer

00:01:45,439 --> 00:01:48,320
some

00:01:45,759 --> 00:01:50,159
just a more formal language some are

00:01:48,320 --> 00:01:51,040
quite controlled in terms of what they

00:01:50,159 --> 00:01:53,360
are

00:01:51,040 --> 00:01:54,560
a tweet is very different from a book

00:01:53,360 --> 00:01:57,600
and when we want

00:01:54,560 --> 00:01:58,640
to search for either tweet or book we

00:01:57,600 --> 00:02:01,280
expect that we get

00:01:58,640 --> 00:02:03,119
good results document with hopefully a

00:02:01,280 --> 00:02:04,640
reasonable query but we don't really

00:02:03,119 --> 00:02:06,840
want to

00:02:04,640 --> 00:02:08,080
spend too much thoughts and too much

00:02:06,840 --> 00:02:10,479
time

00:02:08,080 --> 00:02:12,720
on the best way to do the query that's

00:02:10,479 --> 00:02:15,840
the difference from databases

00:02:12,720 --> 00:02:17,360
so if you do database query for any row

00:02:15,840 --> 00:02:19,920
for any entry

00:02:17,360 --> 00:02:20,480
you usually need to know exactly what

00:02:19,920 --> 00:02:22,480
you want

00:02:20,480 --> 00:02:24,239
so in the simplest case you could do a

00:02:22,480 --> 00:02:27,680
query by an object id

00:02:24,239 --> 00:02:31,280
or you know that a certain text part is

00:02:27,680 --> 00:02:32,000
within the document or you basically

00:02:31,280 --> 00:02:35,680
just

00:02:32,000 --> 00:02:37,519
narrow it down with searching by date by

00:02:35,680 --> 00:02:39,920
name of an author if it is a document

00:02:37,519 --> 00:02:41,920
etc but whatever you do you need to know

00:02:39,920 --> 00:02:43,200
exactly what you want and the database

00:02:41,920 --> 00:02:45,920
system will

00:02:43,200 --> 00:02:46,560
give you exactly what you ask for so if

00:02:45,920 --> 00:02:49,040
you

00:02:46,560 --> 00:02:50,640
are slightly wrong or if there is a

00:02:49,040 --> 00:02:52,879
document that is

00:02:50,640 --> 00:02:54,720
uses a different writing form of a word

00:02:52,879 --> 00:02:56,959
or if you have a typo

00:02:54,720 --> 00:02:58,400
a usual sql query will not help you very

00:02:56,959 --> 00:03:02,000
much

00:02:58,400 --> 00:03:05,120
search is less precise more fuzzy

00:03:02,000 --> 00:03:08,400
and you could also say more in a way

00:03:05,120 --> 00:03:11,519
humane so it tries to

00:03:08,400 --> 00:03:15,040
almost guess what you meant

00:03:11,519 --> 00:03:15,440
by a certain query and then also tries

00:03:15,040 --> 00:03:17,760
to

00:03:15,440 --> 00:03:18,560
give you the most relevant documents

00:03:17,760 --> 00:03:21,680
first so

00:03:18,560 --> 00:03:24,879
you can imagine if you do a

00:03:21,680 --> 00:03:26,640
search in a locked set of documents

00:03:24,879 --> 00:03:28,640
and search for common words that you

00:03:26,640 --> 00:03:31,680
will have many many results and

00:03:28,640 --> 00:03:32,080
you don't usually want to check let's

00:03:31,680 --> 00:03:34,879
say

00:03:32,080 --> 00:03:37,920
200 300 documents before you finally

00:03:34,879 --> 00:03:41,040
find the ones at your mo

00:03:37,920 --> 00:03:43,599
yes so to summarize a database query is

00:03:41,040 --> 00:03:44,400
give me what i want what i set and

00:03:43,599 --> 00:03:46,319
search

00:03:44,400 --> 00:03:48,239
hopefully if it works is give me what i

00:03:46,319 --> 00:03:50,879
mean even though i haven't

00:03:48,239 --> 00:03:50,879
really said it

00:03:52,480 --> 00:03:56,480
what can this mean so let's take an

00:03:55,760 --> 00:03:58,959
example and

00:03:56,480 --> 00:04:01,519
hopefully somebody in the future will

00:03:58,959 --> 00:04:04,080
search for maybe this talk

00:04:01,519 --> 00:04:05,680
and this person may look for my name

00:04:04,080 --> 00:04:09,519
eric

00:04:05,680 --> 00:04:12,159
for python and 2020.

00:04:09,519 --> 00:04:13,599
and well they may actually write my name

00:04:12,159 --> 00:04:17,120
as it's written in german which

00:04:13,599 --> 00:04:20,479
is not sing and they may

00:04:17,120 --> 00:04:22,720
misspell python and well if they empty

00:04:20,479 --> 00:04:24,479
2020 they don't necessarily say that

00:04:22,720 --> 00:04:28,320
they want to search for the date

00:04:24,479 --> 00:04:30,720
2020 so there is no 2020

00:04:28,320 --> 00:04:32,400
in the title of the story of this talk

00:04:30,720 --> 00:04:34,880
for example

00:04:32,400 --> 00:04:35,840
and now a search system give me what i

00:04:34,880 --> 00:04:38,960
mean

00:04:35,840 --> 00:04:41,280
would do some rewriting so it would know

00:04:38,960 --> 00:04:42,000
that german umlauts are not necessarily

00:04:41,280 --> 00:04:44,000
the way

00:04:42,000 --> 00:04:45,040
that the term that german words are

00:04:44,000 --> 00:04:48,720
always written

00:04:45,040 --> 00:04:50,720
so it might rewrite it to this ia form

00:04:48,720 --> 00:04:52,320
and hopefully it would also catch up

00:04:50,720 --> 00:04:54,800
that prison

00:04:52,320 --> 00:04:56,320
is not the right writing for python and

00:04:54,800 --> 00:04:58,720
might rewrite it into

00:04:56,320 --> 00:05:01,280
python because well that is a common

00:04:58,720 --> 00:05:03,759
word a relatively common term

00:05:01,280 --> 00:05:04,800
whereas the misspelled form is not he

00:05:03,759 --> 00:05:08,639
might also

00:05:04,800 --> 00:05:10,080
know that certain numbers 19 something

00:05:08,639 --> 00:05:13,520
20 something

00:05:10,080 --> 00:05:15,759
are very likely yes so it may not

00:05:13,520 --> 00:05:18,320
search for example in the title or in

00:05:15,759 --> 00:05:22,400
the description but in the metadata

00:05:18,320 --> 00:05:26,320
and see okay i know that this is a

00:05:22,400 --> 00:05:28,240
20. so it will take the query

00:05:26,320 --> 00:05:30,160
what i entered and rewrite it into

00:05:28,240 --> 00:05:32,639
something that represents what i mean

00:05:30,160 --> 00:05:34,400
and in order for this to work of course

00:05:32,639 --> 00:05:36,479
it would need to do the same thing

00:05:34,400 --> 00:05:38,960
with all the documents that it gets so

00:05:36,479 --> 00:05:42,080
it would need to both query processing

00:05:38,960 --> 00:05:43,520
and document processing this is quite

00:05:42,080 --> 00:05:45,759
different from a database

00:05:43,520 --> 00:05:46,960
where we need to index our data but we

00:05:45,759 --> 00:05:48,720
don't really change

00:05:46,960 --> 00:05:51,280
or touch the content of neither the

00:05:48,720 --> 00:05:54,320
query nor the document

00:05:51,280 --> 00:05:57,280
yeah and finally we

00:05:54,320 --> 00:05:58,319
also want if we want our documents back

00:05:57,280 --> 00:06:01,199
we also

00:05:58,319 --> 00:06:01,919
want to have the most relevant documents

00:06:01,199 --> 00:06:05,199
at the top

00:06:01,919 --> 00:06:07,039
i already said that but it's it's worth

00:06:05,199 --> 00:06:10,319
getting into because that's the thing

00:06:07,039 --> 00:06:13,039
where search can get quite complicated

00:06:10,319 --> 00:06:14,720
because relevant is something that i as

00:06:13,039 --> 00:06:17,120
a user every user

00:06:14,720 --> 00:06:19,039
would need to decide for themselves so

00:06:17,120 --> 00:06:20,800
for example if i search for something in

00:06:19,039 --> 00:06:22,639
the

00:06:20,800 --> 00:06:23,840
description of some product if i do

00:06:22,639 --> 00:06:25,680
online shopping

00:06:23,840 --> 00:06:27,280
a relevant product might be something

00:06:25,680 --> 00:06:29,280
totally different

00:06:27,280 --> 00:06:31,039
or when it may need a different

00:06:29,280 --> 00:06:32,400
implementation different query and

00:06:31,039 --> 00:06:34,960
document processing

00:06:32,400 --> 00:06:36,880
than if i was searching for a book or if

00:06:34,960 --> 00:06:38,560
i was searching for a tweet a tweet

00:06:36,880 --> 00:06:40,800
might be relevant if it was

00:06:38,560 --> 00:06:42,479
made in the last say 24 hours and

00:06:40,800 --> 00:06:45,039
include my words

00:06:42,479 --> 00:06:46,960
a book may be written in 1900 and still

00:06:45,039 --> 00:06:50,080
be relevant if it

00:06:46,960 --> 00:06:52,160
has a concept that my words allude to

00:06:50,080 --> 00:06:53,520
and well in a product database if you

00:06:52,160 --> 00:06:56,080
implement something like this with

00:06:53,520 --> 00:06:59,199
django or it could be an article

00:06:56,080 --> 00:07:00,800
database just a content management

00:06:59,199 --> 00:07:02,880
system for example

00:07:00,800 --> 00:07:04,000
you would need to decide what's relevant

00:07:02,880 --> 00:07:05,919
for my users or

00:07:04,000 --> 00:07:07,840
what's relevant for me maybe i want to

00:07:05,919 --> 00:07:08,960
show them products or articles that i

00:07:07,840 --> 00:07:11,599
think are

00:07:08,960 --> 00:07:13,120
especially important for me for whatever

00:07:11,599 --> 00:07:16,240
reason

00:07:13,120 --> 00:07:16,960
so i would need to do quite a lot of

00:07:16,240 --> 00:07:18,880
work to

00:07:16,960 --> 00:07:20,400
implement some kind of relevant system

00:07:18,880 --> 00:07:24,160
that really fits me

00:07:20,400 --> 00:07:25,759
fits the use case that i want to serve

00:07:24,160 --> 00:07:27,520
and these are all things that i can keep

00:07:25,759 --> 00:07:29,199
in mind together

00:07:27,520 --> 00:07:30,800
with everything else that goes into an

00:07:29,199 --> 00:07:33,599
i.t system like a jumping

00:07:30,800 --> 00:07:34,560
application as a user i want the system

00:07:33,599 --> 00:07:36,639
to work

00:07:34,560 --> 00:07:38,560
well basically all the time so i don't

00:07:36,639 --> 00:07:41,440
want any down times i want a

00:07:38,560 --> 00:07:43,280
fresh index so if new documents are edit

00:07:41,440 --> 00:07:45,919
i want to be able to search for them

00:07:43,280 --> 00:07:48,720
i want quick results because even with a

00:07:45,919 --> 00:07:51,840
good search system i will likely have to

00:07:48,720 --> 00:07:54,400
try different ways to search a system

00:07:51,840 --> 00:07:56,080
different keywords different terms and

00:07:54,400 --> 00:07:57,680
as an operator of the system

00:07:56,080 --> 00:07:59,520
of course i want something that is

00:07:57,680 --> 00:08:02,479
maintainable so

00:07:59,520 --> 00:08:03,440
some piece of infrastructure that will

00:08:02,479 --> 00:08:05,919
still be around

00:08:03,440 --> 00:08:06,960
in let's say three years time it has a

00:08:05,919 --> 00:08:10,400
stable api

00:08:06,960 --> 00:08:12,479
got documentation it's not too resource

00:08:10,400 --> 00:08:14,160
resource intensive to run it's not too

00:08:12,479 --> 00:08:16,240
hard to learn

00:08:14,160 --> 00:08:18,319
and all these things go into a search

00:08:16,240 --> 00:08:20,800
system so i need to

00:08:18,319 --> 00:08:23,120
know about what will my user search for

00:08:20,800 --> 00:08:25,039
what do my documents look like

00:08:23,120 --> 00:08:28,000
what's relevant for them and also how

00:08:25,039 --> 00:08:30,560
can i actually implement this in it

00:08:28,000 --> 00:08:31,039
and what we're going to do is just look

00:08:30,560 --> 00:08:33,599
at

00:08:31,039 --> 00:08:35,200
two possible ways to have search with

00:08:33,599 --> 00:08:38,080
django

00:08:35,200 --> 00:08:40,399
and one particularly set of documents

00:08:38,080 --> 00:08:44,959
what we are searching for

00:08:40,399 --> 00:08:50,320
and what i came up with is um an old

00:08:44,959 --> 00:08:51,680
set of documents originally from 2013

00:08:50,320 --> 00:08:53,920
you can see

00:08:51,680 --> 00:08:55,360
a citation for the uh for some

00:08:53,920 --> 00:08:57,839
scientific article

00:08:55,360 --> 00:08:58,480
down there on the slide and what these

00:08:57,839 --> 00:09:01,760
um

00:08:58,480 --> 00:09:04,080
people did is just gather some film

00:09:01,760 --> 00:09:07,920
reviews from amazon

00:09:04,080 --> 00:09:08,640
8 million in total and brought them into

00:09:07,920 --> 00:09:12,480
um

00:09:08,640 --> 00:09:15,279
well how well less structured format

00:09:12,480 --> 00:09:16,320
this is quite an interesting data set

00:09:15,279 --> 00:09:18,320
for search

00:09:16,320 --> 00:09:20,240
because as you can imagine some people

00:09:18,320 --> 00:09:22,160
write short reviews some people write

00:09:20,240 --> 00:09:24,160
long reviews some people

00:09:22,160 --> 00:09:25,519
take a lot of care to have good spelling

00:09:24,160 --> 00:09:28,640
and grammar others

00:09:25,519 --> 00:09:29,760
less so so you might encounter something

00:09:28,640 --> 00:09:31,440
where

00:09:29,760 --> 00:09:34,000
there's almost a little essay while

00:09:31,440 --> 00:09:36,080
citizen kane is the best movie ever made

00:09:34,000 --> 00:09:37,920
while the next review is just didn't

00:09:36,080 --> 00:09:40,240
like it

00:09:37,920 --> 00:09:40,959
and yeah you can search for that on

00:09:40,240 --> 00:09:42,560
summary

00:09:40,959 --> 00:09:44,080
and on text so you have this little

00:09:42,560 --> 00:09:45,200
title and you have a longer text

00:09:44,080 --> 00:09:48,320
underneath

00:09:45,200 --> 00:09:50,560
and extra information that

00:09:48,320 --> 00:09:52,800
can be helpful so for example you have a

00:09:50,560 --> 00:09:55,839
helpfulness score in there

00:09:52,800 --> 00:09:58,320
that is a judgment of other users how

00:09:55,839 --> 00:10:00,160
helpful this particular review is we

00:09:58,320 --> 00:10:01,760
will not use this in this talk

00:10:00,160 --> 00:10:03,440
but this for example would be something

00:10:01,760 --> 00:10:04,480
that could be quite useful if you did

00:10:03,440 --> 00:10:07,760
ranking

00:10:04,480 --> 00:10:11,040
on this document set so you wanted to

00:10:07,760 --> 00:10:12,880
surface the high usefulness we've used

00:10:11,040 --> 00:10:14,320
first

00:10:12,880 --> 00:10:16,959
so that's what we are going to use for

00:10:14,320 --> 00:10:21,279
this example on the right side you see a

00:10:16,959 --> 00:10:24,800
very simple django database model

00:10:21,279 --> 00:10:27,279
that actually represents it that we are

00:10:24,800 --> 00:10:28,320
almost exclusively interested in the two

00:10:27,279 --> 00:10:31,519
text fields

00:10:28,320 --> 00:10:33,040
so the summary and the text but if we

00:10:31,519 --> 00:10:35,600
wanted we could also

00:10:33,040 --> 00:10:36,640
well play around with the user ids and

00:10:35,600 --> 00:10:39,680
other things

00:10:36,640 --> 00:10:43,120
we'll see how this works later

00:10:39,680 --> 00:10:44,720
okay now let's imagine we are in this

00:10:43,120 --> 00:10:47,200
situation we want to

00:10:44,720 --> 00:10:49,680
look at rather old movie reviews from

00:10:47,200 --> 00:10:52,000
amazon and we build a website

00:10:49,680 --> 00:10:53,680
and at the beginning we want to keep

00:10:52,000 --> 00:10:56,000
things quite simple

00:10:53,680 --> 00:10:58,560
so we already know we have all the data

00:10:56,000 --> 00:11:02,320
that we might need in our database

00:10:58,560 --> 00:11:03,760
and we already know sql and what we just

00:11:02,320 --> 00:11:06,959
do is

00:11:03,760 --> 00:11:10,000
we just use the i contains operator

00:11:06,959 --> 00:11:12,720
so case incentive contains

00:11:10,000 --> 00:11:14,160
and we look for just one word i'm

00:11:12,720 --> 00:11:16,880
interested about

00:11:14,160 --> 00:11:19,680
movie reviews about water maybe i'm a

00:11:16,880 --> 00:11:23,360
fan of the film water world i don't know

00:11:19,680 --> 00:11:25,760
and i see what i get and

00:11:23,360 --> 00:11:27,680
well it's basically what we would expect

00:11:25,760 --> 00:11:31,519
get some titles

00:11:27,680 --> 00:11:34,000
we get a snippet of the actual text

00:11:31,519 --> 00:11:35,839
and you can see here's just of interest

00:11:34,000 --> 00:11:39,120
we see that we've got about 2

00:11:35,839 --> 00:11:40,480
200 documents and it took slightly less

00:11:39,120 --> 00:11:42,560
than a second to give us

00:11:40,480 --> 00:11:44,000
all these documents i think are indexed

00:11:42,560 --> 00:11:46,320
with i think

00:11:44,000 --> 00:11:48,959
one million documents for this use case

00:11:46,320 --> 00:11:51,680
so i didn't use the um

00:11:48,959 --> 00:11:52,959
whole document in the mc or number of

00:11:51,680 --> 00:11:55,760
documents

00:11:52,959 --> 00:11:57,920
okay that's basically what we expect

00:11:55,760 --> 00:12:00,320
that's sql

00:11:57,920 --> 00:12:02,079
now we have heard about full text search

00:12:00,320 --> 00:12:03,920
and we wonder whether we can already use

00:12:02,079 --> 00:12:05,040
full text search just if we have django

00:12:03,920 --> 00:12:08,639
and postgres

00:12:05,040 --> 00:12:12,320
good news is we can and we can

00:12:08,639 --> 00:12:14,959
in essence just switch it over we

00:12:12,320 --> 00:12:15,920
instead of ike of our i contains we

00:12:14,959 --> 00:12:18,000
search

00:12:15,920 --> 00:12:20,480
and this already together with some

00:12:18,000 --> 00:12:24,480
postgres extensions for django

00:12:20,480 --> 00:12:26,399
transforms this into the well full text

00:12:24,480 --> 00:12:30,560
search functionality that postgres

00:12:26,399 --> 00:12:33,839
provides and again we get some

00:12:30,560 --> 00:12:34,720
um documents and the first thing that we

00:12:33,839 --> 00:12:36,720
see

00:12:34,720 --> 00:12:37,760
if we go for this extremely simple

00:12:36,720 --> 00:12:39,839
approach is that

00:12:37,760 --> 00:12:41,360
first of all we get less documents

00:12:39,839 --> 00:12:42,240
that's interesting we are searching for

00:12:41,360 --> 00:12:44,720
the same

00:12:42,240 --> 00:12:45,680
term the same number of documents what

00:12:44,720 --> 00:12:48,320
could happen well

00:12:45,680 --> 00:12:49,760
our eye contains usually found are also

00:12:48,320 --> 00:12:52,399
documents where what

00:12:49,760 --> 00:12:53,839
was for some reason or other part of a

00:12:52,399 --> 00:12:57,680
word

00:12:53,839 --> 00:13:00,160
so watery would also have been found

00:12:57,680 --> 00:13:01,839
versus here we just search for water so

00:13:00,160 --> 00:13:04,959
just for the term

00:13:01,839 --> 00:13:06,639
and we also we only find water because

00:13:04,959 --> 00:13:08,480
with these functions functions we

00:13:06,639 --> 00:13:09,600
already do some pre-progressing and

00:13:08,480 --> 00:13:13,519
processing

00:13:09,600 --> 00:13:17,360
on the documents so in a sense

00:13:13,519 --> 00:13:20,079
it is a better way to search for

00:13:17,360 --> 00:13:20,800
normal users because there will be less

00:13:20,079 --> 00:13:23,200
surprises

00:13:20,800 --> 00:13:24,639
every document that we have found has

00:13:23,200 --> 00:13:27,440
water in it

00:13:24,639 --> 00:13:28,160
on the nest positive side if we look at

00:13:27,440 --> 00:13:30,480
these

00:13:28,160 --> 00:13:31,920
it is actually not clear why we got

00:13:30,480 --> 00:13:34,079
these documents

00:13:31,920 --> 00:13:35,600
so it's quite possible that there is a

00:13:34,079 --> 00:13:37,519
water somewhere in it

00:13:35,600 --> 00:13:38,800
but it's not obvious why did we get

00:13:37,519 --> 00:13:42,079
these documents

00:13:38,800 --> 00:13:44,800
also it got quite a bit slower

00:13:42,079 --> 00:13:47,760
so it now almost takes 10 seconds too

00:13:44,800 --> 00:13:49,519
fast to leave this results

00:13:47,760 --> 00:13:53,279
and this happens because we have to do

00:13:49,519 --> 00:13:55,360
this processing of the documents

00:13:53,279 --> 00:13:57,040
time so we don't really untouch the

00:13:55,360 --> 00:13:59,279
index when we do that

00:13:57,040 --> 00:14:02,000
but we well have to look at every

00:13:59,279 --> 00:14:04,639
document and do some processing

00:14:02,000 --> 00:14:05,279
let's address both of these issues so

00:14:04,639 --> 00:14:07,120
first

00:14:05,279 --> 00:14:08,880
why do we get these documents can we do

00:14:07,120 --> 00:14:12,560
that better

00:14:08,880 --> 00:14:15,680
and we can so we can start with a very

00:14:12,560 --> 00:14:16,959
simple approach to relevance and we can

00:14:15,680 --> 00:14:19,519
say okay

00:14:16,959 --> 00:14:21,600
the documents that i'm interested in

00:14:19,519 --> 00:14:24,880
should contain water

00:14:21,600 --> 00:14:28,639
in either the review or the summary

00:14:24,880 --> 00:14:30,000
and i think if say if the word water

00:14:28,639 --> 00:14:33,040
appears in this summary

00:14:30,000 --> 00:14:35,279
so in the title the document is

00:14:33,040 --> 00:14:36,800
likely more about water than it is

00:14:35,279 --> 00:14:40,160
somewhere in the summary

00:14:36,800 --> 00:14:42,720
so my relevance model says

00:14:40,160 --> 00:14:44,000
look at these fields build a vector

00:14:42,720 --> 00:14:46,480
representation which

00:14:44,000 --> 00:14:48,000
is basically a full text search

00:14:46,480 --> 00:14:50,720
representation

00:14:48,000 --> 00:14:52,320
of these two fields and weight the

00:14:50,720 --> 00:14:55,680
summary title field

00:14:52,320 --> 00:14:59,040
with priority a the highest

00:14:55,680 --> 00:15:01,279
and the full text slightly lower

00:14:59,040 --> 00:15:03,199
and also it happens explicitly if we

00:15:01,279 --> 00:15:05,680
don't say it but we can say it here

00:15:03,199 --> 00:15:07,680
consider the all these texts english so

00:15:05,680 --> 00:15:10,480
both the query processing

00:15:07,680 --> 00:15:12,560
and the document processing will work

00:15:10,480 --> 00:15:15,920
with english words

00:15:12,560 --> 00:15:19,120
also please rank these documents

00:15:15,920 --> 00:15:22,320
according to these weights and

00:15:19,120 --> 00:15:26,240
also only give me documents that are

00:15:22,320 --> 00:15:28,320
highly likely to be relevant so we move

00:15:26,240 --> 00:15:32,079
everything from the query set

00:15:28,320 --> 00:15:33,920
that may have water somewhere but

00:15:32,079 --> 00:15:35,519
where it doesn't seem to be too

00:15:33,920 --> 00:15:38,399
important

00:15:35,519 --> 00:15:40,160
okay what happens now we got few less

00:15:38,399 --> 00:15:42,000
documents that's to be expected

00:15:40,160 --> 00:15:44,399
we told the system that we were only

00:15:42,000 --> 00:15:47,759
interested in the most relevant ones

00:15:44,399 --> 00:15:50,639
and also now it seems yes we have

00:15:47,759 --> 00:15:51,600
water and if you look at it closely you

00:15:50,639 --> 00:15:54,079
see that

00:15:51,600 --> 00:15:54,800
each of our top three hits here has

00:15:54,079 --> 00:15:58,399
water

00:15:54,800 --> 00:16:00,880
twice in the title

00:15:58,399 --> 00:16:02,800
that happens if you say okay i

00:16:00,880 --> 00:16:05,759
prioritize the title highly

00:16:02,800 --> 00:16:06,720
and if our relevance module is counting

00:16:05,759 --> 00:16:09,360
words

00:16:06,720 --> 00:16:10,560
so the more often the words that we

00:16:09,360 --> 00:16:12,480
search for

00:16:10,560 --> 00:16:13,920
is in the text and the shorter the text

00:16:12,480 --> 00:16:16,560
is the more likely

00:16:13,920 --> 00:16:18,079
the document is about this particularly

00:16:16,560 --> 00:16:21,279
word

00:16:18,079 --> 00:16:23,040
that's not the most sophisticated

00:16:21,279 --> 00:16:24,880
approach to ranking

00:16:23,040 --> 00:16:26,320
but at least we understand why we got

00:16:24,880 --> 00:16:29,519
the documents and

00:16:26,320 --> 00:16:31,680
well it is doubtlessly about water

00:16:29,519 --> 00:16:33,199
negative things though we are still

00:16:31,680 --> 00:16:37,519
there with our

00:16:33,199 --> 00:16:40,639
10 second gravity time okay

00:16:37,519 --> 00:16:43,600
let's look at something else we can

00:16:40,639 --> 00:16:44,240
add in additional index full text search

00:16:43,600 --> 00:16:47,040
index

00:16:44,240 --> 00:16:47,839
to our postgas database and this will

00:16:47,040 --> 00:16:51,600
speed up

00:16:47,839 --> 00:16:52,320
our queries so we all have our regular

00:16:51,600 --> 00:16:54,639
data set

00:16:52,320 --> 00:16:55,600
with our model and we now add a new

00:16:54,639 --> 00:16:56,959
index

00:16:55,600 --> 00:16:59,360
to keep our full text search

00:16:56,959 --> 00:17:01,680
implementation so we can hopefully get

00:16:59,360 --> 00:17:01,680
far

00:17:02,560 --> 00:17:06,240
if we do that we'll have to do slight

00:17:04,720 --> 00:17:09,839
change to our data model

00:17:06,240 --> 00:17:10,720
so we add this new index and in order to

00:17:09,839 --> 00:17:14,240
keep the

00:17:10,720 --> 00:17:18,000
model updated we also make a change to

00:17:14,240 --> 00:17:21,199
our database migration and

00:17:18,000 --> 00:17:22,880
we add an extra trigger so in essence

00:17:21,199 --> 00:17:26,000
what we do is every time

00:17:22,880 --> 00:17:27,520
that the document gets that the new

00:17:26,000 --> 00:17:31,120
documents get added or

00:17:27,520 --> 00:17:34,160
changed we will run this trigger

00:17:31,120 --> 00:17:35,120
this trigger uses the internal postspace

00:17:34,160 --> 00:17:38,240
options

00:17:35,120 --> 00:17:41,440
and builds one new index field

00:17:38,240 --> 00:17:46,000
that this time combines the summary

00:17:41,440 --> 00:17:47,760
and the review text well

00:17:46,000 --> 00:17:49,840
to reverse this migration we would drop

00:17:47,760 --> 00:17:51,919
the trigger again

00:17:49,840 --> 00:17:53,120
okay that's nice so we add our new

00:17:51,919 --> 00:17:55,760
documents

00:17:53,120 --> 00:17:56,720
we do almost the same as we did the last

00:17:55,760 --> 00:18:00,080
time

00:17:56,720 --> 00:18:03,200
with one relevant change

00:18:00,080 --> 00:18:05,440
so what we do is this time we church

00:18:03,200 --> 00:18:07,520
only in the index we defined only one

00:18:05,440 --> 00:18:09,440
we could have divided multiple indices

00:18:07,520 --> 00:18:11,200
and

00:18:09,440 --> 00:18:12,559
gave them different priorities but to

00:18:11,200 --> 00:18:13,679
keep it simple we just have this

00:18:12,559 --> 00:18:15,840
document

00:18:13,679 --> 00:18:17,360
and since we have a different relevance

00:18:15,840 --> 00:18:19,919
model we also

00:18:17,360 --> 00:18:20,720
change the cutoff point so this time we

00:18:19,919 --> 00:18:24,400
are

00:18:20,720 --> 00:18:27,760
taking more different documents and

00:18:24,400 --> 00:18:28,480
what happens so things get significantly

00:18:27,760 --> 00:18:30,400
faster

00:18:28,480 --> 00:18:33,440
even faster than the initial scan when

00:18:30,400 --> 00:18:35,600
we did just the sql contains

00:18:33,440 --> 00:18:39,120
but since we have this time only one

00:18:35,600 --> 00:18:39,120
index our ranking model

00:18:39,440 --> 00:18:44,000
we don't no longer have our search term

00:18:41,440 --> 00:18:47,520
title in the

00:18:44,000 --> 00:18:49,440
water in the title but if we look we can

00:18:47,520 --> 00:18:52,720
see it in the text so it's quite quickly

00:18:49,440 --> 00:18:56,080
in the text but no longer in the title

00:18:52,720 --> 00:18:57,600
okay so looking back this is all more or

00:18:56,080 --> 00:19:00,480
less built in

00:18:57,600 --> 00:19:02,080
we don't need much code to have a simple

00:19:00,480 --> 00:19:04,320
search model

00:19:02,080 --> 00:19:04,320
with

00:19:05,679 --> 00:19:09,520
more or less manual migration okay to

00:19:07,840 --> 00:19:11,440
make a performance we have to define

00:19:09,520 --> 00:19:14,559
some extra inlet sales

00:19:11,440 --> 00:19:17,200
but we can have a reasonable search

00:19:14,559 --> 00:19:19,120
or at least a search where we know what

00:19:17,200 --> 00:19:21,200
happens

00:19:19,120 --> 00:19:23,120
now if things get slightly more

00:19:21,200 --> 00:19:27,120
complicated

00:19:23,120 --> 00:19:31,600
you may need to look into something else

00:19:27,120 --> 00:19:35,120
and this could be elasticsearch

00:19:31,600 --> 00:19:35,679
elasticsearch properly thinks that most

00:19:35,120 --> 00:19:39,760
of you

00:19:35,679 --> 00:19:42,160
know it in one form or another is a

00:19:39,760 --> 00:19:44,000
commercial and open source search

00:19:42,160 --> 00:19:46,559
application

00:19:44,000 --> 00:19:47,039
in a way it is the commercial version of

00:19:46,559 --> 00:19:49,760
solar

00:19:47,039 --> 00:19:51,840
it does more than solar solar you may

00:19:49,760 --> 00:19:52,160
know is a search server based on lucene

00:19:51,840 --> 00:19:54,799
which

00:19:52,160 --> 00:19:56,480
in part is an open source apache java

00:19:54,799 --> 00:20:00,480
library

00:19:56,480 --> 00:20:03,679
and it has many many many features

00:20:00,480 --> 00:20:05,919
so for example if you wanted to

00:20:03,679 --> 00:20:07,840
learn from previous queries which

00:20:05,919 --> 00:20:10,960
documents are the most

00:20:07,840 --> 00:20:11,140
relevant for your users so if you wanted

00:20:10,960 --> 00:20:12,720
to

00:20:11,140 --> 00:20:15,200
[Music]

00:20:12,720 --> 00:20:16,159
use deep learning technologies for

00:20:15,200 --> 00:20:17,840
ranking you could

00:20:16,159 --> 00:20:20,960
do this with elasticsearch and some

00:20:17,840 --> 00:20:23,440
additional things if you wanted to say

00:20:20,960 --> 00:20:26,960
give me a ranking function that will use

00:20:23,440 --> 00:20:30,080
review usefulness you could do that

00:20:26,960 --> 00:20:32,000
but it also means that once you step to

00:20:30,080 --> 00:20:34,000
elasticsearch you get a lot of

00:20:32,000 --> 00:20:35,600
extra complexity in your jungle

00:20:34,000 --> 00:20:38,640
application

00:20:35,600 --> 00:20:41,760
let's see how that looks yeah

00:20:38,640 --> 00:20:45,919
we basically looked at that so

00:20:41,760 --> 00:20:48,880
with postgres we just have one postgres

00:20:45,919 --> 00:20:52,320
database and we have trigger in this

00:20:48,880 --> 00:20:54,720
database that keeps the database in sync

00:20:52,320 --> 00:20:55,600
in terms of full text search and our

00:20:54,720 --> 00:20:58,799
usual

00:20:55,600 --> 00:21:01,440
data and everything works fine

00:20:58,799 --> 00:21:02,080
granted we will add extra data and extra

00:21:01,440 --> 00:21:03,840
load to

00:21:02,080 --> 00:21:05,600
our posts with but so that's some

00:21:03,840 --> 00:21:08,159
scaling issue we might have to

00:21:05,600 --> 00:21:10,640
keep an eye on that but we don't have to

00:21:08,159 --> 00:21:14,240
bring in any extra systems

00:21:10,640 --> 00:21:14,960
this changes once we have elasticsearch

00:21:14,240 --> 00:21:17,760
or solar

00:21:14,960 --> 00:21:19,280
another system in there this case we

00:21:17,760 --> 00:21:22,559
need to think so

00:21:19,280 --> 00:21:24,880
if we search for a new document

00:21:22,559 --> 00:21:26,159
we would first need to hit our search

00:21:24,880 --> 00:21:29,280
system

00:21:26,159 --> 00:21:31,039
then most likely get some document ids

00:21:29,280 --> 00:21:33,760
gets them from the regular database and

00:21:31,039 --> 00:21:36,799
then surface them in a jungle view

00:21:33,760 --> 00:21:37,840
okay this is not too much code we can do

00:21:36,799 --> 00:21:40,799
that in a view and

00:21:37,840 --> 00:21:42,480
we know how that should happen gets

00:21:40,799 --> 00:21:44,720
slightly more complicated if you add

00:21:42,480 --> 00:21:46,960
documents or change documents

00:21:44,720 --> 00:21:49,280
because if you do that you not only have

00:21:46,960 --> 00:21:50,559
to change the data in postgres but also

00:21:49,280 --> 00:21:52,080
in elastic search

00:21:50,559 --> 00:21:54,799
and you have to decide whether you do

00:21:52,080 --> 00:21:57,200
this synchronously or synchronously

00:21:54,799 --> 00:21:58,480
how you do this in the background so you

00:21:57,200 --> 00:22:00,240
could in s

00:21:58,480 --> 00:22:02,799
and see we write another trigger that

00:22:00,240 --> 00:22:05,120
calls an external um program that

00:22:02,799 --> 00:22:06,799
posts data to elasticsearch you could

00:22:05,120 --> 00:22:10,320
have a drop cue to do that

00:22:06,799 --> 00:22:13,440
you could in theory do it in view so

00:22:10,320 --> 00:22:17,039
i wouldn't necessarily recommend it

00:22:13,440 --> 00:22:19,200
yeah you have some extra complexity

00:22:17,039 --> 00:22:21,520
okay it doesn't really buy you so much

00:22:19,200 --> 00:22:24,000
except that you have an extra server

00:22:21,520 --> 00:22:25,760
and the search functionality is not in

00:22:24,000 --> 00:22:29,200
post square so at least you don't have

00:22:25,760 --> 00:22:29,200
all the extra load on postgres

00:22:29,919 --> 00:22:33,840
yeah here we have it as an overview of

00:22:32,480 --> 00:22:35,600
research

00:22:33,840 --> 00:22:37,520
and this is what we're going to

00:22:35,600 --> 00:22:40,960
implement for the in the next

00:22:37,520 --> 00:22:42,000
remaining minutes so what we are going

00:22:40,960 --> 00:22:43,600
to do is just

00:22:42,000 --> 00:22:45,520
have a simple search form the ones that

00:22:43,600 --> 00:22:48,240
we used previously

00:22:45,520 --> 00:22:48,799
send a query to elasticsearch our usual

00:22:48,240 --> 00:22:51,520
water

00:22:48,799 --> 00:22:53,200
but it could be any other search query

00:22:51,520 --> 00:22:55,200
then elasticsearch will give us some

00:22:53,200 --> 00:22:57,520
document ids

00:22:55,200 --> 00:22:59,600
and also just to demonstrate some extra

00:22:57,520 --> 00:23:02,880
features some facets

00:22:59,600 --> 00:23:05,760
so basically counts how much is

00:23:02,880 --> 00:23:06,799
how often a certain features are

00:23:05,760 --> 00:23:09,919
represented in

00:23:06,799 --> 00:23:11,840
all our of our result set and then we

00:23:09,919 --> 00:23:15,280
get the actual data from post squares

00:23:11,840 --> 00:23:16,640
and render view okay let's look how this

00:23:15,280 --> 00:23:18,880
actually looks what this actually would

00:23:16,640 --> 00:23:20,799
look like

00:23:18,880 --> 00:23:22,880
there would be different ways to

00:23:20,799 --> 00:23:25,440
implement this

00:23:22,880 --> 00:23:26,480
we could use the haystack library which

00:23:25,440 --> 00:23:28,559
is an

00:23:26,480 --> 00:23:29,679
abstraction of different full text

00:23:28,559 --> 00:23:33,120
search backends

00:23:29,679 --> 00:23:36,080
for jungle so which gives you

00:23:33,120 --> 00:23:36,559
essentially the same api that you would

00:23:36,080 --> 00:23:40,400
have

00:23:36,559 --> 00:23:43,440
with the standard jungle or orm

00:23:40,400 --> 00:23:45,600
however it already fits

00:23:43,440 --> 00:23:47,120
in some search functionality which is

00:23:45,600 --> 00:23:50,400
nice

00:23:47,120 --> 00:23:53,600
you could also use the official

00:23:50,400 --> 00:23:56,000
python api for elasticsearch or you

00:23:53,600 --> 00:23:58,799
could just use the rest api

00:23:56,000 --> 00:24:00,720
i used the rest api um in a certain

00:23:58,799 --> 00:24:01,840
sense for simplicity's sake so i didn't

00:24:00,720 --> 00:24:04,159
want to distract

00:24:01,840 --> 00:24:05,600
too much from what happens behind the

00:24:04,159 --> 00:24:08,720
curtains

00:24:05,600 --> 00:24:11,760
but also just to show you how the api

00:24:08,720 --> 00:24:14,480
for elasticsearch looks like because

00:24:11,760 --> 00:24:15,360
you have to specify quite a lot of

00:24:14,480 --> 00:24:18,559
things

00:24:15,360 --> 00:24:22,000
that postgres does automatically or

00:24:18,559 --> 00:24:22,000
where postgres has some defaults

00:24:22,559 --> 00:24:29,039
first of all we want to put our data

00:24:25,600 --> 00:24:32,960
into the database and what we need to do

00:24:29,039 --> 00:24:35,679
is well create an index and an index

00:24:32,960 --> 00:24:37,039
is well essentially a definition how do

00:24:35,679 --> 00:24:40,559
we need to process

00:24:37,039 --> 00:24:44,080
our data so what we say is we define

00:24:40,559 --> 00:24:47,600
a filter and this filter says we move

00:24:44,080 --> 00:24:48,720
english stop words stop words are words

00:24:47,600 --> 00:24:51,200
that are ex

00:24:48,720 --> 00:24:52,720
well extremely frequently in documents

00:24:51,200 --> 00:24:56,320
and that we don't really want

00:24:52,720 --> 00:25:00,159
to process when we search they

00:24:56,320 --> 00:25:02,960
and i you they and

00:25:00,159 --> 00:25:05,360
a couple of hundred other words that are

00:25:02,960 --> 00:25:08,720
expected to be in every document and

00:25:05,360 --> 00:25:09,120
not that useful for search okay so we

00:25:08,720 --> 00:25:12,240
move

00:25:09,120 --> 00:25:14,799
all these words we also

00:25:12,240 --> 00:25:16,480
use a standard tokenizer tokenizer

00:25:14,799 --> 00:25:19,520
remember our first example

00:25:16,480 --> 00:25:22,960
water we don't want to

00:25:19,520 --> 00:25:24,799
look for the word waterline necessarily

00:25:22,960 --> 00:25:26,320
but we wanted to break it down we want

00:25:24,799 --> 00:25:26,880
to break the text down into different

00:25:26,320 --> 00:25:28,960
words

00:25:26,880 --> 00:25:30,799
so we define the tokenizer for our

00:25:28,960 --> 00:25:32,960
analyzer

00:25:30,799 --> 00:25:33,919
and then we tell them how to process

00:25:32,960 --> 00:25:37,279
these words

00:25:33,919 --> 00:25:39,520
so we lowercase everything and then we

00:25:37,279 --> 00:25:44,640
remove our stop words

00:25:39,520 --> 00:25:44,640
so this is the way that

00:25:45,039 --> 00:25:48,880
elasticsearch will look at every

00:25:47,360 --> 00:25:54,720
document

00:25:48,880 --> 00:25:54,720
when we index it and when we search for

00:25:54,840 --> 00:25:57,919
it

00:25:56,159 --> 00:25:59,360
so we have defined how to process our

00:25:57,919 --> 00:26:01,200
documents and

00:25:59,360 --> 00:26:02,720
well as you can see here the rest of the

00:26:01,200 --> 00:26:04,559
mapping is pretty close to the

00:26:02,720 --> 00:26:07,200
definition we have

00:26:04,559 --> 00:26:08,240
in django we just have a name and then

00:26:07,200 --> 00:26:10,559
we defined

00:26:08,240 --> 00:26:11,520
different data types and for our text

00:26:10,559 --> 00:26:14,720
fields

00:26:11,520 --> 00:26:17,440
how they should be processed

00:26:14,720 --> 00:26:19,520
then we just post our documents in this

00:26:17,440 --> 00:26:20,400
case i just post every document by

00:26:19,520 --> 00:26:22,320
itself

00:26:20,400 --> 00:26:24,799
there is also a batch api that makes

00:26:22,320 --> 00:26:26,320
things faster but

00:26:24,799 --> 00:26:27,919
for this demonstration it wasn't really

00:26:26,320 --> 00:26:30,720
required

00:26:27,919 --> 00:26:32,799
and every document that we post to

00:26:30,720 --> 00:26:36,880
elasticsearch where the rest interface

00:26:32,799 --> 00:26:37,360
is just well a regular json document it

00:26:36,880 --> 00:26:41,600
looks

00:26:37,360 --> 00:26:44,480
essentially like that so like

00:26:41,600 --> 00:26:44,480
everything before

00:26:44,640 --> 00:26:48,559
and now we want to search now if you

00:26:47,679 --> 00:26:51,919
remember with

00:26:48,559 --> 00:26:54,159
postgres we only had to say i

00:26:51,919 --> 00:26:55,600
want to search in these documents so i

00:26:54,159 --> 00:26:57,520
define a search vector

00:26:55,600 --> 00:26:59,200
i want to search for this particular

00:26:57,520 --> 00:27:02,799
term so i define

00:26:59,200 --> 00:27:03,760
define a search query and potentially a

00:27:02,799 --> 00:27:07,200
ranking model

00:27:03,760 --> 00:27:09,919
and then search away with the

00:27:07,200 --> 00:27:10,799
rest based api we really have to build

00:27:09,919 --> 00:27:13,679
the complete

00:27:10,799 --> 00:27:15,440
rest request and that's what you see on

00:27:13,679 --> 00:27:17,760
this particular slide

00:27:15,440 --> 00:27:19,520
so this is our search function that is

00:27:17,760 --> 00:27:23,440
called in our view

00:27:19,520 --> 00:27:25,919
we call for our query string we

00:27:23,440 --> 00:27:27,039
do call our search function we get our

00:27:25,919 --> 00:27:29,200
results back

00:27:27,039 --> 00:27:30,880
our results have both the documents that

00:27:29,200 --> 00:27:33,919
we're interested in

00:27:30,880 --> 00:27:34,399
and also so-called aggregation which

00:27:33,919 --> 00:27:38,080
keeps

00:27:34,399 --> 00:27:39,919
count of certain elements of the results

00:27:38,080 --> 00:27:42,399
so essentially it says we have so many

00:27:39,919 --> 00:27:45,520
documents in our results that

00:27:42,399 --> 00:27:47,200
that weight the film five versus the

00:27:45,520 --> 00:27:51,360
three versus a four

00:27:47,200 --> 00:27:52,240
or this user is has written so and so

00:27:51,360 --> 00:27:55,520
many doc

00:27:52,240 --> 00:27:57,919
reviews in our results so

00:27:55,520 --> 00:27:59,840
this is called our view then we have our

00:27:57,919 --> 00:28:03,679
multi-search function

00:27:59,840 --> 00:28:06,320
there we define this

00:28:03,679 --> 00:28:08,080
multi-match so we tell elasticsearch

00:28:06,320 --> 00:28:11,760
that we want to search in two fields

00:28:08,080 --> 00:28:14,159
with our usual query and then just

00:28:11,760 --> 00:28:15,120
essentially fill out a template that

00:28:14,159 --> 00:28:17,279
tells

00:28:15,120 --> 00:28:18,159
elasticsearch the details of what we

00:28:17,279 --> 00:28:20,080
want

00:28:18,159 --> 00:28:22,399
and we also define that we want certain

00:28:20,080 --> 00:28:25,840
aggregations to be returned

00:28:22,399 --> 00:28:27,840
so our query is here and this

00:28:25,840 --> 00:28:29,360
part tells us about how we would expect

00:28:27,840 --> 00:28:33,760
our results

00:28:29,360 --> 00:28:33,760
okay and if we do that

00:28:34,080 --> 00:28:38,720
we get our results set back so we get

00:28:36,960 --> 00:28:41,039
this extra facet functionality

00:28:38,720 --> 00:28:42,840
which is nice and not something that you

00:28:41,039 --> 00:28:44,399
would do with post squared out of the

00:28:42,840 --> 00:28:47,120
box

00:28:44,399 --> 00:28:48,159
we also have quite good performance also

00:28:47,120 --> 00:28:49,840
i'd say that the

00:28:48,159 --> 00:28:51,440
cache was warmed for this particular

00:28:49,840 --> 00:28:53,600
example so it wouldn't it would be

00:28:51,440 --> 00:28:56,240
slower from the first hit

00:28:53,600 --> 00:28:57,600
and we once more have a different

00:28:56,240 --> 00:29:01,919
ranking

00:28:57,600 --> 00:29:01,919
but this time again since we

00:29:03,120 --> 00:29:07,279
looked at the title and the way we went

00:29:04,960 --> 00:29:09,039
differently we have water

00:29:07,279 --> 00:29:11,120
at least in the title so we know what

00:29:09,039 --> 00:29:14,000
our documents are from

00:29:11,120 --> 00:29:15,760
and well if we wanted for could say give

00:29:14,000 --> 00:29:17,279
me all documents that this particular

00:29:15,760 --> 00:29:19,600
user has written so

00:29:17,279 --> 00:29:21,520
this person has written nine documents

00:29:19,600 --> 00:29:23,679
or give me all the reviews for this

00:29:21,520 --> 00:29:25,279
particular thing so there

00:29:23,679 --> 00:29:28,799
might be a movie that is related to

00:29:25,279 --> 00:29:32,720
water or give me all the high scores

00:29:28,799 --> 00:29:34,799
so this is one use

00:29:32,720 --> 00:29:36,559
of elasticsearch and we can already see

00:29:34,799 --> 00:29:39,679
it has slightly

00:29:36,559 --> 00:29:42,880
more advanced features it is

00:29:39,679 --> 00:29:44,880
more difficult to learn even if you look

00:29:42,880 --> 00:29:46,799
at the api because you have so many

00:29:44,880 --> 00:29:48,880
different features and it

00:29:46,799 --> 00:29:50,399
is well it can do everything from log

00:29:48,880 --> 00:29:52,840
processing to

00:29:50,399 --> 00:29:54,480
complex product review with external

00:29:52,840 --> 00:29:58,240
ranks

00:29:54,480 --> 00:30:01,840
but it is let's say manageable

00:29:58,240 --> 00:30:05,600
so which search system should we use

00:30:01,840 --> 00:30:08,880
well it always depends on a use case but

00:30:05,600 --> 00:30:10,880
if you only need to look up words

00:30:08,880 --> 00:30:12,320
within a document if you already know

00:30:10,880 --> 00:30:15,360
what you're looking for

00:30:12,320 --> 00:30:18,880
maybe ids maybe specific error messages

00:30:15,360 --> 00:30:20,320
maybe even a regex you can use postgres

00:30:18,880 --> 00:30:22,799
and you don't even need to touch the

00:30:20,320 --> 00:30:25,520
full text functionality

00:30:22,799 --> 00:30:26,480
if you just want one system and you want

00:30:25,520 --> 00:30:29,279
to have a quick

00:30:26,480 --> 00:30:31,600
implementation with some let's say

00:30:29,279 --> 00:30:34,559
reasonable defaults and a

00:30:31,600 --> 00:30:36,720
rather simple ranking model then you can

00:30:34,559 --> 00:30:39,440
stick with postgres

00:30:36,720 --> 00:30:41,200
and if you have more complex

00:30:39,440 --> 00:30:41,919
requirements especially in terms of

00:30:41,200 --> 00:30:44,880
ranking but

00:30:41,919 --> 00:30:46,720
potentially also in times of scaling and

00:30:44,880 --> 00:30:48,720
if you're willing to

00:30:46,720 --> 00:30:50,480
do the extra work to keep different

00:30:48,720 --> 00:30:52,000
systems in sync and to also learn

00:30:50,480 --> 00:30:55,279
different systems

00:30:52,000 --> 00:30:57,279
then you can go to elastic or if not

00:30:55,279 --> 00:30:58,960
to elastic you could go through solar or

00:30:57,279 --> 00:31:01,919
whoosh or

00:30:58,960 --> 00:31:02,960
any other kind of external vortex system

00:31:01,919 --> 00:31:06,159
elasticsearch

00:31:02,960 --> 00:31:08,159
just well happens to be the most popular

00:31:06,159 --> 00:31:11,360
at the moment

00:31:08,159 --> 00:31:12,720
so it's not a simple solution what to

00:31:11,360 --> 00:31:15,919
use there is a lot of

00:31:12,720 --> 00:31:18,240
going back and forth and ultimately it

00:31:15,919 --> 00:31:19,760
will all depend on your particular use

00:31:18,240 --> 00:31:22,000
case

00:31:19,760 --> 00:31:23,919
so do i need all the features do i

00:31:22,000 --> 00:31:25,360
expect that i will need many features in

00:31:23,919 --> 00:31:27,919
the future

00:31:25,360 --> 00:31:29,200
and as you have seen it's ultimately

00:31:27,919 --> 00:31:31,600
quite feasible to

00:31:29,200 --> 00:31:33,039
start out with postgres use the

00:31:31,600 --> 00:31:35,679
functionality there

00:31:33,039 --> 00:31:37,120
and then at some point in time change

00:31:35,679 --> 00:31:39,200
your system to

00:31:37,120 --> 00:31:42,559
use an external search system either for

00:31:39,200 --> 00:31:45,279
ranking or for scaling or because you

00:31:42,559 --> 00:31:46,720
want to keep your database focused on

00:31:45,279 --> 00:31:49,279
only your core data

00:31:46,720 --> 00:31:52,080
or whatever other reason that your use

00:31:49,279 --> 00:31:52,080
case requires

00:31:54,080 --> 00:31:58,000
okay that's already everything for this

00:31:56,559 --> 00:32:00,320
talk

00:31:58,000 --> 00:32:03,200
with extremely short let's say

00:32:00,320 --> 00:32:05,760
overflight of search functionality

00:32:03,200 --> 00:32:06,799
and my takeaway when i went to this

00:32:05,760 --> 00:32:09,600
search is useful

00:32:06,799 --> 00:32:10,880
for many different categories it is not

00:32:09,600 --> 00:32:14,240
necessarily

00:32:10,880 --> 00:32:16,159
easy so we had think five or six

00:32:14,240 --> 00:32:17,919
examples and we saw that each time we

00:32:16,159 --> 00:32:21,679
got different documents

00:32:17,919 --> 00:32:23,440
and if this was an in-depth problem

00:32:21,679 --> 00:32:25,120
so if we had really needed to have the

00:32:23,440 --> 00:32:27,919
best ranking possible

00:32:25,120 --> 00:32:29,440
you would likely spend a lot of time

00:32:27,919 --> 00:32:30,559
working on your different relevance

00:32:29,440 --> 00:32:32,159
models

00:32:30,559 --> 00:32:34,000
and a lot of more time than you would

00:32:32,159 --> 00:32:37,600
spend on making it work in either

00:32:34,000 --> 00:32:37,600
elastic search or postgres

00:32:37,679 --> 00:32:41,279
technologies the technology here is

00:32:40,480 --> 00:32:44,159
simple

00:32:41,279 --> 00:32:45,679
it's part of the problem and the good

00:32:44,159 --> 00:32:46,480
news is that we have multiple options

00:32:45,679 --> 00:32:48,000
available

00:32:46,480 --> 00:32:49,760
one comes out of the box that is

00:32:48,000 --> 00:32:52,159
postgres and

00:32:49,760 --> 00:32:53,200
many other systems are available to help

00:32:52,159 --> 00:32:55,360
us

00:32:53,200 --> 00:32:57,200
and we also have quite a lot of choice

00:32:55,360 --> 00:33:00,159
on how we actually integrate them so we

00:32:57,200 --> 00:33:04,320
could use haystack we could use the api

00:33:00,159 --> 00:33:06,240
or well we could go for a

00:33:04,320 --> 00:33:07,519
different solution all together and even

00:33:06,240 --> 00:33:11,120
implement our own

00:33:07,519 --> 00:33:14,399
full text search system

00:33:11,120 --> 00:33:16,080
okay and with that i'll thank everybody

00:33:14,399 --> 00:33:17,840
who listened to the talk i think we'll

00:33:16,080 --> 00:33:18,799
switch over to jitsi now for the live

00:33:17,840 --> 00:33:22,159
questions and

00:33:18,799 --> 00:33:22,159
yeah thank you very much and see you

00:33:22,840 --> 00:33:25,840
there

00:33:30,880 --> 00:33:35,039
multiple days just trying to get

00:33:32,880 --> 00:33:38,640
everything off the ground running

00:33:35,039 --> 00:33:40,799
and then on the second side

00:33:38,640 --> 00:33:43,600
how much work was it to implement it

00:33:40,799 --> 00:33:43,600
into your stack

00:33:44,320 --> 00:33:48,559
i think getting it to run is reasonably

00:33:46,880 --> 00:33:50,799
straightforward

00:33:48,559 --> 00:33:53,200
and i say i'm at the beginning so i

00:33:50,799 --> 00:33:55,840
haven't i don't use elastic productively

00:33:53,200 --> 00:33:58,559
at the moment i'm still with postgres

00:33:55,840 --> 00:33:59,120
that said learning the api was about a

00:33:58,559 --> 00:34:02,480
day

00:33:59,120 --> 00:34:06,320
for the use case that we've seen here

00:34:02,480 --> 00:34:08,639
operating it again is a different issue

00:34:06,320 --> 00:34:09,359
once especially you go for when

00:34:08,639 --> 00:34:11,119
redundant

00:34:09,359 --> 00:34:12,879
implementation and clustering you get a

00:34:11,119 --> 00:34:15,359
lot of out of the box

00:34:12,879 --> 00:34:16,079
so i would say to set up a development

00:34:15,359 --> 00:34:19,839
environment

00:34:16,079 --> 00:34:20,560
and start learning it's maybe two days

00:34:19,839 --> 00:34:24,079
maybe a week

00:34:20,560 --> 00:34:25,040
it depends however the api if you go

00:34:24,079 --> 00:34:28,320
into the more

00:34:25,040 --> 00:34:30,079
sophisticated use cases so not only

00:34:28,320 --> 00:34:31,760
what kind of data you want back and in

00:34:30,079 --> 00:34:33,599
which order and how filtered

00:34:31,760 --> 00:34:36,399
but the different relevance models the

00:34:33,599 --> 00:34:38,960
different pre-processing options etc

00:34:36,399 --> 00:34:40,560
that will likely take some time because

00:34:38,960 --> 00:34:42,560
not only do you have to change the

00:34:40,560 --> 00:34:44,480
configuration but you have a

00:34:42,560 --> 00:34:46,839
well little go around when you need to

00:34:44,480 --> 00:34:48,000
re-index your documents with different

00:34:46,839 --> 00:34:51,520
settings

00:34:48,000 --> 00:34:52,240
you need to look on how will this all

00:34:51,520 --> 00:34:55,040
work

00:34:52,240 --> 00:34:56,960
if it happened in a background process

00:34:55,040 --> 00:34:58,480
elasticsearch i think is the most

00:34:56,960 --> 00:35:02,000
complicated one solar

00:34:58,480 --> 00:35:05,920
is slightly simpler it cannot do

00:35:02,000 --> 00:35:09,680
as much and but it also doesn't

00:35:05,920 --> 00:35:12,480
try to do everything another thing

00:35:09,680 --> 00:35:14,160
is you could use an abstraction layer

00:35:12,480 --> 00:35:16,800
like haystack

00:35:14,160 --> 00:35:19,920
haystack will help you a lot to make it

00:35:16,800 --> 00:35:23,040
closer to what postgres provides

00:35:19,920 --> 00:35:24,880
um i didn't do it in

00:35:23,040 --> 00:35:26,240
part also because i don't like

00:35:24,880 --> 00:35:27,680
abstraction layers because i don't

00:35:26,240 --> 00:35:30,800
really see what happens

00:35:27,680 --> 00:35:33,280
under the covers this is something you

00:35:30,800 --> 00:35:35,359
may have noticed with postgres

00:35:33,280 --> 00:35:36,720
so if you just use the post squares

00:35:35,359 --> 00:35:40,000
default search options

00:35:36,720 --> 00:35:41,520
it makes a slight some assumptions so

00:35:40,000 --> 00:35:43,359
how do you want to tokenize your

00:35:41,520 --> 00:35:44,800
documents how do you want to have them

00:35:43,359 --> 00:35:47,839
processed

00:35:44,800 --> 00:35:51,680
is everything in english et cetera and

00:35:47,839 --> 00:35:55,040
this can lead to some surprises

00:35:51,680 --> 00:35:56,320
for example with these the water search

00:35:55,040 --> 00:35:58,320
has

00:35:56,320 --> 00:35:59,440
slightly less documents than the than

00:35:58,320 --> 00:36:02,640
the

00:35:59,440 --> 00:36:04,880
water eye contains and you don't

00:36:02,640 --> 00:36:07,920
necessarily understand

00:36:04,880 --> 00:36:11,040
how the documents actually look like

00:36:07,920 --> 00:36:13,599
so yeah to bring it short

00:36:11,040 --> 00:36:15,119
you need let's say two days to get

00:36:13,599 --> 00:36:17,040
started if you have your own virtual

00:36:15,119 --> 00:36:20,800
machines and don't have to

00:36:17,040 --> 00:36:22,640
work much with infrastructure but budget

00:36:20,800 --> 00:36:24,400
at least a couple of weeks if you want

00:36:22,640 --> 00:36:26,240
to use this for a productive use case

00:36:24,400 --> 00:36:27,680
and you want to be able to debug

00:36:26,240 --> 00:36:30,720
problems that your colleagues or

00:36:27,680 --> 00:36:30,720
customers come up with

00:36:31,520 --> 00:36:35,200
thank you welcome

00:36:35,359 --> 00:36:42,240
okay so

00:36:39,520 --> 00:36:43,839
yeah maybe just one hint if you want to

00:36:42,240 --> 00:36:46,800
get started

00:36:43,839 --> 00:36:48,720
um there is a github repository it is

00:36:46,800 --> 00:36:50,960
not much more code than you saw here

00:36:48,720 --> 00:36:51,920
it's basically just a view that produces

00:36:50,960 --> 00:36:54,320
its

00:36:51,920 --> 00:36:56,000
extremely ugly html and you can then

00:36:54,320 --> 00:36:57,359
switch around between the different

00:36:56,000 --> 00:36:59,280
search options

00:36:57,359 --> 00:37:01,440
you will have to set up postgres you

00:36:59,280 --> 00:37:03,200
will need to install elasticsearch if

00:37:01,440 --> 00:37:04,640
you just wanted to follow this tutorial

00:37:03,200 --> 00:37:06,720
it

00:37:04,640 --> 00:37:08,560
will probably take you one maybe two

00:37:06,720 --> 00:37:09,920
hours because it's just a default

00:37:08,560 --> 00:37:11,599
configuration

00:37:09,920 --> 00:37:13,839
and then you can play around with these

00:37:11,599 --> 00:37:16,160
different systems

00:37:13,839 --> 00:37:18,160
if you want to try something else let's

00:37:16,160 --> 00:37:21,119
say solar for example it

00:37:18,160 --> 00:37:21,839
shouldn't take you necessarily longer

00:37:21,119 --> 00:37:25,040
and

00:37:21,839 --> 00:37:26,640
the documents like i said are from a

00:37:25,040 --> 00:37:28,480
research paper

00:37:26,640 --> 00:37:29,760
they are all available so you can

00:37:28,480 --> 00:37:32,240
download

00:37:29,760 --> 00:37:33,680
archive of a couple of hundred megabytes

00:37:32,240 --> 00:37:37,119
and you can then

00:37:33,680 --> 00:37:38,720
search for this particular document oops

00:37:37,119 --> 00:37:40,720
what i like about them is basically it's

00:37:38,720 --> 00:37:42,560
movie review so you don't need much

00:37:40,720 --> 00:37:44,640
domain knowledge to see what's

00:37:42,560 --> 00:37:45,760
fits or what you would expect and what

00:37:44,640 --> 00:37:48,240
wouldn't and

00:37:45,760 --> 00:37:50,400
there is also some metadata in there so

00:37:48,240 --> 00:37:51,200
this review scores the usefulness

00:37:50,400 --> 00:37:54,560
ranking

00:37:51,200 --> 00:37:56,240
the user ids so if you want to go beyond

00:37:54,560 --> 00:37:58,000
pure full text search to do some

00:37:56,240 --> 00:38:00,000
filtering or

00:37:58,000 --> 00:38:01,680
re-ranking or something like that you

00:38:00,000 --> 00:38:03,680
can also do that

00:38:01,680 --> 00:38:05,200
so if you're interested that would be my

00:38:03,680 --> 00:38:06,400
personal recommendation just to get

00:38:05,200 --> 00:38:08,880
started

00:38:06,400 --> 00:38:10,640
you don't necessarily even need to do a

00:38:08,880 --> 00:38:14,079
complete jungle implementation

00:38:10,640 --> 00:38:16,800
since elasticsolar etc have rest apis

00:38:14,079 --> 00:38:18,800
you can just well download them index

00:38:16,800 --> 00:38:21,119
them and then play around with them

00:38:18,800 --> 00:38:22,720
and see whether every the documents that

00:38:21,119 --> 00:38:27,280
you get back make sense

00:38:22,720 --> 00:38:27,280
before you even build a view around them

00:38:28,960 --> 00:38:32,800
yeah and potentially yeah you could do

00:38:31,119 --> 00:38:35,920
the same with postmas

00:38:32,800 --> 00:38:39,280
so if you look for postgres

00:38:35,920 --> 00:38:41,119
full text search you will find a quite

00:38:39,280 --> 00:38:42,880
complex and complete implement and

00:38:41,119 --> 00:38:45,119
documentation

00:38:42,880 --> 00:38:46,000
on postgres itself and you will see some

00:38:45,119 --> 00:38:49,359
of the terms

00:38:46,000 --> 00:38:51,680
that also are visible in the jungle api

00:38:49,359 --> 00:38:55,440
so this gives you some background on

00:38:51,680 --> 00:38:55,440
what seems to happen behind the covers

00:38:56,160 --> 00:38:59,760
thank you again for giving the talk

00:38:58,800 --> 00:39:01,119
welcome

00:38:59,760 --> 00:39:02,960
thanks for joining the talk i hope it

00:39:01,119 --> 00:39:04,000
was interesting or at least you got you

00:39:02,960 --> 00:39:06,400
started

00:39:04,000 --> 00:39:08,960
and yeah if there are no further

00:39:06,400 --> 00:39:11,119
questions i think we'll end this one and

00:39:08,960 --> 00:39:12,240
i wish you much continued fun on the

00:39:11,119 --> 00:39:14,400
conference

00:39:12,240 --> 00:39:17,280
and hopefully see you in person well at

00:39:14,400 --> 00:39:17,280
a later conference

00:39:23,320 --> 00:39:26,320

YouTube URL: https://www.youtube.com/watch?v=r_IyFYdIbQw


