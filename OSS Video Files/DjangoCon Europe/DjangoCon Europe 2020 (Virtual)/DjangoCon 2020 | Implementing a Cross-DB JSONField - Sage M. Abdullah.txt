Title: DjangoCon 2020 | Implementing a Cross-DB JSONField - Sage M. Abdullah
Publication date: 2020-10-08
Playlist: DjangoCon Europe 2020 (Virtual)
Description: 
	DjangoCon Europe 2020 (Virtual)
September 19, 2020 - 10h35 (GMT+1)

“Implementing a Cross-DB JSONField” by Sage M. Abdullah 

Tired of dealing with structured data? Want to avoid database migrations? Try `JSONField`! This talk explains the implementation of a cross-DB `JSONField`, a new feature released in Django 3.1, that can be used on all database backends supported by Django.
Captions: 
	00:00:00,037 --> 00:00:01,700
Hello, everyone, I hope you're

00:00:01,725 --> 00:00:03,702
having a good day, wherever you are.

00:00:03,965 --> 00:00:07,945
This is a pre-recorded talk, which means that if you

00:00:07,945 --> 00:00:10,023
are watching this at the time of the conference,

00:00:10,243 --> 00:00:12,690
I will be in the chat room trying my best

00:00:12,690 --> 00:00:14,780
to answer your questions during the talk.

00:00:16,125 --> 00:00:19,203
Now, I hope you're prepared for this one, because there's

00:00:19,203 --> 00:00:22,676
going to be a lot of code snippets, as I think it's

00:00:22,685 --> 00:00:26,103
much easier to understand this topic through code snippets.

00:00:26,103 --> 00:00:29,957
Before we get into this whole JSONField thing,

00:00:30,137 --> 00:00:32,980
Let me just give you some background on myself.

00:00:33,143 --> 00:00:34,643
I'm Sage Abdullah.

00:00:35,025 --> 00:00:36,760
I'm a computer science undergraduate student

00:00:36,870 --> 00:00:39,253
at Universitas Indonesia.

00:00:39,730 --> 00:00:43,330
I'm currently writing my bachelor thesis on JSONField,

00:00:43,583 --> 00:00:46,783
so I can't wait to finish that and share it with you.

00:00:47,845 --> 00:00:50,565
I've been a Django user since 2018,

00:00:50,715 --> 00:00:53,343
and I'm also a Django contributor.

00:00:54,467 --> 00:00:58,250
Last year, I participated in the Google Summer of Code program

00:00:58,250 --> 00:01:02,273
with Django, during which I implemented

00:01:02,280 --> 00:01:05,293
the cross-DB JSONField that you can use starting from Django 3.1,

00:01:05,455 --> 00:01:08,593
which was just released last month.

00:01:09,540 --> 00:01:12,587
You can find me on GitHub and Twitter @laymonage.

00:01:14,810 --> 00:01:16,543
So, JASONField.

00:01:16,543 --> 00:01:17,043
Oops,

00:01:17,043 --> 00:01:19,643
JSONField. What is it?

00:01:19,943 --> 00:01:23,083
Now, if you're a Django user and you see the suffix

00:01:23,086 --> 00:01:27,860
"Field", you probably think that it's probably a

00:01:27,860 --> 00:01:30,925
model field or a form field, in which case, you are right.

00:01:31,240 --> 00:01:33,873
But I'm going to talk more about the model field here,

00:01:33,880 --> 00:01:36,266
because that's where things get interesting.

00:01:36,380 --> 00:01:39,050
But what exactly is JSONField?

00:01:39,455 --> 00:01:41,450
I'm just going to quote the Django docs here,

00:01:41,533 --> 00:01:44,263
because we all know that the docs are awesome.

00:01:45,343 --> 00:01:48,892
So it says that JSONField is a field

00:01:48,895 --> 00:01:52,602
for storing JSON-encoded data. In Python,

00:01:52,610 --> 00:01:56,030
The data is represented as dictionaries,

00:01:56,220 --> 00:02:01,030
lists, and the basic types that we see in Python.

00:02:01,870 --> 00:02:05,257
Now, it says JSON-encoded data, but what does it mean?

00:02:05,257 --> 00:02:07,990
Before we get into that,

00:02:08,070 --> 00:02:09,807
I'd like to talk a bit about JSON.

00:02:10,810 --> 00:02:13,497
If you're a web developer, you've probably already

00:02:13,497 --> 00:02:17,140
used JSON before, but if you're not familiar with JSON,

00:02:17,143 --> 00:02:21,567
it stands for JavaScript Object Notation

00:02:22,453 --> 00:02:27,370
and it's a key-value data format, much like Python dictionaries.

00:02:27,370 --> 00:02:30,640
Now, JSON-encoded data,

00:02:30,640 --> 00:02:34,143
is basically a string that contains valid JSON data.

00:02:34,433 --> 00:02:36,966
And this string is what we are

00:02:36,966 --> 00:02:38,606
going to save into our database.

00:02:39,672 --> 00:02:42,117
When talking about databases in Django,

00:02:42,220 --> 00:02:44,792
we usually talk about the models.

00:02:46,050 --> 00:02:49,467
Now, this model represents this table in our database,

00:02:49,467 --> 00:02:53,417
and the fields represents the columns.

00:02:53,647 --> 00:02:57,540
Now let's say I want to store the users' preferences or

00:02:57,540 --> 00:03:02,773
configuration in the database, such as a dark mode setting.

00:03:02,863 --> 00:03:06,683
Now, to achieve this, I would have to add another field

00:03:06,686 --> 00:03:10,786
to my model, generate the migration, and run the migration.

00:03:11,136 --> 00:03:15,206
And then sometime in the future, if I want to add a font size configuration,

00:03:15,206 --> 00:03:18,883
I would have to do the same thing again.

00:03:19,136 --> 00:03:21,996
I would add a new field to the model,

00:03:22,065 --> 00:03:24,945
generate a new migration, and run the migration.

00:03:25,177 --> 00:03:29,936
And I always have to do that every time I add a new setting.

00:03:30,053 --> 00:03:32,336
Now, this may be cumbersome if you keep adding

00:03:32,336 --> 00:03:35,520
more and more columns, as you can see here, maybe

00:03:35,520 --> 00:03:38,133
we can do something to make our table simpler.

00:03:39,000 --> 00:03:42,617
Now, if you see the last sync column, it's a DateTimeField.

00:03:42,617 --> 00:03:47,190
While you can see this as a regular string,

00:03:47,315 --> 00:03:51,523
it actually is more complex than that, as the database knows

00:03:51,523 --> 00:03:56,996
that this part of the data is the date

00:03:57,293 --> 00:04:00,526
and this part of the data is the time.

00:04:01,406 --> 00:04:03,282
Now, maybe we can do the same thing

00:04:03,285 --> 00:04:07,010
for our config columns by merging all the columns

00:04:07,010 --> 00:04:10,197
and using a delimiter for the values.

00:04:11,465 --> 00:04:16,219
But we lose the information of what these values represent.

00:04:16,482 --> 00:04:19,150
So we have to remember which part of

00:04:19,150 --> 00:04:22,416
the value is for what configuration.

00:04:23,050 --> 00:04:26,520
Plus we would have to write our own function

00:04:26,530 --> 00:04:30,245
that parses this value into separate values.

00:04:30,490 --> 00:04:32,910
Now, wouldn't it be great if we can

00:04:32,910 --> 00:04:35,200
just use JSON in our database?

00:04:35,316 --> 00:04:39,650
We can still have the information of the configuration name,

00:04:39,650 --> 00:04:43,150
and it's also much more readable.

00:04:43,956 --> 00:04:46,075
However, it does have a downside.

00:04:46,302 --> 00:04:49,503
We repeat the keys for each row.

00:04:50,530 --> 00:04:54,792
Still, you don't have to create a new migration

00:04:54,822 --> 00:04:57,257
every time you want to add a new configuration,

00:04:58,060 --> 00:05:00,347
you just add them to the JSON data.

00:05:01,120 --> 00:05:04,205
So in the end, your database will look like this.

00:05:05,915 --> 00:05:08,675
We have seen how JSON data is stored in the database,

00:05:08,675 --> 00:05:12,075
but how does JSONField actually work?

00:05:13,543 --> 00:05:16,330
Now, let's say I have replaced the configuration fields

00:05:16,330 --> 00:05:20,000
with one single JSONField, and then let's say we have

00:05:20,000 --> 00:05:23,380
this dictionary that contains the configuration values

00:05:23,500 --> 00:05:25,880
that we want to store in our database.

00:05:26,163 --> 00:05:30,050
So what we do is we create a new Profile object with

00:05:30,053 --> 00:05:33,000
that dictionary as the value for our JSONField.

00:05:33,316 --> 00:05:36,543
And then sometime later, when we retrieve the object from

00:05:36,543 --> 00:05:41,790
the database and we access .config, we see that it's a dictionary

00:05:41,790 --> 00:05:46,146
and it's equal to the dictionary that we previously have.

00:05:47,830 --> 00:05:50,385
And we can see here that it's really a dictionary,

00:05:50,387 --> 00:05:53,767
so that means we can do dictionary operations,

00:05:53,767 --> 00:05:57,107
such as updating the values like this.

00:05:57,192 --> 00:05:59,926
After that, if we want to save the data,

00:06:00,036 --> 00:06:02,720
we just call .save() on the object.

00:06:02,846 --> 00:06:06,246
And later, when we retrieve the object back from the database,

00:06:06,260 --> 00:06:09,496
we can see that it has also changed in the database.

00:06:09,770 --> 00:06:13,765
But how does it work in the background?

00:06:14,065 --> 00:06:15,165
Now, let's go back here.

00:06:15,180 --> 00:06:18,090
So from the dictionary, we call objects.create()

00:06:18,117 --> 00:06:21,317
with that dictionary as the config value.

00:06:21,713 --> 00:06:23,500
Actually, I'm going to break this down

00:06:23,500 --> 00:06:27,630
into the instantiation of the profile object,

00:06:27,630 --> 00:06:30,886
and then calling .save() on the object.

00:06:32,112 --> 00:06:35,605
When we call .save(), what happens in the background?

00:06:35,860 --> 00:06:39,636
So what we want to do is we turn the dictionary

00:06:39,866 --> 00:06:43,452
into a JSON-encoded data, and then

00:06:43,452 --> 00:06:47,360
Django will compose an SQL query to store the data

00:06:47,360 --> 00:06:51,613
in the database like this. The config value is

00:06:51,613 --> 00:06:54,926
just a string that contains valid JSON data.

00:06:55,800 --> 00:06:57,950
And then later on, when we retrieve

00:06:57,952 --> 00:06:59,572
the object from the database,

00:07:00,760 --> 00:07:03,700
Django will issue an SQL query like this.

00:07:05,497 --> 00:07:09,075
And the database driver will return the JSON-encoded data,

00:07:09,090 --> 00:07:12,450
which is a string, to Django.

00:07:12,863 --> 00:07:16,450
So we want Django to somehow convert

00:07:16,525 --> 00:07:19,973
this JSON-encoded data into a Python dictionary.

00:07:20,350 --> 00:07:21,850
Now, how do we do that?

00:07:22,117 --> 00:07:25,890
Well, thankfully, Python has its own JSON

00:07:25,890 --> 00:07:29,190
library that lets us encode Python objects into JSON

00:07:29,300 --> 00:07:33,286
and decode JSON into Python objects.

00:07:34,917 --> 00:07:40,027
Now, how it works is that we import JSON, and then if we have

00:07:40,027 --> 00:07:43,860
a Python dictionary that we want to encode into JSON,

00:07:44,060 --> 00:07:49,136
we call json.dumps() with that dictionary as the argument,

00:07:49,460 --> 00:07:53,526
and then we would have the JSON-encoded data as a string.

00:07:54,330 --> 00:07:58,202
And then if we have JSON-encoded data, we can pass it into

00:07:58,205 --> 00:08:03,370
json.loads(), which will give us the Python dictionary.

00:08:03,370 --> 00:08:07,493
And it's equal to the original dictionary that I have.

00:08:07,500 --> 00:08:11,806
And this does not only apply to dictionaries, it actually applies

00:08:11,806 --> 00:08:16,016
to any Python object that can be encoded into JSON.

00:08:17,055 --> 00:08:19,425
Now, what if I tell you that you can implement

00:08:19,427 --> 00:08:23,567
your own cross-DB JSONField in less than 10 lines?

00:08:23,825 --> 00:08:26,123
Well, that happens to be the case.

00:08:27,982 --> 00:08:31,232
This is a cross-DB JSONField in less than 10 lines,

00:08:31,232 --> 00:08:34,410
but it's a bit tight.

00:08:34,410 --> 00:08:37,916
So let's apply some

00:08:37,925 --> 00:08:39,425
physical distancing to the code.

00:08:39,540 --> 00:08:42,775
That's a bit much. OK, perfect.

00:08:43,054 --> 00:08:47,310
Now it's more than 10 lines, but it's still less

00:08:47,310 --> 00:08:51,323
than 15 lines and we have a nice docstring on top.

00:08:51,510 --> 00:08:56,520
So how it works is that we create a subclass of

00:08:56,900 --> 00:09:01,363
TextField because we are storing our JSON data as text.

00:09:02,262 --> 00:09:03,850
And then what we need to do is

00:09:03,852 --> 00:09:06,100
override the get_prep_value() method.

00:09:06,585 --> 00:09:09,920
This method is called by Django to convert

00:09:09,953 --> 00:09:15,390
the Python object into the query value, which is used

00:09:15,390 --> 00:09:19,070
for queries and by default, the database value.

00:09:19,303 --> 00:09:23,863
Now, the thing is, None is reserved for the SQL NULL,

00:09:23,863 --> 00:09:27,716
as defined in the DB-API standard in Python.

00:09:27,890 --> 00:09:32,683
So we should not call json.dumps() on that and just leave it be,

00:09:32,683 --> 00:09:38,292
So that we can still store SQL NULLs. And then,

00:09:38,292 --> 00:09:40,735
for other values, we just call json.dumps().

00:09:40,982 --> 00:09:43,893
And then one other method that we need to override

00:09:44,146 --> 00:09:48,000
is the from_db_value(), which is the method that

00:09:48,003 --> 00:09:51,473
gets called when Django retrieves the value from

00:09:51,473 --> 00:09:55,443
the database. And as None is reserved for SQL NULL,

00:09:55,446 --> 00:09:56,946
we should not touch that.

00:09:57,250 --> 00:10:00,835
And for other values, we just call json.loads(),

00:10:00,845 --> 00:10:04,600
which will decode the data into Python objects.

00:10:05,523 --> 00:10:09,070
Now, if we want, we can also add some extra functionality,

00:10:09,070 --> 00:10:15,155
such as a custom encoder and decoder by adding a subclass of

00:10:15,490 --> 00:10:20,625
the JSONEncoder and JSONDecoder class, and that class will be passed

00:10:20,885 --> 00:10:26,886
as the cls argument when we are calling json.dumps() and json.loads().

00:10:28,352 --> 00:10:30,690
And that is, a cross-DB JSONField

00:10:30,717 --> 00:10:33,472
that you can do in 15 lines.

00:10:35,305 --> 00:10:38,246
All right, there's the thing about empty values.

00:10:38,246 --> 00:10:42,980
So, the None value is reserved for SQL NULL.

00:10:42,983 --> 00:10:47,106
If we are talking about string-based fields, we have

00:10:47,106 --> 00:10:52,576
two possible values for empty: None or the empty string ('').

00:10:52,893 --> 00:10:55,990
However, Django recommends using the empty string

00:10:55,990 --> 00:10:59,063
instead of NULLs on string-based fields.

00:10:59,545 --> 00:11:02,186
Unless you need the field to be unique,

00:11:02,186 --> 00:11:04,380
which means that you can't have multiple

00:11:04,380 --> 00:11:07,332
objects that have the same empty string.

00:11:07,790 --> 00:11:09,713
However, since we we're talking about JSON data,

00:11:09,753 --> 00:11:14,647
what about... the JSON empty string,

00:11:14,647 --> 00:11:17,710
and the empty JSON object, or the empty JSON array,

00:11:18,900 --> 00:11:23,042
or even the value null? They are all

00:11:23,042 --> 00:11:25,720
valid JSON values, which means that you can store them

00:11:25,720 --> 00:11:29,170
in your JSONField as the top-level value.

00:11:29,372 --> 00:11:34,586
These values will be encoded as JSON-encoded strings.

00:11:36,443 --> 00:11:38,082
Now, let's see some comparison.

00:11:38,823 --> 00:11:41,302
So in Python, for empty strings, you can either

00:11:41,305 --> 00:11:44,425
use single quotes, or double quotes.

00:11:44,630 --> 00:11:47,616
But in JSON, you can only use double quotes.

00:11:47,756 --> 00:11:49,886
And as we know, the data that is stored

00:11:49,890 --> 00:11:52,680
in the database is JSON-encoded data.

00:11:52,926 --> 00:11:55,375
So we basically just wrap the valid JSON values

00:11:56,165 --> 00:11:59,376
in strings, like this.

00:12:00,223 --> 00:12:02,440
And the same also goes for the empty JSON objects

00:12:02,440 --> 00:12:04,727
and empty JSON arrays,

00:12:04,925 --> 00:12:06,965
so we have no problem with that.

00:12:08,607 --> 00:12:10,292
Now, what about the None value?

00:12:11,205 --> 00:12:15,612
The JSON equivalent of the None value would be the JSON null.

00:12:16,650 --> 00:12:21,660
And if we encode None in Python with json.dumps(),

00:12:21,660 --> 00:12:25,730
we will get the 'null' string, and that is JSON encoded data.

00:12:25,740 --> 00:12:27,243
It contains valid JSON.

00:12:27,292 --> 00:12:30,280
However, as I previously said, the None value

00:12:30,280 --> 00:12:33,642
is reserved for the SQL NULL.

00:12:33,806 --> 00:12:35,330
So we cannot use that.

00:12:36,397 --> 00:12:39,460
But what if we want to store JSON null

00:12:39,460 --> 00:12:41,997
as the top-level value in our JSONField?

00:12:42,360 --> 00:12:46,296
That means we want to store the string 'null' in our database.

00:12:46,350 --> 00:12:49,290
Well, what we can do is, we wrap the null string

00:12:49,335 --> 00:12:51,900
as a Value object.

00:12:52,266 --> 00:12:57,292
The Value object means that it's a literal database value.

00:12:58,126 --> 00:12:59,832
So that means it does not need

00:12:59,835 --> 00:13:01,752
to be prepared for the database.

00:13:02,183 --> 00:13:06,052
Therefore, json.dumps() is not called,

00:13:06,052 --> 00:13:08,640
and that means we can store JSON null in our database.

00:13:08,902 --> 00:13:11,320
However, there's a problem with this.

00:13:12,410 --> 00:13:15,397
When we retrieve the value from the database, we call

00:13:15,400 --> 00:13:19,663
json.loads() on the value, other than None. The value from

00:13:19,663 --> 00:13:24,280
the database would be the string 'null' and that is not None.

00:13:24,573 --> 00:13:26,683
So Django will call json.loads()

00:13:26,683 --> 00:13:29,503
on that value, which will give us None.

00:13:29,803 --> 00:13:33,633
And then when you save that None back into the database,

00:13:33,913 --> 00:13:37,743
Django will leave it as it is and it will be SQL NULL.

00:13:37,860 --> 00:13:39,870
So, it's kind of tricky,

00:13:40,606 --> 00:13:43,600
and for this case, Django does not recommend you

00:13:43,600 --> 00:13:47,260
to use null values, either JSON null, or SQL NULL.

00:13:47,555 --> 00:13:50,380
And instead Django recommends you to use

00:13:50,383 --> 00:13:52,376
a default in your JSONField,

00:13:52,440 --> 00:13:55,293
such as an empty dictionary instead of null.

00:13:55,443 --> 00:13:59,300
But you should not use the literal

00:13:59,300 --> 00:14:01,680
empty dictionary object ({}) because that will be shared

00:14:01,683 --> 00:14:05,230
across your model instances, because it's mutable.

00:14:05,610 --> 00:14:09,526
So what you would do is, you pass a callable

00:14:09,540 --> 00:14:12,045
that returns a fresh object every time.

00:14:12,700 --> 00:14:16,555
A simple example would be the dict class, which will

00:14:16,555 --> 00:14:19,420
return a fresh, empty dictionary every time.

00:14:20,213 --> 00:14:22,907
This only happens if you want to store JSON null

00:14:22,907 --> 00:14:25,300
as the top-level value of the JSONField.

00:14:26,510 --> 00:14:29,177
If you have JSON null in JSON objects or

00:14:29,177 --> 00:14:32,250
JSON arrays, well, there's no problem with that.

00:14:33,407 --> 00:14:37,020
Previously, we were storing the data as text. However,

00:14:37,020 --> 00:14:41,116
some of the database backends supported by Django actually have

00:14:41,120 --> 00:14:44,837
native JSON data types, and we would like to use that.

00:14:46,100 --> 00:14:51,233
Django supports PostgreSQL SQLite, MySQL,

00:14:51,556 --> 00:14:54,970
MariaDB, and Oracle Database. But not all of them

00:14:54,973 --> 00:14:58,450
have native JSON data types.

00:14:59,327 --> 00:15:03,792
In order to define the data types that will be used on each

00:15:03,792 --> 00:15:07,632
database backend, we can override the db_type() method.

00:15:08,436 --> 00:15:12,005
MySQL has a native JSON data type, stored as binary.

00:15:12,007 --> 00:15:16,813
MariaDB, which uses the same database backend as MySQL,

00:15:16,820 --> 00:15:20,845
however, stores JSON data as text.

00:15:20,950 --> 00:15:24,370
But it does have a JSON data type,

00:15:24,373 --> 00:15:27,193
which is an alias for LONGTEXT.

00:15:27,236 --> 00:15:29,996
Oracle Database lets you store JSON data

00:15:29,996 --> 00:15:34,226
in VARCHAR or LOB data types.

00:15:34,900 --> 00:15:37,953
Postgres has two JSON data types.

00:15:38,036 --> 00:15:40,220
The first is json and the second one

00:15:40,220 --> 00:15:42,286
is jsonb. With json,

00:15:42,286 --> 00:15:45,620
you store the data as text, so when you

00:15:45,620 --> 00:15:49,450
store the data, it's a bit faster, as it doesn't

00:15:49,450 --> 00:15:51,870
need to encode the data into binary.

00:15:52,110 --> 00:15:55,393
But for querying, it can be a bit slower

00:15:55,393 --> 00:15:58,493
because the decoding has to be done on the fly.

00:15:59,040 --> 00:16:01,173
While with jsonb, it's the other way around.

00:16:01,953 --> 00:16:06,150
Data is usually more often queried than stored,

00:16:06,210 --> 00:16:10,063
so we use jsonb. SQLite does not have

00:16:10,066 --> 00:16:13,783
a JSON data type, but it does have JSON functions,

00:16:13,783 --> 00:16:16,703
which we can use to query JSON data.

00:16:17,443 --> 00:16:20,440
Those functions are included in the JSON1 extension.

00:16:21,450 --> 00:16:23,910
Note that this is not how the JSONField

00:16:23,912 --> 00:16:26,815
in Django 3.1 was implemented.

00:16:26,885 --> 00:16:29,540
For the actual JSONField implementation,

00:16:29,593 --> 00:16:33,940
we define the data types in the DatabaseWrapper instead of

00:16:33,943 --> 00:16:37,700
the JSONField class, and we don't subclass TextField.

00:16:39,567 --> 00:16:43,565
And then we can add CHECK constraints to ensure that

00:16:43,570 --> 00:16:47,995
the data inserted into the database is valid JSON.

00:16:47,995 --> 00:16:52,880
On MySQL, there's no need to add a CHECK constraint

00:16:53,000 --> 00:16:57,100
because that already comes with the JSON data type.

00:16:58,013 --> 00:17:02,737
But for MariaDB, prior to version 10.4.3,

00:17:02,905 --> 00:17:08,886
you have to add an explicit JSON_VALID() CHECK constraint

00:17:08,930 --> 00:17:13,963
to ensure that the data is valid JSON. On later versions,

00:17:14,039 --> 00:17:17,805
if you use the JSON alias, it will automatically

00:17:17,807 --> 00:17:20,724
apply the JSON_VALID() constraint.

00:17:22,717 --> 00:17:25,342
On Oracle Database, you just have to add

00:17:25,344 --> 00:17:29,330
the IS JSON keyword. Now on SQLite,

00:17:29,330 --> 00:17:31,940
it's pretty similar, but it's a bit different.

00:17:32,953 --> 00:17:37,160
The thing is, on MySQL and MariaDB,

00:17:37,160 --> 00:17:41,520
the JSON_VALID() function returns true if you pass SQL NULL

00:17:41,520 --> 00:17:46,855
as the argument. However, on SQLite, it returns false.

00:17:46,855 --> 00:17:51,153
So in order to be able to store SQL NULL values,

00:17:51,153 --> 00:17:54,700
we would have to add this OR "%(column)s" IS NULL

00:17:54,700 --> 00:17:57,686
clause to the CHECK constraint.

00:17:57,925 --> 00:18:00,983
This is merely a different way of thinking,

00:18:01,030 --> 00:18:06,393
because you can say that "no data" is valid JSON,

00:18:06,655 --> 00:18:09,430
but you can also say that it's not valid.

00:18:10,153 --> 00:18:14,837
The SQLite developers decide that "no data" is not valid JSON.

00:18:15,005 --> 00:18:18,276
And for Postgres, like MySQL, the check

00:18:18,276 --> 00:18:20,906
already comes with the JSON data types.

00:18:20,910 --> 00:18:22,865
So we just return None.

00:18:23,607 --> 00:18:27,210
We have explored about storing and retrieving JSON data

00:18:27,280 --> 00:18:31,620
to and from the database, and we have also explored

00:18:31,622 --> 00:18:36,100
how we can ensure that the data we insert is valid JSON.

00:18:36,100 --> 00:18:39,250
There's one more thing about the ORM,

00:18:39,465 --> 00:18:42,252
and it's a very important thing that we haven't explored,

00:18:42,252 --> 00:18:46,135
and that is querying the JSON data.

00:18:47,766 --> 00:18:51,093
Let's say we have this JSON data and then we want

00:18:51,093 --> 00:18:54,080
to query the model objects that have the value

00:18:54,083 --> 00:18:57,650
"Sage" at the path "name" in the JSON data.

00:18:58,466 --> 00:19:02,627
Well, looking at how Transforms work on other fields,

00:19:02,630 --> 00:19:06,110
the natural way to do this would be something like this.

00:19:06,117 --> 00:19:09,667
So we just chain the JSONField with double underscore (__)

00:19:09,667 --> 00:19:13,425
and with the path that we want to check for,

00:19:13,605 --> 00:19:16,125
and then the value would be on the right hand side.

00:19:16,500 --> 00:19:19,836
And that is exactly how JSONField transforms work.

00:19:20,626 --> 00:19:23,367
However, the implementation is different on each

00:19:23,370 --> 00:19:26,362
database backend. For example, on Postgres,

00:19:27,467 --> 00:19:31,792
you can use the arrow operator (->) to extract the value

00:19:31,795 --> 00:19:36,120
at a given path and check for that value, whether

00:19:36,120 --> 00:19:38,383
it's equal to something that you look for.

00:19:39,410 --> 00:19:41,822
On a SQLite, you can do the same thing using

00:19:41,822 --> 00:19:46,125
the function JSON_EXTRACT(). On MySQL and MariaDB,

00:19:46,720 --> 00:19:49,880
it's a bit different, because the JSON_EXTRACT() function

00:19:50,420 --> 00:19:54,916
will return this value with the double quotes still in it.

00:19:54,923 --> 00:19:59,990
So it's an SQL string that contains double quotes

00:20:00,045 --> 00:20:02,315
at the beginning and the end of the string.

00:20:02,380 --> 00:20:06,370
So we will need to call another function,

00:20:06,370 --> 00:20:09,682
called JSON_UNQUOTE(), which will unquote the value for us.

00:20:10,855 --> 00:20:14,657
On Oracle Database, the function is named differently.

00:20:15,215 --> 00:20:18,403
It's called JSON_VALUE(), but it works pretty much

00:20:18,403 --> 00:20:22,853
the same way, but it can only be used for scalar values.

00:20:22,936 --> 00:20:27,206
So you cannot use JSON_VALUE() for paths

00:20:27,206 --> 00:20:30,783
that return JSON objects or JSON arrays.

00:20:30,866 --> 00:20:32,743
You would have to use a different

00:20:33,300 --> 00:20:35,290
function called JSON_QUERY() for that.

00:20:36,570 --> 00:20:40,237
Let's add some more complexity. Now we have

00:20:40,237 --> 00:20:44,305
additional information about pets. I have a pet cat,

00:20:44,333 --> 00:20:45,833
his name is Bagol.

00:20:47,150 --> 00:20:50,155
Well, he's actually a street cat, but he comes to

00:20:50,155 --> 00:20:53,275
my house every day, so we treat him like a pet.

00:20:54,362 --> 00:20:58,220
And let's say we want to query for objects that have

00:20:58,297 --> 00:21:03,776
the first pet name of "Bagol". The natural way to do

00:21:03,776 --> 00:21:07,113
this would be to keep chaining the paths, like this.

00:21:07,113 --> 00:21:09,670
So, __pets,

00:21:09,830 --> 00:21:12,793
__0, for the index of the object,

00:21:12,870 --> 00:21:15,443
__name, for the path here.

00:21:16,433 --> 00:21:20,082
And it works the same way like the previous one, but

00:21:20,137 --> 00:21:23,947
on Postgres, instead of using the -> operator, you

00:21:23,947 --> 00:21:27,717
replace the - with # (#>) and in the right hand side

00:21:27,720 --> 00:21:32,846
of the extraction operator, would be an array of keys

00:21:32,846 --> 00:21:36,480
or indexes that compose the path that you want to extract.

00:21:37,325 --> 00:21:39,847
Whereas on SQLite, you just specify

00:21:39,847 --> 00:21:42,040
the path in the second argument.

00:21:42,876 --> 00:21:45,572
This is the JSONPath notation.

00:21:45,787 --> 00:21:49,780
The $ stands for the root of the JSON document,

00:21:49,782 --> 00:21:53,600
and . means that we access the key,

00:21:54,907 --> 00:21:57,502
and accessing arrays works pretty

00:21:57,502 --> 00:21:59,075
much the same way as we know.

00:22:00,912 --> 00:22:04,195
Now, there's still something about empty values.

00:22:04,553 --> 00:22:06,980
Let's say we have the following JSON object.

00:22:08,106 --> 00:22:10,582
And then we also have this JSON object.

00:22:11,460 --> 00:22:13,312
What would the following query return?

00:22:13,650 --> 00:22:16,466
What we do with this query is that we would

00:22:16,496 --> 00:22:20,023
extract the value at the path "partner".

00:22:20,336 --> 00:22:26,270
Now, if the object has the path "partner", even if it's

00:22:26,280 --> 00:22:29,690
null, it should return some information to indicate

00:22:29,780 --> 00:22:33,526
that the path is there and the value is null.

00:22:33,630 --> 00:22:36,940
However, if the path is not there at all,

00:22:36,943 --> 00:22:39,133
then maybe it should return something to

00:22:39,133 --> 00:22:42,050
indicate that the path is not even there.

00:22:42,155 --> 00:22:45,535
So that's exactly the case with the extract

00:22:45,535 --> 00:22:48,710
functions. When the path is not available,

00:22:48,775 --> 00:22:52,083
the function will return SQL NULL.

00:22:52,496 --> 00:22:56,210
However, for JSON null, the function

00:22:56,210 --> 00:22:59,776
would still return the SQL string 'null'.

00:22:59,863 --> 00:23:03,420
So I think it would make sense that this

00:23:03,420 --> 00:23:07,203
query would return the second one, because we

00:23:07,210 --> 00:23:10,730
don't normally use None as a lookup value.

00:23:10,806 --> 00:23:14,910
If we were querying for SQL NULLs, we would use

00:23:14,987 --> 00:23:18,620
the isnull lookup and that's exactly the case here.

00:23:18,630 --> 00:23:21,283
So if we want to query for missing keys,

00:23:21,283 --> 00:23:23,485
we use the isnull lookup.

00:23:25,373 --> 00:23:28,367
The exact lookup with the None right hand side value

00:23:28,370 --> 00:23:31,835
is used to query JSON null values.

00:23:32,236 --> 00:23:35,066
Now, the thing is this, the JSON extract

00:23:35,066 --> 00:23:37,233
function behaves differently on SQLite.

00:23:38,800 --> 00:23:42,950
It returns SQL NULL when the path exists,

00:23:42,953 --> 00:23:47,310
but the value is JSON null. And it also returns

00:23:47,520 --> 00:23:50,790
SQL NULL, if the path is not there, so there's

00:23:50,790 --> 00:23:53,920
no way to determine whether the path is there or not.

00:23:53,973 --> 00:23:57,593
However, there's one other function called JSON_TYPE()

00:23:57,593 --> 00:24:02,652
that returns the type of the JSON value at a given path.

00:24:02,687 --> 00:24:05,827
We can utilize this to determine whether

00:24:05,827 --> 00:24:09,117
the value is JSON null or the path does not exist,

00:24:09,117 --> 00:24:12,400
which should return the SQL NULL.

00:24:12,416 --> 00:24:16,840
We handle this by changing the function that is used

00:24:16,840 --> 00:24:20,946
on SQLite if the right hand side value is None.

00:24:22,955 --> 00:24:26,012
Other than the key and path transforms chained

00:24:26,015 --> 00:24:28,670
with the exact lookup, there are also

00:24:29,200 --> 00:24:31,690
other lookups implemented for JSONField.

00:24:32,657 --> 00:24:36,776
The first ones are the containment lookups. For example,

00:24:36,776 --> 00:24:40,912
let's use this JSON object again, but let's add some

00:24:40,912 --> 00:24:44,027
more data here, and then let's say I want to query

00:24:44,027 --> 00:24:47,280
all the JSON objects that have the value of age 21,

00:24:47,840 --> 00:24:53,046
and also a pet goldfish in one of the pets.

00:24:53,133 --> 00:24:55,403
Well, the contains lookup lets you do this.

00:24:55,446 --> 00:24:59,206
It looks for the supersets of the right hand side value

00:24:59,206 --> 00:25:01,710
that you provide in the query.

00:25:03,340 --> 00:25:06,735
This is implemented on Postgres using the

00:25:06,735 --> 00:25:10,480
containment operator and on MySQL and MariaDB there's

00:25:10,480 --> 00:25:13,312
the JSON_CONTAINS() function that provides the same functionality.

00:25:13,690 --> 00:25:17,233
Sadly, there is no such function on SQLite

00:25:17,233 --> 00:25:20,396
and Oracle so we cannot support this.

00:25:20,473 --> 00:25:22,480
We can actually implement custom functions,

00:25:22,610 --> 00:25:25,330
but it's kind of tricky to get

00:25:25,333 --> 00:25:27,273
the subset checking correctly.

00:25:27,406 --> 00:25:32,206
Therefore, we decided to drop the support for the contains

00:25:32,206 --> 00:25:34,160
lookup on SQLite and Oracle.

00:25:35,962 --> 00:25:38,577
And then there's also the contained_by lookup,

00:25:38,577 --> 00:25:41,576
which is basically the inverse of the contains lookup.

00:25:41,765 --> 00:25:47,183
So instead of looking for supersets, we look for subsets.

00:25:49,793 --> 00:25:54,127
And this is implemented by using the reverse containment operator

00:25:54,130 --> 00:25:57,555
on Postgres. On MySQL and MariaDB,

00:25:57,760 --> 00:26:01,420
you just flip the arguments to the JSON_CONTAINS() function.

00:26:02,736 --> 00:26:07,300
And the last lookups are the key existence lookups. These lookups

00:26:07,532 --> 00:26:11,390
let you query for JSON objects that have certain keys.

00:26:13,110 --> 00:26:15,600
The first one is the has_key lookup, which lets you

00:26:15,600 --> 00:26:20,102
query the objects that have one specific key.

00:26:20,476 --> 00:26:24,015
On Postgres, this is implemented by using the ? operator.

00:26:24,015 --> 00:26:27,863
On MySQL and MariaDB, there's the function

00:26:27,956 --> 00:26:29,980
JSON_CONTAINS_PATH() that provides

00:26:29,980 --> 00:26:32,060
the same functionality. On Oracle,

00:26:32,066 --> 00:26:34,316
there's the function JSON_EXISTS(). On SQLite,

00:26:34,560 --> 00:26:38,296
We reuse the function, JSON_TYPE() to determine

00:26:38,296 --> 00:26:41,713
whether the path is there or not, because it only

00:26:41,800 --> 00:26:45,690
returns SQL NULL if the path does not exist.

00:26:45,695 --> 00:26:48,325
So we just add IS NOT NULL condition

00:26:48,357 --> 00:26:50,716
to the return value of JSON_TYPE().

00:26:51,435 --> 00:26:54,296
And then there's the has_keys lookup, which requires

00:26:54,296 --> 00:26:57,490
the objects to have all of the keys that

00:26:57,490 --> 00:26:59,386
you specify in the right hand side.

00:26:59,440 --> 00:27:02,365
This is implemented on Postgres using

00:27:02,365 --> 00:27:05,213
the ?& operator. On MySQL and MariaDB,

00:27:05,213 --> 00:27:10,366
this is implemented by supplying multiple paths

00:27:10,370 --> 00:27:14,293
and using the 'all' argument instead of 'one', which means

00:27:14,296 --> 00:27:17,742
that the objects should match all of the paths that we specify.

00:27:19,120 --> 00:27:22,037
On Oracle and SQLite, we just chain

00:27:22,037 --> 00:27:24,782
the function calls with the AND operator.

00:27:24,797 --> 00:27:26,900
However, we can see that the Oracle

00:27:27,040 --> 00:27:29,630
and SQLite implementations are very similar.

00:27:30,720 --> 00:27:34,757
To maximize code reuse, we instead unpack

00:27:34,762 --> 00:27:39,493
the JSON_CONTAINS_PATH() function to multiple

00:27:39,493 --> 00:27:44,385
JSON_CONTAINS_PATH() calls and chain them with the AND operator.

00:27:45,972 --> 00:27:48,370
Now, I don't know if there's any performance impacts

00:27:48,372 --> 00:27:50,375
from this, and it was not my call

00:27:50,375 --> 00:27:54,190
to change it to this implementation.

00:27:54,240 --> 00:27:58,996
So if you find out that there is some performance impacts,

00:27:58,996 --> 00:28:02,580
feel free to let me know and I will try to fix it.

00:28:02,580 --> 00:28:06,270
And then the last lookup is the has_any_keys lookup,

00:28:06,270 --> 00:28:09,727
which is basically like has_keys, but you only need

00:28:09,750 --> 00:28:14,180
the JSON objects to match at least one of the keys that you

00:28:14,180 --> 00:28:18,000
specify in the right hand side. On Postgres this is implemented

00:28:18,000 --> 00:28:22,095
using the ?| operator.

00:28:22,262 --> 00:28:25,990
On MySQL and MariaDB it's like has_keys lookup,

00:28:25,993 --> 00:28:29,730
but we use the 'one' argument instead of 'all'.

00:28:30,915 --> 00:28:34,202
And on Oracle and SQLite, we just chain the function calls

00:28:34,202 --> 00:28:38,160
with the OR operator. We did the same thing with

00:28:38,163 --> 00:28:42,473
the MySQL implementation, so that they all use the same

00:28:42,476 --> 00:28:45,013
code with different function templates.

00:28:45,213 --> 00:28:46,813
And thats it!

00:28:46,980 --> 00:28:48,580
So where to go from here?

00:28:49,080 --> 00:28:51,045
Well, if you want to improve the JSONField implementation,

00:28:51,280 --> 00:28:54,796
you can find room for optimizations

00:28:55,056 --> 00:28:57,996
or you can also implement the currently unsupported lookups

00:28:58,060 --> 00:29:02,133
on SQLite and Oracle database.

00:29:02,463 --> 00:29:06,763
As for the usage of JSONField itself, if you still,

00:29:06,763 --> 00:29:10,866
for some reason, want to validate your JSON data

00:29:10,870 --> 00:29:14,750
with a JSON schema, you can do so using Django validators.

00:29:15,325 --> 00:29:19,032
For those of you who only use LTS versions and could not yet

00:29:19,032 --> 00:29:23,280
try the JSONField in Django 3.1,

00:29:23,280 --> 00:29:24,955
well, don't be sad.

00:29:25,002 --> 00:29:27,526
You can use the django-jsonfield-backport

00:29:27,900 --> 00:29:30,533
package on PyPI that I have made.

00:29:30,663 --> 00:29:34,265
It supports Django 2.2 and 3.0.

00:29:34,265 --> 00:29:35,920
So if for some reason you are still on 3.0,

00:29:35,920 --> 00:29:38,753
you can also check that out.

00:29:38,760 --> 00:29:40,616
And there's nothing left for me to say

00:29:40,626 --> 00:29:42,853
other than thank you for listening to me.

00:29:42,986 --> 00:29:45,566
This is my first ever talk at a conference,

00:29:45,566 --> 00:29:48,472
so I really appreciate the opportunity.

00:29:48,640 --> 00:29:51,560
Slides are available hosted on my website

00:29:51,570 --> 00:29:53,695
or you can also find them on my GitHub.

00:29:53,707 --> 00:29:56,727
And as a bonus, here's a photo of Bagol.

00:29:57,150 --> 00:29:58,573

YouTube URL: https://www.youtube.com/watch?v=o9Zb1RmS8vk


