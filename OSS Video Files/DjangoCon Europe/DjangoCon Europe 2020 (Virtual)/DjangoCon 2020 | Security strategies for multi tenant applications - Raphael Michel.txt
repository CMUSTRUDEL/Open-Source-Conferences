Title: DjangoCon 2020 | Security strategies for multi tenant applications - Raphael Michel
Publication date: 2020-09-30
Playlist: DjangoCon Europe 2020 (Virtual)
Description: 
	DjangoCon Europe 2020 (Virtual)
September 18, 2020 - 09h55 (GMT+1)

"Security strategies for multi tenant applications" by Raphael Michel

When writing multi-tenant applications, a very typical and dangerous bug is to forget about a WHERE statement and show data to the wrong users. This often goes unnoticed, since most people are only testing with one user account. This talk discusses strategies to prevent this class of error entirely.


Note: Q&A not available due to technical problems.
Captions: 
	00:00:04,319 --> 00:00:07,200
hello and welcome to the saturday

00:00:05,839 --> 00:00:08,800
morning talk

00:00:07,200 --> 00:00:10,639
about security strategies for

00:00:08,800 --> 00:00:12,080
multi-tenant applications

00:00:10,639 --> 00:00:14,400
my name is rafael i'm a software

00:00:12,080 --> 00:00:16,640
developer from heidelberg germany

00:00:14,400 --> 00:00:17,840
previous housed djangocon europe and if

00:00:16,640 --> 00:00:19,039
you're watching this you're watching a

00:00:17,840 --> 00:00:20,960
recorded version of me

00:00:19,039 --> 00:00:22,720
and the realtime version of me is with

00:00:20,960 --> 00:00:25,039
you in this chat

00:00:22,720 --> 00:00:26,320
and can answer questions as we go i will

00:00:25,039 --> 00:00:28,880
also be available

00:00:26,320 --> 00:00:31,359
at the end of my talk for for live video

00:00:28,880 --> 00:00:32,960
questions

00:00:31,359 --> 00:00:34,480
before we go into the security

00:00:32,960 --> 00:00:35,920
strategies

00:00:34,480 --> 00:00:37,920
i want to make sure that we're all on

00:00:35,920 --> 00:00:40,079
the same page what a multi-talent

00:00:37,920 --> 00:00:42,480
application is so we're quickly going to

00:00:40,079 --> 00:00:45,760
define it and give some examples

00:00:42,480 --> 00:00:47,840
so multi-tenancy is commonly referred to

00:00:45,760 --> 00:00:51,360
as the concept of a single instance of a

00:00:47,840 --> 00:00:53,840
software serving multiple entities

00:00:51,360 --> 00:00:56,160
those entities can be individual users

00:00:53,840 --> 00:00:59,359
or entire enterprises

00:00:56,160 --> 00:01:01,680
or other less organized groups of people

00:00:59,359 --> 00:01:03,920
but the idea is that those entities use

00:01:01,680 --> 00:01:05,680
the software in a pretty separate way

00:01:03,920 --> 00:01:07,200
so an application that is not a

00:01:05,680 --> 00:01:09,119
multi-talent application

00:01:07,200 --> 00:01:10,560
is a social network like facebook or

00:01:09,119 --> 00:01:12,720
messaging or twitter

00:01:10,560 --> 00:01:14,240
where everybody operates on the same

00:01:12,720 --> 00:01:16,560
databases where everybody can

00:01:14,240 --> 00:01:18,000
see and interact with everybody else on

00:01:16,560 --> 00:01:21,040
the platform

00:01:18,000 --> 00:01:22,799
an example for multi-tenancy

00:01:21,040 --> 00:01:24,240
multi-tenant application would for

00:01:22,799 --> 00:01:27,759
example be slack

00:01:24,240 --> 00:01:28,479
where you are inside your own workspace

00:01:27,759 --> 00:01:30,799
together with

00:01:28,479 --> 00:01:32,400
others from your organization and you

00:01:30,799 --> 00:01:35,600
can interact with each other

00:01:32,400 --> 00:01:36,240
but you usually there's a footnote you

00:01:35,600 --> 00:01:39,439
usually

00:01:36,240 --> 00:01:41,680
don't uh interact with people of

00:01:39,439 --> 00:01:43,680
other organizations who might also use

00:01:41,680 --> 00:01:46,960
the same product

00:01:43,680 --> 00:01:49,439
basically multiserency covers most

00:01:46,960 --> 00:01:51,520
software service businesses out there at

00:01:49,439 --> 00:01:55,200
least most of the ones targeted to

00:01:51,520 --> 00:01:58,640
business users

00:01:55,200 --> 00:02:01,439
in our case we're developing pretix

00:01:58,640 --> 00:02:02,399
which is the ticket shop application

00:02:01,439 --> 00:02:05,280
that you used

00:02:02,399 --> 00:02:07,759
to sign up for this virtual conference

00:02:05,280 --> 00:02:10,640
it's an open source event ticket shop

00:02:07,759 --> 00:02:11,440
and one installation can power many

00:02:10,640 --> 00:02:14,400
events

00:02:11,440 --> 00:02:15,760
organized by many different people so it

00:02:14,400 --> 00:02:19,840
fits the definition

00:02:15,760 --> 00:02:19,840
of multi-tenancy that we just gave

00:02:20,640 --> 00:02:25,120
there are now multiple ways to implement

00:02:23,200 --> 00:02:28,000
this multi-tenancy

00:02:25,120 --> 00:02:28,560
inside our database layer the simplest

00:02:28,000 --> 00:02:31,280
one

00:02:28,560 --> 00:02:32,400
would probably be to separate clients on

00:02:31,280 --> 00:02:34,800
a database level

00:02:32,400 --> 00:02:37,920
we could just have a separate database

00:02:34,800 --> 00:02:40,640
per client this gives us a really clean

00:02:37,920 --> 00:02:42,080
separation between our different clients

00:02:40,640 --> 00:02:43,599
and we can

00:02:42,080 --> 00:02:45,360
interact with them separately and make

00:02:43,599 --> 00:02:48,480
sure no data leaks

00:02:45,360 --> 00:02:49,040
between them however it requires us to

00:02:48,480 --> 00:02:50,720
open up

00:02:49,040 --> 00:02:52,640
multiple separate connections to our

00:02:50,720 --> 00:02:53,280
database because with most interface

00:02:52,640 --> 00:02:56,640
system

00:02:53,280 --> 00:02:57,040
it's not easy or at least not somewhat

00:02:56,640 --> 00:02:59,040
quick

00:02:57,040 --> 00:03:00,640
to switch between databases in running

00:02:59,040 --> 00:03:03,599
connection

00:03:00,640 --> 00:03:05,040
and it's also very hard to do in django

00:03:03,599 --> 00:03:07,440
because django

00:03:05,040 --> 00:03:08,560
um has a static concept of database

00:03:07,440 --> 00:03:10,720
connections

00:03:08,560 --> 00:03:12,159
and it's not really easy to define a

00:03:10,720 --> 00:03:13,360
list of databases that we have for

00:03:12,159 --> 00:03:16,000
multiple clients

00:03:13,360 --> 00:03:18,239
on the go with django it's also pretty

00:03:16,000 --> 00:03:18,560
bad for performance probably because not

00:03:18,239 --> 00:03:20,319
having

00:03:18,560 --> 00:03:21,840
kept not being able to reuse the same

00:03:20,319 --> 00:03:23,920
database connections means

00:03:21,840 --> 00:03:25,599
we can't really use connection polling

00:03:23,920 --> 00:03:28,159
so we're opening up a lot of

00:03:25,599 --> 00:03:30,640
database connections so that that's not

00:03:28,159 --> 00:03:30,640
really nice

00:03:31,040 --> 00:03:35,120
the next approach that is actually in

00:03:34,480 --> 00:03:36,799
use

00:03:35,120 --> 00:03:38,480
unlike database level dispersion which i

00:03:36,799 --> 00:03:39,440
haven't seen with django there probably

00:03:38,480 --> 00:03:41,440
people who do it

00:03:39,440 --> 00:03:43,760
but it's very uncommon is schema level

00:03:41,440 --> 00:03:45,440
separation to understand schema level

00:03:43,760 --> 00:03:47,920
separation you need to know

00:03:45,440 --> 00:03:49,040
that on postgresql there are multiple

00:03:47,920 --> 00:03:52,480
levels

00:03:49,040 --> 00:03:54,080
um of hierarchy in your database there's

00:03:52,480 --> 00:03:56,400
the postgresql cluster

00:03:54,080 --> 00:03:57,840
which is your server or combination of

00:03:56,400 --> 00:04:00,480
multiple servers

00:03:57,840 --> 00:04:01,680
there is your database and you can have

00:04:00,480 --> 00:04:05,599
multiple database

00:04:01,680 --> 00:04:08,000
in one cluster and inside that database

00:04:05,599 --> 00:04:10,640
you can have different schemas and those

00:04:08,000 --> 00:04:13,840
schemas contain tables and indesigns

00:04:10,640 --> 00:04:15,120
views and so on so usually you only have

00:04:13,840 --> 00:04:16,560
one schema

00:04:15,120 --> 00:04:19,280
that is called public and all your

00:04:16,560 --> 00:04:23,280
tables live in the schema called public

00:04:19,280 --> 00:04:24,800
but you can have multiple schemas within

00:04:23,280 --> 00:04:28,080
one database

00:04:24,800 --> 00:04:29,840
so unlike multiple databases they are

00:04:28,080 --> 00:04:31,759
still the same database you can connect

00:04:29,840 --> 00:04:33,120
with them at once and you can also query

00:04:31,759 --> 00:04:36,240
from them

00:04:33,120 --> 00:04:38,800
in the same query but unlike

00:04:36,240 --> 00:04:40,320
but they are separated in a way that you

00:04:38,800 --> 00:04:41,759
can have different tables for different

00:04:40,320 --> 00:04:44,880
schemas

00:04:41,759 --> 00:04:46,400
so they kind of work like name spaces

00:04:44,880 --> 00:04:49,120
for tables

00:04:46,400 --> 00:04:50,320
so using schemas and using one schema

00:04:49,120 --> 00:04:52,960
for each client

00:04:50,320 --> 00:04:54,000
allows you to have everything in one

00:04:52,960 --> 00:04:57,120
database

00:04:54,000 --> 00:05:01,840
but have everything clearly separated

00:04:57,120 --> 00:05:03,360
by client it also possibly allows you to

00:05:01,840 --> 00:05:04,720
scale up easily because

00:05:03,360 --> 00:05:06,400
once you grow too large to keep

00:05:04,720 --> 00:05:07,360
everything on one database server you

00:05:06,400 --> 00:05:10,560
can just move

00:05:07,360 --> 00:05:12,000
the different schemas of different

00:05:10,560 --> 00:05:14,560
of different clients to different

00:05:12,000 --> 00:05:16,000
servers and it has a very little overall

00:05:14,560 --> 00:05:17,360
impact to your code base because you

00:05:16,000 --> 00:05:19,680
just need to make sure

00:05:17,360 --> 00:05:22,000
that you're selecting the correct schema

00:05:19,680 --> 00:05:24,960
when you're querying your database

00:05:22,000 --> 00:05:26,720
however it works early in postgresql

00:05:24,960 --> 00:05:27,919
there is no concept of schemas for

00:05:26,720 --> 00:05:30,400
example on my

00:05:27,919 --> 00:05:31,840
sql and it's very hard to do

00:05:30,400 --> 00:05:34,000
cross-tenant queries

00:05:31,840 --> 00:05:34,960
for example i use slack earlier as an

00:05:34,000 --> 00:05:37,840
example for

00:05:34,960 --> 00:05:38,720
a multi-tunnel debation so a couple of

00:05:37,840 --> 00:05:40,960
years back

00:05:38,720 --> 00:05:42,720
this was a hundred percent true because

00:05:40,960 --> 00:05:44,880
inside slack you could only interact

00:05:42,720 --> 00:05:46,560
with people from your own organization

00:05:44,880 --> 00:05:48,479
however in recent years slack has

00:05:46,560 --> 00:05:49,759
introduced a feature called shared

00:05:48,479 --> 00:05:51,840
channels where you can

00:05:49,759 --> 00:05:52,880
share a selection between two different

00:05:51,840 --> 00:05:55,440
companies

00:05:52,880 --> 00:05:56,160
and so even if you don't have it now

00:05:55,440 --> 00:05:58,560
it's

00:05:56,160 --> 00:06:00,080
very likely that one day you will come

00:05:58,560 --> 00:06:02,240
across a use case

00:06:00,080 --> 00:06:04,479
where you will need to run queries

00:06:02,240 --> 00:06:06,479
efficiently across multiple tenants

00:06:04,479 --> 00:06:08,639
and that again is very hard to do with

00:06:06,479 --> 00:06:10,639
schema level separation

00:06:08,639 --> 00:06:12,720
so for those two reasons schema level

00:06:10,639 --> 00:06:13,280
separation can be a very nice and clean

00:06:12,720 --> 00:06:15,520
approach

00:06:13,280 --> 00:06:17,759
but wasn't an option for us in pre-text

00:06:15,520 --> 00:06:20,080
we want to be able to run

00:06:17,759 --> 00:06:22,960
on mysql and sqlite as well and we want

00:06:20,080 --> 00:06:25,840
to be able to do crosstalk queries

00:06:22,960 --> 00:06:26,560
um if you if those restrictions don't

00:06:25,840 --> 00:06:28,160
apply to you

00:06:26,560 --> 00:06:29,520
the schema level separation might be a

00:06:28,160 --> 00:06:30,400
good way and there are multiple

00:06:29,520 --> 00:06:32,080
different

00:06:30,400 --> 00:06:33,680
in different implementations for django

00:06:32,080 --> 00:06:36,160
out there including django

00:06:33,680 --> 00:06:38,960
eg schemas django tenant schemas and

00:06:36,160 --> 00:06:38,960
django tenants

00:06:39,440 --> 00:06:43,360
so with those out of the way the only

00:06:42,080 --> 00:06:45,919
way that really

00:06:43,360 --> 00:06:48,000
that is really left yes is row level

00:06:45,919 --> 00:06:48,479
separation and by row level separation i

00:06:48,000 --> 00:06:50,639
mean

00:06:48,479 --> 00:06:52,319
that with every row with every model

00:06:50,639 --> 00:06:54,800
instance in our database

00:06:52,319 --> 00:06:55,919
we keep track of which tenant it belongs

00:06:54,800 --> 00:06:58,400
to for example

00:06:55,919 --> 00:07:00,560
if we have a client model that

00:06:58,400 --> 00:07:02,400
represents our talents our customers

00:07:00,560 --> 00:07:04,400
and then we have a product model like in

00:07:02,400 --> 00:07:07,280
our ticket shop case where we have

00:07:04,400 --> 00:07:08,800
different products per client um then we

00:07:07,280 --> 00:07:10,240
would need a foreign key from

00:07:08,800 --> 00:07:12,240
product model to the client model so

00:07:10,240 --> 00:07:17,199
we'd like to know which

00:07:12,240 --> 00:07:18,960
client a specific product belongs to

00:07:17,199 --> 00:07:20,400
and then whenever we need a list of

00:07:18,960 --> 00:07:21,360
products for example to share to the

00:07:20,400 --> 00:07:24,560
user

00:07:21,360 --> 00:07:27,280
um we just query all products

00:07:24,560 --> 00:07:27,759
filtered by the client that is currently

00:07:27,280 --> 00:07:31,759
active

00:07:27,759 --> 00:07:34,880
either by looking what users logged in

00:07:31,759 --> 00:07:36,720
or by checking um

00:07:34,880 --> 00:07:40,160
the the domain that we're on or

00:07:36,720 --> 00:07:40,160
something else in our request

00:07:40,720 --> 00:07:44,000
and cross roll level separation is very

00:07:43,360 --> 00:07:47,120
explicit

00:07:44,000 --> 00:07:50,240
you explicitly see in your code base

00:07:47,120 --> 00:07:52,319
what belongs to which event where

00:07:50,240 --> 00:07:53,440
do we have separation where do we not

00:07:52,319 --> 00:07:55,520
have separation

00:07:53,440 --> 00:07:57,599
and it's very readable it's very

00:07:55,520 --> 00:07:59,520
flexible you can easily switch to doing

00:07:57,599 --> 00:08:00,479
queries across multiple tenants over all

00:07:59,520 --> 00:08:02,319
of the tenants

00:08:00,479 --> 00:08:04,000
and it works on every database that is

00:08:02,319 --> 00:08:06,479
supported by jengar

00:08:04,000 --> 00:08:08,560
however there is a downside as well it's

00:08:06,479 --> 00:08:10,800
very easy to get wrong

00:08:08,560 --> 00:08:13,919
and to prove that let's play a short

00:08:10,800 --> 00:08:13,919
game spot the back

00:08:21,680 --> 00:08:26,400
the first one is pretty easy say given

00:08:24,080 --> 00:08:27,759
the models we used before we're looking

00:08:26,400 --> 00:08:30,319
through our code base

00:08:27,759 --> 00:08:30,879
and we're seeing a query like this it

00:08:30,319 --> 00:08:34,080
selects

00:08:30,879 --> 00:08:38,240
products that are currently available

00:08:34,080 --> 00:08:40,560
and with the trained eye you quickly see

00:08:38,240 --> 00:08:42,640
there's something missing we're missing

00:08:40,560 --> 00:08:44,880
the filter for the current client

00:08:42,640 --> 00:08:46,000
saying uh we should add it in or we will

00:08:44,880 --> 00:08:48,480
have a data leak

00:08:46,000 --> 00:08:50,160
so that's still pretty easy to do but

00:08:48,480 --> 00:08:51,920
how about this

00:08:50,160 --> 00:08:53,440
django gives us both very powerful

00:08:51,920 --> 00:08:54,640
things to do things really really

00:08:53,440 --> 00:08:56,640
quickly and this way

00:08:54,640 --> 00:08:58,160
as a list view it's it's a complete

00:08:56,640 --> 00:09:00,000
definition of the view

00:08:58,160 --> 00:09:01,519
that renders all our products we just

00:09:00,000 --> 00:09:03,440
need to hook it up to an url

00:09:01,519 --> 00:09:05,920
write a template it'll give us a list of

00:09:03,440 --> 00:09:08,399
products there's no query set in there

00:09:05,920 --> 00:09:09,279
but it will still be a problem because

00:09:08,399 --> 00:09:10,959
it will

00:09:09,279 --> 00:09:13,600
it will render us the products of all

00:09:10,959 --> 00:09:16,880
our clients so whenever we use a generic

00:09:13,600 --> 00:09:17,920
view we will need to supply a custom

00:09:16,880 --> 00:09:20,000
query set method

00:09:17,920 --> 00:09:22,480
and make sure that we're passing in the

00:09:20,000 --> 00:09:24,480
correct filters

00:09:22,480 --> 00:09:26,959
the same is true normally for generic

00:09:24,480 --> 00:09:28,000
views it's also for example a problem

00:09:26,959 --> 00:09:30,399
for model forms

00:09:28,000 --> 00:09:31,440
for example if we had a model order that

00:09:30,399 --> 00:09:32,880
has a foreign key2

00:09:31,440 --> 00:09:34,720
product which in turn has a foreign key

00:09:32,880 --> 00:09:37,120
to a client

00:09:34,720 --> 00:09:38,320
and then we generate a form for our

00:09:37,120 --> 00:09:41,760
admin backend

00:09:38,320 --> 00:09:42,480
for our event organizer to modify an

00:09:41,760 --> 00:09:46,080
order

00:09:42,480 --> 00:09:47,680
and we say django please give us a model

00:09:46,080 --> 00:09:48,320
form of the model order with a few

00:09:47,680 --> 00:09:50,480
product

00:09:48,320 --> 00:09:52,160
and it looks all fine there's no query

00:09:50,480 --> 00:09:54,560
sets or anything in there

00:09:52,160 --> 00:09:56,720
but it will give us a select box a very

00:09:54,560 --> 00:09:57,440
nice model choice box that i believe

00:09:56,720 --> 00:09:59,120
carlton

00:09:57,440 --> 00:10:00,959
will be talking a lot more on later

00:09:59,120 --> 00:10:04,079
today

00:10:00,959 --> 00:10:07,839
um and it will list us the products of

00:10:04,079 --> 00:10:09,600
all clients in the system and

00:10:07,839 --> 00:10:11,440
the way around this is again pretty

00:10:09,600 --> 00:10:14,640
straightforward but a little bit

00:10:11,440 --> 00:10:17,040
cumbersome would require ca to

00:10:14,640 --> 00:10:18,240
overwrite the underscore underscore init

00:10:17,040 --> 00:10:20,880
method and

00:10:18,240 --> 00:10:21,279
set a custom query set for that field

00:10:20,880 --> 00:10:24,000
and

00:10:21,279 --> 00:10:24,959
those things are not only hard to spot

00:10:24,000 --> 00:10:27,839
in the code base

00:10:24,959 --> 00:10:29,279
they're also how to spot um during

00:10:27,839 --> 00:10:31,120
testing because on your local

00:10:29,279 --> 00:10:33,440
development machine

00:10:31,120 --> 00:10:35,600
for a feature you just developed how

00:10:33,440 --> 00:10:37,279
likely is it that you actually have data

00:10:35,600 --> 00:10:37,839
in your database for multiple different

00:10:37,279 --> 00:10:39,680
clients

00:10:37,839 --> 00:10:42,480
so you won't even notice that it will

00:10:39,680 --> 00:10:44,800
return you too many results

00:10:42,480 --> 00:10:47,760
and i've talked about generic views and

00:10:44,800 --> 00:10:49,440
model forms but the same is true of

00:10:47,760 --> 00:10:52,399
model serializers and django rest

00:10:49,440 --> 00:10:55,519
frameworks filter sets and django filter

00:10:52,399 --> 00:10:58,560
and so on with

00:10:55,519 --> 00:10:59,519
very thorough code review and some

00:10:58,560 --> 00:11:01,920
experience

00:10:59,519 --> 00:11:03,279
it is possible to prevent this kind of

00:11:01,920 --> 00:11:06,320
error

00:11:03,279 --> 00:11:08,800
99 of the time and

00:11:06,320 --> 00:11:09,680
when it doesn't when you don't catch it

00:11:08,800 --> 00:11:13,279
things can

00:11:09,680 --> 00:11:16,399
go bad really really bad

00:11:13,279 --> 00:11:17,760
a few examples from our history as a

00:11:16,399 --> 00:11:21,680
company and as a

00:11:17,760 --> 00:11:22,640
software project in 2017 we encountered

00:11:21,680 --> 00:11:25,839
just that

00:11:22,640 --> 00:11:27,920
we had two incidents of data leaks

00:11:25,839 --> 00:11:29,440
due to list view or model form without a

00:11:27,920 --> 00:11:32,480
custom query set

00:11:29,440 --> 00:11:33,519
it wasn't that bad it was not really it

00:11:32,480 --> 00:11:36,720
was no personal

00:11:33,519 --> 00:11:39,600
uh personally identifiable data involved

00:11:36,720 --> 00:11:41,360
um it was called early on say so it

00:11:39,600 --> 00:11:44,240
wasn't that bad but

00:11:41,360 --> 00:11:46,160
it was a real incident of this and then

00:11:44,240 --> 00:11:48,880
two years later just last year

00:11:46,160 --> 00:11:49,600
we nearly leaked all of our customer

00:11:48,880 --> 00:11:52,240
data

00:11:49,600 --> 00:11:54,399
due to a missing filter clause in a

00:11:52,240 --> 00:11:56,399
query

00:11:54,399 --> 00:11:58,079
the only thing that prevented the

00:11:56,399 --> 00:11:58,880
disaster from happening is that we

00:11:58,079 --> 00:12:01,680
tested the

00:11:58,880 --> 00:12:02,720
feature again shortly after it wrote out

00:12:01,680 --> 00:12:04,639
a production

00:12:02,720 --> 00:12:06,560
and we noticed there was a really really

00:12:04,639 --> 00:12:08,320
large file being exported instead of the

00:12:06,560 --> 00:12:10,160
expected really really small file and we

00:12:08,320 --> 00:12:11,839
immediately shut everything down and we

00:12:10,160 --> 00:12:13,360
were able to see in our log files that

00:12:11,839 --> 00:12:15,600
we were the first one to test it

00:12:13,360 --> 00:12:16,560
and nobody had gotten any data that they

00:12:15,600 --> 00:12:20,079
shouldn't have

00:12:16,560 --> 00:12:22,240
gotten um but it was really really close

00:12:20,079 --> 00:12:23,440
to an absolute privacy and security

00:12:22,240 --> 00:12:24,720
disaster

00:12:23,440 --> 00:12:26,959
if you want to read more about the

00:12:24,720 --> 00:12:28,800
specific incident um it's all

00:12:26,959 --> 00:12:31,440
in our blog as with any security

00:12:28,800 --> 00:12:34,720
incident that we have

00:12:31,440 --> 00:12:38,639
so we needed to find a way to make sure

00:12:34,720 --> 00:12:40,639
this never ever happens again

00:12:38,639 --> 00:12:42,639
and if you want to make sure that

00:12:40,639 --> 00:12:45,760
something never ever happens

00:12:42,639 --> 00:12:47,839
um the best way to go about this is with

00:12:45,760 --> 00:12:48,399
the defense and depth approach defensive

00:12:47,839 --> 00:12:50,800
depth

00:12:48,399 --> 00:12:51,680
it sounds very professional it's a very

00:12:50,800 --> 00:12:54,560
simple term

00:12:51,680 --> 00:12:56,160
it just says that you have multiple

00:12:54,560 --> 00:12:58,480
security measures in place

00:12:56,160 --> 00:13:00,079
which are redundant so even if one of

00:12:58,480 --> 00:13:03,279
the security measures

00:13:00,079 --> 00:13:05,120
fails or gets broken the other security

00:13:03,279 --> 00:13:07,200
measures are still in place

00:13:05,120 --> 00:13:09,440
and you can fall back on them and the

00:13:07,200 --> 00:13:11,440
system is still secure

00:13:09,440 --> 00:13:13,519
so in our case we settled on three

00:13:11,440 --> 00:13:15,839
layers of protection

00:13:13,519 --> 00:13:16,800
the first layer of protection was to

00:13:15,839 --> 00:13:19,519
lock it down

00:13:16,800 --> 00:13:20,880
or better to keep locking it down we

00:13:19,519 --> 00:13:23,680
would still

00:13:20,880 --> 00:13:25,680
and to this day we're still writing all

00:13:23,680 --> 00:13:28,880
those filter statements

00:13:25,680 --> 00:13:28,880
i've talked about we're still

00:13:29,200 --> 00:13:32,800
we're still supply we're still

00:13:31,279 --> 00:13:34,880
overwriting those things on

00:13:32,800 --> 00:13:36,320
every list view and every model form and

00:13:34,880 --> 00:13:40,000
every serialize and so on

00:13:36,320 --> 00:13:41,760
to make sure that it's very explicitly

00:13:40,000 --> 00:13:43,839
in our account base which client

00:13:41,760 --> 00:13:46,560
are we talking about which objects do we

00:13:43,839 --> 00:13:48,959
want to fetch from the database

00:13:46,560 --> 00:13:50,320
i'm not a fan of magic there are

00:13:48,959 --> 00:13:52,000
packages out there like django

00:13:50,320 --> 00:13:52,959
multi-tank which will do this for you

00:13:52,000 --> 00:13:56,160
magically

00:13:52,959 --> 00:13:57,680
you activate tenant and they will they

00:13:56,160 --> 00:13:59,519
they provide you with a model based

00:13:57,680 --> 00:14:01,279
class that injects into your models

00:13:59,519 --> 00:14:03,680
and model managers and automatically

00:14:01,279 --> 00:14:06,720
only returns the correct statements

00:14:03,680 --> 00:14:09,760
which can be convenient but i would say

00:14:06,720 --> 00:14:10,880
um might get really dangerous if you get

00:14:09,760 --> 00:14:12,800
used to the fact

00:14:10,880 --> 00:14:14,079
that everything is done for you and then

00:14:12,800 --> 00:14:16,320
you're in a

00:14:14,079 --> 00:14:18,399
weird place down below in the state

00:14:16,320 --> 00:14:20,880
where it doesn't do everything for you

00:14:18,399 --> 00:14:22,720
and then you forget the query so we're

00:14:20,880 --> 00:14:24,399
still training ourselves

00:14:22,720 --> 00:14:26,880
to put in all those finter filter

00:14:24,399 --> 00:14:30,079
statements and show with code review

00:14:26,880 --> 00:14:30,480
that they're in there uh because we

00:14:30,079 --> 00:14:33,760
believe

00:14:30,480 --> 00:14:36,079
explicit is better than implicit and

00:14:33,760 --> 00:14:38,320
we'd rather write all those statements

00:14:36,079 --> 00:14:41,040
and go through code review one more time

00:14:38,320 --> 00:14:43,519
than uh than miss one of them in a place

00:14:41,040 --> 00:14:46,959
where we can't miss it

00:14:43,519 --> 00:14:47,360
see this is what we've done all the time

00:14:46,959 --> 00:14:48,880
it's

00:14:47,360 --> 00:14:50,480
still in there as our first layer of

00:14:48,880 --> 00:14:52,639
protection but it's nothing new

00:14:50,480 --> 00:14:54,399
the thing uh the first thing that we

00:14:52,639 --> 00:14:55,680
added was our second layer we wanted to

00:14:54,399 --> 00:14:58,079
have a fallback

00:14:55,680 --> 00:14:59,440
so if we ever were to forgot one of

00:14:58,079 --> 00:15:00,880
those statements again

00:14:59,440 --> 00:15:03,600
it wouldn't have catastrophic

00:15:00,880 --> 00:15:07,199
consequences and the outcome of this

00:15:03,600 --> 00:15:08,000
is django scopes djangoscopes is a

00:15:07,199 --> 00:15:11,600
package

00:15:08,000 --> 00:15:13,440
that allows you to annotate

00:15:11,600 --> 00:15:14,800
your django models with information

00:15:13,440 --> 00:15:17,680
about how they are

00:15:14,800 --> 00:15:19,199
related to your tenants for example

00:15:17,680 --> 00:15:21,040
revisiting the

00:15:19,199 --> 00:15:22,959
the model structure from earlier if you

00:15:21,040 --> 00:15:25,279
have a client model and a product model

00:15:22,959 --> 00:15:28,160
you would use a custom model manager for

00:15:25,279 --> 00:15:30,160
your default manager objects

00:15:28,160 --> 00:15:31,360
that is a scoped manager from

00:15:30,160 --> 00:15:33,360
djangoscopes

00:15:31,360 --> 00:15:34,480
and you you tell the two things first of

00:15:33,360 --> 00:15:37,279
all you tell it that

00:15:34,480 --> 00:15:38,240
your tenants are called clients you

00:15:37,279 --> 00:15:40,360
could have

00:15:38,240 --> 00:15:42,480
gynoscopes would allow you to have

00:15:40,360 --> 00:15:43,920
multi-dimensional clients but that's not

00:15:42,480 --> 00:15:47,360
a topic for today

00:15:43,920 --> 00:15:47,680
and um the second thing that you tell it

00:15:47,360 --> 00:15:51,120
is

00:15:47,680 --> 00:15:52,320
uh how it finds the client if it has a

00:15:51,120 --> 00:15:55,440
product object so you

00:15:52,320 --> 00:15:57,199
say you tell it which field is the

00:15:55,440 --> 00:15:59,839
foreign key to the italian mob

00:15:57,199 --> 00:16:00,720
this could also be a foreign key across

00:15:59,839 --> 00:16:02,880
multiple hops

00:16:00,720 --> 00:16:04,560
using the common underscore underscore

00:16:02,880 --> 00:16:05,920
mckinnotation that they can use in

00:16:04,560 --> 00:16:09,279
django

00:16:05,920 --> 00:16:10,240
and then um once this scope manager is

00:16:09,279 --> 00:16:13,519
activated

00:16:10,240 --> 00:16:14,880
if you try to fetch all products from

00:16:13,519 --> 00:16:17,600
the database

00:16:14,880 --> 00:16:18,000
it will just blow up and it will show

00:16:17,600 --> 00:16:21,040
you

00:16:18,000 --> 00:16:22,720
an exception scope error a scope on

00:16:21,040 --> 00:16:23,360
dimension client needs to be active for

00:16:22,720 --> 00:16:26,240
this query

00:16:23,360 --> 00:16:27,680
we don't know which client you want so

00:16:26,240 --> 00:16:29,440
we're better

00:16:27,680 --> 00:16:32,639
we're better off just returning nothing

00:16:29,440 --> 00:16:32,639
and throwing an exception

00:16:32,800 --> 00:16:38,480
if you do want the data for a specific

00:16:36,399 --> 00:16:40,320
client you need to activate a scope

00:16:38,480 --> 00:16:42,560
you need to use a context manager called

00:16:40,320 --> 00:16:44,320
scope and tell the context manager

00:16:42,560 --> 00:16:46,639
which client is the currently active

00:16:44,320 --> 00:16:48,160
client and while that context manager is

00:16:46,639 --> 00:16:49,839
active

00:16:48,160 --> 00:16:52,240
django scopes will hook into all your

00:16:49,839 --> 00:16:54,320
queries and make sure

00:16:52,240 --> 00:16:56,480
that you're filtering for that client

00:16:54,320 --> 00:16:59,600
for example but but as i said

00:16:56,480 --> 00:17:01,199
we will still kind of write the filter

00:16:59,600 --> 00:17:04,400
statements in there

00:17:01,199 --> 00:17:06,400
um if you do

00:17:04,400 --> 00:17:08,160
forget to write the filter statement

00:17:06,400 --> 00:17:09,280
djangoscopes will edit for you

00:17:08,160 --> 00:17:11,520
automatically

00:17:09,280 --> 00:17:12,400
but something we don't rely on but it

00:17:11,520 --> 00:17:15,919
was easier

00:17:12,400 --> 00:17:18,319
to make it implicitly filter than

00:17:15,919 --> 00:17:19,600
to throw an exception we might change

00:17:18,319 --> 00:17:22,720
this at some point

00:17:19,600 --> 00:17:24,400
um to to just

00:17:22,720 --> 00:17:25,760
throwing an exception if the the filter

00:17:24,400 --> 00:17:27,679
statement is not in there but we wanted

00:17:25,760 --> 00:17:30,960
to prevent false positives

00:17:27,679 --> 00:17:31,520
uh from from parsing the the sick light

00:17:30,960 --> 00:17:33,360
so if

00:17:31,520 --> 00:17:34,880
the library isn't sure whether the

00:17:33,360 --> 00:17:37,600
filter statement is in there

00:17:34,880 --> 00:17:39,440
it just adds it in there as a protective

00:17:37,600 --> 00:17:42,080
measure

00:17:39,440 --> 00:17:43,840
of course you can also run queries

00:17:42,080 --> 00:17:45,440
across multiple tenants for example you

00:17:43,840 --> 00:17:47,919
can use the context manager

00:17:45,440 --> 00:17:49,520
to activate multiple clients at the same

00:17:47,919 --> 00:17:51,280
time

00:17:49,520 --> 00:17:53,120
if you have a piece of code very pretty

00:17:51,280 --> 00:17:54,080
sure that you either want to access all

00:17:53,120 --> 00:17:57,760
the tenants or

00:17:54,080 --> 00:17:59,200
that you um that you verified it very

00:17:57,760 --> 00:18:01,440
very thoroughly and there's

00:17:59,200 --> 00:18:03,440
performance impact of gender scopes

00:18:01,440 --> 00:18:06,320
which rarely happens

00:18:03,440 --> 00:18:06,799
might happen and then you can disable it

00:18:06,320 --> 00:18:09,360
either

00:18:06,799 --> 00:18:10,240
also through a content manager or

00:18:09,360 --> 00:18:13,039
through

00:18:10,240 --> 00:18:15,679
um a function decorator scopes disabled

00:18:13,039 --> 00:18:16,400
and within that that function everything

00:18:15,679 --> 00:18:18,960
behave

00:18:16,400 --> 00:18:21,120
like if djangoscopes wasn't installed at

00:18:18,960 --> 00:18:21,120
all

00:18:21,360 --> 00:18:24,559
so this all sounds very inconvenient it

00:18:24,240 --> 00:18:26,559
re

00:18:24,559 --> 00:18:28,559
adding all those context measures all of

00:18:26,559 --> 00:18:29,120
your code base sounds like a lot of work

00:18:28,559 --> 00:18:30,880
and

00:18:29,120 --> 00:18:34,080
cluttering your code base well the thing

00:18:30,880 --> 00:18:36,320
is it doesn't

00:18:34,080 --> 00:18:39,120
um it's very easy to integrate because

00:18:36,320 --> 00:18:41,600
in in most projects you will know

00:18:39,120 --> 00:18:43,919
which clients data you're going to

00:18:41,600 --> 00:18:44,160
access based on the url being accessed

00:18:43,919 --> 00:18:46,799
or

00:18:44,160 --> 00:18:47,840
the user being logged in and so on so

00:18:46,799 --> 00:18:50,000
what we did is

00:18:47,840 --> 00:18:51,360
we implemented a middleware we call it

00:18:50,000 --> 00:18:54,240
scoping middleware

00:18:51,360 --> 00:18:57,200
that figures out which client this

00:18:54,240 --> 00:18:59,679
request belongs to and that activates

00:18:57,200 --> 00:19:02,400
the scope for the whole runtime of the

00:18:59,679 --> 00:19:02,400
jungle view

00:19:03,200 --> 00:19:07,200
now if we look at the other things that

00:19:05,520 --> 00:19:09,520
we identified as the more

00:19:07,200 --> 00:19:11,360
invisible problems are before for

00:19:09,520 --> 00:19:13,440
example like a model form

00:19:11,360 --> 00:19:14,559
just declaring a model form like we did

00:19:13,440 --> 00:19:17,200
before we're saying

00:19:14,559 --> 00:19:18,240
when i have a form for that model and it

00:19:17,200 --> 00:19:21,520
has a foreign key

00:19:18,240 --> 00:19:23,280
on will give you a scope error you can

00:19:21,520 --> 00:19:25,520
no longer declare this way and

00:19:23,280 --> 00:19:27,120
will it will find all those problems in

00:19:25,520 --> 00:19:28,640
your code base immediately after you

00:19:27,120 --> 00:19:30,240
install django scopes

00:19:28,640 --> 00:19:32,000
and try to run your project the first

00:19:30,240 --> 00:19:34,799
time um

00:19:32,000 --> 00:19:36,240
and the way around it is to add in a

00:19:34,799 --> 00:19:38,640
custom field class

00:19:36,240 --> 00:19:40,320
but we had called safe model choice

00:19:38,640 --> 00:19:43,360
field and there's also a safe

00:19:40,320 --> 00:19:43,679
model multiple choice field and then um

00:19:43,360 --> 00:19:45,440
so

00:19:43,679 --> 00:19:47,360
safe model shows field does two things

00:19:45,440 --> 00:19:50,559
it prevents django scopes

00:19:47,360 --> 00:19:53,120
from throwing an exception and

00:19:50,559 --> 00:19:54,080
um it limits the default query set of

00:19:53,120 --> 00:19:57,200
that field

00:19:54,080 --> 00:19:58,400
to an empty query sensor will return no

00:19:57,200 --> 00:20:00,799
data at all and you

00:19:58,400 --> 00:20:02,320
now need to go in overwrite the init

00:20:00,799 --> 00:20:06,480
function and set your own queries

00:20:02,320 --> 00:20:08,720
the way you like it um

00:20:06,480 --> 00:20:11,200
another really good example of where

00:20:08,720 --> 00:20:14,240
this becomes relevant is potential shell

00:20:11,200 --> 00:20:15,600
um we all don't like

00:20:14,240 --> 00:20:17,760
working on the django shell in

00:20:15,600 --> 00:20:19,520
production but we all know it happens

00:20:17,760 --> 00:20:21,039
and also there it's really easy to

00:20:19,520 --> 00:20:22,640
forget a filter statement and

00:20:21,039 --> 00:20:24,640
access data for the wrong client or

00:20:22,640 --> 00:20:27,440
delete data over the wrong client

00:20:24,640 --> 00:20:28,159
so you can also use django scopes there

00:20:27,440 --> 00:20:31,520
and

00:20:28,159 --> 00:20:34,320
um in our project we have a

00:20:31,520 --> 00:20:36,159
shell scoped command that allows you to

00:20:34,320 --> 00:20:36,960
get a django shell where the scope is

00:20:36,159 --> 00:20:38,480
restricted

00:20:36,960 --> 00:20:40,720
to a specific client and you won't be

00:20:38,480 --> 00:20:42,640
able to access data for the clients

00:20:40,720 --> 00:20:44,000
this is currently not part of django

00:20:42,640 --> 00:20:45,360
scopes but

00:20:44,000 --> 00:20:47,200
something we took over from the

00:20:45,360 --> 00:20:49,280
pre-talks project and there's a blog

00:20:47,200 --> 00:20:51,760
post here that describes how to

00:20:49,280 --> 00:20:53,039
integrate this shell-scoped parameter

00:20:51,760 --> 00:20:55,440
into your own

00:20:53,039 --> 00:20:55,440
project

00:20:56,640 --> 00:21:01,520
so how is this working in the real world

00:20:59,120 --> 00:21:02,000
integrating django scopes into pre-tix

00:21:01,520 --> 00:21:04,080
our main

00:21:02,000 --> 00:21:05,600
project with at the time fifty five

00:21:04,080 --> 00:21:06,080
thousand lines of prediction changing

00:21:05,600 --> 00:21:08,080
code

00:21:06,080 --> 00:21:09,280
was around three hours of work so not a

00:21:08,080 --> 00:21:10,960
lot at all

00:21:09,280 --> 00:21:12,720
it was a little bit more tedious to

00:21:10,960 --> 00:21:16,159
integrate into our test suite

00:21:12,720 --> 00:21:18,960
um but the full time from

00:21:16,159 --> 00:21:21,039
djangoscope being a library ready to use

00:21:18,960 --> 00:21:23,280
and djangoscope being fully

00:21:21,039 --> 00:21:25,280
integrated into pretext and running in

00:21:23,280 --> 00:21:27,120
production or still on the order of two

00:21:25,280 --> 00:21:28,960
or three days

00:21:27,120 --> 00:21:30,320
so it's really easy if you have a

00:21:28,960 --> 00:21:31,440
multi-tenant project to add in

00:21:30,320 --> 00:21:34,720
djangoscopes just

00:21:31,440 --> 00:21:37,600
as a safety layer so you know so you

00:21:34,720 --> 00:21:38,799
know whenever you write a model form or

00:21:37,600 --> 00:21:42,799
serializer that

00:21:38,799 --> 00:21:44,720
but uses a too broad query set

00:21:42,799 --> 00:21:46,080
it will just fail and whenever you

00:21:44,720 --> 00:21:49,840
forget the filter statement

00:21:46,080 --> 00:21:49,840
it will automatically be added

00:21:50,400 --> 00:21:54,240
but i wouldn't call a two-layer approach

00:21:52,960 --> 00:21:57,440
defensive depth

00:21:54,240 --> 00:22:00,000
already so there's of course third layer

00:21:57,440 --> 00:22:00,799
third layer is to verify that you're

00:22:00,000 --> 00:22:03,679
actually not

00:22:00,799 --> 00:22:04,320
leaking data and there are multiple

00:22:03,679 --> 00:22:08,000
ideas

00:22:04,320 --> 00:22:11,280
on how to do this for example you could

00:22:08,000 --> 00:22:13,280
log queries to your database maybe not

00:22:11,280 --> 00:22:15,280
all of them but most databases have an

00:22:13,280 --> 00:22:17,679
option to for example log

00:22:15,280 --> 00:22:18,480
two percent or three percent of the

00:22:17,679 --> 00:22:20,799
queries

00:22:18,480 --> 00:22:21,919
to text file and then you could parse

00:22:20,799 --> 00:22:24,799
them back and

00:22:21,919 --> 00:22:25,679
check if there's actually a filter for a

00:22:24,799 --> 00:22:27,679
client in there

00:22:25,679 --> 00:22:29,280
and if it's not you could trigger an

00:22:27,679 --> 00:22:30,240
alert you have an engineer check what's

00:22:29,280 --> 00:22:32,240
going on

00:22:30,240 --> 00:22:34,240
or you could have something on one of

00:22:32,240 --> 00:22:36,480
the levels either in the database or

00:22:34,240 --> 00:22:38,480
in your django code or somewhere else

00:22:36,480 --> 00:22:40,480
that looks at result sizes and whenever

00:22:38,480 --> 00:22:42,559
you get a result from the database big

00:22:40,480 --> 00:22:44,320
that has a lot more records than the

00:22:42,559 --> 00:22:46,159
largest of your clients has

00:22:44,320 --> 00:22:47,919
then there's probably something going

00:22:46,159 --> 00:22:50,960
wrong

00:22:47,919 --> 00:22:53,120
or you could have a honeypot clients in

00:22:50,960 --> 00:22:55,200
a database containing specific data

00:22:53,120 --> 00:22:56,880
and whenever that data passes out of

00:22:55,200 --> 00:22:58,400
your database into your application

00:22:56,880 --> 00:23:00,720
you can trigger an alert because that

00:22:58,400 --> 00:23:03,520
should usually not happen

00:23:00,720 --> 00:23:05,679
so these things rely a little bit on

00:23:03,520 --> 00:23:07,520
security by obscurity by the attacker

00:23:05,679 --> 00:23:10,000
not knowing how it works

00:23:07,520 --> 00:23:10,960
security biosecurity on its own is a

00:23:10,000 --> 00:23:13,840
concept that should

00:23:10,960 --> 00:23:15,120
absolutely be avoided but security by

00:23:13,840 --> 00:23:17,280
obscurity as part

00:23:15,120 --> 00:23:19,120
of this defense and depth strategy can

00:23:17,280 --> 00:23:22,080
be really really valuable

00:23:19,120 --> 00:23:23,760
and unfortunately this also means that

00:23:22,080 --> 00:23:24,480
i'm not gonna tell you in too much

00:23:23,760 --> 00:23:26,320
detail on

00:23:24,480 --> 00:23:27,520
how we implemented these because if an

00:23:26,320 --> 00:23:29,919
attacker would know

00:23:27,520 --> 00:23:31,760
in very much detail they could probably

00:23:29,919 --> 00:23:33,120
structure their attack in a way that

00:23:31,760 --> 00:23:36,880
doesn't trigger

00:23:33,120 --> 00:23:37,679
um those and it doesn't trigger those

00:23:36,880 --> 00:23:39,440
detections

00:23:37,679 --> 00:23:41,279
but i just wanted to to give you the

00:23:39,440 --> 00:23:42,960
idea that um

00:23:41,279 --> 00:23:44,400
in addition to general scopes there's

00:23:42,960 --> 00:23:46,400
even more you can do

00:23:44,400 --> 00:23:48,320
and you can get creative there and do

00:23:46,400 --> 00:23:51,360
something that allows you

00:23:48,320 --> 00:23:52,559
to notice when somebody tries when

00:23:51,360 --> 00:23:54,240
somebody found the security

00:23:52,559 --> 00:23:57,840
vulnerability in the application

00:23:54,240 --> 00:24:01,840
and tries to actually pull the data out

00:23:57,840 --> 00:24:04,320
so this brings me to the end of my talk

00:24:01,840 --> 00:24:06,000
as i said i'm going to be around live

00:24:04,320 --> 00:24:08,000
for questions

00:24:06,000 --> 00:24:10,960
if you have questions later on you can

00:24:08,000 --> 00:24:14,000
reach me by email or on twitter

00:24:10,960 --> 00:24:15,039
you can also find more and more about

00:24:14,000 --> 00:24:18,480
our project

00:24:15,039 --> 00:24:21,760
on prettys.eu or the pretex github page

00:24:18,480 --> 00:24:23,520
and yeah i'd love to hear from you

00:24:21,760 --> 00:24:24,799
about your ideas on how to secure

00:24:23,520 --> 00:24:33,440
multi-tenant data

00:24:24,799 --> 00:24:33,440

YouTube URL: https://www.youtube.com/watch?v=B6G2xbiCji0


