Title: DjangoCon 2020 | The Design and Development of Choices in Django 3.0 - Shai Berger
Publication date: 2020-09-30
Playlist: DjangoCon Europe 2020 (Virtual)
Description: 
	DjangoCon Europe 2020 (Virtual)
September 19, 2020 - 16h30 (GMT+1)

"The Design and Development of Choices in Django 3.0" by Shai Berger

The story of how the Choices feature in Django 3.0 came to be, and how we met challenges of design, implementation, and the project's process. A peek "behind the curtains"(*) of Django development - from discussions and proof-of-concept to a merged PR - and some lessons learned. (*) It's all public
Captions: 
	00:00:09,440 --> 00:00:14,920
hello

00:00:11,280 --> 00:00:17,039
and welcome to my talk

00:00:14,920 --> 00:00:17,840
choices were one of the highlighted

00:00:17,039 --> 00:00:21,359
features

00:00:17,840 --> 00:00:23,279
of the django 3.0 release and i want to

00:00:21,359 --> 00:00:24,240
tell you about how the feature came to

00:00:23,279 --> 00:00:26,480
be

00:00:24,240 --> 00:00:28,880
and about issues we ran into in its

00:00:26,480 --> 00:00:30,560
design and implementation

00:00:28,880 --> 00:00:33,199
i hope we can learn some things from

00:00:30,560 --> 00:00:33,199
this story

00:00:37,040 --> 00:00:41,600
my name is shy belgian i'm a django

00:00:39,760 --> 00:00:43,760
security team member

00:00:41,600 --> 00:00:45,360
i used to be a django core developer for

00:00:43,760 --> 00:00:47,520
a few years

00:00:45,360 --> 00:00:49,440
i've been using python for more than 20

00:00:47,520 --> 00:00:51,920
years and i've been working as a

00:00:49,440 --> 00:00:54,719
programmer for 30.

00:00:51,920 --> 00:00:55,120
here in israel i work at a small company

00:00:54,719 --> 00:00:57,280
called

00:00:55,120 --> 00:00:58,879
kaplan open source consulting that's the

00:00:57,280 --> 00:01:00,960
orange logo

00:00:58,879 --> 00:01:02,719
and i volunteer at the israeli free and

00:01:00,960 --> 00:01:05,280
open source software association

00:01:02,719 --> 00:01:05,280
hamaco

00:01:07,680 --> 00:01:10,799
just to make sure we are on the same

00:01:09,439 --> 00:01:13,840
page

00:01:10,799 --> 00:01:16,720
let's see what we're discussing

00:01:13,840 --> 00:01:19,040
choices as a feature of fields have been

00:01:16,720 --> 00:01:21,040
there for a very long time

00:01:19,040 --> 00:01:22,080
and you specify them with a sequence of

00:01:21,040 --> 00:01:24,560
pairs

00:01:22,080 --> 00:01:25,360
where each pair sets the value and the

00:01:24,560 --> 00:01:28,080
label or

00:01:25,360 --> 00:01:30,079
presentation for a possible choice for

00:01:28,080 --> 00:01:32,079
the field

00:01:30,079 --> 00:01:33,119
if you also wanted constants for the

00:01:32,079 --> 00:01:35,439
values

00:01:33,119 --> 00:01:37,040
you needed to define them separately

00:01:35,439 --> 00:01:39,119
leading to code like you see on the

00:01:37,040 --> 00:01:42,159
screen now

00:01:39,119 --> 00:01:43,840
many people thought that this was

00:01:42,159 --> 00:01:47,360
violating diy

00:01:43,840 --> 00:01:47,360
and generally looks ugly

00:01:48,159 --> 00:01:54,159
in django 3.0 we added choices types

00:01:52,320 --> 00:01:55,520
which allow you to put the constant

00:01:54,159 --> 00:01:59,040
names values

00:01:55,520 --> 00:02:02,079
and labels all in one place by defining

00:01:59,040 --> 00:02:02,079
a kind of a number

00:02:03,119 --> 00:02:08,239
when you use such a type you also get an

00:02:06,079 --> 00:02:09,759
option to have the labels generated from

00:02:08,239 --> 00:02:12,319
your constant names

00:02:09,759 --> 00:02:14,319
if you don't need translation and some

00:02:12,319 --> 00:02:17,360
other features of the enum class from

00:02:14,319 --> 00:02:17,360
the standard library

00:02:18,239 --> 00:02:23,840
so how did we get here

00:02:24,319 --> 00:02:28,560
as i said a lot of people for a very

00:02:27,280 --> 00:02:30,239
long time

00:02:28,560 --> 00:02:32,480
were not happy with the way you had to

00:02:30,239 --> 00:02:36,319
define choices in django

00:02:32,480 --> 00:02:39,519
so they built their own classes

00:02:36,319 --> 00:02:42,319
sorry one important example

00:02:39,519 --> 00:02:45,120
was tom forbes django choice object

00:02:42,319 --> 00:02:47,040
which was published in 2013

00:02:45,120 --> 00:02:48,480
and was not using the stand library in

00:02:47,040 --> 00:02:52,239
num classes

00:02:48,480 --> 00:02:52,239
because it came before them

00:02:55,760 --> 00:02:59,680
the history of the feature in django

00:02:58,239 --> 00:03:02,720
begins with a ticket

00:02:59,680 --> 00:03:05,200
opened in march of 2017

00:03:02,720 --> 00:03:07,519
asking for numbs to be used to specify

00:03:05,200 --> 00:03:10,480
choices on fields

00:03:07,519 --> 00:03:11,440
django 1.11 had not yet been released at

00:03:10,480 --> 00:03:14,159
this point

00:03:11,440 --> 00:03:14,800
but was already feature frozen so the

00:03:14,159 --> 00:03:18,959
suggestion

00:03:14,800 --> 00:03:21,920
targeted django 2.0 as you may recall

00:03:18,959 --> 00:03:22,879
2.0 was the first release to be python 3

00:03:21,920 --> 00:03:25,120
only

00:03:22,879 --> 00:03:27,120
and so it was suitable for a feature

00:03:25,120 --> 00:03:30,000
relying on the part of the python 3

00:03:27,120 --> 00:03:30,000
standard library

00:03:31,680 --> 00:03:35,840
the suggestion itself however was a

00:03:34,159 --> 00:03:38,480
little naive

00:03:35,840 --> 00:03:40,799
asking for a numbers to be used directly

00:03:38,480 --> 00:03:44,400
and for labels to be always generated

00:03:40,799 --> 00:03:47,280
from the num member names it was pointed

00:03:44,400 --> 00:03:49,840
out immediately that this left no room

00:03:47,280 --> 00:03:55,200
for specifying translatable labels

00:03:49,840 --> 00:03:55,200
which for django is a strict requirement

00:03:56,959 --> 00:04:02,560
so the ticket was closed one fix over

00:03:59,920 --> 00:04:02,560
this issue

00:04:04,239 --> 00:04:09,519
five months after it was closed tom

00:04:07,360 --> 00:04:11,760
forbes from three slides ago

00:04:09,519 --> 00:04:12,799
showed up and posted a message on the

00:04:11,760 --> 00:04:14,799
ticket

00:04:12,799 --> 00:04:17,359
suggesting an api for adding

00:04:14,799 --> 00:04:19,759
translatable labels

00:04:17,359 --> 00:04:20,959
this api was taken from django choice

00:04:19,759 --> 00:04:22,400
objects

00:04:20,959 --> 00:04:24,720
but tom did not link to his

00:04:22,400 --> 00:04:27,840
implementation and the ticket

00:04:24,720 --> 00:04:30,320
was already closed so basically nobody

00:04:27,840 --> 00:04:30,320
noticed

00:04:33,520 --> 00:04:40,720
in december of 2018 i was working on my

00:04:37,440 --> 00:04:43,440
first major python 3 only django project

00:04:40,720 --> 00:04:45,199
this project had choices which also

00:04:43,440 --> 00:04:46,960
needed to be translated

00:04:45,199 --> 00:04:49,840
and i joined the ranks of people who

00:04:46,960 --> 00:04:54,080
looked at the issue and said

00:04:49,840 --> 00:04:54,080
maybe we could use enums for this

00:04:54,639 --> 00:05:02,000
i looked around found the closed ticket

00:04:58,160 --> 00:05:05,919
saw tom's suggestion and inspired by it

00:05:02,000 --> 00:05:08,240
i found a way to implement it with enums

00:05:05,919 --> 00:05:10,639
i presented a proof of concept on the

00:05:08,240 --> 00:05:15,199
django developers mailing list

00:05:10,639 --> 00:05:17,039
right on new year's eve saying basically

00:05:15,199 --> 00:05:19,600
we can restore him we have the

00:05:17,039 --> 00:05:19,600
technology

00:05:21,520 --> 00:05:26,479
the reaction was mostly positive but

00:05:24,479 --> 00:05:28,400
there was also a major objection

00:05:26,479 --> 00:05:29,840
which we'll discuss later as a design

00:05:28,400 --> 00:05:32,160
issue

00:05:29,840 --> 00:05:33,039
the discussion went on for about two

00:05:32,160 --> 00:05:36,160
weeks

00:05:33,039 --> 00:05:38,960
and then it died out i was busy

00:05:36,160 --> 00:05:40,560
i guess others were busy too and that's

00:05:38,960 --> 00:05:43,680
the way it stayed

00:05:40,560 --> 00:05:46,880
until djangocon europe

00:05:43,680 --> 00:05:49,919
which was in april

00:05:46,880 --> 00:05:51,600
when i went to djangocon in copenhagen i

00:05:49,919 --> 00:05:52,479
already planned to work on the numbers

00:05:51,600 --> 00:05:55,919
for choices

00:05:52,479 --> 00:05:57,039
in the sprints i talked to people there

00:05:55,919 --> 00:06:00,479
about it

00:05:57,039 --> 00:06:03,680
i managed to get the ticket reopened

00:06:00,479 --> 00:06:05,440
and indeed i spent the sprints fleshing

00:06:03,680 --> 00:06:08,960
out the proof of concept

00:06:05,440 --> 00:06:11,680
to an initial pull request

00:06:08,960 --> 00:06:13,600
at this point we still saw this as

00:06:11,680 --> 00:06:21,120
mostly about enums

00:06:13,600 --> 00:06:23,199
and we still saw it as a minor feature

00:06:21,120 --> 00:06:24,479
with the pr available others got

00:06:23,199 --> 00:06:27,759
involved

00:06:24,479 --> 00:06:29,600
the pr got reviews i'm not naming all

00:06:27,759 --> 00:06:31,680
the people who participated and i hope

00:06:29,600 --> 00:06:34,479
they'll forgive me

00:06:31,680 --> 00:06:35,520
for about a month i was responding to

00:06:34,479 --> 00:06:38,960
comments properly

00:06:35,520 --> 00:06:40,160
and adding fixes but then i got very

00:06:38,960 --> 00:06:43,280
busy again

00:06:40,160 --> 00:06:45,360
and at some point i just said i need

00:06:43,280 --> 00:06:49,840
help with this

00:06:45,360 --> 00:06:49,840
if anyone wants to take over please do

00:06:49,919 --> 00:06:55,599
at mario's felicia suggestion nick pope

00:06:53,520 --> 00:06:59,120
took over development of the future

00:06:55,599 --> 00:07:02,160
in july 2019.

00:06:59,120 --> 00:07:03,280
nick did lots of more work handling

00:07:02,160 --> 00:07:05,440
issues

00:07:03,280 --> 00:07:07,199
polishing the code and improving the

00:07:05,440 --> 00:07:10,080
documentation

00:07:07,199 --> 00:07:12,479
the way it looks now is more next doing

00:07:10,080 --> 00:07:15,360
than mine

00:07:12,479 --> 00:07:16,639
at some point the class name was changed

00:07:15,360 --> 00:07:19,199
to choices

00:07:16,639 --> 00:07:19,759
with subclasses integer choices and text

00:07:19,199 --> 00:07:22,080
choices

00:07:19,759 --> 00:07:23,680
for the most common commonly used value

00:07:22,080 --> 00:07:25,759
types

00:07:23,680 --> 00:07:28,240
the change was made in order to

00:07:25,759 --> 00:07:30,720
de-emphasize the connection to innam

00:07:28,240 --> 00:07:31,919
because at that point we realized that

00:07:30,720 --> 00:07:34,000
enamels were a tool

00:07:31,919 --> 00:07:36,639
and not so essential in the definition

00:07:34,000 --> 00:07:36,639
of the future

00:07:39,599 --> 00:07:45,120
in september choices were declared one

00:07:42,720 --> 00:07:47,680
of the highlights of the coming release

00:07:45,120 --> 00:07:50,479
and merged into django's master branch

00:07:47,680 --> 00:07:52,879
on september 4th

00:07:50,479 --> 00:07:54,720
after one more bump in the road a bug

00:07:52,879 --> 00:07:56,479
that was found in the beta and will be

00:07:54,720 --> 00:07:58,879
discussed later

00:07:56,479 --> 00:08:00,240
the feature was released as part of

00:07:58,879 --> 00:08:04,210
jungle 3.0

00:08:00,240 --> 00:08:07,310
on december 2nd 2019.

00:08:04,210 --> 00:08:07,310
[Music]

00:08:10,840 --> 00:08:16,800
yay

00:08:12,800 --> 00:08:19,360
so in the process

00:08:16,800 --> 00:08:20,000
of getting this feature accepted into

00:08:19,360 --> 00:08:23,120
django

00:08:20,000 --> 00:08:23,840
and developed we ran into several design

00:08:23,120 --> 00:08:27,840
issues

00:08:23,840 --> 00:08:27,840
which i would like to share with you now

00:08:28,960 --> 00:08:33,680
the first objection raised against the

00:08:31,360 --> 00:08:33,680
use of

00:08:39,120 --> 00:08:43,839
and give its inaudib values then the

00:08:41,760 --> 00:08:45,600
enum numbers don't compare equal to

00:08:43,839 --> 00:08:47,600
these values

00:08:45,600 --> 00:08:49,760
for a type that is supposed to provide

00:08:47,600 --> 00:08:54,160
values to fill fields

00:08:49,760 --> 00:08:57,440
that is a very bad property

00:08:54,160 --> 00:08:59,440
but as it turns out if you use enums in

00:08:57,440 --> 00:09:02,720
a slightly different way

00:08:59,440 --> 00:09:03,360
adding a base type then the equality

00:09:02,720 --> 00:09:07,120
issue

00:09:03,360 --> 00:09:09,120
is resolved and with it a small set of

00:09:07,120 --> 00:09:13,120
related issues

00:09:09,120 --> 00:09:13,120
the objection was overcome

00:09:15,120 --> 00:09:19,920
enough can surprise you and when people

00:09:18,320 --> 00:09:23,040
usually think of them

00:09:19,920 --> 00:09:25,440
they don't think of using base types

00:09:23,040 --> 00:09:27,040
among other reasons because the standard

00:09:25,440 --> 00:09:30,080
library documentation

00:09:27,040 --> 00:09:33,120
recommends against it but

00:09:30,080 --> 00:09:35,120
this recommendation has an exception

00:09:33,120 --> 00:09:36,399
for the case where you need to support

00:09:35,120 --> 00:09:39,440
interoperability

00:09:36,399 --> 00:09:42,399
with other systems which is exactly the

00:09:39,440 --> 00:09:44,800
django use case

00:09:42,399 --> 00:09:46,560
we also had to modify some other details

00:09:44,800 --> 00:09:49,680
of the behavior of vinoms

00:09:46,560 --> 00:09:50,720
to make them fit jungle well but all in

00:09:49,680 --> 00:09:53,040
all

00:09:50,720 --> 00:09:54,000
it was best to rely on the familiarity

00:09:53,040 --> 00:09:57,200
and good design

00:09:54,000 --> 00:09:57,200
of the standard library

00:09:57,760 --> 00:10:01,360
nick popp summarized it very well in a

00:10:00,800 --> 00:10:03,920
comment

00:10:01,360 --> 00:10:05,839
on one of the pull requests saying we

00:10:03,920 --> 00:10:08,959
are providing a choices type

00:10:05,839 --> 00:10:12,240
that is in unlike and unbacked but has

00:10:08,959 --> 00:10:12,240
to make its own rules

00:10:14,880 --> 00:10:18,320
another issue we had to deal with was

00:10:17,040 --> 00:10:21,279
the empty choice

00:10:18,320 --> 00:10:23,279
that is specifying the label for nothing

00:10:21,279 --> 00:10:26,320
being chosen

00:10:23,279 --> 00:10:28,399
with a traditional list of pairs this

00:10:26,320 --> 00:10:29,760
was done by attaching a label to the

00:10:28,399 --> 00:10:32,560
value none

00:10:29,760 --> 00:10:34,880
but with an imam with a base type we

00:10:32,560 --> 00:10:37,519
couldn't do the obvious analog

00:10:34,880 --> 00:10:38,480
because the members of such a nums must

00:10:37,519 --> 00:10:42,480
have values

00:10:38,480 --> 00:10:44,240
of the base type we considered several

00:10:42,480 --> 00:10:47,440
options

00:10:44,240 --> 00:10:50,880
one was to designate a specific value

00:10:47,440 --> 00:10:52,720
to mark empty that is say you're making

00:10:50,880 --> 00:10:54,399
an integer choices

00:10:52,720 --> 00:10:56,320
pick some numbers that isn't one of the

00:10:54,399 --> 00:11:00,000
real choices 0

00:10:56,320 --> 00:11:03,279
or 2020 or any other number you don't

00:11:00,000 --> 00:11:05,680
like and use it to set the label for the

00:11:03,279 --> 00:11:08,079
empty choice

00:11:05,680 --> 00:11:08,720
another was to create a special base

00:11:08,079 --> 00:11:12,160
type

00:11:08,720 --> 00:11:15,600
where none is a valid value and use that

00:11:12,160 --> 00:11:18,480
instead of the real base types

00:11:15,600 --> 00:11:19,680
we found more palatable options when we

00:11:18,480 --> 00:11:21,519
remembered

00:11:19,680 --> 00:11:24,079
that we have some control over the

00:11:21,519 --> 00:11:25,839
values that go into the enum

00:11:24,079 --> 00:11:28,000
at the point where we take care of the

00:11:25,839 --> 00:11:31,279
labels we could check if the user

00:11:28,000 --> 00:11:33,519
specified some value as none and then

00:11:31,279 --> 00:11:35,040
pick its label and not pass it into

00:11:33,519 --> 00:11:37,440
their num

00:11:35,040 --> 00:11:38,959
and then we figured that instead of

00:11:37,440 --> 00:11:41,519
checking the value

00:11:38,959 --> 00:11:42,000
we could check the name if we set a

00:11:41,519 --> 00:11:45,279
special

00:11:42,000 --> 00:11:47,200
name for the empty choice then the user

00:11:45,279 --> 00:11:48,880
would not need to write none

00:11:47,200 --> 00:11:51,120
and we'd save them the trouble of

00:11:48,880 --> 00:11:54,000
finding a name for a constant

00:11:51,120 --> 00:11:57,839
that would never be used so that's what

00:11:54,000 --> 00:11:57,839
we did

00:11:59,920 --> 00:12:04,000
the last and most involved major design

00:12:02,880 --> 00:12:07,519
issue

00:12:04,000 --> 00:12:10,240
was about dunder str it was initially

00:12:07,519 --> 00:12:13,279
raised in the context of text choices

00:12:10,240 --> 00:12:15,519
which are themselves string values

00:12:13,279 --> 00:12:16,560
take for example the hearing school

00:12:15,519 --> 00:12:19,680
choices type

00:12:16,560 --> 00:12:20,880
we've seen earlier shortened here to yis

00:12:19,680 --> 00:12:24,079
on the right side

00:12:20,880 --> 00:12:27,440
to fit in the slide if we take

00:12:24,079 --> 00:12:28,639
one of its members say senior and cast

00:12:27,440 --> 00:12:32,160
it to a string

00:12:28,639 --> 00:12:34,079
what should we get the default

00:12:32,160 --> 00:12:37,360
implementation from enum

00:12:34,079 --> 00:12:37,360
is clearly unsuitable

00:12:37,680 --> 00:12:44,639
the options one option story suggested

00:12:41,040 --> 00:12:46,639
was to return the label since dunder str

00:12:44,639 --> 00:12:49,600
is supposed to return a human readable

00:12:46,639 --> 00:12:52,240
presentation of the object

00:12:49,600 --> 00:12:52,880
another option is to note that text

00:12:52,240 --> 00:12:56,000
choices

00:12:52,880 --> 00:12:59,360
inherits strings so its members are

00:12:56,000 --> 00:13:01,040
already strings so we must return the

00:12:59,360 --> 00:13:05,680
string we started with

00:13:01,040 --> 00:13:08,399
which is the value a variation on this

00:13:05,680 --> 00:13:11,200
is to return str of self-value for all

00:13:08,399 --> 00:13:11,200
choices types

00:13:11,680 --> 00:13:16,240
when i realized that both above

00:13:13,760 --> 00:13:19,200
arguments were valid

00:13:16,240 --> 00:13:21,760
i made a suggestion based on my favorite

00:13:19,200 --> 00:13:24,399
tenet of the zen of python

00:13:21,760 --> 00:13:26,320
in the face of ambiguity refuse the

00:13:24,399 --> 00:13:28,959
temptation to guess

00:13:26,320 --> 00:13:30,480
raise an exception and let the developer

00:13:28,959 --> 00:13:34,240
resolve it explicitly

00:13:30,480 --> 00:13:36,800
on a case-by-case basis

00:13:34,240 --> 00:13:38,560
the option not to provide text choices

00:13:36,800 --> 00:13:39,600
and let users run into the issues

00:13:38,560 --> 00:13:41,360
themselves

00:13:39,600 --> 00:13:43,920
was raised but never considered

00:13:41,360 --> 00:13:43,920
seriously

00:13:44,720 --> 00:13:50,160
the debate was left unresolved and the

00:13:47,839 --> 00:13:51,199
default enum implementation was left in

00:13:50,160 --> 00:13:54,079
place

00:13:51,199 --> 00:13:54,959
until a bug was raised during the beta

00:13:54,079 --> 00:13:57,040
by a user

00:13:54,959 --> 00:13:58,480
who put a value from a choice into a

00:13:57,040 --> 00:14:01,680
field and then

00:13:58,480 --> 00:14:02,000
had that rendered in a template this

00:14:01,680 --> 00:14:05,199
made

00:14:02,000 --> 00:14:07,120
us realize that choices are not objects

00:14:05,199 --> 00:14:09,360
to be used in their own right

00:14:07,120 --> 00:14:10,639
but just a way to pick values to put

00:14:09,360 --> 00:14:13,199
into fields

00:14:10,639 --> 00:14:16,160
and once those fields are i'm sorry and

00:14:13,199 --> 00:14:17,839
once those values are in fields

00:14:16,160 --> 00:14:19,760
they should behave as normally as

00:14:17,839 --> 00:14:22,240
possible

00:14:19,760 --> 00:14:24,160
especially for common functionality such

00:14:22,240 --> 00:14:27,199
as dunder str

00:14:24,160 --> 00:14:31,839
so we chose the strfs value for all

00:14:27,199 --> 00:14:31,839
choices types

00:14:33,600 --> 00:14:38,880
now let's talk about the implementation

00:14:36,800 --> 00:14:41,440
we are going to see some advanced python

00:14:38,880 --> 00:14:45,040
here and delve a little into things

00:14:41,440 --> 00:14:47,600
usually referred to as dark magic

00:14:45,040 --> 00:14:48,480
i hope i can make it clear enough and if

00:14:47,600 --> 00:14:50,720
not

00:14:48,480 --> 00:14:53,440
i hope to at least get you curious about

00:14:50,720 --> 00:14:53,440
these topics

00:14:56,959 --> 00:15:02,480
the main challenge of the implementation

00:15:00,399 --> 00:15:03,519
is to make a class based on the nam's

00:15:02,480 --> 00:15:06,399
enum

00:15:03,519 --> 00:15:09,360
such that a user who defines subclasses

00:15:06,399 --> 00:15:11,839
can add labels in their definitions

00:15:09,360 --> 00:15:13,760
we need the labels to not interfere with

00:15:11,839 --> 00:15:16,320
the definition of the enum

00:15:13,760 --> 00:15:18,720
but still be stored and made accessible

00:15:16,320 --> 00:15:18,720
later

00:15:20,880 --> 00:15:28,959
so we want to subclass in amazing

00:15:25,680 --> 00:15:29,759
but what we really want to modify is the

00:15:28,959 --> 00:15:32,800
subclass

00:15:29,759 --> 00:15:34,959
creation process to enable the creation

00:15:32,800 --> 00:15:36,079
of classes which are subclasses of our

00:15:34,959 --> 00:15:39,199
class

00:15:36,079 --> 00:15:42,399
and have special properties

00:15:39,199 --> 00:15:45,839
for this what we really need to inherit

00:15:42,399 --> 00:15:47,920
is the meta class in case you're not

00:15:45,839 --> 00:15:50,160
familiar with meta classes

00:15:47,920 --> 00:15:51,199
a proper introduction is out of scope

00:15:50,160 --> 00:15:54,320
for this talk

00:15:51,199 --> 00:15:55,120
but in a word classes in python are

00:15:54,320 --> 00:15:58,240
themselves

00:15:55,120 --> 00:16:00,399
objects instances of other classes

00:15:58,240 --> 00:16:01,600
and these latter classes are called meta

00:16:00,399 --> 00:16:03,800
classes

00:16:01,600 --> 00:16:06,160
and just like classes can control the

00:16:03,800 --> 00:16:09,120
initialization and behavior of their

00:16:06,160 --> 00:16:13,199
instances metaclasses can control the

00:16:09,120 --> 00:16:13,199
creation and behavior of classes

00:16:13,360 --> 00:16:17,040
in noms are defined with their own very

00:16:16,399 --> 00:16:19,600
special

00:16:17,040 --> 00:16:20,959
very intricate metaclass called innum

00:16:19,600 --> 00:16:23,759
meta

00:16:20,959 --> 00:16:25,759
we inherit this meta class mainly to

00:16:23,759 --> 00:16:28,480
override its dander new

00:16:25,759 --> 00:16:29,040
and when we inherit choices from a num

00:16:28,480 --> 00:16:32,160
the most

00:16:29,040 --> 00:16:37,839
important change we make is to use our

00:16:32,160 --> 00:16:41,040
own meta class

00:16:37,839 --> 00:16:43,680
so let's look at the details of this

00:16:41,040 --> 00:16:43,680
dunder new

00:16:44,160 --> 00:16:48,160
dundernew in metaclasses takes four

00:16:47,199 --> 00:16:50,639
arguments

00:16:48,160 --> 00:16:51,360
of which the most interesting is the

00:16:50,639 --> 00:16:54,240
last one

00:16:51,360 --> 00:16:56,000
called classdict it holds a mapping of

00:16:54,240 --> 00:16:57,199
names to all the objects defined in the

00:16:56,000 --> 00:17:00,800
class body

00:16:57,199 --> 00:17:03,839
methods class attributes and whatnot

00:17:00,800 --> 00:17:06,240
when our metaclass inherits a

00:17:03,839 --> 00:17:08,319
we get a special class dictionary with

00:17:06,240 --> 00:17:10,640
additional properties defined by our

00:17:08,319 --> 00:17:14,319
parent metaclass

00:17:10,640 --> 00:17:17,360
one of them is the list of member names

00:17:14,319 --> 00:17:19,360
when we say member here we mean one of

00:17:17,360 --> 00:17:22,240
the values of the innum

00:17:19,360 --> 00:17:23,839
when you define an enum subclass you can

00:17:22,240 --> 00:17:25,760
define enum members

00:17:23,839 --> 00:17:28,799
but you can also define methods and

00:17:25,760 --> 00:17:31,600
other things which are not members

00:17:28,799 --> 00:17:32,000
the innum meta class takes care to

00:17:31,600 --> 00:17:35,440
produce

00:17:32,000 --> 00:17:38,320
a list of just the member names

00:17:35,440 --> 00:17:39,679
we go over this list of names and for

00:17:38,320 --> 00:17:43,039
each one of them

00:17:39,679 --> 00:17:45,840
we pick up the value and we look at it

00:17:43,039 --> 00:17:46,960
we check if it looks like something that

00:17:45,840 --> 00:17:50,080
is a value

00:17:46,960 --> 00:17:51,120
with an added label that is if it's a

00:17:50,080 --> 00:17:53,760
sequence

00:17:51,120 --> 00:17:54,640
with more than one element and the last

00:17:53,760 --> 00:17:57,360
element

00:17:54,640 --> 00:17:58,400
look looks like a label it's either a

00:17:57,360 --> 00:18:00,880
string

00:17:58,400 --> 00:18:01,600
or a promise which is what you get if

00:18:00,880 --> 00:18:06,080
the user

00:18:01,600 --> 00:18:09,200
puts in a translatable string

00:18:06,080 --> 00:18:10,799
if this is the case we take the label of

00:18:09,200 --> 00:18:14,640
the value

00:18:10,799 --> 00:18:17,679
and live in it only the preceding parts

00:18:14,640 --> 00:18:20,160
otherwise we leave the value alone

00:18:17,679 --> 00:18:23,039
and generate a label from the key which

00:18:20,160 --> 00:18:23,039
is the member name

00:18:23,120 --> 00:18:27,679
the label goes into our list and the

00:18:26,000 --> 00:18:31,039
value without label

00:18:27,679 --> 00:18:32,559
goes back into the class dict

00:18:31,039 --> 00:18:34,400
when we have gone through all the

00:18:32,559 --> 00:18:36,720
members this way

00:18:34,400 --> 00:18:38,080
we take the clean that class dict and

00:18:36,720 --> 00:18:40,080
pass it up

00:18:38,080 --> 00:18:42,640
to the enum metaclass to generate the

00:18:40,080 --> 00:18:44,720
new subclass

00:18:42,640 --> 00:18:46,559
this is how we accomplish hiding the

00:18:44,720 --> 00:18:49,600
labels from the parent

00:18:46,559 --> 00:18:51,360
while collecting them for our own use

00:18:49,600 --> 00:18:54,840
but we are not done with the dunder new

00:18:51,360 --> 00:18:57,840
yet we still need to make the labels

00:18:54,840 --> 00:18:57,840
accessible

00:18:58,799 --> 00:19:05,200
so we have the list of labels

00:19:02,720 --> 00:19:06,480
ordered according to the order of enum

00:19:05,200 --> 00:19:09,120
members

00:19:06,480 --> 00:19:10,080
and from imnam we also get an inner

00:19:09,120 --> 00:19:13,600
dictionary

00:19:10,080 --> 00:19:16,240
value to member map in the same order

00:19:13,600 --> 00:19:16,880
we have everything we need to pair the

00:19:16,240 --> 00:19:20,880
labels

00:19:16,880 --> 00:19:21,679
with the members there were two ways

00:19:20,880 --> 00:19:25,039
suggested

00:19:21,679 --> 00:19:26,880
to make the connection one was to go

00:19:25,039 --> 00:19:29,840
over the members and labels

00:19:26,880 --> 00:19:32,559
and set each label as an attribute on

00:19:29,840 --> 00:19:35,039
the corresponding member

00:19:32,559 --> 00:19:37,120
the other was to build a dictionary

00:19:35,039 --> 00:19:39,440
mapping values to labels

00:19:37,120 --> 00:19:41,600
and give members the property to access

00:19:39,440 --> 00:19:41,600
it

00:19:42,320 --> 00:19:45,919
the map and property option was

00:19:44,240 --> 00:19:48,799
implemented first

00:19:45,919 --> 00:19:49,280
and to be frank the simpler attribute

00:19:48,799 --> 00:19:51,760
option

00:19:49,280 --> 00:19:53,679
never got the consideration it deserves

00:19:51,760 --> 00:19:56,080
as far as i can tell

00:19:53,679 --> 00:19:58,160
it was suggested on the pull request at

00:19:56,080 --> 00:19:59,919
the time when i was no longer responding

00:19:58,160 --> 00:20:02,799
properly to comments

00:19:59,919 --> 00:20:05,840
but before nick took over and there is

00:20:02,799 --> 00:20:08,400
no discussion of it

00:20:05,840 --> 00:20:09,760
that said i still believe that the

00:20:08,400 --> 00:20:12,960
option chosen

00:20:09,760 --> 00:20:14,159
was the right option because choices are

00:20:12,960 --> 00:20:16,720
generic

00:20:14,159 --> 00:20:17,919
and if a base type already has a label

00:20:16,720 --> 00:20:21,840
attribute

00:20:17,919 --> 00:20:21,840
there will be less breakage this way

00:20:26,080 --> 00:20:29,840
although a map and property sounds

00:20:28,799 --> 00:20:35,039
complex

00:20:29,840 --> 00:20:38,240
the implementation is very concise

00:20:35,039 --> 00:20:41,360
in this line zip treats both

00:20:38,240 --> 00:20:43,760
its arguments as iterable so

00:20:41,360 --> 00:20:44,799
from the value to member dictionary it

00:20:43,760 --> 00:20:48,159
gets the keys

00:20:44,799 --> 00:20:49,120
which are the inner member values as we

00:20:48,159 --> 00:20:51,919
noted

00:20:49,120 --> 00:20:53,360
the dictionary and the labels list have

00:20:51,919 --> 00:20:56,480
matching orders

00:20:53,360 --> 00:20:59,600
so this creates the right list of pairs

00:20:56,480 --> 00:20:59,600
to pass into dict

00:20:59,840 --> 00:21:05,840
then at an early version

00:21:02,960 --> 00:21:07,679
nick suggested this line i'm going to

00:21:05,840 --> 00:21:10,000
pause for a few seconds to give you a

00:21:07,679 --> 00:21:17,840
chance to figure it out for yourself

00:21:10,000 --> 00:21:17,840
before i explain it

00:21:35,520 --> 00:21:41,679
so this is one of the most

00:21:38,960 --> 00:21:42,080
impressive single lines of python i have

00:21:41,679 --> 00:21:45,440
seen

00:21:42,080 --> 00:21:47,280
in years if this was chess

00:21:45,440 --> 00:21:50,400
it would be the revealing move of the

00:21:47,280 --> 00:21:50,400
deciding combination

00:21:50,799 --> 00:21:55,919
if this was drama it would be the point

00:21:53,840 --> 00:21:57,600
where three separate plot lines converge

00:21:55,919 --> 00:22:00,640
into one

00:21:57,600 --> 00:22:00,640
let's take it apart

00:22:00,880 --> 00:22:04,559
let's first look at this side we

00:22:03,760 --> 00:22:07,520
normally see

00:22:04,559 --> 00:22:08,640
property used as a decorator but

00:22:07,520 --> 00:22:11,280
decorators

00:22:08,640 --> 00:22:12,000
are just callables called on a function

00:22:11,280 --> 00:22:15,520
or a class

00:22:12,000 --> 00:22:18,720
to modify them in some way one may just

00:22:15,520 --> 00:22:21,360
call it on some function to turn it into

00:22:18,720 --> 00:22:21,360
a property

00:22:21,440 --> 00:22:24,960
now what do we do with the property

00:22:23,840 --> 00:22:27,280
remember

00:22:24,960 --> 00:22:28,720
we are still in dundernew of the meta

00:22:27,280 --> 00:22:30,799
class

00:22:28,720 --> 00:22:32,559
by setting it as an attribute of the

00:22:30,799 --> 00:22:35,280
newly created class

00:22:32,559 --> 00:22:37,760
we are creating an instance property for

00:22:35,280 --> 00:22:37,760
the class

00:22:38,720 --> 00:22:43,360
but what is this property the property

00:22:42,000 --> 00:22:45,679
decorator

00:22:43,360 --> 00:22:47,120
is usually applied to a functional

00:22:45,679 --> 00:22:50,880
member function

00:22:47,120 --> 00:22:55,440
taking just one argument self

00:22:50,880 --> 00:22:58,640
and this looks nothing like that

00:22:55,440 --> 00:23:01,440
but it is a function taking one argument

00:22:58,640 --> 00:23:01,919
and when used as a property the argument

00:23:01,440 --> 00:23:05,679
passed

00:23:01,919 --> 00:23:08,880
will be the enum member itself which

00:23:05,679 --> 00:23:10,960
for the purpose of dictionary get is

00:23:08,880 --> 00:23:14,799
equivalent to its value

00:23:10,960 --> 00:23:14,799
and so the lookup is made

00:23:16,480 --> 00:23:23,120
as impressive as this line might be

00:23:19,600 --> 00:23:24,480
it is a little obscure and in the final

00:23:23,120 --> 00:23:28,080
version

00:23:24,480 --> 00:23:32,159
it was changed to this one which is

00:23:28,080 --> 00:23:37,840
less of a wonder but a little clearer

00:23:32,159 --> 00:23:37,840
and makes the code more maintainable

00:23:45,520 --> 00:23:50,880
so that is all i have to tell you about

00:23:48,240 --> 00:23:54,640
this story so far

00:23:50,880 --> 00:23:54,640
but it doesn't have to be the end

00:23:55,919 --> 00:24:01,200
there are still things left to do there

00:23:59,120 --> 00:24:02,480
are still things you can do with lists

00:24:01,200 --> 00:24:05,600
of tuples

00:24:02,480 --> 00:24:07,279
but cannot do with choices classes and

00:24:05,600 --> 00:24:08,720
they're waiting for someone to solve

00:24:07,279 --> 00:24:10,080
them

00:24:08,720 --> 00:24:12,080
there are features of other

00:24:10,080 --> 00:24:14,480
implementations which haven't found

00:24:12,080 --> 00:24:16,799
their way into django

00:24:14,480 --> 00:24:19,840
so there may be room for more people to

00:24:16,799 --> 00:24:19,840
get involved

00:24:22,080 --> 00:24:27,679
and that is really all this

00:24:25,120 --> 00:24:28,880
is how you can reach me on my personal

00:24:27,679 --> 00:24:33,440
or work emails

00:24:28,880 --> 00:24:36,880
or on twitter or where i do open source

00:24:33,440 --> 00:24:39,919
and as you may or may not be aware

00:24:36,880 --> 00:24:44,640
today is the jewish new year's day

00:24:39,919 --> 00:24:47,919
so a happy 5781 to you all

00:24:44,640 --> 00:25:00,720
and may maybe better than last year

00:24:47,919 --> 00:25:02,799
and thank you and bye bye

00:25:00,720 --> 00:25:02,799

YouTube URL: https://www.youtube.com/watch?v=wQCZ_tcS0uk


