Title: DjangoCon 2020 | GraphQL-first Django - Marcin Gębala
Publication date: 2020-09-30
Playlist: DjangoCon Europe 2020 (Virtual)
Description: 
	DjangoCon Europe 2020 (Virtual)
September 19, 2020 - 11h15 (GMT+1)

"GraphQL-first Django" by Marcin Gębala

GraphQL is a more flexible alternative to REST for building web APIs, and thus is becoming a strong foundation for any modern web stack. This is especially true where static HTML templates are not cutting it or a sophisticated single-page interface is needed, which is often the case on the web nowadays. Even though Django was designed as a model-view-template framework, it can work perfectly well as a GraphQL server to power JavaScript apps. This talk will elaborate on the anatomy of a GraphQL-first Django application, in which GraphQL queries and mutations are the primary interfaces exposed by the backend, while the frontend remains fully dynamic.
Captions: 
	00:00:04,880 --> 00:00:09,120
hello djangocon europe

00:00:06,240 --> 00:00:10,240
um welcome to my presentation graphql

00:00:09,120 --> 00:00:12,080
first django

00:00:10,240 --> 00:00:13,360
uh my name is martin gambala and i'm

00:00:12,080 --> 00:00:15,759
really excited to be

00:00:13,360 --> 00:00:16,880
speaker at this year's drangleicon i

00:00:15,759 --> 00:00:18,960
wish we were seeing each other in

00:00:16,880 --> 00:00:20,640
portland which is obviously not possible

00:00:18,960 --> 00:00:22,960
but it's still really amazing that

00:00:20,640 --> 00:00:24,800
organizers were able to

00:00:22,960 --> 00:00:27,119
run this conference online so this is

00:00:24,800 --> 00:00:29,599
really really amazing

00:00:27,119 --> 00:00:31,599
so first i'd like to tell you a few

00:00:29,599 --> 00:00:33,920
words about me and what i do

00:00:31,599 --> 00:00:35,600
so i'm a lead developer at sailor

00:00:33,920 --> 00:00:38,719
commerce um

00:00:35,600 --> 00:00:40,399
where i'm responsible for um leading the

00:00:38,719 --> 00:00:43,520
back-end team behind the

00:00:40,399 --> 00:00:44,160
sailor graphql api i'm also a python

00:00:43,520 --> 00:00:45,920
django

00:00:44,160 --> 00:00:48,399
uh developer i've been using those

00:00:45,920 --> 00:00:50,160
technologies for five or six years now

00:00:48,399 --> 00:00:51,120
and i'm also a huge enthusiast of

00:00:50,160 --> 00:00:52,800
graphql

00:00:51,120 --> 00:00:54,559
i've been working with this technology

00:00:52,800 --> 00:00:57,199
for about three years now

00:00:54,559 --> 00:00:58,719
um together with django so i'm based in

00:00:57,199 --> 00:01:01,600
uh vroswag in poland

00:00:58,719 --> 00:01:03,359
um roswell is a beautiful city in

00:01:01,600 --> 00:01:05,119
western poland so whenever you have a

00:01:03,359 --> 00:01:06,720
chance to visit our country make sure to

00:01:05,119 --> 00:01:09,200
put it on your list

00:01:06,720 --> 00:01:09,840
um and very quickly a few words about

00:01:09,200 --> 00:01:12,799
sailor

00:01:09,840 --> 00:01:14,240
so sailor is an open source headless

00:01:12,799 --> 00:01:16,880
e-commerce platform

00:01:14,240 --> 00:01:19,520
so e-commerce platform means that you

00:01:16,880 --> 00:01:22,799
can use this software to build and run

00:01:19,520 --> 00:01:26,080
online stores headless means

00:01:22,799 --> 00:01:27,920
that front-end and back end are

00:01:26,080 --> 00:01:29,119
decoupled in this application so it's

00:01:27,920 --> 00:01:32,079
not a

00:01:29,119 --> 00:01:32,960
monolith app but front-end are separate

00:01:32,079 --> 00:01:35,840
apps here

00:01:32,960 --> 00:01:38,000
which allows for really great

00:01:35,840 --> 00:01:41,680
customization and flexibility

00:01:38,000 --> 00:01:43,439
uh in how you use this api um

00:01:41,680 --> 00:01:44,720
so at the heart of the platform there is

00:01:43,439 --> 00:01:47,360
this graphql api

00:01:44,720 --> 00:01:48,079
it's built with django and graphene it's

00:01:47,360 --> 00:01:51,439
pretty large

00:01:48,079 --> 00:01:53,439
uh it has over 350 operations now uh

00:01:51,439 --> 00:01:55,920
and we have those two front end ups apps

00:01:53,439 --> 00:01:58,079
you can see the storefront on the right

00:01:55,920 --> 00:01:59,119
so the storefront is a template of the

00:01:58,079 --> 00:02:01,439
online store that

00:01:59,119 --> 00:02:02,799
your customers would use to buy products

00:02:01,439 --> 00:02:05,200
and there is also the

00:02:02,799 --> 00:02:06,479
dashboard application for store owners

00:02:05,200 --> 00:02:08,800
so both of those

00:02:06,479 --> 00:02:10,239
apps are single page apps built with

00:02:08,800 --> 00:02:13,520
typescript and react

00:02:10,239 --> 00:02:15,040
and they are using our graphql api so if

00:02:13,520 --> 00:02:17,120
you are interested and make sure to

00:02:15,040 --> 00:02:19,680
check it out at sailor.io

00:02:17,120 --> 00:02:22,319
or find us on github because all of that

00:02:19,680 --> 00:02:25,840
is open source

00:02:22,319 --> 00:02:28,400
so what is graphql

00:02:25,840 --> 00:02:31,360
graphql is a open source data query and

00:02:28,400 --> 00:02:33,519
manipulation language for apis

00:02:31,360 --> 00:02:35,599
that's the official official definition

00:02:33,519 --> 00:02:38,959
i would also add to

00:02:35,599 --> 00:02:41,840
that graphql is um api language for

00:02:38,959 --> 00:02:43,680
single page apps because that's uh it's

00:02:41,840 --> 00:02:45,280
its main purpose and that's where it

00:02:43,680 --> 00:02:47,920
really shines

00:02:45,280 --> 00:02:48,800
so let's take a look at graphql and how

00:02:47,920 --> 00:02:50,800
it looks like

00:02:48,800 --> 00:02:54,239
so on this slide you can see example

00:02:50,800 --> 00:02:57,519
from sailor graphql api

00:02:54,239 --> 00:02:59,519
this is a interactive explorer almost

00:02:57,519 --> 00:03:01,200
every framework for building graphql

00:02:59,519 --> 00:03:04,000
servers provides

00:03:01,200 --> 00:03:04,959
provide this kind of explorer so on the

00:03:04,000 --> 00:03:08,080
left we have the

00:03:04,959 --> 00:03:10,560
query uh this is a query where we are

00:03:08,080 --> 00:03:12,879
getting products from the api

00:03:10,560 --> 00:03:14,720
and for each products we are getting

00:03:12,879 --> 00:03:17,200
some fields like name

00:03:14,720 --> 00:03:18,239
description category and variants for

00:03:17,200 --> 00:03:20,000
example so

00:03:18,239 --> 00:03:21,760
so as you can see this is a nested

00:03:20,000 --> 00:03:24,080
structure um

00:03:21,760 --> 00:03:26,319
and on the right we have the response so

00:03:24,080 --> 00:03:28,000
this is json response

00:03:26,319 --> 00:03:30,159
and what is important here we are

00:03:28,000 --> 00:03:30,480
getting only data that we have asked in

00:03:30,159 --> 00:03:33,280
the

00:03:30,480 --> 00:03:34,799
query so this is how it looks like very

00:03:33,280 --> 00:03:36,319
quickly

00:03:34,799 --> 00:03:38,640
and now what are the main features of

00:03:36,319 --> 00:03:41,120
graphql so first of all

00:03:38,640 --> 00:03:41,920
um we are fetching only data that is

00:03:41,120 --> 00:03:44,000
needed

00:03:41,920 --> 00:03:44,959
and it is the client that decides what

00:03:44,000 --> 00:03:47,280
data to fetch

00:03:44,959 --> 00:03:49,519
so this is very uh big difference when

00:03:47,280 --> 00:03:51,920
you compare graphql to rest

00:03:49,519 --> 00:03:54,319
and the idea behind that is to limit

00:03:51,920 --> 00:03:58,000
limit amounts of data transferred

00:03:54,319 --> 00:03:59,680
from server to to the client

00:03:58,000 --> 00:04:01,599
we have three types of operations in

00:03:59,680 --> 00:04:03,599
graphql we have queries

00:04:01,599 --> 00:04:04,640
uh which you already saw on the example

00:04:03,599 --> 00:04:07,840
before

00:04:04,640 --> 00:04:11,200
we also have mutations and subscriptions

00:04:07,840 --> 00:04:14,879
so mutations are equivalent of post

00:04:11,200 --> 00:04:15,840
put or patch requests in rest apis so we

00:04:14,879 --> 00:04:17,840
use them to

00:04:15,840 --> 00:04:20,720
change data on the server to create

00:04:17,840 --> 00:04:22,639
objects update them or delete them

00:04:20,720 --> 00:04:23,759
we also have subscriptions and

00:04:22,639 --> 00:04:26,720
subscriptions are

00:04:23,759 --> 00:04:28,560
real time queries so we can use them to

00:04:26,720 --> 00:04:32,400
fetch data in real time

00:04:28,560 --> 00:04:35,440
and of course they require web sockets

00:04:32,400 --> 00:04:36,960
so our server needs to support websocket

00:04:35,440 --> 00:04:40,080
connection in order to

00:04:36,960 --> 00:04:41,120
to handle those subscriptions and in

00:04:40,080 --> 00:04:43,199
graphql

00:04:41,120 --> 00:04:44,479
we are combining multiple resources in a

00:04:43,199 --> 00:04:46,800
single request

00:04:44,479 --> 00:04:49,120
so it's not like in rest where we have

00:04:46,800 --> 00:04:50,560
uh specific endpoints for different

00:04:49,120 --> 00:04:52,960
types of resources

00:04:50,560 --> 00:04:55,520
in graphql there is only one endpoint

00:04:52,960 --> 00:04:57,680
and as you saw on this example before

00:04:55,520 --> 00:04:58,960
we have this nesting and we can use this

00:04:57,680 --> 00:05:01,919
nesting to

00:04:58,960 --> 00:05:03,199
traverse relations between our types

00:05:01,919 --> 00:05:05,440
between our models

00:05:03,199 --> 00:05:06,320
and we can combine those types in one

00:05:05,440 --> 00:05:09,919
request

00:05:06,320 --> 00:05:11,759
so the idea here is that a single page

00:05:09,919 --> 00:05:14,479
app can only send one request

00:05:11,759 --> 00:05:16,080
and decide uh what data it needs to

00:05:14,479 --> 00:05:18,400
render a particular view

00:05:16,080 --> 00:05:19,440
and it doesn't have to hit multiple

00:05:18,400 --> 00:05:21,520
endpoints

00:05:19,440 --> 00:05:24,240
um so of course there is less traffic

00:05:21,520 --> 00:05:26,320
between uh client app and the server

00:05:24,240 --> 00:05:29,039
we also have strong typing uh which

00:05:26,320 --> 00:05:31,360
means that every field in the api

00:05:29,039 --> 00:05:32,400
or every argument in amputation has its

00:05:31,360 --> 00:05:36,240
own type

00:05:32,400 --> 00:05:39,199
and this gives us static error checking

00:05:36,240 --> 00:05:40,400
when we write those queries in a editor

00:05:39,199 --> 00:05:42,800
which is really nice

00:05:40,400 --> 00:05:44,080
and this all leads to amazing developer

00:05:42,800 --> 00:05:46,320
experience which is

00:05:44,080 --> 00:05:47,919
also one of the most important ideas in

00:05:46,320 --> 00:05:50,320
the graphql ecosystem

00:05:47,919 --> 00:05:51,840
so we have those interactive ides to

00:05:50,320 --> 00:05:54,639
build our queries

00:05:51,840 --> 00:05:55,520
we have api mocking we also have code

00:05:54,639 --> 00:05:57,840
generation

00:05:55,520 --> 00:05:59,680
and this is very powerful feature in the

00:05:57,840 --> 00:06:01,440
front end

00:05:59,680 --> 00:06:02,800
because for example if you are using

00:06:01,440 --> 00:06:05,120
typescript and

00:06:02,800 --> 00:06:06,800
if you have a really large single page

00:06:05,120 --> 00:06:07,759
app then you should probably use

00:06:06,800 --> 00:06:10,160
typescript

00:06:07,759 --> 00:06:11,520
so when you do that you can generate

00:06:10,160 --> 00:06:13,919
your typescript types

00:06:11,520 --> 00:06:16,080
from the graphql schema so whenever the

00:06:13,919 --> 00:06:18,479
schema changes whenever developers

00:06:16,080 --> 00:06:19,680
backend team adds a new field front-end

00:06:18,479 --> 00:06:21,759
team can just

00:06:19,680 --> 00:06:23,360
regenerate those types and they will

00:06:21,759 --> 00:06:23,759
instantly know that there is a new field

00:06:23,360 --> 00:06:27,039
that

00:06:23,759 --> 00:06:27,520
they need to handle so very quickly

00:06:27,039 --> 00:06:30,560
let's

00:06:27,520 --> 00:06:32,880
look at the schema uh so schema is a

00:06:30,560 --> 00:06:35,919
definition of the graphql api

00:06:32,880 --> 00:06:37,440
um you can think of it as a contract

00:06:35,919 --> 00:06:40,319
between front end and back end

00:06:37,440 --> 00:06:42,000
so here in this very simple example we

00:06:40,319 --> 00:06:45,120
have those two special types

00:06:42,000 --> 00:06:46,240
type query and type mutation so these

00:06:45,120 --> 00:06:48,960
are our queries

00:06:46,240 --> 00:06:50,639
and that we have in our api and here is

00:06:48,960 --> 00:06:51,599
example mutation and this is the

00:06:50,639 --> 00:06:53,120
signature

00:06:51,599 --> 00:06:55,039
this is input data that we need to

00:06:53,120 --> 00:06:55,520
provide in order to create the product

00:06:55,039 --> 00:06:58,319
and

00:06:55,520 --> 00:06:59,360
here we have the uh response from the

00:06:58,319 --> 00:07:01,520
mutation

00:06:59,360 --> 00:07:02,720
as you can see here we are defining our

00:07:01,520 --> 00:07:04,639
own type

00:07:02,720 --> 00:07:05,840
we can use those building types like

00:07:04,639 --> 00:07:08,080
string for example

00:07:05,840 --> 00:07:10,000
to create our more complex types and

00:07:08,080 --> 00:07:11,840
here we define the input

00:07:10,000 --> 00:07:13,919
so in graphql we have two approaches

00:07:11,840 --> 00:07:16,800
schema first and code first

00:07:13,919 --> 00:07:18,400
schema first means that we first create

00:07:16,800 --> 00:07:20,639
create those schemas

00:07:18,400 --> 00:07:22,880
and then we build codes in our

00:07:20,639 --> 00:07:26,240
programming language to fulfill

00:07:22,880 --> 00:07:27,199
these schemas in code first approach on

00:07:26,240 --> 00:07:31,360
the other hand

00:07:27,199 --> 00:07:34,160
we first build our code our classes

00:07:31,360 --> 00:07:35,280
to to represent the schema and then the

00:07:34,160 --> 00:07:38,560
schema is generated

00:07:35,280 --> 00:07:40,639
from the code so now i'd like to talk

00:07:38,560 --> 00:07:43,199
about this graphql first

00:07:40,639 --> 00:07:44,080
django architecture and the reason why

00:07:43,199 --> 00:07:45,680
i'm uh

00:07:44,080 --> 00:07:47,599
talking about this kind of architecture

00:07:45,680 --> 00:07:49,919
is that uh our

00:07:47,599 --> 00:07:51,199
product sailor uh is basically using

00:07:49,919 --> 00:07:53,919
this architecture

00:07:51,199 --> 00:07:54,720
uh fun fact is that sailor was in the

00:07:53,919 --> 00:07:57,840
past a

00:07:54,720 --> 00:08:01,120
typical dragon application with uh

00:07:57,840 --> 00:08:03,360
and and views but after we've migrated

00:08:01,120 --> 00:08:06,000
to this headless architecture

00:08:03,360 --> 00:08:06,639
it's django is only used as the graphql

00:08:06,000 --> 00:08:08,080
server

00:08:06,639 --> 00:08:09,680
so now i'd like to tell you a few

00:08:08,080 --> 00:08:12,960
aspects of of this

00:08:09,680 --> 00:08:16,319
architecture so we're gonna use

00:08:12,960 --> 00:08:17,919
a graphene framework here so graphene is

00:08:16,319 --> 00:08:20,479
a high level framework for building

00:08:17,919 --> 00:08:22,400
graphql apis in python

00:08:20,479 --> 00:08:23,520
you can use it standalone with with

00:08:22,400 --> 00:08:25,520
python

00:08:23,520 --> 00:08:27,039
but it has very rich ecosystem of

00:08:25,520 --> 00:08:28,800
libraries um

00:08:27,039 --> 00:08:31,599
and integrations with other frameworks

00:08:28,800 --> 00:08:34,240
such as django or flask

00:08:31,599 --> 00:08:35,200
actually from all the graphql libraries

00:08:34,240 --> 00:08:37,599
in python i think

00:08:35,200 --> 00:08:38,560
graphene has the best tool set for

00:08:37,599 --> 00:08:40,159
django

00:08:38,560 --> 00:08:41,919
so also that's the reason why we are

00:08:40,159 --> 00:08:43,919
using it here and

00:08:41,919 --> 00:08:45,839
what is important here uh is that

00:08:43,919 --> 00:08:47,360
graphene is also code first

00:08:45,839 --> 00:08:49,600
framework which means that we are

00:08:47,360 --> 00:08:50,560
building python classes and python

00:08:49,600 --> 00:08:53,440
functions

00:08:50,560 --> 00:08:56,640
and the graphql schema this contract is

00:08:53,440 --> 00:08:58,959
generated from our python code

00:08:56,640 --> 00:09:00,160
so let's uh look at the project

00:08:58,959 --> 00:09:04,480
structure in

00:09:00,160 --> 00:09:06,560
this graphql first junk architecture

00:09:04,480 --> 00:09:08,160
as you can see on the right there is a

00:09:06,560 --> 00:09:10,800
simple example of

00:09:08,160 --> 00:09:12,959
graphql project that i was uh using

00:09:10,800 --> 00:09:16,000
while working on this presentation

00:09:12,959 --> 00:09:17,839
uh so maybe let's start with the uh with

00:09:16,000 --> 00:09:18,800
those files that we have in the root

00:09:17,839 --> 00:09:20,839
directory

00:09:18,800 --> 00:09:23,519
as you can see this is pretty standard

00:09:20,839 --> 00:09:24,480
um what we have in django so we have

00:09:23,519 --> 00:09:27,120
settings by

00:09:24,480 --> 00:09:29,519
for configuration and we have url spy

00:09:27,120 --> 00:09:30,880
and we also have whiskey pi and usb pi

00:09:29,519 --> 00:09:33,120
so that means that we are using the

00:09:30,880 --> 00:09:35,440
newest django because of this file

00:09:33,120 --> 00:09:36,320
uh so this is pretty standard uh what is

00:09:35,440 --> 00:09:38,240
more interesting

00:09:36,320 --> 00:09:39,920
is the architecture of a single

00:09:38,240 --> 00:09:42,880
application that we have in our

00:09:39,920 --> 00:09:44,800
django project so in this example i have

00:09:42,880 --> 00:09:48,320
these products up

00:09:44,800 --> 00:09:49,680
and so what do we have here models are

00:09:48,320 --> 00:09:53,040
pretty obvious

00:09:49,680 --> 00:09:56,000
this is us in every django application

00:09:53,040 --> 00:09:57,680
uh in this file we define our models uh

00:09:56,000 --> 00:10:00,160
so in this case we will have a product

00:09:57,680 --> 00:10:02,560
model for example and a category model

00:10:00,160 --> 00:10:03,600
so this is pretty obvious but what is a

00:10:02,560 --> 00:10:07,360
bit different

00:10:03,600 --> 00:10:10,880
are those other files so we have types

00:10:07,360 --> 00:10:14,640
uh file so here we define mappings from

00:10:10,880 --> 00:10:16,720
uh our models to graphql types we will

00:10:14,640 --> 00:10:18,880
see that in a moment how it looks like

00:10:16,720 --> 00:10:20,720
and then we have mutations file where we

00:10:18,880 --> 00:10:23,040
define those operations to

00:10:20,720 --> 00:10:24,800
to change data on the server for this

00:10:23,040 --> 00:10:27,040
particular application so here we would

00:10:24,800 --> 00:10:30,079
have operations for creating products

00:10:27,040 --> 00:10:31,839
uh updating or deleting them uh we also

00:10:30,079 --> 00:10:35,040
have data loaders file

00:10:31,839 --> 00:10:38,160
so data loaders are a way to efficiently

00:10:35,040 --> 00:10:39,680
run database queries in in graphene

00:10:38,160 --> 00:10:42,480
so we're going to talk about that later

00:10:39,680 --> 00:10:45,760
as well and lastly there is schema

00:10:42,480 --> 00:10:47,680
by file so every app in this in this

00:10:45,760 --> 00:10:50,399
architecture would have this schema pi

00:10:47,680 --> 00:10:52,240
file which simply imports all the types

00:10:50,399 --> 00:10:55,920
all mutations

00:10:52,240 --> 00:10:56,959
and exports this schema per particular

00:10:55,920 --> 00:10:59,120
application

00:10:56,959 --> 00:11:01,279
and then we also have this global this

00:10:59,120 --> 00:11:02,880
root schema file which imports all the

00:11:01,279 --> 00:11:05,600
app specific schemas

00:11:02,880 --> 00:11:07,519
so here we match our schemas and expose

00:11:05,600 --> 00:11:09,200
that to the graphql view

00:11:07,519 --> 00:11:10,640
so this is how the project structure

00:11:09,200 --> 00:11:13,760
looks like

00:11:10,640 --> 00:11:16,320
now let's look at our urls as i said

00:11:13,760 --> 00:11:17,120
before in graphql there is only one end

00:11:16,320 --> 00:11:20,160
point

00:11:17,120 --> 00:11:21,600
so in our urls when we are starting with

00:11:20,160 --> 00:11:24,320
our application

00:11:21,600 --> 00:11:25,600
uh usually we will have only this one

00:11:24,320 --> 00:11:29,040
url

00:11:25,600 --> 00:11:30,880
so there is this path graphql and

00:11:29,040 --> 00:11:34,079
we have this graphql view which is

00:11:30,880 --> 00:11:36,720
provided by graphing django library

00:11:34,079 --> 00:11:37,680
and that's basically it for the url

00:11:36,720 --> 00:11:40,320
configuration

00:11:37,680 --> 00:11:41,120
when we hit this endpoint with a get

00:11:40,320 --> 00:11:43,920
request

00:11:41,120 --> 00:11:44,240
uh in the browser uh then we would see

00:11:43,920 --> 00:11:46,079
this

00:11:44,240 --> 00:11:47,839
interactive explorer that would allow us

00:11:46,079 --> 00:11:51,279
to play with the api

00:11:47,839 --> 00:11:53,839
um when we sent a post request instead

00:11:51,279 --> 00:11:56,240
um the api this endpoint would return

00:11:53,839 --> 00:11:58,959
the json data

00:11:56,240 --> 00:11:59,519
for for particular query that we send in

00:11:58,959 --> 00:12:02,560
the

00:11:59,519 --> 00:12:03,839
request body so this is how we

00:12:02,560 --> 00:12:07,600
communicate with the api

00:12:03,839 --> 00:12:10,160
using post requests so now let's look at

00:12:07,600 --> 00:12:12,800
types um

00:12:10,160 --> 00:12:13,519
as i said uh in our sample application

00:12:12,800 --> 00:12:16,000
we

00:12:13,519 --> 00:12:17,680
we have the product up and we have also

00:12:16,000 --> 00:12:20,399
the product model so now

00:12:17,680 --> 00:12:21,519
we want to expose that model in the api

00:12:20,399 --> 00:12:24,240
uh somehow

00:12:21,519 --> 00:12:25,920
so how can we do that first solution

00:12:24,240 --> 00:12:29,200
would be to write all of the

00:12:25,920 --> 00:12:31,760
type fields by hand but graphing django

00:12:29,200 --> 00:12:34,720
provides us with this very nice

00:12:31,760 --> 00:12:36,959
class called django object type so we

00:12:34,720 --> 00:12:39,279
basically create our

00:12:36,959 --> 00:12:40,959
type as a new class that inherits from

00:12:39,279 --> 00:12:43,120
dragon object type

00:12:40,959 --> 00:12:44,320
and now let's look at this class meta

00:12:43,120 --> 00:12:46,000
here

00:12:44,320 --> 00:12:48,399
you are probably very familiar with this

00:12:46,000 --> 00:12:50,000
concept because that's also what we do

00:12:48,399 --> 00:12:52,639
in django

00:12:50,000 --> 00:12:53,680
we declare that this django object type

00:12:52,639 --> 00:12:55,440
should use the

00:12:53,680 --> 00:12:56,720
product model from our products

00:12:55,440 --> 00:12:59,600
application

00:12:56,720 --> 00:13:00,240
and then we specify what fields we want

00:12:59,600 --> 00:13:02,800
to

00:13:00,240 --> 00:13:04,639
include in the type and this is useful

00:13:02,800 --> 00:13:06,800
because

00:13:04,639 --> 00:13:09,120
we don't want to expose all all fields

00:13:06,800 --> 00:13:11,200
automatically we want to be sure which

00:13:09,120 --> 00:13:13,440
fields are exposed in the type so that's

00:13:11,200 --> 00:13:15,600
why we use this only fields

00:13:13,440 --> 00:13:17,200
here and that's basically it for

00:13:15,600 --> 00:13:21,279
graphene to

00:13:17,200 --> 00:13:24,079
create a graphql type based on our model

00:13:21,279 --> 00:13:26,160
if we wanted to add custom fields to our

00:13:24,079 --> 00:13:28,639
type we can easily do that as well

00:13:26,160 --> 00:13:29,360
and we do that in a declarative manner

00:13:28,639 --> 00:13:32,399
so

00:13:29,360 --> 00:13:34,720
this is a example of custom field so we

00:13:32,399 --> 00:13:36,720
declare those fields here at this level

00:13:34,720 --> 00:13:38,959
so it's very similar to declaring model

00:13:36,720 --> 00:13:41,440
fields

00:13:38,959 --> 00:13:43,360
and for each field in our type we also

00:13:41,440 --> 00:13:46,000
need to create a resolver

00:13:43,360 --> 00:13:47,839
so let's look at this method here

00:13:46,000 --> 00:13:50,320
resolve price uh

00:13:47,839 --> 00:13:51,120
is a resolver function and it will be

00:13:50,320 --> 00:13:53,760
called

00:13:51,120 --> 00:13:54,880
by graphene whenever it uh finds this

00:13:53,760 --> 00:13:58,079
field in the schema

00:13:54,880 --> 00:14:00,320
so basically resolver uh tells the

00:13:58,079 --> 00:14:01,360
framework how to return data for our

00:14:00,320 --> 00:14:04,880
field

00:14:01,360 --> 00:14:08,560
uh so uh road is instance of our model

00:14:04,880 --> 00:14:09,839
uh here so uh using this we we get the

00:14:08,560 --> 00:14:12,320
price field from the

00:14:09,839 --> 00:14:14,480
from the instance plus we get the

00:14:12,320 --> 00:14:16,160
currency from settings and we use that

00:14:14,480 --> 00:14:18,399
to return the money

00:14:16,160 --> 00:14:20,800
type which represents the price of a

00:14:18,399 --> 00:14:20,800
product

00:14:20,880 --> 00:14:27,199
so now how do we define queries

00:14:23,920 --> 00:14:29,199
we define queries in the schema pi file

00:14:27,199 --> 00:14:32,079
and in this example we have only one

00:14:29,199 --> 00:14:35,360
query and so we do that very similarly

00:14:32,079 --> 00:14:37,120
uh so this is a declarative style again

00:14:35,360 --> 00:14:38,959
something similar to what you already

00:14:37,120 --> 00:14:42,079
saw something similar to what we do with

00:14:38,959 --> 00:14:45,120
uh models we declare that there is

00:14:42,079 --> 00:14:45,839
one query called products uh it is a

00:14:45,120 --> 00:14:49,040
list

00:14:45,839 --> 00:14:50,800
of product types as simple as that

00:14:49,040 --> 00:14:52,639
and for that field we also need to

00:14:50,800 --> 00:14:55,600
define a resolver function

00:14:52,639 --> 00:14:56,959
so in this case we define the resolve

00:14:55,600 --> 00:14:59,440
products function

00:14:56,959 --> 00:15:00,800
and as you can see we are using uh

00:14:59,440 --> 00:15:03,839
django orm

00:15:00,800 --> 00:15:06,079
to return all products from the database

00:15:03,839 --> 00:15:07,519
so this is very simple example of course

00:15:06,079 --> 00:15:10,000
if you wanted to extend

00:15:07,519 --> 00:15:12,079
uh this query with some arguments we

00:15:10,000 --> 00:15:13,600
could easily do that by specifying those

00:15:12,079 --> 00:15:16,480
arguments here

00:15:13,600 --> 00:15:18,480
um so we could use that pattern to for

00:15:16,480 --> 00:15:21,519
example support filtering

00:15:18,480 --> 00:15:23,680
uh sorting or pagination and

00:15:21,519 --> 00:15:27,360
uh if we define an argument here it

00:15:23,680 --> 00:15:30,240
would be available here in the resolver

00:15:27,360 --> 00:15:31,040
so now let's talk about mutations uh

00:15:30,240 --> 00:15:35,040
mutations

00:15:31,040 --> 00:15:37,440
seem a bit more complex at first glance

00:15:35,040 --> 00:15:39,920
so let's let's talk how how we implement

00:15:37,440 --> 00:15:40,560
them so basically we use this graphene

00:15:39,920 --> 00:15:43,440
mutation

00:15:40,560 --> 00:15:44,880
class for that and every mutation uh

00:15:43,440 --> 00:15:46,880
represents a single operation

00:15:44,880 --> 00:15:48,959
for example this one is used to create

00:15:46,880 --> 00:15:52,240
products so every mutation is

00:15:48,959 --> 00:15:54,399
implemented like as a class uh so let's

00:15:52,240 --> 00:15:56,560
look what is going on here

00:15:54,399 --> 00:15:57,440
at the top of this implementation we

00:15:56,560 --> 00:16:00,399
define

00:15:57,440 --> 00:16:01,120
uh what would be the the output of the

00:16:00,399 --> 00:16:03,519
mutation

00:16:01,120 --> 00:16:05,040
so in our case we want to return a new

00:16:03,519 --> 00:16:08,399
product instance

00:16:05,040 --> 00:16:12,320
and a list of errors that may occurred

00:16:08,399 --> 00:16:14,800
during execution of the mutation

00:16:12,320 --> 00:16:15,839
then in the class arguments we define

00:16:14,800 --> 00:16:17,839
the input

00:16:15,839 --> 00:16:19,920
so this is data that we need to provide

00:16:17,839 --> 00:16:22,079
in order to create the product

00:16:19,920 --> 00:16:23,920
so we've we saw that already on the

00:16:22,079 --> 00:16:25,519
schema a few slides before

00:16:23,920 --> 00:16:27,279
i've skipped implementation of this

00:16:25,519 --> 00:16:28,880
product create input because it's very

00:16:27,279 --> 00:16:31,759
similar to what we have here

00:16:28,880 --> 00:16:34,880
it's just a simple class with

00:16:31,759 --> 00:16:34,880
declarative fields

00:16:35,519 --> 00:16:41,440
match with our fields in our model

00:16:38,880 --> 00:16:42,880
and what is uh most important here is

00:16:41,440 --> 00:16:44,800
this mutate function

00:16:42,880 --> 00:16:46,720
so this is basically the resolver of

00:16:44,800 --> 00:16:49,600
that mutation

00:16:46,720 --> 00:16:50,000
so what we want to do here is to get the

00:16:49,600 --> 00:16:53,519
input

00:16:50,000 --> 00:16:56,079
data and create a new product instance

00:16:53,519 --> 00:16:57,440
so we are doing that in the first line

00:16:56,079 --> 00:17:01,440
input represents the

00:16:57,440 --> 00:17:03,839
the incoming data we populate our

00:17:01,440 --> 00:17:06,240
newly created instance with this data

00:17:03,839 --> 00:17:08,959
then we can run some basic validation

00:17:06,240 --> 00:17:10,720
so in this simple example i'm using a

00:17:08,959 --> 00:17:11,679
full clean method from from django

00:17:10,720 --> 00:17:14,799
models

00:17:11,679 --> 00:17:15,760
and uh of course if there are any errors

00:17:14,799 --> 00:17:18,160
like for example

00:17:15,760 --> 00:17:19,760
a field was required by but was not

00:17:18,160 --> 00:17:22,480
provided in the input

00:17:19,760 --> 00:17:23,760
i would get a validation error here so

00:17:22,480 --> 00:17:25,199
here we are catching all those

00:17:23,760 --> 00:17:28,720
validation errors

00:17:25,199 --> 00:17:31,280
uh converting them to with those small

00:17:28,720 --> 00:17:33,760
utility function to a

00:17:31,280 --> 00:17:34,720
format that will match with the format

00:17:33,760 --> 00:17:38,640
of this

00:17:34,720 --> 00:17:40,480
output field and if everything is fine

00:17:38,640 --> 00:17:42,960
then we just save the newly created

00:17:40,480 --> 00:17:45,919
instance and return that

00:17:42,960 --> 00:17:47,450
to the api user so this is how we define

00:17:45,919 --> 00:17:48,640
mutations

00:17:47,450 --> 00:17:50,559
[Music]

00:17:48,640 --> 00:17:52,480
if you look at this code you may think

00:17:50,559 --> 00:17:54,400
that

00:17:52,480 --> 00:17:56,160
if you have a lot of mutations to write

00:17:54,400 --> 00:17:57,840
then probably it would be nice to use

00:17:56,160 --> 00:18:01,840
some abstractions

00:17:57,840 --> 00:18:04,960
for example to have the common logic for

00:18:01,840 --> 00:18:06,480
validation uh so if i had a few

00:18:04,960 --> 00:18:07,840
mutations like this i would like to have

00:18:06,480 --> 00:18:10,480
this code separated

00:18:07,840 --> 00:18:11,039
separated moves to some utility function

00:18:10,480 --> 00:18:14,400
or some

00:18:11,039 --> 00:18:16,559
mixing for example this is

00:18:14,400 --> 00:18:19,120
easily uh this can be easily achieved

00:18:16,559 --> 00:18:20,880
because uh those mutations are classes

00:18:19,120 --> 00:18:22,640
so we can implement those abstractions

00:18:20,880 --> 00:18:25,679
similarly as we do with

00:18:22,640 --> 00:18:29,200
uh django uh class

00:18:25,679 --> 00:18:32,640
based views right and

00:18:29,200 --> 00:18:34,640
so graphene provides us with

00:18:32,640 --> 00:18:36,960
one abstraction that can be useful if

00:18:34,640 --> 00:18:40,840
you are using django forms

00:18:36,960 --> 00:18:42,240
so with those so there are form-based

00:18:40,840 --> 00:18:45,679
mutations

00:18:42,240 --> 00:18:48,160
and what they do is

00:18:45,679 --> 00:18:49,760
take a form so let's assume that we have

00:18:48,160 --> 00:18:52,160
a modal form

00:18:49,760 --> 00:18:52,960
called product form which we can use to

00:18:52,160 --> 00:18:55,840
create new

00:18:52,960 --> 00:18:56,720
products so if we use this django model

00:18:55,840 --> 00:18:59,120
for mutation

00:18:56,720 --> 00:19:01,520
which is provided by graphene chango we

00:18:59,120 --> 00:19:02,880
could say here that this mutation should

00:19:01,520 --> 00:19:05,600
use this form

00:19:02,880 --> 00:19:07,919
and based on that this mutation would

00:19:05,600 --> 00:19:10,000
generate for us

00:19:07,919 --> 00:19:11,120
input for that mutation automatically

00:19:10,000 --> 00:19:13,919
from that form

00:19:11,120 --> 00:19:14,799
uh entire logic that would be delegated

00:19:13,919 --> 00:19:17,760
to the form

00:19:14,799 --> 00:19:18,960
and the output that would be the new

00:19:17,760 --> 00:19:20,720
product estas or

00:19:18,960 --> 00:19:22,000
errors those validation errors that

00:19:20,720 --> 00:19:24,799
could happen

00:19:22,000 --> 00:19:26,799
during the execution of that mutation so

00:19:24,799 --> 00:19:27,520
this is very useful abstraction if you

00:19:26,799 --> 00:19:29,039
want to like

00:19:27,520 --> 00:19:30,880
forms which are really nice tool

00:19:29,039 --> 00:19:33,760
provided by django uh

00:19:30,880 --> 00:19:36,160
also you can benefit from from forms to

00:19:33,760 --> 00:19:38,160
for example encapsulate the validation

00:19:36,160 --> 00:19:40,240
logic in those forms so this is very

00:19:38,160 --> 00:19:42,640
helpful uh abstraction

00:19:40,240 --> 00:19:44,240
if you uh need to build a lot of

00:19:42,640 --> 00:19:46,880
mutations like this

00:19:44,240 --> 00:19:47,760
so now let's talk about authentication

00:19:46,880 --> 00:19:51,280
and

00:19:47,760 --> 00:19:54,400
most up require some authentication ways

00:19:51,280 --> 00:19:55,600
and because graphql is designed for

00:19:54,400 --> 00:19:58,320
single page apps

00:19:55,600 --> 00:20:00,160
uh in single page apps we most often use

00:19:58,320 --> 00:20:03,039
json web tokens

00:20:00,160 --> 00:20:03,919
so if we wanted to support json web

00:20:03,039 --> 00:20:07,039
tokens in our

00:20:03,919 --> 00:20:08,720
uh django application of django graphql

00:20:07,039 --> 00:20:10,240
first django app

00:20:08,720 --> 00:20:12,640
we need to use this library called

00:20:10,240 --> 00:20:15,760
triangle graphql jwt

00:20:12,640 --> 00:20:18,559
so uh json web tokens are not

00:20:15,760 --> 00:20:20,559
provided by default support for that is

00:20:18,559 --> 00:20:22,000
not provided by default in in graphing

00:20:20,559 --> 00:20:24,240
we need to use this library

00:20:22,000 --> 00:20:26,559
and when we install this library we

00:20:24,240 --> 00:20:29,440
would have for example this mutation

00:20:26,559 --> 00:20:30,240
uh in our api this is called token

00:20:29,440 --> 00:20:32,559
create

00:20:30,240 --> 00:20:34,320
and as you can see this mutation accepts

00:20:32,559 --> 00:20:36,320
user credentials

00:20:34,320 --> 00:20:37,440
and when user pass those credentials and

00:20:36,320 --> 00:20:40,000
they are correct

00:20:37,440 --> 00:20:42,640
we can ask for the access token or

00:20:40,000 --> 00:20:44,720
refresh token for example

00:20:42,640 --> 00:20:46,080
we can extend this mutation as well to

00:20:44,720 --> 00:20:49,039
return the user

00:20:46,080 --> 00:20:50,640
so if we want to log them in in our

00:20:49,039 --> 00:20:51,520
single page app and immediate

00:20:50,640 --> 00:20:53,919
immediately

00:20:51,520 --> 00:20:55,520
render the email or avatar we can ask

00:20:53,919 --> 00:20:58,480
for this data here

00:20:55,520 --> 00:20:59,120
uh so once we have the uh token access

00:20:58,480 --> 00:21:02,159
token

00:20:59,120 --> 00:21:05,520
we are using this authorization header

00:21:02,159 --> 00:21:07,280
to pass this token and authenticate

00:21:05,520 --> 00:21:09,440
subsequent requests

00:21:07,280 --> 00:21:10,400
of course this library also provides a

00:21:09,440 --> 00:21:14,480
middleware

00:21:10,400 --> 00:21:16,480
so that our app understands how to

00:21:14,480 --> 00:21:20,320
parse those headers and how to get the

00:21:16,480 --> 00:21:23,360
user from those tokens

00:21:20,320 --> 00:21:26,159
we can also use this library to restrict

00:21:23,360 --> 00:21:27,039
access to particular fields in our api

00:21:26,159 --> 00:21:29,280
so

00:21:27,039 --> 00:21:30,720
let's look at this example we have again

00:21:29,280 --> 00:21:33,120
our product type

00:21:30,720 --> 00:21:34,159
but in this case we also have a revenue

00:21:33,120 --> 00:21:38,159
field

00:21:34,159 --> 00:21:41,120
so this field should be restricted

00:21:38,159 --> 00:21:42,880
only to admin users with a specific

00:21:41,120 --> 00:21:45,200
permission

00:21:42,880 --> 00:21:46,480
in this case it's a product managed

00:21:45,200 --> 00:21:49,760
product permission

00:21:46,480 --> 00:21:52,640
uh we are using here standard um

00:21:49,760 --> 00:21:53,760
permissions framework um for for those

00:21:52,640 --> 00:21:56,320
permissions

00:21:53,760 --> 00:21:57,280
so this library uh gives us the

00:21:56,320 --> 00:21:59,600
permission

00:21:57,280 --> 00:22:01,280
the creator and we can use it to

00:21:59,600 --> 00:22:04,880
decorate our resolvers

00:22:01,280 --> 00:22:09,039
so if we add this decorator here when

00:22:04,880 --> 00:22:11,120
the token is passed to the api

00:22:09,039 --> 00:22:12,480
graphene will check if the user has this

00:22:11,120 --> 00:22:15,200
permission and will

00:22:12,480 --> 00:22:17,760
only return data if if they have those

00:22:15,200 --> 00:22:17,760
permissions

00:22:18,240 --> 00:22:21,840
so uh another aspect of graphql phrase

00:22:20,960 --> 00:22:24,880
django is

00:22:21,840 --> 00:22:27,280
database performance uh so

00:22:24,880 --> 00:22:28,960
you probably probably heard about this n

00:22:27,280 --> 00:22:32,559
plus one problem

00:22:28,960 --> 00:22:34,559
uh this is a problem that we can

00:22:32,559 --> 00:22:35,600
have in classic django for example in

00:22:34,559 --> 00:22:37,919
templates

00:22:35,600 --> 00:22:38,640
when there is a relationship between our

00:22:37,919 --> 00:22:41,760
data

00:22:38,640 --> 00:22:42,720
like one-to-many for example so in our

00:22:41,760 --> 00:22:45,600
case we have

00:22:42,720 --> 00:22:46,640
a product each product can have a

00:22:45,600 --> 00:22:48,559
category

00:22:46,640 --> 00:22:50,240
and a category can have multiple

00:22:48,559 --> 00:22:52,559
products so there is this

00:22:50,240 --> 00:22:53,840
many-to-one relationship between those

00:22:52,559 --> 00:22:56,240
models

00:22:53,840 --> 00:22:58,559
so what we do in django views we use

00:22:56,240 --> 00:23:01,280
select related or prefatulated

00:22:58,559 --> 00:23:04,080
to avoid duplicated queries right but

00:23:01,280 --> 00:23:06,720
this is not necessarily

00:23:04,080 --> 00:23:08,159
the best way in graphql because in

00:23:06,720 --> 00:23:10,080
graphql as you remember

00:23:08,159 --> 00:23:11,280
it is the client that decides what data

00:23:10,080 --> 00:23:14,080
to fetch

00:23:11,280 --> 00:23:14,400
so we might get a query that only asks

00:23:14,080 --> 00:23:17,280
for

00:23:14,400 --> 00:23:17,840
product name but we we also might get a

00:23:17,280 --> 00:23:20,159
query that

00:23:17,840 --> 00:23:22,240
that asks for those categories and we

00:23:20,159 --> 00:23:24,480
only want to run those

00:23:22,240 --> 00:23:25,280
performance improvements to those select

00:23:24,480 --> 00:23:28,320
related

00:23:25,280 --> 00:23:30,159
methods when user actually asks for

00:23:28,320 --> 00:23:31,200
those categories we don't want to run

00:23:30,159 --> 00:23:32,640
them always

00:23:31,200 --> 00:23:35,039
so we need some way to do that

00:23:32,640 --> 00:23:38,000
dynamically

00:23:35,039 --> 00:23:39,919
we achieved that by using data loaders

00:23:38,000 --> 00:23:41,919
so data loaders are concept

00:23:39,919 --> 00:23:43,200
uh which is used in many graphql

00:23:41,919 --> 00:23:45,919
frameworks uh

00:23:43,200 --> 00:23:47,440
it originates in the old in the first

00:23:45,919 --> 00:23:51,600
implementation of graphql that was

00:23:47,440 --> 00:23:53,600
uh built in javascript uh

00:23:51,600 --> 00:23:56,559
so maybe let's first look at how we use

00:23:53,600 --> 00:23:59,679
them and then i'll tell you how it works

00:23:56,559 --> 00:24:01,279
so again we have our product type uh we

00:23:59,679 --> 00:24:04,480
want to return a category

00:24:01,279 --> 00:24:06,640
uh for for this product so

00:24:04,480 --> 00:24:08,400
without any optimization we would simply

00:24:06,640 --> 00:24:11,919
in this resolver we would simply

00:24:08,400 --> 00:24:15,200
do root dot category where root is our

00:24:11,919 --> 00:24:17,919
product instance which would of course

00:24:15,200 --> 00:24:19,279
without any prefetching that run another

00:24:17,919 --> 00:24:22,960
database query

00:24:19,279 --> 00:24:23,679
with data loaders we use this category

00:24:22,960 --> 00:24:26,400
id

00:24:23,679 --> 00:24:28,320
so in our instance we know what is the

00:24:26,400 --> 00:24:29,200
id of the related category without

00:24:28,320 --> 00:24:32,320
fetching it from

00:24:29,200 --> 00:24:34,720
from the separate table and then

00:24:32,320 --> 00:24:36,480
we pass this id to the data loader with

00:24:34,720 --> 00:24:38,640
the load function

00:24:36,480 --> 00:24:40,159
uh and that's it that's what we do in

00:24:38,640 --> 00:24:42,320
those resolvers

00:24:40,159 --> 00:24:43,679
and now uh here's the data loader

00:24:42,320 --> 00:24:47,200
implementation

00:24:43,679 --> 00:24:48,159
so whenever whenever so when graphene

00:24:47,200 --> 00:24:53,120
processes this

00:24:48,159 --> 00:24:55,760
uh query it will look uh all

00:24:53,120 --> 00:24:58,400
the query it will gather all the keys

00:24:55,760 --> 00:25:01,440
that we have passed here so database ids

00:24:58,400 --> 00:25:04,000
and because it returns a promise

00:25:01,440 --> 00:25:05,840
it won't uh immediate immediately return

00:25:04,000 --> 00:25:08,240
the category object instead

00:25:05,840 --> 00:25:09,039
it will gather all of those keys and as

00:25:08,240 --> 00:25:12,159
you can see here

00:25:09,039 --> 00:25:14,559
we pass those keys to a uh orm uh

00:25:12,159 --> 00:25:15,520
method here to get this data in one

00:25:14,559 --> 00:25:18,799
query

00:25:15,520 --> 00:25:20,799
so because of those promises uh uh

00:25:18,799 --> 00:25:21,840
graphene will only run around that at

00:25:20,799 --> 00:25:25,440
the end of

00:25:21,840 --> 00:25:26,960
uh of the processing that graphql query

00:25:25,440 --> 00:25:28,720
so this is something new to django

00:25:26,960 --> 00:25:31,440
developers because promises are not

00:25:28,720 --> 00:25:34,559
concept used in python

00:25:31,440 --> 00:25:36,640
in the next version of of graphene and

00:25:34,559 --> 00:25:38,159
hopefully in the next versions of django

00:25:36,640 --> 00:25:41,360
we will be able to use

00:25:38,159 --> 00:25:42,000
async await syntax here in the future

00:25:41,360 --> 00:25:44,960
once

00:25:42,000 --> 00:25:45,760
asynchronous uh execution is supported

00:25:44,960 --> 00:25:48,080
in django

00:25:45,760 --> 00:25:49,279
and database access as well so this is

00:25:48,080 --> 00:25:50,960
synchronous code

00:25:49,279 --> 00:25:52,880
uh it's using those promises which are

00:25:50,960 --> 00:25:54,880
shipped with a graphene library it's a

00:25:52,880 --> 00:25:58,000
little bit hard to understand at first

00:25:54,880 --> 00:25:58,720
but it's relatively easy to use once you

00:25:58,000 --> 00:26:01,440
know how to

00:25:58,720 --> 00:26:01,440
how to use them

00:26:02,159 --> 00:26:06,320
to inspect how many database queries we

00:26:04,559 --> 00:26:07,200
are actually performing we can use the

00:26:06,320 --> 00:26:10,240
good old

00:26:07,200 --> 00:26:11,120
django debug toolbar so as you can see

00:26:10,240 --> 00:26:13,679
here we are running

00:26:11,120 --> 00:26:15,600
our explorer performing some mutations

00:26:13,679 --> 00:26:16,480
and here we can see that there are 26

00:26:15,600 --> 00:26:19,279
queries

00:26:16,480 --> 00:26:21,200
uh in the background we additionally

00:26:19,279 --> 00:26:23,360
need to install this dragonographic ul

00:26:21,200 --> 00:26:25,840
debug toolbar

00:26:23,360 --> 00:26:27,120
because otherwise uh this this debug

00:26:25,840 --> 00:26:28,159
toolbar doesn't work with those

00:26:27,120 --> 00:26:31,279
interactive

00:26:28,159 --> 00:26:34,080
uh uh explorers

00:26:31,279 --> 00:26:35,520
uh and uh i also wanted to tell you a

00:26:34,080 --> 00:26:38,799
bit about testing

00:26:35,520 --> 00:26:42,080
uh so we need to make sure that we have

00:26:38,799 --> 00:26:44,720
all of our operations are tested so in

00:26:42,080 --> 00:26:46,400
sailor and in those simple examples that

00:26:44,720 --> 00:26:50,320
i'm showing here we are using

00:26:46,400 --> 00:26:51,120
pythest and how can we test our api with

00:26:50,320 --> 00:26:53,679
pi test

00:26:51,120 --> 00:26:55,200
so this is a definition of the query in

00:26:53,679 --> 00:26:57,840
this case this is a mutation

00:26:55,200 --> 00:26:59,279
that we want to test uh it accepts some

00:26:57,840 --> 00:27:02,240
variables

00:26:59,279 --> 00:27:03,679
uh and it's just a multi-line string in

00:27:02,240 --> 00:27:07,679
in python

00:27:03,679 --> 00:27:09,440
so then we use this query here

00:27:07,679 --> 00:27:10,720
here we define our variables for the

00:27:09,440 --> 00:27:13,360
test

00:27:10,720 --> 00:27:14,240
and there is a little bit modified api

00:27:13,360 --> 00:27:17,600
client

00:27:14,240 --> 00:27:19,840
which has the post graphql method

00:27:17,600 --> 00:27:20,960
this is something that we built uh in

00:27:19,840 --> 00:27:22,480
our system it's very simple

00:27:20,960 --> 00:27:24,480
implementation of the

00:27:22,480 --> 00:27:26,640
of the classic pi test client that

00:27:24,480 --> 00:27:29,039
allows you to to query your

00:27:26,640 --> 00:27:29,840
your server and we just pass this query

00:27:29,039 --> 00:27:32,840
here

00:27:29,840 --> 00:27:34,159
and check if we get data that we

00:27:32,840 --> 00:27:35,919
expected

00:27:34,159 --> 00:27:37,440
as a bonus i wanted to show you real

00:27:35,919 --> 00:27:39,840
time queries uh

00:27:37,440 --> 00:27:41,279
so this is these are those subscriptions

00:27:39,840 --> 00:27:45,120
that we have in graphql

00:27:41,279 --> 00:27:48,000
is as you can see on this example uh

00:27:45,120 --> 00:27:49,840
we are getting some data in real time in

00:27:48,000 --> 00:27:52,320
the query here we are using the keyword

00:27:49,840 --> 00:27:54,880
subscription

00:27:52,320 --> 00:27:57,360
and here we are getting fit of some

00:27:54,880 --> 00:27:57,360
messages

00:27:58,080 --> 00:28:02,320
can we implement those subscriptions in

00:28:00,840 --> 00:28:05,200
django

00:28:02,320 --> 00:28:05,919
unfortunately the answer for now is that

00:28:05,200 --> 00:28:07,679
django

00:28:05,919 --> 00:28:09,840
graph graphing doesn't support

00:28:07,679 --> 00:28:11,760
subscriptions out of the box

00:28:09,840 --> 00:28:13,520
and the reason is that there is no ask

00:28:11,760 --> 00:28:16,880
give you our consumer

00:28:13,520 --> 00:28:19,039
to process websocket requests so there

00:28:16,880 --> 00:28:21,840
is ongoing work on adding support

00:28:19,039 --> 00:28:22,880
for subscriptions uh so we may have that

00:28:21,840 --> 00:28:25,679
in the future

00:28:22,880 --> 00:28:27,919
for now we can use third-party libraries

00:28:25,679 --> 00:28:30,399
so it is possible to add

00:28:27,919 --> 00:28:32,080
subscriptions to django but we need uh

00:28:30,399 --> 00:28:34,799
to use django channels

00:28:32,080 --> 00:28:37,039
so those two libraries rely on channels

00:28:34,799 --> 00:28:40,080
to be honest i haven't used them much

00:28:37,039 --> 00:28:41,760
uh i know they are you can

00:28:40,080 --> 00:28:43,760
implement subscriptions with them but i

00:28:41,760 --> 00:28:44,000
would say it's still something a little

00:28:43,760 --> 00:28:46,720
bit

00:28:44,000 --> 00:28:47,200
experimental so i think we need to wait

00:28:46,720 --> 00:28:50,799
uh

00:28:47,200 --> 00:28:53,840
until async support is is um

00:28:50,799 --> 00:28:57,279
is provided by django and graphene

00:28:53,840 --> 00:29:00,720
so is drank a good choice for a graphql

00:28:57,279 --> 00:29:04,080
server so first of all uh for me

00:29:00,720 --> 00:29:07,200
django uh is a his productivity

00:29:04,080 --> 00:29:10,399
uh i love how django provides

00:29:07,200 --> 00:29:12,159
uh very useful tools like migrations

00:29:10,399 --> 00:29:14,799
framework which is really amazing

00:29:12,159 --> 00:29:15,679
orm which is really easy to use and very

00:29:14,799 --> 00:29:17,600
powerful

00:29:15,679 --> 00:29:19,120
and all of the utilities that you have

00:29:17,600 --> 00:29:20,720
in django so

00:29:19,120 --> 00:29:22,720
i always thought that with django you

00:29:20,720 --> 00:29:25,440
can build stuff very fast

00:29:22,720 --> 00:29:27,279
and if you use that with graphene and

00:29:25,440 --> 00:29:28,240
those code first approach when you

00:29:27,279 --> 00:29:31,520
generate

00:29:28,240 --> 00:29:33,279
types from from from models i think that

00:29:31,520 --> 00:29:34,480
you can progress very fast with building

00:29:33,279 --> 00:29:36,159
your application

00:29:34,480 --> 00:29:38,640
so i think that's very very big

00:29:36,159 --> 00:29:41,120
advantage of this tag

00:29:38,640 --> 00:29:42,880
if you are using graphene you will see a

00:29:41,120 --> 00:29:45,360
lot of familiar concepts

00:29:42,880 --> 00:29:46,480
such as object types uh form based

00:29:45,360 --> 00:29:48,399
mutations

00:29:46,480 --> 00:29:50,240
and this all of them are using this

00:29:48,399 --> 00:29:51,919
declarative style which is very familiar

00:29:50,240 --> 00:29:54,060
to django developers because this is how

00:29:51,919 --> 00:29:55,360
we use models for example

00:29:54,060 --> 00:29:57,360
[Music]

00:29:55,360 --> 00:29:59,760
what is also important here is that it's

00:29:57,360 --> 00:30:02,240
relatively easy to add graphql api

00:29:59,760 --> 00:30:04,159
to an existing django app so if you

00:30:02,240 --> 00:30:08,080
already have a django app

00:30:04,159 --> 00:30:10,000
uh it's it's pretty easy to write those

00:30:08,080 --> 00:30:12,000
object types to map your models to to a

00:30:10,000 --> 00:30:13,440
query and if you want to experiment with

00:30:12,000 --> 00:30:15,760
the graphql api

00:30:13,440 --> 00:30:16,640
it's relatively easy to do with django

00:30:15,760 --> 00:30:19,279
and graphene

00:30:16,640 --> 00:30:21,279
as and as an example you may want to

00:30:19,279 --> 00:30:23,039
take a look at cellular graphql api

00:30:21,279 --> 00:30:25,360
which is entirely open source and you

00:30:23,039 --> 00:30:27,120
can find that on git on github

00:30:25,360 --> 00:30:28,480
if you want to see how we implemented

00:30:27,120 --> 00:30:31,200
some particular features

00:30:28,480 --> 00:30:33,200
uh you can look at the source code this

00:30:31,200 --> 00:30:35,200
project is three years old now this

00:30:33,200 --> 00:30:37,679
graphql api in sailor and it's used in

00:30:35,200 --> 00:30:39,919
production

00:30:37,679 --> 00:30:41,840
also there are some cons here so first

00:30:39,919 --> 00:30:44,240
of all fully fledged server requires

00:30:41,840 --> 00:30:46,640
many additional libraries

00:30:44,240 --> 00:30:48,080
which are not always well maintained so

00:30:46,640 --> 00:30:50,080
as you saw we

00:30:48,080 --> 00:30:51,919
need to use additional library for json

00:30:50,080 --> 00:30:53,200
web tokens there are also libraries for

00:30:51,919 --> 00:30:55,120
file uploads

00:30:53,200 --> 00:30:56,640
for some abstractions and utilities so

00:30:55,120 --> 00:30:59,120
there are many many uh

00:30:56,640 --> 00:31:00,159
libraries that are in this ecosystem and

00:30:59,120 --> 00:31:02,320
some of them are not

00:31:00,159 --> 00:31:05,039
really well in my opinion some of them

00:31:02,320 --> 00:31:07,200
are rather small packages

00:31:05,039 --> 00:31:10,000
so if you want to use that in production

00:31:07,200 --> 00:31:12,399
there is always this small risk that

00:31:10,000 --> 00:31:13,200
whenever a new version of graphene comes

00:31:12,399 --> 00:31:15,279
out

00:31:13,200 --> 00:31:17,760
some packages may be behind so there is

00:31:15,279 --> 00:31:19,279
always this risk

00:31:17,760 --> 00:31:20,799
so it's not like in dragon rest

00:31:19,279 --> 00:31:21,760
framework when where a lot of

00:31:20,799 --> 00:31:25,519
functionality is

00:31:21,760 --> 00:31:28,000
provided by the framework itself um

00:31:25,519 --> 00:31:29,919
another disadvantage of of graphene and

00:31:28,000 --> 00:31:32,320
this this stack is that there is

00:31:29,919 --> 00:31:33,440
not much uh not many good learning

00:31:32,320 --> 00:31:35,600
resources

00:31:33,440 --> 00:31:37,600
unfortunately documentation of graphene

00:31:35,600 --> 00:31:40,799
is not the best one

00:31:37,600 --> 00:31:42,000
when you stumble upon some troubles some

00:31:40,799 --> 00:31:43,679
harder problems

00:31:42,000 --> 00:31:45,840
you often need to read the source code

00:31:43,679 --> 00:31:46,320
which is also not the easiest one to

00:31:45,840 --> 00:31:49,279
read

00:31:46,320 --> 00:31:50,159
the source code of graphene i mean so

00:31:49,279 --> 00:31:53,039
definitely

00:31:50,159 --> 00:31:53,360
uh yeah you need to spend some time if

00:31:53,039 --> 00:31:55,360
you

00:31:53,360 --> 00:31:56,960
if you have some difficult problems with

00:31:55,360 --> 00:31:58,880
with implementation

00:31:56,960 --> 00:32:00,080
also the roadmap of graphene is a little

00:31:58,880 --> 00:32:02,399
bit uncertain

00:32:00,080 --> 00:32:03,600
and there is new version coming but it's

00:32:02,399 --> 00:32:05,760
i'm not sure if

00:32:03,600 --> 00:32:07,360
there is any release date and i'm not

00:32:05,760 --> 00:32:09,039
sure if all of the features will be

00:32:07,360 --> 00:32:10,320
supported there there are some features

00:32:09,039 --> 00:32:13,120
missing in the

00:32:10,320 --> 00:32:15,519
uh in graphene that are available in

00:32:13,120 --> 00:32:17,840
other implementations of graphql servers

00:32:15,519 --> 00:32:20,720
in other languages

00:32:17,840 --> 00:32:22,480
so do we have any other options uh yes

00:32:20,720 --> 00:32:25,360
there are other libraries

00:32:22,480 --> 00:32:27,360
for example ariadna this is a completely

00:32:25,360 --> 00:32:29,120
different philosophy because ariana is a

00:32:27,360 --> 00:32:32,240
schema first library

00:32:29,120 --> 00:32:33,679
um so in this in this library we first

00:32:32,240 --> 00:32:35,919
built the schema then we built the

00:32:33,679 --> 00:32:38,480
python functions to fulfill the schema

00:32:35,919 --> 00:32:40,159
but it's really useful when you want to

00:32:38,480 --> 00:32:41,120
use subscriptions because it's fully

00:32:40,159 --> 00:32:42,799
asynchronous

00:32:41,120 --> 00:32:45,200
it has first class support for those

00:32:42,799 --> 00:32:46,799
subscriptions uh it provides whiskey and

00:32:45,200 --> 00:32:50,080
asking views for django

00:32:46,799 --> 00:32:50,799
uh so it's there are no those mappings

00:32:50,080 --> 00:32:52,559
from models

00:32:50,799 --> 00:32:54,960
uh two types for example you need to

00:32:52,559 --> 00:32:56,720
build them by hand

00:32:54,960 --> 00:32:58,559
but still you can use that we've junk as

00:32:56,720 --> 00:33:00,640
well what is very nice about this

00:32:58,559 --> 00:33:02,080
package is that it has very active

00:33:00,640 --> 00:33:04,000
community on spectrum

00:33:02,080 --> 00:33:05,679
actually currently this one is the

00:33:04,000 --> 00:33:08,559
second most popular after graphene when

00:33:05,679 --> 00:33:10,799
you look at github stars

00:33:08,559 --> 00:33:11,840
so that's that's all i've got for you i

00:33:10,799 --> 00:33:14,080
hope you enjoyed the

00:33:11,840 --> 00:33:15,919
presentation if you have any questions

00:33:14,080 --> 00:33:18,880
i'll be available on slack

00:33:15,919 --> 00:33:19,600
uh you can also uh i i think we have

00:33:18,880 --> 00:33:21,679
still some

00:33:19,600 --> 00:33:23,600
time for questions now you can also find

00:33:21,679 --> 00:33:26,240
me on twitter or email me

00:33:23,600 --> 00:33:26,240
thanks a lot

00:33:35,840 --> 00:33:39,840
big problem for me

00:33:40,080 --> 00:33:46,799
and one big problem uh i had was

00:33:43,519 --> 00:33:49,919
like some some of my logic

00:33:46,799 --> 00:33:50,559
was in separate uh functions because i

00:33:49,919 --> 00:33:52,159
wanted to

00:33:50,559 --> 00:33:53,760
like so my business logic to be

00:33:52,159 --> 00:33:57,279
somewhere else not in the

00:33:53,760 --> 00:34:00,320
uh objects uh

00:33:57,279 --> 00:34:04,320
and it made it very difficult to debug

00:34:00,320 --> 00:34:07,360
because graphene just doesn't let

00:34:04,320 --> 00:34:09,919
the error to be thrown so it never gave

00:34:07,360 --> 00:34:13,119
gave me a 500 for example

00:34:09,919 --> 00:34:16,560
uh so it it captures their errors

00:34:13,119 --> 00:34:17,200
uh and uh i get the results saying that

00:34:16,560 --> 00:34:20,320
this

00:34:17,200 --> 00:34:23,919
error in that line uh

00:34:20,320 --> 00:34:26,480
but it it doesn't even say uh which file

00:34:23,919 --> 00:34:27,119
it is in so it says well there's a error

00:34:26,480 --> 00:34:30,560
in line

00:34:27,119 --> 00:34:31,520
10 and i'm what okay cool but in like

00:34:30,560 --> 00:34:34,639
the end of like

00:34:31,520 --> 00:34:35,440
which which file so it made me really

00:34:34,639 --> 00:34:37,520
really

00:34:35,440 --> 00:34:38,800
hard to debug because like there's a

00:34:37,520 --> 00:34:40,960
type error but

00:34:38,800 --> 00:34:41,839
well where in my logic there's a type

00:34:40,960 --> 00:34:44,079
error

00:34:41,839 --> 00:34:45,599
so i don't know if i was just doing

00:34:44,079 --> 00:34:49,119
something

00:34:45,599 --> 00:34:52,240
wrong or if there's a solution for that

00:34:49,119 --> 00:34:54,320
uh actually there

00:34:52,240 --> 00:34:55,679
so i think it's a problem in graphene in

00:34:54,320 --> 00:34:58,480
the default implementation

00:34:55,679 --> 00:35:00,240
of the graphql view but what we did in

00:34:58,480 --> 00:35:00,720
our project that we used in production

00:35:00,240 --> 00:35:03,520
we

00:35:00,720 --> 00:35:04,320
created our own version of that view

00:35:03,520 --> 00:35:07,440
basically

00:35:04,320 --> 00:35:09,520
overreading it and i'm just trying to

00:35:07,440 --> 00:35:11,040
look at where do we have it in the code

00:35:09,520 --> 00:35:15,280
but

00:35:11,040 --> 00:35:17,760
there is a way to write your own

00:35:15,280 --> 00:35:19,920
error handler or something like that so

00:35:17,760 --> 00:35:22,400
basically the default one as you say

00:35:19,920 --> 00:35:23,920
catch all the errors and it's not very

00:35:22,400 --> 00:35:27,040
useful

00:35:23,920 --> 00:35:29,200
uh i need to find that in the code uh

00:35:27,040 --> 00:35:30,480
let me give you one second but i'm

00:35:29,200 --> 00:35:32,640
pretty sure that we need to

00:35:30,480 --> 00:35:34,480
we needed to customize it a little bit

00:35:32,640 --> 00:35:38,160
actually we are using graphene but

00:35:34,480 --> 00:35:38,960
uh we have a lot of small customizations

00:35:38,160 --> 00:35:42,640
here and there

00:35:38,960 --> 00:35:43,520
and this is one example um to handle

00:35:42,640 --> 00:35:45,359
errors so

00:35:43,520 --> 00:35:47,040
yeah i agree that's in the default

00:35:45,359 --> 00:35:50,400
implementation of graphene is

00:35:47,040 --> 00:35:52,800
it's not the best one um

00:35:50,400 --> 00:35:52,800
actually

00:35:54,079 --> 00:36:00,880
i can probably send you a link to

00:35:58,160 --> 00:36:02,480
make sure some links in this call i

00:36:00,880 --> 00:36:05,680
don't know

00:36:02,480 --> 00:36:09,359
there's a chat here

00:36:05,680 --> 00:36:13,200
i think slack would work too yeah yeah

00:36:09,359 --> 00:36:17,359
so maybe i'll show slack in a moment but

00:36:13,200 --> 00:36:17,359
if i find it quickly on github uh

00:36:17,680 --> 00:36:25,520
view because we do have that in our

00:36:22,320 --> 00:36:28,640
code which is only entirely and

00:36:25,520 --> 00:36:32,000
maybe that would help and

00:36:28,640 --> 00:36:41,839
yeah i've had i guess get it

00:36:32,000 --> 00:36:41,839
thermal link so where is the chat here

00:36:45,440 --> 00:36:49,839
i think ice cream is delicious because i

00:36:47,359 --> 00:36:52,839
cannot find

00:36:49,839 --> 00:36:55,839
well alright i can thank you later uh

00:36:52,839 --> 00:36:55,839
just

00:36:57,760 --> 00:37:01,040
the chat link is there in the left

00:36:59,359 --> 00:37:03,280
corner yeah

00:37:01,040 --> 00:37:04,160
yeah so here's the link uh you can take

00:37:03,280 --> 00:37:06,880
a look at

00:37:04,160 --> 00:37:09,040
what we are doing in our project so this

00:37:06,880 --> 00:37:09,920
is basically our own version of graphql

00:37:09,040 --> 00:37:12,960
view

00:37:09,920 --> 00:37:15,119
um it's like

00:37:12,960 --> 00:37:17,359
extended version of what the default one

00:37:15,119 --> 00:37:21,280
does and over there we have the

00:37:17,359 --> 00:37:23,280
for example error handling um

00:37:21,280 --> 00:37:25,920
we have some additional features like

00:37:23,280 --> 00:37:26,640
for example for monitoring our api we

00:37:25,920 --> 00:37:29,359
also have

00:37:26,640 --> 00:37:31,280
we are using open tracing uh which is a

00:37:29,359 --> 00:37:34,240
nice protocol for monitoring

00:37:31,280 --> 00:37:36,320
um your apps and uh we do have those

00:37:34,240 --> 00:37:37,040
open tracing tags over there so whenever

00:37:36,320 --> 00:37:40,160
a

00:37:37,040 --> 00:37:42,480
graphql request is starting we can uh

00:37:40,160 --> 00:37:44,000
mark where it starts and when it ends so

00:37:42,480 --> 00:37:45,200
then we can measure performance of that

00:37:44,000 --> 00:37:48,079
query for example

00:37:45,200 --> 00:37:50,079
so you can look at those examples uh

00:37:48,079 --> 00:37:52,480
what we implemented there for

00:37:50,079 --> 00:37:56,000
what i said it's a little bit customized

00:37:52,480 --> 00:37:56,000
version of graphene

00:38:02,839 --> 00:38:07,440
cool

00:38:04,240 --> 00:38:10,079
any other questions uh

00:38:07,440 --> 00:38:10,480
yeah probably uh probably i would start

00:38:10,079 --> 00:38:13,119
um

00:38:10,480 --> 00:38:13,680
so hit marcin uh can you hear me yes yes

00:38:13,119 --> 00:38:15,839
um

00:38:13,680 --> 00:38:16,720
cool yeah so first of all thank you for

00:38:15,839 --> 00:38:19,440
the for the

00:38:16,720 --> 00:38:21,200
amazing speech it was really nice and

00:38:19,440 --> 00:38:23,920
nice to hear about the graphical

00:38:21,200 --> 00:38:25,200
implementations so yeah um we've been

00:38:23,920 --> 00:38:27,119
following uh

00:38:25,200 --> 00:38:29,119
your sailor implementation of graphql

00:38:27,119 --> 00:38:31,119
for maybe over a year since we're using

00:38:29,119 --> 00:38:34,560
that kernel case technologies for

00:38:31,119 --> 00:38:35,520
almost a year already but yeah we also

00:38:34,560 --> 00:38:39,200
had a lot of

00:38:35,520 --> 00:38:40,960
cones and pros uh when compared to the

00:38:39,200 --> 00:38:42,720
rest framework but probably

00:38:40,960 --> 00:38:44,960
what was always a question for me from

00:38:42,720 --> 00:38:47,520
this from the sale or implementation

00:38:44,960 --> 00:38:49,119
um do you have any plans on maybe

00:38:47,520 --> 00:38:51,680
providing your custom

00:38:49,119 --> 00:38:53,119
implementations abstractions file

00:38:51,680 --> 00:38:56,800
uploaders and so on

00:38:53,119 --> 00:38:59,200
which maybe on on the development phase

00:38:56,800 --> 00:39:00,320
might require a lot of time to find a

00:38:59,200 --> 00:39:02,880
proper solution

00:39:00,320 --> 00:39:04,079
but maybe it had did you had any plans

00:39:02,880 --> 00:39:06,480
you know on providing that

00:39:04,079 --> 00:39:07,920
as a as a library you know as a maybe

00:39:06,480 --> 00:39:09,359
some implementation which for example

00:39:07,920 --> 00:39:11,359
would be used by your project

00:39:09,359 --> 00:39:14,560
but also available for public access and

00:39:11,359 --> 00:39:17,440
public implementations

00:39:14,560 --> 00:39:19,359
yes we had some discussions about that

00:39:17,440 --> 00:39:20,560
unfortunately because the team behind

00:39:19,359 --> 00:39:22,800
sailor is not that big

00:39:20,560 --> 00:39:24,000
uh in fact we are just a bunch of

00:39:22,800 --> 00:39:26,000
developers and we

00:39:24,000 --> 00:39:27,760
were always so busy with developing

00:39:26,000 --> 00:39:29,680
stuff at failure that

00:39:27,760 --> 00:39:31,359
maybe we had no time to actually provide

00:39:29,680 --> 00:39:34,320
the pull request to graphene but

00:39:31,359 --> 00:39:35,200
probably and that would be the best idea

00:39:34,320 --> 00:39:37,920
um

00:39:35,200 --> 00:39:40,880
you know at some point uh i was a bit

00:39:37,920 --> 00:39:43,280
skeptical about about graphene because

00:39:40,880 --> 00:39:44,880
this project uh was maintained by one

00:39:43,280 --> 00:39:48,240
person at some point

00:39:44,880 --> 00:39:50,720
and then this person like stopped

00:39:48,240 --> 00:39:52,320
maintaining it and there was huge

00:39:50,720 --> 00:39:52,960
discussion whether it will be maintained

00:39:52,320 --> 00:39:54,400
anymore

00:39:52,960 --> 00:39:56,240
and now there are there is a group of

00:39:54,400 --> 00:39:59,520
people and i remember that

00:39:56,240 --> 00:40:00,720
uh there was this transition between

00:39:59,520 --> 00:40:03,040
those maintainers

00:40:00,720 --> 00:40:04,079
and at that time we had many questions

00:40:03,040 --> 00:40:06,160
about graphene

00:40:04,079 --> 00:40:07,440
we were opening some issues on github

00:40:06,160 --> 00:40:10,079
and there were like

00:40:07,440 --> 00:40:12,240
sometimes without any response and i saw

00:40:10,079 --> 00:40:14,400
also that sample requests were

00:40:12,240 --> 00:40:16,079
uh you know they were they were not

00:40:14,400 --> 00:40:19,599
merging many pull requests from

00:40:16,079 --> 00:40:21,839
from the community so you know it

00:40:19,599 --> 00:40:24,319
like i felt that it's it's not really

00:40:21,839 --> 00:40:24,800
well maintained at that point and now

00:40:24,319 --> 00:40:29,200
maybe

00:40:24,800 --> 00:40:32,160
when the graphene version 3 comes out

00:40:29,200 --> 00:40:33,760
maybe it would be easier then so

00:40:32,160 --> 00:40:35,520
definitely that would be useful for the

00:40:33,760 --> 00:40:37,119
community

00:40:35,520 --> 00:40:39,760
because graphene is still the most

00:40:37,119 --> 00:40:42,640
popular graphical framework for

00:40:39,760 --> 00:40:43,839
python so for example we could abstract

00:40:42,640 --> 00:40:46,480
away our model

00:40:43,839 --> 00:40:48,720
mutation implementation so we have our

00:40:46,480 --> 00:40:51,280
our own abstraction to build mutations

00:40:48,720 --> 00:40:52,640
from models and it's you know it's also

00:40:51,280 --> 00:40:55,200
very customized for our

00:40:52,640 --> 00:40:57,119
for our needs and it would probably

00:40:55,200 --> 00:40:57,520
require some time to make it you know

00:40:57,119 --> 00:41:00,640
more

00:40:57,520 --> 00:41:02,800
universal um but

00:41:00,640 --> 00:41:03,920
yeah i i i need to think about that and

00:41:02,800 --> 00:41:05,280
write that down because

00:41:03,920 --> 00:41:07,119
it's it's nice that you're saying that

00:41:05,280 --> 00:41:08,000
you're uh looking at sailor as an

00:41:07,119 --> 00:41:10,480
example

00:41:08,000 --> 00:41:11,760
because when we started building uh our

00:41:10,480 --> 00:41:13,440
api there were

00:41:11,760 --> 00:41:16,079
i couldn't find any examples of a

00:41:13,440 --> 00:41:19,200
graphql api in graphing it would be

00:41:16,079 --> 00:41:19,920
let's say production ready only what i

00:41:19,200 --> 00:41:23,359
could found to

00:41:19,920 --> 00:41:26,800
find was some you know sample projects

00:41:23,359 --> 00:41:28,480
so yeah maybe that would be a nice

00:41:26,800 --> 00:41:30,480
nice inspiration for me to actually

00:41:28,480 --> 00:41:32,800
start thinking about abstracting

00:41:30,480 --> 00:41:34,720
some things away because we are gonna

00:41:32,800 --> 00:41:36,480
use graphene probably for for some time

00:41:34,720 --> 00:41:37,520
we are not thinking about migrating to

00:41:36,480 --> 00:41:41,520
something else

00:41:37,520 --> 00:41:41,520
although the ariana library that i've

00:41:46,839 --> 00:41:49,839
presented

00:41:52,480 --> 00:41:54,560

YouTube URL: https://www.youtube.com/watch?v=GoGpjngDB7c


